Project Path: arc_IChooseYou_Reclass_s_nzegas

Source Tree:

```txt
arc_IChooseYou_Reclass_s_nzegas
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake
│   ├── FindQScintilla.cmake
│   ├── FindQt5.cmake
│   └── deploy.cmake
├── deploy
│   └── Reclass.desktop
├── docs
│   ├── README_PIC1.png
│   ├── README_PIC2.png
│   ├── README_PIC3.png
│   ├── RECLASS_DARKMODE.svg
│   └── RECLASS_LIGHTMODE.svg
├── plugins
│   ├── ProcessMemory
│   │   ├── CMakeLists.txt
│   │   ├── ProcessMemoryPlugin.cpp
│   │   └── ProcessMemoryPlugin.h
│   ├── RcNetPluginCompatLayer
│   │   ├── CMakeLists.txt
│   │   ├── ClrHost.cpp
│   │   ├── ClrHost.h
│   │   ├── RcNetCompatPlugin.cpp
│   │   ├── RcNetCompatPlugin.h
│   │   ├── RcNetCompatProvider.cpp
│   │   ├── RcNetCompatProvider.h
│   │   ├── ReClassNET_Plugin.hpp
│   │   └── bridge
│   │       ├── RcNetBridge.cs
│   │       └── RcNetBridge.csproj
│   ├── RemoteProcessMemory
│   │   ├── CMakeLists.txt
│   │   ├── RemoteProcessMemoryPlugin.cpp
│   │   ├── RemoteProcessMemoryPlugin.h
│   │   ├── payload
│   │   │   └── rcx_payload.cpp
│   │   ├── rcx_rpc_protocol.h
│   │   └── tests
│   │       ├── test_rpc_client.cpp
│   │       └── test_rpc_host.cpp
│   └── WinDbgMemory
│       ├── CMakeLists.txt
│       ├── WinDbgMemoryPlugin.cpp
│       └── WinDbgMemoryPlugin.h
├── scripts
│   ├── build.ps1
│   └── build_qscintilla.ps1
├── src
│   ├── addressparser.cpp
│   ├── addressparser.h
│   ├── app.rc
│   ├── compose.cpp
│   ├── controller.cpp
│   ├── controller.h
│   ├── core.h
│   ├── disasm.cpp
│   ├── disasm.h
│   ├── editor.cpp
│   ├── editor.h
│   ├── examples
│   │   ├── EPROCESS.rcx
│   │   ├── KUSER_SHARED_DATA.rcx
│   │   └── MMPFN.rcx
│   ├── fonts
│   │   └── JetBrainsMono.ttf
│   ├── format.cpp
│   ├── generator.cpp
│   ├── generator.h
│   ├── icons
│   │   ├── chevron-down.png
│   │   ├── chevron-right.png
│   │   ├── class.ico
│   │   ├── class.png
│   │   └── close.png
│   ├── imports
│   │   ├── export_reclass_xml.cpp
│   │   ├── export_reclass_xml.h
│   │   ├── import_pdb.cpp
│   │   ├── import_pdb.h
│   │   ├── import_pdb_dialog.cpp
│   │   ├── import_pdb_dialog.h
│   │   ├── import_reclass_xml.cpp
│   │   ├── import_reclass_xml.h
│   │   ├── import_source.cpp
│   │   └── import_source.h
│   ├── iplugin.h
│   ├── main.cpp
│   ├── mainwindow.h
│   ├── mcp
│   │   ├── mcp_bridge.cpp
│   │   └── mcp_bridge.h
│   ├── optionsdialog.cpp
│   ├── optionsdialog.h
│   ├── pluginmanager.cpp
│   ├── pluginmanager.h
│   ├── processpicker.cpp
│   ├── processpicker.h
│   ├── processpicker.ui
│   ├── providerregistry.cpp
│   ├── providerregistry.h
│   ├── providers
│   │   ├── buffer_provider.h
│   │   ├── null_provider.h
│   │   ├── provider.h
│   │   └── snapshot_provider.h
│   ├── resources.qrc
│   ├── themes
│   │   ├── defaults
│   │   │   ├── mid.json
│   │   │   ├── reclass_dark.json
│   │   │   ├── vs.json
│   │   │   └── warm.json
│   │   ├── theme.cpp
│   │   ├── theme.h
│   │   ├── themeeditor.cpp
│   │   ├── themeeditor.h
│   │   ├── thememanager.cpp
│   │   └── thememanager.h
│   ├── titlebar.cpp
│   ├── titlebar.h
│   ├── typeselectorpopup.cpp
│   ├── typeselectorpopup.h
│   ├── vsicons
│   │   ├── LICENSE-CODE.txt
│   │   ├── account.svg
│   │   ├── activate-breakpoints.svg
│   │   ├── add.svg
│   │   ├── archive.svg
│   │   ├── arrow-both.svg
│   │   ├── arrow-down.svg
│   │   ├── arrow-left.svg
│   │   ├── arrow-right.svg
│   │   ├── arrow-small-down.svg
│   │   ├── arrow-small-left.svg
│   │   ├── arrow-small-right.svg
│   │   ├── arrow-small-up.svg
│   │   ├── arrow-up.svg
│   │   ├── beaker.svg
│   │   ├── bell-dot.svg
│   │   ├── bell.svg
│   │   ├── blocked.svg
│   │   ├── bold.svg
│   │   ├── book.svg
│   │   ├── bookmark.svg
│   │   ├── briefcase.svg
│   │   ├── broadcast.svg
│   │   ├── browser.svg
│   │   ├── bug.svg
│   │   ├── build.svg
│   │   ├── calendar.svg
│   │   ├── call-incoming.svg
│   │   ├── call-outgoing.svg
│   │   ├── case-sensitive.svg
│   │   ├── check.svg
│   │   ├── checklist.svg
│   │   ├── chevron-down.svg
│   │   ├── chevron-left.svg
│   │   ├── chevron-right.svg
│   │   ├── chevron-up.svg
│   │   ├── chrome-close.svg
│   │   ├── chrome-maximize.svg
│   │   ├── chrome-minimize.svg
│   │   ├── chrome-restore.svg
│   │   ├── circle-filled.svg
│   │   ├── circle-outline.svg
│   │   ├── circle-slash.svg
│   │   ├── circuit-board.svg
│   │   ├── clear-all.svg
│   │   ├── clippy.svg
│   │   ├── close-all.svg
│   │   ├── close.svg
│   │   ├── cloud-download.svg
│   │   ├── cloud-upload.svg
│   │   ├── cloud.svg
│   │   ├── code.svg
│   │   ├── collapse-all.svg
│   │   ├── color-mode.svg
│   │   ├── comment-discussion-quote.svg
│   │   ├── comment-discussion.svg
│   │   ├── comment.svg
│   │   ├── console.svg
│   │   ├── credit-card.svg
│   │   ├── dash.svg
│   │   ├── dashboard.svg
│   │   ├── database.svg
│   │   ├── debug-alt-small.svg
│   │   ├── debug-alt.svg
│   │   ├── debug-breakpoint-conditional-unverified.svg
│   │   ├── debug-breakpoint-conditional.svg
│   │   ├── debug-breakpoint-data-unverified.svg
│   │   ├── debug-breakpoint-data.svg
│   │   ├── debug-breakpoint-function-unverified.svg
│   │   ├── debug-breakpoint-function.svg
│   │   ├── debug-breakpoint-log-unverified.svg
│   │   ├── debug-breakpoint-log.svg
│   │   ├── debug-breakpoint-stackframe-active.svg
│   │   ├── debug-breakpoint-stackframe-dot.svg
│   │   ├── debug-breakpoint-stackframe.svg
│   │   ├── debug-breakpoint-unsupported.svg
│   │   ├── debug-console.svg
│   │   ├── debug-continue.svg
│   │   ├── debug-disconnect.svg
│   │   ├── debug-pause.svg
│   │   ├── debug-restart-frame.svg
│   │   ├── debug-restart.svg
│   │   ├── debug-reverse-continue.svg
│   │   ├── debug-start.svg
│   │   ├── debug-step-back.svg
│   │   ├── debug-step-into.svg
│   │   ├── debug-step-out.svg
│   │   ├── debug-step-over.svg
│   │   ├── debug-stop.svg
│   │   ├── debug.svg
│   │   ├── desktop-download.svg
│   │   ├── device-camera-video.svg
│   │   ├── device-camera.svg
│   │   ├── device-mobile.svg
│   │   ├── diff-added.svg
│   │   ├── diff-ignored.svg
│   │   ├── diff-modified.svg
│   │   ├── diff-removed.svg
│   │   ├── diff-renamed.svg
│   │   ├── diff.svg
│   │   ├── discard.svg
│   │   ├── edit.svg
│   │   ├── editor-layout.svg
│   │   ├── ellipsis.svg
│   │   ├── empty-window.svg
│   │   ├── error.svg
│   │   ├── exclude.svg
│   │   ├── expand-all.svg
│   │   ├── export.svg
│   │   ├── extensions.svg
│   │   ├── eye-closed.svg
│   │   ├── eye.svg
│   │   ├── feedback.svg
│   │   ├── file-binary.svg
│   │   ├── file-code.svg
│   │   ├── file-media.svg
│   │   ├── file-pdf.svg
│   │   ├── file-submodule.svg
│   │   ├── file-symlink-directory.svg
│   │   ├── file-symlink-file.svg
│   │   ├── file-zip.svg
│   │   ├── file.svg
│   │   ├── files.svg
│   │   ├── filter.svg
│   │   ├── flame.svg
│   │   ├── fold-down.svg
│   │   ├── fold-up.svg
│   │   ├── fold.svg
│   │   ├── folder-active.svg
│   │   ├── folder-opened.svg
│   │   ├── folder.svg
│   │   ├── gear.svg
│   │   ├── gift.svg
│   │   ├── gist-secret.svg
│   │   ├── gist.svg
│   │   ├── git-commit.svg
│   │   ├── git-compare.svg
│   │   ├── git-merge.svg
│   │   ├── git-pull-request.svg
│   │   ├── github-action.svg
│   │   ├── github-inverted.svg
│   │   ├── globe.svg
│   │   ├── go-to-file.svg
│   │   ├── grabber.svg
│   │   ├── graph-left.svg
│   │   ├── graph.svg
│   │   ├── gripper.svg
│   │   ├── group-by-ref-type.svg
│   │   ├── heart.svg
│   │   ├── help.svg
│   │   ├── history.svg
│   │   ├── home.svg
│   │   ├── horizontal-rule.svg
│   │   ├── hubot.svg
│   │   ├── inbox.svg
│   │   ├── info.svg
│   │   ├── issue-closed.svg
│   │   ├── issue-reopened.svg
│   │   ├── issues.svg
│   │   ├── italic.svg
│   │   ├── jersey.svg
│   │   ├── json.svg
│   │   ├── kebab-vertical.svg
│   │   ├── key.svg
│   │   ├── law.svg
│   │   ├── library.svg
│   │   ├── lightbulb-autofix.svg
│   │   ├── lightbulb.svg
│   │   ├── link-external.svg
│   │   ├── link.svg
│   │   ├── list-filter.svg
│   │   ├── list-flat.svg
│   │   ├── list-ordered.svg
│   │   ├── list-selection.svg
│   │   ├── list-tree.svg
│   │   ├── list-unordered.svg
│   │   ├── loading.svg
│   │   ├── location.svg
│   │   ├── lock.svg
│   │   ├── magnet.svg
│   │   ├── mail-read.svg
│   │   ├── mail.svg
│   │   ├── markdown.svg
│   │   ├── megaphone.svg
│   │   ├── mention.svg
│   │   ├── menu.svg
│   │   ├── merge.svg
│   │   ├── milestone.svg
│   │   ├── mirror.svg
│   │   ├── more.svg
│   │   ├── mortar-board.svg
│   │   ├── move.svg
│   │   ├── multiple-windows.svg
│   │   ├── mute.svg
│   │   ├── new-file.svg
│   │   ├── new-folder.svg
│   │   ├── no-newline.svg
│   │   ├── note.svg
│   │   ├── octoface.svg
│   │   ├── open-preview.svg
│   │   ├── organization.svg
│   │   ├── output.svg
│   │   ├── package.svg
│   │   ├── paintcan.svg
│   │   ├── pass.svg
│   │   ├── person.svg
│   │   ├── pin.svg
│   │   ├── pinned.svg
│   │   ├── play-circle.svg
│   │   ├── plug.svg
│   │   ├── preserve-case.svg
│   │   ├── preview.svg
│   │   ├── primitive-square.svg
│   │   ├── project.svg
│   │   ├── pulse.svg
│   │   ├── question.svg
│   │   ├── quote.svg
│   │   ├── quotes.svg
│   │   ├── radio-tower.svg
│   │   ├── reactions.svg
│   │   ├── record-keys.svg
│   │   ├── record-start.svg
│   │   ├── record-stop.svg
│   │   ├── record.svg
│   │   ├── references.svg
│   │   ├── refresh.svg
│   │   ├── regex.svg
│   │   ├── remote-explorer.svg
│   │   ├── remote.svg
│   │   ├── remove.svg
│   │   ├── rename.svg
│   │   ├── replace-all.svg
│   │   ├── replace.svg
│   │   ├── reply.svg
│   │   ├── repo-clone.svg
│   │   ├── repo-force-push.svg
│   │   ├── repo-forked.svg
│   │   ├── repo-pull.svg
│   │   ├── repo-push.svg
│   │   ├── repo.svg
│   │   ├── report.svg
│   │   ├── request-changes.svg
│   │   ├── rocket.svg
│   │   ├── root-folder-opened.svg
│   │   ├── root-folder.svg
│   │   ├── rss.svg
│   │   ├── ruby.svg
│   │   ├── run-above.svg
│   │   ├── run-all.svg
│   │   ├── run-below.svg
│   │   ├── run.svg
│   │   ├── save-all.svg
│   │   ├── save-as.svg
│   │   ├── save.svg
│   │   ├── screen-full.svg
│   │   ├── screen-normal.svg
│   │   ├── search-stop.svg
│   │   ├── search.svg
│   │   ├── server-environment.svg
│   │   ├── server-process.svg
│   │   ├── server.svg
│   │   ├── settings-gear.svg
│   │   ├── settings.svg
│   │   ├── shield.svg
│   │   ├── sign-in.svg
│   │   ├── sign-out.svg
│   │   ├── smiley.svg
│   │   ├── sort-precedence.svg
│   │   ├── source-control.svg
│   │   ├── split-horizontal.svg
│   │   ├── split-vertical.svg
│   │   ├── squirrel.svg
│   │   ├── star-empty.svg
│   │   ├── star-full.svg
│   │   ├── star-half.svg
│   │   ├── stop-circle.svg
│   │   ├── symbol-array.svg
│   │   ├── symbol-boolean.svg
│   │   ├── symbol-class.svg
│   │   ├── symbol-color.svg
│   │   ├── symbol-constant.svg
│   │   ├── symbol-enum-member.svg
│   │   ├── symbol-enum.svg
│   │   ├── symbol-event.svg
│   │   ├── symbol-field.svg
│   │   ├── symbol-file.svg
│   │   ├── symbol-interface.svg
│   │   ├── symbol-key.svg
│   │   ├── symbol-keyword.svg
│   │   ├── symbol-method.svg
│   │   ├── symbol-misc.svg
│   │   ├── symbol-namespace.svg
│   │   ├── symbol-numeric.svg
│   │   ├── symbol-operator.svg
│   │   ├── symbol-parameter.svg
│   │   ├── symbol-property.svg
│   │   ├── symbol-ruler.svg
│   │   ├── symbol-snippet.svg
│   │   ├── symbol-string.svg
│   │   ├── symbol-structure.svg
│   │   ├── symbol-variable.svg
│   │   ├── sync-ignored.svg
│   │   ├── sync.svg
│   │   ├── tag.svg
│   │   ├── tasklist.svg
│   │   ├── telescope.svg
│   │   ├── terminal.svg
│   │   ├── text-size.svg
│   │   ├── three-bars.svg
│   │   ├── thumbsdown.svg
│   │   ├── thumbsup.svg
│   │   ├── tools.svg
│   │   ├── trash.svg
│   │   ├── triangle-down.svg
│   │   ├── triangle-left.svg
│   │   ├── triangle-right.svg
│   │   ├── triangle-up.svg
│   │   ├── twitter.svg
│   │   ├── unfold.svg
│   │   ├── ungroup-by-ref-type.svg
│   │   ├── unlock.svg
│   │   ├── unmute.svg
│   │   ├── unverified.svg
│   │   ├── verified.svg
│   │   ├── versions.svg
│   │   ├── vm-active.svg
│   │   ├── vm-connect.svg
│   │   ├── vm-outline.svg
│   │   ├── vm-pending.svg
│   │   ├── vm-running.svg
│   │   ├── vm.svg
│   │   ├── warning.svg
│   │   ├── watch.svg
│   │   ├── whitespace.svg
│   │   ├── whole-word.svg
│   │   ├── window.svg
│   │   ├── word-wrap.svg
│   │   ├── zoom-in.svg
│   │   └── zoom-out.svg
│   └── workspace_model.h
├── tests
│   ├── bench_import_pdb.cpp
│   ├── test_addressparser.cpp
│   ├── test_command_row.cpp
│   ├── test_compose.cpp
│   ├── test_context_menu.cpp
│   ├── test_controller.cpp
│   ├── test_core.cpp
│   ├── test_dbgconnect.cpp
│   ├── test_disasm.cpp
│   ├── test_editor.cpp
│   ├── test_export_xml.cpp
│   ├── test_format.cpp
│   ├── test_generator.cpp
│   ├── test_import_pdb.cpp
│   ├── test_import_source.cpp
│   ├── test_import_xml.cpp
│   ├── test_new_features.cpp
│   ├── test_options_dialog.cpp
│   ├── test_provider.cpp
│   ├── test_provider_getSymbol.cpp
│   ├── test_rendered_view.cpp
│   ├── test_source_management.cpp
│   ├── test_theme.cpp
│   ├── test_type_selector.cpp
│   ├── test_type_visibility.cpp
│   ├── test_validation.cpp
│   └── test_windbg_provider.cpp
├── third_party
│   ├── fadec
│   │   ├── CMakeLists.txt
│   │   ├── LICENSE
│   │   ├── README.md
│   │   ├── decode-test.c
│   │   ├── decode.c
│   │   ├── encode-test.c
│   │   ├── encode-test.inc
│   │   ├── encode.c
│   │   ├── encode2-test.c
│   │   ├── encode2-test.cc
│   │   ├── encode2.c
│   │   ├── fadec-decode-private.inc
│   │   ├── fadec-decode-public.inc
│   │   ├── fadec-enc.h
│   │   ├── fadec-enc2.h
│   │   ├── fadec.h
│   │   ├── format.c
│   │   ├── instrs.txt
│   │   ├── meson.build
│   │   ├── meson_options.txt
│   │   └── parseinstrs.py
│   ├── qscintilla
│   └── raw_pdb
│       ├── CMakeLists.txt
│       ├── LICENSE
│       ├── README.md
│       ├── raw_pdb.natvis
│       └── src
│           ├── CMakeLists.txt
│           ├── Examples
│           │   ├── CMakeLists.txt
│           │   ├── ExampleContributions.cpp
│           │   ├── ExampleFunctionSymbols.cpp
│           │   ├── ExampleFunctionVariables.cpp
│           │   ├── ExampleIPI.cpp
│           │   ├── ExampleLines.cpp
│           │   ├── ExampleMain.cpp
│           │   ├── ExampleMemoryMappedFile.cpp
│           │   ├── ExampleMemoryMappedFile.h
│           │   ├── ExamplePDBSize.cpp
│           │   ├── ExampleSymbols.cpp
│           │   ├── ExampleTimedScope.cpp
│           │   ├── ExampleTimedScope.h
│           │   ├── ExampleTypeTable.cpp
│           │   ├── ExampleTypeTable.h
│           │   ├── ExampleTypes.cpp
│           │   ├── Examples_PCH.cpp
│           │   └── Examples_PCH.h
│           ├── Foundation
│           │   ├── PDB_ArrayView.h
│           │   ├── PDB_Assert.h
│           │   ├── PDB_BitOperators.h
│           │   ├── PDB_BitUtil.h
│           │   ├── PDB_CRT.h
│           │   ├── PDB_Forward.h
│           │   ├── PDB_Log.h
│           │   ├── PDB_Macros.h
│           │   ├── PDB_Memory.h
│           │   ├── PDB_Move.h
│           │   ├── PDB_Platform.h
│           │   ├── PDB_PointerUtil.h
│           │   ├── PDB_TypeTraits.h
│           │   └── PDB_Warnings.h
│           ├── PDB.cpp
│           ├── PDB.h
│           ├── PDB_CoalescedMSFStream.cpp
│           ├── PDB_CoalescedMSFStream.h
│           ├── PDB_DBIStream.cpp
│           ├── PDB_DBIStream.h
│           ├── PDB_DBITypes.cpp
│           ├── PDB_DBITypes.h
│           ├── PDB_DirectMSFStream.cpp
│           ├── PDB_DirectMSFStream.h
│           ├── PDB_ErrorCodes.h
│           ├── PDB_GlobalSymbolStream.cpp
│           ├── PDB_GlobalSymbolStream.h
│           ├── PDB_IPIStream.cpp
│           ├── PDB_IPIStream.h
│           ├── PDB_IPITypes.h
│           ├── PDB_ImageSectionStream.cpp
│           ├── PDB_ImageSectionStream.h
│           ├── PDB_InfoStream.cpp
│           ├── PDB_InfoStream.h
│           ├── PDB_ModuleInfoStream.cpp
│           ├── PDB_ModuleInfoStream.h
│           ├── PDB_ModuleLineStream.cpp
│           ├── PDB_ModuleLineStream.h
│           ├── PDB_ModuleSymbolStream.cpp
│           ├── PDB_ModuleSymbolStream.h
│           ├── PDB_NamesStream.cpp
│           ├── PDB_NamesStream.h
│           ├── PDB_PCH.cpp
│           ├── PDB_PCH.h
│           ├── PDB_PublicSymbolStream.cpp
│           ├── PDB_PublicSymbolStream.h
│           ├── PDB_RawFile.cpp
│           ├── PDB_RawFile.h
│           ├── PDB_SectionContributionStream.cpp
│           ├── PDB_SectionContributionStream.h
│           ├── PDB_SourceFileStream.cpp
│           ├── PDB_SourceFileStream.h
│           ├── PDB_TPIStream.cpp
│           ├── PDB_TPIStream.h
│           ├── PDB_TPITypes.h
│           ├── PDB_Types.cpp
│           ├── PDB_Types.h
│           └── PDB_Util.h
└── tools
    ├── rcx-mcp-stdio.cpp
    └── test_hover.py

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(Reclass VERSION 0.1 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_C_STANDARD 11)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")

# Find Qt6 or Qt5 (config mode first, then FindQt5.cmake module for auto-download)
set(_QT_COMPONENTS Core Widgets PrintSupport Svg Concurrent Network)
find_package(QT NAMES Qt6 Qt5 COMPONENTS ${_QT_COMPONENTS} QUIET)
if(NOT QT_FOUND)
    find_package(Qt5 REQUIRED COMPONENTS ${_QT_COMPONENTS})
    set(QT_VERSION_MAJOR 5)
endif()
# The NAMES variant only detects the version; load the actual component targets
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS ${_QT_COMPONENTS})
set(QT Qt${QT_VERSION_MAJOR})
message(STATUS "Using ${QT}: ${${QT}_DIR}")

# Qt5 on Windows needs WinExtras for HICON conversion
set(_QT_WINEXTRAS "")
if(QT_VERSION_MAJOR EQUAL 5 AND WIN32)
    find_package(Qt5 REQUIRED COMPONENTS WinExtras)
    set(_QT_WINEXTRAS Qt5::WinExtras)
endif()

find_package(QScintilla REQUIRED)

# RawPDB — direct PDB file reader (no DIA SDK / msdia140.dll dependency)
file(GLOB RAW_PDB_SRCS third_party/raw_pdb/src/*.cpp)
add_library(raw_pdb STATIC ${RAW_PDB_SRCS})
target_include_directories(raw_pdb PUBLIC third_party/raw_pdb/src)
target_compile_features(raw_pdb PRIVATE cxx_std_11)
if(WIN32)
    target_link_libraries(raw_pdb PRIVATE rpcrt4)
endif()

add_executable(Reclass
    src/main.cpp
    src/editor.h
    src/editor.cpp
    src/controller.h
    src/controller.cpp
    src/compose.cpp
    src/format.cpp
    src/generator.h
    src/generator.cpp
    src/processpicker.h
    src/processpicker.cpp
    src/processpicker.ui
    src/resources.qrc
    src/core.h
    src/workspace_model.h
    src/providers/buffer_provider.h src/providers/null_provider.h src/providers/provider.h src/providers/snapshot_provider.h
    src/providerregistry.cpp
    src/providerregistry.h
    src/pluginmanager.cpp
    src/pluginmanager.h
    src/typeselectorpopup.h
    src/typeselectorpopup.cpp
    src/themes/theme.h
    src/themes/theme.cpp
    src/themes/thememanager.h
    src/themes/thememanager.cpp
    src/themes/themeeditor.h
    src/themes/themeeditor.cpp
    src/imports/import_reclass_xml.h
    src/imports/import_reclass_xml.cpp
    src/imports/import_source.h
    src/imports/import_source.cpp
    src/imports/export_reclass_xml.h
    src/imports/export_reclass_xml.cpp
    src/imports/import_pdb.h
    src/imports/import_pdb.cpp
    src/imports/import_pdb_dialog.h
    src/imports/import_pdb_dialog.cpp
    src/mainwindow.h
    src/optionsdialog.h
    src/optionsdialog.cpp
    src/titlebar.h
    src/titlebar.cpp
    src/mcp/mcp_bridge.h
    src/mcp/mcp_bridge.cpp
    src/addressparser.h
    src/addressparser.cpp
    src/disasm.h
    src/disasm.cpp
    third_party/fadec/decode.c
    third_party/fadec/format.c
    $<$<PLATFORM_ID:Windows>:src/app.rc>
)

target_include_directories(Reclass PRIVATE src third_party/fadec)

target_link_libraries(Reclass PRIVATE
    ${QT}::Widgets
    ${QT}::PrintSupport
    ${QT}::Svg
    ${QT}::Concurrent
    ${QT}::Network
    QScintilla::QScintilla
    ${_QT_WINEXTRAS}
)
if(WIN32)
    target_link_libraries(Reclass PRIVATE dbghelp dwmapi psapi raw_pdb)
endif()

add_executable(ReclassMcpBridge tools/rcx-mcp-stdio.cpp)
target_link_libraries(ReclassMcpBridge PRIVATE ${QT}::Core ${QT}::Network)

# Copy built-in theme JSON files to build directory
file(GLOB _theme_files "${CMAKE_SOURCE_DIR}/src/themes/defaults/*.json")
file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/themes")
foreach(_tf ${_theme_files})
    get_filename_component(_name ${_tf} NAME)
    configure_file(${_tf} "${CMAKE_BINARY_DIR}/themes/${_name}" COPYONLY)
endforeach()

# Copy example .rcx files to build directory
file(GLOB _example_files "${CMAKE_SOURCE_DIR}/src/examples/*.rcx")
file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/examples")
foreach(_ef ${_example_files})
    get_filename_component(_name ${_ef} NAME)
    configure_file(${_ef} "${CMAKE_BINARY_DIR}/examples/${_name}" COPYONLY)
endforeach()

include(deploy)


set(_combine_script "${CMAKE_BINARY_DIR}/combine_sources.cmake")
file(WRITE ${_combine_script} "
set(_out \"${CMAKE_BINARY_DIR}/h_cpp_combined.txt\")
file(WRITE \${_out} \"\")
foreach(_f
    \"${CMAKE_SOURCE_DIR}/src/core.h\"
    \"${CMAKE_SOURCE_DIR}/src/editor.h\"
    \"${CMAKE_SOURCE_DIR}/src/editor.cpp\"
    \"${CMAKE_SOURCE_DIR}/src/controller.h\"
    \"${CMAKE_SOURCE_DIR}/src/controller.cpp\"
    \"${CMAKE_SOURCE_DIR}/src/compose.cpp\"
    \"${CMAKE_SOURCE_DIR}/src/format.cpp\"
    \"${CMAKE_SOURCE_DIR}/src/generator.cpp\"
    \"${CMAKE_SOURCE_DIR}/src/main.cpp\")
    file(READ \${_f} _content)
    file(APPEND \${_out} \"\${_content}\")
    file(APPEND \${_out} \"\\n\")
endforeach()
message(STATUS \"Combined sources -> \${_out}\")
")

add_custom_target(combined ALL
    COMMAND ${CMAKE_COMMAND} -P ${_combine_script}
    DEPENDS Reclass
    COMMENT "Combining all source files into h_cpp_combined.txt"
)

include(CTest)
if(BUILD_TESTING)
    find_package(${QT} REQUIRED COMPONENTS Test)
    enable_testing()

    # Disasm/Fadec sources needed by any test that links editor.cpp
    set(DISASM_SRCS src/disasm.cpp third_party/fadec/decode.c third_party/fadec/format.c)

    # ── Headless tests (Qt::Core only — safe for CI without a display) ──

    add_executable(test_core tests/test_core.cpp src/format.cpp src/compose.cpp src/addressparser.cpp)
    target_include_directories(test_core PRIVATE src)
    target_link_libraries(test_core PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_core COMMAND test_core)

    add_executable(test_format tests/test_format.cpp src/format.cpp src/addressparser.cpp)
    target_include_directories(test_format PRIVATE src)
    target_link_libraries(test_format PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_format COMMAND test_format)

    add_executable(test_compose tests/test_compose.cpp src/compose.cpp src/format.cpp src/addressparser.cpp)
    target_include_directories(test_compose PRIVATE src)
    target_link_libraries(test_compose PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_compose COMMAND test_compose)

    add_executable(test_provider tests/test_provider.cpp)
    target_include_directories(test_provider PRIVATE src)
    target_link_libraries(test_provider PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_provider COMMAND test_provider)

    add_executable(test_command_row tests/test_command_row.cpp)
    target_include_directories(test_command_row PRIVATE src)
    target_link_libraries(test_command_row PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_command_row COMMAND test_command_row)

    add_executable(test_generator tests/test_generator.cpp
        src/generator.cpp src/compose.cpp src/format.cpp src/addressparser.cpp)
    target_include_directories(test_generator PRIVATE src)
    target_link_libraries(test_generator PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_generator COMMAND test_generator)

    add_executable(test_import_xml tests/test_import_xml.cpp
        src/imports/import_reclass_xml.cpp src/format.cpp src/compose.cpp src/addressparser.cpp)
    target_include_directories(test_import_xml PRIVATE src)
    target_link_libraries(test_import_xml PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_import_xml COMMAND test_import_xml)

    add_executable(test_import_source tests/test_import_source.cpp
        src/imports/import_source.cpp src/format.cpp src/compose.cpp src/addressparser.cpp)
    target_include_directories(test_import_source PRIVATE src)
    target_link_libraries(test_import_source PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_import_source COMMAND test_import_source)

    add_executable(test_export_xml tests/test_export_xml.cpp
        src/imports/export_reclass_xml.cpp src/imports/import_reclass_xml.cpp src/format.cpp src/compose.cpp src/addressparser.cpp)
    target_include_directories(test_export_xml PRIVATE src)
    target_link_libraries(test_export_xml PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_export_xml COMMAND test_export_xml)

    add_executable(test_disasm tests/test_disasm.cpp
        src/disasm.cpp src/compose.cpp src/format.cpp src/addressparser.cpp
        third_party/fadec/decode.c third_party/fadec/format.c)
    target_include_directories(test_disasm PRIVATE src third_party/fadec)
    target_link_libraries(test_disasm PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_disasm COMMAND test_disasm)

    add_executable(test_addressparser tests/test_addressparser.cpp src/addressparser.cpp)
    target_include_directories(test_addressparser PRIVATE src)
    target_link_libraries(test_addressparser PRIVATE ${QT}::Core ${QT}::Test)
    add_test(NAME test_addressparser COMMAND test_addressparser)

    if(WIN32)
        add_executable(test_import_pdb tests/test_import_pdb.cpp
            src/imports/import_pdb.cpp src/format.cpp src/compose.cpp src/addressparser.cpp)
        target_include_directories(test_import_pdb PRIVATE src)
        target_link_libraries(test_import_pdb PRIVATE
            ${QT}::Core ${QT}::Test raw_pdb)
        add_test(NAME test_import_pdb COMMAND test_import_pdb)

        add_executable(bench_import_pdb tests/bench_import_pdb.cpp
            src/imports/import_pdb.cpp src/format.cpp src/compose.cpp src/addressparser.cpp)
        target_include_directories(bench_import_pdb PRIVATE src)
        target_link_libraries(bench_import_pdb PRIVATE
            ${QT}::Core ${QT}::Test raw_pdb)
        add_test(NAME bench_import_pdb COMMAND bench_import_pdb)
    endif()

    # ── UI tests (require Qt::Widgets / QScintilla / display — skip on headless CI) ──
    option(BUILD_UI_TESTS "Build tests that require a display (Qt Widgets)" ON)
    if(BUILD_UI_TESTS)

    add_executable(test_controller tests/test_controller.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_controller PRIVATE src third_party/fadec)
    target_link_libraries(test_controller PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_controller PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_controller COMMAND test_controller)

    add_executable(test_validation tests/test_validation.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_validation PRIVATE src third_party/fadec)
    target_link_libraries(test_validation PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_validation PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_validation COMMAND test_validation)

    add_executable(test_context_menu tests/test_context_menu.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_context_menu PRIVATE src third_party/fadec)
    target_link_libraries(test_context_menu PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_context_menu PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_context_menu COMMAND test_context_menu)

    add_executable(test_source_management tests/test_source_management.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_source_management PRIVATE src third_party/fadec)
    target_link_libraries(test_source_management PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_source_management PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_source_management COMMAND test_source_management)

    add_executable(test_editor tests/test_editor.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp
        src/providerregistry.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_editor PRIVATE src third_party/fadec)
    target_link_libraries(test_editor PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Test
        QScintilla::QScintilla)
    add_test(NAME test_editor COMMAND test_editor)

    add_executable(test_rendered_view tests/test_rendered_view.cpp
        src/generator.cpp src/compose.cpp src/format.cpp src/addressparser.cpp)
    target_include_directories(test_rendered_view PRIVATE src)
    target_link_libraries(test_rendered_view PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Test
        QScintilla::QScintilla)
    add_test(NAME test_rendered_view COMMAND test_rendered_view)

    add_executable(test_new_features tests/test_new_features.cpp
        src/generator.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/editor.cpp src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_new_features PRIVATE src third_party/fadec)
    target_link_libraries(test_new_features PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_new_features PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_new_features COMMAND test_new_features)

    add_executable(test_type_selector tests/test_type_selector.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_type_selector PRIVATE src third_party/fadec)
    target_link_libraries(test_type_selector PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_type_selector PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_type_selector COMMAND test_type_selector)

    add_executable(test_type_visibility tests/test_type_visibility.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(test_type_visibility PRIVATE src third_party/fadec)
    target_link_libraries(test_type_visibility PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_type_visibility PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_type_visibility COMMAND test_type_visibility)

    add_executable(test_options_dialog tests/test_options_dialog.cpp
        src/optionsdialog.cpp src/themes/theme.cpp src/themes/thememanager.cpp)
    target_include_directories(test_options_dialog PRIVATE src)
    target_link_libraries(test_options_dialog PRIVATE ${QT}::Widgets ${QT}::Test)
    add_test(NAME test_options_dialog COMMAND test_options_dialog)

    add_executable(test_source_provider tests/test_source_provider.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp src/controller.cpp
        src/processpicker.cpp src/processpicker.ui src/providerregistry.cpp
        src/typeselectorpopup.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS}
        src/resources.qrc)
    target_include_directories(test_source_provider PRIVATE src third_party/fadec)
    target_link_libraries(test_source_provider PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test ${QT}::Svg
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(test_source_provider PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME test_source_provider COMMAND test_source_provider)

    if(WIN32)
        add_executable(test_windbg_provider tests/test_windbg_provider.cpp
            plugins/WinDbgMemory/WinDbgMemoryPlugin.cpp)
        target_include_directories(test_windbg_provider PRIVATE src plugins/WinDbgMemory)
        target_link_libraries(test_windbg_provider PRIVATE
            ${QT}::Widgets ${QT}::Concurrent ${QT}::Test dbgeng ole32)
        add_test(NAME test_windbg_provider COMMAND test_windbg_provider)
    endif()

    add_executable(bench_large_class tests/bench_large_class.cpp
        src/editor.cpp src/compose.cpp src/format.cpp src/addressparser.cpp
        src/providerregistry.cpp
        src/themes/theme.cpp src/themes/thememanager.cpp ${DISASM_SRCS})
    target_include_directories(bench_large_class PRIVATE src third_party/fadec)
    target_link_libraries(bench_large_class PRIVATE
        ${QT}::Widgets ${QT}::PrintSupport ${QT}::Concurrent ${QT}::Test
        QScintilla::QScintilla)
    if(WIN32)
        target_link_libraries(bench_large_class PRIVATE dbghelp psapi ${_QT_WINEXTRAS})
    endif()
    add_test(NAME bench_large_class COMMAND bench_large_class)

    # Deploy Qt runtime DLLs for tests (run windeployqt on a representative test exe
    # that links the broadest set of Qt modules; all test exes share the same output dir)
    if(TARGET ${QT}::windeployqt)
        add_custom_target(deploy_tests ALL
            COMMAND $<TARGET_FILE:${QT}::windeployqt>
                --no-compiler-runtime --no-translations
                --no-opengl-sw --no-system-d3d-compiler
                $<TARGET_FILE:test_controller>
            DEPENDS test_controller
            COMMENT "Deploying Qt runtime DLLs for tests..."
        )
    endif()

    endif() # BUILD_UI_TESTS
endif()
add_subdirectory(plugins/ProcessMemory)
add_subdirectory(plugins/RemoteProcessMemory)
if(WIN32)
    add_subdirectory(plugins/WinDbgMemory)
    add_subdirectory(plugins/RcNetPluginCompatLayer)
endif()

```

`LICENSE`:

```
MIT License


Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<div align="center">

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="docs/RECLASS_LIGHTMODE.svg" height="170">
  <img src="docs/RECLASS_DARKMODE.svg" alt="Reclass" height="170" />
</picture>

**A structured binary editor for reverse engineering — inspect raw bytes as typed structs, arrays, and pointers.<p>A complete overhaul of the popular "reclassing" tools**

[Download](https://github.com/IChooseYou/Reclass/releases) · [Build Instructions](#build) · [MCP Integration](#mcp-integration) · [Alternatives](#alternatives)

[![Build](https://github.com/IChooseYou/Reclass/actions/workflows/build.yml/badge.svg)](https://github.com/IChooseYou/Reclass/actions/workflows/build.yml)
[![License](https://img.shields.io/github/license/IChooseYou/Reclass)](LICENSE)
[![Release](https://img.shields.io/github/v/release/IChooseYou/Reclass?label=snapshot)](https://github.com/IChooseYou/Reclass/releases)
[![Platform](https://img.shields.io/badge/platform-Windows%20%7C%20Linux-blue)]()

</div>

---

Reclass helps you inspect raw bytes and interpret them as types (structs, arrays, primitives, pointers, padding) instead of just hex. It is essentially a debugging tool for figuring out unknown data structures — either at runtime from a live process, or from a static source like a binary file or crash dump.

Built with C++17, Qt 6, and QScintilla. The entire editor surface is rendered as formatted plain text with inline editing, fold markers, and hex/ASCII previews.

---

## Features

- **Structured binary view** — render raw bytes as typed fields (integers, floats, pointers, vectors, matrices, strings, booleans, padding)
- **Struct & array nesting** — define nested structs and arrays with collapsible fold regions
- **Inline editing** — click to edit type names, field names, values, and base addresses directly in the editor
- **Undo/redo** — full undo history for all mutations via command stack
- **Split views** — multiple synchronized editor panes over the same document
- **Type autocomplete** — popup type picker when changing field kinds
- **Hex + ASCII margins** — raw byte previews alongside the structured view
- **MCP bridge** — expose all tool functionality to AI clients via Model Context Protocol
- **Plugin system** — extend with custom data source providers via DLL plugins; following ship by default
  - **Process plugin** — access memory of live processes on Windows and Linux
  - **WinDbg plugin** — access data sources live in WinDbg debugging sessions
  - **ReClass.NET compatibility layer** — load existing .NET and native ReClass.NET plugins

---

## Roadmap

- [ ] Process memory section enumeration
- [ ] Address parser auto-complete
- [ ] Safe mode
- [ ] File import for other Reclass instances
- [ ] Expose UI functionality to plugins
- [ ] iOS/macOS support
- [ ] Display RTTI information

---

## Data Sources

- **File** — open any binary file and inspect its contents as structured data
- **Process** — attach to a live process and read its memory in real time
- **Remote Process** — read another process's memory via shared memory
- **WinDbg** — load `.dmp` crash dump files or connect to live debugging sessions

---

## Screenshots

![Type chooser and struct inspection](docs/README_PIC1.png)

![VTable pointer expansion with disassembly preview](docs/README_PIC2.png)

![Split view with rendered C/C++ output](docs/README_PIC3.png)

---

## MCP Integration

Built-in [Model Context Protocol](https://modelcontextprotocol.io/) bridge via `ReclassMcpBridge`. The server does not start by default and can be toggled from the File menu. It exposes all tool functionality to any MCP-compatible client (e.g. Claude Code) and falls back to UI prompts when the client requests something not yet covered by tools. To connect, add this to your MCP client config (e.g. `.mcp.json`):

```json
{
  "mcpServers": {
    "ReclassMcpBridge": {
      "command": "path/to/build/ReclassMcpBridge",
      "args": []
    }
  }
}
```

---

## Build

### Prerequisites

- **Qt 6** with MinGW — [Qt Online Installer](https://doc.qt.io/qt-6/qt-online-installation.html) (select MinGW kit + CMake/Ninja from the Tools section)
- **CMake 3.20+** — [cmake.org](https://cmake.org/download/) (bundled with Qt)
- **Ninja** — bundled with the Qt installer

### Quick Build

```bash
git clone --recurse-submodules https://github.com/IChooseYou/Reclass.git
cd Reclass
.\scripts\build_qscintilla.ps1
.\scripts\build.ps1
```

The build script auto-detects your Qt install location.

### Manual Build

1. Clone with `--recurse-submodules` (or run `git submodule update --init --recursive` after cloning)
2. Build QScintilla: `qmake` + `mingw32-make` in `third_party/qscintilla/src`
3. Configure and build:
   ```bash
   cmake -B build -G Ninja -DCMAKE_PREFIX_PATH=/path/to/Qt/6.x.x/mingw_64
   cmake --build build
   ```
4. Optionally run `windeployqt` on the output executable

### Running Tests

```bash
ctest --test-dir build --output-on-failure
```

---

## Alternatives

- [ReClass.NET](https://github.com/ReClassNET/ReClass.NET)
- [ReClassEx](https://github.com/ajkhoury/ReClassEx)

---

<div align="center">
<sub>MIT License</sub>
</div>

```

`cmake/FindQScintilla.cmake`:

```cmake
set(_QSCI_ROOT "${CMAKE_SOURCE_DIR}/third_party/qscintilla")

# Try to find a pre-built library first
find_path(QScintilla_INCLUDE_DIR
    NAMES Qsci/qsciscintilla.h
    PATHS "${_QSCI_ROOT}/src" "${_QSCI_ROOT}/include"
    NO_DEFAULT_PATH
)

find_library(QScintilla_LIBRARY
    NAMES
        qscintilla2_qt${QT_VERSION_MAJOR} libqscintilla2_qt${QT_VERSION_MAJOR}
        qscintilla2_qt6 libqscintilla2_qt6
        qscintilla2_qt5 libqscintilla2_qt5
    PATHS
        "${_QSCI_ROOT}/src/release"
        "${_QSCI_ROOT}/src"
        "${_QSCI_ROOT}/lib"
    NO_DEFAULT_PATH
)

if(QScintilla_LIBRARY AND QScintilla_INCLUDE_DIR)
    # Use pre-built library
    include(FindPackageHandleStandardArgs)
    find_package_handle_standard_args(QScintilla DEFAULT_MSG
        QScintilla_LIBRARY QScintilla_INCLUDE_DIR)
    if(NOT TARGET QScintilla::QScintilla)
        add_library(QScintilla::QScintilla STATIC IMPORTED)
        set_target_properties(QScintilla::QScintilla PROPERTIES
            IMPORTED_LOCATION "${QScintilla_LIBRARY}"
            INTERFACE_INCLUDE_DIRECTORIES "${QScintilla_INCLUDE_DIR}"
        )
    endif()
elseif(EXISTS "${_QSCI_ROOT}/src/qsciscintilla.cpp")
    # Build from source
    message(STATUS "Building QScintilla from source")

    file(GLOB _QSCI_LEXER_SOURCES "${_QSCI_ROOT}/scintilla/lexers/*.cpp")
    file(GLOB _QSCI_LEXLIB_SOURCES "${_QSCI_ROOT}/scintilla/lexlib/*.cpp")
    file(GLOB _QSCI_SCI_SOURCES "${_QSCI_ROOT}/scintilla/src/*.cpp")
    file(GLOB _QSCI_HEADERS "${_QSCI_ROOT}/src/Qsci/*.h")

    set(_QSCI_QT_SOURCES
        "${_QSCI_ROOT}/src/qsciscintilla.cpp"
        "${_QSCI_ROOT}/src/qsciscintillabase.cpp"
        "${_QSCI_ROOT}/src/qsciabstractapis.cpp"
        "${_QSCI_ROOT}/src/qsciapis.cpp"
        "${_QSCI_ROOT}/src/qscicommand.cpp"
        "${_QSCI_ROOT}/src/qscicommandset.cpp"
        "${_QSCI_ROOT}/src/qscidocument.cpp"
        "${_QSCI_ROOT}/src/qscilexer.cpp"
        "${_QSCI_ROOT}/src/qscilexerasm.cpp"
        "${_QSCI_ROOT}/src/qscilexeravs.cpp"
        "${_QSCI_ROOT}/src/qscilexerbash.cpp"
        "${_QSCI_ROOT}/src/qscilexerbatch.cpp"
        "${_QSCI_ROOT}/src/qscilexercmake.cpp"
        "${_QSCI_ROOT}/src/qscilexercoffeescript.cpp"
        "${_QSCI_ROOT}/src/qscilexercpp.cpp"
        "${_QSCI_ROOT}/src/qscilexercsharp.cpp"
        "${_QSCI_ROOT}/src/qscilexercss.cpp"
        "${_QSCI_ROOT}/src/qscilexercustom.cpp"
        "${_QSCI_ROOT}/src/qscilexerd.cpp"
        "${_QSCI_ROOT}/src/qscilexerdiff.cpp"
        "${_QSCI_ROOT}/src/qscilexeredifact.cpp"
        "${_QSCI_ROOT}/src/qscilexerfortran.cpp"
        "${_QSCI_ROOT}/src/qscilexerfortran77.cpp"
        "${_QSCI_ROOT}/src/qscilexerhex.cpp"
        "${_QSCI_ROOT}/src/qscilexerhtml.cpp"
        "${_QSCI_ROOT}/src/qscilexeridl.cpp"
        "${_QSCI_ROOT}/src/qscilexerintelhex.cpp"
        "${_QSCI_ROOT}/src/qscilexerjava.cpp"
        "${_QSCI_ROOT}/src/qscilexerjavascript.cpp"
        "${_QSCI_ROOT}/src/qscilexerjson.cpp"
        "${_QSCI_ROOT}/src/qscilexerlua.cpp"
        "${_QSCI_ROOT}/src/qscilexermakefile.cpp"
        "${_QSCI_ROOT}/src/qscilexermarkdown.cpp"
        "${_QSCI_ROOT}/src/qscilexermasm.cpp"
        "${_QSCI_ROOT}/src/qscilexermatlab.cpp"
        "${_QSCI_ROOT}/src/qscilexernasm.cpp"
        "${_QSCI_ROOT}/src/qscilexeroctave.cpp"
        "${_QSCI_ROOT}/src/qscilexerpascal.cpp"
        "${_QSCI_ROOT}/src/qscilexerperl.cpp"
        "${_QSCI_ROOT}/src/qscilexerpostscript.cpp"
        "${_QSCI_ROOT}/src/qscilexerpo.cpp"
        "${_QSCI_ROOT}/src/qscilexerpov.cpp"
        "${_QSCI_ROOT}/src/qscilexerproperties.cpp"
        "${_QSCI_ROOT}/src/qscilexerpython.cpp"
        "${_QSCI_ROOT}/src/qscilexerruby.cpp"
        "${_QSCI_ROOT}/src/qscilexerspice.cpp"
        "${_QSCI_ROOT}/src/qscilexersql.cpp"
        "${_QSCI_ROOT}/src/qscilexersrec.cpp"
        "${_QSCI_ROOT}/src/qscilexertcl.cpp"
        "${_QSCI_ROOT}/src/qscilexertekhex.cpp"
        "${_QSCI_ROOT}/src/qscilexertex.cpp"
        "${_QSCI_ROOT}/src/qscilexerverilog.cpp"
        "${_QSCI_ROOT}/src/qscilexervhdl.cpp"
        "${_QSCI_ROOT}/src/qscilexerxml.cpp"
        "${_QSCI_ROOT}/src/qscilexeryaml.cpp"
        "${_QSCI_ROOT}/src/qscimacro.cpp"
        "${_QSCI_ROOT}/src/qsciprinter.cpp"
        "${_QSCI_ROOT}/src/qscistyle.cpp"
        "${_QSCI_ROOT}/src/qscistyledtext.cpp"
        "${_QSCI_ROOT}/src/InputMethod.cpp"
        "${_QSCI_ROOT}/src/ListBoxQt.cpp"
        "${_QSCI_ROOT}/src/PlatQt.cpp"
        "${_QSCI_ROOT}/src/SciAccessibility.cpp"
        "${_QSCI_ROOT}/src/SciClasses.cpp"
        "${_QSCI_ROOT}/src/ScintillaQt.cpp"
    )

    add_library(qscintilla2 STATIC
        ${_QSCI_QT_SOURCES}
        ${_QSCI_HEADERS}
        ${_QSCI_LEXER_SOURCES}
        ${_QSCI_LEXLIB_SOURCES}
        ${_QSCI_SCI_SOURCES}
    )

    target_include_directories(qscintilla2 PUBLIC
        "${_QSCI_ROOT}/src"
    )
    target_include_directories(qscintilla2 PRIVATE
        "${_QSCI_ROOT}/scintilla/include"
        "${_QSCI_ROOT}/scintilla/lexlib"
        "${_QSCI_ROOT}/scintilla/src"
    )

    target_compile_definitions(qscintilla2 PRIVATE
        SCINTILLA_QT
        SCI_LEXER
        INCLUDE_DEPRECATED_FEATURES
    )

    target_link_libraries(qscintilla2 PUBLIC
        ${QT}::Widgets
        ${QT}::PrintSupport
    )

    set_target_properties(qscintilla2 PROPERTIES AUTOMOC ON)

    add_library(QScintilla::QScintilla ALIAS qscintilla2)
    set(QScintilla_FOUND TRUE)
else()
    set(QScintilla_FOUND FALSE)
    if(QScintilla_FIND_REQUIRED)
        message(FATAL_ERROR "Could NOT find QScintilla (missing source and pre-built library)")
    endif()
endif()

```

`cmake/FindQt5.cmake`:

```cmake
# Documentation: https://cmake.org/cmake/help/latest/manual/cmake-developer.7.html#find-modules

# Always try config mode for the requested components (handles repeated calls)
find_package(Qt5 COMPONENTS ${Qt5_FIND_COMPONENTS} QUIET CONFIG)

if(Qt5_FOUND)
    if(NOT Qt5_FIND_QUIETLY)
        message(STATUS "Qt5 found: ${Qt5_DIR}")
    endif()
    return()
endif()

if(Qt5_FIND_REQUIRED AND WIN32)
    message(STATUS "Downloading Qt5...")
    # Fix warnings about DOWNLOAD_EXTRACT_TIMESTAMP
    if(POLICY CMP0135)
        cmake_policy(SET CMP0135 NEW)
    endif()
    include(FetchContent)
    set(FETCHCONTENT_QUIET OFF)
    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
        FetchContent_Declare(Qt5
            URL "https://github.com/x64dbg/deps/releases/download/2025.07.02/qt5.12.12-msvc2017_64.7z"
            URL_HASH SHA256=770490bf09514982c8192ebde9a1fac8821108ba42b021f167bac54e85ada48a
        )
    else()
        FetchContent_Declare(Qt5
            URL "https://github.com/x64dbg/deps/releases/download/2025.07.02/qt5.12.12-msvc2017.7z"
            URL_HASH SHA256=3ff2a58e5ed772be475643cd7bb2df3e5499d7169d794ddf1ed5df5c5e862cb6
        )
    endif()
    FetchContent_MakeAvailable(Qt5)
    unset(FETCHCONTENT_QUIET)
    set(Qt5_ROOT ${qt5_SOURCE_DIR})
    find_package(Qt5 COMPONENTS ${Qt5_FIND_COMPONENTS} CONFIG REQUIRED)
endif()

```

`cmake/deploy.cmake`:

```cmake
# cmake/deploy.cmake - Dual-mode script for deploying Qt runtime DLLs
#
# Script mode:  cmake -P deploy.cmake <target_exe> <windeployqt>
# Include mode: include(deploy) from CMakeLists.txt (creates "deploy" target)

if(CMAKE_SCRIPT_MODE_FILE)
    set(TARGET_EXE ${CMAKE_ARGV3})
    set(WINDEPLOYQT ${CMAKE_ARGV4})
    get_filename_component(TARGET_DIR ${TARGET_EXE} DIRECTORY)

    # Skip if already deployed for this build
    if(EXISTS "${TARGET_DIR}/.qt_deployed")
        return()
    endif()

    message(STATUS "Running windeployqt on ${TARGET_EXE}")

    execute_process(
        COMMAND ${WINDEPLOYQT}
            --pdb
            --no-compiler-runtime
            --no-translations
            --no-opengl-sw
            --no-system-d3d-compiler
            --force
            ${TARGET_EXE}
        RESULT_VARIABLE _result
    )

    if(_result EQUAL 0)
        file(WRITE "${TARGET_DIR}/.qt_deployed" "")
        message(STATUS "windeployqt completed successfully")
    else()
        message(WARNING "windeployqt failed with exit code ${_result}")
    endif()

    return()
endif()

# ── Include mode: configure the deploy target ──

if(NOT WIN32)
    return()
endif()

# Discover windeployqt from qmake
if(NOT TARGET ${QT}::windeployqt AND TARGET ${QT}::qmake)
    get_target_property(_qt_qmake_location ${QT}::qmake IMPORTED_LOCATION)

    execute_process(
        COMMAND "${_qt_qmake_location}" -query QT_INSTALL_PREFIX
        RESULT_VARIABLE _return_code
        OUTPUT_VARIABLE _qt_install_prefix
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )

    set(_windeployqt "${_qt_install_prefix}/bin/windeployqt.exe")
    if(EXISTS ${_windeployqt})
        add_executable(${QT}::windeployqt IMPORTED)
        set_target_properties(${QT}::windeployqt PROPERTIES
            IMPORTED_LOCATION ${_windeployqt}
        )
        message(STATUS "Found windeployqt: ${_windeployqt}")
    else()
        message(WARNING "windeployqt not found at ${_windeployqt}")
    endif()
endif()

if(TARGET ${QT}::windeployqt)
    add_custom_target(deploy
        COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_LIST_DIR}/deploy.cmake
            $<TARGET_FILE:Reclass>
            $<TARGET_FILE:${QT}::windeployqt>
        DEPENDS Reclass
        COMMENT "Deploying Qt runtime DLLs..."
    )

    # Force re-deploy on rebuild
    set_target_properties(deploy PROPERTIES
        ADDITIONAL_CLEAN_FILES $<TARGET_FILE_DIR:Reclass>/.qt_deployed
    )
endif()

```

`deploy/Reclass.desktop`:

```desktop
[Desktop Entry]
Type=Application
Name=Reclass
Comment=Memory structure reverse engineering tool
Exec=Reclass
Icon=reclass
Categories=Development;Debugger;
Terminal=false

```

`docs/RECLASS_DARKMODE.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Ebene_1" data-name="Ebene 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 186.01 52.79">
  <defs>
    <style>
      .cls-1 {
        fill: url(#Unbenannter_Verlauf_130-2);
      }

      .cls-2 {
        fill: url(#Unbenannter_Verlauf_236-2);
      }

      .cls-3 {
        fill: url(#Unbenannter_Verlauf_225-2);
      }

      .cls-4 {
        fill: #1f2939;
      }

      .cls-5 {
        fill: #5d9bd4;
      }

      .cls-6 {
        fill: #1e3e88;
      }

      .cls-7 {
        fill: #6e809a;
      }

      .cls-8 {
        fill: url(#Unbenannter_Verlauf_225);
      }

      .cls-9 {
        fill: url(#Unbenannter_Verlauf_236);
      }

      .cls-10 {
        fill: url(#Unbenannter_Verlauf_130);
      }

      .cls-11 {
        fill: url(#Unbenannter_Verlauf_170);
      }

      .cls-12 {
        fill: url(#Unbenannter_Verlauf_161);
      }

      .cls-13 {
        fill: url(#Unbenannter_Verlauf_183);
      }

      .cls-14 {
        fill: #b06ba9;
      }

      .cls-15 {
        fill: #826415;
      }

      .cls-16 {
        fill: #e2aa11;
      }

      .cls-17 {
        fill: #893089;
      }
    </style>
    <linearGradient id="Unbenannter_Verlauf_161" data-name="Unbenannter Verlauf 161" x1="8.33" y1="8.33" x2="18.11" y2="18.11" gradientTransform="translate(13.22 -5.47) rotate(45)" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#f3db78"/>
      <stop offset=".19" stop-color="#f4e188"/>
      <stop offset=".34" stop-color="#f4e38d"/>
      <stop offset=".38" stop-color="#f4df81"/>
      <stop offset=".47" stop-color="#f5d86f"/>
      <stop offset=".57" stop-color="#f5d463"/>
      <stop offset=".67" stop-color="#f6d360"/>
      <stop offset=".89" stop-color="#f1cc53"/>
      <stop offset="1" stop-color="#efbe33"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_130" data-name="Unbenannter Verlauf 130" x1=".41" y1="15.46" x2="10.98" y2="26.03" gradientTransform="translate(-4.95 39.45) rotate(-135)" gradientUnits="userSpaceOnUse">
      <stop offset=".18" stop-color="#e2aa11"/>
      <stop offset=".91" stop-color="#826415"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_130-2" data-name="Unbenannter Verlauf 130" x1="15.46" y1=".41" x2="26.03" y2="10.98" gradientTransform="translate(31.39 24.39) rotate(-135)" xlink:href="#Unbenannter_Verlauf_130"/>
    <linearGradient id="Unbenannter_Verlauf_170" data-name="Unbenannter Verlauf 170" x1="34.97" y1="15.65" x2="42.34" y2="23.02" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#deb0d3"/>
      <stop offset=".15" stop-color="#e1b5d6"/>
      <stop offset=".3" stop-color="#e3b8d7"/>
      <stop offset=".4" stop-color="#d7a8cd"/>
      <stop offset=".53" stop-color="#cf9cc7"/>
      <stop offset=".67" stop-color="#cd99c5"/>
      <stop offset=".89" stop-color="#c68abc"/>
      <stop offset="1" stop-color="#bb7db4"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_225" data-name="Unbenannter Verlauf 225" x1="28.78" y1="20.14" x2="36.87" y2="28.24" gradientTransform="translate(.63 .63) rotate(-.12) skewX(-.25)" gradientUnits="userSpaceOnUse">
      <stop offset=".19" stop-color="#b06ba9"/>
      <stop offset=".87" stop-color="#893089"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_225-2" data-name="Unbenannter Verlauf 225" x1="39.45" y1="9.43" x2="47.55" y2="17.53" xlink:href="#Unbenannter_Verlauf_225"/>
    <linearGradient id="Unbenannter_Verlauf_183" data-name="Unbenannter Verlauf 183" x1="34.88" y1="39.45" x2="42.29" y2="46.86" gradientTransform="translate(41.82 -14.64) rotate(45)" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#91c4eb"/>
      <stop offset=".2" stop-color="#9dc9ed"/>
      <stop offset=".33" stop-color="#96c6ec"/>
      <stop offset=".35" stop-color="#91c3ea"/>
      <stop offset=".45" stop-color="#7fb8e5"/>
      <stop offset=".56" stop-color="#73b2e2"/>
      <stop offset=".67" stop-color="#70b0e1"/>
      <stop offset=".89" stop-color="#60a7dc"/>
      <stop offset="1" stop-color="#4d9bd5"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_236" data-name="Unbenannter Verlauf 236" x1="28.83" y1="43.9" x2="36.92" y2="51.99" gradientTransform="translate(22.68 105.31) rotate(-135.12) skewX(-.25)" gradientUnits="userSpaceOnUse">
      <stop offset=".19" stop-color="#5d9bd4"/>
      <stop offset=".87" stop-color="#1e3e88"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_236-2" data-name="Unbenannter Verlauf 236" x1="39.51" y1="33.23" x2="47.59" y2="41.32" gradientTransform="translate(48.45 94.63) rotate(-135.12) skewX(-.25)" xlink:href="#Unbenannter_Verlauf_236"/>
  </defs>
  <g>
    <rect class="cls-7" x="22.48" y="16.85" width="1.76" height="25.1"/>
    <rect class="cls-7" x="17.08" y="16.85" width="19.7" height="1.82"/>
    <rect class="cls-7" x="22.48" y="40.19" width="11.9" height="1.76"/>
    <g>
      <rect class="cls-12" x="2.56" y="6.31" width="21.31" height="13.82" transform="translate(-5.48 13.22) rotate(-45)"/>
      <rect class="cls-15" x="17.52" y="6.88" width="1.15" height="22.44" transform="translate(18.1 -7.49) rotate(45)"/>
      <g>
        <rect class="cls-16" x="7.76" y="-2.88" width="1.15" height="22.44" transform="translate(8.34 -3.45) rotate(45)"/>
        <rect class="cls-10" x="5.12" y="13.27" width="1.15" height="14.95" transform="translate(24.39 31.39) rotate(135)"/>
        <rect class="cls-1" x="20.17" y="-1.78" width="1.15" height="14.95" transform="translate(39.45 -4.95) rotate(135)"/>
      </g>
    </g>
    <g>
      <polygon class="cls-11" points="40.33 10.29 29.64 21.02 36.98 28.38 47.67 17.66 40.33 10.29"/>
      <polygon class="cls-17" points="37.01 29.1 36.29 28.38 47.68 16.96 48.39 17.68 37.01 29.1"/>
      <polygon class="cls-14" points="29.67 21.74 28.95 21.02 40.34 9.6 41.05 10.31 29.67 21.74"/>
      <polygon class="cls-8" points="28.95 21.02 29.67 20.3 37.72 28.38 37 29.1 28.95 21.02"/>
      <polygon class="cls-3" points="39.63 10.31 40.34 9.6 48.39 17.67 47.68 18.39 39.63 10.31"/>
    </g>
    <g>
      <rect class="cls-13" x="30.96" y="37.92" width="15.26" height="10.48" transform="translate(-19.21 39.92) rotate(-45)"/>
      <g>
        <rect class="cls-9" x="32.83" y="42.71" width="1.01" height="11.38" transform="translate(91.13 59.06) rotate(135)"/>
        <rect class="cls-2" x="43.5" y="32.04" width="1.01" height="11.38" transform="translate(101.81 33.29) rotate(135)"/>
        <rect class="cls-6" x="41.84" y="38.69" width="1.01" height="16.1" transform="translate(45.45 -16.25) rotate(45)"/>
        <rect class="cls-5" x="34.5" y="31.35" width="1.01" height="16.1" transform="translate(38.11 -13.21) rotate(45)"/>
      </g>
    </g>
  </g>
  <g>
    <path class="cls-4" d="M53.66,30.51v11.46h-2.57v-25.13h9.36c5.04,0,7.72,2.72,7.72,6.65,0,3.22-1.89,5.26-4.51,5.89,2.34.58,4.09,2.2,4.09,6.5v1.02c0,1.74-.11,4.07.33,5.07h-2.54c-.46-1.08-.39-3.1-.39-5.34v-.6c0-3.87-1.12-5.52-5.79-5.52h-5.7ZM53.66,28.26h5.79c4.15,0,6.03-1.56,6.03-4.64,0-2.9-1.89-4.54-5.57-4.54h-6.25v9.18Z"/>
    <path class="cls-4" d="M86.55,29.87h-12.65v9.79h13.88l-.35,2.3h-16.06v-25.12h15.81v2.27h-13.28v8.49h12.65v2.27Z"/>
    <path class="cls-4" d="M109.12,35.04c-1.15,4.11-4.2,7.19-9.68,7.19-7.34,0-11.13-5.72-11.13-12.79s3.76-12.96,11.21-12.96c5.64,0,8.84,3.18,9.63,7.37h-2.56c-1.04-3.02-3.01-5.13-7.18-5.13-5.92,0-8.38,5.4-8.38,10.66s2.39,10.62,8.52,10.62c3.99,0,5.89-2.16,7.01-4.95h2.57Z"/>
    <path class="cls-4" d="M111.62,16.84h2.56v22.82h13.3l-.41,2.27h-15.46v-25.09Z"/>
    <path class="cls-4" d="M133.03,33.77l-2.97,8.16h-2.58l9.09-25.09h3.11l9.48,25.09h-2.76l-3.05-8.16h-10.32ZM142.61,31.5c-2.61-7.07-3.99-10.62-4.51-12.4h-.04c-.61,2-2.16,6.36-4.27,12.4h8.82Z"/>
    <path class="cls-4" d="M151.68,35.08c.72,3.19,2.87,5,6.77,5,4.28,0,5.95-2.09,5.95-4.65,0-2.69-1.25-4.29-6.55-5.59-5.58-1.38-7.76-3.23-7.76-6.81s2.56-6.55,8.04-6.55,8.11,3.41,8.44,6.57h-2.63c-.52-2.48-2.11-4.37-5.93-4.37-3.37,0-5.22,1.55-5.22,4.16s1.54,3.59,6.07,4.7c7.1,1.75,8.24,4.56,8.24,7.67,0,3.85-2.83,7.03-8.78,7.03-6.29,0-8.78-3.56-9.27-7.15h2.63Z"/>
    <path class="cls-4" d="M170.59,35.08c.72,3.19,2.87,5,6.77,5,4.28,0,5.95-2.09,5.95-4.65,0-2.69-1.25-4.29-6.55-5.59-5.58-1.38-7.76-3.23-7.76-6.81s2.56-6.55,8.04-6.55,8.11,3.41,8.44,6.57h-2.63c-.52-2.48-2.11-4.37-5.93-4.37-3.37,0-5.22,1.55-5.22,4.16s1.54,3.59,6.07,4.7c7.1,1.75,8.25,4.56,8.25,7.67,0,3.85-2.83,7.03-8.78,7.03-6.29,0-8.78-3.56-9.27-7.15h2.63Z"/>
  </g>
</svg>
```

`docs/RECLASS_LIGHTMODE.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Ebene_1" data-name="Ebene 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 185.55 52.66">
  <defs>
    <style>
      .cls-1 {
        fill: url(#Unbenannter_Verlauf_130-2);
      }

      .cls-2 {
        fill: url(#Unbenannter_Verlauf_236-2);
      }

      .cls-3 {
        fill: url(#Unbenannter_Verlauf_225-2);
      }

      .cls-4 {
        fill: #5d9bd4;
      }

      .cls-5 {
        fill: #e3e8f0;
      }

      .cls-6 {
        fill: #1e3e88;
      }

      .cls-7 {
        fill: #6e809a;
      }

      .cls-8 {
        fill: url(#Unbenannter_Verlauf_225);
      }

      .cls-9 {
        fill: url(#Unbenannter_Verlauf_236);
      }

      .cls-10 {
        fill: url(#Unbenannter_Verlauf_130);
      }

      .cls-11 {
        fill: url(#Unbenannter_Verlauf_170);
      }

      .cls-12 {
        fill: url(#Unbenannter_Verlauf_161);
      }

      .cls-13 {
        fill: url(#Unbenannter_Verlauf_183);
      }

      .cls-14 {
        fill: #b06ba9;
      }

      .cls-15 {
        fill: #826415;
      }

      .cls-16 {
        fill: #e2aa11;
      }

      .cls-17 {
        fill: #893089;
      }
    </style>
    <linearGradient id="Unbenannter_Verlauf_161" data-name="Unbenannter Verlauf 161" x1="8.31" y1="8.31" x2="18.06" y2="18.06" gradientTransform="translate(13.19 -5.46) rotate(45)" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#f3db78"/>
      <stop offset=".19" stop-color="#f4e188"/>
      <stop offset=".34" stop-color="#f4e38d"/>
      <stop offset=".38" stop-color="#f4df81"/>
      <stop offset=".47" stop-color="#f5d86f"/>
      <stop offset=".57" stop-color="#f5d463"/>
      <stop offset=".67" stop-color="#f6d360"/>
      <stop offset=".89" stop-color="#f1cc53"/>
      <stop offset="1" stop-color="#efbe33"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_130" data-name="Unbenannter Verlauf 130" x1=".41" y1="15.42" x2="10.95" y2="25.97" gradientTransform="translate(-4.94 39.35) rotate(-135)" gradientUnits="userSpaceOnUse">
      <stop offset=".18" stop-color="#e2aa11"/>
      <stop offset=".91" stop-color="#826415"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_130-2" data-name="Unbenannter Verlauf 130" x1="15.42" y1=".41" x2="25.97" y2="10.95" gradientTransform="translate(31.32 24.33) rotate(-135)" xlink:href="#Unbenannter_Verlauf_130"/>
    <linearGradient id="Unbenannter_Verlauf_170" data-name="Unbenannter Verlauf 170" x1="34.88" y1="15.61" x2="42.24" y2="22.97" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#deb0d3"/>
      <stop offset=".15" stop-color="#e1b5d6"/>
      <stop offset=".3" stop-color="#e3b8d7"/>
      <stop offset=".4" stop-color="#d7a8cd"/>
      <stop offset=".53" stop-color="#cf9cc7"/>
      <stop offset=".67" stop-color="#cd99c5"/>
      <stop offset=".89" stop-color="#c68abc"/>
      <stop offset="1" stop-color="#bb7db4"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_225" data-name="Unbenannter Verlauf 225" x1="28.7" y1="20.09" x2="36.78" y2="28.17" gradientTransform="translate(.63 .63) rotate(-.12) skewX(-.25)" gradientUnits="userSpaceOnUse">
      <stop offset=".19" stop-color="#b06ba9"/>
      <stop offset=".87" stop-color="#893089"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_225-2" data-name="Unbenannter Verlauf 225" x1="39.35" y1="9.41" x2="47.43" y2="17.49" xlink:href="#Unbenannter_Verlauf_225"/>
    <linearGradient id="Unbenannter_Verlauf_183" data-name="Unbenannter Verlauf 183" x1="34.79" y1="39.35" x2="42.18" y2="46.74" gradientTransform="translate(41.71 -14.61) rotate(45)" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#91c4eb"/>
      <stop offset=".2" stop-color="#9dc9ed"/>
      <stop offset=".33" stop-color="#96c6ec"/>
      <stop offset=".35" stop-color="#91c3ea"/>
      <stop offset=".45" stop-color="#7fb8e5"/>
      <stop offset=".56" stop-color="#73b2e2"/>
      <stop offset=".67" stop-color="#70b0e1"/>
      <stop offset=".89" stop-color="#60a7dc"/>
      <stop offset="1" stop-color="#4d9bd5"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_236" data-name="Unbenannter Verlauf 236" x1="28.76" y1="43.79" x2="36.83" y2="51.86" gradientTransform="translate(22.62 105.05) rotate(-135.12) skewX(-.25)" gradientUnits="userSpaceOnUse">
      <stop offset=".19" stop-color="#5d9bd4"/>
      <stop offset=".87" stop-color="#1e3e88"/>
    </linearGradient>
    <linearGradient id="Unbenannter_Verlauf_236-2" data-name="Unbenannter Verlauf 236" x1="39.41" y1="33.15" x2="47.47" y2="41.21" gradientTransform="translate(48.33 94.4) rotate(-135.12) skewX(-.25)" xlink:href="#Unbenannter_Verlauf_236"/>
  </defs>
  <g>
    <rect class="cls-7" x="22.43" y="16.81" width="1.75" height="25.04"/>
    <rect class="cls-7" x="17.04" y="16.81" width="19.66" height="1.82"/>
    <rect class="cls-7" x="22.43" y="40.09" width="11.87" height="1.75"/>
    <g>
      <rect class="cls-12" x="2.56" y="6.29" width="21.26" height="13.79" transform="translate(-5.46 13.19) rotate(-45)"/>
      <rect class="cls-15" x="17.48" y="6.87" width="1.15" height="22.38" transform="translate(18.06 -7.47) rotate(45)"/>
      <g>
        <rect class="cls-16" x="7.74" y="-2.87" width="1.15" height="22.38" transform="translate(8.32 -3.45) rotate(45)"/>
        <rect class="cls-10" x="5.1" y="13.24" width="1.15" height="14.92" transform="translate(24.33 31.32) rotate(135)"/>
        <rect class="cls-1" x="20.12" y="-1.78" width="1.15" height="14.92" transform="translate(39.35 -4.94) rotate(135)"/>
      </g>
    </g>
    <g>
      <polygon class="cls-11" points="40.23 10.26 29.56 20.96 36.89 28.31 47.56 17.61 40.23 10.26"/>
      <polygon class="cls-17" points="36.91 29.03 36.2 28.31 47.56 16.92 48.27 17.63 36.91 29.03"/>
      <polygon class="cls-14" points="29.59 21.68 28.88 20.97 40.24 9.57 40.95 10.29 29.59 21.68"/>
      <polygon class="cls-8" points="28.88 20.97 29.59 20.25 37.62 28.31 36.91 29.02 28.88 20.97"/>
      <polygon class="cls-3" points="39.53 10.29 40.24 9.57 48.27 17.63 47.56 18.34 39.53 10.29"/>
    </g>
    <g>
      <rect class="cls-13" x="30.88" y="37.82" width="15.22" height="10.45" transform="translate(-19.17 39.82) rotate(-45)"/>
      <g>
        <rect class="cls-9" x="32.75" y="42.61" width="1.01" height="11.36" transform="translate(90.91 58.91) rotate(135)"/>
        <rect class="cls-2" x="43.4" y="31.96" width="1.01" height="11.36" transform="translate(101.56 33.21) rotate(135)"/>
        <rect class="cls-6" x="41.73" y="38.59" width="1.01" height="16.06" transform="translate(45.34 -16.21) rotate(45)"/>
        <rect class="cls-4" x="34.41" y="31.27" width="1.01" height="16.06" transform="translate(38.02 -13.18) rotate(45)"/>
      </g>
    </g>
  </g>
  <g>
    <path class="cls-5" d="M53.53,30.44v11.43h-2.56v-25.07h9.34c5.03,0,7.7,2.71,7.7,6.63,0,3.21-1.88,5.24-4.5,5.87,2.33.58,4.08,2.19,4.08,6.49v1.01c0,1.74-.11,4.06.33,5.06h-2.54c-.46-1.08-.39-3.09-.39-5.33v-.59c0-3.87-1.12-5.51-5.78-5.51h-5.68ZM53.53,28.19h5.77c4.14,0,6.02-1.55,6.02-4.63,0-2.89-1.88-4.53-5.55-4.53h-6.24v9.16Z"/>
    <path class="cls-5" d="M86.34,29.8h-12.62v9.77h13.84l-.35,2.3h-16.02v-25.06h15.77v2.26h-13.25v8.47h12.62v2.26Z"/>
    <path class="cls-5" d="M108.85,34.96c-1.15,4.09-4.19,7.17-9.65,7.17-7.32,0-11.11-5.7-11.11-12.76s3.75-12.93,11.18-12.93c5.63,0,8.82,3.17,9.6,7.35h-2.56c-1.03-3.02-3-5.12-7.16-5.12-5.91,0-8.36,5.39-8.36,10.63s2.38,10.6,8.5,10.6c3.98,0,5.88-2.16,6.99-4.94h2.56Z"/>
    <path class="cls-5" d="M111.34,16.8h2.56v22.77h13.27l-.4,2.26h-15.42v-25.03Z"/>
    <path class="cls-5" d="M132.69,33.69l-2.96,8.14h-2.57l9.07-25.03h3.1l9.45,25.03h-2.75l-3.04-8.14h-10.3ZM142.25,31.43c-2.61-7.05-3.98-10.59-4.5-12.37h-.04c-.61,2-2.15,6.34-4.26,12.37h8.8Z"/>
    <path class="cls-5" d="M151.31,34.99c.72,3.18,2.86,4.99,6.75,4.99,4.27,0,5.93-2.08,5.93-4.64,0-2.68-1.24-4.28-6.53-5.57-5.57-1.37-7.75-3.23-7.75-6.8s2.55-6.54,8.02-6.54,8.09,3.4,8.42,6.55h-2.62c-.52-2.48-2.11-4.36-5.91-4.36-3.36,0-5.21,1.54-5.21,4.15s1.54,3.58,6.05,4.69c7.09,1.75,8.22,4.55,8.22,7.65,0,3.84-2.82,7.02-8.76,7.02-6.27,0-8.75-3.55-9.24-7.13h2.62Z"/>
    <path class="cls-5" d="M170.17,34.99c.72,3.18,2.86,4.99,6.75,4.99,4.27,0,5.93-2.08,5.93-4.64,0-2.68-1.24-4.28-6.53-5.57-5.57-1.37-7.75-3.23-7.75-6.8s2.55-6.54,8.02-6.54,8.09,3.4,8.42,6.55h-2.62c-.52-2.48-2.11-4.36-5.91-4.36-3.36,0-5.21,1.54-5.21,4.15s1.54,3.58,6.05,4.69c7.09,1.75,8.22,4.55,8.22,7.65,0,3.84-2.82,7.02-8.76,7.02-6.27,0-8.75-3.55-9.24-7.13h2.62Z"/>
  </g>
</svg>
```

`plugins/ProcessMemory/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(ProcessMemoryPlugin LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt is found by the parent project; QT variable (Qt5 or Qt6) is inherited

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# Plugin sources
set(PLUGIN_SOURCES
    ProcessMemoryPlugin.h
    ProcessMemoryPlugin.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.h
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.ui
)

# Create shared library (DLL)
add_library(ProcessMemoryPlugin SHARED ${PLUGIN_SOURCES})

# Link Qt
target_link_libraries(ProcessMemoryPlugin PRIVATE ${QT}::Widgets ${_QT_WINEXTRAS})

# Platform-specific linking
if(WIN32)
    target_link_libraries(ProcessMemoryPlugin PRIVATE psapi shell32)
endif()

# On Linux, hide all symbols by default so only RCX_PLUGIN_EXPORT-marked ones are exported
if(UNIX AND NOT APPLE)
    target_compile_options(ProcessMemoryPlugin PRIVATE -fvisibility=hidden)
endif()

# Include directories
target_include_directories(ProcessMemoryPlugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src
)

# Output to Plugins folder
set_target_properties(ProcessMemoryPlugin PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)

```

`plugins/ProcessMemory/ProcessMemoryPlugin.cpp`:

```cpp
#include "ProcessMemoryPlugin.h"

#include "../../src/processpicker.h"

#include <QStyle>
#include <QApplication>
#include <QRegularExpression>
#include <QMessageBox>
#include <QPixmap>
#include <QImage>
#include <QDir>
#include <QFileInfo>
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0) && defined(_WIN32)
#include <QtWin>
#endif

#ifdef _WIN32
#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <shellapi.h>
#elif defined(__linux__)
#include <climits>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/uio.h>
#include <fstream>
#include <sstream>
#include <cstring>
#endif

// ──────────────────────────────────────────────────────────────────────────
// ProcessMemoryProvider implementation
// ──────────────────────────────────────────────────────────────────────────

#ifdef _WIN32

ProcessMemoryProvider::ProcessMemoryProvider(uint32_t pid, const QString& processName)
    : m_handle(nullptr)
    , m_pid(pid)
    , m_processName(processName)
    , m_writable(false)
    , m_base(0)
{
    // Try to open with write access first
    m_handle = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION,
                          FALSE, pid);
    if (m_handle)
        m_writable = true;
    else
    {
        // Fall back to read-only
        m_handle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid);
        m_writable = false;
    }

    if (m_handle)
        cacheModules();
}

bool ProcessMemoryProvider::read(uint64_t addr, void* buf, int len) const
{
    if (!m_handle || len <= 0) return false;

    SIZE_T bytesRead = 0;
    ReadProcessMemory(m_handle, (LPCVOID)(addr), buf, (SIZE_T)len, &bytesRead);
    if ((int)bytesRead < len)
        memset((char*)buf + bytesRead, 0, len - bytesRead);
    return bytesRead > 0;
}

bool ProcessMemoryProvider::write(uint64_t addr, const void* buf, int len)
{
    if (!m_handle || !m_writable || len <= 0) return false;

    SIZE_T bytesWritten = 0;
    if (WriteProcessMemory(m_handle, (LPVOID)(addr), buf, (SIZE_T)len, &bytesWritten))
        return bytesWritten == (SIZE_T)len;
    return false;
}

QString ProcessMemoryProvider::getSymbol(uint64_t addr) const
{
    for (const auto& mod : m_modules)
    {
        if (addr >= mod.base && addr < mod.base + mod.size)
        {
            uint64_t offset = addr - mod.base;
            return QStringLiteral("%1+0x%2")
                .arg(mod.name)
                .arg(offset, 0, 16, QChar('0'));
        }
    }
    return {};
}

void ProcessMemoryProvider::cacheModules()
{
    HMODULE mods[1024];
    DWORD needed = 0;
    if (!EnumProcessModulesEx(m_handle, mods, sizeof(mods),
                              &needed, LIST_MODULES_ALL))
        return;
    int count = qMin((int)(needed / sizeof(HMODULE)), 1024);
    m_modules.reserve(count);
    for (int i = 0; i < count; ++i)
    {
        MODULEINFO mi{};
        WCHAR modName[MAX_PATH];
        if (GetModuleInformation(m_handle, mods[i], &mi, sizeof(mi))
            && GetModuleBaseNameW(m_handle, mods[i], modName, MAX_PATH))
        {
            if ( i == 0 )
                m_base = (uint64_t)mi.lpBaseOfDll;

            m_modules.append({
                QString::fromWCharArray(modName),
                (uint64_t)mi.lpBaseOfDll,
                (uint64_t)mi.SizeOfImage
            });
        }
    }
}

#elif defined(__linux__)

ProcessMemoryProvider::ProcessMemoryProvider(uint32_t pid, const QString& processName)
    : m_fd(-1)
    , m_pid(pid)
    , m_processName(processName)
    , m_writable(false)
    , m_base(0)
{
    QString memPath = QStringLiteral("/proc/%1/mem").arg(pid);
    QByteArray pathUtf8 = memPath.toUtf8();

    // Try read-write first
    m_fd = ::open(pathUtf8.constData(), O_RDWR);
    if (m_fd >= 0)
        m_writable = true;
    else
    {
        // Fall back to read-only
        m_fd = ::open(pathUtf8.constData(), O_RDONLY);
        m_writable = false;
    }

    if (m_fd >= 0)
        cacheModules();

}

bool ProcessMemoryProvider::read(uint64_t addr, void* buf, int len) const
{
    if (m_fd < 0 || len <= 0) return false;

    // Try process_vm_readv first (faster, no fd seek contention)
    struct iovec local;
    local.iov_base = buf;
    local.iov_len = static_cast<size_t>(len);

    struct iovec remote;
    remote.iov_base = reinterpret_cast<void*>(addr);
    remote.iov_len = static_cast<size_t>(len);

    ssize_t nread = process_vm_readv(m_pid, &local, 1, &remote, 1, 0);
    if (nread == static_cast<ssize_t>(len))
        return true;

    // Fallback: pread on /proc/<pid>/mem
    nread = ::pread(m_fd, buf, static_cast<size_t>(len), static_cast<off_t>(addr));
    return nread == static_cast<ssize_t>(len);
}

bool ProcessMemoryProvider::write(uint64_t addr, const void* buf, int len)
{
    if (m_fd < 0 || !m_writable || len <= 0) return false;

    // Try process_vm_writev first
    struct iovec local;
    local.iov_base = const_cast<void*>(buf);
    local.iov_len = static_cast<size_t>(len);

    struct iovec remote;
    remote.iov_base = reinterpret_cast<void*>(addr);
    remote.iov_len = static_cast<size_t>(len);

    ssize_t nwritten = process_vm_writev(m_pid, &local, 1, &remote, 1, 0);
    if (nwritten == static_cast<ssize_t>(len))
        return true;

    // Fallback: pwrite on /proc/<pid>/mem
    nwritten = ::pwrite(m_fd, buf, static_cast<size_t>(len), static_cast<off_t>(addr));
    return nwritten == static_cast<ssize_t>(len);
}

QString ProcessMemoryProvider::getSymbol(uint64_t addr) const
{
    for (const auto& mod : m_modules)
    {
        if (addr >= mod.base && addr < mod.base + mod.size)
        {
            uint64_t offset = addr - mod.base;
            return QStringLiteral("%1+0x%2")
                .arg(mod.name)
                .arg(offset, 0, 16, QChar('0'));
        }
    }
    return {};
}

void ProcessMemoryProvider::cacheModules()
{
    // Parse /proc/<pid>/maps to discover loaded modules
    QString mapsPath = QStringLiteral("/proc/%1/maps").arg(m_pid);
    std::ifstream mapsFile(mapsPath.toStdString());
    if (!mapsFile.is_open()) return;

    // Accumulate base/end per path, then convert to ModuleInfo
    struct Range { uint64_t base; uint64_t end; };
    QMap<QString, Range> moduleRanges;

    std::string line;
    bool firstExec = true;
    while (std::getline(mapsFile, line))
    {
        // Format: addr_start-addr_end perms offset dev inode pathname
        // Example: 00400000-00452000 r-xp 00000000 08:02 173521 /usr/bin/foo
        std::istringstream iss(line);
        std::string addrRange, perms, offset, dev, inode, pathname;
        iss >> addrRange >> perms >> offset >> dev >> inode;
        std::getline(iss, pathname);

        // Trim leading whitespace from pathname
        size_t start = pathname.find_first_not_of(" \t");
        if (start == std::string::npos) continue;
        pathname = pathname.substr(start);

        // Skip non-file mappings
        if (pathname.empty() || pathname[0] != '/') continue;
        // Skip special mappings
        if (pathname.find("/dev/") == 0 || pathname.find("/memfd:") == 0) continue;

        // Parse address range
        auto dash = addrRange.find('-');
        if (dash == std::string::npos) continue;
        uint64_t addrStart = std::stoull(addrRange.substr(0, dash), nullptr, 16);
        uint64_t addrEnd = std::stoull(addrRange.substr(dash + 1), nullptr, 16);

        QString qpath = QString::fromStdString(pathname);

        // Track first executable mapping as the base address
        if (firstExec && perms.size() >= 3 && perms[2] == 'x')
        {
            m_base = addrStart;
            firstExec = false;
        }

        auto it = moduleRanges.find(qpath);
        if (it != moduleRanges.end())
        {
            if (addrStart < it->base) it->base = addrStart;
            if (addrEnd > it->end) it->end = addrEnd;
        }
        else
        {
            moduleRanges.insert(qpath, {addrStart, addrEnd});
        }
    }

    m_modules.reserve(moduleRanges.size());
    for (auto it = moduleRanges.begin(); it != moduleRanges.end(); ++it)
    {
        QFileInfo fi(it.key());
        m_modules.append({
            fi.fileName(),
            it->base,
            it->end - it->base
        });
    }
}

#endif // platform

uint64_t ProcessMemoryProvider::symbolToAddress(const QString& name) const
{
    for (const auto& mod : m_modules) {
        if (mod.name.compare(name, Qt::CaseInsensitive) == 0)
            return mod.base;
    }
    return 0;
}

ProcessMemoryProvider::~ProcessMemoryProvider()
{
#ifdef _WIN32
    if (m_handle)
        CloseHandle(m_handle);
#elif defined(__linux__)
    if (m_fd >= 0)
        ::close(m_fd);
#endif
}

int ProcessMemoryProvider::size() const
{
#ifdef _WIN32
    return m_handle ? 0x10000 : 0;
#elif defined(__linux__)
    return (m_fd >= 0) ? 0x10000 : 0;
#endif
}

// ──────────────────────────────────────────────────────────────────────────
// ProcessMemoryPlugin implementation
// ──────────────────────────────────────────────────────────────────────────

QIcon ProcessMemoryPlugin::Icon() const
{
    return qApp->style()->standardIcon(QStyle::SP_ComputerIcon);
}

bool ProcessMemoryPlugin::canHandle(const QString& target) const
{
    // Target format: "pid:name" or just "pid"
    QRegularExpression re("^\\d+");
    return re.match(target).hasMatch();
}

std::unique_ptr<rcx::Provider> ProcessMemoryPlugin::createProvider(const QString& target, QString* errorMsg)
{
    // Parse target: "pid:name" or just "pid"
    QStringList parts = target.split(':');
    bool ok = false;
    uint32_t pid = parts[0].toUInt(&ok);

    if (!ok || pid == 0)
    {
        if (errorMsg) *errorMsg = "Invalid PID: " + target;
        return nullptr;
    }

    QString name = parts.size() > 1 ? parts[1] : QString("PID %1").arg(pid);

    auto provider = std::make_unique<ProcessMemoryProvider>(pid, name);
    if (!provider->isValid())
    {
        if (errorMsg)
            *errorMsg = QString("Failed to open process %1 (PID: %2)\n"
                               "Ensure the process is running and you have sufficient permissions.")
                        .arg(name).arg(pid);
        return nullptr;
    }

    return provider;
}

uint64_t ProcessMemoryPlugin::getInitialBaseAddress(const QString& target) const
{
#ifdef _WIN32
    // Parse PID from target
    QStringList parts = target.split(':');
    bool ok = false;
    DWORD pid = parts[0].toUInt(&ok);
    if (!ok || pid == 0) return 0;

    // Open process to get main module base
    HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (!hProc) return 0;

    uint64_t base = 0;
    HMODULE hMod = nullptr;
    DWORD needed = 0;

    if (EnumProcessModulesEx(hProc, &hMod, sizeof(hMod), &needed, LIST_MODULES_ALL) && hMod)
    {
        MODULEINFO mi{};
        if (GetModuleInformation(hProc, hMod, &mi, sizeof(mi)))
            base = (uint64_t)mi.lpBaseOfDll;
    }

    CloseHandle(hProc);
    return base;
#elif defined(__linux__)
    // Parse PID from target
    QStringList parts = target.split(':');
    bool ok = false;
    uint32_t pid = parts[0].toUInt(&ok);
    if (!ok || pid == 0) return 0;

    // Find first executable mapping from /proc/<pid>/maps
    QString mapsPath = QStringLiteral("/proc/%1/maps").arg(pid);
    std::ifstream mapsFile(mapsPath.toStdString());
    if (!mapsFile.is_open()) return 0;

    std::string line;
    while (std::getline(mapsFile, line)) {
        std::istringstream iss(line);
        std::string addrRange, perms;
        iss >> addrRange >> perms;
        if (perms.size() >= 3 && perms[2] == 'x') {
            auto dash = addrRange.find('-');
            if (dash != std::string::npos) {
                return std::stoull(addrRange.substr(0, dash), nullptr, 16);
            }
        }
    }
    return 0;
#else
    Q_UNUSED(target);
    return 0;
#endif
}

bool ProcessMemoryPlugin::selectTarget(QWidget* parent, QString* target)
{
    // Use custom process enumeration from plugin
    QVector<PluginProcessInfo> pluginProcesses = enumerateProcesses();

    // Convert to ProcessInfo for ProcessPicker
    QList<ProcessInfo> processes;
    for (const auto& pinfo : pluginProcesses)
    {
        ProcessInfo info;
        info.pid = pinfo.pid;
        info.name = pinfo.name;
        info.path = pinfo.path;
        info.icon = pinfo.icon;
        processes.append(info);
    }

    // Show ProcessPicker with custom process list
    ProcessPicker picker(processes, parent);
    if (picker.exec() == QDialog::Accepted) {
        uint32_t pid = picker.selectedProcessId();
        QString name = picker.selectedProcessName();

        // Format target as "pid:name"
        *target = QString("%1:%2").arg(pid).arg(name);
        return true;
    }

    return false;
}

QVector<PluginProcessInfo> ProcessMemoryPlugin::enumerateProcesses()
{
    QVector<PluginProcessInfo> processes;

#ifdef _WIN32
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        return processes;
    }

    PROCESSENTRY32W entry;
    entry.dwSize = sizeof(entry);

    if (Process32FirstW(snapshot, &entry)) {
        do {
            PluginProcessInfo info;
            info.pid = entry.th32ProcessID;
            info.name = QString::fromWCharArray(entry.szExeFile);

            // Try to get full path and icon
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, entry.th32ProcessID);
            if (hProcess) {
                wchar_t path[MAX_PATH * 2];
                DWORD pathLen = sizeof(path) / sizeof(wchar_t);

                // Try QueryFullProcessImageNameW first
                if (QueryFullProcessImageNameW(hProcess, 0, path, &pathLen)) {
                    info.path = QString::fromWCharArray(path);

                    // Extract icon
                    SHFILEINFOW sfi = {};
                    if (SHGetFileInfoW(path, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_SMALLICON)) {
                        if (sfi.hIcon) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                            QPixmap pixmap = QPixmap::fromImage(QImage::fromHICON(sfi.hIcon));
#else
                            QPixmap pixmap = QtWin::fromHICON(sfi.hIcon);
#endif
                            info.icon = QIcon(pixmap);
                            DestroyIcon(sfi.hIcon);
                        }
                    }
                }

                CloseHandle(hProcess);
            }

            processes.append(info);

        } while (Process32NextW(snapshot, &entry));
    }

    CloseHandle(snapshot);
#elif defined(__linux__)
    QDir procDir("/proc");
    QStringList entries = procDir.entryList(QDir::Dirs | QDir::NoDotAndDotDot);
    QIcon defaultIcon = qApp->style()->standardIcon(QStyle::SP_ComputerIcon);

    for (const QString& entry : entries) {
        bool ok = false;
        uint32_t pid = entry.toUInt(&ok);
        if (!ok || pid == 0) continue;

        // Read process name from /proc/<pid>/comm
        QString commPath = QStringLiteral("/proc/%1/comm").arg(pid);
        QFile commFile(commPath);
        QString procName;
        if (commFile.open(QIODevice::ReadOnly)) {
            procName = QString::fromUtf8(commFile.readAll()).trimmed();
            commFile.close();
        }
        if (procName.isEmpty()) continue;  // Skip kernel threads with no name

        // Read exe path from /proc/<pid>/exe symlink
        QString exePath = QStringLiteral("/proc/%1/exe").arg(pid);
        QFileInfo exeInfo(exePath);
        QString resolvedPath;
        if (exeInfo.exists())
            resolvedPath = exeInfo.symLinkTarget();

        // Skip if we can't read the process memory (no access)
        QString memPath = QStringLiteral("/proc/%1/mem").arg(pid);
        if (::access(memPath.toUtf8().constData(), R_OK) != 0)
            continue;

        PluginProcessInfo info;
        info.pid = pid;
        info.name = procName;
        info.path = resolvedPath;
        info.icon = defaultIcon;
        processes.append(info);
    }
#endif

    return processes;
}

// ──────────────────────────────────────────────────────────────────────────
// Plugin factory
// ──────────────────────────────────────────────────────────────────────────

extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin()
{
    return new ProcessMemoryPlugin();
}

```

`plugins/ProcessMemory/ProcessMemoryPlugin.h`:

```h
#pragma once
#include "../../src/iplugin.h"
#include "../../src/core.h"

#include <cstdint>

/**
 * Process memory provider
 * Reads/writes memory from a live process using platform APIs
 */
class ProcessMemoryProvider : public rcx::Provider
{
public:
    ProcessMemoryProvider(uint32_t pid, const QString& processName);
    ~ProcessMemoryProvider() override;

    // Required overrides
    bool read(uint64_t addr, void* buf, int len) const override;
    int size() const override;

    // Optional overrides
    bool write(uint64_t addr, const void* buf, int len) override;
    bool isWritable() const override { return m_writable; }
    QString name() const override { return m_processName; }
    QString kind() const override { return QStringLiteral("LocalProcess"); }
    QString getSymbol(uint64_t addr) const override;
    uint64_t symbolToAddress(const QString& name) const override;

    bool isLive() const override { return true; }
    uint64_t base() const override { return m_base; }
    bool isReadable(uint64_t, int len) const override {
#ifdef _WIN32
        return m_handle && len >= 0;
#elif defined(__linux__)
        return m_fd >= 0 && len >= 0;
#endif
    }

    // Process-specific helpers
    uint32_t pid() const { return m_pid; }
    void refreshModules() { m_modules.clear(); cacheModules(); }

private:
    void cacheModules();

private:
#ifdef _WIN32
    void* m_handle;
#elif defined(__linux__)
    int m_fd;
#endif
    uint32_t m_pid;
    QString m_processName;
    bool m_writable;
    uint64_t m_base;

    struct ModuleInfo {
        QString  name;
        uint64_t base;
        uint64_t size;
    };
    QVector<ModuleInfo> m_modules;
};

/**
 * Plugin that provides ProcessMemoryProvider
 */
class ProcessMemoryPlugin : public IProviderPlugin
{
public:
    std::string Name() const override { return "Process Memory"; }
    std::string Version() const override { return "1.0.0"; }
    std::string Author() const override { return "Reclass"; }
    std::string Description() const override { return "Read and write memory from local running processes"; }
    k_ELoadType LoadType() const override { return k_ELoadTypeAuto; }
    QIcon Icon() const override;

    bool canHandle(const QString& target) const override;
    std::unique_ptr<rcx::Provider> createProvider(const QString& target, QString* errorMsg) override;
    uint64_t getInitialBaseAddress(const QString& target) const override;
    bool selectTarget(QWidget* parent, QString* target) override;

    // Optional: provide custom process list
    bool providesProcessList() const override { return true; }
    QVector<PluginProcessInfo> enumerateProcesses() override;
};

// Plugin export
extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin();

```

`plugins/RcNetPluginCompatLayer/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(RcNetCompatPlugin LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt is found by the parent project; QT variable (Qt5 or Qt6) is inherited

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# Plugin sources
set(PLUGIN_SOURCES
    RcNetCompatPlugin.h
    RcNetCompatPlugin.cpp
    RcNetCompatProvider.h
    RcNetCompatProvider.cpp
    ReClassNET_Plugin.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.h
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.ui
)

# -- Optional .NET bridge -------------------------------------------------
# When the .NET SDK is available, build the C# bridge assembly and enable
# CLR hosting support in the C++ plugin.

find_program(DOTNET_EXE dotnet)
if(DOTNET_EXE)
    # Check that 'dotnet build' actually works for net472
    execute_process(
        COMMAND ${DOTNET_EXE} --list-sdks
        OUTPUT_VARIABLE _dotnet_sdks
        ERROR_QUIET
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    if(_dotnet_sdks)
        set(HAS_CLR_BRIDGE ON)
        message(STATUS "RcNetCompat: .NET SDK found -- building managed bridge")
    endif()
endif()

if(HAS_CLR_BRIDGE)
    list(APPEND PLUGIN_SOURCES
        ClrHost.h
        ClrHost.cpp
    )

    # Build the C# bridge assembly
    set(_bridge_src "${CMAKE_CURRENT_SOURCE_DIR}/bridge")
    set(_bridge_out "${CMAKE_BINARY_DIR}/Plugins/RcNetBridge.dll")

    add_custom_command(
        OUTPUT "${_bridge_out}"
        COMMAND ${DOTNET_EXE} build
            "${_bridge_src}/RcNetBridge.csproj"
            -c Release
            -o "${CMAKE_BINARY_DIR}/Plugins"
            --nologo -v quiet
        DEPENDS
            "${_bridge_src}/RcNetBridge.cs"
            "${_bridge_src}/RcNetBridge.csproj"
        COMMENT "Building RcNetBridge.dll (.NET bridge)..."
    )
    add_custom_target(RcNetBridge ALL DEPENDS "${_bridge_out}")
else()
    message(STATUS "RcNetCompat: .NET SDK not found -- managed plugin support disabled")
endif()

# Create shared library (DLL)
add_library(RcNetCompatPlugin SHARED ${PLUGIN_SOURCES})

if(HAS_CLR_BRIDGE)
    target_compile_definitions(RcNetCompatPlugin PRIVATE HAS_CLR_BRIDGE=1)
    add_dependencies(RcNetCompatPlugin RcNetBridge)
    # CLR hosting uses COM (ole32)
    target_link_libraries(RcNetCompatPlugin PRIVATE ole32)
endif()

# Link Qt
target_link_libraries(RcNetCompatPlugin PRIVATE ${QT}::Widgets ${_QT_WINEXTRAS})

# Include directories
target_include_directories(RcNetCompatPlugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src
)

# Output to Plugins folder
set_target_properties(RcNetCompatPlugin PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)

```

`plugins/RcNetPluginCompatLayer/ClrHost.cpp`:

```cpp
#include "ClrHost.h"

#include <cwchar>

// -- GUIDs ----------------------------------------------------------------

using FnCLRCreateInstance = HRESULT(STDAPICALLTYPE*)(REFCLSID, REFIID, LPVOID*);

// {9280188D-0E8E-4867-B30C-7FA83884E8DE}
static const GUID sCLSID_CLRMetaHost =
    {0x9280188d, 0x0e8e, 0x4867, {0xb3, 0x0c, 0x7f, 0xa8, 0x38, 0x84, 0xe8, 0xde}};

// {D332DB9E-B9B3-4125-8207-A14884F53216}
static const GUID sIID_ICLRMetaHost =
    {0xD332DB9E, 0xB9B3, 0x4125, {0x82, 0x07, 0xA1, 0x48, 0x84, 0xF5, 0x32, 0x16}};

// {BD39D1D2-BA2F-486A-89B0-B4B0CB466891}
static const GUID sIID_ICLRRuntimeInfo =
    {0xBD39D1D2, 0xBA2F, 0x486a, {0x89, 0xB0, 0xB4, 0xB0, 0xCB, 0x46, 0x68, 0x91}};

// {90F1A06E-7712-4762-86B5-7A5EBA6BDB02}
static const GUID sCLSID_CLRRuntimeHost =
    {0x90F1A06E, 0x7712, 0x4762, {0x86, 0xB5, 0x7A, 0x5E, 0xBA, 0x6B, 0xDB, 0x02}};

// {90F1A06C-7712-4762-86B5-7A5EBA6BDB02}
static const GUID sIID_ICLRRuntimeHost =
    {0x90F1A06C, 0x7712, 0x4762, {0x86, 0xB5, 0x7A, 0x5E, 0xBA, 0x6B, 0xDB, 0x02}};

// -- ClrHost implementation -----------------------------------------------

ClrHost::ClrHost()
{
    startClr();
}

ClrHost::~ClrHost()
{
    if (m_runtimeHost) m_runtimeHost->Release();
    if (m_runtimeInfo) m_runtimeInfo->Release();
    if (m_metaHost)    m_metaHost->Release();
    if (m_mscoree)     FreeLibrary(m_mscoree);
}

bool ClrHost::startClr()
{
    m_mscoree = LoadLibraryW(L"mscoree.dll");
    if (!m_mscoree)
        return false;

    auto fnCreate = reinterpret_cast<FnCLRCreateInstance>(
        GetProcAddress(m_mscoree, "CLRCreateInstance"));
    if (!fnCreate)
        return false;

    HRESULT hr = fnCreate(sCLSID_CLRMetaHost, sIID_ICLRMetaHost,
                          reinterpret_cast<LPVOID*>(&m_metaHost));
    if (FAILED(hr) || !m_metaHost)
        return false;

    hr = m_metaHost->GetRuntime(L"v4.0.30319", sIID_ICLRRuntimeInfo,
                                reinterpret_cast<LPVOID*>(&m_runtimeInfo));
    if (FAILED(hr) || !m_runtimeInfo)
        return false;

    hr = m_runtimeInfo->GetInterface(sCLSID_CLRRuntimeHost, sIID_ICLRRuntimeHost,
                                     (LPVOID*)&m_runtimeHost);
    if (FAILED(hr) || !m_runtimeHost)
        return false;

    hr = m_runtimeHost->Start();
    if (FAILED(hr))
        return false;

    m_clrStarted = true;

    return true;
}

bool ClrHost::loadManagedPlugin(const QString& bridgeDllPath,
                                const QString& pluginPath,
                                RcNetFunctions* outFunctions,
                                QString* errorMsg)
{
    if (!m_runtimeHost || !m_clrStarted) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                ".NET Framework 4.x is not available on this machine.\n"
                "Install the .NET Framework 4.7.2+ runtime to load managed plugins.");
        return false;
    }


    // Zero the function table -- the bridge will fill it
    memset(outFunctions, 0, sizeof(RcNetFunctions));

    // Build the argument string: "<hex_address_of_function_table>|<plugin_path>"
    // Use %ls (not %s) for wide strings -- MinGW follows POSIX conventions.
    wchar_t arg[2048];
    swprintf(arg, sizeof(arg) / sizeof(wchar_t),
             L"%llx|%ls",
             reinterpret_cast<unsigned long long>(outFunctions),
             reinterpret_cast<const wchar_t*>(pluginPath.utf16()));

    DWORD retVal = 0;
    HRESULT hr = m_runtimeHost->ExecuteInDefaultAppDomain(
        reinterpret_cast<LPCWSTR>(bridgeDllPath.utf16()),
        L"RcNetBridge.Bridge",
        L"Initialize",
        arg,
        &retVal
        );

    if (FAILED(hr)) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                "Failed to execute .NET bridge (HRESULT 0x%1).\n"
                "Bridge: %2\n"
                "Plugin: %3")
                .arg(static_cast<uint>(hr), 8, 16, QChar('0'))
                .arg(bridgeDllPath)
                .arg(pluginPath);
        return false;
    }

    if (retVal != 0) {
        if (errorMsg) {
            switch (retVal) {
            case 1:
                *errorMsg = QStringLiteral("Bridge: invalid argument format.");
                break;
            case 2:
                *errorMsg = QStringLiteral(
                    "No ICoreProcessFunctions implementation found in the .NET plugin.\n"
                    "The DLL may not be a ReClass.NET plugin.");
                break;
            case 3:
                *errorMsg = QStringLiteral(
                    "Failed to load the .NET plugin assembly.\n"
                    "Check that all its dependencies are available.");
                break;
            default:
                *errorMsg = QStringLiteral("Bridge returned error code %1.").arg(retVal);
                break;
            }
        }
        return false;
    }

    // Verify the bridge wrote at least the minimum required function pointers
    if (!outFunctions->ReadRemoteMemory ||
        !outFunctions->OpenRemoteProcess ||
        !outFunctions->EnumerateProcesses ||
        !outFunctions->CloseRemoteProcess) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                "The .NET bridge loaded but did not provide the required functions "
                "(ReadRemoteMemory, OpenRemoteProcess, CloseRemoteProcess, EnumerateProcesses).");
        return false;
    }

    return true;
}

```

`plugins/RcNetPluginCompatLayer/ClrHost.h`:

```h
#pragma once
// In-process CLR hosting for loading .NET ReClass.NET plugins.
// Dynamically loads mscoree.dll and uses ICLRMetaHost -> ICLRRuntimeInfo ->
// ICLRRuntimeHost::ExecuteInDefaultAppDomain to call into the C# bridge.

#include "ReClassNET_Plugin.hpp"
#include <QString>
#include <windows.h>
#include <objbase.h>

// -- Minimal COM interface definitions for CLR hosting --------------------
// Defined here to avoid depending on Windows SDK metahost.h / mscoree.h
// which may not be present in all MinGW distributions.
// Only methods we actually call have real signatures; the rest are stubs
// that preserve correct vtable offsets.

#undef INTERFACE
#define INTERFACE ICLRMetaHost
DECLARE_INTERFACE_(ICLRMetaHost, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    // ICLRMetaHost
    STDMETHOD(GetRuntime)(LPCWSTR pwzVersion, REFIID riid, LPVOID* ppRuntime) PURE;
    STDMETHOD(GetVersionFromFile)(LPCWSTR, LPWSTR, DWORD*) PURE;
    STDMETHOD(EnumerateInstalledRuntimes)(void**) PURE;
    STDMETHOD(EnumerateLoadedRuntimes)(HANDLE, void**) PURE;
    STDMETHOD(RequestRuntimeLoadedNotification)(void*) PURE;
    STDMETHOD(QueryLegacyV2RuntimeBinding)(REFIID, LPVOID*) PURE;
    STDMETHOD_(void, ExitProcess)(INT32) PURE;
};
#undef INTERFACE

#define INTERFACE ICLRRuntimeInfo
DECLARE_INTERFACE_(ICLRRuntimeInfo, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    // ICLRRuntimeInfo
    STDMETHOD(GetVersionString)(LPWSTR, DWORD*) PURE;
    STDMETHOD(GetRuntimeDirectory)(LPWSTR, DWORD*) PURE;
    STDMETHOD(IsLoaded)(HANDLE, BOOL*) PURE;
    STDMETHOD(LoadErrorString)(UINT, LPWSTR, DWORD*, LONG) PURE;
    STDMETHOD(LoadLibrary)(LPCWSTR, HMODULE*) PURE;
    STDMETHOD(GetProcAddress)(LPCSTR, LPVOID*) PURE;
    STDMETHOD(GetInterface)(REFCLSID rclsid, REFIID riid, LPVOID* ppUnk) PURE;
};
#undef INTERFACE

#define INTERFACE ICLRRuntimeHost
DECLARE_INTERFACE_(ICLRRuntimeHost, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    // ICLRRuntimeHost
    STDMETHOD(Start)() PURE;
    STDMETHOD(Stop)() PURE;
    STDMETHOD(SetHostControl)(void*) PURE;
    STDMETHOD(GetCLRControl)(void**) PURE;
    STDMETHOD(UnloadAppDomain)(DWORD, BOOL) PURE;
    STDMETHOD(ExecuteInAppDomain)(DWORD, void*, void*) PURE;
    STDMETHOD(GetCurrentAppDomainId)(DWORD*) PURE;
    STDMETHOD(ExecuteApplication)(LPCWSTR, DWORD, LPCWSTR*, DWORD, LPCWSTR*, int*) PURE;
    STDMETHOD(ExecuteInDefaultAppDomain)(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, DWORD*) PURE;
};
#undef INTERFACE

// -- CLR Host wrapper -----------------------------------------------------

class ClrHost
{
public:
    ClrHost();
    ~ClrHost();

    // True if the .NET Framework CLR (v4.0) is available on this machine.
    bool isAvailable() const { return m_runtimeHost != nullptr && m_clrStarted; }

    // Load a managed ReClass.NET plugin via the C# bridge.
    bool loadManagedPlugin(const QString& bridgeDllPath,
                           const QString& pluginPath,
                           RcNetFunctions* outFunctions,
                           QString* errorMsg = nullptr);

private:
    bool startClr();

    HMODULE           m_mscoree         = nullptr;
    ICLRMetaHost*     m_metaHost        = nullptr;
    ICLRRuntimeInfo*  m_runtimeInfo     = nullptr;
    ICLRRuntimeHost*  m_runtimeHost     = nullptr;
    bool              m_clrStarted      = false;
};

```

`plugins/RcNetPluginCompatLayer/RcNetCompatPlugin.cpp`:

```cpp
#include "RcNetCompatPlugin.h"
#include "RcNetCompatProvider.h"
#include "../../src/processpicker.h"

#include <QApplication>
#include <QCoreApplication>
#include <QDir>
#include <QFileDialog>
#include <QFileInfo>
#include <QMessageBox>
#include <QStyle>

#include <windows.h>

// -- Helpers --------------------------------------------------------------

QIcon RcNetCompatPlugin::Icon() const
{
    return qApp->style()->standardIcon(QStyle::SP_TrashIcon);
}

// --.NET assembly detection ----------------------------------------------

static bool isDotNetAssembly(const QString& path)
{
    // A .NET assembly has a non-zero CLR header directory entry in the PE
    // optional header.  We check this by loading the PE without running
    // DllMain and inspecting the IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR.
    HMODULE hMod = GetModuleHandleW(reinterpret_cast<LPCWSTR>(path.utf16()));
    if (!hMod)
        hMod = LoadLibraryExW(reinterpret_cast<LPCWSTR>(path.utf16()),
                              nullptr, DONT_RESOLVE_DLL_REFERENCES);
    if (!hMod) return false;

    auto* dos = reinterpret_cast<const IMAGE_DOS_HEADER*>(hMod);
    if (dos->e_magic != IMAGE_DOS_SIGNATURE) return false;

    auto* nt = reinterpret_cast<const IMAGE_NT_HEADERS*>(
        reinterpret_cast<const char*>(hMod) + dos->e_lfanew);
    if (nt->Signature != IMAGE_NT_SIGNATURE) return false;

    constexpr DWORD kClrIndex = IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR; // 14
    DWORD rva = 0, dirSize = 0;

    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        auto* opt = reinterpret_cast<const IMAGE_OPTIONAL_HEADER64*>(&nt->OptionalHeader);
        if (opt->NumberOfRvaAndSizes > kClrIndex) {
            rva     = opt->DataDirectory[kClrIndex].VirtualAddress;
            dirSize = opt->DataDirectory[kClrIndex].Size;
        }
    } else {
        auto* opt = reinterpret_cast<const IMAGE_OPTIONAL_HEADER32*>(&nt->OptionalHeader);
        if (opt->NumberOfRvaAndSizes > kClrIndex) {
            rva     = opt->DataDirectory[kClrIndex].VirtualAddress;
            dirSize = opt->DataDirectory[kClrIndex].Size;
        }
    }

    return rva != 0 && dirSize != 0;
}

// --Unified loader (dispatches native vs managed) ------------------------

bool RcNetCompatPlugin::loadPlugin(const QString& path, QString* errorMsg)
{
    if (m_dllPath == path && (m_lib || m_isManaged))
        return true; // Already loaded

    if (isDotNetAssembly(path)) {
#ifdef HAS_CLR_BRIDGE
        return loadManagedDll(path, errorMsg);
#else
        if (errorMsg)
            *errorMsg = QStringLiteral(
                "This is a .NET assembly.\n\n"
                "This build does not include .NET bridge support.\n"
                "Rebuild with the .NET SDK installed to enable managed plugin loading.");
        return false;
#endif
    }
    return loadNativeDll(path, errorMsg);
}

// --Native DLL loading ---------------------------------------------------

bool RcNetCompatPlugin::loadNativeDll(const QString& path, QString* errorMsg)
{
    unloadNativeDll();

    m_lib = std::make_unique<QLibrary>(path);
    if (!m_lib->load()) {
        if (errorMsg)
            *errorMsg = QStringLiteral("Failed to load DLL: %1").arg(m_lib->errorString());
        m_lib.reset();
        return false;
    }

    // Resolve all function pointers
    m_fns.EnumerateProcesses =
        reinterpret_cast<FnEnumerateProcesses>(m_lib->resolve("EnumerateProcesses"));
    m_fns.OpenRemoteProcess =
        reinterpret_cast<FnOpenRemoteProcess>(m_lib->resolve("OpenRemoteProcess"));
    m_fns.IsProcessValid =
        reinterpret_cast<FnIsProcessValid>(m_lib->resolve("IsProcessValid"));
    m_fns.CloseRemoteProcess =
        reinterpret_cast<FnCloseRemoteProcess>(m_lib->resolve("CloseRemoteProcess"));
    m_fns.ReadRemoteMemory =
        reinterpret_cast<FnReadRemoteMemory>(m_lib->resolve("ReadRemoteMemory"));
    m_fns.WriteRemoteMemory =
        reinterpret_cast<FnWriteRemoteMemory>(m_lib->resolve("WriteRemoteMemory"));
    m_fns.EnumerateRemoteSectionsAndModules =
        reinterpret_cast<FnEnumerateRemoteSectionsAndModules>(
            m_lib->resolve("EnumerateRemoteSectionsAndModules"));
    m_fns.ControlRemoteProcess =
        reinterpret_cast<FnControlRemoteProcess>(m_lib->resolve("ControlRemoteProcess"));

    // At minimum we need read + open + close
    if (!m_fns.ReadRemoteMemory || !m_fns.OpenRemoteProcess || !m_fns.CloseRemoteProcess || !m_fns.EnumerateProcesses) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                "DLL is missing required exports (ReadRemoteMemory, OpenRemoteProcess, "
                "CloseRemoteProcess, EnumerateProcesses). Is this a ReClass.NET native plugin?");
        m_lib->unload();
        m_lib.reset();
        m_fns = {};
        return false;
    }

    m_dllPath  = path;
    m_isManaged = false;
    return true;
}

void RcNetCompatPlugin::unloadNativeDll()
{
    if (m_lib) {
        m_lib->unload();
        m_lib.reset();
    }
    m_fns = {};
    m_dllPath.clear();
    m_isManaged = false;
}

// --Managed (.NET) DLL loading via CLR bridge ----------------------------

#ifdef HAS_CLR_BRIDGE

bool RcNetCompatPlugin::loadManagedDll(const QString& path, QString* errorMsg)
{
    unloadNativeDll();

    // Lazily create the CLR host (one per plugin lifetime)
    if (!m_clrHost)
        m_clrHost = std::make_unique<ClrHost>();

    if (!m_clrHost->isAvailable()) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                ".NET Framework 4.x is not available on this machine.\n"
                "Install the .NET Framework 4.7.2+ runtime to load managed plugins.");
        return false;
    }

    // Locate RcNetBridge.dll next to our own plugin DLL
    // Use native separators -- the CLR expects Windows-style backslash paths.
    QString bridgePath = QDir::toNativeSeparators(
        QCoreApplication::applicationDirPath()
        + QStringLiteral("/Plugins/RcNetBridge.dll"));

    if (!QFileInfo::exists(bridgePath)) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                "RcNetBridge.dll not found in the Plugins folder.\n"
                "Expected at: %1").arg(bridgePath);
        return false;
    }

    m_fns = {};
    QString nativePath = QDir::toNativeSeparators(path);
    if (!m_clrHost->loadManagedPlugin(bridgePath, nativePath, &m_fns, errorMsg))
        return false;

    m_dllPath  = path;
    m_isManaged = true;
    return true;
}

#endif // HAS_CLR_BRIDGE

// --IProviderPlugin ------------------------------------------------------

bool RcNetCompatPlugin::canHandle(const QString& target) const
{
    // Target format: "dllpath|pid:name"
    return target.contains('|');
}

std::unique_ptr<rcx::Provider> RcNetCompatPlugin::createProvider(
    const QString& target, QString* errorMsg)
{
    // Parse "dllpath|pid:name"
    int sep = target.indexOf('|');
    if (sep < 0) {
        if (errorMsg) *errorMsg = QStringLiteral("Invalid target format");
        return nullptr;
    }

    QString dllPath = target.left(sep);
    QString pidPart = target.mid(sep + 1);

    // Load (or reuse) the plugin DLL
    if (!loadPlugin(dllPath, errorMsg))
        return nullptr;

    // Parse pid:name
    QStringList parts = pidPart.split(':');
    bool ok = false;
    uint32_t pid = parts[0].toUInt(&ok);
    if (!ok || pid == 0) {
        if (errorMsg) *errorMsg = QStringLiteral("Invalid PID: %1").arg(parts[0]);
        return nullptr;
    }
    QString procName = parts.size() > 1 ? parts[1] : QStringLiteral("PID %1").arg(pid);

    auto provider = std::make_unique<RcNetCompatProvider>(m_fns, pid, procName);
    if (!provider->isValid()) {
        if (errorMsg)
            *errorMsg = QStringLiteral(
                "Failed to open process %1 (PID: %2) via ReClass.NET plugin.\n"
                "Ensure the process is running and the plugin supports it.")
                .arg(procName).arg(pid);
        return nullptr;
    }

    return provider;
}

uint64_t RcNetCompatPlugin::getInitialBaseAddress(const QString& target) const
{
    Q_UNUSED(target);
    // The provider sets its own base from module enumeration.
    return 0;
}

bool RcNetCompatPlugin::selectTarget(QWidget* parent, QString* target)
{
    // Step 1: Pick a ReClass.NET plugin DLL (native or .NET)
    QString dllPath = QFileDialog::getOpenFileName(
        parent,
        QStringLiteral("Select ReClass.NET Plugin"),
        QString(),
        QStringLiteral("DLL Files (*.dll)"));

    if (dllPath.isEmpty())
        return false;

    // Step 2: Load and validate the DLL
    QString loadErr;
    if (!loadPlugin(dllPath, &loadErr)) {
        QMessageBox::warning(parent,
                             QStringLiteral("ReClass.NET Compat Layer"),
                             loadErr);
        return false;
    }

    // Step 3: Enumerate processes and show picker
    QVector<PluginProcessInfo> pluginProcesses = enumerateProcesses();

    QList<ProcessInfo> processes;
    for (const auto& p : pluginProcesses) {
        ProcessInfo info;
        info.pid  = p.pid;
        info.name = p.name;
        info.path = p.path;
        info.icon = p.icon;
        processes.append(info);
    }

    ProcessPicker picker(processes, parent);
    if (picker.exec() != QDialog::Accepted)
        return false;

    uint32_t pid = picker.selectedProcessId();
    QString name = picker.selectedProcessName();

    // Step 4: Format target as "dllpath|pid:name"
    *target = QStringLiteral("%1|%2:%3").arg(dllPath).arg(pid).arg(name);
    return true;
}

// --Process enumeration --------------------------------------------------

namespace {

struct ProcessCollector {
    QVector<PluginProcessInfo>* dest = nullptr;
};
thread_local ProcessCollector g_processCollector;

void RC_CALLCONV processCallback(EnumerateProcessData* data)
{
    if (!data || !g_processCollector.dest) return;

    PluginProcessInfo info;
    info.pid  = static_cast<uint32_t>(data->Id);
    info.name = QString::fromUtf16(data->Name);
    info.path = QString::fromUtf16(data->Path);
    g_processCollector.dest->append(info);
}

} // anonymous namespace

QVector<PluginProcessInfo> RcNetCompatPlugin::enumerateProcesses()
{
    QVector<PluginProcessInfo> result;

    if (!m_fns.EnumerateProcesses)
        return result;

    g_processCollector.dest = &result;
    m_fns.EnumerateProcesses(processCallback);
    g_processCollector.dest = nullptr;

    return result;
}

// --Plugin factory -------------------------------------------------------

extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin()
{
    return new RcNetCompatPlugin();
}

```

`plugins/RcNetPluginCompatLayer/RcNetCompatPlugin.h`:

```h
#pragma once
#include "../../src/iplugin.h"
#include "ReClassNET_Plugin.hpp"

#include <QLibrary>
#include <memory>

#ifdef HAS_CLR_BRIDGE
#include "ClrHost.h"
#endif

/**
 * ReclassX plugin that loads ReClass.NET plugin DLLs
 * and exposes them as ReclassX providers.
 *
 * Supports both native DLLs (C exports) and, when built with
 * HAS_CLR_BRIDGE, managed .NET assemblies via in-process CLR hosting.
 *
 * Target string format: "dllpath|pid:processname"
 */
class RcNetCompatPlugin : public IProviderPlugin
{
public:
    // Plugin metadata
    std::string Name() const override { return "ReClass.NET Compat Layer"; }
    std::string Version() const override { return "1.0.0"; }
    std::string Author() const override { return "Reclass"; }
    std::string Description() const override {
        return "Loads ReClass.NET native and .NET plugin DLLs as Reclass data sources";
    }
    k_ELoadType LoadType() const override { return k_ELoadTypeAuto; }
    QIcon Icon() const override;

    // IProviderPlugin interface
    bool canHandle(const QString& target) const override;
    std::unique_ptr<rcx::Provider> createProvider(const QString& target, QString* errorMsg) override;
    uint64_t getInitialBaseAddress(const QString& target) const override;
    bool selectTarget(QWidget* parent, QString* target) override;

    // Override process enumeration -- we enumerate via the loaded DLL
    bool providesProcessList() const override { return true; }
    QVector<PluginProcessInfo> enumerateProcesses() override;

private:
    bool loadPlugin(const QString& path, QString* errorMsg = nullptr);
    bool loadNativeDll(const QString& path, QString* errorMsg = nullptr);
    void unloadNativeDll();

#ifdef HAS_CLR_BRIDGE
    bool loadManagedDll(const QString& path, QString* errorMsg = nullptr);
    std::unique_ptr<ClrHost> m_clrHost;
#endif

    std::unique_ptr<QLibrary> m_lib;
    RcNetFunctions            m_fns;
    QString                   m_dllPath;
    bool                      m_isManaged = false;
};

// Plugin export
extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin();

```

`plugins/RcNetPluginCompatLayer/RcNetCompatProvider.cpp`:

```cpp
#include "RcNetCompatProvider.h"

#include <QFileInfo>
#include <cstring>

// -- Construction / destruction -------------------------------------------

RcNetCompatProvider::RcNetCompatProvider(const RcNetFunctions& fns,
                                         uint32_t pid,
                                         const QString& processName)
    : m_fns(fns)
    , m_pid(pid)
    , m_processName(processName)
{
    if (m_fns.OpenRemoteProcess)
        m_handle = m_fns.OpenRemoteProcess(static_cast<RC_Size>(pid),
                                           ProcessAccess::Full);

    if (m_handle)
        cacheModules();
}

RcNetCompatProvider::~RcNetCompatProvider()
{
    if (m_handle && m_fns.CloseRemoteProcess)
        m_fns.CloseRemoteProcess(m_handle);
}

// -- Required overrides ---------------------------------------------------

bool RcNetCompatProvider::read(uint64_t addr, void* buf, int len) const
{
    if (!m_handle || !m_fns.ReadRemoteMemory || len <= 0)
        return false;

    return m_fns.ReadRemoteMemory(m_handle,
                                  reinterpret_cast<RC_Pointer>(addr),
                                  static_cast<RC_Pointer>(buf),
                                  0, len);
}

int RcNetCompatProvider::size() const
{
    if (!m_handle) return 0;
    if (m_fns.IsProcessValid && !m_fns.IsProcessValid(m_handle)) return 0;
    return 0x10000;
}

// -- Optional overrides ---------------------------------------------------

bool RcNetCompatProvider::write(uint64_t addr, const void* buf, int len)
{
    if (!m_handle || !m_fns.WriteRemoteMemory || len <= 0)
        return false;

    return m_fns.WriteRemoteMemory(m_handle,
                                   reinterpret_cast<RC_Pointer>(addr),
                                   const_cast<RC_Pointer>(static_cast<const void*>(buf)),
                                   0, len);
}

QString RcNetCompatProvider::getSymbol(uint64_t addr) const
{
    for (const auto& mod : m_modules)
    {
        if (addr >= mod.base && addr < mod.base + mod.size)
        {
            uint64_t offset = addr - mod.base;
            return QStringLiteral("%1+0x%2")
                .arg(mod.name)
                .arg(offset, 0, 16, QChar('0'));
        }
    }
    return {};
}

uint64_t RcNetCompatProvider::symbolToAddress(const QString& name) const
{
    for (const auto& mod : m_modules) {
        if (mod.name.compare(name, Qt::CaseInsensitive) == 0)
            return mod.base;
    }
    return 0;
}

// -- Module enumeration ---------------------------------------------------

namespace {

// Thread-local collector for the module enumeration callback.
// ReClass.NET callbacks are synchronous, so this is safe.
struct ModuleCollector {
    QVector<RcNetCompatProvider::ModuleInfo>* dest = nullptr;
};
thread_local ModuleCollector g_moduleCollector;

void RC_CALLCONV moduleCallback(EnumerateRemoteModuleData* data)
{
    if (!data || !g_moduleCollector.dest) return;

    QString path = QString::fromUtf16(data->Path);
    QFileInfo fi(path);

    RcNetCompatProvider::ModuleInfo info;
    info.name = fi.fileName();
    info.base = reinterpret_cast<uint64_t>(data->BaseAddress);
    info.size = static_cast<uint64_t>(data->Size);
    g_moduleCollector.dest->append(info);
}

// We still need a section callback even though we don't use it.
void RC_CALLCONV sectionCallback(EnumerateRemoteSectionData*)
{
    // Intentionally empty -- we only need module data.
}

} // anonymous namespace

void RcNetCompatProvider::cacheModules()
{
    if (!m_fns.EnumerateRemoteSectionsAndModules || !m_handle)
        return;

    m_modules.clear();
    g_moduleCollector.dest = &m_modules;
    m_fns.EnumerateRemoteSectionsAndModules(m_handle, sectionCallback, moduleCallback);
    g_moduleCollector.dest = nullptr;

    // Set base to first module if we got any
    if (!m_modules.isEmpty() && m_base == 0)
        m_base = m_modules.first().base;
}

```

`plugins/RcNetPluginCompatLayer/RcNetCompatProvider.h`:

```h
#pragma once
#include "../../src/providers/provider.h"
#include "ReClassNET_Plugin.hpp"

#include <QString>
#include <QVector>

/**
 * Provider that bridges ReClass.NET native plugin DLL calls
 * to the ReclassX Provider interface.
 */
class RcNetCompatProvider : public rcx::Provider
{
public:
    RcNetCompatProvider(const RcNetFunctions& fns, uint32_t pid,
                        const QString& processName);
    ~RcNetCompatProvider() override;

    // Required overrides
    bool read(uint64_t addr, void* buf, int len) const override;
    int  size() const override;

    // Optional overrides
    bool     write(uint64_t addr, const void* buf, int len) override;
    bool     isWritable() const override { return m_fns.WriteRemoteMemory != nullptr; }
    QString  name() const override { return m_processName; }
    QString  kind() const override { return QStringLiteral("RcNet"); }
    bool     isLive() const override { return true; }
    uint64_t base() const override { return m_base; }
    QString  getSymbol(uint64_t addr) const override;
    uint64_t symbolToAddress(const QString& name) const override;

    struct ModuleInfo {
        QString  name;
        uint64_t base;
        uint64_t size;
    };

private:
    void cacheModules();

    RcNetFunctions m_fns;
    RC_Pointer     m_handle = nullptr;
    uint32_t       m_pid;
    QString        m_processName;
    uint64_t       m_base = 0;
    QVector<ModuleInfo> m_modules;
};

```

`plugins/RcNetPluginCompatLayer/ReClassNET_Plugin.hpp`:

```hpp
#pragma once
// Subset of ReClass.NET native plugin types needed for the compatibility layer.
// Based on the ReClass.NET NativeCore plugin interface.
// Only types required by the 8 supported exports are included (no debug types).

#include <cstdint>

#ifdef _WIN32
#define RC_CALLCONV __stdcall
#else
#define RC_CALLCONV
#endif

// -- Basic types ----------------------------------------------------------

using RC_Pointer = void*;
using RC_Size    = uint64_t;
using RC_UnicodeChar = char16_t;

// -- Enums ----------------------------------------------------------------

enum class ProcessAccess
{
    Read    = 0,
    Write   = 1,
    Full    = 2
};

enum class SectionProtection
{
    NoAccess  = 0,
    Read      = 1,
    Write     = 2,
    Execute   = 4,
    Guard     = 8
};

enum class SectionType
{
    Unknown = 0,
    Private = 1,
    Mapped  = 2,
    Image   = 3
};

enum class SectionCategory
{
    Unknown = 0,
    CODE    = 1,
    DATA    = 2,
    HEAP    = 3
};

enum class ControlRemoteProcessAction
{
    Suspend = 0,
    Resume  = 1,
    Terminate = 2
};

// -- Callback data structures ---------------------------------------------

#pragma pack(push, 1)

struct EnumerateProcessData
{
    RC_Size     Id;
    RC_UnicodeChar Name[260];
    RC_UnicodeChar Path[260];
};

struct EnumerateRemoteSectionData
{
    RC_Pointer        BaseAddress;
    RC_Size           Size;
    SectionType       Type;
    SectionCategory   Category;
    SectionProtection Protection;
    RC_UnicodeChar    Name[16];
    RC_UnicodeChar    ModulePath[260];
};

struct EnumerateRemoteModuleData
{
    RC_Pointer     BaseAddress;
    RC_Size        Size;
    RC_UnicodeChar Path[260];
};

#pragma pack(pop)

// -- Callback typedefs ----------------------------------------------------

using EnumerateProcessCallback        = void(RC_CALLCONV*)(EnumerateProcessData* data);
using EnumerateRemoteSectionsCallback  = void(RC_CALLCONV*)(EnumerateRemoteSectionData* data);
using EnumerateRemoteModulesCallback   = void(RC_CALLCONV*)(EnumerateRemoteModuleData* data);

// -- Function pointer typedefs for resolved exports -----------------------

using FnEnumerateProcesses = void(RC_CALLCONV*)(EnumerateProcessCallback callback);

using FnOpenRemoteProcess  = RC_Pointer(RC_CALLCONV*)(RC_Size id, ProcessAccess desiredAccess);

using FnIsProcessValid     = bool(RC_CALLCONV*)(RC_Pointer handle);

using FnCloseRemoteProcess = void(RC_CALLCONV*)(RC_Pointer handle);

using FnReadRemoteMemory   = bool(RC_CALLCONV*)(RC_Pointer handle,
                                                 RC_Pointer address,
                                                 RC_Pointer buffer,
                                                 int offset,
                                                 int size);

using FnWriteRemoteMemory  = bool(RC_CALLCONV*)(RC_Pointer handle,
                                                  RC_Pointer address,
                                                  RC_Pointer buffer,
                                                  int offset,
                                                  int size);

using FnEnumerateRemoteSectionsAndModules =
    void(RC_CALLCONV*)(RC_Pointer handle,
                       EnumerateRemoteSectionsCallback sectionCallback,
                       EnumerateRemoteModulesCallback  moduleCallback);

using FnControlRemoteProcess = void(RC_CALLCONV*)(RC_Pointer handle,
                                                    ControlRemoteProcessAction action);

// -- Resolved function table ----------------------------------------------

struct RcNetFunctions
{
    FnEnumerateProcesses                EnumerateProcesses               = nullptr;
    FnOpenRemoteProcess                 OpenRemoteProcess                = nullptr;
    FnIsProcessValid                    IsProcessValid                   = nullptr;
    FnCloseRemoteProcess                CloseRemoteProcess               = nullptr;
    FnReadRemoteMemory                  ReadRemoteMemory                 = nullptr;
    FnWriteRemoteMemory                 WriteRemoteMemory                = nullptr;
    FnEnumerateRemoteSectionsAndModules EnumerateRemoteSectionsAndModules = nullptr;
    FnControlRemoteProcess              ControlRemoteProcess             = nullptr;
};

```

`plugins/RcNetPluginCompatLayer/bridge/RcNetBridge.cs`:

```cs
// RcNetBridge -- in-process C# bridge for loading .NET ReClass.NET plugins.
//
// Called from C++ via ICLRRuntimeHost::ExecuteInDefaultAppDomain().
// The single entry point is Bridge.Initialize(string arg) where arg is:
//   "<hex_address_of_RcNetFunctions>|<plugin_dll_path>"
//
// The bridge:
//   1. Registers an AssemblyResolve handler that provides THIS assembly
//      when a plugin asks for "ReClassNET", so the stub types below satisfy
//      the plugin's type references.
//   2. Loads the plugin assembly and finds an ICoreProcessFunctions
//      implementation.
//   3. Creates [UnmanagedFunctionPointer] delegates wrapping each method.
//   4. Writes the native-callable function pointers into the RcNetFunctions
//      struct at the address provided by C++.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;

// ===========================================================================
// ReClass.NET stub types
// These mirror the subset of types from the ReClass.NET assembly that
// memory-reading plugins reference.  When the CLR resolves "ReClassNET"
// via our AssemblyResolve handler, it gets THIS assembly, and these types
// satisfy the plugin's type references.
//
// Types are placed in the exact namespaces used by the real ReClass.NET
// assembly so that plugins compiled against it resolve correctly.
// ===========================================================================

// --------------------------------------------------------------------------
// ReClassNET.Memory -- section enums (referenced by EnumerateRemoteSectionData)
// --------------------------------------------------------------------------
namespace ReClassNET.Memory
{
    public enum SectionProtection
    {
        NoAccess = 0,
        Read     = 1,
        Write    = 2,
        Execute  = 4,
        Guard    = 8
    }

    public enum SectionType
    {
        Unknown = 0,
        Private = 1,
        Mapped  = 2,
        Image   = 3
    }

    public enum SectionCategory
    {
        Unknown = 0,
        CODE    = 1,
        DATA    = 2,
        HEAP    = 3
    }
}

// --------------------------------------------------------------------------
// ReClassNET.Debugger -- debugger types (used by ICoreProcessFunctions)
// --------------------------------------------------------------------------
namespace ReClassNET.Debugger
{
    public enum DebugContinueStatus
    {
        Handled    = 0,
        NotHandled = 1
    }

    public enum HardwareBreakpointRegister
    {
        InvalidRegister = 0,
        Dr0 = 1,
        Dr1 = 2,
        Dr2 = 3,
        Dr3 = 4
    }

    public enum HardwareBreakpointTrigger
    {
        Execute = 0,
        Access  = 1,
        Write   = 2
    }

    public enum HardwareBreakpointSize
    {
        Size1 = 1,
        Size2 = 2,
        Size4 = 4,
        Size8 = 8
    }

    public struct ExceptionDebugInfo
    {
        public IntPtr ExceptionCode;
        public IntPtr ExceptionFlags;
        public IntPtr ExceptionAddress;
        public HardwareBreakpointRegister CausedBy;
        public RegisterInfo Registers;

        public struct RegisterInfo
        {
            public IntPtr Rax, Rbx, Rcx, Rdx;
            public IntPtr Rdi, Rsi, Rsp, Rbp, Rip;
            public IntPtr R8, R9, R10, R11, R12, R13, R14, R15;
        }
    }

    public struct DebugEvent
    {
        public DebugContinueStatus ContinueStatus;
        public IntPtr ProcessId;
        public IntPtr ThreadId;
        public ExceptionDebugInfo ExceptionInfo;
    }
}

// --------------------------------------------------------------------------
// ReClassNET.Core -- interface, enums, delegates, and data structs
// --------------------------------------------------------------------------
namespace ReClassNET.Core
{
    public enum ProcessAccess
    {
        Read  = 0,
        Write = 1,
        Full  = 2
    }

    public enum ControlRemoteProcessAction
    {
        Suspend   = 0,
        Resume    = 1,
        Terminate = 2
    }

    public struct EnumerateProcessData
    {
        public IntPtr Id;
        public string Name;
        public string Path;
    }

    public struct EnumerateRemoteSectionData
    {
        public IntPtr                          BaseAddress;
        public IntPtr                          Size;
        public ReClassNET.Memory.SectionType       Type;
        public ReClassNET.Memory.SectionCategory   Category;
        public ReClassNET.Memory.SectionProtection Protection;
        public string                          Name;
        public string                          ModulePath;
    }

    public struct EnumerateRemoteModuleData
    {
        public IntPtr BaseAddress;
        public IntPtr Size;
        public string Path;
    }

    public delegate void EnumerateProcessCallback(ref EnumerateProcessData data);
    public delegate void EnumerateRemoteSectionCallback(ref EnumerateRemoteSectionData data);
    public delegate void EnumerateRemoteModuleCallback(ref EnumerateRemoteModuleData data);

    public interface ICoreProcessFunctions
    {
        void   EnumerateProcesses(EnumerateProcessCallback callbackProcess);
        IntPtr OpenRemoteProcess(IntPtr pid, ProcessAccess desiredAccess);
        bool   IsProcessValid(IntPtr process);
        void   CloseRemoteProcess(IntPtr process);
        bool   ReadRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size);
        bool   WriteRemoteMemory(IntPtr process, IntPtr address, ref byte[] buffer, int offset, int size);
        void   EnumerateRemoteSectionsAndModules(
                   IntPtr process,
                   EnumerateRemoteSectionCallback callbackSection,
                   EnumerateRemoteModuleCallback  callbackModule);
        void   ControlRemoteProcess(IntPtr process, ControlRemoteProcessAction action);

        // Debugger methods -- stubs required for interface compatibility
        bool AttachDebuggerToProcess(IntPtr id);
        void DetachDebuggerFromProcess(IntPtr id);
        bool AwaitDebugEvent(ref ReClassNET.Debugger.DebugEvent evt, int timeoutInMilliseconds);
        void HandleDebugEvent(ref ReClassNET.Debugger.DebugEvent evt);
        bool SetHardwareBreakpoint(IntPtr id, IntPtr address,
                 ReClassNET.Debugger.HardwareBreakpointRegister register,
                 ReClassNET.Debugger.HardwareBreakpointTrigger trigger,
                 ReClassNET.Debugger.HardwareBreakpointSize size,
                 bool set);
    }
}

// --------------------------------------------------------------------------
// ReClassNET.Memory -- RemoteProcess stub
// --------------------------------------------------------------------------
namespace ReClassNET.Memory
{
    public class RemoteProcess { }
}

// --------------------------------------------------------------------------
// ReClassNET.Logger -- ILogger stub
// --------------------------------------------------------------------------
namespace ReClassNET.Logger
{
    public interface ILogger { }
}

// --------------------------------------------------------------------------
// Stub types for IPluginHost properties
// --------------------------------------------------------------------------
namespace ReClassNET.Forms
{
    public class MainForm { }
}

namespace ReClassNET
{
    public class Settings { }
}

// --------------------------------------------------------------------------
// ReClassNET.Plugins
// --------------------------------------------------------------------------
namespace ReClassNET.Plugins
{
    public abstract class Plugin : IDisposable
    {
        public virtual bool Initialize(IPluginHost host) { return true; }
        public virtual void Terminate() { }
        public virtual void Dispose() { }
    }

    public interface IPluginHost
    {
        ReClassNET.Forms.MainForm MainWindow { get; }
        System.Resources.ResourceManager Resources { get; }
        ReClassNET.Memory.RemoteProcess Process { get; }
        ReClassNET.Logger.ILogger Logger { get; }
        ReClassNET.Settings Settings { get; }
    }
}

// ===========================================================================
// Bridge
// ===========================================================================

namespace RcNetBridge
{
    internal class StubPluginHost : ReClassNET.Plugins.IPluginHost
    {
        public ReClassNET.Forms.MainForm MainWindow => null;
        public System.Resources.ResourceManager Resources => null;
        public ReClassNET.Memory.RemoteProcess Process => null;
        public ReClassNET.Logger.ILogger Logger => null;
        public ReClassNET.Settings Settings => null;
    }

    public class Bridge
    {
        // -- Persistent state (static so it survives after Initialize returns) --

        private static ReClassNET.Core.ICoreProcessFunctions s_functions;
        private static readonly List<Delegate> s_pinned = new List<Delegate>();

        // -- Entry point called from C++ --------------------------------------

        /// <summary>
        /// Called by ICLRRuntimeHost::ExecuteInDefaultAppDomain.
        /// arg = "&lt;hex_address_of_RcNetFunctions&gt;|&lt;plugin_dll_path&gt;"
        /// Returns 0 on success, non-zero error code on failure.
        /// </summary>
        public static int Initialize(string arg)
        {
            try
            {
                int sep = arg.IndexOf('|');
                if (sep < 0) return 1; // bad arg

                long ptrValue = long.Parse(arg.Substring(0, sep), NumberStyles.HexNumber);
                IntPtr funcTablePtr = new IntPtr(ptrValue);
                string pluginPath = arg.Substring(sep + 1);

                // Set up assembly resolution
                string pluginDir = Path.GetDirectoryName(pluginPath) ?? ".";
                string parentDir = Path.GetDirectoryName(pluginDir);

                AppDomain.CurrentDomain.AssemblyResolve += (sender, resolveArgs) =>
                {
                    string asmName = new AssemblyName(resolveArgs.Name).Name;

                    // Provide our own assembly as the "ReClass.NET" stub
                    if (string.Equals(asmName, "ReClass.NET", StringComparison.OrdinalIgnoreCase))
                        return typeof(Bridge).Assembly;

                    // Search plugin directory and parent for other dependencies
                    string dllName = asmName + ".dll";
                    foreach (string dir in new[] { pluginDir, parentDir })
                    {
                        if (dir == null) continue;
                        string path = Path.Combine(dir, dllName);
                        if (File.Exists(path))
                            return Assembly.LoadFrom(path);
                    }
                    return null;
                };

                // Load plugin and find ICoreProcessFunctions
                if (!LoadPlugin(pluginPath))
                    return 2; // no implementation found

                // Write function pointers
                WriteFunctionPointers(funcTablePtr);
                return 0;
            }
            catch (Exception ex) when (ex is ReflectionTypeLoadException || ex is FileNotFoundException)
            {
                return 3;
            }
            catch
            {
                return 4;
            }
        }

        // -- Plugin loading ---------------------------------------------------

        private static bool LoadPlugin(string pluginPath)
        {
            Assembly asm = Assembly.LoadFrom(pluginPath);

            // Find a concrete type that implements ICoreProcessFunctions.
            // ReClass.NET plugins typically extend Plugin and directly
            // implement ICoreProcessFunctions on the same class.
            foreach (Type type in asm.GetExportedTypes())
            {
                if (type.IsAbstract || type.IsInterface) continue;

                Type iface = type.GetInterfaces().FirstOrDefault(i =>
                    i.FullName == "ReClassNET.Core.ICoreProcessFunctions");
                if (iface == null) continue;

                object instance = Activator.CreateInstance(type);

                // Try calling Initialize() but don't fail if it throws --
                // plugins use it for UI integration with the host app,
                // which we can't fully provide. The process functions
                // (ReadRemoteMemory, etc.) work without it.
                try
                {
                    MethodInfo init = type.GetMethod("Initialize",
                        BindingFlags.Public | BindingFlags.Instance,
                        null, new[] { typeof(ReClassNET.Plugins.IPluginHost) }, null);
                    if (init != null)
                        init.Invoke(instance, new object[] { new StubPluginHost() });
                }
                catch { }

                s_functions = (ReClassNET.Core.ICoreProcessFunctions)instance;
                return true;
            }

            return false;
        }

        // -- Native-callable delegate types -----------------------------------
        // These match the C++ RcNetFunctions struct field order exactly.
        // On x64 Windows all calling conventions collapse to the Microsoft
        // x64 ABI, so StdCall is used for documentation / x86 correctness.

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void DelEnumProcesses(IntPtr callback);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate IntPtr DelOpenRemoteProcess(ulong id, int access);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        [return: MarshalAs(UnmanagedType.I1)]
        delegate bool DelIsProcessValid(IntPtr handle);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void DelCloseRemoteProcess(IntPtr handle);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        [return: MarshalAs(UnmanagedType.I1)]
        delegate bool DelReadRemoteMemory(IntPtr handle, IntPtr address,
            IntPtr buffer, int offset, int size);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        [return: MarshalAs(UnmanagedType.I1)]
        delegate bool DelWriteRemoteMemory(IntPtr handle, IntPtr address,
            IntPtr buffer, int offset, int size);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void DelEnumSectionsAndModules(IntPtr handle,
            IntPtr sectionCallback, IntPtr moduleCallback);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void DelControlRemoteProcess(IntPtr handle, int action);

        // Callback delegate types -- these point into C++ and are called by us.
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void NativeProcessCallback(IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void NativeSectionCallback(IntPtr data);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void NativeModuleCallback(IntPtr data);

        // -- Write function pointers to the C++ struct ------------------------

        private static void WriteFunctionPointers(IntPtr funcTable)
        {
            // RcNetFunctions layout: 8 consecutive function pointers.
            int i = 0;
            WriteSlot(funcTable, i++, Pin<DelEnumProcesses>(EnumProcessesImpl));
            WriteSlot(funcTable, i++, Pin<DelOpenRemoteProcess>(OpenProcessImpl));
            WriteSlot(funcTable, i++, Pin<DelIsProcessValid>(IsProcessValidImpl));
            WriteSlot(funcTable, i++, Pin<DelCloseRemoteProcess>(CloseProcessImpl));
            WriteSlot(funcTable, i++, Pin<DelReadRemoteMemory>(ReadMemoryImpl));
            WriteSlot(funcTable, i++, Pin<DelWriteRemoteMemory>(WriteMemoryImpl));
            WriteSlot(funcTable, i++, Pin<DelEnumSectionsAndModules>(EnumSectionsModulesImpl));
            WriteSlot(funcTable, i++, Pin<DelControlRemoteProcess>(ControlProcessImpl));
        }

        private static IntPtr Pin<T>(T del) where T : class
        {
            Delegate d = del as Delegate;
            s_pinned.Add(d);  // prevent GC
            return Marshal.GetFunctionPointerForDelegate(d);
        }

        private static void WriteSlot(IntPtr table, int index, IntPtr value)
        {
            Marshal.WriteIntPtr(table, index * IntPtr.Size, value);
        }

        // -- Implementation methods -------------------------------------------

        // -- EnumerateProcesses --
        // C++ passes a native callback; we call the plugin, convert each
        // managed EnumerateProcessData to the packed native layout, and
        // forward to the native callback.

        private static void EnumProcessesImpl(IntPtr nativeCallbackPtr)
        {
            try
            {
                if (s_functions == null || nativeCallbackPtr == IntPtr.Zero) return;

                NativeProcessCallback nativeCb =
                    Marshal.GetDelegateForFunctionPointer<NativeProcessCallback>(nativeCallbackPtr);

                // Native layout (pack=1): uint64 Id + char16[260] Name + char16[260] Path
                const int kStructSize = 8 + 520 + 520; // 1048 bytes

                s_functions.EnumerateProcesses(
                    (ref ReClassNET.Core.EnumerateProcessData data) =>
                {
                    IntPtr mem = Marshal.AllocHGlobal(kStructSize);
                    try
                    {
                        // Zero-fill
                        byte[] zeros = new byte[kStructSize];
                        Marshal.Copy(zeros, 0, mem, kStructSize);

                        // Id (8 bytes at offset 0)
                        Marshal.WriteInt64(mem, 0, data.Id.ToInt64());

                        // Name (char16[260] at offset 8)
                        if (data.Name != null)
                        {
                            char[] chars = data.Name.ToCharArray();
                            int count = Math.Min(chars.Length, 259);
                            Marshal.Copy(chars, 0, new IntPtr(mem.ToInt64() + 8), count);
                        }

                        // Path (char16[260] at offset 528)
                        if (data.Path != null)
                        {
                            char[] chars = data.Path.ToCharArray();
                            int count = Math.Min(chars.Length, 259);
                            Marshal.Copy(chars, 0, new IntPtr(mem.ToInt64() + 528), count);
                        }

                        nativeCb(mem);
                    }
                    finally
                    {
                        Marshal.FreeHGlobal(mem);
                    }
                });
            }
            catch { /* swallow -- don't crash the host process */ }
        }

        // -- OpenRemoteProcess --
        private static IntPtr OpenProcessImpl(ulong id, int access)
        {
            try
            {
                if (s_functions == null) return IntPtr.Zero;
                return s_functions.OpenRemoteProcess(
                    new IntPtr((long)id),
                    (ReClassNET.Core.ProcessAccess)access);
            }
            catch { return IntPtr.Zero; }
        }

        // -- IsProcessValid --
        private static bool IsProcessValidImpl(IntPtr handle)
        {
            try
            {
                if (s_functions == null) return false;
                return s_functions.IsProcessValid(handle);
            }
            catch { return false; }
        }

        // -- CloseRemoteProcess --
        private static void CloseProcessImpl(IntPtr handle)
        {
            try { s_functions?.CloseRemoteProcess(handle); }
            catch { }
        }

        // -- ReadRemoteMemory --
        // C++ provides a native buffer pointer. We read into a managed array
        // via the plugin's interface, then copy to the native buffer.
        private static bool ReadMemoryImpl(IntPtr handle, IntPtr address,
            IntPtr buffer, int offset, int size)
        {
            try
            {
                if (s_functions == null || size <= 0) return false;

                byte[] managed = new byte[size];
                bool ok = s_functions.ReadRemoteMemory(
                    handle, address, ref managed, 0, size);

                if (ok)
                    Marshal.Copy(managed, 0, new IntPtr(buffer.ToInt64() + offset), size);

                return ok;
            }
            catch { return false; }
        }

        // -- WriteRemoteMemory --
        private static bool WriteMemoryImpl(IntPtr handle, IntPtr address,
            IntPtr buffer, int offset, int size)
        {
            try
            {
                if (s_functions == null || size <= 0) return false;

                byte[] managed = new byte[size];
                Marshal.Copy(new IntPtr(buffer.ToInt64() + offset), managed, 0, size);

                return s_functions.WriteRemoteMemory(
                    handle, address, ref managed, 0, size);
            }
            catch { return false; }
        }

        // -- EnumerateRemoteSectionsAndModules --
        private static void EnumSectionsModulesImpl(IntPtr handle,
            IntPtr sectionCallbackPtr, IntPtr moduleCallbackPtr)
        {
            try
            {
                if (s_functions == null) return;

                // Section callback -- forward to native
                // Native layout (pack=1): RC_Pointer Base(8) + RC_Size Size(8) +
                //   SectionType(4) + SectionCategory(4) + SectionProtection(4) +
                //   char16 Name[16](32) + char16 ModulePath[260](520) = 580 bytes
                NativeSectionCallback nativeSectionCb = (sectionCallbackPtr != IntPtr.Zero)
                    ? Marshal.GetDelegateForFunctionPointer<NativeSectionCallback>(sectionCallbackPtr)
                    : null;

                // Module callback -- forward to native
                // Native layout (pack=1): RC_Pointer Base(8) + RC_Size Size(8) +
                //   char16 Path[260](520) = 536 bytes
                NativeModuleCallback nativeModuleCb = (moduleCallbackPtr != IntPtr.Zero)
                    ? Marshal.GetDelegateForFunctionPointer<NativeModuleCallback>(moduleCallbackPtr)
                    : null;

                s_functions.EnumerateRemoteSectionsAndModules(handle,
                    // Section callback
                    (ref ReClassNET.Core.EnumerateRemoteSectionData sdata) =>
                    {
                        if (nativeSectionCb == null) return;

                        const int kSize = 8 + 8 + 4 + 4 + 4 + 32 + 520; // 580
                        IntPtr mem = Marshal.AllocHGlobal(kSize);
                        try
                        {
                            byte[] z = new byte[kSize];
                            Marshal.Copy(z, 0, mem, kSize);

                            Marshal.WriteInt64(mem, 0, sdata.BaseAddress.ToInt64());
                            Marshal.WriteInt64(mem, 8, sdata.Size.ToInt64());
                            Marshal.WriteInt32(mem, 16, (int)sdata.Type);
                            Marshal.WriteInt32(mem, 20, (int)sdata.Category);
                            Marshal.WriteInt32(mem, 24, (int)sdata.Protection);

                            if (sdata.Name != null)
                            {
                                char[] c = sdata.Name.ToCharArray();
                                Marshal.Copy(c, 0, new IntPtr(mem.ToInt64() + 28),
                                    Math.Min(c.Length, 15));
                            }
                            if (sdata.ModulePath != null)
                            {
                                char[] c = sdata.ModulePath.ToCharArray();
                                Marshal.Copy(c, 0, new IntPtr(mem.ToInt64() + 60),
                                    Math.Min(c.Length, 259));
                            }

                            nativeSectionCb(mem);
                        }
                        finally { Marshal.FreeHGlobal(mem); }
                    },
                    // Module callback
                    (ref ReClassNET.Core.EnumerateRemoteModuleData mdata) =>
                    {
                        if (nativeModuleCb == null) return;

                        const int kSize = 8 + 8 + 520; // 536
                        IntPtr mem = Marshal.AllocHGlobal(kSize);
                        try
                        {
                            byte[] z = new byte[kSize];
                            Marshal.Copy(z, 0, mem, kSize);

                            Marshal.WriteInt64(mem, 0, mdata.BaseAddress.ToInt64());
                            Marshal.WriteInt64(mem, 8, mdata.Size.ToInt64());

                            if (mdata.Path != null)
                            {
                                char[] c = mdata.Path.ToCharArray();
                                Marshal.Copy(c, 0, new IntPtr(mem.ToInt64() + 16),
                                    Math.Min(c.Length, 259));
                            }

                            nativeModuleCb(mem);
                        }
                        finally { Marshal.FreeHGlobal(mem); }
                    });
            }
            catch { }
        }

        // -- ControlRemoteProcess --
        private static void ControlProcessImpl(IntPtr handle, int action)
        {
            try
            {
                s_functions?.ControlRemoteProcess(handle,
                    (ReClassNET.Core.ControlRemoteProcessAction)action);
            }
            catch { }
        }
    }
}

```

`plugins/RcNetPluginCompatLayer/bridge/RcNetBridge.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <OutputType>Library</OutputType>
    <AssemblyName>RcNetBridge</AssemblyName>
    <RootNamespace>RcNetBridge</RootNamespace>
    <AllowUnsafeBlocks>false</AllowUnsafeBlocks>
    <LangVersion>7.3</LangVersion>
    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    <AppendRuntimeIdentifierToOutputPath>false</AppendRuntimeIdentifierToOutputPath>
  </PropertyGroup>
</Project>

```

`plugins/RemoteProcessMemory/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(RemoteProcessMemory LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt is found by the parent project; QT variable (Qt5 or Qt6) is inherited
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC OFF)   # run uic manually to avoid dupbuild with ProcessMemoryPlugin

# ─── 1. Payload DLL/SO (no Qt, minimal dependencies) ────────────────

add_library(rcx_payload SHARED
    payload/rcx_payload.cpp
    rcx_rpc_protocol.h
)

set_target_properties(rcx_payload PROPERTIES PREFIX "")  # rcx_payload.dll / rcx_payload.so

target_include_directories(rcx_payload PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})

if(WIN32)
    target_link_libraries(rcx_payload PRIVATE psapi)
else()
    target_link_libraries(rcx_payload PRIVATE pthread rt)
    target_compile_options(rcx_payload PRIVATE -fvisibility=hidden)
endif()

# Output payload to Plugins/ (same dir as plugin DLL, discovered at runtime)
set_target_properties(rcx_payload PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)

# Install rule: copy both DLLs to install Plugins/ folder
install(TARGETS rcx_payload
    LIBRARY DESTINATION Plugins
    RUNTIME DESTINATION Plugins
)

# ─── 2. Plugin DLL (Qt, implements IProviderPlugin) ──────────────────

# Generate ui_processpicker.h in our own build dir (avoids dupbuild with ProcessMemoryPlugin)
set(_UI_SRC "${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.ui")
set(_UI_HDR "${CMAKE_CURRENT_BINARY_DIR}/ui_processpicker.h")

add_custom_command(
    OUTPUT  "${_UI_HDR}"
    COMMAND ${QT}::uic -o "${_UI_HDR}" "${_UI_SRC}"
    DEPENDS "${_UI_SRC}"
    COMMENT "UIC processpicker.ui (RemoteProcessMemory)"
    VERBATIM
)

set(PLUGIN_SOURCES
    RemoteProcessMemoryPlugin.h
    RemoteProcessMemoryPlugin.cpp
    rcx_rpc_protocol.h
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.h
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src/processpicker.cpp
    "${_UI_HDR}"
)

add_library(RemoteProcessMemoryPlugin SHARED ${PLUGIN_SOURCES})

target_link_libraries(RemoteProcessMemoryPlugin PRIVATE
    ${QT}::Widgets
    ${_QT_WINEXTRAS}
)

if(WIN32)
    target_link_libraries(RemoteProcessMemoryPlugin PRIVATE psapi shell32)
else()
    target_link_libraries(RemoteProcessMemoryPlugin PRIVATE rt dl)
    target_compile_options(RemoteProcessMemoryPlugin PRIVATE -fvisibility=hidden)
endif()

target_include_directories(RemoteProcessMemoryPlugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_CURRENT_BINARY_DIR}   # for ui_processpicker.h
)

set_target_properties(RemoteProcessMemoryPlugin PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)

install(TARGETS RemoteProcessMemoryPlugin
    LIBRARY DESTINATION Plugins
    RUNTIME DESTINATION Plugins
)

# Plugin must be able to find the payload at runtime
add_dependencies(RemoteProcessMemoryPlugin rcx_payload)

# ─── 3. Test executables (no Qt) ────────────────────────────────────

# Host: loads payload in-process, exposes test buffer
add_executable(test_rpc_host tests/test_rpc_host.cpp)
target_include_directories(test_rpc_host PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
if(WIN32)
    target_link_libraries(test_rpc_host PRIVATE psapi)
else()
    target_link_libraries(test_rpc_host PRIVATE pthread rt dl)
endif()
set_target_properties(test_rpc_host PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)
add_dependencies(test_rpc_host rcx_payload)

# Client: connects to host, tests + benchmarks
add_executable(test_rpc_client tests/test_rpc_client.cpp)
target_include_directories(test_rpc_client PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
if(WIN32)
    target_link_libraries(test_rpc_client PRIVATE psapi)
else()
    target_link_libraries(test_rpc_client PRIVATE pthread rt)
endif()
set_target_properties(test_rpc_client PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)
add_dependencies(test_rpc_client test_rpc_host)

```

`plugins/RemoteProcessMemory/RemoteProcessMemoryPlugin.cpp`:

```cpp
#include "RemoteProcessMemoryPlugin.h"
#include "rcx_rpc_protocol.h"
#include "../../src/processpicker.h"

#include <QStyle>
#include <QApplication>
#include <QMessageBox>
#include <QPushButton>
#include <QDir>
#include <QFileInfo>
#include <QPixmap>
#include <QImage>

#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0) && defined(_WIN32)
#include <QtWin>
#endif

#ifdef _WIN32
#  define WIN32_LEAN_AND_MEAN
#  include <windows.h>
#  include <tlhelp32.h>
#  include <psapi.h>
#  include <shellapi.h>
#else
#  include <unistd.h>
#  include <fcntl.h>
#  include <dlfcn.h>
#  include <sys/mman.h>
#  include <sys/wait.h>
#  include <sys/ptrace.h>
#  include <sys/user.h>
#  include <semaphore.h>
#  include <signal.h>
#  include <link.h>
#  include <climits>
#  include <cstring>
#  include <fstream>
#  include <sstream>
#endif

/* ══════════════════════════════════════════════════════════════════════
 *  IPC Client
 * ══════════════════════════════════════════════════════════════════════ */

struct IpcClient {
#ifdef _WIN32
    HANDLE hShm      = nullptr;
    HANDLE hReqEvent  = nullptr;
    HANDLE hRspEvent  = nullptr;
#else
    int    shmFd      = -1;
    sem_t* reqSem     = SEM_FAILED;
    sem_t* rspSem     = SEM_FAILED;
    char   shmNameBuf[128] = {};
    char   reqNameBuf[128] = {};
    char   rspNameBuf[128] = {};
#endif
    void*  mappedView = nullptr;
    QMutex mutex;
    bool   connected  = false;

    ~IpcClient() { disconnect(); }

    /* ── connect / disconnect ──────────────────────────────────────── */

    bool connect(uint32_t pid, int timeoutMs = 5000)
    {
        char shmName[128], reqName[128], rspName[128];
        rcx_rpc_shm_name(shmName, sizeof(shmName), pid);
        rcx_rpc_req_name(reqName, sizeof(reqName), pid);
        rcx_rpc_rsp_name(rspName, sizeof(rspName), pid);

#ifdef _WIN32
        /* poll for shared memory to appear (payload creating it) */
        auto deadline = GetTickCount64() + (uint64_t)timeoutMs;
        while (!(hShm = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, shmName))) {
            if (GetTickCount64() >= deadline) return false;
            Sleep(10);
        }

        mappedView = MapViewOfFile(hShm, FILE_MAP_ALL_ACCESS, 0, 0, RCX_RPC_SHM_SIZE);
        if (!mappedView) { CloseHandle(hShm); hShm = nullptr; return false; }

        hReqEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, reqName);
        hRspEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, rspName);
        if (!hReqEvent || !hRspEvent) { disconnect(); return false; }
#else
        strncpy(shmNameBuf, shmName, sizeof(shmNameBuf) - 1);
        strncpy(reqNameBuf, reqName, sizeof(reqNameBuf) - 1);
        strncpy(rspNameBuf, rspName, sizeof(rspNameBuf) - 1);

        /* poll for shared memory */
        auto start = std::chrono::steady_clock::now();
        while (true) {
            shmFd = shm_open(shmName, O_RDWR, 0);
            if (shmFd >= 0) break;
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now() - start).count();
            if (elapsed >= timeoutMs) return false;
            usleep(10000);
        }

        mappedView = mmap(nullptr, RCX_RPC_SHM_SIZE, PROT_READ | PROT_WRITE,
                          MAP_SHARED, shmFd, 0);
        if (mappedView == MAP_FAILED) { mappedView = nullptr; close(shmFd); shmFd = -1; return false; }

        reqSem = sem_open(reqName, 0);
        rspSem = sem_open(rspName, 0);
        if (reqSem == SEM_FAILED || rspSem == SEM_FAILED) { disconnect(); return false; }
#endif

        /* wait for payloadReady */
        auto* hdr = static_cast<RcxRpcHeader*>(mappedView);
#ifdef _WIN32
        while (!hdr->payloadReady) {
            if (GetTickCount64() >= deadline) { disconnect(); return false; }
            Sleep(5);
        }
#else
        while (!__atomic_load_n(&hdr->payloadReady, __ATOMIC_ACQUIRE)) {
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now() - start).count();
            if (elapsed >= timeoutMs) { disconnect(); return false; }
            usleep(5000);
        }
#endif

        connected = true;
        return true;
    }

    void disconnect()
    {
#ifdef _WIN32
        if (mappedView) { UnmapViewOfFile(mappedView); mappedView = nullptr; }
        if (hShm)       { CloseHandle(hShm);       hShm       = nullptr; }
        if (hReqEvent)  { CloseHandle(hReqEvent);   hReqEvent  = nullptr; }
        if (hRspEvent)  { CloseHandle(hRspEvent);   hRspEvent  = nullptr; }
#else
        if (mappedView) { munmap(mappedView, RCX_RPC_SHM_SIZE); mappedView = nullptr; }
        if (shmFd >= 0) { close(shmFd); shmFd = -1; }
        if (reqSem != SEM_FAILED) { sem_close(reqSem); reqSem = SEM_FAILED; }
        if (rspSem != SEM_FAILED) { sem_close(rspSem); rspSem = SEM_FAILED; }
#endif
        connected = false;
    }

    /* ── low-level RPC round-trip ──────────────────────────────────── */

    bool signalAndWait(int timeoutMs = 2000)
    {
#ifdef _WIN32
        SetEvent(hReqEvent);
        return WaitForSingleObject(hRspEvent, (DWORD)timeoutMs) == WAIT_OBJECT_0;
#else
        sem_post(reqSem);
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        ts.tv_sec  += timeoutMs / 1000;
        ts.tv_nsec += (timeoutMs % 1000) * 1000000L;
        if (ts.tv_nsec >= 1000000000L) { ts.tv_sec++; ts.tv_nsec -= 1000000000L; }
        return sem_timedwait(rspSem, &ts) == 0;
#endif
    }

    /* ── public API ────────────────────────────────────────────────── */

    bool readSingle(uint64_t addr, void* buf, int len)
    {
        QMutexLocker lock(&mutex);
        if (!connected || len <= 0) return false;

        auto* hdr  = static_cast<RcxRpcHeader*>(mappedView);
        auto* data = static_cast<uint8_t*>(mappedView) + RCX_RPC_DATA_OFFSET;

        hdr->command      = RPC_CMD_READ_BATCH;
        hdr->requestCount = 1;
        hdr->status       = RCX_RPC_STATUS_OK;

        auto* entry       = reinterpret_cast<RcxRpcReadEntry*>(data);
        entry->address    = addr;
        entry->length     = (uint32_t)len;
        entry->dataOffset = sizeof(RcxRpcReadEntry);

        if (!signalAndWait()) { connected = false; return false; }

        memcpy(buf, data + entry->dataOffset, len);
        return true;
    }

    bool writeSingle(uint64_t addr, const void* buf, int len)
    {
        QMutexLocker lock(&mutex);
        if (!connected || len <= 0) return false;

        auto* hdr  = static_cast<RcxRpcHeader*>(mappedView);
        auto* data = static_cast<uint8_t*>(mappedView) + RCX_RPC_DATA_OFFSET;

        hdr->command      = RPC_CMD_WRITE;
        hdr->writeAddress = addr;
        hdr->writeLength  = (uint32_t)len;
        hdr->status       = RCX_RPC_STATUS_OK;

        memcpy(data, buf, len);

        if (!signalAndWait()) { connected = false; return false; }

        return hdr->status == RCX_RPC_STATUS_OK;
    }

    QVector<RemoteProcessProvider::ModuleInfo> enumerateModules()
    {
        QVector<RemoteProcessProvider::ModuleInfo> result;
        QMutexLocker lock(&mutex);
        if (!connected) return result;

        auto* hdr  = static_cast<RcxRpcHeader*>(mappedView);
        auto* data = static_cast<uint8_t*>(mappedView) + RCX_RPC_DATA_OFFSET;

        hdr->command = RPC_CMD_ENUM_MODULES;
        hdr->status  = RCX_RPC_STATUS_OK;

        if (!signalAndWait()) { connected = false; return result; }
        if (hdr->status != RCX_RPC_STATUS_OK) return result;

        uint32_t count = hdr->responseCount;
        result.reserve((int)count);

        for (uint32_t i = 0; i < count; ++i) {
            auto* entry = reinterpret_cast<const RcxRpcModuleEntry*>(
                data + i * sizeof(RcxRpcModuleEntry));

            QString modName;
#ifdef _WIN32
            modName = QString::fromWCharArray(
                reinterpret_cast<const wchar_t*>(data + entry->nameOffset),
                (int)(entry->nameLength / sizeof(wchar_t)));
#else
            modName = QString::fromUtf8(
                reinterpret_cast<const char*>(data + entry->nameOffset),
                (int)entry->nameLength);
#endif
            result.append({modName, entry->base, entry->size});
        }
        return result;
    }

    bool ping()
    {
        QMutexLocker lock(&mutex);
        if (!connected) return false;

        auto* hdr     = static_cast<RcxRpcHeader*>(mappedView);
        hdr->command  = RPC_CMD_PING;
        hdr->status   = RCX_RPC_STATUS_OK;

        if (!signalAndWait()) { connected = false; return false; }
        return true;
    }

    void shutdown()
    {
        QMutexLocker lock(&mutex);
        if (!connected) return;

        auto* hdr     = static_cast<RcxRpcHeader*>(mappedView);
        hdr->command  = RPC_CMD_SHUTDOWN;
        hdr->status   = RCX_RPC_STATUS_OK;

        signalAndWait(500);
        connected = false;
    }
};

/* ══════════════════════════════════════════════════════════════════════
 *  RemoteProcessProvider
 * ══════════════════════════════════════════════════════════════════════ */

RemoteProcessProvider::RemoteProcessProvider(
        uint32_t pid, const QString& processName,
        std::shared_ptr<IpcClient> ipc)
    : m_pid(pid)
    , m_processName(processName)
    , m_connected(ipc && ipc->connected)
    , m_base(0)
    , m_ipc(std::move(ipc))
{
    if (m_connected)
        cacheModules();
}

RemoteProcessProvider::~RemoteProcessProvider() = default;

bool RemoteProcessProvider::read(uint64_t addr, void* buf, int len) const
{
    if (!m_connected || len <= 0) return false;
    bool ok = m_ipc->readSingle(addr, buf, len);
    if (!ok) {
        memset(buf, 0, (size_t)len);
        /* update connectivity flag through mutable ipc */
        const_cast<RemoteProcessProvider*>(this)->m_connected = m_ipc->connected;
    }
    return ok;
}

int RemoteProcessProvider::size() const
{
    return m_connected ? 0x10000 : 0;
}

bool RemoteProcessProvider::write(uint64_t addr, const void* buf, int len)
{
    if (!m_connected || len <= 0) return false;
    bool ok = m_ipc->writeSingle(addr, buf, len);
    if (!ok) m_connected = m_ipc->connected;
    return ok;
}

QString RemoteProcessProvider::getSymbol(uint64_t addr) const
{
    for (const auto& mod : m_modules) {
        if (addr >= mod.base && addr < mod.base + mod.size) {
            uint64_t off = addr - mod.base;
            return QStringLiteral("%1+0x%2")
                .arg(mod.name)
                .arg(off, 0, 16, QChar('0'));
        }
    }
    return {};
}

uint64_t RemoteProcessProvider::symbolToAddress(const QString& n) const
{
    for (const auto& mod : m_modules) {
        if (mod.name.compare(n, Qt::CaseInsensitive) == 0)
            return mod.base;
    }
    return 0;
}

void RemoteProcessProvider::cacheModules()
{
    m_modules = m_ipc->enumerateModules();
    if (!m_modules.isEmpty())
        m_base = m_modules.first().base;
}

/* ══════════════════════════════════════════════════════════════════════
 *  Injection helpers
 * ══════════════════════════════════════════════════════════════════════ */

namespace {

/* Resolve payload DLL/SO path next to this plugin DLL/SO */
static QString payloadPath()
{
#ifdef _WIN32
    HMODULE hSelf = nullptr;
    GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
                       GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                       reinterpret_cast<LPCWSTR>(&payloadPath), &hSelf);
    WCHAR buf[MAX_PATH];
    GetModuleFileNameW(hSelf, buf, MAX_PATH);
    QFileInfo fi(QString::fromWCharArray(buf));
    return fi.absolutePath() + QStringLiteral("/rcx_payload.dll");
#else
    Dl_info info;
    dladdr(reinterpret_cast<void*>(&payloadPath), &info);
    QFileInfo fi(QString::fromUtf8(info.dli_fname));
    return fi.absolutePath() + QStringLiteral("/rcx_payload.so");
#endif
}

#ifdef _WIN32
/* ── Windows injection: CreateRemoteThread + LoadLibraryA ─────────── */

static bool injectPayload(uint32_t pid, QString* errorMsg)
{
    QString path = payloadPath();
    QByteArray pathUtf8 = QDir::toNativeSeparators(path).toLocal8Bit();

    HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProc) {
        if (errorMsg)
            *errorMsg = QStringLiteral("OpenProcess failed (error %1).\n"
                                       "Try running as Administrator.")
                            .arg(GetLastError());
        return false;
    }

    /* allocate + write path string in target */
    SIZE_T pathLen = (SIZE_T)(pathUtf8.size() + 1);
    void* remotePath = VirtualAllocEx(hProc, nullptr, pathLen,
                                      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!remotePath) {
        if (errorMsg) *errorMsg = QStringLiteral("VirtualAllocEx failed.");
        CloseHandle(hProc);
        return false;
    }

    WriteProcessMemory(hProc, remotePath, pathUtf8.constData(), pathLen, nullptr);

    /* Step 1: LoadLibraryA — loads the DLL (DllMain is minimal) */
    HMODULE hK32 = GetModuleHandleA("kernel32.dll");
    auto pLoadLib = reinterpret_cast<LPTHREAD_START_ROUTINE>(
        GetProcAddress(hK32, "LoadLibraryA"));

    HANDLE hThread = CreateRemoteThread(hProc, nullptr, 0,
                                        pLoadLib, remotePath, 0, nullptr);
    if (!hThread) {
        if (errorMsg) *errorMsg = QStringLiteral("CreateRemoteThread failed (error %1).")
                                      .arg(GetLastError());
        VirtualFreeEx(hProc, remotePath, 0, MEM_RELEASE);
        CloseHandle(hProc);
        return false;
    }

    WaitForSingleObject(hThread, 10000);

    DWORD exitCode = 0;
    GetExitCodeThread(hThread, &exitCode);
    CloseHandle(hThread);

    VirtualFreeEx(hProc, remotePath, 0, MEM_RELEASE);

    if (exitCode == 0) {
        CloseHandle(hProc);
        if (errorMsg) *errorMsg = QStringLiteral("LoadLibrary returned NULL in target.\n"
                                                  "Ensure rcx_payload.dll is in: %1").arg(path);
        return false;
    }

    /* Step 2: Call RcxPayloadInit() — safe to create timer queues now
       (loader lock is no longer held after LoadLibrary returned) */
    HMODULE hPayloadRemote = (HMODULE)(uintptr_t)exitCode;
    auto pGetProcAddr = reinterpret_cast<FARPROC(WINAPI*)(HMODULE, LPCSTR)>(
        GetProcAddress(hK32, "GetProcAddress"));

    /* Write "RcxPayloadInit\0" into target, call GetProcAddress remotely */
    const char initName[] = "RcxPayloadInit";
    void* remoteInitName = VirtualAllocEx(hProc, nullptr, sizeof(initName),
                                          MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (remoteInitName) {
        WriteProcessMemory(hProc, remoteInitName, initName, sizeof(initName), nullptr);

        /* We need to call GetProcAddress(hPayload, "RcxPayloadInit") then call the result.
           Simpler approach: write small shellcode that does both calls. */
        uint8_t shellcode[128];
        int off = 0;

        /* sub rsp, 40                   ; shadow space + alignment */
        shellcode[off++] = 0x48; shellcode[off++] = 0x83; shellcode[off++] = 0xEC; shellcode[off++] = 0x28;
        /* mov rcx, hPayloadRemote       ; first arg = module handle */
        shellcode[off++] = 0x48; shellcode[off++] = 0xB9;
        uint64_t hMod = (uint64_t)(uintptr_t)hPayloadRemote;
        memcpy(shellcode + off, &hMod, 8); off += 8;
        /* mov rdx, remoteInitName       ; second arg = "RcxPayloadInit" */
        shellcode[off++] = 0x48; shellcode[off++] = 0xBA;
        uint64_t pName = (uint64_t)(uintptr_t)remoteInitName;
        memcpy(shellcode + off, &pName, 8); off += 8;
        /* mov rax, GetProcAddress       */
        shellcode[off++] = 0x48; shellcode[off++] = 0xB8;
        uint64_t pGPA = (uint64_t)(uintptr_t)pGetProcAddr;
        memcpy(shellcode + off, &pGPA, 8); off += 8;
        /* call rax                      ; rax = RcxPayloadInit */
        shellcode[off++] = 0xFF; shellcode[off++] = 0xD0;
        /* test rax, rax */
        shellcode[off++] = 0x48; shellcode[off++] = 0x85; shellcode[off++] = 0xC0;
        /* jz skip (jump over the call if null) */
        shellcode[off++] = 0x74; shellcode[off++] = 0x02;
        /* call rax                      ; RcxPayloadInit() */
        shellcode[off++] = 0xFF; shellcode[off++] = 0xD0;
        /* skip: add rsp, 40 */
        shellcode[off++] = 0x48; shellcode[off++] = 0x83; shellcode[off++] = 0xC4; shellcode[off++] = 0x28;
        /* ret */
        shellcode[off++] = 0xC3;

        void* remoteCode = VirtualAllocEx(hProc, nullptr, (SIZE_T)off,
                                          MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (remoteCode) {
            WriteProcessMemory(hProc, remoteCode, shellcode, (SIZE_T)off, nullptr);

            HANDLE hThread2 = CreateRemoteThread(hProc, nullptr, 0,
                (LPTHREAD_START_ROUTINE)remoteCode, nullptr, 0, nullptr);
            if (hThread2) {
                WaitForSingleObject(hThread2, 10000);
                CloseHandle(hThread2);
            }
            VirtualFreeEx(hProc, remoteCode, 0, MEM_RELEASE);
        }
        VirtualFreeEx(hProc, remoteInitName, 0, MEM_RELEASE);
    }

    CloseHandle(hProc);
    return true;
}

#else
/* ── Linux injection: ptrace + dlopen ─────────────────────────────── */

static uint64_t findLibBase(pid_t pid, const char* libName)
{
    char mapsPath[64];
    snprintf(mapsPath, sizeof(mapsPath), "/proc/%d/maps", pid);
    FILE* f = fopen(mapsPath, "r");
    if (!f) return 0;

    char line[1024];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, libName)) {
            uint64_t base;
            if (sscanf(line, "%lx-", &base) == 1) {
                fclose(f);
                return base;
            }
        }
    }
    fclose(f);
    return 0;
}

static uint64_t findSyscallInsn(pid_t pid)
{
    char mapsPath[64];
    snprintf(mapsPath, sizeof(mapsPath), "/proc/%d/maps", pid);
    FILE* f = fopen(mapsPath, "r");
    if (!f) return 0;

    char line[1024];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, "libc") && strstr(line, "r-xp")) {
            uint64_t start, end;
            if (sscanf(line, "%lx-%lx", &start, &end) != 2) continue;
            fclose(f);

            /* scan for 0F 05 (syscall) */
            char memPath[64];
            snprintf(memPath, sizeof(memPath), "/proc/%d/mem", pid);
            int memFd = open(memPath, O_RDONLY);
            if (memFd < 0) return 0;

            uint8_t buf[4096];
            for (uint64_t off = start; off < end; off += sizeof(buf)) {
                ssize_t n = pread(memFd, buf, sizeof(buf), (off_t)off);
                if (n <= 1) break;
                for (ssize_t i = 0; i + 1 < n; ++i) {
                    if (buf[i] == 0x0F && buf[i + 1] == 0x05) {
                        close(memFd);
                        return off + (uint64_t)i;
                    }
                }
            }
            close(memFd);
            return 0;
        }
    }
    fclose(f);
    return 0;
}

static bool writeTargetMem(pid_t pid, uint64_t addr, const void* src, size_t len)
{
    const uint8_t* p = static_cast<const uint8_t*>(src);
    for (size_t i = 0; i < len; i += sizeof(long)) {
        long val = 0;
        size_t chunk = (len - i < sizeof(long)) ? (len - i) : sizeof(long);
        if (chunk < sizeof(long)) {
            errno = 0;
            val = ptrace(PTRACE_PEEKDATA, pid, (void*)(addr + i), nullptr);
            if (errno) return false;
        }
        memcpy(&val, p + i, chunk);
        if (ptrace(PTRACE_POKEDATA, pid, (void*)(addr + i), (void*)val) < 0)
            return false;
    }
    return true;
}

static bool injectPayload(uint32_t pid, QString* errorMsg)
{
    QString path = payloadPath();
    QByteArray pathUtf8 = path.toUtf8();

    if (ptrace(PTRACE_ATTACH, (pid_t)pid, nullptr, nullptr) < 0) {
        if (errorMsg)
            *errorMsg = QStringLiteral("ptrace attach failed: %1\n"
                                       "Check /proc/sys/kernel/yama/ptrace_scope or run as root.")
                            .arg(strerror(errno));
        return false;
    }

    int status;
    waitpid((pid_t)pid, &status, 0);

    /* save registers */
    struct user_regs_struct savedRegs, regs;
    ptrace(PTRACE_GETREGS, (pid_t)pid, nullptr, &savedRegs);
    regs = savedRegs;

    /* find syscall instruction in target's libc */
    uint64_t syscallAddr = findSyscallInsn((pid_t)pid);
    if (!syscallAddr) {
        ptrace(PTRACE_DETACH, (pid_t)pid, nullptr, nullptr);
        if (errorMsg) *errorMsg = QStringLiteral("Could not find syscall instruction in target.");
        return false;
    }

    /* find dlopen in target via libc offset technique */
    void* ourDlopen = dlsym(RTLD_DEFAULT, "dlopen");
    uint64_t ourLibcBase = findLibBase(getpid(), "libc");
    uint64_t targetLibcBase = findLibBase((pid_t)pid, "libc");

    if (!ourDlopen || !ourLibcBase || !targetLibcBase) {
        ptrace(PTRACE_DETACH, (pid_t)pid, nullptr, nullptr);
        if (errorMsg) *errorMsg = QStringLiteral("Could not resolve dlopen address.");
        return false;
    }

    uint64_t targetDlopen = targetLibcBase + ((uint64_t)ourDlopen - ourLibcBase);

    /* call mmap in target via syscall: mmap(0, 4096, RWX, MAP_PRIVATE|MAP_ANON, -1, 0) */
    regs.rax = 9;        /* __NR_mmap */
    regs.rdi = 0;
    regs.rsi = 4096;
    regs.rdx = 7;        /* PROT_READ|PROT_WRITE|PROT_EXEC */
    regs.r10 = 0x22;     /* MAP_PRIVATE|MAP_ANONYMOUS */
    regs.r8  = (uint64_t)-1;
    regs.r9  = 0;
    regs.rip = syscallAddr;

    ptrace(PTRACE_SETREGS, (pid_t)pid, nullptr, &regs);
    ptrace(PTRACE_SINGLESTEP, (pid_t)pid, nullptr, nullptr);
    waitpid((pid_t)pid, &status, 0);

    ptrace(PTRACE_GETREGS, (pid_t)pid, nullptr, &regs);
    uint64_t mmapPage = regs.rax;

    if ((int64_t)mmapPage < 0 || mmapPage == 0) {
        ptrace(PTRACE_SETREGS, (pid_t)pid, nullptr, &savedRegs);
        ptrace(PTRACE_DETACH, (pid_t)pid, nullptr, nullptr);
        if (errorMsg) *errorMsg = QStringLiteral("mmap in target failed.");
        return false;
    }

    /* write path string at start of page */
    writeTargetMem((pid_t)pid, mmapPage, pathUtf8.constData(), (size_t)(pathUtf8.size() + 1));

    /* write shellcode after path:
     *   mov rdi, pathAddr     (48 BF xxxxxxxx)
     *   mov rsi, 2            (48 BE 02000000 00000000)
     *   mov rax, dlopenAddr   (48 B8 xxxxxxxx)
     *   call rax              (FF D0)
     *   int3                  (CC)
     */
    uint64_t pathAddr = mmapPage;
    uint64_t codeAddr = mmapPage + ((pathUtf8.size() + 1 + 15) & ~15ULL);

    uint8_t sc[64];
    int len = 0;
    /* mov rdi, imm64 */
    sc[len++] = 0x48; sc[len++] = 0xBF;
    memcpy(sc + len, &pathAddr, 8); len += 8;
    /* mov rsi, 2 (RTLD_NOW) */
    sc[len++] = 0x48; sc[len++] = 0xBE;
    uint64_t rtldNow = 2;
    memcpy(sc + len, &rtldNow, 8); len += 8;
    /* mov rax, dlopen */
    sc[len++] = 0x48; sc[len++] = 0xB8;
    memcpy(sc + len, &targetDlopen, 8); len += 8;
    /* call rax */
    sc[len++] = 0xFF; sc[len++] = 0xD0;
    /* int3 */
    sc[len++] = 0xCC;

    writeTargetMem((pid_t)pid, codeAddr, sc, (size_t)len);

    /* execute shellcode */
    regs = savedRegs;
    regs.rip = codeAddr;
    regs.rsp = (mmapPage + 4096) & ~0xFULL;

    ptrace(PTRACE_SETREGS, (pid_t)pid, nullptr, &regs);
    ptrace(PTRACE_CONT, (pid_t)pid, nullptr, nullptr);
    waitpid((pid_t)pid, &status, 0);

    bool ok = false;
    if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP) {
        ptrace(PTRACE_GETREGS, (pid_t)pid, nullptr, &regs);
        ok = (regs.rax != 0);
    }

    /* clean up: munmap the page via syscall */
    struct user_regs_struct cleanRegs = savedRegs;
    cleanRegs.rax = 11;   /* __NR_munmap */
    cleanRegs.rdi = mmapPage;
    cleanRegs.rsi = 4096;
    cleanRegs.rip = syscallAddr;
    ptrace(PTRACE_SETREGS, (pid_t)pid, nullptr, &cleanRegs);
    ptrace(PTRACE_SINGLESTEP, (pid_t)pid, nullptr, nullptr);
    waitpid((pid_t)pid, &status, 0);

    /* restore and detach */
    ptrace(PTRACE_SETREGS, (pid_t)pid, nullptr, &savedRegs);
    ptrace(PTRACE_DETACH, (pid_t)pid, nullptr, nullptr);

    if (!ok && errorMsg)
        *errorMsg = QStringLiteral("dlopen failed in target.\n"
                                    "Ensure payload is at: %1").arg(path);
    return ok;
}
#endif  /* _WIN32 / linux injection */

} /* anonymous namespace */

/* ══════════════════════════════════════════════════════════════════════
 *  RemoteProcessMemoryPlugin
 * ══════════════════════════════════════════════════════════════════════ */

RemoteProcessMemoryPlugin::RemoteProcessMemoryPlugin() = default;
RemoteProcessMemoryPlugin::~RemoteProcessMemoryPlugin() = default;

QIcon RemoteProcessMemoryPlugin::Icon() const
{
    return qApp->style()->standardIcon(QStyle::SP_DriveNetIcon);
}

bool RemoteProcessMemoryPlugin::canHandle(const QString& target) const
{
    return target.startsWith(QStringLiteral("rpm:"));
}

std::unique_ptr<rcx::Provider>
RemoteProcessMemoryPlugin::createProvider(const QString& target, QString* errorMsg)
{
    /* target = "rpm:{pid}:{name}" */
    QStringList parts = target.split(':');
    if (parts.size() < 3 || parts[0] != QStringLiteral("rpm")) {
        if (errorMsg) *errorMsg = QStringLiteral("Invalid target: ") + target;
        return nullptr;
    }

    bool ok;
    uint32_t pid = parts[1].toUInt(&ok);
    QString name = parts.mid(2).join(':');  /* name may contain colons */

    if (!ok || pid == 0) {
        if (errorMsg) *errorMsg = QStringLiteral("Invalid PID in target.");
        return nullptr;
    }

    auto ipc = getOrCreateConnection(pid, errorMsg);
    if (!ipc) return nullptr;

    return std::make_unique<RemoteProcessProvider>(pid, name, ipc);
}

uint64_t RemoteProcessMemoryPlugin::getInitialBaseAddress(const QString& target) const
{
    /* Read imageBase directly from the shared-memory header -- zero IPC cost.
       The payload filled it at init from PEB->Ldr (Win) / /proc/self/maps (Linux). */
    QStringList parts = target.split(':');
    if (parts.size() < 2 || parts[0] != QStringLiteral("rpm"))
        return 0;

    bool ok;
    uint32_t pid = parts[1].toUInt(&ok);
    if (!ok) return 0;

    QMutexLocker lock(&m_connectionsMutex);
    auto it = m_connections.constFind(pid);
    if (it == m_connections.constEnd() || !(*it)->connected)
        return 0;

    auto* hdr = static_cast<const RcxRpcHeader*>((*it)->mappedView);
    return hdr->imageBase;
}

bool RemoteProcessMemoryPlugin::selectTarget(QWidget* parent, QString* target)
{
    /* ── 1. pick a process ── */
    QVector<PluginProcessInfo> pluginProcs = enumerateProcesses();
    QList<ProcessInfo> procs;
    for (const auto& pi : pluginProcs) {
        ProcessInfo info;
        info.pid  = pi.pid;
        info.name = pi.name;
        info.path = pi.path;
        info.icon = pi.icon;
        procs.append(info);
    }

    ProcessPicker picker(procs, parent);
    if (picker.exec() != QDialog::Accepted) return false;

    uint32_t pid  = picker.selectedProcessId();
    QString  name = picker.selectedProcessName();

    /* ── 2. ask inject or connect ── */
    QMessageBox box(parent);
    box.setWindowTitle(QStringLiteral("Remote Process Memory"));
    box.setText(QStringLiteral("Connect to %1 (PID %2)").arg(name).arg(pid));
    box.setInformativeText(QStringLiteral("Choose how to connect to the target:"));
    QAbstractButton* injectBtn  = box.addButton(QStringLiteral("Inject Payload"),   QMessageBox::ActionRole);
    QAbstractButton* connectBtn = box.addButton(QStringLiteral("Already Injected"), QMessageBox::ActionRole);
    box.addButton(QMessageBox::Cancel);
    box.exec();

    QAbstractButton* clicked = box.clickedButton();
    if (clicked == injectBtn) {
        QString injectErr;
        if (!injectPayload(pid, &injectErr)) {
            QMessageBox::critical(parent, QStringLiteral("Injection Failed"), injectErr);
            return false;
        }

        *target = QStringLiteral("rpm:%1:%2").arg(pid).arg(name);
        return true;
    }
    else if (clicked == connectBtn) {
        *target = QStringLiteral("rpm:%1:%2").arg(pid).arg(name);
        return true;
    }

    return false;
}

QVector<PluginProcessInfo> RemoteProcessMemoryPlugin::enumerateProcesses()
{
    QVector<PluginProcessInfo> procs;

#ifdef _WIN32
    HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snap == INVALID_HANDLE_VALUE) return procs;

    PROCESSENTRY32W entry;
    entry.dwSize = sizeof(entry);

    if (Process32FirstW(snap, &entry)) {
        do {
            PluginProcessInfo info;
            info.pid  = entry.th32ProcessID;
            info.name = QString::fromWCharArray(entry.szExeFile);

            HANDLE hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION,
                                       FALSE, entry.th32ProcessID);
            if (hProc) {
                wchar_t path[MAX_PATH * 2];
                DWORD pathLen = sizeof(path) / sizeof(wchar_t);
                if (QueryFullProcessImageNameW(hProc, 0, path, &pathLen)) {
                    info.path = QString::fromWCharArray(path);
                    SHFILEINFOW sfi = {};
                    if (SHGetFileInfoW(path, 0, &sfi, sizeof(sfi),
                                       SHGFI_ICON | SHGFI_SMALLICON) && sfi.hIcon) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                        info.icon = QIcon(QPixmap::fromImage(QImage::fromHICON(sfi.hIcon)));
#else
                        info.icon = QIcon(QtWin::fromHICON(sfi.hIcon));
#endif
                        DestroyIcon(sfi.hIcon);
                    }
                }
                CloseHandle(hProc);
            }
            procs.append(info);
        } while (Process32NextW(snap, &entry));
    }
    CloseHandle(snap);

#else
    QDir procDir(QStringLiteral("/proc"));
    QIcon defIcon = qApp->style()->standardIcon(QStyle::SP_ComputerIcon);

    for (const QString& entry : procDir.entryList(QDir::Dirs | QDir::NoDotAndDotDot)) {
        bool ok;
        uint32_t pid = entry.toUInt(&ok);
        if (!ok || pid == 0) continue;

        QFile commFile(QStringLiteral("/proc/%1/comm").arg(pid));
        if (!commFile.open(QIODevice::ReadOnly)) continue;
        QString procName = QString::fromUtf8(commFile.readAll()).trimmed();
        commFile.close();
        if (procName.isEmpty()) continue;

        QString memPath = QStringLiteral("/proc/%1/mem").arg(pid);
        if (::access(memPath.toUtf8().constData(), R_OK) != 0) continue;

        QFileInfo exeInfo(QStringLiteral("/proc/%1/exe").arg(pid));
        PluginProcessInfo info;
        info.pid  = pid;
        info.name = procName;
        info.path = exeInfo.exists() ? exeInfo.symLinkTarget() : QString();
        info.icon = defIcon;
        procs.append(info);
    }
#endif

    return procs;
}

std::shared_ptr<IpcClient>
RemoteProcessMemoryPlugin::getOrCreateConnection(
        uint32_t pid, QString* errorMsg)
{
    QMutexLocker lock(&m_connectionsMutex);

    auto it = m_connections.find(pid);
    if (it != m_connections.end() && (*it)->connected)
        return *it;

    auto ipc = std::make_shared<IpcClient>();
    if (!ipc->connect(pid)) {
        if (errorMsg)
            *errorMsg = QStringLiteral("Failed to connect IPC to PID %1.\n"
                                       "Is the payload running?").arg(pid);
        return nullptr;
    }

    m_connections[pid] = ipc;
    return ipc;
}

/* ── Plugin factory ───────────────────────────────────────────────── */

extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin()
{
    return new RemoteProcessMemoryPlugin();
}

```

`plugins/RemoteProcessMemory/RemoteProcessMemoryPlugin.h`:

```h
#pragma once
#include "../../src/iplugin.h"
#include "../../src/providers/provider.h"

#include <cstdint>
#include <memory>
#include <QMutex>
#include <QHash>
#include <QVector>

struct IpcClient;   /* defined in .cpp */

/* ── Provider ─────────────────────────────────────────────────────── */

class RemoteProcessProvider : public rcx::Provider
{
public:
    struct ModuleInfo { QString name; uint64_t base; uint64_t size; };

    RemoteProcessProvider(uint32_t pid, const QString& processName,
                          std::shared_ptr<IpcClient> ipc);
    ~RemoteProcessProvider() override;

    /* required */
    bool read(uint64_t addr, void* buf, int len) const override;
    int  size() const override;

    /* optional */
    bool     write(uint64_t addr, const void* buf, int len) override;
    bool     isWritable() const override { return m_connected; }
    QString  name() const override { return m_processName; }
    QString  kind() const override { return QStringLiteral("RemoteProcess"); }
    bool     isLive() const override { return true; }
    uint64_t base() const override { return m_base; }
    bool     isReadable(uint64_t, int len) const override { return m_connected && len >= 0; }
    QString  getSymbol(uint64_t addr) const override;
    uint64_t symbolToAddress(const QString& n) const override;

    uint32_t pid() const { return m_pid; }

private:
    void cacheModules();

    uint32_t m_pid;
    QString  m_processName;
    bool     m_connected;
    uint64_t m_base;
    mutable std::shared_ptr<IpcClient> m_ipc;
    QVector<ModuleInfo> m_modules;
};

/* ── Plugin ───────────────────────────────────────────────────────── */

class RemoteProcessMemoryPlugin : public IProviderPlugin
{
public:
    RemoteProcessMemoryPlugin();
    ~RemoteProcessMemoryPlugin() override;

    std::string Name() const override        { return "Remote Process Memory"; }
    std::string Version() const override     { return "1.0.0"; }
    std::string Author() const override      { return "Reclass"; }
    std::string Description() const override {
        return "Read/write memory via injected payload (shared-memory IPC)";
    }
    k_ELoadType LoadType() const override { return k_ELoadTypeManual; }
    QIcon Icon() const override;

    bool canHandle(const QString& target) const override;
    std::unique_ptr<rcx::Provider> createProvider(const QString& target,
                                                  QString* errorMsg) override;
    uint64_t getInitialBaseAddress(const QString& target) const override;
    bool selectTarget(QWidget* parent, QString* target) override;

    bool providesProcessList() const override { return true; }
    QVector<PluginProcessInfo> enumerateProcesses() override;

private:
    std::shared_ptr<IpcClient> getOrCreateConnection(
        uint32_t pid, QString* errorMsg);

    mutable QMutex m_connectionsMutex;
    QHash<uint32_t, std::shared_ptr<IpcClient>> m_connections;
};

extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin();

```

`plugins/RemoteProcessMemory/payload/rcx_payload.cpp`:

```cpp
/*
 * rcx_payload  --  injected into target process.
 *
 * Pure Win32 / POSIX, NO Qt, minimal footprint.
 * Creates the main IPC channel (shared memory + events/semaphores)
 * using PID-only naming and uses a timer queue for polling.
 */

#include "../rcx_rpc_protocol.h"

#ifdef _WIN32
/* ===================================================================
 * WINDOWS implementation
 * =================================================================== */
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <psapi.h>

/* ── globals ──────────────────────────────────────────────────────── */
static HANDLE  g_hShm          = nullptr;
static void*   g_mappedView    = nullptr;
static HANDLE  g_hReqEvent     = nullptr;
static HANDLE  g_hRspEvent     = nullptr;
static HANDLE  g_hTimerQueue   = nullptr;
static HANDLE  g_hPollTimer    = nullptr;
static volatile LONG g_initialized = 0;

/* ── memory safety via VirtualQuery ────────────────────────────────── */

inline bool IsReadableProtect(DWORD p)
{
    if (p & (PAGE_NOACCESS | PAGE_GUARD))
        return false;

    const DWORD readable =
        PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY |
        PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY;

    return (p & readable) != 0;
}

inline bool IsWritableProtect(DWORD p)
{
    if (p & (PAGE_NOACCESS | PAGE_GUARD))
        return false;

    const DWORD writable =
        PAGE_READWRITE | PAGE_WRITECOPY |
        PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY;

    return (p & writable) != 0;
}

/* Check that the full range [addr, addr+len) is covered by readable pages. */
static bool IsRangeReadable(uintptr_t addr, uint32_t len)
{
    uintptr_t end = addr + len;
    uintptr_t cur = addr;
    while (cur < end) {
        MEMORY_BASIC_INFORMATION mbi{};
        if (VirtualQuery(reinterpret_cast<LPCVOID>(cur), &mbi, sizeof(mbi)) == 0)
            return false;
        if (mbi.State != MEM_COMMIT || !IsReadableProtect(mbi.Protect))
            return false;
        uintptr_t regionEnd = reinterpret_cast<uintptr_t>(mbi.BaseAddress) + mbi.RegionSize;
        cur = regionEnd;
    }
    return true;
}

static bool IsRangeWritable(uintptr_t addr, uint32_t len)
{
    uintptr_t end = addr + len;
    uintptr_t cur = addr;
    while (cur < end) {
        MEMORY_BASIC_INFORMATION mbi{};
        if (VirtualQuery(reinterpret_cast<LPCVOID>(cur), &mbi, sizeof(mbi)) == 0)
            return false;
        if (mbi.State != MEM_COMMIT || !IsWritableProtect(mbi.Protect))
            return false;
        uintptr_t regionEnd = reinterpret_cast<uintptr_t>(mbi.BaseAddress) + mbi.RegionSize;
        cur = regionEnd;
    }
    return true;
}

/* ── command handlers ─────────────────────────────────────────────── */

static void handle_read_batch(RcxRpcHeader* hdr, uint8_t* data)
{
    auto* entries = reinterpret_cast<RcxRpcReadEntry*>(data);
    for (uint32_t i = 0; i < hdr->requestCount; ++i) {
        uint8_t* dest = data + entries[i].dataOffset;
        uintptr_t src = static_cast<uintptr_t>(entries[i].address);
        if (IsRangeReadable(src, entries[i].length)) {
            memcpy(dest, reinterpret_cast<const void*>(src), entries[i].length);
        } else {
            memset(dest, 0, entries[i].length);
            hdr->status = RCX_RPC_STATUS_PARTIAL;
        }
        /* SEH fallback (commented out, kept for reference):
        __try {
            memcpy(dest, reinterpret_cast<const void*>(src), entries[i].length);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            memset(dest, 0, entries[i].length);
            hdr->status = RCX_RPC_STATUS_PARTIAL;
        }
        */
    }
    hdr->responseCount = hdr->requestCount;
}

static void handle_write(RcxRpcHeader* hdr, uint8_t* data)
{
    uintptr_t dst = static_cast<uintptr_t>(hdr->writeAddress);
    if (IsRangeWritable(dst, hdr->writeLength)) {
        memcpy(reinterpret_cast<void*>(dst), data, hdr->writeLength);
    } else {
        hdr->status = RCX_RPC_STATUS_ERROR;
    }
    /* SEH fallback (commented out, kept for reference):
    __try {
        memcpy(reinterpret_cast<void*>(dst), data, hdr->writeLength);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        hdr->status = RCX_RPC_STATUS_ERROR;
    }
    */
}

static void handle_enum_modules(RcxRpcHeader* hdr, uint8_t* data)
{
    HANDLE hProc = GetCurrentProcess();
    HMODULE mods[1024];
    DWORD needed = 0;
    if (!EnumProcessModules(hProc, mods, sizeof(mods), &needed)) {
        hdr->status = RCX_RPC_STATUS_ERROR;
        hdr->responseCount = 0;
        return;
    }
    int count = (int)(needed / sizeof(HMODULE));
    if (count > 1024) count = 1024;

    uint32_t entryBytes = (uint32_t)(count * sizeof(RcxRpcModuleEntry));
    uint32_t nameDataOff = entryBytes;

    for (int i = 0; i < count; ++i) {
        MODULEINFO mi{};
        WCHAR modName[MAX_PATH];
        GetModuleInformation(hProc, mods[i], &mi, sizeof(mi));
        int nameLen = (int)GetModuleBaseNameW(hProc, mods[i], modName, MAX_PATH);
        uint32_t nameBytes = (uint32_t)(nameLen * sizeof(WCHAR));

        auto* entry = reinterpret_cast<RcxRpcModuleEntry*>(data + i * sizeof(RcxRpcModuleEntry));
        entry->base       = reinterpret_cast<uint64_t>(mi.lpBaseOfDll);
        entry->size       = static_cast<uint64_t>(mi.SizeOfImage);
        entry->nameOffset = nameDataOff;
        entry->nameLength = nameBytes;

        if (nameDataOff + nameBytes <= RCX_RPC_DATA_SIZE) {
            memcpy(data + nameDataOff, modName, nameBytes);
            nameDataOff += nameBytes;
        }
    }

    hdr->responseCount = (uint32_t)count;
    hdr->totalDataUsed = nameDataOff;
    hdr->status        = RCX_RPC_STATUS_OK;
}

/* forward declaration */
void RcxPayloadCleanup();

/* ── timer callback (non-blocking poll) ───────────────────────────── */

static VOID CALLBACK RcxPollTimerCallback(PVOID, BOOLEAN)
{
    if (!g_mappedView || !g_hReqEvent || !g_hRspEvent)
        return;

    /* non-blocking check: is there a pending request? */
    DWORD rc = WaitForSingleObject(g_hReqEvent, 0);
    if (rc != WAIT_OBJECT_0)
        return;

    auto* hdr  = static_cast<RcxRpcHeader*>(g_mappedView);
    auto* data = reinterpret_cast<uint8_t*>(g_mappedView) + RCX_RPC_DATA_OFFSET;

    hdr->status = RCX_RPC_STATUS_OK;

    switch (static_cast<RcxRpcCommand>(hdr->command)) {
    case RPC_CMD_READ_BATCH:   handle_read_batch(hdr, data); break;
    case RPC_CMD_WRITE:        handle_write(hdr, data);      break;
    case RPC_CMD_ENUM_MODULES: handle_enum_modules(hdr, data); break;
    case RPC_CMD_PING:         break;
    case RPC_CMD_SHUTDOWN:
        RcxPayloadCleanup();
        return;
    default:
        hdr->status = RCX_RPC_STATUS_ERROR;
        break;
    }

    SetEvent(g_hRspEvent);
}

/* ── cleanup ──────────────────────────────────────────────────────── */

void RcxPayloadCleanup()
{
    if (!InterlockedCompareExchange(&g_initialized, 0, 0))
        return;

    /* stop the poll timer first */
    if (g_hTimerQueue) {
        DeleteTimerQueueEx(g_hTimerQueue, INVALID_HANDLE_VALUE); /* waits for callbacks */
        g_hTimerQueue = nullptr;
        g_hPollTimer  = nullptr;
    }

    /* mark not-ready */
    if (g_mappedView) {
        auto* hdr = static_cast<RcxRpcHeader*>(g_mappedView);
        InterlockedExchange(reinterpret_cast<volatile LONG*>(&hdr->payloadReady), 0);
    }

    if (g_mappedView) { UnmapViewOfFile(g_mappedView); g_mappedView = nullptr; }
    if (g_hShm)       { CloseHandle(g_hShm);           g_hShm       = nullptr; }
    if (g_hReqEvent)  { CloseHandle(g_hReqEvent);      g_hReqEvent  = nullptr; }
    if (g_hRspEvent)  { CloseHandle(g_hRspEvent);      g_hRspEvent  = nullptr; }

    InterlockedExchange(&g_initialized, 0);
}

/* ── init (called AFTER DllMain returns — safe for timer queues) ── */

extern "C" __declspec(dllexport)
bool RcxPayloadInit()
{
    if (InterlockedCompareExchange(&g_initialized, 1, 0) != 0)
        return true;   /* already initialized */

    uint32_t pid = GetCurrentProcessId();

    char shmName[128], reqName[128], rspName[128];
    rcx_rpc_shm_name(shmName, sizeof(shmName), pid);
    rcx_rpc_req_name(reqName, sizeof(reqName), pid);
    rcx_rpc_rsp_name(rspName, sizeof(rspName), pid);

    g_hShm = CreateFileMappingA(INVALID_HANDLE_VALUE, nullptr,
                                PAGE_READWRITE, 0, RCX_RPC_SHM_SIZE, shmName);
    if (!g_hShm) {
        InterlockedExchange(&g_initialized, 0);
        return false;
    }

    g_mappedView = MapViewOfFile(g_hShm, FILE_MAP_ALL_ACCESS, 0, 0, RCX_RPC_SHM_SIZE);
    if (!g_mappedView) {
        CloseHandle(g_hShm); g_hShm = nullptr;
        InterlockedExchange(&g_initialized, 0);
        return false;
    }

    memset(g_mappedView, 0, RCX_RPC_HEADER_SIZE);
    auto* hdr = static_cast<RcxRpcHeader*>(g_mappedView);
    hdr->version = RCX_RPC_VERSION;

    /* image base from PEB */
    {
        uint64_t peb;
        asm volatile("mov %%gs:0x60, %0" : "=r"(peb));
        uint64_t ldr       = *reinterpret_cast<uint64_t*>(peb + 0x18);
        uint64_t firstLink = *reinterpret_cast<uint64_t*>(ldr + 0x10);
        hdr->imageBase     = *reinterpret_cast<uint64_t*>(firstLink + 0x30);
    }

    g_hReqEvent = CreateEventA(nullptr, FALSE, FALSE, reqName);
    g_hRspEvent = CreateEventA(nullptr, FALSE, FALSE, rspName);
    if (!g_hReqEvent || !g_hRspEvent) {
        RcxPayloadCleanup();
        return false;
    }

    /* create dedicated timer queue + fast poll timer (10ms interval) */
    g_hTimerQueue = CreateTimerQueue();
    if (!g_hTimerQueue) {
        RcxPayloadCleanup();
        return false;
    }

    if (!CreateTimerQueueTimer(&g_hPollTimer, g_hTimerQueue,
                               RcxPollTimerCallback, nullptr,
                               0,     /* start immediately */
                               10,    /* 10ms repeat */
                               WT_EXECUTEDEFAULT)) {
        RcxPayloadCleanup();
        return false;
    }

    /* mark ready */
    InterlockedExchange(reinterpret_cast<volatile LONG*>(&hdr->payloadReady), 1);
    return true;
}

/* ── DllMain — minimal, no heavy work under loader lock ───────────── */

BOOL WINAPI DllMain(HINSTANCE, DWORD reason, LPVOID)
{
    if (reason == DLL_PROCESS_DETACH) {
        RcxPayloadCleanup();
    }
    return TRUE;
}

#else
/* ===================================================================
 * LINUX implementation
 * =================================================================== */
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <errno.h>
#include <time.h>
#include <signal.h>

/* ── globals ──────────────────────────────────────────────────────── */
static int       g_shmFd     = -1;
static void*     g_mappedView = nullptr;
static sem_t*    g_reqSem    = SEM_FAILED;
static sem_t*    g_rspSem    = SEM_FAILED;
static pthread_t g_thread;
static volatile int g_shutdown  = 0;
static volatile int g_threadRunning = 0;
static int       g_memFd     = -1;   /* /proc/self/mem for safe access */
static char      g_shmName[128];
static char      g_reqName[128];
static char      g_rspName[128];

/* ── safe memory access via /proc/self/mem ────────────────────────── */

static void safe_read(uint64_t addr, void* dest, uint32_t len, uint32_t* status)
{
    ssize_t n = pread(g_memFd, dest, len, (off_t)addr);
    if (n < (ssize_t)len) {
        if (n > 0)
            memset((uint8_t*)dest + n, 0, len - (uint32_t)n);
        else
            memset(dest, 0, len);
        *status = RCX_RPC_STATUS_PARTIAL;
    }
}

static void safe_write(uint64_t addr, const void* src, uint32_t len, uint32_t* status)
{
    ssize_t n = pwrite(g_memFd, src, len, (off_t)addr);
    if (n < (ssize_t)len)
        *status = RCX_RPC_STATUS_ERROR;
}

/* ── command handlers ─────────────────────────────────────────────── */

static void handle_read_batch(RcxRpcHeader* hdr, uint8_t* data)
{
    auto* entries = reinterpret_cast<RcxRpcReadEntry*>(data);
    for (uint32_t i = 0; i < hdr->requestCount; ++i) {
        uint8_t* dest = data + entries[i].dataOffset;
        safe_read(entries[i].address, dest, entries[i].length, &hdr->status);
    }
    hdr->responseCount = hdr->requestCount;
}

static void handle_write(RcxRpcHeader* hdr, uint8_t* data)
{
    safe_write(hdr->writeAddress, data, hdr->writeLength, &hdr->status);
}

static void handle_enum_modules(RcxRpcHeader* hdr, uint8_t* data)
{
    FILE* f = fopen("/proc/self/maps", "r");
    if (!f) {
        hdr->status = RCX_RPC_STATUS_ERROR;
        hdr->responseCount = 0;
        return;
    }

    /* first pass: collect unique file-backed mappings */
    struct ModRange { uint64_t base; uint64_t end; char path[512]; };
    static ModRange modules[512];  /* static to avoid large stack alloc */
    int modCount = 0;

    char line[1024];
    while (fgets(line, sizeof(line), f) && modCount < 512) {
        uint64_t start, end;
        char perms[8] = {}, path[512] = {};
        if (sscanf(line, "%lx-%lx %7s %*x %*x:%*x %*u %511[^\n]",
                   &start, &end, perms, path) < 4)
            continue;

        /* skip non-file / special mappings */
        /* trim leading whitespace from path */
        char* p = path;
        while (*p == ' ' || *p == '\t') ++p;
        if (*p != '/') continue;
        if (strncmp(p, "/dev/", 5) == 0) continue;
        if (strncmp(p, "/memfd:", 7) == 0) continue;

        bool found = false;
        for (int i = 0; i < modCount; ++i) {
            if (strcmp(modules[i].path, p) == 0) {
                if (start < modules[i].base) modules[i].base = start;
                if (end   > modules[i].end)  modules[i].end  = end;
                found = true;
                break;
            }
        }
        if (!found) {
            modules[modCount].base = start;
            modules[modCount].end  = end;
            strncpy(modules[modCount].path, p, 511);
            modules[modCount].path[511] = '\0';
            ++modCount;
        }
    }
    fclose(f);

    /* write entries + name strings into data region */
    uint32_t entryBytes  = (uint32_t)(modCount * sizeof(RcxRpcModuleEntry));
    uint32_t nameDataOff = entryBytes;

    for (int i = 0; i < modCount; ++i) {
        const char* basename = strrchr(modules[i].path, '/');
        basename = basename ? basename + 1 : modules[i].path;
        uint32_t nameLen = (uint32_t)strlen(basename);

        auto* entry = reinterpret_cast<RcxRpcModuleEntry*>(
            data + (uint32_t)i * sizeof(RcxRpcModuleEntry));
        entry->base       = modules[i].base;
        entry->size       = modules[i].end - modules[i].base;
        entry->nameOffset = nameDataOff;
        entry->nameLength = nameLen;

        if (nameDataOff + nameLen <= RCX_RPC_DATA_SIZE) {
            memcpy(data + nameDataOff, basename, nameLen);
            nameDataOff += nameLen;
        }
    }

    hdr->responseCount = (uint32_t)modCount;
    hdr->totalDataUsed = nameDataOff;
    hdr->status        = RCX_RPC_STATUS_OK;
}

/* ── server thread ────────────────────────────────────────────────── */

static void* server_thread_func(void*)
{
    auto* hdr  = static_cast<RcxRpcHeader*>(g_mappedView);
    auto* data = reinterpret_cast<uint8_t*>(g_mappedView) + RCX_RPC_DATA_OFFSET;

    __atomic_store_n(&hdr->payloadReady, 1, __ATOMIC_RELEASE);

    while (!__atomic_load_n(&g_shutdown, __ATOMIC_ACQUIRE)) {
        /* timed wait: 250ms */
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        ts.tv_nsec += 250000000;
        if (ts.tv_nsec >= 1000000000) {
            ts.tv_sec  += 1;
            ts.tv_nsec -= 1000000000;
        }

        int rc = sem_timedwait(g_reqSem, &ts);
        if (rc != 0) {
            if (errno == ETIMEDOUT) continue;
            break;
        }

        hdr->status = RCX_RPC_STATUS_OK;

        switch (static_cast<RcxRpcCommand>(hdr->command)) {
        case RPC_CMD_READ_BATCH:   handle_read_batch(hdr, data); break;
        case RPC_CMD_WRITE:        handle_write(hdr, data);      break;
        case RPC_CMD_ENUM_MODULES: handle_enum_modules(hdr, data); break;
        case RPC_CMD_PING:         break;
        case RPC_CMD_SHUTDOWN:
            __atomic_store_n(&g_shutdown, 1, __ATOMIC_RELEASE);
            break;
        default:
            hdr->status = RCX_RPC_STATUS_ERROR;
            break;
        }

        sem_post(g_rspSem);

        if (static_cast<RcxRpcCommand>(hdr->command) == RPC_CMD_SHUTDOWN)
            break;
    }

    __atomic_store_n(&hdr->payloadReady, 0, __ATOMIC_RELEASE);
    __atomic_store_n(&g_threadRunning, 0, __ATOMIC_RELEASE);
    return nullptr;
}

/* ── init / cleanup ───────────────────────────────────────────────── */

static void payload_cleanup()
{
    __atomic_store_n(&g_shutdown, 1, __ATOMIC_RELEASE);

    /* wake the thread if blocked */
    if (g_reqSem != SEM_FAILED) sem_post(g_reqSem);

    if (__atomic_load_n(&g_threadRunning, __ATOMIC_ACQUIRE)) {
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        ts.tv_sec += 2;
        pthread_timedjoin_np(g_thread, nullptr, &ts);
    }

    if (g_mappedView && g_mappedView != MAP_FAILED) {
        munmap(g_mappedView, RCX_RPC_SHM_SIZE);
        g_mappedView = nullptr;
    }
    if (g_shmFd >= 0) { close(g_shmFd); g_shmFd = -1; }
    if (g_reqSem != SEM_FAILED) { sem_close(g_reqSem); g_reqSem = SEM_FAILED; }
    if (g_rspSem != SEM_FAILED) { sem_close(g_rspSem); g_rspSem = SEM_FAILED; }

    /* unlink named objects */
    if (g_shmName[0]) shm_unlink(g_shmName);
    if (g_reqName[0]) sem_unlink(g_reqName);
    if (g_rspName[0]) sem_unlink(g_rspName);

    if (g_memFd >= 0) { close(g_memFd); g_memFd = -1; }
}

__attribute__((constructor))
static void payload_init()
{
    uint32_t pid = (uint32_t)getpid();

    /* ── open /proc/self/mem for safe access ── */
    g_memFd = open("/proc/self/mem", O_RDWR);
    if (g_memFd < 0) return;

    /* ── create main shared memory (PID-only naming) ── */
    rcx_rpc_shm_name(g_shmName, sizeof(g_shmName), pid);
    rcx_rpc_req_name(g_reqName, sizeof(g_reqName), pid);
    rcx_rpc_rsp_name(g_rspName, sizeof(g_rspName), pid);

    g_shmFd = shm_open(g_shmName, O_CREAT | O_RDWR, 0600);
    if (g_shmFd < 0) return;
    if (ftruncate(g_shmFd, RCX_RPC_SHM_SIZE) != 0) {
        close(g_shmFd); g_shmFd = -1; return;
    }

    g_mappedView = mmap(nullptr, RCX_RPC_SHM_SIZE, PROT_READ | PROT_WRITE,
                        MAP_SHARED, g_shmFd, 0);
    if (g_mappedView == MAP_FAILED) {
        g_mappedView = nullptr;
        close(g_shmFd); g_shmFd = -1;
        return;
    }

    memset(g_mappedView, 0, RCX_RPC_HEADER_SIZE);
    auto* hdr = static_cast<RcxRpcHeader*>(g_mappedView);
    hdr->version = RCX_RPC_VERSION;

    /* image base from /proc/self/maps: first executable mapping */
    {
        FILE* f = fopen("/proc/self/maps", "r");
        if (f) {
            char line[256];
            while (fgets(line, sizeof(line), f)) {
                uint64_t start;
                char perms[8] = {};
                if (sscanf(line, "%lx-%*x %7s", &start, perms) >= 2 && perms[2] == 'x') {
                    hdr->imageBase = start;
                    break;
                }
            }
            fclose(f);
        }
    }

    /* ── create semaphores ── */
    g_reqSem = sem_open(g_reqName, O_CREAT, 0600, 0);
    g_rspSem = sem_open(g_rspName, O_CREAT, 0600, 0);
    if (g_reqSem == SEM_FAILED || g_rspSem == SEM_FAILED) {
        payload_cleanup();
        return;
    }

    /* ── start server thread (it will set payloadReady = 1) ── */
    __atomic_store_n(&g_threadRunning, 1, __ATOMIC_RELEASE);
    if (pthread_create(&g_thread, nullptr, server_thread_func, nullptr) != 0) {
        __atomic_store_n(&g_threadRunning, 0, __ATOMIC_RELEASE);
        payload_cleanup();
        return;
    }
    pthread_detach(g_thread);
}

__attribute__((destructor))
static void payload_deinit()
{
    payload_cleanup();
}

#endif /* _WIN32 / linux */

```

`plugins/RemoteProcessMemory/rcx_rpc_protocol.h`:

```h
/*
 * RCX RPC Protocol  --  shared between plugin DLL and payload DLL/SO.
 * No dependencies beyond standard C headers.
 */
#pragma once

#include <stdint.h>
#include <stdio.h>
#include <string.h>

/* ── constants ─────────────────────────────────────────────────────── */
#define RCX_RPC_VERSION       1
#define RCX_RPC_MAX_BATCH     256
#define RCX_RPC_SHM_SIZE      (1024 * 1024)     /* 1 MB                */
#define RCX_RPC_HEADER_SIZE   4096
#define RCX_RPC_DATA_OFFSET   RCX_RPC_HEADER_SIZE
#define RCX_RPC_DATA_SIZE     (RCX_RPC_SHM_SIZE - RCX_RPC_DATA_OFFSET)

/* status codes */
#define RCX_RPC_STATUS_OK       0
#define RCX_RPC_STATUS_ERROR    1
#define RCX_RPC_STATUS_PARTIAL  2

/* ── commands ──────────────────────────────────────────────────────── */
#ifdef __cplusplus
enum RcxRpcCommand : uint32_t {
#else
typedef uint32_t RcxRpcCommand;
enum {
#endif
    RPC_CMD_NONE         = 0,
    RPC_CMD_READ_BATCH   = 1,   /* batch read: N {address, length} pairs  */
    RPC_CMD_WRITE        = 2,   /* single write                           */
    RPC_CMD_ENUM_MODULES = 3,   /* enumerate loaded modules               */
    RPC_CMD_PING         = 4,   /* heartbeat                              */
    RPC_CMD_SHUTDOWN     = 5,   /* graceful teardown                      */
};

/* ── wire structs (natural alignment, verified by static_assert) ─── */

struct RcxRpcReadEntry {
    uint64_t address;
    uint32_t length;
    uint32_t dataOffset;   /* offset into data region for response bytes */
};

struct RcxRpcModuleEntry {
    uint64_t base;
    uint64_t size;
    uint32_t nameOffset;   /* offset into data region, UTF-16 on Win, UTF-8 on Linux */
    uint32_t nameLength;   /* in bytes */
};

/*
 * Header -- lives at shared-memory offset 0, padded to 4096 bytes.
 *
 *   offset  field
 *   ------  -----
 *     0     version          (4)
 *     4     payloadReady     (4)
 *     8     command          (4)
 *    12     requestCount     (4)
 *    16     writeAddress     (8)
 *    24     writeLength      (4)
 *    28     status           (4)
 *    32     responseCount    (4)
 *    36     totalDataUsed    (4)
 *    40     imageBase        (8)  -- main module base from PEB / procfs
 *    48     _pad[4048]
 */
struct RcxRpcHeader {
    uint32_t version;
    uint32_t payloadReady;     /* payload sets to 1 after init */
    uint32_t command;          /* RcxRpcCommand                */
    uint32_t requestCount;
    uint64_t writeAddress;
    uint32_t writeLength;
    uint32_t status;           /* RCX_RPC_STATUS_*             */
    uint32_t responseCount;
    uint32_t totalDataUsed;
    uint64_t imageBase;        /* main module base (PEB on Win, /proc on Linux) */
    uint8_t  _pad[RCX_RPC_HEADER_SIZE - 48];
};

/* ── name formatting helpers (PID-only, no nonce) ─────────────────── */

static inline void rcx_rpc_shm_name(char* buf, int n, uint32_t pid) {
#ifdef _WIN32
    snprintf(buf, n, "Local\\RCX_SHM_%u", pid);
#else
    snprintf(buf, n, "/rcx_shm_%u", pid);
#endif
}

static inline void rcx_rpc_req_name(char* buf, int n, uint32_t pid) {
#ifdef _WIN32
    snprintf(buf, n, "Local\\RCX_REQ_%u", pid);
#else
    snprintf(buf, n, "/rcx_req_%u", pid);
#endif
}

static inline void rcx_rpc_rsp_name(char* buf, int n, uint32_t pid) {
#ifdef _WIN32
    snprintf(buf, n, "Local\\RCX_RSP_%u", pid);
#else
    snprintf(buf, n, "/rcx_rsp_%u", pid);
#endif
}

#ifdef __cplusplus
static_assert(sizeof(RcxRpcHeader) == RCX_RPC_HEADER_SIZE, "Header must be 4096 bytes");
#endif

```

`plugins/RemoteProcessMemory/tests/test_rpc_client.cpp`:

```cpp
/*
 * test_rpc_client  --  connects to a running test_rpc_host (or spawns one),
 *                      exercises every RPC command, and benchmarks throughput.
 *
 * Usage:
 *   test_rpc_client                          (auto-spawn host)
 *   test_rpc_client <pid> [testbuf_hex testlen]
 */

#include "../rcx_rpc_protocol.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <assert.h>
#include <chrono>

#ifdef _WIN32
#  define WIN32_LEAN_AND_MEAN
#  include <windows.h>
#else
#  include <unistd.h>
#  include <fcntl.h>
#  include <sys/mman.h>
#  include <semaphore.h>
#  include <libgen.h>
#  include <limits.h>
#endif

/* ══════════════════════════════════════════════════════════════════════
 *  Minimal standalone IPC client (no Qt, mirrors plugin's IpcClient)
 * ══════════════════════════════════════════════════════════════════════ */

struct TestIpcClient {
#ifdef _WIN32
    HANDLE hShm      = nullptr;
    HANDLE hReqEvent  = nullptr;
    HANDLE hRspEvent  = nullptr;
#else
    int    shmFd      = -1;
    sem_t* reqSem     = SEM_FAILED;
    sem_t* rspSem     = SEM_FAILED;
#endif
    void*  view       = nullptr;
    bool   ok         = false;

    bool connect(uint32_t pid, int timeoutMs = 5000)
    {
        char shmName[128], reqName[128], rspName[128];
        rcx_rpc_shm_name(shmName, sizeof(shmName), pid);
        rcx_rpc_req_name(reqName, sizeof(reqName), pid);
        rcx_rpc_rsp_name(rspName, sizeof(rspName), pid);

#ifdef _WIN32
        ULONGLONG deadline = GetTickCount64() + (ULONGLONG)timeoutMs;
        while (!(hShm = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, shmName))) {
            if (GetTickCount64() >= deadline) return false;
            Sleep(10);
        }
        view = MapViewOfFile(hShm, FILE_MAP_ALL_ACCESS, 0, 0, RCX_RPC_SHM_SIZE);
        if (!view) { CloseHandle(hShm); hShm = nullptr; return false; }

        hReqEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, reqName);
        hRspEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, rspName);
        if (!hReqEvent || !hRspEvent) return false;
#else
        auto start = std::chrono::steady_clock::now();
        while (true) {
            shmFd = shm_open(shmName, O_RDWR, 0);
            if (shmFd >= 0) break;
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now() - start).count();
            if (elapsed >= timeoutMs) return false;
            usleep(10000);
        }
        view = mmap(nullptr, RCX_RPC_SHM_SIZE, PROT_READ | PROT_WRITE,
                     MAP_SHARED, shmFd, 0);
        if (view == MAP_FAILED) { view = nullptr; close(shmFd); shmFd = -1; return false; }

        reqSem = sem_open(reqName, 0);
        rspSem = sem_open(rspName, 0);
        if (reqSem == SEM_FAILED || rspSem == SEM_FAILED) return false;
#endif
        /* wait for payloadReady */
        auto* hdr = (RcxRpcHeader*)view;
#ifdef _WIN32
        while (!hdr->payloadReady) {
            if (GetTickCount64() >= deadline) return false;
            Sleep(5);
        }
#else
        while (!__atomic_load_n(&hdr->payloadReady, __ATOMIC_ACQUIRE)) {
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now() - start).count();
            if (elapsed >= timeoutMs) return false;
            usleep(5000);
        }
#endif
        ok = true;
        return true;
    }

    void disconnect()
    {
#ifdef _WIN32
        if (view)      { UnmapViewOfFile(view); view = nullptr; }
        if (hShm)      { CloseHandle(hShm);      hShm = nullptr; }
        if (hReqEvent) { CloseHandle(hReqEvent);  hReqEvent = nullptr; }
        if (hRspEvent) { CloseHandle(hRspEvent);  hRspEvent = nullptr; }
#else
        if (view) { munmap(view, RCX_RPC_SHM_SIZE); view = nullptr; }
        if (shmFd >= 0) { close(shmFd); shmFd = -1; }
        if (reqSem != SEM_FAILED) { sem_close(reqSem); reqSem = SEM_FAILED; }
        if (rspSem != SEM_FAILED) { sem_close(rspSem); rspSem = SEM_FAILED; }
#endif
        ok = false;
    }

    bool signalAndWait(int timeoutMs = 2000)
    {
#ifdef _WIN32
        SetEvent(hReqEvent);
        return WaitForSingleObject(hRspEvent, (DWORD)timeoutMs) == WAIT_OBJECT_0;
#else
        sem_post(reqSem);
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        ts.tv_sec  += timeoutMs / 1000;
        ts.tv_nsec += (timeoutMs % 1000) * 1000000L;
        if (ts.tv_nsec >= 1000000000L) { ts.tv_sec++; ts.tv_nsec -= 1000000000L; }
        return sem_timedwait(rspSem, &ts) == 0;
#endif
    }

    /* ── RPC helpers ──────────────────────────────────────────────── */

    bool rpc_ping()
    {
        auto* hdr = (RcxRpcHeader*)view;
        hdr->command = RPC_CMD_PING;
        hdr->status  = RCX_RPC_STATUS_OK;
        return signalAndWait();
    }

    bool rpc_read(uint64_t addr, void* buf, uint32_t len)
    {
        auto* hdr  = (RcxRpcHeader*)view;
        auto* data = (uint8_t*)view + RCX_RPC_DATA_OFFSET;

        hdr->command      = RPC_CMD_READ_BATCH;
        hdr->requestCount = 1;
        hdr->status       = RCX_RPC_STATUS_OK;

        auto* entry       = (RcxRpcReadEntry*)data;
        entry->address    = addr;
        entry->length     = len;
        entry->dataOffset = sizeof(RcxRpcReadEntry);

        if (!signalAndWait()) return false;
        memcpy(buf, data + entry->dataOffset, len);
        return true;
    }

    bool rpc_read_batch(const uint64_t* addrs, const uint32_t* lens,
                        uint32_t count, uint8_t* outBuf)
    {
        auto* hdr  = (RcxRpcHeader*)view;
        auto* data = (uint8_t*)view + RCX_RPC_DATA_OFFSET;

        hdr->command      = RPC_CMD_READ_BATCH;
        hdr->requestCount = count;
        hdr->status       = RCX_RPC_STATUS_OK;

        /* lay out entries, then data offsets after all entries */
        uint32_t entriesSize = count * (uint32_t)sizeof(RcxRpcReadEntry);
        uint32_t dataOff = entriesSize;

        for (uint32_t i = 0; i < count; ++i) {
            auto* e = (RcxRpcReadEntry*)(data + i * sizeof(RcxRpcReadEntry));
            e->address    = addrs[i];
            e->length     = lens[i];
            e->dataOffset = dataOff;
            dataOff += lens[i];
        }

        if (!signalAndWait()) return false;

        /* copy out response data */
        uint32_t off = 0;
        for (uint32_t i = 0; i < count; ++i) {
            auto* e = (RcxRpcReadEntry*)(data + i * sizeof(RcxRpcReadEntry));
            memcpy(outBuf + off, data + e->dataOffset, e->length);
            off += e->length;
        }
        return true;
    }

    bool rpc_write(uint64_t addr, const void* buf, uint32_t len)
    {
        auto* hdr  = (RcxRpcHeader*)view;
        auto* data = (uint8_t*)view + RCX_RPC_DATA_OFFSET;

        hdr->command      = RPC_CMD_WRITE;
        hdr->writeAddress = addr;
        hdr->writeLength  = len;
        hdr->status       = RCX_RPC_STATUS_OK;
        memcpy(data, buf, len);

        if (!signalAndWait()) return false;
        return hdr->status == RCX_RPC_STATUS_OK;
    }

    struct ModInfo { uint64_t base; uint64_t size; char name[256]; };

    int rpc_enum_modules(ModInfo* out, int maxOut)
    {
        auto* hdr  = (RcxRpcHeader*)view;
        auto* data = (uint8_t*)view + RCX_RPC_DATA_OFFSET;

        hdr->command = RPC_CMD_ENUM_MODULES;
        hdr->status  = RCX_RPC_STATUS_OK;

        if (!signalAndWait()) return -1;
        if (hdr->status != RCX_RPC_STATUS_OK) return -1;

        int count = (int)hdr->responseCount;
        if (count > maxOut) count = maxOut;

        for (int i = 0; i < count; ++i) {
            auto* entry = (RcxRpcModuleEntry*)(data + i * sizeof(RcxRpcModuleEntry));
            out[i].base = entry->base;
            out[i].size = entry->size;
#ifdef _WIN32
            /* names are UTF-16 on Windows */
            int wchars = (int)(entry->nameLength / sizeof(wchar_t));
            WideCharToMultiByte(CP_UTF8, 0,
                (const wchar_t*)(data + entry->nameOffset), wchars,
                out[i].name, 255, nullptr, nullptr);
            out[i].name[255] = '\0';
#else
            int nLen = (int)entry->nameLength;
            if (nLen > 255) nLen = 255;
            memcpy(out[i].name, data + entry->nameOffset, nLen);
            out[i].name[nLen] = '\0';
#endif
        }
        return count;
    }

    void rpc_shutdown()
    {
        auto* hdr = (RcxRpcHeader*)view;
        hdr->command = RPC_CMD_SHUTDOWN;
        hdr->status  = RCX_RPC_STATUS_OK;
        signalAndWait(500);
    }
};

/* ══════════════════════════════════════════════════════════════════════
 *  Auto-spawn host
 * ══════════════════════════════════════════════════════════════════════ */

#ifdef _WIN32
static HANDLE g_hostProcess = nullptr;
#else
static pid_t  g_hostPid = 0;
#endif
static FILE*  g_hostPipe = nullptr;

static bool spawn_host(uint32_t* outPid,
                        uint64_t* outTestBuf, uint32_t* outTestLen)
{
    /* resolve path to test_rpc_host next to ourselves */
    char cmd[2048];
#ifdef _WIN32
    char exePath[MAX_PATH];
    GetModuleFileNameA(nullptr, exePath, MAX_PATH);
    char* slash = strrchr(exePath, '\\');
    if (!slash) slash = strrchr(exePath, '/');
    if (slash) *(slash + 1) = '\0';
    snprintf(cmd, sizeof(cmd), "\"%stest_rpc_host.exe\" autotest", exePath);
    g_hostPipe = _popen(cmd, "r");
#else
    char exePath[PATH_MAX];
    ssize_t n = readlink("/proc/self/exe", exePath, sizeof(exePath) - 1);
    if (n <= 0) return false;
    exePath[n] = '\0';
    char* dir = dirname(exePath);
    snprintf(cmd, sizeof(cmd), "%s/test_rpc_host autotest", dir);
    g_hostPipe = popen(cmd, "r");
#endif
    if (!g_hostPipe) {
        fprintf(stderr, "ERROR: cannot spawn host: %s\n", cmd);
        return false;
    }

    /* read READY line */
    char line[512];
    if (!fgets(line, sizeof(line), g_hostPipe)) {
        fprintf(stderr, "ERROR: no output from host\n");
        return false;
    }

    /* parse: READY pid=X testbuf=0xZ testlen=N */
    unsigned long long tbuf = 0;
    unsigned tlen = 0;
    if (sscanf(line, "READY pid=%u testbuf=0x%llx testlen=%u",
               outPid, &tbuf, &tlen) < 1) {
        fprintf(stderr, "ERROR: cannot parse host output: %s\n", line);
        return false;
    }
    *outTestBuf = (uint64_t)tbuf;
    *outTestLen = (uint32_t)tlen;
    return true;
}

static void cleanup_host()
{
    if (g_hostPipe) {
#ifdef _WIN32
        _pclose(g_hostPipe);
#else
        pclose(g_hostPipe);
#endif
        g_hostPipe = nullptr;
    }
}

/* ══════════════════════════════════════════════════════════════════════
 *  Printing helpers
 * ══════════════════════════════════════════════════════════════════════ */

static void print_pass(const char* name) { printf("  [PASS] %s\n", name); }
static void print_fail(const char* name) { printf("  [FAIL] %s\n", name); exit(1); }

/* ══════════════════════════════════════════════════════════════════════
 *  main
 * ══════════════════════════════════════════════════════════════════════ */

int main(int argc, char** argv)
{
    uint32_t pid = 0;
    uint64_t testBuf = 0;
    uint32_t testLen = 0;
    bool autoMode = false;

    if (argc >= 2) {
        pid = (uint32_t)atoi(argv[1]);
        if (argc >= 4) {
            testBuf = (uint64_t)strtoull(argv[2], nullptr, 0);
            testLen = (uint32_t)atoi(argv[3]);
        }
    } else {
        autoMode = true;
        printf("Auto-spawning test_rpc_host...\n");
        if (!spawn_host(&pid, &testBuf, &testLen)) return 1;
    }

    printf("Connecting to PID=%u  testbuf=0x%llx  testlen=%u\n\n",
           pid, (unsigned long long)testBuf, testLen);

    /* ── connect ── */
    TestIpcClient ipc;
    if (!ipc.connect(pid)) {
        fprintf(stderr, "ERROR: IPC connect failed\n");
        if (autoMode) cleanup_host();
        return 1;
    }
    printf("=== Functional Tests ===\n");

    /* ── test: ping ── */
    if (ipc.rpc_ping()) print_pass("Ping");
    else                print_fail("Ping");

    /* ── test: enumerate modules ── */
    TestIpcClient::ModInfo mods[512];
    int modCount = ipc.rpc_enum_modules(mods, 512);
    if (modCount > 0) {
        printf("  [PASS] EnumModules (%d modules)\n", modCount);
        printf("         first: %s  base=0x%llx  size=0x%llx\n",
               mods[0].name,
               (unsigned long long)mods[0].base,
               (unsigned long long)mods[0].size);
    } else {
        print_fail("EnumModules");
    }

    /* ── test: read module header (MZ / ELF magic) ── */
    if (modCount > 0) {
        uint8_t header[4] = {};
        if (ipc.rpc_read(mods[0].base, header, 4)) {
#ifdef _WIN32
            if (header[0] == 'M' && header[1] == 'Z')
                print_pass("ReadModuleHeader (MZ)");
            else
                print_fail("ReadModuleHeader (expected MZ)");
#else
            if (header[0] == 0x7F && header[1] == 'E' &&
                header[2] == 'L'  && header[3] == 'F')
                print_pass("ReadModuleHeader (ELF)");
            else
                print_fail("ReadModuleHeader (expected ELF)");
#endif
        } else {
            print_fail("ReadModuleHeader (read failed)");
        }
    }

    /* ── test: read test buffer (known pattern) ── */
    if (testBuf && testLen >= 4096) {
        uint8_t buf[4096];
        if (ipc.rpc_read(testBuf, buf, 4096)) {
            bool good = true;
            for (int i = 0; i < 4096; ++i) {
                if (buf[i] != (uint8_t)(i & 0xFF)) { good = false; break; }
            }
            if (good) print_pass("ReadTestBuffer (4096 bytes, pattern verified)");
            else      print_fail("ReadTestBuffer (pattern mismatch)");
        } else {
            print_fail("ReadTestBuffer (read failed)");
        }
    }

    /* ── test: write ── */
    if (testBuf && testLen >= 16) {
        uint8_t patch[4] = {0xDE, 0xAD, 0xBE, 0xEF};
        if (ipc.rpc_write(testBuf, patch, 4)) {
            uint8_t verify[4] = {};
            ipc.rpc_read(testBuf, verify, 4);
            if (memcmp(verify, patch, 4) == 0)
                print_pass("Write + ReadBack (0xDEADBEEF)");
            else
                print_fail("Write + ReadBack (readback mismatch)");
        } else {
            print_fail("Write (write failed)");
        }
    }

    /* ── test: batch read ── */
    if (testBuf && testLen >= 8192) {
        const uint32_t N = 4;
        uint64_t addrs[N];
        uint32_t lens[N];
        for (uint32_t i = 0; i < N; ++i) {
            addrs[i] = testBuf + i * 1024;
            lens[i]  = 1024;
        }
        uint8_t out[4096];
        if (ipc.rpc_read_batch(addrs, lens, N, out)) {
            print_pass("BatchRead (4 x 1024 bytes)");
        } else {
            print_fail("BatchRead");
        }
    }

    printf("\n=== Benchmarks ===\n");

    /* choose a valid address for benchmarking */
    uint64_t benchAddr = testBuf ? testBuf : (modCount > 0 ? mods[0].base : 0);
    if (!benchAddr) {
        printf("  (no valid address for benchmarks, skipping)\n");
    } else {

        /* ── benchmark: single 4 KB reads ── */
        {
            const int ITERS = 10000;
            const int PAGE  = 4096;
            uint8_t tmp[4096];

            auto t0 = std::chrono::high_resolution_clock::now();
            for (int i = 0; i < ITERS; ++i)
                ipc.rpc_read(benchAddr, tmp, PAGE);
            auto t1 = std::chrono::high_resolution_clock::now();

            double us = (double)std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count();
            double secs = us / 1e6;
            double totalMB = (double)ITERS * PAGE / (1024.0 * 1024.0);

            printf("  Single 4 KB reads:\n");
            printf("    Iterations : %d\n", ITERS);
            printf("    Total data : %.2f MB\n", totalMB);
            printf("    Wall time  : %.3f s\n", secs);
            printf("    Throughput : %.2f MB/s\n", totalMB / secs);
            printf("    Avg latency: %.2f us/read\n", us / ITERS);
        }

        /* ── benchmark: single 64 B reads (pointer-chase-size) ── */
        {
            const int ITERS = 50000;
            const int SZ    = 64;
            uint8_t tmp[64];

            auto t0 = std::chrono::high_resolution_clock::now();
            for (int i = 0; i < ITERS; ++i)
                ipc.rpc_read(benchAddr, tmp, SZ);
            auto t1 = std::chrono::high_resolution_clock::now();

            double us = (double)std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count();
            double secs = us / 1e6;
            double totalKB = (double)ITERS * SZ / 1024.0;

            printf("  Single 64 B reads (pointer-chase):\n");
            printf("    Iterations : %d\n", ITERS);
            printf("    Total data : %.2f KB\n", totalKB);
            printf("    Wall time  : %.3f s\n", secs);
            printf("    Throughput : %.2f KB/s\n", totalKB / secs);
            printf("    Avg latency: %.2f us/read\n", us / ITERS);
        }

        /* ── benchmark: batch read (50 x 4 KB, simulating refresh) ── */
        {
            const int ITERS = 2000;
            const uint32_t BATCH = 50;
            const uint32_t PAGE  = 4096;

            uint64_t addrs[BATCH];
            uint32_t lens[BATCH];
            for (uint32_t i = 0; i < BATCH; ++i) {
                /* wrap within test buffer or module */
                addrs[i] = benchAddr + (i * PAGE) % 65536;
                lens[i]  = PAGE;
            }

            /* allocate response buffer */
            uint8_t* outBuf = (uint8_t*)malloc(BATCH * PAGE);
            if (!outBuf) {
                printf("  (batch malloc failed, skipping)\n");
            } else {
                auto t0 = std::chrono::high_resolution_clock::now();
                for (int i = 0; i < ITERS; ++i)
                    ipc.rpc_read_batch(addrs, lens, BATCH, outBuf);
                auto t1 = std::chrono::high_resolution_clock::now();

                double us = (double)std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count();
                double secs = us / 1e6;
                double totalMB = (double)ITERS * BATCH * PAGE / (1024.0 * 1024.0);

                printf("  Batch read (%u x %u B, simulating refresh):\n", BATCH, PAGE);
                printf("    Iterations : %d\n", ITERS);
                printf("    Total data : %.2f MB\n", totalMB);
                printf("    Wall time  : %.3f s\n", secs);
                printf("    Throughput : %.2f MB/s\n", totalMB / secs);
                printf("    Avg latency: %.2f us/batch\n", us / ITERS);
                printf("    Per-page   : %.2f us/page\n", us / (ITERS * BATCH));

                free(outBuf);
            }
        }

        /* ── benchmark: write 4 KB ── */
        if (testBuf && testLen >= 4096) {
            const int ITERS = 10000;
            const int PAGE  = 4096;
            uint8_t tmp[4096];
            memset(tmp, 0x42, sizeof(tmp));

            auto t0 = std::chrono::high_resolution_clock::now();
            for (int i = 0; i < ITERS; ++i)
                ipc.rpc_write(testBuf, tmp, PAGE);
            auto t1 = std::chrono::high_resolution_clock::now();

            double us = (double)std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count();
            double secs = us / 1e6;
            double totalMB = (double)ITERS * PAGE / (1024.0 * 1024.0);

            printf("  Write 4 KB:\n");
            printf("    Iterations : %d\n", ITERS);
            printf("    Total data : %.2f MB\n", totalMB);
            printf("    Wall time  : %.3f s\n", secs);
            printf("    Throughput : %.2f MB/s\n", totalMB / secs);
            printf("    Avg latency: %.2f us/write\n", us / ITERS);
        }
    }

    /* ── shutdown ── */
    printf("\nSending shutdown...\n");
    ipc.rpc_shutdown();
    ipc.disconnect();

    if (autoMode) {
        /* wait for host to exit */
#ifdef _WIN32
        Sleep(500);
#else
        usleep(500000);
#endif
        cleanup_host();
    }

    printf("Done.\n");
    return 0;
}

```

`plugins/RemoteProcessMemory/tests/test_rpc_host.cpp`:

```cpp
/*
 * test_rpc_host  --  loads rcx_payload in-process, acts as the "target".
 *
 * Usage:  test_rpc_host
 *
 * Prints a READY line (machine-parseable), then waits for the payload
 * to shut down (RPC_CMD_SHUTDOWN from the client).
 */

#include "../rcx_rpc_protocol.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef _WIN32
#  define WIN32_LEAN_AND_MEAN
#  include <windows.h>
#else
#  include <unistd.h>
#  include <dlfcn.h>
#  include <fcntl.h>
#  include <sys/mman.h>
#  include <semaphore.h>
#  include <libgen.h>
#  include <limits.h>
#endif

/* ── Helpers ──────────────────────────────────────────────────────── */

static uint32_t current_pid()
{
#ifdef _WIN32
    return (uint32_t)GetCurrentProcessId();
#else
    return (uint32_t)getpid();
#endif
}

static void sleep_ms(int ms)
{
#ifdef _WIN32
    Sleep((DWORD)ms);
#else
    usleep((useconds_t)ms * 1000);
#endif
}

/* Resolve payload path relative to this executable */
static int payload_path(char* out, int outLen)
{
#ifdef _WIN32
    char exePath[MAX_PATH];
    GetModuleFileNameA(nullptr, exePath, MAX_PATH);
    char* slash = strrchr(exePath, '\\');
    if (!slash) slash = strrchr(exePath, '/');
    if (slash) *(slash + 1) = '\0';
    snprintf(out, outLen, "%srcx_payload.dll", exePath);
#else
    char exePath[PATH_MAX];
    ssize_t n = readlink("/proc/self/exe", exePath, sizeof(exePath) - 1);
    if (n <= 0) return -1;
    exePath[n] = '\0';
    char* dir = dirname(exePath);
    snprintf(out, outLen, "%s/rcx_payload.so", dir);
#endif
    return 0;
}

/* Open the main shared memory (read-only, just to monitor payloadReady) */
static void* open_main_shm(uint32_t pid)
{
    char shmName[128];
    rcx_rpc_shm_name(shmName, sizeof(shmName), pid);

#ifdef _WIN32
    HANDLE h = nullptr;
    for (int i = 0; i < 500; ++i) {
        h = OpenFileMappingA(FILE_MAP_READ, FALSE, shmName);
        if (h) break;
        sleep_ms(10);
    }
    if (!h) return nullptr;
    void* v = MapViewOfFile(h, FILE_MAP_READ, 0, 0, sizeof(RcxRpcHeader));
    return v;
#else
    int fd = -1;
    for (int i = 0; i < 500; ++i) {
        fd = shm_open(shmName, O_RDONLY, 0);
        if (fd >= 0) break;
        sleep_ms(10);
    }
    if (fd < 0) return nullptr;
    void* v = mmap(nullptr, sizeof(RcxRpcHeader), PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    return (v == MAP_FAILED) ? nullptr : v;
#endif
}

/* ── Test buffer (known pattern for client to verify reads/writes) ── */
static uint8_t g_testBuf[65536];

/* ── main ─────────────────────────────────────────────────────────── */

int main(int, char**)
{
    uint32_t pid = current_pid();

    /* fill test buffer with known pattern */
    for (int i = 0; i < (int)sizeof(g_testBuf); ++i)
        g_testBuf[i] = (uint8_t)(i & 0xFF);

    /* load payload */
    char plPath[1024];
    if (payload_path(plPath, sizeof(plPath)) != 0) {
        fprintf(stderr, "ERROR: cannot determine payload path\n");
        return 1;
    }

#ifdef _WIN32
    HMODULE hPayload = LoadLibraryA(plPath);
    if (!hPayload) {
        fprintf(stderr, "ERROR: LoadLibrary(%s) failed (%lu)\n",
                plPath, GetLastError());
        return 1;
    }

    /* Call RcxPayloadInit() — DllMain is minimal, init must be explicit */
    typedef bool (*RcxPayloadInitFn)();
    auto pfnInit = (RcxPayloadInitFn)GetProcAddress(hPayload, "RcxPayloadInit");
    if (!pfnInit || !pfnInit()) {
        fprintf(stderr, "ERROR: RcxPayloadInit() failed or not found\n");
        FreeLibrary(hPayload);
        return 1;
    }
#else
    void* hPayload = dlopen(plPath, RTLD_NOW);
    if (!hPayload) {
        fprintf(stderr, "ERROR: dlopen(%s): %s\n", plPath, dlerror());
        return 1;
    }
#endif

    /* open main shm and wait for payloadReady */
    void* shmView = open_main_shm(pid);
    if (!shmView) {
        fprintf(stderr, "ERROR: failed to open main shared memory\n");
        return 1;
    }

    RcxRpcHeader* hdr = (RcxRpcHeader*)shmView;
    for (int i = 0; i < 500; ++i) {
        if (hdr->payloadReady) break;
        sleep_ms(10);
    }
    if (!hdr->payloadReady) {
        fprintf(stderr, "ERROR: payload did not become ready\n");
        return 1;
    }

    /* print READY line for the client to parse */
    printf("READY pid=%u testbuf=0x%llx testlen=%u\n",
           pid,
           (unsigned long long)(uintptr_t)g_testBuf,
           (unsigned)sizeof(g_testBuf));
    fflush(stdout);

    /* wait until payload shuts down */
    while (hdr->payloadReady)
        sleep_ms(100);

    printf("Payload shut down, exiting.\n");

#ifdef _WIN32
    /* give the timer queue a moment to drain */
    Sleep(200);
    FreeLibrary(hPayload);
    if (shmView) UnmapViewOfFile(shmView);
#else
    usleep(200000);
    dlclose(hPayload);
    if (shmView) munmap(shmView, sizeof(RcxRpcHeader));
#endif

    return 0;
}

```

`plugins/WinDbgMemory/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(WinDbgMemoryPlugin LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt is found by the parent project; QT variable (Qt5 or Qt6) is inherited

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# Plugin sources
set(PLUGIN_SOURCES
    WinDbgMemoryPlugin.h
    WinDbgMemoryPlugin.cpp
)

# Create shared library (DLL)
add_library(WinDbgMemoryPlugin SHARED ${PLUGIN_SOURCES})

# Link Qt + DbgEng
target_link_libraries(WinDbgMemoryPlugin PRIVATE ${QT}::Widgets dbgeng ole32)

# Include directories
target_include_directories(WinDbgMemoryPlugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../../src
)

# Output to Plugins folder
set_target_properties(WinDbgMemoryPlugin PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/Plugins"
)

```

`plugins/WinDbgMemory/WinDbgMemoryPlugin.cpp`:

```cpp
#include "WinDbgMemoryPlugin.h"

#include <QStyle>
#include <QApplication>
#include <QMessageBox>
#include <QDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLineEdit>
#include <QPushButton>
#include <QLabel>
#include <QDebug>
#include <QClipboard>
#include <QGuiApplication>

#ifdef _WIN32
#include <windows.h>
#include <initguid.h>
#include <dbgeng.h>
#pragma comment(lib, "dbgeng.lib")
#endif

// ──────────────────────────────────────────────────────────────────────────
// Thread dispatch helper
// ──────────────────────────────────────────────────────────────────────────

template<typename Fn>
void WinDbgMemoryProvider::dispatchToOwner(Fn&& fn) const
{
    if (!m_dispatcher) { fn(); return; }

    if (QThread::currentThread() == m_dispatcher->thread()) {
        // Already on the owning thread — call directly
        fn();
    } else {
        // Marshal to the owning thread and block until done
        QMetaObject::invokeMethod(m_dispatcher, std::forward<Fn>(fn),
                                  Qt::BlockingQueuedConnection);
    }
}

// ──────────────────────────────────────────────────────────────────────────
// WinDbgMemoryProvider implementation
// ──────────────────────────────────────────────────────────────────────────

WinDbgMemoryProvider::WinDbgMemoryProvider(const QString& target)
{
    // Create a dedicated thread for all DbgEng COM operations.
    // DbgEng's remote transport (TCP/named-pipe) is thread-affine — all
    // calls must happen on the thread that called DebugConnect/DebugCreate.
    // A private thread with its own event loop guarantees:
    //   1. dispatchToOwner() works from any calling thread (main, thread-pool, etc.)
    //   2. No deadlock — the DbgEng thread is never blocked by the caller
    m_dbgThread = new QThread();
    m_dbgThread->setObjectName(QStringLiteral("DbgEngThread"));
    m_dbgThread->start();

    m_dispatcher = new DbgEngDispatcher();
    m_dispatcher->moveToThread(m_dbgThread);

#ifdef _WIN32
    // Run all DbgEng initialization on the dedicated thread.
    // BlockingQueuedConnection blocks us until the lambda finishes,
    // so member variables written inside are visible after the call.
    dispatchToOwner([this, &target]() {
        HRESULT hr;

        qDebug() << "[WinDbg] Opening target:" << target
                 << "on DbgEng thread" << QThread::currentThread();

        if (target.startsWith("tcp:", Qt::CaseInsensitive)
            || target.startsWith("npipe:", Qt::CaseInsensitive))
        {
            // ── Remote: connect to existing WinDbg debug server ──
            QByteArray connUtf8 = target.toUtf8();
            qDebug() << "[WinDbg] DebugConnect:" << target;
            hr = DebugConnect(connUtf8.constData(), IID_IDebugClient, (void**)&m_client);
            qDebug() << "[WinDbg] DebugConnect hr=" << Qt::hex << (unsigned long)hr
                     << "client=" << (void*)m_client;
            if (FAILED(hr) || !m_client) {
                qWarning() << "[WinDbg] DebugConnect FAILED hr=0x" << Qt::hex << (unsigned long)hr;
                return;
            }
            m_isRemote = true;
        }
        else
        {
            // ── Local: create debug client for pid/dump ──
            hr = DebugCreate(IID_IDebugClient, (void**)&m_client);
            qDebug() << "[WinDbg] DebugCreate hr=" << Qt::hex << (unsigned long)hr
                     << "client=" << (void*)m_client;
            if (FAILED(hr) || !m_client) {
                qWarning() << "[WinDbg] DebugCreate FAILED hr=0x" << Qt::hex << (unsigned long)hr;
                return;
            }

            if (target.startsWith("pid:", Qt::CaseInsensitive))
            {
                bool ok = false;
                ULONG pid = target.mid(4).trimmed().toULong(&ok);
                if (!ok || pid == 0) {
                    qWarning() << "[WinDbg] Invalid PID in target:" << target;
                    cleanup();
                    return;
                }

                qDebug() << "[WinDbg] Attaching to PID" << pid << "(non-invasive)";
                hr = m_client->AttachProcess(
                    0, pid,
                    DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND);
                qDebug() << "[WinDbg] AttachProcess hr=" << Qt::hex << (unsigned long)hr;
                if (FAILED(hr)) {
                    qWarning() << "[WinDbg] AttachProcess FAILED";
                    cleanup();
                    return;
                }
            }
            else if (target.startsWith("dump:", Qt::CaseInsensitive))
            {
                QString path = target.mid(5).trimmed();
                QByteArray pathUtf8 = path.toUtf8();

                qDebug() << "[WinDbg] Opening dump file:" << path;
                hr = m_client->OpenDumpFile(pathUtf8.constData());
                qDebug() << "[WinDbg] OpenDumpFile hr=" << Qt::hex << (unsigned long)hr;
                if (FAILED(hr)) {
                    qWarning() << "[WinDbg] OpenDumpFile FAILED";
                    cleanup();
                    return;
                }
            }
            else
            {
                qWarning() << "[WinDbg] Unknown target format:" << target;
                cleanup();
                return;
            }
        }

        initInterfaces();

        // WaitForEvent to finalize the attach/dump load.
        // For remote connections the server session is already active — skip.
        if (m_control && !m_isRemote) {
            qDebug() << "[WinDbg] WaitForEvent...";
            hr = m_control->WaitForEvent(0, 10000);
            qDebug() << "[WinDbg] WaitForEvent hr=" << Qt::hex << (unsigned long)hr;
        }

        querySessionInfo();
    });

#else
    Q_UNUSED(target);
#endif
}

void WinDbgMemoryProvider::initInterfaces()
{
#ifdef _WIN32
    if (!m_client) return;

    HRESULT hr;
    hr = m_client->QueryInterface(IID_IDebugDataSpaces, (void**)&m_dataSpaces);
    qDebug() << "[WinDbg] IDebugDataSpaces hr=" << Qt::hex << (unsigned long)hr
             << "ptr=" << (void*)m_dataSpaces;

    hr = m_client->QueryInterface(IID_IDebugControl, (void**)&m_control);
    qDebug() << "[WinDbg] IDebugControl hr=" << Qt::hex << (unsigned long)hr
             << "ptr=" << (void*)m_control;

    hr = m_client->QueryInterface(IID_IDebugSymbols, (void**)&m_symbols);
    qDebug() << "[WinDbg] IDebugSymbols hr=" << Qt::hex << (unsigned long)hr
             << "ptr=" << (void*)m_symbols;

    if (!m_dataSpaces) {
        qWarning() << "[WinDbg] No IDebugDataSpaces — cleaning up";
        cleanup();
    }
#endif
}

void WinDbgMemoryProvider::querySessionInfo()
{
#ifdef _WIN32
    if (!m_client) return;
    HRESULT hr;

    if (m_control) {
        ULONG debugClass = 0, debugQualifier = 0;
        hr = m_control->GetDebuggeeType(&debugClass, &debugQualifier);
        qDebug() << "[WinDbg] GetDebuggeeType hr=" << Qt::hex << (unsigned long)hr
                 << "class=" << debugClass << "qualifier=" << debugQualifier;
        if (SUCCEEDED(hr)) {
            m_isLive = (debugQualifier < DEBUG_DUMP_SMALL);
            m_writable = m_isLive;
        }
    }

    // WinDbg provides access to the entire virtual address space.
    // Do NOT auto-select a module as base — let the user set their
    // own base address.  m_base stays 0 so the controller won't
    // override tree.baseAddress.
    m_name = m_isLive ? QStringLiteral("WinDbg (Live)")
                      : QStringLiteral("WinDbg (Dump)");

    qDebug() << "[WinDbg] Ready. name=" << m_name
             << "isLive=" << m_isLive;
#endif
}

WinDbgMemoryProvider::~WinDbgMemoryProvider()
{
#ifdef _WIN32
    // Dispatch COM cleanup to the DbgEng thread (thread-affine release)
    if (m_dbgThread && m_dbgThread->isRunning() && m_dispatcher) {
        dispatchToOwner([this]() {
            if (m_client) {
                if (m_isRemote)
                    m_client->EndSession(DEBUG_END_DISCONNECT);
                else
                    m_client->DetachProcesses();
            }
            cleanup();
        });
    } else {
        // Thread not running — clean up directly (best-effort)
        if (m_client) {
            if (m_isRemote)
                m_client->EndSession(DEBUG_END_DISCONNECT);
            else
                m_client->DetachProcesses();
        }
        cleanup();
    }
#else
    cleanup();
#endif

    // Stop the dedicated thread
    if (m_dbgThread) {
        m_dbgThread->quit();
        m_dbgThread->wait(3000);
        delete m_dbgThread;
        m_dbgThread = nullptr;
    }
    delete m_dispatcher;
    m_dispatcher = nullptr;
}

void WinDbgMemoryProvider::cleanup()
{
#ifdef _WIN32
    if (m_symbols)    { m_symbols->Release();    m_symbols = nullptr; }
    if (m_control)    { m_control->Release();    m_control = nullptr; }
    if (m_dataSpaces) { m_dataSpaces->Release(); m_dataSpaces = nullptr; }
    if (m_client)     { m_client->Release();     m_client = nullptr; }
#endif
}

bool WinDbgMemoryProvider::read(uint64_t addr, void* buf, int len) const
{
#ifdef _WIN32
    if (!m_dataSpaces || len <= 0) return false;

    bool result = false;
    dispatchToOwner([&]() {
        ULONG bytesRead = 0;
        HRESULT hr = m_dataSpaces->ReadVirtual(addr, buf, (ULONG)len, &bytesRead);
        if (SUCCEEDED(hr) && (int)bytesRead >= len) {
            result = true;
            return;
        }
        // Partial or failed read — zero-fill remainder and log
        memset((char*)buf + bytesRead, 0, len - bytesRead);
        ++m_readFailCount;
        if (m_readFailCount <= 5 || (m_readFailCount % 100) == 0)
            qDebug() << "[WinDbg] ReadVirtual FAILED addr=0x" << Qt::hex << addr
                     << "len=" << Qt::dec << len
                     << "hr=0x" << Qt::hex << (unsigned long)hr
                     << "got=" << Qt::dec << bytesRead;
        result = bytesRead > 0;
    });
    return result;
#else
    Q_UNUSED(addr); Q_UNUSED(buf); Q_UNUSED(len);
    return false;
#endif
}

bool WinDbgMemoryProvider::write(uint64_t addr, const void* buf, int len)
{
#ifdef _WIN32
    if (!m_dataSpaces || !m_writable || len <= 0) return false;

    bool result = false;
    dispatchToOwner([&]() {
        ULONG bytesWritten = 0;
        HRESULT hr = m_dataSpaces->WriteVirtual(addr, const_cast<void*>(buf),
                                                 (ULONG)len, &bytesWritten);
        result = SUCCEEDED(hr) && bytesWritten == (ULONG)len;
    });
    return result;
#else
    Q_UNUSED(addr); Q_UNUSED(buf); Q_UNUSED(len);
    return false;
#endif
}

int WinDbgMemoryProvider::size() const
{
#ifdef _WIN32
    return m_dataSpaces ? 0x10000 : 0;
#else
    return 0;
#endif
}

bool WinDbgMemoryProvider::isReadable(uint64_t /*addr*/, int len) const
{
#ifdef _WIN32
    // DbgEng's ReadVirtual can read any mapped virtual address.
    return m_dataSpaces != nullptr && len >= 0;
#else
    return false;
#endif
}

QString WinDbgMemoryProvider::getSymbol(uint64_t addr) const
{
#ifdef _WIN32
    if (!m_symbols) return {};

    QString result;
    dispatchToOwner([&]() {
        char nameBuf[512] = {};
        ULONG nameSize = 0;
        ULONG64 displacement = 0;
        HRESULT hr = m_symbols->GetNameByOffset(addr, nameBuf, sizeof(nameBuf),
                                                 &nameSize, &displacement);
        if (SUCCEEDED(hr) && nameSize > 0) {
            result = QString::fromUtf8(nameBuf);
            if (displacement > 0)
                result += QStringLiteral("+0x%1").arg(displacement, 0, 16);
        }
    });
    return result;
#else
    Q_UNUSED(addr);
    return {};
#endif
}

// ──────────────────────────────────────────────────────────────────────────
// WinDbgMemoryPlugin implementation
// ──────────────────────────────────────────────────────────────────────────

QIcon WinDbgMemoryPlugin::Icon() const
{
    return qApp->style()->standardIcon(QStyle::SP_DriveNetIcon);
}

bool WinDbgMemoryPlugin::canHandle(const QString& target) const
{
    return target.startsWith("tcp:", Qt::CaseInsensitive)
        || target.startsWith("npipe:", Qt::CaseInsensitive)
        || target.startsWith("pid:", Qt::CaseInsensitive)
        || target.startsWith("dump:", Qt::CaseInsensitive);
}

std::unique_ptr<rcx::Provider> WinDbgMemoryPlugin::createProvider(const QString& target, QString* errorMsg)
{
    auto provider = std::make_unique<WinDbgMemoryProvider>(target);
    if (!provider->isValid())
    {
        if (errorMsg) {
            if (target.startsWith("tcp:", Qt::CaseInsensitive)
                || target.startsWith("npipe:", Qt::CaseInsensitive))
                *errorMsg = QString("Failed to connect to debug server.\n\n"
                                   "Target: %1\n\n"
                                   "Make sure WinDbg is running with a matching .server command\n"
                                   "(e.g. .server tcp:port=5055) and the port/pipe is reachable.")
                            .arg(target);
            else if (target.startsWith("pid:", Qt::CaseInsensitive))
                *errorMsg = QString("Failed to attach to process.\n\n"
                                   "Target: %1\n\n"
                                   "Make sure the process is running and you have "
                                   "sufficient privileges (try Run as Administrator).")
                            .arg(target);
            else
                *errorMsg = QString("Failed to open dump file.\n\n"
                                   "Target: %1\n\n"
                                   "Make sure the file exists and is a valid dump.")
                            .arg(target);
        }
        return nullptr;
    }
    return provider;
}

uint64_t WinDbgMemoryPlugin::getInitialBaseAddress(const QString& target) const
{
    Q_UNUSED(target);
    return 0;
}

bool WinDbgMemoryPlugin::selectTarget(QWidget* parent, QString* target)
{
    QDialog dlg(parent);
    dlg.setWindowTitle("WinDbg Settings");
    dlg.resize(460, 260);

    QPalette dlgPal = qApp->palette();
    dlg.setPalette(dlgPal);
    dlg.setAutoFillBackground(true);

    auto* layout = new QVBoxLayout(&dlg);

    layout->addWidget(new QLabel(
        "Connect to a running WinDbg debug server.\n"
        "In WinDbg, run:  .server tcp:port=5055"));

    layout->addSpacing(8);
    layout->addWidget(new QLabel("Connection string:"));
    auto* connEdit = new QLineEdit;
    connEdit->setPlaceholderText("tcp:Port=5055,Server=localhost");
    connEdit->setText("tcp:Port=5055,Server=localhost");
    layout->addWidget(connEdit);

    layout->addSpacing(4);
    layout->addWidget(new QLabel("Run one of these in WinDbg first:"));

    auto addExample = [&](const QString& text) {
        auto* row = new QHBoxLayout;
        auto* label = new QLabel(text);
        QPalette lp = dlgPal;
        lp.setColor(QPalette::WindowText, dlgPal.color(QPalette::Disabled, QPalette::WindowText));
        label->setPalette(lp);
        label->setTextInteractionFlags(Qt::TextSelectableByMouse);
        row->addWidget(label, 1);
        auto* copyBtn = new QPushButton("Copy");
        copyBtn->setFixedWidth(50);
        copyBtn->setToolTip("Copy to clipboard");
        QObject::connect(copyBtn, &QPushButton::clicked, [text]() {
            QGuiApplication::clipboard()->setText(text);
        });
        row->addWidget(copyBtn);
        layout->addLayout(row);
    };

    addExample(".server tcp:port=5055");
    addExample(".server npipe:pipe=reclass");
    layout->addStretch();

    auto* btnLayout = new QHBoxLayout;
    btnLayout->addStretch();
    auto* okBtn = new QPushButton("OK");
    auto* cancelBtn = new QPushButton("Cancel");
    btnLayout->addWidget(okBtn);
    btnLayout->addWidget(cancelBtn);
    layout->addLayout(btnLayout);

    QObject::connect(okBtn, &QPushButton::clicked, &dlg, &QDialog::accept);
    QObject::connect(cancelBtn, &QPushButton::clicked, &dlg, &QDialog::reject);

    if (dlg.exec() != QDialog::Accepted)
        return false;

    QString conn = connEdit->text().trimmed();
    if (conn.isEmpty()) return false;
    *target = conn;
    return true;
}

// ──────────────────────────────────────────────────────────────────────────
// Plugin factory
// ──────────────────────────────────────────────────────────────────────────

extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin()
{
    return new WinDbgMemoryPlugin();
}

```

`plugins/WinDbgMemory/WinDbgMemoryPlugin.h`:

```h
#pragma once
#include "../../src/iplugin.h"
#include "../../src/core.h"

#include <cstdint>
#include <QObject>
#include <QThread>

// Forward declarations for DbgEng COM interfaces
struct IDebugClient;
struct IDebugDataSpaces;
struct IDebugControl;
struct IDebugSymbols;

/**
 * WinDbg memory provider
 *
 * Uses DbgEng to read memory from:
 *   - An existing WinDbg debug server via DebugConnect (tcp/npipe)
 *   - A live process by PID via DebugCreate (non-invasive attach)
 *   - A crash dump (.dmp) file via DebugCreate
 *
 * Target string format:
 *   "tcp:Port=5055,Server=localhost"   - connect to WinDbg debug server (TCP)
 *   "npipe:Pipe=name,Server=localhost" - connect to WinDbg debug server (named pipe)
 *   "pid:1234"                         - attach to process 1234
 *   "dump:C:/path/to/file.dmp"        - open dump file
 *
 * Threading: All DbgEng COM calls are dispatched to the thread that created
 * the connection (DebugConnect/DebugCreate).  This is required because the
 * remote transport (TCP/named-pipe) binds to the creating thread.  The
 * controller's background refresh threads call read() which transparently
 * marshals to the owning thread via BlockingQueuedConnection.
 */

// Helper QObject that lives on the DbgEng-owning thread.
// Used as a target for QMetaObject::invokeMethod to marshal calls.
class DbgEngDispatcher : public QObject {
    Q_OBJECT
public:
    using QObject::QObject;
};

class WinDbgMemoryProvider : public rcx::Provider
{
public:
    /// Create a provider from a target string
    WinDbgMemoryProvider(const QString& target);
    ~WinDbgMemoryProvider() override;

    // Required overrides
    bool read(uint64_t addr, void* buf, int len) const override;
    int size() const override;

    // Optional overrides
    bool isReadable(uint64_t addr, int len) const override;
    bool write(uint64_t addr, const void* buf, int len) override;
    bool isWritable() const override { return m_writable; }
    QString name() const override { return m_name; }
    QString kind() const override { return QStringLiteral("WinDbg"); }
    QString getSymbol(uint64_t addr) const override;

    bool isLive() const override { return m_isLive; }
    uint64_t base() const override { return m_base; }

private:
    void initInterfaces();   // get IDebugDataSpaces/Control/Symbols from client
    void querySessionInfo(); // determine live/dump, writable, name, base
    void cleanup();

    // Marshal a lambda to the DbgEng-owning thread.  If already on that
    // thread, calls directly.  Otherwise blocks via QueuedConnection.
    template<typename Fn>
    void dispatchToOwner(Fn&& fn) const;

    IDebugClient*     m_client = nullptr;
    IDebugDataSpaces* m_dataSpaces = nullptr;
    IDebugControl*    m_control = nullptr;
    IDebugSymbols*    m_symbols = nullptr;

    QString  m_name;
    uint64_t m_base = 0;
    bool     m_isLive = false;
    bool     m_writable = false;
    bool     m_isRemote = false;   // true when connected via DebugConnect (tcp/npipe)
    mutable int  m_readFailCount = 0;

    // Dedicated thread for DbgEng COM operations.  The remote TCP/pipe
    // transport is thread-affine — all calls must happen on the thread
    // that called DebugConnect.  A private thread with its own event loop
    // ensures dispatchToOwner() works from any calling thread (including
    // QtConcurrent workers and the main/GUI thread) without deadlock.
    QThread*          m_dbgThread  = nullptr;
    DbgEngDispatcher* m_dispatcher = nullptr;
};

/**
 * Plugin that provides WinDbgMemoryProvider
 *
 * Uses DbgEng to read memory via:
 *   - Remote connection to an existing WinDbg debug server (tcp/npipe)
 *   - Local non-invasive attach to a live process (pid)
 *   - Local crash dump file (dump)
 */
class WinDbgMemoryPlugin : public IProviderPlugin
{
public:
    std::string Name() const override { return "WinDbg Memory"; }
    std::string Version() const override { return "2.0.0"; }
    std::string Author() const override { return "Reclass"; }
    std::string Description() const override { return "Read memory via DbgEng (live process attach or crash dump)"; }
    k_ELoadType LoadType() const override { return k_ELoadTypeAuto; }
    QIcon Icon() const override;

    bool canHandle(const QString& target) const override;
    std::unique_ptr<rcx::Provider> createProvider(const QString& target, QString* errorMsg) override;
    uint64_t getInitialBaseAddress(const QString& target) const override;
    bool selectTarget(QWidget* parent, QString* target) override;
};

// Plugin export
extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin();

```

`scripts/build.ps1`:

```ps1
# PowerShell script to build Reclass
# Automatically detects Qt installation and configures build environment

#Requires -Version 5.1

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$QtDir,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet('Release', 'Debug', 'RelWithDebInfo', 'MinSizeRel')]
    [string]$BuildType = 'Release',
    
    [Parameter(Mandatory=$false)]
    [switch]$Clean,
    
    [Parameter(Mandatory=$false)]
    [switch]$Rebuild
)

$ErrorActionPreference = "Stop"

# ──────────────────────────────────────────────────────────────────────────────
# Functions
# ──────────────────────────────────────────────────────────────────────────────

function Write-ColorOutput {
    param([string]$Message, [ConsoleColor]$Color = [ConsoleColor]::White)
    Write-Host $Message -ForegroundColor $Color
}

function Find-QtInstallation {
    $found = @()
    
    # Query registry for Qt installations
    $registryPaths = @(
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
    )
    
    foreach ($regPath in $registryPaths) {
        if (Test-Path $regPath) {
            Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue | ForEach-Object {
                $displayName = (Get-ItemProperty -Path $_.PSPath -Name DisplayName -ErrorAction SilentlyContinue).DisplayName
                if ($displayName -and $displayName -match 'Qt') {
                    $installLocation = (Get-ItemProperty -Path $_.PSPath -Name InstallLocation -ErrorAction SilentlyContinue).InstallLocation
                    if ($installLocation -and (Test-Path $installLocation)) {
                        # Check if this is a Qt root directory, scan for MinGW installations
                        Get-ChildItem -Path $installLocation -Directory -ErrorAction SilentlyContinue | Where-Object {
                            $_.Name -match '^\d+\.\d+\.\d+$'
                        } | ForEach-Object {
                            Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object {
                                $_.Name -match 'mingw'
                            } | ForEach-Object {
                                $qmakePath = Join-Path $_.FullName "bin\qmake.exe"
                                if (Test-Path $qmakePath) {
                                    $found += $_.FullName
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    # Fallback: scan common paths if registry search found nothing
    if ($found.Count -eq 0) {
        $commonPaths = @(
            "C:\Qt",
            "D:\Qt",
            "E:\Qt",
            "F:\Qt",
            "$env:USERPROFILE\Qt",
            "$env:ProgramFiles\Qt",
            "${env:ProgramFiles(x86)}\Qt"
        )
        
        foreach ($basePath in $commonPaths) {
            if (Test-Path $basePath) {
                Get-ChildItem -Path $basePath -Directory -ErrorAction SilentlyContinue | Where-Object {
                    $_.Name -match '^\d+\.\d+\.\d+$'
                } | ForEach-Object {
                    Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object {
                        $_.Name -match 'mingw'
                    } | ForEach-Object {
                        $qmakePath = Join-Path $_.FullName "bin\qmake.exe"
                        if (Test-Path $qmakePath) {
                            $found += $_.FullName
                        }
                    }
                }
            }
        }
    }
    
    return $found | Select-Object -Unique
}

function Select-QtDirectory {
    Add-Type -AssemblyName System.Windows.Forms
    $folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog
    $folderBrowser.Description = "Select Qt MinGW installation directory (e.g., C:\Qt\6.10.2\mingw_64)"
    $folderBrowser.RootFolder = [System.Environment+SpecialFolder]::MyComputer
    $folderBrowser.ShowNewFolderButton = $false
    
    if ($folderBrowser.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        return $folderBrowser.SelectedPath
    }
    return $null
}

function Get-QtDirectory {
    # 1. Check if provided as parameter
    if ($QtDir) {
        Write-ColorOutput "Using Qt directory from parameter: $QtDir" Cyan
        return $QtDir
    }
    
    # 2. Check environment variable and try to find MinGW under it
    if ($env:QTDIR) {
        $qtdirPath = $env:QTDIR
        Write-ColorOutput "Found QTDIR environment variable: $qtdirPath" Cyan
        
        # Check if QTDIR directly points to a valid MinGW installation
        $qmake = Join-Path $qtdirPath "bin\qmake.exe"
        if ((Test-Path $qmake) -and ($qtdirPath.ToLower() -match 'mingw')) {
            Write-ColorOutput "QTDIR points to valid MinGW installation." Green
            return $qtdirPath
        }
        
        # QTDIR might point to Qt root, search for MinGW subdirectories
        Write-ColorOutput "QTDIR appears to be Qt root directory. Searching for MinGW installations..." Yellow
        $foundMinGW = @()
        
        Get-ChildItem -Path $qtdirPath -Directory -ErrorAction SilentlyContinue | Where-Object {
            $_.Name -match '^\d+\.\d+\.\d+$'
        } | ForEach-Object {
            Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object {
                $_.Name -match 'mingw'
            } | ForEach-Object {
                $qmakePath = Join-Path $_.FullName "bin\qmake.exe"
                if (Test-Path $qmakePath) {
                    $foundMinGW += $_.FullName
                }
            }
        }
        
        if ($foundMinGW.Count -eq 1) {
            Write-ColorOutput "Found MinGW installation under QTDIR: $($foundMinGW[0])" Green
            $response = Read-Host "Use this installation? (Y/n)"
            if ($response -match '^(y|yes|)$' -or [string]::IsNullOrWhiteSpace($response)) {
                return $foundMinGW[0]
            }
        } elseif ($foundMinGW.Count -gt 1) {
            Write-ColorOutput "Found multiple MinGW installations under QTDIR:" Green
            for ($i = 0; $i -lt $foundMinGW.Count; $i++) {
                Write-Host "  [$($i+1)] $($foundMinGW[$i])"
            }
            
            do {
                $choice = Read-Host "Select Qt installation (1-$($foundMinGW.Count))"
                $choiceNum = 0
                $valid = [int]::TryParse($choice, [ref]$choiceNum) -and $choiceNum -ge 1 -and $choiceNum -le $foundMinGW.Count
            } until ($valid)
            
            return $foundMinGW[$choiceNum - 1]
        }
        
        Write-ColorOutput "No MinGW installations found under QTDIR." Yellow
    }
    
    # 3. Try to auto-detect
    Write-ColorOutput "Searching for Qt installations..." Yellow
    $detected = Find-QtInstallation
    
    if ($detected.Count -eq 1) {
        Write-ColorOutput "Found Qt installation: $($detected[0])" Green
        $response = Read-Host "Use this installation? (Y/n)"
        if ($response -match '^(y|yes|)$' -or [string]::IsNullOrWhiteSpace($response)) {
            return $detected[0]
        }
    } elseif ($detected.Count -gt 1) {
        Write-ColorOutput "Found multiple Qt installations:" Green
        for ($i = 0; $i -lt $detected.Count; $i++) {
            Write-Host "  [$($i+1)] $($detected[$i])"
        }
        Write-Host "  [0] Browse for directory manually"
        
        do {
            $choice = Read-Host "Select Qt installation (1-$($detected.Count), or 0 to browse)"
            $choiceNum = 0
            $valid = [int]::TryParse($choice, [ref]$choiceNum) -and $choiceNum -ge 0 -and $choiceNum -le $detected.Count
        } until ($valid)
        
        if ($choiceNum -gt 0) {
            return $detected[$choiceNum - 1]
        }
    }
    
    # 4. Manual input or browse
    Write-ColorOutput "No Qt MinGW installation auto-detected." Yellow
    Write-Host ""
    Write-Host "Options:"
    Write-Host "  [1] Browse for Qt MinGW directory"
    Write-Host "  [2] Enter path manually"
    Write-Host "  [3] Exit"
    
    do {
        $choice = Read-Host "Select option (1-3)"
    } until ($choice -match '^[123]$')
    
    switch ($choice) {
        "1" {
            $dir = Select-QtDirectory
            if ($dir) { return $dir }
            Write-ColorOutput "No directory selected. Exiting." Red
            exit 1
        }
        "2" {
            $dir = Read-Host "Enter Qt MinGW directory path (e.g., C:\Qt\6.10.2\mingw_64)"
            if ($dir) { return $dir }
            Write-ColorOutput "No path entered. Exiting." Red
            exit 1
        }
        "3" {
            Write-ColorOutput "Exiting." Yellow
            exit 0
        }
    }
}

function Validate-QtDirectory {
    param([string]$Dir)
    
    $qmake = Join-Path $Dir "bin\qmake.exe"
    if (-not (Test-Path $qmake)) {
        Write-ColorOutput "ERROR: qmake.exe not found in $Dir\bin\" Red
        Write-ColorOutput "Please ensure you selected a valid Qt installation directory (e.g., C:\Qt\6.10.2\mingw_64)" Red
        return $false
    }
    
    # Validate it's a MinGW build
    $dirLower = $Dir.ToLower()
    if ($dirLower -notmatch 'mingw') {
        Write-ColorOutput "ERROR: Selected Qt installation is not MinGW-based." Red
        Write-ColorOutput "This project requires Qt with MinGW compiler (e.g., C:\Qt\6.10.2\mingw_64)" Red
        Write-ColorOutput "Selected path: $Dir" Red
        return $false
    }
    
    return $true
}

function Find-BuildTool {
    param([string]$QtDir, [string]$ToolName)
    
    $qtRoot = Split-Path (Split-Path $QtDir -Parent) -Parent
    $toolsDir = Join-Path $qtRoot "Tools"
    
    if (Test-Path $toolsDir) {
        # Search for tool in Qt Tools directory
        $toolExe = Get-ChildItem -Path $toolsDir -Recurse -Filter "$ToolName.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($toolExe) {
            return $toolExe.DirectoryName
        }
    }
    
    # Check system PATH
    $cmd = Get-Command "$ToolName.exe" -ErrorAction SilentlyContinue
    if ($cmd) {
        return Split-Path $cmd.Source -Parent
    }
    
    return $null
}

function Find-MinGWDirectory {
    param([string]$QtDir)
    
    $qtRoot = Split-Path (Split-Path $QtDir -Parent) -Parent
    $toolsDir = Join-Path $qtRoot "Tools"
    
    if (Test-Path $toolsDir) {
        $mingwToolDirs = Get-ChildItem -Path $toolsDir -Directory -ErrorAction SilentlyContinue | Where-Object {
            $_.Name -match 'mingw'
        }
        
        foreach ($dir in $mingwToolDirs) {
            $testBin = Join-Path $dir.FullName "bin\g++.exe"
            if (Test-Path $testBin) {
                return Join-Path $dir.FullName "bin"
            }
        }
    }
    
    return $null
}

# ──────────────────────────────────────────────────────────────────────────────
# Main Script
# ──────────────────────────────────────────────────────────────────────────────

Write-ColorOutput "`n========================================" Cyan
Write-ColorOutput "Reclass Build Script" Cyan
Write-ColorOutput "========================================`n" Cyan

# Get script directory and project root
$scriptDir = Split-Path -Parent $PSCommandPath
$projectRoot = Split-Path -Parent $scriptDir
$buildDir = Join-Path $projectRoot "build"

# Get Qt directory
$selectedQtDir = Get-QtDirectory
if (-not $selectedQtDir) {
    Write-ColorOutput "ERROR: No Qt directory provided." Red
    exit 1
}

# Validate Qt directory
if (-not (Validate-QtDirectory $selectedQtDir)) {
    exit 1
}

Write-ColorOutput "`nQt Directory: $selectedQtDir" Green
Write-ColorOutput "Build Type: $BuildType" Green

# Find build tools
Write-ColorOutput "`nSearching for build tools..." Cyan

$cmakeDir = Find-BuildTool $selectedQtDir "cmake"
$ninjaDir = Find-BuildTool $selectedQtDir "ninja"
$mingwDir = Find-MinGWDirectory $selectedQtDir

$missingTools = @()

if (-not $cmakeDir) {
    $missingTools += "CMake"
    Write-ColorOutput "  CMake: NOT FOUND" Red
} else {
    Write-ColorOutput "  CMake: $cmakeDir" Green
}

if (-not $ninjaDir) {
    $missingTools += "Ninja"
    Write-ColorOutput "  Ninja: NOT FOUND" Yellow
    Write-ColorOutput "         (Will try default CMake generator)" Gray
} else {
    Write-ColorOutput "  Ninja: $ninjaDir" Green
}

if (-not $mingwDir) {
    Write-ColorOutput "  MinGW: NOT FOUND (may cause build issues)" Yellow
} else {
    Write-ColorOutput "  MinGW: $mingwDir" Green
}

if ($missingTools.Count -gt 0 -and $missingTools -contains "CMake") {
    Write-ColorOutput "`nERROR: CMake is required but not found." Red
    Write-ColorOutput "Please install CMake or ensure it's in your PATH." Red
    Write-ColorOutput "You can download it from: https://cmake.org/download/" Red
    exit 1
}

# Build PATH environment
$pathDirs = @()
if ($cmakeDir) { $pathDirs += $cmakeDir }
if ($ninjaDir) { $pathDirs += $ninjaDir }
if ($mingwDir) { $pathDirs += $mingwDir }
$pathDirs += (Join-Path $selectedQtDir "bin")
$pathDirs += $env:Path

$env:Path = ($pathDirs -join ";")

Write-ColorOutput "`nEnvironment configured." Green

# Handle clean/rebuild
if ($Rebuild) {
    $Clean = $true
}

if ($Clean -and (Test-Path $buildDir)) {
    Write-ColorOutput "`nCleaning build directory..." Yellow
    try {
        Remove-Item -Path $buildDir -Recurse -Force -ErrorAction Stop
        Write-ColorOutput "Build directory cleaned." Green
    } catch {
        Write-ColorOutput "ERROR: Failed to clean build directory: $_" Red
        exit 1
    }
}

# Create build directory
if (-not (Test-Path $buildDir)) {
    Write-ColorOutput "`nCreating build directory..." Cyan
    New-Item -ItemType Directory -Path $buildDir -Force | Out-Null
}

# Change to build directory
Push-Location $buildDir

try {
    Write-ColorOutput "`nConfiguring CMake..." Cyan
    
    # Prepare CMake command
    $cmakeArgs = @(
        ".."
        "-DCMAKE_BUILD_TYPE=$BuildType"
        "-DCMAKE_PREFIX_PATH=$($selectedQtDir -replace '\\', '/')"
    )
    
    # Add generator if Ninja is available
    if ($ninjaDir) {
        $cmakeArgs = @("-G", "Ninja") + $cmakeArgs
        Write-ColorOutput "Using Ninja generator" Gray
    }
    
    Write-ColorOutput "Command: cmake $($cmakeArgs -join ' ')`n" Gray
    
    & cmake $cmakeArgs
    if ($LASTEXITCODE -ne 0) {
        Write-ColorOutput "`nERROR: CMake configuration failed with exit code $LASTEXITCODE" Red
        exit 1
    }
    Write-ColorOutput "`nCMake configuration completed successfully.`n" Green
    
    # Build
    Write-ColorOutput "Building Reclass..." Cyan
    
    $cores = (Get-CimInstance -ClassName Win32_Processor).NumberOfLogicalProcessors
    if (-not $cores -or $cores -lt 1) {
        $cores = 4
    }
    
    Write-ColorOutput "Command: cmake --build . --config $BuildType -j$cores`n" Gray
    
    & cmake --build . --config $BuildType "-j$cores"
    if ($LASTEXITCODE -ne 0) {
        Write-ColorOutput "`nERROR: Build failed with exit code $LASTEXITCODE" Red
        exit 1
    }
    Write-ColorOutput "`nBuild completed successfully!`n" Green
    
    # Find executable
    Write-ColorOutput "Locating executable..." Cyan
    $exePaths = @(
        (Join-Path $buildDir "Reclass.exe"),
        (Join-Path $buildDir "$BuildType\Reclass.exe")
    )
    
    $exePath = $null
    foreach ($path in $exePaths) {
        if (Test-Path $path) {
            $exePath = $path
            break
        }
    }
    
    if ($exePath) {
        $fileInfo = Get-Item $exePath
        $sizeMB = [math]::Round($fileInfo.Length / 1MB, 2)
        Write-ColorOutput "Executable: $exePath" Green
        Write-ColorOutput "Size: $sizeMB MB" Gray
        
        # Run windeployqt to copy Qt dependencies
        Write-ColorOutput "`nRunning windeployqt..." Cyan
        $windeployqt = Join-Path $selectedQtDir "bin\windeployqt.exe"
        
        if (Test-Path $windeployqt) {
            $exeDir = Split-Path $exePath -Parent
            Write-ColorOutput "Command: `"$windeployqt`" `"$exePath`"`n" Gray
            
            & $windeployqt $exePath
            if ($LASTEXITCODE -eq 0) {
                Write-ColorOutput "windeployqt completed successfully." Green
                
                # Count deployed files
                $deployedFiles = Get-ChildItem -Path $exeDir -Recurse -File | Where-Object {
                    $_.Name -ne "Reclass.exe" -and $_.Extension -match '\.(dll|qm)$'
                }
                if ($deployedFiles) {
                    Write-ColorOutput "Deployed $($deployedFiles.Count) Qt dependency files." Gray
                }
            } else {
                Write-ColorOutput "WARNING: windeployqt failed with exit code $LASTEXITCODE" Yellow
                Write-ColorOutput "Application may not run without Qt DLLs in PATH" Yellow
            }
        } else {
            Write-ColorOutput "WARNING: windeployqt.exe not found at $windeployqt" Yellow
            Write-ColorOutput "Application may not run without Qt DLLs in PATH" Yellow
        }
    } else {
        Write-ColorOutput "WARNING: Could not locate Reclass.exe" Yellow
    }
    
} catch {
    Write-ColorOutput "`nERROR: Build failed with exception: $_" Red
    exit 1
} finally {
    Pop-Location
}

Write-ColorOutput "`n========================================" Cyan
Write-ColorOutput "Build completed successfully!" Cyan
Write-ColorOutput "========================================`n" Cyan

if ($exePath) {
    Write-ColorOutput "Run the application with:" White
    Write-ColorOutput "  .\build\Reclass.exe`n" Cyan
}

```

`scripts/build_qscintilla.ps1`:

```ps1
# PowerShell script to build QScintilla static library for Reclass
# This script checks for Qt installation, prompts if missing, and builds QScintilla

#Requires -Version 5.1

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$QtDir,
    
    [Parameter(Mandatory=$false)]
    [switch]$Clean
)

$ErrorActionPreference = "Stop"

# ──────────────────────────────────────────────────────────────────────────────
# Functions
# ──────────────────────────────────────────────────────────────────────────────

function Write-ColorOutput {
    param([string]$Message, [ConsoleColor]$Color = [ConsoleColor]::White)
    Write-Host $Message -ForegroundColor $Color
}

function Find-QtInstallation {
    $found = @()
    
    # Query registry for Qt installations
    $registryPaths = @(
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
    )
    
    foreach ($regPath in $registryPaths) {
        if (Test-Path $regPath) {
            Get-ChildItem -Path $regPath -ErrorAction SilentlyContinue | ForEach-Object {
                $displayName = (Get-ItemProperty -Path $_.PSPath -Name DisplayName -ErrorAction SilentlyContinue).DisplayName
                if ($displayName -and $displayName -match 'Qt') {
                    $installLocation = (Get-ItemProperty -Path $_.PSPath -Name InstallLocation -ErrorAction SilentlyContinue).InstallLocation
                    if ($installLocation -and (Test-Path $installLocation)) {
                        # Check if this is a Qt root directory, scan for MinGW installations
                        Get-ChildItem -Path $installLocation -Directory -ErrorAction SilentlyContinue | Where-Object {
                            $_.Name -match '^\d+\.\d+\.\d+$'
                        } | ForEach-Object {
                            Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object {
                                $_.Name -match 'mingw'
                            } | ForEach-Object {
                                $qmakePath = Join-Path $_.FullName "bin\qmake.exe"
                                if (Test-Path $qmakePath) {
                                    $found += $_.FullName
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    # Fallback: scan common paths if registry search found nothing
    if ($found.Count -eq 0) {
        $commonPaths = @(
            "C:\Qt",
            "D:\Qt",
            "E:\Qt",
            "F:\Qt"
        )
        
        foreach ($basePath in $commonPaths) {
            if (Test-Path $basePath) {
                Get-ChildItem -Path $basePath -Directory -ErrorAction SilentlyContinue | Where-Object {
                    $_.Name -match '^\d+\.\d+\.\d+$'
                } | ForEach-Object {
                    Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object {
                        $_.Name -match 'mingw'
                    } | ForEach-Object {
                        $qmakePath = Join-Path $_.FullName "bin\qmake.exe"
                        if (Test-Path $qmakePath) {
                            $found += $_.FullName
                        }
                    }
                }
            }
        }
    }
    
    return $found | Select-Object -Unique
}

function Select-QtDirectory {
    Add-Type -AssemblyName System.Windows.Forms
    $folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog
    $folderBrowser.Description = "Select Qt MinGW installation directory (e.g., C:\Qt\6.10.2\mingw_64)"
    $folderBrowser.RootFolder = [System.Environment+SpecialFolder]::MyComputer
    $folderBrowser.ShowNewFolderButton = $false
    
    if ($folderBrowser.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        return $folderBrowser.SelectedPath
    }
    return $null
}

function Get-QtDirectory {
    # 1. Check if provided as parameter
    if ($QtDir) {
        Write-ColorOutput "Using Qt directory from parameter: $QtDir" Cyan
        return $QtDir
    }
    
    # 2. Check environment variable and try to find MinGW under it
    if ($env:QTDIR) {
        $qtdirPath = $env:QTDIR
        Write-ColorOutput "Found QTDIR environment variable: $qtdirPath" Cyan
        
        # Check if QTDIR directly points to a valid MinGW installation
        $qmake = Join-Path $qtdirPath "bin\qmake.exe"
        if ((Test-Path $qmake) -and ($qtdirPath.ToLower() -match 'mingw')) {
            Write-ColorOutput "QTDIR points to valid MinGW installation." Green
            return $qtdirPath
        }
        
        # QTDIR might point to Qt root, search for MinGW subdirectories
        Write-ColorOutput "QTDIR appears to be Qt root directory. Searching for MinGW installations..." Yellow
        $foundMinGW = @()
        
        Get-ChildItem -Path $qtdirPath -Directory -ErrorAction SilentlyContinue | Where-Object {
            $_.Name -match '^\d+\.\d+\.\d+$'
        } | ForEach-Object {
            Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object {
                $_.Name -match 'mingw'
            } | ForEach-Object {
                $qmakePath = Join-Path $_.FullName "bin\qmake.exe"
                if (Test-Path $qmakePath) {
                    $foundMinGW += $_.FullName
                }
            }
        }
        
        if ($foundMinGW.Count -eq 1) {
            Write-ColorOutput "Found MinGW installation under QTDIR: $($foundMinGW[0])" Green
            $response = Read-Host "Use this installation? (Y/n)"
            if ($response -match '^(y|yes|)$' -or [string]::IsNullOrWhiteSpace($response)) {
                return $foundMinGW[0]
            }
        } elseif ($foundMinGW.Count -gt 1) {
            Write-ColorOutput "Found multiple MinGW installations under QTDIR:" Green
            for ($i = 0; $i -lt $foundMinGW.Count; $i++) {
                Write-Host "  [$($i+1)] $($foundMinGW[$i])"
            }
            
            do {
                $choice = Read-Host "Select Qt installation (1-$($foundMinGW.Count))"
                $choiceNum = 0
                $valid = [int]::TryParse($choice, [ref]$choiceNum) -and $choiceNum -ge 1 -and $choiceNum -le $foundMinGW.Count
            } until ($valid)
            
            return $foundMinGW[$choiceNum - 1]
        }
        
        Write-ColorOutput "No MinGW installations found under QTDIR." Yellow
    }
    
    # 3. Try to auto-detect
    Write-ColorOutput "Searching for Qt installations..." Yellow
    $detected = Find-QtInstallation
    
    if ($detected.Count -eq 1) {
        Write-ColorOutput "Found Qt installation: $($detected[0])" Green
        $response = Read-Host "Use this installation? (Y/n)"
        if ($response -match '^(y|yes|)$' -or [string]::IsNullOrWhiteSpace($response)) {
            return $detected[0]
        }
    } elseif ($detected.Count -gt 1) {
        Write-ColorOutput "Found multiple Qt installations:" Green
        for ($i = 0; $i -lt $detected.Count; $i++) {
            Write-Host "  [$($i+1)] $($detected[$i])"
        }
        Write-Host "  [0] Browse for directory manually"
        
        do {
            $choice = Read-Host "Select Qt installation (1-$($detected.Count), or 0 to browse)"
            $choiceNum = 0
            $valid = [int]::TryParse($choice, [ref]$choiceNum) -and $choiceNum -ge 0 -and $choiceNum -le $detected.Count
        } until ($valid)
        
        if ($choiceNum -gt 0) {
            return $detected[$choiceNum - 1]
        }
    }
    
    # 4. Manual input or browse
    Write-ColorOutput "No Qt MinGW installation auto-detected." Yellow
    Write-Host ""
    Write-Host "Options:"
    Write-Host "  [1] Browse for Qt MinGW directory"
    Write-Host "  [2] Enter path manually"
    Write-Host "  [3] Exit"
    
    do {
        $choice = Read-Host "Select option (1-3)"
    } until ($choice -match '^[123]$')
    
    switch ($choice) {
        "1" {
            $dir = Select-QtDirectory
            if ($dir) { return $dir }
            Write-ColorOutput "No directory selected. Exiting." Red
            exit 1
        }
        "2" {
            $dir = Read-Host "Enter Qt MinGW directory path (e.g., C:\Qt\6.10.2\mingw_64)"
            if ($dir) { return $dir }
            Write-ColorOutput "No path entered. Exiting." Red
            exit 1
        }
        "3" {
            Write-ColorOutput "Exiting." Yellow
            exit 0
        }
    }
}

function Validate-QtDirectory {
    param([string]$Dir)
    
    $qmake = Join-Path $Dir "bin\qmake.exe"
    if (-not (Test-Path $qmake)) {
        Write-ColorOutput "ERROR: qmake.exe not found in $Dir\bin\" Red
        Write-ColorOutput "Please ensure you selected a valid Qt installation directory (e.g., C:\Qt\6.10.2\mingw_64)" Red
        return $false
    }
    
    # Validate it's a MinGW build
    $dirLower = $Dir.ToLower()
    if ($dirLower -notmatch 'mingw') {
        Write-ColorOutput "ERROR: Selected Qt installation is not MinGW-based." Red
        Write-ColorOutput "This project requires Qt with MinGW compiler (e.g., C:\Qt\6.10.2\mingw_64)" Red
        Write-ColorOutput "Selected path: $Dir" Red
        return $false
    }
    
    return $true
}

function Find-MakeCommand {
    param([string]$QtDir)
    
    # Look for mingw32-make in Qt Tools directory
    $qtRoot = Split-Path (Split-Path $QtDir -Parent) -Parent
    $toolsDir = Join-Path $qtRoot "Tools"
    
    if (Test-Path $toolsDir) {
        $mingwMake = Get-ChildItem -Path $toolsDir -Recurse -Filter "mingw32-make.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($mingwMake) {
            return $mingwMake.FullName
        }
    }
    
    # Check system PATH
    $makeCmd = Get-Command mingw32-make.exe -ErrorAction SilentlyContinue
    if ($makeCmd) {
        return $makeCmd.Source
    }
    
    Write-ColorOutput "WARNING: mingw32-make.exe not found. Please ensure MinGW is in PATH." Yellow
    return "mingw32-make.exe"
}

# ──────────────────────────────────────────────────────────────────────────────
# Main Script
# ──────────────────────────────────────────────────────────────────────────────

Write-ColorOutput "`n========================================" Cyan
Write-ColorOutput "QScintilla Build Script for Reclass" Cyan
Write-ColorOutput "========================================`n" Cyan

# Get script directory and project root
$scriptDir = Split-Path -Parent $PSCommandPath
$projectRoot = Split-Path -Parent $scriptDir
$qsciSrcDir = Join-Path $projectRoot "third_party\qscintilla\src"

# Check if QScintilla source exists
if (-not (Test-Path $qsciSrcDir)) {
    Write-ColorOutput "ERROR: QScintilla source not found at $qsciSrcDir" Red
    Write-ColorOutput "Please extract QScintilla source to third_party/qscintilla/" Red
    exit 1
}

# Verify qscintilla.pro exists
$proFile = Join-Path $qsciSrcDir "qscintilla.pro"
if (-not (Test-Path $proFile)) {
    Write-ColorOutput "ERROR: qscintilla.pro not found at $proFile" Red
    exit 1
}

# Get Qt directory
$selectedQtDir = Get-QtDirectory
if (-not $selectedQtDir) {
    Write-ColorOutput "ERROR: No Qt directory provided." Red
    exit 1
}

# Validate Qt directory
if (-not (Validate-QtDirectory $selectedQtDir)) {
    exit 1
}

Write-ColorOutput "`nQt Directory: $selectedQtDir" Green

# Find make command
$makeCmd = Find-MakeCommand $selectedQtDir
Write-ColorOutput "Make Command: $makeCmd" Green

# Find MinGW bin directory (contains g++, cc1plus, etc.)
$mingwBinDir = $null
$qtRoot = Split-Path (Split-Path $selectedQtDir -Parent) -Parent
$toolsDir = Join-Path $qtRoot "Tools"

if (Test-Path $toolsDir) {
    # Look for MinGW tools directory
    $mingwToolDirs = Get-ChildItem -Path $toolsDir -Directory -ErrorAction SilentlyContinue | Where-Object {
        $_.Name -match 'mingw'
    }
    
    foreach ($dir in $mingwToolDirs) {
        $testBin = Join-Path $dir.FullName "bin\g++.exe"
        if (Test-Path $testBin) {
            $mingwBinDir = Join-Path $dir.FullName "bin"
            break
        }
    }
}

# Set up environment - add both Qt bin and MinGW bin to PATH
$qmakePath = Join-Path $selectedQtDir "bin\qmake.exe"
if ($mingwBinDir) {
    Write-ColorOutput "MinGW Directory: $mingwBinDir" Green
    $env:Path = "$mingwBinDir;$selectedQtDir\bin;$env:Path"
} else {
    Write-ColorOutput "WARNING: MinGW tools directory not found. Build may fail." Yellow
    Write-ColorOutput "Ensure MinGW bin directory (containing g++.exe, cc1plus.exe) is in PATH" Yellow
    $env:Path = "$selectedQtDir\bin;$env:Path"
}

# Clean if requested
if ($Clean) {
    Write-ColorOutput "`nCleaning previous build..." Yellow
    Push-Location $qsciSrcDir
    try {
        if (Test-Path "Makefile") {
            & $makeCmd clean 2>&1 | Out-Null
        }
        Remove-Item -Path "Makefile*", "release", "debug", "*.o", "*.obj" -Recurse -Force -ErrorAction SilentlyContinue
        Write-ColorOutput "Clean complete." Green
    } finally {
        Pop-Location
    }
}

# Change to QScintilla source directory
Write-ColorOutput "`nChanging to QScintilla source directory..." Cyan
Push-Location $qsciSrcDir

try {
    Write-ColorOutput "Current directory: $PWD`n" Gray
    
    # Run qmake
    Write-ColorOutput "Running qmake..." Cyan
    Write-ColorOutput "Command: `"$qmakePath`" qscintilla.pro `"CONFIG+=staticlib`"`n" Gray
    
    & $qmakePath qscintilla.pro "CONFIG+=staticlib"
    if ($LASTEXITCODE -ne 0) {
        Write-ColorOutput "`nERROR: qmake failed with exit code $LASTEXITCODE" Red
        exit 1
    }
    Write-ColorOutput "qmake completed successfully.`n" Green
    
    # Run make
    Write-ColorOutput "Running $makeCmd..." Cyan
    $cores = (Get-CimInstance -ClassName Win32_Processor).NumberOfLogicalProcessors
    if (-not $cores -or $cores -lt 1) {
        $cores = 4  # Default fallback
    }
    Write-ColorOutput "Command: `"$makeCmd`" -j$cores`n" Gray
    
    & $makeCmd "-j$cores"
    if ($LASTEXITCODE -ne 0) {
        Write-ColorOutput "`nERROR: make failed with exit code $LASTEXITCODE" Red
        exit 1
    }
    Write-ColorOutput "`nmake completed successfully.`n" Green
    
    # Check for output
    Write-ColorOutput "Checking for generated library files..." Cyan
    $foundLibs = @()
    
    $patterns = @("*.a", "*.lib")
    $searchDirs = @(".", "release", "debug")
    
    foreach ($dir in $searchDirs) {
        $fullPath = Join-Path $PWD $dir
        if (Test-Path $fullPath) {
            foreach ($pattern in $patterns) {
                $libs = Get-ChildItem -Path $fullPath -Filter $pattern -ErrorAction SilentlyContinue
                if ($libs) {
                    $foundLibs += $libs | ForEach-Object { 
                        [PSCustomObject]@{
                            Name = $_.Name
                            Path = $_.FullName
                            Size = $_.Length
                        }
                    }
                }
            }
        }
    }
    
    if ($foundLibs.Count -gt 0) {
        Write-ColorOutput "`nBuild successful! Generated libraries:" Green
        foreach ($lib in $foundLibs) {
            $sizeMB = [math]::Round($lib.Size / 1MB, 2)
            Write-Host "  - $($lib.Name) ($sizeMB MB)" -ForegroundColor Green
            Write-Host "    Path: $($lib.Path)" -ForegroundColor Gray
        }
        Write-ColorOutput "`nYou can now build Reclass with CMake." Green
    } else {
        Write-ColorOutput "`nWARNING: Build completed but no library files found." Yellow
        Write-ColorOutput "Expected files: qscintilla2_qt6.a or qscintilla2_qt6.lib" Yellow
    }
    
} catch {
    Write-ColorOutput "`nERROR: Build failed with exception: $_" Red
    exit 1
} finally {
    Pop-Location
}

Write-ColorOutput "`n========================================" Cyan
Write-ColorOutput "Build script completed successfully" Cyan
Write-ColorOutput "========================================`n" Cyan

```

`src/addressparser.cpp`:

```cpp
#include "addressparser.h"

namespace rcx {

// ── Address Expression Parser ──────────────────────────────────────────
//
// Parses expressions like:
//   "7FF66CCE0000"                    → plain hex address
//   "0x100 + 0x200"                   → arithmetic on hex values
//   "<Program.exe> + 0xDE"            → module base + offset
//   "[<Program.exe> + 0xDE] - AB"     → dereference pointer, then subtract
//   "7ff6`6cce0000"                   → WinDbg-style backtick separator (stripped before parsing)
//
// Grammar (standard operator precedence: *, / bind tighter than +, -):
//
//   expr   = term (('+' | '-') term)*
//   term   = unary (('*' | '/') unary)*
//   unary  = '-' unary | atom
//   atom   = '[' expr ']'             -- read pointer at address (dereference)
//          | '<' moduleName '>'       -- resolve module base address
//          | '(' expr ')'             -- grouping
//          | hexLiteral               -- hex number, optional 0x prefix
//
// All numeric literals are hexadecimal (base 16).
// Module names and pointer reads are resolved via optional callbacks.
// Without callbacks, modules and dereferences evaluate to 0 (syntax-check mode).

class ExpressionParser {
public:
    ExpressionParser(const QString& input, const AddressParserCallbacks* callbacks)
        : m_input(input), m_callbacks(callbacks) {}

    AddressParseResult parse() {
        skipSpaces();
        if (atEnd())
            return error("empty expression");

        uint64_t value = 0;
        if (!parseExpression(value))
            return error(m_error);

        skipSpaces();
        if (!atEnd())
            return error(QStringLiteral("unexpected '%1'").arg(m_input[m_pos]));

        return {true, value, {}, -1};
    }

private:
    const QString& m_input;
    const AddressParserCallbacks* m_callbacks;
    int m_pos = 0;
    QString m_error;
    int m_errorPos = 0;

    // ── Helpers ──

    bool atEnd() const { return m_pos >= m_input.size(); }

    QChar peek() const { return atEnd() ? QChar('\0') : m_input[m_pos]; }

    void advance() { m_pos++; }

    void skipSpaces() {
        while (!atEnd() && m_input[m_pos].isSpace())
            m_pos++;
    }

    AddressParseResult error(const QString& msg) const {
        return {false, 0, msg, m_errorPos};
    }

    bool fail(const QString& msg) {
        m_error = msg;
        m_errorPos = m_pos;
        return false;
    }

    bool expect(QChar ch) {
        skipSpaces();
        if (peek() != ch)
            return fail(QStringLiteral("expected '%1'").arg(ch));
        advance();
        return true;
    }

    static bool isHexDigit(QChar ch) {
        return (ch >= '0' && ch <= '9')
            || (ch >= 'a' && ch <= 'f')
            || (ch >= 'A' && ch <= 'F');
    }

    // ── Recursive descent parsing ──

    // expr = term (('+' | '-') term)*
    bool parseExpression(uint64_t& result) {
        if (!parseTerm(result))
            return false;

        for (;;) {
            skipSpaces();
            QChar op = peek();
            if (op != '+' && op != '-')
                break;
            advance();

            uint64_t rhs = 0;
            if (!parseTerm(rhs))
                return false;

            result = (op == '+') ? result + rhs : result - rhs;
        }
        return true;
    }

    // term = unary (('*' | '/') unary)*
    bool parseTerm(uint64_t& result) {
        if (!parseUnary(result))
            return false;

        for (;;) {
            skipSpaces();
            QChar op = peek();
            if (op != '*' && op != '/')
                break;
            advance();

            uint64_t rhs = 0;
            if (!parseUnary(rhs))
                return false;

            if (op == '*') {
                result *= rhs;
            } else {
                if (rhs == 0)
                    return fail("division by zero");
                result /= rhs;
            }
        }
        return true;
    }

    // unary = '-' unary | atom
    bool parseUnary(uint64_t& result) {
        skipSpaces();
        if (peek() == '-') {
            advance();
            uint64_t inner = 0;
            if (!parseUnary(inner))
                return false;
            result = static_cast<uint64_t>(-static_cast<int64_t>(inner));
            return true;
        }
        return parseAtom(result);
    }

    // atom = '[' expr ']' | '<' name '>' | '(' expr ')' | hexLiteral
    bool parseAtom(uint64_t& result) {
        skipSpaces();
        if (atEnd())
            return fail("unexpected end of expression");

        QChar ch = peek();

        if (ch == '[') return parseDereference(result);
        if (ch == '<') return parseModuleName(result);
        if (ch == '(') return parseGrouping(result);
        return parseHexNumber(result);
    }

    // '[' expr ']' — read the pointer value at the computed address
    bool parseDereference(uint64_t& result) {
        advance(); // skip '['

        uint64_t address = 0;
        if (!parseExpression(address))
            return false;
        if (!expect(']'))
            return false;

        // Without a callback, just return 0 (syntax-check mode)
        if (!m_callbacks || !m_callbacks->readPointer) {
            result = 0;
            return true;
        }

        bool ok = false;
        result = m_callbacks->readPointer(address, &ok);
        if (!ok)
            return fail(QStringLiteral("failed to read memory at 0x%1").arg(address, 0, 16));
        return true;
    }

    // '<' moduleName '>' — resolve a module's base address (e.g. <Program.exe>)
    bool parseModuleName(uint64_t& result) {
        advance(); // skip '<'

        int nameStart = m_pos;
        while (!atEnd() && peek() != '>')
            advance();
        if (atEnd())
            return fail("expected '>'");

        QString name = m_input.mid(nameStart, m_pos - nameStart).trimmed();
        advance(); // skip '>'

        if (name.isEmpty())
            return fail("empty module name");

        // Without a callback, just return 0 (syntax-check mode)
        if (!m_callbacks || !m_callbacks->resolveModule) {
            result = 0;
            return true;
        }

        bool ok = false;
        result = m_callbacks->resolveModule(name, &ok);
        if (!ok)
            return fail(QStringLiteral("module '%1' not found").arg(name));
        return true;
    }

    // '(' expr ')' — parenthesized sub-expression for grouping
    bool parseGrouping(uint64_t& result) {
        advance(); // skip '('
        if (!parseExpression(result))
            return false;
        return expect(')');
    }

    // Hex number with optional "0x" prefix. All literals are base-16.
    bool parseHexNumber(uint64_t& result) {
        skipSpaces();
        if (atEnd())
            return fail("unexpected end of expression");

        int start = m_pos;

        // Skip optional 0x/0X prefix
        if (m_pos + 1 < m_input.size()
            && m_input[m_pos] == '0'
            && (m_input[m_pos + 1] == 'x' || m_input[m_pos + 1] == 'X'))
            m_pos += 2;

        // Consume hex digits
        int digitsStart = m_pos;
        while (!atEnd() && isHexDigit(peek()))
            advance();

        if (m_pos == digitsStart) {
            m_errorPos = start;
            return fail("expected hex number");
        }

        QString digits = m_input.mid(digitsStart, m_pos - digitsStart);
        bool ok = false;
        result = digits.toULongLong(&ok, 16);
        if (!ok) {
            m_errorPos = start;
            return fail("invalid hex number");
        }
        return true;
    }
};

// ── Public API ─────────────────────────────────────────────────────────

AddressParseResult AddressParser::evaluate(const QString& formula, int ptrSize,
                                           const AddressParserCallbacks* cb)
{
    Q_UNUSED(ptrSize);

    // WinDbg displays 64-bit addresses with backtick separators for readability,
    // e.g. "00007ff6`1a2b3c4d". Strip them so users can paste directly.
    // Also remove ' in case user uses it
    QString cleaned = formula;
    cleaned.remove('`');
    cleaned.remove('\'');

    ExpressionParser parser(cleaned, cb);
    return parser.parse();
}

QString AddressParser::validate(const QString& formula)
{
    QString cleaned = formula;
    cleaned.remove('`');
    cleaned.remove('\'');
    cleaned = cleaned.trimmed();
    if (cleaned.isEmpty())
        return QStringLiteral("empty");

    // Parse with no callbacks — modules and dereferences succeed but return 0.
    // This checks syntax only.
    ExpressionParser parser(cleaned, nullptr);
    auto result = parser.parse();
    return result.ok ? QString() : result.error;
}

} // namespace rcx

```

`src/addressparser.h`:

```h
#pragma once
#include <QString>
#include <cstdint>
#include <functional>

namespace rcx {

struct AddressParseResult {
    bool ok;
    uint64_t value;
    QString error;
    int errorPos;
};

struct AddressParserCallbacks {
    std::function<uint64_t(const QString& name, bool* ok)> resolveModule;
    std::function<uint64_t(uint64_t addr, bool* ok)>       readPointer;
};

class AddressParser {
public:
    static AddressParseResult evaluate(const QString& formula, int ptrSize = 8,
                                       const AddressParserCallbacks* cb = nullptr);
    static QString validate(const QString& formula);
};

} // namespace rcx

```

`src/app.rc`:

```rc
IDI_ICON1 ICON "icons/class.ico"

```

`src/compose.cpp`:

```cpp
#include "core.h"
#include <algorithm>
#include <numeric>

namespace rcx {

namespace {

// Scintilla fold constants (avoid including Scintilla headers in core)
constexpr int SC_FOLDLEVELBASE       = 0x400;
constexpr int SC_FOLDLEVELHEADERFLAG = 0x2000;
constexpr uint64_t kGoldenRatio      = 0x9E3779B97F4A7C15ULL;

struct ComposeState {
    QString            text;
    QVector<LineMeta>  meta;
    QSet<uint64_t>     visiting;      // cycle detection for struct recursion
    QSet<qulonglong>   ptrVisiting;   // cycle guard for pointer expansions
    QSet<uint64_t>     virtualPtrRefs; // refIds currently being virtually expanded via pointer deref
    int                currentLine = 0;
    int                typeW       = kColType;  // global type column width (fallback)
    int                nameW       = kColName;  // global name column width (fallback)
    int                offsetHexDigits = 8;     // hex digit tier for offset margin
    bool               baseEmitted = false;     // only first root struct shows base address
    bool               compactColumns = false;  // compact column mode: cap type width, overflow long types
    uint64_t           currentPtrBase = 0;      // absolute addr of current pointer expansion target

    // Precomputed for O(1) lookups
    QHash<uint64_t, QVector<int>> childMap;
    QVector<int64_t>              absOffsets;  // indexed by node index

    // Per-scope column widths (containerId -> width for direct children)
    QHash<uint64_t, int> scopeTypeW;
    QHash<uint64_t, int> scopeNameW;

    int effectiveTypeW(uint64_t scopeId) const {
        return scopeTypeW.value(scopeId, typeW);
    }
    int effectiveNameW(uint64_t scopeId) const {
        return scopeNameW.value(scopeId, nameW);
    }

    void emitLine(const QString& lineText, LineMeta lm) {
        if (currentLine > 0) text += '\n';
        // 3-char fold indicator column: " - " expanded, " + " collapsed, "   " other
        // CommandRow has no fold prefix (flush left)
        if (lm.lineKind == LineKind::CommandRow
            || (lm.lineKind == LineKind::Footer && lm.isRootHeader)) {
            // no prefix — flush left
        } else if (lm.foldHead)
            text += lm.foldCollapsed ? QStringLiteral(" \u25B8 ") : QStringLiteral(" \u25BE ");
        else
            text += QStringLiteral("   ");
        text += lineText;
        meta.append(lm);
        currentLine++;
    }
};

int computeFoldLevel(int depth, bool isHead) {
    int level = SC_FOLDLEVELBASE + depth;
    if (isHead) level |= SC_FOLDLEVELHEADERFLAG;
    return level;
}

uint32_t computeMarkers(const Node& node, const Provider& /*prov*/,
                        uint64_t /*addr*/, bool isCont, int /*depth*/) {
    uint32_t mask = 0;
    if (isCont)                          mask |= (1u << M_CONT);
    // No ambient validation markers — errors only shown during inline editing.
    return mask;
}

static QString resolvePointerTarget(const NodeTree& tree, uint64_t refId) {
    if (refId == 0) return {};
    int refIdx = tree.indexOfId(refId);
    if (refIdx < 0) return {};
    const Node& ref = tree.nodes[refIdx];
    return ref.structTypeName.isEmpty() ? ref.name : ref.structTypeName;
}

static int64_t relOffsetFromRoot(const NodeTree& tree, int idx, uint64_t rootId) {
    int64_t total = 0;
    QSet<uint64_t> visited;
    int cur = idx;
    while (cur >= 0 && cur < tree.nodes.size()) {
        uint64_t nid = tree.nodes[cur].id;
        if (visited.contains(nid)) break;
        visited.insert(nid);
        const Node& n = tree.nodes[cur];
        if (n.id == rootId) break;
        total += n.offset;
        if (n.parentId == 0) break;
        cur = tree.indexOfId(n.parentId);
    }
    return total;
}

static inline uint64_t resolveAddr(const ComposeState& state,
                                   const NodeTree& tree,
                                   int nodeIdx,
                                   uint64_t base, uint64_t rootId) {
    if (rootId != 0)
        return base + relOffsetFromRoot(tree, nodeIdx, rootId);
    return state.absOffsets[nodeIdx];
}


static const QVector<int>& childIndices(const ComposeState& state, uint64_t parentId) {
    static const QVector<int> kEmpty;
    auto it = state.childMap.constFind(parentId);
    return it == state.childMap.constEnd() ? kEmpty : it.value();
}

void composeLeaf(ComposeState& state, const NodeTree& tree,
                 const Provider& prov, int nodeIdx,
                 int depth, uint64_t absAddr, uint64_t scopeId) {
    const Node& node = tree.nodes[nodeIdx];

    // Get per-scope widths (falls back to global if no scope entry)
    int typeW = state.effectiveTypeW(scopeId);
    int nameW = state.effectiveNameW(scopeId);

    int numLines = linesForKind(node.kind);

    // Resolve pointer target name for display
    QString ptrTypeOverride;
    QString ptrTargetName;
    if (node.kind == NodeKind::Pointer32 || node.kind == NodeKind::Pointer64) {
        if (node.ptrDepth > 0 && isValidPrimitivePtrTarget(node.elementKind)) {
            // Primitive pointer: e.g. "int32*" or "f64**"
            const auto* meta = kindMeta(node.elementKind);
            QString baseName = meta ? QString::fromLatin1(meta->typeName)
                                    : QStringLiteral("void");
            QString stars = (node.ptrDepth >= 2) ? QStringLiteral("**") : QStringLiteral("*");
            ptrTypeOverride = baseName + stars;
        } else {
            ptrTargetName = resolvePointerTarget(tree, node.refId);
            ptrTypeOverride = fmt::pointerTypeName(node.kind, ptrTargetName);
        }
    }

    // Detect type overflow in compact mode (for effectiveTypeW)
    QString rawType = ptrTypeOverride.isEmpty() ? fmt::typeNameRaw(node.kind) : ptrTypeOverride;
    bool typeOverflow = state.compactColumns && rawType.size() > typeW;
    int lineTypeW = typeOverflow ? rawType.size() : typeW;

    for (int sub = 0; sub < numLines; sub++) {
        bool isCont = (sub > 0);

        LineMeta lm;
        lm.nodeIdx        = nodeIdx;
        lm.nodeId          = node.id;
        lm.subLine         = sub;
        lm.depth           = depth;
        lm.isContinuation  = isCont;
        lm.lineKind        = isCont ? LineKind::Continuation : LineKind::Field;
        lm.nodeKind        = node.kind;
        lm.offsetText      = fmt::fmtOffsetMargin(absAddr, isCont, state.offsetHexDigits);
        lm.offsetAddr      = absAddr;
        lm.ptrBase         = state.currentPtrBase;
        lm.markerMask      = computeMarkers(node, prov, absAddr, isCont, depth);
        lm.foldLevel       = computeFoldLevel(depth, false);
        lm.effectiveTypeW  = lineTypeW;
        lm.effectiveNameW  = nameW;
        lm.pointerTargetName = ptrTargetName;

        // Set byte count for hex preview lines (used for per-byte change highlighting)
        if (isHexPreview(node.kind)) {
            lm.lineByteCount = sizeForKind(node.kind);
        }

        QString lineText = fmt::fmtNodeLine(node, prov, absAddr, depth, sub,
                                            /*comment=*/{}, typeW, nameW, ptrTypeOverride,
                                            state.compactColumns);
        state.emitLine(lineText, lm);
    }
}

// Forward declarations (base/rootId default to 0 = use precomputed offsets)
void composeNode(ComposeState& state, const NodeTree& tree,
                 const Provider& prov, int nodeIdx, int depth,
                 uint64_t base = 0, uint64_t rootId = 0, bool isArrayChild = false,
                 uint64_t scopeId = 0, int arrayElementIdx = -1,
                 uint64_t arrayContainerAddr = 0);
void composeParent(ComposeState& state, const NodeTree& tree,
                   const Provider& prov, int nodeIdx, int depth,
                   uint64_t base = 0, uint64_t rootId = 0, bool isArrayChild = false,
                   uint64_t scopeId = 0, int arrayElementIdx = -1,
                   uint64_t arrayContainerAddr = 0);

void composeParent(ComposeState& state, const NodeTree& tree,
                   const Provider& prov, int nodeIdx, int depth,
                   uint64_t base, uint64_t rootId, bool isArrayChild,
                   uint64_t scopeId, int arrayElementIdx,
                   uint64_t arrayContainerAddr) {
    const Node& node = tree.nodes[nodeIdx];
    uint64_t absAddr = resolveAddr(state, tree, nodeIdx, base, rootId);

    // Cycle detection
    if (state.visiting.contains(node.id)) {
        LineMeta lm;
        lm.nodeIdx    = nodeIdx;
        lm.nodeId     = node.id;
        lm.depth      = depth;
        lm.lineKind   = LineKind::Field;
        lm.offsetText = fmt::fmtOffsetMargin(absAddr, false, state.offsetHexDigits);
        lm.offsetAddr = absAddr;
        lm.ptrBase    = state.currentPtrBase;
        lm.nodeKind   = node.kind;
        lm.markerMask = (1u << M_CYCLE) | (1u << M_ERR);
        lm.foldLevel  = computeFoldLevel(depth, false);
        state.emitLine(fmt::indent(depth) + QStringLiteral("/* CYCLE: ") +
                       node.name + QStringLiteral(" */"), lm);
        return;
    }
    state.visiting.insert(node.id);

    // Array element separator: show [N] to indicate which element this is
    if (isArrayChild && arrayElementIdx >= 0) {
        LineMeta lm;
        lm.nodeIdx    = nodeIdx;
        lm.nodeId     = node.id;
        lm.depth      = depth;
        lm.lineKind   = LineKind::ArrayElementSeparator;
        lm.offsetText = fmt::fmtOffsetMargin(absAddr, false, state.offsetHexDigits);
        lm.offsetAddr = absAddr;
        lm.ptrBase    = state.currentPtrBase;
        lm.nodeKind   = node.kind;
        lm.foldLevel  = computeFoldLevel(depth, false);
        lm.markerMask = 0;
        lm.arrayElementIdx = arrayElementIdx;
        uint64_t relOff = absAddr - arrayContainerAddr;
        QString relOffHex = QString::number(relOff, 16).toUpper();
        state.emitLine(fmt::indent(depth) + QStringLiteral("[%1] +0x%2").arg(arrayElementIdx).arg(relOffHex), lm);
    }

    // Detect root header: first root-level struct — suppressed from display
    // (CommandRow already shows the root class type + name)
    bool isRootHeader = (node.parentId == 0 && node.kind == NodeKind::Struct && !state.baseEmitted);
    if (isRootHeader)
        state.baseEmitted = true;

    // Header line (skip for array element structs and root struct)
    // Root struct header is on CommandRow (type + name + {)
    if (!isArrayChild && !isRootHeader) {
        // Get per-scope widths for this header's parent scope
        int typeW = state.effectiveTypeW(scopeId);
        int nameW = state.effectiveNameW(scopeId);

        LineMeta lm;
        lm.nodeIdx    = nodeIdx;
        lm.nodeId     = node.id;
        lm.depth      = depth;
        lm.lineKind   = LineKind::Header;
        lm.offsetText = fmt::fmtOffsetMargin(absAddr, false, state.offsetHexDigits);
        lm.offsetAddr = absAddr;
        lm.ptrBase    = state.currentPtrBase;
        lm.nodeKind   = node.kind;
        lm.isRootHeader = false;
        lm.foldHead      = true;
        lm.foldCollapsed = node.collapsed;
        lm.foldLevel  = computeFoldLevel(depth, true);
        lm.markerMask = (1u << M_STRUCT_BG);

        QString headerText;
        if (node.kind == NodeKind::Array) {
            // Array header with navigation: "uint32_t[16]  name  {" (no brace when collapsed)
            lm.isArrayHeader = true;
            lm.elementKind   = node.elementKind;
            lm.arrayViewIdx  = node.viewIndex;
            lm.arrayCount    = node.arrayLen;
            QString elemStructName = (node.elementKind == NodeKind::Struct)
                ? resolvePointerTarget(tree, node.refId) : QString();
            QString rawType = fmt::arrayTypeName(node.elementKind, node.arrayLen, elemStructName);
            bool overflow = state.compactColumns && rawType.size() > typeW;
            lm.effectiveTypeW = overflow ? rawType.size() : typeW;
            lm.effectiveNameW = nameW;
            headerText = fmt::fmtArrayHeader(node, depth, node.viewIndex, node.collapsed, typeW, nameW, elemStructName, state.compactColumns);
        } else {
            // All structs (root and nested) use the same header format
            QString rawType = fmt::structTypeName(node);
            bool overflow = state.compactColumns && rawType.size() > typeW;
            lm.effectiveTypeW = overflow ? rawType.size() : typeW;
            lm.effectiveNameW = nameW;
            headerText = fmt::fmtStructHeader(node, depth, node.collapsed, typeW, nameW, state.compactColumns);
        }
        state.emitLine(headerText, lm);
    }

    if (!node.collapsed || isArrayChild || isRootHeader) {
        // Enum with members: render name = value lines instead of offset-based fields
        if (node.resolvedClassKeyword() == QStringLiteral("enum") && !node.enumMembers.isEmpty()) {
            int childDepth = depth + 1;
            int maxNameLen = 4;
            for (const auto& m : node.enumMembers)
                maxNameLen = qMax(maxNameLen, (int)m.first.size());

            for (int mi = 0; mi < node.enumMembers.size(); mi++) {
                const auto& m = node.enumMembers[mi];
                LineMeta lm;
                lm.nodeIdx    = nodeIdx;
                lm.nodeId     = node.id;
                lm.subLine    = mi;
                lm.depth      = childDepth;
                lm.lineKind   = LineKind::Field;
                lm.nodeKind   = NodeKind::UInt32;
                lm.foldLevel  = computeFoldLevel(childDepth, false);
                lm.markerMask = 0;
                lm.offsetText = fmt::fmtOffsetMargin(absAddr, true, state.offsetHexDigits);
                lm.offsetAddr = absAddr;
                lm.ptrBase    = state.currentPtrBase;
                state.emitLine(fmt::fmtEnumMember(m.first, m.second, childDepth, maxNameLen), lm);
            }

            // Footer
            if (!isArrayChild) {
                LineMeta lm;
                lm.nodeIdx   = nodeIdx;
                lm.nodeId    = node.id;
                lm.depth     = depth;
                lm.lineKind  = LineKind::Footer;
                lm.nodeKind  = node.kind;
                lm.isRootHeader = isRootHeader;
                lm.foldLevel = computeFoldLevel(depth, false);
                lm.markerMask = 0;
                lm.offsetText = fmt::fmtOffsetMargin(absAddr, false, state.offsetHexDigits);
                lm.offsetAddr = absAddr;
                lm.ptrBase    = state.currentPtrBase;
                state.emitLine(fmt::fmtStructFooter(node, depth, 0), lm);
            }

            state.visiting.remove(node.id);
            return;
        }

        const QVector<int>& children = childIndices(state, node.id);

        int childDepth = depth + 1;

        // Primitive arrays with no child nodes: synthesize element lines dynamically
        if (node.kind == NodeKind::Array && children.isEmpty()
            && node.elementKind != NodeKind::Struct && node.elementKind != NodeKind::Array) {
            int elemSize = sizeForKind(node.elementKind);
            int eTW = state.effectiveTypeW(node.id);
            int eNW = state.effectiveNameW(node.id);
            for (int i = 0; i < node.arrayLen; i++) {
                uint64_t elemAddr = absAddr + i * elemSize;

                // Type override: "float[0]", "uint32_t[1]", etc.
                QString elemTypeStr = fmt::typeNameRaw(node.elementKind)
                                    + QStringLiteral("[%1]").arg(i);

                Node elem;
                elem.kind = node.elementKind;
                elem.name = QString();  // no name for array elements
                elem.offset = node.offset + i * elemSize;
                elem.parentId = node.id;
                elem.id = 0;

                LineMeta lm;
                lm.nodeIdx    = nodeIdx;
                lm.nodeId     = node.id;
                lm.depth      = childDepth;
                lm.lineKind   = LineKind::Field;
                lm.nodeKind   = node.elementKind;
                lm.isArrayElement = true;
                lm.arrayElementIdx = i;
                lm.offsetText = fmt::fmtOffsetMargin(elemAddr, false, state.offsetHexDigits);
                lm.offsetAddr = elemAddr;
                lm.ptrBase    = state.currentPtrBase;
                lm.markerMask = computeMarkers(elem, prov, elemAddr, false, childDepth);
                lm.foldLevel  = computeFoldLevel(childDepth, false);
                bool elemOverflow = state.compactColumns && elemTypeStr.size() > eTW;
                lm.effectiveTypeW = elemOverflow ? elemTypeStr.size() : eTW;
                lm.effectiveNameW = eNW;

                state.emitLine(fmt::fmtNodeLine(elem, prov, elemAddr, childDepth, 0,
                                                {}, eTW, eNW, elemTypeStr,
                                                state.compactColumns), lm);
            }
        }

        // Struct arrays with refId but no child nodes: synthesize by expanding the
        // referenced struct for each element (like repeated pointer deref)
        if (node.kind == NodeKind::Array && children.isEmpty()
            && node.elementKind == NodeKind::Struct && node.refId != 0) {
            int refIdx = tree.indexOfId(node.refId);
            if (refIdx >= 0) {
                int elemSize = tree.structSpan(node.refId, &state.childMap);
                if (elemSize <= 0) elemSize = 1;
                for (int i = 0; i < node.arrayLen; i++) {
                    uint64_t elemBase = absAddr + (uint64_t)i * elemSize;
                    // Use base offset that maps refStruct's children to the right provider address
                    composeParent(state, tree, prov, refIdx, childDepth, elemBase, node.refId,
                                  /*isArrayChild=*/true, node.id, i, absAddr);
                }
            }
        }

        // Embedded struct with refId but no child nodes: expand referenced struct's
        // children at this node's offset (single instance, like array with count=1)
        if (node.kind == NodeKind::Struct && children.isEmpty() && node.refId != 0) {
            int refIdx = tree.indexOfId(node.refId);
            if (refIdx >= 0) {
                const QVector<int>& refChildren = childIndices(state, node.refId);
                // Use the referenced struct's scope widths (children come from there)
                uint64_t refScopeId = node.refId;
                for (int childIdx : refChildren) {
                    const Node& child = tree.nodes[childIdx];
                    // Self-referential child → show as collapsed struct (non-expandable)
                    if (state.visiting.contains(child.id)) {
                        int typeW = state.effectiveTypeW(refScopeId);
                        int nameW = state.effectiveNameW(refScopeId);
                        QString rawType = fmt::structTypeName(child);
                        bool overflow = state.compactColumns && rawType.size() > typeW;
                        LineMeta lm;
                        lm.nodeIdx    = nodeIdx;  // parent struct — materialize target
                        lm.nodeId     = child.id;
                        lm.depth      = childDepth;
                        lm.lineKind   = LineKind::Header;
                        lm.offsetText = fmt::fmtOffsetMargin(
                            absAddr + child.offset, false,
                            state.offsetHexDigits);
                        lm.offsetAddr = absAddr + child.offset;
                        lm.ptrBase    = state.currentPtrBase;
                        lm.nodeKind   = child.kind;
                        lm.foldHead      = true;
                        lm.foldCollapsed = true;
                        lm.foldLevel  = computeFoldLevel(childDepth, true);
                        lm.markerMask = (1u << M_STRUCT_BG) | (1u << M_CYCLE);
                        lm.effectiveTypeW = overflow ? rawType.size() : typeW;
                        lm.effectiveNameW = nameW;
                        state.emitLine(fmt::fmtStructHeader(child, childDepth,
                            /*collapsed=*/true, typeW, nameW, state.compactColumns), lm);
                        continue;
                    }
                    composeNode(state, tree, prov, childIdx, childDepth,
                                absAddr, node.refId, false, refScopeId);
                }
            }
        }

        // For arrays, render children as condensed (no header/footer for struct elements)
        bool childrenAreArrayElements = (node.kind == NodeKind::Array);
        int elementIdx = 0;
        for (int childIdx : children) {
            // Pass this container's id as the scope for children (for per-scope widths)
            // For array elements, also pass the element index for [N] separator
            composeNode(state, tree, prov, childIdx, childDepth, base, rootId,
                        childrenAreArrayElements, node.id,
                        childrenAreArrayElements ? elementIdx++ : -1,
                        childrenAreArrayElements ? absAddr : 0);
        }
    }

    // Footer line: skip when collapsed or for array element structs
    if (!isArrayChild && (!node.collapsed || isRootHeader)) {
        LineMeta lm;
        lm.nodeIdx   = nodeIdx;
        lm.nodeId    = node.id;
        lm.depth     = depth;
        lm.lineKind   = LineKind::Footer;
        lm.nodeKind   = node.kind;
        lm.isRootHeader = isRootHeader;  // root footer: flush left (no fold prefix)
        lm.foldLevel  = computeFoldLevel(depth, false);
        lm.markerMask = 0;
        int sz = tree.structSpan(node.id, &state.childMap);
        lm.offsetText = fmt::fmtOffsetMargin(absAddr + sz, false, state.offsetHexDigits);
        lm.offsetAddr = absAddr + sz;
        lm.ptrBase    = state.currentPtrBase;
        state.emitLine(fmt::fmtStructFooter(node, depth, sz), lm);
    }

    state.visiting.remove(node.id);
}

void composeNode(ComposeState& state, const NodeTree& tree,
                 const Provider& prov, int nodeIdx, int depth,
                 uint64_t base, uint64_t rootId, bool isArrayChild,
                 uint64_t scopeId, int arrayElementIdx,
                 uint64_t arrayContainerAddr) {
    const Node& node = tree.nodes[nodeIdx];
    uint64_t absAddr = resolveAddr(state, tree, nodeIdx, base, rootId);

    // Get per-scope widths for this node
    int typeW = state.effectiveTypeW(scopeId);
    int nameW = state.effectiveNameW(scopeId);

    // Pointer deref expansion — single fold header merges pointer + struct header
    if ((node.kind == NodeKind::Pointer32 || node.kind == NodeKind::Pointer64)
        && node.refId != 0) {
        QString ptrTargetName = resolvePointerTarget(tree, node.refId);
        QString ptrTypeOverride = fmt::pointerTypeName(node.kind, ptrTargetName);

        // Check if this pointer has materialized children (from materializeRefChildren)
        const QVector<int>& ptrChildren = childIndices(state, node.id);
        bool hasMaterialized = !ptrChildren.isEmpty();

        // Force collapsed if this refId is already being virtually expanded
        // (prevents infinite recursion in virtual expansion mode).
        // Materialized children bypass this — they are real tree nodes with
        // independent collapsed state, so recursion is bounded by the tree.
        bool forceCollapsed = !hasMaterialized
                              && state.virtualPtrRefs.contains(node.refId);
        bool effectiveCollapsed = node.collapsed || forceCollapsed;

        // Emit merged fold header: "Type* Name {" (expanded) or "Type* Name -> val" (collapsed)
        {
            LineMeta lm;
            lm.nodeIdx    = nodeIdx;
            lm.nodeId     = node.id;
            lm.depth      = depth;
            lm.lineKind   = effectiveCollapsed ? LineKind::Field : LineKind::Header;
            lm.offsetText = fmt::fmtOffsetMargin(absAddr, false, state.offsetHexDigits);
            lm.offsetAddr = absAddr;
            lm.ptrBase    = state.currentPtrBase;
            lm.nodeKind   = node.kind;
            lm.foldHead      = true;
            lm.foldCollapsed = effectiveCollapsed;
            lm.foldLevel  = computeFoldLevel(depth, true);
            lm.markerMask = computeMarkers(node, prov, absAddr, false, depth);
            if (forceCollapsed) lm.markerMask |= (1u << M_CYCLE);
            bool ptrOverflow = state.compactColumns && ptrTypeOverride.size() > typeW;
            lm.effectiveTypeW = ptrOverflow ? ptrTypeOverride.size() : typeW;
            lm.effectiveNameW = nameW;
            lm.pointerTargetName = ptrTargetName;
            state.emitLine(fmt::fmtPointerHeader(node, depth, effectiveCollapsed,
                                                  prov, absAddr, ptrTypeOverride,
                                                  typeW, nameW, state.compactColumns), lm);
        }

        if (!effectiveCollapsed) {
            int sz = node.byteSize();
            uint64_t ptrVal = 0;
            if (prov.isValid() && sz > 0 && prov.isReadable(absAddr, sz)) {
                ptrVal = (node.kind == NodeKind::Pointer32)
                    ? (uint64_t)prov.readU32(absAddr) : prov.readU64(absAddr);
                if (ptrVal != 0) {
                    // Treat sentinel values as invalid pointers
                    if (ptrVal == UINT64_MAX || (node.kind == NodeKind::Pointer32 && ptrVal == 0xFFFFFFFF))
                        ptrVal = 0;
                }
            }

            // Pointer target address is used directly (absolute)
            uint64_t pBase = ptrVal;
            bool ptrReadable = (ptrVal != 0) && prov.isReadable(pBase, 1);

            // For invalid/unreadable pointers: use NullProvider (shows zeros)
            static NullProvider s_nullProv;
            const Provider& childProv = ptrReadable ? prov : static_cast<const Provider&>(s_nullProv);
            if (!ptrReadable)
                pBase = 0;

            uint64_t savedPtrBase = state.currentPtrBase;
            state.currentPtrBase = pBase;

            if (hasMaterialized) {
                // Render materialized children at the pointer target address.
                // These are real tree nodes with independent state — use rootId
                // so resolveAddr computes offsets relative to the pointer target.
                for (int childIdx : ptrChildren) {
                    composeNode(state, tree, childProv, childIdx, depth + 1,
                                pBase, node.id, false, node.id);
                }
            } else {
                // Virtual expansion via ref struct definition.
                // Temporarily remove the ref struct from visiting so composeParent
                // doesn't hit the struct-level cycle guard. The ptrVisiting mechanism
                // handles actual address-level pointer cycles, and virtualPtrRefs
                // prevents infinite virtual recursion (inner self-referential pointers
                // are force-collapsed with M_CYCLE for the user to materialize).
                qulonglong key = pBase ^ (node.refId * kGoldenRatio);
                if (!state.ptrVisiting.contains(key)) {
                    state.ptrVisiting.insert(key);
                    int refIdx = tree.indexOfId(node.refId);
                    if (refIdx >= 0) {
                        const Node& ref = tree.nodes[refIdx];
                        if (ref.kind == NodeKind::Struct || ref.kind == NodeKind::Array) {
                            bool wasVisiting = state.visiting.remove(node.refId);
                            state.virtualPtrRefs.insert(node.refId);
                            composeParent(state, tree, childProv, refIdx,
                                          depth, pBase, ref.id,
                                          /*isArrayChild=*/true);
                            state.virtualPtrRefs.remove(node.refId);
                            if (wasVisiting) state.visiting.insert(node.refId);
                        }
                    }
                    state.ptrVisiting.remove(key);
                }
            }

            state.currentPtrBase = savedPtrBase;

            // Footer for pointer fold
            {
                LineMeta lm;
                lm.nodeIdx   = nodeIdx;
                lm.nodeId    = node.id;
                lm.depth     = depth;
                lm.lineKind  = LineKind::Footer;
                lm.nodeKind  = node.kind;
                lm.offsetText.clear();
                lm.foldLevel = computeFoldLevel(depth, false);
                lm.markerMask = 0;
                state.emitLine(fmt::indent(depth) + QStringLiteral("}"), lm);
            }
        }
        return;
    }

    if (node.kind == NodeKind::Struct || node.kind == NodeKind::Array) {
        composeParent(state, tree, prov, nodeIdx, depth, base, rootId, isArrayChild, scopeId, arrayElementIdx, arrayContainerAddr);
    } else {
        composeLeaf(state, tree, prov, nodeIdx, depth, absAddr, scopeId);
    }
}

} // anonymous namespace

ComposeResult compose(const NodeTree& tree, const Provider& prov, uint64_t viewRootId,
                      bool compactColumns) {
    ComposeState state;
    state.compactColumns = compactColumns;

    // Precompute parent→children map
    for (int i = 0; i < tree.nodes.size(); i++)
        state.childMap[tree.nodes[i].parentId].append(i);

    for (auto it = state.childMap.begin(); it != state.childMap.end(); ++it) {
        QVector<int>& children = it.value();
        std::sort(children.begin(), children.end(), [&](int a, int b) {
            return tree.nodes[a].offset < tree.nodes[b].offset;
        });
    }

    // Precompute absolute offsets (baseAddress + structure-relative offset)
    state.absOffsets.resize(tree.nodes.size());
    for (int i = 0; i < tree.nodes.size(); i++)
        state.absOffsets[i] = tree.baseAddress + tree.computeOffset(i);

    // Compute hex digit tier from max absolute address
    {
        uint64_t maxAddr = tree.baseAddress;
        for (int i = 0; i < tree.nodes.size(); i++) {
            uint64_t addr = (uint64_t)state.absOffsets[i];
            if (addr > maxAddr) maxAddr = addr;
        }
        if      (maxAddr <= 0xFFFFULL)             state.offsetHexDigits = 4;
        else if (maxAddr <= 0xFFFFFFFFULL)         state.offsetHexDigits = 8;
        else if (maxAddr <= 0xFFFFFFFFFFFFULL)     state.offsetHexDigits = 12;
        else                                        state.offsetHexDigits = 16;
    }

    // Helper: compute the display type string for a node (for width calculation)
    auto nodeTypeName = [&](const Node& n) -> QString {
        if (n.kind == NodeKind::Array) {
            QString sn = (n.elementKind == NodeKind::Struct)
                ? resolvePointerTarget(tree, n.refId) : QString();
            return fmt::arrayTypeName(n.elementKind, n.arrayLen, sn);
        }
        if (n.kind == NodeKind::Struct)
            return fmt::structTypeName(n);
        if (n.kind == NodeKind::Pointer32 || n.kind == NodeKind::Pointer64)
            return fmt::pointerTypeName(n.kind, resolvePointerTarget(tree, n.refId));
        return fmt::typeNameRaw(n.kind);
    };

    // Compute effective type column width from longest type name
    // Include struct/array headers which use "struct TypeName" or "type[count]" format
    const int typeCap = state.compactColumns ? kCompactTypeW : kMaxTypeW;
    int maxTypeLen = kMinTypeW;
    for (const Node& node : tree.nodes) {
        maxTypeLen = qMax(maxTypeLen, (int)nodeTypeName(node).size());
    }
    state.typeW = qBound(kMinTypeW, maxTypeLen, typeCap);

    // Compute effective name column width from longest name
    // Include struct/array names - they now use columnar layout too
    int maxNameLen = kMinNameW;
    for (const Node& node : tree.nodes) {
        // Skip hex (they show ASCII preview, not name column)
        if (isHexPreview(node.kind)) continue;
        maxNameLen = qMax(maxNameLen, (int)node.name.size());
    }
    state.nameW = qBound(kMinNameW, maxNameLen, kMaxNameW);

    // Pre-compute per-scope widths (each container gets widths based on direct children only)
    for (int i = 0; i < tree.nodes.size(); i++) {
        const Node& container = tree.nodes[i];
        if (container.kind != NodeKind::Struct && container.kind != NodeKind::Array)
            continue;

        int scopeMaxType = kMinTypeW;
        int scopeMaxName = kMinNameW;

        for (int childIdx : state.childMap.value(container.id)) {
            const Node& child = tree.nodes[childIdx];
            scopeMaxType = qMax(scopeMaxType, (int)nodeTypeName(child).size());

            // Name width (skip hex, but include containers)
            if (!isHexPreview(child.kind)) {
                scopeMaxName = qMax(scopeMaxName, (int)child.name.size());
            }
        }

        // Primitive arrays with no tree children: account for synthesized element types
        // e.g. "uint32_t[0]", "uint32_t[99]" — longest index determines width
        if (container.kind == NodeKind::Array
            && state.childMap.value(container.id).isEmpty()
            && container.elementKind != NodeKind::Struct
            && container.elementKind != NodeKind::Array
            && container.arrayLen > 0) {
            int maxIdx = container.arrayLen - 1;
            QString longestElemType = fmt::typeNameRaw(container.elementKind)
                                    + QStringLiteral("[%1]").arg(maxIdx);
            scopeMaxType = qMax(scopeMaxType, (int)longestElemType.size());
        }

        state.scopeTypeW[container.id] = qBound(kMinTypeW, scopeMaxType, typeCap);
        state.scopeNameW[container.id] = qBound(kMinNameW, scopeMaxName, kMaxNameW);
    }

    // Compute scope widths for root level (parentId == 0)
    // Include struct/array headers - they now use columnar layout too
    {
        int rootMaxType = kMinTypeW;
        int rootMaxName = kMinNameW;
        for (int childIdx : state.childMap.value(0)) {
            const Node& child = tree.nodes[childIdx];
            rootMaxType = qMax(rootMaxType, (int)nodeTypeName(child).size());

            // Name width (skip hex, include containers)
            if (!isHexPreview(child.kind)) {
                rootMaxName = qMax(rootMaxName, (int)child.name.size());
            }
        }
        state.scopeTypeW[0] = qBound(kMinTypeW, rootMaxType, typeCap);
        state.scopeNameW[0] = qBound(kMinNameW, rootMaxName, kMaxNameW);
    }

    // Emit CommandRow as line 0 (combined: source + address + root class type + name)
    const QString cmdRowText = QStringLiteral("[\u25B8] source\u25BE \u00B7 0x0 \u00B7 struct NoName {");
    {
        LineMeta lm;
        lm.nodeIdx   = -1;
        lm.nodeId    = kCommandRowId;
        lm.depth     = 0;
        lm.lineKind  = LineKind::CommandRow;
        lm.foldLevel = SC_FOLDLEVELBASE;
        lm.foldHead  = false;
        lm.offsetText = fmt::fmtOffsetMargin(tree.baseAddress, false, state.offsetHexDigits);
        lm.offsetAddr = tree.baseAddress;
        lm.ptrBase    = state.currentPtrBase;
        lm.markerMask = 0;
        lm.effectiveTypeW = state.typeW;
        lm.effectiveNameW = state.nameW;
        state.emitLine(cmdRowText, lm);
    }

    const QVector<int>& roots = childIndices(state, 0);

    for (int idx : roots) {
        // If viewRootId is set, skip roots that don't match
        if (viewRootId != 0 && tree.nodes[idx].id != viewRootId)
            continue;
        composeNode(state, tree, prov, idx, 0);
    }

    return { state.text, state.meta, LayoutInfo{state.typeW, state.nameW, state.offsetHexDigits, tree.baseAddress} };
}

QSet<uint64_t> NodeTree::normalizePreferAncestors(const QSet<uint64_t>& ids) const {
    QSet<uint64_t> result;
    for (uint64_t id : ids) {
        int idx = indexOfId(id);
        if (idx < 0) continue;
        bool ancestorSelected = false;
        uint64_t cur = nodes[idx].parentId;
        QSet<uint64_t> visited;
        while (cur != 0 && !visited.contains(cur)) {
            visited.insert(cur);
            if (ids.contains(cur)) { ancestorSelected = true; break; }
            int pi = indexOfId(cur);
            if (pi < 0) break;
            cur = nodes[pi].parentId;
        }
        if (!ancestorSelected)
            result.insert(id);
    }
    return result;
}

QSet<uint64_t> NodeTree::normalizePreferDescendants(const QSet<uint64_t>& ids) const {
    QSet<uint64_t> result;
    for (uint64_t id : ids) {
        QVector<int> sub = subtreeIndices(id);
        bool hasSelectedDescendant = false;
        for (int si : sub) {
            uint64_t sid = nodes[si].id;
            if (sid != id && ids.contains(sid)) {
                hasSelectedDescendant = true;
                break;
            }
        }
        if (!hasSelectedDescendant)
            result.insert(id);
    }
    return result;
}


} // namespace rcx

```

`src/controller.cpp`:

```cpp
#include "controller.h"
#include "addressparser.h"
#include "typeselectorpopup.h"
#include "providerregistry.h"
#include "themes/thememanager.h"
#include <Qsci/qsciscintilla.h>
#include <QSplitter>
#include <QFile>
#include <QFileInfo>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QMenu>
#include <QInputDialog>
#include <QClipboard>
#include <QApplication>
#include <QFileDialog>
#include <QMessageBox>
#include <QSettings>
#include <QtConcurrent/QtConcurrentRun>
#include <limits>

namespace rcx {

static thread_local const RcxDocument* s_composeDoc = nullptr;

static QString docTypeNameProvider(NodeKind k) {
    if (s_composeDoc) return s_composeDoc->resolveTypeName(k);
    auto* m = kindMeta(k);
    return m ? QString::fromLatin1(m->typeName) : QStringLiteral("???");
}

static QString elide(QString s, int max) {
    if (max <= 0) return {};
    if (s.size() <= max) return s;
    if (max == 1) return QStringLiteral("\u2026");
    return s.left(max - 1) + QChar(0x2026);
}

static QString elideLeft(const QString& s, int max) {
    if (s.size() <= max) return s;
    if (max <= 1) return QStringLiteral("\u2026").left(max);
    return QStringLiteral("\u2026") + s.right(max - 1);
}

static QString crumbFor(const rcx::NodeTree& t, uint64_t nodeId) {
    QStringList parts;
    QSet<uint64_t> seen;
    uint64_t cur = nodeId;
    while (cur != 0 && !seen.contains(cur)) {
        seen.insert(cur);
        int idx = t.indexOfId(cur);
        if (idx < 0) break;
        const auto& n = t.nodes[idx];
        parts << (n.name.isEmpty() ? QStringLiteral("<unnamed>") : n.name);
        cur = n.parentId;
    }
    std::reverse(parts.begin(), parts.end());
    if (parts.size() > 4)
        parts = QStringList{parts.front(), QStringLiteral("\u2026"), parts[parts.size() - 2], parts.back()};
    return parts.join(QStringLiteral(" \u00B7 "));
}

// ── RcxDocument ──

RcxDocument::RcxDocument(QObject* parent)
    : QObject(parent)
    , provider(std::make_shared<NullProvider>())
{
    connect(&undoStack, &QUndoStack::cleanChanged, this, [this](bool clean) {
        modified = !clean;
    });
}

ComposeResult RcxDocument::compose(uint64_t viewRootId, bool compactColumns) const {
    return rcx::compose(tree, *provider, viewRootId, compactColumns);
}

bool RcxDocument::save(const QString& path) {
    QJsonObject json = tree.toJson();

    // Save type aliases
    if (!typeAliases.isEmpty()) {
        QJsonObject aliasObj;
        for (auto it = typeAliases.begin(); it != typeAliases.end(); ++it)
            aliasObj[kindToString(it.key())] = it.value();
        json["typeAliases"] = aliasObj;
    }

    QJsonDocument jdoc(json);
    QFile file(path);
    if (!file.open(QIODevice::WriteOnly))
        return false;
    file.write(jdoc.toJson(QJsonDocument::Indented));
    filePath = path;
    undoStack.setClean();
    modified = false;
    return true;
}

bool RcxDocument::load(const QString& path) {
    QFile file(path);
    if (!file.open(QIODevice::ReadOnly))
        return false;
    undoStack.clear();
    QJsonDocument jdoc = QJsonDocument::fromJson(file.readAll());
    QJsonObject root = jdoc.object();
    tree = NodeTree::fromJson(root);

    // Load type aliases
    typeAliases.clear();
    QJsonObject aliasObj = root["typeAliases"].toObject();
    for (auto it = aliasObj.begin(); it != aliasObj.end(); ++it) {
        NodeKind k = kindFromString(it.key());
        QString v = it.value().toString();
        if (!v.isEmpty())
            typeAliases[k] = v;
    }

    filePath = path;
    modified = false;
    emit documentChanged();
    return true;
}

void RcxDocument::loadData(const QString& binaryPath) {
    QFile file(binaryPath);
    if (!file.open(QIODevice::ReadOnly))
        return;
    undoStack.clear();
    provider = std::make_shared<BufferProvider>(
        file.readAll(), QFileInfo(binaryPath).fileName());
    dataPath = binaryPath;
    tree.baseAddress = 0;
    emit documentChanged();
}

void RcxDocument::loadData(const QByteArray& data) {
    undoStack.clear();
    provider = std::make_shared<BufferProvider>(data);
    tree.baseAddress = 0;
    emit documentChanged();
}

// ── RcxCommand ──

RcxCommand::RcxCommand(RcxController* ctrl, Command cmd)
    : m_ctrl(ctrl), m_cmd(cmd) {}

void RcxCommand::undo() { m_ctrl->applyCommand(m_cmd, true); }
void RcxCommand::redo() { m_ctrl->applyCommand(m_cmd, false); }

// ── RcxController ──

RcxController::RcxController(RcxDocument* doc, QWidget* parent)
    : QObject(parent), m_doc(doc)
{
    fmt::setTypeNameProvider(docTypeNameProvider);
    connect(m_doc, &RcxDocument::documentChanged, this, &RcxController::refresh);
    setupAutoRefresh();
}

RcxController::~RcxController() {
    if (m_refreshWatcher) {
        m_refreshWatcher->cancel();
        m_refreshWatcher->waitForFinished();
    }
}

RcxEditor* RcxController::primaryEditor() const {
    return m_editors.isEmpty() ? nullptr : m_editors.first();
}

RcxEditor* RcxController::addSplitEditor(QWidget* parent) {
    auto* editor = new RcxEditor(parent);
    m_editors.append(editor);
    connectEditor(editor);

    if (!m_lastResult.text.isEmpty()) {
        editor->applyDocument(m_lastResult);
    }
    updateCommandRow();

    // Eagerly pre-warm the type popup so first click isn't slow (~350ms cold start).
    if (!m_cachedPopup) {
        QTimer::singleShot(0, this, [this, editor]() {
            if (!m_cachedPopup && !m_editors.isEmpty())
                ensurePopup(editor);
        });
    }
    return editor;
}

void RcxController::removeSplitEditor(RcxEditor* editor) {
    m_editors.removeOne(editor);
    // Caller (MainWindow) owns the parent QTabWidget and handles widget destruction.
}

void RcxController::connectEditor(RcxEditor* editor) {
    connect(editor, &RcxEditor::marginClicked,
            this, [this, editor](int margin, int line, Qt::KeyboardModifiers mods) {
        handleMarginClick(editor, margin, line, mods);
    });
    connect(editor, &RcxEditor::contextMenuRequested,
            this, [this, editor](int line, int nodeIdx, int subLine, QPoint globalPos) {
        showContextMenu(editor, line, nodeIdx, subLine, globalPos);
    });
    connect(editor, &RcxEditor::keywordConvertRequested,
            this, &RcxController::convertRootKeyword);
    connect(editor, &RcxEditor::nodeClicked,
            this, [this, editor](int line, uint64_t nodeId, Qt::KeyboardModifiers mods) {
        handleNodeClick(editor, line, nodeId, mods);
    });

    // Type selector popup (command row chevron)
    connect(editor, &RcxEditor::typeSelectorRequested,
            this, [this, editor]() {
        showTypePopup(editor, TypePopupMode::Root, -1, QPoint());
    });

    // Type picker popup (array element type / pointer target)
    connect(editor, &RcxEditor::typePickerRequested,
            this, [this, editor](EditTarget target, int nodeIdx, QPoint globalPos) {
        TypePopupMode mode = TypePopupMode::FieldType;
        if (target == EditTarget::ArrayElementType)
            mode = TypePopupMode::ArrayElement;
        else if (target == EditTarget::PointerTarget) {
            // Primitive pointers (ptrDepth>0) should open FieldType with
            // the base type selected and *//** preselected — not PointerTarget.
            bool isPrimPtr = false;
            if (nodeIdx >= 0 && nodeIdx < m_doc->tree.nodes.size()) {
                const auto& n = m_doc->tree.nodes[nodeIdx];
                isPrimPtr = n.ptrDepth > 0 && n.refId == 0;
            }
            mode = isPrimPtr ? TypePopupMode::FieldType
                             : TypePopupMode::PointerTarget;
        }
        showTypePopup(editor, mode, nodeIdx, globalPos);
    });

    // Inline editing signals
    connect(editor, &RcxEditor::inlineEditCommitted,
            this, [this](int nodeIdx, int subLine, EditTarget target, const QString& text,
                         uint64_t resolvedAddr) {
        // CommandRow BaseAddress/Source/RootClass edit has nodeIdx=-1
        if (nodeIdx < 0 && target != EditTarget::BaseAddress && target != EditTarget::Source
            && target != EditTarget::RootClassType && target != EditTarget::RootClassName) { refresh(); return; }
        switch (target) {
        case EditTarget::Name: {
            if (text.isEmpty()) break;
            if (nodeIdx >= m_doc->tree.nodes.size()) break;
            const Node& node = m_doc->tree.nodes[nodeIdx];
            // ASCII edit on Hex nodes
            if (isHexPreview(node.kind)) {
                setNodeValue(nodeIdx, subLine, text, /*isAscii=*/true, resolvedAddr);
            } else {
                renameNode(nodeIdx, text);
            }
            break;
        }
        case EditTarget::Type: {
            // Check for array type syntax: "type[count]" e.g. "int32_t[10]"
            int bracketPos = text.indexOf('[');
            if (bracketPos > 0 && text.endsWith(']')) {
                QString elemTypeName = text.left(bracketPos).trimmed();
                QString countStr = text.mid(bracketPos + 1, text.size() - bracketPos - 2);
                bool countOk;
                int newCount = countStr.toInt(&countOk);
                if (countOk && newCount > 0) {
                    bool typeOk;
                    NodeKind elemKind = kindFromTypeName(elemTypeName, &typeOk);
                    if (typeOk && nodeIdx < m_doc->tree.nodes.size()) {
                        const uint64_t nodeId = m_doc->tree.nodes[nodeIdx].id;
                        bool wasSuppressed = m_suppressRefresh;
                        m_suppressRefresh = true;
                        m_doc->undoStack.beginMacro(QStringLiteral("Change to array"));
                        if (m_doc->tree.nodes[nodeIdx].kind != NodeKind::Array)
                            changeNodeKind(nodeIdx, NodeKind::Array);
                        int idx = m_doc->tree.indexOfId(nodeId);
                        if (idx >= 0) {
                            auto& n = m_doc->tree.nodes[idx];
                            if (n.elementKind != elemKind || n.arrayLen != newCount)
                                m_doc->undoStack.push(new RcxCommand(this,
                                    cmd::ChangeArrayMeta{nodeId, n.elementKind, elemKind,
                                                         n.arrayLen, newCount}));
                        }
                        m_doc->undoStack.endMacro();
                        m_suppressRefresh = wasSuppressed;
                        if (!m_suppressRefresh) refresh();
                    }
                }
            } else {
                // Regular type change
                bool ok;
                NodeKind k = kindFromTypeName(text, &ok);
                if (ok) {
                    changeNodeKind(nodeIdx, k);
                } else if (nodeIdx < m_doc->tree.nodes.size()) {
                    // Check if it's a defined struct type name
                    bool isStructType = false;
                    for (const auto& n : m_doc->tree.nodes) {
                        if (n.kind == NodeKind::Struct && n.structTypeName == text) {
                            isStructType = true;
                            break;
                        }
                    }
                    if (isStructType) {
                        auto& node = m_doc->tree.nodes[nodeIdx];
                        if (node.kind != NodeKind::Struct)
                            changeNodeKind(nodeIdx, NodeKind::Struct);
                        int idx = m_doc->tree.indexOfId(node.id);
                        if (idx >= 0) {
                            QString oldTypeName = m_doc->tree.nodes[idx].structTypeName;
                            if (oldTypeName != text) {
                                m_doc->undoStack.push(new RcxCommand(this,
                                    cmd::ChangeStructTypeName{node.id, oldTypeName, text}));
                            }
                        }
                    }
                }
            }
            break;
        }
        case EditTarget::Value:
            setNodeValue(nodeIdx, subLine, text, /*isAscii=*/false, resolvedAddr);
            break;
        case EditTarget::BaseAddress: {
            QString s = text.trimmed();
            s.remove('`');          // WinDbg backtick separators (e.g. 7ff6`6cce0000)
            s.remove('\n');
            s.remove('\r');

            AddressParserCallbacks cbs;
            if (m_doc->provider) {
                auto* prov = m_doc->provider.get();
                cbs.resolveModule = [prov](const QString& name, bool* ok) -> uint64_t {
                    uint64_t base = prov->symbolToAddress(name);
                    *ok = (base != 0);
                    return base;
                };
                cbs.readPointer = [prov](uint64_t addr, bool* ok) -> uint64_t {
                    uint64_t val = 0;
                    *ok = prov->read(addr, &val, 8);
                    return val;
                };
            }
            auto result = AddressParser::evaluate(s, 8, &cbs);
            if (result.ok && result.value != m_doc->tree.baseAddress) {
                uint64_t oldBase = m_doc->tree.baseAddress;
                QString oldFormula = m_doc->tree.baseAddressFormula;
                // Store formula if input uses module/deref syntax, otherwise clear
                QString newFormula = (s.contains('<') || s.contains('[')) ? s : QString();
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::ChangeBase{oldBase, result.value, oldFormula, newFormula}));
            }
            break;
        }
        case EditTarget::Source:
            selectSource(text);
            break;
        case EditTarget::ArrayElementType: {
            if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) break;
            const Node& node = m_doc->tree.nodes[nodeIdx];
            if (node.kind != NodeKind::Array) break;
            bool ok;
            NodeKind elemKind = kindFromTypeName(text, &ok);
            if (ok && elemKind != node.elementKind) {
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::ChangeArrayMeta{node.id,
                        node.elementKind, elemKind,
                        node.arrayLen, node.arrayLen}));
            }
            break;
        }
        case EditTarget::ArrayElementCount: {
            if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) break;
            const Node& node = m_doc->tree.nodes[nodeIdx];
            if (node.kind != NodeKind::Array) break;
            bool ok;
            int newLen = text.toInt(&ok);
            if (ok && newLen > 0 && newLen <= 100000 && newLen != node.arrayLen) {
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::ChangeArrayMeta{node.id,
                        node.elementKind, node.elementKind,
                        node.arrayLen, newLen}));
            }
            break;
        }
        case EditTarget::PointerTarget: {
            if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) break;
            Node& node = m_doc->tree.nodes[nodeIdx];
            if (node.kind != NodeKind::Pointer32 && node.kind != NodeKind::Pointer64) break;
            // Find the struct with matching name or structTypeName
            uint64_t newRefId = 0;
            for (const auto& n : m_doc->tree.nodes) {
                if (n.kind == NodeKind::Struct &&
                    (n.structTypeName == text || n.name == text)) {
                    newRefId = n.id;
                    break;
                }
            }
            if (newRefId != node.refId) {
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::ChangePointerRef{node.id, node.refId, newRefId}));
            }
            break;
        }
        case EditTarget::RootClassType: {
            QString kw = text.toLower().trimmed();
            if (kw != QStringLiteral("struct") && kw != QStringLiteral("class") && kw != QStringLiteral("enum")) break;
            uint64_t targetId = m_viewRootId;
            if (targetId == 0) {
                for (const auto& n : m_doc->tree.nodes) {
                    if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                        targetId = n.id;
                        break;
                    }
                }
            }
            if (targetId != 0) {
                int idx = m_doc->tree.indexOfId(targetId);
                if (idx >= 0) {
                    QString oldKw = m_doc->tree.nodes[idx].resolvedClassKeyword();
                    if (oldKw != kw) {
                        m_doc->undoStack.push(new RcxCommand(this,
                            cmd::ChangeClassKeyword{targetId, oldKw, kw}));
                    }
                }
            }
            break;
        }
        case EditTarget::RootClassName: {
            // Rename the viewed root struct's structTypeName
            if (!text.isEmpty()) {
                uint64_t targetId = m_viewRootId;
                if (targetId == 0) {
                    for (const auto& n : m_doc->tree.nodes) {
                        if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                            targetId = n.id;
                            break;
                        }
                    }
                }
                if (targetId != 0) {
                    int idx = m_doc->tree.indexOfId(targetId);
                    if (idx >= 0) {
                        QString oldName = m_doc->tree.nodes[idx].structTypeName;
                        if (oldName != text) {
                            m_doc->undoStack.push(new RcxCommand(this,
                                cmd::ChangeStructTypeName{targetId, oldName, text}));
                        }
                    }
                }
            }
            break;
        }
        case EditTarget::ArrayIndex:
        case EditTarget::ArrayCount:
            // Array navigation removed - these cases are unreachable
            break;
        }
        // Always refresh to restore canonical text (handles parse failures, no-ops, etc.)
        refresh();
    });
    connect(editor, &RcxEditor::inlineEditCancelled,
            this, [this]() { refresh(); });
}

void RcxController::setViewRootId(uint64_t id) {
    if (m_viewRootId == id) return;
    m_viewRootId = id;
    refresh();
}

void RcxController::scrollToNodeId(uint64_t nodeId) {
    if (auto* editor = primaryEditor())
        editor->scrollToNodeId(nodeId);
}

void RcxController::setTrackValues(bool on) {
    m_trackValues = on;
    if (!on) {
        m_valueHistory.clear();
        for (auto& lm : m_lastResult.meta)
            lm.heatLevel = 0;
        refresh();
    }
}

void RcxController::refresh() {
    // Bracket compose with thread-local doc pointer for type name resolution
    s_composeDoc = m_doc;

    // Compose against snapshot provider if active, otherwise real provider
    if (m_snapshotProv)
        m_lastResult = rcx::compose(m_doc->tree, *m_snapshotProv, m_viewRootId, m_compactColumns);
    else
        m_lastResult = m_doc->compose(m_viewRootId, m_compactColumns);

    s_composeDoc = nullptr;

    // Mark lines whose node data changed since last refresh
    if (!m_changedOffsets.isEmpty()) {
        for (auto& lm : m_lastResult.meta) {
            if (lm.nodeIdx < 0 || lm.nodeIdx >= m_doc->tree.nodes.size()) continue;
            int64_t offset = m_doc->tree.computeOffset(lm.nodeIdx);
            const Node& node = m_doc->tree.nodes[lm.nodeIdx];

            if (isHexPreview(node.kind)) {
                // Per-byte tracking for hex preview nodes
                int lineOff = 0;
                int byteCount = lm.lineByteCount;
                for (int b = 0; b < byteCount; b++) {
                    if (m_changedOffsets.contains(offset + lineOff + b)) {
                        lm.changedByteIndices.append(b);
                        lm.dataChanged = true;
                    }
                }
            } else {
                // Use structSpan for containers (byteSize returns 0 for Array-of-Struct)
                int sz = (node.kind == NodeKind::Struct || node.kind == NodeKind::Array)
                    ? m_doc->tree.structSpan(node.id) : node.byteSize();
                for (int64_t b = offset; b < offset + sz; b++) {
                    if (m_changedOffsets.contains(b)) {
                        lm.dataChanged = true;
                        break;
                    }
                }
            }
        }
    }

    // Update value history and compute heat levels
    // Only run when a live provider is attached (not for static file/buffer sources)
    {
        const Provider* prov = nullptr;
        if (m_snapshotProv && m_snapshotProv->isLive())
            prov = m_snapshotProv.get();
        else if (m_doc->provider && m_doc->provider->isValid() && m_doc->provider->isLive())
            prov = m_doc->provider.get();

        if (m_trackValues && prov) {
            for (auto& lm : m_lastResult.meta) {
                if (lm.nodeIdx < 0 || lm.nodeIdx >= m_doc->tree.nodes.size()) continue;
                if (isSyntheticLine(lm) || lm.isContinuation) continue;
                if (lm.lineKind != LineKind::Field) continue;

                const Node& node = m_doc->tree.nodes[lm.nodeIdx];
                // Skip containers — they don't have scalar values
                if (node.kind == NodeKind::Struct || node.kind == NodeKind::Array) continue;
                // Skip FuncPtr nodes — vtable entries don't change; tracking them
                // causes false heatmap and popup fighting with the disasm popup.
                if (isFuncPtr(node.kind)) continue;

                // Use the absolute address from compose (correct for pointer-expanded nodes)
                uint64_t addr = lm.offsetAddr;
                int sz = node.byteSize();
                if (sz <= 0 || !prov->isReadable(addr, sz)) continue;

                QString val = fmt::readValue(node, *prov, addr, lm.subLine);
                if (!val.isEmpty()) {
                    m_valueHistory[lm.nodeId].record(val);
                    lm.heatLevel = m_valueHistory[lm.nodeId].heatLevel();
                }
            }
        }
    }

    // Prune stale selections (nodes removed by undo/redo/delete)
    QSet<uint64_t> valid;
    for (uint64_t id : m_selIds) {
        uint64_t nodeId = id & ~(kFooterIdBit | kArrayElemBit | kArrayElemMask);
        if (m_doc->tree.indexOfId(nodeId) >= 0)
            valid.insert(id);  // Keep original ID (with footer/array bits if present)
    }
    m_selIds = valid;

    // Collect unique struct type names for the type picker
    QStringList customTypes;
    QSet<QString> seen;
    for (const auto& node : m_doc->tree.nodes) {
        if (node.kind == NodeKind::Struct && !node.structTypeName.isEmpty()) {
            if (!seen.contains(node.structTypeName)) {
                seen.insert(node.structTypeName);
                customTypes << node.structTypeName;
            }
        }
    }

    // Resolve providers for disasm popup:
    // - snapProv: snapshot or real — for reading pointer values within the tree
    // - realProv: always the real process provider — for reading code at arbitrary addresses
    const Provider* snapProv = m_snapshotProv
        ? static_cast<const Provider*>(m_snapshotProv.get())
        : (m_doc->provider ? m_doc->provider.get() : nullptr);
    const Provider* realProv = m_doc->provider ? m_doc->provider.get() : nullptr;

    for (auto* editor : m_editors) {
        editor->setCustomTypeNames(customTypes);
        editor->setValueHistoryRef(&m_valueHistory);
        editor->setProviderRef(snapProv, realProv, &m_doc->tree);
        ViewState vs = editor->saveViewState();
        editor->applyDocument(m_lastResult);
        editor->restoreViewState(vs);
    }
    // Text-modifying passes first (command row replaces line 0 text),
    // then overlays last so hover indicators survive the refresh.
    pushSavedSourcesToEditors();
    updateCommandRow();
    applySelectionOverlays();
}

void RcxController::convertRootKeyword(const QString& newKeyword) {
    uint64_t targetId = m_viewRootId;
    if (targetId == 0) {
        for (const auto& n : m_doc->tree.nodes) {
            if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                targetId = n.id;
                break;
            }
        }
    }
    if (targetId == 0) return;
    int idx = m_doc->tree.indexOfId(targetId);
    if (idx < 0) return;
    QString oldKw = m_doc->tree.nodes[idx].resolvedClassKeyword();
    if (oldKw == newKeyword) return;
    // Only allow class↔struct conversion
    if (oldKw == QStringLiteral("enum") || newKeyword == QStringLiteral("enum")) return;
    m_doc->undoStack.push(new RcxCommand(this,
        cmd::ChangeClassKeyword{targetId, oldKw, newKeyword}));
}

void RcxController::changeNodeKind(int nodeIdx, NodeKind newKind) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    auto& node = m_doc->tree.nodes[nodeIdx];

    int oldSize = node.byteSize();
    // Compute what byteSize() would be with the new kind
    Node tmp = node;
    tmp.kind = newKind;
    int newSize = tmp.byteSize();

    if (newSize > 0 && newSize < oldSize) {
        // Shrinking: insert hex padding to fill gap (no offset shift)
        int gap = oldSize - newSize;
        uint64_t parentId = node.parentId;
        int baseOffset = node.offset + newSize;

        bool wasSuppressed = m_suppressRefresh;
        m_suppressRefresh = true;
        m_doc->undoStack.beginMacro(QStringLiteral("Change type"));

        // Push type change with no offset adjustments
        m_doc->undoStack.push(new RcxCommand(this,
            cmd::ChangeKind{node.id, node.kind, newKind, {}}));

        // Insert hex nodes to fill the gap (largest first for alignment)
        int padOffset = baseOffset;
        while (gap > 0) {
            NodeKind padKind;
            int padSize;
            if (gap >= 8)      { padKind = NodeKind::Hex64; padSize = 8; }
            else if (gap >= 4) { padKind = NodeKind::Hex32; padSize = 4; }
            else if (gap >= 2) { padKind = NodeKind::Hex16; padSize = 2; }
            else               { padKind = NodeKind::Hex8;  padSize = 1; }

            insertNode(parentId, padOffset, padKind,
                       QString("pad_%1").arg(padOffset, 2, 16, QChar('0')));
            padOffset += padSize;
            gap -= padSize;
        }

        m_doc->undoStack.endMacro();
        m_suppressRefresh = wasSuppressed;
        if (!m_suppressRefresh) refresh();
    } else {
        // Same size or larger: adjust sibling offsets as before
        int delta = newSize - oldSize;
        QVector<cmd::OffsetAdj> adjs;
        if (delta != 0 && oldSize > 0 && newSize > 0) {
            int oldEnd = node.offset + oldSize;
            auto siblings = m_doc->tree.childrenOf(node.parentId);
            for (int si : siblings) {
                if (si == nodeIdx) continue;
                auto& sib = m_doc->tree.nodes[si];
                if (sib.offset >= oldEnd)
                    adjs.append({sib.id, sib.offset, sib.offset + delta});
            }
        }
        m_doc->undoStack.push(new RcxCommand(this,
            cmd::ChangeKind{node.id, node.kind, newKind, adjs}));
    }
}

void RcxController::renameNode(int nodeIdx, const QString& newName) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    auto& node = m_doc->tree.nodes[nodeIdx];
    m_doc->undoStack.push(new RcxCommand(this,
        cmd::Rename{node.id, node.name, newName}));
}

void RcxController::insertNode(uint64_t parentId, int offset, NodeKind kind, const QString& name) {
    Node n;
    n.kind     = kind;
    n.name     = name;
    n.parentId = parentId;

    if (offset < 0) {
        // Auto-place after last sibling with alignment
        int maxEnd = 0;
        auto siblings = m_doc->tree.childrenOf(parentId);
        for (int si : siblings) {
            auto& sn = m_doc->tree.nodes[si];
            int sz  = (sn.kind == NodeKind::Struct || sn.kind == NodeKind::Array)
                ? m_doc->tree.structSpan(sn.id) : sn.byteSize();
            int end = sn.offset + sz;
            if (end > maxEnd) maxEnd = end;
        }
        int align = alignmentFor(kind);
        n.offset = (maxEnd + align - 1) / align * align;
    } else {
        n.offset = offset;
    }

    // Reserve unique ID atomically before pushing command
    n.id = m_doc->tree.reserveId();

    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{n}));
}

void RcxController::removeNode(int nodeIdx) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    const Node& node = m_doc->tree.nodes[nodeIdx];
    uint64_t nodeId = node.id;
    uint64_t parentId = node.parentId;

    // Compute size of deleted node/subtree
    int deletedSize = (node.kind == NodeKind::Struct || node.kind == NodeKind::Array)
        ? m_doc->tree.structSpan(node.id) : node.byteSize();
    int deletedEnd = node.offset + deletedSize;

    // Find siblings after this node and compute offset adjustments
    QVector<cmd::OffsetAdj> adjs;
    if (parentId != 0) {  // only adjust if not root-level
        auto siblings = m_doc->tree.childrenOf(parentId);
        for (int si : siblings) {
            if (si == nodeIdx) continue;
            auto& sib = m_doc->tree.nodes[si];
            if (sib.offset >= deletedEnd) {
                adjs.append({sib.id, sib.offset, sib.offset - deletedSize});
            }
        }
    }

    // Collect subtree
    QVector<int> indices = m_doc->tree.subtreeIndices(nodeId);
    QVector<Node> subtree;
    for (int i : indices)
        subtree.append(m_doc->tree.nodes[i]);

    m_doc->undoStack.push(new RcxCommand(this,
        cmd::Remove{nodeId, subtree, adjs}));
}

void RcxController::deleteRootStruct(uint64_t structId) {
    int ni = m_doc->tree.indexOfId(structId);
    if (ni < 0) return;
    const Node& node = m_doc->tree.nodes[ni];
    if (node.parentId != 0 || node.kind != NodeKind::Struct) return;

    bool wasSuppressed = m_suppressRefresh;
    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Delete root struct"));

    // Clear all refId references pointing to this struct
    for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
        auto& n = m_doc->tree.nodes[i];
        if (n.refId == structId) {
            m_doc->undoStack.push(new RcxCommand(this,
                cmd::ChangePointerRef{n.id, n.refId, (uint64_t)0}));
        }
    }

    // Remove the struct + subtree (re-lookup since commands may shift indices)
    ni = m_doc->tree.indexOfId(structId);
    if (ni >= 0)
        removeNode(ni);

    m_doc->undoStack.endMacro();
    m_suppressRefresh = wasSuppressed;

    // Switch view if we just deleted the viewed root
    if (m_viewRootId == structId) {
        uint64_t nextRoot = 0;
        for (const auto& n : m_doc->tree.nodes) {
            if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                nextRoot = n.id;
                break;
            }
        }
        setViewRootId(nextRoot);
    }

    if (!m_suppressRefresh) refresh();
}

void RcxController::groupIntoUnion(const QSet<uint64_t>& nodeIds) {
    if (nodeIds.size() < 2) return;

    // Collect nodes and verify they share the same parent
    QVector<int> indices;
    uint64_t parentId = 0;
    bool first = true;
    for (uint64_t id : nodeIds) {
        int idx = m_doc->tree.indexOfId(id);
        if (idx < 0) return;
        if (first) { parentId = m_doc->tree.nodes[idx].parentId; first = false; }
        else if (m_doc->tree.nodes[idx].parentId != parentId) return;
        indices.append(idx);
    }

    // Sort by offset to find the union's insertion point
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return m_doc->tree.nodes[a].offset < m_doc->tree.nodes[b].offset;
    });
    int unionOffset = m_doc->tree.nodes[indices.first()].offset;

    bool wasSuppressed = m_suppressRefresh;
    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Group into union"));

    // Save copies of nodes before removal (subtrees included)
    struct SavedNode { Node node; QVector<Node> subtree; };
    QVector<SavedNode> saved;
    for (int idx : indices) {
        SavedNode sn;
        sn.node = m_doc->tree.nodes[idx];
        auto sub = m_doc->tree.subtreeIndices(sn.node.id);
        for (int si : sub)
            if (si != idx) sn.subtree.append(m_doc->tree.nodes[si]);
        saved.append(sn);
    }

    // Remove selected nodes (in reverse order to keep indices valid)
    for (int i = indices.size() - 1; i >= 0; i--) {
        int idx = m_doc->tree.indexOfId(saved[i].node.id);
        if (idx >= 0) {
            QVector<Node> subtree;
            for (int si : m_doc->tree.subtreeIndices(saved[i].node.id))
                subtree.append(m_doc->tree.nodes[si]);
            m_doc->undoStack.push(new RcxCommand(this,
                cmd::Remove{saved[i].node.id, subtree, {}}));
        }
    }

    // Insert union node
    Node unionNode;
    unionNode.kind = NodeKind::Struct;
    unionNode.classKeyword = QStringLiteral("union");
    unionNode.parentId = parentId;
    unionNode.offset = unionOffset;
    unionNode.id = m_doc->tree.reserveId();
    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{unionNode}));
    uint64_t unionId = unionNode.id;

    // Re-insert nodes as children of the union, all at offset 0
    for (const auto& sn : saved) {
        Node copy = sn.node;
        copy.parentId = unionId;
        copy.offset = 0;
        copy.id = m_doc->tree.reserveId();
        m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{copy}));

        // Re-insert subtree with updated parentId for direct children
        uint64_t oldId = sn.node.id;
        uint64_t newId = copy.id;
        for (const auto& child : sn.subtree) {
            Node cc = child;
            if (cc.parentId == oldId) cc.parentId = newId;
            cc.id = m_doc->tree.reserveId();
            m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{cc}));
        }
    }

    m_doc->undoStack.endMacro();
    m_suppressRefresh = wasSuppressed;
    if (!m_suppressRefresh) refresh();
}

void RcxController::dissolveUnion(uint64_t unionId) {
    int ui = m_doc->tree.indexOfId(unionId);
    if (ui < 0) return;
    const Node& unionNode = m_doc->tree.nodes[ui];
    if (unionNode.kind != NodeKind::Struct
        || unionNode.resolvedClassKeyword() != QStringLiteral("union")) return;

    uint64_t parentId = unionNode.parentId;
    int unionOffset = unionNode.offset;

    // Collect union children
    auto children = m_doc->tree.childrenOf(unionId);
    struct SavedNode { Node node; QVector<Node> subtree; };
    QVector<SavedNode> saved;
    for (int ci : children) {
        SavedNode sn;
        sn.node = m_doc->tree.nodes[ci];
        auto sub = m_doc->tree.subtreeIndices(sn.node.id);
        for (int si : sub)
            if (si != ci) sn.subtree.append(m_doc->tree.nodes[si]);
        saved.append(sn);
    }

    bool wasSuppressed = m_suppressRefresh;
    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Dissolve union"));

    // Remove the union (and all its children)
    {
        QVector<Node> subtree;
        for (int si : m_doc->tree.subtreeIndices(unionId))
            subtree.append(m_doc->tree.nodes[si]);
        m_doc->undoStack.push(new RcxCommand(this,
            cmd::Remove{unionId, subtree, {}}));
    }

    // Re-insert children under the union's parent, at the union's offset
    for (const auto& sn : saved) {
        Node copy = sn.node;
        copy.parentId = parentId;
        copy.offset = unionOffset + sn.node.offset;
        copy.id = m_doc->tree.reserveId();
        m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{copy}));

        uint64_t oldId = sn.node.id;
        uint64_t newId = copy.id;
        for (const auto& child : sn.subtree) {
            Node cc = child;
            if (cc.parentId == oldId) cc.parentId = newId;
            cc.id = m_doc->tree.reserveId();
            m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{cc}));
        }
    }

    m_doc->undoStack.endMacro();
    m_suppressRefresh = wasSuppressed;
    if (!m_suppressRefresh) refresh();
}

void RcxController::toggleCollapse(int nodeIdx) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    auto& node = m_doc->tree.nodes[nodeIdx];
    m_doc->undoStack.push(new RcxCommand(this,
        cmd::Collapse{node.id, node.collapsed, !node.collapsed}));
}

void RcxController::materializeRefChildren(int nodeIdx) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    auto& tree = m_doc->tree;

    // Snapshot values before any mutation invalidates references
    const uint64_t parentId   = tree.nodes[nodeIdx].id;
    const uint64_t refId      = tree.nodes[nodeIdx].refId;
    const NodeKind parentKind = tree.nodes[nodeIdx].kind;
    const QString  parentName = tree.nodes[nodeIdx].name;

    if (refId == 0) return;
    if (!tree.childrenOf(parentId).isEmpty()) return;  // already materialized

    // Collect children to clone (copy by value to avoid reference invalidation)
    QVector<int> refChildren = tree.childrenOf(refId);
    if (refChildren.isEmpty()) return;

    QVector<Node> clones;
    clones.reserve(refChildren.size());
    for (int ci : refChildren) {
        Node copy = tree.nodes[ci];  // copy by value before any mutation
        copy.id = tree.reserveId();
        copy.parentId = parentId;
        copy.collapsed = true;
        clones.append(copy);
    }

    // Wrap all mutations in an undo macro
    bool wasSuppressed = m_suppressRefresh;
    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Materialize ref children"));

    for (const Node& clone : clones) {
        m_doc->undoStack.push(new RcxCommand(this,
            cmd::Insert{clone, {}}));
    }

    // Auto-expand the self-referential child (the one that was the cycle)
    // so the user gets expand in a single click
    for (const Node& clone : clones) {
        if (clone.kind == parentKind && clone.name == parentName && clone.refId == refId) {
            m_doc->undoStack.push(new RcxCommand(this,
                cmd::Collapse{clone.id, true, false}));
            break;
        }
    }

    m_doc->undoStack.endMacro();
    m_suppressRefresh = wasSuppressed;
    if (!m_suppressRefresh) refresh();
}

void RcxController::applyCommand(const Command& command, bool isUndo) {
    auto& tree = m_doc->tree;

    // Clear value history for nodes whose effective offset changed.
    // When offsets shift (insert/delete/resize), old recorded values came from
    // a different memory address, so keeping them would show false heat.
    // Also invalidates any in-flight async read so that stale snapshot data
    // from before the offset change doesn't re-introduce false heat.
    auto clearHistoryForAdjs = [&](const QVector<cmd::OffsetAdj>& adjs) {
        if (adjs.isEmpty()) return;
        m_refreshGen++;  // discard in-flight async read (stale layout)
        for (const auto& adj : adjs) {
            // Clear the adjusted node itself
            m_valueHistory.remove(adj.nodeId);
            // Clear all descendants (their effective address also shifted)
            for (int ci : tree.subtreeIndices(adj.nodeId))
                m_valueHistory.remove(tree.nodes[ci].id);
        }
    };

    std::visit([&](auto&& c) {
        using T = std::decay_t<decltype(c)>;
        if constexpr (std::is_same_v<T, cmd::ChangeKind>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0)
                tree.nodes[idx].kind = isUndo ? c.oldKind : c.newKind;
            for (const auto& adj : c.offAdjs) {
                int ai = tree.indexOfId(adj.nodeId);
                if (ai >= 0)
                    tree.nodes[ai].offset = isUndo ? adj.oldOffset : adj.newOffset;
            }
            // The changed node's value format changed; clear its history.
            // If offAdjs is empty (same-size change), still bump gen to
            // discard in-flight reads that would record the old format.
            if (c.offAdjs.isEmpty()) m_refreshGen++;
            m_valueHistory.remove(c.nodeId);
            clearHistoryForAdjs(c.offAdjs);
        } else if constexpr (std::is_same_v<T, cmd::Rename>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0)
                tree.nodes[idx].name = isUndo ? c.oldName : c.newName;
        } else if constexpr (std::is_same_v<T, cmd::Collapse>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0)
                tree.nodes[idx].collapsed = isUndo ? c.oldState : c.newState;
        } else if constexpr (std::is_same_v<T, cmd::Insert>) {
            if (isUndo) {
                // Revert offset adjustments
                for (const auto& adj : c.offAdjs) {
                    int ai = tree.indexOfId(adj.nodeId);
                    if (ai >= 0) tree.nodes[ai].offset = adj.oldOffset;
                }
                int idx = tree.indexOfId(c.node.id);
                if (idx >= 0) {
                    tree.nodes.remove(idx);
                    tree.invalidateIdCache();
                }
            } else {
                tree.addNode(c.node);
                // Apply offset adjustments
                for (const auto& adj : c.offAdjs) {
                    int ai = tree.indexOfId(adj.nodeId);
                    if (ai >= 0) tree.nodes[ai].offset = adj.newOffset;
                }
            }
            clearHistoryForAdjs(c.offAdjs);
        } else if constexpr (std::is_same_v<T, cmd::Remove>) {
            if (isUndo) {
                // Restore nodes first
                for (const Node& n : c.subtree)
                    tree.addNode(n);
                // Revert offset adjustments
                for (const auto& adj : c.offAdjs) {
                    int ai = tree.indexOfId(adj.nodeId);
                    if (ai >= 0) tree.nodes[ai].offset = adj.oldOffset;
                }
            } else {
                // Apply offset adjustments first (before removing changes indices)
                for (const auto& adj : c.offAdjs) {
                    int ai = tree.indexOfId(adj.nodeId);
                    if (ai >= 0) tree.nodes[ai].offset = adj.newOffset;
                }
                // Remove nodes and their value history
                QVector<int> indices = tree.subtreeIndices(c.nodeId);
                std::sort(indices.begin(), indices.end(), std::greater<int>());
                for (int idx : indices) {
                    m_valueHistory.remove(tree.nodes[idx].id);
                    tree.nodes.remove(idx);
                }
                tree.invalidateIdCache();
            }
            // Siblings shifted — their old values are from wrong addresses
            clearHistoryForAdjs(c.offAdjs);
        } else if constexpr (std::is_same_v<T, cmd::ChangeBase>) {
            tree.baseAddress = isUndo ? c.oldBase : c.newBase;
            tree.baseAddressFormula = isUndo ? c.oldFormula : c.newFormula;
            resetSnapshot();
        } else if constexpr (std::is_same_v<T, cmd::WriteBytes>) {
            const QByteArray& bytes = isUndo ? c.oldBytes : c.newBytes;
            // Write through snapshot (patches pages only on success) or provider directly.
            // If write fails, the snapshot is NOT patched, so the next compose shows the
            // real unchanged value — no optimistic visual leak.
            bool ok = m_snapshotProv
                ? m_snapshotProv->write(c.addr, bytes.constData(), bytes.size())
                : m_doc->provider->writeBytes(c.addr, bytes);
            if (!ok)
                qWarning() << "WriteBytes failed at address" << QString::number(c.addr, 16);
        } else if constexpr (std::is_same_v<T, cmd::ChangeArrayMeta>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0) {
                tree.nodes[idx].elementKind = isUndo ? c.oldElementKind : c.newElementKind;
                tree.nodes[idx].arrayLen = isUndo ? c.oldArrayLen : c.newArrayLen;
                if (tree.nodes[idx].viewIndex >= tree.nodes[idx].arrayLen)
                    tree.nodes[idx].viewIndex = qMax(0, tree.nodes[idx].arrayLen - 1);
            }
        } else if constexpr (std::is_same_v<T, cmd::ChangePointerRef>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0) {
                tree.nodes[idx].refId = isUndo ? c.oldRefId : c.newRefId;
                if (tree.nodes[idx].refId != 0)
                    tree.nodes[idx].collapsed = true;
            }
        } else if constexpr (std::is_same_v<T, cmd::ChangeStructTypeName>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0)
                tree.nodes[idx].structTypeName = isUndo ? c.oldName : c.newName;
        } else if constexpr (std::is_same_v<T, cmd::ChangeClassKeyword>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0)
                tree.nodes[idx].classKeyword = isUndo ? c.oldKeyword : c.newKeyword;
        } else if constexpr (std::is_same_v<T, cmd::ChangeOffset>) {
            int idx = tree.indexOfId(c.nodeId);
            if (idx >= 0)
                tree.nodes[idx].offset = isUndo ? c.oldOffset : c.newOffset;
            // Node and its descendants read from a different address now
            m_refreshGen++;  // discard in-flight async read (stale layout)
            m_valueHistory.remove(c.nodeId);
            for (int ci : tree.subtreeIndices(c.nodeId))
                m_valueHistory.remove(tree.nodes[ci].id);
        }
    }, command);

    if (!m_suppressRefresh)
        refresh();
}

void RcxController::setNodeValue(int nodeIdx, int subLine, const QString& text,
                                  bool isAscii, uint64_t resolvedAddr) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    if (!m_doc->provider->isWritable()) return;

    const Node& node = m_doc->tree.nodes[nodeIdx];

    // Use the compose-resolved address when available (correct for pointer children).
    // Fall back to tree.baseAddress + computeOffset for callers that don't supply it.
    uint64_t addr;
    if (resolvedAddr != 0) {
        addr = resolvedAddr;
    } else {
        int64_t signedAddr = m_doc->tree.computeOffset(nodeIdx);
        if (signedAddr < 0) return;  // malformed tree: negative offset
        addr = m_doc->tree.baseAddress + static_cast<uint64_t>(signedAddr);
    }

    // For vector components, redirect to float parsing at sub-offset
    NodeKind editKind = node.kind;
    if ((node.kind == NodeKind::Vec2 || node.kind == NodeKind::Vec3 ||
         node.kind == NodeKind::Vec4) && subLine >= 0) {
        addr += subLine * 4;
        editKind = NodeKind::Float;
    }
    // For Mat4x4 components: subLine encodes flat index (row*4 + col), 0-15
    if (node.kind == NodeKind::Mat4x4 && subLine >= 0 && subLine < 16) {
        addr += subLine * 4;
        editKind = NodeKind::Float;
    }

    bool ok;
    QByteArray newBytes;
    if (isAscii) {
        int expectedSize = sizeForKind(editKind);
        newBytes = fmt::parseAsciiValue(text, expectedSize, &ok);
    } else {
        newBytes = fmt::parseValue(editKind, text, &ok);
    }
    if (!ok) return;

    // For strings, pad/truncate to full buffer size
    if (node.kind == NodeKind::UTF8 || node.kind == NodeKind::UTF16) {
        int fullSize = node.byteSize();
        newBytes = newBytes.left(fullSize);
        if (newBytes.size() < fullSize)
            newBytes.append(QByteArray(fullSize - newBytes.size(), '\0'));
    }

    if (newBytes.isEmpty()) return;

    int writeSize = newBytes.size();

    // Validate write range before pushing command
    if (!m_doc->provider->isReadable(addr, writeSize)) return;

    // Read old bytes before writing (for undo)
    QByteArray oldBytes = m_doc->provider->readBytes(addr, writeSize);

    // Test the write first — don't push a command that will silently fail.
    // This prevents optimistic visual updates for read-only providers.
    bool writeOk = m_snapshotProv
        ? m_snapshotProv->write(addr, newBytes.constData(), newBytes.size())
        : m_doc->provider->writeBytes(addr, newBytes);
    if (!writeOk) {
        qWarning() << "Write failed at address" << QString::number(addr, 16);
        refresh();  // refresh to show the real unchanged value
        return;
    }

    // Write succeeded — push undo command (redo will write again, which is harmless)
    m_doc->undoStack.push(new RcxCommand(this,
        cmd::WriteBytes{addr, oldBytes, newBytes}));
}

void RcxController::duplicateNode(int nodeIdx) {
    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;
    const Node& src = m_doc->tree.nodes[nodeIdx];
    if (src.kind == NodeKind::Struct || src.kind == NodeKind::Array) return;

    int copySize   = src.byteSize();
    int copyOffset = src.offset + copySize;

    // Shift later siblings down to make room for the copy
    QVector<cmd::OffsetAdj> adjs;
    if (src.parentId != 0) {
        auto siblings = m_doc->tree.childrenOf(src.parentId);
        for (int si : siblings) {
            if (si == nodeIdx) continue;
            auto& sib = m_doc->tree.nodes[si];
            if (sib.offset >= copyOffset)
                adjs.append({sib.id, sib.offset, sib.offset + copySize});
        }
    }

    Node n;
    n.kind     = src.kind;
    n.name     = src.name + "_copy";
    n.parentId = src.parentId;
    n.offset   = copyOffset;
    n.id       = m_doc->tree.reserveId();

    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{n, adjs}));
}

void RcxController::convertToTypedPointer(uint64_t nodeId) {
    int ni = m_doc->tree.indexOfId(nodeId);
    if (ni < 0) return;
    const Node& node = m_doc->tree.nodes[ni];

    // Determine pointer kind from current node size
    NodeKind ptrKind;
    if (node.byteSize() >= 8 || node.kind == NodeKind::Pointer64)
        ptrKind = NodeKind::Pointer64;
    else
        ptrKind = NodeKind::Pointer32;

    // Generate unique struct name: "NewClass", "NewClass_2", "NewClass_3", ...
    QString baseName = QStringLiteral("NewClass");
    QString typeName = baseName;
    int suffix = 2;
    while (true) {
        bool exists = false;
        for (const auto& n : m_doc->tree.nodes) {
            if (n.kind == NodeKind::Struct && n.structTypeName == typeName) {
                exists = true; break;
            }
        }
        if (!exists) break;
        typeName = QStringLiteral("%1_%2").arg(baseName).arg(suffix++);
    }

    // Create the new root struct node
    Node rootStruct;
    rootStruct.kind = NodeKind::Struct;
    rootStruct.name = QStringLiteral("instance");
    rootStruct.structTypeName = typeName;
    rootStruct.classKeyword = QStringLiteral("class");
    rootStruct.parentId = 0;
    rootStruct.offset = 0;
    rootStruct.id = m_doc->tree.reserveId();

    // Create child Hex64 fields for the new struct
    constexpr int kDefaultFields = 16;
    QVector<Node> children;
    for (int i = 0; i < kDefaultFields; i++) {
        Node c;
        c.kind = NodeKind::Hex64;
        c.name = QStringLiteral("field_%1").arg(i * 8, 2, 16, QChar('0'));
        c.parentId = rootStruct.id;
        c.offset = i * 8;
        c.id = m_doc->tree.reserveId();
        children.append(c);
    }

    uint64_t oldRefId = node.refId;

    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Change to ptr*"));

    // 1. Change kind to Pointer64/32 (if not already)
    if (node.kind != ptrKind)
        changeNodeKind(ni, ptrKind);

    // 2. Insert the new root struct
    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{rootStruct, {}}));

    // 3. Insert its children
    for (const Node& c : children)
        m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{c, {}}));

    // 4. Set refId to point to the new struct
    m_doc->undoStack.push(new RcxCommand(this,
        cmd::ChangePointerRef{nodeId, oldRefId, rootStruct.id}));

    m_doc->undoStack.endMacro();
    m_suppressRefresh = false;
    refresh();
}

void RcxController::splitHexNode(uint64_t nodeId) {
    int ni = m_doc->tree.indexOfId(nodeId);
    if (ni < 0) return;
    const Node& node = m_doc->tree.nodes[ni];

    NodeKind halfKind;
    int halfSize;
    if (node.kind == NodeKind::Hex64)      { halfKind = NodeKind::Hex32; halfSize = 4; }
    else if (node.kind == NodeKind::Hex32)  { halfKind = NodeKind::Hex16; halfSize = 2; }
    else if (node.kind == NodeKind::Hex16)  { halfKind = NodeKind::Hex8;  halfSize = 1; }
    else return;

    uint64_t parentId = node.parentId;
    int baseOffset = node.offset;
    QString baseName = node.name;

    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Split Hex node"));

    // Remove the original node
    QVector<Node> subtree;
    subtree.append(node);
    m_doc->undoStack.push(new RcxCommand(this,
        cmd::Remove{nodeId, subtree, {}}));

    // Insert two half-sized nodes
    Node lo;
    lo.kind = halfKind;
    lo.name = baseName;
    lo.parentId = parentId;
    lo.offset = baseOffset;
    lo.id = m_doc->tree.reserveId();
    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{lo, {}}));

    Node hi;
    hi.kind = halfKind;
    hi.name = baseName + QStringLiteral("_hi");
    hi.parentId = parentId;
    hi.offset = baseOffset + halfSize;
    hi.id = m_doc->tree.reserveId();
    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{hi, {}}));

    m_doc->undoStack.endMacro();
    m_suppressRefresh = false;
    refresh();
}

void RcxController::showContextMenu(RcxEditor* editor, int line, int nodeIdx,
                                     int subLine, const QPoint& globalPos) {
    auto icon = [](const char* name) { return QIcon(QStringLiteral(":/vsicons/%1").arg(name)); };

    const bool hasNode = nodeIdx >= 0 && nodeIdx < m_doc->tree.nodes.size();

    // Selection policy
    if (hasNode) {
        uint64_t clickedId = m_doc->tree.nodes[nodeIdx].id;
        if (!m_selIds.contains(clickedId)) {
            m_selIds.clear();
            m_selIds.insert(clickedId);
            m_anchorLine = line;
            applySelectionOverlays();
        }
    }

    // Multi-select batch actions
    if (hasNode && m_selIds.size() > 1) {
        QMenu menu;
        int count = m_selIds.size();
        QSet<uint64_t> ids = m_selIds;

        // Helper: collect indices from selected ids
        auto collectIndices = [this, &ids]() {
            QVector<int> indices;
            for (uint64_t id : ids) {
                int idx = m_doc->tree.indexOfId(id);
                if (idx >= 0) indices.append(idx);
            }
            return indices;
        };

        // Quick-convert shortcuts when all selected nodes share the same kind
        NodeKind commonKind = NodeKind::Hex64;
        bool allSame = true;
        {
            bool first = true;
            for (uint64_t id : ids) {
                int idx = m_doc->tree.indexOfId(id);
                if (idx < 0) continue;
                if (first) { commonKind = m_doc->tree.nodes[idx].kind; first = false; }
                else if (m_doc->tree.nodes[idx].kind != commonKind) { allSame = false; break; }
            }
        }
        bool addedQuickConvert = false;
        if (allSame) {
            if (commonKind == NodeKind::Hex64) {
                menu.addAction("Change to uint64_t", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::UInt64); });
                menu.addAction("Change to uint32_t", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::UInt32); });
                addedQuickConvert = true;
            } else if (commonKind == NodeKind::Hex32) {
                menu.addAction("Change to uint32_t", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::UInt32); });
                addedQuickConvert = true;
            } else if (commonKind == NodeKind::Hex16) {
                menu.addAction("Change to int16_t", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::Int16); });
                addedQuickConvert = true;
            }
            if (commonKind == NodeKind::Hex64 || commonKind == NodeKind::Pointer64) {
                menu.addAction("Change to fnptr64", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::FuncPtr64); });
                addedQuickConvert = true;
            }
            if (commonKind == NodeKind::Hex32 || commonKind == NodeKind::Pointer32) {
                menu.addAction("Change to fnptr32", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::FuncPtr32); });
                addedQuickConvert = true;
            }
            if (commonKind == NodeKind::FuncPtr64) {
                menu.addAction("Change to ptr64", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::Pointer64); });
                addedQuickConvert = true;
            }
            if (commonKind == NodeKind::FuncPtr32) {
                menu.addAction("Change to ptr32", [this, collectIndices]() {
                    batchChangeKind(collectIndices(), NodeKind::Pointer32); });
                addedQuickConvert = true;
            }
        }
        if (addedQuickConvert)
            menu.addSeparator();

        menu.addAction(icon("symbol-structure.svg"), QString("Change type of %1 nodes...").arg(count),
                       [this, ids, collectIndices]() {
            QStringList types;
            for (const auto& e : kKindMeta) types << e.name;
            bool ok;
            QString sel = QInputDialog::getItem(nullptr, "Change Type", "Type:",
                                                types, 0, false, &ok);
            if (ok)
                batchChangeKind(collectIndices(), kindFromString(sel));
        });

        menu.addSeparator();
        {
            auto* act = menu.addAction("Track Value Changes");
            act->setCheckable(true);
            act->setChecked(m_trackValues);
            connect(act, &QAction::toggled, this, &RcxController::setTrackValues);
        }
        menu.addSeparator();

        // Check if all selected nodes share the same parent (required for grouping)
        {
            bool sameParent = true;
            uint64_t firstParent = 0;
            bool fp = true;
            for (uint64_t id : ids) {
                int idx = m_doc->tree.indexOfId(id);
                if (idx < 0) { sameParent = false; break; }
                if (fp) { firstParent = m_doc->tree.nodes[idx].parentId; fp = false; }
                else if (m_doc->tree.nodes[idx].parentId != firstParent) { sameParent = false; break; }
            }
            if (sameParent)
                menu.addAction("Group into Union", [this, ids]() { groupIntoUnion(ids); });
        }

        menu.addAction(icon("files.svg"), QString("Duplicate %1 nodes").arg(count), [this, ids]() {
            for (uint64_t id : ids) {
                int idx = m_doc->tree.indexOfId(id);
                if (idx >= 0) duplicateNode(idx);
            }
        });
        menu.addAction(icon("trash.svg"), QString("Delete %1 nodes").arg(count), [this, collectIndices]() {
            batchRemoveNodes(collectIndices());
        });

        menu.addSeparator();

        menu.addAction(icon("link.svg"), "Copy &Address", [this, ids]() {
            QStringList addrs;
            for (uint64_t id : ids) {
                int ni = m_doc->tree.indexOfId(id);
                if (ni < 0) continue;
                uint64_t addr = m_doc->tree.baseAddress + m_doc->tree.computeOffset(ni);
                addrs << QStringLiteral("0x") + QString::number(addr, 16).toUpper();
            }
            QApplication::clipboard()->setText(addrs.join('\n'));
        });

        menu.exec(globalPos);
        return;
    }

    QMenu menu;

    // ── Node-specific actions (only when clicking on a node) ──
    if (hasNode) {
        const Node& node = m_doc->tree.nodes[nodeIdx];
        uint64_t nodeId = node.id;
        uint64_t parentId = node.parentId;

        // Quick-convert suggestions for Hex nodes
        bool addedQuickConvert = false;
        if (node.kind == NodeKind::Hex64) {
            menu.addAction("Change to uint64_t", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::UInt64);
            });
            menu.addAction("Change to uint32_t", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::UInt32);
            });
            addedQuickConvert = true;
        } else if (node.kind == NodeKind::Hex32) {
            menu.addAction("Change to uint32_t", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::UInt32);
            });
            addedQuickConvert = true;
        } else if (node.kind == NodeKind::Hex16) {
            menu.addAction("Change to int16_t", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::Int16);
            });
            addedQuickConvert = true;
        }
        if (node.kind == NodeKind::Hex64 || node.kind == NodeKind::Pointer64) {
            menu.addAction("Change to fnptr64", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::FuncPtr64);
            });
            addedQuickConvert = true;
        }
        if (node.kind == NodeKind::Hex32 || node.kind == NodeKind::Pointer32) {
            menu.addAction("Change to fnptr32", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::FuncPtr32);
            });
            addedQuickConvert = true;
        }
        if (node.kind == NodeKind::FuncPtr64) {
            menu.addAction("Change to ptr64", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::Pointer64);
            });
            addedQuickConvert = true;
        }
        if (node.kind == NodeKind::FuncPtr32) {
            menu.addAction("Change to ptr32", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni >= 0) changeNodeKind(ni, NodeKind::Pointer32);
            });
            addedQuickConvert = true;
        }
        // "Change to ptr*" — convert hex/void-ptr to typed pointer with auto-created class
        if (node.kind == NodeKind::Hex64 || node.kind == NodeKind::Hex32
            || ((node.kind == NodeKind::Pointer64 || node.kind == NodeKind::Pointer32)
                && node.refId == 0)) {
            menu.addAction("Change to ptr*", [this, nodeId]() {
                convertToTypedPointer(nodeId);
            });
            addedQuickConvert = true;
        }
        // Split hex node into two half-sized hex nodes
        if (node.kind == NodeKind::Hex64) {
            menu.addAction("Change to hex32+hex32", [this, nodeId]() {
                splitHexNode(nodeId);
            });
            addedQuickConvert = true;
        } else if (node.kind == NodeKind::Hex32) {
            menu.addAction("Change to hex16+hex16", [this, nodeId]() {
                splitHexNode(nodeId);
            });
            addedQuickConvert = true;
        } else if (node.kind == NodeKind::Hex16) {
            menu.addAction("Change to hex8+hex8", [this, nodeId]() {
                splitHexNode(nodeId);
            });
            addedQuickConvert = true;
        }
        if (addedQuickConvert)
            menu.addSeparator();

        bool isEditable = node.kind != NodeKind::Struct && node.kind != NodeKind::Array
                          && !isHexNode(node.kind)
                          && m_doc->provider->isWritable();
        if (isEditable) {
            menu.addAction(icon("edit.svg"), "Edit &Value\tEnter", [editor, line]() {
                editor->beginInlineEdit(EditTarget::Value, line);
            });
        }

        menu.addAction(icon("rename.svg"), "Re&name\tF2", [editor, line]() {
            editor->beginInlineEdit(EditTarget::Name, line);
        });

        menu.addAction("Change &Type\tT", [editor, line]() {
            editor->beginInlineEdit(EditTarget::Type, line);
        });

        menu.addSeparator();
        {
            auto* act = menu.addAction("Track Value Changes");
            act->setCheckable(true);
            act->setChecked(m_trackValues);
            connect(act, &QAction::toggled, this, &RcxController::setTrackValues);
        }
        menu.addSeparator();

        // Convert to Hex nodes (decompose non-hex types into Hex64/32/16/8)
        if (!isHexNode(node.kind) && node.kind != NodeKind::Struct && node.kind != NodeKind::Array) {
            menu.addAction("Convert to &Hex", [this, nodeId]() {
                int ni = m_doc->tree.indexOfId(nodeId);
                if (ni < 0) return;
                const Node& n = m_doc->tree.nodes[ni];
                int totalSize = n.byteSize();
                if (totalSize <= 0) return;

                uint64_t parentId = n.parentId;
                int baseOffset = n.offset;

                bool wasSuppressed = m_suppressRefresh;
                m_suppressRefresh = true;
                m_doc->undoStack.beginMacro(QStringLiteral("Convert to Hex"));

                // Remove the original node
                QVector<Node> subtree;
                subtree.append(n);
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::Remove{nodeId, subtree, {}}));

                // Insert hex nodes to fill the space (largest first)
                int padOffset = baseOffset;
                int gap = totalSize;
                while (gap > 0) {
                    NodeKind padKind;
                    int padSize;
                    if (gap >= 8)      { padKind = NodeKind::Hex64; padSize = 8; }
                    else if (gap >= 4) { padKind = NodeKind::Hex32; padSize = 4; }
                    else if (gap >= 2) { padKind = NodeKind::Hex16; padSize = 2; }
                    else               { padKind = NodeKind::Hex8;  padSize = 1; }

                    insertNode(parentId, padOffset, padKind,
                               QString("pad_%1").arg(padOffset, 2, 16, QChar('0')));
                    padOffset += padSize;
                    gap -= padSize;
                }

                m_doc->undoStack.endMacro();
                m_suppressRefresh = wasSuppressed;
                if (!m_suppressRefresh) refresh();
            });
        }

        menu.addSeparator();

        if (node.kind == NodeKind::Struct || node.kind == NodeKind::Array) {
            menu.addAction(icon("diff-added.svg"), "Add &Child", [this, nodeId]() {
                insertNode(nodeId, 0, NodeKind::Hex64, "newField");
            });
            if (node.collapsed) {
                menu.addAction(icon("expand-all.svg"), "&Expand", [this, nodeId]() {
                    int ni = m_doc->tree.indexOfId(nodeId);
                    if (ni >= 0) toggleCollapse(ni);
                });
            } else {
                menu.addAction(icon("collapse-all.svg"), "&Collapse", [this, nodeId]() {
                    int ni = m_doc->tree.indexOfId(nodeId);
                    if (ni >= 0) toggleCollapse(ni);
                });
            }

        }

        // Dissolve Union: available on union itself or any of its children
        {
            uint64_t targetUnionId = 0;
            if (node.kind == NodeKind::Struct
                && node.resolvedClassKeyword() == QStringLiteral("union")) {
                targetUnionId = nodeId;
            } else if (node.parentId != 0) {
                int pi = m_doc->tree.indexOfId(node.parentId);
                if (pi >= 0 && m_doc->tree.nodes[pi].kind == NodeKind::Struct
                    && m_doc->tree.nodes[pi].resolvedClassKeyword() == QStringLiteral("union")) {
                    targetUnionId = node.parentId;
                }
            }
            if (targetUnionId != 0) {
                menu.addAction("Dissolve Union", [this, targetUnionId]() {
                    dissolveUnion(targetUnionId);
                });
            }
        }

        menu.addAction(icon("files.svg"), "D&uplicate\tCtrl+D", [this, nodeId]() {
            int ni = m_doc->tree.indexOfId(nodeId);
            if (ni >= 0) duplicateNode(ni);
        });
        menu.addAction(icon("trash.svg"), "&Delete\tDelete", [this, nodeId]() {
            int ni = m_doc->tree.indexOfId(nodeId);
            if (ni >= 0) removeNode(ni);
        });

        menu.addSeparator();

        menu.addAction(icon("link.svg"), "Copy &Address", [this, nodeId]() {
            int ni = m_doc->tree.indexOfId(nodeId);
            if (ni < 0) return;
            uint64_t addr = m_doc->tree.baseAddress + m_doc->tree.computeOffset(ni);
            QApplication::clipboard()->setText(
                QStringLiteral("0x") + QString::number(addr, 16).toUpper());
        });

        menu.addAction(icon("whole-word.svg"), "Copy &Offset", [this, nodeId]() {
            int ni = m_doc->tree.indexOfId(nodeId);
            if (ni < 0) return;
            int off = m_doc->tree.nodes[ni].offset;
            QApplication::clipboard()->setText(
                QStringLiteral("+0x") + QString::number(off, 16).toUpper().rightJustified(4, '0'));
        });

        menu.addSeparator();
    }

    // ── Always-available actions ──

    menu.addAction(icon("diff-added.svg"), "Append bytes...", [this, &menu]() {
        bool ok;
        QString input = QInputDialog::getText(menu.parentWidget(),
            QStringLiteral("Append bytes"),
            QStringLiteral("Byte count (decimal or 0x hex):"),
            QLineEdit::Normal, QStringLiteral("128"), &ok);
        if (!ok || input.trimmed().isEmpty()) return;

        QString trimmed = input.trimmed();
        int byteCount = 0;
        if (trimmed.startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
            byteCount = trimmed.mid(2).toInt(&ok, 16);
        else
            byteCount = trimmed.toInt(&ok, 10);
        if (!ok || byteCount <= 0) return;

        uint64_t target = m_viewRootId ? m_viewRootId : 0;
        int hex64Count = byteCount / 8;
        int remainBytes = byteCount % 8;

        m_suppressRefresh = true;
        m_doc->undoStack.beginMacro(QStringLiteral("Append %1 bytes").arg(byteCount));
        int idx = 0;
        for (int i = 0; i < hex64Count; i++, idx++)
            insertNode(target, -1, NodeKind::Hex64,
                       QStringLiteral("field_%1").arg(idx));
        for (int i = 0; i < remainBytes; i++, idx++)
            insertNode(target, -1, NodeKind::Hex8,
                       QStringLiteral("field_%1").arg(idx));
        m_doc->undoStack.endMacro();
        m_suppressRefresh = false;
        refresh();
    });

    menu.addSeparator();
    // Only add Track Value Changes here if not already added in node-specific section
    if (!hasNode) {
        auto* act = menu.addAction("Track Value Changes");
        act->setCheckable(true);
        act->setChecked(m_trackValues);
        connect(act, &QAction::toggled, this, &RcxController::setTrackValues);
        menu.addSeparator();
    }

    menu.addAction(icon("arrow-left.svg"), "Undo", [this]() {
        m_doc->undoStack.undo();
    })->setEnabled(m_doc->undoStack.canUndo());
    menu.addAction(icon("arrow-right.svg"), "Redo", [this]() {
        m_doc->undoStack.redo();
    })->setEnabled(m_doc->undoStack.canRedo());

    menu.addSeparator();

    menu.addAction(icon("clippy.svg"), "Copy All as Text", [editor]() {
        QApplication::clipboard()->setText(editor->textWithMargins());
    });

    menu.exec(globalPos);
}

void RcxController::batchRemoveNodes(const QVector<int>& nodeIndices) {
    QSet<uint64_t> idSet;
    for (int idx : nodeIndices) {
        if (idx >= 0 && idx < m_doc->tree.nodes.size())
            idSet.insert(m_doc->tree.nodes[idx].id);
    }
    idSet = m_doc->tree.normalizePreferAncestors(idSet);
    if (idSet.isEmpty()) return;

    // Clear selection before delete (prevents stale highlight on shifted lines)
    m_selIds.clear();
    m_anchorLine = -1;

    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QString("Delete %1 nodes").arg(idSet.size()));
    for (uint64_t id : idSet) {
        int idx = m_doc->tree.indexOfId(id);
        if (idx >= 0) removeNode(idx);
    }
    m_doc->undoStack.endMacro();
    m_suppressRefresh = false;
    refresh();
}

void RcxController::batchChangeKind(const QVector<int>& nodeIndices, NodeKind newKind) {
    QSet<uint64_t> idSet;
    for (int idx : nodeIndices) {
        if (idx >= 0 && idx < m_doc->tree.nodes.size())
            idSet.insert(m_doc->tree.nodes[idx].id);
    }
    idSet = m_doc->tree.normalizePreferDescendants(idSet);
    if (idSet.isEmpty()) return;

    // Clear selection before batch change
    m_selIds.clear();
    m_anchorLine = -1;

    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QString("Change type of %1 nodes").arg(idSet.size()));
    for (uint64_t id : idSet) {
        int idx = m_doc->tree.indexOfId(id);
        if (idx >= 0) changeNodeKind(idx, newKind);
    }
    m_doc->undoStack.endMacro();
    m_suppressRefresh = false;
    refresh();
}

void RcxController::handleNodeClick(RcxEditor* source, int line,
                                     uint64_t nodeId,
                                     Qt::KeyboardModifiers mods) {
    bool ctrl  = mods & Qt::ControlModifier;
    bool shift = mods & Qt::ShiftModifier;

    // Compute effective selection ID:
    //   footers        → nodeId | kFooterIdBit
    //   array elements → nodeId | kArrayElemBit | (elemIdx << 48)
    //   everything else → nodeId
    auto effectiveId = [this](int ln, uint64_t nid) -> uint64_t {
        if (ln < 0 || ln >= m_lastResult.meta.size()) return nid;
        const auto& lm = m_lastResult.meta[ln];
        if (lm.lineKind == LineKind::Footer)
            return nid | kFooterIdBit;
        if (lm.isArrayElement && lm.arrayElementIdx >= 0)
            return makeArrayElemSelId(nid, lm.arrayElementIdx);
        return nid;
    };

    uint64_t selId = effectiveId(line, nodeId);

    if (!ctrl && !shift) {
        m_selIds.clear();
        m_selIds.insert(selId);
        m_anchorLine = line;
    } else if (ctrl && !shift) {
        if (m_selIds.contains(selId))
            m_selIds.remove(selId);
        else
            m_selIds.insert(selId);
        m_anchorLine = line;
    } else if (shift && !ctrl) {
        if (m_anchorLine < 0) {
            m_selIds.clear();
            m_selIds.insert(selId);
            m_anchorLine = line;
        } else {
            m_selIds.clear();
            int from = qMin(m_anchorLine, line);
            int to   = qMax(m_anchorLine, line);
            for (int i = from; i <= to && i < m_lastResult.meta.size(); i++) {
                uint64_t nid = m_lastResult.meta[i].nodeId;
                if (nid != 0 && nid != kCommandRowId) m_selIds.insert(effectiveId(i, nid));
            }
        }
    } else { // Ctrl+Shift
        if (m_anchorLine < 0) {
            m_selIds.insert(selId);
            m_anchorLine = line;
        } else {
            int from = qMin(m_anchorLine, line);
            int to   = qMax(m_anchorLine, line);
            for (int i = from; i <= to && i < m_lastResult.meta.size(); i++) {
                uint64_t nid = m_lastResult.meta[i].nodeId;
                if (nid != 0 && nid != kCommandRowId) m_selIds.insert(effectiveId(i, nid));
            }
        }
    }

    updateCommandRow();
    applySelectionOverlays();

    if (m_selIds.size() == 1) {
        uint64_t sid = *m_selIds.begin();
        // Strip footer/array bits for node lookup
        int idx = m_doc->tree.indexOfId(sid & ~(kFooterIdBit | kArrayElemBit | kArrayElemMask));
        if (idx >= 0) emit nodeSelected(idx);
    }
}

void RcxController::clearSelection() {
    m_selIds.clear();
    m_anchorLine = -1;
    updateCommandRow();
    applySelectionOverlays();
}

void RcxController::applySelectionOverlays() {
    for (auto* editor : m_editors)
        editor->applySelectionOverlay(m_selIds);
}


void RcxController::updateCommandRow() {
    // -- Source label: driven by provider metadata --
    QString src;
    QString provName = m_doc->provider->name();
    if (provName.isEmpty()) {
        src = QStringLiteral("source\u25BE");
    } else {
        src = QStringLiteral("'%1'\u25BE")
            .arg(provName);
    }

    QString addr;
    if (!m_doc->tree.baseAddressFormula.isEmpty())
        addr = m_doc->tree.baseAddressFormula;
    else
        addr = QStringLiteral("0x") +
            QString::number(m_doc->tree.baseAddress, 16).toUpper();

    QString row = QStringLiteral("%1 \u00B7 %2")
        .arg(elide(src, 40), elide(addr, 24));

    // Build row 2: root class type + name (uses current view root)
    QString row2;
    if (m_viewRootId != 0) {
        int vi = m_doc->tree.indexOfId(m_viewRootId);
        if (vi >= 0) {
            const auto& n = m_doc->tree.nodes[vi];
            QString keyword = n.resolvedClassKeyword();
            QString className = n.structTypeName.isEmpty() ? n.name : n.structTypeName;
            row2 = QStringLiteral("%1 %2 {")
                .arg(keyword, className.isEmpty() ? QStringLiteral("NoName") : className);
        }
    }
    if (row2.isEmpty()) {
        // Fallback: find first root struct
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            const auto& n = m_doc->tree.nodes[i];
            if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                QString keyword = n.resolvedClassKeyword();
                QString className = n.structTypeName.isEmpty() ? n.name : n.structTypeName;
                row2 = QStringLiteral("%1 %2 {")
                    .arg(keyword, className.isEmpty() ? QStringLiteral("NoName") : className);
                break;
            }
        }
    }
    if (row2.isEmpty())
        row2 = QStringLiteral("struct NoName {");

    QString combined = QStringLiteral("[\u25B8] ") + row + QStringLiteral(" \u00B7 ") + row2;

    for (auto* ed : m_editors) {
        ed->setCommandRowText(combined);
    }
    emit selectionChanged(m_selIds.size());
}

TypeSelectorPopup* RcxController::ensurePopup(RcxEditor* editor) {
    if (!m_cachedPopup) {
        m_cachedPopup = new TypeSelectorPopup(editor);
        // Keep popup colors in sync when theme changes
        connect(&ThemeManager::instance(), &ThemeManager::themeChanged,
                m_cachedPopup, &TypeSelectorPopup::applyTheme);
        // Pre-warm: force native window creation so first visible show is fast
        m_cachedPopup->warmUp();
    }
    // Disconnect previous signals so we can reconnect fresh
    m_cachedPopup->disconnect(this);
    return m_cachedPopup;
}

void RcxController::showTypePopup(RcxEditor* editor, TypePopupMode mode,
                                  int nodeIdx, QPoint globalPos) {
    const Node* node = nullptr;
    if (nodeIdx >= 0 && nodeIdx < m_doc->tree.nodes.size())
        node = &m_doc->tree.nodes[nodeIdx];

    // ── Build entry list based on mode ──
    QVector<TypeEntry> entries;
    TypeEntry currentEntry;
    bool hasCurrent = false;
    int preModId = 0;        // modifier to preselect: 0=plain, 1=*, 2=**, 3=[n]
    int preArrayCount = 0;   // array count when preModId==3

    auto addPrimitives = [&](bool enabled, bool excludeStructArrayPad) {
        for (const auto& m : kKindMeta) {
            if (excludeStructArrayPad &&
                (m.kind == NodeKind::Struct || m.kind == NodeKind::Array))
                continue;
            TypeEntry e;
            e.entryKind     = TypeEntry::Primitive;
            e.primitiveKind = m.kind;
            e.displayName   = QString::fromLatin1(m.typeName);
            e.enabled       = enabled;
            entries.append(e);
        }
    };

    auto addComposites = [&](const std::function<bool(const Node&, const TypeEntry&)>& isCurrent) {
        for (const auto& n : m_doc->tree.nodes) {
            if (n.parentId != 0 || n.kind != NodeKind::Struct) continue;
            TypeEntry e;
            e.entryKind    = TypeEntry::Composite;
            e.structId     = n.id;
            e.displayName  = n.structTypeName.isEmpty() ? n.name : n.structTypeName;
            e.classKeyword = n.resolvedClassKeyword();
            entries.append(e);
            if (!hasCurrent && node && isCurrent(*node, e)) {
                currentEntry = e;
                hasCurrent = true;
            }
        }
    };

    switch (mode) {
    case TypePopupMode::Root:
        // No primitives in Root mode – only project types are valid roots
        addComposites([&](const Node&, const TypeEntry& e) {
            return e.structId == m_viewRootId;
        });
        break;

    case TypePopupMode::FieldType: {
        addPrimitives(/*enabled=*/true, /*excludeStructArrayPad=*/false);
        bool isPtr = node
            && (node->kind == NodeKind::Pointer32 || node->kind == NodeKind::Pointer64);
        bool isTypedPtr = isPtr && node->refId != 0;
        bool isPrimPtr  = isPtr && node->ptrDepth > 0 && node->refId == 0;
        bool isArray = node && node->kind == NodeKind::Array;

        if (isPrimPtr) {
            // Primitive pointer (e.g. int32* or f64**) — current = element kind, modifier = *//**
            preModId = (node->ptrDepth >= 2) ? 2 : 1;
            for (auto& e : entries) {
                if (e.entryKind == TypeEntry::Primitive && e.primitiveKind == node->elementKind) {
                    currentEntry = e;
                    hasCurrent = true;
                    break;
                }
            }
        } else if (isTypedPtr) {
            // Typed pointer (e.g. Ball*) — current = composite target, modifier = *
            preModId = 1;
        } else if (isArray) {
            // Array — modifier = [n]
            preModId = 3;
            preArrayCount = node->arrayLen;
            if (node->elementKind != NodeKind::Struct) {
                // Primitive array — mark element kind as current
                for (auto& e : entries) {
                    if (e.entryKind == TypeEntry::Primitive && e.primitiveKind == node->elementKind) {
                        currentEntry = e;
                        hasCurrent = true;
                        break;
                    }
                }
            }
        } else if (node) {
            // Plain primitive — mark current
            for (auto& e : entries) {
                if (e.entryKind == TypeEntry::Primitive && e.primitiveKind == node->kind) {
                    currentEntry = e;
                    hasCurrent = true;
                    break;
                }
            }
        }
        // For isTypedPtr or struct-array: current is a Composite, set by addComposites below
        addComposites([&](const Node& n, const TypeEntry& e) {
            if (isTypedPtr && n.refId == e.structId) return true;
            if (isArray && n.elementKind == NodeKind::Struct && n.refId == e.structId) return true;
            return false;
        });
        break;
    }

    case TypePopupMode::ArrayElement:
        addPrimitives(/*enabled=*/true, /*excludeStructArrayPad=*/true);
        if (node) {
            for (auto& e : entries) {
                if (e.entryKind == TypeEntry::Primitive && e.primitiveKind == node->elementKind) {
                    currentEntry = e;
                    hasCurrent = true;
                    break;
                }
            }
        }
        addComposites([](const Node& n, const TypeEntry& e) {
            return n.elementKind == NodeKind::Struct && n.refId == e.structId;
        });
        break;

    case TypePopupMode::PointerTarget: {
        // "void" entry as a primitive with a special display
        TypeEntry voidEntry;
        voidEntry.entryKind     = TypeEntry::Primitive;
        voidEntry.primitiveKind = NodeKind::Hex8; // unused, but needs a value
        voidEntry.displayName   = QStringLiteral("void");
        voidEntry.enabled       = true;
        entries.append(voidEntry);
        if (node && node->refId == 0) {
            currentEntry = voidEntry;
            hasCurrent = true;
        }
        addComposites([](const Node& n, const TypeEntry& e) {
            return n.refId == e.structId;
        });
        break;
    }
    }

    // ── Add types from other open documents (not for Root mode) ──
    if (mode != TypePopupMode::Root && m_projectDocs) {
        QSet<QString> localNames;
        for (const auto& e : entries)
            if (e.entryKind == TypeEntry::Composite)
                localNames.insert(e.displayName);
        for (auto* doc : *m_projectDocs) {
            if (doc == m_doc) continue;
            for (const auto& n : doc->tree.nodes) {
                if (n.parentId != 0 || n.kind != NodeKind::Struct) continue;
                QString name = n.structTypeName.isEmpty() ? n.name : n.structTypeName;
                if (name.isEmpty() || localNames.contains(name)) continue;
                localNames.insert(name);
                TypeEntry e;
                e.entryKind    = TypeEntry::Composite;
                e.structId     = 0; // sentinel: not in local tree yet
                e.displayName  = name;
                e.classKeyword = n.resolvedClassKeyword();
                entries.append(e);
            }
        }
    }

    // ── Font with zoom ──
    QSettings settings("Reclass", "Reclass");
    QString fontName = settings.value("font", "JetBrains Mono").toString();
    QFont font(fontName, 12);
    font.setFixedPitch(true);
    auto* sci = editor->scintilla();
    int zoom = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETZOOM);
    font.setPointSize(font.pointSize() + zoom);

    // ── Position ──
    QPoint pos = globalPos;
    if (mode == TypePopupMode::Root) {
        // Bottom-left of the [▸] span on line 0
        long lineStart = sci->SendScintilla(QsciScintillaBase::SCI_POSITIONFROMLINE, 0);
        int lineH = (int)sci->SendScintilla(QsciScintillaBase::SCI_TEXTHEIGHT, 0);
        int x = (int)sci->SendScintilla(QsciScintillaBase::SCI_POINTXFROMPOSITION,
                                         0, lineStart);
        int y = (int)sci->SendScintilla(QsciScintillaBase::SCI_POINTYFROMPOSITION,
                                         0, lineStart);
        pos = sci->viewport()->mapToGlobal(QPoint(x, y + lineH));
    }

    // ── Configure and show popup ──
    auto* popup = ensurePopup(editor);
    popup->setFont(font);
    popup->setMode(mode);

    // Preselect modifier button to reflect current node state (after setMode resets to plain)
    if (preModId > 0)
        popup->setModifier(preModId, preArrayCount);

    // Pass current node size for same-size sorting
    int nodeSize = 0;
    if (node) {
        if (mode == TypePopupMode::ArrayElement)
            nodeSize = sizeForKind(node->elementKind);
        else
            nodeSize = sizeForKind(node->kind);
    }
    popup->setCurrentNodeSize(nodeSize);

    static const char* titles[] = { "Change root", "Change type",
                                    "Element type", "Pointer target" };
    popup->setTitle(QString::fromLatin1(titles[(int)mode]));
    popup->setTypes(entries, hasCurrent ? &currentEntry : nullptr);

    connect(popup, &TypeSelectorPopup::typeSelected,
            this, [this, mode, nodeIdx](const TypeEntry& entry, const QString& fullText) {
        applyTypePopupResult(mode, nodeIdx, entry, fullText);
    });
    connect(popup, &TypeSelectorPopup::createNewTypeRequested,
            this, [this, mode, nodeIdx]() {
        bool wasSuppressed = m_suppressRefresh;
        m_suppressRefresh = true;
        m_doc->undoStack.beginMacro(QStringLiteral("Create new type"));

        // Generate unique default type name
        QString baseName = QStringLiteral("NewClass");
        QString typeName = baseName;
        int counter = 1;
        QSet<QString> existing;
        for (const auto& nd : m_doc->tree.nodes) {
            if (nd.kind == NodeKind::Struct && !nd.structTypeName.isEmpty())
                existing.insert(nd.structTypeName);
        }
        while (existing.contains(typeName))
            typeName = baseName + QString::number(counter++);

        Node n;
        n.kind = NodeKind::Struct;
        n.structTypeName = typeName;
        n.name = QStringLiteral("instance");
        n.parentId = 0;
        n.offset = 0;
        n.id = m_doc->tree.reserveId();
        m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{n}));

        // Populate with default hex nodes (8 x Hex64 = 64 bytes)
        for (int i = 0; i < 8; i++) {
            insertNode(n.id, i * 8, NodeKind::Hex64,
                       QString("field_%1").arg(i * 8, 2, 16, QChar('0')));
        }

        m_doc->undoStack.endMacro();
        m_suppressRefresh = wasSuppressed;

        TypeEntry newEntry;
        newEntry.entryKind = TypeEntry::Composite;
        newEntry.structId  = n.id;
        applyTypePopupResult(mode, nodeIdx, newEntry, QString());
    });

    popup->popup(pos);
}

void RcxController::applyTypePopupResult(TypePopupMode mode, int nodeIdx,
                                         const TypeEntry& entry, const QString& fullText) {
    // Resolve external types: structId==0 means from another document, import first
    TypeEntry resolved = entry;
    if (resolved.entryKind == TypeEntry::Composite && resolved.structId == 0
        && !resolved.displayName.isEmpty()) {
        resolved.structId = findOrCreateStructByName(resolved.displayName);
    }

    if (mode == TypePopupMode::Root) {
        if (resolved.entryKind == TypeEntry::Composite)
            setViewRootId(resolved.structId);
        return;
    }

    if (nodeIdx < 0 || nodeIdx >= m_doc->tree.nodes.size()) return;

    // BUG-1 fix: Copy needed fields to locals before any mutation.
    // changeNodeKind() can trigger insertNode() → addNode() → nodes.append(),
    // which may reallocate the QVector, invalidating any reference into it.
    const uint64_t nodeId   = m_doc->tree.nodes[nodeIdx].id;
    const NodeKind nodeKind = m_doc->tree.nodes[nodeIdx].kind;
    const NodeKind elemKind = m_doc->tree.nodes[nodeIdx].elementKind;
    const uint64_t nodeRefId = m_doc->tree.nodes[nodeIdx].refId;
    const int      arrLen   = m_doc->tree.nodes[nodeIdx].arrayLen;

    // Parse the full text for modifiers (e.g. "int32_t[10]", "Ball*")
    TypeSpec spec = parseTypeSpec(fullText);

    if (mode == TypePopupMode::FieldType) {
        if (resolved.entryKind == TypeEntry::Primitive) {
            if (spec.arrayCount > 0) {
                // Primitive array: e.g. "int32_t[10]"
                bool wasSuppressed = m_suppressRefresh;
                m_suppressRefresh = true;
                m_doc->undoStack.beginMacro(QStringLiteral("Change to primitive array"));
                if (nodeKind != NodeKind::Array)
                    changeNodeKind(nodeIdx, NodeKind::Array);
                int idx = m_doc->tree.indexOfId(nodeId);
                if (idx >= 0) {
                    auto& n = m_doc->tree.nodes[idx];
                    if (n.elementKind != resolved.primitiveKind || n.arrayLen != spec.arrayCount)
                        m_doc->undoStack.push(new RcxCommand(this,
                            cmd::ChangeArrayMeta{nodeId, n.elementKind, resolved.primitiveKind,
                                                 n.arrayLen, spec.arrayCount}));
                }
                m_doc->undoStack.endMacro();
                m_suppressRefresh = wasSuppressed;
                if (!m_suppressRefresh) refresh();
            } else if (spec.isPointer) {
                if (!isValidPrimitivePtrTarget(resolved.primitiveKind)) {
                    // Hex, pointer, fnptr types with * → plain void pointer
                    if (nodeKind != NodeKind::Pointer64)
                        changeNodeKind(nodeIdx, NodeKind::Pointer64);
                    int idx = m_doc->tree.indexOfId(nodeId);
                    if (idx >= 0) {
                        auto& n = m_doc->tree.nodes[idx];
                        n.ptrDepth = 0;
                        if (n.refId != 0)
                            m_doc->undoStack.push(new RcxCommand(this,
                                cmd::ChangePointerRef{nodeId, n.refId, 0}));
                    }
                } else {
                    // Primitive pointer: e.g. "int32*" or "f64**" → Pointer64 + elementKind + ptrDepth
                    bool wasSuppressed = m_suppressRefresh;
                    m_suppressRefresh = true;
                    m_doc->undoStack.beginMacro(QStringLiteral("Change to primitive pointer"));
                    if (nodeKind != NodeKind::Pointer64)
                        changeNodeKind(nodeIdx, NodeKind::Pointer64);
                    int idx = m_doc->tree.indexOfId(nodeId);
                    if (idx >= 0) {
                        auto& n = m_doc->tree.nodes[idx];
                        if (n.elementKind != resolved.primitiveKind || n.ptrDepth != spec.ptrDepth) {
                            NodeKind oldEK = n.elementKind;
                            int oldDepth = n.ptrDepth;
                            n.elementKind = resolved.primitiveKind;
                            n.ptrDepth = spec.ptrDepth;
                            if (n.refId != 0)
                                m_doc->undoStack.push(new RcxCommand(this,
                                    cmd::ChangePointerRef{nodeId, n.refId, 0}));
                            Q_UNUSED(oldEK); Q_UNUSED(oldDepth);
                        }
                    }
                    m_doc->undoStack.endMacro();
                    m_suppressRefresh = wasSuppressed;
                    if (!m_suppressRefresh) refresh();
                }
            } else {
                if (resolved.primitiveKind != nodeKind)
                    changeNodeKind(nodeIdx, resolved.primitiveKind);
            }
        } else if (resolved.entryKind == TypeEntry::Composite) {
            bool wasSuppressed = m_suppressRefresh;
            m_suppressRefresh = true;
            m_doc->undoStack.beginMacro(QStringLiteral("Change to composite type"));

            if (spec.isPointer) {
                // Pointer modifier: e.g. "Material*" → Pointer64 + refId
                if (nodeKind != NodeKind::Pointer64)
                    changeNodeKind(nodeIdx, NodeKind::Pointer64);
                int idx = m_doc->tree.indexOfId(nodeId);
                if (idx >= 0 && m_doc->tree.nodes[idx].refId != resolved.structId)
                    m_doc->undoStack.push(new RcxCommand(this,
                        cmd::ChangePointerRef{nodeId, m_doc->tree.nodes[idx].refId, resolved.structId}));

            } else if (spec.arrayCount > 0) {
                // Array modifier: e.g. "Material[10]" → Array + Struct element
                if (nodeKind != NodeKind::Array)
                    changeNodeKind(nodeIdx, NodeKind::Array);
                int idx = m_doc->tree.indexOfId(nodeId);
                if (idx >= 0) {
                    auto& n = m_doc->tree.nodes[idx];
                    if (n.elementKind != NodeKind::Struct || n.arrayLen != spec.arrayCount)
                        m_doc->undoStack.push(new RcxCommand(this,
                            cmd::ChangeArrayMeta{nodeId, n.elementKind, NodeKind::Struct,
                                                 n.arrayLen, spec.arrayCount}));
                    if (n.refId != resolved.structId)
                        m_doc->undoStack.push(new RcxCommand(this,
                            cmd::ChangePointerRef{nodeId, n.refId, resolved.structId}));
                }

            } else {
                // Plain struct: e.g. "Material" → Struct + structTypeName + refId + collapsed
                if (nodeKind != NodeKind::Struct)
                    changeNodeKind(nodeIdx, NodeKind::Struct);
                int idx = m_doc->tree.indexOfId(nodeId);
                if (idx >= 0) {
                    int refIdx = m_doc->tree.indexOfId(resolved.structId);
                    QString targetName;
                    if (refIdx >= 0) {
                        const Node& ref = m_doc->tree.nodes[refIdx];
                        targetName = ref.structTypeName.isEmpty() ? ref.name : ref.structTypeName;
                    }
                    QString oldTypeName = m_doc->tree.nodes[idx].structTypeName;
                    if (oldTypeName != targetName)
                        m_doc->undoStack.push(new RcxCommand(this,
                            cmd::ChangeStructTypeName{nodeId, oldTypeName, targetName}));
                    // Set refId so compose can expand the referenced struct's children
                    if (m_doc->tree.nodes[idx].refId != resolved.structId)
                        m_doc->undoStack.push(new RcxCommand(this,
                            cmd::ChangePointerRef{nodeId, m_doc->tree.nodes[idx].refId, resolved.structId}));
                    // ChangePointerRef auto-sets collapsed=true when refId != 0
                }
            }

            m_doc->undoStack.endMacro();
            m_suppressRefresh = wasSuppressed;
            if (!m_suppressRefresh) refresh();
        }
    } else if (mode == TypePopupMode::ArrayElement) {
        if (resolved.entryKind == TypeEntry::Primitive) {
            if (resolved.primitiveKind != elemKind) {
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::ChangeArrayMeta{nodeId,
                        elemKind, resolved.primitiveKind,
                        arrLen, arrLen}));
            }
        } else if (resolved.entryKind == TypeEntry::Composite) {
            if (elemKind != NodeKind::Struct || nodeRefId != resolved.structId) {
                m_doc->undoStack.push(new RcxCommand(this,
                    cmd::ChangeArrayMeta{nodeId,
                        elemKind, NodeKind::Struct,
                        arrLen, arrLen}));
                if (nodeRefId != resolved.structId) {
                    m_doc->undoStack.push(new RcxCommand(this,
                        cmd::ChangePointerRef{nodeId, nodeRefId, resolved.structId}));
                }
            }
        }
    } else if (mode == TypePopupMode::PointerTarget) {
        // "void" entry → refId 0; composite entry → real structId
        uint64_t realRefId = (resolved.entryKind == TypeEntry::Composite) ? resolved.structId : 0;
        if (realRefId != nodeRefId) {
            m_doc->undoStack.push(new RcxCommand(this,
                cmd::ChangePointerRef{nodeId, nodeRefId, realRefId}));
        }
    }
}

uint64_t RcxController::findOrCreateStructByName(const QString& typeName) {
    // Check if it already exists locally
    for (const auto& n : m_doc->tree.nodes) {
        if (n.parentId == 0 && n.kind == NodeKind::Struct
            && (n.structTypeName == typeName || (n.structTypeName.isEmpty() && n.name == typeName)))
            return n.id;
    }
    // Import: create a new root struct with that name + default hex fields
    bool wasSuppressed = m_suppressRefresh;
    m_suppressRefresh = true;
    m_doc->undoStack.beginMacro(QStringLiteral("Import type"));
    Node n;
    n.kind = NodeKind::Struct;
    n.structTypeName = typeName;
    n.name = QStringLiteral("instance");
    n.parentId = 0;
    n.offset = 0;
    n.id = m_doc->tree.reserveId();
    m_doc->undoStack.push(new RcxCommand(this, cmd::Insert{n}));
    for (int i = 0; i < 8; i++)
        insertNode(n.id, i * 8, NodeKind::Hex64,
                   QString("field_%1").arg(i * 8, 2, 16, QChar('0')));
    m_doc->undoStack.endMacro();
    m_suppressRefresh = wasSuppressed;
    return n.id;
}

void RcxController::attachViaPlugin(const QString& providerIdentifier, const QString& target) {
    const auto* info = ProviderRegistry::instance().findProvider(providerIdentifier);
    if (!info || !info->plugin) {
        QMessageBox::warning(qobject_cast<QWidget*>(parent()),
            "Provider Error",
            QString("Provider '%1' not found. Is the plugin loaded?").arg(providerIdentifier));
        return;
    }

    QString errorMsg;
    auto provider = info->plugin->createProvider(target, &errorMsg);
    if (!provider) {
        if (!errorMsg.isEmpty())
            QMessageBox::warning(qobject_cast<QWidget*>(parent()), "Provider Error", errorMsg);
        return;
    }

    m_doc->undoStack.clear();
    m_doc->provider = std::move(provider);
    m_doc->dataPath.clear();
    // Don't overwrite baseAddress — caller (e.g. selfTest) already set it.
    // User-initiated source switches go through selectSource() which does update it.

    // Re-evaluate stored formula against the new provider
    if (!m_doc->tree.baseAddressFormula.isEmpty()) {
        AddressParserCallbacks cbs;
        auto* prov = m_doc->provider.get();
        cbs.resolveModule = [prov](const QString& name, bool* ok) -> uint64_t {
            uint64_t base = prov->symbolToAddress(name);
            *ok = (base != 0);
            return base;
        };
        cbs.readPointer = [prov](uint64_t addr, bool* ok) -> uint64_t {
            uint64_t val = 0;
            *ok = prov->read(addr, &val, 8);
            return val;
        };
        auto result = AddressParser::evaluate(m_doc->tree.baseAddressFormula, 8, &cbs);
        if (result.ok)
            m_doc->tree.baseAddress = result.value;
    }

    resetSnapshot();
    emit m_doc->documentChanged();
    refresh();
}

void RcxController::switchToSavedSource(int idx) {
    if (idx < 0 || idx >= m_savedSources.size()) return;
    if (idx == m_activeSourceIdx) return;

    // Save current source's base address before switching
    if (m_activeSourceIdx >= 0 && m_activeSourceIdx < m_savedSources.size()) {
        m_savedSources[m_activeSourceIdx].baseAddress = m_doc->tree.baseAddress;
        m_savedSources[m_activeSourceIdx].baseAddressFormula = m_doc->tree.baseAddressFormula;
    }

    m_activeSourceIdx = idx;
    const auto& entry = m_savedSources[idx];

    if (entry.kind == QStringLiteral("File")) {
        m_doc->loadData(entry.filePath);
        m_doc->tree.baseAddress = entry.baseAddress;
        m_doc->tree.baseAddressFormula = entry.baseAddressFormula;
        refresh();
    } else if (!entry.providerTarget.isEmpty()) {
        // Plugin-based provider (e.g. "processmemory" with target "pid:name")
        // Restore formula before attach so it can be re-evaluated against the new provider
        m_doc->tree.baseAddressFormula = entry.baseAddressFormula;
        attachViaPlugin(entry.kind, entry.providerTarget);
        // Restore saved base address (user may have navigated away from provider default)
        if (entry.baseAddress != 0 && entry.baseAddressFormula.isEmpty())
            m_doc->tree.baseAddress = entry.baseAddress;
    }
}

void RcxController::selectSource(const QString& text) {
    if (text == QStringLiteral("#clear")) {
        clearSources();
    } else if (text.startsWith(QStringLiteral("#saved:"))) {
        int idx = text.mid(7).toInt();
        switchToSavedSource(idx);
    } else if (text == QStringLiteral("File")) {
        auto* w = qobject_cast<QWidget*>(parent());
        QString path = QFileDialog::getOpenFileName(w, "Load Binary Data", {}, "All Files (*)");
        if (!path.isEmpty()) {
            if (m_activeSourceIdx >= 0 && m_activeSourceIdx < m_savedSources.size())
                m_savedSources[m_activeSourceIdx].baseAddress = m_doc->tree.baseAddress;

            m_doc->loadData(path);

            int existingIdx = -1;
            for (int i = 0; i < m_savedSources.size(); i++) {
                if (m_savedSources[i].kind == QStringLiteral("File")
                    && m_savedSources[i].filePath == path) {
                    existingIdx = i;
                    break;
                }
            }
            if (existingIdx >= 0) {
                m_activeSourceIdx = existingIdx;
                m_doc->tree.baseAddress = m_savedSources[existingIdx].baseAddress;
            } else {
                SavedSourceEntry entry;
                entry.kind = QStringLiteral("File");
                entry.displayName = QFileInfo(path).fileName();
                entry.filePath = path;
                entry.baseAddress = m_doc->tree.baseAddress;
                m_savedSources.append(entry);
                m_activeSourceIdx = m_savedSources.size() - 1;
            }
            refresh();
        }
    } else {
        const auto* providerInfo = ProviderRegistry::instance().findProvider(text.toLower().replace(" ", ""));
        if (providerInfo) {
            QString target;
            bool selected = false;

            if (providerInfo->isBuiltin) {
                if (providerInfo->factory)
                    selected = providerInfo->factory(qobject_cast<QWidget*>(parent()), &target);
            } else {
                if (providerInfo->plugin)
                    selected = providerInfo->plugin->selectTarget(qobject_cast<QWidget*>(parent()), &target);
            }

            if (selected && !target.isEmpty()) {
                std::unique_ptr<Provider> provider;
                QString errorMsg;
                if (providerInfo->plugin)
                    provider = providerInfo->plugin->createProvider(target, &errorMsg);

                if (provider) {
                    if (m_activeSourceIdx >= 0 && m_activeSourceIdx < m_savedSources.size())
                        m_savedSources[m_activeSourceIdx].baseAddress = m_doc->tree.baseAddress;

                    uint64_t newBase = provider->base();
                    QString displayName = provider->name();
                    m_doc->undoStack.clear();
                    m_doc->provider = std::move(provider);
                    m_doc->dataPath.clear();
                    m_doc->tree.baseAddress = (newBase != 0) ? newBase : m_doc->tree.baseAddress;
                    resetSnapshot();
                    emit m_doc->documentChanged();

                    QString identifier = providerInfo->identifier;
                    int existingIdx = -1;
                    for (int i = 0; i < m_savedSources.size(); i++) {
                        if (m_savedSources[i].kind == identifier
                            && m_savedSources[i].providerTarget == target) {
                            existingIdx = i;
                            break;
                        }
                    }
                    if (existingIdx >= 0) {
                        m_activeSourceIdx = existingIdx;
                        m_savedSources[existingIdx].baseAddress = m_doc->tree.baseAddress;
                    } else {
                        SavedSourceEntry entry;
                        entry.kind = identifier;
                        entry.displayName = displayName;
                        entry.providerTarget = target;
                        entry.baseAddress = m_doc->tree.baseAddress;
                        m_savedSources.append(entry);
                        m_activeSourceIdx = m_savedSources.size() - 1;
                    }
                    refresh();
                } else if (!errorMsg.isEmpty()) {
                    QMessageBox::warning(qobject_cast<QWidget*>(parent()), "Provider Error", errorMsg);
                }
            }
        }
    }
}

void RcxController::clearSources() {
    m_savedSources.clear();
    m_activeSourceIdx = -1;
    m_doc->provider = std::make_shared<NullProvider>();
    m_doc->dataPath.clear();
    resetSnapshot();
    pushSavedSourcesToEditors();
    refresh();
}

void RcxController::copySavedSources(const QVector<SavedSourceEntry>& sources, int activeIdx) {
    m_savedSources = sources;
    m_activeSourceIdx = activeIdx;
    pushSavedSourcesToEditors();
}

void RcxController::pushSavedSourcesToEditors() {
    QVector<SavedSourceDisplay> display;
    display.reserve(m_savedSources.size());
    for (int i = 0; i < m_savedSources.size(); i++) {
        SavedSourceDisplay d;
        d.text = QStringLiteral("%1 '%2'")
            .arg(m_savedSources[i].kind, m_savedSources[i].displayName);
        d.active = (i == m_activeSourceIdx);
        display.append(d);
    }
    for (auto* editor : m_editors)
        editor->setSavedSources(display);
}

// ── Auto-refresh ──

void RcxController::setRefreshInterval(int ms) {
    if (m_refreshTimer)
        m_refreshTimer->setInterval(qMax(1, ms));
}

void RcxController::setCompactColumns(bool v) {
    m_compactColumns = v;
    refresh();
}

void RcxController::setupAutoRefresh() {
    int ms = QSettings("Reclass", "Reclass").value("refreshMs", 660).toInt();
    m_refreshTimer = new QTimer(this);
    m_refreshTimer->setInterval(qMax(1, ms));
    connect(m_refreshTimer, &QTimer::timeout, this, &RcxController::onRefreshTick);
    m_refreshTimer->start();

    m_refreshWatcher = new QFutureWatcher<PageMap>(this);
    connect(m_refreshWatcher, &QFutureWatcher<PageMap>::finished,
            this, &RcxController::onReadComplete);
}

// Recursively collect memory ranges for a struct and its pointer targets.
// memBase is the absolute address where this struct's data lives.
void RcxController::collectPointerRanges(
        uint64_t structId, uint64_t memBase,
        int depth, int maxDepth,
        QSet<QPair<uint64_t,uint64_t>>& visited,
        QVector<QPair<uint64_t,int>>& ranges) const
{
    if (depth >= maxDepth) return;
    QPair<uint64_t,uint64_t> key{structId, memBase};
    if (visited.contains(key)) return;
    visited.insert(key);

    int span = m_doc->tree.structSpan(structId);
    if (span <= 0) return;
    ranges.append({memBase, span});

    if (!m_snapshotProv) return;

    // Walk children looking for non-collapsed pointers
    QVector<int> children = m_doc->tree.childrenOf(structId);
    for (int ci : children) {
        const Node& child = m_doc->tree.nodes[ci];
        if (child.kind != NodeKind::Pointer32 && child.kind != NodeKind::Pointer64)
            continue;
        if (child.collapsed || child.refId == 0) continue;

        uint64_t ptrAddr = memBase + child.offset;
        int ptrSize = child.byteSize();
        if (!m_snapshotProv->isReadable(ptrAddr, ptrSize)) continue;

        uint64_t ptrVal = (child.kind == NodeKind::Pointer32)
            ? (uint64_t)m_snapshotProv->readU32(ptrAddr)
            : m_snapshotProv->readU64(ptrAddr);
        if (ptrVal == 0 || ptrVal == UINT64_MAX) continue;

        uint64_t pBase = ptrVal;
        collectPointerRanges(child.refId, pBase, depth + 1, maxDepth,
                             visited, ranges);
    }

    // Embedded struct references (struct node with refId but no own children)
    int idx = m_doc->tree.indexOfId(structId);
    if (idx >= 0) {
        const Node& sn = m_doc->tree.nodes[idx];
        if (sn.kind == NodeKind::Struct && sn.refId != 0 && children.isEmpty())
            collectPointerRanges(sn.refId, memBase, depth, maxDepth,
                                 visited, ranges);
    }
}

void RcxController::onRefreshTick() {
    if (m_readInFlight) return;
    if (!m_doc->provider || !m_doc->provider->isLive()) return;
    if (m_suppressRefresh) return;
    for (auto* editor : m_editors)
        if (editor->isEditing()) return;

    int extent = computeDataExtent();
    if (extent <= 0) return;

    // Collect all needed ranges: main struct + pointer targets (absolute addresses)
    QVector<QPair<uint64_t,int>> ranges;
    ranges.append({m_doc->tree.baseAddress, extent});

    if (m_snapshotProv) {
        QSet<QPair<uint64_t,uint64_t>> visited;
        uint64_t rootId = m_viewRootId;
        if (rootId == 0 && !m_doc->tree.nodes.isEmpty())
            rootId = m_doc->tree.nodes[0].id;
        collectPointerRanges(rootId, m_doc->tree.baseAddress, 0, 99, visited, ranges);
    }

    m_readInFlight = true;
    m_readGen = m_refreshGen;

    auto prov = m_doc->provider;
    m_refreshWatcher->setFuture(QtConcurrent::run([prov, ranges]() -> PageMap {
        constexpr uint64_t kPageSize = 4096;
        constexpr uint64_t kPageMask = ~(kPageSize - 1);
        PageMap pages;
        for (const auto& r : ranges) {
            uint64_t pageStart = r.first & kPageMask;
            uint64_t end = r.first + r.second;
            uint64_t pageEnd = (end + kPageSize - 1) & kPageMask;
            for (uint64_t p = pageStart; p < pageEnd; p += kPageSize) {
                if (!pages.contains(p))
                    pages[p] = prov->readBytes(p, static_cast<int>(kPageSize));
            }
        }
        return pages;
    }));
}

void RcxController::onReadComplete() {
    m_readInFlight = false;

    if (m_readGen != m_refreshGen) return;

    PageMap newPages;
    try {
        newPages = m_refreshWatcher->result();
    } catch (const std::exception& e) {
        qWarning() << "[Refresh] async read threw:" << e.what();
        return;
    } catch (...) {
        qWarning() << "[Refresh] async read threw unknown exception";
        return;
    }

    // All-zero guard: if page 0 is all zeros and we already have data, discard
    if (!m_prevPages.isEmpty() && newPages.contains(0)) {
        const QByteArray& p0 = newPages.value(0);
        bool allZero = true;
        for (int i = 0; i < p0.size(); ++i) {
            if (p0[i] != 0) { allZero = false; break; }
        }
        if (allZero) {
            qDebug() << "[Refresh] discarding all-zero page-0, keeping stale snapshot";
            return;
        }
    }

    // Fast path: no changes at all
    if (newPages == m_prevPages)
        return;

    // Compute which byte offsets changed (for change highlighting).
    // Skip on first snapshot — nothing to compare against.
    m_changedOffsets.clear();
    if (!m_prevPages.isEmpty()) {
        for (auto it = newPages.constBegin(); it != newPages.constEnd(); ++it) {
            uint64_t pageAddr = it.key();
            const QByteArray& newPage = it.value();
            auto oldIt = m_prevPages.constFind(pageAddr);
            if (oldIt == m_prevPages.constEnd())
                continue;   // new page, no previous data to diff against
            const QByteArray& oldPage = oldIt.value();
            int cmpLen = qMin(oldPage.size(), newPage.size());
            for (int i = 0; i < cmpLen; ++i) {
                if (oldPage[i] != newPage[i])
                    m_changedOffsets.insert(static_cast<int64_t>(pageAddr) + i);
            }
        }
    }

    int mainExtent = computeDataExtent();
    m_prevPages = newPages;

    if (m_snapshotProv)
        m_snapshotProv->updatePages(std::move(newPages), mainExtent);
    else
        m_snapshotProv = std::make_unique<SnapshotProvider>(
            m_doc->provider, std::move(newPages), mainExtent);

    refresh();
    m_changedOffsets.clear();
}

int RcxController::computeDataExtent() const {
    static constexpr int64_t kMaxMainExtent = 16 * 1024 * 1024; // 16 MB cap

    int64_t treeExtent = 0;
    for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
        const Node& node = m_doc->tree.nodes[i];
        int64_t off = m_doc->tree.computeOffset(i);
        int sz = (node.kind == NodeKind::Struct || node.kind == NodeKind::Array)
            ? m_doc->tree.structSpan(node.id) : node.byteSize();
        int64_t end = off + sz;
        if (end > treeExtent) treeExtent = end;
    }
    if (treeExtent > 0) return static_cast<int>(qMin(treeExtent, kMaxMainExtent));

    int provSize = m_doc->provider->size();
    if (provSize > 0) return provSize;
    return 0;
}

void RcxController::resetSnapshot() {
    m_refreshGen++;
    m_readInFlight = false;
    m_snapshotProv.reset();
    m_prevPages.clear();
    m_changedOffsets.clear();
    m_valueHistory.clear();
}

void RcxController::handleMarginClick(RcxEditor* editor, int margin,
                                       int line, Qt::KeyboardModifiers) {
    const LineMeta* lm = editor->metaForLine(line);
    if (!lm) return;

    if (lm->foldHead && (margin == 0 || margin == 1)) {
        if (lm->markerMask & (1u << M_CYCLE))
            materializeRefChildren(lm->nodeIdx);
        else
            toggleCollapse(lm->nodeIdx);
    } else if (margin == 0 || margin == 1) {
        emit nodeSelected(lm->nodeIdx);
    }
}

void RcxController::setEditorFont(const QString& fontName) {
    for (auto* editor : m_editors)
        editor->setEditorFont(fontName);
}

} // namespace rcx

```

`src/controller.h`:

```h
#pragma once
#include "core.h"
#include "editor.h"
#include "providers/snapshot_provider.h"
#include <QObject>
#include <QUndoStack>
#include <QUndoCommand>
#include <QTimer>
#include <QFutureWatcher>
#include <QPointer>
#include <memory>

namespace rcx {

class RcxController;
class TypeSelectorPopup;
struct TypeEntry;
enum class TypePopupMode;

// ── Document ──

class RcxDocument : public QObject {
    Q_OBJECT
public:
    explicit RcxDocument(QObject* parent = nullptr);

    NodeTree                   tree;
    std::shared_ptr<Provider>  provider;
    QUndoStack                 undoStack;
    QString                    filePath;
    QString                    dataPath;
    bool                       modified = false;
    QHash<NodeKind, QString>   typeAliases;

    QString resolveTypeName(NodeKind kind) const {
        auto it = typeAliases.find(kind);
        if (it != typeAliases.end() && !it.value().isEmpty())
            return it.value();
        auto* m = kindMeta(kind);
        return m ? QString::fromLatin1(m->typeName) : QStringLiteral("???");
    }

    ComposeResult compose(uint64_t viewRootId = 0, bool compactColumns = false) const;
    bool save(const QString& path);
    bool load(const QString& path);
    void loadData(const QString& binaryPath);
    void loadData(const QByteArray& data);

signals:
    void documentChanged();
};

// ── Undo command ──

class RcxCommand : public QUndoCommand {
public:
    RcxCommand(RcxController* ctrl, Command cmd);
    void undo() override;
    void redo() override;
private:
    RcxController* m_ctrl;
    Command m_cmd;
};

// ── Saved source entry ──

struct SavedSourceEntry {
    QString kind;          // "File" or provider identifier (e.g. "processmemory")
    QString displayName;   // filename or process name
    QString filePath;      // for File sources
    QString providerTarget; // for plugin providers (e.g. "pid:name")
    uint64_t baseAddress = 0;
    QString baseAddressFormula;
};

// ── Controller ──

class RcxController : public QObject {
    Q_OBJECT
public:
    explicit RcxController(RcxDocument* doc, QWidget* parent = nullptr);
    ~RcxController() override;

    RcxEditor* primaryEditor() const;
    RcxEditor* addSplitEditor(QWidget* parent = nullptr);
    void removeSplitEditor(RcxEditor* editor);
    QList<RcxEditor*> editors() const { return m_editors; }

    void convertRootKeyword(const QString& newKeyword);
    void changeNodeKind(int nodeIdx, NodeKind newKind);
    void renameNode(int nodeIdx, const QString& newName);
    void insertNode(uint64_t parentId, int offset, NodeKind kind, const QString& name);
    void removeNode(int nodeIdx);
    void toggleCollapse(int nodeIdx);
    void materializeRefChildren(int nodeIdx);
    void setNodeValue(int nodeIdx, int subLine, const QString& text,
                      bool isAscii = false, uint64_t resolvedAddr = 0);
    void duplicateNode(int nodeIdx);
    void convertToTypedPointer(uint64_t nodeId);
    void splitHexNode(uint64_t nodeId);
    void showContextMenu(RcxEditor* editor, int line, int nodeIdx, int subLine, const QPoint& globalPos);
    void batchRemoveNodes(const QVector<int>& nodeIndices);
    void batchChangeKind(const QVector<int>& nodeIndices, NodeKind newKind);
    void deleteRootStruct(uint64_t structId);
    void groupIntoUnion(const QSet<uint64_t>& nodeIds);
    void dissolveUnion(uint64_t unionId);

    void applyCommand(const Command& cmd, bool isUndo);
    void refresh();
    void applyTypePopupResult(TypePopupMode mode, int nodeIdx, const TypeEntry& entry, const QString& fullText);
    uint64_t findOrCreateStructByName(const QString& typeName);

    // Selection
    void handleNodeClick(RcxEditor* source, int line, uint64_t nodeId,
                         Qt::KeyboardModifiers mods);
    void clearSelection();
    void applySelectionOverlays();
    QSet<uint64_t> selectedIds() const { return m_selIds; }

    void setViewRootId(uint64_t id);
    uint64_t viewRootId() const { return m_viewRootId; }
    void scrollToNodeId(uint64_t nodeId);

    RcxDocument* document() const { return m_doc; }
    void setEditorFont(const QString& fontName);
    void setRefreshInterval(int ms);
    void setCompactColumns(bool v);

    // MCP bridge accessors
    void setSuppressRefresh(bool v) { m_suppressRefresh = v; }
    void attachViaPlugin(const QString& providerIdentifier, const QString& target);
    const QVector<SavedSourceEntry>& savedSources() const { return m_savedSources; }
    int activeSourceIndex() const { return m_activeSourceIdx; }
    void switchSource(int idx) { switchToSavedSource(idx); }
    void clearSources();
    void selectSource(const QString& text);
    void copySavedSources(const QVector<SavedSourceEntry>& sources, int activeIdx);

    // Value tracking toggle (per-tab, off by default)
    bool trackValues() const { return m_trackValues; }
    void setTrackValues(bool on);

    // Cross-tab type visibility: point at the project's full document list
    void setProjectDocuments(QVector<RcxDocument*>* docs) { m_projectDocs = docs; }

    // Test accessor
    const QHash<uint64_t, ValueHistory>& valueHistory() const { return m_valueHistory; }

signals:
    void nodeSelected(int nodeIdx);
    void selectionChanged(int count);

private:
    RcxDocument*       m_doc;
    QList<RcxEditor*>  m_editors;
    ComposeResult      m_lastResult;
    QSet<uint64_t>     m_selIds;
    int                m_anchorLine = -1;
    bool               m_suppressRefresh = false;
    bool               m_compactColumns = false;
    uint64_t           m_viewRootId = 0;

    // ── Saved sources for quick-switch ──
    QVector<SavedSourceEntry> m_savedSources;
    int m_activeSourceIdx = -1;

    // ── Cached type selector popup (avoids ~350ms cold-start on first show) ──
    QPointer<TypeSelectorPopup> m_cachedPopup;

    // ── Auto-refresh state ──
    using PageMap = QHash<uint64_t, QByteArray>;
    QTimer*         m_refreshTimer = nullptr;
    QFutureWatcher<PageMap>* m_refreshWatcher = nullptr;
    std::unique_ptr<SnapshotProvider> m_snapshotProv;
    PageMap         m_prevPages;
    QSet<int64_t>   m_changedOffsets;
    QHash<uint64_t, ValueHistory> m_valueHistory;
    bool            m_trackValues = false;
    uint64_t        m_refreshGen = 0;
    uint64_t        m_readGen = 0;
    bool            m_readInFlight = false;

    QVector<RcxDocument*>* m_projectDocs = nullptr;

    void connectEditor(RcxEditor* editor);
    void handleMarginClick(RcxEditor* editor, int margin, int line, Qt::KeyboardModifiers mods);
    void updateCommandRow();
    void switchToSavedSource(int idx);
    void pushSavedSourcesToEditors();
    void showTypePopup(RcxEditor* editor, TypePopupMode mode, int nodeIdx, QPoint globalPos);
    TypeSelectorPopup* ensurePopup(RcxEditor* editor);

    // ── Auto-refresh methods ──
    void setupAutoRefresh();
    void onRefreshTick();
    void onReadComplete();
    int  computeDataExtent() const;
    void resetSnapshot();
    void collectPointerRanges(uint64_t structId, uint64_t memBase,
                              int depth, int maxDepth,
                              QSet<QPair<uint64_t,uint64_t>>& visited,
                              QVector<QPair<uint64_t,int>>& ranges) const;
};

} // namespace rcx

```

`src/core.h`:

```h
#pragma once
#include <QString>
#include <QStringList>
#include <QVector>
#include <QJsonObject>
#include <QJsonArray>
#include <QByteArray>
#include <QHash>
#include <QSet>
#include <cstdint>
#include <array>
#include <memory>
#include <variant>

#include "providers/provider.h"
#include "providers/buffer_provider.h"
#include "providers/null_provider.h"

namespace rcx {

// ── Node kind enum ──

enum class NodeKind : uint8_t {
    Hex8, Hex16, Hex32, Hex64,
    Int8, Int16, Int32, Int64,
    UInt8, UInt16, UInt32, UInt64,
    Float, Double, Bool,
    Pointer32, Pointer64,
    FuncPtr32, FuncPtr64,
    Vec2, Vec3, Vec4, Mat4x4,
    UTF8, UTF16,
    Struct, Array
};

} // namespace rcx (temporarily close for qHash)
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
inline uint qHash(rcx::NodeKind key, uint seed = 0) { return qHash(static_cast<int>(key), seed); }
#endif
namespace rcx { // reopen

// ── Kind flags (replaces repeated Hex switches) ──

enum KindFlags : uint32_t {
    KF_None       = 0,
    KF_HexPreview = 1 << 0,  // Hex8..Hex64 (ASCII+hex layout)
    KF_Container  = 1 << 1,  // Struct/Array
    KF_String     = 1 << 2,  // UTF8/UTF16
    KF_Vector     = 1 << 3,  // Vec2/3/4
};

// ── Unified kind metadata table (single source of truth) ──

struct KindMeta {
    NodeKind    kind;
    const char* name;      // UI/JSON name: "Hex64", "UInt16"
    const char* typeName;  // display name: "Hex64", "uint16_t"
    int         size;      // byte size (0 = dynamic: Struct/Array)
    int         lines;     // display line count
    int         align;     // natural alignment
    uint32_t    flags;     // KindFlags bitmask
};

inline constexpr KindMeta kKindMeta[] = {
    // kind                name         typeName      sz  ln  al  flags
    {NodeKind::Hex8,      "Hex8",      "hex8",        1,  1,  1, KF_HexPreview},
    {NodeKind::Hex16,     "Hex16",     "hex16",       2,  1,  2, KF_HexPreview},
    {NodeKind::Hex32,     "Hex32",     "hex32",       4,  1,  4, KF_HexPreview},
    {NodeKind::Hex64,     "Hex64",     "hex64",       8,  1,  8, KF_HexPreview},
    {NodeKind::Int8,      "Int8",      "int8_t",      1,  1,  1, KF_None},
    {NodeKind::Int16,     "Int16",     "int16_t",     2,  1,  2, KF_None},
    {NodeKind::Int32,     "Int32",     "int32_t",     4,  1,  4, KF_None},
    {NodeKind::Int64,     "Int64",     "int64_t",     8,  1,  8, KF_None},
    {NodeKind::UInt8,     "UInt8",     "uint8_t",     1,  1,  1, KF_None},
    {NodeKind::UInt16,    "UInt16",    "uint16_t",    2,  1,  2, KF_None},
    {NodeKind::UInt32,    "UInt32",    "uint32_t",    4,  1,  4, KF_None},
    {NodeKind::UInt64,    "UInt64",    "uint64_t",    8,  1,  8, KF_None},
    {NodeKind::Float,     "Float",     "float",       4,  1,  4, KF_None},
    {NodeKind::Double,    "Double",    "double",      8,  1,  8, KF_None},
    {NodeKind::Bool,      "Bool",      "bool",        1,  1,  1, KF_None},
    {NodeKind::Pointer32, "Pointer32", "ptr32",       4,  1,  4, KF_None},
    {NodeKind::Pointer64, "Pointer64", "ptr64",       8,  1,  8, KF_None},
    {NodeKind::FuncPtr32, "FuncPtr32", "fnptr32",     4,  1,  4, KF_None},
    {NodeKind::FuncPtr64, "FuncPtr64", "fnptr64",     8,  1,  8, KF_None},
    {NodeKind::Vec2,      "Vec2",      "vec2",        8,  1,  4, KF_Vector},
    {NodeKind::Vec3,      "Vec3",      "vec3",       12,  1,  4, KF_Vector},
    {NodeKind::Vec4,      "Vec4",      "vec4",       16,  1,  4, KF_Vector},
    {NodeKind::Mat4x4,    "Mat4x4",    "mat4x4",     64,  4,  4, KF_None},
    {NodeKind::UTF8,      "UTF8",      "char[]",      1,  1,  1, KF_String},
    {NodeKind::UTF16,     "UTF16",     "wchar_t[]",   2,  1,  2, KF_String},
    {NodeKind::Struct,    "Struct",    "struct",      0,  1,  1, KF_Container},
    {NodeKind::Array,     "Array",     "array",       0,  1,  1, KF_Container},
};

inline constexpr const KindMeta* kindMeta(NodeKind k) {
    for (const auto& m : kKindMeta)
        if (m.kind == k) return &m;
    return nullptr;
}

inline constexpr int sizeForKind(NodeKind k)  { auto* m = kindMeta(k); return m ? m->size  : 0; }
inline constexpr int linesForKind(NodeKind k)  { auto* m = kindMeta(k); return m ? m->lines : 1; }
inline constexpr int alignmentFor(NodeKind k)  { auto* m = kindMeta(k); return m ? m->align : 1; }

inline const char* kindToString(NodeKind k) {
    auto* m = kindMeta(k);
    return m ? m->name : "Unknown";
}

inline NodeKind kindFromString(const QString& s) {
    for (const auto& m : kKindMeta)
        if (s == m.name) return m.kind;
    return NodeKind::Hex8;
}

inline NodeKind kindFromTypeName(const QString& s, bool* ok = nullptr) {
    for (const auto& m : kKindMeta) {
        if (s == m.typeName) {
            if (ok) *ok = true;
            return m.kind;
        }
    }
    if (ok) *ok = false;
    return NodeKind::Hex8;
}

inline constexpr uint32_t flagsFor(NodeKind k) {
    const auto* m = kindMeta(k);
    return m ? m->flags : 0;
}
inline constexpr bool isHexPreview(NodeKind k) {
    return flagsFor(k) & KF_HexPreview;
}
inline constexpr bool isHexNode(NodeKind k) {
    return k >= NodeKind::Hex8 && k <= NodeKind::Hex64;
}
inline constexpr bool isVectorKind(NodeKind k) {
    return k == NodeKind::Vec2 || k == NodeKind::Vec3 || k == NodeKind::Vec4;
}
inline constexpr bool isMatrixKind(NodeKind k) {
    return k == NodeKind::Mat4x4;
}
inline constexpr bool isFuncPtr(NodeKind k) {
    return k == NodeKind::FuncPtr32 || k == NodeKind::FuncPtr64;
}
// Hex types, pointer types, function pointers, and containers are not meaningful
// primitive-pointer targets — dereferencing them produces the same output as void*.
inline constexpr bool isValidPrimitivePtrTarget(NodeKind k) {
    if (isHexNode(k)) return false;
    if (k == NodeKind::Pointer32 || k == NodeKind::Pointer64) return false;
    if (isFuncPtr(k)) return false;
    if (k == NodeKind::Struct || k == NodeKind::Array) return false;
    return true;
}

inline QStringList allTypeNamesForUI(bool stripBrackets = false) {
    QStringList out;
    out.reserve(std::size(kKindMeta));
    for (const auto& m : kKindMeta) {
        QString t = QString::fromLatin1(m.typeName);
        if (stripBrackets) t.remove(QStringLiteral("[]"));
        out << t;
    }
    out.sort(Qt::CaseInsensitive);
    out.removeDuplicates();
    return out;
}

// ── Marker vocabulary ──

enum Marker : int {
    M_CONT      = 0,
    M_PTR0      = 2,
    M_CYCLE     = 3,
    M_ERR       = 4,
    M_STRUCT_BG = 5,
    M_HOVER     = 6,
    M_SELECTED  = 7,
    M_CMD_ROW   = 8,
    M_ACCENT    = 9,
};

// ── Node ──

struct Node {
    uint64_t id         = 0;
    NodeKind kind       = NodeKind::Hex8;
    QString  name;
    QString  structTypeName;  // Struct/Array: optional type name (e.g., "IMAGE_DOS_HEADER")
    QString  classKeyword;    // "struct", "class", or "enum" (empty = "struct")
    uint64_t parentId   = 0;   // 0 = root (no parent)
    int      offset     = 0;
    int      arrayLen   = 1;   // Array: element count
    int      strLen     = 64;
    bool     collapsed  = false;
    uint64_t refId      = 0;       // Pointer32/64: id of Struct to expand at *ptr
    NodeKind elementKind = NodeKind::UInt8;  // Array: element type; Pointer with ptrDepth>0: target type
    int      ptrDepth   = 0;   // Pointer: 0=struct/void ptr, 1=primitive*, 2=primitive**
    int      viewIndex  = 0;   // Array: current view offset (transient)
    QVector<QPair<QString, int64_t>> enumMembers; // Enum: name→value pairs

    // Note: Returns 0 for Array-of-Struct/Array. Use tree.structSpan() for accurate size.
    int byteSize() const {
        switch (kind) {
        case NodeKind::UTF8:    return strLen;
        case NodeKind::UTF16:   return qMin(strLen, INT_MAX / 2) * 2;
        case NodeKind::Array: {
            int elemSz = sizeForKind(elementKind);
            if (elemSz <= 0) return 0;
            return qMin(arrayLen, INT_MAX / elemSz) * elemSz;
        }
        default: return sizeForKind(kind);
        }
    }

    QJsonObject toJson() const {
        QJsonObject o;
        o["id"]        = QString::number(id);
        o["kind"]      = kindToString(kind);
        o["name"]      = name;
        if (!structTypeName.isEmpty())
            o["structTypeName"] = structTypeName;
        if (!classKeyword.isEmpty() && classKeyword != QStringLiteral("struct"))
            o["classKeyword"] = classKeyword;
        o["parentId"]  = QString::number(parentId);
        o["offset"]    = offset;
        o["arrayLen"]  = arrayLen;
        o["strLen"]    = strLen;
        o["collapsed"] = collapsed;
        o["refId"]     = QString::number(refId);
        o["elementKind"] = kindToString(elementKind);
        if (ptrDepth > 0)
            o["ptrDepth"] = ptrDepth;
        if (!enumMembers.isEmpty()) {
            QJsonArray arr;
            for (const auto& m : enumMembers) {
                QJsonObject em;
                em["name"] = m.first;
                em["value"] = QString::number(m.second);
                arr.append(em);
            }
            o["enumMembers"] = arr;
        }
        return o;
    }
    static Node fromJson(const QJsonObject& o) {
        Node n;
        n.id        = o["id"].toString("0").toULongLong();
        n.kind      = kindFromString(o["kind"].toString());
        n.name      = o["name"].toString();
        n.structTypeName = o["structTypeName"].toString();
        n.classKeyword = o["classKeyword"].toString();
        n.parentId  = o["parentId"].toString("0").toULongLong();
        n.offset    = o["offset"].toInt(0);
        n.arrayLen  = qBound(1, o["arrayLen"].toInt(1), 1000000);
        n.strLen    = qBound(1, o["strLen"].toInt(64), 1000000);
        n.collapsed = o["collapsed"].toBool(false);
        n.refId     = o["refId"].toString("0").toULongLong();
        n.elementKind = kindFromString(o["elementKind"].toString("UInt8"));
        n.ptrDepth  = qBound(0, o["ptrDepth"].toInt(0), 2);
        if (o.contains("enumMembers")) {
            QJsonArray arr = o["enumMembers"].toArray();
            for (const auto& v : arr) {
                QJsonObject em = v.toObject();
                n.enumMembers.append({em["name"].toString(),
                                      em["value"].toString("0").toLongLong()});
            }
        }
        return n;
    }

    // Resolved class keyword (never empty)
    QString resolvedClassKeyword() const {
        return classKeyword.isEmpty() ? QStringLiteral("struct") : classKeyword;
    }

    // NOTE: isStringArray() was checking UInt8/UInt16 instead of UTF8/UTF16.
    // Currently unused — commented out until a caller needs it.
    // bool isStringArray() const {
    //     return kind == NodeKind::Array &&
    //            (elementKind == NodeKind::UTF8 || elementKind == NodeKind::UTF16);
    // }
};

// ── NodeTree ──

struct NodeTree {
    QVector<Node> nodes;
    uint64_t      baseAddress = 0x00400000;
    QString       baseAddressFormula;  // e.g. "<ReClass.exe> + 0x100"
    uint64_t      m_nextId    = 1;
    mutable QHash<uint64_t, int> m_idCache;

    int addNode(const Node& n) {
        Node copy = n;
        if (copy.id == 0) copy.id = m_nextId++;
        else if (copy.id >= m_nextId) m_nextId = copy.id + 1;
        int idx = nodes.size();
        nodes.append(copy);
        if (!m_idCache.isEmpty())
            m_idCache[copy.id] = idx;
        return idx;
    }

    // Reserve a unique ID atomically (for use before pushing undo commands)
    uint64_t reserveId() { return m_nextId++; }

    void invalidateIdCache() const { m_idCache.clear(); }

    int indexOfId(uint64_t id) const {
        if (m_idCache.isEmpty() && !nodes.isEmpty()) {
            for (int i = 0; i < nodes.size(); i++)
                m_idCache[nodes[i].id] = i;
        }
        return m_idCache.value(id, -1);
    }

    QVector<int> childrenOf(uint64_t parentId) const {
        QVector<int> result;
        for (int i = 0; i < nodes.size(); i++) {
            if (nodes[i].parentId == parentId) result.append(i);
        }
        return result;
    }

    // Collect node + all descendants (iterative, cycle-safe)
    QVector<int> subtreeIndices(uint64_t nodeId) const {
        int idx = indexOfId(nodeId);
        if (idx < 0) return {};
        // Build parent→children map
        QHash<uint64_t, QVector<int>> childMap;
        for (int i = 0; i < nodes.size(); i++)
            childMap[nodes[i].parentId].append(i);
        // BFS with visited guard
        QVector<int> result;
        QSet<uint64_t> visited;
        QVector<uint64_t> stack;
        stack.append(nodeId);
        result.append(idx);
        visited.insert(nodeId);
        while (!stack.isEmpty()) {
            uint64_t pid = stack.takeLast();
            for (int ci : childMap.value(pid)) {
                uint64_t cid = nodes[ci].id;
                if (!visited.contains(cid)) {
                    visited.insert(cid);
                    result.append(ci);
                    stack.append(cid);
                }
            }
        }
        return result;
    }

    int depthOf(int idx) const {
        int d = 0;
        QSet<uint64_t> visited;
        int cur = idx;
        while (cur >= 0 && cur < nodes.size() && nodes[cur].parentId != 0) {
            uint64_t nid = nodes[cur].id;
            if (visited.contains(nid)) break;
            visited.insert(nid);
            cur = indexOfId(nodes[cur].parentId);
            if (cur < 0) break;
            d++;
        }
        return d;
    }

    int64_t computeOffset(int idx) const {
        int64_t total = 0;
        QSet<uint64_t> visited;
        int cur = idx;
        while (cur >= 0 && cur < nodes.size()) {
            uint64_t nid = nodes[cur].id;
            if (visited.contains(nid)) break;
            visited.insert(nid);
            total += nodes[cur].offset;
            if (nodes[cur].parentId == 0) break;
            cur = indexOfId(nodes[cur].parentId);
        }
        return total;
    }

    int structSpan(uint64_t structId,
                   const QHash<uint64_t, QVector<int>>* childMap = nullptr,
                   QSet<uint64_t>* visited = nullptr) const {
        QSet<uint64_t> localVisited;
        if (!visited) visited = &localVisited;

        if (visited->contains(structId)) return 0;  // Cycle detected
        visited->insert(structId);

        int idx = indexOfId(structId);
        if (idx < 0) return 0;

        const Node& node = nodes[idx];
        int declaredSize = node.byteSize();

        int maxEnd = 0;
        QVector<int> kids = childMap ? childMap->value(structId) : childrenOf(structId);
        for (int ci : kids) {
            const Node& c = nodes[ci];
            int sz = (c.kind == NodeKind::Struct || c.kind == NodeKind::Array)
                ? structSpan(c.id, childMap, visited) : c.byteSize();
            int end = c.offset + sz;
            if (end > maxEnd) maxEnd = end;
        }

        // Embedded struct reference: no own children but refId points to a struct definition
        if (kids.isEmpty() && node.kind == NodeKind::Struct && node.refId != 0)
            maxEnd = qMax(maxEnd, structSpan(node.refId, childMap, visited));

        return qMax(declaredSize, maxEnd);
    }

    // Batch selection normalizers
    QSet<uint64_t> normalizePreferAncestors(const QSet<uint64_t>& ids) const;
    QSet<uint64_t> normalizePreferDescendants(const QSet<uint64_t>& ids) const;

    QJsonObject toJson() const {
        QJsonObject o;
        o["baseAddress"] = QString::number(baseAddress, 16);
        if (!baseAddressFormula.isEmpty())
            o["baseAddressFormula"] = baseAddressFormula;
        o["nextId"]      = QString::number(m_nextId);
        QJsonArray arr;
        for (const auto& n : nodes) arr.append(n.toJson());
        o["nodes"] = arr;
        return o;
    }

    static NodeTree fromJson(const QJsonObject& o) {
        NodeTree t;
        t.baseAddress = o["baseAddress"].toString("400000").toULongLong(nullptr, 16);
        t.baseAddressFormula = o["baseAddressFormula"].toString();
        t.m_nextId    = o["nextId"].toString("1").toULongLong();
        QJsonArray arr = o["nodes"].toArray();
        for (const auto& v : arr) {
            Node n = Node::fromJson(v.toObject());
            t.nodes.append(n);
            if (n.id >= t.m_nextId) t.m_nextId = n.id + 1;
        }
        return t;
    }

};

// ── Value History (ring buffer for heatmap) ──

struct ValueHistory {
    static constexpr int kCapacity = 10;
    std::array<QString, kCapacity> values;
    int count = 0;   // total unique values recorded
    int head  = 0;   // next write position in ring

    void record(const QString& v) {
        if (count > 0) {
            int last = (head + kCapacity - 1) % kCapacity;
            if (values[last] == v) return;  // no change
        }
        values[head] = v;
        head = (head + 1) % kCapacity;
        if (count < INT_MAX) count++;
    }

    int uniqueCount() const { return qMin(count, kCapacity); }

    // 0=static, 1=cold(2 unique), 2=warm(3-4), 3=hot(5+)
    int heatLevel() const {
        if (count <= 1) return 0;
        if (count == 2) return 1;
        if (count <= 4) return 2;
        return 3;
    }

    QString last() const {
        if (count == 0) return {};
        return values[(head + kCapacity - 1) % kCapacity];
    }

    // Iterate from oldest to newest (up to uniqueCount entries)
    template<typename Fn>
    void forEach(Fn&& fn) const {
        int n = uniqueCount();
        int start = (head + kCapacity - n) % kCapacity;
        for (int i = 0; i < n; i++)
            fn(values[(start + i) % kCapacity]);
    }
};

// ── LineMeta ──

enum class LineKind : uint8_t {
    CommandRow,   // line 0: source + address + root class type + name
    Blank,        // (unused — kept for enum stability)
    Header, Field, Continuation, Footer, ArrayElementSeparator
};

static constexpr uint64_t kCommandRowId   = UINT64_MAX;
static constexpr int      kCommandRowLine = 0;
static constexpr int      kFirstDataLine  = 1;
static constexpr uint64_t kFooterIdBit    = 0x8000000000000000ULL;
static constexpr uint64_t kArrayElemBit   = 0x4000000000000000ULL;  // marks array element selection
static constexpr uint64_t kArrayElemShift = 48;                     // bits 48-61 hold element index
static constexpr uint64_t kArrayElemMask  = 0x3FFF000000000000ULL;  // 14 bits → max 16383 elements

// Encode an array element selection ID: nodeId | kArrayElemBit | (elemIdx << 48)
inline uint64_t makeArrayElemSelId(uint64_t nodeId, int elemIdx) {
    return nodeId | kArrayElemBit | ((uint64_t)(elemIdx & 0x3FFF) << kArrayElemShift);
}
inline int arrayElemIdxFromSelId(uint64_t selId) {
    return (int)((selId & kArrayElemMask) >> kArrayElemShift);
}

struct LineMeta {
    int      nodeIdx        = -1;
    uint64_t nodeId         = 0;
    int      subLine        = 0;
    int      depth          = 0;
    int      foldLevel      = 0;
    bool     foldHead       = false;
    bool     foldCollapsed  = false;
    bool     isContinuation = false;
    bool     isRootHeader   = false;  // true for top-level struct headers (base address editable)
    bool     isArrayHeader  = false;  // true for array headers (has <idx/count> nav)
    LineKind lineKind       = LineKind::Field;
    NodeKind nodeKind       = NodeKind::Int32;
    NodeKind elementKind    = NodeKind::UInt8;  // Array element type
    int      arrayViewIdx   = 0;   // Array: current view index
    int      arrayCount     = 0;   // Array: total element count
    int      arrayElementIdx = -1; // Index of this element within parent array (-1 if not array element)
    QString  offsetText;
    uint64_t offsetAddr     = 0;     // Raw absolute address (for margin toggle)
    uint64_t ptrBase        = 0;     // Pointer expansion base (non-zero = use for RVA)
    uint32_t markerMask     = 0;
    bool     dataChanged    = false;  // true if any byte in this node changed since last refresh
    int      heatLevel      = 0;     // 0=static, 1=cold, 2=warm, 3=hot (from ValueHistory)
    QVector<int> changedByteIndices;  // Hex preview: which byte indices (0-based) changed on this line
    int      lineByteCount  = 0;     // Hex preview: actual data byte count on this line
    int      effectiveTypeW = 14;  // Per-line type column width used for rendering
    int      effectiveNameW = 22;  // Per-line name column width used for rendering
    QString  pointerTargetName;    // Resolved target type name for Pointer32/64 (empty = "void")
    bool     isArrayElement  = false;  // true for synthesized primitive array element lines
};

inline bool isSyntheticLine(const LineMeta& lm) {
    return lm.lineKind == LineKind::CommandRow;
}

// ── Layout Info ──

struct LayoutInfo {
    int typeW = 14;  // Effective type column width (default = kColType)
    int nameW = 22;  // Effective name column width (default = kColName)
    int offsetHexDigits = 8;  // Hex digits for offset margin (4/8/12/16)
    uint64_t baseAddress = 0; // Base address for relative offset computation
};

// ── ComposeResult ──

struct ComposeResult {
    QString            text;
    QVector<LineMeta>  meta;
    LayoutInfo         layout;
};

// ── Command ──

namespace cmd {
    struct OffsetAdj   { uint64_t nodeId; int oldOffset, newOffset; };
    struct ChangeKind  { uint64_t nodeId; NodeKind oldKind, newKind;
                         QVector<OffsetAdj> offAdjs; };
    struct Rename      { uint64_t nodeId; QString oldName, newName; };
    struct Collapse    { uint64_t nodeId; bool oldState, newState; };
    struct Insert      { Node node; QVector<OffsetAdj> offAdjs; };
    struct Remove      { uint64_t nodeId; QVector<Node> subtree;
                         QVector<OffsetAdj> offAdjs; };
    struct ChangeBase  { uint64_t oldBase, newBase; QString oldFormula, newFormula; };
    struct WriteBytes  { uint64_t addr; QByteArray oldBytes, newBytes; };
    struct ChangeArrayMeta { uint64_t nodeId;
                             NodeKind oldElementKind, newElementKind;
                             int oldArrayLen, newArrayLen; };
    struct ChangePointerRef { uint64_t nodeId;
                              uint64_t oldRefId, newRefId; };
    struct ChangeStructTypeName { uint64_t nodeId; QString oldName, newName; };
    struct ChangeClassKeyword { uint64_t nodeId; QString oldKeyword, newKeyword; };
    struct ChangeOffset { uint64_t nodeId; int oldOffset, newOffset; };
}

using Command = std::variant<
    cmd::ChangeKind, cmd::Rename, cmd::Collapse,
    cmd::Insert, cmd::Remove, cmd::ChangeBase, cmd::WriteBytes,
    cmd::ChangeArrayMeta, cmd::ChangePointerRef, cmd::ChangeStructTypeName,
    cmd::ChangeClassKeyword, cmd::ChangeOffset
>;

// ── Column spans (for inline editing) ──

struct ColumnSpan {
    int  start = 0;   // inclusive column index
    int  end   = 0;   // exclusive column index
    bool valid = false;
};

enum class EditTarget { Name, Type, Value, BaseAddress, Source, ArrayIndex, ArrayCount,
                        ArrayElementType, ArrayElementCount, PointerTarget,
                        RootClassType, RootClassName, TypeSelector };

// Column layout constants (shared with format.cpp span computation)
inline constexpr int kFoldCol     = 3;   // 3-char fold indicator prefix per line
inline constexpr int kColType     = 14;  // Max type column width (fits "uint64_t[999]")
inline constexpr int kColName     = 22;
inline constexpr int kColValue    = 96;
inline constexpr int kColComment  = 28;  // "// Enter=Save Esc=Cancel" fits
inline constexpr int kColBaseAddr = 12;  // "0x" + up to 10 hex digits (40-bit address)
inline constexpr int kSepWidth    = 1;
inline constexpr int kMinTypeW    = 8;   // Minimum type column width (fits "uint64_t")
inline constexpr int kMaxTypeW    = 128; // Maximum type column width
inline constexpr int kMinNameW    = 8;   // Minimum name column width (matches ASCII preview)
inline constexpr int kMaxNameW    = 128; // Maximum name column width
inline constexpr int kCompactTypeW    = 20; // Type column cap for compact column mode

inline ColumnSpan typeSpanFor(const LineMeta& lm, int typeW = kColType) {
    if (lm.lineKind != LineKind::Field || lm.isContinuation) return {};
    int ind = kFoldCol + lm.depth * 3;
    return {ind, ind + typeW, true};
}

inline ColumnSpan nameSpanFor(const LineMeta& lm, int typeW = kColType, int nameW = kColName) {
    if (lm.isContinuation || lm.lineKind != LineKind::Field) return {};

    int ind = kFoldCol + lm.depth * 3;
    int start = ind + typeW + kSepWidth;

    // Hex: ASCII preview occupies the name column (padded to nameW)
    if (isHexPreview(lm.nodeKind))
        return {start, start + nameW, true};

    return {start, start + nameW, true};
}

inline ColumnSpan valueSpanFor(const LineMeta& lm, int /*lineLength*/, int typeW = kColType, int nameW = kColName) {
    if (lm.lineKind == LineKind::Header || lm.lineKind == LineKind::Footer ||
        lm.lineKind == LineKind::ArrayElementSeparator) return {};
    int ind = kFoldCol + lm.depth * 3;

    // Hex uses nameW for ASCII column (same as regular name column)
    bool isHex = isHexPreview(lm.nodeKind);
    int valWidth = isHex ? 23 : kColValue;

    int prefixW = typeW + nameW + 2 * kSepWidth;

    if (lm.isContinuation) {
        int start = ind + prefixW;
        return {start, start + valWidth, true};
    }
    if (lm.lineKind != LineKind::Field) return {};

    int start = ind + prefixW;
    return {start, start + valWidth, true};
}

inline ColumnSpan commentSpanFor(const LineMeta& lm, int lineLength, int typeW = kColType, int nameW = kColName) {
    if (lm.lineKind == LineKind::Header || lm.lineKind == LineKind::Footer) return {};
    int ind = kFoldCol + lm.depth * 3;

    bool isHex = isHexPreview(lm.nodeKind);
    int valWidth = isHex ? 23 : kColValue;

    int prefixW = typeW + nameW + 2 * kSepWidth;
    int start;
    if (lm.isContinuation) {
        start = ind + prefixW + valWidth;
    } else {
        start = ind + prefixW + valWidth;
    }
    return {start, lineLength, start < lineLength};
}

// ── CommandRow spans ──
// Line format: "source▾ · 0x140000000"

inline ColumnSpan commandRowSrcSpan(const QString& lineText) {
    int idx = lineText.indexOf(QStringLiteral(" \u00B7"));
    if (idx < 0) return {};
    int start = 0;
    while (start < idx && !lineText[start].isLetterOrNumber()
           && lineText[start] != '<' && lineText[start] != '\'') start++;
    if (start >= idx) return {};
    // Exclude trailing ▾ from the editable span
    int end = idx;
    while (end > start && lineText[end - 1] == QChar(0x25BE)) end--;
    if (end <= start) return {};
    return {start, end, true};
}

inline ColumnSpan commandRowAddrSpan(const QString& lineText) {
    int tag = lineText.indexOf(QStringLiteral(" \u00B7"));
    if (tag < 0) return {};
    int start = tag + 3;  // after " · "
    // Scan to next " · " separator (or end of line) to support formulas with spaces
    int nextSep = lineText.indexOf(QStringLiteral(" \u00B7"), start);
    int end = (nextSep >= 0) ? nextSep : lineText.size();
    // Trim trailing whitespace
    while (end > start && lineText[end - 1].isSpace()) end--;
    if (end <= start) return {};
    return {start, end, true};
}

// ── CommandRow root-class spans ──
// Combined CommandRow format ends with: "  struct ClassName {"

inline int commandRowRootStart(const QString& lineText) {
    int best = -1;
    int i;
    // Match "struct " / "class " / "enum " as whole words before the class name
    i = lineText.lastIndexOf(QStringLiteral("struct "));
    if (i > best) best = i;
    i = lineText.lastIndexOf(QStringLiteral("class "));
    if (i > best) best = i;
    i = lineText.lastIndexOf(QStringLiteral("enum "));
    if (i > best) best = i;
    return best;
}

inline ColumnSpan commandRowRootTypeSpan(const QString& lineText) {
    int start = commandRowRootStart(lineText);
    if (start < 0) return {};
    int end = start;
    while (end < lineText.size() && lineText[end] != QChar(' ')) end++;
    if (end <= start) return {};
    return {start, end, true};
}

inline ColumnSpan commandRowRootNameSpan(const QString& lineText) {
    int base = commandRowRootStart(lineText);
    if (base < 0) return {};
    int space = lineText.indexOf(' ', base);
    if (space < 0) return {};
    int nameStart = space + 1;
    while (nameStart < lineText.size() && lineText[nameStart].isSpace()) nameStart++;
    if (nameStart >= lineText.size()) return {};
    int nameEnd = lineText.indexOf(QStringLiteral(" {"), nameStart);
    if (nameEnd < 0) nameEnd = lineText.size();
    while (nameEnd > nameStart && lineText[nameEnd - 1].isSpace()) nameEnd--;
    if (nameEnd <= nameStart) return {};
    return {nameStart, nameEnd, true};
}

// ── CommandRow type-selector chevron span ──
// Detects "[▸]" at the start of the command row text

inline ColumnSpan commandRowChevronSpan(const QString& lineText) {
    if (lineText.size() < 3) return {};
    if (lineText[0] == '[' && lineText[1] == QChar(0x25B8) && lineText[2] == ']')
        return {0, qMin(4, (int)lineText.size()), true};  // include trailing space for easier clicking
    return {};
}

// ── Array element type/count spans (within type column of array headers) ──
// Line format: "   int32_t[10]  name  {"
// arrayElemTypeSpan covers "int32_t", arrayElemCountSpan covers "10"

inline ColumnSpan arrayElemTypeSpanFor(const LineMeta& lm, const QString& lineText) {
    if (lm.lineKind != LineKind::Header || !lm.isArrayHeader) return {};
    int ind = kFoldCol + lm.depth * 3;
    // Find '[' in the type portion
    int bracket = lineText.indexOf('[', ind);
    if (bracket <= ind) return {};
    return {ind, bracket, true};
}

inline ColumnSpan arrayElemCountSpanFor(const LineMeta& lm, const QString& lineText) {
    if (lm.lineKind != LineKind::Header || !lm.isArrayHeader) return {};
    int ind = kFoldCol + lm.depth * 3;
    int openBracket = lineText.indexOf('[', ind);
    int closeBracket = lineText.indexOf(']', openBracket);
    if (openBracket < 0 || closeBracket < 0 || closeBracket <= openBracket + 1) return {};
    return {openBracket + 1, closeBracket, true};
}

// Click-area version: includes brackets [N] for hit testing
inline ColumnSpan arrayElemCountClickSpanFor(const LineMeta& lm, const QString& lineText) {
    if (lm.lineKind != LineKind::Header || !lm.isArrayHeader) return {};
    int ind = kFoldCol + lm.depth * 3;
    int openBracket = lineText.indexOf('[', ind);
    int closeBracket = lineText.indexOf(']', openBracket);
    if (openBracket < 0 || closeBracket < 0 || closeBracket <= openBracket + 1) return {};
    return {openBracket, closeBracket + 1, true};
}

// ── Pointer kind/target spans (within type column of pointer fields) ──
// Line format: "   void*          name  -> 0x..."
// pointerTargetSpan covers the target name before '*'

inline ColumnSpan pointerKindSpanFor(const LineMeta& /*lm*/, const QString& /*lineText*/) {
    return {};  // No separate kind span in "Type*" format
}

inline ColumnSpan pointerTargetSpanFor(const LineMeta& lm, const QString& lineText) {
    if ((lm.lineKind != LineKind::Field && lm.lineKind != LineKind::Header) || lm.isContinuation) return {};
    if (lm.nodeKind != NodeKind::Pointer32 && lm.nodeKind != NodeKind::Pointer64) return {};
    int ind = kFoldCol + lm.depth * 3;
    int star = lineText.indexOf('*', ind);
    if (star <= ind) return {};
    return {ind, star, true};
}

// ── Array navigation spans ──
// Line format: "uint32_t[16]  name  { <0/16>"

inline ColumnSpan arrayPrevSpanFor(const LineMeta& lm, const QString& lineText) {
    if (!lm.isArrayHeader) return {};
    int lt = lineText.lastIndexOf('<');
    if (lt < 0) return {};
    return {lt, lt + 1, true};
}

inline ColumnSpan arrayIndexSpanFor(const LineMeta& lm, const QString& lineText) {
    if (!lm.isArrayHeader) return {};
    int lt = lineText.lastIndexOf('<');
    int slash = lineText.indexOf('/', lt);
    if (lt < 0 || slash < 0) return {};
    return {lt + 1, slash, true};
}

inline ColumnSpan arrayCountSpanFor(const LineMeta& lm, const QString& lineText) {
    if (!lm.isArrayHeader) return {};
    int slash = lineText.lastIndexOf('/');
    int gt = lineText.indexOf('>', slash);
    if (slash < 0 || gt < 0) return {};
    return {slash + 1, gt, true};
}

inline ColumnSpan arrayNextSpanFor(const LineMeta& lm, const QString& lineText) {
    if (!lm.isArrayHeader) return {};
    int gt = lineText.lastIndexOf('>');
    if (gt < 0) return {};
    return {gt, gt + 1, true};
}

// ── ViewState ──

struct ViewState {
    int scrollLine = 0;
    int cursorLine = 0;
    int cursorCol  = 0;
    int xOffset    = 0;  // horizontal scroll in pixels
};

// ── Format function forward declarations ──

namespace fmt {
    using TypeNameFn = QString (*)(NodeKind);
    void setTypeNameProvider(TypeNameFn fn);
    QString typeName(NodeKind kind, int colType = kColType);
    QString typeNameRaw(NodeKind kind);  // Unpadded type name for width calculation
    QString fmtInt8(int8_t v);
    QString fmtInt16(int16_t v);
    QString fmtInt32(int32_t v);
    QString fmtInt64(int64_t v);
    QString fmtUInt8(uint8_t v);
    QString fmtUInt16(uint16_t v);
    QString fmtUInt32(uint32_t v);
    QString fmtUInt64(uint64_t v);
    QString fmtFloat(float v);
    QString fmtDouble(double v);
    QString fmtBool(uint8_t v);
    QString fmtPointer32(uint32_t v);
    QString fmtPointer64(uint64_t v);
    QString fmtNodeLine(const Node& node, const Provider& prov,
                        uint64_t addr, int depth, int subLine = 0,
                        const QString& comment = {}, int colType = kColType, int colName = kColName,
                        const QString& typeOverride = {}, bool compact = false);
    QString fmtOffsetMargin(uint64_t absoluteOffset, bool isContinuation, int hexDigits = 8);
    QString fmtStructHeader(const Node& node, int depth, bool collapsed, int colType = kColType, int colName = kColName, bool compact = false);
    QString fmtStructFooter(const Node& node, int depth, int totalSize = -1);
    QString fmtArrayHeader(const Node& node, int depth, int viewIdx, bool collapsed, int colType = kColType, int colName = kColName, const QString& elemStructName = {}, bool compact = false);
    QString structTypeName(const Node& node);  // Full type string for struct headers
    QString arrayTypeName(NodeKind elemKind, int count, const QString& structName = {});
    QString pointerTypeName(NodeKind kind, const QString& targetName);
    QString fmtPointerHeader(const Node& node, int depth, bool collapsed,
                             const Provider& prov, uint64_t addr,
                             const QString& ptrTypeName, int colType = kColType, int colName = kColName,
                             bool compact = false);
    QString validateBaseAddress(const QString& text);
    QString indent(int depth);
    QString readValue(const Node& node, const Provider& prov,
                      uint64_t addr, int subLine);
    QString editableValue(const Node& node, const Provider& prov,
                          uint64_t addr, int subLine);
    QByteArray parseValue(NodeKind kind, const QString& text, bool* ok);
    QByteArray parseAsciiValue(const QString& text, int expectedSize, bool* ok);
    QString validateValue(NodeKind kind, const QString& text);
    QString fmtEnumMember(const QString& name, int64_t value, int depth, int nameW);
} // namespace fmt

// ── Compose function forward declaration ──

ComposeResult compose(const NodeTree& tree, const Provider& prov, uint64_t viewRootId = 0,
                      bool compactColumns = false);

} // namespace rcx

```

`src/disasm.cpp`:

```cpp
#include "disasm.h"

extern "C" {
#include <fadec.h>
}

namespace rcx {

QString disassemble(const QByteArray& bytes, uint64_t baseAddr, int bitness, int maxBytes) {
    if (bytes.isEmpty() || (bitness != 32 && bitness != 64))
        return {};

    int len = qMin((int)bytes.size(), maxBytes);
    const auto* buf = reinterpret_cast<const uint8_t*>(bytes.constData());

    QString result;
    int off = 0;
    while (off < len) {
        FdInstr instr;
        int ret = fd_decode(buf + off, len - off, bitness, baseAddr + off, &instr);
        if (ret < 0)
            break;

        char fmtBuf[128];
        fd_format(&instr, fmtBuf, sizeof(fmtBuf));

        if (!result.isEmpty())
            result += QLatin1Char('\n');
        result += QStringLiteral("%1  %2")
            .arg(baseAddr + off, bitness == 64 ? 16 : 8, 16, QLatin1Char('0'))
            .arg(QString::fromLatin1(fmtBuf));

        off += ret;
    }
    return result;
}

QString hexDump(const QByteArray& bytes, uint64_t baseAddr, int maxBytes) {
    if (bytes.isEmpty())
        return {};

    int len = qMin((int)bytes.size(), maxBytes);
    QString result;

    for (int off = 0; off < len; off += 16) {
        int lineLen = qMin(16, len - off);

        if (!result.isEmpty())
            result += QLatin1Char('\n');

        // Address
        bool wide = (baseAddr + len > 0xFFFFFFFFULL);
        result += QStringLiteral("%1  ").arg(baseAddr + off, wide ? 16 : 8, 16, QLatin1Char('0'));

        // Hex bytes
        for (int i = 0; i < 16; i++) {
            if (i < lineLen) {
                uint8_t b = static_cast<uint8_t>(bytes[off + i]);
                result += QStringLiteral("%1 ").arg(b, 2, 16, QLatin1Char('0'));
            } else {
                result += QStringLiteral("   ");
            }
            if (i == 7) result += QLatin1Char(' ');
        }

        // ASCII
        result += QLatin1Char(' ');
        for (int i = 0; i < lineLen; i++) {
            char c = bytes[off + i];
            result += (c >= 0x20 && c < 0x7f) ? QLatin1Char(c) : QLatin1Char('.');
        }
    }
    return result;
}

} // namespace rcx

```

`src/disasm.h`:

```h
#pragma once
#include <QString>
#include <QByteArray>
#include <cstdint>

namespace rcx {

// Disassemble up to maxBytes of x86 code, returning formatted asm lines.
// bitness: 32 or 64. Returns one line per instruction, prefixed with offset.
QString disassemble(const QByteArray& bytes, uint64_t baseAddr, int bitness, int maxBytes = 128);

// Format bytes as hex dump lines (16 bytes per line with ASCII sidebar).
QString hexDump(const QByteArray& bytes, uint64_t baseAddr, int maxBytes = 128);

} // namespace rcx

```

`src/editor.cpp`:

```cpp
#include "editor.h"
#include "disasm.h"
#include "providerregistry.h"
#include <QDebug>
#include <Qsci/qsciscintilla.h>
#include <Qsci/qsciscintillabase.h>
#include <Qsci/qscilexercpp.h>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFont>
#include <QColor>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QFocusEvent>
#include <QTimer>
#include <QCursor>
#include <QMenu>
#include <QApplication>
#include <QClipboard>
#include <QLabel>
#include <QToolButton>
#include <QScreen>
#include <QScrollBar>
#include <functional>
#include "themes/thememanager.h"

namespace rcx {

// Forward declaration (defined below, after RcxEditor constructor)
static QString getLineText(QsciScintilla* sci, int line);

// ── Value history popup (styled like TypeSelectorPopup) ──

class ValueHistoryPopup : public QFrame {
    uint64_t m_nodeId = 0;
    bool     m_hasButtons = false;
    QStringList m_values;
    QVector<QLabel*> m_labels;
    std::function<void(const QString&)> m_onSet;
public:
    explicit ValueHistoryPopup(QWidget* parent)
        : QFrame(parent, Qt::ToolTip | Qt::FramelessWindowHint)
    {
        setAttribute(Qt::WA_DeleteOnClose, false);
        setAttribute(Qt::WA_ShowWithoutActivating, true);
        setFrameShape(QFrame::NoFrame);
        setAutoFillBackground(true);
    }

    uint64_t nodeId() const { return m_nodeId; }
    void setOnSet(std::function<void(const QString&)> fn) { m_onSet = std::move(fn); }

    void populate(uint64_t nodeId, const ValueHistory& hist, const QFont& font,
                  bool showButtons = false) {
        QStringList vals;
        hist.forEach([&](const QString& v) { vals.append(v); });

        if (nodeId == m_nodeId && vals == m_values
            && showButtons == m_hasButtons && isVisible())
            return;

        // In-place label update when structure unchanged (avoids flicker)
        if (nodeId == m_nodeId && vals.size() == m_values.size()
            && vals.size() == m_labels.size()
            && showButtons == m_hasButtons && isVisible()) {
            for (int i = 0; i < vals.size(); i++)
                m_labels[i]->setText(vals[i]);
            m_values = vals;
            return;
        }

        m_nodeId = nodeId;
        m_values = vals;
        m_hasButtons = showButtons;
        m_labels.clear();

        delete layout();
        qDeleteAll(findChildren<QWidget*>(QString(), Qt::FindDirectChildrenOnly));

        const auto& theme = ThemeManager::instance().current();
        QPalette pal;
        pal.setColor(QPalette::Window, theme.backgroundAlt);
        pal.setColor(QPalette::WindowText, theme.text);
        setPalette(pal);

        auto* vbox = new QVBoxLayout(this);
        vbox->setContentsMargins(8, 6, 8, 6);
        vbox->setSpacing(2);

        auto* title = new QLabel(QStringLiteral("Previous Values"));
        QFont bold = font;
        bold.setBold(true);
        title->setFont(bold);
        title->setStyleSheet(QStringLiteral("color: %1;").arg(theme.text.name()));
        vbox->addWidget(title);

        auto* sep = new QFrame;
        sep->setFrameShape(QFrame::HLine);
        sep->setFrameShadow(QFrame::Plain);
        sep->setFixedHeight(1);
        QPalette sp; sp.setColor(QPalette::WindowText, theme.border);
        sep->setPalette(sp);
        vbox->addWidget(sep);

        for (const QString& v : vals) {
            auto* row = new QHBoxLayout;
            row->setContentsMargins(0, 1, 0, 1);
            row->setSpacing(8);

            auto* label = new QLabel(v);
            label->setFont(font);
            label->setStyleSheet(QStringLiteral("color: %1;").arg(theme.syntaxNumber.name()));
            row->addWidget(label, 1);
            m_labels.append(label);

            if (showButtons) {
                auto* setBtn = new QToolButton;
                setBtn->setText(QStringLiteral("Set"));
                setBtn->setAutoRaise(true);
                setBtn->setCursor(Qt::PointingHandCursor);
                setBtn->setFont(font);
                setBtn->setStyleSheet(QStringLiteral(
                    "QToolButton { color: %1; border: none; padding: 1px 4px; }"
                    "QToolButton:hover { color: %2; background: %3; }")
                    .arg(theme.textDim.name(), theme.text.name(), theme.hover.name()));
                QString val = v;
                QObject::connect(setBtn, &QToolButton::clicked, [this, val]() {
                    if (m_onSet) m_onSet(val);
                });
                row->addWidget(setBtn);
            }
            vbox->addLayout(row);
        }

        adjustSize();
    }

    void showAt(const QPoint& globalPos) {
        QSize sz = sizeHint();
        QRect screen = QApplication::screenAt(globalPos)
            ? QApplication::screenAt(globalPos)->availableGeometry()
            : QRect(0, 0, 1920, 1080);
        int x = qMin(globalPos.x(), screen.right() - sz.width());
        int y = globalPos.y();
        if (y + sz.height() > screen.bottom())
            y = globalPos.y() - sz.height() - 4;
        move(x, y);
        if (!isVisible()) show();
    }

    void dismiss() {
        if (isVisible()) hide();
        m_nodeId = 0;
        m_values.clear();
        m_labels.clear();
    }
};

// ── Disassembly / hex-dump hover popup ──

class DisasmPopup : public QFrame {
    uint64_t m_nodeId = 0;
    QString  m_body;
    QLabel*  m_titleLabel = nullptr;
    QLabel*  m_bodyLabel  = nullptr;
public:
    explicit DisasmPopup(QWidget* parent)
        : QFrame(parent, Qt::ToolTip | Qt::FramelessWindowHint)
    {
        setAttribute(Qt::WA_DeleteOnClose, false);
        setAttribute(Qt::WA_ShowWithoutActivating, true);
        setFrameShape(QFrame::NoFrame);
        setAutoFillBackground(true);

        auto* vbox = new QVBoxLayout(this);
        vbox->setContentsMargins(8, 6, 8, 6);
        vbox->setSpacing(2);

        m_titleLabel = new QLabel;
        QFont bold = m_titleLabel->font();
        bold.setBold(true);
        m_titleLabel->setFont(bold);
        vbox->addWidget(m_titleLabel);

        auto* sep = new QFrame;
        sep->setFrameShape(QFrame::HLine);
        sep->setFrameShadow(QFrame::Plain);
        sep->setFixedHeight(1);
        vbox->addWidget(sep);

        m_bodyLabel = new QLabel;
        m_bodyLabel->setTextFormat(Qt::PlainText);
        m_bodyLabel->setWordWrap(false);
        vbox->addWidget(m_bodyLabel);
    }

    uint64_t nodeId() const { return m_nodeId; }

    void populate(uint64_t nodeId, const QString& title, const QString& body,
                  const QFont& font) {
        if (nodeId == m_nodeId && body == m_body && isVisible())
            return;

        m_nodeId = nodeId;
        m_body = body;

        const auto& theme = ThemeManager::instance().current();
        QPalette pal;
        pal.setColor(QPalette::Window, theme.backgroundAlt);
        pal.setColor(QPalette::WindowText, theme.text);
        setPalette(pal);

        QFont bold = font;
        bold.setBold(true);
        m_titleLabel->setFont(bold);
        m_titleLabel->setText(title);
        m_titleLabel->setStyleSheet(
            QStringLiteral("color: %1;").arg(theme.text.name()));

        // Find and style the separator
        for (auto* child : findChildren<QFrame*>()) {
            if (child->frameShape() == QFrame::HLine) {
                QPalette sp;
                sp.setColor(QPalette::WindowText, theme.border);
                child->setPalette(sp);
                break;
            }
        }

        m_bodyLabel->setFont(font);
        m_bodyLabel->setText(body);
        m_bodyLabel->setStyleSheet(
            QStringLiteral("color: %1;").arg(theme.syntaxNumber.name()));

        setMaximumWidth(600);
        adjustSize();
    }

    void showAt(const QPoint& globalPos) {
        QSize sz = sizeHint();
        QRect screen = QApplication::screenAt(globalPos)
            ? QApplication::screenAt(globalPos)->availableGeometry()
            : QRect(0, 0, 1920, 1080);
        int x = qMin(globalPos.x(), screen.right() - sz.width());
        int y = globalPos.y();
        if (y + sz.height() > screen.bottom())
            y = globalPos.y() - sz.height() - 4;
        move(x, y);
        if (!isVisible()) show();
    }

    void dismiss() {
        if (isVisible()) hide();
        m_nodeId = 0;
        m_body.clear();
    }
};

class StructPreviewPopup : public QFrame {
    uint64_t m_nodeId = 0;
    QString  m_body;
    QLabel*  m_titleLabel = nullptr;
    QLabel*  m_bodyLabel  = nullptr;
public:
    explicit StructPreviewPopup(QWidget* parent)
        : QFrame(parent, Qt::ToolTip | Qt::FramelessWindowHint)
    {
        setAttribute(Qt::WA_DeleteOnClose, false);
        setAttribute(Qt::WA_ShowWithoutActivating, true);
        setFrameShape(QFrame::NoFrame);
        setAutoFillBackground(true);

        auto* vbox = new QVBoxLayout(this);
        vbox->setContentsMargins(8, 6, 8, 6);
        vbox->setSpacing(2);

        m_titleLabel = new QLabel;
        QFont bold = m_titleLabel->font();
        bold.setBold(true);
        m_titleLabel->setFont(bold);
        vbox->addWidget(m_titleLabel);

        auto* sep = new QFrame;
        sep->setFrameShape(QFrame::HLine);
        sep->setFrameShadow(QFrame::Plain);
        sep->setFixedHeight(1);
        vbox->addWidget(sep);

        m_bodyLabel = new QLabel;
        m_bodyLabel->setTextFormat(Qt::PlainText);
        m_bodyLabel->setWordWrap(false);
        vbox->addWidget(m_bodyLabel);
    }

    uint64_t nodeId() const { return m_nodeId; }

    void populate(uint64_t nodeId, const QString& title, const QString& body,
                  const QFont& font) {
        if (nodeId == m_nodeId && body == m_body && isVisible())
            return;

        m_nodeId = nodeId;
        m_body = body;

        const auto& theme = ThemeManager::instance().current();
        QPalette pal;
        pal.setColor(QPalette::Window, theme.backgroundAlt);
        pal.setColor(QPalette::WindowText, theme.text);
        setPalette(pal);

        QFont bold = font;
        bold.setBold(true);
        m_titleLabel->setFont(bold);
        m_titleLabel->setText(title);
        m_titleLabel->setStyleSheet(
            QStringLiteral("color: %1;").arg(theme.text.name()));

        for (auto* child : findChildren<QFrame*>()) {
            if (child->frameShape() == QFrame::HLine) {
                QPalette sp;
                sp.setColor(QPalette::WindowText, theme.border);
                child->setPalette(sp);
                break;
            }
        }

        m_bodyLabel->setFont(font);
        m_bodyLabel->setText(body);
        m_bodyLabel->setStyleSheet(
            QStringLiteral("color: %1;").arg(theme.text.name()));

        setMaximumWidth(600);
        adjustSize();
    }

    void showAt(const QPoint& globalPos) {
        QSize sz = sizeHint();
        QRect screen = QApplication::screenAt(globalPos)
            ? QApplication::screenAt(globalPos)->availableGeometry()
            : QRect(0, 0, 1920, 1080);
        int x = qMin(globalPos.x(), screen.right() - sz.width());
        int y = globalPos.y();
        if (y + sz.height() > screen.bottom())
            y = globalPos.y() - sz.height() - 4;
        move(x, y);
        if (!isVisible()) show();
    }

    void dismiss() {
        if (isVisible()) hide();
        m_nodeId = 0;
        m_body.clear();
    }
};

static constexpr int IND_EDITABLE   = 8;
static constexpr int IND_HEX_DIM    = 9;
static constexpr int IND_BASE_ADDR  = 10;  // Default text color override for command row address
static constexpr int IND_HOVER_SPAN = 11;  // Blue text on hover (link-like)
static constexpr int IND_CMD_PILL   = 12;  // Rounded chip behind command row spans
static constexpr int IND_HEAT_COLD    = 13; // Heatmap level 1 (changed once)
static constexpr int IND_CLASS_NAME   = 14; // Teal text for root class name
static constexpr int IND_HINT_GREEN   = 15; // Green text for hint/comment text
static constexpr int IND_LOCAL_OFF    = 16; // Dim text for inline local offset in relative mode
static constexpr int IND_HEAT_WARM    = 17; // Heatmap level 2 (moderate changes)
static constexpr int IND_HEAT_HOT     = 18; // Heatmap level 3 (frequent changes)

static QString g_fontName = "JetBrains Mono";

static QFont editorFont() {
    QFont f(g_fontName, 12);
    f.setFixedPitch(true);
    return f;
}

RcxEditor::RcxEditor(QWidget* parent) : QWidget(parent) {
    auto* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);

    m_sci = new QsciScintilla(this);
    layout->addWidget(m_sci);

    setupScintilla();
    setupLexer();
    setupMargins();
    setupFolding();
    setupMarkers();
    allocateMarginStyles();

    applyTheme(ThemeManager::instance().current());
    connect(&ThemeManager::instance(), &ThemeManager::themeChanged,
            this, &RcxEditor::applyTheme);

    m_sci->installEventFilter(this);
    m_sci->viewport()->installEventFilter(this);
    m_sci->viewport()->setMouseTracking(true);

    // Recalculate hover when the viewport scrolls (scrollbar drag, wheel
    // deceleration, etc.) so the highlight tracks whatever is under the cursor.
    connect(m_sci->verticalScrollBar(), &QScrollBar::valueChanged,
            this, [this]() {
        if (m_editState.active || !m_hoverInside) return;
        m_lastHoverPos = m_sci->viewport()->mapFromGlobal(QCursor::pos());
        m_hoverInside = m_sci->viewport()->rect().contains(m_lastHoverPos);
        auto h = hitTest(m_lastHoverPos);
        uint64_t newHoverId = (m_hoverInside && h.line >= 0) ? h.nodeId : 0;
        int newHoverLine = (m_hoverInside && h.line >= 0) ? h.line : -1;
        if (newHoverId != m_hoveredNodeId || newHoverLine != m_hoveredLine) {
            m_hoveredNodeId = newHoverId;
            m_hoveredLine = newHoverLine;
            applyHoverHighlight();
        }
        applyHoverCursor();
    });

    // Hover cursor is applied synchronously in eventFilter (no timer).

    connect(m_sci, &QsciScintilla::marginClicked,
            this, [this](int margin, int line, Qt::KeyboardModifiers mods) {
        emit marginClicked(margin, line, mods);
    });

    m_sci->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_sci, &QWidget::customContextMenuRequested,
            this, [this](const QPoint& pos) {
        // Right-click on offset margin → show margin mode menu
        int margin0Width = (int)m_sci->SendScintilla(
            QsciScintillaBase::SCI_GETMARGINWIDTHN, 0UL, 0L);
        if (pos.x() < margin0Width) {
            QMenu menu;
            auto* actRel = menu.addAction("Relative Offsets (+0x)");
            auto* actAbs = menu.addAction("Absolute Addresses");
            actRel->setCheckable(true);
            actAbs->setCheckable(true);
            actRel->setChecked(m_relativeOffsets);
            actAbs->setChecked(!m_relativeOffsets);
            QAction* chosen = menu.exec(m_sci->mapToGlobal(pos));
            if (chosen == actRel && !m_relativeOffsets) {
                m_relativeOffsets = true;
                reformatMargins();
            } else if (chosen == actAbs && m_relativeOffsets) {
                m_relativeOffsets = false;
                reformatMargins();
            }
            return;
        }
        HitInfo hi = hitTest(pos);
        int line = hi.line;

        // Right-click on command row keyword → show conversion menu
        if (line == 0 && hi.col >= 0 && !m_meta.isEmpty()
            && m_meta[0].lineKind == LineKind::CommandRow) {
            QString lineText = getLineText(m_sci, 0);
            ColumnSpan rts = commandRowRootTypeSpan(lineText);
            if (rts.valid && hi.col >= rts.start && hi.col < rts.end) {
                // Extract current keyword from span text
                QString kw = lineText.mid(rts.start, rts.end - rts.start).trimmed();
                QMenu menu;
                if (kw == QStringLiteral("class"))
                    menu.addAction("Convert to Struct");
                else if (kw == QStringLiteral("struct"))
                    menu.addAction("Convert to Class");
                // enum: no conversion options
                if (!menu.isEmpty()) {
                    QAction* chosen = menu.exec(m_sci->mapToGlobal(pos));
                    if (chosen) {
                        QString newKw = chosen->text().contains("Class")
                            ? QStringLiteral("class") : QStringLiteral("struct");
                        emit keywordConvertRequested(newKw);
                    }
                }
                return;
            }
        }

        int nodeIdx = -1;
        int subLine = 0;
        if (line >= 0 && line < m_meta.size()) {
            nodeIdx = m_meta[line].nodeIdx;
            subLine = m_meta[line].subLine;
        }
        emit contextMenuRequested(line, nodeIdx, subLine, m_sci->mapToGlobal(pos));
    });

    connect(m_sci, &QsciScintilla::userListActivated,
            this, [this](int id, const QString& text) {
        if (!m_editState.active) return;
        if (id == 1 && (m_editState.target == EditTarget::Type
                     || m_editState.target == EditTarget::ArrayElementType
                     || m_editState.target == EditTarget::PointerTarget)) {
            const LineMeta* lm = metaForLine(m_editState.line);
            uint64_t addr = lm ? lm->offsetAddr : 0;
            auto info = endInlineEdit();
            emit inlineEditCommitted(info.nodeIdx, info.subLine, info.target, text, addr);
        }
    });

    connect(m_sci, &QsciScintilla::cursorPositionChanged,
            this, [this](int line, int /*col*/) { updateEditableIndicators(line); });

    connect(m_sci, &QsciScintilla::textChanged, this, [this]() {
        if (!m_editState.active) return;
        if (m_updatingComment) return;  // Skip queuing during comment update
        if (m_editState.target == EditTarget::Value)
            QTimer::singleShot(0, this, &RcxEditor::validateEditLive);
    });

    connect(m_sci, &QsciScintilla::selectionChanged,
            this, &RcxEditor::clampEditSelection);
}

RcxEditor::~RcxEditor() {
}

void RcxEditor::setupScintilla() {
    m_sci->setFont(editorFont());

    m_sci->setReadOnly(true);
    m_sci->setWrapMode(QsciScintilla::WrapNone);
    m_sci->setCaretLineVisible(false);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETCARETWIDTH, 0);

    // Arrow cursor by default — not the I-beam (this is a structured viewer, not a text editor)
    m_sci->viewport()->setCursor(Qt::ArrowCursor);

    m_sci->setTabWidth(2);
    m_sci->setIndentationsUseTabs(false);

    // Line spacing for readability
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETEXTRAASCENT, (long)2);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETEXTRADESCENT, (long)2);

    // Disable native selection rendering — we use markers for selection
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSELFORE, (long)0, (long)0);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSELBACK, (long)0, (long)0);

    // Horizontal scrollbar: sized explicitly in applyDocument() to match content
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSCROLLWIDTHTRACKING, 0);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSCROLLWIDTH, 1);

    // Vertical scrollbar: don't allow scrolling past the last line
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETENDATLASTLINE, 1);

    // Editable-field indicator - HIDDEN (no visual)
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_EDITABLE, 5 /*INDIC_HIDDEN*/);

    // Hex node dim indicator — overrides text color
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_HEX_DIM, 17 /*INDIC_TEXTFORE*/);

    // Base address indicator — text color override on command row
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_BASE_ADDR, 17 /*INDIC_TEXTFORE*/);

    // Hover span indicator — link-like text
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_HOVER_SPAN, 17 /*INDIC_TEXTFORE*/);

    // Command-row pill background
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_CMD_PILL, 8 /*INDIC_STRAIGHTBOX*/);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETALPHA,
                         IND_CMD_PILL, (long)100);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETUNDER,
                         IND_CMD_PILL, (long)1);

    // Heatmap indicators (cold / warm / hot)
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_HEAT_COLD, 17 /*INDIC_TEXTFORE*/);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_HEAT_WARM, 17 /*INDIC_TEXTFORE*/);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_HEAT_HOT, 17 /*INDIC_TEXTFORE*/);

    // Root class name — type color
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_CLASS_NAME, 17 /*INDIC_TEXTFORE*/);

    // Green text for hint/comment annotations
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_HINT_GREEN, 17 /*INDIC_TEXTFORE*/);

    // Local offset text color (dim, like margin text)
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETSTYLE,
                         IND_LOCAL_OFF, 17 /*INDIC_TEXTFORE*/);

}

void RcxEditor::setupLexer() {
    m_lexer = new QsciLexerCPP(m_sci);
    QFont font = editorFont();
    m_lexer->setFont(font);
    for (int i = 0; i <= 127; i++)
        m_lexer->setFont(font, i);

    m_sci->setLexer(m_lexer);
    m_sci->setBraceMatching(QsciScintilla::NoBraceMatch);  // Disable - this is a structured viewer

    // Add built-in type names to keyword set 1 → blue coloring
    QByteArray kw2 = allTypeNamesForUI(/*stripBrackets=*/true).join(' ').toLatin1();
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETKEYWORDS,
                         (uintptr_t)1, kw2.constData());
}

void RcxEditor::setCustomTypeNames(const QStringList& names) {
    m_customTypeNames = names;
    QByteArray kw = names.join(' ').toLatin1();
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETKEYWORDS,
                         (uintptr_t)3, kw.constData());
}

void RcxEditor::setupMargins() {
    m_sci->setMarginsFont(editorFont());

    // Margin 0: Offset text
    m_sci->setMarginType(0, QsciScintilla::TextMarginRightJustified);
    m_sci->setMarginWidth(0, "  00000000  ");  // default 8-digit; resized dynamically in applyDocument()
    m_sci->setMarginSensitivity(0, true);

    // Margin 1: 2px accent bar (selection indicator)
    m_sci->setMarginType(1, QsciScintilla::SymbolMargin);
    m_sci->setMarginWidth(1, 2);
    m_sci->setMarginSensitivity(1, false);
    m_sci->setMarginMarkerMask(1, 1 << M_ACCENT);
}

void RcxEditor::setupFolding() {
    // Hide fold margin (fold indicators are text-based now)
    m_sci->setMarginWidth(2, 0);

    // Fold indicators are now text in the line content (kFoldCol prefix),
    // so no Scintilla markers needed for fold state.

    // Keep Scintilla fold markers invisible (fold levels still used for click detection)
    for (int i = 25; i <= 31; i++)
        m_sci->markerDefine(QsciScintilla::Invisible, i);

    // Disable automatic fold toggle — we handle collapse at model level
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETAUTOMATICFOLD,
                         (unsigned long)0);

    // Disable lexer-driven folding — we set fold levels manually
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETPROPERTY,
                         (const char*)"fold", (const char*)"0");
}

void RcxEditor::setupMarkers() {
    // M_CONT (0): continuation line (metadata only, no visual)
    m_sci->markerDefine(QsciScintilla::Invisible, M_CONT);

    // M_PTR0 (2): right triangle
    m_sci->markerDefine(QsciScintilla::RightTriangle, M_PTR0);

    // M_CYCLE (3): arrows
    m_sci->markerDefine(QsciScintilla::ThreeRightArrows, M_CYCLE);

    // M_ERR (4): background
    m_sci->markerDefine(QsciScintilla::Background, M_ERR);

    // M_STRUCT_BG (5): struct header/footer
    m_sci->markerDefine(QsciScintilla::Background, M_STRUCT_BG);

    // M_HOVER (6): full-row hover highlight
    m_sci->markerDefine(QsciScintilla::Background, M_HOVER);

    // M_SELECTED (7): full-row selection highlight
    m_sci->markerDefine(QsciScintilla::Background, M_SELECTED);

    // M_CMD_ROW (8): distinct background for CommandRow bar
    m_sci->markerDefine(QsciScintilla::Background, M_CMD_ROW);

    // M_ACCENT (9): 2px accent bar in margin 1 (selection indicator)
    m_sci->markerDefine(QsciScintilla::FullRectangle, M_ACCENT);
}

void RcxEditor::allocateMarginStyles() {
    static constexpr int MSTYLE_NORMAL = 0;
    static constexpr int MSTYLE_CONT   = 1;

    long base = m_sci->SendScintilla(QsciScintillaBase::SCI_ALLOCATEEXTENDEDSTYLES, (long)2);
    m_marginStyleBase = (int)base;
    m_sci->SendScintilla(QsciScintillaBase::SCI_MARGINSETSTYLEOFFSET, base);

    QByteArray fontName = editorFont().family().toUtf8();
    int fontSize = editorFont().pointSize();

    for (int s = MSTYLE_NORMAL; s <= MSTYLE_CONT; s++) {
        unsigned long abs = (unsigned long)(base + s);
        m_sci->SendScintilla(QsciScintillaBase::SCI_STYLESETFONT,
                             (uintptr_t)abs, fontName.constData());
        m_sci->SendScintilla(QsciScintillaBase::SCI_STYLESETSIZE, abs, (long)fontSize);
    }
}

void RcxEditor::applyTheme(const Theme& theme) {
    // Paper and text
    m_sci->setPaper(theme.background);
    m_sci->setColor(theme.text);
    m_sci->setCaretForegroundColor(theme.text);

    // Indicator colors
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_HEX_DIM, theme.textFaint);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_BASE_ADDR, theme.text);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_HOVER_SPAN, theme.indHoverSpan);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_CMD_PILL, theme.indCmdPill);
    // Heatmap colors
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_HEAT_COLD, theme.indHeatCold);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_HEAT_WARM, theme.indHeatWarm);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_HEAT_HOT, theme.indHeatHot);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_CLASS_NAME, theme.syntaxType);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_HINT_GREEN, theme.indHintGreen);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICSETFORE,
                         IND_LOCAL_OFF, theme.textFaint);

    // Lexer colors
    m_lexer->setColor(theme.syntaxKeyword, QsciLexerCPP::Keyword);
    m_lexer->setColor(theme.syntaxKeyword, QsciLexerCPP::KeywordSet2);
    m_lexer->setColor(theme.syntaxNumber, QsciLexerCPP::Number);
    m_lexer->setColor(theme.syntaxString, QsciLexerCPP::DoubleQuotedString);
    m_lexer->setColor(theme.syntaxString, QsciLexerCPP::SingleQuotedString);
    m_lexer->setColor(theme.syntaxComment, QsciLexerCPP::Comment);
    m_lexer->setColor(theme.syntaxComment, QsciLexerCPP::CommentLine);
    m_lexer->setColor(theme.syntaxComment, QsciLexerCPP::CommentDoc);
    m_lexer->setColor(theme.text, QsciLexerCPP::Default);
    m_lexer->setColor(theme.text, QsciLexerCPP::Identifier);
    m_lexer->setColor(theme.syntaxPreproc, QsciLexerCPP::PreProcessor);
    m_lexer->setColor(theme.text, QsciLexerCPP::Operator);
    m_lexer->setColor(theme.syntaxType, QsciLexerCPP::GlobalClass);
    for (int i = 0; i <= 127; i++)
        m_lexer->setPaper(theme.background, i);

    // Margins
    m_sci->setMarginsBackgroundColor(theme.background);
    m_sci->setMarginsForegroundColor(theme.textFaint);
    m_sci->setFoldMarginColors(theme.background, theme.background);

    // Markers
    m_sci->setMarkerBackgroundColor(theme.markerPtr, M_PTR0);
    m_sci->setMarkerForegroundColor(theme.markerPtr, M_PTR0);
    m_sci->setMarkerBackgroundColor(theme.markerCycle, M_CYCLE);
    m_sci->setMarkerForegroundColor(theme.markerCycle, M_CYCLE);
    m_sci->setMarkerBackgroundColor(theme.markerError, M_ERR);
    m_sci->setMarkerForegroundColor(QColor("#ffffff"), M_ERR);
    m_sci->setMarkerBackgroundColor(theme.background, M_STRUCT_BG);
    m_sci->setMarkerForegroundColor(theme.text, M_STRUCT_BG);
    m_sci->setMarkerBackgroundColor(theme.hover, M_HOVER);
    m_sci->setMarkerBackgroundColor(theme.selected, M_SELECTED);
    m_sci->setMarkerBackgroundColor(theme.background, M_CMD_ROW);
    m_sci->setMarkerBackgroundColor(theme.indHoverSpan, M_ACCENT);

    // Margin extended styles
    if (m_marginStyleBase >= 0) {
        long base = m_marginStyleBase;
        for (int s = 0; s <= 1; s++) {
            unsigned long abs = (unsigned long)(base + s);
            m_sci->SendScintilla(QsciScintillaBase::SCI_STYLESETFORE,
                                 abs, theme.textFaint);
            m_sci->SendScintilla(QsciScintillaBase::SCI_STYLESETBACK,
                                 abs, theme.background);
        }
    }
}

void RcxEditor::applyDocument(const ComposeResult& result) {
    // Silently deactivate inline edit (no signal — refresh is already happening)
    if (m_editState.active)
        endInlineEdit();

    // Guard: suppress popup dismiss during setText() which fires synthetic Leave events
    m_applyingDocument = true;

    // Save hover state — setText() triggers viewport Leave events that would clear it
    uint64_t savedHoverId = m_hoveredNodeId;
    int savedHoverLine = m_hoveredLine;
    bool savedHoverInside = m_hoverInside;

    m_meta = result.meta;
    m_layout = result.layout;

    // Build nodeId → display-line index for O(1) hover/selection lookup
    m_nodeLineIndex.clear();
    m_nodeLineIndex.reserve(m_meta.size());
    for (int i = 0; i < m_meta.size(); i++) {
        if (m_meta[i].nodeId != 0)
            m_nodeLineIndex[m_meta[i].nodeId].append(i);
    }

    // Dynamically resize margin to fit the current hex digit tier
    QString marginSizer = QString("  %1  ").arg(QString(m_layout.offsetHexDigits, '0'));
    m_sci->setMarginWidth(0, marginSizer);

    m_sci->setReadOnly(false);
    m_sci->setText(result.text);
    m_sci->setReadOnly(true);

    // Set horizontal scroll width to match the longest line (ignoring trailing spaces)
    {
        int maxLen = 0;
        const QStringList lines = result.text.split(QChar('\n'));
        for (const auto& line : lines) {
            int len = line.size();
            while (len > 0 && line[len - 1] == QChar(' ')) --len;
            if (len > maxLen) maxLen = len;
        }
        QFontMetrics fm(editorFont());
        int pixelWidth = fm.horizontalAdvance(QString(maxLen, QChar('0')));
        m_sci->SendScintilla(QsciScintillaBase::SCI_SETSCROLLWIDTH,
                             (unsigned long)qMax(1, pixelWidth));

        // Reset horizontal scroll to 0.  The controller's restoreViewState()
        // will set it back to the (clamped) saved position afterward.
        m_sci->SendScintilla(QsciScintillaBase::SCI_SETXOFFSET, (unsigned long)0);
    }

    // Force full re-lex to fix stale syntax coloring after edits
    m_sci->SendScintilla(QsciScintillaBase::SCI_COLOURISE, (uintptr_t)0, (long)-1);

    applyMarginText(result.meta);
    applyMarkers(result.meta);
    applyFoldLevels(result.meta);
    applyHexDimming(result.meta);
    applyHeatmapHighlight(result.meta);
    applySymbolColoring(result.meta);
    applyCommandRowPills();

    // Reset hint line - applySelectionOverlay will repaint indicators
    m_hintLine = -1;

    // Restore hover state
    m_hoveredNodeId = savedHoverId;
    m_hoveredLine = savedHoverLine;
    m_hoverInside = savedHoverInside;
    m_applyingDocument = false;

    // Re-apply hover markers (setText() clears all Scintilla markers).
    // Reset m_prevHoveredNodeId so the incremental logic re-adds markers.
    // applyHoverCursor() is NOT called here — it evaluates hitTest() against
    // composed text that updateCommandRow() will overwrite.  The correct call
    // happens via applySelectionOverlays() after all text is finalized.
    m_prevHoveredNodeId = 0;
    m_prevHoveredLine = -1;
    applyHoverHighlight();
}

void RcxEditor::applyMarginText(const QVector<LineMeta>& meta) {
    if (m_relativeOffsets)
        return reformatMargins();

    m_sci->clearMarginText(-1);

    for (int i = 0; i < meta.size(); i++) {
        const auto& lm = meta[i];
        if (lm.offsetText.isEmpty()) continue;

        QByteArray text = lm.offsetText.toUtf8();
        m_sci->SendScintilla(QsciScintillaBase::SCI_MARGINSETTEXT,
                             (uintptr_t)i, text.constData());
        QByteArray styles(text.size(), '\0');  // style 0 = dim
        m_sci->SendScintilla(QsciScintillaBase::SCI_MARGINSETSTYLES,
                             (uintptr_t)i, styles.constData());
    }
}

void RcxEditor::reformatMargins() {
    uint64_t base = m_layout.baseAddress;
    int hexDigits = m_layout.offsetHexDigits;

    // ── Pass 1: margin text (global offset only) ──
    m_sci->clearMarginText(-1);
    for (int i = 0; i < m_meta.size(); i++) {
        auto& lm = m_meta[i];

        if (lm.isContinuation) {
            lm.offsetText = QStringLiteral("  \u00B7 ");
        } else if (lm.offsetText.isEmpty()) {
            continue;
        } else if (m_relativeOffsets) {
            if (lm.lineKind == LineKind::Footer ||
                lm.lineKind == LineKind::ArrayElementSeparator ||
                lm.lineKind == LineKind::CommandRow) {
                lm.offsetText = QString(hexDigits + 1, ' ');
            } else {
                uint64_t rvaBase = lm.ptrBase ? lm.ptrBase : base;
                uint64_t rel = lm.offsetAddr >= rvaBase ? lm.offsetAddr - rvaBase : 0;
                lm.offsetText = (QStringLiteral("+") +
                    QString::number(rel, 16).toUpper())
                    .rightJustified(hexDigits, ' ') + QChar(' ');
            }
        } else {
            lm.offsetText = QString::number(lm.offsetAddr, 16).toUpper()
                .rightJustified(hexDigits, '0') + QChar(' ');
        }

        QByteArray text = lm.offsetText.toUtf8();
        m_sci->SendScintilla(QsciScintillaBase::SCI_MARGINSETTEXT,
                             (uintptr_t)i, text.constData());
        QByteArray styles(text.size(), '\0');
        m_sci->SendScintilla(QsciScintillaBase::SCI_MARGINSETSTYLES,
                             (uintptr_t)i, styles.constData());
    }

    // ── Pass 2: inline local offsets in the text indent area ──
    m_sci->setReadOnly(false);
    for (int i = 0; i < m_meta.size(); i++) {
        const auto& lm = m_meta[i];
        if (lm.depth <= 1 || lm.isContinuation) continue;
        if (lm.lineKind != LineKind::Field && lm.lineKind != LineKind::Header)
            continue;

        // Place offset in the parent's indent slot (one level above the field's own indent)
        // so the field's own 3-char indent acts as visual separator from the type column
        int col = kFoldCol + (lm.depth - 2) * 3;
        int slotWidth = 5;

        auto pos = [&](int c) -> long {
            return m_sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                                        (unsigned long)i, (long)c);
        };

        if (m_relativeOffsets) {
            // Derive local offset: for pointer-expanded children use ptrBase,
            // otherwise find enclosing header or array element separator
            uint64_t parentAddr = base;
            if (lm.ptrBase != 0) {
                parentAddr = lm.ptrBase;
            } else {
                for (int j = i - 1; j >= 0; j--) {
                    const auto& pLm = m_meta[j];
                    if (pLm.lineKind == LineKind::Header && pLm.depth < lm.depth) {
                        parentAddr = pLm.offsetAddr;
                        break;
                    }
                    if (pLm.lineKind == LineKind::ArrayElementSeparator && pLm.depth <= lm.depth) {
                        parentAddr = pLm.offsetAddr;
                        break;
                    }
                }
            }
            uint64_t localOff = lm.offsetAddr >= parentAddr ? lm.offsetAddr - parentAddr : 0;

            QString off = QStringLiteral("+") +
                QString::number(localOff, 16).toUpper();
            QString padded = off.size() <= slotWidth
                ? off.rightJustified(slotWidth, ' ')
                : off;
            long posA = pos(col);
            long posB = pos(col + slotWidth);
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETSTART, posA);
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETEND, posB);
            QByteArray utf8 = padded.left(slotWidth).toUtf8();
            m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACETARGET,
                                 (uintptr_t)utf8.size(), utf8.constData());
            // Color the local offset dim
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT, IND_LOCAL_OFF);
            m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORFILLRANGE,
                                 posA, posB - posA);
        } else {
            // Restore spaces when toggling off
            long posA = pos(col);
            long posB = pos(col + slotWidth);
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETSTART, posA);
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETEND, posB);
            QByteArray spaces(slotWidth, ' ');
            m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACETARGET,
                                 (uintptr_t)spaces.size(), spaces.constData());
        }
    }
    m_sci->setReadOnly(true);
}

void RcxEditor::applyMarkers(const QVector<LineMeta>& meta) {
    for (int m = M_CONT; m <= M_STRUCT_BG; m++) {
        m_sci->markerDeleteAll(m);
    }
    m_sci->markerDeleteAll(M_CMD_ROW);
    for (int i = 0; i < meta.size(); i++) {
        if (meta[i].lineKind == LineKind::CommandRow) {
            m_sci->markerAdd(i, M_CMD_ROW);
            continue;
        }
        uint32_t mask = meta[i].markerMask;
        for (int m = M_CONT; m <= M_STRUCT_BG; m++) {
            if (mask & (1u << m)) {
                m_sci->markerAdd(i, m);
            }
        }
    }
}

void RcxEditor::applyFoldLevels(const QVector<LineMeta>& meta) {
    for (int i = 0; i < meta.size(); i++) {
        m_sci->SendScintilla(QsciScintillaBase::SCI_SETFOLDLEVEL,
                             (unsigned long)i, (long)meta[i].foldLevel);
    }
}

static inline void lineRangeNoEol(QsciScintilla* sci, int line, long& start, long& len) {
    start = sci->SendScintilla(QsciScintillaBase::SCI_POSITIONFROMLINE, (unsigned long)line);
    long end = sci->SendScintilla(QsciScintillaBase::SCI_GETLINEENDPOSITION, (unsigned long)line);
    len = (end > start) ? (end - start) : 0;
}

// UTF-8 safe column-to-position conversion
static inline long posFromCol(QsciScintilla* sci, int line, int col) {
    return sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                              (unsigned long)line, (long)col);
}

void RcxEditor::clearIndicatorLine(int indic, int line) {
    if (line < 0) return;
    long start, len;
    lineRangeNoEol(m_sci, line, start, len);
    if (len <= 0) return;
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT, indic);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORCLEARRANGE, start, len);
}

void RcxEditor::fillIndicatorCols(int indic, int line, int colA, int colB) {
    long a = posFromCol(m_sci, line, colA);
    long b = posFromCol(m_sci, line, colB);
    if (b > a) {
        m_sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT, indic);
        m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORFILLRANGE, a, b - a);
    }
}

void RcxEditor::applyHexDimming(const QVector<LineMeta>& meta) {
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT, IND_HEX_DIM);
    for (int i = 0; i < meta.size(); i++) {
        // Dim fold arrows (▸/▾) on fold head lines
        if (meta[i].foldHead && meta[i].lineKind != LineKind::CommandRow)
            fillIndicatorCols(IND_HEX_DIM, i, 0, kFoldCol);

        if (isHexPreview(meta[i].nodeKind)) {
            long pos, len; lineRangeNoEol(m_sci, i, pos, len);
            if (len > 0)
                m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORFILLRANGE, pos, len);
        }
        // Dim struct/array braces: entire footer line, trailing "{" on headers
        if (meta[i].lineKind == LineKind::Footer) {
            long pos, len; lineRangeNoEol(m_sci, i, pos, len);
            if (len > 0)
                m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORFILLRANGE, pos, len);
        } else if (meta[i].lineKind == LineKind::Header ||
                   meta[i].lineKind == LineKind::CommandRow) {
            long endPos = m_sci->SendScintilla(QsciScintillaBase::SCI_GETLINEENDPOSITION, (unsigned long)i);
            for (long p = endPos - 1; p >= 0; --p) {
                int ch = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETCHARAT, (unsigned long)p);
                if (ch == ' ' || ch == '\t') continue;
                if (ch == '{')
                    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORFILLRANGE, p, 1);
                break;
            }
        }
    }
}

void RcxEditor::applySelectionOverlay(const QSet<uint64_t>& selIds) {
    m_currentSelIds = selIds;
    m_sci->markerDeleteAll(M_SELECTED);
    m_sci->markerDeleteAll(M_ACCENT);

    // Clear all editable indicators, then repaint for selected lines only
    long docLen = m_sci->SendScintilla(QsciScintillaBase::SCI_GETLENGTH);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT, IND_EDITABLE);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORCLEARRANGE, (unsigned long)0, docLen);

    // Use index: iterate selected IDs, look up their lines
    for (uint64_t selId : selIds) {
        bool isFooterSel = (selId & kFooterIdBit) != 0;
        bool isArrayElemSel = (selId & kArrayElemBit) != 0;
        int arrayElemIdx = isArrayElemSel ? arrayElemIdxFromSelId(selId) : -1;
        uint64_t nodeId = selId & ~(kFooterIdBit | kArrayElemBit | kArrayElemMask);
        auto it = m_nodeLineIndex.constFind(nodeId);
        if (it == m_nodeLineIndex.constEnd()) continue;
        for (int ln : *it) {
            if (isSyntheticLine(m_meta[ln])) continue;
            bool isFooter = (m_meta[ln].lineKind == LineKind::Footer);
            // Match selection type to line type
            if (isFooterSel && !isFooter) continue;
            if (!isFooterSel && isFooter) continue;
            // Array element: match by element index
            if (isArrayElemSel) {
                if (!m_meta[ln].isArrayElement || m_meta[ln].arrayElementIdx != arrayElemIdx)
                    continue;
            } else if (m_meta[ln].isArrayElement) {
                // Plain nodeId selection shouldn't highlight individual array elements
                // (the header line is enough)
                continue;
            }
            m_sci->markerAdd(ln, M_SELECTED);
            m_sci->markerAdd(ln, M_ACCENT);
            if (!isFooter)
                paintEditableSpans(ln);
        }
    }

    // Reset hint line - updateEditableIndicators will handle cursor hints
    // on actual user navigation (not stale restored positions)
    m_hintLine = -1;

    applyHoverHighlight();
    applyHoverCursor();
}

void RcxEditor::applyHoverHighlight() {
    uint64_t prevId = m_prevHoveredNodeId;
    int prevLine = m_prevHoveredLine;
    m_prevHoveredNodeId = m_hoveredNodeId;
    m_prevHoveredLine = m_hoveredLine;

    // Fast path: nothing changed (same node AND same line)
    if (prevId == m_hoveredNodeId && prevLine == m_hoveredLine
        && m_hoveredNodeId != 0) return;

    // Remove old hover markers
    if (prevId != 0) {
        // Check if old hovered line was a single-line highlight (footer or array element)
        bool prevSingleLine = (prevLine >= 0 && prevLine < m_meta.size() &&
            (m_meta[prevLine].lineKind == LineKind::Footer || m_meta[prevLine].isArrayElement));
        if (prevSingleLine) {
            m_sci->markerDelete(prevLine, M_HOVER);
        } else {
            auto it = m_nodeLineIndex.constFind(prevId);
            if (it != m_nodeLineIndex.constEnd()) {
                for (int ln : *it)
                    m_sci->markerDelete(ln, M_HOVER);
            }
        }
    }

    if (m_editState.active) return;
    if (!m_hoverInside) return;
    if (m_hoveredNodeId == 0) return;

    // Footer and array elements highlight only the specific line
    bool hoveringFooter = (m_hoveredLine >= 0 && m_hoveredLine < m_meta.size() &&
                           m_meta[m_hoveredLine].lineKind == LineKind::Footer);
    bool hoveringArrayElem = (m_hoveredLine >= 0 && m_hoveredLine < m_meta.size() &&
                              m_meta[m_hoveredLine].isArrayElement);

    // Check if the hovered item is already selected (using appropriate ID)
    uint64_t checkId;
    if (hoveringFooter)
        checkId = m_hoveredNodeId | kFooterIdBit;
    else if (hoveringArrayElem)
        checkId = makeArrayElemSelId(m_hoveredNodeId, m_meta[m_hoveredLine].arrayElementIdx);
    else
        checkId = m_hoveredNodeId;
    if (m_currentSelIds.contains(checkId)) return;

    if (hoveringFooter || hoveringArrayElem) {
        // Single-line highlight for footers and array elements
        m_sci->markerAdd(m_hoveredLine, M_HOVER);
    } else {
        // Non-footer, non-array-element: highlight all lines for this node
        auto it = m_nodeLineIndex.constFind(m_hoveredNodeId);
        if (it != m_nodeLineIndex.constEnd()) {
            for (int ln : *it) {
                if (m_meta[ln].lineKind != LineKind::Footer &&
                    !m_meta[ln].isArrayElement)
                    m_sci->markerAdd(ln, M_HOVER);
            }
        }
    }
}

ViewState RcxEditor::saveViewState() const {
    ViewState vs;
    vs.scrollLine = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETFIRSTVISIBLELINE);
    int line, col;
    m_sci->getCursorPosition(&line, &col);
    vs.cursorLine = line;
    vs.cursorCol  = col;
    vs.xOffset = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETXOFFSET);
    return vs;
}

void RcxEditor::restoreViewState(const ViewState& vs) {
    int maxLine = std::max(0, m_sci->lines() - 1);
    int line = std::clamp(vs.cursorLine, 0, maxLine);
    long pos = m_sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                                    (unsigned long)line,
                                    (long)std::max(0, vs.cursorCol));
    m_sci->SendScintilla(QsciScintillaBase::SCI_GOTOPOS, (unsigned long)pos);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETFIRSTVISIBLELINE,
                         (unsigned long)vs.scrollLine);
    // Clamp xOffset so it doesn't exceed the current content width.
    // After a rename that shrinks content, the saved offset may be stale.
    int scrollW = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETSCROLLWIDTH);
    int vpW = m_sci->viewport() ? m_sci->viewport()->width() : 0;
    int maxXOff = qMax(0, scrollW - vpW);
    int xOff = qBound(0, vs.xOffset, maxXOff);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETXOFFSET, (unsigned long)xOff);
}

const LineMeta* RcxEditor::metaForLine(int line) const {
    if (line >= 0 && line < m_meta.size())
        return &m_meta[line];
    return nullptr;
}

int RcxEditor::currentNodeIndex() const {
    int line, col;
    m_sci->getCursorPosition(&line, &col);
    auto* lm = metaForLine(line);
    return lm ? lm->nodeIdx : -1;
}

void RcxEditor::scrollToNodeId(uint64_t nodeId) {
    for (int i = 0; i < m_meta.size(); i++) {
        if (m_meta[i].nodeId == nodeId && m_meta[i].lineKind != LineKind::Footer) {
            m_sci->setCursorPosition(i, 0);
            m_sci->ensureLineVisible(i);
            return;
        }
    }
}

// ── Column span computation ──

ColumnSpan RcxEditor::typeSpan(const LineMeta& lm, int typeW)  { return typeSpanFor(lm, typeW); }
ColumnSpan RcxEditor::nameSpan(const LineMeta& lm, int typeW, int nameW)  { return nameSpanFor(lm, typeW, nameW); }
ColumnSpan RcxEditor::valueSpan(const LineMeta& lm, int lineLength, int typeW, int nameW) { return valueSpanFor(lm, lineLength, typeW, nameW); }

// For pointer-like nodes, narrow value span to just the address portion
// (before the "  // " separator that precedes the symbol like "Module+0x1234").
static ColumnSpan narrowPtrValueSpan(const LineMeta& lm, const ColumnSpan& vs,
                                     const QString& lineText) {
    if (!vs.valid) return vs;
    if (!isFuncPtr(lm.nodeKind)
        && lm.nodeKind != NodeKind::Pointer32
        && lm.nodeKind != NodeKind::Pointer64)
        return vs;
    QString valText = lineText.mid(vs.start, vs.end - vs.start);
    int sep = valText.indexOf(QLatin1String("  // "));
    if (sep > 0)
        return {vs.start, vs.start + sep, true};
    return vs;
}

// ── Multi-selection ──

QSet<int> RcxEditor::selectedNodeIndices() const {
    int lineFrom, indexFrom, lineTo, indexTo;
    m_sci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
    if (lineFrom < 0) {
        int line, col;
        m_sci->getCursorPosition(&line, &col);
        auto* lm = metaForLine(line);
        return lm && lm->nodeIdx >= 0 ? QSet<int>{lm->nodeIdx} : QSet<int>{};
    }
    QSet<int> result;
    for (int line = lineFrom; line <= lineTo; line++) {
        auto* lm = metaForLine(line);
        if (lm && lm->nodeIdx >= 0) result.insert(lm->nodeIdx);
    }
    return result;
}

// ── Inline edit helpers ──

static QString getLineText(QsciScintilla* sci, int line) {
    int len = (int)sci->SendScintilla(QsciScintillaBase::SCI_LINELENGTH, (unsigned long)line);
    if (len <= 0) return {};
    QByteArray buf(len + 1, '\0');
    sci->SendScintilla(QsciScintillaBase::SCI_GETLINE, (unsigned long)line, (void*)buf.data());
    QString text = QString::fromUtf8(buf.data(), len);
    while (text.endsWith('\n') || text.endsWith('\r'))
        text.chop(1);
    return text;
}

void RcxEditor::applyHeatmapHighlight(const QVector<LineMeta>& meta) {
    static constexpr int heatIndicators[] = { IND_HEAT_COLD, IND_HEAT_WARM, IND_HEAT_HOT };

    for (int i = 0; i < meta.size(); i++) {
        const LineMeta& lm = meta[i];
        if (isSyntheticLine(lm)) continue;

        int heat = lm.heatLevel;
        int typeW = lm.effectiveTypeW;
        int nameW = lm.effectiveNameW;

        if (heat <= 0) continue;

        // Pick the right indicator for this heat level (1→cold, 2→warm, 3→hot)
        int activeInd = heatIndicators[qBound(0, heat - 1, 2)];

        // Apply heat-level indicator to value span (narrowed for pointer-like nodes)
        QString lineText = getLineText(m_sci, i);
        ColumnSpan vs = narrowPtrValueSpan(lm,
            valueSpan(lm, lineText.size(), typeW, nameW), lineText);
        if (!vs.valid) continue;

        fillIndicatorCols(activeInd, i, vs.start, vs.end);

        // Clear the other two heat indicators on this span to avoid overlap
        for (int hi : heatIndicators) {
            if (hi != activeInd)
                clearIndicatorLine(hi, i);
        }
    }
}

void RcxEditor::applySymbolColoring(const QVector<LineMeta>& meta) {
    for (int i = 0; i < meta.size(); i++) {
        const LineMeta& lm = meta[i];
        if (!isFuncPtr(lm.nodeKind)
            && lm.nodeKind != NodeKind::Pointer32
            && lm.nodeKind != NodeKind::Pointer64)
            continue;
        QString lineText = getLineText(m_sci, i);
        // Find "  // " within the value region and color "// sym" portion green
        ColumnSpan vs = valueSpan(lm, lineText.size(), lm.effectiveTypeW, lm.effectiveNameW);
        if (!vs.valid) continue;
        int searchFrom = vs.start;
        int sep = lineText.indexOf(QLatin1String("  // "), searchFrom);
        if (sep < 0 || sep >= vs.end) continue;
        int symStart = sep + 2;  // start of "// sym"
        int symEnd = vs.end;
        while (symEnd > symStart && lineText[symEnd - 1] == ' ') symEnd--;
        if (symEnd > symStart)
            fillIndicatorCols(IND_HINT_GREEN, i, symStart, symEnd);
    }
}

void RcxEditor::applyBaseAddressColoring(const QVector<LineMeta>& meta) {
    if (meta.isEmpty() || meta[0].lineKind != LineKind::CommandRow) return;

    clearIndicatorLine(IND_BASE_ADDR, 0);
    // Override lexer's green number coloring on the address with default text color
    QString t = getLineText(m_sci, 0);
    ColumnSpan addr = commandRowAddrSpan(t);
    if (addr.valid)
        fillIndicatorCols(IND_BASE_ADDR, 0, addr.start, addr.end);
}

void RcxEditor::applyCommandRowPills() {
    if (m_meta.isEmpty() || m_meta[0].lineKind != LineKind::CommandRow) return;

    constexpr int line = 0;
    QString t = getLineText(m_sci, line);

    clearIndicatorLine(IND_HEX_DIM, line);
    clearIndicatorLine(IND_CLASS_NAME, line);

    // Dim the [▾] type-selector chevron
    ColumnSpan chevron = commandRowChevronSpan(t);
    if (chevron.valid)
        fillIndicatorCols(IND_HEX_DIM, line, chevron.start, chevron.end);

    // Dim label text: source arrow/placeholder + its ▾ dropdown arrow
    ColumnSpan srcSpan = commandRowSrcSpan(t);
    if (srcSpan.valid) {
        int quotePos = t.indexOf('\'', srcSpan.start);
        int kindEnd = (quotePos > srcSpan.start) ? quotePos : srcSpan.end;
        while (kindEnd > srcSpan.start && t[kindEnd - 1].isSpace()) kindEnd--;
        if (kindEnd > srcSpan.start)
            fillIndicatorCols(IND_HEX_DIM, line, srcSpan.start, kindEnd);
        // Dim the source ▾ dropdown arrow to match (like struct▾)
        int srcDrop = t.indexOf(QChar(0x25BE));
        int rootStart = commandRowRootStart(t);
        if (srcDrop >= 0 && (rootStart < 0 || srcDrop < rootStart))
            fillIndicatorCols(IND_HEX_DIM, line, srcDrop, srcDrop + 1);
    }
    // Dim all " · " separators
    int searchFrom = 0;
    while (true) {
        int tag = t.indexOf(QStringLiteral(" \u00B7"), searchFrom);
        if (tag < 0) break;
        fillIndicatorCols(IND_HEX_DIM, line, tag, tag + 3);
        searchFrom = tag + 3;
    }

    // Dim base address to match source/struct grey
    ColumnSpan addrSpan = commandRowAddrSpan(t);
    if (addrSpan.valid)
        fillIndicatorCols(IND_HEX_DIM, line, addrSpan.start, addrSpan.end);

    // Root class styling (type dim + class-name teal, no underline)
    ColumnSpan rt = commandRowRootTypeSpan(t);
    if (rt.valid) {
        fillIndicatorCols(IND_HEX_DIM, line, rt.start, rt.end);
        int drop = t.indexOf(QChar(0x25BE), rt.start);
        if (drop >= 0)
            fillIndicatorCols(IND_HEX_DIM, line, drop, qMin(drop + 2, t.size()));
    }
    ColumnSpan rn = commandRowRootNameSpan(t);
    if (rn.valid) {
        fillIndicatorCols(IND_CLASS_NAME, line, rn.start, rn.end);
    }

    // Dim trailing opening brace to match the rest of the command row grey
    for (int i = t.size() - 1; i >= 0; --i) {
        if (t[i] == ' ' || t[i] == '\t') continue;
        if (t[i] == '{')
            fillIndicatorCols(IND_HEX_DIM, line, i, i + 1);
        break;
    }
}

// ── Shared inline-edit shutdown ──

RcxEditor::EndEditInfo RcxEditor::endInlineEdit() {
    // Dismiss any open user list / autocomplete popup
    m_sci->SendScintilla(QsciScintillaBase::SCI_AUTOCCANCEL);
    // Clear edit comment and error marker before deactivating
    if (m_editState.target == EditTarget::Value) {
        setEditComment({});  // Clear to spaces
        m_sci->markerDelete(m_editState.line, M_ERR);
    }
    EndEditInfo info{m_editState.nodeIdx, m_editState.subLine, m_editState.target};
    m_editState.active = false;
    m_sci->setReadOnly(true);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETCARETWIDTH, 0);
    // Switch back to Arrow cursor (widget-local, doesn't fight splitters/menus)
    m_sci->viewport()->setCursor(Qt::ArrowCursor);
    // Disable selection rendering again
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSELFORE, (long)0, (long)0);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSELBACK, (long)0, (long)0);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETUNDOCOLLECTION, (long)1);
    m_sci->SendScintilla(QsciScintillaBase::SCI_EMPTYUNDOBUFFER);
    return info;
}

// ── Span helpers ──

// Name span for struct/array headers - uses column-based positioning
// Format: [fold][indent][type col][sep][name col][sep][suffix]
static ColumnSpan headerNameSpan(const LineMeta& lm, const QString& lineText) {
    if (lm.lineKind != LineKind::Header) return {};

    int ind = kFoldCol + lm.depth * 3;
    int typeW = lm.effectiveTypeW;
    int nameStart = ind + typeW + kSepWidth;

    if (nameStart >= lineText.size()) return {};

    // Name ends before " {" suffix (expanded) or at line end (collapsed)
    int nameEnd = lineText.size();
    if (lineText.endsWith(QStringLiteral(" {")))
        nameEnd = lineText.size() - 2;

    if (nameEnd <= nameStart) return {};

    // Don't allow editing array element names like "[0]", "[1]", etc.
    QString name = lineText.mid(nameStart, nameEnd - nameStart).trimmed();
    if (name.isEmpty()) return {};
    if (name.startsWith('[') && name.endsWith(']'))
        return {};

    return {nameStart, nameEnd, true};
}

// Type name span for struct headers (not arrays)
// Format: "struct TYPENAME NAME {" or collapsed variants
// For "struct NAME {" (no typename), returns invalid span
static ColumnSpan headerTypeNameSpan(const LineMeta& lm, const QString& lineText) {
    if (lm.lineKind != LineKind::Header) return {};
    if (lm.isArrayHeader) return {};  // Arrays use arrayHeaderTypeSpan instead

    int ind = kFoldCol + lm.depth * 3;
    int typeW = lm.effectiveTypeW;
    int typeEnd = ind + typeW;

    // Clamp to actual line content
    if (typeEnd > lineText.size()) typeEnd = lineText.size();

    // Extract the type column text and check if it has a typename
    // Format: "struct" or "struct TYPENAME"
    QString typeCol = lineText.mid(ind, typeEnd - ind).trimmed();

    // Find first space (after "struct")
    int firstSpace = typeCol.indexOf(' ');
    if (firstSpace < 0) return {};  // Just "struct", no typename

    // If there's content after "struct ", that's the typename
    QString typename_ = typeCol.mid(firstSpace + 1).trimmed();
    if (typename_.isEmpty()) return {};

    // Return span of the typename within the type column
    int typenameStart = ind + firstSpace + 1;
    // Find where the typename actually ends (skip padding)
    int typenameEnd = typenameStart;
    while (typenameEnd < typeEnd && lineText[typenameEnd] != ' ')
        typenameEnd++;

    return {typenameStart, typenameEnd, true};
}

// Type span for array headers: "int32_t[10]" in "int32_t[10] positions {"
static ColumnSpan arrayHeaderTypeSpan(const LineMeta& lm, const QString& lineText) {
    if (lm.lineKind != LineKind::Header || !lm.isArrayHeader) return {};
    int ind = kFoldCol + lm.depth * 3;
    int typeEnd = lineText.indexOf(' ', ind);
    if (typeEnd <= ind) return {};
    return {ind, typeEnd, true};
}

RcxEditor::NormalizedSpan RcxEditor::normalizeSpan(
    const ColumnSpan& raw, const QString& lineText,
    EditTarget target, bool skipPrefixes) const
{
    if (!raw.valid) return {};
    int textLen = lineText.size();
    if (raw.start >= textLen) return {};

    int start = raw.start;
    int end   = qMin(raw.end, textLen);
    if (end <= start) return {};

    if (skipPrefixes && target == EditTarget::Value) {
        QString spanText = lineText.mid(start, end - start);
        int arrow = spanText.indexOf(QStringLiteral("->"));
        if (arrow >= 0) {
            int i = arrow + 2;
            while (i < spanText.size() && spanText[i].isSpace()) i++;
            start += i;
        } else {
            int eq = spanText.indexOf('=');
            if (eq >= 0 && eq <= 3) {
                int i = eq + 1;
                while (i < spanText.size() && spanText[i].isSpace()) i++;
                start += i;
            }
        }
        if (start >= end) return {};
    }

    QString inner = lineText.mid(start, end - start);
    int lead = 0;
    while (lead < inner.size() && inner[lead].isSpace()) lead++;
    int trail = inner.size();
    while (trail > lead && inner[trail - 1].isSpace()) trail--;
    if (trail <= lead) return {};

    return {start + lead, start + trail, true};
}

bool RcxEditor::resolvedSpanFor(int line, EditTarget t,
                                NormalizedSpan& out, QString* lineTextOut) const {
    const LineMeta* lm = metaForLine(line);
    if (!lm) return false;

    // CommandRow: Source / BaseAddress / Root class (type+name) editing
    if (lm->lineKind == LineKind::CommandRow) {
        if (t != EditTarget::BaseAddress && t != EditTarget::Source
            && t != EditTarget::RootClassType && t != EditTarget::RootClassName
            && t != EditTarget::TypeSelector) return false;
        QString lineText = getLineText(m_sci, line);
        ColumnSpan s;
        if (t == EditTarget::TypeSelector)       s = commandRowChevronSpan(lineText);
        else if (t == EditTarget::Source)        s = commandRowSrcSpan(lineText);
        else if (t == EditTarget::BaseAddress)   s = commandRowAddrSpan(lineText);
        else if (t == EditTarget::RootClassType) s = commandRowRootTypeSpan(lineText);
        else                                     s = commandRowRootNameSpan(lineText);
        out = normalizeSpan(s, lineText, t, /*skipPrefixes=*/(t == EditTarget::BaseAddress));
        if (lineTextOut) *lineTextOut = lineText;
        return out.valid;
    }

    if (lm->nodeIdx < 0) return false;

    // Hex nodes: only Type is editable (ASCII preview + hex bytes are display-only)
    if ((t == EditTarget::Name || t == EditTarget::Value) && isHexNode(lm->nodeKind))
        return false;

    QString lineText = getLineText(m_sci, line);
    int textLen = lineText.size();

    // Use per-line effective widths (set during compose based on containing scope)
    int typeW = lm->effectiveTypeW;
    int nameW = lm->effectiveNameW;

    ColumnSpan s;
    switch (t) {
    case EditTarget::Type:        s = typeSpan(*lm, typeW); break;
    case EditTarget::Name:        s = nameSpan(*lm, typeW, nameW); break;
    case EditTarget::Value:       s = narrowPtrValueSpan(*lm,
                                      valueSpan(*lm, textLen, typeW, nameW), lineText); break;
    case EditTarget::BaseAddress: break;  // No longer on header lines
    case EditTarget::ArrayIndex:
    case EditTarget::ArrayCount:
        break;  // Array navigation removed
    case EditTarget::ArrayElementType:
        s = arrayElemTypeSpanFor(*lm, lineText); break;
    case EditTarget::ArrayElementCount:
        s = arrayElemCountSpanFor(*lm, lineText); break;
    case EditTarget::PointerTarget:
        s = pointerTargetSpanFor(*lm, lineText); break;
    case EditTarget::Source: break;
    }

    // Fallback spans for header lines
    if (!s.valid && t == EditTarget::Type) {
        // For pointer fields, the full type span acts as "kind" span
        // For array headers, fall back to the full type[count] span
        s = arrayHeaderTypeSpan(*lm, lineText);
        if (!s.valid)
            s = headerTypeNameSpan(*lm, lineText);
        if (!s.valid)
            s = pointerKindSpanFor(*lm, lineText);
    }
    if (!s.valid && t == EditTarget::Name)
        s = headerNameSpan(*lm, lineText);

    out = normalizeSpan(s, lineText, t, /*skipPrefixes=*/true);
    if (lineTextOut) *lineTextOut = lineText;
    return out.valid;
}

// ── Point → line/col/nodeId resolution ──

RcxEditor::HitInfo RcxEditor::hitTest(const QPoint& vp) const {
    HitInfo h;

    // Try precise position first (works when cursor is over actual text)
    long pos = m_sci->SendScintilla(QsciScintillaBase::SCI_POSITIONFROMPOINTCLOSE,
                                     (unsigned long)vp.x(), (long)vp.y());
    if (pos >= 0) {
        h.line = (int)m_sci->SendScintilla(
            QsciScintillaBase::SCI_LINEFROMPOSITION, (unsigned long)pos);
        h.col = (int)m_sci->SendScintilla(
            QsciScintillaBase::SCI_GETCOLUMN, (unsigned long)pos);
    } else {
        // Fallback: calculate line from Y coordinate (for empty space past text)
        int firstVisible = (int)m_sci->SendScintilla(
            QsciScintillaBase::SCI_GETFIRSTVISIBLELINE);
        int lineHeight = (int)m_sci->SendScintilla(
            QsciScintillaBase::SCI_TEXTHEIGHT, 0);
        if (lineHeight > 0)
            h.line = firstVisible + vp.y() / lineHeight;
    }

    if (h.line >= 0 && h.line < m_meta.size()) {
        h.nodeId = m_meta[h.line].nodeId;
        h.inFoldCol = (h.col >= 0 && h.col < kFoldCol + 1 && m_meta[h.line].foldHead);
    }
    return h;
}

// ── Double-click hit test ──

static bool hitTestTarget(QsciScintilla* sci,
                          const QVector<LineMeta>& meta,
                          const QPoint& viewportPos,
                          int& outLine, int& outCol, EditTarget& outTarget)
{
    long pos = sci->SendScintilla(QsciScintillaBase::SCI_POSITIONFROMPOINTCLOSE,
                                  (unsigned long)viewportPos.x(), (long)viewportPos.y());
    if (pos < 0) return false;
    int line = (int)sci->SendScintilla(QsciScintillaBase::SCI_LINEFROMPOSITION,
                                       (unsigned long)pos);
    int col  = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETCOLUMN,
                                       (unsigned long)pos);
    outCol = col;
    if (line < 0 || line >= meta.size()) return false;

    QString lineText = getLineText(sci, line);
    int textLen = lineText.size();

    const LineMeta& lm = meta[line];

    if (lm.lineKind == LineKind::ArrayElementSeparator) return false;

    auto inSpan = [&](const ColumnSpan& s) {
        return s.valid && col >= s.start && col < s.end;
    };

    // CommandRow: interactive chevron/SRC/ADDR + root class (type+name)
    if (lm.lineKind == LineKind::CommandRow) {
        ColumnSpan chevron = commandRowChevronSpan(lineText);
        if (inSpan(chevron)) { outTarget = EditTarget::TypeSelector; outLine = line; return true; }
        ColumnSpan ss = commandRowSrcSpan(lineText);
        if (inSpan(ss)) { outTarget = EditTarget::Source; outLine = line; return true; }
        ColumnSpan as = commandRowAddrSpan(lineText);
        if (inSpan(as)) { outTarget = EditTarget::BaseAddress; outLine = line; return true; }

        // RootClassType is no longer clickable — use right-click to convert
        ColumnSpan rns = commandRowRootNameSpan(lineText);
        if (inSpan(rns)) { outTarget = EditTarget::RootClassName; outLine = line; return true; }
        return false;
    }

    // Use per-line effective widths from LineMeta
    int typeW = lm.effectiveTypeW;
    int nameW = lm.effectiveNameW;

    ColumnSpan ts = RcxEditor::typeSpan(lm, typeW);
    ColumnSpan ns = RcxEditor::nameSpan(lm, typeW, nameW);
    ColumnSpan vs = narrowPtrValueSpan(lm,
        RcxEditor::valueSpan(lm, textLen, typeW, nameW), lineText);

    // Pointer fields/headers: check sub-spans within type column first
    if (lm.nodeKind == NodeKind::Pointer32 || lm.nodeKind == NodeKind::Pointer64) {
        ColumnSpan ptrTarget = pointerTargetSpanFor(lm, lineText);
        ColumnSpan ptrKind = pointerKindSpanFor(lm, lineText);
        if (inSpan(ptrTarget)) { outTarget = EditTarget::PointerTarget; outLine = line; return true; }
        if (inSpan(ptrKind))   { outTarget = EditTarget::Type; outLine = line; return true; }
    }

    // Array headers: check element type and count sub-spans first
    // Count click area includes brackets [N] so clicking [ or ] edits the count
    if (lm.isArrayHeader) {
        ColumnSpan elemCountClick = arrayElemCountClickSpanFor(lm, lineText);
        ColumnSpan elemType = arrayElemTypeSpanFor(lm, lineText);
        if (inSpan(elemCountClick)) { outTarget = EditTarget::ArrayElementCount; outLine = line; return true; }
        if (inSpan(elemType))       { outTarget = EditTarget::ArrayElementType; outLine = line; return true; }
    }

    // Fallback spans for header lines
    if (!ts.valid) {
        ts = arrayHeaderTypeSpan(lm, lineText);
        if (!ts.valid)
            ts = headerTypeNameSpan(lm, lineText);
    }
    if (!ns.valid)
        ns = headerNameSpan(lm, lineText);

    if (inSpan(ts))      outTarget = EditTarget::Type;
    else if (inSpan(ns)) outTarget = EditTarget::Name;
    else if (inSpan(vs)) outTarget = EditTarget::Value;
    else return false;

    // Array headers: redirect generic Type hit to ArrayElementType (uses popup, not inline edit)
    if (lm.isArrayHeader && outTarget == EditTarget::Type) {
        outTarget = EditTarget::ArrayElementType;
        outLine = line;
        return true;
    }
    // Array element lines: type/name click opens element type picker on the parent array header
    if (lm.isArrayElement && (outTarget == EditTarget::Type || outTarget == EditTarget::Name)) {
        outTarget = EditTarget::ArrayElementType;
        // Find the array header line (previous line with isArrayHeader and same nodeIdx)
        for (int l = line - 1; l >= 0; l--) {
            if (l >= meta.size()) continue;
            const LineMeta& hdr = meta[l];
            if (hdr.isArrayHeader && hdr.nodeIdx == lm.nodeIdx) {
                outLine = l;
                return true;
            }
        }
        return false;
    }
    // Hex nodes: only Type is editable (ASCII preview + hex bytes are display-only)
    if ((outTarget == EditTarget::Name || outTarget == EditTarget::Value) && isHexNode(lm.nodeKind))
        return false;

    outLine = line;
    return true;
}

// ── Event filter ──

bool RcxEditor::eventFilter(QObject* obj, QEvent* event) {
    if (obj == m_sci && event->type() == QEvent::KeyPress) {
        auto* ke = static_cast<QKeyEvent*>(event);
        bool handled = m_editState.active ? handleEditKey(ke) : handleNormalKey(ke);
        if (!handled && !m_editState.active) {
            // Clear hover on keyboard navigation (stale after scroll)
            m_hoveredNodeId = 0;
            m_hoveredLine = -1;
            applyHoverHighlight();
        }
        return handled;
    }
    if (obj == m_sci->viewport() && event->type() == QEvent::MouseButtonPress
        && m_editState.active) {
        auto* me = static_cast<QMouseEvent*>(event);
        auto h = hitTest(me->pos());

        if (h.line == m_editState.line) {
            int editEnd = editEndCol();
            bool insideTrimmed = (h.col >= m_editState.spanStart && h.col <= editEnd);

            if (insideTrimmed)
                return false;  // inside trimmed text: let Scintilla position cursor

            // Check raw span (full column width) - click in padding moves cursor to end
            const LineMeta* lm = metaForLine(m_editState.line);
            if (lm) {
                QString lineText = getLineText(m_sci, h.line);
                // Use per-line effective widths
                int typeW = lm->effectiveTypeW;
                int nameW = lm->effectiveNameW;
                ColumnSpan raw;
                switch (m_editState.target) {
                case EditTarget::Type:        raw = typeSpan(*lm, typeW); break;
                case EditTarget::Name:        raw = nameSpan(*lm, typeW, nameW); break;
                case EditTarget::Value:       raw = valueSpan(*lm, lineText.size(), typeW, nameW); break;
                case EditTarget::BaseAddress: raw = commandRowAddrSpan(lineText); break;
                case EditTarget::Source:      raw = commandRowSrcSpan(lineText); break;
                case EditTarget::ArrayIndex:  raw = arrayIndexSpanFor(*lm, lineText); break;
                case EditTarget::ArrayCount:  raw = arrayCountSpanFor(*lm, lineText); break;
                case EditTarget::ArrayElementType:  raw = arrayElemTypeSpanFor(*lm, lineText); break;
                case EditTarget::ArrayElementCount: raw = arrayElemCountSpanFor(*lm, lineText); break;
                case EditTarget::PointerTarget:     raw = pointerTargetSpanFor(*lm, lineText); break;
                }
                if (raw.valid && h.col >= raw.start && h.col < raw.end) {
                    // Within raw span but outside trimmed text → move cursor to end
                    long endPos = posFromCol(m_sci, m_editState.line, editEnd);
                    m_sci->SendScintilla(QsciScintillaBase::SCI_GOTOPOS, endPos);
                    return true;  // consume event
                }
            }
        }

        commitInlineEdit();
        m_currentSelIds.clear();
        return true;  // consume — metadata was recomposed; stale coords unsafe
    }
    // Single-click on fold column (" - " / " + ") toggles fold
    // Other left-clicks emit nodeClicked for selection
    if (obj == m_sci->viewport() && !m_editState.active
        && event->type() == QEvent::MouseButtonPress) {
        auto* me = static_cast<QMouseEvent*>(event);
        if (me->button() == Qt::LeftButton) {
            // Sync hover to click position (prevents hover/selection desync)
            m_lastHoverPos = me->pos();
            m_hoverInside = true;
            auto h = hitTest(me->pos());
            uint64_t newHoverId = (h.line >= 0) ? h.nodeId : 0;
            if (newHoverId != m_hoveredNodeId || h.line != m_hoveredLine) {
                m_hoveredNodeId = newHoverId;
                m_hoveredLine = h.line;
                applyHoverHighlight();
            }

            if (h.inFoldCol) {
                emit marginClicked(0, h.line, me->modifiers());
                return true;
            }
            // CommandRow: try chevron/ADDR edit or consume
            if (h.nodeId == kCommandRowId) {
                int tLine, tCol; EditTarget t;
                if (hitTestTarget(m_sci, m_meta, me->pos(), tLine, tCol, t)) {
                    if (t == EditTarget::TypeSelector)
                        emit typeSelectorRequested();
                    else
                        beginInlineEdit(t, tLine, tCol);
                }
                return true;  // consume all CommandRow clicks
            }
            if (h.nodeId != 0) {
                bool alreadySelected = m_currentSelIds.contains(h.nodeId);
                bool plain = !(me->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier));

                // Single-click on editable token of already-selected node → edit
                int tLine, tCol; EditTarget t;
                if (hitTestTarget(m_sci, m_meta, me->pos(), tLine, tCol, t)) {
                    if (alreadySelected && plain) {
                        m_pendingClickNodeId = 0;
                        return beginInlineEdit(t, tLine, tCol);
                    }
                }

                m_dragging = true;
                m_dragStarted = false;  // require threshold before extending
                m_dragStartPos = me->pos();
                m_dragLastLine = h.line;
                m_dragInitMods = me->modifiers();

                bool multi = m_currentSelIds.size() > 1;

                if (alreadySelected && multi && plain) {
                    // Defer: might be start of double-click-to-edit
                    m_pendingClickNodeId = h.nodeId;
                    m_pendingClickLine = h.line;
                    m_pendingClickMods = me->modifiers();
                } else {
                    emit nodeClicked(h.line, h.nodeId, me->modifiers());
                    m_pendingClickNodeId = 0;
                }
            }
            return true;  // consume ALL left-clicks (prevent QScintilla caret/cursor)
        }
    }
    // Drag-select: extend selection as mouse moves with button held
    // Requires minimum drag distance to prevent accidental micro-drag selection
    if (obj == m_sci->viewport() && !m_editState.active
        && event->type() == QEvent::MouseMove && m_dragging) {
        auto* me = static_cast<QMouseEvent*>(event);
        if (me->buttons() & Qt::LeftButton) {
            // Check drag threshold (8 pixels) before starting drag-selection
            if (!m_dragStarted) {
                int dy = me->pos().y() - m_dragStartPos.y();
                if (qAbs(dy) < 8)
                    return true;  // not yet a drag, but still consume (don't let Scintilla handle)
                m_dragStarted = true;
            }

            // Flush deferred click before extending drag
            if (m_pendingClickNodeId != 0) {
                emit nodeClicked(m_pendingClickLine, m_pendingClickNodeId,
                                 m_pendingClickMods);
                m_pendingClickNodeId = 0;
            }
            auto h = hitTest(me->pos());
            if (h.line >= 0 && h.line != m_dragLastLine && h.nodeId != 0) {
                emit nodeClicked(h.line, h.nodeId, m_dragInitMods | Qt::ShiftModifier);
                m_dragLastLine = h.line;
            }
        } else {
            m_dragging = false;
            m_dragStarted = false;
        }
    }
    if (obj == m_sci->viewport() && event->type() == QEvent::MouseButtonRelease) {
        m_dragging = false;
        m_dragStarted = false;
        if (m_pendingClickNodeId != 0) {
            emit nodeClicked(m_pendingClickLine, m_pendingClickNodeId,
                             m_pendingClickMods);
            m_pendingClickNodeId = 0;
        }
        return true;  // consume release (prevent QScintilla from acting on it)
    }
    // Double-click on offset margin → toggle absolute/relative
    if (obj == m_sci->viewport() && event->type() == QEvent::MouseButtonDblClick) {
        auto* me = static_cast<QMouseEvent*>(event);
        int margin0Width = (int)m_sci->SendScintilla(
            QsciScintillaBase::SCI_GETMARGINWIDTHN, 0UL, 0L);
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        if ((int)me->position().x() < margin0Width) {
#else
        if ((int)me->pos().x() < margin0Width) {
#endif
            m_relativeOffsets = !m_relativeOffsets;
            reformatMargins();
            return true;
        }
    }
    // Double-click during edit mode: select entire editable text
    if (obj == m_sci->viewport() && m_editState.active
        && event->type() == QEvent::MouseButtonDblClick) {
        m_sci->setSelection(m_editState.line, m_editState.spanStart,
                           m_editState.line, editEndCol());
        return true;
    }
    if (obj == m_sci->viewport() && !m_editState.active
        && event->type() == QEvent::MouseButtonDblClick) {
        auto* me = static_cast<QMouseEvent*>(event);
        int line, tCol; EditTarget t;
        if (hitTestTarget(m_sci, m_meta, me->pos(), line, tCol, t)) {
            m_pendingClickNodeId = 0;   // cancel deferred selection change
            // Narrow selection to this node before editing
            auto h = hitTest(me->pos());
            if (h.nodeId != 0 && h.nodeId != kCommandRowId)
                emit nodeClicked(h.line, h.nodeId, Qt::NoModifier);
            return beginInlineEdit(t, line, tCol);
        }
        return true;  // consume even on miss (prevent QScintilla word-select)
    }
    if (obj == m_sci && event->type() == QEvent::FocusOut) {
        auto* fe = static_cast<QFocusEvent*>(event);
        // Commit active edit on focus loss (click-away = save)
        // Deferred so autocomplete popup has time to register as active
        if (m_editState.active && fe->reason() != Qt::PopupFocusReason) {
            QTimer::singleShot(0, this, [this]() {
                if (m_editState.active && !m_sci->hasFocus()
                    && !m_sci->SendScintilla(QsciScintillaBase::SCI_AUTOCACTIVE))
                    commitInlineEdit();
            });
        }
        // Clear editable indicators when editor loses focus
        clearIndicatorLine(IND_EDITABLE, m_hintLine);
        m_hintLine = -1;
    }
    if (obj == m_sci && event->type() == QEvent::FocusIn) {
        int line, col;
        m_sci->getCursorPosition(&line, &col);
        updateEditableIndicators(line);
    }
    // Track mouse position for cursor updates (both edit and non-edit mode)
    if (obj == m_sci->viewport()) {
        // Ignore synthetic Leave from setText() during document refresh
        if (m_applyingDocument && event->type() == QEvent::Leave)
            return true;

        if (event->type() == QEvent::MouseMove) {
            m_lastHoverPos = static_cast<QMouseEvent*>(event)->pos();
            m_hoverInside = true;
        } else if (event->type() == QEvent::Leave) {
            m_hoverInside = false;
            if (!m_editState.active) {
                m_hoveredNodeId = 0;
                m_hoveredLine = -1;
                applyHoverHighlight();
            }
        } else if (event->type() == QEvent::Wheel) {
            m_lastHoverPos = m_sci->viewport()->mapFromGlobal(QCursor::pos());
            m_hoverInside = m_sci->viewport()->rect().contains(m_lastHoverPos);
        }
        // Resolve hovered nodeId on move/wheel (non-edit mode only)
        if (!m_editState.active &&
            (event->type() == QEvent::MouseMove || event->type() == QEvent::Wheel)) {
            auto h = hitTest(m_lastHoverPos);
            uint64_t newHoverId = (m_hoverInside && h.line >= 0) ? h.nodeId : 0;
            int newHoverLine = (m_hoverInside && h.line >= 0) ? h.line : -1;
            if (newHoverId != m_hoveredNodeId || newHoverLine != m_hoveredLine) {
                m_hoveredNodeId = newHoverId;
                m_hoveredLine = newHoverLine;
                applyHoverHighlight();
            }
        }
        // Update cursor on move/leave/wheel (both edit and non-edit mode)
        if (event->type() == QEvent::MouseMove
         || event->type() == QEvent::Leave
         || event->type() == QEvent::Wheel)
            applyHoverCursor();

        // Consume MouseMove in non-edit mode so QScintilla's internal handler
        // doesn't override our cursor (it resets to Arrow for read-only widgets)
        if (!m_editState.active && event->type() == QEvent::MouseMove)
            return true;
    }
    return QWidget::eventFilter(obj, event);
}

// ── Normal mode key handling ──

bool RcxEditor::handleNormalKey(QKeyEvent* ke) {
    switch (ke->key()) {
    case Qt::Key_F2:
        return beginInlineEdit(EditTarget::Name);
    case Qt::Key_T:
        if (ke->modifiers() == Qt::NoModifier)
            return beginInlineEdit(EditTarget::Type);
        return false;
    case Qt::Key_Return:
    case Qt::Key_Enter:
        return beginInlineEdit(EditTarget::Value);
    case Qt::Key_Tab: {
        EditTarget order[] = {EditTarget::Name, EditTarget::Type, EditTarget::Value,
                              EditTarget::ArrayElementType, EditTarget::ArrayElementCount,
                              EditTarget::PointerTarget};
        constexpr int N = 6;
        int start = 0;
        for (int i = 0; i < N; i++)
            if (order[i] == m_lastTabTarget) { start = (i + 1) % N; break; }
        for (int i = 0; i < N; i++) {
            EditTarget t = order[(start + i) % N];
            if (beginInlineEdit(t)) { m_lastTabTarget = t; return true; }
        }
        return true;
    }
    default:
        return false;
    }
}

// ── Edit mode key handling ──

bool RcxEditor::handleEditKey(QKeyEvent* ke) {
    // User list is handled via userListActivated signal, not here
    // SCI_AUTOCACTIVE is for autocomplete, not user lists

    switch (ke->key()) {
    case Qt::Key_Return:
    case Qt::Key_Enter:
        commitInlineEdit();
        return true;
    case Qt::Key_Tab:
        m_lastTabTarget = m_editState.target;
        commitInlineEdit();
        return true;
    case Qt::Key_Escape:
        cancelInlineEdit();
        return true;
    case Qt::Key_Up:
    case Qt::Key_Down:
    case Qt::Key_PageUp:
    case Qt::Key_PageDown:
        return true;  // block line navigation
    case Qt::Key_Delete: {
        int line, col;
        m_sci->getCursorPosition(&line, &col);
        if (col >= editEndCol()) return true;  // block at end
        return false;  // allow delete within span
    }
    case Qt::Key_Left:
    case Qt::Key_Backspace: {
        int line, col;
        m_sci->getCursorPosition(&line, &col);
        int minCol = m_editState.spanStart;
        // Don't allow backing into "0x" prefix
        if (m_editState.target == EditTarget::Value || m_editState.target == EditTarget::BaseAddress) {
            QString lineText = getLineText(m_sci, m_editState.line);
            if (lineText.mid(m_editState.spanStart, 2).startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
                minCol = m_editState.spanStart + 2;
        }
        // If there's an active selection, collapse it to the left end (Left only, not Backspace)
        if (ke->key() == Qt::Key_Left) {
            int sL, sC, eL, eC;
            m_sci->getSelection(&sL, &sC, &eL, &eC);
            if (sL >= 0 && (sL != eL || sC != eC)) {
                int leftEnd = qMax(qMin(sC, eC), minCol);
                m_sci->setCursorPosition(m_editState.line, leftEnd);
                return true;
            }
        }
        if (col <= minCol) return true;
        return false;
    }
    case Qt::Key_Right: {
        int line, col;
        m_sci->getCursorPosition(&line, &col);
        // If there's an active selection, collapse it to the right end first
        int sL, sC, eL, eC;
        m_sci->getSelection(&sL, &sC, &eL, &eC);
        if (sL >= 0 && (sL != eL || sC != eC)) {
            int rightEnd = qMin(qMax(sC, eC), editEndCol());
            m_sci->setCursorPosition(m_editState.line, rightEnd);
            return true;
        }
        if (col >= editEndCol()) return true;  // block past end
        return false;
    }
    case Qt::Key_Home: {
        int home = m_editState.spanStart;
        // Skip "0x" prefix for hex values
        if (m_editState.target == EditTarget::Value || m_editState.target == EditTarget::BaseAddress) {
            QString lineText = getLineText(m_sci, m_editState.line);
            if (lineText.mid(m_editState.spanStart, 2).startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
                home = m_editState.spanStart + 2;
        }
        m_sci->setCursorPosition(m_editState.line, home);
        return true;
    }
    case Qt::Key_End:
        m_sci->setCursorPosition(m_editState.line, editEndCol());
        return true;
    case Qt::Key_V:
        if (ke->modifiers() & Qt::ControlModifier) {
            // Sanitized paste: strip newlines (and backticks for base addresses)
            QString clip = QApplication::clipboard()->text();
            clip.remove('\n');
            clip.remove('\r');
            if (m_editState.target == EditTarget::BaseAddress)
                clip.remove('`');
            if (!clip.isEmpty()) {
                QByteArray utf8 = clip.toUtf8();
                m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACESEL,
                                     (uintptr_t)0, utf8.constData());
            }
            return true;
        }
        return false;
    default:
        return false;
    }
}

// ── Begin inline edit ──

bool RcxEditor::beginInlineEdit(EditTarget target, int line, int col) {
    if (target == EditTarget::TypeSelector) return false;  // handled by popup, not inline edit

    // Type, array element type and pointer target: handled by TypeSelectorPopup, not inline edit
    if (target == EditTarget::Type || target == EditTarget::ArrayElementType || target == EditTarget::PointerTarget) {
        if (line < 0) {
            int c;
            m_sci->getCursorPosition(&line, &c);
        }
        auto* lm = metaForLine(line);
        if (!lm) return false;
        // Reject lines that don't support type editing
        if (lm->nodeIdx < 0) return false;              // CommandRow etc.
        if (lm->lineKind == LineKind::Footer) return false;
        // Position popup at the type column start
        ColumnSpan ts = typeSpan(*lm);
        long typePos = posFromCol(m_sci, line, ts.valid ? ts.start : 0);
        int lineH = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_TEXTHEIGHT, (unsigned long)line);
        int x = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTXFROMPOSITION, (unsigned long)0, typePos);
        int y = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTYFROMPOSITION, (unsigned long)0, typePos);
        QPoint pos = m_sci->viewport()->mapToGlobal(QPoint(x, y + lineH));
        emit typePickerRequested(target, lm->nodeIdx, pos);
        return true;
    }

    if (m_editState.active) return false;
    m_hoveredNodeId = 0;
    m_hoveredLine = -1;
    applyHoverHighlight();
    // Dismiss hover popups so they get recreated with Set buttons once edit starts
    if (m_historyPopup)
        static_cast<ValueHistoryPopup*>(m_historyPopup)->dismiss();
    if (m_structPreviewPopup)
        static_cast<StructPreviewPopup*>(m_structPreviewPopup)->dismiss();
    // Clear editable-token color hints (de-emphasize non-active tokens)
    clearIndicatorLine(IND_EDITABLE, m_hintLine);
    m_hintLine = -1;

    if (line >= 0) {
        m_sci->setCursorPosition(line, col >= 0 ? col : 0);
    }
    if (col < 0) {
        m_sci->getCursorPosition(&line, &col);
    }
    auto* lm = metaForLine(line);
    if (!lm) return false;
    // Allow nodeIdx=-1 only for CommandRow editing (command bar)
    if (lm->nodeIdx < 0 && !(lm->lineKind == LineKind::CommandRow &&
        (target == EditTarget::BaseAddress || target == EditTarget::Source
         || target == EditTarget::RootClassType || target == EditTarget::RootClassName)))
        return false;
    // Hex nodes: only Type is editable (ASCII preview + hex bytes are display-only)
    if ((target == EditTarget::Name || target == EditTarget::Value) && isHexNode(lm->nodeKind))
        return false;

    QString lineText;
    NormalizedSpan norm;
    if (!resolvedSpanFor(line, target, norm, &lineText)) return false;

    QString trimmed = lineText.mid(norm.start, norm.end - norm.start);

    int vecComponent = 0;  // which vector/matrix component

    // Helper: parse comma-separated components, narrow span to clicked one
    auto narrowToComponent = [&](const QString& inner, int innerAbsStart) {
        QVector<int> compStarts, compEnds;
        for (int i = 0; i < inner.size(); i++) {
            if (inner[i] == ',') {
                compEnds.append(i);
                int next = i + 1;
                while (next < inner.size() && inner[next] == ' ') next++;
                compStarts.append(next);
            }
        }
        compStarts.prepend(0);
        compEnds.append(inner.size());

        int relCol = col - innerAbsStart;
        vecComponent = 0;
        for (int i = 0; i < compStarts.size(); i++) {
            if (relCol >= compStarts[i] && (i == compStarts.size() - 1 || relCol < compStarts[i + 1]))
                { vecComponent = i; break; }
        }
        if (vecComponent >= compStarts.size()) vecComponent = compStarts.size() - 1;

        int cStart = innerAbsStart + compStarts[vecComponent];
        int cEnd = innerAbsStart + compEnds[vecComponent];
        while (cEnd > cStart && lineText[cEnd - 1] == ' ') cEnd--;
        norm.start = cStart;
        norm.end = cEnd;
        trimmed = lineText.mid(norm.start, norm.end - norm.start);
    };

    // For vector value editing: narrow span to the clicked component
    if (target == EditTarget::Value && isVectorKind(lm->nodeKind)) {
        narrowToComponent(trimmed, norm.start);
    }

    // For Mat4x4 value editing: skip "rowN [...]" and narrow to clicked component
    if (target == EditTarget::Value && isMatrixKind(lm->nodeKind)) {
        int bracketOpen = trimmed.indexOf('[');
        int bracketClose = trimmed.lastIndexOf(']');
        if (bracketOpen < 0 || bracketClose <= bracketOpen)
            return false;
        QString inner = trimmed.mid(bracketOpen + 1, bracketClose - bracketOpen - 1);
        int innerAbsStart = norm.start + bracketOpen + 1;
        narrowToComponent(inner, innerAbsStart);
    }

    m_editState.active = true;
    m_editState.line = line;
    m_editState.nodeIdx = lm->nodeIdx;
    m_editState.subLine = lm->subLine;
    m_editState.target = target;
    m_editState.spanStart = norm.start;
    m_editState.original = trimmed;
    m_editState.linelenAfterReplace = lineText.size();
    m_editState.editKind = lm->nodeKind;
    if (isVectorKind(lm->nodeKind)) {
        m_editState.subLine = vecComponent;
        m_editState.editKind = NodeKind::Float;
    }
    if (isMatrixKind(lm->nodeKind)) {
        m_editState.subLine = lm->subLine * 4 + vecComponent;  // flat index 0-15
        m_editState.editKind = NodeKind::Float;
    }

    // Store fixed comment column position for value editing
    // Use large lineLength so commentCol is always computed (padding added dynamically)
    if (target == EditTarget::Value) {
        ColumnSpan cs = commentSpanFor(*lm, 9999, lm->effectiveTypeW, lm->effectiveNameW);
        m_editState.commentCol = cs.valid ? cs.start : -1;
        m_editState.lastValidationOk = true;  // original value is always valid
    } else {
        m_editState.commentCol = -1;
    }

    // Disable Scintilla undo during inline edit
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETUNDOCOLLECTION, (long)0);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETCARETWIDTH, 1);
    m_sci->setReadOnly(false);

    // For value editing: extend line with trailing spaces for the edit comment area
    // (comment padding is no longer baked into every line to avoid unnecessary scroll width)
    if (target == EditTarget::Value && m_editState.commentCol >= 0) {
        int commentStart = norm.end + 2;
        int neededLen = commentStart + kColComment;
        int currentLen = (int)lineText.size();
        if (currentLen < neededLen) {
            int extend = neededLen - currentLen;
            long lineEndPos = posFromCol(m_sci, line, currentLen);
            QString pad(extend, ' ');
            QByteArray padUtf8 = pad.toUtf8();
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETSTART, lineEndPos);
            m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETEND, lineEndPos);
            m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACETARGET,
                                 (uintptr_t)padUtf8.size(), padUtf8.constData());
            m_editState.linelenAfterReplace += extend;
        }
    }

    // Switch to I-beam for editing (skip for picker-based targets)
    if (target != EditTarget::Type && target != EditTarget::Source
        && target != EditTarget::ArrayElementType && target != EditTarget::PointerTarget
        && target != EditTarget::RootClassType) {
        m_sci->viewport()->setCursor(Qt::IBeamCursor);
    }

    // Re-enable selection rendering for inline edit (skip for picker-based targets)
    bool isPicker = (target == EditTarget::Type || target == EditTarget::Source
                     || target == EditTarget::ArrayElementType
                     || target == EditTarget::PointerTarget
                     || target == EditTarget::RootClassType);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSELFORE, (long)0, (long)0);
    if (!isPicker)
        m_sci->SendScintilla(QsciScintillaBase::SCI_SETSELBACK, (long)1,
                             ThemeManager::instance().current().selection);

    // Use correct UTF-8 position conversion (not lineStart + col!)
    m_editState.posStart = posFromCol(m_sci, line, norm.start);
    m_editState.posEnd = posFromCol(m_sci, line, norm.end);

    // For Value/BaseAddress: skip 0x prefix in selection (select only the number)
    long selStart = m_editState.posStart;
    if ((target == EditTarget::Value || target == EditTarget::BaseAddress) &&
        trimmed.startsWith(QStringLiteral("0x"), Qt::CaseInsensitive)) {
        selStart = m_editState.posStart + 2;  // Skip "0x"
    }
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSEL, selStart, m_editState.posEnd);

    // Show initial edit hint in comment column
    if (target == EditTarget::Value)
        setEditComment(QStringLiteral("Enter=Save Esc=Cancel"));

    // Note: Type, ArrayElementType, PointerTarget are handled by TypeSelectorPopup
    // and exit early above (never reach here).
    if (target == EditTarget::Source)
        QTimer::singleShot(0, this, &RcxEditor::showSourcePicker);
    // RootClassType is no longer editable via click — use right-click conversion instead
    // Refresh hover cursor so value history popup appears with Set buttons immediately
    if (target == EditTarget::Value)
        QTimer::singleShot(0, this, &RcxEditor::applyHoverCursor);
    return true;
}

int RcxEditor::editEndCol() const {
    QString lineText = getLineText(m_sci, m_editState.line);
    int delta = lineText.size() - m_editState.linelenAfterReplace;
    return m_editState.spanStart + m_editState.original.size() + delta;
}

void RcxEditor::clampEditSelection() {
    if (!m_editState.active) return;

    if (m_clampingSelection) return;
    m_clampingSelection = true;

    int selStartLine, selStartCol, selEndLine, selEndCol;
    m_sci->getSelection(&selStartLine, &selStartCol, &selEndLine, &selEndCol);

    int editEnd = editEndCol();
    bool isCursor = (selStartLine == selEndLine && selStartCol == selEndCol);

    // Don't fight cursor positioning - only clamp actual selections
    if (isCursor) {
        m_clampingSelection = false;
        return;
    }

    // Actual selection - clamp both ends to edit span
    bool clamped = false;

    // Force to edit line
    if (selStartLine != m_editState.line || selEndLine != m_editState.line) {
        m_sci->setSelection(m_editState.line, m_editState.spanStart,
                           m_editState.line, editEnd);
        m_clampingSelection = false;
        return;
    }

    if (selStartCol < m_editState.spanStart) { selStartCol = m_editState.spanStart; clamped = true; }
    if (selEndCol < m_editState.spanStart) { selEndCol = m_editState.spanStart; clamped = true; }
    if (selStartCol > editEnd) { selStartCol = editEnd; clamped = true; }
    if (selEndCol > editEnd) { selEndCol = editEnd; clamped = true; }

    if (clamped)
        m_sci->setSelection(selStartLine, selStartCol, selEndLine, selEndCol);

    m_clampingSelection = false;
}

// ── Commit inline edit ──

void RcxEditor::commitInlineEdit() {
    if (!m_editState.active) return;

    QString lineText = getLineText(m_sci, m_editState.line);
    int currentLen = lineText.size();
    int delta = currentLen - m_editState.linelenAfterReplace;
    int editedLen = m_editState.original.size() + delta;

    QString editedText;
    if (editedLen > 0)
        editedText = lineText.mid(m_editState.spanStart, editedLen).trimmed();

    // For Type edits: if nothing changed, commit original
    if (m_editState.target == EditTarget::Type && editedText.isEmpty())
        editedText = m_editState.original;

    // Grab resolved address from LineMeta before endInlineEdit clears state
    const LineMeta* lm = metaForLine(m_editState.line);
    uint64_t addr = lm ? lm->offsetAddr : 0;

    auto info = endInlineEdit();
    emit inlineEditCommitted(info.nodeIdx, info.subLine, info.target, editedText, addr);
}

// ── Cancel inline edit ──

void RcxEditor::cancelInlineEdit() {
    if (!m_editState.active) return;

    endInlineEdit();
    emit inlineEditCancelled();
}

// ── Type picker (user list) ──

void RcxEditor::showTypeAutocomplete() {
    if (!m_editState.active ||
        (m_editState.target != EditTarget::Type && m_editState.target != EditTarget::ArrayElementType))
        return;
    // Replace original type with spaces (keeps layout, clears for typing)
    int len = m_editState.original.size();
    QString spaces(len, ' ');
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSEL,
                         m_editState.posStart, m_editState.posEnd);
    m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACESEL,
                         (uintptr_t)0, spaces.toUtf8().constData());

    // Position cursor at start
    m_sci->SendScintilla(QsciScintillaBase::SCI_GOTOPOS, m_editState.posStart);

    showTypeListFiltered(QString());  // Show full list initially
}

void RcxEditor::showTypeListFiltered(const QString& filter) {
    if (!m_editState.active ||
        (m_editState.target != EditTarget::Type && m_editState.target != EditTarget::ArrayElementType))
        return;

    // Combine native types with custom (struct) type names
    QStringList all = allTypeNamesForUI();
    for (const QString& ct : m_customTypeNames) {
        if (!all.contains(ct))
            all << ct;
    }
    all.sort(Qt::CaseInsensitive);

    // Filter by prefix
    QStringList filtered;
    for (const QString& t : all) {
        if (filter.isEmpty() || t.startsWith(filter, Qt::CaseInsensitive))
            filtered << t;
    }
    if (filtered.isEmpty()) return;  // No matches - keep list hidden

    // Show user list (id=1 for types) - selection handled by userListActivated signal
    QByteArray list = filtered.join('\n').toUtf8();
    m_sci->SendScintilla(QsciScintillaBase::SCI_AUTOCSETSEPARATOR, (long)'\n');
    m_sci->SendScintilla(QsciScintillaBase::SCI_USERLISTSHOW,
                         (uintptr_t)1, list.constData());
    // Force Arrow cursor immediately (don't wait for mouse move)
    m_sci->viewport()->setCursor(Qt::ArrowCursor);
}

void RcxEditor::showSourcePicker() {
    if (!m_editState.active || m_editState.target != EditTarget::Source)
        return;
    QMenu menu;
    QFont menuFont = editorFont();
    int zoom = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETZOOM);
    menuFont.setPointSize(menuFont.pointSize() + zoom);
    menu.setFont(menuFont);
    menu.addAction("File");

    // Add all registered providers from global registry
    const auto& providers = ProviderRegistry::instance().providers();
    for (const auto& provider : providers)
        menu.addAction(provider.name);

    // Saved sources below separator (with checkmarks)
    if (!m_savedSourceDisplay.isEmpty()) {
        menu.addSeparator();
        for (int i = 0; i < m_savedSourceDisplay.size(); i++) {
            auto* act = menu.addAction(m_savedSourceDisplay[i].text);
            act->setCheckable(true);
            act->setChecked(m_savedSourceDisplay[i].active);
            act->setData(i);
        }
        menu.addSeparator();
        auto* clearAct = menu.addAction("Clear All");
        clearAct->setData(QStringLiteral("#clear"));
    }

    int lineH = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_TEXTHEIGHT, 0);
    int x = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTXFROMPOSITION,
                                       0, m_editState.posStart);
    int y = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTYFROMPOSITION,
                                       0, m_editState.posStart);
    QPoint pos = m_sci->viewport()->mapToGlobal(QPoint(x, y + lineH));

    QAction* sel = menu.exec(pos);
    if (sel) {
        const LineMeta* lm = metaForLine(m_editState.line);
        uint64_t addr = lm ? lm->offsetAddr : 0;
        auto info = endInlineEdit();
        QString text = sel->text();
        if (sel->data().toString() == QStringLiteral("#clear"))
            text = QStringLiteral("#clear");
        else if (sel->data().isValid())
            text = QStringLiteral("#saved:") + QString::number(sel->data().toInt());
        emit inlineEditCommitted(info.nodeIdx, info.subLine, info.target, text, addr);
    } else {
        cancelInlineEdit();
    }
}

void RcxEditor::updateTypeListFilter() {
    if (!m_editState.active ||
        (m_editState.target != EditTarget::Type && m_editState.target != EditTarget::ArrayElementType))
        return;

    // Get currently typed text from line
    QString lineText = getLineText(m_sci, m_editState.line);
    long curPos = m_sci->SendScintilla(QsciScintillaBase::SCI_GETCURRENTPOS);
    int col = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETCOLUMN,
                                         (unsigned long)curPos);

    // Extract text from spanStart to cursor
    int len = col - m_editState.spanStart;
    if (len <= 0) {
        showTypeListFiltered(QString());  // Show full list
        return;
    }

    QString typed = lineText.mid(m_editState.spanStart, len);
    showTypeListFiltered(typed);
}

// ── Pointer target picker ──

void RcxEditor::showPointerTargetPicker() {
    if (!m_editState.active || m_editState.target != EditTarget::PointerTarget)
        return;
    // Replace original target with spaces (keeps layout, clears for typing)
    int len = m_editState.original.size();
    QString spaces(len, ' ');
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETSEL,
                         m_editState.posStart, m_editState.posEnd);
    m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACESEL,
                         (uintptr_t)0, spaces.toUtf8().constData());
    m_sci->SendScintilla(QsciScintillaBase::SCI_GOTOPOS, m_editState.posStart);
    showPointerTargetListFiltered(QString());
}

void RcxEditor::showPointerTargetListFiltered(const QString& filter) {
    if (!m_editState.active || m_editState.target != EditTarget::PointerTarget)
        return;

    // Build list: "void" + all struct type names
    QStringList all;
    all << QStringLiteral("void");
    for (const QString& ct : m_customTypeNames) {
        if (!all.contains(ct))
            all << ct;
    }
    all.sort(Qt::CaseInsensitive);
    // Ensure "void" is always first
    all.removeAll(QStringLiteral("void"));
    all.prepend(QStringLiteral("void"));

    QStringList filtered;
    for (const QString& t : all) {
        if (filter.isEmpty() || t.startsWith(filter, Qt::CaseInsensitive))
            filtered << t;
    }
    if (filtered.isEmpty()) return;

    QByteArray list = filtered.join('\n').toUtf8();
    m_sci->SendScintilla(QsciScintillaBase::SCI_AUTOCSETSEPARATOR, (long)'\n');
    m_sci->SendScintilla(QsciScintillaBase::SCI_USERLISTSHOW,
                         (uintptr_t)1, list.constData());
    // Force Arrow cursor immediately (don't wait for mouse move)
    m_sci->viewport()->setCursor(Qt::ArrowCursor);
}

void RcxEditor::updatePointerTargetFilter() {
    if (!m_editState.active || m_editState.target != EditTarget::PointerTarget)
        return;

    QString lineText = getLineText(m_sci, m_editState.line);
    long curPos = m_sci->SendScintilla(QsciScintillaBase::SCI_GETCURRENTPOS);
    int col = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETCOLUMN,
                                         (unsigned long)curPos);
    int len = col - m_editState.spanStart;
    if (len <= 0) {
        showPointerTargetListFiltered(QString());
        return;
    }
    QString typed = lineText.mid(m_editState.spanStart, len);
    showPointerTargetListFiltered(typed);
}

// ── Editable-field text-color indicator ──

void RcxEditor::paintEditableSpans(int line) {
    const LineMeta* lm = metaForLine(line);
    if (!lm) return;
    // CommandRow: paint Source/BaseAddress + root class (type+name) spans
    if (lm->lineKind == LineKind::CommandRow) {
        NormalizedSpan norm;
        if (resolvedSpanFor(line, EditTarget::Source, norm))
            fillIndicatorCols(IND_EDITABLE, line, norm.start, norm.end);
        if (resolvedSpanFor(line, EditTarget::BaseAddress, norm))
            fillIndicatorCols(IND_EDITABLE, line, norm.start, norm.end);
        // RootClassType no longer shown as editable — right-click conversion instead
        if (resolvedSpanFor(line, EditTarget::RootClassName, norm))
            fillIndicatorCols(IND_EDITABLE, line, norm.start, norm.end);
        return;
    }
    if (isSyntheticLine(*lm)) return;
    NormalizedSpan norm;
    for (EditTarget t : {EditTarget::Type, EditTarget::Name, EditTarget::Value,
                         EditTarget::ArrayElementType, EditTarget::ArrayElementCount,
                         EditTarget::PointerTarget}) {
        if (resolvedSpanFor(line, t, norm))
            fillIndicatorCols(IND_EDITABLE, line, norm.start, norm.end);
    }
}

void RcxEditor::updateEditableIndicators(int line) {
    if (m_editState.active) return;
    if (line == m_hintLine) return;

    // No cursor hints when selection is empty (prevents desync during batch ops)
    if (m_currentSelIds.isEmpty()) {
        if (m_hintLine >= 0) {
            clearIndicatorLine(IND_EDITABLE, m_hintLine);
            m_hintLine = -1;
        }
        return;
    }

    // Helper to check if a line's node is selected (handles footer/array element IDs)
    auto isLineSelected = [this](const LineMeta* lm) -> bool {
        if (!lm) return false;
        uint64_t checkId;
        if (lm->lineKind == LineKind::Footer)
            checkId = lm->nodeId | kFooterIdBit;
        else if (lm->isArrayElement && lm->arrayElementIdx >= 0)
            checkId = makeArrayElemSelId(lm->nodeId, lm->arrayElementIdx);
        else
            checkId = lm->nodeId;
        return m_currentSelIds.contains(checkId);
    };

    // If new line is selected, its indicators are managed by applySelectionOverlay
    // But we still need to clear the old non-selected hint line
    const LineMeta* newLm = metaForLine(line);
    if (isLineSelected(newLm)) {
        if (m_hintLine >= 0) {
            const LineMeta* oldLm = metaForLine(m_hintLine);
            if (!isLineSelected(oldLm))
                clearIndicatorLine(IND_EDITABLE, m_hintLine);
        }
        m_hintLine = line;
        return;
    }

    // Clear old cursor line (only if not a selected node)
    if (m_hintLine >= 0) {
        const LineMeta* oldLm = metaForLine(m_hintLine);
        if (!isLineSelected(oldLm))
            clearIndicatorLine(IND_EDITABLE, m_hintLine);
    }

    m_hintLine = line;
    paintEditableSpans(line);
}

// ── Hover cursor ──

void RcxEditor::applyHoverCursor() {
    // Clear previous hover span indicators
    for (int ln : m_hoverSpanLines)
        clearIndicatorLine(IND_HOVER_SPAN, ln);
    m_hoverSpanLines.clear();

    // Lock cursor to Arrow during drag-selection (prevents flicker)
    if (m_dragStarted) {
        m_sci->viewport()->setCursor(Qt::ArrowCursor);
        return;
    }

    // Edit mode: IBeam inside edit span, Arrow outside
    if (m_editState.active) {
        if (m_sci->isListActive()) {
            m_sci->viewport()->setCursor(Qt::ArrowCursor);
        } else {
            auto h = hitTest(m_lastHoverPos);
            if (h.line == m_editState.line &&
                h.col >= m_editState.spanStart && h.col <= editEndCol()) {
                m_sci->viewport()->setCursor(Qt::IBeamCursor);
            } else {
                m_sci->viewport()->setCursor(Qt::ArrowCursor);
            }
        }
        // Value history popup — only during inline value editing on a heated node
        {
            bool showPopup = false;
            if (m_valueHistory && m_editState.target == EditTarget::Value
                && m_editState.line >= 0 && m_editState.line < m_meta.size()) {
                const LineMeta& lm = m_meta[m_editState.line];
                if (lm.heatLevel > 0 && lm.nodeId != 0) {
                    auto it = m_valueHistory->find(lm.nodeId);
                    if (it != m_valueHistory->end() && it->uniqueCount() > 1) {
                        if (!m_historyPopup)
                            m_historyPopup = new ValueHistoryPopup(this);
                        auto* popup = static_cast<ValueHistoryPopup*>(m_historyPopup);
                        popup->setOnSet([this](const QString& val) {
                            if (!m_editState.active) return;
                            long endPos = posFromCol(m_sci, m_editState.line, editEndCol());
                            m_sci->SendScintilla(QsciScintillaBase::SCI_SETSEL,
                                                 m_editState.posStart, endPos);
                            QByteArray utf8 = val.toUtf8();
                            m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACESEL,
                                                 (uintptr_t)0, utf8.constData());
                        });
                        popup->populate(lm.nodeId, *it, editorFont(), true);
                        int px = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTXFROMPOSITION,
                                                           (unsigned long)0, m_editState.posStart);
                        int py = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTYFROMPOSITION,
                                                           (unsigned long)0, m_editState.posStart);
                        int lh = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_TEXTHEIGHT,
                                                           (unsigned long)m_editState.line);
                        QPoint anchor = m_sci->viewport()->mapToGlobal(QPoint(px, py + lh));
                        popup->showAt(anchor);
                        showPopup = true;
                    }
                }
            }
            if (!showPopup && m_historyPopup && m_historyPopup->isVisible())
                static_cast<ValueHistoryPopup*>(m_historyPopup)->dismiss();
        }
        // Always dismiss disasm/preview popups during inline editing
        if (m_disasmPopup && m_disasmPopup->isVisible())
            static_cast<DisasmPopup*>(m_disasmPopup)->dismiss();
        if (m_structPreviewPopup && m_structPreviewPopup->isVisible())
            static_cast<StructPreviewPopup*>(m_structPreviewPopup)->dismiss();
        return;
    }

    // Mouse left viewport - set Arrow, dismiss popups
    // (but not during applyDocument — the Leave is synthetic from setText)
    if (!m_hoverInside) {
        if (m_historyPopup && !m_applyingDocument)
            static_cast<ValueHistoryPopup*>(m_historyPopup)->dismiss();
        if (m_disasmPopup && !m_applyingDocument)
            static_cast<DisasmPopup*>(m_disasmPopup)->dismiss();
        if (m_structPreviewPopup && !m_applyingDocument)
            static_cast<StructPreviewPopup*>(m_structPreviewPopup)->dismiss();
        m_sci->viewport()->setCursor(Qt::ArrowCursor);
        return;
    }

    // If autocomplete/user list popup is active, use arrow cursor
    if (m_sci->isListActive()) {
        m_sci->viewport()->setCursor(Qt::ArrowCursor);
        return;
    }

    auto h = hitTest(m_lastHoverPos);
    int line, hCol; EditTarget t;
    bool tokenHit = hitTestTarget(m_sci, m_meta, m_lastHoverPos, line, hCol, t);

    // Skip hover span on footer lines (nothing editable)
    int hoverLine = h.line;
    bool isFooterLine = (hoverLine >= 0 && hoverLine < m_meta.size()
                         && m_meta[hoverLine].lineKind == LineKind::Footer);

    // Apply hover span indicator for editable tokens
    if (tokenHit && !isFooterLine) {
        NormalizedSpan span;
        QString lineText;
        if (resolvedSpanFor(line, t, span, &lineText)) {
            // For vector/matrix values: narrow hover to the component under cursor
            bool narrowed = false;
            if (t == EditTarget::Value && line >= 0 && line < m_meta.size()) {
                const auto& lm = m_meta[line];
                if (isVectorKind(lm.nodeKind) || isMatrixKind(lm.nodeKind)) {
                    QString val = lineText.mid(span.start, span.end - span.start);
                    int innerStart = span.start;
                    QString inner = val;
                    if (isMatrixKind(lm.nodeKind)) {
                        int bo = val.indexOf('['), bc = val.lastIndexOf(']');
                        if (bo >= 0 && bc > bo) {
                            inner = val.mid(bo + 1, bc - bo - 1);
                            innerStart = span.start + bo + 1;
                        }
                    }
                    QVector<int> starts, ends;
                    starts.append(0);
                    for (int i = 0; i < inner.size(); i++) {
                        if (inner[i] == ',') {
                            ends.append(i);
                            int n = i + 1;
                            while (n < inner.size() && inner[n] == ' ') n++;
                            starts.append(n);
                        }
                    }
                    ends.append(inner.size());
                    // Trim trailing spaces from last component to get true end
                    int lastEnd = ends.last();
                    while (lastEnd > 0 && inner[lastEnd - 1] == ' ') lastEnd--;
                    // Skip highlight if cursor is past the last component
                    int relCol = h.col - innerStart;
                    if (relCol >= lastEnd) {
                        narrowed = true;  // suppress highlight entirely
                    } else {
                        int comp = 0;
                        for (int i = 0; i < starts.size(); i++) {
                            if (relCol >= starts[i] && (i == starts.size() - 1 || relCol < starts[i + 1])) {
                                comp = i; break;
                            }
                        }
                        int cS = innerStart + starts[comp];
                        int cE = innerStart + ends[comp];
                        while (cE > cS && lineText[cE - 1] == ' ') cE--;
                        span.start = cS;
                        span.end = cE;
                        narrowed = true;
                        fillIndicatorCols(IND_HOVER_SPAN, line, span.start, span.end);
                        m_hoverSpanLines.append(line);
                    }
                }
                // Narrow pointer-like nodes to address portion only (exclude symbol)
                if (!narrowed && (isFuncPtr(lm.nodeKind)
                    || lm.nodeKind == NodeKind::Pointer32
                    || lm.nodeKind == NodeKind::Pointer64)) {
                    ColumnSpan full = valueSpan(lm, lineText.size(), lm.effectiveTypeW, lm.effectiveNameW);
                    ColumnSpan narrow = narrowPtrValueSpan(lm, full, lineText);
                    if (h.col >= narrow.start && h.col < narrow.end) {
                        fillIndicatorCols(IND_HOVER_SPAN, line, narrow.start, narrow.end);
                        m_hoverSpanLines.append(line);
                    }
                    narrowed = true;
                }
            }
            if (!narrowed && h.col >= span.start && h.col < span.end) {
                fillIndicatorCols(IND_HOVER_SPAN, line, span.start, span.end);
                m_hoverSpanLines.append(line);
            }
        }
    }

    // Apply hover span on fold arrows (▸/▾) — same visual feedback as editable tokens
    if (h.inFoldCol && h.line >= 0 && h.line < m_meta.size()) {
        fillIndicatorCols(IND_HOVER_SPAN, h.line, 0, kFoldCol);
        m_hoverSpanLines.append(h.line);
    }

    // Value history popup on hover (read-only, no buttons)
    // Skip FuncPtr and void-Pointer nodes — they use the disasm popup instead.
    {
        bool showPopup = false;
        if (m_valueHistory && h.line >= 0 && h.line < m_meta.size()) {
            const LineMeta& lm = m_meta[h.line];
            bool skipForDisasm = isFuncPtr(lm.nodeKind)
                || ((lm.nodeKind == NodeKind::Pointer32
                     || lm.nodeKind == NodeKind::Pointer64)
                    && lm.pointerTargetName.isEmpty());
            if (lm.heatLevel > 0 && lm.nodeId != 0 && !skipForDisasm) {
                auto it = m_valueHistory->find(lm.nodeId);
                if (it != m_valueHistory->end() && it->uniqueCount() > 1) {
                    QString lineText = getLineText(m_sci, h.line);
                    ColumnSpan vs = valueSpan(lm, lineText.size(), lm.effectiveTypeW, lm.effectiveNameW);
                    if (vs.valid && h.col >= vs.start && h.col < vs.end) {
                        if (!m_historyPopup)
                            m_historyPopup = new ValueHistoryPopup(this);
                        auto* popup = static_cast<ValueHistoryPopup*>(m_historyPopup);
                        popup->populate(lm.nodeId, *it, editorFont(), false);
                        long linePos = m_sci->SendScintilla(QsciScintillaBase::SCI_POSITIONFROMLINE,
                                                            (unsigned long)h.line);
                        long byteOff = lineText.left(vs.start).toUtf8().size();
                        int px = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTXFROMPOSITION,
                                                           (unsigned long)0, linePos + byteOff);
                        int py = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_POINTYFROMPOSITION,
                                                           (unsigned long)0, linePos);
                        int lh = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_TEXTHEIGHT,
                                                           (unsigned long)h.line);
                        QPoint anchor = m_sci->viewport()->mapToGlobal(QPoint(px, py + lh));
                        popup->showAt(anchor);
                        showPopup = true;
                    }
                }
            }
        }
        if (!showPopup && m_historyPopup && m_historyPopup->isVisible())
            static_cast<ValueHistoryPopup*>(m_historyPopup)->dismiss();
    }

    // Disasm / hex-dump popup on hover for FuncPtr and void Pointer nodes
    {
        bool showDisasm = false;
        if (m_disasmProvider && m_disasmTree && h.line >= 0 && h.line < m_meta.size()) {
            const LineMeta& lm = m_meta[h.line];
            bool isFP = isFuncPtr(lm.nodeKind);
            bool isVoidPtr = (lm.nodeKind == NodeKind::Pointer32
                              || lm.nodeKind == NodeKind::Pointer64)
                             && lm.pointerTargetName.isEmpty();
            if ((isFP || isVoidPtr) && lm.nodeIdx >= 0
                && lm.nodeIdx < m_disasmTree->nodes.size()) {
                // Check hover is over the address portion of the value column
                QString lineText = getLineText(m_sci, h.line);
                ColumnSpan vs = narrowPtrValueSpan(lm,
                    valueSpan(lm, lineText.size(), lm.effectiveTypeW, lm.effectiveNameW),
                    lineText);
                if (vs.valid && h.col >= vs.start && h.col < vs.end) {
                    const Node& node = m_disasmTree->nodes[lm.nodeIdx];
                    // For void ptrs, only show hex dump if refId == 0
                    if (!isVoidPtr || node.refId == 0) {
                        bool is64 = (lm.nodeKind == NodeKind::FuncPtr64
                                     || lm.nodeKind == NodeKind::Pointer64);
                        // Use composed address (absolute, correct for pointer-expanded nodes)
                        uint64_t provAddr = lm.offsetAddr;
                        uint64_t ptrVal = is64
                            ? m_disasmProvider->readU64(provAddr)
                            : (uint64_t)m_disasmProvider->readU32(provAddr);
                        if (ptrVal != 0 && ptrVal != UINT64_MAX
                            && !(is64 == false && ptrVal == 0xFFFFFFFF)) {
                            // Read code bytes from the function target address.
                            // Use the real provider (not snapshot) because function
                            // code lives at arbitrary process addresses that aren't
                            // in the snapshot page table.
                            const Provider* codeProv = m_disasmRealProv
                                ? m_disasmRealProv : m_disasmProvider;
                            constexpr int kMaxRead = 128;
                            uint64_t codeAddr = ptrVal;
                            QByteArray bytes(kMaxRead, Qt::Uninitialized);
                            bool readOk = codeProv->read(codeAddr, bytes.data(), kMaxRead);
                            if (readOk) {
                                QString title, body;
                                if (isFP) {
                                    title = QStringLiteral("Disassembly");
                                    body = disassemble(bytes, ptrVal,
                                                       is64 ? 64 : 32, kMaxRead);
                                } else {
                                    title = QStringLiteral("Hex Dump");
                                    body = hexDump(bytes, ptrVal, kMaxRead);
                                }
                                // Cap at 6 lines so the popup stays compact
                                {
                                    const int kMaxLines = 6;
                                    int nth = 0, idx = 0;
                                    while (nth < kMaxLines && (idx = body.indexOf('\n', idx)) != -1)
                                        { ++nth; ++idx; }
                                    if (nth == kMaxLines && idx < body.size()) {
                                        body.truncate(idx);
                                        body += QStringLiteral("...");
                                    }
                                }
                                if (!body.isEmpty()) {
                                    if (!m_disasmPopup)
                                        m_disasmPopup = new DisasmPopup(this);
                                    auto* popup = static_cast<DisasmPopup*>(
                                        m_disasmPopup);
                                    popup->populate(lm.nodeId, title, body,
                                                    editorFont());
                                    long linePos = m_sci->SendScintilla(
                                        QsciScintillaBase::SCI_POSITIONFROMLINE,
                                        (unsigned long)h.line);
                                    long byteOff = lineText.left(vs.start)
                                        .toUtf8().size();
                                    int px = (int)m_sci->SendScintilla(
                                        QsciScintillaBase::SCI_POINTXFROMPOSITION,
                                        (unsigned long)0, linePos + byteOff);
                                    int py = (int)m_sci->SendScintilla(
                                        QsciScintillaBase::SCI_POINTYFROMPOSITION,
                                        (unsigned long)0, linePos);
                                    int lh = (int)m_sci->SendScintilla(
                                        QsciScintillaBase::SCI_TEXTHEIGHT,
                                        (unsigned long)h.line);
                                    QPoint anchor = m_sci->viewport()->mapToGlobal(
                                        QPoint(px, py + lh));
                                    popup->showAt(anchor);
                                    showDisasm = true;
                                    // Dismiss value history popup to avoid fighting
                                    if (m_historyPopup && m_historyPopup->isVisible())
                                        static_cast<ValueHistoryPopup*>(m_historyPopup)->dismiss();
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!showDisasm && m_disasmPopup && m_disasmPopup->isVisible())
            static_cast<DisasmPopup*>(m_disasmPopup)->dismiss();
    }

    // Struct preview popup for collapsed typed pointers
    {
        bool showPreview = false;
        if (m_disasmTree && m_disasmProvider && h.line >= 0 && h.line < m_meta.size()) {
            const LineMeta& lm = m_meta[h.line];
            bool isTypedPtr = (lm.nodeKind == NodeKind::Pointer32
                               || lm.nodeKind == NodeKind::Pointer64)
                              && !lm.pointerTargetName.isEmpty();
            if (isTypedPtr && lm.foldCollapsed
                && lm.nodeIdx >= 0 && lm.nodeIdx < m_disasmTree->nodes.size()) {
                const Node& node = m_disasmTree->nodes[lm.nodeIdx];
                if (node.refId != 0) {
                    QString lineText = getLineText(m_sci, h.line);
                    ColumnSpan vs = narrowPtrValueSpan(lm,
                        valueSpan(lm, lineText.size(), lm.effectiveTypeW, lm.effectiveNameW),
                        lineText);
                    if (vs.valid && h.col >= vs.start && h.col < vs.end) {
                        ComposeResult cr = rcx::compose(*m_disasmTree, *m_disasmProvider, node.refId);
                        // Skip command row (line 0), take first 5 data lines
                        QStringList lines = cr.text.split('\n');
                        constexpr int kMaxLines = 5;
                        QString body;
                        int count = 0;
                        for (int i = 1; i < lines.size() && count < kMaxLines; ++i) {
                            if (!lines[i].isEmpty()) {
                                if (count > 0) body += '\n';
                                body += lines[i];
                                ++count;
                            }
                        }
                        if (!body.isEmpty()) {
                            if (!m_structPreviewPopup)
                                m_structPreviewPopup = new StructPreviewPopup(this);
                            auto* popup = static_cast<StructPreviewPopup*>(m_structPreviewPopup);
                            popup->populate(lm.nodeId,
                                lm.pointerTargetName, body, editorFont());
                            long linePos = m_sci->SendScintilla(
                                QsciScintillaBase::SCI_POSITIONFROMLINE,
                                (unsigned long)h.line);
                            long byteOff = lineText.left(vs.start).toUtf8().size();
                            int px = (int)m_sci->SendScintilla(
                                QsciScintillaBase::SCI_POINTXFROMPOSITION,
                                (unsigned long)0, linePos + byteOff);
                            int py = (int)m_sci->SendScintilla(
                                QsciScintillaBase::SCI_POINTYFROMPOSITION,
                                (unsigned long)0, linePos);
                            int lh = (int)m_sci->SendScintilla(
                                QsciScintillaBase::SCI_TEXTHEIGHT,
                                (unsigned long)h.line);
                            QPoint anchor = m_sci->viewport()->mapToGlobal(
                                QPoint(px, py + lh));
                            popup->showAt(anchor);
                            showPreview = true;
                            if (m_historyPopup && m_historyPopup->isVisible())
                                static_cast<ValueHistoryPopup*>(m_historyPopup)->dismiss();
                        }
                    }
                }
            }
        }
        if (!showPreview && m_structPreviewPopup && m_structPreviewPopup->isVisible())
            static_cast<StructPreviewPopup*>(m_structPreviewPopup)->dismiss();
    }

    // Determine cursor shape based on interaction type
    Qt::CursorShape desired = Qt::ArrowCursor;

    if (h.inFoldCol) {
        desired = Qt::PointingHandCursor;  // fold toggle = button
    } else if (tokenHit) {
        // Check if mouse is actually over trimmed text content (not column padding)
        NormalizedSpan trimmed;
        bool overText = resolvedSpanFor(line, t, trimmed)
                        && h.col >= trimmed.start && h.col < trimmed.end;
        if (overText) {
            switch (t) {
            case EditTarget::Type:
            case EditTarget::Source:
            case EditTarget::ArrayElementType:
            case EditTarget::PointerTarget:
            case EditTarget::RootClassType:
            case EditTarget::TypeSelector:
                desired = Qt::PointingHandCursor;
                break;
            default:
                desired = Qt::IBeamCursor;
                break;
            }
        }
        // else: desired stays Arrow (hovering over column padding)
    }

    m_sci->viewport()->setCursor(desired);
}

// ── Live value validation ──

void RcxEditor::setEditComment(const QString& comment) {
    // Value edit must be active
    if (m_editState.commentCol < 0) return;

    // Prevent re-entrancy from textChanged signal
    if (m_updatingComment) return;
    m_updatingComment = true;

    QString lineText = getLineText(m_sci, m_editState.line);

    // Place comment 2 spaces after current value, prefixed with //
    int valueEnd = editEndCol();
    int startCol = valueEnd + 2;  // 2 spaces after value
    int endCol = lineText.size();
    int availWidth = endCol - startCol;
    if (availWidth <= 0) { m_updatingComment = false; return; }

    // Format as "//<comment>" (no space after //)
    QString formatted = QStringLiteral("//") + comment;
    QString padded = formatted.leftJustified(availWidth, ' ').left(availWidth);

    // Use UTF-8 safe column-to-position conversion
    long posA = posFromCol(m_sci, m_editState.line, startCol);
    long posB = posFromCol(m_sci, m_editState.line, endCol);

    QByteArray utf8 = padded.toUtf8();
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETSTART, posA);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETEND, posB);
    m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACETARGET,
                         (uintptr_t)utf8.size(), utf8.constData());

    // Apply green color to hint text
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT, IND_HINT_GREEN);
    m_sci->SendScintilla(QsciScintillaBase::SCI_INDICATORFILLRANGE, posA, posB - posA);

    m_updatingComment = false;
}

void RcxEditor::validateEditLive() {
    QString lineText = getLineText(m_sci, m_editState.line);
    int delta = lineText.size() - m_editState.linelenAfterReplace;
    int editedLen = m_editState.original.size() + delta;
    QString text = (editedLen > 0)
        ? lineText.mid(m_editState.spanStart, editedLen).trimmed() : QString();
    QString errorMsg = (m_editState.target == EditTarget::BaseAddress)
        ? fmt::validateBaseAddress(text)
        : fmt::validateValue(m_editState.editKind, text);

    const LineMeta* lm = metaForLine(m_editState.line);
    const bool isSelected = lm && m_currentSelIds.contains(lm->nodeId);
    const bool isValid = errorMsg.isEmpty();

    // Only update comment when validation state changes (avoid lag)
    const bool stateChanged = (isValid != m_editState.lastValidationOk);
    m_editState.lastValidationOk = isValid;

    // Show/hide error marker (red background)
    // M_SELECTED has higher priority than M_ERR, so temporarily remove it when error
    if (isValid) {
        m_sci->markerDelete(m_editState.line, M_ERR);
        if (isSelected) m_sci->markerAdd(m_editState.line, M_SELECTED);
        if (stateChanged) setEditComment("Enter=Save Esc=Cancel");
    } else {
        if (isSelected) m_sci->markerDelete(m_editState.line, M_SELECTED);
        m_sci->markerAdd(m_editState.line, M_ERR);
        if (stateChanged) setEditComment("! " + errorMsg);
    }
}

void RcxEditor::setCommandRowText(const QString& line) {
    if (m_sci->lines() <= 0) return;
    QString s = line;
    s.replace('\n', ' ');
    s.replace('\r', ' ');

    bool wasReadOnly = m_sci->isReadOnly();
    bool wasModified = m_sci->SendScintilla(QsciScintillaBase::SCI_GETMODIFY);
    long savedPos    = m_sci->SendScintilla(QsciScintillaBase::SCI_GETCURRENTPOS);
    long savedAnchor = m_sci->SendScintilla(QsciScintillaBase::SCI_GETANCHOR);

    m_sci->SendScintilla(QsciScintillaBase::SCI_SETUNDOCOLLECTION, 0);
    m_sci->setReadOnly(false);

    long start = m_sci->SendScintilla(QsciScintillaBase::SCI_POSITIONFROMLINE, 0);
    long end   = m_sci->SendScintilla(QsciScintillaBase::SCI_GETLINEENDPOSITION, 0);
    QByteArray utf8 = s.toUtf8();
    long oldLen = end - start;
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETSTART, start);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETTARGETEND, end);
    m_sci->SendScintilla(QsciScintillaBase::SCI_REPLACETARGET, (uintptr_t)utf8.size(), utf8.constData());

    // Adjust saved cursor/anchor for length change in line 0
    long delta = (long)utf8.size() - oldLen;
    if (savedPos > end)    savedPos    += delta;
    if (savedAnchor > end) savedAnchor += delta;

    if (wasReadOnly) m_sci->setReadOnly(true);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETUNDOCOLLECTION, 1);
    if (!wasModified) m_sci->SendScintilla(QsciScintillaBase::SCI_SETSAVEPOINT);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETCURRENTPOS, savedPos);
    m_sci->SendScintilla(QsciScintillaBase::SCI_SETANCHOR, savedAnchor);
    m_sci->SendScintilla(QsciScintillaBase::SCI_COLOURISE, start, start + utf8.size());
    applyCommandRowPills();
}

void RcxEditor::setEditorFont(const QString& fontName) {
    g_fontName = fontName;
    QFont f = editorFont();

    m_sci->setFont(f);
    m_lexer->setFont(f);
    for (int i = 0; i <= 127; i++)
        m_lexer->setFont(f, i);
    m_sci->setMarginsFont(f);

    // Re-apply margin styles and width with new font metrics
    allocateMarginStyles();
    applyTheme(ThemeManager::instance().current());
    QString marginSizer = QString("  %1  ").arg(QString(m_layout.offsetHexDigits, '0'));
    m_sci->setMarginWidth(0, marginSizer);
}

void RcxEditor::setGlobalFontName(const QString& fontName) {
    g_fontName = fontName;
}

QString RcxEditor::globalFontName() {
    return g_fontName;
}

QString RcxEditor::textWithMargins() const {
    int lineCount = (int)m_sci->SendScintilla(QsciScintillaBase::SCI_GETLINECOUNT);
    QStringList lines;
    lines.reserve(lineCount);
    for (int i = 0; i < lineCount; i++) {
        QString margin;
        if (i < m_meta.size())
            margin = m_meta[i].offsetText;
        QString lineText = getLineText(m_sci, i);
        lines.append(margin + lineText);
    }
    return lines.join('\n');
}

} // namespace rcx

```

`src/editor.h`:

```h
#pragma once
#include "core.h"
#include "themes/theme.h"
#include <QWidget>
#include <QSet>
#include <QPoint>
#include <QHash>

class QsciScintilla;
class QsciLexerCPP;

namespace rcx {

struct SavedSourceDisplay {
    QString text;
    bool active = false;
};

class RcxEditor : public QWidget {
    Q_OBJECT
public:
    explicit RcxEditor(QWidget* parent = nullptr);
    ~RcxEditor() override;

    void applyDocument(const ComposeResult& result);

    ViewState saveViewState() const;
    void restoreViewState(const ViewState& vs);

    QsciScintilla* scintilla() const { return m_sci; }
    QWidget* structPreviewPopup() const { return m_structPreviewPopup; }
    const LineMeta* metaForLine(int line) const;
    int currentNodeIndex() const;
    void scrollToNodeId(uint64_t nodeId);

    // ── Column span computation ──
    static ColumnSpan typeSpan(const LineMeta& lm, int typeW = kColType);
    static ColumnSpan nameSpan(const LineMeta& lm, int typeW = kColType, int nameW = kColName);
    static ColumnSpan valueSpan(const LineMeta& lm, int lineLength, int typeW = kColType, int nameW = kColName);

    // ── Multi-selection ──
    QSet<int> selectedNodeIndices() const;

    // ── Inline editing ──
    bool isEditing() const { return m_editState.active; }
    bool beginInlineEdit(EditTarget target, int line = -1, int col = -1);
    void cancelInlineEdit();

    void applySelectionOverlay(const QSet<uint64_t>& selIds);
    void setCommandRowText(const QString& line);
    void setEditorFont(const QString& fontName);
    static void setGlobalFontName(const QString& fontName);
    static QString globalFontName();
    void applyTheme(const Theme& theme);

    // Custom type names (struct types from the tree) shown in type picker + lexer GlobalClass coloring
    QString textWithMargins() const;
    void setCustomTypeNames(const QStringList& names);
    void setValueHistoryRef(const QHash<uint64_t, ValueHistory>* ref) { m_valueHistory = ref; }
    void setProviderRef(const Provider* prov, const Provider* realProv, const NodeTree* tree) {
        m_disasmProvider = prov; m_disasmRealProv = realProv; m_disasmTree = tree;
    }

    // Saved sources for quick-switch in source picker
    void setSavedSources(const QVector<SavedSourceDisplay>& sources) { m_savedSourceDisplay = sources; }

signals:
    void marginClicked(int margin, int line, Qt::KeyboardModifiers mods);
    void contextMenuRequested(int line, int nodeIdx, int subLine, QPoint globalPos);
    void keywordConvertRequested(const QString& newKeyword);
    void nodeClicked(int line, uint64_t nodeId, Qt::KeyboardModifiers mods);
    void inlineEditCommitted(int nodeIdx, int subLine,
                             EditTarget target, const QString& text,
                             uint64_t resolvedAddr = 0);
    void inlineEditCancelled();
    void typeSelectorRequested();
    void typePickerRequested(EditTarget target, int nodeIdx, QPoint globalPos);

protected:
    bool eventFilter(QObject* obj, QEvent* event) override;

private:
    QsciScintilla*    m_sci    = nullptr;
    QsciLexerCPP*     m_lexer  = nullptr;
    QVector<LineMeta> m_meta;
    LayoutInfo        m_layout;  // cached from ComposeResult

    // ── Toggle: absolute vs relative offset margin
    bool m_relativeOffsets = true;

    int m_marginStyleBase = -1;
    int m_hintLine = -1;

    // ── Hover cursor + highlight ──
    QPoint m_lastHoverPos;
    bool   m_hoverInside = false;
    uint64_t m_hoveredNodeId = 0;
    int      m_hoveredLine = -1;
    uint64_t m_prevHoveredNodeId = 0;  // for incremental marker update
    int      m_prevHoveredLine = -1;   // for incremental marker update
    QSet<uint64_t> m_currentSelIds;
    QVector<int> m_hoverSpanLines;  // Lines with hover span indicators
    // ── nodeId → display-line index (built in applyDocument) ──
    QHash<uint64_t, QVector<int>> m_nodeLineIndex;
    // ── Drag selection ──
    bool m_dragging = false;
    bool m_dragStarted = false;   // true once drag threshold exceeded
    int  m_dragLastLine = -1;
    QPoint m_dragStartPos;        // viewport coords at press
    Qt::KeyboardModifiers m_dragInitMods = Qt::NoModifier;

    // ── Deferred click (protects multi-select on double-click) ──
    uint64_t m_pendingClickNodeId = 0;
    int      m_pendingClickLine = -1;
    Qt::KeyboardModifiers m_pendingClickMods = Qt::NoModifier;

    // ── Inline edit state ──
    struct InlineEditState {
        bool       active    = false;
        int        line      = -1;
        int        nodeIdx   = -1;
        int        subLine   = 0;
        EditTarget target    = EditTarget::Name;
        int        spanStart = 0;
        int        linelenAfterReplace = 0;
        QString    original;
        long       posStart  = 0;   // Scintilla position of edit start
        long       posEnd    = 0;   // Scintilla position of edit end
        NodeKind   editKind = NodeKind::Int32;
        int        commentCol = -1;  // fixed comment column (stored at edit start)
        bool       lastValidationOk = true;  // track state to avoid redundant updates
    };
    InlineEditState m_editState;

    // ── Tab cycling state ──
    EditTarget m_lastTabTarget = EditTarget::Value;

    // ── Custom type names for type picker ──
    QStringList m_customTypeNames;

    // ── Saved sources for quick-switch ──
    QVector<SavedSourceDisplay> m_savedSourceDisplay;

    // ── Value history ref (owned by controller) ──
    const QHash<uint64_t, ValueHistory>* m_valueHistory = nullptr;
    QWidget* m_historyPopup = nullptr;  // ValueHistoryPopup (file-local class in editor.cpp)
    QWidget* m_disasmPopup = nullptr;   // DisasmPopup (file-local class in editor.cpp)
    QWidget* m_structPreviewPopup = nullptr; // StructPreviewPopup (file-local class in editor.cpp)
    const Provider* m_disasmProvider = nullptr;   // snapshot or real — for reading tree data
    const Provider* m_disasmRealProv = nullptr;   // real process provider — for reading code at arbitrary addresses
    const NodeTree* m_disasmTree = nullptr;

    // ── Reentrancy guards ──
    bool m_applyingDocument = false;
    bool m_clampingSelection = false;
    bool m_updatingComment = false;

    void setupScintilla();
    void setupLexer();
    void setupMargins();
    void setupFolding();
    void setupMarkers();
    void allocateMarginStyles();

    void applyMarginText(const QVector<LineMeta>& meta);
    void reformatMargins();
    void applyMarkers(const QVector<LineMeta>& meta);
    void applyFoldLevels(const QVector<LineMeta>& meta);
    void applyHexDimming(const QVector<LineMeta>& meta);
    void applyHeatmapHighlight(const QVector<LineMeta>& meta);
    void applySymbolColoring(const QVector<LineMeta>& meta);
    void applyBaseAddressColoring(const QVector<LineMeta>& meta);
    void applyCommandRowPills();

    void commitInlineEdit();
    int  editEndCol() const;
    bool handleNormalKey(QKeyEvent* ke);
    bool handleEditKey(QKeyEvent* ke);
    void showTypeAutocomplete();
    void showSourcePicker();
    void showTypeListFiltered(const QString& filter);
    void updateTypeListFilter();
    void showPointerTargetPicker();
    void showPointerTargetListFiltered(const QString& filter);
    void updatePointerTargetFilter();
    void paintEditableSpans(int line);
    void updateEditableIndicators(int line);
    void applyHoverCursor();
    void applyHoverHighlight();
    void validateEditLive();
    void setEditComment(const QString& comment);
    void clampEditSelection();

    // ── Refactored helpers ──
    struct HitInfo { int line = -1; int col = -1; uint64_t nodeId = 0; bool inFoldCol = false; };
    HitInfo hitTest(const QPoint& viewportPos) const;

    struct EndEditInfo { int nodeIdx; int subLine; EditTarget target; };
    EndEditInfo endInlineEdit();

    struct NormalizedSpan { int start = 0; int end = 0; bool valid = false; };
    NormalizedSpan normalizeSpan(const ColumnSpan& raw, const QString& lineText,
                                 EditTarget target, bool skipPrefixes) const;

    // ── Indicator helpers (dedupe + UTF-8 safe) ──
    void clearIndicatorLine(int indic, int line);
    void fillIndicatorCols(int indic, int line, int colA, int colB);
    bool resolvedSpanFor(int line, EditTarget t, NormalizedSpan& out,
                         QString* lineTextOut = nullptr) const;
};

} // namespace rcx

```

`src/examples/EPROCESS.rcx`:

```rcx
{
    "baseAddress": "FFFF800000000000",
    "nextId": "9000",
    "nodes": [
        {"id":"100","kind":"Struct","name":"list_entry","structTypeName":"_LIST_ENTRY","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"101","kind":"Pointer64","name":"Flink","offset":0,"parentId":"100","refId":"100","collapsed":true},
        {"id":"102","kind":"Pointer64","name":"Blink","offset":8,"parentId":"100","refId":"100","collapsed":true},

        {"id":"110","kind":"Struct","name":"single_list_entry","structTypeName":"_SINGLE_LIST_ENTRY","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"111","kind":"Pointer64","name":"Next","offset":0,"parentId":"110","refId":"110","collapsed":true},

        {"id":"120","kind":"Struct","name":"ex_push_lock","structTypeName":"_EX_PUSH_LOCK","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"121","kind":"Hex64","name":"Value","offset":0,"parentId":"120"},

        {"id":"130","kind":"Struct","name":"ex_rundown_ref","structTypeName":"_EX_RUNDOWN_REF","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"131","kind":"Struct","name":"","classKeyword":"union","offset":0,"parentId":"130","refId":"0","collapsed":false},
        {"id":"132","kind":"UInt64","name":"Count","offset":0,"parentId":"131"},
        {"id":"133","kind":"Pointer64","name":"Ptr","offset":0,"parentId":"131"},

        {"id":"140","kind":"Struct","name":"ex_fast_ref","structTypeName":"_EX_FAST_REF","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"141","kind":"Struct","name":"","classKeyword":"union","offset":0,"parentId":"140","refId":"0","collapsed":false},
        {"id":"142","kind":"Pointer64","name":"Object","offset":0,"parentId":"141"},
        {"id":"143","kind":"UInt64","name":"Value","offset":0,"parentId":"141"},

        {"id":"150","kind":"Struct","name":"unicode_string","structTypeName":"_UNICODE_STRING","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"151","kind":"UInt16","name":"Length","offset":0,"parentId":"150"},
        {"id":"152","kind":"UInt16","name":"MaximumLength","offset":2,"parentId":"150"},
        {"id":"153","kind":"Pointer64","name":"Buffer","offset":8,"parentId":"150"},

        {"id":"160","kind":"Struct","name":"large_integer","structTypeName":"_LARGE_INTEGER","classKeyword":"union","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"161","kind":"Struct","name":"","offset":0,"parentId":"160","refId":"0","collapsed":false},
        {"id":"162","kind":"UInt32","name":"LowPart","offset":0,"parentId":"161"},
        {"id":"163","kind":"Int32","name":"HighPart","offset":4,"parentId":"161"},
        {"id":"164","kind":"Int64","name":"QuadPart","offset":0,"parentId":"160"},

        {"id":"170","kind":"Struct","name":"rtl_avl_tree","structTypeName":"_RTL_AVL_TREE","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"171","kind":"Pointer64","name":"Root","offset":0,"parentId":"170"},

        {"id":"180","kind":"Struct","name":"kstack_count","structTypeName":"_KSTACK_COUNT","classKeyword":"union","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"181","kind":"Int32","name":"Value","offset":0,"parentId":"180"},
        {"id":"182","kind":"Hex32","name":"State:3 StackCount:29","offset":0,"parentId":"180"},

        {"id":"190","kind":"Struct","name":"kexecute_options","structTypeName":"_KEXECUTE_OPTIONS","classKeyword":"union","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"191","kind":"Hex8","name":"ExecuteOptions","offset":0,"parentId":"190"},

        {"id":"200","kind":"Struct","name":"se_audit_info","structTypeName":"_SE_AUDIT_PROCESS_CREATION_INFO","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"201","kind":"Pointer64","name":"ImageFileName","offset":0,"parentId":"200"},

        {"id":"210","kind":"Struct","name":"ps_protection","structTypeName":"_PS_PROTECTION","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"211","kind":"Struct","name":"","classKeyword":"union","offset":0,"parentId":"210","refId":"0","collapsed":false},
        {"id":"212","kind":"UInt8","name":"Level","offset":0,"parentId":"211"},
        {"id":"213","kind":"Hex8","name":"Type:3 Audit:1 Signer:4","offset":0,"parentId":"211"},

        {"id":"220","kind":"Struct","name":"timer_delay","structTypeName":"_PS_INTERLOCKED_TIMER_DELAY_VALUES","classKeyword":"union","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"221","kind":"Hex64","name":"DelayMs:30 CoalescingWindowMs:30 Reserved:1 NewTimerWheel:1 Retry:1 Locked:1","offset":0,"parentId":"220"},
        {"id":"222","kind":"UInt64","name":"All","offset":0,"parentId":"220"},

        {"id":"230","kind":"Struct","name":"wnf_state_name","structTypeName":"_WNF_STATE_NAME","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"231","kind":"UInt32","name":"Data_0","offset":0,"parentId":"230"},
        {"id":"232","kind":"UInt32","name":"Data_1","offset":4,"parentId":"230"},

        {"id":"240","kind":"Struct","name":"dynamic_ranges","structTypeName":"_PS_DYNAMIC_ENFORCED_ADDRESS_RANGES","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"241","kind":"Struct","name":"Tree","structTypeName":"_RTL_AVL_TREE","offset":0,"parentId":"240","refId":"170","collapsed":true},
        {"id":"242","kind":"Struct","name":"Lock","structTypeName":"_EX_PUSH_LOCK","offset":8,"parentId":"240","refId":"120","collapsed":true},

        {"id":"250","kind":"Struct","name":"alpc_context","structTypeName":"_ALPC_PROCESS_CONTEXT","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"251","kind":"Struct","name":"Lock","structTypeName":"_EX_PUSH_LOCK","offset":0,"parentId":"250","refId":"120","collapsed":true},
        {"id":"252","kind":"Struct","name":"ViewListHead","structTypeName":"_LIST_ENTRY","offset":8,"parentId":"250","refId":"100","collapsed":true},
        {"id":"253","kind":"UInt64","name":"PagedPoolQuotaCache","offset":24,"parentId":"250"},

        {"id":"260","kind":"Struct","name":"mmsupport_flags","structTypeName":"_MMSUPPORT_FLAGS","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"261","kind":"Hex32","name":"EntireFlags","offset":0,"parentId":"260"},

        {"id":"270","kind":"Struct","name":"mmsupport_shared","structTypeName":"_MMSUPPORT_SHARED","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"271","kind":"Pointer64","name":"WorkingSetLockArray","offset":0,"parentId":"270"},
        {"id":"272","kind":"UInt64","name":"ReleasedCommitDebt","offset":8,"parentId":"270"},
        {"id":"273","kind":"UInt64","name":"ResetPagesRepurposedCount","offset":16,"parentId":"270"},
        {"id":"274","kind":"Pointer64","name":"WsSwapSupport","offset":24,"parentId":"270"},
        {"id":"275","kind":"Pointer64","name":"CommitReleaseContext","offset":32,"parentId":"270"},
        {"id":"276","kind":"Pointer64","name":"AccessLog","offset":40,"parentId":"270"},
        {"id":"277","kind":"UInt64","name":"ChargedWslePages","offset":48,"parentId":"270"},
        {"id":"278","kind":"UInt64","name":"ActualWslePages","offset":56,"parentId":"270"},
        {"id":"279","kind":"Int32","name":"WorkingSetCoreLock","offset":64,"parentId":"270"},
        {"id":"280","kind":"Pointer64","name":"ShadowMapping","offset":72,"parentId":"270"},

        {"id":"300","kind":"Struct","name":"mmsupport_instance","structTypeName":"_MMSUPPORT_INSTANCE","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"301","kind":"UInt32","name":"NextPageColor","offset":0,"parentId":"300"},
        {"id":"302","kind":"UInt32","name":"PageFaultCount","offset":4,"parentId":"300"},
        {"id":"303","kind":"UInt64","name":"TrimmedPageCount","offset":8,"parentId":"300"},
        {"id":"304","kind":"Pointer64","name":"VmWorkingSetList","offset":16,"parentId":"300"},
        {"id":"305","kind":"Struct","name":"WorkingSetExpansionLinks","structTypeName":"_LIST_ENTRY","offset":24,"parentId":"300","refId":"100","collapsed":true},
        {"id":"306","kind":"UInt64","name":"AgeDistribution_0","offset":40,"parentId":"300"},
        {"id":"307","kind":"UInt64","name":"AgeDistribution_1","offset":48,"parentId":"300"},
        {"id":"308","kind":"UInt64","name":"AgeDistribution_2","offset":56,"parentId":"300"},
        {"id":"309","kind":"UInt64","name":"AgeDistribution_3","offset":64,"parentId":"300"},
        {"id":"310","kind":"UInt64","name":"AgeDistribution_4","offset":72,"parentId":"300"},
        {"id":"311","kind":"UInt64","name":"AgeDistribution_5","offset":80,"parentId":"300"},
        {"id":"312","kind":"UInt64","name":"AgeDistribution_6","offset":88,"parentId":"300"},
        {"id":"313","kind":"UInt64","name":"AgeDistribution_7","offset":96,"parentId":"300"},
        {"id":"314","kind":"Pointer64","name":"ExitOutswapGate","offset":104,"parentId":"300"},
        {"id":"315","kind":"UInt64","name":"MinimumWorkingSetSize","offset":112,"parentId":"300"},
        {"id":"316","kind":"UInt64","name":"MaximumWorkingSetSize","offset":120,"parentId":"300"},
        {"id":"317","kind":"UInt64","name":"WorkingSetLeafSize","offset":128,"parentId":"300"},
        {"id":"318","kind":"UInt64","name":"WorkingSetLeafPrivateSize","offset":136,"parentId":"300"},
        {"id":"319","kind":"UInt64","name":"WorkingSetSize","offset":144,"parentId":"300"},
        {"id":"320","kind":"UInt64","name":"WorkingSetPrivateSize","offset":152,"parentId":"300"},
        {"id":"321","kind":"UInt64","name":"PeakWorkingSetSize","offset":160,"parentId":"300"},
        {"id":"322","kind":"UInt32","name":"HardFaultCount","offset":168,"parentId":"300"},
        {"id":"323","kind":"UInt16","name":"LastTrimStamp","offset":172,"parentId":"300"},
        {"id":"324","kind":"UInt16","name":"PartitionId","offset":174,"parentId":"300"},
        {"id":"325","kind":"UInt64","name":"SelfmapLock","offset":176,"parentId":"300"},
        {"id":"326","kind":"Struct","name":"Flags","structTypeName":"_MMSUPPORT_FLAGS","offset":184,"parentId":"300","refId":"260","collapsed":true},

        {"id":"350","kind":"Struct","name":"mmsupport_full","structTypeName":"_MMSUPPORT_FULL","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"351","kind":"Struct","name":"Instance","structTypeName":"_MMSUPPORT_INSTANCE","offset":0,"parentId":"350","refId":"300","collapsed":true},
        {"id":"352","kind":"Struct","name":"Shared","structTypeName":"_MMSUPPORT_SHARED","offset":192,"parentId":"350","refId":"270","collapsed":true},

        {"id":"400","kind":"Struct","name":"dispatcher_header","structTypeName":"_DISPATCHER_HEADER","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"401","kind":"Struct","name":"","classKeyword":"union","offset":0,"parentId":"400","refId":"0","collapsed":false},
        {"id":"402","kind":"UInt8","name":"Type","offset":0,"parentId":"401"},
        {"id":"403","kind":"UInt8","name":"Signalling","offset":1,"parentId":"401"},
        {"id":"404","kind":"UInt8","name":"Size","offset":2,"parentId":"401"},
        {"id":"405","kind":"UInt8","name":"Reserved1","offset":3,"parentId":"401"},
        {"id":"406","kind":"Int32","name":"Lock","offset":0,"parentId":"401"},
        {"id":"407","kind":"Int32","name":"SignalState","offset":4,"parentId":"400"},
        {"id":"408","kind":"Struct","name":"WaitListHead","structTypeName":"_LIST_ENTRY","offset":8,"parentId":"400","refId":"100","collapsed":true},

        {"id":"500","kind":"Struct","name":"kprocess","structTypeName":"_KPROCESS","offset":0,"parentId":"0","refId":"0","collapsed":true},
        {"id":"501","kind":"Struct","name":"Header","structTypeName":"_DISPATCHER_HEADER","offset":0,"parentId":"500","refId":"400","collapsed":true},
        {"id":"502","kind":"Struct","name":"ProfileListHead","structTypeName":"_LIST_ENTRY","offset":24,"parentId":"500","refId":"100","collapsed":true},
        {"id":"503","kind":"UInt64","name":"DirectoryTableBase","offset":40,"parentId":"500"},
        {"id":"504","kind":"Struct","name":"ThreadListHead","structTypeName":"_LIST_ENTRY","offset":48,"parentId":"500","refId":"100","collapsed":true},
        {"id":"505","kind":"UInt32","name":"ProcessLock","offset":64,"parentId":"500"},
        {"id":"506","kind":"UInt32","name":"ProcessTimerDelay","offset":68,"parentId":"500"},
        {"id":"507","kind":"UInt64","name":"DeepFreezeStartTime","offset":72,"parentId":"500"},
        {"id":"508","kind":"Pointer64","name":"Affinity","offset":80,"parentId":"500"},
        {"id":"509","kind":"Hex64","name":"AutoBoostState","offset":88,"parentId":"500"},
        {"id":"510","kind":"Struct","name":"ReadyListHead","structTypeName":"_LIST_ENTRY","offset":104,"parentId":"500","refId":"100","collapsed":true},
        {"id":"511","kind":"Struct","name":"SwapListEntry","structTypeName":"_SINGLE_LIST_ENTRY","offset":120,"parentId":"500","refId":"110","collapsed":true},
        {"id":"512","kind":"Pointer64","name":"ActiveProcessors","offset":128,"parentId":"500"},
        {"id":"513","kind":"Struct","name":"","classKeyword":"union","offset":136,"parentId":"500","refId":"0","collapsed":false},
        {"id":"514","kind":"Hex32","name":"AutoAlignment:1 DisableBoost:1 DisableQuantum:1 DeepFreeze:1 TimerVirtualization:1 CheckStackExtents:1 CacheIsolationEnabled:1 PpmPolicy:4 VaSpaceDeleted:1 MultiGroup:1 ForegroundProcess:1 ReservedFlags:18","offset":0,"parentId":"513"},
        {"id":"515","kind":"Int32","name":"ProcessFlags","offset":0,"parentId":"513"},
        {"id":"516","kind":"Int8","name":"BasePriority","offset":144,"parentId":"500"},
        {"id":"517","kind":"Int8","name":"QuantumReset","offset":145,"parentId":"500"},
        {"id":"518","kind":"Int8","name":"Visited","offset":146,"parentId":"500"},
        {"id":"519","kind":"Struct","name":"Flags","structTypeName":"_KEXECUTE_OPTIONS","offset":147,"parentId":"500","refId":"190","collapsed":true},
        {"id":"520","kind":"Struct","name":"StackCount","structTypeName":"_KSTACK_COUNT","offset":264,"parentId":"500","refId":"180","collapsed":true},
        {"id":"521","kind":"Struct","name":"ProcessListEntry","structTypeName":"_LIST_ENTRY","offset":272,"parentId":"500","refId":"100","collapsed":true},
        {"id":"522","kind":"UInt64","name":"CycleTime","offset":288,"parentId":"500"},
        {"id":"523","kind":"UInt64","name":"ContextSwitches","offset":296,"parentId":"500"},
        {"id":"524","kind":"Pointer64","name":"SchedulingGroup","offset":304,"parentId":"500"},
        {"id":"525","kind":"UInt64","name":"KernelTime","offset":312,"parentId":"500"},
        {"id":"526","kind":"UInt64","name":"UserTime","offset":320,"parentId":"500"},
        {"id":"527","kind":"UInt64","name":"ReadyTime","offset":328,"parentId":"500"},
        {"id":"528","kind":"UInt32","name":"FreezeCount","offset":336,"parentId":"500"},
        {"id":"529","kind":"UInt64","name":"UserDirectoryTableBase","offset":344,"parentId":"500"},
        {"id":"530","kind":"UInt8","name":"AddressPolicy","offset":352,"parentId":"500"},
        {"id":"531","kind":"Pointer64","name":"InstrumentationCallback","offset":360,"parentId":"500"},
        {"id":"532","kind":"UInt64","name":"SecureHandle","offset":368,"parentId":"500"},
        {"id":"533","kind":"UInt64","name":"KernelWaitTime","offset":376,"parentId":"500"},
        {"id":"534","kind":"UInt64","name":"UserWaitTime","offset":384,"parentId":"500"},
        {"id":"535","kind":"UInt64","name":"LastRebalanceQpc","offset":392,"parentId":"500"},
        {"id":"536","kind":"Pointer64","name":"PerProcessorCycleTimes","offset":400,"parentId":"500"},
        {"id":"537","kind":"UInt64","name":"ExtendedFeatureDisableMask","offset":408,"parentId":"500"},
        {"id":"538","kind":"UInt16","name":"PrimaryGroup","offset":416,"parentId":"500"},
        {"id":"539","kind":"Pointer64","name":"UserCetLogging","offset":424,"parentId":"500"},
        {"id":"540","kind":"Struct","name":"CpuPartitionList","structTypeName":"_LIST_ENTRY","offset":432,"parentId":"500","refId":"100","collapsed":true},
        {"id":"541","kind":"Pointer64","name":"AvailableCpuState","offset":448,"parentId":"500"},

        {"id":"2000","kind":"Struct","name":"eprocess","structTypeName":"_EPROCESS","offset":0,"parentId":"0","refId":"0","collapsed":false},
        {"id":"2001","kind":"Struct","name":"Pcb","structTypeName":"_KPROCESS","offset":0,"parentId":"2000","refId":"500","collapsed":true},
        {"id":"2002","kind":"Struct","name":"ProcessLock","structTypeName":"_EX_PUSH_LOCK","offset":456,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2003","kind":"Pointer64","name":"UniqueProcessId","offset":464,"parentId":"2000"},
        {"id":"2004","kind":"Struct","name":"ActiveProcessLinks","structTypeName":"_LIST_ENTRY","offset":472,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2005","kind":"Struct","name":"RundownProtect","structTypeName":"_EX_RUNDOWN_REF","offset":488,"parentId":"2000","refId":"130","collapsed":true},
        {"id":"2006","kind":"Struct","name":"","classKeyword":"union","offset":496,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2007","kind":"UInt32","name":"Flags2","offset":0,"parentId":"2006"},
        {"id":"2008","kind":"Hex32","name":"JobNotReallyActive:1 AccountingFolded:1 NewProcessReported:1 ExitProcessReported:1 ReportCommitChanges:1 LastReportMemory:1 ForceWakeCharge:1 CrossSessionCreate:1 NeedsHandleRundown:1 RefTraceEnabled:1 PicoCreated:1 EmptyJobEvaluated:1 DefaultPagePriority:3 PrimaryTokenFrozen:1","offset":0,"parentId":"2006"},
        {"id":"2009","kind":"Struct","name":"","classKeyword":"union","offset":500,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2010","kind":"UInt32","name":"Flags","offset":0,"parentId":"2009"},
        {"id":"2011","kind":"Hex32","name":"CreateReported:1 NoDebugInherit:1 ProcessExiting:1 ProcessDelete:1 ManageExecutableMemoryWrites:1 VmDeleted:1 OutswapEnabled:1 Outswapped:1 FailFastOnCommitFail:1 Wow64VaSpace4Gb:1 AddressSpaceInitialized:2 SetTimerResolution:1 BreakOnTermination:1","offset":0,"parentId":"2009"},
        {"id":"2012","kind":"Int64","name":"CreateTime","offset":504,"parentId":"2000"},
        {"id":"2013","kind":"UInt64","name":"ProcessQuotaUsage_0","offset":512,"parentId":"2000"},
        {"id":"2014","kind":"UInt64","name":"ProcessQuotaUsage_1","offset":520,"parentId":"2000"},
        {"id":"2015","kind":"UInt64","name":"ProcessQuotaPeak_0","offset":528,"parentId":"2000"},
        {"id":"2016","kind":"UInt64","name":"ProcessQuotaPeak_1","offset":536,"parentId":"2000"},
        {"id":"2017","kind":"UInt64","name":"PeakVirtualSize","offset":544,"parentId":"2000"},
        {"id":"2018","kind":"UInt64","name":"VirtualSize","offset":552,"parentId":"2000"},
        {"id":"2019","kind":"Struct","name":"SessionProcessLinks","structTypeName":"_LIST_ENTRY","offset":560,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2020","kind":"Struct","name":"","classKeyword":"union","offset":576,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2021","kind":"Pointer64","name":"ExceptionPortData","offset":0,"parentId":"2020"},
        {"id":"2022","kind":"UInt64","name":"ExceptionPortValue","offset":0,"parentId":"2020"},
        {"id":"2023","kind":"Struct","name":"Token","structTypeName":"_EX_FAST_REF","offset":584,"parentId":"2000","refId":"140","collapsed":true},
        {"id":"2024","kind":"UInt64","name":"MmReserved","offset":592,"parentId":"2000"},
        {"id":"2025","kind":"Struct","name":"AddressCreationLock","structTypeName":"_EX_PUSH_LOCK","offset":600,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2026","kind":"Struct","name":"PageTableCommitmentLock","structTypeName":"_EX_PUSH_LOCK","offset":608,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2027","kind":"Pointer64","name":"RotateInProgress","offset":616,"parentId":"2000"},
        {"id":"2028","kind":"Pointer64","name":"ForkInProgress","offset":624,"parentId":"2000"},
        {"id":"2029","kind":"Pointer64","name":"CommitChargeJob","offset":632,"parentId":"2000"},
        {"id":"2030","kind":"Struct","name":"CloneRoot","structTypeName":"_RTL_AVL_TREE","offset":640,"parentId":"2000","refId":"170","collapsed":true},
        {"id":"2031","kind":"UInt64","name":"NumberOfPrivatePages","offset":648,"parentId":"2000"},
        {"id":"2032","kind":"UInt64","name":"NumberOfLockedPages","offset":656,"parentId":"2000"},
        {"id":"2033","kind":"Pointer64","name":"Win32Process","offset":664,"parentId":"2000"},
        {"id":"2034","kind":"Pointer64","name":"Job","offset":672,"parentId":"2000"},
        {"id":"2035","kind":"Pointer64","name":"SectionObject","offset":680,"parentId":"2000"},
        {"id":"2036","kind":"Pointer64","name":"SectionBaseAddress","offset":688,"parentId":"2000"},
        {"id":"2037","kind":"UInt32","name":"Cookie","offset":696,"parentId":"2000"},
        {"id":"2038","kind":"Pointer64","name":"WorkingSetWatch","offset":704,"parentId":"2000"},
        {"id":"2039","kind":"Pointer64","name":"Win32WindowStation","offset":712,"parentId":"2000"},
        {"id":"2040","kind":"Pointer64","name":"InheritedFromUniqueProcessId","offset":720,"parentId":"2000"},
        {"id":"2041","kind":"UInt64","name":"OwnerProcessId","offset":728,"parentId":"2000"},
        {"id":"2042","kind":"Pointer64","name":"Peb","offset":736,"parentId":"2000"},
        {"id":"2043","kind":"Pointer64","name":"Session","offset":744,"parentId":"2000"},
        {"id":"2044","kind":"Pointer64","name":"Spare1","offset":752,"parentId":"2000"},
        {"id":"2045","kind":"Pointer64","name":"QuotaBlock","offset":760,"parentId":"2000"},
        {"id":"2046","kind":"Pointer64","name":"ObjectTable","offset":768,"parentId":"2000"},
        {"id":"2047","kind":"Pointer64","name":"DebugPort","offset":776,"parentId":"2000"},
        {"id":"2048","kind":"Pointer64","name":"WoW64Process","offset":784,"parentId":"2000"},
        {"id":"2049","kind":"Struct","name":"DeviceMap","structTypeName":"_EX_FAST_REF","offset":792,"parentId":"2000","refId":"140","collapsed":true},
        {"id":"2050","kind":"Pointer64","name":"EtwDataSource","offset":800,"parentId":"2000"},
        {"id":"2051","kind":"UInt64","name":"PageDirectoryPte","offset":808,"parentId":"2000"},
        {"id":"2052","kind":"Pointer64","name":"ImageFilePointer","offset":816,"parentId":"2000"},
        {"id":"2053","kind":"Hex64","name":"ImageFileName_lo","offset":824,"parentId":"2000"},
        {"id":"2054","kind":"Hex32","name":"ImageFileName_mi","offset":832,"parentId":"2000"},
        {"id":"2055","kind":"Hex16","name":"ImageFileName_hi","offset":836,"parentId":"2000"},
        {"id":"2056","kind":"UInt8","name":"ImageFileName_14","offset":838,"parentId":"2000"},
        {"id":"2057","kind":"UInt8","name":"PriorityClass","offset":839,"parentId":"2000"},
        {"id":"2058","kind":"Pointer64","name":"SecurityPort","offset":840,"parentId":"2000"},
        {"id":"2059","kind":"Struct","name":"SeAuditProcessCreationInfo","structTypeName":"_SE_AUDIT_PROCESS_CREATION_INFO","offset":848,"parentId":"2000","refId":"200","collapsed":true},
        {"id":"2060","kind":"Struct","name":"JobLinks","structTypeName":"_LIST_ENTRY","offset":856,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2061","kind":"Pointer64","name":"HighestUserAddress","offset":872,"parentId":"2000"},
        {"id":"2062","kind":"Struct","name":"ThreadListHead","structTypeName":"_LIST_ENTRY","offset":880,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2063","kind":"UInt32","name":"ActiveThreads","offset":896,"parentId":"2000"},
        {"id":"2064","kind":"UInt32","name":"ImagePathHash","offset":900,"parentId":"2000"},
        {"id":"2065","kind":"UInt32","name":"DefaultHardErrorProcessing","offset":904,"parentId":"2000"},
        {"id":"2066","kind":"Int32","name":"LastThreadExitStatus","offset":908,"parentId":"2000"},
        {"id":"2067","kind":"Struct","name":"PrefetchTrace","structTypeName":"_EX_FAST_REF","offset":912,"parentId":"2000","refId":"140","collapsed":true},
        {"id":"2068","kind":"Pointer64","name":"LockedPagesList","offset":920,"parentId":"2000"},
        {"id":"2069","kind":"Int64","name":"ReadOperationCount","offset":928,"parentId":"2000"},
        {"id":"2070","kind":"Int64","name":"WriteOperationCount","offset":936,"parentId":"2000"},
        {"id":"2071","kind":"Int64","name":"OtherOperationCount","offset":944,"parentId":"2000"},
        {"id":"2072","kind":"Int64","name":"ReadTransferCount","offset":952,"parentId":"2000"},
        {"id":"2073","kind":"Int64","name":"WriteTransferCount","offset":960,"parentId":"2000"},
        {"id":"2074","kind":"Int64","name":"OtherTransferCount","offset":968,"parentId":"2000"},
        {"id":"2075","kind":"UInt64","name":"CommitChargeLimit","offset":976,"parentId":"2000"},
        {"id":"2076","kind":"UInt64","name":"CommitCharge","offset":984,"parentId":"2000"},
        {"id":"2077","kind":"UInt64","name":"CommitChargePeak","offset":992,"parentId":"2000"},
        {"id":"2078","kind":"Struct","name":"Vm","structTypeName":"_MMSUPPORT_FULL","offset":1024,"parentId":"2000","refId":"350","collapsed":true},
        {"id":"2079","kind":"Struct","name":"MmProcessLinks","structTypeName":"_LIST_ENTRY","offset":1344,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2080","kind":"UInt32","name":"ModifiedPageCount","offset":1360,"parentId":"2000"},
        {"id":"2081","kind":"Int32","name":"ExitStatus","offset":1364,"parentId":"2000"},
        {"id":"2082","kind":"Struct","name":"VadRoot","structTypeName":"_RTL_AVL_TREE","offset":1368,"parentId":"2000","refId":"170","collapsed":true},
        {"id":"2083","kind":"Pointer64","name":"VadHint","offset":1376,"parentId":"2000"},
        {"id":"2084","kind":"UInt64","name":"VadCount","offset":1384,"parentId":"2000"},
        {"id":"2085","kind":"UInt64","name":"VadPhysicalPages","offset":1392,"parentId":"2000"},
        {"id":"2086","kind":"UInt64","name":"VadPhysicalPagesLimit","offset":1400,"parentId":"2000"},
        {"id":"2087","kind":"Struct","name":"AlpcContext","structTypeName":"_ALPC_PROCESS_CONTEXT","offset":1408,"parentId":"2000","refId":"250","collapsed":true},
        {"id":"2088","kind":"Struct","name":"TimerResolutionLink","structTypeName":"_LIST_ENTRY","offset":1440,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2089","kind":"Pointer64","name":"TimerResolutionStackRecord","offset":1456,"parentId":"2000"},
        {"id":"2090","kind":"UInt32","name":"RequestedTimerResolution","offset":1464,"parentId":"2000"},
        {"id":"2091","kind":"UInt32","name":"SmallestTimerResolution","offset":1468,"parentId":"2000"},
        {"id":"2092","kind":"Int64","name":"ExitTime","offset":1472,"parentId":"2000"},
        {"id":"2093","kind":"Pointer64","name":"InvertedFunctionTable","offset":1480,"parentId":"2000"},
        {"id":"2094","kind":"Struct","name":"InvertedFunctionTableLock","structTypeName":"_EX_PUSH_LOCK","offset":1488,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2095","kind":"UInt32","name":"ActiveThreadsHighWatermark","offset":1496,"parentId":"2000"},
        {"id":"2096","kind":"UInt32","name":"LargePrivateVadCount","offset":1500,"parentId":"2000"},
        {"id":"2097","kind":"Struct","name":"ThreadListLock","structTypeName":"_EX_PUSH_LOCK","offset":1504,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2098","kind":"Pointer64","name":"WnfContext","offset":1512,"parentId":"2000"},
        {"id":"2099","kind":"Pointer64","name":"ServerSilo","offset":1520,"parentId":"2000"},
        {"id":"2100","kind":"UInt8","name":"SignatureLevel","offset":1528,"parentId":"2000"},
        {"id":"2101","kind":"UInt8","name":"SectionSignatureLevel","offset":1529,"parentId":"2000"},
        {"id":"2102","kind":"Struct","name":"Protection","structTypeName":"_PS_PROTECTION","offset":1530,"parentId":"2000","refId":"210","collapsed":true},
        {"id":"2103","kind":"Hex8","name":"HangCount:3 GhostCount:3 PrefilterException:1","offset":1531,"parentId":"2000"},
        {"id":"2104","kind":"Struct","name":"","classKeyword":"union","offset":1532,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2105","kind":"UInt32","name":"Flags3","offset":0,"parentId":"2104"},
        {"id":"2106","kind":"Hex32","name":"Minimal:1 ReplacingPageRoot:1 Crashed:1 JobVadsAreTracked:1 VadTrackingDisabled:1 AuxiliaryProcess:1 SubsystemProcess:1 IndirectCpuSets:1 RelinquishedCommit:1 HighGraphicsPriority:1 CommitFailLogged:1 ReserveFailLogged:1 SystemProcess:1","offset":0,"parentId":"2104"},
        {"id":"2107","kind":"Int32","name":"DeviceAsid","offset":1536,"parentId":"2000"},
        {"id":"2108","kind":"Pointer64","name":"SvmData","offset":1544,"parentId":"2000"},
        {"id":"2109","kind":"Struct","name":"SvmProcessLock","structTypeName":"_EX_PUSH_LOCK","offset":1552,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2110","kind":"UInt64","name":"SvmLock","offset":1560,"parentId":"2000"},
        {"id":"2111","kind":"Struct","name":"SvmProcessDeviceListHead","structTypeName":"_LIST_ENTRY","offset":1568,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2112","kind":"UInt64","name":"LastFreezeInterruptTime","offset":1584,"parentId":"2000"},
        {"id":"2113","kind":"Pointer64","name":"DiskCounters","offset":1592,"parentId":"2000"},
        {"id":"2114","kind":"Pointer64","name":"PicoContext","offset":1600,"parentId":"2000"},
        {"id":"2115","kind":"Pointer64","name":"EnclaveTable","offset":1608,"parentId":"2000"},
        {"id":"2116","kind":"UInt64","name":"EnclaveNumber","offset":1616,"parentId":"2000"},
        {"id":"2117","kind":"Struct","name":"EnclaveLock","structTypeName":"_EX_PUSH_LOCK","offset":1624,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2118","kind":"UInt32","name":"HighPriorityFaultsAllowed","offset":1632,"parentId":"2000"},
        {"id":"2119","kind":"Pointer64","name":"EnergyContext","offset":1640,"parentId":"2000"},
        {"id":"2120","kind":"Pointer64","name":"VmContext","offset":1648,"parentId":"2000"},
        {"id":"2121","kind":"UInt64","name":"SequenceNumber","offset":1656,"parentId":"2000"},
        {"id":"2122","kind":"UInt64","name":"CreateInterruptTime","offset":1664,"parentId":"2000"},
        {"id":"2123","kind":"UInt64","name":"CreateUnbiasedInterruptTime","offset":1672,"parentId":"2000"},
        {"id":"2124","kind":"UInt64","name":"TotalUnbiasedFrozenTime","offset":1680,"parentId":"2000"},
        {"id":"2125","kind":"UInt64","name":"LastAppStateUpdateTime","offset":1688,"parentId":"2000"},
        {"id":"2126","kind":"Hex64","name":"LastAppStateUptime:61 LastAppState:3","offset":1696,"parentId":"2000"},
        {"id":"2127","kind":"UInt64","name":"SharedCommitCharge","offset":1704,"parentId":"2000"},
        {"id":"2128","kind":"Struct","name":"SharedCommitLock","structTypeName":"_EX_PUSH_LOCK","offset":1712,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2129","kind":"Struct","name":"SharedCommitLinks","structTypeName":"_LIST_ENTRY","offset":1720,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2130","kind":"UInt64","name":"AllowedCpuSets","offset":1736,"parentId":"2000"},
        {"id":"2131","kind":"UInt64","name":"DefaultCpuSets","offset":1744,"parentId":"2000"},
        {"id":"2132","kind":"Pointer64","name":"DiskIoAttribution","offset":1752,"parentId":"2000"},
        {"id":"2133","kind":"Pointer64","name":"DxgProcess","offset":1760,"parentId":"2000"},
        {"id":"2134","kind":"UInt32","name":"Win32KFilterSet","offset":1768,"parentId":"2000"},
        {"id":"2135","kind":"UInt16","name":"Machine","offset":1772,"parentId":"2000"},
        {"id":"2136","kind":"UInt8","name":"MmSlabIdentity","offset":1774,"parentId":"2000"},
        {"id":"2137","kind":"UInt8","name":"Spare0","offset":1775,"parentId":"2000"},
        {"id":"2138","kind":"Struct","name":"ProcessTimerDelay","structTypeName":"_PS_INTERLOCKED_TIMER_DELAY_VALUES","offset":1776,"parentId":"2000","refId":"220","collapsed":true},
        {"id":"2139","kind":"UInt32","name":"KTimerSets","offset":1784,"parentId":"2000"},
        {"id":"2140","kind":"UInt32","name":"KTimer2Sets","offset":1788,"parentId":"2000"},
        {"id":"2141","kind":"UInt32","name":"ThreadTimerSets","offset":1792,"parentId":"2000"},
        {"id":"2142","kind":"UInt64","name":"VirtualTimerListLock","offset":1800,"parentId":"2000"},
        {"id":"2143","kind":"Struct","name":"VirtualTimerListHead","structTypeName":"_LIST_ENTRY","offset":1808,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2144","kind":"Struct","name":"WakeChannel","structTypeName":"_WNF_STATE_NAME","offset":1824,"parentId":"2000","refId":"230","collapsed":true},
        {"id":"2145","kind":"Struct","name":"","classKeyword":"union","offset":1872,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2146","kind":"UInt32","name":"MitigationFlags","offset":0,"parentId":"2145"},
        {"id":"2147","kind":"Hex32","name":"ControlFlowGuardEnabled:1 ControlFlowGuardExportSuppressionEnabled:1 ControlFlowGuardStrict:1 DisallowStrippedImages:1 ForceRelocateImages:1 HighEntropyASLREnabled:1 StackRandomizationDisabled:1 ExtensionPointDisable:1 DisableDynamicCode:1","offset":0,"parentId":"2145"},
        {"id":"2148","kind":"Struct","name":"","classKeyword":"union","offset":1876,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2149","kind":"UInt32","name":"MitigationFlags2","offset":0,"parentId":"2148"},
        {"id":"2150","kind":"Hex32","name":"EnableExportAddressFilter:1 AuditExportAddressFilter:1 EnableRopStackPivot:1 AuditRopStackPivot:1 CetUserShadowStacks:1 SpeculativeStoreBypassDisable:1","offset":0,"parentId":"2148"},
        {"id":"2151","kind":"Pointer64","name":"PartitionObject","offset":1880,"parentId":"2000"},
        {"id":"2152","kind":"UInt64","name":"SecurityDomain","offset":1888,"parentId":"2000"},
        {"id":"2153","kind":"UInt64","name":"ParentSecurityDomain","offset":1896,"parentId":"2000"},
        {"id":"2154","kind":"Pointer64","name":"CoverageSamplerContext","offset":1904,"parentId":"2000"},
        {"id":"2155","kind":"Pointer64","name":"MmHotPatchContext","offset":1912,"parentId":"2000"},
        {"id":"2156","kind":"Struct","name":"DynamicEHContinuationTargetsTree","structTypeName":"_RTL_AVL_TREE","offset":1920,"parentId":"2000","refId":"170","collapsed":true},
        {"id":"2157","kind":"Struct","name":"DynamicEHContinuationTargetsLock","structTypeName":"_EX_PUSH_LOCK","offset":1928,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2158","kind":"Struct","name":"DynamicEnforcedCetCompatibleRanges","structTypeName":"_PS_DYNAMIC_ENFORCED_ADDRESS_RANGES","offset":1936,"parentId":"2000","refId":"240","collapsed":true},
        {"id":"2159","kind":"UInt32","name":"DisabledComponentFlags","offset":1952,"parentId":"2000"},
        {"id":"2160","kind":"Int32","name":"PageCombineSequence","offset":1956,"parentId":"2000"},
        {"id":"2161","kind":"Struct","name":"EnableOptionalXStateFeaturesLock","structTypeName":"_EX_PUSH_LOCK","offset":1960,"parentId":"2000","refId":"120","collapsed":true},
        {"id":"2162","kind":"Pointer64","name":"PathRedirectionHashes","offset":1968,"parentId":"2000"},
        {"id":"2163","kind":"Pointer64","name":"SyscallProvider","offset":1976,"parentId":"2000"},
        {"id":"2164","kind":"Struct","name":"SyscallProviderProcessLinks","structTypeName":"_LIST_ENTRY","offset":1984,"parentId":"2000","refId":"100","collapsed":true},
        {"id":"2165","kind":"Hex64","name":"SyscallProviderDispatchContext","offset":2000,"parentId":"2000"},
        {"id":"2166","kind":"Struct","name":"","classKeyword":"union","offset":2008,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2167","kind":"UInt32","name":"MitigationFlags3","offset":0,"parentId":"2166"},
        {"id":"2168","kind":"Hex32","name":"RestrictCoreSharing:1 DisallowFsctlSystemCalls:1 AuditDisallowFsctlSystemCalls:1 MitigationFlags3Spare:29","offset":0,"parentId":"2166"},
        {"id":"2169","kind":"Struct","name":"","classKeyword":"union","offset":2012,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2170","kind":"UInt32","name":"Flags4","offset":0,"parentId":"2169"},
        {"id":"2171","kind":"Hex32","name":"ThreadWasActive:1 MinimalTerminate:1 ImageExpansionDisable:1 SessionFirstProcess:1","offset":0,"parentId":"2169"},
        {"id":"2172","kind":"Struct","name":"","classKeyword":"union","offset":2016,"parentId":"2000","refId":"0","collapsed":true},
        {"id":"2173","kind":"UInt32","name":"SyscallUsage","offset":0,"parentId":"2172"},
        {"id":"2174","kind":"Hex32","name":"SystemModuleInformation:1 SystemModuleInformationEx:1 SystemLocksInformation:1 SystemHandleInformation:1 SystemExtendedHandleInformation:1","offset":0,"parentId":"2172"},
        {"id":"2175","kind":"Int32","name":"SupervisorDeviceAsid","offset":2020,"parentId":"2000"},
        {"id":"2176","kind":"Pointer64","name":"SupervisorSvmData","offset":2024,"parentId":"2000"},
        {"id":"2177","kind":"Pointer64","name":"NetworkCounters","offset":2032,"parentId":"2000"},
        {"id":"2178","kind":"Hex64","name":"Execution","offset":2040,"parentId":"2000"},
        {"id":"2179","kind":"Pointer64","name":"ThreadIndexTable","offset":2048,"parentId":"2000"},
        {"id":"2180","kind":"Struct","name":"FreezeWorkLinks","structTypeName":"_LIST_ENTRY","offset":2056,"parentId":"2000","refId":"100","collapsed":true}
    ]
}

```

`src/examples/KUSER_SHARED_DATA.rcx`:

```rcx
{
    "baseAddress": "7ffe0000",
    "nextId": "704",
    "nodes": [
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "46",
            "kind": "Struct",
            "name": "ksd",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "strLen": 64,
            "structTypeName": "KUSER_SHARED_DATA"
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "47",
            "kind": "UInt32",
            "name": "TickCountLowDeprecated",
            "offset": 0,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "48",
            "kind": "UInt32",
            "name": "TickCountMultiplier",
            "offset": 4,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "49",
            "kind": "UInt32",
            "name": "InterruptTime.LowPart",
            "offset": 8,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "50",
            "kind": "UInt32",
            "name": "InterruptTime.High1Time",
            "offset": 12,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "51",
            "kind": "UInt32",
            "name": "InterruptTime.High2Time",
            "offset": 16,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "52",
            "kind": "UInt32",
            "name": "SystemTime.LowPart",
            "offset": 20,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "53",
            "kind": "UInt32",
            "name": "SystemTime.High1Time",
            "offset": 24,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "54",
            "kind": "UInt32",
            "name": "SystemTime.High2Time",
            "offset": 28,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "55",
            "kind": "UInt32",
            "name": "TimeZoneBias.LowPart",
            "offset": 32,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "56",
            "kind": "UInt32",
            "name": "TimeZoneBias.High1Time",
            "offset": 36,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "57",
            "kind": "UInt32",
            "name": "TimeZoneBias.High2Time",
            "offset": 40,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "58",
            "kind": "UInt16",
            "name": "ImageNumberLow",
            "offset": 44,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "59",
            "kind": "UInt16",
            "name": "ImageNumberHigh",
            "offset": 46,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "60",
            "kind": "UTF16",
            "name": "NtSystemRoot",
            "offset": 48,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "61",
            "kind": "UInt32",
            "name": "MaxStackTraceDepth",
            "offset": 568,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "62",
            "kind": "UInt32",
            "name": "CryptoExponent",
            "offset": 572,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "63",
            "kind": "UInt32",
            "name": "TimeZoneId",
            "offset": 576,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "64",
            "kind": "UInt32",
            "name": "LargePageMinimum",
            "offset": 580,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "65",
            "kind": "UInt32",
            "name": "AitSamplingValue",
            "offset": 584,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "66",
            "kind": "UInt32",
            "name": "AppCompatFlag",
            "offset": 588,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "67",
            "kind": "UInt64",
            "name": "RNGSeedVersion",
            "offset": 592,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "68",
            "kind": "UInt32",
            "name": "GlobalValidationRunlevel",
            "offset": 600,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "69",
            "kind": "Int32",
            "name": "TimeZoneBiasStamp",
            "offset": 604,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "70",
            "kind": "UInt32",
            "name": "NtBuildNumber",
            "offset": 608,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "71",
            "kind": "UInt32",
            "name": "NtProductType",
            "offset": 612,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "72",
            "kind": "UInt8",
            "name": "ProductTypeIsValid",
            "offset": 616,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "73",
            "kind": "UInt8",
            "name": "Reserved0",
            "offset": 617,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "74",
            "kind": "UInt16",
            "name": "NativeProcessorArchitecture",
            "offset": 618,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "75",
            "kind": "UInt32",
            "name": "NtMajorVersion",
            "offset": 620,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "76",
            "kind": "UInt32",
            "name": "NtMinorVersion",
            "offset": 624,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "85",
            "kind": "UInt32",
            "name": "Reserved1",
            "offset": 692,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "86",
            "kind": "UInt32",
            "name": "Reserved3",
            "offset": 696,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "87",
            "kind": "UInt32",
            "name": "TimeSlip",
            "offset": 700,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "88",
            "kind": "UInt32",
            "name": "AlternativeArchitecture",
            "offset": 704,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "89",
            "kind": "UInt32",
            "name": "BootId",
            "offset": 708,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "90",
            "kind": "UInt64",
            "name": "SystemExpirationDate",
            "offset": 712,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "91",
            "kind": "UInt32",
            "name": "SuiteMask",
            "offset": 720,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "92",
            "kind": "UInt8",
            "name": "KdDebuggerEnabled",
            "offset": 724,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "93",
            "kind": "UInt8",
            "name": "MitigationPolicies",
            "offset": 725,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "94",
            "kind": "UInt16",
            "name": "CyclesPerYield",
            "offset": 726,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "95",
            "kind": "UInt32",
            "name": "ActiveConsoleId",
            "offset": 728,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "96",
            "kind": "UInt32",
            "name": "DismountCount",
            "offset": 732,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "97",
            "kind": "UInt32",
            "name": "ComPlusPackage",
            "offset": 736,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "98",
            "kind": "UInt32",
            "name": "LastSystemRITEventTickCount",
            "offset": 740,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "99",
            "kind": "UInt32",
            "name": "NumberOfPhysicalPages",
            "offset": 744,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "100",
            "kind": "UInt8",
            "name": "SafeBootMode",
            "offset": 748,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "101",
            "kind": "UInt8",
            "name": "VirtualizationFlags",
            "offset": 749,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "102",
            "kind": "UInt16",
            "name": "Reserved12",
            "offset": 750,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "103",
            "kind": "Hex32",
            "name": "SharedDataFlags",
            "offset": 752,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "104",
            "kind": "UInt32",
            "name": "DataFlagsPad",
            "offset": 756,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "105",
            "kind": "UInt64",
            "name": "TestRetInstruction",
            "offset": 760,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "106",
            "kind": "Int64",
            "name": "QpcFrequency",
            "offset": 768,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "107",
            "kind": "UInt32",
            "name": "SystemCall",
            "offset": 776,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "108",
            "kind": "UInt32",
            "name": "Reserved2",
            "offset": 780,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "109",
            "kind": "UInt64",
            "name": "FullNumberOfPhysicalPages",
            "offset": 784,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "110",
            "kind": "UInt64",
            "name": "SystemCallPad",
            "offset": 792,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "111",
            "kind": "UInt32",
            "name": "TickCount.LowPart",
            "offset": 800,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "112",
            "kind": "UInt32",
            "name": "TickCount.High1Time",
            "offset": 804,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "113",
            "kind": "UInt32",
            "name": "TickCount.High2Time",
            "offset": 808,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "114",
            "kind": "UInt32",
            "name": "TickCountPad",
            "offset": 812,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "115",
            "kind": "UInt32",
            "name": "Cookie",
            "offset": 816,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "116",
            "kind": "UInt32",
            "name": "CookiePad",
            "offset": 820,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "117",
            "kind": "Int64",
            "name": "ConsoleSessionForegroundProcessId",
            "offset": 824,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "118",
            "kind": "UInt64",
            "name": "TimeUpdateLock",
            "offset": 832,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "119",
            "kind": "UInt64",
            "name": "BaselineSystemTimeQpc",
            "offset": 840,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "120",
            "kind": "UInt64",
            "name": "BaselineInterruptTimeQpc",
            "offset": 848,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "121",
            "kind": "UInt64",
            "name": "QpcSystemTimeIncrement",
            "offset": 856,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "122",
            "kind": "UInt64",
            "name": "QpcInterruptTimeIncrement",
            "offset": 864,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "123",
            "kind": "UInt8",
            "name": "QpcSystemTimeIncrementShift",
            "offset": 872,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "124",
            "kind": "UInt8",
            "name": "QpcInterruptTimeIncrementShift",
            "offset": 873,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "125",
            "kind": "UInt16",
            "name": "UnparkedProcessorCount",
            "offset": 874,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "130",
            "kind": "UInt32",
            "name": "TelemetryCoverageRound",
            "offset": 892,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "147",
            "kind": "UInt32",
            "name": "ImageFileExecutionOptions",
            "offset": 928,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "148",
            "kind": "UInt32",
            "name": "LangGenerationCount",
            "offset": 932,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "149",
            "kind": "UInt64",
            "name": "Reserved4",
            "offset": 936,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "150",
            "kind": "UInt64",
            "name": "InterruptTimeBias",
            "offset": 944,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "151",
            "kind": "UInt64",
            "name": "QpcBias",
            "offset": 952,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "152",
            "kind": "UInt32",
            "name": "ActiveProcessorCount",
            "offset": 960,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "153",
            "kind": "UInt8",
            "name": "ActiveGroupCount",
            "offset": 964,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "154",
            "kind": "UInt8",
            "name": "Reserved9",
            "offset": 965,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "155",
            "kind": "UInt16",
            "name": "QpcData",
            "offset": 966,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "156",
            "kind": "UInt64",
            "name": "TimeZoneBiasEffectiveStart",
            "offset": 968,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "157",
            "kind": "UInt64",
            "name": "TimeZoneBiasEffectiveEnd",
            "offset": 976,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "158",
            "kind": "UInt64",
            "name": "XState.EnabledFeatures",
            "offset": 984,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "159",
            "kind": "UInt64",
            "name": "XState.EnabledVolatileFeatures",
            "offset": 992,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "160",
            "kind": "UInt32",
            "name": "XState.Size",
            "offset": 1000,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "161",
            "kind": "Hex32",
            "name": "XState.ControlFlags",
            "offset": 1004,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "534",
            "kind": "UInt64",
            "name": "XState.EnabledSupervisorFeatures",
            "offset": 1520,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "535",
            "kind": "UInt64",
            "name": "XState.AlignedFeatures",
            "offset": 1528,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "536",
            "kind": "UInt32",
            "name": "XState.AllFeatureSize",
            "offset": 1536,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "601",
            "kind": "UInt64",
            "name": "XState.EnabledUserVisibleSupervisorFeatures",
            "offset": 1796,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "602",
            "kind": "Hex64",
            "name": "XState.Padding0",
            "offset": 1804,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "603",
            "kind": "Hex64",
            "name": "XState.Padding1",
            "offset": 1812,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "604",
            "kind": "Hex32",
            "name": "XState.Padding2",
            "offset": 1820,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "676",
            "kind": "Struct",
            "name": "xf",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "strLen": 64,
            "structTypeName": "XSTATE_FEATURE"
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "677",
            "kind": "UInt32",
            "name": "Offset",
            "offset": 0,
            "parentId": "676",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "678",
            "kind": "UInt32",
            "name": "Size",
            "offset": 4,
            "parentId": "676",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 64,
            "collapsed": true,
            "elementKind": "UInt8",
            "id": "679",
            "kind": "Array",
            "name": "ProcessorFeatures",
            "offset": 628,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 4,
            "collapsed": true,
            "elementKind": "UInt32",
            "id": "680",
            "kind": "Array",
            "name": "EnclaveFeatureMask",
            "offset": 876,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 16,
            "collapsed": true,
            "elementKind": "UInt16",
            "id": "681",
            "kind": "Array",
            "name": "UserModeGlobalLogger",
            "offset": 896,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 64,
            "collapsed": true,
            "elementKind": "Struct",
            "id": "688",
            "kind": "Array",
            "name": "XState.Features",
            "offset": 1008,
            "parentId": "46",
            "refId": "676",
            "strLen": 64
        },
        {
            "arrayLen": 64,
            "collapsed": true,
            "elementKind": "UInt32",
            "id": "690",
            "kind": "Array",
            "name": "XState.AllFeatures",
            "offset": 1540,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "691",
            "kind": "UInt32",
            "name": "FeatureConfigChangeStamp.LowPart",
            "offset": 1824,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "692",
            "kind": "UInt32",
            "name": "FeatureConfigChangeStamp.High1Time",
            "offset": 1828,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "693",
            "kind": "UInt32",
            "name": "FeatureConfigChangeStamp.High2Time",
            "offset": 1832,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "694",
            "kind": "UInt32",
            "name": "Spare",
            "offset": 1836,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 1,
            "collapsed": false,
            "elementKind": "UInt8",
            "id": "695",
            "kind": "UInt64",
            "name": "UserPointerAuthMask",
            "offset": 1840,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        },
        {
            "arrayLen": 210,
            "collapsed": true,
            "elementKind": "UInt32",
            "id": "696",
            "kind": "Array",
            "name": "Reserved10",
            "offset": 1848,
            "parentId": "46",
            "refId": "0",
            "strLen": 64
        }
    ]
}

```

`src/examples/MMPFN.rcx`:

```rcx
{
    "baseAddress": "FFFFCA8010000000",
    "nextId": "3000",
    "nodes": [
        {
            "id": "100",
            "kind": "Struct",
            "name": "list_entry",
            "structTypeName": "_LIST_ENTRY",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "101",
            "kind": "Pointer64",
            "name": "Flink",
            "offset": 0,
            "parentId": "100",
            "refId": "100",
            "collapsed": true
        },
        {
            "id": "102",
            "kind": "Pointer64",
            "name": "Blink",
            "offset": 8,
            "parentId": "100",
            "refId": "100",
            "collapsed": true
        },

        {
            "id": "200",
            "kind": "Struct",
            "name": "balanced_node",
            "structTypeName": "_RTL_BALANCED_NODE",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "210",
            "kind": "Struct",
            "name": "",
            "classKeyword": "union",
            "offset": 0,
            "parentId": "200",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "211",
            "kind": "Pointer64",
            "name": "Left",
            "offset": 0,
            "parentId": "210",
            "refId": "200",
            "collapsed": true
        },
        {
            "id": "212",
            "kind": "Pointer64",
            "name": "Right",
            "offset": 8,
            "parentId": "210",
            "refId": "200",
            "collapsed": true
        },
        {
            "id": "220",
            "kind": "Struct",
            "name": "",
            "classKeyword": "union",
            "offset": 16,
            "parentId": "200",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "221",
            "kind": "UInt64",
            "name": "ParentValue",
            "offset": 0,
            "parentId": "220"
        },

        {
            "id": "300",
            "kind": "Struct",
            "name": "mmpte",
            "structTypeName": "_MMPTE",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "301",
            "kind": "Struct",
            "name": "u",
            "classKeyword": "union",
            "offset": 0,
            "parentId": "300",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "302",
            "kind": "UInt64",
            "name": "Long",
            "offset": 0,
            "parentId": "301"
        },
        {
            "id": "303",
            "kind": "Struct",
            "name": "Hard",
            "structTypeName": "_MMPTE_HARDWARE",
            "offset": 0,
            "parentId": "301",
            "refId": "400",
            "collapsed": true
        },
        {
            "id": "304",
            "kind": "Struct",
            "name": "Proto",
            "structTypeName": "_MMPTE_PROTOTYPE",
            "offset": 0,
            "parentId": "301",
            "refId": "600",
            "collapsed": true
        },
        {
            "id": "305",
            "kind": "Struct",
            "name": "Soft",
            "structTypeName": "_MMPTE_SOFTWARE",
            "offset": 0,
            "parentId": "301",
            "refId": "500",
            "collapsed": true
        },
        {
            "id": "306",
            "kind": "Struct",
            "name": "Trans",
            "structTypeName": "_MMPTE_TRANSITION",
            "offset": 0,
            "parentId": "301",
            "refId": "700",
            "collapsed": true
        },
        {
            "id": "307",
            "kind": "Struct",
            "name": "Subsect",
            "structTypeName": "_MMPTE_SUBSECTION",
            "offset": 0,
            "parentId": "301",
            "refId": "800",
            "collapsed": true
        },
        {
            "id": "308",
            "kind": "Struct",
            "name": "TimeStamp",
            "structTypeName": "_MMPTE_TIMESTAMP",
            "offset": 0,
            "parentId": "301",
            "refId": "900",
            "collapsed": true
        },
        {
            "id": "309",
            "kind": "Struct",
            "name": "List",
            "structTypeName": "_MMPTE_LIST",
            "offset": 0,
            "parentId": "301",
            "refId": "1000",
            "collapsed": true
        },

        {
            "id": "400",
            "kind": "Struct",
            "name": "mmpte_hardware",
            "structTypeName": "_MMPTE_HARDWARE",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "401",
            "kind": "Hex64",
            "name": "Valid:1 Dirty1:1 Owner:1 WriteThrough:1 CacheDisable:1 Accessed:1 Dirty:1 LargePage:1 Global:1 CopyOnWrite:1 Unused:1 Write:1 PageFrameNumber:40 ReservedForSoftware:4 WsleAge:4 WsleProtection:3 NoExecute:1",
            "offset": 0,
            "parentId": "400"
        },

        {
            "id": "500",
            "kind": "Struct",
            "name": "mmpte_software",
            "structTypeName": "_MMPTE_SOFTWARE",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "501",
            "kind": "Hex64",
            "name": "Valid:1 PageFileReserved:1 PageFileAllocated:1 ColdPage:1 SwizzleBit:1 Protection:5 Prototype:1 Transition:1 PageFileLow:4 UsedPageTableEntries:10 ShadowStack:1 OnStandbyLookaside:1 Unused:4 PageFileHigh:32",
            "offset": 0,
            "parentId": "500"
        },

        {
            "id": "600",
            "kind": "Struct",
            "name": "mmpte_prototype",
            "structTypeName": "_MMPTE_PROTOTYPE",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "601",
            "kind": "Hex64",
            "name": "Valid:1 DemandFillProto:1 HiberVerifyConverted:1 ReadOnly:1 SwizzleBit:1 Protection:5 Prototype:1 Combined:1 Unused1:4 ProtoAddress:48",
            "offset": 0,
            "parentId": "600"
        },

        {
            "id": "700",
            "kind": "Struct",
            "name": "mmpte_transition",
            "structTypeName": "_MMPTE_TRANSITION",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "701",
            "kind": "Hex64",
            "name": "Valid:1 Write:1 OnStandbyLookaside:1 IoTracker:1 SwizzleBit:1 Protection:5 Prototype:1 Transition:1 PageFrameNumber:40 Unused:12",
            "offset": 0,
            "parentId": "700"
        },

        {
            "id": "800",
            "kind": "Struct",
            "name": "mmpte_subsection",
            "structTypeName": "_MMPTE_SUBSECTION",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "801",
            "kind": "Hex64",
            "name": "Valid:1 Unused0:2 OnStandbyLookaside:1 SwizzleBit:1 Protection:5 Prototype:1 ColdPage:1 Unused2:3 ExecutePrivilege:1 SubsectionAddress:48",
            "offset": 0,
            "parentId": "800"
        },

        {
            "id": "900",
            "kind": "Struct",
            "name": "mmpte_timestamp",
            "structTypeName": "_MMPTE_TIMESTAMP",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "901",
            "kind": "Hex64",
            "name": "MustBeZero:1 Unused:3 SwizzleBit:1 Protection:5 Prototype:1 Transition:1 PageFileLow:4 Reserved:16 GlobalTimeStamp:32",
            "offset": 0,
            "parentId": "900"
        },

        {
            "id": "1000",
            "kind": "Struct",
            "name": "mmpte_list",
            "structTypeName": "_MMPTE_LIST",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1001",
            "kind": "Hex64",
            "name": "Valid:1 OneEntry:1 filler0:2 SwizzleBit:1 Protection:5 Prototype:1 Transition:1 filler1:13 NextEntry:39",
            "offset": 0,
            "parentId": "1000"
        },

        {
            "id": "1100",
            "kind": "Struct",
            "name": "mipfnflink",
            "structTypeName": "_MIPFNFLINK",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1101",
            "kind": "Hex64",
            "name": "Flink",
            "offset": 0,
            "parentId": "1100"
        },

        {
            "id": "1200",
            "kind": "Struct",
            "name": "mipfnblink",
            "structTypeName": "_MIPFNBLINK",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1201",
            "kind": "Hex64",
            "name": "Blink",
            "offset": 0,
            "parentId": "1200"
        },

        {
            "id": "1300",
            "kind": "Struct",
            "name": "mmpfnentry1",
            "structTypeName": "_MMPFNENTRY1",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1301",
            "kind": "Hex8",
            "name": "Flags",
            "offset": 0,
            "parentId": "1300"
        },

        {
            "id": "1400",
            "kind": "Struct",
            "name": "mmpfnentry3",
            "structTypeName": "_MMPFNENTRY3",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1401",
            "kind": "Hex8",
            "name": "Flags",
            "offset": 0,
            "parentId": "1400"
        },

        {
            "id": "1500",
            "kind": "Struct",
            "name": "mi_pfn_flags",
            "structTypeName": "_MI_PFN_FLAGS",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1501",
            "kind": "Hex32",
            "name": "Flags",
            "offset": 0,
            "parentId": "1500"
        },

        {
            "id": "1600",
            "kind": "Struct",
            "name": "mi_pfn_flags4",
            "structTypeName": "_MI_PFN_FLAGS4",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1601",
            "kind": "Hex64",
            "name": "Flags",
            "offset": 0,
            "parentId": "1600"
        },

        {
            "id": "1700",
            "kind": "Struct",
            "name": "mi_pfn_flags5",
            "structTypeName": "_MI_PFN_FLAGS5",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": true
        },
        {
            "id": "1701",
            "kind": "Hex32",
            "name": "Flags",
            "offset": 0,
            "parentId": "1700"
        },

        {
            "id": "2000",
            "kind": "Struct",
            "name": "mmpfn",
            "structTypeName": "_MMPFN",
            "offset": 0,
            "parentId": "0",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "2001",
            "kind": "Struct",
            "name": "",
            "classKeyword": "union",
            "offset": 0,
            "parentId": "2000",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "2010",
            "kind": "Struct",
            "name": "ListEntry",
            "structTypeName": "_LIST_ENTRY",
            "offset": 0,
            "parentId": "2001",
            "refId": "100",
            "collapsed": true
        },
        {
            "id": "2011",
            "kind": "Struct",
            "name": "TreeNode",
            "structTypeName": "_RTL_BALANCED_NODE",
            "offset": 0,
            "parentId": "2001",
            "refId": "200",
            "collapsed": true
        },
        {
            "id": "2012",
            "kind": "Struct",
            "name": "",
            "offset": 0,
            "parentId": "2001",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "2013",
            "kind": "Struct",
            "name": "u1",
            "structTypeName": "_MIPFNFLINK",
            "offset": 0,
            "parentId": "2012",
            "refId": "1100",
            "collapsed": true
        },
        {
            "id": "2014",
            "kind": "Struct",
            "name": "",
            "classKeyword": "union",
            "offset": 8,
            "parentId": "2012",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "2015",
            "kind": "Pointer64",
            "name": "PteAddress",
            "offset": 0,
            "parentId": "2014",
            "refId": "300",
            "collapsed": true
        },
        {
            "id": "2016",
            "kind": "UInt64",
            "name": "PteLong",
            "offset": 0,
            "parentId": "2014"
        },
        {
            "id": "2017",
            "kind": "Struct",
            "name": "OriginalPte",
            "structTypeName": "_MMPTE",
            "offset": 16,
            "parentId": "2012",
            "refId": "300",
            "collapsed": true
        },

        {
            "id": "2020",
            "kind": "Struct",
            "name": "u2",
            "structTypeName": "_MIPFNBLINK",
            "offset": 24,
            "parentId": "2000",
            "refId": "1200",
            "collapsed": true
        },

        {
            "id": "2030",
            "kind": "Struct",
            "name": "u3",
            "classKeyword": "union",
            "offset": 32,
            "parentId": "2000",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "2031",
            "kind": "Struct",
            "name": "",
            "offset": 0,
            "parentId": "2030",
            "refId": "0",
            "collapsed": false
        },
        {
            "id": "2032",
            "kind": "UInt16",
            "name": "ReferenceCount",
            "offset": 0,
            "parentId": "2031"
        },
        {
            "id": "2033",
            "kind": "Struct",
            "name": "e1",
            "structTypeName": "_MMPFNENTRY1",
            "offset": 2,
            "parentId": "2031",
            "refId": "1300",
            "collapsed": true
        },
        {
            "id": "2034",
            "kind": "Struct",
            "name": "e4",
            "structTypeName": "_MI_PFN_FLAGS",
            "offset": 0,
            "parentId": "2030",
            "refId": "1500",
            "collapsed": true
        },

        {
            "id": "2040",
            "kind": "Struct",
            "name": "u5",
            "structTypeName": "_MI_PFN_FLAGS5",
            "offset": 36,
            "parentId": "2000",
            "refId": "1700",
            "collapsed": true
        },

        {
            "id": "2050",
            "kind": "Struct",
            "name": "u4",
            "structTypeName": "_MI_PFN_FLAGS4",
            "offset": 40,
            "parentId": "2000",
            "refId": "1600",
            "collapsed": true
        }
    ]
}

```

`src/format.cpp`:

```cpp
#include "core.h"
#include "addressparser.h"
#include <cmath>
#include <cstring>
#include <limits>

namespace rcx::fmt {

// ── Column layout ──
// COL_TYPE and COL_NAME use shared constants from core.h (kColType, kColName)
static constexpr int COL_TYPE    = kColType;
static constexpr int COL_NAME    = kColName;
static constexpr int COL_VALUE   = kColValue;
static constexpr int COL_COMMENT = 28;  // "// Enter=Save Esc=Cancel" fits
static const QString SEP = QStringLiteral(" ");

static QString fit(QString s, int w) {
    if (w <= 0) return {};
    if (s.size() > w) {
        if (w >= 2) s = s.left(w - 1) + QChar(0x2026); // ellipsis
        else s = s.left(w);
    }
    return s.leftJustified(w, ' ');
}

// Like fit() but overflows instead of truncating: if s exceeds w, return full string
static QString fitOverflow(const QString& s, int w) {
    if (w <= 0) return {};
    if (s.size() <= w)
        return s.leftJustified(w, ' ');
    return s;
}

// ── Type name ──

// Override seam: injectable type-name provider
static TypeNameFn g_typeNameFn = nullptr;

void setTypeNameProvider(TypeNameFn fn) { g_typeNameFn = fn; }

// Unpadded type name for width calculation
QString typeNameRaw(NodeKind kind) {
    if (g_typeNameFn) return g_typeNameFn(kind);
    auto* m = kindMeta(kind);
    return m ? QString::fromLatin1(m->typeName) : QStringLiteral("???");
}

QString typeName(NodeKind kind, int colType) {
    if (g_typeNameFn) return fit(g_typeNameFn(kind), colType);
    auto* m = kindMeta(kind);
    return fit(m ? QString::fromLatin1(m->typeName) : QStringLiteral("???"), colType);
}

// Array type string: "uint32_t[16]" or "Material[2]"
QString arrayTypeName(NodeKind elemKind, int count, const QString& structName) {
    QString elem;
    if (elemKind == NodeKind::Struct && !structName.isEmpty())
        elem = structName;
    else {
        auto* m = kindMeta(elemKind);
        elem = m ? QString::fromLatin1(m->typeName) : QStringLiteral("???");
    }
    return elem + QStringLiteral("[") + QString::number(count) + QStringLiteral("]");
}

// Pointer type string: "void*" or "StructName*"
QString pointerTypeName(NodeKind kind, const QString& targetName) {
    Q_UNUSED(kind);
    QString target = targetName.isEmpty() ? QStringLiteral("void") : targetName;
    return target + QStringLiteral("*");
}

// ── Value formatting ──

static QString hexVal(uint64_t v) {
    return QStringLiteral("0x") + QString::number(v, 16);
}

static QString rawHex(uint64_t v, int digits) {
    return QString::number(v, 16).rightJustified(digits, '0');
}

QString fmtInt8(int8_t v)     { return hexVal((uint8_t)v); }
QString fmtInt16(int16_t v)   { return hexVal((uint16_t)v); }
QString fmtInt32(int32_t v)   { return hexVal((uint32_t)v); }
QString fmtInt64(int64_t v)   { return hexVal((uint64_t)v); }
QString fmtUInt8(uint8_t v)   { return hexVal(v); }
QString fmtUInt16(uint16_t v) { return hexVal(v); }
QString fmtUInt32(uint32_t v) { return hexVal(v); }
QString fmtUInt64(uint64_t v) { return hexVal(v); }

QString fmtFloat(float v) {
    if (std::isnan(v)) return QStringLiteral("NaN");
    if (std::isinf(v)) return v > 0 ? QStringLiteral("inff") : QStringLiteral("-inff");

    // 6 significant digits — covers full single-precision range
    QString s = QString::number(v, 'g', 6);

    // If 'g' chose scientific notation, reformat as plain decimal
    if (s.contains('e') || s.contains('E')) {
        s = QString::number(v, 'f', 8);
        if (s.contains('.')) {
            int i = s.size() - 1;
            while (i > 0 && s[i] == '0') i--;
            if (s[i] == '.') i++;  // keep at least one decimal digit
            s.truncate(i + 1);
        }
    }

    if (!s.contains('.'))
        s += QStringLiteral(".f");
    else
        s += QLatin1Char('f');
    return s;
}
QString fmtDouble(double v) {
    QString s = QString::number(v, 'g', 6);
    if (!s.contains('.') && !s.contains('e') && !s.contains('E'))
        s += QStringLiteral(".0");
    return s;
}
QString fmtBool(uint8_t v)    { return v ? QStringLiteral("true") : QStringLiteral("false"); }

QString fmtPointer32(uint32_t v) {
    if (v == 0) return QStringLiteral("-> NULL");
    return QStringLiteral("-> ") + hexVal(v);
}

QString fmtPointer64(uint64_t v) {
    if (v == 0) return QStringLiteral("-> NULL");
    return QStringLiteral("-> ") + hexVal(v);
}

// ── Indentation ──

QString indent(int depth) {
    return QString(depth * 3, ' ');
}

// ── Offset margin ──

QString fmtOffsetMargin(uint64_t absoluteOffset, bool isContinuation, int hexDigits) {
    if (isContinuation) return QStringLiteral("  \u00B7 ");
    return QString::number(absoluteOffset, 16).toUpper()
               .rightJustified(hexDigits, '0') + QChar(' ');
}

// ── Struct type name (for width calculation) ──

QString structTypeName(const Node& node) {
    // Full type string: "struct TypeName", "union TypeName", "class TypeName", etc.
    QString base = node.resolvedClassKeyword();
    if (!node.structTypeName.isEmpty())
        return base + QStringLiteral(" ") + node.structTypeName;
    return base;
}

// ── Struct header / footer ──

QString fmtStructHeader(const Node& node, int depth, bool collapsed, int colType, int colName, bool compact) {
    // Columnar format: <type> <name> { (or no brace when collapsed)
    QString ind = indent(depth);
    QString rawType = structTypeName(node);
    QString suffix = collapsed ? QString() : QStringLiteral("{");
    if (node.name.isEmpty()) {
        // Anonymous struct/union: "union {" with no column padding
        return ind + rawType + SEP + suffix;
    }
    QString type = compact ? fitOverflow(rawType, colType) : fit(rawType, colType);
    return ind + type + SEP + node.name + SEP + suffix;
}

QString fmtStructFooter(const Node& /*node*/, int depth, int /*totalSize*/) {
    return indent(depth) + QStringLiteral("};");
}

// ── Array header ──
// Columnar format: <type[count]> <name> { (or no brace when collapsed)
QString fmtArrayHeader(const Node& node, int depth, int /*viewIdx*/, bool collapsed, int colType, int colName, const QString& elemStructName, bool compact) {
    QString ind = indent(depth);
    QString rawType = arrayTypeName(node.elementKind, node.arrayLen, elemStructName);
    QString type = compact ? fitOverflow(rawType, colType) : fit(rawType, colType);
    QString suffix = collapsed ? QString() : QStringLiteral("{");
    return ind + type + SEP + node.name + SEP + suffix;
}

// ── Pointer header (merged pointer + struct header) ──

QString fmtPointerHeader(const Node& node, int depth, bool collapsed,
                         const Provider& prov, uint64_t addr,
                         const QString& ptrTypeName, int colType, int colName,
                         bool compact) {
    QString ind = indent(depth);
    bool overflow = compact && ptrTypeName.size() > colType;
    QString type = compact ? fitOverflow(ptrTypeName, colType) : fit(ptrTypeName, colType);
    if (collapsed) {
        if (overflow) {
            // Overflow: no column padding
            return ind + type + SEP + node.name + SEP + readValue(node, prov, addr, 0);
        }
        // Collapsed: show pointer value instead of brace (name padded for value alignment)
        QString name = fit(node.name, colName);
        QString val = fit(readValue(node, prov, addr, 0), COL_VALUE);
        return ind + type + SEP + name + SEP + val;
    }
    return ind + type + SEP + node.name + SEP + QStringLiteral("{");
}

// ── Hex / ASCII preview ──

static inline bool isAsciiPrintable(uint8_t c) { return c >= 0x20 && c <= 0x7E; }

// Escape control characters for display
static QString sanitizeString(const QString& s) {
    QString out;
    out.reserve(s.size() + 8);
    for (QChar c : s) {
        if (c == '\n')      out += QStringLiteral("\\n");
        else if (c == '\r') out += QStringLiteral("\\r");
        else if (c == '\t') out += QStringLiteral("\\t");
        else if (c == '\\') out += QStringLiteral("\\\\");
        else if (c < QChar(0x20)) out += QStringLiteral("\\x") + QString::number(c.unicode(), 16);
        else out += c;
    }
    return out;
}

static QString bytesToAscii(const QByteArray& b, int slot) {
    QString out;
    out.reserve(slot);
    for (int i = 0; i < slot; ++i) {
        uint8_t c = (i < b.size()) ? (uint8_t)b[i] : 0;
        out += isAsciiPrintable(c) ? QChar(c) : QChar('.');
    }
    return out;
}

static QString bytesToHex(const QByteArray& b, int slot) {
    QString out;
    out.reserve(slot * 3);
    for (int i = 0; i < slot; ++i) {
        uint8_t c = (i < b.size()) ? (uint8_t)b[i] : 0;
        out += QString::asprintf("%02X", (unsigned)c);
        if (i + 1 < slot) out += ' ';
    }
    return out;
}

static QString fmtAsciiAndBytes(const Provider& prov, uint64_t addr,
                                int sizeBytes, int slotBytes = 8) {
    const int slot = qMax(slotBytes, sizeBytes);
    QByteArray b = prov.isReadable(addr, slot)
                       ? prov.readBytes(addr, slot)
                       : QByteArray(slot, '\0');
    return bytesToAscii(b, slot) + QStringLiteral("  ") + bytesToHex(b, slot);
}

// ── Single value from provider (unified) ──

enum class ValueMode { Display, Editable };

static QString readValueImpl(const Node& node, const Provider& prov,
                             uint64_t addr, int subLine, ValueMode mode) {
    const bool display = (mode == ValueMode::Display);
    switch (node.kind) {
    case NodeKind::Hex8:      return display ? hexVal(prov.readU8(addr))  : rawHex(prov.readU8(addr), 2);
    case NodeKind::Hex16:     return display ? hexVal(prov.readU16(addr)) : rawHex(prov.readU16(addr), 4);
    case NodeKind::Hex32:     return display ? hexVal(prov.readU32(addr)) : rawHex(prov.readU32(addr), 8);
    case NodeKind::Hex64:     return display ? hexVal(prov.readU64(addr)) : rawHex(prov.readU64(addr), 16);
    case NodeKind::Int8:      return fmtInt8((int8_t)prov.readU8(addr));
    case NodeKind::Int16:     return fmtInt16((int16_t)prov.readU16(addr));
    case NodeKind::Int32:     return fmtInt32((int32_t)prov.readU32(addr));
    case NodeKind::Int64:     return fmtInt64((int64_t)prov.readU64(addr));
    case NodeKind::UInt8:     return fmtUInt8(prov.readU8(addr));
    case NodeKind::UInt16:    return fmtUInt16(prov.readU16(addr));
    case NodeKind::UInt32:    return fmtUInt32(prov.readU32(addr));
    case NodeKind::UInt64:    return fmtUInt64(prov.readU64(addr));
    case NodeKind::Float:     { auto s = fmtFloat(prov.readF32(addr));   return display ? s : s.trimmed(); }
    case NodeKind::Double:    { auto s = fmtDouble(prov.readF64(addr));  return display ? s : s.trimmed(); }
    case NodeKind::Bool:      return fmtBool(prov.readU8(addr));
    case NodeKind::Pointer32: {
        uint32_t val = prov.readU32(addr);
        if (!display) return rawHex(val, 8);
        QString s = fmtPointer32(val);
        QString sym = prov.getSymbol((uint64_t)val);
        if (!sym.isEmpty()) s += QStringLiteral("  // ") + sym;
        return s;
    }
    case NodeKind::Pointer64: {
        uint64_t val = prov.readU64(addr);
        // Primitive pointer: dereference and show target value
        // (hex/ptr/fnptr targets fall through to plain void* display)
        if (node.ptrDepth > 0 && isValidPrimitivePtrTarget(node.elementKind) && val != 0) {
            uint64_t target = val;
            for (int d = 1; d < node.ptrDepth && target != 0; d++)
                target = prov.isReadable(target, 8) ? prov.readU64(target) : 0;
            if (target != 0 && prov.isReadable(target, sizeForKind(node.elementKind))) {
                // Create a temporary node of the target kind to format the value
                Node tmp;
                tmp.kind = node.elementKind;
                tmp.strLen = node.strLen;
                QString derefVal = readValueImpl(tmp, prov, target, 0, mode);
                if (display) {
                    QString arrow = QStringLiteral("-> ");
                    QString sym = prov.getSymbol(val);
                    if (!sym.isEmpty())
                        return arrow + derefVal + QStringLiteral("  // ") + sym;
                    return arrow + derefVal;
                }
                return derefVal;
            }
            if (!display) return rawHex(val, 16);
            return fmtPointer64(val);
        }
        if (!display) return rawHex(val, 16);
        QString s = fmtPointer64(val);
        QString sym = prov.getSymbol(val);
        if (!sym.isEmpty()) s += QStringLiteral("  // ") + sym;
        return s;
    }
    case NodeKind::FuncPtr32: {
        uint32_t val = prov.readU32(addr);
        if (!display) return rawHex(val, 8);
        QString s = fmtPointer32(val);
        QString sym = prov.getSymbol((uint64_t)val);
        if (!sym.isEmpty()) s += QStringLiteral("  // ") + sym;
        return s;
    }
    case NodeKind::FuncPtr64: {
        uint64_t val = prov.readU64(addr);
        if (!display) return rawHex(val, 16);
        QString s = fmtPointer64(val);
        QString sym = prov.getSymbol(val);
        if (!sym.isEmpty()) s += QStringLiteral("  // ") + sym;
        return s;
    }
    case NodeKind::Vec2:
    case NodeKind::Vec3:
    case NodeKind::Vec4: {
        int count = sizeForKind(node.kind) / 4;
        QStringList parts;
        for (int i = 0; i < count; i++)
            parts << fmtFloat(prov.readF32(addr + i * 4)).trimmed();
        return parts.join(QStringLiteral(", "));
    }
    case NodeKind::Mat4x4: {
        if (!display) return {};  // not editable as single value
        if (subLine < 0 || subLine >= 4) return QStringLiteral("?");
        QString line = QStringLiteral("row%1 [").arg(subLine);
        for (int c = 0; c < 4; c++) {
            if (c > 0) line += QStringLiteral(", ");
            line += fmtFloat(prov.readF32(addr + (subLine * 4 + c) * 4)).trimmed();
        }
        line += QStringLiteral("]");
        return line;
    }
    case NodeKind::UTF8: {
        QByteArray bytes = prov.readBytes(addr, node.strLen);
        int end = bytes.indexOf('\0');
        if (end >= 0) bytes.truncate(end);
        QString s = QString::fromUtf8(bytes);
        if (display) s = sanitizeString(s);
        return display ? (QStringLiteral("\"") + s + QStringLiteral("\"")) : s;
    }
    case NodeKind::UTF16: {
        QByteArray bytes = prov.readBytes(addr, node.strLen * 2);
        QString s = QString::fromUtf16(reinterpret_cast<const char16_t*>(bytes.data()),
                                       bytes.size() / 2);
        int end = s.indexOf(QChar(0));
        if (end >= 0) s.truncate(end);
        if (display) s = sanitizeString(s);
        return display ? (QStringLiteral("L\"") + s + QStringLiteral("\"")) : s;
    }
    default:
        return {};
    }
}

QString readValue(const Node& node, const Provider& prov,
                  uint64_t addr, int subLine) {
    return readValueImpl(node, prov, addr, subLine, ValueMode::Display);
}

// ── Full node line ──

QString fmtNodeLine(const Node& node, const Provider& prov,
                    uint64_t addr, int depth, int subLine,
                    const QString& comment, int colType, int colName,
                    const QString& typeOverride, bool compact) {
    QString ind = indent(depth);

    // Compute raw type string for overflow detection
    QString rawType = typeOverride.isEmpty() ? typeNameRaw(node.kind) : typeOverride;
    bool overflow = compact && rawType.size() > colType;

    QString type = overflow ? fitOverflow(rawType, colType)
                            : (typeOverride.isEmpty() ? typeName(node.kind, colType)
                                                      : fit(typeOverride, colType));
    QString name = overflow ? node.name : fit(node.name, colName);

    // Effective column width for this line (accounts for overflow, clamped to hard max)
    int effectiveColType = overflow ? rawType.size() : colType;
    // Blank prefix for continuation lines (same width as type+sep+name+sep)
    const int prefixW = effectiveColType + (overflow ? name.size() : colName) + 2 * kSepWidth;

    // Comment suffix (only present when a comment is provided; no trailing padding)
    QString cmtSuffix = comment.isEmpty() ? QString()
                                          : fit(comment, COL_COMMENT);

    // Mat4x4: subLine 0..3 = rows — no truncation so large floats always display fully
    if (node.kind == NodeKind::Mat4x4) {
        QString val = readValue(node, prov, addr, subLine);
        if (subLine == 0) return ind + type + SEP + name + SEP + val + cmtSuffix;
        return ind + QString(prefixW, ' ') + val + cmtSuffix;
    }

    // Hex nodes: hex byte preview (ASCII padded to colName to align with value column)
    if (isHexPreview(node.kind)) {
        const int sz = sizeForKind(node.kind);
        QByteArray b = prov.isReadable(addr, sz)
            ? prov.readBytes(addr, sz) : QByteArray(sz, '\0');
        QString ascii = bytesToAscii(b, sz).leftJustified(colName, ' ');
        QString hex = bytesToHex(b, sz).leftJustified(23, ' ');
        return ind + type + SEP + ascii + SEP + hex + cmtSuffix;
    }

    QString val = overflow ? readValue(node, prov, addr, subLine)
                           : fit(readValue(node, prov, addr, subLine), COL_VALUE);
    return ind + type + SEP + name + SEP + val + cmtSuffix;
}

// ── Editable value (parse-friendly form for edit dialog) ──

QString editableValue(const Node& node, const Provider& prov,
                      uint64_t addr, int subLine) {
    return readValueImpl(node, prov, addr, subLine, ValueMode::Editable);
}

// ── Value parsing (text → bytes) ──

template<class T>
static QByteArray toBytes(T v) {
    QByteArray b(sizeof(T), Qt::Uninitialized);
    memcpy(b.data(), &v, sizeof(T));
    return b;
}

static QString stripHex(const QString& s) {
    if (s.startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
        return s.mid(2);
    return s;
}

// Parse ASCII text into raw byte array (each char becomes a byte)
QByteArray parseAsciiValue(const QString& text, int expectedSize, bool* ok) {
    *ok = false;
    if (text.size() != expectedSize) return {};
    QByteArray result(expectedSize, Qt::Uninitialized);
    for (int i = 0; i < expectedSize; i++) {
        uint c = text[i].unicode();
        if (c > 255) return {};  // Non-Latin1 character
        result[i] = (char)c;
    }
    *ok = true;
    return result;
}

// Parse space-separated hex byte string into raw byte array (no endian conversion)
static QByteArray parseHexBytes(const QString& s, int expectedSize, bool* ok) {
    QString clean = s;
    clean.remove(' ');
    if (clean.size() != expectedSize * 2) { *ok = false; return {}; }
    QByteArray result(expectedSize, Qt::Uninitialized);
    for (int i = 0; i < expectedSize; i++) {
        bool byteOk;
        uint byte = clean.mid(i * 2, 2).toUInt(&byteOk, 16);
        if (!byteOk) { *ok = false; return {}; }
        result[i] = (char)byte;
    }
    *ok = true;
    return result;
}

// Range-checked narrowing: sets *ok = false if parsed value doesn't fit in T
template<class T, class ParseT>
static QByteArray parseIntChecked(ParseT val, bool* ok) {
    if (*ok) {
        using L = std::numeric_limits<T>;
        if constexpr (std::is_signed_v<T>) {
            if (val < (ParseT)L::min() || val > (ParseT)L::max()) *ok = false;
        } else {
            if (val > (ParseT)L::max()) *ok = false;
        }
    }
    return *ok ? toBytes<T>(static_cast<T>(val)) : QByteArray{};
}

QByteArray parseValue(NodeKind kind, const QString& text, bool* ok) {
    *ok = false;
    QString s = text.trimmed();

    // Allow empty for string types (will produce zero-length content, caller pads)
    if (s.isEmpty()) {
        if (kind == NodeKind::UTF8 || kind == NodeKind::UTF16) {
            *ok = true;
            return {};
        }
        return {};
    }

    switch (kind) {
    case NodeKind::Hex8:    return parseHexBytes(stripHex(s), 1, ok);
    case NodeKind::Hex16: {
        QString cleaned = stripHex(s);
        // Space-separated bytes → raw byte order (display order preserved)
        if (cleaned.contains(' '))
            return parseHexBytes(cleaned, 2, ok);
        // Single value → native-endian
        uint val = cleaned.toUInt(ok, 16);
        if (*ok && val > 0xFFFF) *ok = false;
        return *ok ? toBytes<uint16_t>(static_cast<uint16_t>(val)) : QByteArray{};
    }
    case NodeKind::Hex32: {
        QString cleaned = stripHex(s);
        // Space-separated bytes → raw byte order (display order preserved)
        if (cleaned.contains(' '))
            return parseHexBytes(cleaned, 4, ok);
        // Single value → native-endian
        uint val = cleaned.toUInt(ok, 16);
        return *ok ? toBytes<uint32_t>(val) : QByteArray{};
    }
    case NodeKind::Hex64: {
        QString cleaned = stripHex(s);
        // Space-separated bytes → raw byte order (display order preserved)
        if (cleaned.contains(' '))
            return parseHexBytes(cleaned, 8, ok);
        // Single value → native-endian
        qulonglong val = cleaned.toULongLong(ok, 16);
        return *ok ? toBytes<uint64_t>(val) : QByteArray{};
    }
    case NodeKind::Int8: {
        bool isHex = s.startsWith("0x", Qt::CaseInsensitive);
        if (isHex) {
            uint val = stripHex(s).toUInt(ok, 16);
            if (*ok && val > 0xFF) *ok = false;
            return *ok ? toBytes<int8_t>(static_cast<int8_t>(val)) : QByteArray{};
        } else {
            int val = s.toInt(ok, 10);
            return parseIntChecked<int8_t>(val, ok);
        }
    }
    case NodeKind::Int16: {
        bool isHex = s.startsWith("0x", Qt::CaseInsensitive);
        if (isHex) {
            uint val = stripHex(s).toUInt(ok, 16);
            if (*ok && val > 0xFFFF) *ok = false;
            return *ok ? toBytes<int16_t>(static_cast<int16_t>(val)) : QByteArray{};
        } else {
            int val = s.toInt(ok, 10);
            return parseIntChecked<int16_t>(val, ok);
        }
    }
    case NodeKind::Int32: {
        bool isHex = s.startsWith("0x", Qt::CaseInsensitive);
        if (isHex) {
            qulonglong val = stripHex(s).toULongLong(ok, 16);
            if (*ok && val > 0xFFFFFFFFULL) *ok = false;
            return *ok ? toBytes<int32_t>(static_cast<int32_t>(val)) : QByteArray{};
        } else {
            int val = s.toInt(ok, 10);
            return *ok ? toBytes<int32_t>(val) : QByteArray{};
        }
    }
    case NodeKind::Int64: {
        bool isHex = s.startsWith("0x", Qt::CaseInsensitive);
        if (isHex) {
            qulonglong val = stripHex(s).toULongLong(ok, 16);
            return *ok ? toBytes<int64_t>(static_cast<int64_t>(val)) : QByteArray{};
        } else {
            qlonglong val = s.toLongLong(ok, 10);
            return *ok ? toBytes<int64_t>(val) : QByteArray{};
        }
    }
    case NodeKind::UInt8:   { int b = s.startsWith("0x",Qt::CaseInsensitive)?16:10; uint val = stripHex(s).toUInt(ok,b);              return parseIntChecked<uint8_t>(val, ok); }
    case NodeKind::UInt16:  { int b = s.startsWith("0x",Qt::CaseInsensitive)?16:10; uint val = stripHex(s).toUInt(ok,b);              return parseIntChecked<uint16_t>(val, ok); }
    case NodeKind::UInt32:  { int b = s.startsWith("0x",Qt::CaseInsensitive)?16:10; qulonglong val = stripHex(s).toULongLong(ok,b);  return parseIntChecked<uint32_t>(val, ok); }
    case NodeKind::UInt64:  { int b = s.startsWith("0x",Qt::CaseInsensitive)?16:10; qulonglong val = stripHex(s).toULongLong(ok,b);   return *ok ? toBytes<uint64_t>(val) : QByteArray{}; }
    case NodeKind::Float: {
        QString n = s.trimmed();
        if (n.endsWith('f', Qt::CaseInsensitive)) n.chop(1);
        n.replace(',', '.');
        float val = n.toFloat(ok);
        return *ok ? toBytes<float>(val) : QByteArray{};
    }
    case NodeKind::Double: {
        QString n = s.trimmed();
        n.replace(',', '.');
        double val = n.toDouble(ok);
        return *ok ? toBytes<double>(val) : QByteArray{};
    }
    case NodeKind::Bool: {
        if (s == QStringLiteral("true") || s == QStringLiteral("1")) {
            *ok = true; return toBytes<uint8_t>(1);
        }
        if (s == QStringLiteral("false") || s == QStringLiteral("0")) {
            *ok = true; return toBytes<uint8_t>(0);
        }
        return {};  // unknown token → ok stays false
    }
    case NodeKind::Pointer32: {
        uint val = stripHex(s).toUInt(ok, 16);
        return *ok ? toBytes<uint32_t>(val) : QByteArray{};
    }
    case NodeKind::Pointer64: {
        qulonglong val = stripHex(s).toULongLong(ok, 16);
        return *ok ? toBytes<uint64_t>(val) : QByteArray{};
    }
    case NodeKind::FuncPtr32: {
        uint val = stripHex(s).toUInt(ok, 16);
        return *ok ? toBytes<uint32_t>(val) : QByteArray{};
    }
    case NodeKind::FuncPtr64: {
        qulonglong val = stripHex(s).toULongLong(ok, 16);
        return *ok ? toBytes<uint64_t>(val) : QByteArray{};
    }
    case NodeKind::UTF8: {
        *ok = true;
        if (s.startsWith('"') && s.endsWith('"'))
            s = s.mid(1, s.size() - 2);
        return s.toUtf8();
    }
    case NodeKind::UTF16: {
        *ok = true;
        if (s.startsWith(QStringLiteral("L\""))) s = s.mid(2);
        else if (s.startsWith('"')) s = s.mid(1);
        if (s.endsWith('"')) s.chop(1);
        QByteArray b(s.size() * 2, Qt::Uninitialized);
        memcpy(b.data(), s.utf16(), s.size() * 2);
        return b;
    }
    default:
        return {};
    }
}

// ── Value validation (returns error message or empty string if valid) ──

QString validateValue(NodeKind kind, const QString& text) {
    QString s = text.trimmed();
    if (s.isEmpty()) return {};

    // For integer/hex types, validate character set first
    bool isHexKind = (kind >= NodeKind::Hex8 && kind <= NodeKind::Hex64)
                  || kind == NodeKind::Pointer32 || kind == NodeKind::Pointer64
                  || kind == NodeKind::FuncPtr32 || kind == NodeKind::FuncPtr64;
    bool isIntKind = (kind >= NodeKind::Int8 && kind <= NodeKind::UInt64);

    if (isHexKind || isIntKind) {
        bool hasHexPrefix = s.startsWith("0x", Qt::CaseInsensitive);
        QString digits = hasHexPrefix ? s.mid(2) : s;

        if (hasHexPrefix || isHexKind) {
            // Hex mode: only 0-9, a-f, A-F
            for (QChar c : digits) {
                if (!c.isDigit() && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
                    return QStringLiteral("invalid hex '%1'").arg(c);
            }
        } else {
            // Decimal mode: only digits (and leading minus for signed)
            int start = 0;
            bool isSigned = (kind >= NodeKind::Int8 && kind <= NodeKind::Int64);
            if (isSigned && !digits.isEmpty() && digits[0] == '-') start = 1;
            for (int i = start; i < digits.size(); i++) {
                if (!digits[i].isDigit())
                    return QStringLiteral("invalid '%1'").arg(digits[i]);
            }
        }
    }

    // Then do the actual parse for range checking
    bool ok;
    parseValue(kind, text, &ok);
    if (ok) return {};

    // Type-appropriate error messages
    bool isFloatKind = (kind == NodeKind::Float || kind == NodeKind::Double);
    if (isFloatKind)
        return QStringLiteral("invalid number");

    // Return byte-capacity max based on type size
    const auto* m = kindMeta(kind);
    if (m && m->size > 0 && m->size <= 8) {
        uint64_t maxVal = (m->size == 8) ? ~0ULL : ((1ULL << (m->size * 8)) - 1);
        return QStringLiteral("too large! max=0x%1").arg(maxVal, m->size * 2, 16, QChar('0'));
    }
    return QStringLiteral("invalid");
}

// ── Base address validation (delegates to AddressParser) ──

QString validateBaseAddress(const QString& text) {
    QString s = text.trimmed();
    if (s.isEmpty()) return QStringLiteral("empty");
    //s.remove('`');
    return AddressParser::validate(s);
}

QString fmtEnumMember(const QString& name, int64_t value, int depth, int nameW) {
    QString ind = indent(depth);
    return ind + name.leftJustified(nameW) + QStringLiteral(" = ") + QString::number(value);
}

} // namespace rcx::fmt

```

`src/generator.cpp`:

```cpp
#include "generator.h"
#include <QHash>
#include <QVector>
#include <QStringList>
#include <algorithm>

namespace rcx {

namespace {

// ── Identifier sanitisation ──

static QString sanitizeIdent(const QString& name) {
    if (name.isEmpty()) return QStringLiteral("unnamed");
    QString out;
    out.reserve(name.size());
    for (QChar c : name) {
        if (c.isLetterOrNumber() || c == '_') out += c;
        else out += '_';
    }
    if (!out[0].isLetter() && out[0] != '_')
        out.prepend('_');
    return out;
}

// ── C type name for a primitive NodeKind ──

static QString cTypeName(NodeKind kind) {
    switch (kind) {
    case NodeKind::Hex8:      return QStringLiteral("uint8_t");
    case NodeKind::Hex16:     return QStringLiteral("uint16_t");
    case NodeKind::Hex32:     return QStringLiteral("uint32_t");
    case NodeKind::Hex64:     return QStringLiteral("uint64_t");
    case NodeKind::Int8:      return QStringLiteral("int8_t");
    case NodeKind::Int16:     return QStringLiteral("int16_t");
    case NodeKind::Int32:     return QStringLiteral("int32_t");
    case NodeKind::Int64:     return QStringLiteral("int64_t");
    case NodeKind::UInt8:     return QStringLiteral("uint8_t");
    case NodeKind::UInt16:    return QStringLiteral("uint16_t");
    case NodeKind::UInt32:    return QStringLiteral("uint32_t");
    case NodeKind::UInt64:    return QStringLiteral("uint64_t");
    case NodeKind::Float:     return QStringLiteral("float");
    case NodeKind::Double:    return QStringLiteral("double");
    case NodeKind::Bool:      return QStringLiteral("bool");
    case NodeKind::Pointer32: return QStringLiteral("uint32_t");
    case NodeKind::Pointer64: return QStringLiteral("uint64_t");
    case NodeKind::FuncPtr32: return QStringLiteral("uint32_t");
    case NodeKind::FuncPtr64: return QStringLiteral("uint64_t");
    case NodeKind::Vec2:      return QStringLiteral("float");
    case NodeKind::Vec3:      return QStringLiteral("float");
    case NodeKind::Vec4:      return QStringLiteral("float");
    case NodeKind::Mat4x4:    return QStringLiteral("float");
    case NodeKind::UTF8:      return QStringLiteral("char");
    case NodeKind::UTF16:     return QStringLiteral("wchar_t");
    default:                  return QStringLiteral("uint8_t");
    }
}

// ── Generator context ──

struct GenContext {
    const NodeTree& tree;
    QHash<uint64_t, QVector<int>> childMap;
    QSet<QString>   emittedTypeNames;   // struct type names already emitted
    QSet<uint64_t>  emittedIds;         // struct node IDs already emitted
    QSet<uint64_t>  visiting;           // cycle guard
    QSet<uint64_t>  forwardDeclared;    // forward-declared type IDs
    QString         output;
    int             padCounter = 0;
    const QHash<NodeKind, QString>* typeAliases = nullptr;

    QString uniquePadName() {
        return QStringLiteral("_pad%1").arg(padCounter++, 4, 16, QChar('0'));
    }

    // Resolve the C type name for a primitive, consulting aliases first
    QString cType(NodeKind kind) const {
        if (typeAliases) {
            auto it = typeAliases->find(kind);
            if (it != typeAliases->end() && !it.value().isEmpty())
                return it.value();
        }
        return cTypeName(kind);
    }

    // Resolve the canonical type name for a struct/array node
    QString structName(const Node& n) const {
        if (!n.structTypeName.isEmpty()) return sanitizeIdent(n.structTypeName);
        if (!n.name.isEmpty())           return sanitizeIdent(n.name);
        return QStringLiteral("anon_%1").arg(n.id, 0, 16);
    }
};

// Forward declarations
static void emitStruct(GenContext& ctx, uint64_t structId);

// ── Field line with offset comment (code + marker + comment) ──
// We use a \x01 marker to separate the code part from the offset comment.
// After all output is generated, alignComments() replaces markers with padding.

static const QChar kCommentMarker = QChar(0x01);

static QString offsetComment(int offset) {
    return QString(kCommentMarker) + QStringLiteral("// 0x%1").arg(QString::number(offset, 16).toUpper());
}

static QString emitField(GenContext& ctx, const Node& node) {
    const NodeTree& tree = ctx.tree;
    QString name = sanitizeIdent(node.name.isEmpty()
        ? QStringLiteral("field_%1").arg(node.offset, 2, 16, QChar('0'))
        : node.name);
    QString oc = offsetComment(node.offset);

    switch (node.kind) {
    case NodeKind::Vec2:
        return QStringLiteral("    %1 %2[2];").arg(ctx.cType(NodeKind::Float), name) + oc;
    case NodeKind::Vec3:
        return QStringLiteral("    %1 %2[3];").arg(ctx.cType(NodeKind::Float), name) + oc;
    case NodeKind::Vec4:
        return QStringLiteral("    %1 %2[4];").arg(ctx.cType(NodeKind::Float), name) + oc;
    case NodeKind::Mat4x4:
        return QStringLiteral("    %1 %2[4][4];").arg(ctx.cType(NodeKind::Float), name) + oc;
    case NodeKind::UTF8:
        return QStringLiteral("    %1 %2[%3];").arg(ctx.cType(NodeKind::UTF8), name).arg(node.strLen) + oc;
    case NodeKind::UTF16:
        return QStringLiteral("    %1 %2[%3];").arg(ctx.cType(NodeKind::UTF16), name).arg(node.strLen) + oc;
    case NodeKind::Pointer32: {
        if (node.refId != 0) {
            int refIdx = tree.indexOfId(node.refId);
            if (refIdx >= 0) {
                QString target = ctx.structName(tree.nodes[refIdx]);
                return QStringLiteral("    %1 %2;").arg(ctx.cType(NodeKind::Pointer32), name) +
                    offsetComment(node.offset).replace(QStringLiteral("//"), QStringLiteral("// -> %1*").arg(target));
            }
        }
        return QStringLiteral("    %1 %2;").arg(ctx.cType(NodeKind::Pointer32), name) + oc;
    }
    case NodeKind::Pointer64: {
        if (node.refId != 0) {
            int refIdx = tree.indexOfId(node.refId);
            if (refIdx >= 0) {
                QString target = ctx.structName(tree.nodes[refIdx]);
                return QStringLiteral("    %1* %2;").arg(target, name) + oc;
            }
        }
        return QStringLiteral("    void* %1;").arg(name) + oc;
    }
    case NodeKind::FuncPtr32:
        return QStringLiteral("    void (*%1)();").arg(name) + oc;
    case NodeKind::FuncPtr64:
        return QStringLiteral("    void (*%1)();").arg(name) + oc;
    default:
        return QStringLiteral("    %1 %2;").arg(ctx.cType(node.kind), name) + oc;
    }
}

// ── Emit struct body (fields + padding) ──

static void emitStructBody(GenContext& ctx, uint64_t structId) {
    const NodeTree& tree = ctx.tree;
    int idx = tree.indexOfId(structId);
    if (idx < 0) return;

    int structSize = tree.structSpan(structId, &ctx.childMap);

    QVector<int> children = ctx.childMap.value(structId);
    std::sort(children.begin(), children.end(), [&](int a, int b) {
        return tree.nodes[a].offset < tree.nodes[b].offset;
    });

    // Helper: emit a padding/hex run as a single collapsed byte array
    auto emitPadRun = [&](int offset, int size) {
        if (size <= 0) return;
        ctx.output += QStringLiteral("    %1 %2[0x%3];%4\n")
            .arg(QStringLiteral("uint8_t"))
            .arg(ctx.uniquePadName())
            .arg(QString::number(size, 16).toUpper())
            .arg(offsetComment(offset));
    };

    int cursor = 0;
    int i = 0;

    while (i < children.size()) {
        const Node& child = tree.nodes[children[i]];
        int childSize;
        if (child.kind == NodeKind::Struct || child.kind == NodeKind::Array)
            childSize = tree.structSpan(child.id, &ctx.childMap);
        else
            childSize = child.byteSize();

        // Gap before this field
        if (child.offset > cursor)
            emitPadRun(cursor, child.offset - cursor);
        else if (child.offset < cursor)
            ctx.output += QStringLiteral("    // WARNING: overlap at offset 0x%1 (previous field ends at 0x%2)\n")
                .arg(QString::number(child.offset, 16).toUpper())
                .arg(QString::number(cursor, 16).toUpper());

        // Collapse consecutive hex nodes into a single padding array
        if (isHexNode(child.kind)) {
            int runStart = child.offset;
            int runEnd = child.offset + childSize;
            int j = i + 1;
            while (j < children.size()) {
                const Node& next = tree.nodes[children[j]];
                if (!isHexNode(next.kind)) break;
                int nextSize = next.byteSize();
                // Allow gaps within the run (they become part of the pad)
                if (next.offset < runEnd) break;  // overlap — stop merging
                runEnd = next.offset + nextSize;
                j++;
            }
            emitPadRun(runStart, runEnd - runStart);
            cursor = runEnd;
            i = j;
            continue;
        }

        // Emit the field
        if (child.kind == NodeKind::Struct) {
            emitStruct(ctx, child.id);
            QString typeName = ctx.structName(child);
            QString fieldName = sanitizeIdent(child.name);
            ctx.output += QStringLiteral("    %1 %2;%3\n").arg(typeName, fieldName, offsetComment(child.offset));
        } else if (child.kind == NodeKind::Array) {
            QVector<int> arrayKids = ctx.childMap.value(child.id);
            bool hasStructChild = false;
            QString elemTypeName;

            for (int ak : arrayKids) {
                if (tree.nodes[ak].kind == NodeKind::Struct) {
                    hasStructChild = true;
                    emitStruct(ctx, tree.nodes[ak].id);
                    elemTypeName = ctx.structName(tree.nodes[ak]);
                    break;
                }
            }

            QString fieldName = sanitizeIdent(child.name);
            if (hasStructChild && !elemTypeName.isEmpty()) {
                ctx.output += QStringLiteral("    %1 %2[%3];%4\n")
                    .arg(elemTypeName, fieldName).arg(child.arrayLen).arg(offsetComment(child.offset));
            } else {
                ctx.output += QStringLiteral("    %1 %2[%3];%4\n")
                    .arg(ctx.cType(child.elementKind), fieldName).arg(child.arrayLen).arg(offsetComment(child.offset));
            }
        } else {
            ctx.output += emitField(ctx, child) + QStringLiteral("\n");
        }

        int childEnd = child.offset + childSize;
        if (childEnd > cursor) cursor = childEnd;
        i++;
    }

    // Tail padding
    if (cursor < structSize)
        emitPadRun(cursor, structSize - cursor);
}

// ── Emit a complete struct definition ──

static void emitStruct(GenContext& ctx, uint64_t structId) {
    if (ctx.emittedIds.contains(structId)) return;
    if (ctx.visiting.contains(structId)) return; // cycle
    ctx.visiting.insert(structId);

    int idx = ctx.tree.indexOfId(structId);
    if (idx < 0) { ctx.visiting.remove(structId); return; }

    const Node& node = ctx.tree.nodes[idx];
    if (node.kind != NodeKind::Struct && node.kind != NodeKind::Array) {
        ctx.visiting.remove(structId);
        return;
    }

    // For arrays, we don't emit a top-level struct — the array itself
    // is a field inside its parent.  But we do emit struct element types.
    if (node.kind == NodeKind::Array) {
        QVector<int> kids = ctx.childMap.value(structId);
        for (int ki : kids) {
            if (ctx.tree.nodes[ki].kind == NodeKind::Struct)
                emitStruct(ctx, ctx.tree.nodes[ki].id);
        }
        ctx.visiting.remove(structId);
        return;
    }

    // Deduplicate by struct type name (different nodes may share the same type)
    QString typeName = ctx.structName(node);
    if (ctx.emittedTypeNames.contains(typeName)) {
        ctx.emittedIds.insert(structId);
        ctx.visiting.remove(structId);
        return;
    }

    // Emit nested struct types first (dependency order)
    QVector<int> children = ctx.childMap.value(structId);
    for (int ci : children) {
        const Node& child = ctx.tree.nodes[ci];
        if (child.kind == NodeKind::Struct)
            emitStruct(ctx, child.id);
        else if (child.kind == NodeKind::Array) {
            QVector<int> arrayKids = ctx.childMap.value(child.id);
            for (int ak : arrayKids) {
                if (ctx.tree.nodes[ak].kind == NodeKind::Struct)
                    emitStruct(ctx, ctx.tree.nodes[ak].id);
            }
        }
        // Forward-declare pointer target types if they're outside this subtree
        if (child.kind == NodeKind::Pointer64 && child.refId != 0) {
            int refIdx = ctx.tree.indexOfId(child.refId);
            if (refIdx >= 0 && !ctx.emittedIds.contains(child.refId)
                && !ctx.forwardDeclared.contains(child.refId)) {
                QString fwdName = ctx.structName(ctx.tree.nodes[refIdx]);
                QString fwdKw = ctx.tree.nodes[refIdx].resolvedClassKeyword();
                if (fwdKw == QStringLiteral("enum") && ctx.tree.nodes[refIdx].enumMembers.isEmpty())
                    fwdKw = QStringLiteral("struct");
                ctx.output += QStringLiteral("%1 %2;\n").arg(fwdKw, fwdName);
                ctx.forwardDeclared.insert(child.refId);
            }
        }
    }

    ctx.emittedIds.insert(structId);
    ctx.emittedTypeNames.insert(typeName);
    int structSize = ctx.tree.structSpan(structId, &ctx.childMap);

    QString kw = node.resolvedClassKeyword();

    // Enum with members: emit as proper C enum
    if (kw == QStringLiteral("enum") && !node.enumMembers.isEmpty()) {
        ctx.output += QStringLiteral("enum %1 {\n").arg(typeName);
        for (const auto& m : node.enumMembers) {
            ctx.output += QStringLiteral("    %1 = %2,\n")
                .arg(sanitizeIdent(m.first))
                .arg(m.second);
        }
        ctx.output += QStringLiteral("};\n\n");
        ctx.visiting.remove(structId);
        return;
    }

    if (kw == QStringLiteral("enum")) kw = QStringLiteral("struct");  // enum without members: fallback
    ctx.output += QStringLiteral("%1 %2 {\n").arg(kw, typeName);

    emitStructBody(ctx, structId);

    ctx.output += QStringLiteral("};\n");
    ctx.output += QStringLiteral("static_assert(sizeof(%1) == 0x%2, \"Size mismatch for %1\");\n\n")
        .arg(typeName)
        .arg(QString::number(structSize, 16).toUpper());

    ctx.visiting.remove(structId);
}

// ── Build the child map used by all generators ──

static QHash<uint64_t, QVector<int>> buildChildMap(const NodeTree& tree) {
    QHash<uint64_t, QVector<int>> map;
    for (int i = 0; i < tree.nodes.size(); i++)
        map[tree.nodes[i].parentId].append(i);
    return map;
}

// ── Align offset comments ──
// Replaces kCommentMarker with spaces so all "// 0x..." comments align to
// the same column (the longest code portion + 1 space).

static QString alignComments(const QString& raw) {
    QStringList lines = raw.split('\n');

    // First pass: find the maximum code width (text before the marker)
    int maxCode = 0;
    for (const QString& line : lines) {
        int pos = line.indexOf(kCommentMarker);
        if (pos >= 0)
            maxCode = qMax(maxCode, pos);
    }

    // Second pass: replace markers with padding
    QString result;
    result.reserve(raw.size() + lines.size() * 8);
    for (int i = 0; i < lines.size(); i++) {
        if (i > 0) result += '\n';
        const QString& line = lines[i];
        int pos = line.indexOf(kCommentMarker);
        if (pos >= 0) {
            result += line.left(pos);
            int pad = maxCode - pos + 1;
            if (pad < 1) pad = 1;
            result += QString(pad, ' ');
            result += line.mid(pos + 1);  // skip the marker char
        } else {
            result += line;
        }
    }
    return result;
}

} // anonymous namespace

// ── Public API ──

QString renderCpp(const NodeTree& tree, uint64_t rootStructId,
                  const QHash<NodeKind, QString>* typeAliases) {
    int idx = tree.indexOfId(rootStructId);
    if (idx < 0) return {};

    const Node& root = tree.nodes[idx];
    if (root.kind != NodeKind::Struct) return {};

    GenContext ctx{tree, buildChildMap(tree), {}, {}, {}, {}, {}, 0, typeAliases};

    ctx.output += QStringLiteral("#pragma once\n\n");

    emitStruct(ctx, rootStructId);

    return alignComments(ctx.output);
}

QString renderCppAll(const NodeTree& tree,
                     const QHash<NodeKind, QString>* typeAliases) {
    GenContext ctx{tree, buildChildMap(tree), {}, {}, {}, {}, {}, 0, typeAliases};

    ctx.output += QStringLiteral("#pragma once\n\n");

    QVector<int> roots = ctx.childMap.value(0);
    std::sort(roots.begin(), roots.end(), [&](int a, int b) {
        return tree.nodes[a].offset < tree.nodes[b].offset;
    });

    for (int ri : roots) {
        if (tree.nodes[ri].kind == NodeKind::Struct)
            emitStruct(ctx, tree.nodes[ri].id);
    }

    return alignComments(ctx.output);
}

QString renderNull(const NodeTree&, uint64_t) {
    return {};
}

} // namespace rcx

```

`src/generator.h`:

```h
#pragma once
#include "core.h"
#include <QString>
#include <QHash>
#include <QSet>

namespace rcx {

// Generate C++ struct definitions for a single root struct and all
// nested/referenced types reachable from it.
QString renderCpp(const NodeTree& tree, uint64_t rootStructId,
                  const QHash<NodeKind, QString>* typeAliases = nullptr);

// Generate C++ struct definitions for every root-level struct (full SDK).
QString renderCppAll(const NodeTree& tree,
                     const QHash<NodeKind, QString>* typeAliases = nullptr);

// Null generator placeholder (returns empty string).
QString renderNull(const NodeTree& tree, uint64_t rootStructId);

} // namespace rcx

```

`src/imports/export_reclass_xml.cpp`:

```cpp
#include "export_reclass_xml.h"
#include <QFile>
#include <QXmlStreamWriter>
#include <QHash>
#include <QVector>
#include <algorithm>

namespace rcx {

// Reverse type map: NodeKind -> ReClassEx V2016 XML Type integer
static int xmlTypeForKind(NodeKind kind) {
    switch (kind) {
    case NodeKind::Struct:    return 1;   // ClassInstance
    case NodeKind::Hex32:     return 4;
    case NodeKind::Hex64:     return 5;
    case NodeKind::Hex16:     return 6;
    case NodeKind::Hex8:      return 7;
    case NodeKind::Pointer64: return 8;   // ClassPointer
    case NodeKind::Pointer32: return 8;
    case NodeKind::Int64:     return 9;
    case NodeKind::Int32:     return 10;
    case NodeKind::Int16:     return 11;
    case NodeKind::Int8:      return 12;
    case NodeKind::Float:     return 13;
    case NodeKind::Double:    return 14;
    case NodeKind::UInt32:    return 15;
    case NodeKind::UInt16:    return 16;
    case NodeKind::UInt8:     return 17;
    case NodeKind::UInt64:    return 32;
    case NodeKind::UTF8:      return 18;
    case NodeKind::UTF16:     return 19;
    case NodeKind::Bool:      return 17;  // No native bool in ReClass, map to UInt8
    case NodeKind::Vec2:      return 22;
    case NodeKind::Vec3:      return 23;
    case NodeKind::Vec4:      return 24;
    case NodeKind::Mat4x4:    return 25;
    case NodeKind::Array:     return 27;  // ClassInstanceArray
    }
    return 7; // fallback to Hex8
}

static int nodeSizeForExport(const Node& node) {
    switch (node.kind) {
    case NodeKind::UTF8:  return node.strLen;
    case NodeKind::UTF16: return node.strLen * 2;
    case NodeKind::Array: {
        int elemSz = sizeForKind(node.elementKind);
        return node.arrayLen * (elemSz > 0 ? elemSz : 0);
    }
    default: return sizeForKind(node.kind);
    }
}

// Resolve a struct type name from a node ID
static QString resolveStructName(const NodeTree& tree, uint64_t refId) {
    int idx = tree.indexOfId(refId);
    if (idx < 0) return {};
    const Node& ref = tree.nodes[idx];
    if (!ref.structTypeName.isEmpty()) return ref.structTypeName;
    return ref.name;
}

bool exportReclassXml(const NodeTree& tree, const QString& filePath, QString* errorMsg) {
    if (tree.nodes.isEmpty()) {
        if (errorMsg) *errorMsg = QStringLiteral("No nodes to export");
        return false;
    }

    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        if (errorMsg) *errorMsg = QStringLiteral("Cannot open file for writing: ") + filePath;
        return false;
    }

    // Build child map
    QHash<uint64_t, QVector<int>> childMap;
    for (int i = 0; i < tree.nodes.size(); i++)
        childMap[tree.nodes[i].parentId].append(i);

    QXmlStreamWriter xml(&file);
    xml.setAutoFormatting(true);
    xml.setAutoFormattingIndent(4);
    xml.writeStartDocument();

    xml.writeStartElement(QStringLiteral("ReClass"));
    xml.writeComment(QStringLiteral("ReClassEx"));

    // Get root structs
    QVector<int> roots = childMap.value(0);
    std::sort(roots.begin(), roots.end(), [&](int a, int b) {
        return tree.nodes[a].offset < tree.nodes[b].offset;
    });

    int classCount = 0;

    for (int ri : roots) {
        const Node& root = tree.nodes[ri];
        if (root.kind != NodeKind::Struct) continue;

        xml.writeStartElement(QStringLiteral("Class"));
        xml.writeAttribute(QStringLiteral("Name"), root.name.isEmpty() ? root.structTypeName : root.name);
        xml.writeAttribute(QStringLiteral("Type"), QStringLiteral("28"));
        xml.writeAttribute(QStringLiteral("Comment"), QString());
        xml.writeAttribute(QStringLiteral("Offset"), QStringLiteral("0"));
        xml.writeAttribute(QStringLiteral("strOffset"), QStringLiteral("0"));
        xml.writeAttribute(QStringLiteral("Code"), QString());

        // Get children sorted by offset
        QVector<int> children = childMap.value(root.id);
        std::sort(children.begin(), children.end(), [&](int a, int b) {
            return tree.nodes[a].offset < tree.nodes[b].offset;
        });

        int i = 0;
        while (i < children.size()) {
            const Node& child = tree.nodes[children[i]];

            // Collapse consecutive hex nodes into a single Custom node (Type=21)
            if (isHexNode(child.kind)) {
                int runStart = child.offset;
                int runEnd = child.offset + child.byteSize();
                int j = i + 1;
                while (j < children.size()) {
                    const Node& next = tree.nodes[children[j]];
                    if (!isHexNode(next.kind)) break;
                    if (next.offset < runEnd) break; // overlap
                    runEnd = next.offset + next.byteSize();
                    j++;
                }
                int totalSize = runEnd - runStart;
                xml.writeStartElement(QStringLiteral("Node"));
                // Use first hex node's name if it's a single node, otherwise generate
                QString hexName = (j - i == 1 && !child.name.isEmpty()) ? child.name : QString();
                xml.writeAttribute(QStringLiteral("Name"), hexName);
                xml.writeAttribute(QStringLiteral("Type"), QStringLiteral("21")); // Custom
                xml.writeAttribute(QStringLiteral("Size"), QString::number(totalSize));
                xml.writeAttribute(QStringLiteral("bHidden"), QStringLiteral("false"));
                xml.writeAttribute(QStringLiteral("Comment"), QString());
                xml.writeEndElement(); // Node
                i = j;
                continue;
            }

            xml.writeStartElement(QStringLiteral("Node"));
            xml.writeAttribute(QStringLiteral("Name"), child.name);
            xml.writeAttribute(QStringLiteral("Type"), QString::number(xmlTypeForKind(child.kind)));
            xml.writeAttribute(QStringLiteral("Size"), QString::number(nodeSizeForExport(child)));
            xml.writeAttribute(QStringLiteral("bHidden"), QStringLiteral("false"));
            xml.writeAttribute(QStringLiteral("Comment"), QString());

            // Pointer with target
            if ((child.kind == NodeKind::Pointer64 || child.kind == NodeKind::Pointer32) && child.refId != 0) {
                QString target = resolveStructName(tree, child.refId);
                if (!target.isEmpty())
                    xml.writeAttribute(QStringLiteral("Pointer"), target);
            }

            // Embedded struct instance
            if (child.kind == NodeKind::Struct) {
                QString instName = child.structTypeName.isEmpty() ? child.name : child.structTypeName;
                xml.writeAttribute(QStringLiteral("Instance"), instName);
            }

            // Array: Total attribute and child <Array> element
            if (child.kind == NodeKind::Array) {
                xml.writeAttribute(QStringLiteral("Total"), QString::number(child.arrayLen));

                // Resolve element type name
                QString elemName;
                if (child.elementKind == NodeKind::Struct && !child.structTypeName.isEmpty()) {
                    elemName = child.structTypeName;
                } else if (child.refId != 0) {
                    elemName = resolveStructName(tree, child.refId);
                }
                if (elemName.isEmpty())
                    elemName = kindToString(child.elementKind);

                xml.writeStartElement(QStringLiteral("Array"));
                xml.writeAttribute(QStringLiteral("Name"), elemName);
                xml.writeAttribute(QStringLiteral("Total"), QString::number(child.arrayLen));
                xml.writeEndElement(); // Array
            }

            xml.writeEndElement(); // Node
            i++;
        }

        xml.writeEndElement(); // Class
        classCount++;
    }

    xml.writeEndElement(); // ReClass
    xml.writeEndDocument();
    file.close();

    if (classCount == 0) {
        if (errorMsg) *errorMsg = QStringLiteral("No struct classes found to export");
        return false;
    }

    return true;
}

} // namespace rcx

```

`src/imports/export_reclass_xml.h`:

```h
#pragma once
#include "core.h"

namespace rcx {

// Export a NodeTree to ReClass .NET / ReClassEx compatible XML format.
// Returns true on success; populates errorMsg on failure if non-null.
bool exportReclassXml(const NodeTree& tree, const QString& filePath, QString* errorMsg = nullptr);

} // namespace rcx

```

`src/imports/import_pdb.cpp`:

```cpp
#include "import_pdb.h"

#ifdef _WIN32

#include <windows.h>
#include <QFile>
#include <QHash>
#include <QPair>
#include <QSet>

// ── RawPDB headers ──
#include "PDB.h"
#include "PDB_RawFile.h"
#include "PDB_TPIStream.h"
#include "PDB_TPITypes.h"
#include "PDB_DBIStream.h"
#include "PDB_InfoStream.h"
#include "PDB_CoalescedMSFStream.h"
#include "Foundation/PDB_Memory.h"

namespace rcx {

// ── Memory-mapped file (mirrors ExampleMemoryMappedFile) ──

struct MappedFile {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMapping = nullptr;
    const void* base = nullptr;
    size_t size = 0;

    bool open(const QString& path) {
        hFile = CreateFileW(reinterpret_cast<const wchar_t*>(path.utf16()),
                            GENERIC_READ, FILE_SHARE_READ, nullptr,
                            OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, nullptr);
        if (hFile == INVALID_HANDLE_VALUE) return false;

        hMapping = CreateFileMappingW(hFile, nullptr, PAGE_READONLY, 0, 0, nullptr);
        if (!hMapping) { close(); return false; }

        base = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
        if (!base) { close(); return false; }

        BY_HANDLE_FILE_INFORMATION info;
        if (!GetFileInformationByHandle(hFile, &info)) { close(); return false; }
        size = (static_cast<size_t>(info.nFileSizeHigh) << 32) | info.nFileSizeLow;
        return true;
    }

    void close() {
        if (base) { UnmapViewOfFile(base); base = nullptr; }
        if (hMapping) { CloseHandle(hMapping); hMapping = nullptr; }
        if (hFile != INVALID_HANDLE_VALUE) { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; }
        size = 0;
    }

    ~MappedFile() { close(); }
    MappedFile() = default;
    MappedFile(const MappedFile&) = delete;
    MappedFile& operator=(const MappedFile&) = delete;
};

// ── TypeTable (mirrors ExampleTypeTable) ──
// Builds an O(1) lookup table from type index → record pointer.

class TypeTable {
public:
    explicit TypeTable(const PDB::TPIStream& tpiStream) {
        m_firstIndex = tpiStream.GetFirstTypeIndex();
        m_lastIndex = tpiStream.GetLastTypeIndex();
        m_count = tpiStream.GetTypeRecordCount();

        const PDB::DirectMSFStream& ds = tpiStream.GetDirectMSFStream();
        m_stream = PDB::CoalescedMSFStream(ds, ds.GetSize(), 0u);

        m_records = PDB_NEW_ARRAY(const PDB::CodeView::TPI::Record*, m_count);
        uint32_t idx = 0;
        tpiStream.ForEachTypeRecordHeaderAndOffset(
            [this, &idx](const PDB::CodeView::TPI::RecordHeader&, size_t offset) {
                m_records[idx++] = m_stream.GetDataAtOffset<const PDB::CodeView::TPI::Record>(offset);
            });
    }

    ~TypeTable() { PDB_DELETE_ARRAY(m_records); }

    uint32_t firstIndex() const { return m_firstIndex; }
    uint32_t lastIndex()  const { return m_lastIndex; }
    size_t   count()      const { return m_count; }

    const PDB::CodeView::TPI::Record* get(uint32_t typeIndex) const {
        if (typeIndex < m_firstIndex || typeIndex >= m_lastIndex) return nullptr;
        return m_records[typeIndex - m_firstIndex];
    }

private:
    uint32_t m_firstIndex = 0;
    uint32_t m_lastIndex = 0;
    size_t   m_count = 0;
    const PDB::CodeView::TPI::Record** m_records = nullptr;
    PDB::CoalescedMSFStream m_stream;

    TypeTable(const TypeTable&) = delete;
    TypeTable& operator=(const TypeTable&) = delete;
};

// ── Leaf numeric helpers (variable-length integer encoding) ──

using TRK = PDB::CodeView::TPI::TypeRecordKind;

static uint8_t leafSize(TRK kind) {
    if (kind < TRK::LF_NUMERIC) return sizeof(TRK); // value is the kind itself
    switch (kind) {
    case TRK::LF_CHAR:   return sizeof(TRK) + sizeof(uint8_t);
    case TRK::LF_SHORT:
    case TRK::LF_USHORT: return sizeof(TRK) + sizeof(uint16_t);
    case TRK::LF_LONG:
    case TRK::LF_ULONG:  return sizeof(TRK) + sizeof(uint32_t);
    case TRK::LF_QUADWORD:
    case TRK::LF_UQUADWORD: return sizeof(TRK) + sizeof(uint64_t);
    default: return sizeof(TRK);
    }
}

static const char* leafName(const char* data, TRK kind) {
    return data + leafSize(kind);
}

static uint64_t leafValue(const char* data, TRK kind) {
    if (kind < TRK::LF_NUMERIC) {
        return static_cast<uint16_t>(kind);
    }
    const char* p = data + sizeof(TRK);
    switch (kind) {
    case TRK::LF_CHAR:      return *reinterpret_cast<const uint8_t*>(p);
    case TRK::LF_SHORT:     return *reinterpret_cast<const int16_t*>(p);
    case TRK::LF_USHORT:    return *reinterpret_cast<const uint16_t*>(p);
    case TRK::LF_LONG:      return *reinterpret_cast<const int32_t*>(p);
    case TRK::LF_ULONG:     return *reinterpret_cast<const uint32_t*>(p);
    case TRK::LF_QUADWORD:  return *reinterpret_cast<const int64_t*>(p);
    case TRK::LF_UQUADWORD: return *reinterpret_cast<const uint64_t*>(p);
    default: return 0;
    }
}

// ── Primitive type index mapping (< 0x1000) ──

static NodeKind mapPrimitiveType(uint32_t typeIndex) {
    uint32_t base = typeIndex & 0xFF;
    switch (base) {
    // void
    case 0x03: return NodeKind::Hex8;
    // signed char
    case 0x10: return NodeKind::Int8;
    // unsigned char
    case 0x20: return NodeKind::UInt8;
    // real char
    case 0x70: return NodeKind::Int8;
    // wchar
    case 0x71: return NodeKind::UInt16;
    // char8
    case 0x7c: return NodeKind::UInt8;
    // char16
    case 0x7a: return NodeKind::UInt16;
    // char32
    case 0x7b: return NodeKind::UInt32;
    // short
    case 0x11: return NodeKind::Int16;
    // ushort
    case 0x21: return NodeKind::UInt16;
    // long
    case 0x12: return NodeKind::Int32;
    // ulong
    case 0x22: return NodeKind::UInt32;
    // int8
    case 0x68: return NodeKind::Int8;
    // uint8
    case 0x69: return NodeKind::UInt8;
    // int16
    case 0x72: return NodeKind::Int16;
    // uint16
    case 0x73: return NodeKind::UInt16;
    // int32
    case 0x74: return NodeKind::Int32;
    // uint32
    case 0x75: return NodeKind::UInt32;
    // quad (int64)
    case 0x13: return NodeKind::Int64;
    // uquad (uint64)
    case 0x23: return NodeKind::UInt64;
    // int64
    case 0x76: return NodeKind::Int64;
    // uint64
    case 0x77: return NodeKind::UInt64;
    // float
    case 0x40: return NodeKind::Float;
    // double
    case 0x41: return NodeKind::Double;
    // bool
    case 0x30: return NodeKind::Bool;
    case 0x31: return NodeKind::UInt16; // bool16
    case 0x32: return NodeKind::UInt32; // bool32
    case 0x33: return NodeKind::UInt64; // bool64
    // HRESULT
    case 0x08: return NodeKind::UInt32;
    // bit
    case 0x60: return NodeKind::UInt8;
    // int128 / uint128 approximation
    case 0x78: return NodeKind::Hex64; // int128 → Hex64 (best we can do)
    case 0x79: return NodeKind::Hex64; // uint128
    default:   return NodeKind::Hex32;
    }
}

static NodeKind hexForSize(uint64_t len) {
    switch (len) {
    case 1: return NodeKind::Hex8;
    case 2: return NodeKind::Hex16;
    case 4: return NodeKind::Hex32;
    case 8: return NodeKind::Hex64;
    default: return NodeKind::Hex32;
    }
}

// ── Helper: read the leaf kind from the start of LF_UNION.data ──
// (LF_UNION lacks the lfEasy member that LF_CLASS has)
static TRK unionLeafKind(const char* data) {
    return *reinterpret_cast<const TRK*>(data);
}

// ── Import context ──

struct PdbCtx {
    NodeTree tree;
    const TypeTable* tt = nullptr;
    QHash<uint32_t, uint64_t> typeCache; // typeIndex → nodeId
    QHash<QString, uint32_t> structDefByName; // struct/class definition name → typeIndex
    QHash<QString, uint32_t> unionDefByName;  // union definition name → typeIndex
    bool udtDefIndexBuilt = false;

    uint64_t importUDT(uint32_t typeIndex);
    uint64_t importEnum(uint32_t typeIndex);
    void importFieldList(uint32_t fieldListIndex, uint64_t parentId);
    void importMemberType(uint32_t typeIndex, int offset, const QString& name, uint64_t parentId);
    void buildUdtDefinitionIndex();
    uint32_t findUdtDefinitionIndex(TRK kind, const char* typeName);

    // Resolve LF_MODIFIER chain to underlying type index
    uint32_t unwrapModifier(uint32_t typeIndex) const {
        if (typeIndex < tt->firstIndex()) return typeIndex;
        const auto* rec = tt->get(typeIndex);
        if (!rec) return typeIndex;
        if (rec->header.kind == TRK::LF_MODIFIER)
            return rec->data.LF_MODIFIER.type;
        return typeIndex;
    }
};

void PdbCtx::buildUdtDefinitionIndex() {
    if (udtDefIndexBuilt || !tt) return;
    udtDefIndexBuilt = true;

    for (uint32_t ti = tt->firstIndex(); ti < tt->lastIndex(); ti++) {
        const auto* rec = tt->get(ti);
        if (!rec) continue;

        bool isUnion = false;
        bool isFwd = false;
        const char* candidateName = nullptr;

        if (rec->header.kind == TRK::LF_UNION) {
            isUnion = true;
            isFwd = rec->data.LF_UNION.property.fwdref;
            candidateName = leafName(rec->data.LF_UNION.data, unionLeafKind(rec->data.LF_UNION.data));
        } else if (rec->header.kind == TRK::LF_STRUCTURE || rec->header.kind == TRK::LF_CLASS) {
            isFwd = rec->data.LF_CLASS.property.fwdref;
            candidateName = leafName(rec->data.LF_CLASS.data, rec->data.LF_CLASS.lfEasy.kind);
        } else {
            continue;
        }

        if (isFwd || !candidateName || candidateName[0] == '\0') continue;

        QString qname = QString::fromUtf8(candidateName);
        QHash<QString, uint32_t>& lookup = isUnion ? unionDefByName : structDefByName;
        if (!lookup.contains(qname)) lookup.insert(qname, ti);
    }
}

uint32_t PdbCtx::findUdtDefinitionIndex(TRK kind, const char* typeName) {
    if (!typeName || typeName[0] == '\0') return 0;

    buildUdtDefinitionIndex();

    const QString qname = QString::fromUtf8(typeName);
    if (kind == TRK::LF_UNION) {
        auto it = unionDefByName.constFind(qname);
        return (it != unionDefByName.cend()) ? it.value() : 0;
    }

    if (kind == TRK::LF_STRUCTURE || kind == TRK::LF_CLASS) {
        auto it = structDefByName.constFind(qname);
        return (it != structDefByName.cend()) ? it.value() : 0;
    }

    return 0;
}

uint64_t PdbCtx::importUDT(uint32_t typeIndex) {
    if (typeIndex < tt->firstIndex()) return 0;

    auto it = typeCache.find(typeIndex);
    if (it != typeCache.end()) return it.value();

    const auto* rec = tt->get(typeIndex);
    if (!rec) return 0;

    const char* name = nullptr;
    uint32_t fieldListIndex = 0;
    uint16_t fieldCount = 0;
    bool isUnion = false;
    const char* sizeData = nullptr;

    if (rec->header.kind == TRK::LF_STRUCTURE || rec->header.kind == TRK::LF_CLASS) {
        // Skip forward references — find the definition
        if (rec->data.LF_CLASS.property.fwdref) return 0;
        fieldCount = rec->data.LF_CLASS.count;
        fieldListIndex = rec->data.LF_CLASS.field;
        sizeData = rec->data.LF_CLASS.data;
        name = leafName(sizeData, rec->data.LF_CLASS.lfEasy.kind);
    } else if (rec->header.kind == TRK::LF_UNION) {
        if (rec->data.LF_UNION.property.fwdref) return 0;
        isUnion = true;
        fieldCount = rec->data.LF_UNION.count;
        fieldListIndex = rec->data.LF_UNION.field;
        sizeData = rec->data.LF_UNION.data;
        name = leafName(sizeData, unionLeafKind(sizeData));
    } else {
        return 0;
    }
    (void)fieldCount;

    QString qname = name ? QString::fromUtf8(name) : QStringLiteral("<anon>");

    Node s;
    s.kind = NodeKind::Struct;
    s.name = qname;
    s.structTypeName = qname;
    s.classKeyword = isUnion ? QStringLiteral("union") : QStringLiteral("struct");
    s.parentId = 0;
    s.collapsed = true;
    int idx = tree.addNode(s);
    uint64_t nodeId = tree.nodes[idx].id;

    typeCache[typeIndex] = nodeId;

    importFieldList(fieldListIndex, nodeId);
    return nodeId;
}

uint64_t PdbCtx::importEnum(uint32_t typeIndex) {
    if (typeIndex < tt->firstIndex()) return 0;

    auto it = typeCache.find(typeIndex);
    if (it != typeCache.end()) return it.value();

    const auto* rec = tt->get(typeIndex);
    if (!rec || rec->header.kind != TRK::LF_ENUM) return 0;
    if (rec->data.LF_ENUM.property.fwdref) return 0;

    QString qname = rec->data.LF_ENUM.name
        ? QString::fromUtf8(rec->data.LF_ENUM.name)
        : QStringLiteral("<anon>");

    Node s;
    s.kind = NodeKind::Struct;
    s.name = qname;
    s.structTypeName = qname;
    s.classKeyword = QStringLiteral("enum");
    s.parentId = 0;
    s.collapsed = true;

    // Extract enum members from field list
    uint32_t fieldListIndex = rec->data.LF_ENUM.field;
    const auto* flRec = tt->get(fieldListIndex);
    if (flRec && flRec->header.kind == TRK::LF_FIELDLIST) {
        auto maxSize = flRec->header.size - sizeof(uint16_t);
        for (size_t i = 0; i < maxSize; ) {
            auto* field = reinterpret_cast<const PDB::CodeView::TPI::FieldList*>(
                reinterpret_cast<const uint8_t*>(&flRec->data.LF_FIELD.list) + i);
            if (field->kind != TRK::LF_ENUMERATE) break;

            int64_t val = static_cast<int64_t>(leafValue(
                field->data.LF_ENUMERATE.value,
                field->data.LF_ENUMERATE.lfEasy.kind));
            const char* eName = leafName(
                field->data.LF_ENUMERATE.value,
                field->data.LF_ENUMERATE.lfEasy.kind);
            if (eName)
                s.enumMembers.append({QString::fromUtf8(eName), val});

            i += static_cast<size_t>(eName - reinterpret_cast<const char*>(field));
            i += strnlen(eName, maxSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3);
        }
    }

    int idx = tree.addNode(s);
    uint64_t nodeId = tree.nodes[idx].id;
    typeCache[typeIndex] = nodeId;
    return nodeId;
}

void PdbCtx::importFieldList(uint32_t fieldListIndex, uint64_t parentId) {
    const auto* rec = tt->get(fieldListIndex);
    if (!rec || rec->header.kind != TRK::LF_FIELDLIST) return;

    auto maximumSize = rec->header.size - sizeof(uint16_t);
    QSet<QPair<int,int>> bitfieldSlots;

    for (size_t i = 0; i < maximumSize; ) {
        auto* field = reinterpret_cast<const PDB::CodeView::TPI::FieldList*>(
            reinterpret_cast<const uint8_t*>(&rec->data.LF_FIELD.list) + i);

        if (field->kind == TRK::LF_MEMBER) {
            // Extract offset from variable-length leaf
            uint16_t offset = 0;
            if (field->data.LF_MEMBER.lfEasy.kind < TRK::LF_NUMERIC)
                offset = *reinterpret_cast<const uint16_t*>(field->data.LF_MEMBER.offset);
            else
                offset = static_cast<uint16_t>(leafValue(field->data.LF_MEMBER.offset,
                    field->data.LF_MEMBER.lfEasy.kind));

            const char* memberName = leafName(field->data.LF_MEMBER.offset,
                                               field->data.LF_MEMBER.lfEasy.kind);
            uint32_t memberType = field->data.LF_MEMBER.index;
            QString qname = memberName ? QString::fromUtf8(memberName) : QString();

            // Check for bitfield type
            uint32_t resolvedType = unwrapModifier(memberType);
            const auto* typeRec = tt->get(resolvedType);
            if (typeRec && typeRec->header.kind == TRK::LF_BITFIELD) {
                uint32_t underlying = typeRec->data.LF_BITFIELD.type;
                uint8_t bitLen = typeRec->data.LF_BITFIELD.length;
                (void)bitLen;

                // Determine slot size from underlying type
                uint64_t slotSize = 4;
                if (underlying < tt->firstIndex()) {
                    NodeKind k = mapPrimitiveType(underlying);
                    slotSize = sizeForKind(k);
                }

                auto key = qMakePair((int)offset, (int)slotSize);
                if (!bitfieldSlots.contains(key)) {
                    bitfieldSlots.insert(key);
                    Node n;
                    n.kind = hexForSize(slotSize);
                    n.name = qname;
                    n.parentId = parentId;
                    n.offset = offset;
                    tree.addNode(n);
                }
            } else {
                importMemberType(memberType, offset, qname, parentId);
            }

            // Advance past this LF_MEMBER
            i += static_cast<size_t>(memberName - reinterpret_cast<const char*>(field));
            i += strnlen(memberName, maximumSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3); // align to 4
        }
        else if (field->kind == TRK::LF_BCLASS) {
            const char* leafEnd = leafName(field->data.LF_BCLASS.offset,
                                           field->data.LF_BCLASS.lfEasy.kind);
            i += static_cast<size_t>(leafEnd - reinterpret_cast<const char*>(field));
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_VBCLASS || field->kind == TRK::LF_IVBCLASS) {
            TRK vbpKind = *reinterpret_cast<const TRK*>(field->data.LF_IVBCLASS.vbpOffset);
            uint8_t vbpSize1 = leafSize(vbpKind);
            TRK vbtKind = *reinterpret_cast<const TRK*>(field->data.LF_IVBCLASS.vbpOffset + vbpSize1);
            uint8_t vbpSize2 = leafSize(vbtKind);
            i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VBCLASS) + vbpSize1 + vbpSize2;
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_INDEX) {
            // Continuation of field list in another record
            importFieldList(field->data.LF_INDEX.type, parentId);
            i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_INDEX);
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_VFUNCTAB) {
            i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VFUNCTAB);
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_NESTTYPE) {
            const char* nestName = field->data.LF_NESTTYPE.name;
            i += static_cast<size_t>(nestName - reinterpret_cast<const char*>(field));
            i += strnlen(nestName, maximumSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_STMEMBER) {
            const char* smName = field->data.LF_STMEMBER.name;
            i += static_cast<size_t>(smName - reinterpret_cast<const char*>(field));
            i += strnlen(smName, maximumSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_METHOD) {
            const char* mName = field->data.LF_METHOD.name;
            i += static_cast<size_t>(mName - reinterpret_cast<const char*>(field));
            i += strnlen(mName, maximumSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_ONEMETHOD) {
            // Determine if it has a vbaseoff field
            auto prop = static_cast<PDB::CodeView::TPI::MethodProperty>(
                field->data.LF_ONEMETHOD.attributes.mprop);
            const char* mName;
            if (prop == PDB::CodeView::TPI::MethodProperty::Intro ||
                prop == PDB::CodeView::TPI::MethodProperty::PureIntro)
                mName = reinterpret_cast<const char*>(field->data.LF_ONEMETHOD.vbaseoff) + sizeof(uint32_t);
            else
                mName = reinterpret_cast<const char*>(field->data.LF_ONEMETHOD.vbaseoff);

            i += static_cast<size_t>(mName - reinterpret_cast<const char*>(field));
            i += strnlen(mName, maximumSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3);
        }
        else if (field->kind == TRK::LF_ENUMERATE) {
            const char* eName = leafName(field->data.LF_ENUMERATE.value,
                                          field->data.LF_ENUMERATE.lfEasy.kind);
            i += static_cast<size_t>(eName - reinterpret_cast<const char*>(field));
            i += strnlen(eName, maximumSize - i - 1) + 1;
            i = (i + 3) & ~size_t(3);
        }
        else {
            break; // unknown field kind, stop
        }
    }
}

void PdbCtx::importMemberType(uint32_t typeIndex, int offset, const QString& name, uint64_t parentId) {
    // Handle primitive type indices (< 0x1000)
    if (typeIndex < tt->firstIndex()) {
        uint32_t ptrMode = (typeIndex >> 8) & 0xF;
        if (ptrMode == 0x04 || ptrMode == 0x05) {
            // 32-bit pointer to a base type
            Node n;
            n.kind = NodeKind::Pointer32;
            n.name = name;
            n.parentId = parentId;
            n.offset = offset;
            n.collapsed = true;
            tree.addNode(n);
            return;
        }
        if (ptrMode == 0x06) {
            // 64-bit pointer to a base type
            Node n;
            n.kind = NodeKind::Pointer64;
            n.name = name;
            n.parentId = parentId;
            n.offset = offset;
            n.collapsed = true;
            tree.addNode(n);
            return;
        }
        if (ptrMode != 0x00) {
            // Some other pointer mode (near, far, huge) — treat as 32-bit
            Node n;
            n.kind = NodeKind::Pointer32;
            n.name = name;
            n.parentId = parentId;
            n.offset = offset;
            n.collapsed = true;
            tree.addNode(n);
            return;
        }
        // Direct base type
        Node n;
        n.kind = mapPrimitiveType(typeIndex);
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        tree.addNode(n);
        return;
    }

    const auto* rec = tt->get(typeIndex);
    if (!rec) {
        Node n;
        n.kind = NodeKind::Hex32;
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        tree.addNode(n);
        return;
    }

    switch (rec->header.kind) {
    case TRK::LF_MODIFIER:
        importMemberType(rec->data.LF_MODIFIER.type, offset, name, parentId);
        break;

    case TRK::LF_POINTER: {
        uint32_t ptrSize = rec->data.LF_POINTER.attr.size;
        uint32_t pointee = rec->data.LF_POINTER.utype;

        // Unwrap modifier on pointee
        uint32_t realPointee = unwrapModifier(pointee);

        Node n;
        n.kind = (ptrSize <= 4) ? NodeKind::Pointer32 : NodeKind::Pointer64;
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        n.collapsed = true;

        // Check if pointee is a UDT
        if (realPointee >= tt->firstIndex()) {
            const auto* pointeeRec = tt->get(realPointee);
            if (pointeeRec) {
                if (pointeeRec->header.kind == TRK::LF_STRUCTURE ||
                    pointeeRec->header.kind == TRK::LF_CLASS ||
                    pointeeRec->header.kind == TRK::LF_UNION) {
                    // If this is a forward ref, search for the definition
                    uint32_t defIndex = realPointee;
                    bool isFwd = false;
                    if (pointeeRec->header.kind == TRK::LF_UNION)
                        isFwd = pointeeRec->data.LF_UNION.property.fwdref;
                    else
                        isFwd = pointeeRec->data.LF_CLASS.property.fwdref;

                    if (isFwd) {
                        const char* typeName = nullptr;
                        if (pointeeRec->header.kind == TRK::LF_UNION)
                            typeName = leafName(pointeeRec->data.LF_UNION.data, unionLeafKind(pointeeRec->data.LF_UNION.data));
                        else
                            typeName = leafName(pointeeRec->data.LF_CLASS.data,
                                               pointeeRec->data.LF_CLASS.lfEasy.kind);

                        uint32_t resolved = findUdtDefinitionIndex(pointeeRec->header.kind, typeName);
                        if (resolved != 0) defIndex = resolved;
                    }
                    n.refId = importUDT(defIndex);
                } else if (pointeeRec->header.kind == TRK::LF_PROCEDURE ||
                           pointeeRec->header.kind == TRK::LF_MFUNCTION) {
                    n.kind = (ptrSize <= 4) ? NodeKind::FuncPtr32 : NodeKind::FuncPtr64;
                }
            }
        }
        tree.addNode(n);
        break;
    }

    case TRK::LF_STRUCTURE:
    case TRK::LF_CLASS:
    case TRK::LF_UNION: {
        // Embedded struct/union
        uint32_t defIndex = typeIndex;

        // Handle forward reference
        bool isFwd = false;
        if (rec->header.kind == TRK::LF_UNION)
            isFwd = rec->data.LF_UNION.property.fwdref;
        else
            isFwd = rec->data.LF_CLASS.property.fwdref;

        if (isFwd) {
            const char* typeName = nullptr;
            if (rec->header.kind == TRK::LF_UNION)
                typeName = leafName(rec->data.LF_UNION.data, unionLeafKind(rec->data.LF_UNION.data));
            else
                typeName = leafName(rec->data.LF_CLASS.data, rec->data.LF_CLASS.lfEasy.kind);

            uint32_t resolved = findUdtDefinitionIndex(rec->header.kind, typeName);
            if (resolved != 0) defIndex = resolved;
        }

        uint64_t refId = importUDT(defIndex);

        const char* typeName = nullptr;
        bool isUnion = (rec->header.kind == TRK::LF_UNION);
        if (isUnion)
            typeName = leafName(rec->data.LF_UNION.data, unionLeafKind(rec->data.LF_UNION.data));
        else
            typeName = leafName(rec->data.LF_CLASS.data, rec->data.LF_CLASS.lfEasy.kind);

        Node n;
        n.kind = NodeKind::Struct;
        n.name = name;
        n.structTypeName = typeName ? QString::fromUtf8(typeName) : QString();
        n.classKeyword = isUnion ? QStringLiteral("union") : QStringLiteral("struct");
        n.parentId = parentId;
        n.offset = offset;
        n.refId = refId;
        n.collapsed = true;
        tree.addNode(n);
        break;
    }

    case TRK::LF_ARRAY: {
        uint32_t elemType = rec->data.LF_ARRAY.elemtype;
        uint64_t totalSize = leafValue(rec->data.LF_ARRAY.data,
            *reinterpret_cast<const TRK*>(rec->data.LF_ARRAY.data));

        // Get element size
        uint64_t elemSize = 0;
        uint32_t realElemType = unwrapModifier(elemType);
        if (realElemType < tt->firstIndex()) {
            NodeKind ek = mapPrimitiveType(realElemType);
            elemSize = sizeForKind(ek);
        } else {
            const auto* elemRec = tt->get(realElemType);
            if (elemRec) {
                if (elemRec->header.kind == TRK::LF_STRUCTURE || elemRec->header.kind == TRK::LF_CLASS) {
                    const char* sizeData = elemRec->data.LF_CLASS.data;
                    elemSize = leafValue(sizeData, elemRec->data.LF_CLASS.lfEasy.kind);
                } else if (elemRec->header.kind == TRK::LF_UNION) {
                    const char* sizeData = elemRec->data.LF_UNION.data;
                    elemSize = leafValue(sizeData, *reinterpret_cast<const TRK*>(sizeData));
                } else if (elemRec->header.kind == TRK::LF_POINTER) {
                    elemSize = elemRec->data.LF_POINTER.attr.size;
                } else if (elemRec->header.kind == TRK::LF_ENUM) {
                    // Size of enum's underlying type
                    uint32_t ut = elemRec->data.LF_ENUM.utype;
                    if (ut < tt->firstIndex()) {
                        NodeKind ek = mapPrimitiveType(ut);
                        elemSize = sizeForKind(ek);
                    } else {
                        elemSize = 4;
                    }
                } else if (elemRec->header.kind == TRK::LF_ARRAY) {
                    // Nested array — get total size
                    elemSize = leafValue(elemRec->data.LF_ARRAY.data,
                        *reinterpret_cast<const TRK*>(elemRec->data.LF_ARRAY.data));
                }
            }
        }

        int count = (elemSize > 0) ? static_cast<int>(totalSize / elemSize) : 1;

        Node n;
        n.kind = NodeKind::Array;
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        n.arrayLen = count;

        // Determine element kind
        if (realElemType < tt->firstIndex()) {
            n.elementKind = mapPrimitiveType(realElemType);
        } else {
            const auto* elemRec = tt->get(realElemType);
            if (elemRec) {
                if (elemRec->header.kind == TRK::LF_STRUCTURE ||
                    elemRec->header.kind == TRK::LF_CLASS ||
                    elemRec->header.kind == TRK::LF_UNION) {
                    n.elementKind = NodeKind::Struct;
                    n.refId = importUDT(realElemType);
                    const char* tn = nullptr;
                    if (elemRec->header.kind == TRK::LF_UNION)
                        tn = leafName(elemRec->data.LF_UNION.data, unionLeafKind(elemRec->data.LF_UNION.data));
                    else
                        tn = leafName(elemRec->data.LF_CLASS.data, elemRec->data.LF_CLASS.lfEasy.kind);
                    if (tn) n.structTypeName = QString::fromUtf8(tn);
                } else if (elemRec->header.kind == TRK::LF_POINTER) {
                    uint32_t sz = elemRec->data.LF_POINTER.attr.size;
                    n.elementKind = (sz <= 4) ? NodeKind::Pointer32 : NodeKind::Pointer64;
                } else {
                    n.elementKind = hexForSize(elemSize);
                }
            }
        }
        tree.addNode(n);
        break;
    }

    case TRK::LF_ENUM: {
        // Map enum to its underlying integer type, link to enum definition
        uint32_t utype = rec->data.LF_ENUM.utype;
        uint64_t enumNodeId = importEnum(typeIndex);
        Node n;
        if (utype < tt->firstIndex()) {
            n.kind = mapPrimitiveType(utype);
        } else {
            n.kind = NodeKind::UInt32; // fallback
        }
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        n.refId = enumNodeId;
        tree.addNode(n);
        break;
    }

    case TRK::LF_PROCEDURE:
    case TRK::LF_MFUNCTION: {
        Node n;
        n.kind = NodeKind::Hex64;
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        tree.addNode(n);
        break;
    }

    case TRK::LF_BITFIELD: {
        uint32_t underlying = rec->data.LF_BITFIELD.type;
        uint64_t slotSize = 4;
        if (underlying < tt->firstIndex()) {
            NodeKind k = mapPrimitiveType(underlying);
            slotSize = sizeForKind(k);
        }
        Node n;
        n.kind = hexForSize(slotSize);
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        tree.addNode(n);
        break;
    }

    default: {
        // Unknown complex type — emit as Hex32
        Node n;
        n.kind = NodeKind::Hex32;
        n.name = name;
        n.parentId = parentId;
        n.offset = offset;
        tree.addNode(n);
        break;
    }
    }
}

// ── Helper: open PDB and build type table ──

struct PdbFile {
    MappedFile mapped;
    PDB::RawFile* rawFile = nullptr;
    PDB::TPIStream* tpiStream = nullptr;
    TypeTable* typeTable = nullptr;

    ~PdbFile() {
        delete typeTable;
        delete tpiStream;
        delete rawFile;
    }

    bool open(const QString& pdbPath, QString* errorMsg) {
        auto setErr = [&](const QString& msg) { if (errorMsg) *errorMsg = msg; };

        if (!QFile::exists(pdbPath)) {
            setErr(QStringLiteral("PDB file not found: ") + pdbPath);
            return false;
        }

        if (!mapped.open(pdbPath)) {
            setErr(QStringLiteral("Failed to memory-map PDB file: ") + pdbPath);
            return false;
        }

        if (PDB::ValidateFile(mapped.base, mapped.size) != PDB::ErrorCode::Success) {
            setErr(QStringLiteral("Invalid PDB file: ") + pdbPath);
            return false;
        }

        rawFile = new PDB::RawFile(PDB::CreateRawFile(mapped.base));

        if (PDB::HasValidTPIStream(*rawFile) != PDB::ErrorCode::Success) {
            setErr(QStringLiteral("PDB has no valid TPI stream: ") + pdbPath);
            return false;
        }

        tpiStream = new PDB::TPIStream(PDB::CreateTPIStream(*rawFile));
        typeTable = new TypeTable(*tpiStream);
        return true;
    }
};

// ── Public API: enumeratePdbTypes ──

QVector<PdbTypeInfo> enumeratePdbTypes(const QString& pdbPath, QString* errorMsg) {
    PdbFile pdb;
    if (!pdb.open(pdbPath, errorMsg)) return {};

    const TypeTable& tt = *pdb.typeTable;
    QVector<PdbTypeInfo> result;

    for (uint32_t ti = tt.firstIndex(); ti < tt.lastIndex(); ti++) {
        const auto* rec = tt.get(ti);
        if (!rec) continue;

        bool isUDT = (rec->header.kind == TRK::LF_STRUCTURE ||
                      rec->header.kind == TRK::LF_CLASS ||
                      rec->header.kind == TRK::LF_UNION);
        bool isEnum = (rec->header.kind == TRK::LF_ENUM);
        if (!isUDT && !isEnum) continue;

        const char* name = nullptr;
        uint16_t fieldCount = 0;
        bool isUnion = false;
        uint64_t size = 0;

        if (isEnum) {
            if (rec->data.LF_ENUM.property.fwdref) continue;
            fieldCount = rec->data.LF_ENUM.count;
            name = rec->data.LF_ENUM.name;
            // Size from underlying type
            uint32_t ut = rec->data.LF_ENUM.utype;
            if (ut < tt.firstIndex()) {
                NodeKind ek = mapPrimitiveType(ut);
                size = sizeForKind(ek);
            } else {
                size = 4;
            }
        } else if (rec->header.kind == TRK::LF_UNION) {
            if (rec->data.LF_UNION.property.fwdref) continue;
            isUnion = true;
            fieldCount = rec->data.LF_UNION.count;
            const char* sizeData = rec->data.LF_UNION.data;
            TRK sizeKind = *reinterpret_cast<const TRK*>(sizeData);
            size = leafValue(sizeData, sizeKind);
            name = leafName(sizeData, sizeKind);
        } else {
            if (rec->data.LF_CLASS.property.fwdref) continue;
            fieldCount = rec->data.LF_CLASS.count;
            const char* sizeData = rec->data.LF_CLASS.data;
            size = leafValue(sizeData, rec->data.LF_CLASS.lfEasy.kind);
            name = leafName(sizeData, rec->data.LF_CLASS.lfEasy.kind);
        }

        if (!name || name[0] == '\0') continue;
        // Skip anonymous types with compiler-generated names
        if (name[0] == '<') continue;

        PdbTypeInfo info;
        info.typeIndex = ti;
        info.name = QString::fromUtf8(name);
        info.size = size;
        info.childCount = fieldCount;
        info.isUnion = isUnion;
        info.isEnum = isEnum;
        result.append(info);
    }

    return result;
}

// ── Public API: importPdbSelected ──

NodeTree importPdbSelected(const QString& pdbPath,
                           const QVector<uint32_t>& typeIndices,
                           QString* errorMsg,
                           ProgressCb progressCb) {
    PdbFile pdb;
    if (!pdb.open(pdbPath, errorMsg)) return {};

    PdbCtx ctx;
    ctx.tt = pdb.typeTable;

    int total = typeIndices.size();
    for (int i = 0; i < total; i++) {
        uint32_t ti = typeIndices[i];
        const auto* rec = pdb.typeTable->get(ti);
        if (rec && rec->header.kind == TRK::LF_ENUM)
            ctx.importEnum(ti);
        else
            ctx.importUDT(ti);
        if (progressCb && !progressCb(i + 1, total)) {
            if (errorMsg) *errorMsg = QStringLiteral("Import cancelled");
            return ctx.tree; // return partial result
        }
    }

    if (ctx.tree.nodes.isEmpty()) {
        if (errorMsg) *errorMsg = QStringLiteral("No types imported");
    }
    return ctx.tree;
}

// ── Public API: importPdb (legacy) ──

NodeTree importPdb(const QString& pdbPath, const QString& structFilter, QString* errorMsg) {
    PdbFile pdb;
    if (!pdb.open(pdbPath, errorMsg)) return {};

    const TypeTable& tt = *pdb.typeTable;
    PdbCtx ctx;
    ctx.tt = &tt;

    for (uint32_t ti = tt.firstIndex(); ti < tt.lastIndex(); ti++) {
        const auto* rec = tt.get(ti);
        if (!rec) continue;

        bool isUDT = (rec->header.kind == TRK::LF_STRUCTURE ||
                      rec->header.kind == TRK::LF_CLASS ||
                      rec->header.kind == TRK::LF_UNION);
        if (!isUDT) continue;

        bool fwdref = false;
        const char* name = nullptr;

        if (rec->header.kind == TRK::LF_UNION) {
            fwdref = rec->data.LF_UNION.property.fwdref;
            name = leafName(rec->data.LF_UNION.data, unionLeafKind(rec->data.LF_UNION.data));
        } else {
            fwdref = rec->data.LF_CLASS.property.fwdref;
            name = leafName(rec->data.LF_CLASS.data, rec->data.LF_CLASS.lfEasy.kind);
        }

        if (fwdref) continue;
        if (!name) continue;

        if (!structFilter.isEmpty()) {
            if (QString::fromUtf8(name) != structFilter) continue;
        }

        ctx.importUDT(ti);

        // If filtering to a single struct, stop after finding it
        if (!structFilter.isEmpty()) break;
    }

    if (ctx.tree.nodes.isEmpty()) {
        if (!structFilter.isEmpty()) {
            if (errorMsg) *errorMsg = QStringLiteral("Type '") + structFilter +
                QStringLiteral("' not found in PDB");
        } else {
            if (errorMsg) *errorMsg = QStringLiteral("No types found in PDB");
        }
    }

    return ctx.tree;
}

} // namespace rcx

#else // !_WIN32

namespace rcx {

QVector<PdbTypeInfo> enumeratePdbTypes(const QString&, QString* errorMsg) {
    if (errorMsg) *errorMsg = QStringLiteral("PDB import requires Windows");
    return {};
}

NodeTree importPdbSelected(const QString&, const QVector<uint32_t>&,
                           QString* errorMsg, ProgressCb) {
    if (errorMsg) *errorMsg = QStringLiteral("PDB import requires Windows");
    return {};
}

NodeTree importPdb(const QString&, const QString&, QString* errorMsg) {
    if (errorMsg) *errorMsg = QStringLiteral("PDB import requires Windows");
    return {};
}

} // namespace rcx

#endif

```

`src/imports/import_pdb.h`:

```h
#pragma once
#include "core.h"
#include <QVector>
#include <functional>

namespace rcx {

struct PdbTypeInfo {
    uint32_t typeIndex;      // TPI type index
    QString  name;           // struct/class/union/enum name
    uint64_t size;           // sizeof in bytes
    int      childCount;     // direct member count
    bool     isUnion;        // union vs struct/class
    bool     isEnum = false; // enum type
};

// Phase 1: Enumerate all UDT types in the PDB (fast scan, no recursive import).
QVector<PdbTypeInfo> enumeratePdbTypes(const QString& pdbPath,
                                       QString* errorMsg = nullptr);

// Phase 2: Import selected types with full recursive child types.
// progressCb is called with (current, total) for each top-level type;
// return false from the callback to cancel the import.
using ProgressCb = std::function<bool(int current, int total)>;
NodeTree importPdbSelected(const QString& pdbPath,
                           const QVector<uint32_t>& typeIndices,
                           QString* errorMsg = nullptr,
                           ProgressCb progressCb = {});

// Legacy single-call API: import one struct by name (or all if filter empty).
NodeTree importPdb(const QString& pdbPath,
                   const QString& structFilter = {},
                   QString* errorMsg = nullptr);

} // namespace rcx

```

`src/imports/import_pdb_dialog.cpp`:

```cpp
#include "import_pdb_dialog.h"
#include "import_pdb.h"

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLineEdit>
#include <QCheckBox>
#include <QListWidget>
#include <QLabel>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QFileDialog>
#include <QMessageBox>
#include <QApplication>

namespace rcx {

PdbImportDialog::PdbImportDialog(QWidget* parent)
    : QDialog(parent)
{
    setWindowTitle("Import from PDB");
    resize(520, 480);

    auto* layout = new QVBoxLayout(this);

    // PDB path row
    auto* pathRow = new QHBoxLayout;
    pathRow->addWidget(new QLabel("PDB File:"));
    m_pathEdit = new QLineEdit;
    m_pathEdit->setPlaceholderText("Select a PDB file...");
    pathRow->addWidget(m_pathEdit);
    m_browseBtn = new QPushButton("...");
    m_browseBtn->setFixedWidth(32);
    pathRow->addWidget(m_browseBtn);
    layout->addLayout(pathRow);

    // Filter row
    auto* filterRow = new QHBoxLayout;
    filterRow->addWidget(new QLabel("Filter:"));
    m_filterEdit = new QLineEdit;
    m_filterEdit->setPlaceholderText("Type name filter...");
    m_filterEdit->setEnabled(false);
    filterRow->addWidget(m_filterEdit);
    layout->addLayout(filterRow);

    // Select all checkbox
    m_selectAll = new QCheckBox("Select All");
    m_selectAll->setEnabled(false);
    layout->addWidget(m_selectAll);

    // Type list
    m_typeList = new QListWidget;
    m_typeList->setEnabled(false);
    layout->addWidget(m_typeList);

    // Count label
    m_countLabel = new QLabel("No PDB loaded");
    layout->addWidget(m_countLabel);

    // Buttons
    m_buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    m_buttons->button(QDialogButtonBox::Ok)->setText("Import");
    m_buttons->button(QDialogButtonBox::Ok)->setEnabled(false);
    layout->addWidget(m_buttons);

    connect(m_browseBtn, &QPushButton::clicked, this, &PdbImportDialog::browsePdb);
    connect(m_pathEdit, &QLineEdit::returnPressed, this, &PdbImportDialog::loadPdb);
    connect(m_filterEdit, &QLineEdit::textChanged, this, &PdbImportDialog::filterChanged);
    connect(m_selectAll, &QCheckBox::toggled, this, &PdbImportDialog::selectAllToggled);
    connect(m_typeList, &QListWidget::itemChanged, this, &PdbImportDialog::updateSelectionCount);
    connect(m_buttons, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(m_buttons, &QDialogButtonBox::rejected, this, &QDialog::reject);
}

QString PdbImportDialog::pdbPath() const {
    return m_pathEdit->text();
}

QVector<uint32_t> PdbImportDialog::selectedTypeIndices() const {
    QVector<uint32_t> result;
    for (int i = 0; i < m_typeList->count(); i++) {
        auto* item = m_typeList->item(i);
        if (item->checkState() == Qt::Checked) {
            uint32_t typeIndex = item->data(Qt::UserRole).toUInt();
            result.append(typeIndex);
        }
    }
    return result;
}

void PdbImportDialog::browsePdb() {
    QString path = QFileDialog::getOpenFileName(this,
        "Select PDB File", {},
        "PDB Files (*.pdb);;All Files (*)");
    if (path.isEmpty()) return;
    m_pathEdit->setText(path);
    loadPdb();
}

void PdbImportDialog::loadPdb() {
    QString path = m_pathEdit->text();
    if (path.isEmpty()) return;

    m_typeList->clear();
    m_allTypes.clear();
    m_countLabel->setText("Loading...");
    m_typeList->setEnabled(false);
    m_filterEdit->setEnabled(false);
    m_selectAll->setEnabled(false);
    m_buttons->button(QDialogButtonBox::Ok)->setEnabled(false);
    QApplication::processEvents();

    QString error;
    QVector<PdbTypeInfo> types = enumeratePdbTypes(path, &error);

    if (types.isEmpty()) {
        m_countLabel->setText(error.isEmpty() ? "No types found" : error);
        return;
    }

    m_allTypes.reserve(types.size());
    for (const auto& t : types) {
        TypeItem item;
        item.typeIndex = t.typeIndex;
        item.name = t.name;
        item.childCount = t.childCount;
        item.isUnion = t.isUnion;
        m_allTypes.append(item);
    }

    // Sort by name
    std::sort(m_allTypes.begin(), m_allTypes.end(),
              [](const TypeItem& a, const TypeItem& b) { return a.name < b.name; });

    m_filterEdit->setEnabled(true);
    m_selectAll->setEnabled(true);
    m_typeList->setEnabled(true);
    populateList();
}

void PdbImportDialog::populateList() {
    m_typeList->blockSignals(true);
    m_typeList->clear();

    QString filter = m_filterEdit->text();
    bool selectAll = m_selectAll->isChecked();

    for (const auto& t : m_allTypes) {
        if (!filter.isEmpty() && !t.name.contains(filter, Qt::CaseInsensitive))
            continue;

        QString label = QStringLiteral("%1  (%2 fields)")
            .arg(t.name).arg(t.childCount);
        auto* item = new QListWidgetItem(label, m_typeList);
        item->setFlags(item->flags() | Qt::ItemIsUserCheckable);
        item->setCheckState(selectAll ? Qt::Checked : Qt::Unchecked);
        item->setData(Qt::UserRole, t.typeIndex);
    }

    m_typeList->blockSignals(false);
    updateSelectionCount();
}

void PdbImportDialog::filterChanged(const QString&) {
    populateList();
}

void PdbImportDialog::selectAllToggled(bool) {
    populateList();
}

void PdbImportDialog::updateSelectionCount() {
    int checked = 0;
    int total = m_typeList->count();
    for (int i = 0; i < total; i++) {
        if (m_typeList->item(i)->checkState() == Qt::Checked)
            checked++;
    }
    m_countLabel->setText(QStringLiteral("%1 of %2 types selected")
        .arg(checked).arg(m_allTypes.size()));
    m_buttons->button(QDialogButtonBox::Ok)->setEnabled(checked > 0);
}

} // namespace rcx

```

`src/imports/import_pdb_dialog.h`:

```h
#pragma once

#include <QDialog>
#include <QVector>
#include <cstdint>

class QLineEdit;
class QCheckBox;
class QListWidget;
class QLabel;
class QDialogButtonBox;
class QPushButton;

namespace rcx {

struct PdbTypeInfo;

class PdbImportDialog : public QDialog {
    Q_OBJECT
public:
    explicit PdbImportDialog(QWidget* parent = nullptr);

    QString pdbPath() const;
    QVector<uint32_t> selectedTypeIndices() const;

private slots:
    void browsePdb();
    void loadPdb();
    void filterChanged(const QString& text);
    void selectAllToggled(bool checked);
    void updateSelectionCount();

private:
    QLineEdit*        m_pathEdit;
    QPushButton*      m_browseBtn;
    QLineEdit*        m_filterEdit;
    QCheckBox*        m_selectAll;
    QListWidget*      m_typeList;
    QLabel*           m_countLabel;
    QDialogButtonBox* m_buttons;

    struct TypeItem {
        uint32_t typeIndex;
        QString  name;
        int      childCount;
        bool     isUnion;
    };
    QVector<TypeItem> m_allTypes;

    void populateList();
};

} // namespace rcx

```

`src/imports/import_reclass_xml.cpp`:

```cpp
#include "import_reclass_xml.h"
#include <QFile>
#include <QXmlStreamReader>
#include <QHash>
#include <QVector>
#include <QDebug>

namespace rcx {

// ── Version-specific type maps ──
// Maps XML Type attribute (integer) → NodeKind.
// Entries with no rcx equivalent use Hex8 as fallback.

enum class XmlVersion { V2013, V2016 };

// 2016 / ReClassEx / MemeClsEx type map (35 entries, index = XML Type value)
static const struct { int xmlType; NodeKind kind; } kTypeMap2016[] = {
    // 0: null (unused)
    { 1,  NodeKind::Struct },     // ClassInstance
    // 2,3: null
    { 4,  NodeKind::Hex32 },
    { 5,  NodeKind::Hex64 },
    { 6,  NodeKind::Hex16 },
    { 7,  NodeKind::Hex8 },
    { 8,  NodeKind::Pointer64 },  // ClassPointer
    { 9,  NodeKind::Int64 },
    { 10, NodeKind::Int32 },
    { 11, NodeKind::Int16 },
    { 12, NodeKind::Int8 },
    { 13, NodeKind::Float },
    { 14, NodeKind::Double },
    { 15, NodeKind::UInt32 },
    { 16, NodeKind::UInt16 },
    { 17, NodeKind::UInt8 },
    { 18, NodeKind::UTF8 },       // UTF8Text
    { 19, NodeKind::UTF16 },      // UTF16Text
    { 20, NodeKind::Pointer64 },  // FunctionPtr
    { 21, NodeKind::Hex8 },       // Custom (expanded by Size)
    { 22, NodeKind::Vec2 },
    { 23, NodeKind::Vec3 },
    { 24, NodeKind::Vec4 },
    { 25, NodeKind::Mat4x4 },
    { 26, NodeKind::Pointer64 },  // VTable
    { 27, NodeKind::Array },      // ClassInstanceArray
    // 28: null (used for Class elements, not nodes)
    { 29, NodeKind::Pointer64 },  // UTF8TextPtr
    { 30, NodeKind::Pointer64 },  // UTF16TextPtr
    // 31: BitField → UInt8 fallback
    { 31, NodeKind::UInt8 },
    { 32, NodeKind::UInt64 },
    { 33, NodeKind::Pointer64 },  // Function
};

// 2013 / ReClass 2011 type map (31 entries)
static const struct { int xmlType; NodeKind kind; } kTypeMap2013[] = {
    { 1,  NodeKind::Struct },     // ClassInstance
    { 4,  NodeKind::Hex32 },
    { 5,  NodeKind::Hex16 },
    { 6,  NodeKind::Hex8 },
    { 7,  NodeKind::Pointer64 },  // ClassPointer
    { 8,  NodeKind::Int32 },
    { 9,  NodeKind::Int16 },
    { 10, NodeKind::Int8 },
    { 11, NodeKind::Float },
    { 12, NodeKind::UInt32 },
    { 13, NodeKind::UInt16 },
    { 14, NodeKind::UInt8 },
    { 15, NodeKind::UTF8 },       // UTF8Text
    { 16, NodeKind::Pointer64 },  // FunctionPtr
    { 17, NodeKind::Hex8 },       // Custom
    { 18, NodeKind::Vec2 },
    { 19, NodeKind::Vec3 },
    { 20, NodeKind::Vec4 },
    { 21, NodeKind::Mat4x4 },
    { 22, NodeKind::Pointer64 },  // VTable
    { 23, NodeKind::Array },      // ClassInstanceArray
    { 27, NodeKind::Int64 },
    { 28, NodeKind::Double },
    { 29, NodeKind::UTF16 },      // UTF16Text
    { 30, NodeKind::Array },      // ClassPointerArray
};

static NodeKind lookupKind(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016) {
        for (const auto& e : kTypeMap2016)
            if (e.xmlType == xmlType) return e.kind;
    } else {
        for (const auto& e : kTypeMap2013)
            if (e.xmlType == xmlType) return e.kind;
    }
    return NodeKind::Hex8; // fallback
}

// Is this XML type a pointer-like type that uses the "Pointer" attribute?
static bool isPointerType(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016)
        return xmlType == 8 || xmlType == 20 || xmlType == 26 || xmlType == 29 || xmlType == 30 || xmlType == 33;
    else
        return xmlType == 7 || xmlType == 16 || xmlType == 22;
}

// Is this XML type a ClassInstance (embedded struct)?
static bool isClassInstanceType(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016) return xmlType == 1;
    else return xmlType == 1;
}

// Is this XML type a ClassInstanceArray?
static bool isClassInstanceArrayType(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016) return xmlType == 27;
    else return xmlType == 23 || xmlType == 30;
}

// Is this XML type a text node?
static bool isTextType(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016) return xmlType == 18 || xmlType == 19;
    else return xmlType == 15 || xmlType == 29;
}

// Is this XML type a UTF16 text node?
static bool isUtf16TextType(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016) return xmlType == 19;
    else return xmlType == 29;
}

// Is this XML type a Custom node (expanded to hex)?
static bool isCustomType(int xmlType, XmlVersion ver) {
    if (ver == XmlVersion::V2016) return xmlType == 21;
    else return xmlType == 17;
}

// Deferred pointer resolution entry
struct PendingRef {
    uint64_t nodeId;
    QString  className;
};

NodeTree importReclassXml(const QString& filePath, QString* errorMsg) {
    qDebug() << "[ImportXML] Opening file:" << filePath;

    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qDebug() << "[ImportXML] ERROR: Cannot open file";
        if (errorMsg) *errorMsg = QStringLiteral("Cannot open file: ") + filePath;
        return {};
    }

    qDebug() << "[ImportXML] File size:" << file.size() << "bytes";

    QXmlStreamReader xml(&file);
    XmlVersion version = XmlVersion::V2016; // default to 2016 (most common)

    NodeTree tree;
    tree.baseAddress = 0x00400000;

    // Class name → struct node ID (for pointer resolution)
    QHash<QString, uint64_t> classIds;
    // Deferred pointer refs to resolve after all classes are parsed
    QVector<PendingRef> pendingRefs;

    // Detect version from first comment
    bool versionDetected = false;

    while (!xml.atEnd()) {
        xml.readNext();

        // Detect version from XML comments
        if (!versionDetected && xml.isComment()) {
            QString comment = xml.text().toString().trimmed();
            if (comment.contains(QStringLiteral("ReClassEx"), Qt::CaseInsensitive) ||
                comment.contains(QStringLiteral("MemeClsEx"), Qt::CaseInsensitive) ||
                comment.contains(QStringLiteral("2016"), Qt::CaseInsensitive) ||
                comment.contains(QStringLiteral("2015"), Qt::CaseInsensitive)) {
                version = XmlVersion::V2016;
            } else if (comment.contains(QStringLiteral("2013"), Qt::CaseInsensitive) ||
                       comment.contains(QStringLiteral("2011"), Qt::CaseInsensitive)) {
                version = XmlVersion::V2013;
            }
            // else keep default V2016
            versionDetected = true;
            qDebug() << "[ImportXML] Detected version:" << (version == XmlVersion::V2016 ? "V2016" : "V2013");
        }

        if (!xml.isStartElement()) continue;

        if (xml.name() == QStringLiteral("Class")) {
            // Parse a class element into a root Struct node
            QString className = xml.attributes().value(QStringLiteral("Name")).toString();
            QString strOffset = xml.attributes().value(QStringLiteral("strOffset")).toString();

            // Create root struct node (collapsed by default for large files)
            Node structNode;
            structNode.kind = NodeKind::Struct;
            structNode.name = className;
            structNode.structTypeName = className;
            structNode.parentId = 0; // root level
            structNode.offset = 0;
            structNode.collapsed = true;

            int structIdx = tree.addNode(structNode);
            uint64_t structId = tree.nodes[structIdx].id;
            classIds[className] = structId;
            qDebug() << "[ImportXML] Class:" << className << "id:" << structId;

            // Parse child Node elements
            int childOffset = 0;
            while (!xml.atEnd()) {
                xml.readNext();

                if (xml.isEndElement() && xml.name() == QStringLiteral("Class"))
                    break;

                if (!xml.isStartElement() || xml.name() != QStringLiteral("Node"))
                    continue;

                int xmlType = xml.attributes().value(QStringLiteral("Type")).toInt();
                QString nodeName = xml.attributes().value(QStringLiteral("Name")).toString();
                int nodeSize = xml.attributes().value(QStringLiteral("Size")).toInt();
                QString ptrClass = xml.attributes().value(QStringLiteral("Pointer")).toString();
                QString instClass = xml.attributes().value(QStringLiteral("Instance")).toString();

                qDebug() << "[ImportXML]   Node:" << nodeName << "type:" << xmlType
                         << "size:" << nodeSize << "ptr:" << ptrClass << "inst:" << instClass;

                // Handle Custom type: expand to appropriate hex nodes
                if (isCustomType(xmlType, version) && nodeSize > 0) {
                    // Pick best-fit hex kind
                    NodeKind hexKind;
                    int hexSize;
                    if (nodeSize >= 8 && nodeSize % 8 == 0) {
                        hexKind = NodeKind::Hex64; hexSize = 8;
                    } else if (nodeSize >= 4 && nodeSize % 4 == 0) {
                        hexKind = NodeKind::Hex32; hexSize = 4;
                    } else if (nodeSize >= 2 && nodeSize % 2 == 0) {
                        hexKind = NodeKind::Hex16; hexSize = 2;
                    } else {
                        hexKind = NodeKind::Hex8; hexSize = 1;
                    }
                    int count = nodeSize / hexSize;
                    for (int i = 0; i < count; i++) {
                        Node n;
                        n.kind = hexKind;
                        n.name = (count == 1) ? nodeName : QString();
                        n.parentId = structId;
                        n.offset = childOffset;
                        tree.addNode(n);
                        childOffset += hexSize;
                    }
                    continue;
                }

                NodeKind kind = lookupKind(xmlType, version);

                // Handle ClassInstanceArray: read child <Array> element
                if (isClassInstanceArrayType(xmlType, version)) {
                    qDebug() << "[ImportXML]     -> ClassInstanceArray";
                    int total = xml.attributes().value(QStringLiteral("Total")).toInt();
                    if (total <= 0)
                        total = xml.attributes().value(QStringLiteral("Count")).toInt();
                    if (total <= 0) total = 1;

                    // Read child <Array> element for class name
                    QString arrayClassName;
                    while (!xml.atEnd()) {
                        xml.readNext();
                        if (xml.isEndElement() && xml.name() == QStringLiteral("Node"))
                            break;
                        if (xml.isStartElement() && xml.name() == QStringLiteral("Array")) {
                            arrayClassName = xml.attributes().value(QStringLiteral("Name")).toString();
                            int arrayTotal = xml.attributes().value(QStringLiteral("Total")).toInt();
                            if (arrayTotal <= 0)
                                arrayTotal = xml.attributes().value(QStringLiteral("Count")).toInt();
                            if (arrayTotal > 0) total = arrayTotal;
                        }
                    }

                    // Create an Array node wrapping Struct elements
                    Node arrNode;
                    arrNode.kind = NodeKind::Array;
                    arrNode.name = nodeName;
                    arrNode.parentId = structId;
                    arrNode.offset = childOffset;
                    arrNode.arrayLen = total;
                    arrNode.elementKind = NodeKind::Struct;
                    if (!arrayClassName.isEmpty())
                        arrNode.structTypeName = arrayClassName;
                    int arrIdx = tree.addNode(arrNode);
                    uint64_t arrId = tree.nodes[arrIdx].id;

                    // Defer ref resolution if array references a class
                    if (!arrayClassName.isEmpty()) {
                        pendingRefs.append({arrId, arrayClassName});
                    }

                    childOffset += nodeSize > 0 ? nodeSize : 0;
                    continue;
                }

                Node n;
                n.kind = kind;
                n.name = nodeName;
                n.parentId = structId;
                n.offset = childOffset;

                // Handle text nodes
                if (isTextType(xmlType, version)) {
                    if (isUtf16TextType(xmlType, version))
                        n.strLen = qMax(1, nodeSize / 2);
                    else
                        n.strLen = qMax(1, nodeSize);
                }

                // Handle pointer types
                if (isPointerType(xmlType, version) && !ptrClass.isEmpty()) {
                    qDebug() << "[ImportXML]     -> Pointer to class:" << ptrClass;
                    n.collapsed = true; // Start collapsed to avoid recursive expansion freeze
                    int nodeIdx = tree.addNode(n);
                    uint64_t nodeId = tree.nodes[nodeIdx].id;
                    pendingRefs.append({nodeId, ptrClass});
                    childOffset += nodeSize > 0 ? nodeSize : sizeForKind(kind);
                    continue;
                }

                // Handle embedded class instance
                if (isClassInstanceType(xmlType, version)) {
                    QString resolvedClass = instClass.isEmpty() ? ptrClass : instClass;
                    qDebug() << "[ImportXML]     -> ClassInstance:" << resolvedClass;
                    n.collapsed = true; // Start collapsed to avoid recursive expansion freeze
                    n.structTypeName = resolvedClass;
                    if (!n.structTypeName.isEmpty()) {
                        int nodeIdx = tree.addNode(n);
                        uint64_t nodeId = tree.nodes[nodeIdx].id;
                        pendingRefs.append({nodeId, n.structTypeName});
                    } else {
                        tree.addNode(n);
                    }
                    childOffset += nodeSize > 0 ? nodeSize : 0;
                    continue;
                }

                tree.addNode(n);
                childOffset += nodeSize > 0 ? nodeSize : sizeForKind(kind);
            }
        }
    }

    if (xml.hasError() && xml.error() != QXmlStreamReader::PrematureEndOfDocumentError) {
        qDebug() << "[ImportXML] XML parse error at line" << xml.lineNumber() << ":" << xml.errorString();
        if (errorMsg)
            *errorMsg = QStringLiteral("XML parse error at line %1: %2")
                .arg(xml.lineNumber())
                .arg(xml.errorString());
        return {};
    }

    qDebug() << "[ImportXML] Parsing complete. Total nodes:" << tree.nodes.size()
             << "classes:" << classIds.size() << "pending refs:" << pendingRefs.size();

    if (tree.nodes.isEmpty()) {
        qDebug() << "[ImportXML] ERROR: No classes found";
        if (errorMsg) *errorMsg = QStringLiteral("No classes found in file");
        return {};
    }

    // Resolve deferred pointer/struct references
    int resolved = 0, unresolved = 0;
    for (const auto& ref : pendingRefs) {
        int nodeIdx = tree.indexOfId(ref.nodeId);
        if (nodeIdx < 0) continue;

        auto it = classIds.find(ref.className);
        if (it != classIds.end()) {
            tree.nodes[nodeIdx].refId = it.value();
            resolved++;
        } else {
            qDebug() << "[ImportXML] Unresolved ref:" << ref.className << "for node" << ref.nodeId;
            unresolved++;
        }
    }

    qDebug() << "[ImportXML] Refs resolved:" << resolved << "unresolved:" << unresolved;
    qDebug() << "[ImportXML] Import complete. Returning tree with" << tree.nodes.size() << "nodes";

    return tree;
}

} // namespace rcx

```

`src/imports/import_reclass_xml.h`:

```h
#pragma once
#include "core.h"

namespace rcx {

// Import a ReClass XML file (.reclass, .MemeCls, etc.) into a NodeTree.
// Supports ReClassEx, MemeClsEx, ReClass 2011/2013/2016 XML formats.
// Returns an empty NodeTree on failure; populates errorMsg if non-null.
NodeTree importReclassXml(const QString& filePath, QString* errorMsg = nullptr);

} // namespace rcx

```

`src/imports/import_source.cpp`:

```cpp
#include "import_source.h"
#include <QHash>
#include <QSet>
#include <QVector>
#include <QRegularExpression>
#include <QDebug>

namespace rcx {

// ── Built-in type alias table ──

struct TypeInfo {
    NodeKind kind;
    int      size; // bytes (0 = dynamic/pointer)
};

static QHash<QString, TypeInfo> buildTypeTable() {
    QHash<QString, TypeInfo> t;

    // stdint.h
    t[QStringLiteral("uint8_t")]  = {NodeKind::UInt8,  1};
    t[QStringLiteral("int8_t")]   = {NodeKind::Int8,   1};
    t[QStringLiteral("uint16_t")] = {NodeKind::UInt16, 2};
    t[QStringLiteral("int16_t")]  = {NodeKind::Int16,  2};
    t[QStringLiteral("uint32_t")] = {NodeKind::UInt32, 4};
    t[QStringLiteral("int32_t")]  = {NodeKind::Int32,  4};
    t[QStringLiteral("uint64_t")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("int64_t")]  = {NodeKind::Int64,  8};

    // Standard C
    t[QStringLiteral("char")]     = {NodeKind::Int8,   1};
    t[QStringLiteral("short")]    = {NodeKind::Int16,  2};
    t[QStringLiteral("int")]      = {NodeKind::Int32,  4};
    t[QStringLiteral("long")]     = {NodeKind::Int32,  4};
    t[QStringLiteral("float")]    = {NodeKind::Float,  4};
    t[QStringLiteral("double")]   = {NodeKind::Double, 8};
    t[QStringLiteral("bool")]     = {NodeKind::Bool,   1};
    t[QStringLiteral("_Bool")]    = {NodeKind::Bool,   1};
    t[QStringLiteral("void")]     = {NodeKind::Hex8,   1};
    t[QStringLiteral("wchar_t")]  = {NodeKind::UInt16, 2};

    // Multi-word C types (pre-merged by parser)
    t[QStringLiteral("unsigned char")]      = {NodeKind::UInt8,  1};
    t[QStringLiteral("signed char")]        = {NodeKind::Int8,   1};
    t[QStringLiteral("unsigned short")]     = {NodeKind::UInt16, 2};
    t[QStringLiteral("signed short")]       = {NodeKind::Int16,  2};
    t[QStringLiteral("unsigned int")]       = {NodeKind::UInt32, 4};
    t[QStringLiteral("signed int")]         = {NodeKind::Int32,  4};
    t[QStringLiteral("unsigned")]           = {NodeKind::UInt32, 4};
    t[QStringLiteral("long long")]          = {NodeKind::Int64,  8};
    t[QStringLiteral("unsigned long")]      = {NodeKind::UInt32, 4};
    t[QStringLiteral("signed long")]        = {NodeKind::Int32,  4};
    t[QStringLiteral("unsigned long long")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("signed long long")]   = {NodeKind::Int64,  8};
    t[QStringLiteral("long int")]           = {NodeKind::Int32,  4};
    t[QStringLiteral("long long int")]      = {NodeKind::Int64,  8};
    t[QStringLiteral("unsigned long int")]  = {NodeKind::UInt32, 4};
    t[QStringLiteral("unsigned long long int")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("short int")]          = {NodeKind::Int16,  2};
    t[QStringLiteral("unsigned short int")] = {NodeKind::UInt16, 2};

    // Windows types
    t[QStringLiteral("BYTE")]      = {NodeKind::UInt8,  1};
    t[QStringLiteral("UCHAR")]     = {NodeKind::UInt8,  1};
    t[QStringLiteral("BOOLEAN")]   = {NodeKind::UInt8,  1};
    t[QStringLiteral("CHAR")]      = {NodeKind::Int8,   1};
    t[QStringLiteral("WORD")]      = {NodeKind::UInt16, 2};
    t[QStringLiteral("USHORT")]    = {NodeKind::UInt16, 2};
    t[QStringLiteral("SHORT")]     = {NodeKind::Int16,  2};
    t[QStringLiteral("WCHAR")]     = {NodeKind::UInt16, 2};
    t[QStringLiteral("DWORD")]     = {NodeKind::UInt32, 4};
    t[QStringLiteral("ULONG")]     = {NodeKind::UInt32, 4};
    t[QStringLiteral("UINT")]      = {NodeKind::UInt32, 4};
    t[QStringLiteral("LONG")]      = {NodeKind::Int32,  4};
    t[QStringLiteral("LONG32")]    = {NodeKind::Int32,  4};
    t[QStringLiteral("INT")]       = {NodeKind::Int32,  4};
    t[QStringLiteral("BOOL")]      = {NodeKind::Int32,  4};
    t[QStringLiteral("FLOAT")]     = {NodeKind::Float,  4};
    t[QStringLiteral("QWORD")]     = {NodeKind::UInt64, 8};
    t[QStringLiteral("ULONGLONG")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("DWORD64")]   = {NodeKind::UInt64, 8};
    t[QStringLiteral("ULONG64")]   = {NodeKind::UInt64, 8};
    t[QStringLiteral("UINT64")]    = {NodeKind::UInt64, 8};
    t[QStringLiteral("LONGLONG")]  = {NodeKind::Int64,  8};
    t[QStringLiteral("LONG64")]    = {NodeKind::Int64,  8};
    t[QStringLiteral("INT64")]     = {NodeKind::Int64,  8};

    // Platform pointer-size types
    t[QStringLiteral("PVOID")]      = {NodeKind::Pointer64, 8};
    t[QStringLiteral("LPVOID")]     = {NodeKind::Pointer64, 8};
    t[QStringLiteral("HANDLE")]     = {NodeKind::Pointer64, 8};
    t[QStringLiteral("HMODULE")]    = {NodeKind::Pointer64, 8};
    t[QStringLiteral("HWND")]       = {NodeKind::Pointer64, 8};
    t[QStringLiteral("HINSTANCE")]  = {NodeKind::Pointer64, 8};
    t[QStringLiteral("SIZE_T")]     = {NodeKind::UInt64, 8};
    t[QStringLiteral("ULONG_PTR")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("UINT_PTR")]  = {NodeKind::UInt64, 8};
    t[QStringLiteral("DWORD_PTR")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("LONG_PTR")]  = {NodeKind::Int64,  8};
    t[QStringLiteral("INT_PTR")]   = {NodeKind::Int64,  8};
    t[QStringLiteral("SSIZE_T")]   = {NodeKind::Int64,  8};
    t[QStringLiteral("uintptr_t")] = {NodeKind::UInt64, 8};
    t[QStringLiteral("intptr_t")]  = {NodeKind::Int64,  8};
    t[QStringLiteral("size_t")]    = {NodeKind::UInt64, 8};
    t[QStringLiteral("ptrdiff_t")] = {NodeKind::Int64,  8};
    t[QStringLiteral("ssize_t")]   = {NodeKind::Int64,  8};

    // Pointer type aliases
    t[QStringLiteral("PCHAR")]  = {NodeKind::Pointer64, 8};
    t[QStringLiteral("LPSTR")]  = {NodeKind::Pointer64, 8};
    t[QStringLiteral("LPCSTR")] = {NodeKind::Pointer64, 8};
    t[QStringLiteral("PCSTR")]  = {NodeKind::Pointer64, 8};
    t[QStringLiteral("PWSTR")]  = {NodeKind::Pointer64, 8};
    t[QStringLiteral("LPWSTR")] = {NodeKind::Pointer64, 8};
    t[QStringLiteral("LPCWSTR")]= {NodeKind::Pointer64, 8};
    t[QStringLiteral("PCWSTR")] = {NodeKind::Pointer64, 8};

    return t;
}

// ── Tokenizer ──

enum class TokKind {
    Ident, Number, Star, Semi, LBrace, RBrace,
    LBracket, RBracket, LParen, RParen, Comma, Colon,
    Equals, Hash, Eof, Other
};

struct Token {
    TokKind kind = TokKind::Eof;
    QString text;
    int     line = 0;
};

// Parsed offset comment associated with a line
struct LineOffset {
    int line;
    int offset; // hex offset value
};

struct Tokenizer {
    const QString& src;
    int pos = 0;
    int line = 1;
    QVector<Token> tokens;
    QVector<LineOffset> offsets; // captured // 0xNN comments

    explicit Tokenizer(const QString& s) : src(s) {}

    void tokenize() {
        while (pos < src.size()) {
            skipWhitespace();
            if (pos >= src.size()) break;

            QChar c = src[pos];

            // Line comments
            if (c == '/' && pos + 1 < src.size() && src[pos + 1] == '/') {
                parseLineComment();
                continue;
            }
            // Block comments
            if (c == '/' && pos + 1 < src.size() && src[pos + 1] == '*') {
                parseBlockComment();
                continue;
            }
            // Preprocessor lines - skip entirely
            if (c == '#') {
                skipToEndOfLine();
                continue;
            }
            // Identifiers / keywords
            if (c.isLetter() || c == '_') {
                parseIdent();
                continue;
            }
            // Numbers
            if (c.isDigit()) {
                parseNumber();
                continue;
            }
            // Single-character tokens
            TokKind tk = TokKind::Other;
            switch (c.toLatin1()) {
            case '*': tk = TokKind::Star;     break;
            case ';': tk = TokKind::Semi;     break;
            case '{': tk = TokKind::LBrace;   break;
            case '}': tk = TokKind::RBrace;   break;
            case '[': tk = TokKind::LBracket; break;
            case ']': tk = TokKind::RBracket; break;
            case '(': tk = TokKind::LParen;   break;
            case ')': tk = TokKind::RParen;   break;
            case ',': tk = TokKind::Comma;    break;
            case ':': tk = TokKind::Colon;    break;
            case '=': tk = TokKind::Equals;   break;
            default:  tk = TokKind::Other;    break;
            }
            tokens.append({tk, QString(c), line});
            pos++;
        }
        tokens.append({TokKind::Eof, {}, line});
    }

private:
    void skipWhitespace() {
        while (pos < src.size()) {
            if (src[pos] == '\n') { line++; pos++; }
            else if (src[pos].isSpace()) { pos++; }
            else break;
        }
    }

    void skipToEndOfLine() {
        while (pos < src.size() && src[pos] != '\n') pos++;
    }

    void parseLineComment() {
        int commentLine = line;
        pos += 2; // skip //
        int start = pos;
        while (pos < src.size() && src[pos] != '\n') pos++;
        QString comment = src.mid(start, pos - start).trimmed();

        // Capture offset comments like "0x10" or "// 0x10"
        static QRegularExpression offsetRe(QStringLiteral("^(?:->\\s*\\S+\\s+)?0x([0-9A-Fa-f]+)$"));
        // Also handle "-> TypeName 0x1A" style
        static QRegularExpression offsetRe2(QStringLiteral("0x([0-9A-Fa-f]+)"));
        auto m = offsetRe.match(comment);
        if (!m.hasMatch()) {
            // Try simpler: just look for "0xHEX" at end of comment
            // Handles "// 0x10", "// -> Material* 0x10", etc.
            static QRegularExpression endHexRe(QStringLiteral("\\b0x([0-9A-Fa-f]+)\\s*$"));
            m = endHexRe.match(comment);
        }
        if (m.hasMatch()) {
            bool ok;
            int val = m.captured(1).toInt(&ok, 16);
            if (ok) {
                offsets.append({commentLine, val});
            }
        }
    }

    void parseBlockComment() {
        pos += 2; // skip /*
        while (pos + 1 < src.size()) {
            if (src[pos] == '\n') line++;
            if (src[pos] == '*' && src[pos + 1] == '/') { pos += 2; return; }
            pos++;
        }
        pos = src.size(); // unterminated
    }

    void parseIdent() {
        int start = pos;
        while (pos < src.size() && (src[pos].isLetterOrNumber() || src[pos] == '_')) pos++;
        tokens.append({TokKind::Ident, src.mid(start, pos - start), line});
    }

    void parseNumber() {
        int start = pos;
        if (src[pos] == '0' && pos + 1 < src.size() &&
            (src[pos + 1] == 'x' || src[pos + 1] == 'X')) {
            pos += 2;
            while (pos < src.size() && (src[pos].isDigit() ||
                   (src[pos] >= 'a' && src[pos] <= 'f') ||
                   (src[pos] >= 'A' && src[pos] <= 'F'))) pos++;
        } else {
            while (pos < src.size() && src[pos].isDigit()) pos++;
        }
        // Skip integer suffixes (U, L, LL, ULL, etc.)
        while (pos < src.size() && (src[pos] == 'u' || src[pos] == 'U' ||
                                     src[pos] == 'l' || src[pos] == 'L')) pos++;
        tokens.append({TokKind::Number, src.mid(start, pos - start), line});
    }
};

// ── Parser ──

struct ParsedField {
    QString typeName;      // base type name (resolved through multi-word merge)
    QString name;
    bool    isPointer = false;
    int     pointerDepth = 0;  // number of * levels
    QVector<int> arraySizes;   // [4], [4][4] etc.
    int     commentOffset = -1; // from // 0xNN (-1 = none)
    int     bitfieldWidth = -1; // -1 = not a bitfield
    QString pointerTarget;     // for Type* -> the type name
    bool    isUnion = false;               // union container
    QVector<ParsedField> unionMembers;     // children of union
};

struct ParsedStruct {
    QString name;
    QString keyword; // "struct", "class", or "enum"
    QVector<ParsedField> fields;
    int declaredSize = -1; // from static_assert
    QVector<QPair<QString, int64_t>> enumValues; // for keyword="enum"
};

struct PendingRef {
    uint64_t nodeId;
    QString  className;
};

// Multi-word type prefix keywords
static bool isTypeModifier(const QString& s) {
    return s == QStringLiteral("unsigned") ||
           s == QStringLiteral("signed") ||
           s == QStringLiteral("long") ||
           s == QStringLiteral("short");
}

static bool isQualifier(const QString& s) {
    return s == QStringLiteral("const") ||
           s == QStringLiteral("volatile") ||
           s == QStringLiteral("mutable") ||
           s == QStringLiteral("struct") ||
           s == QStringLiteral("class") ||
           s == QStringLiteral("enum");
}

struct Parser {
    const QVector<Token>& tokens;
    const QVector<LineOffset>& lineOffsets;
    int cur = 0;

    QVector<ParsedStruct> structs;
    QSet<QString> forwardDecls;
    QHash<QString, QString> typedefs; // alias -> real type
    QHash<QString, int> sizeAsserts;  // struct name -> declared size

    explicit Parser(const QVector<Token>& t, const QVector<LineOffset>& lo)
        : tokens(t), lineOffsets(lo) {}

    const Token& peek(int ahead = 0) const {
        int i = cur + ahead;
        return (i < tokens.size()) ? tokens[i] : tokens.back();
    }

    Token advance() {
        if (cur < tokens.size() - 1) return tokens[cur++];
        return tokens.back();
    }

    bool check(TokKind k) const { return peek().kind == k; }
    bool checkIdent(const QString& s) const { return peek().kind == TokKind::Ident && peek().text == s; }

    bool match(TokKind k) {
        if (check(k)) { advance(); return true; }
        return false;
    }

    bool matchIdent(const QString& s) {
        if (checkIdent(s)) { advance(); return true; }
        return false;
    }

    void skipToSemiOrBrace() {
        int depth = 0;
        while (peek().kind != TokKind::Eof) {
            if (peek().kind == TokKind::LBrace) depth++;
            else if (peek().kind == TokKind::RBrace) {
                if (depth == 0) break;
                depth--;
            }
            else if (peek().kind == TokKind::Semi && depth == 0) {
                advance(); return;
            }
            advance();
        }
    }

    // ── Top-level parse ──

    void parse() {
        while (peek().kind != TokKind::Eof) {
            if (checkIdent("struct") || checkIdent("class")) {
                parseStructOrForward();
            } else if (checkIdent("static_assert")) {
                parseStaticAssert();
            } else if (checkIdent("typedef")) {
                parseTypedef();
            } else if (checkIdent("enum")) {
                parseEnumDef();
            } else if (peek().kind == TokKind::Hash) {
                // preprocessor (shouldn't reach here if tokenizer skipped them)
                advance();
                while (peek().kind != TokKind::Eof && peek().kind != TokKind::Semi) advance();
            } else {
                advance(); // skip unknown
            }
        }
    }

    void parseStructOrForward() {
        QString keyword = advance().text; // "struct" or "class"

        // Anonymous struct: struct { ... }
        if (check(TokKind::LBrace)) {
            // Skip anonymous struct at top level
            skipToSemiOrBrace();
            if (check(TokKind::RBrace)) { advance(); match(TokKind::Semi); }
            return;
        }

        if (!check(TokKind::Ident)) { skipToSemiOrBrace(); return; }
        QString name = advance().text;

        // Check for inheritance: struct Foo : public Bar {
        // Just skip the inheritance clause
        if (check(TokKind::Colon)) {
            advance(); // ':'
            while (peek().kind != TokKind::LBrace && peek().kind != TokKind::Semi &&
                   peek().kind != TokKind::Eof) {
                advance();
            }
        }

        // Forward declaration: struct Foo;
        if (check(TokKind::Semi)) {
            advance();
            forwardDecls.insert(name);
            return;
        }

        if (!match(TokKind::LBrace)) { skipToSemiOrBrace(); return; }

        ParsedStruct ps;
        ps.name = name;
        ps.keyword = keyword;

        parseStructBody(ps);

        if (!match(TokKind::RBrace)) { skipToSemiOrBrace(); return; }
        match(TokKind::Semi);

        structs.append(ps);
    }

    void parseStructBody(ParsedStruct& ps) {
        while (peek().kind != TokKind::RBrace && peek().kind != TokKind::Eof) {
            // Nested struct definition
            if (checkIdent("struct") || checkIdent("class")) {
                if (peek(1).kind == TokKind::Ident && peek(2).kind == TokKind::LBrace) {
                    // Nested named struct: parse as a top-level struct, then treat as embedded field
                    parseStructOrForward();
                    continue;
                }
                if (peek(1).kind == TokKind::LBrace) {
                    // Anonymous nested struct { ... } fieldName;
                    advance(); // skip "struct"
                    advance(); // skip "{"
                    // Skip body
                    int depth = 1;
                    while (peek().kind != TokKind::Eof && depth > 0) {
                        if (peek().kind == TokKind::LBrace) depth++;
                        else if (peek().kind == TokKind::RBrace) depth--;
                        if (depth > 0) advance();
                    }
                    if (check(TokKind::RBrace)) advance();
                    // field name
                    if (check(TokKind::Ident)) advance();
                    match(TokKind::Semi);
                    continue;
                }
                // Might be "struct TypeName fieldName;" - fall through to field parsing
            }

            // Union: create container with all members
            if (checkIdent("union")) {
                parseUnion(ps);
                continue;
            }

            // Enum definition inside struct
            if (checkIdent("enum")) {
                parseEnumDef();
                continue;
            }

            // Static assert inside struct
            if (checkIdent("static_assert")) {
                parseStaticAssert();
                continue;
            }

            // Try to parse as a field
            ParsedField field;
            if (parseField(field)) {
                ps.fields.append(field);
            } else {
                advance(); // skip unrecognized token
            }
        }
    }

    void parseUnion(ParsedStruct& ps) {
        advance(); // skip "union"

        // Optional union tag name (before {)
        if (check(TokKind::Ident) && peek(1).kind == TokKind::LBrace) {
            advance(); // skip union tag name
        }

        if (!match(TokKind::LBrace)) { skipToSemiOrBrace(); return; }

        // Parse ALL members of the union
        ParsedField unionField;
        unionField.isUnion = true;

        while (peek().kind != TokKind::RBrace && peek().kind != TokKind::Eof) {
            // Handle nested unions inside this union
            if (checkIdent("union")) {
                // Recurse: create a sub-union ParsedStruct temporarily,
                // then steal its fields as a nested union member
                ParsedStruct tmp;
                parseUnion(tmp);
                for (auto& f : tmp.fields)
                    unionField.unionMembers.append(f);
                continue;
            }

            // Handle anonymous struct inside union: struct { ... };
            if ((checkIdent("struct") || checkIdent("class")) && peek(1).kind == TokKind::LBrace) {
                advance(); // skip "struct"
                advance(); // skip "{"
                int depth = 1;
                while (peek().kind != TokKind::Eof && depth > 0) {
                    if (peek().kind == TokKind::LBrace) depth++;
                    else if (peek().kind == TokKind::RBrace) depth--;
                    if (depth > 0) advance();
                }
                if (check(TokKind::RBrace)) advance();
                if (check(TokKind::Ident)) advance(); // optional field name
                match(TokKind::Semi);
                continue;
            }

            // Handle nested named struct definition inside union
            if ((checkIdent("struct") || checkIdent("class")) &&
                peek(1).kind == TokKind::Ident && peek(2).kind == TokKind::LBrace) {
                parseStructOrForward();
                continue;
            }

            ParsedField field;
            if (parseField(field)) {
                unionField.unionMembers.append(field);
            } else {
                advance();
            }
        }
        match(TokKind::RBrace);

        // Optional field name after union close: union { ... } u3;
        if (check(TokKind::Ident)) {
            unionField.name = advance().text;
        }
        match(TokKind::Semi);

        // Determine offset from first member with a known offset
        for (const auto& m : unionField.unionMembers) {
            if (m.commentOffset >= 0) {
                unionField.commentOffset = m.commentOffset;
                break;
            }
        }

        ps.fields.append(unionField);
    }

    bool parseField(ParsedField& field) {
        int startPos = cur;

        // Skip qualifiers
        while (isQualifier(peek().text)) advance();

        // Parse type
        QString typeName = parseTypeName();
        if (typeName.isEmpty()) { cur = startPos; return false; }

        // Resolve typedef
        while (typedefs.contains(typeName))
            typeName = typedefs[typeName];

        // Pointer stars
        bool isPointer = false;
        int ptrDepth = 0;
        while (match(TokKind::Star)) {
            isPointer = true;
            ptrDepth++;
        }

        // Skip const after pointer
        while (checkIdent("const") || checkIdent("volatile")) advance();

        // More pointer stars (const Type * const * name)
        while (match(TokKind::Star)) {
            isPointer = true;
            ptrDepth++;
        }

        // Field name
        if (!check(TokKind::Ident)) { cur = startPos; return false; }
        field.name = advance().text;

        // Array sizes: [N], [N][M], etc.
        while (check(TokKind::LBracket)) {
            advance(); // [
            if (check(TokKind::Number)) {
                bool ok;
                QString numText = peek().text;
                int val;
                if (numText.startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
                    val = numText.mid(2).toInt(&ok, 16);
                else
                    val = numText.toInt(&ok);
                if (ok) field.arraySizes.append(val);
                advance();
            } else if (check(TokKind::RBracket)) {
                field.arraySizes.append(0); // unsized array
            }
            match(TokKind::RBracket);
        }

        // Bitfield: Type name : width
        if (check(TokKind::Colon)) {
            advance();
            if (check(TokKind::Number)) {
                bool ok;
                field.bitfieldWidth = peek().text.toInt(&ok);
                advance();
            }
        }

        // Expect semicolon
        if (!match(TokKind::Semi)) { cur = startPos; return false; }

        // Check if next token line has an offset comment
        // We associate offset comments with the field's line
        int fieldLine = tokens[startPos].line;
        for (const auto& lo : lineOffsets) {
            if (lo.line == fieldLine) {
                field.commentOffset = lo.offset;
                break;
            }
        }

        field.typeName = typeName;
        field.isPointer = isPointer;
        field.pointerDepth = ptrDepth;
        if (isPointer) field.pointerTarget = typeName;

        return true;
    }

    QString parseTypeName() {
        if (peek().kind != TokKind::Ident) return {};

        QString first = peek().text;

        // Handle "struct/class TypeName" as a type reference
        if (first == QStringLiteral("struct") || first == QStringLiteral("class") ||
            first == QStringLiteral("enum")) {
            advance(); // skip struct/class/enum
            if (check(TokKind::Ident))
                return advance().text;
            return {};
        }

        // Multi-word type building: unsigned, signed, long, short
        if (isTypeModifier(first)) {
            advance();
            QStringList parts;
            parts << first;

            // Collect further modifiers and the base type
            while (check(TokKind::Ident) && (isTypeModifier(peek().text) || peek().text == QStringLiteral("int") ||
                   peek().text == QStringLiteral("char") || peek().text == QStringLiteral("long"))) {
                parts << advance().text;
            }
            return parts.join(' ');
        }

        // Simple identifier type
        advance();
        return first;
    }

    void parseStaticAssert() {
        advance(); // "static_assert"
        if (!match(TokKind::LParen)) { skipToSemiOrBrace(); return; }

        // Parse: sizeof(X) == 0xNN
        // Skip to find sizeof
        int depth = 1;
        QString structName;
        int sizeVal = -1;

        // Simple state machine to extract sizeof(StructName) and size value
        while (depth > 0 && peek().kind != TokKind::Eof) {
            if (checkIdent("sizeof")) {
                advance();
                if (match(TokKind::LParen)) {
                    if (check(TokKind::Ident))
                        structName = advance().text;
                    match(TokKind::RParen);
                }
            } else if (peek().kind == TokKind::Number && sizeVal < 0) {
                bool ok;
                QString numText = peek().text;
                if (numText.startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
                    sizeVal = numText.mid(2).toInt(&ok, 16);
                else
                    sizeVal = numText.toInt(&ok);
                if (!ok) sizeVal = -1;
                advance();
            } else if (peek().kind == TokKind::LParen) {
                depth++;
                advance();
            } else if (peek().kind == TokKind::RParen) {
                depth--;
                if (depth > 0) advance();
            } else {
                advance();
            }
        }
        if (depth == 0) advance(); // consume closing ')'
        match(TokKind::Semi);

        if (!structName.isEmpty() && sizeVal > 0) {
            sizeAsserts[structName] = sizeVal;
        }
    }

    void parseTypedef() {
        advance(); // "typedef"

        // typedef struct { ... } Name;
        if (checkIdent("struct") || checkIdent("class")) {
            QString keyword = peek().text;
            if (peek(1).kind == TokKind::LBrace ||
                (peek(1).kind == TokKind::Ident && peek(2).kind == TokKind::LBrace)) {
                // Full struct typedef - parse as struct, then register alias
                parseStructOrForward();
                return;
            }
            // typedef struct ExistingName AliasName;
            advance(); // skip struct/class
            if (check(TokKind::Ident)) {
                QString existingName = advance().text;
                // Pointer stars
                while (match(TokKind::Star)) {}
                if (check(TokKind::Ident)) {
                    QString aliasName = advance().text;
                    typedefs[aliasName] = existingName;
                }
            }
            match(TokKind::Semi);
            return;
        }

        // typedef BaseType AliasName;
        QString baseType = parseTypeName();
        if (baseType.isEmpty()) { skipToSemiOrBrace(); return; }
        while (match(TokKind::Star)) {} // pointer typedefs
        if (check(TokKind::Ident)) {
            QString alias = advance().text;
            typedefs[alias] = baseType;
        }
        match(TokKind::Semi);
    }

    void parseEnumDef() {
        advance(); // skip "enum"

        // Optional "class" or "struct" (enum class)
        if (checkIdent("class") || checkIdent("struct"))
            advance();

        // Optional name
        QString name;
        if (check(TokKind::Ident) && peek(1).kind != TokKind::Semi) {
            // Could be: enum Name { ... }; or enum Name : Type { ... };
            // But NOT: enum Name; (forward decl) or enum Name field; (field usage)
            if (peek(1).kind == TokKind::LBrace || peek(1).kind == TokKind::Colon) {
                name = advance().text;
            } else {
                // Not an enum definition — revert. This might be a field like "enum Foo bar;"
                return;
            }
        }

        // Optional underlying type: enum Name : uint8_t { ... }
        if (check(TokKind::Colon)) {
            advance();
            parseTypeName(); // skip underlying type
        }

        // Forward declaration: enum Name;
        if (check(TokKind::Semi)) {
            advance();
            return;
        }

        if (!match(TokKind::LBrace)) { skipToSemiOrBrace(); return; }

        ParsedStruct ps;
        ps.name = name;
        ps.keyword = QStringLiteral("enum");

        // Parse enum members: Name [= Value], ...
        int64_t nextValue = 0;
        while (peek().kind != TokKind::RBrace && peek().kind != TokKind::Eof) {
            if (!check(TokKind::Ident)) { advance(); continue; }
            QString memberName = advance().text;
            int64_t memberValue = nextValue;

            if (check(TokKind::Equals)) {
                advance();
                // Parse value: could be number, negative number, or expression
                bool negative = false;
                if (peek().kind == TokKind::Other && peek().text == QStringLiteral("-")) {
                    negative = true;
                    advance();
                }
                if (check(TokKind::Number)) {
                    bool ok;
                    QString numText = peek().text;
                    if (numText.startsWith(QStringLiteral("0x"), Qt::CaseInsensitive))
                        memberValue = numText.mid(2).toLongLong(&ok, 16);
                    else
                        memberValue = numText.toLongLong(&ok);
                    if (negative) memberValue = -memberValue;
                    advance();
                } else {
                    // Complex expression — skip to comma or brace
                    while (peek().kind != TokKind::Comma &&
                           peek().kind != TokKind::RBrace &&
                           peek().kind != TokKind::Eof)
                        advance();
                }
            }

            ps.enumValues.append({memberName, memberValue});
            nextValue = memberValue + 1;

            // Skip comma between members
            match(TokKind::Comma);
        }
        match(TokKind::RBrace);
        match(TokKind::Semi);

        if (!ps.name.isEmpty())
            structs.append(ps);
    }
};

// ── Padding field detection ──

static bool isPaddingName(const QString& name) {
    return name.startsWith(QStringLiteral("_pad"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("pad_"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("__pad"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("padding"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("_padding"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("__padding"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("_reserved"), Qt::CaseInsensitive) ||
           name.startsWith(QStringLiteral("reserved"), Qt::CaseInsensitive);
}

// Expand padding into best-fit hex nodes (same approach as import_reclass_xml.cpp)
static void emitHexPadding(NodeTree& tree, uint64_t parentId, int offset, int size) {
    if (size <= 0) return;
    NodeKind hexKind;
    int hexSize;
    if (size >= 8 && size % 8 == 0) {
        hexKind = NodeKind::Hex64; hexSize = 8;
    } else if (size >= 4 && size % 4 == 0) {
        hexKind = NodeKind::Hex32; hexSize = 4;
    } else if (size >= 2 && size % 2 == 0) {
        hexKind = NodeKind::Hex16; hexSize = 2;
    } else {
        hexKind = NodeKind::Hex8; hexSize = 1;
    }
    int count = size / hexSize;
    for (int i = 0; i < count; i++) {
        Node n;
        n.kind = hexKind;
        n.parentId = parentId;
        n.offset = offset + i * hexSize;
        tree.addNode(n);
    }
}

// ── Bitfield grouping: emit a single hex node covering consecutive bitfields ──

static void emitBitfieldGroup(NodeTree& tree, uint64_t parentId, int offset, int totalBits) {
    int bytes = (totalBits + 7) / 8;
    // Round up to nearest power-of-2 hex node
    NodeKind hexKind;
    if (bytes <= 1)      hexKind = NodeKind::Hex8;
    else if (bytes <= 2) hexKind = NodeKind::Hex16;
    else if (bytes <= 4) hexKind = NodeKind::Hex32;
    else                 hexKind = NodeKind::Hex64;
    Node n;
    n.kind = hexKind;
    n.parentId = parentId;
    n.offset = offset;
    tree.addNode(n);
}

// ── NodeTree builder: recursive field emitter ──

struct BuildContext {
    NodeTree& tree;
    const QHash<QString, TypeInfo>& typeTable;
    QHash<QString, uint64_t>& classIds;
    QVector<PendingRef>& pendingRefs;
    bool useCommentOffsets;
    QSet<QString> enumNames;  // enum type names (emit as UInt32 + refId)
};

static void buildFields(BuildContext& ctx, uint64_t parentId, int baseOffset,
                        const QVector<ParsedField>& fields) {
    int computedOffset = 0;

    for (int fi = 0; fi < fields.size(); fi++) {
        const auto& field = fields[fi];

        // Bitfield group: consume consecutive bitfields, emit single hex node
        if (field.bitfieldWidth >= 0) {
            int groupOffset;
            if (ctx.useCommentOffsets && field.commentOffset >= 0)
                groupOffset = field.commentOffset - baseOffset;
            else
                groupOffset = computedOffset;
            int totalBits = 0;
            while (fi < fields.size() && fields[fi].bitfieldWidth >= 0) {
                totalBits += fields[fi].bitfieldWidth;
                fi++;
            }
            fi--; // compensate for outer loop increment
            if (totalBits > 0)
                emitBitfieldGroup(ctx.tree, parentId, groupOffset, totalBits);
            int bytes = (totalBits + 7) / 8;
            int nodeSize = (bytes <= 1) ? 1 : (bytes <= 2) ? 2 : (bytes <= 4) ? 4 : 8;
            computedOffset = groupOffset + nodeSize;
            continue;
        }

        // Union container field
        if (field.isUnion) {
            int unionOffset;
            if (ctx.useCommentOffsets && field.commentOffset >= 0)
                unionOffset = field.commentOffset - baseOffset;
            else
                unionOffset = computedOffset;

            Node unionNode;
            unionNode.kind = NodeKind::Struct;
            unionNode.classKeyword = QStringLiteral("union");
            unionNode.name = field.name;
            unionNode.parentId = parentId;
            unionNode.offset = unionOffset;
            unionNode.collapsed = true;

            int unionIdx = ctx.tree.addNode(unionNode);
            uint64_t unionId = ctx.tree.nodes[unionIdx].id;

            // Build each union member independently so each starts at offset 0
            int absUnionOffset = baseOffset + unionOffset;
            for (const auto& member : field.unionMembers) {
                QVector<ParsedField> single;
                single.append(member);
                buildFields(ctx, unionId, absUnionOffset, single);
            }

            // Advance computed offset past the union (max member size)
            int unionSpan = ctx.tree.structSpan(unionId);
            computedOffset = unionOffset + (unionSpan > 0 ? unionSpan : 0);
            continue;
        }

        int fieldOffset;
        if (ctx.useCommentOffsets && field.commentOffset >= 0)
            fieldOffset = field.commentOffset - baseOffset;
        else
            fieldOffset = computedOffset;

        // Resolve type
        auto typeIt = ctx.typeTable.find(field.typeName);
        bool knownType = typeIt != ctx.typeTable.end();

        // Pointer field
        if (field.isPointer) {
            Node n;
            n.kind = NodeKind::Pointer64;
            n.name = field.name;
            n.parentId = parentId;
            n.offset = fieldOffset;
            n.collapsed = true;

            int nodeIdx = ctx.tree.addNode(n);
            uint64_t nodeId = ctx.tree.nodes[nodeIdx].id;

            if (!field.pointerTarget.isEmpty() &&
                field.pointerTarget != QStringLiteral("void")) {
                ctx.pendingRefs.append({nodeId, field.pointerTarget});
            }

            computedOffset = fieldOffset + 8;
            continue;
        }

        // Enum-typed field: emit as UInt32 with refId to enum definition
        if (!knownType && ctx.enumNames.contains(field.typeName)) {
            int elemSize = 4;
            NodeKind elemKind = NodeKind::UInt32;
            if (!field.arraySizes.isEmpty()) {
                int totalElements = 1;
                for (int dim : field.arraySizes) totalElements *= (dim > 0 ? dim : 1);
                Node n;
                n.kind = NodeKind::Array;
                n.name = field.name;
                n.parentId = parentId;
                n.offset = fieldOffset;
                n.arrayLen = totalElements;
                n.elementKind = elemKind;
                ctx.tree.addNode(n);
                computedOffset = fieldOffset + totalElements * elemSize;
            } else {
                Node n;
                n.kind = elemKind;
                n.name = field.name;
                n.parentId = parentId;
                n.offset = fieldOffset;
                int nodeIdx = ctx.tree.addNode(n);
                uint64_t nodeId = ctx.tree.nodes[nodeIdx].id;
                ctx.pendingRefs.append({nodeId, field.typeName});
                computedOffset = fieldOffset + elemSize;
            }
            continue;
        }

        // Determine base type info
        NodeKind baseKind = NodeKind::Hex8;
        int baseSize = 1;
        bool isStructType = false;

        if (knownType) {
            baseKind = typeIt->kind;
            baseSize = typeIt->size;
        } else {
            isStructType = true;
        }

        // Padding fields
        if (isPaddingName(field.name) && !field.arraySizes.isEmpty()) {
            int totalSize = baseSize;
            for (int dim : field.arraySizes) totalSize *= (dim > 0 ? dim : 1);
            emitHexPadding(ctx.tree, parentId, fieldOffset, totalSize);
            computedOffset = fieldOffset + totalSize;
            continue;
        }

        // Array fields
        if (!field.arraySizes.isEmpty() && !isStructType) {
            int firstDim = field.arraySizes.value(0, 1);
            if (firstDim <= 0) firstDim = 1;

            if (baseKind == NodeKind::Int8 && field.arraySizes.size() == 1 &&
                field.typeName == QStringLiteral("char")) {
                Node n;
                n.kind = NodeKind::UTF8;
                n.name = field.name;
                n.parentId = parentId;
                n.offset = fieldOffset;
                n.strLen = firstDim;
                ctx.tree.addNode(n);
                computedOffset = fieldOffset + firstDim;
                continue;
            }

            if (baseKind == NodeKind::UInt16 && field.arraySizes.size() == 1 &&
                (field.typeName == QStringLiteral("wchar_t") || field.typeName == QStringLiteral("WCHAR"))) {
                Node n;
                n.kind = NodeKind::UTF16;
                n.name = field.name;
                n.parentId = parentId;
                n.offset = fieldOffset;
                n.strLen = firstDim;
                ctx.tree.addNode(n);
                computedOffset = fieldOffset + firstDim * 2;
                continue;
            }

            if (baseKind == NodeKind::Float && field.arraySizes.size() == 1) {
                if (firstDim == 2) {
                    Node n; n.kind = NodeKind::Vec2; n.name = field.name;
                    n.parentId = parentId; n.offset = fieldOffset;
                    ctx.tree.addNode(n); computedOffset = fieldOffset + 8; continue;
                }
                if (firstDim == 3) {
                    Node n; n.kind = NodeKind::Vec3; n.name = field.name;
                    n.parentId = parentId; n.offset = fieldOffset;
                    ctx.tree.addNode(n); computedOffset = fieldOffset + 12; continue;
                }
                if (firstDim == 4) {
                    Node n; n.kind = NodeKind::Vec4; n.name = field.name;
                    n.parentId = parentId; n.offset = fieldOffset;
                    ctx.tree.addNode(n); computedOffset = fieldOffset + 16; continue;
                }
            }

            if (baseKind == NodeKind::Float && field.arraySizes.size() == 2 &&
                field.arraySizes[0] == 4 && field.arraySizes[1] == 4) {
                Node n; n.kind = NodeKind::Mat4x4; n.name = field.name;
                n.parentId = parentId; n.offset = fieldOffset;
                ctx.tree.addNode(n); computedOffset = fieldOffset + 64; continue;
            }

            int totalElements = 1;
            for (int dim : field.arraySizes) totalElements *= (dim > 0 ? dim : 1);

            Node n;
            n.kind = NodeKind::Array;
            n.name = field.name;
            n.parentId = parentId;
            n.offset = fieldOffset;
            n.arrayLen = totalElements;
            n.elementKind = baseKind;
            ctx.tree.addNode(n);
            computedOffset = fieldOffset + totalElements * baseSize;
            continue;
        }

        // Struct-type field
        if (isStructType) {
            if (!field.arraySizes.isEmpty()) {
                int totalElements = 1;
                for (int dim : field.arraySizes) totalElements *= (dim > 0 ? dim : 1);

                Node n;
                n.kind = NodeKind::Array;
                n.name = field.name;
                n.parentId = parentId;
                n.offset = fieldOffset;
                n.arrayLen = totalElements;
                n.elementKind = NodeKind::Struct;
                n.structTypeName = field.typeName;
                n.collapsed = true;

                int nodeIdx = ctx.tree.addNode(n);
                uint64_t nodeId = ctx.tree.nodes[nodeIdx].id;
                ctx.pendingRefs.append({nodeId, field.typeName});
                continue;
            }

            Node n;
            n.kind = NodeKind::Struct;
            n.name = field.name;
            n.parentId = parentId;
            n.offset = fieldOffset;
            n.structTypeName = field.typeName;
            n.collapsed = true;

            int nodeIdx = ctx.tree.addNode(n);
            uint64_t nodeId = ctx.tree.nodes[nodeIdx].id;
            ctx.pendingRefs.append({nodeId, field.typeName});
            continue;
        }

        // Simple primitive field
        Node n;
        n.kind = baseKind;
        n.name = field.name;
        n.parentId = parentId;
        n.offset = fieldOffset;
        ctx.tree.addNode(n);
        computedOffset = fieldOffset + baseSize;
    }
}

// ── Check if any field (or union member) has a comment offset ──

static bool hasAnyCommentOffset(const QVector<ParsedField>& fields) {
    for (const auto& f : fields) {
        if (f.commentOffset >= 0) return true;
        if (f.isUnion && hasAnyCommentOffset(f.unionMembers)) return true;
    }
    return false;
}

// ── NodeTree builder ──

NodeTree importFromSource(const QString& sourceCode, QString* errorMsg) {
    if (sourceCode.trimmed().isEmpty()) {
        if (errorMsg) *errorMsg = QStringLiteral("Empty source code");
        return {};
    }

    // Tokenize
    Tokenizer tokenizer(sourceCode);
    tokenizer.tokenize();

    // Parse
    Parser parser(tokenizer.tokens, tokenizer.offsets);
    parser.parse();

    if (parser.structs.isEmpty()) {
        if (errorMsg) *errorMsg = QStringLiteral("No struct or enum definitions found");
        return {};
    }

    // Build type table
    QHash<QString, TypeInfo> typeTable = buildTypeTable();

    // Register typedefs into type table
    for (auto it = parser.typedefs.begin(); it != parser.typedefs.end(); ++it) {
        if (typeTable.contains(it.value())) {
            typeTable[it.key()] = typeTable[it.value()];
        }
    }

    NodeTree tree;
    tree.baseAddress = 0x00400000;

    QHash<QString, uint64_t> classIds;
    QVector<PendingRef> pendingRefs;

    // Determine offset mode: if ANY field in ANY struct has a comment offset, use comment mode
    bool useCommentOffsets = false;
    for (const auto& ps : parser.structs) {
        if (hasAnyCommentOffset(ps.fields)) { useCommentOffsets = true; break; }
    }

    // Collect enum type names for field-type detection
    QSet<QString> enumNames;
    for (const auto& ps : parser.structs) {
        if (ps.keyword == QStringLiteral("enum") && !ps.name.isEmpty())
            enumNames.insert(ps.name);
    }

    BuildContext ctx{tree, typeTable, classIds, pendingRefs, useCommentOffsets, enumNames};

    // Build nodes for each struct/enum
    for (const auto& ps : parser.structs) {
        Node structNode;
        structNode.kind = NodeKind::Struct;
        structNode.name = ps.name;
        structNode.structTypeName = ps.name;
        structNode.classKeyword = ps.keyword;
        structNode.parentId = 0;
        structNode.offset = 0;
        structNode.collapsed = true;

        // Enum: store members directly on the node, no child fields
        if (ps.keyword == QStringLiteral("enum")) {
            structNode.enumMembers = ps.enumValues;
            int idx = tree.addNode(structNode);
            uint64_t nodeId = tree.nodes[idx].id;
            if (!ps.name.isEmpty())
                classIds[ps.name] = nodeId;
            continue;
        }

        int structIdx = tree.addNode(structNode);
        uint64_t structId = tree.nodes[structIdx].id;
        classIds[ps.name] = structId;

        buildFields(ctx, structId, 0, ps.fields);

        // Apply static_assert size: add tail padding if needed
        auto sizeIt = parser.sizeAsserts.find(ps.name);
        if (sizeIt != parser.sizeAsserts.end()) {
            int declaredSize = sizeIt.value();
            int currentSpan = tree.structSpan(structId);
            if (declaredSize > currentSpan) {
                emitHexPadding(tree, structId, currentSpan, declaredSize - currentSpan);
            }
        }
    }

    if (tree.nodes.isEmpty()) {
        if (errorMsg) *errorMsg = QStringLiteral("No nodes generated from source");
        return {};
    }

    // Resolve deferred pointer/struct references
    for (const auto& ref : pendingRefs) {
        int nodeIdx = tree.indexOfId(ref.nodeId);
        if (nodeIdx < 0) continue;

        auto it = classIds.find(ref.className);
        if (it != classIds.end()) {
            tree.nodes[nodeIdx].refId = it.value();
        }
    }

    return tree;
}

} // namespace rcx

```

`src/imports/import_source.h`:

```h
#pragma once
#include "core.h"

namespace rcx {

// Import C/C++ struct definitions from source code into a NodeTree.
// Supports two modes (auto-detected):
//   1. With comment offsets (// 0xNN) - trusts the offset values
//   2. Without comment offsets - computes offsets from type sizes
// Returns an empty NodeTree on failure; populates errorMsg if non-null.
NodeTree importFromSource(const QString& sourceCode, QString* errorMsg = nullptr);

} // namespace rcx

```

`src/iplugin.h`:

```h
#pragma once
#include <QString>
#include <QIcon>
#include <memory>
#include <string>

#ifdef _WIN32
    #define RCX_PLUGIN_EXPORT __declspec(dllexport)
#else
    #define RCX_PLUGIN_EXPORT __attribute__((visibility("default")))
#endif

// Forward declaration
namespace rcx { class Provider; }

/**
 * Plugin interface for Reclass
 *
 * Plugins are loaded from the "Plugins" folder as shared libraries.
 * Each plugin must export a C function: extern "C" RCX_PLUGIN_EXPORT IPlugin* CreatePlugin();
 */
class IPlugin {
public:
    virtual ~IPlugin() = default;
    
    // Plugin metadata
    virtual std::string Name() const = 0;
    virtual std::string Version() const = 0;
    virtual std::string Author() const = 0;
    virtual std::string Description() const = 0;
    virtual QIcon       Icon() const { return QIcon(); }
    
    // Plugin type - determines what functionality it provides
    enum k_EType
    {
        // Provides memory/data sources
        ProviderPlugin,

        // In the future we could make plugins that change the main UI
        // for loading different data sources
    };
    virtual k_EType     Type() const = 0;

    // Plugin load type - determines whether and when the plugin is loaded
    // by the PluginManager
    enum k_ELoadType
    {
        // Plugin is automatically loaded on startup
        k_ELoadTypeAuto,

        // Plugin must be loaded manually via 'Manage Plugins'
        k_ELoadTypeManual,
    };
    virtual k_ELoadType LoadType() const = 0;
};

// Forward declarations
class QWidget;
class QTableWidget;

/**
 * Process information structure for custom process lists
 */
struct PluginProcessInfo {
    uint32_t pid;
    QString name;
    QString path;
    QIcon icon;
    
    PluginProcessInfo() : pid(0) {}
    PluginProcessInfo(uint32_t p, const QString& n, const QString& pth = QString(), const QIcon& i = QIcon())
        : pid(p), name(n), path(pth), icon(i) {}
};

/**
 * Provider plugin interface
 * 
 * Plugins that implement this interface can create Provider instances
 * for reading/writing memory from various sources (processes, files, network, etc.)
 */
class IProviderPlugin : public IPlugin {
public:
    k_EType Type() const override { return ProviderPlugin; }
    
    /**
     * Check if this plugin can create a provider for the given target
     * @param target - Target identifier (e.g., PID for process, path for file)
     * @return true if this plugin can handle the target
     */
    virtual bool canHandle(const QString& target) const = 0;
    
    /**
     * Create a provider instance
     * @param target - Target identifier
     * @param errorMsg - Output parameter for error message if creation fails
     * @return Provider instance, or nullptr on failure
     */
    virtual std::unique_ptr<rcx::Provider> createProvider(const QString& target, QString* errorMsg = nullptr) = 0;
    
    /**
     * Get initial base address for the provider (optional)
     * Called after createProvider to set the document's base address
     * @param target - Same target identifier passed to createProvider
     * @return Initial base address, or 0 if not applicable
     */
    virtual uint64_t getInitialBaseAddress(const QString& target) const { Q_UNUSED(target); return 0; }
    
    /**
     * Show a dialog to select a target (e.g., process picker)
     * @param parent - Parent widget for dialog
     * @param target - Output parameter for selected target
     * @return true if user selected a target, false if cancelled
     */
    virtual bool selectTarget(QWidget* parent, QString* target) = 0;
    
    /**
     * Get custom process list (optional)
     * 
     * If implemented, this allows the plugin to override the default process enumeration.
     * Return an empty list to use the default process picker.
     * 
     * @return List of processes to display, or empty list to use default
     */
    virtual QVector<PluginProcessInfo> enumerateProcesses() { return QVector<PluginProcessInfo>(); }
    
    /**
     * Check if this plugin wants to override the process list
     * @return true if enumerateProcesses() should be called
     */
    virtual bool providesProcessList() const { return false; }
};

// Plugin factory function signature
typedef IPlugin* (*CreatePluginFunc)();

#define IPLUGIN_IID "com.reclass.IPlugin/1.0"

```

`src/main.cpp`:

```cpp
#include "mainwindow.h"
#include "providerregistry.h"
#include "generator.h"
#include "imports/import_reclass_xml.h"
#include "imports/import_source.h"
#include "imports/export_reclass_xml.h"
#include "imports/import_pdb.h"
#include "imports/import_pdb_dialog.h"
#include "mcp/mcp_bridge.h"
#include <QApplication>
#include <QMainWindow>
#include <QMdiArea>
#include <QMdiSubWindow>
#include <QMenuBar>
#include <QToolBar>
#include <QStatusBar>
#include <QLabel>
#include <QSplitter>
#include <QTabWidget>
#include <QTabBar>
#include <QPointer>
#include <QFileDialog>
#include <QFileInfo>
#include <QMessageBox>
#include <QAction>
#include <QActionGroup>
#include <QMap>
#include <QTimer>
#include <QDir>
#include <QMetaObject>
#include <QFontDatabase>
#include <QPainter>
#include <QSvgRenderer>
#include <QSettings>
#include <QDockWidget>
#include <QTreeView>
#include <QStandardItemModel>
#include <QListWidget>
#include <QPushButton>
#include "workspace_model.h"
#include <QTableWidget>
#include <QHeaderView>
#include <QDialogButtonBox>
#include <QVBoxLayout>
#include <QDialog>
#include <QProgressDialog>
#include <Qsci/qsciscintilla.h>
#include <Qsci/qscilexercpp.h>
#include <QProxyStyle>
#include <QDesktopServices>
#include <QWindow>
#include <QMouseEvent>
#include "themes/thememanager.h"
#include "themes/themeeditor.h"
#include "optionsdialog.h"

#ifdef _WIN32
#include <windows.h>
#include <windowsx.h>
#include <dwmapi.h>
#include <dbghelp.h>
#include <cstdio>

static void setDarkTitleBar(QWidget* widget) {
    // Requires Windows 10 1809+ (build 17763)
    auto hwnd = reinterpret_cast<HWND>(widget->winId());
    BOOL dark = TRUE;
    // Attribute 20 = DWMWA_USE_IMMERSIVE_DARK_MODE (build 18985+), 19 for older
    DWORD attr = 20;
    if (FAILED(DwmSetWindowAttribute(hwnd, attr, &dark, sizeof(dark)))) {
        attr = 19;
        DwmSetWindowAttribute(hwnd, attr, &dark, sizeof(dark));
    }
}

// Guard flag to prevent re-entrant crash inside the handler
static volatile LONG s_inCrashHandler = 0;

static LONG WINAPI crashHandler(EXCEPTION_POINTERS* ep) {
    // Prevent re-entrant crash: if we fault inside the handler, skip the
    // risky dbghelp work and just terminate with what we already printed.
    if (InterlockedCompareExchange(&s_inCrashHandler, 1, 0) != 0) {
        fprintf(stderr, "\n(re-entrant fault inside crash handler — aborting)\n");
        fflush(stderr);
        return EXCEPTION_EXECUTE_HANDLER;
    }

    // Phase 1: always-safe output (no allocations, no complex APIs)
    fprintf(stderr, "\n=== UNHANDLED EXCEPTION ===\n");
    fprintf(stderr, "Code : 0x%08lX\n", ep->ExceptionRecord->ExceptionCode);
    fprintf(stderr, "Addr : %p\n", ep->ExceptionRecord->ExceptionAddress);
#ifdef _M_X64
    fprintf(stderr, "RIP  : 0x%016llx\n", (unsigned long long)ep->ContextRecord->Rip);
    fprintf(stderr, "RSP  : 0x%016llx\n", (unsigned long long)ep->ContextRecord->Rsp);
#else
    fprintf(stderr, "EIP  : 0x%08lx\n", (unsigned long)ep->ContextRecord->Eip);
#endif
    fflush(stderr);

    // Phase 1.5: write a full minidump next to the executable
    {
        // Build dump path: <exe_dir>/reclass_crash_<YYYYMMDD_HHMMSS>.dmp
        wchar_t exePath[MAX_PATH] = {};
        GetModuleFileNameW(NULL, exePath, MAX_PATH);
        // Strip exe filename to get directory
        wchar_t* lastSlash = wcsrchr(exePath, L'\\');
        if (lastSlash) *(lastSlash + 1) = L'\0';

        SYSTEMTIME st;
        GetLocalTime(&st);
        wchar_t dumpPath[MAX_PATH];
        _snwprintf(dumpPath, MAX_PATH,
                   L"%sreclass_crash_%04d%02d%02d_%02d%02d%02d.dmp",
                   exePath, st.wYear, st.wMonth, st.wDay,
                   st.wHour, st.wMinute, st.wSecond);

        HANDLE hFile = CreateFileW(dumpPath, GENERIC_WRITE, 0, NULL,
                                   CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            MINIDUMP_EXCEPTION_INFORMATION mei;
            mei.ThreadId          = GetCurrentThreadId();
            mei.ExceptionPointers = ep;
            mei.ClientPointers    = FALSE;

            // MiniDumpWithFullMemory: captures entire process address space
            // so we can inspect all heap objects, Qt state, node trees, etc.
            BOOL ok = MiniDumpWriteDump(
                GetCurrentProcess(), GetCurrentProcessId(), hFile,
                static_cast<MINIDUMP_TYPE>(MiniDumpWithFullMemory
                                          | MiniDumpWithHandleData
                                          | MiniDumpWithThreadInfo
                                          | MiniDumpWithUnloadedModules),
                &mei, NULL, NULL);
            CloseHandle(hFile);

            if (ok) {
                fprintf(stderr, "Dump : %ls\n", dumpPath);
            } else {
                fprintf(stderr, "Dump : FAILED (error %lu)\n", GetLastError());
            }
        } else {
            fprintf(stderr, "Dump : could not create file (error %lu)\n", GetLastError());
        }
        fflush(stderr);
    }

    // Phase 2: attempt symbol resolution + stack walk
    // Copy context so StackWalk64 can mutate it safely
    CONTEXT ctxCopy = *ep->ContextRecord;

    HANDLE process = GetCurrentProcess();
    HANDLE thread  = GetCurrentThread();
    SymSetOptions(SYMOPT_LOAD_LINES | SYMOPT_UNDNAME | SYMOPT_FAIL_CRITICAL_ERRORS);
    if (!SymInitialize(process, NULL, TRUE)) {
        fprintf(stderr, "\n(SymInitialize failed — no stack trace available)\n");
        fprintf(stderr, "=== END CRASH ===\n");
        fflush(stderr);
        return EXCEPTION_EXECUTE_HANDLER;
    }

    STACKFRAME64 frame = {};
    DWORD machineType;
#ifdef _M_X64
    machineType = IMAGE_FILE_MACHINE_AMD64;
    frame.AddrPC.Offset    = ctxCopy.Rip;
    frame.AddrFrame.Offset = ctxCopy.Rbp;
    frame.AddrStack.Offset = ctxCopy.Rsp;
#else
    machineType = IMAGE_FILE_MACHINE_I386;
    frame.AddrPC.Offset    = ctxCopy.Eip;
    frame.AddrFrame.Offset = ctxCopy.Ebp;
    frame.AddrStack.Offset = ctxCopy.Esp;
#endif
    frame.AddrPC.Mode    = AddrModeFlat;
    frame.AddrFrame.Mode = AddrModeFlat;
    frame.AddrStack.Mode = AddrModeFlat;

    fprintf(stderr, "\nStack trace:\n");
    for (int i = 0; i < 64; i++) {
        if (!StackWalk64(machineType, process, thread, &frame, &ctxCopy,
                         NULL, SymFunctionTableAccess64,
                         SymGetModuleBase64, NULL))
            break;
        if (frame.AddrPC.Offset == 0) break;

        char buf[sizeof(SYMBOL_INFO) + 256];
        SYMBOL_INFO* sym = reinterpret_cast<SYMBOL_INFO*>(buf);
        sym->SizeOfStruct = sizeof(SYMBOL_INFO);
        sym->MaxNameLen   = 255;

        DWORD64 disp64 = 0;
        DWORD   disp32 = 0;
        IMAGEHLP_LINE64 line = {};
        line.SizeOfStruct = sizeof(line);

        bool hasSym  = SymFromAddr(process, frame.AddrPC.Offset, &disp64, sym);
        bool hasLine = SymGetLineFromAddr64(process, frame.AddrPC.Offset,
                                            &disp32, &line);
        if (hasSym && hasLine) {
            fprintf(stderr, "  [%2d] %s+0x%llx  (%s:%lu)\n",
                    i, sym->Name, (unsigned long long)disp64,
                    line.FileName, line.LineNumber);
        } else if (hasSym) {
            fprintf(stderr, "  [%2d] %s+0x%llx\n",
                    i, sym->Name, (unsigned long long)disp64);
        } else {
            fprintf(stderr, "  [%2d] 0x%llx\n",
                    i, (unsigned long long)frame.AddrPC.Offset);
        }
    }

    SymCleanup(process);
    fprintf(stderr, "=== END CRASH ===\n");
    fflush(stderr);
    return EXCEPTION_EXECUTE_HANDLER;
}
#endif

class DarkApp : public QApplication {
public:
    using QApplication::QApplication;
    bool notify(QObject* receiver, QEvent* event) override {
        if (event->type() == QEvent::WindowActivate && receiver->isWidgetType()) {
            auto* w = static_cast<QWidget*>(receiver);
            if ((w->windowFlags() & Qt::Window) == Qt::Window
                && !w->property("DarkTitleBar").toBool()) {
                w->setProperty("DarkTitleBar", true);
#ifdef _WIN32
                setDarkTitleBar(w);
#endif
            }
        }
        return QApplication::notify(receiver, event);
    }
};

class MenuBarStyle : public QProxyStyle {
public:
    using QProxyStyle::QProxyStyle;
    QSize sizeFromContents(ContentsType type, const QStyleOption* opt,
                           const QSize& sz, const QWidget* w) const override {
        QSize s = QProxyStyle::sizeFromContents(type, opt, sz, w);
        if (type == CT_MenuBarItem)
            s.setHeight(s.height() + qRound(s.height() * 0.5));
        if (type == CT_MenuItem)
            s = QSize(s.width() + 24, s.height() + 4);
        return s;
    }
    int pixelMetric(PixelMetric metric, const QStyleOption* opt,
                    const QWidget* w) const override {
        // Kill the 1px frame margin Fusion reserves around QMenu contents
        if (metric == PM_MenuPanelWidth)
            return 0;
        // Kill the separator between dock widgets / central widget
        if (metric == PM_DockWidgetSeparatorExtent)
            return 0;
        return QProxyStyle::pixelMetric(metric, opt, w);
    }
    void drawPrimitive(PrimitiveElement elem, const QStyleOption* opt,
                       QPainter* p, const QWidget* w) const override {
        // Kill Fusion's 3D bevel on QMenu — the OS drop shadow is enough
        if (elem == PE_FrameMenu)
            return;
        // Kill the status bar item frame and panel border
        if (elem == PE_FrameStatusBarItem || elem == PE_PanelStatusBar)
            return;
        // Transparent menu bar background (no CSS needed)
        if (elem == PE_PanelMenuBar)
            return;
        QProxyStyle::drawPrimitive(elem, opt, p, w);
    }
    void drawControl(ControlElement element, const QStyleOption* opt,
                     QPainter* p, const QWidget* w) const override {
        // Suppress Fusion's CE_MenuBarEmptyArea — it fills with palette.window()
        // bypassing PE_PanelMenuBar.  TitleBarWidget paints the background.
        if (element == CE_MenuBarEmptyArea)
            return;
        // Menu bar items — fully owned painting (Fusion fills full rect, hiding border)
        if (element == CE_MenuBarItem) {
            if (auto* mi = qstyleoption_cast<const QStyleOptionMenuItem*>(opt)) {
                QRect area = mi->rect.adjusted(0, 0, 0, -1); // leave 1px for border
                bool selected = mi->state & State_Selected;
                bool sunken   = mi->state & State_Sunken;

                // Only fill background for hover/pressed — non-hovered stays
                // transparent so the parent's border line shows through.
                if (sunken)
                    p->fillRect(area, mi->palette.color(QPalette::Mid).darker(130));
                else if (selected)
                    p->fillRect(area, mi->palette.color(QPalette::Mid));

                QColor fg = (selected || sunken)
                    ? mi->palette.color(QPalette::Link)
                    : mi->palette.color(QPalette::ButtonText);
                p->setPen(fg);
                p->drawText(area, Qt::AlignCenter | Qt::TextShowMnemonic, mi->text);
                return; // never delegate to Fusion
            }
        }
        // Popup menu items — palette patch then delegate to Fusion
        if (element == CE_MenuItem) {
            if (auto* mi = qstyleoption_cast<const QStyleOptionMenuItem*>(opt)) {
                if ((mi->state & State_Selected)
                    && mi->menuItemType != QStyleOptionMenuItem::Separator) {
                    QStyleOptionMenuItem patched = *mi;
                    patched.palette.setColor(QPalette::Highlight,
                        mi->palette.color(QPalette::Mid));           // theme.hover
                    patched.palette.setColor(QPalette::HighlightedText,
                        mi->palette.color(QPalette::Link));          // theme.indHoverSpan
                    QProxyStyle::drawControl(element, &patched, p, w);
                    return;
                }
            }
        }
        // Tree view items — use theme.hover for selection instead of blue
        if (element == CE_ItemViewItem) {
            if (auto* vi = qstyleoption_cast<const QStyleOptionViewItem*>(opt)) {
                QStyleOptionViewItem patched = *vi;
                patched.palette.setColor(QPalette::Highlight,
                    vi->palette.color(QPalette::Mid));               // theme.hover
                patched.palette.setColor(QPalette::HighlightedText,
                    vi->palette.color(QPalette::Text));
                QProxyStyle::drawControl(element, &patched, p, w);
                return;
            }
        }
        QProxyStyle::drawControl(element, opt, p, w);
    }
};

static void applyGlobalTheme(const rcx::Theme& theme) {
    QPalette pal;
    pal.setColor(QPalette::Window,          theme.background);
    pal.setColor(QPalette::WindowText,      theme.text);
    pal.setColor(QPalette::Base,            theme.background);
    pal.setColor(QPalette::AlternateBase,   theme.surface);
    pal.setColor(QPalette::Text,            theme.text);
    pal.setColor(QPalette::Button,          theme.button);
    pal.setColor(QPalette::ButtonText,      theme.text);
    pal.setColor(QPalette::Highlight,       theme.selection);
    pal.setColor(QPalette::HighlightedText, theme.text);
    pal.setColor(QPalette::ToolTipBase,     theme.backgroundAlt);
    pal.setColor(QPalette::ToolTipText,     theme.text);
    pal.setColor(QPalette::Mid,             theme.hover);
    pal.setColor(QPalette::Dark,            theme.background);
    pal.setColor(QPalette::Light,           theme.textFaint);
    pal.setColor(QPalette::Link,            theme.indHoverSpan);

    // Disabled group: Fusion reads these for disabled menu items, buttons, etc.
    pal.setColor(QPalette::Disabled, QPalette::WindowText,      theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::Text,            theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::ButtonText,      theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::HighlightedText, theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::Light,           theme.background);

    qApp->setPalette(pal);

    qApp->setStyleSheet(QString());
}

class BorderOverlay : public QWidget {
public:
    QColor color;
    explicit BorderOverlay(QWidget* parent) : QWidget(parent) {
        setAttribute(Qt::WA_TransparentForMouseEvents);
        setAttribute(Qt::WA_NoSystemBackground);
        setFocusPolicy(Qt::NoFocus);
    }
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setPen(color);
        p.drawRect(0, 0, width() - 1, height() - 1);
    }
};

namespace rcx {

// MainWindow class declaration is in mainwindow.h

MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent) {
    setWindowTitle("Reclass");
    resize(1200, 800);

    // Frameless window with system menu (Alt+Space) and min/max/close support
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowSystemMenuHint
                   | Qt::WindowMinMaxButtonsHint);

    // Custom title bar (replaces native menu bar area in QMainWindow)
    m_titleBar = new TitleBarWidget(this);
    m_titleBar->applyTheme(ThemeManager::instance().current());
    setMenuWidget(m_titleBar);

#ifdef _WIN32
    // 1px top margin preserves DWM drop shadow on the frameless window
    {
        auto hwnd = reinterpret_cast<HWND>(winId());
        MARGINS margins = {0, 0, 1, 0};
        DwmExtendFrameIntoClientArea(hwnd, &margins);
    }
#endif

    // Border overlay — draws a 1px colored border on top of everything
    auto* overlay = new BorderOverlay(this);
    m_borderOverlay = overlay;
    overlay->color = ThemeManager::instance().current().borderFocused;
    overlay->setGeometry(rect());
    overlay->raise();
    overlay->show();

    m_mdiArea = new QMdiArea(this);
    m_mdiArea->setFrameShape(QFrame::NoFrame);
    m_mdiArea->setViewMode(QMdiArea::TabbedView);
    m_mdiArea->setTabsClosable(true);
    m_mdiArea->setTabsMovable(true);
    {
        const auto& t = ThemeManager::instance().current();
        m_mdiArea->setStyleSheet(QStringLiteral(
            "QTabBar::tab {"
            "  background: %1; color: %2; padding: 0px 16px; border: none; height: 24px;"
            "}"
            "QTabBar::tab:selected { color: %3; background: %4; }"
            "QTabBar::tab:hover { color: %3; background: %5; }")
            .arg(t.background.name(), t.textMuted.name(), t.text.name(),
                 t.backgroundAlt.name(), t.hover.name()));
    }
    setCentralWidget(m_mdiArea);

    createWorkspaceDock();
    createMenus();
    createStatusBar();

    // Eliminate gap between central widget and status bar
    if (auto* ml = layout()) {
        ml->setSpacing(0);
        ml->setContentsMargins(0, 0, 0, 0);
    }
    // Separator line between central widget and status bar is killed in MenuBarStyle::drawControl

    // Restore menu bar title case setting (after menus are created)
    {
        QSettings s("Reclass", "Reclass");
        m_titleBar->setMenuBarTitleCase(s.value("menuBarTitleCase", false).toBool());
        if (s.value("showIcon", false).toBool())
            m_titleBar->setShowIcon(true);
    }

    // MenuBarStyle is set as app style in main() — covers both QMenuBar and QMenu

    connect(&ThemeManager::instance(), &ThemeManager::themeChanged,
            this, &MainWindow::applyTheme);

    // Load plugins
    m_pluginManager.LoadPlugins();

    // Start MCP bridge
    m_mcp = new McpBridge(this, this);
    if (QSettings("Reclass", "Reclass").value("autoStartMcp", false).toBool())
        m_mcp->start();

    connect(m_mdiArea, &QMdiArea::subWindowActivated,
            this, [this](QMdiSubWindow*) {
        updateWindowTitle();
        rebuildWorkspaceModel();
    });

    // Track which split pane has focus (for menu-driven view switching)
    connect(qApp, &QApplication::focusChanged, this, [this](QWidget*, QWidget* now) {
        if (!now) return;
        auto* tab = activeTab();
        if (!tab) return;
        for (int i = 0; i < tab->panes.size(); ++i) {
            if (tab->panes[i].tabWidget && tab->panes[i].tabWidget->isAncestorOf(now)) {
                tab->activePaneIdx = i;
                syncViewButtons(tab->panes[i].viewMode);
                return;
            }
        }
    });
}

QIcon MainWindow::makeIcon(const QString& svgPath) {
    return QIcon(svgPath);
}

template < typename...Args >
inline QAction* Qt5Qt6AddAction(QMenu* menu, const QString &text, const QKeySequence &shortcut, const QIcon &icon, Args&&...args)
{
    QAction *result = menu->addAction(icon, text);
    if (!shortcut.isEmpty())
        result->setShortcut(shortcut);
    QObject::connect(result, &QAction::triggered, std::forward<Args>(args)...);
    return result;
}

void MainWindow::createMenus() {
    // File
    auto* file = m_titleBar->menuBar()->addMenu("&File");
    Qt5Qt6AddAction(file, "New &Class",  QKeySequence::New, QIcon(), this, &MainWindow::newClass);
    Qt5Qt6AddAction(file, "New &Struct", QKeySequence(Qt::CTRL | Qt::Key_T), QIcon(), this, &MainWindow::newStruct);
    Qt5Qt6AddAction(file, "New &Enum",   QKeySequence(Qt::CTRL | Qt::Key_E), QIcon(), this, &MainWindow::newEnum);
    Qt5Qt6AddAction(file, "&Open...", QKeySequence::Open, makeIcon(":/vsicons/folder-opened.svg"), this, &MainWindow::openFile);
    file->addSeparator();
    Qt5Qt6AddAction(file, "&Save", QKeySequence::Save, makeIcon(":/vsicons/save.svg"), this, &MainWindow::saveFile);
    Qt5Qt6AddAction(file, "Save &As...", QKeySequence::SaveAs, makeIcon(":/vsicons/save-as.svg"), this, &MainWindow::saveFileAs);
    file->addSeparator();
    m_sourceMenu = file->addMenu("Current Tab So&urce");
    connect(m_sourceMenu, &QMenu::aboutToShow, this, &MainWindow::populateSourceMenu);
    file->addSeparator();
    Qt5Qt6AddAction(file, "&Unload Project", QKeySequence(Qt::CTRL | Qt::Key_W), QIcon(), this, &MainWindow::closeFile);
    file->addSeparator();
    Qt5Qt6AddAction(file, "Export &C++ Header...", QKeySequence::UnknownKey, makeIcon(":/vsicons/export.svg"), this, &MainWindow::exportCpp);
    Qt5Qt6AddAction(file, "Export ReClass &XML...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::exportReclassXmlAction);
    Qt5Qt6AddAction(file, "Import from &Source...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::importFromSource);
    Qt5Qt6AddAction(file, "&Import ReClass XML...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::importReclassXml);
    Qt5Qt6AddAction(file, "Import &PDB...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::importPdb);
    // Examples submenu — scan once at init
    {
        QDir exDir(QCoreApplication::applicationDirPath() + "/examples");
        QStringList rcxFiles = exDir.entryList({"*.rcx"}, QDir::Files, QDir::Name);
        if (!rcxFiles.isEmpty()) {
            auto* examples = file->addMenu("&Examples");
            for (const QString& fn : rcxFiles) {
                QString fullPath = exDir.absoluteFilePath(fn);
                examples->addAction(fn, this, [this, fullPath]() { project_open(fullPath); });
            }
        }
    }
    file->addSeparator();
    const auto itemName = QSettings("Reclass", "Reclass").value("autoStartMcp", false).toBool() ? "Stop &MCP Server" : "Start &MCP Server";
    m_mcpAction = Qt5Qt6AddAction(file, itemName, QKeySequence::UnknownKey, QIcon(), this, &MainWindow::toggleMcp);
    file->addSeparator();
    Qt5Qt6AddAction(file, "&Options...", QKeySequence::UnknownKey, makeIcon(":/vsicons/settings-gear.svg"), this, &MainWindow::showOptionsDialog);
    file->addSeparator();
    Qt5Qt6AddAction(file, "E&xit", QKeySequence(Qt::Key_Close), makeIcon(":/vsicons/close.svg"), this, &QMainWindow::close);

    // Edit
    auto* edit = m_titleBar->menuBar()->addMenu("&Edit");
    Qt5Qt6AddAction(edit, "&Undo", QKeySequence::Undo, makeIcon(":/vsicons/arrow-left.svg"), this, &MainWindow::undo);
    Qt5Qt6AddAction(edit, "&Redo", QKeySequence::Redo, makeIcon(":/vsicons/arrow-right.svg"), this, &MainWindow::redo);
    edit->addSeparator();
    Qt5Qt6AddAction(edit, "&Type Aliases...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::showTypeAliasesDialog);

    // View
    auto* view = m_titleBar->menuBar()->addMenu("&View");
    Qt5Qt6AddAction(view, "Split &Horizontal", QKeySequence::UnknownKey, makeIcon(":/vsicons/split-horizontal.svg"), this, &MainWindow::splitView);
    Qt5Qt6AddAction(view, "&Unsplit", QKeySequence::UnknownKey, makeIcon(":/vsicons/chrome-close.svg"), this, &MainWindow::unsplitView);
    view->addSeparator();
    auto* fontMenu = view->addMenu(makeIcon(":/vsicons/text-size.svg"), "&Font");
    auto* fontGroup = new QActionGroup(this);
    fontGroup->setExclusive(true);
    auto* actConsolas = fontMenu->addAction("Consolas");
    actConsolas->setCheckable(true);
    actConsolas->setActionGroup(fontGroup);
    auto* actJetBrains = fontMenu->addAction("JetBrains Mono");
    actJetBrains->setCheckable(true);
    actJetBrains->setActionGroup(fontGroup);
    // Load saved preference
    QSettings settings("Reclass", "Reclass");
    QString savedFont = settings.value("font", "JetBrains Mono").toString();
    if (savedFont == "JetBrains Mono") actJetBrains->setChecked(true);
    else actConsolas->setChecked(true);
    connect(actConsolas, &QAction::triggered, this, [this]() { setEditorFont("Consolas"); });
    connect(actJetBrains, &QAction::triggered, this, [this]() { setEditorFont("JetBrains Mono"); });

    // Theme submenu
    auto* themeMenu = view->addMenu("&Theme");
    auto* themeGroup = new QActionGroup(this);
    themeGroup->setExclusive(true);
    auto& tm = ThemeManager::instance();
    auto allThemes = tm.themes();
    for (int i = 0; i < allThemes.size(); i++) {
        auto* act = themeMenu->addAction(allThemes[i].name);
        act->setCheckable(true);
        act->setActionGroup(themeGroup);
        if (i == tm.currentIndex()) act->setChecked(true);
        connect(act, &QAction::triggered, this, [i]() {
            ThemeManager::instance().setCurrent(i);
        });
    }
    themeMenu->addSeparator();
    Qt5Qt6AddAction(themeMenu, "Edit Theme...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::editTheme);

    view->addSeparator();
    auto* actCompact = view->addAction("Compact &Columns");
    actCompact->setCheckable(true);
    actCompact->setChecked(settings.value("compactColumns", true).toBool());
    connect(actCompact, &QAction::triggered, this, [this](bool checked) {
        QSettings("Reclass", "Reclass").setValue("compactColumns", checked);
        for (auto& tab : m_tabs)
            tab.ctrl->setCompactColumns(checked);
    });

    view->addSeparator();
    view->addAction(m_workspaceDock->toggleViewAction());

    // Plugins
    auto* plugins = m_titleBar->menuBar()->addMenu("&Plugins");
    Qt5Qt6AddAction(plugins, "&Manage Plugins...", QKeySequence::UnknownKey, QIcon(), this, &MainWindow::showPluginsDialog);

    // Help
    auto* help = m_titleBar->menuBar()->addMenu("&Help");
    Qt5Qt6AddAction(help, "&About Reclass", QKeySequence::UnknownKey, makeIcon(":/vsicons/question.svg"), this, &MainWindow::about);
}

// ── Themed resize grip (replaces ugly default QSizeGrip) ──
// Positioned as a direct child of MainWindow at the bottom-right corner,
// NOT inside the status bar layout (which is font-height dependent).
class ResizeGrip : public QWidget {
public:
    static constexpr int kSize = 16;    // widget size
    static constexpr int kPad  = 4;     // padding from window corner (identical right & bottom)

    explicit ResizeGrip(QWidget* parent) : QWidget(parent) {
        setFixedSize(kSize, kSize);
        setCursor(Qt::SizeFDiagCursor);
        m_color = rcx::ThemeManager::instance().current().textFaint;
    }
    void setGripColor(const QColor& c) { m_color = c; update(); }

    // Call from parent's resizeEvent to pin to bottom-right corner
    void reposition() {
        QWidget* w = parentWidget();
        if (w) move(w->width() - kSize - kPad, w->height() - kSize - kPad);
    }

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing);
        p.setPen(Qt::NoPen);
        p.setBrush(m_color);
        // 6 dots in a triangle pointing bottom-right (VS2022 style)
        // Dot grid is centered within the widget: same inset from right and bottom
        const double r = 1.0, s = 4.0;
        const double inset = 4.0;
        double bx = width()  - inset;
        double by = height() - inset;
        // bottom row: 3 dots
        p.drawEllipse(QPointF(bx,         by), r, r);
        p.drawEllipse(QPointF(bx - s,     by), r, r);
        p.drawEllipse(QPointF(bx - 2 * s, by), r, r);
        // middle row: 2 dots
        p.drawEllipse(QPointF(bx,         by - s), r, r);
        p.drawEllipse(QPointF(bx - s,     by - s), r, r);
        // top row: 1 dot
        p.drawEllipse(QPointF(bx,         by - 2 * s), r, r);
    }
    void mousePressEvent(QMouseEvent* e) override {
        if (e->button() == Qt::LeftButton) {
            window()->windowHandle()->startSystemResize(Qt::BottomEdge | Qt::RightEdge);
            e->accept();
        }
    }
private:
    QColor m_color;
};

// ── Custom-painted view tab button (no CSS) ──
class ViewTabButton : public QPushButton {
public:
    static constexpr int kAccentH = 3;   // accent line height in pixels
    static constexpr int kPadLR  = 12;   // horizontal padding
    static constexpr int kPadBot = 4;    // extra bottom padding

    int baselineY = -1;  // set by FlatStatusBar for cross-widget text alignment

    QColor colBg, colBgChecked, colBgHover, colBgPressed;
    QColor colText, colTextMuted, colAccent, colBorder;

    explicit ViewTabButton(const QString& text, QWidget* parent = nullptr)
        : QPushButton(text, parent) {
        setCheckable(true);
        setFlat(true);
        setCursor(Qt::PointingHandCursor);
        setContentsMargins(0, 0, 0, 0);
        setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Ignored);
    }

    QSize sizeHint() const override {
        QFontMetrics fm(font());
        int w = fm.horizontalAdvance(text()) + 2 * kPadLR;
        int h = qRound((fm.height() + kAccentH + kPadBot) * 1.33);
        return QSize(w, h);
    }

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        // Background
        QColor bg = colBg;
        if (isDown())          bg = colBgPressed;
        else if (underMouse()) bg = colBgHover;
        else if (isChecked())  bg = colBgChecked;
        p.fillRect(rect(), bg);

        // Top border (continuous with status bar hairline)
        if (colBorder.isValid())
            p.fillRect(0, 0, width(), 1, colBorder);

        // Accent line at y=0 when checked (paints over border)
        if (isChecked())
            p.fillRect(0, 0, width(), kAccentH, colAccent);

        // Text — use shared baseline if set, otherwise fall back to VCenter
        p.setPen(isChecked() || underMouse() || isDown() ? colText : colTextMuted);
        p.setFont(font());
        if (baselineY >= 0) {
            p.drawText(kPadLR, baselineY, text());
        } else {
            QRect textRect(kPadLR, kAccentH, width() - 2 * kPadLR, height() - kAccentH);
            p.drawText(textRect, Qt::AlignVCenter | Qt::AlignLeft, text());
        }
    }

    void enterEvent(QEnterEvent*) override { update(); }
    void leaveEvent(QEvent*) override { update(); }
};

// ── Borderless status bar with manual child layout ──
// QStatusBarLayout hardcodes 2px margins that can't be overridden.
// We bypass it entirely: children are placed manually in resizeEvent,
// and addWidget() is NOT used. Instead, create children as direct
// children and call manualLayout() to position them.
class FlatStatusBar : public QStatusBar {
public:
    QWidget* tabRow   = nullptr;   // set by createStatusBar
    QLabel*  label    = nullptr;   // set by createStatusBar

    void setDividerColor(const QColor& c) { m_div = c; update(); }
    void setTopLineColor(const QColor& c) { m_top = c; update(); }

    explicit FlatStatusBar(QWidget* parent = nullptr) : QStatusBar(parent) {
        setSizeGripEnabled(false);
    }

    QSize sizeHint() const override {
        const int tabH  = tabRow ? tabRow->sizeHint().height() : 0;
        const int textH = fontMetrics().height();
        const int base  = qMax(tabH, textH + 6);
        const int h     = qRound(base * 1.15);
        return { QStatusBar::sizeHint().width(), h };
    }
    QSize minimumSizeHint() const override { return sizeHint(); }

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.fillRect(rect(), palette().window());

        // Top hairline separator
        if (m_top.isValid())
            p.fillRect(0, 0, width(), 1, m_top);

        // Vertical divider between tabRow and label
        if (m_div.isValid() && m_divX >= 0)
            p.fillRect(m_divX, 4, 1, height() - 8, m_div);
    }
    void resizeEvent(QResizeEvent* e) override {
        QStatusBar::resizeEvent(e);
        manualLayout();
    }
    void showEvent(QShowEvent* e) override {
        QStatusBar::showEvent(e);
        manualLayout();
    }
private:
    QColor m_div, m_top;
    int m_divX = -1;

    void manualLayout() {
        if (!tabRow || !label) return;
        const int h      = height();
        const int tw     = tabRow->sizeHint().width();
        const int gutter = 6;
        tabRow->setGeometry(0, 0, tw, h);
        m_divX = tw;
        label->setGeometry(tw + 1 + gutter, 0,
                           qMax(0, width() - (tw + 1 + gutter)), h);

        // Shared baseline so tab text and status text align.
        // Nudge up by half the accent-line height so text centres
        // in the visible area below the accent bar, not in the full bar.
        QFontMetrics fm(font());
        int by = (h + fm.ascent()) / 2 - (ViewTabButton::kAccentH + 1) / 2;

        // Push baseline to buttons
        auto* lay = tabRow->layout();
        if (lay) {
            for (int i = 0; i < lay->count(); i++)
                static_cast<ViewTabButton*>(lay->itemAt(i)->widget())->baselineY = by;
        }
        // Align label: set top margin so text baseline matches
        int labelTop = by - fm.ascent();
        label->setContentsMargins(0, labelTop, 0, 0);
        label->setAlignment(Qt::AlignLeft | Qt::AlignTop);
    }
};

void MainWindow::createStatusBar() {
    // Replace the default QStatusBar with our borderless, manually-laid-out one.
    // QStatusBarLayout hardcodes 2px margins; we bypass addWidget entirely.
    auto* sb = new FlatStatusBar;
    setStatusBar(sb);

    m_statusLabel = new QLabel("Ready", sb);
    m_statusLabel->setContentsMargins(0, 0, 0, 0);
    m_statusLabel->setAlignment(Qt::AlignVCenter | Qt::AlignLeft);

    // View toggle buttons (Reclass / C/C++) — custom painted, no CSS
    m_viewBtnGroup = new QButtonGroup(this);
    m_viewBtnGroup->setExclusive(true);

    m_btnReclass = new ViewTabButton("Reclass");
    m_btnReclass->setChecked(true);

    m_btnRendered = new ViewTabButton("C/C++");

    m_viewBtnGroup->addButton(m_btnReclass, 0);
    m_viewBtnGroup->addButton(m_btnRendered, 1);

    // Wrap buttons in a plain container — FlatStatusBar paints the chrome
    auto* tabRow = new QWidget(sb);
    auto* tabLay = new QHBoxLayout(tabRow);
    tabLay->setContentsMargins(0, 0, 0, 0);
    tabLay->setSpacing(0);
    tabLay->addWidget(m_btnReclass);
    tabLay->addWidget(m_btnRendered);

    sb->tabRow = tabRow;
    sb->label  = m_statusLabel;

    sb->setMinimumHeight(qMax(m_btnReclass->sizeHint().height(),
                              sb->fontMetrics().height() + 6));

    connect(m_viewBtnGroup, &QButtonGroup::idClicked, this, [this](int id) {
        setViewMode(id == 1 ? VM_Rendered : VM_Reclass);
    });

    // Grip is a direct child of the main window, NOT in the status bar layout.
    // Positioned via reposition() in resizeEvent — immune to font/margin changes.
    auto* grip = new ResizeGrip(this);
    grip->setObjectName("resizeGrip");
    grip->raise();

    {
        const auto& t = ThemeManager::instance().current();
        QPalette sbPal = statusBar()->palette();
        sbPal.setColor(QPalette::Window, t.background);
        sbPal.setColor(QPalette::WindowText, t.textDim);
        statusBar()->setPalette(sbPal);
        statusBar()->setAutoFillBackground(true);

        sb->setTopLineColor(t.border);
        sb->setDividerColor(t.border);

        auto applyViewTabColors = [&](ViewTabButton* btn) {
            btn->colBg        = t.background;
            btn->colBgChecked = t.backgroundAlt;
            btn->colBgHover   = t.hover;
            btn->colBgPressed = t.hover.darker(130);
            btn->colText      = t.text;
            btn->colTextMuted = t.textMuted;
            btn->colAccent    = t.indHoverSpan;
            btn->colBorder    = t.border;
        };
        applyViewTabColors(static_cast<ViewTabButton*>(m_btnReclass));
        applyViewTabColors(static_cast<ViewTabButton*>(m_btnRendered));
    }

}


void MainWindow::styleTabCloseButtons() {
    auto* tabBar = m_mdiArea->findChild<QTabBar*>();
    if (!tabBar) return;

    const auto& t = ThemeManager::instance().current();
    QString style = QStringLiteral(
        "QToolButton { color: %1; border: none; padding: 0px 4px 2px 4px; font-size: 12px; }"
        "QToolButton:hover { color: %2; }")
        .arg(t.textDim.name(), t.indHoverSpan.name());

    auto subs = m_mdiArea->subWindowList();
    for (int i = 0; i < tabBar->count() && i < subs.size(); i++) {
        auto* existing = qobject_cast<QToolButton*>(
            tabBar->tabButton(i, QTabBar::RightSide));
        if (existing && existing->text() == QStringLiteral("\u2715")) {
            // Already our button, just restyle
            existing->setStyleSheet(style);
            continue;
        }
        // Replace with ✕ text button
        auto* btn = new QToolButton(tabBar);
        btn->setText(QStringLiteral("\u2715"));
        btn->setAutoRaise(true);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(style);
        QMdiSubWindow* sub = subs[i];
        connect(btn, &QToolButton::clicked, sub, &QMdiSubWindow::close);
        tabBar->setTabButton(i, QTabBar::RightSide, btn);
    }
}

MainWindow::SplitPane MainWindow::createSplitPane(TabState& tab) {
    SplitPane pane;

    pane.tabWidget = new QTabWidget;
    pane.tabWidget->setTabPosition(QTabWidget::South);
    pane.tabWidget->tabBar()->setVisible(false);
    pane.tabWidget->setDocumentMode(true);  // kill QTabWidget frame border

    // Create editor via controller (parent = tabWidget for ownership)
    pane.editor = tab.ctrl->addSplitEditor(pane.tabWidget);
    pane.tabWidget->addTab(pane.editor, "Reclass");     // index 0

    // Create per-pane rendered C++ view
    pane.rendered = new QsciScintilla;
    setupRenderedSci(pane.rendered);
    pane.tabWidget->addTab(pane.rendered, "C/C++");     // index 1

    pane.tabWidget->setCurrentIndex(0);
    pane.viewMode = VM_Reclass;

    // Add to splitter
    tab.splitter->addWidget(pane.tabWidget);

    // Connect per-pane page switching (driven by status bar buttons via setViewMode)
    QTabWidget* tw = pane.tabWidget;
    connect(tw, &QTabWidget::currentChanged, this, [this, tw](int index) {
        SplitPane* p = findPaneByTabWidget(tw);
        if (!p) return;

        p->viewMode = (index == 1) ? VM_Rendered : VM_Reclass;

        // Sync status bar buttons if this is the active pane
        auto* tab = activeTab();
        if (tab && &tab->panes[tab->activePaneIdx] == p)
            syncViewButtons(p->viewMode);

        if (index == 1) {
            for (auto& tab : m_tabs) {
                for (auto& pane : tab.panes) {
                    if (&pane == p) {
                        updateRenderedView(tab, pane);
                        break;
                    }
                }
            }
        }
    });

    return pane;
}

MainWindow::SplitPane* MainWindow::findPaneByTabWidget(QTabWidget* tw) {
    for (auto& tab : m_tabs) {
        for (auto& pane : tab.panes) {
            if (pane.tabWidget == tw)
                return &pane;
        }
    }
    return nullptr;
}

MainWindow::SplitPane* MainWindow::findActiveSplitPane() {
    auto* tab = activeTab();
    if (!tab || tab->panes.isEmpty()) return nullptr;
    int idx = qBound(0, tab->activePaneIdx, tab->panes.size() - 1);
    return &tab->panes[idx];
}

RcxEditor* MainWindow::activePaneEditor() {
    auto* pane = findActiveSplitPane();
    return pane ? pane->editor : nullptr;
}

static QString rootName(const NodeTree& tree, uint64_t viewRootId = 0) {
    if (viewRootId != 0) {
        int idx = tree.indexOfId(viewRootId);
        if (idx >= 0) {
            const auto& n = tree.nodes[idx];
            if (!n.structTypeName.isEmpty()) return n.structTypeName;
            if (!n.name.isEmpty()) return n.name;
        }
    }
    for (const auto& n : tree.nodes) {
        if (n.parentId == 0 && n.kind == NodeKind::Struct) {
            if (!n.structTypeName.isEmpty()) return n.structTypeName;
            if (!n.name.isEmpty()) return n.name;
        }
    }
    return QStringLiteral("Untitled");
}

QMdiSubWindow* MainWindow::createTab(RcxDocument* doc) {
    auto* splitter = new QSplitter(Qt::Horizontal);
    splitter->setHandleWidth(1);
    auto* ctrl = new RcxController(doc, splitter);

    auto* sub = m_mdiArea->addSubWindow(splitter);
    sub->setWindowIcon(QIcon());  // suppress app icon in MDI tabs
    sub->setWindowTitle(doc->filePath.isEmpty()
                        ? rootName(doc->tree) : QFileInfo(doc->filePath).fileName());
    sub->setAttribute(Qt::WA_DeleteOnClose);
    sub->showMaximized();

    m_tabs[sub] = { doc, ctrl, splitter, {}, 0 };
    auto& tab = m_tabs[sub];

    // Create the initial split pane
    tab.panes.append(createSplitPane(tab));

    // Apply global compact columns setting to new tab
    ctrl->setCompactColumns(QSettings("Reclass", "Reclass").value("compactColumns", true).toBool());

    // Give every controller the shared document list for cross-tab type visibility
    ctrl->setProjectDocuments(&m_allDocs);
    rebuildAllDocs();

    connect(sub, &QObject::destroyed, this, [this, sub]() {
        auto it = m_tabs.find(sub);
        if (it != m_tabs.end()) {
            it->doc->deleteLater();
            m_tabs.erase(it);
        }
        rebuildAllDocs();
        rebuildWorkspaceModel();
    });

    connect(ctrl, &RcxController::nodeSelected,
            this, [this, ctrl, sub](int nodeIdx) {
        if (nodeIdx >= 0 && nodeIdx < ctrl->document()->tree.nodes.size()) {
            auto& node = ctrl->document()->tree.nodes[nodeIdx];
            auto* ap = findActiveSplitPane();
            if (ap && ap->viewMode == VM_Rendered)
                m_statusLabel->setText(
                    QString("Rendered: %1 %2")
                        .arg(kindToString(node.kind))
                        .arg(node.name));
            else
                m_statusLabel->setText(
                    QString("%1 %2  offset: 0x%3  size: %4 bytes")
                        .arg(kindToString(node.kind))
                        .arg(node.name)
                        .arg(node.offset, 4, 16, QChar('0'))
                        .arg(node.byteSize()));
        } else {
            m_statusLabel->setText("Ready");
        }
        // Update all rendered panes on selection change
        auto it = m_tabs.find(sub);
        if (it != m_tabs.end())
            updateAllRenderedPanes(*it);
    });
    connect(ctrl, &RcxController::selectionChanged,
            this, [this](int count) {
        if (count == 0)
            m_statusLabel->setText("Ready");
        else if (count > 1)
            m_statusLabel->setText(QString("%1 nodes selected").arg(count));
    });

    // Update rendered panes and workspace on document changes and undo/redo
    connect(doc, &RcxDocument::documentChanged,
            this, [this, sub]() {
        auto it = m_tabs.find(sub);
        if (it != m_tabs.end())
            QTimer::singleShot(0, this, [this, sub]() {
                auto it2 = m_tabs.find(sub);
                if (it2 != m_tabs.end()) {
                    updateAllRenderedPanes(*it2);
                    if (it2->doc->filePath.isEmpty())
                        sub->setWindowTitle(rootName(it2->doc->tree, it2->ctrl->viewRootId()));
                }
                rebuildWorkspaceModel();
                updateWindowTitle();
            });
    });
    connect(&doc->undoStack, &QUndoStack::indexChanged,
            this, [this, sub](int) {
        auto it = m_tabs.find(sub);
        if (it != m_tabs.end())
            QTimer::singleShot(0, this, [this, sub]() {
                auto it2 = m_tabs.find(sub);
                if (it2 != m_tabs.end()) {
                    updateAllRenderedPanes(*it2);
                    if (it2->doc->filePath.isEmpty())
                        sub->setWindowTitle(rootName(it2->doc->tree, it2->ctrl->viewRootId()));
                }
                updateWindowTitle();
                rebuildWorkspaceModel();
            });
    });

    // Auto-focus on first root struct (don't show all roots)
    for (const auto& n : doc->tree.nodes) {
        if (n.parentId == 0 && n.kind == NodeKind::Struct) {
            ctrl->setViewRootId(n.id);
            break;
        }
    }

    ctrl->refresh();
    rebuildWorkspaceModel();
    styleTabCloseButtons();
    return sub;
}

// Build a minimal empty struct for new documents
static void buildEmptyStruct(NodeTree& tree, const QString& classKeyword = QString()) {
    Node root;
    root.kind = NodeKind::Struct;
    root.name = "instance";
    root.structTypeName = "Unnamed";
    root.classKeyword = classKeyword;
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    for (int i = 0; i < 16; i++) {
        Node n;
        n.kind = NodeKind::Hex64;
        n.name = QStringLiteral("field_%1").arg(i * 8, 2, 16, QChar('0'));
        n.parentId = rootId;
        n.offset = i * 8;
        tree.addNode(n);
    }

    // Default project: add an example enum and a class with a union
    if (classKeyword.isEmpty()) {
        // ── Example enum: _POOL_TYPE ──
        {
            Node e;
            e.kind = NodeKind::Struct;
            e.name = QStringLiteral("_POOL_TYPE");
            e.structTypeName = QStringLiteral("_POOL_TYPE");
            e.classKeyword = QStringLiteral("enum");
            e.parentId = 0;
            e.collapsed = false;
            e.enumMembers = {
                {QStringLiteral("NonPagedPool"), 0},
                {QStringLiteral("PagedPool"), 1},
                {QStringLiteral("NonPagedPoolMustSucceed"), 2},
                {QStringLiteral("DontUseThisType"), 3},
                {QStringLiteral("NonPagedPoolCacheAligned"), 4},
                {QStringLiteral("PagedPoolCacheAligned"), 5},
            };
            tree.addNode(e);
        }

        // ── Example class with a union: _SAMPLE_OBJECT ──
        {
            Node cls;
            cls.kind = NodeKind::Struct;
            cls.name = QStringLiteral("sample");
            cls.structTypeName = QStringLiteral("_SAMPLE_OBJECT");
            cls.classKeyword = QStringLiteral("class");
            cls.parentId = 0;
            cls.offset = 0;
            int ci = tree.addNode(cls);
            uint64_t clsId = tree.nodes[ci].id;

            // Field: uint32_t Type at offset 0
            { Node n; n.kind = NodeKind::UInt32; n.name = QStringLiteral("Type");
              n.parentId = clsId; n.offset = 0; tree.addNode(n); }
            // Field: uint32_t Size at offset 4
            { Node n; n.kind = NodeKind::UInt32; n.name = QStringLiteral("Size");
              n.parentId = clsId; n.offset = 4; tree.addNode(n); }

            // Union at offset 8
            {
                Node u;
                u.kind = NodeKind::Struct;
                u.name = QStringLiteral("Data");
                u.structTypeName = QStringLiteral("Data");
                u.classKeyword = QStringLiteral("union");
                u.parentId = clsId;
                u.offset = 8;
                int ui = tree.addNode(u);
                uint64_t uId = tree.nodes[ui].id;

                // Union member: uint64_t AsLong
                { Node n; n.kind = NodeKind::UInt64; n.name = QStringLiteral("AsLong");
                  n.parentId = uId; n.offset = 0; tree.addNode(n); }
                // Union member: void* AsPointer
                { Node n; n.kind = NodeKind::Pointer64; n.name = QStringLiteral("AsPointer");
                  n.parentId = uId; n.offset = 0; n.collapsed = true; tree.addNode(n); }
                // Union member: float[2] AsFloat2
                { Node n; n.kind = NodeKind::Vec2; n.name = QStringLiteral("AsFloat2");
                  n.parentId = uId; n.offset = 0; tree.addNode(n); }
            }

            // Field: void* Next at offset 16
            { Node n; n.kind = NodeKind::Pointer64; n.name = QStringLiteral("Next");
              n.parentId = clsId; n.offset = 16; n.collapsed = true; tree.addNode(n); }
        }
    }
}

void MainWindow::newClass() {
    project_new(QStringLiteral("class"));
}

void MainWindow::newStruct() {
    project_new();
}

void MainWindow::newEnum() {
    project_new(QStringLiteral("enum"));
}

static void buildEditorDemo(NodeTree& tree, uintptr_t editorAddr) {
    tree.nodes.clear();
    tree.invalidateIdCache();
    tree.m_nextId = 1;
    tree.baseAddress = static_cast<uint64_t>(editorAddr);

    // ── Root struct: RcxEditor ──
    Node root;
    root.kind = NodeKind::Struct;
    root.name = QStringLiteral("editor");
    root.structTypeName = QStringLiteral("RcxEditor");
    root.classKeyword = QStringLiteral("class");
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    // ── VTable struct definition (separate root) ──
    Node vtStruct;
    vtStruct.kind = NodeKind::Struct;
    vtStruct.name = QStringLiteral("VTable");
    vtStruct.structTypeName = QStringLiteral("QWidgetVTable");
    int vti = tree.addNode(vtStruct);
    uint64_t vtId = tree.nodes[vti].id;

    // VTable entries — these are real virtual function pointers from QObject/QWidget
    static const char* vfNames[] = {
        "deleting_dtor", "metaObject", "qt_metacast", "qt_metacall",
        "event", "eventFilter", "timerEvent", "childEvent",
        "customEvent", "connectNotify", "disconnectNotify", "devType",
        "setVisible", "sizeHint", "minimumSizeHint", "heightForWidth",
    };
    for (int i = 0; i < 16; i++) {
        Node fn;
        fn.kind = NodeKind::FuncPtr64;
        fn.name = QString::fromLatin1(vfNames[i]);
        fn.parentId = vtId;
        fn.offset = i * 8;
        tree.addNode(fn);
    }

    // ── RcxEditor fields ──
    // offset 0: vtable pointer → QWidgetVTable
    {
        Node n;
        n.kind = NodeKind::Pointer64;
        n.name = QStringLiteral("__vptr");
        n.parentId = rootId;
        n.offset = 0;
        n.refId = vtId;
        tree.addNode(n);
    }
    // offset 8: QObjectData* d_ptr (QObject internals)
    {
        Node n;
        n.kind = NodeKind::Pointer64;
        n.name = QStringLiteral("d_ptr");
        n.parentId = rootId;
        n.offset = 8;
        tree.addNode(n);
    }
    // The rest of the object: raw memory visible as Hex64 fields
    // QWidget base is large (~200+ bytes), then RcxEditor members follow.
    // Lay out enough to cover the interesting editor state.
    for (int off = 16; off < 512; off += 8) {
        Node n;
        n.kind = NodeKind::Hex64;
        n.name = QStringLiteral("field_%1").arg(off, 3, 16, QLatin1Char('0'));
        n.parentId = rootId;
        n.offset = off;
        tree.addNode(n);
    }

    // ── Example enum: _POOL_TYPE ──
    {
        Node e;
        e.kind = NodeKind::Struct;
        e.name = QStringLiteral("_POOL_TYPE");
        e.structTypeName = QStringLiteral("_POOL_TYPE");
        e.classKeyword = QStringLiteral("enum");
        e.parentId = 0;
        e.collapsed = false;
        e.enumMembers = {
            {QStringLiteral("NonPagedPool"), 0},
            {QStringLiteral("PagedPool"), 1},
            {QStringLiteral("NonPagedPoolMustSucceed"), 2},
            {QStringLiteral("DontUseThisType"), 3},
            {QStringLiteral("NonPagedPoolCacheAligned"), 4},
            {QStringLiteral("PagedPoolCacheAligned"), 5},
        };
        tree.addNode(e);
    }

    // ── Example class with a union: _SAMPLE_OBJECT ──
    {
        Node cls;
        cls.kind = NodeKind::Struct;
        cls.name = QStringLiteral("sample");
        cls.structTypeName = QStringLiteral("_SAMPLE_OBJECT");
        cls.classKeyword = QStringLiteral("class");
        cls.parentId = 0;
        cls.offset = 0;
        int ci = tree.addNode(cls);
        uint64_t clsId = tree.nodes[ci].id;

        // Field: uint32_t Type at offset 0
        { Node n; n.kind = NodeKind::UInt32; n.name = QStringLiteral("Type");
          n.parentId = clsId; n.offset = 0; tree.addNode(n); }
        // Field: uint32_t Size at offset 4
        { Node n; n.kind = NodeKind::UInt32; n.name = QStringLiteral("Size");
          n.parentId = clsId; n.offset = 4; tree.addNode(n); }

        // Union at offset 8
        {
            Node u;
            u.kind = NodeKind::Struct;
            u.name = QStringLiteral("Data");
            u.structTypeName = QStringLiteral("Data");
            u.classKeyword = QStringLiteral("union");
            u.parentId = clsId;
            u.offset = 8;
            int ui = tree.addNode(u);
            uint64_t uId = tree.nodes[ui].id;

            // Union member: uint64_t AsLong
            { Node n; n.kind = NodeKind::UInt64; n.name = QStringLiteral("AsLong");
              n.parentId = uId; n.offset = 0; tree.addNode(n); }
            // Union member: void* AsPointer
            { Node n; n.kind = NodeKind::Pointer64; n.name = QStringLiteral("AsPointer");
              n.parentId = uId; n.offset = 0; n.collapsed = true; tree.addNode(n); }
            // Union member: float[2] AsFloat2
            { Node n; n.kind = NodeKind::Vec2; n.name = QStringLiteral("AsFloat2");
              n.parentId = uId; n.offset = 0; tree.addNode(n); }
        }

        // Field: void* Next at offset 16
        { Node n; n.kind = NodeKind::Pointer64; n.name = QStringLiteral("Next");
          n.parentId = clsId; n.offset = 16; n.collapsed = true; tree.addNode(n); }
    }
}

void MainWindow::selfTest() {
#ifdef Q_OS_WIN
    // Create a new project, then point it at the live editor object
    project_new();

    auto* ctrl = activeController();
    if (!ctrl || ctrl->editors().isEmpty()) return;

    auto* editor = ctrl->editors().first();
    auto* doc = ctrl->document();

    // Build a tree describing RcxEditor, based at the real object address
    buildEditorDemo(doc->tree, reinterpret_cast<uintptr_t>(editor));

    // Attach process memory to self — provider base will be set to the editor address
    DWORD pid = GetCurrentProcessId();
    QString target = QString("%1:Reclass.exe").arg(pid);

    ctrl->attachViaPlugin(QStringLiteral("processmemory"), target);
#else
    project_new();
#endif
}

void MainWindow::openFile() {
    project_open();
}

void MainWindow::saveFile() {
    project_save(nullptr, false);
}

void MainWindow::saveFileAs() {
    project_save(nullptr, true);
}

void MainWindow::closeFile() {
    project_close();
}

void MainWindow::addNode() {
    auto* ctrl = activeController();
    if (!ctrl) return;

    uint64_t parentId = ctrl->viewRootId();  // default to current view root
    auto* primary = activePaneEditor();
    if (primary && primary->isEditing()) return;
    if (primary) {
        int ni = primary->currentNodeIndex();
        if (ni >= 0) {
            auto& node = ctrl->document()->tree.nodes[ni];
            if (node.kind == NodeKind::Struct || node.kind == NodeKind::Array)
                parentId = node.id;
            else
                parentId = node.parentId;
        }
    }
    ctrl->insertNode(parentId, -1, NodeKind::Hex64, "newField");
}

void MainWindow::removeNode() {
    auto* ctrl = activeController();
    if (!ctrl) return;
    auto* primary = activePaneEditor();
    if (primary && primary->isEditing()) return;
    QSet<uint64_t> ids = ctrl->selectedIds();
    QVector<int> indices;
    for (uint64_t id : ids) {
        int idx = ctrl->document()->tree.indexOfId(id & ~kFooterIdBit);
        if (idx >= 0) indices.append(idx);
    }
    if (indices.size() > 1)
        ctrl->batchRemoveNodes(indices);
    else if (indices.size() == 1)
        ctrl->removeNode(indices.first());
}

void MainWindow::changeNodeType() {
    auto* ctrl = activeController();
    if (!ctrl) return;
    auto* primary = activePaneEditor();
    if (!primary) return;
    primary->beginInlineEdit(EditTarget::Type);
}

void MainWindow::renameNodeAction() {
    auto* ctrl = activeController();
    if (!ctrl) return;
    auto* primary = activePaneEditor();
    if (!primary) return;
    primary->beginInlineEdit(EditTarget::Name);
}

void MainWindow::duplicateNodeAction() {
    auto* ctrl = activeController();
    if (!ctrl) return;
    auto* primary = activePaneEditor();
    if (!primary || primary->isEditing()) return;
    int ni = primary->currentNodeIndex();
    if (ni >= 0) ctrl->duplicateNode(ni);
}

void MainWindow::splitView() {
    auto* tab = activeTab();
    if (!tab) return;
    tab->panes.append(createSplitPane(*tab));
}

void MainWindow::unsplitView() {
    auto* tab = activeTab();
    if (!tab || tab->panes.size() <= 1) return;
    auto pane = tab->panes.takeLast();
    tab->ctrl->removeSplitEditor(pane.editor);
    pane.tabWidget->deleteLater();
    tab->activePaneIdx = qBound(0, tab->activePaneIdx, tab->panes.size() - 1);
}

void MainWindow::undo() {
    auto* tab = activeTab();
    if (tab) tab->doc->undoStack.undo();
}

void MainWindow::redo() {
    auto* tab = activeTab();
    if (tab) tab->doc->undoStack.redo();
}

void MainWindow::about() {
    QDialog dlg(this);
    dlg.setWindowTitle("About Reclass");
    dlg.setFixedSize(260, 120);
    auto* lay = new QVBoxLayout(&dlg);
    lay->setContentsMargins(20, 16, 20, 16);
    lay->setSpacing(12);

    auto* buildLabel = new QLabel(
        QStringLiteral("<span style='color:%1;font-size:11px;'>"
                       "Build&ensp;" __DATE__ "&ensp;" __TIME__ "</span>")
            .arg(ThemeManager::instance().current().textDim.name()));
    buildLabel->setAlignment(Qt::AlignCenter);
    lay->addWidget(buildLabel);

    auto* ghBtn = new QPushButton("GitHub");
    ghBtn->setCursor(Qt::PointingHandCursor);
    {
        const auto& t = ThemeManager::instance().current();
        ghBtn->setStyleSheet(QStringLiteral(
            "QPushButton {"
            "  background: %1; color: %2; border: 1px solid %3;"
            "  border-radius: 4px; padding: 5px 16px; font-size: 12px;"
            "}"
            "QPushButton:hover { background: %4; border-color: %5; }")
            .arg(t.indCmdPill.name(), t.text.name(), t.border.name(),
                 t.button.name(), t.textFaint.name()));
    }
    connect(ghBtn, &QPushButton::clicked, this, []() {
        QDesktopServices::openUrl(QUrl("https://github.com/IChooseYou/Reclass"));
    });
    lay->addWidget(ghBtn, 0, Qt::AlignCenter);

    {
        QPalette dlgPal = dlg.palette();
        dlgPal.setColor(QPalette::Window, ThemeManager::instance().current().background);
        dlg.setPalette(dlgPal);
        dlg.setAutoFillBackground(true);
    }
    dlg.exec();
}

void MainWindow::toggleMcp() {
    if (m_mcp->isRunning()) {
        m_mcp->stop();
        m_mcpAction->setText("Start &MCP Server");
        m_statusLabel->setText("MCP server stopped");
    } else {
        m_mcp->start();
        m_mcpAction->setText("Stop &MCP Server");
        m_statusLabel->setText("MCP server listening on pipe: ReclassMcpBridge");
    }
}

void MainWindow::applyTheme(const Theme& theme) {
    applyGlobalTheme(theme);

    // Separator killed via PM_DockWidgetSeparatorExtent in MenuBarStyle

    // Custom title bar
    m_titleBar->applyTheme(theme);

    // Update border overlay color
    updateBorderColor(isActiveWindow() ? theme.borderFocused : theme.border);

    // MDI area tabs
    m_mdiArea->setStyleSheet(QStringLiteral(
        "QTabBar::tab {"
        "  background: %1; color: %2; padding: 0px 16px; border: none; height: 24px;"
        "}"
        "QTabBar::tab:selected { color: %3; background: %4; }"
        "QTabBar::tab:hover { color: %3; background: %5; }")
        .arg(theme.background.name(), theme.textMuted.name(), theme.text.name(),
             theme.backgroundAlt.name(), theme.hover.name()));

    // Re-style ✕ close buttons on MDI tabs
    styleTabCloseButtons();

    // Status bar
    {
        QPalette sbPal = statusBar()->palette();
        sbPal.setColor(QPalette::Window, theme.background);
        sbPal.setColor(QPalette::WindowText, theme.textDim);
        statusBar()->setPalette(sbPal);
    }
    // View toggle buttons + status bar chrome
    {
        auto applyColors = [&](ViewTabButton* btn) {
            btn->colBg        = theme.background;
            btn->colBgChecked = theme.backgroundAlt;
            btn->colBgHover   = theme.hover;
            btn->colBgPressed = theme.hover.darker(130);
            btn->colText      = theme.text;
            btn->colTextMuted = theme.textMuted;
            btn->colAccent    = theme.indHoverSpan;
            btn->colBorder    = theme.border;
            btn->update();
        };
        applyColors(static_cast<ViewTabButton*>(m_btnReclass));
        applyColors(static_cast<ViewTabButton*>(m_btnRendered));

        {   auto* fsb = static_cast<FlatStatusBar*>(statusBar());
            fsb->setTopLineColor(theme.border);
            fsb->setDividerColor(theme.border);
        }
    }
    // Resize grip (direct child of main window, not in status bar)
    if (auto* w = findChild<QWidget*>("resizeGrip"))
        static_cast<ResizeGrip*>(w)->setGripColor(theme.textFaint);

    // Workspace tree: colors from theme (selection + text)
    if (m_workspaceTree) {
        QPalette tp = m_workspaceTree->palette();
        tp.setColor(QPalette::Text, theme.textDim);
        tp.setColor(QPalette::Highlight, theme.hover);
        tp.setColor(QPalette::HighlightedText, theme.text);
        m_workspaceTree->setPalette(tp);
    }

    // Dock titlebar: restyle via palette + close button
    if (m_dockTitleLabel) {
        QPalette lp = m_dockTitleLabel->palette();
        lp.setColor(QPalette::WindowText, theme.textDim);
        m_dockTitleLabel->setPalette(lp);
    }
    if (auto* titleBar = m_workspaceDock ? m_workspaceDock->titleBarWidget() : nullptr) {
        QPalette tbPal = titleBar->palette();
        tbPal.setColor(QPalette::Window, theme.backgroundAlt);
        titleBar->setPalette(tbPal);
    }
    if (m_dockCloseBtn)
        m_dockCloseBtn->setStyleSheet(QStringLiteral(
            "QToolButton { color: %1; border: none; padding: 0px 4px 2px 4px; font-size: 12px; }"
            "QToolButton:hover { color: %2; }")
            .arg(theme.textDim.name(), theme.indHoverSpan.name()));

    // Rendered C/C++ views: update lexer colors, paper, margins
    for (auto& tab : m_tabs) {
        for (auto& pane : tab.panes) {
            auto* sci = pane.rendered;
            if (!sci) continue;
            if (auto* lexer = qobject_cast<QsciLexerCPP*>(sci->lexer())) {
                lexer->setColor(theme.syntaxKeyword, QsciLexerCPP::Keyword);
                lexer->setColor(theme.syntaxKeyword, QsciLexerCPP::KeywordSet2);
                lexer->setColor(theme.syntaxNumber, QsciLexerCPP::Number);
                lexer->setColor(theme.syntaxString, QsciLexerCPP::DoubleQuotedString);
                lexer->setColor(theme.syntaxString, QsciLexerCPP::SingleQuotedString);
                lexer->setColor(theme.syntaxComment, QsciLexerCPP::Comment);
                lexer->setColor(theme.syntaxComment, QsciLexerCPP::CommentLine);
                lexer->setColor(theme.syntaxComment, QsciLexerCPP::CommentDoc);
                lexer->setColor(theme.text, QsciLexerCPP::Default);
                lexer->setColor(theme.text, QsciLexerCPP::Identifier);
                lexer->setColor(theme.syntaxPreproc, QsciLexerCPP::PreProcessor);
                lexer->setColor(theme.text, QsciLexerCPP::Operator);
                for (int i = 0; i <= 127; i++)
                    lexer->setPaper(theme.background, i);
            }
            sci->setPaper(theme.background);
            sci->setColor(theme.text);
            sci->setCaretForegroundColor(theme.text);
            sci->setCaretLineBackgroundColor(theme.hover);
            sci->setSelectionBackgroundColor(theme.selection);
            sci->setSelectionForegroundColor(theme.text);
            sci->setMarginsBackgroundColor(theme.backgroundAlt);
            sci->setMarginsForegroundColor(theme.textDim);
        }
    }
}

void MainWindow::editTheme() {
    auto& tm = ThemeManager::instance();
    int idx = tm.currentIndex();
    ThemeEditor dlg(idx, this);
    if (dlg.exec() == QDialog::Accepted) {
        tm.updateTheme(dlg.selectedIndex(), dlg.result());
    } else {
        tm.revertPreview();
    }
}

// TODO: when adding more and more options, this func becomes very clunky. Fix
void MainWindow::showOptionsDialog() {
    auto& tm = ThemeManager::instance();
    OptionsResult current;
    current.themeIndex = tm.currentIndex();
    current.fontName = QSettings("Reclass", "Reclass").value("font", "JetBrains Mono").toString();
    current.menuBarTitleCase = m_titleBar->menuBarTitleCase();
    current.showIcon = QSettings("Reclass", "Reclass").value("showIcon", false).toBool();
    current.safeMode = QSettings("Reclass", "Reclass").value("safeMode", false).toBool();
    current.autoStartMcp = QSettings("Reclass", "Reclass").value("autoStartMcp", false).toBool();
    current.refreshMs = QSettings("Reclass", "Reclass").value("refreshMs", 660).toInt();

    OptionsDialog dlg(current, this);
    if (dlg.exec() != QDialog::Accepted) return; // OptionsDialog doesn't apply anything. Only apply on OK

    auto r = dlg.result();

    if (r.themeIndex != current.themeIndex)
        tm.setCurrent(r.themeIndex);

    if (r.fontName != current.fontName)
        setEditorFont(r.fontName);

    if (r.menuBarTitleCase != current.menuBarTitleCase) {
        m_titleBar->setMenuBarTitleCase(r.menuBarTitleCase);
        QSettings("Reclass", "Reclass").setValue("menuBarTitleCase", r.menuBarTitleCase);
    }

    if (r.showIcon != current.showIcon) {
        m_titleBar->setShowIcon(r.showIcon);
        QSettings("Reclass", "Reclass").setValue("showIcon", r.showIcon);
    }

    if (r.safeMode != current.safeMode)
        QSettings("Reclass", "Reclass").setValue("safeMode", r.safeMode);

    if (r.autoStartMcp != current.autoStartMcp)
        QSettings("Reclass", "Reclass").setValue("autoStartMcp", r.autoStartMcp);

    if (r.refreshMs != current.refreshMs) {
        QSettings("Reclass", "Reclass").setValue("refreshMs", r.refreshMs);
        for (auto& tab : m_tabs)
            tab.ctrl->setRefreshInterval(r.refreshMs);
    }
}

void MainWindow::setEditorFont(const QString& fontName) {
    QSettings settings("Reclass", "Reclass");
    settings.setValue("font", fontName);
    QFont f(fontName, 12);
    f.setFixedPitch(true);
    for (auto& state : m_tabs) {
        state.ctrl->setEditorFont(fontName);
        for (auto& pane : state.panes) {
            // Update rendered view font
            if (pane.rendered) {
                pane.rendered->setFont(f);
                if (auto* lex = pane.rendered->lexer()) {
                    lex->setFont(f);
                    for (int i = 0; i <= 127; i++)
                        lex->setFont(f, i);
                }
                pane.rendered->setMarginsFont(f);
            }
        }
    }
    // Sync workspace tree font
    if (m_workspaceTree)
        m_workspaceTree->setFont(f);
    // Sync dock titlebar font
    if (m_dockTitleLabel)
        m_dockTitleLabel->setFont(f);
}

RcxController* MainWindow::activeController() const {
    auto* sub = m_mdiArea->activeSubWindow();
    if (sub && m_tabs.contains(sub))
        return m_tabs[sub].ctrl;
    return nullptr;
}

MainWindow::TabState* MainWindow::activeTab() {
    auto* sub = m_mdiArea->activeSubWindow();
    if (sub && m_tabs.contains(sub))
        return &m_tabs[sub];
    return nullptr;
}

MainWindow::TabState* MainWindow::tabByIndex(int index) {
    auto subs = m_mdiArea->subWindowList();
    if (index < 0 || index >= subs.size()) return nullptr;
    auto* sub = subs[index];
    if (m_tabs.contains(sub))
        return &m_tabs[sub];
    return nullptr;
}

void MainWindow::updateWindowTitle() {
    QString title;
    auto* sub = m_mdiArea->activeSubWindow();
    if (sub && m_tabs.contains(sub)) {
        auto& tab = m_tabs[sub];
        QString name = tab.doc->filePath.isEmpty()
                       ? rootName(tab.doc->tree, tab.ctrl->viewRootId())
                       : QFileInfo(tab.doc->filePath).fileName();
        if (tab.doc->modified) name += " *";
        title = name + " - Reclass";
    } else {
        title = "Reclass";
    }
    setWindowTitle(title);
}

// ── Rendered view setup ──

void MainWindow::setupRenderedSci(QsciScintilla* sci) {
    QSettings settings("Reclass", "Reclass");
    QString fontName = settings.value("font", "JetBrains Mono").toString();
    QFont f(fontName, 12);
    f.setFixedPitch(true);

    sci->setFont(f);
    sci->setReadOnly(false);
    sci->setWrapMode(QsciScintilla::WrapNone);
    sci->setTabWidth(4);
    sci->setIndentationsUseTabs(false);
    sci->SendScintilla(QsciScintillaBase::SCI_SETEXTRAASCENT, (long)2);
    sci->SendScintilla(QsciScintillaBase::SCI_SETEXTRADESCENT, (long)2);

    // Line number margin
    sci->setMarginType(0, QsciScintilla::NumberMargin);
    sci->setMarginWidth(0, "00000");
    const auto& theme = ThemeManager::instance().current();
    sci->setMarginsBackgroundColor(theme.backgroundAlt);
    sci->setMarginsForegroundColor(theme.textDim);
    sci->setMarginsFont(f);

    // Hide other margins
    sci->setMarginWidth(1, 0);
    sci->setMarginWidth(2, 0);

    // C++ lexer for syntax highlighting — must be set BEFORE colors below,
    // because setLexer() resets caret line, selection, and paper colors.
    auto* lexer = new QsciLexerCPP(sci);
    lexer->setFont(f);
    lexer->setColor(theme.syntaxKeyword, QsciLexerCPP::Keyword);
    lexer->setColor(theme.syntaxKeyword, QsciLexerCPP::KeywordSet2);
    lexer->setColor(theme.syntaxNumber, QsciLexerCPP::Number);
    lexer->setColor(theme.syntaxString, QsciLexerCPP::DoubleQuotedString);
    lexer->setColor(theme.syntaxString, QsciLexerCPP::SingleQuotedString);
    lexer->setColor(theme.syntaxComment, QsciLexerCPP::Comment);
    lexer->setColor(theme.syntaxComment, QsciLexerCPP::CommentLine);
    lexer->setColor(theme.syntaxComment, QsciLexerCPP::CommentDoc);
    lexer->setColor(theme.text, QsciLexerCPP::Default);
    lexer->setColor(theme.text, QsciLexerCPP::Identifier);
    lexer->setColor(theme.syntaxPreproc, QsciLexerCPP::PreProcessor);
    lexer->setColor(theme.text, QsciLexerCPP::Operator);
    for (int i = 0; i <= 127; i++) {
        lexer->setPaper(theme.background, i);
        lexer->setFont(f, i);
    }
    sci->setLexer(lexer);
    sci->setBraceMatching(QsciScintilla::NoBraceMatch);

    // Colors applied AFTER setLexer() — the lexer resets these on attach
    sci->setPaper(theme.background);
    sci->setColor(theme.text);
    sci->setCaretForegroundColor(theme.text);
    sci->setCaretLineVisible(true);
    sci->setCaretLineBackgroundColor(theme.hover);
    sci->setSelectionBackgroundColor(theme.selection);
    sci->setSelectionForegroundColor(theme.text);
}

// ── View mode / generator switching ──

void MainWindow::setViewMode(ViewMode mode) {
    auto* pane = findActiveSplitPane();
    if (!pane) return;
    pane->viewMode = mode;
    int idx = (mode == VM_Rendered) ? 1 : 0;
    pane->tabWidget->setCurrentIndex(idx);
    syncViewButtons(mode);
}

void MainWindow::syncViewButtons(ViewMode mode) {
    QSignalBlocker block(m_viewBtnGroup);
    if (mode == VM_Rendered) m_btnRendered->setChecked(true);
    else                     m_btnReclass->setChecked(true);
}

// ── Find the root-level struct ancestor for a node ──

uint64_t MainWindow::findRootStructForNode(const NodeTree& tree, uint64_t nodeId) const {
    QSet<uint64_t> visited;
    uint64_t cur = nodeId;
    uint64_t lastStruct = 0;
    while (cur != 0 && !visited.contains(cur)) {
        visited.insert(cur);
        int idx = tree.indexOfId(cur);
        if (idx < 0) break;
        const Node& n = tree.nodes[idx];
        if (n.kind == NodeKind::Struct)
            lastStruct = n.id;
        if (n.parentId == 0)
            return (n.kind == NodeKind::Struct) ? n.id : lastStruct;
        cur = n.parentId;
    }
    return lastStruct;
}

// ── Update the rendered view for a single pane ──

void MainWindow::updateRenderedView(TabState& tab, SplitPane& pane) {
    if (pane.viewMode != VM_Rendered) return;
    if (!pane.rendered) return;

    // Determine which struct to render based on selection
    uint64_t rootId = 0;
    QSet<uint64_t> selIds = tab.ctrl->selectedIds();
    if (selIds.size() >= 1) {
        uint64_t selId = *selIds.begin();
        selId &= ~kFooterIdBit;
        rootId = findRootStructForNode(tab.doc->tree, selId);
    }

    // Generate text
    const QHash<NodeKind, QString>* aliases =
        tab.doc->typeAliases.isEmpty() ? nullptr : &tab.doc->typeAliases;
    QString text;
    if (rootId != 0)
        text = renderCpp(tab.doc->tree, rootId, aliases);
    else
        text = renderCppAll(tab.doc->tree, aliases);

    // Scroll restoration: save if same root, reset if different
    int restoreLine = 0;
    if (rootId != 0 && rootId == pane.lastRenderedRootId) {
        restoreLine = (int)pane.rendered->SendScintilla(
            QsciScintillaBase::SCI_GETFIRSTVISIBLELINE);
    }
    pane.lastRenderedRootId = rootId;

    // Set text
    pane.rendered->setText(text);

    // Update margin width for line count
    int lineCount = pane.rendered->lines();
    QString marginStr = QString(QString::number(lineCount).size() + 2, '0');
    pane.rendered->setMarginWidth(0, marginStr);

    // Restore scroll
    if (restoreLine > 0) {
        pane.rendered->SendScintilla(QsciScintillaBase::SCI_SETFIRSTVISIBLELINE,
                                     (unsigned long)restoreLine);
    }
}

void MainWindow::updateAllRenderedPanes(TabState& tab) {
    for (auto& pane : tab.panes) {
        if (pane.viewMode == VM_Rendered)
            updateRenderedView(tab, pane);
    }
}

// ── Export C++ header to file ──

void MainWindow::exportCpp() {
    auto* tab = activeTab();
    if (!tab) return;

    QString path = QFileDialog::getSaveFileName(this,
        "Export C++ Header", {}, "C++ Header (*.h);;All Files (*)");
    if (path.isEmpty()) return;

    const QHash<NodeKind, QString>* aliases =
        tab->doc->typeAliases.isEmpty() ? nullptr : &tab->doc->typeAliases;
    QString text = renderCppAll(tab->doc->tree, aliases);
    QFile file(path);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QMessageBox::warning(this, "Export Failed",
            "Could not write to: " + path);
        return;
    }
    file.write(text.toUtf8());
    m_statusLabel->setText("Exported to " + QFileInfo(path).fileName());
}

// ── Export ReClass XML ──

void MainWindow::exportReclassXmlAction() {
    auto* tab = activeTab();
    if (!tab) return;

    QString path = QFileDialog::getSaveFileName(this,
        "Export ReClass XML", {}, "ReClass XML (*.reclass);;All Files (*)");
    if (path.isEmpty()) return;

    QString error;
    if (!rcx::exportReclassXml(tab->doc->tree, path, &error)) {
        QMessageBox::warning(this, "Export Failed",
            error.isEmpty() ? QStringLiteral("Could not export") : error);
        return;
    }

    int classCount = 0;
    for (const auto& n : tab->doc->tree.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) classCount++;

    m_statusLabel->setText(QStringLiteral("Exported %1 classes to %2")
        .arg(classCount).arg(QFileInfo(path).fileName()));
}

// ── Import ReClass XML ──

void MainWindow::importReclassXml() {
    QString filePath = QFileDialog::getOpenFileName(this,
        "Import ReClass XML", {},
        "ReClass XML (*.reclass *.MemeCls *.xml);;All Files (*)");
    if (filePath.isEmpty()) return;

    QString error;
    NodeTree tree = rcx::importReclassXml(filePath, &error);
    if (tree.nodes.isEmpty()) {
        QMessageBox::warning(this, "Import Failed", error.isEmpty()
            ? QStringLiteral("No data found in file") : error);
        return;
    }

    // Count root structs for status message
    int classCount = 0;
    for (const auto& n : tree.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) classCount++;

    auto* doc = new RcxDocument(this);
    doc->tree = std::move(tree);

    m_mdiArea->closeAllSubWindows();
    createTab(doc);
    rebuildWorkspaceModel();
    m_statusLabel->setText(QStringLiteral("Imported %1 classes from %2")
        .arg(classCount).arg(QFileInfo(filePath).fileName()));
}

// ── Import from Source ──

void MainWindow::importFromSource() {
    QDialog dlg(this);
    dlg.setWindowTitle("Import from Source");
    dlg.resize(700, 600);

    auto* layout = new QVBoxLayout(&dlg);

    auto* sci = new QsciScintilla(&dlg);
    setupRenderedSci(sci);
    sci->setReadOnly(false);
    sci->setMarginWidth(0, "00000");
    layout->addWidget(sci);

    auto* buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, &dlg);
    buttons->button(QDialogButtonBox::Ok)->setText("Import");
    layout->addWidget(buttons);

    connect(buttons, &QDialogButtonBox::accepted, &dlg, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, &dlg, &QDialog::reject);

    if (dlg.exec() != QDialog::Accepted) return;

    QString source = sci->text();
    if (source.trimmed().isEmpty()) return;

    QString error;
    NodeTree tree = rcx::importFromSource(source, &error);
    if (tree.nodes.isEmpty()) {
        QMessageBox::warning(this, "Import Failed", error.isEmpty()
            ? QStringLiteral("No struct definitions found") : error);
        return;
    }

    int classCount = 0;
    for (const auto& n : tree.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) classCount++;

    auto* doc = new RcxDocument(this);
    doc->tree = std::move(tree);

    m_mdiArea->closeAllSubWindows();
    createTab(doc);
    rebuildWorkspaceModel();
    m_workspaceDock->show();
    m_statusLabel->setText(QStringLiteral("Imported %1 classes from source").arg(classCount));
}

// ── Import PDB ──

void MainWindow::importPdb() {
    rcx::PdbImportDialog dlg(this);
    if (dlg.exec() != QDialog::Accepted) return;

    QString pdbPath = dlg.pdbPath();
    QVector<uint32_t> indices = dlg.selectedTypeIndices();
    if (indices.isEmpty()) return;

    QProgressDialog progress("Importing types...", "Cancel", 0, indices.size(), this);
    progress.setWindowModality(Qt::WindowModal);
    progress.setMinimumDuration(200);
    bool cancelled = false;

    QString error;
    NodeTree tree = rcx::importPdbSelected(pdbPath, indices, &error,
        [&](int current, int total) -> bool {
            progress.setMaximum(total);
            progress.setValue(current);
            QApplication::processEvents();
            if (progress.wasCanceled()) {
                cancelled = true;
                return false;
            }
            return true;
        });
    progress.close();

    if (tree.nodes.isEmpty()) {
        if (!cancelled)
            QMessageBox::warning(this, "Import Failed", error.isEmpty()
                ? QStringLiteral("No types imported") : error);
        return;
    }

    int classCount = 0;
    for (const auto& n : tree.nodes)
        if (n.parentId == 0 && n.kind == rcx::NodeKind::Struct) classCount++;

    auto* doc = new rcx::RcxDocument(this);
    doc->tree = std::move(tree);

    m_mdiArea->closeAllSubWindows();
    createTab(doc);
    rebuildWorkspaceModel();
    m_workspaceDock->show();
    m_statusLabel->setText(QStringLiteral("Imported %1 classes from %2")
        .arg(classCount).arg(QFileInfo(pdbPath).fileName()));
}

// ── Type Aliases Dialog ──

void MainWindow::showTypeAliasesDialog() {
    auto* tab = activeTab();
    if (!tab) return;

    QDialog dlg(this);
    dlg.setWindowTitle("Type Aliases");
    dlg.resize(500, 400);

    auto* layout = new QVBoxLayout(&dlg);

    auto* table = new QTableWidget(&dlg);
    table->setColumnCount(2);
    table->setHorizontalHeaderLabels({"NodeKind", "Alias (C type)"});
    table->horizontalHeader()->setStretchLastSection(true);
    table->horizontalHeader()->setSectionResizeMode(0, QHeaderView::ResizeToContents);
    table->setSelectionMode(QAbstractItemView::SingleSelection);

    // Populate with all NodeKind entries
    int rowCount = static_cast<int>(std::size(kKindMeta));
    table->setRowCount(rowCount);
    for (int i = 0; i < rowCount; i++) {
        const auto& meta = kKindMeta[i];
        auto* kindItem = new QTableWidgetItem(QString::fromLatin1(meta.name));
        kindItem->setFlags(kindItem->flags() & ~Qt::ItemIsEditable);
        table->setItem(i, 0, kindItem);

        QString alias = tab->doc->typeAliases.value(meta.kind);
        table->setItem(i, 1, new QTableWidgetItem(alias));
    }

    layout->addWidget(table);

    auto* buttons = new QDialogButtonBox(
        QDialogButtonBox::Ok | QDialogButtonBox::Cancel, &dlg);
    layout->addWidget(buttons);

    connect(buttons, &QDialogButtonBox::accepted, &dlg, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, &dlg, &QDialog::reject);

    if (dlg.exec() != QDialog::Accepted) return;

    // Collect new aliases
    QHash<NodeKind, QString> newAliases;
    for (int i = 0; i < rowCount; i++) {
        QString val = table->item(i, 1)->text().trimmed();
        if (!val.isEmpty())
            newAliases[kKindMeta[i].kind] = val;
    }

    tab->doc->typeAliases = newAliases;
    tab->doc->modified = true;
    tab->ctrl->refresh();
    updateWindowTitle();
}

// ── Project Lifecycle API ──

QMdiSubWindow* MainWindow::project_new(const QString& classKeyword) {
    auto* doc = new RcxDocument(this);

    QByteArray data(256, '\0');
    doc->loadData(data);
    doc->tree.baseAddress = 0x00400000;

    buildEmptyStruct(doc->tree, classKeyword);

    // Inherit source from current tab (if any)
    auto* currentCtrl = activeController();
    if (currentCtrl && currentCtrl->document()->provider
        && currentCtrl->document()->provider->isValid()) {
        doc->provider = currentCtrl->document()->provider;
    }

    auto* sub = createTab(doc);

    // Copy saved sources to new tab's controller
    if (currentCtrl && !currentCtrl->savedSources().isEmpty()) {
        auto& newTab = m_tabs[sub];
        newTab.ctrl->copySavedSources(currentCtrl->savedSources(),
                                       currentCtrl->activeSourceIndex());
    }

    rebuildWorkspaceModel();
    return sub;
}

QMdiSubWindow* MainWindow::project_open(const QString& path) {
    QString filePath = path;
    if (filePath.isEmpty()) {
        filePath = QFileDialog::getOpenFileName(this,
            "Open Definition", {},
            "All Supported (*.rcx *.json *.reclass *.MemeCls *.xml)"
            ";;Reclass (*.rcx)"
            ";;JSON (*.json)"
            ";;ReClass XML (*.reclass *.MemeCls *.xml)"
            ";;All (*)");
        if (filePath.isEmpty()) return nullptr;
    }

    // Detect if this is an XML-based ReClass file by checking first bytes
    bool isXml = false;
    {
        QFile probe(filePath);
        if (probe.open(QIODevice::ReadOnly)) {
            QByteArray head = probe.read(64);
            isXml = head.trimmed().startsWith("<?xml") || head.trimmed().startsWith("<ReClass")
                    || head.trimmed().startsWith("<MemeCls");
        }
    }

    if (isXml) {
        QString error;
        NodeTree tree = rcx::importReclassXml(filePath, &error);
        if (tree.nodes.isEmpty()) {
            QMessageBox::warning(this, "Import Failed", error.isEmpty()
                ? QStringLiteral("No data found in file") : error);
            return nullptr;
        }
        auto* doc = new RcxDocument(this);
        doc->tree = std::move(tree);
        m_mdiArea->closeAllSubWindows();
        auto* sub = createTab(doc);
        rebuildWorkspaceModel();
        m_workspaceDock->show();
        int classCount = 0;
        for (const auto& n : doc->tree.nodes)
            if (n.parentId == 0 && n.kind == NodeKind::Struct) classCount++;
        m_statusLabel->setText(QStringLiteral("Imported %1 classes from %2")
            .arg(classCount).arg(QFileInfo(filePath).fileName()));
        return sub;
    }

    auto* doc = new RcxDocument(this);
    if (!doc->load(filePath)) {
        QMessageBox::warning(this, "Error", "Failed to load: " + filePath);
        delete doc;
        return nullptr;
    }

    // Close all existing tabs so the project replaces the current state
    m_mdiArea->closeAllSubWindows();

    auto* sub = createTab(doc);
    rebuildWorkspaceModel();
    m_workspaceDock->show();
    return sub;
}

bool MainWindow::project_save(QMdiSubWindow* sub, bool saveAs) {
    if (!sub) sub = m_mdiArea->activeSubWindow();
    if (!sub || !m_tabs.contains(sub)) return false;
    auto& tab = m_tabs[sub];

    if (saveAs || tab.doc->filePath.isEmpty()) {
        QString path = QFileDialog::getSaveFileName(this,
            "Save Definition", {}, "Reclass (*.rcx);;JSON (*.json)");
        if (path.isEmpty()) return false;
        tab.doc->save(path);
    } else {
        tab.doc->save(tab.doc->filePath);
    }
    updateWindowTitle();
    return true;
}

void MainWindow::project_close(QMdiSubWindow* sub) {
    if (!sub) sub = m_mdiArea->activeSubWindow();
    if (!sub) return;
    sub->close();
    rebuildWorkspaceModel();
}

// ── Workspace Dock ──

void MainWindow::createWorkspaceDock() {
    m_workspaceDock = new QDockWidget("Project", this);
    m_workspaceDock->setObjectName("WorkspaceDock");
    m_workspaceDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    m_workspaceDock->setFeatures(QDockWidget::DockWidgetClosable | QDockWidget::DockWidgetMovable);

    // Custom titlebar: label + ✕ close button (matches MDI tab style)
    {
        const auto& t = ThemeManager::instance().current();

        auto* titleBar = new QWidget(m_workspaceDock);
        titleBar->setAutoFillBackground(true);
        {
            QPalette tbPal = titleBar->palette();
            tbPal.setColor(QPalette::Window, t.backgroundAlt);
            titleBar->setPalette(tbPal);
        }
        auto* layout = new QHBoxLayout(titleBar);
        layout->setContentsMargins(6, 2, 2, 2);
        layout->setSpacing(0);

        m_dockTitleLabel = new QLabel("Project", titleBar);
        {
            QPalette lp = m_dockTitleLabel->palette();
            lp.setColor(QPalette::WindowText, t.textDim);
            m_dockTitleLabel->setPalette(lp);
        }
        layout->addWidget(m_dockTitleLabel);

        layout->addStretch();

        m_dockCloseBtn = new QToolButton(titleBar);
        m_dockCloseBtn->setText(QStringLiteral("\u2715"));
        m_dockCloseBtn->setAutoRaise(true);
        m_dockCloseBtn->setCursor(Qt::PointingHandCursor);
        m_dockCloseBtn->setStyleSheet(QStringLiteral(
            "QToolButton { color: %1; border: none; padding: 0px 4px 2px 4px; font-size: 12px; }"
            "QToolButton:hover { color: %2; }")
            .arg(t.textDim.name(), t.indHoverSpan.name()));
        connect(m_dockCloseBtn, &QToolButton::clicked, m_workspaceDock, &QDockWidget::close);
        layout->addWidget(m_dockCloseBtn);

        m_workspaceDock->setTitleBarWidget(titleBar);
    }

    m_workspaceTree = new QTreeView(m_workspaceDock);
    m_workspaceModel = new QStandardItemModel(this);
    m_workspaceModel->setHorizontalHeaderLabels({"Name"});
    m_workspaceTree->setModel(m_workspaceModel);
    m_workspaceTree->setHeaderHidden(true);
    m_workspaceTree->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_workspaceTree->setExpandsOnDoubleClick(false);
    m_workspaceTree->setMouseTracking(true);

    // Override palette: selection + hover use theme colors (not default blue)
    {
        const auto& t = ThemeManager::instance().current();
        QPalette tp = m_workspaceTree->palette();
        tp.setColor(QPalette::Text, t.textDim);
        tp.setColor(QPalette::Highlight, t.hover);
        tp.setColor(QPalette::HighlightedText, t.text);
        m_workspaceTree->setPalette(tp);
    }

    m_workspaceTree->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_workspaceTree, &QWidget::customContextMenuRequested, this, [this](const QPoint& pos) {
        QModelIndex index = m_workspaceTree->indexAt(pos);
        if (!index.isValid()) return;

        auto structIdVar = index.data(Qt::UserRole + 1);
        uint64_t structId = structIdVar.isValid() ? structIdVar.toULongLong() : 0;

        // Right-click on "Project" group → New Class / New Struct / New Enum
        if (structId == rcx::kGroupSentinel) {
            QMenu menu;
            auto* actClass  = menu.addAction("New Class");
            auto* actStruct = menu.addAction("New Struct");
            auto* actEnum   = menu.addAction("New Enum");
            QAction* chosen = menu.exec(m_workspaceTree->viewport()->mapToGlobal(pos));
            if (chosen == actClass)       newClass();
            else if (chosen == actStruct) newStruct();
            else if (chosen == actEnum)   newEnum();
            return;
        }

        if (structId == 0) return;

        auto subVar = index.data(Qt::UserRole);
        if (!subVar.isValid()) return;
        auto* sub = static_cast<QMdiSubWindow*>(subVar.value<void*>());
        if (!sub || !m_tabs.contains(sub)) return;

        auto& tab = m_tabs[sub];
        int ni = tab.doc->tree.indexOfId(structId);
        if (ni < 0) return;
        QString kw = tab.doc->tree.nodes[ni].resolvedClassKeyword();

        QMenu menu;
        QAction* actConvert = nullptr;
        // class↔struct conversion only (no enum conversion)
        if (kw == QStringLiteral("class"))
            actConvert = menu.addAction("Convert to Struct");
        else if (kw == QStringLiteral("struct"))
            actConvert = menu.addAction("Convert to Class");
        auto* actDelete = menu.addAction(QIcon(":/vsicons/remove.svg"), "Delete");

        QAction* chosen = menu.exec(m_workspaceTree->viewport()->mapToGlobal(pos));
        if (chosen == actDelete) {
            QString typeName = tab.doc->tree.nodes[ni].structTypeName.isEmpty()
                ? tab.doc->tree.nodes[ni].name
                : tab.doc->tree.nodes[ni].structTypeName;
            if (typeName.isEmpty()) typeName = QStringLiteral("(unnamed)");

            // Collect detailed reference info
            QStringList refDetails;
            for (const auto& n : tab.doc->tree.nodes) {
                if (n.refId == structId) {
                    QString ownerName;
                    uint64_t pid = n.parentId;
                    while (pid != 0) {
                        int pi = tab.doc->tree.indexOfId(pid);
                        if (pi < 0) break;
                        if (tab.doc->tree.nodes[pi].parentId == 0) {
                            ownerName = tab.doc->tree.nodes[pi].structTypeName.isEmpty()
                                ? tab.doc->tree.nodes[pi].name
                                : tab.doc->tree.nodes[pi].structTypeName;
                            break;
                        }
                        pid = tab.doc->tree.nodes[pi].parentId;
                    }
                    QString fieldDesc = ownerName.isEmpty()
                        ? n.name
                        : QStringLiteral("%1::%2").arg(ownerName, n.name);
                    refDetails << QStringLiteral("  \u2022 %1 (%2)")
                        .arg(fieldDesc, kindToString(n.kind));
                }
            }

            QString msg;
            if (refDetails.isEmpty()) {
                msg = QString("Delete '%1'?").arg(typeName);
            } else {
                msg = QString("Delete '%1'?\n\n"
                              "The following %2 field(s) reference this type "
                              "and will become untyped (void):\n\n%3")
                    .arg(typeName)
                    .arg(refDetails.size())
                    .arg(refDetails.join('\n'));
            }

            auto answer = QMessageBox::question(this, "Delete Type", msg,
                QMessageBox::Yes | QMessageBox::No, QMessageBox::No);
            if (answer != QMessageBox::Yes) return;

            tab.ctrl->deleteRootStruct(structId);
            rebuildWorkspaceModel();
        } else if (chosen && chosen == actConvert) {
            QString newKw = kw == QStringLiteral("class")
                ? QStringLiteral("struct") : QStringLiteral("class");
            QString oldKw = tab.doc->tree.nodes[ni].resolvedClassKeyword();
            tab.doc->undoStack.push(new rcx::RcxCommand(tab.ctrl,
                rcx::cmd::ChangeClassKeyword{structId, oldKw, newKw}));
            rebuildWorkspaceModel();
        }
    });

    m_workspaceDock->setWidget(m_workspaceTree);
    addDockWidget(Qt::LeftDockWidgetArea, m_workspaceDock);
    m_workspaceDock->hide();

    connect(m_workspaceTree, &QTreeView::doubleClicked, this, [this](const QModelIndex& index) {
        auto structIdVar = index.data(Qt::UserRole + 1);
        uint64_t structId = structIdVar.isValid() ? structIdVar.toULongLong() : 0;

        if (structId == rcx::kGroupSentinel) {
            // "Project" folder: toggle expand/collapse
            m_workspaceTree->setExpanded(index, !m_workspaceTree->isExpanded(index));
            return;
        }

        auto subVar = index.data(Qt::UserRole);
        if (!subVar.isValid()) return;
        auto* sub = static_cast<QMdiSubWindow*>(subVar.value<void*>());
        if (!sub || !m_tabs.contains(sub)) return;

        m_mdiArea->setActiveSubWindow(sub);

        // Type/Enum node: navigate to it
        auto& tree = m_tabs[sub].doc->tree;
        int ni = tree.indexOfId(structId);
        if (ni >= 0) tree.nodes[ni].collapsed = false;
        m_tabs[sub].ctrl->setViewRootId(structId);
        m_tabs[sub].ctrl->scrollToNodeId(structId);
    });
}

void MainWindow::rebuildAllDocs() {
    m_allDocs.clear();
    for (auto it = m_tabs.begin(); it != m_tabs.end(); ++it)
        m_allDocs.append(it.value().doc);
}

void MainWindow::rebuildWorkspaceModel() {
    QVector<rcx::TabInfo> tabs;
    for (auto it = m_tabs.begin(); it != m_tabs.end(); ++it) {
        TabState& tab = it.value();
        QString name = tab.doc->filePath.isEmpty()
            ? rootName(tab.doc->tree, tab.ctrl->viewRootId())
            : QFileInfo(tab.doc->filePath).fileName();
        tabs.append({ &tab.doc->tree, name, static_cast<void*>(it.key()) });
    }
    rcx::buildProjectExplorer(m_workspaceModel, tabs);
    m_workspaceTree->expandToDepth(1);
}

void MainWindow::populateSourceMenu() {
    m_sourceMenu->clear();
    auto* ctrl = activeController();

    // Icon map for known provider identifiers
    static const QHash<QString, QString> s_providerIcons = {
        {QStringLiteral("processmemory"),          QStringLiteral(":/vsicons/server-process.svg")},
        {QStringLiteral("remoteprocessmemory"),    QStringLiteral(":/vsicons/remote.svg")},
        {QStringLiteral("windbgmemory"),           QStringLiteral(":/vsicons/debug.svg")},
        {QStringLiteral("reclass.netcompatlayer"), QStringLiteral(":/vsicons/plug.svg")},
    };

    auto addSourceAction = [this](const QString& text, const QIcon& icon, auto&& slot) {
        auto* act = m_sourceMenu->addAction(icon, text);
        act->setIconVisibleInMenu(true);
        connect(act, &QAction::triggered, this, std::forward<decltype(slot)>(slot));
        return act;
    };

    addSourceAction(QStringLiteral("File"),
                    makeIcon(QStringLiteral(":/vsicons/file-binary.svg")),
                    [this]() {
        if (auto* c = activeController()) c->selectSource(QStringLiteral("File"));
    });

    const auto& providers = ProviderRegistry::instance().providers();
    for (const auto& prov : providers) {
        QString name = prov.name;
        auto it = s_providerIcons.constFind(prov.identifier);
        QIcon icon = makeIcon(it != s_providerIcons.constEnd() ? *it
                              : QStringLiteral(":/vsicons/extensions.svg"));

        QString label = prov.dllFileName.isEmpty()
            ? name
            : QStringLiteral("%1  (%2)").arg(name, prov.dllFileName);

        addSourceAction(label, icon, [this, name]() {
            if (auto* c = activeController()) c->selectSource(name);
        });
    }

    if (ctrl && !ctrl->savedSources().isEmpty()) {
        m_sourceMenu->addSeparator();
        for (int i = 0; i < ctrl->savedSources().size(); i++) {
            const auto& e = ctrl->savedSources()[i];
            auto* act = m_sourceMenu->addAction(
                QStringLiteral("%1 '%2'").arg(e.kind, e.displayName));
            act->setCheckable(true);
            act->setChecked(i == ctrl->activeSourceIndex());
            connect(act, &QAction::triggered, this, [this, i]() {
                if (auto* c = activeController()) c->switchSource(i);
            });
        }
        m_sourceMenu->addSeparator();
        auto* clearAct = addSourceAction(QStringLiteral("Clear All"),
                        makeIcon(QStringLiteral(":/vsicons/clear-all.svg")),
                        [this]() {
            if (auto* c = activeController()) c->clearSources();
        });
        Q_UNUSED(clearAct);
    }
}

void MainWindow::showPluginsDialog() {
    QDialog dialog(this);
    dialog.setWindowTitle("Plugins");
    dialog.resize(600, 400);

    auto* layout = new QVBoxLayout(&dialog);

    auto* list = new QListWidget();
    layout->addWidget(list);

    auto refreshList = [&]() {
        list->clear();

        // Populate plugin list
        for (IPlugin* plugin : m_pluginManager.plugins()) {
            QString typeStr;
            switch (plugin->Type())
            {
            case IPlugin::ProviderPlugin: typeStr = "Provider"; break;
            default: typeStr = "Unknown"; break;
            }

            QString text = QString("%1 v%2\n  %3\n  Type: %4\n  Author: %5")
                               .arg(QString::fromStdString(plugin->Name()))
                               .arg(QString::fromStdString(plugin->Version()))
                               .arg(QString::fromStdString(plugin->Description()))
                               .arg(typeStr)
                               .arg(QString::fromStdString(plugin->Author()));

            auto* item = new QListWidgetItem(plugin->Icon(), text);
            item->setData(Qt::UserRole, QString::fromStdString(plugin->Name()));
            list->addItem(item);
        }

        if (m_pluginManager.plugins().isEmpty()) {
            list->addItem("No plugins loaded");
        }
    };

    refreshList();

    // Button row
    auto* btnLayout = new QHBoxLayout();

    auto* btnLoad = new QPushButton("Load Plugin...");
    connect(btnLoad, &QPushButton::clicked, [&, refreshList]() {
        QString path = QFileDialog::getOpenFileName(&dialog, "Load Plugin",
                                                    QCoreApplication::applicationDirPath() + "/Plugins",
                                                    "Plugins (*.dll *.so *.dylib);;All Files (*)");

        if (!path.isEmpty()) {
            if (m_pluginManager.LoadPluginFromPath(path)) {
                refreshList();
                m_statusLabel->setText("Plugin loaded successfully");
            } else {
                QMessageBox::warning(&dialog, "Failed to Load Plugin",
                                     "Could not load the selected plugin.\nCheck the console for details.");
            }
        }
    });

    auto* btnUnload = new QPushButton("Unload Selected");
    connect(btnUnload, &QPushButton::clicked, [&, list, refreshList]() {
        auto* item = list->currentItem();
        if (!item) {
            QMessageBox::information(&dialog, "No Selection", "Please select a plugin to unload.");
            return;
        }

        QString pluginName = item->data(Qt::UserRole).toString();
        if (pluginName.isEmpty()) return;

        auto reply = QMessageBox::question(&dialog, "Unload Plugin",
                                           QString("Are you sure you want to unload '%1'?").arg(pluginName),
                                           QMessageBox::Yes | QMessageBox::No);

        if (reply == QMessageBox::Yes) {
            if (m_pluginManager.UnloadPlugin(pluginName)) {
                refreshList();
                m_statusLabel->setText("Plugin unloaded");
            } else {
                QMessageBox::warning(&dialog, "Failed to Unload",
                                     "Could not unload the selected plugin.");
            }
        }
    });

    auto* btnClose = new QPushButton("Close");
    connect(btnClose, &QPushButton::clicked, &dialog, &QDialog::accept);

    btnLayout->addWidget(btnLoad);
    btnLayout->addWidget(btnUnload);
    btnLayout->addStretch();
    btnLayout->addWidget(btnClose);

    layout->addLayout(btnLayout);

    dialog.exec();
}

void MainWindow::changeEvent(QEvent* event) {
    QMainWindow::changeEvent(event);
    if (event->type() == QEvent::ActivationChange) {
        const auto& t = ThemeManager::instance().current();
        updateBorderColor(isActiveWindow() ? t.borderFocused : t.border);
    }
    if (event->type() == QEvent::WindowStateChange)
        m_titleBar->updateMaximizeIcon();
}

void MainWindow::resizeEvent(QResizeEvent* event) {
    QMainWindow::resizeEvent(event);
    if (m_borderOverlay) {
        m_borderOverlay->setGeometry(rect());
        m_borderOverlay->raise();
    }
    if (auto* w = findChild<QWidget*>("resizeGrip")) {
        auto* grip = static_cast<ResizeGrip*>(w);
        grip->reposition();
        grip->raise();
    }
}

void MainWindow::updateBorderColor(const QColor& color) {
    static_cast<BorderOverlay*>(m_borderOverlay)->color = color;
    m_borderOverlay->update();
}

} // namespace rcx

// ── Entry point ──

int main(int argc, char* argv[]) {
#ifdef _WIN32
    SetUnhandledExceptionFilter(crashHandler);
#endif

    DarkApp app(argc, argv);
    app.setApplicationName("Reclass");
    app.setOrganizationName("Reclass");
    app.setStyle(new MenuBarStyle("Fusion")); // Fusion + generous menu sizing

    // Load embedded fonts
    int fontId = QFontDatabase::addApplicationFont(":/fonts/JetBrainsMono.ttf");
    if (fontId == -1)
        qWarning("Failed to load embedded JetBrains Mono font");
    // Apply saved font preference before creating any editors
    {
        QSettings settings("Reclass", "Reclass");
        QString savedFont = settings.value("font", "JetBrains Mono").toString();
        rcx::RcxEditor::setGlobalFontName(savedFont);
    }

    // Global theme
    applyGlobalTheme(rcx::ThemeManager::instance().current());

    rcx::MainWindow window;
    window.setWindowIcon(QIcon(":/icons/class.png"));

    window.show();

    // Auto-open demo project from saved .rcx file
    QMetaObject::invokeMethod(&window, "selfTest");

    return app.exec();
}

// MainWindow Q_OBJECT is now in mainwindow.h; AUTOMOC handles moc generation.

```

`src/mainwindow.h`:

```h
#pragma once
#include "controller.h"
#include "titlebar.h"
#include "pluginmanager.h"
#include <QMainWindow>
#include <QMdiArea>
#include <QMdiSubWindow>
#include <QLabel>
#include <QSplitter>
#include <QTabWidget>
#include <QDockWidget>
#include <QTreeView>
#include <QStandardItemModel>
#include <QMap>
#include <QButtonGroup>
#include <QPushButton>
#include <Qsci/qsciscintilla.h>

namespace rcx {

class McpBridge;

class MainWindow : public QMainWindow {
    Q_OBJECT
    friend class McpBridge;
public:
    explicit MainWindow(QWidget* parent = nullptr);

private slots:
    void newClass();
    void newStruct();
    void newEnum();
    void selfTest();
    void openFile();
    void saveFile();
    void saveFileAs();
    void closeFile();

    void addNode();
    void removeNode();
    void changeNodeType();
    void renameNodeAction();
    void duplicateNodeAction();
    void splitView();
    void unsplitView();

    void undo();
    void redo();
    void about();
    void toggleMcp();
    void setEditorFont(const QString& fontName);
    void exportCpp();
    void exportReclassXmlAction();
    void importFromSource();
    void importReclassXml();
    void importPdb();
    void showTypeAliasesDialog();
    void editTheme();
    void showOptionsDialog();

public:
    // Project Lifecycle API
    QMdiSubWindow* project_new(const QString& classKeyword = QString());
    QMdiSubWindow* project_open(const QString& path = {});
    bool project_save(QMdiSubWindow* sub = nullptr, bool saveAs = false);
    void project_close(QMdiSubWindow* sub = nullptr);

private:
    enum ViewMode { VM_Reclass, VM_Rendered };

    QMdiArea*       m_mdiArea;
    QLabel*         m_statusLabel;
    QButtonGroup*   m_viewBtnGroup = nullptr;
    QPushButton*    m_btnReclass   = nullptr;
    QPushButton*    m_btnRendered  = nullptr;
    TitleBarWidget* m_titleBar = nullptr;
    QWidget*        m_borderOverlay = nullptr;
    PluginManager   m_pluginManager;
    McpBridge*      m_mcp       = nullptr;
    QAction*        m_mcpAction = nullptr;
    QMenu*          m_sourceMenu = nullptr;

    struct SplitPane {
        QTabWidget*    tabWidget = nullptr;
        RcxEditor*     editor    = nullptr;
        QsciScintilla* rendered  = nullptr;
        ViewMode       viewMode  = VM_Reclass;
        uint64_t       lastRenderedRootId = 0;
    };

    struct TabState {
        RcxDocument*       doc;
        RcxController*     ctrl;
        QSplitter*         splitter;
        QVector<SplitPane> panes;
        int                activePaneIdx = 0;
    };
    QMap<QMdiSubWindow*, TabState> m_tabs;
    QVector<RcxDocument*> m_allDocs;  // all open docs, shared with controllers
    void rebuildAllDocs();

    void createMenus();
    void createStatusBar();
    void showPluginsDialog();
    void populateSourceMenu();
    QIcon makeIcon(const QString& svgPath);

    RcxController* activeController() const;
    TabState* activeTab();
    TabState* tabByIndex(int index);
    int tabCount() const { return m_tabs.size(); }
    QMdiSubWindow* createTab(RcxDocument* doc);
    void updateWindowTitle();

    void setViewMode(ViewMode mode);
    void updateRenderedView(TabState& tab, SplitPane& pane);
    void updateAllRenderedPanes(TabState& tab);
    uint64_t findRootStructForNode(const NodeTree& tree, uint64_t nodeId) const;
    void setupRenderedSci(QsciScintilla* sci);

    SplitPane createSplitPane(TabState& tab);
    void applyTheme(const Theme& theme);
    void styleTabCloseButtons();
    void syncViewButtons(ViewMode mode);
    SplitPane* findPaneByTabWidget(QTabWidget* tw);
    SplitPane* findActiveSplitPane();
    RcxEditor* activePaneEditor();

    // Workspace dock
    QDockWidget*        m_workspaceDock  = nullptr;
    QTreeView*          m_workspaceTree  = nullptr;
    QStandardItemModel* m_workspaceModel = nullptr;
    QLabel*             m_dockTitleLabel = nullptr;
    QToolButton*        m_dockCloseBtn   = nullptr;
    void createWorkspaceDock();
    void rebuildWorkspaceModel();
    void updateBorderColor(const QColor& color);

protected:
    void changeEvent(QEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;
};

} // namespace rcx

```

`src/mcp/mcp_bridge.cpp`:

```cpp
#include "mcp_bridge.h"
#include "core.h"
#include "controller.h"
#include "generator.h"
#include "mainwindow.h"
#include <QCoreApplication>
#include <QDebug>
#include <cstring>

namespace rcx {

// ════════════════════════════════════════════════════════════════════
// Construction / lifecycle
// ════════════════════════════════════════════════════════════════════

McpBridge::McpBridge(MainWindow* mainWindow, QObject* parent)
    : QObject(parent), m_mainWindow(mainWindow)
{}

McpBridge::~McpBridge() {
    stop();
}

void McpBridge::start() {
    if (m_server) return;

    m_server = new QLocalServer(this);
    m_server->setSocketOptions(QLocalServer::WorldAccessOption);

    // Remove stale socket (Linux/Mac leave files behind)
    QLocalServer::removeServer("ReclassMcpBridge");

    if (!m_server->listen("ReclassMcpBridge")) {
        qWarning() << "[MCP] Failed to start server:" << m_server->errorString();
        delete m_server;
        m_server = nullptr;
        return;
    }

    connect(m_server, &QLocalServer::newConnection,
            this, &McpBridge::onNewConnection);
    qDebug() << "[MCP] Server listening on pipe: ReclassMcpBridge";
}

void McpBridge::stop() {
    if (m_client) {
        m_client->disconnectFromServer();
        m_client = nullptr;
    }
    if (m_server) {
        m_server->close();
        delete m_server;
        m_server = nullptr;
    }
}

// ════════════════════════════════════════════════════════════════════
// Connection handling
// ════════════════════════════════════════════════════════════════════

void McpBridge::onNewConnection() {
    auto* pending = m_server->nextPendingConnection();
    if (!pending) return;

    // Single client — disconnect previous
    if (m_client) {
        m_client->disconnectFromServer();
        m_client->deleteLater();
    }

    m_client = pending;
    m_readBuffer.clear();
    m_initialized = false;

    connect(m_client, &QLocalSocket::readyRead,
            this, &McpBridge::onReadyRead);
    connect(m_client, &QLocalSocket::disconnected,
            this, &McpBridge::onDisconnected);

    qDebug() << "[MCP] Client connected";
}

void McpBridge::onReadyRead() {
    m_readBuffer.append(m_client->readAll());

    // Newline-delimited JSON framing
    while (true) {
        int idx = m_readBuffer.indexOf('\n');
        if (idx < 0) break;
        QByteArray line = m_readBuffer.left(idx).trimmed();
        m_readBuffer.remove(0, idx + 1);
        if (!line.isEmpty())
            processLine(line);
    }
}

void McpBridge::onDisconnected() {
    qDebug() << "[MCP] Client disconnected";
    m_client = nullptr;
    m_initialized = false;
}

// ════════════════════════════════════════════════════════════════════
// JSON-RPC plumbing
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::okReply(const QJsonValue& id, const QJsonObject& result) {
    return QJsonObject{
        {"jsonrpc", "2.0"},
        {"id", id},
        {"result", result}
    };
}

QJsonObject McpBridge::errReply(const QJsonValue& id, int code, const QString& msg) {
    return QJsonObject{
        {"jsonrpc", "2.0"},
        {"id", id},
        {"error", QJsonObject{{"code", code}, {"message", msg}}}
    };
}

void McpBridge::sendJson(const QJsonObject& obj) {
    if (!m_client) return;
    QByteArray data = QJsonDocument(obj).toJson(QJsonDocument::Compact);
    qDebug() << "[MCP] >>" << data.left(200);
    data.append('\n');
    m_client->write(data);
    m_client->flush();
}

void McpBridge::sendNotification(const QString& method, const QJsonObject& params) {
    QJsonObject n{{"jsonrpc", "2.0"}, {"method", method}};
    if (!params.isEmpty()) n["params"] = params;
    sendJson(n);
}

QJsonObject McpBridge::makeTextResult(const QString& text, bool isError) {
    QJsonObject entry;
    entry["type"] = QStringLiteral("text");
    entry["text"] = text;
    QJsonArray content;
    content.append(entry);
    QJsonObject result;
    result["content"] = content;
    if (isError) result["isError"] = true;
    return result;
}

// ════════════════════════════════════════════════════════════════════
// Dispatch
// ════════════════════════════════════════════════════════════════════

void McpBridge::processLine(const QByteArray& line) {
    qDebug() << "[MCP] <<" << line.trimmed().left(200);
    auto doc = QJsonDocument::fromJson(line);
    if (!doc.isObject()) {
        sendJson(errReply(QJsonValue(), -32700, "Parse error"));
        return;
    }

    QJsonObject req = doc.object();
    QJsonValue id = req.value("id");
    QString method = req.value("method").toString();

    // Client notifications (no response)
    if (method == "notifications/initialized" ||
        method == "notifications/cancelled") {
        return;
    }

    if (method == "initialize") {
        sendJson(handleInitialize(id, req.value("params").toObject()));
    } else if (method == "tools/list") {
        sendJson(handleToolsList(id));
    } else if (method == "tools/call") {
        sendJson(handleToolsCall(id, req.value("params").toObject()));
    } else {
        sendJson(errReply(id, -32601, "Method not found: " + method));
    }
}

// ════════════════════════════════════════════════════════════════════
// MCP: initialize
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::handleInitialize(const QJsonValue& id, const QJsonObject&) {
    m_initialized = true;

    QJsonObject caps;
    caps["tools"] = QJsonObject{{"listChanged", false}};

    QJsonObject result{
        {"protocolVersion", "2024-11-05"},
        {"capabilities", caps},
        {"serverInfo", QJsonObject{
            {"name", "reclass-mcp"},
            {"version", "1.0.0"}
        }}
    };
    return okReply(id, result);
}

// ════════════════════════════════════════════════════════════════════
// MCP: tools/list
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::handleToolsList(const QJsonValue& id) {
    QJsonArray tools;

    // 1. project.state
    tools.append(QJsonObject{
        {"name", "project.state"},
        {"description", "Returns project state: node tree, base address, sources, provider info. "
                        "Use depth/parentId to avoid dumping the whole tree. "
                        "Call with depth:1 first to see top-level structs, then drill in with parentId."},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"depth", QJsonObject{{"type", "integer"},
                    {"description", "Max tree depth to return (default 1 = top-level structs only)."}}},
                {"parentId", QJsonObject{{"type", "string"},
                    {"description", "Only return children of this node."}}},
                {"includeTree", QJsonObject{{"type", "boolean"},
                    {"description", "If false, return only provider/source info, no tree. Default true."}}}
            }}
        }}
    });

    // 2. tree.apply
    tools.append(QJsonObject{
        {"name", "tree.apply"},
        {"description", "Apply batch of tree operations atomically (undo macro). "
                        "Each op is a JSON object with an 'op' field for the operation type and 'nodeId' (string) for the target node. "
                        "Operations: "
                        "remove: {op:'remove', nodeId:'ID'}. "
                        "rename: {op:'rename', nodeId:'ID', name:'newName'}. "
                        "insert: {op:'insert', kind:'Hex64', name:'field', parentId:'ID', offset:0}. "
                        "change_kind: {op:'change_kind', nodeId:'ID', kind:'UInt32'}. "
                        "change_offset: {op:'change_offset', nodeId:'ID', offset:16}. "
                        "change_base: {op:'change_base', baseAddress:'0x400000'}. "
                        "change_struct_type: {op:'change_struct_type', nodeId:'ID', structTypeName:'Name'}. "
                        "change_class_keyword: {op:'change_class_keyword', nodeId:'ID', classKeyword:'class'}. "
                        "change_pointer_ref: {op:'change_pointer_ref', nodeId:'ID', refId:'targetID'}. "
                        "change_array_meta: {op:'change_array_meta', nodeId:'ID', elementKind:'UInt32', arrayLen:10}. "
                        "collapse: {op:'collapse', nodeId:'ID', collapsed:true}. "
                        "Insert ops get auto-assigned IDs; use $0, $1 etc. to reference them in later ops. "
                        "Kinds: Hex8 Hex16 Hex32 Hex64 Int8 Int16 Int32 Int64 UInt8 UInt16 UInt32 UInt64 "
                        "Float Double Bool Pointer32 Pointer64 Vec2 Vec3 Vec4 Mat4x4 UTF8 UTF16 Struct Array"},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"operations", QJsonObject{{"type", "array"}, {"items", QJsonObject{{"type", "object"}}}}},
                {"macroName", QJsonObject{{"type", "string"}}}
            }},
            {"required", QJsonArray{"operations"}}
        }}
    });

    // 3. source.switch
    tools.append(QJsonObject{
        {"name", "source.switch"},
        {"description", "Switch active data source (provider). Use sourceIndex for saved sources, "
                        "filePath to load a binary file, or pid to attach to a live process."},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"sourceIndex", QJsonObject{{"type", "integer"}}},
                {"filePath", QJsonObject{{"type", "string"}}},
                {"pid", QJsonObject{{"type", "integer"},
                    {"description", "Process ID to attach to for live memory reading."}}},
                {"processName", QJsonObject{{"type", "string"},
                    {"description", "Display name for the process (optional with pid)."}}},
                {"allViews", QJsonObject{{"type", "boolean"}}}
            }}
        }}
    });

    // 4. hex.read
    tools.append(QJsonObject{
        {"name", "hex.read"},
        {"description", "Read raw bytes from provider. Returns hex dump, ASCII, and multi-type "
                        "interpretations (u8/u16/u32/u64/i32/f32/f64/ptr/string heuristics). "
                        "Offset is tree-relative (0-based, baseAddress added automatically) "
                        "unless baseRelative=true (offset is absolute)."},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"offset", QJsonObject{{"type", "integer"}}},
                {"length", QJsonObject{{"type", "integer"}}},
                {"baseRelative", QJsonObject{{"type", "boolean"}}}
            }},
            {"required", QJsonArray{"offset", "length"}}
        }}
    });

    // 5. hex.write
    tools.append(QJsonObject{
        {"name", "hex.write"},
        {"description", "Write raw bytes to provider (through undo stack). Hex string format: '4D5A9000'"},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"offset", QJsonObject{{"type", "integer"}}},
                {"hexBytes", QJsonObject{{"type", "string"}}},
                {"baseRelative", QJsonObject{{"type", "boolean"}}}
            }},
            {"required", QJsonArray{"offset", "hexBytes"}}
        }}
    });

    // 6. status.set
    tools.append(QJsonObject{
        {"name", "status.set"},
        {"description", "Show status text to user. Updates command row (editor line 0) and/or "
                        "the window status bar."},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"text", QJsonObject{{"type", "string"}}},
                {"target", QJsonObject{{"type", "string"},
                    {"enum", QJsonArray{"commandRow", "statusBar", "both"}}}}
            }},
            {"required", QJsonArray{"text"}}
        }}
    });

    // 7. ui.action
    tools.append(QJsonObject{
        {"name", "ui.action"},
        {"description", "Trigger a UI action. Fallback for operations without dedicated tools. "
                        "Actions: undo, redo, new_file, open_file, save_file, save_file_as, "
                        "export_cpp, set_view_root, scroll_to_node, collapse_node, expand_node, "
                        "select_node, refresh"},
        {"inputSchema", QJsonObject{
            {"type", "object"},
            {"properties", QJsonObject{
                {"tabIndex", QJsonObject{{"type", "integer"},
                    {"description", "MDI tab index (0-based). Omit for active tab."}}},
                {"action", QJsonObject{{"type", "string"}}},
                {"nodeId", QJsonObject{{"type", "string"}}},
                {"filePath", QJsonObject{{"type", "string"}}}
            }},
            {"required", QJsonArray{"action"}}
        }}
    });

    return okReply(id, QJsonObject{{"tools", tools}});
}

// ════════════════════════════════════════════════════════════════════
// MCP: tools/call — dispatch to tool implementations
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::handleToolsCall(const QJsonValue& id, const QJsonObject& params) {
    QString toolName = params.value("name").toString();
    QJsonObject args = params.value("arguments").toObject();

    QJsonObject result;
    if      (toolName == "project.state")  result = toolProjectState(args);
    else if (toolName == "tree.apply")     result = toolTreeApply(args);
    else if (toolName == "source.switch")  result = toolSourceSwitch(args);
    else if (toolName == "hex.read")       result = toolHexRead(args);
    else if (toolName == "hex.write")      result = toolHexWrite(args);
    else if (toolName == "status.set")     result = toolStatusSet(args);
    else if (toolName == "ui.action")      result = toolUiAction(args);
    else return errReply(id, -32601, "Unknown tool: " + toolName);

    return okReply(id, result);
}

// ════════════════════════════════════════════════════════════════════
// Helper: resolve "$N" placeholder references
// ════════════════════════════════════════════════════════════════════

QString McpBridge::resolvePlaceholder(const QString& ref,
                                       const QHash<QString, uint64_t>& placeholderMap) {
    if (ref.startsWith('$')) {
        auto it = placeholderMap.find(ref);
        if (it != placeholderMap.end())
            return QString::number(it.value());
    }
    return ref;  // not a placeholder — return as-is
}

// ════════════════════════════════════════════════════════════════════
// Smart tab resolution
// ════════════════════════════════════════════════════════════════════

MainWindow::TabState* McpBridge::resolveTab(const QJsonObject& args) {
    // 1) Explicit tab index from args
    if (args.contains("tabIndex")) {
        int idx = args.value("tabIndex").toInt();
        auto* t = m_mainWindow->tabByIndex(idx);
        if (t) return t;
    }

    // 2) Active sub-window (user clicked on it)
    auto* t = m_mainWindow->activeTab();
    if (t) return t;

    // 3) Fall back to first available tab
    if (m_mainWindow->tabCount() > 0) {
        t = m_mainWindow->tabByIndex(0);
        if (t) return t;
    }

    // 4) No tabs at all — auto-create a project
    m_mainWindow->project_new();
    return m_mainWindow->tabByIndex(0);
}

// ════════════════════════════════════════════════════════════════════
// TOOL: project.state
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolProjectState(const QJsonObject& args) {
    auto* tab = resolveTab(args);
    if (!tab) return makeTextResult("No active tab", true);

    auto* doc = tab->doc;
    auto* ctrl = tab->ctrl;
    const auto& tree = doc->tree;

    int maxDepth = args.value("depth").toInt(1);
    bool includeTree = args.contains("includeTree") ? args.value("includeTree").toBool() : true;
    QString parentIdStr = args.value("parentId").toString();
    uint64_t filterParentId = parentIdStr.isEmpty() ? 0 : parentIdStr.toULongLong();

    QJsonObject state;
    state["baseAddress"] = "0x" + QString::number(tree.baseAddress, 16).toUpper();
    state["viewRootId"] = QString::number(ctrl->viewRootId());
    state["nodeCount"] = tree.nodes.size();

    // Provider info
    QJsonObject provInfo;
    if (doc->provider) {
        provInfo["name"] = doc->provider->name();
        provInfo["writable"] = doc->provider->isWritable();
        provInfo["live"] = doc->provider->isLive();
        provInfo["size"] = doc->provider->size();
        provInfo["kind"] = doc->provider->kind();
    }
    state["provider"] = provInfo;

    // Saved sources
    QJsonArray srcs;
    const auto& savedSources = ctrl->savedSources();
    int activeIdx = ctrl->activeSourceIndex();
    for (int i = 0; i < savedSources.size(); i++) {
        const auto& s = savedSources[i];
        srcs.append(QJsonObject{
            {"index", i},
            {"kind", s.kind},
            {"displayName", s.displayName},
            {"active", i == activeIdx}
        });
    }
    state["sources"] = srcs;

    // Selection
    QJsonArray selArr;
    for (uint64_t sid : ctrl->selectedIds())
        selArr.append(QString::number(sid));
    state["selectedNodeIds"] = selArr;

    // Document info
    state["filePath"] = doc->filePath;
    state["modified"] = doc->modified;
    state["undoAvailable"] = doc->undoStack.canUndo();
    state["redoAvailable"] = doc->undoStack.canRedo();

    // Filtered tree: only emit nodes up to maxDepth from the filter root
    if (includeTree) {
        // Build parent→children map once
        QHash<uint64_t, QVector<int>> childMap;
        for (int i = 0; i < tree.nodes.size(); i++)
            childMap[tree.nodes[i].parentId].append(i);

        // BFS from filterParentId, respecting maxDepth
        QJsonArray nodeArr;
        struct QueueEntry { uint64_t parentId; int depth; };
        QVector<QueueEntry> queue;
        queue.append({filterParentId, 0});

        while (!queue.isEmpty()) {
            auto entry = queue.takeFirst();
            if (entry.depth > maxDepth) continue;

            const auto& kids = childMap.value(entry.parentId);
            for (int ci : kids) {
                const Node& n = tree.nodes[ci];
                QJsonObject nj = n.toJson();
                // Add computed size for containers
                if (n.kind == NodeKind::Struct || n.kind == NodeKind::Array) {
                    nj["computedSize"] = tree.structSpan(n.id, &childMap);
                    nj["childCount"] = childMap.value(n.id).size();
                }
                nodeArr.append(nj);

                // Enqueue children if we haven't hit depth limit
                if (entry.depth + 1 <= maxDepth)
                    queue.append({n.id, entry.depth + 1});
            }
        }

        QJsonObject treeObj;
        treeObj["baseAddress"] = QString::number(tree.baseAddress, 16);
        treeObj["nextId"] = QString::number(tree.m_nextId);
        treeObj["nodes"] = nodeArr;
        state["tree"] = treeObj;
    }

    return makeTextResult(QString::fromUtf8(
        QJsonDocument(state).toJson(QJsonDocument::Indented)));
}

// ════════════════════════════════════════════════════════════════════
// TOOL: tree.apply
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolTreeApply(const QJsonObject& args) {
    auto* tab = resolveTab(args);
    if (!tab) return makeTextResult("No active tab", true);

    auto* doc = tab->doc;
    auto* ctrl = tab->ctrl;
    auto& tree = doc->tree;

    QJsonArray ops = args.value("operations").toArray();
    QString macroName = args.value("macroName").toString("MCP batch");

    if (ops.isEmpty())
        return makeTextResult("No operations provided", true);

    // Phase 1: Pre-scan inserts and reserve IDs
    QHash<QString, uint64_t> placeholders;  // "$0" → reserved ID
    for (int i = 0; i < ops.size(); i++) {
        QJsonObject op = ops[i].toObject();
        if (op.value("op").toString() == "insert") {
            uint64_t newId = tree.reserveId();
            placeholders[QStringLiteral("$%1").arg(i)] = newId;
        }
    }

    // Phase 2: Execute in undo macro
    if (!m_slowMode)
        ctrl->setSuppressRefresh(true);
    doc->undoStack.beginMacro(macroName);

    int applied = 0;
    uint64_t lastRootStructId = 0;  // track root-level struct inserts
    QStringList skippedOps;
    for (int i = 0; i < ops.size(); i++) {
        // Safety valve: keep paint events flowing for large batches
        if (i % 100 == 0 && ops.size() > 200)
            QCoreApplication::processEvents(QEventLoop::ExcludeUserInputEvents, 5);

        QJsonObject op = ops[i].toObject();
        QString opType = op.value("op").toString();

        if (opType == "insert") {
            Node n;
            n.id = placeholders.value(QStringLiteral("$%1").arg(i), tree.reserveId());
            n.kind = kindFromString(op.value("kind").toString("Hex64"));
            n.name = op.value("name").toString();
            QString pid = resolvePlaceholder(op.value("parentId").toString("0"), placeholders);
            n.parentId = pid.toULongLong();
            n.offset = op.value("offset").toInt(0);
            n.structTypeName = op.value("structTypeName").toString();
            n.classKeyword = op.value("classKeyword").toString();
            n.strLen = op.value("strLen").toInt(64);
            n.elementKind = kindFromString(op.value("elementKind").toString("UInt8"));
            n.arrayLen = op.value("arrayLen").toInt(1);
            QString refStr = resolvePlaceholder(op.value("refId").toString("0"), placeholders);
            n.refId = refStr.toULongLong();

            // Auto-place: offset -1 means "after last sibling"
            if (n.offset < 0) {
                int maxEnd = 0;
                auto siblings = tree.childrenOf(n.parentId);
                for (int si : siblings) {
                    auto& sn = tree.nodes[si];
                    int sz = (sn.kind == NodeKind::Struct || sn.kind == NodeKind::Array)
                        ? tree.structSpan(sn.id) : sn.byteSize();
                    int end = sn.offset + sz;
                    if (end > maxEnd) maxEnd = end;
                }
                int align = alignmentFor(n.kind);
                n.offset = (maxEnd + align - 1) / align * align;
            }

            doc->undoStack.push(new RcxCommand(ctrl, cmd::Insert{n, {}}));
            if (n.parentId == 0 && n.kind == NodeKind::Struct)
                lastRootStructId = n.id;
            applied++;
        }
        else if (opType == "remove") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                const Node& node = tree.nodes[idx];
                QVector<int> indices = tree.subtreeIndices(node.id);
                QVector<Node> subtree;
                for (int si : indices) subtree.append(tree.nodes[si]);
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::Remove{node.id, subtree, {}}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: remove nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "rename") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::Rename{tree.nodes[idx].id, tree.nodes[idx].name,
                                op.value("name").toString()}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: rename nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "change_kind") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                NodeKind newKind = kindFromString(op.value("kind").toString());
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::ChangeKind{tree.nodes[idx].id, tree.nodes[idx].kind, newKind, {}}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: change_kind nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "change_offset") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                int newOff = op.value("offset").toInt();
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::ChangeOffset{tree.nodes[idx].id, tree.nodes[idx].offset, newOff}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: change_offset nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "change_base") {
            uint64_t newBase = op.value("baseAddress").toString().toULongLong(nullptr, 16);
            doc->undoStack.push(new RcxCommand(ctrl,
                cmd::ChangeBase{tree.baseAddress, newBase}));
            applied++;
        }
        else if (opType == "change_struct_type") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::ChangeStructTypeName{tree.nodes[idx].id,
                        tree.nodes[idx].structTypeName,
                        op.value("structTypeName").toString()}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: change_struct_type nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "change_class_keyword") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::ChangeClassKeyword{tree.nodes[idx].id,
                        tree.nodes[idx].classKeyword,
                        op.value("classKeyword").toString()}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: change_class_keyword nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "change_pointer_ref") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            QString refStr = resolvePlaceholder(op.value("refId").toString("0"), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::ChangePointerRef{tree.nodes[idx].id,
                        tree.nodes[idx].refId, refStr.toULongLong()}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: change_pointer_ref nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "change_array_meta") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                NodeKind newElemKind = kindFromString(op.value("elementKind").toString());
                int newLen = op.value("arrayLen").toInt(1);
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::ChangeArrayMeta{tree.nodes[idx].id,
                        tree.nodes[idx].elementKind, newElemKind,
                        tree.nodes[idx].arrayLen, newLen}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: change_array_meta nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else if (opType == "collapse") {
            QString nid = resolvePlaceholder(op.value("nodeId").toString(), placeholders);
            int idx = tree.indexOfId(nid.toULongLong());
            if (idx >= 0) {
                bool newState = op.value("collapsed").toBool();
                doc->undoStack.push(new RcxCommand(ctrl,
                    cmd::Collapse{tree.nodes[idx].id, tree.nodes[idx].collapsed, newState}));
                applied++;
            } else {
                skippedOps.append(QStringLiteral("op[%1]: collapse nodeId '%2' not found").arg(i).arg(nid));
            }
        }
        else {
            skippedOps.append(QStringLiteral("op[%1]: unknown op '%2'").arg(i).arg(opType));
        }

        // Slow mode: refresh after each operation for visual feedback
        if (m_slowMode && applied > 0) {
            ctrl->refresh();
            QCoreApplication::processEvents(QEventLoop::ExcludeUserInputEvents, 16);
        }
    }

    doc->undoStack.endMacro();
    if (!m_slowMode)
        ctrl->setSuppressRefresh(false);

    // Auto-switch view to newly created root struct
    if (lastRootStructId)
        ctrl->setViewRootId(lastRootStructId);

    ctrl->refresh();

    // Build response with assigned placeholder IDs
    QJsonObject assignedIds;
    for (auto it = placeholders.begin(); it != placeholders.end(); ++it)
        assignedIds[it.key()] = QString::number(it.value());

    QString msg = QStringLiteral("Applied %1 operations").arg(applied);
    if (!skippedOps.isEmpty())
        msg += QStringLiteral("\nSkipped %1:\n").arg(skippedOps.size()) + skippedOps.join('\n');

    QJsonObject result = makeTextResult(msg, !skippedOps.isEmpty() && applied == 0);
    result["assignedIds"] = assignedIds;
    return result;
}

// ════════════════════════════════════════════════════════════════════
// TOOL: source.switch
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolSourceSwitch(const QJsonObject& args) {
    auto* tab = resolveTab(args);
    if (!tab) return makeTextResult("No active tab", true);

    auto* ctrl = tab->ctrl;
    auto* doc = tab->doc;

    if (args.contains("sourceIndex")) {
        int idx = args.value("sourceIndex").toInt();
        const auto& sources = ctrl->savedSources();
        if (idx < 0 || idx >= sources.size())
            return makeTextResult("Source index out of range: " + QString::number(idx), true);

        if (args.value("allViews").toBool()) {
            // Switch all tabs to this source
            for (auto& t : m_mainWindow->m_tabs)
                t.ctrl->switchSource(idx);
        } else {
            ctrl->switchSource(idx);
        }
        return makeTextResult("Switched to source " + QString::number(idx) +
                              " (" + sources[idx].displayName + ")");
    }

    if (args.contains("pid")) {
        uint32_t pid = (uint32_t)args.value("pid").toInt();
        QString name = args.value("processName").toString();
        if (name.isEmpty()) name = QString("PID %1").arg(pid);
        QString target = QString("%1:%2").arg(pid).arg(name);
        ctrl->attachViaPlugin(QStringLiteral("processmemory"), target);
        return makeTextResult("Attached to process " + name + " (PID " + QString::number(pid) + ")");
    }

    if (args.contains("filePath")) {
        QString path = args.value("filePath").toString();
        doc->loadData(path);
        ctrl->refresh();
        return makeTextResult("Loaded file: " + path);
    }

    return makeTextResult("Provide sourceIndex, filePath, or pid", true);
}

// ════════════════════════════════════════════════════════════════════
// TOOL: hex.read
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolHexRead(const QJsonObject& args) {
    auto* tab = resolveTab(args);
    if (!tab) return makeTextResult("No active tab", true);

    auto* prov = tab->doc->provider.get();
    if (!prov) return makeTextResult("No provider", true);

    int64_t offset = static_cast<int64_t>(args.value("offset").toDouble());
    int length = qMin(args.value("length").toInt(64), 4096);

    if (!args.value("baseRelative").toBool())
        offset += (int64_t)tab->doc->tree.baseAddress;

    if (offset < 0 || !prov->isReadable((uint64_t)offset, length))
        return makeTextResult("Cannot read at offset " + QString::number(offset), true);

    QByteArray data = prov->readBytes((uint64_t)offset, length);

    // Format hex dump (16 bytes per line)
    QString dump;
    for (int i = 0; i < data.size(); i += 16) {
        int lineLen = qMin(16, data.size() - i);
        dump += QString("%1: ").arg((uint64_t)(offset + i), 8, 16, QChar('0'));
        for (int j = 0; j < 16; j++) {
            if (j < lineLen)
                dump += QString("%1 ").arg((uint8_t)data[i+j], 2, 16, QChar('0'));
            else
                dump += "   ";
            if (j == 7) dump += " ";
        }
        dump += " |";
        for (int j = 0; j < lineLen; j++) {
            uint8_t c = (uint8_t)data[i+j];
            dump += (c >= 0x20 && c <= 0x7e) ? QChar(c) : QChar('.');
        }
        dump += "|\n";
    }

    // Type interpretations at start of read
    if (data.size() >= 1) {
        dump += "\n--- Interpretations at offset ---\n";
        dump += "u8:  " + QString::number((uint8_t)data[0]) + "\n";
        if (data.size() >= 2) {
            uint16_t v; memcpy(&v, data.data(), 2);
            dump += "u16: " + QString::number(v) + "\n";
        }
        if (data.size() >= 4) {
            uint32_t v; memcpy(&v, data.data(), 4);
            int32_t iv; memcpy(&iv, data.data(), 4);
            float fv; memcpy(&fv, data.data(), 4);
            dump += "u32: " + QString::number(v) + " (0x" + QString::number(v, 16) + ")\n";
            dump += "i32: " + QString::number(iv) + "\n";
            dump += "f32: " + QString::number((double)fv) + "\n";
        }
        if (data.size() >= 8) {
            uint64_t v; memcpy(&v, data.data(), 8);
            double dv; memcpy(&dv, data.data(), 8);
            dump += "u64: " + QString::number(v) + " (0x" + QString::number(v, 16) + ")\n";
            dump += "f64: " + QString::number(dv) + "\n";

            // Pointer-likeness
            uint64_t base = tab->doc->tree.baseAddress;
            int provSize = prov->size();
            if (v >= base && v < base + (uint64_t)provSize)
                dump += "ptr?: LIKELY (within provider range)\n";
        }
        // String-likeness
        int printable = 0;
        for (int i = 0; i < data.size() && (uint8_t)data[i] >= 0x20 && (uint8_t)data[i] <= 0x7e; i++)
            printable++;
        if (printable >= 4)
            dump += "str?: " + QString::number(printable) + " printable ASCII bytes\n";
    }

    return makeTextResult(dump);
}

// ════════════════════════════════════════════════════════════════════
// TOOL: hex.write
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolHexWrite(const QJsonObject& args) {
    auto* tab = resolveTab(args);
    if (!tab) return makeTextResult("No active tab", true);

    auto* ctrl = tab->ctrl;
    auto* doc = tab->doc;
    auto* prov = doc->provider.get();

    int64_t offset = static_cast<int64_t>(args.value("offset").toDouble());
    QString hexStr = args.value("hexBytes").toString().remove(' ');

    if (!args.value("baseRelative").toBool())
        offset += (int64_t)doc->tree.baseAddress;

    if (hexStr.size() % 2 != 0)
        return makeTextResult("Hex string must have even length", true);

    QByteArray newBytes;
    for (int i = 0; i < hexStr.size(); i += 2) {
        bool ok;
        uint8_t byte = hexStr.mid(i, 2).toUInt(&ok, 16);
        if (!ok) return makeTextResult("Invalid hex at position " + QString::number(i), true);
        newBytes.append((char)byte);
    }

    if (!prov || !prov->isWritable())
        return makeTextResult("Provider is not writable", true);
    if (!prov->isReadable((uint64_t)offset, newBytes.size()))
        return makeTextResult("Offset out of range", true);

    QByteArray oldBytes = prov->readBytes((uint64_t)offset, newBytes.size());
    doc->undoStack.push(new RcxCommand(ctrl,
        cmd::WriteBytes{(uint64_t)offset, oldBytes, newBytes}));

    return makeTextResult("Wrote " + QString::number(newBytes.size()) + " bytes at offset 0x"
                          + QString::number(offset, 16));
}

// ════════════════════════════════════════════════════════════════════
// TOOL: status.set
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolStatusSet(const QJsonObject& args) {
    QString text = args.value("text").toString();
    QString target = args.value("target").toString("both");

    auto* tab = resolveTab(args);

    if (target == "commandRow" || target == "both") {
        if (tab) {
            for (auto& pane : tab->panes) {
                if (pane.editor) {
                    pane.editor->setCommandRowText(
                        QStringLiteral("[\xE2\x96\xB8] [Claude: %1]").arg(text));
                }
            }
        }
    }
    if (target == "statusBar" || target == "both") {
        m_mainWindow->m_statusLabel->setText(text);
    }

    return makeTextResult("Status set: " + text);
}

// ════════════════════════════════════════════════════════════════════
// TOOL: ui.action
// ════════════════════════════════════════════════════════════════════

QJsonObject McpBridge::toolUiAction(const QJsonObject& args) {
    QString action = args.value("action").toString();
    QString nodeIdStr = args.value("nodeId").toString();

    auto* tab = resolveTab(args);
    auto* doc = tab ? tab->doc : nullptr;
    auto* ctrl = tab ? tab->ctrl : nullptr;

    if (action == "undo") {
        if (!doc) return makeTextResult("No active tab", true);
        if (!doc->undoStack.canUndo()) return makeTextResult("Nothing to undo", true);
        doc->undoStack.undo();
        return makeTextResult("Undo performed");
    }
    if (action == "redo") {
        if (!doc) return makeTextResult("No active tab", true);
        if (!doc->undoStack.canRedo()) return makeTextResult("Nothing to redo", true);
        doc->undoStack.redo();
        return makeTextResult("Redo performed");
    }
    if (action == "refresh") {
        if (!ctrl) return makeTextResult("No active tab", true);
        ctrl->refresh();
        return makeTextResult("Refreshed");
    }
    if (action == "set_view_root") {
        if (!ctrl) return makeTextResult("No active tab", true);
        ctrl->setViewRootId(nodeIdStr.toULongLong());
        return makeTextResult("View root set to " + nodeIdStr);
    }
    if (action == "scroll_to_node") {
        if (!ctrl) return makeTextResult("No active tab", true);
        ctrl->scrollToNodeId(nodeIdStr.toULongLong());
        return makeTextResult("Scrolled to node " + nodeIdStr);
    }
    if (action == "export_cpp") {
        if (!doc) return makeTextResult("No active tab", true);
        const QHash<NodeKind, QString>* aliases = doc->typeAliases.isEmpty() ? nullptr : &doc->typeAliases;
        QString code = renderCppAll(doc->tree, aliases);
        return makeTextResult(code);
    }
    if (action == "save_file") {
        m_mainWindow->project_save();
        return makeTextResult("Saved");
    }
    if (action == "new_file") {
        m_mainWindow->project_new();
        return makeTextResult("New project created");
    }
    if (action == "open_file") {
        QString path = args.value("filePath").toString();
        if (path.isEmpty())
            return makeTextResult("filePath required for open_file", true);
        m_mainWindow->project_open(path);
        return makeTextResult("Opened: " + path);
    }
    if (action == "collapse_node") {
        if (!ctrl || !doc) return makeTextResult("No active tab", true);
        int idx = doc->tree.indexOfId(nodeIdStr.toULongLong());
        if (idx < 0) return makeTextResult("Node not found: " + nodeIdStr, true);
        doc->undoStack.push(new RcxCommand(ctrl,
            cmd::Collapse{doc->tree.nodes[idx].id, doc->tree.nodes[idx].collapsed, true}));
        ctrl->refresh();
        return makeTextResult("Collapsed " + nodeIdStr);
    }
    if (action == "expand_node") {
        if (!ctrl || !doc) return makeTextResult("No active tab", true);
        int idx = doc->tree.indexOfId(nodeIdStr.toULongLong());
        if (idx < 0) return makeTextResult("Node not found: " + nodeIdStr, true);
        doc->undoStack.push(new RcxCommand(ctrl,
            cmd::Collapse{doc->tree.nodes[idx].id, doc->tree.nodes[idx].collapsed, false}));
        ctrl->refresh();
        return makeTextResult("Expanded " + nodeIdStr);
    }
    if (action == "select_node") {
        if (!ctrl) return makeTextResult("No active tab", true);
        uint64_t nid = nodeIdStr.toULongLong();
        ctrl->clearSelection();
        auto* editor = ctrl->primaryEditor();
        if (editor)
            ctrl->handleNodeClick(editor, -1, nid, Qt::NoModifier);
        return makeTextResult("Selected node " + nodeIdStr);
    }

    return makeTextResult("Unknown action: " + action, true);
}

// ════════════════════════════════════════════════════════════════════
// Notifications (call from MainWindow/Controller hooks)
// ════════════════════════════════════════════════════════════════════

void McpBridge::notifyTreeChanged() {
    if (!m_client || !m_initialized) return;
    sendNotification("notifications/resources/updated",
                     QJsonObject{{"uri", "project://tree"}});
}

void McpBridge::notifyDataChanged() {
    if (!m_client || !m_initialized) return;
    sendNotification("notifications/resources/updated",
                     QJsonObject{{"uri", "project://data"}});
}

} // namespace rcx

```

`src/mcp/mcp_bridge.h`:

```h
#pragma once
#include "mainwindow.h"
#include <QObject>
#include <QLocalServer>
#include <QLocalSocket>
#include <QJsonObject>
#include <QJsonArray>
#include <QJsonDocument>
#include <QByteArray>

namespace rcx {

class McpBridge : public QObject {
    Q_OBJECT
public:
    explicit McpBridge(MainWindow* mainWindow, QObject* parent = nullptr);
    ~McpBridge() override;

    void start();
    void stop();
    bool isRunning() const { return m_server != nullptr; }

    bool slowMode() const { return m_slowMode; }
    void setSlowMode(bool v) { m_slowMode = v; }

    // Call from controller refresh / data change to notify MCP clients
    void notifyTreeChanged();
    void notifyDataChanged();

private:
    MainWindow*    m_mainWindow;
    QLocalServer*  m_server    = nullptr;
    QLocalSocket*  m_client    = nullptr;  // single client for v1
    QByteArray     m_readBuffer;
    bool           m_initialized = false;
    bool           m_slowMode    = false;

    // JSON-RPC plumbing
    void onNewConnection();
    void onReadyRead();
    void onDisconnected();
    void processLine(const QByteArray& line);
    void sendJson(const QJsonObject& obj);
    QJsonObject okReply(const QJsonValue& id, const QJsonObject& result);
    QJsonObject errReply(const QJsonValue& id, int code, const QString& msg);
    void sendNotification(const QString& method, const QJsonObject& params = {});

    // MCP method handlers
    QJsonObject handleInitialize(const QJsonValue& id, const QJsonObject& params);
    QJsonObject handleToolsList(const QJsonValue& id);
    QJsonObject handleToolsCall(const QJsonValue& id, const QJsonObject& params);

    // Tool implementations
    QJsonObject toolProjectState(const QJsonObject& args);
    QJsonObject toolTreeApply(const QJsonObject& args);
    QJsonObject toolSourceSwitch(const QJsonObject& args);
    QJsonObject toolHexRead(const QJsonObject& args);
    QJsonObject toolHexWrite(const QJsonObject& args);
    QJsonObject toolStatusSet(const QJsonObject& args);
    QJsonObject toolUiAction(const QJsonObject& args);

    // Helpers
    QJsonObject makeTextResult(const QString& text, bool isError = false);
    QString resolvePlaceholder(const QString& ref,
                               const QHash<QString, uint64_t>& placeholderMap);

    // Smart tab resolution: tabIndex arg → activeTab → first tab → auto-create
    MainWindow::TabState* resolveTab(const QJsonObject& args);
};

} // namespace rcx

```

`src/optionsdialog.cpp`:

```cpp
#include "optionsdialog.h"
#include "themes/thememanager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFormLayout>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QGroupBox>
#include <QLabel>
#include <QTreeWidgetItem>
#include <functional>

namespace rcx {

OptionsDialog::OptionsDialog(const OptionsResult& current, QWidget* parent)
    : QDialog(parent)
{
    setWindowTitle("Options");
    setFixedSize(700, 450);

    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(8);
    mainLayout->setContentsMargins(10, 10, 10, 10);

    // -- Middle: left column (search + tree) | right column (pages) --
    auto* middleLayout = new QHBoxLayout;
    middleLayout->setSpacing(8);

    // Left column: search bar + tree
    auto* leftColumn = new QVBoxLayout;
    leftColumn->setSpacing(4);

    m_search = new QLineEdit;
    m_search->setPlaceholderText("Search Options (Ctrl+E)");
    m_search->setClearButtonEnabled(true);
    connect(m_search, &QLineEdit::textChanged, this, &OptionsDialog::filterTree);
    leftColumn->addWidget(m_search);

    m_tree = new QTreeWidget;
    m_tree->setHeaderHidden(true);
    m_tree->setRootIsDecorated(true);
    m_tree->setFixedWidth(200);

    auto* envItem = new QTreeWidgetItem(m_tree, {"Environment"});
    auto* generalItem = new QTreeWidgetItem(envItem, {"General"});
    m_tree->expandAll();
    m_tree->setCurrentItem(generalItem);
    leftColumn->addWidget(m_tree, 1);

    middleLayout->addLayout(leftColumn);

    // Right column: stacked pages with group boxes
    m_pages = new QStackedWidget;

    // -- General page --
    auto* generalPage = new QWidget;
    auto* generalLayout = new QVBoxLayout(generalPage);
    generalLayout->setContentsMargins(0, 0, 0, 0);
    generalLayout->setSpacing(8);

    // Refresh Rate group box
    auto* refreshGroup = new QGroupBox("Refresh Rate");
    auto* refreshLayout = new QFormLayout(refreshGroup);
    refreshLayout->setSpacing(8);
    refreshLayout->setFieldGrowthPolicy(QFormLayout::ExpandingFieldsGrow);

    m_refreshSpin = new QSpinBox;
    m_refreshSpin->setRange(1, 60000);
    m_refreshSpin->setSingleStep(50);
    m_refreshSpin->setValue(current.refreshMs);
    m_refreshSpin->setSuffix(" ms");
    m_refreshSpin->setObjectName("refreshSpin");
    refreshLayout->addRow("Interval:", m_refreshSpin);

    auto* refreshDesc = new QLabel(
        "How often live memory is re-read and the view is updated, in milliseconds. "
        "Lower values give faster updates but use more CPU. Default: 660 ms.");
    refreshDesc->setWordWrap(true);
    refreshDesc->setContentsMargins(0, 0, 0, 0);
    refreshLayout->addRow(refreshDesc);

    generalLayout->addWidget(refreshGroup);

    // Visual Experience group box
    auto* visualGroup = new QGroupBox("Visual Experience");
    auto* visualLayout = new QFormLayout(visualGroup);
    visualLayout->setSpacing(8);
    visualLayout->setFieldGrowthPolicy(QFormLayout::ExpandingFieldsGrow);

    m_themeCombo = new QComboBox;
    auto& tm = ThemeManager::instance();
    for (const auto& theme : tm.themes())
        m_themeCombo->addItem(theme.name);
    m_themeCombo->setCurrentIndex(current.themeIndex);
    m_themeCombo->setObjectName("themeCombo");
    visualLayout->addRow("Color theme:", m_themeCombo);

    m_fontCombo = new QComboBox;
    m_fontCombo->addItem("JetBrains Mono");
    m_fontCombo->addItem("Consolas");
    m_fontCombo->setCurrentText(current.fontName);
    m_fontCombo->setObjectName("fontCombo");
    visualLayout->addRow("Editor Font:", m_fontCombo);

    m_titleCaseCheck = new QCheckBox("Apply title case styling to menu bar");
    m_titleCaseCheck->setChecked(current.menuBarTitleCase);
    visualLayout->addRow(m_titleCaseCheck);

    m_showIconCheck = new QCheckBox("Show icon in title bar");
    m_showIconCheck->setChecked(current.showIcon);
    visualLayout->addRow(m_showIconCheck);

    generalLayout->addWidget(visualGroup);

    // Safe Mode group box
    auto* safeModeGroup = new QGroupBox("Preview Features");
    auto* safeModeLayout = new QVBoxLayout(safeModeGroup);
    safeModeLayout->setSpacing(4);

    m_safeModeCheck = new QCheckBox("Safe Mode");
    m_safeModeCheck->setChecked(current.safeMode);
    safeModeLayout->addWidget(m_safeModeCheck);

    auto* safeModeDesc = new QLabel(
        "Enable to use the default OS icon for this application and "
        "create the window with the name of the executable file.");
    safeModeDesc->setWordWrap(true);
    safeModeDesc->setContentsMargins(20, 0, 0, 0);  // indent under checkbox
    safeModeLayout->addWidget(safeModeDesc);

    generalLayout->addWidget(safeModeGroup);
    generalLayout->addStretch();

    m_pages->addWidget(generalPage);                     // index 0
    m_pageKeywords[generalItem] = collectPageKeywords(generalPage);

    // -- AI Features page --
    auto* aiItem = new QTreeWidgetItem(envItem, {"AI Features"});

    auto* aiPage = new QWidget;
    auto* aiLayout = new QVBoxLayout(aiPage);
    aiLayout->setContentsMargins(0, 0, 0, 0);
    aiLayout->setSpacing(8);

    auto* mcpGroup = new QGroupBox("MCP Server");
    auto* mcpLayout = new QVBoxLayout(mcpGroup);
    mcpLayout->setSpacing(4);

    m_autoMcpCheck = new QCheckBox("Auto-start MCP server");
    m_autoMcpCheck->setChecked(current.autoStartMcp);
    mcpLayout->addWidget(m_autoMcpCheck);

    auto* mcpDesc = new QLabel(
        "Automatically start the MCP bridge server when the application launches, "
        "allowing external AI tools to connect and interact with the editor.");
    mcpDesc->setWordWrap(true);
    mcpDesc->setContentsMargins(20, 0, 0, 0);
    mcpLayout->addWidget(mcpDesc);

    aiLayout->addWidget(mcpGroup);
    aiLayout->addStretch();

    m_pages->addWidget(aiPage);                          // index 1
    m_pageKeywords[aiItem] = collectPageKeywords(aiPage);

    // -- Generator page --
    auto* generatorItem = new QTreeWidgetItem(envItem, {"Generator"});

    auto* generatorPage = new QWidget;
    auto* generatorLayout = new QVBoxLayout(generatorPage);
    generatorLayout->setContentsMargins(0, 0, 0, 0);
    generatorLayout->setSpacing(8);
    generatorLayout->addStretch();

    m_pages->addWidget(generatorPage);                   // index 2
    m_pageKeywords[generatorItem] = collectPageKeywords(generatorPage);

    middleLayout->addWidget(m_pages, 1);

    mainLayout->addLayout(middleLayout, 1);

    // Tree <-> page connection
    m_itemPageIndex[generalItem] = 0;
    m_itemPageIndex[aiItem] = 1;
    m_itemPageIndex[generatorItem] = 2;
    connect(m_tree, &QTreeWidget::currentItemChanged, this,
            [this](QTreeWidgetItem* item, QTreeWidgetItem*) {
        if (!item) return;
        auto it = m_itemPageIndex.find(item);
        if (it != m_itemPageIndex.end())
            m_pages->setCurrentIndex(it.value());
    });

    // -- Button box --
    auto* buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    connect(buttons, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, this, &QDialog::reject);
    mainLayout->addWidget(buttons);

}

OptionsResult OptionsDialog::result() const {
    OptionsResult r;
    r.themeIndex = m_themeCombo->currentIndex();
    r.fontName = m_fontCombo->currentText();
    r.menuBarTitleCase = m_titleCaseCheck->isChecked();
    r.showIcon = m_showIconCheck->isChecked();
    r.safeMode = m_safeModeCheck->isChecked();
    r.autoStartMcp = m_autoMcpCheck->isChecked();
    r.refreshMs = m_refreshSpin->value();
    return r;
}

QStringList OptionsDialog::collectPageKeywords(QWidget* page) {
    QStringList keywords;
    for (auto* child : page->findChildren<QWidget*>()) {
        if (auto* label = qobject_cast<QLabel*>(child))
            keywords << label->text();
        else if (auto* cb = qobject_cast<QCheckBox*>(child))
            keywords << cb->text();
        else if (auto* gb = qobject_cast<QGroupBox*>(child))
            keywords << gb->title();
        else if (auto* combo = qobject_cast<QComboBox*>(child)) {
            for (int i = 0; i < combo->count(); ++i)
                keywords << combo->itemText(i);
        }
    }
    return keywords;
}

void OptionsDialog::filterTree(const QString& text) {
    std::function<bool(QTreeWidgetItem*)> filter = [&](QTreeWidgetItem* item) -> bool {
        bool anyChildVisible = false;
        for (int i = 0; i < item->childCount(); ++i) {
            if (filter(item->child(i)))
                anyChildVisible = true;
        }

        bool selfMatch = item->text(0).contains(text, Qt::CaseInsensitive);
        if (!selfMatch) {
            for (const auto& kw : m_pageKeywords.value(item)) {
                if (kw.contains(text, Qt::CaseInsensitive)) {
                    selfMatch = true;
                    break;
                }
            }
        }
        bool visible = selfMatch || anyChildVisible;
        item->setHidden(!visible);

        if (visible && item->childCount() > 0)
            item->setExpanded(true);

        return visible;
    };

    for (int i = 0; i < m_tree->topLevelItemCount(); ++i)
        filter(m_tree->topLevelItem(i));
}

} // namespace rcx

```

`src/optionsdialog.h`:

```h
#pragma once
#include <QDialog>
#include <QLineEdit>
#include <QTreeWidget>
#include <QStackedWidget>
#include <QComboBox>
#include <QCheckBox>
#include <QHash>
#include <QSpinBox>

namespace rcx {

struct OptionsResult {
    int     themeIndex = 0;
    QString fontName;
    bool    menuBarTitleCase = true;
    bool    showIcon = false;
    bool    safeMode = false;
    bool    autoStartMcp = false;
    int     refreshMs = 660;
};

class OptionsDialog : public QDialog {
    Q_OBJECT
public:
    explicit OptionsDialog(const OptionsResult& current, QWidget* parent = nullptr);

    OptionsResult result() const;

private:
    void filterTree(const QString& text);
    static QStringList collectPageKeywords(QWidget* page);

    QLineEdit*      m_search         = nullptr;
    QTreeWidget*    m_tree           = nullptr;
    QStackedWidget* m_pages          = nullptr;
    QComboBox*      m_themeCombo     = nullptr;
    QComboBox*      m_fontCombo      = nullptr;
    QCheckBox*      m_titleCaseCheck = nullptr;
    QCheckBox*      m_showIconCheck  = nullptr;
    QCheckBox*      m_safeModeCheck  = nullptr;
    QCheckBox*      m_autoMcpCheck   = nullptr;
    QSpinBox*       m_refreshSpin    = nullptr;

    // searchable keywords per leaf tree item
    QHash<QTreeWidgetItem*, QStringList> m_pageKeywords;
    // tree item → stacked widget page index
    QHash<QTreeWidgetItem*, int> m_itemPageIndex;
};

} // namespace rcx

```

`src/pluginmanager.cpp`:

```cpp
#include "pluginmanager.h"
#include "providerregistry.h"
#include <QDir>
#include <QFileInfo>
#include <QCoreApplication>
#include <QDebug>

PluginManager::~PluginManager()
{
    UnloadPlugins();
}

void PluginManager::LoadPlugins()
{
    // Get the Plugins directory relative to the executable
    QString appDir = QCoreApplication::applicationDirPath();
    QString pluginsDir = appDir + "/Plugins";
    
    QDir dir(pluginsDir);
    if (!dir.exists())
    {
        qWarning() << "PluginManager: Plugins directory not found:" << pluginsDir;
        return;
    }
    
    // Find all DLL files
    QStringList filters;
#ifdef _WIN32
    filters << "*.dll";
#elif defined(__APPLE__)
    filters << "*.dylib";
#else
    filters << "*.so";
#endif
    
    dir.setNameFilters(filters);
    QFileInfoList files = dir.entryInfoList(QDir::Files);
    
    qDebug() << "PluginManager: Scanning for plugins in:" << pluginsDir;
    qDebug() << "PluginManager: Found" << files.count() << "potential plugin(s)";
    
    for (const QFileInfo& fileInfo : files)
    {
        LoadPlugin(fileInfo.absoluteFilePath());
    }
    
    qDebug() << "PluginManager: Loaded" << m_plugins.count() << "plugin(s)";
}

bool PluginManager::LoadPlugin(const QString& path)
{
    QLibrary* library = new QLibrary(path);
    
    // Load the library
    if (!library->load())
    {
        qWarning() << "PluginManager: Failed to load plugin:" << path;
        qWarning() << "PluginManager: Error" << library->errorString();
        delete library;
        return false;
    }
    
    // Resolve the CreatePlugin function
    CreatePluginFunc CreateFunc = (CreatePluginFunc)library->resolve("CreatePlugin");
    if (!CreateFunc)
    {
        qWarning() << "PluginManager: Plugin" << path << "does not export CreatePlugin()";
        library->unload();
        delete library;
        return false;
    }
    
    // Create plugin instance
    IPlugin* plugin = CreateFunc();
    if (!plugin)
    {
        qWarning() << "PluginManager: CreatePlugin() returned nullptr for" << path;
        library->unload();
        delete library;
        return false;
    }
    
    qDebug() << "PluginManager: Loaded plugin:" << plugin->Name().c_str() << plugin->Version().c_str() << "by" << plugin->Author().c_str();
    
    // Store plugin entry
    m_entries.append({library, plugin});
    m_plugins.append(plugin);
    
    // Auto-register providers in global registry
    if (plugin->Type() == IPlugin::ProviderPlugin)
    {
        IProviderPlugin* provider = static_cast<IProviderPlugin*>(plugin);
        QString name = QString::fromStdString(plugin->Name());
        QString identifier = name.toLower().replace(" ", "");
        QString dllFileName = QFileInfo(path).fileName();
        ProviderRegistry::instance().registerProvider(name, identifier, provider, dllFileName);
    }
    
    return true;
}

QVector<IProviderPlugin*> PluginManager::providerPlugins() const
{
    QVector<IProviderPlugin*> result;
    for (IPlugin* plugin : m_plugins)
    {
        if (plugin->Type() == IPlugin::ProviderPlugin)
        {
            result.append(static_cast<IProviderPlugin*>(plugin));
        }
    }
    return result;
}

IPlugin* PluginManager::FindPlugin(const QString& name) const
{
    for (IPlugin* plugin : m_plugins)
    {
        if (QString::fromStdString(plugin->Name()) == name)
        {
            return plugin;
        }
    }
    return nullptr;
}

bool PluginManager::LoadPluginFromPath(const QString& path)
{
    // Check if already loaded
    QFileInfo fileInfo(path);
    QString fileName = fileInfo.fileName();
    
    for (const auto& entry : m_entries)
    {
        if (entry.library->fileName().endsWith(fileName))
        {
            qWarning() << "PluginManager: Plugin already loaded:" << fileName;
            return false;
        }
    }
    
    return LoadPlugin(path);
}

bool PluginManager::UnloadPlugin(const QString& name)
{
    for (int i = 0; i < m_entries.size(); ++i)
    {
        if (QString::fromStdString(m_entries[i].plugin->Name()) == name)
        {
            qDebug() << "PluginManager: Unloading plugin:" << name;
            
            IPlugin* plugin = m_entries[i].plugin;
            
            // Unregister provider from global registry
            if (plugin->Type() == IPlugin::ProviderPlugin)
            {
                QString identifier = name.toLower().replace(" ", "");
                ProviderRegistry::instance().unregisterProvider(identifier);
            }
            
            // Delete plugin instance
            delete plugin;
            
            // Unload library
            m_entries[i].library->unload();
            delete m_entries[i].library;
            
            // Remove from lists
            m_entries.remove(i);
            m_plugins.remove(i);
            
            return true;
        }
    }
    
    qWarning() << "PluginManager: Plugin not found:" << name;
    return false;
}

void PluginManager::UnloadPlugins()
{
    // Clear provider registry
    ProviderRegistry::instance().clear();
    
    // Delete plugin instances and unload libraries
    for (int i = 0; i < m_entries.size(); ++i) {
        delete m_entries[i].plugin;
        m_entries[i].library->unload();
        delete m_entries[i].library;
    }
    
    m_entries.clear();
    m_plugins.clear();
}

```

`src/pluginmanager.h`:

```h
#pragma once
#include "iplugin.h"
#include <QVector>
#include <QString>
#include <QLibrary>
#include <memory>

/**
 * Manages plugin loading and lifecycle
 */
class PluginManager
{
public:
    PluginManager() = default;
    ~PluginManager();
    
    // Load plugins from the "Plugins" folder
    void LoadPlugins();
    
    // Get all loaded plugins
    const QVector<IPlugin*>& plugins() const { return m_plugins; }
    
    // Get plugins of a specific type
    QVector<IProviderPlugin*> providerPlugins() const;
    
    // Find plugin by name
    IPlugin* FindPlugin(const QString& name) const;
    
    // Load a single plugin from path
    bool LoadPluginFromPath(const QString& path);
    
    // Unload a specific plugin by name
    bool UnloadPlugin(const QString& name);
    
    // Unload all plugins
    void UnloadPlugins();
    
private:
    struct PluginEntry
    {
        QLibrary* library;
        IPlugin* plugin;
    };
    
    QVector<PluginEntry> m_entries;
    QVector<IPlugin*> m_plugins; // Non-owning pointers for quick access
    
    bool LoadPlugin(const QString& path);
};

```

`src/processpicker.cpp`:

```cpp
#include "processpicker.h"
#include "ui_processpicker.h"
#include <QTableWidgetItem>
#include <QHeaderView>
#include <QMessageBox>
#include <QFileInfo>
#include <QPixmap>

#ifdef _WIN32
#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <shellapi.h>
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
#include <QtWin>
#endif
#elif defined(__linux__)
#include <QDir>
#include <QStyle>
#include <QApplication>
#include <unistd.h>
#endif

ProcessPicker::ProcessPicker(QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::ProcessPicker)
    , m_useCustomList(false)
{
    ui->setupUi(this);
    
    // Configure table
    ui->processTable->setColumnWidth(0, 80);   // PID column - fixed width
    ui->processTable->setColumnWidth(1, 200);  // Name column - fixed width
    ui->processTable->horizontalHeader()->setStretchLastSection(true);  // Path column - fills remaining space
    ui->processTable->setWordWrap(false);  // Disable word wrap for single-line display
    ui->processTable->setTextElideMode(Qt::ElideLeft);  // Elide from left (show end of path)
    
    // Connect signals
    connect(ui->refreshButton, &QPushButton::clicked, this, &ProcessPicker::refreshProcessList);
    connect(ui->processTable, &QTableWidget::itemDoubleClicked, this, &ProcessPicker::onProcessSelected);
    connect(ui->filterEdit, &QLineEdit::textChanged, this, &ProcessPicker::filterProcesses);
    connect(ui->attachButton, &QPushButton::clicked, this, &ProcessPicker::onProcessSelected);
    
    // Initial process enumeration
    refreshProcessList();
}

ProcessPicker::ProcessPicker(const QList<ProcessInfo>& customProcesses, QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::ProcessPicker)
    , m_useCustomList(true)
{
    ui->setupUi(this);
    
    // Configure table
    ui->processTable->setColumnWidth(0, 80);
    ui->processTable->setColumnWidth(1, 200);
    ui->processTable->horizontalHeader()->setStretchLastSection(true);
    ui->processTable->setWordWrap(false);
    ui->processTable->setTextElideMode(Qt::ElideLeft);
    
    // Connect signals (no refresh button for custom lists)
    ui->refreshButton->setVisible(false);
    connect(ui->processTable, &QTableWidget::itemDoubleClicked, this, &ProcessPicker::onProcessSelected);
    connect(ui->filterEdit, &QLineEdit::textChanged, this, &ProcessPicker::filterProcesses);
    connect(ui->attachButton, &QPushButton::clicked, this, &ProcessPicker::onProcessSelected);
    
    // Use custom process list
    m_allProcesses = customProcesses;
    applyFilter();
}

ProcessPicker::~ProcessPicker()
{
    delete ui;
}

uint32_t ProcessPicker::selectedProcessId() const
{
    return m_selectedPid;
}

QString ProcessPicker::selectedProcessName() const
{
    return m_selectedName;
}

void ProcessPicker::refreshProcessList()
{
    ui->processTable->clearContents();
    ui->processTable->setRowCount(0);
    m_allProcesses.clear();
    enumerateProcesses();
}

void ProcessPicker::onProcessSelected()
{
    auto* item = ui->processTable->currentItem();
    if (!item) return;
    
    int row = item->row();
    m_selectedPid = ui->processTable->item(row, 0)->data(Qt::EditRole).toUInt();
    m_selectedName = ui->processTable->item(row, 1)->text();
    
    accept();
}

void ProcessPicker::enumerateProcesses()
{
    QList<ProcessInfo> processes;
    
#ifdef _WIN32
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        QMessageBox::warning(this, "Error", "Failed to enumerate processes.");
        return;
    }
    
    PROCESSENTRY32W pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32W);
    
    if (Process32FirstW(snapshot, &pe32))
    {
        do
        {
            ProcessInfo info;
            info.pid = pe32.th32ProcessID;
            info.name = QString::fromWCharArray(pe32.szExeFile);
            
            // Try to get full path and extract icon
            // If we can't open a process with PROCESS_QUERY_LIMITED_INFORMATION then
            // we for sure can't access their memory. - Skip in this case
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pe32.th32ProcessID);
            if (hProcess)
            {
                WCHAR path[MAX_PATH];
                DWORD pathLen = MAX_PATH;
                if (QueryFullProcessImageNameW(hProcess, 0, path, &pathLen) ||
                    QueryFullProcessImageNameW(hProcess, PROCESS_NAME_NATIVE, path, &pathLen) ||
                    GetModuleFileNameExW(hProcess, nullptr, path, pathLen))
                {
                    info.path = QString::fromWCharArray(path);
                    
                    // Extract icon from executable
                    SHFILEINFOW sfi = {};
                    if (SHGetFileInfoW(path, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_SMALLICON)) {
                        if (sfi.hIcon) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
                            info.icon = QIcon(QPixmap::fromImage(QImage::fromHICON(sfi.hIcon)));
#else
                            info.icon = QIcon(QtWin::fromHICON(sfi.hIcon));
#endif
                            DestroyIcon(sfi.hIcon);
                        }
                    }
                }
                else
                {
                    info.path = "";
                }
                CloseHandle(hProcess);

                processes.append(info);
            }
            
        } while (Process32NextW(snapshot, &pe32));
    }
    
    CloseHandle(snapshot);
#elif defined(__linux__)
    QDir procDir("/proc");
    QStringList entries = procDir.entryList(QDir::Dirs | QDir::NoDotAndDotDot);
    QIcon defaultIcon = qApp->style()->standardIcon(QStyle::SP_ComputerIcon);

    for (const QString& entry : entries) {
        bool ok = false;
        uint32_t pid = entry.toUInt(&ok);
        if (!ok || pid == 0) continue;

        // Read process name from /proc/<pid>/comm
        QString commPath = QStringLiteral("/proc/%1/comm").arg(pid);
        QFile commFile(commPath);
        QString procName;
        if (commFile.open(QIODevice::ReadOnly)) {
            procName = QString::fromUtf8(commFile.readAll()).trimmed();
            commFile.close();
        }
        if (procName.isEmpty()) continue;

        // Read exe path from /proc/<pid>/exe symlink
        QString exePath = QStringLiteral("/proc/%1/exe").arg(pid);
        QFileInfo exeInfo(exePath);
        QString resolvedPath;
        if (exeInfo.exists())
            resolvedPath = exeInfo.symLinkTarget();

        // Skip if we can't read the process memory
        QString memPath = QStringLiteral("/proc/%1/mem").arg(pid);
        if (::access(memPath.toUtf8().constData(), R_OK) != 0)
            continue;

        ProcessInfo info;
        info.pid = pid;
        info.name = procName;
        info.path = resolvedPath;
        info.icon = defaultIcon;
        processes.append(info);
    }
#else
    // Platform not supported
    QMessageBox::warning(this, "Error", "Process enumeration not supported on this platform.");
#endif
    
    m_allProcesses = processes;
    applyFilter();
}

void ProcessPicker::populateTable(const QList<ProcessInfo>& processes)
{
    ui->processTable->setRowCount(processes.size());
    
    for (int i = 0; i < processes.size(); ++i) {
        const auto& proc = processes[i];
        
        // PID column
        auto* pidItem = new QTableWidgetItem();
        pidItem->setData(Qt::EditRole, (int)proc.pid);
        ui->processTable->setItem(i, 0, pidItem);
        
        // Name column with icon
        auto* nameItem = new QTableWidgetItem(proc.name);
        if (!proc.icon.isNull()) {
            nameItem->setIcon(proc.icon);
        }
        ui->processTable->setItem(i, 1, nameItem);
        
        // Path column with tooltip for full path
        auto* pathItem = new QTableWidgetItem(proc.path);
        pathItem->setToolTip(proc.path);  // Show full path on hover
        ui->processTable->setItem(i, 2, pathItem);
    }
}

void ProcessPicker::filterProcesses(const QString& text)
{
    applyFilter();
}

void ProcessPicker::applyFilter()
{
    QString filterText = ui->filterEdit->text().trimmed();
    
    if (filterText.isEmpty()) {
        populateTable(m_allProcesses);
        return;
    }
    
    QList<ProcessInfo> filtered;
    QString lowerFilter = filterText.toLower();
    
    for (const auto& proc : m_allProcesses) {
        // Match by PID, name, or path
        if (QString::number(proc.pid).contains(lowerFilter) ||
            proc.name.toLower().contains(lowerFilter) ||
            proc.path.toLower().contains(lowerFilter)) {
            filtered.append(proc);
        }
    }
    
    populateTable(filtered);
}

```

`src/processpicker.h`:

```h
#ifndef PROCESSPICKER_H
#define PROCESSPICKER_H

#include <QDialog>
#include <QIcon>
#include <cstdint>

namespace Ui {
class ProcessPicker;
}

struct ProcessInfo {
    uint32_t pid;
    QString name;
    QString path;
    QIcon icon;
};

class ProcessPicker : public QDialog
{
    Q_OBJECT

public:
    explicit ProcessPicker(QWidget *parent = nullptr);
    explicit ProcessPicker(const QList<ProcessInfo>& customProcesses, QWidget *parent = nullptr);
    ~ProcessPicker();

    uint32_t selectedProcessId() const;
    QString selectedProcessName() const;

private slots:
    void refreshProcessList();
    void onProcessSelected();
    void filterProcesses(const QString& text);

private:
    void enumerateProcesses();
    void populateTable(const QList<ProcessInfo>& processes);
    void applyFilter();

    Ui::ProcessPicker *ui;
    uint32_t m_selectedPid = 0;
    QString m_selectedName;
    QList<ProcessInfo> m_allProcesses;
    bool m_useCustomList = false;
};

#endif // PROCESSPICKER_H

```

`src/processpicker.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ProcessPicker</class>
 <widget class="QDialog" name="ProcessPicker">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>700</width>
    <height>500</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>700</width>
    <height>500</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>1400</width>
    <height>1000</height>
   </size>
  </property>
  <property name="mouseTracking">
   <bool>true</bool>
  </property>
  <property name="windowTitle">
   <string>Attach to Process</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLineEdit" name="filterEdit">
     <property name="placeholderText">
      <string>Filter by name or PID...</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableWidget" name="processTable">
     <property name="editTriggers">
      <set>QAbstractItemView::EditTrigger::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SelectionMode::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectionBehavior::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <column>
      <property name="text">
       <string>PID</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Process Name</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Path</string>
      </property>
     </column>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="refreshButton">
       <property name="text">
        <string>Refresh</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="attachButton">
       <property name="text">
        <string>Attach</string>
       </property>
       <property name="default">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cancelButton">
       <property name="text">
        <string>Cancel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>attachButton</sender>
   <signal>clicked()</signal>
   <receiver>ProcessPicker</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>600</x>
     <y>470</y>
    </hint>
    <hint type="destinationlabel">
     <x>350</x>
     <y>250</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>cancelButton</sender>
   <signal>clicked()</signal>
   <receiver>ProcessPicker</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>650</x>
     <y>470</y>
    </hint>
    <hint type="destinationlabel">
     <x>350</x>
     <y>250</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/providerregistry.cpp`:

```cpp
#include "providerregistry.h"
#include <QDebug>

ProviderRegistry& ProviderRegistry::instance() {
    static ProviderRegistry s_instance;
    return s_instance;
}

void ProviderRegistry::registerProvider(const QString& name, const QString& identifier,
                                        IProviderPlugin* plugin, const QString& dllFileName) {
    // Check if already registered
    for (const auto& info : m_providers) {
        if (info.identifier == identifier) {
            qWarning() << "ProviderRegistry: Provider already registered:" << identifier;
            return;
        }
    }

    m_providers.append(ProviderInfo(name, identifier, plugin, dllFileName));
    qDebug() << "ProviderRegistry: Registered plugin provider:" << name << "(" << identifier << ")";
}

void ProviderRegistry::registerBuiltinProvider(const QString& name, const QString& identifier, BuiltinFactory factory) {
    // Check if already registered
    for (const auto& info : m_providers) {
        if (info.identifier == identifier) {
            qWarning() << "ProviderRegistry: Provider already registered:" << identifier;
            return;
        }
    }
    
    m_providers.append(ProviderInfo(name, identifier, factory));
    qDebug() << "ProviderRegistry: Registered builtin provider:" << name << "(" << identifier << ")";
}

void ProviderRegistry::unregisterProvider(const QString& identifier) {
    for (int i = 0; i < m_providers.size(); ++i) {
        if (m_providers[i].identifier == identifier) {
            qDebug() << "ProviderRegistry: Unregistered provider:" << identifier;
            m_providers.removeAt(i);
            return;
        }
    }
    qWarning() << "ProviderRegistry: Provider not found:" << identifier;
}

const ProviderRegistry::ProviderInfo* ProviderRegistry::findProvider(const QString& identifier) const {
    for (const auto& info : m_providers) {
        if (info.identifier == identifier) {
            return &info;
        }
    }
    return nullptr;
}

void ProviderRegistry::clear() {
    m_providers.clear();
}

```

`src/providerregistry.h`:

```h
#pragma once
#include "iplugin.h"
#include <QList>
#include <QString>
#include <functional>

// Forward declarations
namespace rcx { class Provider; }
class QWidget;

/**
 * Global registry for data source providers
 * 
 * Providers register themselves here so they can be listed in the Source picker.
 * Supports both plugin-based providers and built-in providers.
 */
class ProviderRegistry {
public:
    // Factory function for creating built-in providers
    using BuiltinFactory = std::function<bool(QWidget* parent, QString* target)>;
    
    struct ProviderInfo {
        QString name;          // Display name (e.g., "Process Memory")
        QString identifier;    // Unique ID (e.g., "process")
        IProviderPlugin* plugin;  // Plugin (if plugin-based)
        BuiltinFactory factory;   // Factory (if built-in)
        bool isBuiltin;
        QString dllFileName;   // Original DLL/SO filename (plugin-based only)

        ProviderInfo(const QString& n, const QString& id, IProviderPlugin* p,
                     const QString& dll = {})
            : name(n), identifier(id), plugin(p), factory(nullptr),
              isBuiltin(false), dllFileName(dll) {}

        ProviderInfo(const QString& n, const QString& id, BuiltinFactory f)
            : name(n), identifier(id), plugin(nullptr), factory(f), isBuiltin(true) {}
    };
    
    static ProviderRegistry& instance();
    
    // Register a plugin-based provider
    void registerProvider(const QString& name, const QString& identifier, IProviderPlugin* plugin,
                          const QString& dllFileName = {});
    
    // Register a built-in provider with a factory function
    void registerBuiltinProvider(const QString& name, const QString& identifier, BuiltinFactory factory);
    
    // Unregister a provider (called when unloading plugins)
    void unregisterProvider(const QString& identifier);
    
    // Get all registered providers
    const QList<ProviderInfo>& providers() const { return m_providers; }
    
    // Find provider by identifier
    const ProviderInfo* findProvider(const QString& identifier) const;
    
    // Clear all providers
    void clear();
    
private:
    ProviderRegistry() = default;
    QList<ProviderInfo> m_providers;
};

```

`src/providers/buffer_provider.h`:

```h
#pragma once
#include "provider.h"
#include <QFile>
#include <QFileInfo>

namespace rcx {

class BufferProvider : public Provider {
    QByteArray m_data;
    QString    m_name;

public:
    explicit BufferProvider(QByteArray data, const QString& name = {})
        : m_data(std::move(data))
        , m_name(name) {}

    static BufferProvider fromFile(const QString& path) {
        QFile f(path);
        if (f.open(QIODevice::ReadOnly))
            return BufferProvider(f.readAll(), QFileInfo(path).fileName());
        return BufferProvider({});
    }

    int size() const override { return m_data.size(); }

    bool read(uint64_t addr, void* buf, int len) const override {
        if (!isReadable(addr, len)) return false;
        std::memcpy(buf, m_data.constData() + addr, len);
        return true;
    }

    bool isWritable() const override { return true; }

    bool write(uint64_t addr, const void* buf, int len) override {
        if (!isReadable(addr, len)) return false;
        std::memcpy(m_data.data() + addr, buf, len);
        return true;
    }

    QString name() const override { return m_name; }
    QString kind() const override { return QStringLiteral("File"); }

    const QByteArray& data() const { return m_data; }
    QByteArray& data() { return m_data; }
};

} // namespace rcx

```

`src/providers/null_provider.h`:

```h
#pragma once
#include "provider.h"

namespace rcx {

class NullProvider : public Provider {
public:
    int  size() const override { return 0; }
    bool read(uint64_t, void*, int) const override { return false; }
    // name() returns "" via base default -- triggers <Select Source> in command row
    // kind() returns "File" via base default
};

} // namespace rcx

```

`src/providers/provider.h`:

```h
#pragma once
#include <QByteArray>
#include <QString>
#include <cstdint>
#include <cstring>

namespace rcx {

class Provider {
public:
    virtual ~Provider() = default;

    // --- Subclasses MUST implement these two ---
    virtual bool read(uint64_t addr, void* buf, int len) const = 0;
    virtual int  size() const = 0;

    // --- Optional overrides ---
    virtual bool write(uint64_t addr, const void* buf, int len) {
        Q_UNUSED(addr); Q_UNUSED(buf); Q_UNUSED(len);
        return false;
    }
    virtual bool isWritable() const { return false; }

    // Human-readable label for this source.
    // Examples: "notepad.exe", "dump.bin", "tcp://10.0.0.1:1337"
    virtual QString name() const { return {}; }

    // Whether data can change externally (e.g. live process, network socket).
    // Auto-refresh is only active for live providers.
    virtual bool isLive() const { return false; }

    // Category tag for the command row Source span.
    // Examples: "File", "Process", "Socket"
    virtual QString kind() const { return QStringLiteral("File"); }

    // Initial base address discovered by the provider (e.g. main module base).
    // Used by the controller to set tree.baseAddress on first attach.
    // For file/buffer providers this is always 0.
    virtual uint64_t base() const { return 0; }

    // Resolve an absolute address to a symbol name.
    // Returns empty string if no symbol is known.
    // Example: "ntdll.dll+0x1A30"
    // BufferProvider: "" (no symbols in flat files)
    virtual QString getSymbol(uint64_t addr) const {
        Q_UNUSED(addr);
        return {};
    }

    // Resolve a module/symbol name to its address (reverse of getSymbol).
    // Returns 0 if the name is not found.
    virtual uint64_t symbolToAddress(const QString& name) const {
        Q_UNUSED(name);
        return 0;
    }

    // --- Derived convenience (non-virtual, never override) ---

    bool isValid() const { return size() > 0; }

    virtual bool isReadable(uint64_t addr, int len) const {
        if (len <= 0) return (len == 0);
        uint64_t ulen = (uint64_t)len;
        return addr <= (uint64_t)size() && ulen <= (uint64_t)size() - addr;
    }

    template<typename T>
    T readAs(uint64_t addr) const {
        T v{};
        read(addr, &v, sizeof(T));
        return v;
    }

    uint8_t  readU8 (uint64_t a) const { return readAs<uint8_t>(a);  }
    uint16_t readU16(uint64_t a) const { return readAs<uint16_t>(a); }
    uint32_t readU32(uint64_t a) const { return readAs<uint32_t>(a); }
    uint64_t readU64(uint64_t a) const { return readAs<uint64_t>(a); }
    float    readF32(uint64_t a) const { return readAs<float>(a);    }
    double   readF64(uint64_t a) const { return readAs<double>(a);   }

    QByteArray readBytes(uint64_t addr, int len) const {
        if (len <= 0) return {};
        QByteArray buf(len, Qt::Uninitialized);
        if (!read(addr, buf.data(), len))
            buf.fill('\0');
        return buf;
    }

    bool writeBytes(uint64_t addr, const QByteArray& d) {
        return write(addr, d.constData(), d.size());
    }
};

} // namespace rcx

```

`src/providers/snapshot_provider.h`:

```h
#pragma once
#include "provider.h"
#include <QHash>
#include <memory>

namespace rcx {

// Page-based snapshot provider.
//
// During async refresh the controller reads pages for the main struct and
// every reachable pointer target.  Compose reads entirely from this page
// table — no fallback to the real provider, no blocking I/O on the UI
// thread.  Pages that were never fetched (truly invalid pointers) simply
// read as zeros.
class SnapshotProvider : public Provider {
    std::shared_ptr<Provider> m_real;
    QHash<uint64_t, QByteArray> m_pages;   // page-aligned addr → 4096-byte page
    int m_mainExtent = 0;                  // logical size of the main struct range

    static constexpr uint64_t kPageSize = 4096;
    static constexpr uint64_t kPageMask = ~(kPageSize - 1);

public:
    using PageMap = QHash<uint64_t, QByteArray>;

    SnapshotProvider(std::shared_ptr<Provider> real, PageMap pages, int mainExtent)
        : m_real(std::move(real))
        , m_pages(std::move(pages))
        , m_mainExtent(mainExtent) {}

    bool read(uint64_t addr, void* buf, int len) const override {
        if (len <= 0) return false;
        char* out = static_cast<char*>(buf);
        uint64_t cur = addr;
        int remaining = len;
        while (remaining > 0) {
            uint64_t pageAddr = cur & kPageMask;
            int pageOff = static_cast<int>(cur - pageAddr);
            int chunk = qMin(remaining, static_cast<int>(kPageSize - pageOff));
            auto it = m_pages.constFind(pageAddr);
            if (it != m_pages.constEnd()) {
                std::memcpy(out, it->constData() + pageOff, chunk);
            } else {
                std::memset(out, 0, chunk);
            }
            out += chunk;
            cur += chunk;
            remaining -= chunk;
        }
        return true;
    }

    bool isReadable(uint64_t addr, int len) const override {
        if (len <= 0) return (len == 0);
        uint64_t end = addr + static_cast<uint64_t>(len);
        for (uint64_t p = addr & kPageMask; p < end; p += kPageSize) {
            if (!m_pages.contains(p)) return false;
        }
        return true;
    }

    int size() const override { return m_mainExtent; }
    bool isWritable() const override { return m_real ? m_real->isWritable() : false; }
    bool isLive() const override { return m_real ? m_real->isLive() : false; }
    QString name() const override { return m_real ? m_real->name() : QString(); }
    QString kind() const override { return m_real ? m_real->kind() : QStringLiteral("File"); }
    QString getSymbol(uint64_t addr) const override {
        return m_real ? m_real->getSymbol(addr) : QString();
    }
    uint64_t symbolToAddress(const QString& n) const override {
        return m_real ? m_real->symbolToAddress(n) : 0;
    }

    bool write(uint64_t addr, const void* buf, int len) override {
        if (!m_real) return false;
        bool ok = m_real->write(addr, buf, len);
        if (ok) patchPages(addr, buf, len);
        return ok;
    }

    // Replace the entire page table (called after async read completes)
    void updatePages(PageMap pages, int mainExtent) {
        m_pages = std::move(pages);
        m_mainExtent = mainExtent;
    }

    // Patch specific bytes in existing pages (called after user writes a value)
    void patchPages(uint64_t addr, const void* buf, int len) {
        const char* src = static_cast<const char*>(buf);
        uint64_t cur = addr;
        int remaining = len;
        while (remaining > 0) {
            uint64_t pageAddr = cur & kPageMask;
            int pageOff = static_cast<int>(cur - pageAddr);
            int chunk = qMin(remaining, static_cast<int>(kPageSize - pageOff));
            auto it = m_pages.find(pageAddr);
            if (it != m_pages.end()) {
                std::memcpy(it->data() + pageOff, src, chunk);
            }
            src += chunk;
            cur += chunk;
            remaining -= chunk;
        }
    }

    const PageMap& pages() const { return m_pages; }
};

} // namespace rcx

```

`src/resources.qrc`:

```qrc
<RCC>
    <qresource prefix="/icons">
        <file alias="chevron-right.png">icons/chevron-right.png</file>
        <file alias="chevron-down.png">icons/chevron-down.png</file>
        <file alias="class.png">icons/class.png</file>

    </qresource>
    <qresource prefix="/fonts">
        <file alias="JetBrainsMono.ttf">fonts/JetBrainsMono.ttf</file>
    </qresource>
    <qresource prefix="/vsicons">
        <file alias="file.svg">vsicons/file.svg</file>
        <file alias="folder-opened.svg">vsicons/folder-opened.svg</file>
        <file alias="save.svg">vsicons/save.svg</file>
        <file alias="save-as.svg">vsicons/save-as.svg</file>
        <file alias="save-all.svg">vsicons/save-all.svg</file>
        <file alias="file-binary.svg">vsicons/file-binary.svg</file>
        <file alias="debug.svg">vsicons/debug.svg</file>
        <file alias="close.svg">vsicons/close.svg</file>
        <file alias="arrow-left.svg">vsicons/arrow-left.svg</file>
        <file alias="arrow-right.svg">vsicons/arrow-right.svg</file>
        <file alias="split-horizontal.svg">vsicons/split-horizontal.svg</file>
        <file alias="chrome-close.svg">vsicons/chrome-close.svg</file>
        <file alias="chrome-minimize.svg">vsicons/chrome-minimize.svg</file>
        <file alias="chrome-maximize.svg">vsicons/chrome-maximize.svg</file>
        <file alias="chrome-restore.svg">vsicons/chrome-restore.svg</file>
        <file alias="text-size.svg">vsicons/text-size.svg</file>
        <file alias="add.svg">vsicons/add.svg</file>
        <file alias="remove.svg">vsicons/remove.svg</file>
        <file alias="symbol-structure.svg">vsicons/symbol-structure.svg</file>
        <file alias="edit.svg">vsicons/edit.svg</file>
        <file alias="files.svg">vsicons/files.svg</file>
        <file alias="extensions.svg">vsicons/extensions.svg</file>
        <file alias="question.svg">vsicons/question.svg</file>
        <file alias="eye.svg">vsicons/eye.svg</file>
        <file alias="code.svg">vsicons/code.svg</file>
        <file alias="export.svg">vsicons/export.svg</file>
        <file alias="preview.svg">vsicons/preview.svg</file>
        <file alias="trash.svg">vsicons/trash.svg</file>
        <file alias="clippy.svg">vsicons/clippy.svg</file>
        <file alias="link.svg">vsicons/link.svg</file>
        <file alias="diff-added.svg">vsicons/diff-added.svg</file>
        <file alias="expand-all.svg">vsicons/expand-all.svg</file>
        <file alias="collapse-all.svg">vsicons/collapse-all.svg</file>
        <file alias="rename.svg">vsicons/rename.svg</file>
        <file alias="whole-word.svg">vsicons/whole-word.svg</file>
        <file alias="selection.svg">vsicons/list-selection.svg</file>
        <file alias="symbol-numeric.svg">vsicons/symbol-numeric.svg</file>
        <file alias="symbol-ruler.svg">vsicons/symbol-ruler.svg</file>
        <file alias="settings-gear.svg">vsicons/settings-gear.svg</file>
        <file alias="chevron-down.svg">vsicons/chevron-down.svg</file>
        <file alias="folder.svg">vsicons/folder.svg</file>
        <file alias="symbol-enum.svg">vsicons/symbol-enum.svg</file>
        <file alias="server-process.svg">vsicons/server-process.svg</file>
        <file alias="remote.svg">vsicons/remote.svg</file>
        <file alias="plug.svg">vsicons/plug.svg</file>
        <file alias="clear-all.svg">vsicons/clear-all.svg</file>
    </qresource>
</RCC>

```

`src/themes/defaults/mid.json`:

```json
{
    "name": "Mid",
    "background": "#0D1219",
    "backgroundAlt": "#121720",
    "surface": "#161C28",
    "border": "#1E2636",
    "borderFocused": "#485068",
    "button": "#181E2C",
    "text": "#B0B8CC",
    "textDim": "#505C74",
    "textMuted": "#384258",
    "textFaint": "#2C3448",
    "hover": "#121720",
    "selected": "#121720",
    "selection": "#1A2038",
    "syntaxKeyword": "#5688C0",
    "syntaxNumber": "#90B480",
    "syntaxString": "#B88060",
    "syntaxComment": "#385030",
    "syntaxPreproc": "#9868A8",
    "syntaxType": "#8FDBFE",
    "indHoverSpan": "#C09038",
    "indCmdPill": "#141A26",
    "indDataChanged": "#608C54",
    "indHeatCold": "#B09030",
    "indHeatWarm": "#C09038",
    "indHeatHot": "#C83838",
    "indHintGreen": "#385830",
    "markerPtr": "#C83838",
    "markerCycle": "#B89028",
    "markerError": "#481818"
}

```

`src/themes/defaults/reclass_dark.json`:

```json
{
    "name": "Reclass Dark",
    "background": "#1e1e1e",
    "backgroundAlt": "#252526",
    "surface": "#2a2d2e",
    "border": "#3c3c3c",
    "borderFocused": "#888888",
    "button": "#333333",
    "text": "#d4d4d4",
    "textDim": "#858585",
    "textMuted": "#585858",
    "textFaint": "#505050",
    "hover": "#1e1e1e",
    "selected": "#1e1e1e",
    "selection": "#2b2b2b",
    "syntaxKeyword": "#569cd6",
    "syntaxNumber": "#b5cea8",
    "syntaxString": "#ce9178",
    "syntaxComment": "#6a9955",
    "syntaxPreproc": "#c586c0",
    "syntaxType": "#4EC9B0",
    "indHoverSpan": "#E6B450",
    "indCmdPill": "#2a2a2a",
    "indDataChanged": "#8fbc7a",
    "indHeatCold": "#D4A945",
    "indHeatWarm": "#E6B450",
    "indHeatHot": "#f44747",
    "indHintGreen": "#5a8248",
    "markerPtr": "#f44747",
    "markerCycle": "#e5a00d",
    "markerError": "#7a2e2e"
}

```

`src/themes/defaults/vs.json`:

```json
{
    "name": "VS2022 Dark",
    "background": "#1e1e1e",
    "backgroundAlt": "#2d2d30",
    "surface": "#333337",
    "border": "#3f3f46",
    "borderFocused": "#b180d7",
    "button": "#3f3f46",
    "text": "#dcdcdc",
    "textDim": "#858585",
    "textMuted": "#636369",
    "textFaint": "#4d4d55",
    "hover": "#2c2c2f",
    "selected": "#262629",
    "selection": "#264f78",
    "syntaxKeyword": "#569cd6",
    "syntaxNumber": "#b5cea8",
    "syntaxString": "#d69d85",
    "syntaxComment": "#57a64a",
    "syntaxPreproc": "#9b9b9b",
    "syntaxType": "#4ec9b0",
    "indHoverSpan": "#b180d7",
    "indCmdPill": "#2d2d30",
    "indDataChanged": "#8fbc7a",
    "indHeatCold": "#D4A945",
    "indHeatWarm": "#d69d85",
    "indHeatHot": "#f44747",
    "indHintGreen": "#5a8248",
    "markerPtr": "#f44747",
    "markerCycle": "#e5a00d",
    "markerError": "#7a2e2e"
}

```

`src/themes/defaults/warm.json`:

```json
{
    "name": "Warm",
    "background": "#212121",
    "backgroundAlt": "#2a2a2a",
    "surface": "#2a2a2a",
    "border": "#373737",
    "borderFocused": "#888888",
    "button": "#373737",
    "text": "#AAA99F",
    "textDim": "#7a7a6e",
    "textMuted": "#555550",
    "textFaint": "#464646",
    "hover": "#282828",
    "selected": "#262626",
    "selection": "#21213A",
    "syntaxKeyword": "#AA9565",
    "syntaxNumber": "#AAA98C",
    "syntaxString": "#6B3B21",
    "syntaxComment": "#464646",
    "syntaxPreproc": "#AA9565",
    "syntaxType": "#6B959F",
    "indHoverSpan": "#AA9565",
    "indCmdPill": "#2a2a2a",
    "indDataChanged": "#6B959F",
    "indHeatCold": "#C4A44A",
    "indHeatWarm": "#AA9565",
    "indHeatHot": "#A05040",
    "indHintGreen": "#464646",
    "markerPtr": "#6B3B21",
    "markerCycle": "#AA9565",
    "markerError": "#3C2121"
}

```

`src/themes/theme.cpp`:

```cpp
#include "theme.h"
#include <QtGlobal>
#include <type_traits>

namespace rcx {

// ── Shared field metadata (serialization + editor UI) ──

const ThemeFieldMeta kThemeFields[] = {
    {"background",    "Background",     "Chrome",      &Theme::background},
    {"backgroundAlt", "Background Alt", "Chrome",      &Theme::backgroundAlt},
    {"surface",       "Surface",        "Chrome",      &Theme::surface},
    {"border",        "Border",         "Chrome",      &Theme::border},
    {"borderFocused", "Border Focused", "Chrome",      &Theme::borderFocused},
    {"button",        "Button",         "Chrome",      &Theme::button},
    {"text",          "Text",           "Text",        &Theme::text},
    {"textDim",       "Text Dim",       "Text",        &Theme::textDim},
    {"textMuted",     "Text Muted",     "Text",        &Theme::textMuted},
    {"textFaint",     "Text Faint",     "Text",        &Theme::textFaint},
    {"hover",         "Hover",          "Interactive",  &Theme::hover},
    {"selected",      "Selected",       "Interactive",  &Theme::selected},
    {"selection",     "Selection",      "Interactive",  &Theme::selection},
    {"syntaxKeyword", "Keyword",        "Syntax",      &Theme::syntaxKeyword},
    {"syntaxNumber",  "Number",         "Syntax",      &Theme::syntaxNumber},
    {"syntaxString",  "String",         "Syntax",      &Theme::syntaxString},
    {"syntaxComment", "Comment",        "Syntax",      &Theme::syntaxComment},
    {"syntaxPreproc", "Preprocessor",   "Syntax",      &Theme::syntaxPreproc},
    {"syntaxType",    "Type",           "Syntax",      &Theme::syntaxType},
    {"indHoverSpan",  "Hover Span",     "Indicators",  &Theme::indHoverSpan},
    {"indCmdPill",    "Cmd Pill",       "Indicators",  &Theme::indCmdPill},
    {"indDataChanged","Data Changed",   "Indicators",  &Theme::indDataChanged},
    {"indHeatCold",   "Heat Cold",      "Indicators",  &Theme::indHeatCold},
    {"indHeatWarm",   "Heat Warm",      "Indicators",  &Theme::indHeatWarm},
    {"indHeatHot",    "Heat Hot",       "Indicators",  &Theme::indHeatHot},
    {"indHintGreen",  "Hint Green",     "Indicators",  &Theme::indHintGreen},
    {"markerPtr",     "Pointer",        "Markers",     &Theme::markerPtr},
    {"markerCycle",   "Cycle",          "Markers",     &Theme::markerCycle},
    {"markerError",   "Error",          "Markers",     &Theme::markerError},
};
const int kThemeFieldCount = static_cast<int>(std::extent_v<decltype(kThemeFields)>);

QJsonObject Theme::toJson() const {
    QJsonObject o;
    o["name"] = name;
    for (int i = 0; i < kThemeFieldCount; i++)
        o[kThemeFields[i].key] = (this->*kThemeFields[i].ptr).name();
    return o;
}

Theme Theme::fromJson(const QJsonObject& o) {
    Theme t;
    t.name = o["name"].toString("Untitled");
    for (int i = 0; i < kThemeFieldCount; i++) {
        if (o.contains(kThemeFields[i].key))
            t.*kThemeFields[i].ptr = QColor(o[kThemeFields[i].key].toString());
    }
    // Derive heat colors from the theme's own palette when keys are absent
    // cold = muted yellow, warm = hover/string amber, hot = marker red
    if (!t.indHeatCold.isValid())
        t.indHeatCold = QColor("#D4A945");
    if (!t.indHeatWarm.isValid())
        t.indHeatWarm = t.indHoverSpan.isValid() ? t.indHoverSpan : t.syntaxString;
    if (!t.indHeatHot.isValid())
        t.indHeatHot = t.markerPtr;

    // Ensure hover is visually distinct from background
    if (t.hover.isValid() && t.background.isValid()) {
        int dist = qAbs(t.hover.red() - t.background.red())
                 + qAbs(t.hover.green() - t.background.green())
                 + qAbs(t.hover.blue() - t.background.blue());
        if (dist < 20)
            t.hover = t.background.lighter(130);
    }
    return t;
}

} // namespace rcx

```

`src/themes/theme.h`:

```h
#pragma once
#include <QColor>
#include <QString>
#include <QJsonObject>

namespace rcx {

struct Theme {
    QString name;

    // ── Chrome ──
    QColor background;      // editor bg, margin bg, window
    QColor backgroundAlt;   // panels, tab selected, tooltips
    QColor surface;         // alternateBase
    QColor border;          // separators, menu borders
    QColor borderFocused;   // window border when focused
    QColor button;          // button bg

    // ── Text ──
    QColor text;            // primary text, caret, identifiers
    QColor textDim;         // margin fg, status bar
    QColor textMuted;       // inactive tab, disabled menu
    QColor textFaint;       // margin dim, hex dim

    // ── Interactive ──
    QColor hover;           // row hover, tab hover, menu hover
    QColor selected;        // row selection highlight
    QColor selection;       // text selection background

    // ── Syntax ──
    QColor syntaxKeyword;
    QColor syntaxNumber;
    QColor syntaxString;
    QColor syntaxComment;
    QColor syntaxPreproc;
    QColor syntaxType;      // custom types / GlobalClass

    // ── Indicators ──
    QColor indHoverSpan;    // hover link text
    QColor indCmdPill;      // command row pill bg
    QColor indDataChanged;  // changed data values (legacy, fallback for old themes)
    QColor indHeatCold;     // heatmap level 1 (changed once)
    QColor indHeatWarm;     // heatmap level 2 (moderate changes)
    QColor indHeatHot;      // heatmap level 3 (frequent changes)
    QColor indHintGreen;    // comment/hint text

    // ── Markers ──
    QColor markerPtr;       // null pointer
    QColor markerCycle;     // cycle detection
    QColor markerError;     // error row bg

    QJsonObject toJson() const;
    static Theme fromJson(const QJsonObject& obj);
};

// ── Shared field metadata (serialization + editor UI) ──

struct ThemeFieldMeta {
    const char*    key;     // JSON key
    const char*    label;   // display label
    const char*    group;   // section group name
    QColor Theme::*ptr;
};

extern const ThemeFieldMeta kThemeFields[];
extern const int kThemeFieldCount;

} // namespace rcx

```

`src/themes/themeeditor.cpp`:

```cpp
#include "themeeditor.h"
#include "thememanager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QScrollArea>
#include <QDialogButtonBox>
#include <QColorDialog>
#include <QComboBox>
#include <cstring>

namespace rcx {

// ── Section header label ──

static QLabel* makeSectionLabel(const QString& text) {
    auto* lbl = new QLabel(text);
    lbl->setStyleSheet(QStringLiteral(
        "font-weight: bold; font-size: 11px; color: #888;"
        "padding: 6px 0 2px 0; border-bottom: 1px solid #444;"));
    return lbl;
}

// ── Constructor ──

ThemeEditor::ThemeEditor(int themeIndex, QWidget* parent)
    : QDialog(parent), m_themeIndex(themeIndex)
{
    auto& tm = ThemeManager::instance();
    auto all = tm.themes();
    m_theme = (themeIndex >= 0 && themeIndex < all.size()) ? all[themeIndex] : tm.current();

    setWindowTitle(QStringLiteral("Theme Editor"));
    setMinimumSize(420, 480);
    resize(440, 640);

    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(6);

    // ── Theme selector combo ──
    {
        auto* row = new QHBoxLayout;
        row->addWidget(new QLabel(QStringLiteral("Theme:")));
        m_themeCombo = new QComboBox;
        for (const auto& t : all)
            m_themeCombo->addItem(t.name);
        m_themeCombo->setCurrentIndex(themeIndex);
        connect(m_themeCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),
                this, [this](int idx) { loadTheme(idx); });
        row->addWidget(m_themeCombo, 1);
        mainLayout->addLayout(row);
    }

    // ── Name field ──
    {
        auto* row = new QHBoxLayout;
        row->addWidget(new QLabel(QStringLiteral("Name:")));
        m_nameEdit = new QLineEdit(m_theme.name);
        connect(m_nameEdit, &QLineEdit::textChanged, this, [this](const QString& t) {
            m_theme.name = t;
        });
        row->addWidget(m_nameEdit, 1);
        mainLayout->addLayout(row);
    }

    // ── File info ──
    m_fileInfoLabel = new QLabel;
    m_fileInfoLabel->setStyleSheet(QStringLiteral("color: #666; font-size: 10px; padding: 0 0 4px 0;"));
    QString path = tm.themeFilePath(themeIndex);
    m_fileInfoLabel->setText(path.isEmpty()
        ? QStringLiteral("Built-in theme (edits save as user copy)")
        : QStringLiteral("File: %1").arg(path));
    mainLayout->addWidget(m_fileInfoLabel);

    // ── Scrollable area for swatches ──
    auto* scroll = new QScrollArea;
    scroll->setWidgetResizable(true);
    scroll->setFrameShape(QFrame::NoFrame);
    auto* scrollWidget = new QWidget;
    auto* scrollLayout = new QVBoxLayout(scrollWidget);
    scrollLayout->setContentsMargins(0, 0, 6, 0);  // right margin for scrollbar
    scrollLayout->setSpacing(2);

    // ── Color swatches (driven by kThemeFields) ──
    const char* currentGroup = nullptr;
    for (int fi = 0; fi < kThemeFieldCount; fi++) {
        const auto& f = kThemeFields[fi];

        // Section header on group change
        if (!currentGroup || std::strcmp(currentGroup, f.group) != 0) {
            scrollLayout->addWidget(makeSectionLabel(QString::fromLatin1(f.group)));
            currentGroup = f.group;
        }

        int idx = m_swatches.size();

        auto* row = new QHBoxLayout;
        row->setSpacing(6);
        row->setContentsMargins(8, 1, 0, 1);

        auto* lbl = new QLabel(QString::fromLatin1(f.label));
        lbl->setFixedWidth(120);
        row->addWidget(lbl);

        auto* swatchBtn = new QPushButton;
        swatchBtn->setFixedSize(32, 18);
        swatchBtn->setCursor(Qt::PointingHandCursor);
        connect(swatchBtn, &QPushButton::clicked, this, [this, idx]() { pickColor(idx); });
        row->addWidget(swatchBtn);

        auto* hexLbl = new QLabel;
        hexLbl->setFixedWidth(60);
        hexLbl->setStyleSheet(QStringLiteral("color: #aaa; font-size: 10px;"));
        row->addWidget(hexLbl);

        row->addStretch();

        SwatchEntry se;
        se.label = f.label;
        se.field = f.ptr;
        se.swatchBtn = swatchBtn;
        se.hexLabel = hexLbl;
        m_swatches.append(se);

        scrollLayout->addLayout(row);
    }

    scrollLayout->addStretch();
    scroll->setWidget(scrollWidget);
    mainLayout->addWidget(scroll, 1);

    // ── Bottom bar ──
    auto* bottomRow = new QHBoxLayout;
    bottomRow->addStretch();

    auto* buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    connect(buttons, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(buttons, &QDialogButtonBox::rejected, this, [this]() {
        ThemeManager::instance().revertPreview();
        reject();
    });
    bottomRow->addWidget(buttons);
    mainLayout->addLayout(bottomRow);

    // Initial swatch update + start live preview
    for (int i = 0; i < m_swatches.size(); i++)
        updateSwatch(i);
    tm.previewTheme(m_theme);
}

// ── Load a different theme into the editor ──

void ThemeEditor::loadTheme(int index) {
    auto& tm = ThemeManager::instance();
    auto all = tm.themes();
    if (index < 0 || index >= all.size()) return;

    m_themeIndex = index;
    m_theme = all[index];
    m_nameEdit->setText(m_theme.name);

    QString path = tm.themeFilePath(index);
    m_fileInfoLabel->setText(path.isEmpty()
        ? QStringLiteral("Built-in theme (edits save as user copy)")
        : QStringLiteral("File: %1").arg(path));

    for (int i = 0; i < m_swatches.size(); i++)
        updateSwatch(i);

    tm.previewTheme(m_theme);
}

// ── Swatch update ──

void ThemeEditor::updateSwatch(int idx) {
    auto& s = m_swatches[idx];
    QColor c = m_theme.*s.field;

    s.swatchBtn->setStyleSheet(QStringLiteral(
        "QPushButton { background: %1; border: 1px solid #555; border-radius: 2px; }")
        .arg(c.name()));
    s.hexLabel->setText(c.name());
}

// ── Color picker ──

void ThemeEditor::pickColor(int idx) {
    auto& s = m_swatches[idx];
    QColor c = QColorDialog::getColor(m_theme.*s.field, this, QString::fromLatin1(s.label));
    if (c.isValid()) {
        m_theme.*s.field = c;
        updateSwatch(idx);
        ThemeManager::instance().previewTheme(m_theme);
    }
}

} // namespace rcx

```

`src/themes/themeeditor.h`:

```h
#pragma once
#include "theme.h"
#include <QDialog>
#include <QVector>
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>

class QScrollArea;
class QVBoxLayout;
class QComboBox;

namespace rcx {

class ThemeEditor : public QDialog {
    Q_OBJECT
public:
    explicit ThemeEditor(int themeIndex, QWidget* parent = nullptr);
    Theme result() const { return m_theme; }
    int selectedIndex() const { return m_themeIndex; }

private:
    Theme m_theme;
    int   m_themeIndex;

    // ── Swatch row (compact: label + swatch + hex) ──
    struct SwatchEntry {
        const char*    label;
        QColor Theme::*field;
        QPushButton*   swatchBtn = nullptr;
        QLabel*        hexLabel  = nullptr;
    };
    QVector<SwatchEntry> m_swatches;

    // ── UI ──
    QComboBox*   m_themeCombo   = nullptr;
    QLineEdit*   m_nameEdit     = nullptr;
    QLabel*      m_fileInfoLabel = nullptr;

    void loadTheme(int index);
    void updateSwatch(int idx);
    void pickColor(int idx);
};

} // namespace rcx

```

`src/themes/thememanager.cpp`:

```cpp
#include "thememanager.h"
#include <QSettings>
#include <QDir>
#include <QFile>
#include <QJsonDocument>
#include <QStandardPaths>
#include <QCoreApplication>

namespace rcx {

ThemeManager& ThemeManager::instance() {
    static ThemeManager s;
    return s;
}

ThemeManager::ThemeManager() {
    loadBuiltInThemes();
    loadUserThemes();

    QSettings settings("Reclass", "Reclass");
    QString fallback;
    for (const auto& t : m_builtIn) {
        if (t.name.contains("VS2022", Qt::CaseInsensitive)) { fallback = t.name; break; }
    }
    if (fallback.isEmpty() && !m_builtIn.isEmpty()) fallback = m_builtIn[0].name;
    QString saved = settings.value("theme", fallback).toString();
    auto all = themes();
    for (int i = 0; i < all.size(); i++) {
        if (all[i].name == saved) { m_currentIdx = i; break; }
    }
}

// ── Load built-in themes from JSON files next to the executable ──

QString ThemeManager::builtInDir() const {
    return QCoreApplication::applicationDirPath() + "/themes";
}

void ThemeManager::loadBuiltInThemes() {
    m_builtIn.clear();
    QDir dir(builtInDir());
    if (!dir.exists()) return;
    for (const QString& name : dir.entryList({"*.json"}, QDir::Files, QDir::Name)) {
        QFile f(dir.filePath(name));
        if (!f.open(QIODevice::ReadOnly)) continue;
        QJsonDocument jdoc = QJsonDocument::fromJson(f.readAll());
        if (jdoc.isObject())
            m_builtIn.append(Theme::fromJson(jdoc.object()));
    }
    m_builtInDefaults = m_builtIn;
}

// ── themes / current ──

QVector<Theme> ThemeManager::themes() const {
    QVector<Theme> all = m_builtIn;
    all.append(m_user);
    return all;
}

const Theme& ThemeManager::current() const {
    if (m_currentIdx < m_builtIn.size())
        return m_builtIn[m_currentIdx];
    int userIdx = m_currentIdx - m_builtIn.size();
    if (userIdx >= 0 && userIdx < m_user.size())
        return m_user[userIdx];
    if (!m_builtIn.isEmpty())
        return m_builtIn[0];
    static const Theme empty;
    return empty;
}

void ThemeManager::setCurrent(int index) {
    auto all = themes();
    if (index < 0 || index >= all.size()) return;
    m_currentIdx = index;
    QSettings settings("Reclass", "Reclass");
    settings.setValue("theme", all[index].name);
    emit themeChanged(current());
}

void ThemeManager::addTheme(const Theme& theme) {
    m_user.append(theme);
    saveUserThemes();
}

void ThemeManager::updateTheme(int index, const Theme& theme) {
    m_previewing = false;  // commit any active preview

    if (index < builtInCount()) {
        m_builtIn[index] = theme;
        m_currentIdx = index;
    } else {
        int ui = index - builtInCount();
        if (ui >= 0 && ui < m_user.size())
            m_user[ui] = theme;
    }
    saveUserThemes();
    QSettings settings("Reclass", "Reclass");
    settings.setValue("theme", current().name);
    emit themeChanged(current());
}

void ThemeManager::removeTheme(int index) {
    if (index < builtInCount()) return;
    int ui = index - builtInCount();
    if (ui < 0 || ui >= m_user.size()) return;
    m_user.remove(ui);
    if (m_currentIdx == index) {
        m_currentIdx = 0;
        emit themeChanged(current());
    } else if (m_currentIdx > index) {
        m_currentIdx--;
    }
    saveUserThemes();
}

// ── User theme persistence ──

QString ThemeManager::userDir() const {
    QString dir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation)
                  + "/themes";
    QDir().mkpath(dir);
    return dir;
}

void ThemeManager::loadUserThemes() {
    m_user.clear();
    QDir dir(userDir());
    for (const QString& name : dir.entryList({"*.json"}, QDir::Files)) {
        QFile f(dir.filePath(name));
        if (!f.open(QIODevice::ReadOnly)) continue;
        QJsonDocument jdoc = QJsonDocument::fromJson(f.readAll());
        if (!jdoc.isObject()) continue;
        Theme t = Theme::fromJson(jdoc.object());

        // If this overrides a built-in (same name), replace it in-place
        bool isOverride = false;
        for (int i = 0; i < m_builtIn.size(); i++) {
            if (m_builtIn[i].name == t.name) {
                m_builtIn[i] = t;
                isOverride = true;
                break;
            }
        }
        if (!isOverride)
            m_user.append(t);
    }
}

void ThemeManager::saveUserThemes() const {
    QString dir = userDir();
    QDir d(dir);
    for (const QString& name : d.entryList({"*.json"}, QDir::Files))
        d.remove(name);

    // Save modified built-ins (compare against on-disk originals)
    for (int i = 0; i < m_builtIn.size() && i < m_builtInDefaults.size(); i++) {
        if (m_builtIn[i].toJson() != m_builtInDefaults[i].toJson()) {
            QString filename = m_builtIn[i].name.toLower().replace(' ', '_') + ".json";
            QFile f(dir + "/" + filename);
            if (f.open(QIODevice::WriteOnly))
                f.write(QJsonDocument(m_builtIn[i].toJson()).toJson(QJsonDocument::Indented));
        }
    }

    // Save user themes
    for (int i = 0; i < m_user.size(); i++) {
        QString filename = m_user[i].name.toLower().replace(' ', '_') + ".json";
        QFile f(dir + "/" + filename);
        if (f.open(QIODevice::WriteOnly))
            f.write(QJsonDocument(m_user[i].toJson()).toJson(QJsonDocument::Indented));
    }
}

QString ThemeManager::themeFilePath(int index) const {
    if (index < builtInCount()) {
        // Built-in has a user override file only if modified
        if (index < m_builtInDefaults.size()
            && m_builtIn[index].toJson() != m_builtInDefaults[index].toJson()) {
            QString filename = m_builtIn[index].name.toLower().replace(' ', '_') + ".json";
            return userDir() + "/" + filename;
        }
        // Show the built-in source file
        QString filename = m_builtIn[index].name.toLower().replace(' ', '_') + ".json";
        return builtInDir() + "/" + filename;
    }
    int ui = index - builtInCount();
    if (ui < 0 || ui >= m_user.size()) return {};
    QString filename = m_user[ui].name.toLower().replace(' ', '_') + ".json";
    return userDir() + "/" + filename;
}

void ThemeManager::previewTheme(const Theme& theme) {
    if (!m_previewing) {
        m_savedTheme = current();
        m_previewing = true;
    }
    emit themeChanged(theme);
}

void ThemeManager::revertPreview() {
    if (m_previewing) {
        m_previewing = false;
        emit themeChanged(m_savedTheme);
    }
}

} // namespace rcx

```

`src/themes/thememanager.h`:

```h
#pragma once
#include "theme.h"
#include <QObject>
#include <QVector>

namespace rcx {

class ThemeManager : public QObject {
    Q_OBJECT
public:
    static ThemeManager& instance();

    QVector<Theme> themes() const;
    int currentIndex() const { return m_currentIdx; }
    const Theme& current() const;

    void setCurrent(int index);
    void addTheme(const Theme& theme);
    void updateTheme(int index, const Theme& theme);
    void removeTheme(int index);

    void loadUserThemes();
    void saveUserThemes() const;

    QString themeFilePath(int index) const;
    void previewTheme(const Theme& theme);
    void revertPreview();

signals:
    void themeChanged(const rcx::Theme& theme);

private:
    ThemeManager();
    QVector<Theme> m_builtIn;          // built-in themes (possibly overridden)
    QVector<Theme> m_builtInDefaults;  // originals loaded from disk
    QVector<Theme> m_user;
    int m_currentIdx = 0;

    int builtInCount() const { return m_builtIn.size(); }
    void loadBuiltInThemes();
    QString builtInDir() const;
    QString userDir() const;
    bool m_previewing = false;
    Theme m_savedTheme;
};

} // namespace rcx

```

`src/titlebar.cpp`:

```cpp
#include "titlebar.h"
#include "themes/thememanager.h"
#include <QMouseEvent>
#include <QPainter>
#include <QStyle>
#include <QWindow>

namespace rcx {

TitleBarWidget::TitleBarWidget(QWidget* parent)
    : QWidget(parent)
    , m_theme(ThemeManager::instance().current())
{
    setFixedHeight(32);

    auto* layout = new QHBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->setSpacing(0);

    // App name
    m_appLabel = new QLabel(QStringLiteral("Reclass"), this);
    m_appLabel->setContentsMargins(10, 0, 4, 0);
    m_appLabel->setAlignment(Qt::AlignVCenter);
    m_appLabel->setAttribute(Qt::WA_TransparentForMouseEvents);
    layout->addWidget(m_appLabel);

    // Menu bar
    m_menuBar = new QMenuBar(this);
    m_menuBar->setNativeMenuBar(false);
    m_menuBar->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Expanding);
    layout->addWidget(m_menuBar);

    layout->addStretch();

    // Chrome buttons
    m_btnMin   = makeChromeButton(":/vsicons/chrome-minimize.svg");
    m_btnMax   = makeChromeButton(":/vsicons/chrome-maximize.svg");
    m_btnClose = makeChromeButton(":/vsicons/chrome-close.svg");

    layout->addWidget(m_btnMin);
    layout->addWidget(m_btnMax);
    layout->addWidget(m_btnClose);

    connect(m_btnMin, &QToolButton::clicked, this, [this]() {
        window()->showMinimized();
    });
    connect(m_btnMax, &QToolButton::clicked, this, [this]() {
        toggleMaximize();
    });
    connect(m_btnClose, &QToolButton::clicked, this, [this]() {
        window()->close();
    });
}

QToolButton* TitleBarWidget::makeChromeButton(const QString& iconPath) {
    auto* btn = new QToolButton(this);
    btn->setIcon(QIcon(iconPath));
    btn->setIconSize(QSize(16, 16));
    btn->setFixedSize(46, 32);
    btn->setAutoRaise(true);
    btn->setFocusPolicy(Qt::NoFocus);
    return btn;
}

void TitleBarWidget::applyTheme(const Theme& theme) {
    m_theme = theme;

    // Title bar background
    setAutoFillBackground(true);
    QPalette pal = palette();
    pal.setColor(QPalette::Window, theme.background);
    setPalette(pal);

    // App label
    m_appLabel->setStyleSheet(
        QStringLiteral("QLabel { color: %1; font-size: 12px; font-weight: bold; }")
            .arg(theme.textDim.name()));

    // Menu bar palette — hover/bg handled by MenuBarStyle QProxyStyle.
    // Set Window + Button to background so Fusion never paints a foreign color.
    {
        QPalette mbPal = m_menuBar->palette();
        mbPal.setColor(QPalette::Window, theme.background);
        mbPal.setColor(QPalette::Button, theme.background);
        mbPal.setColor(QPalette::ButtonText, theme.textDim);
        m_menuBar->setPalette(mbPal);
        m_menuBar->setAutoFillBackground(false);
    }

    // Chrome buttons
    QString btnStyle = QStringLiteral(
        "QToolButton { background: transparent; border: none; }"
        "QToolButton:hover { background: %1; }")
        .arg(theme.hover.name());
    m_btnMin->setStyleSheet(btnStyle);
    m_btnMax->setStyleSheet(btnStyle);

    // Close button: red hover
    m_btnClose->setStyleSheet(QStringLiteral(
        "QToolButton { background: transparent; border: none; }"
        "QToolButton:hover { background: #c42b1c; }"));

    update();
}

void TitleBarWidget::setShowIcon(bool show) {
    if (show) {
        m_appLabel->setText(QString());
        m_appLabel->setPixmap(QIcon(":/icons/class.png").pixmap(24, 24));
    } else {
        m_appLabel->setPixmap(QPixmap());
        m_appLabel->setText(QStringLiteral("Reclass"));
        m_appLabel->setStyleSheet(
            QStringLiteral("QLabel { color: %1; font-size: 12px; font-weight: bold; }")
                .arg(m_theme.textDim.name()));
    }
}

void TitleBarWidget::setMenuBarTitleCase(bool titleCase) {
    m_titleCase = titleCase;
    for (QAction* action : m_menuBar->actions()) {
        QString text = action->text();
        QString clean = text;
        clean.remove('&');

        if (titleCase) {
            action->setText("&" + clean.toUpper());
        } else {
            QString result;
            bool capitalizeNext = true;
            for (int i = 0; i < clean.length(); ++i) {
                QChar ch = clean[i];
                if (ch.isLetter()) {
                    result += capitalizeNext ? ch.toUpper() : ch.toLower();
                    capitalizeNext = false;
                } else {
                    result += ch;
                    if (ch.isSpace()) capitalizeNext = true;
                }
            }
            action->setText("&" + result);
        }
    }
}

void TitleBarWidget::updateMaximizeIcon() {
    if (window()->isMaximized())
        m_btnMax->setIcon(QIcon(":/vsicons/chrome-restore.svg"));
    else
        m_btnMax->setIcon(QIcon(":/vsicons/chrome-maximize.svg"));
}

void TitleBarWidget::toggleMaximize() {
    if (window()->isMaximized())
        window()->showNormal();
    else
        window()->showMaximized();
    updateMaximizeIcon();
}

void TitleBarWidget::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        window()->windowHandle()->startSystemMove();
        event->accept();
    } else {
        QWidget::mousePressEvent(event);
    }
}

void TitleBarWidget::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        toggleMaximize();
        event->accept();
    } else {
        QWidget::mouseDoubleClickEvent(event);
    }
}

void TitleBarWidget::paintEvent(QPaintEvent* event) {
    QWidget::paintEvent(event);

    // 1px bottom border
    QPainter p(this);
    p.setPen(m_theme.border);
    p.drawLine(0, height() - 1, width() - 1, height() - 1);
}

} // namespace rcx

```

`src/titlebar.h`:

```h
#pragma once
#include "themes/theme.h"
#include <QWidget>
#include <QMenuBar>
#include <QToolButton>
#include <QLabel>
#include <QHBoxLayout>

namespace rcx {

class TitleBarWidget : public QWidget {
    Q_OBJECT
public:
    explicit TitleBarWidget(QWidget* parent = nullptr);

    QMenuBar* menuBar() const { return m_menuBar; }
    void applyTheme(const Theme& theme);
    void setShowIcon(bool show);
    void setMenuBarTitleCase(bool titleCase);
    bool menuBarTitleCase() const { return m_titleCase; }

    void updateMaximizeIcon();

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;
    void paintEvent(QPaintEvent* event) override;

private:
    QLabel*      m_appLabel   = nullptr;
    QMenuBar*    m_menuBar    = nullptr;
    QToolButton* m_btnMin     = nullptr;
    QToolButton* m_btnMax     = nullptr;
    QToolButton* m_btnClose   = nullptr;

    Theme m_theme;
    bool  m_titleCase = false;

    QToolButton* makeChromeButton(const QString& iconPath);
    void toggleMaximize();
};

} // namespace rcx

```

`src/typeselectorpopup.cpp`:

```cpp
#include "typeselectorpopup.h"

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QLineEdit>
#include <QListView>
#include <QToolButton>
#include <QButtonGroup>
#include <QStringListModel>
#include <QStyledItemDelegate>
#include <QPainter>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QIcon>
#include <QApplication>
#include <QScreen>
#include <QIntValidator>
#include <QElapsedTimer>
#include "themes/thememanager.h"

namespace rcx {

// ── parseTypeSpec ──

TypeSpec parseTypeSpec(const QString& text) {
    TypeSpec spec;
    QString s = text.trimmed();
    if (s.isEmpty()) return spec;

    // Check for pointer suffix: "Ball*" or "Ball**"
    if (s.endsWith('*')) {
        spec.isPointer = true;
        s.chop(1);
        spec.ptrDepth = 1;
        if (s.endsWith('*')) { s.chop(1); spec.ptrDepth = 2; }
        spec.baseName = s.trimmed();
        return spec;
    }

    // Check for array suffix: "int32_t[10]"
    int bracket = s.indexOf('[');
    if (bracket > 0 && s.endsWith(']')) {
        spec.baseName = s.left(bracket).trimmed();
        QString countStr = s.mid(bracket + 1, s.size() - bracket - 2);
        bool ok;
        int count = countStr.toInt(&ok);
        if (ok && count > 0)
            spec.arrayCount = count;
        return spec;
    }

    spec.baseName = s;
    return spec;
}

// ── Custom delegate: gutter checkmark + icon + text + sections ──

class TypeSelectorDelegate : public QStyledItemDelegate {
public:
    explicit TypeSelectorDelegate(TypeSelectorPopup* popup, QObject* parent = nullptr)
        : QStyledItemDelegate(parent), m_popup(popup) {}

    void setFont(const QFont& f) { m_font = f; }
    void setFilteredTypes(const QVector<TypeEntry>* filtered, const TypeEntry* current, bool hasCurrent) {
        m_filtered = filtered;
        m_current = current;
        m_hasCurrent = hasCurrent;
    }

    void paint(QPainter* painter, const QStyleOptionViewItem& option,
               const QModelIndex& index) const override {
        painter->save();

        const auto& t = ThemeManager::instance().current();
        int row = index.row();
        bool isSection = (m_filtered && row >= 0 && row < m_filtered->size()
                          && (*m_filtered)[row].entryKind == TypeEntry::Section);
        bool isDisabled = (m_filtered && row >= 0 && row < m_filtered->size()
                           && !(*m_filtered)[row].enabled);

        // Background
        if (isSection) {
            // No background highlight for sections
        } else if (isDisabled) {
            // Subtle background on hover only
            if (option.state & QStyle::State_MouseOver)
                painter->fillRect(option.rect, t.surface);
        } else {
            if (option.state & QStyle::State_Selected)
                painter->fillRect(option.rect, t.selected);
            else if (option.state & QStyle::State_MouseOver)
                painter->fillRect(option.rect, t.hover);
        }

        int x = option.rect.x();
        int y = option.rect.y();
        int h = option.rect.height();
        int w = option.rect.width();

        // Scale metrics from font height
        QFontMetrics fmMain(m_font);
        int iconSz = fmMain.height();            // icon matches text height
        int gutterW = fmMain.horizontalAdvance(QChar(0x25B8)) + 4;
        int iconColW = iconSz + 4;

        // Section: centered dim text with horizontal rules
        if (isSection) {
            painter->setPen(t.textDim);
            QFont dimFont = m_font;
            dimFont.setPointSize(qMax(7, m_font.pointSize() - 1));
            painter->setFont(dimFont);
            QFontMetrics fm(dimFont);
            QString text = index.data().toString();
            int textW = fm.horizontalAdvance(text);
            int textX = x + (w - textW) / 2;
            int lineY = y + h / 2;

            // Left rule
            if (textX > x + 8)
                painter->drawLine(x + 8, lineY, textX - 6, lineY);
            // Text
            painter->drawText(QRect(textX, y, textW, h), Qt::AlignVCenter, text);
            // Right rule
            if (textX + textW + 6 < x + w - 8)
                painter->drawLine(textX + textW + 6, lineY, x + w - 8, lineY);

            painter->restore();
            return;
        }

        // Gutter: side triangle if current
        if (m_hasCurrent && m_filtered && row >= 0 && row < m_filtered->size()) {
            const TypeEntry& entry = (*m_filtered)[row];
            bool isCurrent = false;
            if (m_current->entryKind == TypeEntry::Primitive && entry.entryKind == TypeEntry::Primitive)
                isCurrent = (entry.primitiveKind == m_current->primitiveKind);
            else if (m_current->entryKind == TypeEntry::Composite && entry.entryKind == TypeEntry::Composite)
                isCurrent = (entry.structId == m_current->structId);
            if (isCurrent) {
                painter->setPen(t.text);
                painter->setFont(m_font);
                painter->drawText(QRect(x, y, gutterW, h), Qt::AlignCenter,
                                  QString(QChar(0x25B8)));
            }
        }
        x += gutterW;

        // Icon (scaled to font height) — only for composite entries
        bool hasIcon = (m_filtered && row >= 0 && row < m_filtered->size()
                        && (*m_filtered)[row].entryKind == TypeEntry::Composite);
        if (hasIcon) {
            static QIcon structIcon(QStringLiteral(":/vsicons/symbol-structure.svg"));
            QPixmap pm = structIcon.pixmap(iconSz, iconSz);
            if (isDisabled) {
                // Paint dimmed
                QPixmap dimmed(pm.size());
                dimmed.fill(Qt::transparent);
                QPainter p(&dimmed);
                p.setOpacity(0.35);
                p.drawPixmap(0, 0, pm);
                p.end();
                painter->drawPixmap(x, y + (h - iconSz) / 2, dimmed);
            } else {
                structIcon.paint(painter, x, y + (h - iconSz) / 2, iconSz, iconSz);
            }
        }
        x += iconColW;

        // Text
        QColor textColor;
        if (isDisabled)
            textColor = t.textDim;
        else if (option.state & QStyle::State_Selected)
            textColor = option.palette.color(QPalette::HighlightedText);
        else
            textColor = option.palette.color(QPalette::Text);

        painter->setPen(textColor);
        painter->setFont(m_font);
        painter->drawText(QRect(x, y, option.rect.right() - x, h),
                          Qt::AlignVCenter | Qt::AlignLeft,
                          index.data().toString());

        painter->restore();
    }

    QSize sizeHint(const QStyleOptionViewItem& /*option*/,
                   const QModelIndex& index) const override {
        QFontMetrics fm(m_font);
        int row = index.row();
        bool isSection = (m_filtered && row >= 0 && row < m_filtered->size()
                          && (*m_filtered)[row].entryKind == TypeEntry::Section);
        int h = isSection ? fm.height() + 2 : fm.height() + 8;
        return QSize(200, h);
    }

private:
    TypeSelectorPopup* m_popup = nullptr;
    QFont m_font;
    const QVector<TypeEntry>* m_filtered = nullptr;
    const TypeEntry* m_current = nullptr;
    bool m_hasCurrent = false;
};

// ── TypeSelectorPopup ──

TypeSelectorPopup::TypeSelectorPopup(QWidget* parent)
    : QFrame(parent, Qt::Popup | Qt::FramelessWindowHint)
{
    setAttribute(Qt::WA_DeleteOnClose, false);

    const auto& theme = ThemeManager::instance().current();
    QPalette pal;
    pal.setColor(QPalette::Window,          theme.backgroundAlt);
    pal.setColor(QPalette::WindowText,      theme.text);
    pal.setColor(QPalette::Base,            theme.background);
    pal.setColor(QPalette::AlternateBase,   theme.surface);
    pal.setColor(QPalette::Text,            theme.text);
    pal.setColor(QPalette::Button,          theme.button);
    pal.setColor(QPalette::ButtonText,      theme.text);
    pal.setColor(QPalette::Highlight,       theme.hover);
    pal.setColor(QPalette::HighlightedText, theme.text);
    setPalette(pal);
    setAutoFillBackground(true);

    setFrameShape(QFrame::NoFrame);
    setLineWidth(0);

    auto* layout = new QVBoxLayout(this);
    layout->setContentsMargins(6, 6, 6, 6);
    layout->setSpacing(4);

    // Row 1: title + Esc hint
    {
        auto* row = new QHBoxLayout;
        row->setContentsMargins(0, 0, 0, 0);
        m_titleLabel = new QLabel(QStringLiteral("Change type"));
        m_titleLabel->setPalette(pal);
        QFont bold = m_titleLabel->font();
        bold.setBold(true);
        m_titleLabel->setFont(bold);
        row->addWidget(m_titleLabel);

        row->addStretch();

        m_escLabel = new QToolButton;
        m_escLabel->setText(QStringLiteral("\u2715 Esc"));
        m_escLabel->setAutoRaise(true);
        m_escLabel->setCursor(Qt::PointingHandCursor);
        m_escLabel->setStyleSheet(QStringLiteral(
            "QToolButton { color: %1; border: none; padding: 2px 6px; }"
            "QToolButton:hover { color: %2; }")
            .arg(theme.textDim.name(), theme.indHoverSpan.name()));
        connect(m_escLabel, &QToolButton::clicked, this, [this]() {
            hide();
        });
        row->addWidget(m_escLabel);

        layout->addLayout(row);
    }

    // Row 2: + Create new type button (flat, no gradient)
    {
        m_createBtn = new QToolButton;
        m_createBtn->setText(QStringLiteral("+ Create new type\u2026"));
        m_createBtn->setToolButtonStyle(Qt::ToolButtonTextOnly);
        m_createBtn->setAutoRaise(true);
        m_createBtn->setCursor(Qt::PointingHandCursor);
        m_createBtn->setStyleSheet(QStringLiteral(
            "QToolButton { color: %1; border: none; padding: 3px 6px; }"
            "QToolButton:hover { color: %2; background: %3; }")
            .arg(theme.textMuted.name(), theme.text.name(), theme.hover.name()));
        connect(m_createBtn, &QToolButton::clicked, this, [this]() {
            emit createNewTypeRequested();
            hide();
        });
        layout->addWidget(m_createBtn);
    }

    // Separator
    {
        m_separator = new QFrame;
        m_separator->setFrameShape(QFrame::HLine);
        m_separator->setFrameShadow(QFrame::Plain);
        QPalette sepPal = pal;
        sepPal.setColor(QPalette::WindowText, theme.border);
        m_separator->setPalette(sepPal);
        m_separator->setFixedHeight(1);
        layout->addWidget(m_separator);
    }

    // Row 3: Modifier toggles [ plain ] [ * ] [ ** ] [ [n] ]
    {
        m_modRow = new QWidget;
        auto* modLayout = new QHBoxLayout(m_modRow);
        modLayout->setContentsMargins(0, 0, 0, 0);
        modLayout->setSpacing(3);

        m_modGroup = new QButtonGroup(this);
        m_modGroup->setExclusive(true);

        QString btnStyle = QStringLiteral(
            "QToolButton { color: %1; background: %2; border: 1px solid %3;"
            "  padding: 2px 8px; border-radius: 3px; }"
            "QToolButton:checked { color: %4; background: %5; border-color: %5; }"
            "QToolButton:hover:!checked { background: %6; }")
            .arg(theme.textDim.name(), theme.background.name(), theme.border.name(),
                 theme.text.name(), theme.selected.name(), theme.hover.name());

        auto makeToggle = [&](const QString& label, int id) -> QToolButton* {
            auto* btn = new QToolButton;
            btn->setText(label);
            btn->setCheckable(true);
            btn->setCursor(Qt::PointingHandCursor);
            btn->setStyleSheet(btnStyle);
            m_modGroup->addButton(btn, id);
            modLayout->addWidget(btn);
            return btn;
        };

        m_btnPlain  = makeToggle(QStringLiteral("plain"), 0);
        m_btnPtr    = makeToggle(QStringLiteral("*"),     1);
        m_btnDblPtr = makeToggle(QStringLiteral("**"),    2);
        m_btnArray  = makeToggle(QStringLiteral("[n]"),   3);
        m_btnPlain->setChecked(true);

        // Array count input (shown only when [n] is active)
        m_arrayCountEdit = new QLineEdit;
        m_arrayCountEdit->setPlaceholderText(QStringLiteral("n"));
        m_arrayCountEdit->setValidator(new QIntValidator(1, 99999, m_arrayCountEdit));
        m_arrayCountEdit->setFixedWidth(50);
        m_arrayCountEdit->setPalette(pal);
        m_arrayCountEdit->hide();
        modLayout->addWidget(m_arrayCountEdit);

        modLayout->addStretch();
        layout->addWidget(m_modRow);

        connect(m_modGroup, &QButtonGroup::idToggled,
                this, [this](int id, bool checked) {
            if (!checked) return;
            m_arrayCountEdit->setVisible(id == 3);
            if (id == 3) {
                if (m_arrayCountEdit->text().trimmed().isEmpty())
                    m_arrayCountEdit->setText(QStringLiteral("1"));
                m_arrayCountEdit->setFocus();
                m_arrayCountEdit->selectAll();
            }
            updateModifierPreview();
        });
        connect(m_arrayCountEdit, &QLineEdit::textChanged,
                this, [this]() { updateModifierPreview(); });
    }

    // Row 4: Filter + preview
    {
        m_filterEdit = new QLineEdit;
        m_filterEdit->setPlaceholderText(QStringLiteral("Filter types\u2026"));
        m_filterEdit->setClearButtonEnabled(true);
        m_filterEdit->setPalette(pal);
        m_filterEdit->installEventFilter(this);
        connect(m_filterEdit, &QLineEdit::textChanged,
                this, &TypeSelectorPopup::applyFilter);
        layout->addWidget(m_filterEdit);

        m_previewLabel = new QLabel;
        m_previewLabel->setPalette(pal);
        m_previewLabel->setStyleSheet(QStringLiteral(
            "QLabel { color: %1; padding: 1px 6px; }").arg(theme.syntaxType.name()));
        m_previewLabel->hide();
        layout->addWidget(m_previewLabel);
    }

    // Row 4: List
    {
        m_model = new QStringListModel(this);
        m_listView = new QListView;
        m_listView->setModel(m_model);
        m_listView->setPalette(pal);
        m_listView->setFrameShape(QFrame::NoFrame);
        m_listView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        m_listView->setMouseTracking(true);
        m_listView->setEditTriggers(QAbstractItemView::NoEditTriggers);
        m_listView->viewport()->setAttribute(Qt::WA_Hover, true);
        m_listView->installEventFilter(this);

        auto* delegate = new TypeSelectorDelegate(this, m_listView);
        m_listView->setItemDelegate(delegate);

        layout->addWidget(m_listView, 1);

        connect(m_listView, &QListView::clicked,
                this, [this](const QModelIndex& index) {
            acceptIndex(index.row());
        });
    }
}

void TypeSelectorPopup::warmUp() {
    // One-time per-process cost (~170ms): Qt lazily initializes the style/font/DLL
    // subsystem the first time a popup with complex children is shown. Pre-pay it
    // by briefly showing a throwaway dummy popup with a QListView, then show+hide
    // ourselves.
    {
        auto* primer = new QFrame(nullptr, Qt::Popup | Qt::FramelessWindowHint);
        primer->resize(300, 400);
        auto* lay = new QVBoxLayout(primer);
        lay->addWidget(new QLabel(QStringLiteral("x")));
        lay->addWidget(new QLineEdit);
        auto* model = new QStringListModel(primer);
        QStringList items; for (int i = 0; i < 10; i++) items << QStringLiteral("x");
        model->setStringList(items);
        auto* lv = new QListView;
        lv->setModel(model);
        lay->addWidget(lv);
        primer->show();
        QApplication::processEvents();
        primer->hide();
        QApplication::processEvents();
        delete primer;
    }

    TypeEntry dummy;
    dummy.entryKind = TypeEntry::Primitive;
    dummy.primitiveKind = NodeKind::Hex8;
    dummy.displayName = QStringLiteral("warmup");
    setTypes({dummy});
    popup(QPoint(-9999, -9999));
    hide();
    QApplication::processEvents();
}

void TypeSelectorPopup::setFont(const QFont& font) {
    m_font = font;

    m_titleLabel->setFont([&]() {
        QFont f = font; f.setBold(true); return f;
    }());
    m_escLabel->setFont(font);
    m_createBtn->setFont(font);
    m_filterEdit->setFont(font);
    m_listView->setFont(font);
    m_previewLabel->setFont(font);

    QFont smallFont = font;
    smallFont.setPointSize(qMax(7, font.pointSize() - 1));
    m_btnPlain->setFont(smallFont);
    m_btnPtr->setFont(smallFont);
    m_btnDblPtr->setFont(smallFont);
    m_btnArray->setFont(smallFont);
    m_arrayCountEdit->setFont(smallFont);

    auto* delegate = static_cast<TypeSelectorDelegate*>(m_listView->itemDelegate());
    if (delegate)
        delegate->setFont(font);
}

void TypeSelectorPopup::applyTheme(const Theme& theme) {
    QPalette pal;
    pal.setColor(QPalette::Window,          theme.backgroundAlt);
    pal.setColor(QPalette::WindowText,      theme.text);
    pal.setColor(QPalette::Base,            theme.background);
    pal.setColor(QPalette::AlternateBase,   theme.surface);
    pal.setColor(QPalette::Text,            theme.text);
    pal.setColor(QPalette::Button,          theme.button);
    pal.setColor(QPalette::ButtonText,      theme.text);
    pal.setColor(QPalette::Highlight,       theme.hover);
    pal.setColor(QPalette::HighlightedText, theme.text);
    setPalette(pal);

    m_titleLabel->setPalette(pal);
    m_filterEdit->setPalette(pal);
    m_listView->setPalette(pal);
    m_previewLabel->setPalette(pal);
    m_arrayCountEdit->setPalette(pal);

    // Separator
    QPalette sepPal = pal;
    sepPal.setColor(QPalette::WindowText, theme.border);
    m_separator->setPalette(sepPal);

    // Esc button
    m_escLabel->setStyleSheet(QStringLiteral(
        "QToolButton { color: %1; border: none; padding: 2px 6px; }"
        "QToolButton:hover { color: %2; }")
        .arg(theme.textDim.name(), theme.indHoverSpan.name()));

    // Create button
    m_createBtn->setStyleSheet(QStringLiteral(
        "QToolButton { color: %1; border: none; padding: 3px 6px; }"
        "QToolButton:hover { color: %2; background: %3; }")
        .arg(theme.textMuted.name(), theme.text.name(), theme.hover.name()));

    // Modifier toggle buttons
    QString btnStyle = QStringLiteral(
        "QToolButton { color: %1; background: %2; border: 1px solid %3;"
        "  padding: 2px 8px; border-radius: 3px; }"
        "QToolButton:checked { color: %4; background: %5; border-color: %5; }"
        "QToolButton:hover:!checked { background: %6; }")
        .arg(theme.textDim.name(), theme.background.name(), theme.border.name(),
             theme.text.name(), theme.selected.name(), theme.hover.name());
    m_btnPlain->setStyleSheet(btnStyle);
    m_btnPtr->setStyleSheet(btnStyle);
    m_btnDblPtr->setStyleSheet(btnStyle);
    m_btnArray->setStyleSheet(btnStyle);

    // Preview label
    m_previewLabel->setStyleSheet(QStringLiteral(
        "QLabel { color: %1; padding: 1px 6px; }").arg(theme.syntaxType.name()));
}

void TypeSelectorPopup::setTitle(const QString& title) {
    m_titleLabel->setText(title);
}

void TypeSelectorPopup::setMode(TypePopupMode mode) {
    m_mode = mode;
    bool showMods = (mode == TypePopupMode::FieldType
                     || mode == TypePopupMode::ArrayElement);
    m_modRow->setVisible(showMods);
    // Always reset to plain — prevents stale state from leaking across modes
    // (PointerTarget hides buttons but applyFilter still reads their state)
    m_btnPlain->setChecked(true);
    m_arrayCountEdit->clear();
    m_arrayCountEdit->hide();
}

void TypeSelectorPopup::setCurrentNodeSize(int bytes) {
    m_currentNodeSize = bytes;
}

void TypeSelectorPopup::setModifier(int modId, int arrayCount) {
    if (modId == 1)      m_btnPtr->setChecked(true);
    else if (modId == 2) m_btnDblPtr->setChecked(true);
    else if (modId == 3) {
        m_btnArray->setChecked(true);
        m_arrayCountEdit->setText(QString::number(arrayCount));
        m_arrayCountEdit->show();
    } else {
        m_btnPlain->setChecked(true);
    }
}

void TypeSelectorPopup::setTypes(const QVector<TypeEntry>& types, const TypeEntry* current) {
    m_allTypes = types;
    if (current) {
        m_currentEntry = *current;
        m_hasCurrent = true;
    } else {
        m_currentEntry = TypeEntry{};
        m_hasCurrent = false;
    }
    // Don't reset modifier buttons here — setMode() already resets to plain,
    // and setModifier() may have preselected a button between setMode/setTypes.
    m_previewLabel->hide();

    m_filterEdit->clear();
    applyFilter(QString());
}

void TypeSelectorPopup::popup(const QPoint& globalPos) {
    QFontMetrics fm(m_font);
    int maxTextW = fm.horizontalAdvance(QStringLiteral("Choose element type      Esc"));
    for (const auto& t : m_allTypes) {
        QString text = t.classKeyword.isEmpty()
            ? t.displayName
            : (t.classKeyword + QStringLiteral(" ") + t.displayName);
        int gutterW = fm.horizontalAdvance(QChar(0x25B8)) + 4;
        int iconColW = fm.height() + 4;
        int w = gutterW + iconColW + fm.horizontalAdvance(text) + 16;
        if (w > maxTextW) maxTextW = w;
    }
    int popupW = qBound(280, maxTextW + 24, 500);
    int rowH = fm.height() + 8;
    int headerH = rowH * 3 + 30;
    if (m_modRow->isVisible())
        headerH += rowH + 4;  // extra row for modifier toggles
    int listH = qBound(rowH * 3, rowH * (int)m_filteredTypes.size(), rowH * 14);
    int popupH = headerH + listH;

    QScreen* screen = QApplication::screenAt(globalPos);
    if (screen) {
        QRect avail = screen->availableGeometry();
        if (globalPos.y() + popupH > avail.bottom())
            popupH = avail.bottom() - globalPos.y();
        if (globalPos.x() + popupW > avail.right())
            popupW = avail.right() - globalPos.x();
    }

    setFixedSize(popupW, popupH);
    move(globalPos);
    show();
    raise();
    activateWindow();
    m_filterEdit->setFocus();

    // Pre-select current type in list
    if (m_hasCurrent) {
        for (int i = 0; i < m_filteredTypes.size(); i++) {
            const auto& entry = m_filteredTypes[i];
            if (entry.entryKind == TypeEntry::Section) continue;
            bool match = false;
            if (m_currentEntry.entryKind == TypeEntry::Primitive && entry.entryKind == TypeEntry::Primitive)
                match = (entry.primitiveKind == m_currentEntry.primitiveKind);
            else if (m_currentEntry.entryKind == TypeEntry::Composite && entry.entryKind == TypeEntry::Composite)
                match = (entry.structId == m_currentEntry.structId);
            if (match) {
                m_listView->setCurrentIndex(m_model->index(i));
                break;
            }
        }
    }
}

void TypeSelectorPopup::updateModifierPreview() {
    int modId = m_modGroup->checkedId();
    if (modId <= 0) {
        m_previewLabel->hide();
        return;
    }
    QString suffix;
    if (modId == 1) suffix = QStringLiteral("*");
    else if (modId == 2) suffix = QStringLiteral("**");
    else if (modId == 3) {
        QString countText = m_arrayCountEdit->text().trimmed();
        suffix = countText.isEmpty()
            ? QStringLiteral("[n]")
            : QStringLiteral("[%1]").arg(countText);
    }
    m_previewLabel->setText(QStringLiteral("\u2192 <type>%1").arg(suffix));
    m_previewLabel->show();
}

void TypeSelectorPopup::applyFilter(const QString& text) {
    m_filteredTypes.clear();
    QStringList displayStrings;

    QString filterBase = text.trimmed();

    // Separate primitives and composites (all types shown regardless of modifier)
    QVector<TypeEntry> primitives, composites;
    for (const auto& t : m_allTypes) {
        if (t.entryKind == TypeEntry::Section) continue;
        bool matchesFilter = filterBase.isEmpty()
            || t.displayName.contains(filterBase, Qt::CaseInsensitive)
            || t.classKeyword.contains(filterBase, Qt::CaseInsensitive);
        if (!matchesFilter) continue;

        if (t.entryKind == TypeEntry::Primitive)
            primitives.append(t);
        else if (t.entryKind == TypeEntry::Composite)
            composites.append(t);
    }

    auto alphabetical = [](const TypeEntry& a, const TypeEntry& b) {
        return a.displayName.compare(b.displayName, Qt::CaseInsensitive) < 0;
    };

    // For non-Root modes, sort primitives: same-size first, then rest — alphabetical within each group
    if (m_mode != TypePopupMode::Root && m_currentNodeSize > 0 && !primitives.isEmpty()) {
        QVector<TypeEntry> sameSize, other;
        for (const auto& p : primitives) {
            if (sizeForKind(p.primitiveKind) == m_currentNodeSize)
                sameSize.append(p);
            else
                other.append(p);
        }
        std::sort(sameSize.begin(), sameSize.end(), alphabetical);
        std::sort(other.begin(), other.end(), alphabetical);
        primitives = sameSize + other;
    } else {
        std::sort(primitives.begin(), primitives.end(), alphabetical);
    }

    // Helper lambdas for appending sections
    auto appendPrimitives = [&]() {
        if (primitives.isEmpty()) return;
        TypeEntry sec;
        sec.entryKind = TypeEntry::Section;
        sec.displayName = QStringLiteral("primitives");
        sec.enabled = false;
        m_filteredTypes.append(sec);
        displayStrings << sec.displayName;
        for (const auto& p : primitives) {
            m_filteredTypes.append(p);
            displayStrings << p.displayName;
        }
    };
    auto appendComposites = [&]() {
        if (composites.isEmpty()) return;
        TypeEntry sec;
        sec.entryKind = TypeEntry::Section;
        sec.displayName = QStringLiteral("project types");
        sec.enabled = false;
        m_filteredTypes.append(sec);
        displayStrings << sec.displayName;
        for (const auto& c : composites) {
            m_filteredTypes.append(c);
            QString label = c.classKeyword.isEmpty()
                ? c.displayName
                : (c.classKeyword + QStringLiteral(" ") + c.displayName);
            displayStrings << label;
        }
    };

    // Root mode: project types first (composites are the primary selection)
    if (m_mode == TypePopupMode::Root) {
        appendComposites();
        appendPrimitives();
    } else {
        appendPrimitives();
        appendComposites();
    }

    m_model->setStringList(displayStrings);

    auto* delegate = static_cast<TypeSelectorDelegate*>(m_listView->itemDelegate());
    if (delegate)
        delegate->setFilteredTypes(&m_filteredTypes, &m_currentEntry, m_hasCurrent);

    // Select first selectable item
    int first = nextSelectableRow(0, 1);
    if (first >= 0)
        m_listView->setCurrentIndex(m_model->index(first));
}

void TypeSelectorPopup::acceptCurrent() {
    QModelIndex idx = m_listView->currentIndex();
    if (idx.isValid())
        acceptIndex(idx.row());
}

void TypeSelectorPopup::acceptIndex(int row) {
    if (row < 0 || row >= m_filteredTypes.size()) return;
    const TypeEntry& entry = m_filteredTypes[row];
    if (entry.entryKind == TypeEntry::Section) return;
    if (!entry.enabled) return;

    // Build full text with modifier from toggle buttons
    int modId = m_modGroup->checkedId();
    QString fullText = entry.displayName;
    if (modId == 1)
        fullText += QStringLiteral("*");
    else if (modId == 2)
        fullText += QStringLiteral("**");
    else if (modId == 3) {
        QString countText = m_arrayCountEdit->text().trimmed();
        if (!countText.isEmpty())
            fullText += QStringLiteral("[%1]").arg(countText);
    }

    emit typeSelected(entry, fullText);
    hide();
}

int TypeSelectorPopup::nextSelectableRow(int from, int direction) const {
    int i = from;
    while (i >= 0 && i < m_filteredTypes.size()) {
        const auto& e = m_filteredTypes[i];
        if (e.entryKind != TypeEntry::Section && e.enabled)
            return i;
        i += direction;
    }
    return -1;
}

bool TypeSelectorPopup::eventFilter(QObject* obj, QEvent* event) {
    if (event->type() == QEvent::KeyPress) {
        auto* ke = static_cast<QKeyEvent*>(event);

        if (ke->key() == Qt::Key_Escape) {
            hide();
            return true;
        }

        if (obj == m_filterEdit) {
            if (ke->key() == Qt::Key_Down) {
                m_listView->setFocus();
                QModelIndex cur = m_listView->currentIndex();
                int startRow = cur.isValid() ? cur.row() : 0;
                int next = nextSelectableRow(startRow, 1);
                if (next >= 0)
                    m_listView->setCurrentIndex(m_model->index(next));
                return true;
            }
            if (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) {
                acceptCurrent();
                return true;
            }
        }

        if (obj == m_listView) {
            if (ke->key() == Qt::Key_Up) {
                QModelIndex cur = m_listView->currentIndex();
                if (!cur.isValid() || cur.row() == 0) {
                    m_filterEdit->setFocus();
                    return true;
                }
                // Skip sections and disabled entries
                int prev = nextSelectableRow(cur.row() - 1, -1);
                if (prev < 0) {
                    m_filterEdit->setFocus();
                    return true;
                }
                m_listView->setCurrentIndex(m_model->index(prev));
                return true;
            }
            if (ke->key() == Qt::Key_Down) {
                QModelIndex cur = m_listView->currentIndex();
                int startRow = cur.isValid() ? cur.row() + 1 : 0;
                int next = nextSelectableRow(startRow, 1);
                if (next >= 0)
                    m_listView->setCurrentIndex(m_model->index(next));
                return true;
            }
            if (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) {
                acceptCurrent();
                return true;
            }
            // Forward printable keys to filter edit for type-to-filter
            if (!ke->text().isEmpty() && ke->text()[0].isPrint()) {
                m_filterEdit->setFocus();
                m_filterEdit->setText(m_filterEdit->text() + ke->text());
                return true;
            }
        }
    }

    return QFrame::eventFilter(obj, event);
}

void TypeSelectorPopup::hideEvent(QHideEvent* event) {
    QFrame::hideEvent(event);
    emit dismissed();
}

} // namespace rcx

```

`src/typeselectorpopup.h`:

```h
#pragma once
#include <QFrame>
#include <QFont>
#include <QVector>
#include <QString>
#include <cstdint>
#include "core.h"

class QLineEdit;
class QListView;
class QStringListModel;
class QLabel;
class QToolButton;
class QButtonGroup;
class QWidget;

namespace rcx {

struct Theme;

// ── Popup mode ──

enum class TypePopupMode { Root, FieldType, ArrayElement, PointerTarget };

// ── Type entry (explicit discriminant — no sentinel IDs) ──

struct TypeEntry {
    enum Kind { Primitive, Composite, Section };

    Kind        entryKind     = Primitive;
    NodeKind    primitiveKind = NodeKind::Hex8;  // valid when entryKind==Primitive
    uint64_t    structId      = 0;               // valid when entryKind==Composite
    QString     displayName;
    QString     classKeyword;                    // "struct", "class", "enum" (Composite only)
    bool        enabled       = true;            // false = grayed out (visible but not selectable)
};

// ── Parsed type spec (shared between popup filter and inline edit) ──

struct TypeSpec {
    QString baseName;
    bool    isPointer  = false;
    int     ptrDepth   = 0;       // 1 = *, 2 = ** (only meaningful when isPointer)
    int     arrayCount = 0;       // 0 = not array
};

TypeSpec parseTypeSpec(const QString& text);

// ── Popup widget ──

class TypeSelectorPopup : public QFrame {
    Q_OBJECT
public:
    explicit TypeSelectorPopup(QWidget* parent = nullptr);

    void setFont(const QFont& font);
    void setTitle(const QString& title);
    void setMode(TypePopupMode mode);
    void applyTheme(const Theme& theme);
    void setCurrentNodeSize(int bytes);
    void setModifier(int modId, int arrayCount = 0);
    void setTypes(const QVector<TypeEntry>& types, const TypeEntry* current = nullptr);
    void popup(const QPoint& globalPos);

    /// Force native window creation to avoid cold-start delay.
    void warmUp();

signals:
    void typeSelected(const TypeEntry& entry, const QString& fullText);
    void createNewTypeRequested();
    void dismissed();

protected:
    bool eventFilter(QObject* obj, QEvent* event) override;
    void hideEvent(QHideEvent* event) override;

private:
    QLabel*           m_titleLabel   = nullptr;
    QToolButton*      m_escLabel     = nullptr;
    QToolButton*      m_createBtn    = nullptr;
    QLineEdit*        m_filterEdit   = nullptr;
    QLabel*           m_previewLabel = nullptr;
    QListView*        m_listView     = nullptr;
    QStringListModel* m_model        = nullptr;
    QFrame*           m_separator    = nullptr;

    // Modifier toggles
    QWidget*          m_modRow       = nullptr;
    QToolButton*      m_btnPlain     = nullptr;
    QToolButton*      m_btnPtr       = nullptr;
    QToolButton*      m_btnDblPtr    = nullptr;
    QToolButton*      m_btnArray     = nullptr;
    QLineEdit*        m_arrayCountEdit = nullptr;
    QButtonGroup*     m_modGroup     = nullptr;

    QVector<TypeEntry> m_allTypes;
    QVector<TypeEntry> m_filteredTypes;
    TypeEntry          m_currentEntry;
    bool               m_hasCurrent = false;
    TypePopupMode      m_mode = TypePopupMode::FieldType;
    int                m_currentNodeSize = 0;
    QFont              m_font;

    void applyFilter(const QString& text);
    void updateModifierPreview();
    void acceptCurrent();
    void acceptIndex(int row);
    int  nextSelectableRow(int from, int direction) const;
};

} // namespace rcx

```

`src/vsicons/LICENSE-CODE.txt`:

```txt
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE

```

`src/vsicons/account.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M16 7.99201C16 3.58042 12.416 0 8 0C3.584 0 0 3.58042 0 7.99201C0 10.4216 1.104 12.6114 2.832 14.0819C2.848 14.0979 2.864 14.0979 2.864 14.1139C3.008 14.2258 3.152 14.3377 3.312 14.4496C3.392 14.4975 3.456 14.5614 3.536 14.6254C4.816 15.4885 6.352 16 8.016 16C9.68 16 11.216 15.4885 12.496 14.6254C12.576 14.5774 12.64 14.5135 12.72 14.4655C12.864 14.3536 13.024 14.2418 13.168 14.1299C13.184 14.1139 13.2 14.1139 13.2 14.0979C14.896 12.6114 16 10.4216 16 7.99201ZM8 14.993C6.496 14.993 5.12 14.5135 3.984 13.7143C4 13.5864 4.032 13.4585 4.064 13.3307C4.16 12.979 4.304 12.6434 4.48 12.3397C4.656 12.036 4.864 11.7642 5.12 11.5245C5.36 11.2847 5.648 11.0609 5.936 10.8851C6.24 10.7093 6.56 10.5814 6.912 10.4855C7.264 10.3896 7.632 10.3417 8 10.3417C8.592 10.3417 9.136 10.4535 9.632 10.6613C10.128 10.8691 10.56 11.1568 10.928 11.5085C11.296 11.8761 11.584 12.3077 11.792 12.8032C11.904 13.0909 11.984 13.3946 12.032 13.7143C10.88 14.5135 9.504 14.993 8 14.993ZM5.552 7.59241C5.408 7.27273 5.344 6.92108 5.344 6.56943C5.344 6.21778 5.408 5.86613 5.552 5.54645C5.696 5.22677 5.888 4.93906 6.128 4.6993C6.368 4.45954 6.656 4.26773 6.976 4.12388C7.296 3.98002 7.648 3.91608 8 3.91608C8.368 3.91608 8.704 3.98002 9.024 4.12388C9.344 4.26773 9.632 4.45954 9.872 4.6993C10.112 4.93906 10.304 5.22677 10.448 5.54645C10.592 5.86613 10.656 6.21778 10.656 6.56943C10.656 6.93706 10.592 7.27273 10.448 7.59241C10.304 7.91209 10.112 8.1998 9.872 8.43956C9.632 8.67932 9.344 8.87113 9.024 9.01499C8.384 9.28671 7.6 9.28671 6.96 9.01499C6.64 8.87113 6.352 8.67932 6.112 8.43956C5.872 8.1998 5.68 7.91209 5.552 7.59241ZM12.976 12.8991C12.976 12.8671 12.96 12.8511 12.96 12.8192C12.8 12.3237 12.576 11.8442 12.272 11.4126C11.968 10.981 11.616 10.5974 11.184 10.2777C10.864 10.038 10.512 9.83017 10.144 9.67033C10.32 9.55844 10.48 9.41459 10.608 9.28671C10.848 9.04695 11.056 8.79121 11.232 8.5035C11.408 8.21578 11.536 7.91209 11.632 7.57642C11.728 7.24076 11.76 6.90509 11.76 6.56943C11.76 6.04196 11.664 5.54645 11.472 5.0989C11.28 4.65135 11.008 4.25175 10.656 3.9001C10.32 3.56444 9.904 3.29271 9.456 3.1009C9.008 2.90909 8.512 2.81319 7.984 2.81319C7.456 2.81319 6.96 2.90909 6.512 3.1009C6.064 3.29271 5.648 3.56444 5.312 3.91608C4.976 4.25175 4.704 4.66733 4.512 5.11489C4.32 5.56244 4.224 6.05794 4.224 6.58541C4.224 6.93706 4.272 7.27273 4.368 7.59241C4.464 7.92807 4.592 8.23177 4.768 8.51948C4.928 8.80719 5.152 9.06294 5.392 9.3027C5.536 9.44655 5.696 9.57443 5.872 9.68631C5.488 9.86214 5.136 10.0699 4.832 10.3097C4.416 10.6294 4.048 11.013 3.744 11.4286C3.44 11.8601 3.216 12.3237 3.056 12.8352C3.04 12.8671 3.04 12.8991 3.04 12.9151C1.776 11.6364 0.992 9.91009 0.992 7.99201C0.992 4.13986 4.144 0.991009 8 0.991009C11.856 0.991009 15.008 4.13986 15.008 7.99201C15.008 9.91009 14.224 11.6364 12.976 12.8991Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/activate-breakpoints.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.9991 5.5009C15.0304 6.61917 14.634 7.70727 13.8907 8.54341C13.1475 9.37954 12.1134 9.90079 10.9991 10.0009C10.9909 9.65849 10.9232 9.32013 10.7991 9.00089C11.6689 8.91145 12.4755 8.50547 13.0655 7.86015C13.6555 7.21484 13.9878 6.3752 13.9991 5.5009C13.9959 4.599 13.6452 3.73303 13.0201 3.08292C12.395 2.4328 11.5434 2.04852 10.6423 2.0099C9.74125 1.97128 8.85994 2.2813 8.18148 2.87555C7.50302 3.4698 7.07959 4.30258 6.99915 5.20089C6.67717 5.08647 6.34037 5.01911 5.99915 5.0009C6.14761 3.90649 6.68305 2.90142 7.50851 2.16768C8.33397 1.43393 9.39488 1.02002 10.4991 1.00089C11.0908 0.998381 11.6771 1.11306 12.2242 1.33832C12.7713 1.56357 13.2684 1.89494 13.6867 2.31331C14.1051 2.73167 14.4365 3.22875 14.6617 3.77585C14.887 4.32295 15.0017 4.90924 14.9991 5.5009ZM5.49915 6.0009C4.60913 6.0009 3.7391 6.26482 2.99908 6.75928C2.25906 7.25375 1.68228 7.95655 1.34169 8.77882C1.0011 9.60109 0.91198 10.5059 1.08561 11.3788C1.25925 12.2517 1.68783 13.0535 2.31717 13.6829C2.9465 14.3122 3.74833 14.7408 4.62124 14.9144C5.49416 15.0881 6.39896 14.9989 7.22122 14.6584C8.04349 14.3178 8.74629 13.741 9.24076 13.001C9.73523 12.2609 9.99915 11.3909 9.99915 10.5009C9.99915 9.90995 9.88275 9.32478 9.65661 8.77882C9.43046 8.23285 9.09899 7.73678 8.68113 7.31891C8.26326 6.90105 7.76719 6.56958 7.22122 6.34344C6.67526 6.11729 6.0901 6.0009 5.49915 6.0009Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/add.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.0001 7V8H8.00012V14H7.00012V8H1.00012V7H7.00012V1H8.00012V7H14.0001Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/archive.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 1H1.5L1 1.5V4.5L1.5 5H2V13.5L2.5 14H13.5L14 13.5V5H14.5L15 4.5V1.5L14.5 1ZM13.5 4H2.5H2V2H14V4H13.5ZM3 13V5H13V13H3ZM11 7H5V8H11V7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-both.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.99999 9.00004L5.14644 11.1465L4.43933 11.8536L1.43933 8.85359V8.14649L4.43933 5.14648L5.14644 5.85359L2.99999 8.00004H13L10.8535 5.85359L11.5606 5.14648L14.5606 8.14648V8.85359L11.5606 11.8536L10.8535 11.1465L13 9.00004H2.99999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-down.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.14642 9.00001L8.14641 14L8.85352 14L13.8535 9.00001L13.1464 8.2929L8.99997 12.4393L8.99997 2.00001L7.99997 2.00001L7.99997 12.4393L3.85353 8.2929L3.14642 9.00001Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-left.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.99999 3.0929L2 8.09288L2 8.79999L6.99999 13.8L7.7071 13.0929L3.56066 8.94644L14 8.94644L14 7.94644L3.56066 7.94644L7.7071 3.8L6.99999 3.0929Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-right.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.00001 13.8871L14 8.8871L14 8.17999L9.00001 3.17999L8.2929 3.8871L12.4393 8.03354L2 8.03354L2 9.03354L12.4393 9.03354L8.2929 13.18L9.00001 13.8871Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-small-down.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.7 8.64L8.2 11.14H7.5L5 8.64L5.7 7.93L7.35 9.57V4H8.35V9.57L10 7.92L10.7 8.64Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-small-left.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.50001 10.7L4.00001 8.2L4.00001 7.5L6.50001 5L7.21001 5.7L5.57001 7.35L11.14 7.35L11.14 8.35L5.57001 8.35L7.22001 10L6.50001 10.7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-small-right.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.64 4.99995L11.14 7.49995L11.14 8.19995L8.64 10.7L7.93 9.99995L9.57 8.34995L4 8.34995L4 7.34995L9.57 7.34995L7.92 5.69995L8.64 4.99995Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-small-up.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.99995 6.50002L7.49995 4.00002L8.19995 4.00002L10.7 6.50001L9.99995 7.21001L8.34995 5.57001L8.34995 11.14L7.34995 11.14L7.34995 5.57001L5.69995 7.22001L4.99995 6.50002Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/arrow-up.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.8536 6.99999L8.85359 2H8.14648L3.14648 6.99999L3.85359 7.7071L8.00003 3.56066V14H9.00003V3.56066L13.1465 7.7071L13.8536 6.99999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/beaker.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.8929 13.558L9.99994 6.006V2.006H10.9999V1.006H9.99394V1L9.53794 1.005H4.99994V2H5.99994V5.952L2.10594 13.561C2.03023 13.7133 1.99465 13.8825 2.00254 14.0524C2.01044 14.2224 2.06156 14.3875 2.15106 14.5321C2.24057 14.6768 2.3655 14.7962 2.51404 14.8792C2.66258 14.9621 2.82982 15.0057 2.99994 15.006H12.9999C13.1704 15.0058 13.3379 14.9621 13.4867 14.8789C13.6355 14.7958 13.7606 14.676 13.8501 14.5309C13.9395 14.3858 13.9904 14.2203 13.9979 14.05C14.0054 13.8798 13.9693 13.7104 13.8929 13.558ZM6.89294 6.408L6.99994 6.193V2.036L8.99994 2.012V6.007V6.249L9.11094 6.464L10.9369 10.006H5.04894L6.89294 6.408ZM2.99994 14.017L4.54094 11.006H11.4559L13.0029 14.006L2.99994 14.017Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/bell-dot.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 8.9C13.1 9.5 13.2 10 13.4 10.6L14 12.3L13.5 13H10C10 13.5 9.8 14 9.4 14.4C9 14.8 8.5 15 8 15C7.5 15 6.9 14.8 6.6 14.4C6.2 14 6 13.5 6 13H2.5L2 12.3L2.6 10.6C2.8 9.8 3 9 3 8.2V6C3 5.3 3.1 4.6 3.4 4C3.7 3.3 4.1 2.8 4.6 2.3C5.1 1.8 5.7 1.5 6.4 1.3C6.9 1.1 7.5 1 8 1C7.8 1.3 7.6 1.7 7.4 2.1C7.2 2.1 7 2.1 6.7 2.3C6.2 2.4 5.7 2.7 5.3 3.1C4.9 3.4 4.5 3.9 4.3 4.4C4.1 4.9 4 5.4 4 6V8.2C4 9.1 3.8 10 3.6 10.9L3.2 12H12.8L12.4 10.9C12.2246 10.3739 12.1261 9.77084 12.0371 9.22577C12.0246 9.14925 12.0123 9.07387 12 9C12.4 9 12.7 9 13 8.9ZM8 14C8.2 14 8.5 13.9 8.7 13.7C8.9 13.5 9 13.3 9 13H7C7 13.3 7.1 13.5 7.3 13.7C7.5 13.9 7.8 14 8 14ZM15 4C15 5.65685 13.6569 7 12 7C10.3431 7 9 5.65685 9 4C9 2.34315 10.3431 1 12 1C13.6569 1 15 2.34315 15 4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/bell.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.3772 10.5735C13.126 9.80788 12.9944 9.00633 12.9944 8.19282V6.19493C13.0063 4.92681 12.5637 3.69457 11.7263 2.74946C10.8888 1.79239 9.74033 1.18226 8.48417 1.02673C7.79029 0.954953 7.08445 1.02673 6.4145 1.25404C5.74455 1.46938 5.13441 1.82828 4.61999 2.30682C4.10556 2.77339 3.68684 3.34764 3.41168 3.9817C3.13652 4.61576 2.981 5.29767 2.981 6.00351V8.20478C2.981 9.00633 2.8494 9.80788 2.59817 10.5735L2 12.3441L2.47854 13.0021H5.98382C5.98382 13.5285 6.19916 14.0429 6.57002 14.4138C6.94089 14.7847 7.45532 15 7.98171 15C8.5081 15 9.02252 14.7847 9.39339 14.4138C9.76425 14.0429 9.9796 13.5285 9.9796 13.0021H13.4849L13.9634 12.3441L13.3772 10.5735ZM8.68755 13.7199C8.49613 13.9113 8.2449 14.019 7.98171 14.019C7.71851 14.019 7.46728 13.9113 7.27586 13.7199C7.08445 13.5285 6.97678 13.2773 6.97678 13.0141H8.97467C8.98663 13.2773 8.87896 13.5285 8.68755 13.7199ZM3.17241 12.0091L3.54328 10.8965C3.8304 10.0232 3.98593 9.114 3.98593 8.20478V6.00351C3.98593 5.44123 4.10556 4.89092 4.33287 4.38845C4.56017 3.87403 4.88318 3.41942 5.3019 3.04855C5.72062 2.66572 6.21112 2.3786 6.73751 2.21111C7.27586 2.03166 7.83815 1.97184 8.38846 2.03166C9.39339 2.16326 10.3265 2.66572 10.9845 3.43138C11.6545 4.19704 12.0014 5.19 11.9894 6.20689V8.21675C11.9894 9.12596 12.133 10.0352 12.4321 10.9085L12.803 12.0211H3.17241V12.0091Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/blocked.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.00003 1C9.61951 1.00012 11.1888 1.56176 12.4407 2.58924C13.6925 3.61671 14.5493 5.04644 14.8651 6.63483C15.1809 8.22321 14.9363 9.87197 14.1728 11.3002C13.4092 12.7284 12.1742 13.8477 10.6779 14.4673C9.18166 15.087 7.51685 15.1687 5.96713 14.6985C4.41742 14.2283 3.07868 13.2353 2.17902 11.8887C1.27936 10.5421 0.874443 8.92518 1.03327 7.31351C1.19209 5.70183 1.90482 4.19509 3.05003 3.05C3.70009 2.40001 4.47181 1.88442 5.32114 1.53268C6.17046 1.18094 7.08075 0.999934 8.00003 1V1ZM2.00003 8C2.00145 9.41722 2.5045 10.7882 3.42003 11.87L11.87 3.42C10.9982 2.68012 9.933 2.20479 8.80003 2.05C7.95187 1.93589 7.08911 2.00455 6.26966 2.25136C5.45022 2.49817 4.69306 2.91742 4.049 3.48097C3.40494 4.04452 2.88889 4.73933 2.53549 5.51876C2.18209 6.29818 1.99952 7.1442 2.00003 8V8ZM14 8C13.9986 6.58278 13.4956 5.21181 12.58 4.13L4.13003 12.58C4.996 13.338 6.06169 13.8309 7.20003 14C8.05239 14.1147 8.91944 14.0448 9.74243 13.7951C10.5654 13.5454 11.3251 13.1217 11.97 12.5526C12.6149 11.9836 13.1299 11.2826 13.4802 10.4971C13.8304 9.71162 14.0077 8.86001 14 8V8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/bold.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5 13V3H8.36226C9.4783 3 10.3165 3.22436 10.8769 3.67308C11.442 4.12179 11.7245 4.78571 11.7245 5.66484C11.7245 6.13187 11.588 6.54625 11.3148 6.90797C11.0417 7.26511 10.6697 7.54212 10.1988 7.73901C10.7545 7.89011 11.1924 8.17857 11.5126 8.6044C11.8375 9.02564 12 9.5293 12 10.1154C12 11.0128 11.701 11.7179 11.1029 12.2308C10.5049 12.7436 9.6596 13 8.5671 13H5ZM6.35621 8.3228V11.9217H8.59536C9.22637 11.9217 9.72318 11.7637 10.0858 11.4478C10.4531 11.1273 10.6367 10.6877 10.6367 10.1291C10.6367 8.92491 9.96334 8.3228 8.61655 8.3228H6.35621ZM6.35621 7.26511H8.40464C8.99798 7.26511 9.47124 7.12088 9.82442 6.83242C10.1823 6.54396 10.3613 6.15247 10.3613 5.65797C10.3613 5.10852 10.1964 4.71016 9.8668 4.46291C9.53717 4.21108 9.03565 4.08516 8.36226 4.08516H6.35621V7.26511Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/book.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 2H9L8.65002 2.15002L8 2.79004L7.34998 2.15002L7 2H1.5L1 2.5V12.5L1.5 13H6.78998L7.65002 13.85H8.34998L9.21002 13H14.5L15 12.5V2.5L14.5 2ZM7.5 12.3199L7.32001 12.15L7 12H2V3H6.78998L7.53003 3.73999L7.5 12.3199ZM14 12H9L8.65002 12.15L8.51001 12.28V3.69995L9.21002 3H14V12ZM6 5H3V6H6V5ZM6 9H3V10H6V9ZM3 7H6V8H3V7ZM13 5H10V6H13V5ZM10 7H13V8H10V7ZM10 9H13V10H10V9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/bookmark.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.5 1H3.5L3 1.5V14.5L3.872 14.835L8 10.247L12.128 14.835L13 14.5V1.5L12.5 1ZM12 13.2L8.372 9.165H7.628L4 13.2V2H12V13.2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/briefcase.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5 4H11V2.5L10.5 2H5.5L5 2.5V4H1.5L1 4.5V12.5L1.5 13H14.5L15 12.5V4.5L14.5 4ZM6 3H10V4H6V3ZM14 5V5.76L10 8V7.5L9.51 7H6.51L6 7.5V8L2 5.71V5H14ZM9 8V9H7V8H9ZM2 12V6.86L6 9.15V9.5L6.5 10H9.5L10 9.5V9.19L14 6.91V12H2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/broadcast.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.66658 2.01118C5.65328 1.35189 6.81331 1 8 1C9.59075 1.00178 11.1158 1.63449 12.2407 2.75932C13.3655 3.88416 13.9982 5.40925 14 7C14 8.18669 13.6481 9.34672 12.9888 10.3334C12.3295 11.3201 11.3925 12.0891 10.2961 12.5433C10.1995 12.5833 10.102 12.6207 10.0037 12.6555V12.6109C10.0195 12.5965 10.035 12.5816 10.0502 12.5664C10.3278 12.2888 10.4837 11.9124 10.4837 11.5199V11.3831C10.8751 11.1611 11.2384 10.8859 11.5621 10.5621C12.507 9.61728 13.0385 8.33622 13.04 7C13.04 6.00318 12.7444 5.02875 12.1906 4.19993C11.6368 3.3711 10.8497 2.72511 9.92873 2.34365C9.00779 1.96218 7.99441 1.86237 7.01675 2.05684C6.03908 2.25131 5.14104 2.73132 4.43618 3.43618C3.73133 4.14104 3.25131 5.03908 3.05684 6.01674C2.86238 6.99441 2.96218 8.00778 3.34365 8.92872C3.72512 9.84966 4.3711 10.6368 5.19993 11.1906C5.29798 11.2561 5.39807 11.318 5.5 11.3763V11.5199C5.5 11.9124 5.65592 12.2888 5.93348 12.5664C5.94869 12.5816 5.9642 12.5965 5.98 12.6109V12.6497C5.14757 12.3521 4.3876 11.8729 3.75736 11.2426C2.91825 10.4035 2.3468 9.33443 2.11529 8.17054C1.88378 7.00665 2.0026 5.80025 2.45673 4.7039C2.91085 3.60754 3.67989 2.67047 4.66658 2.01118Z" fill="#C5C5C5"/>
<path d="M9.34313 11.8593C9.25311 11.9493 9.13102 11.9999 9.00372 11.9999V14.5199C9.00372 14.6472 8.95315 14.7693 8.86313 14.8593C8.77311 14.9493 8.65102 14.9999 8.52372 14.9999H7.46C7.47148 14.9999 7.4559 14.9957 7.42571 14.9877C7.35052 14.9676 7.1848 14.9235 7.12059 14.8593C7.03057 14.7693 6.98 14.6472 6.98 14.5199V11.9999C6.8527 11.9999 6.73061 11.9493 6.64059 11.8593C6.63782 11.8565 6.6351 11.8537 6.63241 11.8509C6.54752 11.7618 6.5 11.6433 6.5 11.5199V9.5C6.5 9.3965 6.51572 9.29667 6.54491 9.20278C6.67148 8.79563 7.05121 8.5 7.5 8.5H8.48372C8.93548 8.5 9.31728 8.79957 9.44129 9.2109C9.46888 9.30242 9.48372 9.39948 9.48372 9.5V11.5199C9.48372 11.6453 9.43463 11.7657 9.34709 11.8553L9.34313 11.8593Z" fill="#C5C5C5"/>
<path d="M10.64 6.99995C10.6396 7.52524 10.4828 8.03431 10.1953 8.46487C10.3784 8.76684 10.4837 9.12111 10.4837 9.5V9.60589C10.6744 9.42419 10.8454 9.22121 10.9932 9C11.3888 8.40799 11.6 7.71196 11.6 6.99995C11.5987 6.04556 11.219 5.13063 10.5441 4.45577C9.86928 3.78091 8.95434 3.40122 7.99995 3.39995C7.28794 3.39995 6.59192 3.61109 5.9999 4.00666C5.40788 4.40223 4.94646 4.96448 4.67399 5.62229C4.40151 6.2801 4.33022 7.00394 4.46913 7.70228C4.60803 8.40061 4.9509 9.04207 5.45437 9.54554C5.46946 9.56062 5.48467 9.57557 5.5 9.59036V9.5C5.5 9.11608 5.60818 8.75742 5.79571 8.45285C5.70402 8.31375 5.62528 8.16563 5.56091 8.01024C5.3611 7.52784 5.30882 6.99702 5.41068 6.48491C5.51255 5.9728 5.76398 5.5024 6.13319 5.13319C6.5024 4.76398 6.9728 4.51254 7.48491 4.41068C7.99702 4.30881 8.52784 4.36109 9.01024 4.56091C9.49263 4.76072 9.90494 5.0991 10.195 5.53325C10.4851 5.96739 10.64 6.47781 10.64 6.99995Z" fill="#C5C5C5"/>
<path d="M9 7C9 7.55228 8.55229 8 8 8C7.44772 8 7 7.55228 7 7C7 6.44772 7.44772 6 8 6C8.55229 6 9 6.44772 9 7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/browser.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V4.5V13.5L14.5 14H1.5L1 13.5V4.5V1.5L1.5 1ZM2 5V13H14V5H2ZM2 4H14V2H2V4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/bug.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.8775 4.5V3.91833C10.8775 2.30658 9.57092 1 7.95917 1C6.34742 1 5.04084 2.30658 5.04084 3.91833V4.5H4.20835L2.54527 2.8285L1.95216 3.41862L3.56303 5.03764L3.54447 5.08683C3.22212 5.94055 3.04084 6.90159 3.04084 7.91833C3.04084 8.11403 3.04755 8.30766 3.0607 8.49886L3.0637 8.5425H1V9.37916H3.16882L3.17494 9.41265C3.34718 10.3545 3.6785 11.2152 4.12918 11.9442L4.16317 11.9992L2.19995 13.9624L2.79157 14.554L4.66326 12.6823L4.72075 12.748C5.58881 13.7401 6.72251 14.3367 7.95917 14.3367C9.17697 14.3367 10.2949 13.7582 11.1576 12.7932L11.2153 12.7287L13.1251 14.6481L13.7182 14.058L11.7218 12.0515L11.7565 11.9964C12.2239 11.2564 12.567 10.3771 12.7434 9.41265L12.7495 9.37916H14.92V8.5425H12.8546L12.8576 8.49886C12.8708 8.30766 12.8775 8.11403 12.8775 7.91833C12.8775 6.88815 12.6914 5.91515 12.361 5.05303L12.3421 5.00354L13.9119 3.43371L13.3203 2.8421L11.6624 4.5H10.8775ZM5.87751 4.5V3.91833C5.87751 2.76866 6.8095 1.83667 7.95917 1.83667C9.10884 1.83667 10.0408 2.76866 10.0408 3.91833V4.5H5.87751ZM11.5739 5.33667L11.5938 5.38957C11.8772 6.14269 12.0408 7.00011 12.0408 7.91833C12.0408 9.52826 11.5379 10.9522 10.7668 11.9546C9.99644 12.9561 8.99584 13.5 7.95917 13.5C6.9225 13.5 5.9219 12.9561 5.15153 11.9546C4.38048 10.9522 3.8775 9.52826 3.8775 7.91833C3.8775 7.00011 4.0411 6.1427 4.32451 5.38957L4.34441 5.33667H11.5739Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/build.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.854 6.59999L10.354 4.1L9.646 3.4L8 5.043V0H7V5.043L5.354 3.4L4.646 4.1L7.146 6.59999H7.854Z" fill="#C5C5C5"/>
<path d="M14 14.5V4.99999H13V14H2V4.99999H1V14.5L1.5 15H13.5L14 14.5Z" fill="#C5C5C5"/>
<path d="M5 12.5V11.5L4.5 11H3.5L3 11.5V12.5L3.5 13H4.5L5 12.5Z" fill="#C5C5C5"/>
<path d="M9 11.5V12.5L8.5 13H7.5L7 12.5V11.5L7.5 11H8.5L9 11.5Z" fill="#C5C5C5"/>
<path d="M7 9.49999V8.49999L6.5 7.99999H5.5L5 8.49999V9.49999L5.5 9.99999H6.5L7 9.49999Z" fill="#C5C5C5"/>
<path d="M11 8.49999V9.49999L10.5 9.99999H9.5L9 9.49999V8.49999L9.5 7.99999H10.5L11 8.49999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/calendar.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 2H13V1H12V2H4V1H3V2H1.5L1 2.5V14.5L1.5 15H14.5L15 14.5V2.5L14.5 2ZM14 14H2V5H14V14ZM14 4H2V3H14V4ZM4 8H3V9H4V8ZM3 10H4V11H3V10ZM4 12H3V13H4V12ZM6 8H7V9H6V8ZM7 10H6V11H7V10ZM6 12H7V13H6V12ZM7 6H6V7H7V6ZM9 8H10V9H9V8ZM10 10H9V11H10V10ZM9 12H10V13H9V12ZM10 6H9V7H10V6ZM12 8H13V9H12V8ZM13 10H12V11H13V10ZM12 6H13V7H12V6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/call-incoming.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5469 9.32812C12.3542 9.25 12.1562 9.21094 11.9531 9.21094C11.7344 9.20573 11.5495 9.23958 11.3984 9.3125C11.2474 9.38542 11.1042 9.47135 10.9688 9.57031C10.8333 9.66927 10.7135 9.77865 10.6094 9.89844C10.5052 10.0182 10.4036 10.1276 10.3047 10.2266C10.2057 10.3255 10.1094 10.4089 10.0156 10.4766C9.92188 10.5443 9.82031 10.5781 9.71094 10.5781C9.5599 10.5781 9.42969 10.5234 9.32031 10.4141C9.24219 10.3411 9.13281 10.237 8.99219 10.1016C8.85156 9.96615 8.67969 9.80208 8.47656 9.60938C8.27344 9.41667 8.0625 9.21354 7.84375 9C7.625 8.78646 7.39844 8.5651 7.16406 8.33594C6.92969 8.10677 6.71094 7.88542 6.50781 7.67188C6.30469 7.45833 6.11979 7.25781 5.95312 7.07031C5.78646 6.88281 5.65625 6.72135 5.5625 6.58594C5.46875 6.45052 5.42188 6.35156 5.42188 6.28906C5.41667 6.17448 5.45052 6.07031 5.52344 5.97656C5.59635 5.88281 5.68229 5.78646 5.78125 5.6875C5.88021 5.58854 5.98958 5.48438 6.10938 5.375C6.22917 5.26562 6.33854 5.14844 6.4375 5.02344C6.53646 4.89844 6.61979 4.75521 6.6875 4.59375C6.75521 4.43229 6.78906 4.25 6.78906 4.04688C6.78906 3.84375 6.75 3.64583 6.67188 3.45312C6.59375 3.26042 6.48177 3.09115 6.33594 2.94531C6.16927 2.78385 5.99219 2.59115 5.80469 2.36719C5.61719 2.14323 5.41146 1.92969 5.1875 1.72656C4.96354 1.52344 4.73177 1.35156 4.49219 1.21094C4.2526 1.07031 4.0026 1 3.74219 1C3.53906 1 3.34115 1.03906 3.14844 1.11719C2.95573 1.19531 2.78646 1.30729 2.64062 1.45313C2.36979 1.72396 2.13281 1.96615 1.92969 2.17969C1.72656 2.39323 1.55469 2.61458 1.41406 2.84375C1.27344 3.07292 1.16927 3.32812 1.10156 3.60938C1.03385 3.89062 1 4.22917 1 4.625C1 5.17708 1.08854 5.75 1.26562 6.34375C1.44271 6.9375 1.68229 7.52865 1.98438 8.11719C2.28646 8.70573 2.65365 9.28385 3.08594 9.85156C3.51823 10.4193 3.98698 10.9583 4.49219 11.4688C4.9974 11.9792 5.53385 12.4505 6.10156 12.8828C6.66927 13.3151 7.25 13.6875 7.84375 14C8.4375 14.3125 9.03385 14.5573 9.63281 14.7344C10.2318 14.9115 10.8151 15 11.3828 15C11.7682 14.9948 12.1042 14.9583 12.3906 14.8906C12.6771 14.8229 12.9349 14.7188 13.1641 14.5781C13.3932 14.4375 13.6146 14.2656 13.8281 14.0625C14.0417 13.8594 14.2812 13.625 14.5469 13.3594C14.6927 13.2135 14.8047 13.0443 14.8828 12.8516C14.9609 12.6589 15 12.4609 15 12.2578C14.9896 12.0859 14.9557 11.9141 14.8984 11.7422C14.8411 11.5703 14.7552 11.4089 14.6406 11.2578C14.526 11.1068 14.4036 10.9583 14.2734 10.8125C14.1432 10.6667 14.0026 10.526 13.8516 10.3906C13.7005 10.2552 13.5573 10.1276 13.4219 10.0078C13.2865 9.88802 13.1641 9.77344 13.0547 9.66406C12.9089 9.51823 12.7396 9.40625 12.5469 9.32812ZM12.1797 13.9141C11.9661 13.9714 11.7005 14 11.3828 14C10.8984 13.9948 10.3932 13.9141 9.86719 13.7578C9.34115 13.6016 8.8125 13.3802 8.28125 13.0938C7.75 12.8073 7.22396 12.4688 6.70312 12.0781C6.18229 11.6875 5.69271 11.2604 5.23438 10.7969C4.77604 10.3333 4.34635 9.84635 3.94531 9.33594C3.54427 8.82552 3.20052 8.29948 2.91406 7.75781C2.6276 7.21615 2.40365 6.67969 2.24219 6.14844C2.08073 5.61719 2 5.10156 2 4.60156C2.00521 4.29427 2.03646 4.03125 2.09375 3.8125C2.15104 3.59375 2.23698 3.39844 2.35156 3.22656C2.46615 3.05469 2.60677 2.88802 2.77344 2.72656C2.9401 2.5651 3.13021 2.3776 3.34375 2.16406C3.45312 2.05469 3.58594 2 3.74219 2C3.80469 1.99479 3.90104 2.03646 4.03125 2.125C4.16146 2.21354 4.30208 2.32031 4.45312 2.44531C4.60417 2.57031 4.76042 2.71354 4.92188 2.875C5.08333 3.03646 5.22656 3.19271 5.35156 3.34375C5.47656 3.49479 5.58073 3.63281 5.66406 3.75781C5.7474 3.88281 5.78906 3.97917 5.78906 4.04688C5.79427 4.17188 5.76042 4.27604 5.6875 4.35938C5.61458 4.44271 5.52865 4.53906 5.42969 4.64844C5.33073 4.75781 5.22135 4.86198 5.10156 4.96094C4.98177 5.0599 4.8724 5.17708 4.77344 5.3125C4.67448 5.44792 4.59115 5.59375 4.52344 5.75C4.45573 5.90625 4.42188 6.08594 4.42188 6.28906C4.42708 6.5026 4.46875 6.70312 4.54688 6.89062C4.625 7.07812 4.73698 7.24479 4.88281 7.39062L8.60938 11.1172C8.76042 11.2682 8.92969 11.3828 9.11719 11.4609C9.30469 11.5391 9.5026 11.5781 9.71094 11.5781C9.91927 11.5833 10.1016 11.5495 10.2578 11.4766C10.4141 11.4036 10.5573 11.3177 10.6875 11.2188C10.8177 11.1198 10.9375 11.0104 11.0469 10.8906C11.1562 10.7708 11.2578 10.6615 11.3516 10.5625C11.4453 10.4635 11.5417 10.3802 11.6406 10.3125C11.7396 10.2448 11.8438 10.2109 11.9531 10.2109C12.026 10.2109 12.125 10.2526 12.25 10.3359C12.375 10.4193 12.513 10.526 12.6641 10.6562C12.8151 10.7865 12.9714 10.9297 13.1328 11.0859C13.2943 11.2422 13.4375 11.3984 13.5625 11.5547C13.6875 11.7109 13.7917 11.8516 13.875 11.9766C13.9583 12.1016 14 12.1979 14 12.2656C14 12.4167 13.9453 12.5469 13.8359 12.6562C13.612 12.875 13.4219 13.0651 13.2656 13.2266C13.1094 13.388 12.9427 13.5286 12.7656 13.6484C12.5885 13.7682 12.3932 13.8568 12.1797 13.9141ZM15 1.70312L10.3594 6.35156L13.6484 6.35156V7.35156L8.64844 7.35156L8.64844 2.35156L9.64844 2.35156V5.64062L14.2969 1L15 1.70312Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/call-outgoing.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.64844 6.64844L13.2891 2H10V1H15V6H14V2.71094L9.35156 7.35156L8.64844 6.64844ZM11.9531 9.21094C12.1562 9.21094 12.3542 9.25 12.5469 9.32812C12.7396 9.40625 12.9089 9.51823 13.0547 9.66406C13.1641 9.77344 13.2865 9.88802 13.4219 10.0078C13.5573 10.1276 13.7005 10.2552 13.8516 10.3906C14.0026 10.526 14.1432 10.6667 14.2734 10.8125C14.4036 10.9583 14.526 11.1068 14.6406 11.2578C14.7552 11.4089 14.8411 11.5703 14.8984 11.7422C14.9557 11.9141 14.9896 12.0859 15 12.2578C15 12.4609 14.9609 12.6589 14.8828 12.8516C14.8047 13.0443 14.6927 13.2135 14.5469 13.3594C14.2812 13.625 14.0417 13.8594 13.8281 14.0625C13.6146 14.2656 13.3932 14.4375 13.1641 14.5781C12.9349 14.7188 12.6771 14.8229 12.3906 14.8906C12.1042 14.9583 11.7682 14.9948 11.3828 15C10.8151 15 10.2318 14.9115 9.63281 14.7344C9.03385 14.5573 8.4375 14.3125 7.84375 14C7.25 13.6875 6.66927 13.3151 6.10156 12.8828C5.53385 12.4505 4.9974 11.9792 4.49219 11.4688C3.98698 10.9583 3.51823 10.4193 3.08594 9.85156C2.65365 9.28385 2.28646 8.70573 1.98438 8.11719C1.68229 7.52865 1.44271 6.9375 1.26562 6.34375C1.08854 5.75 1 5.17708 1 4.625C1 4.22917 1.03385 3.89062 1.10156 3.60938C1.16927 3.32812 1.27344 3.07292 1.41406 2.84375C1.55469 2.61458 1.72656 2.39323 1.92969 2.17969C2.13281 1.96615 2.36979 1.72396 2.64062 1.45312C2.78646 1.30729 2.95573 1.19531 3.14844 1.11719C3.34115 1.03906 3.53906 1 3.74219 1C4.0026 1 4.2526 1.07031 4.49219 1.21094C4.73177 1.35156 4.96354 1.52344 5.1875 1.72656C5.41146 1.92969 5.61719 2.14323 5.80469 2.36719C5.99219 2.59115 6.16927 2.78385 6.33594 2.94531C6.48177 3.09115 6.59375 3.26042 6.67188 3.45312C6.75 3.64583 6.78906 3.84375 6.78906 4.04688C6.78906 4.25 6.75521 4.43229 6.6875 4.59375C6.61979 4.75521 6.53646 4.89844 6.4375 5.02344C6.33854 5.14844 6.22917 5.26562 6.10938 5.375C5.98958 5.48438 5.88021 5.58854 5.78125 5.6875C5.68229 5.78646 5.59635 5.88281 5.52344 5.97656C5.45052 6.07031 5.41667 6.17448 5.42188 6.28906C5.42188 6.35156 5.46875 6.45052 5.5625 6.58594C5.65625 6.72135 5.78646 6.88281 5.95312 7.07031C6.11979 7.25781 6.30469 7.45833 6.50781 7.67188C6.71094 7.88542 6.92969 8.10677 7.16406 8.33594C7.39844 8.5651 7.625 8.78646 7.84375 9C8.0625 9.21354 8.27344 9.41667 8.47656 9.60938C8.67969 9.80208 8.85156 9.96615 8.99219 10.1016C9.13281 10.237 9.24219 10.3411 9.32031 10.4141C9.42969 10.5234 9.5599 10.5781 9.71094 10.5781C9.82031 10.5781 9.92188 10.5443 10.0156 10.4766C10.1094 10.4089 10.2057 10.3255 10.3047 10.2266C10.4036 10.1276 10.5052 10.0182 10.6094 9.89844C10.7135 9.77865 10.8333 9.66927 10.9688 9.57031C11.1042 9.47135 11.2474 9.38542 11.3984 9.3125C11.5495 9.23958 11.7344 9.20573 11.9531 9.21094ZM11.3828 14C11.7005 14 11.9661 13.9714 12.1797 13.9141C12.3932 13.8568 12.5885 13.7682 12.7656 13.6484C12.9427 13.5286 13.1094 13.388 13.2656 13.2266C13.4219 13.0651 13.612 12.875 13.8359 12.6562C13.9453 12.5469 14 12.4167 14 12.2656C14 12.1979 13.9583 12.1016 13.875 11.9766C13.7917 11.8516 13.6875 11.7109 13.5625 11.5547C13.4375 11.3984 13.2943 11.2422 13.1328 11.0859C12.9714 10.9297 12.8151 10.7865 12.6641 10.6562C12.513 10.526 12.375 10.4193 12.25 10.3359C12.125 10.2526 12.026 10.2109 11.9531 10.2109C11.8438 10.2109 11.7396 10.2448 11.6406 10.3125C11.5417 10.3802 11.4453 10.4635 11.3516 10.5625C11.2578 10.6615 11.1562 10.7708 11.0469 10.8906C10.9375 11.0104 10.8177 11.1198 10.6875 11.2188C10.5573 11.3177 10.4141 11.4036 10.2578 11.4766C10.1016 11.5495 9.91927 11.5833 9.71094 11.5781C9.5026 11.5781 9.30469 11.5391 9.11719 11.4609C8.92969 11.3828 8.76042 11.2682 8.60938 11.1172L4.88281 7.39062C4.73698 7.24479 4.625 7.07812 4.54688 6.89062C4.46875 6.70312 4.42708 6.5026 4.42188 6.28906C4.42188 6.08594 4.45573 5.90625 4.52344 5.75C4.59115 5.59375 4.67448 5.44792 4.77344 5.3125C4.8724 5.17708 4.98177 5.0599 5.10156 4.96094C5.22135 4.86198 5.33073 4.75781 5.42969 4.64844C5.52865 4.53906 5.61458 4.44271 5.6875 4.35938C5.76042 4.27604 5.79427 4.17188 5.78906 4.04688C5.78906 3.97917 5.7474 3.88281 5.66406 3.75781C5.58073 3.63281 5.47656 3.49479 5.35156 3.34375C5.22656 3.19271 5.08333 3.03646 4.92188 2.875C4.76042 2.71354 4.60417 2.57031 4.45312 2.44531C4.30208 2.32031 4.16146 2.21354 4.03125 2.125C3.90104 2.03646 3.80469 1.99479 3.74219 2C3.58594 2 3.45312 2.05469 3.34375 2.16406C3.13021 2.3776 2.9401 2.5651 2.77344 2.72656C2.60677 2.88802 2.46615 3.05469 2.35156 3.22656C2.23698 3.39844 2.15104 3.59375 2.09375 3.8125C2.03646 4.03125 2.00521 4.29427 2 4.60156C2 5.10156 2.08073 5.61719 2.24219 6.14844C2.40365 6.67969 2.6276 7.21615 2.91406 7.75781C3.20052 8.29948 3.54427 8.82552 3.94531 9.33594C4.34635 9.84635 4.77604 10.3333 5.23438 10.7969C5.69271 11.2604 6.18229 11.6875 6.70312 12.0781C7.22396 12.4688 7.75 12.8073 8.28125 13.0938C8.8125 13.3802 9.34115 13.6016 9.86719 13.7578C10.3932 13.9141 10.8984 13.9948 11.3828 14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/case-sensitive.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.495 9.052L8.386 11.402H9.477L6.237 3H5.217L2 11.402H3.095L3.933 9.052H7.495ZM5.811 4.453L5.855 4.588L7.173 8.162H4.255L5.562 4.588L5.606 4.453L5.644 4.297L5.676 4.145L5.697 4.019H5.72L5.744 4.145L5.773 4.297L5.811 4.453ZM13.795 10.464V11.4H14.755V7.498C14.755 6.779 14.575 6.226 14.216 5.837C13.857 5.448 13.327 5.254 12.628 5.254C12.429 5.254 12.227 5.273 12.022 5.31C11.817 5.347 11.622 5.394 11.439 5.451C11.256 5.508 11.091 5.569 10.944 5.636C10.797 5.703 10.683 5.765 10.601 5.824V6.808C10.867 6.578 11.167 6.397 11.505 6.268C11.843 6.139 12.194 6.075 12.557 6.075C12.745 6.075 12.915 6.103 13.07 6.16C13.225 6.217 13.357 6.306 13.466 6.427C13.575 6.548 13.659 6.706 13.718 6.899C13.777 7.092 13.806 7.326 13.806 7.599L11.995 7.851C11.651 7.898 11.355 7.977 11.107 8.088C10.859 8.199 10.654 8.339 10.492 8.507C10.33 8.675 10.21 8.868 10.132 9.087C10.054 9.306 10.015 9.546 10.015 9.808C10.015 10.054 10.057 10.283 10.139 10.496C10.221 10.709 10.342 10.893 10.502 11.047C10.662 11.201 10.862 11.323 11.1 11.413C11.338 11.503 11.613 11.548 11.926 11.548C12.328 11.548 12.686 11.456 13.001 11.27C13.316 11.084 13.573 10.816 13.772 10.464H13.795ZM11.667 8.721C11.843 8.657 12.068 8.607 12.341 8.572L13.806 8.367V8.976C13.806 9.222 13.765 9.451 13.683 9.664C13.601 9.877 13.486 10.063 13.34 10.221C13.194 10.379 13.019 10.503 12.816 10.593C12.613 10.683 12.39 10.728 12.148 10.728C11.961 10.728 11.795 10.703 11.653 10.652C11.511 10.601 11.392 10.53 11.296 10.441C11.2 10.352 11.127 10.247 11.076 10.125C11.025 10.003 11 9.873 11 9.732C11 9.568 11.018 9.421 11.055 9.292C11.092 9.163 11.16 9.051 11.257 8.958C11.354 8.865 11.491 8.785 11.667 8.721Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/check.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.4315 3.3232L5.96151 13.3232L5.1708 13.2874L1.8208 8.5174L2.63915 7.94268L5.61697 12.1827L13.6684 2.67688L14.4315 3.3232Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/checklist.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.75 4.48H3.04L2 3.43L2.71 2.73L3.4 3.41L4.81 2L5.52 2.71L3.75 4.48ZM6.98999 3H14.99V4H6.98999V3ZM6.98999 6H14.99V7H6.98999V6ZM14.99 9H6.98999V10H14.99V9ZM6.98999 12H14.99V13H6.98999V12ZM3.04 7.48001H3.75L5.52 5.71001L4.81 5.01001L3.4 6.42001L2.71 5.73001L2 6.44001L3.04 7.48001ZM3.75 10.49H3.04L2 9.45001L2.71 8.74001L3.4 9.43001L4.81 8.01001L5.52 8.72001L3.75 10.49ZM3.04 13.5H3.75L5.52 11.73L4.81 11.02L3.4 12.44L2.71 11.75L2 12.45L3.04 13.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chevron-down.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.97612 10.0719L12.3334 5.7146L12.9521 6.33332L8.28548 11L7.66676 11L3.0001 6.33332L3.61882 5.7146L7.97612 10.0719Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chevron-left.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.92809 7.97603L10.2854 12.3333L9.66668 12.9521L5.00001 8.28539V7.66667L9.66668 3L10.2854 3.61872L5.92809 7.97603Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chevron-right.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.0719 8.02397L5.7146 3.66666L6.33332 3.04794L11 7.71461V8.33333L6.33332 13L5.7146 12.3813L10.0719 8.02397Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chevron-up.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.02388 5.92809L3.66657 10.2854L3.04785 9.66668L7.71452 5.00001L8.33324 5.00001L12.9999 9.66668L12.3812 10.2854L8.02388 5.92809Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chrome-close.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.1161 7.99992L2.55804 12.558L3.44193 13.4419L7.99999 8.88381L12.558 13.4419L13.4419 12.558L8.88387 7.99992L13.4419 3.44187L12.558 2.55798L7.99999 7.11604L3.44193 2.55798L2.55804 3.44187L7.1161 7.99992Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chrome-maximize.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3 3V13H13V3H3ZM12 12H4V4H12V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chrome-minimize.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 7.99994V8.99994H3V7.99994H14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/chrome-restore.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3 5V14H12V5H3ZM11 13H4V6H11V13Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 5H6V4H13V11H12V12H14V5V3H12H5V5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/circle-filled.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 4C8.36719 4 8.72135 4.04818 9.0625 4.14453C9.40365 4.23828 9.72135 4.3724 10.0156 4.54688C10.3125 4.72135 10.582 4.93099 10.8242 5.17578C11.069 5.41797 11.2786 5.6875 11.4531 5.98438C11.6276 6.27865 11.7617 6.59635 11.8555 6.9375C11.9518 7.27865 12 7.63281 12 8C12 8.36719 11.9518 8.72135 11.8555 9.0625C11.7617 9.40365 11.6276 9.72266 11.4531 10.0195C11.2786 10.3138 11.069 10.5833 10.8242 10.8281C10.582 11.0703 10.3125 11.2786 10.0156 11.4531C9.72135 11.6276 9.40365 11.763 9.0625 11.8594C8.72135 11.9531 8.36719 12 8 12C7.63281 12 7.27865 11.9531 6.9375 11.8594C6.59635 11.763 6.27734 11.6276 5.98047 11.4531C5.6862 11.2786 5.41667 11.0703 5.17188 10.8281C4.92969 10.5833 4.72135 10.3138 4.54688 10.0195C4.3724 9.72266 4.23698 9.40365 4.14063 9.0625C4.04688 8.72135 4 8.36719 4 8C4 7.63281 4.04688 7.27865 4.14063 6.9375C4.23698 6.59635 4.3724 6.27865 4.54688 5.98438C4.72135 5.6875 4.92969 5.41797 5.17188 5.17578C5.41667 4.93099 5.6862 4.72135 5.98047 4.54688C6.27734 4.3724 6.59635 4.23828 6.9375 4.14453C7.27865 4.04818 7.63281 4 8 4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/circle-outline.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 12C10.2091 12 12 10.2091 12 8C12 5.79086 10.2091 4 8 4C5.79086 4 4 5.79086 4 8C4 10.2091 5.79086 12 8 12ZM10.6093 8C10.6093 9.44108 9.44107 10.6093 8 10.6093C6.55893 10.6093 5.39071 9.44108 5.39071 8C5.39071 6.55893 6.55893 5.39071 8 5.39071C9.44107 5.39071 10.6093 6.55893 10.6093 8ZM8 5.24613C9.52092 5.24613 10.7539 6.47908 10.7539 8C10.7539 8 10.7539 8 10.7539 8C10.7539 6.47908 9.52092 5.24613 8 5.24613Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/circle-slash.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 1C9.38447 1 10.7378 1.41054 11.889 2.17971C13.0401 2.94888 13.9373 4.04213 14.4672 5.32122C14.997 6.6003 15.1356 8.00777 14.8655 9.36563C14.5954 10.7235 13.9287 11.9708 12.9497 12.9497C11.9708 13.9287 10.7235 14.5954 9.36563 14.8655C8.00776 15.1356 6.6003 14.997 5.32121 14.4672C4.04213 13.9373 2.94888 13.0401 2.17971 11.889C1.41054 10.7378 0.999997 9.38447 0.999997 8C1.00211 6.14413 1.74029 4.36489 3.05259 3.05259C4.36488 1.7403 6.14413 1.00212 8 1ZM2 8C1.99922 9.41814 2.50371 10.7902 3.423 11.87L11.87 3.423C10.9975 2.68282 9.93139 2.20787 8.7976 2.05426C7.66381 1.90065 6.50974 2.0748 5.47177 2.55614C4.43379 3.03748 3.55529 3.80588 2.94008 4.77056C2.32487 5.73523 1.99866 6.85585 2 8ZM14 8C14.0008 6.58186 13.4963 5.20983 12.577 4.13L4.13 12.577C5.00248 13.3172 6.0686 13.7921 7.20239 13.9457C8.33618 14.0994 9.49025 13.9252 10.5282 13.4439C11.5662 12.9625 12.4447 12.1941 13.0599 11.2294C13.6751 10.2648 14.0013 9.14415 14 8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/circuit-board.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5 1H1.5L1 1.5V14.5L1.5 15H14.5L15 14.5V1.5L14.5 1ZM14 14H5V12H7.3C7.6 12.6 8.3 13 9 13C10.1 13 11 12.1 11 11C11 9.9 10.1 9 9 9C7.9 9 7 9.9 7 11H4V14H2V2H4V4.3C3.4 4.6 3 5.3 3 6C3 7.1 3.9 8 5 8C6.1 8 7 7.1 7 6H9C9 7.1 9.9 8 11 8C12.1 8 13 7.1 13 6C13 4.9 12.1 4 11 4C10.3 4 9.6 4.4 9.3 5H6.7C6.4 4.4 5.7 4 5 4V2H14V14ZM8 11C8 10.4 8.4 10 9 10C9.6 10 10 10.4 10 11C10 11.6 9.6 12 9 12C8.4 12 8 11.6 8 11ZM5 5C5.6 5 6 5.4 6 6C6 6.6 5.6 7 5 7C4.4 7 4 6.6 4 6C4 5.4 4.4 5 5 5ZM11 5C11.6 5 12 5.4 12 6C12 6.6 11.6 7 11 7C10.4 7 10 6.6 10 6C10 5.4 10.4 5 11 5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/clear-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.0001 12.6L10.7001 13.3L12.3001 11.7L13.9001 13.3L14.7001 12.6L13.0001 11L14.7001 9.40005L13.9001 8.60005L12.3001 10.3L10.7001 8.60005L10.0001 9.40005L11.6001 11L10.0001 12.6Z" fill="#C5C5C5"/>
<path d="M1.00006 4L15.0001 4L15.0001 3L1.00006 3L1.00006 4Z" fill="#C5C5C5"/>
<path d="M1.00006 7L15.0001 7L15.0001 6L1.00006 6L1.00006 7Z" fill="#C5C5C5"/>
<path d="M9.00006 9.5L9.00006 9L1.00006 9L1.00006 10L9.00006 10L9.00006 9.5Z" fill="#C5C5C5"/>
<path d="M9.00006 13L9.00006 12.5L9.00006 12L1.00006 12L1.00006 13L9.00006 13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/clippy.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.9916H4V4.99159H12V6.99159H13V4.49159L12.5 3.99159H11V2.99159H10C9.99777 2.46201 9.78559 1.95494 9.41 1.58159C9.03527 1.20908 8.52837 1 8 1C7.47163 1 6.96472 1.20908 6.59 1.58159C6.21441 1.95494 6.00223 2.46201 6 2.99159H4.94V3.99159H3.5L3 4.49159V14.4916L3.5 14.9916H7V13.9916ZM7 2.79159C7.03697 2.59305 7.13319 2.41037 7.27599 2.26757C7.41879 2.12478 7.60147 2.02856 7.8 1.99159C7.995 1.95352 8.19692 1.97441 8.38 2.05159C8.56399 2.12151 8.72139 2.24743 8.83 2.41159C8.96101 2.60413 9.02071 2.83635 8.9988 3.0682C8.97689 3.30006 8.87475 3.51699 8.71 3.68159C8.54541 3.84634 8.32847 3.94848 8.09662 3.97039C7.86477 3.9923 7.63254 3.93259 7.44 3.80159C7.27585 3.69298 7.14993 3.53558 7.08 3.35159C6.99999 3.17651 6.97221 2.98206 7 2.79159ZM14.08 12.2516L13 13.3416V7.99158H12V13.3316L10.92 12.2516L10.21 12.9616L12.15 14.8916H12.86L14.79 12.9616L14.08 12.2516ZM8.16 8.09155H8.87L10.8 10.0216L10.09 10.7316L9.01 9.65155V14.9916H8.01V9.64155L6.93 10.7316L6.22 10.0216L8.16 8.09155Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/close-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.62132 8.0858L7.91421 7.37869L6.5 8.7929L5.08579 7.37869L4.37868 8.0858L5.79289 9.50001L4.37868 10.9142L5.08579 11.6213L6.5 10.2071L7.91421 11.6213L8.62132 10.9142L7.20711 9.50001L8.62132 8.0858Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 3L6 2H13L14 3V10L13 11H11V13L10 14H3L2 13V6L3 5H5V3ZM6 5H10L11 6V10H13V3H6V5ZM10 6H3V13H10V6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/close.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.00004 8.70711L11.6465 12.3536L12.3536 11.6465L8.70714 8.00001L12.3536 4.35356L11.6465 3.64645L8.00004 7.2929L4.35359 3.64645L3.64648 4.35356L7.29293 8.00001L3.64648 11.6465L4.35359 12.3536L8.00004 8.70711Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/cloud-download.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.9565 6H12.0064C12.8004 6 13.5618 6.31607 14.1232 6.87868C14.6846 7.44129 15 8.20435 15 9C15 9.79565 14.6846 10.5587 14.1232 11.1213C13.5618 11.6839 12.8004 12 12.0064 12V11C12.5357 11 13.0434 10.7893 13.4176 10.4142C13.7919 10.0391 14.0021 9.53044 14.0021 9C14.0021 8.46957 13.7919 7.96086 13.4176 7.58579C13.0434 7.21072 12.5357 7 12.0064 7H11.0924L10.9687 6.143C10.8938 5.60541 10.6456 5.10711 10.2618 4.72407C9.87801 4.34103 9.37977 4.09427 8.84303 4.02143C8.30629 3.94859 7.76051 4.05365 7.2889 4.3206C6.81729 4.58754 6.44573 5.00173 6.23087 5.5L5.89759 6.262L5.08933 6.073C4.90382 6.02699 4.71364 6.0025 4.52255 6C3.86093 6 3.22641 6.2634 2.75858 6.73224C2.29075 7.20108 2.02792 7.83696 2.02792 8.5C2.02792 9.16304 2.29075 9.79893 2.75858 10.2678C3.22641 10.7366 3.86093 11 4.52255 11H5.02148V12H4.52255C4.02745 12.0043 3.5371 11.903 3.08403 11.7029C2.63096 11.5028 2.22553 11.2084 1.89461 10.8394C1.5637 10.4703 1.31488 10.0349 1.16465 9.56211C1.01442 9.08932 0.966217 8.58992 1.02324 8.09704C1.08026 7.60416 1.24121 7.12906 1.4954 6.70326C1.74959 6.27745 2.09121 5.91068 2.49762 5.62727C2.90402 5.34385 3.36591 5.15027 3.85264 5.05937C4.33938 4.96847 4.83984 4.98232 5.32083 5.1C5.6241 4.40501 6.14511 3.82799 6.80496 3.45635C7.4648 3.08472 8.22753 2.9387 8.9776 3.04044C9.72768 3.14217 10.4242 3.4861 10.9618 4.02014C11.4993 4.55418 11.8485 5.24923 11.9565 6ZM6.70719 11.1214L8.0212 12.4354V7H9.01506V12.3992L10.2929 11.1214L11 11.8285L8.85356 13.9749H8.14645L6.00008 11.8285L6.70719 11.1214Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/cloud-upload.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.9564 6H12.0063C12.8003 6 13.5617 6.31607 14.1231 6.87868C14.6845 7.44129 14.9999 8.20435 14.9999 9C14.9999 9.79565 14.6845 10.5587 14.1231 11.1213C13.5617 11.6839 12.8003 12 12.0063 12H10.0106V11H12.0063C12.5356 11 13.0432 10.7893 13.4175 10.4142C13.7918 10.0391 14.002 9.53044 14.002 9C14.002 8.46957 13.7918 7.96086 13.4175 7.58579C13.0432 7.21072 12.5356 7 12.0063 7H11.0923L10.9686 6.143C10.8937 5.60541 10.6455 5.10711 10.2617 4.72407C9.87792 4.34103 9.37968 4.09427 8.84295 4.02143C8.30621 3.94859 7.76044 4.05365 7.28883 4.3206C6.81723 4.58754 6.44567 5.00173 6.23082 5.5L5.89754 6.262L5.08929 6.073C4.90378 6.02699 4.71361 6.0025 4.52251 6C3.8609 6 3.22639 6.2634 2.75856 6.73224C2.29073 7.20108 2.02791 7.83696 2.02791 8.5C2.02791 9.16304 2.29073 9.79893 2.75856 10.2678C3.22639 10.7366 3.8609 11 4.52251 11H7.01712V12H4.52251C4.02742 12.0043 3.53708 11.903 3.08401 11.7029C2.63095 11.5028 2.22551 11.2084 1.8946 10.8394C1.56369 10.4703 1.31487 10.0349 1.16465 9.56211C1.01442 9.08932 0.966218 8.58992 1.02324 8.09704C1.08026 7.60416 1.24121 7.12906 1.49539 6.70326C1.74958 6.27745 2.0912 5.91068 2.4976 5.62727C2.904 5.34385 3.36588 5.15027 3.85261 5.05937C4.33935 4.96847 4.8398 4.98232 5.32079 5.1C5.62405 4.40501 6.14506 3.82799 6.8049 3.45635C7.46474 3.08472 8.22745 2.9387 8.97752 3.04044C9.72759 3.14217 10.4241 3.4861 10.9617 4.02014C11.4992 4.55418 11.8484 5.24923 11.9564 6ZM10.2928 9.85348L8.97879 8.53944L8.97879 13.9749H7.98492L7.98493 8.57568L6.7071 9.85347L5.99999 9.14636L8.14643 6.99998H8.85354L10.9999 9.14637L10.2928 9.85348Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/cloud.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.9565 6H12.0064C12.8004 6 13.5618 6.31607 14.1232 6.87868C14.6846 7.44129 15 8.20435 15 9C15 9.79565 14.6846 10.5587 14.1232 11.1213C13.5618 11.6839 12.8004 12 12.0064 12V11.9871L12 12L5.02148 12H4.52255C4.02745 12.0043 3.5371 11.903 3.08403 11.7029C2.63096 11.5028 2.22553 11.2084 1.89461 10.8394C1.5637 10.4703 1.31488 10.0349 1.16465 9.56211C1.01442 9.08932 0.966217 8.58992 1.02324 8.09704C1.08026 7.60416 1.24121 7.12906 1.4954 6.70326C1.74959 6.27745 2.09121 5.91068 2.49762 5.62727C2.90402 5.34385 3.36591 5.15027 3.85264 5.05937C4.33938 4.96847 4.83984 4.98232 5.32083 5.1C5.6241 4.40501 6.14511 3.82799 6.80496 3.45635C7.4648 3.08472 8.22753 2.9387 8.9776 3.04044C9.72768 3.14217 10.4242 3.4861 10.9618 4.02014C11.4993 4.55418 11.8485 5.24923 11.9565 6ZM5 11H12.0101C12.5381 10.999 13.0442 10.7884 13.4176 10.4142C13.7919 10.0391 14.0021 9.53044 14.0021 9C14.0021 8.46957 13.7919 7.96086 13.4176 7.58579C13.0434 7.21072 12.5357 7 12.0064 7H11.0924L10.9687 6.143C10.8938 5.60541 10.6456 5.10711 10.2618 4.72407C9.87801 4.34103 9.37977 4.09427 8.84303 4.02143C8.30629 3.94859 7.76051 4.05365 7.2889 4.3206C6.81729 4.58754 6.44573 5.00173 6.23087 5.5L5.89759 6.262L5.08933 6.073C4.90382 6.02699 4.71364 6.0025 4.52255 6C3.86093 6 3.22641 6.2634 2.75858 6.73224C2.29075 7.20108 2.02792 7.83696 2.02792 8.5C2.02792 9.16304 2.29075 9.79893 2.75858 10.2678C3.22641 10.7366 3.86093 11 4.52255 11L5 11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/code.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.708 5.578L2.061 8.224L4.708 10.87L4 11.578L1 8.578V7.87L4 4.87L4.708 5.578ZM11.708 4.87L11 5.578L13.647 8.224L11 10.87L11.708 11.578L14.708 8.578V7.87L11.708 4.87ZM4.908 13L5.802 13.448L10.802 3.448L9.908 3L4.908 13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/collapse-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 9H4V10H9V9Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 3L6 2H13L14 3V10L13 11H11V13L10 14H3L2 13V6L3 5H5V3ZM6 5H10L11 6V10H13V3H6V5ZM10 6H3V13H10V6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/color-mode.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 1C6.61553 1 5.26216 1.41054 4.11101 2.17971C2.95987 2.94888 2.06266 4.04213 1.53285 5.32122C1.00303 6.6003 0.86441 8.00777 1.13451 9.36563C1.4046 10.7235 2.07129 11.9708 3.05026 12.9497C4.02922 13.9287 5.2765 14.5954 6.63437 14.8655C7.99224 15.1356 9.3997 14.997 10.6788 14.4672C11.9579 13.9373 13.0511 13.0401 13.8203 11.889C14.5895 10.7378 15 9.38447 15 8C15 6.14348 14.2625 4.36301 12.9497 3.05025C11.637 1.7375 9.85652 1 8 1V1ZM8 14V2C9.5913 2 11.1174 2.63214 12.2426 3.75736C13.3679 4.88258 14 6.4087 14 8C14 9.5913 13.3679 11.1174 12.2426 12.2426C11.1174 13.3679 9.5913 14 8 14V14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/comment-discussion-quote.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V11.5L14.5 12H7.71L4.85 14.85L4 14.5V12H1.5L1 11.5V1.5L1.5 1ZM7.5 11H14V2H2V11H4.5L5 11.5V13.29L7.15 11.15L7.5 11ZM13 4H3V5H13V4ZM3 6H13V7H3V6ZM10 8H3V9H10V8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/comment-discussion.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 11.29L5 10.29V11.71L3.85 12.85L3 12.5V10H1.5L1 9.5V1.5L1.5 1H13.5L14 1.5V6H13V2H2V9H3.5L4 9.5V11.29ZM10.29 13L12.15 14.85L13 14.5V13H14.5L15 12.5V7.5L14.5 7H6.5L6 7.5V12.5L6.5 13H10.29ZM10.5 12H7V8H14V12H12.5L12 12.5V13.29L10.85 12.15L10.5 12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/comment.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5 2H1.5L1 2.5V11.5L1.5 12H4V14.5L4.854 14.854L7.707 12H14.5L15 11.5V2.5L14.5 2ZM14 11H7.5L7.146 11.146L5 13.293V11.5L4.5 11H2V3H14V11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/console.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 1H15V15H1V1ZM2 14H14V2H2V14ZM4.00008 5.70709L4.70718 4.99999L8.24272 8.53552L7.53561 9.24263L7.53558 9.2426L4.70711 12.0711L4 11.364L6.82848 8.53549L4.00008 5.70709Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/credit-card.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 5V6H2V5H14ZM2 7H14V12H2V7ZM14 4H2C1.73478 4 1.48043 4.10536 1.29289 4.29289C1.10536 4.48043 1 4.73478 1 5V12C1 12.2652 1.10536 12.5196 1.29289 12.7071C1.48043 12.8946 1.73478 13 2 13H14C14.2652 13 14.5196 12.8946 14.7071 12.7071C14.8946 12.5196 15 12.2652 15 12V5C15 4.73478 14.8946 4.48043 14.7071 4.29289C14.5196 4.10536 14.2652 4 14 4ZM11 10H13V11H11V10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/dash.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="5" y="8" width="6" height="1" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/dashboard.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.8888 2.09545C4.95772 1.38122 6.21442 1 7.5 1C9.22391 1 10.8772 1.68482 12.0962 2.90381C13.3152 4.12279 14 5.77609 14 7.5C14 8.78558 13.6188 10.0423 12.9046 11.1112C12.1903 12.1801 11.1752 13.0132 9.98744 13.5052C8.79973 13.9972 7.49279 14.1259 6.23192 13.8751C4.97104 13.6243 3.81285 13.0052 2.90381 12.0962C1.99477 11.1872 1.3757 10.029 1.1249 8.76809C0.874095 7.50721 1.00282 6.20028 1.49479 5.01256C1.98676 3.82484 2.81988 2.80968 3.8888 2.09545ZM4.44437 12.0731C5.34884 12.6774 6.41221 13 7.5 13C8.95821 12.9984 10.3562 12.4184 11.3873 11.3873C12.4184 10.3562 12.9984 8.9582 13 7.5C13 6.4122 12.6774 5.34883 12.0731 4.44436C11.4687 3.53989 10.6098 2.83494 9.60476 2.41866C8.59977 2.00238 7.4939 1.89346 6.42701 2.10568C5.36011 2.3179 4.3801 2.84172 3.61092 3.61091C2.84173 4.3801 2.3179 5.36011 2.10568 6.427C1.89347 7.4939 2.00238 8.59977 2.41867 9.60476C2.83495 10.6098 3.5399 11.4687 4.44437 12.0731ZM10.2932 4L11.0002 4.707L8.85018 6.857C9.00536 7.17915 9.0415 7.54583 8.95221 7.89208C8.86291 8.23833 8.65395 8.5418 8.36233 8.74874C8.07071 8.95567 7.71526 9.05271 7.35895 9.02266C7.00264 8.99261 6.66846 8.83742 6.41561 8.58457C6.16276 8.33173 6.00757 7.99755 5.97752 7.64123C5.94748 7.28492 6.04452 6.92947 6.25145 6.63785C6.45838 6.34623 6.76185 6.13727 7.1081 6.04798C7.45435 5.95868 7.82103 5.99483 8.14318 6.15L10.2932 4ZM7.2224 7.91573C7.30462 7.97068 7.40129 8 7.50018 8C7.63279 8 7.75997 7.94732 7.85374 7.85355C7.9475 7.75979 8.00018 7.63261 8.00018 7.5C8.00018 7.40111 7.97086 7.30444 7.91592 7.22221C7.86098 7.13999 7.78289 7.0759 7.69152 7.03806C7.60016 7.00022 7.49963 6.99031 7.40264 7.00961C7.30565 7.0289 7.21656 7.07652 7.14663 7.14645C7.0767 7.21637 7.02908 7.30546 7.00979 7.40245C6.9905 7.49945 7.0004 7.59998 7.03824 7.69134C7.07609 7.7827 7.14017 7.86079 7.2224 7.91573ZM11.508 5.46704L10.745 6.23004C10.9111 6.63296 10.9977 7.06422 11 7.50004C10.9972 8.1267 10.8244 8.74086 10.5 9.27704L11.235 10.012C11.683 9.34822 11.9447 8.57638 11.9929 7.77698C12.0411 6.97757 11.874 6.17988 11.509 5.46704H11.508ZM8.73285 4.24196C8.34063 4.08478 7.92238 4.00269 7.49985 3.99996C6.57159 3.99996 5.68135 4.36871 5.02497 5.02509C4.3686 5.68147 3.99985 6.57171 3.99985 7.49996C4.00266 8.12663 4.17547 8.74078 4.49985 9.27696L3.76585 10.012C3.2135 9.18819 2.94877 8.20502 3.01281 7.21528C3.07686 6.22554 3.46609 5.28468 4.12 4.53897C4.77391 3.79326 5.65587 3.28446 6.62876 3.09169C7.60166 2.89891 8.61099 3.03295 9.49985 3.47296L8.73285 4.24196Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/database.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13 3.5C13 2.119 10.761 1 8 1C5.239 1 3 2.119 3 3.5C3 3.54 3.02 3.577 3.024 3.617H3V12.489L3.056 12.846C3.336 14.056 5.429 15 8 15C10.571 15 12.664 14.056 12.944 12.846L13 12.489V3.617H12.976C12.98 3.577 13 3.54 13 3.5ZM8 2.032C10.442 2.032 12 2.996 12 3.5C12 4.004 10.442 4.968 8 4.968C5.558 4.968 4 4 4 3.5C4 3 5.558 2.032 8 2.032ZM12 12.49L11.97 12.621C11.855 13.116 10.431 14 8 14C5.569 14 4.145 13.116 4.03 12.621L4 12.49V4.99C5.21092 5.69833 6.59796 6.04855 8 6C9.40243 6.04734 10.7895 5.69572 12 4.986V12.486V12.49Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/debug-alt-small.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.29333 9.00631L6.41333 9.88552C6.27949 9.34717 5.96917 8.86905 5.53181 8.52735C5.09445 8.18564 4.55521 8 4 8C3.44479 8 2.90555 8.18564 2.46819 8.52735C2.03083 8.86905 1.72051 9.34717 1.58667 9.88552L0.706667 9.00631L0 9.71234L1.14667 10.858L1 11.0045V12.0036H0V13.0027H1V13.056C1.051 13.3815 1.14283 13.6993 1.27333 14.0018L0 15.294L0.706667 16L1.80667 14.901C2.06838 15.2346 2.40078 15.5062 2.78001 15.6962C3.15924 15.8862 3.57587 15.99 4 16C4.42413 15.99 4.84076 15.8862 5.21999 15.6962C5.59922 15.5062 5.93162 15.2346 6.19333 14.901L7.29333 16L8 15.294L6.72667 14.0018C6.85879 13.6929 6.95065 13.3683 7 13.036V12.9694H8V12.0036H7V11.0045L6.85333 10.858L8 9.71234L7.29333 9.00631ZM4 9.00631C4.39782 9.00631 4.77936 9.16421 5.06066 9.44526C5.34196 9.72631 5.5 10.1075 5.5 10.505H2.5C2.5 10.1075 2.65804 9.72631 2.93934 9.44526C3.22064 9.16421 3.60218 9.00631 4 9.00631ZM6 13.0027C5.95116 13.5161 5.72476 13.9965 5.35974 14.3612C4.99472 14.7259 4.5139 14.9521 4 15.0009C3.4861 14.9521 3.00528 14.7259 2.64026 14.3612C2.27524 13.9965 2.04884 13.5161 2 13.0027V11.5041H6V13.0027Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 7V2L14.9146 8.24024L9 12.3805V11.1655L13.1809 8.24024L6.995 3.91209V7H6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/debug-alt.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.94 13.5L9.62 14.82C9.41924 14.0117 8.95376 13.2939 8.29772 12.7809C7.64168 12.2679 6.83282 11.9892 6 11.9892C5.16718 11.9892 4.35832 12.2679 3.70228 12.7809C3.04624 13.2939 2.58076 14.0117 2.38 14.82L1.06 13.5L0 14.56L1.72 16.28L1.5 16.5V18H0V19.5H1.5V19.58C1.5765 20.0687 1.71425 20.5458 1.91 21L0 22.94L1.06 24L2.71 22.35C3.10257 22.8509 3.60118 23.2586 4.17002 23.5438C4.73885 23.8291 5.36381 23.9849 6 24C6.63619 23.9849 7.26115 23.8291 7.82998 23.5438C8.39882 23.2586 8.89743 22.8509 9.29 22.35L10.94 24L12 22.94L10.09 21C10.2882 20.5362 10.426 20.0489 10.5 19.55V19.45H12V18H10.5V16.5L10.28 16.28L12 14.56L10.94 13.5ZM6 13.5C6.59674 13.5 7.16903 13.7371 7.59099 14.159C8.01295 14.581 8.25 15.1533 8.25 15.75H3.75C3.75 15.1533 3.98705 14.581 4.40901 14.159C4.83097 13.7371 5.40326 13.5 6 13.5V13.5ZM9 19.5C8.92674 20.2709 8.58713 20.9921 8.0396 21.5396C7.49207 22.0871 6.77085 22.4267 6 22.5C5.22915 22.4267 4.50793 22.0871 3.9604 21.5396C3.41287 20.9921 3.07326 20.2709 3 19.5V17.25H9V19.5ZM23.76 9.6V10.86L13.5 17.37V15.6L22 10.23L9 2V11.46C8.54306 11.139 8.03624 10.8958 7.5 10.74V0.63L8.64 0L23.76 9.6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/debug-breakpoint-conditional-unverified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.77772 4.67407C6.43551 4.23455 7.20888 4 8.00001 4C9.06087 4 10.0783 4.42149 10.8284 5.17163C11.5786 5.92178 12 6.93913 12 8C12 8.79113 11.7654 9.56449 11.3259 10.2223C10.8863 10.8801 10.2617 11.3928 9.53077 11.6956C8.79986 11.9983 7.9956 12.0774 7.21967 11.9231C6.44375 11.7688 5.73099 11.3878 5.17158 10.8284C4.61217 10.269 4.23119 9.55632 4.07685 8.7804C3.92251 8.00447 4.00176 7.20014 4.30451 6.46924C4.60726 5.73833 5.11992 5.1136 5.77772 4.67407ZM6.47218 10.2865C6.92441 10.5887 7.45611 10.75 8.00001 10.75C8.72935 10.75 9.4288 10.4603 9.94453 9.94458C10.4603 9.42885 10.75 8.72935 10.75 8C10.75 7.4561 10.5887 6.9244 10.2866 6.47217C9.98439 6.01993 9.55487 5.66749 9.05238 5.45935C8.54988 5.25121 7.99696 5.19675 7.46351 5.30286C6.93006 5.40897 6.44008 5.67083 6.05549 6.05542C5.67089 6.44001 5.40897 6.93005 5.30286 7.4635C5.19675 7.99695 5.25122 8.54987 5.45936 9.05237C5.6675 9.55486 6.01994 9.98432 6.47218 10.2865ZM9.5 6.5H6.5V7.5H9.5V6.5ZM9.5 8.5H6.5V9.5H9.5V8.5Z" fill="#848484"/>
</svg>

```

`src/vsicons/debug-breakpoint-conditional.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 4C5.79086 4 4 5.79086 4 8C4 10.2091 5.79086 12 8 12C10.2091 12 12 10.2091 12 8C12 5.79086 10.2091 4 8 4ZM10 9L10 10L6 10L6 9L10 9ZM10 6L10 7L6 7L6 6L10 6Z" fill="#E51400"/>
</svg>

```

`src/vsicons/debug-breakpoint-data-unverified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.93146 4H5.31146L3.00146 8L5.31146 12H9.93146L12.2415 8L9.93146 4ZM9.18146 10.7H6.06147L4.50147 8L6.06147 5.30005H9.18146L10.7415 8L9.18146 10.7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/debug-breakpoint-data.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.2376 7.99988L9.9282 11.9999H5.3094L3 7.99988L5.3094 3.99988H9.9282L12.2376 7.99988Z" fill="#E51400"/>
</svg>

```

`src/vsicons/debug-breakpoint-function-unverified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 11H12L8 4L4 11ZM6.15397 9.75H9.84603L8 6.51946L6.15397 9.75Z" fill="#848484"/>
</svg>

```

`src/vsicons/debug-breakpoint-function.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 4L12 10.9048H4L8 4Z" fill="#E51400"/>
</svg>

```

`src/vsicons/debug-breakpoint-log-unverified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.02039 7.97961L8 3L12.9796 7.97961L8 12.9592L3.02039 7.97961ZM8 10.7696L10.79 7.97961L8 5.18956L5.20996 7.97961L8 10.7696Z" fill="#848484"/>
</svg>

```

`src/vsicons/debug-breakpoint-log.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 3L13 8L8 13L3 8L8 3Z" fill="#E51400"/>
</svg>

```

`src/vsicons/debug-breakpoint-stackframe-active.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.99999 7.99988C9.99999 8.39544 9.88272 8.78206 9.66295 9.11096C9.44319 9.43986 9.13082 9.69628 8.76537 9.84766C8.39992 9.99903 7.99781 10.0386 7.60985 9.96143C7.22189 9.88426 6.86551 9.69377 6.5858 9.41406C6.3061 9.13436 6.11561 8.77798 6.03844 8.39001C5.96127 8.00205 6.00084 7.59995 6.15221 7.2345C6.30359 6.86904 6.56001 6.55668 6.88891 6.33691C7.2178 6.11715 7.60443 5.99988 7.99999 5.99988C8.53042 5.99988 9.0391 6.21062 9.41417 6.58569C9.78925 6.96077 9.99999 7.46944 9.99999 7.99988Z" fill="#E51400"/>
<path d="M14.5 7.1499L10.24 2.40991L9.31006 1.99988H4.25L3 3.24988V12.7299L4.25 13.9799H9.31006L10.24 13.5599L14.5 8.81982V7.1499ZM9.31006 12.7299H4.25V3.24988H9.31006L13.5699 7.97986L9.31006 12.7299Z" fill="#FFCC00"/>
</svg>

```

`src/vsicons/debug-breakpoint-stackframe-dot.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.99999 7.99988C9.99999 8.39544 9.88272 8.78206 9.66295 9.11096C9.44319 9.43986 9.13082 9.69628 8.76537 9.84766C8.39992 9.99903 7.99781 10.0386 7.60985 9.96143C7.22189 9.88426 6.86551 9.69377 6.5858 9.41406C6.3061 9.13436 6.11561 8.77798 6.03844 8.39001C5.96127 8.00205 6.00084 7.59995 6.15221 7.2345C6.30359 6.86904 6.56001 6.55668 6.88891 6.33691C7.2178 6.11715 7.60443 5.99988 7.99999 5.99988C8.53042 5.99988 9.0391 6.21062 9.41417 6.58569C9.78925 6.96077 9.99999 7.46944 9.99999 7.99988Z" fill="#E51400"/>
</svg>

```

`src/vsicons/debug-breakpoint-stackframe.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5 7.1499L10.24 2.40991L9.31006 1.99988H4.25L3 3.24988V12.7299L4.25 13.9799H9.31006L10.24 13.5599L14.5 8.81982V7.1499ZM9.31006 12.7299H4.25V3.24988H9.31006L13.5699 7.97986L9.31006 12.7299Z" fill="#FFCC00"/>
</svg>

```

`src/vsicons/debug-breakpoint-unsupported.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.3259 10.2222C11.7654 9.56436 12 8.791 12 7.99988C12.0001 7.47455 11.8968 6.95435 11.6958 6.46898C11.4948 5.98362 11.2002 5.5426 10.8287 5.17114C10.4573 4.79968 10.0163 4.50505 9.5309 4.30408C9.04553 4.10311 8.52533 3.99974 8 3.99988C7.20888 3.99988 6.43552 4.23447 5.77772 4.674C5.11992 5.11353 4.60723 5.73824 4.30448 6.46914C4.00173 7.20005 3.92252 8.00431 4.07686 8.78024C4.2312 9.55616 4.61216 10.2689 5.17157 10.8283C5.73098 11.3877 6.44372 11.7687 7.21964 11.923C7.99556 12.0774 8.79983 11.9981 9.53073 11.6954C10.2616 11.3926 10.8864 10.88 11.3259 10.2222ZM8.65 9.99988H7.4V10.9999H8.65V9.99988ZM7.4 8.99988V4.99988H8.65V8.99988H7.4Z" fill="#E51400"/>
</svg>

```

`src/vsicons/debug-console.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.03966 1.36109L7.17856 1.30356H21.3214L21.4603 1.36109L22.6389 2.53966L22.6964 2.67856V16.8214L22.6389 16.9603L21.4603 18.1389L21.3214 18.1964H14V18C14 17.4674 13.7918 16.9834 13.4524 16.625H21.125V2.87499H7.37499V10.1566C6.92794 10.0461 6.46642 9.98917 6 9.98917C5.93441 9.98917 5.86892 9.99029 5.80356 9.99253V2.67856L5.86109 2.53966L7.03966 1.36109ZM16.571 10.8132L13.7622 13.6131C13.6719 13.4452 13.5559 13.2875 13.4142 13.1458L12.9953 12.7269L15.231 10.4912L11.6246 6.79677L12.4381 5.9643L16.571 10.0972V10.8132ZM9.62 14.82L10.94 13.5L12 14.56L10.28 16.28L10.5 16.5V18H12V19.45H10.5V19.55C10.426 20.0489 10.2882 20.5362 10.09 21L12 22.94L10.94 24L9.29 22.35C8.89743 22.8509 8.39882 23.2586 7.82998 23.5438C7.26115 23.8291 6.63619 23.9849 6 24C5.36381 23.9849 4.73885 23.8291 4.17002 23.5438C3.60118 23.2586 3.10257 22.8509 2.71 22.35L1.06 24L0 22.94L1.91 21C1.71425 20.5458 1.5765 20.0687 1.5 19.58V19.5H0V18H1.5V16.5L1.72 16.28L0 14.56L1.06 13.5L2.38 14.82C2.58076 14.0117 3.04624 13.2939 3.70228 12.7809C4.35832 12.2679 5.16718 11.9892 6 11.9892C6.83282 11.9892 7.64168 12.2679 8.29772 12.7809C8.95376 13.2939 9.41924 14.0117 9.62 14.82ZM7.59099 14.159C7.16903 13.7371 6.59674 13.5 6 13.5C5.40326 13.5 4.83097 13.7371 4.40901 14.159C3.98705 14.581 3.75 15.1533 3.75 15.75H8.25C8.25 15.1533 8.01295 14.581 7.59099 14.159ZM8.0396 21.5396C8.58713 20.9921 8.92674 20.2709 9 19.5V17.25H3V19.5C3.07326 20.2709 3.41287 20.9921 3.9604 21.5396C4.50793 22.0871 5.22915 22.4267 6 22.5C6.77085 22.4267 7.49207 22.0871 8.0396 21.5396Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/debug-continue.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 2H4V2.24001L4 14L2.5 14L2.5 2ZM6 2.18094V14L15 8.06218L6 2.18094ZM12.3148 8.06218L7.50023 5L7.50023 11.1809L12.3148 8.06218Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-disconnect.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.6172 3.84363C13.5169 3.52917 13.3665 3.23979 13.166 2.97546L14.5195 1.61511L13.9043 0.999878L12.5439 2.35339C12.2796 2.15287 11.9902 2.00248 11.6758 1.90222C11.3659 1.7974 11.0446 1.745 10.7119 1.745C10.3063 1.745 9.91439 1.82247 9.53613 1.97742C9.16243 2.13236 8.83203 2.35339 8.54492 2.6405L7 4.19226L11.3271 8.51941L12.8789 6.97449C13.166 6.68738 13.387 6.35697 13.542 5.98328C13.6969 5.60502 13.7744 5.21309 13.7744 4.8075C13.7744 4.47481 13.722 4.15352 13.6172 3.84363ZM12.7285 5.64832C12.6191 5.91264 12.4619 6.14734 12.2568 6.35242L11.3271 7.2821L8.2373 4.19226L9.16699 3.26257C9.37207 3.0575 9.60677 2.90027 9.87109 2.79089C10.14 2.67696 10.4202 2.62 10.7119 2.62C11.0127 2.62 11.2952 2.67924 11.5596 2.79773C11.8239 2.91166 12.054 3.06889 12.25 3.26941C12.4505 3.46537 12.6077 3.69552 12.7217 3.95984C12.8402 4.22416 12.8994 4.50671 12.8994 4.8075C12.8994 5.09916 12.8424 5.37944 12.7285 5.64832ZM7.9043 10.6415L9.3877 9.09656L8.77246 8.47449L7.28223 10.0262L5.42285 8.16687L6.91309 6.61511L6.29102 5.99988L4.80762 7.5448L4.19238 6.92957L2.64062 8.47449C2.35352 8.7616 2.13249 9.09428 1.97754 9.47253C1.82259 9.84623 1.74512 10.2359 1.74512 10.6415C1.74512 10.9742 1.79525 11.2977 1.89551 11.6122C2.00033 11.9221 2.15299 12.2092 2.35352 12.4735L1 13.8339L1.61523 14.4491L2.97559 13.0956C3.23991 13.2961 3.52702 13.4488 3.83691 13.5536C4.15137 13.6538 4.47493 13.704 4.80762 13.704C5.21322 13.704 5.60286 13.6265 5.97656 13.4716C6.35482 13.3166 6.6875 13.0956 6.97461 12.8085L8.51953 11.2567L7.9043 10.6415ZM5.6416 12.6649C5.37728 12.7743 5.09928 12.829 4.80762 12.829C4.50684 12.829 4.22201 12.772 3.95312 12.6581C3.6888 12.5441 3.45638 12.3892 3.25586 12.1932C3.0599 11.9927 2.90495 11.7603 2.79102 11.496C2.67708 11.2271 2.62012 10.9423 2.62012 10.6415C2.62012 10.3498 2.6748 10.0718 2.78418 9.8075C2.89811 9.53861 3.05762 9.30164 3.2627 9.09656L4.19238 8.16687L7.28223 11.2567L6.35254 12.1864C6.14746 12.3915 5.91048 12.551 5.6416 12.6649Z" fill="#F48771"/>
</svg>

```

`src/vsicons/debug-pause.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.5 2.99988L6 2.99988V12.9999H4.5V2.99988ZM11.5 2.99988V12.9999H10V2.99988L11.5 2.99988Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-restart-frame.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 9.99988V8.99988H6.20703C6.11588 9.32216 6.05337 9.65647 6.02242 9.99988H1ZM7.25716 6.99988C7.57052 6.62045 7.93379 6.28376 8.33692 5.99988H1V6.99988H7.25716ZM6.59971 12.9999C6.43777 12.6831 6.30564 12.3485 6.20703 11.9999H1V12.9999H6.59971ZM15 2.99988V3.99988H1V2.99988H15ZM11.6406 13.0311C13.0386 13.0311 14.1719 11.8978 14.1719 10.4999C14.1719 9.10191 13.0386 7.96863 11.6406 7.96863C10.7037 7.96863 9.88567 8.47766 9.44801 9.23425H10.5156V10.078H8.54688L8.125 9.65613V7.40613H8.96875V8.43764C9.58599 7.6391 10.5533 7.12488 11.6406 7.12488C13.5046 7.12488 15.0156 8.63592 15.0156 10.4999C15.0156 12.3638 13.5046 13.8749 11.6406 13.8749C10.2564 13.8749 9.06689 13.0416 8.54621 11.8493L9.32848 11.5316C9.72341 12.4153 10.6101 13.0311 11.6406 13.0311Z" fill="#89D185"/>
</svg>

```

`src/vsicons/debug-restart.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.75 7.99988C12.75 10.4852 10.7353 12.4999 8.24999 12.4999C6.41795 12.4999 4.84162 11.4051 4.13953 9.83404L2.74882 10.3989C3.67446 12.5185 5.78923 13.9999 8.24999 13.9999C11.5637 13.9999 14.25 11.3136 14.25 7.99988C14.25 4.68617 11.5637 1.99988 8.24999 1.99988C6.3169 1.99988 4.59732 2.91406 3.5 4.33367V2.49988H2V6.49988L2.75 7.24988H6.25V5.74988H4.35201C5.13008 4.40482 6.58436 3.49988 8.24999 3.49988C10.7353 3.49988 12.75 5.5146 12.75 7.99988Z" fill="#89D185"/>
</svg>

```

`src/vsicons/debug-reverse-continue.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 2H12V2.24001L12 14L13.5 14L13.5 2ZM10 2.18094V14L0.999998 8.06218L10 2.18094ZM3.68522 8.06218L8.49976 5L8.49976 11.1809L3.68522 8.06218Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-start.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 2V13.8199L13 7.88L4 2ZM5.5 4.81995L10.3101 7.88L5.5 11V4.81995Z" fill="#89D185"/>
</svg>

```

`src/vsicons/debug-step-back.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.74997 5.75V1.75H3.24997V4.2916C4.39497 2.93303 6.16095 2.08334 8.0908 2.08334C11.2668 2.08334 14.0105 4.39036 14.2492 7.48075L14.27 7.75H12.7689L12.7471 7.5241C12.5345 5.32932 10.5449 3.58334 8.0908 3.58334C6.35474 3.58334 4.84714 4.45925 4.04121 5.75H6.87008V7.25H2.70796L1.74648 6.27493V5.75H1.74997ZM7.99997 14C6.8954 14 5.99997 13.1046 5.99997 12C5.99997 10.8954 6.8954 10 7.99997 10C9.10454 10 9.99997 10.8954 9.99997 12C9.99997 13.1046 9.10454 14 7.99997 14Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-step-into.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.99998 9.532H8.54198L12.447 5.627L11.386 4.567L8.74898 7.177L8.74898 1H7.99998H7.25098L7.25098 7.177L4.61398 4.567L3.55298 5.627L7.45798 9.532H7.99998ZM9.95598 13.013C9.95598 14.1176 9.06055 15.013 7.95598 15.013C6.85141 15.013 5.95598 14.1176 5.95598 13.013C5.95598 11.9084 6.85141 11.013 7.95598 11.013C9.06055 11.013 9.95598 11.9084 9.95598 13.013Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-step-out.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.99998 1H7.45798L3.55298 4.905L4.61398 5.965L7.25098 3.355V9.532H7.99998H8.74898V3.355L11.386 5.965L12.447 4.905L8.54198 1H7.99998ZM9.95598 13.013C9.95598 14.1176 9.06055 15.013 7.95598 15.013C6.85141 15.013 5.95598 14.1176 5.95598 13.013C5.95598 11.9084 6.85141 11.013 7.95598 11.013C9.06055 11.013 9.95598 11.9084 9.95598 13.013Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-step-over.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 5.75V1.75H12.75V4.2916C11.605 2.93303 9.83899 2.08334 7.90914 2.08334C4.73316 2.08334 1.98941 4.39036 1.75072 7.48075L1.72992 7.75H3.231L3.25287 7.5241C3.46541 5.32932 5.45509 3.58334 7.90914 3.58334C9.6452 3.58334 11.1528 4.45925 11.9587 5.75H9.12986V7.25H13.292L14.2535 6.27493V5.75H14.25ZM7.99997 14C9.10454 14 9.99997 13.1046 9.99997 12C9.99997 10.8954 9.10454 10 7.99997 10C6.8954 10 5.99997 10.8954 5.99997 12C5.99997 13.1046 6.8954 14 7.99997 14Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/debug-stop.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2 2V14H14V2H2ZM12.75 12.75H3.25V3.25H12.75V12.75Z" fill="#F48771"/>
</svg>

```

`src/vsicons/debug.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.46279 12.86L3.45815 12.79C3.45964 12.8134 3.46119 12.8367 3.46279 12.86Z" fill="#C5C5C5"/>
<path d="M10.7275 13.5509L7.69304 10.501L8.70723 9.4868L11.9159 12.7117L15.0789 9.54875L16.0931 10.5629L13.0589 13.5972L16.0934 16.647L15.0792 17.6612L11.8705 14.4362L8.70748 17.5993L7.69329 16.5851L10.7275 13.5509Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.9329 5.00286V6H18.2784L21.1205 3.15788L22.1347 4.17207L19.4435 6.86321L19.476 6.94805C20.0424 8.42597 20.3614 10.094 20.3614 11.86C20.3614 12.1955 20.3499 12.5274 20.3274 12.8552L20.3222 12.93H23.8629V14.3643H20.142L20.1315 14.4217C19.8292 16.075 19.2409 17.5825 18.4398 18.851L18.3802 18.9454L21.8027 22.3852L20.7859 23.3968L17.512 20.1063L17.4131 20.2169C15.934 21.8712 14.0177 22.8629 11.93 22.8629C9.81001 22.8629 7.86653 21.8402 6.37842 20.1395L6.27988 20.0268L3.07125 23.2355L2.05706 22.2213L5.42258 18.8558L5.36431 18.7615C4.59172 17.5118 4.02373 16.0363 3.72847 14.4217L3.71797 14.3643H0V12.93H3.53777L3.53262 12.8552C3.51009 12.5274 3.49858 12.1955 3.49858 11.86C3.49858 10.117 3.80935 8.46951 4.36194 7.00599L4.39377 6.92168L1.63228 4.14621L2.64904 3.13457L5.50003 6H6.92715V5.00286C6.92715 2.23986 9.16701 0 11.93 0C14.693 0 16.9329 2.23986 16.9329 5.00286ZM8.36144 5.00286V6H15.4986V5.00286C15.4986 3.03199 13.9009 1.43429 11.93 1.43429C9.95914 1.43429 8.36144 3.03199 8.36144 5.00286ZM18.1609 7.52498L18.1267 7.43429H5.73328L5.69915 7.52498C5.21331 8.81605 4.93286 10.2859 4.93286 11.86C4.93286 14.6199 5.7951 17.061 7.11691 18.7793C8.43755 20.4962 10.1529 21.4286 11.93 21.4286C13.7072 21.4286 15.4225 20.4962 16.7431 18.7793C18.0649 17.061 18.9271 14.6199 18.9271 11.86C18.9271 10.2859 18.6467 8.81605 18.1609 7.52498Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/desktop-download.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 15V14C6 14 6 13.4 6 13H1.5L1 12.5V2.5L1.5 2H14.5L15 2.5V11.74L14 10.74V3H2V12H7.73L7.23 12.5L9.73 15H4ZM11.86 15L14.36 12.5L13.65 11.8L12 13.45V7H11V13.44L9.35999 11.79L8.64999 12.5L11.15 15H11.86Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/device-camera-video.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.25 4.74L11 6.62V4.5L10.5 4H1.5L1 4.5V11.5L1.5 12H10.5L11 11.5V9.5L14.25 11.37L15 10.9V5.18L14.25 4.74ZM10 11H2V5H10V11ZM14 10L11 8.3V7.78L14 6V10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/device-camera.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.707 3H14.5L15 3.5V12.5L14.5 13H1.5L1 12.5V3.5L1.5 3H5.293L6.146 2.146L6.5 2H9.5L9.854 2.146L10.707 3ZM2 12H14V4H10.5L10.146 3.854L9.293 3H6.707L5.854 3.854L5.5 4H2V12ZM3.5 5C3.40111 5 3.30444 5.02932 3.22222 5.08427C3.13999 5.13921 3.0759 5.2173 3.03806 5.30866C3.00022 5.40002 2.99031 5.50055 3.00961 5.59755C3.0289 5.69454 3.07652 5.78363 3.14645 5.85355C3.21637 5.92348 3.30546 5.9711 3.40246 5.99039C3.49945 6.00969 3.59998 5.99978 3.69134 5.96194C3.78271 5.9241 3.86079 5.86001 3.91574 5.77779C3.97068 5.69556 4 5.59889 4 5.5C4 5.36739 3.94732 5.24021 3.85355 5.14645C3.75979 5.05268 3.63261 5 3.5 5ZM8 6C8.39556 6 8.78224 6.1173 9.11114 6.33706C9.44004 6.55682 9.69639 6.86918 9.84776 7.23463C9.99914 7.60009 10.0387 8.00222 9.96157 8.39018C9.8844 8.77814 9.69392 9.13451 9.41421 9.41421C9.13451 9.69392 8.77814 9.8844 8.39018 9.96157C8.00222 10.0387 7.60009 9.99913 7.23463 9.84776C6.86918 9.69638 6.55683 9.44004 6.33706 9.11114C6.1173 8.78224 6 8.39556 6 8C6 7.46957 6.21071 6.96086 6.58579 6.58579C6.96086 6.21071 7.46957 6 8 6ZM8 5C7.40666 5 6.82664 5.17595 6.33329 5.50559C5.83994 5.83524 5.45543 6.30377 5.22836 6.85195C5.0013 7.40013 4.94189 8.00333 5.05765 8.58527C5.1734 9.16721 5.45912 9.70176 5.87868 10.1213C6.29824 10.5409 6.83279 10.8266 7.41473 10.9424C7.99667 11.0581 8.59987 10.9987 9.14805 10.7716C9.69623 10.5446 10.1648 10.1601 10.4944 9.66671C10.8241 9.17336 11 8.59334 11 8C11 7.20435 10.6839 6.44129 10.1213 5.87868C9.55871 5.31607 8.79565 5 8 5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/device-mobile.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 1H12.5L13 1.5V14.5L12.5 15H4.5L4 14.5V1.5L4.5 1ZM5 14H12V2H5V14ZM7.5 12H9.5V13H7.5V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/diff-added.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H13.5L14 1.5V13.5L13.5 14H1.5L1 13.5V1.5L1.5 1ZM2 13H13V2H2V13Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 4H7V7H4V8H7V11H8V8H11V7H8V4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/diff-ignored.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V14.5L14.5 15H1.5L1 14.5V1.5L1.5 1ZM2 14H14V2H2V14ZM10 4H12V6L6 12H4V10L10 4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/diff-modified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V14.5L14.5 15H1.5L1 14.5V1.5L1.5 1ZM2 2V14H14V2H2ZM8 11C9.65685 11 11 9.65685 11 8C11 6.34315 9.65685 5 8 5C6.34315 5 5 6.34315 5 8C5 9.65685 6.34315 11 8 11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/diff-removed.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 7L10 8L5 8L5 7L10 7Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H13.5L14 1.5V13.5L13.5 14H1.5L1 13.5V1.5L1.5 1ZM2 13H13V2H2V13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/diff-renamed.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V14.5L14.5 15H1.5L1 14.5V1.5L1.5 1ZM2 14H14V2H2V14ZM4 9H7V12L12 8L7 4V7H4V9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/diff.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 3.5L2.5 3H7.5L8 3.5V12.5L7.5 13H2.5L2 12.5V3.5ZM3 12H7V6H3V12ZM3 5H7V4H3V5ZM9.5 3H14.5L15 3.5V12.5L14.5 13H9.5L9 12.5V3.5L9.5 3ZM10 12H14V10H10V12ZM10 8H14V4H10V8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/discard.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.5 2V5.5L4 6H7.5V5H4.979L5.92041 4.05869C7.30762 2.67157 9.55664 2.67157 10.9434 4.05869C12.3306 5.4458 12.3306 7.69476 10.9434 9.08188L5.74561 14.2799L6.46582 14.9999L11.6636 9.80194C13.4482 8.01715 13.4482 5.12341 11.6636 3.33859C9.87891 1.5538 6.98486 1.5538 5.2002 3.33859L4.5 4.03882V2H3.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/edit.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.23 1H11.77L3.52002 9.25L3.35999 9.46997L1 13.59L2.41003 15L6.53003 12.64L6.75 12.48L15 4.22998V2.77002L13.23 1ZM2.41003 13.59L3.92004 10.59L5.37 12.04L2.41003 13.59ZM6.23999 11.53L4.46997 9.76001L12.47 1.76001L14.24 3.53003L6.23999 11.53Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/editor-layout.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15 6.49999L14.5302 5.99999H7V1.4698L6.5302 1H1.4698L1 1.4698V9.53019L1.4698 9.99999H4V14.5302L4.4698 15H14.5302L15 14.5302V6.49999ZM2 8.99999V3H6V8.99999H2ZM14 14H5V9.99999H6.5302L7 9.53019V8.01341H14V14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/ellipsis.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 8C4 8.19778 3.94135 8.39112 3.83147 8.55557C3.72159 8.72002 3.56541 8.84819 3.38268 8.92388C3.19996 8.99957 2.99889 9.01937 2.80491 8.98079C2.61093 8.9422 2.43275 8.84696 2.29289 8.70711C2.15304 8.56725 2.0578 8.38907 2.01922 8.19509C1.98063 8.00111 2.00043 7.80004 2.07612 7.61732C2.15181 7.43459 2.27998 7.27841 2.44443 7.16853C2.60888 7.05865 2.80222 7 3 7C3.26522 7 3.51957 7.10536 3.70711 7.29289C3.89464 7.48043 4 7.73478 4 8Z" fill="#C5C5C5"/>
<path d="M9 8C9 8.19778 8.94135 8.39112 8.83147 8.55557C8.72159 8.72002 8.56541 8.84819 8.38268 8.92388C8.19996 8.99957 7.99889 9.01937 7.80491 8.98079C7.61093 8.9422 7.43275 8.84696 7.29289 8.70711C7.15304 8.56725 7.0578 8.38907 7.01922 8.19509C6.98063 8.00111 7.00043 7.80004 7.07612 7.61732C7.15181 7.43459 7.27998 7.27841 7.44443 7.16853C7.60888 7.05865 7.80222 7 8 7C8.26522 7 8.51957 7.10536 8.70711 7.29289C8.89464 7.48043 9 7.73478 9 8Z" fill="#C5C5C5"/>
<path d="M14 8C14 8.19778 13.9414 8.39112 13.8315 8.55557C13.7216 8.72002 13.5654 8.84819 13.3827 8.92388C13.2 8.99957 12.9989 9.01937 12.8049 8.98079C12.6109 8.9422 12.4327 8.84696 12.2929 8.70711C12.153 8.56725 12.0578 8.38907 12.0192 8.19509C11.9806 8.00111 12.0004 7.80004 12.0761 7.61732C12.1518 7.43459 12.28 7.27841 12.4444 7.16853C12.6089 7.05865 12.8022 7 13 7C13.2652 7 13.5196 7.10536 13.7071 7.29289C13.8946 7.48043 14 7.73478 14 8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/empty-window.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 4H7V5H4V8H3V5H0V4H3V1H4V4ZM1 14.5V9H2V14H14V7H8V6H14V4H8V3H14H14.5L15 3.5V14.5L14.5 15H1.5L1 14.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/error.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.59975 0.999985C10.1998 1.09999 11.6998 1.89999 12.7998 2.99999C14.0998 4.39999 14.7998 6.09999 14.7998 8.09999C14.7998 9.69999 14.1998 11.2 13.1998 12.5C12.1998 13.7 10.7998 14.6 9.19975 14.9C7.59975 15.2 5.99975 15 4.59975 14.2C3.19975 13.4 2.09975 12.2 1.49975 10.7C0.899753 9.19999 0.799753 7.49999 1.29975 5.99999C1.79975 4.39999 2.69975 3.09999 4.09975 2.19999C5.39975 1.29999 6.99975 0.899985 8.59975 0.999985ZM9.09975 13.9C10.3998 13.6 11.5998 12.9 12.4998 11.8C13.2998 10.7 13.7998 9.39999 13.6998 7.99999C13.6998 6.39999 13.0998 4.79999 11.9998 3.69999C10.9998 2.69999 9.79975 2.09999 8.39975 1.99999C7.09975 1.89999 5.69975 2.19999 4.59975 2.99999C3.49975 3.79999 2.69975 4.89999 2.29975 6.29999C1.89975 7.59999 1.89975 8.99999 2.49975 10.3C3.09975 11.6 3.99975 12.6 5.19975 13.3C6.39975 14 7.79975 14.2 9.09975 13.9ZM7.89974 7.5L10.2997 5L10.9997 5.7L8.59974 8.2L10.9997 10.7L10.2997 11.4L7.89974 8.9L5.49974 11.4L4.79974 10.7L7.19974 8.2L4.79974 5.7L5.49974 5L7.89974 7.5Z" fill="#F48771"/>
</svg>

```

`src/vsicons/exclude.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.41155 1L6.58845 1.00002L6.10395 3.42254L4.04837 2.05215L2.05214 4.04839L3.42252 6.10396L1 6.58846V9.41156L3.42253 9.89606L2.05214 11.9516L4.04838 13.9479L6.10395 12.5775L6.58845 15H8.67134C8.31745 14.7136 8.00787 14.3747 7.75447 13.9951H7.41231L7.12404 12.5537C7.09769 12.4439 7.07537 12.3325 7.05724 12.2197L6.94068 11.6369L6.17738 11.3207L4.17643 12.6547L3.34531 11.8236L4.67929 9.82263L4.36309 9.05932L2.00495 8.5877V7.41232L4.36309 6.94069L4.67928 6.17739L3.34531 4.17643L4.17642 3.34532L6.17737 4.67928L6.94069 4.36313L7.41231 2.00497L8.58769 2.00496L9.05931 4.36311L9.82263 4.67927L11.8236 3.3453L12.6547 4.17642L11.3207 6.17737L11.6369 6.94069L12.2194 7.05719C12.3324 7.07535 12.444 7.09771 12.554 7.12411L13.995 7.41232V7.75447C14.3747 8.00786 14.7136 8.31745 15 8.67133V6.58846L12.5775 6.10396L13.9479 4.04837L11.9516 2.05214L9.89605 3.42252L9.41155 1ZM8 6C8.8592 6 9.59185 6.54179 9.87496 7.30237C9.55558 7.42609 9.25385 7.58522 8.97457 7.77493C8.87247 7.33103 8.47489 7 8 7C7.44772 7 7 7.44772 7 8C7 8.47489 7.33103 8.87247 7.77493 8.97457C7.58522 9.25385 7.42609 9.55558 7.30237 9.87496C6.54179 9.59185 6 8.8592 6 8C6 6.89543 6.89543 6 8 6ZM9.27944 8.79462C9.90534 8.28088 10.69 8.00006 11.4998 8C11.9594 7.99997 12.4145 8.09047 12.8392 8.26634C13.2639 8.44221 13.6497 8.7 13.9748 9.025C14.5474 9.59754 14.9037 10.3509 14.9831 11.1568C15.0625 11.9626 14.8601 12.771 14.4103 13.4443C13.9604 14.1176 13.2911 14.6141 12.5162 14.8492C11.7413 15.0843 10.9089 15.0435 10.1608 14.7337C9.41269 14.4238 8.79514 13.8642 8.41339 13.1501C8.03163 12.436 7.90929 11.6116 8.06721 10.8174C8.22513 10.0232 8.65354 9.30836 9.27944 8.79462ZM8.99975 11V12H13.9998V11H8.99975Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/expand-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 9H4V10H9V9Z" fill="#C5C5C5"/>
<path d="M7 12L7 7L6 7L6 12L7 12Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 3L6 2H13L14 3V10L13 11H11V13L10 14H3L2 13V6L3 5H5V3ZM6 5H10L11 6V10H13V3H6V5ZM10 6H3V13H10V6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/export.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.086 7L10.6953 4.60156L11.3984 3.89844L15 7.5L11.3984 11.1016L10.6953 10.3984L13.0781 8.01562L13.0785 8H3V7H13.086ZM1 4H2V11H1V4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/extensions.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 1.5L15 0H22.5L24 1.5V9L22.5 10.5H15L13.5 9V1.5ZM15 1.5V9H22.5V1.5H15ZM0 15V6L1.5 4.5H9L10.5 6V13.5H18L19.5 15V22.5L18 24H10.5H9H1.5L0 22.5V15ZM9 13.5V6H1.5V13.5H9ZM9 15H1.5V22.5H9V15ZM10.5 22.5H18V15H10.5V22.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/eye-closed.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 2C6.5 2 5.2 2.4 4.1 3.2L4.9 3.9C5.8 3.3 6.8 3 8 3C11.3 3 14 5.7 14 9H15C15 5.1 11.9 2 8 2ZM1 3.00005L2.6 4.50005C1.6 5.70005 1 7.30005 1 9.00005H2C2 7.50005 2.5 6.20005 3.4 5.20005L5.6 7.20005C5.2 7.70005 5 8.30005 5 9.00005C5 10.7 6.3 12 8 12C8.8 12 9.5 11.7 10 11.2L13 14L13.7 13.3L1.7 2.30005L1 3.00005ZM6.3 7.90005L9.2 10.6C8.9 10.8 8.5 11 8 11C6.9 11 6 10.1 6 9.00005C6 8.60005 6.1 8.20005 6.3 7.90005ZM11 9.5L10 8.6C9.8 7.8 9.1 7.1 8.2 7L7.2 6.1C7.5 6 7.7 6 8 6C9.7 6 11 7.3 11 9V9.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/eye.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 10C1 6.1 4.1 3 8 3C11.9 3 15 6.1 15 10H14C14 6.7 11.3 4 8 4C4.7 4 2 6.7 2 10H1ZM5 10C5 8.3 6.3 7 8 7C9.7 7 11 8.3 11 10C11 11.7 9.7 13 8 13C6.3 13 5 11.7 5 10ZM6 10C6 11.1 6.9 12 8 12C9.1 12 10 11.1 10 10C10 8.9 9.1 8 8 8C6.9 8 6 8.9 6 10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/feedback.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.54883 10.0781C8.00911 10.2604 8.42839 10.502 8.80664 10.8027C9.1849 11.1035 9.50846 11.4521 9.77734 11.8486C10.0462 12.2451 10.2536 12.6712 10.3994 13.127C10.5452 13.5827 10.6204 14.0612 10.625 14.5625V15H9.75V14.5625C9.75 14.0202 9.64746 13.5098 9.44238 13.0312C9.2373 12.5527 8.95475 12.1357 8.59473 11.7803C8.2347 11.4248 7.81771 11.1445 7.34375 10.9395C6.86979 10.7344 6.35938 10.6296 5.8125 10.625C5.27018 10.625 4.75977 10.7275 4.28125 10.9326C3.80273 11.1377 3.38574 11.4202 3.03027 11.7803C2.6748 12.1403 2.39453 12.5573 2.18945 13.0312C1.98438 13.5052 1.87956 14.0156 1.875 14.5625V15H1V14.5625C1 14.0658 1.07292 13.5872 1.21875 13.127C1.36458 12.6667 1.57422 12.2406 1.84766 11.8486C2.12109 11.4567 2.44466 11.1104 2.81836 10.8096C3.19206 10.5088 3.61133 10.265 4.07617 10.0781C3.87109 9.93685 3.68652 9.77279 3.52246 9.58594C3.3584 9.39909 3.2194 9.19857 3.10547 8.98438C2.99154 8.77018 2.90495 8.54232 2.8457 8.30078C2.78646 8.05924 2.75456 7.81315 2.75 7.5625C2.75 7.13867 2.82975 6.74219 2.98926 6.37305C3.14876 6.00391 3.36751 5.68034 3.64551 5.40234C3.9235 5.12435 4.24707 4.9056 4.61621 4.74609C4.98535 4.58659 5.38411 4.50456 5.8125 4.5C6.23633 4.5 6.63281 4.57975 7.00195 4.73926C7.37109 4.89876 7.69466 5.11751 7.97266 5.39551C8.25065 5.6735 8.4694 5.99707 8.62891 6.36621C8.78841 6.73535 8.87044 7.13411 8.875 7.5625C8.875 7.81315 8.84538 8.05697 8.78613 8.29395C8.72689 8.53092 8.63802 8.75879 8.51953 8.97754C8.40104 9.19629 8.26204 9.39909 8.10254 9.58594C7.94303 9.77279 7.75846 9.93685 7.54883 10.0781ZM5.8125 9.75C6.11328 9.75 6.39583 9.69303 6.66016 9.5791C6.92448 9.46517 7.15462 9.31022 7.35059 9.11426C7.54655 8.91829 7.70378 8.68587 7.82227 8.41699C7.94076 8.14811 8 7.86328 8 7.5625C8 7.26172 7.94303 6.97917 7.8291 6.71484C7.71517 6.45052 7.55794 6.22038 7.35742 6.02441C7.1569 5.82845 6.92448 5.67122 6.66016 5.55273C6.39583 5.43424 6.11328 5.375 5.8125 5.375C5.51172 5.375 5.22917 5.43197 4.96484 5.5459C4.70052 5.65983 4.4681 5.81706 4.26758 6.01758C4.06706 6.2181 3.90983 6.45052 3.7959 6.71484C3.68197 6.97917 3.625 7.26172 3.625 7.5625C3.625 7.86328 3.68197 8.14583 3.7959 8.41016C3.90983 8.67448 4.06478 8.9069 4.26074 9.10742C4.45671 9.30794 4.68913 9.46517 4.95801 9.5791C5.22689 9.69303 5.51172 9.75 5.8125 9.75ZM15 1V8H13.25L10.625 10.625V8H9.75V7.125H11.5V8.5127L12.8877 7.125H14.125V1.875H5.375V3.44727C5.22917 3.46549 5.08333 3.48828 4.9375 3.51562C4.79167 3.54297 4.64583 3.58398 4.5 3.63867V1H15Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-binary.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.57 1.14L13.85 4.44L14 4.8V14.5L13.5 15H2.5L2 14.5V1.5L2.5 1H10.22L10.57 1.14ZM3 2V14H13V5L10 2H3ZM4.45947 6.05176C4.45947 7.33903 4.91781 7.98267 5.83447 7.98267C6.29102 7.98267 6.64103 7.809 6.88452 7.46167C7.1298 7.11434 7.25244 6.61483 7.25244 5.96313C7.25244 4.65438 6.80485 4 5.90967 4C5.4388 4 5.07894 4.17546 4.83008 4.52637C4.58301 4.87549 4.45947 5.38395 4.45947 6.05176ZM5.32153 6.03027C5.32153 5.10824 5.50505 4.64722 5.87207 4.64722C6.21582 4.64722 6.3877 5.09481 6.3877 5.98999C6.3877 6.88517 6.21224 7.33276 5.86133 7.33276C5.50146 7.33276 5.32153 6.8986 5.32153 6.03027ZM8.50854 7.91553H10.9443V7.24414H10.1521V4L8.48706 4.33569V5.02319L9.30615 4.84595V7.24414H8.50854V7.91553ZM7.17188 12.9155H4.73608V12.2441H5.53369V9.84595L4.7146 10.0232V9.33569L6.37964 9V12.2441H7.17188V12.9155ZM8.20703 10.9846C8.20703 12.2719 8.66536 12.9155 9.58203 12.9155C10.0386 12.9155 10.3886 12.7419 10.6321 12.3945C10.8774 12.0472 11 11.5477 11 10.896C11 9.58724 10.5524 8.93286 9.65723 8.93286C9.18636 8.93286 8.8265 9.10832 8.57764 9.45923C8.33057 9.80835 8.20703 10.3168 8.20703 10.9846ZM9.06909 10.9631C9.06909 10.0411 9.2526 9.58008 9.61963 9.58008C9.96338 9.58008 10.1353 10.0277 10.1353 10.9229C10.1353 11.818 9.9598 12.2656 9.60889 12.2656C9.24902 12.2656 9.06909 11.8315 9.06909 10.9631Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-code.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.57 1.14L13.85 4.44L14 4.8V14.5L13.5 15H2.5L2 14.5V1.5L2.5 1H10.22L10.57 1.14ZM10 5H13L10 2V5ZM3 2V14H13V6H9.5L9 5.5V2H3ZM5.062 9.533L6.879 7.705L6.17 7L4 9.179V9.886L6.171 12.06L6.878 11.353L5.062 9.533ZM8.8 7.714L9.5 7.005L11.689 9.18V9.889L9.5 12.062L8.795 11.353L10.626 9.533L8.8 7.714Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-media.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 2H8V5.5L8.5 6H12V7H13V4.8L12.85 4.44L9.57 1.14L9.22 1H1.5L1 1.5V14.5L1.5 15H5V14H2V2ZM9 2L12 5H9V2ZM14.5 8H6.5L6 8.5V14.5L6.5 15H14.5L15 14.5V8.5L14.5 8ZM14 9V13L12.37 11.4H11.66L10.5 12.57L8.37 10.44H7.66L7 11.1V9H14ZM11.2 13.27L12.01 12.46L13.55 14H11.93L11.2 13.27ZM7 14V12.51L8 11.51L10.52 14H7ZM12.5 10.5C12.7761 10.5 13 10.2761 13 10C13 9.72386 12.7761 9.5 12.5 9.5C12.2239 9.5 12 9.72386 12 10C12 10.2761 12.2239 10.5 12.5 10.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-pdf.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.85 4.44L10.57 1.14L10.22 1H2.5L2 1.5V7H3V2H9V5.5L9.5 6H13V7H14V4.8L13.85 4.44ZM10 5V2L13 5H10ZM2.5 8L2 8.5V14.5L2.5 15H13.5L14 14.5V8.5L13.5 8H2.5ZM13 13V14H3V9H13V13ZM5 12H4.68V13H4V10H5.06C5.81 10 6.19 10.36 6.19 11C6.19194 11.136 6.16433 11.2708 6.10908 11.3951C6.05383 11.5195 5.97226 11.6303 5.87 11.72C5.62218 11.9132 5.31397 12.0124 5 12ZM4.94 10.55H4.68V11.48H4.94C5.3 11.48 5.48 11.32 5.48 11.01C5.48 10.7 5.3 10.55 4.94 10.55ZM9 12.58C9.14768 12.4345 9.26317 12.2597 9.33896 12.0667C9.41476 11.8738 9.44918 11.6671 9.44 11.46C9.44 10.46 8.91 10 7.84 10H6.78V13H7.84C8.05153 13.0102 8.26298 12.9784 8.46211 12.9063C8.66123 12.8342 8.84406 12.7233 9 12.58ZM7.45 12.45V10.55H7.78C7.90754 10.5419 8.0354 10.5599 8.15576 10.6029C8.27612 10.6459 8.38644 10.7129 8.48 10.8C8.56476 10.889 8.6306 10.9943 8.67357 11.1094C8.71654 11.2246 8.73573 11.3472 8.73 11.47C8.74498 11.7336 8.65511 11.9924 8.48 12.19C8.38845 12.2776 8.28013 12.3458 8.16156 12.3905C8.04298 12.4352 7.9166 12.4554 7.79 12.45H7.45ZM11.9 11.84H10.93V13H10.25V10H11.99V10.55H10.93V11.29H11.9V11.84Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-submodule.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 11H3V6.99H2V11ZM3 5.99V5.5L3.5 5H7.93L8.36 5.25L8.79 6H13H14.5L15 6.5V14.5L14.5 15H3.5L3 14.5V12H1.5L1 11.5V2.5L1.5 2H5.92L6.36 2.25L6.79 3H12.5L13 3.5V6L12 5.97V4H6.5L6.07 3.75L5.64 3H2V5.99H3ZM8.07 6.75L7.64 6H4V9H7.15L7.56 8.26L8 8H14V7H8.5L8.07 6.75ZM7.45 10H4V14H14V9H8.3L7.89 9.74L7.45 10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-symlink-directory.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.71002 3H14.5L15.01 3.5V9V13.5L14.51 14H1.51001L1.01001 13.5V6.5V2.5L1.51001 2H6.51001L6.85999 2.15002L7.71002 3ZM13.99 13V11.49L14 7.48999V5.98999H7.70001L6.84003 6.84998L6.48999 7H2V7.48999V11.49V13H13.99ZM7.48999 5H13.99L14 4.01001H7.5L7.14001 3.85999L6.28998 3.01001H2V6.01001H6.28003L7.14001 5.15002L7.48999 5ZM9.78005 9.06995L8.42001 7.69995L9.16 7.01001L11.38 9.22998V9.93994L9.09005 12.15L8.39004 11.4301L9.79 10.08H8.42001C7.90851 10.103 7.42536 10.3213 7.07003 10.6899C6.89788 10.8612 6.76219 11.0656 6.6711 11.2908C6.58002 11.5159 6.5354 11.7572 6.54 12H5.54C5.53377 11.6293 5.60231 11.2612 5.74148 10.9176C5.88065 10.574 6.08758 10.2619 6.35 10C6.87439 9.44728 7.58943 9.11474 8.35 9.06995H9.78005Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-symlink-file.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.57 1.14L13.85 4.44L14 4.8V14.5L13.5 15H10V14H13V6H9.5L9 5.5V2H3V6H2V1.5L2.5 1H10.22L10.57 1.14ZM10 5H13L10 2V5ZM8.5 7H1.5L1 7.5V14.5L1.5 15H8.5L9 14.5V7.5L8.5 7ZM8 14H2V8H8V14ZM7 9.5V12.5H6V10.707L3.354 13.354L2.646 12.646L5.293 10H3.53V9H6.5L7 9.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file-zip.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 1H13.5L14 1.5V6.5L13.85 6.85L13 7.71V14.5L12.5 15H2.5L2 14.5V1.5L2.5 1ZM6 2H5V4H6V2ZM6 14H10V7.68L9.15 6.83L9 6.47V2H7V4.5L6.5 5H6V6H5V5H4.5L4 4.5V2H3V14H5V13H6V14ZM6 12V13H7V12H6ZM6 11V12H5V11H6ZM6 10H7V11H6V10ZM6 9V10H5V9H6ZM6 8H7V9H6V8ZM6 7V8H5V7H6ZM6 7H7V6H6V7ZM12.15 7.15L13 6.29V2H10V6.27L10.85 7.12L11 7.47V14H12V7.5L12.15 7.15Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/file.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.57 1.14L13.85 4.44L14 4.8V14.5L13.5 15H2.5L2 14.5V1.5L2.5 1H10.22L10.57 1.14ZM10 5H13L10 2V5ZM3 2V14H13V6H9.5L9 5.5V2H3ZM11 7H5V8H11V7ZM5 9H11V10H5V9ZM11 11H5V12H11V11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/files.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.5 0H8.5L7 1.5V6H2.5L1 7.5V22.5699L2.5 24H14.5699L16 22.5699V18H20.7L22 16.5699V4.5L17.5 0ZM17.5 2.12L19.88 4.5H17.5V2.12ZM14.5 22.5H2.5V7.5H7V16.5699L8.5 18H14.5V22.5ZM20.5 16.5H8.5V1.5H16V6H20.5V16.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/filter.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 2V3.66963L10 8.42874V14H6V8.42874L1 3.66963V2H15ZM7 8V13H9V8L14 3.24089V3H2V3.24089L7 8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/flame.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.12994 15L8.59994 14.23C8.88894 13.8519 9.0211 13.3769 8.96895 12.9039C8.9168 12.4308 8.68436 11.9961 8.31994 11.69C7.70737 11.1781 7.28762 10.4726 7.12994 9.69C5.56994 11.92 6.37994 13.15 7.12994 14.24L6.57994 15C5.53554 14.8032 4.59766 14.2351 3.93959 13.4005C3.28152 12.566 2.94775 11.5215 2.99994 10.46C2.99994 10.46 2.78994 8.3 5.27994 6.19C5.27994 6.19 8.09994 3.58 7.11994 1.65L7.82994 1C8.91313 1.75952 9.7418 2.82836 10.2075 4.06664C10.6732 5.30491 10.7542 6.65492 10.4399 7.94C10.6771 7.70862 10.8672 7.43357 10.9999 7.13L11.8699 7.06C11.9399 7.18 13.7099 9.99 12.7599 12.36C12.4216 13.0668 11.9126 13.6782 11.2788 14.1391C10.6451 14.6 9.9066 14.8959 9.12994 15V15ZM7.12994 8.05L7.99994 8.44C7.95356 8.89619 8.01237 9.35695 8.17186 9.78687C8.33134 10.2168 8.58726 10.6044 8.91994 10.92C9.34857 11.2323 9.67322 11.6664 9.85159 12.1658C10.03 12.6653 10.0538 13.2068 9.91994 13.72C10.3333 13.5752 10.713 13.3482 11.0361 13.0526C11.3593 12.7569 11.6191 12.3989 11.7999 12C12.1395 10.7826 11.9924 9.48096 11.3899 8.37C11.2006 8.67719 10.9254 8.92228 10.5985 9.07509C10.2716 9.22789 9.90709 9.28174 9.54994 9.23L9.19994 8.55C9.63797 7.60276 9.78716 6.54744 9.62887 5.5159C9.47058 4.48435 9.01183 3.52232 8.30994 2.75C8.16994 4.87 5.99994 6.83 5.92994 6.94C3.85994 8.7 3.99994 10.33 3.99994 10.4C3.96089 11.0176 4.08772 11.6344 4.36729 12.1865C4.64686 12.7387 5.06899 13.2059 5.58994 13.54C4.99994 12.14 4.99994 10.46 7.15994 8.05H7.12994Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/fold-down.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.207 1.707L13.5 1L7.49997 7L1.49997 1L0.792969 1.707L7.14597 8.061H7.85397L14.207 1.707ZM14.207 7.70688L13.5 6.99988L7.49997 12.9999L1.49997 6.99988L0.792969 7.70688L7.14597 14.0609H7.85397L14.207 7.70688Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/fold-up.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0.999756 7.4L1.69976 8.1L7.69976 2.1L13.6998 8.1L14.3998 7.4L8.09976 1H7.39976L0.999756 7.4ZM0.999756 13.4L1.69976 14.1L7.69976 8.1L13.6998 14.1L14.3998 13.4L8.09976 7H7.39976L0.999756 13.4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/fold.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.9516 2.38128L7.97554 6.35726L3.99951 2.38123L3.38079 2.99994L7.66618 7.28534H8.2849L12.5703 2.99999L11.9516 2.38128ZM3.90363 13.9999L7.97554 9.92804L12.0474 13.9999L12.6662 13.3812L8.2849 8.99996H7.66618L3.28491 13.3812L3.90363 13.9999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/folder-active.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.71014 3H14.5002L15.0102 3.5V8.00717C14.6997 7.77276 14.3611 7.57372 14.0002 7.41604V5.98999H7.69012L6.83014 6.84998L6.48016 7H1.99017V7.48999V11.49V13H7.1002C7.1708 13.3478 7.2775 13.6825 7.41623 14H1.51019L1.01019 13.5V6.5V2.5L1.51019 2H6.51019L6.86017 2.15002L7.71014 3ZM7.49017 5H13.9902L14.0002 4.01001H7.50018L7.1402 3.85999L6.29022 3.01001H2.00018V6.01001H6.28021L7.1402 5.15002L7.49017 5Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.7779 8.67412C10.4357 8.2346 11.2091 8 12.0002 8C13.0607 8.0013 14.0773 8.42315 14.8272 9.17301C15.577 9.92287 15.9989 10.9395 16.0002 12C16.0002 12.7911 15.7656 13.5645 15.3261 14.2223C14.8865 14.8801 14.2618 15.3928 13.5309 15.6955C12.8 15.9983 11.9957 16.0775 11.2198 15.9231C10.4439 15.7688 9.73117 15.3878 9.17176 14.8284C8.61235 14.269 8.23138 13.5563 8.07704 12.7804C7.9227 12.0044 8.00192 11.2002 8.30467 10.4693C8.60742 9.73836 9.12011 9.11365 9.7779 8.67412ZM11.9089 13.6637L14.2952 10.4818L13.4952 9.88184L11.4184 12.651L10.1167 11.6096L9.49197 12.3905L11.1965 13.7541L11.9089 13.6637Z" fill="#388A34"/>
</g>
<defs>
<clipPath id="clip0">
<rect width="16" height="16" fill="white" transform="translate(0.000183105)"/>
</clipPath>
</defs>
</svg>

```

`src/vsicons/folder-opened.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.5 14H12.5L12.98 13.63L15.61 6.63L15.13 6H14V3.5L13.5 3H7.70996L6.84998 2.15002L6.5 2H1.5L1 2.5V13.5L1.5 14ZM2 3H6.29004L7.15002 3.84998L7.5 4H13V6H8.5L8.15002 6.15002L7.29004 7H3.5L3.03003 7.33997L2.03003 10.42L2 3ZM12.13 13H2.18994L3.85999 8H7.5L7.84998 7.84998L8.70996 7H14.5L12.13 13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/folder.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5 3H7.70996L6.85999 2.15002L6.51001 2H1.51001L1.01001 2.5V6.5V13.5L1.51001 14H14.51L15.01 13.5V9V3.5L14.5 3ZM13.99 11.49V13H1.98999V11.49V7.48999V7H6.47998L6.82996 6.84998L7.68994 5.98999H14V7.48999L13.99 11.49ZM13.99 5H7.48999L7.14001 5.15002L6.28003 6.01001H2V3.01001H6.29004L7.14001 3.85999L7.5 4.01001H14L13.99 5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/gear.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.09976 4.4L8.59976 2H7.39976L6.89976 4.4L6.19976 4.7L4.19976 3.4L3.29976 4.2L4.59976 6.2L4.39976 6.9L1.99976 7.4V8.6L4.39976 9.1L4.69976 9.9L3.39976 11.9L4.19976 12.7L6.19976 11.4L6.99976 11.7L7.39976 14H8.59976L9.09976 11.6L9.89976 11.3L11.8998 12.6L12.6998 11.8L11.3998 9.8L11.6998 9L13.9998 8.6V7.4L11.5998 6.9L11.2998 6.1L12.5998 4.1L11.7998 3.3L9.79976 4.6L9.09976 4.4ZM9.39976 1L9.89976 3.4L11.9998 2.1L13.9998 4.1L12.5998 6.2L14.9998 6.6V9.4L12.5998 9.9L13.9998 12L11.9998 14L9.89976 12.6L9.39976 15H6.59976L6.09976 12.6L3.99976 13.9L1.99976 11.9L3.39976 9.8L0.999756 9.4V6.6L3.39976 6.1L2.09976 4L4.09976 2L6.19976 3.4L6.59976 1H9.39976ZM9.99976 8C9.99976 9.1 9.09976 10 7.99976 10C6.89976 10 5.99976 9.1 5.99976 8C5.99976 6.9 6.89976 6 7.99976 6C9.09976 6 9.99976 6.9 9.99976 8ZM7.99976 9C8.59976 9 8.99976 8.6 8.99976 8C8.99976 7.4 8.59976 7 7.99976 7C7.39976 7 6.99976 7.4 6.99976 8C6.99976 8.6 7.39976 9 7.99976 9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/gift.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.5 4H11.9C12 3.6 12 3.2 12 2.8C11.9 2.5 11.8 2.2 11.6 1.9C11.4 1.6 11.2 1.4 10.9 1.3C10.6 1.2 10.3 1 10 1C9.7 1 9.4 1 9.1 1.2C8.4 1.4 7.9 1.9 7.5 2.5C7.1 1.9 6.6 1.4 5.9 1.2C5.6 1.1 5.3 1 5 1C4.7 1 4.4 1.1 4.1 1.3C3.8 1.4 3.6 1.6 3.4 1.9C3.2 2.1 3.1 2.5 3 2.8C3 3.2 3 3.6 3.1 4H1.5L1 4.5V13.5L1.5 14H13.5L14 13.5V4.5L13.5 4ZM7 13H2V5H7V13ZM7 4H4C4 3.9 4 3.9 4 3.8C3.9 3.5 3.9 3.3 3.9 3C4 2.8 4 2.6 4.2 2.5C4.3 2.3 4.5 2.2 4.7 2.1C4.8 2 5 2 5.2 2C5.4 2 5.6 2 5.8 2.1C6.1 2.2 6.4 2.4 6.6 2.7C6.8 3 7 3.3 7 3.7V4ZM8 3.7C8 3.3 8.2 3 8.4 2.7C8.6 2.4 8.9 2.2 9.2 2.1C9.4 2 9.6 2 9.8 2C10 2 10.2 2 10.4 2.1C10.6 2.2 10.7 2.3 10.9 2.5C11 2.6 11 2.8 11.1 3C11.1 3.3 11.1 3.5 11 3.8C11 3.9 11 3.9 10.9 4H8V3.7ZM13 13H8V5H13V13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/gist-secret.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 14H7V14.91L7.09003 15H2.5L2 14.5V1.5L2.5 1H10.22L10.57 1.14001L13.85 4.43994L14 4.80005V7.33997C13.7411 6.95585 13.3994 6.63471 13 6.40002V6H9.5L9 5.5V2H3V14ZM13 5L10 2V5H13ZM13.5 9V10H14.5L15 10.5V14.5L14.5 15H8.5L8 14.5V10.5L8.5 10H9.5V9C9.5 8.46957 9.71074 7.96089 10.0858 7.58582C10.4609 7.21074 10.9696 7 11.5 7C12.0304 7 12.5391 7.21074 12.9142 7.58582C13.2893 7.96089 13.5 8.46957 13.5 9ZM10.7929 8.29285C10.6054 8.48038 10.5 8.73478 10.5 9V10H12.5V9C12.5 8.73478 12.3946 8.48038 12.2071 8.29285C12.0196 8.10531 11.7652 8 11.5 8C11.2348 8 10.9804 8.10531 10.7929 8.29285ZM9 11V14H14V11H9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/gist.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.57 1.14L13.85 4.44L14 4.8V14.5L13.5 15H2.5L2 14.5V1.5L2.5 1H10.22L10.57 1.14ZM10 5H13L10 2V5ZM3 2V14H13V6H9.5L9 5.5V2H3ZM5.062 9.533L6.879 7.705L6.17 7L4 9.179V9.886L6.171 12.06L6.878 11.353L5.062 9.533ZM8.8 7.714L9.5 7.005L11.689 9.18V9.889L9.5 12.062L8.795 11.353L10.626 9.533L8.8 7.714Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/git-commit.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.9788 5C10.443 4.45199 9.73865 4.09982 8.97876 4V0H7.97876V4C7.16572 4.12245 6.42174 4.52718 5.87729 5.14331C5.33284 5.75944 5.02267 6.54757 5.00119 7.36951C4.97972 8.19144 5.24832 8.99471 5.75986 9.63843C6.2714 10.2821 6.99323 10.7253 7.79877 10.89H7.97876V14.89H8.97876V10.89C9.26824 10.8535 9.55107 10.7761 9.81876 10.66C10.4607 10.399 11.0082 9.94912 11.3888 9.37C11.772 8.79546 11.9772 8.12068 11.9788 7.43005C11.9779 6.52007 11.6187 5.64698 10.9788 5V5ZM10.2788 9.23999C9.80838 9.70763 9.17204 9.97006 8.50876 9.96997C8.01463 9.9703 7.53148 9.82427 7.12034 9.55017C6.70919 9.27608 6.38851 8.8863 6.19877 8.43005C6.05515 8.08876 5.98945 7.71974 6.00647 7.34985C6.02349 6.97997 6.12281 6.61853 6.29715 6.29187C6.4715 5.96521 6.71649 5.68144 7.01432 5.46143C7.31214 5.24141 7.6553 5.09067 8.01877 5.02002C8.18177 5.00528 8.34576 5.00528 8.50876 5.02002C8.85172 5.01265 9.19241 5.07732 9.50876 5.20996C9.96501 5.39971 10.3548 5.72045 10.6289 6.13159C10.903 6.54273 11.0491 7.02589 11.0488 7.52002C11.0371 7.85 10.9604 8.17444 10.8231 8.47473C10.6858 8.77503 10.4907 9.04528 10.2488 9.27002L10.2788 9.23999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/git-compare.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.38893 12.9906L6.11891 11.7205L6.78893 11.0206L8.91893 13.1506V13.8505L6.78893 15.9805L6.07893 15.2706L7.34892 14.0006H5.49892C5.17024 14.0019 4.84458 13.9381 4.54067 13.8129C4.23675 13.6878 3.96061 13.5037 3.7282 13.2713C3.49579 13.0389 3.31171 12.7627 3.18654 12.4588C3.06137 12.1549 2.99759 11.8292 2.99892 11.5006V5.95052C2.5198 5.84851 2.07944 5.61279 1.72893 5.27059C1.3808 4.91884 1.14393 4.47238 1.0479 3.98689C0.951867 3.50141 1.00092 2.9984 1.18892 2.54061C1.37867 2.08436 1.69938 1.69458 2.11052 1.42049C2.52166 1.14639 3.00479 1.00024 3.49892 1.00057C3.84188 0.993194 4.18256 1.05787 4.49892 1.19051C4.80197 1.31518 5.07732 1.49871 5.30904 1.73042C5.54075 1.96214 5.72425 2.23755 5.84892 2.54061C5.98157 2.85696 6.0463 3.19765 6.03893 3.54061C6.03926 4.03474 5.89316 4.51789 5.61906 4.92903C5.34497 5.34017 4.95516 5.6608 4.49892 5.85054C4.35057 5.91224 4.19649 5.95915 4.03893 5.99056V11.4906C4.03893 11.8884 4.19695 12.2699 4.47826 12.5512C4.75956 12.8325 5.1411 12.9906 5.53893 12.9906H7.38893ZM2.70894 4.74056C2.95497 4.90376 3.24368 4.99072 3.53893 4.99056C3.81026 4.99066 4.07654 4.91718 4.3094 4.77791C4.54227 4.63864 4.73301 4.43877 4.86128 4.19966C4.98956 3.96056 5.05057 3.69116 5.03783 3.42012C5.02508 3.14908 4.93907 2.88661 4.78893 2.6606C4.62119 2.4121 4.38499 2.21751 4.10893 2.10054C3.83645 1.98955 3.53719 1.96176 3.24892 2.02059C2.95693 2.07705 2.68852 2.2196 2.47823 2.42989C2.26793 2.64018 2.12539 2.90853 2.06892 3.20052C2.0101 3.4888 2.03792 3.78802 2.14891 4.0605C2.26588 4.33656 2.46043 4.57282 2.70894 4.74056ZM13.0389 11.0406C13.5196 11.1384 13.9612 11.3747 14.309 11.7206C14.7766 12.191 15.039 12.8273 15.0389 13.4906C15.0393 13.9847 14.8932 14.4679 14.6191 14.879C14.345 15.2902 13.9552 15.6109 13.499 15.8007C13.0416 15.9915 12.5378 16.0421 12.0516 15.946C11.5654 15.85 11.1187 15.6117 10.7683 15.2612C10.4179 14.9108 10.1795 14.4641 10.0835 13.9779C9.98746 13.4917 10.0381 12.988 10.2289 12.5306C10.4218 12.0768 10.7412 11.688 11.1489 11.4106C11.4177 11.2286 11.7204 11.1028 12.0389 11.0406V5.4906C12.0389 5.09278 11.8809 4.71124 11.5996 4.42993C11.3183 4.14863 10.9368 3.9906 10.5389 3.9906H8.68896L9.95892 5.26062L9.24896 5.97058L7.11893 3.84058V3.14063L9.24896 1.01062L9.95892 1.72058L8.68896 2.9906H10.5389C10.8676 2.98928 11.1933 3.05305 11.4972 3.17822C11.8011 3.30339 12.0772 3.48744 12.3096 3.71985C12.542 3.95226 12.7262 4.22844 12.8513 4.53235C12.9765 4.83626 13.0403 5.16193 13.0389 5.4906V11.0406ZM12.6879 14.9829C13.0324 14.9483 13.3542 14.7956 13.5989 14.5507C13.8439 14.306 13.9966 13.984 14.0313 13.6395C14.0659 13.295 13.9803 12.9492 13.7889 12.6606C13.6212 12.4121 13.385 12.2176 13.1089 12.1006C12.8365 11.9896 12.5372 11.9618 12.249 12.0206C11.957 12.0771 11.6886 12.2196 11.4783 12.4299C11.268 12.6402 11.1254 12.9086 11.069 13.2006C11.0101 13.4888 11.0379 13.7881 11.1489 14.0605C11.2659 14.3366 11.4604 14.5729 11.7089 14.7406C11.9975 14.9319 12.3434 15.0175 12.6879 14.9829Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/git-merge.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.2729 7.73055C12.8025 7.26291 12.1661 7.00048 11.5028 7.00057C11.0087 7.00024 10.5256 7.14639 10.1144 7.42049C9.70327 7.69458 9.38259 8.08436 9.19284 8.54061C9.1345 8.68241 9.09093 8.8298 9.06284 8.98055C8.0405 8.86836 7.08702 8.41091 6.35977 7.68367C5.63253 6.95643 5.17502 6.00289 5.06284 4.98055C5.21358 4.95246 5.36103 4.90889 5.50284 4.85054C5.95909 4.6608 6.34886 4.34017 6.62296 3.92903C6.89705 3.51789 7.04315 3.03474 7.04282 2.54061C7.05019 2.19765 6.98546 1.85696 6.85282 1.54061C6.72814 1.23755 6.54468 0.962142 6.31296 0.730425C6.08124 0.498708 5.8059 0.31518 5.50284 0.190508C5.18648 0.0578651 4.8458 -0.00680644 4.50284 0.00056644C4.00871 0.000236947 3.52555 0.146394 3.11441 0.420488C2.70327 0.694583 2.38259 1.08436 2.19284 1.54061C2.00484 1.9984 1.95582 2.50141 2.05185 2.98689C2.14788 3.47238 2.38469 3.91884 2.73282 4.27059C3.08333 4.61279 3.52372 4.84851 4.00284 4.95052V10.0506C3.68429 10.1128 3.38155 10.2386 3.11283 10.4206C2.70505 10.6979 2.3857 11.0867 2.19284 11.5406C2.00197 11.998 1.95136 12.5017 2.0474 12.9879C2.14343 13.4741 2.38178 13.9208 2.73221 14.2712C3.08264 14.6216 3.52934 14.86 4.01554 14.956C4.50173 15.052 5.00551 15.0015 5.46286 14.8106C5.91911 14.6209 6.30889 14.3001 6.58298 13.889C6.85707 13.4779 7.00317 12.9947 7.00284 12.5006C7.01021 12.1576 6.94548 11.8169 6.81284 11.5006C6.68817 11.1975 6.5047 10.9222 6.27298 10.6905C6.04127 10.4588 5.76592 10.2753 5.46286 10.1506C5.31451 10.0889 5.16041 10.042 5.00284 10.0106V7.61055C5.51949 8.34075 6.20585 8.93443 7.00284 9.34053C7.65409 9.67397 8.36392 9.87772 9.09287 9.94051C9.16518 10.3031 9.31699 10.6452 9.53739 10.942C9.75778 11.2388 10.0413 11.483 10.3674 11.6571C10.6935 11.8311 11.0542 11.9307 11.4235 11.9486C11.7928 11.9665 12.1614 11.9023 12.5028 11.7606C12.9591 11.5708 13.3489 11.2501 13.623 10.8389C13.8971 10.4278 14.0431 9.94465 14.0428 9.45052C14.0193 8.79894 13.7432 8.18211 13.2729 7.73055V7.73055ZM5.07285 11.1106C5.3489 11.2275 5.5851 11.4221 5.75284 11.6706C5.94506 11.9591 6.03138 12.3052 5.99716 12.6502C5.96295 12.9952 5.8103 13.3178 5.56516 13.5629C5.32001 13.8081 4.99755 13.9607 4.65256 13.995C4.30757 14.0292 3.96134 13.9428 3.67282 13.7506C3.42432 13.5828 3.2298 13.3466 3.11283 13.0705C3.00184 12.798 2.97404 12.4988 3.03287 12.2105C3.08933 11.9185 3.23188 11.6502 3.44217 11.4399C3.65246 11.2296 3.92087 11.0871 4.21286 11.0306C4.50114 10.9718 4.80037 10.9996 5.07285 11.1106V11.1106ZM4.50284 4.00057C4.2076 4.00073 3.91886 3.91377 3.67282 3.75057C3.42432 3.58283 3.2298 3.34657 3.11283 3.07051C3.00184 2.79803 2.97404 2.49881 3.03287 2.21053C3.08933 1.91854 3.23188 1.65019 3.44217 1.4399C3.65246 1.22961 3.92087 1.08706 4.21286 1.0306C4.50114 0.971769 4.80037 0.999561 5.07285 1.11055C5.3489 1.22752 5.5851 1.42211 5.75284 1.67061C5.90298 1.89662 5.989 2.15909 6.00174 2.43013C6.01448 2.70117 5.9535 2.97057 5.82523 3.20967C5.69695 3.44878 5.50622 3.64865 5.27335 3.78792C5.04048 3.92719 4.77418 4.00067 4.50284 4.00057V4.00057ZM12.5628 10.5606C12.3181 10.8055 11.9963 10.9582 11.6518 10.9929C11.3073 11.0275 10.9614 10.9419 10.6728 10.7506C10.4243 10.5828 10.2298 10.3466 10.1128 10.0705C10.0018 9.79803 9.97404 9.49881 10.0329 9.21053C10.0893 8.91854 10.2319 8.65019 10.4422 8.4399C10.6525 8.22961 10.9209 8.08706 11.2129 8.0306C11.5011 7.97177 11.8004 7.99956 12.0728 8.11055C12.3489 8.22752 12.5851 8.42211 12.7528 8.67061C12.9442 8.95917 13.0298 9.30501 12.9951 9.64949C12.9605 9.99398 12.8078 10.3159 12.5628 10.5606V10.5606Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/git-pull-request.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.61588 4.92781C5.34298 5.33911 4.95312 5.66074 4.49699 5.84982C4.34885 5.91025 4.03891 5.98822 4.03891 5.98822V10.9959C4.1968 11.0271 4.3508 11.0739 4.49894 11.1363C4.95507 11.3273 5.34298 11.647 5.61783 12.0583C5.89073 12.4696 6.03693 12.953 6.03693 13.4462C6.04472 13.7893 5.9804 14.1304 5.84785 14.4462C5.72309 14.7483 5.53986 15.0232 5.30789 15.2551C5.07788 15.4871 4.80108 15.6703 4.49894 15.7951C4.18316 15.9276 3.84203 15.9919 3.49896 15.9842C3.00579 15.9861 2.52237 15.8399 2.11107 15.5651C1.69977 15.2922 1.37814 14.9023 1.18906 14.4462C1.00192 13.9881 0.953192 13.4852 1.04871 12.9998C1.14422 12.5144 1.38009 12.068 1.72901 11.7172C2.07793 11.3741 2.51847 11.1382 2.99799 11.0369V5.94923C2.52042 5.84592 2.07988 5.61201 1.72901 5.26893C1.38009 4.91806 1.14422 4.47168 1.04871 3.9863C0.951243 3.50093 0.999975 2.99802 1.18906 2.53993C1.37814 2.0838 1.69977 1.69394 2.11107 1.42105C2.52042 1.1462 3.00384 1 3.49896 1C3.84008 0.994152 4.18121 1.05848 4.49699 1.18908C4.79913 1.31383 5.07398 1.49707 5.30594 1.72903C5.53791 1.961 5.72114 2.2378 5.8459 2.53993C5.97845 2.85572 6.04277 3.19684 6.03498 3.53992C6.03693 4.03309 5.89073 4.51651 5.61588 4.92781ZM4.85956 12.7893C4.73091 12.5495 4.53988 12.3487 4.30791 12.2103C4.07595 12.07 3.80889 11.9959 3.53794 11.9998C3.24165 11.9998 2.95316 12.0856 2.70755 12.2493C2.45999 12.417 2.26506 12.6528 2.1481 12.9296C2.03699 13.2025 2.0097 13.5008 2.06818 13.7893C2.12471 14.0797 2.26701 14.3487 2.47753 14.5592C2.68806 14.7697 2.95511 14.912 3.2475 14.9686C3.53599 15.0271 3.83423 14.9998 4.10713 14.8887C4.38393 14.7717 4.6198 14.5768 4.78744 14.3292C4.93753 14.1031 5.0233 13.8399 5.03694 13.569C5.04864 13.298 4.98821 13.029 4.85956 12.7893ZM2.70755 4.74068C2.95511 4.90247 3.2436 4.99019 3.53794 4.99019C3.80889 4.99019 4.07595 4.91611 4.30791 4.77966C4.53988 4.63931 4.73091 4.44049 4.85956 4.20073C4.98821 3.96096 5.05059 3.69196 5.03694 3.42101C5.0233 3.15006 4.93753 2.88691 4.78744 2.66079C4.6198 2.41323 4.38393 2.2183 4.10713 2.10135C3.83423 1.99024 3.53599 1.96295 3.2475 2.02142C2.95706 2.07795 2.68806 2.22025 2.47753 2.43077C2.26701 2.6413 2.12471 2.90835 2.06818 3.20074C2.0097 3.48924 2.03699 3.78748 2.1481 4.06038C2.26506 4.33718 2.45999 4.57304 2.70755 4.74068ZM13.0368 11.0369C13.5163 11.1344 13.9588 11.3722 14.3058 11.7172C14.7716 12.187 15.0348 12.8244 15.0309 13.4832C15.0328 13.9764 14.8866 14.4598 14.6118 14.8711C14.3389 15.2824 13.949 15.6041 13.4929 15.7931C13.0368 15.9842 12.5319 16.0349 12.0465 15.9393C11.5612 15.8438 11.1148 15.606 10.7639 15.2551C10.415 14.9043 10.1752 14.4579 10.0797 13.9725C9.98419 13.4871 10.0349 12.9842 10.2259 12.5261C10.4189 12.0739 10.7386 11.684 11.146 11.4073C11.413 11.224 11.7171 11.0993 12.0348 11.0369V5.48922C12.0348 5.09157 11.8769 4.70951 11.5962 4.42881C11.3155 4.14811 10.9335 3.99022 10.5358 3.99022H8.68597L9.95495 5.25921L9.24541 5.96875L7.11679 3.84013V3.14033L9.24736 1.00977L9.9569 1.72125L8.68791 2.99024H10.5378C10.8653 2.98829 11.1908 3.05262 11.4949 3.17737C11.799 3.30212 12.0758 3.48731 12.3077 3.71927C12.5397 3.95124 12.7249 4.22803 12.8496 4.53212C12.9744 4.83426 13.0387 5.15979 13.0368 5.48922V11.0369ZM13.5943 14.5456C13.8399 14.3019 13.9919 13.9803 14.027 13.6353C14.0621 13.2922 13.9763 12.9452 13.7853 12.6567C13.6177 12.4092 13.3818 12.2143 13.105 12.0973C12.8321 11.9862 12.5339 11.9589 12.2454 12.0174C11.9549 12.0739 11.6859 12.2162 11.4754 12.4267C11.2649 12.6372 11.1226 12.9043 11.066 13.1967C11.0076 13.4852 11.0349 13.7834 11.146 14.0563C11.2629 14.3331 11.4578 14.569 11.7054 14.7366C11.9939 14.9277 12.3389 15.0134 12.6839 14.9783C13.027 14.9433 13.3506 14.7912 13.5943 14.5456Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/github-action.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.04004 10H5.62004L6.27004 11H2.54004L2.04004 10.5V1.5L2.54004 1H14.54L15.04 1.5V6.27L14.04 4.52V2H3.04004V10ZM8.58004 11L7.17004 14.47H9.37004L15 8.7L14.27 7H12.64L13.46 5.54L12.63 4H9.76004L8.84004 4.59L6.56004 9.59L7.47004 11H8.58004ZM9.76004 5H12.63L10.76 8H14.27L8.51004 13.84L10.2 10H7.47004L9.76004 5ZM6.95004 7H4.04004V6H7.40004L6.95004 7ZM6.05004 9H4.04004V8H6.50004L6.05004 9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/github-inverted.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.97553 0C3.57186 0 0 3.57186 0 7.97553C0 11.4985 2.29969 14.4832 5.43119 15.5596C5.82263 15.6086 5.96942 15.3639 5.96942 15.1682C5.96942 14.9725 5.96942 14.4832 5.96942 13.7982C3.76758 14.2875 3.27829 12.7217 3.27829 12.7217C2.93578 11.792 2.39755 11.5474 2.39755 11.5474C1.66361 11.0581 2.44648 11.0581 2.44648 11.0581C3.22936 11.107 3.66972 11.8899 3.66972 11.8899C4.40367 13.1131 5.52905 12.7706 5.96942 12.5749C6.01835 12.0367 6.263 11.6942 6.45872 11.4985C4.69725 11.3028 2.83792 10.6177 2.83792 7.53517C2.83792 6.65443 3.1315 5.96942 3.66972 5.38226C3.62079 5.23547 3.32722 4.40367 3.76758 3.32722C3.76758 3.32722 4.4526 3.1315 5.96942 4.15902C6.6055 3.9633 7.29052 3.91437 7.97553 3.91437C8.66055 3.91437 9.34557 4.01223 9.98165 4.15902C11.4985 3.1315 12.1835 3.32722 12.1835 3.32722C12.6239 4.40367 12.3303 5.23547 12.2813 5.43119C12.7706 5.96942 13.1131 6.70336 13.1131 7.5841C13.1131 10.6667 11.2538 11.3028 9.49235 11.4985C9.78593 11.7431 10.0306 12.2324 10.0306 12.9664C10.0306 14.0428 10.0306 14.8746 10.0306 15.1682C10.0306 15.3639 10.1774 15.6086 10.5688 15.5596C13.7492 14.4832 16 11.4985 16 7.97553C15.9511 3.57186 12.3792 0 7.97553 0Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/globe.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.5 1C9.78557 1 11.0423 1.38123 12.1112 2.09546C13.1801 2.80969 14.0132 3.82483 14.5052 5.01257C14.8972 5.95898 15.0586 6.98108 14.9811 7.99524C14.8962 9.10645 14.5267 10.1801 13.9046 11.1112C13.1903 12.1802 12.1752 13.0133 10.9874 13.5052C9.79973 13.9972 8.4928 14.126 7.23192 13.8751C5.97104 13.6243 4.81285 13.0052 3.90381 12.0962C2.99476 11.1871 2.3757 10.0289 2.12489 8.76807C1.8741 7.5072 2.00282 6.20032 2.49478 5.01257C2.98675 3.82483 3.81987 2.80969 4.88879 2.09546C5.95772 1.38123 7.21443 1 8.5 1ZM13.394 5C12.7527 3.75281 11.6613 2.79626 10.3412 2.32373C10.7845 3.16357 11.106 4.0647 11.294 5H13.394ZM13.9765 7.99524C13.9918 7.83081 13.9997 7.66553 14 7.5C13.999 6.99255 13.9273 6.48767 13.787 6H11.445C11.477 6.33105 11.5 6.66406 11.5 7C11.4997 7.12598 11.4971 7.25195 11.4921 7.37769C11.4917 7.38623 11.4914 7.39417 11.4911 7.40271C11.4834 7.58289 11.4709 7.76331 11.4536 7.94263C11.4192 8.29749 11.366 8.65039 11.294 9H13.787C13.8815 8.67139 13.9449 8.33496 13.9765 7.99524ZM10.4408 7.99524C10.4428 7.97815 10.4447 7.96106 10.4466 7.94397C10.4808 7.63074 10.4987 7.31567 10.5 7C10.4933 6.66553 10.4679 6.33167 10.424 6H6.576C6.53207 6.33167 6.5067 6.66553 6.5 7C6.50274 7.67334 6.5809 8.34412 6.733 9H10.267C10.3439 8.66833 10.4019 8.33289 10.4408 7.99524ZM10.249 5C10.1607 4.60352 10.0465 4.21399 9.90597 3.83447C9.67117 3.2019 9.36551 2.59644 8.994 2.03003C8.83 2.01599 8.666 2 8.5 2C8.39551 2 8.29182 2.00635 8.18843 2.01453C8.12755 2.01929 8.06677 2.02478 8.00599 2.03003L8 2.03918C7.40887 2.94299 6.98573 3.9458 6.75101 5H10.249ZM5.70601 5C5.89779 4.0647 6.22313 3.16174 6.672 2.31897C5.34599 2.78979 4.24946 3.74866 3.606 5H5.70601ZM3.213 6C3.07269 6.48767 3.00101 6.99255 3 7.5C3.00101 8.00745 3.07269 8.51233 3.213 9H5.70601C5.57043 8.34192 5.50142 7.67188 5.5 7C5.5 6.66406 5.52301 6.33105 5.55501 6H3.213ZM5.96701 10H3.60701C3.98501 10.7384 4.52472 11.382 5.18594 11.8829C5.84715 12.3838 6.61285 12.729 7.42601 12.8931C6.78598 12.0142 6.2932 11.0371 5.96701 10ZM8.5 12.644C9.13943 11.8531 9.63927 10.959 9.97799 10H7.022C7.36075 10.959 7.86058 11.8531 8.5 12.644ZM11.033 10C10.7068 11.0371 10.214 12.0142 9.574 12.8931C10.3872 12.729 11.1528 12.3838 11.8141 11.8829C12.4753 11.382 13.015 10.7384 13.393 10H11.033Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/go-to-file.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 5.9142L8.06065 3.85356L8.06065 3.14645L5.91421 1L5.2071 1.70711L5.25 1.75L5.24998 1.75002L5.49997 2H5.5L6.49999 3H3.5C2.83696 3 2.20107 3.2634 1.73223 3.73224C1.26339 4.20108 1 4.83696 1 5.5C1 6.16305 1.26339 6.79893 1.73223 7.26777C2.20107 7.73661 2.83696 8 3.5 8H4V7H3.5C3.10218 7 2.72064 6.84197 2.43934 6.56066C2.15804 6.27936 2 5.89783 2 5.5C2 5.10218 2.15804 4.72065 2.43934 4.43934C2.72064 4.15804 3.10218 4 3.5 4H5V4.00003H5.49996L5.49999 4H6.49999L5.2071 5.29289L5.20711 5.29291L5.2071 5.29292L5.91421 6.00003L6 5.91423V5.9142ZM11 2H8.32838L7.32839 1H12L12.71 1.29L15.71 4.29L16 5V14L15 15H6L5 14V9.00003V6.50003L6 7.34699V14H15V6H11V2ZM12 2V5H15L12 2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/grabber.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 6H1V7H15V6ZM15 9H1V10H15V9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/graph-left.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.1187 4.00003L2.99999 4.88131L2.38127 5.50003L0.7146 3.83336V3.21464L2.38127 1.54797L2.99999 2.16669L2.16665 3.00003H15V4.00003H2.1187ZM3.99999 14.5455V5.45457L4.49999 5.00003H6.49999L6.99999 5.45457V14.5455L6.49999 15H4.49999L3.99999 14.5455ZM5.99999 14.0909V5.90912H4.99999V14.0909H5.99999ZM7.99999 12.5556V5.44447L8.49999 5.00003H10.5L11 5.44447V12.5556L10.5 13H8.49999L7.99999 12.5556ZM9.99999 12.1111V5.88892H8.99999V12.1111H9.99999ZM12 5.4286V10.5715L12.5 11H14.5L15 10.5715V5.4286L14.5 5.00003H12.5L12 5.4286ZM14 5.85717V10.1429H13V5.85717H14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/graph.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 14H15V13H2V0H1V13.5L1.5 14ZM3 11.5V3.5L3.5 3H5.5L6 3.5V11.5L5.5 12H3.5L3 11.5ZM5 11V4H4V11H5ZM11 1.5V11.5L11.5 12H13.5L14 11.5V1.5L13.5 1H11.5L11 1.5ZM13 2V11H12V2H13ZM7 11.5V5.5L7.5 5H9.5L10 5.5V11.5L9.5 12H7.5L7 11.5ZM9 11V6H8V11H9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/gripper.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="5" y="3" width="2" height="2" fill="#C5C5C5"/>
<rect x="5" y="7" width="2" height="2" fill="#C5C5C5"/>
<rect x="5" y="11" width="2" height="2" fill="#C5C5C5"/>
<rect x="9" y="3" width="2" height="2" fill="#C5C5C5"/>
<rect x="9" y="7" width="2" height="2" fill="#C5C5C5"/>
<rect x="9" y="11" width="2" height="2" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/group-by-ref-type.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H3.5V2H2V14H3.5V15H1.5L1 14.5V1.5L1.5 1ZM14 3V7H10V6H8V7H5V4H8V5H10V3H14ZM7 5H6V6H7V5ZM13 4H11V6H13V4ZM10 9H14V13H10V11H8V12H5V9H8V10H10V9ZM7 10H6V11H7V10ZM11 12H13V10H11V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/heart.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.88 4.78006C14.7993 4.46425 14.6747 4.16128 14.51 3.88003C14.3517 3.58746 14.1493 3.32097 13.9099 3.08999C13.5629 2.74413 13.152 2.46909 12.7 2.28006C11.7901 1.90665 10.7698 1.90665 9.85993 2.28006C9.4327 2.4609 9.04021 2.71468 8.69996 3.03006L8.64997 3.08999L7.99995 3.74002L7.34992 3.08999L7.29994 3.03006C6.95969 2.71468 6.5672 2.4609 6.13996 2.28006C5.23012 1.90665 4.20978 1.90665 3.29994 2.28006C2.84792 2.46909 2.437 2.74413 2.08998 3.08999C1.85045 3.32329 1.64508 3.58929 1.47996 3.88003C1.32252 4.16367 1.20155 4.46609 1.11994 4.78006C1.03516 5.10648 0.9948 5.44285 0.999949 5.78006C1.00047 6.09718 1.04078 6.41292 1.11994 6.72C1.20378 7.03004 1.32466 7.32888 1.47996 7.61001C1.64768 7.89902 1.85279 8.16468 2.08998 8.40005L7.99995 14.3101L13.9099 8.40005C14.147 8.16709 14.3492 7.90095 14.51 7.61001C14.6728 7.33138 14.7973 7.03199 14.88 6.72C14.9591 6.41292 14.9994 6.09718 14.9999 5.78006C15.0051 5.44285 14.9647 5.10648 14.88 4.78006V4.78006ZM13.88 6.41006C13.8212 6.63368 13.7338 6.84881 13.6199 7.05008V7.05008C13.5012 7.25741 13.3567 7.44887 13.19 7.62002L7.97993 12.82L2.76997 7.62002C2.60019 7.44904 2.45238 7.25762 2.32997 7.05008C2.21477 6.84476 2.12413 6.62656 2.05995 6.40005C2.00871 6.17357 1.9819 5.94219 1.97996 5.70999C1.98132 5.47115 2.00812 5.23318 2.05995 5.00003C2.12225 4.77287 2.21298 4.55445 2.32997 4.35C2.44991 4.1408 2.59796 3.94907 2.76997 3.78006C3.02686 3.5266 3.32862 3.32317 3.65992 3.18008C4.32754 2.91301 5.07233 2.91301 5.73994 3.18008C6.06911 3.31717 6.36812 3.5176 6.61994 3.77005L7.97993 5.14004L9.33998 3.77005C9.5918 3.5176 9.89075 3.31717 10.2199 3.18008C10.8875 2.91301 11.6323 2.91301 12.2999 3.18008C12.6312 3.32317 12.9331 3.5266 13.19 3.78006C13.3642 3.94464 13.5095 4.13726 13.6199 4.35V4.35C13.7338 4.55128 13.8212 4.7664 13.88 4.99002V4.99002C13.94 5.2185 13.9702 5.45373 13.9699 5.68997C13.9837 5.93159 13.9635 6.17404 13.9099 6.41006H13.88Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/help.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.89002 2.09995C4.64425 1.60002 5.49455 1.26307 6.3865 1.11067C7.27845 0.958273 8.19239 0.993788 9.06983 1.21494C9.94726 1.4361 10.7689 1.83802 11.482 2.39497C12.1952 2.95193 12.7842 3.65166 13.2114 4.44936C13.6385 5.24706 13.8944 6.12516 13.9627 7.02746C14.031 7.92976 13.9101 8.83637 13.6078 9.68926C13.3055 10.5421 12.8285 11.3225 12.2072 11.9804C11.586 12.6384 10.8342 13.1593 10 13.51C8.50787 14.1372 6.8354 14.1851 5.30978 13.6444C3.78416 13.1037 2.51517 12.0132 1.75107 10.5863C0.986971 9.15938 0.78274 7.49873 1.17833 5.92921C1.57392 4.35968 2.54088 2.99422 3.89002 2.09995V2.09995ZM4.44002 12.1C5.07948 12.5047 5.79559 12.7732 6.54356 12.8885C7.29153 13.0039 8.05525 12.9636 8.78693 12.7702C9.51862 12.5769 10.2025 12.2346 10.7959 11.7648C11.3892 11.295 11.8792 10.7078 12.2352 10.04C12.5912 9.37211 12.8056 8.63798 12.8648 7.88349C12.9241 7.12901 12.827 6.37042 12.5797 5.65517C12.3323 4.93993 11.94 4.28343 11.4273 3.72675C10.9146 3.17007 10.2925 2.72519 9.60002 2.41995C8.59886 1.99903 7.49375 1.89096 6.43002 2.10995C5.36188 2.31858 4.38026 2.84108 3.6107 3.61064C2.84114 4.38019 2.31864 5.36182 2.11002 6.42995C1.8982 7.49506 2.00644 8.59904 2.42108 9.60273C2.83573 10.6064 3.53822 11.4649 4.44002 12.07V12.1ZM8.41002 3.99995C8.14031 3.88897 7.85166 3.83124 7.56002 3.82995C7.26792 3.82659 6.97836 3.88451 6.71002 3.99995C6.45004 4.11275 6.21283 4.27202 6.01002 4.46995C5.81316 4.66776 5.65689 4.90216 5.55002 5.15995C5.43111 5.42367 5.37301 5.71075 5.38002 5.99995H6.25002C6.24803 5.7416 6.32307 5.48852 6.46556 5.273C6.60805 5.05749 6.81153 4.88931 7.05002 4.78995C7.21084 4.7192 7.38433 4.68178 7.56002 4.67995C7.73893 4.6818 7.91568 4.71919 8.08002 4.78995C8.39473 4.92452 8.64545 5.17524 8.78002 5.48995C8.84379 5.65254 8.87767 5.82532 8.88002 5.99995C8.87715 6.18096 8.83266 6.35889 8.75002 6.51995C8.65704 6.67559 8.5463 6.81989 8.42002 6.94995L8.00002 7.31995C7.84984 7.46012 7.70951 7.61048 7.58002 7.76995C7.44654 7.93631 7.33868 8.1217 7.26002 8.31995C7.16662 8.53412 7.12221 8.76644 7.13002 8.99995V9.43995H8.00002V8.99995C7.99809 8.81834 8.04285 8.63929 8.13002 8.47995C8.22221 8.32379 8.33302 8.1794 8.46002 8.04995C8.59278 7.90922 8.73298 7.77569 8.88002 7.64995C9.03019 7.50978 9.17052 7.35943 9.30002 7.19995C9.4335 7.03359 9.54135 6.84821 9.62002 6.64995C9.70509 6.44376 9.74924 6.223 9.75002 5.99995C9.74873 5.7083 9.691 5.41966 9.58002 5.14995C9.34464 4.63583 8.92812 4.22644 8.41002 3.99995ZM8.00002 11.22V10.34H7.13002V11.22H8.00002Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/history.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.5072 12.3239C14.4749 11.0906 15.0006 9.56812 15 8.00045C15.0001 6.46996 14.4986 4.98161 13.5723 3.76328C12.6459 2.54495 11.3459 1.66378 9.87105 1.25469C8.39624 0.845604 6.828 0.931139 5.40643 1.4982C3.98487 2.06526 2.78832 3.0826 2 4.39445V2.00045H1V5.50045L1.5 6.00045H5V5.00045H2.811C3.47895 3.84546 4.51237 2.94567 5.74827 2.44298C6.98418 1.94028 8.35226 1.86329 9.63676 2.22413C10.9213 2.58498 12.0491 3.36313 12.8425 4.43587C13.6358 5.50862 14.0495 6.81493 14.0182 8.14879C13.987 9.48265 13.5127 10.7682 12.6701 11.8026C11.8274 12.8371 10.6644 13.5616 9.36443 13.862C8.06445 14.1624 6.70147 14.0215 5.49043 13.4615C4.27939 12.9016 3.2892 11.9544 2.676 10.7695L1.789 11.2315C2.51204 12.6224 3.68106 13.7304 5.10876 14.3779C6.53646 15.0254 8.14019 15.1749 9.66297 14.8025C11.1858 14.4301 12.5395 13.5573 13.5072 12.3239ZM10.146 11.3545L10.854 10.6465L8 7.79349V4.00049H7V8.00049L7.146 8.35449L10.146 11.3545Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/home.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.36002 1.37L14.72 7.16999L14.01 7.87999L13 6.96411V13.49L12.5 13.99H9.50004L9.00004 13.49V9.99002H7.00004V13.49L6.50004 13.99H3.50004L3.00004 13.49L3.00003 6.97166L2.00004 7.87999L1.29004 7.16999L7.64002 1.37H7.65002H8.35002H8.36002ZM4.00004 6.06332V12.99H6.00004V9.49002L6.50004 8.99001H9.50004L10 9.49002V12.99H12V6.05729L8.00002 2.43L4.00004 6.06332Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/horizontal-rule.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.43236 10H7.25503V4H6.43236V6.6109H3.82267V4H3V10H3.82267V7.39371H6.43236V10ZM12.0996 10H13L11.7203 7.37068C11.8513 7.31236 11.9808 7.23561 12.1088 7.14045C12.2367 7.04528 12.351 6.9317 12.4516 6.79969C12.5521 6.66769 12.6328 6.51573 12.6938 6.34382C12.7578 6.17191 12.7898 5.97851 12.7898 5.76362C12.7898 5.55794 12.7623 5.37222 12.7075 5.20645C12.6527 5.03761 12.5795 4.88872 12.4881 4.75979C12.3998 4.62778 12.2962 4.5142 12.1773 4.41903C12.0615 4.32387 11.9412 4.24559 11.8163 4.18419C11.6913 4.12279 11.5664 4.07675 11.4415 4.04605C11.3166 4.01535 11.2023 4 11.0987 4H8.63985V10H9.46252V7.51804H10.9296L12.0996 10ZM11.4186 6.67997C11.3151 6.71681 11.2176 6.73523 11.1261 6.73523H9.46252V4.78741H11.1261C11.2176 4.78741 11.3151 4.80737 11.4186 4.84728C11.5222 4.88718 11.6167 4.94705 11.702 5.02686C11.7904 5.10668 11.8635 5.20798 11.9214 5.33078C11.9793 5.45357 12.0082 5.59785 12.0082 5.76362C12.0082 5.93246 11.9793 6.07828 11.9214 6.20107C11.8635 6.32387 11.7904 6.42517 11.702 6.50499C11.6167 6.58173 11.5222 6.64006 11.4186 6.67997ZM13 12H3V13H13V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/hubot.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.48 4H12.48L12.98 4.5V6.53H13.5L14 7.03V8L13.5 8.5H12.98V11.5L12.48 12H9.36L6.86 14.76L6 14.4V12H3.5L3 11.36V8.5H2.5L2 8V7.03L2.5 6.53H3V4.36L3.53 4H7.53V2.86C7.37327 2.7766 7.24157 2.65299 7.14842 2.50184C7.05528 2.3507 7.00405 2.17749 7 2C7 1.73478 7.10536 1.48043 7.29289 1.29289C7.48043 1.10536 7.73478 1 8 1C8.26522 1 8.51957 1.10536 8.70711 1.29289C8.89464 1.48043 9 1.73478 9 2C8.99178 2.17133 8.93964 2.33767 8.84857 2.48302C8.75751 2.62838 8.63058 2.74786 8.48 2.83V4ZM12 8V7.03V5H4V7.03V8V10.86L6.5 11H7V13.19L8.8 11.15L9.15 11H12V8ZM9.88001 8.51C9.50557 8.88537 9.02924 9.14266 8.51001 9.25V9.24C8.07687 9.32287 7.63005 9.29878 7.20833 9.16982C6.78661 9.04086 6.40274 8.81094 6.09001 8.5L5.39001 9.21C5.73061 9.54934 6.13507 9.81784 6.58001 10C7.03006 10.1878 7.51235 10.2863 8.00001 10.29C8.96678 10.2841 9.89283 9.90004 10.58 9.22L9.88001 8.51ZM6.48999 6.5H5.48999V7.5H6.48999V6.5ZM9.48999 6.5H10.49V7.5H9.48999V6.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/inbox.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 14H14.5L15 13.5V9L12.23 1.34L11.76 1H4.27L3.8 1.33L1 8.74V13.5L1.5 14ZM14 13H2V10.02H4.55001L5.29001 11.27L5.72001 11.51H10.29L10.73 11.25L11.42 10.02H14V13ZM13.978 9.02002H11.12L10.69 9.28002L10 10.51H6.01001L5.26001 9.26002L4.83001 9.02002H2V9L4.62 2H11.4L13.978 9.02002Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/info.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.5682 1.03128C10.1593 1.19039 11.6434 1.90518 12.7598 3.04996C13.9762 4.28555 14.6953 5.92552 14.7801 7.65726C14.8649 9.38899 14.3096 11.0913 13.2199 12.4398C12.2176 13.6857 10.8111 14.5416 9.2441 14.8594C7.67708 15.1772 6.04826 14.9369 4.63985 14.18C3.22843 13.4066 2.12659 12.1706 1.51986 10.68C0.910415 9.18166 0.829286 7.52043 1.28985 5.96988C1.74942 4.42537 2.72779 3.0868 4.05984 2.17996C5.38083 1.27892 6.9771 0.87217 8.5682 1.03128ZM9.03988 13.8799C10.3827 13.6075 11.5886 12.8756 12.4499 11.81C13.3825 10.6509 13.857 9.18961 13.7832 7.70377C13.7095 6.21792 13.0926 4.81093 12.0498 3.74991C11.0947 2.77492 9.82729 2.16667 8.46914 2.0314C7.11099 1.89614 5.7485 2.24247 4.61983 3.00992C3.77027 3.59531 3.08425 4.38792 2.62673 5.31265C2.16921 6.23738 1.95535 7.26359 2.00542 8.2941C2.0555 9.3246 2.36784 10.3253 2.91286 11.2013C3.45789 12.0773 4.21752 12.7997 5.11983 13.3C6.31816 13.9467 7.70562 14.1519 9.03988 13.8799ZM7.37482 6L8.62482 6L8.62482 5L7.37482 5L7.37482 6ZM8.62482 7L8.62482 11L7.37482 11L7.37482 7L8.62482 7Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/issue-closed.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 13C10.4887 13 12.9206 10.6162 12.9981 7.64618L13.9505 6.69379C13.9832 6.95794 14 7.22701 14 7.5C14 11.0899 11.0899 14 7.5 14C3.91015 14 1 11.0899 1 7.5C1 3.91015 3.91015 1 7.5 1C9.65167 1 11.5592 2.04548 12.7422 3.65615L12.0261 4.37432C11.0335 2.93976 9.37651 2 7.5 2C4.46243 2 2 4.46243 2 7.5C2 10.5376 4.46243 13 7.5 13ZM13.697 5.53295L15 4.23002L14.29 3.52002L10.88 6.93993L9.50001 5.55986L8.79001 6.26986L10.52 7.99993H11.23L12.8797 6.35033C12.8797 6.35036 12.8797 6.35038 12.8797 6.3504L13.6971 5.53301C13.6971 5.53299 13.6971 5.53297 13.697 5.53295ZM7 7V9H8V7V4H7V7ZM7 11V10H8V11H7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/issue-reopened.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 6.99994L5.28 5.64994L4.89 4.71994L2.57 5.71994C2.97731 4.53398 3.77903 3.52357 4.84137 2.85735C5.90371 2.19113 7.1624 1.9094 8.40739 2.05917C9.65237 2.20894 10.8083 2.78116 11.6824 3.68033C12.5564 4.57949 13.0956 5.75121 13.21 6.99994H14.21C14.1027 5.53846 13.5032 4.15649 12.5093 3.0796C11.5155 2.0027 10.1859 1.29448 8.73774 1.07052C7.28953 0.846559 5.80817 1.12008 4.53544 1.84645C3.2627 2.57282 2.27376 3.70914 1.73 5.06994L0.92 3.11994L0 3.49994L1.34 6.73994L2 6.99994ZM7.24001 4H8.24001V9H7.24001V4ZM7.24001 10H8.24001V11H7.24001V10ZM14.14 8.33L15.48 11.56L14.56 12L13.74 10C13.1919 11.3661 12.1958 12.5054 10.9149 13.2308C9.63412 13.9562 8.14476 14.2246 6.69127 13.9921C5.23779 13.7595 3.90654 13.0398 2.91599 11.951C1.92544 10.8621 1.33445 9.46894 1.24001 8H2.24001V7.5C2.24281 8.78746 2.69801 10.033 3.52602 11.0189C4.35404 12.0047 5.5022 12.6683 6.76983 12.8934C8.03745 13.1186 9.34388 12.8911 10.4608 12.2507C11.5777 11.6103 12.434 10.5977 12.88 9.39L10.63 10.32L10.24 9.4L13.49 8.05L14.14 8.33Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/issues.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.88882 3.09546C4.95774 2.38123 6.21445 2 7.50002 2C9.22393 2 10.8772 2.68482 12.0962 3.90381C13.3152 5.1228 14 6.77609 14 8.5C14 9.78558 13.6188 11.0423 12.9046 12.1112C12.1903 13.1801 11.1752 14.0133 9.98745 14.5052C8.79973 14.9972 7.49283 15.1259 6.23196 14.8751C4.97108 14.6243 3.81287 14.0052 2.90383 13.0962C1.99479 12.1872 1.37571 11.0289 1.1249 9.76807C0.874098 8.50719 1.00281 7.20029 1.49478 6.01257C1.98674 4.82485 2.8199 3.80969 3.88882 3.09546ZM4.44436 13.0731C5.34883 13.6775 6.41223 14 7.50002 14C8.95871 14 10.3576 13.4205 11.3891 12.389C12.4205 11.3576 13 9.95869 13 8.5C13 7.4122 12.6775 6.34881 12.0731 5.44434C11.4688 4.53987 10.6098 3.83498 9.60476 3.4187C8.59977 3.00242 7.49392 2.89349 6.42703 3.10571C5.36013 3.31793 4.38018 3.84177 3.61099 4.61096C2.8418 5.38015 2.31796 6.36011 2.10574 7.427C1.89352 8.4939 2.00244 9.59974 2.41873 10.6047C2.83501 11.6097 3.53989 12.4688 4.44436 13.0731ZM8 5H7V10H8V5ZM8 11H7V12H8V11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/italic.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.00098 13.5928L8.9043 13.918H4L4.12305 13.5928C4.61523 13.5811 4.94043 13.54 5.09863 13.4697C5.35645 13.3701 5.54688 13.2324 5.66992 13.0566C5.86328 12.7812 6.0625 12.2891 6.26758 11.5801L8.3418 4.39062C8.51758 3.79297 8.60547 3.3418 8.60547 3.03711C8.60547 2.88477 8.56738 2.75586 8.49121 2.65039C8.41504 2.54492 8.29785 2.46582 8.13965 2.41309C7.9873 2.35449 7.68555 2.3252 7.23438 2.3252L7.33984 2H11.9453L11.8486 2.3252C11.4736 2.31934 11.1953 2.36035 11.0137 2.44824C10.75 2.56543 10.5479 2.73242 10.4072 2.94922C10.2725 3.16602 10.0967 3.64648 9.87988 4.39062L7.81445 11.5801C7.62695 12.2422 7.5332 12.6641 7.5332 12.8457C7.5332 12.9922 7.56836 13.1182 7.63867 13.2236C7.71484 13.3232 7.83203 13.4023 7.99023 13.4609C8.1543 13.5137 8.49121 13.5576 9.00098 13.5928Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/jersey.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.91 14.22H4.06L3.56 13.72V7.06H2.15L1.67 6.68L1 4L1.33 3.4L5.59 2L6.23 2.32C6.24566 2.37163 6.26573 2.42181 6.29 2.47C6.3341 2.5696 6.3842 2.66645 6.44 2.76C6.51145 2.86344 6.59175 2.96047 6.68 3.05C6.84789 3.21902 7.04871 3.35176 7.27 3.44C7.49601 3.53655 7.73923 3.58633 7.985 3.58633C8.23077 3.58633 8.47399 3.53655 8.7 3.44C8.92129 3.35176 9.12211 3.21902 9.29 3.05C9.37916 2.95501 9.46264 2.85483 9.54 2.75L9.69 2.46C9.70952 2.4144 9.72622 2.36765 9.74 2.32L10.38 2L14.64 3.42L15 4L14.34 6.66L13.85 7.04H12.41V13.7L11.91 14.22ZM4.56 13.22H11.41V6.56L11.91 6.06H13.43L13.89 4.23L10.49 3.09C10.4576 3.16409 10.4174 3.23449 10.37 3.3C10.2608 3.46107 10.1369 3.61171 10 3.75C9.74065 4.01231 9.43118 4.21976 9.09 4.36C8.73878 4.50852 8.36133 4.58504 7.98 4.58504C7.59867 4.58504 7.22122 4.50852 6.87 4.36C6.54513 4.21159 6.25025 4.00483 6 3.75C5.86122 3.61976 5.74019 3.47182 5.64 3.31L5.51 3.09L2.08 4.23L2.54 6.06H4.06L4.56 6.56V13.22Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/json.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 2.98361V2.97184V2H5.91083C5.59743 2 5.29407 2.06161 5.00128 2.18473C4.70818 2.30798 4.44942 2.48474 4.22578 2.71498C4.00311 2.94422 3.83792 3.19498 3.73282 3.46766L3.73233 3.46898C3.63382 3.7352 3.56814 4.01201 3.53533 4.29917L3.53519 4.30053C3.50678 4.5805 3.4987 4.86844 3.51084 5.16428C3.52272 5.45379 3.52866 5.74329 3.52866 6.03279C3.52866 6.23556 3.48974 6.42594 3.412 6.60507L3.4116 6.60601C3.33687 6.78296 3.23423 6.93866 3.10317 7.07359C2.97644 7.20405 2.82466 7.31055 2.64672 7.3925C2.4706 7.46954 2.28497 7.5082 2.08917 7.5082H2V7.6V8.4V8.4918H2.08917C2.28465 8.4918 2.47001 8.53238 2.64601 8.61334L2.64742 8.61396C2.82457 8.69157 2.97577 8.79762 3.10221 8.93161L3.10412 8.93352C3.23428 9.0637 3.33659 9.21871 3.41129 9.39942L3.41201 9.40108C3.48986 9.58047 3.52866 9.76883 3.52866 9.96721C3.52866 10.2567 3.52272 10.5462 3.51084 10.8357C3.4987 11.1316 3.50677 11.4215 3.53516 11.7055L3.53535 11.7072C3.56819 11.9903 3.63387 12.265 3.73232 12.531L3.73283 12.5323C3.83793 12.805 4.00311 13.0558 4.22578 13.285C4.44942 13.5153 4.70818 13.692 5.00128 13.8153C5.29407 13.9384 5.59743 14 5.91083 14H6V13.2V13.0164H5.91083C5.71095 13.0164 5.52346 12.9777 5.34763 12.9008C5.17396 12.8191 5.02194 12.7126 4.89086 12.5818C4.76386 12.4469 4.66104 12.2911 4.58223 12.1137C4.50838 11.9346 4.47134 11.744 4.47134 11.541C4.47134 11.3127 4.4753 11.0885 4.48321 10.8686C4.49125 10.6411 4.49127 10.4195 4.48324 10.2039C4.47914 9.98246 4.46084 9.76883 4.42823 9.56312C4.39513 9.35024 4.33921 9.14757 4.26039 8.95536C4.18091 8.76157 4.07258 8.57746 3.93616 8.40298C3.82345 8.25881 3.68538 8.12462 3.52283 8C3.68538 7.87538 3.82345 7.74119 3.93616 7.59702C4.07258 7.42254 4.18091 7.23843 4.26039 7.04464C4.33913 6.85263 4.39513 6.65175 4.42826 6.44285C4.46082 6.2333 4.47914 6.01973 4.48324 5.80219C4.49127 5.58262 4.49125 5.36105 4.48321 5.13749C4.4753 4.9134 4.47134 4.68725 4.47134 4.45902C4.47134 4.26019 4.50833 4.07152 4.58238 3.89205C4.66135 3.71034 4.76421 3.55475 4.89086 3.42437C5.02193 3.28942 5.17461 3.18275 5.34802 3.10513C5.5238 3.02427 5.71113 2.98361 5.91083 2.98361H6ZM10 13.0164V13.0282V14H10.0892C10.4026 14 10.7059 13.9384 10.9987 13.8153C11.2918 13.692 11.5506 13.5153 11.7742 13.285C11.9969 13.0558 12.1621 12.805 12.2672 12.5323L12.2677 12.531C12.3662 12.2648 12.4319 11.988 12.4647 11.7008L12.4648 11.6995C12.4932 11.4195 12.5013 11.1316 12.4892 10.8357C12.4773 10.5462 12.4713 10.2567 12.4713 9.96721C12.4713 9.76444 12.5103 9.57406 12.588 9.39493L12.5884 9.39399C12.6631 9.21704 12.7658 9.06134 12.8968 8.92642C13.0236 8.79595 13.1753 8.68945 13.3533 8.6075C13.5294 8.53046 13.715 8.4918 13.9108 8.4918H14V8.4V7.6V7.5082H13.9108C13.7153 7.5082 13.53 7.46762 13.354 7.38666L13.3526 7.38604C13.1754 7.30844 13.0242 7.20238 12.8978 7.06839L12.8959 7.06648C12.7657 6.9363 12.6634 6.78129 12.5887 6.60058L12.588 6.59892C12.5101 6.41953 12.4713 6.23117 12.4713 6.03279C12.4713 5.74329 12.4773 5.45379 12.4892 5.16428C12.5013 4.86842 12.4932 4.57848 12.4648 4.29454L12.4646 4.29285C12.4318 4.00971 12.3661 3.73502 12.2677 3.46897L12.2672 3.46766C12.1621 3.19499 11.9969 2.94422 11.7742 2.71498C11.5506 2.48474 11.2918 2.30798 10.9987 2.18473C10.7059 2.06161 10.4026 2 10.0892 2H10V2.8V2.98361H10.0892C10.2891 2.98361 10.4765 3.0223 10.6524 3.09917C10.826 3.18092 10.9781 3.28736 11.1091 3.41823C11.2361 3.55305 11.339 3.70889 11.4178 3.88628C11.4916 4.0654 11.5287 4.25596 11.5287 4.45902C11.5287 4.68727 11.5247 4.91145 11.5168 5.13142C11.5088 5.35894 11.5087 5.58049 11.5168 5.79605C11.5209 6.01754 11.5392 6.23117 11.5718 6.43688C11.6049 6.64976 11.6608 6.85243 11.7396 7.04464C11.8191 7.23843 11.9274 7.42254 12.0638 7.59702C12.1765 7.74119 12.3146 7.87538 12.4772 8C12.3146 8.12462 12.1765 8.25881 12.0638 8.40298C11.9274 8.57746 11.8191 8.76157 11.7396 8.95536C11.6609 9.14737 11.6049 9.34825 11.5717 9.55715C11.5392 9.7667 11.5209 9.98027 11.5168 10.1978C11.5087 10.4174 11.5087 10.6389 11.5168 10.8625C11.5247 11.0866 11.5287 11.3128 11.5287 11.541C11.5287 11.7398 11.4917 11.9285 11.4176 12.1079C11.3386 12.2897 11.2358 12.4452 11.1091 12.5756C10.9781 12.7106 10.8254 12.8173 10.652 12.8949C10.4762 12.9757 10.2889 13.0164 10.0892 13.0164H10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/kebab-vertical.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.44443 13.8315C7.60888 13.9414 7.80222 14 8 14C8.26522 14 8.51957 13.8946 8.70711 13.7071C8.89464 13.5196 9 13.2652 9 13C9 12.8022 8.94135 12.6089 8.83147 12.4444C8.72159 12.28 8.56541 12.1518 8.38268 12.0761C8.19996 12.0004 7.99889 11.9806 7.80491 12.0192C7.61093 12.0578 7.43275 12.153 7.29289 12.2929C7.15304 12.4327 7.0578 12.6109 7.01922 12.8049C6.98063 12.9989 7.00043 13.2 7.07612 13.3827C7.15181 13.5654 7.27998 13.7216 7.44443 13.8315ZM8 9C7.80222 9 7.60888 8.94135 7.44443 8.83147C7.27998 8.72159 7.15181 8.56541 7.07612 8.38268C7.00043 8.19996 6.98063 7.99889 7.01921 7.80491C7.0578 7.61093 7.15304 7.43274 7.29289 7.29289C7.43275 7.15304 7.61093 7.0578 7.80491 7.01921C7.99889 6.98063 8.19996 7.00043 8.38268 7.07612C8.56541 7.15181 8.72159 7.27998 8.83147 7.44443C8.94135 7.60888 9 7.80222 9 8C9 8.26522 8.89464 8.51957 8.70711 8.70711C8.51957 8.89464 8.26522 9 8 9ZM8.00001 4C7.80222 4 7.60888 3.94135 7.44444 3.83147C7.27999 3.72159 7.15181 3.56541 7.07613 3.38268C7.00044 3.19996 6.98064 2.99889 7.01922 2.80491C7.05781 2.61093 7.15305 2.43275 7.2929 2.29289C7.43275 2.15304 7.61093 2.0578 7.80492 2.01921C7.9989 1.98063 8.19996 2.00043 8.38269 2.07612C8.56542 2.15181 8.72159 2.27998 8.83148 2.44443C8.94136 2.60888 9.00001 2.80222 9.00001 3C9.00001 3.26522 8.89465 3.51957 8.70711 3.70711C8.51958 3.89464 8.26522 4 8.00001 4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/key.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.351 1.09104C12.2239 1.26878 13.025 1.70005 13.654 2.33088C14.1858 2.86724 14.5765 3.52697 14.7911 4.25113C15.0057 4.9753 15.0376 5.74136 14.884 6.48088C14.6614 7.49472 14.1012 8.40297 13.2952 9.05696C12.4891 9.71096 11.485 10.072 10.447 10.0809C10.0091 10.0816 9.5734 10.0179 9.154 9.89188L8.354 10.8289L7.975 11.0039H7V12.5039L6.5 13.0039H5V14.5039L4.5 15.0039H1.5L1 14.5039V12.1969L1.146 11.8439L6.12 6.87088C5.97884 6.4162 5.91132 5.94188 5.92 5.46588C5.93222 4.57514 6.20692 3.70779 6.70969 2.97241C7.21247 2.23704 7.92099 1.6663 8.74657 1.33165C9.57215 0.997 10.4781 0.913306 11.351 1.09104ZM12.6693 8.29061C13.2973 7.78194 13.7341 7.07512 13.908 6.28588L13.912 6.29088C14.0355 5.71382 14.0129 5.11505 13.8463 4.54894C13.6796 3.98283 13.3742 3.46731 12.9578 3.04919C12.5414 2.63106 12.0271 2.32358 11.4617 2.15465C10.8962 1.98572 10.2976 1.96071 9.72 2.08188C8.94078 2.25482 8.24183 2.68349 7.73442 3.29963C7.22701 3.91577 6.94032 4.68396 6.92 5.48188C6.90919 5.93679 6.99049 6.38919 7.159 6.81188L7.049 7.35388L2 12.4039V14.0039H4V12.5039L4.5 12.0039H6V10.5039L6.5 10.0039H7.745L8.621 8.98788L9.182 8.84788C9.58639 9.0059 10.0168 9.08663 10.451 9.08588C11.2592 9.07967 12.0413 8.79928 12.6693 8.29061ZM11.8315 5.55948C11.9414 5.39503 12 5.20169 12 5.00391C12 4.73869 11.8946 4.48434 11.7071 4.2968C11.5196 4.10926 11.2652 4.00391 11 4.00391C10.8022 4.00391 10.6089 4.06256 10.4444 4.17244C10.28 4.28232 10.1518 4.4385 10.0761 4.62122C10.0004 4.80395 9.98063 5.00502 10.0192 5.199C10.0578 5.39298 10.153 5.57116 10.2929 5.71101C10.4327 5.85087 10.6109 5.94611 10.8049 5.98469C10.9989 6.02328 11.2 6.00347 11.3827 5.92779C11.5654 5.8521 11.7216 5.72393 11.8315 5.55948Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/law.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.63 7L13 3H14V2H9V1H8V2H3V3H4L2.38 7H2V8H2.15C2.30639 8.49791 2.62276 8.93028 3.05 9.23C3.47165 9.53576 3.97916 9.7004 4.5 9.7004C5.02084 9.7004 5.52835 9.53576 5.95 9.23C6.37736 8.92817 6.69638 8.49696 6.86 8H7V7H6.55L4.88 3H8V11H6L5.61 11.18L3.61 13.69L4 14.5H13L13.39 13.69L11.39 11.18L11 11H9V3H12.13L10.46 7H10V8H10.15C10.3136 8.49544 10.6292 8.92668 11.052 9.23236C11.4748 9.53804 11.9833 9.70258 12.505 9.70258C13.0267 9.70258 13.5352 9.53804 13.958 9.23236C14.3808 8.92668 14.6964 8.49544 14.86 8H15V7H14.63ZM5.22 8.51C4.99947 8.63205 4.75204 8.69734 4.5 8.7C4.25094 8.69869 4.00642 8.63326 3.79 8.51C3.56931 8.38903 3.38338 8.21342 3.25 8H5.75C5.61775 8.21083 5.43575 8.38595 5.22 8.51ZM5.47 7H3.47L4.47 4.6L5.47 7ZM10.76 12L12 13.5H5L6.24 12H10.76ZM12.54 4.62L13.54 7.02H11.54L12.54 4.62ZM13.22 8.53C13.0014 8.65671 12.7527 8.72233 12.5 8.72V8.72C12.2503 8.72355 12.0045 8.65778 11.79 8.53C11.569 8.40065 11.3835 8.21856 11.25 8H13.75C13.626 8.2225 13.4425 8.40604 13.22 8.53V8.53Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/library.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 2.5L5.5 2H7.5L8 2.5V13.5L7.5 14H5.5L5 13.5V2.5ZM6 3V13H7V3H6Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.17101 3.34472L9.46985 2.70387L11.3492 2.01983L11.9901 2.31866L15.7523 12.6553L15.4535 13.2961L13.5741 13.9802L12.9332 13.6813L9.17101 3.34472ZM10.2817 3.47255L13.7019 12.8695L14.6416 12.5275L11.2214 3.13053L10.2817 3.47255Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 2.5L1.5 2H3.5L4 2.5V13.5L3.5 14H1.5L1 13.5V2.5ZM2 3V13H3V3H2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/lightbulb-autofix.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 9C11.4067 9 10.8266 9.17597 10.3333 9.50562C9.83992 9.83526 9.45547 10.3038 9.22841 10.8519C9.00134 11.4001 8.94187 12.0034 9.05763 12.5853C9.17339 13.1673 9.45912 13.7018 9.87868 14.1213C10.2982 14.5409 10.8327 14.8266 11.4147 14.9424C11.9966 15.0581 12.5999 14.9987 13.1481 14.7716C13.6963 14.5445 14.1648 14.1601 14.4944 13.6667C14.824 13.1734 15 12.5933 15 12C15 11.2044 14.684 10.4413 14.1214 9.87866C13.5587 9.31605 12.7957 9 12 9ZM13.3101 14L12 13L10.7 14L11.2 12.47L10 11.64H11.47L12 10L12.5401 11.64H14L12.8001 12.47L13.3101 14Z" fill="#75BEFF"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.1708 8.08474C9.85081 8.35911 8.77687 9.27684 8.28696 10.5H6.40867V12.7012C6.40867 12.7823 6.4372 12.8512 6.49888 12.9127C6.56058 12.9741 6.63007 13.0028 6.71205 13.0028H8.12487C8.21364 13.3513 8.34773 13.6809 8.52059 13.9851C8.45462 13.9951 8.38715 14 8.31823 14H6.71205C6.53223 14 6.36223 13.9663 6.20306 13.8984C6.04564 13.8311 5.90753 13.7388 5.78961 13.6213C5.67168 13.5038 5.57895 13.3661 5.51141 13.2091C5.44311 13.0503 5.40927 12.8807 5.40927 12.7012V11.1009C5.40927 10.622 5.31772 10.1795 5.13553 9.77209C4.95683 9.36336 4.69832 8.99156 4.35953 8.65806C3.92468 8.22903 3.58896 7.75003 3.35361 7.22134C3.11756 6.69107 3 6.11672 3 5.49953C3 5.08664 3.05342 4.68802 3.16048 4.30397C3.26728 3.92089 3.41907 3.56286 3.61595 3.23018C3.81257 2.89377 4.04777 2.58911 4.32146 2.31641C4.59503 2.04383 4.89858 1.80953 5.23195 1.61364C5.56979 1.41764 5.93146 1.2662 6.31578 1.15983C6.70106 1.0532 7.10094 1 7.51514 1C7.92934 1 8.32923 1.0532 8.71451 1.15983C9.09883 1.2662 9.45803 1.41739 9.79183 1.61351C10.1294 1.80938 10.4351 2.0437 10.7088 2.31641C10.9825 2.5891 11.2177 2.89376 11.4143 3.23016C11.6112 3.56285 11.763 3.92088 11.8698 4.30397C11.9769 4.68802 12.0303 5.08664 12.0303 5.49953C12.0303 6.11672 11.9127 6.69107 11.6767 7.22134C11.5412 7.52562 11.3725 7.81344 11.1708 8.08474Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/lightbulb.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.6708 8.65806C11.3319 8.9916 11.0716 9.36278 10.8886 9.77172C10.7105 10.1792 10.621 10.6219 10.621 11.1009V12.7012C10.621 12.8807 10.5872 13.0503 10.5189 13.2091C10.4513 13.3661 10.3586 13.5038 10.2407 13.6213C10.1228 13.7388 9.98464 13.8311 9.82723 13.8984C9.66806 13.9663 9.49806 14 9.31823 14H7.71205C7.53223 14 7.36223 13.9663 7.20306 13.8984C7.04564 13.8311 6.90753 13.7388 6.78961 13.6213C6.67168 13.5038 6.57895 13.3661 6.51141 13.2091C6.44311 13.0503 6.40927 12.8807 6.40927 12.7012V11.1009C6.40927 10.622 6.31772 10.1795 6.13553 9.77209C5.95683 9.36336 5.69832 8.99156 5.35953 8.65806C4.92468 8.22903 4.58896 7.75003 4.35361 7.22134C4.11756 6.69107 4 6.11672 4 5.49953C4 5.08664 4.05342 4.68802 4.16048 4.30397C4.26728 3.92089 4.41907 3.56286 4.61595 3.23018C4.81257 2.89377 5.04777 2.58911 5.32146 2.31641C5.59503 2.04383 5.89858 1.80953 6.23195 1.61364C6.56979 1.41764 6.93146 1.2662 7.31578 1.15983C7.70106 1.0532 8.10094 1 8.51514 1C8.92934 1 9.32923 1.0532 9.71451 1.15983C10.0988 1.2662 10.458 1.41739 10.7918 1.61351C11.1294 1.80938 11.4351 2.0437 11.7088 2.31641C11.9825 2.5891 12.2177 2.89376 12.4143 3.23016C12.6112 3.56285 12.763 3.92088 12.8698 4.30397C12.9769 4.68802 13.0303 5.08664 13.0303 5.49953C13.0303 6.11672 12.9127 6.69107 12.6767 7.22134C12.4413 7.75003 12.1056 8.22903 11.6708 8.65806ZM9.62162 10.5H7.40867V12.7012C7.40867 12.7823 7.4372 12.8512 7.49888 12.9127C7.56058 12.9741 7.63007 13.0028 7.71205 13.0028H9.31823C9.40022 13.0028 9.46971 12.9741 9.5314 12.9127C9.59309 12.8512 9.62162 12.7823 9.62162 12.7012V10.5Z" fill="#FFCC00"/>
</svg>

```

`src/vsicons/link-external.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.5 1.00006L6 1V2L2 2.00006V14.0001H14V10.0001H15V14.5001L14.5 15.0001H1.5L1 14.5001V1.50006L1.5 1.00006Z" fill="#C5C5C5"/>
<path d="M15 1.50006L15.0001 8.00003H14.0001L14 2.70716L7.24269 9.46451L6.53558 8.7574L13.2929 2.00006L8.00003 2.00006V1.00006H14.5L15 1.50006Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/link.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.4 3H7.485C8.38674 3 9.25154 3.35821 9.88916 3.99584C10.5268 4.63346 10.885 5.49826 10.885 6.4V6.605C10.8837 7.50587 10.5249 8.36939 9.8874 9.00593C9.24992 9.64247 8.38587 10 7.485 10H7V9H7.485C8.11892 8.99868 8.72658 8.74662 9.1753 8.29883C9.62402 7.85105 9.87736 7.24392 9.88 6.61V6.4C9.88001 5.76521 9.62852 5.15627 9.1806 4.70647C8.73267 4.25667 8.12478 4.00265 7.49 4H4.4C3.76348 4 3.15303 4.25286 2.70294 4.70294C2.48008 4.9258 2.3033 5.19038 2.18269 5.48156C2.06208 5.77274 2 6.08483 2 6.4V6.605C2.0015 7.17053 2.20316 7.71727 2.56924 8.14833C2.93532 8.57938 3.44218 8.86693 4 8.96V9.96C3.17781 9.86262 2.4194 9.46858 1.86707 8.85181C1.31473 8.23503 1.00643 7.43791 1 6.61V6.4C1.00132 5.49867 1.35996 4.63463 1.9973 3.9973C2.63463 3.35996 3.49867 3.00132 4.4 3ZM12.0001 7.04V6.04C12.824 6.1376 13.5838 6.53307 14.1363 7.15194C14.6889 7.77081 14.9961 8.57036 15.0001 9.4V9.605C14.9975 10.5046 14.6389 11.3666 14.0028 12.0027C13.3667 12.6388 12.5047 12.9974 11.6051 13H8.51512C7.61598 12.9987 6.75397 12.6413 6.11771 12.0059C5.48146 11.3706 5.12276 10.5091 5.12012 9.61V9.4C5.12012 8.49913 5.47764 7.63508 6.11419 6.9976C6.75073 6.36012 7.61425 6.00132 8.51512 6H9.00012V7H8.51512C7.87946 7.00132 7.2703 7.25477 6.82129 7.70471C6.37229 8.15465 6.12012 8.76435 6.12012 9.4V9.605C6.12144 10.2398 6.37419 10.8482 6.82306 11.2971C7.27192 11.7459 7.88033 11.9987 8.51512 12H11.6051C12.239 11.9987 12.8467 11.7466 13.2954 11.2988C13.7441 10.851 13.9975 10.2439 14.0001 9.61V9.4C13.9998 8.83361 13.7987 8.28568 13.4325 7.85358C13.0663 7.42149 12.5588 7.13321 12.0001 7.04Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/list-filter.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 12V11H10V12H6ZM4 7H12V8H4V7ZM14 3V4H2V3H14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/list-flat.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2 10V9H14V10H2ZM2 6H14V7H2V6ZM14 3V4H2V3H14Z" fill="#C5C5C5"/>
<path d="M2 12V13H14V12H2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/list-ordered.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.28711 2.326L2.69211 2H3.36911V5H2.66111V2.792L2.28711 3.073V2.326ZM5 3H15V4H5V3ZM5 7H15V8H5V7ZM15 11H5V12H15V11ZM3.742 7.62606L3.77055 7.58715C3.79289 7.55685 3.81494 7.52695 3.836 7.49606C3.86778 7.45161 3.89492 7.40403 3.917 7.35406C3.94099 7.30111 3.95942 7.24581 3.972 7.18906C3.98597 7.12332 3.99268 7.05625 3.992 6.98906C3.99211 6.86909 3.97287 6.74989 3.935 6.63606C3.897 6.51709 3.8332 6.40799 3.74815 6.31654C3.6631 6.2251 3.5589 6.15356 3.443 6.10706C3.29959 6.04887 3.14571 6.02095 2.991 6.02506C2.83386 6.02081 2.67764 6.05049 2.533 6.11206C2.41607 6.16344 2.31142 6.23911 2.226 6.33406C2.1491 6.42149 2.09061 6.52352 2.054 6.63406C2.01902 6.73819 2.0008 6.84721 2 6.95706V7.00606H2.81V6.95706C2.81037 6.92997 2.81441 6.90306 2.822 6.87706C2.82825 6.84943 2.83979 6.82328 2.856 6.80006C2.87064 6.77795 2.89013 6.75948 2.913 6.74606C2.93965 6.73253 2.96911 6.72548 2.999 6.72548C3.02889 6.72548 3.05835 6.73253 3.085 6.74606C3.10786 6.76169 3.12698 6.78218 3.141 6.80606C3.15617 6.83095 3.16667 6.8584 3.172 6.88706C3.17759 6.91438 3.18061 6.94217 3.181 6.97006C3.183 7.04136 3.16755 7.11208 3.136 7.17606C3.10118 7.2403 3.06104 7.30152 3.016 7.35906L2.016 8.49706L2.004 8.51006V9.05006H3.992V8.35006H3.092L3.742 7.62606ZM3.705 11.443C3.75065 11.4745 3.79113 11.513 3.825 11.557C3.8733 11.6218 3.91203 11.6931 3.94 11.769C3.97799 11.8775 3.99562 11.9921 3.992 12.107C3.99153 12.2136 3.97466 12.3195 3.942 12.421C3.90674 12.5287 3.84876 12.6276 3.772 12.711C3.68292 12.8033 3.57472 12.8749 3.455 12.921C3.30148 12.9776 3.13857 13.0044 2.975 13C2.85954 13.0005 2.74463 12.984 2.634 12.951C2.54221 12.9234 2.4552 12.8819 2.376 12.828C2.3057 12.7797 2.24415 12.7199 2.194 12.651C2.14817 12.5887 2.10927 12.5217 2.078 12.451C2.05097 12.3865 2.03054 12.3195 2.017 12.251C2.00624 12.1939 2.00055 12.136 2 12.078V12.029H2.814V12.078C2.81417 12.1055 2.81718 12.133 2.823 12.16C2.82808 12.1863 2.83827 12.2115 2.853 12.234C2.86562 12.2558 2.88395 12.2738 2.906 12.286C2.93027 12.2978 2.9567 12.3047 2.98368 12.306C3.01066 12.3074 3.03765 12.3033 3.063 12.294C3.08428 12.2852 3.1034 12.2719 3.119 12.255C3.1378 12.233 3.15207 12.2075 3.161 12.18C3.17307 12.1391 3.17881 12.0966 3.178 12.054C3.18004 11.9988 3.1726 11.9436 3.156 11.891C3.14566 11.8606 3.12817 11.8332 3.105 11.811C3.08765 11.7966 3.06706 11.7866 3.045 11.782C3.01953 11.7778 2.9938 11.7755 2.968 11.775H2.807V11.13H2.975C2.99842 11.1297 3.02167 11.126 3.044 11.119C3.06797 11.1127 3.0902 11.1011 3.109 11.085C3.13011 11.0668 3.14656 11.0438 3.157 11.018C3.17268 10.9796 3.17984 10.9383 3.178 10.897C3.17879 10.8629 3.17337 10.829 3.162 10.797C3.15362 10.7732 3.13994 10.7517 3.122 10.734C3.10589 10.7179 3.08643 10.7056 3.065 10.698C3.03986 10.6886 3.01309 10.6844 2.98629 10.6856C2.95949 10.6868 2.9332 10.6934 2.909 10.705C2.88675 10.7181 2.86791 10.7362 2.854 10.758C2.84002 10.7812 2.82989 10.8065 2.824 10.833C2.81746 10.8595 2.81411 10.8867 2.814 10.914V10.963H2V10.914C2.00261 10.796 2.02632 10.6795 2.07 10.57C2.0992 10.4995 2.13609 10.4324 2.18 10.37C2.2292 10.2987 2.28966 10.2359 2.359 10.184C2.43818 10.1251 2.52677 10.0802 2.621 10.051C2.73545 10.0149 2.85501 9.99764 2.975 9.99996C3.09067 9.99866 3.20611 10.0107 3.319 10.036C3.41072 10.0575 3.49916 10.0911 3.582 10.136C3.65408 10.1739 3.71959 10.2232 3.776 10.282C3.82549 10.3334 3.86786 10.3913 3.902 10.454C3.93274 10.5103 3.95594 10.5705 3.971 10.633C3.98456 10.6879 3.99161 10.7443 3.992 10.801C3.99512 10.911 3.97713 11.0207 3.939 11.124C3.91116 11.1975 3.87276 11.2665 3.825 11.329C3.79087 11.3727 3.75043 11.4111 3.705 11.443Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/list-selection.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1 12L1 11H10V12H1ZM1 7H15V8H1L1 7ZM12 3V4H1L1 3H12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/list-tree.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 3V4H2V3H14Z" fill="#C5C5C5"/>
<path d="M13 6V7H6V6H13Z" fill="#C5C5C5"/>
<path d="M13 9V10H5V9H13Z" fill="#C5C5C5"/>
<path d="M13 12V13H5V12H13Z" fill="#C5C5C5"/>
<rect x="5" y="4" width="1" height="9" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/list-unordered.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 3H1V4H2V3ZM2 6H1V7H2V6ZM1 9H2V10H1V9ZM2 12H1V13H2V12ZM4 3H15V4H4V3ZM15 6H4V7H15V6ZM4 9H15V10H4V9ZM15 12H4V13H15V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/loading.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 0.75C8.17188 0.75 8.33333 0.783854 8.48438 0.851562C8.63542 0.914062 8.76823 1.0026 8.88281 1.11719C8.9974 1.23177 9.08594 1.36458 9.14844 1.51562C9.21615 1.66667 9.25 1.82812 9.25 2C9.25 2.17188 9.21615 2.33333 9.14844 2.48438C9.08594 2.63542 8.9974 2.76823 8.88281 2.88281C8.76823 2.9974 8.63542 3.08854 8.48438 3.15625C8.33333 3.21875 8.17188 3.25 8 3.25C7.82812 3.25 7.66667 3.21875 7.51562 3.15625C7.36458 3.08854 7.23177 2.9974 7.11719 2.88281C7.0026 2.76823 6.91146 2.63542 6.84375 2.48438C6.78125 2.33333 6.75 2.17188 6.75 2C6.75 1.82812 6.78125 1.66667 6.84375 1.51562C6.91146 1.36458 7.0026 1.23177 7.11719 1.11719C7.23177 1.0026 7.36458 0.914062 7.51562 0.851562C7.66667 0.783854 7.82812 0.75 8 0.75ZM2.63281 3.75781C2.63281 3.60156 2.66146 3.45573 2.71875 3.32031C2.77604 3.1849 2.85417 3.06771 2.95312 2.96875C3.05729 2.86458 3.17708 2.78385 3.3125 2.72656C3.45312 2.66406 3.60156 2.63281 3.75781 2.63281C3.91406 2.63281 4.0599 2.66406 4.19531 2.72656C4.33073 2.78385 4.44792 2.86458 4.54688 2.96875C4.65104 3.06771 4.73177 3.1849 4.78906 3.32031C4.85156 3.45573 4.88281 3.60156 4.88281 3.75781C4.88281 3.91406 4.85156 4.0625 4.78906 4.20312C4.73177 4.33854 4.65104 4.45833 4.54688 4.5625C4.44792 4.66146 4.33073 4.73958 4.19531 4.79688C4.0599 4.85417 3.91406 4.88281 3.75781 4.88281C3.60156 4.88281 3.45312 4.85417 3.3125 4.79688C3.17708 4.73958 3.05729 4.66146 2.95312 4.5625C2.85417 4.45833 2.77604 4.33854 2.71875 4.20312C2.66146 4.0625 2.63281 3.91406 2.63281 3.75781ZM2 7C2.14062 7 2.27083 7.02604 2.39062 7.07812C2.51042 7.13021 2.61458 7.20312 2.70312 7.29688C2.79688 7.38542 2.86979 7.48958 2.92188 7.60938C2.97396 7.72917 3 7.85938 3 8C3 8.14062 2.97396 8.27083 2.92188 8.39062C2.86979 8.51042 2.79688 8.61719 2.70312 8.71094C2.61458 8.79948 2.51042 8.86979 2.39062 8.92188C2.27083 8.97396 2.14062 9 2 9C1.85938 9 1.72917 8.97396 1.60938 8.92188C1.48958 8.86979 1.38281 8.79948 1.28906 8.71094C1.20052 8.61719 1.13021 8.51042 1.07812 8.39062C1.02604 8.27083 1 8.14062 1 8C1 7.85938 1.02604 7.72917 1.07812 7.60938C1.13021 7.48958 1.20052 7.38542 1.28906 7.29688C1.38281 7.20312 1.48958 7.13021 1.60938 7.07812C1.72917 7.02604 1.85938 7 2 7ZM2.88281 12.2422C2.88281 12.1224 2.90625 12.0104 2.95312 11.9062C3 11.7969 3.0625 11.7031 3.14062 11.625C3.21875 11.5469 3.3099 11.4844 3.41406 11.4375C3.52344 11.3906 3.63802 11.3672 3.75781 11.3672C3.8776 11.3672 3.98958 11.3906 4.09375 11.4375C4.20312 11.4844 4.29688 11.5469 4.375 11.625C4.45312 11.7031 4.51562 11.7969 4.5625 11.9062C4.60938 12.0104 4.63281 12.1224 4.63281 12.2422C4.63281 12.362 4.60938 12.4766 4.5625 12.5859C4.51562 12.6901 4.45312 12.7812 4.375 12.8594C4.29688 12.9375 4.20312 13 4.09375 13.0469C3.98958 13.0938 3.8776 13.1172 3.75781 13.1172C3.63802 13.1172 3.52344 13.0938 3.41406 13.0469C3.3099 13 3.21875 12.9375 3.14062 12.8594C3.0625 12.7812 3 12.6901 2.95312 12.5859C2.90625 12.4766 2.88281 12.362 2.88281 12.2422ZM8 13.25C8.20833 13.25 8.38542 13.3229 8.53125 13.4688C8.67708 13.6146 8.75 13.7917 8.75 14C8.75 14.2083 8.67708 14.3854 8.53125 14.5312C8.38542 14.6771 8.20833 14.75 8 14.75C7.79167 14.75 7.61458 14.6771 7.46875 14.5312C7.32292 14.3854 7.25 14.2083 7.25 14C7.25 13.7917 7.32292 13.6146 7.46875 13.4688C7.61458 13.3229 7.79167 13.25 8 13.25ZM11.6172 12.2422C11.6172 12.0651 11.6771 11.9167 11.7969 11.7969C11.9167 11.6771 12.0651 11.6172 12.2422 11.6172C12.4193 11.6172 12.5677 11.6771 12.6875 11.7969C12.8073 11.9167 12.8672 12.0651 12.8672 12.2422C12.8672 12.4193 12.8073 12.5677 12.6875 12.6875C12.5677 12.8073 12.4193 12.8672 12.2422 12.8672C12.0651 12.8672 11.9167 12.8073 11.7969 12.6875C11.6771 12.5677 11.6172 12.4193 11.6172 12.2422ZM14 7.5C14.1354 7.5 14.2526 7.54948 14.3516 7.64844C14.4505 7.7474 14.5 7.86458 14.5 8C14.5 8.13542 14.4505 8.2526 14.3516 8.35156C14.2526 8.45052 14.1354 8.5 14 8.5C13.8646 8.5 13.7474 8.45052 13.6484 8.35156C13.5495 8.2526 13.5 8.13542 13.5 8C13.5 7.86458 13.5495 7.7474 13.6484 7.64844C13.7474 7.54948 13.8646 7.5 14 7.5ZM12.2422 2.38281C12.4297 2.38281 12.6068 2.41927 12.7734 2.49219C12.9401 2.5651 13.0859 2.66406 13.2109 2.78906C13.3359 2.91406 13.4349 3.0599 13.5078 3.22656C13.5807 3.39323 13.6172 3.57031 13.6172 3.75781C13.6172 3.94531 13.5807 4.1224 13.5078 4.28906C13.4349 4.45573 13.3359 4.60156 13.2109 4.72656C13.0859 4.85156 12.9401 4.95052 12.7734 5.02344C12.6068 5.09635 12.4297 5.13281 12.2422 5.13281C12.0547 5.13281 11.8776 5.09635 11.7109 5.02344C11.5443 4.95052 11.3984 4.85156 11.2734 4.72656C11.1484 4.60156 11.0495 4.45573 10.9766 4.28906C10.9036 4.1224 10.8672 3.94531 10.8672 3.75781C10.8672 3.57031 10.9036 3.39323 10.9766 3.22656C11.0495 3.0599 11.1484 2.91406 11.2734 2.78906C11.3984 2.66406 11.5443 2.5651 11.7109 2.49219C11.8776 2.41927 12.0547 2.38281 12.2422 2.38281Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/location.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.8325 2.68759C10.0855 1.94057 9.07645 1.51449 8.02009 1.5H7.98009C6.92374 1.51449 5.91472 1.94057 5.16769 2.68759C4.42066 3.43462 3.99458 4.44364 3.9801 5.5C3.96667 6.25028 4.17769 6.98747 4.58609 7.617L7.73355 14H8.26664L11.4141 7.617C11.8225 6.98747 12.0335 6.25028 12.0201 5.5C12.0056 4.44364 11.5795 3.43462 10.8325 2.68759ZM7.9241 2.5L8.00609 2.51L8.0801 2.5C8.86566 2.53421 9.60828 2.86807 10.1553 3.43293C10.7023 3.99779 11.0121 4.75074 11.0211 5.537C11.0287 6.09502 10.8658 6.64206 10.5541 7.105L10.5341 7.139L10.5171 7.174L8.0001 12.279L5.4831 7.179L5.46609 7.14L5.4461 7.106C5.13443 6.64306 4.97151 6.09602 4.9791 5.538C4.98762 4.75083 5.29782 3.99693 5.84575 3.4317C6.39367 2.86647 7.13757 2.53299 7.9241 2.5ZM8.53555 4.66853C8.3711 4.55865 8.17776 4.5 7.97998 4.5C7.71477 4.5 7.46041 4.60536 7.27288 4.79289C7.08534 4.98043 6.97998 5.23478 6.97998 5.5C6.97998 5.69778 7.03863 5.89112 7.14851 6.05557C7.25839 6.22002 7.41457 6.34819 7.5973 6.42388C7.78002 6.49957 7.98109 6.51937 8.17507 6.48079C8.36905 6.4422 8.54724 6.34696 8.68709 6.20711C8.82694 6.06725 8.92218 5.88907 8.96077 5.69509C8.99935 5.50111 8.97955 5.30004 8.90386 5.11732C8.82817 4.93459 8.7 4.77841 8.53555 4.66853ZM6.86884 3.83706C7.19774 3.6173 7.58442 3.5 7.97998 3.5C8.51041 3.5 9.01912 3.71071 9.3942 4.08579C9.76927 4.46086 9.97998 4.96957 9.97998 5.5C9.97998 5.89556 9.86268 6.28224 9.64292 6.61114C9.42316 6.94004 9.1108 7.19638 8.74535 7.34776C8.3799 7.49913 7.97776 7.53874 7.5898 7.46157C7.20184 7.3844 6.84547 7.19392 6.56577 6.91421C6.28606 6.63451 6.09558 6.27814 6.01841 5.89018C5.94124 5.50222 5.98085 5.10009 6.13222 4.73463C6.2836 4.36918 6.53994 4.05682 6.86884 3.83706Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/lock.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13 7H12V5C12 3.93913 11.5786 2.92178 10.8284 2.17163C10.0783 1.42149 9.06087 1 8 1C6.93913 1 5.92172 1.42149 5.17157 2.17163C4.42142 2.92178 4 3.93913 4 5V7H3L2 8V14L3 15H13L14 14V8L13 7ZM5 5C5 4.20435 5.31605 3.44127 5.87866 2.87866C6.44127 2.31605 7.20435 2 8 2C8.79565 2 9.55873 2.31605 10.1213 2.87866C10.6839 3.44127 11 4.20435 11 5V7H5V5ZM13 14H3V8H13V14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/magnet.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 1.5C4.1 1.5 1 4.6 1 8.5V10.5V10.7V13.5L2 14.5H5L6 13.5V11V10.5V8.5C6 7.4 6.9 6.5 8 6.5C9.1 6.5 10 7.4 10 8.5V10.5V11V13.5L11 14.5H14L15 13.5V11.3V10.5V8.5C15 4.6 11.9 1.5 8 1.5ZM5 13.5H2V10.7V10.5H3H5V11V13.5ZM14 13.5H11V11V10.5H12H14V11.3V13.5ZM11 9.5V8.5C11 6.8 9.7 5.5 8 5.5C6.4 5.5 5.1 6.8 5 8.3V9.5H2V8.5C2 5.2 4.7 2.5 8 2.5C11.3 2.5 14 5.2 14 8.5V9.5H11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/mail-read.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.24976 1.56995H7.73976L0.999756 5.55995V13.4999L1.49976 13.9999H14.4998L14.9998 13.4999V5.55995L8.24976 1.56995ZM7.99976 2.57995L13.6298 5.89995L12.2598 7.48995H3.73976L2.42976 5.89995L7.99976 2.57995ZM13.9998 12.9999H1.99976V6.91995L3.10976 8.29995L3.49976 8.48995H12.4998L12.8898 8.29995L13.9998 6.91995V12.9999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/mail.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M0.999756 3.5L1.49976 3H14.4998L14.9998 3.5V3.769V12.5L14.4998 13H1.49976L0.999756 12.5V3.769V3.5ZM1.99976 4.53482V12H13.9998V4.53597L8.30976 8.9H7.69976L1.99976 4.53482ZM13.0298 4H2.96976L7.99976 7.869L13.0298 4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/markdown.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.34542 5H8.44542V11.5333H6.99292L7.04776 6.22383L5.27442 11.5333H4.07159L2.26676 6.22383C2.30642 6.86667 2.32626 11.5333 2.32626 11.5333H0.999756V5H3.15576C3.15576 5 4.68409 9.49283 4.73309 9.80667L6.34542 5ZM13.0549 8.61667V5.11667H11.1113V8.61667H9.16642L12.0831 11.5333L14.9998 8.61667H13.0549Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/megaphone.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.99971 6.77002L14.3297 3.33997L14.9997 3.86997V12.47L14.3297 13L8.24145 11.4051C8.19491 11.5852 8.12516 11.7591 8.03352 11.9223C7.87278 12.2085 7.6489 12.4543 7.3789 12.6411C7.1089 12.8279 6.79989 12.9506 6.47533 13C6.15078 13.0495 5.81923 13.0242 5.50588 12.9263C5.19253 12.8284 4.90563 12.6603 4.66697 12.4349C4.4283 12.2095 4.24417 11.9326 4.12855 11.6254C4.01293 11.3181 3.96887 10.9885 3.99971 10.6617C4.01094 10.5427 4.032 10.4252 4.06248 10.3104L1.99971 9.77002L1.57971 9.24002V7.30002L1.99971 6.77002ZM5.00586 10.5575C4.9842 10.6358 4.97091 10.7168 4.96657 10.7991C4.96657 11.1094 5.08984 11.407 5.30925 11.6265C5.52867 11.8459 5.82626 11.9691 6.13657 11.9691C6.44687 11.9691 6.74447 11.8459 6.96388 11.6265C7.09927 11.4911 7.19804 11.3259 7.25385 11.1464L5.00586 10.5575ZM2.57971 8.82002L13.9997 11.83V4.49997L2.57971 7.72002V8.82002Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/mention.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.4653 12.36C9.54043 12.896 8.47975 13.1517 7.41226 13.096C6.8027 13.1419 6.19038 13.0561 5.6169 12.8445C5.04343 12.6328 4.52222 12.3002 4.08869 11.8692C3.65516 11.4382 3.31946 10.919 3.10439 10.3468C2.88932 9.77457 2.79992 9.16278 2.84226 8.55295C2.8167 7.82964 2.93733 7.10861 3.19691 6.433C3.45649 5.75739 3.8497 5.14109 4.35301 4.62098C4.85631 4.10086 5.45937 3.68763 6.12609 3.40601C6.79282 3.12438 7.5095 2.98015 8.23326 2.98195C10.6103 2.98195 12.6463 4.35695 12.6463 6.98795C12.6463 9.16995 11.3543 10.648 9.74626 10.648C9.07026 10.648 8.64626 10.374 8.62026 9.73095C8.43106 10.0216 8.16995 10.2583 7.86228 10.4183C7.55462 10.5783 7.21082 10.656 6.86426 10.644C5.89526 10.644 5.23526 9.99895 5.23526 8.72095C5.23526 6.95795 6.38326 5.32095 7.85526 5.32095C8.16481 5.28125 8.47839 5.35303 8.73985 5.52343C9.00132 5.69383 9.19359 5.95172 9.28226 6.25095L9.49326 5.44195H10.3933L9.60026 8.64595C9.37426 9.56195 9.47026 9.86095 9.94226 9.86095C10.9263 9.86095 11.7753 8.65095 11.7753 7.03595C11.7753 4.96795 10.3303 3.77095 8.16426 3.77095C5.52226 3.77095 3.79126 5.90295 3.78326 8.55695C3.74231 9.05277 3.80929 9.55158 3.97961 10.019C4.14992 10.4865 4.41952 10.9115 4.76983 11.2647C5.12015 11.618 5.54287 11.8911 6.00887 12.0654C6.47488 12.2396 6.97311 12.3108 7.46926 12.274C8.44226 12.3142 9.40852 12.0954 10.2693 11.64L10.4653 12.36ZM6.21726 8.63895C6.21726 9.42695 6.52426 9.84495 7.13026 9.84495C7.88826 9.84495 8.51026 9.24495 8.81326 8.01395C9.13626 6.74595 8.84926 6.09995 7.94026 6.09995C6.90026 6.09995 6.21726 7.43895 6.21726 8.63895Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/menu.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M16 5H0V4H16V5ZM16 13H0V12H16V13ZM16 8.99218H0V8H16V8.99218Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/merge.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 4.64639L8.35364 2.5H7.64653L5.50009 4.64639L6.2072 5.35349L7.30006 4.26066V5.27972H7.28057V5.73617L7.30543 5.73717C7.30744 5.84794 7.30944 5.95412 7.31144 6.05572C7.31514 6.24322 7.33177 6.43462 7.36133 6.62994C7.3909 6.82525 7.4297 7.02056 7.47774 7.21587C7.52578 7.41119 7.5923 7.62017 7.6773 7.84283C7.83252 8.22173 8.02099 8.56548 8.24273 8.87408C8.46446 9.18267 8.70283 9.47173 8.95782 9.74127C9.21282 10.0108 9.46596 10.2764 9.71726 10.5381C9.96856 10.7999 10.1958 11.0792 10.3991 11.376C10.6024 11.6729 10.7668 11.9971 10.8925 12.3487C11.0181 12.7002 11.0809 13.1045 11.0809 13.5616V14.4463H12.5V13.5616C12.4926 13.042 12.4372 12.5792 12.3337 12.1729C12.2303 11.7667 12.088 11.3995 11.9069 11.0713C11.7258 10.7432 11.5244 10.4444 11.3027 10.1749C11.0809 9.90533 10.85 9.64752 10.6097 9.40142C10.3695 9.15533 10.1386 8.90923 9.91682 8.66314C9.69509 8.41705 9.49368 8.15533 9.3126 7.87798C9.13151 7.60064 8.98738 7.29595 8.88021 6.96392C8.77304 6.63189 8.71946 6.25494 8.71946 5.83306V5.27972H8.71876V4.27935L9.7929 5.3535L10.5 4.64639ZM7.04221 9.74127C7.15493 9.62213 7.26439 9.49917 7.37061 9.3724C7.1264 9.01878 6.92084 8.63423 6.75193 8.22189L6.74293 8.19952C6.70926 8.11134 6.6777 8.02386 6.64835 7.93713C6.4775 8.19261 6.28912 8.43461 6.08321 8.66314C5.86147 8.90923 5.6305 9.15533 5.39029 9.40142C5.15007 9.64752 4.9191 9.90533 4.69737 10.1749C4.47563 10.4444 4.27422 10.7432 4.09314 11.0713C3.91206 11.3995 3.76978 11.7667 3.6663 12.1729C3.56282 12.5792 3.50739 13.042 3.5 13.5616V14.4463H4.9191V13.5616C4.9191 13.1045 4.98193 12.7002 5.10758 12.3487C5.23323 11.9971 5.39768 11.6729 5.60094 11.376C5.80419 11.0792 6.03147 10.7999 6.28277 10.5381C6.53407 10.2764 6.78722 10.0108 7.04221 9.74127Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/milestone.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.99976 1H6.99976V3H1.49976L0.999756 3.5V7.5L1.49976 8H6.99976V15H7.99976V8H12.4898L12.8298 7.87L15.0098 5.87V5.13L12.8298 3.13L12.4998 3H7.99976V1ZM12.2898 7H1.99976V4H12.2898L13.9198 5.5L12.2898 7ZM4.99976 5H9.99976V6H4.99976V5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/mirror.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.56976 1L14.7698 5L14.9998 5.38V14.58L14.2398 15L7.99976 11L1.75976 15L0.999756 14.58V5.38L1.22976 5L7.42976 1H8.56976ZM8.50976 10.13L13.9998 13.67V5.65L8.50976 2.15V5H7.50976V2.13L1.99976 5.67V13.67L7.50976 10.11V10.13H8.50976ZM9.40976 5.35002L10.1198 4.65002L12.5898 7.13002V7.84002L10.1298 10.3L9.42976 9.60003L11.0198 8.00002H8.94976H7.07976H5.01976L6.59976 9.60003L5.89976 10.3L3.43976 7.84002V7.13002L5.91976 4.65002L6.61976 5.35002L4.97976 7.00002H7.07976H8.94976H11.0598L9.40976 5.35002Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/more.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 12C6 12.2967 5.91203 12.5867 5.74721 12.8334C5.58238 13.08 5.34812 13.2723 5.07403 13.3858C4.79994 13.4994 4.49834 13.5291 4.20737 13.4712C3.91639 13.4133 3.64912 13.2704 3.43934 13.0607C3.22956 12.8509 3.0867 12.5836 3.02882 12.2926C2.97094 12.0017 3.00065 11.7001 3.11418 11.426C3.22771 11.1519 3.41997 10.9176 3.66665 10.7528C3.91332 10.588 4.20333 10.5 4.5 10.5C4.89783 10.5 5.27936 10.658 5.56066 10.9393C5.84197 11.2206 6 11.6022 6 12Z" fill="#C5C5C5"/>
<path d="M13.5 12C13.5 12.2967 13.412 12.5867 13.2472 12.8334C13.0824 13.08 12.8481 13.2723 12.574 13.3858C12.2999 13.4994 11.9983 13.5291 11.7074 13.4712C11.4164 13.4133 11.1491 13.2704 10.9393 13.0607C10.7296 12.8509 10.5867 12.5836 10.5288 12.2926C10.4709 12.0017 10.5006 11.7001 10.6142 11.426C10.7277 11.1519 10.92 10.9176 11.1666 10.7528C11.4133 10.588 11.7033 10.5 12 10.5C12.3978 10.5 12.7794 10.658 13.0607 10.9393C13.342 11.2206 13.5 11.6022 13.5 12Z" fill="#C5C5C5"/>
<path d="M21 12C21 12.2967 20.912 12.5867 20.7472 12.8334C20.5824 13.08 20.3481 13.2723 20.074 13.3858C19.7999 13.4994 19.4983 13.5291 19.2074 13.4712C18.9164 13.4133 18.6491 13.2704 18.4393 13.0607C18.2296 12.8509 18.0867 12.5836 18.0288 12.2926C17.9709 12.0017 18.0006 11.7001 18.1142 11.426C18.2277 11.1519 18.42 10.9176 18.6666 10.7528C18.9133 10.588 19.2033 10.5 19.5 10.5C19.8978 10.5 20.2794 10.658 20.5607 10.9393C20.842 11.2206 21 11.6022 21 12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/mortar-board.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.9998 5.66L8.17976 3H7.81976L0.999756 5.66V12H1.99976V7L4.30976 7.9C3.79948 8.62666 3.52381 9.49208 3.51976 10.38C3.50987 10.4898 3.50987 10.6002 3.51976 10.71V10.82L3.79976 11.22L7.77976 13H8.18976L12.1298 11.19L12.4098 10.79V10.67C12.4098 10.57 12.4098 10.46 12.4098 10.35C12.4041 9.46696 12.1323 8.60614 11.6298 7.88L14.9998 6.57V5.66ZM11.4798 10.34V10.41L7.99976 12L4.49976 10.4C4.49508 10.3803 4.49508 10.3597 4.49976 10.34C4.5052 9.56927 4.76932 8.82269 5.24976 8.22L7.82976 9.22H8.18976L10.7498 8.22C11.2258 8.8238 11.4831 9.57112 11.4798 10.34V10.34ZM7.99976 8.25L2.51976 6.12L7.99976 4L13.4798 6.14L7.99976 8.25Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/move.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.2322 10.7071L8.5 12.4393L8.5 9.00001H7.5L7.5 12.4393L5.76777 10.7071L5.06066 11.4142L7.64644 14H8.35355L10.9393 11.4142L10.2322 10.7071ZM5.06066 3.58579L5.76777 4.29289L7.5 2.56066V5.99999L8.5 5.99999L8.5 2.56066L10.2322 4.29289L10.9393 3.58578L8.35355 1H7.64644L5.06066 3.58578L5.06066 3.58579ZM4.79289 5.26776L3.06066 6.99999H6.49999V7.99999H3.06066L4.79289 9.73222L4.08579 10.4393L1.5 7.85355V7.14644L4.08579 4.56065L4.79289 5.26776ZM9.50001 6.99999L12.9393 6.99999L11.2071 5.26776L11.9142 4.56065L14.5 7.14644V7.85354L11.9142 10.4393L11.2071 9.73222L12.9393 7.99999L9.50001 7.99999L9.50001 6.99999Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/multiple-windows.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 1.5L6.5 1H14.5L15 1.5V3.5V8.5L14.5 9H12V8H14V4H7V5H6V3.5V1.5ZM7 2V3H14V2H7ZM1.5 7L1 7.5V14.5L1.5 15H9.5L10 14.5V7.5L9.5 7H1.5ZM2 9V8H9V9H2ZM2 10H9V14H2V10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/mute.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.49976 5.00004H4.28976L8.14976 1.17004L8.99976 1.52004V14.52L8.14976 14.85L4.28976 11H1.49976L0.999756 10.5V5.50004L1.49976 5.00004ZM4.84976 10.17L7.99976 13.31V2.73004L4.84976 5.85004L4.49976 6.00004H1.99976V10H4.49976L4.84976 10.17ZM14.2312 6.06152L14.9383 6.76861L13.2068 8.50006L14.9383 10.2315L14.2312 10.9386L12.4997 9.20716L10.7683 10.9386L10.0612 10.2315L11.7926 8.50007L10.0612 6.76864L10.7683 6.06153L12.4998 7.79297L14.2312 6.06152Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/new-file.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 7H3V4H0V3H3V0H4V3H7V4H4V7ZM10.5 1.09998L13.9 4.59998L14 5V13.5L13.5 14H3.5L3 13.5V8H4V13H13V6H9V2H5V1H10.2L10.5 1.09998ZM10 2V5H12.9L10 2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/new-folder.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 3H4V0H3V3H0V4H3V7H4V4H7V3ZM5.5 7H5V6H5.3L6.1 5.1L6.5 5H14V4H8V3H14.5L15 3.5V13.5L14.5 14H1.5L1 13.5V6.5V6V5H2V6V6.5V13H14V7V6H6.7L5.9 6.9L5.5 7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/no-newline.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.33329 5.50559C2.82664 5.17595 3.40666 5 4 5C4.79565 5 5.55871 5.31607 6.12132 5.87868C6.68393 6.44129 7 7.20435 7 8C7 8.59334 6.82405 9.17336 6.49441 9.66671C6.16477 10.1601 5.69623 10.5446 5.14805 10.7716C4.59987 10.9987 3.99667 11.0581 3.41473 10.9424C2.83279 10.8266 2.29824 10.5409 1.87868 10.1213C1.45912 9.70176 1.1734 9.16721 1.05765 8.58527C0.94189 8.00333 1.0013 7.40013 1.22836 6.85195C1.45543 6.30377 1.83994 5.83524 2.33329 5.50559ZM5.01 6.283C4.70478 6.09986 4.35595 6.00212 4 6C3.64728 5.9979 3.30035 6.08968 2.99481 6.26593C2.68927 6.44218 2.43613 6.69655 2.26136 7.00294C2.08659 7.30932 1.99648 7.65669 2.00028 8.0094C2.00409 8.36211 2.10166 8.70745 2.283 9.01L5.01 6.283ZM2.99 9.717C3.29522 9.90014 3.64406 9.99788 4 10C4.35272 10.0021 4.69965 9.91032 5.00519 9.73407C5.31073 9.55782 5.56387 9.30345 5.73864 8.99706C5.91342 8.69068 6.00352 8.34331 5.99972 7.9906C5.99592 7.63789 5.89834 7.29255 5.717 6.99L2.99 9.717ZM13.9998 5V6.98404C13.9998 7.11665 13.9472 7.24383 13.8534 7.3376C13.7596 7.43136 13.6325 7.48404 13.4998 7.48404H9.36684L10.9998 5.85104L10.2928 5.14404L8.17184 7.26504L7.74915 7.68774V8.25634L10.2928 10.8L10.9998 10.093L9.39084 8.48404H13.4998C13.8977 8.48404 14.2792 8.32601 14.5605 8.0447C14.8418 7.7634 14.9998 7.38187 14.9998 6.98404V5H13.9998Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/note.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.49915 2H14.4991L14.9991 2.5V12.5L14.4991 13H1.49915L0.999146 12.5V2.5L1.49915 2ZM1.99915 3V12H13.9991V3H1.99915ZM3.99915 5H11.9991V6H3.99915V5ZM9.99915 7H3.99915V8H9.99915V7ZM3.99915 9H7.99915V10H3.99915V9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/octoface.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.8625 5.67254C13.9762 5.39254 14.3437 4.28129 13.7487 2.77629C13.7487 2.77629 12.83 2.48754 10.7388 3.91379C9.86375 3.66879 8.9275 3.63379 8 3.63379C7.0725 3.63379 6.13625 3.66879 5.26125 3.91379C3.17 2.47879 2.25125 2.77629 2.25125 2.77629C1.65625 4.28129 2.02375 5.39254 2.1375 5.67254C1.42875 6.43379 1 7.41379 1 8.60379C1 13.11 3.91375 14.125 7.9825 14.125C12.0513 14.125 15 13.11 15 8.60379C15 7.41379 14.5712 6.43379 13.8625 5.67254ZM8 13.2675C5.1125 13.2675 2.7675 13.1363 2.7675 10.3363C2.7675 9.67129 3.1 9.04129 3.66 8.52504C4.59625 7.66754 6.1975 8.12254 8 8.12254C9.81125 8.12254 11.395 7.66754 12.34 8.52504C12.9088 9.04129 13.2325 9.66254 13.2325 10.3363C13.2325 13.1275 10.8875 13.2675 8 13.2675ZM5.80375 8.88379C5.22625 8.88379 4.75375 9.58379 4.75375 10.4413C4.75375 11.2988 5.22625 12.0075 5.80375 12.0075C6.38125 12.0075 6.85375 11.3075 6.85375 10.4413C6.85375 9.57504 6.38125 8.88379 5.80375 8.88379ZM10.1963 8.88379C9.61875 8.88379 9.14625 9.57504 9.14625 10.4413C9.14625 11.3075 9.61875 12.0075 10.1963 12.0075C10.7738 12.0075 11.2463 11.3075 11.2463 10.4413C11.2463 9.57504 10.7825 8.88379 10.1963 8.88379Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/open-preview.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 1H14L15 2V7.30005C14.6853 7.14615 14.3475 7.04476 14 7V2H9V12.88L7.88 14H3L2 13V2L3 1ZM3 13H8V2H3V13ZM13.3787 8.00202C12.9597 8.01773 12.5512 8.13726 12.1899 8.34992H12.1599C11.8705 8.52448 11.6193 8.75571 11.4214 9.02973C11.2235 9.30375 11.083 9.61487 11.0083 9.94453C10.9336 10.2742 10.9261 10.6156 10.9866 10.9482C11.047 11.2808 11.1741 11.5977 11.36 11.88L9 14.2299L9.70996 14.9399L12.0599 12.5799C12.3851 12.8004 12.7594 12.9378 13.15 12.9799C13.535 13.0271 13.9255 12.9825 14.2899 12.8499C14.6686 12.7225 15.0115 12.5065 15.2899 12.2199C15.5599 11.9374 15.7588 11.5946 15.87 11.2199C15.978 10.8465 16.0019 10.4537 15.9399 10.0699C15.8704 9.68581 15.713 9.32307 15.48 9.00996C15.247 8.6929 14.9419 8.43582 14.59 8.25996C14.2138 8.07495 13.7976 7.98631 13.3787 8.00202ZM13.6196 11.9943C13.2746 12.0285 12.9285 11.9422 12.64 11.7499C12.3915 11.5822 12.1969 11.3459 12.08 11.0699C11.969 10.7974 11.9412 10.4982 12 10.2099C12.0565 9.91792 12.199 9.64957 12.4093 9.43928C12.6196 9.22898 12.8879 9.08644 13.1799 9.02998C13.4682 8.97115 13.7674 8.99894 14.0399 9.10993C14.316 9.2269 14.5522 9.42149 14.72 9.66999C14.9122 9.95851 14.9986 10.3046 14.9644 10.6496C14.9301 10.9946 14.7775 11.3172 14.5323 11.5623C14.2872 11.8075 13.9646 11.9601 13.6196 11.9943Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/organization.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.11121 4.66295C8.78231 4.88272 8.39562 4.99999 8.00006 4.99999C7.46963 4.99999 6.96095 4.78925 6.58588 4.41417C6.2108 4.0391 6.00006 3.53042 6.00006 2.99999C6.00006 2.60443 6.11733 2.2178 6.3371 1.88891C6.55686 1.56001 6.86923 1.30359 7.23468 1.15221C7.60013 1.00084 8.0023 0.961271 8.39026 1.03844C8.77822 1.11561 9.13454 1.3061 9.41425 1.5858C9.69395 1.86551 9.88444 2.22189 9.96161 2.60985C10.0388 2.99781 9.99921 3.39992 9.84784 3.76537C9.69646 4.13082 9.4401 4.44319 9.11121 4.66295ZM8.5556 2.16857C8.39115 2.05869 8.19784 1.99999 8.00006 1.99999C7.73484 1.99999 7.48051 2.1053 7.29297 2.29284C7.10543 2.48037 7.00006 2.73477 7.00006 2.99999C7.00006 3.19777 7.0587 3.39108 7.16858 3.55553C7.27846 3.71998 7.43464 3.84813 7.61737 3.92382C7.8001 3.9995 8.00115 4.01941 8.19513 3.98082C8.38911 3.94224 8.5673 3.84699 8.70715 3.70714C8.84701 3.56729 8.94225 3.38904 8.98083 3.19506C9.01942 3.00108 8.99964 2.80002 8.92395 2.6173C8.84826 2.43457 8.72005 2.27845 8.5556 2.16857ZM11.1667 2.19968C11.4134 2.03391 11.7034 1.94543 12.0001 1.94543C12.3979 1.94543 12.7794 2.10438 13.0607 2.3873C13.342 2.67022 13.5001 3.05394 13.5001 3.45406C13.5001 3.75243 13.4121 4.04411 13.2473 4.2922C13.0824 4.54029 12.8482 4.73366 12.5741 4.84784C12.3 4.96202 11.9984 4.9919 11.7074 4.93369C11.4165 4.87548 11.1492 4.7318 10.9394 4.52081C10.7296 4.30983 10.5868 4.04102 10.5289 3.74837C10.471 3.45573 10.5007 3.1524 10.6142 2.87673C10.7278 2.60107 10.92 2.36545 11.1667 2.19968ZM11.6465 3.80964C11.7403 3.90395 11.8675 3.95693 12.0001 3.95693C12.1327 3.95693 12.2598 3.90395 12.3536 3.80964C12.4474 3.71533 12.5001 3.58743 12.5001 3.45406C12.4975 3.32149 12.444 3.19507 12.3508 3.10132C12.2576 3.00756 12.1319 2.95376 12.0001 2.95118C11.8675 2.95118 11.7403 3.00416 11.6465 3.09847C11.5527 3.19278 11.5001 3.32068 11.5001 3.45406C11.5001 3.58743 11.5527 3.71533 11.6465 3.80964ZM3.19008 12.4857H5.00008V13.4914H3.19008C2.87356 13.4888 2.57089 13.3604 2.34801 13.1344C2.12512 12.9083 2.00007 12.6029 2.00008 12.2845V10.4742C1.86562 10.4697 1.73344 10.438 1.61144 10.381C1.48944 10.324 1.38014 10.2428 1.29008 10.1423C1.19497 10.0459 1.12024 9.93119 1.0704 9.80501C1.02056 9.67883 0.996642 9.54381 1.00008 9.40808V7.22561C1.00308 6.75424 1.18978 6.30286 1.52008 5.96842C1.84892 5.63683 2.29444 5.44893 2.76008 5.44543H4.60008C4.3521 5.74058 4.16512 6.0825 4.05008 6.45118H2.76008C2.55744 6.4567 2.36444 6.53937 2.22008 6.6825C2.07879 6.82753 1.99979 7.02257 2.00008 7.22561V9.45836H3.00008V12.2845C2.99778 12.3118 3.00103 12.3392 3.00963 12.3651C3.01822 12.3911 3.03199 12.415 3.05008 12.4354C3.09028 12.4666 3.1393 12.4842 3.19008 12.4857ZM10.4901 5.96842C10.1588 5.63438 9.70919 5.44628 9.24007 5.44543H6.76008C6.29443 5.44893 5.84892 5.63683 5.52008 5.96842C5.18978 6.30286 5.00308 6.75424 5.00008 7.22561V10.4038C4.99866 10.677 5.1026 10.9402 5.29008 11.138C5.38014 11.2385 5.48944 11.3197 5.61144 11.3767C5.73343 11.4337 5.86562 11.4654 6.00008 11.4699V13.7931C5.99914 13.9519 6.0296 14.1092 6.08969 14.2559C6.14978 14.4027 6.23829 14.536 6.35008 14.648C6.52989 14.8164 6.75678 14.9253 7.00008 14.9598H9.00007C9.28103 14.9249 9.53904 14.7862 9.72388 14.5705C9.90872 14.3549 10.0072 14.0778 10.0001 13.7931V11.4699C10.1345 11.4654 10.2667 11.4337 10.3887 11.3767C10.5107 11.3197 10.62 11.2385 10.7101 11.138C10.8052 11.0416 10.8799 10.9269 10.9298 10.8007C10.9796 10.6745 11.0035 10.5395 11.0001 10.4038V7.22561C11.0008 6.75545 10.8176 6.30387 10.4901 5.96842ZM10.0001 10.4541H9.00007V13.7931C8.99932 13.8462 8.97776 13.8968 8.94007 13.9339C8.92301 13.9543 8.90147 13.9703 8.87717 13.9808C8.85287 13.9912 8.82647 13.9959 8.80008 13.9943H7.19007C7.13782 13.9918 7.08835 13.9699 7.05136 13.9327C7.01436 13.8954 6.99251 13.8457 6.99008 13.7931V10.4541H6.00008V7.22561C5.99978 7.02257 6.07879 6.82753 6.22008 6.6825C6.36443 6.53937 6.55744 6.4567 6.76008 6.45118H9.24007C9.44316 6.45464 9.63689 6.53763 9.78008 6.6825C9.85141 6.75333 9.90769 6.83798 9.94551 6.93134C9.98332 7.0247 10.0019 7.12481 10.0001 7.22561V10.4541ZM12.8101 13.4914H11.0001V12.4857H12.8001C12.8508 12.4842 12.8999 12.4666 12.9401 12.4354C12.9599 12.4158 12.9755 12.3923 12.9859 12.3663C12.9962 12.3403 13.001 12.3125 13.0001 12.2845V9.45836H14.0001V7.22561C14.0004 7.02257 13.9213 6.82753 13.7801 6.6825C13.6357 6.53937 13.4427 6.4567 13.2401 6.45118H11.9501C11.835 6.0825 11.648 5.74058 11.4001 5.44543H13.2401C13.7057 5.44893 14.1512 5.63683 14.4801 5.96842C14.8104 6.30286 14.9971 6.75424 15.0001 7.22561V9.40808C15.0005 9.68067 14.8971 9.94308 14.7111 10.1414C14.5251 10.3396 14.2707 10.4587 14.0001 10.4742V12.2845C14.0001 12.6029 13.875 12.9083 13.6521 13.1344C13.4292 13.3604 13.1266 13.4888 12.8101 13.4914ZM4.00006 1.94543C3.70339 1.94543 3.41338 2.03391 3.16671 2.19968C2.92003 2.36545 2.72777 2.60107 2.61424 2.87673C2.50071 3.1524 2.47101 3.45573 2.52888 3.74837C2.58676 4.04102 2.72962 4.30983 2.9394 4.52081C3.14918 4.7318 3.41645 4.87548 3.70743 4.93369C3.9984 4.9919 4.3 4.96202 4.57409 4.84784C4.84818 4.73366 5.08244 4.54029 5.24727 4.2922C5.41209 4.04411 5.50006 3.75243 5.50006 3.45406C5.50006 3.05394 5.34203 2.67022 5.06072 2.3873C4.77942 2.10438 4.39789 1.94543 4.00006 1.94543ZM4.00006 3.95693C3.86745 3.95693 3.74028 3.90395 3.64651 3.80964C3.55274 3.71533 3.50006 3.58743 3.50006 3.45406C3.50006 3.32068 3.55274 3.19278 3.64651 3.09847C3.74028 3.00416 3.86745 2.95118 4.00006 2.95118C4.13187 2.95376 4.25756 3.00756 4.35078 3.10132C4.444 3.19507 4.4975 3.32149 4.50006 3.45406C4.50006 3.58743 4.44738 3.71533 4.35362 3.80964C4.25985 3.90395 4.13267 3.95693 4.00006 3.95693Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/output.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.5 0V1.5L21 3V22.5L19.5 24H4.5L3 22.5V3L4.5 1.5V0H6V1.5H9V0H10.5V1.5H13.5V0H15V1.5H18V0H19.5ZM4.5 22.5H19.5V3H4.5V22.5ZM7.5 6H16.5V7.5H7.5V6ZM16.5 12H7.5V13.5H16.5V12ZM7.5 18H16.5V19.5H7.5V18Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/package.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.61 3L14.35 4.53L15 5V11.74L14.63 12.22L8.5 13.91L2.36 12.22L2 11.74V5L2.61 4.53L8.34 3H8.61ZM8.52 4L4.52 5L5.07 5.2L8.5 6.1L11.5 5.29L12.45 5L8.52 4ZM3 11.36L8 12.73V7L3 5.66V11.36ZM9 7V12.73L14 11.36V5.63L11.98 6.18348V8.75001L10.98 9.01001V6.45748L9 7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/paintcan.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5406 11.8111L13.4006 8.69097V8.63103L8.4906 3.721V2.48101C8.48888 2.28265 8.45164 2.08626 8.38062 1.90105C8.30282 1.71896 8.18926 1.55434 8.04669 1.41692C7.90412 1.2795 7.73543 1.17204 7.5506 1.101C7.36637 1.02753 7.16878 0.993488 6.97058 1.00103C6.77493 0.996863 6.58063 1.03434 6.40057 1.11101C6.221 1.18491 6.05784 1.29365 5.92053 1.43096C5.78322 1.56827 5.67448 1.73148 5.60059 1.91106C5.52392 2.09111 5.48644 2.28536 5.4906 2.48101V5.74102L2.4306 8.74102C2.15449 9.02478 2 9.40515 2 9.80107C2 10.197 2.15449 10.5772 2.4306 10.861L6.06061 14.491C6.20062 14.6322 6.36713 14.7443 6.5506 14.821C6.91641 14.9678 7.3248 14.9678 7.69061 14.821C7.87408 14.7443 8.04059 14.6322 8.1806 14.491L13.1106 9.57097L12.4506 11.771C12.4207 11.9229 12.4207 12.0791 12.4506 12.231C12.4827 12.3831 12.5475 12.5265 12.6406 12.6511C12.7375 12.772 12.8562 12.8737 12.9906 12.951C13.1309 13.021 13.284 13.0618 13.4406 13.071C13.6056 13.0811 13.7705 13.0502 13.9206 12.981C14.0699 12.9135 14.203 12.8145 14.3106 12.691C14.4194 12.5649 14.495 12.4137 14.5306 12.251C14.562 12.1063 14.5654 11.957 14.5406 11.8111ZM6.54059 2.48101C6.52592 2.41515 6.52592 2.34692 6.54059 2.28106C6.56873 2.21688 6.60954 2.15901 6.66058 2.11101C6.71479 2.06818 6.77557 2.03444 6.84058 2.01104C6.90979 1.99617 6.98139 1.99617 7.0506 2.01104C7.17197 2.02042 7.28576 2.07377 7.37061 2.16106C7.44919 2.25294 7.49181 2.37013 7.4906 2.49102V3.75103L6.4906 4.75103L6.54059 2.48101ZM7.54059 13.831C7.49834 13.8816 7.44302 13.9196 7.38062 13.941C7.32077 13.9674 7.25605 13.9811 7.19061 13.9811C7.12518 13.9811 7.06046 13.9674 7.00061 13.941C6.93821 13.9196 6.88283 13.8816 6.84058 13.831L3.21057 10.211C3.16502 10.1643 3.12783 10.1103 3.10059 10.0511C3.07446 9.98938 3.06104 9.923 3.06104 9.85601C3.06104 9.78901 3.07446 9.72275 3.10059 9.66106C3.12783 9.60183 3.16502 9.54768 3.21057 9.50103L7.56061 5.15105V8.00103C7.48441 8.07086 7.42366 8.15593 7.38232 8.25066C7.34099 8.34539 7.31999 8.44772 7.32062 8.55108C7.30842 8.68269 7.33123 8.81515 7.38672 8.93511C7.44221 9.05507 7.5284 9.15826 7.6366 9.23418C7.74479 9.3101 7.87112 9.3561 8.00281 9.36748C8.13449 9.37886 8.26686 9.35523 8.38647 9.299C8.50609 9.24277 8.60871 9.15595 8.68396 9.04729C8.75921 8.93863 8.80443 8.81198 8.815 8.68023C8.82557 8.54847 8.80111 8.41619 8.74414 8.29693C8.68717 8.17766 8.59972 8.07561 8.4906 8.00103V5.17107L12.3406 9.04107L7.54059 13.831Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/pass.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.26989 10.8698H6.97989L11.5398 6.30996L10.8298 5.59996L6.62989 9.80985L4.71 7.88994L4 8.59994L6.26989 10.8698Z" fill="#89D185"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.6 0.999985C10.2 1.09999 11.7 1.89999 12.8 2.99999C14.1 4.39999 14.8 6.09999 14.8 8.09999C14.8 9.69999 14.2 11.2 13.2 12.5C12.2 13.7 10.8 14.6 9.2 14.9C7.6 15.2 6 15 4.6 14.2C3.2 13.4 2.1 12.2 1.5 10.7C0.899997 9.19999 0.799997 7.49999 1.3 5.99999C1.8 4.39999 2.7 3.09999 4.1 2.19999C5.4 1.29999 7 0.899985 8.6 0.999985ZM9.1 13.9C10.4 13.6 11.6 12.9 12.5 11.8C13.3 10.7 13.8 9.39999 13.7 7.99999C13.7 6.39999 13.1 4.79999 12 3.69999C11 2.69999 9.8 2.09999 8.4 1.99999C7.1 1.89999 5.7 2.19999 4.6 2.99999C3.5 3.79999 2.7 4.89999 2.3 6.29999C1.9 7.59999 1.9 8.99999 2.5 10.3C3.1 11.6 4 12.6 5.2 13.3C6.4 14 7.8 14.2 9.1 13.9Z" fill="#89D185"/>
</svg>

```

`src/vsicons/person.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.99996 2C8.19775 2 8.39109 2.05865 8.55554 2.16853C8.71998 2.27841 8.84816 2.43459 8.92384 2.61732C8.99953 2.80004 9.01934 3.00111 8.98075 3.19509C8.94217 3.38907 8.84692 3.56725 8.70707 3.70711C8.56722 3.84696 8.38904 3.9422 8.19506 3.98079C8.00107 4.01937 7.80001 3.99957 7.61728 3.92388C7.43456 3.84819 7.27838 3.72002 7.1685 3.55557C7.05861 3.39112 6.99996 3.19778 6.99996 3C6.99996 2.73478 7.10532 2.48043 7.29286 2.29289C7.48039 2.10536 7.73475 2 7.99996 2V2ZM7.99996 1C7.6044 1 7.21772 1.1173 6.88882 1.33706C6.55993 1.55682 6.30358 1.86918 6.15221 2.23463C6.00083 2.60009 5.96122 3.00222 6.03839 3.39018C6.11557 3.77814 6.30605 4.13451 6.58575 4.41421C6.86546 4.69392 7.22182 4.8844 7.60978 4.96157C7.99775 5.03874 8.39988 4.99913 8.76533 4.84776C9.13078 4.69638 9.44314 4.44004 9.6629 4.11114C9.88267 3.78224 9.99997 3.39556 9.99997 3C9.99997 2.46957 9.78925 1.96086 9.41418 1.58579C9.03911 1.21071 8.5304 1 7.99996 1V1ZM9.22997 5.49H6.76997C6.30053 5.49 5.85033 5.67648 5.51839 6.00842C5.18645 6.34036 4.99997 6.79057 4.99997 7.26V9.9C4.98904 10.1779 5.08775 10.4489 5.27481 10.6547C5.46187 10.8605 5.72231 10.9845 5.99997 11V13.33C5.99997 13.6483 6.12639 13.9535 6.35144 14.1785C6.57648 14.4036 6.88171 14.53 7.19997 14.53H8.79996C8.96097 14.5301 9.12036 14.4978 9.26862 14.435C9.41688 14.3722 9.55099 14.2802 9.66295 14.1645C9.77492 14.0488 9.86246 13.9118 9.92036 13.7615C9.97826 13.6113 10.0053 13.4509 9.99997 13.29V11C10.2776 10.9845 10.5381 10.8605 10.7251 10.6547C10.9122 10.4489 11.0109 10.1779 11 9.9V7.26C11 6.79057 10.8135 6.34036 10.4815 6.00842C10.1496 5.67648 9.6994 5.49 9.22997 5.49V5.49ZM5.99997 10V7.26C5.99862 7.15851 6.01762 7.05778 6.05584 6.96375C6.09406 6.86972 6.15073 6.7843 6.2225 6.71253C6.29427 6.64076 6.37969 6.58409 6.47372 6.54587C6.56774 6.50765 6.66847 6.48866 6.76997 6.49H9.22997C9.33146 6.48866 9.43219 6.50765 9.52621 6.54587C9.62024 6.58409 9.70566 6.64076 9.77743 6.71253C9.8492 6.7843 9.90587 6.86972 9.94409 6.96375C9.98231 7.05778 10.0013 7.15851 9.99997 7.26V10H8.99997V13.31C8.99997 13.363 8.97889 13.4139 8.94139 13.4514C8.90388 13.4889 8.85301 13.51 8.79996 13.51H7.19997C7.14692 13.51 7.09605 13.4889 7.05854 13.4514C7.02104 13.4139 6.99996 13.363 6.99996 13.31V10H5.99997Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/pin.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.4181 4.50005L14.5522 4.12501L13.0931 5.58411L9.07726 4.93638C8.89254 4.41665 8.56673 3.95859 8.13635 3.61361C7.70885 3.2727 7.19349 3.05996 6.65 3L6.1522 3.4978L6.20684 7.31591L0.5 7.30913L1.53633 8.34546L6.22719 8.3455L6.26814 11.7L6.78633 12.2182C7.32017 12.1748 7.82916 11.9743 8.24904 11.6418C8.66893 11.3093 8.98088 10.8597 9.14543 10.35L13.1477 9.82499L14.6477 11.325L15.5 10.9773L15.4181 4.50005ZM13.6931 8.95233L13.2568 8.80226L8.74314 9.40226L8.3545 9.70909C8.17577 10.2805 7.79848 10.769 7.29086 11.0864V8.35915L7.23631 4.17275C7.74931 4.50768 8.13571 5.00445 8.33406 5.58411L8.73631 5.90463L13.2704 6.63413L13.6931 6.49772L14.4772 5.71362L14.5317 9.75L13.6931 8.95233Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/pinned.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.10002 1.08186L3.72499 1.94778L5.18409 3.40687L4.53635 7.42274C4.01662 7.60746 3.55856 7.93327 3.21358 8.36365C2.87267 8.79115 2.65993 9.30651 2.59998 9.85L3.09777 10.3478L6.91588 10.2932L6.9091 16L7.94543 14.9637L7.94548 10.2728L11.3 10.2319L11.8181 9.71367C11.7748 9.17983 11.5742 8.67084 11.2417 8.25096C10.9092 7.83107 10.4597 7.51912 9.95002 7.35457L9.42496 3.35227L10.925 1.85227L10.5772 1L4.10002 1.08186ZM8.5523 2.80687L8.40224 3.24324L9.00224 7.75686L9.30907 8.1455C9.88043 8.32423 10.369 8.70152 10.6864 9.20914L7.95912 9.20914L3.77272 9.26369C4.10766 8.75069 4.60442 8.36429 5.18409 8.16594L5.5046 7.76369L6.23411 3.22959L6.0977 2.80687L5.31359 2.02277L9.34997 1.96825L8.5523 2.80687Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/play-circle.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.6 0.999985C10.2 1.09999 11.7 1.89999 12.8 2.99999C14.1 4.39999 14.8 6.09999 14.8 8.09999C14.8 9.69999 14.2 11.2 13.2 12.5C12.2 13.7 10.8 14.6 9.2 14.9C7.6 15.2 6 15 4.6 14.2C3.2 13.4 2.1 12.2 1.5 10.7C0.899997 9.19999 0.799997 7.49999 1.3 5.99999C1.8 4.39999 2.7 3.09999 4.1 2.19999C5.4 1.29999 7 0.899985 8.6 0.999985ZM9.1 13.9C10.4 13.6 11.6 12.9 12.5 11.8C13.3 10.7 13.8 9.39999 13.7 7.99999C13.7 6.39999 13.1 4.79999 12 3.69999C11 2.69999 9.8 2.09999 8.4 1.99999C7.1 1.89999 5.7 2.19999 4.6 2.99999C3.5 3.79999 2.7 4.89999 2.3 6.29999C1.9 7.59999 1.9 8.99999 2.5 10.3C3.1 11.6 4 12.6 5.2 13.3C6.4 14 7.8 14.2 9.1 13.9Z" fill="#C5C5C5"/>
<path d="M6.25 4.5L11.5 7.97949L6.25 11.5V4.5ZM7.125 9.85938L9.9209 7.98633L7.125 6.12695V9.85938Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/plug.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 1H6V4H4.5L4 4.5V8C4 9.06087 4.42143 10.0783 5.17157 10.8284C5.80289 11.4597 6.6235 11.8582 7.5 11.9686V15H8.5V11.9686C9.3765 11.8582 10.1971 11.4597 10.8284 10.8284C11.5786 10.0783 12 9.06087 12 8V4.5L11.5 4H10V1H9V4H7V1ZM10.1213 10.1213C9.55871 10.6839 8.79565 11 8 11C7.20435 11 6.44129 10.6839 5.87868 10.1213C5.31607 9.55871 5 8.79565 5 8V5H11V8C11 8.79565 10.6839 9.55871 10.1213 10.1213Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/preserve-case.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.53437 12.4673H7.4361L6.53859 10.0936H2.94854L2.10418 12.4673H1L4.24757 4H5.27499L8.53437 12.4673ZM6.21383 9.20202L4.88528 5.59426C4.84198 5.47617 4.79868 5.28722 4.75538 5.02741H4.73176C4.69239 5.26754 4.64712 5.45649 4.59595 5.59426L3.27921 9.20202H6.21383Z" fill="#C5C5C5"/>
<path d="M9.78617 12.4673V4H12.1953C12.9275 4 13.5081 4.17911 13.9372 4.53733C14.3662 4.89554 14.5808 5.36201 14.5808 5.93674C14.5808 6.41698 14.4509 6.83425 14.1911 7.18853C13.9313 7.54281 13.573 7.79474 13.1164 7.94433V7.96795C13.6872 8.03487 14.1438 8.25137 14.4863 8.61746C14.8288 8.97962 15 9.45199 15 10.0346C15 10.7589 14.7402 11.3454 14.2206 11.7942C13.701 12.2429 13.0456 12.4673 12.2543 12.4673H9.78617ZM10.7782 4.89751V7.63138H11.7938C12.337 7.63138 12.7641 7.50148 13.0751 7.24167C13.3861 6.97793 13.5415 6.6079 13.5415 6.13159C13.5415 5.30887 13.0003 4.89751 11.9178 4.89751H10.7782ZM10.7782 8.52299V11.5698H12.1244C12.707 11.5698 13.1577 11.432 13.4766 11.1565C13.7994 10.8809 13.9608 10.503 13.9608 10.0228C13.9608 9.02292 13.2798 8.52299 11.9178 8.52299H10.7782Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/preview.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 2H14L15 3V13L14 14H2L1 13V3L2 2ZM2 13H14V3H2V13ZM13 4H3V7H13V4ZM12 6H4V5H12V6ZM9 12H13V8H9V12ZM10 9H12V11H10V9ZM7 8H3V9H7V8ZM3 11H7V12H3V11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/primitive-square.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.5 4L4 3.5H12L12.5 4V12L12 12.5H4L3.5 12V4ZM4.5 4.5V11.5H11.5V4.5H4.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/project.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V14.5L14.5 15H1.5L1 14.5V1.5L1.5 1ZM2 14H14V2H2V14ZM3 3H5V13H3V3ZM9 3H7V9H9V3ZM11 3H13V11H11V3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/pulse.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.8 9L10 3H9L7.15801 9.64L5.99 4.69H5.02L3.85 9H1V9.99H4.23L4.72 9.62L5.46 6.92L6.59 12H7.62L9.49 4.96L10.95 9.64L11.43 10H15V9H11.8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/question.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.50001 1C6.21443 1 4.95772 1.38123 3.8888 2.09546C2.81988 2.80969 1.98679 3.82485 1.49482 5.01257C1.00285 6.20029 0.874083 7.50719 1.12489 8.76807C1.37569 10.0289 1.99478 11.1872 2.90382 12.0962C3.81286 13.0052 4.97107 13.6243 6.23194 13.8751C7.49282 14.1259 8.79972 13.9972 9.98744 13.5052C11.1752 13.0133 12.1903 12.1801 12.9045 11.1112C13.6188 10.0423 14 8.78558 14 7.5C14 5.77609 13.3152 4.1228 12.0962 2.90381C10.8772 1.68482 9.22392 1 7.50001 1ZM7.50001 13C6.41221 13 5.34881 12.6775 4.44434 12.0731C3.53987 11.4688 2.83493 10.6097 2.41865 9.60474C2.00237 8.59974 1.89344 7.4939 2.10566 6.427C2.31788 5.36011 2.84172 4.38015 3.61091 3.61096C4.3801 2.84177 5.36012 2.31793 6.42701 2.10571C7.49391 1.89349 8.59975 2.00242 9.60474 2.4187C10.6097 2.83498 11.4687 3.53987 12.0731 4.44434C12.6774 5.34881 13 6.4122 13 7.5C13 8.95869 12.4206 10.3576 11.3891 11.389C10.3577 12.4205 8.9587 13 7.50001 13ZM9.04999 4.57994C8.87722 4.40004 8.6697 4.25723 8.44 4.16002C8.151 4.04431 7.84117 3.98979 7.53003 3.99999C7.22804 3.9945 6.92825 4.05246 6.65002 4.17003C6.41146 4.27028 6.19928 4.42423 6.03003 4.61998C5.86442 4.8001 5.73536 5.01066 5.65002 5.23998C5.57068 5.47292 5.52028 5.7147 5.5 5.95995H6.72998C6.73725 5.74494 6.82673 5.54098 6.97998 5.39C7.05193 5.31511 7.13924 5.25671 7.2359 5.21874C7.33256 5.18076 7.43629 5.16414 7.53998 5.17003C7.62942 5.15581 7.72056 5.15581 7.81 5.17003C7.89216 5.2011 7.96708 5.24877 8.03003 5.31004C8.0995 5.37016 8.15422 5.4454 8.19 5.53001C8.23097 5.62465 8.25141 5.72683 8.25 5.82994C8.25037 6.00265 8.21283 6.17333 8.14001 6.32994C8.06739 6.49283 7.97681 6.6472 7.87 6.79002L7.52002 7.20995C7.40002 7.33995 7.27998 7.47998 7.16998 7.61998C7.06332 7.75933 6.97279 7.91024 6.90002 8.06993C6.83065 8.22732 6.79648 8.39797 6.79999 8.56993V9.22997H8V8.73998C8.00339 8.59331 8.04105 8.44943 8.10999 8.31993C8.19183 8.17576 8.28551 8.03871 8.39001 7.91002L8.75 7.46996C8.88106 7.31855 9.00134 7.15818 9.10999 6.98998C9.22491 6.81846 9.31894 6.63376 9.39001 6.43993C9.46294 6.23444 9.50013 6.01808 9.5 5.80003C9.50178 5.57285 9.46807 5.34675 9.40002 5.12999C9.32451 4.9235 9.20506 4.7358 9.04999 4.57994ZM6.8 9.82996H7.97V11H6.8V9.82996Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/quote.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.16 3.50003C4.73 5.06003 3.55 6.67003 3.55 9.36003C3.71 9.31003 3.85 9.31003 3.99 9.31003C5.26 9.31003 6.49 10.17 6.49 11.72C6.49 13.33 5.46 14.33 3.99 14.33C2.09 14.33 1 12.81 1 10.08C1 6.28003 2.75 3.55003 6.02 1.66003L7.16 3.50003ZM14.16 3.50003C11.73 5.06003 10.55 6.67003 10.55 9.36003C10.71 9.31003 10.85 9.31003 10.99 9.31003C12.26 9.31003 13.49 10.17 13.49 11.72C13.49 13.33 12.46 14.33 10.99 14.33C9.1 14.33 8.01 12.81 8.01 10.08C8.01 6.28003 9.76 3.55003 13.03 1.66003L14.17 3.50003H14.16V3.50003Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/quotes.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.24998 6.93C2.23585 6.31838 2.39202 5.71488 2.70105 5.18688C3.01007 4.65889 3.45979 4.22719 3.99998 3.94L3.45998 3C2.69254 3.41672 2.05607 4.0386 1.62166 4.79617C1.18725 5.55374 0.972005 6.41717 0.999976 7.29C0.999976 8.69 1.52998 9.46 2.46998 9.46C2.6408 9.46386 2.81047 9.43119 2.96765 9.36419C3.12482 9.29719 3.26588 9.19739 3.38138 9.07148C3.49688 8.94556 3.58416 8.79644 3.63738 8.63407C3.6906 8.47171 3.70853 8.29985 3.68998 8.13C3.69548 7.96784 3.66777 7.80626 3.60854 7.6552C3.54931 7.50414 3.45981 7.36679 3.34555 7.25159C3.23128 7.13639 3.09467 7.04577 2.9441 6.98531C2.79352 6.92485 2.63218 6.89582 2.46998 6.9V6.9C2.39539 6.89574 2.32069 6.90593 2.24998 6.93ZM5.68998 6.93C5.67352 6.31419 5.83081 5.7062 6.14384 5.17563C6.45687 4.64506 6.913 4.21338 7.45998 3.93V3.93L6.89998 3C6.13254 3.41672 5.49606 4.0386 5.06166 4.79617C4.62725 5.55374 4.412 6.41717 4.43998 7.29C4.43998 8.69 4.96998 9.46 5.89998 9.46C6.07117 9.46368 6.24119 9.43098 6.39881 9.36407C6.55643 9.29715 6.69805 9.19754 6.81431 9.07183C6.93057 8.94612 7.01883 8.79716 7.07325 8.6348C7.12766 8.47244 7.147 8.30039 7.12998 8.13C7.1341 7.96735 7.1051 7.80556 7.04474 7.65447C6.98439 7.50338 6.89394 7.36613 6.77889 7.25109C6.66384 7.13604 6.5266 7.04559 6.37551 6.98523C6.22441 6.92488 6.06263 6.89588 5.89998 6.9V6.9C5.82865 6.89517 5.7571 6.90539 5.68998 6.93V6.93ZM13.75 8.77C13.7664 9.38581 13.6091 9.9938 13.2961 10.5244C12.9831 11.0549 12.527 11.4866 11.98 11.77L12.54 12.71C13.3113 12.2926 13.9505 11.6678 14.3852 10.9061C14.8199 10.1445 15.0329 9.27638 15 8.4C15 7.01 14.47 6.23 13.53 6.23C13.3592 6.22614 13.1895 6.25881 13.0323 6.32581C12.8751 6.39281 12.7341 6.49261 12.6186 6.61852C12.5031 6.74444 12.4158 6.89356 12.3626 7.05593C12.3094 7.21829 12.2914 7.39015 12.31 7.56C12.3045 7.72216 12.3322 7.88374 12.3914 8.0348C12.4506 8.18586 12.5401 8.32321 12.6544 8.43841C12.7687 8.55361 12.9053 8.64423 13.0559 8.70469C13.2064 8.76515 13.3678 8.79418 13.53 8.79C13.6039 8.79282 13.6778 8.7861 13.75 8.77ZM10.31 8.77C10.3288 9.38625 10.1725 9.99521 9.85924 10.5262C9.54594 11.0572 9.0885 11.4885 8.53998 11.77L9.09998 12.71C9.8713 12.2926 10.5105 11.6678 10.9452 10.9061C11.3799 10.1445 11.5929 9.27638 11.56 8.4C11.56 7 11 6.23 10.1 6.23C9.92878 6.22632 9.75876 6.25902 9.60114 6.32593C9.44352 6.39285 9.3019 6.49246 9.18564 6.61817C9.06938 6.74388 8.98112 6.89284 8.92671 7.0552C8.87229 7.21756 8.85295 7.38961 8.86998 7.56C8.86586 7.72265 8.89486 7.88444 8.95521 8.03553C9.01557 8.18662 9.10602 8.32387 9.22106 8.43891C9.33611 8.55396 9.47335 8.64441 9.62444 8.70477C9.77554 8.76512 9.93733 8.79412 10.1 8.79C10.1706 8.79326 10.2413 8.78653 10.31 8.77Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/radio-tower.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.99841 5.57996C3.00865 4.12421 3.59044 2.73077 4.61841 1.69995L3.90839 1C3.30369 1.59963 2.82376 2.31304 2.49622 3.09912C2.16867 3.88521 2 4.72836 2 5.57996C2 6.43155 2.16867 7.27471 2.49622 8.06079C2.82376 8.84688 3.30369 9.56028 3.90839 10.1599L4.61841 9.45996C3.59044 8.42915 3.00865 7.0357 2.99841 5.57996ZM4.05839 5.57996C4.05581 6.16968 4.17129 6.75392 4.39799 7.29834C4.62469 7.84276 4.95803 8.33639 5.3784 8.75L6.08842 8.03992C5.75975 7.72367 5.50086 7.34217 5.32841 6.91992C5.14994 6.49573 5.05812 6.04016 5.05839 5.57996C5.05699 5.12287 5.14888 4.67035 5.32841 4.25C5.49829 3.82346 5.75742 3.43817 6.08842 3.12L5.3784 2.40991C4.95983 2.82487 4.62767 3.31868 4.4011 3.86279C4.17454 4.4069 4.05804 4.99056 4.05839 5.57996ZM11.7084 8.78992L10.9984 8.07996C11.3282 7.7608 11.5872 7.37578 11.7584 6.94995C11.9369 6.52576 12.0287 6.07019 12.0284 5.60999C12.0298 5.1529 11.938 4.70026 11.7584 4.27991C11.5885 3.85337 11.3294 3.46808 10.9984 3.1499L11.7084 2.44995C12.1263 2.86536 12.4579 3.35929 12.6841 3.90332C12.9104 4.44735 13.0269 5.03079 13.0269 5.62C13.0269 6.2092 12.9104 6.79252 12.6841 7.33655C12.4579 7.88058 12.1263 8.3745 11.7084 8.78992ZM13.0684 1L12.3584 1.70996C12.8718 2.21526 13.2796 2.81765 13.5579 3.48206C13.8362 4.14647 13.9795 4.85961 13.9795 5.57996C13.9795 6.3003 13.8362 7.01345 13.5579 7.67786C13.2796 8.34227 12.8718 8.94466 12.3584 9.44995L13.0684 10.1599C13.6731 9.56028 14.1531 8.84688 14.4807 8.06079C14.8082 7.27471 14.9768 6.43155 14.9768 5.57996C14.9768 4.72836 14.8082 3.88521 14.4807 3.09912C14.1531 2.31304 13.6731 1.59963 13.0684 1ZM9.99274 5.4303C10.027 5.77529 9.94063 6.12139 9.74841 6.40991C9.6654 6.49442 9.57503 6.57149 9.47839 6.64001L12.9184 14.37L11.9984 14.7699L11.2284 13.0399H5.68842L4.9184 14.7699L3.99841 14.37L7.43842 6.64001C7.22945 6.42892 7.08694 6.16121 7.02844 5.86999C6.96962 5.58172 6.99741 5.28249 7.1084 5.01001C7.22537 4.73395 7.41989 4.49769 7.6684 4.32995C7.95691 4.13774 8.30314 4.05136 8.64813 4.08557C8.99313 4.11978 9.31559 4.27243 9.56073 4.51758C9.80587 4.76272 9.95852 5.0853 9.99274 5.4303ZM8.39844 5.08996C8.30364 5.1123 8.21702 5.16082 8.14844 5.22998C8.09471 5.29346 8.05694 5.36888 8.03839 5.44995C8.00849 5.5443 8.00849 5.64563 8.03839 5.73999C8.07779 5.83075 8.13975 5.90991 8.21838 5.96997C8.30263 6.02177 8.39951 6.0494 8.49841 6.04993C8.63022 6.04737 8.7559 5.99385 8.84912 5.90063C8.94234 5.80741 8.99585 5.68173 8.99841 5.54993C8.99789 5.45103 8.9702 5.35414 8.9184 5.2699C8.85834 5.19126 8.77918 5.12936 8.68842 5.08996C8.59406 5.06006 8.49279 5.06006 8.39844 5.08996ZM8.62842 7.14001H8.3584L7.4884 9.07995H9.4884L8.62842 7.14001ZM10.8284 12.08L9.93842 10.08H7.05841L6.1684 12.08H10.8284Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/reactions.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 1H11V4H8V5H11V8H12V5H15V4H12V1ZM6 4.02242C3.19675 4.27504 1 6.63098 1 9.5C1 12.5376 3.46243 15 6.5 15C9.36902 15 11.725 12.8033 11.9776 10H10.9725C10.7238 12.25 8.81628 14 6.5 14C4.01472 14 2 11.9853 2 9.5C2 7.18372 3.75002 5.27619 6 5.02747V4.02242ZM4.5 9C5.05228 9 5.5 8.55229 5.5 8C5.5 7.44772 5.05228 7 4.5 7C3.94771 7 3.5 7.44772 3.5 8C3.5 8.55229 3.94771 9 4.5 9ZM6.5 11.5C7.21218 11.5 7.8548 11.2022 8.31014 10.7244L9.0174 11.4316C8.38096 12.0904 7.48832 12.5 6.5 12.5C5.49196 12.5 4.58345 12.0739 3.9448 11.3919L4.65244 10.6842C5.10965 11.1855 5.76809 11.5 6.5 11.5ZM8.5 9C9.05229 9 9.5 8.55228 9.5 8C9.5 7.44771 9.05229 7 8.5 7C7.94772 7 7.5 7.44771 7.5 8C7.5 8.55228 7.94772 9 8.5 9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/record-keys.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 3H3C2.73478 3 2.48044 3.10531 2.29291 3.29285C2.10537 3.48038 2 3.73478 2 4V11C2 11.2652 2.10537 11.5196 2.29291 11.7072C2.48044 11.8947 2.73478 12 3 12H14C14.2652 12 14.5196 11.8947 14.7071 11.7072C14.8946 11.5196 15 11.2652 15 11V4C15 3.73478 14.8946 3.48038 14.7071 3.29285C14.5196 3.10531 14.2652 3 14 3ZM14 11H3V4H14V11ZM11 5H10V6H11V5ZM10 7H9V8H10V7ZM12 5H13V6H12V5ZM13 9H12V10H13V9ZM6 9H11V10H6V9ZM13 7H11V8H13V7ZM8 5H9V6H8V5ZM8 7H7V8H8V7ZM4 9H5V10H4V9ZM4 5H5V6H4V5ZM7 5H6V6H7V5ZM4 7H6V8H4V7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/record-start.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 13.5C11.0376 13.5 13.5 11.0376 13.5 8C13.5 4.96243 11.0376 2.5 8 2.5C4.96243 2.5 2.5 4.96243 2.5 8C2.5 11.0376 4.96243 13.5 8 13.5Z" stroke="#C5C5C5"/>
<path d="M9.5 8C9.5 8.82843 8.82843 9.5 8 9.5C7.17157 9.5 6.5 8.82843 6.5 8C6.5 7.17157 7.17157 6.5 8 6.5C8.82843 6.5 9.5 7.17157 9.5 8Z" fill="#C5C5C5" stroke="#C5C5C5"/>
</svg>

```

`src/vsicons/record-stop.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 2C8.55078 2 9.08203 2.07227 9.59375 2.2168C10.1055 2.35742 10.582 2.55859 11.0234 2.82031C11.4688 3.08203 11.873 3.39648 12.2363 3.76367C12.6035 4.12695 12.918 4.53125 13.1797 4.97656C13.4414 5.41797 13.6426 5.89453 13.7832 6.40625C13.9277 6.91797 14 7.44922 14 8C14 8.55078 13.9277 9.08203 13.7832 9.59375C13.6426 10.1055 13.4414 10.584 13.1797 11.0293C12.918 11.4707 12.6035 11.875 12.2363 12.2422C11.873 12.6055 11.4688 12.918 11.0234 13.1797C10.582 13.4414 10.1055 13.6445 9.59375 13.7891C9.08203 13.9297 8.55078 14 8 14C7.44922 14 6.91797 13.9297 6.40625 13.7891C5.89453 13.6445 5.41602 13.4414 4.9707 13.1797C4.5293 12.918 4.125 12.6055 3.75781 12.2422C3.39453 11.875 3.08203 11.4707 2.82031 11.0293C2.55859 10.584 2.35547 10.1055 2.21094 9.59375C2.07031 9.08203 2 8.55078 2 8C2 7.44922 2.07031 6.91797 2.21094 6.40625C2.35547 5.89453 2.55859 5.41797 2.82031 4.97656C3.08203 4.53125 3.39453 4.12695 3.75781 3.76367C4.125 3.39648 4.5293 3.08203 4.9707 2.82031C5.41602 2.55859 5.89453 2.35742 6.40625 2.2168C6.91797 2.07227 7.44922 2 8 2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/record.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 10C9.10457 10 10 9.10457 10 8C10 6.89543 9.10457 6 8 6C6.89543 6 6 6.89543 6 8C6 9.10457 6.89543 10 8 10Z" fill="#F48771"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.6 0.999985C10.2 1.09999 11.7 1.89999 12.8 2.99999C14.1 4.39999 14.8 6.09999 14.8 8.09999C14.8 9.69999 14.2 11.2 13.2 12.5C12.2 13.7 10.8 14.6 9.2 14.9C7.6 15.2 6 15 4.6 14.2C3.2 13.4 2.1 12.2 1.5 10.7C0.899997 9.19999 0.799997 7.49999 1.3 5.99999C1.8 4.39999 2.7 3.09999 4.1 2.19999C5.4 1.29999 7 0.899985 8.6 0.999985ZM9.1 13.9C10.4 13.6 11.6 12.9 12.5 11.8C13.3 10.7 13.8 9.39999 13.7 7.99999C13.7 6.39999 13.1 4.79999 12 3.69999C11 2.69999 9.8 2.09999 8.4 1.99999C7.1 1.89999 5.7 2.19999 4.6 2.99999C3.5 3.79999 2.7 4.89999 2.3 6.29999C1.9 7.59999 1.9 8.99999 2.5 10.3C3.1 11.6 4 12.6 5.2 13.3C6.4 14 7.8 14.2 9.1 13.9Z" fill="#F48771"/>
</svg>

```

`src/vsicons/references.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.1052 4.5613L7.67505 7.98827L6.54072 6.86834L8.61098 4.78848H3.81131C3.17483 4.78848 2.56442 5.04132 2.11436 5.49138C1.6643 5.94144 1.41147 6.55184 1.41147 7.18832C1.41147 7.8248 1.6643 8.43521 2.11436 8.88527C2.56442 9.33532 3.17483 9.58816 3.81131 9.58816H4.70085V11.1881H3.8209C2.7921 11.142 1.8207 10.7009 1.10896 9.95661C0.397222 9.21231 0 8.22216 0 7.19232C0 6.16249 0.397222 5.17234 1.10896 4.42803C1.8207 3.68373 2.7921 3.24263 3.8209 3.19659H8.62058L6.54072 1.13112L7.67505 0L11.1052 3.43177V4.5613ZM16.6201 24H7.0207L6.22075 23.2V10.4121L7.0207 9.61215H16.6201L17.42 10.4121V23.2L16.6201 24ZM7.82064 22.4001H15.8201V11.212H7.82064V22.4001ZM13.4203 1.6015H23.0196L23.8196 2.40145V15.1878L23.0196 15.9877H19.0199V14.3878H22.2197V3.20139H14.2202V7.98828H12.6203V2.40145L13.4203 1.6015ZM14.2202 12.7879H9.42053V14.3878H14.2202V12.7879ZM9.42053 15.9877H14.2202V17.5876H9.42053V15.9877ZM14.2202 19.1875H9.42053V20.7874H14.2202V19.1875ZM15.8201 4.78848H20.6198V6.38838H15.8201V4.78848ZM20.6198 11.188H19.0199V12.7879H20.6198V11.188ZM17.2824 8.01228V7.98828H20.6198V9.58817H18.8583L17.2824 8.01228Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/refresh.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.56253 2.51577C3.46348 3.4501 2 5.55414 2 7.99999C2 11.3137 4.68629 14 8 14C11.3137 14 14 11.3137 14 7.99999C14 5.32519 12.2497 3.05919 9.83199 2.28482L9.52968 3.23832C11.5429 3.88454 13 5.7721 13 7.99999C13 10.7614 10.7614 13 8 13C5.23858 13 3 10.7614 3 7.99999C3 6.31104 3.83742 4.81767 5.11969 3.91245L5.56253 2.51577Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 3H2V2H5.5L6 2.5V6H5V3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/regex.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.0122 2H10.9879V5.11346L13.5489 3.55609L14.034 4.44095L11.4702 6L14.034 7.55905L13.5489 8.44391L10.9879 6.88654V10H10.0122V6.88654L7.45114 8.44391L6.96606 7.55905L9.5299 6L6.96606 4.44095L7.45114 3.55609L10.0122 5.11346V2ZM2 10H6V14H2V10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/remote-explorer.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.34375 2.125H21.6562L22.4375 2.90625V11.5048C21.9519 11.1401 21.4272 10.8346 20.875 10.593V3.6875H2.125V17.75H9.9375C9.9375 18.2593 9.9873 18.7698 10.0876 19.2741C10.3167 20.4256 10.8012 21.5058 11.5 22.4375H5.25V20.875H9.9375V19.3125H1.34375L0.5625 18.5312V2.90625L1.34375 2.125ZM17.75 11.5C16.5138 11.5 15.3054 11.8665 14.2776 12.5532C13.2498 13.24 12.4487 14.2161 11.9757 15.3582C11.5026 16.5002 11.379 17.757 11.6201 18.9694C11.8613 20.1817 12.4566 21.2952 13.3306 22.1693C14.2047 23.0434 15.3182 23.6387 16.5306 23.8798C17.743 24.121 18.9997 23.9974 20.1418 23.5243C21.2838 23.0513 22.26 22.2501 22.9467 21.2223C23.6335 20.1945 24 18.9861 24 17.75C24 16.0924 23.3414 14.5028 22.1693 13.3307C20.9972 12.1586 19.4076 11.5 17.75 11.5ZM17.75 22.4375C16.8229 22.4375 15.9165 22.1625 15.1457 21.6475C14.3748 21.1324 13.7741 20.4004 13.4193 19.5439C13.0645 18.6873 12.9716 17.7447 13.1525 16.8354C13.3334 15.9261 13.7798 15.091 14.4354 14.4354C15.0909 13.7799 15.9261 13.3334 16.8354 13.1525C17.7447 12.9717 18.6873 13.0646 19.5438 13.4194C20.4004 13.7742 21.1324 14.3749 21.6474 15.1457C22.1625 15.9166 22.4375 16.8229 22.4375 17.75C22.4375 18.9932 21.9436 20.1855 21.0646 21.0646C20.1855 21.9437 18.9932 22.4375 17.75 22.4375ZM20.3527 19.3056L18.1998 17.1526L20.3527 15L21 15.6465L19.4935 17.1526L21 18.6591L20.3527 19.3056ZM15 17.2464L16.5065 18.7528L15 20.2593L15.6473 20.9062L17.7999 18.7528L15.6473 16.5998L15 17.2464Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/remote.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.9041 9.57067L8.9281 5.59463L12.9041 1.6186L12.2854 0.999878L8.00002 5.28527V5.90399L12.2854 10.1894L12.9041 9.57067ZM3 5.61874L7.07191 9.69064L3 13.7626L3.61872 14.3813L7.99999 10V9.38128L3.61872 5.00002L3 5.61874Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/remove.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15 8H1V7H15V8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/rename.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 12.23V3.77L13.13 3H14V2H13L12.69 2.09L11.5 2.9L10.28 2.08L10 2H9V3H9.85L11 3.77V12.23L9.87 13H9V14H10L10.31 13.91L11.5 13.1L12.72 13.92L13 14H14V13H13.15L12 12.23Z" fill="#C5C5C5"/>
<path d="M1 10.5V5.5L1.5 5H10V6H2V10H10V11H1.5L1 10.5Z" fill="#C5C5C5"/>
<path d="M13 5H14.5L15 5.5V10.5L14.5 11H13V10H14V6H13V5Z" fill="#C5C5C5"/>
<path d="M3 7.5V8.5L3.5 9H7.5L8 8.5V7.5L7.5 7H3.5L3 7.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/replace-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.6009 2.67683C11.7474 2.36708 11.9559 2.2122 12.2263 2.2122C12.4742 2.2122 12.6651 2.32987 12.7991 2.56522C12.933 2.80056 13 3.12243 13 3.53082C13 3.97383 12.9218 4.32944 12.7653 4.59766C12.6088 4.86589 12.3997 5 12.138 5C11.9014 5 11.7224 4.87541 11.6009 4.62622H11.5934V4.93511H11V1H11.5934V2.67683H11.6009ZM11.584 3.77742C11.584 3.94873 11.6197 4.09063 11.6911 4.20311C11.7624 4.3156 11.8538 4.37184 11.9653 4.37184C12.1005 4.37184 12.205 4.30002 12.2789 4.15639C12.354 4.01103 12.3915 3.80597 12.3915 3.54121C12.3915 3.32144 12.3571 3.15012 12.2883 3.02726C12.2207 2.90266 12.1236 2.84036 11.9972 2.84036C11.8782 2.84036 11.7793 2.9018 11.7005 3.02466C11.6228 3.14752 11.584 3.30759 11.584 3.50487V3.77742ZM4.11969 7.695L2 5.56781L2.66188 4.90594L3.66781 5.90625V4.39594C3.66695 4.21309 3.70219 4.03187 3.7715 3.86266C3.84082 3.69346 3.94286 3.53961 4.07176 3.40992C4.20066 3.28023 4.3539 3.17727 4.52268 3.10692C4.69146 3.03658 4.87246 3.00024 5.05531 3H7.39906V3.90469H5.05531C4.92856 3.91026 4.8089 3.96476 4.72149 4.05672C4.63408 4.14868 4.58571 4.27094 4.58656 4.39781L4.59406 5.89781L5.54281 4.95375L6.19906 5.61L4.11969 7.695ZM9.3556 4.93017H10V3.22067C10 2.40689 9.68534 2 9.05603 2C8.92098 2 8.77083 2.02421 8.6056 2.07263C8.44181 2.12104 8.3125 2.17691 8.21767 2.24022V2.90503C8.45474 2.70205 8.70474 2.60056 8.96767 2.60056C9.22917 2.60056 9.35991 2.75698 9.35991 3.06983L8.76078 3.17318C8.25359 3.25885 8 3.57914 8 4.13408C8 4.39665 8.06106 4.60708 8.18319 4.76536C8.30675 4.92179 8.47557 5 8.68966 5C8.97989 5 9.19899 4.83985 9.34698 4.51955H9.3556V4.93017ZM9.35991 3.57542V3.76816C9.35991 3.9432 9.31968 4.08845 9.23922 4.20391C9.15876 4.3175 9.0546 4.3743 8.92672 4.3743C8.83477 4.3743 8.76149 4.34264 8.7069 4.27933C8.65374 4.21415 8.62716 4.13128 8.62716 4.03073C8.62716 3.80912 8.73779 3.6797 8.95905 3.64246L9.35991 3.57542ZM7 12.9302H6.3556V12.5196H6.34698C6.19899 12.8399 5.97989 13 5.68966 13C5.47557 13 5.30675 12.9218 5.18319 12.7654C5.06106 12.6071 5 12.3966 5 12.1341C5 11.5791 5.25359 11.2588 5.76078 11.1732L6.35991 11.0698C6.35991 10.757 6.22917 10.6006 5.96767 10.6006C5.70474 10.6006 5.45474 10.702 5.21767 10.905V10.2402C5.3125 10.1769 5.44181 10.121 5.6056 10.0726C5.77083 10.0242 5.92098 10 6.05603 10C6.68534 10 7 10.4069 7 11.2207V12.9302ZM6.35991 11.7682V11.5754L5.95905 11.6425C5.73779 11.6797 5.62716 11.8091 5.62716 12.0307C5.62716 12.1313 5.65374 12.2142 5.7069 12.2793C5.76149 12.3426 5.83477 12.3743 5.92672 12.3743C6.0546 12.3743 6.15876 12.3175 6.23922 12.2039C6.31968 12.0885 6.35991 11.9432 6.35991 11.7682ZM9.26165 13C9.58343 13 9.82955 12.9423 10 12.8268V12.1173C9.81999 12.2551 9.636 12.324 9.44803 12.324C9.23616 12.324 9.06969 12.2523 8.94863 12.1089C8.82756 11.9637 8.76702 11.7644 8.76702 11.5112C8.76702 11.2505 8.82995 11.0466 8.95579 10.8994C9.08323 10.7505 9.25528 10.676 9.47192 10.676C9.66627 10.676 9.84229 10.7449 10 10.8827V10.1341C9.87097 10.0447 9.66229 10 9.37395 10C8.95659 10 8.62286 10.1406 8.37276 10.4218C8.12425 10.7011 8 11.0838 8 11.5698C8 11.9907 8.11629 12.3343 8.34887 12.6006C8.58144 12.8669 8.8857 13 9.26165 13ZM2 9L3 8H12L13 9V14L12 15H3L2 14V9ZM3 9V14H12V9H3ZM6 7L7 6H14L15 7V12L14 13V12V7H7H6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/replace.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.221 3.739L5.482 6.008L7.7 3.784L7 3.084L5.988 4.091L5.98 2.491C5.97909 2.35567 6.03068 2.22525 6.12392 2.12716C6.21716 2.02908 6.3448 1.97095 6.48 1.965H8V1H6.48C6.28496 1.00026 6.09189 1.03902 5.91186 1.11405C5.73183 1.18908 5.56838 1.29892 5.43088 1.43725C5.29338 1.57558 5.18455 1.73969 5.11061 1.92018C5.03667 2.10066 4.99908 2.29396 5 2.489V4.1L3.927 3.033L3.221 3.739ZM9.89014 5.53277H9.90141C10.0836 5.84426 10.3521 6 10.707 6C11.0995 6 11.4131 5.83236 11.6479 5.49708C11.8826 5.1618 12 4.71728 12 4.16353C12 3.65304 11.8995 3.2507 11.6986 2.95652C11.4977 2.66234 11.2113 2.51525 10.8394 2.51525C10.4338 2.51525 10.1211 2.70885 9.90141 3.09604H9.89014V1H9V5.91888H9.89014V5.53277ZM9.87606 4.47177V4.13108C9.87606 3.88449 9.93427 3.6844 10.0507 3.53082C10.169 3.37724 10.3174 3.30045 10.4958 3.30045C10.6854 3.30045 10.831 3.37833 10.9324 3.53407C11.0357 3.68765 11.0873 3.9018 11.0873 4.17651C11.0873 4.50746 11.031 4.76379 10.9183 4.94549C10.8075 5.12503 10.6507 5.2148 10.4479 5.2148C10.2808 5.2148 10.1437 5.14449 10.0366 5.00389C9.92958 4.86329 9.87606 4.68592 9.87606 4.47177ZM9 12.7691C8.74433 12.923 8.37515 13 7.89247 13C7.32855 13 6.87216 12.8225 6.5233 12.4674C6.17443 12.1124 6 11.6543 6 11.0931C6 10.4451 6.18638 9.93484 6.55914 9.5624C6.93429 9.18747 7.43489 9.00001 8.06093 9.00001C8.49343 9.00001 8.80645 9.0596 9 9.17878V10.1769C8.76344 9.99319 8.4994 9.90132 8.20789 9.90132C7.88292 9.90132 7.62485 10.0006 7.43369 10.1993C7.24492 10.3954 7.15054 10.6673 7.15054 11.0149C7.15054 11.3526 7.24134 11.6183 7.42294 11.8119C7.60454 12.0031 7.85424 12.0987 8.17204 12.0987C8.454 12.0987 8.72999 12.0068 9 11.8231V12.7691ZM4 7L3 8V14L4 15H11L12 14V8L11 7H4ZM4 8H5H10H11V9V13V14H10H5H4V13V9V8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/reply.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.30644 2.14648L2.28644 6.16649V6.87359L6.30644 10.8936L7.01354 10.1865L3.80704 6.97998H5.68999C8.50315 6.97998 10.2949 7.58487 11.3952 8.70855C12.4974 9.83407 13.01 11.5857 13.01 14.13V14.48H14.01V14.13C14.01 11.4843 13.4826 9.4109 12.1097 8.00891C10.7351 6.60509 8.61683 5.97998 5.68999 5.97998H3.88716L7.01354 2.85359L6.30644 2.14648Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/repo-clone.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 10H3.99997V2H7.99997V1H3.73996C3.51061 1.00254 3.28363 1.04659 3.06998 1.13C2.85292 1.22447 2.65856 1.36429 2.49997 1.54004C2.33792 1.70959 2.21204 1.91029 2.12998 2.13C2.04772 2.32656 2.0036 2.53696 1.99997 2.75V12.25C1.99757 12.4798 2.0418 12.7078 2.12998 12.92C2.30529 13.3486 2.6433 13.6902 3.06998 13.87C3.28363 13.9534 3.51061 13.9975 3.73996 14H3.99997V13H3.73996C3.64018 13.0003 3.54145 12.9798 3.44998 12.9399C3.27129 12.8614 3.12854 12.7187 3.04996 12.54C3.03479 12.444 3.03479 12.3461 3.04996 12.25V11.75C3.03479 11.6539 3.03479 11.556 3.04996 11.46C3.12854 11.2813 3.27129 11.1386 3.44998 11.0601C3.54145 11.0202 3.64018 10.9997 3.73996 11H13V13H8.99997V14H13.5L14 13.5V9H13V10ZM6 3H5V4H6V3ZM5 5H6V6H5V5ZM5 7H6V8H5V7ZM5.28 15H5V12H8V15H7.72L6.5 13.49L5.28 15ZM10 1H14.5L15 1.5V7.5L14.5 8H12V9H11V8H10C9.73478 8 9.48044 7.89469 9.29291 7.70715C9.10537 7.51962 9 7.26522 9 7V2C9 1.73478 9.10537 1.48038 9.29291 1.29285C9.48044 1.10531 9.73478 1 10 1ZM10.5 7H11V6H10.5C10.3674 6 10.2402 6.05272 10.1464 6.14648C10.0527 6.24025 10 6.36739 10 6.5C10 6.63261 10.0527 6.75975 10.1464 6.85352C10.2402 6.94728 10.3674 7 10.5 7ZM12 7H14V6H12V7ZM11 5H14V2H11V5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/repo-force-push.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.74003 1H13.5L14 1.5V13.5L13.5 14H10V13H13V11H10V10H13V2H4.00003V10H7.00003V11H4.00003H3.74003H3.7399C3.64192 11 3.54491 11.0195 3.45451 11.0573C3.36408 11.0951 3.28205 11.1505 3.2132 11.2203C3.14435 11.29 3.09006 11.3728 3.05346 11.4637C3.01687 11.5547 2.9987 11.652 3.00003 11.75V12.25C2.9987 12.348 3.01687 12.4453 3.05346 12.5363C3.09006 12.6272 3.14435 12.71 3.2132 12.7797C3.28205 12.8495 3.36408 12.9049 3.45451 12.9427C3.54495 12.9805 3.642 13 3.74003 13H7.00003V14H3.74003C3.51068 14 3.2836 13.9547 3.07184 13.8666C2.86008 13.7785 2.66782 13.6495 2.50611 13.4868C2.34441 13.3242 2.21645 13.1312 2.1296 12.9189C2.04274 12.7067 1.99871 12.4793 2.00003 12.25V2.75C1.99871 2.52066 2.04274 2.29332 2.1296 2.08106C2.21645 1.8688 2.34441 1.6758 2.50611 1.51316C2.66782 1.35053 2.86008 1.22147 3.07184 1.1334C3.2836 1.04533 3.51068 0.999996 3.74003 1ZM5.34003 5.83L6.05003 6.53L8.00003 4.58V6.03L5.38003 8.65L6.09003 9.35L8.01003 7.43V15H9.01003V7.32819L11.04 9.35L11.74 8.65L9.00003 5.90028V4.53806L11 6.53L11.7 5.83L8.88003 3H8.17003L5.34003 5.83Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/repo-forked.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 3.99996C14.0007 3.62441 13.8957 3.25624 13.697 2.93758C13.4982 2.61893 13.2138 2.36267 12.8762 2.19813C12.5386 2.0336 12.1615 1.96744 11.7881 2.00723C11.4146 2.04702 11.06 2.19114 10.7646 2.42312C10.4693 2.65509 10.2452 2.96553 10.1181 3.3189C9.99093 3.67228 9.96585 4.05431 10.0457 4.42127C10.1256 4.78823 10.3071 5.12529 10.5696 5.39388C10.8321 5.66246 11.1649 5.85171 11.53 5.93996V6.99996C11.5316 7.09141 11.507 7.1814 11.4592 7.25935C11.4113 7.3373 11.3422 7.39996 11.26 7.43996L8.48997 8.87996L5.72997 7.47996C5.64204 7.43622 5.56929 7.36707 5.52115 7.28148C5.47301 7.19589 5.45169 7.09781 5.45997 6.99996V5.93996C5.9313 5.81827 6.34206 5.52885 6.61527 5.12596C6.88847 4.72307 7.00536 4.23437 6.94403 3.75146C6.88269 3.26856 6.64734 2.8246 6.28208 2.5028C5.91683 2.18101 5.44675 2.00347 4.95997 2.00347C4.47318 2.00347 4.0031 2.18101 3.63785 2.5028C3.2726 2.8246 3.03724 3.26856 2.97591 3.75146C2.91457 4.23437 3.03146 4.72307 3.30466 5.12596C3.57787 5.52885 3.98864 5.81827 4.45997 5.93996V6.99996C4.46054 7.27705 4.53735 7.54865 4.68198 7.785C4.82662 8.02135 5.03349 8.21334 5.27997 8.33996L7.99997 9.73996V11.06C7.52864 11.1817 7.11787 11.4711 6.84466 11.874C6.57146 12.2769 6.45457 12.7656 6.51591 13.2485C6.57724 13.7314 6.8126 14.1753 7.17785 14.4971C7.5431 14.8189 8.01318 14.9965 8.49997 14.9965C8.98675 14.9965 9.45683 14.8189 9.82208 14.4971C10.1873 14.1753 10.4227 13.7314 10.484 13.2485C10.5454 12.7656 10.4285 12.2769 10.1553 11.874C9.88206 11.4711 9.47129 11.1817 8.99997 11.06V9.73996L11.7 8.37996C11.9541 8.25221 12.1664 8.05437 12.3117 7.80983C12.457 7.56529 12.5293 7.28426 12.52 6.99996V5.91996C12.9428 5.80611 13.3167 5.5566 13.584 5.20975C13.8514 4.8629 13.9975 4.43789 14 3.99996ZM3.99997 3.99996C3.99997 3.80218 4.05861 3.60884 4.1685 3.44439C4.27838 3.27994 4.43456 3.15177 4.61728 3.07608C4.80001 3.0004 5.00108 2.98059 5.19506 3.01918C5.38904 3.05776 5.56722 3.153 5.70707 3.29286C5.84693 3.43271 5.94217 3.61089 5.98075 3.80487C6.01934 3.99885 5.99953 4.19992 5.92385 4.38265C5.84816 4.56537 5.71999 4.72155 5.55554 4.83143C5.39109 4.94131 5.19775 4.99996 4.99997 4.99996C4.73475 4.99996 4.4804 4.89461 4.29286 4.70707C4.10532 4.51953 3.99997 4.26518 3.99997 3.99996ZM9.46997 13C9.46997 13.1977 9.41132 13.3911 9.30144 13.5555C9.19155 13.72 9.03538 13.8482 8.85265 13.9238C8.66992 13.9995 8.46886 14.0193 8.27488 13.9807C8.08089 13.9422 7.90271 13.8469 7.76286 13.7071C7.62301 13.5672 7.52777 13.389 7.48918 13.1951C7.4506 13.0011 7.4704 12.8 7.54609 12.6173C7.62177 12.4346 7.74995 12.2784 7.9144 12.1685C8.07884 12.0586 8.27218 12 8.46997 12C8.60129 12 8.73132 12.0258 8.85265 12.0761C8.97397 12.1263 9.08421 12.2 9.17707 12.2929C9.26993 12.3857 9.34359 12.496 9.39385 12.6173C9.4441 12.7386 9.46997 12.8686 9.46997 13V13ZM12 4.99996C11.8022 4.99996 11.6088 4.94131 11.4444 4.83143C11.2799 4.72155 11.1518 4.56537 11.0761 4.38265C11.0004 4.19992 10.9806 3.99885 11.0192 3.80487C11.0578 3.61089 11.153 3.43271 11.2929 3.29286C11.4327 3.153 11.6109 3.05776 11.8049 3.01918C11.9989 2.98059 12.1999 3.0004 12.3826 3.07608C12.5654 3.15177 12.7216 3.27994 12.8314 3.44439C12.9413 3.60884 13 3.80218 13 3.99996C13 4.26518 12.8946 4.51953 12.7071 4.70707C12.5195 4.89461 12.2652 4.99996 12 4.99996Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/repo-pull.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 1.5V3H12V2H3V10H13V13.5L12.5 14H7.99997V13H12V11H3H2.73997H2.73548C2.63723 11.0003 2.54006 11.0207 2.44997 11.06C2.26893 11.1351 2.12507 11.279 2.04997 11.46C2.01802 11.5534 2.00114 11.6513 1.99997 11.75V12.25C2.00114 12.3487 2.01802 12.4466 2.04997 12.54C2.12507 12.721 2.26893 12.8649 2.44997 12.94C2.54144 12.9799 2.64019 13.0003 2.73997 13H2.99997V14H2.73997C2.51062 13.9975 2.28363 13.9534 2.06997 13.87C1.64453 13.6883 1.30712 13.3473 1.12997 12.92C1.04179 12.7078 0.997567 12.4798 0.999971 12.25V2.75C1.00408 2.53701 1.04817 2.3267 1.12997 2.13C1.21219 1.90913 1.33769 1.7069 1.4991 1.53518C1.66052 1.36346 1.8546 1.22571 2.06997 1.13C2.28363 1.04658 2.51062 1.00254 2.73997 1H12.5L13 1.5ZM2 10.17V2.74777L1.99997 2.75V10.17L2 10.17ZM5 3H4V4H5V3ZM5 5H4V6H5V5ZM4 7H5V8H4V7ZM12.07 3.39001L11.37 4.10001L13.29 6.02001H7V7.02001H13.39L11.37 9.05001L12.07 9.75001L14.9 6.93001V6.22001L12.07 3.39001ZM5.5 13.49L4.28 15H4V12H7V15H6.72L5.5 13.49Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/repo-push.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 1H3.74003C3.51068 0.999996 3.2836 1.04533 3.07184 1.1334C2.86008 1.22147 2.66782 1.35053 2.50611 1.51316C2.34441 1.6758 2.21645 1.8688 2.1296 2.08106C2.04274 2.29332 1.99871 2.52066 2.00003 2.75V12.25C1.99871 12.4793 2.04274 12.7067 2.1296 12.9189C2.21645 13.1312 2.34441 13.3242 2.50611 13.4868C2.66782 13.6495 2.86008 13.7785 3.07184 13.8666C3.2836 13.9547 3.51068 14 3.74003 14H7.00003V13H3.74003C3.642 13 3.54495 12.9805 3.45451 12.9427C3.36408 12.9049 3.28205 12.8495 3.2132 12.7797C3.14435 12.71 3.09006 12.6272 3.05346 12.5363C3.01687 12.4453 2.9987 12.348 3.00003 12.25V11.75C2.9987 11.652 3.01687 11.5547 3.05346 11.4637C3.09006 11.3728 3.14435 11.29 3.2132 11.2203C3.28205 11.1505 3.36408 11.0951 3.45451 11.0573C3.54491 11.0195 3.64192 11 3.7399 11C3.73994 11 3.73999 11 3.74003 11H4.00003H7.00003V10H4.00003V2H13V10H10V11H13V13H10V14H13.5L14 13.5V1.5L13.5 1ZM3.00003 2.72987C2.99994 2.73657 2.99994 2.74329 3.00003 2.75V10.17L3.00003 2.72987ZM6.00003 3H5.00003V4H6.00003V3ZM5.38004 8.64995L6.09004 9.34995L8.01004 7.42994V15H9.01004V7.32814L11.04 9.34995L11.74 8.64995L8.92004 5.81995H8.21004L5.38004 8.64995ZM5.00003 5H6.00003V6H5.00003V5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/repo.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.0001 10V1.5L13.5001 1H3.74009C3.51074 1.00254 3.28375 1.04658 3.07009 1.13C2.85473 1.22571 2.66064 1.36346 2.49922 1.53518C2.33781 1.7069 2.21231 1.90913 2.13009 2.13C2.0483 2.3267 2.0042 2.53701 2.00009 2.75V12.25C1.99769 12.4798 2.04191 12.7078 2.13009 12.92C2.30724 13.3473 2.64465 13.6883 3.07009 13.87C3.28375 13.9534 3.51074 13.9975 3.74009 14H4.00009V13H3.74009C3.64031 13.0003 3.54156 12.9799 3.45009 12.94C3.26905 12.8649 3.12519 12.721 3.05009 12.54C3.01814 12.4466 3.00126 12.3487 3.00009 12.25V11.75C3.00126 11.6513 3.01814 11.5534 3.05009 11.46C3.12519 11.279 3.26905 11.1351 3.45009 11.06C3.54019 11.0207 3.63735 11.0003 3.73561 11H3.74009H4.00009H13.0001V13H9.00009V14H13.5001L14.0001 13.5V11V10ZM4.00009 10V2H13.0001V10H4.00009ZM5.00009 3H6.00009V4H5.00009V3ZM5.00009 5H6.00009V6H5.00009V5ZM6.00009 7H5.00009V8H6.00009V7ZM6.50009 13.49L5.28009 15H5.00009V12H8.00009V15H7.72009L6.50009 13.49Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/report.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 1H14.5L15 1.5V11.5L14.5 12H7.707L4.854 14.854L4 14.5V12H1.5L1 11.5V1.5L1.5 1ZM7.5 11H14V2H2V11H4.5L5 11.5V13.293L7.146 11.146L7.5 11ZM7.5 3H8.5V8H7.5V3ZM7.5 10H8.5V9H7.5V10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/request-changes.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 1H1.5L1 1.5V11.5L1.5 12H4V14.5L4.854 14.854L7.707 12H14.5L15 11.5V1.5L14.5 1ZM14 11H7.5L7.146 11.146L5 13.293V11.5L4.5 11H2V2H14V11ZM10 10H6V8.97852H10V10ZM7.5 3H8.5V5H10.5V6H8.5V8H7.5V6H5.5V5H7.5V3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/rocket.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.491 1C10.8926 1.0045 7.83732 2.98269 5.65635 5H1.5L1 5.5V8.5L1.147 8.854L2.13796 9.84496L2.13899 9.854L6.13899 13.854L6.148 13.855L7.147 14.854L7.5 15H10.5L11 14.5V10.346C13.019 8.16839 14.996 5.11301 14.992 1.5L14.491 1ZM2 6H4.64307C3.59247 7.10401 2.8317 8.11996 2.41843 8.71094L2 8.293V6ZM7.7 14L7.28049 13.5766C7.87261 13.1655 8.88995 12.4085 9.995 11.3611V14H7.7ZM6.55699 12.856L3.13599 9.437C4.12799 8 8.37899 2.355 13.978 2.016C13.652 7.628 7.99099 11.869 6.55699 12.856ZM4 15V14H2V12H1V15H4ZM10.7475 7.33284C10.9122 7.08628 11 6.79647 11 6.50001C11 6.3026 10.961 6.10714 10.8853 5.92483C10.8096 5.74251 10.6987 5.57693 10.5589 5.43758C10.4191 5.29822 10.2531 5.18784 10.0706 5.11275C9.888 5.03766 9.6924 4.99935 9.495 5.00001C9.19854 5.001 8.90903 5.08981 8.66301 5.25523C8.417 5.42065 8.22552 5.65526 8.11275 5.92944C7.99999 6.20361 7.97099 6.50506 8.02943 6.7957C8.08788 7.08634 8.23113 7.35314 8.44111 7.56242C8.65108 7.7717 8.91837 7.91407 9.2092 7.97154C9.50003 8.02902 9.80138 7.99902 10.0752 7.88534C10.349 7.77167 10.5829 7.57941 10.7475 7.33284Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/root-folder-opened.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 6.25721V2.5L1.5 2H6.5L6.84998 2.15002L7.70996 3H13.5L14 3.5V6H15.13L15.61 6.63L12.98 13.63L12.5 14H8.7429C8.99653 13.6929 9.21745 13.3578 9.40035 13H12.13L14.5 7H8.7429C8.52568 6.73698 8.28448 6.49451 8.02265 6.27592L8.15002 6.15002L8.5 6H13V4H7.5L7.15002 3.84998L6.29004 3H2L2.0105 5.59439C1.64877 5.77833 1.31011 6.0011 1 6.25721Z" fill="#C5C5C5"/>
<path d="M6 10.5C6 11.3284 5.32843 12 4.5 12C3.67157 12 3 11.3284 3 10.5C3 9.67157 3.67157 9 4.5 9C5.32843 9 6 9.67157 6 10.5Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 10.5C8 12.433 6.433 14 4.5 14C2.567 14 1 12.433 1 10.5C1 8.567 2.567 7 4.5 7C6.433 7 8 8.567 8 10.5ZM4.5 13C5.88071 13 7 11.8807 7 10.5C7 9.11929 5.88071 8 4.5 8C3.11929 8 2 9.11929 2 10.5C2 11.8807 3.11929 13 4.5 13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/root-folder.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.70996 3H14.5L15.01 3.5V9V13.5L14.51 14H8.74284C8.99647 13.6929 9.21739 13.3578 9.40029 13H13.99V11.49L14 7.48999V5.98999H7.68994L7.67296 6.00697C7.39684 5.81162 7.10191 5.64108 6.79144 5.4986L7.14001 5.15002L7.48999 5H13.99L14 4.01001H7.5L7.14001 3.85999L6.29004 3.01001H2V5.59971C1.6461 5.78062 1.31438 5.99874 1.01001 6.24892V2.5L1.51001 2H6.51001L6.85999 2.15002L7.70996 3Z" fill="#C5C5C5"/>
<path d="M6 10.5C6 11.3284 5.32843 12 4.5 12C3.67157 12 3 11.3284 3 10.5C3 9.67157 3.67157 9 4.5 9C5.32843 9 6 9.67157 6 10.5Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 10.5C8 12.433 6.433 14 4.5 14C2.567 14 1 12.433 1 10.5C1 8.567 2.567 7 4.5 7C6.433 7 8 8.567 8 10.5ZM4.5 13C5.88071 13 7 11.8807 7 10.5C7 9.11929 5.88071 8 4.5 8C3.11929 8 2 9.11929 2 10.5C2 11.8807 3.11929 13 4.5 13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/rss.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 13H3V11C4.11 11 5 11.89 5 13ZM3 3V4C5.38695 4 7.67613 4.94821 9.36396 6.63604C11.0518 8.32387 12 10.6131 12 13H13C13 7.48 8.52 3 3 3ZM3 7V8C5.75 8 8 10.25 8 13H9C9 9.69 6.31 7 3 7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/ruby.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 7.19L7.64 13.83H8.36L15 7.19V6.47L11.68 3.15L11.32 3H4.68L4.32 3.15L1 6.47V7.19ZM8 12.75L2.08 6.83L4.89 4H11.11L13.92 6.83L8 12.75ZM8 5.02002H10.69L12.5 6.83002L8 11.23V5.02002Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/run-above.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.77 1.01001L1 1.42001V13.42L1.78 13.84L10.78 7.84001V7.01001L1.77 1.01001ZM2 12.49V2.36001L9.6 7.43001L2 12.49Z" fill="#C5C5C5"/>
<path d="M12.15 8H12.86L15.36 10.5L14.65 11.21L13 9.56V15H12V9.55L10.35 11.2L9.65002 10.5L12.15 8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/run-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.9146 8.24024L2 14.4805V2L10.9146 8.24024ZM2.995 12.5684L9.18093 8.24024L2.995 3.91209V12.5684ZM5.5 14.4805V13.2511L12.6809 8.24024L5.5 3.22935V2L14.4146 8.24024L5.5 14.4805Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/run-below.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.80002 1.01001L1.02002 1.42001V13.42L1.80002 13.84L10.8 7.84001V7.01001L1.80002 1.01001ZM2.02002 12.49V2.36001L9.62002 7.43001L2.02002 12.49Z" fill="#C5C5C5"/>
<path d="M12.85 15H12.14L9.64001 12.5L10.35 11.79L12 13.44V8H13V13.45L14.65 11.8L15.36 12.51L12.85 15Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/run.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 2V14.4805L12.9146 8.24024L4 2ZM11.1809 8.24024L4.995 12.5684V3.91209L11.1809 8.24024Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/save-all.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.85 2.65002L13.35 1.15002L13 1H4.47998L3.97998 1.5V4H1.5L1 4.5V14.5L1.5 15H11.5L12 14.5V12H14.5L15 11.5V3L14.85 2.65002ZM11 14H2V5H3V8.06995H9V5H9.79004L11 6.20996V14ZM6 7V5H8V7H6ZM14 11H12V6L11.85 5.65002L10.35 4.15002L10 4H5V2H12.8101L14.02 3.20996L14 11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/save-as.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.04 1.32996L12.71 3L13 3.70996V4.04004H12.5L12 4.54004V3.70996L10.33 2.04004H10V6.04004H4V2.04004H2V12.04H5L4.5 13.04H2L1 12.04V2.04004L2 1.04004H10.33L11.04 1.32996ZM7 5H9V2H7V5ZM13.5 5L15 6.5L14.98 7.18994L9.47998 12.6899L9.34998 12.8101L8.97998 13.1801L8.88 13.27L5.88 14.77L5.20996 14.1L6.70996 11.1L6.80005 11L7.17004 10.63L7.29004 10.5L12.79 5H13.5ZM7.28003 12.24L6.76001 13.24L7.80005 12.76L7.28003 12.24ZM7.96997 11.21L8.76001 12L13.91 6.84998L13.12 6.06006L7.96997 11.21Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/save.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.353 1.146L14.853 2.646L15 3V14.5L14.5 15H1.5L1 14.5V1.5L1.5 1H13L13.353 1.146ZM2 2V14H14V3.208L12.793 2H11V6H4V2H2ZM8 2V5H10V2H8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/screen-full.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3 12H13V4H3V12ZM5 6H11V10H5V6ZM2 6H1V2.5L1.5 2H5V3H2V6ZM15 2.5V6H14V3H11V2H14.5L15 2.5ZM14 10H15V13.5L14.5 14H11V13H14V10ZM2 13H5V14H1.5L1 13.5V10H2V13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/screen-normal.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.5 4H1V3H3V1H4V3.5L3.5 4ZM13 3V1H12V3.5L12.5 4H15V3H13ZM12 12.5V15H13V13H15V12H12.5L12 12.5ZM1 12V13H3V15H4V12.5L3.5 12H1ZM12 10.5L11.5 11H4.5L4 10.5V5.5L4.5 5H11.5L12 5.5V10.5ZM10 7H6V9H10V7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/search-stop.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.73804 3.31803C4.89412 4.16195 4.42004 5.30657 4.42004 6.50004C4.41962 7.17208 4.57039 7.83558 4.86121 8.44145C5.15202 9.04731 5.57536 9.58001 6.09998 10C6.03038 10.3287 5.99687 10.6641 6 11V11.1701C5.84 11.0601 5.68003 10.95 5.53003 10.83L1.75 14.5L1 13.84L4.80005 10.1501C4.21049 9.48341 3.79142 8.6836 3.57898 7.81938C3.36654 6.95515 3.36703 6.05229 3.58032 5.18827C3.79362 4.32426 4.21337 3.52488 4.80359 2.8588C5.39381 2.19273 6.1368 1.67988 6.96887 1.36418C7.80095 1.04847 8.6973 0.939388 9.58081 1.0463C10.4643 1.15322 11.3086 1.473 12.0414 1.97807C12.7741 2.48313 13.3734 3.15845 13.7877 3.94608C14.202 4.73372 14.419 5.61009 14.42 6.50004C14.4203 6.76784 14.4002 7.03533 14.36 7.30009C14.0728 7.03926 13.7576 6.81114 13.42 6.62003V6.50004C13.42 5.30657 12.9458 4.16195 12.1019 3.31803C11.258 2.47412 10.1135 2.00004 8.92004 2.00004C7.72657 2.00004 6.58195 2.47412 5.73804 3.31803ZM8.77769 7.67407C9.43548 7.23455 10.2089 7 11 7C12.0608 7 13.0782 7.42149 13.8283 8.17163C14.5785 8.92178 15 9.93913 15 11C15 11.7911 14.7654 12.5645 14.3259 13.2223C13.8864 13.8801 13.2616 14.3928 12.5307 14.6956C11.7998 14.9983 10.9955 15.0774 10.2196 14.9231C9.44366 14.7688 8.73102 14.3878 8.17161 13.8284C7.6122 13.269 7.23122 12.5563 7.07688 11.7804C6.92254 11.0045 7.00167 10.2001 7.30442 9.46924C7.60717 8.73833 8.11989 8.1136 8.77769 7.67407ZM8.87864 13.1213C9.44125 13.6839 10.2043 14 11 14C11.623 14.0018 12.2312 13.8095 12.74 13.45L8.55003 9.26001C8.19046 9.76883 7.99818 10.377 7.99998 11C7.99998 11.7956 8.31603 12.5587 8.87864 13.1213ZM9.25999 8.55005L13.4499 12.74C13.8095 12.2312 14.0018 11.623 14 11C14 10.2044 13.6839 9.44127 13.1213 8.87866C12.5587 8.31605 11.7956 8 11 8C10.3769 7.9982 9.7688 8.19048 9.25999 8.55005Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/search.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.25 1.02546e-06C13.6605 -0.000791296 12.1046 0.457574 10.7694 1.32007C9.43422 2.18256 8.37657 3.4124 7.72375 4.8617C7.07094 6.31099 6.85077 7.91801 7.0896 9.4895C7.32843 11.061 8.01604 12.5301 9.06995 13.72L1 22.88L2.12 23.88L10.17 14.76C11.2055 15.5693 12.4192 16.1196 13.7103 16.365C15.0014 16.6104 16.3325 16.5437 17.5927 16.1707C18.8528 15.7976 20.0055 15.1288 20.955 14.2201C21.9044 13.3114 22.623 12.1891 23.0509 10.9465C23.4789 9.70396 23.6038 8.37703 23.4153 7.07642C23.2267 5.77581 22.7302 4.53915 21.967 3.46924C21.2039 2.39933 20.1962 1.52711 19.0278 0.925416C17.8595 0.323719 16.5642 0.00991516 15.25 0.0100108V1.02546e-06ZM15.25 15C13.915 15 12.6099 14.6041 11.4999 13.8624C10.3898 13.1207 9.52469 12.0665 9.01379 10.8331C8.5029 9.59973 8.36919 8.24248 8.62964 6.93311C8.89009 5.62373 9.53305 4.42106 10.4771 3.47705C11.4211 2.53305 12.6237 1.89009 13.9331 1.62964C15.2425 1.36919 16.5997 1.5029 17.8331 2.01379C19.0665 2.52469 20.1207 3.38985 20.8624 4.49988C21.6041 5.60991 22 6.91498 22 8.25C22 10.0402 21.2888 11.7571 20.0229 13.023C18.7571 14.2888 17.0402 15 15.25 15Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/server-environment.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 3H10V4H6V3ZM6 9H10V10H6V9ZM6 11H10V12H6V11ZM15.1406 16H0.859375L2.10938 11H4V2C4 1.86458 4.02604 1.73698 4.07812 1.61719C4.13021 1.4974 4.20052 1.39062 4.28906 1.29688C4.3776 1.20312 4.48438 1.13021 4.60938 1.07812C4.73438 1.02604 4.86458 1 5 1H11C11.1354 1 11.263 1.02604 11.3828 1.07812C11.5026 1.13021 11.6094 1.20052 11.7031 1.28906C11.7969 1.3776 11.8698 1.48438 11.9219 1.60938C11.974 1.73438 12 1.86458 12 2V11H13.8906L15.1406 16ZM5 13H11V2H5V13ZM13.8594 15L13.1094 12H12V14H4V12H2.89062L2.14062 15H13.8594Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/server-process.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2H14.5L15 2.5V9H14V6H2V13H9V14H1.5L1 13.5V2.5L1.5 2ZM2 5H14V3H2V5ZM7 12V10.9062C6.83854 10.849 6.68229 10.7604 6.53125 10.6406L5.58594 11.1797L5.08594 10.3203L6.02344 9.77344C6.00781 9.6901 6 9.59896 6 9.5C6 9.40625 6.00781 9.3151 6.02344 9.22656L5.08594 8.67969L5.58594 7.82031L6.53125 8.35938C6.68229 8.23958 6.83854 8.15104 7 8.09375V7H8V8.09375C8.08854 8.125 8.16927 8.16146 8.24219 8.20312C8.3151 8.24479 8.39062 8.29688 8.46875 8.35938L9.41406 7.82031L9.91406 8.67969L8.97656 9.22656C8.99219 9.3151 9 9.40625 9 9.5C9 9.59896 8.99219 9.6901 8.97656 9.77344L9.91406 10.3203L9.41406 11.1797L8.46875 10.6406C8.39583 10.6979 8.32292 10.7474 8.25 10.7891C8.17708 10.8307 8.09375 10.8698 8 10.9062V12H7ZM6.75 9.5C6.75 9.70833 6.82292 9.88542 6.96875 10.0312C7.11458 10.1771 7.29167 10.25 7.5 10.25C7.70833 10.25 7.88542 10.1771 8.03125 10.0312C8.17708 9.88542 8.25 9.70833 8.25 9.5C8.25 9.29167 8.17708 9.11458 8.03125 8.96875C7.88542 8.82292 7.70833 8.75 7.5 8.75C7.29167 8.75 7.11458 8.82292 6.96875 8.96875C6.82292 9.11458 6.75 9.29167 6.75 9.5ZM12.0841 15V13.9062C11.9226 13.849 11.7664 13.7604 11.6153 13.6406L10.67 14.1797L10.17 13.3203L11.1075 12.7734C11.0919 12.6901 11.0841 12.599 11.0841 12.5C11.0841 12.4062 11.0919 12.3151 11.1075 12.2266L10.17 11.6797L10.67 10.8203L11.6153 11.3594C11.7664 11.2396 11.9226 11.151 12.0841 11.0938V10H13.0841V11.0938C13.1726 11.125 13.2533 11.1615 13.3263 11.2031C13.3992 11.2448 13.4747 11.2969 13.5528 11.3594L14.4981 10.8203L14.9981 11.6797L14.0606 12.2266C14.0763 12.3151 14.0841 12.4062 14.0841 12.5C14.0841 12.599 14.0763 12.6901 14.0606 12.7734L14.9981 13.3203L14.4981 14.1797L13.5528 13.6406C13.4799 13.6979 13.407 13.7474 13.3341 13.7891C13.2611 13.8307 13.1778 13.8698 13.0841 13.9062V15H12.0841ZM11.8341 12.5C11.8341 12.7083 11.907 12.8854 12.0528 13.0312C12.1986 13.1771 12.3757 13.25 12.5841 13.25C12.7924 13.25 12.9695 13.1771 13.1153 13.0312C13.2611 12.8854 13.3341 12.7083 13.3341 12.5C13.3341 12.2917 13.2611 12.1146 13.1153 11.9688C12.9695 11.8229 12.7924 11.75 12.5841 11.75C12.3757 11.75 12.1986 11.8229 12.0528 11.9688C11.907 12.1146 11.8341 12.2917 11.8341 12.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/server.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 5L2 4.5V1.5L2.5 1H13.5L14 1.5V4.5L13.5 5H2.5ZM10 2H9V3H8V2H7V3H6V2H5V3H4V2H3V4H13V2H11V3H10V2ZM2.5 10L2 9.5V6.5L2.5 6H13.5L14 6.5V9.5L13.5 10H2.5ZM6 7H5V8H4V7H3V9H13V7H11V8H10V7H9V8H8V7H7V8H6V7ZM13.5 15L14 14.5V11.5L13.5 11H2.5L2 11.5V14.5L2.5 15H13.5ZM3 14V12H4V13H5V12H6V13H7V12H8V13H9V12H10V13H11V12H13V14H3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/settings-gear.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.85 8.75L24 9.57996V14.42L19.85 15.25L22.2 18.77L18.77 22.2L15.25 19.85L14.42 24H9.57996L8.75 19.85L5.22998 22.2L1.80005 18.77L4.15002 15.25L0 14.42V9.57996L4.15002 8.75L1.80005 5.22998L5.22998 1.80005L8.75 4.15002L9.57996 0H14.42L15.25 4.15002L18.77 1.80005L22.2 5.22998L19.85 8.75ZM18.28 13.8199L22.28 13.01V11.01L18.28 10.2L17.74 8.90002L20.03 5.46997L18.6 4.04004L15.17 6.32996L13.87 5.79004L13.0601 1.79004H11.0601L10.25 5.79004L8.94995 6.32996L5.52002 4.04004L4.08997 5.46997L6.38 8.90002L5.83997 10.2L1.83997 11.01V13.01L5.83997 13.8199L6.38 15.12L4.08997 18.55L5.52002 19.98L8.94995 17.6899L10.25 18.23L11.0601 22.23H13.0601L13.87 18.23L15.17 17.6899L18.6 19.98L20.03 18.55L17.74 15.12L18.28 13.8199ZM10.0943 9.14807C10.6584 8.77118 11.3216 8.56995 12 8.56995C12.9089 8.57258 13.7798 8.93484 14.4225 9.57751C15.0652 10.2202 15.4274 11.0911 15.43 12C15.43 12.6784 15.2288 13.3416 14.8519 13.9056C14.475 14.4697 13.9394 14.9093 13.3126 15.1689C12.6859 15.4286 11.9962 15.4965 11.3308 15.3641C10.6654 15.2318 10.0543 14.9051 9.57457 14.4254C9.09488 13.9457 8.7682 13.3345 8.63585 12.6692C8.50351 12.0038 8.57143 11.3141 8.83104 10.6874C9.09065 10.0606 9.53029 9.52496 10.0943 9.14807ZM11.0499 13.4218C11.3311 13.6097 11.6618 13.71 12 13.71C12.2249 13.7113 12.4479 13.668 12.656 13.5825C12.8641 13.4971 13.0531 13.3712 13.2121 13.2122C13.3712 13.0531 13.497 12.8641 13.5825 12.656C13.668 12.4479 13.7113 12.2249 13.7099 12C13.7099 11.6618 13.6096 11.3311 13.4217 11.0499C13.2338 10.7687 12.9669 10.5496 12.6544 10.4202C12.3419 10.2907 11.9981 10.2569 11.6664 10.3229C11.3347 10.3889 11.03 10.5517 10.7909 10.7909C10.5517 11.03 10.3888 11.3347 10.3229 11.6664C10.2569 11.9981 10.2907 12.342 10.4202 12.6544C10.5496 12.9669 10.7687 13.2339 11.0499 13.4218Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/settings.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.5 2H2.5V7H3.5V2ZM9.6 7H6.4L6 6.45V5.45L6.4 5H9.6L10 5.5V6.5L9.6 7ZM4.6 10H1.4L1 9.5V8.5L1.4 8H4.6L5 8.5V9.5L4.6 10ZM8.5 2H7.5V4H8.5V2ZM7.5 8H8.5V14H7.5V8ZM3.5 11H2.5V14H3.5V11ZM11.4 11H14.59L14.99 10.5V9.55005L14.59 9.05005H11.4L11 9.55005V10.5L11.4 11ZM13.5 2H12.5V8H13.5V2ZM12.5 12H13.5V14H12.5V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/shield.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.24606 14.7126C7.74206 14.416 7.24039 14.0983 6.74106 13.7596C6.23968 13.4201 5.7576 13.0528 5.29706 12.6596C4.83895 12.2651 4.4086 11.8394 4.00906 11.3856C3.60819 10.9309 3.25594 10.4356 2.95806 9.90765C2.65925 9.37372 2.4243 8.80649 2.25806 8.21765C2.08428 7.59356 1.99746 6.94847 2.00006 6.30065V3.10065L2.50006 2.60065C2.83306 2.60065 3.15606 2.58965 3.46906 2.56465C3.76596 2.54212 4.06098 2.49936 4.35206 2.43665C4.63614 2.37502 4.91447 2.28938 5.18406 2.18065C5.46823 2.0629 5.74131 1.91999 6.00006 1.75365C6.3672 1.51235 6.76554 1.32227 7.18406 1.18865C7.83329 1.00105 8.51483 0.952661 9.18406 1.04665C9.40001 1.07645 9.61309 1.12429 9.82106 1.18965C10.0272 1.2534 10.2278 1.33366 10.4211 1.42965C10.6196 1.52668 10.8129 1.63416 11.0001 1.75165C11.2606 1.91872 11.5358 2.06197 11.8221 2.17965C12.0912 2.28878 12.3692 2.37444 12.6531 2.43565C12.9445 2.49842 13.2398 2.54152 13.5371 2.56465C13.8481 2.58865 14.1711 2.59965 14.5041 2.59965L15.0041 3.09965V6.30065C15.0074 6.94871 14.9213 7.59414 14.7481 8.21865C14.5818 8.80748 14.3469 9.37472 14.0481 9.90865C13.7502 10.4363 13.3983 10.9317 12.9981 11.3866C12.5989 11.8392 12.1692 12.2638 11.7121 12.6576C11.2505 13.0513 10.767 13.4185 10.2641 13.7576C9.76206 14.097 9.25872 14.4153 8.75406 14.7126H8.24606ZM3.00006 3.59065V6.30065C2.99643 6.85648 3.07014 7.41012 3.21906 7.94565C3.36304 8.45917 3.56782 8.95367 3.82906 9.41865C4.09327 9.8857 4.40528 10.3241 4.76006 10.7266C5.12934 11.1441 5.52623 11.5363 5.94806 11.9006C6.3796 12.2687 6.83094 12.6129 7.30006 12.9316C7.70006 13.1983 8.10006 13.4543 8.50006 13.6996C8.90006 13.4576 9.30006 13.2016 9.70006 12.9316C10.1704 12.6133 10.6228 12.2691 11.0551 11.9006C11.476 11.5368 11.8722 11.1452 12.2411 10.7286C12.5952 10.3258 12.9069 9.88746 13.1711 9.42065C13.4323 8.95568 13.6371 8.46117 13.7811 7.94765C13.9302 7.41147 14.0039 6.85715 14.0001 6.30065V3.59065C13.8425 3.59065 13.6885 3.57904 13.5363 3.56756L13.4571 3.56165C13.1149 3.53467 12.7749 3.48557 12.4391 3.41465C12.0998 3.33989 11.7674 3.23721 11.4451 3.10765C11.1031 2.96863 10.7744 2.79894 10.4631 2.60065C10.3073 2.50244 10.1464 2.41265 9.98106 2.33165C9.83281 2.25857 9.67899 2.19738 9.52106 2.14865C9.3635 2.09869 9.20189 2.06256 9.03806 2.04065C8.51711 1.9643 7.98586 2.00045 7.48006 2.14665C7.14761 2.2546 6.83112 2.40662 6.53906 2.59865C6.22786 2.7989 5.89919 2.9706 5.55706 3.11165C5.23266 3.2411 4.89821 3.34377 4.55706 3.41865C4.22162 3.48952 3.88189 3.53829 3.54006 3.56465C3.36606 3.57465 3.18506 3.58465 3.00006 3.59065ZM9.06498 7.88995C9.61338 7.66682 9.99999 7.12856 9.99999 6.5C9.99999 5.67157 9.32842 5 8.49999 5C7.67157 5 6.99999 5.67157 6.99999 6.5C6.99999 7.12856 7.3866 7.66682 7.935 7.88995L7.49999 10.5H9.49999L9.06498 7.88995Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/sign-in.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.02 3.77L11.03 3.76L12.02 4.75V2.5L11.52 2H2.52001L2.01001 2.5V2.99301L2 3.00003V13.29L2.36 13.75L7.36 15.47L8 15V14H11.52L12.02 13.5V11.25L11.02 12.25V13H8V4.71003L7.67 4.25003L4.03619 3H7.01001H11.02V3.77ZM7 14.28L3 12.94V3.72003L7 5.06003V14.28ZM10.09 7.53005H15.06V8.53005H10.13L11.72 10.1301L11.01 10.8301L8.53998 8.37005V7.66005L11.03 5.18005L11.73 5.88005L10.09 7.53005Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/sign-out.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.02 3.77V5.33L12.02 4.34V2.5L11.52 2H2.52002L2.02002 2.5V2.98599L2 3.00003V13.29L2.36 13.75L7.36 15.47L8 15V13.9999H11.52L12.02 13.4999V12.9999V11.6899L11.02 10.6899V12.9999H8V4.71003L7.67 4.25003L4.03619 3H7.02002H11.02V3.77ZM7 14.28L3 12.94V3.72003L7 5.06003V14.28ZM13.52 8.48005H8.54999V7.48005H13.48L11.88 5.88005L12.59 5.18005L15.06 7.64005V8.35005L12.57 10.8301L11.87 10.1301L13.52 8.48005Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/smiley.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.11101 2.17969C5.26216 1.41052 6.61552 1 7.99999 1C9.85651 1 11.637 1.73754 12.9498 3.05029C14.2625 4.36305 15 6.14348 15 8C15 9.38447 14.5895 10.7379 13.8203 11.889C13.0511 13.0402 11.9578 13.9373 10.6788 14.4672C9.39968 14.997 7.9922 15.1356 6.63433 14.8655C5.27646 14.5954 4.02919 13.9287 3.05022 12.9497C2.07126 11.9707 1.40461 10.7235 1.13451 9.3656C0.864416 8.00773 1.00301 6.60025 1.53283 5.32117C2.06264 4.04208 2.95987 2.94886 4.11101 2.17969ZM4.66656 12.9888C5.65325 13.6481 6.8133 14 7.99999 14C9.59129 14 11.1174 13.3679 12.2426 12.2427C13.3678 11.1175 14 9.5913 14 8C14 6.81331 13.6481 5.65332 12.9888 4.66663C12.3295 3.67993 11.3924 2.91079 10.2961 2.45667C9.19972 2.00254 7.99334 1.88372 6.82946 2.11523C5.66557 2.34675 4.59649 2.91821 3.75738 3.75732C2.91826 4.59644 2.3468 5.66558 2.11529 6.82947C1.88378 7.99335 2.00259 9.19979 2.45672 10.2961C2.91084 11.3925 3.67986 12.3295 4.66656 12.9888ZM6.5 7C6.5 7.55228 6.05228 8 5.5 8C4.94772 8 4.5 7.55228 4.5 7C4.5 6.44772 4.94772 6 5.5 6C6.05228 6 6.5 6.44772 6.5 7ZM11.5 7C11.5 7.55228 11.0523 8 10.5 8C9.94771 8 9.5 7.55228 9.5 7C9.5 6.44772 9.94771 6 10.5 6C11.0523 6 11.5 6.44772 11.5 7ZM8 11C7.45661 11.0013 6.92303 10.8551 6.4563 10.5768C5.98957 10.2985 5.60718 9.89871 5.34998 9.42004L4.47998 9.90002C4.83013 10.548 5.3524 11.0867 5.9892 11.4568C6.62599 11.8269 7.35259 12.0139 8.08893 11.9973C8.82526 11.9808 9.54277 11.7613 10.1623 11.363C10.7818 10.9647 11.2793 10.403 11.6 9.73999L10.7 9.31006C10.454 9.81684 10.0703 10.2441 9.59283 10.543C9.11534 10.8418 8.56332 11.0002 8 11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/sort-precedence.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 2L6 3V6H7V3H14V5.45306L14.2071 5.29286L15 6.08576V3L14 2H7ZM8 4H10V6H8V4ZM5 9H3V11H5V9ZM2 7L1 8V13L2 14H9L10 13V8L9 7H2ZM2 13V8H9V13H2ZM8 10H6V12H8V10ZM13 4H12V7.86388L10.818 6.68192L10.1109 7.38903L12.1465 9.42454L12.8536 9.42454L14.889 7.38908L14.1819 6.68197L13 7.86388V4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/source-control.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M21.0067 8.22168C21.0102 7.52792 20.8205 6.84689 20.4589 6.25485C20.0971 5.66281 19.5778 5.18315 18.959 4.86957C18.3401 4.556 17.6461 4.42091 16.9548 4.47941C16.2635 4.53793 15.6022 4.78773 15.0448 5.20085C14.4875 5.61397 14.0561 6.17409 13.7991 6.8185C13.5421 7.4629 13.4695 8.16613 13.5895 8.84944C13.7096 9.53274 14.0174 10.1692 14.4787 10.6874C14.94 11.2056 15.5365 11.5852 16.2012 11.7836C15.9558 12.2824 15.576 12.703 15.1047 12.9979C14.6334 13.2929 14.0892 13.4505 13.5331 13.4532H10.5437C9.43702 13.4571 8.37138 13.8727 7.55427 14.6191V7.39809C8.46159 7.21288 9.26783 6.69737 9.81668 5.95151C10.3655 5.20565 10.6178 4.28256 10.5248 3.36121C10.4317 2.43987 9.99985 1.5859 9.31292 0.964873C8.62599 0.343845 7.73295 0 6.80691 0C5.88087 0 4.98783 0.343845 4.3009 0.964873C3.61397 1.5859 3.18211 2.43987 3.08904 3.36121C2.99596 4.28256 3.24831 5.20565 3.79715 5.95151C4.34599 6.69737 5.15223 7.21288 6.05955 7.39809V16.5159C5.15393 16.6891 4.34299 17.1877 3.77969 17.9176C3.21639 18.6476 2.93968 19.5585 3.00173 20.4785C3.06379 21.3984 3.46033 22.2639 4.11656 22.9115C4.77279 23.5592 5.64335 23.9444 6.56403 23.9944C7.48472 24.0445 8.39187 23.7558 9.1144 23.183C9.83693 22.6102 10.3249 21.7928 10.4862 20.885C10.6475 19.9771 10.4712 19.0417 9.99023 18.255C9.50932 17.4683 8.75717 16.8848 7.87564 16.6145C8.12152 16.1162 8.50142 15.6963 8.97272 15.4019C9.44401 15.1074 9.98803 14.9503 10.5437 14.9479H13.5331C14.4658 14.9436 15.3739 14.6486 16.1311 14.1039C16.8882 13.5592 17.4566 12.792 17.7572 11.9091C18.6531 11.7914 19.476 11.3528 20.0735 10.6748C20.671 9.9968 21.0025 9.12533 21.0067 8.22168ZM4.56483 3.73752C4.56483 3.29408 4.69633 2.8606 4.94269 2.4919C5.18906 2.12319 5.53922 1.83581 5.9489 1.66611C6.3586 1.49642 6.8094 1.45202 7.24432 1.53854C7.67924 1.62504 8.07874 1.83857 8.3923 2.15214C8.70586 2.4657 8.9194 2.8652 9.00591 3.30012C9.09241 3.73504 9.04802 4.18585 8.87832 4.59553C8.70862 5.00521 8.42125 5.35539 8.05254 5.60175C7.68383 5.84811 7.25035 5.9796 6.80691 5.9796C6.21227 5.9796 5.642 5.74339 5.22152 5.32291C4.80105 4.90245 4.56483 4.33216 4.56483 3.73752ZM9.04899 20.1794C9.04899 20.6229 8.91749 21.0563 8.67113 21.425C8.42476 21.7937 8.0746 22.0811 7.66492 22.2508C7.25523 22.4205 6.80442 22.4649 6.36951 22.3784C5.93458 22.292 5.53509 22.0784 5.22152 21.7648C4.90796 21.4512 4.69443 21.0517 4.60791 20.6169C4.52141 20.1819 4.5658 19.7311 4.7355 19.3214C4.9052 18.9117 5.19258 18.5615 5.56128 18.3152C5.92999 18.0689 6.36347 17.9373 6.80691 17.9373C7.40155 17.9373 7.97183 18.1736 8.3923 18.594C8.81277 19.0145 9.04899 19.5848 9.04899 20.1794ZM17.2699 10.4638C16.8265 10.4638 16.393 10.3322 16.0243 10.0859C15.6556 9.83954 15.3683 9.48937 15.1986 9.07969C15.0289 8.67 14.9844 8.2192 15.0709 7.78427C15.1574 7.34935 15.3709 6.94985 15.6845 6.63629C15.9981 6.32273 16.3976 6.10919 16.8325 6.02268C17.2674 5.93617 17.7183 5.98058 18.1279 6.15027C18.5377 6.31997 18.8878 6.60734 19.1341 6.97605C19.3805 7.34476 19.512 7.77823 19.512 8.22168C19.512 8.81632 19.2757 9.3866 18.8553 9.80706C18.4348 10.2275 17.8645 10.4638 17.2699 10.4638Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/split-horizontal.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 1H3L2 2V13L3 14H14L15 13V2L14 1ZM8 13H3V2H8V13ZM14 13H9V2H14V13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/split-vertical.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 1H3L2 2V13L3 14H14L15 13V2L14 1ZM14 13H3V8H14V13ZM14 7H3V2H14V7Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/squirrel.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.55808 2.64202C5.51696 2.63805 5.47578 2.63476 5.43455 2.63217C5.41748 2.56415 5.39552 2.49729 5.36879 2.43211C5.29488 2.25195 5.18592 2.08827 5.04822 1.95057C4.91052 1.81288 4.74684 1.70391 4.56668 1.63C4.38652 1.5561 4.19347 1.51872 3.99874 1.52005V2.82739C3.24174 3.12824 2.57169 3.61317 2.0493 4.2383C1.52556 4.86504 1.16687 5.61281 1.00587 6.41355V6.80339C1.46476 7.6402 2.91182 7.93433 3.1597 7.98471C3.18719 7.9903 3.19994 7.99289 3.19495 7.99289C0.775961 8.31276 1.00587 10.2419 1.00587 10.2419C1.0236 10.4947 1.1367 10.7314 1.32227 10.9039C1.50784 11.0765 1.75203 11.1722 2.00545 11.1716C2.2765 11.1535 2.54301 11.0928 2.79511 10.9916H4.85425C4.67577 11.3008 4.5539 11.6393 4.4944 11.9912H4.17454C3.56971 12.0824 3.01782 12.388 2.61961 12.8522C2.2214 13.3165 2.00341 13.9085 2.00545 14.5202C1.99704 14.5777 2.00066 14.6363 2.01607 14.6923C2.03149 14.7483 2.05838 14.8005 2.09502 14.8456C2.13166 14.8907 2.17727 14.9277 2.22896 14.9543C2.28064 14.9809 2.33728 14.9964 2.39528 15H9.07248C9.61565 15.0277 10.1584 14.9372 10.6632 14.7348C11.168 14.5324 11.6228 14.2228 11.9963 13.8274C12.3698 13.4321 12.6531 12.9604 12.8265 12.4449C12.9999 11.9294 13.0594 11.3824 13.0008 10.8417C12.974 10.0844 12.7119 9.35419 12.2512 8.75257L12.1412 8.61263C11.7114 8.06286 11.4615 7.70301 11.5914 7.32317C11.7214 6.94333 11.956 6.92334 11.956 6.92334C11.956 6.92334 12.1412 6.89335 12.4111 7.0133C12.6314 7.14132 12.8711 7.23248 13.1208 7.28319C13.3552 7.3275 13.5965 7.31814 13.8268 7.25582C14.0571 7.19349 14.2702 7.07982 14.4502 6.92334C14.6232 6.77291 14.7618 6.58706 14.8566 6.37838C14.9515 6.1697 15.0004 5.94307 15 5.71385C15.0059 4.99563 14.6695 4.25935 14.2751 3.6263C13.8808 2.99326 13.3497 2.4565 12.721 2.05538C11.9131 1.62378 10.9815 1.48263 10.0821 1.65555C9.44538 1.76761 8.8608 2.07915 8.41276 2.54517C8.05535 2.93495 7.78904 3.39929 7.63309 3.9046C7.44984 3.63238 7.23657 3.38194 6.99748 3.15793V2.9994C7.00019 2.61311 6.85067 2.24129 6.58128 1.96442C6.31189 1.68754 5.9443 1.52789 5.55808 1.52002V2.64202ZM10.8619 11.3808C10.9733 12.1224 11.0813 13.2023 9.99525 13.8227C9.69884 13.9264 9.38747 13.9832 9.07248 13.9904H3.21494C3.21413 13.7386 3.3084 13.4957 3.47889 13.3104C3.64939 13.1251 3.88354 13.0109 4.13455 12.9908H5.41402V12.491C5.40871 12.256 5.44975 12.0223 5.53479 11.8032C5.61984 11.5841 5.74722 11.3838 5.90967 11.214C6.07212 11.0441 6.26644 10.9079 6.48154 10.8132C6.66726 10.7313 6.86533 10.6818 7.06723 10.6665L6.44143 9.77855C6.20521 9.84573 5.97805 9.93175 5.86383 10.012H2.65517C2.56893 10.012 2.4796 10.0474 2.39082 10.0826C2.25324 10.137 2.11696 10.191 1.99545 10.112C1.79553 9.98206 2.1054 8.99247 3.00503 8.99247H4.00461C4.4944 8.99247 4.57437 8.4527 4.57437 8.4527L4.85425 7.32317C4.33991 7.39701 3.81548 7.35158 3.3215 7.19039C2.82753 7.0292 2.37724 6.75656 2.00545 6.39356C2.16456 5.66747 2.55801 5.01384 3.12518 4.53337C3.69234 4.05291 4.40176 3.77226 5.14413 3.73468C5.17312 3.73571 5.20092 3.73656 5.22781 3.73737C5.48831 3.74528 5.6627 3.75057 6.00377 3.9046C6.93338 4.32443 8.15287 6.37357 8.15287 6.37357L8.21284 6.46353H8.38277V6.39356C8.32288 5.95075 8.3627 4.93039 8.49932 4.50495C8.63595 4.0795 8.86593 3.68997 9.17244 3.36483C9.5247 3.01272 9.97976 2.78169 10.4719 2.70511C11.1062 2.56999 11.7681 2.67318 12.3311 2.99499C12.7917 3.27899 13.1814 3.66428 13.4707 4.12156C13.7599 4.57883 13.9466 4.95781 14.0059 5.49563C14.0048 5.51527 14.0062 5.54327 14.0079 5.57707C14.0151 5.71998 14.0275 5.96664 13.8799 6.12367C13.7531 6.25862 13.4321 6.35438 13.2107 6.3036C13.0524 6.26727 12.9007 6.20657 12.7609 6.12367C12.5927 6.01833 12.4031 5.95198 12.2059 5.9295C12.0087 5.90701 11.809 5.92896 11.6214 5.99373C11.3931 6.06736 11.1871 6.19766 11.0228 6.37246C10.8585 6.54727 10.7412 6.76087 10.6818 6.99331C10.5815 7.38979 10.5879 7.80573 10.7003 8.19896C10.8126 8.59219 11.0269 8.94871 11.3215 9.23237L11.4315 9.37231C11.7775 9.80567 11.977 10.3377 12.0013 10.8917C12.0146 11.288 11.9492 11.683 11.8088 12.0539C11.7749 12.1434 11.7368 12.2311 11.6947 12.3166C11.688 12.2368 11.6778 12.157 11.664 12.0776C11.5972 11.6941 11.4487 11.331 11.2304 11.0122L10.8619 11.3808ZM4.24 5C4.10739 5 3.98021 5.05268 3.88644 5.14645C3.79268 5.24021 3.74 5.36739 3.74 5.5C3.74 5.63261 3.79268 5.75979 3.88644 5.85355C3.98021 5.94732 4.10739 6 4.24 6C4.37261 6 4.49978 5.94732 4.59355 5.85355C4.68732 5.75979 4.74 5.63261 4.74 5.5C4.74 5.36739 4.68732 5.24021 4.59355 5.14645C4.49978 5.05268 4.37261 5 4.24 5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/star-empty.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.59454 6.25211L8 1L6.40546 6.25211H1L5.37311 9.65247L3.7496 15L8 11.695L12.2504 15L10.6269 9.65247L15 6.25211H9.59454ZM2.34804 6.72168H6.72044L8 2.50706L8.00002 2.50708L6.72046 6.7217H2.34805L2.34804 6.72168ZM5.88539 9.4722L4.57848 13.7769L4.57851 13.7769L5.8854 9.47221L5.88539 9.4722ZM13.6519 6.7217L13.652 6.72168H9.27956L9.27958 6.7217H13.6519ZM4.90113 7.6229H7.26847L8.00002 5.21332L8.73156 7.6229H11.0989L9.18369 9.1121L9.91523 11.5217L8.00002 10.0325L6.0848 11.5217L6.81635 9.1121L4.90113 7.6229Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/star-full.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.59454 6.25211L8 1L6.40546 6.25211H1L5.37311 9.65247L3.7496 15L8 11.695L12.2504 15L10.6269 9.65247L15 6.25211H9.59454Z" fill="#FF8E00"/>
</svg>

```

`src/vsicons/star-half.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.40546 6.25211L8 1L9.59454 6.25211H15L10.6269 9.65247L12.2504 15L8 11.695L3.7496 15L5.37311 9.65247L1 6.25211H6.40546ZM8 10.0325L8.00002 10.0325L9.91523 11.5217L9.18369 9.1121L11.0989 7.6229H8.73156L8.00002 5.21332L8 5.21338V10.0325V10.0325ZM8 2.50714L8.00002 2.50708L8 2.50706V2.50714ZM13.6519 6.7217L13.652 6.72168H9.27956L9.27958 6.7217H13.6519Z" fill="#FF8E00"/>
</svg>

```

`src/vsicons/stop-circle.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="6" y="6" width="4" height="4" fill="#F48771"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.6 0.999985C10.2 1.09999 11.7 1.89999 12.8 2.99999C14.1 4.39999 14.8 6.09999 14.8 8.09999C14.8 9.69999 14.2 11.2 13.2 12.5C12.2 13.7 10.8 14.6 9.2 14.9C7.6 15.2 6 15 4.6 14.2C3.2 13.4 2.1 12.2 1.5 10.7C0.899997 9.19999 0.799997 7.49999 1.3 5.99999C1.8 4.39999 2.7 3.09999 4.1 2.19999C5.4 1.29999 7 0.899985 8.6 0.999985ZM9.1 13.9C10.4 13.6 11.6 12.9 12.5 11.8C13.3 10.7 13.8 9.39999 13.7 7.99999C13.7 6.39999 13.1 4.79999 12 3.69999C11 2.69999 9.8 2.09999 8.4 1.99999C7.1 1.89999 5.7 2.19999 4.6 2.99999C3.5 3.79999 2.7 4.89999 2.3 6.29999C1.9 7.59999 1.9 8.99999 2.5 10.3C3.1 11.6 4 12.6 5.2 13.3C6.4 14 7.8 14.2 9.1 13.9Z" fill="#F48771"/>
</svg>

```

`src/vsicons/symbol-array.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2L1 2.5V13.5L1.5 14H4V13H2V3H4V2H1.5ZM14.5 14L15 13.5L15 2.5L14.5 2H12V3L14 3L14 13H12V14H14.5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-boolean.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 3.5L1.5 3H14.5L15 3.5L15 12.5L14.5 13H1.5L1 12.5V3.5ZM14 4H8L8 7.49297L7.89793 7.49285L7.5 7.49225V7.49237L3.92614 7.48807L6.01638 5.39784L5.30927 4.69073L2.35356 7.64645L2.35356 8.35355L5.30927 11.3093L6.01638 10.6022L3.90228 8.48807L7.8976 8.49285L8 8.493V7.50702L11.9073 7.51222L9.79289 5.39784L10.5 4.69073L13.4557 7.64645V8.35355L10.5 11.3093L9.79289 10.6022L11.8828 8.51222L8 8.50702V12H14V4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-class.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.34 9.70998H12.05L14.72 7.04005V6.32997L13.38 5.00001H12.68L10.86 6.81007H5.86V5.56007L7.71999 3.70997V3L5.71998 1H5.00001L1 5.00001V5.70997L3 7.70998H3.71003L4.84998 6.56007V12.35L5.34998 12.85H10V13.37L11.33 14.71H12.04L14.7101 12.0401V11.33L13.37 10H12.67L10.81 11.85H5.81001V7.84999H10V8.32997L11.34 9.70998ZM13.0301 6.06007L13.66 6.68995L11.66 8.68996L11.0301 8.06007L13.0301 6.06007ZM13.0301 11.0601L13.66 11.69L11.66 13.69L11.0301 13.0601L13.0301 11.0601ZM3.34998 6.65004L2.06 5.34998L5.34998 2.06006L6.65004 3.34998L3.34998 6.65004Z" fill="#EE9D28"/>
</svg>

```

`src/vsicons/symbol-color.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 1.00305C6.14348 1.00305 4.36299 1.74059 3.05023 3.05334C1.73748 4.3661 1 6.14654 1 8.00305V8.43311C1.09 9.94311 2.91 10.2231 4 9.13306C4.35648 8.81625 4.82054 8.64759 5.29724 8.66162C5.77395 8.67565 6.22729 8.87127 6.56451 9.2085C6.90174 9.54572 7.09736 9.99912 7.11139 10.4758C7.12542 10.9525 6.95682 11.4166 6.64001 11.7731C5.54001 12.9331 5.85 14.843 7.44 14.973H8.03998C9.89649 14.973 11.677 14.2356 12.9897 12.9229C14.3025 11.6101 15.04 9.82954 15.04 7.97302C15.04 6.11651 14.3025 4.33607 12.9897 3.02332C11.677 1.71056 9.89649 0.973022 8.03998 0.973022L8 1.00305ZM8 14.0031H7.47998C7.34751 13.9989 7.22047 13.9495 7.12 13.863C7.04052 13.7807 6.98815 13.6761 6.96997 13.5631C6.9381 13.3682 6.95328 13.1684 7.01416 12.9806C7.07504 12.7927 7.17989 12.6222 7.32001 12.483C7.84048 11.9474 8.13165 11.2299 8.13165 10.483C8.13165 9.73615 7.84048 9.0187 7.32001 8.48303C7.05348 8.21635 6.73699 8.00481 6.38867 7.86047C6.04036 7.71614 5.66702 7.64185 5.28998 7.64185C4.91294 7.64185 4.5396 7.71614 4.19128 7.86047C3.84297 8.00481 3.52654 8.21635 3.26001 8.48303C3.15068 8.61081 3.01089 8.709 2.85358 8.76843C2.69626 8.82786 2.52649 8.84657 2.35999 8.823C2.27593 8.80694 2.19903 8.76498 2.14001 8.703C2.07131 8.6224 2.03556 8.5189 2.03998 8.41309V8.04309C2.03998 6.8564 2.39192 5.69629 3.05121 4.70959C3.7105 3.7229 4.64754 2.95388 5.7439 2.49976C6.84025 2.04563 8.04669 1.92681 9.21057 2.15833C10.3745 2.38984 11.4435 2.9613 12.2827 3.80042C13.1218 4.63953 13.6932 5.70867 13.9247 6.87256C14.1562 8.03644 14.0374 9.24275 13.5833 10.3391C13.1291 11.4355 12.3601 12.3726 11.3734 13.0319C10.3867 13.6911 9.22667 14.0431 8.03998 14.0431L8 14.0031ZM9 3.99683C9 4.54911 8.55228 4.99683 8 4.99683C7.44771 4.99683 7 4.54911 7 3.99683C7 3.44454 7.44771 2.99683 8 2.99683C8.55228 2.99683 9 3.44454 9 3.99683ZM12 11.0037C12 11.5559 11.5523 12.0037 11 12.0037C10.4477 12.0037 10 11.5559 10 11.0037C10 10.4514 10.4477 10.0037 11 10.0037C11.5523 10.0037 12 10.4514 12 11.0037ZM5 6.00415C5.55229 6.00415 6 5.55644 6 5.00415C6 4.45187 5.55229 4.00415 5 4.00415C4.44772 4.00415 4 4.45187 4 5.00415C4 5.55644 4.44772 6.00415 5 6.00415ZM12 5.00415C12 5.55644 11.5523 6.00415 11 6.00415C10.4477 6.00415 10 5.55644 10 5.00415C10 4.45187 10.4477 4.00415 11 4.00415C11.5523 4.00415 12 4.45187 12 5.00415ZM13.0001 7.99939C13.0001 8.55167 12.5524 8.99939 12.0001 8.99939C11.4478 8.99939 11.0001 8.55167 11.0001 7.99939C11.0001 7.4471 11.4478 6.99939 12.0001 6.99939C12.5524 6.99939 13.0001 7.4471 13.0001 7.99939Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-constant.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 6H12V7H4V6ZM12 9H4V10H12V9Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 4L2 3H14L15 4V12L14 13H2L1 12V4ZM2 4V12H14V4H2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-enum-member.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 3L8 2H14L15 3V8L14 9H10V8H14V3H8V6H7V3ZM9 9V8L8 7H7H2L1 8V13L2 14H8L9 13V9ZM8 8V9V13H2V8H7H8ZM9.41421 7L9 6.58579V6H13V7H9.41421ZM9 4H13V5H9V4ZM7 10H3V11H7V10Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/symbol-enum.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 2H8L7 3V6H8V3H14V8H10V9H14L15 8V3L14 2ZM9 6H13V7H9.41L9 6.59V6ZM7 7H2L1 8V13L2 14H8L9 13V8L8 7H7ZM8 13H2V8H8V9V13ZM3 9H7V10H3V9ZM3 11H7V12H3V11ZM9 4H13V5H9V4Z" fill="#EE9D28"/>
</svg>

```

`src/vsicons/symbol-event.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.41354 1.55996L8.31152 1H11.6056L12.424 2.57465L10.2356 6H12.0174L12.7363 7.69512L5.61943 15L4.01675 13.837L6.11943 10H4.89798L4 8.55996L7.41354 1.55996ZM7.78033 9L4.90054 14.3049L12.0174 7H8.31152L11.6056 2H8.31152L4.89798 9H7.78033Z" fill="#EE9D28"/>
</svg>

```

`src/vsicons/symbol-field.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.45 4.5L9.44995 2H8.55005L1.55005 5.5L1 6.39001V10.89L1.55005 11.79L6.55005 14.29H7.44995L14.45 10.79L15 9.89001V5.39001L14.45 4.5ZM6.44995 13.14L1.94995 10.89V7.17004L6.44995 9.17004V13.14ZM6.94995 8.33997L2.29004 6.22998L8.94995 2.89001L13.62 5.22998L6.94995 8.33997ZM13.95 9.89001L7.44995 13.14V9.20996L13.95 6.20996V9.89001Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/symbol-file.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.85 4.44L10.57 1.14L10.22 1H2.5L2 1.5V14.5L2.5 15H13.5L14 14.5V4.8L13.85 4.44ZM13 5H10V2L13 5ZM3 14V2H9V5.5L9.5 6H13V14H3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-interface.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.4965 4C10.655 3.9989 9.84136 4.30189 9.20557 4.85315C8.56977 5.40442 8.15465 6.16684 8.0365 7H4.9364C4.8147 6.52867 4.52533 6.11794 4.12244 5.84473C3.71955 5.57152 3.23083 5.45466 2.74792 5.51599C2.26502 5.57733 1.82106 5.81261 1.49927 6.17786C1.17747 6.54311 1 7.01322 1 7.5C1 7.98679 1.17747 8.45689 1.49927 8.82215C1.82106 9.1874 2.26502 9.42267 2.74792 9.48401C3.23083 9.54535 3.71955 9.42848 4.12244 9.15528C4.52533 8.88207 4.8147 8.47133 4.9364 8H8.0365C8.13236 8.66418 8.41717 9.28683 8.85693 9.7937C9.2967 10.3006 9.87284 10.6703 10.5168 10.8589C11.1609 11.0475 11.8455 11.047 12.4893 10.8574C13.133 10.6679 13.7087 10.2973 14.1477 9.7898C14.5867 9.28227 14.8706 8.65919 14.9655 7.99488C15.0603 7.33056 14.9621 6.65298 14.6827 6.04285C14.4034 5.43272 13.9545 4.91578 13.3895 4.55359C12.8246 4.19141 12.1675 3.99922 11.4965 4V4ZM11.4965 10C11.002 10 10.5187 9.85332 10.1075 9.57862C9.69642 9.30391 9.37599 8.91348 9.18677 8.45667C8.99755 7.99985 8.94809 7.49728 9.04456 7.01233C9.14102 6.52738 9.37901 6.08181 9.72864 5.73218C10.0783 5.38255 10.5238 5.14456 11.0088 5.0481C11.4937 4.95164 11.9963 5.00109 12.4531 5.19031C12.9099 5.37953 13.3004 5.69996 13.5751 6.11109C13.8498 6.52221 13.9965 7.00555 13.9965 7.5C13.9965 8.16304 13.7331 8.79898 13.2643 9.26783C12.7954 9.73667 12.1595 10 11.4965 10V10Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/symbol-key.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.22289 10.933C7.54863 11.1254 7.92163 11.2231 8.29989 11.215C8.63777 11.2218 8.97254 11.1492 9.27721 11.003C9.58188 10.8567 9.84792 10.6409 10.0539 10.373C10.5091 9.76519 10.7402 9.01867 10.7079 8.25998C10.7412 7.58622 10.5374 6.9221 10.1319 6.38298C9.93575 6.14161 9.68577 5.94957 9.402 5.82228C9.11824 5.69498 8.80858 5.63597 8.49789 5.64997C8.07522 5.64699 7.65994 5.76085 7.29789 5.97898C7.18304 6.04807 7.0749 6.12775 6.97489 6.21698V3.47498H5.98389V11.1H6.97889V10.756C7.05516 10.8217 7.13677 10.8809 7.22289 10.933ZM7.84981 6.70006C8.03598 6.62105 8.23807 6.58677 8.43989 6.59998C8.61257 6.59452 8.78404 6.63054 8.93994 6.70501C9.09583 6.77948 9.23161 6.89023 9.33589 7.02798C9.59253 7.39053 9.7184 7.82951 9.69289 8.27297C9.71972 8.79748 9.57969 9.31701 9.29289 9.75698C9.18822 9.91527 9.04546 10.0447 8.87773 10.1335C8.70999 10.2223 8.52264 10.2675 8.33289 10.265C8.14934 10.2732 7.9663 10.24 7.79734 10.1678C7.62838 10.0956 7.47784 9.98628 7.35689 9.84797C7.10152 9.55957 6.96501 9.18506 6.97489 8.79998V8.19998C6.96299 7.78332 7.10263 7.3765 7.36789 7.05498C7.49858 6.90064 7.66364 6.77908 7.84981 6.70006ZM3.28902 5.67499C2.97011 5.67933 2.65388 5.734 2.35202 5.83699C2.06417 5.92293 1.79347 6.05828 1.55202 6.23699L1.45202 6.31399V7.51399L1.87502 7.15499C2.24579 6.80478 2.73133 6.60146 3.24102 6.58299C3.36593 6.57164 3.4917 6.59147 3.60706 6.64068C3.72243 6.6899 3.82377 6.76697 3.90202 6.86499C4.0522 7.0971 4.13239 7.36754 4.13302 7.64399L2.90002 7.82499C2.39435 7.87781 1.91525 8.07772 1.52202 8.39999C1.36697 8.55181 1.24339 8.73271 1.15835 8.93235C1.07331 9.13199 1.02848 9.34644 1.02644 9.56343C1.0244 9.78042 1.06517 9.99568 1.14644 10.1969C1.2277 10.3981 1.34786 10.5813 1.50002 10.736C1.6687 10.8904 1.86622 11.01 2.08125 11.0879C2.29627 11.1659 2.52456 11.2005 2.75302 11.19C3.147 11.1931 3.53278 11.0774 3.86002 10.858C3.96153 10.7897 4.0572 10.7131 4.14602 10.629V11.073H5.08702V7.71499C5.12137 7.17422 4.9543 6.63988 4.61802 6.21499C4.44979 6.03285 4.24348 5.89003 4.01378 5.7967C3.78407 5.70336 3.53661 5.66181 3.28902 5.67499ZM4.14602 8.71599C4.16564 9.13435 4.02592 9.54459 3.75502 9.864C3.63689 10.0005 3.48998 10.1092 3.32486 10.1821C3.15973 10.2551 2.98049 10.2906 2.80002 10.286C2.69049 10.2945 2.58035 10.2812 2.47599 10.2469C2.37163 10.2125 2.27511 10.1579 2.19202 10.086C2.06079 9.93455 1.98856 9.74088 1.98856 9.54049C1.98856 9.34011 2.06079 9.14644 2.19202 8.99499C2.47322 8.82131 2.79233 8.71837 3.12202 8.69499L4.14202 8.54699L4.14602 8.71599ZM12.4588 11.0325C12.766 11.1638 13.0983 11.2261 13.4322 11.215C13.927 11.227 14.4153 11.1006 14.8422 10.85L14.9652 10.775L14.9782 10.768V9.61504L14.5322 9.93504C14.216 10.1592 13.8356 10.2747 13.4482 10.264C13.2497 10.2719 13.052 10.2342 12.8703 10.1538C12.6886 10.0733 12.5278 9.95232 12.4002 9.80004C12.1144 9.42453 11.9725 8.95911 12.0002 8.48804C11.9737 7.98732 12.1352 7.49475 12.4532 7.10704C12.5934 6.94105 12.7695 6.80914 12.9682 6.7213C13.167 6.63346 13.3831 6.592 13.6002 6.60004C13.9439 6.59844 14.2808 6.69525 14.5712 6.87904L15.0002 7.14404V5.97004L14.8312 5.89704C14.4626 5.73432 14.0641 5.6502 13.6612 5.65004C13.2999 5.63991 12.9406 5.70762 12.6078 5.84859C12.2749 5.98956 11.9763 6.20048 11.7322 6.46704C11.2261 7.02683 10.9581 7.76186 10.9852 8.51604C10.9567 9.22346 11.1955 9.91569 11.6542 10.455C11.8769 10.704 12.1516 10.9012 12.4588 11.0325Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-keyword.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15 4H10V3H15V4ZM14 7H12V8H14V7ZM10 7H1V8H10V7ZM12 13H1V14H12V13ZM7 10H1V11H7V10ZM15 10H10V11H15V10ZM8 2V5H1V2H8ZM7 3H2V4H7V3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-method.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.51 4L8.51001 1H7.51001L2.51001 4L2.02002 4.85999V10.86L2.51001 11.71L7.51001 14.71H8.51001L13.51 11.71L14 10.86V4.85999L13.51 4ZM7.51001 13.5601L3.01001 10.86V5.69995L7.51001 8.15002V13.5601ZM3.27002 4.69995L8.01001 1.85999L12.75 4.69995L8.01001 7.29004L3.27002 4.69995ZM13.01 10.86L8.51001 13.5601V8.15002L13.01 5.69995V10.86Z" fill="#B180D7"/>
</svg>

```

`src/vsicons/symbol-misc.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 2H12V6C12.3415 6.03511 12.6774 6.11234 13 6.22998V1H3V9.47998L4 7.72998V2ZM6.14001 10L5 8L4 9.75L3.29004 11L1 15H9L6.70996 11L6.14001 10ZM2.71997 14L4.43994 11L5 10L5.56006 11L7.28003 14H2.71997ZM9.55552 7.58984C10.1311 7.20526 10.8077 7 11.5 7C12.4282 7 13.3185 7.36877 13.9748 8.02515C14.6312 8.68152 15 9.57174 15 10.5C15 11.1922 14.7947 11.8689 14.4101 12.4445C14.0256 13.02 13.4789 13.4686 12.8393 13.7335C12.1998 13.9984 11.4961 14.0678 10.8171 13.9327C10.1382 13.7977 9.51461 13.4643 9.02513 12.9749C8.53564 12.4854 8.20229 11.8618 8.06724 11.1829C7.93219 10.5039 8.00155 9.80019 8.26646 9.16064C8.53137 8.5211 8.97995 7.97443 9.55552 7.58984ZM10.1111 12.5786C10.5222 12.8533 11.0055 13 11.5 13C12.163 13 12.799 12.7367 13.2678 12.2678C13.7366 11.799 14 11.163 14 10.5C14 10.0055 13.8533 9.52221 13.5786 9.11108C13.3039 8.69996 12.9135 8.37953 12.4566 8.19031C11.9998 8.00109 11.4973 7.95163 11.0123 8.0481C10.5274 8.14456 10.0818 8.38255 9.73216 8.73218C9.38253 9.08181 9.14454 9.52738 9.04808 10.0123C8.95161 10.4973 9.00107 10.9998 9.19029 11.4567C9.37951 11.9135 9.69994 12.3039 10.1111 12.5786Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-namespace.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 2.98361V2.97184V2H5.91083C5.59743 2 5.29407 2.06161 5.00128 2.18473C4.70818 2.30798 4.44942 2.48474 4.22578 2.71498C4.00311 2.94422 3.83792 3.19498 3.73282 3.46766L3.73233 3.46898C3.63382 3.7352 3.56814 4.01201 3.53533 4.29917L3.53519 4.30053C3.50678 4.5805 3.4987 4.86844 3.51084 5.16428C3.52272 5.45379 3.52866 5.74329 3.52866 6.03279C3.52866 6.23556 3.48974 6.42594 3.412 6.60507L3.4116 6.60601C3.33687 6.78296 3.23423 6.93866 3.10317 7.07359C2.97644 7.20405 2.82466 7.31055 2.64672 7.3925C2.4706 7.46954 2.28497 7.5082 2.08917 7.5082H2V7.6V8.4V8.4918H2.08917C2.28465 8.4918 2.47001 8.53238 2.64601 8.61334L2.64742 8.61396C2.82457 8.69157 2.97577 8.79762 3.10221 8.93161L3.10412 8.93352C3.23428 9.0637 3.33659 9.21871 3.41129 9.39942L3.41201 9.40108C3.48986 9.58047 3.52866 9.76883 3.52866 9.96721C3.52866 10.2567 3.52272 10.5462 3.51084 10.8357C3.4987 11.1316 3.50677 11.4215 3.53516 11.7055L3.53535 11.7072C3.56819 11.9903 3.63387 12.265 3.73232 12.531L3.73283 12.5323C3.83793 12.805 4.00311 13.0558 4.22578 13.285C4.44942 13.5153 4.70818 13.692 5.00128 13.8153C5.29407 13.9384 5.59743 14 5.91083 14H6V13.2V13.0164H5.91083C5.71095 13.0164 5.52346 12.9777 5.34763 12.9008C5.17396 12.8191 5.02194 12.7126 4.89086 12.5818C4.76386 12.4469 4.66104 12.2911 4.58223 12.1137C4.50838 11.9346 4.47134 11.744 4.47134 11.541C4.47134 11.3127 4.4753 11.0885 4.48321 10.8686C4.49125 10.6411 4.49127 10.4195 4.48324 10.2039C4.47914 9.98246 4.46084 9.76883 4.42823 9.56312C4.39513 9.35024 4.33921 9.14757 4.26039 8.95536C4.18091 8.76157 4.07258 8.57746 3.93616 8.40298C3.82345 8.25881 3.68538 8.12462 3.52283 8C3.68538 7.87538 3.82345 7.74119 3.93616 7.59702C4.07258 7.42254 4.18091 7.23843 4.26039 7.04464C4.33913 6.85263 4.39513 6.65175 4.42826 6.44285C4.46082 6.2333 4.47914 6.01973 4.48324 5.80219C4.49127 5.58262 4.49125 5.36105 4.48321 5.13749C4.4753 4.9134 4.47134 4.68725 4.47134 4.45902C4.47134 4.26019 4.50833 4.07152 4.58238 3.89205C4.66135 3.71034 4.76421 3.55475 4.89086 3.42437C5.02193 3.28942 5.17461 3.18275 5.34802 3.10513C5.5238 3.02427 5.71113 2.98361 5.91083 2.98361H6ZM10 13.0164V13.0282V14H10.0892C10.4026 14 10.7059 13.9384 10.9987 13.8153C11.2918 13.692 11.5506 13.5153 11.7742 13.285C11.9969 13.0558 12.1621 12.805 12.2672 12.5323L12.2677 12.531C12.3662 12.2648 12.4319 11.988 12.4647 11.7008L12.4648 11.6995C12.4932 11.4195 12.5013 11.1316 12.4892 10.8357C12.4773 10.5462 12.4713 10.2567 12.4713 9.96721C12.4713 9.76444 12.5103 9.57406 12.588 9.39493L12.5884 9.39399C12.6631 9.21704 12.7658 9.06134 12.8968 8.92642C13.0236 8.79595 13.1753 8.68945 13.3533 8.6075C13.5294 8.53046 13.715 8.4918 13.9108 8.4918H14V8.4V7.6V7.5082H13.9108C13.7153 7.5082 13.53 7.46762 13.354 7.38666L13.3526 7.38604C13.1754 7.30844 13.0242 7.20238 12.8978 7.06839L12.8959 7.06648C12.7657 6.9363 12.6634 6.78129 12.5887 6.60058L12.588 6.59892C12.5101 6.41953 12.4713 6.23117 12.4713 6.03279C12.4713 5.74329 12.4773 5.45379 12.4892 5.16428C12.5013 4.86842 12.4932 4.57848 12.4648 4.29454L12.4646 4.29285C12.4318 4.00971 12.3661 3.73502 12.2677 3.46897L12.2672 3.46766C12.1621 3.19499 11.9969 2.94422 11.7742 2.71498C11.5506 2.48474 11.2918 2.30798 10.9987 2.18473C10.7059 2.06161 10.4026 2 10.0892 2H10V2.8V2.98361H10.0892C10.2891 2.98361 10.4765 3.0223 10.6524 3.09917C10.826 3.18092 10.9781 3.28736 11.1091 3.41823C11.2361 3.55305 11.339 3.70889 11.4178 3.88628C11.4916 4.0654 11.5287 4.25596 11.5287 4.45902C11.5287 4.68727 11.5247 4.91145 11.5168 5.13142C11.5088 5.35894 11.5087 5.58049 11.5168 5.79605C11.5209 6.01754 11.5392 6.23117 11.5718 6.43688C11.6049 6.64976 11.6608 6.85243 11.7396 7.04464C11.8191 7.23843 11.9274 7.42254 12.0638 7.59702C12.1765 7.74119 12.3146 7.87538 12.4772 8C12.3146 8.12462 12.1765 8.25881 12.0638 8.40298C11.9274 8.57746 11.8191 8.76157 11.7396 8.95536C11.6609 9.14737 11.6049 9.34825 11.5717 9.55715C11.5392 9.7667 11.5209 9.98027 11.5168 10.1978C11.5087 10.4174 11.5087 10.6389 11.5168 10.8625C11.5247 11.0866 11.5287 11.3128 11.5287 11.541C11.5287 11.7398 11.4917 11.9285 11.4176 12.1079C11.3386 12.2897 11.2358 12.4452 11.1091 12.5756C10.9781 12.7106 10.8254 12.8173 10.652 12.8949C10.4762 12.9757 10.2889 13.0164 10.0892 13.0164H10Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-numeric.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 1V5H15V6H11L11 10H15V11H11V15H10V11H6V15H5L5 11H1V10H5L5 6H1V5H5L5 1H6V5H10V1H11ZM6 6L6 10H10L10 6H6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-operator.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.87289 1.10023C3.20768 1.23579 3.47545 1.498 3.61802 1.82988C3.69032 1.99959 3.72675 2.18242 3.72502 2.36688C3.72617 2.54999 3.68975 2.7314 3.61802 2.89988C3.51299 3.14567 3.33782 3.35503 3.11442 3.50177C2.89102 3.64851 2.6293 3.72612 2.36202 3.72488C2.17924 3.72592 1.99818 3.68951 1.83002 3.61788C1.58298 3.51406 1.37227 3.33932 1.22453 3.11575C1.0768 2.89219 0.998666 2.62984 1.00002 2.36188C0.99913 2.17921 1.03519 1.99825 1.10602 1.82988C1.24337 1.50314 1.50328 1.24323 1.83002 1.10588C2.16332 0.966692 2.53809 0.964661 2.87289 1.10023ZM2.57502 2.86488C2.7054 2.80913 2.80927 2.70526 2.86502 2.57488C2.8929 2.50838 2.90718 2.43698 2.90702 2.36488C2.90813 2.2654 2.88215 2.1675 2.83185 2.08167C2.78156 1.99584 2.70884 1.92531 2.62151 1.87767C2.53418 1.83002 2.43553 1.80705 2.33614 1.81121C2.23674 1.81537 2.14035 1.8465 2.05731 1.90128C1.97426 1.95606 1.9077 2.03241 1.86475 2.12215C1.8218 2.21188 1.80409 2.31161 1.81352 2.41065C1.82294 2.50968 1.85915 2.60428 1.91825 2.6843C1.97736 2.76433 2.05713 2.82675 2.14902 2.86488C2.28549 2.92089 2.43854 2.92089 2.57502 2.86488ZM6.42995 1.1095L1.10967 6.42977L1.79557 7.11567L7.11584 1.7954L6.42995 1.1095ZM11.5 8.99999H12.5V11.5H15V12.5H12.5V15H11.5V12.5H9V11.5H11.5V8.99999ZM5.76777 9.52509L6.47487 10.2322L4.70711 12L6.47487 13.7677L5.76777 14.4748L4 12.7071L2.23223 14.4748L1.52513 13.7677L3.29289 12L1.52513 10.2322L2.23223 9.52509L4 11.2929L5.76777 9.52509ZM7.11802 5.32988C7.01442 5.08268 6.83973 4.87183 6.61612 4.72406C6.3925 4.57629 6.13004 4.49826 5.86202 4.49988C5.67935 4.49899 5.49839 4.53505 5.33002 4.60588C5.00328 4.74323 4.74337 5.00314 4.60602 5.32988C4.53588 5.49478 4.49897 5.67191 4.49741 5.8511C4.49586 6.0303 4.52967 6.20804 4.59693 6.37414C4.66419 6.54024 4.76356 6.69143 4.88936 6.81906C5.01516 6.94669 5.1649 7.04823 5.33002 7.11788C5.49867 7.18848 5.67968 7.22484 5.86252 7.22484C6.04535 7.22484 6.22636 7.18848 6.39502 7.11788C6.64201 7.01388 6.8527 6.83913 7.00058 6.61563C7.14845 6.39213 7.22689 6.12987 7.22602 5.86188C7.22655 5.67905 7.1898 5.49803 7.11802 5.32988ZM6.36502 6.07488C6.33766 6.13937 6.29829 6.19808 6.24902 6.24788C6.19908 6.29724 6.14042 6.33691 6.07602 6.36488C6.00854 6.39297 5.93611 6.40725 5.86302 6.40688C5.78991 6.40744 5.71744 6.39315 5.65002 6.36488C5.58541 6.33729 5.52668 6.29757 5.47702 6.24788C5.42691 6.19856 5.38713 6.13975 5.36002 6.07488C5.30401 5.9384 5.30401 5.78536 5.36002 5.64888C5.41536 5.51846 5.51941 5.41477 5.65002 5.35988C5.71737 5.33126 5.78984 5.31663 5.86302 5.31688C5.93618 5.31685 6.0086 5.33147 6.07602 5.35988C6.14037 5.38749 6.19904 5.42682 6.24902 5.47588C6.29786 5.52603 6.33717 5.58465 6.36502 5.64888C6.3934 5.7163 6.40802 5.78872 6.40802 5.86188C6.40802 5.93503 6.3934 6.00745 6.36502 6.07488ZM14 3H10V4H14V3Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-parameter.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 6H10V5.5C10 5.22386 9.77616 5 9.50001 5H8.47902V10.5C8.47902 10.7761 8.70288 11 8.97902 11H9.47902V12H6.47902V11H6.97902C7.25516 11 7.47902 10.7761 7.47902 10.5V5H6.50001C6.22387 5 6.00001 5.22386 6.00001 5.5V6H5.00001V4H11V6ZM13.9142 8.0481L12.4519 6.58581L13.159 5.87871L14.9749 7.69454V8.40165L13.2071 10.1694L12.5 9.46231L13.9142 8.0481ZM3.5481 9.4623L2.08581 8.00002L3.50002 6.58581L2.79291 5.8787L1.02515 7.64647V8.35357L2.841 10.1694L3.5481 9.4623Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-property.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2.80723 14.9754C2.57119 14.9721 2.33826 14.9211 2.12247 14.8254C1.90667 14.7297 1.71248 14.5913 1.55158 14.4186C1.2385 14.1334 1.04433 13.7408 1.00775 13.3189C0.966225 12.8828 1.09269 12.4473 1.36133 12.1013C2.56779 10.8289 4.9473 8.4494 6.67811 6.75479C6.30983 5.75887 6.32704 4.66127 6.72637 3.67739C7.05474 2.85876 7.63869 2.16805 8.39129 1.70807C8.9817 1.31706 9.66031 1.07944 10.3657 1.01673C11.0711 0.954022 11.7809 1.06819 12.4311 1.34892L13.0482 1.6162L10.1824 4.56738L11.4371 5.82582L14.3809 2.94887L14.6482 3.56788C14.8735 4.08976 14.993 4.65119 14.9997 5.21961C15.0064 5.78802 14.9002 6.35211 14.6872 6.87915C14.476 7.40029 14.1623 7.87368 13.7647 8.27122C13.5394 8.49169 13.2904 8.68653 13.0222 8.85218C12.4673 9.22275 11.8324 9.45636 11.1697 9.5338C10.5069 9.61124 9.83521 9.5303 9.20982 9.29764C8.11194 10.4113 5.37142 13.1704 3.89119 14.5522C3.59426 14.8219 3.20832 14.9726 2.80723 14.9754ZM10.7448 1.92802C10.087 1.92637 9.44359 2.12018 8.89614 2.48485C8.68265 2.6152 8.48437 2.76897 8.30498 2.9433C7.82789 3.42423 7.50926 4.03953 7.39182 4.70669C7.27438 5.37385 7.36374 6.06098 7.64792 6.67591L7.78342 6.97288L7.55048 7.20025C5.81224 8.89672 3.28146 11.4201 2.06479 12.7045C1.95646 12.8658 1.91012 13.0608 1.93435 13.2535C1.95857 13.4463 2.05171 13.6238 2.19657 13.7532C2.28005 13.8462 2.38177 13.9211 2.49541 13.9731C2.59557 14.0184 2.70383 14.043 2.81373 14.0455C2.98064 14.0413 3.14044 13.977 3.26383 13.8646C4.83687 12.3964 7.87622 9.32641 8.76807 8.42435L8.9973 8.19326L9.29242 8.32783C9.80617 8.56732 10.3731 8.66985 10.9382 8.62545C11.5033 8.58106 12.0473 8.39125 12.5174 8.07447C12.7313 7.9426 12.9296 7.78694 13.1085 7.61045C13.4183 7.30153 13.6631 6.93374 13.8286 6.52874C13.994 6.12375 14.0767 5.68974 14.0719 5.25228C14.0719 5.03662 14.0505 4.82148 14.0078 4.61007L11.4306 7.12508L8.87944 4.57759L11.3944 1.98834C11.1804 1.94674 10.9628 1.92653 10.7448 1.92802Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-ruler.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 1L3 2V14L4 15H12L13 14V2L12 1H4ZM4 3V2H12V14H4V13H6V12H4V10H8V9H4V7H6V6H4V4H8V3H4Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-snippet.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 1L2 1.5V13H3V2H14V13H15V1.5L14.5 1H2.5ZM2 15V14H3V15H2ZM5 14.0001H4V15.0001H5V14.0001ZM6 14.0001H7V15.0001H6V14.0001ZM9 14.0001H8V15.0001H9V14.0001ZM10 14.0001H11V15.0001H10V14.0001ZM15 15.0001V14.0001H14V15.0001H15ZM12 14.0001H13V15.0001H12V14.0001Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-string.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 2L1 3V12L2 13H14L15 12V3L14 2H2ZM2 12V3H14V12H2ZM5.3556 8.93017H6V7.22067C6 6.40689 5.68534 6 5.05603 6C4.92098 6 4.77083 6.02421 4.6056 6.07263C4.44181 6.12104 4.3125 6.17691 4.21767 6.24022V6.90503C4.45474 6.70205 4.70474 6.60056 4.96767 6.60056C5.22917 6.60056 5.35991 6.75698 5.35991 7.06983L4.76078 7.17318C4.25359 7.25885 4 7.57914 4 8.13408C4 8.39665 4.06106 8.60708 4.18319 8.76536C4.30675 8.92179 4.47557 9 4.68966 9C4.97989 9 5.19899 8.83985 5.34698 8.51955H5.3556V8.93017ZM5.35991 7.57542V7.76816C5.35991 7.9432 5.31968 8.08845 5.23922 8.20391C5.15876 8.3175 5.0546 8.3743 4.92672 8.3743C4.83477 8.3743 4.76149 8.34264 4.7069 8.27933C4.65374 8.21415 4.62716 8.13128 4.62716 8.03073C4.62716 7.80912 4.73779 7.6797 4.95905 7.64246L5.35991 7.57542ZM7.60094 8.62622H7.59343V8.93511H7V5H7.59343V6.67683H7.60094C7.74742 6.36708 7.95587 6.2122 8.22629 6.2122C8.47418 6.2122 8.6651 6.32987 8.79906 6.56522C8.93302 6.80056 9 7.12243 9 7.53082C9 7.97383 8.92175 8.32944 8.76526 8.59766C8.60876 8.86589 8.39969 9 8.13803 9C7.90141 9 7.72238 8.87541 7.60094 8.62622ZM7.58404 7.50487V7.77742C7.58404 7.94873 7.61972 8.09063 7.69108 8.20311C7.76244 8.3156 7.85383 8.37184 7.96526 8.37184C8.10047 8.37184 8.20501 8.30002 8.27887 8.15639C8.35399 8.01103 8.39155 7.80597 8.39155 7.54121C8.39155 7.32144 8.35712 7.15012 8.28826 7.02726C8.22066 6.90266 8.12363 6.84036 7.99718 6.84036C7.87825 6.84036 7.77934 6.9018 7.70047 7.02466C7.62285 7.14752 7.58404 7.30759 7.58404 7.50487ZM11.2616 9C11.5834 9 11.8295 8.94227 12 8.82682V8.11732C11.82 8.25512 11.636 8.32402 11.448 8.32402C11.2362 8.32402 11.0697 8.25233 10.9486 8.10894C10.8276 7.96369 10.767 7.76443 10.767 7.51117C10.767 7.25047 10.8299 7.04656 10.9558 6.89944C11.0832 6.75047 11.2553 6.67598 11.4719 6.67598C11.6663 6.67598 11.8423 6.74488 12 6.88268V6.13408C11.871 6.04469 11.6623 6 11.374 6C10.9566 6 10.6229 6.1406 10.3728 6.42179C10.1243 6.70112 10 7.0838 10 7.56983C10 7.99069 10.1163 8.33426 10.3489 8.60056C10.5814 8.86685 10.8857 9 11.2616 9Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-structure.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 2L1 3V6L2 7H14L15 6V3L14 2H2ZM2 3H3H13H14V4V5V6H13H3H2V5V4V3ZM1 10L2 9H5L6 10V13L5 14H2L1 13V10ZM3 10H2V11V12V13H3H4H5V12V11V10H4H3ZM10 10L11 9H14L15 10V13L14 14H11L10 13V10ZM12 10H11V11V12V13H12H13H14V12V11V10H13H12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/symbol-variable.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 5H4V4H1.5L1 4.5V12.5L1.5 13H4V12H2V5ZM14.5 4H12V5H14V12H12V13H14.5L15 12.5V4.5L14.5 4ZM11.76 6.56995L12 7V9.51001L11.7 9.95996L7.19995 11.96H6.73999L4.23999 10.46L4 10.03V7.53003L4.30005 7.06995L8.80005 5.06995H9.26001L11.76 6.56995ZM5 9.70996L6.5 10.61V9.28003L5 8.38V9.70996ZM5.57996 7.56006L7.03003 8.43005L10.42 6.93005L8.96997 6.06006L5.57996 7.56006ZM7.53003 10.73L11.03 9.17004V7.77002L7.53003 9.31995V10.73Z" fill="#75BEFF"/>
</svg>

```

`src/vsicons/sync-ignored.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.46829 3.68741L4.71084 2.98108C5.65539 2.36081 6.78556 2 8 2C11.2401 2 13.8803 4.56823 13.996 7.78004L15.19 6.60005L15.94 7.36005L13.85 9.43005L13.09 9.42005L11 7.31005L11.76 6.55005L12.9961 7.80051C12.8914 5.13157 10.6946 3 8 3C7.07616 3 6.21084 3.25055 5.46829 3.68741ZM10.0182 12.576L10.802 13.3069C9.96565 13.7494 9.01209 14 8 14C4.77573 14 2.14547 11.4568 2.00583 8.26691L0.78 9.50003L0 8.73003L2.09 6.66003L2.85 6.67003L4.94 8.79003L4.18 9.55003L3.01348 8.36995C3.2028 10.9586 5.363 13 8 13C8.71815 13 9.40094 12.8486 10.0182 12.576Z" fill="#C5C5C5"/>
<rect x="1.12262" y="2.94897" width="1" height="16.2916" transform="rotate(-47 1.12262 2.94897)" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/sync.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.00583 8.26691L0.78 9.50003L0 8.73003L2.09 6.66003L2.85 6.67003L4.94 8.79003L4.18 9.55003L3.01348 8.36995C3.2028 10.9586 5.363 13 8 13C9.91062 13 11.571 11.9283 12.4127 10.3533L13.226 10.9499C12.1959 12.7709 10.2415 14 8 14C4.77573 14 2.14547 11.4568 2.00583 8.26691ZM12.9961 7.80051L11.76 6.55005L11 7.31005L13.09 9.42005L13.85 9.43005L15.94 7.36005L15.19 6.60005L13.996 7.78004C13.8803 4.56823 11.2401 2 8 2C5.83727 2 3.94179 3.14427 2.88597 4.86043L3.69563 5.45436C4.56647 3.98506 6.1682 3 8 3C10.6946 3 12.8914 5.13157 12.9961 7.80051Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/tag.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.2 2H8.017L7.664 2.146L1 8.81V9.517L6.183 14.7H6.89L9.10507 12.4853C9.65808 12.7768 10.2674 12.9502 10.8942 12.9923C11.6588 13.0437 12.4238 12.8981 13.116 12.5694C13.8082 12.2407 14.4046 11.74 14.8481 11.1151C15.2915 10.4902 15.5673 9.76192 15.649 9H15.649C15.6757 8.83446 15.6927 8.66751 15.7 8.5C15.6987 7.30693 15.2242 6.16311 14.3805 5.31948C14.1709 5.10988 13.9428 4.92307 13.7 4.76064V2.5L13.2 2ZM12.7 4.25881C12.2227 4.08965 11.716 4.00057 11.2 4C11.0674 4 10.9402 4.05268 10.8465 4.14645C10.7527 4.24021 10.7 4.36739 10.7 4.5C10.7 4.63261 10.7527 4.75979 10.8465 4.85355C10.9402 4.94732 11.0674 5 11.2 5C11.7238 5 12.2356 5.11743 12.7 5.33771V7.476L8.77481 11.4005C8.75743 11.4095 8.74054 11.4194 8.72425 11.4304C8.66826 11.468 8.62046 11.5166 8.58373 11.5731C8.5745 11.5874 8.56602 11.602 8.55831 11.617L6.536 13.639L2.061 9.163L8.224 3H12.7V4.25881ZM13.7 6.0505C14.3407 6.70435 14.7 7.58365 14.7 8.5C14.6952 8.66769 14.6782 8.8348 14.649 9H14.649C14.5673 9.58097 14.3404 10.1319 13.9892 10.6019C13.638 11.0719 13.174 11.4457 12.64 11.6888C12.1061 11.9319 11.5194 12.0363 10.9344 11.9925C10.562 11.9646 10.1979 11.8772 9.85564 11.7348L13.554 8.037L13.7 7.683V6.0505Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/tasklist.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.57031 6.69861L9.26344 1.76345L8.58482 1L3.27341 5.59585L1.76345 3.76355L1 4.44217L2.84927 6.6562L3.57031 6.69861ZM15 5H6.8241L9.13127 3H15V5ZM6 7H15V9H6V7ZM15 11H6V13H15V11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/telescope.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.24 1L11.83 1.24L13.94 6.17L13.71 6.76L10.42 8.17L9.82999 7.93L9.65999 7.52L6.1 9L5.51999 8.81L5.36 8.43L2.8 9.49L2.22 9.25L1.5 7.58L1.78 6.99L4.27999 5.93L4.09999 5.52L4.33999 4.94L7.9 3.41L7.72 3L7.99999 2.42L11.24 1ZM2.5 7.64L2.85 8.49L5.07 7.58L4.7 6.73L2.5 7.64ZM5.23999 5.52L6.35 7.97L9.35 6.69L8.23999 4.25L5.23999 5.52ZM8.78999 3L10.65 7.11L12.94 6.1L11.18 2L8.72 3H8.78999ZM8.50001 9.09998L11.52 14H10.35L8.47001 10.97V14.97H7.47001V9.81997L5.58001 14H4.48001L6.18001 10.1L8.50001 9.09998Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/terminal.svg`:

```svg
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 1.5L1.5 3V21L3 22.5H21L22.5 21V3L21 1.5H3ZM3 21V3H21V21H3ZM8.65649 16.99L9.6937 18.0513L14.954 12.8078V11.8965L9.69398 6.63641L8.65856 7.69591L13.2486 12.3979L8.65649 16.99Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/text-size.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.35999 7L1 13H2.34003L2.84998 11.53H5.10999L5.64001 13H7L4.65002 7H3.35999ZM3.21002 10.53L3.98999 8.39001L4.77002 10.53H3.21002Z" fill="#C5C5C5"/>
<path d="M11.82 4H10.22L7 13H8.56L9.31 10.71H12.67L13.44 13H15L11.82 4ZM9.66998 9.5L10.85 5.91003C10.909 5.72454 10.9492 5.53351 10.97 5.33997C10.997 5.53171 11.0337 5.72202 11.08 5.91003L12.33 9.5H9.66998Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/three-bars.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 5H2V3H14V5ZM14 9H2V7H14V9ZM2 13H14V11H2V13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/thumbsdown.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.45994 14.11C5.17116 14.1086 4.88928 14.0216 4.64994 13.86C4.39126 13.6736 4.20509 13.4035 4.12305 13.0954C4.04102 12.7873 4.06819 12.4603 4.19994 12.17L5.16994 10H2.37994C2.15086 10.0043 1.92441 9.95059 1.72162 9.84395C1.51882 9.73731 1.34626 9.58116 1.21994 9.39C1.09292 9.1962 1.01791 8.97296 1.00215 8.74178C0.986388 8.5106 1.0304 8.27925 1.12994 8.07C1.79994 6.62 2.99994 4 3.39994 2.9C3.49771 2.63646 3.67363 2.40906 3.90417 2.24822C4.1347 2.08738 4.40885 2.00078 4.68994 2H13.6199C13.9878 2.00526 14.3387 2.15507 14.597 2.41706C14.8552 2.67904 15 3.03214 14.9999 3.4V6.91C14.9999 7.09122 14.9642 7.27067 14.8949 7.4381C14.8255 7.60553 14.7239 7.75766 14.5957 7.88581C14.4676 8.01395 14.3155 8.1156 14.148 8.18495C13.9806 8.25431 13.8012 8.29 13.6199 8.29H12.2399L6.39994 13.75C6.14157 13.9816 5.8069 14.1097 5.45994 14.11V14.11ZM4.68994 3C4.6118 3.0008 4.53569 3.02507 4.4715 3.06965C4.40731 3.11422 4.35799 3.17706 4.32994 3.25C3.92994 4.34 2.85994 6.7 1.99994 8.49C1.97102 8.54559 1.95592 8.60733 1.95592 8.67C1.95592 8.73267 1.97102 8.79441 1.99994 8.85C2.04156 8.90955 2.09979 8.95553 2.16736 8.9822C2.23494 9.00888 2.30887 9.01507 2.37994 9H5.67994L6.19994 9.68V10.14L5.10994 12.58C5.07371 12.6597 5.06689 12.7496 5.09069 12.8338C5.11449 12.918 5.16737 12.9911 5.23994 13.04C5.30774 13.0952 5.3925 13.1254 5.47994 13.1254C5.56738 13.1254 5.65215 13.0952 5.71994 13.04L11.7799 7.45L12.2499 7.32H13.6199C13.6725 7.32016 13.7245 7.30944 13.7726 7.28849C13.8208 7.26755 13.8641 7.23684 13.8998 7.19831C13.9355 7.15978 13.9629 7.11427 13.9801 7.06465C13.9973 7.01502 14.0041 6.96237 13.9999 6.91V3.4C14.0001 3.29729 13.9607 3.19847 13.8899 3.124C13.8192 3.04953 13.7225 3.00514 13.6199 3H4.68994Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/thumbsup.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.5401 1.99999C10.8288 2.00138 11.1107 2.08838 11.3501 2.24999C11.6087 2.43634 11.7949 2.70652 11.8769 3.0146C11.959 3.32268 11.9318 3.64967 11.8001 3.93998L10.8301 6.10998L13.6201 6.10999C13.8491 6.10572 14.0756 6.15939 14.2784 6.26604C14.4812 6.37268 14.6537 6.52883 14.7801 6.71999C14.9071 6.91379 14.9821 7.13702 14.9978 7.3682C15.0136 7.59939 14.9696 7.83074 14.8701 8.03999C14.2001 9.48999 13.0001 12.11 12.6001 13.21C12.5023 13.4735 12.3264 13.7009 12.0958 13.8618C11.8653 14.0226 11.5912 14.1092 11.3101 14.11L2.38006 14.11C2.01223 14.1047 1.66125 13.9549 1.40301 13.6929C1.14477 13.4309 1.00002 13.0778 1.00006 12.71L1.00006 9.19998C1.00006 9.01876 1.03575 8.83931 1.1051 8.67188C1.17446 8.50445 1.27611 8.35232 1.40425 8.22418C1.5324 8.09603 1.68453 7.99438 1.85196 7.92503C2.01938 7.85568 2.19883 7.81998 2.38006 7.81998L3.76006 7.81998L9.60006 2.35998C9.85843 2.12842 10.1931 2.00025 10.5401 1.99999V1.99999ZM11.3101 13.11C11.3882 13.1092 11.4643 13.0849 11.5285 13.0403C11.5927 12.9958 11.642 12.9329 11.6701 12.86C12.0701 11.77 13.1401 9.40999 14.0001 7.61999C14.029 7.56439 14.0441 7.50265 14.0441 7.43999C14.0441 7.37732 14.029 7.31558 14.0001 7.25999C13.9584 7.20044 13.9002 7.15446 13.8326 7.12778C13.7651 7.10111 13.6911 7.09492 13.6201 7.10999L10.3201 7.10998L9.80006 6.42999L9.80006 5.96998L10.8901 3.52999C10.9263 3.45032 10.9331 3.36039 10.9093 3.27617C10.8855 3.19196 10.8326 3.1189 10.7601 3.06999C10.6923 3.01476 10.6075 2.9846 10.5201 2.9846C10.4326 2.9846 10.3479 3.01476 10.2801 3.06998L4.22006 8.65998L3.75006 8.78998L2.38006 8.78998C2.32753 8.78982 2.27553 8.80055 2.22736 8.82149C2.17918 8.84244 2.13588 8.87314 2.10017 8.91167C2.06446 8.9502 2.03713 8.99571 2.0199 9.04534C2.00267 9.09496 1.99591 9.14762 2.00006 9.19998L2.00006 12.71C1.99993 12.8127 2.03932 12.9115 2.11006 12.986C2.1808 13.0604 2.27748 13.1048 2.38006 13.11L11.3101 13.11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/tools.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.7724 3.48501L13.9937 3.30124L11.8849 5.39688L10.6906 4.18062L12.7468 2.02372L12.5674 1.23187C12.1328 1.08662 11.6782 1.00986 11.2199 1.00436C10.7202 0.996443 10.2243 1.09177 9.76308 1.28437C9.31782 1.48601 8.91531 1.77113 8.57742 2.12433C8.20125 2.48057 7.90327 2.91115 7.70242 3.38872C7.31575 4.33966 7.31575 5.40403 7.70242 6.35498C5.91304 8.10498 2.95993 11.0931 1.5293 12.5894C1.31956 12.8644 1.21839 13.207 1.24497 13.5518C1.25427 13.7356 1.30036 13.9156 1.38057 14.0812C1.46022 14.2472 1.5717 14.3958 1.70869 14.5187C1.83279 14.6544 1.98117 14.7657 2.14619 14.8469C2.31626 14.9218 2.49866 14.9648 2.68431 14.9737C2.99994 14.9677 3.30286 14.8481 3.53746 14.6369C5.08621 13.18 8.05243 10.1875 9.73681 8.4331C10.1934 8.62691 10.6845 8.72663 11.1806 8.72625C11.6799 8.72589 12.1742 8.62543 12.6341 8.43081C13.094 8.23618 13.5102 7.9513 13.8581 7.59308C14.5727 6.86438 14.9719 5.88373 14.9693 4.86309C14.9806 4.39597 14.914 3.93029 14.7724 3.48501ZM2.93371 13.9281C2.89503 13.9624 2.84839 13.9864 2.79806 13.9981C2.74884 14.0066 2.69855 14.0066 2.64933 13.9981C2.59751 13.9903 2.54811 13.9709 2.50492 13.9412C2.45888 13.9143 2.41994 13.8768 2.39122 13.8318C2.25122 13.6875 2.11994 13.4162 2.25119 13.2631C3.62056 11.8062 6.44243 8.95809 8.20556 7.21684C8.30659 7.3493 8.4162 7.47498 8.53368 7.59308C8.65214 7.71588 8.77935 7.82994 8.9143 7.93435C7.20805 9.68435 4.42559 12.4975 2.93371 13.9281ZM14.0505 4.86309C14.0531 5.62826 13.7545 6.36373 13.2193 6.91061C12.6844 7.4354 11.9649 7.72938 11.2156 7.72938C10.4662 7.72938 9.74676 7.4354 9.21183 6.91061C8.81999 6.50142 8.55236 5.98941 8.44006 5.4341C8.32776 4.8788 8.37538 4.30301 8.57742 3.77372C8.71194 3.41382 8.92047 3.08613 9.1895 2.81183C9.45853 2.53752 9.78211 2.32269 10.1393 2.18121C10.4786 2.03857 10.8431 1.96567 11.2112 1.96684H11.465L9.64933 3.83935V4.53496L11.5437 6.42061H12.2043L14.0505 4.60498V4.86309ZM3.23992 6.68751H4.77117L5.47554 7.40501L6.15369 6.73125L5.48868 6.05315V6.00936L5.54556 4.36003L5.32681 3.92253L2.46554 2.04126L1.87492 2.1069L1.04366 2.95562L0.978027 3.55499L2.81556 6.47314L3.23992 6.68751ZM2.29491 3.05624L4.6093 4.57878L4.56994 5.70313H3.49365L2.00182 3.34062L2.29491 3.05624ZM9.39991 10.0169L10.0737 9.34314L13.1799 12.5282C13.4415 12.8031 13.5875 13.1681 13.5875 13.5476C13.5875 13.9271 13.4415 14.292 13.1799 14.5669C12.9832 14.7688 12.7303 14.9068 12.4541 14.963C12.1779 15.0192 11.8912 14.9909 11.6312 14.8819C11.4651 14.8083 11.3162 14.7011 11.1937 14.5669L8.05243 11.3644L8.73058 10.6863L11.863 13.88C11.9052 13.9265 11.9577 13.9625 12.0162 13.9851C12.1312 14.0318 12.2599 14.0318 12.3749 13.9851C12.4335 13.9625 12.4859 13.9265 12.528 13.88C12.572 13.8366 12.6063 13.7845 12.6287 13.7269C12.6512 13.6682 12.6631 13.606 12.6637 13.5432C12.6627 13.4804 12.6508 13.4182 12.6287 13.3594C12.6063 13.3018 12.572 13.2497 12.528 13.2063L9.39991 10.0169Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/trash.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 3H12H13V4H12V13L11 14H4L3 13V4H2V3H5V2C5 1.73478 5.10531 1.48038 5.29285 1.29285C5.48038 1.10531 5.73478 1 6 1H9C9.26522 1 9.51962 1.10531 9.70715 1.29285C9.89469 1.48038 10 1.73478 10 2V3ZM9 2H6V3H9V2ZM4 13H11V4H4V13ZM6 5H5V12H6V5ZM7 5H8V12H7V5ZM9 5H10V12H9V5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/triangle-down.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2 5.55973L2.41344 5L13.6067 5L14 5.53925L8.37311 11H7.54622L2 5.55973Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/triangle-left.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.4403 2L11 2.41344L11 13.6067L10.4608 14L5 8.37311L5 7.54622L10.4403 2Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/triangle-right.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.55973 14L5 13.5866L5 2.39328L5.53925 2L11 7.62689L11 8.45378L5.55973 14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/triangle-up.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 10.4403L13.5866 11L2.39328 11L2 10.4607L7.62689 5L8.45378 5L14 10.4403Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/twitter.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15 3.78418C14.8086 4.07129 14.5921 4.33902 14.3506 4.5874C14.109 4.83577 13.847 5.0625 13.5644 5.26757C13.569 5.33138 13.5724 5.39404 13.5747 5.45556C13.577 5.51709 13.5781 5.57975 13.5781 5.64355C13.5781 6.21777 13.5166 6.78515 13.3935 7.3457C13.2705 7.90624 13.0928 8.44856 12.8603 8.97265C12.5231 9.73372 12.1016 10.4139 11.5957 11.0132C11.0898 11.6125 10.5168 12.1195 9.87646 12.5342C9.23616 12.9489 8.53775 13.2656 7.78125 13.4844C7.02474 13.7031 6.23177 13.8125 5.40234 13.8125C4.61848 13.8125 3.854 13.7043 3.10888 13.4878C2.36377 13.2713 1.6608 12.9489 1 12.5205C1.22331 12.5478 1.45117 12.5615 1.68359 12.5615C2.33529 12.5615 2.96533 12.4567 3.57373 12.2471C4.18212 12.0374 4.74153 11.7321 5.25195 11.331C4.94661 11.3265 4.65266 11.2752 4.37011 11.1772C4.08756 11.0793 3.82893 10.9425 3.59423 10.7671C3.35953 10.5916 3.15445 10.3831 2.979 10.1416C2.80354 9.90006 2.66796 9.63346 2.57226 9.34179C2.6634 9.35546 2.75341 9.36686 2.84228 9.37597C2.93115 9.38509 3.02115 9.38964 3.1123 9.38964C3.36751 9.38964 3.61815 9.35547 3.86425 9.28711C3.52701 9.21875 3.21826 9.09798 2.93798 8.9248C2.65771 8.75162 2.41503 8.54085 2.20996 8.29248C2.00488 8.04411 1.84537 7.76383 1.73144 7.45166C1.61751 7.13948 1.56054 6.8125 1.56054 6.4707V6.43652C1.96158 6.66439 2.3968 6.78515 2.8662 6.79883C2.66568 6.66211 2.48681 6.50602 2.32959 6.33056C2.17236 6.15511 2.03906 5.96484 1.92968 5.75976C1.82031 5.55469 1.736 5.33822 1.67675 5.11035C1.61751 4.88249 1.58789 4.64779 1.58789 4.40625C1.58789 4.15104 1.61979 3.90153 1.68359 3.65772C1.74739 3.4139 1.84537 3.18262 1.97753 2.96387C2.34212 3.41504 2.74772 3.8195 3.19433 4.17725C3.64094 4.53499 4.11604 4.84147 4.61962 5.09668C5.1232 5.35189 5.65071 5.55355 6.20214 5.70166C6.75357 5.84977 7.31868 5.9375 7.89745 5.96484C7.87011 5.86003 7.85074 5.75179 7.83934 5.64014C7.82795 5.52848 7.82225 5.41797 7.82225 5.30859C7.82225 4.91211 7.89745 4.53955 8.04784 4.19092C8.19823 3.84228 8.40331 3.53809 8.66307 3.27832C8.92284 3.01855 9.22704 2.81348 9.57567 2.66309C9.92431 2.5127 10.2969 2.4375 10.6933 2.4375C11.0944 2.4375 11.4761 2.51611 11.8384 2.67334C12.2007 2.83057 12.5185 3.05501 12.792 3.34668C13.1155 3.28288 13.4289 3.19287 13.7319 3.07666C14.035 2.96045 14.3278 2.81803 14.6103 2.64941C14.5055 2.9821 14.3449 3.28516 14.1284 3.55859C13.9119 3.83203 13.6533 4.05762 13.3525 4.23535C13.9267 4.16699 14.4759 4.0166 15 3.78418Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/unfold.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.53 6.51V2.51L6.53 3.51L5.82 2.8L7.65 1H8.36L10.2 2.83L9.49 3.53L8.49 2.53V6.51H7.53ZM7.53 9.48999V13.49L6.53 12.49L5.82 13.2L7.65 15H8.36L10.2 13.17L9.49 12.47L8.49 13.47V9.48999H7.53ZM13.73 4L14 5.02L10.32 7.95L14 10.98L13.73 12H9.53V11H12.53L9.55 8.57H6.54L3.45 11H6.53V12H2.27L2 10.98L5.68 8.06L2 5.02L2.27 4H6.53V5H3.45L6.45 7.42H9.46L12.53 5H9.53V4H13.73Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/ungroup-by-ref-type.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.86001 1L4.93001 3.08L4.23001 3.78L3.00001 2.56V7H2.00001V2.55L0.790007 3.78L0.0800073 3.07L2.15001 1H2.86001ZM15 3V7H11V6H9.00001V7H6.00001V4H9.00001V5H11V3H15ZM8.00001 5H7.00001V6H8.00001V5ZM14 4H12V6H14V4ZM11 9H15V13H11V11H9.00001V12H6.00001V9H9.00001V10H11V9ZM8.00001 10H7.00001V11H8.00001V10ZM12 12H14V10H12V12ZM3.00001 13.45V9H2.00001V13.44L0.780007 12.22L0.0700073 12.92L2.15001 15H2.85001L4.92001 12.93L4.22001 12.22L3.00001 13.45Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/unlock.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 7V5C5 3.34315 6.34315 2 8 2C9.30622 2 10.4175 2.83481 10.8293 4H11.874C11.4299 2.27477 9.86384 1 8 1C5.79086 1 4 2.79086 4 5V7H3L2 8V14L3 15H13L14 14V8L13 7H12H11H10H5ZM11 8H12H13V14H3V8H4H5H11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/unmute.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 4.83H4.29L8.15 1L9 1.35V14.35L8.15 14.68L4.29 10.83H1.5L1 10.33V5.33L1.5 4.83ZM4.85 10L8 13.14V2.56L4.85 5.68L4.5 5.83H2V9.83H4.5L4.85 10ZM15.0002 7.83C15.0002 9.51007 14.4084 11.0519 13.4217 12.2583L12.7105 11.5471C13.5181 10.525 14.0002 9.2338 14.0002 7.83C14.0002 6.42969 13.5205 5.14143 12.7165 4.12057L13.4279 3.40918C14.4108 4.61451 15.0002 6.15342 15.0002 7.83ZM13.0002 7.83C13.0002 8.95745 12.6271 9.99774 11.9975 10.8341L11.2816 10.1182C11.7345 9.46979 12.0002 8.68092 12.0002 7.83C12.0002 6.98259 11.7367 6.19673 11.2872 5.54989L12.0034 4.83369C12.6294 5.66872 13.0002 6.70605 13.0002 7.83ZM11.0002 7.83C11.0002 8.40394 10.8391 8.94024 10.5595 9.3961L9.82135 8.65795C9.93624 8.40565 10.0002 8.1253 10.0002 7.83C10.0002 7.53836 9.93781 7.26131 9.82561 7.01146L10.5647 6.27238C10.8411 6.72641 11.0002 7.25961 11.0002 7.83Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/unverified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.67 14.72H8.38L10.1 13H12.5L13 12.5V10.08L14.74 8.36004V7.65004L13.03 5.93004V3.49004L12.53 3.00004H10.1L8.38 1.29004H7.67L6 3.00004H3.53L3 3.50004V5.93004L1.31 7.65004V8.36004L3 10.08V12.5L3.53 13H6L7.67 14.72ZM6.16 12H4V9.87004L3.88 9.52004L2.37 8.00004L3.85 6.49004L4 6.14004V4.00004H6.16L6.52 3.86004L8 2.35004L9.54 3.86004L9.89 4.00004H12V6.14004L12.17 6.49004L13.69 8.00004L12.14 9.52004L12 9.87004V12H9.89L9.51 12.15L8 13.66L6.52 12.14L6.16 12ZM7.60288 6.14101C7.54621 6.22606 7.50337 6.32292 7.47465 6.43203C7.44526 6.54079 7.42468 6.64661 7.41299 6.74891L7.40808 6.79186H6.51332L6.51619 6.74069C6.53447 6.41473 6.60464 6.12645 6.72787 5.87687C6.78019 5.76916 6.84468 5.66329 6.92117 5.55926C7.00224 5.45324 7.10082 5.35923 7.21549 5.27864C7.33383 5.19457 7.47018 5.12809 7.62404 5.07882C7.78275 5.02596 7.96334 5 8.16511 5C8.44581 5 8.68831 5.04573 8.89098 5.13921C9.09163 5.22877 9.25661 5.34985 9.38469 5.50292C9.5119 5.65495 9.60489 5.82866 9.66367 6.02356C9.72201 6.21701 9.75116 6.41655 9.75116 6.62201C9.75116 6.81343 9.71872 6.99327 9.65345 7.1611C9.58934 7.32596 9.50992 7.48175 9.41521 7.62841C9.32115 7.77101 9.21774 7.90792 9.10551 8.03835C8.99509 8.16668 8.89371 8.29042 8.80136 8.40959C8.70988 8.52467 8.63315 8.6383 8.57169 8.74952C8.51214 8.85728 8.48332 8.96318 8.48332 9.06777V9.54783H7.59513V9.00932C7.59513 8.84135 7.62627 8.6862 7.68922 8.54455C7.75366 8.4034 7.83362 8.26953 7.92863 8.14386C8.02548 8.01676 8.12847 7.89406 8.2374 7.77606C8.34426 7.66029 8.44365 7.54161 8.53558 7.42003C8.62919 7.30008 8.70548 7.17399 8.76373 7.04293C8.82348 6.9149 8.85397 6.77427 8.85397 6.62201C8.85397 6.50659 8.8381 6.40079 8.80687 6.30424L8.80647 6.303C8.77825 6.20707 8.73432 6.12583 8.67649 6.05974C8.61866 5.99089 8.5471 5.93848 8.46108 5.90241L8.45931 5.90167C8.377 5.86326 8.27937 5.84324 8.16511 5.84324C8.02809 5.84324 7.91599 5.87172 7.82635 5.92596C7.73629 5.9823 7.66193 6.0539 7.60288 6.14101ZM8.5 11H7.6118V10.1118H8.5V11Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/verified.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.67 14.72H8.38L10.1 13H12.5L13 12.5V10.08L14.74 8.36004V7.65004L13.03 5.93004V3.49004L12.53 3.00004H10.1L8.38 1.29004H7.67L6 3.00004H3.53L3 3.50004V5.93004L1.31 7.65004V8.36004L3 10.08V12.5L3.53 13H6L7.67 14.72ZM6.16 12H4V9.87004L3.88 9.52004L2.37 8.00004L3.85 6.49004L4 6.14004V4.00004H6.16L6.52 3.86004L8 2.35004L9.54 3.86004L9.89 4.00004H12V6.14004L12.17 6.49004L13.69 8.00004L12.14 9.52004L12 9.87004V12H9.89L9.51 12.15L8 13.66L6.52 12.14L6.16 12ZM6.73003 10.4799H7.44004L11.21 6.71L10.5 6L7.09004 9.41991L5.71 8.03984L5 8.74984L6.73003 10.4799Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/versions.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 12.5L7.5 13H14.5L15 12.5V3.5L14.5 3H7.5L7 3.5L7 12.5ZM9 5L13 5V11L9 11L9 5ZM5 9V5H6V4H4.5L4 4.5V9V9.5V11.5L4.5 12H6V11H5V9.5V9ZM2 8V6H3V5H1.5L1 5.5V8V8.5V10.5L1.5 11H3V10H2V8.5V8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/vm-active.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2H14.5L15 2.5V8.00305C14.6892 7.76964 14.3534 7.57413 14 7.41955V3H2V12H7C7 12.326 7.03187 12.6527 7.09608 12.9755C7.24266 13.7124 7.55277 14.4037 8 15H4V14H7V13H1.5L1 12.5V2.5L1.5 2Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.77772 8.67412C10.4355 8.2346 11.2089 8 12 8C13.0605 8.0013 14.0771 8.42315 14.827 9.17301C15.5769 9.92287 15.9987 10.9395 16 12C16 12.7911 15.7654 13.5645 15.3259 14.2223C14.8864 14.8801 14.2616 15.3928 13.5307 15.6955C12.7998 15.9983 11.9956 16.0775 11.2196 15.9231C10.4437 15.7688 9.73098 15.3878 9.17157 14.8284C8.61216 14.269 8.2312 13.5563 8.07686 12.7804C7.92252 12.0044 8.00173 11.2002 8.30448 10.4693C8.60723 9.73836 9.11992 9.11365 9.77772 8.67412ZM11.9087 13.6637L14.295 10.4818L13.495 9.88184L11.4182 12.651L10.1165 11.6096L9.49179 12.3905L11.1963 13.7541L11.9087 13.6637Z" fill="#388A34"/>
</g>
<defs>
<clipPath id="clip0">
<rect width="16" height="16" fill="white"/>
</clipPath>
</defs>
</svg>

```

`src/vsicons/vm-connect.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2H14.5L15 2.5V8.00305C14.6892 7.76964 14.3534 7.57413 14 7.41955V3H2V12H7C7 12.326 7.03187 12.6527 7.09608 12.9755C7.24266 13.7124 7.55277 14.4037 8 15H4V14H7V13H1.5L1 12.5V2.5L1.5 2Z" fill="#C5C5C5"/>
<path d="M12 8C11.2089 8 10.4355 8.23455 9.77769 8.67407C9.11989 9.1136 8.60717 9.73833 8.30442 10.4692C8.00167 11.2001 7.92254 12.0045 8.07688 12.7804C8.23122 13.5563 8.6122 14.269 9.17161 14.8284C9.73102 15.3878 10.4437 15.7688 11.2196 15.9231C11.9955 16.0774 12.7998 15.9983 13.5307 15.6956C14.2616 15.3928 14.8864 14.8801 15.3259 14.2223C15.7654 13.5645 16 12.7911 16 12C16 10.9391 15.5785 9.92178 14.8283 9.17163C14.0782 8.42149 13.0608 8 12 8ZM12 15C11.4066 15 10.8266 14.824 10.3332 14.4944C9.83988 14.1647 9.45543 13.6962 9.22837 13.1481C9.00131 12.5999 8.94184 11.9966 9.0576 11.4147C9.17335 10.8327 9.45908 10.2982 9.87864 9.87866C10.2982 9.4591 10.8327 9.17337 11.4147 9.05762C11.9966 8.94186 12.5999 9.00133 13.148 9.22839C13.6962 9.45546 14.1647 9.8399 14.4944 10.3333C14.824 10.8266 15 11.4067 15 12C15 12.7956 14.6839 13.5587 14.1213 14.1213C13.5587 14.6839 12.7956 15 12 15V15Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.1332 11.4353L13.5685 12.8706L14 12.4396L12.9957 11.4353L14 10.4313L13.5685 10.0002L12.1332 11.4353ZM11.0043 12.5022L10 11.4979L10.4315 11.0669L11.8666 12.5022L10.4315 13.9378L10 13.5065L11.0043 12.5022Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/vm-outline.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2H14.5L15 2.5V8.00305C14.6892 7.76964 14.3534 7.57413 14 7.41955V3H2V12H7C7 12.326 7.03187 12.6527 7.09608 12.9755C7.24266 13.7124 7.55277 14.4037 8 15H4V14H7V13H1.5L1 12.5V2.5L1.5 2Z" fill="#C5C5C5"/>
<path d="M12 8C11.2089 8 10.4355 8.23455 9.77769 8.67407C9.11989 9.1136 8.60717 9.73833 8.30442 10.4692C8.00167 11.2001 7.92254 12.0045 8.07688 12.7804C8.23122 13.5563 8.6122 14.269 9.17161 14.8284C9.73102 15.3878 10.4437 15.7688 11.2196 15.9231C11.9955 16.0774 12.7998 15.9983 13.5307 15.6956C14.2616 15.3928 14.8864 14.8801 15.3259 14.2223C15.7654 13.5645 16 12.7911 16 12C16 10.9391 15.5785 9.92178 14.8283 9.17163C14.0782 8.42149 13.0608 8 12 8ZM12 15C11.4066 15 10.8266 14.824 10.3332 14.4944C9.83988 14.1647 9.45543 13.6962 9.22837 13.1481C9.00131 12.5999 8.94184 11.9966 9.0576 11.4147C9.17335 10.8327 9.45908 10.2982 9.87864 9.87866C10.2982 9.4591 10.8327 9.17337 11.4147 9.05762C11.9966 8.94186 12.5999 9.00133 13.148 9.22839C13.6962 9.45546 14.1647 9.8399 14.4944 10.3333C14.824 10.8266 15 11.4067 15 12C15 12.7956 14.6839 13.5587 14.1213 14.1213C13.5587 14.6839 12.7956 15 12 15V15Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/vm-pending.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2H14.5L15 2.5V8.00305C14.6892 7.76964 14.3534 7.57413 14 7.41955V3H2V12H7C7 12.326 7.03187 12.6527 7.09608 12.9755C7.24266 13.7124 7.55277 14.4037 8 15H4V14H7V13H1.5L1 12.5V2.5L1.5 2Z" fill="#C5C5C5"/>
<path d="M12 8C12.3672 8 12.7214 8.04688 13.0625 8.14062C13.4036 8.23438 13.7214 8.36979 14.0156 8.54688C14.3099 8.72396 14.5794 8.93229 14.8242 9.17188C15.069 9.41146 15.2786 9.68099 15.4531 9.98047C15.6276 10.2799 15.7617 10.599 15.8555 10.9375C15.9492 11.276 15.9974 11.6302 16 12C16 12.3672 15.9531 12.7214 15.8594 13.0625C15.7656 13.4036 15.6302 13.7214 15.4531 14.0156C15.276 14.3099 15.0677 14.5794 14.8281 14.8242C14.5885 15.069 14.319 15.2786 14.0195 15.4531C13.7201 15.6276 13.401 15.7617 13.0625 15.8555C12.724 15.9492 12.3698 15.9974 12 16C11.6328 16 11.2786 15.9531 10.9375 15.8594C10.5964 15.7656 10.2786 15.6302 9.98438 15.4531C9.6901 15.276 9.42057 15.0677 9.17578 14.8281C8.93099 14.5885 8.72135 14.319 8.54688 14.0195C8.3724 13.7201 8.23828 13.401 8.14453 13.0625C8.05078 12.724 8.0026 12.3698 8 12C8 11.6328 8.04688 11.2786 8.14062 10.9375C8.23438 10.5964 8.36979 10.2786 8.54688 9.98438C8.72396 9.6901 8.93229 9.42057 9.17188 9.17578C9.41146 8.93099 9.68099 8.72135 9.98047 8.54688C10.2799 8.3724 10.599 8.23828 10.9375 8.14453C11.276 8.05078 11.6302 8.0026 12 8ZM12 14.0859C12.2005 14.0859 12.3945 14.0586 12.582 14.0039C12.7695 13.9492 12.9466 13.8685 13.1133 13.7617C13.2799 13.6549 13.4284 13.5299 13.5586 13.3867C13.6888 13.2435 13.7982 13.0794 13.8867 12.8945L13.2773 12.6055C13.2174 12.7279 13.1432 12.8385 13.0547 12.9375C12.9661 13.0365 12.8659 13.1211 12.7539 13.1914C12.6419 13.2617 12.5221 13.3164 12.3945 13.3555C12.2669 13.3945 12.1354 13.4141 12 13.4141C11.8125 13.4141 11.6341 13.3776 11.4648 13.3047C11.2956 13.2318 11.1432 13.1302 11.0078 13H11.5V12.5H10V14H10.5V13.4453C10.6953 13.6484 10.9232 13.806 11.1836 13.918C11.444 14.0299 11.7161 14.0859 12 14.0859ZM14 11.5V10H13.5V10.5547C13.3047 10.3516 13.0768 10.194 12.8164 10.082C12.556 9.97005 12.2839 9.91406 12 9.91406C11.7995 9.91406 11.6055 9.94141 11.418 9.99609C11.2305 10.0508 11.0534 10.1315 10.8867 10.2383C10.7201 10.3451 10.5716 10.4701 10.4414 10.6133C10.3112 10.7565 10.2018 10.9206 10.1133 11.1055L10.7227 11.3945C10.7799 11.2721 10.8529 11.1615 10.9414 11.0625C11.0299 10.9635 11.1315 10.8789 11.2461 10.8086C11.3607 10.7383 11.4805 10.6836 11.6055 10.6445C11.7305 10.6055 11.862 10.5859 12 10.5859C12.1875 10.5859 12.3659 10.6224 12.5352 10.6953C12.7044 10.7682 12.8568 10.8698 12.9922 11H12.5V11.5H14Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/vm-running.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2H14.5L15 2.5V8.00305C14.6892 7.76964 14.3534 7.57413 14 7.41955V3H2V12H7C7 12.326 7.03187 12.6527 7.09608 12.9755C7.24266 13.7124 7.55277 14.4037 8 15H4V14H7V13H1.5L1 12.5V2.5L1.5 2Z" fill="#C5C5C5"/>
<path d="M12 8C12.3672 8 12.7214 8.04688 13.0625 8.14062C13.4036 8.23438 13.7214 8.36979 14.0156 8.54688C14.3099 8.72396 14.5794 8.93229 14.8242 9.17188C15.069 9.41146 15.2786 9.68099 15.4531 9.98047C15.6276 10.2799 15.7617 10.599 15.8555 10.9375C15.9492 11.276 15.9974 11.6302 16 12C16 12.3672 15.9531 12.7214 15.8594 13.0625C15.7656 13.4036 15.6302 13.7214 15.4531 14.0156C15.276 14.3099 15.0677 14.5794 14.8281 14.8242C14.5885 15.069 14.319 15.2786 14.0195 15.4531C13.7201 15.6276 13.401 15.7617 13.0625 15.8555C12.724 15.9492 12.3698 15.9974 12 16C11.6328 16 11.2786 15.9531 10.9375 15.8594C10.5964 15.7656 10.2786 15.6302 9.98438 15.4531C9.6901 15.276 9.42057 15.0677 9.17578 14.8281C8.93099 14.5885 8.72135 14.319 8.54688 14.0195C8.3724 13.7201 8.23828 13.401 8.14453 13.0625C8.05078 12.724 8.0026 12.3698 8 12C8 11.6328 8.04688 11.2786 8.14062 10.9375C8.23438 10.5964 8.36979 10.2786 8.54688 9.98438C8.72396 9.6901 8.93229 9.42057 9.17188 9.17578C9.41146 8.93099 9.68099 8.72135 9.98047 8.54688C10.2799 8.3724 10.599 8.23828 10.9375 8.14453C11.276 8.05078 11.6302 8.0026 12 8ZM14 11.9883L11 10V14L14 11.9883Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/vm.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 2H1.5L1 2.5V12.5L1.5 13H7V14H4V15H12V14H9V13H14.5L15 12.5V2.5L14.5 2ZM14 12H2V3H14V12Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/warning.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.55976 1H8.43976L14.9798 13.26L14.5398 14H1.43976L0.999756 13.26L7.55976 1ZM7.99976 2.28L2.27976 13H13.6998L7.99976 2.28ZM8.62476 12V11H7.37476V12H8.62476ZM7.37476 10V6H8.62476V10H7.37476Z" fill="#FFCC00"/>
</svg>

```

`src/vsicons/watch.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.5 9H9.5V8H8V5.5H7V8.5L7.5 9Z" fill="#C5C5C5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.66895C4.00549 4.53345 3 6.14929 3 8C3 9.85071 4.00549 11.4666 5.5 12.3311V14.5L6 15H10L10.5 14.5V12.3311C11.9945 11.4666 13 9.85071 13 8C13 6.14929 11.9945 4.53345 10.5 3.66895V1.5L10 1H6L5.5 1.5V3.66895ZM12 8C12 10.2091 10.2092 12 8 12C5.79083 12 4 10.2091 4 8C4 5.79089 5.79083 4 8 4C10.2092 4 12 5.79089 12 8Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/whitespace.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 2V1H6.5C5.57174 1 4.68152 1.36877 4.02515 2.02515C3.36877 2.68152 3 3.57174 3 4.5C3 5.42826 3.36877 6.31848 4.02515 6.97485C4.68152 7.63123 5.57174 8 6.5 8H8V13H7V14H12V13H11V2H12ZM8 7H6.5C5.83696 7 5.20102 6.73666 4.73218 6.26782C4.26334 5.79898 4 5.16304 4 4.5C4 3.83696 4.26334 3.20102 4.73218 2.73218C5.20102 2.26334 5.83696 2 6.5 2H8V7ZM10 13H9V2H10V13Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/whole-word.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 2H15V3H1V2ZM14 4H13V12H14V4ZM11.272 8.387C11.194 8.088 11.073 7.825 10.912 7.601C10.751 7.377 10.547 7.2 10.303 7.071C10.059 6.942 9.769 6.878 9.437 6.878C9.239 6.878 9.057 6.902 8.89 6.951C8.725 7 8.574 7.068 8.437 7.156C8.301 7.244 8.18 7.35 8.072 7.474L7.893 7.732V4.578H7V12H7.893V11.425L8.019 11.6C8.106 11.702 8.208 11.79 8.323 11.869C8.44 11.947 8.572 12.009 8.721 12.055C8.87 12.101 9.035 12.123 9.219 12.123C9.572 12.123 9.885 12.052 10.156 11.911C10.428 11.768 10.655 11.573 10.838 11.325C11.021 11.075 11.159 10.782 11.252 10.446C11.345 10.108 11.392 9.743 11.392 9.349C11.391 9.007 11.352 8.686 11.272 8.387ZM9.793 7.78C9.944 7.851 10.075 7.956 10.183 8.094C10.292 8.234 10.377 8.407 10.438 8.611C10.489 8.785 10.52 8.982 10.527 9.198L10.52 9.323C10.52 9.65 10.487 9.943 10.42 10.192C10.353 10.438 10.259 10.645 10.142 10.806C10.025 10.968 9.882 11.091 9.721 11.172C9.399 11.334 8.961 11.338 8.652 11.187C8.499 11.112 8.366 11.012 8.259 10.891C8.174 10.795 8.103 10.675 8.041 10.524C8.041 10.524 7.862 10.077 7.862 9.577C7.862 9.077 8.041 8.575 8.041 8.575C8.103 8.398 8.177 8.257 8.265 8.145C8.379 8.002 8.521 7.886 8.689 7.8C8.857 7.714 9.054 7.671 9.276 7.671C9.466 7.671 9.64 7.708 9.793 7.78ZM15 13H1V14H15V13ZM2.813 10L2.085 12.031H1L1.025 11.959L3.466 4.87305H4.407L6.892 12.031H5.81L5.032 10H2.813ZM3.934 6.42205H3.912L3.007 9.17505H4.848L3.934 6.42205Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/window.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.5 2H1.5L1 2.5V13.5L1.5 14H14.5L15 13.5V2.5L14.5 2ZM14 13H2V6H14V13ZM14 5H2V3H14V5Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/word-wrap.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.86838 3.449C3.73951 3.30285 3.57724 3.18998 3.39538 3.12C3.12138 3.009 2.77238 2.97 2.34038 3.044C2.09669 3.08799 1.85836 3.15771 1.62938 3.252C1.54785 3.28668 1.46954 3.32851 1.39538 3.377L1.35238 3.407V4.463L1.52038 4.324C1.66938 4.2 1.84638 4.099 2.04738 4.021C2.24338 3.947 2.44638 3.908 2.65138 3.908C2.83938 3.908 2.98138 3.959 3.08238 4.065C3.16938 4.16 3.21938 4.313 3.22938 4.521L2.26738 4.665C2.04838 4.695 1.85738 4.751 1.69738 4.831C1.54486 4.90638 1.40941 5.01223 1.29938 5.142C1.1957 5.2675 1.11787 5.41228 1.07038 5.568C0.972926 5.89751 0.976758 6.2487 1.08138 6.576C1.13245 6.72744 1.21601 6.86588 1.32622 6.98162C1.43643 7.09736 1.57062 7.18759 1.71938 7.246C1.87438 7.309 2.04738 7.339 2.24738 7.339C2.43291 7.3427 2.61694 7.30504 2.7861 7.22876C2.95526 7.15248 3.10532 7.03949 3.22538 6.898V7.243H4.23238V4.65C4.23238 4.395 4.20238 4.166 4.14338 3.969C4.08893 3.7784 3.99527 3.60129 3.86838 3.449ZM3.23238 5.345V5.581C3.23238 5.7 3.21438 5.812 3.17738 5.922C3.14794 6.01808 3.09936 6.10722 3.03457 6.18403C2.96978 6.26085 2.89012 6.32377 2.80038 6.369C2.63942 6.44302 2.45624 6.45268 2.28838 6.396C2.23057 6.37553 2.1775 6.34355 2.13238 6.302C2.09131 6.26306 2.05923 6.21562 2.03838 6.163C2.01433 6.10398 2.00243 6.04072 2.00338 5.977C2.00338 5.9 2.01238 5.83 2.02738 5.765C2.04133 5.71228 2.06813 5.66383 2.10538 5.624C2.15016 5.57601 2.2052 5.53875 2.26638 5.515C2.36473 5.47845 2.46714 5.45394 2.57138 5.442L3.23238 5.345ZM8.28338 4.278C8.23672 4.04796 8.15439 3.82662 8.03938 3.622C7.93236 3.4367 7.78294 3.2794 7.60338 3.163C7.41073 3.04419 7.18764 2.98408 6.96138 2.99C6.7132 2.98696 6.47084 3.06528 6.27138 3.213C6.17111 3.28858 6.0822 3.37816 6.00738 3.479V1H5.08938V7.224H6.00738V6.943C6.13014 7.09519 6.29394 7.20902 6.47938 7.271C6.57738 7.303 6.68738 7.318 6.80938 7.318C7.06438 7.318 7.29238 7.258 7.48638 7.141C7.67838 7.026 7.84138 6.863 7.97238 6.655C8.11016 6.43406 8.20924 6.19125 8.26538 5.937C8.33139 5.64635 8.36361 5.34904 8.36138 5.051C8.36214 4.79133 8.336 4.53228 8.28338 4.278ZM7.42238 5.036C7.42238 5.268 7.40238 5.475 7.36338 5.649C7.32738 5.821 7.27338 5.964 7.20438 6.073C7.14898 6.17117 7.06859 6.25293 6.97138 6.31C6.88615 6.36014 6.78955 6.38774 6.6907 6.39019C6.59184 6.39264 6.49399 6.36986 6.40638 6.324C6.32419 6.27819 6.25236 6.21588 6.19538 6.141C6.13249 6.05546 6.08479 5.95973 6.05438 5.858C6.01818 5.74213 5.99997 5.62139 6.00038 5.5V4.983C6.00038 4.819 6.02038 4.669 6.05938 4.536C6.09638 4.404 6.14738 4.294 6.21638 4.2C6.2751 4.11382 6.35319 4.04259 6.44438 3.992C6.53297 3.94377 6.63253 3.91931 6.73338 3.921C6.83373 3.91811 6.93297 3.94254 7.02051 3.99168C7.10805 4.04083 7.18059 4.11283 7.23038 4.2C7.29338 4.299 7.33838 4.414 7.37338 4.554C7.40438 4.697 7.42238 4.86 7.42238 5.036ZM2.40838 9.9C2.49495 9.79816 2.60282 9.71657 2.72438 9.661C2.94238 9.561 3.27138 9.556 3.49038 9.643C3.59438 9.685 3.69438 9.743 3.81038 9.827L4.13938 10.087V8.945L4.04338 8.883C3.76373 8.7387 3.45306 8.66489 3.13838 8.668C2.83038 8.668 2.54538 8.725 2.29238 8.836C2.04238 8.946 1.82538 9.106 1.64538 9.311C1.46449 9.52067 1.32745 9.76447 1.24238 10.028C1.15238 10.3 1.10538 10.598 1.10538 10.923C1.10538 11.212 1.14838 11.484 1.23438 11.731C1.32138 11.98 1.44638 12.202 1.60838 12.383C1.76938 12.568 1.96938 12.716 2.20538 12.824C2.43738 12.928 2.69838 12.979 2.98338 12.979C3.21638 12.979 3.41738 12.951 3.59638 12.895C3.76106 12.8447 3.9179 12.7717 4.06238 12.678L4.14038 12.617V11.728L3.94038 11.823C3.91598 11.8342 3.89052 11.8429 3.86438 11.849C3.81438 11.866 3.76538 11.884 3.73638 11.898C3.70038 11.921 3.50938 11.988 3.50938 11.988C3.44938 12.012 3.36938 12.031 3.29138 12.047C3.09069 12.0915 2.88108 12.0715 2.69238 11.99C2.57431 11.9398 2.46955 11.8627 2.38638 11.765C2.29381 11.6545 2.22413 11.5267 2.18138 11.389C2.12877 11.2177 2.10313 11.0392 2.10538 10.86C2.10538 10.65 2.13338 10.461 2.18838 10.3C2.24238 10.142 2.31738 10.006 2.40838 9.9ZM14 6H10V5H14.5L15 5.5V11.5L14.5 12H7.87869L9.94976 14.0711L9.24265 14.7782L6.35356 11.8891V11.182L9.24265 8.2929L9.94976 9L7.94975 11H14V6Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/zoom-in.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.0275 6.14861C12.1231 7.56649 11.6682 8.96661 10.7575 10.0575L15.0175 14.3176L14.3176 15.0275L10.0575 10.7575C8.96661 11.6682 7.56649 12.1231 6.14861 12.0275C4.73072 11.9319 3.40437 11.2931 2.44561 10.2442C1.48684 9.19523 0.969494 7.81691 1.00139 6.39617C1.03329 4.97542 1.61188 3.62162 2.61675 2.61675C3.62162 1.61188 4.97542 1.03329 6.39617 1.00139C7.81691 0.969494 9.19523 1.48684 10.2442 2.44561C11.2931 3.40437 11.9319 4.73072 12.0275 6.14861ZM6.57756 11.0375C7.77042 11.0354 8.91377 10.5608 9.7575 9.71758L9.71758 9.7376C10.1447 9.32074 10.4849 8.82316 10.7183 8.27385C10.9518 7.72455 11.0739 7.13437 11.0776 6.53752C11.0776 5.64751 10.8136 4.77755 10.3191 4.03752C9.82467 3.2975 9.12188 2.72065 8.29961 2.38005C7.47734 2.03946 6.57255 1.95032 5.69963 2.12395C4.82672 2.29758 4.02489 2.72618 3.39556 3.35552C2.76622 3.98485 2.33762 4.78668 2.16399 5.6596C1.99036 6.53251 2.0795 7.4373 2.42009 8.25957C2.76069 9.08184 3.33742 9.78464 4.07744 10.2791C4.81746 10.7736 5.68755 11.0375 6.57756 11.0375ZM9.01749 7.0376V6.0376H7.01749V4.0376H6.01749V6.0376H4.01749V7.0376H6.01749V9.0376H7.01749V7.0376H9.01749Z" fill="#C5C5C5"/>
</svg>

```

`src/vsicons/zoom-out.svg`:

```svg
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.0275 6.14861C12.1231 7.56649 11.6682 8.96661 10.7575 10.0575L15.0175 14.3176L14.3176 15.0275L10.0575 10.7575C8.96661 11.6682 7.56649 12.1231 6.14861 12.0275C4.73072 11.9319 3.40437 11.2931 2.44561 10.2442C1.48684 9.19523 0.969494 7.81691 1.00139 6.39617C1.03329 4.97542 1.61188 3.62162 2.61675 2.61675C3.62162 1.61188 4.97542 1.03329 6.39617 1.00139C7.81691 0.969494 9.19523 1.48684 10.2442 2.44561C11.2931 3.40437 11.9319 4.73072 12.0275 6.14861ZM6.57756 11.0375C7.77042 11.0354 8.91377 10.5608 9.7575 9.71758L9.71758 9.7376C10.1447 9.32074 10.4849 8.82316 10.7183 8.27385C10.9518 7.72455 11.0739 7.13437 11.0776 6.53752C11.0776 5.64751 10.8136 4.77755 10.3191 4.03752C9.82467 3.2975 9.12188 2.72065 8.29961 2.38005C7.47734 2.03946 6.57255 1.95032 5.69963 2.12395C4.82672 2.29758 4.02489 2.72618 3.39556 3.35552C2.76622 3.98485 2.33762 4.78668 2.16399 5.6596C1.99036 6.53251 2.0795 7.4373 2.42009 8.25957C2.76069 9.08184 3.33742 9.78464 4.07744 10.2791C4.81746 10.7736 5.68755 11.0375 6.57756 11.0375ZM4.03748 6.0575H9.03748V7.0575H4.03748V6.0575Z" fill="#C5C5C5"/>
</svg>

```

`src/workspace_model.h`:

```h
#pragma once
#include "core.h"
#include <QIcon>
#include <QStandardItemModel>
#include <QStandardItem>
#include <algorithm>

namespace rcx {

struct TabInfo {
    const NodeTree* tree;
    QString         name;
    void*           subPtr;   // QMdiSubWindow* as void*
};

// Sentinel value stored in UserRole+1 to mark the Project group node.
static constexpr uint64_t kGroupSentinel = ~uint64_t(0);

inline void buildProjectExplorer(QStandardItemModel* model,
                                 const QVector<TabInfo>& tabs) {
    model->clear();
    model->setHorizontalHeaderLabels({QStringLiteral("Name")});

    // Single "Project" root with folder icon
    void* firstSub = tabs.isEmpty() ? nullptr : tabs[0].subPtr;
    auto* projectItem = new QStandardItem(QIcon(":/vsicons/folder.svg"),
                                          QStringLiteral("Project"));
    projectItem->setData(QVariant::fromValue(firstSub), Qt::UserRole);
    projectItem->setData(QVariant::fromValue(kGroupSentinel), Qt::UserRole + 1);

    // Collect all top-level structs/enums across all tabs
    QVector<std::pair<const Node*, void*>> types, enums;
    for (const auto& tab : tabs) {
        QVector<int> topLevel = tab.tree->childrenOf(0);
        for (int idx : topLevel) {
            const Node& n = tab.tree->nodes[idx];
            if (n.kind != NodeKind::Struct) continue;
            if (n.resolvedClassKeyword() == QStringLiteral("enum"))
                enums.append({&n, tab.subPtr});
            else
                types.append({&n, tab.subPtr});
        }
    }

    auto nameOf = [](const Node* n) {
        return n->structTypeName.isEmpty() ? n->name : n->structTypeName;
    };
    auto cmpName = [&](const std::pair<const Node*, void*>& a,
                       const std::pair<const Node*, void*>& b) {
        return nameOf(a.first).compare(nameOf(b.first), Qt::CaseInsensitive) < 0;
    };
    std::sort(types.begin(), types.end(), cmpName);
    std::sort(enums.begin(), enums.end(), cmpName);

    for (const auto& [n, subPtr] : types) {
        QString display = QStringLiteral("%1 (%2)")
            .arg(nameOf(n), n->resolvedClassKeyword());
        auto* item = new QStandardItem(
            QIcon(":/vsicons/symbol-structure.svg"), display);
        item->setData(QVariant::fromValue(subPtr), Qt::UserRole);
        item->setData(QVariant::fromValue(n->id), Qt::UserRole + 1);
        projectItem->appendRow(item);
    }

    for (const auto& [n, subPtr] : enums) {
        QString display = QStringLiteral("%1 (%2)")
            .arg(nameOf(n), n->resolvedClassKeyword());
        auto* item = new QStandardItem(
            QIcon(":/vsicons/symbol-enum.svg"), display);
        item->setData(QVariant::fromValue(subPtr), Qt::UserRole);
        item->setData(QVariant::fromValue(n->id), Qt::UserRole + 1);
        projectItem->appendRow(item);
    }

    model->appendRow(projectItem);
}

} // namespace rcx

```

`tests/bench_import_pdb.cpp`:

```cpp
#include <QtTest/QtTest>
#include "core.h"
#include "imports/import_pdb.h"

using namespace rcx;

class BenchImportPdb : public QObject {
    Q_OBJECT
private slots:
    void benchEnumerateAll();
    void benchImportAll();
};

static const QString kPdbPath = QStringLiteral(
    "C:/Symbols/ntkrnlmp.pdb/0762CF42EF7F3E8116EF7329ADAA09A31/ntkrnlmp.pdb");

void BenchImportPdb::benchEnumerateAll() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    QString err;
    QElapsedTimer timer;
    timer.start();
    QVector<PdbTypeInfo> types = enumeratePdbTypes(kPdbPath, &err);
    qint64 elapsed = timer.elapsed();

    QVERIFY2(!types.isEmpty(), qPrintable(err));
    qDebug() << "enumeratePdbTypes:" << types.size() << "types in" << elapsed << "ms";
}

void BenchImportPdb::benchImportAll() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    // Phase 1: enumerate
    QString err;
    QElapsedTimer timer;
    timer.start();
    QVector<PdbTypeInfo> types = enumeratePdbTypes(kPdbPath, &err);
    qint64 enumerateMs = timer.elapsed();
    QVERIFY2(!types.isEmpty(), qPrintable(err));

    // Collect all type indices
    QVector<uint32_t> indices;
    indices.reserve(types.size());
    for (const auto& t : types)
        indices.append(t.typeIndex);

    // Phase 2: import all
    timer.restart();
    int lastProgress = 0;
    NodeTree tree = importPdbSelected(kPdbPath, indices, &err,
        [&](int cur, int total) -> bool {
            // Report progress at 25% intervals
            int pct = (cur * 100) / total;
            if (pct >= lastProgress + 25) {
                qDebug() << "  progress:" << cur << "/" << total
                         << "(" << pct << "%)";
                lastProgress = pct;
            }
            return true;
        });
    qint64 importMs = timer.elapsed();

    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(err));

    // Count root structs
    int rootCount = 0;
    for (const auto& n : tree.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) rootCount++;

    qDebug() << "";
    qDebug() << "=== PDB Import Benchmark (ntkrnlmp.pdb) ===";
    qDebug() << "  Enumerate:" << types.size() << "types in" << enumerateMs << "ms";
    qDebug() << "  Import all:" << rootCount << "root structs,"
             << tree.nodes.size() << "total nodes in" << importMs << "ms";
    qDebug() << "  Total:" << (enumerateMs + importMs) << "ms";
    qDebug() << "============================================";
}

QTEST_MAIN(BenchImportPdb)
#include "bench_import_pdb.moc"

```

`tests/test_addressparser.cpp`:

```cpp
#include "addressparser.h"
#include <QTest>

using rcx::AddressParser;
using rcx::AddressParserCallbacks;
using rcx::AddressParseResult;

class TestAddressParser : public QObject {
    Q_OBJECT

private slots:
    // -- Hex literals --

    void bareHex()      { auto r = AddressParser::evaluate("AB");          QVERIFY(r.ok); QCOMPARE(r.value, 0xABULL); }
    void prefixedHex()  { auto r = AddressParser::evaluate("0x1F4");       QVERIFY(r.ok); QCOMPARE(r.value, 0x1F4ULL); }
    void zeroLiteral()  { auto r = AddressParser::evaluate("0");           QVERIFY(r.ok); QCOMPARE(r.value, 0ULL); }
    void large64bit()   { auto r = AddressParser::evaluate("7FF66CCE0000");QVERIFY(r.ok); QCOMPARE(r.value, 0x7FF66CCE0000ULL); }

    // -- Arithmetic --

    void addition() {
        auto r = AddressParser::evaluate("0x100 + 0x200");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x300ULL);
    }
    void subtraction() {
        auto r = AddressParser::evaluate("0x300 - 0x100");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x200ULL);
    }
    void multiplication() {
        auto r = AddressParser::evaluate("0x10 * 4");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x40ULL);
    }
    void division() {
        auto r = AddressParser::evaluate("0x100 / 2");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x80ULL);
    }
    void precedence() {
        // 0x10 + 2*3 = 0x10 + 6 = 0x16
        auto r = AddressParser::evaluate("0x10 + 2 * 3");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x16ULL);
    }
    void parentheses() {
        // (0x10 + 2) * 3 = 0x12 * 3 = 0x36
        auto r = AddressParser::evaluate("(0x10 + 2) * 3");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x36ULL);
    }

    // -- Unary minus --

    void unaryMinus() {
        auto r = AddressParser::evaluate("-0x10 + 0x20");
        QVERIFY(r.ok); QCOMPARE(r.value, 0x10ULL);
    }

    // -- Module resolution --

    void moduleResolve() {
        AddressParserCallbacks cbs;
        cbs.resolveModule = [](const QString& name, bool* ok) -> uint64_t {
            *ok = (name == "Program.exe");
            return *ok ? 0x140000000ULL : 0;
        };
        auto r = AddressParser::evaluate("<Program.exe> + 0x123", 8, &cbs);
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0x140000123ULL);
    }

    void moduleNotFound() {
        AddressParserCallbacks cbs;
        cbs.resolveModule = [](const QString&, bool* ok) -> uint64_t {
            *ok = false;
            return 0;
        };
        auto r = AddressParser::evaluate("<NoSuch.dll>", 8, &cbs);
        QVERIFY(!r.ok);
        QVERIFY(r.error.contains("not found"));
    }

    // -- Dereference --

    void derefSimple() {
        AddressParserCallbacks cbs;
        cbs.readPointer = [](uint64_t addr, bool* ok) -> uint64_t {
            *ok = (addr == 0x1000);
            return *ok ? 0xDEADBEEFULL : 0;
        };
        auto r = AddressParser::evaluate("[0x1000]", 8, &cbs);
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0xDEADBEEFULL);
    }

    void derefNested() {
        AddressParserCallbacks cbs;
        cbs.resolveModule = [](const QString& name, bool* ok) -> uint64_t {
            *ok = (name == "mod");
            return *ok ? 0x400000ULL : 0;
        };
        cbs.readPointer = [](uint64_t addr, bool* ok) -> uint64_t {
            *ok = true;
            if (addr == 0x400100) return 0x500000;
            if (addr == 0x900000) return 0xABCDEF;
            return 0;
        };
        // [<mod> + [<mod> + 0x100]] = [0x400000 + [0x400000+0x100]]
        //   inner deref: [0x400100] = 0x500000
        //   outer: [0x400000 + 0x500000] = [0x900000] = 0xABCDEF
        auto r = AddressParser::evaluate("[<mod> + [<mod> + 0x100]]", 8, &cbs);
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0xABCDEFULL);
    }

    void derefReadFailure() {
        AddressParserCallbacks cbs;
        cbs.readPointer = [](uint64_t, bool* ok) -> uint64_t {
            *ok = false;
            return 0;
        };
        auto r = AddressParser::evaluate("[0x1000]", 8, &cbs);
        QVERIFY(!r.ok);
        QVERIFY(r.error.contains("failed to read"));
    }

    // -- Complex expression from plan --

    void complexExpr() {
        AddressParserCallbacks cbs;
        cbs.resolveModule = [](const QString& name, bool* ok) -> uint64_t {
            *ok = (name == "Program.exe");
            return *ok ? 0x140000000ULL : 0;
        };
        cbs.readPointer = [](uint64_t addr, bool* ok) -> uint64_t {
            *ok = true;
            if (addr == 0x1400000DEULL) return 0x500000;
            return 0;
        };
        // [<Program.exe> + 0xDE] - AB = [0x1400000DE] - 0xAB = 0x500000 - 0xAB = 0x4FFF55
        auto r = AddressParser::evaluate("[<Program.exe> + 0xDE] - AB", 8, &cbs);
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0x4FFF55ULL);
    }

    // -- Errors --

    void emptyInput() {
        auto r = AddressParser::evaluate("");
        QVERIFY(!r.ok);
    }
    void unmatchedBracket() {
        auto r = AddressParser::evaluate("[0x1000");
        QVERIFY(!r.ok);
        QVERIFY(r.error.contains("']'"));
    }
    void unmatchedAngle() {
        auto r = AddressParser::evaluate("<Program.exe");
        QVERIFY(!r.ok);
        QVERIFY(r.error.contains("'>'"));
    }
    void divisionByZero() {
        auto r = AddressParser::evaluate("0x100 / 0");
        QVERIFY(!r.ok);
        QVERIFY(r.error.contains("division by zero"));
    }
    void trailingGarbage() {
        auto r = AddressParser::evaluate("0x100 xyz");
        QVERIFY(!r.ok);
        QVERIFY(r.error.contains("unexpected"));
    }
    void trailingOperator() {
        auto r = AddressParser::evaluate("0x100 +");
        QVERIFY(!r.ok);
    }

    // -- Validation --

    void validateValid() {
        QCOMPARE(AddressParser::validate("0x100 + 0x200"), QString());
        QCOMPARE(AddressParser::validate("<Prog.exe> + [0x100]"), QString());
    }
    void validateInvalid() {
        QVERIFY(!AddressParser::validate("").isEmpty());
        QVERIFY(!AddressParser::validate("[0x100").isEmpty());
        QVERIFY(!AddressParser::validate("0x100 xyz").isEmpty());
    }

    // -- Backtick stripping --

    void backtickStripping() {
        auto r = AddressParser::evaluate("7ff6`6cce0000");
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0x7FF66CCE0000ULL);
    }

    // -- Whitespace tolerance --

    void whitespace() {
        auto r = AddressParser::evaluate("  0x100  +  0x200  ");
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0x300ULL);
    }

    // -- Legacy compat: simple hex --

    void simpleHexAddress() {
        auto r = AddressParser::evaluate("140000000");
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0x140000000ULL);
    }

    // -- Multiple additions --

    void multipleAdditions() {
        auto r = AddressParser::evaluate("0x100 + 0x200 + 0x300");
        QVERIFY(r.ok);
        QCOMPARE(r.value, 0x600ULL);
    }
};

QTEST_GUILESS_MAIN(TestAddressParser)
#include "test_addressparser.moc"

```

`tests/test_command_row.cpp`:

```cpp
#include <QTest>
#include <QString>
#include <memory>
#include "providers/provider.h"
#include "providers/buffer_provider.h"
#include "providers/null_provider.h"

using namespace rcx;

// -- Replicate the label-building logic from updateCommandRow so we can test it
//    without needing a full RcxController/RcxDocument/RcxEditor stack.

static QString buildSourceLabel(const Provider& prov) {
    QString provName = prov.name();
    if (provName.isEmpty())
        return QStringLiteral("source\u25BE");
    return QStringLiteral("'%1'\u25BE").arg(provName);
}

static QString buildCommandRow(const Provider& prov, uint64_t baseAddress) {
    QString src = buildSourceLabel(prov);
    QString addr = QStringLiteral("0x") +
        QString::number(baseAddress, 16).toUpper();
    return QStringLiteral("   %1 \u00B7 %2").arg(src, addr);
}

// -- Replicate commandRowSrcSpan for testing
struct TestColumnSpan {
    int start = 0;
    int end = 0;
    bool valid = false;
};

static TestColumnSpan commandRowSrcSpan(const QString& lineText) {
    int idx = lineText.indexOf(QStringLiteral(" \u00B7"));
    if (idx < 0) return {};
    int start = 0;
    while (start < idx && !lineText[start].isLetterOrNumber()
           && lineText[start] != '<' && lineText[start] != '\'') start++;
    if (start >= idx) return {};
    // Exclude trailing ▾ from the editable span
    int end = idx;
    while (end > start && lineText[end - 1] == QChar(0x25BE)) end--;
    if (end <= start) return {};
    return {start, end, true};
}

class TestCommandRow : public QObject {
    Q_OBJECT

private slots:

    // ---------------------------------------------------------------
    // Source label text
    // ---------------------------------------------------------------

    void label_nullProvider_showsSelectSource() {
        NullProvider p;
        QCOMPARE(buildSourceLabel(p), QStringLiteral("source\u25BE"));
    }

    void label_bufferNoName_showsSelectSource() {
        // BufferProvider with empty name also triggers source▾
        BufferProvider p(QByteArray(4, '\0'));
        QCOMPARE(buildSourceLabel(p), QStringLiteral("source\u25BE"));
    }

    void label_bufferWithName_showsFileAndName() {
        BufferProvider p(QByteArray(4, '\0'), "dump.bin");
        QCOMPARE(buildSourceLabel(p), QStringLiteral("'dump.bin'\u25BE"));
    }

    // ---------------------------------------------------------------
    // Full command row text
    // ---------------------------------------------------------------

    void row_nullProvider() {
        NullProvider p;
        QString row = buildCommandRow(p, 0);
        QCOMPARE(row, QStringLiteral("   source\u25BE \u00B7 0x0"));
    }

    void row_fileProvider() {
        BufferProvider p(QByteArray(4, '\0'), "test.bin");
        QString row = buildCommandRow(p, 0x140000000ULL);
        QCOMPARE(row, QStringLiteral("   'test.bin'\u25BE \u00B7 0x140000000"));
    }

    // ---------------------------------------------------------------
    // Source span parsing
    // ---------------------------------------------------------------

    void span_selectSource() {
        QString row = buildCommandRow(NullProvider{}, 0);
        auto span = commandRowSrcSpan(row);
        QVERIFY(span.valid);
        QString extracted = row.mid(span.start, span.end - span.start);
        QCOMPARE(extracted, QStringLiteral("source"));
    }

    void span_fileProvider() {
        BufferProvider p(QByteArray(4, '\0'), "dump.bin");
        QString row = buildCommandRow(p, 0x140000000ULL);
        auto span = commandRowSrcSpan(row);
        QVERIFY(span.valid);
        QString extracted = row.mid(span.start, span.end - span.start);
        QCOMPARE(extracted, QStringLiteral("'dump.bin'"));
    }

    void span_processProvider_simulated() {
        // Simulate a process provider without needing Windows APIs
        // by building the string directly
        QString row = QStringLiteral("   'notepad.exe'\u25BE \u00B7 0x7FF600000000");
        auto span = commandRowSrcSpan(row);
        QVERIFY(span.valid);
        QString extracted = row.mid(span.start, span.end - span.start);
        QCOMPARE(extracted, QStringLiteral("'notepad.exe'"));
    }

    // ---------------------------------------------------------------
    // Provider switching simulation
    // ---------------------------------------------------------------

    void switching_nullToFileToProcess() {
        // Start with NullProvider
        std::unique_ptr<Provider> prov = std::make_unique<NullProvider>();
        QCOMPARE(buildSourceLabel(*prov), QStringLiteral("source\u25BE"));

        // User loads a file
        prov = std::make_unique<BufferProvider>(QByteArray(64, '\0'), "game.exe");
        QCOMPARE(buildSourceLabel(*prov), QStringLiteral("'game.exe'\u25BE"));

        // User switches to a "process" -- simulate with a named BufferProvider
        // (ProcessProvider needs Windows, but the label logic is the same)
        prov = std::make_unique<BufferProvider>(QByteArray(64, '\0'), "notepad.exe");
        // BufferProvider kind is "File", but the switching mechanism works the same
        QCOMPARE(prov->kind(), QStringLiteral("File"));
        QCOMPARE(prov->name(), QStringLiteral("notepad.exe"));
    }
};

QTEST_MAIN(TestCommandRow)
#include "test_command_row.moc"

```

`tests/test_compose.cpp`:

```cpp
#include <QtTest/QTest>
#include <QJsonDocument>
#include <QFile>
#include "core.h"

using namespace rcx;

class TestCompose : public QObject {
    Q_OBJECT
private slots:
    void testBasicStruct() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f1;
        f1.kind = NodeKind::Hex32;
        f1.name = "field_0";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        Node f2;
        f2.kind = NodeKind::Float;
        f2.name = "value";
        f2.parentId = rootId;
        f2.offset = 4;
        tree.addNode(f2);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // CommandRow + 2 fields + root footer = 4
        QCOMPARE(result.meta.size(), 4);

        // Line 0 is CommandRow
        QCOMPARE(result.meta[0].lineKind, LineKind::CommandRow);

        // Fields at depth 1
        QVERIFY(!result.meta[1].foldHead);
        QCOMPARE(result.meta[1].depth, 1);
        QVERIFY(!result.meta[2].foldHead);
        QCOMPARE(result.meta[2].depth, 1);

        // Offset text
        QCOMPARE(result.meta[1].offsetText, QString("0000 "));
        QCOMPARE(result.meta[2].offsetText, QString("0004 "));

        // Line 3 is root footer
        QCOMPARE(result.meta[3].lineKind, LineKind::Footer);
    }

    void testVec3SingleLine() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node v;
        v.kind = NodeKind::Vec3;
        v.name = "pos";
        v.parentId = rootId;
        v.offset = 0;
        tree.addNode(v);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // CommandRow + 1 Vec3 line + root footer = 3
        QCOMPARE(result.meta.size(), 3);

        // Line 1: single Vec3 line, not continuation, depth 1
        QVERIFY(!result.meta[1].isContinuation);
        QCOMPARE(result.meta[1].offsetText, QString("0000 "));
        QCOMPARE(result.meta[1].depth, 1);
        QCOMPARE(result.meta[1].nodeKind, NodeKind::Vec3);

        // Line 2 is root footer
        QCOMPARE(result.meta[2].lineKind, LineKind::Footer);
    }

    void testHexNodeCompose() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "R";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node hex;
        hex.kind = NodeKind::Hex8;
        hex.name = "pad";
        hex.parentId = rootId;
        hex.offset = 0;
        tree.addNode(hex);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // CommandRow + hex node + root footer = 3
        QCOMPARE(result.meta.size(), 3);
        QCOMPARE(result.meta[1].depth, 1);

        // Line 2 is root footer
        QCOMPARE(result.meta[2].lineKind, LineKind::Footer);
    }

    void testNullPointerMarker() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "R";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "ptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        tree.addNode(ptr);

        // Provider with zeros (null ptr)
        QByteArray data(64, '\0');
        BufferProvider prov(data);
        ComposeResult result = compose(tree, prov);

        // CommandRow + ptr + root footer = 3
        QCOMPARE(result.meta.size(), 3);
        // No ambient validation markers — M_PTR0 is no longer set
        QVERIFY(!(result.meta[1].markerMask & (1u << M_PTR0)));
        QCOMPARE(result.meta[1].depth, 1);

        // Line 2 is root footer
        QCOMPARE(result.meta[2].lineKind, LineKind::Footer);
    }

    void testCollapsedStruct() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        root.collapsed = true;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f;
        f.kind = NodeKind::Hex32;
        f.name = "field";
        f.parentId = rootId;
        f.offset = 0;
        tree.addNode(f);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Collapsed root: isRootHeader overrides collapse, so children + footer still render
        // CommandRow + field + root footer = 3
        QCOMPARE(result.meta.size(), 3);
        QCOMPARE(result.meta[1].lineKind, LineKind::Field);
        QCOMPARE(result.meta[1].depth, 1);
        QCOMPARE(result.meta[2].lineKind, LineKind::Footer);
    }

    void testUnreadablePointerNoRead() {
        // No ambient validation — neither M_ERR nor M_PTR0 set
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "R";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "ptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        tree.addNode(ptr);

        // Provider with only 4 bytes — not enough for Pointer64 (8 bytes)
        QByteArray data(4, '\0');
        BufferProvider prov(data);
        ComposeResult result = compose(tree, prov);

        // CommandRow + ptr + root footer = 3
        QCOMPARE(result.meta.size(), 3);
        // No ambient validation markers
        QVERIFY(!(result.meta[1].markerMask & (1u << M_ERR)));
        QVERIFY(!(result.meta[1].markerMask & (1u << M_PTR0)));
        QCOMPARE(result.meta[1].depth, 1);

        // Line 2 is root footer
        QCOMPARE(result.meta[2].lineKind, LineKind::Footer);
    }

    void testFoldLevels() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node child;
        child.kind = NodeKind::Struct;
        child.name = "Child";
        child.parentId = rootId;
        child.offset = 0;
        int ci = tree.addNode(child);
        uint64_t childId = tree.nodes[ci].id;

        Node leaf;
        leaf.kind = NodeKind::Hex8;
        leaf.name = "x";
        leaf.parentId = childId;
        leaf.offset = 0;
        tree.addNode(leaf);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Child header (depth 1, fold head) — root header no longer emitted
        QCOMPARE(result.meta[1].foldLevel, 0x401 | 0x2000);
        QCOMPARE(result.meta[1].depth, 1);
        QVERIFY(result.meta[1].foldHead);

        // Leaf (depth 2, not head)
        QCOMPARE(result.meta[2].foldLevel, 0x402);
        QCOMPARE(result.meta[2].depth, 2);
    }

    void testNestedStruct() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Outer";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f1;
        f1.kind = NodeKind::UInt32;
        f1.name = "flags";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        Node inner;
        inner.kind = NodeKind::Struct;
        inner.name = "Inner";
        inner.parentId = rootId;
        inner.offset = 4;
        int ii = tree.addNode(inner);
        uint64_t innerId = tree.nodes[ii].id;

        Node f2;
        f2.kind = NodeKind::UInt16;
        f2.name = "x";
        f2.parentId = innerId;
        f2.offset = 0;
        tree.addNode(f2);

        Node f3;
        f3.kind = NodeKind::UInt16;
        f3.name = "y";
        f3.parentId = innerId;
        f3.offset = 2;
        tree.addNode(f3);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // CommandRow + flags + Inner header + x + y + Inner footer + root footer = 7
        QCOMPARE(result.meta.size(), 7);

        // flags field (depth 1)
        QCOMPARE(result.meta[1].lineKind, LineKind::Field);
        QCOMPARE(result.meta[1].depth, 1);

        // Inner header (depth 1, fold head)
        QCOMPARE(result.meta[2].lineKind, LineKind::Header);
        QCOMPARE(result.meta[2].depth, 1);
        QVERIFY(result.meta[2].foldHead);
        QCOMPARE(result.meta[2].foldLevel, 0x401 | 0x2000);

        // Inner fields at depth 2
        QCOMPARE(result.meta[3].depth, 2);
        QCOMPARE(result.meta[3].foldLevel, 0x402);
        QCOMPARE(result.meta[4].depth, 2);

        // Inner footer
        QCOMPARE(result.meta[5].lineKind, LineKind::Footer);
        QCOMPARE(result.meta[5].depth, 1);

        // Root footer
        QCOMPARE(result.meta[6].lineKind, LineKind::Footer);
        QCOMPARE(result.meta[6].depth, 0);
    }

    void testPointerDerefExpansion() {
        NodeTree tree;
        tree.baseAddress = 0;

        // Main struct
        Node main;
        main.kind = NodeKind::Struct;
        main.name = "Main";
        main.parentId = 0;
        main.offset = 0;
        int mi = tree.addNode(main);
        uint64_t mainId = tree.nodes[mi].id;

        Node magic;
        magic.kind = NodeKind::UInt32;
        magic.name = "magic";
        magic.parentId = mainId;
        magic.offset = 0;
        tree.addNode(magic);

        // Template struct (separate root)
        Node tmpl;
        tmpl.kind = NodeKind::Struct;
        tmpl.name = "VTable";
        tmpl.parentId = 0;
        tmpl.offset = 200;  // far away so standalone rendering uses offset 200
        int ti = tree.addNode(tmpl);
        uint64_t tmplId = tree.nodes[ti].id;

        Node fn1;
        fn1.kind = NodeKind::UInt64;
        fn1.name = "fn_one";
        fn1.parentId = tmplId;
        fn1.offset = 0;
        tree.addNode(fn1);

        Node fn2;
        fn2.kind = NodeKind::UInt64;
        fn2.name = "fn_two";
        fn2.parentId = tmplId;
        fn2.offset = 8;
        tree.addNode(fn2);

        // Pointer in Main referencing VTable
        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "vtable_ptr";
        ptr.parentId = mainId;
        ptr.offset = 4;
        ptr.refId = tmplId;
        tree.addNode(ptr);

        // Provider: pointer at offset 4 points to address 100
        QByteArray data(256, '\0');
        uint64_t ptrVal = 100;
        memcpy(data.data() + 4, &ptrVal, 8);
        // Some data at the pointer target
        uint64_t v1 = 0xDEADBEEF;
        memcpy(data.data() + 100, &v1, 8);
        uint64_t v2 = 0xCAFEBABE;
        memcpy(data.data() + 108, &v2, 8);
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // CommandRow + magic + ptr(merged fold header) + fn1 + fn2 + ptr footer + Main footer = 7
        // VTable standalone: header + fn1 + fn2 + footer = 4
        // Total = 11
        QCOMPARE(result.meta.size(), 11);

        // magic field (depth 1)
        QCOMPARE(result.meta[1].lineKind, LineKind::Field);
        QCOMPARE(result.meta[1].depth, 1);

        // Pointer as merged fold header: "VTable* ptr {"
        QCOMPARE(result.meta[2].lineKind, LineKind::Header);
        QCOMPARE(result.meta[2].depth, 1);
        QVERIFY(result.meta[2].foldHead);
        QCOMPARE(result.meta[2].nodeKind, NodeKind::Pointer64);

        // Expanded fields at depth 2 (struct header merged into pointer)
        QCOMPARE(result.meta[3].depth, 2);
        QCOMPARE(result.meta[4].depth, 2);

        // Pointer fold footer
        QCOMPARE(result.meta[5].lineKind, LineKind::Footer);
        QCOMPARE(result.meta[5].depth, 1);
    }

    void testPointerDerefNull() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node main;
        main.kind = NodeKind::Struct;
        main.name = "Main";
        main.parentId = 0;
        main.offset = 0;
        int mi = tree.addNode(main);
        uint64_t mainId = tree.nodes[mi].id;

        Node tmpl;
        tmpl.kind = NodeKind::Struct;
        tmpl.name = "Target";
        tmpl.parentId = 0;
        tmpl.offset = 200;
        int ti = tree.addNode(tmpl);
        uint64_t tmplId = tree.nodes[ti].id;

        Node tf;
        tf.kind = NodeKind::UInt32;
        tf.name = "field";
        tf.parentId = tmplId;
        tf.offset = 0;
        tree.addNode(tf);

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "ptr";
        ptr.parentId = mainId;
        ptr.offset = 0;
        ptr.refId = tmplId;
        tree.addNode(ptr);

        // All zeros = null pointer
        QByteArray data(256, '\0');
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // CommandRow + ptr(merged fold header) + target field + ptr footer + Main footer = 5
        // Target standalone: header + field + footer = 3
        // Total = 8  (null ptr still shows template preview)
        QCOMPARE(result.meta.size(), 8);

        // Pointer as merged fold header (expanded — shows template at offset 0)
        QCOMPARE(result.meta[1].lineKind, LineKind::Header);
        QCOMPARE(result.meta[1].depth, 1);
        QVERIFY(result.meta[1].foldHead);

        // Target field shown as template preview
        QCOMPARE(result.meta[2].lineKind, LineKind::Field);
        QCOMPARE(result.meta[2].depth, 2);

        // Pointer fold footer
        QCOMPARE(result.meta[3].lineKind, LineKind::Footer);
    }

    void testPointerDerefCollapsed() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node main;
        main.kind = NodeKind::Struct;
        main.name = "Main";
        main.parentId = 0;
        main.offset = 0;
        int mi = tree.addNode(main);
        uint64_t mainId = tree.nodes[mi].id;

        Node tmpl;
        tmpl.kind = NodeKind::Struct;
        tmpl.name = "Target";
        tmpl.parentId = 0;
        tmpl.offset = 200;
        int ti = tree.addNode(tmpl);
        uint64_t tmplId = tree.nodes[ti].id;

        Node tf;
        tf.kind = NodeKind::UInt32;
        tf.name = "field";
        tf.parentId = tmplId;
        tf.offset = 0;
        tree.addNode(tf);

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "ptr";
        ptr.parentId = mainId;
        ptr.offset = 0;
        ptr.refId = tmplId;
        ptr.collapsed = true;  // collapsed
        tree.addNode(ptr);

        // Non-null pointer
        QByteArray data(256, '\0');
        uint64_t ptrVal = 100;
        memcpy(data.data(), &ptrVal, 8);
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // CommandRow + ptr(fold head, collapsed) + Main footer = 3
        // Target standalone: header + field + footer = 3
        // Total = 6
        QCOMPARE(result.meta.size(), 6);

        // Pointer is fold head (depth 1)
        QVERIFY(result.meta[1].foldHead);
        QCOMPARE(result.meta[1].depth, 1);
    }

    void testPointerDerefCycle() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node main;
        main.kind = NodeKind::Struct;
        main.name = "Main";
        main.parentId = 0;
        main.offset = 0;
        int mi = tree.addNode(main);
        uint64_t mainId = tree.nodes[mi].id;

        // Template struct with a self-referencing pointer
        Node tmpl;
        tmpl.kind = NodeKind::Struct;
        tmpl.name = "Recursive";
        tmpl.parentId = 0;
        tmpl.offset = 200;
        int ti = tree.addNode(tmpl);
        uint64_t tmplId = tree.nodes[ti].id;

        Node tf;
        tf.kind = NodeKind::UInt32;
        tf.name = "data";
        tf.parentId = tmplId;
        tf.offset = 0;
        tree.addNode(tf);

        // Self-referencing pointer inside the template
        Node backPtr;
        backPtr.kind = NodeKind::Pointer64;
        backPtr.name = "self";
        backPtr.parentId = tmplId;
        backPtr.offset = 4;
        backPtr.refId = tmplId;  // points back to same struct
        tree.addNode(backPtr);

        // Pointer in Main → Recursive
        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "ptr";
        ptr.parentId = mainId;
        ptr.offset = 0;
        ptr.refId = tmplId;
        tree.addNode(ptr);

        // Provider: main ptr at offset 0 points to 100
        // Inside expansion: backPtr at offset 100+4=104 also points to 100
        QByteArray data(256, '\0');
        uint64_t ptrVal = 100;
        memcpy(data.data(), &ptrVal, 8);       // main ptr → 100
        memcpy(data.data() + 104, &ptrVal, 8); // backPtr at 104 → 100
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // Must not infinite-loop. Verify we got a finite result.
        QVERIFY(result.meta.size() > 0);
        QVERIFY(result.meta.size() < 100); // sanity: bounded output

        // CommandRow + ptr merged header + data + self merged header
        // Second expansion blocked by cycle guard: no children under self
        // Then: self footer + ptr footer + Main footer + standalone Recursive rendering
        QVERIFY(result.meta[1].foldHead);                     // ptr merged fold head
        QCOMPARE(result.meta[1].lineKind, LineKind::Header); // ptr merged header
        QCOMPARE(result.meta[2].lineKind, LineKind::Field);  // data field (first child of Recursive)
    }

    void testStructFooterSimple() {
        // Root footer is suppressed; test nested struct footer instead
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node inner;
        inner.kind = NodeKind::Struct;
        inner.name = "Inner";
        inner.parentId = rootId;
        inner.offset = 0;
        int ii = tree.addNode(inner);
        uint64_t innerId = tree.nodes[ii].id;

        Node f1;
        f1.kind = NodeKind::UInt32;
        f1.name = "a";
        f1.parentId = innerId;
        f1.offset = 0;
        tree.addNode(f1);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Find a footer line (nested struct footer)
        int footerLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Footer) {
                footerLine = i;
                break;
            }
        }
        QVERIFY2(footerLine >= 0, "Should have a footer for nested struct");

        // Footer text should contain "};" (no sizeof)
        QStringList lines = result.text.split('\n');
        QVERIFY(lines[footerLine].contains("};"));
        QVERIFY(!lines[footerLine].contains("sizeof"));
    }

    void testLineMetaHasNodeId() {
        using namespace rcx;
        NodeTree tree;
        tree.baseAddress = 0;
        Node root; root.kind = NodeKind::Struct; root.name = "Root"; root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f; f.kind = NodeKind::Hex32; f.name = "x"; f.parentId = rootId; f.offset = 0;
        tree.addNode(f);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        for (int i = 0; i < result.meta.size(); i++) {
            // Skip CommandRow (synthetic line with sentinel nodeId)
            if (result.meta[i].lineKind == LineKind::CommandRow) {
                QCOMPARE(result.meta[i].nodeId, kCommandRowId);
                QCOMPARE(result.meta[i].nodeIdx, -1);
                continue;
            }
            QVERIFY2(result.meta[i].nodeId != 0,
                qPrintable(QString("Line %1 has nodeId=0").arg(i)));
            int ni = result.meta[i].nodeIdx;
            QVERIFY(ni >= 0 && ni < tree.nodes.size());
            QCOMPARE(result.meta[i].nodeId, tree.nodes[ni].id);
        }
    }

    // ═════════════════════════════════════════════════════════════
    // Array tests
    // ═════════════════════════════════════════════════════════════

    void testArrayHeaderFormat() {
        // Array header must show "elemType[count]" text and proper metadata
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "data";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::Int32;
        arr.arrayLen = 10;
        tree.addNode(arr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Find the array header line
        int headerLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].isArrayHeader) {
                headerLine = i;
                break;
            }
        }
        QVERIFY(headerLine >= 0);

        // Metadata must be correct
        const LineMeta& lm = result.meta[headerLine];
        QCOMPARE(lm.lineKind, LineKind::Header);
        QVERIFY(lm.isArrayHeader);
        QCOMPARE(lm.elementKind, NodeKind::Int32);
        QCOMPARE(lm.arrayCount, 10);
        QVERIFY(lm.foldHead);
        QVERIFY(!lm.foldCollapsed);

        // Text must contain "int32_t[10]" and the name
        QStringList lines = result.text.split('\n');
        QVERIFY(headerLine < lines.size());
        QString text = lines[headerLine];
        QVERIFY2(text.contains("int32_t[10]"),
                 qPrintable("Header should contain 'int32_t[10]': " + text));
        QVERIFY2(text.contains("data"),
                 qPrintable("Header should contain 'data': " + text));
        QVERIFY2(text.contains("{"),
                 qPrintable("Expanded header should contain '{': " + text));
    }

    void testArrayHeaderCharTypes() {
        // UInt8 array → "uint8_t[N]", UInt16 → "uint16_t[N]"
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr1;
        arr1.kind = NodeKind::Array;
        arr1.name = "str";
        arr1.parentId = rootId;
        arr1.offset = 0;
        arr1.elementKind = NodeKind::UInt8;
        arr1.arrayLen = 64;
        tree.addNode(arr1);

        Node arr2;
        arr2.kind = NodeKind::Array;
        arr2.name = "wstr";
        arr2.parentId = rootId;
        arr2.offset = 64;
        arr2.elementKind = NodeKind::UInt16;
        arr2.arrayLen = 32;
        tree.addNode(arr2);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        QStringList lines = result.text.split('\n');
        bool foundChar = false, foundWchar = false;
        for (int i = 0; i < result.meta.size(); i++) {
            if (!result.meta[i].isArrayHeader) continue;
            QString text = lines[i];
            if (text.contains("uint8_t[64]")) foundChar = true;
            if (text.contains("uint16_t[32]")) foundWchar = true;
        }
        QVERIFY2(foundChar, "Should have 'uint8_t[64]' header");
        QVERIFY2(foundWchar, "Should have 'uint16_t[32]' header");
    }

    void testArraySpansClickable() {
        // Element type and count spans must cover the correct text regions
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "numbers";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::UInt32;
        arr.arrayLen = 5;
        tree.addNode(arr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        int headerLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].isArrayHeader) { headerLine = i; break; }
        }
        QVERIFY(headerLine >= 0);

        QStringList lines = result.text.split('\n');
        QString lineText = lines[headerLine];
        const LineMeta& lm = result.meta[headerLine];

        // Element type span must be valid and cover "uint32_t"
        ColumnSpan typeSpan = arrayElemTypeSpanFor(lm, lineText);
        QVERIFY2(typeSpan.valid, "arrayElemTypeSpanFor must return a valid span");
        QVERIFY(typeSpan.start < typeSpan.end);
        QString typeText = lineText.mid(typeSpan.start, typeSpan.end - typeSpan.start);
        QVERIFY2(typeText.contains("uint32_t"),
                 qPrintable("Type span should cover 'uint32_t', got: '" + typeText + "'"));

        // Element count span must be valid and cover "5"
        ColumnSpan countSpan = arrayElemCountSpanFor(lm, lineText);
        QVERIFY2(countSpan.valid, "arrayElemCountSpanFor must return a valid span");
        QVERIFY(countSpan.start < countSpan.end);
        QString countText = lineText.mid(countSpan.start, countSpan.end - countSpan.start);
        QCOMPARE(countText, QString("5"));
    }

    void testArrayWithStructChildren() {
        // Array with struct children renders separators and child fields
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Array container
        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "items";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::Int32;
        arr.arrayLen = 2;
        int ai = tree.addNode(arr);
        uint64_t arrId = tree.nodes[ai].id;

        // Two struct children inside the array (representing elements)
        Node elem0;
        elem0.kind = NodeKind::Struct;
        elem0.name = "Item";
        elem0.parentId = arrId;
        elem0.offset = 0;
        int e0i = tree.addNode(elem0);
        uint64_t elem0Id = tree.nodes[e0i].id;

        Node f0;
        f0.kind = NodeKind::UInt32;
        f0.name = "value";
        f0.parentId = elem0Id;
        f0.offset = 0;
        tree.addNode(f0);

        Node elem1;
        elem1.kind = NodeKind::Struct;
        elem1.name = "Item";
        elem1.parentId = arrId;
        elem1.offset = 4;
        int e1i = tree.addNode(elem1);
        uint64_t elem1Id = tree.nodes[e1i].id;

        Node f1;
        f1.kind = NodeKind::UInt32;
        f1.name = "value";
        f1.parentId = elem1Id;
        f1.offset = 0;
        tree.addNode(f1);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Must have content between header and footer (not empty!)
        QVERIFY2(result.meta.size() > 4,
                 qPrintable(QString("Array should have content, got %1 lines")
                            .arg(result.meta.size())));

        // Check for [0] and [1] separators
        bool found0 = false, found1 = false;
        int fieldCount = 0;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::ArrayElementSeparator) {
                if (result.meta[i].arrayElementIdx == 0) found0 = true;
                if (result.meta[i].arrayElementIdx == 1) found1 = true;
            }
            // Count fields belonging to array children
            if (result.meta[i].lineKind == LineKind::Field &&
                result.meta[i].depth >= 2)
                fieldCount++;
        }
        QVERIFY2(found0, "Array should have [0] separator");
        QVERIFY2(found1, "Array should have [1] separator");
        QVERIFY2(fieldCount >= 2, "Array children should have field lines");
    }

    void testArrayCollapsedNoChildren() {
        // Collapsed array: header only, no children or footer
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "data";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::Float;
        arr.arrayLen = 100;
        arr.collapsed = true;
        int ai = tree.addNode(arr);
        uint64_t arrId = tree.nodes[ai].id;

        // Child that should NOT appear when collapsed
        Node child;
        child.kind = NodeKind::Float;
        child.name = "elem";
        child.parentId = arrId;
        child.offset = 0;
        tree.addNode(child);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // CommandRow + Array header(collapsed) + root footer = 3
        QCOMPARE(result.meta.size(), 3);

        // Array header is collapsed (at index 1)
        int arrLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].isArrayHeader) { arrLine = i; break; }
        }
        QVERIFY(arrLine >= 0);
        QCOMPARE(arrLine, 1);
        QVERIFY(result.meta[arrLine].foldCollapsed);

        // Header text should NOT contain "{"
        QStringList lines = result.text.split('\n');
        QVERIFY2(!lines[arrLine].contains("{"),
                 qPrintable("Collapsed header should not have '{': " + lines[arrLine]));
    }

    void testArrayCountRecompose() {
        // After changing arrayLen and recomposing, the text shows the new count
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "buf";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::UInt8;
        arr.arrayLen = 10;
        int ai = tree.addNode(arr);

        NullProvider prov;

        // First compose: should show [10]
        ComposeResult r1 = compose(tree, prov);
        QStringList lines1 = r1.text.split('\n');
        bool found10 = false;
        for (const QString& l : lines1) {
            if (l.contains("[10]")) { found10 = true; break; }
        }
        QVERIFY2(found10, "First compose should show [10]");

        // Change count and recompose
        tree.nodes[ai].arrayLen = 42;
        ComposeResult r2 = compose(tree, prov);
        QStringList lines2 = r2.text.split('\n');
        bool found42 = false;
        bool still10Header = false;
        for (int i = 0; i < r2.meta.size(); i++) {
            if (r2.meta[i].isArrayHeader && lines2[i].contains("uint8_t[42]")) found42 = true;
            if (r2.meta[i].isArrayHeader && lines2[i].contains("uint8_t[10]")) still10Header = true;
        }
        QVERIFY2(found42, "Recomposed header should show uint8_t[42]");
        QVERIFY2(!still10Header, "Recomposed header should NOT still show uint8_t[10]");

        // Spans must still work after recompose
        int headerLine = -1;
        for (int i = 0; i < r2.meta.size(); i++) {
            if (r2.meta[i].isArrayHeader) { headerLine = i; break; }
        }
        QVERIFY(headerLine >= 0);
        ColumnSpan countSpan = arrayElemCountSpanFor(r2.meta[headerLine], lines2[headerLine]);
        QVERIFY2(countSpan.valid, "Count span must be valid after recompose");
        QString countText = lines2[headerLine].mid(countSpan.start, countSpan.end - countSpan.start);
        QCOMPARE(countText, QString("42"));
    }

    void testPrimitiveArrayElements() {
        // Expanded primitive array should synthesize element lines dynamically
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "values";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::UInt32;
        arr.arrayLen = 4;
        tree.addNode(arr);

        // Buffer with known values: 0x11, 0x22, 0x33, 0x44
        QByteArray data(64, '\0');
        uint32_t v0 = 0x11, v1 = 0x22, v2 = 0x33, v3 = 0x44;
        memcpy(data.data() + 0, &v0, 4);
        memcpy(data.data() + 4, &v1, 4);
        memcpy(data.data() + 8, &v2, 4);
        memcpy(data.data() + 12, &v3, 4);
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);
        QStringList lines = result.text.split('\n');

        // Find array header
        int headerLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].isArrayHeader) { headerLine = i; break; }
        }
        QVERIFY2(headerLine >= 0, "Array header must exist");
        QVERIFY2(lines[headerLine].contains("uint32_t[4]"),
                 qPrintable("Header should contain 'uint32_t[4]': " + lines[headerLine]));

        // Count element field lines (depth >= 2, lineKind == Field)
        int elemCount = 0;
        bool found0 = false, found3 = false;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Field && result.meta[i].depth >= 2) {
                elemCount++;
                // Type column should have combined type+index: "uint32_t[0]"
                if (lines[i].contains("uint32_t[0]")) found0 = true;
                if (lines[i].contains("uint32_t[3]")) found3 = true;
                // isArrayElement flag must be set
                QVERIFY2(result.meta[i].isArrayElement,
                         qPrintable("Element line must have isArrayElement=true: " + lines[i]));
            }
        }
        QCOMPARE(elemCount, 4);
        QVERIFY2(found0, "Should have uint32_t[0] element");
        QVERIFY2(found3, "Should have uint32_t[3] element");

        // Check footer exists
        bool hasFooter = false;
        for (int i = headerLine + 1; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Footer && result.meta[i].nodeKind == NodeKind::Array) {
                hasFooter = true;
                break;
            }
        }
        QVERIFY2(hasFooter, "Array should have footer line");
    }

    void testPrimitiveArrayCollapsed() {
        // Collapsed primitive array should show NO element lines
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "data";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::UInt16;
        arr.arrayLen = 8;
        arr.collapsed = true;
        tree.addNode(arr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // No field lines at depth >= 2 (no synthesized elements)
        int elemFields = 0;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Field && result.meta[i].depth >= 2)
                elemFields++;
        }
        QCOMPARE(elemFields, 0);
    }

    void testStructArrayStillUsesChildren() {
        // Struct array with manual children should still render child nodes, not synthesize
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "items";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.elementKind = NodeKind::Struct;
        arr.arrayLen = 1;
        int ai = tree.addNode(arr);
        uint64_t arrId = tree.nodes[ai].id;

        // One struct child
        Node elem;
        elem.kind = NodeKind::Struct;
        elem.name = "Item";
        elem.parentId = arrId;
        elem.offset = 0;
        int ei = tree.addNode(elem);
        uint64_t elemId = tree.nodes[ei].id;

        Node field;
        field.kind = NodeKind::UInt32;
        field.name = "val";
        field.parentId = elemId;
        field.offset = 0;
        tree.addNode(field);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Should have the child struct's field rendered
        bool hasVal = false;
        QStringList lines = result.text.split('\n');
        for (int i = 0; i < lines.size(); i++) {
            if (lines[i].contains("val")) { hasVal = true; break; }
        }
        QVERIFY2(hasVal, "Struct array child field 'val' should be rendered");
    }

    // ═════════════════════════════════════════════════════════════
    // Pointer tests
    // ═════════════════════════════════════════════════════════════

    void testPointerDefaultVoid() {
        // Pointer64 with no refId should display as "void*"
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "ptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        // refId defaults to 0 (void*)
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Find the pointer line
        int ptrLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].nodeKind == NodeKind::Pointer64 &&
                result.meta[i].lineKind == LineKind::Field) {
                ptrLine = i;
                break;
            }
        }
        QVERIFY(ptrLine >= 0);

        QStringList lines = result.text.split('\n');
        QString text = lines[ptrLine];
        QVERIFY2(text.contains("void*"),
                 qPrintable("Pointer with no refId should show 'void*': " + text));

        // pointerTargetName should be empty (void)
        QVERIFY(result.meta[ptrLine].pointerTargetName.isEmpty());

        // Should NOT be a fold head (no deref expansion for void*)
        QVERIFY(!result.meta[ptrLine].foldHead);
    }

    void testPointer32DefaultVoid() {
        // Same for Pointer32
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer32;
        ptr.name = "ptr32";
        ptr.parentId = rootId;
        ptr.offset = 0;
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        QStringList lines = result.text.split('\n');
        bool foundPtr32 = false;
        for (const QString& l : lines) {
            if (l.contains("void*")) { foundPtr32 = true; break; }
        }
        QVERIFY2(foundPtr32, "Pointer32 with no refId should show 'void*'");
    }

    void testPointerDisplaysTargetName() {
        // Pointer64 with refId displays "TargetName*"
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Target struct with a structTypeName
        Node target;
        target.kind = NodeKind::Struct;
        target.name = "PlayerData";
        target.structTypeName = "PlayerData";
        target.parentId = 0;
        target.offset = 200;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        Node tf;
        tf.kind = NodeKind::UInt32;
        tf.name = "health";
        tf.parentId = targetId;
        tf.offset = 0;
        tree.addNode(tf);

        // Pointer referencing the target (collapsed to prevent expansion)
        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "player";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = true;
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Find the pointer line (root children at depth 0 due to root suppression)
        int ptrLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].nodeKind == NodeKind::Pointer64 &&
                result.meta[i].lineKind == LineKind::Field) {
                ptrLine = i;
                break;
            }
        }
        QVERIFY(ptrLine >= 0);

        QStringList lines = result.text.split('\n');
        QVERIFY2(lines[ptrLine].contains("PlayerData*"),
                 qPrintable("Should show 'PlayerData*': " + lines[ptrLine]));

        // pointerTargetName metadata
        QCOMPARE(result.meta[ptrLine].pointerTargetName, QString("PlayerData"));

        // Pointer with refId is a fold head (even if collapsed)
        QVERIFY(result.meta[ptrLine].foldHead);
        QVERIFY(result.meta[ptrLine].foldCollapsed);
    }

    void testPointerTargetUsesNameWhenNoTypeName() {
        // If target struct has no structTypeName, use its name field
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node target;
        target.kind = NodeKind::Struct;
        target.name = "MyStruct";
        // structTypeName left empty
        target.parentId = 0;
        target.offset = 200;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "sptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = true;
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        QStringList lines = result.text.split('\n');
        bool found = false;
        for (const QString& l : lines) {
            if (l.contains("MyStruct*")) { found = true; break; }
        }
        QVERIFY2(found, "Should use struct name when structTypeName is empty");
    }

    void testPointerSpans() {
        // pointerKindSpanFor and pointerTargetSpanFor must find correct regions
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node target;
        target.kind = NodeKind::Struct;
        target.name = "VTable";
        target.structTypeName = "VTable";
        target.parentId = 0;
        target.offset = 200;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "vtbl";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = true;
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        int ptrLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].nodeKind == NodeKind::Pointer64 &&
                result.meta[i].lineKind == LineKind::Field) {
                ptrLine = i;
                break;
            }
        }
        QVERIFY(ptrLine >= 0);

        QStringList lines = result.text.split('\n');
        QString lineText = lines[ptrLine];
        const LineMeta& lm = result.meta[ptrLine];

        // Kind span: no longer applicable in "Type*" format
        ColumnSpan kindSpan = pointerKindSpanFor(lm, lineText);
        QVERIFY2(!kindSpan.valid, "pointerKindSpanFor should return invalid in Type* format");

        // Target span: covers "VTable" (before the '*')
        ColumnSpan targetSpan = pointerTargetSpanFor(lm, lineText);
        QVERIFY2(targetSpan.valid, "pointerTargetSpanFor must return valid span");
        QString targetText = lineText.mid(targetSpan.start, targetSpan.end - targetSpan.start).trimmed();
        QCOMPARE(targetText, QString("VTable"));
    }

    void testPointerVoidSpans() {
        // void* pointer should have valid target span but no kind span
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "vptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        int ptrLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].nodeKind == NodeKind::Pointer64 &&
                result.meta[i].lineKind == LineKind::Field) {
                ptrLine = i;
                break;
            }
        }
        QVERIFY(ptrLine >= 0);

        QStringList lines = result.text.split('\n');
        QString lineText = lines[ptrLine];
        const LineMeta& lm = result.meta[ptrLine];

        // Kind span: no longer applicable in "Type*" format
        ColumnSpan kindSpan = pointerKindSpanFor(lm, lineText);
        QVERIFY2(!kindSpan.valid, "Kind span should be invalid in Type* format");

        // Target span: "void" (before the '*')
        ColumnSpan targetSpan = pointerTargetSpanFor(lm, lineText);
        QVERIFY2(targetSpan.valid, "void* pointer should have valid target span");
        QString targetText = lineText.mid(targetSpan.start, targetSpan.end - targetSpan.start).trimmed();
        QCOMPARE(targetText, QString("void"));
    }

    void testPointerToPointerChain() {
        // StructB* → StructB { StructC* } → StructC { field }
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // StructC (innermost target)
        Node structC;
        structC.kind = NodeKind::Struct;
        structC.name = "InnerData";
        structC.structTypeName = "InnerData";
        structC.parentId = 0;
        structC.offset = 300;
        int ci = tree.addNode(structC);
        uint64_t structCId = tree.nodes[ci].id;

        Node cf;
        cf.kind = NodeKind::UInt64;
        cf.name = "payload";
        cf.parentId = structCId;
        cf.offset = 0;
        tree.addNode(cf);

        // StructB (middle target, contains ptr to C)
        Node structB;
        structB.kind = NodeKind::Struct;
        structB.name = "Wrapper";
        structB.structTypeName = "Wrapper";
        structB.parentId = 0;
        structB.offset = 200;
        int bi = tree.addNode(structB);
        uint64_t structBId = tree.nodes[bi].id;

        Node bf;
        bf.kind = NodeKind::UInt32;
        bf.name = "flags";
        bf.parentId = structBId;
        bf.offset = 0;
        tree.addNode(bf);

        Node bptr;
        bptr.kind = NodeKind::Pointer64;
        bptr.name = "inner";
        bptr.parentId = structBId;
        bptr.offset = 4;
        bptr.refId = structCId;  // points to InnerData
        tree.addNode(bptr);

        // Root's pointer to StructB
        Node rptr;
        rptr.kind = NodeKind::Pointer64;
        rptr.name = "wrapper_ptr";
        rptr.parentId = rootId;
        rptr.offset = 0;
        rptr.refId = structBId;
        tree.addNode(rptr);

        // Provider: rptr at 0 → addr 100, bptr at 100+4=104 → addr 150
        QByteArray data(400, '\0');
        uint64_t val1 = 100;
        memcpy(data.data(), &val1, 8);       // rptr → 100
        uint64_t val2 = 150;
        memcpy(data.data() + 104, &val2, 8); // bptr at 104 → 150
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // Must finish (no infinite loop)
        QVERIFY(result.meta.size() > 0);
        QVERIFY(result.meta.size() < 200);

        // Check that Wrapper* and InnerData* both appear in text
        bool foundWrapper = false, foundInner = false;
        QStringList lines = result.text.split('\n');
        for (const QString& l : lines) {
            if (l.contains("Wrapper*")) foundWrapper = true;
            if (l.contains("InnerData*")) foundInner = true;
        }
        QVERIFY2(foundWrapper, "Should display 'Wrapper*'");
        QVERIFY2(foundInner, "Should display 'InnerData*'");

        // The chain: Root → Wrapper*(fold head) → Wrapper expanded →
        //   InnerData*(fold head) → InnerData expanded
        int foldHeadCount = 0;
        for (const LineMeta& lm : result.meta) {
            if (lm.foldHead && lm.nodeKind == NodeKind::Pointer64)
                foldHeadCount++;
        }
        // At least 2 fold-head pointers in the expansion chain (rptr + bptr)
        // Plus standalone renderings of StructB and StructC
        QVERIFY2(foldHeadCount >= 2,
                 qPrintable(QString("Expected >=2 pointer fold heads, got %1")
                            .arg(foldHeadCount)));
    }

    void testPointerMutualCycleAtoB() {
        // A→B→A: Main has ptr to StructB, StructB has ptr back to Main
        // Must not infinite-loop
        NodeTree tree;
        tree.baseAddress = 0;

        // Main struct
        Node main;
        main.kind = NodeKind::Struct;
        main.name = "Main";
        main.parentId = 0;
        main.offset = 0;
        int mi = tree.addNode(main);
        uint64_t mainId = tree.nodes[mi].id;

        Node mf;
        mf.kind = NodeKind::UInt32;
        mf.name = "tag";
        mf.parentId = mainId;
        mf.offset = 0;
        tree.addNode(mf);

        // StructB
        Node structB;
        structB.kind = NodeKind::Struct;
        structB.name = "StructB";
        structB.parentId = 0;
        structB.offset = 200;
        int bi = tree.addNode(structB);
        uint64_t structBId = tree.nodes[bi].id;

        Node bf;
        bf.kind = NodeKind::UInt32;
        bf.name = "data";
        bf.parentId = structBId;
        bf.offset = 0;
        tree.addNode(bf);

        // Main → StructB pointer
        Node ptrToB;
        ptrToB.kind = NodeKind::Pointer64;
        ptrToB.name = "to_b";
        ptrToB.parentId = mainId;
        ptrToB.offset = 4;
        ptrToB.refId = structBId;
        tree.addNode(ptrToB);

        // StructB → Main pointer (creates cycle!)
        Node ptrToMain;
        ptrToMain.kind = NodeKind::Pointer64;
        ptrToMain.name = "back";
        ptrToMain.parentId = structBId;
        ptrToMain.offset = 4;
        ptrToMain.refId = mainId;
        tree.addNode(ptrToMain);

        // Provider: Main.to_b at offset 4 → addr 100
        //           StructB expanded at 100: back at 100+4=104 → addr 50
        //           Main expanded at 50: to_b at 50+4=54 → addr 100 (same as before → cycle!)
        QByteArray data(300, '\0');
        uint64_t val1 = 100;
        memcpy(data.data() + 4, &val1, 8);     // Main.to_b → 100
        uint64_t val2 = 50;
        memcpy(data.data() + 104, &val2, 8);   // StructB.back at 104 → 50
        uint64_t val3 = 100;
        memcpy(data.data() + 54, &val3, 8);    // Main.to_b at 54 → 100 (cycle)
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // MUST terminate with bounded output
        QVERIFY(result.meta.size() > 0);
        QVERIFY2(result.meta.size() < 100,
                 qPrintable(QString("Cycle should be bounded, got %1 lines")
                            .arg(result.meta.size())));

        // Both StructB* and Main* should appear
        bool foundToB = false, foundToMain = false;
        QStringList lines = result.text.split('\n');
        for (const QString& l : lines) {
            if (l.contains("StructB*")) foundToB = true;
            if (l.contains("Main*")) foundToMain = true;
        }
        QVERIFY2(foundToB, "Should display 'StructB*'");
        QVERIFY2(foundToMain, "Should display 'Main*'");

        // The first expansion of each pointer works;
        // the cycle is caught on the second attempt.
        // Main root header is suppressed, and pointer deref uses isArrayChild=true
        // (which also skips headers), so we verify cycle detection by bounded output above.
    }

    void testAllStructsResolvedAsPointerTargets() {
        // Multiple structs in the tree; pointers to each should display the name
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Create several structs
        QStringList structNames = {"Alpha", "Bravo", "Charlie", "Delta"};
        QVector<uint64_t> structIds;
        for (int i = 0; i < structNames.size(); i++) {
            Node s;
            s.kind = NodeKind::Struct;
            s.name = structNames[i];
            s.structTypeName = structNames[i];
            s.parentId = 0;
            s.offset = 1000 + i * 100;
            int si = tree.addNode(s);
            structIds << tree.nodes[si].id;

            // Give each struct a field
            Node f;
            f.kind = NodeKind::UInt32;
            f.name = "x";
            f.parentId = tree.nodes[si].id;
            f.offset = 0;
            tree.addNode(f);
        }

        // Create a pointer to each struct
        for (int i = 0; i < structIds.size(); i++) {
            Node ptr;
            ptr.kind = NodeKind::Pointer64;
            ptr.name = QString("ptr_%1").arg(structNames[i].toLower());
            ptr.parentId = rootId;
            ptr.offset = i * 8;
            ptr.refId = structIds[i];
            ptr.collapsed = true;  // don't expand
            tree.addNode(ptr);
        }

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Every struct name should appear in a "Name*" format
        QStringList lines = result.text.split('\n');
        for (const QString& sname : structNames) {
            QString expected = QString("%1*").arg(sname);
            bool found = false;
            for (const QString& l : lines) {
                if (l.contains(expected)) { found = true; break; }
            }
            QVERIFY2(found, qPrintable(QString("Should display '%1'").arg(expected)));
        }
    }

    void testPointerRefIdToDeletedStruct() {
        // If refId points to a non-existent node, degrade to void*
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "dangling";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = 99999;  // non-existent ID
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // Should not crash, and degrade to void
        QStringList lines = result.text.split('\n');
        bool foundVoid = false;
        for (const QString& l : lines) {
            if (l.contains("void*")) { foundVoid = true; break; }
        }
        QVERIFY2(foundVoid, "Dangling refId should degrade to void*");
    }

    void testPointerCollapsedNoExpansion() {
        // Collapsed pointer with valid non-null target must NOT expand
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node target;
        target.kind = NodeKind::Struct;
        target.name = "Heavy";
        target.parentId = 0;
        target.offset = 200;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        // Many children in target - would inflate output if expanded
        for (int i = 0; i < 10; i++) {
            Node f;
            f.kind = NodeKind::UInt64;
            f.name = QString("f%1").arg(i);
            f.parentId = targetId;
            f.offset = i * 8;
            tree.addNode(f);
        }

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "heavy_ptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = true;  // COLLAPSED
        tree.addNode(ptr);

        // Non-null pointer value
        QByteArray data(300, '\0');
        uint64_t ptrVal = 100;
        memcpy(data.data(), &ptrVal, 8);
        BufferProvider prov(data);

        ComposeResult result = compose(tree, prov);

        // Count lines belonging to depth > 1 inside Root
        // (There should be NONE because the pointer is collapsed)
        int expandedLines = 0;
        for (const LineMeta& lm : result.meta) {
            // Lines at depth >= 2 would be inside the pointer expansion
            if (lm.depth >= 2 && lm.nodeIdx >= 0 &&
                tree.nodes[lm.nodeIdx].parentId == targetId)
                expandedLines++;
        }

        // Standalone Heavy rendering adds lines at depth 1,
        // but pointer expansion at depth >= 2 should be zero
        QCOMPARE(expandedLines, 0);
    }

    void testPointerWidthComputation() {
        // Type column must be wide enough for "LongStructName*"
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node target;
        target.kind = NodeKind::Struct;
        target.name = "VeryLongStructNameForTesting";
        target.structTypeName = "VeryLongStructNameForTesting";
        target.parentId = 0;
        target.offset = 200;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "lptr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = true;
        tree.addNode(ptr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // The text must contain the FULL target name, not truncated
        QStringList lines = result.text.split('\n');
        bool foundFull = false;
        for (const QString& l : lines) {
            if (l.contains("VeryLongStructNameForTesting*")) {
                foundFull = true;
                break;
            }
        }
        QVERIFY2(foundFull,
                 "Type column should be wide enough for long pointer target names");

        // Layout type width should accommodate the long name
        // "VeryLongStructNameForTesting*" = 29 chars
        QVERIFY2(result.layout.typeW >= 29,
                 qPrintable(QString("typeW=%1, should be >= 29").arg(result.layout.typeW)));
    }

    // ═════════════════════════════════════════════════════════════
    // Class keyword + alignment tests
    // ═════════════════════════════════════════════════════════════

    void testClassKeywordJsonRoundTrip() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        root.classKeyword = "class";
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f;
        f.kind = NodeKind::Hex32;
        f.name = "x";
        f.parentId = rootId;
        f.offset = 0;
        tree.addNode(f);

        // Save and reload
        QJsonObject json = tree.toJson();
        NodeTree tree2 = NodeTree::fromJson(json);

        // Find the root struct in the reloaded tree
        bool found = false;
        for (const auto& n : tree2.nodes) {
            if (n.kind == NodeKind::Struct && n.name == "Root") {
                QCOMPARE(n.classKeyword, QString("class"));
                QCOMPARE(n.resolvedClassKeyword(), QString("class"));
                found = true;
                break;
            }
        }
        QVERIFY2(found, "Root struct should exist after JSON round-trip");
    }

    void testClassKeywordDefaultsToStruct() {
        NodeTree tree;
        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        // classKeyword left empty
        tree.addNode(root);

        QJsonObject json = tree.toJson();
        NodeTree tree2 = NodeTree::fromJson(json);

        for (const auto& n : tree2.nodes) {
            if (n.kind == NodeKind::Struct) {
                QVERIFY(n.classKeyword.isEmpty());
                QCOMPARE(n.resolvedClassKeyword(), QString("struct"));
                break;
            }
        }
    }

    void testCommandRowRootNameSpan() {
        // Name span should cover the class name in the merged command row
        QString text = "source\u25BE \u00B7 0x0 \u00B7 struct MyClass {";
        ColumnSpan nameSpan = commandRowRootNameSpan(text);
        QVERIFY(nameSpan.valid);

        QString nameText = text.mid(nameSpan.start, nameSpan.end - nameSpan.start);
        QVERIFY2(nameText.trimmed() == "MyClass",
                 qPrintable("Name span should be 'MyClass', got: '" + nameText.trimmed() + "'"));
    }

    void testTextIsNonEmpty() {
        // Verify composed text is actually generated (not empty)
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "TestStruct";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Mix of types including pointers and arrays
        Node f1;
        f1.kind = NodeKind::UInt64;
        f1.name = "id";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "next";
        ptr.parentId = rootId;
        ptr.offset = 8;
        tree.addNode(ptr);

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "buf";
        arr.parentId = rootId;
        arr.offset = 16;
        arr.elementKind = NodeKind::Hex8;
        arr.arrayLen = 16;
        arr.collapsed = true;
        tree.addNode(arr);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        QVERIFY2(!result.text.isEmpty(), "Composed text must not be empty");
        QVERIFY2(result.meta.size() >= 5,
                 qPrintable(QString("Expected >= 5 lines, got %1").arg(result.meta.size())));

        // Every line should have text content
        QStringList lines = result.text.split('\n');
        QCOMPARE(lines.size(), result.meta.size());
        for (int i = 0; i < lines.size(); i++) {
            QVERIFY2(!lines[i].isEmpty(),
                     qPrintable(QString("Line %1 is empty").arg(i)));
        }
    }

    // ═════════════════════════════════════════════════════════════
    // Union tests
    // ═════════════════════════════════════════════════════════════

    void testUnionHeaderShowsKeyword() {
        // Union (Struct with classKeyword="union") should display "union" in header
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Union container
        Node u;
        u.kind = NodeKind::Struct;
        u.classKeyword = "union";
        u.name = "u1";
        u.parentId = rootId;
        u.offset = 0;
        int ui = tree.addNode(u);
        uint64_t uId = tree.nodes[ui].id;

        // Two members at offset 0
        Node m1;
        m1.kind = NodeKind::UInt32;
        m1.name = "asInt";
        m1.parentId = uId;
        m1.offset = 0;
        tree.addNode(m1);

        Node m2;
        m2.kind = NodeKind::Float;
        m2.name = "asFloat";
        m2.parentId = uId;
        m2.offset = 0;
        tree.addNode(m2);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);
        QStringList lines = result.text.split('\n');

        // Find the union header line
        int headerLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Header &&
                result.meta[i].nodeKind == NodeKind::Struct &&
                result.meta[i].depth == 1) {
                headerLine = i;
                break;
            }
        }
        QVERIFY(headerLine >= 0);
        QVERIFY2(lines[headerLine].contains("union"),
                 qPrintable("Union header should contain 'union': " + lines[headerLine]));

        // Both members should be rendered at depth 2
        int memberCount = 0;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Field && result.meta[i].depth == 2)
                memberCount++;
        }
        QCOMPARE(memberCount, 2);

        // Both members share the same offset text (both at 0000)
        QVector<int> memberLines;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Field && result.meta[i].depth == 2)
                memberLines.append(i);
        }
        QCOMPARE(memberLines.size(), 2);
        QCOMPARE(result.meta[memberLines[0]].offsetText,
                 result.meta[memberLines[1]].offsetText);
    }

    void testUnionCollapsed() {
        // Collapsed union should hide children
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node u;
        u.kind = NodeKind::Struct;
        u.classKeyword = "union";
        u.name = "u1";
        u.parentId = rootId;
        u.offset = 0;
        u.collapsed = true;
        int ui = tree.addNode(u);
        uint64_t uId = tree.nodes[ui].id;

        Node m;
        m.kind = NodeKind::UInt64;
        m.name = "val";
        m.parentId = uId;
        m.offset = 0;
        tree.addNode(m);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // No field lines at depth 2
        int deepFields = 0;
        for (const auto& lm : result.meta) {
            if (lm.lineKind == LineKind::Field && lm.depth >= 2)
                deepFields++;
        }
        QCOMPARE(deepFields, 0);
    }

    void testUnionStructSpan() {
        // structSpan of a union = max(child offset + size), not sum
        NodeTree tree;

        Node u;
        u.kind = NodeKind::Struct;
        u.classKeyword = "union";
        u.name = "U";
        u.parentId = 0;
        u.offset = 0;
        int ui = tree.addNode(u);
        uint64_t uId = tree.nodes[ui].id;

        // 2-byte member
        Node m1;
        m1.kind = NodeKind::UInt16;
        m1.name = "small";
        m1.parentId = uId;
        m1.offset = 0;
        tree.addNode(m1);

        // 8-byte member
        Node m2;
        m2.kind = NodeKind::UInt64;
        m2.name = "big";
        m2.parentId = uId;
        m2.offset = 0;
        tree.addNode(m2);

        // structSpan = max(0+2, 0+8) = 8
        QCOMPARE(tree.structSpan(uId), 8);
    }

    // ═════════════════════════════════════════════════════════════
    // Enum compose tests
    // ═════════════════════════════════════════════════════════════

    void testEnumDisplaysMembers() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node e;
        e.kind = NodeKind::Struct;
        e.classKeyword = "enum";
        e.name = "Color";
        e.structTypeName = "Color";
        e.parentId = rootId;
        e.offset = 0;
        e.collapsed = false;
        e.enumMembers = {{"Red", 0}, {"Green", 1}, {"Blue", 2}};
        tree.addNode(e);

        NullProvider prov;
        auto result = compose(tree, prov);

        // Should have enum members in the text
        QVERIFY(result.text.contains("Red"));
        QVERIFY(result.text.contains("Green"));
        QVERIFY(result.text.contains("Blue"));
        QVERIFY(result.text.contains("= 0"));
        QVERIFY(result.text.contains("= 2"));
        // Header should contain "enum"
        QVERIFY(result.text.contains("enum"));
    }

    void testEnumCollapsed() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node e;
        e.kind = NodeKind::Struct;
        e.classKeyword = "enum";
        e.name = "Flags";
        e.structTypeName = "Flags";
        e.parentId = rootId;
        e.offset = 0;
        e.collapsed = true;
        e.enumMembers = {{"A", 0}, {"B", 1}};
        tree.addNode(e);

        NullProvider prov;
        auto result = compose(tree, prov);

        // Collapsed: members should NOT appear
        QVERIFY(!result.text.contains("= 0"));
        QVERIFY(!result.text.contains("= 1"));
        // But header should still show
        QVERIFY(result.text.contains("enum"));
        QVERIFY(result.text.contains("Flags"));
    }

    // ═════════════════════════════════════════════════════════════
    // Compact columns: load EPROCESS.rcx and compare output
    // ═════════════════════════════════════════════════════════════

    void testCompactColumnsEprocess() {
        // Load the EPROCESS example .rcx
        // Try multiple paths: build dir examples, or source dir
        QString rcxPath;
        QStringList candidates = {
            QCoreApplication::applicationDirPath() + "/examples/EPROCESS.rcx",
            QCoreApplication::applicationDirPath() + "/../src/examples/EPROCESS.rcx",
        };
        for (const auto& c : candidates) {
            if (QFile::exists(c)) { rcxPath = c; break; }
        }
        if (rcxPath.isEmpty())
            QSKIP("EPROCESS.rcx not found");
        QFile file(rcxPath);
        QVERIFY2(file.open(QIODevice::ReadOnly),
                 qPrintable("Cannot open " + rcxPath));
        QJsonDocument jdoc = QJsonDocument::fromJson(file.readAll());
        NodeTree tree = NodeTree::fromJson(jdoc.object());
        NullProvider prov;

        // Compose WITHOUT compact (default)
        ComposeResult normal = compose(tree, prov, 0, false);
        // Compose WITH compact
        ComposeResult compact = compose(tree, prov, 0, true);

        // Compact typeW should be capped at kCompactTypeW (22)
        QVERIFY2(compact.layout.typeW <= kCompactTypeW,
                 qPrintable(QString("compact typeW=%1, expected <= %2")
                            .arg(compact.layout.typeW).arg(kCompactTypeW)));

        // Normal typeW should be wider (the _EPROCESS has long type names)
        QVERIFY2(normal.layout.typeW > compact.layout.typeW,
                 qPrintable(QString("normal typeW=%1 should exceed compact typeW=%2")
                            .arg(normal.layout.typeW).arg(compact.layout.typeW)));

        // Print side-by-side sample for visual inspection
        QStringList normalLines  = normal.text.split('\n');
        QStringList compactLines = compact.text.split('\n');
        qDebug() << "\n=== EPROCESS compact columns comparison ===";
        qDebug() << "Normal typeW:" << normal.layout.typeW
                 << " Compact typeW:" << compact.layout.typeW;
        qDebug() << "Normal lines:" << normalLines.size()
                 << " Compact lines:" << compactLines.size();

        // Dump full output to files for visual diffing
        {
            QFile nf(QCoreApplication::applicationDirPath() + "/../eprocess_normal.txt");
            nf.open(QIODevice::WriteOnly);
            nf.write(normal.text.toUtf8());
        }
        {
            QFile cf(QCoreApplication::applicationDirPath() + "/../eprocess_compact.txt");
            cf.open(QIODevice::WriteOnly);
            cf.write(compact.text.toUtf8());
        }
        qDebug() << "Wrote eprocess_normal.txt and eprocess_compact.txt";

        // Show first 50 lines of each for quick inspection
        qDebug() << "\n--- NORMAL (first 50 lines) ---";
        for (int i = 0; i < qMin(50, normalLines.size()); ++i)
            qDebug().noquote() << normalLines[i];

        qDebug() << "\n--- COMPACT (first 50 lines) ---";
        for (int i = 0; i < qMin(50, compactLines.size()); ++i)
            qDebug().noquote() << compactLines[i];

        // Overflow types should print in full (no truncation)
        bool foundFull = false;
        for (const QString& l : compactLines) {
            if (l.contains("_PS_DYNAMIC_ENFORCED_ADDRESS_RANGES")) {
                foundFull = true;
                break;
            }
        }
        QVERIFY2(foundFull,
                 "Long type _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES should print in full (no truncation)");
    }

    void testMmpfnRcxLoadsAndComposes() {
        // Load the MMPFN.rcx example file and verify it composes without errors
        // Try several paths to find the .rcx file
        QString rcxPath;
        for (const auto& p : {
                QStringLiteral("../src/examples/MMPFN.rcx"),
                QStringLiteral("../../src/examples/MMPFN.rcx"),
                QStringLiteral("src/examples/MMPFN.rcx")}) {
            if (QFile::exists(p)) { rcxPath = p; break; }
        }
        if (rcxPath.isEmpty()) {
            QSKIP("MMPFN.rcx not found (run from build dir)");
        }
        QFile f(rcxPath);
        QVERIFY2(f.open(QIODevice::ReadOnly), "Cannot open MMPFN.rcx");
        QJsonDocument jdoc = QJsonDocument::fromJson(f.readAll());
        QVERIFY(jdoc.isObject());
        NodeTree tree = NodeTree::fromJson(jdoc.object());

        QVERIFY2(tree.nodes.size() >= 60, "Expected at least 60 nodes");

        // Check key top-level types exist
        bool hasMmpfn = false, hasListEntry = false, hasMmpte = false;
        for (const auto& n : tree.nodes) {
            if (n.parentId == 0 && n.structTypeName == "_MMPFN") hasMmpfn = true;
            if (n.parentId == 0 && n.structTypeName == "_LIST_ENTRY") hasListEntry = true;
            if (n.parentId == 0 && n.structTypeName == "_MMPTE") hasMmpte = true;
        }
        QVERIFY2(hasMmpfn, "Missing _MMPFN top-level type");
        QVERIFY2(hasListEntry, "Missing _LIST_ENTRY top-level type");
        QVERIFY2(hasMmpte, "Missing _MMPTE top-level type");

        // Compose and verify output
        NullProvider prov;
        ComposeResult result = compose(tree, prov, 0, false);
        QStringList lines = result.text.split('\n');
        QVERIFY2(lines.size() > 10, "Expected non-trivial compose output");

        // Print first 30 lines for manual inspection
        qDebug() << "=== MMPFN compose output ===";
        for (int i = 0; i < qMin(30, lines.size()); ++i)
            qDebug().noquote() << lines[i];
        qDebug() << "... total lines:" << lines.size();

        // Verify _MMPFN header appears in output
        bool foundMmpfn = false;
        for (const auto& l : lines) {
            if (l.contains("_MMPFN")) { foundMmpfn = true; break; }
        }
        QVERIFY2(foundMmpfn, "Compose output should contain _MMPFN");

        // Verify no M_CYCLE markers on any lines (all self-ref pointers are collapsed)
        for (int i = 0; i < result.meta.size(); i++) {
            bool hasCycle = (result.meta[i].markerMask & (1u << M_CYCLE)) != 0;
            QVERIFY2(!hasCycle,
                     qPrintable(QString("Unexpected cycle marker on line %1").arg(i)));
        }
    }

};

QTEST_MAIN(TestCompose)
#include "test_compose.moc"

```

`tests/test_context_menu.cpp`:

```cpp
#include <QtTest/QTest>
#include <QApplication>
#include <QSplitter>
#include <Qsci/qsciscintilla.h>
#include "controller.h"
#include "core.h"

using namespace rcx;

static void buildTree(NodeTree& tree) {
    tree.baseAddress = 0;

    Node root;
    root.kind = NodeKind::Struct;
    root.structTypeName = "Player";
    root.name = "Player";
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    auto field = [&](int off, NodeKind k, const char* name) {
        Node n;
        n.kind = k;
        n.name = name;
        n.parentId = rootId;
        n.offset = off;
        tree.addNode(n);
    };

    field(0,  NodeKind::Int32,  "health");
    field(4,  NodeKind::Int32,  "armor");
    field(8,  NodeKind::Float,  "speed");
    field(12, NodeKind::Hex32,  "flags");
}

static QByteArray makeBuffer() {
    QByteArray data(128, '\0');
    int32_t health = 100;
    memcpy(data.data() + 0, &health, 4);
    int32_t armor = 50;
    memcpy(data.data() + 4, &armor, 4);
    float speed = 3.5f;
    memcpy(data.data() + 8, &speed, 4);
    uint32_t flags = 0xFF00FF00;
    memcpy(data.data() + 12, &flags, 4);
    return data;
}

class TestContextMenu : public QObject {
    Q_OBJECT
private:
    RcxDocument* m_doc = nullptr;
    RcxController* m_ctrl = nullptr;
    QSplitter* m_splitter = nullptr;
    RcxEditor* m_editor = nullptr;

    int findNode(const QString& name) const {
        for (int i = 0; i < m_doc->tree.nodes.size(); i++)
            if (m_doc->tree.nodes[i].name == name) return i;
        return -1;
    }

    int countNodes() const { return m_doc->tree.nodes.size(); }

private slots:
    void init() {
        m_doc = new RcxDocument();
        buildTree(m_doc->tree);
        m_doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        m_splitter = new QSplitter();
        m_ctrl = new RcxController(m_doc, nullptr);
        m_editor = m_ctrl->addSplitEditor(m_splitter);

        m_splitter->resize(800, 600);
        m_splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(m_splitter));
        QApplication::processEvents();
    }

    void cleanup() {
        delete m_ctrl;  m_ctrl = nullptr;
        m_editor = nullptr;
        delete m_splitter;  m_splitter = nullptr;
        delete m_doc;  m_doc = nullptr;
    }

    // ── Insert adds exactly one node ──

    void testInsertAddsOneNode() {
        int before = countNodes();
        uint64_t rootId = m_doc->tree.nodes[0].id;
        m_ctrl->insertNode(rootId, 16, NodeKind::Hex64, "inserted");
        QApplication::processEvents();

        QCOMPARE(countNodes(), before + 1);

        int idx = findNode("inserted");
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::Hex64);
        QCOMPARE(m_doc->tree.nodes[idx].offset, 16);
        QCOMPARE(m_doc->tree.nodes[idx].parentId, rootId);
    }

    // ── Insert at auto-offset places after last sibling ──

    void testInsertAutoOffset() {
        uint64_t rootId = m_doc->tree.nodes[0].id;

        // Last child is "flags" at offset 12, size 4 → end = 16
        m_ctrl->insertNode(rootId, -1, NodeKind::Hex64, "autoPlaced");
        QApplication::processEvents();

        int idx = findNode("autoPlaced");
        QVERIFY(idx >= 0);
        // Hex64 is 8-byte aligned, next aligned offset after 16 is 16
        QCOMPARE(m_doc->tree.nodes[idx].offset, 16);
    }

    // ── Duplicate creates exactly one copy ──

    void testDuplicateAddsOneNode() {
        int flagsIdx = findNode("flags");
        QVERIFY(flagsIdx >= 0);
        int before = countNodes();

        m_ctrl->duplicateNode(flagsIdx);
        QApplication::processEvents();

        QCOMPARE(countNodes(), before + 1);

        int copyIdx = findNode("flags_copy");
        QVERIFY2(copyIdx >= 0, "Expected a node named 'flags_copy'");
        QCOMPARE(m_doc->tree.nodes[copyIdx].kind, NodeKind::Hex32);
        QCOMPARE(m_doc->tree.nodes[copyIdx].offset, 16);  // flags(12) + 4 = 16
    }

    // ── Duplicate preserves original node unchanged ──

    void testDuplicatePreservesOriginal() {
        int flagsIdx = findNode("flags");
        QVERIFY(flagsIdx >= 0);
        NodeKind origKind = m_doc->tree.nodes[flagsIdx].kind;
        int origOffset = m_doc->tree.nodes[flagsIdx].offset;
        QString origName = m_doc->tree.nodes[flagsIdx].name;

        m_ctrl->duplicateNode(flagsIdx);
        QApplication::processEvents();

        // Original should be unchanged (re-find in case index shifted)
        flagsIdx = findNode("flags");
        QVERIFY(flagsIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[flagsIdx].kind, origKind);
        QCOMPARE(m_doc->tree.nodes[flagsIdx].offset, origOffset);
        QCOMPARE(m_doc->tree.nodes[flagsIdx].name, origName);
    }

    // ── Duplicate undo removes the copy ──

    void testDuplicateUndo() {
        int before = countNodes();
        int flagsIdx = findNode("flags");
        QVERIFY(flagsIdx >= 0);

        m_ctrl->duplicateNode(flagsIdx);
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 1);

        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(countNodes(), before);
        QCOMPARE(findNode("flags_copy"), -1);
    }

    // ── Duplicate on struct is no-op ──

    void testDuplicateStructNoOp() {
        int rootIdx = findNode("Player");
        QVERIFY(rootIdx >= 0);
        int before = countNodes();

        m_ctrl->duplicateNode(rootIdx);
        QApplication::processEvents();

        QCOMPARE(countNodes(), before);
    }

    // ── Insert at root level (parentId=0) ──

    void testInsertAtRootLevel() {
        int before = countNodes();
        m_ctrl->insertNode(0, -1, NodeKind::Hex64, "rootField");
        QApplication::processEvents();

        QCOMPARE(countNodes(), before + 1);
        int idx = findNode("rootField");
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].parentId, (uint64_t)0);
    }

    // ── Append 128 bytes adds exactly 16 Hex64 nodes ──

    void testAppend128Bytes() {
        int before = countNodes();

        // Simulate what "Append 128 bytes" does
        m_ctrl->document()->undoStack.beginMacro("Append 128 bytes");
        for (int i = 0; i < 16; i++)
            m_ctrl->insertNode(0, -1, NodeKind::Hex64,
                               QStringLiteral("field_%1").arg(i));
        m_ctrl->document()->undoStack.endMacro();
        QApplication::processEvents();

        QCOMPARE(countNodes(), before + 16);

        // All should be root-level Hex64
        int foundCount = 0;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            const auto& n = m_doc->tree.nodes[i];
            if (n.name.startsWith("field_") && n.parentId == 0
                && n.kind == NodeKind::Hex64) {
                foundCount++;
            }
        }
        QCOMPARE(foundCount, 16);
    }

    // ── Append 128 bytes undo removes all 16 at once ──

    void testAppend128BytesUndo() {
        int before = countNodes();

        m_ctrl->document()->undoStack.beginMacro("Append 128 bytes");
        for (int i = 0; i < 16; i++)
            m_ctrl->insertNode(0, -1, NodeKind::Hex64,
                               QStringLiteral("field_%1").arg(i));
        m_ctrl->document()->undoStack.endMacro();
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 16);

        // Single undo undoes the entire macro
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(countNodes(), before);
    }

    // ── Insert child into struct ──

    void testInsertChildIntoStruct() {
        uint64_t rootId = m_doc->tree.nodes[0].id;
        int before = countNodes();

        m_ctrl->insertNode(rootId, 0, NodeKind::Hex64, "childField");
        QApplication::processEvents();

        QCOMPARE(countNodes(), before + 1);
        int idx = findNode("childField");
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].parentId, rootId);
        QCOMPARE(m_doc->tree.nodes[idx].offset, 0);
    }

    // ── Remove node then undo restores it ──

    void testRemoveAndUndoNode() {
        int flagsIdx = findNode("flags");
        QVERIFY(flagsIdx >= 0);
        int before = countNodes();

        m_ctrl->removeNode(flagsIdx);
        QApplication::processEvents();
        QCOMPARE(countNodes(), before - 1);
        QCOMPARE(findNode("flags"), -1);

        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(countNodes(), before);
        QVERIFY(findNode("flags") >= 0);
    }

    // ── Multiple duplicates each add exactly one ──

    void testMultipleDuplicates() {
        int before = countNodes();
        int healthIdx = findNode("health");
        QVERIFY(healthIdx >= 0);

        m_ctrl->duplicateNode(healthIdx);
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 1);

        int copyIdx = findNode("health_copy");
        QVERIFY(copyIdx >= 0);

        m_ctrl->duplicateNode(copyIdx);
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 2);

        int copy2Idx = findNode("health_copy_copy");
        QVERIFY(copy2Idx >= 0);
    }

    // ── Duplicate copy has correct parent ──

    void testDuplicateCopyParent() {
        int healthIdx = findNode("health");
        QVERIFY(healthIdx >= 0);
        uint64_t parentId = m_doc->tree.nodes[healthIdx].parentId;

        m_ctrl->duplicateNode(healthIdx);
        QApplication::processEvents();

        int copyIdx = findNode("health_copy");
        QVERIFY(copyIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[copyIdx].parentId, parentId);
    }

    // ── Insert struct at root then add children ──

    void testInsertStructAndChildren() {
        int before = countNodes();

        m_ctrl->insertNode(0, -1, NodeKind::Struct, "NewClass");
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 1);

        int structIdx = findNode("NewClass");
        QVERIFY(structIdx >= 0);
        uint64_t structId = m_doc->tree.nodes[structIdx].id;

        m_ctrl->insertNode(structId, 0, NodeKind::Int32, "x");
        m_ctrl->insertNode(structId, -1, NodeKind::Int32, "y");
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 3);

        int xIdx = findNode("x");
        int yIdx = findNode("y");
        QVERIFY(xIdx >= 0);
        QVERIFY(yIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[xIdx].parentId, structId);
        QCOMPARE(m_doc->tree.nodes[yIdx].parentId, structId);
    }

    // ── Batch remove deletes multiple nodes ──

    void testBatchRemove() {
        int healthIdx = findNode("health");
        int armorIdx = findNode("armor");
        QVERIFY(healthIdx >= 0);
        QVERIFY(armorIdx >= 0);
        int before = countNodes();

        m_ctrl->batchRemoveNodes({healthIdx, armorIdx});
        QApplication::processEvents();
        QCOMPARE(countNodes(), before - 2);
        QCOMPARE(findNode("health"), -1);
        QCOMPARE(findNode("armor"), -1);

        // Undo restores both
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(countNodes(), before);
        QVERIFY(findNode("health") >= 0);
        QVERIFY(findNode("armor") >= 0);
    }

    // ── Insert with invalid parent still works (root-level) ──

    void testInsertInvalidParent() {
        int before = countNodes();
        // parentId=999 doesn't exist, but insertNode doesn't validate parent
        m_ctrl->insertNode(999, 0, NodeKind::Hex32, "orphan");
        QApplication::processEvents();
        QCOMPARE(countNodes(), before + 1);
    }

    // ── Duplicate out-of-range index is no-op ──

    void testDuplicateInvalidIndex() {
        int before = countNodes();
        m_ctrl->duplicateNode(-1);
        m_ctrl->duplicateNode(9999);
        QApplication::processEvents();
        QCOMPARE(countNodes(), before);
    }

    // ── Remove out-of-range index is no-op ──

    void testRemoveInvalidIndex() {
        int before = countNodes();
        m_ctrl->removeNode(-1);
        m_ctrl->removeNode(9999);
        QApplication::processEvents();
        QCOMPARE(countNodes(), before);
    }

    // ── Change to Ptr* creates class and sets refId ──

    void testChangeToPtrStarCreatesClassAndSetsRef() {
        // Add a Hex64 node to the root struct
        uint64_t rootId = m_doc->tree.nodes[0].id;
        m_ctrl->insertNode(rootId, 16, NodeKind::Hex64, "ptrField");
        QApplication::processEvents();

        int ptrIdx = findNode("ptrField");
        QVERIFY(ptrIdx >= 0);
        uint64_t ptrNodeId = m_doc->tree.nodes[ptrIdx].id;
        int before = countNodes();

        // Convert to typed pointer
        m_ctrl->convertToTypedPointer(ptrNodeId);
        QApplication::processEvents();

        // Re-find after tree mutation
        ptrIdx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].id == ptrNodeId) { ptrIdx = i; break; }
        }
        QVERIFY(ptrIdx >= 0);

        // Verify: node kind changed to Pointer64
        QCOMPARE(m_doc->tree.nodes[ptrIdx].kind, NodeKind::Pointer64);

        // Verify: node.refId != 0
        uint64_t refId = m_doc->tree.nodes[ptrIdx].refId;
        QVERIFY(refId != 0);

        // Verify: a new Struct node exists with the refId as its id
        int structIdx = m_doc->tree.indexOfId(refId);
        QVERIFY(structIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[structIdx].kind, NodeKind::Struct);

        // Verify: the new struct has children (Hex64 fields)
        auto children = m_doc->tree.childrenOf(refId);
        QVERIFY(children.size() == 16);
        for (int ci : children)
            QCOMPARE(m_doc->tree.nodes[ci].kind, NodeKind::Hex64);

        // Verify: total nodes increased by 1 struct + 16 children = 17
        QCOMPARE(countNodes(), before + 17);

        // Verify: undo restores the original Hex64 kind and refId==0
        m_doc->undoStack.undo();
        QApplication::processEvents();

        ptrIdx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].id == ptrNodeId) { ptrIdx = i; break; }
        }
        QVERIFY(ptrIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[ptrIdx].kind, NodeKind::Hex64);
        QCOMPARE(m_doc->tree.nodes[ptrIdx].refId, (uint64_t)0);
        QCOMPARE(countNodes(), before);
    }
};

QTEST_MAIN(TestContextMenu)
#include "test_context_menu.moc"

```

`tests/test_controller.cpp`:

```cpp
#include <QtTest/QTest>
#include <QtTest/QSignalSpy>
#include <QApplication>
#include <QSplitter>
#include <Qsci/qsciscintilla.h>
#include "controller.h"
#include "core.h"

using namespace rcx;

// Provider with a configurable base address (for testing source-switch logic)
class BaseAwareProvider : public Provider {
    QByteArray m_data;
    uint64_t   m_base;
public:
    BaseAwareProvider(QByteArray data, uint64_t base)
        : m_data(std::move(data)), m_base(base) {}
    bool read(uint64_t addr, void* buf, int len) const override {
        if (addr + len > (uint64_t)m_data.size()) return false;
        std::memcpy(buf, m_data.constData() + addr, len);
        return true;
    }
    int size() const override { return m_data.size(); }
    uint64_t base() const override { return m_base; }
    bool isLive() const override { return true; }
    QString name() const override { return QStringLiteral("test"); }
    QString kind() const override { return QStringLiteral("Process"); }
};

// Small tree: one root struct with a few typed fields at known offsets.
// Keeps tests fast and deterministic (no giant PEB tree).
static void buildSmallTree(NodeTree& tree) {
    tree.baseAddress = 0;

    Node root;
    root.kind = NodeKind::Struct;
    root.structTypeName = "TestStruct";
    root.name = "root";
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    auto field = [&](int off, NodeKind k, const char* name) {
        Node n;
        n.kind = k;
        n.name = name;
        n.parentId = rootId;
        n.offset = off;
        tree.addNode(n);
    };

    field(0,  NodeKind::UInt32,  "field_u32");    // 4 bytes
    field(4,  NodeKind::Float,   "field_float");   // 4 bytes
    field(8,  NodeKind::UInt8,   "field_u8");      // 1 byte
    field(9,  NodeKind::Hex16,   "pad0");           // 2 bytes
    field(11, NodeKind::Hex8,    "pad1");           // 1 byte
    field(12, NodeKind::Hex32,   "field_hex");     // 4 bytes
}

// 64-byte buffer with recognizable pattern
static QByteArray makeSmallBuffer() {
    QByteArray data(64, '\0');
    // field_u32 at offset 0 = 0xDEADBEEF
    uint32_t v32 = 0xDEADBEEF;
    memcpy(data.data() + 0, &v32, 4);
    // field_float at offset 4 = 3.14f
    float vf = 3.14f;
    memcpy(data.data() + 4, &vf, 4);
    // field_u8 at offset 8 = 0x42
    data[8] = 0x42;
    // pad0 at offset 9 = 0x00 0x00 0x00
    // field_hex at offset 12 = 0xCAFEBABE
    uint32_t vhex = 0xCAFEBABE;
    memcpy(data.data() + 12, &vhex, 4);
    return data;
}

class TestController : public QObject {
    Q_OBJECT
private:
    RcxDocument* m_doc = nullptr;
    RcxController* m_ctrl = nullptr;
    QSplitter* m_splitter = nullptr;
    RcxEditor* m_editor = nullptr;

private slots:
    void init() {
        m_doc = new RcxDocument();
        buildSmallTree(m_doc->tree);
        m_doc->provider = std::make_unique<BufferProvider>(makeSmallBuffer());

        m_splitter = new QSplitter();
        // Pass nullptr as parent so controller is not auto-deleted with splitter
        m_ctrl = new RcxController(m_doc, nullptr);
        m_editor = m_ctrl->addSplitEditor(m_splitter);

        m_splitter->resize(800, 600);
        m_splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(m_splitter));
        QApplication::processEvents();
    }

    void cleanup() {
        // Delete controller first (disconnects from editor signals)
        delete m_ctrl;
        m_ctrl = nullptr;
        m_editor = nullptr;  // owned by splitter
        delete m_splitter;
        m_splitter = nullptr;
        delete m_doc;
        m_doc = nullptr;
    }

    // ── Test: setNodeValue writes bytes to provider ──
    void testSetNodeValueWritesData() {
        // Find field_u32 (index 1, child of root at index 0)
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_u32") { idx = i; break; }
        }
        QVERIFY(idx >= 0);

        // Verify original value in provider
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray origBytes = m_doc->provider->readBytes(addr, 4);
        uint32_t origVal;
        memcpy(&origVal, origBytes.data(), 4);
        QCOMPARE(origVal, (uint32_t)0xDEADBEEF);

        // Write new value "42" (decimal)
        m_ctrl->setNodeValue(idx, 0, "42");
        QApplication::processEvents();

        // Read back: should be 42 in little-endian
        QByteArray newBytes = m_doc->provider->readBytes(addr, 4);
        uint32_t newVal;
        memcpy(&newVal, newBytes.data(), 4);
        QCOMPARE(newVal, (uint32_t)42);
    }

    // ── Test: setNodeValue undo/redo restores data ──
    void testSetNodeValueUndoRedo() {
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_u32") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);

        // Original: 0xDEADBEEF
        QByteArray orig = m_doc->provider->readBytes(addr, 4);
        uint32_t origVal;
        memcpy(&origVal, orig.data(), 4);
        QCOMPARE(origVal, (uint32_t)0xDEADBEEF);

        // Write new value
        m_ctrl->setNodeValue(idx, 0, "99");
        QApplication::processEvents();

        uint32_t newVal;
        QByteArray after = m_doc->provider->readBytes(addr, 4);
        memcpy(&newVal, after.data(), 4);
        QCOMPARE(newVal, (uint32_t)99);

        // Undo → should restore original
        m_doc->undoStack.undo();
        QApplication::processEvents();

        QByteArray undone = m_doc->provider->readBytes(addr, 4);
        uint32_t undoneVal;
        memcpy(&undoneVal, undone.data(), 4);
        QCOMPARE(undoneVal, (uint32_t)0xDEADBEEF);

        // Redo → should restore new value
        m_doc->undoStack.redo();
        QApplication::processEvents();

        QByteArray redone = m_doc->provider->readBytes(addr, 4);
        uint32_t redoneVal;
        memcpy(&redoneVal, redone.data(), 4);
        QCOMPARE(redoneVal, (uint32_t)99);
    }

    // ── Test: setNodeValue on Float field ──
    void testSetNodeValueFloat() {
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_float") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);

        // Original: 3.14f
        QByteArray orig = m_doc->provider->readBytes(addr, 4);
        float origVal;
        memcpy(&origVal, orig.data(), 4);
        QVERIFY(qAbs(origVal - 3.14f) < 0.01f);

        // Write "1.5"
        m_ctrl->setNodeValue(idx, 0, "1.5");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 4);
        float newVal;
        memcpy(&newVal, after.data(), 4);
        QCOMPARE(newVal, 1.5f);

        // Undo
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QByteArray undone = m_doc->provider->readBytes(addr, 4);
        float undoneVal;
        memcpy(&undoneVal, undone.data(), 4);
        QVERIFY(qAbs(undoneVal - 3.14f) < 0.01f);
    }

    // ── Test: renameNode changes name and undo restores ──
    void testRenameNode() {
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_u32") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].name, QString("field_u32"));

        m_ctrl->renameNode(idx, "myRenamedField");
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes[idx].name, QString("myRenamedField"));

        // Undo
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].name, QString("field_u32"));

        // Redo
        m_doc->undoStack.redo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].name, QString("myRenamedField"));
    }

    // ── Test: changeNodeKind changes type and undo restores ──
    void testChangeNodeKind() {
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_u32") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::UInt32);

        m_ctrl->changeNodeKind(idx, NodeKind::Float);
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::Float);

        // Undo
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::UInt32);
    }

    // ── Test: insertNode adds a node, removeNode removes it, undo restores ──
    void testInsertAndRemoveNode() {
        int origSize = m_doc->tree.nodes.size();
        uint64_t rootId = m_doc->tree.nodes[0].id;

        // Insert a new Hex64 at offset 16
        m_ctrl->insertNode(rootId, 16, NodeKind::Hex64, "newHex");
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes.size(), origSize + 1);

        // Find the inserted node
        int newIdx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "newHex") { newIdx = i; break; }
        }
        QVERIFY(newIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[newIdx].kind, NodeKind::Hex64);
        QCOMPARE(m_doc->tree.nodes[newIdx].offset, 16);

        // Remove it
        m_ctrl->removeNode(newIdx);
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes.size(), origSize);

        // Undo remove → node restored
        m_doc->undoStack.undo();
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes.size(), origSize + 1);

        // Find again
        newIdx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "newHex") { newIdx = i; break; }
        }
        QVERIFY(newIdx >= 0);
    }

    // ── Test: setNodeValue with Hex32 (space-separated hex bytes) ──
    void testSetNodeValueHex() {
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_hex") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);

        // Original: 0xCAFEBABE
        QByteArray orig = m_doc->provider->readBytes(addr, 4);
        uint32_t origVal;
        memcpy(&origVal, orig.data(), 4);
        QCOMPARE(origVal, (uint32_t)0xCAFEBABE);

        // Write space-separated hex bytes "AA BB CC DD"
        m_ctrl->setNodeValue(idx, 0, "AA BB CC DD");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 4);
        QCOMPARE((uint8_t)after[0], (uint8_t)0xAA);
        QCOMPARE((uint8_t)after[1], (uint8_t)0xBB);
        QCOMPARE((uint8_t)after[2], (uint8_t)0xCC);
        QCOMPARE((uint8_t)after[3], (uint8_t)0xDD);

        // Undo
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QByteArray undone = m_doc->provider->readBytes(addr, 4);
        uint32_t undoneVal;
        memcpy(&undoneVal, undone.data(), 4);
        QCOMPARE(undoneVal, (uint32_t)0xCAFEBABE);
    }

    // ── Test: full inline edit round-trip (type in editor → commit → verify provider) ──
    void testInlineEditRoundTrip() {
        // Refresh to get composed output
        m_ctrl->refresh();
        QApplication::processEvents();

        // Find field_u8 line (UInt8 at offset 8, value = 0x42 = 66)
        ComposeResult result = m_doc->compose();
        int fieldLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].nodeKind == NodeKind::UInt8 &&
                result.meta[i].lineKind == LineKind::Field) {
                fieldLine = i;
                break;
            }
        }
        QVERIFY(fieldLine >= 0);

        m_editor->applyDocument(result);
        QApplication::processEvents();

        // Select this node so edit is allowed
        uint64_t nodeId = result.meta[fieldLine].nodeId;
        QSet<uint64_t> sel;
        sel.insert(nodeId);
        m_editor->applySelectionOverlay(sel);
        QApplication::processEvents();

        // Begin value edit
        bool ok = m_editor->beginInlineEdit(EditTarget::Value, fieldLine);
        QVERIFY2(ok, "Should be able to begin value edit on UInt8 field");
        QVERIFY(m_editor->isEditing());

        // UInt8 values display in hex (e.g., "0x42"). beginInlineEdit selects
        // from after "0x" to end. Type "FF" to replace the hex digits.
        for (QChar c : QString("FF")) {
            QKeyEvent key(QEvent::KeyPress, 0, Qt::NoModifier, QString(c));
            QApplication::sendEvent(m_editor->scintilla(), &key);
        }
        QApplication::processEvents();

        // Commit
        QSignalSpy spy(m_editor, &RcxEditor::inlineEditCommitted);
        QKeyEvent enter(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier);
        QApplication::sendEvent(m_editor->scintilla(), &enter);

        QCOMPARE(spy.count(), 1);
        QList<QVariant> args = spy.first();
        int nodeIdx = args.at(0).toInt();
        QString text = args.at(3).toString().trimmed();
        // The committed text should contain "0xFF" (hex format for UInt8)
        QVERIFY2(!text.isEmpty(), "Committed text should not be empty");

        // Now simulate what controller does: setNodeValue
        m_ctrl->setNodeValue(nodeIdx, 0, text);
        QApplication::processEvents();

        // Verify provider data changed
        int u8Idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_u8") { u8Idx = i; break; }
        }
        QVERIFY(u8Idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(u8Idx);
        QByteArray bytes = m_doc->provider->readBytes(addr, 1);
        QCOMPARE((uint8_t)bytes[0], (uint8_t)0xFF);
    }

    // ── Test: source switch preserves existing base address ──
    void testSourceSwitchPreservesBase() {
        // Set a non-zero baseAddress to simulate a loaded .rcx file
        m_doc->tree.baseAddress = 0x1000;
        QCOMPARE(m_doc->tree.baseAddress, (uint64_t)0x1000);

        // Simulate attaching a new provider whose base differs (e.g. 0x400000)
        auto prov = std::make_shared<BaseAwareProvider>(makeSmallBuffer(), 0x400000);
        uint64_t newBase = prov->base();
        QCOMPARE(newBase, (uint64_t)0x400000);

        m_doc->provider = prov;
        // Controller logic: keep existing baseAddress when non-zero
        if (m_doc->tree.baseAddress == 0)
            m_doc->tree.baseAddress = newBase;

        // baseAddress must stay at the original value
        QCOMPARE(m_doc->tree.baseAddress, (uint64_t)0x1000);
        // provider base is unchanged (no setBase sync) — provider reports its own initial base
        QCOMPARE(m_doc->provider->base(), (uint64_t)0x400000);
    }

    // ── Test: source switch on fresh doc uses provider default ──
    void testSourceSwitchFreshDocUsesProviderBase() {
        // Simulate a fresh document (no loaded .rcx → baseAddress == 0)
        m_doc->tree.baseAddress = 0;

        auto prov = std::make_shared<BaseAwareProvider>(makeSmallBuffer(), 0x7FFE0000);
        uint64_t newBase = prov->base();

        m_doc->provider = prov;
        if (m_doc->tree.baseAddress == 0)
            m_doc->tree.baseAddress = newBase;

        // Fresh doc should adopt the provider's default base
        QCOMPARE(m_doc->tree.baseAddress, (uint64_t)0x7FFE0000);
    }

    // ── Test: toggleCollapse + undo ──
    void testToggleCollapse() {
        // Root is index 0, a Struct node
        QCOMPARE(m_doc->tree.nodes[0].kind, NodeKind::Struct);
        QCOMPARE(m_doc->tree.nodes[0].collapsed, false);

        m_ctrl->toggleCollapse(0);
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[0].collapsed, true);

        m_ctrl->toggleCollapse(0);
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[0].collapsed, false);

        // Undo twice: uncollapse → collapse → original (false)
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[0].collapsed, true);

        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[0].collapsed, false);
    }
    // ── Test: value history popup only appears during inline editing ──
    void testValueHistoryPopupOnlyDuringEdit() {
        // Record value history for field_u32 so it has heat
        auto& tree = m_doc->tree;
        int idx = -1;
        for (int i = 0; i < tree.nodes.size(); i++) {
            if (tree.nodes[i].name == "field_u32") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        uint64_t nodeId = tree.nodes[idx].id;

        QHash<uint64_t, ValueHistory> history;
        history[nodeId].record("100");
        history[nodeId].record("200");
        history[nodeId].record("300");
        QVERIFY(history[nodeId].uniqueCount() > 1);

        m_editor->setValueHistoryRef(&history);

        // Refresh and compose so editor has meta with heatLevel
        m_ctrl->refresh();
        QApplication::processEvents();
        ComposeResult result = m_doc->compose();
        // Manually set heat on the node's line meta
        for (auto& lm : result.meta) {
            if (lm.nodeId == nodeId) lm.heatLevel = 2;
        }
        m_editor->applyDocument(result);
        QApplication::processEvents();

        // Popup should not exist or not be visible (no editing active)
        auto* popup = m_editor->findChild<QWidget*>(QString(), Qt::FindDirectChildrenOnly);
        // Even if popup widget exists, it should not be visible
        bool popupVisible = false;
        for (auto* child : m_editor->findChildren<QFrame*>(QString(), Qt::FindDirectChildrenOnly)) {
            if (child->isVisible() && child->windowFlags() & Qt::ToolTip)
                popupVisible = true;
        }
        QVERIFY2(!popupVisible, "Popup should not be visible when not editing");

        // Start inline edit on value column of field_u32
        int fieldLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].nodeId == nodeId && result.meta[i].lineKind == LineKind::Field) {
                fieldLine = i; break;
            }
        }
        QVERIFY(fieldLine >= 0);

        bool ok = m_editor->beginInlineEdit(EditTarget::Value, fieldLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        // Trigger hover cursor update (simulates mouse move during editing)
        QApplication::processEvents();

        // Cancel edit to clean up
        m_editor->cancelInlineEdit();
        QApplication::processEvents();

        m_editor->setValueHistoryRef(nullptr);
    }

    // ── Test: delete node clears value history for shifted siblings ──
    void testDeleteClearsHeatForShiftedNodes() {
        // Replace with a live provider so refresh() actually records values
        m_doc->provider = std::make_unique<BaseAwareProvider>(makeSmallBuffer(), 0x1000);
        m_ctrl->refresh();
        QApplication::processEvents();

        auto& tree = m_doc->tree;

        // Locate field_u32 (the node we'll delete) and the siblings after it.
        // The small tree has: field_u32(0), field_float(4), field_u8(8),
        //                     pad0/Hex16(9), pad1/Hex8(11), field_hex/Hex32(12)
        // field_float and field_u8 are regular (non-hex) types.
        int delIdx = -1;
        for (int i = 0; i < tree.nodes.size(); i++) {
            if (tree.nodes[i].name == "field_u32") { delIdx = i; break; }
        }
        QVERIFY(delIdx >= 0);
        uint64_t delId = tree.nodes[delIdx].id;

        // Collect sibling node IDs that come after field_u32 (will be shifted)
        uint64_t parentId = tree.nodes[delIdx].parentId;
        int deletedSize = tree.nodes[delIdx].byteSize(); // 4 bytes
        int deletedEnd = tree.nodes[delIdx].offset + deletedSize;
        QVector<uint64_t> shiftedIds;
        QHash<uint64_t, QString> nameMap;  // for debug messages
        for (int i = 0; i < tree.nodes.size(); i++) {
            if (tree.nodes[i].parentId == parentId && i != delIdx
                && tree.nodes[i].offset >= deletedEnd) {
                shiftedIds.append(tree.nodes[i].id);
                nameMap[tree.nodes[i].id] = tree.nodes[i].name;
            }
        }
        QVERIFY2(!shiftedIds.isEmpty(), "Should have siblings after field_u32");

        // Seed value history for shifted siblings (simulate accumulated heat)
        auto& history = const_cast<QHash<uint64_t, ValueHistory>&>(m_ctrl->valueHistory());
        for (uint64_t id : shiftedIds) {
            history[id].record("old_val_1");
            history[id].record("old_val_2");
            history[id].record("old_val_3");
            QVERIFY2(history[id].heatLevel() >= 2,
                     qPrintable(QString("Pre-delete: %1 should have heat>=2")
                                .arg(nameMap[id])));
        }

        // Also seed the to-be-deleted node
        history[delId].record("del_1");
        history[delId].record("del_2");
        QVERIFY(history.contains(delId));

        // Delete field_u32 — this shifts all subsequent siblings
        m_ctrl->removeNode(delIdx);
        QApplication::processEvents();

        // The deleted node's history should be gone
        QVERIFY2(!m_ctrl->valueHistory().contains(delId),
                 "Deleted node's value history should be cleared");

        // All shifted siblings should have heat=0 after the delete.
        // With a live provider, refresh() inside removeNode re-records one new
        // value at the new offset → count=1 → heatLevel=0.
        for (uint64_t id : shiftedIds) {
            int heat = m_ctrl->valueHistory().contains(id)
                ? m_ctrl->valueHistory()[id].heatLevel() : 0;
            QVERIFY2(heat == 0,
                     qPrintable(QString("Shifted node '%1' (id=%2) should have heat=0, got %3")
                                .arg(nameMap[id]).arg(id).arg(heat)));
        }
    }

    // ── Test: value history records and cycles correctly ──
    void testValueHistoryRingBuffer() {
        ValueHistory vh;
        QCOMPARE(vh.count, 0);
        QCOMPARE(vh.heatLevel(), 0);

        vh.record("10");
        QCOMPARE(vh.count, 1);
        QCOMPARE(vh.heatLevel(), 0);  // 1 unique = static

        // Duplicate should not increase count
        vh.record("10");
        QCOMPARE(vh.count, 1);

        vh.record("20");
        QCOMPARE(vh.count, 2);
        QCOMPARE(vh.heatLevel(), 1);  // cold

        vh.record("30");
        QCOMPARE(vh.count, 3);
        QCOMPARE(vh.heatLevel(), 2);  // warm

        vh.record("40");
        vh.record("50");
        QCOMPARE(vh.count, 5);
        QCOMPARE(vh.heatLevel(), 3);  // hot

        QCOMPARE(vh.last(), QString("50"));

        // Ring buffer: uniqueCount() caps at kCapacity
        for (int i = 0; i < 20; i++)
            vh.record(QString::number(100 + i));
        QCOMPARE(vh.uniqueCount(), ValueHistory::kCapacity);
        QVERIFY(vh.count > ValueHistory::kCapacity);

        // forEach iterates oldest→newest within ring
        QStringList vals;
        vh.forEach([&](const QString& v) { vals.append(v); });
        QCOMPARE(vals.size(), ValueHistory::kCapacity);
        QCOMPARE(vals.last(), vh.last());
    }
    // ── Test: inline edit "int32_t[4]" on primitive converts to array ──
    void testInlineEditPrimitiveArray() {
        // Find a primitive field to convert
        int idx = -1;
        for (int i = 0; i < m_doc->tree.nodes.size(); i++) {
            if (m_doc->tree.nodes[i].name == "field_u32") { idx = i; break; }
        }
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::UInt32);
        uint64_t nodeId = m_doc->tree.nodes[idx].id;

        // Emit inlineEditCommitted with array syntax
        emit m_editor->inlineEditCommitted(idx, 0, EditTarget::Type,
                                           QStringLiteral("int32_t[4]"));
        QApplication::processEvents();

        // Node should now be an Array with elementKind=Int32, arrayLen=4
        int newIdx = m_doc->tree.indexOfId(nodeId);
        QVERIFY(newIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[newIdx].kind, NodeKind::Array);
        QCOMPARE(m_doc->tree.nodes[newIdx].elementKind, NodeKind::Int32);
        QCOMPARE(m_doc->tree.nodes[newIdx].arrayLen, 4);

        // Undo should restore to UInt32
        m_doc->undoStack.undo();
        QApplication::processEvents();
        newIdx = m_doc->tree.indexOfId(nodeId);
        QVERIFY(newIdx >= 0);
        QCOMPARE(m_doc->tree.nodes[newIdx].kind, NodeKind::UInt32);
    }
};

QTEST_MAIN(TestController)
#include "test_controller.moc"

```

`tests/test_core.cpp`:

```cpp
#include <QtTest/QTest>
#include "core.h"

class TestCore : public QObject {
    Q_OBJECT
private slots:
    void testSizeForKind() {
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Hex8),  1);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Hex16), 2);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Hex32), 4);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Hex64), 8);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Float), 4);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Double), 8);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Vec3),  12);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Mat4x4), 64);
        QCOMPARE(rcx::sizeForKind(rcx::NodeKind::Struct), 0);
    }

    void testLinesForKind() {
        QCOMPARE(rcx::linesForKind(rcx::NodeKind::Hex32), 1);
        QCOMPARE(rcx::linesForKind(rcx::NodeKind::Vec2),  1);
        QCOMPARE(rcx::linesForKind(rcx::NodeKind::Vec3),  1);
        QCOMPARE(rcx::linesForKind(rcx::NodeKind::Vec4),  1);
        QCOMPARE(rcx::linesForKind(rcx::NodeKind::Mat4x4), 4);
    }

    void testKindStringRoundTrip() {
        for (int i = 0; i <= static_cast<int>(rcx::NodeKind::Array); i++) {
            auto kind = static_cast<rcx::NodeKind>(i);
            QString s = rcx::kindToString(kind);
            QCOMPARE(rcx::kindFromString(s), kind);
        }
    }

    void testNodeTree_addAndChildren() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        QCOMPARE(ri, 0);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node child;
        child.kind = rcx::NodeKind::Hex32;
        child.name = "field";
        child.parentId = rootId;
        child.offset = 0;
        tree.addNode(child);

        auto children = tree.childrenOf(rootId);
        QCOMPARE(children.size(), 1);
        QCOMPARE(children[0], 1);

        auto roots = tree.childrenOf(0);
        QCOMPARE(roots.size(), 1);
        QCOMPARE(roots[0], 0);
    }

    void testNodeTree_depth() {
        rcx::NodeTree tree;
        rcx::Node a; a.kind = rcx::NodeKind::Struct; a.name = "A"; a.parentId = 0;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;
        rcx::Node b; b.kind = rcx::NodeKind::Struct; b.name = "B"; b.parentId = aId;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;
        rcx::Node c; c.kind = rcx::NodeKind::Hex8; c.name = "c"; c.parentId = bId;
        tree.addNode(c);

        QCOMPARE(tree.depthOf(0), 0);
        QCOMPARE(tree.depthOf(1), 1);
        QCOMPARE(tree.depthOf(2), 2);
    }

    void testNodeTree_computeOffset() {
        rcx::NodeTree tree;
        tree.baseAddress = 0x1000;
        rcx::Node root; root.kind = rcx::NodeKind::Struct; root.name = "R";
        root.parentId = 0; root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node f; f.kind = rcx::NodeKind::Hex32; f.name = "f";
        f.parentId = rootId; f.offset = 16;
        tree.addNode(f);

        QCOMPARE(tree.computeOffset(1), 16);
    }

    void testNodeTree_jsonRoundTrip() {
        rcx::NodeTree tree;
        tree.baseAddress = 0xDEAD;
        rcx::Node root; root.kind = rcx::NodeKind::Struct; root.name = "Test";
        root.parentId = 0; root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node child; child.kind = rcx::NodeKind::Float; child.name = "val";
        child.parentId = rootId; child.offset = 8;
        tree.addNode(child);

        QJsonObject json = tree.toJson();
        rcx::NodeTree tree2 = rcx::NodeTree::fromJson(json);

        QCOMPARE(tree2.baseAddress, (uint64_t)0xDEAD);
        QCOMPARE(tree2.nodes.size(), 2);
        QCOMPARE(tree2.nodes[0].name, QString("Test"));
        QCOMPARE(tree2.nodes[1].kind, rcx::NodeKind::Float);
        QCOMPARE(tree2.nodes[1].offset, 8);
    }

    void testBufferProvider() {
        QByteArray data(16, '\0');
        data[0] = 0x42;
        data[4] = 0x10;
        data[5] = 0x20;

        rcx::BufferProvider prov(data);
        QVERIFY(prov.isValid());
        QCOMPARE(prov.size(), 16);
        QCOMPARE(prov.readU8(0), (uint8_t)0x42);
        QCOMPARE(prov.readU16(4), (uint16_t)0x2010);
    }

    void testNullProvider() {
        rcx::NullProvider prov;
        QVERIFY(!prov.isValid());
        QVERIFY(!prov.isReadable(0, 1));
        QCOMPARE(prov.readU8(0), (uint8_t)0);
        QCOMPARE(prov.readU32(0), (uint32_t)0);
    }

    void testIsReadable() {
        QByteArray data(16, '\0');
        rcx::BufferProvider prov(data);
        QVERIFY(prov.isReadable(0, 4));
        QVERIFY(prov.isReadable(0, 16));
        QVERIFY(!prov.isReadable(0, 17));
        QVERIFY(!prov.isReadable(15, 2));
        QVERIFY(prov.isReadable(15, 1));
    }

    void testStableNodeIds() {
        rcx::NodeTree tree;
        rcx::Node a; a.kind = rcx::NodeKind::Struct; a.name = "A"; a.parentId = 0;
        int ai = tree.addNode(a);
        QCOMPARE(tree.nodes[ai].id, (uint64_t)1);

        rcx::Node b; b.kind = rcx::NodeKind::Hex32; b.name = "B"; b.parentId = tree.nodes[ai].id;
        int bi = tree.addNode(b);
        QCOMPARE(tree.nodes[bi].id, (uint64_t)2);

        QCOMPARE(tree.indexOfId(1), 0);
        QCOMPARE(tree.indexOfId(2), 1);
        QCOMPARE(tree.indexOfId(99), -1);
    }

    void testByteSizeDynamic() {
        rcx::Node n;
        n.kind = rcx::NodeKind::UTF8;
        n.strLen = 128;
        QCOMPARE(n.byteSize(), 128);

        n.kind = rcx::NodeKind::UTF16;
        n.strLen = 32;
        QCOMPARE(n.byteSize(), 64); // 32 * 2

        n.kind = rcx::NodeKind::Float;
        QCOMPARE(n.byteSize(), 4); // falls back to sizeForKind
    }

    void testSubtreeCycleSafe() {
        rcx::NodeTree tree;
        rcx::Node a; a.kind = rcx::NodeKind::Struct; a.name = "A"; a.parentId = 0;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        // Create a child that points back to A's id as parent — not a cycle per se,
        // but test that subtree collection terminates
        rcx::Node b; b.kind = rcx::NodeKind::Hex8; b.name = "B"; b.parentId = aId;
        tree.addNode(b);

        // Should return both nodes without hanging
        auto sub = tree.subtreeIndices(aId);
        QCOMPARE(sub.size(), 2);
        QVERIFY(sub.contains(0));
        QVERIFY(sub.contains(1));
    }

    void testIsReadableOverflow() {
        QByteArray data(16, '\0');
        rcx::BufferProvider prov(data);
        // Normal cases
        QVERIFY(prov.isReadable(0, 16));
        QVERIFY(!prov.isReadable(0, 17));
        // Large address
        QVERIFY(!prov.isReadable(0xFFFFFFFFFFFFFFFFULL, 1));
        // Negative len
        QVERIFY(!prov.isReadable(0, -1));
        // Zero len is readable
        QVERIFY(prov.isReadable(0, 0));
        QVERIFY(prov.isReadable(16, 0));
    }

    void testAlignmentFor() {
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Hex8),  1);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Hex16), 2);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Hex32), 4);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Hex64), 8);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Float), 4);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Double), 8);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Vec3),  4);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Mat4x4), 4);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::UTF8),  1);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::UTF16), 2);
        QCOMPARE(rcx::alignmentFor(rcx::NodeKind::Struct), 1);
    }

    void testDepthOfCycle() {
        rcx::NodeTree tree;
        // Create two nodes that reference each other as parents
        rcx::Node a; a.kind = rcx::NodeKind::Struct; a.name = "A"; a.parentId = 0;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        rcx::Node b; b.kind = rcx::NodeKind::Struct; b.name = "B"; b.parentId = aId;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;

        // Manually create a cycle: A's parent → B
        tree.nodes[ai].parentId = bId;
        tree.invalidateIdCache();

        // Should not hang — cycle detection terminates
        int d = tree.depthOf(ai);
        QVERIFY(d < 100);
    }

    void testComputeOffsetCycle() {
        rcx::NodeTree tree;
        rcx::Node a; a.kind = rcx::NodeKind::Struct; a.name = "A"; a.parentId = 0; a.offset = 10;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        rcx::Node b; b.kind = rcx::NodeKind::Struct; b.name = "B"; b.parentId = aId; b.offset = 20;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;

        // Create cycle: A → B → A
        tree.nodes[ai].parentId = bId;
        tree.invalidateIdCache();

        // Should not hang
        int off = tree.computeOffset(ai);
        Q_UNUSED(off);
        QVERIFY(true); // reaching here means no hang
    }

    void testProviderWrite() {
        QByteArray data(16, '\0');
        rcx::BufferProvider prov(data);
        QVERIFY(prov.isWritable());

        QByteArray patch;
        patch.append((char)0x42);
        patch.append((char)0x43);
        QVERIFY(prov.writeBytes(0, patch));
        QCOMPARE(prov.readU8(0), (uint8_t)0x42);
        QCOMPARE(prov.readU8(1), (uint8_t)0x43);

        // Write past end should fail
        QVERIFY(!prov.writeBytes(15, patch));

        // NullProvider is not writable
        rcx::NullProvider np;
        QVERIFY(!np.isWritable());
    }

    void testComputeOffsetLarge() {
        // Verify computeOffset returns int64_t that doesn't overflow
        rcx::NodeTree tree;
        rcx::Node root; root.kind = rcx::NodeKind::Struct; root.name = "R";
        root.parentId = 0; root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node child; child.kind = rcx::NodeKind::Hex8; child.name = "f";
        child.parentId = rootId; child.offset = 0x7FFFFFFF; // max int32
        tree.addNode(child);

        int64_t off = tree.computeOffset(1);
        QCOMPARE(off, (int64_t)0x7FFFFFFF);
    }

    void testKindMetaCompleteness() {
        // Every NodeKind enum value must have a KindMeta entry
        for (int i = 0; i <= static_cast<int>(rcx::NodeKind::Array); i++) {
            auto kind = static_cast<rcx::NodeKind>(i);
            const rcx::KindMeta* m = rcx::kindMeta(kind);
            QVERIFY2(m != nullptr,
                qPrintable(QString("Missing KindMeta for kind %1").arg(i)));
            QCOMPARE(m->kind, kind);
            QVERIFY(m->name != nullptr);
            QVERIFY(m->typeName != nullptr);
            QVERIFY(m->lines >= 1);
            QVERIFY(m->align >= 1);
        }
        // sizeForKind/linesForKind/alignmentFor must agree with table
        for (const auto& m : rcx::kKindMeta) {
            QCOMPARE(rcx::sizeForKind(m.kind), m.size);
            QCOMPARE(rcx::linesForKind(m.kind), m.lines);
            QCOMPARE(rcx::alignmentFor(m.kind), m.align);
        }
    }

    void testColumnSpan_field() {
        rcx::LineMeta lm;
        lm.lineKind = rcx::LineKind::Field;
        lm.depth = 1;
        lm.isContinuation = false;
        lm.nodeIdx = 0;

        // kFoldCol (3) + depth*3 = 6
        auto ts = rcx::typeSpanFor(lm);
        QVERIFY(ts.valid);
        QCOMPARE(ts.start, 6);
        QCOMPARE(ts.end, 20);   // 6 + 14 (kColType)

        auto ns = rcx::nameSpanFor(lm);
        QVERIFY(ns.valid);
        QCOMPARE(ns.start, 21); // 6 + 14 + 1 (kSepWidth)
        QCOMPARE(ns.end, 43);   // 21 + 22 (kColName)

        auto vs = rcx::valueSpanFor(lm, 100);
        QVERIFY(vs.valid);
        QCOMPARE(vs.start, 44); // 21 + 22 + 1 (kSepWidth)
        QCOMPARE(vs.end, 44 + rcx::kColValue);
    }

    void testColumnSpan_continuation() {
        rcx::LineMeta lm;
        lm.lineKind = rcx::LineKind::Continuation;
        lm.depth = 1;
        lm.isContinuation = true;
        lm.nodeIdx = 0;

        QVERIFY(!rcx::typeSpanFor(lm).valid);
        QVERIFY(!rcx::nameSpanFor(lm).valid);

        auto vs = rcx::valueSpanFor(lm, 100);
        QVERIFY(vs.valid);
        QCOMPARE(vs.start, 6 + 14 + 22 + 2);  // kFoldCol+indent + kColType(14) + kColName(22) + 2*kSepWidth
        QCOMPARE(vs.end, 44 + rcx::kColValue);
    }

    void testColumnSpan_headerFooter() {
        rcx::LineMeta lm;
        lm.lineKind = rcx::LineKind::Header;
        lm.depth = 0;
        lm.nodeIdx = 0;

        QVERIFY(!rcx::typeSpanFor(lm).valid);
        QVERIFY(!rcx::nameSpanFor(lm).valid);
        QVERIFY(!rcx::valueSpanFor(lm, 40).valid);

        lm.lineKind = rcx::LineKind::Footer;
        QVERIFY(!rcx::typeSpanFor(lm).valid);
        QVERIFY(!rcx::nameSpanFor(lm).valid);
        QVERIFY(!rcx::valueSpanFor(lm, 40).valid);
    }

    void testColumnSpan_depth0() {
        rcx::LineMeta lm;
        lm.lineKind = rcx::LineKind::Field;
        lm.depth = 0;
        lm.isContinuation = false;
        lm.nodeIdx = 0;

        // kFoldCol (3) + depth*3(0) = 3
        auto ts = rcx::typeSpanFor(lm);
        QVERIFY(ts.valid);
        QCOMPARE(ts.start, 3);
        QCOMPARE(ts.end, 17);   // 3 + 14 (kColType)

        auto ns = rcx::nameSpanFor(lm);
        QVERIFY(ns.valid);
        QCOMPARE(ns.start, 18); // 3 + 14 + 1 (kSepWidth)
        QCOMPARE(ns.end, 40);   // 18 + 22 (kColName)

        auto vs = rcx::valueSpanFor(lm, 100);
        QVERIFY(vs.valid);
        QCOMPARE(vs.start, 41); // 18 + 22 + 1 (kSepWidth)
        QCOMPARE(vs.end, 41 + rcx::kColValue);   // start + kColValue
    }

    void testNodeIdJsonRoundTrip() {
        rcx::NodeTree tree;
        rcx::Node n; n.kind = rcx::NodeKind::Float; n.name = "x"; n.parentId = 0;
        tree.addNode(n);
        tree.addNode(n);

        QJsonObject json = tree.toJson();
        rcx::NodeTree t2 = rcx::NodeTree::fromJson(json);
        QCOMPARE(t2.nodes[0].id, tree.nodes[0].id);
        QCOMPARE(t2.nodes[1].id, tree.nodes[1].id);
        QVERIFY(t2.m_nextId >= 3);
    }

    void testStructSpan() {
        using namespace rcx;
        NodeTree tree;
        tree.baseAddress = 0;

        // Struct with UInt32 (offset 0, 4 bytes) + UInt64 (offset 4, 8 bytes)
        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Root";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f1;
        f1.kind = NodeKind::UInt32;
        f1.name = "a";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        Node f2;
        f2.kind = NodeKind::UInt64;
        f2.name = "b";
        f2.parentId = rootId;
        f2.offset = 4;
        tree.addNode(f2);

        // Span = max(0+4, 4+8) = 12
        QCOMPARE(tree.structSpan(rootId), 12);

        // Nested struct: inner at offset 0 with a UInt64 at offset 0 (size 8)
        NodeTree tree2;
        Node outer;
        outer.kind = NodeKind::Struct;
        outer.name = "Outer";
        outer.parentId = 0;
        int oi = tree2.addNode(outer);
        uint64_t outerId = tree2.nodes[oi].id;

        Node inner;
        inner.kind = NodeKind::Struct;
        inner.name = "Inner";
        inner.parentId = outerId;
        inner.offset = 0;
        int ii = tree2.addNode(inner);
        uint64_t innerId = tree2.nodes[ii].id;

        Node leaf;
        leaf.kind = NodeKind::UInt64;
        leaf.name = "x";
        leaf.parentId = innerId;
        leaf.offset = 0;
        tree2.addNode(leaf);

        // Inner span = 8, outer span = max(0+8) = 8
        QCOMPARE(tree2.structSpan(innerId), 8);
        QCOMPARE(tree2.structSpan(outerId), 8);

        // Empty struct = 0
        NodeTree tree3;
        Node empty;
        empty.kind = NodeKind::Struct;
        empty.name = "Empty";
        empty.parentId = 0;
        int ei = tree3.addNode(empty);
        QCOMPARE(tree3.structSpan(tree3.nodes[ei].id), 0);

        // Primitive array (no children) should return its declared size
        NodeTree tree4;
        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "data";
        arr.parentId = 0;
        arr.arrayLen = 16;
        arr.elementKind = NodeKind::UInt32;  // 16 * 4 = 64 bytes
        int ai = tree4.addNode(arr);
        QCOMPARE(tree4.structSpan(tree4.nodes[ai].id), 64);

        // Struct containing primitive array - span includes array size
        NodeTree tree5;
        Node container;
        container.kind = NodeKind::Struct;
        container.name = "Container";
        container.parentId = 0;
        int ci = tree5.addNode(container);
        uint64_t containerId = tree5.nodes[ci].id;

        Node arr2;
        arr2.kind = NodeKind::Array;
        arr2.name = "items";
        arr2.parentId = containerId;
        arr2.offset = 8;
        arr2.arrayLen = 10;
        arr2.elementKind = NodeKind::UInt64;  // 10 * 8 = 80 bytes
        tree5.addNode(arr2);

        // Container span = array offset (8) + array size (80) = 88
        QCOMPARE(tree5.structSpan(containerId), 88);
    }
    void testNormalizePreferAncestors() {
        using namespace rcx;
        NodeTree tree;
        // Root -> A -> leaf
        Node root; root.kind = NodeKind::Struct; root.name = "R"; root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node a; a.kind = NodeKind::Struct; a.name = "A"; a.parentId = rootId;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        Node leaf; leaf.kind = NodeKind::Hex8; leaf.name = "x"; leaf.parentId = aId;
        int li = tree.addNode(leaf);
        uint64_t leafId = tree.nodes[li].id;

        // Select root + leaf: leaf should be pruned (root is ancestor)
        QSet<uint64_t> sel = {rootId, leafId};
        QSet<uint64_t> norm = tree.normalizePreferAncestors(sel);
        QCOMPARE(norm.size(), 1);
        QVERIFY(norm.contains(rootId));

        // Select A + leaf: leaf pruned (A is ancestor)
        sel = {aId, leafId};
        norm = tree.normalizePreferAncestors(sel);
        QCOMPARE(norm.size(), 1);
        QVERIFY(norm.contains(aId));

        // Select root + A: A pruned (root is ancestor)
        sel = {rootId, aId};
        norm = tree.normalizePreferAncestors(sel);
        QCOMPARE(norm.size(), 1);
        QVERIFY(norm.contains(rootId));

        // Select only leaf: nothing pruned
        sel = {leafId};
        norm = tree.normalizePreferAncestors(sel);
        QCOMPARE(norm.size(), 1);
        QVERIFY(norm.contains(leafId));
    }

    void testNormalizePreferDescendants() {
        using namespace rcx;
        NodeTree tree;
        Node root; root.kind = NodeKind::Struct; root.name = "R"; root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node a; a.kind = NodeKind::UInt32; a.name = "a"; a.parentId = rootId;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        Node b; b.kind = NodeKind::UInt32; b.name = "b"; b.parentId = rootId; b.offset = 4;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;

        // Select root + a + b: root dropped (has selected descendants)
        QSet<uint64_t> sel = {rootId, aId, bId};
        QSet<uint64_t> norm = tree.normalizePreferDescendants(sel);
        QCOMPARE(norm.size(), 2);
        QVERIFY(norm.contains(aId));
        QVERIFY(norm.contains(bId));
        QVERIFY(!norm.contains(rootId));

        // Select root + a: root dropped, a kept
        sel = {rootId, aId};
        norm = tree.normalizePreferDescendants(sel);
        QCOMPARE(norm.size(), 1);
        QVERIFY(norm.contains(aId));

        // Select only root: nothing dropped (no descendants selected)
        sel = {rootId};
        norm = tree.normalizePreferDescendants(sel);
        QCOMPARE(norm.size(), 1);
        QVERIFY(norm.contains(rootId));
    }

    // ── ValueHistory tests ──

    void testValueHistory_empty() {
        rcx::ValueHistory h;
        QCOMPARE(h.heatLevel(), 0);
        QCOMPARE(h.uniqueCount(), 0);
        QCOMPARE(h.last(), QString());
    }

    void testValueHistory_singleValue() {
        rcx::ValueHistory h;
        h.record("42");
        QCOMPARE(h.heatLevel(), 0);  // only 1 unique → static
        QCOMPARE(h.uniqueCount(), 1);
        QCOMPARE(h.last(), QString("42"));
    }

    void testValueHistory_duplicateIgnored() {
        rcx::ValueHistory h;
        h.record("42");
        h.record("42");
        h.record("42");
        QCOMPARE(h.count, 1);
        QCOMPARE(h.heatLevel(), 0);
    }

    void testValueHistory_heatLevels() {
        rcx::ValueHistory h;
        h.record("a");
        QCOMPARE(h.heatLevel(), 0);  // 1 unique

        h.record("b");
        QCOMPARE(h.heatLevel(), 1);  // 2 unique → cold

        h.record("c");
        QCOMPARE(h.heatLevel(), 2);  // 3 unique → warm

        h.record("d");
        QCOMPARE(h.heatLevel(), 2);  // 4 unique → warm

        h.record("e");
        QCOMPARE(h.heatLevel(), 3);  // 5 unique → hot
    }

    void testValueHistory_ringWrap() {
        rcx::ValueHistory h;
        // Fill beyond capacity
        for (int i = 0; i < 15; i++)
            h.record(QString::number(i));

        QCOMPARE(h.count, 15);
        QCOMPARE(h.uniqueCount(), 10);  // capped at kCapacity
        QCOMPARE(h.heatLevel(), 3);     // hot
        QCOMPARE(h.last(), QString("14"));

        // Verify oldest values were pushed out, newest 10 remain
        QStringList collected;
        h.forEach([&](const QString& v) { collected.append(v); });
        QCOMPARE(collected.size(), 10);
        QCOMPARE(collected.first(), QString("5"));   // oldest surviving
        QCOMPARE(collected.last(), QString("14"));    // newest
    }

    void testValueHistory_forEach() {
        rcx::ValueHistory h;
        h.record("x");
        h.record("y");
        h.record("z");

        QStringList items;
        h.forEach([&](const QString& v) { items.append(v); });
        QCOMPARE(items.size(), 3);
        QCOMPARE(items[0], QString("x"));
        QCOMPARE(items[1], QString("y"));
        QCOMPARE(items[2], QString("z"));
    }

    void testValueHistory_oscillation() {
        // Values that oscillate (A → B → A → B) should still count each unique transition
        rcx::ValueHistory h;
        h.record("A");
        h.record("B");
        h.record("A");
        h.record("B");
        QCOMPARE(h.count, 4);       // 4 transitions
        QCOMPARE(h.heatLevel(), 2); // warm (count=4 → 3-4 range)
    }
};

QTEST_MAIN(TestCore)
#include "test_core.moc"

```

`tests/test_dbgconnect.cpp`:

```cpp
#include <cstdio>
#include <cstdint>
#include <windows.h>
#include <initguid.h>
#include <dbgeng.h>

int main()
{
    const char* connStr = "tcp:Port=5057,Server=localhost";
    printf("Attempting DebugConnect(\"%s\")...\n", connStr);

    IDebugClient* client = nullptr;
    HRESULT hr = DebugConnect(connStr, IID_IDebugClient, (void**)&client);
    printf("DebugConnect returned: 0x%08lX\n", hr);

    if (SUCCEEDED(hr) && client) {
        printf("Connected! Getting IDebugDataSpaces...\n");

        IDebugDataSpaces* ds = nullptr;
        hr = client->QueryInterface(IID_IDebugDataSpaces, (void**)&ds);
        printf("QueryInterface(IDebugDataSpaces) = 0x%08lX\n", hr);

        if (ds) {
            IDebugControl* ctrl = nullptr;
            client->QueryInterface(IID_IDebugControl, (void**)&ctrl);

            if (ctrl) {
                printf("Waiting for event...\n");
                hr = ctrl->WaitForEvent(0, 5000);
                printf("WaitForEvent = 0x%08lX\n", hr);
                ctrl->Release();
            }

            // Try to read 2 bytes
            IDebugSymbols* sym = nullptr;
            client->QueryInterface(IID_IDebugSymbols, (void**)&sym);
            if (sym) {
                ULONG numMods = 0, numUnloaded = 0;
                hr = sym->GetNumberModules(&numMods, &numUnloaded);
                printf("GetNumberModules = 0x%08lX, numMods=%lu\n", hr, numMods);

                if (numMods > 0) {
                    ULONG64 base = 0;
                    hr = sym->GetModuleByIndex(0, &base);
                    printf("Module[0] base = 0x%llX (hr=0x%08lX)\n", base, hr);

                    if (SUCCEEDED(hr) && base) {
                        uint8_t buf[4] = {};
                        ULONG got = 0;
                        hr = ds->ReadVirtual(base, buf, 4, &got);
                        printf("ReadVirtual(%llX, 4) = 0x%08lX, got=%lu, data=[%02X %02X %02X %02X]\n",
                               base, hr, got, buf[0], buf[1], buf[2], buf[3]);
                    }
                }
                sym->Release();
            }
            ds->Release();
        }
        client->Release();
    } else {
        printf("DebugConnect FAILED. hr=0x%08lX\n", hr);
    }

    return 0;
}

```

`tests/test_disasm.cpp`:

```cpp
#include <QtTest/QTest>
#include "disasm.h"
#include "core.h"
#include "providers/buffer_provider.h"

using namespace rcx;

// Helper: extract mnemonic portion from disassembly output (after "addr  ")
static QString mnemonic(const QString& line) {
    int sep = line.indexOf("  ");
    return sep >= 0 ? line.mid(sep + 2) : line;
}

class TestDisasm : public QObject {
    Q_OBJECT
private slots:
    // ──────────────────────────────────────────────────
    //  disassemble() unit tests – exact mnemonic match
    // ──────────────────────────────────────────────────

    void testDisasm64_pushMov() {
        QByteArray code("\x55\x48\x89\xe5", 4);
        QString result = disassemble(code, 0x401000, 64);
        QStringList lines = result.split('\n');
        QCOMPARE(lines.size(), 2);
        QVERIFY(lines[0].startsWith("0000000000401000"));
        QVERIFY(lines[1].startsWith("0000000000401001"));
        QCOMPARE(mnemonic(lines[0]), QStringLiteral("push rbp"));
        QCOMPARE(mnemonic(lines[1]), QStringLiteral("mov rbp, rsp"));
    }

    void testDisasm64_ret()     { QCOMPARE(mnemonic(disassemble(QByteArray("\xc3",1), 0x7FF000, 64)), QStringLiteral("ret")); }
    void testDisasm64_nop()     { QCOMPARE(mnemonic(disassemble(QByteArray("\x90",1), 0, 64)), QStringLiteral("nop")); }
    void testDisasm64_xorEax()  { QCOMPARE(mnemonic(disassemble(QByteArray("\x31\xc0",2), 0, 64)), QStringLiteral("xor eax, eax")); }
    void testDisasm64_subRsp()  { QCOMPARE(mnemonic(disassemble(QByteArray("\x48\x83\xec\x20",4), 0, 64)), QStringLiteral("sub rsp, 0x20")); }
    void testDisasm64_int3()    { QCOMPARE(mnemonic(disassemble(QByteArray("\xcc",1), 0, 64)), QStringLiteral("int3")); }
    void testDisasm64_pushRdi() { QCOMPARE(mnemonic(disassemble(QByteArray("\x57",1), 0, 64)), QStringLiteral("push rdi")); }
    void testDisasm64_popRsi()  { QCOMPARE(mnemonic(disassemble(QByteArray("\x5e",1), 0, 64)), QStringLiteral("pop rsi")); }
    void testDisasm64_testEax() { QCOMPARE(mnemonic(disassemble(QByteArray("\x85\xc0",2), 0, 64)), QStringLiteral("test eax, eax")); }

    void testDisasm64_leaRipRel() {
        QCOMPARE(mnemonic(disassemble(QByteArray("\x48\x8d\x05\x10\x00\x00\x00",7), 0x1000, 64)),
                 QStringLiteral("lea rax, [rip+0x10]"));
    }
    void testDisasm64_callRel() {
        // call target = 0x1000 + 5 + 0x100 = 0x1105
        QCOMPARE(mnemonic(disassemble(QByteArray("\xe8\x00\x01\x00\x00",5), 0x1000, 64)),
                 QStringLiteral("call 0x1105"));
    }
    void testDisasm64_jmpRel() {
        // jmp target = 0x1000 + 2 + 0x10 = 0x1012
        QCOMPARE(mnemonic(disassemble(QByteArray("\xeb\x10",2), 0x1000, 64)),
                 QStringLiteral("jmp 0x1012"));
    }
    void testDisasm64_movMemRead() {
        QCOMPARE(mnemonic(disassemble(QByteArray("\x48\x8b\x43\x10",4), 0, 64)),
                 QStringLiteral("mov rax, qword ptr [rbx+0x10]"));
    }
    void testDisasm64_movMemWrite() {
        QCOMPARE(mnemonic(disassemble(QByteArray("\x48\x89\x4c\x24\x08",5), 0, 64)),
                 QStringLiteral("mov qword ptr [rsp+0x8], rcx"));
    }

    void testDisasm64_functionPrologue() {
        QByteArray code("\x55\x48\x89\xe5\x48\x83\xec\x20\xc3", 9);
        QStringList lines = disassemble(code, 0x140001000ULL, 64).split('\n');
        QCOMPARE(lines.size(), 4);
        QVERIFY(lines[0].startsWith("0000000140001000"));
        QCOMPARE(mnemonic(lines[0]), QStringLiteral("push rbp"));
        QCOMPARE(mnemonic(lines[1]), QStringLiteral("mov rbp, rsp"));
        QCOMPARE(mnemonic(lines[2]), QStringLiteral("sub rsp, 0x20"));
        QCOMPARE(mnemonic(lines[3]), QStringLiteral("ret"));
    }

    void testDisasm64_multipleNops() {
        QStringList lines = disassemble(QByteArray(5,'\x90'), 0x1000, 64).split('\n');
        QCOMPARE(lines.size(), 5);
        for (int i = 0; i < 5; i++) {
            QCOMPARE(mnemonic(lines[i]), QStringLiteral("nop"));
            QVERIFY(lines[i].startsWith(QStringLiteral("%1").arg(0x1000+i, 16, 16, QLatin1Char('0'))));
        }
    }

    void testDisasm32_pushMov() {
        QByteArray code("\x55\x89\xe5", 3);
        QStringList lines = disassemble(code, 0x401000, 32).split('\n');
        QCOMPARE(lines.size(), 2);
        QVERIFY(lines[0].startsWith("00401000"));
        QCOMPARE(mnemonic(lines[0]), QStringLiteral("push ebp"));
        QCOMPARE(mnemonic(lines[1]), QStringLiteral("mov ebp, esp"));
    }

    void testDisasm_empty()          { QVERIFY(disassemble({}, 0, 64).isEmpty()); QVERIFY(disassemble({}, 0, 32).isEmpty()); }
    void testDisasm_invalidBitness() { QVERIFY(disassemble(QByteArray("\x90",1), 0, 16).isEmpty()); }
    void testDisasm_maxBytes()       { QCOMPARE(disassemble(QByteArray(200,'\x90'), 0, 64, 128).count('\n') + 1, 128); }
    void testDisasm64_addrWidth()    { QCOMPARE(disassemble(QByteArray("\x90",1), 0, 64).indexOf("  "), 16); }
    void testDisasm32_addrWidth()    { QCOMPARE(disassemble(QByteArray("\x90",1), 0, 32).indexOf("  "), 8); }

    // ──────────────────────────────────────────────────
    //  hexDump() unit tests
    // ──────────────────────────────────────────────────

    void testHexDump_basic() {
        QByteArray data; for (int i=0;i<32;i++) data.append((char)i);
        QString r = hexDump(data, 0x1000, 128);
        QCOMPARE(r.count('\n')+1, 2);
        QVERIFY(r.startsWith("00001000"));
    }
    void testHexDump_ascii() {
        QVERIFY(hexDump(QByteArray("Hello, World!xx",15), 0, 128).contains("Hello"));
    }
    void testHexDump_nonPrintable() {
        QByteArray d(16,'\0'); d[0]='A'; d[15]='Z';
        QVERIFY(hexDump(d, 0, 128).contains("A..............Z"));
    }
    void testHexDump_empty()     { QVERIFY(hexDump({}, 0).isEmpty()); }
    void testHexDump_maxBytes()  { QCOMPARE(hexDump(QByteArray(200,'\xAA'), 0, 64).count('\n')+1, 4); }
    void testHexDump_wideAddr()  { QVERIFY(hexDump(QByteArray(16,'\0'), 0x100000000ULL, 128).startsWith("0000000100000000")); }
    void testHexDump_hexValues() {
        QByteArray d; d.append('\xDE'); d.append('\xAD'); d.append('\xBE'); d.append('\xEF');
        while (d.size()<16) d.append('\0');
        QVERIFY(hexDump(d, 0, 128).contains("de ad be ef", Qt::CaseInsensitive));
    }
    void testHexDump_secondLineAddr() {
        QStringList lines = hexDump(QByteArray(32,'\x42'), 0x2000, 128).split('\n');
        QCOMPARE(lines.size(), 2);
        QVERIFY(lines[1].startsWith("00002010"));
    }

    // ──────────────────────────────────────────────────
    //  End-to-end: pointer-expanded VTable with FuncPtr64
    //  Verifies we read from the COMPOSED address, not node.offset
    // ──────────────────────────────────────────────────

    void testVTableDisasm_composedAddress() {
        // Memory layout (absolute addresses, baseAddress = 0):
        //
        //   [0x0000]  Root "Obj" struct
        //     +0x00: Pointer64 __vptr => points to 0x100 (vtable)
        //
        //   [0x0100]  VTable (expanded via pointer deref)
        //     +0x00: func ptr 0 => value 0x200 (func0 code)
        //     +0x08: func ptr 1 => value 0x300 (func1 code)
        //
        //   [0x0200]  func0 code: push rbp; ret
        //   [0x0300]  func1 code: xor eax, eax; ret
        //

        // Build a 4KB buffer
        QByteArray mem(4096, '\0');
        auto w64 = [&](int off, uint64_t val) {
            memcpy(mem.data() + off, &val, 8);
        };

        // Root object at offset 0: __vptr points to vtable at 0x100
        w64(0x00, 0x100);

        // VTable at offset 0x100: two function pointers
        w64(0x100, 0x200);  // slot 0 -> func0
        w64(0x108, 0x300);  // slot 1 -> func1

        // func0 at offset 0x200: push rbp; ret
        mem[0x200] = '\x55';
        mem[0x201] = '\xc3';

        // func1 at offset 0x300: xor eax, eax; ret
        mem[0x300] = '\x31';
        mem[0x301] = '\xc0';
        mem[0x302] = '\xc3';

        BufferProvider prov(mem);

        // Build node tree
        NodeTree tree;
        tree.baseAddress = 0;

        // Root struct "Obj"
        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Obj";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // VTable struct definition (template)
        Node vtDef;
        vtDef.kind = NodeKind::Struct;
        vtDef.name = "VTable";
        vtDef.parentId = 0;
        vtDef.offset = 0x1000; // parked far away so it doesn't overlap
        int vti = tree.addNode(vtDef);
        uint64_t vtId = tree.nodes[vti].id;

        // Two FuncPtr64 children inside VTable definition
        Node fp0;
        fp0.kind = NodeKind::FuncPtr64;
        fp0.name = "func0";
        fp0.parentId = vtId;
        fp0.offset = 0;
        tree.addNode(fp0);

        Node fp1;
        fp1.kind = NodeKind::FuncPtr64;
        fp1.name = "func1";
        fp1.parentId = vtId;
        fp1.offset = 8;
        tree.addNode(fp1);

        // Pointer64 "__vptr" in root, pointing to VTable via refId
        Node vptr;
        vptr.kind = NodeKind::Pointer64;
        vptr.name = "__vptr";
        vptr.parentId = rootId;
        vptr.offset = 0;
        vptr.refId = vtId;
        tree.addNode(vptr);

        // Compose the tree
        ComposeResult result = compose(tree, prov);

        // Find the FuncPtr64 lines in the composed output that are inside the
        // pointer-expanded VTable (near vtable address), not the standalone definition.
        struct FuncInfo { int line; uint64_t offsetAddr; NodeKind kind; QString name; };
        QVector<FuncInfo> funcPtrs;
        for (int i = 0; i < result.meta.size(); i++) {
            const LineMeta& lm = result.meta[i];
            if (lm.nodeKind == NodeKind::FuncPtr64 && lm.lineKind == LineKind::Field) {
                // Only include the pointer-expanded ones (near vtable at 0x100)
                if (lm.offsetAddr >= 0x100 && lm.offsetAddr < 0x200) {
                    int nodeIdx = lm.nodeIdx;
                    funcPtrs.append({i, lm.offsetAddr, lm.nodeKind,
                                     nodeIdx >= 0 ? tree.nodes[nodeIdx].name : QString()});
                }
            }
        }

        QCOMPARE(funcPtrs.size(), 2);

        // Verify composed addresses point to the vtable, NOT to the root struct
        // func0 should be at 0x100 (vtable + 0)
        QCOMPARE(funcPtrs[0].offsetAddr, (uint64_t)0x100);
        // func1 should be at 0x108 (vtable + 8)
        QCOMPARE(funcPtrs[1].offsetAddr, (uint64_t)0x108);

        // Now simulate what the hover code should do:
        // Read the function pointer VALUE from the correct provider address
        for (const auto& fp : funcPtrs) {
            // Provider reads at absolute address directly
            uint64_t provAddr = fp.offsetAddr;

            // Read the pointer value (the function address)
            uint64_t ptrVal = prov.readU64(provAddr);

            // Verify we got the right pointer values
            if (fp.name == "func0") {
                QCOMPARE(ptrVal, (uint64_t)0x200);
            } else {
                QCOMPARE(ptrVal, (uint64_t)0x300);
            }

            // Read code bytes at the pointer target (absolute address)
            uint64_t codeProvAddr = ptrVal;
            QByteArray codeBytes = prov.readBytes(codeProvAddr, 128);

            // Disassemble and verify
            QString asm_ = disassemble(codeBytes, ptrVal, 64, 128);
            QVERIFY2(!asm_.isEmpty(), qPrintable("Empty disasm for " + fp.name));

            QStringList lines = asm_.split('\n');
            if (fp.name == "func0") {
                // Should decode: push rbp; ret
                QVERIFY2(lines.size() >= 2, qPrintable(QString("Expected >= 2 lines for func0, got %1: %2").arg(lines.size()).arg(asm_)));
                QCOMPARE(mnemonic(lines[0]), QStringLiteral("push rbp"));
                QCOMPARE(mnemonic(lines[1]), QStringLiteral("ret"));
                // Verify address in output matches the real function address
                QVERIFY2(lines[0].contains("200"),
                         qPrintable("func0 addr wrong: " + lines[0]));
            } else {
                // Should decode: xor eax, eax; ret
                QVERIFY2(lines.size() >= 2, qPrintable(QString("Expected >= 2 lines for func1, got %1: %2").arg(lines.size()).arg(asm_)));
                QCOMPARE(mnemonic(lines[0]), QStringLiteral("xor eax, eax"));
                QCOMPARE(mnemonic(lines[1]), QStringLiteral("ret"));
                QVERIFY2(lines[0].contains("300"),
                         qPrintable("func1 addr wrong: " + lines[0]));
            }
        }

        // CRITICAL: Verify that reading from node.offset (the WRONG way) gives
        // different/wrong results. node.offset for func0=0, func1=8, which are
        // inside the ROOT struct, not the vtable.
        uint64_t wrongVal0 = prov.readU64(0);  // node.offset=0: reads __vptr value
        uint64_t wrongVal1 = prov.readU64(8);  // node.offset=8: reads garbage after __vptr
        // wrongVal0 = 0x100 (the vptr itself, NOT a function address)
        QCOMPARE(wrongVal0, (uint64_t)0x100);
        // This is the vtable address, not a function — disassembling it would be wrong
        QVERIFY2(wrongVal0 != (uint64_t)0x200,
                 "node.offset reads the vptr, not the function pointer");
        QVERIFY2(wrongVal1 != (uint64_t)0x300,
                 "node.offset=8 reads past vptr, not the second function pointer");
    }

    void testVTableDisasm_wrongAddressGivesWrongCode() {
        // Demonstrate that using node.offset instead of composed address
        // gives completely wrong disassembly results
        QByteArray mem(1024, '\0');
        auto w64 = [&](int off, uint64_t val) { memcpy(mem.data()+off, &val, 8); };

        // Root at 0: vptr -> 0x80
        w64(0x00, (uint64_t)0x80);
        // VTable at 0x80: one func ptr -> 0x100
        w64(0x80, (uint64_t)0x100);
        // Code at 0x100: sub rsp, 0x28; nop; ret
        mem[0x100] = '\x48'; mem[0x101] = '\x83'; mem[0x102] = '\xec';
        mem[0x103] = '\x28'; mem[0x104] = '\x90'; mem[0x105] = '\xc3';

        BufferProvider prov(mem);

        // WRONG: read from node.offset=0 (root's vptr value, not the func ptr)
        uint64_t wrongPtrVal = prov.readU64(0);
        QCOMPARE(wrongPtrVal, (uint64_t)0x80);  // This is the vtable addr, not a function!

        // RIGHT: read from composed address (vtable + 0)
        uint64_t rightPtrVal = prov.readU64(0x80);
        QCOMPARE(rightPtrVal, (uint64_t)0x100);  // This IS the function address

        // Disassemble the RIGHT target
        QByteArray rightCode = prov.readBytes(0x100, 128);
        QString rightAsm = disassemble(rightCode, 0x100, 64, 128);
        QStringList rightLines = rightAsm.split('\n');
        QVERIFY(rightLines.size() >= 3);
        QCOMPARE(mnemonic(rightLines[0]), QStringLiteral("sub rsp, 0x28"));
        QCOMPARE(mnemonic(rightLines[1]), QStringLiteral("nop"));
        QCOMPARE(mnemonic(rightLines[2]), QStringLiteral("ret"));

        // Disassemble the WRONG target (vtable data, not code!)
        QByteArray wrongCode = prov.readBytes(0x80, 128);
        QString wrongAsm = disassemble(wrongCode, 0x80, 64, 128);
        // The wrong bytes are the vtable entries (pointer values),
        // which decode as garbage instructions, not sub/nop/ret
        QVERIFY2(!wrongAsm.contains("sub rsp"),
                 qPrintable("Wrong address should NOT produce sub rsp: " + wrongAsm));
    }

    void testHoverFlow_fullSimulation() {
        // Full simulation of the hover flow as implemented in editor.cpp:
        //
        // 1. Compose the tree to get LineMeta with correct offsetAddr
        // 2. For each FuncPtr64 line, read pointer value from provider
        //    using lm.offsetAddr (absolute address)
        // 3. Read code bytes from the REAL provider using ptrVal directly
        //    (the real provider can read any process address; snapshot cannot)
        // 4. Disassemble the code bytes
        //
        // The key distinction: step 2 reads from composed tree addresses (in
        // the snapshot), step 3 reads from arbitrary code addresses (needs
        // the real provider, not snapshot).

        QByteArray mem(8192, '\0');
        auto w64 = [&](int off, uint64_t val) {
            memcpy(mem.data() + off, &val, 8);
        };

        // Layout:
        // [0x000] Root struct: __vptr -> vtable at 0x100
        // [0x100] VTable: func0 -> 0x1000, func1 -> 0x1800
        // [0x1000] func0 code: push rbp; mov rbp, rsp; sub rsp, 0x20; ret
        // [0x1800] func1 code: xor eax, eax; ret
        w64(0x000, (uint64_t)0x100);                   // __vptr
        w64(0x100, (uint64_t)0x1000);                   // vtable[0]
        w64(0x108, (uint64_t)0x1800);                   // vtable[1]
        // func0 code
        memcpy(mem.data() + 0x1000, "\x55\x48\x89\xe5\x48\x83\xec\x20\xc3", 9);
        // func1 code
        memcpy(mem.data() + 0x1800, "\x31\xc0\xc3", 3);

        // This provider represents the real process memory.
        BufferProvider realProv(mem);

        // Build a snapshot that only contains tree-data pages (like the
        // async refresh does). The snapshot does NOT contain function code pages.
        // This simulates the real scenario where SnapshotProvider only has
        // pages for the root struct and pointer-expanded structs.
        QByteArray snapData(0x200, '\0');   // only pages for root + vtable
        memcpy(snapData.data(), mem.constData(), 0x200);
        BufferProvider snapProv(snapData);

        // Build node tree
        NodeTree tree;
        tree.baseAddress = 0;

        Node root; root.kind = NodeKind::Struct; root.name = "Obj";
        root.parentId = 0; root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node vtDef; vtDef.kind = NodeKind::Struct; vtDef.name = "VTable";
        vtDef.parentId = 0; vtDef.offset = 0x2000;
        int vti = tree.addNode(vtDef);
        uint64_t vtId = tree.nodes[vti].id;

        Node fp0; fp0.kind = NodeKind::FuncPtr64; fp0.name = "func0";
        fp0.parentId = vtId; fp0.offset = 0;
        tree.addNode(fp0);
        Node fp1; fp1.kind = NodeKind::FuncPtr64; fp1.name = "func1";
        fp1.parentId = vtId; fp1.offset = 8;
        tree.addNode(fp1);

        Node vptr; vptr.kind = NodeKind::Pointer64; vptr.name = "__vptr";
        vptr.parentId = rootId; vptr.offset = 0; vptr.refId = vtId;
        tree.addNode(vptr);

        // Compose with the snapshot (like production: compose uses snapshot)
        ComposeResult result = compose(tree, snapProv);

        // Find expanded FuncPtr64 lines
        for (int i = 0; i < result.meta.size(); i++) {
            const LineMeta& lm = result.meta[i];
            if (lm.nodeKind != NodeKind::FuncPtr64 || lm.lineKind != LineKind::Field)
                continue;
            if (lm.offsetAddr < 0x100 || lm.offsetAddr >= 0x200)
                continue;  // skip standalone VTable definition entries

            // --- Hover step 1: read pointer value from snapshot ---
            uint64_t provAddr = lm.offsetAddr;
            // The snapshot has this data (vtable pages are in it)
            QVERIFY2(snapProv.isReadable(provAddr, 8),
                     qPrintable(QString("Snapshot should have vtable page at %1")
                                .arg(provAddr, 0, 16)));
            uint64_t ptrVal = snapProv.readU64(provAddr);
            QVERIFY2(ptrVal != 0, "Function pointer should not be zero");

            // --- Hover step 2: read code from REAL provider ---
            // The snapshot does NOT have the code pages:
            uint64_t codeAddr = ptrVal;
            QVERIFY2(!snapProv.isReadable(codeAddr, 1),
                     "Snapshot should NOT have function code pages");
            // But the real provider does:
            QByteArray codeBytes(128, Qt::Uninitialized);
            bool readOk = realProv.read(codeAddr, codeBytes.data(), 128);
            QVERIFY2(readOk, "Real provider should be able to read code bytes");

            // --- Hover step 3: disassemble ---
            QString asm_ = disassemble(codeBytes, ptrVal, 64, 128);
            QVERIFY2(!asm_.isEmpty(), qPrintable("Empty disasm for line " + QString::number(i)));

            QStringList lines = asm_.split('\n');
            const Node& node = tree.nodes[lm.nodeIdx];
            if (node.name == "func0") {
                QVERIFY(lines.size() >= 4);
                QCOMPARE(mnemonic(lines[0]), QStringLiteral("push rbp"));
                QCOMPARE(mnemonic(lines[1]), QStringLiteral("mov rbp, rsp"));
                QCOMPARE(mnemonic(lines[2]), QStringLiteral("sub rsp, 0x20"));
                QCOMPARE(mnemonic(lines[3]), QStringLiteral("ret"));
            } else if (node.name == "func1") {
                QVERIFY(lines.size() >= 2);
                QCOMPARE(mnemonic(lines[0]), QStringLiteral("xor eax, eax"));
                QCOMPARE(mnemonic(lines[1]), QStringLiteral("ret"));
            }
        }
    }
};

QTEST_MAIN(TestDisasm)
#include "test_disasm.moc"

```

`tests/test_editor.cpp`:

```cpp
#include <QtTest/QTest>
#include <QtTest/QSignalSpy>
#include <QApplication>
#include <QKeyEvent>
#include <QFocusEvent>
#include <QMouseEvent>
#include <QFile>
#include <QMenu>
#include <QProxyStyle>
#include <QStyleOption>
#include <QImage>
#include <QPainter>
#include <QCursor>
#include <QScreen>
#include <QMainWindow>
#include <QStatusBar>
#include <QPushButton>
#include <QButtonGroup>
#include <QLabel>
#include <QLayout>
#include <QHBoxLayout>
#include <QScrollBar>
#include <Qsci/qsciscintilla.h>
#include <Qsci/qsciscintillabase.h>
#include "editor.h"
#include "core.h"

using namespace rcx;

// ── Cursor test helpers ──

static Qt::CursorShape viewportCursor(RcxEditor* editor) {
    return editor->scintilla()->viewport()->cursor().shape();
}

static QPoint colToViewport(QsciScintilla* sci, int line, int col) {
    long pos = sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                                  (unsigned long)line, (long)col);
    int x = (int)sci->SendScintilla(QsciScintillaBase::SCI_POINTXFROMPOSITION, 0, pos);
    int y = (int)sci->SendScintilla(QsciScintillaBase::SCI_POINTYFROMPOSITION, 0, pos);
    return QPoint(x, y);
}

static void sendMouseMove(QWidget* viewport, const QPoint& pos) {
    QMouseEvent move(QEvent::MouseMove, QPointF(pos), QPointF(pos),
                     Qt::NoButton, Qt::NoButton, Qt::NoModifier);
    QApplication::sendEvent(viewport, &move);
}

static void sendLeftClick(QWidget* viewport, const QPoint& pos) {
    QMouseEvent press(QEvent::MouseButtonPress, QPointF(pos), QPointF(pos),
                      Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
    QApplication::sendEvent(viewport, &press);
    QMouseEvent release(QEvent::MouseButtonRelease, QPointF(pos), QPointF(pos),
                        Qt::LeftButton, Qt::NoButton, Qt::NoModifier);
    QApplication::sendEvent(viewport, &release);
}

// 0x7D0 bytes of PEB-like data with recognizable values at key offsets
static BufferProvider makeTestProvider() {
    QByteArray data(0x7D0, '\0');

    auto w8  = [&](int off, uint8_t  v) { data[off] = (char)v; };
    auto w16 = [&](int off, uint16_t v) { memcpy(data.data()+off, &v, 2); };
    auto w32 = [&](int off, uint32_t v) { memcpy(data.data()+off, &v, 4); };
    auto w64 = [&](int off, uint64_t v) { memcpy(data.data()+off, &v, 8); };

    w8 (0x002, 1);                              // BeingDebugged
    w8 (0x003, 0x04);                           // BitField
    w64(0x008, 0xFFFFFFFFFFFFFFFFULL);          // Mutant (-1)
    w64(0x010, 0x00007FF6DE120000ULL);          // ImageBaseAddress
    w64(0x018, 0x00007FFE3B8B53C0ULL);          // Ldr
    w64(0x020, 0x000001A4C3E20F90ULL);          // ProcessParameters
    w64(0x028, 0x0000000000000000ULL);          // SubSystemData
    w64(0x030, 0x000001A4C3D40000ULL);          // ProcessHeap
    w64(0x038, 0x00007FFE3B8D4260ULL);          // FastPebLock
    w64(0x040, 0x0000000000000000ULL);          // AtlThunkSListPtr
    w64(0x048, 0x0000000000000000ULL);          // IFEOKey
    w32(0x050, 0x01);                           // CrossProcessFlags
    w64(0x058, 0x00007FFE3B720000ULL);          // KernelCallbackTable
    w32(0x060, 0);                              // SystemReserved
    w32(0x064, 0);                              // AtlThunkSListPtr32
    w64(0x068, 0x00007FFE3E570000ULL);          // ApiSetMap
    w32(0x070, 0);                              // TlsExpansionCounter
    w64(0x078, 0x00007FFE3B8D3F50ULL);          // TlsBitmap
    w32(0x080, 0x00000003);                     // TlsBitmapBits[0]
    w32(0x084, 0x00000000);                     // TlsBitmapBits[1]
    w64(0x088, 0x00007FFE38800000ULL);          // ReadOnlySharedMemoryBase
    w64(0x090, 0x00007FFE38820000ULL);          // SharedData
    w64(0x098, 0x00007FFE388A0000ULL);          // ReadOnlyStaticServerData
    w64(0x0A0, 0x00007FFE3B8D1000ULL);          // AnsiCodePageData
    w64(0x0A8, 0x00007FFE3B8D2040ULL);          // OemCodePageData
    w64(0x0B0, 0x00007FFE3B8CE020ULL);          // UnicodeCaseTableData
    w32(0x0B8, 8);                              // NumberOfProcessors
    w32(0x0BC, 0x70);                           // NtGlobalFlag
    w64(0x0C0, 0xFFFFFFFF7C91E000ULL);          // CriticalSectionTimeout
    w64(0x0C8, 0x0000000000100000ULL);          // HeapSegmentReserve
    w64(0x0D0, 0x0000000000002000ULL);          // HeapSegmentCommit
    w64(0x0D8, 0x0000000000040000ULL);          // HeapDeCommitTotalFreeThreshold
    w64(0x0E0, 0x0000000000001000ULL);          // HeapDeCommitFreeBlockThreshold
    w32(0x0E8, 4);                              // NumberOfHeaps
    w32(0x0EC, 16);                             // MaximumNumberOfHeaps
    w64(0x0F0, 0x000001A4C3D40688ULL);          // ProcessHeaps
    w64(0x0F8, 0x00007FFE388B0000ULL);          // GdiSharedHandleTable
    w64(0x100, 0x0000000000000000ULL);          // ProcessStarterHelper
    w32(0x108, 0);                              // GdiDCAttributeList
    w64(0x110, 0x00007FFE3B8D42E8ULL);          // LoaderLock
    w32(0x118, 10);                             // OSMajorVersion
    w32(0x11C, 0);                              // OSMinorVersion
    w16(0x120, 19045);                          // OSBuildNumber
    w16(0x122, 0);                              // OSCSDVersion
    w32(0x124, 2);                              // OSPlatformId
    w32(0x128, 3);                              // ImageSubsystem (CUI)
    w32(0x12C, 10);                             // ImageSubsystemMajorVersion
    w32(0x130, 0);                              // ImageSubsystemMinorVersion
    w64(0x138, 0x00000000000000FFULL);          // ActiveProcessAffinityMask
    w64(0x230, 0x0000000000000000ULL);          // PostProcessInitRoutine
    w64(0x238, 0x00007FFE3B8D3F70ULL);          // TlsExpansionBitmap
    w32(0x2C0, 1);                              // SessionId
    w64(0x2C8, 0x0000000000000000ULL);          // AppCompatFlags
    w64(0x2D0, 0x0000000000000000ULL);          // AppCompatFlagsUser
    w64(0x2D8, 0x0000000000000000ULL);          // pShimData
    w64(0x2E0, 0x0000000000000000ULL);          // AppCompatInfo
    w16(0x2E8, 0);                              // CSDVersion.Length
    w16(0x2EA, 0);                              // CSDVersion.MaximumLength
    w64(0x2F0, 0x0000000000000000ULL);          // CSDVersion.Buffer
    w64(0x2F8, 0x000001A4C3E21000ULL);          // ActivationContextData
    w64(0x300, 0x000001A4C3E22000ULL);          // ProcessAssemblyStorageMap
    w64(0x308, 0x00007FFE38840000ULL);          // SystemDefaultActivationContextData
    w64(0x310, 0x00007FFE38850000ULL);          // SystemAssemblyStorageMap
    w64(0x318, 0x0000000000002000ULL);          // MinimumStackCommit
    w64(0x330, 0x0000000000000000ULL);          // PatchLoaderData
    w64(0x338, 0x0000000000000000ULL);          // ChpeV2ProcessInfo
    w32(0x340, 0);                              // AppModelFeatureState
    w16(0x34C, 1252);                           // ActiveCodePage
    w16(0x34E, 437);                            // OemCodePage
    w16(0x350, 0);                              // UseCaseMapping
    w16(0x352, 0);                              // UnusedNlsField
    w64(0x358, 0x000001A4C3E30000ULL);          // WerRegistrationData
    w64(0x360, 0x0000000000000000ULL);          // WerShipAssertPtr
    w64(0x368, 0x0000000000000000ULL);          // EcCodeBitMap
    w64(0x370, 0x0000000000000000ULL);          // pImageHeaderHash
    w32(0x378, 0);                              // TracingFlags
    w64(0x380, 0x00007FFE38890000ULL);          // CsrServerReadOnlySharedMemoryBase
    w64(0x388, 0x0000000000000000ULL);          // TppWorkerpListLock
    w64(0x390, 0x000000D87B5E5390ULL);          // TppWorkerpList.Flink (self)
    w64(0x398, 0x000000D87B5E5390ULL);          // TppWorkerpList.Blink (self)
    w64(0x7A0, 0x0000000000000000ULL);          // TelemetryCoverageHeader
    w32(0x7A8, 0);                              // CloudFileFlags
    w32(0x7AC, 0);                              // CloudFileDiagFlags
    w8 (0x7B0, 0);                              // PlaceholderCompatibilityMode
    w64(0x7B8, 0x00007FFE38860000ULL);          // LeapSecondData
    w32(0x7C0, 0);                              // LeapSecondFlags
    w32(0x7C4, 0);                              // NtGlobalFlag2
    w64(0x7C8, 0x0000000000000000ULL);          // ExtendedFeatureDisableMask

    return BufferProvider(data, "peb_snapshot.bin");
}

// Build the full _PEB64 tree (0x7D0 bytes), unions mapped to first member
static NodeTree makeTestTree() {
    NodeTree tree;
    tree.baseAddress = 0;

    // Root struct
    Node root;
    root.kind = NodeKind::Struct;
    root.structTypeName = "_PEB64";
    root.name = "Peb";
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    // Helpers
    auto field = [&](int off, NodeKind k, const char* name) {
        Node n; n.kind = k; n.name = name;
        n.parentId = rootId; n.offset = off;
        tree.addNode(n);
    };
    auto pad = [&](int off, int /*len*/, const char* name) {
        // 4-byte padding → Hex32 (all usages in this test pass len=4)
        Node n; n.kind = NodeKind::Hex32; n.name = name;
        n.parentId = rootId; n.offset = off;
        tree.addNode(n);
    };
    auto arr = [&](int off, NodeKind ek, int len, const char* name) {
        Node n; n.kind = NodeKind::Array; n.name = name;
        n.parentId = rootId; n.offset = off;
        n.arrayLen = len; n.elementKind = ek;
        tree.addNode(n);
    };
    auto sub = [&](int off, const char* ty, const char* name) -> uint64_t {
        Node n; n.kind = NodeKind::Struct; n.structTypeName = ty; n.name = name;
        n.parentId = rootId; n.offset = off;
        int idx = tree.addNode(n); return tree.nodes[idx].id;
    };

    // ── 0x000 – 0x007 ──
    field(0x000, NodeKind::UInt8,     "InheritedAddressSpace");
    field(0x001, NodeKind::UInt8,     "ReadImageFileExecOptions");
    field(0x002, NodeKind::UInt8,     "BeingDebugged");
    field(0x003, NodeKind::UInt8,     "BitField");              // union → first member
    pad  (0x004, 4,                   "Padding0");

    // ── 0x008 – 0x04F ──
    field(0x008, NodeKind::Pointer64, "Mutant");
    field(0x010, NodeKind::Pointer64, "ImageBaseAddress");
    field(0x018, NodeKind::Pointer64, "Ldr");
    field(0x020, NodeKind::Pointer64, "ProcessParameters");
    field(0x028, NodeKind::Pointer64, "SubSystemData");
    field(0x030, NodeKind::Pointer64, "ProcessHeap");
    field(0x038, NodeKind::Pointer64, "FastPebLock");
    field(0x040, NodeKind::Pointer64, "AtlThunkSListPtr");
    field(0x048, NodeKind::Pointer64, "IFEOKey");

    // ── 0x050 – 0x07F ──
    field(0x050, NodeKind::UInt32,    "CrossProcessFlags");     // union → first member
    pad  (0x054, 4,                   "Padding1");
    field(0x058, NodeKind::Pointer64, "KernelCallbackTable");   // union → first member
    field(0x060, NodeKind::UInt32,    "SystemReserved");
    field(0x064, NodeKind::UInt32,    "AtlThunkSListPtr32");
    field(0x068, NodeKind::Pointer64, "ApiSetMap");
    field(0x070, NodeKind::UInt32,    "TlsExpansionCounter");
    pad  (0x074, 4,                   "Padding2");
    field(0x078, NodeKind::Pointer64, "TlsBitmap");
    arr  (0x080, NodeKind::UInt32, 2, "TlsBitmapBits");

    // ── 0x088 – 0x0BF ──
    field(0x088, NodeKind::Pointer64, "ReadOnlySharedMemoryBase");
    field(0x090, NodeKind::Pointer64, "SharedData");
    field(0x098, NodeKind::Pointer64, "ReadOnlyStaticServerData");
    field(0x0A0, NodeKind::Pointer64, "AnsiCodePageData");
    field(0x0A8, NodeKind::Pointer64, "OemCodePageData");
    field(0x0B0, NodeKind::Pointer64, "UnicodeCaseTableData");
    field(0x0B8, NodeKind::UInt32,    "NumberOfProcessors");
    field(0x0BC, NodeKind::Hex32,     "NtGlobalFlag");

    // ── 0x0C0 – 0x0EF ──
    field(0x0C0, NodeKind::UInt64,    "CriticalSectionTimeout"); // _LARGE_INTEGER union
    field(0x0C8, NodeKind::UInt64,    "HeapSegmentReserve");
    field(0x0D0, NodeKind::UInt64,    "HeapSegmentCommit");
    field(0x0D8, NodeKind::UInt64,    "HeapDeCommitTotalFreeThreshold");
    field(0x0E0, NodeKind::UInt64,    "HeapDeCommitFreeBlockThreshold");
    field(0x0E8, NodeKind::UInt32,    "NumberOfHeaps");
    field(0x0EC, NodeKind::UInt32,    "MaximumNumberOfHeaps");

    // ── 0x0F0 – 0x13F ──
    field(0x0F0, NodeKind::Pointer64, "ProcessHeaps");
    field(0x0F8, NodeKind::Pointer64, "GdiSharedHandleTable");
    field(0x100, NodeKind::Pointer64, "ProcessStarterHelper");
    field(0x108, NodeKind::UInt32,    "GdiDCAttributeList");
    pad  (0x10C, 4,                   "Padding3");
    field(0x110, NodeKind::Pointer64, "LoaderLock");
    field(0x118, NodeKind::UInt32,    "OSMajorVersion");
    field(0x11C, NodeKind::UInt32,    "OSMinorVersion");
    field(0x120, NodeKind::UInt16,    "OSBuildNumber");
    field(0x122, NodeKind::UInt16,    "OSCSDVersion");
    field(0x124, NodeKind::UInt32,    "OSPlatformId");
    field(0x128, NodeKind::UInt32,    "ImageSubsystem");
    field(0x12C, NodeKind::UInt32,    "ImageSubsystemMajorVersion");
    field(0x130, NodeKind::UInt32,    "ImageSubsystemMinorVersion");
    pad  (0x134, 4,                   "Padding4");
    field(0x138, NodeKind::UInt64,    "ActiveProcessAffinityMask");

    // ── 0x140 – 0x22F ──
    arr  (0x140, NodeKind::UInt32, 60, "GdiHandleBuffer");

    // ── 0x230 – 0x2BF ──
    field(0x230, NodeKind::Pointer64, "PostProcessInitRoutine");
    field(0x238, NodeKind::Pointer64, "TlsExpansionBitmap");
    arr  (0x240, NodeKind::UInt32, 32, "TlsExpansionBitmapBits");

    // ── 0x2C0 – 0x2E7 ──
    field(0x2C0, NodeKind::UInt32,    "SessionId");
    pad  (0x2C4, 4,                   "Padding5");
    field(0x2C8, NodeKind::UInt64,    "AppCompatFlags");         // _ULARGE_INTEGER union
    field(0x2D0, NodeKind::UInt64,    "AppCompatFlagsUser");     // _ULARGE_INTEGER union
    field(0x2D8, NodeKind::Pointer64, "pShimData");
    field(0x2E0, NodeKind::Pointer64, "AppCompatInfo");

    // ── 0x2E8 – 0x2F7: _STRING64 CSDVersion (nested struct) ──
    {
        uint64_t sid = sub(0x2E8, "_STRING64", "CSDVersion");
        Node n;
        n.parentId = sid;

        n.kind = NodeKind::UInt16;  n.name = "Length";         n.offset = 0; tree.addNode(n);
        n.kind = NodeKind::UInt16;  n.name = "MaximumLength";  n.offset = 2; tree.addNode(n);
        n.kind = NodeKind::Hex32; n.name = "Pad";
        n.offset = 4; n.arrayLen = 1; tree.addNode(n);
        n.kind = NodeKind::Pointer64; n.name = "Buffer"; n.offset = 8; n.arrayLen = 1;
        tree.addNode(n);
    }

    // ── 0x2F8 – 0x31F ──
    field(0x2F8, NodeKind::Pointer64, "ActivationContextData");
    field(0x300, NodeKind::Pointer64, "ProcessAssemblyStorageMap");
    field(0x308, NodeKind::Pointer64, "SystemDefaultActivationContextData");
    field(0x310, NodeKind::Pointer64, "SystemAssemblyStorageMap");
    field(0x318, NodeKind::UInt64,    "MinimumStackCommit");

    // ── 0x320 – 0x34B ──
    arr  (0x320, NodeKind::UInt64, 2, "SparePointers");
    field(0x330, NodeKind::Pointer64, "PatchLoaderData");
    field(0x338, NodeKind::Pointer64, "ChpeV2ProcessInfo");
    field(0x340, NodeKind::UInt32,    "AppModelFeatureState");
    arr  (0x344, NodeKind::UInt32, 2, "SpareUlongs");
    field(0x34C, NodeKind::UInt16,    "ActiveCodePage");
    field(0x34E, NodeKind::UInt16,    "OemCodePage");
    field(0x350, NodeKind::UInt16,    "UseCaseMapping");
    field(0x352, NodeKind::UInt16,    "UnusedNlsField");

    // ── 0x354 – 0x37F (implicit padding + fields) ──
    pad  (0x354, 4,                   "Pad354");
    field(0x358, NodeKind::Pointer64, "WerRegistrationData");
    field(0x360, NodeKind::Pointer64, "WerShipAssertPtr");
    field(0x368, NodeKind::Pointer64, "EcCodeBitMap");
    field(0x370, NodeKind::Pointer64, "pImageHeaderHash");
    field(0x378, NodeKind::UInt32,    "TracingFlags");           // union → first member
    pad  (0x37C, 4,                   "Padding6");

    // ── 0x380 – 0x39F ──
    field(0x380, NodeKind::Pointer64, "CsrServerReadOnlySharedMemoryBase");
    field(0x388, NodeKind::UInt64,    "TppWorkerpListLock");

    // ── 0x390 – 0x39F: LIST_ENTRY64 TppWorkerpList (nested struct) ──
    {
        uint64_t sid = sub(0x390, "LIST_ENTRY64", "TppWorkerpList");
        Node n;
        n.parentId = sid;
        n.kind = NodeKind::Pointer64; n.name = "Flink"; n.offset = 0; tree.addNode(n);
        n.kind = NodeKind::Pointer64; n.name = "Blink"; n.offset = 8; tree.addNode(n);
    }

    // ── 0x3A0 – 0x79F ──
    arr  (0x3A0, NodeKind::UInt64, 128, "WaitOnAddressHashTable");

    // ── 0x7A0 – 0x7CF ──
    field(0x7A0, NodeKind::Pointer64, "TelemetryCoverageHeader");
    field(0x7A8, NodeKind::UInt32,    "CloudFileFlags");
    field(0x7AC, NodeKind::UInt32,    "CloudFileDiagFlags");
    field(0x7B0, NodeKind::Int8,      "PlaceholderCompatibilityMode");
    arr  (0x7B1, NodeKind::Int8, 7,   "PlaceholderCompatibilityModeReserved");
    field(0x7B8, NodeKind::Pointer64, "LeapSecondData");
    field(0x7C0, NodeKind::UInt32,    "LeapSecondFlags");        // union → first member
    field(0x7C4, NodeKind::UInt32,    "NtGlobalFlag2");
    field(0x7C8, NodeKind::UInt64,    "ExtendedFeatureDisableMask");

    return tree;
}

// ── Pointer expansion demo data ──
// Small tree with a working pointer that points within the buffer.
// Root struct "Demo" has a UInt32 "id" and Pointer64 "pChild" → ChildData.
// ChildData has UInt32 "x", UInt32 "y", Float "z".
struct PtrDemo {
    NodeTree tree;
    BufferProvider prov{QByteArray()};
    uint64_t rootId = 0;
    uint64_t childStructId = 0;
};

static PtrDemo makePtrDemo(bool collapsed = false, bool nullPtr = false) {
    PtrDemo d;
    d.tree.baseAddress = 0;

    // Root struct
    Node root;
    root.kind = NodeKind::Struct;
    root.structTypeName = "Demo";
    root.name = "demo";
    root.parentId = 0;
    root.offset = 0;
    int ri = d.tree.addNode(root);
    d.rootId = d.tree.nodes[ri].id;

    // id field at offset 0
    {
        Node n;
        n.kind = NodeKind::UInt32;
        n.name = "id";
        n.parentId = d.rootId;
        n.offset = 0;
        d.tree.addNode(n);
    }

    // ChildData struct definition (separate root)
    Node child;
    child.kind = NodeKind::Struct;
    child.structTypeName = "ChildData";
    child.name = "ChildData";
    child.parentId = 0;
    child.offset = 200; // standalone rendering offset
    int ci = d.tree.addNode(child);
    d.childStructId = d.tree.nodes[ci].id;

    {
        Node n;
        n.kind = NodeKind::UInt32; n.name = "x";
        n.parentId = d.childStructId; n.offset = 0;
        d.tree.addNode(n);
        n.kind = NodeKind::UInt32; n.name = "y";
        n.offset = 4;
        d.tree.addNode(n);
        n.kind = NodeKind::Float; n.name = "z";
        n.offset = 8;
        d.tree.addNode(n);
    }

    // Pointer at offset 8 → ChildData
    {
        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "pChild";
        ptr.parentId = d.rootId;
        ptr.offset = 8;
        ptr.refId = d.childStructId;
        ptr.collapsed = collapsed;
        d.tree.addNode(ptr);
    }

    // Buffer: 128 bytes
    QByteArray data(128, '\0');
    uint32_t idVal = 42;
    memcpy(data.data() + 0, &idVal, 4);

    if (!nullPtr) {
        uint64_t ptrVal = 64; // points to offset 64 in buffer
        memcpy(data.data() + 8, &ptrVal, 8);
    }

    // Data at the pointer target (offset 64)
    uint32_t xVal = 100;  memcpy(data.data() + 64, &xVal, 4);
    uint32_t yVal = 200;  memcpy(data.data() + 68, &yVal, 4);
    float    zVal = 3.14f; memcpy(data.data() + 72, &zVal, 4);

    d.prov = BufferProvider(data, "ptr_demo");
    return d;
}

class TestEditor : public QObject {
    Q_OBJECT
private:
    RcxEditor* m_editor = nullptr;
    ComposeResult m_result;

private slots:
    void initTestCase() {
        m_editor = new RcxEditor();
        m_editor->resize(800, 600);
        m_editor->show();
        QVERIFY(QTest::qWaitForWindowExposed(m_editor));

        NodeTree tree = makeTestTree();
        BufferProvider prov = makeTestProvider();
        m_result = compose(tree, prov);
        m_editor->applyDocument(m_result);
    }

    void cleanupTestCase() {
        delete m_editor;
    }

    // ── Test: CommandRow at line 0 rejects non-ADDR edits ──
    void testCommandRowLineRejectsEdits() {
        m_editor->applyDocument(m_result);

        // Line 0 should be the CommandRow
        const LineMeta* lm = m_editor->metaForLine(0);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::CommandRow);
        QCOMPARE(lm->nodeId, kCommandRowId);
        QCOMPARE(lm->nodeIdx, -1);

        // Type/Name/Value should be rejected on CommandRow
        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Type, 0));
        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Name, 0));
        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Value, 0));
        QVERIFY(!m_editor->isEditing());

        // Set CommandRow text with an ADDR value (simulates controller.updateCommandRow)
        m_editor->setCommandRowText(
            QStringLiteral("source\u25BE \u00B7 0xD87B5E5000"));

        // BaseAddress should be ALLOWED on CommandRow (ADDR field)
        bool ok = m_editor->beginInlineEdit(EditTarget::BaseAddress, 0);
        QVERIFY2(ok, "BaseAddress edit should be allowed on CommandRow");
        QVERIFY(m_editor->isEditing());
        m_editor->cancelInlineEdit();

        // Source should be ALLOWED on CommandRow (SRC field)
        ok = m_editor->beginInlineEdit(EditTarget::Source, 0);
        QVERIFY2(ok, "Source edit should be allowed on CommandRow");
        QVERIFY(m_editor->isEditing());
        m_editor->cancelInlineEdit();
        QApplication::processEvents(); // flush deferred showSourcePicker timer
    }

    // ── Test: inline edit lifecycle (begin → commit → re-edit) ──
    void testInlineEditReEntry() {
        // Move cursor to first data line (0=CommandRow, root header suppressed)
        m_editor->scintilla()->setCursorPosition(kFirstDataLine, 0);

        // Should not be editing
        QVERIFY(!m_editor->isEditing());

        // Begin edit on Name column
        bool ok = m_editor->beginInlineEdit(EditTarget::Name, kFirstDataLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        // Cancel the edit
        m_editor->cancelInlineEdit();
        QVERIFY(!m_editor->isEditing());

        // Re-apply document (simulates controller refresh)
        m_editor->applyDocument(m_result);

        // Should be able to edit again
        ok = m_editor->beginInlineEdit(EditTarget::Name, kFirstDataLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        // Cancel again
        m_editor->cancelInlineEdit();
        QVERIFY(!m_editor->isEditing());
    }

    // ── Test: commit inline edit then re-edit same line ──
    void testCommitThenReEdit() {
        m_editor->applyDocument(m_result);
        m_editor->scintilla()->setCursorPosition(kFirstDataLine, 0);

        // Begin value edit
        bool ok = m_editor->beginInlineEdit(EditTarget::Value, kFirstDataLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        // Simulate Enter key → commit (via signal spy)
        QSignalSpy spy(m_editor, &RcxEditor::inlineEditCommitted);
        QKeyEvent enter(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier);
        QApplication::sendEvent(m_editor->scintilla(), &enter);

        // Should have emitted commit signal and exited edit mode
        QCOMPARE(spy.count(), 1);
        QVERIFY(!m_editor->isEditing());

        // Re-apply document (simulates refresh)
        m_editor->applyDocument(m_result);

        // Must be able to edit the same line again
        ok = m_editor->beginInlineEdit(EditTarget::Value, kFirstDataLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        m_editor->cancelInlineEdit();
    }

    // ── Test: mouse click during edit commits it ──
    void testMouseClickCommitsEdit() {
        m_editor->applyDocument(m_result);

        bool ok = m_editor->beginInlineEdit(EditTarget::Name, kFirstDataLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        // Simulate mouse click on viewport — should commit (save), not cancel
        QSignalSpy commitSpy(m_editor, &RcxEditor::inlineEditCommitted);
        QSignalSpy cancelSpy(m_editor, &RcxEditor::inlineEditCancelled);
        QMouseEvent click(QEvent::MouseButtonPress, QPointF(10, 10),
                          QPointF(10, 10), Qt::LeftButton,
                          Qt::LeftButton, Qt::NoModifier);
        QApplication::sendEvent(m_editor->scintilla()->viewport(), &click);

        QVERIFY(!m_editor->isEditing());
        QCOMPARE(commitSpy.count(), 1);
        QCOMPARE(cancelSpy.count(), 0);
    }

    // ── Test: type edit emits typePickerRequested (popup-based, not inline edit) ──
    void testTypeEditCancel() {
        m_editor->applyDocument(m_result);

        QSignalSpy spy(m_editor, &RcxEditor::typePickerRequested);

        // Begin type edit on a field line — now handled by TypeSelectorPopup
        bool ok = m_editor->beginInlineEdit(EditTarget::Type, kFirstDataLine);
        QVERIFY(ok);
        QCOMPARE(spy.count(), 1);
        // Type editing uses popup, not inline edit state
        QVERIFY(!m_editor->isEditing());
    }

    // ── Test: edit on header line (Name and Type valid, Value invalid) ──
    void testHeaderLineEdit() {
        m_editor->applyDocument(m_result);

        // Root header is suppressed; find a nested struct header (e.g. CSDVersion)
        int headerLine = -1;
        for (int i = 0; i < m_result.meta.size(); i++) {
            if (m_result.meta[i].lineKind == LineKind::Header &&
                m_result.meta[i].foldHead) {
                headerLine = i;
                break;
            }
        }
        QVERIFY2(headerLine >= 0, "Should have a nested struct header");

        const LineMeta* lm = m_editor->metaForLine(headerLine);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::Header);

        // Scroll to header line to ensure visibility
        m_editor->scintilla()->SendScintilla(
            QsciScintillaBase::SCI_ENSUREVISIBLE, (unsigned long)headerLine);
        m_editor->scintilla()->SendScintilla(
            QsciScintillaBase::SCI_GOTOLINE, (unsigned long)headerLine);
        QApplication::processEvents();

        // Type edit on header should succeed (emits popup signal, not inline edit)
        QSignalSpy typeSpy(m_editor, &RcxEditor::typePickerRequested);
        bool ok = m_editor->beginInlineEdit(EditTarget::Type, headerLine);
        QVERIFY(ok);
        QCOMPARE(typeSpy.count(), 1);

        // Name edit on header should succeed
        ok = m_editor->beginInlineEdit(EditTarget::Name, headerLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());
        m_editor->cancelInlineEdit();
    }

    // ── Test: footer line rejects all edits ──
    void testFooterLineEdit() {
        m_editor->applyDocument(m_result);

        // Find the footer line
        int footerLine = -1;
        for (int i = 0; i < m_result.meta.size(); i++) {
            if (m_result.meta[i].lineKind == LineKind::Footer) {
                footerLine = i;
                break;
            }
        }
        QVERIFY(footerLine >= 0);

        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Type, footerLine));
        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Name, footerLine));
        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Value, footerLine));
        QVERIFY(!m_editor->isEditing());
    }

    // ── Test: parseValue accepts space-separated hex bytes ──
    void testParseValueHexWithSpaces() {
        bool ok;

        // Hex8 with spaces (single byte, but test the .remove(' '))
        QByteArray b = fmt::parseValue(NodeKind::Hex8, "4D", &ok);
        QVERIFY(ok);
        QCOMPARE((uint8_t)b[0], (uint8_t)0x4D);

        // Hex32 with space-separated bytes (raw byte order, no endian conversion)
        b = fmt::parseValue(NodeKind::Hex32, "DE AD BE EF", &ok);
        QVERIFY(ok);
        QCOMPARE(b.size(), 4);
        QCOMPARE((uint8_t)b[0], (uint8_t)0xDE);
        QCOMPARE((uint8_t)b[1], (uint8_t)0xAD);
        QCOMPARE((uint8_t)b[2], (uint8_t)0xBE);
        QCOMPARE((uint8_t)b[3], (uint8_t)0xEF);

        // Hex64 with space-separated bytes
        b = fmt::parseValue(NodeKind::Hex64, "4D 5A 90 00 00 00 00 00", &ok);
        QVERIFY(ok);
        QCOMPARE(b.size(), 8);
        QCOMPARE((uint8_t)b[0], (uint8_t)0x4D);
        QCOMPARE((uint8_t)b[1], (uint8_t)0x5A);
        QCOMPARE((uint8_t)b[7], (uint8_t)0x00);

        // Hex64 continuous - stores as native-endian (numeric value preserved)
        b = fmt::parseValue(NodeKind::Hex64, "4D5A900000000000", &ok);
        QVERIFY(ok);
        uint64_t v64;
        memcpy(&v64, b.data(), 8);
        QCOMPARE(v64, (uint64_t)0x4D5A900000000000);

        // Hex64 with 0x prefix and spaces
        b = fmt::parseValue(NodeKind::Hex64, "0x4D 5A 90 00 00 00 00 00", &ok);
        QVERIFY(ok);
    }

    // ── Test: type autocomplete accepts typed input and commits ──
    void testTypeAutocompleteTypingAndCommit() {
        m_editor->applyDocument(m_result);

        QSignalSpy spy(m_editor, &RcxEditor::typePickerRequested);

        // Type edit now emits typePickerRequested for TypeSelectorPopup
        bool ok = m_editor->beginInlineEdit(EditTarget::Type, kFirstDataLine);
        QVERIFY(ok);
        QCOMPARE(spy.count(), 1);

        // Verify signal carries valid nodeIdx (second arg)
        QList<QVariant> args = spy.first();
        QVERIFY(args.at(1).toInt() >= 0);

        // No inline edit state — popup handles everything
        QVERIFY(!m_editor->isEditing());

        m_editor->applyDocument(m_result);
    }

    // ── Test: type edit click-away commits original (no change) ──
    void testTypeEditClickAwayNoChange() {
        m_editor->applyDocument(m_result);

        QSignalSpy spy(m_editor, &RcxEditor::typePickerRequested);

        // Type edit emits typePickerRequested (popup handles click-away)
        bool ok = m_editor->beginInlineEdit(EditTarget::Type, kFirstDataLine);
        QVERIFY(ok);
        QCOMPARE(spy.count(), 1);

        // No inline edit state — popup handles click-away behavior
        QVERIFY(!m_editor->isEditing());

        m_editor->applyDocument(m_result);
    }

    // ── Test: column span hit-testing for cursor shape ──
    void testColumnSpanHitTest() {
        m_editor->applyDocument(m_result);

        // kFirstDataLine is a field line (UInt8), verify spans are valid
        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::Field);

        // Type span should be valid for field lines
        ColumnSpan ts = RcxEditor::typeSpan(*lm);
        QVERIFY(ts.valid);
        QVERIFY(ts.start < ts.end);

        // Name span should be valid for field lines
        ColumnSpan ns = RcxEditor::nameSpan(*lm);
        QVERIFY(ns.valid);
        QVERIFY(ns.start < ns.end);

        // Value span should be valid for field lines
        QString lineText;
        int len = (int)m_editor->scintilla()->SendScintilla(
            QsciScintillaBase::SCI_LINELENGTH, (unsigned long)kFirstDataLine);
        QVERIFY(len > 0);
        ColumnSpan vs = RcxEditor::valueSpan(*lm, len);
        QVERIFY(vs.valid);
        QVERIFY(vs.start < vs.end);

        // Footer line should have no valid type/name spans
        int footerLine = -1;
        for (int i = 0; i < m_result.meta.size(); i++) {
            if (m_result.meta[i].lineKind == LineKind::Footer) {
                footerLine = i;
                break;
            }
        }
        QVERIFY(footerLine >= 0);
        const LineMeta* flm = m_editor->metaForLine(footerLine);
        QVERIFY(flm);
        ColumnSpan fts = RcxEditor::typeSpan(*flm);
        QVERIFY(!fts.valid);
        ColumnSpan fns = RcxEditor::nameSpan(*flm);
        QVERIFY(!fns.valid);
        ColumnSpan fvs = RcxEditor::valueSpan(*flm, 10);
        QVERIFY(!fvs.valid);
    }

    // ── Test: selectedNodeIndices ──
    void testSelectedNodeIndices() {
        m_editor->applyDocument(m_result);

        // Put cursor on first field line (kFirstDataLine; 0=CommandRow)
        m_editor->scintilla()->setCursorPosition(kFirstDataLine, 0);
        QSet<int> sel = m_editor->selectedNodeIndices();
        QCOMPARE(sel.size(), 1);

        // The node index should match the first field
        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);
        QVERIFY(sel.contains(lm->nodeIdx));
    }

    // ── Test: composed text does not contain "// base:" (moved to cmd bar) ──
    void testBaseAddressDisplay() {
        NodeTree tree = makeTestTree();
        tree.baseAddress = 0x10;
        BufferProvider prov = makeTestProvider();
        ComposeResult result = compose(tree, prov);

        m_editor->applyDocument(result);

        // Root header is suppressed; verify no "// base:" anywhere in output
        QVERIFY2(!result.text.contains("// base:"),
                 "Composed text should not contain '// base:' (consolidated into cmd bar)");

        // kFirstDataLine should be the first field (root header suppressed)
        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::Field);

        m_editor->applyDocument(m_result);
    }

    // ── Test: CommandRow ADDR span is valid ──
    void testBaseAddressSpan() {
        m_editor->applyDocument(m_result);

        // Set CommandRow text with ADDR value (simulates controller)
        m_editor->setCommandRowText(
            QStringLiteral("source\u25BE \u00B7 0xD87B5E5000"));

        // Line 0 is CommandRow
        const LineMeta* lm = m_editor->metaForLine(0);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::CommandRow);

        // Get CommandRow line text
        QString lineText;
        int len = (int)m_editor->scintilla()->SendScintilla(
            QsciScintillaBase::SCI_LINELENGTH, (unsigned long)0);
        if (len > 0) {
            QByteArray buf(len + 1, '\0');
            m_editor->scintilla()->SendScintilla(
                QsciScintillaBase::SCI_GETLINE, (unsigned long)0, (void*)buf.data());
            lineText = QString::fromUtf8(buf.constData(), len);
            while (lineText.endsWith('\n') || lineText.endsWith('\r'))
                lineText.chop(1);
        }

        // ADDR span should be valid (uses commandRowAddrSpan)
        ColumnSpan as = commandRowAddrSpan(lineText);
        QVERIFY2(as.valid, "ADDR span should be valid on CommandRow");
        QVERIFY(as.start < as.end);

        // The span should cover the hex address
        QString spanText = lineText.mid(as.start, as.end - as.start);
        QVERIFY2(spanText.contains("0x") || spanText.startsWith("0X"),
                 qPrintable("Span should contain hex address, got: " + spanText));

        m_editor->applyDocument(m_result);
    }

    // ── Test: value edit commit fires signal with typed text ──
    void testValueEditCommitUpdatesSignal() {
        m_editor->applyDocument(m_result);

        // kFirstDataLine = first UInt8 field (InheritedAddressSpace, root header suppressed)
        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::Field);
        // Begin value edit
        bool ok = m_editor->beginInlineEdit(EditTarget::Value, kFirstDataLine);
        QVERIFY(ok);
        QVERIFY(m_editor->isEditing());

        // Select all text in the edit span and type replacement
        QKeyEvent home(QEvent::KeyPress, Qt::Key_Home, Qt::NoModifier);
        QApplication::sendEvent(m_editor->scintilla(), &home);
        QKeyEvent end(QEvent::KeyPress, Qt::Key_End, Qt::ShiftModifier);
        QApplication::sendEvent(m_editor->scintilla(), &end);

        // Type "42" to replace selected text
        for (QChar c : QString("42")) {
            QKeyEvent key(QEvent::KeyPress, 0, Qt::NoModifier, QString(c));
            QApplication::sendEvent(m_editor->scintilla(), &key);
        }
        QApplication::processEvents();

        // Commit with Enter
        QSignalSpy spy(m_editor, &RcxEditor::inlineEditCommitted);
        QKeyEvent enter(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier);
        QApplication::sendEvent(m_editor->scintilla(), &enter);

        QCOMPARE(spy.count(), 1);
        QVERIFY(!m_editor->isEditing());

        // Verify the committed text contains what was typed.
        // UInt8 values display as hex (e.g., "0x042"), so the typed "42" gets
        // concatenated with the existing "0x0" prefix → "0x042".
        // The important check: the signal fired with non-empty text.
        QList<QVariant> args = spy.first();
        QString committedText = args.at(3).toString().trimmed();
        QVERIFY2(!committedText.isEmpty(),
                 "Committed text should not be empty");

        m_editor->applyDocument(m_result);
    }

    // ── Test: base address edit begins on CommandRow (line 0) ──
    void testBaseAddressEditBegins() {
        m_editor->applyDocument(m_result);

        // Set CommandRow text with ADDR value (simulates controller)
        m_editor->setCommandRowText(
            QStringLiteral("source\u25BE \u00B7 0xD87B5E5000"));

        // Begin base address edit on line 0 (CommandRow ADDR field)
        bool ok = m_editor->beginInlineEdit(EditTarget::BaseAddress, 0);
        QVERIFY2(ok, "Should be able to begin base address edit on CommandRow");
        QVERIFY(m_editor->isEditing());

        // Cancel and reset
        m_editor->cancelInlineEdit();
        m_editor->applyDocument(m_result);
    }

    // ── Test: cursor stays Arrow after left-click on a node ──
    void testCursorAfterLeftClick() {
        m_editor->applyDocument(m_result);

        // Click on a field line at the indent area (col 0 — not over editable text)
        QPoint clickPos = colToViewport(m_editor->scintilla(), kFirstDataLine, 0);
        sendLeftClick(m_editor->scintilla()->viewport(), clickPos);
        QApplication::processEvents();

        // Cursor must be Arrow — QScintilla must NOT have set it to IBeam
        QCOMPARE(viewportCursor(m_editor), Qt::ArrowCursor);
        QVERIFY(!m_editor->isEditing());
    }

    // ── Test: cursor is IBeam only over trimmed name text, Arrow over padding ──
    void testCursorShapeOverText() {
        m_editor->applyDocument(m_result);

        // kFirstDataLine is a field (UInt8 InheritedAddressSpace)
        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);

        // Get the name span (padded to kColName width)
        ColumnSpan ns = RcxEditor::nameSpan(*lm, lm->effectiveTypeW, lm->effectiveNameW);
        QVERIFY(ns.valid);

        // Move mouse to the start of the name span (should be over text)
        QPoint textPos = colToViewport(m_editor->scintilla(), kFirstDataLine, ns.start + 1);
        sendMouseMove(m_editor->scintilla()->viewport(), textPos);
        QApplication::processEvents();
        QCOMPARE(viewportCursor(m_editor), Qt::IBeamCursor);

        // Move mouse to far padding area (past end of text, within padded span)
        // The padded span ends at ns.end but the trimmed text is shorter
        QPoint padPos = colToViewport(m_editor->scintilla(), kFirstDataLine, ns.end - 1);
        sendMouseMove(m_editor->scintilla()->viewport(), padPos);
        QApplication::processEvents();
        // Should be Arrow (padding whitespace, not actual text)
        QCOMPARE(viewportCursor(m_editor), Qt::ArrowCursor);
    }

    // ── Test: cursor is PointingHand over type column text ──
    void testCursorShapeOverType() {
        m_editor->applyDocument(m_result);

        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);

        // Type span starts after the fold column + indent
        ColumnSpan ts = RcxEditor::typeSpan(*lm, lm->effectiveTypeW);
        QVERIFY(ts.valid);

        // Move to start of type text (e.g. "uint8_t")
        QPoint typePos = colToViewport(m_editor->scintilla(), kFirstDataLine, ts.start + 1);
        sendMouseMove(m_editor->scintilla()->viewport(), typePos);
        QApplication::processEvents();
        QCOMPARE(viewportCursor(m_editor), Qt::PointingHandCursor);
    }

    // ── Test: cursor is PointingHand over fold column ──
    void testCursorShapeInFoldColumn() {
        m_editor->applyDocument(m_result);
        QApplication::processEvents();

        // Root header is suppressed; find a nested struct with foldHead
        int foldLine = -1;
        for (int i = 0; i < m_result.meta.size(); i++) {
            if (m_result.meta[i].foldHead && m_result.meta[i].lineKind == LineKind::Header) {
                foldLine = i;
                break;
            }
        }
        QVERIFY2(foldLine >= 0, "Should have at least one foldable struct header");

        const LineMeta* lm = m_editor->metaForLine(foldLine);
        QVERIFY(lm);
        QVERIFY(lm->foldHead);

        // Scroll to ensure the fold line is visible
        m_editor->scintilla()->SendScintilla(
            QsciScintillaBase::SCI_ENSUREVISIBLE, (unsigned long)foldLine);
        m_editor->scintilla()->SendScintilla(
            QsciScintillaBase::SCI_GOTOLINE, (unsigned long)foldLine);
        QApplication::processEvents();

        // Fold indicator is always at cols 0-2 (kFoldCol=3), regardless of depth
        QPoint foldPos = colToViewport(m_editor->scintilla(), foldLine, 1);
        QVERIFY2(foldPos.y() > 0, qPrintable(QString("Fold line %1 should be visible, got y=%2")
            .arg(foldLine).arg(foldPos.y())));
        sendMouseMove(m_editor->scintilla()->viewport(), foldPos);
        QApplication::processEvents();
        QCOMPARE(viewportCursor(m_editor), Qt::PointingHandCursor);
    }

    // ── Test: no IBeam after click then mouse-move to non-editable area ──
    void testNoIBeamAfterClickThenMove() {
        m_editor->applyDocument(m_result);

        // Click on a field to select the node
        const LineMeta* lm = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm);
        ColumnSpan ns = RcxEditor::nameSpan(*lm, lm->effectiveTypeW, lm->effectiveNameW);
        QVERIFY(ns.valid);

        // Click in the name area (selects the node)
        QPoint clickPos = colToViewport(m_editor->scintilla(), kFirstDataLine, ns.start + 1);
        sendLeftClick(m_editor->scintilla()->viewport(), clickPos);
        QApplication::processEvents();

        // Now move mouse to col 0 (indent area — non-editable)
        QPoint emptyPos = colToViewport(m_editor->scintilla(), kFirstDataLine, 0);
        sendMouseMove(m_editor->scintilla()->viewport(), emptyPos);
        QApplication::processEvents();

        // Must be Arrow, NOT IBeam (QScintilla must not have leaked its cursor state)
        QCOMPARE(viewportCursor(m_editor), Qt::ArrowCursor);
        QVERIFY(!m_editor->isEditing());
    }

    // ── Test: CommandRow root class edits on line 0 ──
    void testCommandRowRootClassEdits() {
        m_editor->applyDocument(m_result);

        // Set CommandRow text with root class (simulates controller.updateCommandRow)
        m_editor->setCommandRowText(
            QStringLiteral("source\u25BE \u00B7 0xD87B5E5000 \u00B7 struct _PEB64 {"));

        // RootClassName should be allowed on CommandRow (line 0)
        bool ok = m_editor->beginInlineEdit(EditTarget::RootClassName, 0);
        QVERIFY2(ok, "RootClassName edit should be allowed on CommandRow");
        QVERIFY(m_editor->isEditing());
        m_editor->cancelInlineEdit();
    }

    // ── Test: CommandRow root class name editable ──
    void testCommandRowRootClassName() {
        m_editor->applyDocument(m_result);

        // Set CommandRow with root class
        m_editor->setCommandRowText(
            QStringLiteral("source\u25BE \u00B7 0xD87B5E5000 \u00B7 struct _PEB64 {"));

        // Line 0 is CommandRow
        const LineMeta* lm = m_editor->metaForLine(0);
        QVERIFY(lm);
        QCOMPARE(lm->lineKind, LineKind::CommandRow);

        // RootClassName should work
        QVERIFY(m_editor->beginInlineEdit(EditTarget::RootClassName, 0));
        QVERIFY(m_editor->isEditing());
        m_editor->cancelInlineEdit();

        m_editor->applyDocument(m_result);
    }

    // ── Test: root header/footer are suppressed (CommandRow replaces them) ──
    void testRootFoldSuppressed() {
        m_editor->applyDocument(m_result);

        // Root struct header is completely suppressed from output.
        // Line 0 = CommandRow, Line 1 = first field.
        const LineMeta* lm2 = m_editor->metaForLine(kFirstDataLine);
        QVERIFY(lm2);
        QCOMPARE(lm2->lineKind, LineKind::Field);

        // Verify no root header line exists in the output (footer may have isRootHeader for flush-left)
        bool foundRootHeader = false;
        for (int i = 0; i < m_result.meta.size(); i++) {
            if (m_result.meta[i].isRootHeader && m_result.meta[i].lineKind == LineKind::Header) {
                foundRootHeader = true;
                break;
            }
        }
        QVERIFY2(!foundRootHeader,
                 "Root header should be suppressed from compose output");
    }

    // ── Test: command row hover indicator survives refresh cycle ──
    void testCommandRowHoverSurvivesRefresh() {
        // IND_HOVER_SPAN = 11 (defined in editor.cpp, replicate for test)
        constexpr int IND_HOVER_SPAN = 11;

        m_editor->applyDocument(m_result);

        // Set command row text (simulates controller.updateCommandRow)
        QString cmdText = QStringLiteral(
            "source\u25BE \u00B7 0xD87B5E5000 \u00B7 struct _PEB64 {");
        m_editor->setCommandRowText(cmdText);
        QApplication::processEvents();

        // Parse the source span on line 0
        auto* sci = m_editor->scintilla();
        int len = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_LINELENGTH, (unsigned long)0);
        QVERIFY(len > 0);
        QByteArray buf(len + 1, '\0');
        sci->SendScintilla(QsciScintillaBase::SCI_GETLINE, (unsigned long)0,
                           (void*)buf.data());
        QString lineText = QString::fromUtf8(buf.constData(), len);
        while (lineText.endsWith('\n') || lineText.endsWith('\r'))
            lineText.chop(1);

        ColumnSpan srcSpan = commandRowSrcSpan(lineText);
        QVERIFY2(srcSpan.valid, "Source span should be valid on command row");

        // Programmatically move mouse to the source span
        int hoverCol = srcSpan.start + 1;
        QPoint hoverPos = colToViewport(sci, 0, hoverCol);
        sendMouseMove(sci->viewport(), hoverPos);
        QApplication::processEvents();

        // Verify IND_HOVER_SPAN is set at the hover position
        long pos = sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                                      (unsigned long)0, (long)hoverCol);
        sci->SendScintilla(QsciScintillaBase::SCI_SETINDICATORCURRENT,
                           (unsigned long)IND_HOVER_SPAN);
        int valBefore = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_INDICATORVALUEAT,
            (unsigned long)IND_HOVER_SPAN, pos);
        QVERIFY2(valBefore != 0,
                 "IND_HOVER_SPAN should be set on source span after hover");

        // Verify cursor is PointingHand (Source target = clickable)
        QCOMPARE(viewportCursor(m_editor), Qt::PointingHandCursor);

        // ── Simulate a full refresh cycle (same order as controller.refresh) ──
        ViewState vs = m_editor->saveViewState();
        m_editor->applyDocument(m_result);
        m_editor->restoreViewState(vs);

        // Cursor must NOT have flipped to Arrow during applyDocument
        // (applyHoverCursor is not called prematurely on composed text)
        QCOMPARE(viewportCursor(m_editor), Qt::PointingHandCursor);

        // updateCommandRow() — replaces line 0 text
        m_editor->setCommandRowText(cmdText);

        // applySelectionOverlays() — must run AFTER updateCommandRow
        m_editor->applySelectionOverlay(QSet<uint64_t>());
        QApplication::processEvents();

        // Re-query the position (text was replaced, byte offset may have shifted)
        long posAfter = sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                                           (unsigned long)0, (long)hoverCol);
        int valAfter = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_INDICATORVALUEAT,
            (unsigned long)IND_HOVER_SPAN, posAfter);
        QVERIFY2(valAfter != 0,
                 "IND_HOVER_SPAN must survive refresh on command row "
                 "(hover should not flicker)");

        // Cursor must still be PointingHand after full refresh cycle
        QCOMPARE(viewportCursor(m_editor), Qt::PointingHandCursor);

        m_editor->applyDocument(m_result);
    }

    // ── Test: command row hover survives multiple rapid refresh cycles ──
    void testCommandRowHoverSurvivesRepeatedRefresh() {
        constexpr int IND_HOVER_SPAN = 11;

        m_editor->applyDocument(m_result);

        QString cmdText = QStringLiteral(
            "source\u25BE \u00B7 0xD87B5E5000 \u00B7 struct _PEB64 {");
        m_editor->setCommandRowText(cmdText);
        QApplication::processEvents();

        auto* sci = m_editor->scintilla();
        int lineLen = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_LINELENGTH, (unsigned long)0);
        QByteArray buf(lineLen + 1, '\0');
        sci->SendScintilla(QsciScintillaBase::SCI_GETLINE, (unsigned long)0,
                           (void*)buf.data());
        QString lineText = QString::fromUtf8(buf.constData(), lineLen);
        while (lineText.endsWith('\n') || lineText.endsWith('\r'))
            lineText.chop(1);

        ColumnSpan srcSpan = commandRowSrcSpan(lineText);
        QVERIFY(srcSpan.valid);
        int hoverCol = srcSpan.start + 1;

        // Move mouse into position
        QPoint hoverPos = colToViewport(sci, 0, hoverCol);
        sendMouseMove(sci->viewport(), hoverPos);
        QApplication::processEvents();

        // Simulate 5 rapid refresh cycles (like ~660ms timer x5)
        for (int cycle = 0; cycle < 5; cycle++) {
            ViewState vs = m_editor->saveViewState();
            m_editor->applyDocument(m_result);
            m_editor->restoreViewState(vs);
            m_editor->setCommandRowText(cmdText);
            m_editor->applySelectionOverlay(QSet<uint64_t>());

            // Re-send mouse move each cycle (mouse is still there physically)
            sendMouseMove(sci->viewport(), hoverPos);
            QApplication::processEvents();

            long pos = sci->SendScintilla(QsciScintillaBase::SCI_FINDCOLUMN,
                                          (unsigned long)0, (long)hoverCol);
            int val = (int)sci->SendScintilla(
                QsciScintillaBase::SCI_INDICATORVALUEAT,
                (unsigned long)IND_HOVER_SPAN, pos);
            QVERIFY2(val != 0,
                     qPrintable(QString(
                         "IND_HOVER_SPAN lost on refresh cycle %1").arg(cycle)));
            QVERIFY2(viewportCursor(m_editor) == Qt::PointingHandCursor,
                     qPrintable(QString(
                         "Cursor flipped away from PointingHand on cycle %1").arg(cycle)));
        }

        m_editor->applyDocument(m_result);
    }

    // ── Test: MenuBarStyle gives QMenu items generous click targets ──
    // ── Test: M_ACCENT marker appears on selected rows ──
    void testAccentMarkerOnSelectedRows() {
        m_editor->applyDocument(m_result);

        // Find a data line with a valid nodeId
        uint64_t targetId = 0;
        int targetLine = -1;
        for (int i = kFirstDataLine; i < m_result.meta.size(); i++) {
            const auto& lm = m_result.meta[i];
            if (lm.nodeId != 0 && lm.nodeId != kCommandRowId
                && lm.lineKind == LineKind::Field) {
                targetId = lm.nodeId;
                targetLine = i;
                break;
            }
        }
        QVERIFY2(targetLine >= 0, "No data line found for accent test");

        // Apply selection overlay with that node
        QSet<uint64_t> selIds;
        selIds.insert(targetId);
        m_editor->applySelectionOverlay(selIds);

        auto* sci = m_editor->scintilla();

        // Direct test: add M_ACCENT manually and read it back
        int directHandle = sci->markerAdd(targetLine, M_ACCENT);
        int directMarkers = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_MARKERGET, (unsigned long)targetLine);
        QVERIFY2(directMarkers & (1 << M_ACCENT),
                 qPrintable(QString("Direct markerAdd(M_ACCENT=%1) failed on line %2 (handle=%3, mask=0x%4)")
                     .arg(M_ACCENT).arg(targetLine).arg(directHandle).arg(directMarkers, 0, 16)));
        sci->markerDelete(targetLine, M_ACCENT);

        // Now test via applySelectionOverlay
        m_editor->applySelectionOverlay(selIds);

        // Verify M_SELECTED is set on the target line
        int markers = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_MARKERGET, (unsigned long)targetLine);
        QVERIFY2(markers & (1 << M_SELECTED),
                 qPrintable(QString("M_SELECTED not set on line %1 (mask=0x%2)")
                     .arg(targetLine).arg(markers, 0, 16)));

        // Verify M_ACCENT is set on the target line
        QVERIFY2(markers & (1 << M_ACCENT),
                 qPrintable(QString("M_ACCENT not set on line %1 (mask=0x%2)")
                     .arg(targetLine).arg(markers, 0, 16)));

        // Verify a non-selected line does NOT have M_ACCENT
        int otherLine = -1;
        for (int i = kFirstDataLine; i < m_result.meta.size(); i++) {
            const auto& lm = m_result.meta[i];
            if (lm.nodeId != targetId && lm.nodeId != 0
                && lm.nodeId != kCommandRowId && lm.lineKind == LineKind::Field) {
                otherLine = i;
                break;
            }
        }
        if (otherLine >= 0) {
            int otherMarkers = (int)sci->SendScintilla(
                QsciScintillaBase::SCI_MARKERGET, (unsigned long)otherLine);
            QVERIFY2(!(otherMarkers & (1 << M_ACCENT)),
                     qPrintable(QString("M_ACCENT should NOT be set on non-selected line %1 (mask=0x%2)")
                         .arg(otherLine).arg(otherMarkers, 0, 16)));
        }

        // Clear selection and verify accent is removed
        m_editor->applySelectionOverlay(QSet<uint64_t>());
        markers = (int)sci->SendScintilla(
            QsciScintillaBase::SCI_MARKERGET, (unsigned long)targetLine);
        QVERIFY2(!(markers & (1 << M_ACCENT)),
                 qPrintable(QString("M_ACCENT should be cleared after deselection on line %1 (mask=0x%2)")
                     .arg(targetLine).arg(markers, 0, 16)));
    }

    void testMenuItemSizeIsAccessible() {
        // Instantiate the same QProxyStyle used by the app (MenuBarStyle is
        // defined in main.cpp — we replicate the logic here to test it)
        class TestMenuStyle : public QProxyStyle {
        public:
            using QProxyStyle::QProxyStyle;
            QSize sizeFromContents(ContentsType type, const QStyleOption* opt,
                                   const QSize& sz, const QWidget* w) const override {
                QSize s = QProxyStyle::sizeFromContents(type, opt, sz, w);
                if (type == CT_MenuBarItem)
                    s.setHeight(s.height() + qRound(s.height() * 0.5));
                if (type == CT_MenuItem)
                    s = QSize(s.width() + 24, s.height() + 4);
                return s;
            }
        };

        TestMenuStyle style;
        QMenu menu;
        auto* action = menu.addAction("Delete Node");

        QStyleOptionMenuItem opt;
        opt.initFrom(&menu);
        opt.text = action->text();

        QSize base = style.QProxyStyle::sizeFromContents(
            QStyle::CT_MenuItem, &opt, QSize(80, 20), &menu);
        QSize styled = style.sizeFromContents(
            QStyle::CT_MenuItem, &opt, QSize(80, 20), &menu);

        // Width must grow by at least 24px
        QVERIFY2(styled.width() >= base.width() + 24,
                 qPrintable(QString("Menu item width %1 too narrow (base %2, need +24)")
                     .arg(styled.width()).arg(base.width())));

        // Height must grow by at least 4px
        QVERIFY2(styled.height() >= base.height() + 4,
                 qPrintable(QString("Menu item height %1 too short (base %2, need +4)")
                     .arg(styled.height()).arg(base.height())));
    }

    // ── Test: non-hex nodes don't show false heat coloring after offset shift ──
    void testDeleteClearsHeatOnShiftedNodes() {
        // Heat indicator constants (replicated from editor.cpp)
        constexpr int IND_HEAT_COLD = 13;
        constexpr int IND_HEAT_WARM = 17;
        constexpr int IND_HEAT_HOT  = 18;

        // Build a small tree: root struct with mixed regular (non-hex) + hex fields
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.structTypeName = "SmallStruct";
        root.name = "s";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // field0: UInt32  at offset  0 (4 bytes) — will be deleted
        // field1: UInt32  at offset  4 (4 bytes) — regular type, will shift
        // field2: Float   at offset  8 (4 bytes) — regular type, will shift
        // field3: Hex32   at offset 12 (4 bytes) — hex type, will shift
        struct FieldDef { int off; NodeKind kind; const char* name; };
        FieldDef defs[] = {
            { 0, NodeKind::UInt32, "count"},
            { 4, NodeKind::UInt32, "flags"},
            { 8, NodeKind::Float,  "speed"},
            {12, NodeKind::Hex32,  "raw"},
        };
        QVector<uint64_t> fieldIds;
        for (auto& d : defs) {
            Node n;
            n.kind = d.kind;
            n.name = d.name;
            n.parentId = rootId;
            n.offset = d.off;
            int idx = tree.addNode(n);
            fieldIds.append(tree.nodes[idx].id);
        }

        // Create a provider with 16 bytes of recognizable data
        QByteArray data(16, '\0');
        uint32_t v0 = 42;       memcpy(data.data() + 0,  &v0, 4);  // count=42
        uint32_t v1 = 0xFF;     memcpy(data.data() + 4,  &v1, 4);  // flags=255
        float    v2 = 3.14f;    memcpy(data.data() + 8,  &v2, 4);  // speed=3.14
        uint32_t v3 = 0xCAFE;   memcpy(data.data() + 12, &v3, 4);  // raw=0xCAFE
        BufferProvider prov(data);

        // Compose the initial document
        ComposeResult result = compose(tree, prov);

        // Inject heatLevel=2 (warm) on field1, field2, field3 — simulates
        // heat accumulated before the delete
        for (auto& lm : result.meta) {
            for (int i = 1; i <= 3; i++) {
                if (lm.nodeId == fieldIds[i])
                    lm.heatLevel = 2;
            }
        }

        // Apply to editor — heat indicators should appear
        m_editor->applyDocument(result);
        QApplication::processEvents();

        auto* sci = m_editor->scintilla();

        // Helper: check if any heat indicator is set anywhere on a line
        auto hasHeatOnLine = [&](int line) -> bool {
            int lineLen = (int)sci->SendScintilla(
                QsciScintillaBase::SCI_LINELENGTH, (unsigned long)line);
            long lineStart = sci->SendScintilla(
                QsciScintillaBase::SCI_POSITIONFROMLINE, (unsigned long)line);
            for (long pos = lineStart; pos < lineStart + lineLen; pos++) {
                for (int ind : { IND_HEAT_COLD, IND_HEAT_WARM, IND_HEAT_HOT }) {
                    int val = (int)sci->SendScintilla(
                        QsciScintillaBase::SCI_INDICATORVALUEAT,
                        (unsigned long)ind, pos);
                    if (val != 0) return true;
                }
            }
            return false;
        };

        // Find lines for each shifted field
        auto findFieldLine = [&](const ComposeResult& cr, uint64_t nodeId) -> int {
            for (int i = 0; i < cr.meta.size(); i++) {
                if (cr.meta[i].nodeId == nodeId && cr.meta[i].lineKind == LineKind::Field)
                    return i;
            }
            return -1;
        };

        int line1 = findFieldLine(result, fieldIds[1]);
        int line2 = findFieldLine(result, fieldIds[2]);
        int line3 = findFieldLine(result, fieldIds[3]);
        QVERIFY(line1 >= 0);
        QVERIFY(line2 >= 0);
        QVERIFY(line3 >= 0);

        // Verify heat indicators ARE present (UInt32, Float, and Hex32)
        QVERIFY2(hasHeatOnLine(line1),
                 "Heat should be present on UInt32 'flags' before delete");
        QVERIFY2(hasHeatOnLine(line2),
                 "Heat should be present on Float 'speed' before delete");
        QVERIFY2(hasHeatOnLine(line3),
                 "Heat should be present on Hex32 'raw' before delete");

        // ── Simulate delete of field0 (UInt32 'count' at offset 0) ──
        int field0Idx = tree.indexOfId(fieldIds[0]);
        QVERIFY(field0Idx >= 0);
        tree.nodes.remove(field0Idx);
        tree.invalidateIdCache();

        // Shift remaining fields' offsets down by 4
        for (int i = 1; i <= 3; i++) {
            int fi = tree.indexOfId(fieldIds[i]);
            if (fi >= 0) tree.nodes[fi].offset -= 4;
        }

        // Recompose — heatLevel defaults to 0 (simulates cleared history)
        ComposeResult afterResult = compose(tree, prov);

        // Apply the post-delete document to the editor
        m_editor->applyDocument(afterResult);
        QApplication::processEvents();

        // Find new line positions
        int newLine1 = findFieldLine(afterResult, fieldIds[1]);
        int newLine2 = findFieldLine(afterResult, fieldIds[2]);
        int newLine3 = findFieldLine(afterResult, fieldIds[3]);
        QVERIFY(newLine1 >= 0);
        QVERIFY(newLine2 >= 0);
        QVERIFY(newLine3 >= 0);

        // After applying heatLevel=0, NO heat indicators should appear
        QVERIFY2(!hasHeatOnLine(newLine1),
                 "UInt32 'flags' should NOT show heat after offset shift "
                 "(old values are from wrong address)");
        QVERIFY2(!hasHeatOnLine(newLine2),
                 "Float 'speed' should NOT show heat after offset shift "
                 "(old values are from wrong address)");
        QVERIFY2(!hasHeatOnLine(newLine3),
                 "Hex32 'raw' should NOT show heat after offset shift "
                 "(old values are from wrong address)");

        // Restore original document
        m_editor->applyDocument(m_result);
    }

    void testMenuHoverRendersAmberText() {
        // Replicate MenuBarStyle with drawControl hover override
        class TestMenuStyle : public QProxyStyle {
        public:
            using QProxyStyle::QProxyStyle;
            QSize sizeFromContents(ContentsType type, const QStyleOption* opt,
                                   const QSize& sz, const QWidget* w) const override {
                QSize s = QProxyStyle::sizeFromContents(type, opt, sz, w);
                if (type == CT_MenuBarItem)
                    s.setHeight(s.height() + qRound(s.height() * 0.5));
                if (type == CT_MenuItem)
                    s = QSize(s.width() + 24, s.height() + 4);
                return s;
            }
            void drawPrimitive(PrimitiveElement elem, const QStyleOption* opt,
                               QPainter* p, const QWidget* w) const override {
                if (elem == PE_FrameMenu) return;
                QProxyStyle::drawPrimitive(elem, opt, p, w);
            }
            void drawControl(ControlElement element, const QStyleOption* opt,
                             QPainter* p, const QWidget* w) const override {
                if (element == CE_MenuItem || element == CE_MenuBarItem) {
                    if (auto* mi = qstyleoption_cast<const QStyleOptionMenuItem*>(opt)) {
                        if ((mi->state & State_Selected)
                            && mi->menuItemType != QStyleOptionMenuItem::Separator) {
                            QStyleOptionMenuItem patched = *mi;
                            patched.palette.setColor(QPalette::Highlight,
                                mi->palette.color(QPalette::Mid));
                            patched.palette.setColor(QPalette::HighlightedText,
                                mi->palette.color(QPalette::Link));
                            QProxyStyle::drawControl(element, &patched, p, w);
                            return;
                        }
                    }
                }
                QProxyStyle::drawControl(element, opt, p, w);
            }
        };

        // Install our style as the app style (same as main.cpp does)
        qApp->setStyle(new TestMenuStyle("Fusion"));

        // Set app palette matching applyGlobalTheme for Reclass Dark
        QPalette pal;
        pal.setColor(QPalette::Window,          QColor("#1e1e1e"));
        pal.setColor(QPalette::WindowText,      QColor("#d4d4d4"));
        pal.setColor(QPalette::Base,            QColor("#252526"));
        pal.setColor(QPalette::AlternateBase,   QColor("#2a2d2e"));
        pal.setColor(QPalette::Text,            QColor("#d4d4d4"));
        pal.setColor(QPalette::Button,          QColor("#333333"));
        pal.setColor(QPalette::ButtonText,      QColor("#d4d4d4"));
        pal.setColor(QPalette::Highlight,       QColor("#2b2b2b"));
        pal.setColor(QPalette::HighlightedText, QColor("#E6B450"));
        pal.setColor(QPalette::Mid,             QColor("#3c3c3c"));
        pal.setColor(QPalette::Dark,            QColor("#1e1e1e"));
        pal.setColor(QPalette::Light,           QColor("#505050"));
        pal.setColor(QPalette::Link,            QColor("#E6B450"));
        qApp->setPalette(pal);

        // Build and show a real QMenu
        QMenu menu;
        menu.addAction("First Item");
        menu.addAction("Second Item");
        menu.addAction("Third Item");
        menu.popup(QPoint(100, 100));
        QVERIFY(QTest::qWaitForWindowExposed(&menu));
        QApplication::processEvents();

        // ── Deliver real mouse events to trigger hover on second item ──
        QList<QAction*> actions = menu.actions();
        QRect itemRect = menu.actionGeometry(actions[1]);
        QPoint localCenter = itemRect.center();

        // Enter event — tells QMenu the mouse is inside
        QEvent enter(QEvent::Enter);
        QApplication::sendEvent(&menu, &enter);
        QApplication::processEvents();

        // MouseMove to the second item — triggers hover/select
        QMouseEvent move(QEvent::MouseMove, QPointF(localCenter),
                         menu.mapToGlobal(localCenter),
                         Qt::NoButton, Qt::NoButton, Qt::NoModifier);
        QApplication::sendEvent(&menu, &move);
        QApplication::processEvents();
        QTest::qWait(50);  // let repaint settle

        // Verify QMenu internally considers the action hovered
        QVERIFY2(menu.activeAction() == actions[1],
                 "QMenu did not set activeAction after mouse move — "
                 "hover event delivery failed");

        // ── Capture what's actually on screen ──
        QScreen* screen = QGuiApplication::primaryScreen();
        QVERIFY(screen);
        QPixmap grab = screen->grabWindow(menu.winId());
        QImage img = grab.toImage().convertToFormat(QImage::Format_ARGB32);

        // Crop to just the hovered item rect
        QImage itemImg = img.copy(itemRect);

        // Scan hovered item for amber pixels (E6B450 = R:230 G:180 B:80)
        int amberPixels = 0;
        int totalPixels = itemImg.width() * itemImg.height();
        for (int y = 0; y < itemImg.height(); ++y) {
            for (int x = 0; x < itemImg.width(); ++x) {
                QColor c = itemImg.pixelColor(x, y);
                if (c.red() > 180 && c.green() > 140 && c.blue() < 100)
                    ++amberPixels;
            }
        }

        // Always save screenshots so we can visually inspect
        img.save("menu_hover_full.png");
        itemImg.save("menu_hover_item.png");

        menu.close();

        QVERIFY2(amberPixels > 10,
                 qPrintable(QString("Expected amber text pixels in hovered item, "
                     "found %1 / %2 total (see menu_hover_full.png, menu_hover_item.png)")
                     .arg(amberPixels).arg(totalPixels)));
    }
    void testStructPreviewPopupOnCollapsedTypedPointer() {
        // Build a small tree: root struct with a typed Pointer64 → target struct
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.structTypeName = "TestRoot";
        root.name = "Root";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Target struct with some fields
        Node target;
        target.kind = NodeKind::Struct;
        target.structTypeName = "TargetStruct";
        target.name = "TargetStruct";
        target.parentId = 0;
        target.offset = 0;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        // Add fields to the target struct
        {
            Node f; f.parentId = targetId;
            f.kind = NodeKind::UInt64; f.name = "FieldA"; f.offset = 0;
            tree.addNode(f);
            f.kind = NodeKind::UInt64; f.name = "FieldB"; f.offset = 8;
            tree.addNode(f);
            f.kind = NodeKind::UInt32; f.name = "FieldC"; f.offset = 16;
            tree.addNode(f);
        }

        // Add a Pointer64 node that references the target struct, collapsed
        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "pTarget";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = true;
        tree.addNode(ptr);

        // Provider: 8 bytes at offset 0 holding a pointer value
        QByteArray data(64, '\0');
        uint64_t ptrVal = 0x00007FFE12340000ULL;
        memcpy(data.data(), &ptrVal, 8);
        BufferProvider prov(data, "test_struct_preview");

        ComposeResult cr = compose(tree, prov);
        m_editor->applyDocument(cr);
        m_editor->setProviderRef(&prov, nullptr, &tree);
        QApplication::processEvents();

        // Find the pointer line (should be a Pointer64 with foldCollapsed=true)
        int ptrLine = -1;
        for (int i = 0; i < cr.meta.size(); ++i) {
            if (cr.meta[i].nodeKind == NodeKind::Pointer64
                && cr.meta[i].foldCollapsed) {
                ptrLine = i;
                break;
            }
        }
        QVERIFY2(ptrLine >= 0, "Could not find collapsed Pointer64 line in compose output");

        // Simulate hover over the value column of the pointer line
        const LineMeta& lm = cr.meta[ptrLine];
        QString lineText;
        {
            long len = m_editor->scintilla()->SendScintilla(
                QsciScintillaBase::SCI_LINELENGTH, (unsigned long)ptrLine);
            QByteArray buf(len + 1, '\0');
            m_editor->scintilla()->SendScintilla(
                QsciScintillaBase::SCI_GETLINE, (uintptr_t)ptrLine, static_cast<const char*>(buf.data()));
            lineText = QString::fromUtf8(buf.left(len));
        }
        ColumnSpan vs = m_editor->valueSpan(lm, lineText.size(),
                                             lm.effectiveTypeW, lm.effectiveNameW);
        QVERIFY2(vs.valid, "Value span for pointer line is not valid");

        int hoverCol = (vs.start + vs.end) / 2;  // middle of value span
        QPoint vp = colToViewport(m_editor->scintilla(), ptrLine, hoverCol);
        sendMouseMove(m_editor->scintilla()->viewport(), vp);
        QApplication::processEvents();

        // Verify struct preview popup is shown
        QVERIFY2(m_editor->structPreviewPopup() != nullptr,
                 "Struct preview popup was not created");
        QVERIFY2(m_editor->structPreviewPopup()->isVisible(),
                 "Struct preview popup is not visible");

        // Restore original document for other tests
        m_editor->setProviderRef(nullptr, nullptr, nullptr);
        m_editor->applyDocument(m_result);
    }

    void testStructPreviewPopupNotShownWhenExpanded() {
        // Same tree but pointer is NOT collapsed — popup should not show
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.structTypeName = "TestRoot";
        root.name = "Root";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node target;
        target.kind = NodeKind::Struct;
        target.structTypeName = "TargetStruct";
        target.name = "TargetStruct";
        target.parentId = 0;
        target.offset = 0;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        {
            Node f; f.parentId = targetId;
            f.kind = NodeKind::UInt64; f.name = "FieldA"; f.offset = 0;
            tree.addNode(f);
            f.kind = NodeKind::UInt64; f.name = "FieldB"; f.offset = 8;
            tree.addNode(f);
        }

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "pTarget";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.refId = targetId;
        ptr.collapsed = false;  // expanded
        tree.addNode(ptr);

        QByteArray data(64, '\0');
        uint64_t ptrVal = 0x00007FFE12340000ULL;
        memcpy(data.data(), &ptrVal, 8);
        BufferProvider prov(data, "test_struct_preview_expanded");

        ComposeResult cr = compose(tree, prov);
        m_editor->applyDocument(cr);
        m_editor->setProviderRef(&prov, nullptr, &tree);
        QApplication::processEvents();

        // Find the pointer line (should be Pointer64 and NOT collapsed)
        int ptrLine = -1;
        for (int i = 0; i < cr.meta.size(); ++i) {
            if (cr.meta[i].nodeKind == NodeKind::Pointer64) {
                ptrLine = i;
                break;
            }
        }
        QVERIFY2(ptrLine >= 0, "Could not find Pointer64 line in compose output");

        // Hover at a middle column on the pointer line — expanded pointer header
        // may not have a standard value span, but we just need to verify no popup
        int hoverCol = 40;  // somewhere in the middle of the line
        QPoint vp = colToViewport(m_editor->scintilla(), ptrLine, hoverCol);
        sendMouseMove(m_editor->scintilla()->viewport(), vp);
        QApplication::processEvents();

        // Struct preview popup should NOT be visible (pointer is expanded)
        bool popupVisible = m_editor->structPreviewPopup()
                            && m_editor->structPreviewPopup()->isVisible();
        QVERIFY2(!popupVisible,
                 "Struct preview popup should not appear for expanded pointer");

        // Restore
        m_editor->setProviderRef(nullptr, nullptr, nullptr);
        m_editor->applyDocument(m_result);
    }

    // ── Test: expanded pointer renders child fields from buffer ──
    void testPointerExpansionRendersChildren() {
        PtrDemo d = makePtrDemo(/*collapsed=*/false);
        ComposeResult cr = compose(d.tree, d.prov);
        m_editor->applyDocument(cr);
        QApplication::processEvents();

        // Find the pointer header line
        int ptrHeaderLine = -1;
        for (int i = 0; i < cr.meta.size(); ++i) {
            if (cr.meta[i].nodeKind == NodeKind::Pointer64
                && cr.meta[i].foldHead && !cr.meta[i].foldCollapsed) {
                ptrHeaderLine = i;
                break;
            }
        }
        QVERIFY2(ptrHeaderLine >= 0, "Should have an expanded Pointer64 header");
        QCOMPARE(cr.meta[ptrHeaderLine].lineKind, LineKind::Header);

        // Find expanded child fields (x, y, z at depth = header depth + 1)
        int headerDepth = cr.meta[ptrHeaderLine].depth;
        int childFieldCount = 0;
        for (int i = ptrHeaderLine + 1; i < cr.meta.size(); ++i) {
            const LineMeta& lm = cr.meta[i];
            if (lm.depth == headerDepth + 1 && lm.lineKind == LineKind::Field)
                childFieldCount++;
            if (lm.lineKind == LineKind::Footer && lm.nodeKind == NodeKind::Pointer64)
                break; // reached pointer footer
        }
        QCOMPARE(childFieldCount, 3); // x, y, z

        // Find the pointer footer line
        int ptrFooterLine = -1;
        for (int i = ptrHeaderLine + 1; i < cr.meta.size(); ++i) {
            if (cr.meta[i].lineKind == LineKind::Footer
                && cr.meta[i].nodeKind == NodeKind::Pointer64) {
                ptrFooterLine = i;
                break;
            }
        }
        QVERIFY2(ptrFooterLine > ptrHeaderLine, "Should have a pointer footer after header");

        // Verify the composed text contains the child field values
        // UInt32 displays as hex (e.g. 100 → "0x00000064"), Float as decimal
        QStringList lines = cr.text.split('\n');
        bool foundX = false, foundY = false, foundZ = false;
        for (const QString& line : lines) {
            if (line.contains("0x64") && line.contains("x")) foundX = true;  // 100 = 0x64
            if (line.contains("0xc8") && line.contains("y")) foundY = true;  // 200 = 0xc8
            if (line.contains("3.14") && line.contains("z")) foundZ = true;
        }
        QVERIFY2(foundX, "Child field 'x' with value 0x64 should appear in output");
        QVERIFY2(foundY, "Child field 'y' with value 0xc8 should appear in output");
        QVERIFY2(foundZ, "Child field 'z' with value 3.14 should appear in output");

        // Verify the pointer type name appears
        QVERIFY2(cr.text.contains("ChildData*"),
                 "Pointer type 'ChildData*' should appear in output");

        // Editor should have rendered all lines
        int editorLineCount = m_editor->scintilla()->lines();
        QVERIFY2(editorLineCount >= cr.meta.size(),
                 qPrintable(QString("Editor has %1 lines but compose has %2 meta entries")
                     .arg(editorLineCount).arg(cr.meta.size())));

        m_editor->applyDocument(m_result);
    }

    // ── Test: collapsed pointer hides child fields ──
    void testPointerCollapsedHidesChildren() {
        PtrDemo expanded = makePtrDemo(/*collapsed=*/false);
        ComposeResult crExpanded = compose(expanded.tree, expanded.prov);

        PtrDemo collapsed = makePtrDemo(/*collapsed=*/true);
        ComposeResult crCollapsed = compose(collapsed.tree, collapsed.prov);

        // Collapsed should have fewer lines (no child fields, no pointer footer)
        QVERIFY2(crCollapsed.meta.size() < crExpanded.meta.size(),
                 qPrintable(QString("Collapsed (%1 lines) should be smaller than expanded (%2)")
                     .arg(crCollapsed.meta.size()).arg(crExpanded.meta.size())));

        // The pointer line should be a Field (not Header) with foldCollapsed=true
        bool foundCollapsedPtr = false;
        for (const LineMeta& lm : crCollapsed.meta) {
            if (lm.nodeKind == NodeKind::Pointer64 && lm.foldHead) {
                QVERIFY(lm.foldCollapsed);
                QCOMPARE(lm.lineKind, LineKind::Field);
                foundCollapsedPtr = true;
                break;
            }
        }
        QVERIFY2(foundCollapsedPtr, "Should have a collapsed Pointer64 fold head");

        // No child fields from ChildData should appear in the main struct section
        bool foundChildField = false;
        for (const LineMeta& lm : crCollapsed.meta) {
            if (lm.lineKind == LineKind::Footer && lm.nodeKind == NodeKind::Pointer64) {
                foundChildField = true; // pointer footer exists = children visible
                break;
            }
        }
        QVERIFY2(!foundChildField,
                 "Collapsed pointer should not have a pointer footer (no children)");

        // Apply collapsed to editor
        m_editor->applyDocument(crCollapsed);
        QApplication::processEvents();

        int collapsedLines = m_editor->scintilla()->lines();
        m_editor->applyDocument(crExpanded);
        QApplication::processEvents();
        int expandedLines = m_editor->scintilla()->lines();

        QVERIFY2(collapsedLines < expandedLines,
                 qPrintable(QString("Collapsed (%1 editor lines) should be fewer than expanded (%2)")
                     .arg(collapsedLines).arg(expandedLines)));

        m_editor->applyDocument(m_result);
    }

    // ── Test: null pointer still shows template fields (via NullProvider) ──
    void testPointerNullShowsTemplate() {
        PtrDemo d = makePtrDemo(/*collapsed=*/false, /*nullPtr=*/true);
        ComposeResult cr = compose(d.tree, d.prov);
        m_editor->applyDocument(cr);
        QApplication::processEvents();

        // Even with null pointer, expanded pointer should show template children
        int ptrHeaderLine = -1;
        for (int i = 0; i < cr.meta.size(); ++i) {
            if (cr.meta[i].nodeKind == NodeKind::Pointer64
                && cr.meta[i].foldHead && !cr.meta[i].foldCollapsed) {
                ptrHeaderLine = i;
                break;
            }
        }
        QVERIFY2(ptrHeaderLine >= 0,
                 "Null pointer should still produce an expanded header");

        // Should have child field lines (template from NullProvider shows zeros)
        int headerDepth = cr.meta[ptrHeaderLine].depth;
        int childFieldCount = 0;
        for (int i = ptrHeaderLine + 1; i < cr.meta.size(); ++i) {
            const LineMeta& lm = cr.meta[i];
            if (lm.depth == headerDepth + 1 && lm.lineKind == LineKind::Field)
                childFieldCount++;
            if (lm.lineKind == LineKind::Footer && lm.nodeKind == NodeKind::Pointer64)
                break;
        }
        QCOMPARE(childFieldCount, 3); // x, y, z template still rendered

        // Verify ChildData* appears in output
        QVERIFY2(cr.text.contains("ChildData*"),
                 "Null pointer should still show 'ChildData*' type");

        m_editor->applyDocument(m_result);
    }

    // ── Test: nested pointer chain renders multiple expansion levels ──
    void testPointerChainExpansion() {
        NodeTree tree;
        tree.baseAddress = 0;

        // Root struct
        Node root;
        root.kind = NodeKind::Struct;
        root.structTypeName = "Chain";
        root.name = "chain";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Inner struct (innermost target)
        Node inner;
        inner.kind = NodeKind::Struct;
        inner.structTypeName = "Inner";
        inner.name = "Inner";
        inner.parentId = 0;
        inner.offset = 300;
        int ii = tree.addNode(inner);
        uint64_t innerId = tree.nodes[ii].id;
        {
            Node f;
            f.kind = NodeKind::UInt32; f.name = "value";
            f.parentId = innerId; f.offset = 0;
            tree.addNode(f);
        }

        // Outer struct (contains pointer to Inner)
        Node outer;
        outer.kind = NodeKind::Struct;
        outer.structTypeName = "Outer";
        outer.name = "Outer";
        outer.parentId = 0;
        outer.offset = 200;
        int oi = tree.addNode(outer);
        uint64_t outerId = tree.nodes[oi].id;
        {
            Node f;
            f.kind = NodeKind::UInt32; f.name = "tag";
            f.parentId = outerId; f.offset = 0;
            tree.addNode(f);

            Node p;
            p.kind = NodeKind::Pointer64; p.name = "pInner";
            p.parentId = outerId; p.offset = 8;
            p.refId = innerId;
            tree.addNode(p);
        }

        // Root pointer to Outer
        {
            Node p;
            p.kind = NodeKind::Pointer64; p.name = "pOuter";
            p.parentId = rootId; p.offset = 0;
            p.refId = outerId;
            tree.addNode(p);
        }

        // Buffer: pOuter at 0 → 32, pInner at 32+8=40 → 64, value at 64 = 999
        QByteArray data(128, '\0');
        uint64_t pOuter = 32;  memcpy(data.data() + 0,  &pOuter, 8);
        uint64_t pInner = 64;  memcpy(data.data() + 40, &pInner, 8);
        uint32_t tag = 0xAB;   memcpy(data.data() + 32, &tag, 4);
        uint32_t val = 999;    memcpy(data.data() + 64, &val, 4);
        BufferProvider prov(data, "chain_demo");

        ComposeResult cr = compose(tree, prov);
        m_editor->applyDocument(cr);
        QApplication::processEvents();

        // Both Outer* and Inner* should appear
        QVERIFY2(cr.text.contains("Outer*"), "Should display 'Outer*' pointer type");
        QVERIFY2(cr.text.contains("Inner*"), "Should display 'Inner*' pointer type");

        // Count pointer fold heads — should have at least 2 (pOuter + pInner)
        int ptrFoldHeads = 0;
        int maxDepth = 0;
        for (const LineMeta& lm : cr.meta) {
            if (lm.foldHead && lm.nodeKind == NodeKind::Pointer64)
                ptrFoldHeads++;
            if (lm.depth > maxDepth) maxDepth = lm.depth;
        }
        QVERIFY2(ptrFoldHeads >= 2,
                 qPrintable(QString("Expected >=2 pointer fold heads, got %1")
                     .arg(ptrFoldHeads)));

        // Depth should reach at least 3 (root=0, pOuter children=1..2, pInner children=2..3)
        QVERIFY2(maxDepth >= 3,
                 qPrintable(QString("Expected max depth >= 3 for chain, got %1")
                     .arg(maxDepth)));

        // Verify innermost value (999 = 0x3e7) appears in the output
        QVERIFY2(cr.text.contains("0x3e7"),
                 "Innermost field 'value = 0x3e7' should appear in chain expansion");

        m_editor->applyDocument(m_result);
    }

    // ── Test: status bar view toggle buttons (pixel-level) ──
    void testStatusBarViewToggleButtons() {
        // Mirror the production ViewTabButton from main.cpp
        static constexpr int kAccentH = 2;
        static constexpr int kPadLR  = 12;
        static constexpr int kPadBot = 4;
        class VTB : public QPushButton {
        public:
            QColor colBg, colBgChecked, colBgHover, colBgPressed;
            QColor colText, colTextMuted, colAccent;
            explicit VTB(const QString& t, QWidget* p = nullptr) : QPushButton(t, p) {
                setCheckable(true); setFlat(true); setContentsMargins(0,0,0,0);
                setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Ignored);
            }
            QSize sizeHint() const override {
                QFontMetrics fm(font());
                return QSize(fm.horizontalAdvance(text()) + 2*kPadLR,
                             fm.height() + kAccentH + kPadBot);
            }
        protected:
            void paintEvent(QPaintEvent*) override {
                QPainter p(this);
                QColor bg = colBg;
                if (isDown())          bg = colBgPressed;
                else if (underMouse()) bg = colBgHover;
                else if (isChecked())  bg = colBgChecked;
                p.fillRect(rect(), bg);
                if (isChecked())
                    p.fillRect(0, 0, width(), kAccentH, colAccent);
                p.setPen(isChecked() || underMouse() || isDown() ? colText : colTextMuted);
                p.setFont(font());
                QRect tr(kPadLR, kAccentH, width()-2*kPadLR, height()-kAccentH);
                p.drawText(tr, Qt::AlignVCenter|Qt::AlignLeft, text());
            }
            void enterEvent(QEnterEvent*) override { update(); }
            void leaveEvent(QEvent*) override { update(); }
        };

        QColor bg(30,30,30), bgAlt(45,45,48), hover(62,62,66);
        QColor text(212,212,212), textMuted(128,128,128);
        QColor accent("#b180d7");
        QColor pressed = hover.darker(130);

        auto setColors = [&](VTB* b) {
            b->colBg = bg; b->colBgChecked = bgAlt; b->colBgHover = hover;
            b->colBgPressed = pressed; b->colText = text;
            b->colTextMuted = textMuted; b->colAccent = accent;
        };

        // Borderless status bar with manual layout (mirrors production FlatStatusBar)
        class FSB : public QStatusBar {
        public:
            QWidget* tabRow = nullptr;
            QLabel*  label  = nullptr;
            FSB() { setSizeGripEnabled(false); }
        protected:
            void paintEvent(QPaintEvent*) override {
                QPainter p(this); p.fillRect(rect(), palette().window());
            }
            void resizeEvent(QResizeEvent* e) override {
                QStatusBar::resizeEvent(e);
                doLayout();
            }
            void showEvent(QShowEvent* e) override {
                QStatusBar::showEvent(e);
                doLayout();
            }
        private:
            void doLayout() {
                if (!tabRow || !label) return;
                int h = height(), tw = tabRow->sizeHint().width();
                tabRow->setGeometry(0, 0, tw, h);
                label->setGeometry(tw, 0, width() - tw, h);
            }
        };

        QMainWindow win;
        win.resize(600, 400);
        QPalette pal; pal.setColor(QPalette::Window, bg);
        win.setPalette(pal);
        auto* sb = new FSB;
        win.setStatusBar(sb);
        sb->setPalette(pal);
        sb->setAutoFillBackground(true);
        if (win.layout()) {
            win.layout()->setSpacing(0);
            win.layout()->setContentsMargins(0,0,0,0);
        }

        auto* btnGroup = new QButtonGroup(&win);
        btnGroup->setExclusive(true);
        auto* btnR = new VTB("Reclass");
        auto* btnC = new VTB("C/C++");
        setColors(btnR); setColors(btnC);
        btnR->setChecked(true);
        btnGroup->addButton(btnR, 0);
        btnGroup->addButton(btnC, 1);
        auto* tabRow = new QWidget(sb);
        auto* tabLay = new QHBoxLayout(tabRow);
        tabLay->setContentsMargins(0,0,0,0);
        tabLay->setSpacing(0);
        tabLay->addWidget(btnR);
        tabLay->addWidget(btnC);
        auto* lbl = new QLabel("Ready", sb);
        lbl->setContentsMargins(10,0,0,0);
        sb->tabRow = tabRow;
        sb->label  = lbl;

        win.show();
        QVERIFY(QTest::qWaitForWindowExposed(&win));
        QTest::qWait(100);

        // ── Toggle logic ──
        QVERIFY(btnR->isChecked());
        QVERIFY(!btnC->isChecked());
        QTest::mouseClick(btnC, Qt::LeftButton);
        QVERIFY(btnC->isChecked());
        QVERIFY(!btnR->isChecked());
        QTest::mouseClick(btnR, Qt::LeftButton);
        QVERIFY(btnR->isChecked());
        QTest::qWait(50);

        // ── Pixel: accent line on checked button at rows 0..(kAccentH-1) ──
        QImage imgR = btnR->grab().toImage().convertToFormat(QImage::Format_ARGB32);
        QVERIFY(imgR.height() >= kAccentH + 4);

        // Every pixel in the top kAccentH rows (middle 80% width) must be accent
        int x0 = imgR.width() / 10, x1 = imgR.width() * 9 / 10;
        for (int y = 0; y < kAccentH; y++) {
            for (int x = x0; x < x1; x++) {
                QColor c(imgR.pixel(x, y));
                QVERIFY2(qAbs(c.red() - accent.red()) < 10
                      && qAbs(c.green() - accent.green()) < 10
                      && qAbs(c.blue() - accent.blue()) < 10,
                    qPrintable(QString("Checked btn pixel(%1,%2)=%3 expected accent %4")
                        .arg(x).arg(y).arg(c.name(), accent.name())));
            }
        }

        // Mid-height row must NOT be accent (accent doesn't bleed into body)
        {
            int midY = imgR.height() / 2;
            QColor c(imgR.pixel(imgR.width()/2, midY));
            QVERIFY2(qAbs(c.red() - accent.red()) > 15
                  || qAbs(c.green() - accent.green()) > 15
                  || qAbs(c.blue() - accent.blue()) > 15,
                qPrintable(QString("Row %1 should be background, not accent: %2")
                    .arg(midY).arg(c.name())));
        }

        // ── Pixel: unchecked button has NO accent line ──
        QImage imgC = btnC->grab().toImage().convertToFormat(QImage::Format_ARGB32);
        for (int y = 0; y < kAccentH; y++) {
            QColor c(imgC.pixel(imgC.width()/2, y));
            QVERIFY2(qAbs(c.red() - accent.red()) > 15
                  || qAbs(c.green() - accent.green()) > 15
                  || qAbs(c.blue() - accent.blue()) > 15,
                qPrintable(QString("Unchecked btn row %1 has accent: %2")
                    .arg(y).arg(c.name())));
        }

        // ── Pixel: zero gap between the two buttons ──
        // Map to their shared parent (the tabRow container)
        QWidget* container = btnR->parentWidget();
        int rRight = btnR->mapTo(container, QPoint(btnR->width(), 0)).x();
        int cLeft  = btnC->mapTo(container, QPoint(0, 0)).x();
        QVERIFY2(rRight == cLeft,
            qPrintable(QString("Gap between buttons: btnR right=%1 btnC left=%2 gap=%3")
                .arg(rRight).arg(cLeft).arg(cLeft - rRight)));

        // ── Pressed color is darker than hover ──
        QVERIFY2(pressed.lightness() < hover.lightness(),
            qPrintable(QString("Pressed %1 should be darker than hover %2")
                .arg(pressed.name(), hover.name())));

        // ── Button starts at x=0 in status bar (no left padding) ──
        QPoint btnTopLeft = tabRow->mapTo(sb, QPoint(0, 0));
        QVERIFY2(btnTopLeft.x() == 0,
            qPrintable(QString("Tab row left margin: x=%1, expected 0").arg(btnTopLeft.x())));

        // ── Button starts at y=0 in status bar (no top padding) ──
        QVERIFY2(btnTopLeft.y() == 0,
            qPrintable(QString("Tab row top margin: y=%1, expected 0").arg(btnTopLeft.y())));

        // ── Button takes full status bar height ──
        QVERIFY2(btnR->height() == sb->height(),
            qPrintable(QString("Button height=%1 sb height=%2")
                .arg(btnR->height()).arg(sb->height())));

        // ── Accent at y=0 in status bar pixel coordinates (grab status bar) ──
        QImage sbImg = sb->grab().toImage().convertToFormat(QImage::Format_ARGB32);
        {
            QColor c(sbImg.pixel(btnR->width()/2, 0));
            QVERIFY2(qAbs(c.red() - accent.red()) < 10
                  && qAbs(c.green() - accent.green()) < 10
                  && qAbs(c.blue() - accent.blue()) < 10,
                qPrintable(QString("Status bar pixel(x,%1,0)=%2 expected accent %3")
                    .arg(btnR->width()/2).arg(c.name(), accent.name())));
        }

        qDebug() << QString("ViewTabButton: accent=%1 btnH=%2 sbH=%3 gap=%4 leftX=%5 topY=%6")
            .arg(accent.name()).arg(btnR->height()).arg(sb->height())
            .arg(cLeft - rRight).arg(btnTopLeft.x()).arg(btnTopLeft.y());
    }

    // ── Test: resize grip dots are equidistant from right and bottom window edges ──
    // The grip is a direct child of the window positioned via move(), not inside
    // the status bar layout. This test verifies the dot placement is symmetric
    // regardless of font, and runs the check at two different font sizes to prove
    // font independence.
    // ── Test: horizontal scrollbar after long name rename ──
    void testHScrollResetAfterNameShrink() {
        // Use a dedicated narrow editor so content easily overflows the viewport
        auto* editor = new RcxEditor();
        editor->resize(200, 300);
        editor->show();
        QVERIFY(QTest::qWaitForWindowExposed(editor));
        auto* sci = editor->scintilla();
        auto* hbar = sci->horizontalScrollBar();

        auto makeTree = [](const QString& fieldName) {
            NodeTree tree;
            tree.baseAddress = 0;
            Node root;
            root.kind = NodeKind::Struct;
            root.structTypeName = "MyStruct";
            root.name = "s";
            root.parentId = 0;
            root.offset = 0;
            int ri = tree.addNode(root);
            uint64_t rootId = tree.nodes[ri].id;

            Node f;
            f.kind = NodeKind::Int32;
            f.name = fieldName;
            f.parentId = rootId;
            f.offset = 0;
            tree.addNode(f);
            return tree;
        };

        BufferProvider prov(QByteArray(64, '\0'));

        // ── Step 1: long name → wide content, scrollbar must appear ──
        QString longName = QString(120, QChar('W'));
        {
            NodeTree tree = makeTree(longName);
            ComposeResult cr = compose(tree, prov);
            editor->applyDocument(cr);
            QApplication::processEvents();
            QTest::qWait(50);
        }

        int scrollW1 = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETSCROLLWIDTH);
        int viewW    = sci->viewport()->width();

        qDebug() << QString("Long name: scrollW=%1 vpW=%2 hbar.visible=%3 "
                            "hbar.max=%4 hbar.value=%5")
                        .arg(scrollW1).arg(viewW)
                        .arg(hbar->isVisible())
                        .arg(hbar->maximum()).arg(hbar->value());

        QVERIFY2(scrollW1 > viewW,
                 qPrintable(QString("scrollW=%1 should exceed vpW=%2")
                     .arg(scrollW1).arg(viewW)));

        // Scrollbar must be visible when content overflows
        QVERIFY2(hbar->isVisible(),
                 "Horizontal scrollbar should be visible when content overflows");
        QVERIFY2(hbar->maximum() > 0,
                 qPrintable(QString("Scrollbar max should be >0, got %1")
                     .arg(hbar->maximum())));

        // Simulate user scrolled right
        sci->SendScintilla(QsciScintillaBase::SCI_SETXOFFSET, (unsigned long)(scrollW1 / 2));
        QApplication::processEvents();
        QTest::qWait(20);
        int xOff1 = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETXOFFSET);
        QVERIFY2(xOff1 > 0, "X offset should be non-zero after scrolling right");

        // ── Step 2: short name → narrower content ──
        {
            NodeTree tree = makeTree("x");
            ComposeResult cr = compose(tree, prov);
            editor->applyDocument(cr);
            QApplication::processEvents();
            QTest::qWait(50);
        }

        int scrollW2 = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETSCROLLWIDTH);
        int xOff2    = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETXOFFSET);

        qDebug() << QString("Short name: scrollW=%1 xOff=%2 vpW=%3 hbar.visible=%4 "
                            "hbar.max=%5 hbar.value=%6")
                        .arg(scrollW2).arg(xOff2).arg(viewW)
                        .arg(hbar->isVisible())
                        .arg(hbar->maximum()).arg(hbar->value());

        // Scroll width should have shrunk
        QVERIFY2(scrollW2 < scrollW1,
                 qPrintable(QString("scrollW should shrink: was %1, now %2")
                     .arg(scrollW1).arg(scrollW2)));

        // X offset must be clamped to max(0, scrollW - viewportW)
        int maxValidXOff = qMax(0, scrollW2 - viewW);
        QVERIFY2(xOff2 <= maxValidXOff,
                 qPrintable(QString("xOffset=%1 exceeds max valid=%2 (scrollW=%3 vpW=%4)")
                     .arg(xOff2).arg(maxValidXOff).arg(scrollW2).arg(viewW)));

        // If content fits viewport entirely, offset must be 0
        if (scrollW2 <= viewW) {
            QCOMPARE(xOff2, 0);
        }

        // If content still overflows, scrollbar must still be visible
        if (scrollW2 > viewW) {
            QVERIFY2(hbar->isVisible(),
                     "Scrollbar should remain visible when content still overflows");
        }

        // ── Step 3: apply long name again → scrollbar must reappear ──
        {
            NodeTree tree = makeTree(longName);
            ComposeResult cr = compose(tree, prov);
            editor->applyDocument(cr);
            QApplication::processEvents();
            QTest::qWait(50);
        }

        int scrollW3 = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETSCROLLWIDTH);
        int xOff3    = (int)sci->SendScintilla(QsciScintillaBase::SCI_GETXOFFSET);

        qDebug() << QString("Long again: scrollW=%1 xOff=%2 hbar.visible=%3 hbar.max=%4")
                        .arg(scrollW3).arg(xOff3)
                        .arg(hbar->isVisible()).arg(hbar->maximum());

        QVERIFY2(scrollW3 > viewW,
                 qPrintable(QString("scrollW=%1 should exceed vpW=%2 after re-widen")
                     .arg(scrollW3).arg(viewW)));
        QVERIFY2(hbar->isVisible(),
                 "Scrollbar must reappear after content widens again");
        // After fresh apply with no prior scroll, xOffset should be 0
        QCOMPARE(xOff3, 0);

        delete editor;
    }

    void testResizeGripCornerSymmetry() {
        // Same constants as production ResizeGrip in main.cpp
        static constexpr int kSize = 16;
        static constexpr int kPad  = 4;
        static constexpr double kInset = 4.0;

        class Grip : public QWidget {
        public:
            explicit Grip(QWidget* p) : QWidget(p) { setFixedSize(kSize, kSize); }
            void reposition() {
                if (auto* w = parentWidget())
                    move(w->width() - kSize - kPad, w->height() - kSize - kPad);
            }
        protected:
            void paintEvent(QPaintEvent*) override {
                QPainter p(this);
                p.setRenderHint(QPainter::Antialiasing);
                p.setPen(Qt::NoPen);
                p.setBrush(Qt::red);
                const double r = 1.0, s = 4.0;
                double bx = width()  - kInset;
                double by = height() - kInset;
                p.drawEllipse(QPointF(bx,         by), r, r);
                p.drawEllipse(QPointF(bx - s,     by), r, r);
                p.drawEllipse(QPointF(bx - 2 * s, by), r, r);
                p.drawEllipse(QPointF(bx,         by - s), r, r);
                p.drawEllipse(QPointF(bx - s,     by - s), r, r);
                p.drawEllipse(QPointF(bx,         by - 2 * s), r, r);
            }
        };

        // Helper: grab window, find bottommost-rightmost red pixel, measure gaps
        auto measureGaps = [](QWidget* win, int& gapRight, int& gapBottom) -> bool {
            QPixmap px = win->grab();
            QImage img = px.toImage().convertToFormat(QImage::Format_ARGB32);
            int W = img.width(), H = img.height();
            if (W < 50 || H < 50) return false;

            int foundX = -1, foundY = -1;
            for (int y = H - 1; y >= H - 40 && foundY < 0; --y) {
                for (int x = W - 1; x >= W - 40; --x) {
                    QColor c(img.pixel(x, y));
                    if (c.red() > 180 && c.green() < 80 && c.blue() < 80) {
                        foundX = x; foundY = y; break;
                    }
                }
            }
            if (foundX < 0) return false;
            gapRight  = (W - 1) - foundX;
            gapBottom = (H - 1) - foundY;

            // Save diagnostic image
            QImage diag = img.copy();
            QPainter dp(&diag);
            dp.setPen(QPen(Qt::cyan, 1));
            dp.drawRect(foundX - 3, foundY - 3, 6, 6);
            dp.setPen(QPen(Qt::yellow, 1));
            dp.drawLine(foundX, foundY, W - 1, foundY);
            dp.drawLine(foundX, foundY, foundX, H - 1);
            dp.end();
            diag.save("grip_corner_diag.png");
            return true;
        };

        // --- Round 1: default system font ---
        QMainWindow win;
        win.resize(500, 375);

        QPalette pal;
        pal.setColor(QPalette::Window, QColor(30, 30, 30));
        win.setPalette(pal);
        win.statusBar()->setPalette(pal);
        win.statusBar()->setAutoFillBackground(true);

        auto* grip = new Grip(&win);
        grip->raise();

        win.show();
        QVERIFY(QTest::qWaitForWindowExposed(&win));
        grip->reposition();
        QTest::qWait(100);

        int gapR1 = 0, gapB1 = 0;
        QVERIFY2(measureGaps(&win, gapR1, gapB1),
                 "Could not find red grip dot (round 1)");
        QVERIFY2(gapR1 == gapB1,
                 qPrintable(QString("Round 1 asymmetric: gapRight=%1 gapBottom=%2")
                     .arg(gapR1).arg(gapB1)));

        // --- Round 2: large font on status bar (must NOT change grip position) ---
        QFont bigFont("Arial", 24);
        win.statusBar()->setFont(bigFont);
        QTest::qWait(100);
        grip->reposition();
        QTest::qWait(100);

        int gapR2 = 0, gapB2 = 0;
        QVERIFY2(measureGaps(&win, gapR2, gapB2),
                 "Could not find red grip dot (round 2, big font)");
        QVERIFY2(gapR2 == gapB2,
                 qPrintable(QString("Round 2 asymmetric: gapRight=%1 gapBottom=%2")
                     .arg(gapR2).arg(gapB2)));

        // Gaps must be identical across both font sizes
        QVERIFY2(gapR1 == gapR2 && gapB1 == gapB2,
                 qPrintable(QString("Font changed grip position: "
                     "round1=(%1,%2) round2=(%3,%4)")
                     .arg(gapR1).arg(gapB1).arg(gapR2).arg(gapB2)));

        qDebug() << "Grip corner symmetry:"
                 << QString("gapRight=%1 gapBottom=%2 (font-independent)")
                    .arg(gapR1).arg(gapB1);
    }
};

QTEST_MAIN(TestEditor)
#include "test_editor.moc"

```

`tests/test_export_xml.cpp`:

```cpp
#include <QtTest/QtTest>
#include <QTemporaryFile>
#include "core.h"
#include "imports/export_reclass_xml.h"
#include "imports/import_reclass_xml.h"

using namespace rcx;

class TestExportXml : public QObject {
    Q_OBJECT
private slots:
    void exportEmptyTree();
    void exportSingleStruct();
    void exportPointerRef();
    void exportEmbeddedStruct();
    void exportArray();
    void exportTextNodes();
    void exportVectors();
    void exportHexCollapse();
    void exportMultiClass();
    void roundTripImportExport();
};

static int countRoots(const NodeTree& tree) {
    int n = 0;
    for (const auto& node : tree.nodes)
        if (node.parentId == 0 && node.kind == NodeKind::Struct) n++;
    return n;
}

static QVector<int> childrenOf(const NodeTree& tree, uint64_t parentId) {
    QVector<int> result;
    for (int i = 0; i < tree.nodes.size(); i++)
        if (tree.nodes[i].parentId == parentId) result.append(i);
    return result;
}

static QString exportToString(const NodeTree& tree) {
    QTemporaryFile tmp;
    tmp.setAutoRemove(true);
    if (!tmp.open()) return {};
    QString path = tmp.fileName();
    tmp.close();

    QString err;
    if (!exportReclassXml(tree, path, &err)) return {};

    QFile f(path);
    if (!f.open(QIODevice::ReadOnly | QIODevice::Text)) return {};
    return QString::fromUtf8(f.readAll());
}

static NodeTree roundTrip(const NodeTree& tree) {
    QTemporaryFile tmp;
    tmp.setAutoRemove(true);
    if (!tmp.open()) return {};
    QString path = tmp.fileName();
    tmp.close();

    QString err;
    if (!exportReclassXml(tree, path, &err)) return {};
    return importReclassXml(path, &err);
}

// ── Tests ──

void TestExportXml::exportEmptyTree() {
    NodeTree tree;
    QString err;
    QVERIFY(!exportReclassXml(tree, "dummy.xml", &err));
    QVERIFY(!err.isEmpty());
}

void TestExportXml::exportSingleStruct() {
    NodeTree tree;
    Node s; s.kind = NodeKind::Struct; s.name = QStringLiteral("Player");
    s.structTypeName = QStringLiteral("Player"); s.parentId = 0;
    int si = tree.addNode(s);
    uint64_t sid = tree.nodes[si].id;

    Node f1; f1.kind = NodeKind::Int32; f1.name = QStringLiteral("health");
    f1.parentId = sid; f1.offset = 0; tree.addNode(f1);

    Node f2; f2.kind = NodeKind::Float; f2.name = QStringLiteral("speed");
    f2.parentId = sid; f2.offset = 4; tree.addNode(f2);

    Node f3; f3.kind = NodeKind::UInt64; f3.name = QStringLiteral("id");
    f3.parentId = sid; f3.offset = 8; tree.addNode(f3);

    QString xml = exportToString(tree);
    QVERIFY(!xml.isEmpty());
    QVERIFY(xml.contains(QStringLiteral("Player")));
    QVERIFY(xml.contains(QStringLiteral("health")));
    QVERIFY(xml.contains(QStringLiteral("speed")));
    QVERIFY(xml.contains(QStringLiteral("ReClassEx")));

    // Round-trip
    NodeTree rt = roundTrip(tree);
    QCOMPARE(countRoots(rt), 1);
    QCOMPARE(rt.nodes[0].name, QStringLiteral("Player"));
    auto kids = childrenOf(rt, rt.nodes[0].id);
    QCOMPARE(kids.size(), 3);
    QCOMPARE(rt.nodes[kids[0]].kind, NodeKind::Int32);
    QCOMPARE(rt.nodes[kids[1]].kind, NodeKind::Float);
    QCOMPARE(rt.nodes[kids[2]].kind, NodeKind::UInt64);
}

void TestExportXml::exportPointerRef() {
    NodeTree tree;
    Node s1; s1.kind = NodeKind::Struct; s1.name = QStringLiteral("Target");
    s1.structTypeName = QStringLiteral("Target"); s1.parentId = 0;
    int s1i = tree.addNode(s1);
    uint64_t s1id = tree.nodes[s1i].id;

    Node f; f.kind = NodeKind::Int32; f.name = QStringLiteral("val");
    f.parentId = s1id; f.offset = 0; tree.addNode(f);

    Node s2; s2.kind = NodeKind::Struct; s2.name = QStringLiteral("HasPtr");
    s2.structTypeName = QStringLiteral("HasPtr"); s2.parentId = 0;
    int s2i = tree.addNode(s2);
    uint64_t s2id = tree.nodes[s2i].id;

    Node ptr; ptr.kind = NodeKind::Pointer64; ptr.name = QStringLiteral("pTarget");
    ptr.parentId = s2id; ptr.offset = 0; ptr.refId = s1id;
    tree.addNode(ptr);

    QString xml = exportToString(tree);
    QVERIFY(xml.contains(QStringLiteral("Pointer=\"Target\"")));

    // Round-trip: pointer should resolve
    NodeTree rt = roundTrip(tree);
    QCOMPARE(countRoots(rt), 2);
    bool foundPtr = false;
    for (const auto& n : rt.nodes) {
        if (n.kind == NodeKind::Pointer64 && n.name == QStringLiteral("pTarget")) {
            QVERIFY(n.refId != 0);
            foundPtr = true;
        }
    }
    QVERIFY(foundPtr);
}

void TestExportXml::exportEmbeddedStruct() {
    NodeTree tree;
    Node inner; inner.kind = NodeKind::Struct; inner.name = QStringLiteral("Inner");
    inner.structTypeName = QStringLiteral("Inner"); inner.parentId = 0;
    int ii = tree.addNode(inner);
    uint64_t iid = tree.nodes[ii].id;

    Node iv; iv.kind = NodeKind::Int32; iv.name = QStringLiteral("x");
    iv.parentId = iid; iv.offset = 0; tree.addNode(iv);

    Node outer; outer.kind = NodeKind::Struct; outer.name = QStringLiteral("Outer");
    outer.structTypeName = QStringLiteral("Outer"); outer.parentId = 0;
    int oi = tree.addNode(outer);
    uint64_t oid = tree.nodes[oi].id;

    Node embed; embed.kind = NodeKind::Struct; embed.name = QStringLiteral("embedded");
    embed.structTypeName = QStringLiteral("Inner"); embed.parentId = oid;
    embed.offset = 0; embed.refId = iid;
    tree.addNode(embed);

    QString xml = exportToString(tree);
    QVERIFY(xml.contains(QStringLiteral("Instance=\"Inner\"")));
}

void TestExportXml::exportArray() {
    NodeTree tree;
    Node s; s.kind = NodeKind::Struct; s.name = QStringLiteral("Container");
    s.structTypeName = QStringLiteral("Container"); s.parentId = 0;
    int si = tree.addNode(s);
    uint64_t sid = tree.nodes[si].id;

    Node arr; arr.kind = NodeKind::Array; arr.name = QStringLiteral("items");
    arr.parentId = sid; arr.offset = 0; arr.arrayLen = 10;
    arr.elementKind = NodeKind::Int32;
    tree.addNode(arr);

    QString xml = exportToString(tree);
    QVERIFY(xml.contains(QStringLiteral("Total=\"10\"")));
    QVERIFY(xml.contains(QStringLiteral("<Array")));
}

void TestExportXml::exportTextNodes() {
    NodeTree tree;
    Node s; s.kind = NodeKind::Struct; s.name = QStringLiteral("TextStruct");
    s.structTypeName = QStringLiteral("TextStruct"); s.parentId = 0;
    int si = tree.addNode(s);
    uint64_t sid = tree.nodes[si].id;

    Node u8; u8.kind = NodeKind::UTF8; u8.name = QStringLiteral("name");
    u8.parentId = sid; u8.offset = 0; u8.strLen = 32; tree.addNode(u8);

    Node u16; u16.kind = NodeKind::UTF16; u16.name = QStringLiteral("wname");
    u16.parentId = sid; u16.offset = 32; u16.strLen = 16; tree.addNode(u16);

    NodeTree rt = roundTrip(tree);
    QCOMPARE(countRoots(rt), 1);
    auto kids = childrenOf(rt, rt.nodes[0].id);
    QCOMPARE(kids.size(), 2);
    QCOMPARE(rt.nodes[kids[0]].kind, NodeKind::UTF8);
    QCOMPARE(rt.nodes[kids[0]].strLen, 32);
    QCOMPARE(rt.nodes[kids[1]].kind, NodeKind::UTF16);
    QCOMPARE(rt.nodes[kids[1]].strLen, 16);
}

void TestExportXml::exportVectors() {
    NodeTree tree;
    Node s; s.kind = NodeKind::Struct; s.name = QStringLiteral("Vectors");
    s.structTypeName = QStringLiteral("Vectors"); s.parentId = 0;
    int si = tree.addNode(s);
    uint64_t sid = tree.nodes[si].id;

    Node v2; v2.kind = NodeKind::Vec2; v2.name = QStringLiteral("pos2");
    v2.parentId = sid; v2.offset = 0; tree.addNode(v2);

    Node v3; v3.kind = NodeKind::Vec3; v3.name = QStringLiteral("pos3");
    v3.parentId = sid; v3.offset = 8; tree.addNode(v3);

    Node v4; v4.kind = NodeKind::Vec4; v4.name = QStringLiteral("rot");
    v4.parentId = sid; v4.offset = 20; tree.addNode(v4);

    Node m; m.kind = NodeKind::Mat4x4; m.name = QStringLiteral("matrix");
    m.parentId = sid; m.offset = 36; tree.addNode(m);

    NodeTree rt = roundTrip(tree);
    auto kids = childrenOf(rt, rt.nodes[0].id);
    QCOMPARE(kids.size(), 4);
    QCOMPARE(rt.nodes[kids[0]].kind, NodeKind::Vec2);
    QCOMPARE(rt.nodes[kids[1]].kind, NodeKind::Vec3);
    QCOMPARE(rt.nodes[kids[2]].kind, NodeKind::Vec4);
    QCOMPARE(rt.nodes[kids[3]].kind, NodeKind::Mat4x4);
}

void TestExportXml::exportHexCollapse() {
    NodeTree tree;
    Node s; s.kind = NodeKind::Struct; s.name = QStringLiteral("HexTest");
    s.structTypeName = QStringLiteral("HexTest"); s.parentId = 0;
    int si = tree.addNode(s);
    uint64_t sid = tree.nodes[si].id;

    // 4 consecutive Hex8 nodes should collapse to one Custom node
    for (int i = 0; i < 4; i++) {
        Node h; h.kind = NodeKind::Hex8; h.parentId = sid; h.offset = i;
        tree.addNode(h);
    }
    // Followed by a real field
    Node f; f.kind = NodeKind::Int32; f.name = QStringLiteral("val");
    f.parentId = sid; f.offset = 4; tree.addNode(f);

    QString xml = exportToString(tree);
    // Should have Type="21" (Custom) for the collapsed hex
    QVERIFY(xml.contains(QStringLiteral("Type=\"21\"")));
    // Size should be 4
    QVERIFY(xml.contains(QStringLiteral("Size=\"4\"")));

    // Round-trip: custom expands back to hex nodes
    NodeTree rt = roundTrip(tree);
    QCOMPARE(countRoots(rt), 1);
    auto kids = childrenOf(rt, rt.nodes[0].id);
    // Import expands Custom(4 bytes) to best-fit hex: Hex32 (1 node) + Int32 = 2
    QVERIFY(kids.size() >= 2);
    // Last child should be Int32
    QCOMPARE(rt.nodes[kids.last()].kind, NodeKind::Int32);
}

void TestExportXml::exportMultiClass() {
    NodeTree tree;
    for (int c = 0; c < 5; c++) {
        Node s; s.kind = NodeKind::Struct;
        s.name = QStringLiteral("Class%1").arg(c);
        s.structTypeName = s.name; s.parentId = 0;
        int si = tree.addNode(s);
        uint64_t sid = tree.nodes[si].id;

        Node f; f.kind = NodeKind::Int32;
        f.name = QStringLiteral("field%1").arg(c);
        f.parentId = sid; f.offset = 0; tree.addNode(f);
    }

    NodeTree rt = roundTrip(tree);
    QCOMPARE(countRoots(rt), 5);

    // All class names preserved
    QSet<QString> names;
    for (const auto& n : rt.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) names.insert(n.name);
    for (int c = 0; c < 5; c++)
        QVERIFY(names.contains(QStringLiteral("Class%1").arg(c)));
}

void TestExportXml::roundTripImportExport() {
    // Build a comprehensive tree and verify it survives export->import
    NodeTree tree;

    Node s; s.kind = NodeKind::Struct; s.name = QStringLiteral("FullTest");
    s.structTypeName = QStringLiteral("FullTest"); s.parentId = 0;
    int si = tree.addNode(s);
    uint64_t sid = tree.nodes[si].id;

    int offset = 0;
    auto addField = [&](NodeKind kind, const QString& name) {
        Node n; n.kind = kind; n.name = name; n.parentId = sid; n.offset = offset;
        tree.addNode(n);
        offset += sizeForKind(kind);
    };

    addField(NodeKind::Int8, QStringLiteral("a"));
    addField(NodeKind::Int16, QStringLiteral("b"));
    addField(NodeKind::Int32, QStringLiteral("c"));
    addField(NodeKind::Int64, QStringLiteral("d"));
    addField(NodeKind::UInt8, QStringLiteral("e"));
    addField(NodeKind::UInt16, QStringLiteral("f"));
    addField(NodeKind::UInt32, QStringLiteral("g"));
    addField(NodeKind::UInt64, QStringLiteral("h"));
    addField(NodeKind::Float, QStringLiteral("i"));
    addField(NodeKind::Double, QStringLiteral("j"));
    addField(NodeKind::Vec2, QStringLiteral("k"));
    addField(NodeKind::Vec3, QStringLiteral("l"));
    addField(NodeKind::Vec4, QStringLiteral("m"));

    // Self-pointer
    Node ptr; ptr.kind = NodeKind::Pointer64; ptr.name = QStringLiteral("self");
    ptr.parentId = sid; ptr.offset = offset; ptr.refId = sid;
    tree.addNode(ptr);
    offset += 8;

    // UTF8
    Node u8; u8.kind = NodeKind::UTF8; u8.name = QStringLiteral("str");
    u8.parentId = sid; u8.offset = offset; u8.strLen = 64;
    tree.addNode(u8);

    NodeTree rt = roundTrip(tree);
    QCOMPARE(countRoots(rt), 1);
    QCOMPARE(rt.nodes[0].name, QStringLiteral("FullTest"));

    auto origKids = childrenOf(tree, sid);
    auto rtKids = childrenOf(rt, rt.nodes[0].id);
    QCOMPARE(rtKids.size(), origKids.size());

    // Verify each field kind matches
    for (int i = 0; i < origKids.size(); i++) {
        QCOMPARE(rt.nodes[rtKids[i]].kind, tree.nodes[origKids[i]].kind);
        QCOMPARE(rt.nodes[rtKids[i]].name, tree.nodes[origKids[i]].name);
    }

    // Verify self-pointer resolved
    bool foundSelf = false;
    for (const auto& n : rt.nodes) {
        if (n.name == QStringLiteral("self") && n.kind == NodeKind::Pointer64) {
            QVERIFY(n.refId != 0);
            QCOMPARE(n.refId, rt.nodes[0].id);
            foundSelf = true;
        }
    }
    QVERIFY(foundSelf);
}

QTEST_MAIN(TestExportXml)
#include "test_export_xml.moc"

```

`tests/test_format.cpp`:

```cpp
#include <QtTest/QTest>
#include "core.h"

using namespace rcx;

class TestFormat : public QObject {
    Q_OBJECT
private slots:
    void testTypeName() {
        QString s = fmt::typeName(NodeKind::Float);
        QVERIFY(s.trimmed() == "float");
        QCOMPARE(s.size(), 14); // kColType
    }

    void testFmtInt32() {
        // fmtInt32 outputs hex representation (0xffffffd6 for -42)
        QCOMPARE(fmt::fmtInt32(-42), QString("0xffffffd6"));
        QCOMPARE(fmt::fmtInt32(0),   QString("0x0"));
    }

    void testFmtFloat() {
        QString s = fmt::fmtFloat(3.14159f);
        QVERIFY(s.contains("3.14"));
    }

    void testFmtBool() {
        QCOMPARE(fmt::fmtBool(1), QString("true"));
        QCOMPARE(fmt::fmtBool(0), QString("false"));
    }

    void testFmtPointer64_null() {
        QCOMPARE(fmt::fmtPointer64(0), QString("-> NULL"));
    }

    void testFmtPointer64_nonNull() {
        QString s = fmt::fmtPointer64(0x400000);
        QVERIFY(s.startsWith("-> 0x"));
        QVERIFY(s.contains("400000"));
    }

    void testFmtOffsetMargin_primary() {
        QCOMPARE(fmt::fmtOffsetMargin(0x10, false), QString("00000010 "));
        QCOMPARE(fmt::fmtOffsetMargin(0, false),    QString("00000000 "));
    }

    void testFmtOffsetMargin_continuation() {
        QCOMPARE(fmt::fmtOffsetMargin(0x10, true), QString("  \u00B7 "));
    }

    void testFmtOffsetMargin_kernelAddr() {
        QCOMPARE(fmt::fmtOffsetMargin(0xFFFFF80012345678ULL, false, 16),
                 QString("FFFFF80012345678 "));
        QCOMPARE(fmt::fmtOffsetMargin(0x10, false, 16),
                 QString("0000000000000010 "));
        QCOMPARE(fmt::fmtOffsetMargin(0x10, false, 4),
                 QString("0010 "));
    }

    void testFmtStructHeader() {
        Node n;
        n.kind = NodeKind::Struct;
        n.name = "Test";
        // Expanded header should contain opening brace
        QString s = fmt::fmtStructHeader(n, 0, /*collapsed=*/false);
        QVERIFY(s.contains("struct"));
        QVERIFY(s.contains("Test"));
        QVERIFY(s.contains("{"));

        // Collapsed header should not contain opening brace
        QString collapsed = fmt::fmtStructHeader(n, 0, /*collapsed=*/true);
        QVERIFY(collapsed.contains("struct"));
        QVERIFY(collapsed.contains("Test"));
        QVERIFY(!collapsed.contains("{"));
    }

    void testFmtStructFooter() {
        Node n;
        n.kind = NodeKind::Struct;
        n.name = "Test";
        QString s = fmt::fmtStructFooter(n, 0);
        QVERIFY(s.contains("};"));
        // When no size, footer is just "};" without name
    }

    void testIndent() {
        QCOMPARE(fmt::indent(0), QString(""));
        QCOMPARE(fmt::indent(1), QString("   "));
        QCOMPARE(fmt::indent(3), QString("         "));
    }

    void testParseValueInt32() {
        bool ok;
        QByteArray b = fmt::parseValue(NodeKind::Int32, "-42", &ok);
        QVERIFY(ok);
        QCOMPARE(b.size(), 4);
        int32_t v;
        memcpy(&v, b.data(), 4);
        QCOMPARE(v, -42);
    }

    void testParseValueFloat() {
        bool ok;
        QByteArray b = fmt::parseValue(NodeKind::Float, "3.14", &ok);
        QVERIFY(ok);
        QCOMPARE(b.size(), 4);
        float v;
        memcpy(&v, b.data(), 4);
        QVERIFY(qAbs(v - 3.14f) < 0.01f);
    }

    void testParseValueHex32() {
        bool ok;
        // Hex parsing produces native-endian bytes (matches display which reads native-endian)
        QByteArray b = fmt::parseValue(NodeKind::Hex32, "DEADBEEF", &ok);
        QVERIFY(ok);
        QCOMPARE(b.size(), 4);
        // Value 0xDEADBEEF stored as native-endian (little-endian on x86)
        uint32_t v;
        memcpy(&v, b.data(), 4);
        QCOMPARE(v, (uint32_t)0xDEADBEEF);
    }

    void testParseValueBool() {
        bool ok;
        QByteArray b = fmt::parseValue(NodeKind::Bool, "true", &ok);
        QVERIFY(ok);
        QCOMPARE(b.size(), 1);
        QCOMPARE((uint8_t)b[0], (uint8_t)1);

        b = fmt::parseValue(NodeKind::Bool, "false", &ok);
        QVERIFY(ok);
        QCOMPARE((uint8_t)b[0], (uint8_t)0);

        // Unknown token should fail
        fmt::parseValue(NodeKind::Bool, "banana", &ok);
        QVERIFY(!ok);
    }

    void testParseValueHex0xPrefix() {
        bool ok;
        // Hex32 with 0x prefix should work (native-endian, matches display)
        QByteArray b = fmt::parseValue(NodeKind::Hex32, "0xDEADBEEF", &ok);
        QVERIFY(ok);
        uint32_t v32;
        memcpy(&v32, b.data(), 4);
        QCOMPARE(v32, (uint32_t)0xDEADBEEF);

        // Pointer64 with 0x prefix
        b = fmt::parseValue(NodeKind::Pointer64, "0x0000000000400000", &ok);
        QVERIFY(ok);
        uint64_t v64;
        memcpy(&v64, b.data(), 8);
        QCOMPARE(v64, (uint64_t)0x400000);
    }

    void testParseValueOverflow() {
        bool ok;
        // UInt8: 300 exceeds uint8_t max (255) → should fail
        fmt::parseValue(NodeKind::UInt8, "300", &ok);
        QVERIFY(!ok);

        // UInt8: 255 should succeed
        QByteArray b = fmt::parseValue(NodeKind::UInt8, "255", &ok);
        QVERIFY(ok);
        QCOMPARE((uint8_t)b[0], (uint8_t)255);

        // Int8: 200 exceeds int8_t max (127) → should fail
        fmt::parseValue(NodeKind::Int8, "200", &ok);
        QVERIFY(!ok);

        // Int8: -129 below min → should fail
        fmt::parseValue(NodeKind::Int8, "-129", &ok);
        QVERIFY(!ok);

        // Int8: -128 is valid
        b = fmt::parseValue(NodeKind::Int8, "-128", &ok);
        QVERIFY(ok);
        int8_t sv;
        memcpy(&sv, b.data(), 1);
        QCOMPARE(sv, (int8_t)-128);

        // UInt16: 70000 exceeds uint16_t max → should fail
        fmt::parseValue(NodeKind::UInt16, "70000", &ok);
        QVERIFY(!ok);

        // Hex8: 0x1FF exceeds uint8_t → should fail
        fmt::parseValue(NodeKind::Hex8, "1FF", &ok);
        QVERIFY(!ok);

        // Hex16: 0x1FFFF exceeds uint16_t → should fail
        fmt::parseValue(NodeKind::Hex16, "1FFFF", &ok);
        QVERIFY(!ok);
    }

    void testSignedHexRoundTrip() {
        bool ok;
        // Int8: 0xFF should parse as -1 (two's complement)
        QByteArray b = fmt::parseValue(NodeKind::Int8, "0xFF", &ok);
        QVERIFY(ok);
        int8_t sv8;
        memcpy(&sv8, b.data(), 1);
        QCOMPARE(sv8, (int8_t)-1);

        // Int8: 0x80 should parse as -128
        b = fmt::parseValue(NodeKind::Int8, "0x80", &ok);
        QVERIFY(ok);
        memcpy(&sv8, b.data(), 1);
        QCOMPARE(sv8, (int8_t)-128);

        // Int16: 0xFFFF should parse as -1
        b = fmt::parseValue(NodeKind::Int16, "0xFFFF", &ok);
        QVERIFY(ok);
        int16_t sv16;
        memcpy(&sv16, b.data(), 2);
        QCOMPARE(sv16, (int16_t)-1);

        // Int32: 0xFFFFFFFF should parse as -1
        b = fmt::parseValue(NodeKind::Int32, "0xFFFFFFFF", &ok);
        QVERIFY(ok);
        int32_t sv32;
        memcpy(&sv32, b.data(), 4);
        QCOMPARE(sv32, (int32_t)-1);

        // Int8: 0x1FF should fail (exceeds byte range)
        fmt::parseValue(NodeKind::Int8, "0x1FF", &ok);
        QVERIFY(!ok);

        // Int16: 0x1FFFF should fail (exceeds 16-bit range)
        fmt::parseValue(NodeKind::Int16, "0x1FFFF", &ok);
        QVERIFY(!ok);
    }

    void testReadValueBoundsCheck() {
        // Vec2 single-line: subLine=0 returns all components
        QByteArray data(16, '\0');
        BufferProvider prov(data);
        Node n;
        n.kind = NodeKind::Vec2;
        n.name = "v";
        QVERIFY(fmt::readValue(n, prov, 0, 0).contains(","));

        // Vec3 single-line: subLine=0 returns 3 comma-separated values
        n.kind = NodeKind::Vec3;
        QCOMPARE(fmt::readValue(n, prov, 0, 0).count(','), 2);

        // Vec4 single-line: subLine=0 returns 4 comma-separated values
        n.kind = NodeKind::Vec4;
        QCOMPARE(fmt::readValue(n, prov, 0, 0).count(','), 3);
    }

    void testEditableValueBasic() {
        QByteArray data(16, '\0');
        // Write a known float value
        float val = 3.14f;
        memcpy(data.data(), &val, 4);
        BufferProvider prov(data);

        Node n;
        n.kind = NodeKind::Float;
        n.name = "f";
        QString s = fmt::editableValue(n, prov, 0, 0);
        QVERIFY(s.contains("3.14"));

        // Vec2 single-line: returns comma-separated values
        n.kind = NodeKind::Vec2;
        QString vec2 = fmt::editableValue(n, prov, 0, 0);
        QVERIFY(vec2.contains(","));
    }

    void testParseValueEmptyString() {
        bool ok;
        // Empty UTF8 should succeed (caller pads)
        QByteArray b = fmt::parseValue(NodeKind::UTF8, "", &ok);
        QVERIFY(ok);
        QVERIFY(b.isEmpty());

        // Empty non-string should fail
        fmt::parseValue(NodeKind::Int32, "", &ok);
        QVERIFY(!ok);
    }

    void testFmtStructFooterSimple() {
        Node n;
        n.kind = NodeKind::Struct;
        n.name = "Test";

        // Footer is always just "};" (no sizeof comment)
        QString s = fmt::fmtStructFooter(n, 0, 0x14);
        QVERIFY(s.contains("};"));
        QVERIFY(!s.contains("sizeof"));  // No sizeof comment
    }
};

QTEST_MAIN(TestFormat)
#include "test_format.moc"

```

`tests/test_generator.cpp`:

```cpp
#include <QtTest/QTest>
#include <QFile>
#include <QTemporaryFile>
#include "core.h"
#include "generator.h"

class TestGenerator : public QObject {
    Q_OBJECT

private:
    // Helper: build a simple struct with a few fields
    rcx::NodeTree makeSimpleStruct() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "Player";
        root.structTypeName = "Player";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node f1;
        f1.kind = rcx::NodeKind::Int32;
        f1.name = "health";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        rcx::Node f2;
        f2.kind = rcx::NodeKind::Float;
        f2.name = "speed";
        f2.parentId = rootId;
        f2.offset = 4;
        tree.addNode(f2);

        rcx::Node f3;
        f3.kind = rcx::NodeKind::UInt64;
        f3.name = "id";
        f3.parentId = rootId;
        f3.offset = 8;
        tree.addNode(f3);

        return tree;
    }

private slots:

    // ── Basic struct generation ──

    void testSimpleStruct() {
        auto tree = makeSimpleStruct();
        uint64_t rootId = tree.nodes[0].id;
        QString result = rcx::renderCpp(tree, rootId);

        // Header
        QVERIFY(result.contains("#pragma once"));
        QVERIFY(!result.contains("#include <cstdint>"));
        QVERIFY(!result.contains("#pragma pack"));

        // Struct definition
        QVERIFY(result.contains("struct Player {"));
        QVERIFY(result.contains("int32_t health;"));
        QVERIFY(result.contains("float speed;"));
        QVERIFY(result.contains("uint64_t id;"));
        QVERIFY(result.contains("};"));

        // static_assert - struct is 16 bytes (0+4 + 4+4 + 8+8 = 16)
        QVERIFY(result.contains("static_assert(sizeof(Player) == 0x10"));
    }

    // ── Padding gap detection ──

    void testPaddingGaps() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "GappyStruct";
        root.structTypeName = "GappyStruct";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Field at offset 0, size 4
        rcx::Node f1;
        f1.kind = rcx::NodeKind::UInt32;
        f1.name = "a";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        // Field at offset 8, size 4 (gap of 4 bytes at offset 4)
        rcx::Node f2;
        f2.kind = rcx::NodeKind::UInt32;
        f2.name = "b";
        f2.parentId = rootId;
        f2.offset = 8;
        tree.addNode(f2);

        QString result = rcx::renderCpp(tree, rootId);

        // Should contain a padding field between a and b
        QVERIFY(result.contains("uint8_t _pad"));
        QVERIFY(result.contains("[0x4]"));
        QVERIFY(result.contains("uint32_t a;"));
        QVERIFY(result.contains("uint32_t b;"));
    }

    // ── Tail padding ──

    void testTailPadding() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "TailPad";
        root.structTypeName = "TailPad";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Only field at offset 0, size 1
        rcx::Node f1;
        f1.kind = rcx::NodeKind::UInt8;
        f1.name = "flag";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        // Add another field at offset 16 to make struct bigger
        rcx::Node f2;
        f2.kind = rcx::NodeKind::UInt8;
        f2.name = "end";
        f2.parentId = rootId;
        f2.offset = 16;
        tree.addNode(f2);

        QString result = rcx::renderCpp(tree, rootId);

        // Gap between offset 1 and 16 = 15 bytes padding
        QVERIFY(result.contains("[0xF]"));
        // Total size = 17
        QVERIFY(result.contains("static_assert(sizeof(TailPad) == 0x11"));
    }

    // ── Overlap warning ──

    void testOverlapWarning() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "OverlapStruct";
        root.structTypeName = "OverlapStruct";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        // Two fields that overlap: both at offset 0, size 8 and size 4
        rcx::Node f1;
        f1.kind = rcx::NodeKind::UInt64;
        f1.name = "wide";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        rcx::Node f2;
        f2.kind = rcx::NodeKind::UInt32;
        f2.name = "narrow";
        f2.parentId = rootId;
        f2.offset = 4; // starts at 4, but wide ends at 8 => overlap
        tree.addNode(f2);

        QString result = rcx::renderCpp(tree, rootId);

        // Should contain overlap warning
        QVERIFY(result.contains("WARNING: overlap"));
    }

    // ── Nested struct ──

    void testNestedStruct() {
        rcx::NodeTree tree;

        // Outer struct
        rcx::Node outer;
        outer.kind = rcx::NodeKind::Struct;
        outer.name = "Outer";
        outer.structTypeName = "Outer";
        outer.parentId = 0;
        int oi = tree.addNode(outer);
        uint64_t outerId = tree.nodes[oi].id;

        // Inner struct as child
        rcx::Node inner;
        inner.kind = rcx::NodeKind::Struct;
        inner.name = "pos";
        inner.structTypeName = "Vec2f";
        inner.parentId = outerId;
        inner.offset = 0;
        int ii = tree.addNode(inner);
        uint64_t innerId = tree.nodes[ii].id;

        // Inner fields
        rcx::Node ix;
        ix.kind = rcx::NodeKind::Float;
        ix.name = "x";
        ix.parentId = innerId;
        ix.offset = 0;
        tree.addNode(ix);

        rcx::Node iy;
        iy.kind = rcx::NodeKind::Float;
        iy.name = "y";
        iy.parentId = innerId;
        iy.offset = 4;
        tree.addNode(iy);

        // Another field in outer after inner
        rcx::Node f2;
        f2.kind = rcx::NodeKind::Int32;
        f2.name = "score";
        f2.parentId = outerId;
        f2.offset = 8;
        tree.addNode(f2);

        QString result = rcx::renderCpp(tree, outerId);

        // Inner struct should be defined before outer
        int innerPos = result.indexOf("struct Vec2f {");
        int outerPos = result.indexOf("struct Outer {");
        QVERIFY(innerPos >= 0);
        QVERIFY(outerPos >= 0);
        QVERIFY(innerPos < outerPos);

        // Inner struct fields
        QVERIFY(result.contains("float x;"));
        QVERIFY(result.contains("float y;"));
        QVERIFY(result.contains("static_assert(sizeof(Vec2f) == 0x8"));

        // Outer struct uses inner type
        QVERIFY(result.contains("Vec2f pos;"));
        QVERIFY(result.contains("int32_t score;"));
    }

    // ── Primitive array ──

    void testPrimitiveArray() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "WithArray";
        root.structTypeName = "WithArray";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node arr;
        arr.kind = rcx::NodeKind::Array;
        arr.name = "data";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.arrayLen = 16;
        arr.elementKind = rcx::NodeKind::UInt32;
        tree.addNode(arr);

        QString result = rcx::renderCpp(tree, rootId);
        QVERIFY(result.contains("uint32_t data[16];"));
    }

    // ── Pointer fields ──

    void testPointerFields() {
        rcx::NodeTree tree;

        // Target struct (separate root)
        rcx::Node target;
        target.kind = rcx::NodeKind::Struct;
        target.name = "Target";
        target.structTypeName = "TargetData";
        target.parentId = 0;
        target.offset = 0x100;
        int ti = tree.addNode(target);
        uint64_t targetId = tree.nodes[ti].id;

        rcx::Node tf;
        tf.kind = rcx::NodeKind::UInt32;
        tf.name = "value";
        tf.parentId = targetId;
        tf.offset = 0;
        tree.addNode(tf);

        // Main struct with pointers
        rcx::Node main;
        main.kind = rcx::NodeKind::Struct;
        main.name = "Main";
        main.structTypeName = "MainStruct";
        main.parentId = 0;
        int mi = tree.addNode(main);
        uint64_t mainId = tree.nodes[mi].id;

        // ptr64 with reference
        rcx::Node p64;
        p64.kind = rcx::NodeKind::Pointer64;
        p64.name = "pTarget";
        p64.parentId = mainId;
        p64.offset = 0;
        p64.refId = targetId;
        tree.addNode(p64);

        // ptr64 without reference
        rcx::Node p64n;
        p64n.kind = rcx::NodeKind::Pointer64;
        p64n.name = "pVoid";
        p64n.parentId = mainId;
        p64n.offset = 8;
        tree.addNode(p64n);

        // ptr32 with reference
        rcx::Node p32;
        p32.kind = rcx::NodeKind::Pointer32;
        p32.name = "pTarget32";
        p32.parentId = mainId;
        p32.offset = 16;
        p32.refId = targetId;
        tree.addNode(p32);

        QString result = rcx::renderCpp(tree, mainId);

        // ptr64 with target → real C++ pointer
        QVERIFY(result.contains("TargetData* pTarget;"));
        // ptr64 without target → void*
        QVERIFY(result.contains("void* pVoid;"));
        // ptr32 with target → uint32_t with comment
        QVERIFY(result.contains("uint32_t pTarget32;"));
        QVERIFY(result.contains("-> TargetData*"));
        // Forward declaration for TargetData
        QVERIFY(result.contains("struct TargetData;"));
    }

    // ── Vector and matrix types ──

    void testVectorTypes() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "Vectors";
        root.structTypeName = "Vectors";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node v2;
        v2.kind = rcx::NodeKind::Vec2;
        v2.name = "pos2d";
        v2.parentId = rootId;
        v2.offset = 0;
        tree.addNode(v2);

        rcx::Node v3;
        v3.kind = rcx::NodeKind::Vec3;
        v3.name = "pos3d";
        v3.parentId = rootId;
        v3.offset = 8;
        tree.addNode(v3);

        rcx::Node v4;
        v4.kind = rcx::NodeKind::Vec4;
        v4.name = "color";
        v4.parentId = rootId;
        v4.offset = 20;
        tree.addNode(v4);

        rcx::Node mat;
        mat.kind = rcx::NodeKind::Mat4x4;
        mat.name = "transform";
        mat.parentId = rootId;
        mat.offset = 36;
        tree.addNode(mat);

        QString result = rcx::renderCpp(tree, rootId);

        QVERIFY(result.contains("float pos2d[2];"));
        QVERIFY(result.contains("float pos3d[3];"));
        QVERIFY(result.contains("float color[4];"));
        QVERIFY(result.contains("float transform[4][4];"));
    }

    // ── String types ──

    void testStringTypes() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "Strings";
        root.structTypeName = "Strings";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node utf8;
        utf8.kind = rcx::NodeKind::UTF8;
        utf8.name = "name";
        utf8.parentId = rootId;
        utf8.offset = 0;
        utf8.strLen = 64;
        tree.addNode(utf8);

        rcx::Node utf16;
        utf16.kind = rcx::NodeKind::UTF16;
        utf16.name = "wname";
        utf16.parentId = rootId;
        utf16.offset = 64;
        utf16.strLen = 32;
        tree.addNode(utf16);

        QString result = rcx::renderCpp(tree, rootId);

        QVERIFY(result.contains("char name[64];"));
        QVERIFY(result.contains("wchar_t wname[32];"));
    }

    // ── Full SDK export (multiple root structs) ──

    void testFullSdkExport() {
        rcx::NodeTree tree;

        // Struct A at offset 0
        rcx::Node a;
        a.kind = rcx::NodeKind::Struct;
        a.name = "StructA";
        a.structTypeName = "StructA";
        a.parentId = 0;
        a.offset = 0;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        rcx::Node af;
        af.kind = rcx::NodeKind::UInt32;
        af.name = "valueA";
        af.parentId = aId;
        af.offset = 0;
        tree.addNode(af);

        // Struct B at offset 0x100
        rcx::Node b;
        b.kind = rcx::NodeKind::Struct;
        b.name = "StructB";
        b.structTypeName = "StructB";
        b.parentId = 0;
        b.offset = 0x100;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;

        rcx::Node bf;
        bf.kind = rcx::NodeKind::UInt64;
        bf.name = "valueB";
        bf.parentId = bId;
        bf.offset = 0;
        tree.addNode(bf);

        QString result = rcx::renderCppAll(tree);

        QVERIFY(result.contains("struct StructA {"));
        QVERIFY(result.contains("struct StructB {"));
        QVERIFY(result.contains("uint32_t valueA;"));
        QVERIFY(result.contains("uint64_t valueB;"));
        QVERIFY(result.contains("static_assert(sizeof(StructA) == 0x4"));
        QVERIFY(result.contains("static_assert(sizeof(StructB) == 0x8"));
    }

    // ── Null generator ──

    void testNullGenerator() {
        auto tree = makeSimpleStruct();
        QString result = rcx::renderNull(tree, tree.nodes[0].id);
        QVERIFY(result.isEmpty());
    }

    // ── Invalid root ID ──

    void testInvalidRootId() {
        auto tree = makeSimpleStruct();
        QString result = rcx::renderCpp(tree, 9999);
        QVERIFY(result.isEmpty());
    }

    // ── Non-struct root ──

    void testNonStructRoot() {
        rcx::NodeTree tree;
        rcx::Node n;
        n.kind = rcx::NodeKind::UInt32;
        n.name = "scalar";
        n.parentId = 0;
        tree.addNode(n);

        QString result = rcx::renderCpp(tree, tree.nodes[0].id);
        QVERIFY(result.isEmpty());
    }

    // ── Empty struct ──

    void testEmptyStruct() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "Empty";
        root.structTypeName = "Empty";
        root.parentId = 0;
        tree.addNode(root);

        QString result = rcx::renderCpp(tree, tree.nodes[0].id);

        QVERIFY(result.contains("struct Empty {"));
        QVERIFY(result.contains("};"));
        QVERIFY(result.contains("static_assert(sizeof(Empty) == 0x0"));
    }

    // ── Name sanitization ──

    void testNameSanitization() {
        rcx::NodeTree tree;
        rcx::Node root;
        root.kind = rcx::NodeKind::Struct;
        root.name = "my struct-name";
        root.structTypeName = "my struct-name";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        rcx::Node f;
        f.kind = rcx::NodeKind::UInt32;
        f.name = "field with spaces";
        f.parentId = rootId;
        f.offset = 0;
        tree.addNode(f);

        QString result = rcx::renderCpp(tree, rootId);

        // Spaces and dashes should be replaced with underscores
        QVERIFY(result.contains("struct my_struct_name {"));
        QVERIFY(result.contains("uint32_t field_with_spaces;"));
    }

    // ── Export produces valid file content ──

    void testExportToFile() {
        auto tree = makeSimpleStruct();
        uint64_t rootId = tree.nodes[0].id;
        QString text = rcx::renderCpp(tree, rootId);

        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        tmpFile.write(text.toUtf8());
        tmpFile.close();

        // Read back and verify
        QVERIFY(tmpFile.open());
        QByteArray readBack = tmpFile.readAll();
        tmpFile.close();

        QString readStr = QString::fromUtf8(readBack);
        QVERIFY(readStr.contains("#pragma once"));
        QVERIFY(readStr.contains("struct Player {"));
        QVERIFY(readStr.contains("static_assert"));
    }

    // ── Full SDK with no structs (only primitives) ──

    void testFullSdkNoStructs() {
        rcx::NodeTree tree;
        rcx::Node n;
        n.kind = rcx::NodeKind::UInt32;
        n.name = "scalar";
        n.parentId = 0;
        tree.addNode(n);

        QString result = rcx::renderCppAll(tree);

        // Header present but no struct definitions
        QVERIFY(result.contains("#pragma once"));
        QVERIFY(!result.contains("struct "));
    }

    // ── Deeply nested structs ──

    void testDeeplyNested() {
        rcx::NodeTree tree;

        // A > B > C, each containing one field
        rcx::Node a;
        a.kind = rcx::NodeKind::Struct;
        a.name = "A";
        a.structTypeName = "TypeA";
        a.parentId = 0;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        rcx::Node b;
        b.kind = rcx::NodeKind::Struct;
        b.name = "b";
        b.structTypeName = "TypeB";
        b.parentId = aId;
        b.offset = 0;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;

        rcx::Node c;
        c.kind = rcx::NodeKind::Struct;
        c.name = "c";
        c.structTypeName = "TypeC";
        c.parentId = bId;
        c.offset = 0;
        int ci = tree.addNode(c);
        uint64_t cId = tree.nodes[ci].id;

        rcx::Node leaf;
        leaf.kind = rcx::NodeKind::UInt8;
        leaf.name = "val";
        leaf.parentId = cId;
        leaf.offset = 0;
        tree.addNode(leaf);

        QString result = rcx::renderCpp(tree, aId);

        // TypeC defined first, then TypeB, then TypeA
        int cPos = result.indexOf("struct TypeC {");
        int bPos = result.indexOf("struct TypeB {");
        int aPos = result.indexOf("struct TypeA {");
        QVERIFY(cPos >= 0);
        QVERIFY(bPos >= 0);
        QVERIFY(aPos >= 0);
        QVERIFY(cPos < bPos);
        QVERIFY(bPos < aPos);

        // TypeA contains TypeB, TypeB contains TypeC
        QVERIFY(result.contains("TypeB b;"));
        QVERIFY(result.contains("TypeC c;"));
        QVERIFY(result.contains("uint8_t val;"));
    }
};

QTEST_MAIN(TestGenerator)
#include "test_generator.moc"

```

`tests/test_import_pdb.cpp`:

```cpp
#include <QtTest/QtTest>
#include "core.h"
#include "imports/import_pdb.h"

using namespace rcx;

class TestImportPdb : public QObject {
    Q_OBJECT
private slots:
    void missingFileReturnsError();
    void importKProcess();
    void verifyDispatcherHeader();
    void verifyListEntry();
    void importFilteredStruct();
    void enumerateTypes();
    void importSelected();
};

static const QString kPdbPath = QStringLiteral(
    "C:/Symbols/ntkrnlmp.pdb/0762CF42EF7F3E8116EF7329ADAA09A31/ntkrnlmp.pdb");

// Find a root struct by structTypeName
static int findRootStruct(const NodeTree& tree, const QString& name) {
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].parentId == 0 &&
            tree.nodes[i].kind == NodeKind::Struct &&
            tree.nodes[i].structTypeName == name)
            return i;
    }
    return -1;
}

// Find a child of parentId by name
static int findChildNode(const NodeTree& tree, uint64_t parentId, const QString& name) {
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].parentId == parentId && tree.nodes[i].name == name)
            return i;
    }
    return -1;
}

void TestImportPdb::missingFileReturnsError() {
    QString err;
    NodeTree tree = importPdb(QStringLiteral("C:/nonexistent.pdb"), {}, &err);
    QVERIFY(tree.nodes.isEmpty());
    QVERIFY(!err.isEmpty());
}

void TestImportPdb::importKProcess() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    QString err;
    NodeTree tree = importPdb(kPdbPath, QStringLiteral("_KPROCESS"), &err);
    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(err));

    // Find _KPROCESS root struct
    int kpIdx = findRootStruct(tree, QStringLiteral("_KPROCESS"));
    QVERIFY2(kpIdx >= 0, "Expected _KPROCESS root struct");
    uint64_t kpId = tree.nodes[kpIdx].id;

    // Verify Header field at offset 0 → embedded _DISPATCHER_HEADER
    int headerIdx = findChildNode(tree, kpId, QStringLiteral("Header"));
    QVERIFY2(headerIdx >= 0, "Expected 'Header' child of _KPROCESS");
    QCOMPARE(tree.nodes[headerIdx].kind, NodeKind::Struct);
    QCOMPARE(tree.nodes[headerIdx].structTypeName, QStringLiteral("_DISPATCHER_HEADER"));
    QCOMPARE(tree.nodes[headerIdx].offset, 0);

    // Verify ProfileListHead at offset 0x18 → embedded _LIST_ENTRY
    int profileIdx = findChildNode(tree, kpId, QStringLiteral("ProfileListHead"));
    QVERIFY2(profileIdx >= 0, "Expected 'ProfileListHead' child of _KPROCESS");
    QCOMPARE(tree.nodes[profileIdx].kind, NodeKind::Struct);
    QCOMPARE(tree.nodes[profileIdx].structTypeName, QStringLiteral("_LIST_ENTRY"));
    QCOMPARE(tree.nodes[profileIdx].offset, 0x18);
}

void TestImportPdb::verifyDispatcherHeader() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    QString err;
    NodeTree tree = importPdb(kPdbPath, QStringLiteral("_KPROCESS"), &err);
    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(err));

    // _DISPATCHER_HEADER should be imported as a transitive dependency
    int dhIdx = findRootStruct(tree, QStringLiteral("_DISPATCHER_HEADER"));
    QVERIFY2(dhIdx >= 0, "_DISPATCHER_HEADER should be imported as a dependency");

    uint64_t dhId = tree.nodes[dhIdx].id;
    auto kids = tree.childrenOf(dhId);
    QVERIFY2(!kids.isEmpty(), "_DISPATCHER_HEADER should have children (fields)");

    // Look for WaitListHead — a _LIST_ENTRY at offset 0x10 in most builds
    int waitIdx = findChildNode(tree, dhId, QStringLiteral("WaitListHead"));
    QVERIFY2(waitIdx >= 0, "Expected 'WaitListHead' in _DISPATCHER_HEADER");
    QCOMPARE(tree.nodes[waitIdx].kind, NodeKind::Struct);
    QCOMPARE(tree.nodes[waitIdx].structTypeName, QStringLiteral("_LIST_ENTRY"));
}

void TestImportPdb::verifyListEntry() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    QString err;
    NodeTree tree = importPdb(kPdbPath, QStringLiteral("_KPROCESS"), &err);
    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(err));

    // _LIST_ENTRY should be imported (used by ProfileListHead and others)
    int leIdx = findRootStruct(tree, QStringLiteral("_LIST_ENTRY"));
    QVERIFY2(leIdx >= 0, "_LIST_ENTRY should be imported");

    uint64_t leId = tree.nodes[leIdx].id;

    // Flink at offset 0 — pointer to _LIST_ENTRY
    int flinkIdx = findChildNode(tree, leId, QStringLiteral("Flink"));
    QVERIFY2(flinkIdx >= 0, "Expected 'Flink' in _LIST_ENTRY");
    QCOMPARE(tree.nodes[flinkIdx].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[flinkIdx].offset, 0);

    // Blink at offset 8 — pointer to _LIST_ENTRY
    int blinkIdx = findChildNode(tree, leId, QStringLiteral("Blink"));
    QVERIFY2(blinkIdx >= 0, "Expected 'Blink' in _LIST_ENTRY");
    QCOMPARE(tree.nodes[blinkIdx].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[blinkIdx].offset, 8);

    // Both should point back to _LIST_ENTRY (self-referencing)
    QCOMPARE(tree.nodes[flinkIdx].refId, leId);
    QCOMPARE(tree.nodes[blinkIdx].refId, leId);
}

void TestImportPdb::importFilteredStruct() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    QString err;
    NodeTree tree = importPdb(kPdbPath, QStringLiteral("_LIST_ENTRY"), &err);
    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(err));

    int leIdx = findRootStruct(tree, QStringLiteral("_LIST_ENTRY"));
    QVERIFY(leIdx >= 0);

    // _LIST_ENTRY only references itself, so exactly 1 root struct
    int rootCount = 0;
    for (const auto& n : tree.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) rootCount++;
    QCOMPARE(rootCount, 1);
}

void TestImportPdb::enumerateTypes() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    QString err;
    QVector<PdbTypeInfo> types = enumeratePdbTypes(kPdbPath, &err);
    QVERIFY2(!types.isEmpty(), qPrintable(err));

    // Should have hundreds of types in ntkrnlmp
    QVERIFY2(types.size() > 100,
             qPrintable(QStringLiteral("Expected >100 types, got %1").arg(types.size())));

    // Verify _KPROCESS is present
    bool foundKProcess = false;
    bool foundListEntry = false;
    for (const auto& t : types) {
        if (t.name == QStringLiteral("_KPROCESS")) {
            foundKProcess = true;
            QVERIFY2(t.childCount > 0, "_KPROCESS should have children");
            QVERIFY2(t.size > 0, "_KPROCESS should have non-zero size");
        }
        if (t.name == QStringLiteral("_LIST_ENTRY")) {
            foundListEntry = true;
        }
    }
    QVERIFY2(foundKProcess, "_KPROCESS not found in enumerated types");
    QVERIFY2(foundListEntry, "_LIST_ENTRY not found in enumerated types");
}

void TestImportPdb::importSelected() {
    if (!QFile::exists(kPdbPath))
        QSKIP("ntkrnlmp.pdb not found at expected path");

    // First enumerate to find _LIST_ENTRY's type index
    QString err;
    QVector<PdbTypeInfo> types = enumeratePdbTypes(kPdbPath, &err);
    QVERIFY2(!types.isEmpty(), qPrintable(err));

    uint32_t listEntryIdx = 0;
    bool found = false;
    for (const auto& t : types) {
        if (t.name == QStringLiteral("_LIST_ENTRY")) {
            listEntryIdx = t.typeIndex;
            found = true;
            break;
        }
    }
    QVERIFY2(found, "_LIST_ENTRY not found in enumeration");

    // Import just _LIST_ENTRY
    QVector<uint32_t> indices = { listEntryIdx };
    int progressCalls = 0;
    NodeTree tree = importPdbSelected(kPdbPath, indices, &err,
        [&](int cur, int total) -> bool {
            progressCalls++;
            Q_UNUSED(total);
            Q_ASSERT(cur <= total);
            return true; // don't cancel
        });
    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(err));
    QVERIFY(progressCalls > 0);

    // Verify _LIST_ENTRY root struct
    int leIdx = findRootStruct(tree, QStringLiteral("_LIST_ENTRY"));
    QVERIFY2(leIdx >= 0, "_LIST_ENTRY should be imported");

    // Flink and Blink
    uint64_t leId = tree.nodes[leIdx].id;
    int flinkIdx = findChildNode(tree, leId, QStringLiteral("Flink"));
    QVERIFY2(flinkIdx >= 0, "Expected 'Flink' in _LIST_ENTRY");
    QCOMPARE(tree.nodes[flinkIdx].kind, NodeKind::Pointer64);

    int blinkIdx = findChildNode(tree, leId, QStringLiteral("Blink"));
    QVERIFY2(blinkIdx >= 0, "Expected 'Blink' in _LIST_ENTRY");
    QCOMPARE(tree.nodes[blinkIdx].kind, NodeKind::Pointer64);

    // Self-referencing pointers
    QCOMPARE(tree.nodes[flinkIdx].refId, leId);
    QCOMPARE(tree.nodes[blinkIdx].refId, leId);

    // Only 1 root struct
    int rootCount = 0;
    for (const auto& n : tree.nodes)
        if (n.parentId == 0 && n.kind == NodeKind::Struct) rootCount++;
    QCOMPARE(rootCount, 1);
}

QTEST_MAIN(TestImportPdb)
#include "test_import_pdb.moc"

```

`tests/test_import_source.cpp`:

```cpp
#include <QtTest/QtTest>
#include "core.h"
#include "imports/import_source.h"

using namespace rcx;

class TestImportSource : public QObject {
    Q_OBJECT
private slots:
    // Basic type tests
    void emptyInput();
    void noStructs();
    void singleEmptyStruct();
    void stdintTypes();
    void windowsTypes();
    void platformPointerTypes();
    void standardCTypes();
    void multiWordTypes();
    void floatDouble();
    void boolType();

    // Pointer tests
    void voidPointer();
    void typedPointer();
    void selfReferencingPointer();
    void doublePointer();

    // Array tests
    void primitiveArray();
    void charArrayToUtf8();
    void wcharArrayToUtf16();
    void floatArrayToVec2();
    void floatArrayToVec3();
    void floatArrayToVec4();
    void floatArray4x4ToMat4x4();
    void genericFloatArray();
    void structArray();

    // Comment offset tests
    void commentOffsets();
    void computedOffsets();
    void mixedOffsetsAutoDetect();

    // Multi-struct tests
    void multiStruct();
    void pointerCrossRef();

    // Forward declarations
    void forwardDeclaration();

    // Union handling
    void unionContainer();
    void unionWithCommentOffsets();
    void namedUnion();

    // Padding fields
    void paddingFieldExpansion();

    // static_assert
    void staticAssertTailPadding();

    // Embedded struct
    void embeddedStruct();

    // Typedef
    void typedefBasic();

    // Qualifiers
    void constVolatileQualifiers();
    void structPrefixOnType();

    // Edge cases
    void bitfieldSkipped();
    void bitfieldWithOffsetsEmitsHex();
    void hexArraySizes();
    void windowsStylePEB();
    void classKeyword();
    void inheritanceSkipped();

    // Enum tests
    void enumBasic();
    void enumAutoValues();
    void enumHexValues();
    void enumInStruct();
    void enumClass();

    // Round-trip test (requires generator.h)
    void basicRoundTrip();
};

// ── Helper ──

static int countRoots(const NodeTree& tree) {
    int n = 0;
    for (const auto& node : tree.nodes)
        if (node.parentId == 0 && node.kind == NodeKind::Struct) n++;
    return n;
}

static QVector<int> childrenOf(const NodeTree& tree, uint64_t parentId) {
    QVector<int> result;
    for (int i = 0; i < tree.nodes.size(); i++)
        if (tree.nodes[i].parentId == parentId) result.append(i);
    return result;
}

// ── Tests ──

void TestImportSource::emptyInput() {
    QString err;
    NodeTree tree = importFromSource(QString(), &err);
    QVERIFY(tree.nodes.isEmpty());
    QVERIFY(!err.isEmpty());
}

void TestImportSource::noStructs() {
    QString err;
    NodeTree tree = importFromSource(QStringLiteral("int x = 42;"), &err);
    QVERIFY(tree.nodes.isEmpty());
    QVERIFY(!err.isEmpty());
}

void TestImportSource::singleEmptyStruct() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Empty {};\n"
    ));
    QCOMPARE(countRoots(tree), 1);
    QCOMPARE(tree.nodes[0].name, QStringLiteral("Empty"));
    QCOMPARE(tree.nodes[0].kind, NodeKind::Struct);
}

void TestImportSource::stdintTypes() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Test {\n"
        "    uint8_t  a;\n"
        "    int8_t   b;\n"
        "    uint16_t c;\n"
        "    int16_t  d;\n"
        "    uint32_t e;\n"
        "    int32_t  f;\n"
        "    uint64_t g;\n"
        "    int64_t  h;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 1);
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 8);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt8);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Int8);
    QCOMPARE(tree.nodes[kids[2]].kind, NodeKind::UInt16);
    QCOMPARE(tree.nodes[kids[3]].kind, NodeKind::Int16);
    QCOMPARE(tree.nodes[kids[4]].kind, NodeKind::UInt32);
    QCOMPARE(tree.nodes[kids[5]].kind, NodeKind::Int32);
    QCOMPARE(tree.nodes[kids[6]].kind, NodeKind::UInt64);
    QCOMPARE(tree.nodes[kids[7]].kind, NodeKind::Int64);
}

void TestImportSource::windowsTypes() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct WinTypes {\n"
        "    BYTE a;\n"
        "    WORD b;\n"
        "    DWORD c;\n"
        "    QWORD d;\n"
        "    ULONG e;\n"
        "    LONG f;\n"
        "    USHORT g;\n"
        "    UCHAR h;\n"
        "    BOOLEAN i;\n"
        "    BOOL j;\n"
        "    CHAR k;\n"
        "    WCHAR l;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 12);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt8);   // BYTE
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::UInt16);  // WORD
    QCOMPARE(tree.nodes[kids[2]].kind, NodeKind::UInt32);  // DWORD
    QCOMPARE(tree.nodes[kids[3]].kind, NodeKind::UInt64);  // QWORD
    QCOMPARE(tree.nodes[kids[4]].kind, NodeKind::UInt32);  // ULONG
    QCOMPARE(tree.nodes[kids[5]].kind, NodeKind::Int32);   // LONG
    QCOMPARE(tree.nodes[kids[6]].kind, NodeKind::UInt16);  // USHORT
    QCOMPARE(tree.nodes[kids[7]].kind, NodeKind::UInt8);   // UCHAR
    QCOMPARE(tree.nodes[kids[8]].kind, NodeKind::UInt8);   // BOOLEAN
    QCOMPARE(tree.nodes[kids[9]].kind, NodeKind::Int32);   // BOOL
    QCOMPARE(tree.nodes[kids[10]].kind, NodeKind::Int8);   // CHAR
    QCOMPARE(tree.nodes[kids[11]].kind, NodeKind::UInt16); // WCHAR
}

void TestImportSource::platformPointerTypes() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct PtrTypes {\n"
        "    PVOID a;\n"
        "    HANDLE b;\n"
        "    SIZE_T c;\n"
        "    ULONG_PTR d;\n"
        "    uintptr_t e;\n"
        "    size_t f;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 6);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[kids[2]].kind, NodeKind::UInt64);
    QCOMPARE(tree.nodes[kids[3]].kind, NodeKind::UInt64);
    QCOMPARE(tree.nodes[kids[4]].kind, NodeKind::UInt64);
    QCOMPARE(tree.nodes[kids[5]].kind, NodeKind::UInt64);
}

void TestImportSource::standardCTypes() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct CTypes {\n"
        "    char a;\n"
        "    short b;\n"
        "    int c;\n"
        "    long d;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 4);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Int8);    // char
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Int16);   // short
    QCOMPARE(tree.nodes[kids[2]].kind, NodeKind::Int32);   // int
    QCOMPARE(tree.nodes[kids[3]].kind, NodeKind::Int32);   // long
}

void TestImportSource::multiWordTypes() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct MultiWord {\n"
        "    unsigned char a;\n"
        "    unsigned short b;\n"
        "    unsigned int c;\n"
        "    unsigned long d;\n"
        "    long long e;\n"
        "    unsigned long long f;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 6);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt8);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::UInt16);
    QCOMPARE(tree.nodes[kids[2]].kind, NodeKind::UInt32);
    QCOMPARE(tree.nodes[kids[3]].kind, NodeKind::UInt32);
    QCOMPARE(tree.nodes[kids[4]].kind, NodeKind::Int64);
    QCOMPARE(tree.nodes[kids[5]].kind, NodeKind::UInt64);
}

void TestImportSource::floatDouble() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct FD {\n"
        "    float a;\n"
        "    double b;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 2);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Float);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Double);
}

void TestImportSource::boolType() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct B {\n"
        "    bool a;\n"
        "    _Bool b;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 2);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Bool);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Bool);
}

void TestImportSource::voidPointer() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct VP {\n"
        "    void* ptr;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[kids[0]].name, QStringLiteral("ptr"));
    QCOMPARE(tree.nodes[kids[0]].refId, uint64_t(0)); // void* has no target
}

void TestImportSource::typedPointer() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Target {\n"
        "    int x;\n"
        "};\n"
        "struct HasPtr {\n"
        "    Target* pTarget;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 2);
    // Find HasPtr
    int hasPtrIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("HasPtr") && tree.nodes[i].parentId == 0) {
            hasPtrIdx = i; break;
        }
    }
    QVERIFY(hasPtrIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[hasPtrIdx].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Pointer64);
    QVERIFY(tree.nodes[kids[0]].refId != 0);
    // refId should point to Target struct
    int targetIdx = tree.indexOfId(tree.nodes[kids[0]].refId);
    QVERIFY(targetIdx >= 0);
    QCOMPARE(tree.nodes[targetIdx].name, QStringLiteral("Target"));
}

void TestImportSource::selfReferencingPointer() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Node {\n"
        "    int value;\n"
        "    Node* next;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 2);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[kids[1]].refId, tree.nodes[0].id);
}

void TestImportSource::doublePointer() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct DP {\n"
        "    void** ppData;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Pointer64);
}

void TestImportSource::primitiveArray() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct PA {\n"
        "    int32_t values[10];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Array);
    QCOMPARE(tree.nodes[kids[0]].arrayLen, 10);
    QCOMPARE(tree.nodes[kids[0]].elementKind, NodeKind::Int32);
}

void TestImportSource::charArrayToUtf8() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct CA {\n"
        "    char name[64];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UTF8);
    QCOMPARE(tree.nodes[kids[0]].strLen, 64);
}

void TestImportSource::wcharArrayToUtf16() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct WC {\n"
        "    wchar_t name[32];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UTF16);
    QCOMPARE(tree.nodes[kids[0]].strLen, 32);
}

void TestImportSource::floatArrayToVec2() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct V {\n"
        "    float pos[2];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Vec2);
}

void TestImportSource::floatArrayToVec3() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct V {\n"
        "    float pos[3];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Vec3);
}

void TestImportSource::floatArrayToVec4() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct V {\n"
        "    float rot[4];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Vec4);
}

void TestImportSource::floatArray4x4ToMat4x4() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct M {\n"
        "    float matrix[4][4];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Mat4x4);
}

void TestImportSource::genericFloatArray() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct GF {\n"
        "    float values[8];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Array);
    QCOMPARE(tree.nodes[kids[0]].arrayLen, 8);
    QCOMPARE(tree.nodes[kids[0]].elementKind, NodeKind::Float);
}

void TestImportSource::structArray() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Item {\n"
        "    int id;\n"
        "};\n"
        "struct Container {\n"
        "    Item items[5];\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 2);
    // Find Container
    int contIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("Container") && tree.nodes[i].parentId == 0) {
            contIdx = i; break;
        }
    }
    QVERIFY(contIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[contIdx].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Array);
    QCOMPARE(tree.nodes[kids[0]].arrayLen, 5);
    QCOMPARE(tree.nodes[kids[0]].elementKind, NodeKind::Struct);
}

void TestImportSource::commentOffsets() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Offsets {\n"
        "    uint64_t vtable; // 0x0\n"
        "    float health; // 0x8\n"
        "    uint8_t _pad000C[0x4]; // 0xC\n"
        "    double score; // 0x10\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    // vtable at 0x0
    QCOMPARE(tree.nodes[kids[0]].offset, 0);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt64);
    // health at 0x8
    QCOMPARE(tree.nodes[kids[1]].offset, 8);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Float);
    // _pad at 0xC -> hex nodes
    // score at 0x10
    // Find the double
    bool foundDouble = false;
    for (int k : kids) {
        if (tree.nodes[k].kind == NodeKind::Double) {
            QCOMPARE(tree.nodes[k].offset, 0x10);
            foundDouble = true;
        }
    }
    QVERIFY(foundDouble);
}

void TestImportSource::computedOffsets() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Computed {\n"
        "    uint8_t a;\n"
        "    uint16_t b;\n"
        "    uint32_t c;\n"
        "    uint64_t d;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 4);
    QCOMPARE(tree.nodes[kids[0]].offset, 0);  // uint8_t at 0
    QCOMPARE(tree.nodes[kids[1]].offset, 1);  // uint16_t at 1
    QCOMPARE(tree.nodes[kids[2]].offset, 3);  // uint32_t at 3
    QCOMPARE(tree.nodes[kids[3]].offset, 7);  // uint64_t at 7
}

void TestImportSource::mixedOffsetsAutoDetect() {
    // If any field has a comment offset, all should use comment mode
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Mixed {\n"
        "    uint32_t a; // 0x0\n"
        "    uint32_t b;\n"
        "    uint32_t c; // 0x10\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(tree.nodes[kids[0]].offset, 0);
    // b has no comment offset, in comment mode it gets computed offset 4
    QCOMPARE(tree.nodes[kids[1]].offset, 4);
    // c has comment offset 0x10
    QCOMPARE(tree.nodes[kids[2]].offset, 0x10);
}

void TestImportSource::multiStruct() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct A {\n"
        "    int x;\n"
        "};\n"
        "struct B {\n"
        "    float y;\n"
        "};\n"
        "struct C {\n"
        "    double z;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 3);
}

void TestImportSource::pointerCrossRef() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct A {\n"
        "    int value;\n"
        "};\n"
        "struct B {\n"
        "    A* ref;\n"
        "};\n"
    ));
    // Find B's pointer field
    int bIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("B") && tree.nodes[i].parentId == 0) {
            bIdx = i; break;
        }
    }
    QVERIFY(bIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[bIdx].id);
    QCOMPARE(kids.size(), 1);
    QVERIFY(tree.nodes[kids[0]].refId != 0);
    // Should point to A
    int aIdx = tree.indexOfId(tree.nodes[kids[0]].refId);
    QVERIFY(aIdx >= 0);
    QCOMPARE(tree.nodes[aIdx].name, QStringLiteral("A"));
}

void TestImportSource::forwardDeclaration() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Bar;\n"
        "struct Foo {\n"
        "    Bar* pBar;\n"
        "};\n"
        "struct Bar {\n"
        "    int val;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 2);
    // Foo's pBar should resolve to Bar
    int fooIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("Foo") && tree.nodes[i].parentId == 0) {
            fooIdx = i; break;
        }
    }
    QVERIFY(fooIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[fooIdx].id);
    QCOMPARE(kids.size(), 1);
    QVERIFY(tree.nodes[kids[0]].refId != 0);
}

void TestImportSource::unionContainer() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct WithUnion {\n"
        "    union {\n"
        "        float asFloat;\n"
        "        uint32_t asInt;\n"
        "    };\n"
        "    int after;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    // Should have 2 direct children: union container + after
    QCOMPARE(kids.size(), 2);

    // First child is the union container
    const auto& unionNode = tree.nodes[kids[0]];
    QCOMPARE(unionNode.kind, NodeKind::Struct);
    QCOMPARE(unionNode.classKeyword, QStringLiteral("union"));
    QCOMPARE(unionNode.offset, 0);

    // Union has 2 children, both at offset 0
    auto unionKids = childrenOf(tree, unionNode.id);
    QCOMPARE(unionKids.size(), 2);
    QCOMPARE(tree.nodes[unionKids[0]].kind, NodeKind::Float);
    QCOMPARE(tree.nodes[unionKids[0]].name, QStringLiteral("asFloat"));
    QCOMPARE(tree.nodes[unionKids[0]].offset, 0);
    QCOMPARE(tree.nodes[unionKids[1]].kind, NodeKind::UInt32);
    QCOMPARE(tree.nodes[unionKids[1]].name, QStringLiteral("asInt"));
    QCOMPARE(tree.nodes[unionKids[1]].offset, 0);

    // structSpan of union = max member size = 4
    QCOMPARE(tree.structSpan(unionNode.id), 4);

    // after field follows the union at offset 4
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Int32);
    QCOMPARE(tree.nodes[kids[1]].name, QStringLiteral("after"));
    QCOMPARE(tree.nodes[kids[1]].offset, 4);
}

void TestImportSource::unionWithCommentOffsets() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct S {\n"
        "    uint64_t a; // 0x0\n"
        "    union {\n"
        "        uint32_t x; // 0x8\n"
        "        float y; // 0x8\n"
        "    };\n"
        "    uint32_t b; // 0xC\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 3); // a + union + b

    // Union at offset 0x8
    const auto& unionNode = tree.nodes[kids[1]];
    QCOMPARE(unionNode.kind, NodeKind::Struct);
    QCOMPARE(unionNode.classKeyword, QStringLiteral("union"));
    QCOMPARE(unionNode.offset, 0x8);

    // Union members at offset 0 (relative to union)
    auto unionKids = childrenOf(tree, unionNode.id);
    QCOMPARE(unionKids.size(), 2);
    QCOMPARE(tree.nodes[unionKids[0]].offset, 0);
    QCOMPARE(tree.nodes[unionKids[1]].offset, 0);

    // b at 0xC
    QCOMPARE(tree.nodes[kids[2]].offset, 0xC);
}

void TestImportSource::namedUnion() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct S {\n"
        "    union {\n"
        "        uint16_t shortVal;\n"
        "        uint64_t longVal;\n"
        "    } u3;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);

    const auto& unionNode = tree.nodes[kids[0]];
    QCOMPARE(unionNode.kind, NodeKind::Struct);
    QCOMPARE(unionNode.classKeyword, QStringLiteral("union"));
    QCOMPARE(unionNode.name, QStringLiteral("u3"));

    auto unionKids = childrenOf(tree, unionNode.id);
    QCOMPARE(unionKids.size(), 2);
    // structSpan = max(2, 8) = 8
    QCOMPARE(tree.structSpan(unionNode.id), 8);
}

void TestImportSource::paddingFieldExpansion() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Padded {\n"
        "    uint8_t _pad0000[0x10];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    // 0x10 = 16 bytes, should be 2x Hex64 (best fit)
    QCOMPARE(kids.size(), 2);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Hex64);
    QCOMPARE(tree.nodes[kids[0]].offset, 0);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Hex64);
    QCOMPARE(tree.nodes[kids[1]].offset, 8);
}

void TestImportSource::staticAssertTailPadding() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Sized {\n"
        "    uint32_t x;\n"
        "};\n"
        "static_assert(sizeof(Sized) == 0x10, \"Size check\");\n"
    ));
    // x is 4 bytes, static_assert says 0x10 = 16
    // Should have tail padding from offset 4 to 16 (12 bytes)
    int span = tree.structSpan(tree.nodes[0].id);
    QCOMPARE(span, 0x10);
}

void TestImportSource::embeddedStruct() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Inner {\n"
        "    int a;\n"
        "};\n"
        "struct Outer {\n"
        "    Inner embedded;\n"
        "    float after;\n"
        "};\n"
    ));
    int outerIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("Outer") && tree.nodes[i].parentId == 0) {
            outerIdx = i; break;
        }
    }
    QVERIFY(outerIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[outerIdx].id);
    QCOMPARE(kids.size(), 2);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Struct);
    QCOMPARE(tree.nodes[kids[0]].structTypeName, QStringLiteral("Inner"));
    QVERIFY(tree.nodes[kids[0]].refId != 0);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Float);
}

void TestImportSource::typedefBasic() {
    NodeTree tree = importFromSource(QStringLiteral(
        "typedef uint32_t MyInt;\n"
        "struct TD {\n"
        "    MyInt value;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt32);
}

void TestImportSource::constVolatileQualifiers() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Quals {\n"
        "    const uint32_t a;\n"
        "    volatile int32_t b;\n"
        "    const volatile uint8_t c;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 3);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt32);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Int32);
    QCOMPARE(tree.nodes[kids[2]].kind, NodeKind::UInt8);
}

void TestImportSource::structPrefixOnType() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Inner {\n"
        "    int val;\n"
        "};\n"
        "struct Outer {\n"
        "    struct Inner member;\n"
        "};\n"
    ));
    int outerIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("Outer") && tree.nodes[i].parentId == 0) {
            outerIdx = i; break;
        }
    }
    QVERIFY(outerIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[outerIdx].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Struct);
    QCOMPARE(tree.nodes[kids[0]].structTypeName, QStringLiteral("Inner"));
}

void TestImportSource::bitfieldSkipped() {
    // Bitfields emit a hex placeholder covering the group
    NodeTree tree = importFromSource(QStringLiteral(
        "struct BF {\n"
        "    uint32_t normal;\n"
        "    uint32_t bitA : 4;\n"
        "    uint32_t bitB : 12;\n"
        "    uint32_t after;\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    // normal + Hex16 (16 bits → 2 bytes) + after
    QCOMPARE(kids.size(), 3);
    QCOMPARE(tree.nodes[kids[0]].name, QStringLiteral("normal"));
    QCOMPARE(tree.nodes[kids[0]].offset, 0);
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Hex16);
    QCOMPARE(tree.nodes[kids[1]].offset, 4);
    QCOMPARE(tree.nodes[kids[2]].name, QStringLiteral("after"));
    QCOMPARE(tree.nodes[kids[2]].offset, 6);
}

void TestImportSource::bitfieldWithOffsetsEmitsHex() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct BF2 {\n"
        "    uint32_t normal; // 0x0\n"
        "    ULONGLONG Valid : 1; // 0x4\n"
        "    ULONGLONG Dirty : 1; // 0x4\n"
        "    ULONGLONG PageFrameNumber : 36; // 0x4\n"
        "    ULONGLONG Reserved : 26; // 0x4\n"
        "    uint32_t after; // 0xC\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    // normal + hex64 (bitfield group: 64 bits) + after = 3
    QCOMPARE(kids.size(), 3);
    QCOMPARE(tree.nodes[kids[0]].name, QStringLiteral("normal"));
    QCOMPARE(tree.nodes[kids[0]].offset, 0);
    // Bitfield group emitted as Hex64 at offset 4
    QCOMPARE(tree.nodes[kids[1]].kind, NodeKind::Hex64);
    QCOMPARE(tree.nodes[kids[1]].offset, 4);
    // after at 0xC
    QCOMPARE(tree.nodes[kids[2]].name, QStringLiteral("after"));
    QCOMPARE(tree.nodes[kids[2]].offset, 0xC);
}

void TestImportSource::hexArraySizes() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct HexArr {\n"
        "    uint8_t data[0x20];\n"
        "};\n"
    ));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Array);
    QCOMPARE(tree.nodes[kids[0]].arrayLen, 0x20);
}

void TestImportSource::windowsStylePEB() {
    // Test with Windows PEB-style struct (no comment offsets)
    NodeTree tree = importFromSource(QStringLiteral(
        "struct PEB64 {\n"
        "    BOOLEAN InheritedAddressSpace;\n"
        "    BOOLEAN ReadImageFileExecOptions;\n"
        "    BOOLEAN BeingDebugged;\n"
        "    BOOLEAN BitField;\n"
        "    PVOID Mutant;\n"
        "    PVOID ImageBaseAddress;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 1);
    QCOMPARE(tree.nodes[0].name, QStringLiteral("PEB64"));
    auto kids = childrenOf(tree, tree.nodes[0].id);
    QCOMPARE(kids.size(), 6);
    // First 4 are BOOLEAN (UInt8)
    for (int i = 0; i < 4; i++)
        QCOMPARE(tree.nodes[kids[i]].kind, NodeKind::UInt8);
    // Last 2 are PVOID (Pointer64)
    QCOMPARE(tree.nodes[kids[4]].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[kids[5]].kind, NodeKind::Pointer64);
}

void TestImportSource::classKeyword() {
    NodeTree tree = importFromSource(QStringLiteral(
        "class MyClass {\n"
        "    int value;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 1);
    QCOMPARE(tree.nodes[0].classKeyword, QStringLiteral("class"));
}

void TestImportSource::inheritanceSkipped() {
    NodeTree tree = importFromSource(QStringLiteral(
        "struct Base {\n"
        "    int a;\n"
        "};\n"
        "struct Derived : public Base {\n"
        "    float b;\n"
        "};\n"
    ));
    QCOMPARE(countRoots(tree), 2);
    int derivedIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("Derived") && tree.nodes[i].parentId == 0) {
            derivedIdx = i; break;
        }
    }
    QVERIFY(derivedIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[derivedIdx].id);
    QCOMPARE(kids.size(), 1);
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::Float);
}

void TestImportSource::basicRoundTrip() {
    // Build a simple tree manually, export it, then re-import and compare
    NodeTree original;
    {
        Node s;
        s.kind = NodeKind::Struct;
        s.name = QStringLiteral("RoundTrip");
        s.structTypeName = QStringLiteral("RoundTrip");
        s.parentId = 0;
        s.offset = 0;
        int sIdx = original.addNode(s);
        uint64_t sId = original.nodes[sIdx].id;

        Node f1;
        f1.kind = NodeKind::UInt32;
        f1.name = QStringLiteral("field_a");
        f1.parentId = sId;
        f1.offset = 0;
        original.addNode(f1);

        Node f2;
        f2.kind = NodeKind::Float;
        f2.name = QStringLiteral("field_b");
        f2.parentId = sId;
        f2.offset = 4;
        original.addNode(f2);

        Node f3;
        f3.kind = NodeKind::UInt64;
        f3.name = QStringLiteral("field_c");
        f3.parentId = sId;
        f3.offset = 8;
        original.addNode(f3);
    }

    // Create source text that matches what generator would produce
    QString source = QStringLiteral(
        "struct RoundTrip {\n"
        "    uint32_t field_a; // 0x0\n"
        "    float field_b; // 0x4\n"
        "    uint64_t field_c; // 0x8\n"
        "};\n"
        "static_assert(sizeof(RoundTrip) == 0x10, \"Size mismatch\");\n"
    );

    NodeTree reimported = importFromSource(source);
    QCOMPARE(countRoots(reimported), 1);
    QCOMPARE(reimported.nodes[0].name, QStringLiteral("RoundTrip"));

    auto origKids = childrenOf(original, original.nodes[0].id);
    auto reimpKids = childrenOf(reimported, reimported.nodes[0].id);

    // Compare field count (reimported may have extra padding nodes from static_assert)
    // Check that the first 3 fields match
    QVERIFY(reimpKids.size() >= 3);
    for (int i = 0; i < 3; i++) {
        QCOMPARE(reimported.nodes[reimpKids[i]].kind, original.nodes[origKids[i]].kind);
        QCOMPARE(reimported.nodes[reimpKids[i]].name, original.nodes[origKids[i]].name);
        QCOMPARE(reimported.nodes[reimpKids[i]].offset, original.nodes[origKids[i]].offset);
    }
}

// ── Enum tests ──

void TestImportSource::enumBasic() {
    auto tree = importFromSource(QStringLiteral(
        "enum Color { Red = 0, Green = 1, Blue = 2 };"));
    QCOMPARE(countRoots(tree), 1);
    QCOMPARE(tree.nodes[0].classKeyword, QStringLiteral("enum"));
    QCOMPARE(tree.nodes[0].structTypeName, QStringLiteral("Color"));
    QCOMPARE(tree.nodes[0].enumMembers.size(), 3);
    QCOMPARE(tree.nodes[0].enumMembers[0].first, QStringLiteral("Red"));
    QCOMPARE(tree.nodes[0].enumMembers[0].second, 0LL);
    QCOMPARE(tree.nodes[0].enumMembers[1].first, QStringLiteral("Green"));
    QCOMPARE(tree.nodes[0].enumMembers[1].second, 1LL);
    QCOMPARE(tree.nodes[0].enumMembers[2].first, QStringLiteral("Blue"));
    QCOMPARE(tree.nodes[0].enumMembers[2].second, 2LL);
}

void TestImportSource::enumAutoValues() {
    auto tree = importFromSource(QStringLiteral(
        "enum Flags { A, B, C };"));
    QCOMPARE(tree.nodes[0].enumMembers.size(), 3);
    QCOMPARE(tree.nodes[0].enumMembers[0].second, 0LL);
    QCOMPARE(tree.nodes[0].enumMembers[1].second, 1LL);
    QCOMPARE(tree.nodes[0].enumMembers[2].second, 2LL);
}

void TestImportSource::enumHexValues() {
    auto tree = importFromSource(QStringLiteral(
        "enum { X = 0x10, Y = 0x20 };"));
    // Anonymous enum has no name — parser skips it (unnamed enums are not added)
    // Actually, let's use a named enum with hex values
    tree = importFromSource(QStringLiteral(
        "enum Hex { X = 0x10, Y = 0x20 };"));
    QCOMPARE(tree.nodes[0].enumMembers.size(), 2);
    QCOMPARE(tree.nodes[0].enumMembers[0].second, 0x10LL);
    QCOMPARE(tree.nodes[0].enumMembers[1].second, 0x20LL);
}

void TestImportSource::enumInStruct() {
    auto tree = importFromSource(QStringLiteral(
        "enum PoolType { NonPaged = 0, Paged = 1 };\n"
        "struct Foo {\n"
        "    PoolType pool; //0x0\n"
        "    uint32_t size; //0x4\n"
        "};"));
    // Should have 2 roots: PoolType enum + Foo struct
    QCOMPARE(countRoots(tree), 2);

    // Find Foo struct
    int fooIdx = -1;
    for (int i = 0; i < tree.nodes.size(); i++) {
        if (tree.nodes[i].name == QStringLiteral("Foo")) { fooIdx = i; break; }
    }
    QVERIFY(fooIdx >= 0);
    auto kids = childrenOf(tree, tree.nodes[fooIdx].id);
    QCOMPARE(kids.size(), 2);
    // First child should be UInt32 (enum mapped to int) with refId to PoolType
    QCOMPARE(tree.nodes[kids[0]].kind, NodeKind::UInt32);
    QCOMPARE(tree.nodes[kids[0]].name, QStringLiteral("pool"));
    QVERIFY(tree.nodes[kids[0]].refId != 0); // linked to enum definition
}

void TestImportSource::enumClass() {
    auto tree = importFromSource(QStringLiteral(
        "enum class Scope : uint8_t { A = 1, B = 2 };"));
    QCOMPARE(countRoots(tree), 1);
    QCOMPARE(tree.nodes[0].classKeyword, QStringLiteral("enum"));
    QCOMPARE(tree.nodes[0].structTypeName, QStringLiteral("Scope"));
    QCOMPARE(tree.nodes[0].enumMembers.size(), 2);
    QCOMPARE(tree.nodes[0].enumMembers[0].first, QStringLiteral("A"));
    QCOMPARE(tree.nodes[0].enumMembers[0].second, 1LL);
}

QTEST_MAIN(TestImportSource)
#include "test_import_source.moc"

```

`tests/test_import_xml.cpp`:

```cpp
#include <QtTest/QtTest>
#include "core.h"
#include "imports/import_reclass_xml.h"

using namespace rcx;

class TestImportXml : public QObject {
    Q_OBJECT
private slots:
    void importSmallXml();
};

void TestImportXml::importSmallXml() {
    // Create a minimal XML in a temp file and test parsing
    QTemporaryFile tmp;
    tmp.setAutoRemove(true);
    QVERIFY(tmp.open());
    tmp.write(R"(<?xml version="1.0" encoding="UTF-8"?>
<ReClass>
    <!--ReClassEx-->
    <Class Name="TestClass" Type="28" Comment="" Offset="0" strOffset="0" Code="">
        <Node Name="vtable" Type="9" Size="8" bHidden="false" Comment=""/>
        <Node Name="health" Type="13" Size="4" bHidden="false" Comment=""/>
        <Node Name="name" Type="18" Size="32" bHidden="false" Comment=""/>
        <Node Name="position" Type="23" Size="12" bHidden="false" Comment=""/>
        <Node Name="pNext" Type="8" Size="8" bHidden="false" Comment="" Pointer="TestClass"/>
    </Class>
</ReClass>
)");
    tmp.flush();

    QString error;
    NodeTree tree = importReclassXml(tmp.fileName(), &error);
    QVERIFY2(!tree.nodes.isEmpty(), qPrintable(error));

    // Should have 1 root struct + 5 children = 6 nodes
    QCOMPARE(tree.nodes.size(), 6);

    // Root struct
    QCOMPARE(tree.nodes[0].kind, NodeKind::Struct);
    QCOMPARE(tree.nodes[0].name, QStringLiteral("TestClass"));

    // vtable = Int64
    QCOMPARE(tree.nodes[1].kind, NodeKind::Int64);
    QCOMPARE(tree.nodes[1].name, QStringLiteral("vtable"));
    QCOMPARE(tree.nodes[1].offset, 0);

    // health = Float
    QCOMPARE(tree.nodes[2].kind, NodeKind::Float);
    QCOMPARE(tree.nodes[2].name, QStringLiteral("health"));
    QCOMPARE(tree.nodes[2].offset, 8);

    // name = UTF8 with strLen=32
    QCOMPARE(tree.nodes[3].kind, NodeKind::UTF8);
    QCOMPARE(tree.nodes[3].strLen, 32);
    QCOMPARE(tree.nodes[3].offset, 12);

    // position = Vec3
    QCOMPARE(tree.nodes[4].kind, NodeKind::Vec3);
    QCOMPARE(tree.nodes[4].offset, 44);

    // pNext = Pointer64 with resolved refId
    QCOMPARE(tree.nodes[5].kind, NodeKind::Pointer64);
    QCOMPARE(tree.nodes[5].name, QStringLiteral("pNext"));
    QVERIFY(tree.nodes[5].refId != 0);
    QCOMPARE(tree.nodes[5].refId, tree.nodes[0].id); // points to TestClass
}

QTEST_MAIN(TestImportXml)
#include "test_import_xml.moc"

```

`tests/test_new_features.cpp`:

```cpp
#include <QtTest/QTest>
#include <QJsonDocument>
#include <QJsonObject>
#include <QTemporaryFile>
#include <QStandardItemModel>
#include "core.h"
#include "generator.h"
#include "controller.h"
#include "workspace_model.h"

using namespace rcx;

class TestNewFeatures : public QObject {
    Q_OBJECT

private:
    NodeTree makeSimpleTree() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Player";
        root.structTypeName = "Player";
        root.parentId = 0;
        root.offset = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node f1;
        f1.kind = NodeKind::Int32;
        f1.name = "health";
        f1.parentId = rootId;
        f1.offset = 0;
        tree.addNode(f1);

        Node f2;
        f2.kind = NodeKind::Float;
        f2.name = "speed";
        f2.parentId = rootId;
        f2.offset = 4;
        tree.addNode(f2);

        return tree;
    }

    NodeTree makeTwoRootTree() {
        NodeTree tree;
        tree.baseAddress = 0;

        // Root struct A
        Node a;
        a.kind = NodeKind::Struct;
        a.name = "Alpha";
        a.structTypeName = "Alpha";
        a.parentId = 0;
        a.offset = 0;
        int ai = tree.addNode(a);
        uint64_t aId = tree.nodes[ai].id;

        Node af;
        af.kind = NodeKind::UInt32;
        af.name = "flagsA";
        af.parentId = aId;
        af.offset = 0;
        tree.addNode(af);

        // Root struct B
        Node b;
        b.kind = NodeKind::Struct;
        b.name = "Bravo";
        b.structTypeName = "Bravo";
        b.parentId = 0;
        b.offset = 0x100;
        int bi = tree.addNode(b);
        uint64_t bId = tree.nodes[bi].id;

        Node bf;
        bf.kind = NodeKind::UInt64;
        bf.name = "flagsB";
        bf.parentId = bId;
        bf.offset = 0;
        tree.addNode(bf);

        return tree;
    }

    NodeTree makeRichTree() {
        NodeTree tree;
        tree.baseAddress = 0x00400000;

        // ── Pet (root struct) ──
        Node pet;
        pet.kind = NodeKind::Struct;
        pet.name = "Pet";
        pet.structTypeName = "Pet";
        pet.parentId = 0;
        pet.offset = 0;
        int pi = tree.addNode(pet);
        uint64_t petId = tree.nodes[pi].id;

        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_00"; n.parentId = petId; n.offset = 0;  tree.addNode(n); }
        { Node n; n.kind = NodeKind::UTF8;      n.name = "name";   n.parentId = petId; n.offset = 8;  n.strLen = 16; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_18"; n.parentId = petId; n.offset = 24; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex32;     n.name = "hex_20"; n.parentId = petId; n.offset = 32; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex32;     n.name = "hex_24"; n.parentId = petId; n.offset = 36; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Pointer64; n.name = "owner";  n.parentId = petId; n.offset = 40; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_30"; n.parentId = petId; n.offset = 48; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_38"; n.parentId = petId; n.offset = 56; tree.addNode(n); }

        // ── Cat (root struct, "inherits" Pet via nested struct) ──
        Node cat;
        cat.kind = NodeKind::Struct;
        cat.name = "Cat";
        cat.structTypeName = "Cat";
        cat.parentId = 0;
        cat.offset = 0;
        int ci = tree.addNode(cat);
        uint64_t catId = tree.nodes[ci].id;

        // base = embedded Pet (nested struct child at offset 0)
        Node base;
        base.kind = NodeKind::Struct;
        base.name = "base";
        base.structTypeName = "Pet";
        base.parentId = catId;
        base.offset = 0;
        int bi = tree.addNode(base);
        uint64_t baseId = tree.nodes[bi].id;

        // Children inside the nested Pet base
        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_00"; n.parentId = baseId; n.offset = 0;  tree.addNode(n); }
        { Node n; n.kind = NodeKind::UTF8;      n.name = "name";   n.parentId = baseId; n.offset = 8;  n.strLen = 16; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_18"; n.parentId = baseId; n.offset = 24; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Pointer64; n.name = "owner";  n.parentId = baseId; n.offset = 32; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;     n.name = "hex_28"; n.parentId = baseId; n.offset = 40; tree.addNode(n); }

        // Cat's own fields after base
        { Node n; n.kind = NodeKind::Hex64; n.name = "hex_30";     n.parentId = catId; n.offset = 48; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64; n.name = "hex_38";     n.parentId = catId; n.offset = 56; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Float; n.name = "whiskerLen"; n.parentId = catId; n.offset = 64; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex32; n.name = "hex_44";     n.parentId = catId; n.offset = 68; tree.addNode(n); }
        { Node n; n.kind = NodeKind::UInt8; n.name = "lives";      n.parentId = catId; n.offset = 72; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex8;  n.name = "hex_49";     n.parentId = catId; n.offset = 73; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex16; n.name = "hex_4A";     n.parentId = catId; n.offset = 74; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex32; n.name = "hex_4C";     n.parentId = catId; n.offset = 76; tree.addNode(n); }

        // ── Ball (independent root struct) ──
        Node ball;
        ball.kind = NodeKind::Struct;
        ball.name = "Ball";
        ball.structTypeName = "Ball";
        ball.parentId = 0;
        ball.offset = 0;
        int bli = tree.addNode(ball);
        uint64_t ballId = tree.nodes[bli].id;

        { Node n; n.kind = NodeKind::Hex64;  n.name = "hex_00";   n.parentId = ballId; n.offset = 0;  tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;  n.name = "hex_08";   n.parentId = ballId; n.offset = 8;  tree.addNode(n); }
        { Node n; n.kind = NodeKind::Float;  n.name = "speed";    n.parentId = ballId; n.offset = 16; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex32;  n.name = "hex_14";   n.parentId = ballId; n.offset = 20; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;  n.name = "hex_18";   n.parentId = ballId; n.offset = 24; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Vec4;   n.name = "position"; n.parentId = ballId; n.offset = 32; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;  n.name = "hex_30";   n.parentId = ballId; n.offset = 48; tree.addNode(n); }
        { Node n; n.kind = NodeKind::UInt32; n.name = "color";    n.parentId = ballId; n.offset = 56; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex32;  n.name = "hex_3C";   n.parentId = ballId; n.offset = 60; tree.addNode(n); }
        { Node n; n.kind = NodeKind::Hex64;  n.name = "hex_40";   n.parentId = ballId; n.offset = 64; tree.addNode(n); }

        return tree;
    }

private slots:

    // ═══════════════════════════════════════════════════
    // Feature 1: Type Aliases
    // ═══════════════════════════════════════════════════

    void testResolveTypeName_noAlias() {
        RcxDocument doc;
        // No aliases set — should return default type name
        QString name = doc.resolveTypeName(NodeKind::Int32);
        QCOMPARE(name, QString("int32_t"));

        name = doc.resolveTypeName(NodeKind::Float);
        QCOMPARE(name, QString("float"));

        name = doc.resolveTypeName(NodeKind::Hex64);
        QCOMPARE(name, QString("hex64"));
    }

    void testResolveTypeName_withAlias() {
        RcxDocument doc;
        doc.typeAliases[NodeKind::Int32] = "DWORD";
        doc.typeAliases[NodeKind::Float] = "FLOAT";

        QCOMPARE(doc.resolveTypeName(NodeKind::Int32), QString("DWORD"));
        QCOMPARE(doc.resolveTypeName(NodeKind::Float), QString("FLOAT"));
        // Non-aliased types still return default
        QCOMPARE(doc.resolveTypeName(NodeKind::UInt64), QString("uint64_t"));
    }

    void testResolveTypeName_emptyAlias() {
        RcxDocument doc;
        doc.typeAliases[NodeKind::Int32] = "";  // empty alias should be ignored
        QCOMPARE(doc.resolveTypeName(NodeKind::Int32), QString("int32_t"));
    }

    void testTypeAliases_saveLoad() {
        // Save a document with type aliases, reload, verify aliases persist
        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        QString path = tmpFile.fileName();
        tmpFile.close();

        // Create document with aliases and save
        {
            RcxDocument doc;
            doc.tree = makeSimpleTree();
            doc.typeAliases[NodeKind::Int32] = "DWORD";
            doc.typeAliases[NodeKind::Float] = "FLOAT";
            QVERIFY(doc.save(path));
        }

        // Reload and check aliases
        {
            RcxDocument doc;
            QVERIFY(doc.load(path));
            QCOMPARE(doc.typeAliases.size(), 2);
            QCOMPARE(doc.typeAliases.value(NodeKind::Int32), QString("DWORD"));
            QCOMPARE(doc.typeAliases.value(NodeKind::Float), QString("FLOAT"));
        }
    }

    void testTypeAliases_saveLoadEmpty() {
        // Save without aliases, reload, verify no aliases
        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        QString path = tmpFile.fileName();
        tmpFile.close();

        {
            RcxDocument doc;
            doc.tree = makeSimpleTree();
            QVERIFY(doc.save(path));
        }

        {
            RcxDocument doc;
            QVERIFY(doc.load(path));
            QVERIFY(doc.typeAliases.isEmpty());
        }
    }

    void testTypeAliases_jsonFormat() {
        // Verify the JSON format of saved aliases
        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        QString path = tmpFile.fileName();
        tmpFile.close();

        RcxDocument doc;
        doc.tree = makeSimpleTree();
        doc.typeAliases[NodeKind::UInt32] = "UINT";
        QVERIFY(doc.save(path));

        // Read raw JSON
        QFile file(path);
        QVERIFY(file.open(QIODevice::ReadOnly));
        QJsonDocument jdoc = QJsonDocument::fromJson(file.readAll());
        QJsonObject root = jdoc.object();

        QVERIFY(root.contains("typeAliases"));
        QJsonObject aliases = root["typeAliases"].toObject();
        QCOMPARE(aliases["UInt32"].toString(), QString("UINT"));
    }

    void testGenerator_typeAliases() {
        // Generator should use aliases for field types
        auto tree = makeSimpleTree();
        uint64_t rootId = tree.nodes[0].id;

        QHash<NodeKind, QString> aliases;
        aliases[NodeKind::Int32] = "LONG";
        aliases[NodeKind::Float] = "FLOAT";

        QString result = renderCpp(tree, rootId, &aliases);

        QVERIFY(result.contains("LONG health;"));
        QVERIFY(result.contains("FLOAT speed;"));
        // struct keyword itself should not be aliased
        QVERIFY(result.contains("struct Player {"));
    }

    void testGenerator_typeAliases_null() {
        // With nullptr aliases, should behave like before
        auto tree = makeSimpleTree();
        uint64_t rootId = tree.nodes[0].id;

        QString result = renderCpp(tree, rootId, nullptr);
        QVERIFY(result.contains("int32_t health;"));
        QVERIFY(result.contains("float speed;"));
    }

    void testGenerator_typeAliases_array() {
        // Array element type should use alias
        NodeTree tree;
        Node root;
        root.kind = NodeKind::Struct;
        root.name = "ArrTest";
        root.structTypeName = "ArrTest";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node arr;
        arr.kind = NodeKind::Array;
        arr.name = "data";
        arr.parentId = rootId;
        arr.offset = 0;
        arr.arrayLen = 16;
        arr.elementKind = NodeKind::UInt32;
        tree.addNode(arr);

        QHash<NodeKind, QString> aliases;
        aliases[NodeKind::UInt32] = "DWORD";

        QString result = renderCpp(tree, rootId, &aliases);
        QVERIFY(result.contains("DWORD data[16];"));
    }

    void testGenerator_renderCppAll_typeAliases() {
        auto tree = makeTwoRootTree();

        QHash<NodeKind, QString> aliases;
        aliases[NodeKind::UInt32] = "DWORD";
        aliases[NodeKind::UInt64] = "QWORD";

        QString result = renderCppAll(tree, &aliases);
        QVERIFY(result.contains("DWORD flagsA;"));
        QVERIFY(result.contains("QWORD flagsB;"));
    }

    // ═══════════════════════════════════════════════════
    // Feature 3: Per-Window View Root Class
    // ═══════════════════════════════════════════════════

    void testCompose_viewRootId_zero() {
        // viewRootId=0 should show all roots (same as default)
        auto tree = makeTwoRootTree();

        NullProvider prov;
        ComposeResult result = compose(tree, prov, 0);

        // Should have content from both structs
        QStringList lines = result.text.split('\n');
        bool foundFlagsA = false, foundFlagsB = false;
        for (const QString& l : lines) {
            if (l.contains("flagsA")) foundFlagsA = true;
            if (l.contains("flagsB")) foundFlagsB = true;
        }
        QVERIFY2(foundFlagsA, "viewRootId=0 should include Alpha struct");
        QVERIFY2(foundFlagsB, "viewRootId=0 should include Bravo struct");
    }

    void testCompose_viewRootId_filter() {
        // viewRootId set to Alpha's id should only show Alpha's fields
        auto tree = makeTwoRootTree();
        uint64_t alphaId = tree.nodes[0].id;

        NullProvider prov;
        ComposeResult result = compose(tree, prov, alphaId);

        QStringList lines = result.text.split('\n');
        bool foundFlagsA = false, foundFlagsB = false;
        for (const QString& l : lines) {
            if (l.contains("flagsA")) foundFlagsA = true;
            if (l.contains("flagsB")) foundFlagsB = true;
        }
        QVERIFY2(foundFlagsA, "viewRootId=Alpha should include Alpha's fields");
        QVERIFY2(!foundFlagsB, "viewRootId=Alpha should NOT include Bravo's fields");
    }

    void testCompose_viewRootId_otherRoot() {
        // viewRootId set to Bravo's id should only show Bravo's fields
        auto tree = makeTwoRootTree();
        uint64_t bravoId = tree.nodes[2].id;  // Bravo is the 3rd node (index 2)

        NullProvider prov;
        ComposeResult result = compose(tree, prov, bravoId);

        QStringList lines = result.text.split('\n');
        bool foundFlagsA = false, foundFlagsB = false;
        for (const QString& l : lines) {
            if (l.contains("flagsA")) foundFlagsA = true;
            if (l.contains("flagsB")) foundFlagsB = true;
        }
        QVERIFY2(!foundFlagsA, "viewRootId=Bravo should NOT include Alpha's fields");
        QVERIFY2(foundFlagsB, "viewRootId=Bravo should include Bravo's fields");
    }

    void testCompose_viewRootId_invalid() {
        // viewRootId pointing to non-existent node: should show nothing (only command rows)
        auto tree = makeTwoRootTree();

        NullProvider prov;
        ComposeResult result = compose(tree, prov, 99999);

        // Only command row
        QCOMPARE(result.meta.size(), 1);
        QCOMPARE(result.meta[0].lineKind, LineKind::CommandRow);
    }

    void testCompose_viewRootId_singleRoot() {
        // Single root tree with viewRootId set to that root — should work normally
        auto tree = makeSimpleTree();
        uint64_t rootId = tree.nodes[0].id;

        NullProvider prov;
        ComposeResult full = compose(tree, prov, 0);
        ComposeResult filtered = compose(tree, prov, rootId);

        // Both should have same number of lines (only one root anyway)
        QCOMPARE(full.meta.size(), filtered.meta.size());
    }

    void testDocument_compose_viewRootId() {
        // Test RcxDocument::compose passes viewRootId through
        RcxDocument doc;
        doc.tree = makeTwoRootTree();
        uint64_t alphaId = doc.tree.nodes[0].id;

        ComposeResult fullResult = doc.compose(0);
        ComposeResult filtered = doc.compose(alphaId);

        // Filtered should have fewer lines than full
        QVERIFY(filtered.meta.size() < fullResult.meta.size());

        // Filtered should have Alpha's fields
        bool foundFlagsA = false;
        for (const QString& l : filtered.text.split('\n')) {
            if (l.contains("flagsA")) foundFlagsA = true;
        }
        QVERIFY(foundFlagsA);
    }

    // ═══════════════════════════════════════════════════
    // Feature 2: Project Lifecycle API (document-level)
    // ═══════════════════════════════════════════════════

    void testDocument_saveLoadPreservesData() {
        // Verify save/load round-trip preserves tree + aliases + baseAddress
        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        QString path = tmpFile.fileName();
        tmpFile.close();

        {
            RcxDocument doc;
            doc.tree = makeTwoRootTree();
            doc.tree.baseAddress = 0xDEADBEEF;
            doc.typeAliases[NodeKind::Int32] = "INT";
            QVERIFY(doc.save(path));
        }

        {
            RcxDocument doc;
            QVERIFY(doc.load(path));
            QCOMPARE(doc.tree.baseAddress, (uint64_t)0xDEADBEEF);
            QCOMPARE(doc.tree.nodes.size(), 4);  // 2 roots + 2 fields
            QCOMPARE(doc.typeAliases.value(NodeKind::Int32), QString("INT"));
            QCOMPARE(doc.filePath, path);
            QVERIFY(!doc.modified);
        }
    }

    void testDocument_saveCreatesFile() {
        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        QString path = tmpFile.fileName();
        tmpFile.close();

        RcxDocument doc;
        doc.tree = makeSimpleTree();
        QVERIFY(doc.save(path));
        QCOMPARE(doc.filePath, path);
        QVERIFY(!doc.modified);

        // Verify file exists and is valid JSON
        QFile file(path);
        QVERIFY(file.open(QIODevice::ReadOnly));
        QJsonDocument jdoc = QJsonDocument::fromJson(file.readAll());
        QVERIFY(!jdoc.isNull());
        QVERIFY(jdoc.object().contains("nodes"));
    }

    void testDocument_loadInvalidPath() {
        RcxDocument doc;
        QVERIFY(!doc.load("/nonexistent/path/file.rcx"));
    }

    // ═══════════════════════════════════════════════════
    // Integration: Type aliases + compose + generator
    // ═══════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════
    // Feature 4: Workspace Model
    // ═══════════════════════════════════════════════════

    void testWorkspace_simpleTree() {
        auto tree = makeSimpleTree();
        QStandardItemModel model;
        QVector<TabInfo> tabs = {{ &tree, "TestProject.rcx", nullptr }};
        buildProjectExplorer(&model, tabs);

        // Single "Project" root
        QCOMPARE(model.rowCount(), 1);
        QStandardItem* project = model.item(0);
        QCOMPARE(project->text(), QString("Project"));

        // 1 type directly under Project: Player (no member fields)
        QCOMPARE(project->rowCount(), 1);
        QVERIFY(project->child(0)->text().contains("Player"));
        QVERIFY(project->child(0)->text().contains("struct"));
        QCOMPARE(project->child(0)->rowCount(), 0);
    }

    void testWorkspace_twoRootTree() {
        auto tree = makeTwoRootTree();
        QStandardItemModel model;
        QVector<TabInfo> tabs = {{ &tree, "TwoRoot.rcx", nullptr }};
        buildProjectExplorer(&model, tabs);

        QCOMPARE(model.rowCount(), 1);
        QStandardItem* project = model.item(0);

        // 2 types sorted alphabetically: Alpha, Bravo (no field children)
        QCOMPARE(project->rowCount(), 2);
        QVERIFY(project->child(0)->text().contains("Alpha"));
        QVERIFY(project->child(1)->text().contains("Bravo"));
        QCOMPARE(project->child(0)->rowCount(), 0);
        QCOMPARE(project->child(1)->rowCount(), 0);
    }

    void testWorkspace_richTree_rootCount() {
        auto tree = makeRichTree();
        QStandardItemModel model;
        QVector<TabInfo> tabs = {{ &tree, "Rich.rcx", nullptr }};
        buildProjectExplorer(&model, tabs);

        QStandardItem* project = model.item(0);
        QCOMPARE(project->rowCount(), 3);  // Ball, Cat, Pet (sorted)
    }

    void testWorkspace_richTree_sorted() {
        auto tree = makeRichTree();
        QStandardItemModel model;
        QVector<TabInfo> tabs = {{ &tree, "Rich.rcx", nullptr }};
        buildProjectExplorer(&model, tabs);

        QStandardItem* project = model.item(0);
        // Sorted alphabetically: Ball, Cat, Pet
        QVERIFY(project->child(0)->text().contains("Ball"));
        QVERIFY(project->child(1)->text().contains("Cat"));
        QVERIFY(project->child(2)->text().contains("Pet"));
        // No member fields under type nodes
        QCOMPARE(project->child(0)->rowCount(), 0);
        QCOMPARE(project->child(1)->rowCount(), 0);
        QCOMPARE(project->child(2)->rowCount(), 0);
    }

    void testWorkspace_emptyTree() {
        NodeTree tree;
        QStandardItemModel model;
        QVector<TabInfo> tabs = {{ &tree, "Empty.rcx", nullptr }};
        buildProjectExplorer(&model, tabs);

        // Still has the "Project" root, just no children
        QCOMPARE(model.rowCount(), 1);
        QCOMPARE(model.item(0)->text(), QString("Project"));
        QCOMPARE(model.item(0)->rowCount(), 0);
    }

    void testWorkspace_structIdRole() {
        auto tree = makeSimpleTree();
        QStandardItemModel model;
        QVector<TabInfo> tabs = {{ &tree, "Test.rcx", nullptr }};
        buildProjectExplorer(&model, tabs);

        QStandardItem* project = model.item(0);
        // Project root has kGroupSentinel
        QCOMPARE(project->data(Qt::UserRole + 1).toULongLong(), kGroupSentinel);

        // Player type item should have structId
        QStandardItem* player = project->child(0);
        QVERIFY(player->data(Qt::UserRole + 1).isValid());
        QVERIFY(player->data(Qt::UserRole + 1).toULongLong() > 0);
        QVERIFY(player->data(Qt::UserRole + 1).toULongLong() != kGroupSentinel);
    }

    // ═══════════════════════════════════════════════════
    // Feature: Double-click navigation (viewRootId + scroll)
    // ═══════════════════════════════════════════════════

    void testDoubleClick_switchToCollapsedClass() {
        // Simulates: Ball is collapsed (hidden). Double-click Ball in workspace
        // → uncollapse, set viewRootId, compose shows only Ball with children.
        RcxDocument doc;
        doc.tree = makeRichTree();

        // Collapse Ball (3rd root struct)
        uint64_t ballId = 0;
        for (auto& node : doc.tree.nodes) {
            if (node.parentId == 0 && node.kind == NodeKind::Struct
                && node.structTypeName == "Ball") {
                node.collapsed = true;
                ballId = node.id;
                break;
            }
        }
        QVERIFY(ballId != 0);

        // Compose with viewRootId=0 should skip collapsed Ball
        {
            NullProvider prov;
            ComposeResult result = compose(doc.tree, prov, 0);
            bool foundSpeed = false;
            for (const auto& lm : result.meta) {
                int ni = lm.nodeIdx;
                if (ni >= 0 && ni < doc.tree.nodes.size()
                    && doc.tree.nodes[ni].name == "speed")
                    foundSpeed = true;
            }
            QVERIFY2(!foundSpeed, "Collapsed Ball's children should not appear with viewRootId=0");
        }

        // Simulate double-click: uncollapse Ball + set viewRootId
        int bi = doc.tree.indexOfId(ballId);
        QVERIFY(bi >= 0);
        doc.tree.nodes[bi].collapsed = false;

        // Compose with viewRootId=Ball should show Ball and its children
        {
            NullProvider prov;
            ComposeResult result = compose(doc.tree, prov, ballId);
            bool foundSpeed = false, foundPosition = false, foundColor = false;
            for (const auto& lm : result.meta) {
                int ni = lm.nodeIdx;
                if (ni < 0 || ni >= doc.tree.nodes.size()) continue;
                const QString& name = doc.tree.nodes[ni].name;
                if (name == "speed")    foundSpeed = true;
                if (name == "position") foundPosition = true;
                if (name == "color")    foundColor = true;
            }
            QVERIFY2(foundSpeed, "Ball's speed field should appear");
            QVERIFY2(foundPosition, "Ball's position field should appear");
            QVERIFY2(foundColor, "Ball's color field should appear");
        }

        // Pet/Cat fields should NOT be in the Ball-filtered result
        {
            NullProvider prov;
            ComposeResult result = compose(doc.tree, prov, ballId);
            bool foundPetField = false;
            for (const auto& lm : result.meta) {
                int ni = lm.nodeIdx;
                if (ni < 0 || ni >= doc.tree.nodes.size()) continue;
                if (doc.tree.nodes[ni].name == "owner") foundPetField = true;
            }
            QVERIFY2(!foundPetField, "Pet's owner should not appear when viewing Ball");
        }
    }

    void testDoubleClick_fieldNavigatesToParentRoot() {
        // Simulates: double-click a field inside Ball → walk up to Ball root,
        // set viewRootId to Ball, and the field should be in the compose output.
        RcxDocument doc;
        doc.tree = makeRichTree();

        // Find Ball's "speed" child
        uint64_t ballId = 0, speedId = 0;
        for (auto& node : doc.tree.nodes) {
            if (node.parentId == 0 && node.structTypeName == "Ball")
                ballId = node.id;
        }
        QVERIFY(ballId != 0);
        for (auto& node : doc.tree.nodes) {
            if (node.parentId == ballId && node.name == "speed")
                speedId = node.id;
        }
        QVERIFY(speedId != 0);

        // Walk up from speed to find root struct (simulating handler logic)
        uint64_t rootId = 0;
        uint64_t cur = speedId;
        while (cur != 0) {
            int idx = doc.tree.indexOfId(cur);
            if (idx < 0) break;
            if (doc.tree.nodes[idx].parentId == 0) { rootId = cur; break; }
            cur = doc.tree.nodes[idx].parentId;
        }
        QCOMPARE(rootId, ballId);

        // Compose with viewRootId=Ball should contain speed
        NullProvider prov;
        ComposeResult result = compose(doc.tree, prov, ballId);
        bool foundSpeed = false;
        for (const auto& lm : result.meta) {
            if (lm.nodeId == speedId) { foundSpeed = true; break; }
        }
        QVERIFY2(foundSpeed, "speed field should be in compose output when viewing its root");
    }

    void testDoubleClick_projectRootShowsAll() {
        // Double-click project root clears viewRootId → all non-collapsed roots shown
        RcxDocument doc;
        doc.tree = makeRichTree();

        // Collapse Ball
        for (auto& node : doc.tree.nodes) {
            if (node.parentId == 0 && node.structTypeName == "Ball")
                node.collapsed = true;
        }

        // viewRootId=0 → Pet and Cat visible, Ball hidden
        NullProvider prov;
        ComposeResult result = compose(doc.tree, prov, 0);
        bool foundOwner = false, foundWhiskerLen = false, foundSpeed = false;
        for (const auto& lm : result.meta) {
            int ni = lm.nodeIdx;
            if (ni < 0 || ni >= doc.tree.nodes.size()) continue;
            const QString& name = doc.tree.nodes[ni].name;
            if (name == "owner")      foundOwner = true;
            if (name == "whiskerLen") foundWhiskerLen = true;
            if (name == "speed")      foundSpeed = true;
        }
        QVERIFY2(foundOwner, "Pet's owner should appear with viewRootId=0");
        QVERIFY2(foundWhiskerLen, "Cat's whiskerLen should appear with viewRootId=0");
        QVERIFY2(!foundSpeed, "Collapsed Ball's speed should not appear with viewRootId=0");
    }

    // ═══════════════════════════════════════════════════
    // Integration: Type aliases + compose + generator
    // ═══════════════════════════════════════════════════

    void testAliasesPreservedThroughSaveReloadCompose() {
        // Full workflow: set aliases, save, reload, compose + generate
        QTemporaryFile tmpFile;
        tmpFile.setAutoRemove(true);
        QVERIFY(tmpFile.open());
        QString path = tmpFile.fileName();
        tmpFile.close();

        auto tree = makeSimpleTree();

        // Save with aliases
        {
            RcxDocument doc;
            doc.tree = tree;
            doc.typeAliases[NodeKind::Int32] = "my_int32";
            doc.typeAliases[NodeKind::Float] = "my_float";
            QVERIFY(doc.save(path));
        }

        // Reload and verify compose + generate work
        {
            RcxDocument doc;
            QVERIFY(doc.load(path));

            // Compose should succeed
            ComposeResult result = doc.compose();
            QVERIFY(result.meta.size() > 0);

            // Generator should use aliases
            uint64_t rootId = doc.tree.nodes[0].id;
            const QHash<NodeKind, QString>* aliases =
                doc.typeAliases.isEmpty() ? nullptr : &doc.typeAliases;
            QString cpp = renderCpp(doc.tree, rootId, aliases);
            QVERIFY(cpp.contains("my_int32 health;"));
            QVERIFY(cpp.contains("my_float speed;"));
        }
    }
    void testVec4SingleLineValue() {
        NodeTree tree;
        tree.baseAddress = 0;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Obj";
        root.parentId = 0;
        int ri = tree.addNode(root);
        uint64_t rootId = tree.nodes[ri].id;

        Node v;
        v.kind = NodeKind::Vec4;
        v.name = "position";
        v.parentId = rootId;
        v.offset = 0;
        tree.addNode(v);

        NullProvider prov;
        ComposeResult result = compose(tree, prov);

        // CommandRow + 1 Vec4 line + footer = 3
        QCOMPARE(result.meta.size(), 3);

        // The Vec4 line (index 1) is a single field line, not continuation
        QCOMPARE(result.meta[1].lineKind, LineKind::Field);
        QCOMPARE(result.meta[1].nodeKind, NodeKind::Vec4);
        QVERIFY(!result.meta[1].isContinuation);

        // Copy text (equivalent to editor's "Copy All as Text")
        QString text = result.text;
        // NullProvider reads 0 for all floats, values are "0.f, 0.f, 0.f, 0.f"
        QVERIFY(text.contains("0.f, 0.f, 0.f, 0.f"));
        // Confirm type, name, and values all on the same line
        QStringList lines = text.split('\n');
        QVERIFY(lines[1].contains("vec4"));
        QVERIFY(lines[1].contains("position"));
        QVERIFY(lines[1].contains("0.f, 0.f, 0.f, 0.f"));
    }
};

QTEST_MAIN(TestNewFeatures)
#include "test_new_features.moc"

```

`tests/test_options_dialog.cpp`:

```cpp
#include <QtTest/QTest>
#include <QApplication>
#include <QComboBox>
#include <QCheckBox>
#include <QTreeWidget>
#include <QStackedWidget>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QGroupBox>
#include <QLineEdit>
#include <QSpinBox>
#include <QLabel>
#include "optionsdialog.h"
#include "themes/thememanager.h"

using namespace rcx;

// Helper: apply the global palette the same way main.cpp does
static void applyGlobalTheme(const Theme& theme) {
    QPalette pal;
    pal.setColor(QPalette::Window,          theme.background);
    pal.setColor(QPalette::WindowText,      theme.text);
    pal.setColor(QPalette::Base,            theme.background);
    pal.setColor(QPalette::AlternateBase,   theme.surface);
    pal.setColor(QPalette::Text,            theme.text);
    pal.setColor(QPalette::Button,          theme.button);
    pal.setColor(QPalette::ButtonText,      theme.text);
    pal.setColor(QPalette::Highlight,       theme.selection);
    pal.setColor(QPalette::HighlightedText, theme.text);
    pal.setColor(QPalette::ToolTipBase,     theme.backgroundAlt);
    pal.setColor(QPalette::ToolTipText,     theme.text);
    pal.setColor(QPalette::Mid,             theme.border);
    pal.setColor(QPalette::Dark,            theme.background);
    pal.setColor(QPalette::Light,           theme.textFaint);
    pal.setColor(QPalette::Link,            theme.indHoverSpan);

    pal.setColor(QPalette::Disabled, QPalette::WindowText,      theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::Text,            theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::ButtonText,      theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::HighlightedText, theme.textMuted);
    pal.setColor(QPalette::Disabled, QPalette::Light,           theme.background);

    qApp->setPalette(pal);
    qApp->setStyleSheet(QString());
}

class TestOptionsDialog : public QObject {
    Q_OBJECT
private slots:

    void initTestCase() {
        // Apply theme palette so dialog inherits real colors
        auto& tm = ThemeManager::instance();
        applyGlobalTheme(tm.current());
    }

    void dialogCreatesAllWidgets() {
        OptionsResult defaults;
        defaults.themeIndex = 0;
        defaults.fontName = "JetBrains Mono";
        defaults.menuBarTitleCase = true;
        defaults.safeMode = false;
        defaults.autoStartMcp = false;

        OptionsDialog dlg(defaults);

        // Core widgets exist
        auto* tree = dlg.findChild<QTreeWidget*>();
        QVERIFY(tree);
        auto* pages = dlg.findChild<QStackedWidget*>();
        QVERIFY(pages);
        QCOMPARE(pages->count(), 3);

        auto* themeCombo = dlg.findChild<QComboBox*>("themeCombo");
        QVERIFY(themeCombo);
        QVERIFY(themeCombo->count() >= 3);

        auto* fontCombo = dlg.findChild<QComboBox*>("fontCombo");
        QVERIFY(fontCombo);
        QCOMPARE(fontCombo->count(), 2);

        auto* showIconCheck = dlg.findChild<QCheckBox*>();
        QVERIFY(showIconCheck);

        auto* buttons = dlg.findChild<QDialogButtonBox*>();
        QVERIFY(buttons);
        QVERIFY(buttons->button(QDialogButtonBox::Ok));
        QVERIFY(buttons->button(QDialogButtonBox::Cancel));
    }

    void resultReflectsInput() {
        OptionsResult input;
        input.themeIndex = 1;
        input.fontName = "Consolas";
        input.menuBarTitleCase = false;
        input.safeMode = true;
        input.autoStartMcp = true;

        OptionsDialog dlg(input);
        auto r = dlg.result();

        QCOMPARE(r.themeIndex, 1);
        QCOMPARE(r.fontName, QString("Consolas"));
        QCOMPARE(r.menuBarTitleCase, false);
        QCOMPARE(r.safeMode, true);
        QCOMPARE(r.autoStartMcp, true);
    }

    void noStyleSheetOnDialog() {
        OptionsResult defaults;
        OptionsDialog dlg(defaults);

        // Dialog itself must have no stylesheet override
        QVERIFY(dlg.styleSheet().isEmpty());

        // Combo boxes must have no stylesheet override
        auto* themeCombo = dlg.findChild<QComboBox*>("themeCombo");
        QVERIFY(themeCombo->styleSheet().isEmpty());
        auto* fontCombo = dlg.findChild<QComboBox*>("fontCombo");
        QVERIFY(fontCombo->styleSheet().isEmpty());

        // No child widget should have a stylesheet set
        for (auto* child : dlg.findChildren<QWidget*>()) {
            QVERIFY2(child->styleSheet().isEmpty(),
                      qPrintable(QString("Widget %1 (%2) has unexpected stylesheet: %3")
                          .arg(child->objectName(),
                               child->metaObject()->className(),
                               child->styleSheet())));
        }
    }

    void highlightColorDiffersFromBackground() {
        // Verify the palette Highlight is distinguishable from Window background
        // This is the root cause of broken hover: if they're the same, hover is invisible
        auto& tm = ThemeManager::instance();
        const auto themes = tm.themes();
        for (const auto& theme : themes) {
            QVERIFY2(theme.selection != theme.background,
                      qPrintable(QString("Theme '%1': selection == background (%2)")
                          .arg(theme.name, theme.background.name())));
        }
    }

    void paletteHighlightIsSelection() {
        // After applying theme, QPalette::Highlight must be theme.selection (not theme.hover)
        auto& tm = ThemeManager::instance();
        const auto& theme = tm.current();
        applyGlobalTheme(theme);

        QPalette pal = qApp->palette();
        QCOMPARE(pal.color(QPalette::Highlight), theme.selection);
    }

    void treePageSwitching() {
        OptionsResult defaults;
        OptionsDialog dlg(defaults);

        auto* tree = dlg.findChild<QTreeWidget*>();
        auto* pages = dlg.findChild<QStackedWidget*>();
        QVERIFY(tree && pages);

        // General is selected by default -> page 0
        QCOMPARE(pages->currentIndex(), 0);

        // Find "AI Features" item and select it
        auto* envItem = tree->topLevelItem(0);
        QVERIFY(envItem);
        QTreeWidgetItem* aiItem = nullptr;
        for (int i = 0; i < envItem->childCount(); ++i) {
            if (envItem->child(i)->text(0) == "AI Features") {
                aiItem = envItem->child(i);
                break;
            }
        }
        QVERIFY(aiItem);
        tree->setCurrentItem(aiItem);
        QCOMPARE(pages->currentIndex(), 1);

        // Switch back to General
        QTreeWidgetItem* generalItem = nullptr;
        for (int i = 0; i < envItem->childCount(); ++i) {
            if (envItem->child(i)->text(0) == "General") {
                generalItem = envItem->child(i);
                break;
            }
        }
        QVERIFY(generalItem);
        tree->setCurrentItem(generalItem);
        QCOMPARE(pages->currentIndex(), 0);
    }

    void searchFilterHidesItems() {
        OptionsResult defaults;
        OptionsDialog dlg(defaults);

        auto* search = dlg.findChild<QLineEdit*>();
        auto* tree = dlg.findChild<QTreeWidget*>();
        QVERIFY(search && tree);

        auto* envItem = tree->topLevelItem(0);
        QVERIFY(envItem);

        // All children visible initially
        for (int i = 0; i < envItem->childCount(); ++i)
            QVERIFY(!envItem->child(i)->isHidden());

        // Search for "MCP" - should hide General, show AI Features
        search->setText("MCP");
        QTreeWidgetItem* generalItem = nullptr;
        QTreeWidgetItem* aiItem = nullptr;
        for (int i = 0; i < envItem->childCount(); ++i) {
            auto* child = envItem->child(i);
            if (child->text(0) == "General") generalItem = child;
            if (child->text(0) == "AI Features") aiItem = child;
        }
        QVERIFY(generalItem && aiItem);
        QVERIFY(generalItem->isHidden());
        QVERIFY(!aiItem->isHidden());

        // Clear search - all visible again
        search->setText("");
        QVERIFY(!generalItem->isHidden());
        QVERIFY(!aiItem->isHidden());
    }

    void refreshRateSpinBoxExists() {
        OptionsResult defaults;
        defaults.refreshMs = 660;
        OptionsDialog dlg(defaults);

        auto* spin = dlg.findChild<QSpinBox*>("refreshSpin");
        QVERIFY(spin);
        QCOMPARE(spin->value(), 660);
        QCOMPARE(spin->minimum(), 1);
        QCOMPARE(spin->maximum(), 60000);
    }

    void refreshRateResultReflectsInput() {
        OptionsResult input;
        input.refreshMs = 200;
        OptionsDialog dlg(input);

        auto r = dlg.result();
        QCOMPARE(r.refreshMs, 200);

        // Change via spin box
        auto* spin = dlg.findChild<QSpinBox*>("refreshSpin");
        QVERIFY(spin);
        spin->setValue(100);
        r = dlg.result();
        QCOMPARE(r.refreshMs, 100);
    }

    void refreshRateClampsMin() {
        OptionsResult input;
        input.refreshMs = 0; // below minimum
        OptionsDialog dlg(input);

        auto* spin = dlg.findChild<QSpinBox*>("refreshSpin");
        QVERIFY(spin);
        // QSpinBox clamps to minimum
        QCOMPARE(spin->value(), 1);
    }

    void dialogInheritsPalette() {
        auto& tm = ThemeManager::instance();
        const auto& theme = tm.current();
        applyGlobalTheme(theme);

        OptionsResult defaults;
        OptionsDialog dlg(defaults);
        dlg.show();
        QTest::qWaitForWindowExposed(&dlg);

        // Dialog's effective palette should match the app palette
        QPalette dlgPal = dlg.palette();
        QPalette appPal = qApp->palette();

        QCOMPARE(dlgPal.color(QPalette::Window), appPal.color(QPalette::Window));
        QCOMPARE(dlgPal.color(QPalette::WindowText), appPal.color(QPalette::WindowText));
        QCOMPARE(dlgPal.color(QPalette::Highlight), appPal.color(QPalette::Highlight));
        QCOMPARE(dlgPal.color(QPalette::Button), appPal.color(QPalette::Button));
        QCOMPARE(dlgPal.color(QPalette::ButtonText), appPal.color(QPalette::ButtonText));

        // Highlight must be visible against background
        QVERIFY(dlgPal.color(QPalette::Highlight) != dlgPal.color(QPalette::Window));
    }
};

QTEST_MAIN(TestOptionsDialog)
#include "test_options_dialog.moc"

```

`tests/test_provider.cpp`:

```cpp
#include <QTest>
#include <QByteArray>
#include <QDir>
#include <QFile>
#include <cstring>
#include "providers/provider.h"
#include "providers/buffer_provider.h"
#include "providers/null_provider.h"

using namespace rcx;

class TestProvider : public QObject {
    Q_OBJECT

private slots:

    // ---------------------------------------------------------------
    // NullProvider
    // ---------------------------------------------------------------

    void nullProvider_isNotValid() {
        NullProvider p;
        QVERIFY(!p.isValid());
        QCOMPARE(p.size(), 0);
    }

    void nullProvider_readFails() {
        NullProvider p;
        uint8_t buf = 0xFF;
        QVERIFY(!p.read(0, &buf, 1));
        QCOMPARE(buf, (uint8_t)0xFF); // buf unchanged on failure
    }

    void nullProvider_readU8ReturnsZero() {
        NullProvider p;
        QCOMPARE(p.readU8(0), (uint8_t)0);
    }

    void nullProvider_readBytesReturnsZeroed() {
        NullProvider p;
        QByteArray b = p.readBytes(0, 4);
        QCOMPARE(b.size(), 4);
        QCOMPARE(b, QByteArray(4, '\0'));
    }

    void nullProvider_isNotWritable() {
        NullProvider p;
        QVERIFY(!p.isWritable());
    }

    void nullProvider_nameIsEmpty() {
        NullProvider p;
        QVERIFY(p.name().isEmpty());
    }

    void nullProvider_getSymbolReturnsEmpty() {
        NullProvider p;
        QVERIFY(p.getSymbol(0x7FF00000).isEmpty());
    }

    // ---------------------------------------------------------------
    // BufferProvider -- construction
    // ---------------------------------------------------------------

    void buffer_emptyIsNotValid() {
        BufferProvider p(QByteArray{});
        QVERIFY(!p.isValid());
        QCOMPARE(p.size(), 0);
    }

    void buffer_nonEmptyIsValid() {
        BufferProvider p(QByteArray(16, '\0'));
        QVERIFY(p.isValid());
        QCOMPARE(p.size(), 16);
    }

    void buffer_nameFromConstructor() {
        BufferProvider p(QByteArray(4, '\0'), "dump.bin");
        QCOMPARE(p.name(), QStringLiteral("dump.bin"));
        QCOMPARE(p.kind(), QStringLiteral("File"));
    }

    void buffer_nameEmptyByDefault() {
        BufferProvider p(QByteArray(4, '\0'));
        QVERIFY(p.name().isEmpty());
    }

    // ---------------------------------------------------------------
    // BufferProvider -- reading typed values
    // ---------------------------------------------------------------

    void buffer_readU8() {
        QByteArray d(4, '\0');
        d[0] = (char)0xAB;
        BufferProvider p(d);
        QCOMPARE(p.readU8(0), (uint8_t)0xAB);
    }

    void buffer_readU16_littleEndian() {
        QByteArray d(4, '\0');
        d[0] = (char)0x34; d[1] = (char)0x12;
        BufferProvider p(d);
        QCOMPARE(p.readU16(0), (uint16_t)0x1234);
    }

    void buffer_readU32() {
        QByteArray d(8, '\0');
        uint32_t val = 0xDEADBEEF;
        std::memcpy(d.data(), &val, 4);
        BufferProvider p(d);
        QCOMPARE(p.readU32(0), (uint32_t)0xDEADBEEF);
    }

    void buffer_readU64() {
        QByteArray d(16, '\0');
        uint64_t val = 0x0102030405060708ULL;
        std::memcpy(d.data() + 4, &val, 8);
        BufferProvider p(d);
        QCOMPARE(p.readU64(4), val);
    }

    void buffer_readF32() {
        QByteArray d(4, '\0');
        float val = 3.14f;
        std::memcpy(d.data(), &val, 4);
        BufferProvider p(d);
        QCOMPARE(p.readF32(0), val);
    }

    void buffer_readF64() {
        QByteArray d(8, '\0');
        double val = 2.71828;
        std::memcpy(d.data(), &val, 8);
        BufferProvider p(d);
        QCOMPARE(p.readF64(0), val);
    }

    void buffer_readAs_customStruct() {
        struct Pair { uint16_t a; uint16_t b; };
        QByteArray d(4, '\0');
        Pair orig{0x1111, 0x2222};
        std::memcpy(d.data(), &orig, 4);
        BufferProvider p(d);
        Pair result = p.readAs<Pair>(0);
        QCOMPARE(result.a, (uint16_t)0x1111);
        QCOMPARE(result.b, (uint16_t)0x2222);
    }

    // ---------------------------------------------------------------
    // BufferProvider -- readBytes
    // ---------------------------------------------------------------

    void buffer_readBytes_full() {
        QByteArray d("Hello, World!", 13);
        BufferProvider p(d);
        QCOMPARE(p.readBytes(0, 5), QByteArray("Hello"));
    }

    void buffer_readBytes_offset() {
        QByteArray d("ABCDEFGH", 8);
        BufferProvider p(d);
        QCOMPARE(p.readBytes(4, 4), QByteArray("EFGH"));
    }

    void buffer_readBytes_pastEnd() {
        QByteArray d(4, 'X');
        BufferProvider p(d);
        QByteArray result = p.readBytes(2, 8);
        // read fails (past end), returns zeroed buffer
        QCOMPARE(result.size(), 8);
        QCOMPARE(result, QByteArray(8, '\0'));
    }

    void buffer_readBytes_zeroLen() {
        BufferProvider p(QByteArray(4, '\0'));
        QByteArray result = p.readBytes(0, 0);
        QCOMPARE(result.size(), 0);
    }

    // ---------------------------------------------------------------
    // BufferProvider -- isReadable boundary checks
    // ---------------------------------------------------------------

    void buffer_isReadable_withinBounds() {
        BufferProvider p(QByteArray(16, '\0'));
        QVERIFY(p.isReadable(0, 16));
        QVERIFY(p.isReadable(15, 1));
        QVERIFY(p.isReadable(0, 0));
    }

    void buffer_isReadable_outOfBounds() {
        BufferProvider p(QByteArray(16, '\0'));
        QVERIFY(!p.isReadable(0, 17));
        QVERIFY(!p.isReadable(16, 1));
        QVERIFY(!p.isReadable(100, 1));
    }

    void buffer_isReadable_zeroSizeProvider() {
        BufferProvider p(QByteArray{});
        QVERIFY(!p.isReadable(0, 1));
        QVERIFY(p.isReadable(0, 0)); // zero-len read always ok
    }

    // ---------------------------------------------------------------
    // BufferProvider -- writing
    // ---------------------------------------------------------------

    void buffer_isWritable() {
        BufferProvider p(QByteArray(4, '\0'));
        QVERIFY(p.isWritable());
    }

    void buffer_writeBytes() {
        QByteArray d(8, '\0');
        BufferProvider p(d);
        QByteArray payload("\xAA\xBB\xCC\xDD", 4);
        QVERIFY(p.writeBytes(2, payload));
        QCOMPARE(p.readU8(2), (uint8_t)0xAA);
        QCOMPARE(p.readU8(5), (uint8_t)0xDD);
    }

    void buffer_write_pastEndFails() {
        BufferProvider p(QByteArray(4, '\0'));
        QByteArray big(8, 'X');
        QVERIFY(!p.writeBytes(0, big));
    }

    void buffer_write_thenRead() {
        QByteArray d(8, '\0');
        BufferProvider p(d);
        uint32_t val = 0x12345678;
        QVERIFY(p.write(0, &val, sizeof(val)));
        QCOMPARE(p.readU32(0), (uint32_t)0x12345678);
    }

    // ---------------------------------------------------------------
    // BufferProvider -- fromFile
    // ---------------------------------------------------------------

    void buffer_fromFile_nonexistent() {
        auto p = BufferProvider::fromFile("/tmp/__rcx_test_nonexistent_file__");
        QVERIFY(!p.isValid());
        QCOMPARE(p.size(), 0);
    }

    void buffer_fromFile_valid() {
        // Write a temp file, read it back
        QString path = QDir::tempPath() + "/rcx_test_buffer_provider.bin";
        {
            QFile f(path);
            QVERIFY(f.open(QIODevice::WriteOnly));
            f.write(QByteArray(64, '\xAB'));
        }
        auto p = BufferProvider::fromFile(path);
        QVERIFY(p.isValid());
        QCOMPARE(p.size(), 64);
        QCOMPARE(p.readU8(0), (uint8_t)0xAB);
        QCOMPARE(p.name(), QStringLiteral("rcx_test_buffer_provider.bin"));
        QFile::remove(path);
    }

    // ---------------------------------------------------------------
    // Polymorphism -- unique_ptr<Provider> usage
    // ---------------------------------------------------------------

    void polymorphic_nullToBuffer() {
        std::unique_ptr<Provider> prov = std::make_unique<NullProvider>();
        QVERIFY(!prov->isValid());
        QVERIFY(prov->name().isEmpty());

        // Switch to buffer
        QByteArray d(8, '\0');
        uint64_t val = 0xCAFEBABE;
        std::memcpy(d.data(), &val, sizeof(val));
        prov = std::make_unique<BufferProvider>(d, "test.bin");

        QVERIFY(prov->isValid());
        QCOMPARE(prov->readU64(0), (uint64_t)0xCAFEBABE);
        QCOMPARE(prov->name(), QStringLiteral("test.bin"));
        QCOMPARE(prov->kind(), QStringLiteral("File"));
        QVERIFY(prov->getSymbol(0x1000).isEmpty());
    }

    // ---------------------------------------------------------------
    // getSymbol -- base class returns empty
    // ---------------------------------------------------------------

    void buffer_getSymbol_alwaysEmpty() {
        BufferProvider p(QByteArray(64, '\0'), "test.bin");
        QVERIFY(p.getSymbol(0).isEmpty());
        QVERIFY(p.getSymbol(0x7FF00000).isEmpty());
    }
};

QTEST_MAIN(TestProvider)
#include "test_provider.moc"

```

`tests/test_provider_getSymbol.cpp`:

```cpp
#include <QTest>
#ifdef _WIN32
#include "providers/process_provider.h"
using namespace rcx;
#endif

class TestProcessProviderSymbol : public QObject {
    Q_OBJECT

private slots:

#ifdef _WIN32
    void getSymbol_selfProcess() {
        // Attach to our own process for testing
        HANDLE self = GetCurrentProcess();

        // DuplicateHandle to get a real handle we can pass
        HANDLE hReal = nullptr;
        DuplicateHandle(self, self, self, &hReal, 0, FALSE, DUPLICATE_SAME_ACCESS);

        HMODULE hMod = nullptr;
        DWORD needed = 0;
        EnumProcessModulesEx(hReal, &hMod, sizeof(hMod), &needed, LIST_MODULES_ALL);

        MODULEINFO mi{};
        GetModuleInformation(hReal, hMod, &mi, sizeof(mi));
        uint64_t base = (uint64_t)mi.lpBaseOfDll;
        int regionSize = (int)mi.SizeOfImage;

        // ProcessProvider takes ownership of the handle
        ProcessProvider prov(hReal, base, regionSize, "self_test");

        QCOMPARE(prov.kind(), QStringLiteral("Process"));
        QCOMPARE(prov.name(), QStringLiteral("self_test"));
        QVERIFY(prov.isValid());
        QVERIFY(prov.size() > 0);

        // getSymbol for our own base address should resolve to our exe name
        QString sym = prov.getSymbol(base);
        QVERIFY(!sym.isEmpty());
        // Should contain +0x
        QVERIFY(sym.contains("+0x"));

        // getSymbol for a bogus address should return empty
        QString bogus = prov.getSymbol(0xDEAD);
        QVERIFY(bogus.isEmpty());

        // Read our own PE signature as a sanity check
        // (first two bytes of any PE are 'MZ')
        uint16_t mz = prov.readU16(0);
        QCOMPARE(mz, (uint16_t)0x5A4D); // 'MZ' in little-endian
    }

    void getSymbol_ntdllResolvable() {
        // ntdll is loaded in every process
        HANDLE self = GetCurrentProcess();
        HANDLE hReal = nullptr;
        DuplicateHandle(self, self, self, &hReal, 0, FALSE, DUPLICATE_SAME_ACCESS);

        HMODULE mods[256];
        DWORD needed = 0;
        EnumProcessModulesEx(hReal, mods, sizeof(mods), &needed, LIST_MODULES_ALL);

        // Find ntdll
        uint64_t ntdllBase = 0;
        int count = (int)(needed / sizeof(HMODULE));
        for (int i = 0; i < count; ++i) {
            WCHAR name[MAX_PATH];
            if (GetModuleBaseNameW(hReal, mods[i], name, MAX_PATH)) {
                if (QString::fromWCharArray(name).toLower() == "ntdll.dll") {
                    MODULEINFO mi{};
                    GetModuleInformation(hReal, mods[i], &mi, sizeof(mi));
                    ntdllBase = (uint64_t)mi.lpBaseOfDll;
                    break;
                }
            }
        }
        QVERIFY(ntdllBase != 0);

        // Use main module as the "base" for the provider
        MODULEINFO mainMi{};
        GetModuleInformation(hReal, mods[0], &mainMi, sizeof(mainMi));

        ProcessProvider prov(hReal, (uint64_t)mainMi.lpBaseOfDll,
                             (int)mainMi.SizeOfImage, "self_test");

        // Resolve ntdll base -- should return "ntdll.dll+0x0"
        QString sym = prov.getSymbol(ntdllBase);
        QVERIFY(sym.toLower().startsWith("ntdll.dll+0x"));
    }
#else
    void skip() { QSKIP("ProcessProvider tests are Windows-only"); }
#endif
};

QTEST_MAIN(TestProcessProviderSymbol)
#include "test_provider_getSymbol.moc"

```

`tests/test_rendered_view.cpp`:

```cpp
#include <QtTest/QTest>
#include <QApplication>
#include <Qsci/qsciscintilla.h>
#include <Qsci/qsciscintillabase.h>
#include <Qsci/qscilexercpp.h>
#include <QColor>
#include <QFont>

#include "core.h"
#include "generator.h"

// Raw Scintilla message IDs not exposed by QsciScintillaBase wrapper
static constexpr int SCI_GETSELBACK  = 2477;
static constexpr int SCI_GETSELFORE  = 2476;

// ── Helper: extract BGR long from QColor (Scintilla stores colors as 0x00BBGGRR) ──

static long toBGR(const QColor& c) {
    return (long)c.red() | ((long)c.green() << 8) | ((long)c.blue() << 16);
}

// ── Replicates MainWindow::setupRenderedSci so the test stays in sync ──

static void setupRenderedSci(QsciScintilla* sci) {
    QFont f("Consolas", 12);
    f.setFixedPitch(true);

    sci->setFont(f);
    sci->setReadOnly(false);
    sci->setWrapMode(QsciScintilla::WrapNone);
    sci->setTabWidth(4);
    sci->setIndentationsUseTabs(false);
    sci->SendScintilla(QsciScintillaBase::SCI_SETEXTRAASCENT, (long)2);
    sci->SendScintilla(QsciScintillaBase::SCI_SETEXTRADESCENT, (long)2);

    // Line number margin
    sci->setMarginType(0, QsciScintilla::NumberMargin);
    sci->setMarginWidth(0, "00000");
    sci->setMarginsBackgroundColor(QColor("#252526"));
    sci->setMarginsForegroundColor(QColor("#858585"));
    sci->setMarginsFont(f);

    sci->setMarginWidth(1, 0);
    sci->setMarginWidth(2, 0);

    // Lexer FIRST — setLexer() resets caret/selection/paper colors
    auto* lexer = new QsciLexerCPP(sci);
    lexer->setFont(f);
    lexer->setColor(QColor("#569cd6"), QsciLexerCPP::Keyword);
    lexer->setColor(QColor("#569cd6"), QsciLexerCPP::KeywordSet2);
    lexer->setColor(QColor("#b5cea8"), QsciLexerCPP::Number);
    lexer->setColor(QColor("#ce9178"), QsciLexerCPP::DoubleQuotedString);
    lexer->setColor(QColor("#ce9178"), QsciLexerCPP::SingleQuotedString);
    lexer->setColor(QColor("#6a9955"), QsciLexerCPP::Comment);
    lexer->setColor(QColor("#6a9955"), QsciLexerCPP::CommentLine);
    lexer->setColor(QColor("#6a9955"), QsciLexerCPP::CommentDoc);
    lexer->setColor(QColor("#d4d4d4"), QsciLexerCPP::Default);
    lexer->setColor(QColor("#d4d4d4"), QsciLexerCPP::Identifier);
    lexer->setColor(QColor("#c586c0"), QsciLexerCPP::PreProcessor);
    lexer->setColor(QColor("#d4d4d4"), QsciLexerCPP::Operator);
    for (int i = 0; i <= 127; i++) {
        lexer->setPaper(QColor("#1e1e1e"), i);
        lexer->setFont(f, i);
    }
    sci->setLexer(lexer);
    sci->setBraceMatching(QsciScintilla::NoBraceMatch);

    // Colors AFTER setLexer() — the lexer resets these on attach
    sci->setPaper(QColor("#1e1e1e"));
    sci->setColor(QColor("#d4d4d4"));
    sci->setCaretForegroundColor(QColor("#d4d4d4"));
    sci->setCaretLineVisible(true);
    sci->setCaretLineBackgroundColor(QColor(43, 43, 43));
    sci->setSelectionBackgroundColor(QColor("#264f78"));
    sci->setSelectionForegroundColor(QColor("#d4d4d4"));
}

// ── Test tree helper ──

static rcx::NodeTree makeTestTree() {
    rcx::NodeTree tree;
    rcx::Node root;
    root.kind = rcx::NodeKind::Struct;
    root.name = "TestStruct";
    root.structTypeName = "TestStruct";
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    rcx::Node f1;
    f1.kind = rcx::NodeKind::Int32;
    f1.name = "health";
    f1.parentId = rootId;
    f1.offset = 0;
    tree.addNode(f1);

    rcx::Node f2;
    f2.kind = rcx::NodeKind::Float;
    f2.name = "speed";
    f2.parentId = rootId;
    f2.offset = 4;
    tree.addNode(f2);

    return tree;
}

// ── Test class ──

class TestRenderedView : public QObject {
    Q_OBJECT

private slots:

    // ── Verify caret line background is NOT yellow after setup ──

    void testCaretLineBackgroundNotYellow() {
        QsciScintilla sci;
        setupRenderedSci(&sci);
        sci.show();
        sci.setText("struct Foo {\n    int x;\n};\n");
        QTest::qWait(50);

        long bgr = sci.SendScintilla(QsciScintillaBase::SCI_GETCARETLINEBACK);
        long expected = toBGR(QColor(43, 43, 43));

        // Yellow would be 0x00FFFF or similar high-value — ours should be dark
        long yellow = toBGR(QColor(255, 255, 0));
        QVERIFY2(bgr != yellow,
                 qPrintable(QString("Caret line is yellow (0x%1), expected dark (0x%2)")
                            .arg(bgr, 6, 16, QChar('0'))
                            .arg(expected, 6, 16, QChar('0'))));
        QCOMPARE(bgr, expected);
    }

    // ── Verify caret line is enabled ──

    void testCaretLineEnabled() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        long visible = sci.SendScintilla(QsciScintillaBase::SCI_GETCARETLINEVISIBLE);
        QCOMPARE(visible, (long)1);
    }

    // ── Verify editor background (paper) is dark ──

    void testPaperColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        // Query default style background via Scintilla
        long bgr = sci.SendScintilla(QsciScintillaBase::SCI_STYLEGETBACK,
                                     (unsigned long)0 /*STYLE_DEFAULT*/);
        long expected = toBGR(QColor("#1e1e1e"));
        QCOMPARE(bgr, expected);
    }

    // ── Verify caret (cursor) foreground color ──

    void testCaretForegroundColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        long bgr = sci.SendScintilla(QsciScintillaBase::SCI_GETCARETFORE);
        long expected = toBGR(QColor("#d4d4d4"));
        QCOMPARE(bgr, expected);
    }

    // ── Verify selection colors are set (no direct Scintilla getter, but we can
    //    verify they survive a round-trip through the SCI_SETSEL* messages by
    //    checking the element colour API introduced in Scintilla 5.x) ──

    void testSelectionColorsApplied() {
        QsciScintilla sci;
        setupRenderedSci(&sci);
        sci.show();
        sci.setText("int x = 42;\n");
        QTest::qWait(50);

        // Select text and verify rendering doesn't crash
        sci.SendScintilla(QsciScintillaBase::SCI_SETSEL, (unsigned long)0, (long)3);
        QTest::qWait(50);

        // SCI_GETELEMENTCOLOUR (element 10 = SC_ELEMENT_SELECTION_BACK) returns
        // the selection back colour on Scintilla >= 5.2.  If not available, fall
        // back to verifying the calls didn't throw and caret line is still correct.
        constexpr int SCI_GETELEMENTCOLOUR = 2753;
        constexpr int SC_ELEMENT_SELECTION_BACK = 10;

        long selBack = sci.SendScintilla(SCI_GETELEMENTCOLOUR,
                                         (unsigned long)SC_ELEMENT_SELECTION_BACK);
        if (selBack != 0) {
            // Scintilla 5.x: colour stored as 0xAABBGGRR (with alpha in high byte)
            long bgrMask = selBack & 0x00FFFFFF;
            long expected = toBGR(QColor("#264f78"));
            QCOMPARE(bgrMask, expected);
        } else {
            // Older Scintilla: just verify caret line is still correct as a proxy
            long caretBg = sci.SendScintilla(QsciScintillaBase::SCI_GETCARETLINEBACK);
            long expected = toBGR(QColor(43, 43, 43));
            QCOMPARE(caretBg, expected);
        }
    }

    // ── Verify lexer keyword color is VS Code blue, not default ──

    void testKeywordColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QColor kw = lexer->color(QsciLexerCPP::Keyword);
        QCOMPARE(kw, QColor("#569cd6"));
    }

    // ── Verify comment color is VS Code green ──

    void testCommentColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QCOMPARE(lexer->color(QsciLexerCPP::Comment),    QColor("#6a9955"));
        QCOMPARE(lexer->color(QsciLexerCPP::CommentLine), QColor("#6a9955"));
    }

    // ── Verify number color is VS Code light green ──

    void testNumberColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QCOMPARE(lexer->color(QsciLexerCPP::Number), QColor("#b5cea8"));
    }

    // ── Verify string color is VS Code orange ──

    void testStringColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QCOMPARE(lexer->color(QsciLexerCPP::DoubleQuotedString), QColor("#ce9178"));
        QCOMPARE(lexer->color(QsciLexerCPP::SingleQuotedString), QColor("#ce9178"));
    }

    // ── Verify preprocessor color is VS Code purple ──

    void testPreprocessorColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QCOMPARE(lexer->color(QsciLexerCPP::PreProcessor), QColor("#c586c0"));
    }

    // ── Verify default/identifier text color ──

    void testDefaultTextColor() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QCOMPARE(lexer->color(QsciLexerCPP::Default),    QColor("#d4d4d4"));
        QCOMPARE(lexer->color(QsciLexerCPP::Identifier), QColor("#d4d4d4"));
        QCOMPARE(lexer->color(QsciLexerCPP::Operator),   QColor("#d4d4d4"));
    }

    // ── Verify all 128 lexer styles have dark paper ──

    void testAllStylesHaveDarkPaper() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        auto* lexer = qobject_cast<QsciLexerCPP*>(sci.lexer());
        QVERIFY(lexer != nullptr);

        QColor expected("#1e1e1e");
        for (int i = 0; i <= 127; i++) {
            QColor paper = lexer->paper(i);
            QVERIFY2(paper == expected,
                     qPrintable(QString("Style %1 paper is %2, expected %3")
                                .arg(i).arg(paper.name()).arg(expected.name())));
        }
    }

    // ── Verify margin colors match dark theme ──

    void testMarginColors() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        // Query margin background via Scintilla (style 33 = STYLE_LINENUMBER)
        long marginBg = sci.SendScintilla(QsciScintillaBase::SCI_STYLEGETBACK,
                                          (unsigned long)33);
        long expectedBg = toBGR(QColor("#252526"));
        QCOMPARE(marginBg, expectedBg);

        long marginFg = sci.SendScintilla(QsciScintillaBase::SCI_STYLEGETFORE,
                                          (unsigned long)33);
        long expectedFg = toBGR(QColor("#858585"));
        QCOMPARE(marginFg, expectedFg);
    }

    // ── End-to-end: generate C++ and load into rendered view ──

    void testGeneratedCodeInRenderedView() {
        auto tree = makeTestTree();
        uint64_t rootId = tree.nodes[0].id;
        QString code = rcx::renderCpp(tree, rootId);

        // Verify generated code has no pragma pack / cstdint
        QVERIFY(!code.contains("#pragma pack"));
        QVERIFY(!code.contains("#include <cstdint>"));
        QVERIFY(code.contains("#pragma once"));
        QVERIFY(code.contains("struct TestStruct {"));

        // Load into rendered sci and verify colors survive
        QsciScintilla sci;
        setupRenderedSci(&sci);
        sci.show();
        sci.setText(code);
        QTest::qWait(100);

        // Caret line must still be dark after text load
        long caretBg = sci.SendScintilla(QsciScintillaBase::SCI_GETCARETLINEBACK);
        long expected = toBGR(QColor(43, 43, 43));
        QCOMPARE(caretBg, expected);

        // Paper must still be dark
        long paperBg = sci.SendScintilla(QsciScintillaBase::SCI_STYLEGETBACK,
                                         (unsigned long)0);
        QCOMPARE(paperBg, toBGR(QColor("#1e1e1e")));
    }

    // ── Verify brace matching is disabled ──

    void testBraceMatchDisabled() {
        QsciScintilla sci;
        setupRenderedSci(&sci);

        QCOMPARE(sci.braceMatching(), QsciScintilla::NoBraceMatch);
    }
};

QTEST_MAIN(TestRenderedView)
#include "test_rendered_view.moc"

```

`tests/test_source_management.cpp`:

```cpp
#include <QtTest/QTest>
#include <QApplication>
#include <QSplitter>
#include <QDir>
#include <QFile>
#include <Qsci/qsciscintilla.h>
#include "controller.h"
#include "core.h"
#include "providers/null_provider.h"
#include "providers/buffer_provider.h"

using namespace rcx;

static void buildTree(NodeTree& tree) {
    tree.baseAddress = 0x1000;

    Node root;
    root.kind = NodeKind::Struct;
    root.structTypeName = "TestClass";
    root.name = "TestClass";
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    Node f;
    f.kind = NodeKind::Hex64;
    f.name = "field_00";
    f.parentId = rootId;
    f.offset = 0;
    tree.addNode(f);
}

class TestSourceManagement : public QObject {
    Q_OBJECT
private:
    RcxDocument* m_doc = nullptr;
    RcxController* m_ctrl = nullptr;
    QSplitter* m_splitter = nullptr;

    // Helper: write a temp binary file and return its path
    QString writeTempFile(const QString& name, const QByteArray& data) {
        QString path = QDir::tempPath() + "/" + name;
        QFile f(path);
        f.open(QIODevice::WriteOnly);
        f.write(data);
        f.close();
        return path;
    }

    // Helper: directly add a file source entry (bypasses QFileDialog)
    void addFileSource(const QString& path, const QString& displayName) {
        m_doc->loadData(path);
        SavedSourceEntry entry;
        entry.kind = QStringLiteral("File");
        entry.displayName = displayName;
        entry.filePath = path;
        entry.baseAddress = m_doc->tree.baseAddress;
        // Access saved sources through selectSource's internal mechanism
        // We manually add since selectSource("File") opens a dialog
        m_ctrl->document()->provider = std::make_shared<BufferProvider>(
            QFile(path).readAll().isEmpty() ? QByteArray(64, '\0') : QByteArray(64, '\0'));
        // Use the test accessor pattern from controller
    }

private slots:
    void init() {
        m_doc = new RcxDocument();
        buildTree(m_doc->tree);

        m_splitter = new QSplitter();
        m_ctrl = new RcxController(m_doc, nullptr);
        m_ctrl->addSplitEditor(m_splitter);

        m_splitter->resize(800, 600);
        m_splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(m_splitter));
        QApplication::processEvents();
    }

    void cleanup() {
        delete m_ctrl;  m_ctrl = nullptr;
        delete m_splitter;  m_splitter = nullptr;
        delete m_doc;  m_doc = nullptr;
    }

    // ── Initial state: NullProvider, no saved sources ──

    void testInitialProviderIsNull() {
        QVERIFY(m_doc->provider != nullptr);
        QCOMPARE(m_doc->provider->size(), 0);
        QVERIFY(!m_doc->provider->isValid());
        QCOMPARE(m_ctrl->savedSources().size(), 0);
        QCOMPARE(m_ctrl->activeSourceIndex(), -1);
    }

    // ── Loading binary data creates a valid provider ──

    void testLoadDataCreatesValidProvider() {
        QByteArray data(128, '\xAB');
        m_doc->loadData(data);
        QApplication::processEvents();

        QVERIFY(m_doc->provider->isValid());
        QCOMPARE(m_doc->provider->size(), 128);
        QCOMPARE(m_doc->provider->readU8(0), (uint8_t)0xAB);
    }

    // ── clearSources resets to NullProvider ──

    void testClearSourcesResetsToNull() {
        // Load some data first so provider is valid
        QByteArray data(64, '\xFF');
        m_doc->loadData(data);
        QApplication::processEvents();
        QVERIFY(m_doc->provider->isValid());

        m_ctrl->clearSources();
        QApplication::processEvents();

        // Provider should be NullProvider
        QVERIFY(!m_doc->provider->isValid());
        QCOMPARE(m_doc->provider->size(), 0);

        // Saved sources should be empty
        QCOMPARE(m_ctrl->savedSources().size(), 0);
        QCOMPARE(m_ctrl->activeSourceIndex(), -1);
    }

    // ── clearSources clears value history ──

    void testClearSourcesClearsValueHistory() {
        // The value history is cleared via resetSnapshot inside clearSources
        m_ctrl->clearSources();
        QApplication::processEvents();

        QVERIFY(m_ctrl->valueHistory().isEmpty());
    }

    // ── clearSources clears dataPath ──

    void testClearSourcesClearsDataPath() {
        QString path = writeTempFile("rcx_test_src.bin", QByteArray(64, '\xCC'));
        m_doc->loadData(path);
        QVERIFY(!m_doc->dataPath.isEmpty());

        m_ctrl->clearSources();
        QApplication::processEvents();

        QVERIFY(m_doc->dataPath.isEmpty());
        QFile::remove(path);
    }

    // ── selectSource("#clear") calls clearSources ──

    void testSelectSourceClearCommand() {
        QByteArray data(64, '\xFF');
        m_doc->loadData(data);
        QVERIFY(m_doc->provider->isValid());

        m_ctrl->selectSource(QStringLiteral("#clear"));
        QApplication::processEvents();

        QVERIFY(!m_doc->provider->isValid());
        QCOMPARE(m_ctrl->savedSources().size(), 0);
        QCOMPARE(m_ctrl->activeSourceIndex(), -1);
    }

    // ── clearSources then refresh still works (compose doesn't crash) ──

    void testClearSourcesThenRefreshWorks() {
        m_ctrl->clearSources();
        QApplication::processEvents();

        // refresh() is called internally by clearSources; verify it didn't crash
        // and the editor still has content (the tree structure is intact)
        auto* editor = m_ctrl->editors().first();
        QVERIFY(editor != nullptr);
    }

    // ── Multiple clearSources calls are safe (idempotent) ──

    void testMultipleClearSourcesIdempotent() {
        m_ctrl->clearSources();
        m_ctrl->clearSources();
        m_ctrl->clearSources();
        QApplication::processEvents();

        QVERIFY(!m_doc->provider->isValid());
        QCOMPARE(m_ctrl->savedSources().size(), 0);
        QCOMPARE(m_ctrl->activeSourceIndex(), -1);
    }

    // ── switchToSavedSource with invalid index is no-op ──

    void testSwitchInvalidIndexNoOp() {
        m_ctrl->switchSource(-1);
        m_ctrl->switchSource(999);
        QApplication::processEvents();

        // Should still be in initial state
        QCOMPARE(m_ctrl->activeSourceIndex(), -1);
    }

    // ── Provider read fails after clear (all zeros) ──

    void testProviderReadFailsAfterClear() {
        QByteArray data(64, '\xAB');
        m_doc->loadData(data);
        QCOMPARE(m_doc->provider->readU8(0), (uint8_t)0xAB);

        m_ctrl->clearSources();
        QApplication::processEvents();

        // NullProvider: read returns false, readU8 returns 0
        uint8_t buf = 0xFF;
        QVERIFY(!m_doc->provider->read(0, &buf, 1));
        QCOMPARE(m_doc->provider->readU8(0), (uint8_t)0);
    }

    // ── clearSources resets snapshot state ──

    void testClearSourcesResetsSnapshot() {
        QByteArray data(64, '\x00');
        m_doc->loadData(data);
        QApplication::processEvents();

        m_ctrl->clearSources();
        QApplication::processEvents();

        // After clear, the value history should be empty (resetSnapshot was called)
        QVERIFY(m_ctrl->valueHistory().isEmpty());
    }

    // ── NullProvider name is empty (triggers "source" placeholder in command row) ──

    void testNullProviderNameEmpty() {
        m_ctrl->clearSources();
        QApplication::processEvents();

        QVERIFY(m_doc->provider->name().isEmpty());
    }
};

QTEST_MAIN(TestSourceManagement)
#include "test_source_management.moc"

```

`tests/test_theme.cpp`:

```cpp
#include <QtTest/QTest>
#include <QtTest/QSignalSpy>
#include <QJsonDocument>
#include <QJsonObject>
#include "themes/theme.h"
#include "themes/thememanager.h"

using namespace rcx;

class TestTheme : public QObject {
    Q_OBJECT
private slots:
    void builtInThemes() {
        auto& tm = ThemeManager::instance();
        auto all = tm.themes();
        QVERIFY(all.size() >= 2);

        // Find themes by name
        const Theme* dark = nullptr;
        const Theme* warm = nullptr;
        for (const auto& t : all) {
            if (t.name == "Reclass Dark") dark = &t;
            if (t.name == "Warm") warm = &t;
        }
        QVERIFY(dark);
        QCOMPARE(dark->name, QString("Reclass Dark"));
        QVERIFY(dark->background.isValid());
        QVERIFY(dark->text.isValid());
        QVERIFY(dark->syntaxKeyword.isValid());
        QVERIFY(dark->markerError.isValid());

        QVERIFY(warm);
        QCOMPARE(warm->name, QString("Warm"));
        QVERIFY(warm->background.isValid());
        QVERIFY(warm->text.isValid());
        QCOMPARE(warm->background, QColor("#212121"));
        QCOMPARE(warm->selection, QColor("#21213A"));
        QCOMPARE(warm->syntaxKeyword, QColor("#AA9565"));
        QCOMPARE(warm->syntaxType, QColor("#6B959F"));
    }

    void jsonRoundTrip() {
        auto& tm = ThemeManager::instance();
        Theme orig = tm.themes()[0];
        QJsonObject json = orig.toJson();
        Theme loaded = Theme::fromJson(json);

        QCOMPARE(loaded.name, orig.name);
        QCOMPARE(loaded.background, orig.background);
        QCOMPARE(loaded.text, orig.text);
        QCOMPARE(loaded.selection, orig.selection);
        QCOMPARE(loaded.syntaxKeyword, orig.syntaxKeyword);
        QCOMPARE(loaded.syntaxNumber, orig.syntaxNumber);
        QCOMPARE(loaded.syntaxString, orig.syntaxString);
        QCOMPARE(loaded.syntaxComment, orig.syntaxComment);
        QCOMPARE(loaded.syntaxType, orig.syntaxType);
        QCOMPARE(loaded.markerPtr, orig.markerPtr);
        QCOMPARE(loaded.markerError, orig.markerError);
        QCOMPARE(loaded.indHoverSpan, orig.indHoverSpan);
    }

    void jsonRoundTripWarm() {
        auto& tm = ThemeManager::instance();
        auto all = tm.themes();
        Theme orig;
        for (const auto& t : all)
            if (t.name == "Warm") { orig = t; break; }

        QJsonObject json = orig.toJson();
        Theme loaded = Theme::fromJson(json);

        QCOMPARE(loaded.name, orig.name);
        QCOMPARE(loaded.background, orig.background);
        QCOMPARE(loaded.selection, orig.selection);
        QCOMPARE(loaded.syntaxKeyword, orig.syntaxKeyword);
    }

    void fromJsonMissingFields() {
        QJsonObject sparse;
        sparse["name"] = "Sparse";
        sparse["background"] = "#ff0000";
        Theme t = Theme::fromJson(sparse);

        QCOMPARE(t.name, QString("Sparse"));
        QCOMPARE(t.background, QColor("#ff0000"));
        // Missing fields are default (invalid) QColor
        QVERIFY(!t.text.isValid());
        QVERIFY(!t.syntaxKeyword.isValid());
        QVERIFY(!t.markerError.isValid());
    }

    void themeManagerHasBuiltIns() {
        auto& tm = ThemeManager::instance();
        auto all = tm.themes();
        QVERIFY(all.size() >= 3);
        QCOMPARE(all[0].name, QString("Reclass Dark"));
        // VS2022 Dark and Warm are also loaded (order depends on filename sort)
        bool hasVs = false, hasWarm = false;
        for (const auto& t : all) {
            if (t.name == "VS2022 Dark") hasVs = true;
            if (t.name == "Warm") hasWarm = true;
        }
        QVERIFY(hasVs);
        QVERIFY(hasWarm);
    }

    void themeManagerSwitch() {
        auto& tm = ThemeManager::instance();
        QSignalSpy spy(&tm, &ThemeManager::themeChanged);

        int startIdx = tm.currentIndex();
        int target = (startIdx == 0) ? 1 : 0;
        tm.setCurrent(target);

        QCOMPARE(spy.count(), 1);
        QCOMPARE(tm.currentIndex(), target);
        QCOMPARE(tm.current().name, tm.themes()[target].name);

        // Restore
        tm.setCurrent(startIdx);
    }

    void themeManagerCRUD() {
        auto& tm = ThemeManager::instance();
        int initialCount = tm.themes().size();

        // Add
        Theme custom = tm.themes()[0];
        custom.name = "Test Custom";
        custom.background = QColor("#ff0000");
        tm.addTheme(custom);
        QCOMPARE(tm.themes().size(), initialCount + 1);
        QCOMPARE(tm.themes().last().name, QString("Test Custom"));

        // Update
        int idx = tm.themes().size() - 1;
        Theme updated = custom;
        updated.background = QColor("#00ff00");
        tm.updateTheme(idx, updated);
        QCOMPARE(tm.themes()[idx].background, QColor("#00ff00"));

        // Remove
        tm.removeTheme(idx);
        QCOMPARE(tm.themes().size(), initialCount);
    }
};

QTEST_MAIN(TestTheme)
#include "test_theme.moc"

```

`tests/test_type_selector.cpp`:

```cpp
#include <QtTest/QTest>
#include <QtTest/QSignalSpy>
#include <QApplication>
#include <QSplitter>
#include <QElapsedTimer>
#include <QVBoxLayout>
#include <QToolButton>
#include <QButtonGroup>
#include <QLineEdit>
#include <QListView>
#include <QStringListModel>
#include <QLabel>
#include <QFrame>
#include <Qsci/qsciscintilla.h>
#include "controller.h"
#include "typeselectorpopup.h"
#include "themes/thememanager.h"
#include "core.h"

Q_DECLARE_METATYPE(rcx::TypeEntry)

using namespace rcx;

static void buildTwoRootTree(NodeTree& tree) {
    tree.baseAddress = 0;

    Node a;
    a.kind = NodeKind::Struct;
    a.name = "Alpha";
    a.structTypeName = "Alpha";
    a.parentId = 0;
    a.offset = 0;
    int ai = tree.addNode(a);
    uint64_t aId = tree.nodes[ai].id;

    { Node n; n.kind = NodeKind::Int32; n.name = "x"; n.parentId = aId; n.offset = 0; tree.addNode(n); }
    { Node n; n.kind = NodeKind::Int32; n.name = "y"; n.parentId = aId; n.offset = 4; tree.addNode(n); }

    Node b;
    b.kind = NodeKind::Struct;
    b.name = "Bravo";
    b.structTypeName = "Bravo";
    b.parentId = 0;
    b.offset = 0x100;
    int bi = tree.addNode(b);
    uint64_t bId = tree.nodes[bi].id;

    { Node n; n.kind = NodeKind::Float; n.name = "speed"; n.parentId = bId; n.offset = 0; tree.addNode(n); }
}

static QByteArray makeBuffer() {
    return QByteArray(0x200, '\0');
}

class TestTypeSelector : public QObject {
    Q_OBJECT

private slots:
    void initTestCase() {
        qRegisterMetaType<TypeEntry>("TypeEntry");
    }

    // ── Chevron span detection ──

    void testChevronSpanDetected() {
        QString text = QStringLiteral("[\u25B8] source\u25BE \u00B7 0x1000 \u00B7 struct Alpha {");
        ColumnSpan span = commandRowChevronSpan(text);
        QVERIFY(span.valid);
        QCOMPARE(span.start, 0);
        QCOMPARE(span.end, 4);  // includes trailing space for easier clicking
    }

    void testChevronSpanRejects() {
        QVERIFY(!commandRowChevronSpan(QStringLiteral("Hi")).valid);
        QVERIFY(!commandRowChevronSpan(QStringLiteral("\u25B8 source")).valid);
        // Old down-triangle glyph must not match
        QVERIFY(!commandRowChevronSpan(QStringLiteral("[\u25BE] source")).valid);
    }

    // ── Existing spans unbroken by chevron prefix ──

    void testSpansWithPrefix() {
        QString text = QStringLiteral("[\u25B8] source\u25BE \u00B7 0x1000 \u00B7 struct Alpha {");

        ColumnSpan src = commandRowSrcSpan(text);
        QVERIFY(src.valid);
        QVERIFY(text.mid(src.start, src.end - src.start).contains("source"));

        ColumnSpan addr = commandRowAddrSpan(text);
        QVERIFY(addr.valid);
        QVERIFY(text.mid(addr.start, addr.end - addr.start).contains("0x1000"));

        ColumnSpan rootName = commandRowRootNameSpan(text);
        QVERIFY(rootName.valid);
        QCOMPARE(text.mid(rootName.start, rootName.end - rootName.start).trimmed(), QString("Alpha"));
    }

    // ── Benchmark: warmUp() + cached reuse vs cold new/delete ──

    void benchmarkPopupOpen() {
        auto makeComposite = [](uint64_t id, const QString& name, const QString& kw) {
            TypeEntry e;
            e.entryKind = TypeEntry::Composite;
            e.structId = id;
            e.displayName = name;
            e.classKeyword = kw;
            return e;
        };
        QVector<TypeEntry> types;
        types.append(makeComposite(1, "Alpha", "struct"));
        types.append(makeComposite(2, "Bravo", "struct"));
        types.append(makeComposite(3, "Charlie", "struct"));
        types.append(makeComposite(4, "Delta", "class"));

        TypeEntry cur1 = makeComposite(1, "Alpha", "struct");
        TypeEntry cur2 = makeComposite(2, "Bravo", "struct");

        QFont font("Consolas", 12);
        font.setFixedPitch(true);

        auto ms = [](qint64 ns) { return QString::number(ns / 1000000.0, 'f', 2); };

        // --- Measure cold path: new popup, first show ever ---
        {
            QElapsedTimer total;
            total.start();
            auto* popup = new TypeSelectorPopup();
            popup->setFont(font);
            popup->setTypes(types, &cur1);
            popup->popup(QPoint(100, 100));
            QApplication::processEvents();
            qint64 tCold = total.nsecsElapsed();
            popup->hide();
            QApplication::processEvents();

            qDebug() << "";
            qDebug().noquote() << QString("=== COLD (new popup, no warmUp) ===");
            qDebug().noquote() << QString("  Total: %1 ms").arg(ms(tCold));

            // --- Measure cached reuse of same instance ---
            {
                QElapsedTimer t2;
                t2.start();
                popup->setTypes(types, &cur2);
                popup->popup(QPoint(100, 100));
                QApplication::processEvents();
                qint64 tReuse = t2.nsecsElapsed();
                popup->hide();
                QApplication::processEvents();

                qDebug() << "";
                qDebug().noquote() << QString("=== WARM (reuse same popup) ===");
                qDebug().noquote() << QString("  Total: %1 ms").arg(ms(tReuse));
            }

            delete popup;
        }

        // --- Measure warmUp() approach ---
        {
            QElapsedTimer tWarmup;
            tWarmup.start();
            auto* popup2 = new TypeSelectorPopup();
            popup2->warmUp();
            qint64 tWarmMs = tWarmup.nsecsElapsed();

            qDebug() << "";
            qDebug().noquote() << QString("=== warmUp() cost (constructor + hidden show/hide) ===");
            qDebug().noquote() << QString("  Total: %1 ms").arg(ms(tWarmMs));

            // First user-visible show after warmUp
            QElapsedTimer t3;
            t3.start();
            popup2->setFont(font);
            popup2->setTypes(types, &cur1);
            popup2->popup(QPoint(100, 100));
            QApplication::processEvents();
            qint64 tFirst = t3.nsecsElapsed();
            popup2->hide();
            QApplication::processEvents();

            qDebug() << "";
            qDebug().noquote() << QString("=== FIRST visible show after warmUp() ===");
            qDebug().noquote() << QString("  Total: %1 ms").arg(ms(tFirst));

            // Second show (fully warm)
            QElapsedTimer t4;
            t4.start();
            popup2->setTypes(types, &cur2);
            popup2->popup(QPoint(100, 100));
            QApplication::processEvents();
            qint64 tSecond = t4.nsecsElapsed();
            popup2->hide();
            QApplication::processEvents();

            qDebug() << "";
            qDebug().noquote() << QString("=== SECOND visible show after warmUp() ===");
            qDebug().noquote() << QString("  Total: %1 ms").arg(ms(tSecond));

            delete popup2;
        }
    }

    // ── Isolate first-show cost with different window flags ──

    void benchmarkFirstShow() {
        auto ms = [](qint64 ns) { return QString::number(ns / 1000000.0, 'f', 2); };

        struct FlagTest {
            const char* name;
            Qt::WindowFlags flags;
        };
        FlagTest tests[] = {
            {"Qt::Popup|Frameless",         Qt::Popup | Qt::FramelessWindowHint},
            {"Qt::Tool|Frameless",          Qt::Tool | Qt::FramelessWindowHint},
            {"Qt::ToolTip",                 Qt::ToolTip},
            {"Qt::Window|Frameless",        Qt::Window | Qt::FramelessWindowHint},
            {"Qt::Popup|Frameless (2nd)",   Qt::Popup | Qt::FramelessWindowHint},
        };

        for (const auto& test : tests) {
            auto* f = new QFrame(nullptr, test.flags);
            f->resize(300, 400);

            QElapsedTimer t; t.start();
            f->show();
            qint64 t1 = t.nsecsElapsed(); t.restart();
            QApplication::processEvents();
            qint64 t2 = t.nsecsElapsed();
            f->hide();
            QApplication::processEvents();

            t.restart();
            f->show();
            qint64 t3 = t.nsecsElapsed(); t.restart();
            QApplication::processEvents();
            qint64 t4 = t.nsecsElapsed();
            f->hide();
            QApplication::processEvents();

            qDebug() << "";
            qDebug().noquote() << QString("=== %1 ===").arg(test.name);
            qDebug().noquote() << QString("  1st: show=%1ms events=%2ms | 2nd: show=%3ms events=%4ms")
                .arg(ms(t1)).arg(ms(t2)).arg(ms(t3)).arg(ms(t4));
            delete f;
        }

        // TypeSelectorPopup: cold vs after warmUp
        {
            auto* popup = new TypeSelectorPopup();
            TypeEntry dummy;
            dummy.entryKind = TypeEntry::Primitive;
            dummy.primitiveKind = NodeKind::Hex8;
            dummy.displayName = "test";
            popup->setTypes({dummy});

            QElapsedTimer t; t.start();
            popup->show();
            qint64 t1 = t.nsecsElapsed(); t.restart();
            QApplication::processEvents();
            qint64 t2 = t.nsecsElapsed();
            popup->hide();
            QApplication::processEvents();

            t.restart();
            popup->show();
            qint64 t3 = t.nsecsElapsed(); t.restart();
            QApplication::processEvents();
            qint64 t4 = t.nsecsElapsed();
            popup->hide();
            QApplication::processEvents();

            qDebug() << "";
            qDebug().noquote() << QString("=== TypeSelectorPopup (cold, Qt::Popup) ===");
            qDebug().noquote() << QString("  1st: show=%1ms events=%2ms | 2nd: show=%3ms events=%4ms")
                .arg(ms(t1)).arg(ms(t2)).arg(ms(t3)).arg(ms(t4));
            delete popup;
        }

        // Clean order test: dummy popup with children FIRST, then TypeSelectorPopup
        qDebug() << "";
        qDebug() << "=== CLEAN: dummy popup first, then TypeSelectorPopup ===";
        {
            auto* dummy = new QFrame(nullptr, Qt::Popup | Qt::FramelessWindowHint);
            dummy->resize(300, 400);
            auto* dLay = new QVBoxLayout(dummy);
            dLay->addWidget(new QLabel("dummy"));
            dLay->addWidget(new QLineEdit);
            auto* dModel = new QStringListModel(dummy);
            QStringList dItems; for (int i = 0; i < 10; i++) dItems << "x";
            dModel->setStringList(dItems);
            auto* dLv = new QListView; dLv->setModel(dModel);
            dLay->addWidget(dLv);

            QElapsedTimer t; t.start();
            dummy->show();
            qint64 t1 = t.nsecsElapsed(); t.restart();
            QApplication::processEvents();
            qint64 t2 = t.nsecsElapsed();
            dummy->hide();
            QApplication::processEvents();
            qDebug().noquote() << QString("  Dummy popup: show=%1ms events=%2ms").arg(ms(t1)).arg(ms(t2));
            delete dummy;
        }
        {
            auto* popup = new TypeSelectorPopup();
            TypeEntry e;
            e.entryKind = TypeEntry::Primitive;
            e.primitiveKind = NodeKind::Hex8;
            e.displayName = "test";
            popup->setTypes({e});
            popup->resize(300, 400);
            QElapsedTimer t; t.start();
            popup->show();
            qint64 t1 = t.nsecsElapsed(); t.restart();
            QApplication::processEvents();
            qint64 t2 = t.nsecsElapsed();
            popup->hide();
            QApplication::processEvents();
            qDebug().noquote() << QString("  TypeSelectorPopup (after dummy): show=%1ms events=%2ms").arg(ms(t1)).arg(ms(t2));
            delete popup;
        }
    }

    // ── Popup data model ──

    void testPopupListsRootStructs() {
        NodeTree tree;
        buildTwoRootTree(tree);

        QVector<TypeEntry> types;
        for (const auto& n : tree.nodes) {
            if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                TypeEntry e;
                e.entryKind = TypeEntry::Composite;
                e.structId = n.id;
                e.displayName = n.structTypeName.isEmpty() ? n.name : n.structTypeName;
                e.classKeyword = n.resolvedClassKeyword();
                types.append(e);
            }
        }

        QCOMPARE(types.size(), 2);
        QCOMPARE(types[0].displayName, QString("Alpha"));
        QCOMPARE(types[1].displayName, QString("Bravo"));
    }

    // ── Popup signals ──

    void testPopupSignals() {
        TypeSelectorPopup popup;

        TypeEntry eA;
        eA.entryKind = TypeEntry::Composite;
        eA.structId = 1;
        eA.displayName = "A";
        eA.classKeyword = "struct";
        TypeEntry eB;
        eB.entryKind = TypeEntry::Composite;
        eB.structId = 2;
        eB.displayName = "B";
        eB.classKeyword = "struct";
        QVector<TypeEntry> types;
        types.append(eA);
        types.append(eB);
        popup.setTypes(types, &eA);

        QSignalSpy typeSpy(&popup, &TypeSelectorPopup::typeSelected);
        QSignalSpy createSpy(&popup, &TypeSelectorPopup::createNewTypeRequested);

        emit popup.typeSelected(eB, QStringLiteral("B"));
        QCOMPARE(typeSpy.count(), 1);
        // Verify the entry came through — check the fullText (second arg)
        QCOMPARE(typeSpy.at(0).at(1).toString(), QStringLiteral("B"));

        emit popup.createNewTypeRequested();
        QCOMPARE(createSpy.count(), 1);
    }

    // ── Full GUI integration ──
    // Single test method to avoid QScintilla reinit issues.

    void testViewSwitchingAndCreateType() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        auto* editor = ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));

        // Initial refresh so compose populates meta + editor text
        ctrl->refresh();
        QApplication::processEvents();

        auto* sci = editor->scintilla();

        // -- Command row starts with [U+25B8] --
        {
            const LineMeta* meta = editor->metaForLine(0);
            QVERIFY(meta);
            QCOMPARE(meta->lineKind, LineKind::CommandRow);

            QString line0 = sci->text(0);
            if (line0.endsWith('\n')) line0.chop(1);
            QVERIFY2(line0.startsWith(QStringLiteral("[\u25B8]")),
                     qPrintable("Expected chevron prefix, got: " + line0.left(10)));
        }

        // -- Find root IDs --
        uint64_t alphaId = 0, bravoId = 0;
        for (const auto& n : doc->tree.nodes) {
            if (n.parentId == 0 && n.kind == NodeKind::Struct) {
                if (n.name == "Alpha") alphaId = n.id;
                if (n.name == "Bravo") bravoId = n.id;
            }
        }
        QVERIFY(alphaId != 0);
        QVERIFY(bravoId != 0);
        QCOMPARE(ctrl->viewRootId(), (uint64_t)0);

        // -- Switch to Bravo: command row + fields update --
        ctrl->setViewRootId(bravoId);
        QApplication::processEvents();

        QCOMPARE(ctrl->viewRootId(), bravoId);
        QVERIFY2(sci->text(0).contains("Bravo"),
                 qPrintable("Expected 'Bravo' in command row, got: " + sci->text(0)));
        QVERIFY2(sci->text().contains("speed"),
                 "View should show Bravo's 'speed' field");

        // -- Switch to Alpha --
        ctrl->setViewRootId(alphaId);
        QApplication::processEvents();

        QCOMPARE(ctrl->viewRootId(), alphaId);
        QVERIFY2(sci->text(0).contains("Alpha"),
                 qPrintable("Expected 'Alpha' in command row, got: " + sci->text(0)));

        // -- Create new type (no name) --
        int nodesBefore = doc->tree.nodes.size();

        Node newNode;
        newNode.kind = NodeKind::Struct;
        newNode.name = QString();
        newNode.parentId = 0;
        newNode.offset = 0;
        newNode.id = doc->tree.reserveId();
        uint64_t newId = newNode.id;

        doc->undoStack.push(new RcxCommand(ctrl, cmd::Insert{newNode}));
        ctrl->setViewRootId(newId);
        QApplication::processEvents();

        // Verify new struct
        int idx = doc->tree.indexOfId(newId);
        QVERIFY(idx >= 0);
        QVERIFY(doc->tree.nodes[idx].name.isEmpty());
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Struct);
        QCOMPARE(doc->tree.nodes[idx].parentId, (uint64_t)0);
        QCOMPARE(ctrl->viewRootId(), newId);

        // Command row shows "NoName" for empty-named struct
        QVERIFY2(sci->text(0).contains("NoName"),
                 qPrintable("Expected 'NoName' in command row, got: " + sci->text(0)));

        // -- Undo removes the new struct --
        doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(doc->tree.nodes.size(), nodesBefore);

        // Cleanup
        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── parseTypeSpec tests ──

    void testParseTypeSpecPlain() {
        TypeSpec spec = parseTypeSpec("int32_t");
        QCOMPARE(spec.baseName, QString("int32_t"));
        QVERIFY(!spec.isPointer);
        QCOMPARE(spec.arrayCount, 0);
    }

    void testParseTypeSpecArray() {
        TypeSpec spec = parseTypeSpec("int32_t[10]");
        QCOMPARE(spec.baseName, QString("int32_t"));
        QVERIFY(!spec.isPointer);
        QCOMPARE(spec.arrayCount, 10);
    }

    void testParseTypeSpecPointer() {
        TypeSpec spec = parseTypeSpec("Ball*");
        QCOMPARE(spec.baseName, QString("Ball"));
        QVERIFY(spec.isPointer);
        QCOMPARE(spec.ptrDepth, 1);
        QCOMPARE(spec.arrayCount, 0);
    }

    void testParseTypeSpecDoublePointer() {
        TypeSpec spec = parseTypeSpec("Ball**");
        QCOMPARE(spec.baseName, QString("Ball"));
        QVERIFY(spec.isPointer);
        QCOMPARE(spec.ptrDepth, 2);
    }

    void testParseTypeSpecEmpty() {
        TypeSpec spec = parseTypeSpec("");
        QVERIFY(spec.baseName.isEmpty());
        QVERIFY(!spec.isPointer);
        QCOMPARE(spec.arrayCount, 0);
    }

    void testParseTypeSpecWhitespace() {
        TypeSpec spec = parseTypeSpec("  Ball *  ");
        // trimmed → "Ball *", ends with '*'
        QCOMPARE(spec.baseName, QString("Ball"));
        QVERIFY(spec.isPointer);
    }

    void testParseTypeSpecArrayZero() {
        // [0] parses baseName but arrayCount stays 0 (invalid count)
        TypeSpec spec = parseTypeSpec("int32_t[0]");
        QCOMPARE(spec.baseName, QString("int32_t"));
        QCOMPARE(spec.arrayCount, 0);
    }

    // ── FieldType popup: selecting a composite (struct) type changes node kind + structTypeName + collapsed ──

    void testFieldTypeCompositeChangesNodeToStruct() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32) inside Alpha struct, and Bravo struct id
        int xIdx = -1;
        uint64_t bravoId = 0;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            const auto& n = doc->tree.nodes[i];
            if (n.name == "x" && n.kind == NodeKind::Int32) xIdx = i;
            if (n.name == "Bravo" && n.kind == NodeKind::Struct) bravoId = n.id;
        }
        QVERIFY(xIdx >= 0);
        QVERIFY(bravoId != 0);

        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);
        QVERIFY(!doc->tree.nodes[xIdx].collapsed);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        // Simulate the plain-struct path of applyTypePopupResult:
        // beginMacro → changeNodeKind(Struct) → ChangeStructTypeName → ChangePointerRef → endMacro
        doc->undoStack.beginMacro(QStringLiteral("Change to composite type"));
        ctrl->changeNodeKind(xIdx, NodeKind::Struct);

        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);

        int bravoIdx = doc->tree.indexOfId(bravoId);
        QVERIFY(bravoIdx >= 0);
        QString targetName = doc->tree.nodes[bravoIdx].structTypeName;

        doc->undoStack.push(new RcxCommand(ctrl,
            cmd::ChangeStructTypeName{xNodeId, doc->tree.nodes[xIdx].structTypeName, targetName}));

        // Set refId so compose can expand referenced struct children (auto-collapses)
        doc->undoStack.push(new RcxCommand(ctrl,
            cmd::ChangePointerRef{xNodeId, 0, bravoId}));

        doc->undoStack.endMacro();
        QApplication::processEvents();

        // Verify: Struct with correct name, refId, AND collapsed
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Struct);
        QCOMPARE(doc->tree.nodes[xIdx].structTypeName, QString("Bravo"));
        QCOMPARE(doc->tree.nodes[xIdx].refId, bravoId);
        QVERIFY(doc->tree.nodes[xIdx].collapsed);

        // Single undo reverses the entire macro
        doc->undoStack.undo();
        QApplication::processEvents();
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);
        QCOMPARE(doc->tree.nodes[xIdx].refId, uint64_t(0));
        QVERIFY(doc->tree.nodes[xIdx].structTypeName.isEmpty());

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── FieldType popup: selecting a composite with * modifier creates Pointer64 + refId ──

    void testFieldTypeCompositeWithPointerModifier() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32) and Bravo struct
        int xIdx = -1;
        uint64_t bravoId = 0;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            const auto& n = doc->tree.nodes[i];
            if (n.name == "x" && n.kind == NodeKind::Int32) xIdx = i;
            if (n.name == "Bravo" && n.kind == NodeKind::Struct) bravoId = n.id;
        }
        QVERIFY(xIdx >= 0);
        QVERIFY(bravoId != 0);

        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        // Simulate the pointer path of applyTypePopupResult:
        // beginMacro → changeNodeKind(Pointer64) → ChangePointerRef → endMacro
        doc->undoStack.beginMacro(QStringLiteral("Change to composite type"));
        ctrl->changeNodeKind(xIdx, NodeKind::Pointer64);

        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Pointer64);

        doc->undoStack.push(new RcxCommand(ctrl,
            cmd::ChangePointerRef{xNodeId, 0, bravoId}));
        doc->undoStack.endMacro();
        QApplication::processEvents();

        // Verify: Pointer64 with refId pointing to Bravo, auto-collapsed
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[xIdx].refId, bravoId);
        QVERIFY(doc->tree.nodes[xIdx].collapsed);

        // Single undo reverses the entire macro
        doc->undoStack.undo();
        QApplication::processEvents();
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);
        QCOMPARE(doc->tree.nodes[xIdx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── FieldType popup: selecting a primitive type still works ──

    void testFieldTypePrimitiveStillWorks() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32)
        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);

        // Change to Float via changeNodeKind (same path as primitive TypeEntry)
        ctrl->changeNodeKind(xIdx, NodeKind::Float);
        QApplication::processEvents();
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Float);

        // Undo
        doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── Section headers in filtered list ──

    void testSectionHeadersPresent() {
        TypeSelectorPopup popup;

        // Build entries with both primitives and composites
        QVector<TypeEntry> types;
        TypeEntry prim;
        prim.entryKind = TypeEntry::Primitive;
        prim.primitiveKind = NodeKind::Int32;
        prim.displayName = "int32_t";
        types.append(prim);

        TypeEntry comp;
        comp.entryKind = TypeEntry::Composite;
        comp.structId = 42;
        comp.displayName = "MyStruct";
        comp.classKeyword = "struct";
        types.append(comp);

        popup.setTypes(types);
        // After setTypes, the internal filtered list should have section headers
        // We can verify this indirectly by checking the model row count
        // (should be > 2 due to section headers)
        auto* listView = popup.findChild<QListView*>();
        QVERIFY(listView);
        QVERIFY(listView->model()->rowCount() > 2);
    }
    // ── FieldType popup: primitive with [n] creates an array ──

    void testFieldTypePrimitiveArrayCreation() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32)
        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        // Simulate the primitive-array path of applyTypePopupResult:
        // beginMacro → changeNodeKind(Array) → ChangeArrayMeta → endMacro
        doc->undoStack.beginMacro(QStringLiteral("Change to primitive array"));
        ctrl->changeNodeKind(xIdx, NodeKind::Array);
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        doc->undoStack.push(new RcxCommand(ctrl,
            cmd::ChangeArrayMeta{xNodeId, doc->tree.nodes[xIdx].elementKind,
                                 NodeKind::Int32,
                                 doc->tree.nodes[xIdx].arrayLen, 4}));
        doc->undoStack.endMacro();
        QApplication::processEvents();

        // Node should now be an Array
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Array);
        QCOMPARE(doc->tree.nodes[xIdx].elementKind, NodeKind::Int32);
        QCOMPARE(doc->tree.nodes[xIdx].arrayLen, 4);

        // Single undo reverses the entire macro
        doc->undoStack.undo();
        QApplication::processEvents();
        xIdx = doc->tree.indexOfId(xNodeId);
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);

        delete ctrl;
        delete splitter;
        delete doc;
    }
    // ── Test: SVG icon and gutter scale with font size ──

    void testDelegateIconScalesWithFont() {
        // Create a popup and set two different font sizes.
        // The delegate sizeHint row height should scale with font.
        TypeSelectorPopup popup;

        TypeEntry prim;
        prim.entryKind = TypeEntry::Primitive;
        prim.primitiveKind = NodeKind::Int32;
        prim.displayName = QStringLiteral("int32_t");

        TypeEntry comp;
        comp.entryKind = TypeEntry::Composite;
        comp.structId = 100;
        comp.displayName = QStringLiteral("TestStruct");
        comp.classKeyword = QStringLiteral("struct");

        // Small font
        QFont small(QStringLiteral("Consolas"), 9);
        popup.setFont(small);
        popup.setTypes({prim, comp});
        popup.popup(QPoint(-9999, -9999));  // offscreen
        QApplication::processEvents();

        auto* listView = popup.findChild<QListView*>();
        QVERIFY(listView);
        auto* delegate = listView->itemDelegate();
        QVERIFY(delegate);

        // Find first non-section row for consistent measurement
        int dataRow = -1;
        for (int i = 0; i < listView->model()->rowCount(); i++) {
            QSize h = delegate->sizeHint(QStyleOptionViewItem(), listView->model()->index(i, 0));
            // Non-section rows are taller (font.height + 8 vs + 2)
            if (h.height() > QFontMetrics(small).height() + 4) { dataRow = i; break; }
        }
        QVERIFY2(dataRow >= 0, "Should find a non-section row");

        QSize smallHint = delegate->sizeHint(QStyleOptionViewItem(), listView->model()->index(dataRow, 0));
        popup.hide();

        // Large font (simulates zoomed editor)
        QFont large(QStringLiteral("Consolas"), 18);
        popup.setFont(large);
        popup.setTypes({prim, comp});
        popup.popup(QPoint(-9999, -9999));
        QApplication::processEvents();

        QSize largeHint = delegate->sizeHint(QStyleOptionViewItem(), listView->model()->index(dataRow, 0));
        popup.hide();

        // Large font should produce taller rows than small font
        QVERIFY2(largeHint.height() > smallHint.height(),
                 qPrintable(QString("Large hint %1 should be > small hint %2")
                     .arg(largeHint.height()).arg(smallHint.height())));

        // The ratio should roughly match the font size ratio (18/9 = 2x)
        double ratio = double(largeHint.height()) / double(smallHint.height());
        QVERIFY2(ratio > 1.4, qPrintable(QString("Row height ratio %1 should be > 1.4").arg(ratio)));
    }

    void testPopupWidthScalesWithFont() {
        TypeSelectorPopup popup;

        TypeEntry comp;
        comp.entryKind = TypeEntry::Composite;
        comp.structId = 100;
        comp.displayName = QStringLiteral("MyLongStructName");
        comp.classKeyword = QStringLiteral("struct");
        popup.setTypes({comp});

        // Small font
        QFont small(QStringLiteral("Consolas"), 9);
        popup.setFont(small);
        popup.popup(QPoint(-9999, -9999));
        QApplication::processEvents();
        int smallW = popup.width();
        popup.hide();

        // Large font
        QFont large(QStringLiteral("Consolas"), 18);
        popup.setFont(large);
        popup.setTypes({comp});
        popup.popup(QPoint(-9999, -9999));
        QApplication::processEvents();
        int largeW = popup.width();
        popup.hide();

        // Popup with larger font should be wider
        QVERIFY2(largeW > smallW,
                 qPrintable(QString("Large popup width %1 should be > small %2")
                     .arg(largeW).arg(smallW)));
    }
    // ── Test: popup updates colors when theme changes ──

    void testPopupUpdatesOnThemeChange() {
        auto& tm = ThemeManager::instance();
        int origIdx = tm.currentIndex();

        // Ensure at least two themes exist
        QVERIFY2(tm.themes().size() >= 2,
                 "Need at least 2 themes to test theme switching");

        // Create popup with current theme
        TypeSelectorPopup popup;
        TypeEntry prim;
        prim.entryKind = TypeEntry::Primitive;
        prim.primitiveKind = NodeKind::Int32;
        prim.displayName = QStringLiteral("int32_t");
        popup.setTypes({prim});

        QColor bgBefore = popup.palette().color(QPalette::Window);

        // Switch to a different theme
        int otherIdx = (origIdx == 0) ? 1 : 0;
        tm.setCurrent(otherIdx);
        QApplication::processEvents();

        // The popup should have applyTheme connected to themeChanged
        popup.applyTheme(tm.current());
        QColor bgAfter = popup.palette().color(QPalette::Window);

        // If the two themes have different background colors, verify the change
        // (some themes may coincidentally share colors, so we just verify the
        // method doesn't crash and the palette is set to the new theme's color)
        QCOMPARE(bgAfter, tm.current().backgroundAlt);

        // Also verify child widgets got updated
        auto* filterEdit = popup.findChild<QLineEdit*>();
        QVERIFY(filterEdit);
        QCOMPARE(filterEdit->palette().color(QPalette::Base),
                 tm.current().background);

        auto* listView = popup.findChild<QListView*>();
        QVERIFY(listView);
        QCOMPARE(listView->palette().color(QPalette::Base),
                 tm.current().background);

        // Restore original theme
        tm.setCurrent(origIdx);
    }

    void testPopupAutoConnectsThemeChange() {
        auto& tm = ThemeManager::instance();
        int origIdx = tm.currentIndex();
        QVERIFY2(tm.themes().size() >= 2, "Need >= 2 themes");

        TypeSelectorPopup popup;

        // applyTheme is a public slot — verify it can be connected
        connect(&tm, &ThemeManager::themeChanged,
                &popup, &TypeSelectorPopup::applyTheme);

        QColor bgBefore = popup.palette().color(QPalette::Window);

        int otherIdx = (origIdx == 0) ? 1 : 0;
        tm.setCurrent(otherIdx);
        QApplication::processEvents();

        // After theme change + signal, popup palette should match new theme
        QCOMPARE(popup.palette().color(QPalette::Window),
                 tm.current().backgroundAlt);

        // Restore
        tm.setCurrent(origIdx);
    }

    // ── parseTypeSpec: primitive pointer ptrDepth ──

    void testParseTypeSpecPrimitiveStar() {
        TypeSpec spec = parseTypeSpec("int32_t*");
        QCOMPARE(spec.baseName, QString("int32_t"));
        QVERIFY(spec.isPointer);
        QCOMPARE(spec.ptrDepth, 1);
        QCOMPARE(spec.arrayCount, 0);
    }

    void testParseTypeSpecPrimitiveDoubleStar() {
        TypeSpec spec = parseTypeSpec("f64**");
        QCOMPARE(spec.baseName, QString("f64"));
        QVERIFY(spec.isPointer);
        QCOMPARE(spec.ptrDepth, 2);
        QCOMPARE(spec.arrayCount, 0);
    }

    // ── Primitive pointer creation via applyTypePopupResult path ──

    void testPrimitivePointerCreation() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32) inside Alpha
        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        QCOMPARE(doc->tree.nodes[xIdx].kind, NodeKind::Int32);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        // Simulate the primitive-pointer path: Int32 → Pointer64 + elementKind=Int32 + ptrDepth=1
        doc->undoStack.beginMacro(QStringLiteral("Change to primitive pointer"));
        ctrl->changeNodeKind(xIdx, NodeKind::Pointer64);
        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        doc->tree.nodes[idx].elementKind = NodeKind::Int32;
        doc->tree.nodes[idx].ptrDepth = 1;
        doc->undoStack.endMacro();
        QApplication::processEvents();

        // Verify: Pointer64 with elementKind=Int32, ptrDepth=1, refId=0
        idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].elementKind, NodeKind::Int32);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 1);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        // Undo reverses the macro
        doc->undoStack.undo();
        QApplication::processEvents();
        idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Int32);

        delete ctrl;
        delete splitter;
        delete doc;
    }

    void testDoublePointerCreation() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32) inside Alpha
        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        // Simulate: Int32 → Pointer64 + elementKind=Double + ptrDepth=2
        doc->undoStack.beginMacro(QStringLiteral("Change to double pointer"));
        ctrl->changeNodeKind(xIdx, NodeKind::Pointer64);
        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        doc->tree.nodes[idx].elementKind = NodeKind::Double;
        doc->tree.nodes[idx].ptrDepth = 2;
        doc->undoStack.endMacro();
        QApplication::processEvents();

        // Verify: Pointer64 with elementKind=Double, ptrDepth=2
        idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].elementKind, NodeKind::Double);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 2);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── ptrDepth JSON round-trip ──

    void testPtrDepthJsonRoundTrip() {
        Node n;
        n.kind = NodeKind::Pointer64;
        n.name = "pData";
        n.elementKind = NodeKind::Float;
        n.ptrDepth = 2;
        n.id = 42;

        QJsonObject obj = n.toJson();
        QCOMPARE(obj["ptrDepth"].toInt(), 2);

        Node restored = Node::fromJson(obj);
        QCOMPARE(restored.ptrDepth, 2);
        QCOMPARE(restored.elementKind, NodeKind::Float);
        QCOMPARE(restored.kind, NodeKind::Pointer64);
    }

    void testPtrDepthJsonDefault() {
        // Nodes without ptrDepth in JSON should default to 0
        Node n;
        n.kind = NodeKind::Pointer64;
        n.name = "pVoid";
        n.id = 99;

        QJsonObject obj = n.toJson();
        // ptrDepth==0 is not serialized
        QVERIFY(!obj.contains("ptrDepth"));

        Node restored = Node::fromJson(obj);
        QCOMPARE(restored.ptrDepth, 0);
    }

    // ── setMode always resets modifier buttons ──

    void testSetModeResetsModifierInPointerTargetMode() {
        TypeSelectorPopup popup;

        // Set FieldType mode and select * modifier
        popup.setMode(TypePopupMode::FieldType);
        popup.setModifier(1);  // select *

        // Now switch to PointerTarget mode — should reset to plain
        popup.setMode(TypePopupMode::PointerTarget);

        // Verify: modifier buttons are hidden but internally reset to plain (modId=0)
        // This means primitives will be visible in applyFilter
        TypeEntry prim;
        prim.entryKind = TypeEntry::Primitive;
        prim.primitiveKind = NodeKind::Int32;
        prim.displayName = "int32_t";

        TypeEntry voidEntry;
        voidEntry.entryKind = TypeEntry::Primitive;
        voidEntry.primitiveKind = NodeKind::Pointer64;
        voidEntry.displayName = "void";

        popup.setTypes({prim, voidEntry});

        // Both primitives should be visible (not filtered out)
        auto* listView = popup.findChild<QListView*>();
        QVERIFY(listView);
        int rowCount = listView->model()->rowCount();
        // Should have section header + 2 primitives = at least 3 rows
        QVERIFY2(rowCount >= 3,
                 qPrintable(QString("Expected >=3 rows (header+2 prims), got %1").arg(rowCount)));
    }

    // ── setModifier preselection ──

    void testSetModifierPreselects() {
        TypeSelectorPopup popup;

        // Test * preselection
        popup.setMode(TypePopupMode::FieldType);
        popup.setModifier(1);
        auto* btnGroup = popup.findChild<QButtonGroup*>();
        QVERIFY(btnGroup);
        QCOMPARE(btnGroup->checkedId(), 1);

        // Test ** preselection
        popup.setMode(TypePopupMode::FieldType);
        popup.setModifier(2);
        QCOMPARE(btnGroup->checkedId(), 2);

        // Test [n] preselection with count
        popup.setMode(TypePopupMode::FieldType);
        popup.setModifier(3, 8);
        QCOMPARE(btnGroup->checkedId(), 3);
        auto* countEdit = popup.findChild<QLineEdit*>(QStringLiteral("arrayCountEdit"));
        // Array count edit may not have objectName set; find via parent
        // Just verify button group is correct
    }

    // ── isValidPrimitivePtrTarget ──

    void testIsValidPrimitivePtrTarget() {
        // Hex types → NOT valid (deref shows same hex as void*)
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Hex8));
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Hex16));
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Hex32));
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Hex64));

        // Pointer types → NOT valid (use composite * for chains)
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Pointer32));
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Pointer64));

        // Function pointers → NOT valid
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::FuncPtr32));
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::FuncPtr64));

        // Containers → NOT valid
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Struct));
        QVERIFY(!isValidPrimitivePtrTarget(NodeKind::Array));

        // Value types → valid
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::Int32));
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::UInt64));
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::Float));
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::Double));
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::Bool));
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::Vec3));
        QVERIFY(isValidPrimitivePtrTarget(NodeKind::UTF8));
    }

    // ── hex64* falls back to void* ──

    void testHex64StarFallsBackToVoidPointer() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the "x" field (Int32)
        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        // Build a TypeEntry for hex64
        TypeEntry hexEntry;
        hexEntry.entryKind = TypeEntry::Primitive;
        hexEntry.primitiveKind = NodeKind::Hex64;
        hexEntry.displayName = "hex64";

        // Apply it with pointer modifier (fullText = "hex64*")
        ctrl->applyTypePopupResult(TypePopupMode::FieldType, xIdx,
                                   hexEntry, QStringLiteral("hex64*"));
        QApplication::processEvents();

        // Should be a void pointer: Pointer64, ptrDepth=0, refId=0
        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 0);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    void testHex8StarFallsBackToVoidPointer() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        TypeEntry hexEntry;
        hexEntry.entryKind = TypeEntry::Primitive;
        hexEntry.primitiveKind = NodeKind::Hex8;
        hexEntry.displayName = "hex8";

        ctrl->applyTypePopupResult(TypePopupMode::FieldType, xIdx,
                                   hexEntry, QStringLiteral("hex8*"));
        QApplication::processEvents();

        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 0);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    void testPtr64StarFallsBackToVoidPointer() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        TypeEntry ptrEntry;
        ptrEntry.entryKind = TypeEntry::Primitive;
        ptrEntry.primitiveKind = NodeKind::Pointer64;
        ptrEntry.displayName = "ptr64";

        ctrl->applyTypePopupResult(TypePopupMode::FieldType, xIdx,
                                   ptrEntry, QStringLiteral("ptr64*"));
        QApplication::processEvents();

        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 0);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── Valid primitive pointers still work ──

    void testInt32StarStillCreatesPrimitivePointer() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        TypeEntry intEntry;
        intEntry.entryKind = TypeEntry::Primitive;
        intEntry.primitiveKind = NodeKind::Int32;
        intEntry.displayName = "int32_t";

        ctrl->applyTypePopupResult(TypePopupMode::FieldType, xIdx,
                                   intEntry, QStringLiteral("int32_t*"));
        QApplication::processEvents();

        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 1);
        QCOMPARE(doc->tree.nodes[idx].elementKind, NodeKind::Int32);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    void testDoubleDoubleStarStillCreatesPrimitivePointer() {
        auto* doc = new RcxDocument();
        buildTwoRootTree(doc->tree);
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        int xIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].name == "x") { xIdx = i; break; }
        }
        QVERIFY(xIdx >= 0);
        uint64_t xNodeId = doc->tree.nodes[xIdx].id;

        TypeEntry dblEntry;
        dblEntry.entryKind = TypeEntry::Primitive;
        dblEntry.primitiveKind = NodeKind::Double;
        dblEntry.displayName = "double";

        ctrl->applyTypePopupResult(TypePopupMode::FieldType, xIdx,
                                   dblEntry, QStringLiteral("double**"));
        QApplication::processEvents();

        int idx = doc->tree.indexOfId(xNodeId);
        QVERIFY(idx >= 0);
        QCOMPARE(doc->tree.nodes[idx].kind, NodeKind::Pointer64);
        QCOMPARE(doc->tree.nodes[idx].ptrDepth, 2);
        QCOMPARE(doc->tree.nodes[idx].elementKind, NodeKind::Double);
        QCOMPARE(doc->tree.nodes[idx].refId, uint64_t(0));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── Defense: compose/format treat invalid ptrDepth as void* ──

    void testComposeShowsVoidPtrForHexPtrDepth() {
        // If a node somehow has ptrDepth>0 with hex elementKind
        // (e.g. from old JSON), compose should show "void*" not "hex64*"
        NodeTree tree;
        tree.baseAddress = 0x1000;

        Node root;
        root.kind = NodeKind::Struct;
        root.name = "Test";
        root.structTypeName = "Test";
        root.parentId = 0;
        tree.addNode(root);
        uint64_t rootId = tree.nodes[0].id;

        Node ptr;
        ptr.kind = NodeKind::Pointer64;
        ptr.name = "badPtr";
        ptr.parentId = rootId;
        ptr.offset = 0;
        ptr.ptrDepth = 1;
        ptr.elementKind = NodeKind::Hex64;  // invalid target
        tree.addNode(ptr);

        QByteArray buf(0x100, '\0');
        BufferProvider prov(buf);

        ComposeResult result = compose(tree, prov);

        // The composed text should NOT contain "hex64*" — the invalid target
        // should fall through to normal void pointer display
        QVERIFY2(!result.text.contains("hex64*"),
                 qPrintable("Should not show 'hex64*', got: " + result.text));
    }
};

QTEST_MAIN(TestTypeSelector)
#include "test_type_selector.moc"

```

`tests/test_type_visibility.cpp`:

```cpp
#include <QtTest/QTest>
#include <QApplication>
#include <QSplitter>
#include <Qsci/qsciscintilla.h>
#include "controller.h"
#include "typeselectorpopup.h"
#include "core.h"
#include "providers/buffer_provider.h"

using namespace rcx;

static QByteArray makeBuffer() { return QByteArray(0x200, '\0'); }

// Build a tree with one root struct + a Pointer64 field
static void buildPointerTree(NodeTree& tree, const QString& rootName) {
    tree.baseAddress = 0;
    Node root;
    root.kind = NodeKind::Struct;
    root.name = "instance";
    root.structTypeName = rootName;
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    Node ptr;
    ptr.kind = NodeKind::Pointer64;
    ptr.name = "ptr";
    ptr.parentId = rootId;
    ptr.offset = 0;
    tree.addNode(ptr);
}

class TestTypeVisibility : public QObject {
    Q_OBJECT

private slots:

    // ── 1. New types created via createNewTypeRequested get a default name ──

    void testCreateNewTypeGetsDefaultName() {
        auto* doc = new RcxDocument();
        buildPointerTree(doc->tree, "Main");
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);
        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        int nodesBefore = doc->tree.nodes.size();

        // Simulate what createNewTypeRequested does: create struct with default name
        // (The actual handler is a lambda; we test the result via tree inspection)
        {
            bool wasSuppressed = ctrl->document() != nullptr; Q_UNUSED(wasSuppressed);

            // Generate unique default name — same logic as the handler
            QString baseName = QStringLiteral("NewClass");
            QString typeName = baseName;
            int counter = 1;
            QSet<QString> existing;
            for (const auto& nd : doc->tree.nodes) {
                if (nd.kind == NodeKind::Struct && !nd.structTypeName.isEmpty())
                    existing.insert(nd.structTypeName);
            }
            while (existing.contains(typeName))
                typeName = baseName + QString::number(counter++);

            Node n;
            n.kind = NodeKind::Struct;
            n.structTypeName = typeName;
            n.name = QStringLiteral("instance");
            n.parentId = 0;
            n.offset = 0;
            n.id = doc->tree.reserveId();
            doc->undoStack.push(new RcxCommand(ctrl, cmd::Insert{n}));
        }

        ctrl->refresh();
        QApplication::processEvents();

        // Verify new struct was created with a name
        QCOMPARE(doc->tree.nodes.size(), nodesBefore + 1);
        bool found = false;
        for (const auto& n : doc->tree.nodes) {
            if (n.structTypeName == "NewClass") { found = true; break; }
        }
        QVERIFY2(found, "New struct should have structTypeName 'NewClass'");

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── 2. Second new type gets incremented name ──

    void testCreateNewTypeIncrementsName() {
        auto* doc = new RcxDocument();
        buildPointerTree(doc->tree, "Main");
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        // Add a struct already named "NewClass"
        {
            Node n;
            n.kind = NodeKind::Struct;
            n.structTypeName = "NewClass";
            n.name = "instance";
            n.parentId = 0;
            n.offset = 0;
            doc->tree.addNode(n);
        }

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);
        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Generate name using same logic
        QString baseName = QStringLiteral("NewClass");
        QString typeName = baseName;
        int counter = 1;
        QSet<QString> existing;
        for (const auto& nd : doc->tree.nodes) {
            if (nd.kind == NodeKind::Struct && !nd.structTypeName.isEmpty())
                existing.insert(nd.structTypeName);
        }
        while (existing.contains(typeName))
            typeName = baseName + QString::number(counter++);

        QCOMPARE(typeName, QStringLiteral("NewClass1"));

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── 3. Cross-tab: types from other documents visible via project docs ──

    void testCrossTabTypesVisible() {
        // Doc A: has "Alpha" struct with a Pointer64 field
        auto* docA = new RcxDocument();
        buildPointerTree(docA->tree, "Alpha");
        docA->provider = std::make_unique<BufferProvider>(makeBuffer());

        // Doc B: has "Beta" struct
        auto* docB = new RcxDocument();
        buildPointerTree(docB->tree, "Beta");
        docB->provider = std::make_unique<BufferProvider>(makeBuffer());

        // Shared doc list (simulates MainWindow::m_allDocs)
        QVector<RcxDocument*> allDocs;
        allDocs << docA << docB;

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(docA, nullptr);
        ctrl->addSplitEditor(splitter);
        ctrl->setProjectDocuments(&allDocs);

        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Find the Pointer64 node in docA
        int ptrIdx = -1;
        for (int i = 0; i < docA->tree.nodes.size(); i++) {
            if (docA->tree.nodes[i].kind == NodeKind::Pointer64) {
                ptrIdx = i;
                break;
            }
        }
        QVERIFY(ptrIdx >= 0);

        // Apply an external type (structId=0, displayName="Beta") as pointer target
        TypeEntry extEntry;
        extEntry.entryKind = TypeEntry::Composite;
        extEntry.structId = 0;  // external sentinel
        extEntry.displayName = QStringLiteral("Beta");
        ctrl->applyTypePopupResult(TypePopupMode::PointerTarget, ptrIdx,
                                    extEntry, QString());
        QApplication::processEvents();

        // "Beta" should now exist in docA as a local struct (imported)
        bool found = false;
        uint64_t betaLocalId = 0;
        for (const auto& n : docA->tree.nodes) {
            if (n.parentId == 0 && n.kind == NodeKind::Struct
                && n.structTypeName == "Beta") {
                found = true;
                betaLocalId = n.id;
                break;
            }
        }
        QVERIFY2(found, "Beta struct should be imported into docA");

        // The pointer's refId should point at the local Beta
        int ptrIdx2 = -1;
        for (int i = 0; i < docA->tree.nodes.size(); i++) {
            if (docA->tree.nodes[i].kind == NodeKind::Pointer64
                && docA->tree.nodes[i].name == "ptr") {
                ptrIdx2 = i;
                break;
            }
        }
        QVERIFY(ptrIdx2 >= 0);
        QCOMPARE(docA->tree.nodes[ptrIdx2].refId, betaLocalId);

        delete ctrl;
        delete splitter;
        delete docA;
        delete docB;
    }

    // ── 4. findOrCreateStructByName reuses existing local struct ──

    void testFindOrCreateReusesExisting() {
        auto* doc = new RcxDocument();
        buildPointerTree(doc->tree, "Main");
        doc->provider = std::make_unique<BufferProvider>(makeBuffer());

        // Add "Target" struct manually
        Node target;
        target.kind = NodeKind::Struct;
        target.structTypeName = "Target";
        target.name = "instance";
        target.parentId = 0;
        target.offset = 0;
        int ti = doc->tree.addNode(target);
        uint64_t targetId = doc->tree.nodes[ti].id;

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(doc, nullptr);
        ctrl->addSplitEditor(splitter);
        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        int nodesBefore = doc->tree.nodes.size();

        // Apply external entry with name "Target" — should reuse existing
        int ptrIdx = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].kind == NodeKind::Pointer64) {
                ptrIdx = i;
                break;
            }
        }
        QVERIFY(ptrIdx >= 0);

        TypeEntry extEntry;
        extEntry.entryKind = TypeEntry::Composite;
        extEntry.structId = 0;
        extEntry.displayName = QStringLiteral("Target");
        ctrl->applyTypePopupResult(TypePopupMode::PointerTarget, ptrIdx,
                                    extEntry, QString());
        QApplication::processEvents();

        // Should NOT have created a new struct — reused existing one
        QCOMPARE(doc->tree.nodes.size(), nodesBefore);

        // Pointer should reference the existing Target
        int ptrIdx2 = -1;
        for (int i = 0; i < doc->tree.nodes.size(); i++) {
            if (doc->tree.nodes[i].kind == NodeKind::Pointer64
                && doc->tree.nodes[i].name == "ptr") {
                ptrIdx2 = i;
                break;
            }
        }
        QVERIFY(ptrIdx2 >= 0);
        QCOMPARE(doc->tree.nodes[ptrIdx2].refId, targetId);

        delete ctrl;
        delete splitter;
        delete doc;
    }

    // ── 5. External types skip duplicates already in local doc ──

    void testExternalTypesSkipLocalDuplicates() {
        // Both docs have "Shared" type — should not appear twice
        auto* docA = new RcxDocument();
        buildPointerTree(docA->tree, "Shared");
        docA->provider = std::make_unique<BufferProvider>(makeBuffer());

        auto* docB = new RcxDocument();
        buildPointerTree(docB->tree, "Shared");
        docB->provider = std::make_unique<BufferProvider>(makeBuffer());

        QVector<RcxDocument*> allDocs;
        allDocs << docA << docB;

        auto* splitter = new QSplitter();
        auto* ctrl = new RcxController(docA, nullptr);
        ctrl->addSplitEditor(splitter);
        ctrl->setProjectDocuments(&allDocs);
        splitter->resize(800, 600);
        splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(splitter));
        ctrl->refresh();
        QApplication::processEvents();

        // Count how many "Shared" entries exist in local doc's root structs
        int sharedCount = 0;
        for (const auto& n : docA->tree.nodes) {
            if (n.parentId == 0 && n.kind == NodeKind::Struct
                && n.structTypeName == "Shared")
                sharedCount++;
        }
        QCOMPARE(sharedCount, 1); // only the local one

        delete ctrl;
        delete splitter;
        delete docA;
        delete docB;
    }
};

QTEST_MAIN(TestTypeVisibility)
#include "test_type_visibility.moc"

```

`tests/test_validation.cpp`:

```cpp
// Stress tests for editor/controller validation:
// – Invalid values, boundary values, excessive inputs
// – Ensures no crashes and data integrity after rejected edits
// Skips: ASCII/byte preview editing (under discussion)

#include <QtTest/QTest>
#include <QtTest/QSignalSpy>
#include <QApplication>
#include <QSplitter>
#include <Qsci/qsciscintilla.h>
#include "controller.h"
#include "core.h"

using namespace rcx;

// ── Fixture: small tree with diverse field types ──

static void buildValidationTree(NodeTree& tree) {
    tree.baseAddress = 0;

    Node root;
    root.kind = NodeKind::Struct;
    root.structTypeName = "TestStruct";
    root.name = "root";
    root.parentId = 0;
    root.offset = 0;
    int ri = tree.addNode(root);
    uint64_t rootId = tree.nodes[ri].id;

    auto field = [&](int off, NodeKind k, const char* name) {
        Node n;
        n.kind = k; n.name = name;
        n.parentId = rootId; n.offset = off;
        tree.addNode(n);
    };
    auto fieldArr = [&](int off, NodeKind ek, int count, const char* name) {
        Node n;
        n.kind = NodeKind::Array; n.name = name;
        n.parentId = rootId; n.offset = off;
        n.arrayLen = count; n.elementKind = ek;
        tree.addNode(n);
    };

    field(0,  NodeKind::Int8,       "field_i8");
    field(1,  NodeKind::UInt8,      "field_u8");
    field(2,  NodeKind::Int16,      "field_i16");
    field(4,  NodeKind::UInt16,     "field_u16");
    field(6,  NodeKind::Int32,      "field_i32");
    field(10, NodeKind::UInt32,     "field_u32");
    field(14, NodeKind::Int64,      "field_i64");
    field(22, NodeKind::UInt64,     "field_u64");
    field(30, NodeKind::Float,      "field_float");
    field(34, NodeKind::Double,     "field_dbl");
    field(42, NodeKind::Bool,       "field_bool");
    field(43, NodeKind::Hex8,       "field_h8");
    field(44, NodeKind::Hex16,      "field_h16");
    field(46, NodeKind::Hex32,      "field_h32");
    field(50, NodeKind::Hex64,      "field_h64");
    field(58, NodeKind::Pointer64,  "field_ptr");
    field(66, NodeKind::Hex32,      "pad0");
    field(70, NodeKind::Hex16,      "pad1");
    fieldArr(72, NodeKind::UInt32, 4, "field_arr");
}

static QByteArray makeValidationBuffer() {
    QByteArray data(256, '\0');
    // i8 = -5
    data[0] = (char)(int8_t)-5;
    // u8 = 0x42
    data[1] = 0x42;
    // i16 = -1000
    int16_t i16v = -1000;
    memcpy(data.data() + 2, &i16v, 2);
    // u16 = 60000
    uint16_t u16v = 60000;
    memcpy(data.data() + 4, &u16v, 2);
    // i32 = -100000
    int32_t i32v = -100000;
    memcpy(data.data() + 6, &i32v, 4);
    // u32 = 0xDEADBEEF
    uint32_t u32v = 0xDEADBEEF;
    memcpy(data.data() + 10, &u32v, 4);
    // i64 = -1
    int64_t i64v = -1;
    memcpy(data.data() + 14, &i64v, 8);
    // u64 = UINT64_MAX
    uint64_t u64v = ~0ULL;
    memcpy(data.data() + 22, &u64v, 8);
    // float = 3.14f
    float fv = 3.14f;
    memcpy(data.data() + 30, &fv, 4);
    // double = 2.718
    double dv = 2.718;
    memcpy(data.data() + 34, &dv, 8);
    // bool = 1
    data[42] = 1;
    // hex8 = 0xAB
    data[43] = (char)0xAB;
    // hex16 = 0xCAFE
    uint16_t h16 = 0xCAFE;
    memcpy(data.data() + 44, &h16, 2);
    // hex32 = 0xBAADF00D
    uint32_t h32 = 0xBAADF00D;
    memcpy(data.data() + 46, &h32, 4);
    // hex64 = 0xDEADC0DEDEADBEEF
    uint64_t h64 = 0xDEADC0DEDEADBEEFULL;
    memcpy(data.data() + 50, &h64, 8);
    // pointer = 0x7FFE3B8D4260
    uint64_t ptr = 0x00007FFE3B8D4260ULL;
    memcpy(data.data() + 58, &ptr, 8);
    return data;
}

// ── Helper: find node index by name ──

static int findNode(const NodeTree& tree, const char* name) {
    for (int i = 0; i < tree.nodes.size(); i++)
        if (tree.nodes[i].name == name) return i;
    return -1;
}

// ══════════════════════════════════════════════════════════════════════
// Part 1: Pure unit tests – fmt::parseValue / fmt::validateValue
// These are mixed into TestValidationController so they all run under
// one QTEST_MAIN. The init()/cleanup() create GUI fixtures but the
// pure parsing tests simply don't use them.
// ══════════════════════════════════════════════════════════════════════

// (forward-declared — tests are added as slots of TestValidationController below)

// ══════════════════════════════════════════════════════════════════════
// Part 2: Controller-level stress tests (requires GUI)
// Tests that invalid inputs through the controller API don't corrupt data.
// ══════════════════════════════════════════════════════════════════════

class TestValidationController : public QObject {
    Q_OBJECT
private:
    RcxDocument* m_doc = nullptr;
    RcxController* m_ctrl = nullptr;
    QSplitter* m_splitter = nullptr;
    RcxEditor* m_editor = nullptr;

    QByteArray snapshotProvider() {
        return m_doc->provider->readBytes(m_doc->tree.baseAddress,
                                          m_doc->provider->isReadable(m_doc->tree.baseAddress, 256) ? 256 : 0);
    }

private slots:

    void init() {
        m_doc = new RcxDocument();
        buildValidationTree(m_doc->tree);
        m_doc->provider = std::make_unique<BufferProvider>(makeValidationBuffer());

        m_splitter = new QSplitter();
        m_ctrl = new RcxController(m_doc, nullptr);
        m_editor = m_ctrl->addSplitEditor(m_splitter);

        m_splitter->resize(800, 600);
        m_splitter->show();
        QVERIFY(QTest::qWaitForWindowExposed(m_splitter));
        QApplication::processEvents();
    }

    void cleanup() {
        delete m_ctrl;  m_ctrl = nullptr; m_editor = nullptr;
        delete m_splitter; m_splitter = nullptr;
        delete m_doc; m_doc = nullptr;
    }

    // ════════════════════════════════════════════════════════
    // Pure parsing/validation tests (no GUI interaction)
    // ════════════════════════════════════════════════════════

    // ── Integer overflow: values that exceed type max ──

    void testInt8Overflow() {
        bool ok;
        // Max int8 = 127, min = -128
        fmt::parseValue(NodeKind::Int8, "128", &ok);
        QVERIFY2(!ok, "128 overflows int8");

        fmt::parseValue(NodeKind::Int8, "-129", &ok);
        QVERIFY2(!ok, "-129 underflows int8");

        fmt::parseValue(NodeKind::Int8, "127", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Int8, "-128", &ok);
        QVERIFY(ok);

        // Hex overflow: 0x100 > 0xFF
        fmt::parseValue(NodeKind::Int8, "0x100", &ok);
        QVERIFY2(!ok, "0x100 overflows int8 hex");

        fmt::parseValue(NodeKind::Int8, "0xFF", &ok);
        QVERIFY(ok);
    }

    void testUInt8Overflow() {
        bool ok;
        fmt::parseValue(NodeKind::UInt8, "256", &ok);
        QVERIFY2(!ok, "256 overflows uint8");

        fmt::parseValue(NodeKind::UInt8, "255", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::UInt8, "0", &ok);
        QVERIFY(ok);

        // Negative should fail for unsigned
        fmt::parseValue(NodeKind::UInt8, "-1", &ok);
        QVERIFY2(!ok, "Negative should fail for uint8");
    }

    void testInt16Overflow() {
        bool ok;
        fmt::parseValue(NodeKind::Int16, "32768", &ok);
        QVERIFY2(!ok, "32768 overflows int16");

        fmt::parseValue(NodeKind::Int16, "-32769", &ok);
        QVERIFY2(!ok, "-32769 underflows int16");

        fmt::parseValue(NodeKind::Int16, "32767", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Int16, "-32768", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Int16, "0x10000", &ok);
        QVERIFY2(!ok, "0x10000 overflows int16 hex");
    }

    void testUInt16Overflow() {
        bool ok;
        fmt::parseValue(NodeKind::UInt16, "65536", &ok);
        QVERIFY2(!ok, "65536 overflows uint16");

        fmt::parseValue(NodeKind::UInt16, "65535", &ok);
        QVERIFY(ok);
    }

    void testInt32Overflow() {
        bool ok;
        // 2147483647 is INT32_MAX
        fmt::parseValue(NodeKind::Int32, "2147483647", &ok);
        QVERIFY(ok);

        // 2147483648 overflows signed int32 in decimal
        // Note: toInt returns false for overflow
        fmt::parseValue(NodeKind::Int32, "2147483648", &ok);
        QVERIFY2(!ok, "2147483648 overflows int32 decimal");

        fmt::parseValue(NodeKind::Int32, "0xFFFFFFFF", &ok);
        QVERIFY(ok);  // hex path allows up to 0xFFFFFFFF

        fmt::parseValue(NodeKind::Int32, "0x100000000", &ok);
        QVERIFY2(!ok, "0x100000000 overflows int32 hex");
    }

    void testUInt32Overflow() {
        bool ok;
        fmt::parseValue(NodeKind::UInt32, "4294967295", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::UInt32, "4294967296", &ok);
        QVERIFY2(!ok, "4294967296 overflows uint32");
    }

    void testUInt64Max() {
        bool ok;
        // UINT64_MAX = 18446744073709551615
        fmt::parseValue(NodeKind::UInt64, "18446744073709551615", &ok);
        QVERIFY(ok);

        // Beyond UINT64_MAX should fail to parse
        fmt::parseValue(NodeKind::UInt64, "18446744073709551616", &ok);
        QVERIFY2(!ok, "UINT64_MAX+1 should fail");

        fmt::parseValue(NodeKind::UInt64, "0xFFFFFFFFFFFFFFFF", &ok);
        QVERIFY(ok);
    }

    // ── Invalid characters in numeric fields ──

    void testInvalidCharsInIntegers() {
        bool ok;
        fmt::parseValue(NodeKind::Int32, "12abc", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::UInt32, "hello", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Int8, "3.14", &ok);
        QVERIFY(!ok);  // Not a valid integer

        fmt::parseValue(NodeKind::UInt16, "", &ok);
        QVERIFY(!ok);  // Empty string fails for non-string types
    }

    void testInvalidCharsInHex() {
        bool ok;
        fmt::parseValue(NodeKind::Hex32, "GHIJKL", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Hex64, "0xZZZZ", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Hex8, "XY", &ok);
        QVERIFY(!ok);
    }

    // ── Hex wrong byte count ──

    void testHexWrongByteCount() {
        bool ok;
        // Hex32 expects 4 bytes when space-separated
        fmt::parseValue(NodeKind::Hex32, "AA BB CC DD EE", &ok);
        QVERIFY2(!ok, "5 bytes should fail for Hex32");

        fmt::parseValue(NodeKind::Hex32, "AA BB", &ok);
        QVERIFY2(!ok, "2 bytes should fail for Hex32");

        // Correct: 4 bytes
        fmt::parseValue(NodeKind::Hex32, "AA BB CC DD", &ok);
        QVERIFY(ok);

        // Hex64 expects 8 bytes
        fmt::parseValue(NodeKind::Hex64, "AA BB CC DD", &ok);
        QVERIFY2(!ok, "4 bytes should fail for Hex64");

        fmt::parseValue(NodeKind::Hex64, "AA BB CC DD EE FF 00 11", &ok);
        QVERIFY(ok);
    }

    // ── Float/Double edge cases ──

    void testFloatEdgeCases() {
        bool ok;
        // Valid floats
        fmt::parseValue(NodeKind::Float, "0", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Float, "-0.0", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Float, "1e38", &ok);
        QVERIFY(ok);

        // EU comma separator (converted to dot internally)
        fmt::parseValue(NodeKind::Float, "3,14", &ok);
        QVERIFY(ok);

        // Junk
        fmt::parseValue(NodeKind::Float, "not_a_number", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Float, "", &ok);
        QVERIFY(!ok);
    }

    void testDoubleEdgeCases() {
        bool ok;
        fmt::parseValue(NodeKind::Double, "1.7976931348623157e+308", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Double, "abc", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Double, "1,5", &ok);
        QVERIFY(ok);  // EU comma
    }

    // ── Bool: only "true"/"false"/"0"/"1" are valid ──

    void testBoolInvalid() {
        bool ok;
        fmt::parseValue(NodeKind::Bool, "true", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Bool, "false", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Bool, "1", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Bool, "0", &ok);
        QVERIFY(ok);

        // Invalid: "yes", "no", "2", random text
        fmt::parseValue(NodeKind::Bool, "yes", &ok);
        QVERIFY2(!ok, "'yes' is not valid bool");

        fmt::parseValue(NodeKind::Bool, "no", &ok);
        QVERIFY2(!ok, "'no' is not valid bool");

        fmt::parseValue(NodeKind::Bool, "2", &ok);
        QVERIFY2(!ok, "'2' is not valid bool");

        fmt::parseValue(NodeKind::Bool, "TRUE", &ok);
        QVERIFY2(!ok, "'TRUE' (uppercase) is not valid bool");

        fmt::parseValue(NodeKind::Bool, "", &ok);
        QVERIFY(!ok);
    }

    // ── Pointer: hex-only parsing ──

    void testPointerInvalid() {
        bool ok;
        // Valid
        fmt::parseValue(NodeKind::Pointer64, "0x7FFE3B8D4260", &ok);
        QVERIFY(ok);

        fmt::parseValue(NodeKind::Pointer64, "7FFE3B8D4260", &ok);
        QVERIFY(ok);

        // Invalid chars
        fmt::parseValue(NodeKind::Pointer64, "0xGGGG", &ok);
        QVERIFY(!ok);

        // Pointer32 overflow
        fmt::parseValue(NodeKind::Pointer32, "0x100000000", &ok);
        QVERIFY2(!ok, "0x100000000 overflows ptr32");

        fmt::parseValue(NodeKind::Pointer32, "0xFFFFFFFF", &ok);
        QVERIFY(ok);
    }

    // ── validateValue: error message testing ──

    void testValidateValueMessages() {
        // Hex kind with non-hex chars → character-level error
        QString err = fmt::validateValue(NodeKind::Hex32, "GGGG");
        QVERIFY(!err.isEmpty());
        QVERIFY(err.contains("invalid hex"));

        // Int kind overflow → "too large" message
        err = fmt::validateValue(NodeKind::UInt8, "999");
        QVERIFY(!err.isEmpty());
        QVERIFY(err.contains("too large"));

        // Decimal with non-digit
        err = fmt::validateValue(NodeKind::UInt32, "12!3");
        QVERIFY(!err.isEmpty());
        QVERIFY(err.contains("invalid"));

        // Signed integer with leading minus accepted
        err = fmt::validateValue(NodeKind::Int32, "-42");
        QVERIFY2(err.isEmpty(), qPrintable("Negative int32 should be valid: " + err));

        // Unsigned with minus → invalid
        err = fmt::validateValue(NodeKind::UInt32, "-1");
        QVERIFY(!err.isEmpty());

        // Float junk
        err = fmt::validateValue(NodeKind::Float, "abc");
        QVERIFY(!err.isEmpty());
        QVERIFY(err.contains("invalid number"));

        // Empty is valid (special case)
        err = fmt::validateValue(NodeKind::UInt32, "");
        QVERIFY(err.isEmpty());

        // Spaces only trimmed to empty → valid
        err = fmt::validateValue(NodeKind::UInt32, "   ");
        QVERIFY(err.isEmpty());
    }

    // ── validateBaseAddress: equation syntax ──

    void testValidateBaseAddressEdgeCases() {
        // Valid cases
        QVERIFY(fmt::validateBaseAddress("0x1000").isEmpty());
        QVERIFY(fmt::validateBaseAddress("1000").isEmpty());
        QVERIFY(fmt::validateBaseAddress("0x1000 + 0x100").isEmpty());
        QVERIFY(fmt::validateBaseAddress("0x2000 - 0x10").isEmpty());
        QVERIFY(fmt::validateBaseAddress("0x400+0x200-0x100").isEmpty());
        QVERIFY(fmt::validateBaseAddress("  0xDEAD  ").isEmpty());

        // Invalid cases
        QVERIFY(!fmt::validateBaseAddress("").isEmpty());   // empty
        QVERIFY(!fmt::validateBaseAddress("  ").isEmpty()); // whitespace only - no hex digits
        QVERIFY(!fmt::validateBaseAddress("0xGGGG").isEmpty());
        QVERIFY(fmt::validateBaseAddress("0x1000 * 2").isEmpty());   // multiplication supported
        QVERIFY(!fmt::validateBaseAddress("0x1000 ++ 0x100").isEmpty());  // double operator
        QVERIFY(!fmt::validateBaseAddress("hello").isEmpty());
    }

    // ── Extremely long strings ──

    void testExtremelyLongInput() {
        bool ok;
        // 10000-char string of hex digits
        QString longHex = QString("F").repeated(10000);
        fmt::parseValue(NodeKind::Hex32, longHex, &ok);
        // Should either fail or succeed gracefully (no crash)
        // For Hex32 continuous mode, this is a valid huge hex number that overflows uint32
        Q_UNUSED(ok);  // Just testing it doesn't crash

        // Long garbage
        QString longJunk = QString("@#$%^&*").repeated(1000);
        fmt::parseValue(NodeKind::Int32, longJunk, &ok);
        QVERIFY(!ok);

        // Very long decimal number
        QString longDec = QString("9").repeated(100);
        fmt::parseValue(NodeKind::UInt64, longDec, &ok);
        QVERIFY(!ok);  // Way beyond UINT64_MAX

        // Extremely long hex for parseValue
        fmt::parseValue(NodeKind::Hex64, "0x" + QString("F").repeated(200), &ok);
        // No crash is the test
    }

    // ── Special/weird characters ──

    void testSpecialCharacters() {
        bool ok;
        fmt::parseValue(NodeKind::Int32, "\0", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Int32, "\t42\n", &ok);
        // trimmed internally — may or may not parse; just don't crash
        Q_UNUSED(ok);

        fmt::parseValue(NodeKind::UInt32, "  42  ", &ok);
        QVERIFY(ok);  // Leading/trailing whitespace should be trimmed

        // Unicode characters
        fmt::parseValue(NodeKind::UInt32, QString::fromUtf8("\xC3\xA9"), &ok);  // é
        QVERIFY(!ok);
    }

    // ── Container kinds: parseValue should fail gracefully ──

    void testContainerKindParseValue() {
        bool ok;
        fmt::parseValue(NodeKind::Struct, "anything", &ok);
        QVERIFY(!ok);

        fmt::parseValue(NodeKind::Array, "42", &ok);
        QVERIFY(!ok);
    }

    // ════════════════════════════════════════════════════════
    // Controller-level stress tests (uses GUI fixtures)
    // ════════════════════════════════════════════════════════

    // ── setNodeValue rejects overflowing values without changing data ──

    void testRejectOverflowInt8() {
        int idx = findNode(m_doc->tree, "field_i8");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 1);

        m_ctrl->setNodeValue(idx, 0, "999");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 1);
        QCOMPARE(after, before);  // Data unchanged
        QCOMPARE(m_doc->undoStack.count(), 0);  // No command pushed
    }

    void testRejectOverflowUInt8() {
        int idx = findNode(m_doc->tree, "field_u8");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 1);

        m_ctrl->setNodeValue(idx, 0, "256");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 1);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    void testRejectOverflowUInt16() {
        int idx = findNode(m_doc->tree, "field_u16");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 2);

        m_ctrl->setNodeValue(idx, 0, "70000");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 2);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    void testRejectOverflowUInt32() {
        int idx = findNode(m_doc->tree, "field_u32");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 4);

        m_ctrl->setNodeValue(idx, 0, "4294967296");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 4);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── setNodeValue rejects garbage text ──

    void testRejectGarbageText() {
        int idx = findNode(m_doc->tree, "field_u32");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 4);

        // Various garbage inputs
        const char* junk[] = {
            "hello", "!@#$%", "", "   ", "0xGGGG", "3.14",
            "true", "null", "NaN", "inf", "\t\n\r"
        };
        for (const char* s : junk) {
            m_ctrl->setNodeValue(idx, 0, s);
            QApplication::processEvents();
        }

        QByteArray after = m_doc->provider->readBytes(addr, 4);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    void testRejectGarbageFloat() {
        int idx = findNode(m_doc->tree, "field_float");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 4);

        m_ctrl->setNodeValue(idx, 0, "not_a_number");
        m_ctrl->setNodeValue(idx, 0, "");
        m_ctrl->setNodeValue(idx, 0, "0xDEAD");  // hex not valid for float
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 4);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    void testRejectGarbageBool() {
        int idx = findNode(m_doc->tree, "field_bool");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 1);

        m_ctrl->setNodeValue(idx, 0, "yes");
        m_ctrl->setNodeValue(idx, 0, "2");
        m_ctrl->setNodeValue(idx, 0, "TRUE");
        m_ctrl->setNodeValue(idx, 0, "maybe");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 1);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── setNodeValue on invalid node indices ──

    void testOutOfBoundsNodeIndex() {
        QByteArray before = m_doc->provider->readBytes(m_doc->tree.baseAddress, 256);

        m_ctrl->setNodeValue(-1, 0, "42");
        m_ctrl->setNodeValue(-100, 0, "42");
        m_ctrl->setNodeValue(99999, 0, "42");
        m_ctrl->setNodeValue(INT_MAX, 0, "42");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(m_doc->tree.baseAddress, 256);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── renameNode with edge cases ──

    void testRenameNodeEdgeCases() {
        int idx = findNode(m_doc->tree, "field_u32");
        QVERIFY(idx >= 0);

        // Empty name is allowed at controller level
        m_ctrl->renameNode(idx, "");
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].name, QString(""));
        m_doc->undoStack.undo();
        QCOMPARE(m_doc->tree.nodes[idx].name, QString("field_u32"));

        // Very long name (1000 chars)
        QString longName = QString("a").repeated(1000);
        m_ctrl->renameNode(idx, longName);
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].name, longName);
        m_doc->undoStack.undo();

        // Special characters
        m_ctrl->renameNode(idx, "field with spaces & <special> \"chars\"");
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].name,
                 QString("field with spaces & <special> \"chars\""));
        m_doc->undoStack.undo();

        // Out of bounds indices
        m_ctrl->renameNode(-1, "bad");
        m_ctrl->renameNode(99999, "bad");
        QApplication::processEvents();
        // Should not crash; undo stack not affected
    }

    // ── changeNodeKind with invalid indices ──

    void testChangeKindOutOfBounds() {
        int origCount = m_doc->tree.nodes.size();

        m_ctrl->changeNodeKind(-1, NodeKind::Float);
        m_ctrl->changeNodeKind(99999, NodeKind::Float);
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes.size(), origCount);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── changeNodeKind size transitions: shrink inserts hex nodes ──

    void testChangeKindShrinkInsertsHexNodes() {
        int idx = findNode(m_doc->tree, "field_u32");
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::UInt32);  // 4 bytes

        int origCount = m_doc->tree.nodes.size();
        m_ctrl->changeNodeKind(idx, NodeKind::UInt8);  // 4 → 1 byte = 3 gap
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::UInt8);
        // Should have inserted hex nodes (Hex16 + Hex8 = 3 bytes, or similar)
        QVERIFY(m_doc->tree.nodes.size() > origCount);

        // Undo restores everything
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::UInt32);
        QCOMPARE(m_doc->tree.nodes.size(), origCount);
    }

    // ── insertNode / removeNode boundary conditions ──

    void testInsertNodeWithInvalidParent() {
        int origCount = m_doc->tree.nodes.size();

        // Non-existent parent ID — insertNode doesn't validate parent existence,
        // so it will add a node with an orphan parentId. Verify no crash.
        m_ctrl->insertNode(0xDEADBEEF, 0, NodeKind::UInt32, "orphan");
        QApplication::processEvents();

        // The node was added (the tree accepts orphan parentId)
        QCOMPARE(m_doc->tree.nodes.size(), origCount + 1);

        // Undo cleans up
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes.size(), origCount);
    }

    void testRemoveNodeOutOfBounds() {
        int origCount = m_doc->tree.nodes.size();

        m_ctrl->removeNode(-1);
        m_ctrl->removeNode(99999);
        QApplication::processEvents();

        QCOMPARE(m_doc->tree.nodes.size(), origCount);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── Array element count: boundary validation ──

    void testArrayCountBoundaries() {
        int idx = findNode(m_doc->tree, "field_arr");
        QVERIFY(idx >= 0);
        QCOMPARE(m_doc->tree.nodes[idx].kind, NodeKind::Array);
        int origLen = m_doc->tree.nodes[idx].arrayLen;

        // Simulate EditTarget::ArrayElementCount through the controller API
        // The controller validates: ok && newLen > 0 && newLen <= 100000

        // Zero count — should be rejected (> 0 check)
        m_doc->undoStack.clear();
        {
            bool ok;
            int newLen = QString("0").toInt(&ok);
            // Controller logic: ok && newLen > 0 → false
            QVERIFY(ok && newLen == 0);  // toInt succeeds, but newLen is 0
            // This should NOT push a command
        }

        // Negative count
        {
            bool ok;
            int newLen = QString("-5").toInt(&ok);
            QVERIFY(ok && newLen < 0);  // toInt succeeds, but negative
        }

        // Just above max: 100001
        {
            bool ok;
            int newLen = QString("100001").toInt(&ok);
            QVERIFY(ok && newLen > 100000);
        }

        // At max: 100000 (should be accepted)
        {
            bool ok;
            int newLen = QString("100000").toInt(&ok);
            QVERIFY(ok && newLen > 0 && newLen <= 100000);
        }

        // Non-numeric text
        {
            bool ok;
            QString("hello").toInt(&ok);
            QVERIFY(!ok);
        }

        // Verify actual array length is unchanged
        QCOMPARE(m_doc->tree.nodes[idx].arrayLen, origLen);
    }

    // ── Hex values: space-separated with wrong count ──

    void testHexWrongByteCountAtController() {
        int idx = findNode(m_doc->tree, "field_h32");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 4);

        // 5 bytes for a 4-byte field
        m_ctrl->setNodeValue(idx, 0, "AA BB CC DD EE");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 4);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── Valid writes followed by undo: verify round-trip integrity ──

    void testValueWriteUndoIntegrity() {
        // Write valid values to multiple fields, undo all, verify original data
        int i8idx  = findNode(m_doc->tree, "field_i8");
        int u32idx = findNode(m_doc->tree, "field_u32");
        int fltidx = findNode(m_doc->tree, "field_float");
        QVERIFY(i8idx >= 0 && u32idx >= 0 && fltidx >= 0);

        // Snapshot original provider
        QByteArray origData = m_doc->provider->readBytes(
            m_doc->tree.baseAddress, 256);

        // Write three valid values
        m_ctrl->setNodeValue(i8idx, 0, "42");
        m_ctrl->setNodeValue(u32idx, 0, "12345");
        m_ctrl->setNodeValue(fltidx, 0, "2.5");
        QApplication::processEvents();

        QCOMPARE(m_doc->undoStack.count(), 3);

        // Undo all three
        m_doc->undoStack.undo();
        m_doc->undoStack.undo();
        m_doc->undoStack.undo();
        QApplication::processEvents();

        QByteArray afterUndo = m_doc->provider->readBytes(
            m_doc->tree.baseAddress, 256);
        QCOMPARE(afterUndo, origData);
    }

    // ── toggleCollapse on out-of-bounds index ──

    void testToggleCollapseOutOfBounds() {
        m_ctrl->toggleCollapse(-1);
        m_ctrl->toggleCollapse(99999);
        QApplication::processEvents();
        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── Rapid fire: many rejected writes don't accumulate undo history ──

    void testRapidFireRejectedWrites() {
        int idx = findNode(m_doc->tree, "field_u8");
        QVERIFY(idx >= 0);

        for (int i = 0; i < 100; i++)
            m_ctrl->setNodeValue(idx, 0, "9999");  // overflow
        QApplication::processEvents();

        QCOMPARE(m_doc->undoStack.count(), 0);
    }

    // ── Duplicate nodes: verify they get unique IDs ──

    void testDuplicateNodeGetsUniqueId() {
        int idx = findNode(m_doc->tree, "field_u32");
        QVERIFY(idx >= 0);
        int origCount = m_doc->tree.nodes.size();

        m_ctrl->duplicateNode(idx);
        QApplication::processEvents();

        // duplicateNode appends "_copy" to the name
        QCOMPARE(m_doc->tree.nodes.size(), origCount + 1);

        int copyIdx = findNode(m_doc->tree, "field_u32_copy");
        QVERIFY2(copyIdx >= 0, "Duplicate node should exist with '_copy' suffix");

        // Verify all IDs are unique
        QSet<uint64_t> ids;
        for (const auto& n : m_doc->tree.nodes) {
            QVERIFY2(!ids.contains(n.id),
                     qPrintable(QString("Duplicate ID found: %1").arg(n.id)));
            ids.insert(n.id);
        }

        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes.size(), origCount);
    }

    // ── Batch remove with invalid indices in the mix ──

    void testBatchRemoveWithInvalidIndices() {
        int origCount = m_doc->tree.nodes.size();
        int validIdx = findNode(m_doc->tree, "field_u8");
        QVERIFY(validIdx >= 0);

        // Mix of valid and invalid indices — batchRemoveNodes filters internally
        QVector<int> indices = {validIdx, -1, 99999};
        m_ctrl->batchRemoveNodes(indices);
        QApplication::processEvents();

        // At least the valid node should have been removed
        QVERIFY(m_doc->tree.nodes.size() < origCount);

        // Undo restores
        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes.size(), origCount);
    }

    // ── Batch change kind with invalid indices ──

    void testBatchChangeKindWithInvalidIndices() {
        int validIdx = findNode(m_doc->tree, "field_i32");
        QVERIFY(validIdx >= 0);
        NodeKind origKind = m_doc->tree.nodes[validIdx].kind;

        // Mix of valid and invalid
        QVector<int> indices = {-1, validIdx, 99999};
        m_ctrl->batchChangeKind(indices, NodeKind::Float);
        QApplication::processEvents();

        // Valid node should have changed
        QCOMPARE(m_doc->tree.nodes[validIdx].kind, NodeKind::Float);

        m_doc->undoStack.undo();
        QApplication::processEvents();
        QCOMPARE(m_doc->tree.nodes[validIdx].kind, origKind);
    }

    // ── Editor: inline edit rejected on out-of-range lines ──

    void testInlineEditOutOfRangeLines() {
        m_ctrl->refresh();
        QApplication::processEvents();

        // Try to edit a line that doesn't exist
        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Name, 99999));
        QVERIFY(!m_editor->isEditing());

        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Value, -1));
        QVERIFY(!m_editor->isEditing());
    }

    // ── Editor: struct header rejects value edit ──

    void testStructHeaderRejectsValueEdit() {
        m_ctrl->refresh();
        QApplication::processEvents();

        ComposeResult result = m_doc->compose();
        m_editor->applyDocument(result);
        QApplication::processEvents();

        // Find a non-root header line (root header has no editable name/type spans)
        int headerLine = -1;
        for (int i = 0; i < result.meta.size(); i++) {
            if (result.meta[i].lineKind == LineKind::Header && !result.meta[i].isRootHeader) {
                headerLine = i;
                break;
            }
        }
        QVERIFY(headerLine >= 0);

        QVERIFY(!m_editor->beginInlineEdit(EditTarget::Value, headerLine));
        QVERIFY(!m_editor->isEditing());

        // But Name and Type should work
        bool ok = m_editor->beginInlineEdit(EditTarget::Name, headerLine);
        QVERIFY(ok);
        m_editor->cancelInlineEdit();
    }

    // ── Base address: invalid equation syntax ──

    void testBaseAddressInvalidEquation() {
        uint64_t origBase = m_doc->tree.baseAddress;

        m_ctrl->refresh();
        QApplication::processEvents();

        // These are processed through the inlineEditCommitted handler,
        // but we can test the parsing logic directly:
        // The controller silently ignores invalid base address text

        // Test the validation function directly
        QVERIFY(!fmt::validateBaseAddress("0x1000 ** 2").isEmpty());
        QVERIFY(fmt::validateBaseAddress("0x1000 / 2").isEmpty());  // division supported
        QVERIFY(!fmt::validateBaseAddress("abc xyz").isEmpty());

        // Original base should be unchanged
        QCOMPARE(m_doc->tree.baseAddress, origBase);
    }

    // ── Pointer64 value: accepts hex, rejects garbage ──

    void testPointerValueValidation() {
        int idx = findNode(m_doc->tree, "field_ptr");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 8);

        // Garbage
        m_ctrl->setNodeValue(idx, 0, "not_a_pointer");
        m_ctrl->setNodeValue(idx, 0, "");
        m_ctrl->setNodeValue(idx, 0, "0xZZZZ");
        QApplication::processEvents();

        QByteArray after = m_doc->provider->readBytes(addr, 8);
        QCOMPARE(after, before);
        QCOMPARE(m_doc->undoStack.count(), 0);

        // Valid hex write
        m_ctrl->setNodeValue(idx, 0, "0xDEADBEEFCAFEBABE");
        QApplication::processEvents();

        QByteArray written = m_doc->provider->readBytes(addr, 8);
        uint64_t writtenVal;
        memcpy(&writtenVal, written.data(), 8);
        QCOMPARE(writtenVal, (uint64_t)0xDEADBEEFCAFEBABEULL);

        m_doc->undoStack.undo();
        QApplication::processEvents();
        QByteArray restored = m_doc->provider->readBytes(addr, 8);
        QCOMPARE(restored, before);
    }

    // ── Hex64 space-separated: exact 8 bytes accepted, other counts rejected ──

    void testHex64SpaceSeparatedBoundary() {
        int idx = findNode(m_doc->tree, "field_h64");
        QVERIFY(idx >= 0);
        uint64_t addr = m_doc->tree.computeOffset(idx);
        QByteArray before = m_doc->provider->readBytes(addr, 8);

        // 7 bytes — reject
        m_ctrl->setNodeValue(idx, 0, "AA BB CC DD EE FF 00");
        QApplication::processEvents();
        QCOMPARE(m_doc->provider->readBytes(addr, 8), before);

        // 9 bytes — reject
        m_ctrl->setNodeValue(idx, 0, "AA BB CC DD EE FF 00 11 22");
        QApplication::processEvents();
        QCOMPARE(m_doc->provider->readBytes(addr, 8), before);

        QCOMPARE(m_doc->undoStack.count(), 0);

        // 8 bytes — accept
        m_ctrl->setNodeValue(idx, 0, "01 02 03 04 05 06 07 08");
        QApplication::processEvents();
        QCOMPARE(m_doc->undoStack.count(), 1);

        QByteArray written = m_doc->provider->readBytes(addr, 8);
        QCOMPARE((uint8_t)written[0], (uint8_t)0x01);
        QCOMPARE((uint8_t)written[7], (uint8_t)0x08);

        m_doc->undoStack.undo();
    }

    // ── Multiple undos past the beginning don't crash ──

    void testExcessiveUndos() {
        int idx = findNode(m_doc->tree, "field_u32");
        QVERIFY(idx >= 0);

        m_ctrl->setNodeValue(idx, 0, "42");
        QApplication::processEvents();
        QCOMPARE(m_doc->undoStack.count(), 1);

        // Undo once (valid)
        m_doc->undoStack.undo();
        // Undo 50 more times (all no-ops, should not crash)
        for (int i = 0; i < 50; i++)
            m_doc->undoStack.undo();
        QApplication::processEvents();

        // Redo 50 times past the end
        m_doc->undoStack.redo();
        for (int i = 0; i < 50; i++)
            m_doc->undoStack.redo();
        QApplication::processEvents();
    }
};

QTEST_MAIN(TestValidationController)
#include "test_validation.moc"

```

`tests/test_windbg_provider.cpp`:

```cpp
#include <QTest>
#include <QByteArray>
#include <QProcess>
#include <QThread>
#include <QtConcurrent>
#include <QFuture>
#include <cstring>

#include "providers/provider.h"
#include "../plugins/WinDbgMemory/WinDbgMemoryPlugin.h"

#ifdef _WIN32
#include <windows.h>
#include <tlhelp32.h>
#include <initguid.h>
#include <dbgeng.h>
#endif

using namespace rcx;

static const char* CDB_PATH = "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\cdb.exe";
static const int   DBG_PORT = 5055;

class TestWinDbgProvider : public QObject {
    Q_OBJECT

private:
    QProcess* m_cdbProcess = nullptr;
    uint32_t  m_notepadPid = 0;
    bool      m_weSpawnedNotepad = false;
    QString   m_connString;

    static uint32_t findProcess(const wchar_t* name)
    {
#ifdef _WIN32
        HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (snap == INVALID_HANDLE_VALUE) return 0;
        PROCESSENTRY32W entry;
        entry.dwSize = sizeof(entry);
        uint32_t pid = 0;
        if (Process32FirstW(snap, &entry)) {
            do {
                if (_wcsicmp(entry.szExeFile, name) == 0) {
                    pid = entry.th32ProcessID;
                    break;
                }
            } while (Process32NextW(snap, &entry));
        }
        CloseHandle(snap);
        return pid;
#else
        Q_UNUSED(name); return 0;
#endif
    }

    static uint32_t launchNotepad()
    {
#ifdef _WIN32
        STARTUPINFOW si{};
        si.cb = sizeof(si);
        PROCESS_INFORMATION pi{};
        if (CreateProcessW(L"C:\\Windows\\notepad.exe", nullptr, nullptr, nullptr,
                           FALSE, 0, nullptr, nullptr, &si, &pi)) {
            WaitForInputIdle(pi.hProcess, 3000);
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            return pi.dwProcessId;
        }
        return 0;
#else
        return 0;
#endif
    }

    static void terminateProcess(uint32_t pid)
    {
#ifdef _WIN32
        HANDLE h = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
        if (h) { TerminateProcess(h, 0); CloseHandle(h); }
#else
        Q_UNUSED(pid);
#endif
    }

private slots:

    // ── Fixture ──

    /// Try a quick DebugConnect to see if the port is already serving.
    static bool canConnect(const QString& connStr)
    {
#ifdef _WIN32
        IDebugClient* probe = nullptr;
        QByteArray utf8 = connStr.toUtf8();
        HRESULT hr = DebugConnect(utf8.constData(), IID_IDebugClient, (void**)&probe);
        if (SUCCEEDED(hr) && probe) {
            probe->EndSession(DEBUG_END_DISCONNECT);
            probe->Release();
            return true;
        }
        return false;
#else
        Q_UNUSED(connStr);
        return false;
#endif
    }

    void initTestCase()
    {
        m_connString = QString("tcp:Port=%1,Server=localhost").arg(DBG_PORT);

        // If a debug server is already listening (e.g. WinDbg with .server),
        // skip launching our own cdb.exe.
        if (canConnect(m_connString)) {
            qDebug() << "Debug server already running on port" << DBG_PORT << "— using it";
            return;
        }

        // No server running — launch cdb ourselves
        m_notepadPid = findProcess(L"notepad.exe");
        if (m_notepadPid == 0) {
            m_notepadPid = launchNotepad();
            m_weSpawnedNotepad = true;
        }
        QVERIFY2(m_notepadPid != 0, "Need notepad.exe running");
        qDebug() << "Using notepad.exe PID:" << m_notepadPid;

        m_cdbProcess = new QProcess(this);
        QStringList args;
        args << "-server" << QString("tcp:port=%1").arg(DBG_PORT)
             << "-pv"
             << "-p" << QString::number(m_notepadPid);

        m_cdbProcess->setProgram(CDB_PATH);
        m_cdbProcess->setArguments(args);
        m_cdbProcess->start();

        QVERIFY2(m_cdbProcess->waitForStarted(5000), "Failed to start cdb.exe");
        QThread::sleep(3);

        qDebug() << "cdb.exe debug server started on port" << DBG_PORT;
    }

    void cleanupTestCase()
    {
        if (m_cdbProcess) {
            m_cdbProcess->write("q\n");
            if (!m_cdbProcess->waitForFinished(5000))
                m_cdbProcess->kill();
            delete m_cdbProcess;
            m_cdbProcess = nullptr;
        }

        if (m_weSpawnedNotepad && m_notepadPid)
            terminateProcess(m_notepadPid);
    }

    // ── Plugin metadata ──

    void plugin_name()
    {
        WinDbgMemoryPlugin plugin;
        QCOMPARE(plugin.Name(), std::string("WinDbg Memory"));
    }

    void plugin_version()
    {
        WinDbgMemoryPlugin plugin;
        QCOMPARE(plugin.Version(), std::string("2.0.0"));
    }

    void plugin_canHandle_tcp()
    {
        WinDbgMemoryPlugin plugin;
        QVERIFY(plugin.canHandle("tcp:Port=5055,Server=localhost"));
        QVERIFY(plugin.canHandle("TCP:Port=1234,Server=10.0.0.1"));
    }

    void plugin_canHandle_npipe()
    {
        WinDbgMemoryPlugin plugin;
        QVERIFY(plugin.canHandle("npipe:Pipe=test,Server=localhost"));
    }

    void plugin_canHandle_pid()
    {
        WinDbgMemoryPlugin plugin;
        QVERIFY(plugin.canHandle("pid:1234"));
    }

    void plugin_canHandle_dump()
    {
        WinDbgMemoryPlugin plugin;
        QVERIFY(plugin.canHandle("dump:C:/test.dmp"));
    }

    void plugin_canHandle_invalid()
    {
        WinDbgMemoryPlugin plugin;
        QVERIFY(!plugin.canHandle(""));
        QVERIFY(!plugin.canHandle("1234"));
        QVERIFY(!plugin.canHandle("file:///test.bin"));
    }

    // ── Connection failure ──

    void provider_connect_badPort()
    {
        WinDbgMemoryProvider prov("tcp:Port=59999,Server=localhost");
        QVERIFY(!prov.isValid());
        QCOMPARE(prov.size(), 0);
    }

    void provider_connect_badPipe()
    {
        WinDbgMemoryProvider prov("npipe:Pipe=nonexistent_reclass_test_pipe,Server=localhost");
        QVERIFY(!prov.isValid());
        QCOMPARE(prov.size(), 0);
    }

    void plugin_createProvider_badConnection()
    {
        WinDbgMemoryPlugin plugin;
        QString error;
        auto prov = plugin.createProvider("tcp:Port=59999,Server=localhost", &error);
        QVERIFY(prov == nullptr);
        QVERIFY(!error.isEmpty());
    }

    // ── Connect and read (main thread) ──

    void provider_connect_valid()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY2(prov.isValid(), "Should connect to cdb debug server");
        QCOMPARE(prov.kind(), QStringLiteral("WinDbg"));
        QVERIFY(prov.size() > 0);
    }

    void provider_name()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        QVERIFY(!prov.name().isEmpty());
        qDebug() << "Provider name:" << prov.name();
    }

    void provider_isLive()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        QVERIFY(prov.isLive());
    }

    void provider_baseAddress()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        // WinDbg provider no longer auto-selects a module base — it returns 0
        // so the controller doesn't override the user's chosen base address.
        QCOMPARE(prov.base(), (uint64_t)0);
    }

    // ── Read: MZ header on main thread ──

    void provider_read_mz_mainThread()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());

        uint8_t buf[2] = {};
        bool ok = prov.read(0, buf, 2);
        QVERIFY2(ok, "Failed to read from debug session (main thread)");
        QCOMPARE(buf[0], (uint8_t)'M');
        QCOMPARE(buf[1], (uint8_t)'Z');
    }

    // ── Read: MZ header from a background thread (the actual failure case) ──

    void provider_read_mz_backgroundThread()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());

        // Simulate what the controller's refresh does:
        // read from a QtConcurrent worker thread.
        QFuture<QByteArray> future = QtConcurrent::run([&prov]() -> QByteArray {
            return prov.readBytes(0, 128);
        });
        future.waitForFinished();
        QByteArray data = future.result();

        QCOMPARE(data.size(), 128);
        QCOMPARE((uint8_t)data[0], (uint8_t)'M');
        QCOMPARE((uint8_t)data[1], (uint8_t)'Z');
    }

    // ── Read: bulk data from background thread ──

    void provider_read_4k_backgroundThread()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());

        QFuture<QByteArray> future = QtConcurrent::run([&prov]() -> QByteArray {
            return prov.readBytes(0, 4096);
        });
        future.waitForFinished();
        QByteArray data = future.result();

        QCOMPARE(data.size(), 4096);
        QCOMPARE((uint8_t)data[0], (uint8_t)'M');
        QCOMPARE((uint8_t)data[1], (uint8_t)'Z');

        // Verify it's not all zeros (the old failure mode)
        bool allZero = true;
        for (int i = 0; i < data.size(); ++i) {
            if (data[i] != '\0') { allZero = false; break; }
        }
        QVERIFY2(!allZero, "Data is all zeros — background thread read failed");
    }

    // ── Multiple sequential background reads (simulates refresh timer) ──

    void provider_read_multipleRefreshes()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());

        for (int i = 0; i < 5; ++i) {
            QFuture<QByteArray> future = QtConcurrent::run([&prov]() -> QByteArray {
                return prov.readBytes(0, 128);
            });
            future.waitForFinished();
            QByteArray data = future.result();
            QCOMPARE(data.size(), 128);
            QCOMPARE((uint8_t)data[0], (uint8_t)'M');
            QCOMPARE((uint8_t)data[1], (uint8_t)'Z');
        }
    }

    // ── Read helpers ──

    void provider_readU16()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        QCOMPARE(prov.readU16(0), (uint16_t)0x5A4D); // "MZ" little-endian
    }

    void provider_read_peSignature()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());

        uint32_t peOffset = prov.readU32(0x3C);
        QVERIFY2(peOffset > 0 && peOffset < 0x1000, "PE offset should be reasonable");

        uint8_t sig[4] = {};
        bool ok = prov.read(peOffset, sig, 4);
        QVERIFY(ok);
        QCOMPARE(sig[0], (uint8_t)'P');
        QCOMPARE(sig[1], (uint8_t)'E');
        QCOMPARE(sig[2], (uint8_t)0);
        QCOMPARE(sig[3], (uint8_t)0);
    }

    // ── Edge cases ──

    void provider_read_zeroLength()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        uint8_t buf = 0xFF;
        QVERIFY(!prov.read(0, &buf, 0));
    }

    void provider_read_negativeLength()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        uint8_t buf = 0xFF;
        QVERIFY(!prov.read(0, &buf, -1));
    }

    // ── getSymbol ──

    void provider_getSymbol()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());
        QString sym = prov.getSymbol(0);
        qDebug() << "Symbol at base+0:" << sym;
        // Should not crash; may or may not resolve
    }

    void provider_getSymbol_backgroundThread()
    {
        WinDbgMemoryProvider prov(m_connString);
        QVERIFY(prov.isValid());

        QFuture<QString> future = QtConcurrent::run([&prov]() -> QString {
            return prov.getSymbol(0);
        });
        future.waitForFinished();
        // Should not crash from background thread
        qDebug() << "Symbol (bg thread):" << future.result();
    }

    // ── createProvider full flow ──

    void plugin_createProvider_valid()
    {
        WinDbgMemoryPlugin plugin;
        QString error;
        auto prov = plugin.createProvider(m_connString, &error);
        QVERIFY2(prov != nullptr, qPrintable("createProvider failed: " + error));
        QVERIFY(prov->isValid());

        uint8_t mz[2] = {};
        QVERIFY(prov->read(0, mz, 2));
        QCOMPARE(mz[0], (uint8_t)'M');
        QCOMPARE(mz[1], (uint8_t)'Z');
    }

    // ── Multiple concurrent connections ──

    void provider_multipleConcurrent()
    {
        WinDbgMemoryProvider prov1(m_connString);
        WinDbgMemoryProvider prov2(m_connString);

        QVERIFY(prov1.isValid());
        QVERIFY(prov2.isValid());

        QCOMPARE(prov1.readU16(0), (uint16_t)0x5A4D);
        QCOMPARE(prov2.readU16(0), (uint16_t)0x5A4D);
    }

    // ── Factory ──

    void factory_createPlugin()
    {
        IPlugin* raw = CreatePlugin();
        QVERIFY(raw != nullptr);
        QCOMPARE(raw->Type(), IPlugin::ProviderPlugin);
        QCOMPARE(raw->Name(), std::string("WinDbg Memory"));
        delete raw;
    }

    // ── Kernel session tests ──
    // Requires a WinDbg instance with a kernel dump loaded and
    // .server tcp:port=5055 running.  Skipped automatically if
    // no server is available.  Override with WINDBG_KERNEL_CONN env var.

    void provider_kernel_connect()
    {
        QString kernelConn = qEnvironmentVariable("WINDBG_KERNEL_CONN",
            "tcp:Port=5055,Server=localhost");
        if (!canConnect(kernelConn))
            QSKIP("No kernel debug server available (set WINDBG_KERNEL_CONN)");

        WinDbgMemoryProvider prov(kernelConn);
        QVERIFY2(prov.isValid(), "Should connect to kernel debug server");
        QCOMPARE(prov.kind(), QStringLiteral("WinDbg"));

        qDebug() << "Kernel provider name:" << prov.name();
        qDebug() << "Kernel provider base:" << QString("0x%1").arg(prov.base(), 0, 16);
        qDebug() << "Kernel provider isLive:" << prov.isLive();

        // Name should not be an arbitrary user-mode DLL
        QVERIFY2(!prov.name().contains("WS2_32", Qt::CaseInsensitive),
                 qPrintable("Name should not be 'WS2_32', got: " + prov.name()));
    }

    void provider_kernel_read_base()
    {
        QString kernelConn = qEnvironmentVariable("WINDBG_KERNEL_CONN",
            "tcp:Port=5055,Server=localhost");
        if (!canConnect(kernelConn))
            QSKIP("No kernel debug server available");

        WinDbgMemoryProvider prov(kernelConn);
        QVERIFY(prov.isValid());

        // Provider no longer auto-selects a base.  Use a known kernel address
        // from env, or skip.
        QString addrStr = qEnvironmentVariable("WINDBG_KERNEL_ADDR", "");
        if (addrStr.isEmpty())
            QSKIP("Set WINDBG_KERNEL_ADDR to a readable kernel address");

        bool ok = false;
        uint64_t addr = addrStr.toULongLong(&ok, 16);
        QVERIFY2(ok && addr != 0, "WINDBG_KERNEL_ADDR must be a valid hex address");

        uint8_t buf[16] = {};
        ok = prov.read(addr, buf, 16);
        QVERIFY2(ok, "Should read from kernel address");

        bool allZero = true;
        for (int i = 0; i < 16; ++i) {
            if (buf[i] != 0) { allZero = false; break; }
        }
        QVERIFY2(!allZero, "Kernel read returned all zeros");
    }

    void provider_kernel_read_high_address()
    {
        QString kernelConn = qEnvironmentVariable("WINDBG_KERNEL_CONN",
            "tcp:Port=5055,Server=localhost");
        if (!canConnect(kernelConn))
            QSKIP("No kernel debug server available");

        WinDbgMemoryProvider prov(kernelConn);
        QVERIFY(prov.isValid());

        // Use env var for a specific kernel address (e.g. _EPROCESS),
        // otherwise fall back to the provider's base.
        QString addrStr = qEnvironmentVariable("WINDBG_KERNEL_ADDR", "");
        uint64_t addr = 0;
        if (!addrStr.isEmpty()) {
            bool ok = false;
            addr = addrStr.toULongLong(&ok, 16);
            if (!ok) addr = 0;
        }
        if (addr == 0) addr = prov.base();

        uint8_t buf[64] = {};
        bool ok = prov.read(addr, buf, 64);
        QVERIFY2(ok, qPrintable(QString("Should read kernel addr 0x%1")
                                 .arg(addr, 0, 16)));

        bool allZero = true;
        for (int i = 0; i < 64; ++i) {
            if (buf[i] != 0) { allZero = false; break; }
        }
        QVERIFY2(!allZero, "Kernel high-address read returned all zeros");

        qDebug() << "Read 64 bytes at" << QString("0x%1").arg(addr, 0, 16)
                 << "first 8:" << QString("%1 %2 %3 %4 %5 %6 %7 %8")
                    .arg(buf[0], 2, 16, QChar('0'))
                    .arg(buf[1], 2, 16, QChar('0'))
                    .arg(buf[2], 2, 16, QChar('0'))
                    .arg(buf[3], 2, 16, QChar('0'))
                    .arg(buf[4], 2, 16, QChar('0'))
                    .arg(buf[5], 2, 16, QChar('0'))
                    .arg(buf[6], 2, 16, QChar('0'))
                    .arg(buf[7], 2, 16, QChar('0'));
    }

    void provider_kernel_read_backgroundThread()
    {
        QString kernelConn = qEnvironmentVariable("WINDBG_KERNEL_CONN",
            "tcp:Port=5055,Server=localhost");
        if (!canConnect(kernelConn))
            QSKIP("No kernel debug server available");

        QString addrStr = qEnvironmentVariable("WINDBG_KERNEL_ADDR", "");
        if (addrStr.isEmpty())
            QSKIP("Set WINDBG_KERNEL_ADDR to a readable kernel address");

        bool ok = false;
        uint64_t addr = addrStr.toULongLong(&ok, 16);
        QVERIFY2(ok && addr != 0, "WINDBG_KERNEL_ADDR must be a valid hex address");

        WinDbgMemoryProvider prov(kernelConn);
        QVERIFY(prov.isValid());

        // Simulate the controller's async refresh pattern
        QFuture<QByteArray> future = QtConcurrent::run([&prov, addr]() -> QByteArray {
            return prov.readBytes(addr, 4096);
        });
        future.waitForFinished();
        QByteArray data = future.result();

        QCOMPARE(data.size(), 4096);
        bool allZero = true;
        for (int i = 0; i < data.size(); ++i) {
            if (data[i] != '\0') { allZero = false; break; }
        }
        QVERIFY2(!allZero, "Kernel background read returned all zeros");
    }
};

QTEST_MAIN(TestWinDbgProvider)
#include "test_windbg_provider.moc"

```

`third_party/fadec/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.23)

project(fadec LANGUAGES C)
enable_testing()

# TODO: make this actually optional
enable_language(CXX OPTIONAL)

# Options
set(FADEC_ARCHMODE "both" CACHE STRING "Support only 32-bit x86, 64-bit x86 or both")
set_property(CACHE FADEC_ARCHMODE PROPERTY STRINGS both only32 only64)

option(FADEC_UNDOC "Include undocumented instructions" FALSE)
option(FADEC_DECODE "Include support for decoding" TRUE)
option(FADEC_ENCODE "Include support for encoding" TRUE)
option(FADEC_ENCODE2 "Include support for new encoding API" FALSE)

set(CMAKE_C_STANDARD 11)

if (MSVC)
    add_compile_options(/W4 -D_CRT_SECURE_NO_WARNINGS /wd4018 /wd4146 /wd4244 /wd4245 /wd4267 /wd4310)
    add_compile_options($<$<COMPILE_LANGUAGE:CXX>:-Zc:preprocessor>)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Wno-overlength-strings)
endif()

find_package(Python3 3.9 REQUIRED)

add_library(fadec)
add_library(fadec::fadec ALIAS fadec)
set_target_properties(fadec PROPERTIES
    LINKER_LANGUAGE C
)

set(GEN_ARGS "")
if (NOT FADEC_ARCHMODE STREQUAL "only64")
    list(APPEND GEN_ARGS "--32")
endif ()
if (NOT FADEC_ARCHMODE STREQUAL "only32")
    list(APPEND GEN_ARGS "--64")
endif ()
if (FADEC_UNDOC)
    list(APPEND GEN_ARGS "--with-undoc")
endif ()

file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/include")

function(fadec_component)
    cmake_parse_arguments(ARG "" "NAME" "HEADERS;SOURCES" ${ARGN})

    set(PRIV_INC ${CMAKE_CURRENT_BINARY_DIR}/include/fadec-${ARG_NAME}-private.inc)
    set(PUB_INC ${CMAKE_CURRENT_BINARY_DIR}/include/fadec-${ARG_NAME}-public.inc)

    add_custom_command(
        OUTPUT ${PRIV_INC} ${PUB_INC}
        COMMAND ${Python3_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/parseinstrs.py ${ARG_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/instrs.txt
        ${PUB_INC} ${PRIV_INC} ${GEN_ARGS}
        DEPENDS instrs.txt parseinstrs.py
        COMMENT "Building table for ${ARG_NAME}"
    )

    list(APPEND FADEC_HEADERS ${PUB_INC})
    target_sources(fadec PRIVATE
        ${ARG_SOURCES}

        PUBLIC
        FILE_SET HEADERS
        BASE_DIRS .
        FILES
            ${ARG_HEADERS}

        PUBLIC
        FILE_SET generated_public TYPE HEADERS
        BASE_DIRS ${CMAKE_CURRENT_BINARY_DIR}/include
        FILES
            ${PUB_INC}

        PRIVATE
        FILE_SET generated_private TYPE HEADERS
        BASE_DIRS ${CMAKE_CURRENT_BINARY_DIR}/include
        FILES
            ${PRIV_INC}
    )

    add_executable(fadec-${ARG_NAME}-test ${ARG_NAME}-test.c)
    target_link_libraries(fadec-${ARG_NAME}-test PRIVATE fadec)
    add_test(NAME ${ARG_NAME} COMMAND fadec-${ARG_NAME}-test)

    if (CMAKE_CXX_COMPILER AND ${ARG_NAME} STREQUAL "encode2")
        add_executable(fadec-${ARG_NAME}-test-cpp ${ARG_NAME}-test.cc)
        target_link_libraries(fadec-${ARG_NAME}-test-cpp PRIVATE fadec)
        add_test(NAME ${ARG_NAME}-cpp COMMAND fadec-${ARG_NAME}-test-cpp)
    endif()
endfunction()

if (FADEC_DECODE)
    fadec_component(NAME decode SOURCES decode.c format.c HEADERS fadec.h)
endif ()
if (FADEC_ENCODE)
    fadec_component(NAME encode SOURCES encode.c HEADERS fadec-enc.h)
endif ()
if (FADEC_ENCODE2)
    fadec_component(NAME encode2 SOURCES encode2.c HEADERS fadec-enc2.h)
endif ()

install(TARGETS fadec EXPORT fadec
    LIBRARY
    ARCHIVE
    FILE_SET HEADERS FILE_SET generated_public)

```

`third_party/fadec/LICENSE`:

```
Copyright (c) 2018, Alexis Engelke
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

```

`third_party/fadec/README.md`:

```md
# Fadec — Fast Decoder for x86-32 and x86-64 and Encoder for x86-64

Fadec is a fast and lightweight decoder for x86-32 and x86-64. To meet the goal of speed, lookup tables are used to map the opcode the (internal) description of the instruction encoding. This table currently has a size of roughly 37 kiB (for 32/64-bit combined).

Fadec-Enc (or Faenc) is a small, lightweight and easy-to-use encoder, currently for x86-64 only.

## Key features

> **Q: Why not just use any other decoding/encoding library available out there?**
>
> A: I needed to embed a small and fast decoder in a project for a freestanding environment (i.e., no libc). Further, only very few plain encoding libraries are available for x86-64; and most of them are large or make heavy use of external dependencies.

- **Small size:** the entire library with the x86-64/32 decoder and the x86-64 encoder are only 95 kiB; for specific use cases, the size can be reduced even further (e.g., by dropping AVX-512). The main decode/encode routines are only a few hundreds lines of code.
- **Performance:** Fadec is significantly faster than libopcodes, Capstone, or Zydis due to the absence of high-level abstractions and the small lookup table.
- **Zero dependencies:** the entire library has no dependencies, even on the standard library, making it suitable for freestanding environments without a full libc or `malloc`-style memory allocation.
- **Correctness:** even corner cases should be handled correctly (if not, that's a bug), e.g., the order of prefixes, immediate sizes of jump instructions, the presence of the `lock` prefix, or properly handling VEX.W in 32-bit mode.

All components of this library target the Intel 64 implementations of x86. While AMD64 is _mostly similar_, there are some minor differences (e.g. operand sizes for jump instructions, more instructions, `cr8` can be accessed with `lock` prefix, `f34190` is `xchg`, not `pause`) which are currently not handled.

## Decoder Usage

### Example
```c
uint8_t buffer[] = {0x49, 0x90};
FdInstr instr;
// Decode from buffer into instr in 64-bit mode.
int ret = fd_decode(buffer, sizeof(buffer), 64, 0, &instr);
// ret<0 indicates an error, ret>0 the number of decoded bytes
// Relevant properties of instructions can now be queried using the FD_* macros.
// Or, we can format the instruction to a string buffer:
char fmtbuf[64];
fd_format(&instr, fmtbuf, sizeof(fmtbuf));
// fmtbuf now reads: "xchg r8, rax"
```

### API

The API consists of two functions to decode and format instructions, as well as several accessor macros. A full documentation can be found in [fadec.h](fadec.h). Direct access of any structure fields is not recommended.

- `int fd_decode(const uint8_t* buf, size_t len, int mode, uintptr_t address, FdInstr* out_instr)`
    - Decode a single instruction. For internal performance reasons, note that:
        - The decoded operand sizes are not always exact. However, the exact size can be reconstructed in all cases.
        - An implicit `fwait` in FPU instructions is decoded as a separate instruction (matching the opcode layout in machine code). For example, `finit` is decoded as `FD_FWAIT` + `FD_FINIT`
    - Return value: number of bytes used, or a negative value in case of an error.
    - `buf`/`len`: buffer containing instruction bytes. At most 15 bytes will be read. If the instruction is longer than `len`, an error value is returned.
    - `mode`: architecture mode, either `32` or `64`.
    - `address`: set to `0`. (Obsolete use: virtual address of the decoded instruction.)
    - `out_instr`: Pointer to the instruction buffer, might get written partially in case of an error.
- `void fd_format(const FdInstr* instr, char* buf, size_t len)`
    - Format a single instruction to a human-readable format.
    - `instr`: decoded instruction.
    - `buf`/`len`: buffer for formatted instruction string
- Various accessor macros: see [fadec.h](fadec.h).

## Encoder Usage

The encoder has two API variants: "v1" has a single entry point (`fe_enc64`) and the instruction is specified as integer parameter. "v2" has one entry point per instruction. v2 is currently about 3x faster than v1, but also has much larger code size (v1: <10 kiB; v2: ~3 MiB) and takes much longer to compile. It is therefore off by default and can be enabled by passing `-Dwith_encode2=true` to Meson. Both variants are supported.

### Example (API v1)

```c
int failed = 0;
uint8_t buf[64];
uint8_t* cur = buf;

// xor eax, eax
failed |= fe_enc64(&cur, FE_XOR32rr, FE_AX, FE_AX);
// movzx ecx, byte ptr [rdi + 1*rax + 0]
failed |= fe_enc64(&cur, FE_MOVZXr32m8, FE_CX, FE_MEM(FE_DI, 1, FE_AX, 0));
// test ecx, ecx
failed |= fe_enc64(&cur, FE_TEST32rr, FE_CX, FE_CX);
// jnz $
// This will be replaced later; FE_JMPL enforces use of longest offset
uint8_t* fwd_jmp = cur;
failed |= fe_enc64(&cur, FE_JNZ|FE_JMPL, (intptr_t) cur);
uint8_t* loop_tgt = cur;
// add rax, rcx
failed |= fe_enc64(&cur, FE_ADD64rr, FE_AX, FE_CX);
// sub ecx, 1
failed |= fe_enc64(&cur, FE_SUB32ri, FE_CX, 1);
// jnz loop_tgt
failed |= fe_enc64(&cur, FE_JNZ, (intptr_t) loop_tgt);
// (alternatively: fe_enc64(&cur, FE_Jcc|FE_CC_NZ, (intptr_t) loop_tgt).)
// Update previous jump to jump here. Note that we _must_ specify FE_JMPL too.
failed |= fe_enc64(&fwd_jmp, FE_JNZ|FE_JMPL, (intptr_t) cur);
// ret
failed |= fe_enc64(&cur, FE_RET);
// cur now points to the end of the buffer, failed indicates any failures.
```

### Example (API v2)

```c
uint8_t buf[64];
uint8_t* cur = buf;

// xor eax, eax
cur += fe64_XOR32rr(cur, 0, FE_AX, FE_AX);
// movzx ecx, byte ptr [rdi + 1*rax + 0]
cur += fe64_MOVZXr32m8(cur, 0, FE_CX, FE_MEM(FE_DI, 1, FE_AX, 0));
// test ecx, ecx
cur += fe64_TEST32rr(cur, 0, FE_CX, FE_CX);
// jnz $
// This will be replaced later; FE_JMPL enforces use of longest offset
uint8_t* fwd_jmp = cur;
cur += fe64_JNZ(cur, FE_JMPL, cur);
uint8_t* loop_tgt = cur;
// add rax, rcx
cur += fe64_ADD64rr(cur, 0, FE_AX, FE_CX);
// sub ecx, 1
cur += fe64_SUB32ri(cur, 0, FE_CX, 1);
// jnz loop_tgt
cur += fe64_JNZ(cur, 0, loop_tgt);
// (alternatively: fe64_Jcc(cur, FE_CC_NZ, loop_tgt).)
// Update previous jump to jump here. Note that we _must_ specify FE_JMPL too.
fe64_JNZ(fwd_jmp, FE_JMPL, cur);
// ret
cur += fe64_RET(cur, 0);
// cur now points to the end of the buffer
// errors are ignored, this example should not cause any :-)
```

### API v1

The API consists of one function to handle encode requests, as well as some macros. More information can be found in [fadec-enc.h](fadec-enc.h). Usage of internals like enum values is not recommended.

- `int fe_enc64(uint8_t** buf, uint64_t mnem, int64_t operands...)`
    - Encodes an instruction for x86-64 into `*buf`. EVEX-encoded instructions will transparently encode with the shorter VEX prefix where permitted.
    - Return value: `0` on success, a negative value in error cases.
    - `buf`: Pointer to the pointer to the instruction buffer. The pointer (`*buf`) will be advanced by the number of bytes written. The instruction buffer must have at least 15 bytes left.
    - `mnem`: Instruction mnemonic to encode combined with extra flags:
        - `FE_SEG(segreg)`: override segment to specified segment register.
        - `FE_ADDR32`: override address size to 32-bit.
        - `FE_JMPL`: use longest possible offset encoding, useful when jump target is not known.
        - `FE_MASK(maskreg)`: specify non-zero mask register (1--7) for instructions that support masking (suffixed with `_mask` or `_maskz`) or require a mask (AVX-512 gather/scatter).
        - `FE_RC_RN/RD/RU/RZ`: set rounding mode for instructions with static rounding control (suffixed `_er`).
        - `FE_CC_O/NO/E/NE/...`: set condition code for instructions with unspecified condition code (`Jcc`, `SETcc`, `CMOVcc`, `CMPccXADD`).
    - `operands...`: Up to 4 instruction operands. The operand kinds must match the requirements of the mnemonic.
        - For register operands (`r`=non-mask register, `k`=mask register), use the register: `FE_AX`, `FE_AH`, `FE_XMM12`.
        - For immediate operands (`i`=regular, `a`=absolute address), use the constant: `12`, `-0xbeef`.
        - For memory operands (`m`=regular or `b`=broadcast), use: `FE_MEM(basereg,scale,indexreg,offset)`. Use `0` to specify _no register_. For RIP-relative addressing, the size of the instruction is added automatically.
        - For offset operands (`o`), specify the target address.

### API v2

The API consists of one function per instruction, as well as some macros. The API provides type safety for different register types as well as for memory operands (regular vs. VSIB). Besides a few details listed here, the usage is very similar to API v1. More information can be found in [fadec-enc2.h](fadec-enc2.h). Usage of internals like enum values is not recommended.

- `int fe64_<mnemonic>(uint8_t* buf, int flags, <operands...>)`
    - Encodes the specified instruction for x86-64 into `buf`. EVEX-encoded instructions will transparently encode with the shorter VEX prefix where permitted.
    - Return value: `0` on failure, otherwise the instruction length.
    - `buf`: Pointer to the instruction buffer. The instruction buffer must have at least 15 bytes left. Bytes beyond the returned instruction length can be overwritten.
    - `flags`: combination of extra flags, default to `0`:
        - `FE_SEG(segreg)`: override segment to specified segment register.
        - `FE_ADDR32`: override address size to 32-bit.
        - `FE_JMPL`: use longest possible offset encoding, useful when jump target is not known.
        - `FE_RC_RN/RD/RU/RZ`: set rounding mode for instructions with static rounding control (suffixed `_er`).
        - `FE_CC_O/NO/E/NE/...`: set condition code for instructions with unspecified condition code (`Jcc`, `SETcc`, `CMOVcc`, `CMPccXADD`).
    - `FeRegMASK opmask` (instructions with opmask only): specify non-zero mask register (1--7) for instructions suffixed with `_mask`/`_maskz` and AVX-512 gather/scatter.
    - `operands...`: up to four instruction operands.
        - Registers have types `FeRegGP`/`FeRegXMM`/`FeRegMASK`/etc.; byte registers accepting high-byte operands also accept `FeRegGPH`.
        - Immediate operands have an appropriately sized integer type.
        - Memory operands use a `FeMem` (VSIB: `FeMemV`) structure, use the macro `FE_MEM(basereg,scale,indexreg,offset)` (VSIB: `FE_MEMV(...)`). Use `FE_NOREG` to specify _no register_. For RIP-relative addressing, the size of the instruction is added automatically.
        - For offset operands (`o`), specify the target address relative to `buf`.
- `int fe64_NOP(uint8_t* buf, unsigned size)`
    - Encode a series of `nop`s of `size` bytes, but at least emit one byte. This will use larger the `nop` encodings to reduce the number of instructions and is intended for filling padding.

## Known issues
- Decoder/Encoder: register uniqueness constraints are not enforced. This affects:
    - VSIB-encoded instructions: no vector register may be used more than once
    - AMX instructions: no tile register may be used more than once
    - AVX-512 complex FP16 multiplication: destination must be not be equal to a source register
- Prefixes for indirect jumps and calls are not properly decoded, e.g. `notrack`, `bnd`.
- Low test coverage. (Help needed.)
- No Python API.

Some ISA extensions are not supported, often because they are deprecated or unsupported by recent hardware. These are unlikely to be implemented in the near future:

- (Intel) MPX: Intel lists MPX as deprecated.
- (Intel) HLE prefixes `xacquire`/`xrelease`: Intel lists HLE as deprecated. The formatter for decoded instructions is able to reconstruct these in most cases, though.
- (Intel) Xeon Phi (KNC/KNL/KNM) extensions, including the MVEX prefix: the hardware is discontinued/no longer available.
- (AMD) XOP: unsupported by newer hardware.
- (AMD) FMA4: unsupported by newer hardware.

If you find any other issues, please report a bug. Or, even better, send a patch fixing the issue.

```

`third_party/fadec/decode-test.c`:

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include <fadec.h>


static
void
print_hex(const uint8_t* buf, size_t len)
{
    for (size_t i = 0; i < len; i++)
        printf("%02x", buf[i]);
}

static
int
test(const void* buf, size_t buf_len, unsigned mode, const char* exp_fmt)
{
    FdInstr instr;
    char fmt[128];

    memset(fmt, 0, sizeof(fmt));
    int retval = fd_decode(buf, buf_len, mode, 0, &instr);

    if (retval == FD_ERR_INTERNAL) {
        return 0; // not compiled with this arch-mode (32/64 bit)
    } else if (retval == FD_ERR_PARTIAL) {
        strcpy(fmt, "PARTIAL");
    } else if (retval == FD_ERR_UD) {
        strcpy(fmt, "UD");
    } else {
        fd_format(&instr, fmt, sizeof(fmt));
    }

    if ((retval < 0 || (unsigned) retval == buf_len)) {
        if (!strcmp(fmt, exp_fmt))
            return 0;
        // Consider 32/64 bit differences, e.g. for addressing mode.
        const char* it = exp_fmt;
        while ((it = (const char*) strchr(it, '@'))) {
            if (fmt[it - exp_fmt] == (mode != 64 ? 'e' : 'r'))
                fmt[it - exp_fmt] = '@';
            it++;
        }
        if (!strcmp(fmt, exp_fmt))
            return 0;
    }

    printf("Failed case (%u-bit): ", mode);
    print_hex(buf, buf_len);
    printf("\n  Exp (%2zu): %s", buf_len, exp_fmt);
    printf("\n  Got (%2d): %s\n", retval, fmt);
    return -1;
}

#define TEST1(mode, buf, exp_fmt) test(buf, sizeof(buf)-1, mode, exp_fmt)
#define TEST32(...) failed |= TEST1(32, __VA_ARGS__)
#define TEST64(...) failed |= TEST1(64, __VA_ARGS__)
#define TEST3264(buf, exp_fmt32, exp_fmt64) \
            failed |= TEST1(32, buf, exp_fmt32) | TEST1(64, buf, exp_fmt64)
#define TEST(...) failed |= TEST1(32, __VA_ARGS__) | TEST1(64, __VA_ARGS__)

int
main(int argc, char** argv)
{
    (void) argc; (void) argv;

    int failed = 0;

    TEST("\x90", "nop");
    TEST("\xac", "lodsb");
    TEST3264("\x26\xac", "es lodsb", "lodsb");
    TEST3264("\x2e\xac", "cs lodsb", "lodsb");
    TEST3264("\x36\xac", "ss lodsb", "lodsb");
    TEST3264("\x3e\xac", "ds lodsb", "lodsb");
    TEST("\x64\xac", "fs lodsb");
    TEST("\x65\xac", "gs lodsb");
    TEST3264("\x2e\x2e\xac", "cs lodsb", "lodsb");
    TEST3264("\x2e\x26\xac", "es lodsb", "lodsb");
    TEST3264("\x26\x2e\xac", "cs lodsb", "lodsb");
    TEST3264("\x26\x65\xac", "gs lodsb", "gs lodsb");
    TEST3264("\x65\x26\xac", "es lodsb", "gs lodsb");
    TEST("\x01\x00", "add dword ptr [@ax], eax");
    TEST3264("\x26\x01\x00", "add dword ptr es:[eax], eax", "add dword ptr [rax], eax");
    TEST3264("\x2e\x01\x00", "add dword ptr cs:[eax], eax", "add dword ptr [rax], eax");
    TEST3264("\x36\x01\x00", "add dword ptr ss:[eax], eax", "add dword ptr [rax], eax");
    TEST3264("\x3e\x01\x00", "add dword ptr ds:[eax], eax", "add dword ptr [rax], eax");
    TEST("\x64\x01\x00", "add dword ptr fs:[@ax], eax");
    TEST("\x65\x01\x00", "add dword ptr gs:[@ax], eax");
    TEST("\x0f\x10\xc1", "movups xmm0, xmm1");
    TEST("\x66\x0f\x10\xc1", "movupd xmm0, xmm1");
    TEST("\xf2\x66\x0f\x10\xc1", "movsd xmm0, xmm1");
    TEST("\xf3\x66\x0f\x10\xc1", "movss xmm0, xmm1");
    TEST("\xf3\xf2\x66\x0f\x10\xc1", "movsd xmm0, xmm1");
    TEST("\xf2\x66\xf3\x66\x0f\x10\xc1", "movss xmm0, xmm1");

    TEST64("\x48\x91", "xchg rcx, rax");
    TEST64("\x48\x26\x91", "xchg ecx, eax");
    TEST("\x90", "nop");
    TEST("\xf2\x90", "nop");
    TEST("\x66\x90", "nop"); // NB: could be xchg ax, ax
    TEST("\x66\xf2\x90", "nop"); // NB: could be xchg ax, ax
    TEST64("\x41\x90", "xchg r8d, eax");
    TEST64("\xf2\x41\x90", "xchg r8d, eax");
    TEST64("\x66\x41\x90", "xchg r8w, ax");
    TEST64("\x66\xf2\x41\x90", "xchg r8w, ax");
    TEST64("\x48\x90", "nop"); // NB: could be xchg rax, rax
    TEST64("\xf2\x48\x90", "nop"); // NB: could be xchg rax, rax
    TEST64("\x66\x48\x90", "nop"); // NB: could be xchg rax, rax
    TEST64("\x66\xf2\x48\x90", "nop"); // NB: could be xchg rax, rax
    TEST64("\x49\x90", "xchg r8, rax");
    TEST64("\xf2\x49\x90", "xchg r8, rax");
    TEST64("\x66\x49\x90", "xchg r8, rax");
    TEST64("\x66\xf2\x49\x90", "xchg r8, rax");
    TEST("\xf3\x90", "pause");
    TEST("\x66\xf3\x90", "pause");
    TEST64("\xf3\x41\x90", "pause"); // NB: xchg for AMD
    TEST64("\x66\xf3\x41\x90", "pause"); // NB: xchg for AMD
    TEST64("\xf3\x48\x90", "pause");
    TEST64("\x66\xf3\x48\x90", "pause");
    TEST64("\xf3\x49\x90", "pause"); // NB: xchg for AMD
    TEST64("\x66\xf3\x49\x90", "pause"); // NB: xchg for AMD
    TEST("\xf3\x91", "xchg ecx, eax");

    TEST("\x0f\xc7\x0f", "cmpxchg8b qword ptr [@di]");
    TEST("\x66\x0f\xc7\x0f", "cmpxchg8b qword ptr [@di]"); // 66h is ignored
    TEST64("\x48\x0f\xc7\x0f", "cmpxchg16b xmmword ptr [rdi]");
    TEST("\xf2\x0f\xc7\x0f", "cmpxchg8b qword ptr [@di]");
    TEST("\xf3\x0f\xc7\x0f", "cmpxchg8b qword ptr [@di]");
    TEST("\xf2\xf0\x0f\xc7\x0f", "xacquire lock cmpxchg8b qword ptr [@di]");
    TEST("\xf3\xf0\x0f\xc7\x0f", "xrelease lock cmpxchg8b qword ptr [@di]");
    TEST("\x87\x0f", "xchg dword ptr [@di], ecx");
    TEST("\xf2\x87\x0f", "xacquire xchg dword ptr [@di], ecx");
    TEST("\xf3\x87\x0f", "xrelease xchg dword ptr [@di], ecx");
    TEST("\xf2\xf0\x87\x0f", "xacquire lock xchg dword ptr [@di], ecx");
    TEST("\xf3\xf0\x87\x0f", "xrelease lock xchg dword ptr [@di], ecx");
    TEST("\xc6\x07\x12", "mov byte ptr [@di], 0x12");
    TEST("\xf2\xc6\x07\x12", "mov byte ptr [@di], 0x12"); // no xacquire
    TEST("\xf3\xc6\x07\x12", "xrelease mov byte ptr [@di], 0x12");
    TEST("\x66\xc7\x07\x34\x12", "mov word ptr [@di], 0x1234");
    TEST("\x66\xf2\xc7\x07\x34\x12", "mov word ptr [@di], 0x1234"); // no xacquire
    TEST("\x66\xf3\xc7\x07\x34\x12", "xrelease mov word ptr [@di], 0x1234");
    TEST64("\xf0\xff\xc0", "UD"); // lock with register operand is UD
    TEST64("\xf0\xd0\x00", "UD"); // lock with rol is UD
    TEST("\x66", "PARTIAL");
    TEST("\xf0", "PARTIAL");
    TEST("\x0f", "PARTIAL");
    TEST("\x0f\x38", "PARTIAL");
    TEST("\x0f\x3a", "PARTIAL");
    TEST("\x80", "PARTIAL");
    TEST("\x80\x04", "PARTIAL");
    TEST("\x80\x40", "PARTIAL");
    TEST("\x80\x80\x00\x00\x00", "PARTIAL");
    TEST("\xb0", "PARTIAL");
    TEST("\xb8", "PARTIAL");
    TEST("\xb8\x00", "PARTIAL");
    TEST("\xb8\x00\x00", "PARTIAL");
    TEST("\xb8\x00\x00\x00", "PARTIAL");
    TEST("\x0F\x01\x22", "smsw word ptr [@dx]");
    TEST64("\x48\x0F\x01\x22", "smsw word ptr [rdx]");
    TEST("\x66\x0F\x01\x22", "smsw word ptr [@dx]");
    TEST("\x0F\x01\xE2", "smsw edx");
    TEST("\x66\x0F\x01\xE2", "smsw dx");
    TEST64("\x66\x48\x0F\x01\xE2", "smsw rdx");
    TEST64("\xf2\x66\x0f\x01\x23", "smsw word ptr [rbx]");
    TEST("\x66\x0f\x20\x00", "mov @ax, cr0"); // mod=0, 66h
    TEST("\xf3\x0f\x20\x00", "mov @ax, cr0"); // REP
    TEST("\x0f\x20\xc8", "UD"); // cr1
    TEST("\x0f\x20\xd0", "mov @ax, cr2"); // cr2
    TEST64("\x48\x0f\x20\xd0", "mov rax, cr2"); // cr2 + REX.W
    TEST("\x0f\x20\xd8", "mov @ax, cr3"); // cr3
    TEST("\x0f\x20\xe0", "mov @ax, cr4"); // cr4
    TEST3264("\x0f\x20\xe8", "UD", "UD"); // cr5
    TEST64("\x44\x0f\x20\x00", "mov rax, cr8"); // cr8
    TEST64("\x45\x0f\x20\x00", "mov r8, cr8"); // cr8
    TEST64("\x44\x0f\x20\x08", "UD"); // cr9
    TEST64("\x44\x0f\x21\x00", "UD"); // dr8
    TEST32("\xf0\x0f\x20\x00", "UD"); // LOCK
    TEST("\x8c\xc0", "mov ax, es");
    TEST64("\x44\x8c\xc0", "mov ax, es");
    TEST64("\x44\x8c\xf0", "UD"); // no segment register 6
    TEST64("\x44\x8c\xf8", "UD"); // no segment register 7
    TEST("\x8e\xc0", "mov es, ax");
    TEST("\x8e\xc8", "UD"); // No mov cs, eax
    TEST("\x0f\x1e\xc0", "nop eax, eax"); // reserved nop
    TEST("\x0f\x1e\x04\x25\x01\x00\x00\x00", "nop dword ptr [0x1], eax"); // reserved nop
    TEST64("\xf3\x4f\x0f\x1e\xfc", "nop r12, r15"); // reserved nop
    TEST("\xd8\xc1", "fadd st(0), st(1)");
    TEST("\xdc\xc1", "fadd st(1), st(0)");
    TEST64("\x41\xd8\xc1", "fadd st(0), st(1)"); // REX.B ignored
    TEST64("\xd9\xc9", "fxch st(1)");
    TEST64("\xd9\xd0", "fnop");
    TEST("\xdf\xe0", "fstsw ax");
    TEST64("\x41\xdf\xe0", "fstsw ax");

    // ModRM Test cases
    // reg
    TEST("\x01\xc0", "add eax, eax");
    TEST("\x01\xc1", "add ecx, eax");
    TEST("\x01\xd0", "add eax, edx");
    TEST("\x01\xff", "add edi, edi");
    TEST64("\x41\x01\xd0", "add r8d, edx");
    TEST64("\x45\x01\xd0", "add r8d, r10d");
    TEST64("\x45\x01\xff", "add r15d, r15d");
    // [reg]
    TEST("\x01\x00", "add dword ptr [@ax], eax");
    TEST("\x01\x08", "add dword ptr [@ax], ecx");
    TEST("\x01\x01", "add dword ptr [@cx], eax");
    TEST("\x01\x07", "add dword ptr [@di], eax");
    TEST("\x01\x38", "add dword ptr [@ax], edi");
    TEST("\x01\x04\x24", "add dword ptr [@sp], eax");
    TEST64("\x41\x01\x00", "add dword ptr [r8], eax");
    TEST64("\x44\x01\x08", "add dword ptr [rax], r9d");
    TEST64("\x45\x01\x00", "add dword ptr [r8], r8d");
    TEST64("\x41\x01\x07", "add dword ptr [r15], eax");
    TEST64("\x41\x01\x04\x24", "add dword ptr [r12], eax");
    // [disp32]
    TEST32("\x01\x05\x01\x00\x00\x00", "add dword ptr [0x1], eax");
    TEST32("\x01\x05\xff\xff\xff\xff", "add dword ptr [0xffffffff], eax");
    TEST("\x01\x04\x25\x01\x00\x00\x00", "add dword ptr [0x1], eax");
    TEST3264("\x01\x04\x25\x00\x00\x00\x80", "add dword ptr [0x80000000], eax", "add dword ptr [0xffffffff80000000], eax");
    TEST64("\x41\x01\x04\x25\x01\x00\x00\x00", "add dword ptr [0x1], eax");
    TEST("\x01\x04\x25\x00\x00\x00\x00", "add dword ptr [0x0], eax");
    // [rip+disp32]
    TEST64("\x01\x05\x01\x00\x00\x00", "add dword ptr [rip+0x1], eax");
    TEST64("\x41\x01\x05\x01\x00\x00\x00", "add dword ptr [rip+0x1], eax");
    TEST64("\x67\x01\x05\x01\x00\x00\x00", "add dword ptr [eip+0x1], eax");
    TEST64("\x67\x41\x01\x05\x01\x00\x00\x00", "add dword ptr [eip+0x1], eax");
    // [reg+disp32]
    TEST("\x01\x80\x01\x00\x00\x00", "add dword ptr [@ax+0x1], eax");
    TEST("\x01\x80\x00\x00\x00\x80", "add dword ptr [@ax-0x80000000], eax");
    // [reg+eiz+disp32]
    TEST("\x01\x84\x25\x01\x00\x00\x00", "add dword ptr [@bp+0x1], eax");
    // [reg+s*reg+disp32]
    TEST64("\x42\x01\x84\x25\x01\x00\x00\x00", "add dword ptr [rbp+1*r12+0x1], eax");
    // [s*reg]
    TEST("\x01\x04\x8d\x00\x00\x00\x00", "add dword ptr [4*@cx], eax");

    // 32-bit+67 ModRM cases. reg=0
    TEST32("\x67\x01\x00", "add dword ptr [bx+1*si], eax");
    TEST32("\x67\x01\x01", "add dword ptr [bx+1*di], eax");
    TEST32("\x67\x01\x02", "add dword ptr [bp+1*si], eax");
    TEST32("\x67\x01\x03", "add dword ptr [bp+1*di], eax");
    TEST32("\x67\x01\x04", "add dword ptr [1*si], eax");
    TEST32("\x67\x01\x05", "add dword ptr [1*di], eax");
    TEST32("\x67\x01\x06\x11\x22", "add dword ptr [0x2211], eax");
    TEST32("\x67\x01\x06\xf0\xff", "add dword ptr [0xfff0], eax");
    TEST32("\x67\x01\x07", "add dword ptr [bx], eax");
    TEST32("\x67\x01\x40\x12", "add dword ptr [bx+1*si+0x12], eax");
    TEST32("\x67\x01\x40\x99", "add dword ptr [bx+1*si-0x67], eax");
    TEST32("\x67\x01\x41\x12", "add dword ptr [bx+1*di+0x12], eax");
    TEST32("\x67\x01\x41\x99", "add dword ptr [bx+1*di-0x67], eax");
    TEST32("\x67\x01\x42\x12", "add dword ptr [bp+1*si+0x12], eax");
    TEST32("\x67\x01\x42\x99", "add dword ptr [bp+1*si-0x67], eax");
    TEST32("\x67\x01\x43\x12", "add dword ptr [bp+1*di+0x12], eax");
    TEST32("\x67\x01\x43\x99", "add dword ptr [bp+1*di-0x67], eax");
    TEST32("\x67\x01\x44\x12", "add dword ptr [1*si+0x12], eax");
    TEST32("\x67\x01\x44\x99", "add dword ptr [1*si-0x67], eax");
    TEST32("\x67\x01\x45\x12", "add dword ptr [1*di+0x12], eax");
    TEST32("\x67\x01\x45\x99", "add dword ptr [1*di-0x67], eax");
    TEST32("\x67\x01\x46\x12", "add dword ptr [bp+0x12], eax");
    TEST32("\x67\x01\x46\x99", "add dword ptr [bp-0x67], eax");
    TEST32("\x67\x01\x47\x12", "add dword ptr [bx+0x12], eax");
    TEST32("\x67\x01\x47\x99", "add dword ptr [bx-0x67], eax");
    TEST32("\x67\x01\x80\x11\x22", "add dword ptr [bx+1*si+0x2211], eax");
    TEST32("\x67\x01\x80\xf0\xff", "add dword ptr [bx+1*si-0x10], eax");
    TEST32("\x67\x01\x81\x11\x22", "add dword ptr [bx+1*di+0x2211], eax");
    TEST32("\x67\x01\x81\xf0\xff", "add dword ptr [bx+1*di-0x10], eax");
    TEST32("\x67\x01\x82\x11\x22", "add dword ptr [bp+1*si+0x2211], eax");
    TEST32("\x67\x01\x82\xf0\xff", "add dword ptr [bp+1*si-0x10], eax");
    TEST32("\x67\x01\x83\x11\x22", "add dword ptr [bp+1*di+0x2211], eax");
    TEST32("\x67\x01\x83\xf0\xff", "add dword ptr [bp+1*di-0x10], eax");
    TEST32("\x67\x01\x84\x11\x22", "add dword ptr [1*si+0x2211], eax");
    TEST32("\x67\x01\x84\xf0\xff", "add dword ptr [1*si-0x10], eax");
    TEST32("\x67\x01\x85\x11\x22", "add dword ptr [1*di+0x2211], eax");
    TEST32("\x67\x01\x85\xf0\xff", "add dword ptr [1*di-0x10], eax");
    TEST32("\x67\x01\x86\x11\x22", "add dword ptr [bp+0x2211], eax");
    TEST32("\x67\x01\x86\xf0\xff", "add dword ptr [bp-0x10], eax");
    TEST32("\x67\x01\x87\x11\x22", "add dword ptr [bx+0x2211], eax");
    TEST32("\x67\x01\x87\xf0\xff", "add dword ptr [bx-0x10], eax");
    TEST32("\x67\x01", "PARTIAL");
    TEST32("\x67\x01\x47", "PARTIAL");
    TEST32("\x67\x01\x80", "PARTIAL");
    TEST32("\x67\x01\x80\x11", "PARTIAL");

    // 32-bit, 64-bit and 64-bit+67 ModRM+SIB cases. scale=2, reg=0
    TEST("\x01\x00", "add dword ptr [@ax], eax");
    TEST64("\x67\x01\x00", "add dword ptr [eax], eax");
    TEST("\x01\x01", "add dword ptr [@cx], eax");
    TEST64("\x67\x01\x01", "add dword ptr [ecx], eax");
    TEST("\x01\x02", "add dword ptr [@dx], eax");
    TEST64("\x67\x01\x02", "add dword ptr [edx], eax");
    TEST("\x01\x03", "add dword ptr [@bx], eax");
    TEST64("\x67\x01\x03", "add dword ptr [ebx], eax");
    TEST("\x01\x04\x80", "add dword ptr [@ax+4*@ax], eax");
    TEST64("\x67\x01\x04\x80", "add dword ptr [eax+4*eax], eax");
    TEST("\x01\x04\x81", "add dword ptr [@cx+4*@ax], eax");
    TEST64("\x67\x01\x04\x81", "add dword ptr [ecx+4*eax], eax");
    TEST("\x01\x04\x82", "add dword ptr [@dx+4*@ax], eax");
    TEST64("\x67\x01\x04\x82", "add dword ptr [edx+4*eax], eax");
    TEST("\x01\x04\x83", "add dword ptr [@bx+4*@ax], eax");
    TEST64("\x67\x01\x04\x83", "add dword ptr [ebx+4*eax], eax");
    TEST("\x01\x04\x84", "add dword ptr [@sp+4*@ax], eax");
    TEST64("\x67\x01\x04\x84", "add dword ptr [esp+4*eax], eax");
    TEST("\x01\x04\x85\x11\x22\x33\x44", "add dword ptr [4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x04\x85\x11\x22\x33\x44", "add dword ptr [4*eax+0x44332211], eax");
    TEST("\x01\x04\x86", "add dword ptr [@si+4*@ax], eax");
    TEST64("\x67\x01\x04\x86", "add dword ptr [esi+4*eax], eax");
    TEST("\x01\x04\x87", "add dword ptr [@di+4*@ax], eax");
    TEST64("\x67\x01\x04\x87", "add dword ptr [edi+4*eax], eax");
    TEST("\x01\x04\x88", "add dword ptr [@ax+4*@cx], eax");
    TEST64("\x67\x01\x04\x88", "add dword ptr [eax+4*ecx], eax");
    TEST("\x01\x04\x89", "add dword ptr [@cx+4*@cx], eax");
    TEST64("\x67\x01\x04\x89", "add dword ptr [ecx+4*ecx], eax");
    TEST("\x01\x04\x8a", "add dword ptr [@dx+4*@cx], eax");
    TEST64("\x67\x01\x04\x8a", "add dword ptr [edx+4*ecx], eax");
    TEST("\x01\x04\x8b", "add dword ptr [@bx+4*@cx], eax");
    TEST64("\x67\x01\x04\x8b", "add dword ptr [ebx+4*ecx], eax");
    TEST("\x01\x04\x8c", "add dword ptr [@sp+4*@cx], eax");
    TEST64("\x67\x01\x04\x8c", "add dword ptr [esp+4*ecx], eax");
    TEST("\x01\x04\x8d\x11\x22\x33\x44", "add dword ptr [4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x04\x8d\x11\x22\x33\x44", "add dword ptr [4*ecx+0x44332211], eax");
    TEST("\x01\x04\x8e", "add dword ptr [@si+4*@cx], eax");
    TEST64("\x67\x01\x04\x8e", "add dword ptr [esi+4*ecx], eax");
    TEST("\x01\x04\x8f", "add dword ptr [@di+4*@cx], eax");
    TEST64("\x67\x01\x04\x8f", "add dword ptr [edi+4*ecx], eax");
    TEST("\x01\x04\x90", "add dword ptr [@ax+4*@dx], eax");
    TEST64("\x67\x01\x04\x90", "add dword ptr [eax+4*edx], eax");
    TEST("\x01\x04\x91", "add dword ptr [@cx+4*@dx], eax");
    TEST64("\x67\x01\x04\x91", "add dword ptr [ecx+4*edx], eax");
    TEST("\x01\x04\x92", "add dword ptr [@dx+4*@dx], eax");
    TEST64("\x67\x01\x04\x92", "add dword ptr [edx+4*edx], eax");
    TEST("\x01\x04\x93", "add dword ptr [@bx+4*@dx], eax");
    TEST64("\x67\x01\x04\x93", "add dword ptr [ebx+4*edx], eax");
    TEST("\x01\x04\x94", "add dword ptr [@sp+4*@dx], eax");
    TEST64("\x67\x01\x04\x94", "add dword ptr [esp+4*edx], eax");
    TEST("\x01\x04\x95\x11\x22\x33\x44", "add dword ptr [4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x04\x95\x11\x22\x33\x44", "add dword ptr [4*edx+0x44332211], eax");
    TEST("\x01\x04\x96", "add dword ptr [@si+4*@dx], eax");
    TEST64("\x67\x01\x04\x96", "add dword ptr [esi+4*edx], eax");
    TEST("\x01\x04\x97", "add dword ptr [@di+4*@dx], eax");
    TEST64("\x67\x01\x04\x97", "add dword ptr [edi+4*edx], eax");
    TEST("\x01\x04\x98", "add dword ptr [@ax+4*@bx], eax");
    TEST64("\x67\x01\x04\x98", "add dword ptr [eax+4*ebx], eax");
    TEST("\x01\x04\x99", "add dword ptr [@cx+4*@bx], eax");
    TEST64("\x67\x01\x04\x99", "add dword ptr [ecx+4*ebx], eax");
    TEST("\x01\x04\x9a", "add dword ptr [@dx+4*@bx], eax");
    TEST64("\x67\x01\x04\x9a", "add dword ptr [edx+4*ebx], eax");
    TEST("\x01\x04\x9b", "add dword ptr [@bx+4*@bx], eax");
    TEST64("\x67\x01\x04\x9b", "add dword ptr [ebx+4*ebx], eax");
    TEST("\x01\x04\x9c", "add dword ptr [@sp+4*@bx], eax");
    TEST64("\x67\x01\x04\x9c", "add dword ptr [esp+4*ebx], eax");
    TEST("\x01\x04\x9d\x11\x22\x33\x44", "add dword ptr [4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x04\x9d\x11\x22\x33\x44", "add dword ptr [4*ebx+0x44332211], eax");
    TEST("\x01\x04\x9e", "add dword ptr [@si+4*@bx], eax");
    TEST64("\x67\x01\x04\x9e", "add dword ptr [esi+4*ebx], eax");
    TEST("\x01\x04\x9f", "add dword ptr [@di+4*@bx], eax");
    TEST64("\x67\x01\x04\x9f", "add dword ptr [edi+4*ebx], eax");
    TEST("\x01\x04\xa0", "add dword ptr [@ax], eax");
    TEST64("\x67\x01\x04\xa0", "add dword ptr [eax], eax");
    TEST("\x01\x04\xa1", "add dword ptr [@cx], eax");
    TEST64("\x67\x01\x04\xa1", "add dword ptr [ecx], eax");
    TEST("\x01\x04\xa2", "add dword ptr [@dx], eax");
    TEST64("\x67\x01\x04\xa2", "add dword ptr [edx], eax");
    TEST("\x01\x04\xa3", "add dword ptr [@bx], eax");
    TEST64("\x67\x01\x04\xa3", "add dword ptr [ebx], eax");
    TEST("\x01\x04\xa4", "add dword ptr [@sp], eax");
    TEST64("\x67\x01\x04\xa4", "add dword ptr [esp], eax");
    TEST3264("\x01\x04\xa5\x11\x22\x33\x44", "add dword ptr [0x44332211], eax", "add dword ptr [0x44332211], eax");
    TEST64("\x67\x01\x04\xa5\x11\x22\x33\x44", "add dword ptr [0x44332211], eax");
    TEST("\x01\x04\xa6", "add dword ptr [@si], eax");
    TEST64("\x67\x01\x04\xa6", "add dword ptr [esi], eax");
    TEST("\x01\x04\xa7", "add dword ptr [@di], eax");
    TEST64("\x67\x01\x04\xa7", "add dword ptr [edi], eax");
    TEST("\x01\x04\xa8", "add dword ptr [@ax+4*@bp], eax");
    TEST64("\x67\x01\x04\xa8", "add dword ptr [eax+4*ebp], eax");
    TEST("\x01\x04\xa9", "add dword ptr [@cx+4*@bp], eax");
    TEST64("\x67\x01\x04\xa9", "add dword ptr [ecx+4*ebp], eax");
    TEST("\x01\x04\xaa", "add dword ptr [@dx+4*@bp], eax");
    TEST64("\x67\x01\x04\xaa", "add dword ptr [edx+4*ebp], eax");
    TEST("\x01\x04\xab", "add dword ptr [@bx+4*@bp], eax");
    TEST64("\x67\x01\x04\xab", "add dword ptr [ebx+4*ebp], eax");
    TEST("\x01\x04\xac", "add dword ptr [@sp+4*@bp], eax");
    TEST64("\x67\x01\x04\xac", "add dword ptr [esp+4*ebp], eax");
    TEST("\x01\x04\xad\x11\x22\x33\x44", "add dword ptr [4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x04\xad\x11\x22\x33\x44", "add dword ptr [4*ebp+0x44332211], eax");
    TEST("\x01\x04\xae", "add dword ptr [@si+4*@bp], eax");
    TEST64("\x67\x01\x04\xae", "add dword ptr [esi+4*ebp], eax");
    TEST("\x01\x04\xaf", "add dword ptr [@di+4*@bp], eax");
    TEST64("\x67\x01\x04\xaf", "add dword ptr [edi+4*ebp], eax");
    TEST("\x01\x04\xb0", "add dword ptr [@ax+4*@si], eax");
    TEST64("\x67\x01\x04\xb0", "add dword ptr [eax+4*esi], eax");
    TEST("\x01\x04\xb1", "add dword ptr [@cx+4*@si], eax");
    TEST64("\x67\x01\x04\xb1", "add dword ptr [ecx+4*esi], eax");
    TEST("\x01\x04\xb2", "add dword ptr [@dx+4*@si], eax");
    TEST64("\x67\x01\x04\xb2", "add dword ptr [edx+4*esi], eax");
    TEST("\x01\x04\xb3", "add dword ptr [@bx+4*@si], eax");
    TEST64("\x67\x01\x04\xb3", "add dword ptr [ebx+4*esi], eax");
    TEST("\x01\x04\xb4", "add dword ptr [@sp+4*@si], eax");
    TEST64("\x67\x01\x04\xb4", "add dword ptr [esp+4*esi], eax");
    TEST("\x01\x04\xb5\x11\x22\x33\x44", "add dword ptr [4*@si+0x44332211], eax");
    TEST64("\x67\x01\x04\xb5\x11\x22\x33\x44", "add dword ptr [4*esi+0x44332211], eax");
    TEST("\x01\x04\xb6", "add dword ptr [@si+4*@si], eax");
    TEST64("\x67\x01\x04\xb6", "add dword ptr [esi+4*esi], eax");
    TEST("\x01\x04\xb7", "add dword ptr [@di+4*@si], eax");
    TEST64("\x67\x01\x04\xb7", "add dword ptr [edi+4*esi], eax");
    TEST("\x01\x04\xb8", "add dword ptr [@ax+4*@di], eax");
    TEST64("\x67\x01\x04\xb8", "add dword ptr [eax+4*edi], eax");
    TEST("\x01\x04\xb9", "add dword ptr [@cx+4*@di], eax");
    TEST64("\x67\x01\x04\xb9", "add dword ptr [ecx+4*edi], eax");
    TEST("\x01\x04\xba", "add dword ptr [@dx+4*@di], eax");
    TEST64("\x67\x01\x04\xba", "add dword ptr [edx+4*edi], eax");
    TEST("\x01\x04\xbb", "add dword ptr [@bx+4*@di], eax");
    TEST64("\x67\x01\x04\xbb", "add dword ptr [ebx+4*edi], eax");
    TEST("\x01\x04\xbc", "add dword ptr [@sp+4*@di], eax");
    TEST64("\x67\x01\x04\xbc", "add dword ptr [esp+4*edi], eax");
    TEST("\x01\x04\xbd\x11\x22\x33\x44", "add dword ptr [4*@di+0x44332211], eax");
    TEST64("\x67\x01\x04\xbd\x11\x22\x33\x44", "add dword ptr [4*edi+0x44332211], eax");
    TEST("\x01\x04\xbe", "add dword ptr [@si+4*@di], eax");
    TEST64("\x67\x01\x04\xbe", "add dword ptr [esi+4*edi], eax");
    TEST("\x01\x04\xbf", "add dword ptr [@di+4*@di], eax");
    TEST64("\x67\x01\x04\xbf", "add dword ptr [edi+4*edi], eax");
    TEST3264("\x01\x05\x11\x22\x33\x44", "add dword ptr [0x44332211], eax", "add dword ptr [rip+0x44332211], eax");
    TEST64("\x67\x01\x05\x11\x22\x33\x44", "add dword ptr [eip+0x44332211], eax");
    TEST("\x01\x06", "add dword ptr [@si], eax");
    TEST64("\x67\x01\x06", "add dword ptr [esi], eax");
    TEST("\x01\x07", "add dword ptr [@di], eax");
    TEST64("\x67\x01\x07", "add dword ptr [edi], eax");
    TEST("\x01\x40\x99", "add dword ptr [@ax-0x67], eax");
    TEST64("\x67\x01\x40\x99", "add dword ptr [eax-0x67], eax");
    TEST("\x01\x41\x99", "add dword ptr [@cx-0x67], eax");
    TEST64("\x67\x01\x41\x99", "add dword ptr [ecx-0x67], eax");
    TEST("\x01\x42\x99", "add dword ptr [@dx-0x67], eax");
    TEST64("\x67\x01\x42\x99", "add dword ptr [edx-0x67], eax");
    TEST("\x01\x43\x99", "add dword ptr [@bx-0x67], eax");
    TEST64("\x67\x01\x43\x99", "add dword ptr [ebx-0x67], eax");
    TEST("\x01\x44\x80\x99", "add dword ptr [@ax+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x80\x99", "add dword ptr [eax+4*eax-0x67], eax");
    TEST("\x01\x44\x81\x99", "add dword ptr [@cx+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x81\x99", "add dword ptr [ecx+4*eax-0x67], eax");
    TEST("\x01\x44\x82\x99", "add dword ptr [@dx+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x82\x99", "add dword ptr [edx+4*eax-0x67], eax");
    TEST("\x01\x44\x83\x99", "add dword ptr [@bx+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x83\x99", "add dword ptr [ebx+4*eax-0x67], eax");
    TEST("\x01\x44\x84\x99", "add dword ptr [@sp+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x84\x99", "add dword ptr [esp+4*eax-0x67], eax");
    TEST("\x01\x44\x85\x99", "add dword ptr [@bp+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x85\x99", "add dword ptr [ebp+4*eax-0x67], eax");
    TEST("\x01\x44\x86\x99", "add dword ptr [@si+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x86\x99", "add dword ptr [esi+4*eax-0x67], eax");
    TEST("\x01\x44\x87\x99", "add dword ptr [@di+4*@ax-0x67], eax");
    TEST64("\x67\x01\x44\x87\x99", "add dword ptr [edi+4*eax-0x67], eax");
    TEST("\x01\x44\x88\x99", "add dword ptr [@ax+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x88\x99", "add dword ptr [eax+4*ecx-0x67], eax");
    TEST("\x01\x44\x89\x99", "add dword ptr [@cx+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x89\x99", "add dword ptr [ecx+4*ecx-0x67], eax");
    TEST("\x01\x44\x8a\x99", "add dword ptr [@dx+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x8a\x99", "add dword ptr [edx+4*ecx-0x67], eax");
    TEST("\x01\x44\x8b\x99", "add dword ptr [@bx+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x8b\x99", "add dword ptr [ebx+4*ecx-0x67], eax");
    TEST("\x01\x44\x8c\x99", "add dword ptr [@sp+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x8c\x99", "add dword ptr [esp+4*ecx-0x67], eax");
    TEST("\x01\x44\x8d\x99", "add dword ptr [@bp+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x8d\x99", "add dword ptr [ebp+4*ecx-0x67], eax");
    TEST("\x01\x44\x8e\x99", "add dword ptr [@si+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x8e\x99", "add dword ptr [esi+4*ecx-0x67], eax");
    TEST("\x01\x44\x8f\x99", "add dword ptr [@di+4*@cx-0x67], eax");
    TEST64("\x67\x01\x44\x8f\x99", "add dword ptr [edi+4*ecx-0x67], eax");
    TEST("\x01\x44\x90\x99", "add dword ptr [@ax+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x90\x99", "add dword ptr [eax+4*edx-0x67], eax");
    TEST("\x01\x44\x91\x99", "add dword ptr [@cx+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x91\x99", "add dword ptr [ecx+4*edx-0x67], eax");
    TEST("\x01\x44\x92\x99", "add dword ptr [@dx+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x92\x99", "add dword ptr [edx+4*edx-0x67], eax");
    TEST("\x01\x44\x93\x99", "add dword ptr [@bx+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x93\x99", "add dword ptr [ebx+4*edx-0x67], eax");
    TEST("\x01\x44\x94\x99", "add dword ptr [@sp+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x94\x99", "add dword ptr [esp+4*edx-0x67], eax");
    TEST("\x01\x44\x95\x99", "add dword ptr [@bp+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x95\x99", "add dword ptr [ebp+4*edx-0x67], eax");
    TEST("\x01\x44\x96\x99", "add dword ptr [@si+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x96\x99", "add dword ptr [esi+4*edx-0x67], eax");
    TEST("\x01\x44\x97\x99", "add dword ptr [@di+4*@dx-0x67], eax");
    TEST64("\x67\x01\x44\x97\x99", "add dword ptr [edi+4*edx-0x67], eax");
    TEST("\x01\x44\x98\x99", "add dword ptr [@ax+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x98\x99", "add dword ptr [eax+4*ebx-0x67], eax");
    TEST("\x01\x44\x99\x99", "add dword ptr [@cx+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x99\x99", "add dword ptr [ecx+4*ebx-0x67], eax");
    TEST("\x01\x44\x9a\x99", "add dword ptr [@dx+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x9a\x99", "add dword ptr [edx+4*ebx-0x67], eax");
    TEST("\x01\x44\x9b\x99", "add dword ptr [@bx+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x9b\x99", "add dword ptr [ebx+4*ebx-0x67], eax");
    TEST("\x01\x44\x9c\x99", "add dword ptr [@sp+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x9c\x99", "add dword ptr [esp+4*ebx-0x67], eax");
    TEST("\x01\x44\x9d\x99", "add dword ptr [@bp+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x9d\x99", "add dword ptr [ebp+4*ebx-0x67], eax");
    TEST("\x01\x44\x9e\x99", "add dword ptr [@si+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x9e\x99", "add dword ptr [esi+4*ebx-0x67], eax");
    TEST("\x01\x44\x9f\x99", "add dword ptr [@di+4*@bx-0x67], eax");
    TEST64("\x67\x01\x44\x9f\x99", "add dword ptr [edi+4*ebx-0x67], eax");
    TEST("\x01\x44\xa0\x99", "add dword ptr [@ax-0x67], eax");
    TEST64("\x67\x01\x44\xa0\x99", "add dword ptr [eax-0x67], eax");
    TEST("\x01\x44\xa1\x99", "add dword ptr [@cx-0x67], eax");
    TEST64("\x67\x01\x44\xa1\x99", "add dword ptr [ecx-0x67], eax");
    TEST("\x01\x44\xa2\x99", "add dword ptr [@dx-0x67], eax");
    TEST64("\x67\x01\x44\xa2\x99", "add dword ptr [edx-0x67], eax");
    TEST("\x01\x44\xa3\x99", "add dword ptr [@bx-0x67], eax");
    TEST64("\x67\x01\x44\xa3\x99", "add dword ptr [ebx-0x67], eax");
    TEST("\x01\x44\xa4\x99", "add dword ptr [@sp-0x67], eax");
    TEST64("\x67\x01\x44\xa4\x99", "add dword ptr [esp-0x67], eax");
    TEST("\x01\x44\xa5\x99", "add dword ptr [@bp-0x67], eax");
    TEST64("\x67\x01\x44\xa5\x99", "add dword ptr [ebp-0x67], eax");
    TEST("\x01\x44\xa6\x99", "add dword ptr [@si-0x67], eax");
    TEST64("\x67\x01\x44\xa6\x99", "add dword ptr [esi-0x67], eax");
    TEST("\x01\x44\xa7\x99", "add dword ptr [@di-0x67], eax");
    TEST64("\x67\x01\x44\xa7\x99", "add dword ptr [edi-0x67], eax");
    TEST("\x01\x44\xa8\x99", "add dword ptr [@ax+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xa8\x99", "add dword ptr [eax+4*ebp-0x67], eax");
    TEST("\x01\x44\xa9\x99", "add dword ptr [@cx+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xa9\x99", "add dword ptr [ecx+4*ebp-0x67], eax");
    TEST("\x01\x44\xaa\x99", "add dword ptr [@dx+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xaa\x99", "add dword ptr [edx+4*ebp-0x67], eax");
    TEST("\x01\x44\xab\x99", "add dword ptr [@bx+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xab\x99", "add dword ptr [ebx+4*ebp-0x67], eax");
    TEST("\x01\x44\xac\x99", "add dword ptr [@sp+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xac\x99", "add dword ptr [esp+4*ebp-0x67], eax");
    TEST("\x01\x44\xad\x99", "add dword ptr [@bp+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xad\x99", "add dword ptr [ebp+4*ebp-0x67], eax");
    TEST("\x01\x44\xae\x99", "add dword ptr [@si+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xae\x99", "add dword ptr [esi+4*ebp-0x67], eax");
    TEST("\x01\x44\xaf\x99", "add dword ptr [@di+4*@bp-0x67], eax");
    TEST64("\x67\x01\x44\xaf\x99", "add dword ptr [edi+4*ebp-0x67], eax");
    TEST("\x01\x44\xb0\x99", "add dword ptr [@ax+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb0\x99", "add dword ptr [eax+4*esi-0x67], eax");
    TEST("\x01\x44\xb1\x99", "add dword ptr [@cx+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb1\x99", "add dword ptr [ecx+4*esi-0x67], eax");
    TEST("\x01\x44\xb2\x99", "add dword ptr [@dx+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb2\x99", "add dword ptr [edx+4*esi-0x67], eax");
    TEST("\x01\x44\xb3\x99", "add dword ptr [@bx+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb3\x99", "add dword ptr [ebx+4*esi-0x67], eax");
    TEST("\x01\x44\xb4\x99", "add dword ptr [@sp+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb4\x99", "add dword ptr [esp+4*esi-0x67], eax");
    TEST("\x01\x44\xb5\x99", "add dword ptr [@bp+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb5\x99", "add dword ptr [ebp+4*esi-0x67], eax");
    TEST("\x01\x44\xb6\x99", "add dword ptr [@si+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb6\x99", "add dword ptr [esi+4*esi-0x67], eax");
    TEST("\x01\x44\xb7\x99", "add dword ptr [@di+4*@si-0x67], eax");
    TEST64("\x67\x01\x44\xb7\x99", "add dword ptr [edi+4*esi-0x67], eax");
    TEST("\x01\x44\xb8\x99", "add dword ptr [@ax+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xb8\x99", "add dword ptr [eax+4*edi-0x67], eax");
    TEST("\x01\x44\xb9\x99", "add dword ptr [@cx+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xb9\x99", "add dword ptr [ecx+4*edi-0x67], eax");
    TEST("\x01\x44\xba\x99", "add dword ptr [@dx+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xba\x99", "add dword ptr [edx+4*edi-0x67], eax");
    TEST("\x01\x44\xbb\x99", "add dword ptr [@bx+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xbb\x99", "add dword ptr [ebx+4*edi-0x67], eax");
    TEST("\x01\x44\xbc\x99", "add dword ptr [@sp+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xbc\x99", "add dword ptr [esp+4*edi-0x67], eax");
    TEST("\x01\x44\xbd\x99", "add dword ptr [@bp+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xbd\x99", "add dword ptr [ebp+4*edi-0x67], eax");
    TEST("\x01\x44\xbe\x99", "add dword ptr [@si+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xbe\x99", "add dword ptr [esi+4*edi-0x67], eax");
    TEST("\x01\x44\xbf\x99", "add dword ptr [@di+4*@di-0x67], eax");
    TEST64("\x67\x01\x44\xbf\x99", "add dword ptr [edi+4*edi-0x67], eax");
    TEST("\x01\x45\x99", "add dword ptr [@bp-0x67], eax");
    TEST64("\x67\x01\x45\x99", "add dword ptr [ebp-0x67], eax");
    TEST("\x01\x46\x99", "add dword ptr [@si-0x67], eax");
    TEST64("\x67\x01\x46\x99", "add dword ptr [esi-0x67], eax");
    TEST("\x01\x47\x99", "add dword ptr [@di-0x67], eax");
    TEST64("\x67\x01\x47\x99", "add dword ptr [edi-0x67], eax");
    TEST("\x01\x80\x11\x22\x33\x44", "add dword ptr [@ax+0x44332211], eax");
    TEST64("\x67\x01\x80\x11\x22\x33\x44", "add dword ptr [eax+0x44332211], eax");
    TEST("\x01\x81\x11\x22\x33\x44", "add dword ptr [@cx+0x44332211], eax");
    TEST64("\x67\x01\x81\x11\x22\x33\x44", "add dword ptr [ecx+0x44332211], eax");
    TEST("\x01\x82\x11\x22\x33\x44", "add dword ptr [@dx+0x44332211], eax");
    TEST64("\x67\x01\x82\x11\x22\x33\x44", "add dword ptr [edx+0x44332211], eax");
    TEST("\x01\x83\x11\x22\x33\x44", "add dword ptr [@bx+0x44332211], eax");
    TEST64("\x67\x01\x83\x11\x22\x33\x44", "add dword ptr [ebx+0x44332211], eax");
    TEST("\x01\x84\x80\x11\x22\x33\x44", "add dword ptr [@ax+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x80\x11\x22\x33\x44", "add dword ptr [eax+4*eax+0x44332211], eax");
    TEST("\x01\x84\x81\x11\x22\x33\x44", "add dword ptr [@cx+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x81\x11\x22\x33\x44", "add dword ptr [ecx+4*eax+0x44332211], eax");
    TEST("\x01\x84\x82\x11\x22\x33\x44", "add dword ptr [@dx+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x82\x11\x22\x33\x44", "add dword ptr [edx+4*eax+0x44332211], eax");
    TEST("\x01\x84\x83\x11\x22\x33\x44", "add dword ptr [@bx+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x83\x11\x22\x33\x44", "add dword ptr [ebx+4*eax+0x44332211], eax");
    TEST("\x01\x84\x84\x11\x22\x33\x44", "add dword ptr [@sp+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x84\x11\x22\x33\x44", "add dword ptr [esp+4*eax+0x44332211], eax");
    TEST("\x01\x84\x85\x11\x22\x33\x44", "add dword ptr [@bp+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x85\x11\x22\x33\x44", "add dword ptr [ebp+4*eax+0x44332211], eax");
    TEST("\x01\x84\x86\x11\x22\x33\x44", "add dword ptr [@si+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x86\x11\x22\x33\x44", "add dword ptr [esi+4*eax+0x44332211], eax");
    TEST("\x01\x84\x87\x11\x22\x33\x44", "add dword ptr [@di+4*@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\x87\x11\x22\x33\x44", "add dword ptr [edi+4*eax+0x44332211], eax");
    TEST("\x01\x84\x88\x11\x22\x33\x44", "add dword ptr [@ax+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x88\x11\x22\x33\x44", "add dword ptr [eax+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x89\x11\x22\x33\x44", "add dword ptr [@cx+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x89\x11\x22\x33\x44", "add dword ptr [ecx+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x8a\x11\x22\x33\x44", "add dword ptr [@dx+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x8a\x11\x22\x33\x44", "add dword ptr [edx+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x8b\x11\x22\x33\x44", "add dword ptr [@bx+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x8b\x11\x22\x33\x44", "add dword ptr [ebx+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x8c\x11\x22\x33\x44", "add dword ptr [@sp+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x8c\x11\x22\x33\x44", "add dword ptr [esp+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x8d\x11\x22\x33\x44", "add dword ptr [@bp+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x8d\x11\x22\x33\x44", "add dword ptr [ebp+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x8e\x11\x22\x33\x44", "add dword ptr [@si+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x8e\x11\x22\x33\x44", "add dword ptr [esi+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x8f\x11\x22\x33\x44", "add dword ptr [@di+4*@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\x8f\x11\x22\x33\x44", "add dword ptr [edi+4*ecx+0x44332211], eax");
    TEST("\x01\x84\x90\x11\x22\x33\x44", "add dword ptr [@ax+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x90\x11\x22\x33\x44", "add dword ptr [eax+4*edx+0x44332211], eax");
    TEST("\x01\x84\x91\x11\x22\x33\x44", "add dword ptr [@cx+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x91\x11\x22\x33\x44", "add dword ptr [ecx+4*edx+0x44332211], eax");
    TEST("\x01\x84\x92\x11\x22\x33\x44", "add dword ptr [@dx+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x92\x11\x22\x33\x44", "add dword ptr [edx+4*edx+0x44332211], eax");
    TEST("\x01\x84\x93\x11\x22\x33\x44", "add dword ptr [@bx+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x93\x11\x22\x33\x44", "add dword ptr [ebx+4*edx+0x44332211], eax");
    TEST("\x01\x84\x94\x11\x22\x33\x44", "add dword ptr [@sp+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x94\x11\x22\x33\x44", "add dword ptr [esp+4*edx+0x44332211], eax");
    TEST("\x01\x84\x95\x11\x22\x33\x44", "add dword ptr [@bp+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x95\x11\x22\x33\x44", "add dword ptr [ebp+4*edx+0x44332211], eax");
    TEST("\x01\x84\x96\x11\x22\x33\x44", "add dword ptr [@si+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x96\x11\x22\x33\x44", "add dword ptr [esi+4*edx+0x44332211], eax");
    TEST("\x01\x84\x97\x11\x22\x33\x44", "add dword ptr [@di+4*@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\x97\x11\x22\x33\x44", "add dword ptr [edi+4*edx+0x44332211], eax");
    TEST("\x01\x84\x98\x11\x22\x33\x44", "add dword ptr [@ax+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x98\x11\x22\x33\x44", "add dword ptr [eax+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x99\x11\x22\x33\x44", "add dword ptr [@cx+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x99\x11\x22\x33\x44", "add dword ptr [ecx+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x9a\x11\x22\x33\x44", "add dword ptr [@dx+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x9a\x11\x22\x33\x44", "add dword ptr [edx+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x9b\x11\x22\x33\x44", "add dword ptr [@bx+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x9b\x11\x22\x33\x44", "add dword ptr [ebx+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x9c\x11\x22\x33\x44", "add dword ptr [@sp+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x9c\x11\x22\x33\x44", "add dword ptr [esp+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x9d\x11\x22\x33\x44", "add dword ptr [@bp+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x9d\x11\x22\x33\x44", "add dword ptr [ebp+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x9e\x11\x22\x33\x44", "add dword ptr [@si+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x9e\x11\x22\x33\x44", "add dword ptr [esi+4*ebx+0x44332211], eax");
    TEST("\x01\x84\x9f\x11\x22\x33\x44", "add dword ptr [@di+4*@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\x9f\x11\x22\x33\x44", "add dword ptr [edi+4*ebx+0x44332211], eax");
    TEST("\x01\x84\xa0\x11\x22\x33\x44", "add dword ptr [@ax+0x44332211], eax");
    TEST64("\x67\x01\x84\xa0\x11\x22\x33\x44", "add dword ptr [eax+0x44332211], eax");
    TEST("\x01\x84\xa1\x11\x22\x33\x44", "add dword ptr [@cx+0x44332211], eax");
    TEST64("\x67\x01\x84\xa1\x11\x22\x33\x44", "add dword ptr [ecx+0x44332211], eax");
    TEST("\x01\x84\xa2\x11\x22\x33\x44", "add dword ptr [@dx+0x44332211], eax");
    TEST64("\x67\x01\x84\xa2\x11\x22\x33\x44", "add dword ptr [edx+0x44332211], eax");
    TEST("\x01\x84\xa3\x11\x22\x33\x44", "add dword ptr [@bx+0x44332211], eax");
    TEST64("\x67\x01\x84\xa3\x11\x22\x33\x44", "add dword ptr [ebx+0x44332211], eax");
    TEST("\x01\x84\xa4\x11\x22\x33\x44", "add dword ptr [@sp+0x44332211], eax");
    TEST64("\x67\x01\x84\xa4\x11\x22\x33\x44", "add dword ptr [esp+0x44332211], eax");
    TEST("\x01\x84\xa5\x11\x22\x33\x44", "add dword ptr [@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xa5\x11\x22\x33\x44", "add dword ptr [ebp+0x44332211], eax");
    TEST("\x01\x84\xa6\x11\x22\x33\x44", "add dword ptr [@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xa6\x11\x22\x33\x44", "add dword ptr [esi+0x44332211], eax");
    TEST("\x01\x84\xa7\x11\x22\x33\x44", "add dword ptr [@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xa7\x11\x22\x33\x44", "add dword ptr [edi+0x44332211], eax");
    TEST("\x01\x84\xa8\x11\x22\x33\x44", "add dword ptr [@ax+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xa8\x11\x22\x33\x44", "add dword ptr [eax+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xa9\x11\x22\x33\x44", "add dword ptr [@cx+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xa9\x11\x22\x33\x44", "add dword ptr [ecx+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xaa\x11\x22\x33\x44", "add dword ptr [@dx+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xaa\x11\x22\x33\x44", "add dword ptr [edx+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xab\x11\x22\x33\x44", "add dword ptr [@bx+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xab\x11\x22\x33\x44", "add dword ptr [ebx+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xac\x11\x22\x33\x44", "add dword ptr [@sp+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xac\x11\x22\x33\x44", "add dword ptr [esp+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xad\x11\x22\x33\x44", "add dword ptr [@bp+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xad\x11\x22\x33\x44", "add dword ptr [ebp+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xae\x11\x22\x33\x44", "add dword ptr [@si+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xae\x11\x22\x33\x44", "add dword ptr [esi+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xaf\x11\x22\x33\x44", "add dword ptr [@di+4*@bp+0x44332211], eax");
    TEST64("\x67\x01\x84\xaf\x11\x22\x33\x44", "add dword ptr [edi+4*ebp+0x44332211], eax");
    TEST("\x01\x84\xb0\x11\x22\x33\x44", "add dword ptr [@ax+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb0\x11\x22\x33\x44", "add dword ptr [eax+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb1\x11\x22\x33\x44", "add dword ptr [@cx+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb1\x11\x22\x33\x44", "add dword ptr [ecx+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb2\x11\x22\x33\x44", "add dword ptr [@dx+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb2\x11\x22\x33\x44", "add dword ptr [edx+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb3\x11\x22\x33\x44", "add dword ptr [@bx+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb3\x11\x22\x33\x44", "add dword ptr [ebx+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb4\x11\x22\x33\x44", "add dword ptr [@sp+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb4\x11\x22\x33\x44", "add dword ptr [esp+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb5\x11\x22\x33\x44", "add dword ptr [@bp+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb5\x11\x22\x33\x44", "add dword ptr [ebp+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb6\x11\x22\x33\x44", "add dword ptr [@si+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb6\x11\x22\x33\x44", "add dword ptr [esi+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb7\x11\x22\x33\x44", "add dword ptr [@di+4*@si+0x44332211], eax");
    TEST64("\x67\x01\x84\xb7\x11\x22\x33\x44", "add dword ptr [edi+4*esi+0x44332211], eax");
    TEST("\x01\x84\xb8\x11\x22\x33\x44", "add dword ptr [@ax+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xb8\x11\x22\x33\x44", "add dword ptr [eax+4*edi+0x44332211], eax");
    TEST("\x01\x84\xb9\x11\x22\x33\x44", "add dword ptr [@cx+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xb9\x11\x22\x33\x44", "add dword ptr [ecx+4*edi+0x44332211], eax");
    TEST("\x01\x84\xba\x11\x22\x33\x44", "add dword ptr [@dx+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xba\x11\x22\x33\x44", "add dword ptr [edx+4*edi+0x44332211], eax");
    TEST("\x01\x84\xbb\x11\x22\x33\x44", "add dword ptr [@bx+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xbb\x11\x22\x33\x44", "add dword ptr [ebx+4*edi+0x44332211], eax");
    TEST("\x01\x84\xbc\x11\x22\x33\x44", "add dword ptr [@sp+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xbc\x11\x22\x33\x44", "add dword ptr [esp+4*edi+0x44332211], eax");
    TEST("\x01\x84\xbd\x11\x22\x33\x44", "add dword ptr [@bp+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xbd\x11\x22\x33\x44", "add dword ptr [ebp+4*edi+0x44332211], eax");
    TEST("\x01\x84\xbe\x11\x22\x33\x44", "add dword ptr [@si+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xbe\x11\x22\x33\x44", "add dword ptr [esi+4*edi+0x44332211], eax");
    TEST("\x01\x84\xbf\x11\x22\x33\x44", "add dword ptr [@di+4*@di+0x44332211], eax");
    TEST64("\x67\x01\x84\xbf\x11\x22\x33\x44", "add dword ptr [edi+4*edi+0x44332211], eax");
    TEST("\x01\x85\x11\x22\x33\x44", "add dword ptr [@bp+0x44332211], eax");
    TEST64("\x67\x01\x85\x11\x22\x33\x44", "add dword ptr [ebp+0x44332211], eax");
    TEST("\x01\x86\x11\x22\x33\x44", "add dword ptr [@si+0x44332211], eax");
    TEST64("\x67\x01\x86\x11\x22\x33\x44", "add dword ptr [esi+0x44332211], eax");
    TEST("\x01\x87\x11\x22\x33\x44", "add dword ptr [@di+0x44332211], eax");
    TEST64("\x67\x01\x87\x11\x22\x33\x44", "add dword ptr [edi+0x44332211], eax");
    TEST("\x01\xc0", "add eax, eax");
    TEST("\x01\xc1", "add ecx, eax");
    TEST("\x01\xc2", "add edx, eax");
    TEST("\x01\xc3", "add ebx, eax");
    TEST("\x01\xc4", "add esp, eax");
    TEST("\x01\xc5", "add ebp, eax");
    TEST("\x01\xc6", "add esi, eax");
    TEST("\x01\xc7", "add edi, eax");

    TEST("\x0f\xbc\xc0", "bsf eax, eax");
    TEST("\x66\x0f\xbc\xc0", "bsf ax, ax");
    TEST("\xf2\x0f\xbc\xc0", "bsf eax, eax");
    TEST("\x66\xf2\x0f\xbc\xc0", "bsf ax, ax");
    TEST("\x0f\x01\x00", "sgdt [@ax]");
    TEST("\x66\x0f\x01\x00", "sgdt [@ax]");
    TEST("\xf2\x0f\x01\x00", "sgdt [@ax]");
    TEST("\xf3\x0f\x01\x00", "sgdt [@ax]");
    TEST("\x04\x01", "add al, 0x1");
    TEST("\x66\x50", "push ax");
    TEST("\x50", "push @ax");
    TEST("\x66\x68\xff\xad", "pushw 0xadff");
    TEST3264("\x68\xff\xad\x90\xbc", "push 0xbc90adff", "push 0xffffffffbc90adff");
    TEST("\x66\x6a\xff", "pushw 0xffff");
    TEST3264("\x6a\xff", "push 0xffffffff", "push 0xffffffffffffffff");
    TEST32("\x60", "pushad");
    TEST32("\x66\x60", "pushaw");
    TEST("\xb0\xf0", "mov al, 0xf0");
    TEST("\xb1\xda", "mov cl, 0xda");
    TEST("\xb2\xff", "mov dl, 0xff");
    TEST("\xb3\x8d", "mov bl, 0x8d");
    TEST("\xb4\x5e", "mov ah, 0x5e");
    TEST64("\x40\xb4\x00", "mov spl, 0x0");
    TEST("\xb5\x74", "mov ch, 0x74");
    TEST64("\x40\xb5\xd0", "mov bpl, 0xd0");
    TEST("\xb6\xe5", "mov dh, 0xe5");
    TEST64("\x40\xb6\xf1", "mov sil, 0xf1");
    TEST("\xb7\xe8", "mov bh, 0xe8");
    TEST64("\x40\xb7\x31", "mov dil, 0x31");
    TEST("\x66\xb8\xf0\xf0", "mov ax, 0xf0f0");
    TEST("\xb8\xf0\xf0\xab\xff", "mov eax, 0xffabf0f0");
    TEST64("\x48\xb8\xf0\xf0\xab\xff\x00\x12\x12\xcd", "mov rax, 0xcd121200ffabf0f0");
    TEST64("\xcd\x80", "int 0x80");

    // Test FD/TD encoding
    TEST32("\xa0\x44\x33\x22\x11", "mov al, byte ptr [0x11223344]");
    TEST64("\xa0\x88\x77\x66\x55\x44\x33\x22\x11", "mov al, byte ptr [0x1122334455667788]");
    TEST32("\x67\xa0\x22\x11", "mov al, byte ptr [0x1122]");
    TEST64("\x67\xa0\x44\x33\x22\x11", "mov al, byte ptr [0x11223344]");
    TEST32("\xa1\x44\x33\x22\x11", "mov eax, dword ptr [0x11223344]");
    TEST64("\xa1\x88\x77\x66\x55\x44\x33\x22\x11", "mov eax, dword ptr [0x1122334455667788]");
    TEST32("\x67\xa1\x22\x11", "mov eax, dword ptr [0x1122]");
    TEST64("\x67\xa1\x44\x33\x22\x11", "mov eax, dword ptr [0x11223344]");
    TEST32("\x66\xa1\x44\x33\x22\x11", "mov ax, word ptr [0x11223344]");
    TEST64("\x66\xa1\x88\x77\x66\x55\x44\x33\x22\x11", "mov ax, word ptr [0x1122334455667788]");
    TEST32("\x66\x67\xa1\x22\x11", "mov ax, word ptr [0x1122]");
    TEST64("\x66\x67\xa1\x44\x33\x22\x11", "mov ax, word ptr [0x11223344]");
    TEST64("\x48\xa1\x88\x77\x66\x55\x44\x33\x22\x11", "mov rax, qword ptr [0x1122334455667788]");
    TEST64("\x67\x48\xa1\x44\x33\x22\x11", "mov rax, qword ptr [0x11223344]");
    TEST32("\xa2\x44\x33\x22\x11", "mov byte ptr [0x11223344], al");
    TEST64("\xa2\x88\x77\x66\x55\x44\x33\x22\x11", "mov byte ptr [0x1122334455667788], al");
    TEST32("\x67\xa2\x22\x11", "mov byte ptr [0x1122], al");
    TEST64("\x67\xa2\x44\x33\x22\x11", "mov byte ptr [0x11223344], al");
    TEST32("\xa3\x44\x33\x22\x11", "mov dword ptr [0x11223344], eax");
    TEST64("\xa3\x88\x77\x66\x55\x44\x33\x22\x11", "mov dword ptr [0x1122334455667788], eax");
    TEST32("\x67\xa3\x22\x11", "mov dword ptr [0x1122], eax");
    TEST64("\x67\xa3\x44\x33\x22\x11", "mov dword ptr [0x11223344], eax");
    TEST32("\x66\xa3\x44\x33\x22\x11", "mov word ptr [0x11223344], ax");
    TEST64("\x66\xa3\x88\x77\x66\x55\x44\x33\x22\x11", "mov word ptr [0x1122334455667788], ax");
    TEST32("\x66\x67\xa3\x22\x11", "mov word ptr [0x1122], ax");
    TEST64("\x66\x67\xa3\x44\x33\x22\x11", "mov word ptr [0x11223344], ax");
    TEST64("\x48\xa3\x88\x77\x66\x55\x44\x33\x22\x11", "mov qword ptr [0x1122334455667788], rax");
    TEST64("\x67\x48\xa3\x44\x33\x22\x11", "mov qword ptr [0x11223344], rax");
    TEST32("\xa0\x44\x33\x22", "PARTIAL");
    TEST64("\xa0\x88\x77\x66\x55\x44\x33\x22", "PARTIAL");
    TEST32("\x67\xa0\x22", "PARTIAL");
    TEST64("\x67\xa0\x44\x33\x22", "PARTIAL");

    TEST("\x66\xc8\x00\x00\x00", "enterw 0x0, 0x0");
    TEST("\x66\xc8\x00\x0f\x00", "enterw 0xf00, 0x0");
    TEST("\x66\xc8\x00\x00\x01", "enterw 0x0, 0x1");
    TEST32("\xc8\x00\x00\x00", "enter 0x0, 0x0");
    TEST32("\xc8\x00\x0f\x00", "enter 0xf00, 0x0");
    TEST32("\xc8\x00\x00\x01", "enter 0x0, 0x1");
    TEST64("\xc8\x00\x00\x00", "enter 0x0, 0x0");
    TEST64("\xc8\x00\x0f\x00", "enter 0xf00, 0x0");
    TEST64("\xc8\x00\x00\x01", "enter 0x0, 0x1");

    TEST64("\xd3\xe0", "shl eax, cl");
    TEST64("\xd0\x3e", "sar byte ptr [rsi], 0x1");
    TEST64("\x0f\xa5\xd0", "shld eax, edx, cl");

    TEST("\x69\xC7\x08\x01\x00\x00", "imul eax, edi, 0x108");
    TEST("\x6B\xC7\x08", "imul eax, edi, 0x8");
    TEST("\x6B\xC7\xff", "imul eax, edi, 0xffffffff");

    TEST("\x0f\x38\xf0\xd1", "UD"); // MOVBE doesn't allow register moves
    TEST("\x0f\x38\xf0\x11", "movbe edx, dword ptr [@cx]");
    TEST("\x66\x0f\x38\xf0\x11", "movbe dx, word ptr [@cx]");
    TEST64("\x48\x0f\x38\xf0\x01", "movbe rax, qword ptr [rcx]");
    TEST("\xf2\x0f\x38\xf0\xd1", "crc32 edx, cl");
    TEST("\xf2\x66\x0f\x38\xf1\xd1", "crc32 edx, cx");
    TEST("\xf2\x0f\x38\xf1\xd1", "crc32 edx, ecx");
    TEST64("\xf2\x48\x0f\x38\xf1\xd1", "crc32 edx, rcx");
    TEST64("\xf2\x4c\x0f\x38\xf1\xd1", "crc32 r10d, rcx");

    TEST("\x8d\x00", "lea eax, [@ax]");
    TEST("\x8d\xc0", "UD");

    TEST("\x00\xc0", "add al, al");
    TEST("\x00\xc1", "add cl, al");
    TEST("\x00\xd0", "add al, dl");
    TEST("\x00\xff", "add bh, bh");
    TEST("\x01\xc0", "add eax, eax");
    TEST("\x01\xc1", "add ecx, eax");
    TEST("\x01\xd0", "add eax, edx");
    TEST("\x01\xff", "add edi, edi");
    TEST("\x02\xc0", "add al, al");
    TEST("\x02\xc1", "add al, cl");
    TEST("\x02\xd0", "add dl, al");
    TEST("\x02\xff", "add bh, bh");
    TEST("\x03\xc0", "add eax, eax");
    TEST("\x03\xc1", "add eax, ecx");
    TEST("\x03\xd0", "add edx, eax");
    TEST("\x03\xff", "add edi, edi");
    TEST("\x05\x01\x00\x00\x80", "add eax, 0x80000001");
    TEST64("\x48\x05\x01\x00\x00\x80", "add rax, 0xffffffff80000001");

    TEST32("\x40", "inc eax");
    TEST32("\x43", "inc ebx");
    TEST32("\x66\x47", "inc di");
    TEST("\xfe\xc0", "inc al");
    TEST("\xfe\xc4", "inc ah");
    TEST("\xff\xc0", "inc eax");
    TEST("\xff\xc4", "inc esp");
    TEST("\xff\x00", "inc dword ptr [@ax]");
    TEST("\xf0\xff\x00", "lock inc dword ptr [@ax]");
    TEST("\x66\xff\xc0", "inc ax");
    TEST("\x66\xff\xc4", "inc sp");
    TEST64("\x48\xff\xc0", "inc rax");
    TEST64("\x48\xff\xc4", "inc rsp");
    TEST64("\x49\xff\xc7", "inc r15");

    TEST32("\xe9\x00\x00\x00\x00", "jmp 0x5");
    TEST32("\x66\xe9\x01\x00", "jmpw 0x5");
    TEST64("\xe9\x00\x00\x00\x00", "jmp 0x5");
    TEST64("\x66\xe9\x00\x00\x00\x00", "jmp 0x6");
    TEST64("\x66\xeb\x00", "jmp 0x3");
    TEST64("\x66\xeb\xff", "jmp 0x2");
    TEST("\x66\xe9\x00", "PARTIAL");
    TEST("\x66\xe9", "PARTIAL");
    TEST32("\xc7\xf8\xd3\x9c\xff\xff", "xbegin 0xffff9cd9");
    TEST32("\x66\xc7\xf8\xd3\x9c", "xbegin 0xffff9cd8");
    TEST64("\xc7\xf8\xd3\x9c\xff\xff", "xbegin 0xffffffffffff9cd9");
    TEST64("\x66\xc7\xf8\xd3\x9c", "xbegin 0xffffffffffff9cd8");


    TEST("\xa5", "movsd");
    TEST("\x66\xa5", "movsw");
    TEST("\xf3\xa5", "rep movsd");
    TEST("\xf3\x66\xa5", "rep movsw");
    TEST("\xf3\xae", "rep scasb");
    TEST("\xf2\xae", "repnz scasb");
    TEST("\xf3\x66\xae", "rep scasb");
    TEST("\xf2\x66\xae", "repnz scasb");
    TEST("\xf3\xaf", "rep scasd");
    TEST("\xf2\xaf", "repnz scasd");
    TEST("\xf3\x66\xaf", "rep scasw");
    TEST("\xf2\x66\xaf", "repnz scasw");
    TEST64("\xf3\x48\xaf", "rep scasq");
    TEST64("\xf2\x48\xaf", "repnz scasq");
    TEST64("\xf3\x66\x48\xaf", "rep scasq");
    TEST64("\xf2\x66\x48\xaf", "repnz scasq");

    TEST("\x66\x0f\xbe\xc2", "movsx ax, dl");
    TEST("\x0f\xbe\xc2", "movsx eax, dl");
    TEST("\x0f\xbe\xc4", "movsx eax, ah");
    TEST64("\x40\x0f\xbe\xc4", "movsx eax, spl");
    TEST("\x0f\xbf\xc2", "movsx eax, dx");
    TEST64("\x48\x0f\xbf\xc2", "movsx rax, dx");
    TEST64("\x48\x63\xc2", "movsx rax, edx");

    TEST32("\x66\xc3", "retw");
    TEST32("\x66\xc2\x00\x00", "retw 0x0");
    TEST32("\x66\xc2\x0d\x00", "retw 0xd");
    TEST32("\x66\xc2\x0d\xff", "retw 0xff0d");
    TEST64("\x66\xc3", "ret");
    TEST64("\x66\xc2\x00\x00", "ret 0x0");
    TEST64("\x66\xc2\x0d\x00", "ret 0xd");
    TEST64("\x66\xc2\x0d\xff", "ret 0xff0d");
    TEST32("\xc3", "ret");
    TEST32("\xc2\x00\x00", "ret 0x0");
    TEST32("\xc2\x0d\x00", "ret 0xd");
    TEST32("\xc2\x0d\xff", "ret 0xff0d");
    TEST64("\xc3", "ret");
    TEST64("\xc2\x00\x00", "ret 0x0");
    TEST64("\xc2\x0d\x00", "ret 0xd");
    TEST64("\xc2\x0d\xff", "ret 0xff0d");
    TEST("\xca\x00\x00", "retfd 0x0");
    TEST("\xca\x0d\x00", "retfd 0xd");
    TEST("\xca\x0d\xff", "retfd 0xff0d");
    TEST("\xcb", "retfd");
    TEST("\x66\xca\x00\x00", "retfw 0x0");
    TEST("\x66\xca\x0d\x00", "retfw 0xd");
    TEST("\x66\xca\x0d\xff", "retfw 0xff0d");
    TEST("\x66\xcb", "retfw");
    TEST64("\x48\xca\x00\x00", "retfq 0x0");
    TEST64("\x48\xca\x0d\x00", "retfq 0xd");
    TEST64("\x48\xca\x0d\xff", "retfq 0xff0d");
    TEST64("\x48\xcb", "retfq");

    // BMI1
    TEST("\xf3\x0f\xbc\xc0", "tzcnt eax, eax");
    TEST("\x66\xf3\x0f\xbc\xc0", "tzcnt ax, ax");
    TEST64("\xf3\x48\x0f\xbc\xc0", "tzcnt rax, rax");
    TEST("\xf3\x0f\xbd\xc0", "lzcnt eax, eax");
    TEST("\x66\xf3\x0f\xbd\xc0", "lzcnt ax, ax");
    TEST64("\xf3\x48\x0f\xbd\xc0", "lzcnt rax, rax");
    TEST3264("\xc4\xc2\x18\xf2\xc7", "andn eax, esp, edi", "andn eax, r12d, r15d");
    TEST3264("\xc4\xc2\x98\xf2\xc7", "andn eax, esp, edi", "andn rax, r12, r15");
    TEST64("\xc4\x42\x18\xf2\xc7", "andn r8d, r12d, r15d");
    TEST64("\xc4\x42\x98\xf2\xc7", "andn r8, r12, r15");
    TEST("\xc4\xe2\x78\xf3\xca", "blsr eax, edx");
    TEST("\xc4\xe2\x78\xf3\x08", "blsr eax, dword ptr [@ax]");
    TEST("\xc4\xe2\xf8\xf3\xca", "blsr @ax, @dx");
    TEST3264("\xc4\xe2\xf8\xf3\x08", "blsr eax, dword ptr [eax]", "blsr rax, qword ptr [rax]");
    TEST3264("\xc4\xc2\x38\xf3\xc9", "blsr eax, ecx", "blsr r8d, r9d");
    TEST3264("\xc4\xc2\xb8\xf3\xc9", "blsr eax, ecx", "blsr r8, r9");
    TEST3264("\xc4\xe2\x38\xf3\xc9", "blsr eax, ecx", "blsr r8d, ecx");
    TEST3264("\xc4\xe2\xb8\xf3\xc9", "blsr eax, ecx", "blsr r8, rcx");
    TEST3264("\xc4\xc2\x78\xf3\xc9", "blsr eax, ecx", "blsr eax, r9d");
    TEST3264("\xc4\xc2\xf8\xf3\xc9", "blsr eax, ecx", "blsr rax, r9");
    TEST("\xc4\xe2\x78\xf3\xd2", "blsmsk eax, edx");
    TEST("\xc4\xe2\x78\xf3\x10", "blsmsk eax, dword ptr [@ax]");
    TEST("\xc4\xe2\xf8\xf3\xd2", "blsmsk @ax, @dx");
    TEST3264("\xc4\xe2\xf8\xf3\x10", "blsmsk eax, dword ptr [eax]", "blsmsk rax, qword ptr [rax]");
    TEST("\xc4\xe2\x78\xf3\xda", "blsi eax, edx");
    TEST("\xc4\xe2\x78\xf3\x18", "blsi eax, dword ptr [@ax]");
    TEST("\xc4\xe2\xf8\xf3\xda", "blsi @ax, @dx");
    TEST3264("\xc4\xe2\xf8\xf3\x18", "blsi eax, dword ptr [eax]", "blsi rax, qword ptr [rax]");
    TEST3264("\xc4\xc2\x18\xf7\xc7", "bextr eax, edi, esp", "bextr eax, r15d, r12d");
    TEST3264("\xc4\xc2\x98\xf7\xc7", "bextr eax, edi, esp", "bextr rax, r15, r12");
    TEST64("\xc4\x42\x18\xf7\xc7", "bextr r8d, r15d, r12d");
    TEST64("\xc4\x42\x98\xf7\xc7", "bextr r8, r15, r12");

    // NFx/66+F2/F3 combinations
    TEST("\x0f\xc7\xf0", "rdrand eax");
    TEST64("\x48\x0f\xc7\xf0", "rdrand rax");
    TEST("\x66\x0f\xc7\xf0", "rdrand ax");
    TEST64("\x66\x48\x0f\xc7\xf0", "rdrand rax");
    TEST("\x0f\xc7\xf8", "rdseed eax");
    TEST64("\x48\x0f\xc7\xf8", "rdseed rax");
    TEST("\x66\x0f\xc7\xf8", "rdseed ax");
    TEST64("\x66\x48\x0f\xc7\xf8", "rdseed rax");
    TEST32("\xf3\x0f\xc7\xf8", "rdpid eax");
    TEST32("\x66\xf3\x0f\xc7\xf8", "rdpid eax");
    TEST32("\xf3\x66\x0f\xc7\xf8", "rdpid eax");
    TEST64("\xf3\x0f\xc7\xf8", "rdpid rax");
    TEST64("\x66\xf3\x0f\xc7\xf8", "rdpid rax");
    TEST64("\xf3\x66\x0f\xc7\xf8", "rdpid rax");
    TEST64("\xf3\x0f\xc7\x00", "UD");
    TEST64("\x0f\xc7\x30", "vmptrld qword ptr [rax]");
    TEST64("\x66\x0f\xc7\x30", "vmclear qword ptr [rax]");
    TEST64("\xf3\x0f\xc7\x30", "vmxon qword ptr [rax]");
    TEST("\x0f\x78\xc1", "vmread @cx, @ax");
    TEST("\x0f\x79\xc1", "vmwrite @ax, @cx");

    TEST64("\x0f\x09", "wbinvd");
    TEST64("\xf3\x0f\x09", "wbnoinvd");
    TEST("\x66\x0f\x38\x82\x01", "invpcid @ax, xmmword ptr [@cx]");
    TEST("\x66\x0f\x38\x80\x02", "invept @ax, xmmword ptr [@dx]");
    TEST("\x66\x0f\x38\x81\x02", "invvpid @ax, xmmword ptr [@dx]");
    TEST("\x66\x0f\x38\xf8\x01", "movdir64b @ax, zmmword ptr [@cx]");
    // TODO: MOVDIR64B first operand has address size.
    // TEST32("\x67\x66\x0f\x38\xf8\x01", "movdir64b ax, zmmword ptr [cx]");
    // TEST64("\x67\x66\x0f\x38\xf8\x01", "movdir64b eax, zmmword ptr [ecx]");
    TEST("\x0f\x30", "wrmsr");
    TEST("\x0f\x32", "rdmsr");
    TEST("\x0f\x01\xc6", "wrmsrns");
    TEST3264("\xf2\x0f\x01\xc6", "UD", "rdmsrlist");
    TEST3264("\xf3\x0f\x01\xc6", "UD", "wrmsrlist");
    TEST3264("\xc4\xe7\x7b\xf6\xc1\x10\x20\x30\x40", "UD", "rdmsr rcx, 0x40302010");
    TEST3264("\xc4\xe7\x7a\xf6\xc1\x10\x20\x30\x40", "UD", "wrmsrns 0x40302010, rcx");
    TEST3264("\xf2\x0f\x38\xf8\xc1", "UD", "urdmsr rcx, rax");
    TEST3264("\xf3\x0f\x38\xf8\xc1", "UD", "uwrmsr rcx, rax");
    TEST3264("\xc4\xe7\x7b\xf8\xc1\x10\x20\x30\x40", "UD", "urdmsr rcx, 0x40302010");
    TEST3264("\xc4\xe7\x7a\xf8\xc1\x10\x20\x30\x40", "UD", "uwrmsr 0x40302010, rcx");

    TEST("\x0f\x38\xfc\xc1", "UD"); // Must be memory operand
    TEST("\x0f\x38\xfc\x01", "aadd dword ptr [@cx], eax");
    TEST64("\x48\x0f\x38\xfc\x01", "aadd qword ptr [rcx], rax");
    TEST("\x66\x0f\x38\xfc\xc1", "UD"); // Must be memory operand
    TEST("\x66\x0f\x38\xfc\x01", "aand dword ptr [@cx], eax");
    TEST64("\x66\x48\x0f\x38\xfc\x01", "aand qword ptr [rcx], rax");
    TEST("\xf3\x0f\x38\xfc\xc1", "UD"); // Must be memory operand
    TEST("\xf3\x0f\x38\xfc\x01", "axor dword ptr [@cx], eax");
    TEST64("\xf3\x48\x0f\x38\xfc\x01", "axor qword ptr [rcx], rax");
    TEST("\xf2\x0f\x38\xfc\xc1", "UD"); // Must be memory operand
    TEST("\xf2\x0f\x38\xfc\x01", "aor dword ptr [@cx], eax");
    TEST64("\xf2\x48\x0f\x38\xfc\x01", "aor qword ptr [rcx], rax");

    TEST64("\xc4\xe2\x61\xe0\x08", "cmpoxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe0\x08", "cmpoxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe1\x08", "cmpnoxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe1\x08", "cmpnoxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe2\x08", "cmpbxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe2\x08", "cmpbxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe3\x08", "cmpnbxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe3\x08", "cmpnbxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe4\x08", "cmpzxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe4\x08", "cmpzxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe5\x08", "cmpnzxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe5\x08", "cmpnzxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe6\x08", "cmpbexadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe6\x08", "cmpbexadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe7\x08", "cmpnbexadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe7\x08", "cmpnbexadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe8\x08", "cmpsxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe8\x08", "cmpsxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xe9\x08", "cmpnsxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xe9\x08", "cmpnsxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xea\x08", "cmppxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xea\x08", "cmppxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xeb\x08", "cmpnpxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xeb\x08", "cmpnpxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xec\x08", "cmplxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xec\x08", "cmplxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xed\x08", "cmpnlxadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xed\x08", "cmpnlxadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xee\x08", "cmplexadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xee\x08", "cmplexadd qword ptr [rax], rcx, rbx");
    TEST64("\xc4\xe2\x61\xef\x08", "cmpnlexadd dword ptr [rax], ecx, ebx");
    TEST64("\xc4\xe2\xe1\xef\x08", "cmpnlexadd qword ptr [rax], rcx, rbx");

    TEST("\x0f\xae\xe8", "lfence");
    TEST("\x0f\xae\xe9", "lfence");
    TEST("\x0f\xae\xef", "lfence");
    TEST("\x0f\xae\xf0", "mfence");
    TEST("\x0f\xae\xf7", "mfence");
    TEST("\x0f\xae\xf8", "sfence");
    TEST("\x0f\xae\xf9", "sfence");
    TEST("\x0f\xae\xff", "sfence");

    TEST("\x0f\x6e\xc0", "movd mm0, eax");
    TEST64("\x48\x0f\x6e\xc0", "movq mm0, rax");
    TEST("\x0f\x70\xc0\x85", "pshufw mm0, mm0, 0x85");

    TEST("\x0f\x58\xc1", "addps xmm0, xmm1");
    TEST64("\x40\x0f\x58\xc1", "addps xmm0, xmm1");
    TEST64("\x41\x0f\x58\xc1", "addps xmm0, xmm9");
    TEST64("\x42\x0f\x58\xc1", "addps xmm0, xmm1"); // REX.X ignored
    TEST64("\x43\x0f\x58\xc1", "addps xmm0, xmm9"); // REX.X ignored
    TEST64("\x44\x0f\x58\xc1", "addps xmm8, xmm1");
    TEST64("\x45\x0f\x58\xc1", "addps xmm8, xmm9");
    TEST64("\x46\x0f\x58\xc1", "addps xmm8, xmm1"); // REX.X ignored
    TEST64("\x47\x0f\x58\xc1", "addps xmm8, xmm9"); // REX.X ignored
    TEST("\xf3\x0f\x2a\xc1", "cvtsi2ss xmm0, ecx");
    TEST("\xf3\x66\x0f\x2a\xc1", "cvtsi2ss xmm0, ecx");
    TEST("\x66\xf3\x0f\x2a\xc1", "cvtsi2ss xmm0, ecx");
    TEST64("\xf3\x48\x0f\x2a\xc1", "cvtsi2ss xmm0, rcx");
    TEST64("\x66\xf3\x48\x0f\x2a\xc1", "cvtsi2ss xmm0, rcx");
    TEST64("\x66\x0f\x50\xc1", "movmskpd rax, xmm1");
    TEST("\x66\x0f\xc6\xc0\x01", "shufpd xmm0, xmm0, 0x1");
    TEST("\x66\x0f\x71\xd0\x01", "psrlw xmm0, 0x1");
    TEST("\x66\x0f\x3a\x20\xc4\x01", "pinsrb xmm0, spl, 0x1");
    TEST("\x66\x0f\x71\x10\x01", "UD");
    TEST("\x66\x0f\x78\xc0\xab\xcd", "extrq xmm0, 0xab, 0xcd");
    TEST("\xf2\x0f\x78\xc1\xab\xcd", "insertq xmm0, xmm1, 0xab, 0xcd");
    TEST("\x66\x0f\x38\x20\xc1", "pmovsxbw xmm0, xmm1");
    TEST("\x66\x0f\x38\x20\x00", "pmovsxbw xmm0, qword ptr [@ax]");
    TEST("\x66\x0f\x38\x21\xc1", "pmovsxbd xmm0, xmm1");
    TEST("\x66\x0f\x38\x21\x00", "pmovsxbd xmm0, dword ptr [@ax]");
    TEST("\x66\x0f\x38\x22\xc1", "pmovsxbq xmm0, xmm1");
    TEST("\x66\x0f\x38\x22\x00", "pmovsxbq xmm0, word ptr [@ax]");
    TEST("\x66\x0f\x38\x23\xc1", "pmovsxwd xmm0, xmm1");
    TEST("\x66\x0f\x38\x23\x00", "pmovsxwd xmm0, qword ptr [@ax]");
    TEST("\x66\x0f\x38\x24\xc1", "pmovsxwq xmm0, xmm1");
    TEST("\x66\x0f\x38\x24\x00", "pmovsxwq xmm0, dword ptr [@ax]");
    TEST("\x66\x0f\x38\x25\xc1", "pmovsxdq xmm0, xmm1");
    TEST("\x66\x0f\x38\x25\x00", "pmovsxdq xmm0, qword ptr [@ax]");
    TEST("\x66\x0f\x38\x30\xc1", "pmovzxbw xmm0, xmm1");
    TEST("\x66\x0f\x38\x30\x00", "pmovzxbw xmm0, qword ptr [@ax]");
    TEST("\x66\x0f\x38\x31\xc1", "pmovzxbd xmm0, xmm1");
    TEST("\x66\x0f\x38\x31\x00", "pmovzxbd xmm0, dword ptr [@ax]");
    TEST("\x66\x0f\x38\x32\xc1", "pmovzxbq xmm0, xmm1");
    TEST("\x66\x0f\x38\x32\x00", "pmovzxbq xmm0, word ptr [@ax]");
    TEST("\x66\x0f\x38\x33\xc1", "pmovzxwd xmm0, xmm1");
    TEST("\x66\x0f\x38\x33\x00", "pmovzxwd xmm0, qword ptr [@ax]");
    TEST("\x66\x0f\x38\x34\xc1", "pmovzxwq xmm0, xmm1");
    TEST("\x66\x0f\x38\x34\x00", "pmovzxwq xmm0, dword ptr [@ax]");
    TEST("\x66\x0f\x38\x35\xc1", "pmovzxdq xmm0, xmm1");
    TEST("\x66\x0f\x38\x35\x00", "pmovzxdq xmm0, qword ptr [@ax]");

    TEST("\xc4", "PARTIAL");
    TEST("\xc5", "PARTIAL");
    TEST32("\xc4\xc0", "PARTIAL");
    TEST64("\xc4\x00", "PARTIAL");
    TEST32("\xc5\xc0", "PARTIAL");
    TEST64("\xc5\x00", "PARTIAL");
    TEST("\xc4\xe0\x78\x10\xc0", "UD"); // VEX map 0
    TEST("\xc4\xe1\x78\x10\xc0", "vmovups xmm0, xmm0"); // VEX map 1
    TEST("\xc4\xe2\x78\x10\xc0", "UD"); // VEX map 2
    TEST("\xc4\xe3\x78\x10\xc0\x00", "UD"); // VEX map 3
    TEST("\xc4\xe4\x78\x10\xc0", "UD"); // VEX map 4
    TEST("\xc4\xe5\x78\x10\xc0", "UD"); // VEX map 5
    TEST("\xc4\xe6\x78\x10\xc0", "UD"); // VEX map 6
    TEST("\xc4\xe7\x78\x10\xc0", "UD"); // VEX map 7
    TEST("\xc4\xe8\x78\x10\xc0", "UD"); // VEX map 8
    TEST("\xc4\xe9\x78\x10\xc0", "UD"); // VEX map 9
    TEST("\xc4\xea\x78\x10\xc0", "UD"); // VEX map 10
    TEST("\xc4\xeb\x78\x10\xc0", "UD"); // VEX map 11
    TEST("\xc4\xec\x78\x10\xc0", "UD"); // VEX map 12
    TEST("\xc4\xed\x78\x10\xc0", "UD"); // VEX map 13
    TEST("\xc4\xee\x78\x10\xc0", "UD"); // VEX map 14
    TEST("\xc4\xef\x78\x10\xc0", "UD"); // VEX map 15
    TEST("\xc4\xf0\x78\x10\xc0", "UD"); // VEX map 16
    TEST("\xc4\xf1\x78\x10\xc0", "UD"); // VEX map 17
    TEST("\xc4\xf2\x78\x10\xc0", "UD"); // VEX map 18
    TEST("\xc4\xf3\x78\x10\xc0", "UD"); // VEX map 19
    TEST("\xc4\xf4\x78\x10\xc0", "UD"); // VEX map 20
    TEST("\xc4\xf5\x78\x10\xc0", "UD"); // VEX map 21
    TEST("\xc4\xf6\x78\x10\xc0", "UD"); // VEX map 22
    TEST("\xc4\xf7\x78\x10\xc0", "UD"); // VEX map 23
    TEST("\xc4\xf8\x78\x10\xc0", "UD"); // VEX map 24
    TEST("\xc4\xf9\x78\x10\xc0", "UD"); // VEX map 25
    TEST("\xc4\xfa\x78\x10\xc0", "UD"); // VEX map 26
    TEST("\xc4\xfb\x78\x10\xc0", "UD"); // VEX map 27
    TEST("\xc4\xfc\x78\x10\xc0", "UD"); // VEX map 28
    TEST("\xc4\xfd\x78\x10\xc0", "UD"); // VEX map 29
    TEST("\xc4\xfe\x78\x10\xc0", "UD"); // VEX map 30
    TEST("\xc4\xff\x78\x10\xc0", "UD"); // VEX map 31
    TEST32("\xc4\x00", "les eax, fword ptr [eax]");
    TEST32("\xc5\x00", "lds eax, fword ptr [eax]");
    TEST("\x0f\xb2\x00", "lss eax, fword ptr [@ax]");
    TEST64("\x48\x0f\xb2\x00", "lss rax, tbyte ptr [rax]");
    TEST("\x0f\xb4\x00", "lfs eax, fword ptr [@ax]");
    TEST64("\x48\x0f\xb4\x00", "lfs rax, tbyte ptr [rax]");
    TEST("\x0f\xb5\x00", "lgs eax, fword ptr [@ax]");
    TEST64("\x48\x0f\xb5\x00", "lgs rax, tbyte ptr [rax]");
    TEST("\xc5\xf2\x2a\xc0", "vcvtsi2ss xmm0, xmm1, eax");
    TEST("\xc4\xe1\xf2\x2a\xc0", "vcvtsi2ss xmm0, xmm1, @ax"); // VEX.W ignored
    TEST("\xf3\xc5\xf2\x2a\xc0", "UD"); // VEX+REP
    TEST("\xf2\xc5\xf2\x2a\xc0", "UD"); // VEX+REPNZ
    TEST("\xf2\xf3\xc5\xf2\x2a\xc0", "UD"); // VEX+REP+REPNZ
    TEST("\x66\xc5\xf2\x2a\xc0", "UD"); // VEX+66
    TEST("\xf0\xc5\xf2\x2a\xc0", "UD"); // VEX+LOCK
    TEST64("\x40\xc5\xf2\x2a\xc0", "UD"); // VEX+REX
    TEST64("\x40\x26\xc5\xf2\x2a\xc0", "vcvtsi2ss xmm0, xmm1, eax"); // VEX+REX, but REX doesn't precede VEX

    TEST("\xd9\x00", "fld dword ptr [@ax]");
    TEST("\xdd\x00", "fld qword ptr [@ax]");
    TEST("\xdb\x28", "fld tbyte ptr [@ax]");
    TEST("\xd9\xc1", "fld st(1)");
    TEST("\xdf\xe9", "fucomip st(0), st(1)");
    TEST64("\x45\xdf\xe9", "fucomip st(0), st(1)"); // REX.RB are ignored.

    TEST("\xf3\x0f\x7e\x5c\x24\x08", "movq xmm3, qword ptr [@sp+0x8]");
    TEST3264("\xc4\xe1\x00\x58\xc1", "vaddps xmm0, xmm7, xmm1", "vaddps xmm0, xmm15, xmm1"); // MSB in vvvv ignored
    TEST3264("\xc4\xc1\x78\x58\xc0", "vaddps xmm0, xmm0, xmm0", "vaddps xmm0, xmm0, xmm8"); // VEX.B ignored in 32-bit
    TEST("\xc5\xf9\x6e\xc8", "vmovd xmm1, eax");
    TEST64("\xc4\xe1\xf9\x6e\xc8", "vmovq xmm1, rax");
    TEST32("\xc4\xe1\xf9\x6e\xc8", "vmovd xmm1, eax");
    TEST("\xc5\xf9\x7e\xc8", "vmovd eax, xmm1");
    TEST64("\xc4\xe1\xf9\x7e\xc8", "vmovq rax, xmm1");
    TEST32("\xc4\xe1\xf9\x7e\xc8", "vmovd eax, xmm1");
    TEST("\xc5\xf2\x10\xc2", "vmovss xmm0, xmm1, xmm2");
    TEST("\xc5\xf6\x10\xc2", "vmovss xmm0, xmm1, xmm2"); // VEX.L=1
    TEST("\xc5\xfa\x10\x04\x25\x34\x12\x00\x00", "vmovss xmm0, dword ptr [0x1234]");
    TEST("\xc5\xf2\x10\x04\x25\x34\x12\x00\x00", "UD"); // VEX.vvvv != 0
    TEST("\xc5\xfa\x11\x04\x25\x34\x12\x00\x00", "vmovss dword ptr [0x1234], xmm0");
    TEST("\xc5\xf2\x11\x04\x25\x34\x12\x00\x00", "UD"); // VEX.vvvv != 0
    TEST("\xc5\xf2\x2a\xc0", "vcvtsi2ss xmm0, xmm1, eax");
    TEST("\xc4\xe1\xf2\x2a\xc0", "vcvtsi2ss xmm0, xmm1, @ax");
    TEST("\xc5\xf8\x53\xc0", "vrcpps xmm0, xmm0");
    TEST("\xc5\xf9\xf7\xc1", "vmaskmovdqu xmm0, xmm1");
    TEST("\xc5\xf9\xf7\x00", "UD"); // must have memory operand
    TEST("\xc5\xfd\xf7\xc1", "UD"); // VEX.L != 0
    TEST64("\xc5\x07\xd0\x02", "vaddsubps ymm8, ymm15, ymmword ptr [rdx]");
    TEST("\xc4\xc3\x6d\x09\xd9\x85", "UD"); // VEX.vvvv != 0
    TEST3264("\xc4\xc3\x7d\x09\xd9\x85", "vroundpd ymm3, ymm1, 0x85", "vroundpd ymm3, ymm9, 0x85");
    TEST("\xc5\xff\xf0\xd1", "UD"); // must have memory operand
    TEST("\xc5\xff\xf0\x11", "vlddqu ymm2, ymmword ptr [@cx]");

    // VMOVDDUP with L0 has smaller second operand size.
    TEST("\xf2\x0f\x12\x08", "movddup xmm1, qword ptr [@ax]");
    TEST("\xf2\x0f\x12\xc8", "movddup xmm1, xmm0");
    TEST("\xc5\xfb\x12\x08", "vmovddup xmm1, qword ptr [@ax]");
    TEST("\xc5\xfb\x12\xc8", "vmovddup xmm1, xmm0");
    TEST("\xc5\xff\x12\x08", "vmovddup ymm1, ymmword ptr [@ax]");
    TEST("\xc5\xff\x12\xc8", "vmovddup ymm1, ymm0");

    TEST("\xc5\xf1\xe1\xc2", "vpsraw xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xe1\x00", "vpsraw xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xe1\xc2", "vpsraw ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xe1\x00", "vpsraw ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xe2\xc2", "vpsrad xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xe2\x00", "vpsrad xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xe2\xc2", "vpsrad ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xe2\x00", "vpsrad ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xd1\xc2", "vpsrlw xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xd1\x00", "vpsrlw xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xd1\xc2", "vpsrlw ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xd1\x00", "vpsrlw ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xd2\xc2", "vpsrld xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xd2\x00", "vpsrld xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xd2\xc2", "vpsrld ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xd2\x00", "vpsrld ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xd3\xc2", "vpsrlq xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xd3\x00", "vpsrlq xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xd3\xc2", "vpsrlq ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xd3\x00", "vpsrlq ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xf1\xc2", "vpsllw xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xf1\x00", "vpsllw xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xf1\xc2", "vpsllw ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xf1\x00", "vpsllw ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xf2\xc2", "vpslld xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xf2\x00", "vpslld xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xf2\xc2", "vpslld ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xf2\x00", "vpslld ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc5\xf1\xf3\xc2", "vpsllq xmm0, xmm1, xmm2");
    TEST("\xc5\xf1\xf3\x00", "vpsllq xmm0, xmm1, xmmword ptr [@ax]");
    TEST("\xc5\xf5\xf3\xc2", "vpsllq ymm0, ymm1, xmm2");
    TEST("\xc5\xf5\xf3\x00", "vpsllq ymm0, ymm1, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x71\x47\xc2", "vpsllvd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x47\xc2", "vpsllvq xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x45\xc2", "vpsrlvd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x45\xc2", "vpsrlvq xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x46\xc2", "vpsravd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x46\xc2", "UD"); // VEX-encoded VPSRAVQ doesn't exist

    TEST("\xc4\xe3\x79\x14\xc0\x00", "vpextrb eax, xmm0, 0x0");
    TEST("\xc4\xe3\xf9\x14\xc0\x00", "vpextrb eax, xmm0, 0x0");
    TEST("\xc4\xe3\x79\x15\xc0\x00", "vpextrw eax, xmm0, 0x0");
    TEST("\xc4\xe3\xf9\x15\xc0\x00", "vpextrw eax, xmm0, 0x0");
    TEST("\xc4\xe1\x79\xc5\xc0\x00", "vpextrw eax, xmm0, 0x0");
    TEST("\xc4\xe3\x79\x16\xc0\x00", "vpextrd eax, xmm0, 0x0");
    TEST3264("\xc4\xe3\xf9\x16\xc0\x00", "vpextrd eax, xmm0, 0x0", "vpextrq rax, xmm0, 0x0");

    TEST("\xc4\xe3\x71\x20\xc0\x00", "vpinsrb xmm0, xmm1, al, 0x0");
    TEST("\xc4\xe3\xf1\x20\xc0\x00", "vpinsrb xmm0, xmm1, al, 0x0");
    TEST("\xc4\xe3\x71\x20\xc6\x00", "vpinsrb xmm0, xmm1, sil, 0x0");
    TEST("\xc4\xe1\x71\xc4\xc0\x00", "vpinsrw xmm0, xmm1, ax, 0x0");
    TEST("\xc4\xe1\xf1\xc4\xc0\x00", "vpinsrw xmm0, xmm1, ax, 0x0");
    TEST("\xc4\xe3\x71\x22\xc0\x00", "vpinsrd xmm0, xmm1, eax, 0x0");
    TEST3264("\xc4\xe3\xf1\x22\xc0\x00", "vpinsrd xmm0, xmm1, eax, 0x0", "vpinsrq xmm0, xmm1, rax, 0x0");
    TEST("\xc4\xe3\x75\x20\xc0\x00", "UD"); // VEX.L != 0
    TEST("\xc4\xe1\x75\xc4\xc0\x00", "UD"); // VEX.L != 0
    TEST("\xc4\xe1\xf5\xc4\xc0\x00", "UD"); // VEX.L != 0
    TEST("\xc4\xe3\x75\x22\xc0\x00", "UD"); // VEX.L != 0
    TEST("\xc4\xe3\xf5\x22\xc0\x00", "UD"); // VEX.L != 0

    TEST("\xc5\xf1\x71\xd7\x02", "vpsrlw xmm1, xmm7, 0x2");
    TEST("\xc5\xf5\x71\xd7\x02", "vpsrlw ymm1, ymm7, 0x2");
    TEST("\xc5\xf5\x71\x00\x02", "UD"); // Must have register operand
    TEST("\xc4\xe2\x71\x45\xc2", "vpsrlvd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\x45\xc2", "vpsrlvd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf1\x45\xc2", "vpsrlvq xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf5\x45\xc2", "vpsrlvq ymm0, ymm1, ymm2");

    TEST("\xc4\xe2\x79\x20\xc1", "vpmovsxbw xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x20\xc1", "vpmovsxbw ymm0, xmm1");
    TEST("\xc4\xe2\x79\x20\x00", "vpmovsxbw xmm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x20\x00", "vpmovsxbw ymm0, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x79\x21\xc1", "vpmovsxbd xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x21\xc1", "vpmovsxbd ymm0, xmm1");
    TEST("\xc4\xe2\x79\x21\x00", "vpmovsxbd xmm0, dword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x21\x00", "vpmovsxbd ymm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x79\x22\xc1", "vpmovsxbq xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x22\xc1", "vpmovsxbq ymm0, xmm1");
    TEST("\xc4\xe2\x79\x22\x00", "vpmovsxbq xmm0, word ptr [@ax]");
    TEST("\xc4\xe2\x7d\x22\x00", "vpmovsxbq ymm0, dword ptr [@ax]");
    TEST("\xc4\xe2\x79\x23\xc1", "vpmovsxwd xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x23\xc1", "vpmovsxwd ymm0, xmm1");
    TEST("\xc4\xe2\x79\x23\x00", "vpmovsxwd xmm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x23\x00", "vpmovsxwd ymm0, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x79\x24\xc1", "vpmovsxwq xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x24\xc1", "vpmovsxwq ymm0, xmm1");
    TEST("\xc4\xe2\x79\x24\x00", "vpmovsxwq xmm0, dword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x24\x00", "vpmovsxwq ymm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x79\x25\xc1", "vpmovsxdq xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x25\xc1", "vpmovsxdq ymm0, xmm1");
    TEST("\xc4\xe2\x79\x25\x00", "vpmovsxdq xmm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x25\x00", "vpmovsxdq ymm0, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x79\x30\xc1", "vpmovzxbw xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x30\xc1", "vpmovzxbw ymm0, xmm1");
    TEST("\xc4\xe2\x79\x30\x00", "vpmovzxbw xmm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x30\x00", "vpmovzxbw ymm0, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x79\x31\xc1", "vpmovzxbd xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x31\xc1", "vpmovzxbd ymm0, xmm1");
    TEST("\xc4\xe2\x79\x31\x00", "vpmovzxbd xmm0, dword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x31\x00", "vpmovzxbd ymm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x79\x32\xc1", "vpmovzxbq xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x32\xc1", "vpmovzxbq ymm0, xmm1");
    TEST("\xc4\xe2\x79\x32\x00", "vpmovzxbq xmm0, word ptr [@ax]");
    TEST("\xc4\xe2\x7d\x32\x00", "vpmovzxbq ymm0, dword ptr [@ax]");
    TEST("\xc4\xe2\x79\x33\xc1", "vpmovzxwd xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x33\xc1", "vpmovzxwd ymm0, xmm1");
    TEST("\xc4\xe2\x79\x33\x00", "vpmovzxwd xmm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x33\x00", "vpmovzxwd ymm0, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x79\x34\xc1", "vpmovzxwq xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x34\xc1", "vpmovzxwq ymm0, xmm1");
    TEST("\xc4\xe2\x79\x34\x00", "vpmovzxwq xmm0, dword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x34\x00", "vpmovzxwq ymm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x79\x35\xc1", "vpmovzxdq xmm0, xmm1");
    TEST("\xc4\xe2\x7d\x35\xc1", "vpmovzxdq ymm0, xmm1");
    TEST("\xc4\xe2\x79\x35\x00", "vpmovzxdq xmm0, qword ptr [@ax]");
    TEST("\xc4\xe2\x7d\x35\x00", "vpmovzxdq ymm0, xmmword ptr [@ax]");

    TEST("\xc4\xe3\x71\x4a\xc2", "PARTIAL");
    TEST("\xc4\xe3\x71\x4a\xc2\x30", "vblendvps xmm0, xmm1, xmm2, xmm3");
    TEST3264("\xc4\xe3\x75\x4a\xc2\xf0", "vblendvps ymm0, ymm1, ymm2, ymm7", "vblendvps ymm0, ymm1, ymm2, ymm15"); // Bit 7 is ignored
    TEST("\xc4\xe3\x71\x4b\xc2\x70", "vblendvpd xmm0, xmm1, xmm2, xmm7");
    TEST3264("\xc4\xe3\x75\x4b\xc2\x80", "vblendvpd ymm0, ymm1, ymm2, ymm0", "vblendvpd ymm0, ymm1, ymm2, ymm8"); // Bit 7 is ignored
    TEST3264("\xc4\xc3\xfd\x00\xc9\x12", "vpermq ymm1, ymm1, 0x12", "vpermq ymm1, ymm9, 0x12"); // VEX.B ignored
    TEST("\xc4\xc3\x7d\x00\xc9\x12", "UD"); // VEX.W = 0 is UD
    TEST("\xc4\xe3\xfd\x01\xcf\x12", "vpermpd ymm1, ymm7, 0x12");

    TEST("\xc4\xe2\x71\x96\xc2", "vfmaddsub132ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x96\x06", "vfmaddsub132ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\x96\xc2", "vfmaddsub132ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\x96\x06", "vfmaddsub132ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\x96\xc2", "vfmaddsub132pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x96\x06", "vfmaddsub132pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\x96\xc2", "vfmaddsub132pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\x96\x06", "vfmaddsub132pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\x97\xc2", "vfmsubadd132ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x97\x06", "vfmsubadd132ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\x97\xc2", "vfmsubadd132ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\x97\x06", "vfmsubadd132ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\x97\xc2", "vfmsubadd132pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x97\x06", "vfmsubadd132pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\x97\xc2", "vfmsubadd132pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\x97\x06", "vfmsubadd132pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\x98\xc2", "vfmadd132ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x98\x06", "vfmadd132ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\x98\xc2", "vfmadd132ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\x98\x06", "vfmadd132ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\x98\xc2", "vfmadd132pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x98\x06", "vfmadd132pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\x98\xc2", "vfmadd132pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\x98\x06", "vfmadd132pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\x99\xc2", "vfmadd132ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x99\x06", "vfmadd132ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\x99\xc2", "vfmadd132sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x99\x06", "vfmadd132sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\x9a\xc2", "vfmsub132ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x9a\x06", "vfmsub132ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\x9a\xc2", "vfmsub132ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\x9a\x06", "vfmsub132ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\x9a\xc2", "vfmsub132pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x9a\x06", "vfmsub132pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\x9a\xc2", "vfmsub132pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\x9a\x06", "vfmsub132pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\x9b\xc2", "vfmsub132ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x9b\x06", "vfmsub132ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\x9b\xc2", "vfmsub132sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x9b\x06", "vfmsub132sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\x9c\xc2", "vfnmadd132ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x9c\x06", "vfnmadd132ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\x9c\xc2", "vfnmadd132ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\x9c\x06", "vfnmadd132ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\x9c\xc2", "vfnmadd132pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x9c\x06", "vfnmadd132pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\x9c\xc2", "vfnmadd132pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\x9c\x06", "vfnmadd132pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\x9d\xc2", "vfnmadd132ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x9d\x06", "vfnmadd132ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\x9d\xc2", "vfnmadd132sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x9d\x06", "vfnmadd132sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\x9e\xc2", "vfnmsub132ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x9e\x06", "vfnmsub132ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\x9e\xc2", "vfnmsub132ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\x9e\x06", "vfnmsub132ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\x9e\xc2", "vfnmsub132pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x9e\x06", "vfnmsub132pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\x9e\xc2", "vfnmsub132pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\x9e\x06", "vfnmsub132pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\x9f\xc2", "vfnmsub132ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\x9f\x06", "vfnmsub132ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\x9f\xc2", "vfnmsub132sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\x9f\x06", "vfnmsub132sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xa6\xc2", "vfmaddsub213ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xa6\x06", "vfmaddsub213ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xa6\xc2", "vfmaddsub213ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xa6\x06", "vfmaddsub213ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xa6\xc2", "vfmaddsub213pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xa6\x06", "vfmaddsub213pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xa6\xc2", "vfmaddsub213pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xa6\x06", "vfmaddsub213pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xa7\xc2", "vfmsubadd213ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xa7\x06", "vfmsubadd213ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xa7\xc2", "vfmsubadd213ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xa7\x06", "vfmsubadd213ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xa7\xc2", "vfmsubadd213pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xa7\x06", "vfmsubadd213pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xa7\xc2", "vfmsubadd213pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xa7\x06", "vfmsubadd213pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xa8\xc2", "vfmadd213ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xa8\x06", "vfmadd213ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xa8\xc2", "vfmadd213ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xa8\x06", "vfmadd213ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xa8\xc2", "vfmadd213pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xa8\x06", "vfmadd213pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xa8\xc2", "vfmadd213pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xa8\x06", "vfmadd213pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xa9\xc2", "vfmadd213ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xa9\x06", "vfmadd213ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xa9\xc2", "vfmadd213sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xa9\x06", "vfmadd213sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xaa\xc2", "vfmsub213ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xaa\x06", "vfmsub213ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xaa\xc2", "vfmsub213ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xaa\x06", "vfmsub213ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xaa\xc2", "vfmsub213pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xaa\x06", "vfmsub213pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xaa\xc2", "vfmsub213pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xaa\x06", "vfmsub213pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xab\xc2", "vfmsub213ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xab\x06", "vfmsub213ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xab\xc2", "vfmsub213sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xab\x06", "vfmsub213sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xac\xc2", "vfnmadd213ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xac\x06", "vfnmadd213ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xac\xc2", "vfnmadd213ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xac\x06", "vfnmadd213ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xac\xc2", "vfnmadd213pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xac\x06", "vfnmadd213pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xac\xc2", "vfnmadd213pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xac\x06", "vfnmadd213pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xad\xc2", "vfnmadd213ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xad\x06", "vfnmadd213ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xad\xc2", "vfnmadd213sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xad\x06", "vfnmadd213sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xae\xc2", "vfnmsub213ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xae\x06", "vfnmsub213ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xae\xc2", "vfnmsub213ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xae\x06", "vfnmsub213ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xae\xc2", "vfnmsub213pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xae\x06", "vfnmsub213pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xae\xc2", "vfnmsub213pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xae\x06", "vfnmsub213pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xaf\xc2", "vfnmsub213ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xaf\x06", "vfnmsub213ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xaf\xc2", "vfnmsub213sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xaf\x06", "vfnmsub213sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xb6\xc2", "vfmaddsub231ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xb6\x06", "vfmaddsub231ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xb6\xc2", "vfmaddsub231ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xb6\x06", "vfmaddsub231ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xb6\xc2", "vfmaddsub231pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xb6\x06", "vfmaddsub231pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xb6\xc2", "vfmaddsub231pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xb6\x06", "vfmaddsub231pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xb7\xc2", "vfmsubadd231ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xb7\x06", "vfmsubadd231ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xb7\xc2", "vfmsubadd231ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xb7\x06", "vfmsubadd231ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xb7\xc2", "vfmsubadd231pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xb7\x06", "vfmsubadd231pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xb7\xc2", "vfmsubadd231pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xb7\x06", "vfmsubadd231pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xb8\xc2", "vfmadd231ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xb8\x06", "vfmadd231ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xb8\xc2", "vfmadd231ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xb8\x06", "vfmadd231ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xb8\xc2", "vfmadd231pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xb8\x06", "vfmadd231pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xb8\xc2", "vfmadd231pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xb8\x06", "vfmadd231pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xb9\xc2", "vfmadd231ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xb9\x06", "vfmadd231ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xb9\xc2", "vfmadd231sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xb9\x06", "vfmadd231sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xba\xc2", "vfmsub231ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xba\x06", "vfmsub231ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xba\xc2", "vfmsub231ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xba\x06", "vfmsub231ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xba\xc2", "vfmsub231pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xba\x06", "vfmsub231pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xba\xc2", "vfmsub231pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xba\x06", "vfmsub231pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xbb\xc2", "vfmsub231ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xbb\x06", "vfmsub231ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xbb\xc2", "vfmsub231sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xbb\x06", "vfmsub231sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xbc\xc2", "vfnmadd231ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xbc\x06", "vfnmadd231ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xbc\xc2", "vfnmadd231ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xbc\x06", "vfnmadd231ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xbc\xc2", "vfnmadd231pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xbc\x06", "vfnmadd231pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xbc\xc2", "vfnmadd231pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xbc\x06", "vfnmadd231pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xbd\xc2", "vfnmadd231ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xbd\x06", "vfnmadd231ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xbd\xc2", "vfnmadd231sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xbd\x06", "vfnmadd231sd xmm0, xmm1, qword ptr [@si]");
    TEST("\xc4\xe2\x71\xbe\xc2", "vfnmsub231ps xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xbe\x06", "vfnmsub231ps xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\x75\xbe\xc2", "vfnmsub231ps ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x75\xbe\x06", "vfnmsub231ps ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\xf1\xbe\xc2", "vfnmsub231pd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xbe\x06", "vfnmsub231pd xmm0, xmm1, xmmword ptr [@si]");
    TEST("\xc4\xe2\xf5\xbe\xc2", "vfnmsub231pd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf5\xbe\x06", "vfnmsub231pd ymm0, ymm1, ymmword ptr [@si]");
    TEST("\xc4\xe2\x71\xbf\xc2", "vfnmsub231ss xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x71\xbf\x06", "vfnmsub231ss xmm0, xmm1, dword ptr [@si]");
    TEST("\xc4\xe2\xf1\xbf\xc2", "vfnmsub231sd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf1\xbf\x06", "vfnmsub231sd xmm0, xmm1, qword ptr [@si]");

    TEST("\xc4\xe2\x79\xdb\xc1", "vaesimc xmm0, xmm1");
    TEST("\xc4\xe2\x7d\xdb\xc1", "UD"); // VEX.L != 0
    TEST("\xc4\xe3\x79\xdf\xc1\xae", "vaeskeygenassist xmm0, xmm1, 0xae");
    TEST("\xc4\xe3\x7d\xdf\xc1\xae", "UD"); // VEX.L != 0
    TEST("\xc4\xe2\x71\xdc\xc2", "vaesenc xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\xdc\xc2", "vaesenc ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\xdd\xc2", "vaesenclast xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\xdd\xc2", "vaesenclast ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\xde\xc2", "vaesdec xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\xde\xc2", "vaesdec ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\xdf\xc2", "vaesdeclast xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\xdf\xc2", "vaesdeclast ymm0, ymm1, ymm2");

    TEST("\xc4\xe2\x70\x50\xc2", "vpdpbuud xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x74\x50\xc2", "vpdpbuud ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\x50\xc2", "vpdpbusd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\x50\xc2", "vpdpbusd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x72\x50\xc2", "vpdpbsud xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x76\x50\xc2", "vpdpbsud ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x73\x50\xc2", "vpdpbssd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x77\x50\xc2", "vpdpbssd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x70\x51\xc2", "vpdpbuuds xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x74\x51\xc2", "vpdpbuuds ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\x51\xc2", "vpdpbusds xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\x51\xc2", "vpdpbusds ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x72\x51\xc2", "vpdpbsuds xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x76\x51\xc2", "vpdpbsuds ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x73\x51\xc2", "vpdpbssds xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x77\x51\xc2", "vpdpbssds ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\x52\xc2", "vpdpwssd xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\x52\xc2", "vpdpwssd ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\x71\x53\xc2", "vpdpwssds xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\x75\x53\xc2", "vpdpwssds ymm0, ymm1, ymm2");

    TEST("\xc4\xe2\x78\xb0\xc8", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x78\xb0\x08", "vcvtneoph2ps xmm1, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x7c\xb0\x08", "vcvtneoph2ps ymm1, ymmword ptr [@ax]");
    TEST("\xc4\xe2\x79\xb0\xc8", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x79\xb0\x08", "vcvtneeph2ps xmm1, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x7d\xb0\x08", "vcvtneeph2ps ymm1, ymmword ptr [@ax]");
    TEST("\xc4\xe2\x7a\xb0\xc8", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x7a\xb0\x08", "vcvtneebf162ps xmm1, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x7e\xb0\x08", "vcvtneebf162ps ymm1, ymmword ptr [@ax]");
    TEST("\xc4\xe2\x7b\xb0\xc8", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x7b\xb0\x08", "vcvtneobf162ps xmm1, xmmword ptr [@ax]");
    TEST("\xc4\xe2\x7f\xb0\x08", "vcvtneobf162ps ymm1, ymmword ptr [@ax]");
    TEST("\xc4\xe2\x79\xb1\xc8", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x79\xb1\x08", "vbcstnesh2ps xmm1, word ptr [@ax]");
    TEST("\xc4\xe2\x7d\xb1\x08", "vbcstnesh2ps ymm1, word ptr [@ax]");
    TEST("\xc4\xe2\x7a\xb1\xc8", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x7a\xb1\x08", "vbcstnebf162ps xmm1, word ptr [@ax]");
    TEST("\xc4\xe2\x7e\xb1\x08", "vbcstnebf162ps ymm1, word ptr [@ax]");
    TEST("\xc4\xe2\x7a\x72\xc1", "vcvtneps2bf16 xmm0, xmm1");
    TEST("\xc4\xe2\x7e\x72\xc1", "vcvtneps2bf16 xmm0, ymm1");

    TEST("\xc4\xe2\xf1\xb4\xc2", "vpmadd52luq xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf5\xb4\xc2", "vpmadd52luq ymm0, ymm1, ymm2");
    TEST("\xc4\xe2\xf1\xb5\xc2", "vpmadd52huq xmm0, xmm1, xmm2");
    TEST("\xc4\xe2\xf5\xb5\xc2", "vpmadd52huq ymm0, ymm1, ymm2");

    TEST("\xc4\xe2\x71\x92\xc0", "UD"); // Must have memory operand
    TEST("\xc4\xe2\x71\x92\x00", "UD"); // Must have SIB byte
    TEST("\xc4\xe2\x71\x92\x05\x00\x00\x00\x00", "UD"); // Must have SIB byte
    TEST3264("\x67\xc4\xe2\x71\x92\x04\xe7", "UD", "vgatherdps xmm0, dword ptr [edi+8*xmm4], xmm1"); // VSIB + 16-bit addrsize is UD
    TEST("\xc4\xe2\x71\x92\x04\xe7", "vgatherdps xmm0, dword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\x75\x92\x04\xe7", "vgatherdps ymm0, dword ptr [@di+8*ymm4], ymm1");
    TEST("\xc4\xe2\x71\x93\x04\xe7", "vgatherqps xmm0, dword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\x75\x93\x04\xe7", "vgatherqps xmm0, dword ptr [@di+8*ymm4], xmm1");
    TEST("\xc4\xe2\xf1\x92\x04\xe7", "vgatherdpd xmm0, qword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\xf5\x92\x04\xe7", "vgatherdpd ymm0, qword ptr [@di+8*xmm4], ymm1");
    TEST("\xc4\xe2\xf1\x93\x04\xe7", "vgatherqpd xmm0, qword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\xf5\x93\x04\xe7", "vgatherqpd ymm0, qword ptr [@di+8*ymm4], ymm1");
    TEST("\xc4\xe2\x71\x90\x04\xe7", "vpgatherdd xmm0, dword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\x75\x90\x04\xe7", "vpgatherdd ymm0, dword ptr [@di+8*ymm4], ymm1");
    TEST("\xc4\xe2\x71\x91\x04\xe7", "vpgatherqd xmm0, dword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\x75\x91\x04\xe7", "vpgatherqd xmm0, dword ptr [@di+8*ymm4], xmm1");
    TEST("\xc4\xe2\xf1\x90\x04\xe7", "vpgatherdq xmm0, qword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\xf5\x90\x04\xe7", "vpgatherdq ymm0, qword ptr [@di+8*xmm4], ymm1");
    TEST("\xc4\xe2\xf1\x91\x04\xe7", "vpgatherqq xmm0, qword ptr [@di+8*xmm4], xmm1");
    TEST("\xc4\xe2\xf5\x91\x04\xe7", "vpgatherqq ymm0, qword ptr [@di+8*ymm4], ymm1");

    TEST("\xc4\xe2\x7d\x5a\x20", "vbroadcasti128 ymm4, xmmword ptr [@ax]");
    TEST64("\xc4\x62\x7d\x5a\x20", "vbroadcasti128 ymm12, xmmword ptr [rax]");
    TEST("\xc4\xe2\x75\x5a\x20", "UD"); // VEX.vvvv != 1111
    TEST("\xc4\xe2\x7d\x5a\xc0", "UD"); // ModRM.mod != 11
    TEST("\xc4\xe2\x79\x5a\x20", "UD"); // VEX.L != 1
    TEST("\xc4\xe2\xfd\x5a\x20", "UD"); // VEX.W != 0

    // Intel-Syntax special cases
    TEST("\x66\x98", "cbw");
    TEST("\x98", "cwde");
    TEST64("\x48\x98", "cdqe");
    TEST("\x66\x99", "cwd");
    TEST("\x99", "cdq");
    TEST64("\x48\x99", "cqo");

    TEST("\x0f\xae\x00", "fxsave [@ax]");
    TEST64("\x48\x0f\xae\x00", "fxsave64 [rax]");
    TEST("\x0f\xae\x08", "fxrstor [@ax]");
    TEST64("\x48\x0f\xae\x08", "fxrstor64 [rax]");
    TEST("\x0f\xae\x20", "xsave [@ax]");
    TEST64("\x48\x0f\xae\x20", "xsave64 [rax]");
    TEST("\x0f\xc7\x20", "xsavec [@ax]");
    TEST64("\x48\x0f\xc7\x20", "xsavec64 [rax]");
    TEST("\x0f\xae\x30", "xsaveopt [@ax]");
    TEST64("\x48\x0f\xae\x30", "xsaveopt64 [rax]");
    TEST("\x0f\xc7\x28", "xsaves [@ax]");
    TEST64("\x48\x0f\xc7\x28", "xsaves64 [rax]");
    TEST("\x0f\xae\x28", "xrstor [@ax]");
    TEST64("\x48\x0f\xae\x28", "xrstor64 [rax]");
    TEST("\x0f\xc7\x18", "xrstors [@ax]");
    TEST64("\x48\x0f\xc7\x18", "xrstors64 [rax]");
    TEST("\xff\xe0", "jmp @ax");
    TEST3264("\x66\xff\xe0", "jmp ax", "jmp rax");
    TEST64("\x48\xff\xe0", "jmp rax");
    TEST("\xff\xd0", "call @ax");
    TEST3264("\x66\xff\xd0", "call ax", "call rax");
    TEST64("\x48\xff\xd0", "call rax");
    TEST3264("\x66\x70\x00", "jow 0x3", "jo 0x3");
    TEST("\xe3\xfe", "j@cxz 0x0");
    TEST3264("\x67\xe3\xfd", "jcxz 0x0", "jecxz 0x0");
    TEST3264("\xff\x20", "jmp dword ptr [eax]", "jmp qword ptr [rax]");
    TEST3264("\x66\xff\x20", "jmp word ptr [eax]", "jmp qword ptr [rax]");
    TEST64("\x48\xff\x20", "jmp qword ptr [rax]");
    TEST("\xff\x28", "jmp far fword ptr [@ax]");
    TEST("\x66\xff\x28", "jmp far dword ptr [@ax]");
    TEST64("\x48\xff\x28", "jmp far tbyte ptr [rax]");
    TEST3264("\xea\x11\x22\x33\x44\x55\x66", "jmp far 0x6655:0x44332211", "UD");
    TEST3264("\x66\xea\x11\x22\x33\x44", "jmp far 0x4433:0x2211", "UD");
    TEST32("\x66\x9a\x23\x01\x23\x00", "call far 0x23:0x123");
    TEST32("\x9a\x67\x45\x23\x01\x23\x00", "call far 0x23:0x1234567");
    TEST32("\x9a\xff\xff\xff\xff\xff\xff", "call far 0xffff:0xffffffff");
    TEST("\x66\xff\x1f", "call far dword ptr [@di]");
    TEST("\xff\x1f", "call far fword ptr [@di]");
    TEST64("\x48\xff\x1f", "call far tbyte ptr [rdi]");
    TEST("\x0f\xb4", "PARTIAL");
    TEST("\x66\x0f\xb4\x07", "lfs ax, dword ptr [@di]");
    TEST("\x0f\xb4\x07", "lfs eax, fword ptr [@di]");
    TEST64("\x48\x0f\xb4\x07", "lfs rax, tbyte ptr [rdi]");
    TEST("\xa5", "movsd");
    TEST("\x64\xa5", "fs movsd");
    TEST3264("\x2e\xa5", "cs movsd", "movsd");
    TEST3264("\x67\xa5", "addr16 movsd", "addr32 movsd");
    TEST("\xaf", "scasd");
    TEST("\x64\xaf", "scasd"); // SCAS doesn't use segment overrides
    TEST("\xec", "inb");
    TEST("\x66\xed", "inw");
    TEST("\xed", "ind");
    // TEST64("\x48\xed", "ind"); // TODO
    // TEST64("\x66\x48\xed", "ind"); // TODO
    TEST("\xee", "outb");
    TEST("\x66\xef", "outw");
    TEST("\xef", "outd");
    // TEST64("\x48\xef", "outd"); // TODO
    // TEST64("\x66\x48\xef", "outd"); // TODO
    TEST("\xe4\x00", "in al, 0x0");
    TEST("\xe4\xff", "in al, 0xff");
    TEST("\x66\xe5\xff", "in ax, 0xff");
    TEST("\xe5\xff", "in eax, 0xff");
    // TEST64("\x66\x48\xe5\xff", "in eax, 0xff"); // TODO
    // TEST64("\x48\xe5\xff", "in eax, 0xff"); // TODO
    TEST("\xe6\x00", "out al, 0x0");
    TEST("\xe6\xff", "out al, 0xff");
    TEST("\x66\xe7\xff", "out ax, 0xff");
    TEST("\xe7\xff", "out eax, 0xff");
    // TEST64("\x66\x48\xe7\xff", "out eax, 0xff"); // TODO
    // TEST64("\x48\xe7\xff", "out eax, 0xff"); // TODO
    TEST32("\x66\x61", "popaw");
    TEST32("\x61", "popad");
    TEST("\x66\x9c", "pushfw");
    TEST3264("\x9c", "pushfd", "pushfq");
    TEST("\x66\x9d", "popfw");
    TEST3264("\x9d", "popfd", "popfq");
    TEST("\x66\xcf", "iretw");
    TEST("\xcf", "iretd");
    TEST64("\x48\xcf", "iretq");
    TEST32("\x06", "push es");
    TEST32("\x66\x06", "pushw es");
    TEST32("\x07", "pop es");
    TEST32("\x66\x07", "popw es");
    TEST32("\x0e", "push cs");
    TEST32("\x66\x0e", "pushw cs");
    TEST32("\x16", "push ss");
    TEST32("\x66\x16", "pushw ss");
    TEST32("\x17", "pop ss");
    TEST32("\x66\x17", "popw ss");
    TEST("\x0f\xa8", "push gs");
    TEST("\x66\x0f\xa8", "pushw gs");
    TEST("\x0f\xa9", "pop gs");
    TEST("\x66\x0f\xa9", "popw gs");
    TEST("\x0f\x21\xd0", "mov @ax, dr2");
    TEST32("\x62\x00", "bound eax, qword ptr [eax]");
    TEST32("\x66\x62\x00", "bound ax, dword ptr [eax]");
    TEST("\x0f\xae\x38", "clflush byte ptr [@ax]");
    TEST("\xdd\x00", "fld qword ptr [@ax]");
    TEST("\xdb\x28", "fld tbyte ptr [@ax]");
    TEST("\xd9\x20", "fldenv [@ax]");

    // MPX
#if 0
    TEST("\x66\x0f\x1a\xc1", "bndmov bnd0, bnd1");
    TEST("\x66\x0f\x1a\xc4", "UD"); // ModRM bnd4 is undefined
    TEST64("\x41\x66\x0f\x1a\xc0", "UD"); // ModRM bnd8 is undefined
    TEST("\xf3\x0f\x1b\x00", "bndmk bnd0, [@ax]");
    TEST64("\x0f\x1a\x05\x00\x00\x00\x00", "UD"); // BNDSTX+RIP-rel = UD
    TEST64("\x0f\x1b\x05\x00\x00\x00\x00", "UD"); // BNDLDX+RIP-rel = UD
    TEST64("\xf3\x0f\x1b\x05\x00\x00\x00\x00", "UD"); // BNDMK+RIP-rel = UD
#endif
    TEST("\xf3\x0f\x1b\xc0", "nop eax, eax"); // BNDMK with reg/reg remains NOP

    // 3DNow!
    TEST("\x0f\x0f\xc0\x00", "UD");
    TEST("\x0f\x0f\xc0\x0c", "3dnow mm0, mm0, 0xc"); // PI2FW
    TEST("\x0f\x0f\xc0\x0d", "3dnow mm0, mm0, 0xd"); // PI2FD
    TEST("\x0f\x0f\xc0\x0e", "UD");
    TEST("\x0f\x0f\xc0\x1c", "3dnow mm0, mm0, 0x1c"); // PF2IW
    TEST("\x0f\x0f\xc0\x1d", "3dnow mm0, mm0, 0x1d"); // PF2ID
    TEST("\x0f\x0f\xc0\x42", "UD");
    TEST("\x0f\x0f\xc0\x80", "UD");
    TEST("\x0f\x0f\xc0\x8a", "3dnow mm0, mm0, 0x8a"); // PFNACC
    TEST("\x0f\x0f\xc0\xa0", "3dnow mm0, mm0, 0xa0"); // PFCMPGT
    TEST("\x0f\x0f\xc0\xb6", "3dnow mm0, mm0, 0xb6"); // PFRCPIT2
    TEST("\x0f\x0f\xc0\xbf", "3dnow mm0, mm0, 0xbf"); // PAVGUSB

    TEST("\x0f\x01\xfc", "clzero eax");
    TEST("\x66\x0f\x01\xfc", "clzero ax");
    TEST64("\x48\x0f\x01\xfc", "clzero rax");

    // VIA PadLock
    TEST("\x0f\xa7\xc0", "xstore");
    TEST("\xf3\x0f\xa7\xc0", "rep xstore");
    TEST("\xf2\x0f\xa7\xc0", "UD");
    TEST("\x0f\xa7\xe8 ", "UD");
    TEST("\xf2\x0f\xa7\xe8", "UD");
    TEST("\xf3\x0f\xa7\xe8", "rep xcryptofb");

    // Maximum instruction length is 15 bytes.
    TEST("\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x90", "PARTIAL");

    // AMX
    TEST64("\xc4\xe2\x78\x49\x00", "ldtilecfg [rax]");
    TEST64("\xc4\xe2\x79\x49\x00", "sttilecfg [rax]");
    TEST64("\xc4\xe2\x78\x49\xc0", "tilerelease");
    TEST64("\xc4\xe2\x7b\x49\x00", "UD"); // ModRM.mod != 11
    TEST64("\xc4\xe2\x7b\x49\xc0", "tilezero tmm0");
    TEST64("\xc4\xe2\x7b\x49\xc1", "UD"); // ModRM.rm != 0
    TEST64("\xc4\xe2\x7b\x49\xc7", "UD"); // ModRM.rm != 0
    TEST64("\xc4\xe2\x7b\x49\xc8", "tilezero tmm1");
    TEST64("\xc4\xe2\x7b\x49\xf8", "tilezero tmm7");
    TEST64("\xc4\x02\x7b\x49\xf8", "tilezero tmm7"); // VEX.RXB ignored
    TEST64("\xc4\xe2\x7b\x4b\x04\x10", "tileloadd tmm0, [rax+1*rdx]");
    TEST64("\xc4\xe2\x7b\x4b\x04\x20", "tileloadd tmm0, [rax]"); // riz
    TEST64("\xc4\x02\x7b\x4b\x3c\x10", "tileloadd tmm7, [r8+1*r10]"); // VEX.R ignored
    TEST64("\xc4\xe2\x7b\x4b\x00", "UD"); // must have SIB byte
    TEST64("\xc4\xe2\x7b\x4b\xff", "UD"); // must have memory operand
    TEST64("\xc4\xe2\x79\x4b\x04\x10", "tileloaddt1 tmm0, [rax+1*rdx]");
    TEST64("\xc4\xe2\x79\x4b\x04\x20", "tileloaddt1 tmm0, [rax]"); // riz
    TEST64("\xc4\x02\x79\x4b\x3c\x10", "tileloaddt1 tmm7, [r8+1*r10]"); // VEX.R ignored
    TEST64("\xc4\xe2\x79\x4b\x00", "UD"); // must have SIB byte
    TEST64("\xc4\xe2\x79\x4b\xff", "UD"); // must have memory operand
    TEST64("\xc4\xe2\x7a\x4b\x04\x10", "tilestored [rax+1*rdx], tmm0");
    TEST64("\xc4\xe2\x7a\x4b\x04\x20", "tilestored [rax], tmm0"); // riz
    TEST64("\xc4\x02\x7a\x4b\x3c\x10", "tilestored [r8+1*r10], tmm7"); // VEX.R ignored
    TEST64("\xc4\xe2\x7a\x4b\x00", "UD"); // must have SIB byte
    TEST64("\xc4\xe2\x7a\x4b\xff", "UD"); // must have memory operand
    TEST64("\xc4\xe2\x68\x5e\x00", "UD"); // must have register operand
    TEST64("\xc4\xe2\x68\x5e\xc8", "tdpbuud tmm1, tmm0, tmm2");
    TEST64("\xc4\x02\x28\x5e\xc8", "tdpbuud tmm1, tmm0, tmm2"); // VEX.RBV3 ignored
    // TODO: enforce that all registers must be different
    //TEST64("\xc4\xe2\x68\x5e\xc0", "UD"); // ModRM.rm == ModRM.reg
    //TEST64("\xc4\xe2\x68\x5e\xca", "UD"); // ModRM.rm == VEX.vvvv
    //TEST64("\xc4\xe2\x68\x5e\xd0", "UD"); // ModRM.reg == VEX.vvvv
    TEST64("\xc4\xe2\x6a\x5c\xc8", "tdpbf16ps tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x6b\x5c\xc8", "tdpfp16ps tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x68\x5e\xc8", "tdpbuud tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x69\x5e\xc8", "tdpbusd tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x6a\x5e\xc8", "tdpbsud tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x6b\x5e\xc8", "tdpbssd tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x68\x6c\xc8", "tcmmrlfp16ps tmm1, tmm0, tmm2");
    TEST64("\xc4\xe2\x69\x6c\xc8", "tcmmimfp16ps tmm1, tmm0, tmm2");

    // Complete test of VADDPS and all encoding options
    TEST("\x62", "PARTIAL");
    TEST("\x62\xf1", "PARTIAL");
    TEST("\x62\xf1\x74", "PARTIAL");
    TEST("\x62\xf1\x74\x18", "PARTIAL");
    TEST("\x62\xf1\x74\x18\x58", "PARTIAL");
    TEST("\x62\xf1\x74\x18\x58\xc2", "vaddps zmm0, zmm1, zmm2, {rn-sae}");
    TEST("\x62\xf1\x74\x38\x58\xc2", "vaddps zmm0, zmm1, zmm2, {rd-sae}");
    TEST("\x62\xf1\x74\x58\x58\xc2", "vaddps zmm0, zmm1, zmm2, {ru-sae}");
    TEST("\x62\xf1\x74\x78\x58\xc2", "vaddps zmm0, zmm1, zmm2, {rz-sae}");
    TEST("\x62\xf1\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2");
    TEST("\x62\xf1\x74\x09\x58\xc2", "vaddps xmm0{k1}, xmm1, xmm2");
    TEST("\x62\xf1\x74\x89\x58\xc2", "vaddps xmm0{k1}{z}, xmm1, xmm2");
    TEST("\x62\xf1\x74\x88\x58\xc2", "UD"); // EVEX.z = 1
    TEST("\x62\xf1\x74\x28\x58\xc2", "vaddps ymm0, ymm1, ymm2");
    TEST("\x62\xf1\x74\x29\x58\xc2", "vaddps ymm0{k1}, ymm1, ymm2");
    TEST("\x62\xf1\x74\xa9\x58\xc2", "vaddps ymm0{k1}{z}, ymm1, ymm2");
    TEST("\x62\xf1\x74\xa8\x58\xc2", "UD"); // EVEX.z = 1
    TEST("\x62\xf1\x74\x48\x58\xc2", "vaddps zmm0, zmm1, zmm2");
    TEST("\x62\xf1\x74\x49\x58\xc2", "vaddps zmm0{k1}, zmm1, zmm2");
    TEST("\x62\xf1\x74\xc9\x58\xc2", "vaddps zmm0{k1}{z}, zmm1, zmm2");
    TEST("\x62\xf1\x74\xc8\x58\xc2", "UD"); // EVEX.z = 1
    TEST("\x62\xf1\x74\x68\x58\xc2", "UD"); // EVEX.L'Lb = 110    TEST32("\x62\xf1\x74\x08\x58\x00", "vaddps xmm0, xmm1, xmmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x08\x58\x00", "vaddps xmm0, xmm1, xmmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x08\x58\x00", "vaddps xmm0, xmm1, xmmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x08\x58\x00", "vaddps xmm0, xmm1, xmmword ptr [eax]");
    TEST32("\x62\xf1\x74\x0a\x58\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x0a\x58\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x0a\x58\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x0a\x58\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax]");
    TEST32("\x62\xf1\x74\x8a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x8a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x8a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x8a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax]");
    TEST32("\x62\xf1\x74\x88\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x88\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x88\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x88\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x18\x58\x00", "vaddps xmm0, xmm1, dword ptr [eax]{1to4}");
    TEST32("\x67\x62\xf1\x74\x18\x58\x00", "vaddps xmm0, xmm1, dword ptr [bx+1*si]{1to4}");
    TEST64("\x62\xf1\x74\x18\x58\x00", "vaddps xmm0, xmm1, dword ptr [rax]{1to4}");
    TEST64("\x67\x62\xf1\x74\x18\x58\x00", "vaddps xmm0, xmm1, dword ptr [eax]{1to4}");
    TEST32("\x62\xf1\x74\x1a\x58\x00", "vaddps xmm0{k2}, xmm1, dword ptr [eax]{1to4}");
    TEST32("\x67\x62\xf1\x74\x1a\x58\x00", "vaddps xmm0{k2}, xmm1, dword ptr [bx+1*si]{1to4}");
    TEST64("\x62\xf1\x74\x1a\x58\x00", "vaddps xmm0{k2}, xmm1, dword ptr [rax]{1to4}");
    TEST64("\x67\x62\xf1\x74\x1a\x58\x00", "vaddps xmm0{k2}, xmm1, dword ptr [eax]{1to4}");
    TEST32("\x62\xf1\x74\x9a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax]{1to4}");
    TEST32("\x67\x62\xf1\x74\x9a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [bx+1*si]{1to4}");
    TEST64("\x62\xf1\x74\x9a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [rax]{1to4}");
    TEST64("\x67\x62\xf1\x74\x9a\x58\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax]{1to4}");
    TEST32("\x62\xf1\x74\x98\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x98\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x98\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x98\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x28\x58\x00", "vaddps ymm0, ymm1, ymmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x28\x58\x00", "vaddps ymm0, ymm1, ymmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x28\x58\x00", "vaddps ymm0, ymm1, ymmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x28\x58\x00", "vaddps ymm0, ymm1, ymmword ptr [eax]");
    TEST32("\x62\xf1\x74\x2a\x58\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x2a\x58\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x2a\x58\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x2a\x58\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax]");
    TEST32("\x62\xf1\x74\xaa\x58\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\xaa\x58\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\xaa\x58\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\xaa\x58\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax]");
    TEST32("\x62\xf1\x74\xa8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xa8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xa8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xa8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x38\x58\x00", "vaddps ymm0, ymm1, dword ptr [eax]{1to8}");
    TEST32("\x67\x62\xf1\x74\x38\x58\x00", "vaddps ymm0, ymm1, dword ptr [bx+1*si]{1to8}");
    TEST64("\x62\xf1\x74\x38\x58\x00", "vaddps ymm0, ymm1, dword ptr [rax]{1to8}");
    TEST64("\x67\x62\xf1\x74\x38\x58\x00", "vaddps ymm0, ymm1, dword ptr [eax]{1to8}");
    TEST32("\x62\xf1\x74\x3a\x58\x00", "vaddps ymm0{k2}, ymm1, dword ptr [eax]{1to8}");
    TEST32("\x67\x62\xf1\x74\x3a\x58\x00", "vaddps ymm0{k2}, ymm1, dword ptr [bx+1*si]{1to8}");
    TEST64("\x62\xf1\x74\x3a\x58\x00", "vaddps ymm0{k2}, ymm1, dword ptr [rax]{1to8}");
    TEST64("\x67\x62\xf1\x74\x3a\x58\x00", "vaddps ymm0{k2}, ymm1, dword ptr [eax]{1to8}");
    TEST32("\x62\xf1\x74\xba\x58\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax]{1to8}");
    TEST32("\x67\x62\xf1\x74\xba\x58\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [bx+1*si]{1to8}");
    TEST64("\x62\xf1\x74\xba\x58\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [rax]{1to8}");
    TEST64("\x67\x62\xf1\x74\xba\x58\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax]{1to8}");
    TEST32("\x62\xf1\x74\xb8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xb8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xb8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xb8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x48\x58\x00", "vaddps zmm0, zmm1, zmmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x48\x58\x00", "vaddps zmm0, zmm1, zmmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x48\x58\x00", "vaddps zmm0, zmm1, zmmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x48\x58\x00", "vaddps zmm0, zmm1, zmmword ptr [eax]");
    TEST32("\x62\xf1\x74\x4a\x58\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\x4a\x58\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\x4a\x58\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\x4a\x58\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax]");
    TEST32("\x62\xf1\x74\xca\x58\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax]");
    TEST32("\x67\x62\xf1\x74\xca\x58\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [bx+1*si]");
    TEST64("\x62\xf1\x74\xca\x58\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [rax]");
    TEST64("\x67\x62\xf1\x74\xca\x58\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax]");
    TEST32("\x62\xf1\x74\xc8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xc8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xc8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xc8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x58\x58\x00", "vaddps zmm0, zmm1, dword ptr [eax]{1to16}");
    TEST32("\x67\x62\xf1\x74\x58\x58\x00", "vaddps zmm0, zmm1, dword ptr [bx+1*si]{1to16}");
    TEST64("\x62\xf1\x74\x58\x58\x00", "vaddps zmm0, zmm1, dword ptr [rax]{1to16}");
    TEST64("\x67\x62\xf1\x74\x58\x58\x00", "vaddps zmm0, zmm1, dword ptr [eax]{1to16}");
    TEST32("\x62\xf1\x74\x5a\x58\x00", "vaddps zmm0{k2}, zmm1, dword ptr [eax]{1to16}");
    TEST32("\x67\x62\xf1\x74\x5a\x58\x00", "vaddps zmm0{k2}, zmm1, dword ptr [bx+1*si]{1to16}");
    TEST64("\x62\xf1\x74\x5a\x58\x00", "vaddps zmm0{k2}, zmm1, dword ptr [rax]{1to16}");
    TEST64("\x67\x62\xf1\x74\x5a\x58\x00", "vaddps zmm0{k2}, zmm1, dword ptr [eax]{1to16}");
    TEST32("\x62\xf1\x74\xda\x58\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax]{1to16}");
    TEST32("\x67\x62\xf1\x74\xda\x58\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [bx+1*si]{1to16}");
    TEST64("\x62\xf1\x74\xda\x58\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [rax]{1to16}");
    TEST64("\x67\x62\xf1\x74\xda\x58\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax]{1to16}");
    TEST32("\x62\xf1\x74\xd8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xd8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xd8\x58\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xd8\x58\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x68\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x68\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x68\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x68\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x6a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x6a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x6a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x6a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xea\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xea\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xea\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xea\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xe8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xe8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xe8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xe8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x78\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x78\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x78\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x78\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x7a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x7a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x7a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x7a\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xfa\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xfa\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xfa\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xfa\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xf8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xf8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xf8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xf8\x58\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x08\x58\x40\x01", "vaddps xmm0, xmm1, xmmword ptr [eax+0x10]");
    TEST32("\x67\x62\xf1\x74\x08\x58\x40\x01", "vaddps xmm0, xmm1, xmmword ptr [bx+1*si+0x10]");
    TEST64("\x62\xf1\x74\x08\x58\x40\x01", "vaddps xmm0, xmm1, xmmword ptr [rax+0x10]");
    TEST64("\x67\x62\xf1\x74\x08\x58\x40\x01", "vaddps xmm0, xmm1, xmmword ptr [eax+0x10]");
    TEST32("\x62\xf1\x74\x0a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax+0x10]");
    TEST32("\x67\x62\xf1\x74\x0a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, xmmword ptr [bx+1*si+0x10]");
    TEST64("\x62\xf1\x74\x0a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, xmmword ptr [rax+0x10]");
    TEST64("\x67\x62\xf1\x74\x0a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax+0x10]");
    TEST32("\x62\xf1\x74\x8a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax+0x10]");
    TEST32("\x67\x62\xf1\x74\x8a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [bx+1*si+0x10]");
    TEST64("\x62\xf1\x74\x8a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [rax+0x10]");
    TEST64("\x67\x62\xf1\x74\x8a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax+0x10]");
    TEST32("\x62\xf1\x74\x88\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x88\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x88\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x88\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x18\x58\x40\x01", "vaddps xmm0, xmm1, dword ptr [eax+0x4]{1to4}");
    TEST32("\x67\x62\xf1\x74\x18\x58\x40\x01", "vaddps xmm0, xmm1, dword ptr [bx+1*si+0x4]{1to4}");
    TEST64("\x62\xf1\x74\x18\x58\x40\x01", "vaddps xmm0, xmm1, dword ptr [rax+0x4]{1to4}");
    TEST64("\x67\x62\xf1\x74\x18\x58\x40\x01", "vaddps xmm0, xmm1, dword ptr [eax+0x4]{1to4}");
    TEST32("\x62\xf1\x74\x1a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, dword ptr [eax+0x4]{1to4}");
    TEST32("\x67\x62\xf1\x74\x1a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, dword ptr [bx+1*si+0x4]{1to4}");
    TEST64("\x62\xf1\x74\x1a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, dword ptr [rax+0x4]{1to4}");
    TEST64("\x67\x62\xf1\x74\x1a\x58\x40\x01", "vaddps xmm0{k2}, xmm1, dword ptr [eax+0x4]{1to4}");
    TEST32("\x62\xf1\x74\x9a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax+0x4]{1to4}");
    TEST32("\x67\x62\xf1\x74\x9a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, dword ptr [bx+1*si+0x4]{1to4}");
    TEST64("\x62\xf1\x74\x9a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, dword ptr [rax+0x4]{1to4}");
    TEST64("\x67\x62\xf1\x74\x9a\x58\x40\x01", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax+0x4]{1to4}");
    TEST32("\x62\xf1\x74\x98\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x98\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x98\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x98\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x28\x58\x40\x01", "vaddps ymm0, ymm1, ymmword ptr [eax+0x20]");
    TEST32("\x67\x62\xf1\x74\x28\x58\x40\x01", "vaddps ymm0, ymm1, ymmword ptr [bx+1*si+0x20]");
    TEST64("\x62\xf1\x74\x28\x58\x40\x01", "vaddps ymm0, ymm1, ymmword ptr [rax+0x20]");
    TEST64("\x67\x62\xf1\x74\x28\x58\x40\x01", "vaddps ymm0, ymm1, ymmword ptr [eax+0x20]");
    TEST32("\x62\xf1\x74\x2a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax+0x20]");
    TEST32("\x67\x62\xf1\x74\x2a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, ymmword ptr [bx+1*si+0x20]");
    TEST64("\x62\xf1\x74\x2a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, ymmword ptr [rax+0x20]");
    TEST64("\x67\x62\xf1\x74\x2a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax+0x20]");
    TEST32("\x62\xf1\x74\xaa\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax+0x20]");
    TEST32("\x67\x62\xf1\x74\xaa\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [bx+1*si+0x20]");
    TEST64("\x62\xf1\x74\xaa\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [rax+0x20]");
    TEST64("\x67\x62\xf1\x74\xaa\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax+0x20]");
    TEST32("\x62\xf1\x74\xa8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xa8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xa8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xa8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x38\x58\x40\x01", "vaddps ymm0, ymm1, dword ptr [eax+0x4]{1to8}");
    TEST32("\x67\x62\xf1\x74\x38\x58\x40\x01", "vaddps ymm0, ymm1, dword ptr [bx+1*si+0x4]{1to8}");
    TEST64("\x62\xf1\x74\x38\x58\x40\x01", "vaddps ymm0, ymm1, dword ptr [rax+0x4]{1to8}");
    TEST64("\x67\x62\xf1\x74\x38\x58\x40\x01", "vaddps ymm0, ymm1, dword ptr [eax+0x4]{1to8}");
    TEST32("\x62\xf1\x74\x3a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, dword ptr [eax+0x4]{1to8}");
    TEST32("\x67\x62\xf1\x74\x3a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, dword ptr [bx+1*si+0x4]{1to8}");
    TEST64("\x62\xf1\x74\x3a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, dword ptr [rax+0x4]{1to8}");
    TEST64("\x67\x62\xf1\x74\x3a\x58\x40\x01", "vaddps ymm0{k2}, ymm1, dword ptr [eax+0x4]{1to8}");
    TEST32("\x62\xf1\x74\xba\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax+0x4]{1to8}");
    TEST32("\x67\x62\xf1\x74\xba\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, dword ptr [bx+1*si+0x4]{1to8}");
    TEST64("\x62\xf1\x74\xba\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, dword ptr [rax+0x4]{1to8}");
    TEST64("\x67\x62\xf1\x74\xba\x58\x40\x01", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax+0x4]{1to8}");
    TEST32("\x62\xf1\x74\xb8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xb8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xb8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xb8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x48\x58\x40\x01", "vaddps zmm0, zmm1, zmmword ptr [eax+0x40]");
    TEST32("\x67\x62\xf1\x74\x48\x58\x40\x01", "vaddps zmm0, zmm1, zmmword ptr [bx+1*si+0x40]");
    TEST64("\x62\xf1\x74\x48\x58\x40\x01", "vaddps zmm0, zmm1, zmmword ptr [rax+0x40]");
    TEST64("\x67\x62\xf1\x74\x48\x58\x40\x01", "vaddps zmm0, zmm1, zmmword ptr [eax+0x40]");
    TEST32("\x62\xf1\x74\x4a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax+0x40]");
    TEST32("\x67\x62\xf1\x74\x4a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, zmmword ptr [bx+1*si+0x40]");
    TEST64("\x62\xf1\x74\x4a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, zmmword ptr [rax+0x40]");
    TEST64("\x67\x62\xf1\x74\x4a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax+0x40]");
    TEST32("\x62\xf1\x74\xca\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax+0x40]");
    TEST32("\x67\x62\xf1\x74\xca\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [bx+1*si+0x40]");
    TEST64("\x62\xf1\x74\xca\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [rax+0x40]");
    TEST64("\x67\x62\xf1\x74\xca\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax+0x40]");
    TEST32("\x62\xf1\x74\xc8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xc8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xc8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xc8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x58\x58\x40\x01", "vaddps zmm0, zmm1, dword ptr [eax+0x4]{1to16}");
    TEST32("\x67\x62\xf1\x74\x58\x58\x40\x01", "vaddps zmm0, zmm1, dword ptr [bx+1*si+0x4]{1to16}");
    TEST64("\x62\xf1\x74\x58\x58\x40\x01", "vaddps zmm0, zmm1, dword ptr [rax+0x4]{1to16}");
    TEST64("\x67\x62\xf1\x74\x58\x58\x40\x01", "vaddps zmm0, zmm1, dword ptr [eax+0x4]{1to16}");
    TEST32("\x62\xf1\x74\x5a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, dword ptr [eax+0x4]{1to16}");
    TEST32("\x67\x62\xf1\x74\x5a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, dword ptr [bx+1*si+0x4]{1to16}");
    TEST64("\x62\xf1\x74\x5a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, dword ptr [rax+0x4]{1to16}");
    TEST64("\x67\x62\xf1\x74\x5a\x58\x40\x01", "vaddps zmm0{k2}, zmm1, dword ptr [eax+0x4]{1to16}");
    TEST32("\x62\xf1\x74\xda\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax+0x4]{1to16}");
    TEST32("\x67\x62\xf1\x74\xda\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, dword ptr [bx+1*si+0x4]{1to16}");
    TEST64("\x62\xf1\x74\xda\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, dword ptr [rax+0x4]{1to16}");
    TEST64("\x67\x62\xf1\x74\xda\x58\x40\x01", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax+0x4]{1to16}");
    TEST32("\x62\xf1\x74\xd8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xd8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xd8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xd8\x58\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x68\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x68\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x68\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x68\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x6a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x6a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x6a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x6a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xea\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xea\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xea\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xea\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xe8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xe8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xe8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xe8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x78\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x78\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x78\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x78\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x7a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x7a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x7a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x7a\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xfa\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xfa\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xfa\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xfa\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xf8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xf8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xf8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xf8\x58\x40\x01", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x08\x58\x40\xff", "vaddps xmm0, xmm1, xmmword ptr [eax-0x10]");
    TEST32("\x67\x62\xf1\x74\x08\x58\x40\xff", "vaddps xmm0, xmm1, xmmword ptr [bx+1*si-0x10]");
    TEST64("\x62\xf1\x74\x08\x58\x40\xff", "vaddps xmm0, xmm1, xmmword ptr [rax-0x10]");
    TEST64("\x67\x62\xf1\x74\x08\x58\x40\xff", "vaddps xmm0, xmm1, xmmword ptr [eax-0x10]");
    TEST32("\x62\xf1\x74\x0a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax-0x10]");
    TEST32("\x67\x62\xf1\x74\x0a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, xmmword ptr [bx+1*si-0x10]");
    TEST64("\x62\xf1\x74\x0a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, xmmword ptr [rax-0x10]");
    TEST64("\x67\x62\xf1\x74\x0a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax-0x10]");
    TEST32("\x62\xf1\x74\x8a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax-0x10]");
    TEST32("\x67\x62\xf1\x74\x8a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [bx+1*si-0x10]");
    TEST64("\x62\xf1\x74\x8a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [rax-0x10]");
    TEST64("\x67\x62\xf1\x74\x8a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax-0x10]");
    TEST32("\x62\xf1\x74\x88\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x88\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x88\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x88\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x18\x58\x40\xff", "vaddps xmm0, xmm1, dword ptr [eax-0x4]{1to4}");
    TEST32("\x67\x62\xf1\x74\x18\x58\x40\xff", "vaddps xmm0, xmm1, dword ptr [bx+1*si-0x4]{1to4}");
    TEST64("\x62\xf1\x74\x18\x58\x40\xff", "vaddps xmm0, xmm1, dword ptr [rax-0x4]{1to4}");
    TEST64("\x67\x62\xf1\x74\x18\x58\x40\xff", "vaddps xmm0, xmm1, dword ptr [eax-0x4]{1to4}");
    TEST32("\x62\xf1\x74\x1a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, dword ptr [eax-0x4]{1to4}");
    TEST32("\x67\x62\xf1\x74\x1a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, dword ptr [bx+1*si-0x4]{1to4}");
    TEST64("\x62\xf1\x74\x1a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, dword ptr [rax-0x4]{1to4}");
    TEST64("\x67\x62\xf1\x74\x1a\x58\x40\xff", "vaddps xmm0{k2}, xmm1, dword ptr [eax-0x4]{1to4}");
    TEST32("\x62\xf1\x74\x9a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax-0x4]{1to4}");
    TEST32("\x67\x62\xf1\x74\x9a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, dword ptr [bx+1*si-0x4]{1to4}");
    TEST64("\x62\xf1\x74\x9a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, dword ptr [rax-0x4]{1to4}");
    TEST64("\x67\x62\xf1\x74\x9a\x58\x40\xff", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax-0x4]{1to4}");
    TEST32("\x62\xf1\x74\x98\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x98\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x98\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x98\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x28\x58\x40\xff", "vaddps ymm0, ymm1, ymmword ptr [eax-0x20]");
    TEST32("\x67\x62\xf1\x74\x28\x58\x40\xff", "vaddps ymm0, ymm1, ymmword ptr [bx+1*si-0x20]");
    TEST64("\x62\xf1\x74\x28\x58\x40\xff", "vaddps ymm0, ymm1, ymmword ptr [rax-0x20]");
    TEST64("\x67\x62\xf1\x74\x28\x58\x40\xff", "vaddps ymm0, ymm1, ymmword ptr [eax-0x20]");
    TEST32("\x62\xf1\x74\x2a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax-0x20]");
    TEST32("\x67\x62\xf1\x74\x2a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, ymmword ptr [bx+1*si-0x20]");
    TEST64("\x62\xf1\x74\x2a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, ymmword ptr [rax-0x20]");
    TEST64("\x67\x62\xf1\x74\x2a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax-0x20]");
    TEST32("\x62\xf1\x74\xaa\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax-0x20]");
    TEST32("\x67\x62\xf1\x74\xaa\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [bx+1*si-0x20]");
    TEST64("\x62\xf1\x74\xaa\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [rax-0x20]");
    TEST64("\x67\x62\xf1\x74\xaa\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax-0x20]");
    TEST32("\x62\xf1\x74\xa8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xa8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xa8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xa8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x38\x58\x40\xff", "vaddps ymm0, ymm1, dword ptr [eax-0x4]{1to8}");
    TEST32("\x67\x62\xf1\x74\x38\x58\x40\xff", "vaddps ymm0, ymm1, dword ptr [bx+1*si-0x4]{1to8}");
    TEST64("\x62\xf1\x74\x38\x58\x40\xff", "vaddps ymm0, ymm1, dword ptr [rax-0x4]{1to8}");
    TEST64("\x67\x62\xf1\x74\x38\x58\x40\xff", "vaddps ymm0, ymm1, dword ptr [eax-0x4]{1to8}");
    TEST32("\x62\xf1\x74\x3a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, dword ptr [eax-0x4]{1to8}");
    TEST32("\x67\x62\xf1\x74\x3a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, dword ptr [bx+1*si-0x4]{1to8}");
    TEST64("\x62\xf1\x74\x3a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, dword ptr [rax-0x4]{1to8}");
    TEST64("\x67\x62\xf1\x74\x3a\x58\x40\xff", "vaddps ymm0{k2}, ymm1, dword ptr [eax-0x4]{1to8}");
    TEST32("\x62\xf1\x74\xba\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax-0x4]{1to8}");
    TEST32("\x67\x62\xf1\x74\xba\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, dword ptr [bx+1*si-0x4]{1to8}");
    TEST64("\x62\xf1\x74\xba\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, dword ptr [rax-0x4]{1to8}");
    TEST64("\x67\x62\xf1\x74\xba\x58\x40\xff", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax-0x4]{1to8}");
    TEST32("\x62\xf1\x74\xb8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xb8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xb8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xb8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x48\x58\x40\xff", "vaddps zmm0, zmm1, zmmword ptr [eax-0x40]");
    TEST32("\x67\x62\xf1\x74\x48\x58\x40\xff", "vaddps zmm0, zmm1, zmmword ptr [bx+1*si-0x40]");
    TEST64("\x62\xf1\x74\x48\x58\x40\xff", "vaddps zmm0, zmm1, zmmword ptr [rax-0x40]");
    TEST64("\x67\x62\xf1\x74\x48\x58\x40\xff", "vaddps zmm0, zmm1, zmmword ptr [eax-0x40]");
    TEST32("\x62\xf1\x74\x4a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax-0x40]");
    TEST32("\x67\x62\xf1\x74\x4a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, zmmword ptr [bx+1*si-0x40]");
    TEST64("\x62\xf1\x74\x4a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, zmmword ptr [rax-0x40]");
    TEST64("\x67\x62\xf1\x74\x4a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax-0x40]");
    TEST32("\x62\xf1\x74\xca\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax-0x40]");
    TEST32("\x67\x62\xf1\x74\xca\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [bx+1*si-0x40]");
    TEST64("\x62\xf1\x74\xca\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [rax-0x40]");
    TEST64("\x67\x62\xf1\x74\xca\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax-0x40]");
    TEST32("\x62\xf1\x74\xc8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xc8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xc8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xc8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x58\x58\x40\xff", "vaddps zmm0, zmm1, dword ptr [eax-0x4]{1to16}");
    TEST32("\x67\x62\xf1\x74\x58\x58\x40\xff", "vaddps zmm0, zmm1, dword ptr [bx+1*si-0x4]{1to16}");
    TEST64("\x62\xf1\x74\x58\x58\x40\xff", "vaddps zmm0, zmm1, dword ptr [rax-0x4]{1to16}");
    TEST64("\x67\x62\xf1\x74\x58\x58\x40\xff", "vaddps zmm0, zmm1, dword ptr [eax-0x4]{1to16}");
    TEST32("\x62\xf1\x74\x5a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, dword ptr [eax-0x4]{1to16}");
    TEST32("\x67\x62\xf1\x74\x5a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, dword ptr [bx+1*si-0x4]{1to16}");
    TEST64("\x62\xf1\x74\x5a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, dword ptr [rax-0x4]{1to16}");
    TEST64("\x67\x62\xf1\x74\x5a\x58\x40\xff", "vaddps zmm0{k2}, zmm1, dword ptr [eax-0x4]{1to16}");
    TEST32("\x62\xf1\x74\xda\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax-0x4]{1to16}");
    TEST32("\x67\x62\xf1\x74\xda\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, dword ptr [bx+1*si-0x4]{1to16}");
    TEST64("\x62\xf1\x74\xda\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, dword ptr [rax-0x4]{1to16}");
    TEST64("\x67\x62\xf1\x74\xda\x58\x40\xff", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax-0x4]{1to16}");
    TEST32("\x62\xf1\x74\xd8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xd8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xd8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xd8\x58\x40\xff", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x68\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x68\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x68\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x68\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x6a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x6a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x6a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x6a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xea\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xea\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xea\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xea\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xe8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xe8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xe8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xe8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x78\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x78\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x78\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x78\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x7a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x7a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x7a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x7a\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xfa\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xfa\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xfa\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xfa\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xf8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xf8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xf8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xf8\x58\x40\xff", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x08\x58\x80\x01\x00\x00\x00", "vaddps xmm0, xmm1, xmmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x08\x58\x80\x01\x00", "vaddps xmm0, xmm1, xmmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x08\x58\x80\x01\x00\x00\x00", "vaddps xmm0, xmm1, xmmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x08\x58\x80\x01\x00\x00\x00", "vaddps xmm0, xmm1, xmmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\x0a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x0a\x58\x80\x01\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x0a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x0a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}, xmm1, xmmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\x8a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x8a\x58\x80\x01\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x8a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x8a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}{z}, xmm1, xmmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\x88\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x88\x58\x80\x01\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x88\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x88\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x18\x58\x80\x01\x00\x00\x00", "vaddps xmm0, xmm1, dword ptr [eax+0x1]{1to4}");
    TEST32("\x67\x62\xf1\x74\x18\x58\x80\x01\x00", "vaddps xmm0, xmm1, dword ptr [bx+1*si+0x1]{1to4}");
    TEST64("\x62\xf1\x74\x18\x58\x80\x01\x00\x00\x00", "vaddps xmm0, xmm1, dword ptr [rax+0x1]{1to4}");
    TEST64("\x67\x62\xf1\x74\x18\x58\x80\x01\x00\x00\x00", "vaddps xmm0, xmm1, dword ptr [eax+0x1]{1to4}");
    TEST32("\x62\xf1\x74\x1a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}, xmm1, dword ptr [eax+0x1]{1to4}");
    TEST32("\x67\x62\xf1\x74\x1a\x58\x80\x01\x00", "vaddps xmm0{k2}, xmm1, dword ptr [bx+1*si+0x1]{1to4}");
    TEST64("\x62\xf1\x74\x1a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}, xmm1, dword ptr [rax+0x1]{1to4}");
    TEST64("\x67\x62\xf1\x74\x1a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}, xmm1, dword ptr [eax+0x1]{1to4}");
    TEST32("\x62\xf1\x74\x9a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax+0x1]{1to4}");
    TEST32("\x67\x62\xf1\x74\x9a\x58\x80\x01\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [bx+1*si+0x1]{1to4}");
    TEST64("\x62\xf1\x74\x9a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [rax+0x1]{1to4}");
    TEST64("\x67\x62\xf1\x74\x9a\x58\x80\x01\x00\x00\x00", "vaddps xmm0{k2}{z}, xmm1, dword ptr [eax+0x1]{1to4}");
    TEST32("\x62\xf1\x74\x98\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\x98\x58\x80\x01\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\x98\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\x98\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x28\x58\x80\x01\x00\x00\x00", "vaddps ymm0, ymm1, ymmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x28\x58\x80\x01\x00", "vaddps ymm0, ymm1, ymmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x28\x58\x80\x01\x00\x00\x00", "vaddps ymm0, ymm1, ymmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x28\x58\x80\x01\x00\x00\x00", "vaddps ymm0, ymm1, ymmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\x2a\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x2a\x58\x80\x01\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x2a\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x2a\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}, ymm1, ymmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\xaa\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\xaa\x58\x80\x01\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\xaa\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\xaa\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}{z}, ymm1, ymmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\xa8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xa8\x58\x80\x01\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xa8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xa8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x38\x58\x80\x01\x00\x00\x00", "vaddps ymm0, ymm1, dword ptr [eax+0x1]{1to8}");
    TEST32("\x67\x62\xf1\x74\x38\x58\x80\x01\x00", "vaddps ymm0, ymm1, dword ptr [bx+1*si+0x1]{1to8}");
    TEST64("\x62\xf1\x74\x38\x58\x80\x01\x00\x00\x00", "vaddps ymm0, ymm1, dword ptr [rax+0x1]{1to8}");
    TEST64("\x67\x62\xf1\x74\x38\x58\x80\x01\x00\x00\x00", "vaddps ymm0, ymm1, dword ptr [eax+0x1]{1to8}");
    TEST32("\x62\xf1\x74\x3a\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}, ymm1, dword ptr [eax+0x1]{1to8}");
    TEST32("\x67\x62\xf1\x74\x3a\x58\x80\x01\x00", "vaddps ymm0{k2}, ymm1, dword ptr [bx+1*si+0x1]{1to8}");
    TEST64("\x62\xf1\x74\x3a\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}, ymm1, dword ptr [rax+0x1]{1to8}");
    TEST64("\x67\x62\xf1\x74\x3a\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}, ymm1, dword ptr [eax+0x1]{1to8}");
    TEST32("\x62\xf1\x74\xba\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax+0x1]{1to8}");
    TEST32("\x67\x62\xf1\x74\xba\x58\x80\x01\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [bx+1*si+0x1]{1to8}");
    TEST64("\x62\xf1\x74\xba\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [rax+0x1]{1to8}");
    TEST64("\x67\x62\xf1\x74\xba\x58\x80\x01\x00\x00\x00", "vaddps ymm0{k2}{z}, ymm1, dword ptr [eax+0x1]{1to8}");
    TEST32("\x62\xf1\x74\xb8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xb8\x58\x80\x01\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xb8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xb8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x48\x58\x80\x01\x00\x00\x00", "vaddps zmm0, zmm1, zmmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x48\x58\x80\x01\x00", "vaddps zmm0, zmm1, zmmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x48\x58\x80\x01\x00\x00\x00", "vaddps zmm0, zmm1, zmmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x48\x58\x80\x01\x00\x00\x00", "vaddps zmm0, zmm1, zmmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\x4a\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\x4a\x58\x80\x01\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\x4a\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\x4a\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}, zmm1, zmmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\xca\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax+0x1]");
    TEST32("\x67\x62\xf1\x74\xca\x58\x80\x01\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [bx+1*si+0x1]");
    TEST64("\x62\xf1\x74\xca\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [rax+0x1]");
    TEST64("\x67\x62\xf1\x74\xca\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}{z}, zmm1, zmmword ptr [eax+0x1]");
    TEST32("\x62\xf1\x74\xc8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xc8\x58\x80\x01\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xc8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xc8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x58\x58\x80\x01\x00\x00\x00", "vaddps zmm0, zmm1, dword ptr [eax+0x1]{1to16}");
    TEST32("\x67\x62\xf1\x74\x58\x58\x80\x01\x00", "vaddps zmm0, zmm1, dword ptr [bx+1*si+0x1]{1to16}");
    TEST64("\x62\xf1\x74\x58\x58\x80\x01\x00\x00\x00", "vaddps zmm0, zmm1, dword ptr [rax+0x1]{1to16}");
    TEST64("\x67\x62\xf1\x74\x58\x58\x80\x01\x00\x00\x00", "vaddps zmm0, zmm1, dword ptr [eax+0x1]{1to16}");
    TEST32("\x62\xf1\x74\x5a\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}, zmm1, dword ptr [eax+0x1]{1to16}");
    TEST32("\x67\x62\xf1\x74\x5a\x58\x80\x01\x00", "vaddps zmm0{k2}, zmm1, dword ptr [bx+1*si+0x1]{1to16}");
    TEST64("\x62\xf1\x74\x5a\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}, zmm1, dword ptr [rax+0x1]{1to16}");
    TEST64("\x67\x62\xf1\x74\x5a\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}, zmm1, dword ptr [eax+0x1]{1to16}");
    TEST32("\x62\xf1\x74\xda\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax+0x1]{1to16}");
    TEST32("\x67\x62\xf1\x74\xda\x58\x80\x01\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [bx+1*si+0x1]{1to16}");
    TEST64("\x62\xf1\x74\xda\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [rax+0x1]{1to16}");
    TEST64("\x67\x62\xf1\x74\xda\x58\x80\x01\x00\x00\x00", "vaddps zmm0{k2}{z}, zmm1, dword ptr [eax+0x1]{1to16}");
    TEST32("\x62\xf1\x74\xd8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf1\x74\xd8\x58\x80\x01\x00", "UD"); // EVEX.z = 1
    TEST64("\x62\xf1\x74\xd8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf1\x74\xd8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.z = 1
    TEST32("\x62\xf1\x74\x68\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x68\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x68\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x68\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x6a\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x6a\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x6a\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x6a\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xea\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xea\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xea\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xea\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xe8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xe8\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xe8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xe8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x78\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x78\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x78\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x78\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\x7a\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\x7a\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\x7a\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\x7a\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xfa\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xfa\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xfa\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xfa\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x62\xf1\x74\xf8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST32("\x67\x62\xf1\x74\xf8\x58\x80\x01\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x62\xf1\x74\xf8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11
    TEST64("\x67\x62\xf1\x74\xf8\x58\x80\x01\x00\x00\x00", "UD"); // EVEX.L'L = 11

    // Test register extensions encoded in EVEX prefixs
    TEST3264("\x62\xf1\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm0, xmm1, xmm2");
    TEST3264("\x62\xd1\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm0, xmm1, xmm10");
    TEST64("\x62\xb1\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm18");
    TEST64("\x62\x91\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm26");
    TEST3264("\x62\xf1\x34\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm0, xmm9, xmm2");
    TEST3264("\x62\xd1\x34\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm0, xmm9, xmm10");
    TEST64("\x62\xb1\x34\x08\x58\xc2", "vaddps xmm0, xmm9, xmm18");
    TEST64("\x62\x91\x34\x08\x58\xc2", "vaddps xmm0, xmm9, xmm26");
    TEST3264("\x62\xf1\x74\x00\x58\xc2", "UD", "vaddps xmm0, xmm17, xmm2"); // EVEX.V' = 0
    TEST3264("\x62\xd1\x74\x00\x58\xc2", "UD", "vaddps xmm0, xmm17, xmm10"); // EVEX.V' = 0
    TEST64("\x62\xb1\x74\x00\x58\xc2", "vaddps xmm0, xmm17, xmm18");
    TEST64("\x62\x91\x74\x00\x58\xc2", "vaddps xmm0, xmm17, xmm26");
    TEST3264("\x62\xf1\x34\x00\x58\xc2", "UD", "vaddps xmm0, xmm25, xmm2"); // EVEX.V' = 0
    TEST3264("\x62\xd1\x34\x00\x58\xc2", "UD", "vaddps xmm0, xmm25, xmm10"); // EVEX.V' = 0
    TEST64("\x62\xb1\x34\x00\x58\xc2", "vaddps xmm0, xmm25, xmm18");
    TEST64("\x62\x91\x34\x00\x58\xc2", "vaddps xmm0, xmm25, xmm26");
    TEST64("\x62\x71\x74\x08\x58\xc2", "vaddps xmm8, xmm1, xmm2");
    TEST64("\x62\x51\x74\x08\x58\xc2", "vaddps xmm8, xmm1, xmm10");
    TEST64("\x62\x31\x74\x08\x58\xc2", "vaddps xmm8, xmm1, xmm18");
    TEST64("\x62\x11\x74\x08\x58\xc2", "vaddps xmm8, xmm1, xmm26");
    TEST64("\x62\x71\x34\x08\x58\xc2", "vaddps xmm8, xmm9, xmm2");
    TEST64("\x62\x51\x34\x08\x58\xc2", "vaddps xmm8, xmm9, xmm10");
    TEST64("\x62\x31\x34\x08\x58\xc2", "vaddps xmm8, xmm9, xmm18");
    TEST64("\x62\x11\x34\x08\x58\xc2", "vaddps xmm8, xmm9, xmm26");
    TEST64("\x62\x71\x74\x00\x58\xc2", "vaddps xmm8, xmm17, xmm2");
    TEST64("\x62\x51\x74\x00\x58\xc2", "vaddps xmm8, xmm17, xmm10");
    TEST64("\x62\x31\x74\x00\x58\xc2", "vaddps xmm8, xmm17, xmm18");
    TEST64("\x62\x11\x74\x00\x58\xc2", "vaddps xmm8, xmm17, xmm26");
    TEST64("\x62\x71\x34\x00\x58\xc2", "vaddps xmm8, xmm25, xmm2");
    TEST64("\x62\x51\x34\x00\x58\xc2", "vaddps xmm8, xmm25, xmm10");
    TEST64("\x62\x31\x34\x00\x58\xc2", "vaddps xmm8, xmm25, xmm18");
    TEST64("\x62\x11\x34\x00\x58\xc2", "vaddps xmm8, xmm25, xmm26");
    TEST3264("\x62\xe1\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm16, xmm1, xmm2");
    TEST3264("\x62\xc1\x74\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm16, xmm1, xmm10");
    TEST64("\x62\xa1\x74\x08\x58\xc2", "vaddps xmm16, xmm1, xmm18");
    TEST64("\x62\x81\x74\x08\x58\xc2", "vaddps xmm16, xmm1, xmm26");
    TEST3264("\x62\xe1\x34\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm16, xmm9, xmm2");
    TEST3264("\x62\xc1\x34\x08\x58\xc2", "vaddps xmm0, xmm1, xmm2", "vaddps xmm16, xmm9, xmm10");
    TEST64("\x62\xa1\x34\x08\x58\xc2", "vaddps xmm16, xmm9, xmm18");
    TEST64("\x62\x81\x34\x08\x58\xc2", "vaddps xmm16, xmm9, xmm26");
    TEST3264("\x62\xe1\x74\x00\x58\xc2", "UD", "vaddps xmm16, xmm17, xmm2"); // EVEX.V' = 0
    TEST3264("\x62\xc1\x74\x00\x58\xc2", "UD", "vaddps xmm16, xmm17, xmm10"); // EVEX.V' = 0
    TEST64("\x62\xa1\x74\x00\x58\xc2", "vaddps xmm16, xmm17, xmm18");
    TEST64("\x62\x81\x74\x00\x58\xc2", "vaddps xmm16, xmm17, xmm26");
    TEST3264("\x62\xe1\x34\x00\x58\xc2", "UD", "vaddps xmm16, xmm25, xmm2"); // EVEX.V' = 0
    TEST3264("\x62\xc1\x34\x00\x58\xc2", "UD", "vaddps xmm16, xmm25, xmm10"); // EVEX.V' = 0
    TEST64("\x62\xa1\x34\x00\x58\xc2", "vaddps xmm16, xmm25, xmm18");
    TEST64("\x62\x81\x34\x00\x58\xc2", "vaddps xmm16, xmm25, xmm26");
    TEST64("\x62\x61\x74\x08\x58\xc2", "vaddps xmm24, xmm1, xmm2");
    TEST64("\x62\x41\x74\x08\x58\xc2", "vaddps xmm24, xmm1, xmm10");
    TEST64("\x62\x21\x74\x08\x58\xc2", "vaddps xmm24, xmm1, xmm18");
    TEST64("\x62\x01\x74\x08\x58\xc2", "vaddps xmm24, xmm1, xmm26");
    TEST64("\x62\x61\x34\x08\x58\xc2", "vaddps xmm24, xmm9, xmm2");
    TEST64("\x62\x41\x34\x08\x58\xc2", "vaddps xmm24, xmm9, xmm10");
    TEST64("\x62\x21\x34\x08\x58\xc2", "vaddps xmm24, xmm9, xmm18");
    TEST64("\x62\x01\x34\x08\x58\xc2", "vaddps xmm24, xmm9, xmm26");
    TEST64("\x62\x61\x74\x00\x58\xc2", "vaddps xmm24, xmm17, xmm2");
    TEST64("\x62\x41\x74\x00\x58\xc2", "vaddps xmm24, xmm17, xmm10");
    TEST64("\x62\x21\x74\x00\x58\xc2", "vaddps xmm24, xmm17, xmm18");
    TEST64("\x62\x01\x74\x00\x58\xc2", "vaddps xmm24, xmm17, xmm26");
    TEST64("\x62\x61\x34\x00\x58\xc2", "vaddps xmm24, xmm25, xmm2");
    TEST64("\x62\x41\x34\x00\x58\xc2", "vaddps xmm24, xmm25, xmm10");
    TEST64("\x62\x21\x34\x00\x58\xc2", "vaddps xmm24, xmm25, xmm18");
    TEST64("\x62\x01\x34\x00\x58\xc2", "vaddps xmm24, xmm25, xmm26");

    // VMOVDDUP has special tuple size for L0.
    TEST("\x62\xf1\xff\x08\x12\x48\x01", "vmovddup xmm1, qword ptr [@ax+0x8]");
    TEST("\x62\xf1\xff\x08\x12\xc8", "vmovddup xmm1, xmm0");
    TEST("\x62\xf1\xff\x28\x12\x48\x01", "vmovddup ymm1, ymmword ptr [@ax+0x20]");
    TEST("\x62\xf1\xff\x28\x12\xc8", "vmovddup ymm1, ymm0");
    TEST("\x62\xf1\xff\x48\x12\x48\x01", "vmovddup zmm1, zmmword ptr [@ax+0x40]");
    TEST("\x62\xf1\xff\x48\x12\xc8", "vmovddup zmm1, zmm0");

    // Check EVEX.L'L constraints
    TEST("\x62\xf2\x7d\x08\x18\x48\x01", "vbroadcastss xmm1, dword ptr [@ax+0x4]");
    TEST("\x62\xf2\x7d\x08\x18\xc8", "vbroadcastss xmm1, xmm0");
    TEST("\x62\xf2\x7d\x28\x18\x48\x01", "vbroadcastss ymm1, dword ptr [@ax+0x4]");
    TEST("\x62\xf2\x7d\x28\x18\xc8", "vbroadcastss ymm1, xmm0");
    TEST("\x62\xf2\x7d\x48\x18\x48\x01", "vbroadcastss zmm1, dword ptr [@ax+0x4]");
    TEST("\x62\xf2\x7d\x48\x18\xc8", "vbroadcastss zmm1, xmm0");
    TEST("\x62\xf2\x7d\x68\x18\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x68\x18\xc8", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x08\x19\x48\x01", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\x7d\x08\x19\xc8", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\x7d\x28\x19\x48\x01", "vbroadcastf32x2 ymm1, qword ptr [@ax+0x8]");
    TEST("\x62\xf2\x7d\x28\x19\xc8", "vbroadcastf32x2 ymm1, xmm0");
    TEST("\x62\xf2\x7d\x48\x19\x48\x01", "vbroadcastf32x2 zmm1, qword ptr [@ax+0x8]");
    TEST("\x62\xf2\x7d\x48\x19\xc8", "vbroadcastf32x2 zmm1, xmm0");
    TEST("\x62\xf2\x7d\x68\x19\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x68\x19\xc8", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\xfd\x08\x19\x48\x01", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\xfd\x08\x19\xc8", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\xfd\x28\x19\x48\x01", "vbroadcastsd ymm1, qword ptr [@ax+0x8]");
    TEST("\x62\xf2\xfd\x28\x19\xc8", "vbroadcastsd ymm1, xmm0");
    TEST("\x62\xf2\xfd\x48\x19\x48\x01", "vbroadcastsd zmm1, qword ptr [@ax+0x8]");
    TEST("\x62\xf2\xfd\x48\x19\xc8", "vbroadcastsd zmm1, xmm0");
    TEST("\x62\xf2\xfd\x68\x19\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\xfd\x68\x19\xc8", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x08\x1a\x48\x01", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\x7d\x08\x1a\xc8", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\x7d\x28\x1a\x48\x01", "vbroadcastf32x4 ymm1, xmmword ptr [@ax+0x10]");
    TEST("\x62\xf2\x7d\x28\x1a\xc8", "UD"); // must have a memory operand
    TEST("\x62\xf2\x7d\x48\x1a\x48\x01", "vbroadcastf32x4 zmm1, xmmword ptr [@ax+0x10]");
    TEST("\x62\xf2\x7d\x48\x1a\xc8", "UD"); // must have a memory operand
    TEST("\x62\xf2\x7d\x68\x1a\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x68\x1a\xc8", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\xfd\x08\x1a\x48\x01", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\xfd\x08\x1a\xc8", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\xfd\x28\x1a\x48\x01", "vbroadcastf64x2 ymm1, xmmword ptr [@ax+0x10]");
    TEST("\x62\xf2\xfd\x28\x1a\xc8", "UD"); // must have a memory operand
    TEST("\x62\xf2\xfd\x48\x1a\x48\x01", "vbroadcastf64x2 zmm1, xmmword ptr [@ax+0x10]");
    TEST("\x62\xf2\xfd\x48\x1a\xc8", "UD"); // must have a memory operand
    TEST("\x62\xf2\xfd\x68\x1a\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\xfd\x68\x1a\xc8", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x08\x1b\x48\x01", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\x7d\x08\x1b\xc8", "UD"); // EVEX.L'L = 0
    TEST3264("\x62\xf2\x7d\x28\x1b\x48\x01", "UD", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf2\x7d\x28\x1b\xc8", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf2\x7d\x48\x1b\x48\x01", "vbroadcastf32x8 zmm1, ymmword ptr [@ax+0x20]");
    TEST("\x62\xf2\x7d\x48\x1b\xc8", "UD"); // must have a memory operand
    TEST("\x62\xf2\x7d\x68\x1b\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x68\x1b\xc8", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\xfd\x08\x1b\x48\x01", "UD"); // EVEX.L'L = 0
    TEST("\x62\xf2\xfd\x08\x1b\xc8", "UD"); // EVEX.L'L = 0
    TEST3264("\x62\xf2\xfd\x28\x1b\x48\x01", "UD", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf2\xfd\x28\x1b\xc8", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf2\xfd\x48\x1b\x48\x01", "vbroadcastf64x4 zmm1, ymmword ptr [@ax+0x20]");
    TEST("\x62\xf2\xfd\x48\x1b\xc8", "UD"); // must have a memory operand
    TEST("\x62\xf2\xfd\x68\x1b\x48\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\xfd\x68\x1b\xc8", "UD"); // EVEX.L'L = 3

    // EVEX PEXTR/PINSR/MOV_G2X/MOV_X2G/PBROADCAST ignore EVEX.W in 32-bit mode
    // and have different mnemonics on due to this distinction.
    TEST("\x62\xf3\x7d\x08\x14\x00\x01", "vpextrb byte ptr [@ax], xmm0, 0x1");
    TEST("\x62\xf3\x7d\x08\x14\x40\x01\x01", "vpextrb byte ptr [@ax+0x1], xmm0, 0x1");
    TEST("\x62\xf3\x7d\x08\x14\xc0\x01", "vpextrb eax, xmm0, 0x1");
    TEST("\x62\xf3\x7d\x18\x14\xc0\x01", "UD"); // EVEX.b != 0
    TEST("\x62\xf3\x7d\x28\x14\xc0\x01", "UD"); // EVEX.L'L != 0
    TEST("\x62\xf3\x7d\x48\x14\xc0\x01", "UD"); // EVEX.L'L != 0
    TEST("\x62\xf3\x7d\x88\x14\xc0\x01", "UD"); // EVEX.z != 0
    TEST("\x62\xf3\x7d\x09\x14\xc0\x01", "UD"); // EVEX.aaa != 0
    TEST("\x62\xf3\x7d\x08\x15\x00\x01", "vpextrw word ptr [@ax], xmm0, 0x1");
    TEST("\x62\xf3\x7d\x08\x15\x40\x01\x01", "vpextrw word ptr [@ax+0x2], xmm0, 0x1");
    TEST("\x62\xf3\x7d\x08\x15\xc0\x01", "vpextrw eax, xmm0, 0x1");
    TEST("\x62\xf1\x7d\x08\xc5\xc0\x01", "vpextrw eax, xmm0, 0x1");
    TEST("\x62\xf1\x7d\x08\xc5\x00\x01", "UD"); // must have register operand
    TEST("\x62\xf3\x7d\x08\x16\x00\x01", "vpextrd dword ptr [@ax], xmm0, 0x1");
    TEST("\x62\xf3\x7d\x08\x16\x40\x01\x01", "vpextrd dword ptr [@ax+0x4], xmm0, 0x1");
    TEST("\x62\xf3\x7d\x08\x16\xc0\x01", "vpextrd eax, xmm0, 0x1");
    TEST3264("\x62\xf3\xfd\x08\x16\x00\x01", "vpextrd dword ptr [eax], xmm0, 0x1", "vpextrq qword ptr [rax], xmm0, 0x1"); // EVEX.W ignored
    TEST3264("\x62\xf3\xfd\x08\x16\x40\x01\x01", "vpextrd dword ptr [eax+0x4], xmm0, 0x1", "vpextrq qword ptr [rax+0x8], xmm0, 0x1"); // EVEX.W ignored
    TEST3264("\x62\xf3\xfd\x08\x16\xc0\x01", "vpextrd eax, xmm0, 0x1", "vpextrq rax, xmm0, 0x1"); // EVEX.W ignored
    TEST("\x62\xf3\x75\x08\x20\x00\x01", "vpinsrb xmm0, xmm1, byte ptr [@ax], 0x1");
    TEST("\x62\xf3\x75\x08\x20\x40\x01\x01", "vpinsrb xmm0, xmm1, byte ptr [@ax+0x1], 0x1");
    TEST("\x62\xf3\x75\x08\x20\xc0\x01", "vpinsrb xmm0, xmm1, al, 0x1");
    TEST("\x62\xf1\x75\x08\xc4\x00\x01", "vpinsrw xmm0, xmm1, word ptr [@ax], 0x1");
    TEST("\x62\xf1\x75\x08\xc4\x40\x01\x01", "vpinsrw xmm0, xmm1, word ptr [@ax+0x2], 0x1");
    TEST("\x62\xf1\x75\x08\xc4\xc0\x01", "vpinsrw xmm0, xmm1, ax, 0x1");
    TEST("\x62\xf3\x75\x08\x22\x00\x01", "vpinsrd xmm0, xmm1, dword ptr [@ax], 0x1");
    TEST("\x62\xf3\x75\x08\x22\x40\x01\x01", "vpinsrd xmm0, xmm1, dword ptr [@ax+0x4], 0x1");
    TEST("\x62\xf3\x75\x08\x22\xc0\x01", "vpinsrd xmm0, xmm1, eax, 0x1");
    TEST3264("\x62\xf3\xf5\x08\x22\x00\x01", "vpinsrd xmm0, xmm1, dword ptr [eax], 0x1", "vpinsrq xmm0, xmm1, qword ptr [rax], 0x1"); // EVEX.W ignored
    TEST3264("\x62\xf3\xf5\x08\x22\x40\x01\x01", "vpinsrd xmm0, xmm1, dword ptr [eax+0x4], 0x1", "vpinsrq xmm0, xmm1, qword ptr [rax+0x8], 0x1"); // EVEX.W ignored
    TEST3264("\x62\xf3\xf5\x08\x22\xc0\x01", "vpinsrd xmm0, xmm1, eax, 0x1", "vpinsrq xmm0, xmm1, rax, 0x1"); // EVEX.W ignored
    TEST("\x62\xf1\x7d\x08\x6e\x40\x01", "vmovd xmm0, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x7d\x28\x6e\x40\x01", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\x7d\x48\x6e\x40\x01", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\x7d\x68\x6e\x40\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf1\x7d\x08\x6e\xc1", "vmovd xmm0, ecx");
    TEST("\x62\xf1\x7d\x28\x6e\xc1", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\x7d\x48\x6e\xc1", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\x7d\x68\x6e\xc1", "UD"); // EVEX.L'L = 3
    TEST3264("\x62\xf1\xfd\x08\x6e\x40\x01", "vmovd xmm0, dword ptr [eax+0x4]", "vmovq xmm0, qword ptr [rax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xfd\x28\x6e\x40\x01", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\xfd\x48\x6e\x40\x01", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\xfd\x68\x6e\x40\x01", "UD"); // EVEX.L'L = 3
    TEST3264("\x62\xf1\xfd\x08\x6e\xc1", "vmovd xmm0, ecx", "vmovq xmm0, rcx"); // EVEX.W ignored
    TEST("\x62\xf1\xfd\x28\x6e\xc1", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\xfd\x48\x6e\xc1", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\xfd\x68\x6e\xc1", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf1\x7d\x08\x7e\x40\x01", "vmovd dword ptr [@ax+0x4], xmm0");
    TEST("\x62\xf1\x7d\x28\x7e\x40\x01", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\x7d\x48\x7e\x40\x01", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\x7d\x68\x7e\x40\x01", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf1\x7d\x08\x7e\xc1", "vmovd ecx, xmm0");
    TEST("\x62\xf1\x7d\x28\x7e\xc1", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\x7d\x48\x7e\xc1", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\x7d\x68\x7e\xc1", "UD"); // EVEX.L'L = 3
    TEST3264("\x62\xf1\xfd\x08\x7e\x40\x01", "vmovd dword ptr [eax+0x4], xmm0", "vmovq qword ptr [rax+0x8], xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xfd\x28\x7e\x40\x01", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\xfd\x48\x7e\x40\x01", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\xfd\x68\x7e\x40\x01", "UD"); // EVEX.L'L = 3
    TEST3264("\x62\xf1\xfd\x08\x7e\xc1", "vmovd ecx, xmm0", "vmovq rcx, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xfd\x28\x7e\xc1", "UD"); // EVEX.L'L = 1
    TEST("\x62\xf1\xfd\x48\x7e\xc1", "UD"); // EVEX.L'L = 2
    TEST("\x62\xf1\xfd\x68\x7e\xc1", "UD"); // EVEX.L'L = 3
    TEST("\x62\xf2\x7d\x08\x7a\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7d\x08\x7a\xc0", "vpbroadcastb xmm0, al");
    TEST("\x62\xf2\x7d\x28\x7a\xc0", "vpbroadcastb ymm0, al");
    TEST("\x62\xf2\x7d\x48\x7a\xc0", "vpbroadcastb zmm0, al");
    TEST("\x62\xf2\xfd\x08\x7a\xc0", "UD"); // EVEX.W = 1
    TEST("\x62\xf2\x7d\x18\x7a\xc0", "UD"); // EVEX.b = 1
    TEST("\x62\xf2\x7d\x09\x7a\xc0", "vpbroadcastb xmm0{k1}, al");
    TEST("\x62\xf2\x7d\x89\x7a\xc0", "vpbroadcastb xmm0{k1}{z}, al");
    TEST("\x62\xf2\x7d\x08\x7b\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7d\x08\x7b\xc0", "vpbroadcastw xmm0, ax");
    TEST("\x62\xf2\x7d\x28\x7b\xc0", "vpbroadcastw ymm0, ax");
    TEST("\x62\xf2\x7d\x48\x7b\xc0", "vpbroadcastw zmm0, ax");
    TEST("\x62\xf2\xfd\x08\x7b\xc0", "UD"); // EVEX.W = 1
    TEST("\x62\xf2\x7d\x18\x7b\xc0", "UD"); // EVEX.b = 1
    TEST("\x62\xf2\x7d\x09\x7b\xc0", "vpbroadcastw xmm0{k1}, ax");
    TEST("\x62\xf2\x7d\x89\x7b\xc0", "vpbroadcastw xmm0{k1}{z}, ax");
    TEST("\x62\xf2\x7d\x08\x7c\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7d\x08\x7c\xc0", "vpbroadcastd xmm0, eax");
    TEST("\x62\xf2\x7d\x28\x7c\xc0", "vpbroadcastd ymm0, eax");
    TEST("\x62\xf2\x7d\x48\x7c\xc0", "vpbroadcastd zmm0, eax");
    TEST("\x62\xf2\x7d\x18\x7c\xc0", "UD"); // EVEX.b = 1
    TEST("\x62\xf2\x7d\x09\x7c\xc0", "vpbroadcastd xmm0{k1}, eax");
    TEST("\x62\xf2\x7d\x89\x7c\xc0", "vpbroadcastd xmm0{k1}{z}, eax");
    TEST("\x62\xf2\xfd\x08\x7c\x00", "UD"); // Must have register operand
    TEST3264("\x62\xf2\xfd\x08\x7c\xc0", "vpbroadcastd xmm0, eax", "vpbroadcastq xmm0, rax"); // EVEX.W ignored
    TEST3264("\x62\xf2\xfd\x28\x7c\xc0", "vpbroadcastd ymm0, eax", "vpbroadcastq ymm0, rax"); // EVEX.W ignored
    TEST3264("\x62\xf2\xfd\x48\x7c\xc0", "vpbroadcastd zmm0, eax", "vpbroadcastq zmm0, rax"); // EVEX.W ignored
    TEST("\x62\xf2\xfd\x18\x7c\xc0", "UD"); // EVEX.b = 1
    TEST3264("\x62\xf2\xfd\x09\x7c\xc0", "vpbroadcastd xmm0{k1}, eax", "vpbroadcastq xmm0{k1}, rax"); // EVEX.W ignored
    TEST3264("\x62\xf2\xfd\x89\x7c\xc0", "vpbroadcastd xmm0{k1}{z}, eax", "vpbroadcastq xmm0{k1}{z}, rax"); // EVEX.W ignored

    // EVEX.z with memory or mask destination is UD
    TEST32("\x62\xf2\x7d\x08\x63\x40\x01", "vpcompressb byte ptr [eax+0x1], xmm0");
    TEST32("\x67\x62\xf2\x7d\x08\x63\x40\x01", "vpcompressb byte ptr [bx+1*si+0x1], xmm0");
    TEST64("\x62\xf2\x7d\x08\x63\x40\x01", "vpcompressb byte ptr [rax+0x1], xmm0");
    TEST64("\x67\x62\xf2\x7d\x08\x63\x40\x01", "vpcompressb byte ptr [eax+0x1], xmm0");
    TEST32("\x62\xf2\x7d\x88\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf2\x7d\x88\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf2\x7d\x88\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf2\x7d\x88\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x62\xf2\x7d\x09\x63\x40\x01", "vpcompressb byte ptr [eax+0x1]{k1}, xmm0");
    TEST32("\x67\x62\xf2\x7d\x09\x63\x40\x01", "vpcompressb byte ptr [bx+1*si+0x1]{k1}, xmm0");
    TEST64("\x62\xf2\x7d\x09\x63\x40\x01", "vpcompressb byte ptr [rax+0x1]{k1}, xmm0");
    TEST64("\x67\x62\xf2\x7d\x09\x63\x40\x01", "vpcompressb byte ptr [eax+0x1]{k1}, xmm0");
    TEST32("\x62\xf2\x7d\x89\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST32("\x67\x62\xf2\x7d\x89\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x62\xf2\x7d\x89\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST64("\x67\x62\xf2\x7d\x89\x63\x40\x01", "UD"); // EVEX.z = 1
    TEST("\x62\xf2\x7d\x08\x63\xc1", "vpcompressb xmm1, xmm0");
    TEST("\x62\xf2\x7d\x09\x63\xc1", "vpcompressb xmm1{k1}, xmm0");
    TEST("\x62\xf2\x7d\x88\x63\xc1", "UD"); // EVEX.z = 1
    TEST("\x62\xf2\x7d\x89\x63\xc1", "vpcompressb xmm1{k1}{z}, xmm0");
    TEST("\x62\xf1\x75\x08\x74\xc2", "vpcmpeqb k0, xmm1, xmm2");
    TEST("\x62\xf1\x75\x09\x74\xc2", "vpcmpeqb k0{k1}, xmm1, xmm2");
    TEST("\x62\xf1\x75\x88\x74\xc2", "UD"); // EVEX.z = 1
    TEST("\x62\xf1\x75\x89\x74\xc2", "UD"); // EVEX.z = 1

    // CVT(T?S[SD]2U?SI|U?SI2S[SD]) ignore EVEX.W in 32-bit mode.
    TEST("\x62\xf1\x7e\x08\x2c\x40\x01", "vcvttss2si eax, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x7e\x18\x2c\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7e\x08\x2c\xc0", "vcvttss2si eax, xmm0");
    TEST("\x62\xf1\x7e\x18\x2c\xc0", "vcvttss2si eax, xmm0, {sae}");
    TEST("\x62\xf1\xfe\x08\x2c\x40\x01", "vcvttss2si @ax, dword ptr [@ax+0x4]"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x08\x2c\xc0", "vcvttss2si @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x18\x2c\xc0", "vcvttss2si @ax, xmm0, {sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7f\x08\x2c\x40\x01", "vcvttsd2si eax, qword ptr [@ax+0x8]");
    TEST("\x62\xf1\x7f\x18\x2c\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7f\x08\x2c\xc0", "vcvttsd2si eax, xmm0");
    TEST("\x62\xf1\x7f\x18\x2c\xc0", "vcvttsd2si eax, xmm0, {sae}");
    TEST("\x62\xf1\xff\x08\x2c\x40\x01", "vcvttsd2si @ax, qword ptr [@ax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x08\x2c\xc0", "vcvttsd2si @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x18\x2c\xc0", "vcvttsd2si @ax, xmm0, {sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7e\x08\x2d\x40\x01", "vcvtss2si eax, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x7e\x18\x2d\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7e\x08\x2d\xc0", "vcvtss2si eax, xmm0");
    TEST("\x62\xf1\x7e\x18\x2d\xc0", "vcvtss2si eax, xmm0, {rn-sae}");
    TEST("\x62\xf1\xfe\x08\x2d\x40\x01", "vcvtss2si @ax, dword ptr [@ax+0x4]"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x08\x2d\xc0", "vcvtss2si @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x18\x2d\xc0", "vcvtss2si @ax, xmm0, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7f\x08\x2d\x40\x01", "vcvtsd2si eax, qword ptr [@ax+0x8]");
    TEST("\x62\xf1\x7f\x18\x2d\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7f\x08\x2d\xc0", "vcvtsd2si eax, xmm0");
    TEST("\x62\xf1\x7f\x18\x2d\xc0", "vcvtsd2si eax, xmm0, {rn-sae}");
    TEST("\x62\xf1\xff\x08\x2d\x40\x01", "vcvtsd2si @ax, qword ptr [@ax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x08\x2d\xc0", "vcvtsd2si @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x18\x2d\xc0", "vcvtsd2si @ax, xmm0, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7e\x08\x78\x40\x01", "vcvttss2usi eax, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x7e\x18\x78\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7e\x08\x78\xc0", "vcvttss2usi eax, xmm0");
    TEST("\x62\xf1\x7e\x18\x78\xc0", "vcvttss2usi eax, xmm0, {sae}");
    TEST("\x62\xf1\xfe\x08\x78\x40\x01", "vcvttss2usi @ax, dword ptr [@ax+0x4]"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x08\x78\xc0", "vcvttss2usi @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x18\x78\xc0", "vcvttss2usi @ax, xmm0, {sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7f\x08\x78\x40\x01", "vcvttsd2usi eax, qword ptr [@ax+0x8]");
    TEST("\x62\xf1\x7f\x18\x78\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7f\x08\x78\xc0", "vcvttsd2usi eax, xmm0");
    TEST("\x62\xf1\x7f\x18\x78\xc0", "vcvttsd2usi eax, xmm0, {sae}");
    TEST("\x62\xf1\xff\x08\x78\x40\x01", "vcvttsd2usi @ax, qword ptr [@ax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x08\x78\xc0", "vcvttsd2usi @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x18\x78\xc0", "vcvttsd2usi @ax, xmm0, {sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7e\x08\x79\x40\x01", "vcvtss2usi eax, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x7e\x18\x79\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7e\x08\x79\xc0", "vcvtss2usi eax, xmm0");
    TEST("\x62\xf1\x7e\x18\x79\xc0", "vcvtss2usi eax, xmm0, {rn-sae}");
    TEST("\x62\xf1\xfe\x08\x79\x40\x01", "vcvtss2usi @ax, dword ptr [@ax+0x4]"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x08\x79\xc0", "vcvtss2usi @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xfe\x18\x79\xc0", "vcvtss2usi @ax, xmm0, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x7f\x08\x79\x40\x01", "vcvtsd2usi eax, qword ptr [@ax+0x8]");
    TEST("\x62\xf1\x7f\x18\x79\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x7f\x08\x79\xc0", "vcvtsd2usi eax, xmm0");
    TEST("\x62\xf1\x7f\x18\x79\xc0", "vcvtsd2usi eax, xmm0, {rn-sae}");
    TEST("\x62\xf1\xff\x08\x79\x40\x01", "vcvtsd2usi @ax, qword ptr [@ax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x08\x79\xc0", "vcvtsd2usi @ax, xmm0"); // EVEX.W ignored
    TEST("\x62\xf1\xff\x18\x79\xc0", "vcvtsd2usi @ax, xmm0, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x6e\x08\x2a\x40\x01", "vcvtsi2ss xmm0, xmm2, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x6e\x18\x2a\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x6e\x08\x2a\xc0", "vcvtsi2ss xmm0, xmm2, eax");
    TEST("\x62\xf1\x6e\x18\x2a\xc0", "vcvtsi2ss xmm0, xmm2, eax, {rn-sae}");
    TEST3264("\x62\xf1\xee\x08\x2a\x40\x01", "vcvtsi2ss xmm0, xmm2, dword ptr [eax+0x4]", "vcvtsi2ss xmm0, xmm2, qword ptr [rax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xee\x08\x2a\xc0", "vcvtsi2ss xmm0, xmm2, @ax"); // EVEX.W ignored
    TEST("\x62\xf1\xee\x18\x2a\xc0", "vcvtsi2ss xmm0, xmm2, @ax, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x6f\x08\x2a\x40\x01", "vcvtsi2sd xmm0, xmm2, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x6f\x18\x2a\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x6f\x08\x2a\xc0", "vcvtsi2sd xmm0, xmm2, eax");
    TEST("\x62\xf1\x6f\x18\x2a\xc0", "vcvtsi2sd xmm0, xmm2, eax, {rn-sae}");
    TEST3264("\x62\xf1\xef\x08\x2a\x40\x01", "vcvtsi2sd xmm0, xmm2, dword ptr [eax+0x4]", "vcvtsi2sd xmm0, xmm2, qword ptr [rax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xef\x08\x2a\xc0", "vcvtsi2sd xmm0, xmm2, @ax"); // EVEX.W ignored
    TEST("\x62\xf1\xef\x18\x2a\xc0", "vcvtsi2sd xmm0, xmm2, @ax, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x6e\x08\x7b\x40\x01", "vcvtusi2ss xmm0, xmm2, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x6e\x18\x7b\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x6e\x08\x7b\xc0", "vcvtusi2ss xmm0, xmm2, eax");
    TEST("\x62\xf1\x6e\x18\x7b\xc0", "vcvtusi2ss xmm0, xmm2, eax, {rn-sae}");
    TEST3264("\x62\xf1\xee\x08\x7b\x40\x01", "vcvtusi2ss xmm0, xmm2, dword ptr [eax+0x4]", "vcvtusi2ss xmm0, xmm2, qword ptr [rax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xee\x08\x7b\xc0", "vcvtusi2ss xmm0, xmm2, @ax"); // EVEX.W ignored
    TEST("\x62\xf1\xee\x18\x7b\xc0", "vcvtusi2ss xmm0, xmm2, @ax, {rn-sae}"); // EVEX.W ignored
    TEST("\x62\xf1\x6f\x08\x7b\x40\x01", "vcvtusi2sd xmm0, xmm2, dword ptr [@ax+0x4]");
    TEST("\x62\xf1\x6f\x18\x7b\x40\x01", "UD"); // EVEX.b with memory operand
    TEST("\x62\xf1\x6f\x08\x7b\xc0", "vcvtusi2sd xmm0, xmm2, eax");
    TEST("\x62\xf1\x6f\x18\x7b\xc0", "vcvtusi2sd xmm0, xmm2, eax, {rn-sae}");
    TEST3264("\x62\xf1\xef\x08\x7b\x40\x01", "vcvtusi2sd xmm0, xmm2, dword ptr [eax+0x4]", "vcvtusi2sd xmm0, xmm2, qword ptr [rax+0x8]"); // EVEX.W ignored
    TEST("\x62\xf1\xef\x08\x7b\xc0", "vcvtusi2sd xmm0, xmm2, @ax"); // EVEX.W ignored
    TEST("\x62\xf1\xef\x18\x7b\xc0", "vcvtusi2sd xmm0, xmm2, @ax, {rn-sae}"); // EVEX.W ignored

    // 32-bit mode: no UD constraints for K-reg
    // 64-bit mode: EVEX.R/EVEX.vvvv=0xxx causes UD for K-reg; EVEX.B is ignored
    TEST("\xc5\xed\x41\x00", "UD"); // Must have register operand
    TEST("\xc5\xed\x41\xcb", "kandb k1, k2, k3");
    TEST("\xc4\xe1\x6d\x41\xcb", "kandb k1, k2, k3"); // 3-byte VEX encoding
    TEST("\xc4\xc1\x6d\x41\xcb", "kandb k1, k2, k3"); // VEX.B is ignored
    TEST64("\xc4\x61\x6d\x41\xcb", "UD"); // VEX.R is UD
    TEST3264("\xc4\xe1\x2d\x41\xcb", "kandb k1, k2, k3", "UD"); // 32-bit: VEX.vvvv MSB is ignored, 64-bit: VEX.vvvv = 0xxx
    TEST64("\xc5\xad\x41\xcb", "UD"); // VEX.vvvv = 0xxx

    TEST("\x62\xf2\x7e\x08\x28\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7e\x08\x28\xc1", "vpmovm2b xmm0, k1");
    TEST3264("\x62\xe2\x7e\x08\x28\xc1", "vpmovm2b xmm0, k1", "vpmovm2b xmm16, k1"); // EVEX.R' ignored
    TEST("\x62\xd2\x7e\x08\x28\xc1", "vpmovm2b xmm0, k1"); // EVEX.B ignored
    TEST64("\x62\xb2\x7e\x08\x28\xc1", "vpmovm2b xmm0, k1"); // EVEX.X ignored
    TEST64("\x62\x72\x7e\x08\x28\xc1", "vpmovm2b xmm8, k1");
    TEST("\x62\xf2\xfe\x08\x28\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\xfe\x08\x28\xc1", "vpmovm2w xmm0, k1");
    TEST3264("\x62\xe2\xfe\x08\x28\xc1", "vpmovm2w xmm0, k1", "vpmovm2w xmm16, k1"); // EVEX.R' ignored
    TEST("\x62\xd2\xfe\x08\x28\xc1", "vpmovm2w xmm0, k1"); // EVEX.B ignored
    TEST64("\x62\xb2\xfe\x08\x28\xc1", "vpmovm2w xmm0, k1"); // EVEX.X ignored
    TEST64("\x62\x72\xfe\x08\x28\xc1", "vpmovm2w xmm8, k1");
    TEST("\x62\xf2\x7e\x08\x38\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7e\x08\x38\xc1", "vpmovm2d xmm0, k1");
    TEST3264("\x62\xe2\x7e\x08\x38\xc1", "vpmovm2d xmm0, k1", "vpmovm2d xmm16, k1"); // EVEX.R' ignored
    TEST("\x62\xd2\x7e\x08\x38\xc1", "vpmovm2d xmm0, k1"); // EVEX.B ignored
    TEST64("\x62\xb2\x7e\x08\x38\xc1", "vpmovm2d xmm0, k1"); // EVEX.X ignored
    TEST64("\x62\x72\x7e\x08\x38\xc1", "vpmovm2d xmm8, k1");
    TEST("\x62\xf2\xfe\x08\x38\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\xfe\x08\x38\xc1", "vpmovm2q xmm0, k1");
    TEST3264("\x62\xe2\xfe\x08\x38\xc1", "vpmovm2q xmm0, k1", "vpmovm2q xmm16, k1"); // EVEX.R' ignored
    TEST("\x62\xd2\xfe\x08\x38\xc1", "vpmovm2q xmm0, k1"); // EVEX.B ignored
    TEST64("\x62\xb2\xfe\x08\x38\xc1", "vpmovm2q xmm0, k1"); // EVEX.X ignored
    TEST64("\x62\x72\xfe\x08\x38\xc1", "vpmovm2q xmm8, k1");

    TEST("\x62\xf2\x7e\x08\x29\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7e\x08\x29\xc1", "vpmovb2m k0, xmm1");
    TEST3264("\x62\xe2\x7e\x08\x29\xc1", "vpmovb2m k0, xmm1", "UD"); // 32-bit: EVEX.R' ignored, 64-bit: EVEX.R' for mask is UD
    TEST3264("\x62\xd2\x7e\x08\x29\xc1", "vpmovb2m k0, xmm1", "vpmovb2m k0, xmm9"); // EVEX.B ignored
    TEST64("\x62\xb2\x7e\x08\x29\xc1", "vpmovb2m k0, xmm17");
    TEST64("\x62\x72\x7e\x08\x29\xc1", "UD"); // EVEX.R for mask is UD
    TEST("\x62\xf2\xfe\x08\x29\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\xfe\x08\x29\xc1", "vpmovw2m k0, xmm1");
    TEST3264("\x62\xe2\xfe\x08\x29\xc1", "vpmovw2m k0, xmm1", "UD"); // 32-bit: EVEX.R' ignored, 64-bit: EVEX.R' for mask is UD
    TEST3264("\x62\xd2\xfe\x08\x29\xc1", "vpmovw2m k0, xmm1", "vpmovw2m k0, xmm9"); // EVEX.B ignored
    TEST64("\x62\xb2\xfe\x08\x29\xc1", "vpmovw2m k0, xmm17");
    TEST64("\x62\x72\xfe\x08\x29\xc1", "UD"); // EVEX.R for mask is UD
    TEST("\x62\xf2\x7e\x08\x39\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\x7e\x08\x39\xc1", "vpmovd2m k0, xmm1");
    TEST3264("\x62\xe2\x7e\x08\x39\xc1", "vpmovd2m k0, xmm1", "UD"); // 32-bit: EVEX.R' ignored, 64-bit: EVEX.R' for mask is UD
    TEST3264("\x62\xd2\x7e\x08\x39\xc1", "vpmovd2m k0, xmm1", "vpmovd2m k0, xmm9"); // EVEX.B ignored
    TEST64("\x62\xb2\x7e\x08\x39\xc1", "vpmovd2m k0, xmm17");
    TEST64("\x62\x72\x7e\x08\x39\xc1", "UD"); // EVEX.R for mask is UD
    TEST("\x62\xf2\xfe\x08\x39\x00", "UD"); // Must have register operand
    TEST("\x62\xf2\xfe\x08\x39\xc1", "vpmovq2m k0, xmm1");
    TEST3264("\x62\xe2\xfe\x08\x39\xc1", "vpmovq2m k0, xmm1", "UD"); // 32-bit: EVEX.R' ignored, 64-bit: EVEX.R' for mask is UD
    TEST3264("\x62\xd2\xfe\x08\x39\xc1", "vpmovq2m k0, xmm1", "vpmovq2m k0, xmm9"); // EVEX.B ignored
    TEST64("\x62\xb2\xfe\x08\x39\xc1", "vpmovq2m k0, xmm17");
    TEST64("\x62\x72\xfe\x08\x39\xc1", "UD"); // EVEX.R for mask is UD

    // VSIB encoding, test all combinations of EVEX.RXBR'V' once
    TEST("\x62\xf2\x7d\x0a\xa2\xcc", "UD"); // Must have memory operand
    TEST("\x62\xf2\x7d\x0a\xa2\x01", "UD"); // Must have SIB byte
    TEST("\x62\xf2\x7d\x08\xa2\x0c\xe7", "UD"); // EVEX.aaa = 000
    TEST3264("\x67\x62\xf2\x7d\x0a\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [edi+8*xmm4]{k2}, xmm1"); // VISB and 16-bit addrsize is UD
    TEST("\x62\xf2\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [@di+8*xmm4]{k2}, xmm1");
    TEST3264("\x62\xd2\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterdps dword ptr [r15+8*xmm4]{k2}, xmm1");
    TEST64("\x62\xb2\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm12]{k2}, xmm1");
    TEST64("\x62\x92\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm12]{k2}, xmm1");
    TEST3264("\x62\xf2\x7d\x02\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [rdi+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\x7d\x02\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [r15+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x92\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x72\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x52\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x32\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x12\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x72\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x52\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x32\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm28]{k2}, xmm9");
    TEST64("\x62\x12\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm28]{k2}, xmm9");
    TEST3264("\x62\xe2\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterdps dword ptr [rdi+8*xmm4]{k2}, xmm17");
    TEST3264("\x62\xc2\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterdps dword ptr [r15+8*xmm4]{k2}, xmm17");
    TEST64("\x62\xa2\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm12]{k2}, xmm17");
    TEST64("\x62\x82\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm12]{k2}, xmm17");
    TEST3264("\x62\xe2\x7d\x02\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [rdi+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\x7d\x02\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [r15+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x82\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x62\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x42\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x22\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x02\x7d\x0a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x62\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x42\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x22\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*xmm28]{k2}, xmm25");
    TEST64("\x62\x02\x7d\x02\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*xmm28]{k2}, xmm25");
    TEST("\x62\xf2\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [@di+8*ymm4]{k2}, ymm1");
    TEST3264("\x62\xd2\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*ymm4]{k2}, ymm1", "vscatterdps dword ptr [r15+8*ymm4]{k2}, ymm1");
    TEST64("\x62\xb2\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm12]{k2}, ymm1");
    TEST64("\x62\x92\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm12]{k2}, ymm1");
    TEST3264("\x62\xf2\x7d\x22\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [rdi+8*ymm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\x7d\x22\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [r15+8*ymm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm28]{k2}, ymm1");
    TEST64("\x62\x92\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm28]{k2}, ymm1");
    TEST64("\x62\x72\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm4]{k2}, ymm9");
    TEST64("\x62\x52\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm4]{k2}, ymm9");
    TEST64("\x62\x32\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm12]{k2}, ymm9");
    TEST64("\x62\x12\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm12]{k2}, ymm9");
    TEST64("\x62\x72\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm20]{k2}, ymm9");
    TEST64("\x62\x52\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm20]{k2}, ymm9");
    TEST64("\x62\x32\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm28]{k2}, ymm9");
    TEST64("\x62\x12\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm28]{k2}, ymm9");
    TEST3264("\x62\xe2\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*ymm4]{k2}, ymm1", "vscatterdps dword ptr [rdi+8*ymm4]{k2}, ymm17");
    TEST3264("\x62\xc2\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*ymm4]{k2}, ymm1", "vscatterdps dword ptr [r15+8*ymm4]{k2}, ymm17");
    TEST64("\x62\xa2\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm12]{k2}, ymm17");
    TEST64("\x62\x82\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm12]{k2}, ymm17");
    TEST3264("\x62\xe2\x7d\x22\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [rdi+8*ymm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\x7d\x22\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [r15+8*ymm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm28]{k2}, ymm17");
    TEST64("\x62\x82\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm28]{k2}, ymm17");
    TEST64("\x62\x62\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm4]{k2}, ymm25");
    TEST64("\x62\x42\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm4]{k2}, ymm25");
    TEST64("\x62\x22\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm12]{k2}, ymm25");
    TEST64("\x62\x02\x7d\x2a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm12]{k2}, ymm25");
    TEST64("\x62\x62\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm20]{k2}, ymm25");
    TEST64("\x62\x42\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm20]{k2}, ymm25");
    TEST64("\x62\x22\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*ymm28]{k2}, ymm25");
    TEST64("\x62\x02\x7d\x22\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*ymm28]{k2}, ymm25");
    TEST("\x62\xf2\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [@di+8*zmm4]{k2}, zmm1");
    TEST3264("\x62\xd2\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*zmm4]{k2}, zmm1", "vscatterdps dword ptr [r15+8*zmm4]{k2}, zmm1");
    TEST64("\x62\xb2\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm12]{k2}, zmm1");
    TEST64("\x62\x92\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm12]{k2}, zmm1");
    TEST3264("\x62\xf2\x7d\x42\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [rdi+8*zmm20]{k2}, zmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\x7d\x42\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [r15+8*zmm20]{k2}, zmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm28]{k2}, zmm1");
    TEST64("\x62\x92\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm28]{k2}, zmm1");
    TEST64("\x62\x72\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm4]{k2}, zmm9");
    TEST64("\x62\x52\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm4]{k2}, zmm9");
    TEST64("\x62\x32\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm12]{k2}, zmm9");
    TEST64("\x62\x12\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm12]{k2}, zmm9");
    TEST64("\x62\x72\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm20]{k2}, zmm9");
    TEST64("\x62\x52\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm20]{k2}, zmm9");
    TEST64("\x62\x32\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm28]{k2}, zmm9");
    TEST64("\x62\x12\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm28]{k2}, zmm9");
    TEST3264("\x62\xe2\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*zmm4]{k2}, zmm1", "vscatterdps dword ptr [rdi+8*zmm4]{k2}, zmm17");
    TEST3264("\x62\xc2\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [edi+8*zmm4]{k2}, zmm1", "vscatterdps dword ptr [r15+8*zmm4]{k2}, zmm17");
    TEST64("\x62\xa2\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm12]{k2}, zmm17");
    TEST64("\x62\x82\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm12]{k2}, zmm17");
    TEST3264("\x62\xe2\x7d\x42\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [rdi+8*zmm20]{k2}, zmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\x7d\x42\xa2\x0c\xe7", "UD", "vscatterdps dword ptr [r15+8*zmm20]{k2}, zmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm28]{k2}, zmm17");
    TEST64("\x62\x82\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm28]{k2}, zmm17");
    TEST64("\x62\x62\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm4]{k2}, zmm25");
    TEST64("\x62\x42\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm4]{k2}, zmm25");
    TEST64("\x62\x22\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm12]{k2}, zmm25");
    TEST64("\x62\x02\x7d\x4a\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm12]{k2}, zmm25");
    TEST64("\x62\x62\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm20]{k2}, zmm25");
    TEST64("\x62\x42\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm20]{k2}, zmm25");
    TEST64("\x62\x22\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [rdi+8*zmm28]{k2}, zmm25");
    TEST64("\x62\x02\x7d\x42\xa2\x0c\xe7", "vscatterdps dword ptr [r15+8*zmm28]{k2}, zmm25");
    TEST("\x62\xf2\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [@di+8*xmm4]{k2}, xmm1");
    TEST3264("\x62\xd2\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterqps dword ptr [r15+8*xmm4]{k2}, xmm1");
    TEST64("\x62\xb2\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm12]{k2}, xmm1");
    TEST64("\x62\x92\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm12]{k2}, xmm1");
    TEST3264("\x62\xf2\x7d\x02\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [rdi+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\x7d\x02\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [r15+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x92\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x72\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x52\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x32\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x12\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x72\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x52\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x32\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm28]{k2}, xmm9");
    TEST64("\x62\x12\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm28]{k2}, xmm9");
    TEST3264("\x62\xe2\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterqps dword ptr [rdi+8*xmm4]{k2}, xmm17");
    TEST3264("\x62\xc2\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterqps dword ptr [r15+8*xmm4]{k2}, xmm17");
    TEST64("\x62\xa2\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm12]{k2}, xmm17");
    TEST64("\x62\x82\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm12]{k2}, xmm17");
    TEST3264("\x62\xe2\x7d\x02\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [rdi+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\x7d\x02\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [r15+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x82\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x62\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x42\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x22\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x02\x7d\x0a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x62\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x42\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x22\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*xmm28]{k2}, xmm25");
    TEST64("\x62\x02\x7d\x02\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*xmm28]{k2}, xmm25");
    TEST("\x62\xf2\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [@di+8*ymm4]{k2}, xmm1");
    TEST3264("\x62\xd2\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*ymm4]{k2}, xmm1", "vscatterqps dword ptr [r15+8*ymm4]{k2}, xmm1");
    TEST64("\x62\xb2\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm12]{k2}, xmm1");
    TEST64("\x62\x92\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm12]{k2}, xmm1");
    TEST3264("\x62\xf2\x7d\x22\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [rdi+8*ymm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\x7d\x22\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [r15+8*ymm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm28]{k2}, xmm1");
    TEST64("\x62\x92\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm28]{k2}, xmm1");
    TEST64("\x62\x72\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm4]{k2}, xmm9");
    TEST64("\x62\x52\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm4]{k2}, xmm9");
    TEST64("\x62\x32\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm12]{k2}, xmm9");
    TEST64("\x62\x12\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm12]{k2}, xmm9");
    TEST64("\x62\x72\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm20]{k2}, xmm9");
    TEST64("\x62\x52\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm20]{k2}, xmm9");
    TEST64("\x62\x32\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm28]{k2}, xmm9");
    TEST64("\x62\x12\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm28]{k2}, xmm9");
    TEST3264("\x62\xe2\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*ymm4]{k2}, xmm1", "vscatterqps dword ptr [rdi+8*ymm4]{k2}, xmm17");
    TEST3264("\x62\xc2\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*ymm4]{k2}, xmm1", "vscatterqps dword ptr [r15+8*ymm4]{k2}, xmm17");
    TEST64("\x62\xa2\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm12]{k2}, xmm17");
    TEST64("\x62\x82\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm12]{k2}, xmm17");
    TEST3264("\x62\xe2\x7d\x22\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [rdi+8*ymm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\x7d\x22\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [r15+8*ymm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm28]{k2}, xmm17");
    TEST64("\x62\x82\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm28]{k2}, xmm17");
    TEST64("\x62\x62\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm4]{k2}, xmm25");
    TEST64("\x62\x42\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm4]{k2}, xmm25");
    TEST64("\x62\x22\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm12]{k2}, xmm25");
    TEST64("\x62\x02\x7d\x2a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm12]{k2}, xmm25");
    TEST64("\x62\x62\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm20]{k2}, xmm25");
    TEST64("\x62\x42\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm20]{k2}, xmm25");
    TEST64("\x62\x22\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*ymm28]{k2}, xmm25");
    TEST64("\x62\x02\x7d\x22\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*ymm28]{k2}, xmm25");
    TEST("\x62\xf2\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [@di+8*zmm4]{k2}, ymm1");
    TEST3264("\x62\xd2\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*zmm4]{k2}, ymm1", "vscatterqps dword ptr [r15+8*zmm4]{k2}, ymm1");
    TEST64("\x62\xb2\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm12]{k2}, ymm1");
    TEST64("\x62\x92\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm12]{k2}, ymm1");
    TEST3264("\x62\xf2\x7d\x42\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [rdi+8*zmm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\x7d\x42\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [r15+8*zmm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm28]{k2}, ymm1");
    TEST64("\x62\x92\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm28]{k2}, ymm1");
    TEST64("\x62\x72\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm4]{k2}, ymm9");
    TEST64("\x62\x52\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm4]{k2}, ymm9");
    TEST64("\x62\x32\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm12]{k2}, ymm9");
    TEST64("\x62\x12\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm12]{k2}, ymm9");
    TEST64("\x62\x72\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm20]{k2}, ymm9");
    TEST64("\x62\x52\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm20]{k2}, ymm9");
    TEST64("\x62\x32\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm28]{k2}, ymm9");
    TEST64("\x62\x12\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm28]{k2}, ymm9");
    TEST3264("\x62\xe2\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*zmm4]{k2}, ymm1", "vscatterqps dword ptr [rdi+8*zmm4]{k2}, ymm17");
    TEST3264("\x62\xc2\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [edi+8*zmm4]{k2}, ymm1", "vscatterqps dword ptr [r15+8*zmm4]{k2}, ymm17");
    TEST64("\x62\xa2\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm12]{k2}, ymm17");
    TEST64("\x62\x82\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm12]{k2}, ymm17");
    TEST3264("\x62\xe2\x7d\x42\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [rdi+8*zmm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\x7d\x42\xa3\x0c\xe7", "UD", "vscatterqps dword ptr [r15+8*zmm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm28]{k2}, ymm17");
    TEST64("\x62\x82\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm28]{k2}, ymm17");
    TEST64("\x62\x62\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm4]{k2}, ymm25");
    TEST64("\x62\x42\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm4]{k2}, ymm25");
    TEST64("\x62\x22\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm12]{k2}, ymm25");
    TEST64("\x62\x02\x7d\x4a\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm12]{k2}, ymm25");
    TEST64("\x62\x62\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm20]{k2}, ymm25");
    TEST64("\x62\x42\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm20]{k2}, ymm25");
    TEST64("\x62\x22\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [rdi+8*zmm28]{k2}, ymm25");
    TEST64("\x62\x02\x7d\x42\xa3\x0c\xe7", "vscatterqps dword ptr [r15+8*zmm28]{k2}, ymm25");
    TEST("\x62\xf2\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [@di+8*xmm4]{k2}, xmm1");
    TEST3264("\x62\xd2\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, xmm1");
    TEST64("\x62\xb2\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, xmm1");
    TEST64("\x62\x92\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, xmm1");
    TEST3264("\x62\xf2\xfd\x02\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\xfd\x02\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x92\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x72\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x52\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x32\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x12\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x72\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x52\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x32\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, xmm9");
    TEST64("\x62\x12\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, xmm9");
    TEST3264("\x62\xe2\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterdpd qword ptr [rdi+8*xmm4]{k2}, xmm17");
    TEST3264("\x62\xc2\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, xmm17");
    TEST64("\x62\xa2\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, xmm17");
    TEST64("\x62\x82\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, xmm17");
    TEST3264("\x62\xe2\xfd\x02\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\xfd\x02\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x82\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x62\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x42\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x22\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x02\xfd\x0a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x62\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x42\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x22\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, xmm25");
    TEST64("\x62\x02\xfd\x02\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, xmm25");
    TEST("\x62\xf2\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [@di+8*xmm4]{k2}, ymm1");
    TEST3264("\x62\xd2\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*xmm4]{k2}, ymm1", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, ymm1");
    TEST64("\x62\xb2\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, ymm1");
    TEST64("\x62\x92\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, ymm1");
    TEST3264("\x62\xf2\xfd\x22\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\xfd\x22\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, ymm1");
    TEST64("\x62\x92\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, ymm1");
    TEST64("\x62\x72\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm4]{k2}, ymm9");
    TEST64("\x62\x52\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, ymm9");
    TEST64("\x62\x32\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, ymm9");
    TEST64("\x62\x12\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, ymm9");
    TEST64("\x62\x72\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, ymm9");
    TEST64("\x62\x52\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, ymm9");
    TEST64("\x62\x32\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, ymm9");
    TEST64("\x62\x12\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, ymm9");
    TEST3264("\x62\xe2\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*xmm4]{k2}, ymm1", "vscatterdpd qword ptr [rdi+8*xmm4]{k2}, ymm17");
    TEST3264("\x62\xc2\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*xmm4]{k2}, ymm1", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, ymm17");
    TEST64("\x62\xa2\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, ymm17");
    TEST64("\x62\x82\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, ymm17");
    TEST3264("\x62\xe2\xfd\x22\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\xfd\x22\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, ymm17");
    TEST64("\x62\x82\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, ymm17");
    TEST64("\x62\x62\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm4]{k2}, ymm25");
    TEST64("\x62\x42\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm4]{k2}, ymm25");
    TEST64("\x62\x22\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm12]{k2}, ymm25");
    TEST64("\x62\x02\xfd\x2a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm12]{k2}, ymm25");
    TEST64("\x62\x62\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm20]{k2}, ymm25");
    TEST64("\x62\x42\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm20]{k2}, ymm25");
    TEST64("\x62\x22\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*xmm28]{k2}, ymm25");
    TEST64("\x62\x02\xfd\x22\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*xmm28]{k2}, ymm25");
    TEST("\x62\xf2\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [@di+8*ymm4]{k2}, zmm1");
    TEST3264("\x62\xd2\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*ymm4]{k2}, zmm1", "vscatterdpd qword ptr [r15+8*ymm4]{k2}, zmm1");
    TEST64("\x62\xb2\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm12]{k2}, zmm1");
    TEST64("\x62\x92\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm12]{k2}, zmm1");
    TEST3264("\x62\xf2\xfd\x42\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [rdi+8*ymm20]{k2}, zmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\xfd\x42\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [r15+8*ymm20]{k2}, zmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm28]{k2}, zmm1");
    TEST64("\x62\x92\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm28]{k2}, zmm1");
    TEST64("\x62\x72\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm4]{k2}, zmm9");
    TEST64("\x62\x52\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm4]{k2}, zmm9");
    TEST64("\x62\x32\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm12]{k2}, zmm9");
    TEST64("\x62\x12\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm12]{k2}, zmm9");
    TEST64("\x62\x72\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm20]{k2}, zmm9");
    TEST64("\x62\x52\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm20]{k2}, zmm9");
    TEST64("\x62\x32\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm28]{k2}, zmm9");
    TEST64("\x62\x12\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm28]{k2}, zmm9");
    TEST3264("\x62\xe2\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*ymm4]{k2}, zmm1", "vscatterdpd qword ptr [rdi+8*ymm4]{k2}, zmm17");
    TEST3264("\x62\xc2\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [edi+8*ymm4]{k2}, zmm1", "vscatterdpd qword ptr [r15+8*ymm4]{k2}, zmm17");
    TEST64("\x62\xa2\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm12]{k2}, zmm17");
    TEST64("\x62\x82\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm12]{k2}, zmm17");
    TEST3264("\x62\xe2\xfd\x42\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [rdi+8*ymm20]{k2}, zmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\xfd\x42\xa2\x0c\xe7", "UD", "vscatterdpd qword ptr [r15+8*ymm20]{k2}, zmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm28]{k2}, zmm17");
    TEST64("\x62\x82\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm28]{k2}, zmm17");
    TEST64("\x62\x62\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm4]{k2}, zmm25");
    TEST64("\x62\x42\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm4]{k2}, zmm25");
    TEST64("\x62\x22\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm12]{k2}, zmm25");
    TEST64("\x62\x02\xfd\x4a\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm12]{k2}, zmm25");
    TEST64("\x62\x62\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm20]{k2}, zmm25");
    TEST64("\x62\x42\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm20]{k2}, zmm25");
    TEST64("\x62\x22\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [rdi+8*ymm28]{k2}, zmm25");
    TEST64("\x62\x02\xfd\x42\xa2\x0c\xe7", "vscatterdpd qword ptr [r15+8*ymm28]{k2}, zmm25");
    TEST("\x62\xf2\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [@di+8*xmm4]{k2}, xmm1");
    TEST3264("\x62\xd2\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterqpd qword ptr [r15+8*xmm4]{k2}, xmm1");
    TEST64("\x62\xb2\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm12]{k2}, xmm1");
    TEST64("\x62\x92\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm12]{k2}, xmm1");
    TEST3264("\x62\xf2\xfd\x02\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [rdi+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\xfd\x02\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [r15+8*xmm20]{k2}, xmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x92\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm28]{k2}, xmm1");
    TEST64("\x62\x72\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x52\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm4]{k2}, xmm9");
    TEST64("\x62\x32\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x12\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm12]{k2}, xmm9");
    TEST64("\x62\x72\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x52\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm20]{k2}, xmm9");
    TEST64("\x62\x32\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm28]{k2}, xmm9");
    TEST64("\x62\x12\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm28]{k2}, xmm9");
    TEST3264("\x62\xe2\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterqpd qword ptr [rdi+8*xmm4]{k2}, xmm17");
    TEST3264("\x62\xc2\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*xmm4]{k2}, xmm1", "vscatterqpd qword ptr [r15+8*xmm4]{k2}, xmm17");
    TEST64("\x62\xa2\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm12]{k2}, xmm17");
    TEST64("\x62\x82\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm12]{k2}, xmm17");
    TEST3264("\x62\xe2\xfd\x02\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [rdi+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\xfd\x02\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [r15+8*xmm20]{k2}, xmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x82\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm28]{k2}, xmm17");
    TEST64("\x62\x62\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x42\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm4]{k2}, xmm25");
    TEST64("\x62\x22\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x02\xfd\x0a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm12]{k2}, xmm25");
    TEST64("\x62\x62\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x42\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm20]{k2}, xmm25");
    TEST64("\x62\x22\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*xmm28]{k2}, xmm25");
    TEST64("\x62\x02\xfd\x02\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*xmm28]{k2}, xmm25");
    TEST("\x62\xf2\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [@di+8*ymm4]{k2}, ymm1");
    TEST3264("\x62\xd2\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*ymm4]{k2}, ymm1", "vscatterqpd qword ptr [r15+8*ymm4]{k2}, ymm1");
    TEST64("\x62\xb2\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm12]{k2}, ymm1");
    TEST64("\x62\x92\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm12]{k2}, ymm1");
    TEST3264("\x62\xf2\xfd\x22\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [rdi+8*ymm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\xfd\x22\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [r15+8*ymm20]{k2}, ymm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm28]{k2}, ymm1");
    TEST64("\x62\x92\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm28]{k2}, ymm1");
    TEST64("\x62\x72\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm4]{k2}, ymm9");
    TEST64("\x62\x52\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm4]{k2}, ymm9");
    TEST64("\x62\x32\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm12]{k2}, ymm9");
    TEST64("\x62\x12\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm12]{k2}, ymm9");
    TEST64("\x62\x72\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm20]{k2}, ymm9");
    TEST64("\x62\x52\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm20]{k2}, ymm9");
    TEST64("\x62\x32\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm28]{k2}, ymm9");
    TEST64("\x62\x12\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm28]{k2}, ymm9");
    TEST3264("\x62\xe2\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*ymm4]{k2}, ymm1", "vscatterqpd qword ptr [rdi+8*ymm4]{k2}, ymm17");
    TEST3264("\x62\xc2\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*ymm4]{k2}, ymm1", "vscatterqpd qword ptr [r15+8*ymm4]{k2}, ymm17");
    TEST64("\x62\xa2\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm12]{k2}, ymm17");
    TEST64("\x62\x82\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm12]{k2}, ymm17");
    TEST3264("\x62\xe2\xfd\x22\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [rdi+8*ymm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\xfd\x22\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [r15+8*ymm20]{k2}, ymm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm28]{k2}, ymm17");
    TEST64("\x62\x82\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm28]{k2}, ymm17");
    TEST64("\x62\x62\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm4]{k2}, ymm25");
    TEST64("\x62\x42\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm4]{k2}, ymm25");
    TEST64("\x62\x22\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm12]{k2}, ymm25");
    TEST64("\x62\x02\xfd\x2a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm12]{k2}, ymm25");
    TEST64("\x62\x62\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm20]{k2}, ymm25");
    TEST64("\x62\x42\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm20]{k2}, ymm25");
    TEST64("\x62\x22\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*ymm28]{k2}, ymm25");
    TEST64("\x62\x02\xfd\x22\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*ymm28]{k2}, ymm25");
    TEST("\x62\xf2\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [@di+8*zmm4]{k2}, zmm1");
    TEST3264("\x62\xd2\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*zmm4]{k2}, zmm1", "vscatterqpd qword ptr [r15+8*zmm4]{k2}, zmm1");
    TEST64("\x62\xb2\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm12]{k2}, zmm1");
    TEST64("\x62\x92\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm12]{k2}, zmm1");
    TEST3264("\x62\xf2\xfd\x42\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [rdi+8*zmm20]{k2}, zmm1"); // EVEX.V' == 0
    TEST3264("\x62\xd2\xfd\x42\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [r15+8*zmm20]{k2}, zmm1"); // EVEX.V' == 0
    TEST64("\x62\xb2\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm28]{k2}, zmm1");
    TEST64("\x62\x92\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm28]{k2}, zmm1");
    TEST64("\x62\x72\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm4]{k2}, zmm9");
    TEST64("\x62\x52\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm4]{k2}, zmm9");
    TEST64("\x62\x32\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm12]{k2}, zmm9");
    TEST64("\x62\x12\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm12]{k2}, zmm9");
    TEST64("\x62\x72\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm20]{k2}, zmm9");
    TEST64("\x62\x52\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm20]{k2}, zmm9");
    TEST64("\x62\x32\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm28]{k2}, zmm9");
    TEST64("\x62\x12\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm28]{k2}, zmm9");
    TEST3264("\x62\xe2\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*zmm4]{k2}, zmm1", "vscatterqpd qword ptr [rdi+8*zmm4]{k2}, zmm17");
    TEST3264("\x62\xc2\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [edi+8*zmm4]{k2}, zmm1", "vscatterqpd qword ptr [r15+8*zmm4]{k2}, zmm17");
    TEST64("\x62\xa2\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm12]{k2}, zmm17");
    TEST64("\x62\x82\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm12]{k2}, zmm17");
    TEST3264("\x62\xe2\xfd\x42\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [rdi+8*zmm20]{k2}, zmm17"); // EVEX.V' == 0
    TEST3264("\x62\xc2\xfd\x42\xa3\x0c\xe7", "UD", "vscatterqpd qword ptr [r15+8*zmm20]{k2}, zmm17"); // EVEX.V' == 0
    TEST64("\x62\xa2\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm28]{k2}, zmm17");
    TEST64("\x62\x82\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm28]{k2}, zmm17");
    TEST64("\x62\x62\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm4]{k2}, zmm25");
    TEST64("\x62\x42\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm4]{k2}, zmm25");
    TEST64("\x62\x22\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm12]{k2}, zmm25");
    TEST64("\x62\x02\xfd\x4a\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm12]{k2}, zmm25");
    TEST64("\x62\x62\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm20]{k2}, zmm25");
    TEST64("\x62\x42\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm20]{k2}, zmm25");
    TEST64("\x62\x22\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [rdi+8*zmm28]{k2}, zmm25");
    TEST64("\x62\x02\xfd\x42\xa3\x0c\xe7", "vscatterqpd qword ptr [r15+8*zmm28]{k2}, zmm25");

    // All EVEX-VSIB instructions. VSCATTER* cases additionally test scaled offset.
    TEST("\x62\xf2\x7d\x09\xa2\x44\xe7\x01", "vscatterdps dword ptr [@di+8*xmm4+0x4]{k1}, xmm0");
    TEST("\x62\xf2\x7d\x29\xa2\x44\xe7\x01", "vscatterdps dword ptr [@di+8*ymm4+0x4]{k1}, ymm0");
    TEST("\x62\xf2\x7d\x49\xa2\x44\xe7\x01", "vscatterdps dword ptr [@di+8*zmm4+0x4]{k1}, zmm0");
    TEST("\x62\xf2\x7d\x09\xa3\x44\xe7\x01", "vscatterqps dword ptr [@di+8*xmm4+0x4]{k1}, xmm0");
    TEST("\x62\xf2\x7d\x29\xa3\x44\xe7\x01", "vscatterqps dword ptr [@di+8*ymm4+0x4]{k1}, xmm0");
    TEST("\x62\xf2\x7d\x49\xa3\x44\xe7\x01", "vscatterqps dword ptr [@di+8*zmm4+0x4]{k1}, ymm0");
    TEST("\x62\xf2\xfd\x09\xa2\x44\xe7\x01", "vscatterdpd qword ptr [@di+8*xmm4+0x8]{k1}, xmm0");
    TEST("\x62\xf2\xfd\x29\xa2\x44\xe7\x01", "vscatterdpd qword ptr [@di+8*xmm4+0x8]{k1}, ymm0");
    TEST("\x62\xf2\xfd\x49\xa2\x44\xe7\x01", "vscatterdpd qword ptr [@di+8*ymm4+0x8]{k1}, zmm0");
    TEST("\x62\xf2\xfd\x09\xa3\x44\xe7\x01", "vscatterqpd qword ptr [@di+8*xmm4+0x8]{k1}, xmm0");
    TEST("\x62\xf2\xfd\x29\xa3\x44\xe7\x01", "vscatterqpd qword ptr [@di+8*ymm4+0x8]{k1}, ymm0");
    TEST("\x62\xf2\xfd\x49\xa3\x44\xe7\x01", "vscatterqpd qword ptr [@di+8*zmm4+0x8]{k1}, zmm0");
    TEST("\x62\xf2\x7d\x09\xa0\x44\xe7\x01", "vpscatterdd dword ptr [@di+8*xmm4+0x4]{k1}, xmm0");
    TEST("\x62\xf2\x7d\x29\xa0\x44\xe7\x01", "vpscatterdd dword ptr [@di+8*ymm4+0x4]{k1}, ymm0");
    TEST("\x62\xf2\x7d\x49\xa0\x44\xe7\x01", "vpscatterdd dword ptr [@di+8*zmm4+0x4]{k1}, zmm0");
    TEST("\x62\xf2\x7d\x09\xa1\x44\xe7\x01", "vpscatterqd dword ptr [@di+8*xmm4+0x4]{k1}, xmm0");
    TEST("\x62\xf2\x7d\x29\xa1\x44\xe7\x01", "vpscatterqd dword ptr [@di+8*ymm4+0x4]{k1}, xmm0");
    TEST("\x62\xf2\x7d\x49\xa1\x44\xe7\x01", "vpscatterqd dword ptr [@di+8*zmm4+0x4]{k1}, ymm0");
    TEST("\x62\xf2\xfd\x09\xa0\x44\xe7\x01", "vpscatterdq qword ptr [@di+8*xmm4+0x8]{k1}, xmm0");
    TEST("\x62\xf2\xfd\x29\xa0\x44\xe7\x01", "vpscatterdq qword ptr [@di+8*xmm4+0x8]{k1}, ymm0");
    TEST("\x62\xf2\xfd\x49\xa0\x44\xe7\x01", "vpscatterdq qword ptr [@di+8*ymm4+0x8]{k1}, zmm0");
    TEST("\x62\xf2\xfd\x09\xa1\x44\xe7\x01", "vpscatterqq qword ptr [@di+8*xmm4+0x8]{k1}, xmm0");
    TEST("\x62\xf2\xfd\x29\xa1\x44\xe7\x01", "vpscatterqq qword ptr [@di+8*ymm4+0x8]{k1}, ymm0");
    TEST("\x62\xf2\xfd\x49\xa1\x44\xe7\x01", "vpscatterqq qword ptr [@di+8*zmm4+0x8]{k1}, zmm0");
    TEST("\x62\xf2\x7d\x09\x90\x44\xe7\x01", "vpgatherdd xmm0{k1}, dword ptr [@di+8*xmm4+0x4]");
    TEST("\x62\xf2\x7d\x29\x90\x44\xe7\x01", "vpgatherdd ymm0{k1}, dword ptr [@di+8*ymm4+0x4]");
    TEST("\x62\xf2\x7d\x49\x90\x44\xe7\x01", "vpgatherdd zmm0{k1}, dword ptr [@di+8*zmm4+0x4]");
    TEST("\x62\xf2\x7d\x09\x91\x44\xe7\x01", "vpgatherqd xmm0{k1}, dword ptr [@di+8*xmm4+0x4]");
    TEST("\x62\xf2\x7d\x29\x91\x44\xe7\x01", "vpgatherqd xmm0{k1}, dword ptr [@di+8*ymm4+0x4]");
    TEST("\x62\xf2\x7d\x49\x91\x44\xe7\x01", "vpgatherqd ymm0{k1}, dword ptr [@di+8*zmm4+0x4]");
    TEST("\x62\xf2\xfd\x09\x90\x44\xe7\x01", "vpgatherdq xmm0{k1}, qword ptr [@di+8*xmm4+0x8]");
    TEST("\x62\xf2\xfd\x29\x90\x44\xe7\x01", "vpgatherdq ymm0{k1}, qword ptr [@di+8*xmm4+0x8]");
    TEST("\x62\xf2\xfd\x49\x90\x44\xe7\x01", "vpgatherdq zmm0{k1}, qword ptr [@di+8*ymm4+0x8]");
    TEST("\x62\xf2\xfd\x09\x91\x44\xe7\x01", "vpgatherqq xmm0{k1}, qword ptr [@di+8*xmm4+0x8]");
    TEST("\x62\xf2\xfd\x29\x91\x44\xe7\x01", "vpgatherqq ymm0{k1}, qword ptr [@di+8*ymm4+0x8]");
    TEST("\x62\xf2\xfd\x49\x91\x44\xe7\x01", "vpgatherqq zmm0{k1}, qword ptr [@di+8*zmm4+0x8]");
    TEST("\x62\xf2\x7d\x09\x92\x44\xe7\x01", "vgatherdps xmm0{k1}, dword ptr [@di+8*xmm4+0x4]");
    TEST("\x62\xf2\x7d\x29\x92\x44\xe7\x01", "vgatherdps ymm0{k1}, dword ptr [@di+8*ymm4+0x4]");
    TEST("\x62\xf2\x7d\x49\x92\x44\xe7\x01", "vgatherdps zmm0{k1}, dword ptr [@di+8*zmm4+0x4]");
    TEST("\x62\xf2\x7d\x09\x93\x44\xe7\x01", "vgatherqps xmm0{k1}, dword ptr [@di+8*xmm4+0x4]");
    TEST("\x62\xf2\x7d\x29\x93\x44\xe7\x01", "vgatherqps xmm0{k1}, dword ptr [@di+8*ymm4+0x4]");
    TEST("\x62\xf2\x7d\x49\x93\x44\xe7\x01", "vgatherqps ymm0{k1}, dword ptr [@di+8*zmm4+0x4]");
    TEST("\x62\xf2\xfd\x09\x92\x44\xe7\x01", "vgatherdpd xmm0{k1}, qword ptr [@di+8*xmm4+0x8]");
    TEST("\x62\xf2\xfd\x29\x92\x44\xe7\x01", "vgatherdpd ymm0{k1}, qword ptr [@di+8*xmm4+0x8]");
    TEST("\x62\xf2\xfd\x49\x92\x44\xe7\x01", "vgatherdpd zmm0{k1}, qword ptr [@di+8*ymm4+0x8]");
    TEST("\x62\xf2\xfd\x09\x93\x44\xe7\x01", "vgatherqpd xmm0{k1}, qword ptr [@di+8*xmm4+0x8]");
    TEST("\x62\xf2\xfd\x29\x93\x44\xe7\x01", "vgatherqpd ymm0{k1}, qword ptr [@di+8*ymm4+0x8]");
    TEST("\x62\xf2\xfd\x49\x93\x44\xe7\x01", "vgatherqpd zmm0{k1}, qword ptr [@di+8*zmm4+0x8]");

    // AVX512-FP16
    TEST("\x62\xf5\x74\x08\x5c\xc2", "vsubph xmm0, xmm1, xmm2");
    TEST("\x62\xf5\x74\x28\x5c\xc2", "vsubph ymm0, ymm1, ymm2");
    TEST("\x62\xf5\x74\x48\x5c\xc2", "vsubph zmm0, zmm1, zmm2");
    TEST("\x62\xf5\x74\x08\x5c\x42\x01", "vsubph xmm0, xmm1, xmmword ptr [@dx+0x10]");
    TEST("\x62\xf5\x74\x28\x5c\x42\x01", "vsubph ymm0, ymm1, ymmword ptr [@dx+0x20]");
    TEST("\x62\xf5\x74\x48\x5c\x42\x01", "vsubph zmm0, zmm1, zmmword ptr [@dx+0x40]");
    TEST("\x62\xf5\x74\x18\x5c\x42\x01", "vsubph xmm0, xmm1, word ptr [@dx+0x2]{1to8}");
    TEST("\x62\xf5\x74\x38\x5c\x42\x01", "vsubph ymm0, ymm1, word ptr [@dx+0x2]{1to16}");
    TEST("\x62\xf5\x74\x58\x5c\x42\x01", "vsubph zmm0, zmm1, word ptr [@dx+0x2]{1to32}");
    TEST64("\x62\x93\x36\x34\xc2\xeb\x89", "vcmpsh k5{k4}, xmm25, xmm27, 0x89, {sae}");
    TEST("\x62\xf5\x66\x4c\x11\xd5", "vmovsh xmm5{k4}, xmm3, xmm2");
    TEST64("\x62\x25\x66\x4c\x11\xd5", "vmovsh xmm21{k4}, xmm3, xmm26");

    // GFNI
    TEST("\x66\x0f\x38\xcf\xc1", "gf2p8mulb xmm0, xmm1");
    TEST("\x66\x0f\x3a\xce\xc1\x01", "gf2p8affineqb xmm0, xmm1, 0x1");
    TEST("\x66\x0f\x3a\xcf\xc1\x01", "gf2p8affineinvqb xmm0, xmm1, 0x1");
    TEST("\xc4\xe2\x69\xcf\xc1", "vgf2p8mulb xmm0, xmm2, xmm1");
    TEST("\xc4\xe2\x6d\xcf\xc1", "vgf2p8mulb ymm0, ymm2, ymm1");
    TEST("\xc4\xe3\xe9\xce\xc1\x01", "vgf2p8affineqb xmm0, xmm2, xmm1, 0x1");
    TEST("\xc4\xe3\xed\xce\xc1\x01", "vgf2p8affineqb ymm0, ymm2, ymm1, 0x1");
    TEST("\xc4\xe3\xe9\xcf\xc1\x01", "vgf2p8affineinvqb xmm0, xmm2, xmm1, 0x1");
    TEST("\xc4\xe3\xed\xcf\xc1\x01", "vgf2p8affineinvqb ymm0, ymm2, ymm1, 0x1");
    TEST("\x62\xf3\xdd\x18\xcf\x49\x01\x07", "vgf2p8affineinvqb xmm1, xmm4, qword ptr [@cx+0x8]{1to2}, 0x7");
    TEST64("\x62\xf3\xdd\x10\xcf\x49\x01\x07", "vgf2p8affineinvqb xmm1, xmm20, qword ptr [rcx+0x8]{1to2}, 0x7");

    // AMD RDPRU
    TEST64("\x0f\x01\xfd", "rdpru");
    TEST64("\x66\x0f\x01\xfd", "rdpru"); // 66 prefix ignored

    // AMD SNP
    TEST64("\xf3\x0f\x01\xfd", "rmpquery");
    TEST64("\xf2\x0f\x01\xfd", "rmpread");
    TEST64("\xf3\x0f\x01\xfe", "rmpadjust");
    TEST64("\xf2\x0f\x01\xfe", "rmpupdate");
    TEST64("\xf3\x0f\x01\xff", "psmash");
    TEST64("\xf2\x0f\x01\xff", "pvalidate");

    // PBNDKB
    TEST3264("\x0f\x01\xc7", "UD", "pbndkb");

    // SM4
    TEST("\xc4\xe2\x6a\xda\x01", "vsm4key4 xmm0, xmm2, xmmword ptr [@cx]");
    TEST("\xc4\xe2\x6e\xda\x01", "vsm4key4 ymm0, ymm2, ymmword ptr [@cx]");
    TEST("\xc4\xe2\x6a\xda\xc1", "vsm4key4 xmm0, xmm2, xmm1");
    TEST("\xc4\xe2\x6e\xda\xc1", "vsm4key4 ymm0, ymm2, ymm1");
    TEST("\x62\xf2\x6e\x08\xda\x01", "vsm4key4 xmm0, xmm2, xmmword ptr [@cx]");
    TEST("\x62\xf2\x6e\x28\xda\x01", "vsm4key4 ymm0, ymm2, ymmword ptr [@cx]");
    TEST("\x62\xf2\x6e\x48\xda\x01", "vsm4key4 zmm0, zmm2, zmmword ptr [@cx]");
    TEST("\x62\xf2\x6e\x08\xda\xc1", "vsm4key4 xmm0, xmm2, xmm1");
    TEST("\x62\xf2\x6e\x28\xda\xc1", "vsm4key4 ymm0, ymm2, ymm1");
    TEST("\x62\xf2\x6e\x48\xda\xc1", "vsm4key4 zmm0, zmm2, zmm1");
    TEST("\xc4\xe2\x6b\xda\x01", "vsm4rnds4 xmm0, xmm2, xmmword ptr [@cx]");
    TEST("\xc4\xe2\x6f\xda\x01", "vsm4rnds4 ymm0, ymm2, ymmword ptr [@cx]");
    TEST("\xc4\xe2\x6b\xda\xc1", "vsm4rnds4 xmm0, xmm2, xmm1");
    TEST("\xc4\xe2\x6f\xda\xc1", "vsm4rnds4 ymm0, ymm2, ymm1");
    TEST("\x62\xf2\x6f\x08\xda\x01", "vsm4rnds4 xmm0, xmm2, xmmword ptr [@cx]");
    TEST("\x62\xf2\x6f\x28\xda\x01", "vsm4rnds4 ymm0, ymm2, ymmword ptr [@cx]");
    TEST("\x62\xf2\x6f\x48\xda\x01", "vsm4rnds4 zmm0, zmm2, zmmword ptr [@cx]");
    TEST("\x62\xf2\x6f\x08\xda\xc1", "vsm4rnds4 xmm0, xmm2, xmm1");
    TEST("\x62\xf2\x6f\x28\xda\xc1", "vsm4rnds4 ymm0, ymm2, ymm1");
    TEST("\x62\xf2\x6f\x48\xda\xc1", "vsm4rnds4 zmm0, zmm2, zmm1");


    puts(failed ? "Some tests FAILED" : "All tests PASSED");
    return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`third_party/fadec/decode.c`:

```c

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <fadec.h>


#ifdef __GNUC__
#define LIKELY(x) __builtin_expect((x), 1)
#define UNLIKELY(x) __builtin_expect((x), 0)
#define ASSUME(x) do { if (!(x)) __builtin_unreachable(); } while (0)
#else
#define LIKELY(x) (x)
#define UNLIKELY(x) (x)
#define ASSUME(x) ((void) 0)
#endif

// Defines FD_TABLE_OFFSET_32 and FD_TABLE_OFFSET_64, if available
#define FD_DECODE_TABLE_DEFINES
#include <fadec-decode-private.inc>
#undef FD_DECODE_TABLE_DEFINES

enum DecodeMode {
    DECODE_64 = 0,
    DECODE_32 = 1,
};

typedef enum DecodeMode DecodeMode;

#define ENTRY_NONE 0
#define ENTRY_INSTR 1
#define ENTRY_TABLE256 2
#define ENTRY_TABLE16 3
#define ENTRY_TABLE8E 4
#define ENTRY_TABLE_PREFIX 5
#define ENTRY_TABLE_VEX 6
#define ENTRY_TABLE_ROOT 8
#define ENTRY_MASK 7

static uint16_t
table_lookup(unsigned cur_idx, unsigned entry_idx) {
    static _Alignas(16) const uint16_t _decode_table[] = {
#define FD_DECODE_TABLE_DATA
#include <fadec-decode-private.inc>
#undef FD_DECODE_TABLE_DATA
    };
    return _decode_table[cur_idx + entry_idx];
}

static unsigned
table_walk(unsigned table_entry, unsigned entry_idx) {
    return table_lookup(table_entry & ~0x3, entry_idx);
}

#define LOAD_LE_1(buf) ((uint64_t) *(const uint8_t*) (buf))
#define LOAD_LE_2(buf) (LOAD_LE_1(buf) | LOAD_LE_1((const uint8_t*) (buf) + 1)<<8)
#define LOAD_LE_3(buf) (LOAD_LE_2(buf) | LOAD_LE_1((const uint8_t*) (buf) + 2)<<16)
#define LOAD_LE_4(buf) (LOAD_LE_2(buf) | LOAD_LE_2((const uint8_t*) (buf) + 2)<<16)
#define LOAD_LE_8(buf) (LOAD_LE_4(buf) | LOAD_LE_4((const uint8_t*) (buf) + 4)<<32)

enum
{
    PREFIX_REXB = 0x01,
    PREFIX_REXX = 0x02,
    PREFIX_REXR = 0x04,
    PREFIX_REXW = 0x08,
    PREFIX_REX = 0x40,
    PREFIX_REXRR = 0x10,
    PREFIX_VEX = 0x20,
};

struct InstrDesc
{
    uint16_t type;
    uint16_t operand_indices;
    uint16_t operand_sizes;
    uint16_t reg_types;
};

#define DESC_HAS_MODRM(desc) (((desc)->operand_indices & (3 << 0)) != 0)
#define DESC_MODRM_IDX(desc) ((((desc)->operand_indices >> 0) & 3) ^ 3)
#define DESC_HAS_MODREG(desc) (((desc)->operand_indices & (3 << 2)) != 0)
#define DESC_MODREG_IDX(desc) ((((desc)->operand_indices >> 2) & 3) ^ 3)
#define DESC_HAS_VEXREG(desc) (((desc)->operand_indices & (3 << 4)) != 0)
#define DESC_VEXREG_IDX(desc) ((((desc)->operand_indices >> 4) & 3) ^ 3)
#define DESC_IMM_CONTROL(desc) (((desc)->operand_indices >> 12) & 0x7)
#define DESC_IMM_IDX(desc) ((((desc)->operand_indices >> 6) & 3) ^ 3)
#define DESC_EVEX_BCST(desc) (((desc)->operand_indices >> 8) & 1)
#define DESC_EVEX_MASK(desc) (((desc)->operand_indices >> 9) & 1)
#define DESC_ZEROREG_VAL(desc) (((desc)->operand_indices >> 10) & 1)
#define DESC_LOCK(desc) (((desc)->operand_indices >> 11) & 1)
#define DESC_VSIB(desc) (((desc)->operand_indices >> 15) & 1)
#define DESC_OPSIZE(desc) (((desc)->reg_types >> 11) & 7)
#define DESC_MODRM_SIZE(desc) (((desc)->operand_sizes >> 0) & 3)
#define DESC_MODREG_SIZE(desc) (((desc)->operand_sizes >> 2) & 3)
#define DESC_VEXREG_SIZE(desc) (((desc)->operand_sizes >> 4) & 3)
#define DESC_IMM_SIZE(desc) (((desc)->operand_sizes >> 6) & 3)
#define DESC_LEGACY(desc) (((desc)->operand_sizes >> 8) & 1)
#define DESC_SIZE_FIX1(desc) (((desc)->operand_sizes >> 10) & 7)
#define DESC_SIZE_FIX2(desc) (((desc)->operand_sizes >> 13) & 3)
#define DESC_INSTR_WIDTH(desc) (((desc)->operand_sizes >> 15) & 1)
#define DESC_MODRM(desc) (((desc)->reg_types >> 14) & 1)
#define DESC_IGN66(desc) (((desc)->reg_types >> 15) & 1)
#define DESC_EVEX_SAE(desc) (((desc)->reg_types >> 8) & 1)
#define DESC_EVEX_ER(desc) (((desc)->reg_types >> 9) & 1)
#define DESC_EVEX_BCST16(desc) (((desc)->reg_types >> 10) & 1)
#define DESC_REGTY_MODRM(desc) (((desc)->reg_types >> 0) & 7)
#define DESC_REGTY_MODREG(desc) (((desc)->reg_types >> 3) & 7)
#define DESC_REGTY_VEXREG(desc) (((desc)->reg_types >> 6) & 3)

int
fd_decode(const uint8_t* buffer, size_t len_sz, int mode_int, uintptr_t address,
          FdInstr* instr)
{
    int len = len_sz > 15 ? 15 : len_sz;

    // Ensure that we can actually handle the decode request
    DecodeMode mode;
    unsigned table_root_idx;
    switch (mode_int)
    {
#if defined(FD_TABLE_OFFSET_32)
    case 32: table_root_idx = FD_TABLE_OFFSET_32; mode = DECODE_32; break;
#endif
#if defined(FD_TABLE_OFFSET_64)
    case 64: table_root_idx = FD_TABLE_OFFSET_64; mode = DECODE_64; break;
#endif
    default: return FD_ERR_INTERNAL;
    }

    int off = 0;
    uint8_t vex_operand = 0;

    uint8_t addr_size = mode == DECODE_64 ? 3 : 2;
    unsigned prefix_rex = 0;
    uint8_t prefix_rep = 0;
    unsigned vexl = 0;
    unsigned prefix_evex = 0;
    instr->segment = FD_REG_NONE;

    // Values must match prefixes in parseinstrs.py.
    enum {
        PF_SEG1 = 0xfff8 - 0xfff8,
        PF_SEG2 = 0xfff9 - 0xfff8,
        PF_66 = 0xfffa - 0xfff8,
        PF_67 = 0xfffb - 0xfff8,
        PF_LOCK = 0xfffc - 0xfff8,
        PF_REP = 0xfffd - 0xfff8,
        PF_REX = 0xfffe - 0xfff8,
    };

    uint8_t prefixes[8] = {0};
    unsigned table_entry = 0;
    while (true) {
        if (UNLIKELY(off >= len))
            return FD_ERR_PARTIAL;
        uint8_t prefix = buffer[off];
        table_entry = table_lookup(table_root_idx, prefix);
        if (LIKELY(table_entry - 0xfff8 >= 8))
            break;
        prefixes[PF_REX] = 0;
        prefixes[table_entry - 0xfff8] = prefix;
        off++;
    }
    if (off) {
        if (UNLIKELY(prefixes[PF_SEG2])) {
            if (prefixes[PF_SEG2] & 0x02)
                instr->segment = prefixes[PF_SEG2] >> 3 & 3;
            else
                instr->segment = prefixes[PF_SEG2] & 7;
        }
        if (UNLIKELY(prefixes[PF_67]))
            addr_size--;
        prefix_rex = prefixes[PF_REX];
        prefix_rep = prefixes[PF_REP];
    }

    // table_entry kinds: INSTR(0), T16(1), ESCAPE_A(2), ESCAPE_B(3)
    if (LIKELY(!(table_entry & 2))) {
        off++;

        // Then, walk through ModR/M-encoded opcode extensions.
        if (table_entry & 1) {
            if (UNLIKELY(off >= len))
                return FD_ERR_PARTIAL;
            unsigned isreg = buffer[off] >= 0xc0;
            table_entry = table_walk(table_entry, ((buffer[off] >> 2) & 0xe) | isreg);
            // table_entry kinds: INSTR(0), T8E(1)
            if (table_entry & 1)
                table_entry = table_walk(table_entry, buffer[off] & 7);
        }

        // table_entry kinds: INSTR(0)
        goto direct;
    }

    if (UNLIKELY(off >= len))
        return FD_ERR_PARTIAL;

    unsigned opcode_escape = 0;
    uint8_t mandatory_prefix = 0; // without escape/VEX/EVEX, this is ignored.
    if (buffer[off] == 0x0f)
    {
        if (UNLIKELY(off + 1 >= len))
            return FD_ERR_PARTIAL;
        if (buffer[off + 1] == 0x38)
            opcode_escape = 2;
        else if (buffer[off + 1] == 0x3a)
            opcode_escape = 3;
        else
            opcode_escape = 1;
        off += opcode_escape >= 2 ? 2 : 1;

        // If there is no REP/REPNZ prefix offer 66h as mandatory prefix. If
        // there is a REP prefix, then the 66h prefix is ignored here.
        mandatory_prefix = prefix_rep ? prefix_rep ^ 0xf1 : !!prefixes[PF_66];
    }
    else if (UNLIKELY((unsigned) buffer[off] - 0xc4 < 2 || buffer[off] == 0x62))
    {
        unsigned vex_prefix = buffer[off];
        // VEX (C4/C5) or EVEX (62)
        if (UNLIKELY(off + 1 >= len))
            return FD_ERR_PARTIAL;
        if (UNLIKELY(mode == DECODE_32 && buffer[off + 1] < 0xc0)) {
            off++;
            table_entry = table_walk(table_entry, 0);
            // table_entry kinds: INSTR(0)
            goto direct;
        }

        // VEX/EVEX + 66/F3/F2/REX will #UD.
        // Note: REX is also here only respected if it immediately precedes the
        // opcode, in this case the VEX/EVEX "prefix".
        if (prefixes[PF_66] || prefixes[PF_REP] || prefix_rex)
            return FD_ERR_UD;

        uint8_t byte = buffer[off + 1];
        if (vex_prefix == 0xc5) // 2-byte VEX
        {
            opcode_escape = 1;
            prefix_rex = byte & 0x80 ? 0 : PREFIX_REXR;
        }
        else // 3-byte VEX or EVEX
        {
            // SDM Vol 2A 2-15 (Dec. 2016): Ignored in 32-bit mode
            if (mode == DECODE_64)
                prefix_rex = byte >> 5 ^ 0x7;
            if (vex_prefix == 0x62) // EVEX
            {
                if (byte & 0x08) // Bit 3 of opcode_escape must be clear.
                    return FD_ERR_UD;
                _Static_assert(PREFIX_REXRR == 0x10, "wrong REXRR value");
                if (mode == DECODE_64)
                    prefix_rex |= (byte & PREFIX_REXRR) ^ PREFIX_REXRR;
            }
            else // 3-byte VEX
            {
                if (byte & 0x18) // Bits 4:3 of opcode_escape must be clear.
                    return FD_ERR_UD;
            }

            opcode_escape = (byte & 0x07);
            if (UNLIKELY(opcode_escape == 0)) {
                int prefix_len = vex_prefix == 0x62 ? 4 : 3;
                // Pretend to decode the prefix plus one opcode byte.
                return off + prefix_len > len ? FD_ERR_PARTIAL : FD_ERR_UD;
            }

            // Load third byte of VEX prefix
            if (UNLIKELY(off + 2 >= len))
                return FD_ERR_PARTIAL;
            byte = buffer[off + 2];
            prefix_rex |= byte & 0x80 ? PREFIX_REXW : 0;
        }

        mandatory_prefix = byte & 3;
        vex_operand = ((byte & 0x78) >> 3) ^ 0xf;
        prefix_rex |= PREFIX_VEX;

        if (vex_prefix == 0x62) // EVEX
        {
            if (!(byte & 0x04)) // Bit 10 must be 1.
                return FD_ERR_UD;
            if (UNLIKELY(off + 3 >= len))
                return FD_ERR_PARTIAL;
            byte = buffer[off + 3];
            // prefix_evex is z:L'L/RC:b:V':aaa
            vexl = (byte >> 5) & 3;
            prefix_evex = byte | 0x100; // Ensure that prefix_evex is non-zero.
            if (mode == DECODE_64) // V' causes UD in 32-bit mode
                vex_operand |= byte & 0x08 ? 0 : 0x10; // V'
            else if (!(byte & 0x08))
                return FD_ERR_UD;
            off += 4;
        }
        else // VEX
        {
            vexl = byte & 0x04 ? 1 : 0;
            off += 0xc7 - vex_prefix; // 3 for c4, 2 for c5
        }
    }

    table_entry = table_walk(table_entry, opcode_escape);
    // table_entry kinds: INSTR(0) [only for invalid], T256(2)
    if (UNLIKELY(!table_entry))
        return FD_ERR_UD;
    if (UNLIKELY(off >= len))
        return FD_ERR_PARTIAL;
    table_entry = table_walk(table_entry, buffer[off++]);
    // table_entry kinds: INSTR(0), T16(1), TVEX(2), TPREFIX(3)

    // Handle mandatory prefixes (which behave like an opcode ext.).
    if ((table_entry & 3) == 3)
        table_entry = table_walk(table_entry, mandatory_prefix);
    // table_entry kinds: INSTR(0), T16(1), TVEX(2)

    // Then, walk through ModR/M-encoded opcode extensions.
    if (table_entry & 1) {
        if (UNLIKELY(off >= len))
            return FD_ERR_PARTIAL;
        unsigned isreg = buffer[off] >= 0xc0;
        table_entry = table_walk(table_entry, ((buffer[off] >> 2) & 0xe) | isreg);
        // table_entry kinds: INSTR(0), T8E(1), TVEX(2)
        if (table_entry & 1)
            table_entry = table_walk(table_entry, buffer[off] & 7);
    }
    // table_entry kinds: INSTR(0), TVEX(2)

    // For VEX prefix, we have to distinguish between VEX.W and VEX.L which may
    // be part of the opcode.
    if (UNLIKELY(table_entry & 2))
    {
        uint8_t index = 0;
        index |= prefix_rex & PREFIX_REXW ? (1 << 0) : 0;
        // When EVEX.L'L is the rounding mode, the instruction must not have
        // L'L constraints.
        index |= vexl << 1;
        table_entry = table_walk(table_entry, index);
    }
    // table_entry kinds: INSTR(0)

direct:
    // table_entry kinds: INSTR(0)
    if (UNLIKELY(!table_entry))
        return FD_ERR_UD;

    static _Alignas(16) const struct InstrDesc descs[] = {
#define FD_DECODE_TABLE_DESCS
#include <fadec-decode-private.inc>
#undef FD_DECODE_TABLE_DESCS
    };
    const struct InstrDesc* desc = &descs[table_entry >> 2];

    instr->type = desc->type;
    instr->addrsz = addr_size;
    instr->flags = ((prefix_rep + 1) & 6) + (mode == DECODE_64 ? FD_FLAG_64 : 0);
    instr->address = address;

    for (unsigned i = 0; i < sizeof(instr->operands) / sizeof(FdOp); i++)
        instr->operands[i] = (FdOp) {0};

    if (DESC_MODRM(desc) && UNLIKELY(off++ >= len))
        return FD_ERR_PARTIAL;
    unsigned op_byte = buffer[off - 1] | (!DESC_MODRM(desc) ? 0xc0 : 0);

    if (UNLIKELY(prefix_evex)) {
        // VSIB inst (gather/scatter) without mask register or w/EVEX.z is UD
        if (DESC_VSIB(desc) && (!(prefix_evex & 0x07) || (prefix_evex & 0x80)))
            return FD_ERR_UD;
        // Inst doesn't support masking, so EVEX.z or EVEX.aaa is UD
        if (!DESC_EVEX_MASK(desc) && (prefix_evex & 0x87))
            return FD_ERR_UD;
        // EVEX.z without EVEX.aaa is UD. The Intel SDM is rather unprecise
        // about this, but real hardware doesn't accept this.
        if ((prefix_evex & 0x87) == 0x80)
            return FD_ERR_UD;

        // Cases for SAE/RC (reg operands only):
        //  - ER supported -> all ok
        //  - SAE supported -> assume L'L is RC, but ignored (undocumented)
        //  - Neither supported -> b == 0
        if ((prefix_evex & 0x10) && (op_byte & 0xc0) == 0xc0) { // EVEX.b+reg
            if (!DESC_EVEX_SAE(desc))
                return FD_ERR_UD;
            vexl = 2;
            if (DESC_EVEX_ER(desc))
                instr->evex = prefix_evex;
            else
                instr->evex = (prefix_evex & 0x87) | 0x60; // set RC, clear B
        } else {
            if (UNLIKELY(vexl == 3)) // EVEX.L'L == 11b is UD
                return FD_ERR_UD;
            instr->evex = prefix_evex & 0x87; // clear RC, clear B
        }

        if (DESC_VSIB(desc))
            vex_operand &= 0xf; // EVEX.V' is used as index extension instead.
    } else {
        instr->evex = 0;
    }

    unsigned op_size;
    unsigned op_size_alt = 0;
    if (!(DESC_OPSIZE(desc) & 4)) {
        if (mode == DECODE_64)
            op_size = ((prefix_rex & PREFIX_REXW) || DESC_OPSIZE(desc) == 3) ? 4 :
                              UNLIKELY(prefixes[PF_66] && !DESC_IGN66(desc)) ? 2 :
                                                           DESC_OPSIZE(desc) ? 4 :
                                                                               3;
        else
            op_size = UNLIKELY(prefixes[PF_66] && !DESC_IGN66(desc)) ? 2 : 3;
    } else {
        op_size = 5 + vexl;
        op_size_alt = op_size - (DESC_OPSIZE(desc) & 3);
    }

    uint8_t operand_sizes[4] = {
        DESC_SIZE_FIX1(desc), DESC_SIZE_FIX2(desc) + 1, op_size, op_size_alt
    };

    if (UNLIKELY(instr->type == FDI_MOV_CR || instr->type == FDI_MOV_DR)) {
        unsigned modreg = (op_byte >> 3) & 0x7;
        unsigned modrm = op_byte & 0x7;

        FdOp* op_modreg = &instr->operands[DESC_MODREG_IDX(desc)];
        op_modreg->type = FD_OT_REG;
        op_modreg->size = op_size;
        op_modreg->reg = modreg | (prefix_rex & PREFIX_REXR ? 8 : 0);
        op_modreg->misc = instr->type == FDI_MOV_CR ? FD_RT_CR : FD_RT_DR;
        if (instr->type == FDI_MOV_CR && (~0x011d >> op_modreg->reg) & 1)
            return FD_ERR_UD;
        else if (instr->type == FDI_MOV_DR && prefix_rex & PREFIX_REXR)
            return FD_ERR_UD;

        FdOp* op_modrm = &instr->operands[DESC_MODRM_IDX(desc)];
        op_modrm->type = FD_OT_REG;
        op_modrm->size = op_size;
        op_modrm->reg = modrm | (prefix_rex & PREFIX_REXB ? 8 : 0);
        op_modrm->misc = FD_RT_GPL;
        goto skip_modrm;
    }

    if (DESC_HAS_MODREG(desc))
    {
        FdOp* op_modreg = &instr->operands[DESC_MODREG_IDX(desc)];
        unsigned reg_idx = (op_byte & 0x38) >> 3;
        unsigned reg_ty = DESC_REGTY_MODREG(desc);
        op_modreg->misc = reg_ty;
        if (LIKELY(reg_ty < 2))
            reg_idx += prefix_rex & PREFIX_REXR ? 8 : 0;
        else if (reg_ty == 7 && (prefix_rex & PREFIX_REXR || prefix_evex & 0x80))
            return FD_ERR_UD; // REXR in 64-bit mode or EVEX.z with mask as dest
        if (UNLIKELY(reg_ty == FD_RT_VEC)) // REXRR ignored above in 32-bit mode
            reg_idx += prefix_rex & PREFIX_REXRR ? 16 : 0;
        else if (UNLIKELY(prefix_rex & PREFIX_REXRR))
            return FD_ERR_UD;
        op_modreg->type = FD_OT_REG;
        op_modreg->size = operand_sizes[DESC_MODREG_SIZE(desc)];
        op_modreg->reg = reg_idx;
    }

    if (DESC_HAS_MODRM(desc))
    {
        FdOp* op_modrm = &instr->operands[DESC_MODRM_IDX(desc)];
        op_modrm->size = operand_sizes[DESC_MODRM_SIZE(desc)];

        unsigned rm = op_byte & 0x07;
        if (op_byte >= 0xc0)
        {
            uint8_t reg_idx = rm;
            unsigned reg_ty = DESC_REGTY_MODRM(desc);
            op_modrm->misc = reg_ty;
            if (LIKELY(reg_ty < 2))
                reg_idx += prefix_rex & PREFIX_REXB ? 8 : 0;
            if (prefix_evex && reg_ty == 0) // vector registers only
                reg_idx += prefix_rex & PREFIX_REXX ? 16 : 0;
            op_modrm->type = FD_OT_REG;
            op_modrm->reg = reg_idx;
        }
        else
        {
            unsigned dispscale = 0;

            if (UNLIKELY(prefix_evex)) {
                // EVEX.z for memory destination operand is UD.
                if (UNLIKELY(prefix_evex & 0x80) && DESC_MODRM_IDX(desc) == 0)
                    return FD_ERR_UD;

                // EVEX.b for memory-operand without broadcast support is UD.
                if (UNLIKELY(prefix_evex & 0x10)) {
                    if (UNLIKELY(!DESC_EVEX_BCST(desc)))
                        return FD_ERR_UD;
                    if (UNLIKELY(DESC_EVEX_BCST16(desc)))
                        dispscale = 1;
                    else
                        dispscale = prefix_rex & PREFIX_REXW ? 3 : 2;
                    instr->segment |= dispscale << 6; // Store broadcast size
                    op_modrm->type = FD_OT_MEMBCST;
                } else {
                    dispscale = op_modrm->size - 1;
                    op_modrm->type = FD_OT_MEM;
                }
            } else {
                op_modrm->type = FD_OT_MEM;
            }

            // 16-bit address size implies different ModRM encoding
            if (UNLIKELY(addr_size == 1)) {
                ASSUME(mode == DECODE_32);
                if (UNLIKELY(DESC_VSIB(desc))) // 16-bit addr size + VSIB is UD
                    return FD_ERR_UD;
                if (rm < 6)
                    op_modrm->misc = rm & 1 ? FD_REG_DI : FD_REG_SI;
                else
                    op_modrm->misc = FD_REG_NONE;

                if (rm < 4)
                    op_modrm->reg = rm & 2 ? FD_REG_BP : FD_REG_BX;
                else if (rm < 6 || (op_byte & 0xc7) == 0x06)
                    op_modrm->reg = FD_REG_NONE;
                else
                    op_modrm->reg = rm == 6 ? FD_REG_BP : FD_REG_BX;

                const uint8_t* dispbase = &buffer[off];
                if (op_byte & 0x40) {
                    if (UNLIKELY((off += 1) > len))
                        return FD_ERR_PARTIAL;
                    instr->disp = (int8_t) LOAD_LE_1(dispbase) * (1 << dispscale);
                } else if (op_byte & 0x80 || (op_byte & 0xc7) == 0x06) {
                    if (UNLIKELY((off += 2) > len))
                        return FD_ERR_PARTIAL;
                    instr->disp = (int16_t) LOAD_LE_2(dispbase);
                } else {
                    instr->disp = 0;
                }
                goto end_modrm;
            }

            // SIB byte
            uint8_t base = rm;
            if (rm == 4) {
                if (UNLIKELY(off >= len))
                    return FD_ERR_PARTIAL;
                uint8_t sib = buffer[off++];
                unsigned scale = sib & 0xc0;
                unsigned idx = (sib & 0x38) >> 3;
                idx += prefix_rex & PREFIX_REXX ? 8 : 0;
                base = sib & 0x07;
                if (idx == 4)
                    idx = FD_REG_NONE;
                op_modrm->misc = scale | idx;
            } else {
                op_modrm->misc = FD_REG_NONE;
            }

            if (UNLIKELY(DESC_VSIB(desc))) {
                // VSIB must have a memory operand with SIB byte.
                if (rm != 4)
                    return FD_ERR_UD;
                _Static_assert(FD_REG_NONE == 0x3f, "unexpected FD_REG_NONE");
                // idx 4 is valid for VSIB
                if ((op_modrm->misc & 0x3f) == FD_REG_NONE)
                    op_modrm->misc &= 0xc4;
                if (prefix_evex) // EVEX.V':EVEX.X:SIB.idx
                    op_modrm->misc |= prefix_evex & 0x8 ? 0 : 0x10;
            }

            // RIP-relative addressing only if SIB-byte is absent
            if (op_byte < 0x40 && rm == 5 && mode == DECODE_64)
                op_modrm->reg = FD_REG_IP;
            else if (op_byte < 0x40 && base == 5)
                op_modrm->reg = FD_REG_NONE;
            else
                op_modrm->reg = base + (prefix_rex & PREFIX_REXB ? 8 : 0);

            const uint8_t* dispbase = &buffer[off];
            if (op_byte & 0x40) {
                if (UNLIKELY((off += 1) > len))
                    return FD_ERR_PARTIAL;
                instr->disp = (int8_t) LOAD_LE_1(dispbase) * (1 << dispscale);
            } else if (op_byte & 0x80 || (op_byte < 0x40 && base == 5)) {
                if (UNLIKELY((off += 4) > len))
                    return FD_ERR_PARTIAL;
                instr->disp = (int32_t) LOAD_LE_4(dispbase);
            } else {
                instr->disp = 0;
            }
        end_modrm:;
        }
    }

    if (UNLIKELY(DESC_HAS_VEXREG(desc)))
    {
        FdOp* operand = &instr->operands[DESC_VEXREG_IDX(desc)];
        if (DESC_ZEROREG_VAL(desc)) {
            operand->type = FD_OT_REG;
            operand->size = 1;
            operand->reg = FD_REG_CL;
            operand->misc = FD_RT_GPL;
        } else {
            operand->type = FD_OT_REG;
            // Without VEX prefix, this encodes an implicit register
            operand->size = operand_sizes[DESC_VEXREG_SIZE(desc)];
            if (mode == DECODE_32)
                vex_operand &= 0x7;
            // Note: 32-bit will never UD here. EVEX.V' is caught above already.
            // Note: UD if > 16 for non-VEC. No EVEX-encoded instruction uses
            // EVEX.vvvv to refer to non-vector registers. Verified in parseinstrs.
            operand->reg = vex_operand;

            unsigned reg_ty = DESC_REGTY_VEXREG(desc); // VEC GPL MSK FPU/TMM
            if (prefix_rex & PREFIX_VEX) { // TMM with VEX, FPU otherwise
                // In 64-bit mode: UD if FD_RT_MASK and vex_operand&8 != 0
                if (reg_ty == 2 && vex_operand >= 8)
                    return FD_ERR_UD;
                if (UNLIKELY(reg_ty == 3)) // TMM
                    operand->reg &= 0x7; // TODO: verify
                operand->misc = (06710 >> (3 * reg_ty)) & 0x7;
            } else {
                operand->misc = (04710 >> (3 * reg_ty)) & 0x7;
            }
        }
    }
    else if (vex_operand != 0)
    {
        // TODO: bit 3 ignored in 32-bit mode? unverified
        return FD_ERR_UD;
    }

    uint32_t imm_control = UNLIKELY(DESC_IMM_CONTROL(desc));
    if (LIKELY(!imm_control)) {
    } else if (UNLIKELY(imm_control == 1))
    {
        // 1 = immediate constant 1, used for shifts
        FdOp* operand = &instr->operands[DESC_IMM_IDX(desc)];
        operand->type = FD_OT_IMM;
        operand->size = 1;
        instr->imm = 1;
    }
    else if (UNLIKELY(imm_control == 2))
    {
        // 2 = memory, address-sized, used for mov with moffs operand
        FdOp* operand = &instr->operands[DESC_IMM_IDX(desc)];
        operand->type = FD_OT_MEM;
        operand->size = operand_sizes[DESC_IMM_SIZE(desc)];
        operand->reg = FD_REG_NONE;
        operand->misc = FD_REG_NONE;

        int moffsz = 1 << addr_size;
        if (UNLIKELY(off + moffsz > len))
            return FD_ERR_PARTIAL;
        if (moffsz == 2)
            instr->disp = LOAD_LE_2(&buffer[off]);
        if (moffsz == 4)
            instr->disp = LOAD_LE_4(&buffer[off]);
        if (LIKELY(moffsz == 8))
            instr->disp = LOAD_LE_8(&buffer[off]);
        off += moffsz;
    }
    else if (UNLIKELY(imm_control == 3))
    {
        // 3 = register in imm8[7:4], used for RVMR encoding with VBLENDVP[SD]
        FdOp* operand = &instr->operands[DESC_IMM_IDX(desc)];
        operand->type = FD_OT_REG;
        operand->size = op_size;
        operand->misc = FD_RT_VEC;

        if (UNLIKELY(off + 1 > len))
            return FD_ERR_PARTIAL;
        uint8_t reg = (uint8_t) LOAD_LE_1(&buffer[off]);
        off += 1;

        if (mode == DECODE_32)
            reg &= 0x7f;
        operand->reg = reg >> 4;
        instr->imm = reg & 0x0f;
    }
    else if (imm_control != 0)
    {
        // 4/5 = immediate, operand-sized/8 bit
        // 6/7 = offset, operand-sized/8 bit (used for jumps/calls)
        int imm_byte = imm_control & 1;
        int imm_offset = imm_control & 2;

        FdOp* operand = &instr->operands[DESC_IMM_IDX(desc)];
        operand->type = FD_OT_IMM;

        if (imm_byte) {
            if (UNLIKELY(off + 1 > len))
                return FD_ERR_PARTIAL;
            instr->imm = (int8_t) LOAD_LE_1(&buffer[off++]);
            operand->size = DESC_IMM_SIZE(desc) & 1 ? 1 : op_size;
        } else {
            operand->size = operand_sizes[DESC_IMM_SIZE(desc)];

            uint8_t imm_size;
            if (UNLIKELY(instr->type == FDI_RET || instr->type == FDI_RETF ||
                         instr->type == FDI_SSE_EXTRQ ||
                         instr->type == FDI_SSE_INSERTQ))
                imm_size = 2;
            else if (UNLIKELY(instr->type == FDI_JMPF || instr->type == FDI_CALLF))
                imm_size = (1 << op_size >> 1) + 2;
            else if (UNLIKELY(instr->type == FDI_ENTER))
                imm_size = 3;
            else if (instr->type == FDI_MOVABS)
                imm_size = (1 << op_size >> 1);
            else
                imm_size = op_size == 2 ? 2 : 4;

            if (UNLIKELY(off + imm_size > len))
                return FD_ERR_PARTIAL;

            if (imm_size == 2)
                instr->imm = (int16_t) LOAD_LE_2(&buffer[off]);
            else if (imm_size == 3)
                instr->imm = LOAD_LE_3(&buffer[off]);
            else if (imm_size == 4)
                instr->imm = (int32_t) LOAD_LE_4(&buffer[off]);
            else if (imm_size == 6)
                instr->imm = LOAD_LE_4(&buffer[off]) | LOAD_LE_2(&buffer[off+4]) << 32;
            else if (imm_size == 8)
                instr->imm = (int64_t) LOAD_LE_8(&buffer[off]);
            off += imm_size;
        }

        if (imm_offset)
        {
            if (instr->address != 0)
                instr->imm += instr->address + off;
            else
                operand->type = FD_OT_OFF;
        }
    }

skip_modrm:
    if (UNLIKELY(prefixes[PF_LOCK])) {
        if (!DESC_LOCK(desc) || instr->operands[0].type != FD_OT_MEM)
            return FD_ERR_UD;
        instr->flags |= FD_FLAG_LOCK;
    }

    if (UNLIKELY(DESC_LEGACY(desc))) {
        // Without REX prefix, convert one-byte GP regs to high-byte regs
        // This actually only applies to SZ8/MOVSX/MOVZX; but no VEX-encoded
        // instructions have a byte-sized GP register in the first two operands.
        if (!(prefix_rex & PREFIX_REX)) {
            for (int i = 0; i < 2; i++) {
                FdOp* operand = &instr->operands[i];
                if (operand->type == FD_OT_NONE)
                    break;
                if (operand->type == FD_OT_REG && operand->misc == FD_RT_GPL &&
                    operand->size == 1 && operand->reg >= 4)
                    operand->misc = FD_RT_GPH;
            }
        }

        if (instr->type == FDI_XCHG_NOP) {
            // Only 4890, 90, and 6690 are true NOPs.
            if (instr->operands[0].reg == 0) {
                instr->operands[0].type = FD_OT_NONE;
                instr->operands[1].type = FD_OT_NONE;
                instr->type = FD_HAS_REP(instr) ? FDI_PAUSE : FDI_NOP;
            } else if ((instr->operands[0].reg & 7) == 0 && FD_HAS_REP(instr)) {
                // On Intel, REX.B is ignored for F3.90.
                instr->operands[0].type = FD_OT_NONE;
                instr->operands[1].type = FD_OT_NONE;
                instr->type = FDI_PAUSE;
            } else {
                instr->type = FDI_XCHG;
            }
        }

        if (UNLIKELY(instr->type == FDI_3DNOW)) {
            unsigned opc3dn = instr->imm;
            if (opc3dn & 0x40)
                return FD_ERR_UD;
            uint64_t msk = opc3dn & 0x80 ? 0x88d144d144d14400 : 0x30003000;
            if (!(msk >> (opc3dn & 0x3f) & 1))
                return FD_ERR_UD;
        }

        instr->operandsz = UNLIKELY(DESC_INSTR_WIDTH(desc)) ? op_size - 1 : 0;
    } else {
        instr->operandsz = 0;
    }

    instr->size = off;

    return off;
}

```

`third_party/fadec/encode-test.c`:

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include <fadec-enc.h>


static
void
print_hex(const uint8_t* buf, size_t len)
{
    for (size_t i = 0; i < len; i++)
        printf("%02x", buf[i]);
}

static
int
test(uint8_t* buf, const char* name, uint64_t mnem, uint64_t op0, uint64_t op1, uint64_t op2, uint64_t op3, const void* exp, size_t exp_len)
{
    memset(buf, 0, 16);

    uint8_t* inst = buf;
    int res = fe_enc64(&inst, mnem, op0, op1, op2, op3);
    if ((res != 0) != (exp_len == 0)) goto fail;
    if (inst - buf != (ptrdiff_t) exp_len) goto fail;
    if (memcmp(buf, exp, exp_len)) goto fail;

    return 0;

fail:
    printf("Failed case %s:\n", name);
    printf("  Exp (%2zu): ", exp_len);
    print_hex(exp, exp_len);
    printf("\n  Got (%2zd): ", inst - buf);
    print_hex(buf, inst - buf);
    printf("\n");
    return -1;
}

#define TEST2(str, exp, exp_len, mnem, flags, op0, op1, op2, op3, ...) test(buf, str, FE_ ## mnem|flags, op0, op1, op2, op3, exp, exp_len)
#define TEST1(str, exp, ...) TEST2(str, exp, sizeof(exp)-1, __VA_ARGS__, 0, 0, 0, 0, 0)
#define TEST(exp, ...) failed |= TEST1(#__VA_ARGS__, exp, __VA_ARGS__)

int
main(int argc, char** argv)
{
    (void) argc; (void) argv;

    int failed = 0;
    uint8_t buf[16];

    // VSIB encoding doesn't differ for this API
#define FE_MEMV FE_MEM
#define FE_PTR(off) ((intptr_t) buf + (off))
#define FLAGMASK(flags, mask) (flags | FE_MASK(mask & 7))
#include "encode-test.inc"

    puts(failed ? "Some tests FAILED" : "All tests PASSED");
    return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`third_party/fadec/encode-test.inc`:

```inc

TEST("\00\xe0", ADD8rr, 0, FE_AX, FE_AH);
TEST("", ADD8rr, 0, FE_SI, FE_AH);
TEST("\xeb\xfe", JMP, 0, FE_PTR(0));
TEST("\xeb\x7f", JMP, 0, FE_PTR(129));
TEST("\xe9\x7d\x00\x00\x00", JMP, 0, FE_PTR(130));
TEST("\xeb\x80", JMP, 0, FE_PTR(-126));
TEST("\xe9\x7c\xff\xff\xff", JMP, 0, FE_PTR(-127));
TEST("\xe9\xfb\xff\xff\xff", JMP, FE_JMPL, FE_PTR(0));
TEST("\xe9\x00\x00\x00\x00", JMP, FE_JMPL, FE_PTR(5));
TEST("\x75\x00", JNZ, 0, FE_PTR(2));
TEST("\x0f\x85\x00\x00\x00\x00", JNZ, FE_JMPL, FE_PTR(6));
TEST("\x70\x7f", JO, 0, FE_PTR(129));
TEST("\x0f\x80\x7c\x00\x00\x00", JO, 0, FE_PTR(130));
TEST("\x70\x80", JO, 0, FE_PTR(-126));
TEST("\x0f\x80\x7b\xff\xff\xff", JO, 0, FE_PTR(-127));
TEST("\xe3\xfc", JCXZ, 0, FE_PTR(-2));
TEST("\x67\xe3\xfb", JCXZ, FE_ADDR32, FE_PTR(-2));
TEST("\xe3\xfc", JCXZ, FE_JMPL, FE_PTR(-2));
TEST("\xac", LODS8, 0);
TEST("\x67\xac", LODS8, FE_ADDR32);
TEST("\x50", PUSHr, 0, FE_AX);
TEST("\x66\x50", PUSH16r, 0, FE_AX);
TEST("\x54", PUSHr, 0, FE_SP);
TEST("\x41\x57", PUSHr, 0, FE_R15);
TEST("\x41\x50", PUSHr, 0, FE_R8);
TEST("", PUSH_SEGr, 0, FE_ES);
TEST("", PUSH_SEG16r, 0, FE_ES);
TEST("", PUSH_SEGr, 0, FE_CS);
TEST("", PUSH_SEG16r, 0, FE_CS);
TEST("", PUSH_SEGr, 0, FE_SS);
TEST("", PUSH_SEG16r, 0, FE_SS);
TEST("", PUSH_SEGr, 0, FE_DS);
TEST("", PUSH_SEG16r, 0, FE_DS);
TEST("\x0f\xa0", PUSH_SEGr, 0, FE_FS);
TEST("\x66\x0f\xa0", PUSH_SEG16r, 0, FE_FS);
TEST("\x0f\xa8", PUSH_SEGr, 0, FE_GS);
TEST("\x66\x0f\xa8", PUSH_SEG16r, 0, FE_GS);
TEST("\xff\x30", PUSHm, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xff\x31", PUSHm, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0));
TEST("\x9c", PUSHF, 0);
TEST("\x8c\xc0", MOV_S2Grr, 0, FE_AX, FE_ES);
TEST("\x8c\xc8", MOV_S2Grr, 0, FE_AX, FE_CS);
TEST("\x8c\xd0", MOV_S2Grr, 0, FE_AX, FE_SS);
TEST("\x8c\xd8", MOV_S2Grr, 0, FE_AX, FE_DS);
TEST("\x8c\xe0", MOV_S2Grr, 0, FE_AX, FE_FS);
TEST("\x8c\xe8", MOV_S2Grr, 0, FE_AX, FE_GS);
TEST("\x8e\xc0", MOV_G2Srr, 0, FE_ES, FE_AX);
// TEST("", MOV_G2Srr, 0, FE_CS, FE_AX);
TEST("\x8e\xd0", MOV_G2Srr, 0, FE_SS, FE_AX);
TEST("\x8e\xd8", MOV_G2Srr, 0, FE_DS, FE_AX);
TEST("\x8e\xe0", MOV_G2Srr, 0, FE_FS, FE_AX);
TEST("\x8e\xe8", MOV_G2Srr, 0, FE_GS, FE_AX);
TEST("\xd2\xe4", SHL8rr, 0, FE_AH, FE_CX);
TEST("", SHL8rr, 0, FE_AH, FE_DX);
TEST("\xd0\xe0", SHL8ri, 0, FE_AX, 1);
TEST("\xc0\xe0\x02", SHL8ri, 0, FE_AX, 2);
TEST("\xc1\xe0\x02", SHL32ri, 0, FE_AX, 2);
TEST("\x48\xc1\xe0\x02", SHL64ri, 0, FE_AX, 2);
TEST("\x48\xf7\x28", IMUL64m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc2\x00\x00", RETi, 0, 0);
TEST("\xff\xd0", CALLr, 0, FE_AX);
TEST("\x83\xc0\x7f", ADD32ri, 0, FE_AX, 0x7f);
TEST("\x05\x80\x00\x00\x00", ADD32ri, 0, FE_AX, 0x80);
TEST("\x05\x00\x01\x00\x00", ADD32ri, 0, FE_AX, 0x100);
TEST("\x66\x05\x00\x01", ADD16ri, 0, FE_AX, 0x100);
#ifndef ENC_TEST_TYPESAFE
TEST("", ADD16ri, 0, FE_AX, 0x12345);
TEST("\x66\x05\xff\xee", ADD16ri, 0, FE_AX, 0xffffffffffffeeff);
#endif
TEST("\xb8\x05\x00\x01\x00", MOV32ri, 0, FE_AX, 0x10005);
TEST("\xb8\xff\xff\xff\x7f", MOV32ri, 0, FE_AX, 0x7fffffff);
TEST("\x48\xb8\x05\x00\x01\x00\xff\x00\x00\x00", MOV64ri, 0, FE_AX, 0xff00010005);
TEST("\x48\xc7\xc0\x00\x00\x00\x00", MOV64ri, 0, FE_AX, 0x0);
TEST("\x48\xc7\xc0\x00\x00\x00\x80", MOV64ri, 0, FE_AX, (int32_t) 0x80000000);
TEST("\x48\xb8\x00\x00\x00\x00\x00\x00\x00\x80", MOV64ri, 0, FE_AX, INT64_MIN);
TEST("\x48\xb8\x00\x00\x00\x80\x00\x00\x00\x00", MOV64ri, 0, FE_AX, 0x80000000);
TEST("\xb0\xff", MOV8ri, 0, FE_AX, (int8_t) 0xff);
TEST("\xb4\xff", MOV8ri, 0, FE_AH, -1);
TEST("\xb7\x64", MOV8ri, 0, FE_BH, 0x64);
TEST("\x40\xb6\x64", MOV8ri, 0, FE_SI, 0x64);
TEST("\x41\xb6\x64", MOV8ri, 0, FE_R14, 0x64);
TEST("\x66\x0f\xbe\xc2", MOVSXr16r8, 0, FE_AX, FE_DX);
TEST("\x0f\xbe\xc2", MOVSXr32r8, 0, FE_AX, FE_DX);
TEST("\x48\x0f\xbe\xc2", MOVSXr64r8, 0, FE_AX, FE_DX);
TEST("\x66\x0f\xbe\xc6", MOVSXr16r8, 0, FE_AX, FE_DH);
TEST("\x0f\xbe\xc6", MOVSXr32r8, 0, FE_AX, FE_DH);
TEST("", MOVSXr64r8, 0, FE_AX, FE_DH);
TEST("\x66\x0f\xbf\xc2", MOVSXr16r16, 0, FE_AX, FE_DX);
TEST("\x0f\xbf\xc2", MOVSXr32r16, 0, FE_AX, FE_DX);
TEST("\x48\x0f\xbf\xc2", MOVSXr64r16, 0, FE_AX, FE_DX);
TEST("\x66\x63\xc2", MOVSXr16r32, 0, FE_AX, FE_DX);
TEST("\x63\xc2", MOVSXr32r32, 0, FE_AX, FE_DX);
TEST("\x48\x63\xc2", MOVSXr64r32, 0, FE_AX, FE_DX);
TEST("\xc8\x33\x22\x11", ENTERi, 0, 0x112233);
TEST("", ENTERi, 0, 0x1112233);
TEST("\x0f\x05", SYSCALL, 0);
TEST("\x0f\x90\xc4", SETO8r, 0, FE_AH);
TEST("\x40\x0f\x90\xc4", SETO8r, 0, FE_SP);
TEST("\x41\x0f\x90\xc4", SETO8r, 0, FE_R12);
TEST("\xf3\x0f\xb8\xc2", POPCNT32rr, 0, FE_AX, FE_DX);
TEST("\x66\xf3\x0f\xb8\xc2", POPCNT16rr, 0, FE_AX, FE_DX);
TEST("\xf3\x48\x0f\xb8\xc2", POPCNT64rr, 0, FE_AX, FE_DX);
TEST("\x0f\xbc\xc2", BSF32rr, 0, FE_AX, FE_DX);
TEST("\x66\x0f\xbc\xc2", BSF16rr, 0, FE_AX, FE_DX);
TEST("\x0f\x01\xd0", XGETBV, 0);
TEST("\x41\x90", XCHG32rr, 0, FE_R8, FE_AX);
TEST("\x91", XCHG32rr, 0, FE_CX, FE_AX);
TEST("\x66\x90", XCHG16rr, 0, FE_AX, FE_AX);
TEST("\x87\xc0", XCHG32rr, 0, FE_AX, FE_AX);
TEST("\x48\x90", XCHG64rr, 0, FE_AX, FE_AX);
TEST("\x87\x00", XCHG32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x87\x08", XCHG32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX);
TEST("\x90", NOP, 0);
TEST("\xf3\x90", PAUSE, 0);
TEST("\x0f\x1f\xc0", NOP32r, 0, FE_AX);
TEST("\x26\x01\x00", ADD32mr, FE_SEG(FE_ES), FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x2e\x01\x00", ADD32mr, FE_SEG(FE_CS), FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x36\x01\x00", ADD32mr, FE_SEG(FE_SS), FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x3e\x01\x00", ADD32mr, FE_SEG(FE_DS), FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x64\x01\x00", ADD32mr, FE_SEG(FE_FS), FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x65\x01\x00", ADD32mr, FE_SEG(FE_GS), FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x8e\xc0", MOV_G2Srr, 0, FE_ES, FE_AX);
TEST("\xae", SCAS8, 0);
TEST("\xf2\xae", REPNZ_SCAS8, 0);
TEST("\xf3\xae", REPZ_SCAS8, 0);
TEST("\x66\xab", STOS16, 0);
TEST("\x66\xf3\xab", REP_STOS16, 0);
TEST("\xab", STOS32, 0);
TEST("\xf3\xab", REP_STOS32, 0);
TEST("\x48\xab", STOS64, 0);
TEST("\xf3\x48\xab", REP_STOS64, 0);
TEST("\x6c", INS8, 0);
TEST("\x67\x6c", INS8, FE_ADDR32);
TEST("\x66\x6d", INS16, 0);
TEST("\x67\x66\x6d", INS16, FE_ADDR32);
TEST("\x6d", INS32, 0);
TEST("\x67\x6d", INS32, FE_ADDR32);
TEST("\x0f\x38\xf0\x11", MOVBE32rm, 0, FE_DX, FE_MEM(FE_CX, 0, FE_NOREG, 0));
TEST("\x66\x0f\x38\xf0\x11", MOVBE16rm, 0, FE_DX, FE_MEM(FE_CX, 0, FE_NOREG, 0));
TEST("\x48\x0f\x38\xf0\x11", MOVBE64rm, 0, FE_DX, FE_MEM(FE_CX, 0, FE_NOREG, 0));
TEST("\xf2\x0f\x38\xf0\xc1", CRC32_8rr, 0, FE_AX, FE_CX);
TEST("\xf2\x0f\x38\xf0\xc5", CRC32_8rr, 0, FE_AX, FE_CH);
TEST("\xf2\x0f\x38\xf1\xc1", CRC32_32rr, 0, FE_AX, FE_CX);
TEST("\x66\xf2\x0f\x38\xf1\xc1", CRC32_16rr, 0, FE_AX, FE_CX);
TEST("\x66\xf2\x41\x0f\x38\xf1\xc2", CRC32_16rr, 0, FE_AX, FE_R10);
TEST("\x0f\xc7\xf7", RDRAND32r, 0, FE_DI);
TEST("\x66\x0f\xc7\xf7", RDRAND16r, 0, FE_DI);
TEST("\x48\x0f\xc7\xf7", RDRAND64r, 0, FE_DI);
TEST("\x0f\xc7\xff", RDSEED32r, 0, FE_DI);
TEST("\x66\x0f\xc7\xff", RDSEED16r, 0, FE_DI);
TEST("\x48\x0f\xc7\xff", RDSEED64r, 0, FE_DI);
TEST("\xf3\x0f\xc7\xff", RDPIDr, 0, FE_DI);
TEST("\x66\x0f\x3a\x14\xc1\x02", SSE_PEXTRBrri, 0, FE_CX, FE_XMM0, 2);
TEST("\x66\x0f\x3a\x20\xc1\x02", SSE_PINSRBrri, 0, FE_XMM0, FE_CX, 2);
#ifndef ENC_TEST_TYPESAFE
TEST("", SSE_PEXTRBrri, 0, FE_CH, FE_XMM0, 2);
TEST("", SSE_PINSRBrri, 0, FE_XMM0, FE_CH, 2);
#endif
TEST("\x66\x0f\xf7\xc1", SSE_MASKMOVDQUrr, 0, FE_XMM0, FE_XMM1);
TEST("\x67\x66\x0f\xf7\xc1", SSE_MASKMOVDQUrr, FE_ADDR32, FE_XMM0, FE_XMM1);
TEST("\x66\x0f\x6e\xc1", SSE_MOVD_G2Xrr, 0, FE_XMM0, FE_CX);
TEST("\x66\x41\x0f\x6e\xc1", SSE_MOVD_G2Xrr, 0, FE_XMM0, FE_R9);
TEST("\x66\x44\x0f\x6e\xc1", SSE_MOVD_G2Xrr, 0, FE_XMM8, FE_CX);
TEST("\x66\x45\x0f\x6e\xc1", SSE_MOVD_G2Xrr, 0, FE_XMM8, FE_R9);
TEST("\x66\x48\x0f\x6e\xc1", SSE_MOVQ_G2Xrr, 0, FE_XMM0, FE_CX);
TEST("\x66\x49\x0f\x6e\xc1", SSE_MOVQ_G2Xrr, 0, FE_XMM0, FE_R9);
TEST("\x66\x4c\x0f\x6e\xc1", SSE_MOVQ_G2Xrr, 0, FE_XMM8, FE_CX);
TEST("\x66\x4d\x0f\x6e\xc1", SSE_MOVQ_G2Xrr, 0, FE_XMM8, FE_R9);
TEST("\x66\x0f\x7e\xc1", SSE_MOVD_X2Grr, 0, FE_CX, FE_XMM0);
TEST("\x66\x41\x0f\x7e\xc1", SSE_MOVD_X2Grr, 0, FE_R9, FE_XMM0);
TEST("\x66\x44\x0f\x7e\xc1", SSE_MOVD_X2Grr, 0, FE_CX, FE_XMM8);
TEST("\x66\x45\x0f\x7e\xc1", SSE_MOVD_X2Grr, 0, FE_R9, FE_XMM8);
TEST("\x66\x48\x0f\x7e\xc1", SSE_MOVQ_X2Grr, 0, FE_CX, FE_XMM0);
TEST("\x66\x49\x0f\x7e\xc1", SSE_MOVQ_X2Grr, 0, FE_R9, FE_XMM0);
TEST("\x66\x4c\x0f\x7e\xc1", SSE_MOVQ_X2Grr, 0, FE_CX, FE_XMM8);
TEST("\x66\x4d\x0f\x7e\xc1", SSE_MOVQ_X2Grr, 0, FE_R9, FE_XMM8);
TEST("\x0f\xae\xe8", LFENCE, 0);
TEST("\x0f\xae\xf0", MFENCE, 0);
TEST("\x0f\xae\xf8", SFENCE, 0);
TEST("\x66\x98", C_EX16, 0);
TEST("\x66\x98", CBW, 0);
TEST("\x98", C_EX32, 0);
TEST("\x98", CWDE, 0);
TEST("\x48\x98", C_EX64, 0);
TEST("\x48\x98", CDQE, 0);
TEST("\x66\x99", C_SEP16, 0);
TEST("\x66\x99", CWD, 0);
TEST("\x99", C_SEP32, 0);
TEST("\x99", CDQ, 0);
TEST("\x48\x99", C_SEP64, 0);
TEST("\x48\x99", CQO, 0);
TEST("\x0f\xc7\x0f", CMPXCHGD32m, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0));
TEST("\x0f\xc7\x0f", CMPXCHG8Bm, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0));
TEST("\x48\x0f\xc7\x0f", CMPXCHGD64m, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0));
TEST("\x48\x0f\xc7\x0f", CMPXCHG16Bm, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0));

// Condition codes
TEST("\x70\x00", JO, 0, FE_PTR(2));
TEST("\x70\x00", Jcc, FE_CC_O, FE_PTR(2));
TEST("\x0f\x80\x00\x00\x00\x00", JO, FE_JMPL, FE_PTR(6));
TEST("\x0f\x80\x00\x00\x00\x00", Jcc, FE_CC_O|FE_JMPL, FE_PTR(6));
TEST("\x0f\x80\x7c\x00\x00\x00", JO, 0, FE_PTR(130));
TEST("\x0f\x80\x7c\x00\x00\x00", Jcc, FE_CC_O, FE_PTR(130));
TEST("\x0f\x90\xc0", SETO8r, 0, FE_AX);
TEST("\x0f\x90\xc0", SETcc8r, FE_CC_O, FE_AX);
TEST("\x0f\x90\x00", SETO8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x90\x00", SETcc8m, FE_CC_O, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x90\x00", SETO8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x90\x00", SETcc8m, FE_CC_O|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x40\xc0", CMOVO32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x40\xc0", CMOVcc32rr, FE_CC_O, FE_AX, FE_AX);
TEST("\x0f\x40\x00", CMOVO32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x40\x00", CMOVcc32rm, FE_CC_O, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x40\x00", CMOVO32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x40\x00", CMOVcc32rm, FE_CC_O|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe0\x08", CMPOXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe0\x08", CMPccXADD32mrr, FE_CC_O, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe0\x08", CMPOXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe0\x08", CMPccXADD64mrr, FE_CC_O, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x71\x00", JNO, 0, FE_PTR(2));
TEST("\x71\x00", Jcc, FE_CC_NO, FE_PTR(2));
TEST("\x0f\x81\x00\x00\x00\x00", JNO, FE_JMPL, FE_PTR(6));
TEST("\x0f\x81\x00\x00\x00\x00", Jcc, FE_CC_NO|FE_JMPL, FE_PTR(6));
TEST("\x0f\x81\x7c\x00\x00\x00", JNO, 0, FE_PTR(130));
TEST("\x0f\x81\x7c\x00\x00\x00", Jcc, FE_CC_NO, FE_PTR(130));
TEST("\x0f\x91\xc0", SETNO8r, 0, FE_AX);
TEST("\x0f\x91\xc0", SETcc8r, FE_CC_NO, FE_AX);
TEST("\x0f\x91\x00", SETNO8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x91\x00", SETcc8m, FE_CC_NO, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x91\x00", SETNO8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x91\x00", SETcc8m, FE_CC_NO|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x41\xc0", CMOVNO32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x41\xc0", CMOVcc32rr, FE_CC_NO, FE_AX, FE_AX);
TEST("\x0f\x41\x00", CMOVNO32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x41\x00", CMOVcc32rm, FE_CC_NO, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x41\x00", CMOVNO32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x41\x00", CMOVcc32rm, FE_CC_NO|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe1\x08", CMPNOXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe1\x08", CMPccXADD32mrr, FE_CC_NO, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe1\x08", CMPNOXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe1\x08", CMPccXADD64mrr, FE_CC_NO, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x72\x00", JC, 0, FE_PTR(2));
TEST("\x72\x00", Jcc, FE_CC_C, FE_PTR(2));
TEST("\x0f\x82\x00\x00\x00\x00", JC, FE_JMPL, FE_PTR(6));
TEST("\x0f\x82\x00\x00\x00\x00", Jcc, FE_CC_C|FE_JMPL, FE_PTR(6));
TEST("\x0f\x82\x7c\x00\x00\x00", JC, 0, FE_PTR(130));
TEST("\x0f\x82\x7c\x00\x00\x00", Jcc, FE_CC_C, FE_PTR(130));
TEST("\x0f\x92\xc0", SETC8r, 0, FE_AX);
TEST("\x0f\x92\xc0", SETcc8r, FE_CC_C, FE_AX);
TEST("\x0f\x92\x00", SETC8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x92\x00", SETcc8m, FE_CC_C, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x92\x00", SETC8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x92\x00", SETcc8m, FE_CC_C|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x42\xc0", CMOVC32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x42\xc0", CMOVcc32rr, FE_CC_C, FE_AX, FE_AX);
TEST("\x0f\x42\x00", CMOVC32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x42\x00", CMOVcc32rm, FE_CC_C, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x42\x00", CMOVC32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x42\x00", CMOVcc32rm, FE_CC_C|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe2\x08", CMPBXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe2\x08", CMPccXADD32mrr, FE_CC_B, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe2\x08", CMPBXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe2\x08", CMPccXADD64mrr, FE_CC_B, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x73\x00", JNC, 0, FE_PTR(2));
TEST("\x73\x00", Jcc, FE_CC_NC, FE_PTR(2));
TEST("\x0f\x83\x00\x00\x00\x00", JNC, FE_JMPL, FE_PTR(6));
TEST("\x0f\x83\x00\x00\x00\x00", Jcc, FE_CC_NC|FE_JMPL, FE_PTR(6));
TEST("\x0f\x83\x7c\x00\x00\x00", JNC, 0, FE_PTR(130));
TEST("\x0f\x83\x7c\x00\x00\x00", Jcc, FE_CC_NC, FE_PTR(130));
TEST("\x0f\x93\xc0", SETNC8r, 0, FE_AX);
TEST("\x0f\x93\xc0", SETcc8r, FE_CC_NC, FE_AX);
TEST("\x0f\x93\x00", SETNC8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x93\x00", SETcc8m, FE_CC_NC, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x93\x00", SETNC8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x93\x00", SETcc8m, FE_CC_NC|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x43\xc0", CMOVNC32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x43\xc0", CMOVcc32rr, FE_CC_NC, FE_AX, FE_AX);
TEST("\x0f\x43\x00", CMOVNC32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x43\x00", CMOVcc32rm, FE_CC_NC, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x43\x00", CMOVNC32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x43\x00", CMOVcc32rm, FE_CC_NC|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe3\x08", CMPNBXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe3\x08", CMPccXADD32mrr, FE_CC_NB, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe3\x08", CMPNBXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe3\x08", CMPccXADD64mrr, FE_CC_NB, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x74\x00", JZ, 0, FE_PTR(2));
TEST("\x74\x00", Jcc, FE_CC_Z, FE_PTR(2));
TEST("\x0f\x84\x00\x00\x00\x00", JZ, FE_JMPL, FE_PTR(6));
TEST("\x0f\x84\x00\x00\x00\x00", Jcc, FE_CC_Z|FE_JMPL, FE_PTR(6));
TEST("\x0f\x84\x7c\x00\x00\x00", JZ, 0, FE_PTR(130));
TEST("\x0f\x84\x7c\x00\x00\x00", Jcc, FE_CC_Z, FE_PTR(130));
TEST("\x0f\x94\xc0", SETZ8r, 0, FE_AX);
TEST("\x0f\x94\xc0", SETcc8r, FE_CC_Z, FE_AX);
TEST("\x0f\x94\x00", SETZ8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x94\x00", SETcc8m, FE_CC_Z, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x94\x00", SETZ8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x94\x00", SETcc8m, FE_CC_Z|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x44\xc0", CMOVZ32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x44\xc0", CMOVcc32rr, FE_CC_Z, FE_AX, FE_AX);
TEST("\x0f\x44\x00", CMOVZ32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x44\x00", CMOVcc32rm, FE_CC_Z, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x44\x00", CMOVZ32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x44\x00", CMOVcc32rm, FE_CC_Z|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe4\x08", CMPZXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe4\x08", CMPccXADD32mrr, FE_CC_Z, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe4\x08", CMPZXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe4\x08", CMPccXADD64mrr, FE_CC_Z, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x75\x00", JNZ, 0, FE_PTR(2));
TEST("\x75\x00", Jcc, FE_CC_NZ, FE_PTR(2));
TEST("\x0f\x85\x00\x00\x00\x00", JNZ, FE_JMPL, FE_PTR(6));
TEST("\x0f\x85\x00\x00\x00\x00", Jcc, FE_CC_NZ|FE_JMPL, FE_PTR(6));
TEST("\x0f\x85\x7c\x00\x00\x00", JNZ, 0, FE_PTR(130));
TEST("\x0f\x85\x7c\x00\x00\x00", Jcc, FE_CC_NZ, FE_PTR(130));
TEST("\x0f\x95\xc0", SETNZ8r, 0, FE_AX);
TEST("\x0f\x95\xc0", SETcc8r, FE_CC_NZ, FE_AX);
TEST("\x0f\x95\x00", SETNZ8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x95\x00", SETcc8m, FE_CC_NZ, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x95\x00", SETNZ8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x95\x00", SETcc8m, FE_CC_NZ|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x45\xc0", CMOVNZ32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x45\xc0", CMOVcc32rr, FE_CC_NZ, FE_AX, FE_AX);
TEST("\x0f\x45\x00", CMOVNZ32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x45\x00", CMOVcc32rm, FE_CC_NZ, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x45\x00", CMOVNZ32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x45\x00", CMOVcc32rm, FE_CC_NZ|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe5\x08", CMPNZXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe5\x08", CMPccXADD32mrr, FE_CC_NZ, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe5\x08", CMPNZXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe5\x08", CMPccXADD64mrr, FE_CC_NZ, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x76\x00", JBE, 0, FE_PTR(2));
TEST("\x76\x00", Jcc, FE_CC_BE, FE_PTR(2));
TEST("\x0f\x86\x00\x00\x00\x00", JBE, FE_JMPL, FE_PTR(6));
TEST("\x0f\x86\x00\x00\x00\x00", Jcc, FE_CC_BE|FE_JMPL, FE_PTR(6));
TEST("\x0f\x86\x7c\x00\x00\x00", JBE, 0, FE_PTR(130));
TEST("\x0f\x86\x7c\x00\x00\x00", Jcc, FE_CC_BE, FE_PTR(130));
TEST("\x0f\x96\xc0", SETBE8r, 0, FE_AX);
TEST("\x0f\x96\xc0", SETcc8r, FE_CC_BE, FE_AX);
TEST("\x0f\x96\x00", SETBE8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x96\x00", SETcc8m, FE_CC_BE, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x96\x00", SETBE8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x96\x00", SETcc8m, FE_CC_BE|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x46\xc0", CMOVBE32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x46\xc0", CMOVcc32rr, FE_CC_BE, FE_AX, FE_AX);
TEST("\x0f\x46\x00", CMOVBE32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x46\x00", CMOVcc32rm, FE_CC_BE, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x46\x00", CMOVBE32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x46\x00", CMOVcc32rm, FE_CC_BE|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe6\x08", CMPBEXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe6\x08", CMPccXADD32mrr, FE_CC_BE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe6\x08", CMPBEXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe6\x08", CMPccXADD64mrr, FE_CC_BE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x77\x00", JA, 0, FE_PTR(2));
TEST("\x77\x00", Jcc, FE_CC_A, FE_PTR(2));
TEST("\x0f\x87\x00\x00\x00\x00", JA, FE_JMPL, FE_PTR(6));
TEST("\x0f\x87\x00\x00\x00\x00", Jcc, FE_CC_A|FE_JMPL, FE_PTR(6));
TEST("\x0f\x87\x7c\x00\x00\x00", JA, 0, FE_PTR(130));
TEST("\x0f\x87\x7c\x00\x00\x00", Jcc, FE_CC_A, FE_PTR(130));
TEST("\x0f\x97\xc0", SETA8r, 0, FE_AX);
TEST("\x0f\x97\xc0", SETcc8r, FE_CC_A, FE_AX);
TEST("\x0f\x97\x00", SETA8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x97\x00", SETcc8m, FE_CC_A, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x97\x00", SETA8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x97\x00", SETcc8m, FE_CC_A|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x47\xc0", CMOVA32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x47\xc0", CMOVcc32rr, FE_CC_A, FE_AX, FE_AX);
TEST("\x0f\x47\x00", CMOVA32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x47\x00", CMOVcc32rm, FE_CC_A, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x47\x00", CMOVA32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x47\x00", CMOVcc32rm, FE_CC_A|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe7\x08", CMPNBEXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe7\x08", CMPccXADD32mrr, FE_CC_NBE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe7\x08", CMPNBEXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe7\x08", CMPccXADD64mrr, FE_CC_NBE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x78\x00", JS, 0, FE_PTR(2));
TEST("\x78\x00", Jcc, FE_CC_S, FE_PTR(2));
TEST("\x0f\x88\x00\x00\x00\x00", JS, FE_JMPL, FE_PTR(6));
TEST("\x0f\x88\x00\x00\x00\x00", Jcc, FE_CC_S|FE_JMPL, FE_PTR(6));
TEST("\x0f\x88\x7c\x00\x00\x00", JS, 0, FE_PTR(130));
TEST("\x0f\x88\x7c\x00\x00\x00", Jcc, FE_CC_S, FE_PTR(130));
TEST("\x0f\x98\xc0", SETS8r, 0, FE_AX);
TEST("\x0f\x98\xc0", SETcc8r, FE_CC_S, FE_AX);
TEST("\x0f\x98\x00", SETS8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x98\x00", SETcc8m, FE_CC_S, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x98\x00", SETS8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x98\x00", SETcc8m, FE_CC_S|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x48\xc0", CMOVS32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x48\xc0", CMOVcc32rr, FE_CC_S, FE_AX, FE_AX);
TEST("\x0f\x48\x00", CMOVS32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x48\x00", CMOVcc32rm, FE_CC_S, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x48\x00", CMOVS32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x48\x00", CMOVcc32rm, FE_CC_S|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe8\x08", CMPSXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe8\x08", CMPccXADD32mrr, FE_CC_S, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe8\x08", CMPSXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe8\x08", CMPccXADD64mrr, FE_CC_S, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x79\x00", JNS, 0, FE_PTR(2));
TEST("\x79\x00", Jcc, FE_CC_NS, FE_PTR(2));
TEST("\x0f\x89\x00\x00\x00\x00", JNS, FE_JMPL, FE_PTR(6));
TEST("\x0f\x89\x00\x00\x00\x00", Jcc, FE_CC_NS|FE_JMPL, FE_PTR(6));
TEST("\x0f\x89\x7c\x00\x00\x00", JNS, 0, FE_PTR(130));
TEST("\x0f\x89\x7c\x00\x00\x00", Jcc, FE_CC_NS, FE_PTR(130));
TEST("\x0f\x99\xc0", SETNS8r, 0, FE_AX);
TEST("\x0f\x99\xc0", SETcc8r, FE_CC_NS, FE_AX);
TEST("\x0f\x99\x00", SETNS8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x99\x00", SETcc8m, FE_CC_NS, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x99\x00", SETNS8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x99\x00", SETcc8m, FE_CC_NS|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x49\xc0", CMOVNS32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x49\xc0", CMOVcc32rr, FE_CC_NS, FE_AX, FE_AX);
TEST("\x0f\x49\x00", CMOVNS32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x49\x00", CMOVcc32rm, FE_CC_NS, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x49\x00", CMOVNS32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x49\x00", CMOVcc32rm, FE_CC_NS|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xe9\x08", CMPNSXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xe9\x08", CMPccXADD32mrr, FE_CC_NS, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe9\x08", CMPNSXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xe9\x08", CMPccXADD64mrr, FE_CC_NS, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x7a\x00", JP, 0, FE_PTR(2));
TEST("\x7a\x00", Jcc, FE_CC_P, FE_PTR(2));
TEST("\x0f\x8a\x00\x00\x00\x00", JP, FE_JMPL, FE_PTR(6));
TEST("\x0f\x8a\x00\x00\x00\x00", Jcc, FE_CC_P|FE_JMPL, FE_PTR(6));
TEST("\x0f\x8a\x7c\x00\x00\x00", JP, 0, FE_PTR(130));
TEST("\x0f\x8a\x7c\x00\x00\x00", Jcc, FE_CC_P, FE_PTR(130));
TEST("\x0f\x9a\xc0", SETP8r, 0, FE_AX);
TEST("\x0f\x9a\xc0", SETcc8r, FE_CC_P, FE_AX);
TEST("\x0f\x9a\x00", SETP8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x9a\x00", SETcc8m, FE_CC_P, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9a\x00", SETP8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9a\x00", SETcc8m, FE_CC_P|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4a\xc0", CMOVP32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x4a\xc0", CMOVcc32rr, FE_CC_P, FE_AX, FE_AX);
TEST("\x0f\x4a\x00", CMOVP32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4a\x00", CMOVcc32rm, FE_CC_P, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4a\x00", CMOVP32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4a\x00", CMOVcc32rm, FE_CC_P|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xea\x08", CMPPXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xea\x08", CMPccXADD32mrr, FE_CC_P, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xea\x08", CMPPXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xea\x08", CMPccXADD64mrr, FE_CC_P, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x7b\x00", JNP, 0, FE_PTR(2));
TEST("\x7b\x00", Jcc, FE_CC_NP, FE_PTR(2));
TEST("\x0f\x8b\x00\x00\x00\x00", JNP, FE_JMPL, FE_PTR(6));
TEST("\x0f\x8b\x00\x00\x00\x00", Jcc, FE_CC_NP|FE_JMPL, FE_PTR(6));
TEST("\x0f\x8b\x7c\x00\x00\x00", JNP, 0, FE_PTR(130));
TEST("\x0f\x8b\x7c\x00\x00\x00", Jcc, FE_CC_NP, FE_PTR(130));
TEST("\x0f\x9b\xc0", SETNP8r, 0, FE_AX);
TEST("\x0f\x9b\xc0", SETcc8r, FE_CC_NP, FE_AX);
TEST("\x0f\x9b\x00", SETNP8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x9b\x00", SETcc8m, FE_CC_NP, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9b\x00", SETNP8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9b\x00", SETcc8m, FE_CC_NP|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4b\xc0", CMOVNP32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x4b\xc0", CMOVcc32rr, FE_CC_NP, FE_AX, FE_AX);
TEST("\x0f\x4b\x00", CMOVNP32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4b\x00", CMOVcc32rm, FE_CC_NP, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4b\x00", CMOVNP32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4b\x00", CMOVcc32rm, FE_CC_NP|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xeb\x08", CMPNPXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xeb\x08", CMPccXADD32mrr, FE_CC_NP, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xeb\x08", CMPNPXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xeb\x08", CMPccXADD64mrr, FE_CC_NP, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x7c\x00", JL, 0, FE_PTR(2));
TEST("\x7c\x00", Jcc, FE_CC_L, FE_PTR(2));
TEST("\x0f\x8c\x00\x00\x00\x00", JL, FE_JMPL, FE_PTR(6));
TEST("\x0f\x8c\x00\x00\x00\x00", Jcc, FE_CC_L|FE_JMPL, FE_PTR(6));
TEST("\x0f\x8c\x7c\x00\x00\x00", JL, 0, FE_PTR(130));
TEST("\x0f\x8c\x7c\x00\x00\x00", Jcc, FE_CC_L, FE_PTR(130));
TEST("\x0f\x9c\xc0", SETL8r, 0, FE_AX);
TEST("\x0f\x9c\xc0", SETcc8r, FE_CC_L, FE_AX);
TEST("\x0f\x9c\x00", SETL8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x9c\x00", SETcc8m, FE_CC_L, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9c\x00", SETL8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9c\x00", SETcc8m, FE_CC_L|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4c\xc0", CMOVL32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x4c\xc0", CMOVcc32rr, FE_CC_L, FE_AX, FE_AX);
TEST("\x0f\x4c\x00", CMOVL32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4c\x00", CMOVcc32rm, FE_CC_L, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4c\x00", CMOVL32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4c\x00", CMOVcc32rm, FE_CC_L|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xec\x08", CMPLXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xec\x08", CMPccXADD32mrr, FE_CC_L, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xec\x08", CMPLXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xec\x08", CMPccXADD64mrr, FE_CC_L, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x7d\x00", JGE, 0, FE_PTR(2));
TEST("\x7d\x00", Jcc, FE_CC_GE, FE_PTR(2));
TEST("\x0f\x8d\x00\x00\x00\x00", JGE, FE_JMPL, FE_PTR(6));
TEST("\x0f\x8d\x00\x00\x00\x00", Jcc, FE_CC_GE|FE_JMPL, FE_PTR(6));
TEST("\x0f\x8d\x7c\x00\x00\x00", JGE, 0, FE_PTR(130));
TEST("\x0f\x8d\x7c\x00\x00\x00", Jcc, FE_CC_GE, FE_PTR(130));
TEST("\x0f\x9d\xc0", SETGE8r, 0, FE_AX);
TEST("\x0f\x9d\xc0", SETcc8r, FE_CC_GE, FE_AX);
TEST("\x0f\x9d\x00", SETGE8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x9d\x00", SETcc8m, FE_CC_GE, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9d\x00", SETGE8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9d\x00", SETcc8m, FE_CC_GE|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4d\xc0", CMOVGE32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x4d\xc0", CMOVcc32rr, FE_CC_GE, FE_AX, FE_AX);
TEST("\x0f\x4d\x00", CMOVGE32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4d\x00", CMOVcc32rm, FE_CC_GE, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4d\x00", CMOVGE32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4d\x00", CMOVcc32rm, FE_CC_GE|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xed\x08", CMPNLXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xed\x08", CMPccXADD32mrr, FE_CC_NL, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xed\x08", CMPNLXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xed\x08", CMPccXADD64mrr, FE_CC_NL, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x7e\x00", JLE, 0, FE_PTR(2));
TEST("\x7e\x00", Jcc, FE_CC_LE, FE_PTR(2));
TEST("\x0f\x8e\x00\x00\x00\x00", JLE, FE_JMPL, FE_PTR(6));
TEST("\x0f\x8e\x00\x00\x00\x00", Jcc, FE_CC_LE|FE_JMPL, FE_PTR(6));
TEST("\x0f\x8e\x7c\x00\x00\x00", JLE, 0, FE_PTR(130));
TEST("\x0f\x8e\x7c\x00\x00\x00", Jcc, FE_CC_LE, FE_PTR(130));
TEST("\x0f\x9e\xc0", SETLE8r, 0, FE_AX);
TEST("\x0f\x9e\xc0", SETcc8r, FE_CC_LE, FE_AX);
TEST("\x0f\x9e\x00", SETLE8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x9e\x00", SETcc8m, FE_CC_LE, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9e\x00", SETLE8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9e\x00", SETcc8m, FE_CC_LE|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4e\xc0", CMOVLE32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x4e\xc0", CMOVcc32rr, FE_CC_LE, FE_AX, FE_AX);
TEST("\x0f\x4e\x00", CMOVLE32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4e\x00", CMOVcc32rm, FE_CC_LE, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4e\x00", CMOVLE32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4e\x00", CMOVcc32rm, FE_CC_LE|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xee\x08", CMPLEXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xee\x08", CMPccXADD32mrr, FE_CC_LE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xee\x08", CMPLEXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xee\x08", CMPccXADD64mrr, FE_CC_LE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

TEST("\x7f\x00", JG, 0, FE_PTR(2));
TEST("\x7f\x00", Jcc, FE_CC_G, FE_PTR(2));
TEST("\x0f\x8f\x00\x00\x00\x00", JG, FE_JMPL, FE_PTR(6));
TEST("\x0f\x8f\x00\x00\x00\x00", Jcc, FE_CC_G|FE_JMPL, FE_PTR(6));
TEST("\x0f\x8f\x7c\x00\x00\x00", JG, 0, FE_PTR(130));
TEST("\x0f\x8f\x7c\x00\x00\x00", Jcc, FE_CC_G, FE_PTR(130));
TEST("\x0f\x9f\xc0", SETG8r, 0, FE_AX);
TEST("\x0f\x9f\xc0", SETcc8r, FE_CC_G, FE_AX);
TEST("\x0f\x9f\x00", SETG8m, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x9f\x00", SETcc8m, FE_CC_G, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9f\x00", SETG8m, FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x9f\x00", SETcc8m, FE_CC_G|FE_ADDR32, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4f\xc0", CMOVG32rr, 0, FE_AX, FE_AX);
TEST("\x0f\x4f\xc0", CMOVcc32rr, FE_CC_G, FE_AX, FE_AX);
TEST("\x0f\x4f\x00", CMOVG32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x0f\x4f\x00", CMOVcc32rm, FE_CC_G, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4f\x00", CMOVG32rm, FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x67\x0f\x4f\x00", CMOVcc32rm, FE_CC_G|FE_ADDR32, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x61\xef\x08", CMPNLEXADD32mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\x61\xef\x08", CMPccXADD32mrr, FE_CC_NLE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xef\x08", CMPNLEXADD64mrr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);
TEST("\xc4\xe2\xe1\xef\x08", CMPccXADD64mrr, FE_CC_NLE, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX, FE_BX);

// Test FD/TD encodings
TEST("\xa0\x00\x00\x00\x00\x00\x00\x00\x00", MOV8ra, 0, FE_AX, 0);
TEST("\x67\xa0\x00\x00\x00\x00", MOV8ra, FE_ADDR32, FE_AX, 0);
TEST("\x66\xa1\x00\x00\x00\x00\x00\x00\x00\x00", MOV16ra, 0, FE_AX, 0);
TEST("\x67\x66\xa1\x00\x00\x00\x00", MOV16ra, FE_ADDR32, FE_AX, 0);
TEST("\x66\xa1\x10\x32\x54\x76\x98\xba\xdc\xfe", MOV16ra, 0, FE_AX, 0xfedcba9876543210);
TEST("\x67\x66\xa1\x98\xba\xdc\xfe", MOV16ra, FE_ADDR32, FE_AX, 0xfedcba98);
TEST("\xa1\x10\x32\x54\x76\x98\xba\xdc\xfe", MOV32ra, 0, FE_AX, 0xfedcba9876543210);
TEST("\x67\xa1\x98\xba\xdc\xfe", MOV32ra, FE_ADDR32, FE_AX, 0xfedcba98);
TEST("\x48\xa1\x10\x32\x54\x76\x98\xba\xdc\xfe", MOV64ra, 0, FE_AX, 0xfedcba9876543210);
TEST("\x67\x48\xa1\x98\xba\xdc\xfe", MOV64ra, FE_ADDR32, FE_AX, 0xfedcba98);
TEST("\xa2\x00\x00\x00\x00\x00\x00\x00\x00", MOV8ar, 0, 0, FE_AX);
TEST("\x67\xa2\x00\x00\x00\x00", MOV8ar, FE_ADDR32, 0, FE_AX);
TEST("\x66\xa3\x00\x00\x00\x00\x00\x00\x00\x00", MOV16ar, 0, 0, FE_AX);
TEST("\x67\x66\xa3\x00\x00\x00\x00", MOV16ar, FE_ADDR32, 0, FE_AX);
TEST("\x66\xa3\x10\x32\x54\x76\x98\xba\xdc\xfe", MOV16ar, 0, 0xfedcba9876543210, FE_AX);
TEST("\x67\x66\xa3\x98\xba\xdc\xfe", MOV16ar, FE_ADDR32, 0xfedcba98, FE_AX);
TEST("\xa3\x10\x32\x54\x76\x98\xba\xdc\xfe", MOV32ar, 0, 0xfedcba9876543210, FE_AX);
TEST("\x67\xa3\x98\xba\xdc\xfe", MOV32ar, FE_ADDR32, 0xfedcba98, FE_AX);
TEST("\x48\xa3\x10\x32\x54\x76\x98\xba\xdc\xfe", MOV64ar, 0, 0xfedcba9876543210, FE_AX);
TEST("\x67\x48\xa3\x98\xba\xdc\xfe", MOV64ar, FE_ADDR32, 0xfedcba98, FE_AX);
TEST("", MOV8ra, 0, FE_CX, 0);
TEST("", MOV8ra, FE_ADDR32, FE_CX, 0);
TEST("", MOV16ra, 0, FE_CX, 0);
TEST("", MOV16ra, FE_ADDR32, FE_CX, 0);
TEST("", MOV16ra, 0, FE_CX, 0xfedcba9876543210);
TEST("", MOV16ra, FE_ADDR32, FE_CX, 0xfedcba98);
TEST("", MOV32ra, 0, FE_CX, 0xfedcba9876543210);
TEST("", MOV32ra, FE_ADDR32, FE_CX, 0xfedcba98);
TEST("", MOV64ra, 0, FE_CX, 0xfedcba9876543210);
TEST("", MOV64ra, FE_ADDR32, FE_CX, 0xfedcba98);
TEST("", MOV8ar, 0, 0, FE_CX);
TEST("", MOV8ar, FE_ADDR32, 0, FE_CX);
TEST("", MOV16ar, 0, 0, FE_CX);
TEST("", MOV16ar, FE_ADDR32, 0, FE_CX);
TEST("", MOV16ar, 0, 0xfedcba9876543210, FE_CX);
TEST("", MOV16ar, FE_ADDR32, 0xfedcba98, FE_CX);
TEST("", MOV32ar, 0, 0xfedcba9876543210, FE_CX);
TEST("", MOV32ar, FE_ADDR32, 0xfedcba98, FE_CX);
TEST("", MOV64ar, 0, 0xfedcba9876543210, FE_CX);
TEST("", MOV64ar, FE_ADDR32, 0xfedcba98, FE_CX);

TEST("\xc7\xf8\x02\x00\x00\x00", XBEGIN, 0, FE_PTR(8));

// BMI1
TEST("\xf3\x0f\xbc\xc2", TZCNT32rr, 0, FE_AX, FE_DX);
TEST("\x66\xf3\x0f\xbc\xc2", TZCNT16rr, 0, FE_AX, FE_DX);
TEST("\xf3\x48\x0f\xbc\xc2", TZCNT64rr, 0, FE_AX, FE_DX);
TEST("\xf3\x0f\xbd\xc2", LZCNT32rr, 0, FE_AX, FE_DX);
TEST("\x66\xf3\x0f\xbd\xc2", LZCNT16rr, 0, FE_AX, FE_DX);
TEST("\xf3\x48\x0f\xbd\xc2", LZCNT64rr, 0, FE_AX, FE_DX);
TEST("\xc4\xc2\x18\xf2\xc7", ANDN32rrr, 0, FE_AX, FE_R12, FE_R15);
TEST("\xc4\xc2\x98\xf2\xc7", ANDN64rrr, 0, FE_AX, FE_R12, FE_R15);
TEST("\xc4\x42\x18\xf2\xc7", ANDN32rrr, 0, FE_R8, FE_R12, FE_R15);
TEST("\xc4\x42\x98\xf2\xc7", ANDN64rrr, 0, FE_R8, FE_R12, FE_R15);
TEST("\xc4\xe2\x78\xf3\xca", BLSR32rr, 0, FE_AX, FE_DX);
TEST("\xc4\xe2\x78\xf3\x08", BLSR32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf8\xf3\xca", BLSR64rr, 0, FE_AX, FE_DX);
TEST("\xc4\xe2\xf8\xf3\x08", BLSR64rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xc2\x38\xf3\xc9", BLSR32rr, 0, FE_R8, FE_R9);
TEST("\xc4\xc2\xb8\xf3\xc9", BLSR64rr, 0, FE_R8, FE_R9);
TEST("\xc4\xe2\x38\xf3\xc9", BLSR32rr, 0, FE_R8, FE_CX);
TEST("\xc4\xe2\xb8\xf3\xc9", BLSR64rr, 0, FE_R8, FE_CX);
TEST("\xc4\xc2\x78\xf3\xc9", BLSR32rr, 0, FE_AX, FE_R9);
TEST("\xc4\xc2\xf8\xf3\xc9", BLSR64rr, 0, FE_AX, FE_R9);
TEST("\xc4\xe2\x78\xf3\xd2", BLSMSK32rr, 0, FE_AX, FE_DX);
TEST("\xc4\xe2\x78\xf3\x10", BLSMSK32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf8\xf3\xd2", BLSMSK64rr, 0, FE_AX, FE_DX);
TEST("\xc4\xe2\xf8\xf3\x10", BLSMSK64rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x78\xf3\xda", BLSI32rr, 0, FE_AX, FE_DX);
TEST("\xc4\xe2\x78\xf3\x18", BLSI32rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf8\xf3\xda", BLSI64rr, 0, FE_AX, FE_DX);
TEST("\xc4\xe2\xf8\xf3\x18", BLSI64rm, 0, FE_AX, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xc2\x18\xf7\xc7", BEXTR32rrr, 0, FE_AX, FE_R15, FE_R12);
TEST("\xc4\xc2\x98\xf7\xc7", BEXTR64rrr, 0, FE_AX, FE_R15, FE_R12);
TEST("\xc4\x42\x18\xf7\xc7", BEXTR32rrr, 0, FE_R8, FE_R15, FE_R12);
TEST("\xc4\x42\x98\xf7\xc7", BEXTR64rrr, 0, FE_R8, FE_R15, FE_R12);

TEST("\x0f\x30", WRMSR, 0);
TEST("\x0f\x32", RDMSR, 0);
TEST("\x0f\x01\xc6", WRMSRNS, 0);
TEST("\xf2\x0f\x01\xc6", RDMSRLIST, 0);
TEST("\xf3\x0f\x01\xc6", WRMSRLIST, 0);
TEST("\xc4\xe7\x7b\xf6\xc1\x10\x20\x30\x40", RDMSRri, 0, FE_CX, 0x40302010);
TEST("\xc4\xe7\x7a\xf6\xc1\x10\x20\x30\x40", WRMSRNSir, 0, 0x40302010, FE_CX);
TEST("\xf2\x0f\x38\xf8\xc1", URDMSRrr, 0, FE_CX, FE_AX);
TEST("\xf3\x0f\x38\xf8\xc1", UWRMSRrr, 0, FE_CX, FE_AX);
TEST("\xc4\xe7\x7b\xf8\xc1\x10\x20\x30\x40", URDMSRri, 0, FE_CX, 0x40302010);
TEST("\xc4\xe7\x7a\xf8\xc1\x10\x20\x30\x40", UWRMSRir, 0, 0x40302010, FE_CX);

TEST("\x0f\x38\xfc\x01", AADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x48\x0f\x38\xfc\x01", AADD64mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x66\x0f\x38\xfc\x01", AAND32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x66\x48\x0f\x38\xfc\x01", AAND64mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\xf3\x0f\x38\xfc\x01", AXOR32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\xf3\x48\x0f\x38\xfc\x01", AXOR64mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\xf2\x0f\x38\xfc\x01", AOR32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\xf2\x48\x0f\x38\xfc\x01", AOR64mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);

// Test FPU instructions
TEST("\xd8\x00", FADDm32, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xdc\x00", FADDm64, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xd8\xc0", FADDrr, 0, FE_ST0, FE_ST0);
TEST("\xd8\xc1", FADDrr, 0, FE_ST0, FE_ST1);
TEST("\xdc\xc1", FADDrr, 0, FE_ST1, FE_ST0);
TEST("", FADDrr, 0, FE_ST1, FE_ST1);
TEST("\xde\xc1", FADDPrr, 0, FE_ST1, FE_ST0);
TEST("\xda\x00", FIADDm32, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xde\x00", FIADDm16, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xd9\x00", FLDm32, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xdd\x00", FLDm64, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xdb\x28", FLDm80, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xdf\x00", FILDm16, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xdb\x00", FILDm32, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xdf\x28", FILDm64, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xd9\xc1", FLDr, 0, FE_ST1);
TEST("\xd9\xe8", FLD1, 0);
TEST("\xdf\xe0", FSTSWr, 0, FE_AX);
TEST("", FSTSWr, 0, FE_CX);

// Test VEX encoding
TEST("\xc5\xfc\x77", VZEROALL, 0);
TEST("\xc5\xf8\x77", VZEROUPPER, 0);
TEST("\xc5\xf2\x58\xc2", VADDSSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc5\xf0\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc5\xf4\x58\xc2", VADDPS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xc1\x74\x58\xc0", VADDPS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM8);
TEST("\xc4\x62\x7d\x19\xc2", VBROADCASTSD256rr, 0, FE_XMM8, FE_XMM2);
TEST("\xc4\x62\x7d\x1a\xc2", VBROADCASTF128_256rr, 0, FE_XMM8, FE_XMM2);
TEST("\xc4\xe2\x71\x9d\xc2", VFNMADD132SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9d\xc2", VFNMADD132SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x2e\x17", VMASKMOVPS128mrr, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0), FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x2e\x17", VMASKMOVPS256mrr, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0), FE_XMM1, FE_XMM2);
TEST("\xc5\xf1\x71\xd7\x02", VPSRLW128rri, 0, FE_XMM1, FE_XMM7, 0x2);
TEST("\xc5\xf5\x71\xd7\x02", VPSRLW256rri, 0, FE_XMM1, FE_XMM7, 0x2);
TEST("\xc4\xc3\xfd\x00\xc9\x12", VPERMQ256rri, 0, FE_XMM1, FE_XMM9, 0x12);
TEST("\xc4\xe3\xfd\x01\xcf\x12", VPERMPD256rri, 0, FE_XMM1, FE_XMM7, 0x12);
TEST("\xc5\xf9\xc5\xc0\x00", VPEXTRWrri, 0, FE_AX, FE_XMM0, 0x0);
// VMASKMOVDQU is the only VEX instruction which supports addrsize/segment
// overrides without a memory operand.
TEST("\xc5\xf9\xf7\xc1", VMASKMOVDQU128rr, 0, FE_XMM0, FE_XMM1);
TEST("\x64\xc5\xf9\xf7\xc1", VMASKMOVDQU128rr, FE_SEG(FE_FS), FE_XMM0, FE_XMM1);
TEST("\x67\xc5\xf9\xf7\xc1", VMASKMOVDQU128rr, FE_ADDR32, FE_XMM0, FE_XMM1);
TEST("\x64\x67\xc5\xf9\xf7\xc1", VMASKMOVDQU128rr, FE_ADDR32|FE_SEG(FE_FS), FE_XMM0, FE_XMM1);

// Test VEX.RXBv
TEST("\xc5\xf4\x58\xc2", VADDPS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc5\x74\x58\xc2", VADDPS256rrr, 0, FE_XMM8, FE_XMM1, FE_XMM2);
TEST("\xc5\xb4\x58\xc2", VADDPS256rrr, 0, FE_XMM0, FE_XMM9, FE_XMM2);
TEST("\xc5\x34\x58\xc2", VADDPS256rrr, 0, FE_XMM8, FE_XMM9, FE_XMM2);
TEST("\xc4\xc1\x74\x58\xc2", VADDPS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM10);
TEST("\xc4\x41\x74\x58\xc2", VADDPS256rrr, 0, FE_XMM8, FE_XMM1, FE_XMM10);
TEST("\xc4\xc1\x34\x58\xc2", VADDPS256rrr, 0, FE_XMM0, FE_XMM9, FE_XMM10);
TEST("\xc4\x41\x34\x58\xc2", VADDPS256rrr, 0, FE_XMM8, FE_XMM9, FE_XMM10);

TEST("\xc5\xf4\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0));
TEST("\xc5\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0));
TEST("\xc4\xa1\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0));
TEST("\xc4\x21\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0));
TEST("\xc5\xb4\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0));
TEST("\xc5\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0));
TEST("\xc4\xa1\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0));
TEST("\xc4\x21\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0));
TEST("\xc4\xc1\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0));
TEST("\xc4\x41\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0));
TEST("\xc4\x81\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0));
TEST("\xc4\x01\x74\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0));
TEST("\xc4\xc1\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0));
TEST("\xc4\x41\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0));
TEST("\xc4\x81\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0));
TEST("\xc4\x01\x34\x58\x04\x1a", VADDPS256rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0));

// Test RVMR encoding
TEST("\xc4\xe3\x71\x4a\xc2\x30", VBLENDVPS128rrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2, FE_XMM3);
TEST("\xc4\xe3\x75\x4a\xc2\x30", VBLENDVPS256rrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2, FE_XMM3);
TEST("\xc4\xe3\x71\x4a\x05\x00\x00\x00\x00\x20", VBLENDVPS128rrmr, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_IP, 0, FE_NOREG, 10), FE_XMM2);
TEST("\xc4\xe3\x75\x4a\x05\x00\x00\x00\x00\x20", VBLENDVPS256rrmr, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_IP, 0, FE_NOREG, 10), FE_XMM2);

// Make sure that high registers fail with VEX-only instructions
TEST("", VBLENDVPS128rrrr, 0, FE_XMM16, FE_XMM1, FE_XMM2, FE_XMM3);
TEST("", VBLENDVPS128rrrr, 0, FE_XMM0, FE_XMM17, FE_XMM2, FE_XMM3);
TEST("", VBLENDVPS128rrrr, 0, FE_XMM0, FE_XMM1, FE_XMM18, FE_XMM3);
TEST("", VBLENDVPS128rrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2, FE_XMM19);
TEST("", VGATHERDPS128rmr, 0, FE_XMM16, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM17, 0), FE_XMM1);
TEST("", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM18);

TEST("\xc4\xe2\x71\x96\xc2", VFMADDSUB132PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x96\x06", VFMADDSUB132PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\x96\xc2", VFMADDSUB132PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x96\x06", VFMADDSUB132PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x96\xc2", VFMADDSUB132PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x96\x06", VFMADDSUB132PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\x96\xc2", VFMADDSUB132PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\x96\x06", VFMADDSUB132PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x97\xc2", VFMSUBADD132PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x97\x06", VFMSUBADD132PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\x97\xc2", VFMSUBADD132PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x97\x06", VFMSUBADD132PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x97\xc2", VFMSUBADD132PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x97\x06", VFMSUBADD132PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\x97\xc2", VFMSUBADD132PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\x97\x06", VFMSUBADD132PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x98\xc2", VFMADD132PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x98\x06", VFMADD132PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\x98\xc2", VFMADD132PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x98\x06", VFMADD132PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x98\xc2", VFMADD132PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x98\x06", VFMADD132PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\x98\xc2", VFMADD132PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\x98\x06", VFMADD132PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x99\xc2", VFMADD132SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x99\x06", VFMADD132SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x99\xc2", VFMADD132SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x99\x06", VFMADD132SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x9a\xc2", VFMSUB132PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x9a\x06", VFMSUB132PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\x9a\xc2", VFMSUB132PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x9a\x06", VFMSUB132PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x9a\xc2", VFMSUB132PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9a\x06", VFMSUB132PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\x9a\xc2", VFMSUB132PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\x9a\x06", VFMSUB132PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x9b\xc2", VFMSUB132SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x9b\x06", VFMSUB132SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x9b\xc2", VFMSUB132SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9b\x06", VFMSUB132SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x9c\xc2", VFNMADD132PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x9c\x06", VFNMADD132PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\x9c\xc2", VFNMADD132PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x9c\x06", VFNMADD132PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x9c\xc2", VFNMADD132PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9c\x06", VFNMADD132PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\x9c\xc2", VFNMADD132PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\x9c\x06", VFNMADD132PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x9d\xc2", VFNMADD132SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x9d\x06", VFNMADD132SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x9d\xc2", VFNMADD132SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9d\x06", VFNMADD132SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x9e\xc2", VFNMSUB132PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x9e\x06", VFNMSUB132PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\x9e\xc2", VFNMSUB132PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x9e\x06", VFNMSUB132PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x9e\xc2", VFNMSUB132PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9e\x06", VFNMSUB132PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\x9e\xc2", VFNMSUB132PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\x9e\x06", VFNMSUB132PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\x9f\xc2", VFNMSUB132SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x9f\x06", VFNMSUB132SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\x9f\xc2", VFNMSUB132SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\x9f\x06", VFNMSUB132SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xa6\xc2", VFMADDSUB213PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xa6\x06", VFMADDSUB213PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xa6\xc2", VFMADDSUB213PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xa6\x06", VFMADDSUB213PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xa6\xc2", VFMADDSUB213PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xa6\x06", VFMADDSUB213PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xa6\xc2", VFMADDSUB213PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xa6\x06", VFMADDSUB213PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xa7\xc2", VFMSUBADD213PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xa7\x06", VFMSUBADD213PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xa7\xc2", VFMSUBADD213PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xa7\x06", VFMSUBADD213PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xa7\xc2", VFMSUBADD213PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xa7\x06", VFMSUBADD213PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xa7\xc2", VFMSUBADD213PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xa7\x06", VFMSUBADD213PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xa8\xc2", VFMADD213PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xa8\x06", VFMADD213PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xa8\xc2", VFMADD213PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xa8\x06", VFMADD213PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xa8\xc2", VFMADD213PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xa8\x06", VFMADD213PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xa8\xc2", VFMADD213PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xa8\x06", VFMADD213PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xa9\xc2", VFMADD213SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xa9\x06", VFMADD213SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xa9\xc2", VFMADD213SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xa9\x06", VFMADD213SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xaa\xc2", VFMSUB213PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xaa\x06", VFMSUB213PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xaa\xc2", VFMSUB213PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xaa\x06", VFMSUB213PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xaa\xc2", VFMSUB213PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xaa\x06", VFMSUB213PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xaa\xc2", VFMSUB213PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xaa\x06", VFMSUB213PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xab\xc2", VFMSUB213SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xab\x06", VFMSUB213SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xab\xc2", VFMSUB213SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xab\x06", VFMSUB213SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xac\xc2", VFNMADD213PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xac\x06", VFNMADD213PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xac\xc2", VFNMADD213PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xac\x06", VFNMADD213PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xac\xc2", VFNMADD213PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xac\x06", VFNMADD213PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xac\xc2", VFNMADD213PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xac\x06", VFNMADD213PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xad\xc2", VFNMADD213SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xad\x06", VFNMADD213SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xad\xc2", VFNMADD213SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xad\x06", VFNMADD213SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xae\xc2", VFNMSUB213PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xae\x06", VFNMSUB213PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xae\xc2", VFNMSUB213PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xae\x06", VFNMSUB213PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xae\xc2", VFNMSUB213PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xae\x06", VFNMSUB213PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xae\xc2", VFNMSUB213PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xae\x06", VFNMSUB213PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xaf\xc2", VFNMSUB213SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xaf\x06", VFNMSUB213SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xaf\xc2", VFNMSUB213SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xaf\x06", VFNMSUB213SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xb6\xc2", VFMADDSUB231PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xb6\x06", VFMADDSUB231PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xb6\xc2", VFMADDSUB231PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xb6\x06", VFMADDSUB231PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xb6\xc2", VFMADDSUB231PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xb6\x06", VFMADDSUB231PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xb6\xc2", VFMADDSUB231PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xb6\x06", VFMADDSUB231PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xb7\xc2", VFMSUBADD231PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xb7\x06", VFMSUBADD231PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xb7\xc2", VFMSUBADD231PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xb7\x06", VFMSUBADD231PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xb7\xc2", VFMSUBADD231PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xb7\x06", VFMSUBADD231PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xb7\xc2", VFMSUBADD231PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xb7\x06", VFMSUBADD231PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xb8\xc2", VFMADD231PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xb8\x06", VFMADD231PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xb8\xc2", VFMADD231PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xb8\x06", VFMADD231PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xb8\xc2", VFMADD231PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xb8\x06", VFMADD231PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xb8\xc2", VFMADD231PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xb8\x06", VFMADD231PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xb9\xc2", VFMADD231SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xb9\x06", VFMADD231SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xb9\xc2", VFMADD231SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xb9\x06", VFMADD231SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xba\xc2", VFMSUB231PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xba\x06", VFMSUB231PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xba\xc2", VFMSUB231PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xba\x06", VFMSUB231PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xba\xc2", VFMSUB231PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xba\x06", VFMSUB231PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xba\xc2", VFMSUB231PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xba\x06", VFMSUB231PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xbb\xc2", VFMSUB231SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xbb\x06", VFMSUB231SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xbb\xc2", VFMSUB231SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xbb\x06", VFMSUB231SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xbc\xc2", VFNMADD231PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xbc\x06", VFNMADD231PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xbc\xc2", VFNMADD231PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xbc\x06", VFNMADD231PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xbc\xc2", VFNMADD231PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xbc\x06", VFNMADD231PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xbc\xc2", VFNMADD231PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xbc\x06", VFNMADD231PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xbd\xc2", VFNMADD231SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xbd\x06", VFNMADD231SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xbd\xc2", VFNMADD231SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xbd\x06", VFNMADD231SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xbe\xc2", VFNMSUB231PS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xbe\x06", VFNMSUB231PS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x75\xbe\xc2", VFNMSUB231PS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xbe\x06", VFNMSUB231PS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xbe\xc2", VFNMSUB231PD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xbe\x06", VFNMSUB231PD128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf5\xbe\xc2", VFNMSUB231PD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xbe\x06", VFNMSUB231PD256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x71\xbf\xc2", VFNMSUB231SSrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xbf\x06", VFNMSUB231SSrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));
TEST("\xc4\xe2\xf1\xbf\xc2", VFNMSUB231SDrrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xbf\x06", VFNMSUB231SDrrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_SI, 0, FE_NOREG, 0));

// VSIB encodings
#ifndef ENC_TEST_TYPESAFE
TEST("", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEM(FE_DI, 8, FE_NOREG, 0), FE_XMM1); // must have SIB
TEST("", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0), FE_XMM1); // must have SIB
TEST("", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEM(FE_DI, 0, FE_AX, 0), FE_XMM1); // must have XMM index
#endif
TEST("\xc4\xe2\x71\x92\x04\xff", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x92\x04\xe7", VGATHERDPS128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x92\x04\xff", VGATHERDPS256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x92\x04\xe7", VGATHERDPS256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x93\x04\xff", VGATHERQPS128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x93\x04\xe7", VGATHERQPS128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x93\x04\xff", VGATHERQPS256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x93\x04\xe7", VGATHERQPS256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x92\x04\xff", VGATHERDPD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x92\x04\xe7", VGATHERDPD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x92\x04\xff", VGATHERDPD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x92\x04\xe7", VGATHERDPD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x93\x04\xff", VGATHERQPD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x93\x04\xe7", VGATHERQPD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x93\x04\xff", VGATHERQPD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x93\x04\xe7", VGATHERQPD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x90\x04\xff", VPGATHERDD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x90\x04\xe7", VPGATHERDD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x90\x04\xff", VPGATHERDD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x90\x04\xe7", VPGATHERDD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x91\x04\xff", VPGATHERQD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x71\x91\x04\xe7", VPGATHERQD128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x91\x04\xff", VPGATHERQD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\x75\x91\x04\xe7", VPGATHERQD256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x90\x04\xff", VPGATHERDQ128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x90\x04\xe7", VPGATHERDQ128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x90\x04\xff", VPGATHERDQ256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x90\x04\xe7", VPGATHERDQ256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x91\x04\xff", VPGATHERQQ128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf1\x91\x04\xe7", VPGATHERQQ128rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x91\x04\xff", VPGATHERQQ256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM7, 0), FE_XMM1);
TEST("\xc4\xe2\xf5\x91\x04\xe7", VPGATHERQQ256rmr, 0, FE_XMM0, FE_MEMV(FE_DI, 8, FE_XMM4, 0), FE_XMM1);

TEST("\xc4\xe2\x79\xdb\xc1", VAESIMCrr, 0, FE_XMM0, FE_XMM1);
TEST("\xc4\xe3\x79\xdf\xc1\xae", VAESKEYGENASSISTrri, 0, FE_XMM0, FE_XMM1, (int8_t) 0xae);
TEST("\xc4\xe2\x71\xdc\xc2", VAESENC128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xdc\xc2", VAESENC256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xdd\xc2", VAESENCLAST128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xdd\xc2", VAESENCLAST256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xde\xc2", VAESDEC128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xde\xc2", VAESDEC256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\xdf\xc2", VAESDECLAST128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\xdf\xc2", VAESDECLAST256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);

TEST("\xc4\xe2\x70\x50\xc2", VPDPBUUD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x74\x50\xc2", VPDPBUUD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x50\xc2", VPDPBUSD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x50\xc2", VPDPBUSD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x72\x50\xc2", VPDPBSUD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x76\x50\xc2", VPDPBSUD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x73\x50\xc2", VPDPBSSD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x77\x50\xc2", VPDPBSSD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x70\x51\xc2", VPDPBUUDS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x74\x51\xc2", VPDPBUUDS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x51\xc2", VPDPBUSDS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x51\xc2", VPDPBUSDS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x72\x51\xc2", VPDPBSUDS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x76\x51\xc2", VPDPBSUDS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x73\x51\xc2", VPDPBSSDS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x77\x51\xc2", VPDPBSSDS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x52\xc2", VPDPWSSD128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x52\xc2", VPDPWSSD256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x71\x53\xc2", VPDPWSSDS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\x75\x53\xc2", VPDPWSSDS256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);

TEST("\xc4\xe2\x78\xb0\x08", VCVTNEOPH2PS128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7c\xb0\x08", VCVTNEOPH2PS256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x79\xb0\x08", VCVTNEEPH2PS128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7d\xb0\x08", VCVTNEEPH2PS256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7a\xb0\x08", VCVTNEEBF162PS128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7e\xb0\x08", VCVTNEEBF162PS256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7b\xb0\x08", VCVTNEOBF162PS128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7f\xb0\x08", VCVTNEOBF162PS256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x79\xb1\x08", VBCSTNESH2PS128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7d\xb1\x08", VBCSTNESH2PS256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7a\xb1\x08", VBCSTNEBF162PS128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7e\xb1\x08", VBCSTNEBF162PS256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x7a\x72\xc1", VCVTNEPS2BF16_128rr, 0, FE_XMM0, FE_XMM1);
TEST("\xc4\xe2\x7e\x72\xc1", VCVTNEPS2BF16_256rr, 0, FE_XMM0, FE_XMM1);

TEST("\xc4\xe2\xf1\xb4\xc2", VPMADD52LUQ128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xb4\xc2", VPMADD52LUQ256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf1\xb5\xc2", VPMADD52HUQ128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc4\xe2\xf5\xb5\xc2", VPMADD52HUQ256rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);

// AVX-512
// NB: VEX instructions are here to test automatic downgrading from EVEX to VEX.

// EVEX functionality; VEX-downgrade occasionally prevented with mask
// Part 1: register extension bits for rrr/rri
TEST("\xc5\xf0\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x09\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\xc5\x70\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM1, FE_XMM2);
TEST("\x62\x71\x74\x09\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM1, FE_XMM2);
TEST("\x62\xe1\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM1, FE_XMM2);
TEST("\x62\x61\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM1, FE_XMM2);
TEST("\xc5\xb0\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM9, FE_XMM2);
TEST("\x62\xf1\x34\x09\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM9, FE_XMM2);
TEST("\xc5\x30\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM9, FE_XMM2);
TEST("\x62\x71\x34\x09\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM9, FE_XMM2);
TEST("\x62\xe1\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM9, FE_XMM2);
TEST("\x62\x61\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM9, FE_XMM2);
TEST("\x62\xf1\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM17, FE_XMM2);
TEST("\x62\x71\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM17, FE_XMM2);
TEST("\x62\xe1\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM17, FE_XMM2);
TEST("\x62\x61\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM17, FE_XMM2);
TEST("\x62\xf1\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM25, FE_XMM2);
TEST("\x62\x71\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM25, FE_XMM2);
TEST("\x62\xe1\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM25, FE_XMM2);
TEST("\x62\x61\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM25, FE_XMM2);
TEST("\xc4\xc1\x70\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM10);
TEST("\xc4\x41\x70\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM1, FE_XMM10);
TEST("\x62\xc1\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM1, FE_XMM10);
TEST("\x62\x41\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM1, FE_XMM10);
TEST("\xc4\xc1\x30\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM9, FE_XMM10);
TEST("\xc4\x41\x30\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM9, FE_XMM10);
TEST("\x62\xc1\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM9, FE_XMM10);
TEST("\x62\x41\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM9, FE_XMM10);
TEST("\x62\xd1\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM17, FE_XMM10);
TEST("\x62\x51\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM17, FE_XMM10);
TEST("\x62\xc1\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM17, FE_XMM10);
TEST("\x62\x41\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM17, FE_XMM10);
TEST("\x62\xd1\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM25, FE_XMM10);
TEST("\x62\x51\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM25, FE_XMM10);
TEST("\x62\xc1\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM25, FE_XMM10);
TEST("\x62\x41\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM25, FE_XMM10);
TEST("\x62\xb1\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM18);
TEST("\x62\x31\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM1, FE_XMM18);
TEST("\x62\xa1\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM1, FE_XMM18);
TEST("\x62\x21\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM1, FE_XMM18);
TEST("\x62\xb1\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM9, FE_XMM18);
TEST("\x62\x31\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM9, FE_XMM18);
TEST("\x62\xa1\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM9, FE_XMM18);
TEST("\x62\x21\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM9, FE_XMM18);
TEST("\x62\xb1\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM17, FE_XMM18);
TEST("\x62\x31\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM17, FE_XMM18);
TEST("\x62\xa1\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM17, FE_XMM18);
TEST("\x62\x21\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM17, FE_XMM18);
TEST("\x62\xb1\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM25, FE_XMM18);
TEST("\x62\x31\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM25, FE_XMM18);
TEST("\x62\xa1\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM25, FE_XMM18);
TEST("\x62\x21\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM25, FE_XMM18);
TEST("\x62\x91\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM1, FE_XMM26);
TEST("\x62\x11\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM1, FE_XMM26);
TEST("\x62\x81\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM1, FE_XMM26);
TEST("\x62\x01\x74\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM1, FE_XMM26);
TEST("\x62\x91\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM9, FE_XMM26);
TEST("\x62\x11\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM9, FE_XMM26);
TEST("\x62\x81\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM9, FE_XMM26);
TEST("\x62\x01\x34\x08\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM9, FE_XMM26);
TEST("\x62\x91\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM17, FE_XMM26);
TEST("\x62\x11\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM17, FE_XMM26);
TEST("\x62\x81\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM17, FE_XMM26);
TEST("\x62\x01\x74\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM17, FE_XMM26);
TEST("\x62\x91\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM0, FE_XMM25, FE_XMM26);
TEST("\x62\x11\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM8, FE_XMM25, FE_XMM26);
TEST("\x62\x81\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM16, FE_XMM25, FE_XMM26);
TEST("\x62\x01\x34\x00\x58\xc2", VADDPS128rrr, 0, FE_XMM24, FE_XMM25, FE_XMM26);
TEST("\xc5\xf9\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM0, FE_XMM1, 1);
TEST("\xc5\xb9\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM8, FE_XMM1, 1);
TEST("\x62\xf1\x7d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM16, FE_XMM1, 1);
TEST("\x62\xf1\x3d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM24, FE_XMM1, 1);
TEST("\xc4\xc1\x79\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM0, FE_XMM9, 1);
TEST("\xc4\xc1\x39\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM8, FE_XMM9, 1);
TEST("\x62\xd1\x7d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM16, FE_XMM9, 1);
TEST("\x62\xd1\x3d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM24, FE_XMM9, 1);
TEST("\x62\xb1\x7d\x08\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM0, FE_XMM17, 1);
TEST("\x62\xb1\x3d\x08\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM8, FE_XMM17, 1);
TEST("\x62\xb1\x7d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM16, FE_XMM17, 1);
TEST("\x62\xb1\x3d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM24, FE_XMM17, 1);
TEST("\x62\x91\x7d\x08\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM0, FE_XMM25, 1);
TEST("\x62\x91\x3d\x08\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM8, FE_XMM25, 1);
TEST("\x62\x91\x7d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM16, FE_XMM25, 1);
TEST("\x62\x91\x3d\x00\x71\xd1\x01", VPSRLW128rri, 0, FE_XMM24, FE_XMM25, 1);
TEST("\xc5\xfd\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM0, FE_XMM1, 1);
TEST("\xc5\xbd\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM8, FE_XMM1, 1);
TEST("\x62\xf1\x7d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM16, FE_XMM1, 1);
TEST("\x62\xf1\x3d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM24, FE_XMM1, 1);
TEST("\xc4\xc1\x7d\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM0, FE_XMM9, 1);
TEST("\xc4\xc1\x3d\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM8, FE_XMM9, 1);
TEST("\x62\xd1\x7d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM16, FE_XMM9, 1);
TEST("\x62\xd1\x3d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM24, FE_XMM9, 1);
TEST("\x62\xb1\x7d\x28\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM0, FE_XMM17, 1);
TEST("\x62\xb1\x3d\x28\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM8, FE_XMM17, 1);
TEST("\x62\xb1\x7d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM16, FE_XMM17, 1);
TEST("\x62\xb1\x3d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM24, FE_XMM17, 1);
TEST("\x62\x91\x7d\x28\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM0, FE_XMM25, 1);
TEST("\x62\x91\x3d\x28\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM8, FE_XMM25, 1);
TEST("\x62\x91\x7d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM16, FE_XMM25, 1);
TEST("\x62\x91\x3d\x20\x71\xd1\x01", VPSRLW256rri, 0, FE_XMM24, FE_XMM25, 1);
TEST("\x62\xf1\x7d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM0, FE_XMM1, 1);
TEST("\x62\xf1\x3d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM8, FE_XMM1, 1);
TEST("\x62\xf1\x7d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM16, FE_XMM1, 1);
TEST("\x62\xf1\x3d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM24, FE_XMM1, 1);
TEST("\x62\xd1\x7d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM0, FE_XMM9, 1);
TEST("\x62\xd1\x3d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM8, FE_XMM9, 1);
TEST("\x62\xd1\x7d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM16, FE_XMM9, 1);
TEST("\x62\xd1\x3d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM24, FE_XMM9, 1);
TEST("\x62\xb1\x7d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM0, FE_XMM17, 1);
TEST("\x62\xb1\x3d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM8, FE_XMM17, 1);
TEST("\x62\xb1\x7d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM16, FE_XMM17, 1);
TEST("\x62\xb1\x3d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM24, FE_XMM17, 1);
TEST("\x62\x91\x7d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM0, FE_XMM25, 1);
TEST("\x62\x91\x3d\x48\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM8, FE_XMM25, 1);
TEST("\x62\x91\x7d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM16, FE_XMM25, 1);
TEST("\x62\x91\x3d\x40\x71\xd1\x01", VPSRLW512rri, 0, FE_XMM24, FE_XMM25, 1);
// Part 2: register extension bits with rrm
TEST("\xc5\xf0\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xf1\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\xc5\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x71\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xe1\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x61\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM1, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\xc5\xb0\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xf1\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\xc5\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x71\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xe1\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x61\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM9, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xf1\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xf1\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x71\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM17, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x71\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM17, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xe1\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM17, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x61\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM17, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xf1\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM25, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x71\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM25, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\xe1\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM25, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\x62\x61\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM25, FE_MEM(FE_DX, 1, FE_BX, 0x40));
TEST("\xc4\xa1\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xb1\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\xc4\x21\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x31\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xa1\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x21\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM1, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\xc4\xa1\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xb1\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\xc4\x21\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x31\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xa1\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x21\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM9, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xb1\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xb1\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x31\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM17, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x31\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM17, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xa1\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM17, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x21\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM17, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xb1\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM25, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x31\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM25, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\xa1\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM25, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\x62\x21\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM25, FE_MEM(FE_DX, 1, FE_R11, 0x40));
TEST("\xc4\xc1\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xd1\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\xc4\x41\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x51\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xc1\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x41\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM1, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\xc4\xc1\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xd1\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\xc4\x41\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x51\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xc1\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x41\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM9, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xd1\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xd1\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM17, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x51\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM17, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x51\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM17, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xc1\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM17, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x41\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM17, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xd1\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM25, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x51\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM25, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\xc1\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM25, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\x62\x41\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM25, FE_MEM(FE_R10, 1, FE_BX, 0x40));
TEST("\xc4\x81\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x91\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\xc4\x01\x70\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x11\x74\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x81\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x01\x74\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM1, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\xc4\x81\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM0, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x91\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\xc4\x01\x30\x58\x44\x1a\x40", VADDPS128rrm, 0, FE_XMM8, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x11\x34\x09\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x81\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x01\x34\x08\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM9, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x91\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x91\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM17, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x11\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM17, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x11\x74\x01\x58\x44\x1a\x04", VADDPS128rrm_mask, FLAGMASK(0, FE_K1), FE_XMM8, FE_XMM17, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x81\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM17, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x01\x74\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM17, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x91\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM0, FE_XMM25, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x11\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM8, FE_XMM25, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x81\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM16, FE_XMM25, FE_MEM(FE_R10, 1, FE_R11, 0x40));
TEST("\x62\x01\x34\x00\x58\x44\x1a\x04", VADDPS128rrm, 0, FE_XMM24, FE_XMM25, FE_MEM(FE_R10, 1, FE_R11, 0x40));
// Part 3: register extension bits with general-purpose register
TEST("\xc4\xe3\x71\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM1, FE_DX, 1);
TEST("\xc4\xc3\x71\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM1, FE_R10, 1);
TEST("\xc4\x63\x71\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM1, FE_DX, 1);
TEST("\xc4\x43\x71\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM1, FE_R10, 1);
TEST("\x62\xe3\x75\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM1, FE_DX, 1);
TEST("\x62\xc3\x75\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM1, FE_R10, 1);
TEST("\x62\x63\x75\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM1, FE_DX, 1);
TEST("\x62\x43\x75\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM1, FE_R10, 1);
TEST("\xc4\xe3\x31\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM9, FE_DX, 1);
TEST("\xc4\xc3\x31\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM9, FE_R10, 1);
TEST("\xc4\x63\x31\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM9, FE_DX, 1);
TEST("\xc4\x43\x31\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM9, FE_R10, 1);
TEST("\x62\xe3\x35\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM9, FE_DX, 1);
TEST("\x62\xc3\x35\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM9, FE_R10, 1);
TEST("\x62\x63\x35\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM9, FE_DX, 1);
TEST("\x62\x43\x35\x08\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM9, FE_R10, 1);
TEST("\x62\xf3\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM17, FE_DX, 1);
TEST("\x62\xd3\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM17, FE_R10, 1);
TEST("\x62\x73\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM17, FE_DX, 1);
TEST("\x62\x53\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM17, FE_R10, 1);
TEST("\x62\xe3\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM17, FE_DX, 1);
TEST("\x62\xc3\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM17, FE_R10, 1);
TEST("\x62\x63\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM17, FE_DX, 1);
TEST("\x62\x43\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM17, FE_R10, 1);
TEST("\x62\xf3\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM25, FE_DX, 1);
TEST("\x62\xd3\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM25, FE_R10, 1);
TEST("\x62\x73\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM25, FE_DX, 1);
TEST("\x62\x53\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM8, FE_XMM25, FE_R10, 1);
TEST("\x62\xe3\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM25, FE_DX, 1);
TEST("\x62\xc3\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM16, FE_XMM25, FE_R10, 1);
TEST("\x62\x63\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM25, FE_DX, 1);
TEST("\x62\x43\x35\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM24, FE_XMM25, FE_R10, 1);
// Part 4: register extensions with unusual VEX fallbacks
TEST("\xc5\xfa\x7e\xc1", VMOVQrr, 0, FE_XMM0, FE_XMM1);
TEST("\x62\xb1\xfe\x08\x7e\xc1", VMOVQrr, 0, FE_XMM0, FE_XMM17);
TEST("\xc5\xf9\x7e\xc8", VMOVD_X2Grr, 0, FE_AX, FE_XMM1);
TEST("\x62\xe1\x7d\x08\x7e\xc8", VMOVD_X2Grr, 0, FE_AX, FE_XMM17);
TEST("\xc5\xf9\x7e\x08", VMOVDmr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_XMM1);
TEST("\x62\xe1\x7d\x08\x7e\x08", VMOVDmr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_XMM17);
TEST("\xc5\xf9\x6e\xc8", VMOVD_G2Xrr, 0, FE_XMM1, FE_AX);
TEST("\x62\xe1\x7d\x08\x6e\xc8", VMOVD_G2Xrr, 0, FE_XMM17, FE_AX);
TEST("\xc5\xf9\x6e\x08", VMOVDrm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x62\xe1\x7d\x08\x6e\x08", VMOVDrm, 0, FE_XMM17, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe1\xf9\x7e\xc8", VMOVQ_X2Grr, 0, FE_AX, FE_XMM1);
TEST("\x62\xe1\xfd\x08\x7e\xc8", VMOVQ_X2Grr, 0, FE_AX, FE_XMM17);
TEST("\xc5\xf9\xd6\x08", VMOVQmr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_XMM1);
TEST("\x62\xe1\xfd\x08\xd6\x08", VMOVQmr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_XMM17);
TEST("\xc4\xe1\xf9\x6e\xc8", VMOVQ_G2Xrr, 0, FE_XMM1, FE_AX);
TEST("\x62\xe1\xfd\x08\x6e\xc8", VMOVQ_G2Xrr, 0, FE_XMM17, FE_AX);
TEST("\xc5\xfa\x7e\x08", VMOVQrm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\x62\xe1\xfe\x08\x7e\x08", VMOVQrm, 0, FE_XMM17, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe3\x71\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM1, FE_DX, 1);
TEST("\x62\xf3\x75\x00\x20\xc2\x01", VPINSRBrrri, 0, FE_XMM0, FE_XMM17, FE_DX, 1);
TEST("\xc4\xe3\x71\x20\x42\x20\x01", VPINSRBrrmi, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\x62\xf3\x75\x00\x20\x42\x20\x01", VPINSRBrrmi, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\xc5\xf1\xc4\xc2\x01", VPINSRWrrri, 0, FE_XMM0, FE_XMM1, FE_DX, 1);
TEST("\x62\xf1\x75\x00\xc4\xc2\x01", VPINSRWrrri, 0, FE_XMM0, FE_XMM17, FE_DX, 1);
TEST("\xc5\xf1\xc4\x42\x20\x01", VPINSRWrrmi, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\x62\xf1\x75\x00\xc4\x42\x10\x01", VPINSRWrrmi, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\xc4\xe3\x71\x22\xc2\x01", VPINSRDrrri, 0, FE_XMM0, FE_XMM1, FE_DX, 1);
TEST("\x62\xf3\x75\x00\x22\xc2\x01", VPINSRDrrri, 0, FE_XMM0, FE_XMM17, FE_DX, 1);
TEST("\xc4\xe3\x71\x22\x42\x20\x01", VPINSRDrrmi, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\x62\xf3\x75\x00\x22\x42\x08\x01", VPINSRDrrmi, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\xc4\xe3\xf1\x22\xc2\x01", VPINSRQrrri, 0, FE_XMM0, FE_XMM1, FE_DX, 1);
TEST("\x62\xf3\xf5\x00\x22\xc2\x01", VPINSRQrrri, 0, FE_XMM0, FE_XMM17, FE_DX, 1);
TEST("\xc4\xe3\xf1\x22\x42\x20\x01", VPINSRQrrmi, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\x62\xf3\xf5\x00\x22\x42\x04\x01", VPINSRQrrmi, 0, FE_XMM0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), 1);
TEST("\xc4\xe3\x79\x14\xca\x01", VPEXTRBrri, 0, FE_DX, FE_XMM1, 1);
TEST("\x62\xe3\x7d\x08\x14\xca\x01", VPEXTRBrri, 0, FE_DX, FE_XMM17, 1);
TEST("\xc4\xe3\x79\x14\x4a\x20\x01", VPEXTRBmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM1, 1);
TEST("\x62\xe3\x7d\x08\x14\x4a\x20\x01", VPEXTRBmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM17, 1);
TEST("\xc5\xf9\xc5\xd1\x01", VPEXTRWrri, 0, FE_DX, FE_XMM1, 1);
TEST("\x62\xb1\x7d\x08\xc5\xd1\x01", VPEXTRWrri, 0, FE_DX, FE_XMM17, 1);
TEST("\xc4\xe3\x79\x15\x4a\x20\x01", VPEXTRWmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM1, 1);
TEST("\x62\xe3\x7d\x08\x15\x4a\x10\x01", VPEXTRWmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM17, 1);
TEST("\xc4\xe3\x79\x16\xca\x01", VPEXTRDrri, 0, FE_DX, FE_XMM1, 1);
TEST("\x62\xe3\x7d\x08\x16\xca\x01", VPEXTRDrri, 0, FE_DX, FE_XMM17, 1);
TEST("\xc4\xe3\x79\x16\x4a\x20\x01", VPEXTRDmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM1, 1);
TEST("\x62\xe3\x7d\x08\x16\x4a\x08\x01", VPEXTRDmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM17, 1);
TEST("\xc4\xe3\xf9\x16\xca\x01", VPEXTRQrri, 0, FE_DX, FE_XMM1, 1);
TEST("\x62\xe3\xfd\x08\x16\xca\x01", VPEXTRQrri, 0, FE_DX, FE_XMM17, 1);
TEST("\xc4\xe3\xf9\x16\x4a\x20\x01", VPEXTRQmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM1, 1);
TEST("\x62\xe3\xfd\x08\x16\x4a\x04\x01", VPEXTRQmri, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x20), FE_XMM17, 1);
TEST("\xc4\xe2\x79\x78\xc8", VPBROADCASTB128rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x08\x78\xc8", VPBROADCASTB128rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x7d\x78\xc8", VPBROADCASTB256rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x28\x78\xc8", VPBROADCASTB256rr, 0, FE_XMM17, FE_XMM0);
TEST("\x62\xf2\x7d\x48\x78\xc8", VPBROADCASTB512rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x48\x78\xc8", VPBROADCASTB512rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x79\x78\x4a\x20", VPBROADCASTB128rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x08\x78\x4a\x20", VPBROADCASTB128rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x7d\x78\x4a\x20", VPBROADCASTB256rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x28\x78\x4a\x20", VPBROADCASTB256rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x78\x4a\x20", VPBROADCASTB512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x48\x78\x4a\x20", VPBROADCASTB512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x79\x79\xc8", VPBROADCASTW128rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x08\x79\xc8", VPBROADCASTW128rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x7d\x79\xc8", VPBROADCASTW256rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x28\x79\xc8", VPBROADCASTW256rr, 0, FE_XMM17, FE_XMM0);
TEST("\x62\xf2\x7d\x48\x79\xc8", VPBROADCASTW512rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x48\x79\xc8", VPBROADCASTW512rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x79\x79\x4a\x20", VPBROADCASTW128rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x08\x79\x4a\x10", VPBROADCASTW128rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x7d\x79\x4a\x20", VPBROADCASTW256rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x28\x79\x4a\x10", VPBROADCASTW256rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x79\x4a\x10", VPBROADCASTW512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x48\x79\x4a\x10", VPBROADCASTW512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x79\x58\xc8", VPBROADCASTD128rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x08\x58\xc8", VPBROADCASTD128rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x7d\x58\xc8", VPBROADCASTD256rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x28\x58\xc8", VPBROADCASTD256rr, 0, FE_XMM17, FE_XMM0);
TEST("\x62\xf2\x7d\x48\x58\xc8", VPBROADCASTD512rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\x7d\x48\x58\xc8", VPBROADCASTD512rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x79\x58\x4a\x20", VPBROADCASTD128rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x08\x58\x4a\x08", VPBROADCASTD128rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x7d\x58\x4a\x20", VPBROADCASTD256rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x28\x58\x4a\x08", VPBROADCASTD256rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x58\x4a\x08", VPBROADCASTD512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x48\x58\x4a\x08", VPBROADCASTD512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x79\x59\xc8", VPBROADCASTQ128rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\xfd\x08\x59\xc8", VPBROADCASTQ128rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x7d\x59\xc8", VPBROADCASTQ256rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\xfd\x28\x59\xc8", VPBROADCASTQ256rr, 0, FE_XMM17, FE_XMM0);
TEST("\x62\xf2\xfd\x48\x59\xc8", VPBROADCASTQ512rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xe2\xfd\x48\x59\xc8", VPBROADCASTQ512rr, 0, FE_XMM17, FE_XMM0);
TEST("\xc4\xe2\x79\x59\x4a\x20", VPBROADCASTQ128rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\xfd\x08\x59\x4a\x04", VPBROADCASTQ128rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x7d\x59\x4a\x20", VPBROADCASTQ256rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\xfd\x28\x59\x4a\x04", VPBROADCASTQ256rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x48\x59\x4a\x04", VPBROADCASTQ512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\xfd\x48\x59\x4a\x04", VPBROADCASTQ512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc4\xe2\x7d\x5a\x4a\x20", VBROADCASTI128rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("", VBROADCASTI128rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20)); // no EVEX version exists
TEST("\x62\xf2\x7d\x28\x5a\x4a\x02", VBROADCASTI32X4_256rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x28\x5a\x4a\x02", VBROADCASTI32X4_256rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x5a\x4a\x02", VBROADCASTI32X4_512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x48\x5a\x4a\x02", VBROADCASTI32X4_512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x28\x5a\x4a\x02", VBROADCASTI64X2_256rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\xfd\x28\x5a\x4a\x02", VBROADCASTI64X2_256rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x48\x5a\x4a\x02", VBROADCASTI64X2_512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\xfd\x48\x5a\x4a\x02", VBROADCASTI64X2_512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x5b\x4a\x01", VBROADCASTI32X8_512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\x7d\x48\x5b\x4a\x01", VBROADCASTI32X8_512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x48\x5b\x4a\x01", VBROADCASTI64X4_512rm, 0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xe2\xfd\x48\x5b\x4a\x01", VBROADCASTI64X4_512rm, 0, FE_XMM17, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x08\x7a\xca", VPBROADCASTB_GP128rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x08\x7a\xca", VPBROADCASTB_GP128rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x28\x7a\xca", VPBROADCASTB_GP256rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x28\x7a\xca", VPBROADCASTB_GP256rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x48\x7a\xca", VPBROADCASTB_GP512rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x48\x7a\xca", VPBROADCASTB_GP512rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x08\x7b\xca", VPBROADCASTW_GP128rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x08\x7b\xca", VPBROADCASTW_GP128rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x28\x7b\xca", VPBROADCASTW_GP256rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x28\x7b\xca", VPBROADCASTW_GP256rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x48\x7b\xca", VPBROADCASTW_GP512rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x48\x7b\xca", VPBROADCASTW_GP512rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x08\x7c\xca", VPBROADCASTD_GP128rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x08\x7c\xca", VPBROADCASTD_GP128rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x28\x7c\xca", VPBROADCASTD_GP256rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x28\x7c\xca", VPBROADCASTD_GP256rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\x7d\x48\x7c\xca", VPBROADCASTD_GP512rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\x7d\x48\x7c\xca", VPBROADCASTD_GP512rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\xfd\x08\x7c\xca", VPBROADCASTQ_GP128rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\xfd\x08\x7c\xca", VPBROADCASTQ_GP128rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\xfd\x28\x7c\xca", VPBROADCASTQ_GP256rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\xfd\x28\x7c\xca", VPBROADCASTQ_GP256rr, 0, FE_XMM17, FE_DX);
TEST("\x62\xf2\xfd\x48\x7c\xca", VPBROADCASTQ_GP512rr, 0, FE_XMM1, FE_DX);
TEST("\x62\xe2\xfd\x48\x7c\xca", VPBROADCASTQ_GP512rr, 0, FE_XMM17, FE_DX);
// Part 5: masks
TEST("\x62\xf1\x74\x09\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x89\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x0a\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K2), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x8a\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K2), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x0b\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K3), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x8b\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K3), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x0c\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K4), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x8c\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K4), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x0d\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K5), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x8d\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K5), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x0e\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K6), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x8e\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K6), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x0f\x58\xc2", VADDPS128rrr_mask, FLAGMASK(0, FE_K7), FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x8f\x58\xc2", VADDPS128rrr_maskz, FLAGMASK(0, FE_K7), FE_XMM0, FE_XMM1, FE_XMM2);
// Part 6: memory operands: disp8 compression + broadcast
TEST("\xc5\xf0\x58\x02", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\xc5\xf0\x58\x42\x01", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\xc5\xf0\x58\x42\xff", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\xc5\xf0\x58\x42\x10", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x10));
TEST("\xc5\xf0\x58\x42\xf0", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x10));
TEST("\xc5\xf0\x58\x82\xf0\x07\x00\x00", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x7f0));
TEST("\xc5\xf0\x58\x82\x00\x08\x00\x00", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x800));
TEST("\xc5\xf0\x58\x82\x00\xf8\xff\xff", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x800));
TEST("\xc5\xf0\x58\x82\xf0\xf7\xff\xff", VADDPS128rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x810));
TEST("\x62\xf1\x74\x89\x58\x02", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\x89\x58\x82\x01\x00\x00\x00", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\x89\x58\x82\xff\xff\xff\xff", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\x89\x58\x42\x01", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x10));
TEST("\x62\xf1\x74\x89\x58\x42\xff", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x10));
TEST("\x62\xf1\x74\x89\x58\x42\x7f", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x7f0));
TEST("\x62\xf1\x74\x89\x58\x82\x00\x08\x00\x00", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x800));
TEST("\x62\xf1\x74\x89\x58\x42\x80", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x800));
TEST("\x62\xf1\x74\x89\x58\x82\xf0\xf7\xff\xff", VADDPS128rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x810));
TEST("\x62\xf1\x74\x18\x58\x02", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\x18\x58\x82\x01\x00\x00\x00", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\x18\x58\x82\xff\xff\xff\xff", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\x18\x58\x42\x01", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x4));
TEST("\x62\xf1\x74\x18\x58\x42\xff", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x4));
TEST("\x62\xf1\x74\x18\x58\x42\x7f", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc));
TEST("\x62\xf1\x74\x18\x58\x82\x00\x02\x00\x00", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x200));
TEST("\x62\xf1\x74\x18\x58\x42\x80", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x200));
TEST("\x62\xf1\x74\x18\x58\x82\xfc\xfd\xff\xff", VADDPS128rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x204));
TEST("\x62\xf1\x74\x99\x58\x02", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\x99\x58\x82\x01\x00\x00\x00", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\x99\x58\x82\xff\xff\xff\xff", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\x99\x58\x42\x01", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x4));
TEST("\x62\xf1\x74\x99\x58\x42\xff", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x4));
TEST("\x62\xf1\x74\x99\x58\x42\x7f", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc));
TEST("\x62\xf1\x74\x99\x58\x82\x00\x02\x00\x00", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x200));
TEST("\x62\xf1\x74\x99\x58\x42\x80", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x200));
TEST("\x62\xf1\x74\x99\x58\x82\xfc\xfd\xff\xff", VADDPS128rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x204));
TEST("\xc5\xf4\x58\x02", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\xc5\xf4\x58\x42\x01", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\xc5\xf4\x58\x42\xff", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\xc5\xf4\x58\x42\x20", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\xc5\xf4\x58\x42\xe0", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x20));
TEST("\xc5\xf4\x58\x82\xe0\x0f\x00\x00", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0xfe0));
TEST("\xc5\xf4\x58\x82\x00\x10\x00\x00", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1000));
TEST("\xc5\xf4\x58\x82\x00\xf0\xff\xff", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x1000));
TEST("\xc5\xf4\x58\x82\xe0\xef\xff\xff", VADDPS256rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x1020));
TEST("\x62\xf1\x74\xa9\x58\x02", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\xa9\x58\x82\x01\x00\x00\x00", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\xa9\x58\x82\xff\xff\xff\xff", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\xa9\x58\x42\x01", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x20));
TEST("\x62\xf1\x74\xa9\x58\x42\xff", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x20));
TEST("\x62\xf1\x74\xa9\x58\x42\x7f", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0xfe0));
TEST("\x62\xf1\x74\xa9\x58\x82\x00\x10\x00\x00", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1000));
TEST("\x62\xf1\x74\xa9\x58\x42\x80", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x1000));
TEST("\x62\xf1\x74\xa9\x58\x82\xe0\xef\xff\xff", VADDPS256rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x1020));
TEST("\x62\xf1\x74\x38\x58\x02", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\x38\x58\x82\x01\x00\x00\x00", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\x38\x58\x82\xff\xff\xff\xff", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\x38\x58\x42\x01", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x4));
TEST("\x62\xf1\x74\x38\x58\x42\xff", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x4));
TEST("\x62\xf1\x74\x38\x58\x42\x7f", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc));
TEST("\x62\xf1\x74\x38\x58\x82\x00\x02\x00\x00", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x200));
TEST("\x62\xf1\x74\x38\x58\x42\x80", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x200));
TEST("\x62\xf1\x74\x38\x58\x82\xfc\xfd\xff\xff", VADDPS256rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x204));
TEST("\x62\xf1\x74\xb9\x58\x02", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\xb9\x58\x82\x01\x00\x00\x00", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\xb9\x58\x82\xff\xff\xff\xff", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\xb9\x58\x42\x01", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x4));
TEST("\x62\xf1\x74\xb9\x58\x42\xff", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x4));
TEST("\x62\xf1\x74\xb9\x58\x42\x7f", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc));
TEST("\x62\xf1\x74\xb9\x58\x82\x00\x02\x00\x00", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x200));
TEST("\x62\xf1\x74\xb9\x58\x42\x80", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x200));
TEST("\x62\xf1\x74\xb9\x58\x82\xfc\xfd\xff\xff", VADDPS256rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x204));
TEST("\x62\xf1\x74\x48\x58\x02", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\x48\x58\x82\x01\x00\x00\x00", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\x48\x58\x82\xff\xff\xff\xff", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\x48\x58\x42\x01", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x40));
TEST("\x62\xf1\x74\x48\x58\x42\xff", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x40));
TEST("\x62\xf1\x74\x48\x58\x42\x7f", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc0));
TEST("\x62\xf1\x74\x48\x58\x82\x00\x20\x00\x00", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x2000));
TEST("\x62\xf1\x74\x48\x58\x42\x80", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x2000));
TEST("\x62\xf1\x74\x48\x58\x82\xc0\xdf\xff\xff", VADDPS512rrm, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x2040));
TEST("\x62\xf1\x74\xc9\x58\x02", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\xc9\x58\x82\x01\x00\x00\x00", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\xc9\x58\x82\xff\xff\xff\xff", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\xc9\x58\x42\x01", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x40));
TEST("\x62\xf1\x74\xc9\x58\x42\xff", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x40));
TEST("\x62\xf1\x74\xc9\x58\x42\x7f", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc0));
TEST("\x62\xf1\x74\xc9\x58\x82\x00\x20\x00\x00", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x2000));
TEST("\x62\xf1\x74\xc9\x58\x42\x80", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x2000));
TEST("\x62\xf1\x74\xc9\x58\x82\xc0\xdf\xff\xff", VADDPS512rrm_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x2040));
TEST("\x62\xf1\x74\x58\x58\x02", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\x58\x58\x82\x01\x00\x00\x00", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\x58\x58\x82\xff\xff\xff\xff", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\x58\x58\x42\x01", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x4));
TEST("\x62\xf1\x74\x58\x58\x42\xff", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x4));
TEST("\x62\xf1\x74\x58\x58\x42\x7f", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc));
TEST("\x62\xf1\x74\x58\x58\x82\x00\x02\x00\x00", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x200));
TEST("\x62\xf1\x74\x58\x58\x42\x80", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x200));
TEST("\x62\xf1\x74\x58\x58\x82\xfc\xfd\xff\xff", VADDPS512rrb, 0, FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x204));
TEST("\x62\xf1\x74\xd9\x58\x02", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0));
TEST("\x62\xf1\x74\xd9\x58\x82\x01\x00\x00\x00", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 1));
TEST("\x62\xf1\x74\xd9\x58\x82\xff\xff\xff\xff", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -1));
TEST("\x62\xf1\x74\xd9\x58\x42\x01", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x4));
TEST("\x62\xf1\x74\xd9\x58\x42\xff", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x4));
TEST("\x62\xf1\x74\xd9\x58\x42\x7f", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x1fc));
TEST("\x62\xf1\x74\xd9\x58\x82\x00\x02\x00\x00", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x200));
TEST("\x62\xf1\x74\xd9\x58\x42\x80", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x200));
TEST("\x62\xf1\x74\xd9\x58\x82\xfc\xfd\xff\xff", VADDPS512rrb_maskz, FLAGMASK(0, FE_K1), FE_XMM0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, -0x204));
// Part 7: ER/SAE
TEST("\x62\xf1\x74\x48\x58\xc2", VADDPS512rrr, 0, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x18\x58\xc2", VADDPS512rrr_er, FE_RC_RN, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x38\x58\xc2", VADDPS512rrr_er, FE_RC_RD, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x58\x58\xc2", VADDPS512rrr_er, FE_RC_RU, FE_XMM0, FE_XMM1, FE_XMM2);
TEST("\x62\xf1\x74\x78\x58\xc2", VADDPS512rrr_er, FE_RC_RZ, FE_XMM0, FE_XMM1, FE_XMM2);
// Part 8: VSIB
TEST("", VPGATHERDD128rm, FLAGMASK(0, FE_K0), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM1, 0)); // k0 not allowed
TEST("\x62\xf2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM1, 0));
TEST("\x62\xf2\x7d\x09\x90\x44\x08\x04", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM1, 0x10));
TEST("\x62\xf2\x7d\x09\x90\x84\x08\x11\x00\x00\x00", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM1, 0x11));
TEST("\x62\xf2\x7d\x09\x90\x04\x0d\x00\x00\x00\x00", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_NOREG, 1, FE_XMM1, 0));
TEST("\x62\xf2\x7d\x09\x90\x84\xc8\x11\x00\x00\x00", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 8, FE_XMM1, 0x11));
TEST("\x62\xf2\x7d\x09\x90\x04\xcd\x00\x00\x00\x00", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_NOREG, 8, FE_XMM1, 0));
TEST("\x62\xf2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM1, 0));
TEST("\x62\xd2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_R8, 1, FE_XMM1, 0));
TEST("\x62\xb2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM9, 0));
TEST("\x62\x92\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_R8, 1, FE_XMM9, 0));
TEST("\x62\xf2\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM17, 0));
TEST("\x62\xd2\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_R8, 1, FE_XMM17, 0));
TEST("\x62\xb2\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_AX, 1, FE_XMM25, 0));
TEST("\x62\x92\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM0, FE_MEMV(FE_R8, 1, FE_XMM25, 0));
TEST("\x62\x72\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_AX, 1, FE_XMM1, 0));
TEST("\x62\x52\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_R8, 1, FE_XMM1, 0));
TEST("\x62\x32\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_AX, 1, FE_XMM9, 0));
TEST("\x62\x12\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_R8, 1, FE_XMM9, 0));
TEST("\x62\x72\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_AX, 1, FE_XMM17, 0));
TEST("\x62\x52\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_R8, 1, FE_XMM17, 0));
TEST("\x62\x32\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_AX, 1, FE_XMM25, 0));
TEST("\x62\x12\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM8, FE_MEMV(FE_R8, 1, FE_XMM25, 0));
TEST("\x62\xe2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_AX, 1, FE_XMM1, 0));
TEST("\x62\xc2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_R8, 1, FE_XMM1, 0));
TEST("\x62\xa2\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_AX, 1, FE_XMM9, 0));
TEST("\x62\x82\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_R8, 1, FE_XMM9, 0));
TEST("\x62\xe2\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_AX, 1, FE_XMM17, 0));
TEST("\x62\xc2\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_R8, 1, FE_XMM17, 0));
TEST("\x62\xa2\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_AX, 1, FE_XMM25, 0));
TEST("\x62\x82\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM16, FE_MEMV(FE_R8, 1, FE_XMM25, 0));
TEST("\x62\x62\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_AX, 1, FE_XMM1, 0));
TEST("\x62\x42\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_R8, 1, FE_XMM1, 0));
TEST("\x62\x22\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_AX, 1, FE_XMM9, 0));
TEST("\x62\x02\x7d\x09\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_R8, 1, FE_XMM9, 0));
TEST("\x62\x62\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_AX, 1, FE_XMM17, 0));
TEST("\x62\x42\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_R8, 1, FE_XMM17, 0));
TEST("\x62\x22\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_AX, 1, FE_XMM25, 0));
TEST("\x62\x02\x7d\x01\x90\x04\x08", VPGATHERDD128rm, FLAGMASK(0, FE_K1), FE_XMM24, FE_MEMV(FE_R8, 1, FE_XMM25, 0));

// VCVTTPD2DQ has different W bit for VEX/EVEX, so fallback is implemented using
// REXW flip. Test that this works.
TEST("\xc4\x41\x79\xe6\xf7", VCVTTPD2DQ128rr, 0, FE_XMM14, FE_XMM15);
TEST("\xc4\x41\x7d\xe6\xf7", VCVTTPD2DQ256rr, 0, FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\x48\xe6\xf7", VCVTTPD2DQ512rr, 0, FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\x18\xe6\xf7", VCVTTPD2DQ512rr_sae, 0, FE_XMM14, FE_XMM15);
TEST("\xc4\x01\x79\xe6\x74\x37\x40", VCVTTPD2DQ128rm, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\xc4\x01\x7d\xe6\x74\x37\x40", VCVTTPD2DQ256rm, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x48\xe6\x74\x37\x01", VCVTTPD2DQ512rm, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x18\xe6\x74\x37\x08", VCVTTPD2DQ128rb, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x38\xe6\x74\x37\x08", VCVTTPD2DQ256rb, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x58\xe6\x74\x37\x08", VCVTTPD2DQ512rb, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x51\xfd\x09\xe6\xf7", VCVTTPD2DQ128rr_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\x29\xe6\xf7", VCVTTPD2DQ256rr_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\x49\xe6\xf7", VCVTTPD2DQ512rr_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\x19\xe6\xf7", VCVTTPD2DQ512rr_mask_sae, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x11\xfd\x09\xe6\x74\x37\x04", VCVTTPD2DQ128rm_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x29\xe6\x74\x37\x02", VCVTTPD2DQ256rm_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x49\xe6\x74\x37\x01", VCVTTPD2DQ512rm_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x19\xe6\x74\x37\x08", VCVTTPD2DQ128rb_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x39\xe6\x74\x37\x08", VCVTTPD2DQ256rb_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x59\xe6\x74\x37\x08", VCVTTPD2DQ512rb_mask, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x51\xfd\x89\xe6\xf7", VCVTTPD2DQ128rr_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\xa9\xe6\xf7", VCVTTPD2DQ256rr_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\xc9\xe6\xf7", VCVTTPD2DQ512rr_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x51\xfd\x99\xe6\xf7", VCVTTPD2DQ512rr_maskz_sae, FLAGMASK(0, FE_K1), FE_XMM14, FE_XMM15);
TEST("\x62\x11\xfd\x89\xe6\x74\x37\x04", VCVTTPD2DQ128rm_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\xa9\xe6\x74\x37\x02", VCVTTPD2DQ256rm_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\xc9\xe6\x74\x37\x01", VCVTTPD2DQ512rm_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\x99\xe6\x74\x37\x08", VCVTTPD2DQ128rb_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\xb9\xe6\x74\x37\x08", VCVTTPD2DQ256rb_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x11\xfd\xd9\xe6\x74\x37\x08", VCVTTPD2DQ512rb_maskz, FLAGMASK(0, FE_K1), FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));

TEST("\xc4\x42\x7d\x19\xf7", VBROADCASTSD256rr, 0, FE_XMM14, FE_XMM15);
TEST("\xc4\x02\x7d\x19\x74\x37\x40", VBROADCASTSD256rm, 0, FE_XMM14, FE_MEM(FE_R15, 1, FE_R14, 0x40));
TEST("\x62\x82\xfd\x28\x19\x44\x37\x08", VBROADCASTSD256rm, 0, FE_XMM16, FE_MEM(FE_R15, 1, FE_R14, 0x40));

// VMOVDDUP has special tuple size for L0.
TEST("\xc5\xfb\x12\x48\x08", VMOVDDUP128rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0x8));
TEST("\x62\xf1\xff\x09\x12\x48\x01", VMOVDDUP128rm_mask, FLAGMASK(0, FE_K1), FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0x8));
TEST("\xc5\xfb\x12\xc8", VMOVDDUP128rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xf1\xff\x09\x12\xc8", VMOVDDUP128rr_mask, FLAGMASK(0, FE_K1), FE_XMM1, FE_XMM0);
TEST("\xc5\xff\x12\x48\x20", VMOVDDUP256rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf1\xff\x29\x12\x48\x01", VMOVDDUP256rm_mask, FLAGMASK(0, FE_K1), FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\xc5\xff\x12\xc8", VMOVDDUP256rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xf1\xff\x29\x12\xc8", VMOVDDUP256rr_mask, FLAGMASK(0, FE_K1), FE_XMM1, FE_XMM0);
TEST("\x62\xf1\xff\x48\x12\x48\x01", VMOVDDUP512rm, 0, FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0x40));
TEST("\x62\xf1\xff\x49\x12\x48\x01", VMOVDDUP512rm_mask, FLAGMASK(0, FE_K1), FE_XMM1, FE_MEM(FE_AX, 0, FE_NOREG, 0x40));
TEST("\x62\xf1\xff\x48\x12\xc8", VMOVDDUP512rr, 0, FE_XMM1, FE_XMM0);
TEST("\x62\xf1\xff\x49\x12\xc8", VMOVDDUP512rr_mask, FLAGMASK(0, FE_K1), FE_XMM1, FE_XMM0);

// VPCOMPRESS and VPEXPAND have different scale size
TEST("\x62\xf2\x7d\x08\x63\x40\x20", VPCOMPRESSB128mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\x7d\x28\x63\x40\x20", VPCOMPRESSB256mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\x7d\x48\x63\x40\x20", VPCOMPRESSB512mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\xfd\x08\x63\x40\x10", VPCOMPRESSW128mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\xfd\x28\x63\x40\x10", VPCOMPRESSW256mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\xfd\x48\x63\x40\x10", VPCOMPRESSW512mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\x7d\x08\x8b\x40\x08", VPCOMPRESSD128mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\x7d\x28\x8b\x40\x08", VPCOMPRESSD256mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\x7d\x48\x8b\x40\x08", VPCOMPRESSD512mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\xfd\x08\x8b\x40\x04", VPCOMPRESSQ128mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\xfd\x28\x8b\x40\x04", VPCOMPRESSQ256mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\xfd\x48\x8b\x40\x04", VPCOMPRESSQ512mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20), FE_XMM0);
TEST("\x62\xf2\x7d\x08\x62\x40\x20", VPEXPANDB128rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x28\x62\x40\x20", VPEXPANDB256rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x62\x40\x20", VPEXPANDB512rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x08\x62\x40\x10", VPEXPANDW128rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x28\x62\x40\x10", VPEXPANDW256rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x48\x62\x40\x10", VPEXPANDW512rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x08\x89\x40\x08", VPEXPANDD128rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x28\x89\x40\x08", VPEXPANDD256rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\x7d\x48\x89\x40\x08", VPEXPANDD512rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x08\x89\x40\x04", VPEXPANDQ128rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x28\x89\x40\x04", VPEXPANDQ256rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));
TEST("\x62\xf2\xfd\x48\x89\x40\x04", VPEXPANDQ512rm, 0, FE_XMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0x20));

// Mask can also be destination
TEST("\x62\xf1\x74\x08\xc2\xc2\x01", VCMPPS128krri, 0, FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x09\xc2\xc2\x01", VCMPPS128krri_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x08\xc2\x02\x01", VCMPPS128krmi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0), 1);
TEST("\x62\xf1\x74\x09\xc2\x02\x01", VCMPPS128krmi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0), 1);
TEST("\x62\xf1\x74\x08\xc2\x42\x08\x01", VCMPPS128krmi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x09\xc2\x42\x08\x01", VCMPPS128krmi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x18\xc2\x42\x20\x01", VCMPPS128krbi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x19\xc2\x42\x20\x01", VCMPPS128krbi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x28\xc2\xc2\x01", VCMPPS256krri, 0, FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x29\xc2\xc2\x01", VCMPPS256krri_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x28\xc2\x02\x01", VCMPPS256krmi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0), 1);
TEST("\x62\xf1\x74\x29\xc2\x02\x01", VCMPPS256krmi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0), 1);
TEST("\x62\xf1\x74\x28\xc2\x42\x04\x01", VCMPPS256krmi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x29\xc2\x42\x04\x01", VCMPPS256krmi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x38\xc2\x42\x20\x01", VCMPPS256krbi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x39\xc2\x42\x20\x01", VCMPPS256krbi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x48\xc2\xc2\x01", VCMPPS512krri, 0, FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x49\xc2\xc2\x01", VCMPPS512krri_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x48\xc2\x02\x01", VCMPPS512krmi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0), 1);
TEST("\x62\xf1\x74\x49\xc2\x02\x01", VCMPPS512krmi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0), 1);
TEST("\x62\xf1\x74\x48\xc2\x42\x02\x01", VCMPPS512krmi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x49\xc2\x42\x02\x01", VCMPPS512krmi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x58\xc2\x42\x20\x01", VCMPPS512krbi, 0, FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x59\xc2\x42\x20\x01", VCMPPS512krbi_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_MEM(FE_DX, 0, FE_NOREG, 0x80), 1);
TEST("\x62\xf1\x74\x18\xc2\xc2\x01", VCMPPS512krri_sae, 0, FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x74\x19\xc2\xc2\x01", VCMPPS512krri_mask_sae, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x76\x08\xc2\xc2\x01", VCMPSSkrri, 0, FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x76\x09\xc2\xc2\x01", VCMPSSkrri_mask, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x76\x18\xc2\xc2\x01", VCMPSSkrri_sae, 0, FE_K0, FE_XMM1, FE_XMM2, 1);
TEST("\x62\xf1\x76\x19\xc2\xc2\x01", VCMPSSkrri_mask_sae, FLAGMASK(0, FE_K1), FE_K0, FE_XMM1, FE_XMM2, 1);

// Mask instructions
TEST("\xc5\xcd\x41\xef", KANDBkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x41\xef", KANDWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcd\x41\xef", KANDDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x41\xef", KANDQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcd\x42\xef", KANDNBkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x42\xef", KANDNWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcd\x42\xef", KANDNDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x42\xef", KANDNQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xf9\x44\xee", KNOTBkk, 0, FE_K5, FE_K6);
TEST("\xc5\xf8\x44\xee", KNOTWkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf9\x44\xee", KNOTDkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf8\x44\xee", KNOTQkk, 0, FE_K5, FE_K6);
TEST("\xc5\xcd\x45\xef", KORBkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x45\xef", KORWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcd\x45\xef", KORDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x45\xef", KORQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcd\x46\xef", KXNORBkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x46\xef", KXNORWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcd\x46\xef", KXNORDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x46\xef", KXNORQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcd\x47\xef", KXORBkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x47\xef", KXORWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcd\x47\xef", KXORDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x47\xef", KXORQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcd\x4a\xef", KADDBkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x4a\xef", KADDWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcd\x4a\xef", KADDDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x4a\xef", KADDQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcd\x4b\xef", KUNPCKBWkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xcc\x4b\xef", KUNPCKWDkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc4\xe1\xcc\x4b\xef", KUNPCKDQkkk, 0, FE_K5, FE_K6, FE_K7);
TEST("\xc5\xf9\x98\xee", KORTESTBkk, 0, FE_K5, FE_K6);
TEST("\xc5\xf8\x98\xee", KORTESTWkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf9\x98\xee", KORTESTDkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf8\x98\xee", KORTESTQkk, 0, FE_K5, FE_K6);
TEST("\xc5\xf9\x90\xee", KMOVBkk, 0, FE_K5, FE_K6);
TEST("\xc5\xf8\x90\xee", KMOVWkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf9\x90\xee", KMOVDkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf8\x90\xee", KMOVQkk, 0, FE_K5, FE_K6);
TEST("\xc5\xf9\x90\x7a\x10", KMOVBkm, 0, FE_K7, FE_MEM(FE_DX, 0, FE_NOREG, 0x10));
TEST("\xc5\xf8\x90\x7a\x10", KMOVWkm, 0, FE_K7, FE_MEM(FE_DX, 0, FE_NOREG, 0x10));
TEST("\xc4\xe1\xf9\x90\x7a\x10", KMOVDkm, 0, FE_K7, FE_MEM(FE_DX, 0, FE_NOREG, 0x10));
TEST("\xc4\xe1\xf8\x90\x7a\x10", KMOVQkm, 0, FE_K7, FE_MEM(FE_DX, 0, FE_NOREG, 0x10));
TEST("\xc5\xf9\x91\x7a\x10", KMOVBmk, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x10), FE_K7);
TEST("\xc5\xf8\x91\x7a\x10", KMOVWmk, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x10), FE_K7);
TEST("\xc4\xe1\xf9\x91\x7a\x10", KMOVDmk, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x10), FE_K7);
TEST("\xc4\xe1\xf8\x91\x7a\x10", KMOVQmk, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x10), FE_K7);
TEST("\xc5\xf9\x92\xe8", KMOVBkr, 0, FE_K5, FE_AX);
TEST("\xc5\xf8\x92\xe8", KMOVWkr, 0, FE_K5, FE_AX);
TEST("\xc5\xfb\x92\xe8", KMOVDkr, 0, FE_K5, FE_AX);
TEST("\xc4\xe1\xfb\x92\xe8", KMOVQkr, 0, FE_K5, FE_AX);
TEST("\xc5\xf9\x93\xc7", KMOVBrk, 0, FE_AX, FE_K7);
TEST("\xc5\xf8\x93\xc7", KMOVWrk, 0, FE_AX, FE_K7);
TEST("\xc5\xfb\x93\xc7", KMOVDrk, 0, FE_AX, FE_K7);
TEST("\xc4\xe1\xfb\x93\xc7", KMOVQrk, 0, FE_AX, FE_K7);
TEST("\xc5\xf9\x99\xee", KTESTBkk, 0, FE_K5, FE_K6);
TEST("\xc5\xf8\x99\xee", KTESTWkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf9\x99\xee", KTESTDkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe1\xf8\x99\xee", KTESTQkk, 0, FE_K5, FE_K6);
TEST("\xc4\xe3\x79\x30\xee\x0b", KSHIFTRBkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\xf9\x30\xee\x0b", KSHIFTRWkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\x79\x31\xee\x0b", KSHIFTRDkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\xf9\x31\xee\x0b", KSHIFTRQkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\x79\x32\xee\x0b", KSHIFTLBkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\xf9\x32\xee\x0b", KSHIFTLWkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\x79\x33\xee\x0b", KSHIFTLDkki, 0, FE_K5, FE_K6, 11);
TEST("\xc4\xe3\xf9\x33\xee\x0b", KSHIFTLQkki, 0, FE_K5, FE_K6, 11);

// Test REX prefix
TEST("\x00\x01", ADD8mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x00\x21", ADD8mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AH);
TEST("\x40\x00\x21", ADD8mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_SP);
TEST("\x41\x00\x01", ADD8mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_AX);
TEST("", ADD8mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_AH);
TEST("\x41\x00\x21", ADD8mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_SP);
TEST("\x44\x00\x01", ADD8mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_R8);
TEST("\x45\x00\x01", ADD8mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_R8);
TEST("", ADD8mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_AH);
TEST("\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_AX);
TEST("\x00\x24\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_AH);
TEST("\x40\x00\x24\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_SP);
TEST("\x41\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_AX);
TEST("\x41\x00\x24\x11", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_SP);
TEST("", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_AH);
TEST("\x42\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_AX);
TEST("\x42\x00\x24\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_SP);
TEST("", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_AH);
TEST("\x43\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_AX);
TEST("\x43\x00\x24\x11", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_SP);
TEST("", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_AH);
TEST("\x44\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_R8);
TEST("\x45\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_R8);
TEST("\x46\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_R8);
TEST("\x47\x00\x04\x11", ADD8mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_R8);
TEST("\x00\xc1", ADD8rr, 0, FE_CX, FE_AX);
TEST("\x00\xc5", ADD8rr, 0, FE_CH, FE_AX);
TEST("\x40\x00\xc5", ADD8rr, 0, FE_BP, FE_AX);
TEST("\x41\x00\xc1", ADD8rr, 0, FE_R9, FE_AX);
TEST("\x00\xe1", ADD8rr, 0, FE_CX, FE_AH);
TEST("\x00\xe5", ADD8rr, 0, FE_CH, FE_AH);
TEST("", ADD8rr, 0, FE_BP, FE_AH);
TEST("", ADD8rr, 0, FE_R9, FE_AH);
TEST("\x40\x00\xe1", ADD8rr, 0, FE_CX, FE_SP);
TEST("", ADD8rr, 0, FE_CH, FE_SP);
TEST("\x40\x00\xe5", ADD8rr, 0, FE_BP, FE_SP);
TEST("\x41\x00\xe1", ADD8rr, 0, FE_R9, FE_SP);
TEST("\x44\x00\xc1", ADD8rr, 0, FE_CX, FE_R8);
TEST("", ADD8rr, 0, FE_CH, FE_R8);
TEST("\x44\x00\xc5", ADD8rr, 0, FE_BP, FE_R8);
TEST("\x45\x00\xc1", ADD8rr, 0, FE_R9, FE_R8);
TEST("\x01\x01", ADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x41\x01\x01", ADD32mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_AX);
TEST("\x44\x01\x01", ADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_R8);
TEST("\x45\x01\x01", ADD32mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_R8);
TEST("\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_AX);
TEST("\x41\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_AX);
TEST("\x42\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_AX);
TEST("\x43\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_AX);
TEST("\x44\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_R8);
TEST("\x45\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_R8);
TEST("\x46\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_R8);
TEST("\x47\x01\x04\x11", ADD32mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_R8);
TEST("\x48\x01\x01", ADD64mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x49\x01\x01", ADD64mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_AX);
TEST("\x4c\x01\x01", ADD64mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_R8);
TEST("\x4d\x01\x01", ADD64mr, 0, FE_MEM(FE_R9, 0, FE_NOREG, 0), FE_R8);
TEST("\x48\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_AX);
TEST("\x49\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_AX);
TEST("\x4a\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_AX);
TEST("\x4b\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_AX);
TEST("\x4c\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_CX, 1, FE_DX, 0), FE_R8);
TEST("\x4d\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_R9, 1, FE_DX, 0), FE_R8);
TEST("\x4e\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_CX, 1, FE_R10, 0), FE_R8);
TEST("\x4f\x01\x04\x11", ADD64mr, 0, FE_MEM(FE_R9, 1, FE_R10, 0), FE_R8);
TEST("\x01\xc1", ADD32rr, 0, FE_CX, FE_AX);
TEST("\x41\x01\xc1", ADD32rr, 0, FE_R9, FE_AX);
TEST("\x44\x01\xc1", ADD32rr, 0, FE_CX, FE_R8);
TEST("\x45\x01\xc1", ADD32rr, 0, FE_R9, FE_R8);
TEST("\x48\x01\xc1", ADD64rr, 0, FE_CX, FE_AX);
TEST("\x49\x01\xc1", ADD64rr, 0, FE_R9, FE_AX);
TEST("\x4c\x01\xc1", ADD64rr, 0, FE_CX, FE_R8);
TEST("\x4d\x01\xc1", ADD64rr, 0, FE_R9, FE_R8);

// Test ModRM encoding
TEST("\x01\x00", ADD32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x04\x24", ADD32mr, 0, FE_MEM(FE_SP, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x45\x00", ADD32mr, 0, FE_MEM(FE_BP, 0, FE_NOREG, 0), FE_AX);
TEST("\x41\x01\x45\x00", ADD32mr, 0, FE_MEM(FE_R13, 0, FE_NOREG, 0), FE_AX);
TEST("\x41\x01\x45\x80", ADD32mr, 0, FE_MEM(FE_R13, 0, FE_NOREG, -0x80), FE_AX);
TEST("\x41\x01\x85\x80\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_R13, 0, FE_NOREG, 0x80), FE_AX);
TEST("\x01\x04\x25\x01\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_NOREG, 0, FE_NOREG, 0x1), FE_AX);
TEST("\x01\x04\x25\x00\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_NOREG, 0, FE_NOREG, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 0, FE_AX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 3, FE_AX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 5, FE_AX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 9, FE_AX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 15, FE_AX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 1, FE_NOREG, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 2, FE_NOREG, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 3, FE_NOREG, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_NOREG, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 8, FE_NOREG, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 15, FE_NOREG, 0), FE_AX);
TEST("\x01\x04\x05\x00\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_NOREG, 1, FE_AX, 0), FE_AX);
TEST("\x01\x04\xc5\x00\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_NOREG, 8, FE_AX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 8, FE_SP, 0), FE_AX);
TEST("\x42\x01\x04\x05\x00\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_NOREG, 1, FE_R8, 0), FE_AX);
// RIP-relative addressing, adds instruction size to offset.
TEST("\x01\x05\x01\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x7), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_IP, 1, FE_AX, 0x7), FE_AX);
TEST("\x0f\xaf\x05\xf9\xff\xff\xff", IMUL32rm, 0, FE_AX, FE_MEM(FE_IP, 0, FE_NOREG, 0));
TEST("\x6b\x05\xf9\xff\xff\xff\x02", IMUL32rmi, 0, FE_AX, FE_MEM(FE_IP, 0, FE_NOREG, 0), 2);
TEST("\x66\x6b\x05\xf8\xff\xff\xff\x02", IMUL16rmi, 0, FE_AX, FE_MEM(FE_IP, 0, FE_NOREG, 0), 2);
TEST("\x69\x05\xf6\xff\xff\xff\x80\x00\x00\x00", IMUL32rmi, 0, FE_AX, FE_MEM(FE_IP, 0, FE_NOREG, 0), 0x80);
TEST("\x66\x69\x05\xf7\xff\xff\xff\x80\x00", IMUL16rmi, 0, FE_AX, FE_MEM(FE_IP, 0, FE_NOREG, 0), 0x80);
// Test RIP-relative addressing with various prefixes
TEST("\x01\x05\x0a\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x44\x01\x05\x09\x00\x00\x00", ADD32mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x67\x01\x05\x09\x00\x00\x00", ADD32mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x67\x44\x01\x05\x08\x00\x00\x00", ADD32mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\x01\x05\x09\x00\x00\x00", ADD32mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\x44\x01\x05\x08\x00\x00\x00", ADD32mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\x67\x01\x05\x08\x00\x00\x00", ADD32mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\x67\x44\x01\x05\x07\x00\x00\x00", ADD32mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x66\x01\x05\x09\x00\x00\x00", ADD16mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x66\x44\x01\x05\x08\x00\x00\x00", ADD16mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x67\x66\x01\x05\x08\x00\x00\x00", ADD16mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x67\x66\x44\x01\x05\x07\x00\x00\x00", ADD16mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\x66\x01\x05\x08\x00\x00\x00", ADD16mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\x66\x44\x01\x05\x07\x00\x00\x00", ADD16mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\x67\x66\x01\x05\x07\x00\x00\x00", ADD16mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\x67\x66\x44\x01\x05\x06\x00\x00\x00", ADD16mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\xf0\x01\x05\x09\x00\x00\x00", LOCK_ADD32mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\xf0\x44\x01\x05\x08\x00\x00\x00", LOCK_ADD32mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x67\xf0\x01\x05\x08\x00\x00\x00", LOCK_ADD32mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x67\xf0\x44\x01\x05\x07\x00\x00\x00", LOCK_ADD32mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\xf0\x01\x05\x08\x00\x00\x00", LOCK_ADD32mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\xf0\x44\x01\x05\x07\x00\x00\x00", LOCK_ADD32mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\x67\xf0\x01\x05\x07\x00\x00\x00", LOCK_ADD32mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\x67\xf0\x44\x01\x05\x06\x00\x00\x00", LOCK_ADD32mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\xf0\x66\x01\x05\x08\x00\x00\x00", LOCK_ADD16mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\xf0\x66\x44\x01\x05\x07\x00\x00\x00", LOCK_ADD16mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x67\xf0\x66\x01\x05\x07\x00\x00\x00", LOCK_ADD16mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x67\xf0\x66\x44\x01\x05\x06\x00\x00\x00", LOCK_ADD16mr, FE_ADDR32, FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\xf0\x66\x01\x05\x07\x00\x00\x00", LOCK_ADD16mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\xf0\x66\x44\x01\x05\x06\x00\x00\x00", LOCK_ADD16mr, FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\x64\x67\xf0\x66\x01\x05\x06\x00\x00\x00", LOCK_ADD16mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_AX);
TEST("\x64\x67\xf0\x66\x44\x01\x05\x05\x00\x00\x00", LOCK_ADD16mr, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_IP, 0, FE_NOREG, 0x10), FE_R8);
TEST("\xc5\xf9\x6e\x05\x08\x00\x00\x00", VMOVDrm, 0, FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\xc4\xe1\xf9\x6e\x05\x07\x00\x00\x00", VMOVQ_G2Xrm, 0, FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x67\xc5\xf9\x6e\x05\x07\x00\x00\x00", VMOVDrm, FE_ADDR32, FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x67\xc4\xe1\xf9\x6e\x05\x06\x00\x00\x00", VMOVQ_G2Xrm, FE_ADDR32, FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x64\xc5\xf9\x6e\x05\x07\x00\x00\x00", VMOVDrm, FE_SEG(FE_FS), FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x64\xc4\xe1\xf9\x6e\x05\x06\x00\x00\x00", VMOVQ_G2Xrm, FE_SEG(FE_FS), FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x64\x67\xc5\xf9\x6e\x05\x06\x00\x00\x00", VMOVDrm, FE_ADDR32|FE_SEG(FE_FS), FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x64\x67\xc4\xe1\xf9\x6e\x05\x05\x00\x00\x00", VMOVQ_G2Xrm, FE_ADDR32|FE_SEG(FE_FS), FE_XMM0, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x62\xe1\x7d\x08\x6e\x05\x06\x00\x00\x00", VMOVDrm, 0, FE_XMM16, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x67\x62\xe1\x7d\x08\x6e\x05\x05\x00\x00\x00", VMOVDrm, FE_ADDR32, FE_XMM16, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x64\x62\xe1\x7d\x08\x6e\x05\x05\x00\x00\x00", VMOVDrm, FE_SEG(FE_FS), FE_XMM16, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));
TEST("\x64\x67\x62\xe1\x7d\x08\x6e\x05\x04\x00\x00\x00", VMOVDrm, FE_ADDR32|FE_SEG(FE_FS), FE_XMM16, FE_MEM(FE_IP, 0, FE_NOREG, 0x10));

TEST("\x01\x00", ADD32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x01", ADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x02", ADD32mr, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x03", ADD32mr, 0, FE_MEM(FE_BX, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x04\x80", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x81", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x82", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x83", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x84", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x85\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x04\x86", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x87", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_AX, 0), FE_AX);
TEST("\x01\x04\x88", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x89", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x8a", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x8b", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x8c", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x8d\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x04\x8e", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x8f", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_CX, 0), FE_AX);
TEST("\x01\x04\x90", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x91", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x92", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x93", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x94", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x95\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x04\x96", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x97", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_DX, 0), FE_AX);
TEST("\x01\x04\x98", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_BX, 0), FE_AX);
TEST("\x01\x04\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_BX, 0), FE_AX);
TEST("\x01\x04\x9a", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_BX, 0), FE_AX);
TEST("\x01\x04\x9b", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_BX, 0), FE_AX);
TEST("\x01\x04\x9c", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_BX, 0), FE_AX);
TEST("\x01\x04\x9d\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x04\x9e", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_BX, 0), FE_AX);
TEST("\x01\x04\x9f", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_BX, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_SP, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_SP, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_SP, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_SP, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_SP, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_SP, 0), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_SP, 0), FE_AX);
TEST("\x01\x04\xa8", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xa9", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xaa", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xab", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xac", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xad\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x04\xae", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xaf", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_BP, 0), FE_AX);
TEST("\x01\x04\xb0", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb1", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb2", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb3", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb4", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb5\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x04\xb6", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb7", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_SI, 0), FE_AX);
TEST("\x01\x04\xb8", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_DI, 0), FE_AX);
TEST("\x01\x04\xb9", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_DI, 0), FE_AX);
TEST("\x01\x04\xba", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_DI, 0), FE_AX);
TEST("\x01\x04\xbb", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_DI, 0), FE_AX);
TEST("\x01\x04\xbc", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_DI, 0), FE_AX);
TEST("\x01\x04\xbd\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_NOREG, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x04\xbe", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_DI, 0), FE_AX);
TEST("\x01\x04\xbf", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_DI, 0), FE_AX);
TEST("\x01\x05\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_IP, 0, FE_NOREG, 0x44332217), FE_AX);
TEST("\x01\x06", ADD32mr, 0, FE_MEM(FE_SI, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x07", ADD32mr, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0), FE_AX);
TEST("\x01\x40\x99", ADD32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x41\x99", ADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x42\x99", ADD32mr, 0, FE_MEM(FE_DX, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x43\x99", ADD32mr, 0, FE_MEM(FE_BX, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x44\x80\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x81\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x82\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x83\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x84\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x85\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x86\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x87\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_AX, -0x67), FE_AX);
TEST("\x01\x44\x88\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x89\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x8a\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x8b\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x8c\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x8d\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x8e\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x8f\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_CX, -0x67), FE_AX);
TEST("\x01\x44\x90\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x91\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x92\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x93\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x94\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x95\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x96\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x97\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_DX, -0x67), FE_AX);
TEST("\x01\x44\x98\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x99\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x9a\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x9b\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x9c\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x9d\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x9e\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_BX, -0x67), FE_AX);
TEST("\x01\x44\x9f\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_BX, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_SP, -0x67), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_SP, -0x67), FE_AX);
TEST("\x01\x44\xa8\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xa9\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xaa\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xab\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xac\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xad\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xae\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xaf\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_BP, -0x67), FE_AX);
TEST("\x01\x44\xb0\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb1\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb2\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb3\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb4\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb5\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb6\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb7\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_SI, -0x67), FE_AX);
TEST("\x01\x44\xb8\x99", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xb9\x99", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xba\x99", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xbb\x99", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xbc\x99", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xbd\x99", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xbe\x99", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x44\xbf\x99", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_DI, -0x67), FE_AX);
TEST("\x01\x45\x99", ADD32mr, 0, FE_MEM(FE_BP, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x46\x99", ADD32mr, 0, FE_MEM(FE_SI, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x47\x99", ADD32mr, 0, FE_MEM(FE_DI, 0, FE_NOREG, -0x67), FE_AX);
TEST("\x01\x80\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\x81\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\x82\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\x83\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\x84\x80\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x81\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x82\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x83\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x84\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x85\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x86\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x87\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_AX, 0x44332211), FE_AX);
TEST("\x01\x84\x88\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x89\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x8a\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x8b\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x8c\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x8d\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x8e\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x8f\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_CX, 0x44332211), FE_AX);
TEST("\x01\x84\x90\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x91\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x92\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x93\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x94\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x95\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x96\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x97\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_DX, 0x44332211), FE_AX);
TEST("\x01\x84\x98\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x99\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x9a\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x9b\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x9c\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x9d\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x9e\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_BX, 0x44332211), FE_AX);
TEST("\x01\x84\x9f\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_BX, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_SP, 0x44332211), FE_AX);
TEST("", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_SP, 0x44332211), FE_AX);
TEST("\x01\x84\xa8\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xa9\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xaa\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xab\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xac\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xad\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xae\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xaf\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_BP, 0x44332211), FE_AX);
TEST("\x01\x84\xb0\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb1\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb2\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb3\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb4\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb5\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb6\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb7\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_SI, 0x44332211), FE_AX);
TEST("\x01\x84\xb8\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_AX, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xb9\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_CX, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xba\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DX, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xbb\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BX, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xbc\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SP, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xbd\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xbe\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x84\xbf\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 4, FE_DI, 0x44332211), FE_AX);
TEST("\x01\x85\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_BP, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\x86\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_SI, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\x87\x11\x22\x33\x44", ADD32mr, 0, FE_MEM(FE_DI, 0, FE_NOREG, 0x44332211), FE_AX);
TEST("\x01\xc0", ADD32rr, 0, FE_AX, FE_AX);
TEST("\x01\xc1", ADD32rr, 0, FE_CX, FE_AX);
TEST("\x01\xc2", ADD32rr, 0, FE_DX, FE_AX);
TEST("\x01\xc3", ADD32rr, 0, FE_BX, FE_AX);
TEST("\x01\xc4", ADD32rr, 0, FE_SP, FE_AX);
TEST("\x01\xc5", ADD32rr, 0, FE_BP, FE_AX);
TEST("\x01\xc6", ADD32rr, 0, FE_SI, FE_AX);
TEST("\x01\xc7", ADD32rr, 0, FE_DI, FE_AX);

// AMX
TEST("\xc4\xe2\x78\x49\x00", LDTILECFGm, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x79\x49\x00", STTILECFGm, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0));
TEST("\xc4\xe2\x78\x49\xc0", TILERELEASE, 0);
TEST("\xc4\xe2\x7b\x49\xc0", TILEZEROr, 0, FE_TMM0);
TEST("\xc4\xe2\x7b\x49\xc8", TILEZEROr, 0, FE_TMM1);
TEST("\xc4\xe2\x7b\x49\xf8", TILEZEROr, 0, FE_TMM7);
TEST("\xc4\xe2\x7b\x4b\x04\x10", TILELOADDrm, 0, FE_TMM0, FE_MEM(FE_AX, 1, FE_DX, 0));
TEST("\xc4\xe2\x7b\x4b\x04\x20", TILELOADDrm, 0, FE_TMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0)); // has SIB
TEST("\xc4\xe2\x79\x4b\x04\x10", TILELOADDT1rm, 0, FE_TMM0, FE_MEM(FE_AX, 1, FE_DX, 0));
TEST("\xc4\xe2\x79\x4b\x04\x20", TILELOADDT1rm, 0, FE_TMM0, FE_MEM(FE_AX, 0, FE_NOREG, 0)); // has SIB
TEST("\xc4\xe2\x7a\x4b\x04\x10", TILESTOREDmr, 0, FE_MEM(FE_AX, 1, FE_DX, 0), FE_TMM0);
TEST("\xc4\xe2\x7a\x4b\x04\x20", TILESTOREDmr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_TMM0); // has SIB
// TODO: enforce that all registers must be different
//TEST("", TDPBUUDrrr, 0, FE_TMM0, FE_TMM0, FE_TMM2");
//TEST("", TDPBUUDrrr, 0, FE_TMM2, FE_TMM0, FE_TMM2");
//TEST("", TDPBUUDrrr, 0, FE_TMM1, FE_TMM2, FE_TMM2");
TEST("\xc4\xe2\x6a\x5c\xc8", TDPBF16PSrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x6b\x5c\xc8", TDPFP16PSrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x68\x5e\xc8", TDPBUUDrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x69\x5e\xc8", TDPBUSDrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x6a\x5e\xc8", TDPBSUDrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x6b\x5e\xc8", TDPBSSDrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x68\x6c\xc8", TCMMRLFP16PSrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);
TEST("\xc4\xe2\x69\x6c\xc8", TCMMIMFP16PSrrr, 0, FE_TMM1, FE_TMM0, FE_TMM2);

// Test LOCK prefix
TEST("\xf0\x87\x08", LOCK_XCHG32mr, 0, FE_MEM(FE_AX, 0, FE_NOREG, 0), FE_CX);
TEST("\xf0\x0f\xc1\x01", LOCK_XADD32mr, 0, FE_MEM(FE_CX, 0, FE_NOREG, 0), FE_AX);

// Test long instructions
TEST("\x64\x67\xf0\x41\x81\x84\x00\x00\xff\xff\xff\x78\x56\x34\x12", LOCK_ADD32mi, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_R8, 1, FE_AX, -0x100), 0x12345678);
TEST("\x64\xf0\x66\x41\x81\x84\x00\x00\xff\xff\xff\x34\x12", LOCK_ADD16mi, FE_SEG(FE_FS), FE_MEM(FE_R8, 1, FE_AX, -0x100), 0x1234);
TEST("\x64\x67\xf0\x41\x0f\xba\xac\x00\x00\xff\xff\xff\x78", LOCK_BTS32mi, FE_ADDR32|FE_SEG(FE_FS), FE_MEM(FE_R8, 1, FE_AX, -0x100), 0x78);

// PBNDKB
TEST("\x0f\x01\xc7", PBNDKB, 0);

// SM4
TEST("\xc4\xe2\x6a\xda\xc1", VSM4KEY4_128rrr, 0, FE_XMM0, FE_XMM2, FE_XMM1);
TEST("\x62\xf2\x6e\x00\xda\xc1", VSM4KEY4_128rrr, 0, FE_XMM0, FE_XMM18, FE_XMM1);
TEST("\xc4\xe2\x6e\xda\xc1", VSM4KEY4_256rrr, 0, FE_XMM0, FE_XMM2, FE_XMM1);
TEST("\x62\xf2\x6e\x20\xda\xc1", VSM4KEY4_256rrr, 0, FE_XMM0, FE_XMM18, FE_XMM1);
TEST("\x62\xf2\x6e\x48\xda\xc1", VSM4KEY4_512rrr, 0, FE_XMM0, FE_XMM2, FE_XMM1);
TEST("\x62\xf2\x6e\x40\xda\xc1", VSM4KEY4_512rrr, 0, FE_XMM0, FE_XMM18, FE_XMM1);
TEST("\xc4\xe2\x6b\xda\xc1", VSM4RNDS4_128rrr, 0, FE_XMM0, FE_XMM2, FE_XMM1);
TEST("\x62\xf2\x6f\x00\xda\xc1", VSM4RNDS4_128rrr, 0, FE_XMM0, FE_XMM18, FE_XMM1);
TEST("\xc4\xe2\x6f\xda\xc1", VSM4RNDS4_256rrr, 0, FE_XMM0, FE_XMM2, FE_XMM1);
TEST("\x62\xf2\x6f\x20\xda\xc1", VSM4RNDS4_256rrr, 0, FE_XMM0, FE_XMM18, FE_XMM1);
TEST("\x62\xf2\x6f\x48\xda\xc1", VSM4RNDS4_512rrr, 0, FE_XMM0, FE_XMM2, FE_XMM1);
TEST("\x62\xf2\x6f\x40\xda\xc1", VSM4RNDS4_512rrr, 0, FE_XMM0, FE_XMM18, FE_XMM1);

```

`third_party/fadec/encode.c`:

```c

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <fadec-enc.h>


#ifdef __GNUC__
#define LIKELY(x) __builtin_expect((x), 1)
#define UNLIKELY(x) __builtin_expect((x), 0)
#else
#define LIKELY(x) (x)
#define UNLIKELY(x) (x)
#endif

#define OPC_66 0x80000
#define OPC_F2 0x100000
#define OPC_F3 0x200000
#define OPC_REXW 0x400000
#define OPC_LOCK 0x800000
#define OPC_VEXL0 0x1000000
#define OPC_VEXL1 0x1800000
#define OPC_EVEXL0 0x2000000
#define OPC_EVEXL1 0x2800000
#define OPC_EVEXL2 0x3000000
#define OPC_EVEXL3 0x3800000
#define OPC_EVEXB 0x4000000
#define OPC_VSIB 0x8000000
#define OPC_67 FE_ADDR32
#define OPC_SEG_MSK 0xe0000000
#define OPC_JMPL FE_JMPL
#define OPC_MASK_MSK 0xe00000000
#define OPC_EVEXZ 0x1000000000
#define OPC_USER_MSK (OPC_67|OPC_SEG_MSK|OPC_MASK_MSK)
#define OPC_FORCE_SIB 0x2000000000
#define OPC_DOWNGRADE_VEX 0x4000000000
#define OPC_DOWNGRADE_VEX_FLIPW 0x40000000000
#define OPC_EVEX_DISP8SCALE 0x38000000000
#define OPC_GPH_OP0 0x200000000000
#define OPC_GPH_OP1 0x400000000000

#define EPFX_REX_MSK 0x43f
#define EPFX_REX 0x20
#define EPFX_EVEX 0x40
#define EPFX_REXR 0x10
#define EPFX_REXX 0x08
#define EPFX_REXB 0x04
#define EPFX_REXR4 0x02
#define EPFX_REXB4 0x01
#define EPFX_REXX4 0x400
#define EPFX_VVVV_IDX 11

static bool op_mem(FeOp op) { return op < 0; }
static bool op_reg(FeOp op) { return op >= 0; }
static bool op_reg_gpl(FeOp op) { return (op & ~0x1f) == 0x100; }
static bool op_reg_gph(FeOp op) { return (op & ~0x3) == 0x204; }
static bool op_reg_xmm(FeOp op) { return (op & ~0x1f) == 0x600; }
static int64_t op_mem_offset(FeOp op) { return (int32_t) op; }
static unsigned op_mem_base(FeOp op) { return (op >> 32) & 0xfff; }
static unsigned op_mem_idx(FeOp op) { return (op >> 44) & 0xfff; }
static unsigned op_mem_scale(FeOp op) { return (op >> 56) & 0xf; }
static unsigned op_reg_idx(FeOp op) { return op & 0xff; }
static bool op_imm_n(FeOp imm, unsigned immsz) {
    if (immsz == 0 && !imm) return true;
    if (immsz == 1 && (int8_t) imm == imm) return true;
    if (immsz == 2 && (int16_t) imm == imm) return true;
    if (immsz == 3 && (imm&0xffffff) == imm) return true;
    if (immsz == 4 && (int32_t) imm == imm) return true;
    if (immsz == 8 && (int64_t) imm == imm) return true;
    return false;
}

static
unsigned
opc_size(uint64_t opc, uint64_t epfx)
{
    unsigned res = 1;
    if (UNLIKELY(opc & OPC_EVEXL0)) {
        res += 4;
    } else if (UNLIKELY(opc & OPC_VEXL0)) {
        if (opc & (OPC_REXW|0x20000) || epfx & (EPFX_REXX|EPFX_REXB))
            res += 3;
        else
            res += 2;
    } else {
        if (opc & OPC_LOCK) res++;
        if (opc & OPC_66) res++;
        if (opc & (OPC_F2|OPC_F3)) res++;
        if (opc & OPC_REXW || epfx & EPFX_REX_MSK) res++;
        if (opc & 0x30000) res++;
        if (opc & 0x20000) res++;
    }
    if (opc & OPC_SEG_MSK) res++;
    if (opc & OPC_67) res++;
    if (opc & 0x8000) res++;
    return res;
}

static
int
enc_opc(uint8_t** restrict buf, uint64_t opc, uint64_t epfx)
{
    if (opc & OPC_SEG_MSK)
        *(*buf)++ = (0x65643e362e2600 >> (8 * ((opc >> 29) & 7))) & 0xff;
    if (opc & OPC_67) *(*buf)++ = 0x67;
    if (opc & OPC_EVEXL0) {
        *(*buf)++ = 0x62;
        unsigned b1 = opc >> 16 & 7;
        if (!(epfx & EPFX_REXR)) b1 |= 0x80;
        if (!(epfx & EPFX_REXX)) b1 |= 0x40;
        if (!(epfx & EPFX_REXB)) b1 |= 0x20;
        if (!(epfx & EPFX_REXR4)) b1 |= 0x10;
        if ((epfx & EPFX_REXB4)) b1 |= 0x08;
        *(*buf)++ = b1;
        unsigned b2 = opc >> 20 & 3;
        if (!(epfx & EPFX_REXX4)) b2 |= 0x04;
        b2 |= (~(epfx >> EPFX_VVVV_IDX) & 0xf) << 3;
        if (opc & OPC_REXW) b2 |= 0x80;
        *(*buf)++ = b2;
        unsigned b3 = opc >> 33 & 7;
        b3 |= (~(epfx >> EPFX_VVVV_IDX) & 0x10) >> 1;
        if (opc & OPC_EVEXB) b3 |= 0x10;
        b3 |= (opc >> 23 & 3) << 5;
        if (opc & OPC_EVEXZ) b3 |= 0x80;
        *(*buf)++ = b3;
    } else if (opc & OPC_VEXL0) {
        if (epfx & (EPFX_REXR4|EPFX_REXX4|EPFX_REXB4|(0x10<<EPFX_VVVV_IDX))) return -1;
        bool vex3 = opc & (OPC_REXW|0x20000) || epfx & (EPFX_REXX|EPFX_REXB);
        unsigned pp = opc >> 20 & 3;
        *(*buf)++ = 0xc4 | !vex3;
        unsigned b2 = pp | (opc & 0x800000 ? 0x4 : 0);
        if (vex3) {
            unsigned b1 = opc >> 16 & 7;
            if (!(epfx & EPFX_REXR)) b1 |= 0x80;
            if (!(epfx & EPFX_REXX)) b1 |= 0x40;
            if (!(epfx & EPFX_REXB)) b1 |= 0x20;
            *(*buf)++ = b1;
            if (opc & OPC_REXW) b2 |= 0x80;
        } else {
            if (!(epfx & EPFX_REXR)) b2 |= 0x80;
        }
        b2 |= (~(epfx >> EPFX_VVVV_IDX) & 0xf) << 3;
        *(*buf)++ = b2;
    } else {
        if (opc & OPC_LOCK) *(*buf)++ = 0xF0;
        if (opc & OPC_66) *(*buf)++ = 0x66;
        if (opc & OPC_F2) *(*buf)++ = 0xF2;
        if (opc & OPC_F3) *(*buf)++ = 0xF3;
        if (opc & OPC_REXW || epfx & (EPFX_REX_MSK)) {
            unsigned rex = 0x40;
            if (opc & OPC_REXW) rex |= 8;
            if (epfx & EPFX_REXR) rex |= 4;
            if (epfx & EPFX_REXX) rex |= 2;
            if (epfx & EPFX_REXB) rex |= 1;
            *(*buf)++ = rex;
        }
        if (opc & 0x30000) *(*buf)++ = 0x0F;
        if ((opc & 0x30000) == 0x20000) *(*buf)++ = 0x38;
        if ((opc & 0x30000) == 0x30000) *(*buf)++ = 0x3A;
    }
    *(*buf)++ = opc & 0xff;
    if (opc & 0x8000) *(*buf)++ = (opc >> 8) & 0xff;
    return 0;
}

static
int
enc_imm(uint8_t** restrict buf, uint64_t imm, unsigned immsz)
{
    if (!op_imm_n(imm, immsz)) return -1;
    for (unsigned i = 0; i < immsz; i++)
        *(*buf)++ = imm >> 8 * i;
    return 0;
}

static
int
enc_o(uint8_t** restrict buf, uint64_t opc, uint64_t epfx, uint64_t op0)
{
    if (op_reg_idx(op0) & 0x8) epfx |= EPFX_REXB;

    // NB: this cannot happen. There is only one O-encoded instruction which
    // accepts high-byte registers (b0+/MOVABS Rb,Ib), which will never have a
    // REx prefix if the operand is a high-byte register.
    // bool has_rex = opc & OPC_REXW || epfx & EPFX_REX_MSK;
    // if (has_rex && op_reg_gph(op0)) return -1;

    if (enc_opc(buf, opc, epfx)) return -1;
    *(*buf - 1) = (*(*buf - 1) & 0xf8) | (op_reg_idx(op0) & 0x7);
    return 0;
}

static
int
enc_mr(uint8_t** restrict buf, uint64_t opc, uint64_t epfx, uint64_t op0,
       uint64_t op1, unsigned immsz)
{
    // If !op_reg(op1), it is a constant value for ModRM.reg
    if (op_reg(op0) && (op_reg_idx(op0) & 0x8)) epfx |= EPFX_REXB;
    if (op_reg(op0) && (op_reg_idx(op0) & 0x10))
        epfx |= 0 ? EPFX_REXB4 : EPFX_REXX|EPFX_EVEX;
    if (op_mem(op0) && (op_mem_base(op0) & 0x8)) epfx |= EPFX_REXB;
    if (op_mem(op0) && (op_mem_base(op0) & 0x10)) epfx |= EPFX_REXB4;
    if (op_mem(op0) && (op_mem_idx(op0) & 0x8)) epfx |= EPFX_REXX;
    if (op_mem(op0) && (op_mem_idx(op0) & 0x10))
        epfx |= opc & OPC_VSIB ? 0x10<<EPFX_VVVV_IDX : EPFX_REXX4;
    if (op_reg(op1) && (op_reg_idx(op1) & 0x8)) epfx |= EPFX_REXR;
    if (op_reg(op1) && (op_reg_idx(op1) & 0x10)) epfx |= EPFX_REXR4;

    bool has_rex = opc & (OPC_REXW|OPC_VEXL0|OPC_EVEXL0) || (epfx & EPFX_REX_MSK);
    if (has_rex && (op_reg_gph(op0) || op_reg_gph(op1))) return -1;

    if (epfx & (EPFX_EVEX|EPFX_REXB4|EPFX_REXX4|EPFX_REXR4|(0x10<<EPFX_VVVV_IDX))) {
        if (!(opc & OPC_EVEXL0)) return -1;
    } else if (opc & OPC_DOWNGRADE_VEX) { // downgrade EVEX to VEX
        // clear EVEX and disp8scale, set VEX
        opc = (opc & ~(uint64_t) (OPC_EVEXL0|OPC_EVEX_DISP8SCALE)) | OPC_VEXL0;
        if (opc & OPC_DOWNGRADE_VEX_FLIPW)
            opc ^= OPC_REXW;
    }

    if (LIKELY(op_reg(op0))) {
        if (enc_opc(buf, opc, epfx)) return -1;
        *(*buf)++ = 0xc0 | ((op_reg_idx(op1) & 7) << 3) | (op_reg_idx(op0) & 7);
        return 0;
    }

    unsigned opcsz = opc_size(opc, epfx);

    int mod = 0, reg = op1 & 7, rm;
    int scale = 0, idx = 4, base = 0;
    int32_t off = op_mem_offset(op0);
    bool withsib = opc & OPC_FORCE_SIB;

    if (!!op_mem_idx(op0) != !!op_mem_scale(op0)) return -1;
    if (!op_mem_idx(op0) && (opc & OPC_VSIB)) return -1;
    if (op_mem_idx(op0))
    {
        if (opc & OPC_VSIB)
        {
            if (!op_reg_xmm(op_mem_idx(op0))) return -1;
            // EVEX VSIB requires non-zero opmask
            if ((opc & OPC_EVEXL0) && !(opc & OPC_MASK_MSK)) return -1;
        }
        else
        {
            if (!op_reg_gpl(op_mem_idx(op0))) return -1;
            if (op_reg_idx(op_mem_idx(op0)) == 4) return -1;
        }
        idx = op_mem_idx(op0) & 7;
        int scalabs = op_mem_scale(op0);
        if (scalabs & (scalabs - 1)) return -1;
        scale = (scalabs & 0xA ? 1 : 0) | (scalabs & 0xC ? 2 : 0);
        withsib = true;
    }

    unsigned dispsz = 0;
    if (!op_mem_base(op0))
    {
        base = 5;
        rm = 4;
        dispsz = 4;
    }
    else if (op_mem_base(op0) == FE_IP)
    {
        rm = 5;
        dispsz = 4;
        // Adjust offset, caller doesn't know instruction length.
        off -= opcsz + 5 + immsz;
        if (withsib) return -1;
    }
    else
    {
        if (!op_reg_gpl(op_mem_base(op0))) return -1;
        rm = op_reg_idx(op_mem_base(op0)) & 7;
        if (withsib || rm == 4) {
            base = rm;
            rm = 4;
        }
        if (off) {
            unsigned disp8scale = (opc & OPC_EVEX_DISP8SCALE) >> 39;
            if (!(off & ((1 << disp8scale) - 1)) && op_imm_n(off >> disp8scale, 1)) {
                mod = 0x40;
                dispsz = 1;
                off >>= disp8scale;
            } else {
                mod = 0x80;
                dispsz = 4;
            }
        } else if (rm == 5) {
            mod = 0x40;
            dispsz = 1;
        }
    }

    if (opcsz + 1 + (rm == 4) + dispsz + immsz > 15) return -1;

    if (enc_opc(buf, opc, epfx)) return -1;
    *(*buf)++ = mod | (reg << 3) | rm;
    if (UNLIKELY(rm == 4))
        *(*buf)++ = (scale << 6) | (idx << 3) | base;
    return enc_imm(buf, off, dispsz);
}

typedef enum {
    ENC_NP, ENC_M, ENC_R, ENC_M1, ENC_MC, ENC_MR, ENC_RM, ENC_RMA, ENC_MRC,
    ENC_AM, ENC_MA, ENC_I, ENC_O, ENC_OA, ENC_S, ENC_A, ENC_D, ENC_FD, ENC_TD,
    ENC_IM,
    ENC_RVM, ENC_RVMR, ENC_RMV, ENC_VM, ENC_MVR, ENC_MRV,
    ENC_MAX
} Encoding;

struct EncodingInfo {
    uint8_t modrm : 2;
    uint8_t modreg : 2;
    uint8_t vexreg : 2;
    uint8_t immidx : 2;
    // 0 = normal or jump, 1 = constant 1, 2 = address-size, 3 = RVMR
    uint8_t immctl : 3;
    uint8_t zregidx : 2;
    uint8_t zregval : 1;
};

const struct EncodingInfo encoding_infos[ENC_MAX] = {
    [ENC_NP]      = { 0 },
    [ENC_M]       = { .modrm = 0x0^3, .immidx = 1 },
    [ENC_R]       = { .modreg = 0x0^3 },
    [ENC_M1]      = { .modrm = 0x0^3, .immctl = 1, .immidx = 1 },
    [ENC_MC]      = { .modrm = 0x0^3, .zregidx = 0x1^3, .zregval = 1 },
    [ENC_MR]      = { .modrm = 0x0^3, .modreg = 0x1^3, .immidx = 2 },
    [ENC_RM]      = { .modrm = 0x1^3, .modreg = 0x0^3, .immidx = 2 },
    [ENC_RMA]     = { .modrm = 0x1^3, .modreg = 0x0^3, .zregidx = 0x2^3, .zregval = 0 },
    [ENC_MRC]     = { .modrm = 0x0^3, .modreg = 0x1^3, .zregidx = 0x2^3, .zregval = 1 },
    [ENC_AM]      = { .modrm = 0x1^3, .zregidx = 0x0^3, .zregval = 0 },
    [ENC_MA]      = { .modrm = 0x0^3, .zregidx = 0x1^3, .zregval = 0 },
    [ENC_I]       = { .immidx = 0 },
    [ENC_O]       = { .modreg = 0x0^3, .immidx = 1 },
    [ENC_OA]      = { .modreg = 0x0^3, .zregidx = 0x1^3, .zregval = 0 },
    [ENC_S]       = { 0 },
    [ENC_A]       = { .zregidx = 0x0^3, .zregval = 0, .immidx = 1 },
    [ENC_D]       = { .immidx = 0 },
    [ENC_FD]      = { .zregidx = 0x0^3, .zregval = 0, .immctl = 2, .immidx = 1 },
    [ENC_TD]      = { .zregidx = 0x1^3, .zregval = 0, .immctl = 2, .immidx = 0 },
    [ENC_IM]      = { .modrm = 0x1^3, .immidx = 0 },
    [ENC_RVM]     = { .modrm = 0x2^3, .modreg = 0x0^3, .vexreg = 0x1^3, .immidx = 3 },
    [ENC_RVMR]    = { .modrm = 0x2^3, .modreg = 0x0^3, .vexreg = 0x1^3, .immctl = 3, .immidx = 3 },
    [ENC_RMV]     = { .modrm = 0x1^3, .modreg = 0x0^3, .vexreg = 0x2^3 },
    [ENC_VM]      = { .modrm = 0x1^3, .vexreg = 0x0^3, .immidx = 2 },
    [ENC_MVR]     = { .modrm = 0x0^3, .modreg = 0x2^3, .vexreg = 0x1^3 },
    [ENC_MRV]     = { .modrm = 0x0^3, .modreg = 0x1^3, .vexreg = 0x2^3 },
};

static const uint64_t alt_tab[] = {
#include <fadec-encode-private.inc>
};

int
fe_enc64_impl(uint8_t** restrict buf, uint64_t opc, FeOp op0, FeOp op1,
              FeOp op2, FeOp op3)
{
    uint8_t* buf_start = *buf;
    uint64_t ops[4] = {op0, op1, op2, op3};

    uint64_t epfx = 0;
    // Doesn't change between variants
    if ((opc & OPC_GPH_OP0) && op_reg_gpl(op0) && op0 >= FE_SP)
        epfx |= EPFX_REX;
    else if (!(opc & OPC_GPH_OP0) && op_reg_gph(op0))
        goto fail;
    if ((opc & OPC_GPH_OP1) && op_reg_gpl(op1) && op1 >= FE_SP)
        epfx |= EPFX_REX;
    else if (!(opc & OPC_GPH_OP1) && op_reg_gph(op1))
        goto fail;

try_encode:;
    unsigned enc = (opc >> 51) & 0x1f;
    const struct EncodingInfo* ei = &encoding_infos[enc];

    int64_t imm = 0xcc;
    unsigned immsz = (opc >> 47) & 0xf;

    if (UNLIKELY(ei->zregidx && op_reg_idx(ops[ei->zregidx^3]) != ei->zregval))
        goto next;

    if (UNLIKELY(enc == ENC_S)) {
        if ((op_reg_idx(op0) << 3 & 0x20) != (opc & 0x20)) goto next;
        opc |= op_reg_idx(op0) << 3;
    }

    if (immsz) {
        imm = ops[ei->immidx];
        if (UNLIKELY(ei->immctl)) {
            if (ei->immctl == 2) {
                immsz = UNLIKELY(opc & OPC_67) ? 4 : 8;
                if (immsz == 4) imm = (int32_t) imm; // address are zero-extended
            } else if (ei->immctl == 3) {
                if (!op_reg_xmm(imm)) goto fail;
                imm = op_reg_idx(imm) << 4;
                if (!op_imm_n(imm, 1)) goto fail;
            } else if (ei->immctl == 1) {
                if (imm != 1) goto next;
                immsz = 0;
            }
        } else if (enc == ENC_D) {
            imm -= (int64_t) *buf + opc_size(opc, epfx) + immsz;
            bool has_alt = opc >> 56 != 0;
            bool skip_to_alt = has_alt && UNLIKELY(opc & FE_JMPL);
            if (skip_to_alt || !op_imm_n(imm, immsz)) {
                if (!has_alt) goto fail;
                // JMP/Jcc special case
                immsz = 4;
                if (opc & 0x80) { // JMP
                    opc -= 2; // Convert opcode 0xeb to 0xe9
                    imm -= 3; // 3 extra immediate bytes
                } else { // Jcc
                    opc += 0x10010; // Add 0f escape + 0x10 to opcode
                    imm -= 4; // 0f escape + 3 extra immediate bytes
                }
                if (!op_imm_n(imm, immsz)) goto fail;
            }
        } else {
            if (!op_imm_n(imm, immsz)) goto next;
        }
    }

    // NOP has no operands, so this must be the 32-bit OA XCHG
    if ((opc & 0xfffffff) == 0x90 && ops[0] == FE_AX) goto next;

    if (UNLIKELY(enc == ENC_R)) {
        if (enc_mr(buf, opc, epfx, 0, ops[0], immsz)) goto fail;
    } else if (ei->modrm) {
        FeOp modreg = ei->modreg ? ops[ei->modreg^3] : (opc & 0xff00) >> 8;
        if (ei->vexreg)
            epfx |= ((uint64_t) op_reg_idx(ops[ei->vexreg^3])) << EPFX_VVVV_IDX;
        // Can fail for upgrade to EVEX due to high register numbers
        if (enc_mr(buf, opc, epfx, ops[ei->modrm^3], modreg, immsz)) goto next;
    } else if (ei->modreg) {
        if (enc_o(buf, opc, epfx, ops[ei->modreg^3])) goto fail;
    } else {
        if (enc_opc(buf, opc, epfx)) goto fail;
    }

    if (immsz)
        if (enc_imm(buf, imm, immsz)) goto fail;

    return 0;

next:;
    uint64_t alt = opc >> 56;
    if (alt) { // try alternative encoding, if available
        opc = alt_tab[alt] | (opc & OPC_USER_MSK);
        goto try_encode;
    }

fail:
    // Don't advance buffer on error; though we shouldn't write anything.
    *buf = buf_start;
    return -1;
}

```

`third_party/fadec/encode2-test.c`:

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include <fadec-enc2.h>


static
void print_hex(const uint8_t* buf, size_t len) {
    for (size_t i = 0; i < len; i++)
        printf("%02x", buf[i]);
}

static int
check(const uint8_t* buf, const void* exp, size_t exp_len, unsigned res, const char* name) {
    if (res == exp_len && !memcmp(buf, exp, exp_len))
        return 0;
    printf("Failed case (new) %s:\n", name);
    printf("  Exp (%2zu): ", exp_len);
    print_hex((const uint8_t*)exp, exp_len);
    printf("\n  Got (%2u): ", res);
    print_hex(buf, res);
    printf("\n");
    return -1;
}

#define TEST1(str, exp, name, ...) do { \
            memset(buf, 0, sizeof buf); \
            unsigned res = fe64_ ## name(buf, __VA_ARGS__); \
            failed |= check(buf, exp, sizeof(exp) - 1, res, str); \
        } while (0)
#define TEST(exp, ...) TEST1(#__VA_ARGS__, exp, __VA_ARGS__)

int
main(void) {
    int failed = 0;
    uint8_t buf[16];

    // This API is type safe and prohibits compilation of reg-type mismatches
#define ENC_TEST_TYPESAFE
    // Silence -Warray-bounds with double cast
#define FE_PTR(off) (const void*) ((uintptr_t) buf + (off))
#define FLAGMASK(flags, mask) flags, mask
#include "encode-test.inc"

    TEST("\x90", NOP, 0);
    TEST("\x90", NOP, 1);
    TEST("\x66\x90", NOP, 2);
    TEST("\x0f\x1f\x00", NOP, 3);
    TEST("\x0f\x1f\x40\x00", NOP, 4);
    TEST("\x0f\x1f\x44\x00\x00", NOP, 5);
    TEST("\x66\x0f\x1f\x44\x00\x00", NOP, 6);
    TEST("\x0f\x1f\x80\x00\x00\x00\x00", NOP, 7);
    TEST("\x0f\x1f\x84\x00\x00\x00\x00\x00", NOP, 8);
    TEST("\x66\x0f\x1f\x84\x00\x00\x00\x00\x00", NOP, 9);
    TEST("\x66\x0f\x1f\x84\x00\x00\x00\x00\x00\x90", NOP, 10);
    TEST("\x66\x0f\x1f\x84\x00\x00\x00\x00\x00\x66\x90", NOP, 11);
    TEST("\x66\x0f\x1f\x84\x00\x00\x00\x00\x00\x0f\x1f\x00", NOP, 12);

    puts(failed ? "Some tests FAILED" : "All tests PASSED");
    return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`third_party/fadec/encode2-test.cc`:

```cc

#include <array>
#include <cstring>
#include <cstdio>
#include <cstdlib>

#include <fadec-enc2.h>


using Buffer = std::array<uint8_t, 16>;

static
void print_hex(const uint8_t* buf, size_t len) {
    for (size_t i = 0; i < len; i++)
        std::printf("%02x", buf[i]);
}

static int
check(const Buffer& buf, const char* exp, size_t exp_len, unsigned res, const char* name) {
    if (res == exp_len && !std::memcmp(buf.data(), exp, exp_len))
        return 0;
    std::printf("Failed case (new) %s:\n", name);
    std::printf("  Exp (%2zu): ", exp_len);
    print_hex(reinterpret_cast<const uint8_t*>(exp), exp_len);
    std::printf("\n  Got (%2u): ", res);
    print_hex(buf.data(), res);
    std::printf("\n");
    return -1;
}

#define TEST1(str, exp, name, ...) do { \
            buf.fill(0); \
            unsigned res = fe64_ ## name(buf.data(), __VA_ARGS__); \
            failed |= check(buf, exp, sizeof(exp) - 1, res, str); \
        } while (0)
#define TEST(exp, ...) TEST1(#__VA_ARGS__, exp, __VA_ARGS__)

#define TEST_CPP1(str, exp, expr) do { \
            buf.fill(0); \
            unsigned res = (expr); \
            failed |= check(buf, exp, sizeof(exp) - 1, res, str); \
        } while (0)
#define TEST_CPP(exp, ...) TEST_CPP1(#__VA_ARGS__, exp, __VA_ARGS__)

int main() {
    int failed = 0;
    Buffer buf{};

    // This API is type safe and prohibits compilation of reg-type mismatches
#define ENC_TEST_TYPESAFE
    // Silence -Warray-bounds with double cast
#define FE_PTR(off) (const void*) ((uintptr_t) buf.data() + (off))
#define FLAGMASK(flags, mask) flags, mask
#include "encode-test.inc"

    // Test implicit conversion of parameters also on the actual functions
    TEST_CPP("\x0f\x90\xc0", fe64_SETO8r(buf.data(), 0, FE_AX));
    TEST_CPP("\x0f\x90\xc0", (fe64_SETO8r)(buf.data(), 0, FE_AX));
    TEST_CPP("\x0f\x90\xc4", fe64_SETO8r(buf.data(), 0, FE_AH));
    TEST_CPP("\x0f\x90\xc4", (fe64_SETO8r)(buf.data(), 0, FE_AH));

    std::puts(failed ? "Some tests FAILED" : "All tests PASSED");
    return failed ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`third_party/fadec/encode2.c`:

```c

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <fadec-enc2.h>


#ifdef __GNUC__
#define LIKELY(x) __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#if __has_attribute(cold) && __has_attribute(preserve_most)
#define HINT_COLD __attribute__((cold,preserve_most,noinline))
#elif  __has_attribute(cold)
#define HINT_COLD __attribute__((cold,noinline))
#else
#define HINT_COLD
#endif
#else
#define LIKELY(x) (x)
#define UNLIKELY(x) (x)
#define HINT_COLD
#endif

#define op_reg_idx(op) (op).idx
#define op_reg_gph(op) (((op).idx & ~0x3) == 0x24)
#define op_mem_base(mem) op_reg_idx((mem).base)
#define op_mem_idx(mem) op_reg_idx((mem).idx)

static bool
op_imm_n(int64_t imm, unsigned immsz) {
    if (immsz == 0 && !imm) return true;
    if (immsz == 1 && (int8_t) imm == imm) return true;
    if (immsz == 2 && (int16_t) imm == imm) return true;
    if (immsz == 3 && (imm&0xffffff) == imm) return true;
    if (immsz == 4 && (int32_t) imm == imm) return true;
    if (immsz == 8 && (int64_t) imm == imm) return true;
    return false;
}

HINT_COLD static unsigned
enc_seg67(uint8_t* buf, unsigned flags) {
    unsigned idx = 0;
    if (UNLIKELY(flags & FE_SEG_MASK)) {
        unsigned seg = (0x65643e362e2600 >> (8 * (flags & FE_SEG_MASK))) & 0xff;
        buf[idx++] = seg;
    }
    if (UNLIKELY(flags & FE_ADDR32)) buf[idx++] = 0x67;
    return idx;
}

static unsigned
enc_rex_mem(FeMem op0, uint64_t op1) {
    // Essentially just an and+or due to struct layout.
    uint32_t val = op1 | op0.flags | (op_mem_base(op0) << 8) |
                   ((uint32_t)op_mem_idx(op0) << 24);
    // Combine REX.RXB using multiplication for branch-less code.
    uint32_t masked = val & 0x08000808;
    return masked ? (uint8_t) (masked * (1|(1<<15)|(1<<25)) >> 26) + 0x40 : 0;
}

static void
enc_imm(uint8_t* buf, uint64_t imm, unsigned immsz) {
#ifdef __GNUC__
    // Clang doesn't fold the loop into a single store.
    // See: https://github.com/llvm/llvm-project/issues/154696
    if (__builtin_constant_p(immsz)) {
        __builtin_memcpy(buf, &imm, immsz);
        return;
    }
#endif
    for (unsigned i = 0; i < immsz; i++)
        *buf++ = imm >> 8 * i;
}

static int
enc_mem_common(uint8_t* buf, unsigned ripoff, FeMem op0, uint64_t op1,
               unsigned disp8scale) {
    int mod = 0, reg = op1 & 7, rm;
    unsigned sib = 0x20;
    bool withsib = false;
    unsigned dispsz = 0;
    int32_t off = op0.off;

    if (op_reg_idx(op0.idx) < 0x80) {
        int scalabs = op0.scale;
        if (UNLIKELY((unsigned) (op0.scale - 1) >= 8 ||
                     (op0.scale & (op0.scale - 1))))
            return 0;
        unsigned scale = (scalabs & 0xA ? 1 : 0) | (scalabs & 0xC ? 2 : 0);
        sib = scale << 6 | (op_reg_idx(op0.idx) & 7) << 3;
        withsib = true;
    } else if (UNLIKELY(op0.scale != 0)) {
        return 0;
    }

    if (UNLIKELY(op0.base.idx >= 0x20)) {
        if (UNLIKELY(op0.base.idx >= op_reg_idx(FE_NOREG))) {
            *buf++ = (reg << 3) | 4;
            *buf++ = sib | 5;
            enc_imm(buf, off, 4);
            return ripoff + 6;
        } else if (LIKELY(op0.base.idx == FE_IP.idx)) {
            if (withsib)
                return 0;
            *buf++ = (reg << 3) | 5;
            // Adjust offset, caller doesn't know instruction length.
            enc_imm(buf, off - ripoff - 5, 4);
            return ripoff + 5;
        } else {
            return 0;
        }
    }

    rm = op_reg_idx(op0.base) & 7;

    if (off) {
        if (LIKELY(!disp8scale)) {
            mod = (int8_t) off == off ? 0x40 : 0x80;
            dispsz = (int8_t) off == off ? 1 : 4;
        } else {
            if (!(off & ((1 << disp8scale) - 1)) && op_imm_n(off >> disp8scale, 1))
                off >>= disp8scale, mod = 0x40, dispsz = 1;
            else
                mod = 0x80, dispsz = 4;
        }
    } else if (rm == 5) {
        dispsz = 1;
        mod = 0x40;
    }

    // Always write four bytes of displacement. The buffer is always large
    // enough, and we truncate by returning a smaller "written bytes" count.
    if (withsib || rm == 4) {
        *buf++ = mod | (reg << 3) | 4;
        *buf++ = sib | rm;
        enc_imm(buf, off, 4);
        return ripoff + 2 + dispsz;
    } else {
        *buf++ = mod | (reg << 3) | rm;
        enc_imm(buf, off, 4);
        return ripoff + 1 + dispsz;
    }
}

static int
enc_mem(uint8_t* buf, unsigned ripoff, FeMem op0, uint64_t op1, bool forcesib,
        unsigned disp8scale) {
    if (UNLIKELY(op_reg_idx(op0.idx) == 4))
        return 0;
    if (forcesib && op_reg_idx(op0.idx) == op_reg_idx(FE_NOREG)) {
        op0.scale = 1;
        op0.idx = FE_GP(4);
    }
    return enc_mem_common(buf, ripoff, op0, op1, disp8scale);
}

static int
enc_mem_vsib(uint8_t* buf, unsigned ripoff, FeMemV op0, uint64_t op1,
             bool forcesib, unsigned disp8scale) {
    (void) forcesib;
    FeMem mem = FE_MEM(op0.base, op0.scale, FE_GP(op_reg_idx(op0.idx)), op0.off);
    return enc_mem_common(buf, ripoff, mem, op1, disp8scale);
}

// EVEX/VEX "Opcode" format:
//
// | EVEX byte 4 | P P M M M - - W | Opcode byte | VEX-D VEX-D-FLIPW
// 0             8                 16            24

enum {
    FE_OPC_VEX_WPP_SHIFT = 8,
    FE_OPC_VEX_WPP_MASK = 0x83 << FE_OPC_VEX_WPP_SHIFT,
    FE_OPC_VEX_MMM_SHIFT = 10,
    FE_OPC_VEX_MMM_MASK = 0x1f << FE_OPC_VEX_MMM_SHIFT,
    FE_OPC_VEX_DOWNGRADE_VEX = 1 << 24,
    FE_OPC_VEX_DOWNGRADE_VEX_FLIPW = 1 << 25,
};

static int
enc_vex_common(uint8_t* buf, unsigned opcode, unsigned base,
               unsigned idx, unsigned reg, unsigned vvvv) {
    if ((base | idx | reg | vvvv) & 0x10) return 0;
    bool vex3 = ((base | idx) & 0x08) || (opcode & 0xfc00) != 0x0400;
    if (vex3) {
        *buf++ = 0xc4;
        unsigned b1 = (opcode & FE_OPC_VEX_MMM_MASK) >> FE_OPC_VEX_MMM_SHIFT;
        if (!(reg & 0x08)) b1 |= 0x80;
        if (!(idx & 0x08)) b1 |= 0x40;
        if (!(base & 0x08)) b1 |= 0x20;
        *buf++ = b1;
        unsigned b2 = (opcode & FE_OPC_VEX_WPP_MASK) >> FE_OPC_VEX_WPP_SHIFT;
        if (opcode & 0x20) b2 |= 0x04;
        b2 |= (vvvv ^ 0xf) << 3;
        *buf++ = b2;
    } else {
        *buf++ = 0xc5;
        unsigned b2 = opcode >> FE_OPC_VEX_WPP_SHIFT & 3;
        if (opcode & 0x20) b2 |= 0x04;
        if (!(reg & 0x08)) b2 |= 0x80;
        b2 |= (vvvv ^ 0xf) << 3;
        *buf++ = b2;
    }
    *buf++ = (opcode & 0xff0000) >> 16;
    return 3 + vex3;
}

static int
enc_vex_reg(uint8_t* buf, unsigned opcode, uint64_t rm, uint64_t reg,
            uint64_t vvvv) {
    unsigned off = enc_vex_common(buf, opcode, rm, 0, reg, vvvv);
    buf[off] = 0xc0 | (reg << 3 & 0x38) | (rm & 7);
    return off ? off + 1 : 0;
}

static int
enc_vex_mem(uint8_t* buf, unsigned opcode, FeMem rm, uint64_t reg,
            uint64_t vvvv, unsigned ripoff, bool forcesib, unsigned disp8scale) {
    unsigned off = enc_vex_common(buf, opcode, op_reg_idx(rm.base), op_reg_idx(rm.idx), reg, vvvv);
    unsigned memoff = enc_mem(buf + off, ripoff + off, rm, reg, forcesib, disp8scale);
    return off && memoff ? memoff : 0;
}

static int
enc_vex_vsib(uint8_t* buf, unsigned opcode, FeMemV rm, uint64_t reg,
             uint64_t vvvv, unsigned ripoff, bool forcesib, unsigned disp8scale) {
    unsigned off = enc_vex_common(buf, opcode, op_reg_idx(rm.base), op_reg_idx(rm.idx), reg, vvvv);
    unsigned memoff = enc_mem_vsib(buf + off, ripoff + off, rm, reg, forcesib, disp8scale);
    return off && memoff ? memoff : 0;
}

static int
enc_evex_common(uint8_t* buf, unsigned opcode, unsigned base,
                unsigned idx, unsigned reg, unsigned vvvv) {
    *buf++ = 0x62;
    bool evexr3 = reg & 0x08;
    bool evexr4 = reg & 0x10;
    bool evexb3 = base & 0x08;
    bool evexb4 = base & 0x10; // evexb4 is unused in AVX-512 encoding
    bool evexx3 = idx & 0x08;
    bool evexx4 = idx & 0x10;
    bool evexv4 = vvvv & 0x10;
    unsigned b1 = (opcode & FE_OPC_VEX_MMM_MASK) >> FE_OPC_VEX_MMM_SHIFT;
    if (!evexr3) b1 |= 0x80;
    if (!evexx3) b1 |= 0x40;
    if (!evexb3) b1 |= 0x20;
    if (!evexr4) b1 |= 0x10;
    if (evexb4) b1 |= 0x08;
    *buf++ = b1;
    unsigned b2 = (opcode & FE_OPC_VEX_WPP_MASK) >> FE_OPC_VEX_WPP_SHIFT;
    if (!evexx4) b2 |= 0x04;
    b2 |= (~vvvv & 0xf) << 3;
    *buf++ = b2;
    unsigned b3 = opcode & 0xff;
    if (!evexv4) b3 |= 0x08;
    *buf++ = b3;
    *buf++ = (opcode & 0xff0000) >> 16;
    return 5;
}

static unsigned
enc_evex_to_vex(unsigned opcode) {
    return opcode & FE_OPC_VEX_DOWNGRADE_VEX_FLIPW ? opcode ^ 0x8000 : opcode;
}

// Encode AVX-512 EVEX r/m-reg, non-xmm reg, vvvv, prefer vex
static int
enc_evex_reg(uint8_t* buf, unsigned opcode, unsigned rm,
             unsigned reg, unsigned vvvv) {
    unsigned off;
    if (!((rm | reg | vvvv) & 0x10) && (opcode & FE_OPC_VEX_DOWNGRADE_VEX))
        off = enc_vex_common(buf, enc_evex_to_vex(opcode), rm, 0, reg, vvvv);
    else
        off = enc_evex_common(buf, opcode, rm, 0, reg, vvvv);
    buf[off] = 0xc0 | (reg << 3 & 0x38) | (rm & 7);
    return off + 1;
}

// Encode AVX-512 EVEX r/m-reg, xmm reg, vvvv, prefer vex
static int
enc_evex_xmm(uint8_t* buf, unsigned opcode, unsigned rm,
             unsigned reg, unsigned vvvv) {
    unsigned off;
    if (!((rm | reg | vvvv) & 0x10) && (opcode & FE_OPC_VEX_DOWNGRADE_VEX))
        off = enc_vex_common(buf, enc_evex_to_vex(opcode), rm, 0, reg, vvvv);
    else
        // AVX-512 XMM reg encoding uses X3 instead of B4.
        off = enc_evex_common(buf, opcode, rm & 0x0f, rm >> 1, reg, vvvv);
    buf[off] = 0xc0 | (reg << 3 & 0x38) | (rm & 7);
    return off + 1;
}

static int
enc_evex_mem(uint8_t* buf, unsigned opcode, FeMem rm, uint64_t reg,
             uint64_t vvvv, unsigned ripoff, bool forcesib, unsigned disp8scale) {
    unsigned off;
    if (!((op_reg_idx(rm.base) | op_reg_idx(rm.idx) | reg | vvvv) & 0x10) &&
        (opcode & FE_OPC_VEX_DOWNGRADE_VEX)) {
        disp8scale = 0; // Only AVX-512 EVEX compresses displacement
        off = enc_vex_common(buf, enc_evex_to_vex(opcode), op_reg_idx(rm.base), op_reg_idx(rm.idx), reg, vvvv);
    } else {
        off = enc_evex_common(buf, opcode, op_reg_idx(rm.base), op_reg_idx(rm.idx), reg, vvvv);
    }
    unsigned memoff = enc_mem(buf + off, ripoff + off, rm, reg, forcesib, disp8scale);
    return off && memoff ? memoff : 0;
}

static int
enc_evex_vsib(uint8_t* buf, unsigned opcode, FeMemV rm, uint64_t reg,
             uint64_t vvvv, unsigned ripoff, bool forcesib, unsigned disp8scale) {
    (void) vvvv;
    // EVEX VSIB requires non-zero mask operand
    if (!(opcode & 0x7)) return 0;
    // EVEX.X4 is encoded in EVEX.V4
    unsigned idx = op_reg_idx(rm.idx);
    unsigned off = enc_evex_common(buf, opcode, op_reg_idx(rm.base), idx & 0x0f, reg, idx & 0x10);
    unsigned memoff = enc_mem_vsib(buf + off, ripoff + off, rm, reg, forcesib, disp8scale);
    return off && memoff ? memoff : 0;
}

unsigned fe64_NOP(uint8_t* buf, unsigned flags) {
    unsigned len = flags ? flags : 1;
    // Taken from Intel SDM
    static const uint8_t tbl[] = {
        0x90,
        0x66, 0x90,
        0x0f, 0x1f, 0x00,
        0x0f, 0x1f, 0x40, 0x00,
        0x0f, 0x1f, 0x44, 0x00, 0x00,
        0x66, 0x0f, 0x1f, 0x44, 0x00, 0x00,
        0x0f, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x66, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    unsigned remain = len;
    for (; remain > 9; remain -= 9)
        for (unsigned i = 0; i < 9; i++)
            *(buf++) = tbl[36 + i];
    const uint8_t* src = tbl + (remain * (remain - 1)) / 2;
    for (unsigned i = 0; i < remain; i++)
        *(buf++) = src[i];
    return len;
}

#include <fadec-encode2-private.inc>

```

`third_party/fadec/fadec-decode-private.inc`:

```inc
// Auto-generated file -- do not modify!
#if defined(FD_DECODE_TABLE_DATA)
0x0004,0x0008,0x000c,0x0010,0x0014,0x0018,0x001c,0x0020,0x0024,0x0028,0x002c,0x0030,0x0034,0x0038,0x001c,0x0372,0x003c,0x0040,0x0044,0x0048,0x004c,0x0050,0x001c,0x0020,0x0054,0x0058,0x005c,0x0060,0x0064,0x0068,0x001c,0x0020,0x006c,0x0070,0x0074,0x0078,0x007c,0x0080,0xfff9,0x0084,0x0088,0x008c,0x0090,0x0094,0x0098,0x009c,0xfff9,0x00a0,0x00a4,0x00a8,0x00ac,0x00b0,0x00b4,0x00b8,0xfff9,0x00bc,0x00c0,0x00c4,0x00c8,0x00cc,0x00d0,0x00d4,0xfff9,0x00d8,0x00dc,0x00dc,0x00dc,0x00dc,0x00dc,0x00dc,0x00dc,0x00dc,0x00e0,0x00e0,0x00e0,0x00e0,0x00e0,0x00e0,0x00e0,0x00e0,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00ec,0x00f0,0x0202,0x00f8,0xfff9,0xfff9,0xfffa,0xfffb,0x0100,0x0104,0x0108,0x010c,0x0110,0x0114,0x0118,0x011c,0x0120,0x0124,0x0128,0x012c,0x0130,0x0134,0x0138,0x013c,0x0140,0x0144,0x0148,0x014c,0x0150,0x0154,0x0158,0x015c,0x0209,0x0219,0x0209,0x0229,0x01c0,0x01c4,0x01c8,0x01cc,0x01d0,0x01d4,0x01d8,0x01dc,0x0239,0x0249,0x0259,0x0269,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f4,0x01f8,0x01fc,0x0200,0x0204,0x0208,0x020c,0x0210,0x0214,0x0218,0x021c,0x0220,0x0224,0x0228,0x022c,0x0230,0x0234,0x0238,0x023c,0x0240,0x0244,0x0248,0x024c,0x0250,0x0254,0x0254,0x0254,0x0254,0x0254,0x0254,0x0254,0x0254,0x0258,0x0258,0x0258,0x0258,0x0258,0x0258,0x0258,0x0258,0x0279,0x0289,0x0294,0x0298,0x029a,0x02a2,0x02a9,0x02c1,0x02b8,0x02bc,0x02c0,0x02c4,0x02c8,0x02cc,0x02d0,0x02d4,0x02f1,0x0301,0x0311,0x0321,0x0348,0x034c,0x0000,0x0350,0x20d1,0x20e1,0x2119,0x2131,0x2149,0x2159,0x2169,0x2181,0x0354,0x0358,0x035c,0x0360,0x0364,0x0368,0x036c,0x0370,0x0374,0x0378,0x037c,0x0380,0x0384,0x0388,0x038c,0x0390,0xfffc,0x0394,0xfffd,0xfffd,0x0398,0x039c,0x0331,0x0341,0x03d8,0x03dc,0x03e0,0x03e4,0x03e8,0x03ec,0x0351,0x0361,0x0004,0x0008,0x000c,0x0010,0x0014,0x0018,0x0000,0x0000,0x0024,0x0028,0x002c,0x0030,0x0034,0x0038,0x0000,0x048a,0x003c,0x0040,0x0044,0x0048,0x004c,0x0050,0x0000,0x0000,0x0054,0x0058,0x005c,0x0060,0x0064,0x0068,0x0000,0x0000,0x006c,0x0070,0x0074,0x0078,0x007c,0x0080,0xfff8,0x0000,0x0088,0x008c,0x0090,0x0094,0x0098,0x009c,0xfff8,0x0000,0x00a4,0x00a8,0x00ac,0x00b0,0x00b4,0x00b8,0xfff8,0x0000,0x00c0,0x00c4,0x00c8,0x00cc,0x00d0,0x00d4,0xfff8,0x0000,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0xfffe,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e4,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x00e8,0x0000,0x0000,0x248a,0x00fc,0xfff9,0xfff9,0xfffa,0xfffb,0x0100,0x0104,0x0108,0x010c,0x0110,0x0114,0x0118,0x011c,0x0120,0x0124,0x0128,0x012c,0x0130,0x0134,0x0138,0x013c,0x0140,0x0144,0x0148,0x014c,0x0150,0x0154,0x0158,0x015c,0x0209,0x0219,0x0000,0x0229,0x01c0,0x01c4,0x01c8,0x01cc,0x01d0,0x01d4,0x01d8,0x01dc,0x0239,0x0249,0x0259,0x0269,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f0,0x01f4,0x01f8,0x0000,0x0200,0x0204,0x0208,0x020c,0x0210,0x0214,0x0218,0x021c,0x0220,0x0224,0x0228,0x022c,0x0230,0x0234,0x0238,0x023c,0x0240,0x0244,0x0248,0x024c,0x0250,0x0254,0x0254,0x0254,0x0254,0x0254,0x0254,0x0254,0x0254,0x0258,0x0258,0x0258,0x0258,0x0258,0x0258,0x0258,0x0258,0x0279,0x0289,0x0294,0x0298,0x1126,0x1126,0x02a9,0x02d1,0x02b8,0x02bc,0x02c0,0x02c4,0x02c8,0x02cc,0x0000,0x02d4,0x02f1,0x0301,0x0311,0x0321,0x0000,0x0000,0x0000,0x0350,0x20d1,0x20e1,0x2119,0x2131,0x2149,0x2159,0x2169,0x2181,0x0354,0x0358,0x035c,0x0360,0x0364,0x0368,0x036c,0x0370,0x0374,0x0378,0x0000,0x0380,0x0384,0x0388,0x038c,0x0390,0xfffc,0x0394,0xfffd,0xfffd,0x0398,0x039c,0x0331,0x0341,0x03d8,0x03dc,0x03e0,0x03e4,0x03e8,0x03ec,0x0351,0x0361,0x00f4,0x2e3e,0x237e,0x2592,0x0000,0x45be,0x48a2,0x0000,0x0160,0x0160,0x0164,0x0164,0x0168,0x0168,0x016c,0x016c,0x0170,0x0170,0x0174,0x0174,0x0178,0x0178,0x017c,0x017c,0x0180,0x0180,0x0184,0x0184,0x0188,0x0188,0x018c,0x018c,0x0190,0x0190,0x0194,0x0194,0x0198,0x0198,0x019c,0x019c,0x01a0,0x01a0,0x01a4,0x01a4,0x01a8,0x01a8,0x01ac,0x01ac,0x01b0,0x01b0,0x01b4,0x01b4,0x01b8,0x01b8,0x01bc,0x01bc,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x01e0,0x0000,0x0000,0x0000,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e4,0x0000,0x01e8,0x01e8,0x0000,0x0000,0x01e8,0x01e8,0x01e8,0x01e8,0x01e8,0x01e8,0x01e8,0x01e8,0x0000,0x0000,0x0000,0x0000,0x01ec,0x01ec,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x025c,0x025c,0x0260,0x0260,0x0264,0x0264,0x0268,0x0268,0x026c,0x026c,0x0270,0x0270,0x026c,0x026c,0x0274,0x0274,0x0278,0x0278,0x027c,0x027c,0x0280,0x0280,0x0284,0x0284,0x0288,0x0288,0x028c,0x028c,0x0288,0x0288,0x0290,0x0290,0x029c,0x144a,0x101a,0x123e,0x0000,0x0000,0x0000,0x0000,0x02a0,0x144a,0x101a,0x123e,0x0000,0x0000,0x0000,0x0000,0x02a4,0x02a4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x02b9,0x02a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x02ac,0x02ac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x02e1,0x02ac,0x02ac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x02e9,0x02b0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x02b4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x02d8,0x02d8,0x02dc,0x02dc,0x02e0,0x02e0,0x02e4,0x02e4,0x02e8,0x02e8,0x02ec,0x02ec,0x02e8,0x02e8,0x02f0,0x02f0,0x02f4,0x02f4,0x02f8,0x02f8,0x02fc,0x02fc,0x0300,0x0300,0x0304,0x0304,0x0308,0x0308,0x0304,0x0304,0x030c,0x030c,0x0310,0x0310,0x0314,0x0314,0x0318,0x0318,0x031c,0x031c,0x0320,0x0320,0x0324,0x0324,0x0320,0x0320,0x0328,0x0328,0x032c,0x032c,0x0330,0x0330,0x0334,0x0334,0x0338,0x0338,0x033c,0x033c,0x0340,0x0340,0x033c,0x033c,0x0344,0x0344,0x03a0,0x03a0,0x03a0,0x03a0,0x03a4,0x03a4,0x03a8,0x03a8,0x03ac,0x03ac,0x03b0,0x03b0,0x03b4,0x03b4,0x03b8,0x03b8,0x03bc,0x03bc,0x03bc,0x03bc,0x03c0,0x03c0,0x03c4,0x03c4,0x03c8,0x03c8,0x03cc,0x03cc,0x03d0,0x03d0,0x03d4,0x03d4,0x03f0,0x03f0,0x03f4,0x03f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x03f8,0x03f8,0x03fc,0x03fc,0x0400,0x0400,0x0404,0x0000,0x0408,0x0408,0x040c,0x0000,0x0410,0x0410,0x0000,0x0000,0x0000,0x037a,0x072e,0x0b56,0x0000,0x0000,0x0000,0x0000,0x2af7,0x05b3,0x0480,0x0484,0x0000,0x0000,0x048c,0x0000,0x0494,0x26eb,0x0000,0x049c,0x0000,0x0679,0x04b4,0x04b8,0x0c5b,0x0c5f,0x0c63,0x0c87,0x0cab,0x0caf,0x0cb3,0x0cd7,0x0689,0x04b0,0x04b0,0x04b0,0x220b,0x04b0,0x21ab,0x06a9,0x04d8,0x04dc,0x04e0,0x04e4,0x0000,0x0000,0x0000,0x0000,0x0cfb,0x0cff,0x0957,0x0d03,0x095b,0x095f,0x0d47,0x0d4b,0x04e8,0x04ec,0x04f0,0x04f4,0x04f8,0x04fc,0x0000,0x06bb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0504,0x0508,0x050c,0x0510,0x0514,0x0518,0x051c,0x0520,0x0524,0x0528,0x052c,0x0530,0x0534,0x0538,0x053c,0x0540,0x0d4f,0x0d73,0x0d77,0x0d7b,0x0d7f,0x0d83,0x0d87,0x0d8b,0x0d8f,0x0d93,0x0d97,0x0d9b,0x0d9f,0x0da3,0x0da7,0x0dab,0x0963,0x0967,0x096b,0x096f,0x0973,0x0977,0x097b,0x097f,0x0983,0x0987,0x098b,0x098f,0x0daf,0x0db3,0x0993,0x099f,0x09a3,0x09a7,0x09bb,0x09cf,0x09e3,0x09e7,0x09eb,0x09ef,0x0def,0x0e13,0x0000,0x0000,0x0e37,0x0e3b,0x09f3,0x09ff,0x0544,0x0548,0x054c,0x0550,0x0554,0x0558,0x055c,0x0560,0x0564,0x0568,0x056c,0x0570,0x0574,0x0578,0x057c,0x0580,0x0584,0x0588,0x058c,0x0590,0x0594,0x0598,0x059c,0x05a0,0x05a4,0x05a8,0x05ac,0x05b0,0x05b4,0x05b8,0x05bc,0x05c0,0x05c4,0x05c8,0x05cc,0x05d0,0x05d4,0x05d8,0x221f,0x224b,0x05c4,0x05c8,0x05dc,0x05e0,0x05e4,0x05e8,0x0e47,0x05ec,0x05f0,0x05f4,0x06bd,0x05fc,0x06cd,0x06dd,0x0608,0x060c,0x06ef,0x0614,0x06f1,0x0628,0x0703,0x0707,0x063c,0x0640,0x0644,0x0648,0x0e5f,0x070b,0x0a03,0x0a07,0x0e73,0x22cf,0x0654,0x0654,0x0654,0x0654,0x0654,0x0654,0x0654,0x0654,0x0e77,0x0a1b,0x0a1f,0x0a23,0x0a27,0x0a2b,0x0a2f,0x0a53,0x0a67,0x0a6b,0x0a6f,0x0a73,0x0a77,0x0a7b,0x0a7f,0x0a83,0x0a87,0x0a8b,0x0a8f,0x0a93,0x0a97,0x0a9b,0x0e8b,0x0a9f,0x0ab3,0x0ab7,0x0ac3,0x0abb,0x0abf,0x0acb,0x0ac7,0x0acf,0x0e9f,0x0ad3,0x0ad7,0x0adb,0x0adf,0x0ae3,0x0ae7,0x0aeb,0x0aff,0x0b03,0x0b07,0x0b0b,0x0b0f,0x0b13,0x0b17,0x0658,0x0414,0x0414,0x0418,0x0418,0x041c,0x041c,0x0420,0x0420,0x0424,0x0424,0x0428,0x0428,0x0000,0x0000,0x0000,0x0000,0x0000,0x0492,0x0842,0x0b56,0x0000,0x0000,0x0000,0x0000,0x2af7,0x05ef,0x0480,0x0484,0x0000,0x0488,0x048c,0x0490,0x0494,0x26eb,0x0000,0x049c,0x0000,0x0679,0x04b4,0x04b8,0x0c5b,0x0c5f,0x0c63,0x0c87,0x0cab,0x0caf,0x0cb3,0x0cd7,0x0699,0x04b0,0x04b0,0x04b0,0x220b,0x04b0,0x21ab,0x06a9,0x04d8,0x04dc,0x04e0,0x04e4,0x0000,0x0000,0x0000,0x0000,0x0cfb,0x0cff,0x0957,0x0d03,0x095b,0x095f,0x0d47,0x0d4b,0x04e8,0x04ec,0x04f0,0x04f4,0x04f8,0x04fc,0x0000,0x06bb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0504,0x0508,0x050c,0x0510,0x0514,0x0518,0x051c,0x0520,0x0524,0x0528,0x052c,0x0530,0x0534,0x0538,0x053c,0x0540,0x0d4f,0x0d73,0x0d77,0x0d7b,0x0d7f,0x0d83,0x0d87,0x0d8b,0x0d8f,0x0d93,0x0d97,0x0d9b,0x0d9f,0x0da3,0x0da7,0x0dab,0x0963,0x0967,0x096b,0x096f,0x0973,0x0977,0x097b,0x097f,0x0983,0x0987,0x098b,0x098f,0x0daf,0x0db3,0x0993,0x099f,0x09a3,0x09a7,0x09bb,0x09cf,0x09e3,0x09e7,0x09eb,0x09ef,0x0def,0x0e13,0x0000,0x0000,0x0e37,0x0e3b,0x09f3,0x09ff,0x0544,0x0548,0x054c,0x0550,0x0554,0x0558,0x055c,0x0560,0x0564,0x0568,0x056c,0x0570,0x0574,0x0578,0x057c,0x0580,0x0584,0x0588,0x058c,0x0590,0x0594,0x0598,0x059c,0x05a0,0x05a4,0x05a8,0x05ac,0x05b0,0x05b4,0x05b8,0x05bc,0x05c0,0x05c4,0x05c8,0x05cc,0x05d0,0x05d4,0x05d8,0x221f,0x224b,0x05c4,0x05c8,0x05dc,0x05e0,0x05e4,0x05e8,0x0e5b,0x05ec,0x05f0,0x05f4,0x06bd,0x05fc,0x06cd,0x06dd,0x0608,0x060c,0x06ef,0x0614,0x06f1,0x0628,0x0703,0x0707,0x063c,0x0640,0x0644,0x0648,0x0e5f,0x070b,0x0a03,0x0a07,0x0e73,0x2303,0x0654,0x0654,0x0654,0x0654,0x0654,0x0654,0x0654,0x0654,0x0e77,0x0a1b,0x0a1f,0x0a23,0x0a27,0x0a2b,0x0a2f,0x0a53,0x0a67,0x0a6b,0x0a6f,0x0a73,0x0a77,0x0a7b,0x0a7f,0x0a83,0x0a87,0x0a8b,0x0a8f,0x0a93,0x0a97,0x0a9b,0x0e8b,0x0a9f,0x0ab3,0x0ab7,0x0ac3,0x0abb,0x0abf,0x0acb,0x0ac7,0x0acf,0x0e9f,0x0ad3,0x0ad7,0x0adb,0x0adf,0x0ae3,0x0ae7,0x0aeb,0x0aff,0x0b03,0x0b07,0x0b0b,0x0b0f,0x0b13,0x0b17,0x0658,0x042c,0x05e5,0x0430,0x0629,0x0434,0x0631,0x0438,0x231d,0x043c,0x0440,0x0000,0x26ed,0x0444,0x0444,0x0448,0x0659,0x042c,0x0621,0x0430,0x0629,0x0434,0x0631,0x0438,0x231d,0x043c,0x0440,0x0000,0x26ed,0x0444,0x0444,0x0448,0x0639,0x0591,0x05b5,0x05c5,0x05d5,0x042c,0x0000,0x0430,0x2315,0x0434,0x0000,0x0438,0x231d,0x043c,0x0440,0x0000,0x0000,0x0444,0x0444,0x0448,0x0661,0x042c,0x0000,0x0430,0x2b09,0x0434,0x0000,0x0438,0x2325,0x043c,0x0440,0x14c8,0x2199,0x0444,0x0444,0x0448,0x0669,0x042c,0x0000,0x0430,0x2b11,0x0434,0x0000,0x0438,0x2325,0x043c,0x0440,0x0000,0x2725,0x0444,0x0444,0x0448,0x0671,0x044c,0x1524,0x1530,0x1534,0x1548,0x15f4,0x16d4,0x0000,0x05a1,0x05f1,0x0601,0x0611,0x042c,0x0000,0x0430,0x2315,0x0434,0x0000,0x0438,0x231d,0x043c,0x0440,0x0000,0x0000,0x0444,0x0444,0x0448,0x0641,0x042c,0x286d,0x0430,0x2b09,0x0434,0x0000,0x0438,0x2325,0x043c,0x0440,0x14c8,0x21a1,0x0444,0x0444,0x0448,0x0649,0x042c,0x2865,0x0430,0x2b11,0x0434,0x0000,0x0438,0x2325,0x043c,0x0440,0x0000,0x2725,0x0444,0x0444,0x0448,0x0651,0x044c,0x1524,0x1530,0x1534,0x1548,0x15f4,0x16d4,0x17a4,0x0450,0x0454,0x0458,0x045c,0x0000,0x0000,0x0000,0x0460,0x0464,0x0468,0x0000,0x0000,0x152c,0x046c,0x0470,0x0474,0x0478,0x047c,0x158c,0x1594,0x1560,0x1564,0x1598,0x159c,0x0478,0x047c,0x0000,0x0000,0x1560,0x1564,0x0000,0x0000,0x0478,0x047c,0x1590,0x0000,0x1560,0x15a0,0x15a8,0x15b0,0x0478,0x047c,0x0000,0x0000,0x1560,0x15a4,0x15ac,0x15b4,0x0000,0x047c,0x158c,0x1594,0x1560,0x1564,0x1598,0x159c,0x0000,0x047c,0x0000,0x0000,0x1560,0x1564,0x0000,0x0000,0x0000,0x047c,0x1590,0x0000,0x1560,0x0000,0x0000,0x0000,0x0000,0x047c,0x0000,0x0000,0x1560,0x0000,0x0000,0x0000,0x04a0,0x04b0,0x04a4,0x04b0,0x04a8,0x04b0,0x04ac,0x04b0,0x04ac,0x04b0,0x04ac,0x04b0,0x04ac,0x04b0,0x04ac,0x04b0,0x04bc,0x04b0,0x04c0,0x04b0,0x04c4,0x04b0,0x04c8,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04bc,0x04b0,0x04c0,0x04b0,0x04c4,0x04b0,0x04c8,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04cc,0x04b0,0x04d0,0x04b0,0x04d4,0x04d4,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x0500,0x0000,0x0000,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x05f8,0x0000,0x0600,0x0000,0x0600,0x0000,0x0600,0x0000,0x0600,0x0000,0x0600,0x0000,0x0600,0x0000,0x0600,0x0000,0x0600,0x0000,0x0604,0x0000,0x0604,0x0000,0x0604,0x0000,0x0604,0x0000,0x0604,0x0000,0x0604,0x0000,0x0604,0x0000,0x0604,0x0000,0x0000,0x0000,0x0610,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0618,0x0618,0x061c,0x061c,0x0620,0x0620,0x0624,0x0624,0x062c,0x062c,0x0630,0x062c,0x0634,0x0634,0x0638,0x0634,0x070d,0x0000,0x0000,0x0000,0x064c,0x0000,0x064c,0x0000,0x064c,0x0000,0x064c,0x0000,0x064c,0x0000,0x064c,0x0000,0x064c,0x0000,0x064c,0x0000,0x0000,0x0000,0x0650,0x0000,0x0000,0x0000,0x162c,0x0000,0x1630,0x0000,0x1634,0x0000,0x1538,0x1638,0x153c,0x163c,0x0b1b,0x0b1f,0x0b23,0x0b27,0x0b2b,0x0b2f,0x0b33,0x0b37,0x0b3b,0x0b3f,0x0b43,0x0b47,0x0000,0x0000,0x0000,0x0000,0x0ec3,0x0000,0x0000,0x0000,0x0ec7,0x0ecb,0x0000,0x0ecf,0x0000,0x0000,0x0000,0x0000,0x0b4b,0x0b4f,0x0b53,0x0000,0x0ed3,0x0ed7,0x0edb,0x0edf,0x0ee3,0x0ee7,0x0000,0x0000,0x0eeb,0x0eef,0x0ef3,0x0f07,0x0000,0x0000,0x0000,0x0000,0x0f0b,0x0f0f,0x0f13,0x0f17,0x0f1b,0x0f1f,0x0000,0x0f23,0x0f27,0x0f2b,0x0f2f,0x0f33,0x0f37,0x0f3b,0x0f3f,0x0f43,0x0f47,0x0f4b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x22a7,0x22bb,0x26f7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x270b,0x270f,0x2713,0x2717,0x271b,0x271f,0x0000,0x234f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a7b,0x0000,0x0000,0x1003,0x1007,0x100b,0x100f,0x1013,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x082f,0x0943,0x0000,0x0000,0x0000,0x21c7,0x20cf,0x0000,0x0f4f,0x0f67,0x2acf,0x2ae3,0x2877,0x0000,0x0000,0x0000,0x0831,0x0831,0x0000,0x0660,0x065c,0x0000,0x065c,0x0000,0x065c,0x0000,0x065c,0x0000,0x065c,0x0000,0x065c,0x0000,0x065c,0x0000,0x065c,0x0000,0x0b1b,0x0b1f,0x0b23,0x0b27,0x0b2b,0x0b2f,0x0b33,0x0b37,0x0b3b,0x0b3f,0x0b43,0x0b47,0x0000,0x0000,0x0000,0x0000,0x0ec3,0x0000,0x0000,0x0000,0x0ec7,0x0ecb,0x0000,0x0ecf,0x0000,0x0000,0x0000,0x0000,0x0b4b,0x0b4f,0x0b53,0x0000,0x0ed3,0x0ed7,0x0edb,0x0edf,0x0ee3,0x0ee7,0x0000,0x0000,0x0eeb,0x0eef,0x0ef3,0x0f07,0x0000,0x0000,0x0000,0x0000,0x0f0b,0x0f0f,0x0f13,0x0f17,0x0f1b,0x0f1f,0x0000,0x0f23,0x0f27,0x0f2b,0x0f2f,0x0f33,0x0f37,0x0f3b,0x0f3f,0x0f43,0x0f47,0x0f4b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x22a7,0x22bb,0x26f7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x270b,0x270f,0x2713,0x2717,0x271b,0x271f,0x0000,0x234f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a7b,0x0000,0x0000,0x1003,0x1007,0x100b,0x100f,0x1013,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x082f,0x0943,0x0000,0x0000,0x0000,0x21c7,0x20cf,0x0000,0x0f63,0x0f67,0x2acf,0x2ae3,0x2877,0x0000,0x0000,0x0000,0x0945,0x0945,0x0000,0x0668,0x0664,0x0000,0x0664,0x0000,0x0664,0x0000,0x0664,0x0000,0x0664,0x0000,0x0664,0x0000,0x0664,0x0000,0x0664,0x0000,0x066c,0x0670,0x0870,0x0874,0x0674,0x0678,0x0888,0x088c,0x067c,0x0680,0x0890,0x0894,0x0684,0x096c,0x0000,0x0000,0x0688,0x0970,0x0000,0x0000,0x068c,0x0974,0x0000,0x0000,0x0690,0x0978,0x0000,0x0000,0x0694,0x097c,0x0000,0x0000,0x0698,0x0980,0x0000,0x0000,0x069c,0x0984,0x0000,0x0000,0x06a0,0x0988,0x0000,0x0000,0x06a4,0x098c,0x0000,0x0000,0x06a8,0x0990,0x0000,0x0000,0x06ac,0x0994,0x0000,0x0000,0x06b0,0x0998,0x0000,0x0000,0x0996,0x0db6,0x0000,0x0000,0x06b4,0x06b8,0x06b4,0x06b8,0x0000,0x0000,0x0000,0x0000,0x06bc,0x09ac,0x09b0,0x0000,0x06c0,0x09b4,0x09b8,0x09bc,0x09a9,0x0dbd,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x06c4,0x0000,0x0000,0x0000,0x06c8,0x0000,0x0000,0x0000,0x06cc,0x0000,0x0000,0x09bd,0x0dcd,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x06d0,0x0000,0x0000,0x0000,0x06d4,0x0000,0x0000,0x0000,0x06d8,0x0000,0x0000,0x09d1,0x0ddd,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x06dc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x06e0,0x0000,0x0000,0x06e4,0x09e8,0x0000,0x0000,0x06e8,0x09ec,0x0000,0x0000,0x06ec,0x09f0,0x0000,0x0000,0x06f0,0x0000,0x0000,0x0000,0x09f6,0x0e3e,0x0a1c,0x0000,0x06f4,0x06f8,0x06f4,0x06f8,0x0000,0x0000,0x0000,0x0000,0x06fc,0x0a20,0x0a24,0x0000,0x0700,0x0a54,0x0000,0x0000,0x0a09,0x0e61,0x0000,0x0000,0x0000,0x0704,0x0000,0x0704,0x0000,0x0704,0x0000,0x0704,0x0000,0x0704,0x0000,0x0704,0x0000,0x0704,0x0000,0x0704,0x0708,0x0a6c,0x0000,0x0000,0x070c,0x0a70,0x0000,0x0000,0x0710,0x0a74,0x0000,0x0000,0x0714,0x0a78,0x0000,0x0000,0x0718,0x0a7c,0x0000,0x0000,0x0000,0x0a80,0x0a41,0x0a31,0x0000,0x071c,0x0000,0x071c,0x0000,0x071c,0x0000,0x071c,0x0000,0x071c,0x0000,0x071c,0x0000,0x071c,0x0000,0x071c,0x0000,0x0720,0x0000,0x0720,0x0000,0x0720,0x0000,0x0720,0x0000,0x0720,0x0000,0x0720,0x0000,0x0720,0x0000,0x0720,0x0a55,0x0e79,0x0000,0x0000,0x0000,0x0724,0x0000,0x0724,0x0000,0x0724,0x0000,0x0724,0x0000,0x0724,0x0000,0x0724,0x0000,0x0724,0x0000,0x0724,0x0728,0x0a88,0x0000,0x0000,0x072c,0x0a8c,0x0000,0x0000,0x0730,0x0a90,0x0000,0x0000,0x0734,0x0a94,0x0000,0x0000,0x0738,0x0a98,0x0000,0x0000,0x073c,0x0a9c,0x0000,0x0000,0x0740,0x0aa0,0x0000,0x0000,0x0744,0x0aa4,0x0000,0x0000,0x0748,0x0aa8,0x0000,0x0000,0x074c,0x0aac,0x0000,0x0000,0x0750,0x0ab0,0x0000,0x0000,0x0754,0x0ab4,0x0000,0x0000,0x0758,0x0ab8,0x0000,0x0000,0x075c,0x0abc,0x0000,0x0000,0x0aa1,0x0e8d,0x0000,0x0000,0x0760,0x0000,0x0760,0x0000,0x0760,0x0000,0x0760,0x0000,0x0760,0x0000,0x0760,0x0000,0x0760,0x0000,0x0760,0x0000,0x0764,0x0ad0,0x0000,0x0000,0x0768,0x0ad4,0x0000,0x0000,0x076c,0x0ad8,0x0000,0x0000,0x0770,0x0adc,0x0000,0x0000,0x0774,0x0ae0,0x0000,0x0000,0x0778,0x0ae4,0x0000,0x0000,0x077c,0x0ae8,0x0000,0x0000,0x0780,0x0aec,0x0000,0x0000,0x0784,0x0af4,0x0000,0x0000,0x0788,0x0af8,0x0000,0x0000,0x078c,0x0afc,0x0000,0x0000,0x0790,0x0b00,0x0000,0x0000,0x0794,0x0b04,0x0000,0x0000,0x0798,0x0b08,0x0000,0x0000,0x0aed,0x0eb1,0x0000,0x0000,0x0000,0x079c,0x0000,0x079c,0x0000,0x079c,0x0000,0x079c,0x0000,0x079c,0x0000,0x079c,0x0000,0x079c,0x0000,0x079c,0x07a0,0x0b10,0x0000,0x0000,0x07a4,0x0b14,0x0000,0x0000,0x07a8,0x0b18,0x0000,0x0000,0x07ac,0x0b1c,0x0000,0x0000,0x07b0,0x0b20,0x0000,0x0000,0x07b4,0x0b24,0x0000,0x0000,0x07b8,0x0b28,0x0000,0x0000,0x07bc,0x0b2c,0x0000,0x0000,0x07c0,0x0b30,0x0000,0x0000,0x07c4,0x0b34,0x0000,0x0000,0x07c8,0x0b38,0x0000,0x0000,0x07cc,0x0b3c,0x0000,0x0000,0x07d0,0x0b40,0x0000,0x0000,0x07d4,0x0b44,0x0000,0x0000,0x07d8,0x0b48,0x0000,0x0000,0x07dc,0x0b4c,0x0000,0x0000,0x07e0,0x0b50,0x0000,0x0000,0x07e4,0x0b54,0x0000,0x0000,0x07e8,0x0b58,0x0000,0x0000,0x07ec,0x0b6c,0x0000,0x0000,0x07f0,0x0b70,0x0000,0x0000,0x07f4,0x0b74,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0f7b,0x0f7f,0x0f83,0x0f87,0x0f8b,0x0f8f,0x0f93,0x0c57,0x0000,0x0000,0x0000,0x0000,0x0f97,0x0fab,0x0fbf,0x0fcb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0fcf,0x0fd3,0x0fd7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0fe3,0x0fe7,0x0feb,0x0000,0x0fef,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0ff3,0x0ff7,0x0ffb,0x0fff,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2723,0x0000,0x2353,0x2357,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1017,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x284b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x07f8,0x0c08,0x0000,0x0000,0x07fc,0x0800,0x0804,0x0808,0x080c,0x0810,0x0814,0x0818,0x0c65,0x0c75,0x0828,0x082c,0x081c,0x0820,0x081c,0x0820,0x081c,0x0820,0x081c,0x0820,0x081c,0x0820,0x081c,0x0820,0x081c,0x0820,0x081c,0x0820,0x0824,0x0000,0x0824,0x0000,0x0824,0x0000,0x0824,0x0000,0x0824,0x0000,0x0824,0x0000,0x0824,0x0000,0x0824,0x0000,0x0c89,0x0c99,0x0000,0x0000,0x0830,0x0000,0x0830,0x0000,0x0830,0x0000,0x0830,0x0000,0x0830,0x0000,0x0830,0x0000,0x0830,0x0000,0x0830,0x0000,0x0834,0x0000,0x0834,0x0000,0x0834,0x0000,0x0834,0x0000,0x0834,0x0000,0x0834,0x0000,0x0834,0x0000,0x0834,0x0000,0x0838,0x083c,0x0000,0x0000,0x0840,0x0844,0x0000,0x0000,0x0cb5,0x0cc5,0x0854,0x0000,0x0848,0x084c,0x0848,0x084c,0x0848,0x084c,0x0848,0x084c,0x0848,0x084c,0x0848,0x084c,0x0848,0x084c,0x0848,0x084c,0x0850,0x0000,0x0850,0x0000,0x0850,0x0000,0x0850,0x0000,0x0850,0x0000,0x0850,0x0000,0x0850,0x0000,0x0850,0x0000,0x0cd9,0x0ce9,0x0000,0x0000,0x0858,0x0000,0x0858,0x0000,0x0858,0x0000,0x0858,0x0000,0x0858,0x0000,0x0858,0x0000,0x0858,0x0000,0x0858,0x0000,0x085c,0x0000,0x085c,0x0000,0x085c,0x0000,0x085c,0x0000,0x085c,0x0000,0x085c,0x0000,0x085c,0x0000,0x085c,0x0000,0x0860,0x0864,0x0000,0x0000,0x0868,0x086c,0x0000,0x0000,0x0d05,0x0d15,0x0d25,0x0d35,0x0878,0x0000,0x0878,0x0000,0x0878,0x0000,0x0878,0x0000,0x0878,0x0000,0x0878,0x0000,0x0878,0x0000,0x0878,0x0000,0x087c,0x0000,0x087c,0x0000,0x087c,0x0000,0x087c,0x0000,0x087c,0x0000,0x087c,0x0000,0x087c,0x0000,0x087c,0x0000,0x0880,0x0000,0x0880,0x0000,0x0880,0x0000,0x0880,0x0000,0x0880,0x0000,0x0880,0x0000,0x0880,0x0000,0x0880,0x0000,0x0884,0x0000,0x0884,0x0000,0x0884,0x0000,0x0884,0x0000,0x0884,0x0000,0x0884,0x0000,0x0884,0x0000,0x0884,0x0000,0x0898,0x089c,0x0000,0x0000,0x08a0,0x08a4,0x0000,0x0000,0x0d51,0x0d61,0x0000,0x0000,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08a8,0x0000,0x08ac,0x0000,0x08ac,0x0000,0x08ac,0x0000,0x08ac,0x0000,0x08ac,0x0000,0x08ac,0x0000,0x08ac,0x0000,0x08ac,0x08b0,0x08b4,0x08b8,0x08bc,0x08c0,0x0000,0x08c4,0x0000,0x08c8,0x0000,0x08cc,0x0000,0x08d0,0x08d4,0x0000,0x0000,0x08d8,0x08dc,0x0000,0x0000,0x08e0,0x08e4,0x0000,0x0000,0x08e8,0x08ec,0x0000,0x0000,0x08f0,0x08f4,0x08f8,0x08fc,0x0900,0x0904,0x0908,0x090c,0x0910,0x0914,0x0918,0x091c,0x0920,0x0924,0x0928,0x0000,0x092c,0x0930,0x0934,0x0938,0x093c,0x0940,0x0944,0x0948,0x094c,0x0950,0x0954,0x0958,0x095c,0x0960,0x0964,0x0968,0x0000,0x099c,0x0000,0x0000,0x0000,0x09a0,0x0000,0x0000,0x09a4,0x09a8,0x09a4,0x09a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x09c0,0x0000,0x0000,0x0000,0x09c4,0x0000,0x0000,0x0000,0x09c8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x09cc,0x0000,0x0000,0x0000,0x09d0,0x0000,0x0000,0x0000,0x09d4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x09d8,0x0000,0x09dc,0x0000,0x0000,0x0000,0x0000,0x0000,0x09e0,0x0000,0x09e4,0x1540,0x0df1,0x0000,0x0e01,0x0000,0x09f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x09f8,0x0000,0x09f8,0x0000,0x09f8,0x0000,0x09f8,0x0000,0x09f8,0x0000,0x09f8,0x0000,0x09f8,0x0000,0x09f8,0x1544,0x0e15,0x0000,0x0e25,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x09fc,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a00,0x0000,0x0a04,0x0000,0x0a08,0x0000,0x0a0c,0x0000,0x0a10,0x0a14,0x0a18,0x0a14,0x0a18,0x0000,0x0000,0x0000,0x0000,0x0e49,0x232d,0x21e9,0x233d,0x0a28,0x0000,0x0a2c,0x0000,0x0a30,0x0000,0x0a34,0x0000,0x1614,0x0000,0x1618,0x0a38,0x161c,0x0a3c,0x1624,0x0a40,0x0e49,0x232d,0x21f9,0x233d,0x0a44,0x0a48,0x0a4c,0x0a50,0x0000,0x0a58,0x0000,0x0a58,0x0000,0x0a58,0x0000,0x0a58,0x0000,0x0a58,0x0000,0x0a58,0x0000,0x0a58,0x0000,0x0a58,0x0a5c,0x0a60,0x0000,0x0000,0x0000,0x0a64,0x0000,0x0a68,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0a84,0x0000,0x0ac0,0x0ac4,0x0ac8,0x0acc,0x0000,0x0acc,0x0000,0x0acc,0x0000,0x0acc,0x0000,0x0acc,0x0000,0x0acc,0x0000,0x0acc,0x0000,0x0acc,0x0000,0x0000,0x0000,0x0000,0x0ea1,0x0af0,0x0000,0x0af0,0x0000,0x0af0,0x0000,0x0af0,0x0000,0x0af0,0x0000,0x0af0,0x0000,0x0af0,0x0000,0x0af0,0x0000,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b0c,0x0000,0x0b5c,0x0000,0x0000,0x0000,0x0b60,0x0000,0x0000,0x0000,0x0b64,0x0000,0x0000,0x0000,0x0b68,0x0000,0x0000,0x0000,0x0b78,0x0000,0x0000,0x0000,0x0b7c,0x0000,0x0000,0x0000,0x0b80,0x0000,0x0000,0x0000,0x0b84,0x0000,0x0000,0x0000,0x0b88,0x0000,0x0000,0x0000,0x0b8c,0x0000,0x0000,0x0000,0x0b90,0x0000,0x0000,0x0000,0x0b94,0x0000,0x0000,0x0000,0x0ef5,0x0000,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0b98,0x0000,0x0000,0x0b9c,0x0000,0x0000,0x0000,0x0ba0,0x0000,0x0000,0x0000,0x0ba4,0x0000,0x0000,0x0000,0x0ba8,0x0000,0x0000,0x0000,0x0bac,0x0000,0x0000,0x0000,0x0bb0,0x0000,0x0000,0x0000,0x0bb4,0x0000,0x0000,0x0000,0x0bb8,0x0000,0x0000,0x0000,0x0bbc,0x0000,0x0000,0x0000,0x0bc0,0x0000,0x0000,0x0000,0x0bc4,0x0000,0x0000,0x0000,0x0bc8,0x0000,0x0000,0x0000,0x0bcc,0x0000,0x0000,0x0000,0x0bd0,0x0000,0x0000,0x0000,0x0bd4,0x0000,0x0000,0x0000,0x0bd8,0x0000,0x0000,0x0000,0x0bdc,0x0000,0x0000,0x0000,0x0be0,0x0000,0x0000,0x0000,0x0f51,0x26c9,0x26a9,0x0be4,0x0000,0x0be4,0x0000,0x0be4,0x0000,0x0be4,0x0000,0x0be4,0x0000,0x0be4,0x0000,0x0be4,0x0000,0x0be4,0x0000,0x0000,0x0f51,0x26d9,0x26b9,0x0f69,0x0000,0x0000,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0be8,0x0000,0x0000,0x0bec,0x0000,0x0000,0x0000,0x0bf0,0x0000,0x0000,0x0000,0x0bf4,0x0000,0x0000,0x0000,0x0bf8,0x0000,0x0000,0x0000,0x0bfc,0x0000,0x0000,0x0000,0x0c00,0x0000,0x0000,0x0000,0x0c04,0x0000,0x0000,0x0000,0x0f99,0x0000,0x0000,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0c0c,0x0c10,0x0000,0x0fad,0x0000,0x0000,0x0c14,0x0c18,0x0c14,0x0c18,0x0c14,0x0c18,0x0c14,0x0c18,0x0c14,0x0c18,0x0c14,0x0c18,0x0c14,0x0c18,0x0c14,0x0c18,0x0000,0x0fc2,0x0000,0x0000,0x0c1c,0x0c20,0x0c1c,0x0c20,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c24,0x0000,0x0000,0x0000,0x0c28,0x0000,0x0000,0x0000,0x0c2c,0x0000,0x0000,0x0000,0x0fda,0x0000,0x0000,0x0c30,0x0c34,0x0c30,0x0c34,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c38,0x0000,0x0000,0x0000,0x0c3c,0x0000,0x0000,0x0000,0x0c40,0x0000,0x0000,0x0000,0x0c44,0x0000,0x0000,0x0000,0x0c48,0x0000,0x0000,0x0000,0x0c4c,0x0000,0x0000,0x0000,0x0c50,0x0000,0x0000,0x0000,0x0c54,0x0000,0x0000,0x0000,0x0c58,0x0000,0x0000,0x0000,0x0c5c,0x2a8d,0x0000,0x0000,0x0c60,0x2a9d,0x0000,0x0000,0x0c64,0x2aad,0x0000,0x0000,0x0c68,0x2abd,0x0000,0x0000,0x0c6c,0x0000,0x0000,0x1a5b,0x1a5f,0x1a63,0x1a67,0x1a6b,0x1a6f,0x1a73,0x1a77,0x1a7b,0x1a7f,0x1a83,0x1a87,0x1a8b,0x1a97,0x1aa3,0x1aaf,0x0000,0x0000,0x0000,0x1abb,0x0000,0x0000,0x1ac7,0x1ad3,0x1ad7,0x1ae3,0x1aef,0x0000,0x1afb,0x1aff,0x1b03,0x0000,0x1b07,0x1b0b,0x1b0f,0x1b13,0x1b17,0x1b1b,0x0000,0x0000,0x1b1f,0x1b23,0x1b27,0x1b3b,0x1b3f,0x1b5b,0x1b77,0x1b93,0x1baf,0x1bb3,0x1bb7,0x1bbb,0x1bbf,0x1bc3,0x1bc7,0x1bd3,0x1bd7,0x1bdb,0x1bdf,0x1be3,0x1be7,0x1beb,0x1bef,0x1bf3,0x1bf7,0x1bfb,0x0000,0x0000,0x0000,0x1c07,0x1c13,0x1c1f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x272f,0x2753,0x2777,0x2783,0x0000,0x0000,0x0000,0x0000,0x1c2b,0x1c37,0x1c43,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2827,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c5f,0x1c6b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c77,0x0000,0x1c93,0x0000,0x1caf,0x1ccb,0x1ce7,0x1d03,0x0000,0x0000,0x1d1f,0x1d2b,0x1d37,0x1d43,0x1d4f,0x1d5b,0x1d67,0x1d73,0x1d7f,0x1d8b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d97,0x1da3,0x1daf,0x1dbb,0x1dc7,0x1dd3,0x1ddf,0x1deb,0x1df7,0x1e03,0x278f,0x27f3,0x0000,0x0000,0x2833,0x283f,0x1e0f,0x1e1b,0x1e27,0x1e33,0x1e3f,0x1e4b,0x1e57,0x1e63,0x1e6f,0x1e7b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x235b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e17,0x111b,0x122f,0x1233,0x1237,0x123b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x203f,0x204b,0x0000,0x208f,0x20ab,0x2077,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x111e,0x0000,0x0000,0x0c70,0x0c70,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x154e,0x112e,0x134a,0x0000,0x0000,0x0000,0x2cae,0x1a5b,0x1a5f,0x1a63,0x1a67,0x1a6b,0x1a6f,0x1a73,0x1a77,0x1a7b,0x1a7f,0x1a83,0x1a87,0x1a8b,0x1a97,0x1aa3,0x1aaf,0x0000,0x0000,0x0000,0x1abb,0x0000,0x0000,0x1ac7,0x1ad3,0x1ad7,0x1ae3,0x1aef,0x0000,0x1afb,0x1aff,0x1b03,0x0000,0x1b07,0x1b0b,0x1b0f,0x1b13,0x1b17,0x1b1b,0x0000,0x0000,0x1b1f,0x1b23,0x1b27,0x1b3b,0x1b3f,0x1b5b,0x1b77,0x1b93,0x1baf,0x1bb3,0x1bb7,0x1bbb,0x1bbf,0x1bc3,0x1bc7,0x1bd3,0x1bd7,0x1bdb,0x1bdf,0x1be3,0x1be7,0x1beb,0x1bef,0x1bf3,0x1bf7,0x1bfb,0x0000,0x0000,0x0000,0x1c07,0x1c13,0x1c1f,0x0000,0x2b1b,0x0000,0x2b7f,0x0000,0x0000,0x0000,0x0000,0x272f,0x2753,0x2777,0x2783,0x0000,0x0000,0x0000,0x0000,0x1c2b,0x1c37,0x1c43,0x0000,0x2be3,0x0000,0x2c17,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c7b,0x0000,0x0000,0x0000,0x0000,0x0000,0x2827,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c5f,0x1c6b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c77,0x0000,0x1c93,0x0000,0x1caf,0x1ccb,0x1ce7,0x1d03,0x0000,0x0000,0x1d1f,0x1d2b,0x1d37,0x1d43,0x1d4f,0x1d5b,0x1d67,0x1d73,0x1d7f,0x1d8b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d97,0x1da3,0x1daf,0x1dbb,0x1dc7,0x1dd3,0x1ddf,0x1deb,0x1df7,0x1e03,0x278f,0x27f3,0x0000,0x0000,0x2833,0x283f,0x1e0f,0x1e1b,0x1e27,0x1e33,0x1e3f,0x1e4b,0x1e57,0x1e63,0x1e6f,0x1e7b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x235b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e17,0x111b,0x122f,0x1233,0x1237,0x123b,0x28bb,0x28d7,0x28f3,0x290f,0x292b,0x2947,0x2963,0x297f,0x299b,0x29b7,0x29d3,0x29ef,0x2a0b,0x2a27,0x2a43,0x2a5f,0x0000,0x0000,0x203f,0x204b,0x0000,0x208f,0x20ab,0x2077,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c74,0x0000,0x0000,0x0000,0x0c78,0x0000,0x0000,0x0000,0x0c7c,0x0000,0x0000,0x0000,0x0c80,0x0000,0x0000,0x1e87,0x1e93,0x1e9f,0x0000,0x1eab,0x1eb7,0x1ec3,0x0000,0x1ecf,0x1ed3,0x1ed7,0x1edb,0x1edf,0x1ee3,0x1ee7,0x1eeb,0x0000,0x0000,0x0000,0x0000,0x1eef,0x1f13,0x1f37,0x1f4f,0x1f5b,0x1f67,0x0000,0x0000,0x0000,0x1f73,0x0000,0x0000,0x1f7f,0x1f8b,0x1f97,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44fb,0x4517,0x4533,0x454f,0x0000,0x0000,0x0000,0x0000,0x1faf,0x1fbb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1fc7,0x1fcb,0x1fd7,0x0000,0x1fdb,0x0000,0x1fdf,0x0000,0x0000,0x0000,0x1feb,0x1ff7,0x2003,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x200f,0x201b,0x2027,0x2033,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2367,0x2373,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x133f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2083,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1342,0x0000,0x0000,0x0c84,0x0c84,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e87,0x1e93,0x1e9f,0x0000,0x1eab,0x1eb7,0x1ec3,0x0000,0x1ecf,0x1ed3,0x1ed7,0x1edb,0x1edf,0x1ee3,0x1ee7,0x1eeb,0x0000,0x0000,0x0000,0x0000,0x1eef,0x1f13,0x1f43,0x1f4f,0x1f5b,0x1f67,0x0000,0x0000,0x0000,0x1f73,0x0000,0x0000,0x1f7f,0x1f8b,0x1fa3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44fb,0x4517,0x4533,0x454f,0x0000,0x0000,0x0000,0x0000,0x1faf,0x1fbb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1fc7,0x1fcb,0x1fd7,0x0000,0x1fdb,0x0000,0x1fdf,0x0000,0x0000,0x0000,0x1feb,0x1ff7,0x2003,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x200f,0x201b,0x2027,0x2033,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2367,0x2373,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x133f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2083,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x154b,0x166f,0x1693,0x16d7,0x170b,0x170f,0x1713,0x174f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1783,0x1787,0x178b,0x178f,0x17b3,0x17b7,0x17bb,0x17bf,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x41db,0x420f,0x0000,0x4243,0x4277,0x42ab,0x42df,0x0000,0x0000,0x4313,0x4347,0x0000,0x0000,0x0000,0x0000,0x17c3,0x17e7,0x17eb,0x17ef,0x17f3,0x17f7,0x17fb,0x17ff,0x1803,0x1807,0x180b,0x180f,0x1813,0x1817,0x181b,0x181f,0x1823,0x1827,0x182b,0x182f,0x1833,0x1837,0x183b,0x183f,0x1843,0x1847,0x184b,0x184f,0x1853,0x1857,0x185b,0x1873,0x1877,0x187b,0x188f,0x18a3,0x18b7,0x18bb,0x18bf,0x18c3,0x0000,0x0000,0x0000,0x0000,0x18cf,0x18d3,0x18d7,0x18f7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x43af,0x43c3,0x43f7,0x445f,0x0000,0x0000,0x0000,0x0000,0x437b,0x44c7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18fb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x191f,0x0000,0x1923,0x192f,0x194b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x194f,0x1953,0x1957,0x195b,0x195f,0x1963,0x1967,0x1973,0x1987,0x198b,0x198f,0x1993,0x1997,0x199b,0x199f,0x19a3,0x19a7,0x19ab,0x19af,0x19b3,0x19b7,0x19bb,0x19bf,0x19c3,0x19d7,0x19db,0x19e7,0x19df,0x19e3,0x19eb,0x19ef,0x19f3,0x19f7,0x1a0b,0x1a0f,0x1a13,0x1a17,0x1a1b,0x1a1f,0x1a23,0x1a3f,0x1a43,0x1a47,0x1a4b,0x1a4f,0x1a53,0x1a57,0x0000,0x0c88,0x0c8c,0x164d,0x165d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x154b,0x166f,0x1693,0x16d7,0x170b,0x170f,0x1713,0x174f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1783,0x1787,0x178b,0x178f,0x17b3,0x17b7,0x17bb,0x17bf,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x41db,0x420f,0x0000,0x4243,0x4277,0x42ab,0x42df,0x0000,0x0000,0x4313,0x4347,0x0000,0x0000,0x0000,0x0000,0x17c3,0x17e7,0x17eb,0x17ef,0x17f3,0x17f7,0x17fb,0x17ff,0x1803,0x1807,0x180b,0x180f,0x1813,0x1817,0x181b,0x181f,0x1823,0x1827,0x182b,0x182f,0x1833,0x1837,0x183b,0x183f,0x1843,0x1847,0x184b,0x184f,0x1853,0x1857,0x1867,0x1873,0x1877,0x187b,0x188f,0x18a3,0x18b7,0x18bb,0x18bf,0x18c3,0x0000,0x0000,0x0000,0x0000,0x18cf,0x18d3,0x18e3,0x18f7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x43af,0x43c3,0x4413,0x447b,0x0000,0x0000,0x0000,0x0000,0x437b,0x44c7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18fb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x191f,0x0000,0x1923,0x192f,0x194b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x194f,0x1953,0x1957,0x195b,0x195f,0x1963,0x1967,0x1973,0x1987,0x198b,0x198f,0x1993,0x1997,0x199b,0x199f,0x19a3,0x19a7,0x19ab,0x19af,0x19b3,0x19b7,0x19bb,0x19bf,0x19c3,0x19d7,0x19db,0x19e7,0x19df,0x19e3,0x19eb,0x19ef,0x19f3,0x19f7,0x1a0b,0x1a0f,0x1a13,0x1a17,0x1a1b,0x1a1f,0x1a23,0x1a3f,0x1a43,0x1a47,0x1a4b,0x1a4f,0x1a53,0x1a57,0x0000,0x0c90,0x0c94,0x0c90,0x0c94,0x0c90,0x0c94,0x0c90,0x0c94,0x0c90,0x0c94,0x0c90,0x0c94,0x0c90,0x0c94,0x0c90,0x0c94,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0c98,0x0c9c,0x0ca0,0x0ca4,0x1671,0x1681,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0ca8,0x0cac,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x0cb0,0x0cb4,0x1695,0x16b5,0x0ccc,0x16ce,0x16a6,0x16ae,0x16a6,0x16ae,0x16a6,0x16ae,0x16a6,0x16ae,0x16a6,0x16ae,0x16a6,0x16ae,0x16a6,0x16ae,0x16a6,0x16ae,0x0cb8,0x0cb8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0cbc,0x0cbc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x16c6,0x0000,0x0cc0,0x0cc0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0cc4,0x0cc4,0x0cc8,0x0cc8,0x0000,0x0000,0x0000,0x0000,0x16d9,0x16f1,0x0000,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x16ea,0x0000,0x0cd0,0x0cd0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1702,0x0000,0x1702,0x0000,0x1702,0x0000,0x1702,0x0000,0x1702,0x0000,0x1702,0x0000,0x1702,0x0000,0x1702,0x0000,0x0cd4,0x0cd4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0cd8,0x0cdc,0x0000,0x0000,0x0ce0,0x0ce4,0x0000,0x0000,0x1715,0x1735,0x0cf4,0x0000,0x1726,0x172e,0x1726,0x172e,0x1726,0x172e,0x1726,0x172e,0x1726,0x172e,0x1726,0x172e,0x1726,0x172e,0x1726,0x172e,0x0ce8,0x0ce8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0cec,0x0cec,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1746,0x0000,0x1746,0x0000,0x1746,0x0000,0x1746,0x0000,0x1746,0x0000,0x1746,0x0000,0x1746,0x0000,0x1746,0x0000,0x0cf0,0x0cf0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1751,0x1769,0x0000,0x0000,0x1762,0x0000,0x1762,0x0000,0x1762,0x0000,0x1762,0x0000,0x1762,0x0000,0x1762,0x0000,0x1762,0x0000,0x1762,0x0000,0x0cf8,0x0cf8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x177a,0x0000,0x177a,0x0000,0x177a,0x0000,0x177a,0x0000,0x177a,0x0000,0x177a,0x0000,0x177a,0x0000,0x177a,0x0000,0x0cfc,0x0cfc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0d00,0x0d04,0x0000,0x0000,0x0d08,0x0d0c,0x0000,0x0000,0x0000,0x0000,0x0d10,0x0d14,0x1791,0x17a1,0x0000,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d18,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0d1c,0x0000,0x0000,0x0000,0x0d20,0x0d24,0x0000,0x0000,0x0d28,0x0d2c,0x0d30,0x0d34,0x0000,0x0000,0x0d38,0x0d3c,0x0000,0x0000,0x17c5,0x17d5,0x0000,0x0000,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d40,0x0000,0x0d44,0x0000,0x0d44,0x0000,0x0d44,0x0000,0x0d44,0x0000,0x0d44,0x0000,0x0d44,0x0000,0x0d44,0x0000,0x0d44,0x0d48,0x0d4c,0x0d50,0x0d54,0x0d58,0x0000,0x0d5c,0x0000,0x0d60,0x0000,0x0d64,0x0000,0x0d68,0x0d6c,0x0000,0x0000,0x0d70,0x0d74,0x0000,0x0000,0x0d78,0x0d7c,0x0000,0x0000,0x0d80,0x0d84,0x0000,0x0000,0x0d88,0x0d8c,0x0d90,0x0d94,0x0d98,0x0d9c,0x0da0,0x0da4,0x0da8,0x0dac,0x0db0,0x0db4,0x0db8,0x0dbc,0x0dc0,0x0000,0x0dc4,0x0dc8,0x0dcc,0x0dd0,0x0dd4,0x0dd8,0x0ddc,0x0de0,0x0de4,0x0de8,0x0dec,0x0df0,0x0df4,0x0df8,0x0dfc,0x0e00,0x0000,0x0e04,0x0000,0x0000,0x0000,0x0e08,0x0000,0x0000,0x0000,0x0e0c,0x0000,0x0000,0x0000,0x0e10,0x0000,0x0000,0x0000,0x0e14,0x0000,0x0000,0x0000,0x0e18,0x0000,0x0000,0x0000,0x0e1c,0x0000,0x0000,0x0000,0x0e20,0x0000,0x0000,0x0000,0x0e24,0x0000,0x0000,0x0000,0x0e28,0x0000,0x0000,0x0000,0x0e2c,0x0000,0x0000,0x0000,0x0e30,0x0000,0x0000,0x0000,0x0e34,0x0000,0x0000,0x0000,0x0e38,0x0000,0x0000,0x0000,0x185e,0x0000,0x0000,0x0e3c,0x0e3c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x186a,0x0000,0x0000,0x0e3c,0x0e40,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0e44,0x0e48,0x0000,0x0000,0x0e4c,0x0e50,0x0e54,0x0000,0x187d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0e58,0x0000,0x0000,0x0000,0x0e5c,0x0000,0x0000,0x0000,0x0e60,0x0000,0x0000,0x0000,0x1891,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0e64,0x0000,0x0000,0x0000,0x0e68,0x0000,0x0000,0x0000,0x0e6c,0x0000,0x0000,0x0000,0x18a5,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0e70,0x0000,0x0e74,0x0000,0x0000,0x0000,0x0000,0x0000,0x0e78,0x0000,0x0e7c,0x0000,0x0e80,0x0000,0x0000,0x0000,0x0e84,0x0000,0x0000,0x0000,0x0e88,0x0000,0x0000,0x18c6,0x0000,0x0000,0x0000,0x0e8c,0x0e8c,0x0e90,0x0e90,0x0000,0x0000,0x0000,0x0000,0x0000,0x0e94,0x0000,0x0e98,0x0000,0x0e9c,0x0000,0x0ea0,0x0000,0x18da,0x18ee,0x0000,0x0ea4,0x0ea4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18e6,0x18ee,0x0000,0x0ea4,0x0ea8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0eac,0x0eac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0eb0,0x0eb4,0x0000,0x18fd,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x190e,0x0000,0x1916,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0eb8,0x0eb8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0ebc,0x0ebc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0ec0,0x0ec4,0x0ec8,0x0ecc,0x0000,0x1926,0x0000,0x0000,0x0ed0,0x0ed0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1931,0x0000,0x0000,0x0000,0x1942,0x0000,0x1942,0x0000,0x1942,0x0000,0x1942,0x0000,0x1942,0x0000,0x1942,0x0000,0x1942,0x0000,0x1942,0x0ed4,0x0ed4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0ed8,0x0edc,0x0000,0x0000,0x0000,0x0ee0,0x0000,0x0ee4,0x0000,0x0ee8,0x0000,0x0000,0x0000,0x0eec,0x0000,0x0000,0x0000,0x0ef0,0x0000,0x0000,0x0000,0x0ef4,0x0000,0x0000,0x0000,0x0ef8,0x0000,0x0000,0x0000,0x196a,0x0000,0x0000,0x0efc,0x0efc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1975,0x0000,0x0000,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f00,0x0000,0x0f04,0x0000,0x0000,0x0000,0x0f08,0x0000,0x0000,0x0000,0x0f0c,0x0000,0x0000,0x0000,0x0f10,0x0000,0x0000,0x0000,0x0f14,0x0000,0x0000,0x0000,0x0f18,0x0000,0x0000,0x0000,0x0f1c,0x0000,0x0000,0x0000,0x0f20,0x0000,0x0000,0x0000,0x0f24,0x0000,0x0000,0x0000,0x0f28,0x0000,0x0000,0x0000,0x0f2c,0x0000,0x0000,0x0000,0x0f30,0x0000,0x0000,0x0000,0x0f34,0x0000,0x0000,0x0000,0x0f38,0x0000,0x0000,0x0000,0x0f3c,0x0f40,0x0f44,0x0000,0x19c5,0x0000,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0f48,0x0000,0x0000,0x0f4c,0x0000,0x0000,0x0000,0x0f50,0x0000,0x0000,0x0000,0x0f54,0x0000,0x0000,0x0000,0x0f58,0x0000,0x0000,0x0000,0x0f5c,0x0000,0x0000,0x0000,0x0f60,0x0000,0x0000,0x0000,0x0f64,0x0000,0x0000,0x0000,0x0f68,0x0000,0x0000,0x0000,0x0000,0x0000,0x19f9,0x0f6c,0x0000,0x0f6c,0x0000,0x0f6c,0x0000,0x0f6c,0x0000,0x0f6c,0x0000,0x0f6c,0x0000,0x0f6c,0x0000,0x0f6c,0x0000,0x0000,0x0f70,0x0000,0x0000,0x0000,0x0f74,0x0000,0x0000,0x0000,0x0f78,0x0000,0x0000,0x0000,0x0f7c,0x0000,0x0000,0x0000,0x0f80,0x0000,0x0000,0x0000,0x0f84,0x0000,0x0000,0x0000,0x1a25,0x0000,0x0000,0x0000,0x1a36,0x0000,0x1a36,0x0000,0x1a36,0x0000,0x1a36,0x0000,0x1a36,0x0000,0x1a36,0x0000,0x1a36,0x0000,0x1a36,0x0f88,0x0f88,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0f8c,0x0000,0x0000,0x0000,0x0f90,0x0000,0x0000,0x0000,0x0f94,0x0000,0x0000,0x0000,0x0f98,0x0000,0x0000,0x0000,0x0f9c,0x0000,0x0000,0x0000,0x0fa0,0x0000,0x0000,0x0000,0x0fa4,0x0000,0x0000,0x0000,0x0fa8,0x0000,0x0000,0x0000,0x0fac,0x0000,0x0000,0x0000,0x0fb0,0x0000,0x0000,0x0000,0x0fb4,0x0000,0x0000,0x0000,0x0fb8,0x0000,0x0000,0x0000,0x0fbc,0x0000,0x0000,0x0000,0x0fc0,0x0000,0x0000,0x0000,0x0fc4,0x0000,0x0000,0x0000,0x0fc8,0x0000,0x0000,0x0000,0x0fcc,0x0000,0x0000,0x0000,0x0fd0,0x0000,0x0000,0x0000,0x0fd4,0x0000,0x0000,0x0000,0x1a8e,0x0000,0x0000,0x0fd8,0x0000,0x0fd8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1a9a,0x0000,0x0000,0x0fdc,0x0000,0x0fdc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1aa6,0x0000,0x0000,0x0fe0,0x0000,0x0fe0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ab2,0x0000,0x0000,0x0fe4,0x0000,0x0fe4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1abe,0x0000,0x0000,0x0fe8,0x0000,0x0fe8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1aca,0x0000,0x0000,0x0000,0x0000,0x0fec,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0ff0,0x0000,0x0000,0x0000,0x1ada,0x0000,0x0000,0x0ff4,0x0000,0x0ff4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ae6,0x0000,0x0000,0x0000,0x0000,0x0ff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1af2,0x0000,0x0000,0x0000,0x0000,0x0ffc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1000,0x0000,0x0000,0x0000,0x1004,0x0000,0x0000,0x0000,0x1008,0x0000,0x0000,0x0000,0x100c,0x0000,0x0000,0x0000,0x1010,0x0000,0x0000,0x0000,0x1014,0x0000,0x0000,0x0000,0x1018,0x0000,0x0000,0x0000,0x101c,0x0000,0x0000,0x0000,0x1020,0x0000,0x0000,0x0000,0x1024,0x0000,0x0000,0x0000,0x1028,0x0000,0x0000,0x0000,0x1b29,0x0000,0x0000,0x102c,0x0000,0x102c,0x0000,0x102c,0x0000,0x102c,0x0000,0x102c,0x0000,0x102c,0x0000,0x102c,0x0000,0x102c,0x0000,0x0000,0x1030,0x0000,0x0000,0x0000,0x1b41,0x0000,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1b52,0x0000,0x1034,0x0000,0x1034,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1b5d,0x0000,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1b6e,0x0000,0x1038,0x0000,0x1038,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1b79,0x0000,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x1b8a,0x0000,0x103c,0x0000,0x103c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1b95,0x0000,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1ba6,0x0000,0x1040,0x0000,0x1040,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1044,0x0000,0x0000,0x0000,0x1048,0x0000,0x0000,0x0000,0x104c,0x0000,0x0000,0x0000,0x1050,0x0000,0x0000,0x0000,0x1054,0x0000,0x0000,0x0000,0x1058,0x0000,0x0000,0x0000,0x1bca,0x0000,0x0000,0x0000,0x0000,0x105c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1060,0x0000,0x0000,0x0000,0x1064,0x0000,0x0000,0x0000,0x1068,0x0000,0x0000,0x0000,0x106c,0x0000,0x0000,0x0000,0x1070,0x0000,0x0000,0x0000,0x1074,0x0000,0x0000,0x0000,0x1078,0x0000,0x0000,0x0000,0x107c,0x0000,0x0000,0x0000,0x1080,0x0000,0x0000,0x0000,0x1084,0x0000,0x0000,0x0000,0x1bfe,0x0000,0x0000,0x1088,0x1088,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c0a,0x0000,0x0000,0x108c,0x1090,0x108c,0x1090,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c16,0x0000,0x0000,0x1094,0x0000,0x1094,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c22,0x0000,0x0000,0x1098,0x109c,0x1098,0x109c,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c2e,0x0000,0x0000,0x10a0,0x0000,0x10a0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c3a,0x0000,0x0000,0x10a4,0x0000,0x10a4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c45,0x0000,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x1c56,0x0000,0x0000,0x0000,0x10a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c62,0x0000,0x0000,0x10ac,0x0000,0x10ac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c6e,0x0000,0x0000,0x10b0,0x0000,0x10b0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c79,0x0000,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x1c8a,0x0000,0x10b4,0x10b8,0x10b4,0x10b8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c95,0x0000,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x1ca6,0x0000,0x10bc,0x10c0,0x10bc,0x10c0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1cb1,0x0000,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x1cc2,0x0000,0x10c4,0x10c8,0x10c4,0x10c8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ccd,0x0000,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x1cde,0x0000,0x10cc,0x10d0,0x10cc,0x10d0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ce9,0x0000,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x1cfa,0x0000,0x10d4,0x10d8,0x10d4,0x10d8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d05,0x0000,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x1d16,0x0000,0x10dc,0x10e0,0x10dc,0x10e0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d22,0x0000,0x0000,0x10e4,0x10e8,0x10e4,0x10e8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d2e,0x0000,0x0000,0x10ec,0x10f0,0x10ec,0x10f0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d3a,0x0000,0x0000,0x10f4,0x10f8,0x10f4,0x10f8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d46,0x0000,0x0000,0x10fc,0x1100,0x10fc,0x1100,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d52,0x0000,0x0000,0x1104,0x1108,0x1104,0x1108,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d5e,0x0000,0x0000,0x110c,0x1110,0x110c,0x1110,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d6a,0x0000,0x0000,0x1114,0x1118,0x1114,0x1118,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d76,0x0000,0x0000,0x111c,0x1120,0x111c,0x1120,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d82,0x0000,0x0000,0x1124,0x1128,0x1124,0x1128,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d8e,0x0000,0x0000,0x112c,0x1130,0x112c,0x1130,0x0000,0x0000,0x0000,0x0000,0x0000,0x1d9a,0x0000,0x0000,0x1134,0x1138,0x1134,0x1138,0x0000,0x0000,0x0000,0x0000,0x0000,0x1da6,0x0000,0x0000,0x113c,0x1140,0x113c,0x1140,0x0000,0x0000,0x0000,0x0000,0x0000,0x1db2,0x0000,0x0000,0x1144,0x1148,0x1144,0x1148,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dbe,0x0000,0x0000,0x114c,0x1150,0x114c,0x1150,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dca,0x0000,0x0000,0x1154,0x1158,0x1154,0x1158,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dd6,0x0000,0x0000,0x115c,0x1160,0x115c,0x1160,0x0000,0x0000,0x0000,0x0000,0x0000,0x1de2,0x0000,0x0000,0x1164,0x1168,0x1164,0x1168,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dee,0x0000,0x0000,0x116c,0x1170,0x116c,0x1170,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dfa,0x0000,0x0000,0x1174,0x1178,0x1174,0x1178,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e06,0x0000,0x0000,0x117c,0x1180,0x117c,0x1180,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e12,0x0000,0x0000,0x1184,0x1188,0x1184,0x1188,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e1e,0x0000,0x0000,0x118c,0x1190,0x118c,0x1190,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e2a,0x0000,0x0000,0x1194,0x1198,0x1194,0x1198,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e36,0x0000,0x0000,0x119c,0x11a0,0x119c,0x11a0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e42,0x0000,0x0000,0x11a4,0x11a8,0x11a4,0x11a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e4e,0x0000,0x0000,0x11ac,0x11b0,0x11ac,0x11b0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e5a,0x0000,0x0000,0x11b4,0x11b8,0x11b4,0x11b8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e66,0x0000,0x0000,0x11bc,0x11c0,0x11bc,0x11c0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e72,0x0000,0x0000,0x11c4,0x11c8,0x11c4,0x11c8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e7e,0x0000,0x0000,0x11cc,0x11d0,0x11cc,0x11d0,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e8a,0x0000,0x0000,0x0000,0x0000,0x0000,0x11d4,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e96,0x0000,0x0000,0x0000,0x0000,0x0000,0x11d8,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ea2,0x0000,0x0000,0x11dc,0x0000,0x11dc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1eae,0x0000,0x0000,0x11e0,0x0000,0x11e0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1eba,0x0000,0x0000,0x11e4,0x0000,0x11e4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ec6,0x0000,0x0000,0x0000,0x0000,0x11e8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x11ec,0x0000,0x0000,0x0000,0x11f0,0x0000,0x0000,0x0000,0x11f4,0x0000,0x0000,0x0000,0x11f8,0x0000,0x0000,0x0000,0x11fc,0x0000,0x0000,0x0000,0x1200,0x0000,0x0000,0x0000,0x1204,0x0000,0x0000,0x0000,0x1208,0x0000,0x0000,0x0000,0x1ef1,0x0000,0x0000,0x1f02,0x1f0a,0x1f02,0x1f0a,0x1f02,0x1f0a,0x1f02,0x1f0a,0x1f02,0x1f0a,0x1f02,0x1f0a,0x1f02,0x1f0a,0x1f02,0x1f0a,0x120c,0x120c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1210,0x1210,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f15,0x0000,0x0000,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1f26,0x1f2e,0x1214,0x1214,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1218,0x1218,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f3a,0x0000,0x0000,0x121c,0x121c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f46,0x0000,0x0000,0x121c,0x1220,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f52,0x0000,0x0000,0x1224,0x1224,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f5e,0x0000,0x0000,0x0000,0x0000,0x1228,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f6a,0x0000,0x0000,0x0000,0x0000,0x122c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f76,0x0000,0x0000,0x1230,0x0000,0x1230,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f82,0x0000,0x0000,0x1234,0x1234,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f8e,0x0000,0x0000,0x1238,0x1238,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f9a,0x0000,0x0000,0x123c,0x123c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1fa6,0x0000,0x0000,0x123c,0x1240,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1fb2,0x0000,0x0000,0x0000,0x0000,0x1244,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1fbe,0x0000,0x0000,0x0000,0x0000,0x1248,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x124c,0x0000,0x0000,0x0000,0x1fce,0x0000,0x0000,0x1250,0x1250,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1254,0x0000,0x0000,0x0000,0x1258,0x0000,0x0000,0x0000,0x1fe2,0x0000,0x0000,0x0000,0x0000,0x125c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1fee,0x0000,0x0000,0x1260,0x0000,0x1260,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ffa,0x0000,0x0000,0x1264,0x0000,0x1264,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2006,0x0000,0x0000,0x1268,0x0000,0x1268,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2012,0x0000,0x0000,0x126c,0x126c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x201e,0x0000,0x0000,0x1270,0x1270,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x202a,0x0000,0x0000,0x1274,0x1274,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2036,0x0000,0x0000,0x1278,0x1278,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2042,0x0000,0x0000,0x0000,0x127c,0x127c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x204d,0x0000,0x0000,0x0000,0x0000,0x0000,0x205e,0x205e,0x2066,0x2066,0x206e,0x206e,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1280,0x1280,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1284,0x1284,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1288,0x1288,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x207a,0x20b6,0x20c6,0x20be,0x128c,0x128c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2086,0x1290,0x1290,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2092,0x0000,0x20a2,0x209a,0x1294,0x1294,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1298,0x1298,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x129c,0x129c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x20ae,0x12a0,0x12a0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x12a4,0x12a4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x12a8,0x12a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x12ac,0x12ac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x21d9,0x12b0,0x12b4,0x0000,0x12b8,0x12d8,0x12bc,0x12dc,0x12c0,0x12e0,0x12c4,0x12e4,0x12c8,0x12e8,0x12cc,0x12ec,0x12d0,0x12f0,0x12d4,0x12f4,0x12f8,0x1314,0x0000,0x1318,0x12fc,0x20f1,0x1300,0x0000,0x1304,0x20f9,0x1308,0x2101,0x130c,0x2109,0x1310,0x2111,0x131c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1320,0x1324,0x0000,0x0000,0x1328,0x132c,0x0000,0x0000,0x1330,0x1334,0x1338,0x133c,0x1340,0x1344,0x1348,0x0000,0x134c,0x1350,0x1354,0x1358,0x135c,0x1360,0x1364,0x1368,0x136c,0x1370,0x1374,0x1378,0x137c,0x1380,0x1384,0x1388,0x138c,0x13ac,0x1390,0x13b0,0x1394,0x13b4,0x1398,0x13b8,0x139c,0x0000,0x13a0,0x2129,0x13a4,0x0000,0x13a8,0x0000,0x0000,0x13bc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x13c0,0x13d8,0x13c4,0x13dc,0x13c8,0x13e0,0x13cc,0x13e4,0x0000,0x2141,0x13d0,0x13f0,0x0000,0x13f4,0x13d4,0x0000,0x0000,0x0000,0x13e8,0x13ec,0x0000,0x0000,0x0000,0x0000,0x13f8,0x1418,0x13fc,0x141c,0x1400,0x0000,0x1404,0x0000,0x1408,0x1420,0x140c,0x1424,0x1410,0x1428,0x1414,0x142c,0x1430,0x144c,0x1434,0x0000,0x1438,0x1450,0x143c,0x1454,0x1440,0x1458,0x0000,0x145c,0x1444,0x0000,0x1448,0x0000,0x1460,0x1480,0x1464,0x1484,0x1468,0x0000,0x146c,0x2179,0x1470,0x148c,0x1474,0x1490,0x1478,0x1494,0x147c,0x1498,0x0000,0x1488,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x149c,0x0000,0x14a0,0x0000,0x14a4,0x0000,0x14a8,0x0000,0x14ac,0x2191,0x14b0,0x14c0,0x14b4,0x14c4,0x14b8,0x0000,0x14bc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x14cc,0x0000,0x14d0,0x0000,0x0000,0x0000,0x0000,0x0000,0x14cc,0x0000,0x14d0,0x0000,0x16c0,0x16c4,0x16c8,0x16cc,0x04b0,0x04b0,0x21ad,0x04b0,0x04b0,0x04b0,0x04b0,0x14d4,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x21bd,0x04b0,0x04b0,0x14d8,0x14dc,0x04b0,0x04b0,0x04b0,0x04b0,0x0000,0x21c9,0x0000,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e0,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x14e4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x15c4,0x15c4,0x0000,0x14ec,0x14e8,0x15bc,0x0000,0x0000,0x0000,0x1604,0x0000,0x1608,0x0000,0x160c,0x0000,0x1610,0x15c4,0x15c4,0x0000,0x14ec,0x14e8,0x15bc,0x0000,0x0000,0x220d,0x04b0,0x04b0,0x04b0,0x14f0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x04b0,0x0000,0x0000,0x2221,0x0000,0x0000,0x2231,0x0000,0x2239,0x0000,0x2241,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x14f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x14f8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x14fc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x224d,0x224d,0x2265,0x0000,0x0000,0x225d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1500,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2275,0x0000,0x227d,0x0000,0x2285,0x0000,0x228d,0x0000,0x2295,0x0000,0x229d,0x0000,0x0000,0x0000,0x0000,0x1504,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1508,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x150c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1510,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1514,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1518,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x22a9,0x0000,0x0000,0x151c,0x0000,0x151c,0x0000,0x151c,0x0000,0x151c,0x0000,0x151c,0x0000,0x151c,0x0000,0x151c,0x0000,0x151c,0x0000,0x0000,0x22bd,0x0000,0x0000,0x1520,0x0000,0x1520,0x0000,0x1520,0x0000,0x1520,0x0000,0x1520,0x0000,0x1520,0x0000,0x1520,0x0000,0x1520,0x0000,0x071d,0x22d1,0x22e1,0x22f1,0x0000,0x0000,0x0650,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1528,0x1638,0x0000,0x163c,0x0000,0x0000,0x0650,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x154c,0x0000,0x0000,0x1640,0x0000,0x0000,0x0650,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x071d,0x22d1,0x2305,0x22f1,0x0000,0x0000,0x0650,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x154c,0x16d0,0x0000,0x1640,0x0000,0x0000,0x0000,0x0000,0x1550,0x1554,0x1558,0x155c,0x1568,0x156c,0x1574,0x1578,0x157c,0x1580,0x1584,0x1588,0x1568,0x1570,0x1574,0x1578,0x157c,0x1580,0x1584,0x1588,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1620,0x15b8,0x1628,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x15c0,0x0000,0x0000,0x0000,0x15c8,0x0000,0x0000,0x0000,0x15cc,0x0000,0x0000,0x0000,0x15d0,0x0000,0x0000,0x0000,0x235e,0x0000,0x0000,0x15d4,0x0000,0x15d4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x236a,0x0000,0x0000,0x0000,0x15d8,0x0000,0x15d8,0x0000,0x0000,0x0000,0x0000,0x0000,0x2376,0x0000,0x0000,0x0000,0x15dc,0x0000,0x15dc,0x0000,0x0000,0x0000,0x0000,0x35d7,0x0000,0x0000,0x0000,0x34fb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x359f,0x3d5b,0x3d67,0x0000,0x0000,0x3ee7,0x3f03,0x3f1f,0x3867,0x3f53,0x3f6f,0x3d8b,0x0000,0x37bf,0x37cb,0x37d7,0x37f3,0x338f,0x3393,0x3397,0x33a3,0x3553,0x3557,0x355b,0x355f,0x3563,0x3567,0x40a7,0x40b3,0x3593,0x343b,0x321f,0x33c3,0x415f,0x416b,0x0000,0x0000,0x3573,0x3577,0x357b,0x357f,0x3583,0x3587,0x3d2b,0x345b,0x3513,0x3517,0x3523,0x3527,0x3533,0x3537,0x3543,0x3547,0x35af,0x0000,0x3aeb,0x3af7,0x3e53,0x408f,0x407b,0x4067,0x0000,0x0000,0x0000,0x0000,0x40e7,0x40f3,0x4147,0x4153,0x3cf3,0x3cff,0x38bb,0x3d13,0x3f87,0x3f93,0x0000,0x0000,0x3bef,0x3bfb,0x3c07,0x3c23,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3dd3,0x3c9f,0x3b63,0x37b3,0x3b57,0x0000,0x3b4b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x400f,0x401b,0x3833,0x4047,0x0000,0x3d37,0x3d43,0x3d4f,0x3bd7,0x3be3,0x3b6f,0x3b8b,0x3ba7,0x3daf,0x3dbb,0x3dc7,0x0000,0x0000,0x0000,0x3f7b,0x0000,0x0000,0x0000,0x0000,0x38c7,0x3df7,0x380f,0x3cc3,0x0000,0x3d1f,0x0000,0x4053,0x3e1b,0x3e37,0x3ab3,0x3acf,0x0000,0x0000,0x3933,0x393f,0x394b,0x3957,0x3963,0x396f,0x397b,0x3987,0x3993,0x399f,0x3fbf,0x3fdb,0x4177,0x4193,0x0000,0x0000,0x39ab,0x39b7,0x39c3,0x39cf,0x39db,0x39e7,0x39f3,0x39ff,0x3a0b,0x3a17,0x0000,0x0000,0x0000,0x0000,0x3e5f,0x3e6b,0x3a23,0x3a2f,0x3a3b,0x3a47,0x3a53,0x3a5f,0x3a6b,0x3a77,0x3a83,0x3a8f,0x0000,0x0000,0x0000,0x0000,0x3ce7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x247f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e2b,0x0000,0x2f63,0x2f67,0x2f6b,0x2f6f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2482,0x0000,0x0000,0x15e0,0x0000,0x15e0,0x0000,0x15e0,0x0000,0x15e0,0x0000,0x0000,0x2e3e,0x2492,0x2592,0x0000,0x45be,0x48a2,0x0000,0x35d7,0x0000,0x0000,0x0000,0x34fb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x359f,0x3d5b,0x3d67,0x0000,0x0000,0x3ee7,0x3f03,0x3f1f,0x3867,0x3f53,0x3f6f,0x3d8b,0x0000,0x37bf,0x37cb,0x37d7,0x37f3,0x338f,0x3393,0x3397,0x33a3,0x3553,0x3557,0x355b,0x355f,0x3563,0x3567,0x40a7,0x40b3,0x3593,0x343b,0x321f,0x33c3,0x415f,0x416b,0x0000,0x0000,0x3573,0x3577,0x357b,0x357f,0x3583,0x3587,0x3d2b,0x345b,0x3513,0x3517,0x3523,0x3527,0x3533,0x3537,0x3543,0x3547,0x35af,0x0000,0x3aeb,0x3af7,0x3e53,0x408f,0x407b,0x4067,0x0000,0x0000,0x0000,0x0000,0x40e7,0x40f3,0x4147,0x4153,0x3cf3,0x3cff,0x38bb,0x3d13,0x3f87,0x3f93,0x0000,0x0000,0x3bef,0x3bfb,0x3c07,0x3c23,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3dd3,0x3c9f,0x3b63,0x37b3,0x3b57,0x0000,0x3b4b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x400f,0x401b,0x3833,0x4047,0x0000,0x3d37,0x3d43,0x3d4f,0x3bd7,0x3be3,0x3b6f,0x3b8b,0x3bbb,0x3daf,0x3dbb,0x3dc7,0x0000,0x0000,0x0000,0x3f7b,0x0000,0x0000,0x0000,0x0000,0x38c7,0x3df7,0x380f,0x3cc3,0x0000,0x3d1f,0x0000,0x4053,0x3e1b,0x3e37,0x3ab3,0x3acf,0x0000,0x0000,0x3933,0x393f,0x394b,0x3957,0x3963,0x396f,0x397b,0x3987,0x3993,0x399f,0x3fbf,0x3fdb,0x4177,0x4193,0x0000,0x0000,0x39ab,0x39b7,0x39c3,0x39cf,0x39db,0x39e7,0x39f3,0x39ff,0x3a0b,0x3a17,0x0000,0x0000,0x0000,0x0000,0x3e5f,0x3e6b,0x3a23,0x3a2f,0x3a3b,0x3a47,0x3a53,0x3a5f,0x3a6b,0x3a77,0x3a83,0x3a8f,0x0000,0x0000,0x0000,0x0000,0x3ce7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x247f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e2b,0x0000,0x2f63,0x2f67,0x2f6b,0x2f6f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3d97,0x3da3,0x0000,0x37a7,0x3d73,0x3d7f,0x0000,0x0000,0x4117,0x4123,0x412f,0x413b,0x0000,0x0000,0x0000,0x33ff,0x0000,0x0000,0x0000,0x0000,0x3467,0x34a7,0x34cb,0x305f,0x3b1b,0x38eb,0x3b27,0x38f7,0x0000,0x3873,0x3c6f,0x3c7b,0x34d7,0x306b,0x34ef,0x41af,0x0000,0x409b,0x3b03,0x3b0f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3b33,0x3903,0x3b3f,0x390f,0x0000,0x0000,0x3c87,0x3c93,0x0000,0x0000,0x38af,0x41bb,0x3423,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x40cf,0x40db,0x0000,0x0000,0x391b,0x3927,0x40ff,0x410b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3a9b,0x3aa7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3ff7,0x4003,0x4027,0x4033,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x45ab,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2693,0x269f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2696,0x0000,0x0000,0x0000,0x15e4,0x0000,0x15e4,0x0000,0x15e4,0x0000,0x15e4,0x0000,0x26a2,0x0000,0x0000,0x0000,0x15e8,0x0000,0x15e8,0x0000,0x15e8,0x0000,0x15e8,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x0000,0x15ec,0x17b0,0x15ec,0x17b0,0x15ec,0x17b0,0x15ec,0x17b0,0x15ec,0x17b0,0x15ec,0x17b0,0x15ec,0x17b0,0x15ec,0x17b0,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x0000,0x15f0,0x17b4,0x15f0,0x17b4,0x15f0,0x17b4,0x15f0,0x17b4,0x15f0,0x17b4,0x15f0,0x17b4,0x15f0,0x17b4,0x15f0,0x17b4,0x0498,0x0498,0x15f8,0x0498,0x16bc,0x0000,0x0000,0x0000,0x0000,0x0000,0x15fc,0x1600,0x0000,0x26f9,0x0000,0x0000,0x1644,0x0000,0x1644,0x0000,0x1644,0x0000,0x1644,0x0000,0x1644,0x0000,0x1644,0x0000,0x1644,0x0000,0x1644,0x0000,0x1648,0x0000,0x0000,0x0000,0x164c,0x0000,0x0000,0x0000,0x1650,0x0000,0x0000,0x0000,0x1654,0x0000,0x0000,0x0000,0x1658,0x0000,0x0000,0x0000,0x165c,0x0000,0x0000,0x0000,0x1660,0x0000,0x0000,0x0000,0x1664,0x1668,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2732,0x273a,0x2742,0x274a,0x166c,0x0000,0x166c,0x0000,0x0000,0x0000,0x0000,0x0000,0x1670,0x0000,0x1670,0x0000,0x0000,0x0000,0x0000,0x0000,0x1674,0x0000,0x1674,0x0000,0x0000,0x0000,0x0000,0x0000,0x1678,0x0000,0x1678,0x0000,0x0000,0x0000,0x0000,0x0000,0x2756,0x275e,0x2766,0x276e,0x167c,0x0000,0x167c,0x0000,0x0000,0x0000,0x0000,0x0000,0x1680,0x0000,0x1680,0x0000,0x0000,0x0000,0x0000,0x0000,0x1684,0x0000,0x1684,0x0000,0x0000,0x0000,0x0000,0x0000,0x1688,0x0000,0x1688,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x277a,0x0000,0x0000,0x168c,0x0000,0x168c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2786,0x0000,0x0000,0x1690,0x0000,0x1690,0x0000,0x0000,0x0000,0x0000,0x0000,0x2791,0x27a9,0x27c1,0x27d9,0x27a2,0x0000,0x27a2,0x0000,0x27a2,0x0000,0x27a2,0x0000,0x27a2,0x0000,0x27a2,0x0000,0x27a2,0x0000,0x27a2,0x0000,0x1694,0x0000,0x1694,0x0000,0x0000,0x0000,0x0000,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x27ba,0x0000,0x1698,0x0000,0x1698,0x0000,0x0000,0x0000,0x0000,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x27d2,0x0000,0x169c,0x0000,0x169c,0x0000,0x0000,0x0000,0x0000,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x27ea,0x0000,0x16a0,0x0000,0x16a0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x27f5,0x280d,0x0000,0x2806,0x0000,0x2806,0x0000,0x2806,0x0000,0x2806,0x0000,0x2806,0x0000,0x2806,0x0000,0x2806,0x0000,0x2806,0x0000,0x16a4,0x0000,0x16a4,0x0000,0x0000,0x0000,0x0000,0x0000,0x281e,0x0000,0x281e,0x0000,0x281e,0x0000,0x281e,0x0000,0x281e,0x0000,0x281e,0x0000,0x281e,0x0000,0x281e,0x0000,0x16a8,0x0000,0x16a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x282a,0x0000,0x16ac,0x0000,0x16ac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2836,0x0000,0x0000,0x0000,0x16b0,0x0000,0x16b0,0x0000,0x0000,0x0000,0x0000,0x0000,0x2842,0x0000,0x0000,0x0000,0x16b4,0x0000,0x16b4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x284d,0x0000,0x0000,0x285d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x16b8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x16d8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x16dc,0x0000,0x2879,0x2889,0x2899,0x28a9,0x16e0,0x0000,0x16e0,0x0000,0x16e0,0x0000,0x16e0,0x0000,0x16e0,0x0000,0x16e0,0x0000,0x16e0,0x0000,0x16e0,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e4,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16e8,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x16ec,0x0000,0x0000,0x28bd,0x0000,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x28ce,0x0000,0x16f0,0x16f0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x28d9,0x0000,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x28ea,0x0000,0x16f4,0x16f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x28f5,0x0000,0x0000,0x2906,0x0000,0x2906,0x0000,0x2906,0x0000,0x2906,0x0000,0x2906,0x0000,0x2906,0x0000,0x2906,0x0000,0x2906,0x0000,0x16f8,0x16f8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2911,0x0000,0x0000,0x2922,0x0000,0x2922,0x0000,0x2922,0x0000,0x2922,0x0000,0x2922,0x0000,0x2922,0x0000,0x2922,0x0000,0x2922,0x0000,0x16fc,0x16fc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x292d,0x0000,0x0000,0x293e,0x0000,0x293e,0x0000,0x293e,0x0000,0x293e,0x0000,0x293e,0x0000,0x293e,0x0000,0x293e,0x0000,0x293e,0x0000,0x1700,0x1700,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2949,0x0000,0x0000,0x295a,0x0000,0x295a,0x0000,0x295a,0x0000,0x295a,0x0000,0x295a,0x0000,0x295a,0x0000,0x295a,0x0000,0x295a,0x0000,0x1704,0x1704,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2965,0x0000,0x0000,0x2976,0x0000,0x2976,0x0000,0x2976,0x0000,0x2976,0x0000,0x2976,0x0000,0x2976,0x0000,0x2976,0x0000,0x2976,0x0000,0x1708,0x1708,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2981,0x0000,0x0000,0x2992,0x0000,0x2992,0x0000,0x2992,0x0000,0x2992,0x0000,0x2992,0x0000,0x2992,0x0000,0x2992,0x0000,0x2992,0x0000,0x170c,0x170c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x299d,0x0000,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x29ae,0x0000,0x1710,0x1710,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x29b9,0x0000,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x29ca,0x0000,0x1714,0x1714,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x29d5,0x0000,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x29e6,0x0000,0x1718,0x1718,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x29f1,0x0000,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x2a02,0x0000,0x171c,0x171c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a0d,0x0000,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x2a1e,0x0000,0x1720,0x1720,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a29,0x0000,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x2a3a,0x0000,0x1724,0x1724,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a45,0x0000,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x2a56,0x0000,0x1728,0x1728,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a61,0x0000,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x2a72,0x0000,0x172c,0x172c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2a7d,0x0000,0x1730,0x0000,0x1734,0x0000,0x1738,0x0000,0x173c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1740,0x1744,0x1740,0x1744,0x1740,0x1744,0x1740,0x1744,0x1740,0x1744,0x1740,0x1744,0x1740,0x1744,0x1740,0x1744,0x1748,0x0000,0x1748,0x0000,0x1748,0x0000,0x1748,0x0000,0x1748,0x0000,0x1748,0x0000,0x1748,0x0000,0x1748,0x0000,0x174c,0x0000,0x174c,0x0000,0x174c,0x0000,0x174c,0x0000,0x174c,0x0000,0x174c,0x0000,0x174c,0x0000,0x174c,0x0000,0x1750,0x0000,0x1750,0x0000,0x1750,0x0000,0x1750,0x0000,0x1750,0x0000,0x1750,0x0000,0x1750,0x0000,0x1750,0x0000,0x0000,0x0000,0x2ad1,0x0000,0x0000,0x1754,0x0000,0x1754,0x0000,0x1754,0x0000,0x1754,0x0000,0x1754,0x0000,0x1754,0x0000,0x1754,0x0000,0x1754,0x0000,0x0000,0x2ae5,0x0000,0x0000,0x1758,0x0000,0x1758,0x0000,0x1758,0x0000,0x1758,0x0000,0x1758,0x0000,0x1758,0x0000,0x1758,0x0000,0x1758,0x0479,0x0479,0x0479,0x2af9,0x0414,0x0414,0x0418,0x0418,0x041c,0x041c,0x0420,0x0420,0x0424,0x0424,0x0428,0x0428,0x175c,0x175c,0x0000,0x0000,0x0000,0x0000,0x1760,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1764,0x0000,0x0000,0x0000,0x0000,0x0000,0x2b1d,0x2b35,0x0000,0x2b5d,0x2b2e,0x2b4d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1768,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2b46,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x176c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2b56,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1770,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2b6d,0x0000,0x2b6d,0x0000,0x2b6d,0x0000,0x2b6d,0x0000,0x2b6d,0x0000,0x2b6d,0x0000,0x2b6d,0x0000,0x2b6d,0x2b76,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1774,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2b81,0x2ba1,0x2bc1,0x2b91,0x0000,0x2b91,0x0000,0x2b91,0x0000,0x2b91,0x0000,0x2b91,0x0000,0x2b91,0x0000,0x2b91,0x0000,0x2b91,0x0000,0x0000,0x0000,0x0000,0x0000,0x2b9a,0x0000,0x0000,0x0000,0x1778,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x2bb1,0x0000,0x0000,0x0000,0x0000,0x0000,0x2bba,0x0000,0x0000,0x0000,0x177c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x2bd1,0x0000,0x0000,0x0000,0x0000,0x0000,0x2bda,0x0000,0x0000,0x0000,0x1780,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2be5,0x2bfd,0x0000,0x2bf6,0x0000,0x2bf6,0x0000,0x2bf6,0x0000,0x2bf6,0x0000,0x2bf6,0x0000,0x2bf6,0x0000,0x2bf6,0x0000,0x2bf6,0x1784,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c0e,0x0000,0x2c0e,0x0000,0x2c0e,0x0000,0x2c0e,0x0000,0x2c0e,0x0000,0x2c0e,0x0000,0x2c0e,0x0000,0x2c0e,0x1788,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c19,0x2c31,0x2c49,0x2c61,0x0000,0x2c2a,0x0000,0x2c2a,0x0000,0x2c2a,0x0000,0x2c2a,0x0000,0x2c2a,0x0000,0x2c2a,0x0000,0x2c2a,0x0000,0x2c2a,0x178c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c42,0x0000,0x2c42,0x0000,0x2c42,0x0000,0x2c42,0x0000,0x2c42,0x0000,0x2c42,0x0000,0x2c42,0x0000,0x2c42,0x1790,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c5a,0x0000,0x2c5a,0x0000,0x2c5a,0x0000,0x2c5a,0x0000,0x2c5a,0x0000,0x2c5a,0x0000,0x2c5a,0x0000,0x2c5a,0x1794,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c72,0x0000,0x2c72,0x0000,0x2c72,0x0000,0x2c72,0x0000,0x2c72,0x0000,0x2c72,0x0000,0x2c72,0x0000,0x2c72,0x1798,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2c7d,0x2c95,0x0000,0x0000,0x0000,0x2c8e,0x0000,0x2c8e,0x0000,0x2c8e,0x0000,0x2c8e,0x0000,0x2c8e,0x0000,0x2c8e,0x0000,0x2c8e,0x0000,0x2c8e,0x179c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2ca6,0x0000,0x2ca6,0x0000,0x2ca6,0x0000,0x2ca6,0x0000,0x2ca6,0x0000,0x2ca6,0x0000,0x2ca6,0x0000,0x2ca6,0x17a0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2daf,0x0000,0x2de3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2dc9,0x2db1,0x0000,0x2dc2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x17a8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2dda,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x17ac,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2dfd,0x2de5,0x0000,0x2df6,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x17b8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e0e,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x17bc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e1a,0x2e22,0x17c0,0x0000,0x17c0,0x0000,0x0000,0x0000,0x0000,0x0000,0x17c4,0x0000,0x17c4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2e2e,0x2e36,0x17c0,0x0000,0x17c0,0x0000,0x17c0,0x0000,0x17c0,0x0000,0x17c4,0x0000,0x17c4,0x0000,0x17c4,0x0000,0x17c4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x329f,0x32e3,0x30ff,0x317b,0x377f,0x3793,0x31af,0x31eb,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x30bf,0x30d3,0x3023,0x3257,0x3037,0x300f,0x376b,0x2fbf,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3723,0x0000,0x0000,0x2f73,0x2f87,0x337b,0x41c7,0x2f3f,0x3357,0x2ffb,0x2fe7,0x3747,0x309b,0x303b,0x3077,0x36c3,0x36c7,0x36cb,0x33af,0x3447,0x344b,0x344f,0x33b3,0x36e3,0x36e7,0x36eb,0x33b7,0x36d7,0x36f7,0x30f3,0x310b,0x35db,0x35e7,0x35fb,0x3627,0x3427,0x342b,0x342f,0x0000,0x388b,0x3853,0x387f,0x3847,0x0000,0x0000,0x30e7,0x3117,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2f9b,0x0000,0x34e3,0x348b,0x370f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x364b,0x364f,0x365b,0x33e3,0x35ab,0x3293,0x0000,0x36bb,0x36bf,0x3503,0x3403,0x33f7,0x33fb,0x3507,0x340f,0x341b,0x3667,0x366b,0x341f,0x35a3,0x35a7,0x2fd3,0x323b,0x36b3,0x36b7,0x350b,0x35c7,0x33ef,0x33f3,0x350f,0x3703,0x0000,0x3677,0x367b,0x3687,0x35bb,0x34ff,0x35d3,0x0000,0x3693,0x3697,0x369b,0x36a7,0x33cf,0x33d3,0x33d7,0x0000,0x2f42,0x2f4a,0x2f52,0x2f5a,0x17c8,0x0000,0x17c8,0x0000,0x17c8,0x0000,0x17c8,0x0000,0x0000,0x17cc,0x0000,0x17cc,0x0000,0x17cc,0x0000,0x17cc,0x17d0,0x0000,0x17d0,0x0000,0x17d0,0x0000,0x17d0,0x0000,0x0000,0x17d4,0x0000,0x17d4,0x0000,0x17d4,0x0000,0x17d4,0x0000,0x17d8,0x0000,0x0000,0x0000,0x17dc,0x0000,0x0000,0x0000,0x17e0,0x0000,0x0000,0x0000,0x17e4,0x0000,0x0000,0x2f76,0x2f7e,0x0000,0x0000,0x17e8,0x0000,0x17e8,0x0000,0x17e8,0x0000,0x17e8,0x0000,0x0000,0x17ec,0x0000,0x17ec,0x0000,0x17ec,0x0000,0x17ec,0x2f8a,0x2f92,0x0000,0x0000,0x17f0,0x0000,0x17f0,0x0000,0x17f0,0x0000,0x17f0,0x0000,0x0000,0x17f4,0x0000,0x17f4,0x0000,0x17f4,0x0000,0x17f4,0x2f9e,0x2fa6,0x2fae,0x2fb6,0x17f8,0x0000,0x17f8,0x0000,0x17f8,0x0000,0x17f8,0x0000,0x0000,0x17fc,0x0000,0x17fc,0x0000,0x17fc,0x0000,0x17fc,0x1800,0x0000,0x1800,0x0000,0x1800,0x0000,0x1800,0x0000,0x0000,0x1804,0x0000,0x1804,0x0000,0x1804,0x0000,0x1804,0x2fc2,0x2fca,0x0000,0x0000,0x1808,0x0000,0x1808,0x0000,0x1808,0x0000,0x1808,0x0000,0x0000,0x180c,0x0000,0x180c,0x0000,0x180c,0x0000,0x180c,0x0000,0x3026,0x2fd6,0x2fde,0x1810,0x1bfc,0x1810,0x1bfc,0x1810,0x1bfc,0x1810,0x1bfc,0x0000,0x1814,0x0000,0x1814,0x0000,0x1814,0x0000,0x1814,0x2fea,0x2ff2,0x302e,0x0000,0x1818,0x1c00,0x1818,0x1c00,0x1818,0x1c00,0x1818,0x1c00,0x181c,0x0000,0x181c,0x0000,0x181c,0x0000,0x181c,0x0000,0x2ffe,0x3006,0x3012,0x301a,0x1820,0x0000,0x1820,0x0000,0x1820,0x0000,0x1820,0x0000,0x0000,0x1824,0x0000,0x1824,0x0000,0x1824,0x0000,0x1824,0x0000,0x0000,0x1828,0x182c,0x1830,0x0000,0x1830,0x0000,0x1830,0x0000,0x1830,0x0000,0x0000,0x1834,0x0000,0x1834,0x0000,0x1834,0x0000,0x1834,0x0000,0x0000,0x1838,0x183c,0x0000,0x1840,0x0000,0x1840,0x0000,0x1840,0x0000,0x1840,0x1844,0x0000,0x1844,0x0000,0x1844,0x0000,0x1844,0x0000,0x0000,0x0000,0x184c,0x1848,0x303e,0x3046,0x304e,0x3056,0x1850,0x0000,0x1850,0x0000,0x1850,0x0000,0x1850,0x0000,0x0000,0x1854,0x0000,0x1854,0x0000,0x1854,0x0000,0x1854,0x1858,0x0000,0x1858,0x0000,0x1858,0x0000,0x1858,0x0000,0x0000,0x185c,0x0000,0x185c,0x0000,0x185c,0x0000,0x185c,0x0000,0x3062,0x0000,0x0000,0x1860,0x1860,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x306e,0x0000,0x0000,0x1864,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x307a,0x3082,0x308a,0x3092,0x1868,0x0000,0x1868,0x0000,0x1868,0x0000,0x1868,0x0000,0x0000,0x186c,0x0000,0x186c,0x0000,0x186c,0x0000,0x186c,0x1870,0x0000,0x1870,0x0000,0x1870,0x0000,0x1870,0x0000,0x0000,0x1874,0x0000,0x1874,0x0000,0x1874,0x0000,0x1874,0x309e,0x30a6,0x30ae,0x30b6,0x1878,0x0000,0x1878,0x0000,0x1878,0x0000,0x1878,0x0000,0x0000,0x187c,0x0000,0x187c,0x0000,0x187c,0x0000,0x187c,0x1880,0x0000,0x1880,0x0000,0x1880,0x0000,0x1880,0x0000,0x0000,0x1884,0x0000,0x1884,0x0000,0x1884,0x0000,0x1884,0x30c2,0x30ca,0x0000,0x0000,0x1888,0x0000,0x1888,0x0000,0x1888,0x0000,0x1888,0x0000,0x0000,0x188c,0x0000,0x188c,0x0000,0x188c,0x0000,0x188c,0x30d6,0x30de,0x0000,0x0000,0x1890,0x0000,0x1890,0x0000,0x1890,0x0000,0x1890,0x0000,0x0000,0x1894,0x0000,0x1894,0x0000,0x1894,0x0000,0x1894,0x0000,0x30ea,0x328a,0x0000,0x1898,0x1898,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x30f6,0x0000,0x0000,0x189c,0x189c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3141,0x3161,0x3326,0x3102,0x0000,0x18a0,0x0000,0x18a4,0x0000,0x18a4,0x0000,0x0000,0x0000,0x310e,0x3122,0x3132,0x18a8,0x18ac,0x18a8,0x18ac,0x18a8,0x18ac,0x18a8,0x18ac,0x0000,0x311a,0x312a,0x313a,0x18b0,0x18b4,0x18b0,0x18b4,0x18b0,0x18b4,0x18b0,0x18b4,0x18b8,0x18bc,0x18b8,0x18bc,0x18b8,0x18bc,0x18b8,0x18bc,0x18c0,0x18c4,0x18c0,0x18c4,0x18c0,0x18c4,0x18c0,0x18c4,0x18c8,0x18cc,0x18c8,0x18cc,0x18c8,0x18cc,0x18c8,0x18cc,0x18d0,0x18d4,0x18d0,0x18d4,0x18d0,0x18d4,0x18d0,0x18d4,0x3152,0x315a,0x3152,0x315a,0x3152,0x315a,0x3152,0x315a,0x3152,0x315a,0x3152,0x315a,0x3152,0x315a,0x3152,0x315a,0x18d8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18dc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3172,0x0000,0x3172,0x0000,0x3172,0x0000,0x3172,0x0000,0x3172,0x0000,0x3172,0x0000,0x3172,0x0000,0x3172,0x0000,0x0000,0x18e0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x317d,0x3195,0x0000,0x0000,0x318e,0x0000,0x318e,0x0000,0x318e,0x0000,0x318e,0x0000,0x318e,0x0000,0x318e,0x0000,0x318e,0x0000,0x318e,0x0000,0x18e4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x31a6,0x0000,0x0000,0x18e8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x31b1,0x31d1,0x332e,0x0000,0x31c2,0x31ca,0x31c2,0x31ca,0x31c2,0x31ca,0x31c2,0x31ca,0x31c2,0x31ca,0x31c2,0x31ca,0x31c2,0x31ca,0x31c2,0x31ca,0x18ec,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18f0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x31e2,0x0000,0x0000,0x18f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x31ed,0x3205,0x0000,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x31fe,0x0000,0x18f8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3216,0x0000,0x3216,0x0000,0x3216,0x0000,0x3216,0x0000,0x3216,0x0000,0x3216,0x0000,0x3216,0x0000,0x3216,0x0000,0x0000,0x18fc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3221,0x3c3d,0x0000,0x3232,0x0000,0x3232,0x0000,0x3232,0x0000,0x3232,0x0000,0x3232,0x0000,0x3232,0x0000,0x3232,0x0000,0x3232,0x0000,0x1900,0x0000,0x1900,0x0000,0x1900,0x0000,0x1900,0x0000,0x0000,0x323d,0x0000,0x0000,0x324e,0x0000,0x324e,0x0000,0x324e,0x0000,0x324e,0x0000,0x324e,0x0000,0x324e,0x0000,0x324e,0x0000,0x324e,0x0000,0x1904,0x0000,0x1904,0x0000,0x1904,0x0000,0x1904,0x0000,0x3259,0x3271,0x0000,0x0000,0x326a,0x0000,0x326a,0x0000,0x326a,0x0000,0x326a,0x0000,0x326a,0x0000,0x326a,0x0000,0x326a,0x0000,0x326a,0x0000,0x1908,0x0000,0x1908,0x0000,0x1908,0x0000,0x1908,0x0000,0x3282,0x0000,0x3282,0x0000,0x3282,0x0000,0x3282,0x0000,0x3282,0x0000,0x3282,0x0000,0x3282,0x0000,0x3282,0x0000,0x0000,0x190c,0x0000,0x190c,0x0000,0x190c,0x0000,0x190c,0x0000,0x1910,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3296,0x0000,0x0000,0x0000,0x1914,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3336,0x333e,0x32a1,0x32c1,0x32b2,0x32ba,0x32b2,0x32ba,0x32b2,0x32ba,0x32b2,0x32ba,0x32b2,0x32ba,0x32b2,0x32ba,0x32b2,0x32ba,0x32b2,0x32ba,0x1918,0x0000,0x1918,0x0000,0x1918,0x0000,0x1918,0x0000,0x191c,0x0000,0x191c,0x0000,0x191c,0x0000,0x191c,0x0000,0x32d2,0x32da,0x32d2,0x32da,0x32d2,0x32da,0x32d2,0x32da,0x32d2,0x32da,0x32d2,0x32da,0x32d2,0x32da,0x32d2,0x32da,0x0000,0x1920,0x0000,0x1920,0x0000,0x1920,0x0000,0x1920,0x0000,0x1924,0x0000,0x1924,0x0000,0x1924,0x0000,0x1924,0x3346,0x334e,0x32e5,0x3305,0x32f6,0x32fe,0x32f6,0x32fe,0x32f6,0x32fe,0x32f6,0x32fe,0x32f6,0x32fe,0x32f6,0x32fe,0x32f6,0x32fe,0x32f6,0x32fe,0x1928,0x0000,0x1928,0x0000,0x1928,0x0000,0x1928,0x0000,0x192c,0x0000,0x192c,0x0000,0x192c,0x0000,0x192c,0x0000,0x3316,0x331e,0x3316,0x331e,0x3316,0x331e,0x3316,0x331e,0x3316,0x331e,0x3316,0x331e,0x3316,0x331e,0x3316,0x331e,0x0000,0x1930,0x0000,0x1930,0x0000,0x1930,0x0000,0x1930,0x0000,0x1934,0x0000,0x1934,0x0000,0x1934,0x0000,0x1934,0x1938,0x0000,0x1938,0x0000,0x1938,0x0000,0x1938,0x0000,0x193c,0x0000,0x193c,0x0000,0x193c,0x0000,0x193c,0x0000,0x1940,0x0000,0x1940,0x0000,0x1940,0x0000,0x1940,0x0000,0x0000,0x1944,0x0000,0x1944,0x0000,0x1944,0x0000,0x1944,0x1948,0x0000,0x1948,0x0000,0x1948,0x0000,0x1948,0x0000,0x0000,0x194c,0x0000,0x194c,0x0000,0x194c,0x0000,0x194c,0x335a,0x3362,0x336a,0x3372,0x1950,0x0000,0x1950,0x0000,0x1950,0x0000,0x1950,0x0000,0x0000,0x1954,0x0000,0x1954,0x0000,0x1954,0x0000,0x1954,0x1958,0x0000,0x1958,0x0000,0x1958,0x0000,0x1958,0x0000,0x0000,0x195c,0x0000,0x195c,0x0000,0x195c,0x0000,0x195c,0x337e,0x3386,0x0000,0x0000,0x1960,0x0000,0x1960,0x0000,0x1960,0x0000,0x1960,0x0000,0x0000,0x1964,0x0000,0x1964,0x0000,0x1964,0x0000,0x1964,0x0000,0x1968,0x0000,0x0000,0x0000,0x196c,0x0000,0x0000,0x0000,0x339a,0x0000,0x0000,0x1970,0x0000,0x1970,0x0000,0x1970,0x0000,0x1970,0x0000,0x0000,0x33a6,0x0000,0x0000,0x0000,0x1974,0x0000,0x1974,0x0000,0x1974,0x0000,0x1974,0x0000,0x1978,0x0000,0x0000,0x0000,0x197c,0x0000,0x0000,0x0000,0x33ba,0x0000,0x0000,0x1980,0x0000,0x1980,0x0000,0x1980,0x0000,0x1980,0x0000,0x0000,0x33c6,0x0000,0x0000,0x1984,0x0000,0x1984,0x0000,0x1984,0x0000,0x1984,0x0000,0x0000,0x1988,0x0000,0x0000,0x0000,0x198c,0x0000,0x0000,0x0000,0x33da,0x0000,0x0000,0x1990,0x0000,0x1990,0x0000,0x1990,0x0000,0x1990,0x0000,0x0000,0x33e6,0x0000,0x0000,0x0000,0x1994,0x0000,0x1994,0x0000,0x1994,0x0000,0x1994,0x0000,0x1998,0x0000,0x0000,0x0000,0x199c,0x0000,0x0000,0x0000,0x19a0,0x0000,0x0000,0x0000,0x19a4,0x0000,0x0000,0x0000,0x19a8,0x0000,0x0000,0x0000,0x3406,0x0000,0x0000,0x19ac,0x19b0,0x19ac,0x19b0,0x19ac,0x19b0,0x19ac,0x19b0,0x0000,0x3412,0x0000,0x0000,0x19b4,0x19b8,0x19b4,0x19b8,0x19b4,0x19b8,0x19b4,0x19b8,0x0000,0x19bc,0x0000,0x0000,0x0000,0x19c0,0x0000,0x0000,0x0000,0x19c4,0x0000,0x0000,0x0000,0x19c8,0x0000,0x0000,0x0000,0x19cc,0x0000,0x0000,0x0000,0x3432,0x0000,0x0000,0x19d0,0x0000,0x19d0,0x0000,0x19d0,0x0000,0x19d0,0x0000,0x0000,0x343e,0x3e75,0x0000,0x0000,0x19d4,0x0000,0x19d4,0x0000,0x19d4,0x0000,0x19d4,0x0000,0x19d8,0x0000,0x0000,0x0000,0x19dc,0x0000,0x0000,0x0000,0x3452,0x0000,0x0000,0x19e0,0x0000,0x19e0,0x0000,0x19e0,0x0000,0x19e0,0x0000,0x0000,0x345e,0x0000,0x0000,0x0000,0x19e4,0x0000,0x19e4,0x0000,0x19e4,0x0000,0x19e4,0x0000,0x3469,0x0000,0x0000,0x347a,0x3482,0x347a,0x3482,0x347a,0x3482,0x347a,0x3482,0x347a,0x3482,0x347a,0x3482,0x347a,0x3482,0x347a,0x3482,0x19e8,0x19e8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x19ec,0x19ec,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x348d,0x0000,0x0000,0x0000,0x349e,0x0000,0x349e,0x0000,0x349e,0x0000,0x349e,0x0000,0x349e,0x0000,0x349e,0x0000,0x349e,0x0000,0x349e,0x19f0,0x19f0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x34a9,0x0000,0x0000,0x34ba,0x34c2,0x34ba,0x34c2,0x34ba,0x34c2,0x34ba,0x34c2,0x34ba,0x34c2,0x34ba,0x34c2,0x34ba,0x34c2,0x34ba,0x34c2,0x19f4,0x19f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x19f8,0x19f8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x34ce,0x0000,0x0000,0x19fc,0x19fc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x34da,0x0000,0x0000,0x1a00,0x1a00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x34e6,0x0000,0x0000,0x1a04,0x1a04,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x34f2,0x0000,0x0000,0x1a08,0x1a08,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1a0c,0x0000,0x0000,0x0000,0x1a10,0x0000,0x0000,0x0000,0x1a14,0x0000,0x0000,0x0000,0x1a18,0x0000,0x0000,0x0000,0x1a1c,0x0000,0x0000,0x0000,0x1a20,0x0000,0x0000,0x0000,0x1a24,0x3ebd,0x0000,0x0000,0x351a,0x3e8d,0x0000,0x1a28,0x1a2c,0x1a28,0x1a2c,0x1a28,0x1a2c,0x1a28,0x1a2c,0x0000,0x1a30,0x3c55,0x0000,0x0000,0x352a,0x0000,0x0000,0x1a34,0x1a38,0x1a34,0x1a38,0x1a34,0x1a38,0x1a34,0x1a38,0x0000,0x1a3c,0x0000,0x0000,0x0000,0x353a,0x0000,0x0000,0x1a40,0x1a44,0x1a40,0x1a44,0x1a40,0x1a44,0x1a40,0x1a44,0x0000,0x1a48,0x0000,0x0000,0x0000,0x354a,0x0000,0x0000,0x1a4c,0x1a50,0x1a4c,0x1a50,0x1a4c,0x1a50,0x1a4c,0x1a50,0x0000,0x1a54,0x3ede,0x0000,0x0000,0x1a58,0x3efa,0x0000,0x0000,0x1a5c,0x3f16,0x0000,0x0000,0x1a60,0x3f32,0x0000,0x0000,0x1a64,0x3f4a,0x0000,0x0000,0x356a,0x3f66,0x0000,0x1a68,0x0000,0x1a68,0x0000,0x1a68,0x0000,0x1a68,0x0000,0x0000,0x1a6c,0x3ed6,0x0000,0x0000,0x1a70,0x3ef2,0x0000,0x0000,0x1a74,0x3f0e,0x0000,0x0000,0x1a78,0x3f2a,0x0000,0x0000,0x1a7c,0x3f42,0x0000,0x0000,0x358a,0x3f5e,0x0000,0x1a80,0x0000,0x1a80,0x0000,0x1a80,0x0000,0x1a80,0x0000,0x0000,0x3596,0x3ea5,0x0000,0x0000,0x1a84,0x0000,0x1a84,0x0000,0x1a84,0x0000,0x1a84,0x0000,0x1a88,0x0000,0x0000,0x0000,0x1a8c,0x0000,0x0000,0x0000,0x1a90,0x0000,0x0000,0x0000,0x1a94,0x0000,0x0000,0x0000,0x35b2,0x0000,0x0000,0x1a98,0x1a9c,0x1a98,0x1a9c,0x1a98,0x1a9c,0x1a98,0x1a9c,0x0000,0x35be,0x0000,0x0000,0x0000,0x1aa0,0x0000,0x1aa0,0x0000,0x1aa0,0x0000,0x1aa0,0x0000,0x35ca,0x0000,0x0000,0x1aa4,0x1aa8,0x1aa4,0x1aa8,0x1aa4,0x1aa8,0x1aa4,0x1aa8,0x0000,0x1aac,0x0000,0x0000,0x0000,0x1ab0,0x0000,0x0000,0x0000,0x35de,0x1ab8,0x1abc,0x1ab4,0x0000,0x1ab4,0x0000,0x1ab4,0x0000,0x1ab4,0x0000,0x0000,0x35e9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ac0,0x1ac0,0x0000,0x0000,0x1ac4,0x1ac4,0x0000,0x0000,0x1ac8,0x1ac8,0x0000,0x0000,0x0000,0x35fd,0x0000,0x0000,0x3fa6,0x3fa6,0x3fb6,0x3fb6,0x360e,0x360e,0x0000,0x0000,0x3616,0x3616,0x0000,0x0000,0x361e,0x361e,0x0000,0x0000,0x1acc,0x0000,0x1acc,0x0000,0x1acc,0x0000,0x1acc,0x0000,0x1ad0,0x1adc,0x1ad0,0x1adc,0x1ad0,0x1adc,0x1ad0,0x1adc,0x1ad4,0x0000,0x1ad4,0x0000,0x1ad4,0x0000,0x1ad4,0x0000,0x0000,0x3629,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x363a,0x363a,0x1b08,0x1b08,0x0000,0x0000,0x0000,0x0000,0x3642,0x3642,0x1b0c,0x1b0c,0x0000,0x1ad8,0x0000,0x1ad8,0x0000,0x1ad8,0x0000,0x1ad8,0x0000,0x1ae0,0x0000,0x1ae0,0x0000,0x1ae0,0x0000,0x1ae0,0x0000,0x1ae4,0x0000,0x0000,0x0000,0x3652,0x0000,0x0000,0x1ae8,0x0000,0x1ae8,0x0000,0x1ae8,0x0000,0x1ae8,0x0000,0x0000,0x365e,0x0000,0x0000,0x0000,0x1aec,0x0000,0x1aec,0x0000,0x1aec,0x0000,0x1aec,0x0000,0x1af0,0x0000,0x0000,0x0000,0x366e,0x0000,0x0000,0x1af4,0x1af8,0x1af4,0x1af8,0x1af4,0x1af8,0x1af4,0x1af8,0x0000,0x1afc,0x0000,0x0000,0x0000,0x367e,0x0000,0x0000,0x1b00,0x0000,0x1b00,0x0000,0x1b00,0x0000,0x1b00,0x0000,0x0000,0x368a,0x0000,0x0000,0x0000,0x1b04,0x0000,0x1b04,0x0000,0x1b04,0x0000,0x1b04,0x0000,0x1b10,0x0000,0x0000,0x0000,0x1b14,0x0000,0x0000,0x0000,0x369e,0x0000,0x0000,0x1b18,0x0000,0x1b18,0x0000,0x1b18,0x0000,0x1b18,0x0000,0x0000,0x36aa,0x0000,0x0000,0x0000,0x1b1c,0x0000,0x1b1c,0x0000,0x1b1c,0x0000,0x1b1c,0x0000,0x1b20,0x0000,0x0000,0x0000,0x1b24,0x0000,0x0000,0x0000,0x1b28,0x0000,0x0000,0x0000,0x1b2c,0x0000,0x0000,0x0000,0x1b30,0x0000,0x0000,0x0000,0x1b34,0x0000,0x0000,0x0000,0x36ce,0x0000,0x0000,0x1b38,0x0000,0x1b38,0x0000,0x1b38,0x0000,0x1b38,0x0000,0x0000,0x36da,0x0000,0x0000,0x0000,0x1b3c,0x0000,0x1b3c,0x0000,0x1b3c,0x0000,0x1b3c,0x0000,0x1b40,0x0000,0x0000,0x0000,0x1b44,0x0000,0x0000,0x0000,0x36ee,0x0000,0x0000,0x1b48,0x0000,0x1b48,0x0000,0x1b48,0x0000,0x1b48,0x0000,0x0000,0x36fa,0x0000,0x0000,0x0000,0x1b4c,0x0000,0x1b4c,0x0000,0x1b4c,0x0000,0x1b4c,0x0000,0x3706,0x0000,0x0000,0x1b50,0x1b54,0x1b50,0x1b54,0x1b50,0x1b54,0x1b50,0x1b54,0x3712,0x371a,0x0000,0x0000,0x1b58,0x0000,0x1b58,0x0000,0x1b58,0x0000,0x1b58,0x0000,0x0000,0x1b5c,0x0000,0x1b5c,0x0000,0x1b5c,0x0000,0x1b5c,0x3726,0x372e,0x3736,0x373e,0x1b60,0x0000,0x1b60,0x0000,0x1b60,0x0000,0x1b60,0x0000,0x0000,0x1b64,0x0000,0x1b64,0x0000,0x1b64,0x0000,0x1b64,0x1b68,0x0000,0x1b68,0x0000,0x1b68,0x0000,0x1b68,0x0000,0x0000,0x1b6c,0x0000,0x1b6c,0x0000,0x1b6c,0x0000,0x1b6c,0x374a,0x3752,0x375a,0x3762,0x1b70,0x0000,0x1b70,0x0000,0x1b70,0x0000,0x1b70,0x0000,0x0000,0x1b74,0x0000,0x1b74,0x0000,0x1b74,0x0000,0x1b74,0x1b78,0x0000,0x1b78,0x0000,0x1b78,0x0000,0x1b78,0x0000,0x0000,0x1b7c,0x0000,0x1b7c,0x0000,0x1b7c,0x0000,0x1b7c,0x376e,0x3776,0x0000,0x0000,0x1b80,0x0000,0x1b80,0x0000,0x1b80,0x0000,0x1b80,0x0000,0x0000,0x1b84,0x0000,0x1b84,0x0000,0x1b84,0x0000,0x1b84,0x3782,0x378a,0x0000,0x0000,0x1b88,0x0000,0x1b88,0x0000,0x1b88,0x0000,0x1b88,0x0000,0x0000,0x1b8c,0x0000,0x1b8c,0x0000,0x1b8c,0x0000,0x1b8c,0x3796,0x379e,0x0000,0x0000,0x1b90,0x0000,0x1b90,0x0000,0x1b90,0x0000,0x1b90,0x0000,0x0000,0x1b94,0x0000,0x1b94,0x0000,0x1b94,0x0000,0x1b94,0x0000,0x37aa,0x0000,0x0000,0x1b98,0x1b9c,0x1b98,0x1b9c,0x1b98,0x1b9c,0x1b98,0x1b9c,0x0000,0x37b6,0x0000,0x0000,0x1ba0,0x1ba4,0x1ba0,0x1ba4,0x1ba0,0x1ba4,0x1ba0,0x1ba4,0x0000,0x37c2,0x0000,0x0000,0x1ba8,0x0000,0x1ba8,0x0000,0x1ba8,0x0000,0x1ba8,0x0000,0x0000,0x37ce,0x0000,0x0000,0x0000,0x0000,0x1bac,0x1bb0,0x1bac,0x1bb0,0x0000,0x0000,0x0000,0x37d9,0x0000,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x37ea,0x0000,0x0000,0x0000,0x1bb4,0x1bb8,0x1bb4,0x1bb8,0x0000,0x0000,0x0000,0x37f5,0x0000,0x0000,0x3806,0x0000,0x3806,0x0000,0x3806,0x0000,0x3806,0x0000,0x3806,0x0000,0x3806,0x0000,0x3806,0x0000,0x3806,0x0000,0x0000,0x0000,0x0000,0x0000,0x1bbc,0x1bc0,0x0000,0x0000,0x0000,0x3811,0x0000,0x0000,0x3822,0x382a,0x3822,0x382a,0x3822,0x382a,0x3822,0x382a,0x3822,0x382a,0x3822,0x382a,0x3822,0x382a,0x3822,0x382a,0x1bc4,0x1bcc,0x1bc4,0x1bcc,0x1bc4,0x1bcc,0x1bc4,0x1bcc,0x1bc8,0x1bd0,0x1bc8,0x1bd0,0x1bc8,0x1bd0,0x1bc8,0x1bd0,0x0000,0x403e,0x383e,0x3836,0x1bd4,0x0000,0x1bd4,0x0000,0x1bd4,0x0000,0x1bd4,0x0000,0x1bd8,0x0000,0x1bd8,0x0000,0x1bd8,0x0000,0x1bd8,0x0000,0x0000,0x384a,0x1c10,0x1c0c,0x1bdc,0x1be0,0x1bdc,0x1be0,0x1bdc,0x1be0,0x1bdc,0x1be0,0x3856,0x385e,0x1c08,0x1c04,0x1be4,0x1be8,0x1be4,0x1be8,0x1be4,0x1be8,0x1be4,0x1be8,0x1bec,0x1bf0,0x1bec,0x1bf0,0x1bec,0x1bf0,0x1bec,0x1bf0,0x0000,0x386a,0x3f3a,0x0000,0x1bf4,0x0000,0x1bf4,0x0000,0x1bf4,0x0000,0x1bf4,0x0000,0x0000,0x3876,0x0000,0x0000,0x1bf8,0x0000,0x1bf8,0x0000,0x1bf8,0x0000,0x1bf8,0x0000,0x0000,0x3882,0x389e,0x38a6,0x1c14,0x1c18,0x1c14,0x1c18,0x1c14,0x1c18,0x1c14,0x1c18,0x388e,0x3896,0x1c30,0x1c2c,0x1c1c,0x1c20,0x1c1c,0x1c20,0x1c1c,0x1c20,0x1c1c,0x1c20,0x1c24,0x1c28,0x1c24,0x1c28,0x1c24,0x1c28,0x1c24,0x1c28,0x1c34,0x1c3c,0x1c34,0x1c3c,0x1c34,0x1c3c,0x1c34,0x1c3c,0x1c38,0x1c40,0x1c38,0x1c40,0x1c38,0x1c40,0x1c38,0x1c40,0x0000,0x38b2,0x0000,0x0000,0x1c44,0x0000,0x1c44,0x0000,0x1c44,0x0000,0x1c44,0x0000,0x0000,0x3d0a,0x38be,0x0000,0x1c48,0x0000,0x1c48,0x0000,0x1c48,0x0000,0x1c48,0x0000,0x0000,0x38c9,0x0000,0x0000,0x38da,0x38e2,0x38da,0x38e2,0x38da,0x38e2,0x38da,0x38e2,0x38da,0x38e2,0x38da,0x38e2,0x38da,0x38e2,0x38da,0x38e2,0x1c4c,0x1c54,0x1c4c,0x1c54,0x1c4c,0x1c54,0x1c4c,0x1c54,0x1c50,0x1c58,0x1c50,0x1c58,0x1c50,0x1c58,0x1c50,0x1c58,0x0000,0x38ee,0x0000,0x0000,0x0000,0x0000,0x1c5c,0x1c60,0x1c5c,0x1c60,0x0000,0x0000,0x0000,0x38fa,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c64,0x1c68,0x0000,0x0000,0x0000,0x3906,0x0000,0x0000,0x0000,0x0000,0x1c6c,0x1c70,0x1c6c,0x1c70,0x0000,0x0000,0x0000,0x3912,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1c74,0x1c78,0x0000,0x0000,0x0000,0x391e,0x0000,0x0000,0x1c7c,0x1c80,0x1c7c,0x1c80,0x1c7c,0x1c80,0x1c7c,0x1c80,0x0000,0x392a,0x0000,0x0000,0x1c84,0x1c88,0x1c84,0x1c88,0x1c84,0x1c88,0x1c84,0x1c88,0x0000,0x3936,0x0000,0x0000,0x1c8c,0x1c90,0x1c8c,0x1c90,0x1c8c,0x1c90,0x1c8c,0x1c90,0x0000,0x3942,0x0000,0x0000,0x1c94,0x1c98,0x1c94,0x1c98,0x1c94,0x1c98,0x1c94,0x1c98,0x0000,0x394e,0x0000,0x0000,0x1c9c,0x1ca0,0x1c9c,0x1ca0,0x1c9c,0x1ca0,0x1c9c,0x1ca0,0x0000,0x395a,0x0000,0x0000,0x1ca4,0x1ca8,0x1ca4,0x1ca8,0x1ca4,0x1ca8,0x1ca4,0x1ca8,0x0000,0x3966,0x0000,0x0000,0x1cac,0x1cb0,0x1cac,0x1cb0,0x1cac,0x1cb0,0x1cac,0x1cb0,0x0000,0x3972,0x0000,0x0000,0x1cb4,0x1cb8,0x1cb4,0x1cb8,0x1cb4,0x1cb8,0x1cb4,0x1cb8,0x0000,0x397e,0x0000,0x0000,0x1cbc,0x1cc0,0x1cbc,0x1cc0,0x1cbc,0x1cc0,0x1cbc,0x1cc0,0x0000,0x398a,0x0000,0x0000,0x1cc4,0x1cc8,0x1cc4,0x1cc8,0x1cc4,0x1cc8,0x1cc4,0x1cc8,0x0000,0x3996,0x0000,0x0000,0x1ccc,0x1cd0,0x1ccc,0x1cd0,0x1ccc,0x1cd0,0x1ccc,0x1cd0,0x0000,0x39a2,0x0000,0x0000,0x1cd4,0x1cd8,0x1cd4,0x1cd8,0x1cd4,0x1cd8,0x1cd4,0x1cd8,0x0000,0x39ae,0x0000,0x0000,0x1cdc,0x1ce0,0x1cdc,0x1ce0,0x1cdc,0x1ce0,0x1cdc,0x1ce0,0x0000,0x39ba,0x0000,0x0000,0x1ce4,0x1ce8,0x1ce4,0x1ce8,0x1ce4,0x1ce8,0x1ce4,0x1ce8,0x0000,0x39c6,0x0000,0x0000,0x1cec,0x1cf0,0x1cec,0x1cf0,0x1cec,0x1cf0,0x1cec,0x1cf0,0x0000,0x39d2,0x0000,0x0000,0x1cf4,0x1cf8,0x1cf4,0x1cf8,0x1cf4,0x1cf8,0x1cf4,0x1cf8,0x0000,0x39de,0x0000,0x0000,0x1cfc,0x1d00,0x1cfc,0x1d00,0x1cfc,0x1d00,0x1cfc,0x1d00,0x0000,0x39ea,0x0000,0x0000,0x1d04,0x1d08,0x1d04,0x1d08,0x1d04,0x1d08,0x1d04,0x1d08,0x0000,0x39f6,0x0000,0x0000,0x1d0c,0x1d10,0x1d0c,0x1d10,0x1d0c,0x1d10,0x1d0c,0x1d10,0x0000,0x3a02,0x0000,0x0000,0x1d14,0x1d18,0x1d14,0x1d18,0x1d14,0x1d18,0x1d14,0x1d18,0x0000,0x3a0e,0x0000,0x0000,0x1d1c,0x1d20,0x1d1c,0x1d20,0x1d1c,0x1d20,0x1d1c,0x1d20,0x0000,0x3a1a,0x0000,0x0000,0x1d24,0x1d28,0x1d24,0x1d28,0x1d24,0x1d28,0x1d24,0x1d28,0x0000,0x3a26,0x0000,0x0000,0x1d2c,0x1d30,0x1d2c,0x1d30,0x1d2c,0x1d30,0x1d2c,0x1d30,0x0000,0x3a32,0x0000,0x0000,0x1d34,0x1d38,0x1d34,0x1d38,0x1d34,0x1d38,0x1d34,0x1d38,0x0000,0x3a3e,0x0000,0x0000,0x1d3c,0x1d40,0x1d3c,0x1d40,0x1d3c,0x1d40,0x1d3c,0x1d40,0x0000,0x3a4a,0x0000,0x0000,0x1d44,0x1d48,0x1d44,0x1d48,0x1d44,0x1d48,0x1d44,0x1d48,0x0000,0x3a56,0x0000,0x0000,0x1d4c,0x1d50,0x1d4c,0x1d50,0x1d4c,0x1d50,0x1d4c,0x1d50,0x0000,0x3a62,0x0000,0x0000,0x1d54,0x1d58,0x1d54,0x1d58,0x1d54,0x1d58,0x1d54,0x1d58,0x0000,0x3a6e,0x0000,0x0000,0x1d5c,0x1d60,0x1d5c,0x1d60,0x1d5c,0x1d60,0x1d5c,0x1d60,0x0000,0x3a7a,0x0000,0x0000,0x1d64,0x1d68,0x1d64,0x1d68,0x1d64,0x1d68,0x1d64,0x1d68,0x0000,0x3a86,0x0000,0x0000,0x1d6c,0x1d70,0x1d6c,0x1d70,0x1d6c,0x1d70,0x1d6c,0x1d70,0x0000,0x3a92,0x0000,0x0000,0x1d74,0x1d78,0x1d74,0x1d78,0x1d74,0x1d78,0x1d74,0x1d78,0x459a,0x3a9e,0x0000,0x0000,0x1d7c,0x1d80,0x1d7c,0x1d80,0x1d7c,0x1d80,0x1d7c,0x1d80,0x45a2,0x3aaa,0x0000,0x0000,0x1d84,0x1d88,0x1d84,0x1d88,0x1d84,0x1d88,0x1d84,0x1d88,0x0000,0x3ab5,0x0000,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x3ac6,0x0000,0x1d8c,0x1d90,0x1d8c,0x1d90,0x1d8c,0x1d90,0x1d8c,0x1d90,0x0000,0x3ad1,0x0000,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x3ae2,0x0000,0x1d94,0x1d98,0x1d94,0x1d98,0x1d94,0x1d98,0x1d94,0x1d98,0x0000,0x3aee,0x0000,0x0000,0x1d9c,0x1da0,0x1d9c,0x1da0,0x1d9c,0x1da0,0x1d9c,0x1da0,0x0000,0x3afa,0x0000,0x0000,0x1da4,0x1da8,0x1da4,0x1da8,0x1da4,0x1da8,0x1da4,0x1da8,0x457a,0x3b06,0x0000,0x0000,0x1dac,0x1db0,0x1dac,0x1db0,0x1dac,0x1db0,0x1dac,0x1db0,0x4582,0x3b12,0x0000,0x0000,0x1db4,0x1db8,0x1db4,0x1db8,0x1db4,0x1db8,0x1db4,0x1db8,0x0000,0x3b1e,0x0000,0x0000,0x0000,0x0000,0x1dbc,0x1dc0,0x1dbc,0x1dc0,0x0000,0x0000,0x0000,0x3b2a,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dc4,0x1dc8,0x0000,0x0000,0x0000,0x3b36,0x0000,0x0000,0x0000,0x0000,0x1dcc,0x1dd0,0x1dcc,0x1dd0,0x0000,0x0000,0x0000,0x3b42,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1dd4,0x1dd8,0x0000,0x0000,0x0000,0x0000,0x0000,0x3b4e,0x1ddc,0x1de0,0x1ddc,0x1de0,0x1ddc,0x1de0,0x1ddc,0x1de0,0x0000,0x3b5a,0x0000,0x0000,0x1de4,0x1de8,0x1de4,0x1de8,0x1de4,0x1de8,0x1de4,0x1de8,0x0000,0x3b66,0x0000,0x0000,0x1dec,0x1df0,0x1dec,0x1df0,0x1dec,0x1df0,0x1dec,0x1df0,0x0000,0x3b71,0x0000,0x0000,0x0000,0x3b82,0x0000,0x3b82,0x0000,0x3b82,0x0000,0x3b82,0x0000,0x3b82,0x0000,0x3b82,0x0000,0x3b82,0x0000,0x3b82,0x1df4,0x0000,0x1df4,0x0000,0x1df4,0x0000,0x1df4,0x0000,0x0000,0x3b8d,0x0000,0x0000,0x0000,0x3b9e,0x0000,0x3b9e,0x0000,0x3b9e,0x0000,0x3b9e,0x0000,0x3b9e,0x0000,0x3b9e,0x0000,0x3b9e,0x0000,0x3b9e,0x1df8,0x0000,0x1df8,0x0000,0x1df8,0x0000,0x1df8,0x0000,0x0000,0x3ba9,0x0000,0x0000,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x1dfc,0x0000,0x3bbd,0x0000,0x0000,0x0000,0x3bce,0x0000,0x3bce,0x0000,0x3bce,0x0000,0x3bce,0x0000,0x3bce,0x0000,0x3bce,0x0000,0x3bce,0x0000,0x3bce,0x1dfc,0x1e00,0x1dfc,0x1e00,0x1dfc,0x1e00,0x1dfc,0x1e00,0x0000,0x3bda,0x0000,0x0000,0x1e04,0x0000,0x1e04,0x0000,0x1e04,0x0000,0x1e04,0x0000,0x0000,0x3be6,0x0000,0x0000,0x1e08,0x0000,0x1e08,0x0000,0x1e08,0x0000,0x1e08,0x0000,0x0000,0x3bf2,0x0000,0x0000,0x1e0c,0x0000,0x1e0c,0x0000,0x1e0c,0x0000,0x1e0c,0x0000,0x0000,0x3bfe,0x0000,0x0000,0x1e14,0x1e10,0x1e14,0x1e10,0x1e14,0x1e10,0x1e14,0x1e10,0x0000,0x3c09,0x0000,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x3c1a,0x0000,0x0000,0x0000,0x1e18,0x1e1c,0x1e18,0x1e1c,0x0000,0x0000,0x0000,0x3c25,0x0000,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x3c36,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e20,0x1e24,0x0000,0x0000,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x3c4e,0x0000,0x1e28,0x0000,0x1e28,0x0000,0x1e28,0x0000,0x1e28,0x0000,0x3c66,0x0000,0x3c66,0x0000,0x3c66,0x0000,0x3c66,0x0000,0x3c66,0x0000,0x3c66,0x0000,0x3c66,0x0000,0x3c66,0x1e2c,0x0000,0x1e2c,0x0000,0x1e2c,0x0000,0x1e2c,0x0000,0x0000,0x3c72,0x0000,0x0000,0x1e30,0x1e38,0x1e30,0x1e38,0x1e30,0x1e38,0x1e30,0x1e38,0x0000,0x3c7e,0x0000,0x0000,0x1e34,0x1e3c,0x1e34,0x1e3c,0x1e34,0x1e3c,0x1e34,0x1e3c,0x0000,0x3c8a,0x0000,0x0000,0x1e40,0x1e48,0x1e40,0x1e48,0x1e40,0x1e48,0x1e40,0x1e48,0x0000,0x3c96,0x0000,0x0000,0x1e44,0x1e4c,0x1e44,0x1e4c,0x1e44,0x1e4c,0x1e44,0x1e4c,0x0000,0x3ca1,0x0000,0x0000,0x3cb2,0x3cba,0x3cb2,0x3cba,0x3cb2,0x3cba,0x3cb2,0x3cba,0x3cb2,0x3cba,0x3cb2,0x3cba,0x3cb2,0x3cba,0x3cb2,0x3cba,0x1e50,0x1e58,0x1e50,0x1e58,0x1e50,0x1e58,0x1e50,0x1e58,0x1e54,0x1e5c,0x1e54,0x1e5c,0x1e54,0x1e5c,0x1e54,0x1e5c,0x0000,0x3cc5,0x0000,0x0000,0x3cd6,0x3cde,0x3cd6,0x3cde,0x3cd6,0x3cde,0x3cd6,0x3cde,0x3cd6,0x3cde,0x3cd6,0x3cde,0x3cd6,0x3cde,0x3cd6,0x3cde,0x1e60,0x1e68,0x1e60,0x1e68,0x1e60,0x1e68,0x1e60,0x1e68,0x1e64,0x1e6c,0x1e64,0x1e6c,0x1e64,0x1e6c,0x1e64,0x1e6c,0x0000,0x3cea,0x0000,0x0000,0x1e70,0x1e74,0x1e70,0x1e74,0x1e70,0x1e74,0x1e70,0x1e74,0x0000,0x3cf6,0x0000,0x0000,0x1e78,0x0000,0x1e78,0x0000,0x1e78,0x0000,0x1e78,0x0000,0x0000,0x3d02,0x0000,0x0000,0x1e7c,0x0000,0x1e7c,0x0000,0x1e7c,0x0000,0x1e7c,0x0000,0x1e80,0x0000,0x1e80,0x0000,0x1e80,0x0000,0x1e80,0x0000,0x0000,0x3d16,0x0000,0x0000,0x1e84,0x0000,0x1e84,0x0000,0x1e84,0x0000,0x1e84,0x0000,0x0000,0x3d22,0x0000,0x0000,0x1e88,0x1e8c,0x1e88,0x1e8c,0x1e88,0x1e8c,0x1e88,0x1e8c,0x0000,0x3d2e,0x0000,0x0000,0x0000,0x0000,0x1e90,0x1ec4,0x1e90,0x1ec4,0x0000,0x0000,0x0000,0x3d3a,0x0000,0x0000,0x1e94,0x1e98,0x1e94,0x1e98,0x1e94,0x1e98,0x1e94,0x1e98,0x0000,0x3d46,0x0000,0x0000,0x1e9c,0x1ea0,0x1e9c,0x1ea0,0x1e9c,0x1ea0,0x1e9c,0x1ea0,0x0000,0x3d52,0x0000,0x0000,0x1ea4,0x1ea8,0x1ea4,0x1ea8,0x1ea4,0x1ea8,0x1ea4,0x1ea8,0x0000,0x3d5e,0x0000,0x0000,0x1eac,0x0000,0x1eac,0x0000,0x1eac,0x0000,0x1eac,0x0000,0x0000,0x3d6a,0x0000,0x0000,0x0000,0x1eb0,0x0000,0x1eb0,0x0000,0x1eb0,0x0000,0x1eb0,0x0000,0x3d76,0x0000,0x0000,0x1eb4,0x0000,0x1eb4,0x0000,0x1eb4,0x0000,0x1eb4,0x0000,0x0000,0x3d82,0x0000,0x0000,0x0000,0x1eb8,0x0000,0x1eb8,0x0000,0x1eb8,0x0000,0x1eb8,0x0000,0x3d8e,0x0000,0x0000,0x0000,0x0000,0x1ebc,0x1ec0,0x1ebc,0x1ec0,0x0000,0x0000,0x0000,0x3d9a,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ec8,0x0000,0x1ec8,0x0000,0x0000,0x0000,0x3da6,0x0000,0x0000,0x0000,0x0000,0x0000,0x1ecc,0x0000,0x1ecc,0x0000,0x0000,0x0000,0x3db2,0x0000,0x0000,0x1ed0,0x1ed4,0x1ed0,0x1ed4,0x1ed0,0x1ed4,0x1ed0,0x1ed4,0x0000,0x3dbe,0x0000,0x0000,0x1ed8,0x1edc,0x1ed8,0x1edc,0x1ed8,0x1edc,0x1ed8,0x1edc,0x0000,0x3dca,0x0000,0x0000,0x1ee0,0x1ee4,0x1ee0,0x1ee4,0x1ee0,0x1ee4,0x1ee0,0x1ee4,0x0000,0x3dd5,0x0000,0x0000,0x3de6,0x3dee,0x3de6,0x3dee,0x3de6,0x3dee,0x3de6,0x3dee,0x3de6,0x3dee,0x3de6,0x3dee,0x3de6,0x3dee,0x3de6,0x3dee,0x1ee8,0x1ef0,0x1ee8,0x1ef0,0x1ee8,0x1ef0,0x1ee8,0x1ef0,0x1eec,0x1ef4,0x1eec,0x1ef4,0x1eec,0x1ef4,0x1eec,0x1ef4,0x0000,0x3df9,0x0000,0x0000,0x3e0a,0x3e12,0x3e0a,0x3e12,0x3e0a,0x3e12,0x3e0a,0x3e12,0x3e0a,0x3e12,0x3e0a,0x3e12,0x3e0a,0x3e12,0x3e0a,0x3e12,0x1ef8,0x1f00,0x1ef8,0x1f00,0x1ef8,0x1f00,0x1ef8,0x1f00,0x1efc,0x1f04,0x1efc,0x1f04,0x1efc,0x1f04,0x1efc,0x1f04,0x0000,0x3e1d,0x0000,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x3e2e,0x0000,0x1f08,0x1f0c,0x1f08,0x1f0c,0x1f08,0x1f0c,0x1f08,0x1f0c,0x0000,0x3e39,0x0000,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x3e4a,0x0000,0x1f10,0x1f14,0x1f10,0x1f14,0x1f10,0x1f14,0x1f10,0x1f14,0x0000,0x3e56,0x0000,0x0000,0x1f18,0x1f1c,0x1f18,0x1f1c,0x1f18,0x1f1c,0x1f18,0x1f1c,0x0000,0x3e62,0x0000,0x0000,0x0000,0x1f20,0x0000,0x1f20,0x0000,0x1f20,0x0000,0x1f20,0x0000,0x3e6e,0x0000,0x0000,0x0000,0x1f24,0x0000,0x1f24,0x0000,0x1f24,0x0000,0x1f24,0x0000,0x3e86,0x0000,0x3e86,0x0000,0x3e86,0x0000,0x3e86,0x0000,0x3e86,0x0000,0x3e86,0x0000,0x3e86,0x0000,0x3e86,0x1f28,0x1f2c,0x1f28,0x1f2c,0x1f28,0x1f2c,0x1f28,0x1f2c,0x0000,0x3e9e,0x0000,0x3e9e,0x0000,0x3e9e,0x0000,0x3e9e,0x0000,0x3e9e,0x0000,0x3e9e,0x0000,0x3e9e,0x0000,0x3e9e,0x1f30,0x1f34,0x1f30,0x1f34,0x1f30,0x1f34,0x1f30,0x1f34,0x0000,0x3eb6,0x0000,0x3eb6,0x0000,0x3eb6,0x0000,0x3eb6,0x0000,0x3eb6,0x0000,0x3eb6,0x0000,0x3eb6,0x0000,0x3eb6,0x1f38,0x1f3c,0x1f38,0x1f3c,0x1f38,0x1f3c,0x1f38,0x1f3c,0x0000,0x3ece,0x0000,0x3ece,0x0000,0x3ece,0x0000,0x3ece,0x0000,0x3ece,0x0000,0x3ece,0x0000,0x3ece,0x0000,0x3ece,0x1f40,0x1f44,0x1f40,0x1f44,0x1f40,0x1f44,0x1f40,0x1f44,0x1f48,0x0000,0x1f48,0x0000,0x1f48,0x0000,0x1f48,0x0000,0x1f4c,0x0000,0x1f4c,0x0000,0x1f4c,0x0000,0x1f4c,0x0000,0x0000,0x4086,0x3eea,0x0000,0x1f50,0x0000,0x1f50,0x0000,0x1f50,0x0000,0x1f50,0x0000,0x1f54,0x0000,0x1f54,0x0000,0x1f54,0x0000,0x1f54,0x0000,0x1f58,0x0000,0x1f58,0x0000,0x1f58,0x0000,0x1f58,0x0000,0x0000,0x4072,0x3f06,0x0000,0x1f5c,0x0000,0x1f5c,0x0000,0x1f5c,0x0000,0x1f5c,0x0000,0x1f60,0x0000,0x1f60,0x0000,0x1f60,0x0000,0x1f60,0x0000,0x1f64,0x0000,0x1f64,0x0000,0x1f64,0x0000,0x1f64,0x0000,0x0000,0x405e,0x3f22,0x0000,0x1f68,0x0000,0x1f68,0x0000,0x1f68,0x0000,0x1f68,0x0000,0x1f6c,0x0000,0x1f6c,0x0000,0x1f6c,0x0000,0x1f6c,0x0000,0x1f70,0x0000,0x1f70,0x0000,0x1f70,0x0000,0x1f70,0x0000,0x1f74,0x0000,0x1f74,0x0000,0x1f74,0x0000,0x1f74,0x0000,0x1f78,0x0000,0x1f78,0x0000,0x1f78,0x0000,0x1f78,0x0000,0x1f7c,0x0000,0x1f7c,0x0000,0x1f7c,0x0000,0x1f7c,0x0000,0x0000,0x3f9e,0x3f56,0x0000,0x1f80,0x0000,0x1f80,0x0000,0x1f80,0x0000,0x1f80,0x0000,0x1f84,0x0000,0x1f84,0x0000,0x1f84,0x0000,0x1f84,0x0000,0x1f88,0x0000,0x1f88,0x0000,0x1f88,0x0000,0x1f88,0x0000,0x0000,0x3fae,0x3f72,0x0000,0x1f8c,0x0000,0x1f8c,0x0000,0x1f8c,0x0000,0x1f8c,0x0000,0x0000,0x3f7e,0x0000,0x0000,0x0000,0x1f90,0x0000,0x1f90,0x0000,0x1f90,0x0000,0x1f90,0x0000,0x3f8a,0x0000,0x0000,0x1f94,0x1f98,0x1f94,0x1f98,0x1f94,0x1f98,0x1f94,0x1f98,0x0000,0x3f96,0x0000,0x0000,0x1f9c,0x1fa0,0x1f9c,0x1fa0,0x1f9c,0x1fa0,0x1f9c,0x1fa0,0x1fa4,0x1fa8,0x1fa4,0x1fa8,0x1fa4,0x1fa8,0x1fa4,0x1fa8,0x1fac,0x1fb0,0x1fac,0x1fb0,0x1fac,0x1fb0,0x1fac,0x1fb0,0x1fb4,0x1fb8,0x1fb4,0x1fb8,0x1fb4,0x1fb8,0x1fb4,0x1fb8,0x1fbc,0x1fc0,0x1fbc,0x1fc0,0x1fbc,0x1fc0,0x1fbc,0x1fc0,0x0000,0x3fc1,0x0000,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x3fd2,0x0000,0x1fc4,0x1fc8,0x1fc4,0x1fc8,0x1fc4,0x1fc8,0x1fc4,0x1fc8,0x0000,0x3fdd,0x0000,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x3fee,0x0000,0x1fcc,0x1fd0,0x1fcc,0x1fd0,0x1fcc,0x1fd0,0x1fcc,0x1fd0,0x0000,0x3ffa,0x0000,0x0000,0x0000,0x1fd4,0x0000,0x1fd4,0x0000,0x1fd4,0x0000,0x1fd4,0x0000,0x4006,0x0000,0x0000,0x1fd8,0x1fdc,0x1fd8,0x1fdc,0x1fd8,0x1fdc,0x1fd8,0x1fdc,0x0000,0x4012,0x0000,0x0000,0x0000,0x1fe0,0x0000,0x1fe0,0x0000,0x1fe0,0x0000,0x1fe0,0x0000,0x401e,0x0000,0x0000,0x1fe4,0x1fe8,0x1fe4,0x1fe8,0x1fe4,0x1fe8,0x1fe4,0x1fe8,0x0000,0x402a,0x0000,0x0000,0x0000,0x1fec,0x0000,0x1fec,0x0000,0x1fec,0x0000,0x1fec,0x0000,0x4036,0x0000,0x0000,0x1ff0,0x1ff4,0x1ff0,0x1ff4,0x1ff0,0x1ff4,0x1ff0,0x1ff4,0x0000,0x1ff8,0x0000,0x1ff8,0x0000,0x1ff8,0x0000,0x1ff8,0x0000,0x404a,0x0000,0x0000,0x1ffc,0x2000,0x1ffc,0x2000,0x1ffc,0x2000,0x1ffc,0x2000,0x0000,0x4056,0x0000,0x0000,0x2004,0x0000,0x2004,0x0000,0x2004,0x0000,0x2004,0x0000,0x0000,0x2008,0x0000,0x2008,0x0000,0x2008,0x0000,0x2008,0x0000,0x406a,0x0000,0x0000,0x200c,0x2010,0x200c,0x2010,0x200c,0x2010,0x200c,0x2010,0x0000,0x2014,0x0000,0x2014,0x0000,0x2014,0x0000,0x2014,0x0000,0x407e,0x0000,0x0000,0x2018,0x201c,0x2018,0x201c,0x2018,0x201c,0x2018,0x201c,0x0000,0x2020,0x0000,0x2020,0x0000,0x2020,0x0000,0x2020,0x0000,0x4092,0x0000,0x0000,0x2024,0x2028,0x2024,0x2028,0x2024,0x2028,0x2024,0x2028,0x0000,0x409e,0x0000,0x0000,0x202c,0x2030,0x202c,0x2030,0x202c,0x2030,0x202c,0x2030,0x0000,0x40aa,0x40be,0x0000,0x2034,0x2038,0x2034,0x2038,0x2034,0x2038,0x2034,0x2038,0x0000,0x40b6,0x40c6,0x0000,0x203c,0x2040,0x203c,0x2040,0x203c,0x2040,0x203c,0x2040,0x2044,0x2048,0x2044,0x2048,0x2044,0x2048,0x2044,0x2048,0x204c,0x2050,0x204c,0x2050,0x204c,0x2050,0x204c,0x2050,0x0000,0x40d2,0x0000,0x0000,0x2054,0x2058,0x2054,0x2058,0x2054,0x2058,0x2054,0x2058,0x0000,0x40de,0x0000,0x0000,0x205c,0x2060,0x205c,0x2060,0x205c,0x2060,0x205c,0x2060,0x0000,0x40ea,0x0000,0x0000,0x2064,0x2068,0x2064,0x2068,0x2064,0x2068,0x2064,0x2068,0x0000,0x40f6,0x0000,0x0000,0x206c,0x2070,0x206c,0x2070,0x206c,0x2070,0x206c,0x2070,0x458a,0x4102,0x0000,0x0000,0x2074,0x2078,0x2074,0x2078,0x2074,0x2078,0x2074,0x2078,0x4592,0x410e,0x0000,0x0000,0x207c,0x2080,0x207c,0x2080,0x207c,0x2080,0x207c,0x2080,0x456a,0x411a,0x0000,0x0000,0x2084,0x0000,0x2084,0x0000,0x2084,0x0000,0x2084,0x0000,0x0000,0x4126,0x0000,0x0000,0x0000,0x2088,0x0000,0x2088,0x0000,0x2088,0x0000,0x2088,0x4572,0x4132,0x0000,0x0000,0x208c,0x0000,0x208c,0x0000,0x208c,0x0000,0x208c,0x0000,0x0000,0x413e,0x0000,0x0000,0x0000,0x2090,0x0000,0x2090,0x0000,0x2090,0x0000,0x2090,0x0000,0x414a,0x0000,0x0000,0x2094,0x2098,0x2094,0x2098,0x2094,0x2098,0x2094,0x2098,0x0000,0x4156,0x0000,0x0000,0x209c,0x20a0,0x209c,0x20a0,0x209c,0x20a0,0x209c,0x20a0,0x0000,0x4162,0x0000,0x0000,0x20a4,0x20a8,0x20a4,0x20a8,0x20a4,0x20a8,0x20a4,0x20a8,0x0000,0x416e,0x0000,0x0000,0x20ac,0x20b0,0x20ac,0x20b0,0x20ac,0x20b0,0x20ac,0x20b0,0x0000,0x4179,0x0000,0x0000,0x418a,0x0000,0x418a,0x0000,0x418a,0x0000,0x418a,0x0000,0x418a,0x0000,0x418a,0x0000,0x418a,0x0000,0x418a,0x0000,0x20b4,0x20b8,0x20b4,0x20b8,0x20b4,0x20b8,0x20b4,0x20b8,0x0000,0x4195,0x0000,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x41a6,0x0000,0x20bc,0x20c0,0x20bc,0x20c0,0x20bc,0x20c0,0x20bc,0x20c0,0x0000,0x41b2,0x0000,0x0000,0x0000,0x0000,0x20c4,0x20c8,0x20c4,0x20c8,0x0000,0x0000,0x0000,0x41be,0x0000,0x0000,0x0000,0x0000,0x20cc,0x20d0,0x20cc,0x20d0,0x0000,0x0000,0x41ca,0x41d2,0x0000,0x0000,0x20d4,0x0000,0x20d4,0x0000,0x20d4,0x0000,0x20d4,0x0000,0x0000,0x20d8,0x0000,0x20d8,0x0000,0x20d8,0x0000,0x20d8,0x41f5,0x41dd,0x0000,0x0000,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x41ee,0x0000,0x0000,0x20dc,0x20e4,0x0000,0x0000,0x0000,0x0000,0x0000,0x4206,0x0000,0x4206,0x0000,0x4206,0x0000,0x4206,0x0000,0x4206,0x0000,0x4206,0x0000,0x4206,0x0000,0x4206,0x0000,0x0000,0x20e0,0x20e8,0x0000,0x0000,0x0000,0x0000,0x4229,0x4211,0x0000,0x0000,0x0000,0x4222,0x0000,0x4222,0x0000,0x4222,0x0000,0x4222,0x0000,0x4222,0x0000,0x4222,0x0000,0x4222,0x0000,0x4222,0x0000,0x0000,0x20ec,0x20f4,0x0000,0x0000,0x0000,0x0000,0x0000,0x423a,0x0000,0x423a,0x0000,0x423a,0x0000,0x423a,0x0000,0x423a,0x0000,0x423a,0x0000,0x423a,0x0000,0x423a,0x0000,0x0000,0x20f0,0x20f8,0x0000,0x0000,0x0000,0x0000,0x425d,0x4245,0x0000,0x0000,0x0000,0x4256,0x0000,0x4256,0x0000,0x4256,0x0000,0x4256,0x0000,0x4256,0x0000,0x4256,0x0000,0x4256,0x0000,0x4256,0x20fc,0x2104,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x426e,0x0000,0x426e,0x0000,0x426e,0x0000,0x426e,0x0000,0x426e,0x0000,0x426e,0x0000,0x426e,0x0000,0x426e,0x2100,0x2108,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4291,0x4279,0x0000,0x0000,0x0000,0x428a,0x0000,0x428a,0x0000,0x428a,0x0000,0x428a,0x0000,0x428a,0x0000,0x428a,0x0000,0x428a,0x0000,0x428a,0x0000,0x0000,0x210c,0x2114,0x0000,0x0000,0x0000,0x0000,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x42a2,0x0000,0x0000,0x2110,0x2118,0x0000,0x0000,0x0000,0x0000,0x42c5,0x42ad,0x0000,0x0000,0x0000,0x42be,0x0000,0x42be,0x0000,0x42be,0x0000,0x42be,0x0000,0x42be,0x0000,0x42be,0x0000,0x42be,0x0000,0x42be,0x0000,0x0000,0x211c,0x2124,0x0000,0x0000,0x0000,0x0000,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x42d6,0x0000,0x0000,0x2120,0x2128,0x0000,0x0000,0x0000,0x0000,0x42f9,0x42e1,0x0000,0x0000,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x42f2,0x0000,0x0000,0x212c,0x2134,0x0000,0x0000,0x0000,0x0000,0x0000,0x430a,0x0000,0x430a,0x0000,0x430a,0x0000,0x430a,0x0000,0x430a,0x0000,0x430a,0x0000,0x430a,0x0000,0x430a,0x0000,0x0000,0x2130,0x2138,0x0000,0x0000,0x0000,0x0000,0x432d,0x4315,0x0000,0x0000,0x0000,0x4326,0x0000,0x4326,0x0000,0x4326,0x0000,0x4326,0x0000,0x4326,0x0000,0x4326,0x0000,0x4326,0x0000,0x4326,0x0000,0x0000,0x213c,0x2144,0x0000,0x0000,0x0000,0x0000,0x0000,0x433e,0x0000,0x433e,0x0000,0x433e,0x0000,0x433e,0x0000,0x433e,0x0000,0x433e,0x0000,0x433e,0x0000,0x433e,0x0000,0x0000,0x2140,0x2148,0x0000,0x0000,0x0000,0x0000,0x4361,0x4349,0x0000,0x0000,0x0000,0x435a,0x0000,0x435a,0x0000,0x435a,0x0000,0x435a,0x0000,0x435a,0x0000,0x435a,0x0000,0x435a,0x0000,0x435a,0x0000,0x0000,0x214c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4372,0x0000,0x4372,0x0000,0x4372,0x0000,0x4372,0x0000,0x4372,0x0000,0x4372,0x0000,0x4372,0x0000,0x4372,0x0000,0x0000,0x2150,0x2154,0x0000,0x0000,0x0000,0x0000,0x4395,0x437d,0x0000,0x0000,0x0000,0x438e,0x0000,0x438e,0x0000,0x438e,0x0000,0x438e,0x0000,0x438e,0x0000,0x438e,0x0000,0x438e,0x0000,0x438e,0x2158,0x2160,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x43a6,0x0000,0x43a6,0x0000,0x43a6,0x0000,0x43a6,0x0000,0x43a6,0x0000,0x43a6,0x0000,0x43a6,0x0000,0x43a6,0x215c,0x2164,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x43ba,0x43b2,0x0000,0x0000,0x2168,0x2170,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x216c,0x2174,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x43dd,0x43c5,0x0000,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x43d6,0x0000,0x2178,0x2180,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x43ee,0x0000,0x217c,0x2184,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4415,0x43f9,0x0000,0x442d,0x0000,0x440a,0x0000,0x440a,0x0000,0x440a,0x0000,0x440a,0x0000,0x440a,0x0000,0x440a,0x0000,0x440a,0x0000,0x440a,0x2188,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4415,0x43f9,0x0000,0x4445,0x0000,0x4426,0x0000,0x4426,0x0000,0x4426,0x0000,0x4426,0x0000,0x4426,0x0000,0x4426,0x0000,0x4426,0x0000,0x4426,0x218c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x443e,0x0000,0x443e,0x0000,0x443e,0x0000,0x443e,0x0000,0x443e,0x0000,0x443e,0x0000,0x443e,0x0000,0x443e,0x2190,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4456,0x0000,0x4456,0x0000,0x4456,0x0000,0x4456,0x0000,0x4456,0x0000,0x4456,0x0000,0x4456,0x0000,0x4456,0x2190,0x2194,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x447d,0x4461,0x0000,0x4495,0x0000,0x4472,0x0000,0x4472,0x0000,0x4472,0x0000,0x4472,0x0000,0x4472,0x0000,0x4472,0x0000,0x4472,0x0000,0x4472,0x2198,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x447d,0x4461,0x0000,0x44ad,0x0000,0x448e,0x0000,0x448e,0x0000,0x448e,0x0000,0x448e,0x0000,0x448e,0x0000,0x448e,0x0000,0x448e,0x0000,0x448e,0x219c,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44a6,0x0000,0x44a6,0x0000,0x44a6,0x0000,0x44a6,0x0000,0x44a6,0x0000,0x44a6,0x0000,0x44a6,0x0000,0x44a6,0x21a0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44be,0x0000,0x44be,0x0000,0x44be,0x0000,0x44be,0x0000,0x44be,0x0000,0x44be,0x0000,0x44be,0x0000,0x44be,0x21a0,0x21a4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44e1,0x44c9,0x0000,0x0000,0x0000,0x44da,0x0000,0x44da,0x0000,0x44da,0x0000,0x44da,0x0000,0x44da,0x0000,0x44da,0x0000,0x44da,0x0000,0x44da,0x21a8,0x21b0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44f2,0x0000,0x44f2,0x0000,0x44f2,0x0000,0x44f2,0x0000,0x44f2,0x0000,0x44f2,0x0000,0x44f2,0x0000,0x44f2,0x21ac,0x21b4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x44fd,0x0000,0x0000,0x0000,0x450e,0x0000,0x450e,0x0000,0x450e,0x0000,0x450e,0x0000,0x450e,0x0000,0x450e,0x0000,0x450e,0x0000,0x450e,0x21b8,0x21bc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4519,0x0000,0x0000,0x0000,0x452a,0x0000,0x452a,0x0000,0x452a,0x0000,0x452a,0x0000,0x452a,0x0000,0x452a,0x0000,0x452a,0x0000,0x452a,0x21c0,0x21c4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4535,0x0000,0x0000,0x0000,0x4546,0x0000,0x4546,0x0000,0x4546,0x0000,0x4546,0x0000,0x4546,0x0000,0x4546,0x0000,0x4546,0x0000,0x4546,0x21c8,0x21cc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4551,0x0000,0x0000,0x0000,0x4562,0x0000,0x4562,0x0000,0x4562,0x0000,0x4562,0x0000,0x4562,0x0000,0x4562,0x0000,0x4562,0x0000,0x4562,0x21d0,0x21d4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x21d8,0x0000,0x21d8,0x0000,0x21d8,0x0000,0x21d8,0x0000,0x21dc,0x0000,0x21dc,0x0000,0x21dc,0x0000,0x21dc,0x0000,0x21e0,0x0000,0x21e0,0x0000,0x21e0,0x0000,0x21e0,0x0000,0x21e4,0x0000,0x21e4,0x0000,0x21e4,0x0000,0x21e4,0x0000,0x21e8,0x0000,0x21e8,0x0000,0x21e8,0x0000,0x21e8,0x0000,0x21ec,0x0000,0x21ec,0x0000,0x21ec,0x0000,0x21ec,0x0000,0x21f0,0x0000,0x21f0,0x0000,0x21f0,0x0000,0x21f0,0x0000,0x21f4,0x0000,0x21f4,0x0000,0x21f4,0x0000,0x21f4,0x0000,0x45ae,0x0000,0x45b6,0x0000,0x21f8,0x0000,0x21f8,0x0000,0x21f8,0x0000,0x21f8,0x0000,0x21fc,0x0000,0x21fc,0x0000,0x21fc,0x0000,0x21fc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x46bf,0x46e3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4707,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x471b,0x0000,0x471f,0x4723,0x4727,0x4733,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x473f,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4753,0x4767,0x477b,0x479f,0x47bb,0x47cf,0x47e3,0x47f7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x480b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4817,0x482b,0x483f,0x4853,0x485f,0x4873,0x4897,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x46c1,0x0000,0x46d2,0x46da,0x46d2,0x46da,0x46d2,0x46da,0x46d2,0x46da,0x46d2,0x46da,0x46d2,0x46da,0x46d2,0x46da,0x46d2,0x46da,0x2200,0x0000,0x2200,0x0000,0x2200,0x0000,0x2200,0x0000,0x2204,0x0000,0x2204,0x0000,0x2204,0x0000,0x2204,0x0000,0x0000,0x0000,0x46e5,0x0000,0x46f6,0x46fe,0x46f6,0x46fe,0x46f6,0x46fe,0x46f6,0x46fe,0x46f6,0x46fe,0x46f6,0x46fe,0x46f6,0x46fe,0x46f6,0x46fe,0x2208,0x0000,0x2208,0x0000,0x2208,0x0000,0x2208,0x0000,0x220c,0x0000,0x220c,0x0000,0x220c,0x0000,0x220c,0x0000,0x470a,0x4712,0x0000,0x0000,0x2210,0x0000,0x2210,0x0000,0x2210,0x0000,0x2210,0x0000,0x2214,0x0000,0x2214,0x0000,0x2214,0x0000,0x2214,0x0000,0x0000,0x0000,0x2218,0x0000,0x0000,0x0000,0x221c,0x0000,0x0000,0x0000,0x2220,0x0000,0x472a,0x0000,0x0000,0x0000,0x2224,0x0000,0x2224,0x0000,0x2224,0x0000,0x2224,0x0000,0x4736,0x0000,0x0000,0x0000,0x2228,0x0000,0x2228,0x0000,0x2228,0x0000,0x2228,0x0000,0x4742,0x0000,0x474a,0x0000,0x222c,0x0000,0x222c,0x0000,0x222c,0x0000,0x222c,0x0000,0x2230,0x0000,0x2230,0x0000,0x2230,0x0000,0x2230,0x0000,0x4756,0x0000,0x475e,0x0000,0x2234,0x0000,0x2234,0x0000,0x2234,0x0000,0x2234,0x0000,0x2238,0x0000,0x2238,0x0000,0x2238,0x0000,0x2238,0x0000,0x476a,0x0000,0x4772,0x0000,0x223c,0x0000,0x223c,0x0000,0x223c,0x0000,0x223c,0x0000,0x2240,0x0000,0x2240,0x0000,0x2240,0x0000,0x2240,0x0000,0x477e,0x4786,0x478e,0x4796,0x2244,0x0000,0x2244,0x0000,0x2244,0x0000,0x2244,0x0000,0x0000,0x2248,0x0000,0x2248,0x0000,0x2248,0x0000,0x2248,0x224c,0x0000,0x224c,0x0000,0x224c,0x0000,0x224c,0x0000,0x0000,0x2250,0x0000,0x2250,0x0000,0x2250,0x0000,0x2250,0x47a2,0x47aa,0x47b2,0x0000,0x2254,0x2258,0x2254,0x2258,0x2254,0x2258,0x2254,0x2258,0x225c,0x0000,0x225c,0x0000,0x225c,0x0000,0x225c,0x0000,0x2260,0x0000,0x2260,0x0000,0x2260,0x0000,0x2260,0x0000,0x47be,0x0000,0x47c6,0x0000,0x2264,0x0000,0x2264,0x0000,0x2264,0x0000,0x2264,0x0000,0x2268,0x0000,0x2268,0x0000,0x2268,0x0000,0x2268,0x0000,0x47d2,0x0000,0x47da,0x0000,0x226c,0x0000,0x226c,0x0000,0x226c,0x0000,0x226c,0x0000,0x2270,0x0000,0x2270,0x0000,0x2270,0x0000,0x2270,0x0000,0x47e6,0x0000,0x47ee,0x0000,0x2274,0x0000,0x2274,0x0000,0x2274,0x0000,0x2274,0x0000,0x2278,0x0000,0x2278,0x0000,0x2278,0x0000,0x2278,0x0000,0x47fa,0x0000,0x4802,0x0000,0x227c,0x0000,0x227c,0x0000,0x227c,0x0000,0x227c,0x0000,0x2280,0x0000,0x2280,0x0000,0x2280,0x0000,0x2280,0x0000,0x0000,0x480e,0x0000,0x0000,0x2284,0x2284,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x481a,0x4822,0x2290,0x0000,0x2288,0x0000,0x2288,0x0000,0x2288,0x0000,0x2288,0x0000,0x228c,0x0000,0x228c,0x0000,0x228c,0x0000,0x228c,0x0000,0x482e,0x4836,0x229c,0x0000,0x2294,0x0000,0x2294,0x0000,0x2294,0x0000,0x2294,0x0000,0x2298,0x0000,0x2298,0x0000,0x2298,0x0000,0x2298,0x0000,0x0000,0x4842,0x0000,0x484a,0x22a0,0x0000,0x22a0,0x0000,0x22a0,0x0000,0x22a0,0x0000,0x22a4,0x22a8,0x22a4,0x22a8,0x22a4,0x22a8,0x22a4,0x22a8,0x0000,0x4856,0x22b0,0x0000,0x22ac,0x0000,0x22ac,0x0000,0x22ac,0x0000,0x22ac,0x0000,0x4862,0x486a,0x0000,0x0000,0x22b4,0x0000,0x22b4,0x0000,0x22b4,0x0000,0x22b4,0x0000,0x22b8,0x0000,0x22b8,0x0000,0x22b8,0x0000,0x22b8,0x0000,0x4876,0x487e,0x4886,0x488e,0x22bc,0x0000,0x22bc,0x0000,0x22bc,0x0000,0x22bc,0x0000,0x22c0,0x0000,0x22c0,0x0000,0x22c0,0x0000,0x22c0,0x0000,0x22c4,0x0000,0x22c4,0x0000,0x22c4,0x0000,0x22c4,0x0000,0x22c8,0x0000,0x22c8,0x0000,0x22c8,0x0000,0x22c8,0x0000,0x0000,0x489a,0x0000,0x0000,0x22cc,0x22cc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x49a3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x49b7,0x49c3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x49cf,0x49db,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x49e7,0x49f3,0x49ff,0x4a0b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4a17,0x4a2b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4a67,0x4a8b,0x4aaf,0x4ad3,0x4af7,0x4b1b,0x4b3f,0x4b63,0x4b87,0x4bab,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4a73,0x4a97,0x4abb,0x4adf,0x4b03,0x4b27,0x4b4b,0x4b6f,0x4b93,0x4bb7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4a7f,0x4aa3,0x4ac7,0x4aeb,0x4b0f,0x4b33,0x4b57,0x4b7b,0x4b9f,0x4bc3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4a3f,0x4a53,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x49ae,0x49a6,0x0000,0x0000,0x22d0,0x0000,0x22d0,0x0000,0x22d0,0x0000,0x22d0,0x0000,0x22d4,0x0000,0x22d4,0x0000,0x22d4,0x0000,0x22d4,0x0000,0x0000,0x49ba,0x0000,0x0000,0x22d8,0x0000,0x22d8,0x0000,0x22d8,0x0000,0x22d8,0x0000,0x0000,0x49c6,0x0000,0x0000,0x22dc,0x0000,0x22dc,0x0000,0x22dc,0x0000,0x22dc,0x0000,0x0000,0x49d2,0x0000,0x0000,0x22e0,0x0000,0x22e0,0x0000,0x22e0,0x0000,0x22e0,0x0000,0x0000,0x49de,0x0000,0x0000,0x22e4,0x0000,0x22e4,0x0000,0x22e4,0x0000,0x22e4,0x0000,0x0000,0x49ea,0x0000,0x0000,0x22e8,0x0000,0x22e8,0x0000,0x22e8,0x0000,0x22e8,0x0000,0x0000,0x49f6,0x0000,0x0000,0x22ec,0x0000,0x22ec,0x0000,0x22ec,0x0000,0x22ec,0x0000,0x0000,0x4a02,0x0000,0x0000,0x22f0,0x0000,0x22f0,0x0000,0x22f0,0x0000,0x22f0,0x0000,0x0000,0x4a0e,0x0000,0x0000,0x22f4,0x0000,0x22f4,0x0000,0x22f4,0x0000,0x22f4,0x0000,0x0000,0x0000,0x4a1a,0x4a22,0x22f8,0x0000,0x22f8,0x0000,0x22f8,0x0000,0x22f8,0x0000,0x22fc,0x0000,0x22fc,0x0000,0x22fc,0x0000,0x22fc,0x0000,0x0000,0x0000,0x4a2e,0x4a36,0x2300,0x0000,0x2300,0x0000,0x2300,0x0000,0x2300,0x0000,0x2304,0x0000,0x2304,0x0000,0x2304,0x0000,0x2304,0x0000,0x0000,0x0000,0x4a42,0x4a4a,0x2308,0x0000,0x2308,0x0000,0x2308,0x0000,0x2308,0x0000,0x230c,0x0000,0x230c,0x0000,0x230c,0x0000,0x230c,0x0000,0x0000,0x0000,0x4a56,0x4a5e,0x2310,0x0000,0x2310,0x0000,0x2310,0x0000,0x2310,0x0000,0x2314,0x0000,0x2314,0x0000,0x2314,0x0000,0x2314,0x0000,0x0000,0x4a6a,0x0000,0x0000,0x2318,0x0000,0x2318,0x0000,0x2318,0x0000,0x2318,0x0000,0x0000,0x4a76,0x0000,0x0000,0x231c,0x0000,0x231c,0x0000,0x231c,0x0000,0x231c,0x0000,0x0000,0x4a82,0x0000,0x0000,0x2320,0x0000,0x2320,0x0000,0x2320,0x0000,0x2320,0x0000,0x0000,0x4a8e,0x0000,0x0000,0x2324,0x0000,0x2324,0x0000,0x2324,0x0000,0x2324,0x0000,0x0000,0x4a9a,0x0000,0x0000,0x2328,0x0000,0x2328,0x0000,0x2328,0x0000,0x2328,0x0000,0x0000,0x4aa6,0x0000,0x0000,0x232c,0x0000,0x232c,0x0000,0x232c,0x0000,0x232c,0x0000,0x0000,0x4ab2,0x0000,0x0000,0x2330,0x0000,0x2330,0x0000,0x2330,0x0000,0x2330,0x0000,0x0000,0x4abe,0x0000,0x0000,0x2334,0x0000,0x2334,0x0000,0x2334,0x0000,0x2334,0x0000,0x0000,0x4aca,0x0000,0x0000,0x2338,0x0000,0x2338,0x0000,0x2338,0x0000,0x2338,0x0000,0x0000,0x4ad6,0x0000,0x0000,0x233c,0x0000,0x233c,0x0000,0x233c,0x0000,0x233c,0x0000,0x0000,0x4ae2,0x0000,0x0000,0x2340,0x0000,0x2340,0x0000,0x2340,0x0000,0x2340,0x0000,0x0000,0x4aee,0x0000,0x0000,0x2344,0x0000,0x2344,0x0000,0x2344,0x0000,0x2344,0x0000,0x0000,0x4afa,0x0000,0x0000,0x2348,0x0000,0x2348,0x0000,0x2348,0x0000,0x2348,0x0000,0x0000,0x4b06,0x0000,0x0000,0x234c,0x0000,0x234c,0x0000,0x234c,0x0000,0x234c,0x0000,0x0000,0x4b12,0x0000,0x0000,0x2350,0x0000,0x2350,0x0000,0x2350,0x0000,0x2350,0x0000,0x0000,0x4b1e,0x0000,0x0000,0x2354,0x0000,0x2354,0x0000,0x2354,0x0000,0x2354,0x0000,0x0000,0x4b2a,0x0000,0x0000,0x2358,0x0000,0x2358,0x0000,0x2358,0x0000,0x2358,0x0000,0x0000,0x4b36,0x0000,0x0000,0x235c,0x0000,0x235c,0x0000,0x235c,0x0000,0x235c,0x0000,0x0000,0x4b42,0x0000,0x0000,0x2360,0x0000,0x2360,0x0000,0x2360,0x0000,0x2360,0x0000,0x0000,0x4b4e,0x0000,0x0000,0x2364,0x0000,0x2364,0x0000,0x2364,0x0000,0x2364,0x0000,0x0000,0x4b5a,0x0000,0x0000,0x2368,0x0000,0x2368,0x0000,0x2368,0x0000,0x2368,0x0000,0x0000,0x4b66,0x0000,0x0000,0x236c,0x0000,0x236c,0x0000,0x236c,0x0000,0x236c,0x0000,0x0000,0x4b72,0x0000,0x0000,0x2370,0x0000,0x2370,0x0000,0x2370,0x0000,0x2370,0x0000,0x0000,0x4b7e,0x0000,0x0000,0x2374,0x0000,0x2374,0x0000,0x2374,0x0000,0x2374,0x0000,0x0000,0x4b8a,0x0000,0x0000,0x2378,0x0000,0x2378,0x0000,0x2378,0x0000,0x2378,0x0000,0x0000,0x4b96,0x0000,0x0000,0x237c,0x0000,0x237c,0x0000,0x237c,0x0000,0x237c,0x0000,0x0000,0x4ba2,0x0000,0x0000,0x2380,0x0000,0x2380,0x0000,0x2380,0x0000,0x2380,0x0000,0x0000,0x4bae,0x0000,0x0000,0x2384,0x0000,0x2384,0x0000,0x2384,0x0000,0x2384,0x0000,0x0000,0x4bba,0x0000,0x0000,0x2388,0x0000,0x2388,0x0000,0x2388,0x0000,0x2388,0x0000,0x0000,0x4bc6,0x0000,0x0000,0x238c,0x0000,0x238c,0x0000,0x238c,0x0000,0x238c,0x0000,
#elif defined(FD_DECODE_TABLE_DESCS)
{0},{FDI_ADD, 2059, 1280, 16393},{FDI_ADD, 2059, 1034, 16393},{FDI_ADD, 14, 1280, 16393},{FDI_ADD, 14, 1034, 16393},{FDI_ADD, 20656, 1344, 64},{FDI_ADD, 16560, 1184, 64},{FDI_PUSH, 12, 1032, 24},{FDI_POP, 12, 1032, 24},{FDI_OR, 2059, 1280, 16393},{FDI_OR, 2059, 1034, 16393},{FDI_OR, 14, 1280, 16393},{FDI_OR, 14, 1034, 16393},{FDI_OR, 20656, 1344, 64},{FDI_OR, 16560, 1184, 64},{FDI_ADC, 2059, 1280, 16393},{FDI_ADC, 2059, 1034, 16393},{FDI_ADC, 14, 1280, 16393},{FDI_ADC, 14, 1034, 16393},{FDI_ADC, 20656, 1344, 64},{FDI_ADC, 16560, 1184, 64},{FDI_SBB, 2059, 1280, 16393},{FDI_SBB, 2059, 1034, 16393},{FDI_SBB, 14, 1280, 16393},{FDI_SBB, 14, 1034, 16393},{FDI_SBB, 20656, 1344, 64},{FDI_SBB, 16560, 1184, 64},{FDI_AND, 2059, 1280, 16393},{FDI_AND, 2059, 1034, 16393},{FDI_AND, 14, 1280, 16393},{FDI_AND, 14, 1034, 16393},{FDI_AND, 20656, 1344, 64},{FDI_AND, 16560, 1184, 64},{FDI_DAA, 0, 1024, 0},{FDI_SUB, 2059, 1280, 16393},{FDI_SUB, 2059, 1034, 16393},{FDI_SUB, 14, 1280, 16393},{FDI_SUB, 14, 1034, 16393},{FDI_SUB, 20656, 1344, 64},{FDI_SUB, 16560, 1184, 64},{FDI_DAS, 0, 1024, 0},{FDI_XOR, 2059, 1280, 16393},{FDI_XOR, 2059, 1034, 16393},{FDI_XOR, 14, 1280, 16393},{FDI_XOR, 14, 1034, 16393},{FDI_XOR, 20656, 1344, 64},{FDI_XOR, 16560, 1184, 64},{FDI_AAA, 0, 1024, 0},{FDI_CMP, 11, 1280, 16393},{FDI_CMP, 11, 1034, 16393},{FDI_CMP, 14, 1280, 16393},{FDI_CMP, 14, 1034, 16393},{FDI_CMP, 20656, 1344, 64},{FDI_CMP, 16560, 1184, 64},{FDI_AAS, 0, 1024, 0},{FDI_INC, 3, 1026, 1},{FDI_DEC, 3, 1026, 1},{FDI_PUSH, 3, 1026, 4097},{FDI_POP, 3, 1026, 4097},{FDI_PUSHA, 0, 34048, 0},{FDI_POPA, 0, 34048, 0},{FDI_BOUND, 14, 1034, 16392},{FDI_ARPL, 11, 2048, 16393},{FDI_MOVSX, 14, 3336, 16393},{FDI_PUSH, 16576, 1152, 4096},{FDI_IMUL, 16462, 1162, 16393},{FDI_PUSH, 20672, 1024, 4096},{FDI_IMUL, 20558, 1034, 16393},{FDI_INS, 0, 1280, 0},{FDI_INS, 0, 34048, 0},{FDI_OUTS, 0, 1280, 0},{FDI_OUTS, 0, 34048, 0},{FDI_JO, 28864, 1024, 6144},{FDI_JNO, 28864, 1024, 6144},{FDI_JC, 28864, 1024, 6144},{FDI_JNC, 28864, 1024, 6144},{FDI_JZ, 28864, 1024, 6144},{FDI_JNZ, 28864, 1024, 6144},{FDI_JBE, 28864, 1024, 6144},{FDI_JA, 28864, 1024, 6144},{FDI_JS, 28864, 1024, 6144},{FDI_JNS, 28864, 1024, 6144},{FDI_JP, 28864, 1024, 6144},{FDI_JNP, 28864, 1024, 6144},{FDI_JL, 28864, 1024, 6144},{FDI_JGE, 28864, 1024, 6144},{FDI_JLE, 28864, 1024, 6144},{FDI_JG, 28864, 1024, 6144},{FDI_ADD, 22659, 1344, 16385},{FDI_OR, 22659, 1344, 16385},{FDI_ADC, 22659, 1344, 16385},{FDI_SBB, 22659, 1344, 16385},{FDI_AND, 22659, 1344, 16385},{FDI_SUB, 22659, 1344, 16385},{FDI_XOR, 22659, 1344, 16385},{FDI_CMP, 20611, 1344, 16385},{FDI_ADD, 18563, 1154, 16385},{FDI_OR, 18563, 1154, 16385},{FDI_ADC, 18563, 1154, 16385},{FDI_SBB, 18563, 1154, 16385},{FDI_AND, 18563, 1154, 16385},{FDI_SUB, 18563, 1154, 16385},{FDI_XOR, 18563, 1154, 16385},{FDI_CMP, 16515, 1154, 16385},{FDI_ADD, 22659, 1026, 16385},{FDI_OR, 22659, 1026, 16385},{FDI_ADC, 22659, 1026, 16385},{FDI_SBB, 22659, 1026, 16385},{FDI_AND, 22659, 1026, 16385},{FDI_SUB, 22659, 1026, 16385},{FDI_XOR, 22659, 1026, 16385},{FDI_CMP, 20611, 1026, 16385},{FDI_TEST, 11, 1280, 16393},{FDI_TEST, 11, 1034, 16393},{FDI_XCHG, 2059, 1280, 16393},{FDI_XCHG, 2059, 1034, 16393},{FDI_MOV, 11, 1280, 16393},{FDI_MOV, 11, 1034, 16393},{FDI_MOV, 14, 1280, 16393},{FDI_MOV, 14, 1034, 16393},{FDI_MOV_S2G, 11, 2048, 16409},{FDI_LEA, 14, 8, 16392},{FDI_MOV_G2S, 14, 2048, 16409},{FDI_POP, 3, 1026, 20481},{FDI_XCHG_NOP, 35, 1314, 65},{FDI_C_EX, 0, 34048, 0},{FDI_C_SEP, 0, 34048, 0},{FDI_CALLF, 16576, 1152, 0},{FDI_FWAIT, 0, 1024, 0},{FDI_PUSHF, 0, 34048, 4096},{FDI_POPF, 0, 34048, 4096},{FDI_SAHF, 0, 1024, 0},{FDI_LAHF, 0, 1024, 0},{FDI_MOV, 8368, 1280, 64},{FDI_MOV, 8368, 1184, 64},{FDI_MOV, 8416, 1280, 64},{FDI_MOV, 8416, 1184, 64},{FDI_MOVS, 0, 1280, 0},{FDI_MOVS, 0, 34048, 0},{FDI_CMPS, 0, 1280, 0},{FDI_CMPS, 0, 34048, 0},{FDI_TEST, 20656, 1344, 64},{FDI_TEST, 16560, 1184, 64},{FDI_STOS, 0, 1280, 0},{FDI_STOS, 0, 34048, 0},{FDI_LODS, 0, 1280, 0},{FDI_LODS, 0, 34048, 0},{FDI_SCAS, 0, 1280, 0},{FDI_SCAS, 0, 34048, 0},{FDI_MOVABS, 20611, 1344, 1},{FDI_MOVABS, 16515, 1154, 1},{FDI_ROL, 20611, 1344, 16385},{FDI_ROR, 20611, 1344, 16385},{FDI_RCL, 20611, 1344, 16385},{FDI_RCR, 20611, 1344, 16385},{FDI_SHL, 20611, 1344, 16385},{FDI_SHR, 20611, 1344, 16385},{FDI_SAR, 20611, 1344, 16385},{FDI_ROL, 20611, 1090, 16385},{FDI_ROR, 20611, 1090, 16385},{FDI_RCL, 20611, 1090, 16385},{FDI_RCR, 20611, 1090, 16385},{FDI_SHL, 20611, 1090, 16385},{FDI_SHR, 20611, 1090, 16385},{FDI_SAR, 20611, 1090, 16385},{FDI_RET, 16576, 35072, 6144},{FDI_RET, 0, 34048, 6144},{FDI_LES, 14, 1034, 16392},{FDI_LDS, 14, 1034, 16392},{FDI_MOV, 20611, 1344, 16385},{FDI_XABORT, 20672, 1088, 16384},{FDI_MOV, 16515, 1154, 16385},{FDI_XBEGIN, 24768, 3072, 16384},{FDI_XBEGIN, 24768, 4096, 16384},{FDI_ENTER, 16576, 36096, 4096},{FDI_LEAVE, 0, 34048, 4096},{FDI_RETF, 16576, 35072, 0},{FDI_RETF, 0, 34048, 0},{FDI_INT3, 0, 1024, 0},{FDI_INT, 20672, 1088, 0},{FDI_INTO, 0, 1024, 0},{FDI_IRET, 0, 34048, 0},{FDI_ROL, 4227, 1280, 16385},{FDI_ROR, 4227, 1280, 16385},{FDI_RCL, 4227, 1280, 16385},{FDI_RCR, 4227, 1280, 16385},{FDI_SHL, 4227, 1280, 16385},{FDI_SHR, 4227, 1280, 16385},{FDI_SAR, 4227, 1280, 16385},{FDI_ROL, 4227, 1026, 16385},{FDI_ROR, 4227, 1026, 16385},{FDI_RCL, 4227, 1026, 16385},{FDI_RCR, 4227, 1026, 16385},{FDI_SHL, 4227, 1026, 16385},{FDI_SHR, 4227, 1026, 16385},{FDI_SAR, 4227, 1026, 16385},{FDI_ROL, 1059, 1280, 16449},{FDI_ROR, 1059, 1280, 16449},{FDI_RCL, 1059, 1280, 16449},{FDI_RCR, 1059, 1280, 16449},{FDI_SHL, 1059, 1280, 16449},{FDI_SHR, 1059, 1280, 16449},{FDI_SAR, 1059, 1280, 16449},{FDI_ROL, 1059, 1026, 16449},{FDI_ROR, 1059, 1026, 16449},{FDI_RCL, 1059, 1026, 16449},{FDI_RCR, 1059, 1026, 16449},{FDI_SHL, 1059, 1026, 16449},{FDI_SHR, 1059, 1026, 16449},{FDI_SAR, 1059, 1026, 16449},{FDI_AAM, 20672, 1344, 0},{FDI_AAD, 20672, 1344, 0},{FDI_XLATB, 0, 1024, 0},{FDI_LOOPNZ, 28864, 1024, 6144},{FDI_LOOPZ, 28864, 1024, 6144},{FDI_LOOP, 28864, 1024, 6144},{FDI_JCXZ, 28864, 1024, 6144},{FDI_IN, 20656, 1344, 64},{FDI_IN, 20656, 1120, 64},{FDI_OUT, 20656, 1344, 64},{FDI_OUT, 20656, 1120, 64},{FDI_CALL, 24768, 1152, 6144},{FDI_JMP, 24768, 1152, 6144},{FDI_JMPF, 16576, 1152, 0},{FDI_JMP, 28864, 1024, 6144},{FDI_IN, 0, 1280, 0},{FDI_IN, 0, 34048, 0},{FDI_OUT, 0, 1280, 0},{FDI_OUT, 0, 34048, 0},{FDI_INT1, 0, 1024, 0},{FDI_HLT, 0, 1024, 0},{FDI_CMC, 0, 1024, 0},{FDI_TEST, 20611, 1344, 16385},{FDI_NOT, 2051, 1280, 16385},{FDI_NEG, 2051, 1280, 16385},{FDI_MUL, 3, 1280, 16385},{FDI_IMUL, 3, 1280, 16385},{FDI_DIV, 3, 1280, 16385},{FDI_IDIV, 3, 1280, 16385},{FDI_TEST, 16515, 1154, 16385},{FDI_NOT, 2051, 1026, 16385},{FDI_NEG, 2051, 1026, 16385},{FDI_MUL, 3, 1026, 16385},{FDI_IMUL, 3, 1026, 16385},{FDI_DIV, 3, 1026, 16385},{FDI_IDIV, 3, 1026, 16385},{FDI_CLC, 0, 1024, 0},{FDI_STC, 0, 1024, 0},{FDI_CLI, 0, 1024, 0},{FDI_STI, 0, 1024, 0},{FDI_CLD, 0, 1024, 0},{FDI_STD, 0, 1024, 0},{FDI_INC, 2051, 1280, 16385},{FDI_DEC, 2051, 1280, 16385},{FDI_INC, 2051, 1026, 16385},{FDI_DEC, 2051, 1026, 16385},{FDI_CALL, 3, 1026, 22529},{FDI_CALLF, 3, 1026, 16384},{FDI_JMP, 3, 1026, 22529},{FDI_JMPF, 3, 1026, 16384},{FDI_PUSH, 3, 1026, 20481},{FDI_SLDT, 3, 2048, 16385},{FDI_STR, 3, 2048, 16385},{FDI_LLDT, 3, 2048, 16385},{FDI_LTR, 3, 2048, 16385},{FDI_VERR, 3, 2048, 16385},{FDI_VERW, 3, 2048, 16385},{FDI_SGDT, 3, 0, 16384},{FDI_SIDT, 3, 0, 16384},{FDI_LGDT, 3, 0, 16384},{FDI_LIDT, 3, 0, 16384},{FDI_SMSW, 3, 2048, 16384},{FDI_SMSW, 3, 1026, 16385},{FDI_LMSW, 3, 2048, 16385},{FDI_INVLPG, 3, 1280, 16384},{FDI_ENCLV, 0, 1024, 49152},{FDI_MONITOR, 0, 1024, 49152},{FDI_MWAIT, 0, 1024, 49152},{FDI_CLAC, 0, 1024, 49152},{FDI_STAC, 0, 1024, 49152},{FDI_ENCLS, 0, 1024, 49152},{FDI_XGETBV, 0, 1024, 49152},{FDI_XSETBV, 0, 1024, 49152},{FDI_XEND, 0, 1024, 49152},{FDI_XTEST, 0, 1024, 49152},{FDI_ENCLU, 0, 1024, 49152},{FDI_SWAPGS, 0, 1024, 16384},{FDI_RDTSCP, 0, 1024, 16384},{FDI_LAR, 14, 2056, 16393},{FDI_LSL, 14, 2056, 16393},{FDI_SYSCALL, 0, 1024, 0},{FDI_CLTS, 0, 1024, 0},{FDI_SYSRET, 0, 1024, 0},{FDI_INVD, 0, 1024, 0},{FDI_WBINVD, 0, 1024, 0},{FDI_UD2, 0, 1024, 0},{FDI_PREFETCH, 3, 1024, 16384},{FDI_PREFETCHW, 3, 1024, 16384},{FDI_PREFETCHWT1, 3, 1024, 16384},{FDI_RESERVED_PREFETCH, 3, 1024, 16384},{FDI_RESERVED_NOP, 11, 1034, 16393},{FDI_FEMMS, 0, 1024, 0},{FDI_3DNOW, 20558, 4416, 16429},{FDI_PREFETCHNTA, 3, 1024, 16384},{FDI_PREFETCHT0, 3, 1024, 16384},{FDI_PREFETCHT1, 3, 1024, 16384},{FDI_PREFETCHT2, 3, 1024, 16384},{FDI_PREFETCHIT1, 3, 1024, 16384},{FDI_PREFETCHIT0, 3, 1024, 16384},{FDI_NOP, 3, 1026, 16385},{FDI_MOV_CR, 11, 1034, 53249},{FDI_MOV_DR, 11, 1034, 53249},{FDI_MOV_CR, 14, 1034, 53249},{FDI_MOV_DR, 14, 1034, 53249},{FDI_WRMSR, 0, 1024, 0},{FDI_RDTSC, 0, 1024, 0},{FDI_RDMSR, 0, 1024, 0},{FDI_RDPMC, 0, 1024, 0},{FDI_SYSENTER, 0, 1024, 0},{FDI_SYSEXIT, 0, 1024, 0},{FDI_GETSEC, 0, 1024, 32768},{FDI_CMOVO, 14, 1034, 16393},{FDI_CMOVNO, 14, 1034, 16393},{FDI_CMOVC, 14, 1034, 16393},{FDI_CMOVNC, 14, 1034, 16393},{FDI_CMOVZ, 14, 1034, 16393},{FDI_CMOVNZ, 14, 1034, 16393},{FDI_CMOVBE, 14, 1034, 16393},{FDI_CMOVA, 14, 1034, 16393},{FDI_CMOVS, 14, 1034, 16393},{FDI_CMOVNS, 14, 1034, 16393},{FDI_CMOVP, 14, 1034, 16393},{FDI_CMOVNP, 14, 1034, 16393},{FDI_CMOVL, 14, 1034, 16393},{FDI_CMOVGE, 14, 1034, 16393},{FDI_CMOVLE, 14, 1034, 16393},{FDI_CMOVG, 14, 1034, 16393},{FDI_JO, 24768, 1152, 6144},{FDI_JNO, 24768, 1152, 6144},{FDI_JC, 24768, 1152, 6144},{FDI_JNC, 24768, 1152, 6144},{FDI_JZ, 24768, 1152, 6144},{FDI_JNZ, 24768, 1152, 6144},{FDI_JBE, 24768, 1152, 6144},{FDI_JA, 24768, 1152, 6144},{FDI_JS, 24768, 1152, 6144},{FDI_JNS, 24768, 1152, 6144},{FDI_JP, 24768, 1152, 6144},{FDI_JNP, 24768, 1152, 6144},{FDI_JL, 24768, 1152, 6144},{FDI_JGE, 24768, 1152, 6144},{FDI_JLE, 24768, 1152, 6144},{FDI_JG, 24768, 1152, 6144},{FDI_SETO, 3, 1280, 16385},{FDI_SETNO, 3, 1280, 16385},{FDI_SETC, 3, 1280, 16385},{FDI_SETNC, 3, 1280, 16385},{FDI_SETZ, 3, 1280, 16385},{FDI_SETNZ, 3, 1280, 16385},{FDI_SETBE, 3, 1280, 16385},{FDI_SETA, 3, 1280, 16385},{FDI_SETS, 3, 1280, 16385},{FDI_SETNS, 3, 1280, 16385},{FDI_SETP, 3, 1280, 16385},{FDI_SETNP, 3, 1280, 16385},{FDI_SETL, 3, 1280, 16385},{FDI_SETGE, 3, 1280, 16385},{FDI_SETLE, 3, 1280, 16385},{FDI_SETG, 3, 1280, 16385},{FDI_PUSH, 12, 1032, 4120},{FDI_POP, 12, 1032, 4120},{FDI_CPUID, 0, 1024, 0},{FDI_BT, 11, 1034, 16393},{FDI_SHLD, 20555, 1098, 16393},{FDI_SHLD, 1051, 1034, 16457},{FDI_RSM, 0, 1024, 0},{FDI_BTS, 2059, 1034, 16393},{FDI_SHRD, 20555, 1098, 16393},{FDI_SHRD, 1051, 1034, 16457},{FDI_IMUL, 14, 1034, 16393},{FDI_CMPXCHG, 2059, 1280, 16393},{FDI_CMPXCHG, 2059, 1034, 16393},{FDI_LSS, 14, 1034, 16392},{FDI_BTR, 2059, 1034, 16393},{FDI_LFS, 14, 1034, 16392},{FDI_LGS, 14, 1034, 16392},{FDI_MOVZX, 14, 1288, 16393},{FDI_MOVZX, 14, 2312, 16393},{FDI_POPCNT, 14, 1034, 16393},{FDI_UD1, 14, 1034, 16393},{FDI_BT, 20611, 1090, 16385},{FDI_BTS, 22659, 1090, 16385},{FDI_BTR, 22659, 1090, 16385},{FDI_BTC, 22659, 1090, 16385},{FDI_BTC, 2059, 1034, 16393},{FDI_BSF, 14, 1034, 16393},{FDI_TZCNT, 14, 1034, 16393},{FDI_BSR, 14, 1034, 16393},{FDI_LZCNT, 14, 1034, 16393},{FDI_MOVSX, 14, 1288, 16393},{FDI_MOVSX, 14, 2312, 16393},{FDI_XADD, 2059, 1280, 16393},{FDI_XADD, 2059, 1034, 16393},{FDI_MOVNTI, 11, 1034, 49160},{FDI_CMPXCHGD, 2051, 33024, 49152},{FDI_BSWAP, 3, 1026, 1},{FDI_UD0, 14, 1034, 16393},{FDI_MOVBE, 14, 1034, 16392},{FDI_CRC32, 14, 17668, 49161},{FDI_MOVBE, 11, 1034, 16392},{FDI_CRC32, 14, 3074, 16393},{FDI_MMX_CVTPI2PS, 14, 4096, 49157},{FDI_MMX_CVTPI2PD, 14, 29697, 49157},{FDI_MMX_CVTTPS2PI, 14, 4096, 49192},{FDI_MMX_CVTTPD2PI, 14, 29700, 49192},{FDI_MMX_CVTPS2PI, 14, 4096, 49192},{FDI_MMX_CVTPD2PI, 14, 29700, 49192},{FDI_MMX_PUNPCKLBW, 14, 27652, 49197},{FDI_MMX_PUNPCKLWD, 14, 27652, 49197},{FDI_MMX_PUNPCKLDQ, 14, 27652, 49197},{FDI_MMX_PACKSSWB, 14, 4096, 49197},{FDI_MMX_PCMPGTB, 14, 4096, 49197},{FDI_MMX_PCMPGTW, 14, 4096, 49197},{FDI_MMX_PCMPGTD, 14, 4096, 49197},{FDI_MMX_PACKUSWB, 14, 4096, 49197},{FDI_MMX_PUNPCKHBW, 14, 4096, 49197},{FDI_MMX_PUNPCKHWD, 14, 4096, 49197},{FDI_MMX_PUNPCKHDQ, 14, 4096, 49197},{FDI_MMX_PACKSSDW, 14, 4096, 49197},{FDI_MMX_MOVD, 14, 4098, 49193},{FDI_MMX_MOVQ, 14, 4098, 49193},{FDI_MMX_MOVQ, 14, 4096, 49197},{FDI_MMX_PSHUFW, 20558, 4160, 49197},{FDI_MMX_PSRLW, 20611, 4160, 49157},{FDI_MMX_PSRAW, 20611, 4160, 49157},{FDI_MMX_PSLLW, 20611, 4160, 49157},{FDI_MMX_PSRLD, 20611, 4160, 49157},{FDI_MMX_PSRAD, 20611, 4160, 49157},{FDI_MMX_PSLLD, 20611, 4160, 49157},{FDI_MMX_PSRLQ, 20611, 4160, 49157},{FDI_MMX_PSLLQ, 20611, 4160, 49157},{FDI_MMX_PCMPEQB, 14, 4096, 49197},{FDI_MMX_PCMPEQW, 14, 4096, 49197},{FDI_MMX_PCMPEQD, 14, 4096, 49197},{FDI_MMX_EMMS, 0, 1024, 32768},{FDI_MMX_MOVD, 11, 1034, 49193},{FDI_MMX_MOVQ, 11, 1034, 49193},{FDI_MMX_MOVQ, 11, 4096, 49197},{FDI_MMX_PINSRW, 20558, 26692, 49193},{FDI_MMX_PEXTRW, 20558, 4168, 53261},{FDI_MMX_PSRLW, 14, 4096, 49197},{FDI_MMX_PSRLD, 14, 4096, 49197},{FDI_MMX_PSRLQ, 14, 4096, 49197},{FDI_MMX_PADDQ, 14, 4096, 49197},{FDI_MMX_PMULLW, 14, 4096, 49197},{FDI_MMX_MOVDQ2Q, 14, 4096, 49192},{FDI_MMX_MOVQ2DQ, 14, 29697, 49157},{FDI_MMX_PMOVMSKB, 14, 4104, 53261},{FDI_MMX_PSUBUSB, 14, 4096, 49197},{FDI_MMX_PSUBUSW, 14, 4096, 49197},{FDI_MMX_PMINUB, 14, 4096, 49197},{FDI_MMX_PAND, 14, 4096, 49197},{FDI_MMX_PADDUSB, 14, 4096, 49197},{FDI_MMX_PADDUSW, 14, 4096, 49197},{FDI_MMX_PMAXUB, 14, 4096, 49197},{FDI_MMX_PANDN, 14, 4096, 49197},{FDI_MMX_PAVGB, 14, 4096, 49197},{FDI_MMX_PSRAW, 14, 4096, 49197},{FDI_MMX_PSRAD, 14, 4096, 49197},{FDI_MMX_PAVGW, 14, 4096, 49197},{FDI_MMX_PMULHUW, 14, 4096, 49197},{FDI_MMX_PMULHW, 14, 4096, 49197},{FDI_MMX_MOVNTQ, 11, 4096, 49192},{FDI_MMX_PSUBSB, 14, 4096, 49197},{FDI_MMX_PSUBSW, 14, 4096, 49197},{FDI_MMX_POR, 14, 4096, 49197},{FDI_MMX_PADDSB, 14, 4096, 49197},{FDI_MMX_PMINSW, 14, 4096, 49197},{FDI_MMX_PMAXSW, 14, 4096, 49197},{FDI_MMX_PADDSW, 14, 4096, 49197},{FDI_MMX_PXOR, 14, 4096, 49197},{FDI_MMX_PSLLW, 14, 4096, 49197},{FDI_MMX_PSLLD, 14, 4096, 49197},{FDI_MMX_PSLLQ, 14, 4096, 49197},{FDI_MMX_PMULUDQ, 14, 4096, 49197},{FDI_MMX_PMADDWD, 14, 4096, 49197},{FDI_MMX_PSADBW, 14, 4096, 49197},{FDI_MMX_MASKMOVQ, 14, 4096, 49197},{FDI_MMX_PSUBB, 14, 4096, 49197},{FDI_MMX_PSUBW, 14, 4096, 49197},{FDI_MMX_PSUBD, 14, 4096, 49197},{FDI_MMX_PSUBQ, 14, 4096, 49197},{FDI_MMX_PADDB, 14, 4096, 49197},{FDI_MMX_PADDW, 14, 4096, 49197},{FDI_MMX_PADDD, 14, 4096, 49197},{FDI_MMX_PSHUFB, 14, 4096, 49197},{FDI_MMX_PHADDW, 14, 4096, 49197},{FDI_MMX_PHADDD, 14, 4096, 49197},{FDI_MMX_PHADDSW, 14, 4096, 49197},{FDI_MMX_PMADDUBSW, 14, 4096, 49197},{FDI_MMX_PHSUBW, 14, 4096, 49197},{FDI_MMX_PHSUBD, 14, 4096, 49197},{FDI_MMX_PHSUBSW, 14, 4096, 49197},{FDI_MMX_PSIGNB, 14, 4096, 49197},{FDI_MMX_PSIGNW, 14, 4096, 49197},{FDI_MMX_PSIGND, 14, 4096, 49197},{FDI_MMX_PMULHRSW, 14, 4096, 49197},{FDI_MMX_PABSB, 14, 4096, 49197},{FDI_MMX_PABSW, 14, 4096, 49197},{FDI_MMX_PABSD, 14, 4096, 49197},{FDI_MMX_PALIGNR, 20558, 4160, 49197},{FDI_SSE_MOVUPS, 14, 1034, 57344},{FDI_SSE_MOVUPD, 14, 1034, 57344},{FDI_SSE_MOVSS, 14, 3080, 57344},{FDI_SSE_MOVSD, 14, 4104, 57344},{FDI_SSE_MOVUPS, 11, 1034, 57344},{FDI_SSE_MOVUPD, 11, 1034, 57344},{FDI_SSE_MOVSS, 11, 3072, 49152},{FDI_SSE_MOVSD, 11, 4096, 49152},{FDI_SSE_MOVLPS, 14, 4104, 57344},{FDI_SSE_MOVHLPS, 14, 1034, 57344},{FDI_SSE_MOVLPD, 14, 4104, 57344},{FDI_SSE_MOVSLDUP, 14, 1034, 57344},{FDI_SSE_MOVDDUP, 14, 4104, 57344},{FDI_SSE_MOVLPS, 11, 4096, 49152},{FDI_SSE_MOVLPD, 11, 4096, 49152},{FDI_SSE_UNPCKLPS, 14, 1034, 57344},{FDI_SSE_UNPCKLPD, 14, 1034, 57344},{FDI_SSE_UNPCKHPS, 14, 1034, 57344},{FDI_SSE_UNPCKHPD, 14, 1034, 57344},{FDI_SSE_MOVHPS, 14, 4104, 57344},{FDI_SSE_MOVLHPS, 14, 4104, 57344},{FDI_SSE_MOVHPD, 14, 29697, 49152},{FDI_SSE_MOVSHDUP, 14, 1034, 57344},{FDI_SSE_MOVHPS, 11, 4104, 57344},{FDI_SSE_MOVHPD, 11, 4104, 57344},{FDI_SSE_MOVAPS, 14, 1034, 57344},{FDI_SSE_MOVAPD, 14, 1034, 57344},{FDI_SSE_MOVAPS, 11, 1034, 57344},{FDI_SSE_MOVAPD, 11, 1034, 57344},{FDI_SSE_CVTSI2SS, 14, 3074, 49153},{FDI_SSE_CVTSI2SD, 14, 4098, 49153},{FDI_SSE_MOVNTPS, 11, 1034, 57344},{FDI_SSE_MOVNTPD, 11, 1034, 57344},{FDI_SSE_MOVNTSS, 11, 3072, 49152},{FDI_SSE_MOVNTSD, 11, 4096, 49152},{FDI_SSE_CVTTSS2SI, 14, 3080, 49160},{FDI_SSE_CVTTSD2SI, 14, 4104, 49160},{FDI_SSE_CVTSS2SI, 14, 3080, 49160},{FDI_SSE_CVTSD2SI, 14, 4104, 49160},{FDI_SSE_UCOMISS, 14, 3072, 49152},{FDI_SSE_UCOMISD, 14, 4096, 49152},{FDI_SSE_COMISS, 14, 3072, 49152},{FDI_SSE_COMISD, 14, 4096, 49152},{FDI_SSE_MOVMSKPS, 14, 5128, 53256},{FDI_SSE_MOVMSKPD, 14, 5128, 53256},{FDI_SSE_SQRTPS, 14, 1034, 57344},{FDI_SSE_SQRTPD, 14, 1034, 57344},{FDI_SSE_SQRTSS, 14, 3072, 49152},{FDI_SSE_SQRTSD, 14, 4096, 49152},{FDI_SSE_RSQRTPS, 14, 1034, 57344},{FDI_SSE_RSQRTSS, 14, 3072, 49152},{FDI_SSE_RCPPS, 14, 1034, 57344},{FDI_SSE_RCPSS, 14, 3072, 49152},{FDI_SSE_ANDPS, 14, 1034, 57344},{FDI_SSE_ANDPD, 14, 1034, 57344},{FDI_SSE_ANDNPS, 14, 1034, 57344},{FDI_SSE_ANDNPD, 14, 1034, 57344},{FDI_SSE_ORPS, 14, 1034, 57344},{FDI_SSE_ORPD, 14, 1034, 57344},{FDI_SSE_XORPS, 14, 1034, 57344},{FDI_SSE_XORPD, 14, 1034, 57344},{FDI_SSE_ADDPS, 14, 1034, 57344},{FDI_SSE_ADDPD, 14, 1034, 57344},{FDI_SSE_ADDSS, 14, 3072, 49152},{FDI_SSE_ADDSD, 14, 4096, 49152},{FDI_SSE_MULPS, 14, 1034, 57344},{FDI_SSE_MULPD, 14, 1034, 57344},{FDI_SSE_MULSS, 14, 3072, 49152},{FDI_SSE_MULSD, 14, 4096, 49152},{FDI_SSE_CVTPS2PD, 14, 4104, 57344},{FDI_SSE_CVTPD2PS, 14, 1034, 57344},{FDI_SSE_CVTSS2SD, 14, 27652, 49152},{FDI_SSE_CVTSD2SS, 14, 27649, 49152},{FDI_SSE_CVTDQ2PS, 14, 5128, 57344},{FDI_SSE_CVTPS2DQ, 14, 5122, 57344},{FDI_SSE_CVTTPS2DQ, 14, 5122, 57344},{FDI_SSE_SUBPS, 14, 1034, 57344},{FDI_SSE_SUBPD, 14, 1034, 57344},{FDI_SSE_SUBSS, 14, 3072, 49152},{FDI_SSE_SUBSD, 14, 4096, 49152},{FDI_SSE_MINPS, 14, 1034, 57344},{FDI_SSE_MINPD, 14, 1034, 57344},{FDI_SSE_MINSS, 14, 3072, 49152},{FDI_SSE_MINSD, 14, 4096, 49152},{FDI_SSE_DIVPS, 14, 1034, 57344},{FDI_SSE_DIVPD, 14, 1034, 57344},{FDI_SSE_DIVSS, 14, 3072, 49152},{FDI_SSE_DIVSD, 14, 4096, 49152},{FDI_SSE_MAXPS, 14, 1034, 57344},{FDI_SSE_MAXPD, 14, 1034, 57344},{FDI_SSE_MAXSS, 14, 3072, 49152},{FDI_SSE_MAXSD, 14, 4096, 49152},{FDI_SSE_PUNPCKLBW, 14, 1034, 57344},{FDI_SSE_PUNPCKLWD, 14, 1034, 57344},{FDI_SSE_PUNPCKLDQ, 14, 1034, 57344},{FDI_SSE_PACKSSWB, 14, 1034, 57344},{FDI_SSE_PCMPGTB, 14, 1034, 57344},{FDI_SSE_PCMPGTW, 14, 1034, 57344},{FDI_SSE_PCMPGTD, 14, 1034, 57344},{FDI_SSE_PACKUSWB, 14, 1034, 57344},{FDI_SSE_PUNPCKHBW, 14, 1034, 57344},{FDI_SSE_PUNPCKHWD, 14, 1034, 57344},{FDI_SSE_PUNPCKHDQ, 14, 1034, 57344},{FDI_SSE_PACKSSDW, 14, 1034, 57344},{FDI_SSE_PUNPCKLQDQ, 14, 1034, 57344},{FDI_SSE_PUNPCKHQDQ, 14, 1034, 57344},{FDI_SSE_MOVD, 14, 3080, 57345},{FDI_SSE_MOVQ, 14, 4104, 57345},{FDI_SSE_MOVDQA, 14, 1034, 57344},{FDI_SSE_MOVDQU, 14, 1034, 57344},{FDI_SSE_PSHUFD, 20558, 1098, 57344},{FDI_SSE_PSHUFHW, 20558, 1098, 57344},{FDI_SSE_PSHUFLW, 20558, 1098, 57344},{FDI_SSE_PSRLW, 20611, 1090, 57344},{FDI_SSE_PSRAW, 20611, 1090, 57344},{FDI_SSE_PSLLW, 20611, 1090, 57344},{FDI_SSE_PSRLD, 20611, 1090, 57344},{FDI_SSE_PSRAD, 20611, 1090, 57344},{FDI_SSE_PSLLD, 20611, 1090, 57344},{FDI_SSE_PSRLQ, 20611, 1090, 57344},{FDI_SSE_PSRLDQ, 20611, 1090, 57344},{FDI_SSE_PSLLQ, 20611, 1090, 57344},{FDI_SSE_PSLLDQ, 20611, 1090, 57344},{FDI_SSE_PCMPEQB, 14, 1034, 57344},{FDI_SSE_PCMPEQW, 14, 1034, 57344},{FDI_SSE_PCMPEQD, 14, 1034, 57344},{FDI_SSE_EXTRQ, 16515, 2050, 57344},{FDI_SSE_INSERTQ, 16462, 2058, 57344},{FDI_SSE_EXTRQ, 14, 1034, 57344},{FDI_SSE_INSERTQ, 14, 1034, 57344},{FDI_SSE_HADDPD, 14, 1034, 57344},{FDI_SSE_HADDPS, 14, 1034, 57344},{FDI_SSE_HSUBPD, 14, 1034, 57344},{FDI_SSE_HSUBPS, 14, 1034, 57344},{FDI_SSE_MOVD, 11, 1034, 49153},{FDI_SSE_MOVQ, 11, 1034, 49153},{FDI_SSE_MOVQ, 14, 4104, 57344},{FDI_SSE_MOVDQA, 11, 1034, 57344},{FDI_SSE_MOVDQU, 11, 1034, 57344},{FDI_FXSAVE, 3, 33024, 49152},{FDI_FXRSTOR, 3, 33024, 49152},{FDI_LDMXCSR, 3, 3072, 49152},{FDI_STMXCSR, 3, 3072, 49152},{FDI_LFENCE, 0, 1024, 49152},{FDI_MFENCE, 0, 1024, 49152},{FDI_SFENCE, 0, 1024, 49152},{FDI_SSE_CMPPS, 20558, 1098, 57344},{FDI_SSE_CMPPD, 20558, 1098, 57344},{FDI_SSE_CMPSS, 20558, 3136, 49152},{FDI_SSE_CMPSD, 20558, 4160, 49152},{FDI_SSE_PINSRW, 20558, 2120, 57345},{FDI_SSE_PEXTRW, 20558, 5192, 53256},{FDI_SSE_SHUFPS, 20558, 1098, 57344},{FDI_SSE_SHUFPD, 20558, 1098, 57344},{FDI_SSE_ADDSUBPD, 14, 1034, 57344},{FDI_SSE_ADDSUBPS, 14, 1034, 57344},{FDI_SSE_PSRLW, 14, 1034, 57344},{FDI_SSE_PSRLD, 14, 1034, 57344},{FDI_SSE_PSRLQ, 14, 1034, 57344},{FDI_SSE_PADDQ, 14, 1034, 57344},{FDI_SSE_PMULLW, 14, 1034, 57344},{FDI_SSE_MOVQ, 11, 4096, 49152},{FDI_SSE_PMOVMSKB, 14, 5128, 53256},{FDI_SSE_PSUBUSB, 14, 1034, 57344},{FDI_SSE_PSUBUSW, 14, 1034, 57344},{FDI_SSE_PMINUB, 14, 1034, 57344},{FDI_SSE_PAND, 14, 1034, 57344},{FDI_SSE_PADDUSB, 14, 1034, 57344},{FDI_SSE_PADDUSW, 14, 1034, 57344},{FDI_SSE_PMAXUB, 14, 1034, 57344},{FDI_SSE_PANDN, 14, 1034, 57344},{FDI_SSE_PAVGB, 14, 1034, 57344},{FDI_SSE_PSRAW, 14, 1034, 57344},{FDI_SSE_PSRAD, 14, 1034, 57344},{FDI_SSE_PAVGW, 14, 1034, 57344},{FDI_SSE_PMULHUW, 14, 1034, 57344},{FDI_SSE_PMULHW, 14, 1034, 57344},{FDI_SSE_CVTTPD2DQ, 14, 1034, 57344},{FDI_SSE_CVTDQ2PD, 14, 4104, 57344},{FDI_SSE_CVTPD2DQ, 14, 1034, 57344},{FDI_SSE_MOVNTDQ, 11, 1034, 57344},{FDI_SSE_PSUBSB, 14, 1034, 57344},{FDI_SSE_PSUBSW, 14, 1034, 57344},{FDI_SSE_POR, 14, 1034, 57344},{FDI_SSE_PADDSB, 14, 1034, 57344},{FDI_SSE_PMINSW, 14, 1034, 57344},{FDI_SSE_PMAXSW, 14, 1034, 57344},{FDI_SSE_PADDSW, 14, 1034, 57344},{FDI_SSE_PXOR, 14, 1034, 57344},{FDI_SSE_LDDQU, 14, 1034, 57344},{FDI_SSE_PSLLW, 14, 1034, 57344},{FDI_SSE_PSLLD, 14, 1034, 57344},{FDI_SSE_PSLLQ, 14, 1034, 57344},{FDI_SSE_PMULUDQ, 14, 1034, 57344},{FDI_SSE_PMADDWD, 14, 1034, 57344},{FDI_SSE_PSADBW, 14, 1034, 57344},{FDI_SSE_MASKMOVDQU, 14, 1034, 57344},{FDI_SSE_PSUBB, 14, 1034, 57344},{FDI_SSE_PSUBW, 14, 1034, 57344},{FDI_SSE_PSUBD, 14, 1034, 57344},{FDI_SSE_PSUBQ, 14, 1034, 57344},{FDI_SSE_PADDB, 14, 1034, 57344},{FDI_SSE_PADDW, 14, 1034, 57344},{FDI_SSE_PADDD, 14, 1034, 57344},{FDI_SSE_PSHUFB, 14, 1034, 57344},{FDI_SSE_PHADDW, 14, 1034, 57344},{FDI_SSE_PHADDD, 14, 1034, 57344},{FDI_SSE_PHADDSW, 14, 1034, 57344},{FDI_SSE_PMADDUBSW, 14, 1034, 57344},{FDI_SSE_PHSUBW, 14, 1034, 57344},{FDI_SSE_PHSUBD, 14, 1034, 57344},{FDI_SSE_PHSUBSW, 14, 1034, 57344},{FDI_SSE_PSIGNB, 14, 1034, 57344},{FDI_SSE_PSIGNW, 14, 1034, 57344},{FDI_SSE_PSIGND, 14, 1034, 57344},{FDI_SSE_PMULHRSW, 14, 1034, 57344},{FDI_SSE_PBLENDVB, 14, 5120, 49152},{FDI_SSE_BLENDVPS, 30, 5120, 49152},{FDI_SSE_BLENDVPD, 30, 5120, 49152},{FDI_SSE_PTEST, 14, 1034, 57344},{FDI_SSE_PABSB, 14, 1034, 57344},{FDI_SSE_PABSW, 14, 1034, 57344},{FDI_SSE_PABSD, 14, 1034, 57344},{FDI_SSE_PMOVSXBW, 14, 1035, 59392},{FDI_SSE_PMOVSXBD, 14, 1035, 61440},{FDI_SSE_PMOVSXBQ, 14, 1035, 63488},{FDI_SSE_PMOVSXWD, 14, 1035, 59392},{FDI_SSE_PMOVSXWQ, 14, 1035, 61440},{FDI_SSE_PMOVSXDQ, 14, 1035, 59392},{FDI_SSE_PMULDQ, 14, 1034, 57344},{FDI_SSE_PCMPEQQ, 14, 1034, 57344},{FDI_SSE_MOVNTDQA, 14, 1034, 57344},{FDI_SSE_PACKUSDW, 14, 1034, 57344},{FDI_SSE_PMOVZXBW, 14, 1035, 59392},{FDI_SSE_PMOVZXBD, 14, 1035, 61440},{FDI_SSE_PMOVZXBQ, 14, 1035, 63488},{FDI_SSE_PMOVZXWD, 14, 1035, 59392},{FDI_SSE_PMOVZXWQ, 14, 1035, 61440},{FDI_SSE_PMOVZXDQ, 14, 1035, 59392},{FDI_SSE_PCMPGTQ, 14, 1034, 57344},{FDI_SSE_PMINSB, 14, 1034, 57344},{FDI_SSE_PMINSD, 14, 1034, 57344},{FDI_SSE_PMINUW, 14, 1034, 57344},{FDI_SSE_PMINUD, 14, 1034, 57344},{FDI_SSE_PMAXSB, 14, 1034, 57344},{FDI_SSE_PMAXSD, 14, 1034, 57344},{FDI_SSE_PMAXUW, 14, 1034, 57344},{FDI_SSE_PMAXUD, 14, 1034, 57344},{FDI_SSE_PMULLD, 14, 1034, 57344},{FDI_SSE_PHMINPOSUW, 14, 1034, 57344},{FDI_MOVDIR64B, 14, 7176, 53256},{FDI_MOVDIRI, 11, 1034, 49160},{FDI_SSE_ROUNDPS, 20558, 1098, 57344},{FDI_SSE_ROUNDPD, 20558, 1098, 57344},{FDI_SSE_ROUNDSS, 20558, 3136, 49152},{FDI_SSE_ROUNDSD, 20558, 4160, 49152},{FDI_SSE_BLENDPS, 20558, 1098, 57344},{FDI_SSE_BLENDPD, 20558, 1098, 57344},{FDI_SSE_PBLENDW, 20558, 1098, 57344},{FDI_SSE_PALIGNR, 20558, 1098, 57344},{FDI_SSE_PEXTRB, 20555, 1096, 57344},{FDI_SSE_PEXTRB, 20555, 3144, 57345},{FDI_SSE_PEXTRW, 20555, 2120, 57344},{FDI_SSE_PEXTRW, 20555, 3144, 57345},{FDI_SSE_PEXTRD, 20555, 3144, 57345},{FDI_SSE_PEXTRQ, 20555, 4168, 57345},{FDI_SSE_EXTRACTPS, 20555, 3144, 57345},{FDI_SSE_PINSRB, 20558, 1096, 57345},{FDI_SSE_INSERTPS, 20558, 3144, 57344},{FDI_SSE_PINSRD, 20558, 3144, 57345},{FDI_SSE_PINSRQ, 20558, 4168, 57345},{FDI_SSE_DPPS, 20558, 1098, 57344},{FDI_SSE_DPPD, 20558, 1098, 57344},{FDI_SSE_MPSADBW, 20558, 1098, 57344},{FDI_SSE_PCLMULQDQ, 20558, 5184, 49152},{FDI_SSE_PCMPESTRM, 20558, 5184, 49152},{FDI_SSE_PCMPESTRI, 20558, 5184, 49152},{FDI_SSE_PCMPISTRM, 20558, 5184, 49152},{FDI_SSE_PCMPISTRI, 20558, 5184, 49152},{FDI_AESIMC, 14, 5120, 49152},{FDI_AESENC, 14, 5120, 49152},{FDI_AESENCLAST, 14, 5120, 49152},{FDI_AESDEC, 14, 5120, 49152},{FDI_AESDECLAST, 14, 5120, 49152},{FDI_AESKEYGENASSIST, 20558, 5184, 49152},{FDI_VAESIMC, 14, 5120, 49152},{FDI_VAESENC, 45, 1066, 57344},{FDI_VAESENCLAST, 45, 1066, 57344},{FDI_VAESDEC, 45, 1066, 57344},{FDI_VAESDECLAST, 45, 1066, 57344},{FDI_VAESKEYGENASSIST, 20558, 5184, 49152},{FDI_VMOVUPS, 14, 1034, 57344},{FDI_VMOVUPD, 14, 1034, 57344},{FDI_VMOVSS, 14, 21505, 49152},{FDI_VMOVSS, 45, 21505, 49152},{FDI_VMOVSD, 14, 29697, 49152},{FDI_VMOVSD, 45, 29697, 49152},{FDI_VMOVUPS, 11, 1034, 57344},{FDI_VMOVUPD, 11, 1034, 57344},{FDI_VMOVSS, 11, 3072, 49152},{FDI_VMOVSS, 39, 21508, 49152},{FDI_VMOVSD, 11, 4096, 49152},{FDI_VMOVSD, 39, 29700, 49152},{FDI_VMOVLPS, 45, 29697, 49152},{FDI_VMOVHLPS, 45, 5120, 49152},{FDI_VMOVLPD, 45, 29697, 49152},{FDI_VMOVDDUP, 14, 4104, 57344},{FDI_VMOVDDUP, 14, 1034, 57344},{FDI_VMOVSLDUP, 14, 1034, 57344},{FDI_VMOVLPS, 11, 4096, 49152},{FDI_VMOVLPD, 11, 4096, 49152},{FDI_VUNPCKLPS, 45, 1066, 57344},{FDI_VUNPCKLPD, 45, 1066, 57344},{FDI_VUNPCKHPS, 45, 1066, 57344},{FDI_VUNPCKHPD, 45, 1066, 57344},{FDI_VMOVHPS, 45, 29713, 49152},{FDI_VMOVLHPS, 45, 29713, 49152},{FDI_VMOVHPD, 45, 29713, 49152},{FDI_VMOVSHDUP, 14, 1034, 57344},{FDI_VMOVHPS, 11, 4096, 49152},{FDI_VMOVHPD, 11, 4096, 49152},{FDI_VMOVAPS, 14, 1034, 57344},{FDI_VMOVAPD, 14, 1034, 57344},{FDI_VMOVAPS, 11, 1034, 57344},{FDI_VMOVAPD, 11, 1034, 57344},{FDI_VCVTSI2SS, 45, 5122, 49153},{FDI_VCVTSI2SD, 45, 5122, 49153},{FDI_VMOVNTPS, 11, 1034, 57344},{FDI_VMOVNTPD, 11, 1034, 57344},{FDI_VCVTTSS2SI, 14, 3080, 49160},{FDI_VCVTTSD2SI, 14, 4104, 49160},{FDI_VCVTSS2SI, 14, 3080, 49160},{FDI_VCVTSD2SI, 14, 4104, 49160},{FDI_VUCOMISS, 14, 3072, 49152},{FDI_VUCOMISD, 14, 4096, 49152},{FDI_VCOMISS, 14, 3072, 49152},{FDI_VCOMISD, 14, 4096, 49152},{FDI_VMOVMSKPS, 14, 3074, 57352},{FDI_VMOVMSKPD, 14, 3074, 57352},{FDI_VSQRTPS, 14, 1034, 57344},{FDI_VSQRTPD, 14, 1034, 57344},{FDI_VSQRTSS, 45, 21505, 49152},{FDI_VSQRTSD, 45, 29697, 49152},{FDI_VRSQRTPS, 14, 1034, 57344},{FDI_VRSQRTSS, 45, 21505, 49152},{FDI_VRCPPS, 14, 1034, 57344},{FDI_VRCPSS, 45, 21505, 49152},{FDI_VANDPS, 45, 1066, 57344},{FDI_VANDPD, 45, 1066, 57344},{FDI_VANDNPS, 45, 1066, 57344},{FDI_VANDNPD, 45, 1066, 57344},{FDI_VORPS, 45, 1066, 57344},{FDI_VORPD, 45, 1066, 57344},{FDI_VXORPS, 45, 1066, 57344},{FDI_VXORPD, 45, 1066, 57344},{FDI_VADDPS, 45, 1066, 57344},{FDI_VADDPD, 45, 1066, 57344},{FDI_VADDSS, 45, 21505, 49152},{FDI_VADDSD, 45, 29697, 49152},{FDI_VMULPS, 45, 1066, 57344},{FDI_VMULPD, 45, 1066, 57344},{FDI_VMULSS, 45, 21505, 49152},{FDI_VMULSD, 45, 29697, 49152},{FDI_VCVTPS2PD, 14, 1035, 59392},{FDI_VCVTPD2PS, 14, 1038, 59392},{FDI_VCVTSS2SD, 45, 21505, 49152},{FDI_VCVTSD2SS, 45, 29697, 49152},{FDI_VCVTDQ2PS, 14, 1034, 57344},{FDI_VCVTPS2DQ, 14, 1034, 57344},{FDI_VCVTTPS2DQ, 14, 1034, 57344},{FDI_VSUBPS, 45, 1066, 57344},{FDI_VSUBPD, 45, 1066, 57344},{FDI_VSUBSS, 45, 21505, 49152},{FDI_VSUBSD, 45, 29697, 49152},{FDI_VMINPS, 45, 1066, 57344},{FDI_VMINPD, 45, 1066, 57344},{FDI_VMINSS, 45, 21505, 49152},{FDI_VMINSD, 45, 29697, 49152},{FDI_VDIVPS, 45, 1066, 57344},{FDI_VDIVPD, 45, 1066, 57344},{FDI_VDIVSS, 45, 21505, 49152},{FDI_VDIVSD, 45, 29697, 49152},{FDI_VMAXPS, 45, 1066, 57344},{FDI_VMAXPD, 45, 1066, 57344},{FDI_VMAXSS, 45, 21505, 49152},{FDI_VMAXSD, 45, 29697, 49152},{FDI_VPUNPCKLBW, 45, 1066, 57344},{FDI_VPUNPCKLWD, 45, 1066, 57344},{FDI_VPUNPCKLDQ, 45, 1066, 57344},{FDI_VPACKSSWB, 45, 1066, 57344},{FDI_VPCMPGTB, 45, 1066, 57344},{FDI_VPCMPGTW, 45, 1066, 57344},{FDI_VPCMPGTD, 45, 1066, 57344},{FDI_VPACKUSWB, 45, 1066, 57344},{FDI_VPUNPCKHBW, 45, 1066, 57344},{FDI_VPUNPCKHWD, 45, 1066, 57344},{FDI_VPUNPCKHDQ, 45, 1066, 57344},{FDI_VPACKSSDW, 45, 1066, 57344},{FDI_VPUNPCKLQDQ, 45, 1066, 57344},{FDI_VPUNPCKHQDQ, 45, 1066, 57344},{FDI_VMOVD, 14, 1034, 49153},{FDI_VMOVQ, 14, 1034, 49153},{FDI_VMOVDQA, 14, 1034, 57344},{FDI_VMOVDQU, 14, 1034, 57344},{FDI_VPSHUFD, 20558, 1098, 57344},{FDI_VPSHUFHW, 20558, 1098, 57344},{FDI_VPSHUFLW, 20558, 1098, 57344},{FDI_VPSRLW, 20594, 1122, 57344},{FDI_VPSRAW, 20594, 1122, 57344},{FDI_VPSLLW, 20594, 1122, 57344},{FDI_VPSRLD, 20594, 1122, 57344},{FDI_VPSRAD, 20594, 1122, 57344},{FDI_VPSLLD, 20594, 1122, 57344},{FDI_VPSRLQ, 20594, 1122, 57344},{FDI_VPSRLDQ, 20594, 1122, 57344},{FDI_VPSLLQ, 20594, 1122, 57344},{FDI_VPSLLDQ, 20594, 1122, 57344},{FDI_VPCMPEQB, 45, 1066, 57344},{FDI_VPCMPEQW, 45, 1066, 57344},{FDI_VPCMPEQD, 45, 1066, 57344},{FDI_VZEROUPPER, 0, 1024, 32768},{FDI_VZEROALL, 0, 1024, 32768},{FDI_VHADDPD, 45, 1066, 57344},{FDI_VHADDPS, 45, 1066, 57344},{FDI_VHSUBPD, 45, 1066, 57344},{FDI_VHSUBPS, 45, 1066, 57344},{FDI_VMOVD, 11, 1034, 49153},{FDI_VMOVQ, 11, 1034, 49153},{FDI_VMOVQ, 14, 4096, 49152},{FDI_VMOVDQA, 11, 1034, 57344},{FDI_VMOVDQU, 11, 1034, 57344},{FDI_VLDMXCSR, 3, 3072, 49152},{FDI_VSTMXCSR, 3, 3072, 49152},{FDI_VCMPPS, 20525, 1130, 57344},{FDI_VCMPPD, 20525, 1130, 57344},{FDI_VCMPSS, 20525, 21569, 49152},{FDI_VCMPSD, 20525, 29761, 49152},{FDI_VPINSRW, 20525, 13377, 49153},{FDI_VPEXTRW, 20558, 21572, 49160},{FDI_VSHUFPS, 20525, 1130, 57344},{FDI_VSHUFPD, 20525, 1130, 57344},{FDI_VADDSUBPD, 45, 1066, 57344},{FDI_VADDSUBPS, 45, 1066, 57344},{FDI_VPSRLW, 45, 5160, 57344},{FDI_VPSRLD, 45, 5160, 57344},{FDI_VPSRLQ, 45, 5160, 57344},{FDI_VPADDQ, 45, 1066, 57344},{FDI_VPMULLW, 45, 1066, 57344},{FDI_VMOVQ, 11, 4096, 49152},{FDI_VPMOVMSKB, 14, 3074, 57352},{FDI_VPSUBUSB, 45, 1066, 57344},{FDI_VPSUBUSW, 45, 1066, 57344},{FDI_VPMINUB, 45, 1066, 57344},{FDI_VPAND, 45, 1066, 57344},{FDI_VPADDUSB, 45, 1066, 57344},{FDI_VPADDUSW, 45, 1066, 57344},{FDI_VPMAXUB, 45, 1066, 57344},{FDI_VPANDN, 45, 1066, 57344},{FDI_VPAVGB, 45, 1066, 57344},{FDI_VPSRAW, 45, 5160, 57344},{FDI_VPSRAD, 45, 5160, 57344},{FDI_VPAVGW, 45, 1066, 57344},{FDI_VPMULHUW, 45, 1066, 57344},{FDI_VPMULHW, 45, 1066, 57344},{FDI_VCVTTPD2DQ, 14, 1038, 59392},{FDI_VCVTDQ2PD, 14, 1035, 59392},{FDI_VCVTPD2DQ, 14, 1038, 59392},{FDI_VMOVNTDQ, 11, 1034, 57344},{FDI_VPSUBSB, 45, 1066, 57344},{FDI_VPSUBSW, 45, 1066, 57344},{FDI_VPOR, 45, 1066, 57344},{FDI_VPADDSB, 45, 1066, 57344},{FDI_VPMINSW, 45, 1066, 57344},{FDI_VPADDSW, 45, 1066, 57344},{FDI_VPMAXSW, 45, 1066, 57344},{FDI_VPXOR, 45, 1066, 57344},{FDI_VLDDQU, 14, 1034, 57344},{FDI_VPSLLW, 45, 5160, 57344},{FDI_VPSLLD, 45, 5160, 57344},{FDI_VPSLLQ, 45, 5160, 57344},{FDI_VPMULUDQ, 45, 1066, 57344},{FDI_VPMADDWD, 45, 1066, 57344},{FDI_VPSADBW, 45, 1066, 57344},{FDI_VMASKMOVDQU, 14, 1034, 57344},{FDI_VPSUBB, 45, 1066, 57344},{FDI_VPSUBW, 45, 1066, 57344},{FDI_VPSUBD, 45, 1066, 57344},{FDI_VPSUBQ, 45, 1066, 57344},{FDI_VPADDB, 45, 1066, 57344},{FDI_VPADDW, 45, 1066, 57344},{FDI_VPADDD, 45, 1066, 57344},{FDI_VPSHUFB, 45, 1066, 57344},{FDI_VPHADDW, 45, 1066, 57344},{FDI_VPHADDD, 45, 1066, 57344},{FDI_VPHADDSW, 45, 1066, 57344},{FDI_VPMADDUBSW, 45, 1066, 57344},{FDI_VPHSUBW, 45, 1066, 57344},{FDI_VPHSUBD, 45, 1066, 57344},{FDI_VPHSUBSW, 45, 1066, 57344},{FDI_VPSIGNB, 45, 1066, 57344},{FDI_VPSIGNW, 45, 1066, 57344},{FDI_VPSIGND, 45, 1066, 57344},{FDI_VPMULHRSW, 45, 1066, 57344},{FDI_VPERMILPS, 45, 1066, 57344},{FDI_VPERMILPD, 45, 1066, 57344},{FDI_VTESTPS, 14, 1034, 57344},{FDI_VTESTPD, 14, 1034, 57344},{FDI_VCVTPH2PS, 14, 1035, 59392},{FDI_VPERMPS, 45, 1066, 57344},{FDI_VPTEST, 14, 1034, 57344},{FDI_VBROADCASTSS, 14, 3080, 57344},{FDI_VBROADCASTSD, 14, 4104, 57344},{FDI_VBROADCASTF128, 14, 5128, 57344},{FDI_VPABSB, 14, 1034, 57344},{FDI_VPABSW, 14, 1034, 57344},{FDI_VPABSD, 14, 1034, 57344},{FDI_VPMOVSXBW, 14, 1035, 59392},{FDI_VPMOVSXBD, 14, 1035, 61440},{FDI_VPMOVSXBQ, 14, 1035, 63488},{FDI_VPMOVSXWD, 14, 1035, 59392},{FDI_VPMOVSXWQ, 14, 1035, 61440},{FDI_VPMOVSXDQ, 14, 1035, 59392},{FDI_VPMULDQ, 45, 1066, 57344},{FDI_VPCMPEQQ, 45, 1066, 57344},{FDI_VMOVNTDQA, 14, 1034, 57344},{FDI_VPACKUSDW, 45, 1066, 57344},{FDI_VMASKMOVPS, 45, 1066, 57344},{FDI_VMASKMOVPD, 45, 1066, 57344},{FDI_VMASKMOVPS, 39, 1066, 57344},{FDI_VMASKMOVPD, 39, 1066, 57344},{FDI_VPMOVZXBW, 14, 1035, 59392},{FDI_VPMOVZXBD, 14, 1035, 61440},{FDI_VPMOVZXBQ, 14, 1035, 63488},{FDI_VPMOVZXWD, 14, 1035, 59392},{FDI_VPMOVZXWQ, 14, 1035, 61440},{FDI_VPMOVZXDQ, 14, 1035, 59392},{FDI_VPERMD, 45, 1066, 57344},{FDI_VPCMPGTQ, 45, 1066, 57344},{FDI_VPMINSB, 45, 1066, 57344},{FDI_VPMINSD, 45, 1066, 57344},{FDI_VPMINUW, 45, 1066, 57344},{FDI_VPMINUD, 45, 1066, 57344},{FDI_VPMAXSB, 45, 1066, 57344},{FDI_VPMAXSD, 45, 1066, 57344},{FDI_VPMAXUW, 45, 1066, 57344},{FDI_VPMAXUD, 45, 1066, 57344},{FDI_VPMULLD, 45, 1066, 57344},{FDI_VPHMINPOSUW, 14, 1034, 57344},{FDI_VPSRLVD, 45, 1066, 57344},{FDI_VPSRLVQ, 45, 1066, 57344},{FDI_VPSRAVD, 45, 1066, 57344},{FDI_VPSLLVD, 45, 1066, 57344},{FDI_VPSLLVQ, 45, 1066, 57344},{FDI_VPBROADCASTD, 14, 3080, 57344},{FDI_VPBROADCASTQ, 14, 4104, 57344},{FDI_VBROADCASTI128, 14, 5128, 57344},{FDI_VPBROADCASTB, 14, 1032, 57344},{FDI_VPBROADCASTW, 14, 2056, 57344},{FDI_VPMASKMOVD, 45, 1066, 57344},{FDI_VPMASKMOVQ, 45, 1066, 57344},{FDI_VPMASKMOVD, 39, 1066, 57344},{FDI_VPMASKMOVQ, 39, 1066, 57344},{FDI_VPGATHERDD, 32798, 3112, 57344},{FDI_VPGATHERDQ, 32798, 4136, 57344},{FDI_VPGATHERQD, 32798, 3132, 59392},{FDI_VPGATHERQQ, 32798, 4136, 57344},{FDI_VGATHERDPS, 32798, 3112, 57344},{FDI_VGATHERDPD, 32798, 4136, 57344},{FDI_VGATHERQPS, 32798, 3132, 59392},{FDI_VGATHERQPD, 32798, 4136, 57344},{FDI_VFMADDSUB132PS, 45, 1066, 57344},{FDI_VFMADDSUB132PD, 45, 1066, 57344},{FDI_VFMSUBADD132PS, 45, 1066, 57344},{FDI_VFMSUBADD132PD, 45, 1066, 57344},{FDI_VFMADD132PS, 45, 1066, 57344},{FDI_VFMADD132PD, 45, 1066, 57344},{FDI_VFMADD132SS, 45, 21505, 49152},{FDI_VFMADD132SD, 45, 29697, 49152},{FDI_VFMSUB132PS, 45, 1066, 57344},{FDI_VFMSUB132PD, 45, 1066, 57344},{FDI_VFMSUB132SS, 45, 21505, 49152},{FDI_VFMSUB132SD, 45, 29697, 49152},{FDI_VFNMADD132PS, 45, 1066, 57344},{FDI_VFNMADD132PD, 45, 1066, 57344},{FDI_VFNMADD132SS, 45, 21505, 49152},{FDI_VFNMADD132SD, 45, 29697, 49152},{FDI_VFNMSUB132PS, 45, 1066, 57344},{FDI_VFNMSUB132PD, 45, 1066, 57344},{FDI_VFNMSUB132SS, 45, 21505, 49152},{FDI_VFNMSUB132SD, 45, 29697, 49152},{FDI_VFMADDSUB213PS, 45, 1066, 57344},{FDI_VFMADDSUB213PD, 45, 1066, 57344},{FDI_VFMSUBADD213PS, 45, 1066, 57344},{FDI_VFMSUBADD213PD, 45, 1066, 57344},{FDI_VFMADD213PS, 45, 1066, 57344},{FDI_VFMADD213PD, 45, 1066, 57344},{FDI_VFMADD213SS, 45, 21505, 49152},{FDI_VFMADD213SD, 45, 29697, 49152},{FDI_VFMSUB213PS, 45, 1066, 57344},{FDI_VFMSUB213PD, 45, 1066, 57344},{FDI_VFMSUB213SS, 45, 21505, 49152},{FDI_VFMSUB213SD, 45, 29697, 49152},{FDI_VFNMADD213PS, 45, 1066, 57344},{FDI_VFNMADD213PD, 45, 1066, 57344},{FDI_VFNMADD213SS, 45, 21505, 49152},{FDI_VFNMADD213SD, 45, 29697, 49152},{FDI_VFNMSUB213PS, 45, 1066, 57344},{FDI_VFNMSUB213PD, 45, 1066, 57344},{FDI_VFNMSUB213SS, 45, 21505, 49152},{FDI_VFNMSUB213SD, 45, 29697, 49152},{FDI_VFMADDSUB231PS, 45, 1066, 57344},{FDI_VFMADDSUB231PD, 45, 1066, 57344},{FDI_VFMSUBADD231PS, 45, 1066, 57344},{FDI_VFMSUBADD231PD, 45, 1066, 57344},{FDI_VFMADD231PS, 45, 1066, 57344},{FDI_VFMADD231PD, 45, 1066, 57344},{FDI_VFMADD231SS, 45, 21505, 49152},{FDI_VFMADD231SD, 45, 29697, 49152},{FDI_VFMSUB231PS, 45, 1066, 57344},{FDI_VFMSUB231PD, 45, 1066, 57344},{FDI_VFMSUB231SS, 45, 21505, 49152},{FDI_VFMSUB231SD, 45, 29697, 49152},{FDI_VFNMADD231PS, 45, 1066, 57344},{FDI_VFNMADD231PD, 45, 1066, 57344},{FDI_VFNMADD231SS, 45, 21505, 49152},{FDI_VFNMADD231SD, 45, 29697, 49152},{FDI_VFNMSUB231PS, 45, 1066, 57344},{FDI_VFNMSUB231PD, 45, 1066, 57344},{FDI_VFNMSUB231SS, 45, 21505, 49152},{FDI_VFNMSUB231SD, 45, 29697, 49152},{FDI_VPERMQ, 20558, 1098, 57344},{FDI_VPERMPD, 20558, 1098, 57344},{FDI_VPBLENDD, 20525, 1130, 57344},{FDI_VPERMILPS, 20558, 1098, 57344},{FDI_VPERMILPD, 20558, 1098, 57344},{FDI_VPERM2F128, 20525, 1130, 57344},{FDI_VROUNDPS, 20558, 1098, 57344},{FDI_VROUNDPD, 20558, 1098, 57344},{FDI_VROUNDSS, 20525, 21569, 49152},{FDI_VROUNDSD, 20525, 29761, 49152},{FDI_VBLENDPS, 20525, 1130, 57344},{FDI_VBLENDPD, 20525, 1130, 57344},{FDI_VPBLENDW, 20525, 1130, 57344},{FDI_VPALIGNR, 20525, 1130, 57344},{FDI_VPEXTRB, 20555, 5185, 49152},{FDI_VPEXTRB, 20555, 21569, 49153},{FDI_VPEXTRW, 20555, 13377, 49152},{FDI_VPEXTRW, 20555, 21569, 49153},{FDI_VPEXTRD, 20555, 5186, 49153},{FDI_VPEXTRQ, 20555, 5186, 49153},{FDI_VEXTRACTPS, 20555, 21569, 49153},{FDI_VINSERTF128, 20525, 5224, 57344},{FDI_VEXTRACTF128, 20555, 5192, 57344},{FDI_VCVTPS2PH, 20555, 1099, 59392},{FDI_VPINSRB, 20525, 5185, 49153},{FDI_VINSERTPS, 20525, 21569, 49152},{FDI_VPINSRD, 20525, 5186, 49153},{FDI_VPINSRQ, 20525, 5186, 49153},{FDI_VINSERTI128, 20525, 5224, 57344},{FDI_VEXTRACTI128, 20555, 5192, 57344},{FDI_VDPPS, 20525, 1130, 57344},{FDI_VDPPD, 20525, 1130, 57344},{FDI_VMPSADBW, 20525, 1130, 57344},{FDI_VPCLMULQDQ, 20525, 1130, 57344},{FDI_VPERM2I128, 20525, 1130, 57344},{FDI_VBLENDVPS, 12333, 1194, 57344},{FDI_VBLENDVPD, 12333, 1194, 57344},{FDI_VPBLENDVB, 12333, 1194, 57344},{FDI_VPCMPESTRM, 20558, 1098, 57344},{FDI_VPCMPESTRI, 20558, 1098, 57344},{FDI_VPCMPISTRM, 20558, 1098, 57344},{FDI_VPCMPISTRI, 20558, 1098, 57344},{FDI_ANDN, 45, 1066, 49225},{FDI_BLSR, 50, 1058, 49217},{FDI_BLSMSK, 50, 1058, 49217},{FDI_BLSI, 50, 1058, 49217},{FDI_BEXTR, 30, 1066, 49225},{FDI_RORX, 20558, 1098, 49161},{FDI_BZHI, 30, 1066, 49225},{FDI_PDEP, 45, 1066, 49225},{FDI_PEXT, 45, 1066, 49225},{FDI_MULX, 45, 1066, 49225},{FDI_SHLX, 30, 1066, 49225},{FDI_SHRX, 30, 1066, 49225},{FDI_SARX, 30, 1066, 49225},{FDI_ADCX, 14, 1034, 49161},{FDI_ADOX, 14, 1034, 49161},{FDI_FADD, 3, 3072, 16384},{FDI_FMUL, 3, 3072, 16384},{FDI_FCOM, 3, 3072, 16384},{FDI_FCOMP, 3, 3072, 16384},{FDI_FSUB, 3, 3072, 16384},{FDI_FSUBR, 3, 3072, 16384},{FDI_FDIV, 3, 3072, 16384},{FDI_FDIVR, 3, 3072, 16384},{FDI_FADD, 50, 0, 16580},{FDI_FMUL, 50, 0, 16580},{FDI_FCOM, 50, 0, 16580},{FDI_FCOMP, 50, 0, 16580},{FDI_FSUB, 50, 0, 16580},{FDI_FSUBR, 50, 0, 16580},{FDI_FDIV, 50, 0, 16580},{FDI_FDIVR, 50, 0, 16580},{FDI_FLD, 3, 3072, 16384},{FDI_FST, 3, 3072, 16384},{FDI_FSTP, 3, 3072, 16384},{FDI_FLDENV, 3, 0, 16384},{FDI_FLDCW, 3, 2048, 16384},{FDI_FSTENV, 3, 0, 16384},{FDI_FSTCW, 3, 2048, 16384},{FDI_FLD, 3, 0, 16388},{FDI_FXCH, 3, 0, 16388},{FDI_FNOP, 0, 1024, 16384},{FDI_FCHS, 0, 1024, 16384},{FDI_FABS, 0, 1024, 16384},{FDI_FTST, 0, 1024, 16384},{FDI_FXAM, 0, 1024, 16384},{FDI_FLD1, 0, 1024, 16384},{FDI_FLDL2T, 0, 1024, 16384},{FDI_FLDL2E, 0, 1024, 16384},{FDI_FLDPI, 0, 1024, 16384},{FDI_FLDLG2, 0, 1024, 16384},{FDI_FLDLN2, 0, 1024, 16384},{FDI_FLDZ, 0, 1024, 16384},{FDI_F2XM1, 0, 1024, 16384},{FDI_FYL2X, 0, 1024, 16384},{FDI_FPTAN, 0, 1024, 16384},{FDI_FPATAN, 0, 1024, 16384},{FDI_FXTRACT, 0, 1024, 16384},{FDI_FPREM1, 0, 1024, 16384},{FDI_FDECSTP, 0, 1024, 16384},{FDI_FINCSTP, 0, 1024, 16384},{FDI_FPREM, 0, 1024, 16384},{FDI_FYL2XP1, 0, 1024, 16384},{FDI_FSQRT, 0, 1024, 16384},{FDI_FSINCOS, 0, 1024, 16384},{FDI_FRNDINT, 0, 1024, 16384},{FDI_FSCALE, 0, 1024, 16384},{FDI_FSIN, 0, 1024, 16384},{FDI_FCOS, 0, 1024, 16384},{FDI_FIADD, 3, 3072, 16384},{FDI_FIMUL, 3, 3072, 16384},{FDI_FICOM, 3, 3072, 16384},{FDI_FICOMP, 3, 3072, 16384},{FDI_FISUB, 3, 3072, 16384},{FDI_FISUBR, 3, 3072, 16384},{FDI_FIDIV, 3, 3072, 16384},{FDI_FIDIVR, 3, 3072, 16384},{FDI_FCMOVB, 3, 0, 16388},{FDI_FCMOVE, 3, 0, 16388},{FDI_FCMOVBE, 3, 0, 16388},{FDI_FCMOVU, 3, 0, 16388},{FDI_FUCOMPP, 0, 1024, 16384},{FDI_FILD, 3, 3072, 16384},{FDI_FISTTP, 3, 3072, 16384},{FDI_FIST, 3, 3072, 16384},{FDI_FISTP, 3, 3072, 16384},{FDI_FLD, 3, 0, 16384},{FDI_FSTP, 3, 0, 16384},{FDI_FCMOVNB, 3, 0, 16388},{FDI_FCMOVNE, 3, 0, 16388},{FDI_FCMOVNBE, 3, 0, 16388},{FDI_FCMOVNU, 3, 0, 16388},{FDI_FCLEX, 0, 1024, 16384},{FDI_FINIT, 0, 1024, 16384},{FDI_FUCOMI, 3, 0, 16388},{FDI_FCOMI, 3, 0, 16388},{FDI_FADD, 3, 4096, 16384},{FDI_FMUL, 3, 4096, 16384},{FDI_FCOM, 3, 4096, 16384},{FDI_FCOMP, 3, 4096, 16384},{FDI_FSUB, 3, 4096, 16384},{FDI_FSUBR, 3, 4096, 16384},{FDI_FDIV, 3, 4096, 16384},{FDI_FDIVR, 3, 4096, 16384},{FDI_FADD, 35, 0, 16580},{FDI_FMUL, 35, 0, 16580},{FDI_FSUBR, 35, 0, 16580},{FDI_FSUB, 35, 0, 16580},{FDI_FDIVR, 35, 0, 16580},{FDI_FDIV, 35, 0, 16580},{FDI_FLD, 3, 4096, 16384},{FDI_FISTTP, 3, 4096, 16384},{FDI_FST, 3, 4096, 16384},{FDI_FSTP, 3, 4096, 16384},{FDI_FRSTOR, 3, 0, 16384},{FDI_FSAVE, 3, 0, 16384},{FDI_FSTSW, 3, 2048, 16384},{FDI_FFREE, 3, 0, 16388},{FDI_FST, 3, 0, 16388},{FDI_FSTP, 3, 0, 16388},{FDI_FUCOM, 3, 0, 16388},{FDI_FUCOMP, 3, 0, 16388},{FDI_FIADD, 3, 2048, 16384},{FDI_FIMUL, 3, 2048, 16384},{FDI_FICOM, 3, 2048, 16384},{FDI_FICOMP, 3, 2048, 16384},{FDI_FISUB, 3, 2048, 16384},{FDI_FISUBR, 3, 2048, 16384},{FDI_FIDIV, 3, 2048, 16384},{FDI_FIDIVR, 3, 2048, 16384},{FDI_FADDP, 35, 0, 16580},{FDI_FMULP, 35, 0, 16580},{FDI_FCOMPP, 0, 1024, 16384},{FDI_FSUBRP, 35, 0, 16580},{FDI_FSUBP, 35, 0, 16580},{FDI_FDIVRP, 35, 0, 16580},{FDI_FDIVP, 35, 0, 16580},{FDI_FILD, 3, 2048, 16384},{FDI_FISTTP, 3, 2048, 16384},{FDI_FIST, 3, 2048, 16384},{FDI_FISTP, 3, 2048, 16384},{FDI_FBLD, 3, 0, 16384},{FDI_FILD, 3, 4096, 16384},{FDI_FBSTP, 3, 0, 16384},{FDI_FISTP, 3, 4096, 16384},{FDI_FSTSW, 48, 2048, 16448},{FDI_FUCOMIP, 50, 0, 16580},{FDI_FCOMIP, 50, 0, 16580},{FDI_RSTORSSP, 3, 4096, 49152},{FDI_SETSSBSY, 0, 1024, 49152},{FDI_SAVEPREVSSP, 0, 1024, 49152},{FDI_RDSSP, 3, 1026, 49153},{FDI_ENDBR64, 0, 1024, 49152},{FDI_ENDBR32, 0, 1024, 49152},{FDI_WRUSS, 11, 1034, 49160},{FDI_WRSS, 11, 1034, 49160},{FDI_CLRSSBSY, 3, 4096, 49152},{FDI_INCSSP, 3, 1026, 49153},{FDI_CLDEMOTE, 3, 1024, 49152},{FDI_REP_MONTMUL, 0, 1024, 49152},{FDI_REP_XSHA1, 0, 1024, 49152},{FDI_REP_XSHA256, 0, 1024, 49152},{FDI_XSTORE, 0, 1024, 16384},{FDI_REP_XSTORE, 0, 1024, 49152},{FDI_REP_XCRYPTECB, 0, 1024, 49152},{FDI_REP_XCRYPTCBC, 0, 1024, 49152},{FDI_REP_XCRYPTCTR, 0, 1024, 49152},{FDI_REP_XCRYPTCFB, 0, 1024, 49152},{FDI_REP_XCRYPTOFB, 0, 1024, 49152},{FDI_INVEPT, 14, 5128, 53256},{FDI_INVVPID, 14, 5128, 53256},{FDI_VMCALL, 0, 1024, 49152},{FDI_VMCLEAR, 3, 4096, 49152},{FDI_VMFUNC, 0, 1024, 49152},{FDI_VMLAUNCH, 0, 1024, 49152},{FDI_VMRESUME, 0, 1024, 49152},{FDI_VMPTRLD, 3, 4096, 49152},{FDI_VMPTRST, 3, 4096, 49152},{FDI_VMREAD, 11, 1034, 53257},{FDI_VMWRITE, 14, 1034, 53257},{FDI_VMXOFF, 0, 1024, 49152},{FDI_VMXON, 3, 4096, 49152},{FDI_TDCALL, 0, 1024, 49152},{FDI_SEAMRET, 0, 1024, 49152},{FDI_SEAMOPS, 0, 1024, 49152},{FDI_SEAMCALL, 0, 1024, 49152},{FDI_CLZERO, 48, 1056, 16448},{FDI_RDPRU, 0, 1024, 16384},{FDI_VMRUN, 0, 1024, 16384},{FDI_VMMCALL, 0, 1024, 16384},{FDI_VMGEXIT, 0, 1024, 49152},{FDI_VMLOAD, 0, 1024, 16384},{FDI_VMSAVE, 0, 1024, 16384},{FDI_STGI, 0, 1024, 16384},{FDI_CLGI, 0, 1024, 16384},{FDI_SKINIT, 0, 1024, 16384},{FDI_INVLPGA, 0, 1024, 16384},{FDI_MONITORX, 0, 1024, 49152},{FDI_MCOMMIT, 0, 1024, 49152},{FDI_MWAITX, 0, 1024, 49152},{FDI_INVLPGB, 0, 1024, 49152},{FDI_TLBSYNC, 0, 1024, 49152},{FDI_RMPQUERY, 0, 1024, 49152},{FDI_RMPREAD, 0, 1024, 49152},{FDI_RMPADJUST, 0, 1024, 49152},{FDI_RMPUPDATE, 0, 1024, 49152},{FDI_PSMASH, 0, 1024, 49152},{FDI_PVALIDATE, 0, 1024, 49152},{FDI_TPAUSE, 3, 3072, 49153},{FDI_UMONITOR, 3, 1026, 49153},{FDI_UMWAIT, 3, 3072, 49153},{FDI_PTWRITE, 3, 1026, 49153},{FDI_GF2P8MULB, 14, 1034, 57344},{FDI_GF2P8AFFINEQB, 20558, 1098, 57344},{FDI_GF2P8AFFINEINVQB, 20558, 1098, 57344},{FDI_VGF2P8MULB, 45, 1066, 57344},{FDI_VGF2P8AFFINEQB, 20525, 1130, 57344},{FDI_VGF2P8AFFINEINVQB, 20525, 1130, 57344},{FDI_EVX_GF2P8MULB, 557, 1066, 57344},{FDI_EVX_GF2P8AFFINEQB, 21293, 1130, 57344},{FDI_EVX_GF2P8AFFINEINVQB, 21293, 1130, 57344},{FDI_ENQCMD, 14, 7176, 49160},{FDI_ENQCMDS, 14, 7176, 49160},{FDI_PCONFIG, 0, 1024, 49152},{FDI_WBNOINVD, 0, 1024, 32768},{FDI_RDPKRU, 0, 1024, 49152},{FDI_WRPKRU, 0, 1024, 49152},{FDI_RDFSBASE, 3, 1026, 49153},{FDI_RDGSBASE, 3, 1026, 49153},{FDI_WRFSBASE, 3, 1026, 49153},{FDI_WRGSBASE, 3, 1026, 49153},{FDI_XSAVE, 3, 33024, 49152},{FDI_XRSTOR, 3, 33024, 49152},{FDI_XSAVEOPT, 3, 33024, 49152},{FDI_CLWB, 3, 1024, 49152},{FDI_CLFLUSH, 3, 1024, 49152},{FDI_CLFLUSHOPT, 3, 1024, 49152},{FDI_XRSTORS, 3, 33024, 49152},{FDI_XSAVEC, 3, 33024, 49152},{FDI_XSAVES, 3, 33024, 49152},{FDI_RDRAND, 3, 1026, 16385},{FDI_RDSEED, 3, 1026, 16385},{FDI_RDPID, 3, 1026, 53249},{FDI_INVPCID, 14, 5128, 53256},{FDI_SHA1NEXTE, 14, 5120, 49152},{FDI_SHA1MSG1, 14, 5120, 49152},{FDI_SHA1MSG2, 14, 5120, 49152},{FDI_SHA256RNDS2, 30, 5120, 49152},{FDI_SHA256MSG1, 14, 5120, 49152},{FDI_SHA256MSG2, 14, 5120, 49152},{FDI_SHA1RNDS4, 20558, 5184, 49152},{FDI_XSUSLDTRK, 0, 1024, 49152},{FDI_XRESLDTRK, 0, 1024, 49152},{FDI_VPDPBUUD, 45, 1066, 57344},{FDI_VPDPBUSD, 45, 1066, 57344},{FDI_VPDPBSUD, 45, 1066, 57344},{FDI_VPDPBSSD, 45, 1066, 57344},{FDI_VPDPBUUDS, 45, 1066, 57344},{FDI_VPDPBUSDS, 45, 1066, 57344},{FDI_VPDPBSUDS, 45, 1066, 57344},{FDI_VPDPBSSDS, 45, 1066, 57344},{FDI_VPDPWSSD, 45, 1066, 57344},{FDI_VPDPWSSDS, 45, 1066, 57344},{FDI_VCVTNEOPH2PS, 14, 1034, 57344},{FDI_VCVTNEEPH2PS, 14, 1034, 57344},{FDI_VCVTNEEBF162PS, 14, 1034, 57344},{FDI_VCVTNEOBF162PS, 14, 1034, 57344},{FDI_VBCSTNESH2PS, 14, 2056, 57344},{FDI_VBCSTNEBF162PS, 14, 2056, 57344},{FDI_VCVTNEPS2BF16, 14, 1038, 59392},{FDI_VPMADD52LUQ, 45, 1066, 57344},{FDI_VPMADD52HUQ, 45, 1066, 57344},{FDI_HRESET, 20672, 1088, 49152},{FDI_SERIALIZE, 0, 1024, 49152},{FDI_UIRET, 0, 1024, 49152},{FDI_TESTUI, 0, 1024, 49152},{FDI_CLUI, 0, 1024, 49152},{FDI_STUI, 0, 1024, 49152},{FDI_SENDUIPI, 3, 1026, 53249},{FDI_WRMSRNS, 0, 1024, 49152},{FDI_RDMSRLIST, 0, 1024, 49152},{FDI_WRMSRLIST, 0, 1024, 49152},{FDI_AADD, 11, 1034, 49160},{FDI_AAND, 11, 1034, 49160},{FDI_AXOR, 11, 1034, 49160},{FDI_AOR, 11, 1034, 49160},{FDI_CMPOXADD, 27, 1066, 49224},{FDI_CMPNOXADD, 27, 1066, 49224},{FDI_CMPBXADD, 27, 1066, 49224},{FDI_CMPNBXADD, 27, 1066, 49224},{FDI_CMPZXADD, 27, 1066, 49224},{FDI_CMPNZXADD, 27, 1066, 49224},{FDI_CMPBEXADD, 27, 1066, 49224},{FDI_CMPNBEXADD, 27, 1066, 49224},{FDI_CMPSXADD, 27, 1066, 49224},{FDI_CMPNSXADD, 27, 1066, 49224},{FDI_CMPPXADD, 27, 1066, 49224},{FDI_CMPNPXADD, 27, 1066, 49224},{FDI_CMPLXADD, 27, 1066, 49224},{FDI_CMPNLXADD, 27, 1066, 49224},{FDI_CMPLEXADD, 27, 1066, 49224},{FDI_CMPNLEXADD, 27, 1066, 49224},{FDI_AESENCWIDE128KL, 3, 0, 49152},{FDI_AESDECWIDE128KL, 3, 0, 49152},{FDI_AESENCWIDE256KL, 3, 0, 49152},{FDI_AESDECWIDE256KL, 3, 0, 49152},{FDI_AESENC128KL, 14, 8, 57344},{FDI_LOADIWKEY, 14, 1034, 57344},{FDI_AESDEC128KL, 14, 8, 57344},{FDI_AESENC256KL, 14, 8, 57344},{FDI_AESDEC256KL, 14, 8, 57344},{FDI_ENCODEKEY128, 14, 3072, 49161},{FDI_ENCODEKEY256, 14, 3072, 49161},{FDI_LKGS, 3, 2048, 49153},{FDI_ERETU, 0, 1024, 49152},{FDI_ERETS, 0, 1024, 49152},{FDI_LDTILECFG, 3, 0, 49152},{FDI_STTILECFG, 3, 0, 49152},{FDI_TILERELEASE, 0, 1024, 49152},{FDI_TILEZERO, 12, 0, 49200},{FDI_TILELOADDT1, 14, 0, 49200},{FDI_TILESTORED, 11, 0, 49200},{FDI_TILELOADD, 14, 0, 49200},{FDI_TDPBF16PS, 30, 0, 49398},{FDI_TDPFP16PS, 30, 0, 49398},{FDI_TDPBUUD, 30, 0, 49398},{FDI_TDPBUSD, 30, 0, 49398},{FDI_TDPBSUD, 30, 0, 49398},{FDI_TDPBSSD, 30, 0, 49398},{FDI_TCMMRLFP16PS, 30, 0, 49398},{FDI_TCMMIMFP16PS, 30, 0, 49398},{FDI_PBNDKB, 0, 1024, 49152},{FDI_RDMSR, 16515, 27649, 49153},{FDI_WRMSRNS, 16578, 27649, 49153},{FDI_URDMSR, 11, 4096, 49161},{FDI_UWRMSR, 11, 4096, 49161},{FDI_URDMSR, 16515, 27649, 49153},{FDI_UWRMSR, 16578, 27649, 49153},{FDI_VSM4KEY4, 45, 1066, 57344},{FDI_VSM4RNDS4, 45, 1066, 57344},{FDI_EVX_ADDPS, 813, 1066, 58112},{FDI_EVX_ADDPD, 813, 1066, 58112},{FDI_EVX_ADDSS, 557, 21505, 49920},{FDI_EVX_ADDSD, 557, 29697, 49920},{FDI_EVX_AESENC, 45, 1066, 57344},{FDI_EVX_AESENCLAST, 45, 1066, 57344},{FDI_EVX_AESDEC, 45, 1066, 57344},{FDI_EVX_AESDECLAST, 45, 1066, 57344},{FDI_EVX_ANDPS, 813, 1066, 57344},{FDI_EVX_ANDPD, 813, 1066, 57344},{FDI_EVX_ANDNPS, 813, 1066, 57344},{FDI_EVX_ANDNPD, 813, 1066, 57344},{FDI_EVX_CMPPS, 21293, 1122, 57656},{FDI_EVX_CMPPD, 21293, 1122, 57656},{FDI_EVX_CMPSS, 21037, 17489, 49464},{FDI_EVX_CMPSD, 21037, 25681, 49464},{FDI_EVX_COMISS, 14, 3072, 49408},{FDI_EVX_COMISD, 14, 4096, 49408},{FDI_EVX_CVTDQ2PD, 782, 1035, 59648},{FDI_EVX_CVTPD2DQ, 782, 1038, 60160},{FDI_EVX_CVTDQ2PS, 782, 1034, 58112},{FDI_EVX_CVTPS2DQ, 782, 1034, 58112},{FDI_EVX_CVTPS2PD, 782, 1035, 59648},{FDI_EVX_CVTPD2PS, 782, 1038, 60160},{FDI_EVX_CVTSS2SI, 14, 3080, 49928},{FDI_EVX_CVTSD2SI, 14, 4104, 49928},{FDI_EVX_CVTSS2SD, 557, 21505, 49408},{FDI_EVX_CVTSD2SS, 557, 29697, 49920},{FDI_EVX_CVTSI2SS, 45, 5122, 49921},{FDI_EVX_CVTSI2SD, 45, 5122, 49921},{FDI_EVX_CVTTPD2DQ, 782, 1038, 59648},{FDI_EVX_CVTTPS2DQ, 782, 1034, 57600},{FDI_EVX_CVTTSD2SI, 14, 4104, 49416},{FDI_EVX_CVTTSS2SI, 14, 3080, 49416},{FDI_EVX_DIVPS, 813, 1066, 58112},{FDI_EVX_DIVPD, 813, 1066, 58112},{FDI_EVX_DIVSS, 557, 21505, 49920},{FDI_EVX_DIVSD, 557, 29697, 49920},{FDI_EVX_EXTRACTPS, 20555, 21569, 49153},{FDI_EVX_INSERTPS, 20525, 21569, 49152},{FDI_EVX_MAXPS, 813, 1066, 57600},{FDI_EVX_MAXPD, 813, 1066, 57600},{FDI_EVX_MAXSS, 557, 21505, 49408},{FDI_EVX_MAXSD, 557, 29697, 49408},{FDI_EVX_MINPS, 813, 1066, 57600},{FDI_EVX_MINPD, 813, 1066, 57600},{FDI_EVX_MINSS, 557, 21505, 49408},{FDI_EVX_MINSD, 557, 29697, 49408},{FDI_EVX_MOVAPS, 526, 1034, 57344},{FDI_EVX_MOVAPD, 526, 1034, 57344},{FDI_EVX_MOVAPS, 523, 1034, 57344},{FDI_EVX_MOVAPD, 523, 1034, 57344},{FDI_EVX_MOV_X2G, 11, 1034, 49153},{FDI_EVX_MOV_G2X, 14, 1034, 49153},{FDI_EVX_MOVDDUP, 526, 4104, 57344},{FDI_EVX_MOVDDUP, 526, 1034, 57344},{FDI_EVX_MOVDQA32, 526, 1034, 57344},{FDI_EVX_MOVDQA64, 526, 1034, 57344},{FDI_EVX_MOVDQA32, 523, 1034, 57344},{FDI_EVX_MOVDQA64, 523, 1034, 57344},{FDI_EVX_MOVDQU32, 526, 1034, 57344},{FDI_EVX_MOVDQU64, 526, 1034, 57344},{FDI_EVX_MOVDQU32, 523, 1034, 57344},{FDI_EVX_MOVDQU64, 523, 1034, 57344},{FDI_EVX_MOVDQU8, 526, 1034, 57344},{FDI_EVX_MOVDQU16, 526, 1034, 57344},{FDI_EVX_MOVDQU8, 523, 1034, 57344},{FDI_EVX_MOVDQU16, 523, 1034, 57344},{FDI_EVX_MOVLPS, 45, 29697, 49152},{FDI_EVX_MOVHLPS, 45, 5120, 49152},{FDI_EVX_MOVLPD, 45, 29697, 49152},{FDI_EVX_MOVLPS, 11, 4096, 49152},{FDI_EVX_MOVLPD, 11, 4096, 49152},{FDI_EVX_MOVHPS, 45, 29713, 49152},{FDI_EVX_MOVLHPS, 45, 29713, 49152},{FDI_EVX_MOVHPD, 45, 29713, 49152},{FDI_EVX_MOVHPS, 11, 4096, 49152},{FDI_EVX_MOVHPD, 11, 4096, 49152},{FDI_EVX_MOVNTDQA, 14, 1034, 57344},{FDI_EVX_MOVNTDQ, 11, 1034, 57344},{FDI_EVX_MOVNTPS, 11, 1034, 57344},{FDI_EVX_MOVNTPD, 11, 1034, 57344},{FDI_EVX_MOVQ, 14, 4096, 49152},{FDI_EVX_MOVQ, 11, 4096, 49152},{FDI_EVX_MOVSS, 526, 21505, 49152},{FDI_EVX_MOVSS, 557, 21505, 49152},{FDI_EVX_MOVSD, 526, 29697, 49152},{FDI_EVX_MOVSD, 557, 29697, 49152},{FDI_EVX_MOVSS, 523, 3072, 49152},{FDI_EVX_MOVSS, 551, 21508, 49152},{FDI_EVX_MOVSD, 523, 4096, 49152},{FDI_EVX_MOVSD, 551, 29700, 49152},{FDI_EVX_MOVSLDUP, 526, 1034, 57344},{FDI_EVX_MOVSHDUP, 526, 1034, 57344},{FDI_EVX_MOVUPS, 526, 1034, 57344},{FDI_EVX_MOVUPD, 526, 1034, 57344},{FDI_EVX_MOVUPS, 523, 1034, 57344},{FDI_EVX_MOVUPD, 523, 1034, 57344},{FDI_EVX_MULPS, 813, 1066, 58112},{FDI_EVX_MULPD, 813, 1066, 58112},{FDI_EVX_MULSS, 557, 21505, 49920},{FDI_EVX_MULSD, 557, 29697, 49920},{FDI_EVX_ORPS, 813, 1066, 57344},{FDI_EVX_ORPD, 813, 1066, 57344},{FDI_EVX_PABSB, 526, 1034, 57344},{FDI_EVX_PABSW, 526, 1034, 57344},{FDI_EVX_PABSD, 782, 1034, 57344},{FDI_EVX_PABSQ, 782, 1034, 57344},{FDI_EVX_PACKSSWB, 557, 1066, 57344},{FDI_EVX_PACKUSWB, 557, 1066, 57344},{FDI_EVX_PACKSSDW, 813, 1066, 57344},{FDI_EVX_PACKUSDW, 813, 1066, 57344},{FDI_EVX_PADDB, 557, 1066, 57344},{FDI_EVX_PADDW, 557, 1066, 57344},{FDI_EVX_PADDD, 813, 1066, 57344},{FDI_EVX_PADDQ, 813, 1066, 57344},{FDI_EVX_PADDSB, 557, 1066, 57344},{FDI_EVX_PADDSW, 557, 1066, 57344},{FDI_EVX_PADDUSB, 557, 1066, 57344},{FDI_EVX_PADDUSW, 557, 1066, 57344},{FDI_EVX_PALIGNR, 21037, 1130, 57344},{FDI_EVX_PANDD, 813, 1066, 57344},{FDI_EVX_PANDQ, 813, 1066, 57344},{FDI_EVX_PANDND, 813, 1066, 57344},{FDI_EVX_PANDNQ, 813, 1066, 57344},{FDI_EVX_PAVGB, 557, 1066, 57344},{FDI_EVX_PAVGW, 557, 1066, 57344},{FDI_EVX_PCLMULQDQ, 20525, 1130, 57344},{FDI_EVX_PCMPEQB, 557, 34, 57400},{FDI_EVX_PCMPEQW, 557, 34, 57400},{FDI_EVX_PCMPEQD, 813, 34, 57400},{FDI_EVX_PCMPEQQ, 813, 34, 57400},{FDI_EVX_PCMPGTB, 557, 34, 57400},{FDI_EVX_PCMPGTW, 557, 34, 57400},{FDI_EVX_PCMPGTD, 813, 34, 57400},{FDI_EVX_PCMPGTQ, 813, 34, 57400},{FDI_EVX_PEXTRB, 20555, 5185, 49152},{FDI_EVX_PEXTRB, 20555, 21569, 49153},{FDI_EVX_PEXTRW, 20558, 21572, 49160},{FDI_EVX_PEXTRW, 20555, 13377, 49152},{FDI_EVX_PEXTRW, 20555, 21569, 49153},{FDI_EVX_PEXTR, 20555, 5186, 49153},{FDI_EVX_PINSR, 20525, 5185, 49153},{FDI_EVX_PINSR, 20525, 13377, 49153},{FDI_EVX_PINSR, 20525, 5186, 49153},{FDI_EVX_PMADDUBSW, 557, 1066, 57344},{FDI_EVX_PMADDWD, 557, 1066, 57344},{FDI_EVX_PMINUB, 557, 1066, 57344},{FDI_EVX_PMAXUB, 557, 1066, 57344},{FDI_EVX_PMINSW, 557, 1066, 57344},{FDI_EVX_PMAXSW, 557, 1066, 57344},{FDI_EVX_PMINSB, 557, 1066, 57344},{FDI_EVX_PMINSD, 813, 1066, 57344},{FDI_EVX_PMINSQ, 813, 1066, 57344},{FDI_EVX_PMINUW, 557, 1066, 57344},{FDI_EVX_PMINUD, 813, 1066, 57344},{FDI_EVX_PMINUQ, 813, 1066, 57344},{FDI_EVX_PMAXSB, 557, 1066, 57344},{FDI_EVX_PMAXSD, 813, 1066, 57344},{FDI_EVX_PMAXSQ, 813, 1066, 57344},{FDI_EVX_PMAXUW, 557, 1066, 57344},{FDI_EVX_PMAXUD, 813, 1066, 57344},{FDI_EVX_PMAXUQ, 813, 1066, 57344},{FDI_EVX_PMOVSXBW, 526, 1035, 59392},{FDI_EVX_PMOVSXBD, 526, 1035, 61440},{FDI_EVX_PMOVSXBQ, 526, 1035, 63488},{FDI_EVX_PMOVSXWD, 526, 1035, 59392},{FDI_EVX_PMOVSXWQ, 526, 1035, 61440},{FDI_EVX_PMOVSXDQ, 526, 1035, 59392},{FDI_EVX_PMOVZXBW, 526, 1035, 59392},{FDI_EVX_PMOVZXBD, 526, 1035, 61440},{FDI_EVX_PMOVZXBQ, 526, 1035, 63488},{FDI_EVX_PMOVZXWD, 526, 1035, 59392},{FDI_EVX_PMOVZXWQ, 526, 1035, 61440},{FDI_EVX_PMOVZXDQ, 526, 1035, 59392},{FDI_EVX_PMULDQ, 813, 1066, 57344},{FDI_EVX_PMULHRSW, 557, 1066, 57344},{FDI_EVX_PMULHUW, 557, 1066, 57344},{FDI_EVX_PMULHW, 557, 1066, 57344},{FDI_EVX_PMULLW, 557, 1066, 57344},{FDI_EVX_PMULLD, 813, 1066, 57344},{FDI_EVX_PMULLQ, 813, 1066, 57344},{FDI_EVX_PMULUDQ, 813, 1066, 57344},{FDI_EVX_PORD, 813, 1066, 57344},{FDI_EVX_PORQ, 813, 1066, 57344},{FDI_EVX_PSADBW, 45, 1066, 57344},{FDI_EVX_PSHUFB, 557, 1066, 57344},{FDI_EVX_PSHUFD, 21326, 1098, 57344},{FDI_EVX_PSHUFHW, 21070, 1098, 57344},{FDI_EVX_PSHUFLW, 21070, 1098, 57344},{FDI_EVX_PSRLW, 21106, 1122, 57344},{FDI_EVX_PSRAW, 21106, 1122, 57344},{FDI_EVX_PSLLW, 21106, 1122, 57344},{FDI_EVX_PSRLD, 21362, 1122, 57344},{FDI_EVX_PSRAD, 21362, 1122, 57344},{FDI_EVX_PSLLD, 21362, 1122, 57344},{FDI_EVX_PSRLQ, 21362, 1122, 57344},{FDI_EVX_PSRAQ, 21362, 1122, 57344},{FDI_EVX_PSLLQ, 21362, 1122, 57344},{FDI_EVX_PSRLW, 557, 5160, 57344},{FDI_EVX_PSRLD, 557, 5160, 57344},{FDI_EVX_PSRLQ, 557, 5160, 57344},{FDI_EVX_PSRAW, 557, 5160, 57344},{FDI_EVX_PSRAD, 557, 5160, 57344},{FDI_EVX_PSRAQ, 557, 5160, 57344},{FDI_EVX_PSLLW, 557, 5160, 57344},{FDI_EVX_PSLLD, 557, 5160, 57344},{FDI_EVX_PSLLQ, 557, 5160, 57344},{FDI_EVX_PSRLDQ, 20594, 1122, 57344},{FDI_EVX_PSLLDQ, 20594, 1122, 57344},{FDI_EVX_PSUBB, 557, 1066, 57344},{FDI_EVX_PSUBW, 557, 1066, 57344},{FDI_EVX_PSUBD, 813, 1066, 57344},{FDI_EVX_PSUBQ, 813, 1066, 57344},{FDI_EVX_PSUBSB, 557, 1066, 57344},{FDI_EVX_PSUBSW, 557, 1066, 57344},{FDI_EVX_PSUBUSB, 557, 1066, 57344},{FDI_EVX_PSUBUSW, 557, 1066, 57344},{FDI_EVX_PUNPCKLBW, 557, 1066, 57344},{FDI_EVX_PUNPCKLWD, 557, 1066, 57344},{FDI_EVX_PUNPCKLDQ, 813, 1066, 57344},{FDI_EVX_PUNPCKLQDQ, 813, 1066, 57344},{FDI_EVX_PUNPCKHBW, 557, 1066, 57344},{FDI_EVX_PUNPCKHWD, 557, 1066, 57344},{FDI_EVX_PUNPCKHDQ, 813, 1066, 57344},{FDI_EVX_PUNPCKHQDQ, 813, 1066, 57344},{FDI_EVX_PXORD, 813, 1066, 57344},{FDI_EVX_PXORQ, 813, 1066, 57344},{FDI_EVX_SHUFPS, 21293, 1130, 57344},{FDI_EVX_SHUFPD, 21293, 1130, 57344},{FDI_EVX_SQRTPS, 782, 1034, 58112},{FDI_EVX_SQRTPD, 782, 1034, 58112},{FDI_EVX_SQRTSS, 557, 21505, 49920},{FDI_EVX_SQRTSD, 557, 29697, 49920},{FDI_EVX_SUBPS, 813, 1066, 58112},{FDI_EVX_SUBPD, 813, 1066, 58112},{FDI_EVX_SUBSS, 557, 21505, 49920},{FDI_EVX_SUBSD, 557, 29697, 49920},{FDI_EVX_UCOMISS, 14, 3072, 49408},{FDI_EVX_UCOMISD, 14, 4096, 49408},{FDI_EVX_UNPCKLPS, 813, 1066, 57344},{FDI_EVX_UNPCKLPD, 813, 1066, 57344},{FDI_EVX_UNPCKHPS, 813, 1066, 57344},{FDI_EVX_UNPCKHPD, 813, 1066, 57344},{FDI_EVX_ALIGND, 21293, 1130, 57344},{FDI_EVX_ALIGNQ, 21293, 1130, 57344},{FDI_EVX_BLENDMPS, 813, 1066, 57344},{FDI_EVX_BLENDMPD, 813, 1066, 57344},{FDI_EVX_BROADCASTSS, 526, 3080, 57344},{FDI_EVX_BROADCASTF32X2, 526, 4104, 57344},{FDI_EVX_BROADCASTSD, 526, 4104, 57344},{FDI_EVX_BROADCASTF32X4, 526, 5128, 57344},{FDI_EVX_BROADCASTF64X2, 526, 5128, 57344},{FDI_EVX_BROADCASTF32X8, 526, 6152, 57344},{FDI_EVX_BROADCASTF64X4, 526, 6152, 57344},{FDI_EVX_COMPRESSPS, 523, 3080, 57344},{FDI_EVX_COMPRESSPS, 523, 1034, 57344},{FDI_EVX_COMPRESSPD, 523, 4104, 57344},{FDI_EVX_COMPRESSPD, 523, 1034, 57344},{FDI_EVX_CVTNE2PS2BF16, 813, 1066, 57344},{FDI_EVX_CVTNEPS2BF16, 782, 1038, 59392},{FDI_EVX_CVTPS2QQ, 782, 1035, 60160},{FDI_EVX_CVTPD2QQ, 782, 1034, 58112},{FDI_EVX_CVTPS2UDQ, 782, 1034, 58112},{FDI_EVX_CVTPD2UDQ, 782, 1038, 60160},{FDI_EVX_CVTPS2UQQ, 782, 1035, 60160},{FDI_EVX_CVTPD2UQQ, 782, 1034, 58112},{FDI_EVX_CVTPH2PS, 526, 1035, 59648},{FDI_EVX_CVTPS2PH, 21067, 1099, 59648},{FDI_EVX_CVTQQ2PD, 782, 1034, 58112},{FDI_EVX_CVTQQ2PS, 782, 1038, 60160},{FDI_EVX_CVTSD2USI, 14, 4104, 49928},{FDI_EVX_CVTSS2USI, 14, 3080, 49928},{FDI_EVX_CVTUSI2SD, 45, 5122, 49921},{FDI_EVX_CVTUSI2SS, 45, 5122, 49921},{FDI_EVX_CVTTPS2QQ, 782, 1035, 59648},{FDI_EVX_CVTTPD2QQ, 782, 1034, 57600},{FDI_EVX_CVTTPS2UDQ, 782, 1034, 57600},{FDI_EVX_CVTTPD2UDQ, 782, 1038, 59648},{FDI_EVX_CVTTPS2UQQ, 782, 1035, 59648},{FDI_EVX_CVTTPD2UQQ, 782, 1034, 57600},{FDI_EVX_CVTTSD2USI, 14, 4104, 49416},{FDI_EVX_CVTTSS2USI, 14, 3080, 49416},{FDI_EVX_CVTUDQ2PD, 782, 1035, 59648},{FDI_EVX_CVTUDQ2PS, 782, 1034, 58112},{FDI_EVX_CVTUQQ2PD, 782, 1034, 58112},{FDI_EVX_CVTUQQ2PS, 782, 1038, 60160},{FDI_EVX_DBPSADBW, 21037, 1130, 57344},{FDI_EVX_DPBF16PS, 813, 1066, 57344},{FDI_EVX_EXPANDPS, 526, 3080, 57344},{FDI_EVX_EXPANDPS, 526, 1034, 57344},{FDI_EVX_EXPANDPD, 526, 4104, 57344},{FDI_EVX_EXPANDPD, 526, 1034, 57344},{FDI_EVX_EXTRACTF32X4, 21067, 5192, 57344},{FDI_EVX_EXTRACTF64X2, 21067, 5192, 57344},{FDI_EVX_EXTRACTF32X8, 21067, 6216, 57344},{FDI_EVX_EXTRACTF64X4, 21067, 6216, 57344},{FDI_EVX_EXTRACTI32X4, 21067, 5192, 57344},{FDI_EVX_EXTRACTI64X2, 21067, 5192, 57344},{FDI_EVX_EXTRACTI32X8, 21067, 6216, 57344},{FDI_EVX_EXTRACTI64X4, 21067, 6216, 57344},{FDI_EVX_FIXUPIMMPS, 21293, 1130, 57600},{FDI_EVX_FIXUPIMMPD, 21293, 1130, 57600},{FDI_EVX_FIXUPIMMSS, 21037, 21569, 49408},{FDI_EVX_FIXUPIMMSD, 21037, 29761, 49408},{FDI_EVX_FMADDSUB132PS, 813, 1066, 58112},{FDI_EVX_FMADDSUB132PD, 813, 1066, 58112},{FDI_EVX_FMSUBADD132PS, 813, 1066, 58112},{FDI_EVX_FMSUBADD132PD, 813, 1066, 58112},{FDI_EVX_FMADD132PS, 813, 1066, 58112},{FDI_EVX_FMADD132PD, 813, 1066, 58112},{FDI_EVX_FMADD132SS, 557, 21505, 49920},{FDI_EVX_FMADD132SD, 557, 29697, 49920},{FDI_EVX_FMSUB132PS, 813, 1066, 58112},{FDI_EVX_FMSUB132PD, 813, 1066, 58112},{FDI_EVX_FMSUB132SS, 557, 21505, 49920},{FDI_EVX_FMSUB132SD, 557, 29697, 49920},{FDI_EVX_FNMADD132PS, 813, 1066, 58112},{FDI_EVX_FNMADD132PD, 813, 1066, 58112},{FDI_EVX_FNMADD132SS, 557, 21505, 49920},{FDI_EVX_FNMADD132SD, 557, 29697, 49920},{FDI_EVX_FNMSUB132PS, 813, 1066, 58112},{FDI_EVX_FNMSUB132PD, 813, 1066, 58112},{FDI_EVX_FNMSUB132SS, 557, 21505, 49920},{FDI_EVX_FNMSUB132SD, 557, 29697, 49920},{FDI_EVX_FMADDSUB213PS, 813, 1066, 58112},{FDI_EVX_FMADDSUB213PD, 813, 1066, 58112},{FDI_EVX_FMSUBADD213PS, 813, 1066, 58112},{FDI_EVX_FMSUBADD213PD, 813, 1066, 58112},{FDI_EVX_FMADD213PS, 813, 1066, 58112},{FDI_EVX_FMADD213PD, 813, 1066, 58112},{FDI_EVX_FMADD213SS, 557, 21505, 49920},{FDI_EVX_FMADD213SD, 557, 29697, 49920},{FDI_EVX_FMSUB213PS, 813, 1066, 58112},{FDI_EVX_FMSUB213PD, 813, 1066, 58112},{FDI_EVX_FMSUB213SS, 557, 21505, 49920},{FDI_EVX_FMSUB213SD, 557, 29697, 49920},{FDI_EVX_FNMADD213PS, 813, 1066, 58112},{FDI_EVX_FNMADD213PD, 813, 1066, 58112},{FDI_EVX_FNMADD213SS, 557, 21505, 49920},{FDI_EVX_FNMADD213SD, 557, 29697, 49920},{FDI_EVX_FNMSUB213PS, 813, 1066, 58112},{FDI_EVX_FNMSUB213PD, 813, 1066, 58112},{FDI_EVX_FNMSUB213SS, 557, 21505, 49920},{FDI_EVX_FNMSUB213SD, 557, 29697, 49920},{FDI_EVX_FMADDSUB231PS, 813, 1066, 58112},{FDI_EVX_FMADDSUB231PD, 813, 1066, 58112},{FDI_EVX_FMSUBADD231PS, 813, 1066, 58112},{FDI_EVX_FMSUBADD231PD, 813, 1066, 58112},{FDI_EVX_FMADD231PS, 813, 1066, 58112},{FDI_EVX_FMADD231PD, 813, 1066, 58112},{FDI_EVX_FMADD231SS, 557, 21505, 49920},{FDI_EVX_FMADD231SD, 557, 29697, 49920},{FDI_EVX_FMSUB231PS, 813, 1066, 58112},{FDI_EVX_FMSUB231PD, 813, 1066, 58112},{FDI_EVX_FMSUB231SS, 557, 21505, 49920},{FDI_EVX_FMSUB231SD, 557, 29697, 49920},{FDI_EVX_FNMADD231PS, 813, 1066, 58112},{FDI_EVX_FNMADD231PD, 813, 1066, 58112},{FDI_EVX_FNMADD231SS, 557, 21505, 49920},{FDI_EVX_FNMADD231SD, 557, 29697, 49920},{FDI_EVX_FNMSUB231PS, 813, 1066, 58112},{FDI_EVX_FNMSUB231PD, 813, 1066, 58112},{FDI_EVX_FNMSUB231SS, 557, 21505, 49920},{FDI_EVX_FNMSUB231SD, 557, 29697, 49920},{FDI_EVX_FPCLASSPS, 21326, 1090, 57400},{FDI_EVX_FPCLASSPD, 21326, 1090, 57400},{FDI_EVX_FPCLASSSS, 21070, 17473, 49208},{FDI_EVX_FPCLASSSD, 21070, 25665, 49208},{FDI_EVX_GATHERDPS, 33294, 3080, 57344},{FDI_EVX_GATHERDPD, 33294, 4104, 57344},{FDI_EVX_GATHERQPS, 33294, 3084, 59392},{FDI_EVX_GATHERQPD, 33294, 4104, 57344},{FDI_EVX_GETEXPPS, 782, 1034, 57600},{FDI_EVX_GETEXPPD, 782, 1034, 57600},{FDI_EVX_GETEXPSS, 557, 21505, 49408},{FDI_EVX_GETEXPSD, 557, 29697, 49408},{FDI_EVX_GETMANTPS, 21326, 1098, 57600},{FDI_EVX_GETMANTPD, 21326, 1098, 57600},{FDI_EVX_GETMANTSS, 21037, 21569, 49408},{FDI_EVX_GETMANTSD, 21037, 29761, 49408},{FDI_EVX_INSERTF32X4, 21037, 5224, 57344},{FDI_EVX_INSERTF64X2, 21037, 5224, 57344},{FDI_EVX_INSERTF32X8, 21037, 6248, 57344},{FDI_EVX_INSERTF64X4, 21037, 6248, 57344},{FDI_EVX_INSERTI32X4, 21037, 5224, 57344},{FDI_EVX_INSERTI64X2, 21037, 5224, 57344},{FDI_EVX_INSERTI32X8, 21037, 6248, 57344},{FDI_EVX_INSERTI64X4, 21037, 6248, 57344},{FDI_EVX_P2INTERSECTD, 301, 34, 57400},{FDI_EVX_P2INTERSECTQ, 301, 34, 57400},{FDI_EVX_PBLENDMB, 557, 1066, 57344},{FDI_EVX_PBLENDMW, 557, 1066, 57344},{FDI_EVX_PBLENDMD, 813, 1066, 57344},{FDI_EVX_PBLENDMQ, 813, 1066, 57344},{FDI_EVX_PBROADCAST, 526, 1032, 57345},{FDI_EVX_PBROADCAST, 526, 2056, 57345},{FDI_EVX_PBROADCAST, 526, 3080, 57345},{FDI_EVX_PBROADCAST, 526, 4104, 57345},{FDI_EVX_PBROADCASTB, 526, 1032, 57344},{FDI_EVX_PBROADCASTW, 526, 2056, 57344},{FDI_EVX_PBROADCASTD, 526, 3080, 57344},{FDI_EVX_PBROADCASTQ, 526, 4104, 57344},{FDI_EVX_BROADCASTI32X2, 526, 4104, 57344},{FDI_EVX_BROADCASTI32X4, 526, 5128, 57344},{FDI_EVX_BROADCASTI64X2, 526, 5128, 57344},{FDI_EVX_BROADCASTI32X8, 526, 6152, 57344},{FDI_EVX_BROADCASTI64X4, 526, 6152, 57344},{FDI_EVX_PBROADCASTMB2Q, 14, 8, 57351},{FDI_EVX_PBROADCASTMW2D, 14, 8, 57351},{FDI_EVX_PCMPUD, 21293, 98, 57400},{FDI_EVX_PCMPD, 21293, 98, 57400},{FDI_EVX_PCMPUQ, 21293, 98, 57400},{FDI_EVX_PCMPQ, 21293, 98, 57400},{FDI_EVX_PCMPUB, 21037, 98, 57400},{FDI_EVX_PCMPB, 21037, 98, 57400},{FDI_EVX_PCMPUW, 21037, 98, 57400},{FDI_EVX_PCMPW, 21037, 98, 57400},{FDI_EVX_PCOMPRESSB, 523, 1032, 57344},{FDI_EVX_PCOMPRESSB, 523, 1034, 57344},{FDI_EVX_PCOMPRESSW, 523, 2056, 57344},{FDI_EVX_PCOMPRESSW, 523, 1034, 57344},{FDI_EVX_PCOMPRESSD, 523, 3080, 57344},{FDI_EVX_PCOMPRESSD, 523, 1034, 57344},{FDI_EVX_PCOMPRESSQ, 523, 4104, 57344},{FDI_EVX_PCOMPRESSQ, 523, 1034, 57344},{FDI_EVX_PCONFLICTD, 782, 1034, 57344},{FDI_EVX_PCONFLICTQ, 782, 1034, 57344},{FDI_EVX_PDPBUSD, 813, 1066, 57344},{FDI_EVX_PDPBUSDS, 813, 1066, 57344},{FDI_EVX_PDPWSSD, 813, 1066, 57344},{FDI_EVX_PDPWSSDS, 813, 1066, 57344},{FDI_EVX_PERMB, 557, 1066, 57344},{FDI_EVX_PERMW, 557, 1066, 57344},{FDI_EVX_PERMD, 813, 1066, 57344},{FDI_EVX_PERMI2B, 557, 1066, 57344},{FDI_EVX_PERMI2W, 557, 1066, 57344},{FDI_EVX_PERMI2D, 813, 1066, 57344},{FDI_EVX_PERMI2Q, 813, 1066, 57344},{FDI_EVX_PERMI2PS, 813, 1066, 57344},{FDI_EVX_PERMI2PD, 813, 1066, 57344},{FDI_EVX_PERMILPS, 813, 1066, 57344},{FDI_EVX_PERMILPD, 813, 1066, 57344},{FDI_EVX_PERMILPS, 21326, 1098, 57344},{FDI_EVX_PERMILPD, 21326, 1098, 57344},{FDI_EVX_PERMPS, 813, 1066, 57344},{FDI_EVX_PERMPD, 813, 1066, 57344},{FDI_EVX_PERMQ, 813, 1066, 57344},{FDI_EVX_PERMQ, 21326, 1098, 57344},{FDI_EVX_PERMPD, 21326, 1098, 57344},{FDI_EVX_PERMT2B, 557, 1066, 57344},{FDI_EVX_PERMT2W, 557, 1066, 57344},{FDI_EVX_PERMT2D, 813, 1066, 57344},{FDI_EVX_PERMT2Q, 813, 1066, 57344},{FDI_EVX_PERMT2PS, 813, 1066, 57344},{FDI_EVX_PERMT2PD, 813, 1066, 57344},{FDI_EVX_PEXPANDB, 526, 1032, 57344},{FDI_EVX_PEXPANDB, 526, 1034, 57344},{FDI_EVX_PEXPANDW, 526, 2056, 57344},{FDI_EVX_PEXPANDW, 526, 1034, 57344},{FDI_EVX_PEXPANDD, 526, 3080, 57344},{FDI_EVX_PEXPANDD, 526, 1034, 57344},{FDI_EVX_PEXPANDQ, 526, 4104, 57344},{FDI_EVX_PEXPANDQ, 526, 1034, 57344},{FDI_EVX_PGATHERDD, 33294, 3080, 57344},{FDI_EVX_PGATHERDQ, 33294, 4104, 57344},{FDI_EVX_PGATHERQD, 33294, 3084, 59392},{FDI_EVX_PGATHERQQ, 33294, 4104, 57344},{FDI_EVX_PLZCNTD, 782, 1034, 57344},{FDI_EVX_PLZCNTQ, 782, 1034, 57344},{FDI_EVX_PMADD52LUQ, 813, 1066, 57344},{FDI_EVX_PMADD52HUQ, 813, 1066, 57344},{FDI_EVX_PMOVB2M, 14, 2, 57400},{FDI_EVX_PMOVW2M, 14, 2, 57400},{FDI_EVX_PMOVD2M, 14, 2, 57400},{FDI_EVX_PMOVQ2M, 14, 2, 57400},{FDI_EVX_PMOVM2B, 14, 8, 57351},{FDI_EVX_PMOVM2W, 14, 8, 57351},{FDI_EVX_PMOVM2D, 14, 8, 57351},{FDI_EVX_PMOVM2Q, 14, 8, 57351},{FDI_EVX_PMOVWB, 523, 1035, 59392},{FDI_EVX_PMOVSWB, 523, 1035, 59392},{FDI_EVX_PMOVUSWB, 523, 1035, 59392},{FDI_EVX_PMOVDB, 523, 1035, 61440},{FDI_EVX_PMOVSDB, 523, 1035, 61440},{FDI_EVX_PMOVUSDB, 523, 1035, 61440},{FDI_EVX_PMOVQB, 523, 1035, 63488},{FDI_EVX_PMOVSQB, 523, 1035, 63488},{FDI_EVX_PMOVUSQB, 523, 1035, 63488},{FDI_EVX_PMOVDW, 523, 1035, 59392},{FDI_EVX_PMOVSDW, 523, 1035, 59392},{FDI_EVX_PMOVUSDW, 523, 1035, 59392},{FDI_EVX_PMOVQW, 523, 1035, 61440},{FDI_EVX_PMOVSQW, 523, 1035, 61440},{FDI_EVX_PMOVUSQW, 523, 1035, 61440},{FDI_EVX_PMOVQD, 523, 1035, 59392},{FDI_EVX_PMOVSQD, 523, 1035, 59392},{FDI_EVX_PMOVUSQD, 523, 1035, 59392},{FDI_EVX_PMULTISHIFTQB, 813, 1066, 57344},{FDI_EVX_POPCNTB, 526, 1034, 57344},{FDI_EVX_POPCNTW, 526, 1034, 57344},{FDI_EVX_POPCNTD, 782, 1034, 57344},{FDI_EVX_POPCNTQ, 782, 1034, 57344},{FDI_EVX_PRORVD, 813, 1066, 57344},{FDI_EVX_PRORVQ, 813, 1066, 57344},{FDI_EVX_PRORD, 21362, 1122, 57344},{FDI_EVX_PRORQ, 21362, 1122, 57344},{FDI_EVX_PROLVD, 813, 1066, 57344},{FDI_EVX_PROLVQ, 813, 1066, 57344},{FDI_EVX_PROLD, 21362, 1122, 57344},{FDI_EVX_PROLQ, 21362, 1122, 57344},{FDI_EVX_PSCATTERDD, 33291, 3080, 57344},{FDI_EVX_PSCATTERDQ, 33291, 4104, 57344},{FDI_EVX_PSCATTERQD, 33291, 3084, 59392},{FDI_EVX_PSCATTERQQ, 33291, 4104, 57344},{FDI_EVX_PSHLDW, 21037, 1130, 57344},{FDI_EVX_PSHLDD, 21293, 1130, 57344},{FDI_EVX_PSHLDQ, 21293, 1130, 57344},{FDI_EVX_PSHLDVW, 557, 1066, 57344},{FDI_EVX_PSHLDVD, 813, 1066, 57344},{FDI_EVX_PSHLDVQ, 813, 1066, 57344},{FDI_EVX_PSHRDW, 21037, 1130, 57344},{FDI_EVX_PSHRDD, 21293, 1130, 57344},{FDI_EVX_PSHRDQ, 21293, 1130, 57344},{FDI_EVX_PSHRDVW, 557, 1066, 57344},{FDI_EVX_PSHRDVD, 813, 1066, 57344},{FDI_EVX_PSHRDVQ, 813, 1066, 57344},{FDI_EVX_PSHUFBITQMB, 557, 34, 57400},{FDI_EVX_PSLLVW, 557, 1066, 57344},{FDI_EVX_PSLLVD, 813, 1066, 57344},{FDI_EVX_PSLLVQ, 813, 1066, 57344},{FDI_EVX_PSRAVW, 557, 1066, 57344},{FDI_EVX_PSRAVD, 813, 1066, 57344},{FDI_EVX_PSRAVQ, 813, 1066, 57344},{FDI_EVX_PSRLVW, 557, 1066, 57344},{FDI_EVX_PSRLVD, 813, 1066, 57344},{FDI_EVX_PSRLVQ, 813, 1066, 57344},{FDI_EVX_PTERNLOGD, 21293, 1130, 57344},{FDI_EVX_PTERNLOGQ, 21293, 1130, 57344},{FDI_EVX_PTESTMB, 557, 34, 57400},{FDI_EVX_PTESTMW, 557, 34, 57400},{FDI_EVX_PTESTMD, 813, 34, 57400},{FDI_EVX_PTESTMQ, 813, 34, 57400},{FDI_EVX_PTESTNMB, 557, 34, 57400},{FDI_EVX_PTESTNMW, 557, 34, 57400},{FDI_EVX_PTESTNMD, 813, 34, 57400},{FDI_EVX_PTESTNMQ, 813, 34, 57400},{FDI_EVX_RANGEPS, 21293, 1130, 57600},{FDI_EVX_RANGEPD, 21293, 1130, 57600},{FDI_EVX_RANGESS, 21037, 21569, 49408},{FDI_EVX_RANGESD, 21037, 29761, 49408},{FDI_EVX_RCP14PS, 782, 1034, 57344},{FDI_EVX_RCP14PD, 782, 1034, 57344},{FDI_EVX_RCP14SS, 557, 21505, 49152},{FDI_EVX_RCP14SD, 557, 29697, 49152},{FDI_EVX_REDUCEPS, 21326, 1098, 57600},{FDI_EVX_REDUCEPD, 21326, 1098, 57600},{FDI_EVX_REDUCESS, 21037, 21569, 49408},{FDI_EVX_REDUCESD, 21037, 29761, 49408},{FDI_EVX_RNDSCALEPS, 21326, 1098, 57600},{FDI_EVX_RNDSCALEPD, 21326, 1098, 57600},{FDI_EVX_RNDSCALESS, 21037, 21569, 49408},{FDI_EVX_RNDSCALESD, 21037, 29761, 49408},{FDI_EVX_RSQRT14PS, 782, 1034, 57344},{FDI_EVX_RSQRT14PD, 782, 1034, 57344},{FDI_EVX_RSQRT14SS, 557, 21505, 49152},{FDI_EVX_RSQRT14SD, 557, 29697, 49152},{FDI_EVX_SCALEFPS, 813, 1066, 58112},{FDI_EVX_SCALEFPD, 813, 1066, 58112},{FDI_EVX_SCALEFSS, 557, 21505, 49920},{FDI_EVX_SCALEFSD, 557, 29697, 49920},{FDI_EVX_SCATTERDPS, 33291, 3080, 57344},{FDI_EVX_SCATTERDPD, 33291, 4104, 57344},{FDI_EVX_SCATTERQPS, 33291, 3084, 59392},{FDI_EVX_SCATTERQPD, 33291, 4104, 57344},{FDI_EVX_SHUFF32X4, 21293, 1130, 57344},{FDI_EVX_SHUFF64X2, 21293, 1130, 57344},{FDI_EVX_SHUFI32X4, 21293, 1130, 57344},{FDI_EVX_SHUFI64X2, 21293, 1130, 57344},{FDI_EVX_XORPS, 813, 1066, 57344},{FDI_EVX_XORPD, 813, 1066, 57344},{FDI_KANDB, 45, 1024, 49343},{FDI_KANDW, 45, 2048, 49343},{FDI_KANDD, 45, 3072, 49343},{FDI_KANDQ, 45, 4096, 49343},{FDI_KANDNB, 45, 1024, 49343},{FDI_KANDNW, 45, 2048, 49343},{FDI_KANDND, 45, 3072, 49343},{FDI_KANDNQ, 45, 4096, 49343},{FDI_KNOTB, 14, 1024, 49215},{FDI_KNOTW, 14, 2048, 49215},{FDI_KNOTD, 14, 3072, 49215},{FDI_KNOTQ, 14, 4096, 49215},{FDI_KORB, 45, 1024, 49343},{FDI_KORW, 45, 2048, 49343},{FDI_KORD, 45, 3072, 49343},{FDI_KORQ, 45, 4096, 49343},{FDI_KXNORB, 45, 1024, 49343},{FDI_KXNORW, 45, 2048, 49343},{FDI_KXNORD, 45, 3072, 49343},{FDI_KXNORQ, 45, 4096, 49343},{FDI_KXORB, 45, 1024, 49343},{FDI_KXORW, 45, 2048, 49343},{FDI_KXORD, 45, 3072, 49343},{FDI_KXORQ, 45, 4096, 49343},{FDI_KADDB, 45, 1024, 49343},{FDI_KADDW, 45, 2048, 49343},{FDI_KADDD, 45, 3072, 49343},{FDI_KADDQ, 45, 4096, 49343},{FDI_KUNPCKBW, 45, 9220, 49343},{FDI_KUNPCKWD, 45, 18436, 49343},{FDI_KUNPCKDQ, 45, 27652, 49343},{FDI_KORTESTB, 14, 1024, 49215},{FDI_KORTESTW, 14, 2048, 49215},{FDI_KORTESTD, 14, 3072, 49215},{FDI_KORTESTQ, 14, 4096, 49215},{FDI_KMOVB, 14, 1024, 49215},{FDI_KMOVW, 14, 2048, 49215},{FDI_KMOVD, 14, 3072, 49215},{FDI_KMOVQ, 14, 4096, 49215},{FDI_KMOVB, 11, 1024, 49208},{FDI_KMOVW, 11, 2048, 49208},{FDI_KMOVD, 11, 3072, 49208},{FDI_KMOVQ, 11, 4096, 49208},{FDI_KMOVB, 14, 17409, 49209},{FDI_KMOVW, 14, 18433, 49209},{FDI_KMOVD, 14, 3072, 49209},{FDI_KMOVQ, 14, 4096, 49209},{FDI_KMOVB, 14, 17412, 49167},{FDI_KMOVW, 14, 18436, 49167},{FDI_KMOVD, 14, 3072, 49167},{FDI_KMOVQ, 14, 4096, 49167},{FDI_KTESTB, 14, 1024, 49215},{FDI_KTESTW, 14, 2048, 49215},{FDI_KTESTD, 14, 3072, 49215},{FDI_KTESTQ, 14, 4096, 49215},{FDI_KSHIFTRB, 20558, 1088, 49215},{FDI_KSHIFTRW, 20558, 2112, 49215},{FDI_KSHIFTRD, 20558, 3136, 49215},{FDI_KSHIFTRQ, 20558, 4160, 49215},{FDI_KSHIFTLB, 20558, 1088, 49215},{FDI_KSHIFTLW, 20558, 2112, 49215},{FDI_KSHIFTLD, 20558, 3136, 49215},{FDI_KSHIFTLQ, 20558, 4160, 49215},{FDI_EVX_RNDSCALEPH, 21326, 1098, 58624},{FDI_EVX_RNDSCALESH, 21037, 13377, 49408},{FDI_EVX_GETMANTPH, 21326, 1098, 58624},{FDI_EVX_GETMANTSH, 21037, 13377, 49408},{FDI_EVX_REDUCEPH, 21326, 1098, 58624},{FDI_EVX_REDUCESH, 21037, 13377, 49408},{FDI_EVX_FPCLASSPH, 21326, 66, 58424},{FDI_EVX_FPCLASSSH, 21070, 9281, 49208},{FDI_EVX_CMPPH, 21293, 98, 58680},{FDI_EVX_CMPSH, 21037, 9297, 49464},{FDI_EVX_MOVSH, 526, 13313, 49152},{FDI_EVX_MOVSH, 557, 13313, 49152},{FDI_EVX_MOVSH, 523, 2048, 49152},{FDI_EVX_MOVSH, 551, 13316, 49152},{FDI_EVX_CVTSS2SH, 557, 21505, 49920},{FDI_EVX_CVTPS2PHX, 782, 1038, 60160},{FDI_EVX_CVTSI2SH, 45, 5122, 49921},{FDI_EVX_CVTTSH2SI, 14, 2056, 49416},{FDI_EVX_CVTSH2SI, 14, 2056, 49928},{FDI_EVX_UCOMISH, 14, 2048, 49408},{FDI_EVX_COMISH, 14, 2048, 49408},{FDI_EVX_SQRTPH, 782, 1034, 59136},{FDI_EVX_SQRTSH, 557, 13313, 49920},{FDI_EVX_ADDPH, 813, 1066, 59136},{FDI_EVX_ADDSH, 557, 13313, 49920},{FDI_EVX_MULPH, 813, 1066, 59136},{FDI_EVX_MULSH, 557, 13313, 49920},{FDI_EVX_CVTPH2PD, 782, 1035, 62720},{FDI_EVX_CVTPD2PH, 782, 1038, 62208},{FDI_EVX_CVTSH2SD, 557, 13313, 49408},{FDI_EVX_CVTSD2SH, 557, 29697, 49920},{FDI_EVX_CVTDQ2PH, 782, 1038, 60160},{FDI_EVX_CVTQQ2PH, 782, 1038, 62208},{FDI_EVX_CVTPH2DQ, 782, 1035, 61184},{FDI_EVX_CVTTPH2DQ, 782, 1035, 60672},{FDI_EVX_SUBPH, 813, 1066, 59136},{FDI_EVX_SUBSH, 557, 13313, 49920},{FDI_EVX_MINPH, 813, 1066, 58624},{FDI_EVX_MINSH, 557, 13313, 49408},{FDI_EVX_DIVPH, 813, 1066, 59136},{FDI_EVX_DIVSH, 557, 13313, 49920},{FDI_EVX_MAXPH, 813, 1066, 58624},{FDI_EVX_MAXSH, 557, 13313, 49408},{FDI_EVX_MOVW_G2X, 14, 13313, 49153},{FDI_EVX_CVTTPH2UDQ, 782, 1035, 60672},{FDI_EVX_CVTTPH2UQQ, 782, 1035, 62720},{FDI_EVX_CVTTSH2USI, 14, 2056, 49416},{FDI_EVX_CVTPH2UDQ, 782, 1035, 61184},{FDI_EVX_CVTPH2UQQ, 782, 1035, 63232},{FDI_EVX_CVTSH2USI, 14, 2056, 49928},{FDI_EVX_CVTTPH2QQ, 782, 1035, 62720},{FDI_EVX_CVTUDQ2PH, 782, 1038, 60160},{FDI_EVX_CVTUQQ2PH, 782, 1038, 62208},{FDI_EVX_CVTPH2QQ, 782, 1035, 63232},{FDI_EVX_CVTUSI2SH, 45, 5122, 49921},{FDI_EVX_CVTTPH2UW, 782, 1034, 58624},{FDI_EVX_CVTTPH2W, 782, 1034, 58624},{FDI_EVX_CVTPH2UW, 782, 1034, 59136},{FDI_EVX_CVTPH2W, 782, 1034, 59136},{FDI_EVX_CVTW2PH, 782, 1034, 59136},{FDI_EVX_CVTUW2PH, 782, 1034, 59136},{FDI_EVX_MOVW_X2G, 11, 2048, 49153},{FDI_EVX_CVTPH2PSX, 782, 1035, 60672},{FDI_EVX_CVTSH2SS, 557, 13313, 49408},{FDI_EVX_SCALEFPH, 813, 1066, 59136},{FDI_EVX_SCALEFSH, 557, 13313, 49920},{FDI_EVX_GETEXPPH, 782, 1034, 58624},{FDI_EVX_GETEXPSH, 557, 13313, 49408},{FDI_EVX_RCPPH, 782, 1034, 58368},{FDI_EVX_RCPSH, 557, 13313, 49152},{FDI_EVX_RSQRTPH, 782, 1034, 58368},{FDI_EVX_RSQRTSH, 557, 13313, 49152},{FDI_EVX_FMADDCPH, 813, 1066, 58112},{FDI_EVX_FCMADDCPH, 813, 1066, 58112},{FDI_EVX_FMADDCSH, 557, 21505, 49920},{FDI_EVX_FCMADDCSH, 557, 21505, 49920},{FDI_EVX_FMULCPH, 813, 1066, 58112},{FDI_EVX_FCMULCPH, 813, 1066, 58112},{FDI_EVX_FMULCSH, 557, 21505, 49920},{FDI_EVX_FCMULCSH, 557, 21505, 49920},{FDI_EVX_FMADDSUB132PH, 813, 1066, 59136},{FDI_EVX_FMADDSUB213PH, 813, 1066, 59136},{FDI_EVX_FMADDSUB231PH, 813, 1066, 59136},{FDI_EVX_FMSUBADD132PH, 813, 1066, 59136},{FDI_EVX_FMSUBADD213PH, 813, 1066, 59136},{FDI_EVX_FMSUBADD231PH, 813, 1066, 59136},{FDI_EVX_FMADD132PH, 813, 1066, 59136},{FDI_EVX_FMADD213PH, 813, 1066, 59136},{FDI_EVX_FMADD231PH, 813, 1066, 59136},{FDI_EVX_FMADD132SH, 557, 13313, 49920},{FDI_EVX_FMADD213SH, 557, 13313, 49920},{FDI_EVX_FMADD231SH, 557, 13313, 49920},{FDI_EVX_FMSUB132PH, 813, 1066, 59136},{FDI_EVX_FMSUB213PH, 813, 1066, 59136},{FDI_EVX_FMSUB231PH, 813, 1066, 59136},{FDI_EVX_FMSUB132SH, 557, 13313, 49920},{FDI_EVX_FMSUB213SH, 557, 13313, 49920},{FDI_EVX_FMSUB231SH, 557, 13313, 49920},{FDI_EVX_FNMADD132PH, 813, 1066, 59136},{FDI_EVX_FNMADD213PH, 813, 1066, 59136},{FDI_EVX_FNMADD231PH, 813, 1066, 59136},{FDI_EVX_FNMADD132SH, 557, 13313, 49920},{FDI_EVX_FNMADD213SH, 557, 13313, 49920},{FDI_EVX_FNMADD231SH, 557, 13313, 49920},{FDI_EVX_FNMSUB132PH, 813, 1066, 59136},{FDI_EVX_FNMSUB213PH, 813, 1066, 59136},{FDI_EVX_FNMSUB231PH, 813, 1066, 59136},{FDI_EVX_FNMSUB132SH, 557, 13313, 49920},{FDI_EVX_FNMSUB213SH, 557, 13313, 49920},{FDI_EVX_FNMSUB231SH, 557, 13313, 49920}
#elif defined(FD_DECODE_TABLE_STRTAB1)
"xtestuiretf2xm1xsusldtrkaddbextrclacall farplahfabsfencenclslarcrc32xsetbvaddpdepbndkblsidtcmmimfp16pshufwaitcmmrlfp16psmasha1msg1xsavesahfaddpconfigetsecbw cwdecdqencluincsspopaaaddaamcommitdcalldtilecfgxsaveoptwritenclvaddphltrdfsbaseamcalldsarxabortdpbf16psaveprevsspopfbldasbblsmskinitdpbssdxsaveclcldemotencodekey128xrstorssprefetchit0xresldtrkadddxlatblsrdgsbaseamopscaseamretdpbsud0xgetbvaddpsenduipinsertqxendbr32xbegint1wrusserializencodekey256wrssetaandwrpkrud1wrmsrnsetbendbr64wrmsrlistaclflushoptdpbusdwrgsbasetclgint3dnowbinvdbpsadbwbnoinvdivpdpbssdsetgenqcmdsetleaverrdmsrlistgintoutsetnclidtdpbuud2wrfsbasetnovzeroupperetsetnprefetchit1vzeroallfenceretumonitorxvxorpsetnsetnzvxorpdvunpcklpsetovunpcklpdvunpckhpsetpausetssbsyscallfsaverwvunpckhpdvucomissetzcntdpfp16psgdtileloaddt1vucomisha1msg2vucomisdvtestpsha1nextevtestpdvsubssha1rnds4vsubsha256msg1vsubsdvsubpsha256msg2vsubphresetilereleasevsubpdvstmxcsrdpidvsqrtssha256rnds2vsqrtshlxvsqrtsdvsqrtpshrxvsqrtphvsqrtpdvsm4rnds4vsm4key4vshufpsmswapgstosttilecfgvshufpdvshufi64x2vshufi32x4vshuff64x2vshuff32x4vscatterqpsysenterdpkrumwaitxvscatterqpdvscatterdpsysexitilestoredvscatterdpdvscalefssysretilezerorxvscalefshvscalefsdvscalefpsvscalefphvscalefpdvrsqrtssvrsqrtshvrsqrtpsvrsqrtphvrsqrt14ssvrsqrt14sdvrsqrt14psvrsqrt14pdvroundssvroundsdvroundpsvroundpdvrndscalessvrndscaleshvrndscalesdvrndscalepsvrndscalephvrndscalepdvreducessvreduceshvreducesdvreducepsvreducephvreducepdvrcpssvrcpshvrcppsvrcpphvrcp14ssvrcp14sdvrcp14psvrcp14pdvrangessvrangesdvrangepsvrangepdvpxorqvpxordpmclrssbsyvpunpcklwdvpunpcklqdqvpunpckldqvpunpcklbwvpunpckhwdvpunpckhqdqvpunpckhdqvpunpckhbwvptestnmwvptestnmqvptestnmdvptestnmboundvptestmwvptestmqvptestmdvptestmbsrdprurdmsrdrandvpternlogqvpternlogdvpsubwvpsubuswvpsubusbswaprefetchntaasvpsubswvpsubsbtcltsvpsubqvpsubdvpsubbtrdseedvpsrlwvpsrlvwvpsrlvqvpsrlvdivphadddvpsrlqvpsrldqvpsrawvpsravwvpsravqvpsravdivpsadbwvpsraqvpsradcxvpsllwvpsllvwvpsllvqvpsllvdivsdvpsllqvpslldqvpsignwvpsigndvpsignbtsvpshuflwvpshufhwvpshufdecstprefetcht0vpshufbitqmbzhinveptlbsynclwbvpshrdwvpshrdvwvpshrdvqvpshrdvdivshvpshrdqvpshrddvpshldwvpshldvwvpshldvqvpshldvdivssvpshldqvpshlddvpscatterqqvpscatterqdvpscatterdqvpscatterddvprorvqvprorvdpbf16psvprorqvprordssprefetcht1vprolvqvprolvdppdvprolqvproldvporqvpordtscpuidvpopcntwvpopcntqvpopcntdvpopcntbvpmuludqvpmultishiftqbvpmullwvpmullqvpmulldvpmulhwvpmulhuwrmsrep montmulxvpmulhrswvpmuldqvpmovzxwqvpmovzxwdvpmovzxdqvpmovzxbwvpmovzxbqvpmovzxbdvpmovwbvpmovw2mfencevpmovuswbvpmovusqwvpmovusqdvpmovusqbvpmovusdwvpmovusdbvpmovsxwqvpmovsxwdvpmovsxdqvpmovsxbwvpmovsxbqvpmovsxbdvpmovswbvpmovsqwvpmovsqdvpmovsqbvpmovsdwvpmovsdbvpmovqwvpmovqdvpmovqbvpmovq2movdir64bvpmovmskbvpmovm2wvpmovm2qvpmovm2dvpmovm2bvpmovdwvpmovdbvpmovd2movdirinvlpgadoxvpmovb2movdq2qvpminuwvpminuqvpminudvpminubvpminswvpminsqvpminsdvpminsbvpmaxuwvpmaxuqvpmaxudvpmaxubvpmaxswvpmaxsqvpmaxsdvpmaxsbvpmaskmovq2dqvpmaskmovdppsvpmaddwdvpmaddubswvpmadd52luqvpmadd52huqvplzcntqvplzcntdvpinsrwvpinsrqvpinsrdvpinsrbvphsubwvphsubswvphsubdvphminposuwvphaddwvphaddswvpgatherqqvpgatherqdvpgatherdqvpgatherddvpextrwvpextrqvpextrdvpextrbvpexpandwvpexpandqvpexpanddvpexpandbvpermwvpermt2wvpermt2qvpermt2psvpermt2pdvpermt2dvpermt2bvpermqvpermpsvpermpdvpermilpsvpermilpdvpermi2wvpermi2qvpermi2psvpermi2pdvpermi2dvpermi2bvpermdvpermbvperm2i128vperm2f128vpdpwssdsvpdpbuudsvpdpbusdsvpdpbsudsvpconflictqvpconflictdvpcompresswvpcompressqvpcompressdvpcompressbvpcmpwvpcmpuwvpcmpuqvpcmpudvpcmpubvpcmpqvpcmpistrmpadjustvpcmpistrinvlpgbvpcmpgtwvpcmpgtqvpcmpgtdvpcmpgtbvpcmpestrmpqueryvpcmpestrinvpcidvpcmpeqwvpcmpeqqvpcmpeqdvpcmpeqbvpcmpdvpcmpbexaddvpclmulqdqvpbroadcastwvpbroadcastqvpbroadcastmw2dvpbroadcastmb2qvpbroadcastdvpbroadcastbvpblendwvpblendvbcstnebf162psvpblendmwvpblendmqvpblendmdvpblendmbvpblenddvpavgwvpavgbvpandqvpandnqvpandndvpanddvpalignrep xcryptcbclzerovpaddwvpadduswvpaddusbvpaddswvpaddsbvpaddqvpadddvpaddbvpackuswbvpackusdwvpacksswbvpackssdwvpabswvpabsqvpabsdvpabsbvp2intersectqvp2intersectdvorpsvorpdvmxonegvmxoffreevmwritevmulssvmulshvmulsdvmulpsvmulphvmulpdvmsavexpandpdvmrunvmresumevmreadvmptrstvmptrldvmpsadbwvmovwvmovupsvmovupdvmovssvmovslduprefetcht2vmovshduprefetchwt1vmovsdvmovqvmovntpsvmovntpdvmovntdqaesdec128klgdtvmovmskpsvmovmskpdvmovlpsvmovlpdvmovlhpsvmovhpsvmovhpdvmovhlpsvmovdqu8vmovdqu64vmovdqu32vmovdqu16vmovdqa64vmovdqa32vmovddupushaesdec256klgsvmovapsvmovapdvmmcallkgsvmloadiwkeyvmlaunchvminssvminshvminsdvminpsvminphvminpdvmgexitvmfuncmcmovaddsdvmclearep xcryptcfbstpushfchsvmcallmswvmaxssvmaxshvmaxsdvmaxpsvmaxphvmaxpdvmaskmovpsvmaskmovpdvmaskmovdquvldmxcsrep xcryptctrep xcryptecbvlddquvinsertpsvinserti64x4vinserti64x2vinserti32x8vinserti32x4vinserti128vinsertf64x4vinsertf64x2vinsertf32x8vinsertf32x4vinsertf128vhsubpsvhsubpdvhaddpsvhaddpdvgf2p8mulbvgf2p8affineqbvgf2p8affineinvqbvgetmantssvgetmantshvgetmantsdvgetmantpsvgetmantphvgetmantpdvgetexpssvgetexpshvgetexpsdvgetexppsvgetexpphvgetexppdvgatherqpsvgatherqpdvgatherdpsvgatherdpdvfpclassssvfpclassshvfpclasssdvfpclasspsvfpclassphvfpclasspdvfnmsub231ssvfnmsub231shvfnmsub231sdvfnmsub231psvfnmsub231phvfnmsub231pdvfnmsub213ssvfnmsub213shvfnmsub213sdvfnmsub213psvfnmsub213phvfnmsub213pdvfnmsub132ssvfnmsub132shvfnmsub132sdvfnmsub132psvfnmsub132phvfnmsub132pdvfnmadd231ssvfnmadd231shvfnmadd231sdvfnmadd231psvfnmadd231phvfnmadd231pdvfnmadd213ssvfnmadd213shvfnmadd213sdvfnmadd213psvfnmadd213phvfnmadd213pdvfnmadd132ssvfnmadd132shvfnmadd132sdvfnmadd132psvfnmadd132phvfnmadd132pdvfmulcshvfmulcphvfmsubadd231psvfmsubadd231phvfmsubadd231pdvfmsubadd213psvfmsubadd213phvfmsubadd213pdvfmsubadd132psvfmsubadd132phvfmsubadd132pdvfmsub231ssvfmsub231shvfmsub231sdvfmsub231psvfmsub231phvfmsub231pdvfmsub213ssvfmsub213shvfmsub213sdvfmsub213psvfmsub213phvfmsub213pdvfmsub132ssvfmsub132shvfmsub132sdvfmsub132psvfmsub132phvfmsub132pdvfmaddsub231psvfmaddsub231phvfmaddsub231pdvfmaddsub213psvfmaddsub213phvfmaddsub213pdvfmaddsub132psvfmaddsub132phvfmaddsub132pdvfmaddcshvfmaddcphvfmadd231ssvfmadd231shvfmadd231sdvfmadd231psvfmadd231phvfmadd231pdvfmadd213ssvfmadd213shvfmadd213sdvfmadd213psvfmadd213phvfmadd213pdvfmadd132ssvfmadd132shvfmadd132sdvfmadd132psvfmadd132phvfmadd132pdvfixupimmssvfixupimmsdvfixupimmpsvfixupimmpdvfcmulcshvfcmulcphvfcmaddcshvfcmaddcphvextractpsvextracti64x4vextracti64x2vextracti32x8vextracti32x4vextracti128vextractf64x4vextractf64x2vextractf32x8vextractf32x4vextractf128vexpandpsvcvtw2phvcvtuw2phvcvtusi2ssvcvtusi2shvcvtusi2sdvcvtuqq2psvcvtuqq2phvcvtuqq2pdvcvtudq2psvcvtudq2phvcvtudq2pdvcvttss2usinvvpidvcvttss2sivcvttsh2usivcvttsh2sivcvttsd2usivcvttsd2sivcvttps2uqqvcvttps2udqvcvttps2qqvcvttps2dqvcvttph2wvcvttph2uwvcvttph2uqqvcvttph2udqvcvttph2qqvcvttph2dqvcvttpd2uqqvcvttpd2udqvcvttpd2qqvcvttpd2dqvcvtss2usivcvtss2sivcvtss2shvcvtss2sdvcvtsi2ssvcvtsi2shvcvtsi2sdvcvtsh2usivcvtsh2ssvcvtsh2sivcvtsh2sdvcvtsd2usivcvtsd2ssvcvtsd2sivcvtsd2shvcvtqq2psvcvtqq2phvcvtqq2pdvcvtps2uqqvcvtps2udqvcvtps2qqvcvtps2phxvcvtps2pdvcvtps2dqvcvtph2wvcvtph2uwvcvtph2uqqvcvtph2udqvcvtph2qqvcvtph2psxvcvtph2pdvcvtph2dqvcvtpd2uqqvcvtpd2udqvcvtpd2qqvcvtpd2psvcvtpd2phvcvtpd2dqvcvtneps2bf16vcvtneoph2psvcvtneobf162psvcvtneeph2psvcvtneebf162psvcvtne2ps2bf16vcvtdq2psvcvtdq2phvcvtdq2pdvcompresspsvcompresspdvcomissvcomishvcomisdvcmpssvcmpshvcmpsdvcmppsvcmpphvcmppdvbroadcastssvbroadcastsdvbroadcasti64x4vbroadcasti64x2vbroadcasti32x8vbroadcasti32x4vbroadcasti32x2vbroadcasti128vbroadcastf64x4vbroadcastf64x2vbroadcastf32x8vbroadcastf32x4vbroadcastf32x2vbroadcastf128vblendvpsvblendvpdvblendpsvblendpdvblendmpsvblendmpdvbcstnesh2psvandpsvandpdvandnpsvandnpdvalignqvaligndvaeskeygenassistvaesimcmovcmovgevaesenclastvaesdeclastvaddsubpsvaddsubpdvaddssvaddshrsmovntirmpupdatermpreadrep xstorep xcryptofbrep xsha256rep xsha1pvalidatemovntssmovntsdmovntqloopzloopnzlodskxorwkxorqkxordkxorbkxnorwkxnorqkxnordkxnorbkunpckwdkunpckdqkunpckbwktestwktestqktestdktestbkshiftrwkshiftrqkshiftrdkshiftrbkshiftlwkshiftlqkshiftldkshiftlbkorwkortestwkortestqkortestdkortestbkorqkordkorbknotwknotqknotdknotbkmovwkmovbkandwkandqkandnwkandnqkandndkandnbkanddkandbkaddwkaddqjzjsjpjojnzjnsjnpjnojncmovlejmp farjlejgejcxz jecxzjrcxzjbejaesdecwide128klfyl2xp1fxtractfxsavefxrstorfxchfxamfucomppfucomipftstfsubrpfsubpfstswfstpfstenvfstcwd cdq cqofsqrtfsincosfscalefrstorfrndintfptanfprem1fpatanfnopfmulpfldzfldpifldln2fldlg2fldl2tfldl2efldenvfldcwfld1fisubrfisttpfistpfinitfincstpfimulfildfidivrficompfiaddfemmsfdivrpfdivpfcosfcomppfcomipfcmovufcmovnufcmovnefcmovnbefcmovefcmovbefclexcvttps2picvttpd2picvtps2picvtpi2pscvtpi2pdcvtpd2picmpzxaddcmpxchgcmpsxaddcmppxaddcmpoxaddcmpnzxaddcmpnsxaddcmpnpxaddcmpnoxaddcmpnlxaddcmpnlexaddcmpnbxaddcmpnbexaddcmplxaddcmplexaddcmpbxaddcmovzcmovscmovpcmovocmovnzcmovnscmovnpcmovnocmovncaxoraoraesencwide256klaesencwide128klaesenc256klaesenc128klaesdecwide256kl"
#elif defined(FD_DECODE_TABLE_STRTAB2)
529,177,178,178,182,459,1777,1917,1917,24,2749,4189,4189,4329,7548,8045,8688,7537,8677,8666,7537,8651,8636,7521,7505,460,3786,8633,41,8629,27,85,279,357,1669,49,1705,1763,1793,1793,1816,1985,2036,35,35,32,300,302,302,498,498,523,601,1544,1795,166,2050,3823,4433,4435,8380,7526,7530,7530,8007,8007,8623,8617,8611,8605,8599,8594,8589,8584,8579,3421,3596,8571,8562,8554,8544,8535,8525,8516,8507,8498,8489,8480,8472,8464,7163,8456,8449,8449,8441,2282,63,153,8142,181,275,159,552,55,164,216,309,441,414,481,566,566,1086,632,663,73,220,394,4438,7582,7576,7547,7547,7536,7536,7497,7490,7483,7476,7470,7464,7443,7434,7371,7356,7341,7326,7311,7282,7267,7252,7237,7222,7210,7198,7192,7186,7180,7174,7168,7162,7155,7148,7141,7130,7119,7110,7101,7092,7078,7013,7004,6995,6986,6977,6967,6957,6948,6939,6929,6929,6920,6910,6900,6891,6883,6874,6865,6855,6855,6846,6836,6826,6817,6808,6799,6790,6781,6772,6762,6753,6744,6735,6725,6716,6707,6698,6689,6680,6671,6661,6651,6641,6630,6619,6609,6599,6588,6577,6567,6558,6548,6538,6527,6516,6506,6495,6485,6474,6464,6447,6437,6427,6417,6407,6397,6387,6377,6367,6357,6348,6340,537,551,1849,1897,1946,2083,2132,2208,4042,6331,6306,6293,6280,6267,6242,6229,6216,6203,6193,6183,6173,6164,6155,6144,6133,6122,6111,6100,6089,6078,6067,6056,6045,6034,6023,6012,6001,5990,5979,5968,5957,5946,5935,5924,5913,5904,5895,5881,5867,5853,5839,5825,5811,5797,5783,5769,5758,5747,5736,5725,5714,5703,5692,5681,5670,5659,5648,5637,5626,5615,5604,5593,5582,5571,5557,5543,5529,5515,5501,5487,5473,5459,5445,5437,5429,5417,5405,5393,5381,5369,5357,5345,5333,5321,5309,5297,5285,5273,5261,5249,5237,5225,5213,5201,5189,5177,5165,5153,5141,5129,5117,5105,5093,5081,5069,5057,5045,5033,5021,5009,4997,4987,4977,4967,4957,4947,4937,4927,4917,4907,4897,4888,4879,4870,4861,4852,4843,4833,4823,4813,4803,4793,4783,4766,4752,4742,4691,4679,4667,4655,4632,4620,4608,4596,4587,4512,4506,4500,4494,4488,4482,4415,4409,4403,4397,4391,4385,4349,4342,4318,4309,4300,4291,4282,4273,4265,4257,4250,4243,4235,4228,4221,4181,4181,4173,4165,4160,4154,4135,4135,4117,4111,4104,4097,4092,4092,4092,4092,4032,4026,4020,4014,4008,4002,3974,3969,3956,3943,3937,3931,3925,3919,3910,3901,3892,3883,3877,3871,3865,3858,3851,3843,3835,3829,3804,3798,3791,3784,3778,3772,3766,3749,3740,3731,3722,3615,3681,3669,3654,3639,3627,3615,3605,3594,3588,3580,3572,3564,3556,3516,3508,3500,3492,3453,3446,3439,3432,3425,3419,3408,3397,3386,3375,3364,3353,3335,3335,3317,3317,3291,3285,3277,3269,3260,3251,3243,3235,3226,3217,3210,3203,3197,3189,3181,3172,3163,3155,3147,3141,3132,3123,3114,3105,3077,3098,3077,3067,3057,3047,3037,2961,2953,2945,2934,2923,2913,2905,2872,2865,2858,2851,2844,2837,2830,2823,2816,2809,2802,2795,2788,2781,2774,2767,2753,2730,2723,2716,2708,2700,2692,2684,2659,2652,2645,2638,2630,2622,2614,2606,2598,2590,2581,2572,2563,2554,2545,2536,2527,2518,2509,2500,2491,2482,2469,2462,2453,2444,2435,2426,2417,2408,2401,2392,2369,2362,2355,2348,2341,2327,2319,2311,2303,2295,2287,2275,2270,2264,2258,2248,2241,2223,2217,2203,2196,1900,2185,2174,2163,2152,2145,2138,2126,2118,2110,2103,2096,2089,2077,2069,2061,2054,2025,2025,2004,1996,1988,1958,1958,1952,1941,1934,1927,1921,1913,1907,1892,1885,1878,1872,1865,1865,1859,1844,1837,1830,1824,1811,1805,1799,1787,1780,1756,1748,1742,1732,1722,1698,1690,1682,1674,1661,1652,1643,1634,1624,1614,1603,1593,1583,1573,1562,1552,1536,1530,1522,1514,1506,1498,1490,1482,1474,1466,1460,1448,1433,1424,1415,1406,1397,1388,1377,1366,1355,1344,1333,1322,1280,1270,1260,1250,1242,1226,1209,1200,1191,1182,1173,1150,1139,1113,1102,1073,1063,1053,1043,1033,1026,1001,977,970,960,953,944,927,909,888,873,867,853,839,809,795,760,751,717,708,696,690,676,10,47,138,138,272,4461,4469,8386,8379,8379,8373,8365,8365,8358,8351,8345,8333,8339,8339,8333,8333,8329,2009,8318,8324,8318,8318,8313,3990,8308,8302,8302,8296,8296,8292,8287,8280,8275,8264,8270,8264,8258,8258,8210,8254,8249,8243,8237,8231,8225,8219,8214,8210,5430,8205,8201,8195,8189,8189,8184,8177,8171,744,8165,8158,8158,8153,8124,8139,8133,8129,8124,8113,8119,8113,8113,8109,8095,8102,8102,8095,8095,104,8091,8087,8080,8074,8067,8060,8060,148,4767,4753,4743,225,893,8297,8288,169,169,169,406,425,425,526,591,535,2039,2743,2743,3485,3549,6457,6,8044,8041,8026,8026,8023,8023,8020,8020,8013,8013,8005,8002,7999,7996,7993,7991,7989,7987,7985,23,348,7980,7975,7970,7965,7959,7953,7947,7941,7936,7931,7926,2897,2884,7921,7916,7911,7906,7901,7897,7893,7889,7881,7873,7865,7857,7853,7845,7837,7829,7821,7813,7805,7797,7789,7783,7777,7771,7765,7757,7749,7741,7735,7729,7723,7717,7712,7707,7702,7697,44,60,4550,241,195,575,575,1131,658,743,4199,4339,602,4362,194,4478,4368,7693,7682,7687,7682,58,4005,226,2947,184,2476,8433,8425,8417,8409,8400,8391,8314,2881,2666,2760,7676,2640,2885,3938,3932,3920,3911,3902,3884,3878,3872,3866,3859,3852,3844,3836,3830,3805,3109,3785,3773,3767,3581,3573,3557,3517,3509,3493,3078,1853,3030,3023,3005,2997,2990,2962,2914,2906,2852,2845,2796,2789,2676,2393,2370,2363,2342,2320,2271,540,2026,100,1980,1973,1966,1959,1953,1922,1914,1873,1866,1860,1825,1812,1806,1800,1788,1781,1757,1749,1743,1625,1615,1594,1584,1574,1553,1531,668,668,2410,2410,8381,2666,2737,7590,2538,2538,2410,2410,2410,2410,2410,2321,2388,1096,1096,3983,8202,7902,249,594,594,728,80,142,77,3078,174,174,2288,269,329,329,640,1767,2015,2231,4125,4143,4143,118,210,4325,4325,4465,7653,31,62,228,360,581,581,922,1090,1540,1707,1716,1818,2227,2278,2278,2380,3811,4450,4556,4568,7620,7644,7633,7612,8202,329,7,7,3467,3532,7605,7596,2243,1169,1169,7588,322,135,243,243,259,277,372,234,366,375,399,433,456,477,520,562,562,572,572,597,619,636,681,685,704,725,731,731,767,50,781,122,801,823,844,857,878,933,949,2105,949,966,2056,966,87,283,18,1007,74,395,4439,7577,7568,7559,7484,7477,4046,6335,7427,7419,7410,7401,7193,7181,7175,7163,811,762,7111,7093,7005,6987,6875,6866,6782,6773,6717,6699,6690,6672,6652,6549,6507,6465,552,1898,1947,2133,2254,2901,6194,3086,4736,4729,4722,4715,4588,406,4582,4539,4513,4501,2867,4483,4416,4404,2811,4386,4350,4343,2666,4319,4301,4266,4258,4251,4244,4236,4229,4222,4213,4204,4182,4182,4174,4166,7669,7662,2640,2624,4136,4118,4112,4105,4098,4085,4033,4021,4015,4003,692,678,3938,3932,3920,3911,3902,3893,3884,3878,3872,3866,3859,3852,3844,3836,3830,3805,3109,3785,3773,3767,3702,3694,3606,3581,3573,3565,3557,3541,3525,3517,3509,3501,3493,3477,3460,3099,3092,3085,3078,1853,3030,3023,3012,3005,2997,2990,2983,2976,2969,2962,2914,2906,2873,2866,2852,2845,2838,2824,2817,2810,2796,2789,2782,2768,2676,2582,2573,2564,2555,2546,2537,2454,2445,2436,2427,2418,2409,2402,2393,2370,2363,2356,2342,2320,2271,540,2026,2005,1997,1989,1980,1973,1966,1959,1959,1953,1922,1914,1873,1866,1866,1860,1825,1812,1806,1800,1788,1781,1757,1749,1743,1635,1625,1615,1604,1594,1584,1574,1563,1553,1531,1455,1443,1315,1307,1299,1291,1235,1219,1027,1002,978,961,954,928,910,874,868,840,810,761,752,718,709,697,691,677,495,8140,3678,588,7230,916,1014,3465,1017,3,840,1009,737,1083,1123,1158,90,108,190,251,288,381,507,605,773,1,1,784,784,898,1129,1163,2044,727,769,386,468,610,5,667,1095,1711,2375,73,394,4438,7576,7567,7558,7547,7547,7536,7536,7520,7504,7483,7476,7470,7464,3708,7452,7426,7418,7409,7400,7386,7297,7210,7198,7192,7180,7174,7162,7155,7141,7110,7092,7064,7052,7038,7026,7013,7004,6986,6929,6874,6865,6855,6781,6772,6716,6698,6689,6671,6651,6548,6506,6464,551,1897,1946,2132,2253,2900,578,747,6319,6255,6193,6100,6078,6067,6045,6034,6012,6001,5979,5968,5946,5935,5913,5881,5853,5839,5811,5797,5769,5758,5736,5725,5703,5692,5670,5659,5637,5626,5604,5593,5571,5557,5529,5515,5487,5473,5445,5417,5393,5381,5357,5345,5321,5309,5285,5273,5249,5237,5213,5201,5177,5165,5141,5129,5105,5093,5069,5057,5033,5021,4997,4927,4917,4907,4897,4766,4752,4742,4735,4728,4721,4714,4703,4644,4587,4581,4549,4538,4528,4518,4512,4500,4494,4482,4473,4444,4428,4421,4415,4403,4397,4385,4377,4366,4356,4349,4342,4265,4318,4300,4265,4257,4250,4243,4235,4228,4221,4212,4203,4181,4181,4173,4165,4160,4154,4135,4117,4111,4104,4097,4084,4077,4070,4064,4056,4051,4038,4032,4020,4014,4002,3995,3986,3979,3974,3969,3937,3931,3919,3910,3901,3892,3883,3877,3871,3865,3858,3851,3843,3835,3829,3804,3778,3784,3772,3766,3758,3701,3693,3681,3669,3627,3615,3605,3580,3572,3564,3556,3540,3524,3516,3508,3500,3492,3476,3459,554,554,3344,3344,3335,3335,3326,3326,3317,3317,3307,3297,3285,3226,3217,3210,3203,3197,3098,3091,3084,3077,3067,3057,3047,3037,1852,3029,3022,3011,3004,2996,2989,2982,2975,2968,2961,2934,2923,2913,2905,2892,2879,2872,2865,2851,2844,2837,2823,2816,2809,2795,2788,2781,2767,2675,2581,2572,2563,2554,2545,2536,2453,2444,2435,2426,2417,2408,2401,2392,2369,2362,2355,2341,2319,2270,1900,2025,2004,1996,1988,1979,1972,1965,1958,1958,1952,1941,1934,1921,1913,1892,1872,1865,1865,1859,1844,1837,1824,1811,1805,1799,1787,1780,1756,1748,1742,1634,1624,1614,1603,1593,1583,1573,1562,1552,1530,1454,1442,1314,1306,1298,1290,1234,1218,1026,1001,993,984,977,960,953,927,915,909,873,867,839,832,817,809,760,751,717,708,696,690,676,651,624,533,545,613,514,471,488,471,463,453,429,246,3601,421,8452,0,413,389,353,677,340,321,321,130,295,204,130,68,7616,15,0
#elif defined(FD_DECODE_TABLE_STRTAB3)
5,3,3,4,3,4,3,3,4,3,4,6,11,11,10,15,15,6,11,11,10,15,15,6,15,3,4,3,4,4,5,4,6,4,5,3,3,5,2,3,3,3,4,4,8,4,3,3,8,7,10,4,3,8,4,4,4,6,3,5,6,5,5,6,5,6,6,6,6,6,6,5,5,5,5,3,9,8,9,8,10,9,10,9,9,9,9,9,8,8,4,8,7,7,8,5,5,12,11,3,3,3,3,5,5,5,12,12,7,7,6,7,5,5,5,6,6,6,6,6,6,7,11,7,11,7,7,7,7,6,6,9,9,15,15,15,15,15,15,15,15,15,15,12,12,6,6,6,6,6,6,7,7,7,11,11,9,9,9,14,13,9,9,9,9,10,10,9,9,9,10,9,10,10,9,8,9,9,9,10,9,10,10,9,9,9,9,9,9,10,9,9,9,10,9,9,9,9,9,9,10,10,10,11,11,10,10,11,11,10,9,10,10,11,11,10,11,10,11,10,11,10,10,10,10,10,10,10,10,10,9,8,9,6,6,6,6,6,6,9,9,9,13,13,13,13,13,13,13,13,10,10,10,9,9,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,9,9,14,14,14,14,14,14,14,14,14,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,14,14,14,8,8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,10,10,10,10,10,10,17,14,10,12,12,12,12,12,12,12,12,9,6,6,6,6,6,6,6,6,6,6,6,6,7,7,8,9,9,9,9,9,8,8,7,7,8,7,7,8,9,8,8,5,6,6,9,9,6,7,7,5,5,4,4,6,6,6,6,6,6,5,5,13,13,6,6,6,6,9,9,9,9,6,6,6,7,7,8,8,6,8,6,7,7,6,6,6,9,9,9,9,11,12,12,15,15,12,12,10,6,6,8,8,8,8,8,8,8,8,6,7,7,7,7,6,11,11,11,11,11,11,8,9,8,9,6,6,8,8,9,9,8,8,9,9,7,7,6,8,8,9,9,8,8,6,9,9,9,9,6,7,7,10,10,10,10,6,8,8,11,11,10,8,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,7,7,8,8,8,8,8,7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,8,7,9,9,9,9,9,9,7,9,8,7,7,7,7,14,8,8,8,8,8,5,5,6,6,7,7,6,6,7,7,7,11,11,11,11,7,7,8,8,8,7,7,7,8,8,8,7,7,12,7,8,8,6,7,6,7,7,7,6,6,6,7,7,7,6,6,7,6,7,7,7,6,6,6,6,7,7,8,8,6,10,10,8,8,8,8,9,9,9,9,10,10,11,10,10,10,11,10,6,6,8,8,8,8,8,8,8,8,6,6,9,9,9,9,9,9,11,11,11,11,11,11,10,10,10,10,8,8,9,9,9,9,9,9,11,11,11,11,10,10,10,10,7,7,7,7,7,7,7,7,6,6,6,6,6,6,8,8,8,9,9,9,9,6,6,5,4,4,5,4,5,4,5,6,7,6,7,8,7,7,6,4,5,6,5,6,4,7,4,5,5,6,5,5,5,5,6,5,6,4,5,7,5,4,5,6,5,6,3,4,5,6,6,6,6,6,5,4,4,5,4,6,5,6,5,7,6,5,6,4,7,5,3,5,6,4,5,4,5,5,6,4,5,6,7,6,7,5,4,4,7,6,7,5,7,6,16,13,9,3,6,4,4,2,3,6,3,3,4,4,4,4,6,6,7,7,7,7,4,2,3,2,15,2,3,2,3,3,7,3,3,3,3,3,2,2,2,2,5,5,5,5,5,5,6,6,6,6,5,5,5,5,5,5,5,5,5,5,4,4,4,8,8,8,8,4,8,8,8,8,8,8,8,8,6,6,6,6,8,8,8,6,6,6,6,5,5,5,5,4,3,7,3,9,3,5,3,6,3,4,3,4,4,4,4,9,4,4,6,5,3,3,3,5,7,6,8,8,8,8,9,9,4,8,4,7,6,4,7,5,5,5,8,8,8,5,5,5,6,6,7,7,5,7,4,5,5,5,7,7,7,7,7,7,6,6,7,6,6,7,6,6,9,7,6,6,6,6,8,8,7,6,6,7,3,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,6,6,7,7,5,9,9,9,9,9,9,4,7,8,3,3,5,9,7,6,4,5,5,3,3,3,3,3,4,5,6,3,3,3,2,3,4,5,6,7,4,4,3,4,6,4,8,11,11,11,10,10,10,9,11,6,7,4,5,5,9,3,3,8,8,5,9,5,6,5,5,6,6,5,5,6,11,13,13,13,13,13,9,11,10,3,8,3,4,9,8,7,9,3,3,4,3,8,4,3,4,11,3,4,8,7,7,8,9,4,5,4,4,5,4,5,5,5,5,5,5,4,4,4,8,4,6,4,8,8,9,9,10,10,11,3,4,4,3,4,4,4,6,4,4,5,5,5,5,8,8,6,6,5,5,7,7,8,8,5,5,5,5,6,6,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,5,5,5,5,4,4,9,5,6,6,6,6,8,7,5,10,5,5,5,5,5,5,5,5,6,6,4,7,6,6,7,6,6,7,6,6,8,8,7,8,7,7,7,7,4,5,8,8,5,6,6,7,5,5,5,5,4,4,5,5,5,8,8,8,8,5,5,5,6,6,7,7,5,7,4,5,5,5,8,7,9,7,7,7,7,9,9,7,7,7,7,9,9,6,6,6,6,6,7,6,10,6,7,6,6,6,6,6,9,7,6,6,6,6,6,6,6,6,6,6,6,6,8,8,8,8,8,8,8,8,8,8,8,8,8,6,8,7,6,6,6,7,3,6,6,6,7,7,6,6,6,5,6,5,5,5,5,5,6,5,5,5,5,5,6,6,7,7,5,5,9,9,10,9,9,9,10,9,4,5,5,7,7,7,7,7,7,6,6,6,6,6,6,5,5,5,5,7,7,8,8,8,8,5,5,4,3,3,4,3,7,4,3,9,4,3,6,7,8,7,6,12,12,6,9,7,7,7,7,9,4,6,9,11,11,10,8,7,6,5,3,3,3,5,8,6,6,6,6,6,6,6,9,9,7,11,7,11,7,16,7,7,6,6,14,12,8,8,9,9,14,14,12,12,6,6,6,6,7,7,9,9,14,12,14,12,13,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,6,6,6,6,5,5,4,4,12,12,10,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,11,11,11,11,11,11,11,11,11,11,11,11,14,14,14,14,14,14,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,10,10,10,10,17,14,10,7,7,7,7,11,11,9,6,8,11,10,10,6,6,6,6,6,7,6,7,6,6,6,6,8,6,7,7,7,5,8,7,7,8,7,7,8,7,7,9,9,8,9,8,8,5,6,9,9,6,7,7,8,7,7,6,8,5,6,6,6,6,6,7,6,5,5,5,6,6,6,9,9,9,9,6,6,6,7,7,8,8,6,8,5,6,6,6,8,9,8,12,12,12,12,10,8,8,8,8,10,10,8,8,8,8,10,10,8,9,8,9,8,9,8,9,8,9,10,10,6,9,9,7,7,6,7,7,7,7,10,10,10,10,7,8,7,11,7,8,7,7,7,7,7,11,11,10,8,10,10,7,7,7,7,7,7,7,7,7,7,7,7,9,9,9,9,9,9,9,9,9,9,9,9,9,7,9,8,7,7,7,8,4,7,7,7,8,8,7,7,7,6,7,6,7,7,6,6,7,6,6,7,6,7,7,6,6,6,6,7,7,8,8,6,6,10,10,11,10,10,10,11,10,5,6,6,8,8,8,8,8,8,7,7,8,9,7,7,7,7,8,6,6,6,6,7,7,8,8,9,9,9,9,6,6,8,10,6,8,8,8,5,9,7,6,4,5,6,4,6,4,0,4,6,5,3,9,6,7,5,6,8,6,6,6,9,5
#elif defined(FD_DECODE_TABLE_DEFINES)
#define FD_TABLE_OFFSET_32 0
#define FD_TABLE_OFFSET_64 256

#else
#error "unspecified decode table"
#endif

```

`third_party/fadec/fadec-decode-public.inc`:

```inc
FD_MNEMONIC(3DNOW,0)
FD_MNEMONIC(AAA,1)
FD_MNEMONIC(AAD,2)
FD_MNEMONIC(AADD,3)
FD_MNEMONIC(AAM,4)
FD_MNEMONIC(AAND,5)
FD_MNEMONIC(AAS,6)
FD_MNEMONIC(ADC,7)
FD_MNEMONIC(ADCX,8)
FD_MNEMONIC(ADD,9)
FD_MNEMONIC(ADOX,10)
FD_MNEMONIC(AESDEC,11)
FD_MNEMONIC(AESDEC128KL,12)
FD_MNEMONIC(AESDEC256KL,13)
FD_MNEMONIC(AESDECLAST,14)
FD_MNEMONIC(AESDECWIDE128KL,15)
FD_MNEMONIC(AESDECWIDE256KL,16)
FD_MNEMONIC(AESENC,17)
FD_MNEMONIC(AESENC128KL,18)
FD_MNEMONIC(AESENC256KL,19)
FD_MNEMONIC(AESENCLAST,20)
FD_MNEMONIC(AESENCWIDE128KL,21)
FD_MNEMONIC(AESENCWIDE256KL,22)
FD_MNEMONIC(AESIMC,23)
FD_MNEMONIC(AESKEYGENASSIST,24)
FD_MNEMONIC(AND,25)
FD_MNEMONIC(ANDN,26)
FD_MNEMONIC(AOR,27)
FD_MNEMONIC(ARPL,28)
FD_MNEMONIC(AXOR,29)
FD_MNEMONIC(BEXTR,30)
FD_MNEMONIC(BLSI,31)
FD_MNEMONIC(BLSMSK,32)
FD_MNEMONIC(BLSR,33)
FD_MNEMONIC(BOUND,34)
FD_MNEMONIC(BSF,35)
FD_MNEMONIC(BSR,36)
FD_MNEMONIC(BSWAP,37)
FD_MNEMONIC(BT,38)
FD_MNEMONIC(BTC,39)
FD_MNEMONIC(BTR,40)
FD_MNEMONIC(BTS,41)
FD_MNEMONIC(BZHI,42)
FD_MNEMONIC(CALL,43)
FD_MNEMONIC(CALLF,44)
FD_MNEMONIC(CLAC,45)
FD_MNEMONIC(CLC,46)
FD_MNEMONIC(CLD,47)
FD_MNEMONIC(CLDEMOTE,48)
FD_MNEMONIC(CLFLUSH,49)
FD_MNEMONIC(CLFLUSHOPT,50)
FD_MNEMONIC(CLGI,51)
FD_MNEMONIC(CLI,52)
FD_MNEMONIC(CLRSSBSY,53)
FD_MNEMONIC(CLTS,54)
FD_MNEMONIC(CLUI,55)
FD_MNEMONIC(CLWB,56)
FD_MNEMONIC(CLZERO,57)
FD_MNEMONIC(CMC,58)
FD_MNEMONIC(CMOVA,59)
FD_MNEMONIC(CMOVBE,60)
FD_MNEMONIC(CMOVC,61)
FD_MNEMONIC(CMOVG,62)
FD_MNEMONIC(CMOVGE,63)
FD_MNEMONIC(CMOVL,64)
FD_MNEMONIC(CMOVLE,65)
FD_MNEMONIC(CMOVNC,66)
FD_MNEMONIC(CMOVNO,67)
FD_MNEMONIC(CMOVNP,68)
FD_MNEMONIC(CMOVNS,69)
FD_MNEMONIC(CMOVNZ,70)
FD_MNEMONIC(CMOVO,71)
FD_MNEMONIC(CMOVP,72)
FD_MNEMONIC(CMOVS,73)
FD_MNEMONIC(CMOVZ,74)
FD_MNEMONIC(CMP,75)
FD_MNEMONIC(CMPBEXADD,76)
FD_MNEMONIC(CMPBXADD,77)
FD_MNEMONIC(CMPLEXADD,78)
FD_MNEMONIC(CMPLXADD,79)
FD_MNEMONIC(CMPNBEXADD,80)
FD_MNEMONIC(CMPNBXADD,81)
FD_MNEMONIC(CMPNLEXADD,82)
FD_MNEMONIC(CMPNLXADD,83)
FD_MNEMONIC(CMPNOXADD,84)
FD_MNEMONIC(CMPNPXADD,85)
FD_MNEMONIC(CMPNSXADD,86)
FD_MNEMONIC(CMPNZXADD,87)
FD_MNEMONIC(CMPOXADD,88)
FD_MNEMONIC(CMPPXADD,89)
FD_MNEMONIC(CMPS,90)
FD_MNEMONIC(CMPSXADD,91)
FD_MNEMONIC(CMPXCHG,92)
FD_MNEMONIC(CMPXCHGD,93)
FD_MNEMONIC(CMPZXADD,94)
FD_MNEMONIC(CPUID,95)
FD_MNEMONIC(CRC32,96)
FD_MNEMONIC(C_EX,97)
FD_MNEMONIC(C_SEP,98)
FD_MNEMONIC(DAA,99)
FD_MNEMONIC(DAS,100)
FD_MNEMONIC(DEC,101)
FD_MNEMONIC(DIV,102)
FD_MNEMONIC(ENCLS,103)
FD_MNEMONIC(ENCLU,104)
FD_MNEMONIC(ENCLV,105)
FD_MNEMONIC(ENCODEKEY128,106)
FD_MNEMONIC(ENCODEKEY256,107)
FD_MNEMONIC(ENDBR32,108)
FD_MNEMONIC(ENDBR64,109)
FD_MNEMONIC(ENQCMD,110)
FD_MNEMONIC(ENQCMDS,111)
FD_MNEMONIC(ENTER,112)
FD_MNEMONIC(ERETS,113)
FD_MNEMONIC(ERETU,114)
FD_MNEMONIC(EVX_ADDPD,115)
FD_MNEMONIC(EVX_ADDPH,116)
FD_MNEMONIC(EVX_ADDPS,117)
FD_MNEMONIC(EVX_ADDSD,118)
FD_MNEMONIC(EVX_ADDSH,119)
FD_MNEMONIC(EVX_ADDSS,120)
FD_MNEMONIC(EVX_AESDEC,121)
FD_MNEMONIC(EVX_AESDECLAST,122)
FD_MNEMONIC(EVX_AESENC,123)
FD_MNEMONIC(EVX_AESENCLAST,124)
FD_MNEMONIC(EVX_ALIGND,125)
FD_MNEMONIC(EVX_ALIGNQ,126)
FD_MNEMONIC(EVX_ANDNPD,127)
FD_MNEMONIC(EVX_ANDNPS,128)
FD_MNEMONIC(EVX_ANDPD,129)
FD_MNEMONIC(EVX_ANDPS,130)
FD_MNEMONIC(EVX_BLENDMPD,131)
FD_MNEMONIC(EVX_BLENDMPS,132)
FD_MNEMONIC(EVX_BROADCASTF32X2,133)
FD_MNEMONIC(EVX_BROADCASTF32X4,134)
FD_MNEMONIC(EVX_BROADCASTF32X8,135)
FD_MNEMONIC(EVX_BROADCASTF64X2,136)
FD_MNEMONIC(EVX_BROADCASTF64X4,137)
FD_MNEMONIC(EVX_BROADCASTI32X2,138)
FD_MNEMONIC(EVX_BROADCASTI32X4,139)
FD_MNEMONIC(EVX_BROADCASTI32X8,140)
FD_MNEMONIC(EVX_BROADCASTI64X2,141)
FD_MNEMONIC(EVX_BROADCASTI64X4,142)
FD_MNEMONIC(EVX_BROADCASTSD,143)
FD_MNEMONIC(EVX_BROADCASTSS,144)
FD_MNEMONIC(EVX_CMPPD,145)
FD_MNEMONIC(EVX_CMPPH,146)
FD_MNEMONIC(EVX_CMPPS,147)
FD_MNEMONIC(EVX_CMPSD,148)
FD_MNEMONIC(EVX_CMPSH,149)
FD_MNEMONIC(EVX_CMPSS,150)
FD_MNEMONIC(EVX_COMISD,151)
FD_MNEMONIC(EVX_COMISH,152)
FD_MNEMONIC(EVX_COMISS,153)
FD_MNEMONIC(EVX_COMPRESSPD,154)
FD_MNEMONIC(EVX_COMPRESSPS,155)
FD_MNEMONIC(EVX_CVTDQ2PD,156)
FD_MNEMONIC(EVX_CVTDQ2PH,157)
FD_MNEMONIC(EVX_CVTDQ2PS,158)
FD_MNEMONIC(EVX_CVTNE2PS2BF16,159)
FD_MNEMONIC(EVX_CVTNEPS2BF16,160)
FD_MNEMONIC(EVX_CVTPD2DQ,161)
FD_MNEMONIC(EVX_CVTPD2PH,162)
FD_MNEMONIC(EVX_CVTPD2PS,163)
FD_MNEMONIC(EVX_CVTPD2QQ,164)
FD_MNEMONIC(EVX_CVTPD2UDQ,165)
FD_MNEMONIC(EVX_CVTPD2UQQ,166)
FD_MNEMONIC(EVX_CVTPH2DQ,167)
FD_MNEMONIC(EVX_CVTPH2PD,168)
FD_MNEMONIC(EVX_CVTPH2PS,169)
FD_MNEMONIC(EVX_CVTPH2PSX,170)
FD_MNEMONIC(EVX_CVTPH2QQ,171)
FD_MNEMONIC(EVX_CVTPH2UDQ,172)
FD_MNEMONIC(EVX_CVTPH2UQQ,173)
FD_MNEMONIC(EVX_CVTPH2UW,174)
FD_MNEMONIC(EVX_CVTPH2W,175)
FD_MNEMONIC(EVX_CVTPS2DQ,176)
FD_MNEMONIC(EVX_CVTPS2PD,177)
FD_MNEMONIC(EVX_CVTPS2PH,178)
FD_MNEMONIC(EVX_CVTPS2PHX,179)
FD_MNEMONIC(EVX_CVTPS2QQ,180)
FD_MNEMONIC(EVX_CVTPS2UDQ,181)
FD_MNEMONIC(EVX_CVTPS2UQQ,182)
FD_MNEMONIC(EVX_CVTQQ2PD,183)
FD_MNEMONIC(EVX_CVTQQ2PH,184)
FD_MNEMONIC(EVX_CVTQQ2PS,185)
FD_MNEMONIC(EVX_CVTSD2SH,186)
FD_MNEMONIC(EVX_CVTSD2SI,187)
FD_MNEMONIC(EVX_CVTSD2SS,188)
FD_MNEMONIC(EVX_CVTSD2USI,189)
FD_MNEMONIC(EVX_CVTSH2SD,190)
FD_MNEMONIC(EVX_CVTSH2SI,191)
FD_MNEMONIC(EVX_CVTSH2SS,192)
FD_MNEMONIC(EVX_CVTSH2USI,193)
FD_MNEMONIC(EVX_CVTSI2SD,194)
FD_MNEMONIC(EVX_CVTSI2SH,195)
FD_MNEMONIC(EVX_CVTSI2SS,196)
FD_MNEMONIC(EVX_CVTSS2SD,197)
FD_MNEMONIC(EVX_CVTSS2SH,198)
FD_MNEMONIC(EVX_CVTSS2SI,199)
FD_MNEMONIC(EVX_CVTSS2USI,200)
FD_MNEMONIC(EVX_CVTTPD2DQ,201)
FD_MNEMONIC(EVX_CVTTPD2QQ,202)
FD_MNEMONIC(EVX_CVTTPD2UDQ,203)
FD_MNEMONIC(EVX_CVTTPD2UQQ,204)
FD_MNEMONIC(EVX_CVTTPH2DQ,205)
FD_MNEMONIC(EVX_CVTTPH2QQ,206)
FD_MNEMONIC(EVX_CVTTPH2UDQ,207)
FD_MNEMONIC(EVX_CVTTPH2UQQ,208)
FD_MNEMONIC(EVX_CVTTPH2UW,209)
FD_MNEMONIC(EVX_CVTTPH2W,210)
FD_MNEMONIC(EVX_CVTTPS2DQ,211)
FD_MNEMONIC(EVX_CVTTPS2QQ,212)
FD_MNEMONIC(EVX_CVTTPS2UDQ,213)
FD_MNEMONIC(EVX_CVTTPS2UQQ,214)
FD_MNEMONIC(EVX_CVTTSD2SI,215)
FD_MNEMONIC(EVX_CVTTSD2USI,216)
FD_MNEMONIC(EVX_CVTTSH2SI,217)
FD_MNEMONIC(EVX_CVTTSH2USI,218)
FD_MNEMONIC(EVX_CVTTSS2SI,219)
FD_MNEMONIC(EVX_CVTTSS2USI,220)
FD_MNEMONIC(EVX_CVTUDQ2PD,221)
FD_MNEMONIC(EVX_CVTUDQ2PH,222)
FD_MNEMONIC(EVX_CVTUDQ2PS,223)
FD_MNEMONIC(EVX_CVTUQQ2PD,224)
FD_MNEMONIC(EVX_CVTUQQ2PH,225)
FD_MNEMONIC(EVX_CVTUQQ2PS,226)
FD_MNEMONIC(EVX_CVTUSI2SD,227)
FD_MNEMONIC(EVX_CVTUSI2SH,228)
FD_MNEMONIC(EVX_CVTUSI2SS,229)
FD_MNEMONIC(EVX_CVTUW2PH,230)
FD_MNEMONIC(EVX_CVTW2PH,231)
FD_MNEMONIC(EVX_DBPSADBW,232)
FD_MNEMONIC(EVX_DIVPD,233)
FD_MNEMONIC(EVX_DIVPH,234)
FD_MNEMONIC(EVX_DIVPS,235)
FD_MNEMONIC(EVX_DIVSD,236)
FD_MNEMONIC(EVX_DIVSH,237)
FD_MNEMONIC(EVX_DIVSS,238)
FD_MNEMONIC(EVX_DPBF16PS,239)
FD_MNEMONIC(EVX_EXPANDPD,240)
FD_MNEMONIC(EVX_EXPANDPS,241)
FD_MNEMONIC(EVX_EXTRACTF32X4,242)
FD_MNEMONIC(EVX_EXTRACTF32X8,243)
FD_MNEMONIC(EVX_EXTRACTF64X2,244)
FD_MNEMONIC(EVX_EXTRACTF64X4,245)
FD_MNEMONIC(EVX_EXTRACTI32X4,246)
FD_MNEMONIC(EVX_EXTRACTI32X8,247)
FD_MNEMONIC(EVX_EXTRACTI64X2,248)
FD_MNEMONIC(EVX_EXTRACTI64X4,249)
FD_MNEMONIC(EVX_EXTRACTPS,250)
FD_MNEMONIC(EVX_FCMADDCPH,251)
FD_MNEMONIC(EVX_FCMADDCSH,252)
FD_MNEMONIC(EVX_FCMULCPH,253)
FD_MNEMONIC(EVX_FCMULCSH,254)
FD_MNEMONIC(EVX_FIXUPIMMPD,255)
FD_MNEMONIC(EVX_FIXUPIMMPS,256)
FD_MNEMONIC(EVX_FIXUPIMMSD,257)
FD_MNEMONIC(EVX_FIXUPIMMSS,258)
FD_MNEMONIC(EVX_FMADD132PD,259)
FD_MNEMONIC(EVX_FMADD132PH,260)
FD_MNEMONIC(EVX_FMADD132PS,261)
FD_MNEMONIC(EVX_FMADD132SD,262)
FD_MNEMONIC(EVX_FMADD132SH,263)
FD_MNEMONIC(EVX_FMADD132SS,264)
FD_MNEMONIC(EVX_FMADD213PD,265)
FD_MNEMONIC(EVX_FMADD213PH,266)
FD_MNEMONIC(EVX_FMADD213PS,267)
FD_MNEMONIC(EVX_FMADD213SD,268)
FD_MNEMONIC(EVX_FMADD213SH,269)
FD_MNEMONIC(EVX_FMADD213SS,270)
FD_MNEMONIC(EVX_FMADD231PD,271)
FD_MNEMONIC(EVX_FMADD231PH,272)
FD_MNEMONIC(EVX_FMADD231PS,273)
FD_MNEMONIC(EVX_FMADD231SD,274)
FD_MNEMONIC(EVX_FMADD231SH,275)
FD_MNEMONIC(EVX_FMADD231SS,276)
FD_MNEMONIC(EVX_FMADDCPH,277)
FD_MNEMONIC(EVX_FMADDCSH,278)
FD_MNEMONIC(EVX_FMADDSUB132PD,279)
FD_MNEMONIC(EVX_FMADDSUB132PH,280)
FD_MNEMONIC(EVX_FMADDSUB132PS,281)
FD_MNEMONIC(EVX_FMADDSUB213PD,282)
FD_MNEMONIC(EVX_FMADDSUB213PH,283)
FD_MNEMONIC(EVX_FMADDSUB213PS,284)
FD_MNEMONIC(EVX_FMADDSUB231PD,285)
FD_MNEMONIC(EVX_FMADDSUB231PH,286)
FD_MNEMONIC(EVX_FMADDSUB231PS,287)
FD_MNEMONIC(EVX_FMSUB132PD,288)
FD_MNEMONIC(EVX_FMSUB132PH,289)
FD_MNEMONIC(EVX_FMSUB132PS,290)
FD_MNEMONIC(EVX_FMSUB132SD,291)
FD_MNEMONIC(EVX_FMSUB132SH,292)
FD_MNEMONIC(EVX_FMSUB132SS,293)
FD_MNEMONIC(EVX_FMSUB213PD,294)
FD_MNEMONIC(EVX_FMSUB213PH,295)
FD_MNEMONIC(EVX_FMSUB213PS,296)
FD_MNEMONIC(EVX_FMSUB213SD,297)
FD_MNEMONIC(EVX_FMSUB213SH,298)
FD_MNEMONIC(EVX_FMSUB213SS,299)
FD_MNEMONIC(EVX_FMSUB231PD,300)
FD_MNEMONIC(EVX_FMSUB231PH,301)
FD_MNEMONIC(EVX_FMSUB231PS,302)
FD_MNEMONIC(EVX_FMSUB231SD,303)
FD_MNEMONIC(EVX_FMSUB231SH,304)
FD_MNEMONIC(EVX_FMSUB231SS,305)
FD_MNEMONIC(EVX_FMSUBADD132PD,306)
FD_MNEMONIC(EVX_FMSUBADD132PH,307)
FD_MNEMONIC(EVX_FMSUBADD132PS,308)
FD_MNEMONIC(EVX_FMSUBADD213PD,309)
FD_MNEMONIC(EVX_FMSUBADD213PH,310)
FD_MNEMONIC(EVX_FMSUBADD213PS,311)
FD_MNEMONIC(EVX_FMSUBADD231PD,312)
FD_MNEMONIC(EVX_FMSUBADD231PH,313)
FD_MNEMONIC(EVX_FMSUBADD231PS,314)
FD_MNEMONIC(EVX_FMULCPH,315)
FD_MNEMONIC(EVX_FMULCSH,316)
FD_MNEMONIC(EVX_FNMADD132PD,317)
FD_MNEMONIC(EVX_FNMADD132PH,318)
FD_MNEMONIC(EVX_FNMADD132PS,319)
FD_MNEMONIC(EVX_FNMADD132SD,320)
FD_MNEMONIC(EVX_FNMADD132SH,321)
FD_MNEMONIC(EVX_FNMADD132SS,322)
FD_MNEMONIC(EVX_FNMADD213PD,323)
FD_MNEMONIC(EVX_FNMADD213PH,324)
FD_MNEMONIC(EVX_FNMADD213PS,325)
FD_MNEMONIC(EVX_FNMADD213SD,326)
FD_MNEMONIC(EVX_FNMADD213SH,327)
FD_MNEMONIC(EVX_FNMADD213SS,328)
FD_MNEMONIC(EVX_FNMADD231PD,329)
FD_MNEMONIC(EVX_FNMADD231PH,330)
FD_MNEMONIC(EVX_FNMADD231PS,331)
FD_MNEMONIC(EVX_FNMADD231SD,332)
FD_MNEMONIC(EVX_FNMADD231SH,333)
FD_MNEMONIC(EVX_FNMADD231SS,334)
FD_MNEMONIC(EVX_FNMSUB132PD,335)
FD_MNEMONIC(EVX_FNMSUB132PH,336)
FD_MNEMONIC(EVX_FNMSUB132PS,337)
FD_MNEMONIC(EVX_FNMSUB132SD,338)
FD_MNEMONIC(EVX_FNMSUB132SH,339)
FD_MNEMONIC(EVX_FNMSUB132SS,340)
FD_MNEMONIC(EVX_FNMSUB213PD,341)
FD_MNEMONIC(EVX_FNMSUB213PH,342)
FD_MNEMONIC(EVX_FNMSUB213PS,343)
FD_MNEMONIC(EVX_FNMSUB213SD,344)
FD_MNEMONIC(EVX_FNMSUB213SH,345)
FD_MNEMONIC(EVX_FNMSUB213SS,346)
FD_MNEMONIC(EVX_FNMSUB231PD,347)
FD_MNEMONIC(EVX_FNMSUB231PH,348)
FD_MNEMONIC(EVX_FNMSUB231PS,349)
FD_MNEMONIC(EVX_FNMSUB231SD,350)
FD_MNEMONIC(EVX_FNMSUB231SH,351)
FD_MNEMONIC(EVX_FNMSUB231SS,352)
FD_MNEMONIC(EVX_FPCLASSPD,353)
FD_MNEMONIC(EVX_FPCLASSPH,354)
FD_MNEMONIC(EVX_FPCLASSPS,355)
FD_MNEMONIC(EVX_FPCLASSSD,356)
FD_MNEMONIC(EVX_FPCLASSSH,357)
FD_MNEMONIC(EVX_FPCLASSSS,358)
FD_MNEMONIC(EVX_GATHERDPD,359)
FD_MNEMONIC(EVX_GATHERDPS,360)
FD_MNEMONIC(EVX_GATHERQPD,361)
FD_MNEMONIC(EVX_GATHERQPS,362)
FD_MNEMONIC(EVX_GETEXPPD,363)
FD_MNEMONIC(EVX_GETEXPPH,364)
FD_MNEMONIC(EVX_GETEXPPS,365)
FD_MNEMONIC(EVX_GETEXPSD,366)
FD_MNEMONIC(EVX_GETEXPSH,367)
FD_MNEMONIC(EVX_GETEXPSS,368)
FD_MNEMONIC(EVX_GETMANTPD,369)
FD_MNEMONIC(EVX_GETMANTPH,370)
FD_MNEMONIC(EVX_GETMANTPS,371)
FD_MNEMONIC(EVX_GETMANTSD,372)
FD_MNEMONIC(EVX_GETMANTSH,373)
FD_MNEMONIC(EVX_GETMANTSS,374)
FD_MNEMONIC(EVX_GF2P8AFFINEINVQB,375)
FD_MNEMONIC(EVX_GF2P8AFFINEQB,376)
FD_MNEMONIC(EVX_GF2P8MULB,377)
FD_MNEMONIC(EVX_INSERTF32X4,378)
FD_MNEMONIC(EVX_INSERTF32X8,379)
FD_MNEMONIC(EVX_INSERTF64X2,380)
FD_MNEMONIC(EVX_INSERTF64X4,381)
FD_MNEMONIC(EVX_INSERTI32X4,382)
FD_MNEMONIC(EVX_INSERTI32X8,383)
FD_MNEMONIC(EVX_INSERTI64X2,384)
FD_MNEMONIC(EVX_INSERTI64X4,385)
FD_MNEMONIC(EVX_INSERTPS,386)
FD_MNEMONIC(EVX_MAXPD,387)
FD_MNEMONIC(EVX_MAXPH,388)
FD_MNEMONIC(EVX_MAXPS,389)
FD_MNEMONIC(EVX_MAXSD,390)
FD_MNEMONIC(EVX_MAXSH,391)
FD_MNEMONIC(EVX_MAXSS,392)
FD_MNEMONIC(EVX_MINPD,393)
FD_MNEMONIC(EVX_MINPH,394)
FD_MNEMONIC(EVX_MINPS,395)
FD_MNEMONIC(EVX_MINSD,396)
FD_MNEMONIC(EVX_MINSH,397)
FD_MNEMONIC(EVX_MINSS,398)
FD_MNEMONIC(EVX_MOVAPD,399)
FD_MNEMONIC(EVX_MOVAPS,400)
FD_MNEMONIC(EVX_MOVDDUP,401)
FD_MNEMONIC(EVX_MOVDQA32,402)
FD_MNEMONIC(EVX_MOVDQA64,403)
FD_MNEMONIC(EVX_MOVDQU16,404)
FD_MNEMONIC(EVX_MOVDQU32,405)
FD_MNEMONIC(EVX_MOVDQU64,406)
FD_MNEMONIC(EVX_MOVDQU8,407)
FD_MNEMONIC(EVX_MOVHLPS,408)
FD_MNEMONIC(EVX_MOVHPD,409)
FD_MNEMONIC(EVX_MOVHPS,410)
FD_MNEMONIC(EVX_MOVLHPS,411)
FD_MNEMONIC(EVX_MOVLPD,412)
FD_MNEMONIC(EVX_MOVLPS,413)
FD_MNEMONIC(EVX_MOVNTDQ,414)
FD_MNEMONIC(EVX_MOVNTDQA,415)
FD_MNEMONIC(EVX_MOVNTPD,416)
FD_MNEMONIC(EVX_MOVNTPS,417)
FD_MNEMONIC(EVX_MOVQ,418)
FD_MNEMONIC(EVX_MOVSD,419)
FD_MNEMONIC(EVX_MOVSH,420)
FD_MNEMONIC(EVX_MOVSHDUP,421)
FD_MNEMONIC(EVX_MOVSLDUP,422)
FD_MNEMONIC(EVX_MOVSS,423)
FD_MNEMONIC(EVX_MOVUPD,424)
FD_MNEMONIC(EVX_MOVUPS,425)
FD_MNEMONIC(EVX_MOVW_G2X,426)
FD_MNEMONIC(EVX_MOVW_X2G,427)
FD_MNEMONIC(EVX_MOV_G2X,428)
FD_MNEMONIC(EVX_MOV_X2G,429)
FD_MNEMONIC(EVX_MULPD,430)
FD_MNEMONIC(EVX_MULPH,431)
FD_MNEMONIC(EVX_MULPS,432)
FD_MNEMONIC(EVX_MULSD,433)
FD_MNEMONIC(EVX_MULSH,434)
FD_MNEMONIC(EVX_MULSS,435)
FD_MNEMONIC(EVX_ORPD,436)
FD_MNEMONIC(EVX_ORPS,437)
FD_MNEMONIC(EVX_P2INTERSECTD,438)
FD_MNEMONIC(EVX_P2INTERSECTQ,439)
FD_MNEMONIC(EVX_PABSB,440)
FD_MNEMONIC(EVX_PABSD,441)
FD_MNEMONIC(EVX_PABSQ,442)
FD_MNEMONIC(EVX_PABSW,443)
FD_MNEMONIC(EVX_PACKSSDW,444)
FD_MNEMONIC(EVX_PACKSSWB,445)
FD_MNEMONIC(EVX_PACKUSDW,446)
FD_MNEMONIC(EVX_PACKUSWB,447)
FD_MNEMONIC(EVX_PADDB,448)
FD_MNEMONIC(EVX_PADDD,449)
FD_MNEMONIC(EVX_PADDQ,450)
FD_MNEMONIC(EVX_PADDSB,451)
FD_MNEMONIC(EVX_PADDSW,452)
FD_MNEMONIC(EVX_PADDUSB,453)
FD_MNEMONIC(EVX_PADDUSW,454)
FD_MNEMONIC(EVX_PADDW,455)
FD_MNEMONIC(EVX_PALIGNR,456)
FD_MNEMONIC(EVX_PANDD,457)
FD_MNEMONIC(EVX_PANDND,458)
FD_MNEMONIC(EVX_PANDNQ,459)
FD_MNEMONIC(EVX_PANDQ,460)
FD_MNEMONIC(EVX_PAVGB,461)
FD_MNEMONIC(EVX_PAVGW,462)
FD_MNEMONIC(EVX_PBLENDMB,463)
FD_MNEMONIC(EVX_PBLENDMD,464)
FD_MNEMONIC(EVX_PBLENDMQ,465)
FD_MNEMONIC(EVX_PBLENDMW,466)
FD_MNEMONIC(EVX_PBROADCAST,467)
FD_MNEMONIC(EVX_PBROADCASTB,468)
FD_MNEMONIC(EVX_PBROADCASTD,469)
FD_MNEMONIC(EVX_PBROADCASTMB2Q,470)
FD_MNEMONIC(EVX_PBROADCASTMW2D,471)
FD_MNEMONIC(EVX_PBROADCASTQ,472)
FD_MNEMONIC(EVX_PBROADCASTW,473)
FD_MNEMONIC(EVX_PCLMULQDQ,474)
FD_MNEMONIC(EVX_PCMPB,475)
FD_MNEMONIC(EVX_PCMPD,476)
FD_MNEMONIC(EVX_PCMPEQB,477)
FD_MNEMONIC(EVX_PCMPEQD,478)
FD_MNEMONIC(EVX_PCMPEQQ,479)
FD_MNEMONIC(EVX_PCMPEQW,480)
FD_MNEMONIC(EVX_PCMPGTB,481)
FD_MNEMONIC(EVX_PCMPGTD,482)
FD_MNEMONIC(EVX_PCMPGTQ,483)
FD_MNEMONIC(EVX_PCMPGTW,484)
FD_MNEMONIC(EVX_PCMPQ,485)
FD_MNEMONIC(EVX_PCMPUB,486)
FD_MNEMONIC(EVX_PCMPUD,487)
FD_MNEMONIC(EVX_PCMPUQ,488)
FD_MNEMONIC(EVX_PCMPUW,489)
FD_MNEMONIC(EVX_PCMPW,490)
FD_MNEMONIC(EVX_PCOMPRESSB,491)
FD_MNEMONIC(EVX_PCOMPRESSD,492)
FD_MNEMONIC(EVX_PCOMPRESSQ,493)
FD_MNEMONIC(EVX_PCOMPRESSW,494)
FD_MNEMONIC(EVX_PCONFLICTD,495)
FD_MNEMONIC(EVX_PCONFLICTQ,496)
FD_MNEMONIC(EVX_PDPBUSD,497)
FD_MNEMONIC(EVX_PDPBUSDS,498)
FD_MNEMONIC(EVX_PDPWSSD,499)
FD_MNEMONIC(EVX_PDPWSSDS,500)
FD_MNEMONIC(EVX_PERMB,501)
FD_MNEMONIC(EVX_PERMD,502)
FD_MNEMONIC(EVX_PERMI2B,503)
FD_MNEMONIC(EVX_PERMI2D,504)
FD_MNEMONIC(EVX_PERMI2PD,505)
FD_MNEMONIC(EVX_PERMI2PS,506)
FD_MNEMONIC(EVX_PERMI2Q,507)
FD_MNEMONIC(EVX_PERMI2W,508)
FD_MNEMONIC(EVX_PERMILPD,509)
FD_MNEMONIC(EVX_PERMILPS,510)
FD_MNEMONIC(EVX_PERMPD,511)
FD_MNEMONIC(EVX_PERMPS,512)
FD_MNEMONIC(EVX_PERMQ,513)
FD_MNEMONIC(EVX_PERMT2B,514)
FD_MNEMONIC(EVX_PERMT2D,515)
FD_MNEMONIC(EVX_PERMT2PD,516)
FD_MNEMONIC(EVX_PERMT2PS,517)
FD_MNEMONIC(EVX_PERMT2Q,518)
FD_MNEMONIC(EVX_PERMT2W,519)
FD_MNEMONIC(EVX_PERMW,520)
FD_MNEMONIC(EVX_PEXPANDB,521)
FD_MNEMONIC(EVX_PEXPANDD,522)
FD_MNEMONIC(EVX_PEXPANDQ,523)
FD_MNEMONIC(EVX_PEXPANDW,524)
FD_MNEMONIC(EVX_PEXTR,525)
FD_MNEMONIC(EVX_PEXTRB,526)
FD_MNEMONIC(EVX_PEXTRW,527)
FD_MNEMONIC(EVX_PGATHERDD,528)
FD_MNEMONIC(EVX_PGATHERDQ,529)
FD_MNEMONIC(EVX_PGATHERQD,530)
FD_MNEMONIC(EVX_PGATHERQQ,531)
FD_MNEMONIC(EVX_PINSR,532)
FD_MNEMONIC(EVX_PLZCNTD,533)
FD_MNEMONIC(EVX_PLZCNTQ,534)
FD_MNEMONIC(EVX_PMADD52HUQ,535)
FD_MNEMONIC(EVX_PMADD52LUQ,536)
FD_MNEMONIC(EVX_PMADDUBSW,537)
FD_MNEMONIC(EVX_PMADDWD,538)
FD_MNEMONIC(EVX_PMAXSB,539)
FD_MNEMONIC(EVX_PMAXSD,540)
FD_MNEMONIC(EVX_PMAXSQ,541)
FD_MNEMONIC(EVX_PMAXSW,542)
FD_MNEMONIC(EVX_PMAXUB,543)
FD_MNEMONIC(EVX_PMAXUD,544)
FD_MNEMONIC(EVX_PMAXUQ,545)
FD_MNEMONIC(EVX_PMAXUW,546)
FD_MNEMONIC(EVX_PMINSB,547)
FD_MNEMONIC(EVX_PMINSD,548)
FD_MNEMONIC(EVX_PMINSQ,549)
FD_MNEMONIC(EVX_PMINSW,550)
FD_MNEMONIC(EVX_PMINUB,551)
FD_MNEMONIC(EVX_PMINUD,552)
FD_MNEMONIC(EVX_PMINUQ,553)
FD_MNEMONIC(EVX_PMINUW,554)
FD_MNEMONIC(EVX_PMOVB2M,555)
FD_MNEMONIC(EVX_PMOVD2M,556)
FD_MNEMONIC(EVX_PMOVDB,557)
FD_MNEMONIC(EVX_PMOVDW,558)
FD_MNEMONIC(EVX_PMOVM2B,559)
FD_MNEMONIC(EVX_PMOVM2D,560)
FD_MNEMONIC(EVX_PMOVM2Q,561)
FD_MNEMONIC(EVX_PMOVM2W,562)
FD_MNEMONIC(EVX_PMOVQ2M,563)
FD_MNEMONIC(EVX_PMOVQB,564)
FD_MNEMONIC(EVX_PMOVQD,565)
FD_MNEMONIC(EVX_PMOVQW,566)
FD_MNEMONIC(EVX_PMOVSDB,567)
FD_MNEMONIC(EVX_PMOVSDW,568)
FD_MNEMONIC(EVX_PMOVSQB,569)
FD_MNEMONIC(EVX_PMOVSQD,570)
FD_MNEMONIC(EVX_PMOVSQW,571)
FD_MNEMONIC(EVX_PMOVSWB,572)
FD_MNEMONIC(EVX_PMOVSXBD,573)
FD_MNEMONIC(EVX_PMOVSXBQ,574)
FD_MNEMONIC(EVX_PMOVSXBW,575)
FD_MNEMONIC(EVX_PMOVSXDQ,576)
FD_MNEMONIC(EVX_PMOVSXWD,577)
FD_MNEMONIC(EVX_PMOVSXWQ,578)
FD_MNEMONIC(EVX_PMOVUSDB,579)
FD_MNEMONIC(EVX_PMOVUSDW,580)
FD_MNEMONIC(EVX_PMOVUSQB,581)
FD_MNEMONIC(EVX_PMOVUSQD,582)
FD_MNEMONIC(EVX_PMOVUSQW,583)
FD_MNEMONIC(EVX_PMOVUSWB,584)
FD_MNEMONIC(EVX_PMOVW2M,585)
FD_MNEMONIC(EVX_PMOVWB,586)
FD_MNEMONIC(EVX_PMOVZXBD,587)
FD_MNEMONIC(EVX_PMOVZXBQ,588)
FD_MNEMONIC(EVX_PMOVZXBW,589)
FD_MNEMONIC(EVX_PMOVZXDQ,590)
FD_MNEMONIC(EVX_PMOVZXWD,591)
FD_MNEMONIC(EVX_PMOVZXWQ,592)
FD_MNEMONIC(EVX_PMULDQ,593)
FD_MNEMONIC(EVX_PMULHRSW,594)
FD_MNEMONIC(EVX_PMULHUW,595)
FD_MNEMONIC(EVX_PMULHW,596)
FD_MNEMONIC(EVX_PMULLD,597)
FD_MNEMONIC(EVX_PMULLQ,598)
FD_MNEMONIC(EVX_PMULLW,599)
FD_MNEMONIC(EVX_PMULTISHIFTQB,600)
FD_MNEMONIC(EVX_PMULUDQ,601)
FD_MNEMONIC(EVX_POPCNTB,602)
FD_MNEMONIC(EVX_POPCNTD,603)
FD_MNEMONIC(EVX_POPCNTQ,604)
FD_MNEMONIC(EVX_POPCNTW,605)
FD_MNEMONIC(EVX_PORD,606)
FD_MNEMONIC(EVX_PORQ,607)
FD_MNEMONIC(EVX_PROLD,608)
FD_MNEMONIC(EVX_PROLQ,609)
FD_MNEMONIC(EVX_PROLVD,610)
FD_MNEMONIC(EVX_PROLVQ,611)
FD_MNEMONIC(EVX_PRORD,612)
FD_MNEMONIC(EVX_PRORQ,613)
FD_MNEMONIC(EVX_PRORVD,614)
FD_MNEMONIC(EVX_PRORVQ,615)
FD_MNEMONIC(EVX_PSADBW,616)
FD_MNEMONIC(EVX_PSCATTERDD,617)
FD_MNEMONIC(EVX_PSCATTERDQ,618)
FD_MNEMONIC(EVX_PSCATTERQD,619)
FD_MNEMONIC(EVX_PSCATTERQQ,620)
FD_MNEMONIC(EVX_PSHLDD,621)
FD_MNEMONIC(EVX_PSHLDQ,622)
FD_MNEMONIC(EVX_PSHLDVD,623)
FD_MNEMONIC(EVX_PSHLDVQ,624)
FD_MNEMONIC(EVX_PSHLDVW,625)
FD_MNEMONIC(EVX_PSHLDW,626)
FD_MNEMONIC(EVX_PSHRDD,627)
FD_MNEMONIC(EVX_PSHRDQ,628)
FD_MNEMONIC(EVX_PSHRDVD,629)
FD_MNEMONIC(EVX_PSHRDVQ,630)
FD_MNEMONIC(EVX_PSHRDVW,631)
FD_MNEMONIC(EVX_PSHRDW,632)
FD_MNEMONIC(EVX_PSHUFB,633)
FD_MNEMONIC(EVX_PSHUFBITQMB,634)
FD_MNEMONIC(EVX_PSHUFD,635)
FD_MNEMONIC(EVX_PSHUFHW,636)
FD_MNEMONIC(EVX_PSHUFLW,637)
FD_MNEMONIC(EVX_PSLLD,638)
FD_MNEMONIC(EVX_PSLLDQ,639)
FD_MNEMONIC(EVX_PSLLQ,640)
FD_MNEMONIC(EVX_PSLLVD,641)
FD_MNEMONIC(EVX_PSLLVQ,642)
FD_MNEMONIC(EVX_PSLLVW,643)
FD_MNEMONIC(EVX_PSLLW,644)
FD_MNEMONIC(EVX_PSRAD,645)
FD_MNEMONIC(EVX_PSRAQ,646)
FD_MNEMONIC(EVX_PSRAVD,647)
FD_MNEMONIC(EVX_PSRAVQ,648)
FD_MNEMONIC(EVX_PSRAVW,649)
FD_MNEMONIC(EVX_PSRAW,650)
FD_MNEMONIC(EVX_PSRLD,651)
FD_MNEMONIC(EVX_PSRLDQ,652)
FD_MNEMONIC(EVX_PSRLQ,653)
FD_MNEMONIC(EVX_PSRLVD,654)
FD_MNEMONIC(EVX_PSRLVQ,655)
FD_MNEMONIC(EVX_PSRLVW,656)
FD_MNEMONIC(EVX_PSRLW,657)
FD_MNEMONIC(EVX_PSUBB,658)
FD_MNEMONIC(EVX_PSUBD,659)
FD_MNEMONIC(EVX_PSUBQ,660)
FD_MNEMONIC(EVX_PSUBSB,661)
FD_MNEMONIC(EVX_PSUBSW,662)
FD_MNEMONIC(EVX_PSUBUSB,663)
FD_MNEMONIC(EVX_PSUBUSW,664)
FD_MNEMONIC(EVX_PSUBW,665)
FD_MNEMONIC(EVX_PTERNLOGD,666)
FD_MNEMONIC(EVX_PTERNLOGQ,667)
FD_MNEMONIC(EVX_PTESTMB,668)
FD_MNEMONIC(EVX_PTESTMD,669)
FD_MNEMONIC(EVX_PTESTMQ,670)
FD_MNEMONIC(EVX_PTESTMW,671)
FD_MNEMONIC(EVX_PTESTNMB,672)
FD_MNEMONIC(EVX_PTESTNMD,673)
FD_MNEMONIC(EVX_PTESTNMQ,674)
FD_MNEMONIC(EVX_PTESTNMW,675)
FD_MNEMONIC(EVX_PUNPCKHBW,676)
FD_MNEMONIC(EVX_PUNPCKHDQ,677)
FD_MNEMONIC(EVX_PUNPCKHQDQ,678)
FD_MNEMONIC(EVX_PUNPCKHWD,679)
FD_MNEMONIC(EVX_PUNPCKLBW,680)
FD_MNEMONIC(EVX_PUNPCKLDQ,681)
FD_MNEMONIC(EVX_PUNPCKLQDQ,682)
FD_MNEMONIC(EVX_PUNPCKLWD,683)
FD_MNEMONIC(EVX_PXORD,684)
FD_MNEMONIC(EVX_PXORQ,685)
FD_MNEMONIC(EVX_RANGEPD,686)
FD_MNEMONIC(EVX_RANGEPS,687)
FD_MNEMONIC(EVX_RANGESD,688)
FD_MNEMONIC(EVX_RANGESS,689)
FD_MNEMONIC(EVX_RCP14PD,690)
FD_MNEMONIC(EVX_RCP14PS,691)
FD_MNEMONIC(EVX_RCP14SD,692)
FD_MNEMONIC(EVX_RCP14SS,693)
FD_MNEMONIC(EVX_RCPPH,694)
FD_MNEMONIC(EVX_RCPSH,695)
FD_MNEMONIC(EVX_REDUCEPD,696)
FD_MNEMONIC(EVX_REDUCEPH,697)
FD_MNEMONIC(EVX_REDUCEPS,698)
FD_MNEMONIC(EVX_REDUCESD,699)
FD_MNEMONIC(EVX_REDUCESH,700)
FD_MNEMONIC(EVX_REDUCESS,701)
FD_MNEMONIC(EVX_RNDSCALEPD,702)
FD_MNEMONIC(EVX_RNDSCALEPH,703)
FD_MNEMONIC(EVX_RNDSCALEPS,704)
FD_MNEMONIC(EVX_RNDSCALESD,705)
FD_MNEMONIC(EVX_RNDSCALESH,706)
FD_MNEMONIC(EVX_RNDSCALESS,707)
FD_MNEMONIC(EVX_RSQRT14PD,708)
FD_MNEMONIC(EVX_RSQRT14PS,709)
FD_MNEMONIC(EVX_RSQRT14SD,710)
FD_MNEMONIC(EVX_RSQRT14SS,711)
FD_MNEMONIC(EVX_RSQRTPH,712)
FD_MNEMONIC(EVX_RSQRTSH,713)
FD_MNEMONIC(EVX_SCALEFPD,714)
FD_MNEMONIC(EVX_SCALEFPH,715)
FD_MNEMONIC(EVX_SCALEFPS,716)
FD_MNEMONIC(EVX_SCALEFSD,717)
FD_MNEMONIC(EVX_SCALEFSH,718)
FD_MNEMONIC(EVX_SCALEFSS,719)
FD_MNEMONIC(EVX_SCATTERDPD,720)
FD_MNEMONIC(EVX_SCATTERDPS,721)
FD_MNEMONIC(EVX_SCATTERQPD,722)
FD_MNEMONIC(EVX_SCATTERQPS,723)
FD_MNEMONIC(EVX_SHUFF32X4,724)
FD_MNEMONIC(EVX_SHUFF64X2,725)
FD_MNEMONIC(EVX_SHUFI32X4,726)
FD_MNEMONIC(EVX_SHUFI64X2,727)
FD_MNEMONIC(EVX_SHUFPD,728)
FD_MNEMONIC(EVX_SHUFPS,729)
FD_MNEMONIC(EVX_SQRTPD,730)
FD_MNEMONIC(EVX_SQRTPH,731)
FD_MNEMONIC(EVX_SQRTPS,732)
FD_MNEMONIC(EVX_SQRTSD,733)
FD_MNEMONIC(EVX_SQRTSH,734)
FD_MNEMONIC(EVX_SQRTSS,735)
FD_MNEMONIC(EVX_SUBPD,736)
FD_MNEMONIC(EVX_SUBPH,737)
FD_MNEMONIC(EVX_SUBPS,738)
FD_MNEMONIC(EVX_SUBSD,739)
FD_MNEMONIC(EVX_SUBSH,740)
FD_MNEMONIC(EVX_SUBSS,741)
FD_MNEMONIC(EVX_UCOMISD,742)
FD_MNEMONIC(EVX_UCOMISH,743)
FD_MNEMONIC(EVX_UCOMISS,744)
FD_MNEMONIC(EVX_UNPCKHPD,745)
FD_MNEMONIC(EVX_UNPCKHPS,746)
FD_MNEMONIC(EVX_UNPCKLPD,747)
FD_MNEMONIC(EVX_UNPCKLPS,748)
FD_MNEMONIC(EVX_XORPD,749)
FD_MNEMONIC(EVX_XORPS,750)
FD_MNEMONIC(F2XM1,751)
FD_MNEMONIC(FABS,752)
FD_MNEMONIC(FADD,753)
FD_MNEMONIC(FADDP,754)
FD_MNEMONIC(FBLD,755)
FD_MNEMONIC(FBSTP,756)
FD_MNEMONIC(FCHS,757)
FD_MNEMONIC(FCLEX,758)
FD_MNEMONIC(FCMOVB,759)
FD_MNEMONIC(FCMOVBE,760)
FD_MNEMONIC(FCMOVE,761)
FD_MNEMONIC(FCMOVNB,762)
FD_MNEMONIC(FCMOVNBE,763)
FD_MNEMONIC(FCMOVNE,764)
FD_MNEMONIC(FCMOVNU,765)
FD_MNEMONIC(FCMOVU,766)
FD_MNEMONIC(FCOM,767)
FD_MNEMONIC(FCOMI,768)
FD_MNEMONIC(FCOMIP,769)
FD_MNEMONIC(FCOMP,770)
FD_MNEMONIC(FCOMPP,771)
FD_MNEMONIC(FCOS,772)
FD_MNEMONIC(FDECSTP,773)
FD_MNEMONIC(FDIV,774)
FD_MNEMONIC(FDIVP,775)
FD_MNEMONIC(FDIVR,776)
FD_MNEMONIC(FDIVRP,777)
FD_MNEMONIC(FEMMS,778)
FD_MNEMONIC(FFREE,779)
FD_MNEMONIC(FIADD,780)
FD_MNEMONIC(FICOM,781)
FD_MNEMONIC(FICOMP,782)
FD_MNEMONIC(FIDIV,783)
FD_MNEMONIC(FIDIVR,784)
FD_MNEMONIC(FILD,785)
FD_MNEMONIC(FIMUL,786)
FD_MNEMONIC(FINCSTP,787)
FD_MNEMONIC(FINIT,788)
FD_MNEMONIC(FIST,789)
FD_MNEMONIC(FISTP,790)
FD_MNEMONIC(FISTTP,791)
FD_MNEMONIC(FISUB,792)
FD_MNEMONIC(FISUBR,793)
FD_MNEMONIC(FLD,794)
FD_MNEMONIC(FLD1,795)
FD_MNEMONIC(FLDCW,796)
FD_MNEMONIC(FLDENV,797)
FD_MNEMONIC(FLDL2E,798)
FD_MNEMONIC(FLDL2T,799)
FD_MNEMONIC(FLDLG2,800)
FD_MNEMONIC(FLDLN2,801)
FD_MNEMONIC(FLDPI,802)
FD_MNEMONIC(FLDZ,803)
FD_MNEMONIC(FMUL,804)
FD_MNEMONIC(FMULP,805)
FD_MNEMONIC(FNOP,806)
FD_MNEMONIC(FPATAN,807)
FD_MNEMONIC(FPREM,808)
FD_MNEMONIC(FPREM1,809)
FD_MNEMONIC(FPTAN,810)
FD_MNEMONIC(FRNDINT,811)
FD_MNEMONIC(FRSTOR,812)
FD_MNEMONIC(FSAVE,813)
FD_MNEMONIC(FSCALE,814)
FD_MNEMONIC(FSIN,815)
FD_MNEMONIC(FSINCOS,816)
FD_MNEMONIC(FSQRT,817)
FD_MNEMONIC(FST,818)
FD_MNEMONIC(FSTCW,819)
FD_MNEMONIC(FSTENV,820)
FD_MNEMONIC(FSTP,821)
FD_MNEMONIC(FSTSW,822)
FD_MNEMONIC(FSUB,823)
FD_MNEMONIC(FSUBP,824)
FD_MNEMONIC(FSUBR,825)
FD_MNEMONIC(FSUBRP,826)
FD_MNEMONIC(FTST,827)
FD_MNEMONIC(FUCOM,828)
FD_MNEMONIC(FUCOMI,829)
FD_MNEMONIC(FUCOMIP,830)
FD_MNEMONIC(FUCOMP,831)
FD_MNEMONIC(FUCOMPP,832)
FD_MNEMONIC(FWAIT,833)
FD_MNEMONIC(FXAM,834)
FD_MNEMONIC(FXCH,835)
FD_MNEMONIC(FXRSTOR,836)
FD_MNEMONIC(FXSAVE,837)
FD_MNEMONIC(FXTRACT,838)
FD_MNEMONIC(FYL2X,839)
FD_MNEMONIC(FYL2XP1,840)
FD_MNEMONIC(GETSEC,841)
FD_MNEMONIC(GF2P8AFFINEINVQB,842)
FD_MNEMONIC(GF2P8AFFINEQB,843)
FD_MNEMONIC(GF2P8MULB,844)
FD_MNEMONIC(HLT,845)
FD_MNEMONIC(HRESET,846)
FD_MNEMONIC(IDIV,847)
FD_MNEMONIC(IMUL,848)
FD_MNEMONIC(IN,849)
FD_MNEMONIC(INC,850)
FD_MNEMONIC(INCSSP,851)
FD_MNEMONIC(INS,852)
FD_MNEMONIC(INT,853)
FD_MNEMONIC(INT1,854)
FD_MNEMONIC(INT3,855)
FD_MNEMONIC(INTO,856)
FD_MNEMONIC(INVD,857)
FD_MNEMONIC(INVEPT,858)
FD_MNEMONIC(INVLPG,859)
FD_MNEMONIC(INVLPGA,860)
FD_MNEMONIC(INVLPGB,861)
FD_MNEMONIC(INVPCID,862)
FD_MNEMONIC(INVVPID,863)
FD_MNEMONIC(IRET,864)
FD_MNEMONIC(JA,865)
FD_MNEMONIC(JBE,866)
FD_MNEMONIC(JC,867)
FD_MNEMONIC(JCXZ,868)
FD_MNEMONIC(JG,869)
FD_MNEMONIC(JGE,870)
FD_MNEMONIC(JL,871)
FD_MNEMONIC(JLE,872)
FD_MNEMONIC(JMP,873)
FD_MNEMONIC(JMPF,874)
FD_MNEMONIC(JNC,875)
FD_MNEMONIC(JNO,876)
FD_MNEMONIC(JNP,877)
FD_MNEMONIC(JNS,878)
FD_MNEMONIC(JNZ,879)
FD_MNEMONIC(JO,880)
FD_MNEMONIC(JP,881)
FD_MNEMONIC(JS,882)
FD_MNEMONIC(JZ,883)
FD_MNEMONIC(KADDB,884)
FD_MNEMONIC(KADDD,885)
FD_MNEMONIC(KADDQ,886)
FD_MNEMONIC(KADDW,887)
FD_MNEMONIC(KANDB,888)
FD_MNEMONIC(KANDD,889)
FD_MNEMONIC(KANDNB,890)
FD_MNEMONIC(KANDND,891)
FD_MNEMONIC(KANDNQ,892)
FD_MNEMONIC(KANDNW,893)
FD_MNEMONIC(KANDQ,894)
FD_MNEMONIC(KANDW,895)
FD_MNEMONIC(KMOVB,896)
FD_MNEMONIC(KMOVD,897)
FD_MNEMONIC(KMOVQ,898)
FD_MNEMONIC(KMOVW,899)
FD_MNEMONIC(KNOTB,900)
FD_MNEMONIC(KNOTD,901)
FD_MNEMONIC(KNOTQ,902)
FD_MNEMONIC(KNOTW,903)
FD_MNEMONIC(KORB,904)
FD_MNEMONIC(KORD,905)
FD_MNEMONIC(KORQ,906)
FD_MNEMONIC(KORTESTB,907)
FD_MNEMONIC(KORTESTD,908)
FD_MNEMONIC(KORTESTQ,909)
FD_MNEMONIC(KORTESTW,910)
FD_MNEMONIC(KORW,911)
FD_MNEMONIC(KSHIFTLB,912)
FD_MNEMONIC(KSHIFTLD,913)
FD_MNEMONIC(KSHIFTLQ,914)
FD_MNEMONIC(KSHIFTLW,915)
FD_MNEMONIC(KSHIFTRB,916)
FD_MNEMONIC(KSHIFTRD,917)
FD_MNEMONIC(KSHIFTRQ,918)
FD_MNEMONIC(KSHIFTRW,919)
FD_MNEMONIC(KTESTB,920)
FD_MNEMONIC(KTESTD,921)
FD_MNEMONIC(KTESTQ,922)
FD_MNEMONIC(KTESTW,923)
FD_MNEMONIC(KUNPCKBW,924)
FD_MNEMONIC(KUNPCKDQ,925)
FD_MNEMONIC(KUNPCKWD,926)
FD_MNEMONIC(KXNORB,927)
FD_MNEMONIC(KXNORD,928)
FD_MNEMONIC(KXNORQ,929)
FD_MNEMONIC(KXNORW,930)
FD_MNEMONIC(KXORB,931)
FD_MNEMONIC(KXORD,932)
FD_MNEMONIC(KXORQ,933)
FD_MNEMONIC(KXORW,934)
FD_MNEMONIC(LAHF,935)
FD_MNEMONIC(LAR,936)
FD_MNEMONIC(LDMXCSR,937)
FD_MNEMONIC(LDS,938)
FD_MNEMONIC(LDTILECFG,939)
FD_MNEMONIC(LEA,940)
FD_MNEMONIC(LEAVE,941)
FD_MNEMONIC(LES,942)
FD_MNEMONIC(LFENCE,943)
FD_MNEMONIC(LFS,944)
FD_MNEMONIC(LGDT,945)
FD_MNEMONIC(LGS,946)
FD_MNEMONIC(LIDT,947)
FD_MNEMONIC(LKGS,948)
FD_MNEMONIC(LLDT,949)
FD_MNEMONIC(LMSW,950)
FD_MNEMONIC(LOADIWKEY,951)
FD_MNEMONIC(LODS,952)
FD_MNEMONIC(LOOP,953)
FD_MNEMONIC(LOOPNZ,954)
FD_MNEMONIC(LOOPZ,955)
FD_MNEMONIC(LSL,956)
FD_MNEMONIC(LSS,957)
FD_MNEMONIC(LTR,958)
FD_MNEMONIC(LZCNT,959)
FD_MNEMONIC(MCOMMIT,960)
FD_MNEMONIC(MFENCE,961)
FD_MNEMONIC(MMX_CVTPD2PI,962)
FD_MNEMONIC(MMX_CVTPI2PD,963)
FD_MNEMONIC(MMX_CVTPI2PS,964)
FD_MNEMONIC(MMX_CVTPS2PI,965)
FD_MNEMONIC(MMX_CVTTPD2PI,966)
FD_MNEMONIC(MMX_CVTTPS2PI,967)
FD_MNEMONIC(MMX_EMMS,968)
FD_MNEMONIC(MMX_MASKMOVQ,969)
FD_MNEMONIC(MMX_MOVD,970)
FD_MNEMONIC(MMX_MOVDQ2Q,971)
FD_MNEMONIC(MMX_MOVNTQ,972)
FD_MNEMONIC(MMX_MOVQ,973)
FD_MNEMONIC(MMX_MOVQ2DQ,974)
FD_MNEMONIC(MMX_PABSB,975)
FD_MNEMONIC(MMX_PABSD,976)
FD_MNEMONIC(MMX_PABSW,977)
FD_MNEMONIC(MMX_PACKSSDW,978)
FD_MNEMONIC(MMX_PACKSSWB,979)
FD_MNEMONIC(MMX_PACKUSWB,980)
FD_MNEMONIC(MMX_PADDB,981)
FD_MNEMONIC(MMX_PADDD,982)
FD_MNEMONIC(MMX_PADDQ,983)
FD_MNEMONIC(MMX_PADDSB,984)
FD_MNEMONIC(MMX_PADDSW,985)
FD_MNEMONIC(MMX_PADDUSB,986)
FD_MNEMONIC(MMX_PADDUSW,987)
FD_MNEMONIC(MMX_PADDW,988)
FD_MNEMONIC(MMX_PALIGNR,989)
FD_MNEMONIC(MMX_PAND,990)
FD_MNEMONIC(MMX_PANDN,991)
FD_MNEMONIC(MMX_PAVGB,992)
FD_MNEMONIC(MMX_PAVGW,993)
FD_MNEMONIC(MMX_PCMPEQB,994)
FD_MNEMONIC(MMX_PCMPEQD,995)
FD_MNEMONIC(MMX_PCMPEQW,996)
FD_MNEMONIC(MMX_PCMPGTB,997)
FD_MNEMONIC(MMX_PCMPGTD,998)
FD_MNEMONIC(MMX_PCMPGTW,999)
FD_MNEMONIC(MMX_PEXTRW,1000)
FD_MNEMONIC(MMX_PHADDD,1001)
FD_MNEMONIC(MMX_PHADDSW,1002)
FD_MNEMONIC(MMX_PHADDW,1003)
FD_MNEMONIC(MMX_PHSUBD,1004)
FD_MNEMONIC(MMX_PHSUBSW,1005)
FD_MNEMONIC(MMX_PHSUBW,1006)
FD_MNEMONIC(MMX_PINSRW,1007)
FD_MNEMONIC(MMX_PMADDUBSW,1008)
FD_MNEMONIC(MMX_PMADDWD,1009)
FD_MNEMONIC(MMX_PMAXSW,1010)
FD_MNEMONIC(MMX_PMAXUB,1011)
FD_MNEMONIC(MMX_PMINSW,1012)
FD_MNEMONIC(MMX_PMINUB,1013)
FD_MNEMONIC(MMX_PMOVMSKB,1014)
FD_MNEMONIC(MMX_PMULHRSW,1015)
FD_MNEMONIC(MMX_PMULHUW,1016)
FD_MNEMONIC(MMX_PMULHW,1017)
FD_MNEMONIC(MMX_PMULLW,1018)
FD_MNEMONIC(MMX_PMULUDQ,1019)
FD_MNEMONIC(MMX_POR,1020)
FD_MNEMONIC(MMX_PSADBW,1021)
FD_MNEMONIC(MMX_PSHUFB,1022)
FD_MNEMONIC(MMX_PSHUFW,1023)
FD_MNEMONIC(MMX_PSIGNB,1024)
FD_MNEMONIC(MMX_PSIGND,1025)
FD_MNEMONIC(MMX_PSIGNW,1026)
FD_MNEMONIC(MMX_PSLLD,1027)
FD_MNEMONIC(MMX_PSLLQ,1028)
FD_MNEMONIC(MMX_PSLLW,1029)
FD_MNEMONIC(MMX_PSRAD,1030)
FD_MNEMONIC(MMX_PSRAW,1031)
FD_MNEMONIC(MMX_PSRLD,1032)
FD_MNEMONIC(MMX_PSRLQ,1033)
FD_MNEMONIC(MMX_PSRLW,1034)
FD_MNEMONIC(MMX_PSUBB,1035)
FD_MNEMONIC(MMX_PSUBD,1036)
FD_MNEMONIC(MMX_PSUBQ,1037)
FD_MNEMONIC(MMX_PSUBSB,1038)
FD_MNEMONIC(MMX_PSUBSW,1039)
FD_MNEMONIC(MMX_PSUBUSB,1040)
FD_MNEMONIC(MMX_PSUBUSW,1041)
FD_MNEMONIC(MMX_PSUBW,1042)
FD_MNEMONIC(MMX_PUNPCKHBW,1043)
FD_MNEMONIC(MMX_PUNPCKHDQ,1044)
FD_MNEMONIC(MMX_PUNPCKHWD,1045)
FD_MNEMONIC(MMX_PUNPCKLBW,1046)
FD_MNEMONIC(MMX_PUNPCKLDQ,1047)
FD_MNEMONIC(MMX_PUNPCKLWD,1048)
FD_MNEMONIC(MMX_PXOR,1049)
FD_MNEMONIC(MONITOR,1050)
FD_MNEMONIC(MONITORX,1051)
FD_MNEMONIC(MOV,1052)
FD_MNEMONIC(MOVABS,1053)
FD_MNEMONIC(MOVBE,1054)
FD_MNEMONIC(MOVDIR64B,1055)
FD_MNEMONIC(MOVDIRI,1056)
FD_MNEMONIC(MOVNTI,1057)
FD_MNEMONIC(MOVS,1058)
FD_MNEMONIC(MOVSX,1059)
FD_MNEMONIC(MOVZX,1060)
FD_MNEMONIC(MOV_CR,1061)
FD_MNEMONIC(MOV_DR,1062)
FD_MNEMONIC(MOV_G2S,1063)
FD_MNEMONIC(MOV_S2G,1064)
FD_MNEMONIC(MUL,1065)
FD_MNEMONIC(MULX,1066)
FD_MNEMONIC(MWAIT,1067)
FD_MNEMONIC(MWAITX,1068)
FD_MNEMONIC(NEG,1069)
FD_MNEMONIC(NOP,1070)
FD_MNEMONIC(NOT,1071)
FD_MNEMONIC(OR,1072)
FD_MNEMONIC(OUT,1073)
FD_MNEMONIC(OUTS,1074)
FD_MNEMONIC(PAUSE,1075)
FD_MNEMONIC(PBNDKB,1076)
FD_MNEMONIC(PCONFIG,1077)
FD_MNEMONIC(PDEP,1078)
FD_MNEMONIC(PEXT,1079)
FD_MNEMONIC(POP,1080)
FD_MNEMONIC(POPA,1081)
FD_MNEMONIC(POPCNT,1082)
FD_MNEMONIC(POPF,1083)
FD_MNEMONIC(PREFETCH,1084)
FD_MNEMONIC(PREFETCHIT0,1085)
FD_MNEMONIC(PREFETCHIT1,1086)
FD_MNEMONIC(PREFETCHNTA,1087)
FD_MNEMONIC(PREFETCHT0,1088)
FD_MNEMONIC(PREFETCHT1,1089)
FD_MNEMONIC(PREFETCHT2,1090)
FD_MNEMONIC(PREFETCHW,1091)
FD_MNEMONIC(PREFETCHWT1,1092)
FD_MNEMONIC(PSMASH,1093)
FD_MNEMONIC(PTWRITE,1094)
FD_MNEMONIC(PUSH,1095)
FD_MNEMONIC(PUSHA,1096)
FD_MNEMONIC(PUSHF,1097)
FD_MNEMONIC(PVALIDATE,1098)
FD_MNEMONIC(RCL,1099)
FD_MNEMONIC(RCR,1100)
FD_MNEMONIC(RDFSBASE,1101)
FD_MNEMONIC(RDGSBASE,1102)
FD_MNEMONIC(RDMSR,1103)
FD_MNEMONIC(RDMSRLIST,1104)
FD_MNEMONIC(RDPID,1105)
FD_MNEMONIC(RDPKRU,1106)
FD_MNEMONIC(RDPMC,1107)
FD_MNEMONIC(RDPRU,1108)
FD_MNEMONIC(RDRAND,1109)
FD_MNEMONIC(RDSEED,1110)
FD_MNEMONIC(RDSSP,1111)
FD_MNEMONIC(RDTSC,1112)
FD_MNEMONIC(RDTSCP,1113)
FD_MNEMONIC(REP_MONTMUL,1114)
FD_MNEMONIC(REP_XCRYPTCBC,1115)
FD_MNEMONIC(REP_XCRYPTCFB,1116)
FD_MNEMONIC(REP_XCRYPTCTR,1117)
FD_MNEMONIC(REP_XCRYPTECB,1118)
FD_MNEMONIC(REP_XCRYPTOFB,1119)
FD_MNEMONIC(REP_XSHA1,1120)
FD_MNEMONIC(REP_XSHA256,1121)
FD_MNEMONIC(REP_XSTORE,1122)
FD_MNEMONIC(RESERVED_NOP,1123)
FD_MNEMONIC(RESERVED_PREFETCH,1124)
FD_MNEMONIC(RET,1125)
FD_MNEMONIC(RETF,1126)
FD_MNEMONIC(RMPADJUST,1127)
FD_MNEMONIC(RMPQUERY,1128)
FD_MNEMONIC(RMPREAD,1129)
FD_MNEMONIC(RMPUPDATE,1130)
FD_MNEMONIC(ROL,1131)
FD_MNEMONIC(ROR,1132)
FD_MNEMONIC(RORX,1133)
FD_MNEMONIC(RSM,1134)
FD_MNEMONIC(RSTORSSP,1135)
FD_MNEMONIC(SAHF,1136)
FD_MNEMONIC(SAR,1137)
FD_MNEMONIC(SARX,1138)
FD_MNEMONIC(SAVEPREVSSP,1139)
FD_MNEMONIC(SBB,1140)
FD_MNEMONIC(SCAS,1141)
FD_MNEMONIC(SEAMCALL,1142)
FD_MNEMONIC(SEAMOPS,1143)
FD_MNEMONIC(SEAMRET,1144)
FD_MNEMONIC(SENDUIPI,1145)
FD_MNEMONIC(SERIALIZE,1146)
FD_MNEMONIC(SETA,1147)
FD_MNEMONIC(SETBE,1148)
FD_MNEMONIC(SETC,1149)
FD_MNEMONIC(SETG,1150)
FD_MNEMONIC(SETGE,1151)
FD_MNEMONIC(SETL,1152)
FD_MNEMONIC(SETLE,1153)
FD_MNEMONIC(SETNC,1154)
FD_MNEMONIC(SETNO,1155)
FD_MNEMONIC(SETNP,1156)
FD_MNEMONIC(SETNS,1157)
FD_MNEMONIC(SETNZ,1158)
FD_MNEMONIC(SETO,1159)
FD_MNEMONIC(SETP,1160)
FD_MNEMONIC(SETS,1161)
FD_MNEMONIC(SETSSBSY,1162)
FD_MNEMONIC(SETZ,1163)
FD_MNEMONIC(SFENCE,1164)
FD_MNEMONIC(SGDT,1165)
FD_MNEMONIC(SHA1MSG1,1166)
FD_MNEMONIC(SHA1MSG2,1167)
FD_MNEMONIC(SHA1NEXTE,1168)
FD_MNEMONIC(SHA1RNDS4,1169)
FD_MNEMONIC(SHA256MSG1,1170)
FD_MNEMONIC(SHA256MSG2,1171)
FD_MNEMONIC(SHA256RNDS2,1172)
FD_MNEMONIC(SHL,1173)
FD_MNEMONIC(SHLD,1174)
FD_MNEMONIC(SHLX,1175)
FD_MNEMONIC(SHR,1176)
FD_MNEMONIC(SHRD,1177)
FD_MNEMONIC(SHRX,1178)
FD_MNEMONIC(SIDT,1179)
FD_MNEMONIC(SKINIT,1180)
FD_MNEMONIC(SLDT,1181)
FD_MNEMONIC(SMSW,1182)
FD_MNEMONIC(SSE_ADDPD,1183)
FD_MNEMONIC(SSE_ADDPS,1184)
FD_MNEMONIC(SSE_ADDSD,1185)
FD_MNEMONIC(SSE_ADDSS,1186)
FD_MNEMONIC(SSE_ADDSUBPD,1187)
FD_MNEMONIC(SSE_ADDSUBPS,1188)
FD_MNEMONIC(SSE_ANDNPD,1189)
FD_MNEMONIC(SSE_ANDNPS,1190)
FD_MNEMONIC(SSE_ANDPD,1191)
FD_MNEMONIC(SSE_ANDPS,1192)
FD_MNEMONIC(SSE_BLENDPD,1193)
FD_MNEMONIC(SSE_BLENDPS,1194)
FD_MNEMONIC(SSE_BLENDVPD,1195)
FD_MNEMONIC(SSE_BLENDVPS,1196)
FD_MNEMONIC(SSE_CMPPD,1197)
FD_MNEMONIC(SSE_CMPPS,1198)
FD_MNEMONIC(SSE_CMPSD,1199)
FD_MNEMONIC(SSE_CMPSS,1200)
FD_MNEMONIC(SSE_COMISD,1201)
FD_MNEMONIC(SSE_COMISS,1202)
FD_MNEMONIC(SSE_CVTDQ2PD,1203)
FD_MNEMONIC(SSE_CVTDQ2PS,1204)
FD_MNEMONIC(SSE_CVTPD2DQ,1205)
FD_MNEMONIC(SSE_CVTPD2PS,1206)
FD_MNEMONIC(SSE_CVTPS2DQ,1207)
FD_MNEMONIC(SSE_CVTPS2PD,1208)
FD_MNEMONIC(SSE_CVTSD2SI,1209)
FD_MNEMONIC(SSE_CVTSD2SS,1210)
FD_MNEMONIC(SSE_CVTSI2SD,1211)
FD_MNEMONIC(SSE_CVTSI2SS,1212)
FD_MNEMONIC(SSE_CVTSS2SD,1213)
FD_MNEMONIC(SSE_CVTSS2SI,1214)
FD_MNEMONIC(SSE_CVTTPD2DQ,1215)
FD_MNEMONIC(SSE_CVTTPS2DQ,1216)
FD_MNEMONIC(SSE_CVTTSD2SI,1217)
FD_MNEMONIC(SSE_CVTTSS2SI,1218)
FD_MNEMONIC(SSE_DIVPD,1219)
FD_MNEMONIC(SSE_DIVPS,1220)
FD_MNEMONIC(SSE_DIVSD,1221)
FD_MNEMONIC(SSE_DIVSS,1222)
FD_MNEMONIC(SSE_DPPD,1223)
FD_MNEMONIC(SSE_DPPS,1224)
FD_MNEMONIC(SSE_EXTRACTPS,1225)
FD_MNEMONIC(SSE_EXTRQ,1226)
FD_MNEMONIC(SSE_HADDPD,1227)
FD_MNEMONIC(SSE_HADDPS,1228)
FD_MNEMONIC(SSE_HSUBPD,1229)
FD_MNEMONIC(SSE_HSUBPS,1230)
FD_MNEMONIC(SSE_INSERTPS,1231)
FD_MNEMONIC(SSE_INSERTQ,1232)
FD_MNEMONIC(SSE_LDDQU,1233)
FD_MNEMONIC(SSE_MASKMOVDQU,1234)
FD_MNEMONIC(SSE_MAXPD,1235)
FD_MNEMONIC(SSE_MAXPS,1236)
FD_MNEMONIC(SSE_MAXSD,1237)
FD_MNEMONIC(SSE_MAXSS,1238)
FD_MNEMONIC(SSE_MINPD,1239)
FD_MNEMONIC(SSE_MINPS,1240)
FD_MNEMONIC(SSE_MINSD,1241)
FD_MNEMONIC(SSE_MINSS,1242)
FD_MNEMONIC(SSE_MOVAPD,1243)
FD_MNEMONIC(SSE_MOVAPS,1244)
FD_MNEMONIC(SSE_MOVD,1245)
FD_MNEMONIC(SSE_MOVDDUP,1246)
FD_MNEMONIC(SSE_MOVDQA,1247)
FD_MNEMONIC(SSE_MOVDQU,1248)
FD_MNEMONIC(SSE_MOVHLPS,1249)
FD_MNEMONIC(SSE_MOVHPD,1250)
FD_MNEMONIC(SSE_MOVHPS,1251)
FD_MNEMONIC(SSE_MOVLHPS,1252)
FD_MNEMONIC(SSE_MOVLPD,1253)
FD_MNEMONIC(SSE_MOVLPS,1254)
FD_MNEMONIC(SSE_MOVMSKPD,1255)
FD_MNEMONIC(SSE_MOVMSKPS,1256)
FD_MNEMONIC(SSE_MOVNTDQ,1257)
FD_MNEMONIC(SSE_MOVNTDQA,1258)
FD_MNEMONIC(SSE_MOVNTPD,1259)
FD_MNEMONIC(SSE_MOVNTPS,1260)
FD_MNEMONIC(SSE_MOVNTSD,1261)
FD_MNEMONIC(SSE_MOVNTSS,1262)
FD_MNEMONIC(SSE_MOVQ,1263)
FD_MNEMONIC(SSE_MOVSD,1264)
FD_MNEMONIC(SSE_MOVSHDUP,1265)
FD_MNEMONIC(SSE_MOVSLDUP,1266)
FD_MNEMONIC(SSE_MOVSS,1267)
FD_MNEMONIC(SSE_MOVUPD,1268)
FD_MNEMONIC(SSE_MOVUPS,1269)
FD_MNEMONIC(SSE_MPSADBW,1270)
FD_MNEMONIC(SSE_MULPD,1271)
FD_MNEMONIC(SSE_MULPS,1272)
FD_MNEMONIC(SSE_MULSD,1273)
FD_MNEMONIC(SSE_MULSS,1274)
FD_MNEMONIC(SSE_ORPD,1275)
FD_MNEMONIC(SSE_ORPS,1276)
FD_MNEMONIC(SSE_PABSB,1277)
FD_MNEMONIC(SSE_PABSD,1278)
FD_MNEMONIC(SSE_PABSW,1279)
FD_MNEMONIC(SSE_PACKSSDW,1280)
FD_MNEMONIC(SSE_PACKSSWB,1281)
FD_MNEMONIC(SSE_PACKUSDW,1282)
FD_MNEMONIC(SSE_PACKUSWB,1283)
FD_MNEMONIC(SSE_PADDB,1284)
FD_MNEMONIC(SSE_PADDD,1285)
FD_MNEMONIC(SSE_PADDQ,1286)
FD_MNEMONIC(SSE_PADDSB,1287)
FD_MNEMONIC(SSE_PADDSW,1288)
FD_MNEMONIC(SSE_PADDUSB,1289)
FD_MNEMONIC(SSE_PADDUSW,1290)
FD_MNEMONIC(SSE_PADDW,1291)
FD_MNEMONIC(SSE_PALIGNR,1292)
FD_MNEMONIC(SSE_PAND,1293)
FD_MNEMONIC(SSE_PANDN,1294)
FD_MNEMONIC(SSE_PAVGB,1295)
FD_MNEMONIC(SSE_PAVGW,1296)
FD_MNEMONIC(SSE_PBLENDVB,1297)
FD_MNEMONIC(SSE_PBLENDW,1298)
FD_MNEMONIC(SSE_PCLMULQDQ,1299)
FD_MNEMONIC(SSE_PCMPEQB,1300)
FD_MNEMONIC(SSE_PCMPEQD,1301)
FD_MNEMONIC(SSE_PCMPEQQ,1302)
FD_MNEMONIC(SSE_PCMPEQW,1303)
FD_MNEMONIC(SSE_PCMPESTRI,1304)
FD_MNEMONIC(SSE_PCMPESTRM,1305)
FD_MNEMONIC(SSE_PCMPGTB,1306)
FD_MNEMONIC(SSE_PCMPGTD,1307)
FD_MNEMONIC(SSE_PCMPGTQ,1308)
FD_MNEMONIC(SSE_PCMPGTW,1309)
FD_MNEMONIC(SSE_PCMPISTRI,1310)
FD_MNEMONIC(SSE_PCMPISTRM,1311)
FD_MNEMONIC(SSE_PEXTRB,1312)
FD_MNEMONIC(SSE_PEXTRD,1313)
FD_MNEMONIC(SSE_PEXTRQ,1314)
FD_MNEMONIC(SSE_PEXTRW,1315)
FD_MNEMONIC(SSE_PHADDD,1316)
FD_MNEMONIC(SSE_PHADDSW,1317)
FD_MNEMONIC(SSE_PHADDW,1318)
FD_MNEMONIC(SSE_PHMINPOSUW,1319)
FD_MNEMONIC(SSE_PHSUBD,1320)
FD_MNEMONIC(SSE_PHSUBSW,1321)
FD_MNEMONIC(SSE_PHSUBW,1322)
FD_MNEMONIC(SSE_PINSRB,1323)
FD_MNEMONIC(SSE_PINSRD,1324)
FD_MNEMONIC(SSE_PINSRQ,1325)
FD_MNEMONIC(SSE_PINSRW,1326)
FD_MNEMONIC(SSE_PMADDUBSW,1327)
FD_MNEMONIC(SSE_PMADDWD,1328)
FD_MNEMONIC(SSE_PMAXSB,1329)
FD_MNEMONIC(SSE_PMAXSD,1330)
FD_MNEMONIC(SSE_PMAXSW,1331)
FD_MNEMONIC(SSE_PMAXUB,1332)
FD_MNEMONIC(SSE_PMAXUD,1333)
FD_MNEMONIC(SSE_PMAXUW,1334)
FD_MNEMONIC(SSE_PMINSB,1335)
FD_MNEMONIC(SSE_PMINSD,1336)
FD_MNEMONIC(SSE_PMINSW,1337)
FD_MNEMONIC(SSE_PMINUB,1338)
FD_MNEMONIC(SSE_PMINUD,1339)
FD_MNEMONIC(SSE_PMINUW,1340)
FD_MNEMONIC(SSE_PMOVMSKB,1341)
FD_MNEMONIC(SSE_PMOVSXBD,1342)
FD_MNEMONIC(SSE_PMOVSXBQ,1343)
FD_MNEMONIC(SSE_PMOVSXBW,1344)
FD_MNEMONIC(SSE_PMOVSXDQ,1345)
FD_MNEMONIC(SSE_PMOVSXWD,1346)
FD_MNEMONIC(SSE_PMOVSXWQ,1347)
FD_MNEMONIC(SSE_PMOVZXBD,1348)
FD_MNEMONIC(SSE_PMOVZXBQ,1349)
FD_MNEMONIC(SSE_PMOVZXBW,1350)
FD_MNEMONIC(SSE_PMOVZXDQ,1351)
FD_MNEMONIC(SSE_PMOVZXWD,1352)
FD_MNEMONIC(SSE_PMOVZXWQ,1353)
FD_MNEMONIC(SSE_PMULDQ,1354)
FD_MNEMONIC(SSE_PMULHRSW,1355)
FD_MNEMONIC(SSE_PMULHUW,1356)
FD_MNEMONIC(SSE_PMULHW,1357)
FD_MNEMONIC(SSE_PMULLD,1358)
FD_MNEMONIC(SSE_PMULLW,1359)
FD_MNEMONIC(SSE_PMULUDQ,1360)
FD_MNEMONIC(SSE_POR,1361)
FD_MNEMONIC(SSE_PSADBW,1362)
FD_MNEMONIC(SSE_PSHUFB,1363)
FD_MNEMONIC(SSE_PSHUFD,1364)
FD_MNEMONIC(SSE_PSHUFHW,1365)
FD_MNEMONIC(SSE_PSHUFLW,1366)
FD_MNEMONIC(SSE_PSIGNB,1367)
FD_MNEMONIC(SSE_PSIGND,1368)
FD_MNEMONIC(SSE_PSIGNW,1369)
FD_MNEMONIC(SSE_PSLLD,1370)
FD_MNEMONIC(SSE_PSLLDQ,1371)
FD_MNEMONIC(SSE_PSLLQ,1372)
FD_MNEMONIC(SSE_PSLLW,1373)
FD_MNEMONIC(SSE_PSRAD,1374)
FD_MNEMONIC(SSE_PSRAW,1375)
FD_MNEMONIC(SSE_PSRLD,1376)
FD_MNEMONIC(SSE_PSRLDQ,1377)
FD_MNEMONIC(SSE_PSRLQ,1378)
FD_MNEMONIC(SSE_PSRLW,1379)
FD_MNEMONIC(SSE_PSUBB,1380)
FD_MNEMONIC(SSE_PSUBD,1381)
FD_MNEMONIC(SSE_PSUBQ,1382)
FD_MNEMONIC(SSE_PSUBSB,1383)
FD_MNEMONIC(SSE_PSUBSW,1384)
FD_MNEMONIC(SSE_PSUBUSB,1385)
FD_MNEMONIC(SSE_PSUBUSW,1386)
FD_MNEMONIC(SSE_PSUBW,1387)
FD_MNEMONIC(SSE_PTEST,1388)
FD_MNEMONIC(SSE_PUNPCKHBW,1389)
FD_MNEMONIC(SSE_PUNPCKHDQ,1390)
FD_MNEMONIC(SSE_PUNPCKHQDQ,1391)
FD_MNEMONIC(SSE_PUNPCKHWD,1392)
FD_MNEMONIC(SSE_PUNPCKLBW,1393)
FD_MNEMONIC(SSE_PUNPCKLDQ,1394)
FD_MNEMONIC(SSE_PUNPCKLQDQ,1395)
FD_MNEMONIC(SSE_PUNPCKLWD,1396)
FD_MNEMONIC(SSE_PXOR,1397)
FD_MNEMONIC(SSE_RCPPS,1398)
FD_MNEMONIC(SSE_RCPSS,1399)
FD_MNEMONIC(SSE_ROUNDPD,1400)
FD_MNEMONIC(SSE_ROUNDPS,1401)
FD_MNEMONIC(SSE_ROUNDSD,1402)
FD_MNEMONIC(SSE_ROUNDSS,1403)
FD_MNEMONIC(SSE_RSQRTPS,1404)
FD_MNEMONIC(SSE_RSQRTSS,1405)
FD_MNEMONIC(SSE_SHUFPD,1406)
FD_MNEMONIC(SSE_SHUFPS,1407)
FD_MNEMONIC(SSE_SQRTPD,1408)
FD_MNEMONIC(SSE_SQRTPS,1409)
FD_MNEMONIC(SSE_SQRTSD,1410)
FD_MNEMONIC(SSE_SQRTSS,1411)
FD_MNEMONIC(SSE_SUBPD,1412)
FD_MNEMONIC(SSE_SUBPS,1413)
FD_MNEMONIC(SSE_SUBSD,1414)
FD_MNEMONIC(SSE_SUBSS,1415)
FD_MNEMONIC(SSE_UCOMISD,1416)
FD_MNEMONIC(SSE_UCOMISS,1417)
FD_MNEMONIC(SSE_UNPCKHPD,1418)
FD_MNEMONIC(SSE_UNPCKHPS,1419)
FD_MNEMONIC(SSE_UNPCKLPD,1420)
FD_MNEMONIC(SSE_UNPCKLPS,1421)
FD_MNEMONIC(SSE_XORPD,1422)
FD_MNEMONIC(SSE_XORPS,1423)
FD_MNEMONIC(STAC,1424)
FD_MNEMONIC(STC,1425)
FD_MNEMONIC(STD,1426)
FD_MNEMONIC(STGI,1427)
FD_MNEMONIC(STI,1428)
FD_MNEMONIC(STMXCSR,1429)
FD_MNEMONIC(STOS,1430)
FD_MNEMONIC(STR,1431)
FD_MNEMONIC(STTILECFG,1432)
FD_MNEMONIC(STUI,1433)
FD_MNEMONIC(SUB,1434)
FD_MNEMONIC(SWAPGS,1435)
FD_MNEMONIC(SYSCALL,1436)
FD_MNEMONIC(SYSENTER,1437)
FD_MNEMONIC(SYSEXIT,1438)
FD_MNEMONIC(SYSRET,1439)
FD_MNEMONIC(TCMMIMFP16PS,1440)
FD_MNEMONIC(TCMMRLFP16PS,1441)
FD_MNEMONIC(TDCALL,1442)
FD_MNEMONIC(TDPBF16PS,1443)
FD_MNEMONIC(TDPBSSD,1444)
FD_MNEMONIC(TDPBSUD,1445)
FD_MNEMONIC(TDPBUSD,1446)
FD_MNEMONIC(TDPBUUD,1447)
FD_MNEMONIC(TDPFP16PS,1448)
FD_MNEMONIC(TEST,1449)
FD_MNEMONIC(TESTUI,1450)
FD_MNEMONIC(TILELOADD,1451)
FD_MNEMONIC(TILELOADDT1,1452)
FD_MNEMONIC(TILERELEASE,1453)
FD_MNEMONIC(TILESTORED,1454)
FD_MNEMONIC(TILEZERO,1455)
FD_MNEMONIC(TLBSYNC,1456)
FD_MNEMONIC(TPAUSE,1457)
FD_MNEMONIC(TZCNT,1458)
FD_MNEMONIC(UD0,1459)
FD_MNEMONIC(UD1,1460)
FD_MNEMONIC(UD2,1461)
FD_MNEMONIC(UIRET,1462)
FD_MNEMONIC(UMONITOR,1463)
FD_MNEMONIC(UMWAIT,1464)
FD_MNEMONIC(URDMSR,1465)
FD_MNEMONIC(UWRMSR,1466)
FD_MNEMONIC(VADDPD,1467)
FD_MNEMONIC(VADDPS,1468)
FD_MNEMONIC(VADDSD,1469)
FD_MNEMONIC(VADDSS,1470)
FD_MNEMONIC(VADDSUBPD,1471)
FD_MNEMONIC(VADDSUBPS,1472)
FD_MNEMONIC(VAESDEC,1473)
FD_MNEMONIC(VAESDECLAST,1474)
FD_MNEMONIC(VAESENC,1475)
FD_MNEMONIC(VAESENCLAST,1476)
FD_MNEMONIC(VAESIMC,1477)
FD_MNEMONIC(VAESKEYGENASSIST,1478)
FD_MNEMONIC(VANDNPD,1479)
FD_MNEMONIC(VANDNPS,1480)
FD_MNEMONIC(VANDPD,1481)
FD_MNEMONIC(VANDPS,1482)
FD_MNEMONIC(VBCSTNEBF162PS,1483)
FD_MNEMONIC(VBCSTNESH2PS,1484)
FD_MNEMONIC(VBLENDPD,1485)
FD_MNEMONIC(VBLENDPS,1486)
FD_MNEMONIC(VBLENDVPD,1487)
FD_MNEMONIC(VBLENDVPS,1488)
FD_MNEMONIC(VBROADCASTF128,1489)
FD_MNEMONIC(VBROADCASTI128,1490)
FD_MNEMONIC(VBROADCASTSD,1491)
FD_MNEMONIC(VBROADCASTSS,1492)
FD_MNEMONIC(VCMPPD,1493)
FD_MNEMONIC(VCMPPS,1494)
FD_MNEMONIC(VCMPSD,1495)
FD_MNEMONIC(VCMPSS,1496)
FD_MNEMONIC(VCOMISD,1497)
FD_MNEMONIC(VCOMISS,1498)
FD_MNEMONIC(VCVTDQ2PD,1499)
FD_MNEMONIC(VCVTDQ2PS,1500)
FD_MNEMONIC(VCVTNEEBF162PS,1501)
FD_MNEMONIC(VCVTNEEPH2PS,1502)
FD_MNEMONIC(VCVTNEOBF162PS,1503)
FD_MNEMONIC(VCVTNEOPH2PS,1504)
FD_MNEMONIC(VCVTNEPS2BF16,1505)
FD_MNEMONIC(VCVTPD2DQ,1506)
FD_MNEMONIC(VCVTPD2PS,1507)
FD_MNEMONIC(VCVTPH2PS,1508)
FD_MNEMONIC(VCVTPS2DQ,1509)
FD_MNEMONIC(VCVTPS2PD,1510)
FD_MNEMONIC(VCVTPS2PH,1511)
FD_MNEMONIC(VCVTSD2SI,1512)
FD_MNEMONIC(VCVTSD2SS,1513)
FD_MNEMONIC(VCVTSI2SD,1514)
FD_MNEMONIC(VCVTSI2SS,1515)
FD_MNEMONIC(VCVTSS2SD,1516)
FD_MNEMONIC(VCVTSS2SI,1517)
FD_MNEMONIC(VCVTTPD2DQ,1518)
FD_MNEMONIC(VCVTTPS2DQ,1519)
FD_MNEMONIC(VCVTTSD2SI,1520)
FD_MNEMONIC(VCVTTSS2SI,1521)
FD_MNEMONIC(VDIVPD,1522)
FD_MNEMONIC(VDIVPS,1523)
FD_MNEMONIC(VDIVSD,1524)
FD_MNEMONIC(VDIVSS,1525)
FD_MNEMONIC(VDPPD,1526)
FD_MNEMONIC(VDPPS,1527)
FD_MNEMONIC(VERR,1528)
FD_MNEMONIC(VERW,1529)
FD_MNEMONIC(VEXTRACTF128,1530)
FD_MNEMONIC(VEXTRACTI128,1531)
FD_MNEMONIC(VEXTRACTPS,1532)
FD_MNEMONIC(VFMADD132PD,1533)
FD_MNEMONIC(VFMADD132PS,1534)
FD_MNEMONIC(VFMADD132SD,1535)
FD_MNEMONIC(VFMADD132SS,1536)
FD_MNEMONIC(VFMADD213PD,1537)
FD_MNEMONIC(VFMADD213PS,1538)
FD_MNEMONIC(VFMADD213SD,1539)
FD_MNEMONIC(VFMADD213SS,1540)
FD_MNEMONIC(VFMADD231PD,1541)
FD_MNEMONIC(VFMADD231PS,1542)
FD_MNEMONIC(VFMADD231SD,1543)
FD_MNEMONIC(VFMADD231SS,1544)
FD_MNEMONIC(VFMADDSUB132PD,1545)
FD_MNEMONIC(VFMADDSUB132PS,1546)
FD_MNEMONIC(VFMADDSUB213PD,1547)
FD_MNEMONIC(VFMADDSUB213PS,1548)
FD_MNEMONIC(VFMADDSUB231PD,1549)
FD_MNEMONIC(VFMADDSUB231PS,1550)
FD_MNEMONIC(VFMSUB132PD,1551)
FD_MNEMONIC(VFMSUB132PS,1552)
FD_MNEMONIC(VFMSUB132SD,1553)
FD_MNEMONIC(VFMSUB132SS,1554)
FD_MNEMONIC(VFMSUB213PD,1555)
FD_MNEMONIC(VFMSUB213PS,1556)
FD_MNEMONIC(VFMSUB213SD,1557)
FD_MNEMONIC(VFMSUB213SS,1558)
FD_MNEMONIC(VFMSUB231PD,1559)
FD_MNEMONIC(VFMSUB231PS,1560)
FD_MNEMONIC(VFMSUB231SD,1561)
FD_MNEMONIC(VFMSUB231SS,1562)
FD_MNEMONIC(VFMSUBADD132PD,1563)
FD_MNEMONIC(VFMSUBADD132PS,1564)
FD_MNEMONIC(VFMSUBADD213PD,1565)
FD_MNEMONIC(VFMSUBADD213PS,1566)
FD_MNEMONIC(VFMSUBADD231PD,1567)
FD_MNEMONIC(VFMSUBADD231PS,1568)
FD_MNEMONIC(VFNMADD132PD,1569)
FD_MNEMONIC(VFNMADD132PS,1570)
FD_MNEMONIC(VFNMADD132SD,1571)
FD_MNEMONIC(VFNMADD132SS,1572)
FD_MNEMONIC(VFNMADD213PD,1573)
FD_MNEMONIC(VFNMADD213PS,1574)
FD_MNEMONIC(VFNMADD213SD,1575)
FD_MNEMONIC(VFNMADD213SS,1576)
FD_MNEMONIC(VFNMADD231PD,1577)
FD_MNEMONIC(VFNMADD231PS,1578)
FD_MNEMONIC(VFNMADD231SD,1579)
FD_MNEMONIC(VFNMADD231SS,1580)
FD_MNEMONIC(VFNMSUB132PD,1581)
FD_MNEMONIC(VFNMSUB132PS,1582)
FD_MNEMONIC(VFNMSUB132SD,1583)
FD_MNEMONIC(VFNMSUB132SS,1584)
FD_MNEMONIC(VFNMSUB213PD,1585)
FD_MNEMONIC(VFNMSUB213PS,1586)
FD_MNEMONIC(VFNMSUB213SD,1587)
FD_MNEMONIC(VFNMSUB213SS,1588)
FD_MNEMONIC(VFNMSUB231PD,1589)
FD_MNEMONIC(VFNMSUB231PS,1590)
FD_MNEMONIC(VFNMSUB231SD,1591)
FD_MNEMONIC(VFNMSUB231SS,1592)
FD_MNEMONIC(VGATHERDPD,1593)
FD_MNEMONIC(VGATHERDPS,1594)
FD_MNEMONIC(VGATHERQPD,1595)
FD_MNEMONIC(VGATHERQPS,1596)
FD_MNEMONIC(VGF2P8AFFINEINVQB,1597)
FD_MNEMONIC(VGF2P8AFFINEQB,1598)
FD_MNEMONIC(VGF2P8MULB,1599)
FD_MNEMONIC(VHADDPD,1600)
FD_MNEMONIC(VHADDPS,1601)
FD_MNEMONIC(VHSUBPD,1602)
FD_MNEMONIC(VHSUBPS,1603)
FD_MNEMONIC(VINSERTF128,1604)
FD_MNEMONIC(VINSERTI128,1605)
FD_MNEMONIC(VINSERTPS,1606)
FD_MNEMONIC(VLDDQU,1607)
FD_MNEMONIC(VLDMXCSR,1608)
FD_MNEMONIC(VMASKMOVDQU,1609)
FD_MNEMONIC(VMASKMOVPD,1610)
FD_MNEMONIC(VMASKMOVPS,1611)
FD_MNEMONIC(VMAXPD,1612)
FD_MNEMONIC(VMAXPS,1613)
FD_MNEMONIC(VMAXSD,1614)
FD_MNEMONIC(VMAXSS,1615)
FD_MNEMONIC(VMCALL,1616)
FD_MNEMONIC(VMCLEAR,1617)
FD_MNEMONIC(VMFUNC,1618)
FD_MNEMONIC(VMGEXIT,1619)
FD_MNEMONIC(VMINPD,1620)
FD_MNEMONIC(VMINPS,1621)
FD_MNEMONIC(VMINSD,1622)
FD_MNEMONIC(VMINSS,1623)
FD_MNEMONIC(VMLAUNCH,1624)
FD_MNEMONIC(VMLOAD,1625)
FD_MNEMONIC(VMMCALL,1626)
FD_MNEMONIC(VMOVAPD,1627)
FD_MNEMONIC(VMOVAPS,1628)
FD_MNEMONIC(VMOVD,1629)
FD_MNEMONIC(VMOVDDUP,1630)
FD_MNEMONIC(VMOVDQA,1631)
FD_MNEMONIC(VMOVDQU,1632)
FD_MNEMONIC(VMOVHLPS,1633)
FD_MNEMONIC(VMOVHPD,1634)
FD_MNEMONIC(VMOVHPS,1635)
FD_MNEMONIC(VMOVLHPS,1636)
FD_MNEMONIC(VMOVLPD,1637)
FD_MNEMONIC(VMOVLPS,1638)
FD_MNEMONIC(VMOVMSKPD,1639)
FD_MNEMONIC(VMOVMSKPS,1640)
FD_MNEMONIC(VMOVNTDQ,1641)
FD_MNEMONIC(VMOVNTDQA,1642)
FD_MNEMONIC(VMOVNTPD,1643)
FD_MNEMONIC(VMOVNTPS,1644)
FD_MNEMONIC(VMOVQ,1645)
FD_MNEMONIC(VMOVSD,1646)
FD_MNEMONIC(VMOVSHDUP,1647)
FD_MNEMONIC(VMOVSLDUP,1648)
FD_MNEMONIC(VMOVSS,1649)
FD_MNEMONIC(VMOVUPD,1650)
FD_MNEMONIC(VMOVUPS,1651)
FD_MNEMONIC(VMPSADBW,1652)
FD_MNEMONIC(VMPTRLD,1653)
FD_MNEMONIC(VMPTRST,1654)
FD_MNEMONIC(VMREAD,1655)
FD_MNEMONIC(VMRESUME,1656)
FD_MNEMONIC(VMRUN,1657)
FD_MNEMONIC(VMSAVE,1658)
FD_MNEMONIC(VMULPD,1659)
FD_MNEMONIC(VMULPS,1660)
FD_MNEMONIC(VMULSD,1661)
FD_MNEMONIC(VMULSS,1662)
FD_MNEMONIC(VMWRITE,1663)
FD_MNEMONIC(VMXOFF,1664)
FD_MNEMONIC(VMXON,1665)
FD_MNEMONIC(VORPD,1666)
FD_MNEMONIC(VORPS,1667)
FD_MNEMONIC(VPABSB,1668)
FD_MNEMONIC(VPABSD,1669)
FD_MNEMONIC(VPABSW,1670)
FD_MNEMONIC(VPACKSSDW,1671)
FD_MNEMONIC(VPACKSSWB,1672)
FD_MNEMONIC(VPACKUSDW,1673)
FD_MNEMONIC(VPACKUSWB,1674)
FD_MNEMONIC(VPADDB,1675)
FD_MNEMONIC(VPADDD,1676)
FD_MNEMONIC(VPADDQ,1677)
FD_MNEMONIC(VPADDSB,1678)
FD_MNEMONIC(VPADDSW,1679)
FD_MNEMONIC(VPADDUSB,1680)
FD_MNEMONIC(VPADDUSW,1681)
FD_MNEMONIC(VPADDW,1682)
FD_MNEMONIC(VPALIGNR,1683)
FD_MNEMONIC(VPAND,1684)
FD_MNEMONIC(VPANDN,1685)
FD_MNEMONIC(VPAVGB,1686)
FD_MNEMONIC(VPAVGW,1687)
FD_MNEMONIC(VPBLENDD,1688)
FD_MNEMONIC(VPBLENDVB,1689)
FD_MNEMONIC(VPBLENDW,1690)
FD_MNEMONIC(VPBROADCASTB,1691)
FD_MNEMONIC(VPBROADCASTD,1692)
FD_MNEMONIC(VPBROADCASTQ,1693)
FD_MNEMONIC(VPBROADCASTW,1694)
FD_MNEMONIC(VPCLMULQDQ,1695)
FD_MNEMONIC(VPCMPEQB,1696)
FD_MNEMONIC(VPCMPEQD,1697)
FD_MNEMONIC(VPCMPEQQ,1698)
FD_MNEMONIC(VPCMPEQW,1699)
FD_MNEMONIC(VPCMPESTRI,1700)
FD_MNEMONIC(VPCMPESTRM,1701)
FD_MNEMONIC(VPCMPGTB,1702)
FD_MNEMONIC(VPCMPGTD,1703)
FD_MNEMONIC(VPCMPGTQ,1704)
FD_MNEMONIC(VPCMPGTW,1705)
FD_MNEMONIC(VPCMPISTRI,1706)
FD_MNEMONIC(VPCMPISTRM,1707)
FD_MNEMONIC(VPDPBSSD,1708)
FD_MNEMONIC(VPDPBSSDS,1709)
FD_MNEMONIC(VPDPBSUD,1710)
FD_MNEMONIC(VPDPBSUDS,1711)
FD_MNEMONIC(VPDPBUSD,1712)
FD_MNEMONIC(VPDPBUSDS,1713)
FD_MNEMONIC(VPDPBUUD,1714)
FD_MNEMONIC(VPDPBUUDS,1715)
FD_MNEMONIC(VPDPWSSD,1716)
FD_MNEMONIC(VPDPWSSDS,1717)
FD_MNEMONIC(VPERM2F128,1718)
FD_MNEMONIC(VPERM2I128,1719)
FD_MNEMONIC(VPERMD,1720)
FD_MNEMONIC(VPERMILPD,1721)
FD_MNEMONIC(VPERMILPS,1722)
FD_MNEMONIC(VPERMPD,1723)
FD_MNEMONIC(VPERMPS,1724)
FD_MNEMONIC(VPERMQ,1725)
FD_MNEMONIC(VPEXTRB,1726)
FD_MNEMONIC(VPEXTRD,1727)
FD_MNEMONIC(VPEXTRQ,1728)
FD_MNEMONIC(VPEXTRW,1729)
FD_MNEMONIC(VPGATHERDD,1730)
FD_MNEMONIC(VPGATHERDQ,1731)
FD_MNEMONIC(VPGATHERQD,1732)
FD_MNEMONIC(VPGATHERQQ,1733)
FD_MNEMONIC(VPHADDD,1734)
FD_MNEMONIC(VPHADDSW,1735)
FD_MNEMONIC(VPHADDW,1736)
FD_MNEMONIC(VPHMINPOSUW,1737)
FD_MNEMONIC(VPHSUBD,1738)
FD_MNEMONIC(VPHSUBSW,1739)
FD_MNEMONIC(VPHSUBW,1740)
FD_MNEMONIC(VPINSRB,1741)
FD_MNEMONIC(VPINSRD,1742)
FD_MNEMONIC(VPINSRQ,1743)
FD_MNEMONIC(VPINSRW,1744)
FD_MNEMONIC(VPMADD52HUQ,1745)
FD_MNEMONIC(VPMADD52LUQ,1746)
FD_MNEMONIC(VPMADDUBSW,1747)
FD_MNEMONIC(VPMADDWD,1748)
FD_MNEMONIC(VPMASKMOVD,1749)
FD_MNEMONIC(VPMASKMOVQ,1750)
FD_MNEMONIC(VPMAXSB,1751)
FD_MNEMONIC(VPMAXSD,1752)
FD_MNEMONIC(VPMAXSW,1753)
FD_MNEMONIC(VPMAXUB,1754)
FD_MNEMONIC(VPMAXUD,1755)
FD_MNEMONIC(VPMAXUW,1756)
FD_MNEMONIC(VPMINSB,1757)
FD_MNEMONIC(VPMINSD,1758)
FD_MNEMONIC(VPMINSW,1759)
FD_MNEMONIC(VPMINUB,1760)
FD_MNEMONIC(VPMINUD,1761)
FD_MNEMONIC(VPMINUW,1762)
FD_MNEMONIC(VPMOVMSKB,1763)
FD_MNEMONIC(VPMOVSXBD,1764)
FD_MNEMONIC(VPMOVSXBQ,1765)
FD_MNEMONIC(VPMOVSXBW,1766)
FD_MNEMONIC(VPMOVSXDQ,1767)
FD_MNEMONIC(VPMOVSXWD,1768)
FD_MNEMONIC(VPMOVSXWQ,1769)
FD_MNEMONIC(VPMOVZXBD,1770)
FD_MNEMONIC(VPMOVZXBQ,1771)
FD_MNEMONIC(VPMOVZXBW,1772)
FD_MNEMONIC(VPMOVZXDQ,1773)
FD_MNEMONIC(VPMOVZXWD,1774)
FD_MNEMONIC(VPMOVZXWQ,1775)
FD_MNEMONIC(VPMULDQ,1776)
FD_MNEMONIC(VPMULHRSW,1777)
FD_MNEMONIC(VPMULHUW,1778)
FD_MNEMONIC(VPMULHW,1779)
FD_MNEMONIC(VPMULLD,1780)
FD_MNEMONIC(VPMULLW,1781)
FD_MNEMONIC(VPMULUDQ,1782)
FD_MNEMONIC(VPOR,1783)
FD_MNEMONIC(VPSADBW,1784)
FD_MNEMONIC(VPSHUFB,1785)
FD_MNEMONIC(VPSHUFD,1786)
FD_MNEMONIC(VPSHUFHW,1787)
FD_MNEMONIC(VPSHUFLW,1788)
FD_MNEMONIC(VPSIGNB,1789)
FD_MNEMONIC(VPSIGND,1790)
FD_MNEMONIC(VPSIGNW,1791)
FD_MNEMONIC(VPSLLD,1792)
FD_MNEMONIC(VPSLLDQ,1793)
FD_MNEMONIC(VPSLLQ,1794)
FD_MNEMONIC(VPSLLVD,1795)
FD_MNEMONIC(VPSLLVQ,1796)
FD_MNEMONIC(VPSLLW,1797)
FD_MNEMONIC(VPSRAD,1798)
FD_MNEMONIC(VPSRAVD,1799)
FD_MNEMONIC(VPSRAW,1800)
FD_MNEMONIC(VPSRLD,1801)
FD_MNEMONIC(VPSRLDQ,1802)
FD_MNEMONIC(VPSRLQ,1803)
FD_MNEMONIC(VPSRLVD,1804)
FD_MNEMONIC(VPSRLVQ,1805)
FD_MNEMONIC(VPSRLW,1806)
FD_MNEMONIC(VPSUBB,1807)
FD_MNEMONIC(VPSUBD,1808)
FD_MNEMONIC(VPSUBQ,1809)
FD_MNEMONIC(VPSUBSB,1810)
FD_MNEMONIC(VPSUBSW,1811)
FD_MNEMONIC(VPSUBUSB,1812)
FD_MNEMONIC(VPSUBUSW,1813)
FD_MNEMONIC(VPSUBW,1814)
FD_MNEMONIC(VPTEST,1815)
FD_MNEMONIC(VPUNPCKHBW,1816)
FD_MNEMONIC(VPUNPCKHDQ,1817)
FD_MNEMONIC(VPUNPCKHQDQ,1818)
FD_MNEMONIC(VPUNPCKHWD,1819)
FD_MNEMONIC(VPUNPCKLBW,1820)
FD_MNEMONIC(VPUNPCKLDQ,1821)
FD_MNEMONIC(VPUNPCKLQDQ,1822)
FD_MNEMONIC(VPUNPCKLWD,1823)
FD_MNEMONIC(VPXOR,1824)
FD_MNEMONIC(VRCPPS,1825)
FD_MNEMONIC(VRCPSS,1826)
FD_MNEMONIC(VROUNDPD,1827)
FD_MNEMONIC(VROUNDPS,1828)
FD_MNEMONIC(VROUNDSD,1829)
FD_MNEMONIC(VROUNDSS,1830)
FD_MNEMONIC(VRSQRTPS,1831)
FD_MNEMONIC(VRSQRTSS,1832)
FD_MNEMONIC(VSHUFPD,1833)
FD_MNEMONIC(VSHUFPS,1834)
FD_MNEMONIC(VSM4KEY4,1835)
FD_MNEMONIC(VSM4RNDS4,1836)
FD_MNEMONIC(VSQRTPD,1837)
FD_MNEMONIC(VSQRTPS,1838)
FD_MNEMONIC(VSQRTSD,1839)
FD_MNEMONIC(VSQRTSS,1840)
FD_MNEMONIC(VSTMXCSR,1841)
FD_MNEMONIC(VSUBPD,1842)
FD_MNEMONIC(VSUBPS,1843)
FD_MNEMONIC(VSUBSD,1844)
FD_MNEMONIC(VSUBSS,1845)
FD_MNEMONIC(VTESTPD,1846)
FD_MNEMONIC(VTESTPS,1847)
FD_MNEMONIC(VUCOMISD,1848)
FD_MNEMONIC(VUCOMISS,1849)
FD_MNEMONIC(VUNPCKHPD,1850)
FD_MNEMONIC(VUNPCKHPS,1851)
FD_MNEMONIC(VUNPCKLPD,1852)
FD_MNEMONIC(VUNPCKLPS,1853)
FD_MNEMONIC(VXORPD,1854)
FD_MNEMONIC(VXORPS,1855)
FD_MNEMONIC(VZEROALL,1856)
FD_MNEMONIC(VZEROUPPER,1857)
FD_MNEMONIC(WBINVD,1858)
FD_MNEMONIC(WBNOINVD,1859)
FD_MNEMONIC(WRFSBASE,1860)
FD_MNEMONIC(WRGSBASE,1861)
FD_MNEMONIC(WRMSR,1862)
FD_MNEMONIC(WRMSRLIST,1863)
FD_MNEMONIC(WRMSRNS,1864)
FD_MNEMONIC(WRPKRU,1865)
FD_MNEMONIC(WRSS,1866)
FD_MNEMONIC(WRUSS,1867)
FD_MNEMONIC(XABORT,1868)
FD_MNEMONIC(XADD,1869)
FD_MNEMONIC(XBEGIN,1870)
FD_MNEMONIC(XCHG,1871)
FD_MNEMONIC(XCHG_NOP,1872)
FD_MNEMONIC(XEND,1873)
FD_MNEMONIC(XGETBV,1874)
FD_MNEMONIC(XLATB,1875)
FD_MNEMONIC(XOR,1876)
FD_MNEMONIC(XRESLDTRK,1877)
FD_MNEMONIC(XRSTOR,1878)
FD_MNEMONIC(XRSTORS,1879)
FD_MNEMONIC(XSAVE,1880)
FD_MNEMONIC(XSAVEC,1881)
FD_MNEMONIC(XSAVEOPT,1882)
FD_MNEMONIC(XSAVES,1883)
FD_MNEMONIC(XSETBV,1884)
FD_MNEMONIC(XSTORE,1885)
FD_MNEMONIC(XSUSLDTRK,1886)
FD_MNEMONIC(XTEST,1887)

```

`third_party/fadec/fadec-enc.h`:

```h

#ifndef FD_FADEC_ENC_H_
#define FD_FADEC_ENC_H_

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    FE_AX = 0x100, FE_CX, FE_DX, FE_BX, FE_SP, FE_BP, FE_SI, FE_DI,
    FE_R8, FE_R9, FE_R10, FE_R11, FE_R12, FE_R13, FE_R14, FE_R15,
    FE_IP = 0x120,
    FE_AH = 0x204, FE_CH, FE_DH, FE_BH,
    FE_ES = 0x300, FE_CS, FE_SS, FE_DS, FE_FS, FE_GS,
    FE_ST0 = 0x400, FE_ST1, FE_ST2, FE_ST3, FE_ST4, FE_ST5, FE_ST6, FE_ST7,
    FE_MM0 = 0x500, FE_MM1, FE_MM2, FE_MM3, FE_MM4, FE_MM5, FE_MM6, FE_MM7,
    FE_XMM0 = 0x600, FE_XMM1, FE_XMM2, FE_XMM3, FE_XMM4, FE_XMM5, FE_XMM6, FE_XMM7,
    FE_XMM8, FE_XMM9, FE_XMM10, FE_XMM11, FE_XMM12, FE_XMM13, FE_XMM14, FE_XMM15,
    FE_XMM16, FE_XMM17, FE_XMM18, FE_XMM19, FE_XMM20, FE_XMM21, FE_XMM22, FE_XMM23,
    FE_XMM24, FE_XMM25, FE_XMM26, FE_XMM27, FE_XMM28, FE_XMM29, FE_XMM30, FE_XMM31,
    FE_K0 = 0x700, FE_K1, FE_K2, FE_K3, FE_K4, FE_K5, FE_K6, FE_K7,
    FE_TMM0 = 0x800, FE_TMM1, FE_TMM2, FE_TMM3, FE_TMM4, FE_TMM5, FE_TMM6, FE_TMM7,
} FeReg;

typedef int64_t FeOp;

/** Construct a memory operand. Unused parts can be set to 0 and will be
 * ignored. FE_IP can be used as base register, in which case the offset is
 * interpreted as the offset from the /current/ position -- the size of the
 * encoded instruction will be subtracted during encoding. scale must be 1, 2,
 * 4, or 8; but is ignored if  idx == 0. **/
#define FE_MEM(base,sc,idx,off) (INT64_MIN | ((int64_t) ((base) & 0xfff) << 32) | ((int64_t) ((idx) & 0xfff) << 44) | ((int64_t) ((sc) & 0xf) << 56) | ((off) & 0xffffffff))
#define FE_NOREG ((FeReg) 0)

/** Add segment override prefix. This may or may not generate prefixes for the
 * ignored prefixes ES/CS/DS/SS in 64-bit mode. **/
#define FE_SEG(seg) ((uint64_t) (((seg) & 0x7) + 1) << 29)
/** Do not use. **/
#define FE_SEG_MASK 0xe0000000
/** Overrides address size. **/
#define FE_ADDR32 0x10000000
/** Used together with a RIP-relative (conditional) jump, this will force the
 * use of the encoding with the largest distance. Useful for reserving a jump
 * when the target offset is still unknown; if the jump is re-encoded later on,
 * FE_JMPL must be specified there, too, so that the encoding lengths match. **/
#define FE_JMPL 0x100000000
#define FE_MASK(kreg) ((uint64_t) ((kreg) & 0x7) << 33)
#define FE_RC_RN 0x0000000
#define FE_RC_RD 0x0800000
#define FE_RC_RU 0x1000000
#define FE_RC_RZ 0x1800000

enum {
    FE_CC_O = 0x0,
    FE_CC_NO = 0x1,
    FE_CC_C = 0x2,
    FE_CC_B = FE_CC_C,
    FE_CC_NAE = FE_CC_C,
    FE_CC_NC = 0x3,
    FE_CC_AE = FE_CC_NC,
    FE_CC_NB = FE_CC_NC,
    FE_CC_Z = 0x4,
    FE_CC_E = FE_CC_Z,
    FE_CC_NZ = 0x5,
    FE_CC_NE = FE_CC_NZ,
    FE_CC_BE = 0x6,
    FE_CC_NA = FE_CC_BE,
    FE_CC_A = 0x7,
    FE_CC_NBE = FE_CC_A,
    FE_CC_S = 0x8,
    FE_CC_NS = 0x9,
    FE_CC_P = 0xa,
    FE_CC_PE = FE_CC_P,
    FE_CC_NP = 0xb,
    FE_CC_PO = FE_CC_NP,
    FE_CC_L = 0xc,
    FE_CC_NGE = FE_CC_L,
    FE_CC_GE = 0xd,
    FE_CC_NL = FE_CC_GE,
    FE_CC_LE = 0xe,
    FE_CC_NG = FE_CC_LE,
    FE_CC_G = 0xf,
    FE_CC_NLE = FE_CC_G,
};

#include <fadec-encode-public.inc>

/** Do not use. **/
#define fe_enc64_1(buf, mnem, op0, op1, op2, op3, ...) fe_enc64_impl(buf, mnem, op0, op1, op2, op3)
/** Encode a single instruction for 64-bit mode.
 * \param buf Pointer to the buffer for instruction bytes, must have a size of
 *        15 bytes. The pointer is advanced by the number of bytes used for
 *        encoding the specified instruction.
 * \param mnem Mnemonic, optionally or-ed with FE_SEG(), FE_ADDR32, or FE_JMPL.
 * \param operands... Instruction operands. Immediate operands are passed as
 *        plain value; register operands using the FeReg enum; memory operands
 *        using FE_MEM(); and offset operands for RIP-relative jumps/calls are
 *        specified as _address in buf_, e.g. (intptr_t) jmptgt, the address of
 *        buf and the size of the encoded instruction are subtracted internally.
 * \return Zero for success or a negative value in case of an error.
 **/
#define fe_enc64(buf, ...) fe_enc64_1(buf, __VA_ARGS__, 0, 0, 0, 0, 0)
/** Do not use. **/
int fe_enc64_impl(uint8_t** buf, uint64_t mnem, FeOp op0, FeOp op1, FeOp op2, FeOp op3);

#ifdef __cplusplus
}
#endif

#endif

```

`third_party/fadec/fadec-enc2.h`:

```h

#ifndef FD_FADEC_ENC2_H_
#define FD_FADEC_ENC2_H_

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
#define FE_STRUCT(name) name
#else
#define FE_STRUCT(name) (name)
#endif

// Flags
#define FE_JMPL 0x8
#define FE_ADDR32 0x10
#define FE_SEG_MASK 0x7
#define FE_SEG(seg) (((seg).idx + 1) & FE_SEG_MASK)
#define FE_RC_MASK 0x60
#define FE_RC_RN 0x00
#define FE_RC_RD 0x20
#define FE_RC_RU 0x40
#define FE_RC_RZ 0x60

// Condition codes
typedef enum FeCond {
    FE_CC_O = 0x00000,
    FE_CC_NO = 0x10000,
    FE_CC_C = 0x20000,
    FE_CC_B = FE_CC_C,
    FE_CC_NAE = FE_CC_C,
    FE_CC_NC = 0x30000,
    FE_CC_AE = FE_CC_NC,
    FE_CC_NB = FE_CC_NC,
    FE_CC_Z = 0x40000,
    FE_CC_E = FE_CC_Z,
    FE_CC_NZ = 0x50000,
    FE_CC_NE = FE_CC_NZ,
    FE_CC_BE = 0x60000,
    FE_CC_NA = FE_CC_BE,
    FE_CC_A = 0x70000,
    FE_CC_NBE = FE_CC_A,
    FE_CC_S = 0x80000,
    FE_CC_NS = 0x90000,
    FE_CC_P = 0xa0000,
    FE_CC_PE = FE_CC_P,
    FE_CC_NP = 0xb0000,
    FE_CC_PO = FE_CC_NP,
    FE_CC_L = 0xc0000,
    FE_CC_NGE = FE_CC_L,
    FE_CC_GE = 0xd0000,
    FE_CC_NL = FE_CC_GE,
    FE_CC_LE = 0xe0000,
    FE_CC_NG = FE_CC_LE,
    FE_CC_G = 0xf0000,
    FE_CC_NLE = FE_CC_G,

    FE_CC_MASK = 0xf0000
} FeCond;

typedef struct FeRegGP { unsigned char idx; } FeRegGP;
#define FE_GP(idx) (FE_STRUCT(FeRegGP) { idx })
#define FE_AX FE_GP(0)
#define FE_CX FE_GP(1)
#define FE_DX FE_GP(2)
#define FE_BX FE_GP(3)
#define FE_SP FE_GP(4)
#define FE_BP FE_GP(5)
#define FE_SI FE_GP(6)
#define FE_DI FE_GP(7)
#define FE_R8 FE_GP(8)
#define FE_R9 FE_GP(9)
#define FE_R10 FE_GP(10)
#define FE_R11 FE_GP(11)
#define FE_R12 FE_GP(12)
#define FE_R13 FE_GP(13)
#define FE_R14 FE_GP(14)
#define FE_R15 FE_GP(15)
#define FE_IP FE_GP(0x20)
#define FE_NOREG FE_GP(0x80)
typedef struct FeRegGPH { unsigned char idx; } FeRegGPH;
#define FE_GPH(idx) (FE_STRUCT(FeRegGPH) { idx })
#define FE_AH FE_GPH(4)
#define FE_CH FE_GPH(5)
#define FE_DH FE_GPH(6)
#define FE_BH FE_GPH(7)
typedef struct FeRegSREG { unsigned char idx; } FeRegSREG;
#define FE_SREG(idx) (FE_STRUCT(FeRegSREG) { idx })
#define FE_ES FE_SREG(0)
#define FE_CS FE_SREG(1)
#define FE_SS FE_SREG(2)
#define FE_DS FE_SREG(3)
#define FE_FS FE_SREG(4)
#define FE_GS FE_SREG(5)
typedef struct FeRegST { unsigned char idx; } FeRegST;
#define FE_ST(idx) (FE_STRUCT(FeRegST) { idx })
#define FE_ST0 FE_ST(0)
#define FE_ST1 FE_ST(1)
#define FE_ST2 FE_ST(2)
#define FE_ST3 FE_ST(3)
#define FE_ST4 FE_ST(4)
#define FE_ST5 FE_ST(5)
#define FE_ST6 FE_ST(6)
#define FE_ST7 FE_ST(7)
typedef struct FeRegMM { unsigned char idx; } FeRegMM;
#define FE_MM(idx) (FE_STRUCT(FeRegMM) { idx })
#define FE_MM0 FE_MM(0)
#define FE_MM1 FE_MM(1)
#define FE_MM2 FE_MM(2)
#define FE_MM3 FE_MM(3)
#define FE_MM4 FE_MM(4)
#define FE_MM5 FE_MM(5)
#define FE_MM6 FE_MM(6)
#define FE_MM7 FE_MM(7)
typedef struct FeRegXMM { unsigned char idx; } FeRegXMM;
#define FE_XMM(idx) (FE_STRUCT(FeRegXMM) { idx })
#define FE_XMM0 FE_XMM(0)
#define FE_XMM1 FE_XMM(1)
#define FE_XMM2 FE_XMM(2)
#define FE_XMM3 FE_XMM(3)
#define FE_XMM4 FE_XMM(4)
#define FE_XMM5 FE_XMM(5)
#define FE_XMM6 FE_XMM(6)
#define FE_XMM7 FE_XMM(7)
#define FE_XMM8 FE_XMM(8)
#define FE_XMM9 FE_XMM(9)
#define FE_XMM10 FE_XMM(10)
#define FE_XMM11 FE_XMM(11)
#define FE_XMM12 FE_XMM(12)
#define FE_XMM13 FE_XMM(13)
#define FE_XMM14 FE_XMM(14)
#define FE_XMM15 FE_XMM(15)
#define FE_XMM16 FE_XMM(16)
#define FE_XMM17 FE_XMM(17)
#define FE_XMM18 FE_XMM(18)
#define FE_XMM19 FE_XMM(19)
#define FE_XMM20 FE_XMM(20)
#define FE_XMM21 FE_XMM(21)
#define FE_XMM22 FE_XMM(22)
#define FE_XMM23 FE_XMM(23)
#define FE_XMM24 FE_XMM(24)
#define FE_XMM25 FE_XMM(25)
#define FE_XMM26 FE_XMM(26)
#define FE_XMM27 FE_XMM(27)
#define FE_XMM28 FE_XMM(28)
#define FE_XMM29 FE_XMM(29)
#define FE_XMM30 FE_XMM(30)
#define FE_XMM31 FE_XMM(31)
typedef struct FeRegMASK { unsigned char idx; } FeRegMASK;
#define FE_K(idx) (FE_STRUCT(FeRegMASK) { idx })
#define FE_K0 FE_K(0)
#define FE_K1 FE_K(1)
#define FE_K2 FE_K(2)
#define FE_K3 FE_K(3)
#define FE_K4 FE_K(4)
#define FE_K5 FE_K(5)
#define FE_K6 FE_K(6)
#define FE_K7 FE_K(7)
typedef struct FeRegTMM { unsigned char idx; } FeRegTMM;
#define FE_TMM(idx) (FE_STRUCT(FeRegTMM) { idx })
#define FE_TMM0 FE_TMM(0)
#define FE_TMM1 FE_TMM(1)
#define FE_TMM2 FE_TMM(2)
#define FE_TMM3 FE_TMM(3)
#define FE_TMM4 FE_TMM(4)
#define FE_TMM5 FE_TMM(5)
#define FE_TMM6 FE_TMM(6)
#define FE_TMM7 FE_TMM(7)
typedef struct FeRegCR { unsigned char idx; } FeRegCR;
#define FE_CR(idx) (FE_STRUCT(FeRegCR) { idx })
typedef struct FeRegDR { unsigned char idx; } FeRegDR;
#define FE_DR(idx) (FE_STRUCT(FeRegDR) { idx })

// Internal only
// Disambiguate GP and GPH -- C++ uses conversion constructors; C uses _Generic.
#ifdef __cplusplus
}
namespace {
    struct FeRegGPLH {
        unsigned char idx;
        FeRegGPLH(FeRegGP gp) : idx(gp.idx) {}
        FeRegGPLH(FeRegGPH gp) : idx(gp.idx | 0x20) {}
    };
}
extern "C" {
#define FE_MAKE_GPLH(reg) reg
#else
typedef struct FeRegGPLH { unsigned char idx; } FeRegGPLH;
#define FE_GPLH(idx) (FE_STRUCT(FeRegGPLH) { idx })
#define FE_MAKE_GPLH(reg) FE_GPLH(_Generic((reg), FeRegGPH: 0x20, FeRegGP: 0) | (reg).idx)
#endif

typedef struct FeMem {
    uint8_t flags;
    FeRegGP base;
    unsigned char scale;
    // union {
        FeRegGP idx;
    //     FeRegXMM idx_xmm;
    // };
    int32_t off;
} FeMem;
#define FE_MEM(base,sc,idx,off) (FE_STRUCT(FeMem) { 0, base, sc, idx, off })
typedef struct FeMemV {
    uint8_t flags;
    FeRegGP base;
    unsigned char scale;
    FeRegXMM idx;
    int32_t off;
} FeMemV;
#define FE_MEMV(base,sc,idx,off) (FE_STRUCT(FeMemV) { 0, base, sc, idx, off })

// NOP is special: flags is interpreted as the length in bytes, 0 = 1 byte, too.
unsigned fe64_NOP(uint8_t* buf, unsigned flags);

#include <fadec-encode2-public.inc>

#ifdef __cplusplus
}
#endif

#endif

```

`third_party/fadec/fadec.h`:

```h

#ifndef FD_FADEC_H_
#define FD_FADEC_H_

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    FD_REG_R0 = 0, FD_REG_R1, FD_REG_R2, FD_REG_R3,
    FD_REG_R4, FD_REG_R5, FD_REG_R6, FD_REG_R7,
    FD_REG_R8, FD_REG_R9, FD_REG_R10, FD_REG_R11,
    FD_REG_R12, FD_REG_R13, FD_REG_R14, FD_REG_R15,
    // Alternative names for byte registers
    FD_REG_AL = 0, FD_REG_CL, FD_REG_DL, FD_REG_BL,
    FD_REG_AH, FD_REG_CH, FD_REG_DH, FD_REG_BH,
    // Alternative names for general purpose registers
    FD_REG_AX = 0, FD_REG_CX, FD_REG_DX, FD_REG_BX,
    FD_REG_SP, FD_REG_BP, FD_REG_SI, FD_REG_DI,
    // FD_REG_IP can only be accessed in long mode (64-bit)
    FD_REG_IP = 0x10,
    // Segment register values
    FD_REG_ES = 0, FD_REG_CS, FD_REG_SS, FD_REG_DS, FD_REG_FS, FD_REG_GS,
    // No register specified
    FD_REG_NONE = 0x3f
} FdReg;

typedef enum {
#define FD_MNEMONIC(name,value) FDI_ ## name = value,
#include <fadec-decode-public.inc>
#undef FD_MNEMONIC
} FdInstrType;

/** Internal use only. **/
enum {
    FD_FLAG_LOCK = 1 << 0,
    FD_FLAG_REP = 1 << 2,
    FD_FLAG_REPNZ = 1 << 1,
    FD_FLAG_64 = 1 << 7,
};

/** Operand types. **/
typedef enum {
    FD_OT_NONE = 0,
    FD_OT_REG = 1,
    FD_OT_IMM = 2,
    FD_OT_MEM = 3,
    FD_OT_OFF = 4,
    FD_OT_MEMBCST = 5,
} FdOpType;

typedef enum {
    /** Vector (SSE/AVX) register XMMn/YMMn/ZMMn **/
    FD_RT_VEC = 0,
    /** Low general purpose register **/
    FD_RT_GPL = 1,
    /** High-byte general purpose register **/
    FD_RT_GPH = 2,
    /** Segment register **/
    FD_RT_SEG = 3,
    /** FPU register ST(n) **/
    FD_RT_FPU = 4,
    /** MMX register MMn **/
    FD_RT_MMX = 5,
    /** TMM register TMMn **/
    FD_RT_TMM = 6,
    /** Vector mask (AVX-512) register Kn **/
    FD_RT_MASK = 7,
    /** Bound register BNDn **/
    FD_RT_BND = 8,
    /** Control Register CRn **/
    FD_RT_CR = 9,
    /** Debug Register DRn **/
    FD_RT_DR = 10,
    /** Must be a memory operand **/
    FD_RT_MEM = 15,
} FdRegType;

/** Do not depend on the actual enum values. **/
typedef enum {
    /** Round to nearest (even) **/
    FD_RC_RN = 1,
    /** Round down **/
    FD_RC_RD = 3,
    /** Round up **/
    FD_RC_RU = 5,
    /** Round to zero (truncate) **/
    FD_RC_RZ = 7,
    /** Rounding mode as specified in MXCSR **/
    FD_RC_MXCSR = 0,
    /** Rounding mode irrelevant, but SAE **/
    FD_RC_SAE = 6,
} FdRoundControl;

/** Internal use only. **/
typedef struct {
    uint8_t type;
    uint8_t size;
    uint8_t reg;
    uint8_t misc;
} FdOp;

/** Never(!) access struct fields directly. Use the macros defined below. **/
typedef struct {
    uint16_t type;
    uint8_t flags;
    uint8_t segment;
    uint8_t addrsz;
    uint8_t operandsz;
    uint8_t size;
    uint8_t evex;

    FdOp operands[4];

    int64_t disp;
    int64_t imm;

    uint64_t address;
} FdInstr;

typedef enum {
    FD_ERR_UD = -1,
    FD_ERR_INTERNAL = -2,
    FD_ERR_PARTIAL = -3,
} FdErr;


/** Decode an instruction.
 * \param buf Buffer for instruction bytes.
 * \param len Length of the buffer (in bytes). An instruction is not longer than
 *        15 bytes on all x86 architectures.
 * \param mode Decoding mode, either 32 for protected/compatibility mode or 64
 *        for long mode. 16-bit mode is not supported.
 * \param address Virtual address where the decoded instruction. This is used
 *        for computing jump targets. If "0" is passed, operands which require
 *        adding EIP/RIP will be stored as FD_OT_OFF operands.
 *        DEPRECATED: Strongly prefer passing 0 and using FD_OT_OFF operands.
 * \param out_instr Pointer to the instruction buffer. Note that this may get
 *        partially written even if an error is returned.
 * \return The number of bytes consumed by the instruction, or a negative number
 *         indicating an error.
 **/
int fd_decode(const uint8_t* buf, size_t len, int mode, uintptr_t address,
              FdInstr* out_instr);

/** Format an instruction to a string.
 * \param instr The instruction.
 * \param buf The buffer to hold the formatted string.
 * \param len The length of the buffer.
 **/
void fd_format(const FdInstr* instr, char* buf, size_t len);

/** Format an instruction to a string.
 * NOTE: API stability is currently not guaranteed for this function; its name
 * and/or signature may change in future.
 *
 * \param instr The instruction.
 * \param addr The base address to use for printing FD_OT_OFF operands.
 * \param buf The buffer to hold the formatted string.
 * \param len The length of the buffer.
 **/
void fd_format_abs(const FdInstr* instr, uint64_t addr, char* buf, size_t len);

/** Get the stringified name of an instruction type.
 * NOTE: API stability is currently not guaranteed for this function; changes
 * to the signature and/or the returned string can be expected. E.g., a future
 * version may take an extra parameter for the instruction operand size; or may
 * take a complete decoded instruction as first parameter and return the
 * mnemonic returned by fd_format.
 *
 * \param ty An instruction type
 * \return The instruction type as string, or "(invalid)".
 **/
const char* fdi_name(FdInstrType ty);


/** Gets the type/mnemonic of the instruction.
 * ABI STABILITY NOTE: different versions or builds of the library may use
 * different values. When linking as shared library, any interpretation of this
 * value is meaningless; in such cases use  fdi_name.
 *
 * API STABILITY NOTE: a future version of this library may decode string
 * instructions prefixed with REP/REPNZ and instructions prefixed with LOCK as
 * separate instruction types. **/
#define FD_TYPE(instr) ((FdInstrType) (instr)->type)
/** DEPRECATED: This functionality is obsolete in favor of FD_OT_OFF.
 * Gets the address of the instruction. Invalid if decoded  address == 0. **/
#define FD_ADDRESS(instr) ((instr)->address)
/** Gets the size of the instruction in bytes. **/
#define FD_SIZE(instr) ((instr)->size)
/** Gets the specified segment override, or FD_REG_NONE for default segment. **/
#define FD_SEGMENT(instr) ((FdReg) (instr)->segment & 0x3f)
/** Gets the address size attribute of the instruction in bytes. **/
#define FD_ADDRSIZE(instr) (1 << (instr)->addrsz)
/** Get the logarithmic address size; FD_ADDRSIZE == 1 << FD_ADDRSIZELG **/
#define FD_ADDRSIZELG(instr) ((instr)->addrsz)
/** Gets the operation width in bytes of the instruction if this is not encoded
 * in the operands, for example for the string instruction (e.g. MOVS). **/
#define FD_OPSIZE(instr) (1 << (instr)->operandsz)
/** Get the logarithmic operand size; FD_OPSIZE == 1 << FD_OPSIZELG iff
 * FD_OPSIZE is valid. **/
#define FD_OPSIZELG(instr) ((instr)->operandsz)
/** Indicates whether the instruction was encoded with a REP prefix. Needed for:
 * (1) Handling the instructions MOVS, STOS, LODS, INS and OUTS properly.
 * (2) Handling the instructions SCAS and CMPS, for which this means REPZ. **/
#define FD_HAS_REP(instr) ((instr)->flags & FD_FLAG_REP)
/** Indicates whether the instruction was encoded with a REPNZ prefix. **/
#define FD_HAS_REPNZ(instr) ((instr)->flags & FD_FLAG_REPNZ)
/** Indicates whether the instruction was encoded with a LOCK prefix. **/
#define FD_HAS_LOCK(instr) ((instr)->flags & FD_FLAG_LOCK)
/** Do not use. **/
#define FD_IS64(instr) ((instr)->flags & FD_FLAG_64)

/** Gets the type of an operand at the given index. **/
#define FD_OP_TYPE(instr,idx) ((FdOpType) (instr)->operands[idx].type)
/** Gets the size in bytes of an operand. However, there are a few exceptions:
 * (1) For some register types, e.g., segment registers, or x87 registers, the
 *     size is zero. (This allows some simplifications internally.)
 * (2) On some vector instructions this may be only an approximation of the
 *     actually needed operand size (that is, an instruction may/must only use
 *     a smaller part than specified here). The real operand size is always
 *     fully recoverable in combination with the instruction type. **/
#define FD_OP_SIZE(instr,idx) (1 << (instr)->operands[idx].size >> 1)
/** Get the logarithmic size of an operand; see FD_OP_SIZE for special cases.
 * The following equality holds:  FD_OP_SIZE == 1 << (FD_OP_SIZELG + 1) >> 1
 * Note that typically  FD_OP_SIZE == 1 << FD_OP_SIZELG  unless a zero-sized
 * memory operand, FPU register, or mask register is involved.  **/
#define FD_OP_SIZELG(instr,idx) ((instr)->operands[idx].size - 1)
/** Gets the accessed register index of a register operand. Note that /only/ the
 * index is returned, no further interpretation of the index (which depends on
 * the instruction type) is done. The register type can be fetched using
 * FD_OP_REG_TYPE, e.g. for distinguishing high-byte registers.
 * Only valid if  FD_OP_TYPE == FD_OT_REG  **/
#define FD_OP_REG(instr,idx) ((FdReg) (instr)->operands[idx].reg)
/** Gets the type of the accessed register.
 * Only valid if  FD_OP_TYPE == FD_OT_REG  **/
#define FD_OP_REG_TYPE(instr,idx) ((FdRegType) (instr)->operands[idx].misc)
/** DEPRECATED: use FD_OP_REG_TYPE() == FD_RT_GPH instead.
 * Returns whether the accessed register is a high-byte register. In that case,
 * the register index has to be decreased by 4.
 * Only valid if  FD_OP_TYPE == FD_OT_REG  **/
#define FD_OP_REG_HIGH(instr,idx) (FD_OP_REG_TYPE(instr,idx) == FD_RT_GPH)
/** Gets the index of the base register from a memory operand, or FD_REG_NONE,
 * if the memory operand has no base register. This is the only case where the
 * 64-bit register RIP can be returned, in which case the operand also has no
 * scaled index register.
 * Only valid if  FD_OP_TYPE == FD_OT_MEM/MEMBCST  **/
#define FD_OP_BASE(instr,idx) ((FdReg) (instr)->operands[idx].reg)
/** Gets the index of the index register from a memory operand, or FD_REG_NONE,
 * if the memory operand has no scaled index register.
 * Only valid if  FD_OP_TYPE == FD_OT_MEM/MEMBCST  **/
#define FD_OP_INDEX(instr,idx) ((FdReg) (instr)->operands[idx].misc & 0x3f)
/** Gets the scale of the index register from a memory operand when existent.
 * This does /not/ return the scale in an absolute value but returns the amount
 * of bits the index register is shifted to the left (i.e. the value in in the
 * range 0-3). The actual scale can be computed easily using  1<<FD_OP_SCALE.
 * Only valid if  FD_OP_TYPE == FD_OT_MEM/MEMBCST  and  FD_OP_INDEX != NONE **/
#define FD_OP_SCALE(instr,idx) ((instr)->operands[idx].misc >> 6)
/** Gets the sign-extended displacement of a memory operand.
 * Only valid if  FD_OP_TYPE == FD_OT_MEM/MEMBCST  **/
#define FD_OP_DISP(instr,idx) ((int64_t) (instr)->disp)
/** Get memory broadcast size in bytes.
 * Only valid if  FD_OP_TYPE == FD_OT_MEMBCST **/
#define FD_OP_BCSTSZ(instr,idx) (1 << FD_OP_BCSTSZLG(instr,idx))
/** Get logarithmic memory broadcast size (1 = 2-byte; 2=4-byte; 3=8-byte).
 * Only valid if  FD_OP_TYPE == FD_OT_MEMBCST **/
#define FD_OP_BCSTSZLG(instr,idx) ((instr)->segment >> 6)
/** Gets the (sign-extended) encoded constant for an immediate operand.
 * Only valid if  FD_OP_TYPE == FD_OT_IMM  or  FD_OP_TYPE == FD_OT_OFF  **/
#define FD_OP_IMM(instr,idx) ((instr)->imm)

/** Get the opmask register for EVEX-encoded instructions; 0 for no mask. **/
#define FD_MASKREG(instr) ((instr)->evex & 0x07)
/** Get whether zero masking shall be used. Only valid if  FD_MASKREG != 0. **/
#define FD_MASKZERO(instr) ((instr)->evex & 0x80)
/** Get rounding mode for EVEX-encoded instructions. See FdRoundControl. **/
#define FD_ROUNDCONTROL(instr) ((FdRoundControl) (((instr)->evex & 0x70) >> 4))

#ifdef __cplusplus
}
#endif

#endif

```

`third_party/fadec/format.c`:

```c

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#ifdef _MSC_VER
#include <intrin.h>
#endif

#include <fadec.h>


#ifdef __GNUC__
#define LIKELY(x) __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#define DECLARE_ARRAY_SIZE(n) static n
#define DECLARE_RESTRICTED_ARRAY_SIZE(n) restrict static n
#else
#define LIKELY(x) (x)
#define UNLIKELY(x) (x)
#define DECLARE_ARRAY_SIZE(n) n
#define DECLARE_RESTRICTED_ARRAY_SIZE(n) n
#endif

#if defined(__has_attribute)
#if __has_attribute(fallthrough)
#define FALLTHROUGH() __attribute__((fallthrough))
#endif
#endif
#if !defined(FALLTHROUGH)
#define FALLTHROUGH() ((void)0)
#endif

struct FdStr {
    const char* s;
    unsigned sz;
};

#define fd_stre(s) ((struct FdStr) { (s "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"), sizeof (s)-1 })

static char*
fd_strpcat(char* restrict dst, struct FdStr src) {
#ifdef __GNUC__
    unsigned lim = __builtin_constant_p(src.sz) && src.sz <= 8 ? 8 : 16;
#else
    unsigned lim = 16;
#endif
    for (unsigned i = 0; i < lim; i++)
        dst[i] = src.s[i];
    // __builtin_memcpy(dst, src.s, 16);
    return dst + src.sz;
}

static unsigned
fd_clz64(uint64_t v) {
#if defined(__GNUC__)
    return __builtin_clzll(v);
#elif defined(_MSC_VER)
    unsigned long index;

    // 32-bit MSVC doesn't support _BitScanReverse64. This is an attempt to
    // identify this case.
#if INTPTR_MAX == INT64_MAX
    _BitScanReverse64(&index, v);
#else
    if (_BitScanReverse(&index, v >> 32))
        return 31 - index;

    _BitScanReverse(&index, v & 0xffffffff);
#endif

    return 63 - index;
#else
#error Unsupported compiler.
#endif
}

#if defined(__SSE2__)
#include <immintrin.h>
#endif

static char*
fd_strpcatnum(char dst[DECLARE_ARRAY_SIZE(18)], uint64_t val) {
    unsigned lz = fd_clz64(val|1);
    unsigned numbytes = 16 - (lz / 4);
#if defined(__SSE2__)
    __m128i mv = _mm_set_epi64x(0, val << (lz & -4));
    __m128i mvp = _mm_unpacklo_epi8(mv, mv);
    __m128i mva = _mm_srli_epi16(mvp, 12);
    __m128i mvb = _mm_and_si128(mvp, _mm_set1_epi16(0x0f00u));
    __m128i ml = _mm_or_si128(mva, mvb);
    __m128i mn = _mm_or_si128(ml, _mm_set1_epi8(0x30));
    __m128i mgt = _mm_cmpgt_epi8(ml, _mm_set1_epi8(9));
    __m128i mgtm = _mm_and_si128(mgt, _mm_set1_epi8(0x61 - 0x3a));
    __m128i ma = _mm_add_epi8(mn, mgtm);
    __m128i msw = _mm_shufflehi_epi16(_mm_shufflelo_epi16(ma, 0x1b), 0x1b);
    __m128i ms = _mm_shuffle_epi32(msw, 0x4e);
    _mm_storeu_si128((__m128i_u*) (dst + 2), ms);
#else
    unsigned idx = numbytes + 2;
    do {
        dst[--idx] = "0123456789abcdef"[val % 16];
        val /= 16;
    } while (val);
#endif
    dst[0] = '0';
    dst[1] = 'x';
    return dst + numbytes + 2;
}

static char*
fd_strpcatreg(char* restrict dst, size_t rt, size_t ri, unsigned size) {
    const char* nametab =
        "\2al\4bnd0\2cl\4bnd1\2dl\4bnd2\2bl\4bnd3"
        "\3spl\0   \3bpl\0   \3sil\0   \3dil\0   "
        "\3r8b\0   \3r9b\0   \4r10b\0  \4r11b\0  "
        "\4r12b\2ah\4r13b\2ch\4r14b\2dh\4r15b\2bh\0\0      "

        "\2ax\4tmm0\2cx\4tmm1\2dx\4tmm2\2bx\4tmm3"
        "\2sp\4tmm4\2bp\4tmm5\2si\4tmm6\2di\4tmm7"
        "\3r8w \2es\3r9w \2cs\4r10w\2ss\4r11w\2ds"
        "\4r12w\2fs\4r13w\2gs\4r14w\0  \4r15w\0  \2ip\0    "

        "\3eax\3mm0\3ecx\3mm1\3edx\3mm2\3ebx\3mm3"
        "\3esp\3mm4\3ebp\3mm5\3esi\3mm6\3edi\3mm7"
        "\3r8d \2k0\3r9d \2k1\4r10d\2k2\4r11d\2k3"
        "\4r12d\2k4\4r13d\2k5\4r14d\2k6\4r15d\2k7\3eip\0   "

        "\3rax\3cr0\3rcx\0   \3rdx\3cr2\3rbx\3cr3"
        "\3rsp\3cr4\3rbp\0   \3rsi\0   \3rdi\0   "
        "\2r8 \3cr8\2r9 \3dr0\3r10\3dr1\3r11\3dr2"
        "\3r12\3dr3\3r13\3dr4\3r14\3dr5\3r15\3dr6\3rip\3dr7"

        "\5st(0)\0 \5st(1)\0 \5st(2)\0 \5st(3)\0 "
        "\5st(4)\0 \5st(5)\0 \5st(6)\0 \5st(7)\0 "

        "\4xmm0\0  \4xmm1\0  \4xmm2\0  \4xmm3\0  "
        "\4xmm4\0  \4xmm5\0  \4xmm6\0  \4xmm7\0  "
        "\4xmm8\0  \4xmm9\0  \5xmm10\0 \5xmm11\0 "
        "\5xmm12\0 \5xmm13\0 \5xmm14\0 \5xmm15\0 "
        "\5xmm16\0 \5xmm17\0 \5xmm18\0 \5xmm19\0 "
        "\5xmm20\0 \5xmm21\0 \5xmm22\0 \5xmm23\0 "
        "\5xmm24\0 \5xmm25\0 \5xmm26\0 \5xmm27\0 "
        "\5xmm28\0 \5xmm29\0 \5xmm30\0 \5xmm31\0 ";

    static const uint16_t nametabidx[] = {
        [FD_RT_GPL] = 0 * 17*8 + 0 * 8 + 0,
        [FD_RT_GPH] = 0 * 17*8 + 8 * 8 + 5,
        [FD_RT_SEG] = 1 * 17*8 + 8 * 8 + 5,
        [FD_RT_FPU] = 4 * 17*8 + 0 * 8 + 0,
        [FD_RT_MMX] = 2 * 17*8 + 0 * 8 + 4,
        [FD_RT_VEC] = 4 * 17*8 + 8 * 8 + 0,
        [FD_RT_MASK]= 2 * 17*8 + 8 * 8 + 5,
        [FD_RT_BND] = 0 * 17*8 + 0 * 8 + 3,
        [FD_RT_CR]  = 3 * 17*8 + 0 * 8 + 4,
        [FD_RT_DR]  = 3 * 17*8 + 9 * 8 + 4,
        [FD_RT_TMM] = 1 * 17*8 + 0 * 8 + 3,
    };

    unsigned idx = rt == FD_RT_GPL ? size * 17*8 : nametabidx[rt];
    const char* name = nametab + idx + 8*ri;
    for (unsigned i = 0; i < 8; i++)
        dst[i] = name[i+1];
    if (UNLIKELY(rt == FD_RT_VEC && size > 4))
        dst[0] += size - 4;
    return dst + *name;
}

const char*
fdi_name(FdInstrType ty) {
    (void) ty;
    return "(invalid)";
}

static char*
fd_mnemonic(char buf[DECLARE_RESTRICTED_ARRAY_SIZE(48)], const FdInstr* instr) {
#define FD_DECODE_TABLE_STRTAB1
    static const char* mnemonic_str =
#include <fadec-decode-private.inc>
        // 20 NULL Bytes to prevent out-of-bounds reads
        "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
#undef FD_DECODE_TABLE_STRTAB1

#define FD_DECODE_TABLE_STRTAB2
    static const uint16_t mnemonic_offs[] = {
#include <fadec-decode-private.inc>
    };
#undef FD_DECODE_TABLE_STRTAB2

#define FD_DECODE_TABLE_STRTAB3
    static const uint8_t mnemonic_lens[] = {
#include <fadec-decode-private.inc>
    };
#undef FD_DECODE_TABLE_STRTAB3

    const char* mnem = &mnemonic_str[mnemonic_offs[FD_TYPE(instr)]];
    unsigned mnemlen = mnemonic_lens[FD_TYPE(instr)];

    bool prefix_xacq_xrel = false;
    bool prefix_segment = false;

    char sizesuffix[4] = {0};
    unsigned sizesuffixlen = 0;

    if (UNLIKELY(FD_OP_TYPE(instr, 0) == FD_OT_OFF && FD_OP_SIZELG(instr, 0) == 1))
        sizesuffix[0] = 'w', sizesuffixlen = 1;

    switch (FD_TYPE(instr)) {
    case FDI_C_SEP:
        mnem += FD_OPSIZE(instr) & 0xc;
        mnemlen = 3;
        break;
    case FDI_C_EX:
        mnem += FD_OPSIZE(instr) & 0xc;
        mnemlen = FD_OPSIZE(instr) < 4 ? 3 : 4;
        break;
    case FDI_CMPXCHGD:
        switch (FD_OPSIZELG(instr)) {
        default: break;
        case 2: sizesuffix[0] = '8', sizesuffix[1] = 'b', sizesuffixlen = 2; break;
        case 3: sizesuffix[0] = '1', sizesuffix[1] = '6', sizesuffix[2] = 'b', sizesuffixlen = 3; break;
        }
        break;
    case FDI_JCXZ:
        mnemlen = FD_ADDRSIZELG(instr) == 1 ? 4 : 5;
        mnem += 5 * (FD_ADDRSIZELG(instr) - 1);
        break;
    case FDI_PUSH:
        if (FD_OP_SIZELG(instr, 0) == 1 && FD_OP_TYPE(instr, 0) == FD_OT_IMM)
            sizesuffix[0] = 'w', sizesuffixlen = 1;
        FALLTHROUGH();
    case FDI_POP:
        if (FD_OP_SIZELG(instr, 0) == 1 && FD_OP_TYPE(instr, 0) == FD_OT_REG &&
            FD_OP_REG_TYPE(instr, 0) == FD_RT_SEG)
            sizesuffix[0] = 'w', sizesuffixlen = 1;
        break;
    case FDI_XCHG:
        if (FD_OP_TYPE(instr, 0) == FD_OT_MEM)
            prefix_xacq_xrel = true;
        break;
    case FDI_MOV:
        // MOV C6h/C7h can have XRELEASE prefix.
        if (FD_HAS_REP(instr) && FD_OP_TYPE(instr, 0) == FD_OT_MEM &&
            FD_OP_TYPE(instr, 1) == FD_OT_IMM)
            prefix_xacq_xrel = true;
        break;
    case FDI_FXSAVE:
    case FDI_FXRSTOR:
    case FDI_XSAVE:
    case FDI_XSAVEC:
    case FDI_XSAVEOPT:
    case FDI_XSAVES:
    case FDI_XRSTOR:
    case FDI_XRSTORS:
        if (FD_OPSIZELG(instr) == 3)
            sizesuffix[0] = '6', sizesuffix[1] = '4', sizesuffixlen = 2;
        break;
    case FDI_EVX_MOV_G2X:
    case FDI_EVX_MOV_X2G:
    case FDI_EVX_PEXTR:
        sizesuffix[0] = "bwdq"[FD_OP_SIZELG(instr, 0)];
        sizesuffixlen = 1;
        break;
    case FDI_EVX_PBROADCAST:
        sizesuffix[0] = "bwdq"[FD_OP_SIZELG(instr, 1)];
        sizesuffixlen = 1;
        break;
    case FDI_EVX_PINSR:
        sizesuffix[0] = "bwdq"[FD_OP_SIZELG(instr, 2)];
        sizesuffixlen = 1;
        break;
    case FDI_RET:
    case FDI_ENTER:
    case FDI_LEAVE:
        if (FD_OPSIZELG(instr) == 1)
            sizesuffix[0] = 'w', sizesuffixlen = 1;
        break;
    case FDI_LODS:
    case FDI_MOVS:
    case FDI_CMPS:
    case FDI_OUTS:
        prefix_segment = true;
        FALLTHROUGH();
    case FDI_STOS:
    case FDI_SCAS:
    case FDI_INS:
        if (FD_HAS_REP(instr))
            buf = fd_strpcat(buf, fd_stre("rep "));
        if (FD_HAS_REPNZ(instr))
            buf = fd_strpcat(buf, fd_stre("repnz "));
        if (FD_IS64(instr) && FD_ADDRSIZELG(instr) == 2)
            buf = fd_strpcat(buf, fd_stre("addr32 "));
        if (!FD_IS64(instr) && FD_ADDRSIZELG(instr) == 1)
            buf = fd_strpcat(buf, fd_stre("addr16 "));
        FALLTHROUGH();
    case FDI_IN:
    case FDI_OUT:
        if (FD_OP_TYPE(instr, 0) != FD_OT_NONE)
            break;
        FALLTHROUGH();
    case FDI_PUSHA:
    case FDI_POPA:
    case FDI_PUSHF:
    case FDI_POPF:
    case FDI_RETF:
    case FDI_IRET:
        sizesuffix[0] = "bwdq"[FD_OPSIZELG(instr)];
        sizesuffixlen = 1;
        break;
    default: break;
    }

    if (UNLIKELY(prefix_xacq_xrel || FD_HAS_LOCK(instr))) {
        if (FD_HAS_REP(instr))
            buf = fd_strpcat(buf, fd_stre("xrelease "));
        if (FD_HAS_REPNZ(instr))
            buf = fd_strpcat(buf, fd_stre("xacquire "));
    }
    if (UNLIKELY(FD_HAS_LOCK(instr)))
        buf = fd_strpcat(buf, fd_stre("lock "));
    if (UNLIKELY(prefix_segment && FD_SEGMENT(instr) != FD_REG_NONE)) {
        *buf++ = "ecsdfg\0"[FD_SEGMENT(instr) & 7];
        *buf++ = 's';
        *buf++ = ' ';
    }

    for (unsigned i = 0; i < 20; i++)
        buf[i] = mnem[i];
    buf += mnemlen;
    for (unsigned i = 0; i < 4; i++)
        buf[i] = sizesuffix[i];
    buf += sizesuffixlen;

    return buf;
}

static char*
fd_format_impl(char buf[DECLARE_RESTRICTED_ARRAY_SIZE(128)], const FdInstr* instr, uint64_t addr) {
    buf = fd_mnemonic(buf, instr);

    for (int i = 0; i < 4; i++)
    {
        FdOpType op_type = FD_OP_TYPE(instr, i);
        if (op_type == FD_OT_NONE)
            break;
        if (i > 0)
            *buf++ = ',';
        *buf++ = ' ';

        int size = FD_OP_SIZELG(instr, i);

        if (op_type == FD_OT_REG) {
            unsigned type = FD_OP_REG_TYPE(instr, i);
            unsigned idx = FD_OP_REG(instr, i);
            buf = fd_strpcatreg(buf, type, idx, size);
        } else if (op_type == FD_OT_MEM || op_type == FD_OT_MEMBCST) {
            unsigned idx_rt = FD_RT_GPL;
            unsigned idx_sz = FD_ADDRSIZELG(instr);
            switch (FD_TYPE(instr)) {
            case FDI_CMPXCHGD: size = FD_OPSIZELG(instr) + 1; break;
            case FDI_BOUND: size += 1; break;
            case FDI_JMPF:
            case FDI_CALLF:
            case FDI_LDS:
            case FDI_LES:
            case FDI_LFS:
            case FDI_LGS:
            case FDI_LSS:
                size += 6;
                break;
            case FDI_FLD:
            case FDI_FSTP:
            case FDI_FBLD:
            case FDI_FBSTP:
                size = size >= 0 ? size : 9;
                break;
            case FDI_VPGATHERQD:
            case FDI_VGATHERQPS:
            case FDI_EVX_PGATHERQD:
            case FDI_EVX_GATHERQPS:
                idx_rt = FD_RT_VEC;
                idx_sz = FD_OP_SIZELG(instr, 0) + 1;
                break;
            case FDI_EVX_PSCATTERQD:
            case FDI_EVX_SCATTERQPS:
                idx_rt = FD_RT_VEC;
                idx_sz = FD_OP_SIZELG(instr, 1) + 1;
                break;
            case FDI_VPGATHERDQ:
            case FDI_VGATHERDPD:
            case FDI_EVX_PGATHERDQ:
            case FDI_EVX_GATHERDPD:
                idx_rt = FD_RT_VEC;
                idx_sz = FD_OP_SIZELG(instr, 0) - 1;
                break;
            case FDI_EVX_PSCATTERDQ:
            case FDI_EVX_SCATTERDPD:
                idx_rt = FD_RT_VEC;
                idx_sz = FD_OP_SIZELG(instr, 1) - 1;
                break;
            case FDI_VPGATHERDD:
            case FDI_VPGATHERQQ:
            case FDI_VGATHERDPS:
            case FDI_VGATHERQPD:
            case FDI_EVX_PGATHERDD:
            case FDI_EVX_PGATHERQQ:
            case FDI_EVX_GATHERDPS:
            case FDI_EVX_GATHERQPD:
                idx_rt = FD_RT_VEC;
                idx_sz = FD_OP_SIZELG(instr, 0);
                break;
            case FDI_EVX_PSCATTERDD:
            case FDI_EVX_PSCATTERQQ:
            case FDI_EVX_SCATTERDPS:
            case FDI_EVX_SCATTERQPD:
                idx_rt = FD_RT_VEC;
                idx_sz = FD_OP_SIZELG(instr, 1);
                break;
            default: break;
            }

            if (op_type == FD_OT_MEMBCST)
                size = FD_OP_BCSTSZLG(instr, i);

            const char* ptrsizes =
                "\00               "
                "\11byte ptr       "
                "\11word ptr       "
                "\12dword ptr      "
                "\12qword ptr      "
                "\14xmmword ptr    "
                "\14ymmword ptr    "
                "\14zmmword ptr    "
                "\12dword ptr      "  // far ptr; word + 2
                "\12fword ptr      "  // far ptr; dword + 2
                "\12tbyte ptr      "; // far ptr/FPU; qword + 2
            const char* ptrsize = ptrsizes + 16 * (size + 1);
            buf = fd_strpcat(buf, (struct FdStr) { ptrsize+1, *ptrsize });

            unsigned seg = FD_SEGMENT(instr);
            if (seg != FD_REG_NONE) {
                *buf++ = "ecsdfg\0"[seg & 7];
                *buf++ = 's';
                *buf++ = ':';
            }
            *buf++ = '[';

            bool has_base = FD_OP_BASE(instr, i) != FD_REG_NONE;
            bool has_idx = FD_OP_INDEX(instr, i) != FD_REG_NONE;
            if (has_base)
                buf = fd_strpcatreg(buf, FD_RT_GPL, FD_OP_BASE(instr, i), FD_ADDRSIZELG(instr));
            if (has_idx) {
                if (has_base)
                    *buf++ = '+';
                *buf++ = '0' + (1 << FD_OP_SCALE(instr, i));
                *buf++ = '*';
                buf = fd_strpcatreg(buf, idx_rt, FD_OP_INDEX(instr, i), idx_sz);
            }
            uint64_t disp = FD_OP_DISP(instr, i);
            if (disp && (has_base || has_idx)) {
                *buf++ = (int64_t) disp < 0 ? '-' : '+';
                if ((int64_t) disp < 0)
                    disp = -disp;
            }
            if (FD_ADDRSIZELG(instr) == 1)
                disp &= 0xffff;
            else if (FD_ADDRSIZELG(instr) == 2)
                disp &= 0xffffffff;
            if (disp || (!has_base && !has_idx))
                buf = fd_strpcatnum(buf, disp);
            *buf++ = ']';

            if (UNLIKELY(op_type == FD_OT_MEMBCST)) {
                // {1toX}, X = FD_OP_SIZE(instr, i) / BCSTSZ (=> 2/4/8/16/32)
                unsigned bcstszidx = FD_OP_SIZELG(instr, i) - FD_OP_BCSTSZLG(instr, i) - 1;
                const char* bcstsizes = "\6{1to2} \6{1to4} \6{1to8} \7{1to16}\7{1to32}         ";
                const char* bcstsize = bcstsizes + bcstszidx * 8;
                buf = fd_strpcat(buf, (struct FdStr) { bcstsize+1, *bcstsize });
            }
        } else if (op_type == FD_OT_IMM || op_type == FD_OT_OFF) {
            uint64_t immediate = FD_OP_IMM(instr, i);
            // Some instructions have actually two immediate operands which are
            // decoded as a single operand. Split them here appropriately.
            switch (FD_TYPE(instr)) {
            default:
                goto nosplitimm;
            case FDI_SSE_EXTRQ:
            case FDI_SSE_INSERTQ:
                buf = fd_strpcatnum(buf, immediate & 0xff);
                buf = fd_strpcat(buf, fd_stre(", "));
                immediate = (immediate >> 8) & 0xff;
                break;
            case FDI_ENTER:
                buf = fd_strpcatnum(buf, immediate & 0xffff);
                buf = fd_strpcat(buf, fd_stre(", "));
                immediate = (immediate >> 16) & 0xff;
                break;
            case FDI_JMPF:
            case FDI_CALLF:
                buf = fd_strpcatnum(buf, (immediate >> (8 << size)) & 0xffff);
                *buf++ = ':';
                // immediate is masked below.
                break;
            }

        nosplitimm:
            if (op_type == FD_OT_OFF)
                immediate += addr + FD_SIZE(instr);
            if (size == 0)
                immediate &= 0xff;
            else if (size == 1)
                immediate &= 0xffff;
            else if (size == 2)
                immediate &= 0xffffffff;
            buf = fd_strpcatnum(buf, immediate);
        }

        if (i == 0 && FD_MASKREG(instr)) {
            *buf++ = '{';
            buf = fd_strpcatreg(buf, FD_RT_MASK, FD_MASKREG(instr), 0);
            *buf++ = '}';
            if (FD_MASKZERO(instr))
                buf = fd_strpcat(buf, fd_stre("{z}"));
        }
    }
    if (UNLIKELY(FD_ROUNDCONTROL(instr) != FD_RC_MXCSR)) {
        switch (FD_ROUNDCONTROL(instr)) {
        case FD_RC_RN: buf = fd_strpcat(buf, fd_stre(", {rn-sae}")); break;
        case FD_RC_RD: buf = fd_strpcat(buf, fd_stre(", {rd-sae}")); break;
        case FD_RC_RU: buf = fd_strpcat(buf, fd_stre(", {ru-sae}")); break;
        case FD_RC_RZ: buf = fd_strpcat(buf, fd_stre(", {rz-sae}")); break;
        case FD_RC_SAE: buf = fd_strpcat(buf, fd_stre(", {sae}")); break;
        default: break; // should not happen
        }
    }
    *buf++ = '\0';
    return buf;
}

void
fd_format(const FdInstr* instr, char* buffer, size_t len)
{
    fd_format_abs(instr, 0, buffer, len);
}

void
fd_format_abs(const FdInstr* instr, uint64_t addr, char* restrict buffer, size_t len) {
    char tmp[128];
    char* buf = buffer;
    if (UNLIKELY(len < 128)) {
        if (!len)
            return;
        buf = tmp;
    }

    char* end = fd_format_impl(buf, instr, addr);

    if (buf != buffer) {
        unsigned i;
        for (i = 0; i < (end - tmp) && i < len-1; i++)
            buffer[i] = tmp[i];
        buffer[i] = '\0';
    }
}

```

`third_party/fadec/instrs.txt`:

```txt
# Fadec Instruction Description Table
#
# This file table contains all supported instructions. The format is custom,
# this parsed and processed into decode tables/encoders in parseinstrs.py.
#
#
# The opcode is used to determine the instruction row when decoding from
# instruction bytes. There are multiple components up to the opcode byte:
#
#   (VEX\.|EVEX\.)? -> VEX/EVEX prefix; or legacy if absent
#   ((NP|66|F2|F3|NFx)\.)? -> optional mandatory prefix
#   (W[01]\.)? -> W0/W1, ignored if absent
#   (L(0|1|12|IG)\.)? -> VEX.L/EVEX.L'L constraint, must not occur for legacy
#       opcodes; not really used for distinguishing instructions/encodings
#       (exceptions: VZEROUPPER/VZEROALL and VMOVDDUP)
#   (|0f|0f38|0f3a|M[56]\.) -> legacy escape; or VEX/EVEX opcode map
#   [0-9a-f]{2} -> actual opcode byte
#
# After the opcode byte, at most one of the following specifiers can follow:
#
#   /[rm] -> ModRM.mod specifier (register or memory operand only)
#   /[0-7] -> ModRM.reg specifier (used as opcode extension)
#   /[0-7][rm] -> ModRM.mod and ModRM.reg specifier
#   /[rm][0-7] -> ModRM.mod and ModRM.r/m specifier (AMX only)
#   [c-f][0-9a-f] -> complete ModRM specifier, whole byte used as opcode ext.
#   + -> for O-encoded instructions, the last three bits are an operand
#
# A legacy opcode may be prefixed with "*", making it a weak opcode which can be
# overwritten by later opcode definitions. This is used for reserved nops,
# reserved prefetch, BSF/BSR (overwritten by TZCNT/LZCNT), and WBINVD
# (overwritten by WBNOINVD).
#
# The encoding description follows the naming found in older (pre-AVX-512) Intel
# SDMs. It maps encoding fields to operand indices and specifies the immediate
# encoding. The gist is: M=ModRM.r/m; R=ModRM.reg; V=VEX.vvvv; A=EAX/XMM0; C=CL;
# I=imm; O=opcode bits 5:7; S=opcode bits 2:4; FD/TD=absolute address; D=jump
# destination. RVMR is an exception, the register is encoded in imm8[7:4].
# MOV_CR/MOV_DR are another exception, they ignore ModRM.mod and always encode a
# register operand.
#
# For operands, the first letter specified the operand kind. Naming is mostly
# consistent with Intel's SDM, except for F (Intel: eflags; here: FPU).
#
#                   GP  MMX XMM MSK TMM FPU CR  DR  SEG
#   ModRM.r/m (reg) R   N   U   K   T   F   -   -   -
#   ModRM.r/m (r/m) E   Q   W   K   T   -   -   -   -
#   ModRM.reg       G   P   V   K   T   F   C   D   S
#   VEX.vvvv        B   -   H   K   T   -   -   -   -
#   imm8[7:4]       -   -   L   -   -   -   -   -   -
#
#   M=memory only; O=direct address
#   I=immediate; A=address/far jmp; J=rip-relative address/jmp
#
# The remaining one or two letters specify the operand size:
#
# - Fixed sizes: b=1; w=2, d/ss=4; q/sd=8; dq=16; qq=32; oq=64
# - GP operand sizes: v=2/4/8 (66/REX.W); y=4/8 (66 ignored)
# - Vector sizes: x/ps/pd=16/32/64 (EVEX.L'L); h=half x, f=fourth x; e=eighth x
# - Other immediate sizes: z=v with max. 4 bytes; bs=v (sign-extended byte);
#   zd=z (but always four byte imm); zq=z (but always eight byte imm)
# - Special operand size: a=z:z (BOUND only); p=w:z (far pointer)
# - If not letter is specified, the operand size is decoded as zero. The size
#   is implicitly part of the operand and can be reconstructed by the user.
#
# The instruction mnemonic is generally specified as decoded/formatted (there
# are a few exceptions, see parseinstrs.py decode_table and encode_mnems).
#
# After the mnemonic, flags can be specified. Some common flags have a short
# form immediately after the mnemonic (e.g., EVX_ADDSD+kr), others do not.
#
# - I64: invalid in 64-bit mode
# - O64: only valid in 64-bit mode
# - +w (INSTR_WIDTH): store operand size as instruction attribute; used for
#   instructions that depend on the operand size but have no explicit operands.
# - +a (U67): respects addr-size override even without memory operand.
# - +s (USEG): respects segment override even without memory operand.
# - +k (MASK): supports EVEX masking.
# - +e (SAE): supports EVEX suppress all exceptions.
# - +r (ER): supports EVEX embedded rounding control.
# - +b (BCST): supports EVEX embedded broadcast. Broadcast size depends on REX.W
#   (REX.W=0 => 32 bits; REX.W=1 => 64 bits).
# - BCST16: set EVEX embedded broadcast size to 16 bits.
# - SZ8: has effective operand size of 8 bits (encode only).
# - U66: uses 66 prefix as operand size override even with a mandatory prefix.
# - I66: ignores 66 prefix as operand size override.
# - LOCK: supports LOCK prefix when the first operand is memory.
# - D64: defaults to 64-bit operand size in 64-bit mode (REX.W ignored).
# - F64: forced to 64-bit operand size in 64-bit mode (66/REX.W ignored).
#   NB: this is Intel-specific. On AMD, F64 behaves like D64.
# - VSIB: memory operand uses VSIB encoding (SIB required, idx is vector).
# - ENC_SEPSZ: attach size suffixes to each operand (encode only).
# - ENC_NOSZ: do not attach size suffix (encode only).
# - ENC_REP: supports REP prefix.
# - ENC_REPCC: supports REPZ/REPNZ prefix.
# - UNDOC: undocumented, ignored by default.
# - TUPLE_*: AVX-512 tuple size. Only used to verify operand sizes.
# - CPL0: only valid if CPL=0 (system mode). Annotation only.
# - F=<feature flags>: feature flags. Annotation only.
# - EFL=<flags>: status flags use/modifications. Order: OF/DF/IF/SF/ZF/AF/PF/CF.
#   t=test; m=modify; 0=clear; 1=set; M=test-and-modify; u=undefined
#
#
# Opcode               ENC  OP1 OP2 OP3 OP4 MNEM       COND SZ? MISC FLAGS
#                                                      LOCK SZ8
#                                                       I64 D64
#                                                       O64 F64
#                                                      VSIB U66
#                                                           I66
# -------------------  ---- --- --- --- --- -------    ---- --- ----------
00                     MR   Eb  Gb  -   -   ADD        LOCK SZ8 EFL=m--mmmmm
01                     MR   Ev  Gv  -   -   ADD        LOCK     EFL=m--mmmmm
02                     RM   Gb  Eb  -   -   ADD             SZ8 EFL=m--mmmmm
03                     RM   Gv  Ev  -   -   ADD                 EFL=m--mmmmm
04                     IA   Rb  Ib  -   -   ADD             SZ8 EFL=m--mmmmm
05                     IA   Rv  Iz  -   -   ADD                 EFL=m--mmmmm
06                     S    Sv  -   -   -   PUSH_SEG    I64
07                     S    Sv  -   -   -   POP_SEG     I64
08                     MR   Eb  Gb  -   -   OR         LOCK SZ8 EFL=0--mmum0
09                     MR   Ev  Gv  -   -   OR         LOCK     EFL=0--mmum0
0a                     RM   Gb  Eb  -   -   OR              SZ8 EFL=0--mmum0
0b                     RM   Gv  Ev  -   -   OR                  EFL=0--mmum0
0c                     IA   Rb  Ib  -   -   OR              SZ8 EFL=0--mmum0
0d                     IA   Rv  Iz  -   -   OR                  EFL=0--mmum0
0e                     S    Sv  -   -   -   PUSH_SEG    I64
#0f    escape opcode
10                     MR   Eb  Gb  -   -   ADC        LOCK SZ8 EFL=m--mmmmM
11                     MR   Ev  Gv  -   -   ADC        LOCK     EFL=m--mmmmM
12                     RM   Gb  Eb  -   -   ADC             SZ8 EFL=m--mmmmM
13                     RM   Gv  Ev  -   -   ADC                 EFL=m--mmmmM
14                     IA   Rb  Ib  -   -   ADC             SZ8 EFL=m--mmmmM
15                     IA   Rv  Iz  -   -   ADC                 EFL=m--mmmmM
16                     S    Sv  -   -   -   PUSH_SEG    I64
17                     S    Sv  -   -   -   POP_SEG     I64
18                     MR   Eb  Gb  -   -   SBB        LOCK SZ8 EFL=m--mmmmM
19                     MR   Ev  Gv  -   -   SBB        LOCK     EFL=m--mmmmM
1a                     RM   Gb  Eb  -   -   SBB             SZ8 EFL=m--mmmmM
1b                     RM   Gv  Ev  -   -   SBB                 EFL=m--mmmmM
1c                     IA   Rb  Ib  -   -   SBB             SZ8 EFL=m--mmmmM
1d                     IA   Rv  Iz  -   -   SBB                 EFL=m--mmmmM
1e                     S    Sv  -   -   -   PUSH_SEG    I64
1f                     S    Sv  -   -   -   POP_SEG     I64
20                     MR   Eb  Gb  -   -   AND        LOCK SZ8 EFL=0--mmum0
21                     MR   Ev  Gv  -   -   AND        LOCK     EFL=0--mmum0
22                     RM   Gb  Eb  -   -   AND             SZ8 EFL=0--mmum0
23                     RM   Gv  Ev  -   -   AND                 EFL=0--mmum0
24                     IA   Rb  Ib  -   -   AND             SZ8 EFL=0--mmum0
25                     IA   Rv  Iz  -   -   AND                 EFL=0--mmum0
#26    SEG=ES prefix
27                     NP   -   -   -   -   DAA         I64     EFL=u--mmMmM
28                     MR   Eb  Gb  -   -   SUB        LOCK SZ8 EFL=m--mmmmm
29                     MR   Ev  Gv  -   -   SUB        LOCK     EFL=m--mmmmm
2a                     RM   Gb  Eb  -   -   SUB             SZ8 EFL=m--mmmmm
2b                     RM   Gv  Ev  -   -   SUB                 EFL=m--mmmmm
2c                     IA   Rb  Ib  -   -   SUB             SZ8 EFL=m--mmmmm
2d                     IA   Rv  Iz  -   -   SUB                 EFL=m--mmmmm
#2e    SEG=CS prefix
2f                     NP   -   -   -   -   DAS         I64     EFL=u--mmMmM
30                     MR   Eb  Gb  -   -   XOR        LOCK SZ8 EFL=0--mmum0
31                     MR   Ev  Gv  -   -   XOR        LOCK     EFL=0--mmum0
32                     RM   Gb  Eb  -   -   XOR             SZ8 EFL=0--mmum0
33                     RM   Gv  Ev  -   -   XOR                 EFL=0--mmum0
34                     IA   Rb  Ib  -   -   XOR             SZ8 EFL=0--mmum0
35                     IA   Rv  Iz  -   -   XOR                 EFL=0--mmum0
#36    SEG=SS prefix
37                     NP   -   -   -   -   AAA         I64     EFL=u--uuMum
38                     MR   Eb  Gb  -   -   CMP             SZ8 EFL=m--mmmmm
39                     MR   Ev  Gv  -   -   CMP                 EFL=m--mmmmm
3a                     RM   Gb  Eb  -   -   CMP             SZ8 EFL=m--mmmmm
3b                     RM   Gv  Ev  -   -   CMP                 EFL=m--mmmmm
3c                     IA   Rb  Ib  -   -   CMP             SZ8 EFL=m--mmmmm
3d                     IA   Rv  Iz  -   -   CMP                 EFL=m--mmmmm
#3e    SEG=DS prefix
3f                     NP   -   -   -   -   AAS         I64     EFL=u--uuMum
40+                    O    Rv  -   -   -   INC         I64     EFL=m--mmmm-
48+                    O    Rv  -   -   -   DEC         I64     EFL=m--mmmm-
50+                    O    Rv  -   -   -   PUSH            D64
58+                    O    Rv  -   -   -   POP             D64
60                     NP   -   -   -   -   PUSHA+w     I64
61                     NP   -   -   -   -   POPA+w      I64
62/m                   RM   Gv  Ma  -   -   BOUND       I64
63                     MR   Ew  Gw  -   -   ARPL        I64     EFL=----m---
63                     RM   Gv  Ed  -   -   MOVSX       O64     F=LM ENC_SEPSZ
#64    SEG=FS prefix
#65    SEG=GS prefix
#66    operand size prefix
#67    address size prefix
68                     I    Iz  -   -   -   PUSH            D64
69                     RMI  Gv  Ev  Iz  -   IMUL                EFL=m--uuuum
6a                     I    Ibs -   -   -   PUSH            D64
6b                     RMI  Gv  Ev  Ibs -   IMUL                EFL=m--uuuum
6c                     NP   -   -   -   -   INS+wa          SZ8 ENC_REP EFL=-t------
6d                     NP   -   -   -   -   INS+wa              ENC_REP EFL=-t------
6e                     NP   -   -   -   -   OUTS+was        SZ8 ENC_REP EFL=-t------
6f                     NP   -   -   -   -   OUTS+was            ENC_REP EFL=-t------
70                     D    Jbs -   -   -   JO              F64 EFL=t------- ENC_CC_BEGIN
71                     D    Jbs -   -   -   JNO             F64 EFL=t-------
72                     D    Jbs -   -   -   JC              F64 EFL=-------t
73                     D    Jbs -   -   -   JNC             F64 EFL=-------t
74                     D    Jbs -   -   -   JZ              F64 EFL=----t---
75                     D    Jbs -   -   -   JNZ             F64 EFL=----t---
76                     D    Jbs -   -   -   JBE             F64 EFL=----t--t
77                     D    Jbs -   -   -   JA              F64 EFL=----t--t
78                     D    Jbs -   -   -   JS              F64 EFL=---t----
79                     D    Jbs -   -   -   JNS             F64 EFL=---t----
7a                     D    Jbs -   -   -   JP              F64 EFL=------t-
7b                     D    Jbs -   -   -   JNP             F64 EFL=------t-
7c                     D    Jbs -   -   -   JL              F64 EFL=t--t----
7d                     D    Jbs -   -   -   JGE             F64 EFL=t--t----
7e                     D    Jbs -   -   -   JLE             F64 EFL=t--tt---
7f                     D    Jbs -   -   -   JG              F64 EFL=t--tt---
80/0                   MI   Eb  Ib  -   -   ADD        LOCK SZ8 EFL=m--mmmmm
80/1                   MI   Eb  Ib  -   -   OR         LOCK SZ8 EFL=0--mmum0
80/2                   MI   Eb  Ib  -   -   ADC        LOCK SZ8 EFL=m--mmmmM
80/3                   MI   Eb  Ib  -   -   SBB        LOCK SZ8 EFL=m--mmmmM
80/4                   MI   Eb  Ib  -   -   AND        LOCK SZ8 EFL=0--mmum0
80/5                   MI   Eb  Ib  -   -   SUB        LOCK SZ8 EFL=m--mmmmm
80/6                   MI   Eb  Ib  -   -   XOR        LOCK SZ8 EFL=0--mmum0
80/7                   MI   Eb  Ib  -   -   CMP             SZ8 EFL=m--mmmmm
81/0                   MI   Ev  Iz  -   -   ADD        LOCK     EFL=m--mmmmm
81/1                   MI   Ev  Iz  -   -   OR         LOCK     EFL=0--mmum0
81/2                   MI   Ev  Iz  -   -   ADC        LOCK     EFL=m--mmmmM
81/3                   MI   Ev  Iz  -   -   SBB        LOCK     EFL=m--mmmmM
81/4                   MI   Ev  Iz  -   -   AND        LOCK     EFL=0--mmum0
81/5                   MI   Ev  Iz  -   -   SUB        LOCK     EFL=m--mmmmm
81/6                   MI   Ev  Iz  -   -   XOR        LOCK     EFL=0--mmum0
81/7                   MI   Ev  Iz  -   -   CMP                 EFL=m--mmmmm
82/0                   MI   Eb  Ib  -   -   ADD    LOCK I64 SZ8 EFL=m--mmmmm
82/1                   MI   Eb  Ib  -   -   OR     LOCK I64 SZ8 EFL=0--mmum0
82/2                   MI   Eb  Ib  -   -   ADC    LOCK I64 SZ8 EFL=m--mmmmM
82/3                   MI   Eb  Ib  -   -   SBB    LOCK I64 SZ8 EFL=m--mmmmM
82/4                   MI   Eb  Ib  -   -   AND    LOCK I64 SZ8 EFL=0--mmum0
82/5                   MI   Eb  Ib  -   -   SUB    LOCK I64 SZ8 EFL=m--mmmmm
82/6                   MI   Eb  Ib  -   -   XOR    LOCK I64 SZ8 EFL=0--mmum0
82/7                   MI   Eb  Ib  -   -   CMP         I64 SZ8 EFL=m--mmmmm
83/0                   MI   Ev  Ibs -   -   ADD        LOCK     EFL=m--mmmmm
83/1                   MI   Ev  Ibs -   -   OR         LOCK     EFL=0--mmum0
83/2                   MI   Ev  Ibs -   -   ADC        LOCK     EFL=m--mmmmM
83/3                   MI   Ev  Ibs -   -   SBB        LOCK     EFL=m--mmmmM
83/4                   MI   Ev  Ibs -   -   AND        LOCK     EFL=0--mmum0
83/5                   MI   Ev  Ibs -   -   SUB        LOCK     EFL=m--mmmmm
83/6                   MI   Ev  Ibs -   -   XOR        LOCK     EFL=0--mmum0
83/7                   MI   Ev  Ibs -   -   CMP                 EFL=m--mmmmm
84                     MR   Eb  Gb  -   -   TEST            SZ8 EFL=0--mmum0
85                     MR   Ev  Gv  -   -   TEST                EFL=0--mmum0
86                     MR   Eb  Gb  -   -   XCHG       LOCK SZ8
87                     MR   Ev  Gv  -   -   XCHG       LOCK
88                     MR   Eb  Gb  -   -   MOV             SZ8
89                     MR   Ev  Gv  -   -   MOV
8a                     RM   Gb  Eb  -   -   MOV             SZ8
8b                     RM   Gv  Ev  -   -   MOV
# TODO: 8c is actually Ev,Sw; exact semantics are TBD
8c/0                   MR   Ew  Sw  -   -   MOV_S2G
8c/1                   MR   Ew  Sw  -   -   MOV_S2G
8c/2                   MR   Ew  Sw  -   -   MOV_S2G
8c/3                   MR   Ew  Sw  -   -   MOV_S2G
8c/4                   MR   Ew  Sw  -   -   MOV_S2G
8c/5                   MR   Ew  Sw  -   -   MOV_S2G
8d/m                   RM   Gv  M   -   -   LEA
8e/0                   RM   Sw  Ew  -   -   MOV_G2S
8e/2                   RM   Sw  Ew  -   -   MOV_G2S
8e/3                   RM   Sw  Ew  -   -   MOV_G2S
8e/4                   RM   Sw  Ew  -   -   MOV_G2S
8e/5                   RM   Sw  Ew  -   -   MOV_G2S
8f/0                   M    Ev  -   -   -   POP             D64
# Against frequent belief, only, XCHG (r/e)AX, (r)AX with 90 is NOP.
# As a lacking REX.B cannot be specified here, this is hardcoded.
90+                    OA   Rv  Rv  -   -   XCHG_NOP
98                     NP   -   -   -   -   C_EX+w
99                     NP   -   -   -   -   C_SEP+w
# Far jmp/call immediate size adjusted in code
9a                     I    Ap  -   -   -   CALLF       I64
9b                     NP   -   -   -   -   FWAIT
9c                     NP   -   -   -   -   PUSHF+w         D64 EFL=tttttttt
9d                     NP   -   -   -   -   POPF+w          D64 EFL=mmmmmmmm
9e                     NP   -   -   -   -   SAHF                EFL=---mmmmm
9f                     NP   -   -   -   -   LAHF                EFL=---ttttt
a0                     FD   Rb  Ob  -   -   MOV+as          SZ8
a1                     FD   Rv  Ov  -   -   MOV+as
a2                     TD   Ob  Rb  -   -   MOV+as          SZ8
a3                     TD   Ov  Rv  -   -   MOV+as
a4                     NP   -   -   -   -   MOVS+was        SZ8 ENC_REP EFL=-t------
a5                     NP   -   -   -   -   MOVS+was            ENC_REP EFL=-t------
a6                     NP   -   -   -   -   CMPS+was        SZ8 ENC_REPCC EFL=mt-mmmmm
a7                     NP   -   -   -   -   CMPS+was            ENC_REPCC EFL=mt-mmmmm
a8                     IA   Rb  Ib  -   -   TEST            SZ8 EFL=0--mmum0
a9                     IA   Rv  Iz  -   -   TEST                EFL=0--mmum0
aa                     NP   -   -   -   -   STOS+wa         SZ8 ENC_REP EFL=-t------
ab                     NP   -   -   -   -   STOS+wa             ENC_REP EFL=-t------
ac                     NP   -   -   -   -   LODS+was        SZ8 ENC_REP EFL=-t------
ad                     NP   -   -   -   -   LODS+was            ENC_REP EFL=-t------
ae                     NP   -   -   -   -   SCAS+wa         SZ8 ENC_REPCC EFL=mt-mmmmm
af                     NP   -   -   -   -   SCAS+wa             ENC_REPCC EFL=mt-mmmmm
b0+                    OI   Rb  Ib  -   -   MOVABS          SZ8
b8+                    OI   Rv  Iv  -   -   MOVABS
c0/0                   MI   Eb  Ib  -   -   ROL             SZ8 EFL=m------m
c0/1                   MI   Eb  Ib  -   -   ROR             SZ8 EFL=m------m
c0/2                   MI   Eb  Ib  -   -   RCL             SZ8 EFL=m------M
c0/3                   MI   Eb  Ib  -   -   RCR             SZ8 EFL=m------M
c0/4                   MI   Eb  Ib  -   -   SHL             SZ8 EFL=m--mmumm
c0/5                   MI   Eb  Ib  -   -   SHR             SZ8 EFL=m--mmumm
c0/6                   MI   Eb  Ib  -   -   SHL             SZ8 EFL=m--mmumm
c0/7                   MI   Eb  Ib  -   -   SAR             SZ8 EFL=m--mmumm
c1/0                   MI   Ev  Ib  -   -   ROL                 EFL=m------m
c1/1                   MI   Ev  Ib  -   -   ROR                 EFL=m------m
c1/2                   MI   Ev  Ib  -   -   RCL                 EFL=m------M
c1/3                   MI   Ev  Ib  -   -   RCR                 EFL=m------M
c1/4                   MI   Ev  Ib  -   -   SHL                 EFL=m--mmumm
c1/5                   MI   Ev  Ib  -   -   SHR                 EFL=m--mmumm
c1/6                   MI   Ev  Ib  -   -   SHL                 EFL=m--mmumm
c1/7                   MI   Ev  Ib  -   -   SAR                 EFL=m--mmumm
# RET immediate size handled in code
c2                     I    Iw  -   -   -   RET+w           F64
c3                     NP   -   -   -   -   RET+w           F64
c4/m                   RM   Gv  Mp  -   -   LES         I64
c5/m                   RM   Gv  Mp  -   -   LDS         I64
c6/0                   MI   Eb  Ib  -   -   MOV             SZ8
c6f8                   I    Ib  -   -   -   XABORT              F=HLERTM
c7/0                   MI   Ev  Iz  -   -   MOV
c7f8                   D    Jzd -   -   -   XBEGIN      I64     F=HLERTM
c7f8                   D    Jzq -   -   -   XBEGIN      O64     F=HLERTM
# ENTER immediate handled in code, actually it is Iw,Ib
c8                     I    Id  -   -   -   ENTER+w         D64
c9                     NP   -   -   -   -   LEAVE+w         D64
# RETF immediate size handled in code
ca                     I    Iw  -   -   -   RETF+w
cb                     NP   -   -   -   -   RETF+w
cc                     NP   -   -   -   -   INT3                EFL=--M-----
cd                     I    Ib  -   -   -   INT                 EFL=--M-----
ce                     NP   -   -   -   -   INTO        I64     EFL=t-M-----
cf                     NP   -   -   -   -   IRET+w              EFL=mmmmmmmm
d0/0                   M1   Eb  Ib  -   -   ROL             SZ8 EFL=m------m
d0/1                   M1   Eb  Ib  -   -   ROR             SZ8 EFL=m------m
d0/2                   M1   Eb  Ib  -   -   RCL             SZ8 EFL=m------M
d0/3                   M1   Eb  Ib  -   -   RCR             SZ8 EFL=m------M
d0/4                   M1   Eb  Ib  -   -   SHL             SZ8 EFL=m--mmumm
d0/5                   M1   Eb  Ib  -   -   SHR             SZ8 EFL=m--mmumm
d0/6                   M1   Eb  Ib  -   -   SHL             SZ8 EFL=m--mmumm
d0/7                   M1   Eb  Ib  -   -   SAR             SZ8 EFL=m--mmumm
d1/0                   M1   Ev  Ib  -   -   ROL                 EFL=m------m
d1/1                   M1   Ev  Ib  -   -   ROR                 EFL=m------m
d1/2                   M1   Ev  Ib  -   -   RCL                 EFL=m------M
d1/3                   M1   Ev  Ib  -   -   RCR                 EFL=m------M
d1/4                   M1   Ev  Ib  -   -   SHL                 EFL=m--mmumm
d1/5                   M1   Ev  Ib  -   -   SHR                 EFL=m--mmumm
d1/6                   M1   Ev  Ib  -   -   SHL                 EFL=m--mmumm
d1/7                   M1   Ev  Ib  -   -   SAR                 EFL=m--mmumm
d2/0                   MC   Eb  Rb  -   -   ROL             SZ8 EFL=m------m
d2/1                   MC   Eb  Rb  -   -   ROR             SZ8 EFL=m------m
d2/2                   MC   Eb  Rb  -   -   RCL             SZ8 EFL=m------M
d2/3                   MC   Eb  Rb  -   -   RCR             SZ8 EFL=m------M
d2/4                   MC   Eb  Rb  -   -   SHL             SZ8 EFL=m--mmumm
d2/5                   MC   Eb  Rb  -   -   SHR             SZ8 EFL=m--mmumm
d2/6                   MC   Eb  Rb  -   -   SHL             SZ8 EFL=m--mmumm
d2/7                   MC   Eb  Rb  -   -   SAR             SZ8 EFL=m--mmumm
d3/0                   MC   Ev  Rb  -   -   ROL                 EFL=m------m
d3/1                   MC   Ev  Rb  -   -   ROR                 EFL=m------m
d3/2                   MC   Ev  Rb  -   -   RCL                 EFL=m------M
d3/3                   MC   Ev  Rb  -   -   RCR                 EFL=m------M
d3/4                   MC   Ev  Rb  -   -   SHL                 EFL=m--mmumm
d3/5                   MC   Ev  Rb  -   -   SHR                 EFL=m--mmumm
d3/6                   MC   Ev  Rb  -   -   SHL                 EFL=m--mmumm
d3/7                   MC   Ev  Rb  -   -   SAR                 EFL=m--mmumm
d4                     I    Ib  -   -   -   AAM         I64 SZ8 EFL=u--mmumu
d5                     I    Ib  -   -   -   AAD         I64 SZ8 EFL=u--mmumu
d6                     NP   -   -   -   -   SALC        I64     UNDOC
d7                     NP   -   -   -   -   XLATB+as
#d8-df FPU Escape
e0                     D    Jbs -   -   -   LOOPNZ+a        F64 EFL=----t---
e1                     D    Jbs -   -   -   LOOPZ+a         F64 EFL=----t---
e2                     D    Jbs -   -   -   LOOP+a          F64
e3                     D    Jbs -   -   -   JCXZ+a          F64
e4                     IA   Rb  Ib  -   -   IN              SZ8
e5                     IA   Rz  Ib  -   -   IN
e6                     IA   Rb  Ib  -   -   OUT             SZ8
e7                     IA   Rz  Ib  -   -   OUT
e8                     D    Jz  -   -   -   CALL            F64
e9                     D    Jz  -   -   -   JMP             F64
# Far jmp/call immediate size adjusted in code
ea                     I    Ap  -   -   -   JMPF        I64
eb                     D    Jbs -   -   -   JMP             F64
ec                     NP   -   -   -   -   IN+w            SZ8
ed                     NP   -   -   -   -   IN+w
ee                     NP   -   -   -   -   OUT+w           SZ8
ef                     NP   -   -   -   -   OUT+w
#f0 prefix
f1                     NP   -   -   -   -   INT1                EFL=--M-----
#f2 REPNZ prefix
#f3 REP/REPZ prefix
f4                     NP   -   -   -   -   HLT                 CPL0
f5                     NP   -   -   -   -   CMC                 EFL=-------M
f6/0                   MI   Eb  Ib  -   -   TEST            SZ8 EFL=0--mmum0
f6/1                   MI   Eb  Ib  -   -   TEST            SZ8 EFL=0--mmum0
f6/2                   M    Eb  -   -   -   NOT        LOCK SZ8
f6/3                   M    Eb  -   -   -   NEG        LOCK SZ8 EFL=m--mmmmm
f6/4                   M    Eb  -   -   -   MUL             SZ8 EFL=m--uuuum
f6/5                   M    Eb  -   -   -   IMUL            SZ8 EFL=m--uuuum
f6/6                   M    Eb  -   -   -   DIV             SZ8 EFL=u--uuuuu
f6/7                   M    Eb  -   -   -   IDIV            SZ8 EFL=u--uuuuu
f7/0                   MI   Ev  Iz  -   -   TEST                EFL=0--mmum0
f7/1                   MI   Ev  Iz  -   -   TEST                EFL=0--mmum0
f7/2                   M    Ev  -   -   -   NOT        LOCK
f7/3                   M    Ev  -   -   -   NEG        LOCK     EFL=m--mmmmm
f7/4                   M    Ev  -   -   -   MUL                 EFL=m--uuuum
f7/5                   M    Ev  -   -   -   IMUL                EFL=m--uuuum
f7/6                   M    Ev  -   -   -   DIV                 EFL=u--uuuuu
f7/7                   M    Ev  -   -   -   IDIV                EFL=u--uuuuu
f8                     NP   -   -   -   -   CLC                 EFL=-------0
f9                     NP   -   -   -   -   STC                 EFL=-------1
fa                     NP   -   -   -   -   CLI                 EFL=--0-----
fb                     NP   -   -   -   -   STI                 EFL=--1-----
fc                     NP   -   -   -   -   CLD                 EFL=-0------
fd                     NP   -   -   -   -   STD                 EFL=-1------
fe/0                   M    Eb  -   -   -   INC        LOCK SZ8 EFL=m--mmmm-
fe/1                   M    Eb  -   -   -   DEC        LOCK SZ8 EFL=m--mmmm-
ff/0                   M    Ev  -   -   -   INC        LOCK     EFL=m--mmmm-
ff/1                   M    Ev  -   -   -   DEC        LOCK     EFL=m--mmmm-
ff/2                   M    Ev  -   -   -   CALL            F64
ff/3m                  M    Mp  -   -   -   CALLF
ff/4                   M    Ev  -   -   -   JMP             F64
ff/5m                  M    Mp  -   -   -   JMPF
ff/6                   M    Ev  -   -   -   PUSH            D64
# TODO: SDM states taht SLDT/STR are Rv/Mw (like SMSW), but semantics not verified
0f00/0                 M    Ew  -   -   -   SLDT
0f00/1                 M    Ew  -   -   -   STR
0f00/2                 M    Ew  -   -   -   LLDT                CPL0
0f00/3                 M    Ew  -   -   -   LTR                 CPL0
0f00/4                 M    Ew  -   -   -   VERR                EFL=----m---
0f00/5                 M    Ew  -   -   -   VERW                EFL=----m---
0f01/0m                M    M   -   -   -   SGDT
0f01/1m                M    M   -   -   -   SIDT
0f01/2m                M    M   -   -   -   LGDT                CPL0
0f01/3m                M    M   -   -   -   LIDT                CPL0
0f01/4m                M    Mw  -   -   -   SMSW
0f01/4r                M    Rv  -   -   -   SMSW
0f01/6                 M    Ew  -   -   -   LMSW                CPL0
0f01/7m                M    Mb  -   -   -   INVLPG          SZ8 F=486 CPL0
NP.0f01c0              NP   -   -   -   -   ENCLV               F=SGX
NP.0f01c8              NP   -   -   -   -   MONITOR             F=MONITOR
NP.0f01c9              NP   -   -   -   -   MWAIT               F=MONITOR
NP.0f01ca              NP   -   -   -   -   CLAC                F=SMAP CPL0
NP.0f01cb              NP   -   -   -   -   STAC                F=SMAP CPL0
NP.0f01cf              NP   -   -   -   -   ENCLS               F=SGX
NP.0f01d0              NP   -   -   -   -   XGETBV              F=XSAVE
NP.0f01d1              NP   -   -   -   -   XSETBV              F=XSAVE
NP.0f01d5              NP   -   -   -   -   XEND                F=HLERTM
NP.0f01d6              NP   -   -   -   -   XTEST               F=HLERTM EFL=0--0m000
NP.0f01d7              NP   -   -   -   -   ENCLU               F=SGX
0f01f8                 NP   -   -   -   -   SWAPGS      O64     F=LM
0f01f9                 NP   -   -   -   -   RDTSCP              F=RDTSCP
0f02                   RM   Gv  Ew  -   -   LAR                 EFL=----m---
0f03                   RM   Gv  Ew  -   -   LSL                 EFL=----m---
0f05                   NP   -   -   -   -   SYSCALL     O64     F=LM EFL=MMMMMMMM
0f06                   NP   -   -   -   -   CLTS                CPL0
0f07                   NP   -   -   -   -   SYSRET      O64     F=LM CPL0 EFL=mmmmmmmm
0f08                   NP   -   -   -   -   INVD                F=486 CPL0
*0f09                  NP   -   -   -   -   WBINVD              F=486 CPL0
0f0b                   NP   -   -   -   -   UD2
0f0d/0m                M    Mb  -   -   -   PREFETCH            F=PREFETCH
0f0d/1m                M    Mb  -   -   -   PREFETCHW           F=PREFETCHW
0f0d/2m                M    Mb  -   -   -   PREFETCHWT1         F=PREFETCHWT1
# All other slots are reserved, AMD maps them to /0
*0f0d/m                M    Mb  -   -   -   RESERVED_PREFETCH   ONLYAMD F=PREFETCH
*0f0d/r                MR   Rv  Gv  -   -   RESERVED_NOP
0f0e                   NP   -   -   -   -   FEMMS               ONLYAMD F=3DNOW
# TODO: actually decode 3DNow! instructions. Given that 3DNow! no longer exists,
# this is unlikely to happen, though.
0f0f                   RMI  Pq  Qq  Ib  -   3DNOW               ONLYAMD F=3DNOW
0f18/0m                M    Mb  -   -   -   PREFETCHNTA         F=SSE
0f18/1m                M    Mb  -   -   -   PREFETCHT0          F=SSE
0f18/2m                M    Mb  -   -   -   PREFETCHT1          F=SSE
0f18/3m                M    Mb  -   -   -   PREFETCHT2          F=SSE
0f18/6m                M    Mb  -   -   -   PREFETCHIT1 O64     F=PREFETCHI
0f18/7m                M    Mb  -   -   -   PREFETCHIT0 O64     F=PREFETCHI
# Reserved NOPs are weak, they can be overridden by other instructions.
*0f18                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f19                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f1a                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f1b                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f1c                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f1d                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f1e                  MR   Ev  Gv  -   -   RESERVED_NOP
*0f1f                  MR   Ev  Gv  -   -   RESERVED_NOP
0f1f/0                 M    Ev  -   -   -   NOP
0f20                   MR   Ry  Cy  -   -   MOV_CR2G    I66 D64 CPL0 EFL=u--uuuuu
0f21                   MR   Ry  Dy  -   -   MOV_DR2G    I66 D64 CPL0 EFL=u--uuuuu
0f22                   RM   Cy  Ry  -   -   MOV_G2CR    I66 D64 CPL0 EFL=u--uuuuu
0f23                   RM   Dy  Ry  -   -   MOV_G2DR    I66 D64 CPL0 EFL=u--uuuuu
0f30                   NP   -   -   -   -   WRMSR               F=586 CPL0
0f31                   NP   -   -   -   -   RDTSC               F=586
0f32                   NP   -   -   -   -   RDMSR               F=586 CPL0
0f33                   NP   -   -   -   -   RDPMC               F=686
0f34                   NP   -   -   -   -   SYSENTER            F=686 EFL=--m-----
0f35                   NP   -   -   -   -   SYSEXIT             F=686 CPL0
NP.0f37                NP   -   -   -   -   GETSEC              F=SMX EFL=MMMMMMMM
# 0f38, 0f3a are escape opcodes
0f40                   RM   Gv  Ev  -   -   CMOVO               F=CMOV EFL=t------- ENC_CC_BEGIN
0f41                   RM   Gv  Ev  -   -   CMOVNO              F=CMOV EFL=t-------
0f42                   RM   Gv  Ev  -   -   CMOVC               F=CMOV EFL=-------t
0f43                   RM   Gv  Ev  -   -   CMOVNC              F=CMOV EFL=-------t
0f44                   RM   Gv  Ev  -   -   CMOVZ               F=CMOV EFL=----t---
0f45                   RM   Gv  Ev  -   -   CMOVNZ              F=CMOV EFL=----t---
0f46                   RM   Gv  Ev  -   -   CMOVBE              F=CMOV EFL=----t--t
0f47                   RM   Gv  Ev  -   -   CMOVA               F=CMOV EFL=----t--t
0f48                   RM   Gv  Ev  -   -   CMOVS               F=CMOV EFL=---t----
0f49                   RM   Gv  Ev  -   -   CMOVNS              F=CMOV EFL=---t----
0f4a                   RM   Gv  Ev  -   -   CMOVP               F=CMOV EFL=------t-
0f4b                   RM   Gv  Ev  -   -   CMOVNP              F=CMOV EFL=------t-
0f4c                   RM   Gv  Ev  -   -   CMOVL               F=CMOV EFL=t--t----
0f4d                   RM   Gv  Ev  -   -   CMOVGE              F=CMOV EFL=t--t----
0f4e                   RM   Gv  Ev  -   -   CMOVLE              F=CMOV EFL=t--tt---
0f4f                   RM   Gv  Ev  -   -   CMOVG               F=CMOV EFL=t--tt---
0f80                   D    Jz  -   -   -   JO              F64 EFL=t------- ENC_CC_BEGIN
0f81                   D    Jz  -   -   -   JNO             F64 EFL=t-------
0f82                   D    Jz  -   -   -   JC              F64 EFL=-------t
0f83                   D    Jz  -   -   -   JNC             F64 EFL=-------t
0f84                   D    Jz  -   -   -   JZ              F64 EFL=----t---
0f85                   D    Jz  -   -   -   JNZ             F64 EFL=----t---
0f86                   D    Jz  -   -   -   JBE             F64 EFL=----t--t
0f87                   D    Jz  -   -   -   JA              F64 EFL=----t--t
0f88                   D    Jz  -   -   -   JS              F64 EFL=---t----
0f89                   D    Jz  -   -   -   JNS             F64 EFL=---t----
0f8a                   D    Jz  -   -   -   JP              F64 EFL=------t-
0f8b                   D    Jz  -   -   -   JNP             F64 EFL=------t-
0f8c                   D    Jz  -   -   -   JL              F64 EFL=t--t----
0f8d                   D    Jz  -   -   -   JGE             F64 EFL=t--t----
0f8e                   D    Jz  -   -   -   JLE             F64 EFL=t--tt---
0f8f                   D    Jz  -   -   -   JG              F64 EFL=t--tt---
0f90                   M    Eb  -   -   -   SETO            SZ8 EFL=t------- ENC_CC_BEGIN
0f91                   M    Eb  -   -   -   SETNO           SZ8 EFL=t-------
0f92                   M    Eb  -   -   -   SETC            SZ8 EFL=-------t
0f93                   M    Eb  -   -   -   SETNC           SZ8 EFL=-------t
0f94                   M    Eb  -   -   -   SETZ            SZ8 EFL=----t---
0f95                   M    Eb  -   -   -   SETNZ           SZ8 EFL=----t---
0f96                   M    Eb  -   -   -   SETBE           SZ8 EFL=----t--t
0f97                   M    Eb  -   -   -   SETA            SZ8 EFL=----t--t
0f98                   M    Eb  -   -   -   SETS            SZ8 EFL=---t----
0f99                   M    Eb  -   -   -   SETNS           SZ8 EFL=---t----
0f9a                   M    Eb  -   -   -   SETP            SZ8 EFL=------t-
0f9b                   M    Eb  -   -   -   SETNP           SZ8 EFL=------t-
0f9c                   M    Eb  -   -   -   SETL            SZ8 EFL=t--t----
0f9d                   M    Eb  -   -   -   SETGE           SZ8 EFL=t--t----
0f9e                   M    Eb  -   -   -   SETLE           SZ8 EFL=t--tt---
0f9f                   M    Eb  -   -   -   SETG            SZ8 EFL=t--tt---
0fa0                   S    Sv  -   -   -   PUSH_SEG        D64
0fa1                   S    Sv  -   -   -   POP_SEG         D64
0fa2                   NP   -   -   -   -   CPUID               F=586
0fa3                   MR   Ev  Gv  -   -   BT                  EFL=u--u-uum
0fa4                   MRI  Ev  Gv  Ib  -   SHLD                EFL=u--mmumm
0fa5                   MRC  Ev  Gv  Rb  -   SHLD                EFL=u--mmumm
0fa8                   S    Sv  -   -   -   PUSH_SEG        D64
0fa9                   S    Sv  -   -   -   POP_SEG         D64
0faa                   NP   -   -   -   -   RSM                 F=586
0fab                   MR   Ev  Gv  -   -   BTS        LOCK     EFL=u--u-uum
0fac                   MRI  Ev  Gv  Ib  -   SHRD                EFL=u--mmumm
0fad                   MRC  Ev  Gv  Rb  -   SHRD                EFL=u--mmumm
0faf                   RM   Gv  Ev  -   -   IMUL                EFL=m--uuuum
0fb0                   MR   Eb  Gb  -   -   CMPXCHG    LOCK SZ8 F=486 EFL=m--mmmmm
0fb1                   MR   Ev  Gv  -   -   CMPXCHG    LOCK     F=486 EFL=m--mmmmm
0fb2/m                 RM   Gv  Mp  -   -   LSS
0fb3                   MR   Ev  Gv  -   -   BTR        LOCK     EFL=u--u-uum
0fb4/m                 RM   Gv  Mp  -   -   LFS
0fb5/m                 RM   Gv  Mp  -   -   LGS
0fb6                   RM   Gv  Eb  -   -   MOVZX               ENC_SEPSZ
0fb7                   RM   Gv  Ew  -   -   MOVZX               ENC_SEPSZ
F3.0fb8                RM   Gv  Ev  -   -   POPCNT          U66 F=POPCNT EFL=0--0m000
0fb9                   RM   Gv  Ev  -   -   UD1
0fba/4                 MI   Ev  Ib  -   -   BT                  EFL=u--u-uum
0fba/5                 MI   Ev  Ib  -   -   BTS        LOCK     EFL=u--u-uum
0fba/6                 MI   Ev  Ib  -   -   BTR        LOCK     EFL=u--u-uum
0fba/7                 MI   Ev  Ib  -   -   BTC        LOCK     EFL=u--u-uum
0fbb                   MR   Ev  Gv  -   -   BTC        LOCK     EFL=u--u-uum
*0fbc                  RM   Gv  Ev  -   -   BSF                 EFL=u--umuuu
F3.0fbc                RM   Gv  Ev  -   -   TZCNT           U66 F=BMI1 EFL=u--umuum
*0fbd                  RM   Gv  Ev  -   -   BSR                 EFL=u--umuuu
F3.0fbd                RM   Gv  Ev  -   -   LZCNT           U66 F=LZCNT EFL=u--umuum
0fbe                   RM   Gv  Eb  -   -   MOVSX               ENC_SEPSZ
0fbf                   RM   Gv  Ew  -   -   MOVSX               ENC_SEPSZ
0fc0                   MR   Eb  Gb  -   -   XADD       LOCK SZ8 F=486 EFL=m--mmmmm
0fc1                   MR   Ev  Gv  -   -   XADD       LOCK     F=486 EFL=m--mmmmm
NP.0fc3/m              MR   My  Gy  -   -   MOVNTI              F=SSE2
0fc7/1m                M    M   -   -   -   CMPXCHGD+w LOCK I66 F=586 EFL=----m---
0fc8+                  O    Rv  -   -   -   BSWAP               F=486
0fff                   RM   Gv  Ev  -   -   UD0
#
NFx.0f38f0/m           RM   Gv  Mv  -   -   MOVBE               F=MOVBE
F2.0f38f0              RM   Gd  Eb  -   -   CRC32           SZ8 F=SSE42
NFx.0f38f1/m           MR   Mv  Gv  -   -   MOVBE               F=MOVBE
F2.0f38f1              RM   Gd  Ev  -   -   CRC32           U66 F=SSE42
#
# MMX
NP.0f2a                RM   Vq  Qq  -   -   MMX_CVTPI2PS        F=SSE2
66.0f2a                RM   Vdq Qq  -   -   MMX_CVTPI2PD        F=SSE2
NP.0f2c                RM   Pq  Wq  -   -   MMX_CVTTPS2PI       F=SSE2
66.0f2c                RM   Pq  Wdq -   -   MMX_CVTTPD2PI       F=SSE2
NP.0f2d                RM   Pq  Wq  -   -   MMX_CVTPS2PI        F=SSE2
66.0f2d                RM   Pq  Wdq -   -   MMX_CVTPD2PI        F=SSE2
NP.0f60                RM   Pq  Qd  -   -   MMX_PUNPCKLBW       F=MMX
NP.0f61                RM   Pq  Qd  -   -   MMX_PUNPCKLWD       F=MMX
NP.0f62                RM   Pq  Qd  -   -   MMX_PUNPCKLDQ       F=MMX
NP.0f63                RM   Pq  Qq  -   -   MMX_PACKSSWB        F=MMX
NP.0f64                RM   Pq  Qq  -   -   MMX_PCMPGTB         F=MMX
NP.0f65                RM   Pq  Qq  -   -   MMX_PCMPGTW         F=MMX
NP.0f66                RM   Pq  Qq  -   -   MMX_PCMPGTD         F=MMX
NP.0f67                RM   Pq  Qq  -   -   MMX_PACKUSWB        F=MMX
NP.0f68                RM   Pq  Qq  -   -   MMX_PUNPCKHBW       F=MMX
NP.0f69                RM   Pq  Qq  -   -   MMX_PUNPCKHWD       F=MMX
NP.0f6a                RM   Pq  Qq  -   -   MMX_PUNPCKHDQ       F=MMX
NP.0f6b                RM   Pq  Qq  -   -   MMX_PACKSSDW        F=MMX
NP.W0.0f6e             RM   Pq  Ey  -   -   MMX_MOVD_G2M        F=MMX ENC_NOSZ
NP.W1.0f6e             RM   Pq  Ey  -   -   MMX_MOVQ_G2M        F=MMX ENC_NOSZ
NP.0f6f                RM   Pq  Qq  -   -   MMX_MOVQ            F=MMX
NP.0f70                RMI  Pq  Qq  Ib  -   MMX_PSHUFW          F=SSE
NP.0f71/2r             MI   Nq  Ib  -   -   MMX_PSRLW           F=MMX
NP.0f71/4r             MI   Nq  Ib  -   -   MMX_PSRAW           F=MMX
NP.0f71/6r             MI   Nq  Ib  -   -   MMX_PSLLW           F=MMX
NP.0f72/2r             MI   Nq  Ib  -   -   MMX_PSRLD           F=MMX
NP.0f72/4r             MI   Nq  Ib  -   -   MMX_PSRAD           F=MMX
NP.0f72/6r             MI   Nq  Ib  -   -   MMX_PSLLD           F=MMX
NP.0f73/2r             MI   Nq  Ib  -   -   MMX_PSRLQ           F=MMX
NP.0f73/6r             MI   Nq  Ib  -   -   MMX_PSLLQ           F=MMX
NP.0f74                RM   Pq  Qq  -   -   MMX_PCMPEQB         F=MMX
NP.0f75                RM   Pq  Qq  -   -   MMX_PCMPEQW         F=MMX
NP.0f76                RM   Pq  Qq  -   -   MMX_PCMPEQD         F=MMX
NP.0f77                NP   -   -   -   -   MMX_EMMS            F=MMX
NP.W0.0f7e             MR   Ey  Py  -   -   MMX_MOVD_M2G        F=MMX ENC_NOSZ
NP.W1.0f7e             MR   Ey  Py  -   -   MMX_MOVQ_M2G        F=MMX ENC_NOSZ
NP.0f7f                MR   Qq  Pq  -   -   MMX_MOVQ            F=MMX
NP.0fc4                RMI  Pq  Ew  Ib  -   MMX_PINSRW          F=SSE ENC_NOSZ
NP.0fc5/r              RMI  Gy  Nq  Ib  -   MMX_PEXTRW      D64 F=SSE
NP.0fd1                RM   Pq  Qq  -   -   MMX_PSRLW           F=MMX
NP.0fd2                RM   Pq  Qq  -   -   MMX_PSRLD           F=MMX
NP.0fd3                RM   Pq  Qq  -   -   MMX_PSRLQ           F=MMX
NP.0fd4                RM   Pq  Qq  -   -   MMX_PADDQ           F=MMX
NP.0fd5                RM   Pq  Qq  -   -   MMX_PMULLW          F=MMX
F2.0fd6/r              RM   Pq  Uq  -   -   MMX_MOVDQ2Q         F=SSE
F3.0fd6/r              RM   Vdq Nq  -   -   MMX_MOVQ2DQ         F=SSE
NP.0fd7/r              RM   Gv  Nq  -   -   MMX_PMOVMSKB    D64 F=SSE
NP.0fd8                RM   Pq  Qq  -   -   MMX_PSUBUSB         F=MMX
NP.0fd9                RM   Pq  Qq  -   -   MMX_PSUBUSW         F=MMX
NP.0fda                RM   Pq  Qq  -   -   MMX_PMINUB          F=SSE
NP.0fdb                RM   Pq  Qq  -   -   MMX_PAND            F=MMX
NP.0fdc                RM   Pq  Qq  -   -   MMX_PADDUSB         F=MMX
NP.0fdd                RM   Pq  Qq  -   -   MMX_PADDUSW         F=MMX
NP.0fde                RM   Pq  Qq  -   -   MMX_PMAXUB          F=SSE
NP.0fdf                RM   Pq  Qq  -   -   MMX_PANDN           F=MMX
NP.0fe0                RM   Pq  Qq  -   -   MMX_PAVGB           F=SSE
NP.0fe1                RM   Pq  Qq  -   -   MMX_PSRAW           F=MMX
NP.0fe2                RM   Pq  Qq  -   -   MMX_PSRAD           F=MMX
NP.0fe3                RM   Pq  Qq  -   -   MMX_PAVGW           F=SSE
NP.0fe4                RM   Pq  Qq  -   -   MMX_PMULHUW         F=SSE
NP.0fe5                RM   Pq  Qq  -   -   MMX_PMULHW          F=MMX
NP.0fe7/m              MR   Mq  Pq  -   -   MMX_MOVNTQ          F=SSE
NP.0fe8                RM   Pq  Qq  -   -   MMX_PSUBSB          F=MMX
NP.0fe9                RM   Pq  Qq  -   -   MMX_PSUBSW          F=MMX
NP.0feb                RM   Pq  Qq  -   -   MMX_POR             F=MMX
NP.0fec                RM   Pq  Qq  -   -   MMX_PADDSB          F=MMX
NP.0fea                RM   Pq  Qq  -   -   MMX_PMINSW          F=SSE
NP.0fee                RM   Pq  Qq  -   -   MMX_PMAXSW          F=SSE
NP.0fed                RM   Pq  Qq  -   -   MMX_PADDSW          F=MMX
NP.0fef                RM   Pq  Qq  -   -   MMX_PXOR            F=MMX
NP.0ff1                RM   Pq  Qq  -   -   MMX_PSLLW           F=MMX
NP.0ff2                RM   Pq  Qq  -   -   MMX_PSLLD           F=MMX
NP.0ff3                RM   Pq  Qq  -   -   MMX_PSLLQ           F=MMX
NP.0ff4                RM   Pq  Qq  -   -   MMX_PMULUDQ         F=MMX
NP.0ff5                RM   Pq  Qq  -   -   MMX_PMADDWD         F=MMX
NP.0ff6                RM   Pq  Qq  -   -   MMX_PSADBW          F=SSE
NP.0ff7/r              RM   Pq  Nq  -   -   MMX_MASKMOVQ+as     F=SSE
NP.0ff8                RM   Pq  Qq  -   -   MMX_PSUBB           F=MMX
NP.0ff9                RM   Pq  Qq  -   -   MMX_PSUBW           F=MMX
NP.0ffa                RM   Pq  Qq  -   -   MMX_PSUBD           F=MMX
NP.0ffb                RM   Pq  Qq  -   -   MMX_PSUBQ           F=MMX
NP.0ffc                RM   Pq  Qq  -   -   MMX_PADDB           F=MMX
NP.0ffd                RM   Pq  Qq  -   -   MMX_PADDW           F=MMX
NP.0ffe                RM   Pq  Qq  -   -   MMX_PADDD           F=MMX
NP.0f3800              RM   Pq  Qq  -   -   MMX_PSHUFB          F=SSSE3
NP.0f3801              RM   Pq  Qq  -   -   MMX_PHADDW          F=SSSE3
NP.0f3802              RM   Pq  Qq  -   -   MMX_PHADDD          F=SSSE3
NP.0f3803              RM   Pq  Qq  -   -   MMX_PHADDSW         F=SSSE3
NP.0f3804              RM   Pq  Qq  -   -   MMX_PMADDUBSW       F=SSSE3
NP.0f3805              RM   Pq  Qq  -   -   MMX_PHSUBW          F=SSSE3
NP.0f3806              RM   Pq  Qq  -   -   MMX_PHSUBD          F=SSSE3
NP.0f3807              RM   Pq  Qq  -   -   MMX_PHSUBSW         F=SSSE3
NP.0f3808              RM   Pq  Qq  -   -   MMX_PSIGNB          F=SSSE3
NP.0f3809              RM   Pq  Qq  -   -   MMX_PSIGNW          F=SSSE3
NP.0f380a              RM   Pq  Qq  -   -   MMX_PSIGND          F=SSSE3
NP.0f380b              RM   Pq  Qq  -   -   MMX_PMULHRSW        F=SSSE3
NP.0f381c              RM   Pq  Qq  -   -   MMX_PABSB           F=SSSE3
NP.0f381d              RM   Pq  Qq  -   -   MMX_PABSW           F=SSSE3
NP.0f381e              RM   Pq  Qq  -   -   MMX_PABSD           F=SSSE3
NP.0f3a0f              RMI  Pq  Qq  Ib  -   MMX_PALIGNR         F=SSSE3
#
# SSE
NP.0f10                RM   Vps Wps -   -   SSE_MOVUPS          F=SSE
66.0f10                RM   Vpd Wpd -   -   SSE_MOVUPD          F=SSE2
# MOVSS/MOVSD reg,mem set the full XMM register
F3.0f10                RM   Vx  Wss -   -   SSE_MOVSS           F=SSE
F2.0f10                RM   Vx  Wsd -   -   SSE_MOVSD           F=SSE2
NP.0f11                MR   Wps Vps -   -   SSE_MOVUPS          F=SSE
66.0f11                MR   Wpd Vpd -   -   SSE_MOVUPD          F=SSE2
F3.0f11                MR   Wss Vss -   -   SSE_MOVSS           F=SSE
F2.0f11                MR   Wsd Vsd -   -   SSE_MOVSD           F=SSE2
NP.0f12/m              RM   Vx  Mq  -   -   SSE_MOVLPS          F=SSE
NP.0f12/r              RM   Vx  Ux  -   -   SSE_MOVHLPS         F=SSE
66.0f12/m              RM   Vx  Mq  -   -   SSE_MOVLPD          F=SSE2
F3.0f12                RM   Vx  Wx  -   -   SSE_MOVSLDUP        F=SSE3
F2.0f12                RM   Vx  Wq  -   -   SSE_MOVDDUP         F=SSE3
NP.0f13/m              MR   Mq  Vq  -   -   SSE_MOVLPS          F=SSE
66.0f13/m              MR   Mq  Vq  -   -   SSE_MOVLPD          F=SSE2
NP.0f14                RM   Vps Wps -   -   SSE_UNPCKLPS        F=SSE
66.0f14                RM   Vpd Wpd -   -   SSE_UNPCKLPD        F=SSE2
NP.0f15                RM   Vps Wps -   -   SSE_UNPCKHPS        F=SSE
66.0f15                RM   Vpd Wpd -   -   SSE_UNPCKHPD        F=SSE2
NP.0f16/m              RM   Vx  Mq  -   -   SSE_MOVHPS          F=SSE
NP.0f16/r              RM   Vx  Uq  -   -   SSE_MOVLHPS         F=SSE
66.0f16/m              RM   Vdq Mq  -   -   SSE_MOVHPD          F=SSE2
F3.0f16                RM   Vx  Wx  -   -   SSE_MOVSHDUP        F=SSE3
NP.0f17/m              MR   Mq  Vx  -   -   SSE_MOVHPS          F=SSE
66.0f17/m              MR   Mq  Vx  -   -   SSE_MOVHPD          F=SSE2
NP.0f28                RM   Vps Wps -   -   SSE_MOVAPS          F=SSE
66.0f28                RM   Vpd Wpd -   -   SSE_MOVAPD          F=SSE2
NP.0f29                MR   Wps Vps -   -   SSE_MOVAPS          F=SSE
66.0f29                MR   Wpd Vpd -   -   SSE_MOVAPD          F=SSE2
F3.0f2a                RM   Vss Ey  -   -   SSE_CVTSI2SS        F=SSE
F2.0f2a                RM   Vsd Ey  -   -   SSE_CVTSI2SD        F=SSE2
NP.0f2b/m              MR   Mps Vps -   -   SSE_MOVNTPS         F=SSE
66.0f2b/m              MR   Mpd Vpd -   -   SSE_MOVNTPD         F=SSE2
F3.0f2b/m              MR   Mss Vss -   -   SSE_MOVNTSS         F=SSE ONLYAMD
F2.0f2b/m              MR   Msd Vsd -   -   SSE_MOVNTSD         F=SSE2 ONLYAMD
F3.0f2c                RM   Gy  Wss -   -   SSE_CVTTSS2SI       F=SSE
F2.0f2c                RM   Gy  Wsd -   -   SSE_CVTTSD2SI       F=SSE2
F3.0f2d                RM   Gy  Wss -   -   SSE_CVTSS2SI        F=SSE
F2.0f2d                RM   Gy  Wsd -   -   SSE_CVTSD2SI        F=SSE2
NP.0f2e                RM   Vss Wss -   -   SSE_UCOMISS         F=SSE EFL=0--0m0mm
66.0f2e                RM   Vsd Wsd -   -   SSE_UCOMISD         F=SSE2 EFL=0--0m0mm
NP.0f2f                RM   Vss Wss -   -   SSE_COMISS          F=SSE EFL=0--0m0mm
66.0f2f                RM   Vsd Wsd -   -   SSE_COMISD          F=SSE2 EFL=0--0m0mm
NP.0f50/r              RM   Gy  Udq -   -   SSE_MOVMSKPS    D64 F=SSE
66.0f50/r              RM   Gy  Udq -   -   SSE_MOVMSKPD    D64 F=SSE2
NP.0f51                RM   Vps Wps -   -   SSE_SQRTPS          F=SSE
66.0f51                RM   Vpd Wpd -   -   SSE_SQRTPD          F=SSE2
F3.0f51                RM   Vss Wss -   -   SSE_SQRTSS          F=SSE
F2.0f51                RM   Vsd Wsd -   -   SSE_SQRTSD          F=SSE2
NP.0f52                RM   Vps Wps -   -   SSE_RSQRTPS         F=SSE
F3.0f52                RM   Vss Wss -   -   SSE_RSQRTSS         F=SSE
NP.0f53                RM   Vps Wps -   -   SSE_RCPPS           F=SSE
F3.0f53                RM   Vss Wss -   -   SSE_RCPSS           F=SSE
NP.0f54                RM   Vps Wps -   -   SSE_ANDPS           F=SSE
66.0f54                RM   Vpd Wpd -   -   SSE_ANDPD           F=SSE2
NP.0f55                RM   Vps Wps -   -   SSE_ANDNPS          F=SSE
66.0f55                RM   Vpd Wpd -   -   SSE_ANDNPD          F=SSE2
NP.0f56                RM   Vps Wps -   -   SSE_ORPS            F=SSE
66.0f56                RM   Vpd Wpd -   -   SSE_ORPD            F=SSE2
NP.0f57                RM   Vps Wps -   -   SSE_XORPS           F=SSE
66.0f57                RM   Vpd Wpd -   -   SSE_XORPD           F=SSE2
NP.0f58                RM   Vps Wps -   -   SSE_ADDPS           F=SSE
66.0f58                RM   Vpd Wpd -   -   SSE_ADDPD           F=SSE2
F3.0f58                RM   Vss Wss -   -   SSE_ADDSS           F=SSE
F2.0f58                RM   Vsd Wsd -   -   SSE_ADDSD           F=SSE2
NP.0f59                RM   Vps Wps -   -   SSE_MULPS           F=SSE
66.0f59                RM   Vpd Wpd -   -   SSE_MULPD           F=SSE2
F3.0f59                RM   Vss Wss -   -   SSE_MULSS           F=SSE
F2.0f59                RM   Vsd Wsd -   -   SSE_MULSD           F=SSE2
NP.0f5a                RM   Vpd Wq  -   -   SSE_CVTPS2PD        F=SSE2
66.0f5a                RM   Vps Wpd -   -   SSE_CVTPD2PS        F=SSE2
F3.0f5a                RM   Vsd Wss -   -   SSE_CVTSS2SD        F=SSE2
F2.0f5a                RM   Vss Wsd -   -   SSE_CVTSD2SS        F=SSE2
NP.0f5b                RM   Vps Wdq -   -   SSE_CVTDQ2PS        F=SSE2
66.0f5b                RM   Vdq Wps -   -   SSE_CVTPS2DQ        F=SSE2
F3.0f5b                RM   Vdq Wps -   -   SSE_CVTTPS2DQ       F=SSE2
NP.0f5c                RM   Vps Wps -   -   SSE_SUBPS           F=SSE
66.0f5c                RM   Vpd Wpd -   -   SSE_SUBPD           F=SSE2
F3.0f5c                RM   Vss Wss -   -   SSE_SUBSS           F=SSE
F2.0f5c                RM   Vsd Wsd -   -   SSE_SUBSD           F=SSE2
NP.0f5d                RM   Vps Wps -   -   SSE_MINPS           F=SSE
66.0f5d                RM   Vpd Wpd -   -   SSE_MINPD           F=SSE2
F3.0f5d                RM   Vss Wss -   -   SSE_MINSS           F=SSE
F2.0f5d                RM   Vsd Wsd -   -   SSE_MINSD           F=SSE2
NP.0f5e                RM   Vps Wps -   -   SSE_DIVPS           F=SSE
66.0f5e                RM   Vpd Wpd -   -   SSE_DIVPD           F=SSE2
F3.0f5e                RM   Vss Wss -   -   SSE_DIVSS           F=SSE
F2.0f5e                RM   Vsd Wsd -   -   SSE_DIVSD           F=SSE2
NP.0f5f                RM   Vps Wps -   -   SSE_MAXPS           F=SSE
66.0f5f                RM   Vpd Wpd -   -   SSE_MAXPD           F=SSE2
F3.0f5f                RM   Vss Wss -   -   SSE_MAXSS           F=SSE
F2.0f5f                RM   Vsd Wsd -   -   SSE_MAXSD           F=SSE2
66.0f60                RM   Vx  Wx  -   -   SSE_PUNPCKLBW       F=SSE2
66.0f61                RM   Vx  Wx  -   -   SSE_PUNPCKLWD       F=SSE2
66.0f62                RM   Vx  Wx  -   -   SSE_PUNPCKLDQ       F=SSE2
66.0f63                RM   Vx  Wx  -   -   SSE_PACKSSWB        F=SSE2
66.0f64                RM   Vx  Wx  -   -   SSE_PCMPGTB         F=SSE2
66.0f65                RM   Vx  Wx  -   -   SSE_PCMPGTW         F=SSE2
66.0f66                RM   Vx  Wx  -   -   SSE_PCMPGTD         F=SSE2
66.0f67                RM   Vx  Wx  -   -   SSE_PACKUSWB        F=SSE2
66.0f68                RM   Vx  Wx  -   -   SSE_PUNPCKHBW       F=SSE2
66.0f69                RM   Vx  Wx  -   -   SSE_PUNPCKHWD       F=SSE2
66.0f6a                RM   Vx  Wx  -   -   SSE_PUNPCKHDQ       F=SSE2
66.0f6b                RM   Vx  Wx  -   -   SSE_PACKSSDW        F=SSE2
66.0f6c                RM   Vx  Wx  -   -   SSE_PUNPCKLQDQ      F=SSE2
66.0f6d                RM   Vx  Wx  -   -   SSE_PUNPCKHQDQ      F=SSE2
66.W0.0f6e             RM   Vx  Ed  -   -   SSE_MOVD_G2X        F=SSE2 ENC_NOSZ
66.W1.0f6e             RM   Vx  Eq  -   -   SSE_MOVQ_G2X        F=SSE2 ENC_NOSZ
66.0f6f                RM   Vx  Wx  -   -   SSE_MOVDQA          F=SSE2
F3.0f6f                RM   Vx  Wx  -   -   SSE_MOVDQU          F=SSE2
66.0f70                RMI  Vx  Wx  Ib  -   SSE_PSHUFD          F=SSE2
F3.0f70                RMI  Vx  Wx  Ib  -   SSE_PSHUFHW         F=SSE2
F2.0f70                RMI  Vx  Wx  Ib  -   SSE_PSHUFLW         F=SSE2
66.0f71/2r             MI   Ux  Ib  -   -   SSE_PSRLW           F=SSE2
66.0f71/4r             MI   Ux  Ib  -   -   SSE_PSRAW           F=SSE2
66.0f71/6r             MI   Ux  Ib  -   -   SSE_PSLLW           F=SSE2
66.0f72/2r             MI   Ux  Ib  -   -   SSE_PSRLD           F=SSE2
66.0f72/4r             MI   Ux  Ib  -   -   SSE_PSRAD           F=SSE2
66.0f72/6r             MI   Ux  Ib  -   -   SSE_PSLLD           F=SSE2
66.0f73/2r             MI   Ux  Ib  -   -   SSE_PSRLQ           F=SSE2
66.0f73/3r             MI   Ux  Ib  -   -   SSE_PSRLDQ          F=SSE2
66.0f73/6r             MI   Ux  Ib  -   -   SSE_PSLLQ           F=SSE2
66.0f73/7r             MI   Ux  Ib  -   -   SSE_PSLLDQ          F=SSE2
66.0f74                RM   Vx  Wx  -   -   SSE_PCMPEQB         F=SSE2
66.0f75                RM   Vx  Wx  -   -   SSE_PCMPEQW         F=SSE2
66.0f76                RM   Vx  Wx  -   -   SSE_PCMPEQD         F=SSE2
# EXTRQ/INSERTQ immediate size handled in code.
66.0f78/0r             MI   Ux  Iw  -   -   SSE_EXTRQ           F=SSE4A ONLYAMD
F2.0f78/r              RMI  Vx  Ux  Iw  -   SSE_INSERTQ         F=SSE4A ONLYAMD
66.0f79/r              RM   Vx  Ux  -   -   SSE_EXTRQ           F=SSE4A ONLYAMD
F2.0f79/r              RM   Vx  Ux  -   -   SSE_INSERTQ         F=SSE4A ONLYAMD
66.0f7c                RM   Vx  Wx  -   -   SSE_HADDPD          F=SSE3
F2.0f7c                RM   Vx  Wx  -   -   SSE_HADDPS          F=SSE3
66.0f7d                RM   Vx  Wx  -   -   SSE_HSUBPD          F=SSE3
F2.0f7d                RM   Vx  Wx  -   -   SSE_HSUBPS          F=SSE3
66.W0.0f7e             MR   Ey  Vy  -   -   SSE_MOVD_X2G        F=SSE2 ENC_NOSZ
66.W1.0f7e             MR   Ey  Vy  -   -   SSE_MOVQ_X2G        F=SSE2 ENC_NOSZ
F3.0f7e                RM   Vx  Wq  -   -   SSE_MOVQ            F=SSE2
66.0f7f                MR   Wx  Vx  -   -   SSE_MOVDQA          F=SSE2
F3.0f7f                MR   Wx  Vx  -   -   SSE_MOVDQU          F=SSE2
NP.0fae/0m             M    M   -   -   -   FXSAVE+w            F=FXSR
NP.0fae/1m             M    M   -   -   -   FXRSTOR+w           F=FXSR
NP.0fae/2m             M    Md  -   -   -   LDMXCSR             F=SSE
NP.0fae/3m             M    Md  -   -   -   STMXCSR             F=SSE
NP.0faee8+             NP   -   -   -   -   LFENCE              F=SSE2
NP.0faef0+             NP   -   -   -   -   MFENCE              F=SSE2
NP.0faef8+             NP   -   -   -   -   SFENCE              F=SSE
NP.0fc2                RMI  Vps Wps Ib  -   SSE_CMPPS           F=SSE
66.0fc2                RMI  Vpd Wpd Ib  -   SSE_CMPPD           F=SSE2
F3.0fc2                RMI  Vss Wss Ib  -   SSE_CMPSS           F=SSE
F2.0fc2                RMI  Vsd Wsd Ib  -   SSE_CMPSD           F=SSE2
66.0fc4                RMI  Vx  Ew  Ib  -   SSE_PINSRW          F=SSE2 ENC_NOSZ
66.0fc5/r              RMI  Gy  Udq Ib  -   SSE_PEXTRW      D64 F=SSE2 ENC_NOSZ
NP.0fc6                RMI  Vps Wps Ib  -   SSE_SHUFPS          F=SSE
66.0fc6                RMI  Vpd Wpd Ib  -   SSE_SHUFPD          F=SSE2
66.0fd0                RM   Vps Wps -   -   SSE_ADDSUBPD        F=SSE3
F2.0fd0                RM   Vpd Wpd -   -   SSE_ADDSUBPS        F=SSE3
66.0fd1                RM   Vx  Wx  -   -   SSE_PSRLW           F=SSE2
66.0fd2                RM   Vx  Wx  -   -   SSE_PSRLD           F=SSE2
66.0fd3                RM   Vx  Wx  -   -   SSE_PSRLQ           F=SSE2
66.0fd4                RM   Vx  Wx  -   -   SSE_PADDQ           F=SSE2
66.0fd5                RM   Vx  Wx  -   -   SSE_PMULLW          F=SSE2
# This is tricky, MOVQ to mem writes 64 bits, MOVQ to reg writes 128 bits
66.0fd6                MR   Wq  Vq  -   -   SSE_MOVQ            F=SSE2
66.0fd7/r              RM   Gy  Udq -   -   SSE_PMOVMSKB    D64 F=SSE2
66.0fd8                RM   Vx  Wx  -   -   SSE_PSUBUSB         F=SSE2
66.0fd9                RM   Vx  Wx  -   -   SSE_PSUBUSW         F=SSE2
66.0fda                RM   Vx  Wx  -   -   SSE_PMINUB          F=SSE2
66.0fdb                RM   Vx  Wx  -   -   SSE_PAND            F=SSE2
66.0fdc                RM   Vx  Wx  -   -   SSE_PADDUSB         F=SSE2
66.0fdd                RM   Vx  Wx  -   -   SSE_PADDUSW         F=SSE2
66.0fde                RM   Vx  Wx  -   -   SSE_PMAXUB          F=SSE2
66.0fdf                RM   Vx  Wx  -   -   SSE_PANDN           F=SSE2
66.0fe0                RM   Vx  Wx  -   -   SSE_PAVGB           F=SSE2
66.0fe1                RM   Vx  Wx  -   -   SSE_PSRAW           F=SSE2
66.0fe2                RM   Vx  Wx  -   -   SSE_PSRAD           F=SSE2
66.0fe3                RM   Vx  Wx  -   -   SSE_PAVGW           F=SSE2
66.0fe4                RM   Vx  Wx  -   -   SSE_PMULHUW         F=SSE2
66.0fe5                RM   Vx  Wx  -   -   SSE_PMULHW          F=SSE2
66.0fe6                RM   Vx  Wpd -   -   SSE_CVTTPD2DQ       F=SSE2
F3.0fe6                RM   Vpd Wq  -   -   SSE_CVTDQ2PD        F=SSE2
F2.0fe6                RM   Vx  Wpd -   -   SSE_CVTPD2DQ        F=SSE2
66.0fe7/m              MR   Mx  Vx  -   -   SSE_MOVNTDQ         F=SSE2
66.0fe8                RM   Vx  Wx  -   -   SSE_PSUBSB          F=SSE2
66.0fe9                RM   Vx  Wx  -   -   SSE_PSUBSW          F=SSE2
66.0feb                RM   Vx  Wx  -   -   SSE_POR             F=SSE2
66.0fec                RM   Vx  Wx  -   -   SSE_PADDSB          F=SSE2
66.0fea                RM   Vx  Wx  -   -   SSE_PMINSW          F=SSE2
66.0fee                RM   Vx  Wx  -   -   SSE_PMAXSW          F=SSE2
66.0fed                RM   Vx  Wx  -   -   SSE_PADDSW          F=SSE2
66.0fef                RM   Vx  Wx  -   -   SSE_PXOR            F=SSE2
F2.0ff0/m              RM   Vx  Mx  -   -   SSE_LDDQU           F=SSE3
66.0ff1                RM   Vx  Wx  -   -   SSE_PSLLW           F=SSE2
66.0ff2                RM   Vx  Wx  -   -   SSE_PSLLD           F=SSE2
66.0ff3                RM   Vx  Wx  -   -   SSE_PSLLQ           F=SSE2
66.0ff4                RM   Vx  Wx  -   -   SSE_PMULUDQ         F=SSE2
66.0ff5                RM   Vx  Wx  -   -   SSE_PMADDWD         F=SSE2
66.0ff6                RM   Vx  Wx  -   -   SSE_PSADBW          F=SSE2
66.0ff7/r              RM   Vx  Ux  -   -   SSE_MASKMOVDQU+as   F=SSE2
66.0ff8                RM   Vx  Wx  -   -   SSE_PSUBB           F=SSE2
66.0ff9                RM   Vx  Wx  -   -   SSE_PSUBW           F=SSE2
66.0ffa                RM   Vx  Wx  -   -   SSE_PSUBD           F=SSE2
66.0ffb                RM   Vx  Wx  -   -   SSE_PSUBQ           F=SSE2
66.0ffc                RM   Vx  Wx  -   -   SSE_PADDB           F=SSE2
66.0ffd                RM   Vx  Wx  -   -   SSE_PADDW           F=SSE2
66.0ffe                RM   Vx  Wx  -   -   SSE_PADDD           F=SSE2
#
66.0f3800              RM   Vx  Wx  -   -   SSE_PSHUFB          F=SSSE3
66.0f3801              RM   Vx  Wx  -   -   SSE_PHADDW          F=SSSE3
66.0f3802              RM   Vx  Wx  -   -   SSE_PHADDD          F=SSSE3
66.0f3803              RM   Vx  Wx  -   -   SSE_PHADDSW         F=SSSE3
66.0f3804              RM   Vx  Wx  -   -   SSE_PMADDUBSW       F=SSSE3
66.0f3805              RM   Vx  Wx  -   -   SSE_PHSUBW          F=SSSE3
66.0f3806              RM   Vx  Wx  -   -   SSE_PHSUBD          F=SSSE3
66.0f3807              RM   Vx  Wx  -   -   SSE_PHSUBSW         F=SSSE3
66.0f3808              RM   Vx  Wx  -   -   SSE_PSIGNB          F=SSSE3
66.0f3809              RM   Vx  Wx  -   -   SSE_PSIGNW          F=SSSE3
66.0f380a              RM   Vx  Wx  -   -   SSE_PSIGND          F=SSSE3
66.0f380b              RM   Vx  Wx  -   -   SSE_PMULHRSW        F=SSSE3
66.0f3810              RM   Vdq Wdq -   -   SSE_PBLENDVB        F=SSE41
66.0f3814              RMA  Vdq Wdq Hdq -   SSE_BLENDVPS        F=SSE41
66.0f3815              RMA  Vdq Wdq Hdq -   SSE_BLENDVPD        F=SSE41
66.0f3817              RM   Vx  Wx  -   -   SSE_PTEST           F=SSE41 EFL=0--0m00m
66.0f381c              RM   Vx  Wx  -   -   SSE_PABSB           F=SSSE3
66.0f381d              RM   Vx  Wx  -   -   SSE_PABSW           F=SSSE3
66.0f381e              RM   Vx  Wx  -   -   SSE_PABSD           F=SSSE3
66.0f3820              RM   Vx  Wh  -   -   SSE_PMOVSXBW        F=SSE41
66.0f3821              RM   Vx  Wf  -   -   SSE_PMOVSXBD        F=SSE41
66.0f3822              RM   Vx  We  -   -   SSE_PMOVSXBQ        F=SSE41
66.0f3823              RM   Vx  Wh  -   -   SSE_PMOVSXWD        F=SSE41
66.0f3824              RM   Vx  Wf  -   -   SSE_PMOVSXWQ        F=SSE41
66.0f3825              RM   Vx  Wh  -   -   SSE_PMOVSXDQ        F=SSE41
66.0f3828              RM   Vx  Wx  -   -   SSE_PMULDQ          F=SSE41
66.0f3829              RM   Vx  Wx  -   -   SSE_PCMPEQQ         F=SSE41
66.0f382a/m            RM   Vx  Mx  -   -   SSE_MOVNTDQA        F=SSE41
66.0f382b              RM   Vx  Wx  -   -   SSE_PACKUSDW        F=SSE41
66.0f3830              RM   Vx  Wh  -   -   SSE_PMOVZXBW        F=SSE41
66.0f3831              RM   Vx  Wf  -   -   SSE_PMOVZXBD        F=SSE41
66.0f3832              RM   Vx  We  -   -   SSE_PMOVZXBQ        F=SSE41
66.0f3833              RM   Vx  Wh  -   -   SSE_PMOVZXWD        F=SSE41
66.0f3834              RM   Vx  Wf  -   -   SSE_PMOVZXWQ        F=SSE41
66.0f3835              RM   Vx  Wh  -   -   SSE_PMOVZXDQ        F=SSE41
66.0f3837              RM   Vx  Wx  -   -   SSE_PCMPGTQ         F=SSE41
66.0f3838              RM   Vx  Wx  -   -   SSE_PMINSB          F=SSE41
66.0f3839              RM   Vx  Wx  -   -   SSE_PMINSD          F=SSE41
66.0f383a              RM   Vx  Wx  -   -   SSE_PMINUW          F=SSE41
66.0f383b              RM   Vx  Wx  -   -   SSE_PMINUD          F=SSE41
66.0f383c              RM   Vx  Wx  -   -   SSE_PMAXSB          F=SSE41
66.0f383d              RM   Vx  Wx  -   -   SSE_PMAXSD          F=SSE41
66.0f383e              RM   Vx  Wx  -   -   SSE_PMAXUW          F=SSE41
66.0f383f              RM   Vx  Wx  -   -   SSE_PMAXUD          F=SSE41
66.0f3840              RM   Vx  Wx  -   -   SSE_PMULLD          F=SSE41
66.0f3841              RM   Vx  Wx  -   -   SSE_PHMINPOSUW      F=SSE41
# TODO: GP operand has address size
66.0f38f8/m            RM   Gy  Moq -   -   MOVDIR64B       D64 F=MOVDIR64B
NP.0f38f9/m            MR   My  Gy  -   -   MOVDIRI             F=MOVDIRI
#
66.0f3a08              RMI  Vps Wps Ib  -   SSE_ROUNDPS         F=SSE41
66.0f3a09              RMI  Vpd Wpd Ib  -   SSE_ROUNDPD         F=SSE41
66.0f3a0a              RMI  Vss Wss Ib  -   SSE_ROUNDSS         F=SSE41
66.0f3a0b              RMI  Vsd Wsd Ib  -   SSE_ROUNDSD         F=SSE41
66.0f3a0c              RMI  Vps Wps Ib  -   SSE_BLENDPS         F=SSE41
66.0f3a0d              RMI  Vpd Wpd Ib  -   SSE_BLENDPD         F=SSE41
66.0f3a0e              RMI  Vx  Wx  Ib  -   SSE_PBLENDW         F=SSE41
66.0f3a0f              RMI  Vx  Wx  Ib  -   SSE_PALIGNR         F=SSSE3
66.0f3a14/m            MRI  Mb  Vx  Ib  -   SSE_PEXTRB          F=SSE41
66.0f3a14/r            MRI  Rd  Vx  Ib  -   SSE_PEXTRB          F=SSE41 ENC_NOSZ
66.0f3a15/m            MRI  Mw  Vx  Ib  -   SSE_PEXTRW          F=SSE41
66.0f3a15/r            MRI  Rd  Vx  Ib  -   SSE_PEXTRW          F=SSE41 ENC_NOSZ
66.W0.0f3a16           MRI  Ed  Vx  Ib  -   SSE_PEXTRD          F=SSE41 ENC_NOSZ
66.W1.0f3a16           MRI  Eq  Vx  Ib  -   SSE_PEXTRQ          F=SSE41 ENC_NOSZ
66.0f3a17              MRI  Ed  Vx  Ib  -   SSE_EXTRACTPS       F=SSE41
66.0f3a20              RMI  Vx  Eb  Ib  -   SSE_PINSRB          F=SSE41
66.0f3a21              RMI  Vps Wss Ib  -   SSE_INSERTPS        F=SSE41
66.W0.0f3a22           RMI  Vx  Ed  Ib  -   SSE_PINSRD          F=SSE41 ENC_NOSZ
66.W1.0f3a22           RMI  Vx  Eq  Ib  -   SSE_PINSRQ          F=SSE41 ENC_NOSZ
66.0f3a40              RMI  Vps Wps Ib  -   SSE_DPPS            F=SSE41
66.0f3a41              RMI  Vpd Wpd Ib  -   SSE_DPPD            F=SSE41
66.0f3a42              RMI  Vx  Wx  Ib  -   SSE_MPSADBW         F=SSE41
66.0f3a44              RMI  Vdq Wdq Ib  -   SSE_PCLMULQDQ       F=PCLMULQDQ
66.0f3a60              RMI  Vdq Wdq Ib  -   SSE_PCMPESTRM       F=SSE42 EFL=m--mm00m
66.0f3a61              RMI  Vdq Wdq Ib  -   SSE_PCMPESTRI       F=SSE42 EFL=m--mm00m
66.0f3a62              RMI  Vdq Wdq Ib  -   SSE_PCMPISTRM       F=SSE42 EFL=m--mm00m
66.0f3a63              RMI  Vdq Wdq Ib  -   SSE_PCMPISTRI       F=SSE42 EFL=m--mm00m
#
66.0f38db              RM   Vdq Wdq -   -   AESIMC              F=AESNI
66.0f38dc              RM   Vdq Wdq -   -   AESENC              F=AESNI
66.0f38dd              RM   Vdq Wdq -   -   AESENCLAST          F=AESNI
66.0f38de              RM   Vdq Wdq -   -   AESDEC              F=AESNI
66.0f38df              RM   Vdq Wdq -   -   AESDECLAST          F=AESNI
66.0f3adf              RMI  Vdq Wdq Ib  -   AESKEYGENASSIST     F=AESNI
VEX.66.L0.0f38db       RM   Vdq Wdq -   -   VAESIMC             F=AESNI,AVX
# 256-bit encodings require VAES.
VEX.66.0f38dc          RVM  Vx  Hx  Wx  -   VAESENC             F=AESNI,AVX
VEX.66.0f38dd          RVM  Vx  Hx  Wx  -   VAESENCLAST         F=AESNI,AVX
VEX.66.0f38de          RVM  Vx  Hx  Wx  -   VAESDEC             F=AESNI,AVX
VEX.66.0f38df          RVM  Vx  Hx  Wx  -   VAESDECLAST         F=AESNI,AVX
VEX.66.L0.0f3adf       RMI  Vdq Wdq Ib  -   VAESKEYGENASSIST    F=AESNI,AVX
#
# AVX
VEX.NP.0f10            RM   Vps Wps -   -   VMOVUPS             F=AVX
VEX.66.0f10            RM   Vpd Wpd -   -   VMOVUPD             F=AVX
VEX.F3.LIG.0f10/m      RM   Vdq Mss -   -   VMOVSS              F=AVX
VEX.F3.LIG.0f10/r      RVM  Vdq Hdq Uss -   VMOVSS              F=AVX
VEX.F2.LIG.0f10/m      RM   Vdq Msd -   -   VMOVSD              F=AVX
VEX.F2.LIG.0f10/r      RVM  Vdq Hdq Usd -   VMOVSD              F=AVX
VEX.NP.0f11            MR   Wps Vps -   -   VMOVUPS             F=AVX
VEX.66.0f11            MR   Wpd Vpd -   -   VMOVUPD             F=AVX
VEX.F3.LIG.0f11/m      MR   Mss Vss -   -   VMOVSS              F=AVX
VEX.F3.LIG.0f11/r      MVR  Udq Hdq Vss -   VMOVSS              F=AVX
VEX.F2.LIG.0f11/m      MR   Msd Vsd -   -   VMOVSD              F=AVX
VEX.F2.LIG.0f11/r      MVR  Udq Hdq Vsd -   VMOVSD              F=AVX
VEX.NP.L0.0f12/m       RVM  Vdq Hdq Mq  -   VMOVLPS             F=AVX
VEX.NP.L0.0f12/r       RVM  Vdq Hdq Udq -   VMOVHLPS            F=AVX
VEX.66.L0.0f12/m       RVM  Vdq Hdq Mq  -   VMOVLPD             F=AVX
VEX.F2.L0.0f12         RM   Vx  Wq  -   -   VMOVDDUP            F=AVX
VEX.F2.L1.0f12         RM   Vx  Wx  -   -   VMOVDDUP            F=AVX
VEX.F3.0f12            RM   Vx  Wx  -   -   VMOVSLDUP           F=AVX
VEX.NP.L0.0f13/m       MR   Mq  Vq  -   -   VMOVLPS             F=AVX
VEX.66.L0.0f13/m       MR   Mq  Vq  -   -   VMOVLPD             F=AVX
VEX.NP.0f14            RVM  Vx  Hx  Wx  -   VUNPCKLPS           F=AVX
VEX.66.0f14            RVM  Vx  Hx  Wx  -   VUNPCKLPD           F=AVX
VEX.NP.0f15            RVM  Vx  Hx  Wx  -   VUNPCKHPS           F=AVX
VEX.66.0f15            RVM  Vx  Hx  Wx  -   VUNPCKHPD           F=AVX
VEX.NP.L0.0f16/m       RVM  Vdq Hq  Mq  -   VMOVHPS             F=AVX
VEX.NP.L0.0f16/r       RVM  Vdq Hq  Uq  -   VMOVLHPS            F=AVX
VEX.66.L0.0f16/m       RVM  Vdq Hq  Mq  -   VMOVHPD             F=AVX
VEX.F3.0f16            RM   Vx  Wx  -   -   VMOVSHDUP           F=AVX
VEX.NP.L0.0f17/m       MR   Mq  Vq  -   -   VMOVHPS             F=AVX
VEX.66.L0.0f17/m       MR   Mq  Vq  -   -   VMOVHPD             F=AVX
VEX.NP.0f28            RM   Vps Wps -   -   VMOVAPS             F=AVX
VEX.66.0f28            RM   Vpd Wpd -   -   VMOVAPD             F=AVX
VEX.NP.0f29            MR   Wps Vps -   -   VMOVAPS             F=AVX
VEX.66.0f29            MR   Wpd Vpd -   -   VMOVAPD             F=AVX
VEX.F3.LIG.0f2a        RVM  Vdq Hdq Ey  -   VCVTSI2SS           F=AVX
VEX.F2.LIG.0f2a        RVM  Vdq Hdq Ey  -   VCVTSI2SD           F=AVX
VEX.NP.0f2b/m          MR   Mps Vps -   -   VMOVNTPS            F=AVX
VEX.66.0f2b/m          MR   Mpd Vpd -   -   VMOVNTPD            F=AVX
VEX.F3.LIG.0f2c        RM   Gy  Wss -   -   VCVTTSS2SI          F=AVX
VEX.F2.LIG.0f2c        RM   Gy  Wsd -   -   VCVTTSD2SI          F=AVX
VEX.F3.LIG.0f2d        RM   Gy  Wss -   -   VCVTSS2SI           F=AVX
VEX.F2.LIG.0f2d        RM   Gy  Wsd -   -   VCVTSD2SI           F=AVX
VEX.NP.LIG.0f2e        RM   Vss Wss -   -   VUCOMISS            F=AVX EFL=0--0m0mm
VEX.66.LIG.0f2e        RM   Vsd Wsd -   -   VUCOMISD            F=AVX EFL=0--0m0mm
VEX.NP.LIG.0f2f        RM   Vss Wss -   -   VCOMISS             F=AVX EFL=0--0m0mm
VEX.66.LIG.0f2f        RM   Vsd Wsd -   -   VCOMISD             F=AVX EFL=0--0m0mm
VEX.NP.0f50/r          RM   Gd  Ups -   -   VMOVMSKPS           F=AVX
VEX.66.0f50/r          RM   Gd  Upd -   -   VMOVMSKPD           F=AVX
VEX.NP.0f51            RM   Vps Wps -   -   VSQRTPS             F=AVX
VEX.66.0f51            RM   Vpd Wpd -   -   VSQRTPD             F=AVX
VEX.F3.LIG.0f51        RVM  Vdq Hdq Wss -   VSQRTSS             F=AVX
VEX.F2.LIG.0f51        RVM  Vdq Hdq Wsd -   VSQRTSD             F=AVX
VEX.NP.0f52            RM   Vps Wps -   -   VRSQRTPS            F=AVX
VEX.F3.LIG.0f52        RVM  Vdq Hdq Wss -   VRSQRTSS            F=AVX
VEX.NP.0f53            RM   Vps Wps -   -   VRCPPS              F=AVX
VEX.F3.LIG.0f53        RVM  Vdq Hdq Wss -   VRCPSS              F=AVX
VEX.NP.0f54            RVM  Vps Hps Wps -   VANDPS              F=AVX
VEX.66.0f54            RVM  Vpd Hpd Wpd -   VANDPD              F=AVX
VEX.NP.0f55            RVM  Vps Hps Wps -   VANDNPS             F=AVX
VEX.66.0f55            RVM  Vpd Hpd Wpd -   VANDNPD             F=AVX
VEX.NP.0f56            RVM  Vps Hps Wps -   VORPS               F=AVX
VEX.66.0f56            RVM  Vpd Hpd Wpd -   VORPD               F=AVX
VEX.NP.0f57            RVM  Vps Hps Wps -   VXORPS              F=AVX
VEX.66.0f57            RVM  Vpd Hpd Wpd -   VXORPD              F=AVX
VEX.NP.0f58            RVM  Vps Hps Wps -   VADDPS              F=AVX
VEX.66.0f58            RVM  Vpd Hpd Wpd -   VADDPD              F=AVX
VEX.F3.LIG.0f58        RVM  Vdq Hdq Wss -   VADDSS              F=AVX
VEX.F2.LIG.0f58        RVM  Vdq Hdq Wsd -   VADDSD              F=AVX
VEX.NP.0f59            RVM  Vps Hps Wps -   VMULPS              F=AVX
VEX.66.0f59            RVM  Vpd Hpd Wpd -   VMULPD              F=AVX
VEX.F3.LIG.0f59        RVM  Vdq Hdq Wss -   VMULSS              F=AVX
VEX.F2.LIG.0f59        RVM  Vdq Hdq Wsd -   VMULSD              F=AVX
VEX.NP.0f5a            RM   Vpd Wh  -   -   VCVTPS2PD           F=AVX
VEX.66.0f5a            RM   Vh  Wpd -   -   VCVTPD2PS           F=AVX
VEX.F3.LIG.0f5a        RVM  Vdq Hdq Wss -   VCVTSS2SD           F=AVX
VEX.F2.LIG.0f5a        RVM  Vdq Hdq Wsd -   VCVTSD2SS           F=AVX
VEX.NP.0f5b            RM   Vps Wx  -   -   VCVTDQ2PS           F=AVX
VEX.66.0f5b            RM   Vx  Wps -   -   VCVTPS2DQ           F=AVX
VEX.F3.0f5b            RM   Vx  Wps -   -   VCVTTPS2DQ          F=AVX
VEX.NP.0f5c            RVM  Vps Hps Wps -   VSUBPS              F=AVX
VEX.66.0f5c            RVM  Vpd Hpd Wpd -   VSUBPD              F=AVX
VEX.F3.LIG.0f5c        RVM  Vdq Hdq Wss -   VSUBSS              F=AVX
VEX.F2.LIG.0f5c        RVM  Vdq Hdq Wsd -   VSUBSD              F=AVX
VEX.NP.0f5d            RVM  Vps Hps Wps -   VMINPS              F=AVX
VEX.66.0f5d            RVM  Vpd Hpd Wpd -   VMINPD              F=AVX
VEX.F3.LIG.0f5d        RVM  Vdq Hdq Wss -   VMINSS              F=AVX
VEX.F2.LIG.0f5d        RVM  Vdq Hdq Wsd -   VMINSD              F=AVX
VEX.NP.0f5e            RVM  Vps Hps Wps -   VDIVPS              F=AVX
VEX.66.0f5e            RVM  Vpd Hpd Wpd -   VDIVPD              F=AVX
VEX.F3.LIG.0f5e        RVM  Vdq Hdq Wss -   VDIVSS              F=AVX
VEX.F2.LIG.0f5e        RVM  Vdq Hdq Wsd -   VDIVSD              F=AVX
VEX.NP.0f5f            RVM  Vps Hps Wps -   VMAXPS              F=AVX
VEX.66.0f5f            RVM  Vpd Hpd Wpd -   VMAXPD              F=AVX
VEX.F3.LIG.0f5f        RVM  Vdq Hdq Wss -   VMAXSS              F=AVX
VEX.F2.LIG.0f5f        RVM  Vdq Hdq Wsd -   VMAXSD              F=AVX
VEX.66.0f60            RVM  Vx  Hx  Wx  -   VPUNPCKLBW          F=AVX
VEX.66.0f61            RVM  Vx  Hx  Wx  -   VPUNPCKLWD          F=AVX
VEX.66.0f62            RVM  Vx  Hx  Wx  -   VPUNPCKLDQ          F=AVX
VEX.66.0f63            RVM  Vx  Hx  Wx  -   VPACKSSWB           F=AVX
VEX.66.0f64            RVM  Vx  Hx  Wx  -   VPCMPGTB            F=AVX
VEX.66.0f65            RVM  Vx  Hx  Wx  -   VPCMPGTW            F=AVX
VEX.66.0f66            RVM  Vx  Hx  Wx  -   VPCMPGTD            F=AVX
VEX.66.0f67            RVM  Vx  Hx  Wx  -   VPACKUSWB           F=AVX
VEX.66.0f68            RVM  Vx  Hx  Wx  -   VPUNPCKHBW          F=AVX
VEX.66.0f69            RVM  Vx  Hx  Wx  -   VPUNPCKHWD          F=AVX
VEX.66.0f6a            RVM  Vx  Hx  Wx  -   VPUNPCKHDQ          F=AVX
VEX.66.0f6b            RVM  Vx  Hx  Wx  -   VPACKSSDW           F=AVX
VEX.66.0f6c            RVM  Vx  Hx  Wx  -   VPUNPCKLQDQ         F=AVX
VEX.66.0f6d            RVM  Vx  Hx  Wx  -   VPUNPCKHQDQ         F=AVX
VEX.66.W0.L0.0f6e      RM   Vy  Ey  -   -   VMOVD_G2X           F=AVX ENC_NOSZ
VEX.66.W1.L0.0f6e      RM   Vy  Ey  -   -   VMOVD_G2X   I64     F=AVX ENC_NOSZ
VEX.66.W1.L0.0f6e      RM   Vy  Ey  -   -   VMOVQ_G2X   O64     F=AVX ENC_NOSZ
VEX.66.0f6f            RM   Vx  Wx  -   -   VMOVDQA             F=AVX
VEX.F3.0f6f            RM   Vx  Wx  -   -   VMOVDQU             F=AVX
VEX.66.0f70            RMI  Vx  Wx  Ib  -   VPSHUFD             F=AVX
VEX.F3.0f70            RMI  Vx  Wx  Ib  -   VPSHUFHW            F=AVX
VEX.F2.0f70            RMI  Vx  Wx  Ib  -   VPSHUFLW            F=AVX
VEX.66.0f71/2r         VMI  Hx  Ux  Ib  -   VPSRLW              F=AVX
VEX.66.0f71/4r         VMI  Hx  Ux  Ib  -   VPSRAW              F=AVX
VEX.66.0f71/6r         VMI  Hx  Ux  Ib  -   VPSLLW              F=AVX
VEX.66.0f72/2r         VMI  Hx  Ux  Ib  -   VPSRLD              F=AVX
VEX.66.0f72/4r         VMI  Hx  Ux  Ib  -   VPSRAD              F=AVX
VEX.66.0f72/6r         VMI  Hx  Ux  Ib  -   VPSLLD              F=AVX
VEX.66.0f73/2r         VMI  Hx  Ux  Ib  -   VPSRLQ              F=AVX
VEX.66.0f73/3r         VMI  Hx  Ux  Ib  -   VPSRLDQ             F=AVX
VEX.66.0f73/6r         VMI  Hx  Ux  Ib  -   VPSLLQ              F=AVX
VEX.66.0f73/7r         VMI  Hx  Ux  Ib  -   VPSLLDQ             F=AVX
VEX.66.0f74            RVM  Vx  Hx  Wx  -   VPCMPEQB            F=AVX
VEX.66.0f75            RVM  Vx  Hx  Wx  -   VPCMPEQW            F=AVX
VEX.66.0f76            RVM  Vx  Hx  Wx  -   VPCMPEQD            F=AVX
VEX.NP.L0.0f77         NP   -   -   -   -   VZEROUPPER          F=AVX
VEX.NP.L1.0f77         NP   -   -   -   -   VZEROALL            F=AVX
VEX.66.0f7c            RVM  Vx  Hx  Wx  -   VHADDPD             F=AVX
VEX.F2.0f7c            RVM  Vx  Hx  Wx  -   VHADDPS             F=AVX
VEX.66.0f7d            RVM  Vx  Hx  Wx  -   VHSUBPD             F=AVX
VEX.F2.0f7d            RVM  Vx  Hx  Wx  -   VHSUBPS             F=AVX
VEX.66.W0.L0.0f7e      MR   Ey  Vy  -   -   VMOVD_X2G           F=AVX ENC_NOSZ
VEX.66.W1.L0.0f7e      MR   Ey  Vy  -   -   VMOVD_X2G   I64     F=AVX ENC_NOSZ
VEX.66.W1.L0.0f7e      MR   Ey  Vy  -   -   VMOVQ_X2G   O64     F=AVX ENC_NOSZ
VEX.F3.L0.0f7e         RM   Vq  Wq  -   -   VMOVQ               F=AVX
VEX.66.0f7f            MR   Wx  Vx  -   -   VMOVDQA             F=AVX
VEX.F3.0f7f            MR   Wx  Vx  -   -   VMOVDQU             F=AVX
VEX.NP.L0.0fae/2m      M    Md  -   -   -   VLDMXCSR            F=AVX
VEX.NP.L0.0fae/3m      M    Md  -   -   -   VSTMXCSR            F=AVX
VEX.NP.0fc2            RVMI Vx  Hx  Wx  Ib  VCMPPS              F=AVX
VEX.66.0fc2            RVMI Vx  Hx  Wx  Ib  VCMPPD              F=AVX
VEX.F3.LIG.0fc2        RVMI Vdq Hdq Wss Ib  VCMPSS              F=AVX
VEX.F2.LIG.0fc2        RVMI Vdq Hdq Wsd Ib  VCMPSD              F=AVX
VEX.66.L0.0fc4         RVMI Vdq Hdq Ew  Ib  VPINSRW             F=AVX
VEX.66.L0.0fc5/r       RMI  Gd  Udq Ib  -   VPEXTRW             F=AVX
VEX.NP.0fc6            RVMI Vx  Hx  Wx  Ib  VSHUFPS             F=AVX
VEX.66.0fc6            RVMI Vx  Hx  Wx  Ib  VSHUFPD             F=AVX
VEX.66.0fd0            RVM  Vx  Hx  Wx  -   VADDSUBPD           F=AVX
VEX.F2.0fd0            RVM  Vx  Hx  Wx  -   VADDSUBPS           F=AVX
VEX.66.0fd1            RVM  Vx  Hx  Wdq -   VPSRLW              F=AVX
VEX.66.0fd2            RVM  Vx  Hx  Wdq -   VPSRLD              F=AVX
VEX.66.0fd3            RVM  Vx  Hx  Wdq -   VPSRLQ              F=AVX
VEX.66.0fd4            RVM  Vx  Hx  Wx  -   VPADDQ              F=AVX
VEX.66.0fd5            RVM  Vx  Hx  Wx  -   VPMULLW             F=AVX
VEX.66.L0.0fd6         MR   Wq  Vq  -   -   VMOVQ               F=AVX
VEX.66.0fd7/r          RM   Gd  Ux  -   -   VPMOVMSKB           F=AVX
VEX.66.0fd8            RVM  Vx  Hx  Wx  -   VPSUBUSB            F=AVX
VEX.66.0fd9            RVM  Vx  Hx  Wx  -   VPSUBUSW            F=AVX
VEX.66.0fda            RVM  Vx  Hx  Wx  -   VPMINUB             F=AVX
VEX.66.0fdb            RVM  Vx  Hx  Wx  -   VPAND               F=AVX
VEX.66.0fdc            RVM  Vx  Hx  Wx  -   VPADDUSB            F=AVX
VEX.66.0fdd            RVM  Vx  Hx  Wx  -   VPADDUSW            F=AVX
VEX.66.0fde            RVM  Vx  Hx  Wx  -   VPMAXUB             F=AVX
VEX.66.0fdf            RVM  Vx  Hx  Wx  -   VPANDN              F=AVX
VEX.66.0fe0            RVM  Vx  Hx  Wx  -   VPAVGB              F=AVX
VEX.66.0fe1            RVM  Vx  Hx  Wdq -   VPSRAW              F=AVX
VEX.66.0fe2            RVM  Vx  Hx  Wdq -   VPSRAD              F=AVX
VEX.66.0fe3            RVM  Vx  Hx  Wx  -   VPAVGW              F=AVX
VEX.66.0fe4            RVM  Vx  Hx  Wx  -   VPMULHUW            F=AVX
VEX.66.0fe5            RVM  Vx  Hx  Wx  -   VPMULHW             F=AVX
VEX.66.0fe6            RM   Vh  Wx  -   -   VCVTTPD2DQ          F=AVX
VEX.F3.0fe6            RM   Vx  Wh  -   -   VCVTDQ2PD           F=AVX
VEX.F2.0fe6            RM   Vh  Wx  -   -   VCVTPD2DQ           F=AVX
VEX.66.0fe7/m          MR   Mx  Vx  -   -   VMOVNTDQ            F=AVX
VEX.66.0fe8            RVM  Vx  Hx  Wx  -   VPSUBSB             F=AVX
VEX.66.0fe9            RVM  Vx  Hx  Wx  -   VPSUBSW             F=AVX
VEX.66.0feb            RVM  Vx  Hx  Wx  -   VPOR                F=AVX
VEX.66.0fec            RVM  Vx  Hx  Wx  -   VPADDSB             F=AVX
VEX.66.0fea            RVM  Vx  Hx  Wx  -   VPMINSW             F=AVX
VEX.66.0fed            RVM  Vx  Hx  Wx  -   VPADDSW             F=AVX
VEX.66.0fee            RVM  Vx  Hx  Wx  -   VPMAXSW             F=AVX
VEX.66.0fef            RVM  Vx  Hx  Wx  -   VPXOR               F=AVX
VEX.F2.0ff0/m          RM   Vx  Mx  -   -   VLDDQU              F=AVX
VEX.66.0ff1            RVM  Vx  Hx  Wdq -   VPSLLW              F=AVX
VEX.66.0ff2            RVM  Vx  Hx  Wdq -   VPSLLD              F=AVX
VEX.66.0ff3            RVM  Vx  Hx  Wdq -   VPSLLQ              F=AVX
VEX.66.0ff4            RVM  Vx  Hx  Wx  -   VPMULUDQ            F=AVX
VEX.66.0ff5            RVM  Vx  Hx  Wx  -   VPMADDWD            F=AVX
VEX.66.0ff6            RVM  Vx  Hx  Wx  -   VPSADBW             F=AVX
VEX.66.L0.0ff7/r       RM   Vx  Ux  -   -   VMASKMOVDQU+as      F=AVX
VEX.66.0ff8            RVM  Vx  Hx  Wx  -   VPSUBB              F=AVX
VEX.66.0ff9            RVM  Vx  Hx  Wx  -   VPSUBW              F=AVX
VEX.66.0ffa            RVM  Vx  Hx  Wx  -   VPSUBD              F=AVX
VEX.66.0ffb            RVM  Vx  Hx  Wx  -   VPSUBQ              F=AVX
VEX.66.0ffc            RVM  Vx  Hx  Wx  -   VPADDB              F=AVX
VEX.66.0ffd            RVM  Vx  Hx  Wx  -   VPADDW              F=AVX
VEX.66.0ffe            RVM  Vx  Hx  Wx  -   VPADDD              F=AVX
VEX.66.0f3800          RVM  Vx  Hx  Wx  -   VPSHUFB             F=AVX
VEX.66.0f3801          RVM  Vx  Hx  Wx  -   VPHADDW             F=AVX
VEX.66.0f3802          RVM  Vx  Hx  Wx  -   VPHADDD             F=AVX
VEX.66.0f3803          RVM  Vx  Hx  Wx  -   VPHADDSW            F=AVX
VEX.66.0f3804          RVM  Vx  Hx  Wx  -   VPMADDUBSW          F=AVX
VEX.66.0f3805          RVM  Vx  Hx  Wx  -   VPHSUBW             F=AVX
VEX.66.0f3806          RVM  Vx  Hx  Wx  -   VPHSUBD             F=AVX
VEX.66.0f3807          RVM  Vx  Hx  Wx  -   VPHSUBSW            F=AVX
VEX.66.0f3808          RVM  Vx  Hx  Wx  -   VPSIGNB             F=AVX
VEX.66.0f3809          RVM  Vx  Hx  Wx  -   VPSIGNW             F=AVX
VEX.66.0f380a          RVM  Vx  Hx  Wx  -   VPSIGND             F=AVX
VEX.66.0f380b          RVM  Vx  Hx  Wx  -   VPMULHRSW           F=AVX
VEX.66.W0.0f380c       RVM  Vx  Hx  Wx  -   VPERMILPS           F=AVX
VEX.66.W0.0f380d       RVM  Vx  Hx  Wx  -   VPERMILPD           F=AVX
VEX.66.W0.0f380e       RM   Vx  Wx  -   -   VTESTPS             F=AVX
VEX.66.W0.0f380f       RM   Vx  Wx  -   -   VTESTPD             F=AVX
VEX.66.W0.0f3813       RM   Vx  Wh  -   -   VCVTPH2PS           F=F16C
VEX.66.W0.L1.0f3816    RVM  Vx  Hx  Wx  -   VPERMPS             F=AVX2
VEX.66.0f3817          RM   Vx  Wx  -   -   VPTEST              F=AVX EFL=0--0m00m
VEX.66.W0.0f3818       RM   Vx  Wd  -   -   VBROADCASTSS        F=AVX
VEX.66.W0.L1.0f3819    RM   Vx  Wq  -   -   VBROADCASTSD        F=AVX
VEX.66.W0.L1.0f381a    RM   Vx  Wdq -   -   VBROADCASTF128      F=AVX
VEX.66.0f381c          RM   Vx  Wx  -   -   VPABSB              F=AVX
VEX.66.0f381d          RM   Vx  Wx  -   -   VPABSW              F=AVX
VEX.66.0f381e          RM   Vx  Wx  -   -   VPABSD              F=AVX
VEX.66.0f3820          RM   Vx  Wh  -   -   VPMOVSXBW           F=AVX
VEX.66.0f3821          RM   Vx  Wf  -   -   VPMOVSXBD           F=AVX
VEX.66.0f3822          RM   Vx  We  -   -   VPMOVSXBQ           F=AVX
VEX.66.0f3823          RM   Vx  Wh  -   -   VPMOVSXWD           F=AVX
VEX.66.0f3824          RM   Vx  Wf  -   -   VPMOVSXWQ           F=AVX
VEX.66.0f3825          RM   Vx  Wh  -   -   VPMOVSXDQ           F=AVX
VEX.66.0f3828          RVM  Vx  Hx  Wx  -   VPMULDQ             F=AVX
VEX.66.0f3829          RVM  Vx  Hx  Wx  -   VPCMPEQQ            F=AVX
VEX.66.0f382a/m        RM   Vx  Mx  -   -   VMOVNTDQA           F=AVX
VEX.66.0f382b          RVM  Vx  Hx  Wx  -   VPACKUSDW           F=AVX
VEX.66.W0.0f382c/m     RVM  Vx  Hx  Mx  -   VMASKMOVPS          F=AVX
VEX.66.W0.0f382d/m     RVM  Vx  Hx  Mx  -   VMASKMOVPD          F=AVX
VEX.66.W0.0f382e/m     MVR  Mx  Hx  Vx  -   VMASKMOVPS          F=AVX
VEX.66.W0.0f382f/m     MVR  Mx  Hx  Vx  -   VMASKMOVPD          F=AVX
VEX.66.0f3830          RM   Vx  Wh  -   -   VPMOVZXBW           F=AVX
VEX.66.0f3831          RM   Vx  Wf  -   -   VPMOVZXBD           F=AVX
VEX.66.0f3832          RM   Vx  We  -   -   VPMOVZXBQ           F=AVX
VEX.66.0f3833          RM   Vx  Wh  -   -   VPMOVZXWD           F=AVX
VEX.66.0f3834          RM   Vx  Wf  -   -   VPMOVZXWQ           F=AVX
VEX.66.0f3835          RM   Vx  Wh  -   -   VPMOVZXDQ           F=AVX
VEX.66.W0.L1.0f3836    RVM  Vx  Hx  Wx  -   VPERMD              F=AVX2
VEX.66.0f3837          RVM  Vx  Hx  Wx  -   VPCMPGTQ            F=AVX
VEX.66.0f3838          RVM  Vx  Hx  Wx  -   VPMINSB             F=AVX
VEX.66.0f3839          RVM  Vx  Hx  Wx  -   VPMINSD             F=AVX
VEX.66.0f383a          RVM  Vx  Hx  Wx  -   VPMINUW             F=AVX
VEX.66.0f383b          RVM  Vx  Hx  Wx  -   VPMINUD             F=AVX
VEX.66.0f383c          RVM  Vx  Hx  Wx  -   VPMAXSB             F=AVX
VEX.66.0f383d          RVM  Vx  Hx  Wx  -   VPMAXSD             F=AVX
VEX.66.0f383e          RVM  Vx  Hx  Wx  -   VPMAXUW             F=AVX
VEX.66.0f383f          RVM  Vx  Hx  Wx  -   VPMAXUD             F=AVX
VEX.66.0f3840          RVM  Vx  Hx  Wx  -   VPMULLD             F=AVX
VEX.66.L0.0f3841       RM   Vx  Wx  -   -   VPHMINPOSUW         F=AVX
VEX.66.W0.0f3845       RVM  Vx  Hx  Wx  -   VPSRLVD             F=AVX2
VEX.66.W1.0f3845       RVM  Vx  Hx  Wx  -   VPSRLVQ             F=AVX2
VEX.66.W0.0f3846       RVM  Vx  Hx  Wx  -   VPSRAVD             F=AVX2
VEX.66.W0.0f3847       RVM  Vx  Hx  Wx  -   VPSLLVD             F=AVX2
VEX.66.W1.0f3847       RVM  Vx  Hx  Wx  -   VPSLLVQ             F=AVX2
VEX.66.W0.0f3858       RM   Vx  Wd  -   -   VPBROADCASTD        F=AVX2
VEX.66.W0.0f3859       RM   Vx  Wq  -   -   VPBROADCASTQ        F=AVX2
VEX.66.W0.L1.0f385a/m  RM   Vx  Mdq -   -   VBROADCASTI128      F=AVX2 ENC_NOSZ
VEX.66.W0.0f3878       RM   Vx  Wb  -   -   VPBROADCASTB        F=AVX2
VEX.66.W0.0f3879       RM   Vx  Ww  -   -   VPBROADCASTW        F=AVX2
VEX.66.W0.0f388c/m     RVM  Vx  Hx  Mx  -   VPMASKMOVD          F=AVX2
VEX.66.W1.0f388c/m     RVM  Vx  Hx  Mx  -   VPMASKMOVQ          F=AVX2
VEX.66.W0.0f388e/m     MVR  Mx  Hx  Vx  -   VPMASKMOVD          F=AVX2
VEX.66.W1.0f388e/m     MVR  Mx  Hx  Vx  -   VPMASKMOVQ          F=AVX2
VEX.66.W0.0f3890/m     RMV  Vx  Md  Hx  -   VPGATHERDD VSIB     F=AVX2
VEX.66.W1.0f3890/m     RMV  Vx  Mq  Hx  -   VPGATHERDQ VSIB     F=AVX2
VEX.66.W0.0f3891/m     RMV  Vh  Md  Hh  -   VPGATHERQD VSIB     F=AVX2
VEX.66.W1.0f3891/m     RMV  Vx  Mq  Hx  -   VPGATHERQQ VSIB     F=AVX2
VEX.66.W0.0f3892/m     RMV  Vx  Md  Hx  -   VGATHERDPS VSIB     F=AVX2
VEX.66.W1.0f3892/m     RMV  Vx  Mq  Hx  -   VGATHERDPD VSIB     F=AVX2
VEX.66.W0.0f3893/m     RMV  Vh  Md  Hh  -   VGATHERQPS VSIB     F=AVX2
VEX.66.W1.0f3893/m     RMV  Vx  Mq  Hx  -   VGATHERQPD VSIB     F=AVX2
VEX.66.W0.0f3896       RVM  Vx  Hx  Wx  -   VFMADDSUB132PS      F=FMA
VEX.66.W1.0f3896       RVM  Vx  Hx  Wx  -   VFMADDSUB132PD      F=FMA
VEX.66.W0.0f3897       RVM  Vx  Hx  Wx  -   VFMSUBADD132PS      F=FMA
VEX.66.W1.0f3897       RVM  Vx  Hx  Wx  -   VFMSUBADD132PD      F=FMA
VEX.66.W0.0f3898       RVM  Vx  Hx  Wx  -   VFMADD132PS         F=FMA
VEX.66.W1.0f3898       RVM  Vx  Hx  Wx  -   VFMADD132PD         F=FMA
VEX.66.W0.LIG.0f3899   RVM  Vdq Hdq Wss -   VFMADD132SS         F=FMA
VEX.66.W1.LIG.0f3899   RVM  Vdq Hdq Wsd -   VFMADD132SD         F=FMA
VEX.66.W0.0f389a       RVM  Vx  Hx  Wx  -   VFMSUB132PS         F=FMA
VEX.66.W1.0f389a       RVM  Vx  Hx  Wx  -   VFMSUB132PD         F=FMA
VEX.66.W0.LIG.0f389b   RVM  Vdq Hdq Wss -   VFMSUB132SS         F=FMA
VEX.66.W1.LIG.0f389b   RVM  Vdq Hdq Wsd -   VFMSUB132SD         F=FMA
VEX.66.W0.0f389c       RVM  Vx  Hx  Wx  -   VFNMADD132PS        F=FMA
VEX.66.W1.0f389c       RVM  Vx  Hx  Wx  -   VFNMADD132PD        F=FMA
VEX.66.W0.LIG.0f389d   RVM  Vdq Hdq Wss -   VFNMADD132SS        F=FMA
VEX.66.W1.LIG.0f389d   RVM  Vdq Hdq Wsd -   VFNMADD132SD        F=FMA
VEX.66.W0.0f389e       RVM  Vx  Hx  Wx  -   VFNMSUB132PS        F=FMA
VEX.66.W1.0f389e       RVM  Vx  Hx  Wx  -   VFNMSUB132PD        F=FMA
VEX.66.W0.LIG.0f389f   RVM  Vdq Hdq Wss -   VFNMSUB132SS        F=FMA
VEX.66.W1.LIG.0f389f   RVM  Vdq Hdq Wsd -   VFNMSUB132SD        F=FMA
VEX.66.W0.0f38a6       RVM  Vx  Hx  Wx  -   VFMADDSUB213PS      F=FMA
VEX.66.W1.0f38a6       RVM  Vx  Hx  Wx  -   VFMADDSUB213PD      F=FMA
VEX.66.W0.0f38a7       RVM  Vx  Hx  Wx  -   VFMSUBADD213PS      F=FMA
VEX.66.W1.0f38a7       RVM  Vx  Hx  Wx  -   VFMSUBADD213PD      F=FMA
VEX.66.W0.0f38a8       RVM  Vx  Hx  Wx  -   VFMADD213PS         F=FMA
VEX.66.W1.0f38a8       RVM  Vx  Hx  Wx  -   VFMADD213PD         F=FMA
VEX.66.W0.LIG.0f38a9   RVM  Vdq Hdq Wss -   VFMADD213SS         F=FMA
VEX.66.W1.LIG.0f38a9   RVM  Vdq Hdq Wsd -   VFMADD213SD         F=FMA
VEX.66.W0.0f38aa       RVM  Vx  Hx  Wx  -   VFMSUB213PS         F=FMA
VEX.66.W1.0f38aa       RVM  Vx  Hx  Wx  -   VFMSUB213PD         F=FMA
VEX.66.W0.LIG.0f38ab   RVM  Vdq Hdq Wss -   VFMSUB213SS         F=FMA
VEX.66.W1.LIG.0f38ab   RVM  Vdq Hdq Wsd -   VFMSUB213SD         F=FMA
VEX.66.W0.0f38ac       RVM  Vx  Hx  Wx  -   VFNMADD213PS        F=FMA
VEX.66.W1.0f38ac       RVM  Vx  Hx  Wx  -   VFNMADD213PD        F=FMA
VEX.66.W0.LIG.0f38ad   RVM  Vdq Hdq Wss -   VFNMADD213SS        F=FMA
VEX.66.W1.LIG.0f38ad   RVM  Vdq Hdq Wsd -   VFNMADD213SD        F=FMA
VEX.66.W0.0f38ae       RVM  Vx  Hx  Wx  -   VFNMSUB213PS        F=FMA
VEX.66.W1.0f38ae       RVM  Vx  Hx  Wx  -   VFNMSUB213PD        F=FMA
VEX.66.W0.LIG.0f38af   RVM  Vdq Hdq Wss -   VFNMSUB213SS        F=FMA
VEX.66.W1.LIG.0f38af   RVM  Vdq Hdq Wsd -   VFNMSUB213SD        F=FMA
VEX.66.W0.0f38b6       RVM  Vx  Hx  Wx  -   VFMADDSUB231PS      F=FMA
VEX.66.W1.0f38b6       RVM  Vx  Hx  Wx  -   VFMADDSUB231PD      F=FMA
VEX.66.W0.0f38b7       RVM  Vx  Hx  Wx  -   VFMSUBADD231PS      F=FMA
VEX.66.W1.0f38b7       RVM  Vx  Hx  Wx  -   VFMSUBADD231PD      F=FMA
VEX.66.W0.0f38b8       RVM  Vx  Hx  Wx  -   VFMADD231PS         F=FMA
VEX.66.W1.0f38b8       RVM  Vx  Hx  Wx  -   VFMADD231PD         F=FMA
VEX.66.W0.LIG.0f38b9   RVM  Vdq Hdq Wss -   VFMADD231SS         F=FMA
VEX.66.W1.LIG.0f38b9   RVM  Vdq Hdq Wsd -   VFMADD231SD         F=FMA
VEX.66.W0.0f38ba       RVM  Vx  Hx  Wx  -   VFMSUB231PS         F=FMA
VEX.66.W1.0f38ba       RVM  Vx  Hx  Wx  -   VFMSUB231PD         F=FMA
VEX.66.W0.LIG.0f38bb   RVM  Vdq Hdq Wss -   VFMSUB231SS         F=FMA
VEX.66.W1.LIG.0f38bb   RVM  Vdq Hdq Wsd -   VFMSUB231SD         F=FMA
VEX.66.W0.0f38bc       RVM  Vx  Hx  Wx  -   VFNMADD231PS        F=FMA
VEX.66.W1.0f38bc       RVM  Vx  Hx  Wx  -   VFNMADD231PD        F=FMA
VEX.66.W0.LIG.0f38bd   RVM  Vdq Hdq Wss -   VFNMADD231SS        F=FMA
VEX.66.W1.LIG.0f38bd   RVM  Vdq Hdq Wsd -   VFNMADD231SD        F=FMA
VEX.66.W0.0f38be       RVM  Vx  Hx  Wx  -   VFNMSUB231PS        F=FMA
VEX.66.W1.0f38be       RVM  Vx  Hx  Wx  -   VFNMSUB231PD        F=FMA
VEX.66.W0.LIG.0f38bf   RVM  Vdq Hdq Wss -   VFNMSUB231SS        F=FMA
VEX.66.W1.LIG.0f38bf   RVM  Vdq Hdq Wsd -   VFNMSUB231SD        F=FMA
VEX.66.W1.L1.0f3a00    RMI  Vx  Wx  Ib  -   VPERMQ              F=AVX2
VEX.66.W1.L1.0f3a01    RMI  Vx  Wx  Ib  -   VPERMPD             F=AVX2
VEX.66.W0.0f3a02       RVMI Vx  Hx  Wx  Ib  VPBLENDD            F=AVX2
VEX.66.W0.0f3a04       RMI  Vx  Wx  Ib  -   VPERMILPS           F=AVX
VEX.66.W0.0f3a05       RMI  Vx  Wx  Ib  -   VPERMILPD           F=AVX
VEX.66.W0.L1.0f3a06    RVMI Vx  Hx  Wx  Ib  VPERM2F128          F=AVX
VEX.66.0f3a08          RMI  Vps Wps Ib  -   VROUNDPS            F=AVX
VEX.66.0f3a09          RMI  Vpd Wpd Ib  -   VROUNDPD            F=AVX
VEX.66.LIG.0f3a0a      RVMI Vdq Hdq Wss Ib  VROUNDSS            F=AVX
VEX.66.LIG.0f3a0b      RVMI Vdq Hdq Wsd Ib  VROUNDSD            F=AVX
VEX.66.0f3a0c          RVMI Vx  Hx  Wx  Ib  VBLENDPS            F=AVX
VEX.66.0f3a0d          RVMI Vx  Hx  Wx  Ib  VBLENDPD            F=AVX
VEX.66.0f3a0e          RVMI Vx  Hx  Wx  Ib  VPBLENDW            F=AVX
VEX.66.0f3a0f          RVMI Vx  Hx  Wx  Ib  VPALIGNR            F=AVX
VEX.66.L0.0f3a14/m     MRI  Mb  Vdq Ib  -   VPEXTRB             F=AVX
VEX.66.L0.0f3a14/r     MRI  Rd  Vdq Ib  -   VPEXTRB             F=AVX
VEX.66.L0.0f3a15/m     MRI  Mw  Vdq Ib  -   VPEXTRW             F=AVX
VEX.66.L0.0f3a15/r     MRI  Rd  Vdq Ib  -   VPEXTRW             F=AVX
VEX.66.W0.L0.0f3a16    MRI  Ey  Vdq Ib  -   VPEXTRD             F=AVX ENC_NOSZ
VEX.66.W1.L0.0f3a16    MRI  Ey  Vdq Ib  -   VPEXTRD     I64     F=AVX ENC_NOSZ
VEX.66.W1.L0.0f3a16    MRI  Ey  Vdq Ib  -   VPEXTRQ     O64     F=AVX ENC_NOSZ
VEX.66.L0.0f3a17       MRI  Ed  Vdq Ib  -   VEXTRACTPS          F=AVX
VEX.66.W0.L1.0f3a18    RVMI Vx  Hx  Wdq Ib  VINSERTF128         F=AVX ENC_NOSZ
VEX.66.W0.L1.0f3a19    MRI  Wdq Vx  Ib  -   VEXTRACTF128        F=AVX ENC_NOSZ
VEX.66.W0.0f3a1d       MRI  Wh  Vx  Ib  -   VCVTPS2PH           F=F16C
VEX.66.L0.0f3a20       RVMI Vdq Hdq Eb  Ib  VPINSRB             F=AVX
VEX.66.L0.0f3a21       RVMI Vdq Hdq Wd  Ib  VINSERTPS           F=AVX
VEX.66.W0.L0.0f3a22    RVMI Vdq Hdq Ey  Ib  VPINSRD             F=AVX ENC_NOSZ
VEX.66.W1.L0.0f3a22    RVMI Vdq Hdq Ey  Ib  VPINSRD     I64     F=AVX ENC_NOSZ
VEX.66.W1.L0.0f3a22    RVMI Vdq Hdq Ey  Ib  VPINSRQ     O64     F=AVX ENC_NOSZ
VEX.66.W0.L1.0f3a38    RVMI Vx  Hx  Wdq Ib  VINSERTI128         F=AVX2 ENC_NOSZ
VEX.66.W0.L1.0f3a39    MRI  Wdq Vx  Ib  -   VEXTRACTI128        F=AVX2 ENC_NOSZ
VEX.66.0f3a40          RVMI Vx  Hx  Wx  Ib  VDPPS               F=AVX
VEX.66.L0.0f3a41       RVMI Vx  Hx  Wx  Ib  VDPPD               F=AVX
VEX.66.0f3a42          RVMI Vx  Hx  Wx  Ib  VMPSADBW            F=AVX
VEX.66.0f3a44          RVMI Vx  Hx  Wx  Ib  VPCLMULQDQ          F=PCLMULQDQ,AVX
VEX.66.W0.L1.0f3a46    RVMI Vx  Hx  Wx  Ib  VPERM2I128          F=AVX2
VEX.66.W0.0f3a4a       RVMR Vx  Hx  Wx  Lx  VBLENDVPS           F=AVX
VEX.66.W0.0f3a4b       RVMR Vx  Hx  Wx  Lx  VBLENDVPD           F=AVX
VEX.66.W0.0f3a4c       RVMR Vx  Hx  Wx  Lx  VPBLENDVB           F=AVX
VEX.66.L0.0f3a60       RMI  Vx  Wx  Ib  -   VPCMPESTRM          F=AVX ENC_NOSZ
VEX.66.L0.0f3a61       RMI  Vx  Wx  Ib  -   VPCMPESTRI          F=AVX ENC_NOSZ
VEX.66.L0.0f3a62       RMI  Vx  Wx  Ib  -   VPCMPISTRM          F=AVX ENC_NOSZ
VEX.66.L0.0f3a63       RMI  Vx  Wx  Ib  -   VPCMPISTRI          F=AVX ENC_NOSZ
#
# BMI1
VEX.NP.L0.0f38f2       RVM  Gy  By  Ey  -   ANDN                F=BMI1 EFL=0--mmuu0
VEX.NP.L0.0f38f3/1     VM   By  Ey  -   -   BLSR                F=BMI1 EFL=0--mmuum
VEX.NP.L0.0f38f3/2     VM   By  Ey  -   -   BLSMSK              F=BMI1 EFL=0--m0uum
VEX.NP.L0.0f38f3/3     VM   By  Ey  -   -   BLSI                F=BMI1 EFL=0--mmuum
VEX.NP.L0.0f38f7       RMV  Gy  Ey  By  -   BEXTR               F=BMI1 EFL=0--umuu0
# BMI2
VEX.F2.L0.0f3af0       RMI  Gy  Ey  Ib  -   RORX                F=BMI2
VEX.NP.L0.0f38f5       RMV  Gy  Ey  By  -   BZHI                F=BMI2 EFL=0--mmuum
VEX.F2.L0.0f38f5       RVM  Gy  By  Ey  -   PDEP                F=BMI2
VEX.F3.L0.0f38f5       RVM  Gy  By  Ey  -   PEXT                F=BMI2
VEX.F2.L0.0f38f6       RVM  Gy  By  Ey  -   MULX                F=BMI2
VEX.66.L0.0f38f7       RMV  Gy  Ey  By  -   SHLX                F=BMI2
VEX.F2.L0.0f38f7       RMV  Gy  Ey  By  -   SHRX                F=BMI2
VEX.F3.L0.0f38f7       RMV  Gy  Ey  By  -   SARX                F=BMI2
# ADX
66.0f38f6              RM   Gy  Ey  -   -   ADCX                F=ADX EFL=-------M
F3.0f38f6              RM   Gy  Ey  -   -   ADOX                F=ADX EFL=M-------
#
# FPU
# Source for UNDOC opcodes: https://www.sandpile.org/x86/opc_fpu.htm
d8/0m                  M    Md  -   -   -   FADD                F=387 ENC_SEPSZ
d8/1m                  M    Md  -   -   -   FMUL                F=387 ENC_SEPSZ
d8/2m                  M    Md  -   -   -   FCOM                F=387 ENC_SEPSZ
d8/3m                  M    Md  -   -   -   FCOMP               F=387 ENC_SEPSZ
d8/4m                  M    Md  -   -   -   FSUB                F=387 ENC_SEPSZ
d8/5m                  M    Md  -   -   -   FSUBR               F=387 ENC_SEPSZ
d8/6m                  M    Md  -   -   -   FDIV                F=387 ENC_SEPSZ
d8/7m                  M    Md  -   -   -   FDIVR               F=387 ENC_SEPSZ
d8/0r                  AM   Ft  Ft  -   -   FADD                F=387
d8/1r                  AM   Ft  Ft  -   -   FMUL                F=387
d8/2r                  AM   Ft  Ft  -   -   FCOM                F=387
d8/3r                  AM   Ft  Ft  -   -   FCOMP               F=387
d8/4r                  AM   Ft  Ft  -   -   FSUB                F=387
d8/5r                  AM   Ft  Ft  -   -   FSUBR               F=387
d8/6r                  AM   Ft  Ft  -   -   FDIV                F=387
d8/7r                  AM   Ft  Ft  -   -   FDIVR               F=387
d9/0m                  M    Md  -   -   -   FLD                 F=387 ENC_SEPSZ
d9/2m                  M    Md  -   -   -   FST                 F=387 ENC_SEPSZ
d9/3m                  M    Md  -   -   -   FSTP                F=387 ENC_SEPSZ
d9/4m                  M    M   -   -   -   FLDENV              F=387
d9/5m                  M    Mw  -   -   -   FLDCW               F=387
d9/6m                  M    M   -   -   -   FSTENV              F=387
d9/7m                  M    Mw  -   -   -   FSTCW               F=387
d9/0r                  M    Ft  -   -   -   FLD                 F=387
d9/1r                  M    Ft  -   -   -   FXCH                F=387
d9d0                   NP   -   -   -   -   FNOP                F=387
d9/3r                  MA   Ft  Ft  -   -   FSTPNCE             F=387 UNDOC
d9e0                   NP   -   -   -   -   FCHS                F=387
d9e1                   NP   -   -   -   -   FABS                F=387
d9e4                   NP   -   -   -   -   FTST                F=387
d9e5                   NP   -   -   -   -   FXAM                F=387
d9e8                   NP   -   -   -   -   FLD1                F=387
d9e9                   NP   -   -   -   -   FLDL2T              F=387
d9ea                   NP   -   -   -   -   FLDL2E              F=387
d9eb                   NP   -   -   -   -   FLDPI               F=387
d9ec                   NP   -   -   -   -   FLDLG2              F=387
d9ed                   NP   -   -   -   -   FLDLN2              F=387
d9ee                   NP   -   -   -   -   FLDZ                F=387
d9f0                   NP   -   -   -   -   F2XM1               F=387
d9f1                   NP   -   -   -   -   FYL2X               F=387
d9f2                   NP   -   -   -   -   FPTAN               F=387
d9f3                   NP   -   -   -   -   FPATAN              F=387
d9f4                   NP   -   -   -   -   FXTRACT             F=387
d9f5                   NP   -   -   -   -   FPREM1              F=387
d9f6                   NP   -   -   -   -   FDECSTP             F=387
d9f7                   NP   -   -   -   -   FINCSTP             F=387
d9f8                   NP   -   -   -   -   FPREM               F=387
d9f9                   NP   -   -   -   -   FYL2XP1             F=387
d9fa                   NP   -   -   -   -   FSQRT               F=387
d9fb                   NP   -   -   -   -   FSINCOS             F=387
d9fc                   NP   -   -   -   -   FRNDINT             F=387
d9fd                   NP   -   -   -   -   FSCALE              F=387
d9fe                   NP   -   -   -   -   FSIN                F=387
d9ff                   NP   -   -   -   -   FCOS                F=387
da/0m                  M    Md  -   -   -   FIADD               F=387 ENC_SEPSZ
da/1m                  M    Md  -   -   -   FIMUL               F=387 ENC_SEPSZ
da/2m                  M    Md  -   -   -   FICOM               F=387 ENC_SEPSZ
da/3m                  M    Md  -   -   -   FICOMP              F=387 ENC_SEPSZ
da/4m                  M    Md  -   -   -   FISUB               F=387 ENC_SEPSZ
da/5m                  M    Md  -   -   -   FISUBR              F=387 ENC_SEPSZ
da/6m                  M    Md  -   -   -   FIDIV               F=387 ENC_SEPSZ
da/7m                  M    Md  -   -   -   FIDIVR              F=387 ENC_SEPSZ
da/0r                  M    Ft  -   -   -   FCMOVB              F=686 EFL=-------t
da/1r                  M    Ft  -   -   -   FCMOVE              F=686 EFL=----t---
da/2r                  M    Ft  -   -   -   FCMOVBE             F=686 EFL=----t--t
da/3r                  M    Ft  -   -   -   FCMOVU              F=686 EFL=------t-
dae9                   NP   -   -   -   -   FUCOMPP             F=387
db/0m                  M    Md  -   -   -   FILD                F=387 ENC_SEPSZ
db/1m                  M    Md  -   -   -   FISTTP              F=SSE3 ENC_SEPSZ
db/2m                  M    Md  -   -   -   FIST                F=387 ENC_SEPSZ
db/3m                  M    Md  -   -   -   FISTP               F=387 ENC_SEPSZ
db/5m                  M    Mt  -   -   -   FLD                 F=387 ENC_SEPSZ
db/7m                  M    Mt  -   -   -   FSTP                F=387 ENC_SEPSZ
db/0r                  M    Ft  -   -   -   FCMOVNB             F=686 EFL=-------t
db/1r                  M    Ft  -   -   -   FCMOVNE             F=686 EFL=----t---
db/2r                  M    Ft  -   -   -   FCMOVNBE            F=686 EFL=----t--t
db/3r                  M    Ft  -   -   -   FCMOVNU             F=686 EFL=------t-
dbe0                   NP   -   -   -   -   FENI8087_NOP        F=387 UNDOC
dbe1                   NP   -   -   -   -   FDISI8087_NOP       F=387 UNDOC
dbe2                   NP   -   -   -   -   FCLEX               F=387
dbe3                   NP   -   -   -   -   FINIT               F=387
dbe4                   NP   -   -   -   -   FSETPM287_NOP       F=387 UNDOC
dbe5                   NP   -   -   -   -   FSETPM287_NOP       F=387 UNDOC
db/5r                  M    Ft  -   -   -   FUCOMI              F=686 EFL=0--0m0mm
db/6r                  M    Ft  -   -   -   FCOMI               F=686 EFL=0--0m0mm
dc/0m                  M    Mq  -   -   -   FADD                F=387 ENC_SEPSZ
dc/1m                  M    Mq  -   -   -   FMUL                F=387 ENC_SEPSZ
dc/2m                  M    Mq  -   -   -   FCOM                F=387 ENC_SEPSZ
dc/3m                  M    Mq  -   -   -   FCOMP               F=387 ENC_SEPSZ
dc/4m                  M    Mq  -   -   -   FSUB                F=387 ENC_SEPSZ
dc/5m                  M    Mq  -   -   -   FSUBR               F=387 ENC_SEPSZ
dc/6m                  M    Mq  -   -   -   FDIV                F=387 ENC_SEPSZ
dc/7m                  M    Mq  -   -   -   FDIVR               F=387 ENC_SEPSZ
dc/0r                  MA   Ft  Ft  -   -   FADD                F=387
dc/1r                  MA   Ft  Ft  -   -   FMUL                F=387
dc/2r                  MA   Ft  Ft  -   -   FCOM                F=387 UNDOC
dc/3r                  MA   Ft  Ft  -   -   FCOMP               F=387 UNDOC
dc/4r                  MA   Ft  Ft  -   -   FSUBR               F=387
dc/5r                  MA   Ft  Ft  -   -   FSUB                F=387
dc/6r                  MA   Ft  Ft  -   -   FDIVR               F=387
dc/7r                  MA   Ft  Ft  -   -   FDIV                F=387
dd/0m                  M    Mq  -   -   -   FLD                 F=387 ENC_SEPSZ
dd/1m                  M    Mq  -   -   -   FISTTP              F=387 ENC_SEPSZ
dd/2m                  M    Mq  -   -   -   FST                 F=387 ENC_SEPSZ
dd/3m                  M    Mq  -   -   -   FSTP                F=387 ENC_SEPSZ
dd/4m                  M    M   -   -   -   FRSTOR              F=387
dd/6m                  M    M   -   -   -   FSAVE               F=387
dd/7m                  M    Mw  -   -   -   FSTSW               F=387
dd/0r                  M    Ft  -   -   -   FFREE               F=387
dd/1r                  AM   Ft  Ft  -   -   FXCH                F=387 UNDOC
dd/2r                  M    Ft  -   -   -   FST                 F=387
dd/3r                  M    Ft  -   -   -   FSTP                F=387
dd/4r                  M    Ft  -   -   -   FUCOM               F=387
dd/5r                  M    Ft  -   -   -   FUCOMP              F=387
de/0m                  M    Mw  -   -   -   FIADD               F=387 ENC_SEPSZ
de/1m                  M    Mw  -   -   -   FIMUL               F=387 ENC_SEPSZ
de/2m                  M    Mw  -   -   -   FICOM               F=387 ENC_SEPSZ
de/3m                  M    Mw  -   -   -   FICOMP              F=387 ENC_SEPSZ
de/4m                  M    Mw  -   -   -   FISUB               F=387 ENC_SEPSZ
de/5m                  M    Mw  -   -   -   FISUBR              F=387 ENC_SEPSZ
de/6m                  M    Mw  -   -   -   FIDIV               F=387 ENC_SEPSZ
de/7m                  M    Mw  -   -   -   FIDIVR              F=387 ENC_SEPSZ
de/0r                  MA   Ft  Ft  -   -   FADDP               F=387
de/1r                  MA   Ft  Ft  -   -   FMULP               F=387
de/2r                  AM   Ft  Ft  -   -   FCOMP               F=387 UNDOC
ded9                   NP   -   -   -   -   FCOMPP              F=387
de/4r                  MA   Ft  Ft  -   -   FSUBRP              F=387
de/5r                  MA   Ft  Ft  -   -   FSUBP               F=387
de/6r                  MA   Ft  Ft  -   -   FDIVRP              F=387
de/7r                  MA   Ft  Ft  -   -   FDIVP               F=387
df/0m                  M    Mw  -   -   -   FILD                F=387 ENC_SEPSZ
df/1m                  M    Mw  -   -   -   FISTTP              F=387 ENC_SEPSZ
df/2m                  M    Mw  -   -   -   FIST                F=387 ENC_SEPSZ
df/3m                  M    Mw  -   -   -   FISTP               F=387 ENC_SEPSZ
df/4m                  M    Mt  -   -   -   FBLD                F=387
df/5m                  M    Mq  -   -   -   FILD                F=387 ENC_SEPSZ
df/6m                  M    Mt  -   -   -   FBSTP               F=387
df/7m                  M    Mq  -   -   -   FISTP               F=387 ENC_SEPSZ
df/0r                  M    Ft  -   -   -   FFREEP              F=387 UNDOC
df/1r                  AM   Ft  Ft  -   -   FXCH                F=387 UNDOC
df/2r                  MA   Ft  Ft  -   -   FSTP                F=387 UNDOC
df/3r                  MA   Ft  Ft  -   -   FSTP                F=387 UNDOC
# FSTSW AX
dfe0                   A    Rw  -   -   -   FSTSW               F=387
df/5r                  AM   Ft  Ft  -   -   FUCOMIP             F=686 EFL=0--0m0mm
df/6r                  AM   Ft  Ft  -   -   FCOMIP              F=686 EFL=0--0m0mm
#
# Control Flow Enforcement
F3.0f01/5m             M    Mq  -   -   -   RSTORSSP            F=CET
F3.0f01e8              NP   -   -   -   -   SETSSBSY            F=CET CPL0
F3.0f01ea              NP   -   -   -   -   SAVEPREVSSP         F=CET
F3.0f1e/1r             M    Ry  -   -   -   RDSSP               F=CET
F3.0f1efa              NP   -   -   -   -   ENDBR64             F=CET
F3.0f1efb              NP   -   -   -   -   ENDBR32             F=CET
66.0f38f5/m            MR   My  Gy  -   -   WRUSS               F=CET
NP.0f38f6/m            MR   My  Gy  -   -   WRSS                F=CET
F3.0fae/6m             M    Mq  -   -   -   CLRSSBSY            F=CET CPL0
F3.0fae/5r             M    Ry  -   -   -   INCSSP              F=CET
#
# CLDEMOTE
NP.0f1c/0m             M    Mb  -   -   -   CLDEMOTE            F=CLDEMOTE

# VIA PadLock
F3.0fa6c0              NP   -   -   -   -   REP_MONTMUL         F=PADLOCK ONLYVIA
F3.0fa6c8              NP   -   -   -   -   REP_XSHA1           F=PADLOCK ONLYVIA
F3.0fa6d0              NP   -   -   -   -   REP_XSHA256         F=PADLOCK ONLYVIA
NFx.0fa7c0             NP   -   -   -   -   XSTORE              F=PADLOCK ONLYVIA
F3.0fa7c0              NP   -   -   -   -   REP_XSTORE          F=PADLOCK ONLYVIA
F3.0fa7c8              NP   -   -   -   -   REP_XCRYPTECB       F=PADLOCK ONLYVIA
F3.0fa7d0              NP   -   -   -   -   REP_XCRYPTCBC       F=PADLOCK ONLYVIA
F3.0fa7d8              NP   -   -   -   -   REP_XCRYPTCTR       F=PADLOCK ONLYVIA
F3.0fa7e0              NP   -   -   -   -   REP_XCRYPTCFB       F=PADLOCK ONLYVIA
F3.0fa7e8              NP   -   -   -   -   REP_XCRYPTOFB       F=PADLOCK ONLYVIA

# VMX
66.0f3880/m            RM   Gy  Mdq -   -   INVEPT          D64 F=VMX EFL=0--0m00m CPL0
66.0f3881/m            RM   Gy  Mdq -   -   INVVPID         D64 F=VMX EFL=0--0m00m CPL0
NP.0f01c1              NP   -   -   -   -   VMCALL              F=VMX EFL=0--0m00m CPL0
66.0fc7/6m             M    Mq  -   -   -   VMCLEAR             F=VMX EFL=0--0m00m CPL0
NP.0f01d4              NP   -   -   -   -   VMFUNC              F=VMX EFL=0--0m00m
NP.0f01c2              NP   -   -   -   -   VMLAUNCH            F=VMX EFL=0--0m00m CPL0
NP.0f01c3              NP   -   -   -   -   VMRESUME            F=VMX EFL=0--0m00m CPL0
NP.0fc7/6m             M    Mq  -   -   -   VMPTRLD             F=VMX EFL=0--0m00m CPL0
NP.0fc7/7m             M    Mq  -   -   -   VMPTRST             F=VMX EFL=0--0m00m CPL0
NP.0f78                MR   Ey  Gy  -   -   VMREAD          D64 F=VMX EFL=0--0m00m CPL0
NP.0f79                RM   Gy  Ey  -   -   VMWRITE         D64 F=VMX EFL=0--0m00m CPL0
NP.0f01c4              NP   -   -   -   -   VMXOFF              F=VMX EFL=0--0m00m CPL0
F3.0fc7/6m             M    Mq  -   -   -   VMXON               F=VMX EFL=0--0m00m CPL0
# SEAM/TDX
66.0f01cc              NP   -   -   -   -   TDCALL              F=SEAM
66.0f01cd              NP   -   -   -   -   SEAMRET             F=SEAM
66.0f01ce              NP   -   -   -   -   SEAMOPS             F=SEAM
66.0f01cf              NP   -   -   -   -   SEAMCALL            F=SEAM

# AMD CLZERO
0f01fc                 A    Rv  -   -   -   CLZERO              F=CLZERO ONLYAMD

# AMD RDPRU
# Tested on hardware, 66 prefix also accepted. F2/F3 trigger UD.
NFx.0f01fd             NP   -   -   -   -   RDPRU               F=RDPRU ONLYAMD

# AMD SVM
0f01d8                 NP   -   -   -   -   VMRUN               F=SVM ONLYAMD CPL0
NFx.0f01d9             NP   -   -   -   -   VMMCALL             F=SVM ONLYAMD
F3.0f01d9              NP   -   -   -   -   VMGEXIT             F=SEVES ONLYAMD
F2.0f01d9              NP   -   -   -   -   VMGEXIT             F=SEVES ONLYAMD
0f01da                 NP   -   -   -   -   VMLOAD              F=SVM ONLYAMD CPL0
0f01db                 NP   -   -   -   -   VMSAVE              F=SVM ONLYAMD CPL0
0f01dc                 NP   -   -   -   -   STGI                F=SKINIT ONLYAMD CPL0
0f01dd                 NP   -   -   -   -   CLGI                F=SKINIT ONLYAMD CPL0
0f01de                 NP   -   -   -   -   SKINIT              EFL=00000000 F=SKINIT ONLYAMD CPL0
0f01df                 NP   -   -   -   -   INVLPGA             F=SVM ONLYAMD CPL0
NP.0f01fa              NP   -   -   -   -   MONITORX            F=MONITORX ONLYAMD
F3.0f01fa              NP   -   -   -   -   MCOMMIT             F=MCOMMIT ONLYAMD
NP.0f01fb              NP   -   -   -   -   MWAITX              F=MONITORX ONLYAMD
NP.0f01fe              NP   -   -   -   -   INVLPGB             F=INVLPGB ONLYAMD CPL0
NP.0f01ff              NP   -   -   -   -   TLBSYNC             F=INVLPGB ONLYAMD CPL0

# AMD SNP
F3.0f01fd              NP   -   -   -   -   RMPQUERY    O64     EFL=m--mmmm- F=RMPQUERY ONLYAMD CPL0
F2.0f01fd              NP   -   -   -   -   RMPREAD     O64     EFL=m--mmmm- F=RMPREAD ONLYAMD CPL0
F3.0f01fe              NP   -   -   -   -   RMPADJUST   O64     EFL=m--mmmm- F=SNP ONLYAMD CPL0
F2.0f01fe              NP   -   -   -   -   RMPUPDATE   O64     EFL=m--mmmm- F=SNP ONLYAMD CPL0
F3.0f01ff              NP   -   -   -   -   PSMASH      O64     EFL=m--mmmm- F=SNP ONLYAMD
F2.0f01ff              NP   -   -   -   -   PVALIDATE   O64     EFL=m--mmmmm F=SNP ONLYAMD

# WAITPKG
66.0fae/6r             M    Rd  -   -   -   TPAUSE              F=WAITPKG EFL=0--0000m
# TODO: Ry operand is address-sized
F3.0fae/6r             M    Ry  -   -   -   UMONITOR            F=WAITPKG
F2.0fae/6r             M    Rd  -   -   -   UMWAIT              F=WAITPKG EFL=0--0000m

# PRWRITE
F3.0fae/4              M    Ey  -   -   -   PTWRITE             F=PTWRITE

# GFNI
66.0f38cf              RM   Vx  Wx  -   -   GF2P8MULB           F=GFNI
66.0f3ace              RMI  Vx  Wx  Ib  -   GF2P8AFFINEQB       F=GFNI
66.0f3acf              RMI  Vx  Wx  Ib  -   GF2P8AFFINEINVQB    F=GFNI
VEX.66.W0.0f38cf       RVM  Vx  Hx  Wx  -   VGF2P8MULB          F=AVX,GFNI
VEX.66.W1.0f3ace       RVMI Vx  Hx  Wx  Ib  VGF2P8AFFINEQB      F=AVX,GFNI
VEX.66.W1.0f3acf       RVMI Vx  Hx  Wx  Ib  VGF2P8AFFINEINVQB   F=AVX,GFNI
EVEX.66.W0.0f38cf      RVM  Vx  Hx  Wx  -   EVX_GF2P8MULB+k     F=AVX,GFNI TUPLE_FULL_MEM
EVEX.66.W1.0f3ace      RVMI Vx  Hx  Wx  Ib  EVX_GF2P8AFFINEQB+kb F=AVX512F,GFNI TUPLE_FULL_64
EVEX.66.W1.0f3acf      RVMI Vx  Hx  Wx  Ib  EVX_GF2P8AFFINEINVQB+kb F=AVX512F,GFNI TUPLE_FULL_64

# ENQCMD
# TODO: Gy operands are address-sized
F2.0f38f8/m            RM   Gy  Moq -   -   ENQCMD              F=ENQCMD
F3.0f38f8/m            RM   Gy  Moq -   -   ENQCMDS             F=ENQCMD

# PCONFIG
NP.0f01c5              NP   -   -   -   -   PCONFIG             F=PCONFIG

# WBNOINVD
F3.0f09                NP   -   -   -   -   WBNOINVD            F=WBNOINVD CPL0

NP.0f01ee              NP   -   -   -   -   RDPKRU              F=OSPKE
NP.0f01ef              NP   -   -   -   -   WRPKRU              F=OSPKE
F3.0fae/0r             M    Ry  -   -   -   RDFSBASE    O64     F=FSGSBASE
F3.0fae/1r             M    Ry  -   -   -   RDGSBASE    O64     F=FSGSBASE
F3.0fae/2r             M    Ry  -   -   -   WRFSBASE    O64     F=FSGSBASE
F3.0fae/3r             M    Ry  -   -   -   WRGSBASE    O64     F=FSGSBASE
NP.0fae/4m             M    M   -   -   -   XSAVE+w             F=XSAVE
NP.0fae/5m             M    M   -   -   -   XRSTOR+w            F=XSAVE
NP.0fae/6m             M    M   -   -   -   XSAVEOPT+w          F=XSAVEOPT
66.0fae/6m             M    Mb  -   -   -   CLWB                F=CLWB
NP.0fae/7m             M    Mb  -   -   -   CLFLUSH             F=CLFLSH
66.0fae/7m             M    Mb  -   -   -   CLFLUSHOPT          F=CLFLUSHOPT
NP.0fc7/3m             M    M   -   -   -   XRSTORS+w           F=XSS
NP.0fc7/4m             M    M   -   -   -   XSAVEC+w            F=XSAVEC
NP.0fc7/5m             M    M   -   -   -   XSAVES+w            F=XSS
NFx.0fc7/6r            M    Rv  -   -   -   RDRAND              F=RDRAND EFL=0--0000m
NFx.0fc7/7r            M    Rv  -   -   -   RDSEED              F=RDSEED EFL=0--0000m
F3.0fc7/7r             M    Ry  -   -   -   RDPID           D64 F=RDPID
66.0f3882/m            RM   Gy  Mdq -   -   INVPCID         D64 F=INVPCID CPL0
NP.0f38c8              RM   Vdq Wdq -   -   SHA1NEXTE           F=SHA
NP.0f38c9              RM   Vdq Wdq -   -   SHA1MSG1            F=SHA
NP.0f38ca              RM   Vdq Wdq -   -   SHA1MSG2            F=SHA
NP.0f38cb              RMA  Vdq Wdq Hdq -   SHA256RNDS2         F=SHA
NP.0f38cc              RM   Vdq Wdq -   -   SHA256MSG1          F=SHA
NP.0f38cd              RM   Vdq Wdq -   -   SHA256MSG2          F=SHA
NP.0f3acc              RMI  Vdq Wdq Ib  -   SHA1RNDS4           F=SHA

#NP.0f1a/m             RM   Z   M   -   -   BNDLDX              F=MPX
#66.0f1a               RM   Z   Z   -   -   BNDMOV          D64 F=MPX
#F2.0f1a               RM   Z   Ey  -   -   BNDCU           D64 F=MPX
#F3.0f1a               RM   Z   Ey  -   -   BNDCL           D64 F=MPX
#NP.0f1b/m             MR   M   Z   -   -   BNDSTX              F=MPX
#66.0f1b               MR   Z   Z   -   -   BNDMOV          D64 F=MPX
#F2.0f1b               RM   Z   Ey  -   -   BNDCN           D64 F=MPX
#F3.0f1b/m             RM   Z   M   -   -   BNDMK               F=MPX

# TSXLDTRK
F2.0f01e8              NP   -   -   -   -   XSUSLDTRK           F=TSXLDTRK
F2.0f01e9              NP   -   -   -   -   XRESLDTRK           F=TSXLDTRK

# AVX_VNNI
VEX.NP.W0.0f3850       RVM  Vx  Hx  Wx  -   VPDPBUUD            F=VNNI-INT8
VEX.66.W0.0f3850       RVM  Vx  Hx  Wx  -   VPDPBUSD            F=VNNI
VEX.F3.W0.0f3850       RVM  Vx  Hx  Wx  -   VPDPBSUD            F=VNNI-INT8
VEX.F2.W0.0f3850       RVM  Vx  Hx  Wx  -   VPDPBSSD            F=VNNI-INT8
VEX.NP.W0.0f3851       RVM  Vx  Hx  Wx  -   VPDPBUUDS           F=VNNI-INT8
VEX.66.W0.0f3851       RVM  Vx  Hx  Wx  -   VPDPBUSDS           F=VNNI
VEX.F3.W0.0f3851       RVM  Vx  Hx  Wx  -   VPDPBSUDS           F=VNNI-INT8
VEX.F2.W0.0f3851       RVM  Vx  Hx  Wx  -   VPDPBSSDS           F=VNNI-INT8
VEX.66.W0.0f3852       RVM  Vx  Hx  Wx  -   VPDPWSSD            F=VNNI
VEX.66.W0.0f3853       RVM  Vx  Hx  Wx  -   VPDPWSSDS           F=VNNI

# AVX-NE-CONVERT
VEX.NP.W0.0f38b0/m     RM   Vx  Mx  -   -   VCVTNEOPH2PS        F=AVX-NE-CONVERT
VEX.66.W0.0f38b0/m     RM   Vx  Mx  -   -   VCVTNEEPH2PS        F=AVX-NE-CONVERT
VEX.F3.W0.0f38b0/m     RM   Vx  Mx  -   -   VCVTNEEBF162PS      F=AVX-NE-CONVERT
VEX.F2.W0.0f38b0/m     RM   Vx  Mx  -   -   VCVTNEOBF162PS      F=AVX-NE-CONVERT
VEX.66.W0.0f38b1/m     RM   Vx  Mw  -   -   VBCSTNESH2PS        F=AVX-NE-CONVERT
VEX.F3.W0.0f38b1/m     RM   Vx  Mw  -   -   VBCSTNEBF162PS      F=AVX-NE-CONVERT
VEX.F3.W0.0f3872       RM   Vh  Wps -   -   VCVTNEPS2BF16       F=AVX-NE-CONVERT

# AVX-IFMA
VEX.66.W1.0f38b4       RVM  Vx  Hx  Wx  -   VPMADD52LUQ         F=AVX-IFMA
VEX.66.W1.0f38b5       RVM  Vx  Hx  Wx  -   VPMADD52HUQ         F=AVX-IFMA

# HRESET
F3.0f3af0c0            I    Ib  -   -   -   HRESET              F=HRESET

# SERIALIZE
NP.0f01e8              NP   -   -   -   -   SERIALIZE           F=SERIALIZE

# UINTR
F3.0f01ec              NP   -   -   -   -   UIRET       O64     F=UINTR
F3.0f01ed              NP   -   -   -   -   TESTUI      O64     F=UINTR
F3.0f01ee              NP   -   -   -   -   CLUI        O64     F=UINTR
F3.0f01ef              NP   -   -   -   -   STUI        O64     F=UINTR
F3.0fc7/6r             M    Ry  -   -   -   SENDUIPI    O64 D64 F=UINTR

# WRMSRNS
NP.0f01c6              NP   -   -   -   -   WRMSRNS             F=WRMSRNS CPL0

# MSRLIST
F2.0f01c6              NP   -   -   -   -   RDMSRLIST   O64     F=MSRLIST CPL0
F3.0f01c6              NP   -   -   -   -   WRMSRLIST   O64     F=MSRLIST CPL0

# RAO-INT
NP.0f38fc/m            MR   My  Gy  -   -   AADD                F=RAO-INT
66.0f38fc/m            MR   My  Gy  -   -   AAND                F=RAO-INT
F3.0f38fc/m            MR   My  Gy  -   -   AXOR                F=RAO-INT
F2.0f38fc/m            MR   My  Gy  -   -   AOR                 F=RAO-INT

# CMPCCXADD
VEX.66.L0.0f38e0/m     MRV  My  Gy  By  -   CMPOXADD    O64     F=CMPCCXADD EFL=m--mmmmm ENC_CC_BEGIN
VEX.66.L0.0f38e1/m     MRV  My  Gy  By  -   CMPNOXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e2/m     MRV  My  Gy  By  -   CMPBXADD    O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e3/m     MRV  My  Gy  By  -   CMPNBXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e4/m     MRV  My  Gy  By  -   CMPZXADD    O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e5/m     MRV  My  Gy  By  -   CMPNZXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e6/m     MRV  My  Gy  By  -   CMPBEXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e7/m     MRV  My  Gy  By  -   CMPNBEXADD  O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e8/m     MRV  My  Gy  By  -   CMPSXADD    O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38e9/m     MRV  My  Gy  By  -   CMPNSXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38ea/m     MRV  My  Gy  By  -   CMPPXADD    O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38eb/m     MRV  My  Gy  By  -   CMPNPXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38ec/m     MRV  My  Gy  By  -   CMPLXADD    O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38ed/m     MRV  My  Gy  By  -   CMPNLXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38ee/m     MRV  My  Gy  By  -   CMPLEXADD   O64     F=CMPCCXADD EFL=m--mmmmm
VEX.66.L0.0f38ef/m     MRV  My  Gy  By  -   CMPNLEXADD  O64     F=CMPCCXADD EFL=m--mmmmm

# AESKLE/KL (Key Locker)
F3.0f38d8/0m           M    M   -   -   -   AESENCWIDE128KL     F=AESKLE
F3.0f38d8/1m           M    M   -   -   -   AESDECWIDE128KL     F=AESKLE
F3.0f38d8/2m           M    M   -   -   -   AESENCWIDE256KL     F=AESKLE
F3.0f38d8/3m           M    M   -   -   -   AESDECWIDE256KL     F=AESKLE
F3.0f38dc/m            RM   Vx  M   -   -   AESENC128KL         F=AESKLE
F3.0f38dc/r            RM   Vx  Ux  -   -   LOADIWKEY           F=AESKLE
F3.0f38dd/m            RM   Vx  M   -   -   AESDEC128KL         F=AESKLE
F3.0f38de/m            RM   Vx  M   -   -   AESENC256KL         F=AESKLE
F3.0f38df/m            RM   Vx  M   -   -   AESDEC256KL         F=AESKLE
F3.0f38fa/r            RM   Gd  Rd  -   -   ENCODEKEY128        F=AESKLE
F3.0f38fb/r            RM   Gd  Rd  -   -   ENCODEKEY256        F=AESKLE

# FRED
F2.0f00/6              M    Ew  -   -   -   LKGS                F=FRED
F3.0f01ca              NP   -   -   -   -   ERETU               F=FRED
F2.0f01ca              NP   -   -   -   -   ERETS               F=FRED

# AMX
VEX.NP.W0.L0.0f3849/0m M    M   -   -   -   LDTILECFG   O64     F=AMX-TILE
VEX.66.W0.L0.0f3849/0m M    M   -   -   -   STTILECFG   O64     F=AMX-TILE
VEX.NP.W0.L0.0f3849c0  NP   -   -   -   -   TILERELEASE O64     F=AMX-TILE
VEX.F2.W0.L0.0f3849/r0 R    T   -   -   -   TILEZERO    O64     F=AMX-TILE
VEX.66.W0.L0.0f384b/m4 RM   T   M   -   -   TILELOADDT1 O64     F=AMX-TILE
VEX.F3.W0.L0.0f384b/m4 MR   M   T   -   -   TILESTORED  O64     F=AMX-TILE
VEX.F2.W0.L0.0f384b/m4 RM   T   M   -   -   TILELOADD   O64     F=AMX-TILE
VEX.F3.W0.L0.0f385c/r  RMV  T   T   T   -   TDPBF16PS   O64     F=AMX-BF16
VEX.F2.W0.L0.0f385c/r  RMV  T   T   T   -   TDPFP16PS   O64     F=AMX-FP16
VEX.NP.W0.L0.0f385e/r  RMV  T   T   T   -   TDPBUUD     O64     F=AMX-INT8
VEX.66.W0.L0.0f385e/r  RMV  T   T   T   -   TDPBUSD     O64     F=AMX-INT8
VEX.F3.W0.L0.0f385e/r  RMV  T   T   T   -   TDPBSUD     O64     F=AMX-INT8
VEX.F2.W0.L0.0f385e/r  RMV  T   T   T   -   TDPBSSD     O64     F=AMX-INT8
VEX.NP.W0.L0.0f386c/r  RMV  T   T   T   -   TCMMRLFP16PS O64    F=AMX-COMPLEX
VEX.66.W0.L0.0f386c/r  RMV  T   T   T   -   TCMMIMFP16PS O64    F=AMX-COMPLEX

# PBNDKB
NP.0f01c7              NP   -   -   -   -   PBNDKB      O64     F=PBNDKB CPL0

# MSR_IMM
VEX.F2.W0.L0.M7.f6/0r  MI   Rq  Id  -   -   RDMSR       O64     F=MSR_IMM CPL0
VEX.F3.W0.L0.M7.f6/0r  IM   Id  Rq  -   -   WRMSRNS     O64     F=MSR_IMM CPL0

# USER_MSR
F2.0f38f8/r            MR   Rq  Gq  -   -   URDMSR      O64     F=USER_MSR
F3.0f38f8/r            MR   Rq  Gq  -   -   UWRMSR      O64     F=USER_MSR
VEX.F2.W0.L0.M7.f8/0r  MI   Rq  Id  -   -   URDMSR      O64     F=USER_MSR
VEX.F3.W0.L0.M7.f8/0r  IM   Id  Rq  -   -   UWRMSR      O64     F=USER_MSR

# SM4
VEX.F3.W0.0f38da       RVM  Vx  Hx  Wx  -   VSM4KEY4            F=AVX,SM4
VEX.F2.W0.0f38da       RVM  Vx  Hx  Wx  -   VSM4RNDS4           F=AVX,SM4
EVEX.F3.W0.0f38da      RVM  Vx  Hx  Wx  -   VSM4KEY4            F=AVX10.2,SM4 TUPLE_FULL_MEM
EVEX.F2.W0.0f38da      RVM  Vx  Hx  Wx  -   VSM4RNDS4           F=AVX10.2,SM4 TUPLE_FULL_MEM

# AVX512
EVEX.NP.W0.0f58        RVM  Vps Hps Wps -   EVX_ADDPS+kbr       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f58        RVM  Vpd Hpd Wpd -   EVX_ADDPD+kbr       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f58    RVM  Vdq Hdq Wss -   EVX_ADDSS+kr        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f58    RVM  Vdq Hdq Wsd -   EVX_ADDSD+kr        F=AVX512F TUPLE1_SCALAR_64
EVEX.66.0f38dc         RVM  Vx  Hx  Wx  -   EVX_AESENC          F=AVX512F,VAES TUPLE_FULL_MEM
EVEX.66.0f38dd         RVM  Vx  Hx  Wx  -   EVX_AESENCLAST      F=AVX512F,VAES TUPLE_FULL_MEM
EVEX.66.0f38de         RVM  Vx  Hx  Wx  -   EVX_AESDEC          F=AVX512F,VAES TUPLE_FULL_MEM
EVEX.66.0f38df         RVM  Vx  Hx  Wx  -   EVX_AESDECLAST      F=AVX512F,VAES TUPLE_FULL_MEM
EVEX.NP.W0.0f54        RVM  Vps Hps Wps -   EVX_ANDPS+kb        F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f54        RVM  Vpd Hpd Wpd -   EVX_ANDPD+kb        F=AVX512DQ TUPLE_FULL_64
EVEX.NP.W0.0f55        RVM  Vps Hps Wps -   EVX_ANDNPS+kb       F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f55        RVM  Vpd Hpd Wpd -   EVX_ANDNPD+kb       F=AVX512DQ TUPLE_FULL_64
EVEX.NP.W0.0fc2        RVMI Kb  Hps Wps Ib  EVX_CMPPS+kbe       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0fc2        RVMI Kb  Hpd Wpd Ib  EVX_CMPPD+kbe       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0fc2    RVMI Kb  Hss Wss Ib  EVX_CMPSS+ke        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0fc2    RVMI Kb  Hsd Wsd Ib  EVX_CMPSD+ke        F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.LIG.0f2f    RM   Vss Wss -   -   EVX_COMISS+e        F=AVX512F TUPLE1_SCALAR_32 EFL=0--0m0mm
EVEX.66.W1.LIG.0f2f    RM   Vsd Wsd -   -   EVX_COMISD+e        F=AVX512F TUPLE1_SCALAR_64 EFL=0--0m0mm
# Note: SAE is ignored
EVEX.F3.W0.0fe6        RM   Vpd Wh  -   -   EVX_CVTDQ2PD+kbe    F=AVX512F TUPLE_HALF_32
EVEX.F2.W1.0fe6        RM   Vh  Wpd -   -   EVX_CVTPD2DQ+kbr    F=AVX512F TUPLE_FULL_64
EVEX.NP.W0.0f5b        RM   Vps Wps -   -   EVX_CVTDQ2PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W0.0f5b        RM   Vps Wps -   -   EVX_CVTPS2DQ+kbr    F=AVX512F TUPLE_FULL_32
EVEX.NP.W0.0f5a        RM   Vpd Wh  -   -   EVX_CVTPS2PD+kbe    F=AVX512F TUPLE_HALF_32
EVEX.66.W1.0f5a        RM   Vh  Wpd -   -   EVX_CVTPD2PS+kbr    F=AVX512F TUPLE_FULL_64
EVEX.F3.LIG.0f2d       RM   Gy  Wss -   -   EVX_CVTSS2SI+r      F=AVX512F TUPLE1_FIXED_32
EVEX.F2.LIG.0f2d       RM   Gy  Wsd -   -   EVX_CVTSD2SI+r      F=AVX512F TUPLE1_FIXED_64
EVEX.F3.W0.LIG.0f5a    RVM  Vdq Hdq Wss -   EVX_CVTSS2SD+ke     F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f5a    RVM  Vdq Hdq Wsd -   EVX_CVTSD2SS+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.F3.LIG.0f2a       RVM  Vdq Hdq Ey  -   EVX_CVTSI2SS+r      F=AVX512F TUPLE1_SCALAR_OPSZ
# Note: for W0, ER is ignored (i.e., will not UD, according to Intel SDM)
EVEX.F2.LIG.0f2a       RVM  Vdq Hdq Ey  -   EVX_CVTSI2SD+r      F=AVX512F TUPLE1_SCALAR_OPSZ
EVEX.66.W1.0fe6        RM   Vh  Wpd -   -   EVX_CVTTPD2DQ+kbe   F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.0f5b        RM   Vps Wps -   -   EVX_CVTTPS2DQ+kbe   F=AVX512F TUPLE_FULL_32
EVEX.F2.LIG.0f2c       RM   Gy  Wsd -   -   EVX_CVTTSD2SI+e     F=AVX512F TUPLE1_FIXED_64
EVEX.F3.LIG.0f2c       RM   Gy  Wss -   -   EVX_CVTTSS2SI+e     F=AVX512F TUPLE1_FIXED_32
EVEX.NP.W0.0f5e        RVM  Vps Hps Wps -   EVX_DIVPS+kbr       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f5e        RVM  Vpd Hpd Wpd -   EVX_DIVPD+kbr       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f5e    RVM  Vdq Hdq Wss -   EVX_DIVSS+kr        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f5e    RVM  Vdq Hdq Wsd -   EVX_DIVSD+kr        F=AVX512F TUPLE1_SCALAR_64
# Note: tuple size is actually fixed at 32 bits, regardless of EVEX.W
EVEX.66.L0.0f3a17      MRI  Ess Vdq Ib  -   EVX_EXTRACTPS       F=AVX512F TUPLE1_FIXED_32
EVEX.66.W0.L0.0f3a21   RVMI Vdq Hdq Wss Ib  EVX_INSERTPS        F=AVX512F TUPLE1_SCALAR_32
EVEX.NP.W0.0f5f        RVM  Vps Hps Wps -   EVX_MAXPS+kbe       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f5f        RVM  Vpd Hpd Wpd -   EVX_MAXPD+kbe       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f5f    RVM  Vdq Hdq Wss -   EVX_MAXSS+ke        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f5f    RVM  Vdq Hdq Wsd -   EVX_MAXSD+ke        F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.0f5d        RVM  Vps Hps Wps -   EVX_MINPS+kbe       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f5d        RVM  Vpd Hpd Wpd -   EVX_MINPD+kbe       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f5d    RVM  Vdq Hdq Wss -   EVX_MINSS+ke        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f5d    RVM  Vdq Hdq Wsd -   EVX_MINSD+ke        F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.0f28        RM   Vps Wps -   -   EVX_MOVAPS+k        F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f28        RM   Vpd Wpd -   -   EVX_MOVAPD+k        F=AVX512F TUPLE_FULL_MEM
EVEX.NP.W0.0f29        MR   Wps Vps -   -   EVX_MOVAPS+k        F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f29        MR   Wpd Vpd -   -   EVX_MOVAPD+k        F=AVX512F TUPLE_FULL_MEM
EVEX.66.L0.0f7e        MR   Ey  Vy  -   -   EVX_MOV_X2G         F=AVX512F TUPLE1_SCALAR_OPSZ
EVEX.66.L0.0f6e        RM   Vy  Ey  -   -   EVX_MOV_G2X         F=AVX512F TUPLE1_SCALAR_OPSZ
EVEX.F2.W1.L0.0f12     RM   Vpd Wq  -   -   EVX_MOVDDUP+k       F=AVX512F TUPLE1_SCALAR_64
EVEX.F2.W1.L12.0f12    RM   Vpd Wpd -   -   EVX_MOVDDUP+k       F=AVX512F TUPLE_MOVDDUP
EVEX.66.W0.0f6f        RM   Vx  Wx  -   -   EVX_MOVDQA32+k      F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f6f        RM   Vx  Wx  -   -   EVX_MOVDQA64+k      F=AVX512F TUPLE_FULL_MEM
EVEX.66.W0.0f7f        MR   Wx  Vx  -   -   EVX_MOVDQA32+k      F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f7f        MR   Wx  Vx  -   -   EVX_MOVDQA64+k      F=AVX512F TUPLE_FULL_MEM
EVEX.F3.W0.0f6f        RM   Vx  Wx  -   -   EVX_MOVDQU32+k      F=AVX512F TUPLE_FULL_MEM
EVEX.F3.W1.0f6f        RM   Vx  Wx  -   -   EVX_MOVDQU64+k      F=AVX512F TUPLE_FULL_MEM
EVEX.F3.W0.0f7f        MR   Wx  Vx  -   -   EVX_MOVDQU32+k      F=AVX512F TUPLE_FULL_MEM
EVEX.F3.W1.0f7f        MR   Wx  Vx  -   -   EVX_MOVDQU64+k      F=AVX512F TUPLE_FULL_MEM
EVEX.F2.W0.0f6f        RM   Vx  Wx  -   -   EVX_MOVDQU8+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.F2.W1.0f6f        RM   Vx  Wx  -   -   EVX_MOVDQU16+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.F2.W0.0f7f        MR   Wx  Vx  -   -   EVX_MOVDQU8+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.F2.W1.0f7f        MR   Wx  Vx  -   -   EVX_MOVDQU16+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.NP.W0.L0.0f12/m   RVM  Vdq Hdq Mq  -   EVX_MOVLPS          F=AVX512F TUPLE2_32
EVEX.NP.W0.L0.0f12/r   RVM  Vdq Hdq Udq -   EVX_MOVHLPS         F=AVX512F
EVEX.66.W1.L0.0f12/m   RVM  Vdq Hdq Msd -   EVX_MOVLPD          F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.L0.0f13/m   MR   Mq  Vq  -   -   EVX_MOVLPS          F=AVX512F TUPLE2_32
EVEX.66.W1.L0.0f13/m   MR   Msd Vsd -   -   EVX_MOVLPD          F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.L0.0f16/m   RVM  Vdq Hq  Mq  -   EVX_MOVHPS          F=AVX512F TUPLE2_32
EVEX.NP.W0.L0.0f16/r   RVM  Vdq Hq  Uq  -   EVX_MOVLHPS         F=AVX512F
EVEX.66.W1.L0.0f16/m   RVM  Vdq Hsd Msd -   EVX_MOVHPD          F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.L0.0f17/m   MR   Mq  Vq  -   -   EVX_MOVHPS          F=AVX512F TUPLE2_32
EVEX.66.W1.L0.0f17/m   MR   Msd Vsd -   -   EVX_MOVHPD          F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f382a/m    RM   Vx  Mx  -   -   EVX_MOVNTDQA        F=AVX512F TUPLE_FULL_MEM
EVEX.66.W0.0fe7/m      MR   Mx  Vx  -   -   EVX_MOVNTDQ         F=AVX512F TUPLE_FULL_MEM
EVEX.NP.W0.0f2b/m      MR   Mps Vps -   -   EVX_MOVNTPS         F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f2b/m      MR   Mpd Vpd -   -   EVX_MOVNTPD         F=AVX512F TUPLE_FULL_MEM
EVEX.F3.W1.L0.0f7e     RM   Vq  Wq  -   -   EVX_MOVQ            F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W1.L0.0fd6     MR   Wq  Vq  -   -   EVX_MOVQ            F=AVX512F TUPLE1_SCALAR_64
EVEX.F3.W0.LIG.0f10/m  RM   Vdq Mss -   -   EVX_MOVSS+k         F=AVX512F TUPLE1_SCALAR_32
EVEX.F3.W0.LIG.0f10/r  RVM  Vdq Hdq Uss -   EVX_MOVSS+k         F=AVX512F
EVEX.F2.W1.LIG.0f10/m  RM   Vdq Msd -   -   EVX_MOVSD+k         F=AVX512F TUPLE1_SCALAR_64
EVEX.F2.W1.LIG.0f10/r  RVM  Vdq Hdq Usd -   EVX_MOVSD+k         F=AVX512F
EVEX.F3.W0.LIG.0f11/m  MR   Mss Vss -   -   EVX_MOVSS+k         F=AVX512F TUPLE1_SCALAR_32
EVEX.F3.W0.LIG.0f11/r  MVR  Udq Hdq Vss -   EVX_MOVSS+k         F=AVX512F
EVEX.F2.W1.LIG.0f11/m  MR   Msd Vsd -   -   EVX_MOVSD+k         F=AVX512F TUPLE1_SCALAR_64
EVEX.F2.W1.LIG.0f11/r  MVR  Udq Hdq Vsd -   EVX_MOVSD+k         F=AVX512F
EVEX.F3.W0.0f12        RM   Vps Wps -   -   EVX_MOVSLDUP+k      F=AVX512F TUPLE_FULL_MEM
EVEX.F3.W0.0f16        RM   Vps Wps -   -   EVX_MOVSHDUP+k      F=AVX512F TUPLE_FULL_MEM
EVEX.NP.W0.0f10        RM   Vps Wps -   -   EVX_MOVUPS+k        F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f10        RM   Vpd Wpd -   -   EVX_MOVUPD+k        F=AVX512F TUPLE_FULL_MEM
EVEX.NP.W0.0f11        MR   Wps Vps -   -   EVX_MOVUPS+k        F=AVX512F TUPLE_FULL_MEM
EVEX.66.W1.0f11        MR   Wpd Vpd -   -   EVX_MOVUPD+k        F=AVX512F TUPLE_FULL_MEM
EVEX.NP.W0.0f59        RVM  Vps Hps Wps -   EVX_MULPS+kbr       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f59        RVM  Vpd Hpd Wpd -   EVX_MULPD+kbr       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f59    RVM  Vdq Hdq Wss -   EVX_MULSS+kr        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f59    RVM  Vdq Hdq Wsd -   EVX_MULSD+kr        F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.0f56        RVM  Vps Hps Wps -   EVX_ORPS+kb         F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f56        RVM  Vpd Hpd Wpd -   EVX_ORPD+kb         F=AVX512DQ TUPLE_FULL_64
EVEX.66.0f381c         RM   Vx  Wx  -   -   EVX_PABSB+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f381d         RM   Vx  Wx  -   -   EVX_PABSW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f381e      RM   Vx  Wx  -   -   EVX_PABSD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f381f      RM   Vx  Wx  -   -   EVX_PABSQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.0f63           RVM  Vx  Hx  Wx  -   EVX_PACKSSWB+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f67           RVM  Vx  Hx  Wx  -   EVX_PACKUSWB+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f6b        RVM  Vx  Hx  Wx  -   EVX_PACKSSDW+kb     F=AVX512BW TUPLE_FULL_32
EVEX.66.W0.0f382b      RVM  Vx  Hx  Wx  -   EVX_PACKUSDW+kb     F=AVX512BW TUPLE_FULL_32
EVEX.66.0ffc           RVM  Vx  Hx  Wx  -   EVX_PADDB+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0ffd           RVM  Vx  Hx  Wx  -   EVX_PADDW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0ffe        RVM  Vx  Hx  Wx  -   EVX_PADDD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0fd4        RVM  Vx  Hx  Wx  -   EVX_PADDQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.0fec           RVM  Vx  Hx  Wx  -   EVX_PADDSB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fed           RVM  Vx  Hx  Wx  -   EVX_PADDSW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fdc           RVM  Vx  Hx  Wx  -   EVX_PADDUSB+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fdd           RVM  Vx  Hx  Wx  -   EVX_PADDUSW+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f3a0f         RVMI Vx  Hx  Wx  Ib  EVX_PALIGNR+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0fdb        RVM  Vx  Hx  Wx  -   EVX_PANDD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0fdb        RVM  Vx  Hx  Wx  -   EVX_PANDQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0fdf        RVM  Vx  Hx  Wx  -   EVX_PANDND+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0fdf        RVM  Vx  Hx  Wx  -   EVX_PANDNQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.0fe0           RVM  Vx  Hx  Wx  -   EVX_PAVGB+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fe3           RVM  Vx  Hx  Wx  -   EVX_PAVGW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f3a44         RVMI Vx  Hx  Wx  Ib  EVX_PCLMULQDQ       F=AVX512F,VPCLMULQDQ TUPLE_FULL_MEM
EVEX.66.0f74           RVM  K   Hx  Wx  -   EVX_PCMPEQB+k       F=AVX512F TUPLE_FULL_MEM
EVEX.66.0f75           RVM  K   Hx  Wx  -   EVX_PCMPEQW+k       F=AVX512F TUPLE_FULL_MEM
EVEX.66.W0.0f76        RVM  K   Hx  Wx  -   EVX_PCMPEQD+kb      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3829      RVM  K   Hx  Wx  -   EVX_PCMPEQQ+kb      F=AVX512F TUPLE_FULL_64
EVEX.66.0f64           RVM  K   Hx  Wx  -   EVX_PCMPGTB+k       F=AVX512F TUPLE_FULL_MEM
EVEX.66.0f65           RVM  K   Hx  Wx  -   EVX_PCMPGTW+k       F=AVX512F TUPLE_FULL_MEM
EVEX.66.W0.0f66        RVM  K   Hx  Wx  -   EVX_PCMPGTD+kb      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3837      RVM  K   Hx  Wx  -   EVX_PCMPGTQ+kb      F=AVX512F TUPLE_FULL_64
EVEX.66.L0.0f3a14/m    MRI  Mb  Vdq Ib  -   EVX_PEXTRB          F=AVX512BW TUPLE1_SCALAR_8
EVEX.66.L0.0f3a14/r    MRI  Rd  Vdq Ib  -   EVX_PEXTRB          F=AVX512BW
EVEX.66.L0.0fc5/r      RMI  Gd  Udq Ib  -   EVX_PEXTRW          F=AVX512BW
EVEX.66.L0.0f3a15/m    MRI  Mw  Vdq Ib  -   EVX_PEXTRW          F=AVX512BW TUPLE1_SCALAR_16
EVEX.66.L0.0f3a15/r    MRI  Rd  Vdq Ib  -   EVX_PEXTRW          F=AVX512BW
EVEX.66.L0.0f3a16      MRI  Ey  Vdq Ib  -   EVX_PEXTR           F=AVX512DQ TUPLE1_SCALAR_OPSZ
EVEX.66.L0.0f3a20      RVMI Vdq Hdq Eb  Ib  EVX_PINSR           F=AVX512BW TUPLE1_SCALAR_8
EVEX.66.L0.0fc4        RVMI Vdq Hdq Ew  Ib  EVX_PINSR           F=AVX512BW TUPLE1_SCALAR_16
EVEX.66.L0.0f3a22      RVMI Vdq Hdq Ey  Ib  EVX_PINSR           F=AVX512DQ TUPLE1_SCALAR_OPSZ
EVEX.66.0f3804         RVM  Vx  Hx  Wx  -   EVX_PMADDUBSW+k     F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0ff5           RVM  Vx  Hx  Wx  -   EVX_PMADDWD+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fda           RVM  Vx  Hx  Wx  -   EVX_PMINUB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fde           RVM  Vx  Hx  Wx  -   EVX_PMAXUB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fea           RVM  Vx  Hx  Wx  -   EVX_PMINSW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fee           RVM  Vx  Hx  Wx  -   EVX_PMAXSW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f3838         RVM  Vx  Hx  Wx  -   EVX_PMINSB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3839      RVM  Vx  Hx  Wx  -   EVX_PMINSD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3839      RVM  Vx  Hx  Wx  -   EVX_PMINSQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.0f383a         RVM  Vx  Hx  Wx  -   EVX_PMINUW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f383b      RVM  Vx  Hx  Wx  -   EVX_PMINUD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f383b      RVM  Vx  Hx  Wx  -   EVX_PMINUQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.0f383c         RVM  Vx  Hx  Wx  -   EVX_PMAXSB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f383d      RVM  Vx  Hx  Wx  -   EVX_PMAXSD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f383d      RVM  Vx  Hx  Wx  -   EVX_PMAXSQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.0f383e         RVM  Vx  Hx  Wx  -   EVX_PMAXUW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f383f      RVM  Vx  Hx  Wx  -   EVX_PMAXUD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f383f      RVM  Vx  Hx  Wx  -   EVX_PMAXUQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.0f3820         RM   Vx  Wh  -   -   EVX_PMOVSXBW+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.0f3821         RM   Vx  Wf  -   -   EVX_PMOVSXBD+k      F=AVX512F TUPLE_QUARTER_MEM
EVEX.66.0f3822         RM   Vx  We  -   -   EVX_PMOVSXBQ+k      F=AVX512F TUPLE_EIGHTH_MEM
EVEX.66.0f3823         RM   Vx  Wh  -   -   EVX_PMOVSXWD+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.0f3824         RM   Vx  Wf  -   -   EVX_PMOVSXWQ+k      F=AVX512F TUPLE_QUARTER_MEM
EVEX.66.W0.0f3825      RM   Vx  Wh  -   -   EVX_PMOVSXDQ+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.0f3830         RM   Vx  Wh  -   -   EVX_PMOVZXBW+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.0f3831         RM   Vx  Wf  -   -   EVX_PMOVZXBD+k      F=AVX512F TUPLE_QUARTER_MEM
EVEX.66.0f3832         RM   Vx  We  -   -   EVX_PMOVZXBQ+k      F=AVX512F TUPLE_EIGHTH_MEM
EVEX.66.0f3833         RM   Vx  Wh  -   -   EVX_PMOVZXWD+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.0f3834         RM   Vx  Wf  -   -   EVX_PMOVZXWQ+k      F=AVX512F TUPLE_QUARTER_MEM
EVEX.66.W0.0f3835      RM   Vx  Wh  -   -   EVX_PMOVZXDQ+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.W1.0f3828      RVM  Vx  Hx  Wx  -   EVX_PMULDQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.0f380b         RVM  Vx  Hx  Wx  -   EVX_PMULHRSW+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fe4           RVM  Vx  Hx  Wx  -   EVX_PMULHUW+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fe5           RVM  Vx  Hx  Wx  -   EVX_PMULHW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fd5           RVM  Vx  Hx  Wx  -   EVX_PMULLW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3840      RVM  Vx  Hx  Wx  -   EVX_PMULLD+kb       F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f3840      RVM  Vx  Hx  Wx  -   EVX_PMULLQ+kb       F=AVX512DQ TUPLE_FULL_64
EVEX.66.W1.0ff4        RVM  Vx  Hx  Wx  -   EVX_PMULUDQ+kb      F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0feb        RVM  Vx  Hx  Wx  -   EVX_PORD+kb         F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0feb        RVM  Vx  Hx  Wx  -   EVX_PORQ+kb         F=AVX512F TUPLE_FULL_64
EVEX.66.0ff6           RVM  Vx  Hx  Wx  -   EVX_PSADBW          F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f3800         RVM  Vx  Hx  Wx  -   EVX_PSHUFB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f70        RMI  Vx  Wx  Ib  -   EVX_PSHUFD+kb       F=AVX512F TUPLE_FULL_32
EVEX.F3.0f70           RMI  Vx  Wx  Ib  -   EVX_PSHUFHW+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.F2.0f70           RMI  Vx  Wx  Ib  -   EVX_PSHUFLW+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f71/2         VMI  Hx  Wx  Ib  -   EVX_PSRLW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f71/4         VMI  Hx  Wx  Ib  -   EVX_PSRAW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f71/6         VMI  Hx  Wx  Ib  -   EVX_PSLLW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f72/2      VMI  Hx  Wx  Ib  -   EVX_PSRLD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W0.0f72/4      VMI  Hx  Wx  Ib  -   EVX_PSRAD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W0.0f72/6      VMI  Hx  Wx  Ib  -   EVX_PSLLD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f73/2      VMI  Hx  Wx  Ib  -   EVX_PSRLQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W1.0f72/4      VMI  Hx  Wx  Ib  -   EVX_PSRAQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W1.0f73/6      VMI  Hx  Wx  Ib  -   EVX_PSLLQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.0fd1           RVM  Vx  Hx  Wdq -   EVX_PSRLW+k         F=AVX512BW TUPLE_MEM128
EVEX.66.W0.0fd2        RVM  Vx  Hx  Wdq -   EVX_PSRLD+k         F=AVX512F TUPLE_MEM128
EVEX.66.W1.0fd3        RVM  Vx  Hx  Wdq -   EVX_PSRLQ+k         F=AVX512F TUPLE_MEM128
EVEX.66.0fe1           RVM  Vx  Hx  Wdq -   EVX_PSRAW+k         F=AVX512BW TUPLE_MEM128
EVEX.66.W0.0fe2        RVM  Vx  Hx  Wdq -   EVX_PSRAD+k         F=AVX512F TUPLE_MEM128
EVEX.66.W1.0fe2        RVM  Vx  Hx  Wdq -   EVX_PSRAQ+k         F=AVX512F TUPLE_MEM128
EVEX.66.0ff1           RVM  Vx  Hx  Wdq -   EVX_PSLLW+k         F=AVX512BW TUPLE_MEM128
EVEX.66.W0.0ff2        RVM  Vx  Hx  Wdq -   EVX_PSLLD+k         F=AVX512F TUPLE_MEM128
EVEX.66.W1.0ff3        RVM  Vx  Hx  Wdq -   EVX_PSLLQ+k         F=AVX512F TUPLE_MEM128
EVEX.66.0f73/3         VMI  Hx  Wx  Ib  -   EVX_PSRLDQ          F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f73/7         VMI  Hx  Wx  Ib  -   EVX_PSLLDQ          F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0ff8           RVM  Vx  Hx  Wx  -   EVX_PSUBB+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0ff9           RVM  Vx  Hx  Wx  -   EVX_PSUBW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0ffa        RVM  Vx  Hx  Wx  -   EVX_PSUBD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0ffb        RVM  Vx  Hx  Wx  -   EVX_PSUBQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.0fe8           RVM  Vx  Hx  Wx  -   EVX_PSUBSB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fe9           RVM  Vx  Hx  Wx  -   EVX_PSUBSW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fd8           RVM  Vx  Hx  Wx  -   EVX_PSUBUSB+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0fd9           RVM  Vx  Hx  Wx  -   EVX_PSUBUSW+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f60           RVM  Vx  Hx  Wx  -   EVX_PUNPCKLBW+k     F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f61           RVM  Vx  Hx  Wx  -   EVX_PUNPCKLWD+k     F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f62        RVM  Vx  Hx  Wx  -   EVX_PUNPCKLDQ+kb    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f6c        RVM  Vx  Hx  Wx  -   EVX_PUNPCKLQDQ+kb   F=AVX512F TUPLE_FULL_64
EVEX.66.0f68           RVM  Vx  Hx  Wx  -   EVX_PUNPCKHBW+k     F=AVX512BW TUPLE_FULL_MEM
EVEX.66.0f69           RVM  Vx  Hx  Wx  -   EVX_PUNPCKHWD+k     F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f6a        RVM  Vx  Hx  Wx  -   EVX_PUNPCKHDQ+kb    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f6d        RVM  Vx  Hx  Wx  -   EVX_PUNPCKHQDQ+kb   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0fef        RVM  Vx  Hx  Wx  -   EVX_PXORD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0fef        RVM  Vx  Hx  Wx  -   EVX_PXORQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.NP.W0.0fc6        RVMI Vx  Hx  Wx  Ib  EVX_SHUFPS+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0fc6        RVMI Vx  Hx  Wx  Ib  EVX_SHUFPD+kb       F=AVX512F TUPLE_FULL_64
EVEX.NP.W0.0f51        RM   Vps Wps -   -   EVX_SQRTPS+kbr      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f51        RM   Vpd Wpd -   -   EVX_SQRTPD+kbr      F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f51    RVM  Vdq Hdq Wss -   EVX_SQRTSS+kr       F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f51    RVM  Vdq Hdq Wsd -   EVX_SQRTSD+kr       F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.0f5c        RVM  Vps Hps Wps -   EVX_SUBPS+kbr       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f5c        RVM  Vpd Hpd Wpd -   EVX_SUBPD+kbr       F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.LIG.0f5c    RVM  Vdq Hdq Wss -   EVX_SUBSS+kr        F=AVX512F TUPLE1_SCALAR_32
EVEX.F2.W1.LIG.0f5c    RVM  Vdq Hdq Wsd -   EVX_SUBSD+kr        F=AVX512F TUPLE1_SCALAR_64
EVEX.NP.W0.LIG.0f2e    RM   Vss Wss -   -   EVX_UCOMISS+e       F=AVX512F TUPLE1_SCALAR_32 EFL=0--0m0mm
EVEX.66.W1.LIG.0f2e    RM   Vsd Wsd -   -   EVX_UCOMISD+e       F=AVX512F TUPLE1_SCALAR_64 EFL=0--0m0mm
EVEX.NP.W0.0f14        RVM  Vps Hps Wps -   EVX_UNPCKLPS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f14        RVM  Vpd Hpd Wpd -   EVX_UNPCKLPD+kb     F=AVX512F TUPLE_FULL_64
EVEX.NP.W0.0f15        RVM  Vps Hps Wps -   EVX_UNPCKHPS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f15        RVM  Vpd Hpd Wpd -   EVX_UNPCKHPD+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3a03      RVMI Vx  Hx  Wx  Ib  EVX_ALIGND+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a03      RVMI Vx  Hx  Wx  Ib  EVX_ALIGNQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3865      RVM  Vx  Hx  Wx  -   EVX_BLENDMPS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3865      RVM  Vx  Hx  Wx  -   EVX_BLENDMPD+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3818      RM   Vx  Wd  -   -   EVX_BROADCASTSS+k   F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W0.L12.0f3819  RM   Vx  Wq  -   -   EVX_BROADCASTF32X2+k F=AVX512DQ TUPLE2_32
EVEX.66.W1.L12.0f3819  RM   Vx  Wq  -   -   EVX_BROADCASTSD+k   F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.L12.0f381a/m RM   Vx  Mdq -   -   EVX_BROADCASTF32X4+k F=AVX512F TUPLE4_32
EVEX.66.W1.L12.0f381a/m RM   Vx  Mdq -   -   EVX_BROADCASTF64X2+k F=AVX512DQ TUPLE2_64
EVEX.66.W0.L2.0f381b/m RM   Vx  Mqq -   -   EVX_BROADCASTF32X8+k F=AVX512DQ TUPLE8_32
EVEX.66.W1.L2.0f381b/m RM   Vx  Mqq -   -   EVX_BROADCASTF64X4+k F=AVX512F TUPLE4_64
# Note tuple type, scale is not memory size but element size
EVEX.66.W0.0f388a/m    MR   Md  Vx  -   -   EVX_COMPRESSPS+k    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W0.0f388a/r    MR   Ux  Vx  -   -   EVX_COMPRESSPS+k    F=AVX512F
EVEX.66.W1.0f388a/m    MR   Mq  Vx  -   -   EVX_COMPRESSPD+k    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W1.0f388a/r    MR   Ux  Vx  -   -   EVX_COMPRESSPD+k    F=AVX512F
EVEX.F2.W0.0f3872      RVM  Vx  Hx  Wx  -   EVX_CVTNE2PS2BF16+kb F=AVX512_BF16 TUPLE_FULL_32
EVEX.F3.W0.0f3872      RM   Vh  Wx  -   -   EVX_CVTNEPS2BF16+kb F=AVX512_BF16 TUPLE_FULL_32
EVEX.66.W0.0f7b        RM   Vx  Wh  -   -   EVX_CVTPS2QQ+kbr    F=AVX512DQ TUPLE_HALF_32
EVEX.66.W1.0f7b        RM   Vx  Wx  -   -   EVX_CVTPD2QQ+kbr    F=AVX512DQ TUPLE_FULL_64
EVEX.NP.W0.0f79        RM   Vx  Wx  -   -   EVX_CVTPS2UDQ+kbr   F=AVX512F TUPLE_FULL_32
EVEX.NP.W1.0f79        RM   Vh  Wx  -   -   EVX_CVTPD2UDQ+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f79        RM   Vx  Wh  -   -   EVX_CVTPS2UQQ+kbr   F=AVX512F TUPLE_HALF_32
EVEX.66.W1.0f79        RM   Vx  Wx  -   -   EVX_CVTPD2UQQ+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3813      RM   Vx  Wh  -   -   EVX_CVTPH2PS+ke     F=AVX512F TUPLE_HALF_MEM
EVEX.66.W0.0f3a1d      MRI  Wh  Vx  Ib  -   EVX_CVTPS2PH+ke     F=AVX512F TUPLE_HALF_MEM
EVEX.F3.W1.0fe6        RM   Vx  Wx  -   -   EVX_CVTQQ2PD+kbr    F=AVX512DQ TUPLE_FULL_64
EVEX.NP.W1.0f5b        RM   Vh  Wx  -   -   EVX_CVTQQ2PS+kbr    F=AVX512DQ TUPLE_FULL_64
EVEX.F2.LIG.0f79       RM   Gy  Wsd -   -   EVX_CVTSD2USI+r     F=AVX512F TUPLE1_FIXED_64
EVEX.F3.LIG.0f79       RM   Gy  Wss -   -   EVX_CVTSS2USI+r     F=AVX512F TUPLE1_FIXED_32
# Note: for W0, ER is ignored (i.e., will not UD, according to Intel SDM)
EVEX.F2.LIG.0f7b       RVM  Vdq Hdq Ey  -   EVX_CVTUSI2SD+r     F=AVX512F TUPLE1_SCALAR_OPSZ
EVEX.F3.LIG.0f7b       RVM  Vdq Hdq Ey  -   EVX_CVTUSI2SS+r     F=AVX512F TUPLE1_SCALAR_OPSZ
EVEX.66.W0.0f7a        RM   Vx  Wh  -   -   EVX_CVTTPS2QQ+kbe   F=AVX512DQ TUPLE_HALF_32
EVEX.66.W1.0f7a        RM   Vx  Wx  -   -   EVX_CVTTPD2QQ+kbe   F=AVX512DQ TUPLE_FULL_64
EVEX.NP.W0.0f78        RM   Vx  Wx  -   -   EVX_CVTTPS2UDQ+kbe  F=AVX512F TUPLE_FULL_32
EVEX.NP.W1.0f78        RM   Vh  Wx  -   -   EVX_CVTTPD2UDQ+kbe  F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f78        RM   Vx  Wh  -   -   EVX_CVTTPS2UQQ+kbe  F=AVX512F TUPLE_HALF_32
EVEX.66.W1.0f78        RM   Vx  Wx  -   -   EVX_CVTTPD2UQQ+kbe  F=AVX512F TUPLE_FULL_64
EVEX.F2.LIG.0f78       RM   Gy  Wsd -   -   EVX_CVTTSD2USI+e    F=AVX512F TUPLE1_FIXED_64
EVEX.F3.LIG.0f78       RM   Gy  Wss -   -   EVX_CVTTSS2USI+e    F=AVX512F TUPLE1_FIXED_32
# Note: SAE is ignored.
EVEX.F3.W0.0f7a        RM   Vx  Wh  -   -   EVX_CVTUDQ2PD+kbe   F=AVX512F TUPLE_HALF_32
EVEX.F2.W0.0f7a        RM   Vx  Wx  -   -   EVX_CVTUDQ2PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.F3.W1.0f7a        RM   Vx  Wx  -   -   EVX_CVTUQQ2PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.F2.W1.0f7a        RM   Vh  Wx  -   -   EVX_CVTUQQ2PS+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3a42      RVMI Vx  Hx  Wx  Ib  EVX_DBPSADBW+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.F3.W0.0f3852      RVM  Vx  Hx  Wx  -   EVX_DPBF16PS+kb     F=AVX512_BF16 TUPLE_FULL_32
# Note tuple type, scale is not memory size but element size
EVEX.66.W0.0f3888/m    RM   Vx  Md  -   -   EVX_EXPANDPS+k      F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W0.0f3888/r    RM   Vx  Ux  -   -   EVX_EXPANDPS+k      F=AVX512F
EVEX.66.W1.0f3888/m    RM   Vx  Mq  -   -   EVX_EXPANDPD+k      F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W1.0f3888/r    RM   Vx  Ux  -   -   EVX_EXPANDPD+k      F=AVX512F
EVEX.66.W0.L12.0f3a19  MRI  Wdq Vx  Ib  -   EVX_EXTRACTF32X4+k  F=AVX512F TUPLE4_32
EVEX.66.W1.L12.0f3a19  MRI  Wdq Vx  Ib  -   EVX_EXTRACTF64X2+k  F=AVX512F TUPLE2_64
EVEX.66.W0.L2.0f3a1b   MRI  Wqq Vx  Ib  -   EVX_EXTRACTF32X8+k  F=AVX512F TUPLE8_32
EVEX.66.W1.L2.0f3a1b   MRI  Wqq Vx  Ib  -   EVX_EXTRACTF64X4+k  F=AVX512F TUPLE4_64
EVEX.66.W0.L12.0f3a39  MRI  Wdq Vx  Ib  -   EVX_EXTRACTI32X4+k  F=AVX512F TUPLE4_32
EVEX.66.W1.L12.0f3a39  MRI  Wdq Vx  Ib  -   EVX_EXTRACTI64X2+k  F=AVX512F TUPLE2_64
EVEX.66.W0.L2.0f3a3b   MRI  Wqq Vx  Ib  -   EVX_EXTRACTI32X8+k  F=AVX512F TUPLE8_32
EVEX.66.W1.L2.0f3a3b   MRI  Wqq Vx  Ib  -   EVX_EXTRACTI64X4+k  F=AVX512F TUPLE4_64
EVEX.66.W0.0f3a54      RVMI Vps Hps Wps Ib  EVX_FIXUPIMMPS+kbe  F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a54      RVMI Vpd Hpd Wpd Ib  EVX_FIXUPIMMPD+kbe  F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f3a55  RVMI Vdq Hdq Wss Ib  EVX_FIXUPIMMSS+ke   F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3a55  RVMI Vdq Hdq Wsd Ib  EVX_FIXUPIMMSD+ke   F=AVX512F TUPLE1_SCALAR_64
# TODO: verify these, this is just copied from AVX/FMA.
EVEX.66.W0.0f3896      RVM  Vx  Hx  Wx  -   EVX_FMADDSUB132PS+kbr F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3896      RVM  Vx  Hx  Wx  -   EVX_FMADDSUB132PD+kbr F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3897      RVM  Vx  Hx  Wx  -   EVX_FMSUBADD132PS+kbr F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3897      RVM  Vx  Hx  Wx  -   EVX_FMSUBADD132PD+kbr F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3898      RVM  Vx  Hx  Wx  -   EVX_FMADD132PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3898      RVM  Vx  Hx  Wx  -   EVX_FMADD132PD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f3899  RVM  Vdq Hdq Wss -   EVX_FMADD132SS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3899  RVM  Vdq Hdq Wsd -   EVX_FMADD132SD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f389a      RVM  Vx  Hx  Wx  -   EVX_FMSUB132PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f389a      RVM  Vx  Hx  Wx  -   EVX_FMSUB132PD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f389b  RVM  Vdq Hdq Wss -   EVX_FMSUB132SS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f389b  RVM  Vdq Hdq Wsd -   EVX_FMSUB132SD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f389c      RVM  Vx  Hx  Wx  -   EVX_FNMADD132PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f389c      RVM  Vx  Hx  Wx  -   EVX_FNMADD132PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f389d  RVM  Vdq Hdq Wss -   EVX_FNMADD132SS+kr    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f389d  RVM  Vdq Hdq Wsd -   EVX_FNMADD132SD+kr    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f389e      RVM  Vx  Hx  Wx  -   EVX_FNMSUB132PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f389e      RVM  Vx  Hx  Wx  -   EVX_FNMSUB132PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f389f  RVM  Vdq Hdq Wss -   EVX_FNMSUB132SS+kr    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f389f  RVM  Vdq Hdq Wsd -   EVX_FNMSUB132SD+kr    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38a6      RVM  Vx  Hx  Wx  -   EVX_FMADDSUB213PS+kbr F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38a6      RVM  Vx  Hx  Wx  -   EVX_FMADDSUB213PD+kbr F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f38a7      RVM  Vx  Hx  Wx  -   EVX_FMSUBADD213PS+kbr F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38a7      RVM  Vx  Hx  Wx  -   EVX_FMSUBADD213PD+kbr F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f38a8      RVM  Vx  Hx  Wx  -   EVX_FMADD213PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38a8      RVM  Vx  Hx  Wx  -   EVX_FMADD213PD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38a9  RVM  Vdq Hdq Wss -   EVX_FMADD213SS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38a9  RVM  Vdq Hdq Wsd -   EVX_FMADD213SD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38aa      RVM  Vx  Hx  Wx  -   EVX_FMSUB213PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38aa      RVM  Vx  Hx  Wx  -   EVX_FMSUB213PD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38ab  RVM  Vdq Hdq Wss -   EVX_FMSUB213SS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38ab  RVM  Vdq Hdq Wsd -   EVX_FMSUB213SD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38ac      RVM  Vx  Hx  Wx  -   EVX_FNMADD213PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38ac      RVM  Vx  Hx  Wx  -   EVX_FNMADD213PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38ad  RVM  Vdq Hdq Wss -   EVX_FNMADD213SS+kr    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38ad  RVM  Vdq Hdq Wsd -   EVX_FNMADD213SD+kr    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38ae      RVM  Vx  Hx  Wx  -   EVX_FNMSUB213PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38ae      RVM  Vx  Hx  Wx  -   EVX_FNMSUB213PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38af  RVM  Vdq Hdq Wss -   EVX_FNMSUB213SS+kr    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38af  RVM  Vdq Hdq Wsd -   EVX_FNMSUB213SD+kr    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38b6      RVM  Vx  Hx  Wx  -   EVX_FMADDSUB231PS+kbr F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38b6      RVM  Vx  Hx  Wx  -   EVX_FMADDSUB231PD+kbr F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f38b7      RVM  Vx  Hx  Wx  -   EVX_FMSUBADD231PS+kbr F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38b7      RVM  Vx  Hx  Wx  -   EVX_FMSUBADD231PD+kbr F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f38b8      RVM  Vx  Hx  Wx  -   EVX_FMADD231PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38b8      RVM  Vx  Hx  Wx  -   EVX_FMADD231PD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38b9  RVM  Vdq Hdq Wss -   EVX_FMADD231SS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38b9  RVM  Vdq Hdq Wsd -   EVX_FMADD231SD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38ba      RVM  Vx  Hx  Wx  -   EVX_FMSUB231PS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38ba      RVM  Vx  Hx  Wx  -   EVX_FMSUB231PD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38bb  RVM  Vdq Hdq Wss -   EVX_FMSUB231SS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38bb  RVM  Vdq Hdq Wsd -   EVX_FMSUB231SD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38bc      RVM  Vx  Hx  Wx  -   EVX_FNMADD231PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38bc      RVM  Vx  Hx  Wx  -   EVX_FNMADD231PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38bd  RVM  Vdq Hdq Wss -   EVX_FNMADD231SS+kr    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38bd  RVM  Vdq Hdq Wsd -   EVX_FNMADD231SD+kr    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38be      RVM  Vx  Hx  Wx  -   EVX_FNMSUB231PS+kbr   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f38be      RVM  Vx  Hx  Wx  -   EVX_FNMSUB231PD+kbr   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f38bf  RVM  Vdq Hdq Wss -   EVX_FNMSUB231SS+kr    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f38bf  RVM  Vdq Hdq Wsd -   EVX_FNMSUB231SD+kr    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f3a66      RMI  Kb  Wps Ib  -   EVX_FPCLASSPS+kb    F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f3a66      RMI  Kb  Wpd Ib  -   EVX_FPCLASSPD+kb    F=AVX512DQ TUPLE_FULL_64
EVEX.66.W0.LIG.0f3a67  RMI  Kb  Wss Ib  -   EVX_FPCLASSSS+k     F=AVX512DQ TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3a67  RMI  Kb  Wsd Ib  -   EVX_FPCLASSSD+k     F=AVX512DQ TUPLE1_SCALAR_64
EVEX.66.W0.0f3892/m    RM   Vx  Md  -   -   EVX_GATHERDPS+k     F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f3892/m    RM   Vx  Mq  -   -   EVX_GATHERDPD+k     F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.0f3893/m    RM   Vh  Md  -   -   EVX_GATHERQPS+k     F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f3893/m    RM   Vx  Mq  -   -   EVX_GATHERQPD+k     F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.0f3842      RM   Vps Wps -   -   EVX_GETEXPPS+kbe    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3842      RM   Vpd Wpd -   -   EVX_GETEXPPD+kbe    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f3843  RVM  Vdq Hdq Wss -   EVX_GETEXPSS+ke     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3843  RVM  Vdq Hdq Wsd -   EVX_GETEXPSD+ke     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f3a26      RMI  Vps Wps Ib  -   EVX_GETMANTPS+kbe   F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a26      RMI  Vpd Wpd Ib  -   EVX_GETMANTPD+kbe   F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f3a27  RVMI Vdq Hdq Wss Ib  EVX_GETMANTSS+ke    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3a27  RVMI Vdq Hdq Wsd Ib  EVX_GETMANTSD+ke    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.L12.0f3a18  RVMI Vx  Hx  Wdq Ib  EVX_INSERTF32X4+k   F=AVX512F TUPLE4_32
EVEX.66.W1.L12.0f3a18  RVMI Vx  Hx  Wdq Ib  EVX_INSERTF64X2+k   F=AVX512DQ TUPLE2_64
EVEX.66.W0.L2.0f3a1a   RVMI Vx  Hx  Wqq Ib  EVX_INSERTF32X8+k   F=AVX512DQ TUPLE8_32
EVEX.66.W1.L2.0f3a1a   RVMI Vx  Hx  Wqq Ib  EVX_INSERTF64X4+k   F=AVX512F TUPLE4_64
EVEX.66.W0.L12.0f3a38  RVMI Vx  Hx  Wdq Ib  EVX_INSERTI32X4+k   F=AVX512F TUPLE4_32
EVEX.66.W1.L12.0f3a38  RVMI Vx  Hx  Wdq Ib  EVX_INSERTI64X2+k   F=AVX512DQ TUPLE2_64
EVEX.66.W0.L2.0f3a3a   RVMI Vx  Hx  Wqq Ib  EVX_INSERTI32X8+k   F=AVX512DQ TUPLE8_32
EVEX.66.W1.L2.0f3a3a   RVMI Vx  Hx  Wqq Ib  EVX_INSERTI64X4+k   F=AVX512F TUPLE4_64
EVEX.F2.W0.0f3868      RVM  K   Hx  Wx  -   EVX_P2INTERSECTD+b  F=AVX512_VP2INTERSECT TUPLE_FULL_32
EVEX.F2.W1.0f3868      RVM  K   Hx  Wx  -   EVX_P2INTERSECTQ+b  F=AVX512_VP2INTERSECT TUPLE_FULL_64
EVEX.66.W0.0f3866      RVM  Vx  Hx  Wx  -   EVX_PBLENDMB+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W1.0f3866      RVM  Vx  Hx  Wx  -   EVX_PBLENDMW+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3864      RVM  Vx  Hx  Wx  -   EVX_PBLENDMD+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3864      RVM  Vx  Hx  Wx  -   EVX_PBLENDMQ+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f387a/r    RM   Vx  Rb  -   -   EVX_PBROADCAST+k    F=AVX512BW
EVEX.66.W0.0f387b/r    RM   Vx  Rw  -   -   EVX_PBROADCAST+k    F=AVX512BW
EVEX.66.W0.0f387c/r    RM   Vx  Rd  -   -   EVX_PBROADCAST+k    F=AVX512F
EVEX.66.W1.0f387c/r    RM   Vx  Rd  -   -   EVX_PBROADCAST+k I64 F=AVX512F
EVEX.66.W1.0f387c/r    RM   Vx  Rq  -   -   EVX_PBROADCAST+k O64 F=AVX512F
EVEX.66.W0.0f3878      RM   Vx  Wb  -   -   EVX_PBROADCASTB+k   F=AVX512BW TUPLE1_SCALAR_8
EVEX.66.W0.0f3879      RM   Vx  Ww  -   -   EVX_PBROADCASTW+k   F=AVX512BW TUPLE1_SCALAR_16
EVEX.66.W0.0f3858      RM   Vx  Wd  -   -   EVX_PBROADCASTD+k   F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.0f3859      RM   Vx  Wq  -   -   EVX_PBROADCASTQ+k   F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f3859      RM   Vx  Wq  -   -   EVX_BROADCASTI32X2+k F=AVX512DQ TUPLE2_32
EVEX.66.W0.L12.0f385a/m RM   Vx  Mdq -   -   EVX_BROADCASTI32X4+k F=AVX512DQ TUPLE4_32
EVEX.66.W1.L12.0f385a/m RM   Vx  Mdq -   -   EVX_BROADCASTI64X2+k F=AVX512DQ TUPLE2_64
EVEX.66.W0.L2.0f385b/m RM   Vx  Mqq -   -   EVX_BROADCASTI32X8+k F=AVX512DQ TUPLE8_32
EVEX.66.W1.L2.0f385b/m RM   Vx  Mqq -   -   EVX_BROADCASTI64X4+k F=AVX512F TUPLE4_64
EVEX.F3.W1.0f382a/r    RM   Vx  K   -   -   EVX_PBROADCASTMB2Q  F=AVX512CD
EVEX.F3.W0.0f383a/r    RM   Vx  K   -   -   EVX_PBROADCASTMW2D  F=AVX512CD
EVEX.66.W0.0f3a1e      RVMI K   Hx  Wx  Ib  EVX_PCMPUD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W0.0f3a1f      RVMI K   Hx  Wx  Ib  EVX_PCMPD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a1e      RVMI K   Hx  Wx  Ib  EVX_PCMPUQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W1.0f3a1f      RVMI K   Hx  Wx  Ib  EVX_PCMPQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3a3e      RVMI K   Hx  Wx  Ib  EVX_PCMPUB+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3a3f      RVMI K   Hx  Wx  Ib  EVX_PCMPB+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W1.0f3a3e      RVMI K   Hx  Wx  Ib  EVX_PCMPUW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W1.0f3a3f      RVMI K   Hx  Wx  Ib  EVX_PCMPW+k         F=AVX512BW TUPLE_FULL_MEM
# Note tuple type, scale is not memory size but element size
EVEX.66.W0.0f3863/m    MR   Mb  Vx  -   -   EVX_PCOMPRESSB+k    F=AVX512_VBMI2 TUPLE1_SCALAR_8
EVEX.66.W0.0f3863/r    MR   Ux  Vx  -   -   EVX_PCOMPRESSB+k    F=AVX512_VBMI2
EVEX.66.W1.0f3863/m    MR   Mw  Vx  -   -   EVX_PCOMPRESSW+k    F=AVX512_VBMI2 TUPLE1_SCALAR_16
EVEX.66.W1.0f3863/r    MR   Ux  Vx  -   -   EVX_PCOMPRESSW+k    F=AVX512_VBMI2
EVEX.66.W0.0f388b/m    MR   Md  Vx  -   -   EVX_PCOMPRESSD+k    F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W0.0f388b/r    MR   Ux  Vx  -   -   EVX_PCOMPRESSD+k    F=AVX512F
EVEX.66.W1.0f388b/m    MR   Mq  Vx  -   -   EVX_PCOMPRESSQ+k    F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W1.0f388b/r    MR   Ux  Vx  -   -   EVX_PCOMPRESSQ+k    F=AVX512F
EVEX.66.W0.0f38c4      RM   Vx  Wx  -   -   EVX_PCONFLICTD+kb   F=AVX512CD TUPLE_FULL_32
EVEX.66.W1.0f38c4      RM   Vx  Wx  -   -   EVX_PCONFLICTQ+kb   F=AVX512CD TUPLE_FULL_64
EVEX.66.W0.0f3850      RVM  Vx  Hx  Wx  -   EVX_PDPBUSD+kb      F=AVX512_VNNI TUPLE_FULL_32
EVEX.66.W0.0f3851      RVM  Vx  Hx  Wx  -   EVX_PDPBUSDS+kb     F=AVX512_VNNI TUPLE_FULL_32
EVEX.66.W0.0f3852      RVM  Vx  Hx  Wx  -   EVX_PDPWSSD+kb      F=AVX512_VNNI TUPLE_FULL_32
EVEX.66.W0.0f3853      RVM  Vx  Hx  Wx  -   EVX_PDPWSSDS+kb     F=AVX512_VNNI TUPLE_FULL_32
EVEX.66.W0.0f388d      RVM  Vx  Hx  Wx  -   EVX_PERMB+k         F=AVX512_VBMI TUPLE_FULL_MEM
EVEX.66.W1.0f388d      RVM  Vx  Hx  Wx  -   EVX_PERMW+k         F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.L12.0f3836  RVM  Vx  Hx  Wx  -   EVX_PERMD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W0.0f3875      RVM  Vx  Hx  Wx  -   EVX_PERMI2B+k       F=AVX512_VBMI TUPLE_FULL_MEM
EVEX.66.W1.0f3875      RVM  Vx  Hx  Wx  -   EVX_PERMI2W+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3876      RVM  Vx  Hx  Wx  -   EVX_PERMI2D+kb      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3876      RVM  Vx  Hx  Wx  -   EVX_PERMI2Q+kb      F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3877      RVM  Vx  Hx  Wx  -   EVX_PERMI2PS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3877      RVM  Vx  Hx  Wx  -   EVX_PERMI2PD+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f380c      RVM  Vx  Hx  Wx  -   EVX_PERMILPS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f380d      RVM  Vx  Hx  Wx  -   EVX_PERMILPD+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3a04      RMI  Vx  Wx  Ib  -   EVX_PERMILPS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a05      RMI  Vx  Wx  Ib  -   EVX_PERMILPD+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.L12.0f3816  RVM  Vx  Hx  Wx  -   EVX_PERMPS+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.L12.0f3816  RVM  Vx  Hx  Wx  -   EVX_PERMPD+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W1.L12.0f3836  RVM  Vx  Hx  Wx  -   EVX_PERMQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W1.L12.0f3a00  RMI  Vx  Wx  Ib  -   EVX_PERMQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W1.L12.0f3a01  RMI  Vx  Wx  Ib  -   EVX_PERMPD+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f387d      RVM  Vx  Hx  Wx  -   EVX_PERMT2B+k       F=AVX512_VBMI TUPLE_FULL_MEM
EVEX.66.W1.0f387d      RVM  Vx  Hx  Wx  -   EVX_PERMT2W+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f387e      RVM  Vx  Hx  Wx  -   EVX_PERMT2D+kb      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f387e      RVM  Vx  Hx  Wx  -   EVX_PERMT2Q+kb      F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f387f      RVM  Vx  Hx  Wx  -   EVX_PERMT2PS+kb     F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f387f      RVM  Vx  Hx  Wx  -   EVX_PERMT2PD+kb     F=AVX512F TUPLE_FULL_64
# Note tuple type, scale is not memory size but element size
EVEX.66.W0.0f3862/m    RM   Vx  Mb  -   -   EVX_PEXPANDB+k      F=AVX512_VBMI2 TUPLE1_SCALAR_8
EVEX.66.W0.0f3862/r    RM   Vx  Ux  -   -   EVX_PEXPANDB+k      F=AVX512_VBMI2
EVEX.66.W1.0f3862/m    RM   Vx  Mw  -   -   EVX_PEXPANDW+k      F=AVX512_VBMI2 TUPLE1_SCALAR_16
EVEX.66.W1.0f3862/r    RM   Vx  Ux  -   -   EVX_PEXPANDW+k      F=AVX512_VBMI2
EVEX.66.W0.0f3889/m    RM   Vx  Md  -   -   EVX_PEXPANDD+k      F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W0.0f3889/r    RM   Vx  Ux  -   -   EVX_PEXPANDD+k      F=AVX512F
EVEX.66.W1.0f3889/m    RM   Vx  Mq  -   -   EVX_PEXPANDQ+k      F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W1.0f3889/r    RM   Vx  Ux  -   -   EVX_PEXPANDQ+k      F=AVX512F
EVEX.66.W0.0f3890/m    RM   Vx  Md  -   -   EVX_PGATHERDD+k     F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f3890/m    RM   Vx  Mq  -   -   EVX_PGATHERDQ+k     F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.0f3891/m    RM   Vh  Md  -   -   EVX_PGATHERQD+k     F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f3891/m    RM   Vx  Mq  -   -   EVX_PGATHERQQ+k     F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.0f3844      RM   Vx  Wx  -   -   EVX_PLZCNTD+kb      F=AVX512CD TUPLE_FULL_32
EVEX.66.W1.0f3844      RM   Vx  Wx  -   -   EVX_PLZCNTQ+kb      F=AVX512CD TUPLE_FULL_64
EVEX.66.W1.0f38b4      RVM  Vx  Hx  Wx  -   EVX_PMADD52LUQ+kb   F=AVX512_IFMA TUPLE_FULL_64
EVEX.66.W1.0f38b5      RVM  Vx  Hx  Wx  -   EVX_PMADD52HUQ+kb   F=AVX512_IFMA TUPLE_FULL_64
EVEX.F3.W0.0f3829/r    RM   K   Ux  -   -   EVX_PMOVB2M         F=AVX512BW
EVEX.F3.W1.0f3829/r    RM   K   Ux  -   -   EVX_PMOVW2M         F=AVX512BW
EVEX.F3.W0.0f3839/r    RM   K   Ux  -   -   EVX_PMOVD2M         F=AVX512DQ
EVEX.F3.W1.0f3839/r    RM   K   Ux  -   -   EVX_PMOVQ2M         F=AVX512DQ
EVEX.F3.W0.0f3828/r    RM   Vx  K   -   -   EVX_PMOVM2B         F=AVX512BW
EVEX.F3.W1.0f3828/r    RM   Vx  K   -   -   EVX_PMOVM2W         F=AVX512BW
EVEX.F3.W0.0f3838/r    RM   Vx  K   -   -   EVX_PMOVM2D         F=AVX512DQ
EVEX.F3.W1.0f3838/r    RM   Vx  K   -   -   EVX_PMOVM2Q         F=AVX512DQ
EVEX.F3.W0.0f3830      MR   Wh  Vx  -   -   EVX_PMOVWB+k        F=AVX512BW TUPLE_HALF_MEM
EVEX.F3.W0.0f3820      MR   Wh  Vx  -   -   EVX_PMOVSWB+k       F=AVX512BW TUPLE_HALF_MEM
EVEX.F3.W0.0f3810      MR   Wh  Vx  -   -   EVX_PMOVUSWB+k      F=AVX512BW TUPLE_HALF_MEM
EVEX.F3.W0.0f3831      MR   Wf  Vx  -   -   EVX_PMOVDB+k        F=AVX512F TUPLE_QUARTER_MEM
EVEX.F3.W0.0f3821      MR   Wf  Vx  -   -   EVX_PMOVSDB+k       F=AVX512F TUPLE_QUARTER_MEM
EVEX.F3.W0.0f3811      MR   Wf  Vx  -   -   EVX_PMOVUSDB+k      F=AVX512F TUPLE_QUARTER_MEM
EVEX.F3.W0.0f3832      MR   We  Vx  -   -   EVX_PMOVQB+k        F=AVX512F TUPLE_EIGHTH_MEM
EVEX.F3.W0.0f3822      MR   We  Vx  -   -   EVX_PMOVSQB+k       F=AVX512F TUPLE_EIGHTH_MEM
EVEX.F3.W0.0f3812      MR   We  Vx  -   -   EVX_PMOVUSQB+k      F=AVX512F TUPLE_EIGHTH_MEM
EVEX.F3.W0.0f3833      MR   Wh  Vx  -   -   EVX_PMOVDW+k        F=AVX512F TUPLE_HALF_MEM
EVEX.F3.W0.0f3823      MR   Wh  Vx  -   -   EVX_PMOVSDW+k       F=AVX512F TUPLE_HALF_MEM
EVEX.F3.W0.0f3813      MR   Wh  Vx  -   -   EVX_PMOVUSDW+k      F=AVX512F TUPLE_HALF_MEM
EVEX.F3.W0.0f3834      MR   Wf  Vx  -   -   EVX_PMOVQW+k        F=AVX512F TUPLE_QUARTER_MEM
EVEX.F3.W0.0f3824      MR   Wf  Vx  -   -   EVX_PMOVSQW+k       F=AVX512F TUPLE_QUARTER_MEM
EVEX.F3.W0.0f3814      MR   Wf  Vx  -   -   EVX_PMOVUSQW+k      F=AVX512F TUPLE_QUARTER_MEM
EVEX.F3.W0.0f3835      MR   Wh  Vx  -   -   EVX_PMOVQD+k        F=AVX512F TUPLE_HALF_MEM
EVEX.F3.W0.0f3825      MR   Wh  Vx  -   -   EVX_PMOVSQD+k       F=AVX512F TUPLE_HALF_MEM
EVEX.F3.W0.0f3815      MR   Wh  Vx  -   -   EVX_PMOVUSQD+k      F=AVX512F TUPLE_HALF_MEM
EVEX.66.W1.0f3883      RVM  Vx  Hx  Wx  -   EVX_PMULTISHIFTQB+kb F=AVX512_VBMI TUPLE_FULL_64
EVEX.66.W0.0f3854      RM   Vx  Wx  -   -   EVX_POPCNTB+k       F=AVX512_BITALG TUPLE_FULL_MEM
EVEX.66.W1.0f3854      RM   Vx  Wx  -   -   EVX_POPCNTW+k       F=AVX512_BITALG TUPLE_FULL_MEM
EVEX.66.W0.0f3855      RM   Vx  Wx  -   -   EVX_POPCNTD+kb      F=AVX512_VPOPCNTDQ TUPLE_FULL_32
EVEX.66.W1.0f3855      RM   Vx  Wx  -   -   EVX_POPCNTQ+kb      F=AVX512_VPOPCNTDQ TUPLE_FULL_64
EVEX.66.W0.0f3814      RVM  Vx  Hx  Wx  -   EVX_PRORVD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3814      RVM  Vx  Hx  Wx  -   EVX_PRORVQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f72/0      VMI  Hx  Wx  Ib  -   EVX_PRORD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f72/0      VMI  Hx  Wx  Ib  -   EVX_PRORQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3815      RVM  Vx  Hx  Wx  -   EVX_PROLVD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3815      RVM  Vx  Hx  Wx  -   EVX_PROLVQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f72/1      VMI  Hx  Wx  Ib  -   EVX_PROLD+kb        F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f72/1      VMI  Hx  Wx  Ib  -   EVX_PROLQ+kb        F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f38a0/m    MR   Md  Vx  -   -   EVX_PSCATTERDD+k    F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f38a0/m    MR   Mq  Vx  -   -   EVX_PSCATTERDQ+k    F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.0f38a1/m    MR   Md  Vh  -   -   EVX_PSCATTERQD+k    F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f38a1/m    MR   Mq  Vx  -   -   EVX_PSCATTERQQ+k    F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W1.0f3a70      RVMI Vx  Hx  Wx  Ib  EVX_PSHLDW+k        F=AVX512_VBMI2 TUPLE_FULL_MEM
EVEX.66.W0.0f3a71      RVMI Vx  Hx  Wx  Ib  EVX_PSHLDD+kb       F=AVX512_VBMI2 TUPLE_FULL_32
EVEX.66.W1.0f3a71      RVMI Vx  Hx  Wx  Ib  EVX_PSHLDQ+kb       F=AVX512_VBMI2 TUPLE_FULL_64
EVEX.66.W1.0f3870      RVM  Vx  Hx  Wx  -   EVX_PSHLDVW+k       F=AVX512_VBMI2 TUPLE_FULL_MEM
EVEX.66.W0.0f3871      RVM  Vx  Hx  Wx  -   EVX_PSHLDVD+kb      F=AVX512_VBMI2 TUPLE_FULL_32
EVEX.66.W1.0f3871      RVM  Vx  Hx  Wx  -   EVX_PSHLDVQ+kb      F=AVX512_VBMI2 TUPLE_FULL_64
EVEX.66.W1.0f3a72      RVMI Vx  Hx  Wx  Ib  EVX_PSHRDW+k        F=AVX512_VBMI2 TUPLE_FULL_MEM
EVEX.66.W0.0f3a73      RVMI Vx  Hx  Wx  Ib  EVX_PSHRDD+kb       F=AVX512_VBMI2 TUPLE_FULL_32
EVEX.66.W1.0f3a73      RVMI Vx  Hx  Wx  Ib  EVX_PSHRDQ+kb       F=AVX512_VBMI2 TUPLE_FULL_64
EVEX.66.W1.0f3872      RVM  Vx  Hx  Wx  -   EVX_PSHRDVW+k       F=AVX512_VBMI2 TUPLE_FULL_MEM
EVEX.66.W0.0f3873      RVM  Vx  Hx  Wx  -   EVX_PSHRDVD+kb      F=AVX512_VBMI2 TUPLE_FULL_32
EVEX.66.W1.0f3873      RVM  Vx  Hx  Wx  -   EVX_PSHRDVQ+kb      F=AVX512_VBMI2 TUPLE_FULL_64
EVEX.66.W0.0f388f      RVM  K   Hx  Wx  -   EVX_PSHUFBITQMB+k   F=AVX512_BITALG TUPLE_FULL_MEM
EVEX.66.W1.0f3812      RVM  Vx  Hx  Wx  -   EVX_PSLLVW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3847      RVM  Vx  Hx  Wx  -   EVX_PSLLVD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3847      RVM  Vx  Hx  Wx  -   EVX_PSLLVQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W1.0f3811      RVM  Vx  Hx  Wx  -   EVX_PSRAVW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3846      RVM  Vx  Hx  Wx  -   EVX_PSRAVD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3846      RVM  Vx  Hx  Wx  -   EVX_PSRAVQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W1.0f3810      RVM  Vx  Hx  Wx  -   EVX_PSRLVW+k        F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3845      RVM  Vx  Hx  Wx  -   EVX_PSRLVD+kb       F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3845      RVM  Vx  Hx  Wx  -   EVX_PSRLVQ+kb       F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3a25      RVMI Vx  Hx  Wx  Ib  EVX_PTERNLOGD+kb    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a25      RVMI Vx  Hx  Wx  Ib  EVX_PTERNLOGQ+kb    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3826      RVM  K   Hx  Wx  -   EVX_PTESTMB+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W1.0f3826      RVM  K   Hx  Wx  -   EVX_PTESTMW+k       F=AVX512BW TUPLE_FULL_MEM
EVEX.66.W0.0f3827      RVM  K   Hx  Wx  -   EVX_PTESTMD+kb      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3827      RVM  K   Hx  Wx  -   EVX_PTESTMQ+kb      F=AVX512F TUPLE_FULL_64
EVEX.F3.W0.0f3826      RVM  K   Hx  Wx  -   EVX_PTESTNMB+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.F3.W1.0f3826      RVM  K   Hx  Wx  -   EVX_PTESTNMW+k      F=AVX512BW TUPLE_FULL_MEM
EVEX.F3.W0.0f3827      RVM  K   Hx  Wx  -   EVX_PTESTNMD+kb     F=AVX512F TUPLE_FULL_32
EVEX.F3.W1.0f3827      RVM  K   Hx  Wx  -   EVX_PTESTNMQ+kb     F=AVX512F TUPLE_FULL_64
EVEX.66.W0.0f3a50      RVMI Vps Hps Wps Ib  EVX_RANGEPS+kbe     F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f3a50      RVMI Vpd Hpd Wpd Ib  EVX_RANGEPD+kbe     F=AVX512DQ TUPLE_FULL_64
EVEX.66.W0.LIG.0f3a51  RVMI Vdq Hdq Wss Ib  EVX_RANGESS+ke      F=AVX512DQ TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3a51  RVMI Vdq Hdq Wsd Ib  EVX_RANGESD+ke      F=AVX512DQ TUPLE1_SCALAR_64
EVEX.66.W0.0f384c      RM   Vps Wps -   -   EVX_RCP14PS+kb      F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f384c      RM   Vpd Wpd -   -   EVX_RCP14PD+kb      F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f384d  RVM  Vdq Hdq Wss -   EVX_RCP14SS+k       F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f384d  RVM  Vdq Hdq Wsd -   EVX_RCP14SD+k       F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f3a56      RMI  Vps Wps Ib  -   EVX_REDUCEPS+kbe    F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f3a56      RMI  Vpd Wpd Ib  -   EVX_REDUCEPD+kbe    F=AVX512DQ TUPLE_FULL_64
EVEX.66.W0.LIG.0f3a57  RVMI Vdq Hdq Wss Ib  EVX_REDUCESS+ke     F=AVX512DQ TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3a57  RVMI Vdq Hdq Wsd Ib  EVX_REDUCESD+ke     F=AVX512DQ TUPLE1_SCALAR_64
EVEX.66.W0.0f3a08      RMI  Vps Wps Ib  -   EVX_RNDSCALEPS+kbe  F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f3a09      RMI  Vpd Wpd Ib  -   EVX_RNDSCALEPD+kbe  F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f3a0a  RVMI Vdq Hdq Wss Ib  EVX_RNDSCALESS+ke   F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f3a0b  RVMI Vdq Hdq Wsd Ib  EVX_RNDSCALESD+ke   F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f384e      RM   Vps Wps -   -   EVX_RSQRT14PS+kb    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f384e      RM   Vpd Wpd -   -   EVX_RSQRT14PD+kb    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f384f  RVM  Vdq Hdq Wss -   EVX_RSQRT14SS+k     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f384f  RVM  Vdq Hdq Wsd -   EVX_RSQRT14SD+k     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f382c      RVM  Vps Hps Wps -   EVX_SCALEFPS+kbr    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.0f382c      RVM  Vpd Hpd Wpd -   EVX_SCALEFPD+kbr    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.LIG.0f382d  RVM  Vdq Hdq Wss -   EVX_SCALEFSS+kr     F=AVX512F TUPLE1_SCALAR_32
EVEX.66.W1.LIG.0f382d  RVM  Vdq Hdq Wsd -   EVX_SCALEFSD+kr     F=AVX512F TUPLE1_SCALAR_64
EVEX.66.W0.0f38a2/m    MR   Md  Vx  -   -   EVX_SCATTERDPS+k    F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f38a2/m    MR   Mq  Vx  -   -   EVX_SCATTERDPD+k    F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.0f38a3/m    MR   Md  Vh  -   -   EVX_SCATTERQPS+k    F=AVX512F VSIB TUPLE1_SCALAR_32
EVEX.66.W1.0f38a3/m    MR   Mq  Vx  -   -   EVX_SCATTERQPD+k    F=AVX512F VSIB TUPLE1_SCALAR_64
EVEX.66.W0.L12.0f3a23  RVMI Vps Hps Wps Ib  EVX_SHUFF32X4+kb    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.L12.0f3a23  RVMI Vpd Hpd Wpd Ib  EVX_SHUFF64X2+kb    F=AVX512F TUPLE_FULL_64
EVEX.66.W0.L12.0f3a43  RVMI Vx  Hx  Wx  Ib  EVX_SHUFI32X4+kb    F=AVX512F TUPLE_FULL_32
EVEX.66.W1.L12.0f3a43  RVMI Vx  Hx  Wx  Ib  EVX_SHUFI64X2+kb    F=AVX512F TUPLE_FULL_64
EVEX.NP.W0.0f57        RVM  Vps Hps Wps -   EVX_XORPS+kb        F=AVX512DQ TUPLE_FULL_32
EVEX.66.W1.0f57        RVM  Vpd Hpd Wpd -   EVX_XORPD+kb        F=AVX512DQ TUPLE_FULL_64


# AVX512 Mask instructions
VEX.66.W0.L1.0f41/r    RVM  Kb  Kb  Kb  -   KANDB               F=AVX512DQ
VEX.NP.W0.L1.0f41/r    RVM  Kw  Kw  Kw  -   KANDW               F=AVX512F
VEX.66.W1.L1.0f41/r    RVM  Kd  Kd  Kd  -   KANDD               F=AVX512BW
VEX.NP.W1.L1.0f41/r    RVM  Kq  Kq  Kq  -   KANDQ               F=AVX512BW
VEX.66.W0.L1.0f42/r    RVM  Kb  Kb  Kb  -   KANDNB              F=AVX512DQ
VEX.NP.W0.L1.0f42/r    RVM  Kw  Kw  Kw  -   KANDNW              F=AVX512F
VEX.66.W1.L1.0f42/r    RVM  Kd  Kd  Kd  -   KANDND              F=AVX512BW
VEX.NP.W1.L1.0f42/r    RVM  Kq  Kq  Kq  -   KANDNQ              F=AVX512BW
VEX.66.W0.L0.0f44/r    RM   Kb  Kb  -   -   KNOTB               F=AVX512DQ
VEX.NP.W0.L0.0f44/r    RM   Kw  Kw  -   -   KNOTW               F=AVX512F
VEX.66.W1.L0.0f44/r    RM   Kd  Kd  -   -   KNOTD               F=AVX512BW
VEX.NP.W1.L0.0f44/r    RM   Kq  Kq  -   -   KNOTQ               F=AVX512BW
VEX.66.W0.L1.0f45/r    RVM  Kb  Kb  Kb  -   KORB                F=AVX512DQ
VEX.NP.W0.L1.0f45/r    RVM  Kw  Kw  Kw  -   KORW                F=AVX512F
VEX.66.W1.L1.0f45/r    RVM  Kd  Kd  Kd  -   KORD                F=AVX512BW
VEX.NP.W1.L1.0f45/r    RVM  Kq  Kq  Kq  -   KORQ                F=AVX512BW
VEX.66.W0.L1.0f46/r    RVM  Kb  Kb  Kb  -   KXNORB              F=AVX512DQ
VEX.NP.W0.L1.0f46/r    RVM  Kw  Kw  Kw  -   KXNORW              F=AVX512F
VEX.66.W1.L1.0f46/r    RVM  Kd  Kd  Kd  -   KXNORD              F=AVX512BW
VEX.NP.W1.L1.0f46/r    RVM  Kq  Kq  Kq  -   KXNORQ              F=AVX512BW
VEX.66.W0.L1.0f47/r    RVM  Kb  Kb  Kb  -   KXORB               F=AVX512DQ
VEX.NP.W0.L1.0f47/r    RVM  Kw  Kw  Kw  -   KXORW               F=AVX512F
VEX.66.W1.L1.0f47/r    RVM  Kd  Kd  Kd  -   KXORD               F=AVX512BW
VEX.NP.W1.L1.0f47/r    RVM  Kq  Kq  Kq  -   KXORQ               F=AVX512BW
VEX.66.W0.L1.0f4a/r    RVM  Kb  Kb  Kb  -   KADDB               F=AVX512DQ
VEX.NP.W0.L1.0f4a/r    RVM  Kw  Kw  Kw  -   KADDW               F=AVX512DQ
VEX.66.W1.L1.0f4a/r    RVM  Kd  Kd  Kd  -   KADDD               F=AVX512BW
VEX.NP.W1.L1.0f4a/r    RVM  Kq  Kq  Kq  -   KADDQ               F=AVX512BW
VEX.66.W0.L1.0f4b/r    RVM  Kw  Kb  Kb  -   KUNPCKBW            F=AVX512F
VEX.NP.W0.L1.0f4b/r    RVM  Kd  Kw  Kw  -   KUNPCKWD            F=AVX512BW
VEX.NP.W1.L1.0f4b/r    RVM  Kq  Kd  Kd  -   KUNPCKDQ            F=AVX512BW
VEX.66.W0.L0.0f98/r    RM   Kb  Kb  -   -   KORTESTB            F=AVX512DQ EFL=0--0m00m
VEX.NP.W0.L0.0f98/r    RM   Kw  Kw  -   -   KORTESTW            F=AVX512F EFL=0--0m00m
VEX.66.W1.L0.0f98/r    RM   Kd  Kd  -   -   KORTESTD            F=AVX512BW EFL=0--0m00m
VEX.NP.W1.L0.0f98/r    RM   Kq  Kq  -   -   KORTESTQ            F=AVX512BW EFL=0--0m00m
VEX.66.W0.L0.0f90      RM   Kb  Kb  -   -   KMOVB               F=AVX512DQ
VEX.NP.W0.L0.0f90      RM   Kw  Kw  -   -   KMOVW               F=AVX512F
VEX.66.W1.L0.0f90      RM   Kd  Kd  -   -   KMOVD               F=AVX512BW
VEX.NP.W1.L0.0f90      RM   Kq  Kq  -   -   KMOVQ               F=AVX512BW
VEX.66.W0.L0.0f91/m    MR   Mb  Kb  -   -   KMOVB               F=AVX512DQ
VEX.NP.W0.L0.0f91/m    MR   Mw  Kw  -   -   KMOVW               F=AVX512F
VEX.66.W1.L0.0f91/m    MR   Md  Kd  -   -   KMOVD               F=AVX512BW
VEX.NP.W1.L0.0f91/m    MR   Mq  Kq  -   -   KMOVQ               F=AVX512BW
VEX.66.W0.L0.0f92/r    RM   Kb  Rd  -   -   KMOVB               F=AVX512DQ
VEX.NP.W0.L0.0f92/r    RM   Kw  Rd  -   -   KMOVW               F=AVX512F
VEX.F2.W0.L0.0f92/r    RM   Kd  Rd  -   -   KMOVD               F=AVX512BW
VEX.F2.W1.L0.0f92/r    RM   Kq  Rq  -   -   KMOVQ       O64     F=AVX512BW
VEX.66.W0.L0.0f93/r    RM   Gd  Kb  -   -   KMOVB               F=AVX512DQ
VEX.NP.W0.L0.0f93/r    RM   Gd  Kw  -   -   KMOVW               F=AVX512F
VEX.F2.W0.L0.0f93/r    RM   Gd  Kd  -   -   KMOVD               F=AVX512BW
VEX.F2.W1.L0.0f93/r    RM   Gq  Kq  -   -   KMOVQ       O64     F=AVX512BW
VEX.66.W0.L0.0f99/r    RM   Kb  Kb  -   -   KTESTB              F=AVX512DQ EFL=0--0m00m
VEX.NP.W0.L0.0f99/r    RM   Kw  Kw  -   -   KTESTW              F=AVX512DQ EFL=0--0m00m
VEX.66.W1.L0.0f99/r    RM   Kd  Kd  -   -   KTESTD              F=AVX512BW EFL=0--0m00m
VEX.NP.W1.L0.0f99/r    RM   Kq  Kq  -   -   KTESTQ              F=AVX512BW EFL=0--0m00m
VEX.66.W0.L0.0f3a30/r  RMI  Kb  Kb  Ib  -   KSHIFTRB            F=AVX512DQ
VEX.66.W1.L0.0f3a30/r  RMI  Kw  Kw  Ib  -   KSHIFTRW            F=AVX512F
VEX.66.W0.L0.0f3a31/r  RMI  Kd  Kd  Ib  -   KSHIFTRD            F=AVX512BW
VEX.66.W1.L0.0f3a31/r  RMI  Kq  Kq  Ib  -   KSHIFTRQ            F=AVX512BW
VEX.66.W0.L0.0f3a32/r  RMI  Kb  Kb  Ib  -   KSHIFTLB            F=AVX512DQ
VEX.66.W1.L0.0f3a32/r  RMI  Kw  Kw  Ib  -   KSHIFTLW            F=AVX512F
VEX.66.W0.L0.0f3a33/r  RMI  Kd  Kd  Ib  -   KSHIFTLD            F=AVX512BW
VEX.66.W1.L0.0f3a33/r  RMI  Kq  Kq  Ib  -   KSHIFTLQ            F=AVX512BW

# AVX512-FP16
EVEX.NP.W0.0f3a08      RMI  Vx  Wx  Ib  -   EVX_RNDSCALEPH+kbe  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.NP.W0.LIG.0f3a0a  RVMI Vdq Hdq Ww  Ib  EVX_RNDSCALESH+ke   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.0f3a26      RMI  Vx  Wx  Ib  -   EVX_GETMANTPH+kbe   F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.NP.W0.LIG.0f3a27  RVMI Vdq Hdq Ww  Ib  EVX_GETMANTSH+ke    F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.0f3a56      RMI  Vx  Wx  Ib  -   EVX_REDUCEPH+kbe    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.NP.W0.LIG.0f3a57  RVMI Vdq Hdq Ww  Ib  EVX_REDUCESH+ke     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.0f3a66      RMI  K   Wx  Ib  -   EVX_FPCLASSPH+kb    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.NP.W0.LIG.0f3a67  RMI  Kb  Ww  Ib  -   EVX_FPCLASSSH+k     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.0f3ac2      RVMI K   Hx  Wx  Ib  EVX_CMPPH+kbe       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.0f3ac2  RVMI Kb  Hw  Ww  Ib  EVX_CMPSH+ke        F=AVX512-FP16 TUPLE1_SCALAR_16

EVEX.F3.W0.LIG.M5.10/m RM   Vdq Mw  -   -   EVX_MOVSH+k         F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.F3.W0.LIG.M5.10/r RVM  Vdq Hdq Uw  -   EVX_MOVSH+k         F=AVX512-FP16
EVEX.F3.W0.LIG.M5.11/m MR   Mw  Vw  -   -   EVX_MOVSH+k         F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.F3.W0.LIG.M5.11/r MVR  Udq Hdq Vw  -   EVX_MOVSH+k         F=AVX512-FP16
EVEX.NP.W0.LIG.M5.1d   RVM  Vdq Hdq Wd  -   EVX_CVTSS2SH+kr     F=AVX512-FP16 TUPLE1_SCALAR_32
EVEX.66.W0.M5.1d       RM   Vh  Wx  -   -   EVX_CVTPS2PHX+kbr   F=AVX512-FP16 TUPLE_FULL_32
EVEX.F3.LIG.M5.2a      RVM  Vdq Hdq Ey  -   EVX_CVTSI2SH+r      F=AVX512-FP16 TUPLE1_SCALAR_OPSZ
EVEX.F3.LIG.M5.2c      RM   Gy  Ww  -   -   EVX_CVTTSH2SI+e     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.F3.LIG.M5.2d      RM   Gy  Ww  -   -   EVX_CVTSH2SI+r      F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.LIG.M5.2e   RM   Vw  Ww  -   -   EVX_UCOMISH+e       F=AVX512-FP16 TUPLE1_SCALAR_16 EFL=0--0m0mm
EVEX.NP.W0.LIG.M5.2f   RM   Vw  Ww  -   -   EVX_COMISH+e        F=AVX512-FP16 TUPLE1_SCALAR_16 EFL=0--0m0mm
EVEX.NP.W0.M5.51       RM   Vx  Wx  -   -   EVX_SQRTPH+kbr      F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.51   RVM  Vdq Hdq Ww  -   EVX_SQRTSH+kr       F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.58       RVM  Vx  Hx  Wx  -   EVX_ADDPH+kbr       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.58   RVM  Vdq Hdq Ww  -   EVX_ADDSH+kr        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.59       RVM  Vx  Hx  Wx  -   EVX_MULPH+kbr       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.59   RVM  Vdq Hdq Ww  -   EVX_MULSH+kr        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.5a       RM   Vx  Wf  -   -   EVX_CVTPH2PD+kbe    F=AVX512-FP16 TUPLE_QUARTER_16 BCST16
EVEX.66.W1.M5.5a       RM   Vf  Wx  -   -   EVX_CVTPD2PH+kbr    F=AVX512-FP16 TUPLE_FULL_64
EVEX.F3.W0.LIG.M5.5a   RVM  Vdq Hdq Ww  -   EVX_CVTSH2SD+ke     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.F2.W1.LIG.M5.5a   RVM  Vdq Hdq Wq  -   EVX_CVTSD2SH+kr     F=AVX512-FP16 TUPLE1_SCALAR_64
EVEX.NP.W0.M5.5b       RM   Vh  Wx  -   -   EVX_CVTDQ2PH+kbr    F=AVX512-FP16 TUPLE_FULL_32
EVEX.NP.W1.M5.5b       RM   Vf  Wx  -   -   EVX_CVTQQ2PH+kbr    F=AVX512-FP16 TUPLE_FULL_64
EVEX.66.W0.M5.5b       RM   Vx  Wh  -   -   EVX_CVTPH2DQ+kbr    F=AVX512-FP16 TUPLE_HALF_16 BCST16
EVEX.F3.W0.M5.5b       RM   Vx  Wh  -   -   EVX_CVTTPH2DQ+kbe   F=AVX512-FP16 TUPLE_HALF_16 BCST16
EVEX.NP.W0.M5.5c       RVM  Vx  Hx  Wx  -   EVX_SUBPH+kbr       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.5c   RVM  Vdq Hdq Ww  -   EVX_SUBSH+kr        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.5d       RVM  Vx  Hx  Wx  -   EVX_MINPH+kbe       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.5d   RVM  Vdq Hdq Ww  -   EVX_MINSH+ke        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.5e       RVM  Vx  Hx  Wx  -   EVX_DIVPH+kbr       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.5e   RVM  Vdq Hdq Ww  -   EVX_DIVSH+kr        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.5f       RVM  Vx  Hx  Wx  -   EVX_MAXPH+kbe       F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.LIG.M5.5f   RVM  Vdq Hdq Ww  -   EVX_MAXSH+ke        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.L0.M5.6e       RM   Vdq Ew  -   -   EVX_MOVW_G2X        F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.78       RM   Vx  Wh  -   -   EVX_CVTTPH2UDQ+kbe  F=AVX512-FP16 TUPLE_HALF_16 BCST16
EVEX.66.W0.M5.78       RM   Vx  Wf  -   -   EVX_CVTTPH2UQQ+kbe  F=AVX512-FP16 TUPLE_QUARTER_16 BCST16
EVEX.F3.LIG.M5.78      RM   Gy  Ww  -   -   EVX_CVTTSH2USI+e    F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.NP.W0.M5.79       RM   Vx  Wh  -   -   EVX_CVTPH2UDQ+kbr   F=AVX512-FP16 TUPLE_HALF_16 BCST16
EVEX.66.W0.M5.79       RM   Vx  Wf  -   -   EVX_CVTPH2UQQ+kbr   F=AVX512-FP16 TUPLE_QUARTER_16 BCST16
EVEX.F3.LIG.M5.79      RM   Gy  Ww  -   -   EVX_CVTSH2USI+r     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M5.7a       RM   Vx  Wf  -   -   EVX_CVTTPH2QQ+kbe   F=AVX512-FP16 TUPLE_QUARTER_16 BCST16
EVEX.F2.W0.M5.7a       RM   Vh  Wx  -   -   EVX_CVTUDQ2PH+kbr   F=AVX512-FP16 TUPLE_FULL_32
EVEX.F2.W1.M5.7a       RM   Vf  Wx  -   -   EVX_CVTUQQ2PH+kbr   F=AVX512-FP16 TUPLE_FULL_64
EVEX.66.W0.M5.7b       RM   Vx  Wf  -   -   EVX_CVTPH2QQ+kbr    F=AVX512-FP16 TUPLE_QUARTER_16 BCST16
EVEX.F3.LIG.M5.7b      RVM  Vdq Hdq Ey  -   EVX_CVTUSI2SH+r     F=AVX512-FP16 TUPLE1_SCALAR_OPSZ
EVEX.NP.W0.M5.7c       RM   Vx  Wx  -   -   EVX_CVTTPH2UW+kbe   F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M5.7c       RM   Vx  Wx  -   -   EVX_CVTTPH2W+kbe    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.NP.W0.M5.7d       RM   Vx  Wx  -   -   EVX_CVTPH2UW+kbr    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M5.7d       RM   Vx  Wx  -   -   EVX_CVTPH2W+kbr     F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F3.W0.M5.7d       RM   Vx  Wx  -   -   EVX_CVTW2PH+kbr     F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.F2.W0.M5.7d       RM   Vx  Wx  -   -   EVX_CVTUW2PH+kbr    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.L0.M5.7e       MR   Ew  Vw  -   -   EVX_MOVW_X2G        F=AVX512-FP16 TUPLE1_SCALAR_16

EVEX.66.W0.M6.13       RM   Vx  Wh  -   -   EVX_CVTPH2PSX+kbe   F=AVX512-FP16 TUPLE_HALF_16 BCST16
EVEX.NP.W0.LIG.M6.13   RVM  Vdq Hdq Ww  -   EVX_CVTSH2SS+ke     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.2c       RVM  Vx  Hx  Wx  -   EVX_SCALEFPH+kbr    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.2d   RVM  Vdq Hdq Ww  -   EVX_SCALEFSH+kr     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.42       RM   Vx  Wx  -   -   EVX_GETEXPPH+kbe    F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.43   RVM  Vdq Hdq Ww  -   EVX_GETEXPSH+ke     F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.4c       RM   Vx  Wx  -   -   EVX_RCPPH+kb        F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.4d   RVM  Vdq Hdq Ww  -   EVX_RCPSH+k         F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.4e       RM   Vx  Wx  -   -   EVX_RSQRTPH+kb      F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.4f   RVM  Vdq Hdq Ww  -   EVX_RSQRTSH+k       F=AVX512-FP16 TUPLE1_SCALAR_16

# TODO: for F{,C}M{ADD,UL}C{P,S}H, destreg must be unequal to the source registers
EVEX.F3.W0.M6.56       RVM  Vx  Hx  Wx  -   EVX_FMADDCPH+kbr    F=AVX512-FP16 TUPLE_FULL_32
EVEX.F2.W0.M6.56       RVM  Vx  Hx  Wx  -   EVX_FCMADDCPH+kbr   F=AVX512-FP16 TUPLE_FULL_32
EVEX.F3.W0.LIG.M6.57   RVM  Vdq Hdq Wd  -   EVX_FMADDCSH+kr     F=AVX512-FP16 TUPLE1_SCALAR_32
EVEX.F2.W0.LIG.M6.57   RVM  Vdq Hdq Wd  -   EVX_FCMADDCSH+kr    F=AVX512-FP16 TUPLE1_SCALAR_32
EVEX.F3.W0.M6.d6       RVM  Vx  Hx  Wx  -   EVX_FMULCPH+kbr     F=AVX512-FP16 TUPLE_FULL_32
EVEX.F2.W0.M6.d6       RVM  Vx  Hx  Wx  -   EVX_FCMULCPH+kbr    F=AVX512-FP16 TUPLE_FULL_32
EVEX.F3.W0.LIG.M6.d7   RVM  Vdq Hdq Wd  -   EVX_FMULCSH+kr      F=AVX512-FP16 TUPLE1_SCALAR_32
EVEX.F2.W0.LIG.M6.d7   RVM  Vdq Hdq Wd  -   EVX_FCMULCSH+kr     F=AVX512-FP16 TUPLE1_SCALAR_32

EVEX.66.W0.M6.96       RVM  Vx  Hx  Wx  -   EVX_FMADDSUB132PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.a6       RVM  Vx  Hx  Wx  -   EVX_FMADDSUB213PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.b6       RVM  Vx  Hx  Wx  -   EVX_FMADDSUB231PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.97       RVM  Vx  Hx  Wx  -   EVX_FMSUBADD132PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.a7       RVM  Vx  Hx  Wx  -   EVX_FMSUBADD213PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.b7       RVM  Vx  Hx  Wx  -   EVX_FMSUBADD231PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.98       RVM  Vx  Hx  Wx  -   EVX_FMADD132PH+kbr  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.a8       RVM  Vx  Hx  Wx  -   EVX_FMADD213PH+kbr  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.b8       RVM  Vx  Hx  Wx  -   EVX_FMADD231PH+kbr  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.99   RVM  Vdq Hdq Ww  -   EVX_FMADD132SH+kr   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.a9   RVM  Vdq Hdq Ww  -   EVX_FMADD213SH+kr   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.b9   RVM  Vdq Hdq Ww  -   EVX_FMADD231SH+kr   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.9a       RVM  Vx  Hx  Wx  -   EVX_FMSUB132PH+kbr  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.aa       RVM  Vx  Hx  Wx  -   EVX_FMSUB213PH+kbr  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.ba       RVM  Vx  Hx  Wx  -   EVX_FMSUB231PH+kbr  F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.9b   RVM  Vdq Hdq Ww  -   EVX_FMSUB132SH+kr   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.ab   RVM  Vdq Hdq Ww  -   EVX_FMSUB213SH+kr   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.bb   RVM  Vdq Hdq Ww  -   EVX_FMSUB231SH+kr   F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.9c       RVM  Vx  Hx  Wx  -   EVX_FNMADD132PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.ac       RVM  Vx  Hx  Wx  -   EVX_FNMADD213PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.bc       RVM  Vx  Hx  Wx  -   EVX_FNMADD231PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.9d   RVM  Vdq Hdq Ww  -   EVX_FNMADD132SH+kr  F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.ad   RVM  Vdq Hdq Ww  -   EVX_FNMADD213SH+kr  F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.bd   RVM  Vdq Hdq Ww  -   EVX_FNMADD231SH+kr  F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.M6.9e       RVM  Vx  Hx  Wx  -   EVX_FNMSUB132PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.ae       RVM  Vx  Hx  Wx  -   EVX_FNMSUB213PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.M6.be       RVM  Vx  Hx  Wx  -   EVX_FNMSUB231PH+kbr F=AVX512-FP16 TUPLE_FULL_16 BCST16
EVEX.66.W0.LIG.M6.9f   RVM  Vdq Hdq Ww  -   EVX_FNMSUB132SH+kr  F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.af   RVM  Vdq Hdq Ww  -   EVX_FNMSUB213SH+kr  F=AVX512-FP16 TUPLE1_SCALAR_16
EVEX.66.W0.LIG.M6.bf   RVM  Vdq Hdq Ww  -   EVX_FNMSUB231SH+kr  F=AVX512-FP16 TUPLE1_SCALAR_16

```

`third_party/fadec/meson.build`:

```build
project('fadec', ['c'], default_options: ['warning_level=3', 'c_std=c11'],
        meson_version: '>=0.49')

python3 = find_program('python3')

# Check Python version
py_version_res = run_command(python3, ['--version'], check: true)
py_version = py_version_res.stdout().split(' ')[1]
if not py_version.version_compare('>=3.9')
  error('Python 3.9 required, got @0@'.format(py_version))
endif

has_cpp = add_languages('cpp', required: false)

cc = meson.get_compiler('c')
if cc.has_argument('-fstrict-aliasing')
  add_project_arguments('-fstrict-aliasing', language: 'c')
endif
if get_option('warning_level').to_int() >= 3
  extra_warnings = [
    '-Wmissing-prototypes', '-Wshadow',  '-Wwrite-strings', '-Wswitch-default',
    '-Winline', '-Wstrict-prototypes', '-Wundef',
    # We have strings longer than 4095 characters
    '-Wno-overlength-strings',
    # GCC 8 requires an extra option for strict cast alignment checks, Clang
    # always warns, even on architectures without alignment requirements.
    '-Wcast-align', '-Wcast-align=strict',
  ]
  add_project_arguments(cc.get_supported_arguments(extra_warnings), language: 'c')
endif
if cc.get_argument_syntax() == 'msvc'
  # Disable some warnings to align warnings with GCC and Clang:
  add_project_arguments('-D_CRT_SECURE_NO_WARNINGS',
                        '/wd4018', # - Signed/unsigned comparison
                        '/wd4146', # - Unary minus operator applied to unsigned
                                   #   type, result still unsigned
                        '/wd4244', # - Possible loss of data in conversion
                                   #   from integer type to smaller integer type
                        '/wd4245', # - Signed/unsigned assignment
                        '/wd4267', # - Possible loss of data in conversion
                                   #   from size_t to smaller type
                        '/wd4310', # - Possible loss of data in conversion
                                   #   of constant value to smaller type
                        language: 'c')
endif
if cc.get_id() == 'msvc' and has_cpp
  cxx = meson.get_compiler('cpp')
  if cxx.get_id() == 'msvc'
    # Enable standard conformant preprocessor
    add_project_arguments(cxx.get_supported_arguments(['-Zc:preprocessor']), language: 'cpp')
  endif
endif

sources = []
headers = []
components = []

if get_option('with_decode')
  components += 'decode'
  headers += files('fadec.h')
  sources += files('decode.c', 'format.c')
endif
if get_option('with_encode')
  components += 'encode'
  headers += files('fadec-enc.h')
  sources += files('encode.c')
endif
if get_option('with_encode2')
  components += 'encode2'
  headers += files('fadec-enc2.h')
  sources += files('encode2.c')
endif

generate_args = []
if get_option('archmode') != 'only64'
  generate_args += ['--32']
endif
if get_option('archmode') != 'only32'
  generate_args += ['--64']
endif
if get_option('with_undoc')
  generate_args += ['--with-undoc']
endif
if not meson.is_subproject()
  generate_args += ['--stats']
endif

tables = []
foreach component : components
  tables += custom_target('@0@_table'.format(component),
                          command: [python3, '@INPUT0@', component,
                                    '@INPUT1@', '@OUTPUT@'] + generate_args,
                          input: files('parseinstrs.py', 'instrs.txt'),
                          output: ['fadec-@0@-public.inc'.format(component),
                                   'fadec-@0@-private.inc'.format(component)],
                          install: true,
                          install_dir: [get_option('includedir'), false])
endforeach

libfadec = static_library('fadec', sources, tables, install: true)
fadec = declare_dependency(link_with: libfadec,
                           include_directories: include_directories('.'),
                           sources: tables)
install_headers(headers)

foreach component : components
  test(component, executable('@0@-test'.format(component),
                             '@0@-test.c'.format(component),
                             dependencies: fadec))
  if component == 'encode2' and has_cpp
    test(component + '-cpp', executable('@0@-test-cpp'.format(component),
                                        '@0@-test.cc'.format(component),
                                        dependencies: fadec))
  endif
endforeach

if meson.version().version_compare('>=0.54.0')
  meson.override_dependency('fadec', fadec)
endif

pkg = import('pkgconfig')
pkg.generate(libraries: libfadec,
             version: '0.1',
             name: 'fadec',
             filebase: 'fadec',
             description: 'Fast Decoder for x86-32 and x86-64')

```

`third_party/fadec/meson_options.txt`:

```txt
option('archmode', type: 'combo', choices: ['both', 'only32', 'only64'])
option('with_undoc', type: 'boolean', value: false)
option('with_decode', type: 'boolean', value: true)
option('with_encode', type: 'boolean', value: true)
# encode2 is off-by-default to reduce size and compile-time
option('with_encode2', type: 'boolean', value: false)

```

`third_party/fadec/parseinstrs.py`:

```py
#!/usr/bin/python3

import argparse
import bisect
from collections import OrderedDict, defaultdict, namedtuple
from enum import Enum
from itertools import product
import re
from typing import NamedTuple, FrozenSet, List, Tuple, Union

INSTR_FLAGS_FIELDS, INSTR_FLAGS_SIZES = zip(*[
    ("modrm_idx", 2),
    ("modreg_idx", 2),
    ("vexreg_idx", 2), # note: vexreg w/o vex prefix is zeroreg_val
    ("imm_idx", 2),
    ("evex_bcst", 1),
    ("evex_mask", 1),
    ("zeroreg_val", 1),
    ("lock", 1),
    ("imm_control", 3),
    ("vsib", 1),
    ("modrm_size", 2),
    ("modreg_size", 2),
    ("vexreg_size", 2),
    ("imm_size", 2),
    ("legacy", 1),
    ("unused2", 1),
    ("size_fix1", 3),
    ("size_fix2", 2),
    ("instr_width", 1),
    ("modrm_ty", 3),
    ("modreg_ty", 3),
    ("vexreg_ty", 2),
    ("imm_ty", 0),
    ("evex_rc", 2),
    ("evex_bcst16", 1),
    ("opsize", 3),
    ("modrm", 1),
    ("ign66", 1),
][::-1])
class InstrFlags(namedtuple("InstrFlags", INSTR_FLAGS_FIELDS)):
    def __new__(cls, **kwargs):
        init = {**{f: 0 for f in cls._fields}, **kwargs}
        return super(InstrFlags, cls).__new__(cls, **init)
    def _encode(self):
        enc = 0
        for value, size in zip(self, INSTR_FLAGS_SIZES):
            enc = enc << size | (value & ((1 << size) - 1))
        return enc

ENCODINGS = {
    "NP": InstrFlags(),
    "M": InstrFlags(modrm=1, modrm_idx=0^3),
    "R": InstrFlags(modrm=1, modreg_idx=0^3), # AMX TILEZERO
    "M1": InstrFlags(modrm=1, modrm_idx=0^3, imm_idx=1^3, imm_control=1),
    "MI": InstrFlags(modrm=1, modrm_idx=0^3, imm_idx=1^3, imm_control=4),
    "IM": InstrFlags(modrm=1, modrm_idx=1^3, imm_idx=0^3, imm_control=4),
    "MC": InstrFlags(modrm=1, modrm_idx=0^3, vexreg_idx=1^3, zeroreg_val=1),
    "MR": InstrFlags(modrm=1, modrm_idx=0^3, modreg_idx=1^3),
    "RM": InstrFlags(modrm=1, modrm_idx=1^3, modreg_idx=0^3),
    "RMA": InstrFlags(modrm=1, modrm_idx=1^3, modreg_idx=0^3, vexreg_idx=2^3),
    "MRI": InstrFlags(modrm=1, modrm_idx=0^3, modreg_idx=1^3, imm_idx=2^3, imm_control=4),
    "RMI": InstrFlags(modrm=1, modrm_idx=1^3, modreg_idx=0^3, imm_idx=2^3, imm_control=4),
    "MRC": InstrFlags(modrm=1, modrm_idx=0^3, modreg_idx=1^3, vexreg_idx=2^3, zeroreg_val=1),
    "AM": InstrFlags(modrm=1, modrm_idx=1^3, vexreg_idx=0^3),
    "MA": InstrFlags(modrm=1, modrm_idx=0^3, vexreg_idx=1^3),
    "I": InstrFlags(imm_idx=0^3, imm_control=4),
    "IA": InstrFlags(vexreg_idx=0^3, imm_idx=1^3, imm_control=4),
    "O": InstrFlags(modrm_idx=0^3),
    "OI": InstrFlags(modrm_idx=0^3, imm_idx=1^3, imm_control=4),
    "OA": InstrFlags(modrm_idx=0^3, vexreg_idx=1^3),
    "S": InstrFlags(modreg_idx=0^3), # segment register in bits 3,4,5
    "A": InstrFlags(vexreg_idx=0^3),
    "D": InstrFlags(imm_idx=0^3, imm_control=6),
    "FD": InstrFlags(vexreg_idx=0^3, imm_idx=1^3, imm_control=2),
    "TD": InstrFlags(vexreg_idx=1^3, imm_idx=0^3, imm_control=2),

    "RVM": InstrFlags(modrm=1, modrm_idx=2^3, modreg_idx=0^3, vexreg_idx=1^3),
    "RVMI": InstrFlags(modrm=1, modrm_idx=2^3, modreg_idx=0^3, vexreg_idx=1^3, imm_idx=3^3, imm_control=4),
    "RVMR": InstrFlags(modrm=1, modrm_idx=2^3, modreg_idx=0^3, vexreg_idx=1^3, imm_idx=3^3, imm_control=3),
    "RMV": InstrFlags(modrm=1, modrm_idx=1^3, modreg_idx=0^3, vexreg_idx=2^3),
    "VM": InstrFlags(modrm=1, modrm_idx=1^3, vexreg_idx=0^3),
    "VMI": InstrFlags(modrm=1, modrm_idx=1^3, vexreg_idx=0^3, imm_idx=2^3, imm_control=4),
    "MVR": InstrFlags(modrm=1, modrm_idx=0^3, modreg_idx=2^3, vexreg_idx=1^3),
    "MRV": InstrFlags(modrm=1, modrm_idx=0^3, modreg_idx=1^3, vexreg_idx=2^3),
}
ENCODING_OPTYS = ["modrm", "modreg", "vexreg", "imm"]
ENCODING_OPORDER = { enc: sorted(ENCODING_OPTYS, key=lambda ty: getattr(ENCODINGS[enc], ty+"_idx")^3) for enc in ENCODINGS}

OPKIND_CANONICALIZE = {
    "I": "IMM", # immediate
        "A": "IMM", # Direct address, far jmp
    "J": "IMM", # RIP-relative address
    "M": "MEM", # ModRM.r/m selects memory only
        "O": "MEM", # Direct address, FD/TD encoding
    "R": "GP", # ModRM.r/m selects GP
        "B": "GP", # VEX.vvvv selects GP
        "E": "GP", # ModRM.r/m selects GP or memory
        "G": "GP", # ModRM.reg selects GP
    "P": "MMX", # ModRM.reg selects MMX
        "N": "MMX", # ModRM.r/m selects MMX
        "Q": "MMX", # ModRM.r/m selects MMX or memory
    "V": "XMM", # ModRM.reg selects XMM
        "H": "XMM", # VEX.vvvv selects XMM
        "L": "XMM", # bits7:4 of imm8 select XMM
        "U": "XMM", # ModRM.r/m selects XMM
        "W": "XMM", # ModRM.r/m selects XMM or memory
    "S": "SEG", # ModRM.reg selects SEG
    "C": "CR", # ModRM.reg selects CR
    "D": "DR", # ModRM.reg selects DR

    # Custom names
    "F": "FPU", # F is used for RFLAGS by Intel
    "K": "MASK",
    "T": "TMM",
    "Z": "BND",
}
OPKIND_SIZES = {
    "b": 1,
    "w": 2,
    "d": 4,
    "ss": 4, # Scalar single of XMM (d)
    "q": 8,
    "sd": 8, # Scalar double of XMM (q)
    "t": 10, # FPU/ten-byte
    "dq": 16,
    "qq": 32,
    "oq": 64, # oct-quadword
    "": 0, # for MEMZ
    "v": -1, # operand size (w/d/q)
    "y": -1, # operand size (d/q)
    "z": -1, # w/d (immediates, min(operand size, 4))
    "a": -1, # z:z
    "p": -1, # w:z
    "x": -2, # vector size
    "h": -3, # half x
    "f": -4, # fourth x
    "e": -5, # eighth x
    "pd": -2, # packed double (x)
    "ps": -2, # packed single (x)

    # Custom names
    "bs": -1, # sign-extended immediate
    "zd": 4, # z-immediate, but always 4-byte operand
    "zq": 8, # z-immediate, but always 8-byte operand
}
class OpKind(NamedTuple):
    regkind: str
    sizestr: str

    SZ_OP = -1
    SZ_VEC = -2
    SZ_VEC_HALF = -3
    SZ_VEC_QUARTER = -4
    SZ_VEC_EIGHTH = -5

    def abssize(self, opsz=None, vecsz=None):
        res = opsz if self.size == self.SZ_OP else \
              vecsz if self.size == self.SZ_VEC else \
              vecsz >> 1 if self.size == self.SZ_VEC_HALF else \
              vecsz >> 2 if self.size == self.SZ_VEC_QUARTER else \
              vecsz >> 3 if self.size == self.SZ_VEC_EIGHTH else self.size
        if res is None:
            raise Exception("unspecified operand size")
        return res
    def immsize(self, opsz):
        maxsz = 1 if self.sizestr == "bs" else 4 if self.sizestr[0] == "z" else 8
        return min(maxsz, self.abssize(opsz))
    @property
    def kind(self):
        return OPKIND_CANONICALIZE[self.regkind]
    @property
    def size(self):
        return OPKIND_SIZES[self.sizestr]
    @classmethod
    def parse(cls, op):
        return cls(op[0], op[1:])

    def __eq__(self, other):
        # Custom equality for canonicalization of kind/size.
        return isinstance(other, OpKind) and self.kind == other.kind and self.size == other.size

class InstrDesc(NamedTuple):
    mnemonic: str
    encoding: str
    operands: Tuple[str, ...]
    flags: FrozenSet[str]

    OPKIND_REGTYS = {
        ("modrm", "GP"): 1,   ("modreg", "GP"): 1,   ("vexreg", "GP"): 1,
        ("modrm", "XMM"): 0,  ("modreg", "XMM"): 0,  ("vexreg", "XMM"): 0,
        ("modrm", "MMX"): 5,  ("modreg", "MMX"): 5,
        ("modrm", "FPU"): 4,                         ("vexreg", "FPU"): 3,
        ("modrm", "TMM"): 6,  ("modreg", "TMM"): 6,  ("vexreg", "TMM"): 3,
        ("modrm", "MASK"): 7, ("modreg", "MASK"): 7, ("vexreg", "MASK"): 2,
                              ("modreg", "SEG"): 3,
                              ("modreg", "DR"): 0, # handled in code
                              ("modreg", "CR"): 0, # handled in code
        ("modrm", "MEM"): 0,
        ("imm", "MEM"): 0, ("imm", "IMM"): 0, ("imm", "XMM"): 0,
    }
    OPKIND_SIZES = {
        0: 0, 1: 1, 2: 2, 4: 3, 8: 4, 16: 5, 32: 6, 64: 7, 10: 0,
        # OpKind.SZ_OP: -2, OpKind.SZ_VEC: -3, OpKind.SZ_HALFVEC: -4,
    }

    @classmethod
    def parse(cls, desc):
        desc = desc.split()
        mnem, _, compactDesc = desc[5].partition("+")
        flags = frozenset(desc[6:] + [{
            "w": "INSTR_WIDTH",
            "a": "U67",
            "s": "USEG",
            "k": "MASK",
            "b": "BCST",
            "e": "SAE",
            "r": "ER",
        }[c] for c in compactDesc])
        operands = tuple(OpKind.parse(op) for op in desc[1:5] if op != "-")
        return cls(mnem, desc[0], operands, flags)

    def imm_size(self, opsz):
        flags = ENCODINGS[self.encoding]
        if flags.imm_control < 3:
            return 0
        if flags.imm_control == 3:
            return 1
        if self.mnemonic == "ENTER":
            return 3
        return self.operands[flags.imm_idx^3].immsize(opsz)

    def dynsizes(self):
        dynopsz = set(op.size for op in self.operands if op.size < 0)
        if {"INSTR_WIDTH", "SZ8"} & self.flags: dynopsz.add(OpKind.SZ_OP)
        if OpKind.SZ_OP in dynopsz and len(dynopsz) > 1:
            raise Exception(f"conflicting dynamic operand sizes in {self}")
        return dynopsz

    def encode(self, mnem, ign66, modrm):
        flags = ENCODINGS[self.encoding]
        extraflags = {}

        dynopsz = self.dynsizes()
        # Operand size either refers to vectors or GP, but not both
        if dynopsz and OpKind.SZ_OP not in dynopsz: # Vector operand size
            if self.flags & {"SZ8", "D64", "F64", "INSTR_WIDTH", "LOCK", "U66"}:
                raise Exception(f"incompatible flags in {self}")
            # Allow at most the vector size together with one alternative
            dynsizes = [OpKind.SZ_VEC] + list(dynopsz - {OpKind.SZ_VEC})
            extraflags["opsize"] = 4 | (OpKind.SZ_VEC - dynsizes[-1])
            if len(dynsizes) > 2:
                raise Exception(f"conflicting vector operand sizes in {self}")
        else: # either empty or GP operand size
            dynsizes = [OpKind.SZ_OP]
            if "SZ8" in self.flags:
                dynsizes = []
            if "D64" in self.flags: extraflags["opsize"] = 2
            if "F64" in self.flags: extraflags["opsize"] = 3
            extraflags["lock"] = "LOCK" in self.flags

        if (self.flags & {"SZ8", "INSTR_WIDTH"} or
            mnem in ("MOVSX", "MOVZX", "XCHG_NOP", "3DNOW")):
            extraflags["legacy"] = 1
            # INSTR_WIDTH defaults to zero, so only enable when SZ8 is unset
            if "INSTR_WIDTH" in self.flags and "SZ8" not in self.flags:
                extraflags["instr_width"] = 1

        imm_byte = self.imm_size(4) == 1
        extraflags["imm_control"] = flags.imm_control | imm_byte

        # Sort fixed sizes encodable in size_fix2 as second element.
        # But: byte-sized immediates are handled specially and don't cost space.
        fixed = set(self.OPKIND_SIZES[op.size] for op in self.operands if
                    op.size >= 0 and not (imm_byte and op.kind == "IMM"))
        fixed = sorted(fixed, key=lambda x: 1 <= x <= 4)
        if len(fixed) > 2 or (len(fixed) == 2 and not (1 <= fixed[1] <= 4)):
            raise Exception(f"invalid fixed sizes {fixed} in {self}")
        sizes = (fixed + [1, 1])[:2] + dynsizes # See operand_sizes in decode.c.
        extraflags["size_fix1"] = sizes[0]
        extraflags["size_fix2"] = sizes[1] - 1

        for i, opkind in enumerate(self.operands):
            sz = self.OPKIND_SIZES[opkind.size] if opkind.size >= 0 else opkind.size
            if opkind.kind == "IMM":
                if imm_byte and sz not in [1] + dynsizes[:1]:
                    raise Exception(f"imm_byte with opsize {sz} in {self}")
                extraflags[f"imm_size"] = sz == 1 if imm_byte else sizes.index(sz)
            else:
                opname = ENCODING_OPORDER[self.encoding][i]
                extraflags[f"{opname}_size"] = sizes.index(sz)
                extraflags[f"{opname}_ty"] = self.OPKIND_REGTYS[opname, opkind.kind]

        # Miscellaneous Flags
        if "VSIB" in self.flags:        extraflags["vsib"] = 1
        if "BCST" in self.flags:        extraflags["evex_bcst"] = 1
        if "BCST16" in self.flags:      extraflags["evex_bcst16"] = 1
        if "MASK" in self.flags:        extraflags["evex_mask"] = 1
        if "SAE" in self.flags:         extraflags["evex_rc"] = 1
        if "ER" in self.flags:          extraflags["evex_rc"] = 3
        if modrm:                       extraflags["modrm"] = 1

        if "U66" not in self.flags and (ign66 or "I66" in self.flags):
            extraflags["ign66"] = 1

        enc = flags._replace(**extraflags)._encode()
        enc = tuple((enc >> i) & 0xffff for i in range(0, 48, 16))
        # First 2 bytes are the mnemonic, last 6 bytes are the encoding.
        return f"{{FDI_{mnem}, {enc[0]}, {enc[1]}, {enc[2]}}}"

class EntryKind(Enum):
    NONE = 0x00
    PREFIX = 0x10
    INSTR = 0x20
    WEAKINSTR = 0x30
    TABLE16 = 0x01
    TABLE8E = 0x11
    ESCAPE = 0x02
    TABLE256 = 0x12
    TABLE_VEX = 0x22
    TABLE_PREFIX = 0x03
    TABLE_ROOT = -1
    @property
    def is_table(self):
        return self != EntryKind.INSTR and self != EntryKind.WEAKINSTR and self != EntryKind.PREFIX

opcode_regex = re.compile(
     r"^(?:(?P<prefixes>(?P<vex>E?VEX\.)?(?P<legacy>NP|66|F2|F3|NFx)\." +
                     r"(?:W(?P<rexw>[01])\.)?(?:L(?P<vexl>0|1|12|2|IG)\.)?))?" +
     r"(?P<escape>0f38|0f3a|0f|M[567]\.|)" +
     r"(?P<opcode>[0-9a-f]{2})" +
     r"(?:/(?P<modreg>[0-7]|[rm][0-7]?|[0-7][rm])|(?P<opcext>[c-f][0-9a-f]))?(?P<extended>\+)?$")

class Opcode(NamedTuple):
    prefix: Union[None, str] # None/NP/66/F2/F3/NFx
    escape: int # [0, 0f, 0f38, 0f3a]
    opc: int
    extended: bool # Extend opc or opcext in ModRM.rm, if present
    # Fixed ModRM.mod ("r"/"m"), ModRM.reg, ModRM.rm (opcext + AMX)
    modrm: Tuple[Union[None, str], Union[None, int], Union[None, int]]
    vex: int # 0 = legacy, 1 = VEX, 2 = EVEX
    vexl: Union[str, None] # 0, 1, 12, 2, IG, None = used, both
    rexw: Union[str, None] # 0, 1, None = both (or ignored)

    @classmethod
    def parse(cls, opcode_string):
        match = opcode_regex.match(opcode_string)
        if match is None:
            raise Exception(opcode_string)
            return None

        opcext = int(match.group("opcext") or "0", 16)
        modreg = match.group("modreg")
        if opcext:
            modrm = "r", (opcext >> 3) & 7, opcext & 7
        elif modreg:
            if modreg[0] in "rm":
                modrm = modreg[0], None, int(modreg[1:]) if modreg[1:] else None
            else:
                modrm = modreg[1:] or None, int(modreg[0]), None
        else:
            modrm = None, None, None

        return cls(
            prefix=match.group("legacy"),
            escape=["", "0f", "0f38", "0f3a", "M4.", "M5.", "M6.", "M7."].index(match.group("escape")),
            opc=int(match.group("opcode"), 16),
            extended=match.group("extended") is not None,
            modrm=modrm,
            vex=[None, "VEX.", "EVEX."].index(match.group("vex")),
            vexl=match.group("vexl"),
            rexw=match.group("rexw"),
        )

def verifyOpcodeDesc(opcode, desc):
    flags = ENCODINGS[desc.encoding]
    oporder = ENCODING_OPORDER[desc.encoding]
    expected_immkinds = ["", "I", "O", "L", "IA", "", "J"][flags.imm_control]
    fixed_mod = opcode.modrm[0]
    if opcode.extended or desc.mnemonic in ("MOV_CR2G", "MOV_DR2G", "MOV_G2CR", "MOV_G2DR"):
        fixed_mod = "r"
    expected_modrmkinds = {None: "EQWFKT", "r": "RNUFKT", "m": "M"}[fixed_mod]
    # allow F and R for zeroreg, which we overlap with vexreg
    expected_vexkinds = "BHKT" if opcode.vex else "BHRF"
    for i, opkind in enumerate(desc.operands):
        if oporder[i] == "modrm" and opkind.regkind not in expected_modrmkinds:
            raise Exception(f"modrm operand-regkind mismatch {opcode}, {desc}")
        if oporder[i] == "modreg" and opkind.regkind not in "GPVSCDFKT":
            raise Exception(f"modreg operand-regkind mismatch {opcode}, {desc}")
        if oporder[i] == "vexreg" and opkind.regkind not in expected_vexkinds:
            raise Exception(f"vexreg operand-regkind mismatch {opcode}, {desc}")
        if oporder[i] == "imm" and opkind.regkind not in expected_immkinds:
            raise Exception(f"imm operand-regkind mismatch {opcode}, {desc}")
    if "INSTR_WIDTH" in desc.flags and len(desc.operands) > 3:
        raise Exception(f"+w with four operands {opcode}, {desc}")
    if opcode.escape == 2 and flags.imm_control != 0:
        raise Exception(f"0f38 has no immediate operand {opcode}, {desc}")
    if opcode.escape == 3 and desc.imm_size(4) != 1:
        raise Exception(f"0f3a must have immediate byte {opcode}, {desc}")
    if opcode.escape == 0 and opcode.prefix is not None:
        raise Exception(f"unescaped opcode has prefix {opcode}, {desc}")
    if opcode.escape == 0 and opcode.vexl is not None:
        raise Exception(f"unescaped opcode has L specifier {opcode}, {desc}")
    if opcode.escape == 0 and opcode.rexw is not None:
        raise Exception(f"unescaped opcode has W specifier {opcode}, {desc}")
    if opcode.escape == 0 and opcode.vex:
        raise Exception(f"VEX opcode without escape {opcode}, {desc}")
    if opcode.vex and opcode.extended:
        raise Exception(f"VEX/EVEX must not be extended {opcode}, {desc}")
    if opcode.vex and opcode.prefix not in ("NP", "66", "F2", "F3"):
        raise Exception(f"VEX/EVEX must have mandatory prefix {opcode}, {desc}")
    if opcode.vexl == "IG" and desc.dynsizes() - {OpKind.SZ_OP}:
        raise Exception(f"(E)VEX.LIG with dynamic vector size {opcode}, {desc}")
    if "VSIB" in desc.flags and opcode.modrm[0] != "m":
        raise Exception(f"VSIB for non-memory opcode {opcode}, {desc}")
    if opcode.vex == 2 and flags.vexreg_idx:
        # Checking this here allows to omit check for V' in decoder.
        if desc.operands[flags.vexreg_idx ^ 3].kind != "XMM":
            raise Exception(f"EVEX.vvvv must refer to XMM {opcode}, {desc}")
    if opcode.vex == 2 and flags.modreg_idx and flags.modreg_idx ^ 3 != 0:
        # EVEX.z=0 is only checked for mask operands in ModReg
        if desc.operands[flags.modreg_idx ^ 3].kind == "MASK":
            raise Exception(f"ModRM.reg mask not first operand {opcode}, {desc}")
    # Verify tuple type
    if opcode.vex == 2 and opcode.modrm[0] != "r":
        tts = [s for s in desc.flags if s.startswith("TUPLE")]
        if len(tts) != 1:
            raise Exception(f"missing tuple type in {opcode}, {desc}")
        if flags.modrm_idx == 3 ^ 3:
            raise Exception(f"missing memory operand {opcode}, {desc}")
        # From Intel SDM
        bcst, evexw, vszs = {
            "TUPLE_FULL_16":      (2,    "0",  (  16,   32,   64)),
            "TUPLE_FULL_32":      (4,    "0",  (  16,   32,   64)),
            "TUPLE_FULL_64":      (8,    "1",  (  16,   32,   64)),
            "TUPLE_HALF_16":      (2,    "0",  (   8,   16,   32)),
            "TUPLE_HALF_32":      (4,    "0",  (   8,   16,   32)),
            "TUPLE_HALF_64":      (8,    "1",  (   8,   16,   32)),
            "TUPLE_QUARTER_16":   (2,    "0",  (   4,    8,   16)),
            "TUPLE_FULL_MEM":     (None, None, (  16,   32,   64)),
            "TUPLE_HALF_MEM":     (None, None, (   8,   16,   32)),
            "TUPLE_QUARTER_MEM":  (None, None, (   4,    8,   16)),
            "TUPLE_EIGHTH_MEM":   (None, None, (   2,    4,    8)),
            "TUPLE1_SCALAR_8":    (None, None, (   1,    1,    1)),
            "TUPLE1_SCALAR_16":   (None, None, (   2,    2,    2)),
            "TUPLE1_SCALAR_32":   (None, "0",  (   4,    4,    4)),
            "TUPLE1_SCALAR_64":   (None, "1",  (   8,    8,    8)),
            "TUPLE1_SCALAR_OPSZ": (None, None, (   0,    0,    0)),
            "TUPLE1_FIXED_32":    (None, None, (   4,    4,    4)),
            "TUPLE1_FIXED_64":    (None, None, (   8,    8,    8)),
            "TUPLE2_32":          (None, "0",  (   8,    8,    8)),
            "TUPLE2_64":          (None, "1",  (None,   16,   16)),
            "TUPLE4_32":          (None, "0",  (None,   16,   16)),
            "TUPLE4_64":          (None, "1",  (None, None,   32)),
            "TUPLE8_32":          (None, "0",  (None, None,   32)),
            "TUPLE_MEM128":       (None, None, (  16,   16,   16)),
            # TODO: Fix MOVDDUP tuple size :(
            "TUPLE_MOVDDUP":      (None, None, (  16,   32,   64)),
        }[tts[0]]
        if "BCST" in desc.flags:
            if bcst is None:
                raise Exception(f"broadcast on incompatible type {opcode}, {desc}")
            if ("BCST16" in desc.flags) != (bcst == 2):
                raise Exception(f"bcst16 mismatch, should be {bcst} {opcode}, {desc}")
        # EVEX.W is used to distinguish 4/8-byte broadcast size
        if evexw and opcode.rexw != evexw:
            raise Exception(f"incompatible EVEX.W {opcode}, {desc}")
        for l, tupsz in enumerate(vszs):
            opsz = desc.operands[flags.modrm_idx ^ 3].abssize(0, 16 << l)
            if tupsz is not None and opsz != tupsz:
                raise Exception(f"memory size {opsz} != {tupsz} {opcode}, {desc}")

class Trie:
    KIND_ORDER = (EntryKind.TABLE_ROOT, EntryKind.ESCAPE, EntryKind.TABLE256,
                  EntryKind.TABLE_PREFIX, EntryKind.TABLE16,
                  EntryKind.TABLE8E, EntryKind.TABLE_VEX)
    TABLE_LENGTH = {
        EntryKind.TABLE_ROOT: 256,
        EntryKind.ESCAPE: 8,
        EntryKind.TABLE256: 256,
        EntryKind.TABLE_PREFIX: 4,
        EntryKind.TABLE16: 16,
        EntryKind.TABLE8E: 8,
        EntryKind.TABLE_VEX: 8,
    }

    def __init__(self, root_count):
        self.trie = []
        self.trie.append([None] * root_count)
        self.kindmap = defaultdict(list)

    def _add_table(self, kind):
        self.trie.append([None] * self.TABLE_LENGTH[kind])
        self.kindmap[kind].append(len(self.trie) - 1)
        return len(self.trie) - 1

    def _clone(self, elem):
        if not elem or not elem[0].is_table:
            return elem
        new_num = self._add_table(elem[0])
        self.trie[new_num] = [self._clone(e) for e in self.trie[elem[1]]]
        return elem[0], new_num

    def _transform_opcode(self, opc):
        realopcext = opc.extended and opc.modrm[2] is None
        topc = [opc.opc + i for i in range(8 if realopcext else 1)]
        if opc.escape == 0 and opc.opc in (0xc4, 0xc5, 0x62):
            assert opc.prefix is None
            assert opc.modrm == ("m", None, None)
            assert opc.rexw is None
            assert opc.vexl is None
            # We do NOT encode /m, this is handled by prefix code.
            # Order must match KIND_ORDER.
            return topc, [0], None, None, None, None, None
        elif opc.escape == 0:
            troot, tescape, topc = topc, None, None
        else:
            troot = [[0x0f], [0xc4, 0xc5], [0x62]][opc.vex]
            tescape = [opc.escape]

        tprefix, t16, t8e, tvex = None, None, None, None
        if opc.prefix == "NFx":
            tprefix = [0, 1]
        elif opc.prefix:
            tprefix = [["NP", "66", "F3", "F2"].index(opc.prefix)]
        if opc.modrm != (None, None, None):
            # TODO: optimize for /r and /m specifiers to reduce size
            mod = {"m": [0], "r": [1], None: [0, 1]}[opc.modrm[0]]
            reg = [opc.modrm[1]] if opc.modrm[1] is not None else list(range(8))
            t16 = [x + (y << 1) for x in mod for y in reg]
            if opc.modrm[2] is not None and not opc.extended:
                t8e = [opc.modrm[2]]
        if opc.rexw is not None or (opc.vexl or "IG") != "IG":
            rexw = {"0": [0], "1": [1<<0], None: [0, 1<<0]}[opc.rexw]
            if opc.vex < 2:
                vexl = {"0": [0], "1": [1<<1], "IG": [0, 1<<1]}[opc.vexl or "IG"]
            else:
                vexl = {"0": [0], "12": [1<<1, 2<<1], "2": [2<<1], "IG": [0, 1<<1, 2<<1, 3<<1]}[opc.vexl or "IG"]
            tvex = list(map(sum, product(rexw, vexl)))
        # Order must match KIND_ORDER.
        return troot, tescape, topc, tprefix, t16, t8e, tvex

    def add_opcode(self, opcode, descidx, root_idx, weak=False):
        opcode = self._transform_opcode(opcode)
        frontier = [(0, root_idx)]
        for elem_kind, elem in zip(self.KIND_ORDER, opcode):
            new_frontier = []
            for entry_num, entry_idx in frontier:
                entry = self.trie[entry_num]
                if elem is None:
                    if entry[entry_idx] is None or entry[entry_idx][0] != elem_kind:
                        new_frontier.append((entry_num, entry_idx))
                        continue
                    elem = list(range(self.TABLE_LENGTH[elem_kind]))
                if entry[entry_idx] is None:
                    new_num = self._add_table(elem_kind)
                    entry[entry_idx] = elem_kind, new_num
                elif entry[entry_idx][0] != elem_kind:
                    # Need to add a new node here and copy entry one level below
                    new_num = self._add_table(elem_kind)
                    # Keep original entry, but clone others recursively
                    self.trie[new_num][0] = entry[entry_idx]
                    for i in range(1, len(self.trie[new_num])):
                        self.trie[new_num][i] = self._clone(entry[entry_idx])
                    entry[entry_idx] = elem_kind, new_num
                for elem_idx in elem:
                    new_frontier.append((entry[entry_idx][1], elem_idx))
            frontier = new_frontier
        for entry_num, entry_idx in frontier:
            entry = self.trie[entry_num]
            if not entry[entry_idx] or entry[entry_idx][0] == EntryKind.WEAKINSTR:
                kind = EntryKind.INSTR if not weak else EntryKind.WEAKINSTR
                entry[entry_idx] = kind, descidx << 2
            elif not weak:
                raise Exception(f"redundant non-weak {opcode}")

    def add_prefix(self, byte, prefix, root_idx):
        if self.trie[0][root_idx] is None:
            self.trie[0][root_idx] = EntryKind.TABLE_ROOT, self._add_table(EntryKind.TABLE_ROOT)
        self.trie[self.trie[0][root_idx][1]][byte] = EntryKind.PREFIX, prefix

    def deduplicate(self):
        synonyms = {}
        for kind in self.KIND_ORDER[::-1]:
            entries = {}
            for num in self.kindmap[kind]:
                # Replace previous synonyms
                entry = self.trie[num]
                for i, elem in enumerate(entry):
                    if elem and elem[0].is_table and elem[1] in synonyms:
                        entry[i] = synonyms[elem[1]]

                unique_entry = tuple(entry)
                if len(set(unique_entry)) == 1:
                    # Omit kind if all entries point to the same child
                    synonyms[num] = entry[0]
                    self.trie[num] = None
                elif unique_entry in entries:
                    # Deduplicate entries of this kind
                    synonyms[num] = kind, entries[unique_entry]
                    self.trie[num] = None
                else:
                    entries[unique_entry] = num

    def compile(self):
        offsets = [None] * len(self.trie)
        last_off = 0
        for num, entry in enumerate(self.trie[1:], start=1):
            if not entry:
                continue
            offsets[num] = last_off
            last_off += (len(entry) + 3) & ~3
        if last_off >= 0x8000:
            raise Exception(f"maximum table size exceeded: {last_off:#x}")

        data = [0] * last_off
        for off, entry in zip(offsets, self.trie):
            if off is None:
                continue
            for i, elem in enumerate(entry, start=off):
                if elem is not None:
                    value = offsets[elem[1]] if elem[0].is_table else elem[1]
                    data[i] = value | (elem[0].value & 3)
        return tuple(data), [offsets[v] for _, v in self.trie[0]]

    @property
    def stats(self):
        return {k.name: sum(self.trie[e] is not None for e in v)
                for k, v in self.kindmap.items()}


def superstring(strs):
    # This faces the "shortest superstring" problem, which is NP-hard.
    # Preprocessing: remove any strings which are already completely covered
    realstrs = []
    for s in sorted(strs, key=len, reverse=True):
        for s2 in realstrs:
            if s in s2:
                break
        else:
            realstrs.append(s)

    # Greedy heuristic generally yields acceptable results, though it depends on
    # the order of the menmonics. More compact results are possible, but the
    # expectable gains of an optimal result (probably with O(n!)) are small.
    # First sort strings and later do a binary search for each possible prefix.
    realstrs.sort()
    merged = ""
    while realstrs:
        for i in range(min(16, len(merged)), 0, -1):
            idx = bisect.bisect_left(realstrs, merged[-i:])
            if idx < len(realstrs) and realstrs[idx][:i] == merged[-i:]:
                merged += realstrs.pop(idx)[i:]
                break
        else:
            merged += realstrs.pop()
    return merged

def decode_table(entries, args):
    modes = args.modes

    trie = Trie(root_count=len(modes))
    for i, mode in enumerate(modes):
        # Magic values must match PF_* enum in decode.c.
        trie.add_prefix(0x66, 0xfffa, i)
        trie.add_prefix(0x67, 0xfffb, i)
        trie.add_prefix(0xf0, 0xfffc, i)
        trie.add_prefix(0xf2, 0xfffd, i)
        trie.add_prefix(0xf3, 0xfffd, i)
        trie.add_prefix(0x64, 0xfff9, i)
        trie.add_prefix(0x65, 0xfff9, i)
        for seg in (0x26, 0x2e, 0x36, 0x3e):
            trie.add_prefix(seg, 0xfff8 + (mode <= 32), i)
        if mode > 32:
            for rex in range(0x40, 0x50):
                trie.add_prefix(rex, 0xfffe, i)

    # pause is hardcoded together with XCHG_NOP.
    mnems, descs, desc_map = {"PAUSE"}, [], {}
    descs.append("{0}") # desc index zero is "invalid"
    for weak, opcode, desc in entries:
        ign66 = opcode.prefix in ("NP", "66", "F2", "F3")
        modrm = opcode.modrm != (None, None, None)
        mnem = {
            "PUSH_SEG": "PUSH", "POP_SEG": "POP",
            "MOV_CR2G": "MOV_CR", "MOV_G2CR": "MOV_CR",
            "MOV_DR2G": "MOV_DR", "MOV_G2DR": "MOV_DR",
            "MMX_MOVD_M2G": "MMX_MOVD", "MMX_MOVD_G2M": "MMX_MOVD",
            "MMX_MOVQ_M2G": "MMX_MOVQ", "MMX_MOVQ_G2M": "MMX_MOVQ",
            "SSE_MOVD_X2G": "SSE_MOVD", "SSE_MOVD_G2X": "SSE_MOVD",
            "SSE_MOVQ_X2G": "SSE_MOVQ", "SSE_MOVQ_G2X": "SSE_MOVQ",
            "VMOVD_X2G": "VMOVD", "VMOVD_G2X": "VMOVD",
            "VMOVQ_X2G": "VMOVQ", "VMOVQ_G2X": "VMOVQ",
        }.get(desc.mnemonic, desc.mnemonic)
        mnems.add(mnem)
        descenc = desc.encode(mnem, ign66, modrm)
        desc_idx = desc_map.get(descenc)
        if desc_idx is None:
            desc_idx = desc_map[descenc] = len(descs)
            descs.append(descenc)
        for i, mode in enumerate(modes):
            if "IO"[mode <= 32]+"64" not in desc.flags:
                trie.add_opcode(opcode, desc_idx, i, weak)

    trie.deduplicate()
    table_data, root_offsets = trie.compile()

    mnems = sorted(mnems)
    decode_mnems_lines = [f"FD_MNEMONIC({m},{i})\n" for i, m in enumerate(mnems)]

    mnemonics_intel = [m.replace("SSE_", "").replace("MMX_", "")
                        .replace("EVX_", "V")
                        .replace("MOVABS", "MOV").replace("RESERVED_", "")
                        .replace("JMPF", "JMP FAR").replace("CALLF", "CALL FAR")
                        .replace("_S2G", "").replace("_G2S", "")
                        .replace("_X2G", "").replace("_G2X", "")
                        .replace("_CR", "").replace("_DR", "")
                        .replace("REP_", "REP ").replace("CMPXCHGD", "CMPXCHG")
                        .replace("JCXZ", "JCXZ JECXZJRCXZ")
                        .replace("C_SEP", "CWD CDQ CQO")
                        .replace("C_EX", "CBW CWDECDQE").replace("XCHG_NOP", "")
                        .lower() for m in mnems]
    mnemonics_str = superstring(mnemonics_intel)

    if args.stats:
        print(f"Decode stats: Descs -- {len(descs)} ({8*len(descs)} bytes); ",
              f"Trie -- {2*len(table_data)} bytes, {trie.stats}; "
              f"Mnems -- {len(mnemonics_str)} + {3*len(mnemonics_intel)} bytes")

    defines = ["FD_TABLE_OFFSET_%d %d\n"%k for k in zip(modes, root_offsets)]

    return "".join(decode_mnems_lines), f"""// Auto-generated file -- do not modify!
#if defined(FD_DECODE_TABLE_DATA)
{"".join(f"{e:#06x}," for e in table_data)}
#elif defined(FD_DECODE_TABLE_DESCS)
{",".join(descs)}
#elif defined(FD_DECODE_TABLE_STRTAB1)
"{mnemonics_str}"
#elif defined(FD_DECODE_TABLE_STRTAB2)
{",".join(str(mnemonics_str.index(mnem)) for mnem in mnemonics_intel)}
#elif defined(FD_DECODE_TABLE_STRTAB3)
{",".join(str(len(mnem)) for mnem in mnemonics_intel)}
#elif defined(FD_DECODE_TABLE_DEFINES)
{"".join("#define " + line for line in defines)}
#else
#error "unspecified decode table"
#endif
"""

class EncodeVariant(NamedTuple):
    opcode: Opcode
    desc: InstrDesc
    evexbcst: bool = False
    evexmask: int = 0 # 0 = none, 1 = must have mask, 2 = mask + EVEX.z
    evexsae: int = 0 # 0 = no EVEX.b, 1 = EVEX.b, 2 = EVEX.b + L'L is rounding mode
    evexdisp8scale: int = 0 # EVEX disp8 shift
    downgrade: int = 0 # 0 = none, 1 = to VEX, 2 = to VEX flipping REXW
    flexcc: bool = False # Flexible condition code

def encode_mnems(entries):
    # mapping from (mnem, opsize, ots) -> (opcode, desc)
    mnemonics = defaultdict(list)
    # Cannot have PAUSE in instrs.txt, because opcodes in without escape must
    # not have mandatory prefixes. For decode, this is hardcoded.
    mnemonics["PAUSE", 0, ""] = [EncodeVariant(Opcode.parse("F3.90"), InstrDesc.parse("NP - - - - NOP"))]
    for weak, opcode, desc in entries:
        if "I64" in desc.flags or desc.mnemonic[:9] == "RESERVED_":
            continue
        mnem_name = {"MOVABS": "MOV", "XCHG_NOP": "XCHG"}.get(desc.mnemonic, desc.mnemonic)
        mnem_name = mnem_name.replace("EVX_", "V")

        opsizes, vecsizes = {0}, {0}
        prepend_opsize, prepend_vecsize = False, False
        # Where to put the operand size in the mnemonic
        separate_opsize = "ENC_SEPSZ" in desc.flags

        if "ENC_NOSZ" in desc.flags or not desc.dynsizes():
            pass
        elif OpKind.SZ_OP in desc.dynsizes():
            if opcode.rexw is not None:
                raise Exception(f"unexpected REXW specifier {desc}")
            opsizes = {8} if "SZ8" in desc.flags else {16, 32, 64}
            if opcode.prefix in ("NP", "66", "F2", "F3") and "U66" not in desc.flags:
                opsizes -= {16}
            if "I66" in desc.flags:
                opsizes -= {16}
            if "D64" in desc.flags:
                opsizes -= {32}
            prepend_opsize = not separate_opsize
            if "F64" in desc.flags:
                opsizes = {64}
                prepend_opsize = False
        elif opcode.vex and opcode.vexl != "IG": # vectors; don't care for SSE
            vecsizes = {128, 256, 512} if opcode.vex == 2 else {128, 256}
            if opcode.vexl:
                vecsizes = {128 << int(c) for c in opcode.vexl}
            prepend_vecsize = not separate_opsize

        # All encoding types; reg is r/k (mask); modrm is r/m/b (broadcast)
        optypes_base = []
        for i, opkind in enumerate(desc.operands):
            reg = "k" if opkind.kind == "MASK" else "r"
            opname = ENCODING_OPORDER[desc.encoding][i]
            if opname == "modrm":
                modrm_type = (opcode.modrm[0] or "rm").replace("r", reg)
                if opcode.extended or desc.mnemonic in ("MOV_CR2G", "MOV_DR2G", "MOV_G2CR", "MOV_G2DR"):
                    modrm_type = reg
                if "BCST" in desc.flags:
                    modrm_type += "b"
                optypes_base.append(modrm_type)
            elif opname == "modreg" or opname == "vexreg":
                optypes_base.append(reg)
            else:
                optypes_base.append(" iariioo"[ENCODINGS[desc.encoding].imm_control])
        optypes = ["".join(x) for x in product(*optypes_base)]

        prefixes = [("", "")]
        if "LOCK" in desc.flags:
            prefixes.append(("LOCK_", "LOCK"))
        if "ENC_REP" in desc.flags:
            prefixes.append(("REP_", "F3"))
        if "ENC_REPCC" in desc.flags:
            prefixes.append(("REPNZ_", "F2"))
            prefixes.append(("REPZ_", "F3"))

        evexmasks = [0]
        if "MASK" in desc.flags:
            if "VSIB" in desc.flags:
                evexmasks = [1]
            else:
                evexmasks.append(1)
                if desc.operands[0].kind != "MASK":
                    evexmasks.append(2) # maskz only for non-mask destinations
        evexsaes = [0]
        if "SAE" in desc.flags:
            evexsaes.append(1)
        elif "ER" in desc.flags:
            evexsaes.append(2)

        keys = (opsizes, vecsizes, prefixes, optypes, evexmasks, evexsaes)
        for opsize, vecsize, prefix, ots, evexmask, evexsae in product(*keys):
            has_memory = "m" in ots or "b" in ots
            if prefix[1] == "LOCK" and ots[0] != "m":
                continue
            if evexmask == 2 and ots[0] != "r":
                continue # EVEX.z must be zero for memory destination
            if evexsae and (vecsize not in (0, 512) or has_memory):
                continue # SAE/ER only works with 512 bit width and no memory

            spec_opcode = opcode
            if prefix[1]:
                spec_opcode = spec_opcode._replace(prefix=prefix[1])
            if opsize == 64 and "D64" not in desc.flags and "F64" not in desc.flags:
                spec_opcode = spec_opcode._replace(rexw="1")
            if vecsize == 512:
                spec_opcode = spec_opcode._replace(vexl="2")
            if vecsize == 256:
                spec_opcode = spec_opcode._replace(vexl="1")
            if vecsize == 128:
                spec_opcode = spec_opcode._replace(vexl="0")
            if spec_opcode.vexl == "IG":
                spec_opcode = spec_opcode._replace(vexl="0")
            if ENCODINGS[desc.encoding].modrm_idx:
                modrm = ("m" if has_memory else "r",) + spec_opcode.modrm[1:]
                spec_opcode = spec_opcode._replace(modrm=modrm)
            if ENCODINGS[desc.encoding].modrm or None not in opcode.modrm:
                assert spec_opcode.modrm[0] in ("r", "m")

            evexbcst = "b" in ots
            evexdisp8scale = 0
            if spec_opcode.vex == 2 and has_memory:
                if not evexbcst:
                    op = desc.operands[ENCODINGS[desc.encoding].modrm_idx^3]
                    size = op.abssize(opsize//8, vecsize//8)
                    evexdisp8scale = size.bit_length() - 1
                elif "BCST16" in desc.flags:
                    evexdisp8scale = 1
                else:
                    evexdisp8scale = 2 if spec_opcode.rexw != "1" else 3

            # Construct mnemonic name
            name = prefix[0] + mnem_name

            # Transform MOV_G2X/X2G into MOVD/MOVQ_G2X/X2G. This isn't done for
            # VEX for historical reasons and there's no reason to break
            # backwards compatibility. This enables EVEX->VEX fallback.
            if desc.mnemonic in ("EVX_MOV_G2X", "EVX_MOV_X2G"):
                name = name[:-4] + "DQ"[opsize == 64] + name[-4:]
                prepend_opsize, opsize = False, 0
            # For VMOVD with memory operand, there's no need to be explicit
            # about G2X/X2G, as there's no alternative. For VMOVQ, another
            # opcode exists, so keep G2X/X2G there for distinguishing.
            if name in ("VMOVD_G2X", "VMOVD_X2G") and has_memory:
                name = name.replace("_G2X", "").replace("_X2G", "")
            # PEXTR/PBROADCAST/PINSR are stored without size suffix in the table
            # to avoid having different tables for 32/64 bit mode due to EVEX.W
            # being ignored in 32-bit mode. Add suffix here.
            if desc.mnemonic == "EVX_PEXTR":
                name += " BW D   Q"[desc.operands[0].abssize(opsize//8, vecsize//8)]
                prepend_opsize, opsize = False, 0
            if desc.mnemonic == "EVX_PBROADCAST":
                name += " BW D   Q"[desc.operands[1].abssize(opsize//8, vecsize//8)]
                name += "_GP"
                prepend_opsize, opsize = False, 0
            if desc.mnemonic == "EVX_PINSR":
                name += " BW D   Q"[desc.operands[2].abssize(opsize//8, vecsize//8)]
                prepend_opsize, opsize = False, 0

            if prepend_opsize and not ("D64" in desc.flags and opsize == 64):
                name += f"_{opsize}"[name[-1] not in "0123456789":]
            if prepend_vecsize:
                name += f"_{vecsize}"[name[-1] not in "0123456789":]
            for ot, op in zip(ots, desc.operands):
                name += ot.replace("o", "")
                if separate_opsize:
                    name += f"{op.abssize(opsize//8, vecsize//8)*8}"
            if "VSIB" not in desc.flags:
                # VSIB implies non-zero mask register, so suffix is not required
                name += ["", "_mask", "_maskz"][evexmask]
            name += ["", "_sae", "_er"][evexsae]
            variant = EncodeVariant(spec_opcode, desc, evexbcst, evexmask, evexsae, evexdisp8scale)
            mnemonics[name, opsize, ots].append(variant)
            altname = {
                "C_EX16": "CBW", "C_EX32": "CWDE", "C_EX64": "CDQE",
                "C_SEP16": "CWD", "C_SEP32": "CDQ", "C_SEP64": "CQO",
                "CMPXCHGD32m": "CMPXCHG8Bm", "CMPXCHGD64m": "CMPXCHG16Bm",
            }.get(name)
            if altname:
                mnemonics[altname, opsize, ots].append(variant)
            if "ENC_CC_BEGIN" in desc.flags:
                # Replace last "O" with "cc"
                ccname = "cc".join(name.rsplit("O", 1))
                ccvariant = variant._replace(flexcc=True)
                mnemonics[ccname, opsize, ots].append(ccvariant)

    for (mnem, opsize, ots), all_variants in mnemonics.items():
        dedup = OrderedDict()
        for i, variant in enumerate(all_variants):
            PRIO = ["O", "OA", "AO", "AM", "MA", "IA", "OI"]
            enc_prio = PRIO.index(variant.desc.encoding) if variant.desc.encoding in PRIO else len(PRIO)
            unique = 0 if variant.desc.encoding != "S" else i
            # Prefer VEX over EVEX for shorter encoding
            key = variant.desc.imm_size(opsize//8), variant.opcode.vex, enc_prio, unique
            if key not in dedup:
                dedup[key] = variant
        variants = [dedup[k] for k in sorted(dedup.keys())]
        if len(variants) > 1 and any(v.opcode.vex for v in variants):
            # Case 1: VEX -> EVEX promotion (AVX-512, APX)
            # Case 2: legacy -> EVEX promotion (APX)
            # In any case, there should be exactly one EVEX opcode.
            if len(variants) != 2:
                raise Exception(f"VEX/EVEX mnemonic with more than two encodings {mnem} {opcode}")
            if variants[0].opcode.vex == 2 or variants[1].opcode.vex != 2:
                raise Exception(f"EVEX mnemonic not with non-EVEX pair {mnem} {opcode} {variants}")
            no_evex, evex = variants[0], variants[1]

            # Make sure that for promotions, only minor things vary.
            # REX.W is special, EVEX might mandate W1 while VEX mandates W0/WIG.
            # Technically ok: IG -> IG/IG -> 0/0 -> IG/0 -> 0/1 -> IG/1 -> 1
            # rexwdowngrade = (no_evex.opcode.rexw is None or
            #                  no_evex.opcode.rexw == evex.opcode.rexw)
            #
            # However, other encoders always use W0 in case of WIG for VEX, and
            # that's probably most beneficial... so:
            # Possible downgrades: IG -> IG/IG -> 0/0 -> IG/0 -> 0/1 -> 1
            # This affects quite a few instructions, so we use an extra bit to
            # flip EVEX.W to VEX.W.

            if (no_evex.opcode.prefix != evex.opcode.prefix or
                no_evex.opcode.escape != evex.opcode.escape or
                no_evex.opcode.opc != evex.opcode.opc or
                # reg/mem doesn't matter, it's already fixed in the mnemonic
                no_evex.opcode.modrm[1:] != evex.opcode.modrm[1:] or
                no_evex.opcode.vexl != evex.opcode.vexl or
                # we don't check rexw_flip here, we can always handle it
                no_evex.desc.encoding != evex.desc.encoding or
                no_evex.desc.operands != evex.desc.operands):
                print(mnem, no_evex)
                print(mnem, evex)
                # Should not happen.
                raise Exception("cannot downgrade EVEX?")
            else:
                rexw_flip = (no_evex.opcode.rexw == "1") != (evex.opcode.rexw == "1")
                variants = [evex._replace(downgrade=1 if not rexw_flip else 2)]
        mnemonics[mnem, opsize, ots] = variants

    return dict(mnemonics)

def encode_table(entries, args):
    mnemonics = encode_mnems(entries)
    mnemonics["NOP", 0, ""] = [EncodeVariant(Opcode.parse("90"), InstrDesc.parse("NP - - - - NOP"))]
    mnem_map = {}
    alt_table = [0] # first entry is unused
    for (mnem, opsize, ots), variants in mnemonics.items():
        supports_high_regs = []
        if variants[0][1].mnemonic in ("MOVSX", "MOVZX") or opsize == 8:
            # Should be the same for all variants
            desc = variants[0][1]
            for i, (ot, op) in enumerate(zip(ots, desc.operands)):
                if ot == "r" and op.kind == "GP" and op.abssize(opsize//8) == 1:
                    supports_high_regs.append(i)

        alt_indices = [i + len(alt_table) for i in range(len(variants) - 1)] + [0]

        if variants[0][1].encoding == "D":
            assert 1 <= len(variants) <= 2
            # We handle jump (jmp/jcc) alternatives in code to support Jcc.
            if len(variants) > 1:
                assert variants[0][1].mnemonic[:1] == "J"
                variants = variants[:1]
                alt_indices = [0xff]

        enc_opcs = []
        for alt, variant in zip(alt_indices, variants):
            opcode, desc = variant.opcode, variant.desc
            encoding = ENCODINGS[desc.encoding]
            opc_i = opcode.opc
            if None not in opcode.modrm:
                opc_i |= 0xc000 | opcode.modrm[1] << 11 | opcode.modrm[2] << 8
            elif opcode.modrm[1] is not None:
                opc_i |= opcode.modrm[1] << 8
            if opcode.modrm == ("m", None, 4):
                opc_i |= 0x2000000000 # FORCE_SIB
            if not opcode.vex:
                assert opcode.escape < 4
                opc_i |= opcode.escape * 0x10000
                opc_i |= 0x80000 if opcode.prefix == "66" or opsize == 16 else 0
                opc_i |= 0x100000 if opcode.prefix == "F2" else 0
                opc_i |= 0x200000 if opcode.prefix == "F3" else 0
            else:
                assert opcode.escape < 8
                opc_i |= opcode.escape * 0x10000
                if opcode.prefix == "66" or opsize == 16:
                    assert opcode.prefix not in ("F2", "F3")
                    opc_i |= 0x100000
                if opcode.prefix == "F3":
                    opc_i |= 0x200000
                elif opcode.prefix == "F2":
                    opc_i |= 0x300000
            opc_i |= 0x400000 if opcode.rexw == "1" else 0
            if opcode.prefix == "LOCK":
                opc_i |= 0x800000
            elif opcode.vex == 1:
                opc_i |= 0x1000000 + 0x800000 * int(opcode.vexl or 0)
            elif opcode.vex == 2:
                opc_i |= 0x2000000
                # L'L encodes SAE rounding mode otherwise
                if not variant.evexsae:
                    opc_i |= 0x800000 * int(opcode.vexl or 0)
            assert not (variant.evexsae and variant.evexbcst)
            opc_i |= 0x4000000 if variant.evexsae or variant.evexbcst else 0
            opc_i |= 0x8000000 if "VSIB" in desc.flags else 0
            opc_i |= 0x1000000000 if variant.evexmask == 2 else 0
            opc_i |= 0x4000000000 if variant.downgrade in (1, 2) else 0
            opc_i |= 0x40000000000 if variant.downgrade == 2 else 0
            opc_i |= 0x8000000000 * variant.evexdisp8scale
            if alt >= 0x100:
                raise Exception("encode alternate bits exhausted")
            opc_i |= sum(1 << i for i in supports_high_regs) << 45
            if encoding.imm_control >= 3:
                opc_i |= desc.imm_size(opsize//8) << 47
            elif encoding.imm_control in (1, 2):
                # Must be an arbitrary non-zero value, replaced by address size
                # for imm_ctl=2 and zero for imm_ctl=1 (constant 1).
                opc_i |= 1 << 47

            enc_encoding = desc.encoding
            if desc.encoding != "I" and desc.encoding.endswith("I"):
                enc_encoding = desc.encoding[:-1]
            elif desc.encoding == "IA":
                enc_encoding = "A"
            opc_i |= ["NP", "M", "R", "M1", "MC", "MR", "RM", "RMA", "MRC",
                "AM", "MA", "I", "O", "OA", "S", "A", "D", "FD", "TD", "IM",
                "RVM", "RVMR", "RMV", "VM", "MVR", "MRV",
            ].index(enc_encoding) << 51
            opc_i |= alt << 56
            enc_opcs.append(opc_i)
        mnem_map[f"FE_{mnem}"] = enc_opcs[0]
        alt_table += enc_opcs[1:]

    mnem_tab = "".join(f"#define {m} {v:#x}\n" for m, v in mnem_map.items())
    alt_tab = "".join(f"[{i}] = {v:#x},\n" for i, v in enumerate(alt_table))
    return mnem_tab, alt_tab

def unique(it):
    vals = set(it)
    if len(vals) != 1:
        raise Exception(f"multiple values: {vals}")
    return next(iter(vals))

def encode2_gen_legacy(variant: EncodeVariant, opsize: int, supports_high_regs: list[int], imm_expr: str, imm_size_expr: str, has_idx: bool) -> str:
    opcode = variant.opcode
    desc = variant.desc
    flags = ENCODINGS[variant.desc.encoding]
    code = ""

    rex_expr = [] if opcode.rexw != "1" else ["0x48"]
    rex_values = set()
    for i in supports_high_regs:
        rex_expr.append(f"(op_reg_idx(op{i}) >= 4 && op_reg_idx(op{i}) <= 15?0x40:0)")
        rex_values.add(0x40)
    has_modreg_rex = False
    if flags.modreg_idx:
        has_modreg_rex = desc.operands[flags.modreg_idx^3].kind in ("GP", "XMM", "CR", "DR")
    if flags.modrm_idx:
        if opcode.modrm[0] == "m":
            rex_modreg_op = f"op_reg_idx(op{flags.modreg_idx^3})" if has_modreg_rex else "0"
            rex_expr.append(f"enc_rex_mem(op{flags.modrm_idx^3}, {rex_modreg_op})")
            rex_values |= {0x41, 0x42, 0x44}
        elif desc.operands[flags.modrm_idx^3].kind in ("GP", "XMM"):
            rex_expr.append(f"(op_reg_idx(op{flags.modrm_idx^3})&8?0x1:0)")
            rex_values.add(0x41)
            if has_modreg_rex:
                rex_expr.append(f"(op_reg_idx(op{flags.modreg_idx^3})&8?0x4:0)")
                rex_values.add(0x44)
    elif has_modreg_rex: # O encoding
        rex_expr.append(f"(op_reg_idx(op{flags.modreg_idx^3})&8?0x1:0)")
        rex_values.add(0x41)

    if rex_expr:
        code += f"  unsigned rex = {'|'.join(rex_expr) or '0'};\n"
    for i in supports_high_regs:
        code += f"  if (rex && op_reg_gph(op{i})) return 0;\n"

    if not has_idx:
        code += "  unsigned idx = 0;\n"
    if opcode.prefix == "LOCK":
        code += f"  buf[idx++] = 0xF0;\n"
    if opsize == 16 or opcode.prefix == "66":
        code += "  buf[idx++] = 0x66;\n"
    if opcode.prefix in ("F2", "F3"):
        code += f"  buf[idx++] = 0x{opcode.prefix};\n"
    if opcode.rexw == "1":
        code += f"  buf[idx++] = rex;\n"
    elif len(rex_values) == 1:
        code += f"  buf[idx] = {next(iter(rex_values))};\n  idx += rex != 0;\n"
    elif len(rex_values) == 2:
        code += f"  buf[idx] = 0x40|rex;\n  idx += rex != 0;\n"
    elif rex_expr: # memory, multiplication is expensive
        code += f"  if (rex) buf[idx++] = 0x40|rex;\n"
    if opcode.escape:
        code += f"  buf[idx++] = 0x0F;\n"
        if opcode.escape == 2:
            code += f"  buf[idx++] = 0x38;\n"
        elif opcode.escape == 3:
            code += f"  buf[idx++] = 0x3A;\n"
    opcodestr = f"{opcode.opc:#x}" + ("|(flags>>16)" if variant.flexcc else "")
    code += f"  buf[idx++] = {opcodestr};\n"
    if None not in opcode.modrm:
        opcext = 0xc0 | opcode.modrm[1] << 3 | opcode.modrm[2]
        code += f"  buf[idx++] = {opcext:#x};\n"

    if flags.modrm:
        if flags.modreg_idx:
            modreg = f"op_reg_idx(op{flags.modreg_idx^3})"
        else:
            modreg = opcode.modrm[1] or 0
        if opcode.modrm[0] == "m":
            assert "VSIB" not in desc.flags
            assert opcode.modrm[2] is None
            modrm = f"op{flags.modrm_idx^3}"
            code += f"  idx = enc_mem(buf+idx, idx+{imm_size_expr}, {modrm}, {modreg}, 0, 0);\n"
            code += f"  if (!idx) return 0;\n  idx -= {imm_size_expr};\n"
        else:
            if flags.modrm_idx:
                modrm = f"op_reg_idx(op{flags.modrm_idx^3})"
            else:
                modrm = f"{opcode.modrm[2] or 0}"
            code += f"  buf[idx++] = 0xC0|({modreg}<<3)|({modrm}&7);\n"
    elif flags.modrm_idx:
        code += f"  buf[idx-1] |= op_reg_idx(op{flags.modrm_idx^3}) & 7;\n"
    if flags.imm_control >= 2:
        if flags.imm_control == 6:
            imm_expr += " - idx"
        code += f"  enc_imm(buf+idx, {imm_expr}, {imm_size_expr});\n"
        code += f"  return idx + {imm_size_expr};\n"
    else:
        code += f"  return idx;\n"
    return code

def encode2_gen_vex(variant: EncodeVariant, imm_expr: str, imm_size_expr: str, has_idx: bool) -> str:
    opcode = variant.opcode
    flags = ENCODINGS[variant.desc.encoding]
    code = ""

    helperopc = opcode.opc << 16
    helperopc |= ["NP", "66", "F3", "F2"].index(opcode.prefix) << 8
    helperopc |= 0x8000 if opcode.rexw == "1" else 0
    if not variant.evexsae:
        # ER: L'L encodes rounding mode for SAE
        helperopc |= 0x0020 * int(opcode.vexl or 0) # EVEX.L'L
    helperopc |= opcode.escape << 10
    helperopc |= 0x10 if variant.evexsae or variant.evexbcst else 0 # EVEX.b
    helperopc |= 0x80 if variant.evexmask == 2 else 0 # EVEX.z
    helperopc |= 0x1000000 if variant.downgrade in (1, 2) else 0
    helperopc |= 0x2000000 if variant.downgrade == 2 else 0
    helperopc = f"{helperopc:#x}"
    if variant.flexcc:
        helperopc += "|(flags&FE_CC_MASK)"
    if variant.evexsae == 2:
        helperopc += "|(flags&FE_RC_MASK)"
    if variant.evexmask:
        code += "  if (!op_reg_idx(opmask)) return 0;\n"
        helperopc += "|(op_reg_idx(opmask)&7)"

    if flags.modreg_idx:
        modreg = f"op_reg_idx(op{flags.modreg_idx^3})"
    else:
        modreg = opcode.modrm[1] or 0
    vexop = f"op_reg_idx(op{flags.vexreg_idx^3})" if flags.vexreg_idx else 0
    is_memory = opcode.modrm[0] == "m"
    if not flags.modrm and opcode.modrm == (None, None, None):
        # No ModRM, prefix only (VZEROUPPER/VZEROALL)
        assert opcode.vex == 1
        assert not has_idx
        helperfn, helperargs = "enc_vex_common", f"0, 0, 0, 0"
    elif opcode.modrm[0] == "m":
        vsib = "VSIB" in variant.desc.flags
        helperfn = "enc" + ["", "_vex", "_evex"][opcode.vex] + ["_mem", "_vsib"][vsib]
        assert opcode.modrm[2] in (None, 4)
        forcesib = 1 if opcode.modrm[2] == 4 else 0 # AMX
        modrm = f"op{flags.modrm_idx^3}"
        ripoff = imm_size_expr + ("" if not has_idx else "+idx")
        helperargs = (f"{modrm}, {modreg}, {vexop}, {ripoff}, " +
                      f"{forcesib}, {variant.evexdisp8scale}")
    else:
        if flags.modrm_idx:
            modrm = f"op_reg_idx(op{flags.modrm_idx^3})"
        else:
            modrm = f"{opcode.modrm[2] or 0}"
        suffix = "_reg"
        if (opcode.vex == 2 and flags.modrm_idx and
            variant.desc.operands[flags.modrm_idx^3].kind == "XMM"):
            suffix = "_xmm"
        helperfn = "enc" + ["", "_vex", "_evex"][opcode.vex] + suffix
        helperargs = f"{modrm}, {modreg}, {vexop}"
    bufidx = "buf" if not has_idx else "buf+idx"
    helpercall = f"{helperfn}({bufidx}, {helperopc}, {helperargs})"
    if flags.imm_control >= 2:
        assert flags.imm_control < 6, "jmp with VEX/EVEX?"
        if is_memory:
            code += f"  unsigned instlen = {helpercall};\n"
            code += f"  if (instlen) enc_imm(buf+instlen-{imm_size_expr}, {imm_expr}, {imm_size_expr});\n"
            code += f"  return instlen;\n"
        else:
            code += f"  unsigned vexoff = {helpercall};\n"
            code += f"  enc_imm({bufidx}+vexoff, {imm_expr}, {imm_size_expr});\n"
            code += f"  return vexoff ? vexoff+{imm_size_expr}{'+idx' if has_idx else ''} : 0;\n"
    elif has_idx and not is_memory:
        code += f"  unsigned vexoff = {helpercall};\n"
        code += f"  return vexoff ? vexoff+idx : 0;\n"
    else:
        code += f"  return {helpercall};\n"
    return code

def encode2_table(entries, args):
    mnemonics = encode_mnems(entries)

    enc_decls, enc_code = "", ""
    for (mnem, opsize, ots), variants in mnemonics.items():
        max_imm_size = max(v.desc.imm_size(opsize//8) for v in variants)

        supports_high_regs = []
        if variants[0].desc.mnemonic in ("MOVSX", "MOVZX") or opsize == 8:
            # Should be the same for all variants
            for i, (ot, op) in enumerate(zip(ots, variants[0].desc.operands)):
                if ot == "r" and op.kind == "GP" and op.abssize(opsize//8) == 1:
                    supports_high_regs.append(i)
        supports_vsib = unique("VSIB" in v.desc.flags for v in variants)
        opkinds = unique(tuple(op.kind for op in v.desc.operands) for v in variants)
        evexmask = unique(v.evexmask for v in variants)
        evexsae = unique(v.evexsae for v in variants)

        OPKIND_LUT = {"FPU": "ST", "SEG": "SREG", "MMX": "MM"}
        reg_tys = [OPKIND_LUT.get(opkind, opkind) for opkind in opkinds]

        fnname = f"fe64_{mnem}"
        op_tys = [{
            "i": f"int{max_imm_size*8 if max_imm_size != 3 else 32}_t",
            "a": "uintptr_t",
            "r": f"FeReg{reg_ty if i not in supports_high_regs else 'GPLH'}",
            "k": "FeRegMASK",
            "m": "FeMem" if not supports_vsib else "FeMemV",
            "b": "FeMem",
            "o": "const void*",
        }[ot] for i, (ot, reg_ty) in enumerate(zip(ots, reg_tys))]
        fn_opargs = ", FeRegMASK opmask" if evexmask else ""
        fn_opargs += "".join(f", {ty} op{i}" for i, ty in enumerate(op_tys))
        fn_sig = f"unsigned ({fnname})(uint8_t* buf, int flags{fn_opargs})"
        enc_decls += f"{fn_sig};\n"
        if supports_high_regs:
            enc_decls += f"#define fe64_{mnem}(buf, flags"
            enc_decls += "".join(f", op{i}" for i in range(len(op_tys)))
            enc_decls += f") {fnname}(buf, flags"
            enc_decls += "".join(f", FE_MAKE_GPLH(op{i})" if i in supports_high_regs else f", op{i}" for i in range(len(op_tys)))
            enc_decls += f")\n"

        code = f"{fn_sig} {{\n"

        has_memory = unique(v.opcode.modrm[0] == "m" for v in variants)
        has_useg = unique("USEG" in v.desc.flags for v in variants)
        has_u67 = unique("U67" in v.desc.flags for v in variants)
        if has_memory or has_useg:
            # segment override without addrsize override shouldn't happen
            assert has_memory or has_u67
            code += f"  unsigned idx = UNLIKELY(flags & (FE_SEG_MASK|FE_ADDR32)) ? enc_seg67(buf, flags) : 0;\n"
        elif has_u67:
            # STOS, SCAS, JCXZ, LOOP, LOOPcc
            code += f"  unsigned idx = UNLIKELY(flags & FE_ADDR32) ? (*buf=0x67, 1) : 0;\n"
        else:
            code += "  (void) flags;\n"

        # indicate whether an idx variable exists
        has_idx = has_memory or has_useg or has_u67

        for i, variant in enumerate(variants):
            opcode, desc = variant.opcode, variant.desc
            flags = ENCODINGS[desc.encoding]

            conds = []
            # Select usable encoding.
            if desc.encoding == "S":
                # Segment encoding is weird.
                conds.append(f"op_reg_idx(op0)=={(opcode.opc>>3)&0x7:#x}")
            if desc.mnemonic == "XCHG_NOP" and opsize == 32:
                # XCHG eax, eax must not be encoded as 90 -- that'd be NOP.
                conds.append(f"!(op_reg_idx(op0)==0&&op_reg_idx(op1)==0)")
            if flags.vexreg_idx and not opcode.vex: # vexreg w/o vex is zeroreg
                conds.append(f"op_reg_idx(op{flags.vexreg_idx^3})=={flags.zeroreg_val}")

            imm_size = desc.imm_size(opsize//8)
            imm_size_expr = f"{imm_size}"
            imm_expr = f"(int64_t) op{flags.imm_idx^3}"
            if flags.imm_control == 1:
                conds.append(f"op{flags.imm_idx^3} == 1")
            elif flags.imm_control == 2:
                imm_size_expr = "(flags & FE_ADDR32 ? 4 : 8)"
                imm_expr = f"(int64_t) (flags & FE_ADDR32 ? (int32_t) {imm_expr} : {imm_expr})"
            elif flags.imm_control == 3:
                imm_expr = f"op_reg_idx(op{flags.imm_idx^3}) << 4"
                code += f"  if (op_reg_idx(op{flags.imm_idx^3}) >= 16) return 0;\n"
            elif flags.imm_control == 4 and imm_size == 3: # ENTER
                code += f"  if ((uint32_t) op{flags.imm_idx^3} >= 0x1000000) return 0;\n"
            elif flags.imm_control == 4 and imm_size < max_imm_size:
                conds.append(f"op_imm_n({imm_expr}, {imm_size})")
            elif flags.imm_control == 6:
                imm_expr = f"{imm_expr} - (int64_t) buf - {imm_size}"
                if i != len(variants) - 1: # only Jcc+JMP
                    conds.append(f"!(flags & FE_JMPL)")
                    # assume one-byte opcode without escape/prefixes
                    conds.append(f"op_imm_n({imm_expr}-1, {imm_size})")

            if conds:
                code += f"  if ({'&&'.join(conds)}) {{\n"

            if opcode.vex:
                code += encode2_gen_vex(variant, imm_expr, imm_size_expr, has_idx)
            else:
                code += encode2_gen_legacy(variant, opsize, supports_high_regs, imm_expr, imm_size_expr, has_idx)

            if conds:
                code += "  }\n"
            else:
                break
        else:
            code += "  return 0;\n"

        enc_code += code + "}\n"

    return enc_decls, enc_code


if __name__ == "__main__":
    generators = {
        "decode": decode_table,
        "encode": encode_table,
        "encode2": encode2_table,
    }

    parser = argparse.ArgumentParser()
    parser.add_argument("--32", dest="modes", action="append_const", const=32)
    parser.add_argument("--64", dest="modes", action="append_const", const=64)
    parser.add_argument("--with-undoc", action="store_true")
    parser.add_argument("--stats", action="store_true")
    parser.add_argument("mode", choices=generators.keys())
    parser.add_argument("table", type=argparse.FileType('r'))
    parser.add_argument("out_public", type=argparse.FileType('w'))
    parser.add_argument("out_private", type=argparse.FileType('w'))
    args = parser.parse_args()

    entries = []
    for line in args.table.read().splitlines():
        if not line or line[0] == "#": continue
        line, weak = (line, False) if line[0] != "*" else (line[1:], True)
        opcode_string, desc_string = tuple(line.split(maxsplit=1))
        opcode, desc = Opcode.parse(opcode_string), InstrDesc.parse(desc_string)
        verifyOpcodeDesc(opcode, desc)
        if "UNDOC" not in desc.flags or args.with_undoc:
            entries.append((weak, opcode, desc))

    res_public, res_private = generators[args.mode](entries, args)
    args.out_public.write(res_public)
    args.out_private.write(res_private)

```

`third_party/raw_pdb/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

project(raw_pdb)

set(CMAKE_CXX_STANDARD 11)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

add_subdirectory(src)
```

`third_party/raw_pdb/LICENSE`:

```
BSD 2-Clause License

Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`third_party/raw_pdb/README.md`:

```md
# RawPDB

**RawPDB** is a C++11 library that directly reads Microsoft Program DataBase PDB files. The code is extracted almost directly from <a href="https://liveplusplus.tech/">Live++ 2</a>, a battle-tested hot-reload tool for C++.

## Design

**RawPDB** gives you direct access to the stream data contained in a PDB file. It does not attempt to offer abstractions for iterating symbols, translation units, contributions, etc.

Building a high-level abstraction over the provided low-level data is an ill-fated attempt that can never really be performant for everybody, because different tools like debuggers, hot-reload tools (e.g. <a href="https://liveplusplus.tech/">Live++</a>), profilers (e.g. <a href="https://superluminal.eu/">Superluminal</a>), need to perform different queries against the stored data.

We therefore believe the best solution is to offer direct access to the underlying data, with applications bringing that data into their own structures.

## Goal

Eventually, we want **RawPDB** to become the de-facto replacement of <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/debug-interface-access-sdk">Microsoft's DIA SDK</a> that most C++ developers (have to) use.

## Features

* Fast - **RawPDB** works directly with memory-mapped data, so only the data from the streams you touch affect performance. It is orders of magnitudes faster than the DIA SDK, and faster than comparable LLVM code
* Scalable - **RawPDB's** API gives you access to individual streams that can all be read concurrently in a trivial fashion, since all returned data structures are immutable. There are no locks or waits anywhere inside the library
* Lightweight - **RawPDB** is small and compiles in roughly 1 second
* Allocation-friendly - **RawPDB** performs only a few allocations, and those can be overridden easily by changing the underlying macro
* No STL - **RawPDB** does not need any STL containers or algorithms
* No exceptions - **RawPDB** does not use exceptions
* No RTTI - **RawPDB** does not need RTTI or use class hierarchies
* High-quality code - **RawPDB** compiles clean under -Wall

## Building

The code compiles clean under Visual Studio 2015, 2017, 2019, or 2022. A solution for Visual Studio 2019 is included.

## Performance

Running the **Symbols** and **Contributions** examples on a 1GiB PDB yields the following output:

<pre>
Opening PDB file C:\Development\llvm-project\build\tools\clang\unittests\Tooling\RelWithDebInfo\ToolingTests.pdb

Running example "Symbols"
| Reading image section stream
| ---> done in 0.066ms
| Reading module info stream
| ---> done in 0.562ms
| Reading symbol record stream
| ---> done in 25.185ms
| Reading public symbol stream
| ---> done in 1.133ms
| Storing public symbols
| ---> done in 46.171ms (212023 elements)
| Reading global symbol stream
| ---> done in 1.381ms
| Storing global symbols
| ---> done in 12.769ms (448957 elements)
| Storing symbols from modules
| ---> done in 145.849ms (2243 elements)
---> done in 233.694ms (539611 elements)
</pre>

<pre>
Opening PDB file C:\Development\llvm-project\build\tools\clang\unittests\Tooling\RelWithDebInfo\ToolingTests.pdb

Running example "Contributions"
| Reading image section stream
| ---> done in 0.066ms
| Reading module info stream
| ---> done in 0.594ms
| Reading section contribution stream
| ---> done in 9.839ms
| Storing contributions
| ---> done in 67.346ms (630924 elements)
| std::sort contributions
| ---> done in 19.218ms
---> done in 97.283ms
20 largest contributions:
1: 1896496 bytes from LLVMAMDGPUCodeGen.dir\RelWithDebInfo\AMDGPUInstructionSelector.obj
2: 1700720 bytes from LLVMHexagonCodeGen.dir\RelWithDebInfo\HexagonInstrInfo.obj
3: 1536470 bytes from LLVMRISCVCodeGen.dir\RelWithDebInfo\RISCVISelDAGToDAG.obj
4: 1441408 bytes from LLVMAArch64CodeGen.dir\RelWithDebInfo\AArch64InstructionSelector.obj
5: 1187048 bytes from LLVMRISCVCodeGen.dir\RelWithDebInfo\RISCVInstructionSelector.obj
6: 1026504 bytes from LLVMARMCodeGen.dir\RelWithDebInfo\ARMInstructionSelector.obj
7: 952080 bytes from LLVMAMDGPUDesc.dir\RelWithDebInfo\AMDGPUMCTargetDesc.obj
8: 849888 bytes from LLVMX86Desc.dir\RelWithDebInfo\X86MCTargetDesc.obj
9: 712176 bytes from LLVMHexagonCodeGen.dir\RelWithDebInfo\HexagonInstrInfo.obj
10: 679035 bytes from LLVMX86CodeGen.dir\RelWithDebInfo\X86ISelDAGToDAG.obj
11: 525174 bytes from LLVMAMDGPUDesc.dir\RelWithDebInfo\AMDGPUMCTargetDesc.obj
12: 523035 bytes from * Linker *
13: 519312 bytes from LLVMRISCVDesc.dir\RelWithDebInfo\RISCVMCTargetDesc.obj
14: 512496 bytes from LLVMVEDesc.dir\RelWithDebInfo\VEMCTargetDesc.obj
15: 498768 bytes from LLVMX86CodeGen.dir\RelWithDebInfo\X86InstructionSelector.obj
16: 483528 bytes from LLVMMipsCodeGen.dir\RelWithDebInfo\MipsInstructionSelector.obj
17: 449472 bytes from LLVMAMDGPUCodeGen.dir\RelWithDebInfo\AMDGPUISelDAGToDAG.obj
18: 444246 bytes from C:\Development\llvm-project\build\tools\clang\lib\Basic\obj.clangBasic.dir\RelWithDebInfo\DiagnosticIDs.obj
19: 371584 bytes from LLVMAArch64CodeGen.dir\RelWithDebInfo\AArch64ISelDAGToDAG.obj
20: 370272 bytes from LLVMNVPTXDesc.dir\RelWithDebInfo\NVPTXMCTargetDesc.obj
</pre>

This is at least an order of magnitude faster than DIA, even though the example code is completely serial and uses std::vector, std::string, and std::sort, which are used for illustration purposes only.

When reading streams in a concurrent fashion, you will most likely be limited by the speed at which the OS can bring the data into your process.

Running the **Lines** example on a 1.37 GiB PDB yields the following output:

<pre>

Opening PDB file C:\pdb-test-files\clang-debug.pdb
Version 20000404, signature 1658696914, age 1, GUID 563dd8f1-f32b-459b-8c2beae0e70bc19b

Running example "Lines"
| Reading image section stream
| ---> done in 0.313ms
| Reading module info stream
| ---> done in 0.403ms
| Reading names stream
| ---> done in 0.126ms
| Storing lines from modules
| ---> done in 306.720ms (1847 elements)
| std::sort sections
| ---> done in 103.090ms (4023680 elements)

</pre>

## Supported streams

**RawPDB** gives you access to the following PDB stream data:

* DBI stream data
	* Public symbols
	* Global symbols
	* Modules
	* Module symbols
	* Module lines (C13 line information)
	* Image sections
	* Info stream
		* "/names" stream
	* Section contributions
	* Source files

* IPI stream data

* TPI stream data

Furthermore, PDBs linked using /DEBUG:FASTLINK are not supported. These PDBs do not contain much information, since private symbol information is distributed among object files and library files.

## Documentation

If you are unfamiliar with the basic structure of a PDB file, the <a href="https://llvm.org/docs/PDB/index.html">LLVM documentation</a> serves as a good introduction.

Consult the example code to see how to read and parse the PDB streams.

## Directory structure

* bin: contains final binary output files (.exe and .pdb)
* build: contains Visual Studio 2019 solution and project files
* lib: contains the RawPDB library output files (.lib and .pdb)
* src: contains the RawPDB source code, as well as example code
* temp: contains intermediate build artefacts

## Examples

### Symbols (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExampleSymbols.cpp">ExampleSymbols.cpp</a>)

A basic example that shows how to load symbols from public, global, and module streams.

### Contributions (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExampleContributions.cpp">ExampleContributions.cpp</a>)

A basic example that shows how to load contributions, sort them by size, and output the 20 largest ones along with the object file they originated from.

### Function symbols (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExampleFunctionSymbols.cpp">ExampleFunctionSymbols.cpp</a>)

An example intended for profiler developers that shows how to enumerate all function symbols and retrieve or compute their code size.

### Function variables (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExampleFunctionVariables.cpp">ExampleFunctionVariables.cpp</a>)

An example intended for debugger developers that shows how to enumerate all function records needed for displaying function variables. 

### Lines (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExampleLines.cpp">ExampleLines.cpp</a>)

An example that shows to how to load line information for all modules.

### Types (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExampleTypes.cpp">ExampleTypes.cpp</a>)

An example that prints all type records.

### PDBSize (<a href="https://github.com/MolecularMatters/raw_pdb/blob/main/src/Examples/ExamplePDBSize.cpp">ExamplePDBSize.cpp</a>)

An example that could serve as a starting point for people wanting to investigate and optimize the size of their PDBs.

## Sponsoring or supporting RawPDB

We have chosen a very liberal license to let **RawPDB** be used in as many scenarios as possible, including commercial applications. If you would like to support its development, consider licensing <a href="https://liveplusplus.tech/">Live++</a> instead. Not only do you give something back, but get a great productivity enhancement on top!

```

`third_party/raw_pdb/raw_pdb.natvis`:

```natvis
<?xml version="1.0" encoding="utf-8"?>
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">
	<Type Name="PDB::ArrayView&lt;*&gt;">
		<DisplayString>{{ size={m_length} }}</DisplayString>
		<Expand>
			<ArrayItems>
				<Size>m_length</Size>
				<ValuePointer>m_data</ValuePointer>
			</ArrayItems>
		</Expand>
	</Type>
</AutoVisualizer>

```

`third_party/raw_pdb/src/CMakeLists.txt`:

```txt
set(SOURCES
	Foundation/PDB_ArrayView.h
	Foundation/PDB_Assert.h
	Foundation/PDB_BitOperators.h
	Foundation/PDB_BitUtil.h
	Foundation/PDB_CRT.h
	Foundation/PDB_Forward.h
	Foundation/PDB_Log.h
	Foundation/PDB_Macros.h
	Foundation/PDB_Memory.h
	Foundation/PDB_Move.h
	Foundation/PDB_Platform.h
	Foundation/PDB_PointerUtil.h
	Foundation/PDB_TypeTraits.h
	Foundation/PDB_Warnings.h
	
	PDB.cpp
	PDB.h
	PDB_CoalescedMSFStream.cpp
	PDB_CoalescedMSFStream.h
	PDB_DBIStream.cpp
	PDB_DBIStream.h
	PDB_DBITypes.cpp
	PDB_DBITypes.h
	PDB_DirectMSFStream.cpp
	PDB_DirectMSFStream.h
	PDB_ErrorCodes.h
	PDB_GlobalSymbolStream.cpp
	PDB_GlobalSymbolStream.h
	PDB_ImageSectionStream.cpp
	PDB_ImageSectionStream.h
	PDB_InfoStream.cpp
	PDB_InfoStream.h
	PDB_IPIStream.cpp
	PDB_IPIStream.h
	PDB_IPITypes.h
	PDB_ModuleInfoStream.cpp
	PDB_ModuleInfoStream.h
	PDB_ModuleLineStream.cpp
	PDB_ModuleLineStream.h
	PDB_ModuleSymbolStream.cpp
	PDB_ModuleSymbolStream.h
	PDB_NamesStream.cpp
	PDB_NamesStream.h
	PDB_PCH.cpp
	PDB_PCH.h
	PDB_PublicSymbolStream.cpp
	PDB_PublicSymbolStream.h
	PDB_RawFile.cpp
	PDB_RawFile.h
	PDB_SectionContributionStream.cpp
	PDB_SectionContributionStream.h
	PDB_SourceFileStream.cpp
	PDB_SourceFileStream.h
	PDB_TPIStream.cpp
	PDB_TPIStream.h
	PDB_TPITypes.h
	PDB_Types.cpp
	PDB_Types.h
	PDB_Util.h
)

source_group(src FILES
    ${SOURCES}
)

add_library(raw_pdb
    ${SOURCES}
)

target_include_directories(raw_pdb
  PUBLIC
    .
)

target_precompile_headers(raw_pdb
  PRIVATE
    PDB_PCH.h
)

option(RAWPDB_BUILD_EXAMPLES "Build Examples" ON)

if (RAWPDB_BUILD_EXAMPLES)
	add_subdirectory(Examples)
endif()

if (UNIX)
	include(GNUInstallDirs)

	install(
		TARGETS raw_pdb
		LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}"
	)

	file(GLOB_RECURSE HEADER_FILES
		"${CMAKE_CURRENT_SOURCE_DIR}/*.h"
	)

	file(GLOB_RECURSE HEADER_FILES_FOUNDATION
		"${CMAKE_CURRENT_SOURCE_DIR}/Foundation/*.h"
	)

	install(
		FILES ${HEADER_FILES}
		DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/raw_pdb/"
	)

	install(
		FILES ${HEADER_FILES_FOUNDATION}
		DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/raw_pdb/Foundation"
	)
endif (UNIX)

```

`third_party/raw_pdb/src/Examples/CMakeLists.txt`:

```txt
project(Examples)

set(SOURCES
	ExampleContributions.cpp
	ExampleFunctionSymbols.cpp
	ExampleFunctionVariables.cpp
	ExampleIPI.cpp
	ExampleLines.cpp
	ExampleMain.cpp
	ExampleMemoryMappedFile.cpp
	ExampleMemoryMappedFile.h
	ExamplePDBSize.cpp
	Examples_PCH.cpp
	Examples_PCH.h
	ExampleSymbols.cpp
	ExampleTimedScope.cpp
	ExampleTimedScope.h
	ExampleTypes.cpp
	ExampleTypeTable.cpp
	ExampleTypeTable.h
)

source_group(src FILES
    ${SOURCES}
)

add_executable(Examples
    ${SOURCES}
)

target_link_libraries(Examples
  PUBLIC
    raw_pdb
)

target_precompile_headers(Examples
  PUBLIC
    Examples_PCH.h
)
```

`third_party/raw_pdb/src/Examples/ExampleContributions.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"


namespace
{
	// we don't have to store std::string in the contributions, since all the data is memory-mapped anyway.
	// we do it in this example to ensure that we don't "cheat" when reading the PDB file. memory-mapped data will only
	// be faulted into the process once it's touched, so actually copying the string data makes us touch the needed data,
	// giving us a real performance measurement.
	struct Contribution
	{
		std::string objectFile;
		uint32_t rva;
		uint32_t size;
	};
}


void ExampleContributions(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream);
void ExampleContributions(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream)
{
	TimedScope total("\nRunning example \"Contributions\"");

	// in order to keep the example easy to understand, we load the PDB data serially.
	// note that this can be improved a lot by reading streams concurrently.

	// prepare the image section stream first. it is needed for converting section + offset into an RVA
	TimedScope sectionScope("Reading image section stream");
	const PDB::ImageSectionStream imageSectionStream = dbiStream.CreateImageSectionStream(rawPdbFile);
	sectionScope.Done();


	// prepare the module info stream for matching contributions against files
	TimedScope moduleScope("Reading module info stream");
	const PDB::ModuleInfoStream moduleInfoStream = dbiStream.CreateModuleInfoStream(rawPdbFile);
	moduleScope.Done();


	// read contribution stream
	TimedScope contributionScope("Reading section contribution stream");
	const PDB::SectionContributionStream sectionContributionStream = dbiStream.CreateSectionContributionStream(rawPdbFile);
	contributionScope.Done();

	std::vector<Contribution> contributions;
	{
		TimedScope scope("Storing contributions");

		const PDB::ArrayView<PDB::DBI::SectionContribution> sectionContributions = sectionContributionStream.GetContributions();
		const size_t count = sectionContributions.GetLength();

		contributions.reserve(count);

		for (const PDB::DBI::SectionContribution& contribution : sectionContributions)
		{
			const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(contribution.section, contribution.offset);
			if (rva == 0u)
			{
				printf("Contribution has invalid RVA\n");
				continue;
			}

			const PDB::ModuleInfoStream::Module& module = moduleInfoStream.GetModule(contribution.moduleIndex);

			contributions.push_back(Contribution { module.GetName().Decay(), rva, contribution.size });
		}
		
		scope.Done(count);
	}

	TimedScope sortScope("std::sort contributions");
	std::sort(contributions.begin(), contributions.end(), [](const Contribution& lhs, const Contribution& rhs)
	{
		return lhs.size > rhs.size;
	});
	sortScope.Done();

	total.Done();

	// log the 20 largest contributions
	{
		printf("20 largest contributions:\n");

		const size_t countToShow = std::min<size_t>(20ul, contributions.size());
		for (size_t i = 0u; i < countToShow; ++i)
		{
			const Contribution& contribution = contributions[i];
			printf("%zu: %u bytes from %s\n", i + 1u, contribution.size, contribution.objectFile.c_str());
		}
	}
}

```

`third_party/raw_pdb/src/Examples/ExampleFunctionSymbols.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"

namespace
{
	// in this example, we are only interested in function symbols: function name, RVA, and size.
	// this is what most profilers need, they aren't interested in any other data.
	struct FunctionSymbol
	{
		std::string name;
		uint32_t rva;
		uint32_t size;
		const PDB::CodeView::DBI::Record* frameProc;
	};
}


void ExampleFunctionSymbols(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream);
void ExampleFunctionSymbols(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream)
{
	TimedScope total("\nRunning example \"Function symbols\"");

	// in order to keep the example easy to understand, we load the PDB data serially.
	// note that this can be improved a lot by reading streams concurrently.

	// prepare the image section stream first. it is needed for converting section + offset into an RVA
	TimedScope sectionScope("Reading image section stream");
	const PDB::ImageSectionStream imageSectionStream = dbiStream.CreateImageSectionStream(rawPdbFile);
	sectionScope.Done();


	// prepare the module info stream for grabbing function symbols from modules
	TimedScope moduleScope("Reading module info stream");
	const PDB::ModuleInfoStream moduleInfoStream = dbiStream.CreateModuleInfoStream(rawPdbFile);
	moduleScope.Done();


	// prepare symbol record stream needed by the public stream
	TimedScope symbolStreamScope("Reading symbol record stream");
	const PDB::CoalescedMSFStream symbolRecordStream = dbiStream.CreateSymbolRecordStream(rawPdbFile);
	symbolStreamScope.Done();


	// note that we only use unordered_set in order to keep the example code easy to understand.
	// using other hash set implementations like e.g. abseil's Swiss Tables (https://abseil.io/about/design/swisstables) is *much* faster.
	std::vector<FunctionSymbol> functionSymbols;
	std::unordered_set<uint32_t> seenFunctionRVAs;

	// start by reading the module stream, grabbing every function symbol we can find.
	// in most cases, this gives us ~90% of all function symbols already, along with their size.
	{
		TimedScope scope("Storing function symbols from modules");

		const PDB::ArrayView<PDB::ModuleInfoStream::Module> modules = moduleInfoStream.GetModules();

		for (const PDB::ModuleInfoStream::Module& module : modules)
		{
			if (!module.HasSymbolStream())
			{
				continue;
			}

			const PDB::ModuleSymbolStream moduleSymbolStream = module.CreateSymbolStream(rawPdbFile);
			moduleSymbolStream.ForEachSymbol([&functionSymbols, &seenFunctionRVAs, &imageSectionStream](const PDB::CodeView::DBI::Record* record)
			{
				// only grab function symbols from the module streams
				const char* name = nullptr;
				uint32_t rva = 0u;
				uint32_t size = 0u;
				if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_FRAMEPROC)
				{
					functionSymbols[functionSymbols.size() - 1].frameProc = record;
					return;
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_THUNK32)
				{
					if (record->data.S_THUNK32.thunk == PDB::CodeView::DBI::ThunkOrdinal::TrampolineIncremental)
					{
						// we have never seen incremental linking thunks stored inside a S_THUNK32 symbol, but better safe than sorry
						name = "ILT";
						rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_THUNK32.section, record->data.S_THUNK32.offset);
						size = 5u;
					}
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_TRAMPOLINE)
				{
					// incremental linking thunks are stored in the linker module
					name = "ILT";
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_TRAMPOLINE.thunkSection, record->data.S_TRAMPOLINE.thunkOffset);
					size = 5u;
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LPROC32)
				{
					name = record->data.S_LPROC32.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LPROC32.section, record->data.S_LPROC32.offset);
					size = record->data.S_LPROC32.codeSize;
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GPROC32)
				{
					name = record->data.S_GPROC32.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_GPROC32.section, record->data.S_GPROC32.offset);
					size = record->data.S_GPROC32.codeSize;
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LPROC32_ID)
				{
					name = record->data.S_LPROC32_ID.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LPROC32_ID.section, record->data.S_LPROC32_ID.offset);
					size = record->data.S_LPROC32_ID.codeSize;
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GPROC32_ID)
				{
					name = record->data.S_GPROC32_ID.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_GPROC32_ID.section, record->data.S_GPROC32_ID.offset);
					size = record->data.S_GPROC32_ID.codeSize;
				}

				if (rva == 0u)
				{
					return;
				}

				functionSymbols.push_back(FunctionSymbol { name, rva, size, nullptr });
				seenFunctionRVAs.emplace(rva);
			});
		}

		scope.Done(modules.GetLength());
	}

	// we don't need to touch global symbols in this case.
	// most of the data we need can be obtained from the module symbol streams, and the global symbol stream only offers data symbols on top of that, which we are not interested in.
	// however, there can still be public function symbols we haven't seen yet in any of the modules, especially for PDBs that don't provide module-specific information.

	// read public symbols
	TimedScope publicScope("Reading public symbol stream");
	const PDB::PublicSymbolStream publicSymbolStream = dbiStream.CreatePublicSymbolStream(rawPdbFile);
	publicScope.Done();
	{
		TimedScope scope("Storing public function symbols");

		const PDB::ArrayView<PDB::HashRecord> hashRecords = publicSymbolStream.GetRecords();
		const size_t count = hashRecords.GetLength();

		for (const PDB::HashRecord& hashRecord : hashRecords)
		{
			const PDB::CodeView::DBI::Record* record = publicSymbolStream.GetRecord(symbolRecordStream, hashRecord);
			if (record->header.kind != PDB::CodeView::DBI::SymbolRecordKind::S_PUB32)
			{
				// normally, a PDB only contains S_PUB32 symbols in the public symbol stream, but we have seen PDBs that also store S_CONSTANT as public symbols.
				// ignore these.
				continue;
			}

			if ((PDB_AS_UNDERLYING(record->data.S_PUB32.flags) & PDB_AS_UNDERLYING(PDB::CodeView::DBI::PublicSymbolFlags::Function)) == 0u)
			{
				// ignore everything that is not a function
				continue;
			}

			const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_PUB32.section, record->data.S_PUB32.offset);
			if (rva == 0u)
			{
				// certain symbols (e.g. control-flow guard symbols) don't have a valid RVA, ignore those
				continue;
			}

			// check whether we already know this symbol from one of the module streams
			const auto it = seenFunctionRVAs.find(rva);
			if (it != seenFunctionRVAs.end())
			{
				// we know this symbol already, ignore it
				continue;
			}

			// this is a new function symbol, so store it.
			// note that we don't know its size yet.
			functionSymbols.push_back(FunctionSymbol { record->data.S_PUB32.name, rva, 0u, nullptr });
		}

		scope.Done(count);
	}


	// we still need to find the size of the public function symbols.
	// this can be deduced by sorting the symbols by their RVA, and then computing the distance between the current and the next symbol.
	// this works since functions are always mapped to executable pages, so they aren't interleaved by any data symbols.
	TimedScope sortScope("std::sort function symbols");
	std::sort(functionSymbols.begin(), functionSymbols.end(), [](const FunctionSymbol& lhs, const FunctionSymbol& rhs)
	{
		return lhs.rva < rhs.rva;
	});
	sortScope.Done();

	const size_t symbolCount = functionSymbols.size();
	if (symbolCount != 0u)
	{
		TimedScope computeScope("Computing function symbol sizes");

		size_t foundCount = 0u;

		// we have at least 1 symbol.
		// compute missing symbol sizes by computing the distance from this symbol to the next.
		// note that this includes "int 3" padding after the end of a function. if you don't want that, but the actual number of bytes of
		// the function's code, your best bet is to use a disassembler instead.
		for (size_t i = 0u; i < symbolCount - 1u; ++i)
		{
			FunctionSymbol& currentSymbol = functionSymbols[i];
			if (currentSymbol.size != 0u)
			{
				// the symbol's size is already known
				continue;
			}

			const FunctionSymbol& nextSymbol = functionSymbols[i + 1u];
			const size_t size = nextSymbol.rva - currentSymbol.rva;
			(void)size; // unused
			++foundCount;
		}

		// we know have the sizes of all symbols, except the last.
		// this can be found by going through the contributions, if needed.
		FunctionSymbol& lastSymbol = functionSymbols[symbolCount - 1u];
		if (lastSymbol.size == 0u)
		{
			// bad luck, we can't deduce the last symbol's size, so have to consult the contributions instead.
			// we do a linear search in this case to keep the code simple.
			const PDB::SectionContributionStream sectionContributionStream = dbiStream.CreateSectionContributionStream(rawPdbFile);
			const PDB::ArrayView<PDB::DBI::SectionContribution> sectionContributions = sectionContributionStream.GetContributions();
			for (const PDB::DBI::SectionContribution& contribution : sectionContributions)
			{
				const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(contribution.section, contribution.offset);
				if (rva == 0u)
				{
					printf("Contribution has invalid RVA\n");
					continue;
				}

				if (rva == lastSymbol.rva)
				{
					lastSymbol.size = contribution.size;
					break;
				}
				
				if (rva > lastSymbol.rva)
				{
					// should have found the contribution by now
					printf("Unknown contribution for symbol %s at RVA 0x%X", lastSymbol.name.c_str(), lastSymbol.rva);
					break;
				}
			}
		}

		computeScope.Done(foundCount);
	}

	total.Done(functionSymbols.size());
}

```

`third_party/raw_pdb/src/Examples/ExampleFunctionVariables.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "ExampleTypeTable.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"
#include "PDB_TPIStream.h"

using SymbolRecordKind = PDB::CodeView::DBI::SymbolRecordKind;

static std::string GetVariableTypeName(const TypeTable& typeTable, uint32_t typeIndex)
{
	// Defined in ExampleTypes.cpp
	extern std::string GetTypeName(const TypeTable & typeTable, uint32_t typeIndex);

	std::string typeName = GetTypeName(typeTable, typeIndex);

	// Remove any '%s' substring used to insert a variable/field name.
	const uint64_t markerPos = typeName.find("%s");
	if (markerPos != typeName.npos)
	{
		typeName.erase(markerPos, 2);
	}

	return typeName;
}

static void Printf(uint32_t indent, const char* format, ...) 
{
	va_list args;
	va_start(args, format);

	printf("%*s", indent * 4, "");
	vprintf(format, args);

	va_end(args);
}

void ExampleFunctionVariables(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream, const PDB::TPIStream& tpiStream);
void ExampleFunctionVariables(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream, const PDB::TPIStream& tpiStream)
{
	TimedScope total("\nRunning example \"Function variables\"");

	TimedScope typeTableScope("Create TypeTable");
	TypeTable typeTable(tpiStream);
	typeTableScope.Done();

	// in order to keep the example easy to understand, we load the PDB data serially.
	// note that this can be improved a lot by reading streams concurrently.

	// prepare the image section stream first. it is needed for converting section + offset into an RVA
	TimedScope sectionScope("Reading image section stream");
	const PDB::ImageSectionStream imageSectionStream = dbiStream.CreateImageSectionStream(rawPdbFile);
	sectionScope.Done();

	// prepare the module info stream for grabbing function symbols from modules
	TimedScope moduleScope("Reading module info stream");
	const PDB::ModuleInfoStream moduleInfoStream = dbiStream.CreateModuleInfoStream(rawPdbFile);
	moduleScope.Done();

	// prepare symbol record stream needed by the public stream
	TimedScope symbolStreamScope("Reading symbol record stream");
	const PDB::CoalescedMSFStream symbolRecordStream = dbiStream.CreateSymbolRecordStream(rawPdbFile);
	symbolStreamScope.Done();

	{
		TimedScope scope("Printing function variable records from modules\n");

		const PDB::ArrayView<PDB::ModuleInfoStream::Module> modules = moduleInfoStream.GetModules();

		uint32_t blockLevel = 0;
		uint32_t recordCount = 0;

		for (const PDB::ModuleInfoStream::Module& module : modules)
		{
			if (!module.HasSymbolStream())
			{
				continue;
			}

			const PDB::ModuleSymbolStream moduleSymbolStream = module.CreateSymbolStream(rawPdbFile);
			moduleSymbolStream.ForEachSymbol([&typeTable, &imageSectionStream, &blockLevel, &recordCount](const PDB::CodeView::DBI::Record* record)
			{
				const SymbolRecordKind kind = record->header.kind;
				const PDB::CodeView::DBI::Record::Data& data = record->data;

				if (kind == SymbolRecordKind::S_END)
				{
					PDB_ASSERT(blockLevel > 0, "Block level for S_END is 0");
					blockLevel--;
					Printf(blockLevel, "S_END\n");

					if (blockLevel == 0)
					{
						Printf(0, "\n");
					}
				}
				else if(kind == SymbolRecordKind::S_SKIP)
				{
					Printf(blockLevel, "S_SKIP\n");
				}
				else if (kind == SymbolRecordKind::S_BLOCK32)
				{
					const uint32_t offset = imageSectionStream.ConvertSectionOffsetToRVA(data.S_BLOCK32.section, data.S_BLOCK32.offset);

					Printf(blockLevel, "S_BLOCK32: '%s' | Code Offset 0x%X\n", data.S_BLOCK32.name, offset);
					blockLevel++;
				}
				else if (kind == SymbolRecordKind::S_LABEL32)
				{
					Printf(blockLevel, "S_LABEL32: '%s' | Offset 0x%X\n", data.S_LABEL32.name, data.S_LABEL32.offset);
				}
				else if(kind == SymbolRecordKind::S_CONSTANT)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_CONSTANT.typeIndex);

					Printf(blockLevel, "S_CONSTANT: '%s' -> '%s' | Value 0x%X\n", typeName.c_str(), data.S_CONSTANT.name, data.S_CONSTANT.value);
				}
				else if(kind == SymbolRecordKind::S_LOCAL)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_LOCAL.typeIndex);
					Printf(blockLevel, "S_LOCAL: '%s' -> '%s' | Param: %s | Optimized Out: %s\n", typeName.c_str(), data.S_LOCAL.name, data.S_LOCAL.flags.fIsParam ? "True" : "False", data.S_LOCAL.flags.fIsOptimizedOut ? "True" : "False");
				}
				else if (kind == SymbolRecordKind::S_DEFRANGE_REGISTER)
				{
					Printf(blockLevel, "S_DEFRANGE_REGISTER: Register 0x%X\n", data.S_DEFRANGE_REGISTER.reg);
				}
				else if(kind == SymbolRecordKind::S_DEFRANGE_FRAMEPOINTER_REL)
				{
					Printf(blockLevel, "S_DEFRANGE_FRAMEPOINTER_REL: Frame Pointer Offset 0x%X | Range Start 0x%X | Range Section Start 0x%X | Range Length %u\n", 
							data.S_DEFRANGE_FRAMEPOINTER_REL.offsetFramePointer, 
							data.S_DEFRANGE_FRAMEPOINTER_REL.range.offsetStart, 
							data.S_DEFRANGE_FRAMEPOINTER_REL.range.isectionStart, 
							data.S_DEFRANGE_FRAMEPOINTER_REL.range.length);
				}
				else if(kind == SymbolRecordKind::S_DEFRANGE_SUBFIELD_REGISTER)
				{
					Printf(blockLevel, "S_DEFRANGE_SUBFIELD_REGISTER: Register %u | Parent offset 0x%X | Range Start 0x%X | Range Section Start 0x%X | Range Length %u\n", 
						data.S_DEFRANGE_SUBFIELD_REGISTER.reg,
						data.S_DEFRANGE_SUBFIELD_REGISTER.offsetParent,
						data.S_DEFRANGE_SUBFIELD_REGISTER.range.offsetStart, 
						data.S_DEFRANGE_SUBFIELD_REGISTER.range.isectionStart, 
						data.S_DEFRANGE_SUBFIELD_REGISTER.range.length);
				}
				else if (kind == SymbolRecordKind::S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE)
				{
					Printf(blockLevel, "S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE: Offset 0x%X\n", data.S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE.offsetFramePointer);
				}
				else if (kind == SymbolRecordKind::S_DEFRANGE_REGISTER_REL)
				{
					Printf(blockLevel, "S_DEFRANGE_REGISTER_REL: Base Register %u | Parent offset 0x%X | Base Register Offset 0x%X | Range Start 0x%X | Range Section Start 0x%X | Range Length %u\n",
						data.S_DEFRANGE_REGISTER_REL.baseRegister,
						data.S_DEFRANGE_REGISTER_REL.offsetParent,
						data.S_DEFRANGE_REGISTER_REL.offsetBasePointer,
						data.S_DEFRANGE_REGISTER_REL.offsetParent,
						data.S_DEFRANGE_REGISTER_REL.range.offsetStart, 
						data.S_DEFRANGE_REGISTER_REL.range.isectionStart, 
						data.S_DEFRANGE_REGISTER_REL.range.length);						
				}
				else if(kind == SymbolRecordKind::S_FILESTATIC)
				{
					Printf(blockLevel, "S_FILESTATIC: '%s'\n", data.S_FILESTATIC.name);
				}
				else if (kind == SymbolRecordKind::S_INLINESITE)
				{
					Printf(blockLevel, "S_INLINESITE: Parent 0x%X\n", data.S_INLINESITE.parent);
					blockLevel++;
				}
				else if (kind == SymbolRecordKind::S_INLINESITE_END)
				{
					PDB_ASSERT(blockLevel > 0, "Block level for S_INLINESITE_END is 0");
					blockLevel--;					
					Printf(blockLevel, "S_INLINESITE_END:\n");
				}
				else if (kind == SymbolRecordKind::S_CALLEES)
				{
					Printf(blockLevel, "S_CALLEES: Count %u\n", data.S_CALLEES.count);
				}
				else if (kind == SymbolRecordKind::S_CALLERS)
				{
					Printf(blockLevel, "S_CALLERS: Count %u\n", data.S_CALLERS.count);
				}
				else if (kind == SymbolRecordKind::S_INLINEES)
				{
					Printf(blockLevel, "S_INLINEES: Count %u\n", data.S_INLINEES.count);
				}
				else if (kind == SymbolRecordKind::S_LDATA32)
				{
					if (blockLevel > 0)
					{
						// Not sure why some type index 0 (T_NO_TYPE) are included in some PDBs.
						if (data.S_LDATA32.typeIndex != 0) // PDB::CodeView::TPI::TypeIndexKind::T_NOTYPE)
						{
							const std::string typeName = GetVariableTypeName(typeTable, data.S_LDATA32.typeIndex);
							Printf(blockLevel, "S_LDATA32: '%s' -> '%s'\n", data.S_LDATA32.name, typeName.c_str());
						}						
					}
				}
				else if (kind == SymbolRecordKind::S_LTHREAD32)
				{
					if (blockLevel > 0)
					{
						const std::string typeName = GetVariableTypeName(typeTable, data.S_LTHREAD32.typeIndex);
						Printf(blockLevel, "S_LTHREAD32: '%s' -> '%s'\n", data.S_LTHREAD32.name, typeName.c_str());
					}
				}
				else if (kind == SymbolRecordKind::S_UDT)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_UDT.typeIndex);

					Printf(blockLevel, "S_UDT: '%s' -> '%s'\n", data.S_UDT.name, typeName.c_str());
				}
				else if (kind == PDB::CodeView::DBI::SymbolRecordKind::S_REGISTER)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_REGSYM.typeIndex);

					Printf(blockLevel, "S_REGSYM: '%s' -> '%s' | Register %i\n",
						data.S_REGSYM.name, typeName.c_str(),
						data.S_REGSYM.reg);
				}
				else if (kind == PDB::CodeView::DBI::SymbolRecordKind::S_BPREL32)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_BPRELSYM32.typeIndex);

					Printf(blockLevel, "S_BPRELSYM32: '%s' -> '%s' | BP register Offset 0x%X\n",
						data.S_BPRELSYM32.name, typeName.c_str(),
						data.S_BPRELSYM32.offset);
				}
				else if (kind == PDB::CodeView::DBI::SymbolRecordKind::S_REGREL32)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_REGREL32.typeIndex);
	
					Printf(blockLevel, "S_REGREL32: '%s' -> '%s' | Register %i | Register Offset 0x%X\n", 
						data.S_REGREL32.name, typeName.c_str(), 
						data.S_REGREL32.reg, 
						data.S_REGREL32.offset);
				}
				else if(kind == SymbolRecordKind::S_FRAMECOOKIE)
				{
					Printf(blockLevel, "S_FRAMECOOKIE: Offset 0x%X | Register %u | Type %u\n", 
						data.S_FRAMECOOKIE.offset, 
						data.S_FRAMECOOKIE.reg, 
						data.S_FRAMECOOKIE.cookietype);
				}
				else if(kind == SymbolRecordKind::S_CALLSITEINFO)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_CALLSITEINFO.typeIndex);
					Printf(blockLevel, "S_CALLSITEINFO: '%s' | Offset 0x%X | Section %u\n", typeName.c_str(), data.S_CALLSITEINFO.offset, data.S_CALLSITEINFO.section);
				}
				else if(kind == SymbolRecordKind::S_HEAPALLOCSITE)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_HEAPALLOCSITE.typeIndex);
					Printf(blockLevel, "S_HEAPALLOCSITE: '%s' | Offset 0x%X | Section %u | Instruction Length %u\n", typeName.c_str(), 
						data.S_HEAPALLOCSITE.offset, 
						data.S_HEAPALLOCSITE.section, 
						data.S_HEAPALLOCSITE.instructionLength);
				}
				else if (kind == SymbolRecordKind::S_FRAMEPROC)
				{
					Printf(blockLevel, "S_FRAMEPROC: Size %u | Padding %u | Padding Offset 0x%X | Callee Registers Size %u\n", 
						data.S_FRAMEPROC.cbFrame, 
						data.S_FRAMEPROC.cbPad, 
						data.S_FRAMEPROC.offPad, 
						data.S_FRAMEPROC.cbSaveRegs);
				}
				else if (kind == SymbolRecordKind::S_ANNOTATION)
				{
					Printf(blockLevel, "S_ANNOTATION: Offset 0x%X | Count %u\n", data.S_ANNOTATIONSYM.offset, data.S_ANNOTATIONSYM.annotationsCount);
					// print N null-terminated annotation strings, skipping their null-terminators to get to the next string
					const char* annotation = data.S_ANNOTATIONSYM.annotations;
					for (int i = 0; i < data.S_ANNOTATIONSYM.annotationsCount; ++i, annotation += strlen(annotation) + 1)
						Printf(blockLevel + 1, "S_ANNOTATION.%u: %s\n", i, annotation);
					PDB_ASSERT(annotation <= (const char*)record + record->header.size + sizeof(record->header.size),
						"Annotation strings end beyond the record size %X; annotaions count: %u", record->header.size, data.S_ANNOTATIONSYM.annotationsCount);
				}
				else if (kind == SymbolRecordKind::S_THUNK32)
				{
					PDB_ASSERT(blockLevel == 0, "BlockLevel %u != 0", blockLevel);

					if (data.S_THUNK32.thunk == PDB::CodeView::DBI::ThunkOrdinal::TrampolineIncremental)
					{
						// we have never seen incremental linking thunks stored inside a S_THUNK32 symbol, but better safe than sorry
						const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_THUNK32.section, data.S_THUNK32.offset);
						Printf(blockLevel, "Function: 'ILT/Thunk' | RVA 0x%X\n", rva);
					}
					else
					{
						const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_THUNK32.section, data.S_THUNK32.offset);
						Printf(blockLevel, "S_THUNK32 Function '%s' | RVA 0x%X\n", data.S_THUNK32.name, rva);
						blockLevel++;
					}
				}
				else if (kind == SymbolRecordKind::S_TRAMPOLINE)
				{
					PDB_ASSERT(blockLevel == 0, "BlockLevel %u != 0", blockLevel);
					// incremental linking thunks are stored in the linker module
					const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_TRAMPOLINE.thunkSection, data.S_TRAMPOLINE.thunkOffset);
					Printf(blockLevel, "Function 'ILT/Trampoline' | RVA 0x%X\n", rva);
				}
				else if (kind == SymbolRecordKind::S_LPROC32)
				{
					PDB_ASSERT(blockLevel == 0, "BlockLevel %u != 0", blockLevel);
					const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_LPROC32.section, data.S_LPROC32.offset);
					Printf(blockLevel, "S_LPROC32 Function '%s' | RVA 0x%X\n", data.S_LPROC32.name, rva);
					blockLevel++;
				}
				else if (kind == SymbolRecordKind::S_GPROC32)
				{
					PDB_ASSERT(blockLevel == 0, "BlockLevel %u != 0", blockLevel);
					const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_GPROC32.section, data.S_GPROC32.offset);
					Printf(blockLevel, "S_GPROC32 Function '%s' | RVA 0x%X\n", data.S_GPROC32.name, rva);
					blockLevel++;
				}
				else if (kind == SymbolRecordKind::S_LPROC32_ID)
				{
					PDB_ASSERT(blockLevel == 0, "BlockLevel %u != 0", blockLevel);
					const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_LPROC32_ID.section, data.S_LPROC32_ID.offset);
					Printf(blockLevel, "S_LPROC32_ID Function '%s' | RVA 0x%X\n", data.S_LPROC32_ID.name, rva);
					blockLevel++;
				}
				else if (kind == SymbolRecordKind::S_GPROC32_ID)
				{
					PDB_ASSERT(blockLevel == 0, "BlockLevel %u != 0", blockLevel);
					const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(data.S_GPROC32_ID.section, data.S_GPROC32_ID.offset);
					Printf(blockLevel, "S_GPROC32_ID Function '%s' | RVA 0x%X\n", data.S_GPROC32_ID.name, rva);
					blockLevel++;
				}
				else if (kind == SymbolRecordKind::S_REGREL32_INDIR)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_REGREL32_INDIR.typeIndex);

					Printf(blockLevel, "S_REGREL32_INDIR: '%s' -> '%s' | Register %i | Unknown1 0x%X | Unknown2 0x%X\n",
						data.S_REGREL32_INDIR.name, typeName.c_str(),
						data.S_REGREL32_INDIR.unknown1,
						data.S_REGREL32_INDIR.unknown1);
				}
				else if (kind == SymbolRecordKind::S_REGREL32_ENCTMP)
				{
					const std::string typeName = GetVariableTypeName(typeTable, data.S_REGREL32.typeIndex);

					Printf(blockLevel, "S_REGREL32_ENCTMP: '%s' -> '%s' | Register %i | Register Offset 0x%X\n",
						data.S_REGREL32.name, typeName.c_str(),
						data.S_REGREL32.reg,
						data.S_REGREL32.offset);
				}
				else if (kind == SymbolRecordKind::S_UNAMESPACE)
				{
					Printf(blockLevel, "S_UNAMESPACE: '%s'\n", data.S_UNAMESPACE.name);
				}
				else if (kind == SymbolRecordKind::S_ARMSWITCHTABLE)
				{
					Printf(blockLevel, "S_ARMSWITCHTABLE: "
						"Switch Type: %u | Num Entries: %u | Base Section: %u | Base Offset: 0x%X | "
						"Branch Section: %u | Branch Offset: 0x%X | Table Section: %u | Table Offset: 0x%X\n",
							data.S_ARMSWITCHTABLE.switchType,
							data.S_ARMSWITCHTABLE.numEntries,
							data.S_ARMSWITCHTABLE.sectionBase,
							data.S_ARMSWITCHTABLE.offsetBase,
							data.S_ARMSWITCHTABLE.sectionBranch,
							data.S_ARMSWITCHTABLE.offsetBranch,
							data.S_ARMSWITCHTABLE.sectionTable,
							data.S_ARMSWITCHTABLE.offsetTable);
				}
				else
				{
					// We only care about records inside functions.
					if (blockLevel > 0)
					{
						PDB_ASSERT(false, "Unhandled record kind 0x%X with block level %u\n", static_cast<uint16_t>(kind), blockLevel);
					}
				}

				recordCount++;

			});
		}

		scope.Done(recordCount);
	}
}

```

`third_party/raw_pdb/src/Examples/ExampleIPI.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "ExampleTypeTable.h"
#include "PDB_RawFile.h"
#include "PDB_InfoStream.h"
#include "PDB_IPIStream.h"
#include "PDB_TPIStream.h"

static std::string GetTypeNameIPI(const TypeTable& typeTable, uint32_t typeIndex)
{
	// Defined in ExampleTypes.cpp
	extern std::string GetTypeName(const TypeTable & typeTable, uint32_t typeIndex);

	std::string typeName = GetTypeName(typeTable, typeIndex);

	// Remove any '%s' substring used to insert a variable/field name.
	const uint64_t markerPos = typeName.find("%s");
	if (markerPos != typeName.npos)
	{
		typeName.erase(markerPos, 2);
	}

	return typeName;
}

void ExampleIPI(const PDB::RawFile& rawPdbFile, const PDB::InfoStream& infoStream, const PDB::TPIStream& tpiStream, const PDB::IPIStream& ipiStream);

void ExampleIPI(const PDB::RawFile& rawPdbFile, const PDB::InfoStream& infoStream, const PDB::TPIStream& tpiStream, const PDB::IPIStream& ipiStream)
{
	if (!infoStream.HasIPIStream())
	{
		return;
	}

	TimedScope total("\nRunning example \"IPI\"");

	TimedScope typeTableScope("Create TypeTable");
	TypeTable typeTable(tpiStream);
	typeTableScope.Done();

	// prepare names stream for grabbing file paths from lines
	TimedScope namesScope("Reading names stream");
	const PDB::NamesStream namesStream = infoStream.CreateNamesStream(rawPdbFile);
	namesScope.Done();

	const uint32_t firstTypeIndex = ipiStream.GetFirstTypeIndex();

	PDB::ArrayView<const PDB::CodeView::IPI::Record*> records = ipiStream.GetTypeRecords();

	std::vector<const char*> strings;

	strings.resize(records.GetLength(), nullptr);

	size_t index = 0;

	for (const PDB::CodeView::IPI::Record* record : records)
	{
		const PDB::CodeView::IPI::RecordHeader& header = record->header;

		if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_STRING_ID)
		{
			strings[index] = record->data.LF_STRING_ID.name;
		}

		index++;
	}

	uint32_t identifier = firstTypeIndex;

	std::string typeName, parentTypeName;

	printf("\n --- IPI Records ---\n\n");

	for(const PDB::CodeView::IPI::Record* record : records)
	{
		const PDB::CodeView::IPI::RecordHeader& header = record->header;

		if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_FUNC_ID)
		{ 
			typeName = GetTypeNameIPI(typeTable, record->data.LF_FUNC_ID.typeIndex);

			printf("Kind: 'LF_FUNC_ID' Size: %i ID: %u\n", header.size, identifier);
			printf(" Scope ID: %u\n Type: '%s'\n Name: '%s'\n\n", 
				record->data.LF_FUNC_ID.scopeId, 
				typeName.c_str(), 
				record->data.LF_FUNC_ID.name);

		}
		else if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_MFUNC_ID)
		{
			typeName = GetTypeNameIPI(typeTable, record->data.LF_MFUNC_ID.typeIndex);
			parentTypeName = GetTypeNameIPI(typeTable, record->data.LF_MFUNC_ID.parentTypeIndex);

			printf("Kind: 'LF_MFUNC_ID' Size: %i ID: %u\n", header.size, identifier);
			printf(" Parent Type: '%s'\n Type: '%s'\n Name: '%s'\n\n",
				parentTypeName.c_str(),
				typeName.c_str(),
				record->data.LF_MFUNC_ID.name);

		}
		else if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_BUILDINFO)
		{
			printf("Kind: 'LF_BUILDINFO' Size: %u ID: %u\n", header.size, identifier);

			if (record->data.LF_BUILDINFO.count == 0)
			{
				continue;
			}

			printf("Strings: '%s'", strings[record->data.LF_BUILDINFO.typeIndices[0] - firstTypeIndex]);

			for (uint32_t i = 1, size = record->data.LF_BUILDINFO.count; i < size; ++i)
			{
				const uint32_t stringIndex = record->data.LF_BUILDINFO.typeIndices[i];

				if (stringIndex == 0)
				{
					printf(", ''");
				}
				else
				{
					printf(", '%s'", strings[stringIndex - firstTypeIndex]);
				}
			}

			printf("\n\n");
		}
		else if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_SUBSTR_LIST)
		{
			printf("Kind: 'LF_SUBSTR_LIST' Size: %u ID: %u\n", header.size, identifier);

			if (record->data.LF_SUBSTR_LIST.count == 0)
			{
				continue;
			}

			printf(" Strings: '%s'", strings[record->data.LF_SUBSTR_LIST.typeIndices[0] - firstTypeIndex]);

			for (uint32_t i = 1, size = record->data.LF_SUBSTR_LIST.count; i < size; ++i)
			{
				const uint32_t stringIndex = record->data.LF_SUBSTR_LIST.typeIndices[i];

				if (stringIndex == 0)
				{
					printf(", ''");
				}
				else
				{
					printf(", '%s'", strings[stringIndex - firstTypeIndex]);
				}
			}

			printf("\n\n");
		}
		else if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_STRING_ID)
		{
			printf("Kind: 'LF_STRING_ID' Size: %u ID: %u\n", header.size, identifier);

			printf(" Substring ID: %u\n Name: '%s'\n\n", record->data.LF_STRING_ID.id, record->data.LF_STRING_ID.name);
		}
		else if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_UDT_SRC_LINE)
		{
			typeName = GetTypeNameIPI(typeTable, record->data.LF_UDT_SRC_LINE.typeIndex);

			const uint32_t stringIndex = record->data.LF_UDT_SRC_LINE.stringIndex;

			printf("Kind: 'LF_UDT_SRC_LINE' Size: %u ID: %u\n", header.size, identifier);

			printf(" Type: '%s'\n Source Path: %s\n Line: %u\n\n", 
				typeName.c_str(),
				strings[stringIndex - firstTypeIndex],
				record->data.LF_UDT_SRC_LINE.line);
		}
		else if (header.kind == PDB::CodeView::IPI::TypeRecordKind::LF_UDT_MOD_SRC_LINE)
		{
			typeName = GetTypeNameIPI(typeTable, record->data.LF_UDT_MOD_SRC_LINE.typeIndex);

			const char* string = namesStream.GetFilename(record->data.LF_UDT_MOD_SRC_LINE.stringIndex);

			printf("Kind: 'LF_UDT_SRC_LINE' Size: %u ID: %u\n", header.size, identifier);

			printf(" Type: '%s'\n Source Path: %s\n Line: %u\n Module Index: %u\n\n",
				typeName.c_str(),
				string,
				record->data.LF_UDT_MOD_SRC_LINE.line,
				record->data.LF_UDT_MOD_SRC_LINE.moduleIndex);
		}
		else
		{
			printf("Kind: 0x%X Size: %u ID: %u\n\n", static_cast<uint32_t>(header.kind), header.size, identifier);
		}

		identifier++;
	}
}

```

`third_party/raw_pdb/src/Examples/ExampleLines.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "Foundation/PDB_PointerUtil.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"
#include "PDB_InfoStream.h"

#include <cstring>

namespace
{
	struct Section
	{
		uint16_t index;
		uint32_t offset;
		size_t   lineIndex;
	};

	struct Filename
	{
		uint32_t fileChecksumOffset;
		uint32_t namesFilenameOffset;
		PDB::CodeView::DBI::ChecksumKind checksumKind;
		uint8_t  checksumSize;
		uint8_t  checksum[32];
	};

	struct Line
	{
		uint32_t lineNumber;
		uint32_t codeSize;
		size_t   filenameIndex;
	};
}

void ExampleLines(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream, const PDB::InfoStream& infoStream);
void ExampleLines(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream, const PDB::InfoStream& infoStream)
{
	if (!infoStream.HasNamesStream())
	{
		printf("PDB has no '/names' stream for looking up filenames for lines, skipping \"Lines\" example.");
		return;
	}

	TimedScope total("\nRunning example \"Lines\"");

	// prepare the image section stream first. it is needed for converting section + offset into an RVA
	TimedScope sectionScope("Reading image section stream");
	const PDB::ImageSectionStream imageSectionStream = dbiStream.CreateImageSectionStream(rawPdbFile);
	sectionScope.Done();

	// prepare the module info stream for grabbing function symbols from modules
	TimedScope moduleScope("Reading module info stream");
	const PDB::ModuleInfoStream moduleInfoStream = dbiStream.CreateModuleInfoStream(rawPdbFile);
	moduleScope.Done();

	// prepare names stream for grabbing file paths from lines
	TimedScope namesScope("Reading names stream");
	const PDB::NamesStream namesStream = infoStream.CreateNamesStream(rawPdbFile);
	namesScope.Done();

	// keeping sections and lines separate, as sorting the smaller Section struct is 2x faster in release builds
	// than having all the fields in one big Line struct and sorting those.
	std::vector<Section> sections;
	std::vector<Filename> filenames;
	std::vector<Line> lines;

	{
		TimedScope scope("Storing lines from modules");

		const PDB::ArrayView<PDB::ModuleInfoStream::Module> modules = moduleInfoStream.GetModules();

		for (const PDB::ModuleInfoStream::Module& module : modules)
		{
			if (!module.HasLineStream())
			{
				continue;
			}

			const PDB::ModuleLineStream moduleLineStream = module.CreateLineStream(rawPdbFile);

			const size_t moduleFilenamesStartIndex = filenames.size();
			const PDB::CodeView::DBI::FileChecksumHeader* moduleFileChecksumHeader = nullptr;

			moduleLineStream.ForEachSection([&moduleLineStream, &namesStream, &moduleFileChecksumHeader, &sections, &filenames, &lines](const PDB::CodeView::DBI::LineSection* lineSection)
			{
				if (lineSection->header.kind == PDB::CodeView::DBI::DebugSubsectionKind::S_LINES)
				{
					moduleLineStream.ForEachLinesBlock(lineSection, 
					[&lineSection, &sections, &filenames, &lines](const PDB::CodeView::DBI::LinesFileBlockHeader* linesBlockHeader, const PDB::CodeView::DBI::Line* blocklines, const PDB::CodeView::DBI::Column* blockColumns)
					{
						if (linesBlockHeader->numLines == 0)
						{
							return;
						}

						const PDB::CodeView::DBI::Line& firstLine = blocklines[0];

						const uint16_t sectionIndex  = lineSection->linesHeader.sectionIndex;
						const uint32_t sectionOffset = lineSection->linesHeader.sectionOffset;
						const uint32_t fileChecksumOffset = linesBlockHeader->fileChecksumOffset;

						const size_t filenameIndex = filenames.size();

						// there will be duplicate filenames for any real world pdb. 
						// ideally the filenames would be stored in a map with the filename or checksum as the key.
						// but that would complicate the logic in this example and therefore just use a vector to make it easier to understand.
						filenames.push_back({ fileChecksumOffset, 0, PDB::CodeView::DBI::ChecksumKind::None, 0, {0} });

						sections.push_back({ sectionIndex, sectionOffset, lines.size() });

						// initially set code size of first line to 0, will be updated in loop below.
						lines.push_back({ firstLine.linenumStart, 0, filenameIndex });

						for(uint32_t i = 1, size = linesBlockHeader->numLines; i < size; ++i)
						{
							const PDB::CodeView::DBI::Line& line = blocklines[i];

							// calculate code size of previous line by using the current line offset.
							lines.back().codeSize = line.offset - blocklines[i-1].offset;

							sections.push_back({ sectionIndex, sectionOffset + line.offset, lines.size() });
							lines.push_back({ line.linenumStart, 0, filenameIndex });
						}

						// calc code size of last line
						lines.back().codeSize = lineSection->linesHeader.codeSize - blocklines[linesBlockHeader->numLines-1].offset;

						// columns are optional
						if (blockColumns == nullptr)
						{
							return;
						}

						for (uint32_t i = 0, size = linesBlockHeader->numLines; i < size; ++i)
						{
							const PDB::CodeView::DBI::Column& column = blockColumns[i];
							(void)column;
						}
					});
				}
				else if (lineSection->header.kind == PDB::CodeView::DBI::DebugSubsectionKind::S_FILECHECKSUMS)
				{
					// how to read checksums and their filenames from the Names Stream
					moduleLineStream.ForEachFileChecksum(lineSection, [&namesStream](const PDB::CodeView::DBI::FileChecksumHeader* fileChecksumHeader)
					{
						const char* filename = namesStream.GetFilename(fileChecksumHeader->filenameOffset);
						(void)filename;
					});

					// store the checksum header for the module, as there might be more lines after the checksums.
					// so lines will get their checksum header values assigned after processing all line sections in the module.
					PDB_ASSERT(moduleFileChecksumHeader == nullptr, "Module File Checksum Header already set");
					moduleFileChecksumHeader = &lineSection->checksumHeader;
				}
				else if (lineSection->header.kind == PDB::CodeView::DBI::DebugSubsectionKind::S_INLINEELINES)
				{
					if (lineSection->inlineeHeader.kind == PDB::CodeView::DBI::InlineeSourceLineKind::Signature)
					{
						moduleLineStream.ForEachInlineeSourceLine(lineSection, [](const PDB::CodeView::DBI::InlineeSourceLine* inlineeSourceLine)
						{
							(void)inlineeSourceLine;

						});
					}
					else
					{
						moduleLineStream.ForEachInlineeSourceLineEx(lineSection, [](const PDB::CodeView::DBI::InlineeSourceLineEx* inlineeSourceLineEx)
						{
							for (uint32_t i = 0; i < inlineeSourceLineEx->extraLines; ++i)
							{
								const uint32_t checksumOffset = inlineeSourceLineEx->extrafileChecksumOffsets[i];
								(void)checksumOffset;
							}
						});
					}
				}
				else
				{
					PDB_ASSERT(false, "Line Section kind 0x%X not handled", static_cast<uint32_t>(lineSection->header.kind));
				}
			});
	
			// assign checksum values for each filename added in this module
			for (size_t i = moduleFilenamesStartIndex, size = filenames.size(); i < size; ++i)
			{
				Filename& filename = filenames[i];

				// look up the filename's checksum header in the module's checksums section
				const PDB::CodeView::DBI::FileChecksumHeader* checksumHeader = PDB::Pointer::Offset<const PDB::CodeView::DBI::FileChecksumHeader*>(moduleFileChecksumHeader, filename.fileChecksumOffset);

				PDB_ASSERT(checksumHeader->checksumKind >= PDB::CodeView::DBI::ChecksumKind::None && 
							checksumHeader->checksumKind <= PDB::CodeView::DBI::ChecksumKind::SHA256,
							"Invalid checksum kind %u", static_cast<uint16_t>(checksumHeader->checksumKind));

				// store checksum values in filname struct
				filename.namesFilenameOffset = checksumHeader->filenameOffset;
				filename.checksumKind = checksumHeader->checksumKind;
				filename.checksumSize = checksumHeader->checksumSize;
				std::memcpy(filename.checksum, checksumHeader->checksum, checksumHeader->checksumSize);
			}
		}

		scope.Done(modules.GetLength());

		TimedScope sortScope("std::sort sections");

		// sort sections, so we can iterate over lines by address order.
		std::sort(sections.begin(), sections.end(), [](const Section& lhs, const Section& rhs)
		{
			if (lhs.index == rhs.index)
			{
				return lhs.offset < rhs.offset;
			}

			return lhs.index < rhs.index;
		});

		sortScope.Done(sections.size());

// Disabled by default, as it will print a lot of lines for large PDBs :-)
#if 0
		// DIA2Dump style lines output
		static const char hexChars[17] = "0123456789ABCDEF";
		char checksumString[128];

		printf("*** LINES RAW PDB\n");

		const char* prevFilename = nullptr;

		for (const Section& section : sections)
		{
			const Line& line = lines[section.lineIndex];
			const Filename& lineFilename = filenames[line.filenameIndex];

			const char* filename = namesStream.GetFilename(lineFilename.namesFilenameOffset);
			
			const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(section.index, section.offset);

			// only print filename for a line if it is different from the previous one.
			if (filename != prevFilename)
			{
				for (size_t i = 0, j = 0; i < lineFilename.checksumSize; i++, j+=2)
				{
					checksumString[j]   = hexChars[lineFilename.checksum[i] >> 4];
					checksumString[j+1] = hexChars[lineFilename.checksum[i] & 0xF];
				}

				checksumString[lineFilename.checksumSize * 2] = '\0';

				printf("	line %u at [0x%08X][0x%04X:0x%08X], len = 0x%X %s (0x%02X: %s)\n",
					line.lineNumber, rva, section.index, section.offset, line.codeSize,
					filename, static_cast<uint32_t>(lineFilename.checksumKind), checksumString);
	
				prevFilename = filename;
			}
			else
			{
				printf("	line %u at [0x%08X][0x%04X:0x%08X], len = 0x%X\n",
					line.lineNumber, rva, section.index, section.offset, line.codeSize);
			}
		}
#endif
	}
}

```

`third_party/raw_pdb/src/Examples/ExampleMain.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleMemoryMappedFile.h"
#include "PDB.h"
#include "PDB_RawFile.h"
#include "PDB_InfoStream.h"
#include "PDB_DBIStream.h"
#include "PDB_TPIStream.h"
#include "PDB_IPIStream.h"
#include "PDB_NamesStream.h"

namespace
{
	PDB_NO_DISCARD static bool IsError(PDB::ErrorCode errorCode)
	{
		switch (errorCode)
		{
			case PDB::ErrorCode::Success:
				return false;

			case PDB::ErrorCode::InvalidSuperBlock:
				printf("Invalid Superblock\n");
				return true;

			case PDB::ErrorCode::InvalidFreeBlockMap:
				printf("Invalid free block map\n");
				return true;

			case PDB::ErrorCode::InvalidStream:
				printf("Invalid stream\n");
				return true;

			case PDB::ErrorCode::InvalidSignature:
				printf("Invalid stream signature\n");
				return true;

			case PDB::ErrorCode::InvalidStreamIndex:
				printf("Invalid stream index\n");
				return true;

			case PDB::ErrorCode::InvalidDataSize:
				printf("Invalid data size\n");
				return true;

			case PDB::ErrorCode::UnknownVersion:
				printf("Unknown version\n");
				return true;
		}

		// only ErrorCode::Success means there wasn't an error, so all other paths have to assume there was an error
		return true;
	}

	PDB_NO_DISCARD static bool HasValidDBIStreams(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream)
	{
		// check whether the DBI stream offers all sub-streams we need
		if (IsError(dbiStream.HasValidSymbolRecordStream(rawPdbFile)))
		{
			return false;
		}

		if (IsError(dbiStream.HasValidPublicSymbolStream(rawPdbFile)))
		{
			return false;
		}

		if (IsError(dbiStream.HasValidGlobalSymbolStream(rawPdbFile)))
		{
			return false;
		}

		if (IsError(dbiStream.HasValidSectionContributionStream(rawPdbFile)))
		{
			return false;
		}

		if (IsError(dbiStream.HasValidImageSectionStream(rawPdbFile)))
		{
			return false;
		}

		return true;
	}
}


// declare all examples
extern void ExamplePDBSize(const PDB::RawFile&, const PDB::DBIStream&);
extern void ExampleTPISize(const PDB::TPIStream& tpiStream, const char* outPath);
extern void ExampleContributions(const PDB::RawFile&, const PDB::DBIStream&);
extern void ExampleSymbols(const PDB::RawFile&, const PDB::DBIStream&);
extern void ExampleFunctionSymbols(const PDB::RawFile&, const PDB::DBIStream&);
extern void ExampleFunctionVariables(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream, const PDB::TPIStream&);
extern void ExampleLines(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream, const PDB::InfoStream& infoStream);
extern void ExampleTypes(const PDB::TPIStream&);
extern void ExampleIPI(const PDB::RawFile& rawPdbFile, const PDB::InfoStream& infoStream, const PDB::TPIStream& tpiStream, const PDB::IPIStream& ipiStream);

int main(int argc, char** argv)
{
	if (argc != 2)
	{
		printf("Usage: Examples <PDB path>\nError: Incorrect usage\n");

		return 1;
	}

	printf("Opening PDB file %s\n", argv[1]);

	// try to open the PDB file and check whether all the data we need is available
	MemoryMappedFile::Handle pdbFile = MemoryMappedFile::Open(argv[1]);
	if (!pdbFile.baseAddress)
	{
		printf("Cannot memory-map file %s\n", argv[1]);

		return 1;
	}

	if (IsError(PDB::ValidateFile(pdbFile.baseAddress, pdbFile.len)))
	{
		MemoryMappedFile::Close(pdbFile);

		return 2;
	}

	const PDB::RawFile rawPdbFile = PDB::CreateRawFile(pdbFile.baseAddress);
	if (IsError(PDB::HasValidDBIStream(rawPdbFile)))
	{
		MemoryMappedFile::Close(pdbFile);

		return 3;
	}

	const PDB::InfoStream infoStream(rawPdbFile);
	if (infoStream.UsesDebugFastLink())
	{
		printf("PDB was linked using unsupported option /DEBUG:FASTLINK\n");

		MemoryMappedFile::Close(pdbFile);

		return 4;
	}

	const auto h = infoStream.GetHeader();
	printf("Version %u, signature %u, age %u, GUID %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",
		static_cast<uint32_t>(h->version), h->signature, h->age,
		h->guid.Data1, h->guid.Data2, h->guid.Data3,
		h->guid.Data4[0], h->guid.Data4[1], h->guid.Data4[2], h->guid.Data4[3], h->guid.Data4[4], h->guid.Data4[5], h->guid.Data4[6], h->guid.Data4[7]);

	const PDB::DBIStream dbiStream = PDB::CreateDBIStream(rawPdbFile);
	if (!HasValidDBIStreams(rawPdbFile, dbiStream))
	{
		MemoryMappedFile::Close(pdbFile);

		return 5;
	}

	if (IsError(PDB::HasValidTPIStream(rawPdbFile)))
	{
		MemoryMappedFile::Close(pdbFile);

		return 5;
	}
	const PDB::TPIStream tpiStream = PDB::CreateTPIStream(rawPdbFile);

	PDB::IPIStream ipiStream;

	// It's perfectly possible that an old PDB does not have an IPI stream.
	if(infoStream.HasIPIStream())
	{
		PDB::ErrorCode error = PDB::HasValidIPIStream(rawPdbFile);

		if (error != PDB::ErrorCode::InvalidStream && IsError(error))
		{
			MemoryMappedFile::Close(pdbFile);

			return 5;
		}

		ipiStream = PDB::CreateIPIStream(rawPdbFile);
	}	


	// run all examples
	ExamplePDBSize(rawPdbFile, dbiStream);
	ExampleContributions(rawPdbFile, dbiStream);
	ExampleSymbols(rawPdbFile, dbiStream);
	ExampleFunctionSymbols(rawPdbFile, dbiStream);
	ExampleFunctionVariables(rawPdbFile, dbiStream, tpiStream);
	ExampleLines(rawPdbFile, dbiStream, infoStream);
	ExampleTypes(tpiStream);
	ExampleIPI(rawPdbFile, infoStream, tpiStream, ipiStream);
	// uncomment to dump type sizes to a CSV
	// ExampleTPISize(tpiStream, "output.csv");

	MemoryMappedFile::Close(pdbFile);

	return 0;
}

```

`third_party/raw_pdb/src/Examples/ExampleMemoryMappedFile.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleMemoryMappedFile.h"


MemoryMappedFile::Handle MemoryMappedFile::Open(const char* path)
{
#ifdef _WIN32
	void* file = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, nullptr);

	if (file == INVALID_HANDLE_VALUE)
	{
		return Handle { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	void* fileMapping = CreateFileMappingW(file, nullptr, PAGE_READONLY, 0, 0, nullptr);

	if (fileMapping == nullptr)
	{
		CloseHandle(file);

		return Handle { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	void* baseAddress = MapViewOfFile(fileMapping, FILE_MAP_READ, 0, 0, 0);

	if (baseAddress == nullptr)
	{
		CloseHandle(fileMapping);
		CloseHandle(file);

		return Handle { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	BY_HANDLE_FILE_INFORMATION fileInformation;
	const bool getInformationResult = GetFileInformationByHandle(file, &fileInformation);
	if (!getInformationResult)
	{
		UnmapViewOfFile(baseAddress);
		CloseHandle(fileMapping);
		CloseHandle(file);

		return Handle { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	const size_t fileSizeHighBytes = static_cast<size_t>(fileInformation.nFileSizeHigh) << 32;
	const size_t fileSizeLowBytes = fileInformation.nFileSizeLow;
	const size_t fileSize = fileSizeHighBytes | fileSizeLowBytes;
	return Handle { file, fileMapping, baseAddress, fileSize };
#else
	struct stat fileSb;

	int file = open(path, O_RDONLY);

	if (file == INVALID_HANDLE_VALUE)
	{
		return Handle { INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	if (fstat(file, &fileSb) == -1)
	{
		close(file);

		return Handle { INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	void* baseAddress = mmap(nullptr, fileSb.st_size, PROT_READ, MAP_PRIVATE, file, 0);

	if (baseAddress == MAP_FAILED)
	{
		close(file);

		return Handle { INVALID_HANDLE_VALUE, nullptr, 0 };
	}

	return Handle { file, baseAddress, static_cast<size_t>(fileSb.st_size) };
#endif
}


void MemoryMappedFile::Close(Handle& handle)
{
#ifdef _WIN32
	UnmapViewOfFile(handle.baseAddress);
	CloseHandle(handle.fileMapping);
	CloseHandle(handle.file);

	handle.file = nullptr;
	handle.fileMapping = nullptr;
#else
	munmap(handle.baseAddress, handle.len);
	close(handle.file);

	handle.file = 0;
#endif

	handle.baseAddress = nullptr;
}

```

`third_party/raw_pdb/src/Examples/ExampleMemoryMappedFile.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#ifndef _WIN32
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define INVALID_HANDLE_VALUE ((long)-1)
#endif

namespace MemoryMappedFile
{
	struct Handle
	{
#ifdef _WIN32
		void* file;
		void* fileMapping;
#else
		int   file;
#endif
		void* baseAddress;
		size_t len;
	};

	Handle Open(const char* path);
	void Close(Handle& handle);
}

```

`third_party/raw_pdb/src/Examples/ExamplePDBSize.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"


namespace
{
	struct Stream
	{
		std::string name;
		uint32_t size;
	};
}


void ExamplePDBSize(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream);
void ExamplePDBSize(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream)
{
	TimedScope total("\nRunning example \"PDBSize\"");

	std::vector<Stream> streams;

	// print show general statistics
	printf("General\n");
	printf("-------\n");
	{
		const PDB::SuperBlock* superBlock = rawPdbFile.GetSuperBlock();
		printf("PDB page size (block size): %u\n", superBlock->blockSize);
		printf("PDB block count: %u\n", superBlock->blockCount);

		const size_t rawSize = static_cast<size_t>(superBlock->blockSize) * static_cast<size_t>(superBlock->blockCount);
		printf("PDB raw size: %zu MiB (%zu GiB)\n", rawSize >> 20u, rawSize >> 30u);
	}

	// print the sizes of all known streams
	printf("\n");
	printf("Sizes of known streams\n");
	printf("----------------------\n");
	{
		const uint32_t streamCount = rawPdbFile.GetStreamCount();
		const uint32_t tpiStreamSize = (streamCount > 2u) ? rawPdbFile.GetStreamSize(2u) : 0u;
		const uint32_t dbiStreamSize = (streamCount > 3u) ? rawPdbFile.GetStreamSize(3u) : 0u;
		const uint32_t ipiStreamSize = (streamCount > 4u) ? rawPdbFile.GetStreamSize(4u) : 0u;

		printf("TPI stream size: %u KiB (%u MiB)\n", tpiStreamSize >> 10u, tpiStreamSize >> 20u);
		printf("DBI stream size: %u KiB (%u MiB)\n", dbiStreamSize >> 10u, dbiStreamSize >> 20u);
		printf("IPI stream size: %u KiB (%u MiB)\n", ipiStreamSize >> 10u, ipiStreamSize >> 20u);

		streams.push_back(Stream { "TPI", tpiStreamSize });
		streams.push_back(Stream { "DBI", dbiStreamSize });
		streams.push_back(Stream { "IPI", ipiStreamSize });

		const uint32_t globalSymbolStreamSize = rawPdbFile.GetStreamSize(dbiStream.GetHeader().globalStreamIndex);
		const uint32_t publicSymbolStreamSize = rawPdbFile.GetStreamSize(dbiStream.GetHeader().publicStreamIndex);
		const uint32_t symbolRecordStreamSize = rawPdbFile.GetStreamSize(dbiStream.GetHeader().symbolRecordStreamIndex);

		printf("Global symbol stream size: %u KiB (%u MiB)\n", globalSymbolStreamSize >> 10u, globalSymbolStreamSize >> 20u);
		printf("Public symbol stream size: %u KiB (%u MiB)\n", publicSymbolStreamSize >> 10u, publicSymbolStreamSize >> 20u);
		printf("Symbol record stream size: %u KiB (%u MiB)\n", symbolRecordStreamSize >> 10u, symbolRecordStreamSize >> 20u);

		streams.emplace_back(Stream { "Global", globalSymbolStreamSize });
		streams.emplace_back(Stream { "Public", publicSymbolStreamSize });
		streams.emplace_back(Stream { "Symbol", symbolRecordStreamSize });
	}

	// print the sizes of all module streams
	printf("\n");
	printf("Sizes of module streams\n");
	printf("-----------------------\n");
	{
		const PDB::ModuleInfoStream moduleInfoStream = dbiStream.CreateModuleInfoStream(rawPdbFile);
		const PDB::ArrayView<PDB::ModuleInfoStream::Module> modules = moduleInfoStream.GetModules();

		for (const PDB::ModuleInfoStream::Module& module : modules)
		{
			const PDB::DBI::ModuleInfo* moduleInfo = module.GetInfo();
			const char* name = module.GetName().Decay();
			const char* objectName = module.GetObjectName().Decay();

			const uint16_t streamIndex = module.HasSymbolStream() ? moduleInfo->moduleSymbolStreamIndex : 0u;
			const uint32_t moduleStreamSize = (streamIndex != 0u) ? rawPdbFile.GetStreamSize(streamIndex) : 0u;

			printf("Module %s (%s) stream size: %u KiB (%u MiB)\n", name, objectName, moduleStreamSize >> 10u, moduleStreamSize >> 20u);

			streams.push_back(Stream { name, moduleStreamSize });
		}
	}

	// sort the streams by their size
	std::sort(streams.begin(), streams.end(), [](const Stream& lhs, const Stream& rhs)
	{
		return lhs.size > rhs.size;
	});

	// log the 20 largest stream
	{
		printf("\n");
		printf("Sizes of 20 largest streams:\n");

		const size_t countToShow = std::min<size_t>(20ul, streams.size());
		for (size_t i = 0u; i < countToShow; ++i)
		{
			const Stream& stream = streams[i];
			printf("%zu: %u KiB (%u MiB) from stream %s\n", i + 1u, stream.size >> 10u, stream.size >> 20u, stream.name.c_str());
		}
	}

	// print the raw stream sizes
	printf("\n");
	printf("Raw sizes of all streams\n");
	printf("------------------------\n");
	{
		const uint32_t streamCount = rawPdbFile.GetStreamCount();
		for (uint32_t i = 0u; i < streamCount; ++i)
		{
			const uint32_t streamSize = rawPdbFile.GetStreamSize(i);
			printf("Stream %u size: %u KiB (%u MiB)\n", i, streamSize >> 10u, streamSize >> 20u);
		}
	}
}

```

`third_party/raw_pdb/src/Examples/ExampleSymbols.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"


namespace
{
	// we don't have to store std::string in the symbols, since all the data is memory-mapped anyway.
	// we do it in this example to ensure that we don't "cheat" when reading the PDB file. memory-mapped data will only
	// be faulted into the process once it's touched, so actually copying the string data makes us touch the needed data,
	// giving us a real performance measurement.
	struct Symbol
	{
		std::string name;
		uint32_t rva;
	};
}


void ExampleSymbols(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream);
void ExampleSymbols(const PDB::RawFile& rawPdbFile, const PDB::DBIStream& dbiStream)
{
	TimedScope total("\nRunning example \"Symbols\"");

	// in order to keep the example easy to understand, we load the PDB data serially.
	// note that this can be improved a lot by reading streams concurrently.

	// prepare the image section stream first. it is needed for converting section + offset into an RVA
	TimedScope sectionScope("Reading image section stream");
	const PDB::ImageSectionStream imageSectionStream = dbiStream.CreateImageSectionStream(rawPdbFile);
	sectionScope.Done();


	// prepare the module info stream for matching contributions against files
	TimedScope moduleScope("Reading module info stream");
	const PDB::ModuleInfoStream moduleInfoStream = dbiStream.CreateModuleInfoStream(rawPdbFile);
	moduleScope.Done();


	// prepare symbol record stream needed by both public and global streams
	TimedScope symbolStreamScope("Reading symbol record stream");
	const PDB::CoalescedMSFStream symbolRecordStream = dbiStream.CreateSymbolRecordStream(rawPdbFile);
	symbolStreamScope.Done();

	std::vector<Symbol> symbols;

	// read public symbols
	TimedScope publicScope("Reading public symbol stream");
	const PDB::PublicSymbolStream publicSymbolStream = dbiStream.CreatePublicSymbolStream(rawPdbFile);
	publicScope.Done();
	{
		TimedScope scope("Storing public symbols");

		const PDB::ArrayView<PDB::HashRecord> hashRecords = publicSymbolStream.GetRecords();
		const size_t count = hashRecords.GetLength();

		symbols.reserve(count);

		for (const PDB::HashRecord& hashRecord : hashRecords)
		{
			const PDB::CodeView::DBI::Record* record = publicSymbolStream.GetRecord(symbolRecordStream, hashRecord);
			if (record->header.kind != PDB::CodeView::DBI::SymbolRecordKind::S_PUB32)
			{
				// normally, a PDB only contains S_PUB32 symbols in the public symbol stream, but we have seen PDBs that also store S_CONSTANT as public symbols.
				// ignore these.
				continue;
			}

			const uint32_t rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_PUB32.section, record->data.S_PUB32.offset);
			if (rva == 0u)
			{
				// certain symbols (e.g. control-flow guard symbols) don't have a valid RVA, ignore those
				continue;
			}

			symbols.push_back(Symbol { record->data.S_PUB32.name, rva });
		}

		scope.Done(count);
	}


	// read global symbols
	TimedScope globalScope("Reading global symbol stream");
	const PDB::GlobalSymbolStream globalSymbolStream = dbiStream.CreateGlobalSymbolStream(rawPdbFile);
	globalScope.Done();
	{
		TimedScope scope("Storing global symbols");

		const PDB::ArrayView<PDB::HashRecord> hashRecords = globalSymbolStream.GetRecords();
		const size_t count = hashRecords.GetLength();

		symbols.reserve(symbols.size() + count);

		for (const PDB::HashRecord& hashRecord : hashRecords)
		{
			const PDB::CodeView::DBI::Record* record = globalSymbolStream.GetRecord(symbolRecordStream, hashRecord);

			const char* name = nullptr;
			uint32_t rva = 0u;
			if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GDATA32)
			{
				name = record->data.S_GDATA32.name;
				rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_GDATA32.section, record->data.S_GDATA32.offset);
			}
			else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GTHREAD32)
			{
				name = record->data.S_GTHREAD32.name;
				rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_GTHREAD32.section, record->data.S_GTHREAD32.offset);
			}
			else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LDATA32)
			{
				name = record->data.S_LDATA32.name;
				rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LDATA32.section, record->data.S_LDATA32.offset);
			}
			else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LTHREAD32)
			{
				name = record->data.S_LTHREAD32.name;
				rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LTHREAD32.section, record->data.S_LTHREAD32.offset);
			}
			else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_UDT)
			{
				name = record->data.S_UDT.name;
			}
			else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_UDT_ST)
			{
				name = record->data.S_UDT_ST.name;
			}

			if (rva == 0u)
			{
				// certain symbols (e.g. control-flow guard symbols) don't have a valid RVA, ignore those
				continue;
			}

			symbols.push_back(Symbol { name, rva });
		}

		scope.Done(count);
	}


	// read module symbols
	{
		TimedScope scope("Storing symbols from modules");

		const PDB::ArrayView<PDB::ModuleInfoStream::Module> modules = moduleInfoStream.GetModules();

		for (const PDB::ModuleInfoStream::Module& module : modules)
		{
			if (!module.HasSymbolStream())
			{
				continue;
			}

			const PDB::ModuleSymbolStream moduleSymbolStream = module.CreateSymbolStream(rawPdbFile);
			moduleSymbolStream.ForEachSymbol([&symbols, &imageSectionStream](const PDB::CodeView::DBI::Record* record)
			{
				const char* name = nullptr;
				uint32_t rva = 0u;
				if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_THUNK32)
				{
					if (record->data.S_THUNK32.thunk == PDB::CodeView::DBI::ThunkOrdinal::TrampolineIncremental)
					{
						// we have never seen incremental linking thunks stored inside a S_THUNK32 symbol, but better be safe than sorry
						name = "ILT";
						rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_THUNK32.section, record->data.S_THUNK32.offset);
					}
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_TRAMPOLINE)
				{
					// incremental linking thunks are stored in the linker module
					name = "ILT";
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_TRAMPOLINE.thunkSection, record->data.S_TRAMPOLINE.thunkOffset);
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_BLOCK32)
				{
					// blocks never store a name and are only stored for indicating whether other symbols are children of this block
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LABEL32)
				{
					// labels don't have a name
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LPROC32)
				{
					name = record->data.S_LPROC32.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LPROC32.section, record->data.S_LPROC32.offset);
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GPROC32)
				{
					name = record->data.S_GPROC32.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_GPROC32.section, record->data.S_GPROC32.offset);
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LPROC32_ID)
				{
					name = record->data.S_LPROC32_ID.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LPROC32_ID.section, record->data.S_LPROC32_ID.offset);
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_GPROC32_ID)
				{
					name = record->data.S_GPROC32_ID.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_GPROC32_ID.section, record->data.S_GPROC32_ID.offset);
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_REGREL32)
				{
					name = record->data.S_REGREL32.name;
					// You can only get the address while running the program by checking the register value and adding the offset
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LDATA32)
				{
					name = record->data.S_LDATA32.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LDATA32.section, record->data.S_LDATA32.offset);
				}
				else if (record->header.kind == PDB::CodeView::DBI::SymbolRecordKind::S_LTHREAD32)
				{
					name = record->data.S_LTHREAD32.name;
					rva = imageSectionStream.ConvertSectionOffsetToRVA(record->data.S_LTHREAD32.section, record->data.S_LTHREAD32.offset);
				}

				if (rva == 0u)
				{
					// certain symbols (e.g. control-flow guard symbols) don't have a valid RVA, ignore those
					return;
				}

				symbols.push_back(Symbol { name, rva });
			});
		}

		scope.Done(modules.GetLength());
	}

	total.Done(symbols.size());
}

```

`third_party/raw_pdb/src/Examples/ExampleTimedScope.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"

namespace
{
	static unsigned int g_indent = 0u;

	static void PrintIndent(void)
	{
		printf("%.*s", g_indent * 2u, "| | | | | | | | ");
	}
}


TimedScope::TimedScope(const char* message)
	: m_begin(std::chrono::high_resolution_clock::now())
{
	PrintIndent();
	++g_indent;

	printf("%s\n", message);
}


void TimedScope::Done(void) const
{
	--g_indent;
	PrintIndent();

	const double milliSeconds = ReadMilliseconds();
	printf("---> done in %.3fms\n", milliSeconds);
}


void TimedScope::Done(size_t count) const
{
	--g_indent;
	PrintIndent();

	const double milliSeconds = ReadMilliseconds();
	printf("---> done in %.3fms (%zu elements)\n", milliSeconds, count);
}


double TimedScope::ReadMilliseconds(void) const
{
	const std::chrono::high_resolution_clock::time_point now = std::chrono::high_resolution_clock::now();
	const std::chrono::duration<double> seconds = now - m_begin;
	
	return seconds.count() * 1000.0;
}

```

`third_party/raw_pdb/src/Examples/ExampleTimedScope.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Foundation/PDB_Macros.h"
#include <chrono>


class TimedScope
{
public:
	explicit TimedScope(const char* message);

	void Done(void) const;
	void Done(size_t count) const;

private:
	double ReadMilliseconds(void) const;

	const std::chrono::high_resolution_clock::time_point m_begin;

	PDB_DISABLE_COPY_MOVE(TimedScope);
};

```

`third_party/raw_pdb/src/Examples/ExampleTypeTable.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"
#include "ExampleTypeTable.h"
#include "Foundation/PDB_Memory.h"

TypeTable::TypeTable(const PDB::TPIStream& tpiStream) PDB_NO_EXCEPT
	: typeIndexBegin(tpiStream.GetFirstTypeIndex()), typeIndexEnd(tpiStream.GetLastTypeIndex()),
	m_recordCount(tpiStream.GetTypeRecordCount())
{
	// Create coalesced stream from TPI stream, so the records can be referenced directly using pointers.
	const PDB::DirectMSFStream& directStream = tpiStream.GetDirectMSFStream();
	m_stream = PDB::CoalescedMSFStream(directStream, directStream.GetSize(), 0);

	// types in the TPI stream are accessed by their index from other streams.
	// however, the index is not stored with types in the TPI stream directly, but has to be built while walking the stream.
	// similarly, because types are variable-length records, there are no direct offsets to access individual types.
	// we therefore walk the TPI stream once, and store pointers to the records for trivial O(1) array lookup by index later.	
	m_records = PDB_NEW_ARRAY(const PDB::CodeView::TPI::Record*, m_recordCount);

	// parse the CodeView records
	uint32_t typeIndex = 0u;

	tpiStream.ForEachTypeRecordHeaderAndOffset([this, &typeIndex](const PDB::CodeView::TPI::RecordHeader& header, size_t offset)
		{
			// The header includes the record kind and size, which can be stored along with offset
			// to allow for lazy loading of the types on-demand directly from the TPIStream::GetDirectMSFStream()
			// using DirectMSFStream::ReadAtOffset(...). Thus not needing a CoalescedMSFStream to look up the types.
			(void)header;

			const PDB::CodeView::TPI::Record* record = m_stream.GetDataAtOffset<const PDB::CodeView::TPI::Record>(offset);
			m_records[typeIndex] = record;
			++typeIndex;
		});
}

TypeTable::~TypeTable() PDB_NO_EXCEPT
{
	PDB_DELETE_ARRAY(m_records);
}

```

`third_party/raw_pdb/src/Examples/ExampleTypeTable.h`:

```h
#pragma once

#include "PDB_TPIStream.h"
#include "PDB_CoalescedMSFStream.h"

class TypeTable
{
public:
	explicit TypeTable(const PDB::TPIStream& tpiStream) PDB_NO_EXCEPT;
	~TypeTable() PDB_NO_EXCEPT;

	// Returns the index of the first type, which is not necessarily zero.
	PDB_NO_DISCARD inline uint32_t GetFirstTypeIndex(void) const PDB_NO_EXCEPT
	{
		return typeIndexBegin;
	}

	// Returns the index of the last type.
	PDB_NO_DISCARD inline uint32_t GetLastTypeIndex(void) const PDB_NO_EXCEPT
	{
		return typeIndexEnd;
	}

	PDB_NO_DISCARD inline const PDB::CodeView::TPI::Record* GetTypeRecord(uint32_t typeIndex) const PDB_NO_EXCEPT
	{
		if (typeIndex < typeIndexBegin || typeIndex > typeIndexEnd)
			return nullptr;

		return m_records[typeIndex - typeIndexBegin];
	}

	// Returns a view of all type records.
	// Records identified by a type index can be accessed via "allRecords[typeIndex - firstTypeIndex]".
	PDB_NO_DISCARD inline PDB::ArrayView<const PDB::CodeView::TPI::Record*> GetTypeRecords(void) const PDB_NO_EXCEPT
	{
		return PDB::ArrayView<const PDB::CodeView::TPI::Record*>(m_records, m_recordCount);
	}

private:
	uint32_t typeIndexBegin;
	uint32_t typeIndexEnd;

	size_t m_recordCount;
	const PDB::CodeView::TPI::Record **m_records;

	PDB::CoalescedMSFStream m_stream;

	PDB_DISABLE_COPY(TypeTable);
};

```

`third_party/raw_pdb/src/Examples/ExampleTypes.cpp`:

```cpp

#include "Examples_PCH.h"
#include "ExampleTimedScope.h"
#include "ExampleTypeTable.h"
#include "PDB_RawFile.h"
#include "PDB_DBIStream.h"
#include "PDB_TPIStream.h"
#include <cstring>
#include <cinttypes>

// not all enumeration values are handled explicitly by some of the switch statements
PDB_DISABLE_WARNING_MSVC(4061)
PDB_DISABLE_WARNING_CLANG("-Wswitch-enum")

// some format strings are not string literals
PDB_DISABLE_WARNING_MSVC(4774)
PDB_DISABLE_WARNING_CLANG("-Wformat-nonliteral")

std::string GetTypeName(const TypeTable& typeTable, uint32_t typeIndex);

static uint8_t GetLeafSize(PDB::CodeView::TPI::TypeRecordKind kind)
{
	if (kind < PDB::CodeView::TPI::TypeRecordKind::LF_NUMERIC)
	{
		// No leaf can have an index less than LF_NUMERIC (0x8000)
		// so word is the value...
		return sizeof(PDB::CodeView::TPI::TypeRecordKind);
	}

	switch (kind)
	{
	case PDB::CodeView::TPI::TypeRecordKind::LF_CHAR:
		return sizeof(PDB::CodeView::TPI::TypeRecordKind) + sizeof(uint8_t);

	case PDB::CodeView::TPI::TypeRecordKind::LF_USHORT:
	case PDB::CodeView::TPI::TypeRecordKind::LF_SHORT:
		return sizeof(PDB::CodeView::TPI::TypeRecordKind) + sizeof(uint16_t);

	case PDB::CodeView::TPI::TypeRecordKind::LF_LONG:
	case PDB::CodeView::TPI::TypeRecordKind::LF_ULONG:
		return sizeof(PDB::CodeView::TPI::TypeRecordKind) + sizeof(uint32_t);

	case PDB::CodeView::TPI::TypeRecordKind::LF_QUADWORD:
	case PDB::CodeView::TPI::TypeRecordKind::LF_UQUADWORD:
		return sizeof(PDB::CodeView::TPI::TypeRecordKind) + sizeof(uint64_t);

	default:
		printf("Error! 0x%04x bogus type encountered, aborting...\n", PDB_AS_UNDERLYING(kind));
	}
	return 0;
}


static const char* GetLeafName(const char* data, PDB::CodeView::TPI::TypeRecordKind kind)
{
	return &data[GetLeafSize(kind)];
}


static const char* GetTypeName(const TypeTable& typeTable, uint32_t typeIndex, uint8_t& pointerLevel, const PDB::CodeView::TPI::Record** referencedType, const PDB::CodeView::TPI::Record** modifierRecord)
{
	const char* typeName = nullptr;
	const PDB::CodeView::TPI::Record* underlyingType = nullptr;

	if (referencedType)
		*referencedType = nullptr;

	if (modifierRecord)
		*modifierRecord = nullptr;

	auto typeIndexBegin = typeTable.GetFirstTypeIndex();
	if (typeIndex < typeIndexBegin)
	{
		auto type = static_cast<PDB::CodeView::TPI::TypeIndexKind>(typeIndex);
		switch (type)
		{
		case PDB::CodeView::TPI::TypeIndexKind::T_NOTYPE:
			return "<NO TYPE>";
		case PDB::CodeView::TPI::TypeIndexKind::T_HRESULT:
			return "HRESULT";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PHRESULT:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PHRESULT:
			return "PHRESULT";

		case PDB::CodeView::TPI::TypeIndexKind::T_UNKNOWN_0600:
			return "UNKNOWN_0x0600";

		case PDB::CodeView::TPI::TypeIndexKind::T_VOID:
			return "void";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PVOID:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PVOID:
		case PDB::CodeView::TPI::TypeIndexKind::T_PVOID:
			return "PVOID";

		case PDB::CodeView::TPI::TypeIndexKind::T_32PBOOL08:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PBOOL16:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PBOOL32:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PBOOL64:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PBOOL08:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PBOOL16:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PBOOL32:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PBOOL64:
			return "PBOOL";

		case PDB::CodeView::TPI::TypeIndexKind::T_BOOL08:
		case PDB::CodeView::TPI::TypeIndexKind::T_BOOL16:
		case PDB::CodeView::TPI::TypeIndexKind::T_BOOL32:
			return "BOOL";

		case PDB::CodeView::TPI::TypeIndexKind::T_RCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_CHAR:
			return "CHAR";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PRCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PRCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_PRCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_PCHAR:
			return "PCHAR";

		case PDB::CodeView::TPI::TypeIndexKind::T_UCHAR:
			return "UCHAR";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PUCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PUCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_PUCHAR:
			return "PUCHAR";

		case PDB::CodeView::TPI::TypeIndexKind::T_WCHAR:
			return "WCHAR";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PWCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PWCHAR:
		case PDB::CodeView::TPI::TypeIndexKind::T_PWCHAR:
			return "PWCHAR";

		case PDB::CodeView::TPI::TypeIndexKind::T_CHAR8:
			return "CHAR8";
		case PDB::CodeView::TPI::TypeIndexKind::T_PCHAR8:
		case PDB::CodeView::TPI::TypeIndexKind::T_PFCHAR8:
		case PDB::CodeView::TPI::TypeIndexKind::T_PHCHAR8:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PCHAR8:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PFCHAR8:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PCHAR8:
			return "PCHAR8";

		case PDB::CodeView::TPI::TypeIndexKind::T_CHAR16:
			return "CHAR16";
		case PDB::CodeView::TPI::TypeIndexKind::T_PCHAR16:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PCHAR16:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PCHAR16:
			return "PCHAR16";

		case PDB::CodeView::TPI::TypeIndexKind::T_CHAR32:
			return "CHAR32";
		case PDB::CodeView::TPI::TypeIndexKind::T_PCHAR32:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PCHAR32:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PCHAR32:
			return "PCHAR32";

		case PDB::CodeView::TPI::TypeIndexKind::T_SHORT:
			return "SHORT";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PSHORT:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PSHORT:
		case PDB::CodeView::TPI::TypeIndexKind::T_PSHORT:
			return "PSHORT";
		case PDB::CodeView::TPI::TypeIndexKind::T_USHORT:
			return "USHORT";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PUSHORT:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PUSHORT:
		case PDB::CodeView::TPI::TypeIndexKind::T_PUSHORT:
			return "PUSHORT";
		case PDB::CodeView::TPI::TypeIndexKind::T_LONG:
			return "LONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PLONG:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PLONG:
		case PDB::CodeView::TPI::TypeIndexKind::T_PLONG:
			return "PLONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_ULONG:
			return "ULONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PULONG:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PULONG:
		case PDB::CodeView::TPI::TypeIndexKind::T_PULONG:
			return "PULONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_REAL32:
			return "FLOAT";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PREAL32:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PREAL32:
		case PDB::CodeView::TPI::TypeIndexKind::T_PREAL32:
			return "PFLOAT";
		case PDB::CodeView::TPI::TypeIndexKind::T_REAL64:
			return "DOUBLE";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PREAL64:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PREAL64:
		case PDB::CodeView::TPI::TypeIndexKind::T_PREAL64:
			return "PDOUBLE";
		case PDB::CodeView::TPI::TypeIndexKind::T_REAL80:
			return "REAL80";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PREAL80:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PREAL80:
		case PDB::CodeView::TPI::TypeIndexKind::T_PREAL80:
			return "PREAL80";
		case PDB::CodeView::TPI::TypeIndexKind::T_QUAD:
			return "LONGLONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PQUAD:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PQUAD:
		case PDB::CodeView::TPI::TypeIndexKind::T_PQUAD:
			return "PLONGLONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_UQUAD:
			return "ULONGLONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PUQUAD:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PUQUAD:
		case PDB::CodeView::TPI::TypeIndexKind::T_PUQUAD:
			return "PULONGLONG";
		case PDB::CodeView::TPI::TypeIndexKind::T_INT4:
			return "INT";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PINT4:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PINT4:
		case PDB::CodeView::TPI::TypeIndexKind::T_PINT4:
			return "PINT";
		case PDB::CodeView::TPI::TypeIndexKind::T_UINT4:
			return "UINT";
		case PDB::CodeView::TPI::TypeIndexKind::T_32PUINT4:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PUINT4:
		case PDB::CodeView::TPI::TypeIndexKind::T_PUINT4:
			return "PUINT";

		case PDB::CodeView::TPI::TypeIndexKind::T_UINT8:
			return "UINT8";
		case PDB::CodeView::TPI::TypeIndexKind::T_PUINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_PFUINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_PHUINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PUINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PFUINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PUINT8:
			return "PUINT8";

		case PDB::CodeView::TPI::TypeIndexKind::T_INT8:
			return "INT8";
		case PDB::CodeView::TPI::TypeIndexKind::T_PINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_PFINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_PHINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PFINT8:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PINT8:
			return "PINT8";

		case PDB::CodeView::TPI::TypeIndexKind::T_OCT:
			return "OCTAL";

		case PDB::CodeView::TPI::TypeIndexKind::T_POCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_PFOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_PHOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_32POCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PFOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_64POCT:
			return "POCTAL";

		case PDB::CodeView::TPI::TypeIndexKind::T_UOCT:
			return "UOCTAL";

		case PDB::CodeView::TPI::TypeIndexKind::T_PUOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_PFUOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_PHUOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PUOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_32PFUOCT:
		case PDB::CodeView::TPI::TypeIndexKind::T_64PUOCT:
			return "PUOCTAL";

		default:
			PDB_ASSERT(false, "Unhandled special type 0x%X", typeIndex);
			return "unhandled_special_type";
		}
	}
	else
	{
		auto typeRecord = typeTable.GetTypeRecord(typeIndex);
		if (!typeRecord)
			return nullptr;

		switch (typeRecord->header.kind)
		{
		case PDB::CodeView::TPI::TypeRecordKind::LF_MODIFIER:
			if(modifierRecord)
				*modifierRecord = typeRecord;
			return GetTypeName(typeTable, typeRecord->data.LF_MODIFIER.type, pointerLevel, referencedType, nullptr);
		case PDB::CodeView::TPI::TypeRecordKind::LF_POINTER:
			++pointerLevel;
			if(referencedType)
				*referencedType = typeRecord;
			if (typeRecord->data.LF_POINTER.utype >= typeIndexBegin)
			{
				underlyingType = typeTable.GetTypeRecord(typeRecord->data.LF_POINTER.utype);
				if (!underlyingType)
					return nullptr;

				if(underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_POINTER)
					return GetTypeName(typeTable, typeRecord->data.LF_POINTER.utype, pointerLevel, referencedType, modifierRecord);

				// Type record order can be LF_POINTER -> LF_MODIFIER -> LF_POINTER -> ...
				if (underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MODIFIER)
				{
					if (modifierRecord)
						*modifierRecord = underlyingType;

					return GetTypeName(typeTable, underlyingType->data.LF_MODIFIER.type, pointerLevel, referencedType, nullptr);
				}
			}

			return GetTypeName(typeTable, typeRecord->data.LF_POINTER.utype, pointerLevel, &typeRecord, modifierRecord);
		case PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE:
			if (referencedType)
				*referencedType = typeRecord;
			return nullptr;
		case PDB::CodeView::TPI::TypeRecordKind::LF_BITFIELD:
			if (typeRecord->data.LF_BITFIELD.type < typeIndexBegin)
			{
				typeName = GetTypeName(typeTable, typeRecord->data.LF_BITFIELD.type, pointerLevel, nullptr, modifierRecord);
				if (referencedType)
					*referencedType = typeRecord;
				return typeName;
			}
			else
			{
				if (referencedType)
					*referencedType = typeRecord;
				return nullptr;
			}
		case PDB::CodeView::TPI::TypeRecordKind::LF_ARRAY:
			if (referencedType)
				*referencedType = typeRecord;
			return GetTypeName(typeTable, typeRecord->data.LF_ARRAY.elemtype, pointerLevel, &typeRecord, modifierRecord);
		case PDB::CodeView::TPI::TypeRecordKind::LF_CLASS:
		case PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE:
			return GetLeafName(typeRecord->data.LF_CLASS.data, typeRecord->header.kind);

		case PDB::CodeView::TPI::TypeRecordKind::LF_CLASS2:
		case PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE2:
			return GetLeafName(typeRecord->data.LF_CLASS2.data, typeRecord->header.kind);

		case  PDB::CodeView::TPI::TypeRecordKind::LF_UNION:
			return GetLeafName(typeRecord->data.LF_UNION.data, typeRecord->header.kind);
		case PDB::CodeView::TPI::TypeRecordKind::LF_ENUM:
			return &typeRecord->data.LF_ENUM.name[0];
		case PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION:
			if (referencedType)
				*referencedType = typeRecord;
			return nullptr;
	
		default:
			PDB_ASSERT(false, "Unhandled TypeRecordKind 0x%X", static_cast<uint16_t>(typeRecord->header.kind));
			break;
		}
	   
	}

	return "unknown_type";
}

static const char* GetModifierName(const PDB::CodeView::TPI::Record* modifierRecord)
{
	if (modifierRecord->data.LF_MODIFIER.attr.MOD_const)
		return "const";
	else if (modifierRecord->data.LF_MODIFIER.attr.MOD_volatile)
		return "volatile";
	else if (modifierRecord->data.LF_MODIFIER.attr.MOD_unaligned)
		return "unaligned";
	
	return "";
}

static bool GetMethodPrototype(const TypeTable& typeTable, const PDB::CodeView::TPI::Record* methodRecord, std::string& methodPrototype);

static bool GetFunctionPrototype(const TypeTable& typeTable, const PDB::CodeView::TPI::Record* functionRecord, std::string& functionPrototype)
{
	PDB_ASSERT(functionRecord->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE, "TPI Record kind is 0x%X, expected 0x%X (LF_PROCEDURE)",
		(uint32_t)functionRecord->header.kind, (uint32_t)PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE);

	std::string underlyingTypePrototype;

	size_t markerPos = 0;
	uint8_t pointerLevel = 0;
	const PDB::CodeView::TPI::Record* referencedType = nullptr;
	const PDB::CodeView::TPI::Record* underlyingType = nullptr;
	const PDB::CodeView::TPI::Record* modifierRecord = nullptr;

	functionPrototype.clear();

	auto typeName = GetTypeName(typeTable, functionRecord->data.LF_PROCEDURE.rvtype, pointerLevel, &referencedType, &modifierRecord);
	if (typeName)
	{
		if (modifierRecord)
		{
			functionPrototype += GetModifierName(modifierRecord);
			functionPrototype += ' ';
		}

		functionPrototype += typeName;

		for (size_t i = 0; i < pointerLevel; i++)
			functionPrototype += '*';
	}
	else
	{
		PDB_ASSERT(referencedType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_POINTER, "Referenced type kind 0x%X != LF_POINTER (0x%X)", (uint32_t)referencedType->header.kind, (uint32_t)PDB::CodeView::TPI::TypeRecordKind::LF_POINTER);

		underlyingType = typeTable.GetTypeRecord(referencedType->data.LF_POINTER.utype);
		if (!underlyingType)
			return false;

		if (underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE)
		{
			if (!GetFunctionPrototype(typeTable, underlyingType, underlyingTypePrototype))
				return false;
		}
		else if (underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION)
		{
			if (!GetMethodPrototype(typeTable, underlyingType, underlyingTypePrototype))
				return false;
		}
		else
		{
			PDB_ASSERT(false, "Unhandled underlyingType kind 0x%X", (uint32_t)underlyingType->header.kind);
		}

		markerPos = underlyingTypePrototype.find("%s");
		underlyingTypePrototype.erase(markerPos, 2);
		functionPrototype = underlyingTypePrototype;
	}

	functionPrototype += " (*%s)(";

	if (functionRecord->data.LF_PROCEDURE.parmcount)
	{
		auto argList = typeTable.GetTypeRecord(functionRecord->data.LF_PROCEDURE.arglist);
		if (!argList)
			return false;

		for (size_t i = 0; i < argList->data.LF_ARGLIST.count; i++)
		{
			pointerLevel = 0;
			typeName = GetTypeName(typeTable, argList->data.LF_ARGLIST.arg[i], pointerLevel, &referencedType, &modifierRecord);
			if (referencedType)
			{
				if (referencedType->data.LF_POINTER.utype >= typeTable.GetFirstTypeIndex())
				{
					underlyingType = typeTable.GetTypeRecord(referencedType->data.LF_POINTER.utype);
					if (!underlyingType)
						return false;
				}

				if (!underlyingType || (underlyingType->header.kind != PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE && underlyingType->header.kind != PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION))
				{
					if (modifierRecord)
					{
						functionPrototype += GetModifierName(modifierRecord);
						functionPrototype += ' ';
					}

					functionPrototype += typeName;
					functionPrototype += '*';

					if (referencedType->data.LF_POINTER.attr.isvolatile)
						functionPrototype += "volatile";
					else if (referencedType->data.LF_POINTER.attr.isconst)
						functionPrototype += "const";
				}
				else if(underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE)
				{
					if (!GetFunctionPrototype(typeTable, underlyingType, underlyingTypePrototype))
						return false;

					markerPos = underlyingTypePrototype.find("%s");
					underlyingTypePrototype.erase(markerPos, 2);

					for (size_t j = 1; j < pointerLevel; j++)
						underlyingTypePrototype.insert(markerPos, 1, '*');

					functionPrototype += underlyingTypePrototype;
				}
				else if(underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION)
				{
					functionPrototype += GetTypeName(typeTable, argList->data.LF_ARGLIST.arg[i]);
				}
			}
			else
			{
				functionPrototype += typeName;
			}

			if (i < (argList->data.LF_ARGLIST.count - 1))
				functionPrototype += ", ";
		}
	}

	functionPrototype += ')';

	return true;
}


static bool GetMethodPrototype(const TypeTable& typeTable, const PDB::CodeView::TPI::Record* methodRecord, std::string& methodPrototype)
{
	PDB_ASSERT(methodRecord->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION, "TPI Record kind is 0x%X, expected 0x%X (LF_MFUNCTION)",
		(uint32_t)methodRecord->header.kind, (uint32_t)PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION);

	std::string underlyingTypePrototype;

	size_t markerPos = 0;
	uint8_t pointerLevel = 0;
	const PDB::CodeView::TPI::Record* referencedType = nullptr;
	const PDB::CodeView::TPI::Record* underlyingType = nullptr;
	const PDB::CodeView::TPI::Record* modifierRecord = nullptr;

	methodPrototype.clear();

	auto typeName = GetTypeName(typeTable, methodRecord->data.LF_MFUNCTION.rvtype, pointerLevel, &referencedType, &modifierRecord);
	if (typeName)
	{
		if (modifierRecord)
		{
			methodPrototype += GetModifierName(modifierRecord);
			methodPrototype += ' ';
		}

		methodPrototype += typeName;

		for (size_t i = 0; i < pointerLevel; i++)
			methodPrototype += '*';
	}
	else
	{
		underlyingType = typeTable.GetTypeRecord(referencedType->data.LF_POINTER.utype);
		if (!underlyingType)
			return false;

		if (underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE)
		{
			if (!GetFunctionPrototype(typeTable, underlyingType, underlyingTypePrototype))
				return false;
		}
		else if(underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION)
		{
			if (!GetMethodPrototype(typeTable, underlyingType, underlyingTypePrototype))
				return false;
		}
		else
		{
			PDB_ASSERT(false, "Unhandled underlyingType kind 0x%X", (uint32_t)underlyingType->header.kind);
		}

		markerPos = underlyingTypePrototype.find("%s");
		underlyingTypePrototype.erase(markerPos, 2);
		methodPrototype = underlyingTypePrototype;
	}

	methodPrototype += " %s(";

	if (methodRecord->data.LF_MFUNCTION.parmcount)
	{
		auto argList = typeTable.GetTypeRecord(methodRecord->data.LF_MFUNCTION.arglist);
		if (!argList)
			return false;

		for (size_t i = 0; i < argList->data.LF_ARGLIST.count; i++)
		{
			pointerLevel = 0;
			typeName = GetTypeName(typeTable, argList->data.LF_ARGLIST.arg[i], pointerLevel, &referencedType, &modifierRecord);
			if (referencedType)
			{
				if (referencedType->data.LF_POINTER.utype >= typeTable.GetFirstTypeIndex())
				{
					underlyingType = typeTable.GetTypeRecord(referencedType->data.LF_POINTER.utype);
					if (!underlyingType)
						return false;
				}

				if (!underlyingType || (underlyingType->header.kind != PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE && underlyingType->header.kind != PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION))
				{
					if (modifierRecord)
					{
						methodPrototype += GetModifierName(modifierRecord);
						methodPrototype += ' ';
					}

					if(typeName)
						methodPrototype += typeName;
	
					methodPrototype += '*';

					if (referencedType->data.LF_POINTER.attr.isvolatile)
						methodPrototype += "volatile";
					else if (referencedType->data.LF_POINTER.attr.isconst)
						methodPrototype += "const";
				}
				else if (underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE)
				{
					if (!GetFunctionPrototype(typeTable, underlyingType, underlyingTypePrototype))
						return false;

					markerPos = underlyingTypePrototype.find("%s");
					underlyingTypePrototype.erase(markerPos, 2);

					for (size_t j = 1; j < pointerLevel; j++)
						underlyingTypePrototype.insert(markerPos, 1, '*');

					methodPrototype += underlyingTypePrototype;
				}
				else if (underlyingType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION)
				{
					methodPrototype += GetTypeName(typeTable, argList->data.LF_ARGLIST.arg[i]);
				}
			}
			else
			{
				methodPrototype += typeName;
			}

			if (i < (argList->data.LF_ARGLIST.count - 1))
				methodPrototype += ", ";
		}
	}

	methodPrototype += ')';

	return true;
}


static const char* GetMethodName(const PDB::CodeView::TPI::FieldList* fieldRecord)
{
	auto methodAttributes = static_cast<PDB::CodeView::TPI::MethodProperty>(fieldRecord->data.LF_ONEMETHOD.attributes.mprop);
	switch (methodAttributes)
	{
	case PDB::CodeView::TPI::MethodProperty::Intro:
	case PDB::CodeView::TPI::MethodProperty::PureIntro:
		return &reinterpret_cast<const char*>(fieldRecord->data.LF_ONEMETHOD.vbaseoff)[sizeof(uint32_t)];
	default:
		break;
	}

	return  &reinterpret_cast<const char*>(fieldRecord->data.LF_ONEMETHOD.vbaseoff)[0];
}


static void DisplayFields(const TypeTable& typeTable, const PDB::CodeView::TPI::Record* record)
{
	const PDB::CodeView::TPI::Record* referencedType = nullptr;
	const PDB::CodeView::TPI::Record* underlyingType = nullptr;
	const PDB::CodeView::TPI::Record* modifierRecord = nullptr;
	const char* leafName = nullptr;
	const char* typeName = nullptr;
	std::string functionPrototype;
	uint16_t offset = 0;

	auto maximumSize = record->header.size - sizeof(uint16_t);

	for (size_t i = 0; i < maximumSize;)
	{
		uint8_t pointerLevel = 0;
		auto fieldRecord = reinterpret_cast<const PDB::CodeView::TPI::FieldList*>(reinterpret_cast<const uint8_t*>(&record->data.LF_FIELD.list) + i);

		// Other kinds of records are not implemented
		PDB_ASSERT(
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_BCLASS ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VBCLASS ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_IVBCLASS ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_INDEX ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VFUNCTAB ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_NESTTYPE ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUM ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_MEMBER ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_STMEMBER ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_METHOD ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ONEMETHOD,
			"Unknown record kind %X",
			static_cast<unsigned int>(fieldRecord->kind));

		if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_MEMBER)
		{
			if (fieldRecord->data.LF_MEMBER.lfEasy.kind < PDB::CodeView::TPI::TypeRecordKind::LF_NUMERIC)
				offset = *reinterpret_cast<const uint16_t*>(&fieldRecord->data.LF_MEMBER.offset[0]);
			else
				offset = *reinterpret_cast<const uint16_t*>(&fieldRecord->data.LF_MEMBER.offset[sizeof(PDB::CodeView::TPI::TypeRecordKind)]);

			leafName = GetLeafName(fieldRecord->data.LF_MEMBER.offset, fieldRecord->data.LF_MEMBER.lfEasy.kind);

			typeName = GetTypeName(typeTable, fieldRecord->data.LF_MEMBER.index, pointerLevel, &referencedType, &modifierRecord);
			if (referencedType)
			{
				switch (referencedType->header.kind)
				{
				case PDB::CodeView::TPI::TypeRecordKind::LF_POINTER:
					if (referencedType->data.LF_POINTER.utype >= typeTable.GetFirstTypeIndex())
					{
						underlyingType = typeTable.GetTypeRecord(referencedType->data.LF_POINTER.utype);
						if (!underlyingType)
							break;

						if (underlyingType->header.kind != PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE)
						{
							if (modifierRecord)
								printf("[0x%X]%s %s", offset, GetModifierName(modifierRecord), typeName);
							else
								printf("[0x%X]%s", offset, typeName);

							for (size_t j = 0; j < pointerLevel; j++)
								printf("*");

							printf(" %s\n", leafName);
						}
						else
						{
							if (!GetFunctionPrototype(typeTable, underlyingType, functionPrototype))
								break;

							printf("[0x%X]", offset);
							printf(functionPrototype.c_str(), leafName);
							printf("\n");
						}
					}
					else
					{
						printf("[0x%X]%s", offset, typeName);

						for (size_t j = 0; j < pointerLevel; j++)
							printf("*");

						if (referencedType->data.LF_POINTER.attr.isvolatile)
							printf(" volatile");
						else if (referencedType->data.LF_POINTER.attr.isconst)
							printf(" const");

						printf(" %s\n", leafName);
					}
					break;
				case PDB::CodeView::TPI::TypeRecordKind::LF_BITFIELD:
					if (typeName)
					{
						printf("[0x%X]%s %s : %d\n",
							offset,
							typeName,
							leafName,
							referencedType->data.LF_BITFIELD.length);
					}
					else
					{
						modifierRecord = typeTable.GetTypeRecord(referencedType->data.LF_BITFIELD.type);
						if (!modifierRecord)
							break;

						printf("[0x%X]%s %s %s : %d\n",
							offset,
							GetModifierName(modifierRecord),
							GetTypeName(typeTable, modifierRecord->data.LF_MODIFIER.type, pointerLevel, nullptr, nullptr),
							leafName,
							referencedType->data.LF_BITFIELD.length);
					}
					break;
				case PDB::CodeView::TPI::TypeRecordKind::LF_ARRAY:
					if (!modifierRecord)
					{
						printf("[0x%X]%s %s[] /*0x%X*/\n",
							offset,
							typeName,
							leafName,
							*reinterpret_cast<const uint16_t*>(referencedType->data.LF_ARRAY.data));
					}
					else
					{
						printf("[0x%X]%s %s %s[] /*0x%X*/\n",
							offset,
							GetModifierName(modifierRecord),
							GetTypeName(typeTable, modifierRecord->data.LF_MODIFIER.type, pointerLevel, nullptr, nullptr),
							leafName,
							*reinterpret_cast<const uint16_t*>(referencedType->data.LF_ARRAY.data));
					}
					break;
				default:
					break;
				}
			}
			else
			{
				if (modifierRecord)
					printf("[0x%X]%s %s %s\n", offset, GetModifierName(modifierRecord), typeName, leafName);
				else
					printf("[0x%X]%s %s\n", offset, typeName, leafName);
			}
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_NESTTYPE)
		{
			leafName = &fieldRecord->data.LF_NESTTYPE.name[0];
			typeName = GetTypeName(typeTable, fieldRecord->data.LF_NESTTYPE.index, pointerLevel, &referencedType, &modifierRecord);

			printf("%s %s\n", typeName, leafName);
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_STMEMBER)
		{
			leafName = &fieldRecord->data.LF_STMEMBER.name[0];
			typeName = GetTypeName(typeTable, fieldRecord->data.LF_STMEMBER.index, pointerLevel, &referencedType, &modifierRecord);

			if (!modifierRecord)
				printf("%s %s\n", typeName, leafName);
			else
				printf("%s %s %s\n", GetModifierName(modifierRecord), typeName, leafName);
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_METHOD)
		{
			leafName = fieldRecord->data.LF_METHOD.name;

			auto methodList = typeTable.GetTypeRecord(fieldRecord->data.LF_METHOD.mList);
			if (!methodList)
				break;

			// https://github.com/microsoft/microsoft-pdb/blob/master/PDB/include/symtypeutils.h#L220
			size_t offsetInMethodList = 0;
			for (size_t j = 0; j < fieldRecord->data.LF_METHOD.count; j++)
			{
				size_t entrySize = 2 * sizeof(uint32_t);
				const PDB::CodeView::TPI::MethodListEntry* entry = (const PDB::CodeView::TPI::MethodListEntry*)(methodList->data.LF_METHODLIST.mList + offsetInMethodList);
				if (!GetMethodPrototype(typeTable, typeTable.GetTypeRecord(entry->index), functionPrototype))
					break;
				printf(functionPrototype.c_str(), leafName);
				printf("\n");
				PDB::CodeView::TPI::MethodProperty methodProp = (PDB::CodeView::TPI::MethodProperty)entry->attributes.mprop;
				if (methodProp == PDB::CodeView::TPI::MethodProperty::Intro || methodProp == PDB::CodeView::TPI::MethodProperty::PureIntro)
					entrySize += sizeof(uint32_t);
				offsetInMethodList += entrySize;
			}
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ONEMETHOD)
		{
			leafName = GetMethodName(fieldRecord);

			referencedType = typeTable.GetTypeRecord(fieldRecord->data.LF_ONEMETHOD.index);
			if (!referencedType)
				break;

			if (!GetMethodPrototype(typeTable, referencedType, functionPrototype))
				break;

			printf(functionPrototype.c_str(), leafName);
			printf("\n");
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_BCLASS)
		{
			leafName = GetLeafName(fieldRecord->data.LF_BCLASS.offset, fieldRecord->data.LF_BCLASS.lfEasy.kind);

			i += static_cast<size_t>(leafName - reinterpret_cast<const char*>(fieldRecord));
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VBCLASS || fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_IVBCLASS)
		{
			// virtual base pointer offset from address point
			// followed by virtual base offset from vbtable

			const PDB::CodeView::TPI::TypeRecordKind vbpOffsetAddressPointKind = *(const PDB::CodeView::TPI::TypeRecordKind*)(fieldRecord->data.LF_IVBCLASS.vbpOffset);
			const uint8_t vbpOffsetAddressPointSize = GetLeafSize(vbpOffsetAddressPointKind);

			const  PDB::CodeView::TPI::TypeRecordKind vbpOffsetVBTableKind = *(const PDB::CodeView::TPI::TypeRecordKind*)(fieldRecord->data.LF_IVBCLASS.vbpOffset + vbpOffsetAddressPointSize);
			const uint8_t vbpOffsetVBTableSize = GetLeafSize(vbpOffsetVBTableKind);

			i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VBCLASS);
			i += vbpOffsetAddressPointSize + vbpOffsetVBTableSize;
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_INDEX)
		{
			i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_INDEX);
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VFUNCTAB)
		{
			i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VFUNCTAB);
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else
		{
			break;
		}

		i += static_cast<size_t>(leafName - reinterpret_cast<const char*>(fieldRecord));
		i += strnlen(leafName, maximumSize - i - 1) + 1;
		i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
	}
}

// Used in ExamplesFunctionVariables
std::string GetTypeName(const TypeTable& typeTable, uint32_t typeIndex)
{
	uint8_t pointerLevel = 0;
	const PDB::CodeView::TPI::Record* referencedType = nullptr;
	const PDB::CodeView::TPI::Record* modifierRecord = nullptr;

	const char* typeName = GetTypeName(typeTable, typeIndex, pointerLevel, &referencedType, &modifierRecord);

	if (typeName == nullptr)
	{
		if (referencedType == nullptr && (typeIndex & 0x80000000) != 0)
		{
			// d3d12.pdb\1DEAE23C86E6462A86018FB180EB8E4A1, S_CALLSITE for `dynamic initializer for 'g_Telemetry'': typeIndex == 0x80900001
			char typeIndexBuf[0x0C];
			sprintf_s(typeIndexBuf, sizeof(typeIndexBuf), "%08X", typeIndex);
			return std::string("<BAD_TYPE_INDEX:0x") + typeIndexBuf + ">";
		}
		PDB_ASSERT(referencedType != nullptr, "Neither typeName nor referencedType are set.");

		if (referencedType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_POINTER)
		{
			std::string pointerType = GetTypeName(typeTable, referencedType->data.LF_POINTER.utype);

			for (size_t i = 0; i < pointerLevel; i++)
				pointerType += '*';

			return pointerType;
		}
		else if (referencedType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_ARRAY)
		{
			const std::string elementType = GetTypeName(typeTable, referencedType->data.LF_ARRAY.elemtype);
			const std::string indexType = GetTypeName(typeTable, referencedType->data.LF_ARRAY.idxtype);

			return elementType + "[" + indexType + "]";
		}
		else if (referencedType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE)
		{
			std::string functionPrototype;

			if (!GetFunctionPrototype(typeTable, referencedType, functionPrototype))
			{
				PDB_ASSERT(false, "Resolving function prototype failed");
				return "resolving function type failed";
			}

			return functionPrototype;
		}
		else if (referencedType->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION)
		{
			std::string methodPrototype;

			if (!GetMethodPrototype(typeTable, referencedType, methodPrototype))
			{
				PDB_ASSERT(false, "Resolving method prototype failed");
				return "resolving method type failed";
			}

			std::string classTypeName = GetTypeName(typeTable, referencedType->data.LF_MFUNCTION.classtype);
			classTypeName += "::*";

			const int stringLength = std::snprintf(nullptr, 0, methodPrototype.c_str(), classTypeName.c_str());
			PDB_ASSERT(stringLength > 0, "String length %i <= 0", stringLength);

			std::vector<char> resultString(static_cast<size_t>(stringLength) + 1u);

			std::snprintf(&resultString[0], resultString.size(), methodPrototype.c_str(), classTypeName.c_str());

			return std::string(resultString.data());
		}
		else
		{
			PDB_ASSERT(false, "Unhandled referencedType kind 0x%X", static_cast<uint16_t>(referencedType->header.kind));
			return "not found";
		}
	}

	return typeName;
}

static void DisplayEnumerates(const PDB::CodeView::TPI::Record* record, uint8_t underlyingTypeSize)
{
	const char* leafName = nullptr;
	uint64_t value = 0;
	const char* valuePtr = nullptr;

	auto maximumSize = record->header.size - sizeof(uint16_t);

	for (size_t i = 0; i < maximumSize;)
	{
		auto fieldRecord = reinterpret_cast<const PDB::CodeView::TPI::FieldList*>(reinterpret_cast<const uint8_t*>(&record->data.LF_FIELD.list) + i);

		leafName = GetLeafName(fieldRecord->data.LF_ENUMERATE.value, fieldRecord->data.LF_ENUMERATE.lfEasy.kind);
		
		if (fieldRecord->data.LF_ENUMERATE.lfEasy.kind < PDB::CodeView::TPI::TypeRecordKind::LF_NUMERIC)
			valuePtr = &fieldRecord->data.LF_ENUMERATE.value[0];
		else
			valuePtr = &fieldRecord->data.LF_ENUMERATE.value[sizeof(PDB::CodeView::TPI::TypeRecordKind)];

		switch (underlyingTypeSize)
		{
		case 1:
			value = *reinterpret_cast<const uint8_t*>(&fieldRecord->data.LF_ENUMERATE.value[0]);
			break;
		case 2:
			value = *reinterpret_cast<const uint16_t*>(&fieldRecord->data.LF_ENUMERATE.value[0]);
			break;
		case 4:
			value = *reinterpret_cast<const uint32_t*>(&fieldRecord->data.LF_ENUMERATE.value[0]);
			break;
		case 8:
			value = *reinterpret_cast<const uint64_t*>(&fieldRecord->data.LF_ENUMERATE.value[0]);
			break;
		default:
			break;
		}

		printf("%s = %" PRIu64 "\n", leafName, value);

		i += static_cast<size_t>(leafName - reinterpret_cast<const char*>(fieldRecord));
		i += strnlen(leafName, maximumSize - i - 1) + 1;
		i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));

		(void)valuePtr;
	}
}


void ExampleTypes(const PDB::TPIStream& tpiStream);
void ExampleTypes(const PDB::TPIStream& tpiStream)
{
	TimedScope total("\nRunning example \"Function types\"");

	TimedScope typeTableScope("Create TypeTable");
	TypeTable typeTable(tpiStream);
	typeTableScope.Done();

	for (const auto& record : typeTable.GetTypeRecords())
	{
		if ((record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_CLASS) || (record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE))
		{
			if (record->data.LF_CLASS.property.fwdref)
				continue;

			auto typeRecord = typeTable.GetTypeRecord(record->data.LF_CLASS.field);
			if (!typeRecord)
				continue;

			auto leafName = GetLeafName(record->data.LF_CLASS.data, record->data.LF_CLASS.lfEasy.kind);

			printf("struct %s\n{\n", leafName);
			
			DisplayFields(typeTable, typeRecord);

			printf("}\n");
		}
		else if (record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_UNION)
		{
			if (record->data.LF_UNION.property.fwdref)
				continue;

			auto typeRecord = typeTable.GetTypeRecord(record->data.LF_UNION.field);
			if (!typeRecord)
				continue;

			auto leafName = GetLeafName(record->data.LF_UNION.data, static_cast<PDB::CodeView::TPI::TypeRecordKind>(0));

			printf("union %s\n{\n", leafName);

			DisplayFields(typeTable, typeRecord);

			printf("}\n");
		}
		else if (record->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUM)
		{
			if (record->data.LF_ENUM.property.fwdref)
				continue;

			auto typeRecord = typeTable.GetTypeRecord(record->data.LF_ENUM.field);
			if (!typeRecord)
				continue;

			printf("enum %s\n{\n", record->data.LF_ENUM.name);

			DisplayEnumerates(typeRecord, GetLeafSize(static_cast<PDB::CodeView::TPI::TypeRecordKind>(record->data.LF_ENUM.utype)));

			printf("}\n");
		}
	}

	total.Done(tpiStream.GetTypeRecordCount());
}

template<typename T>
static void TagRecursively(const TypeTable& typeTable, uint32_t typeIndex, T setName);

#define TAG_AND_CHECK(typeIndex) if (setName(typeIndex)) TagRecursively(typeTable, typeIndex, setName)

template<typename T>
static void TagChildren(const TypeTable& typeTable, const PDB::CodeView::TPI::Record* record, T setName)
{
	const char* leafName = nullptr;

	auto maximumSize = record->header.size - sizeof(uint16_t);

	for (size_t i = 0; i < maximumSize;)
	{
		auto fieldRecord = reinterpret_cast<const PDB::CodeView::TPI::FieldList*>(reinterpret_cast<const uint8_t*>(&record->data.LF_FIELD.list) + i);

		// these are all the record kinds I have observed
		PDB_ASSERT(
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_BCLASS ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VBCLASS ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_IVBCLASS ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_INDEX ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VFUNCTAB ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_NESTTYPE ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUM ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_MEMBER ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_STMEMBER ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_METHOD ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ONEMETHOD ||
			fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUMERATE,
			"Unknown record kind %X",
			static_cast<unsigned int>(fieldRecord->kind));

		if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_MEMBER)
		{
			leafName = GetLeafName(fieldRecord->data.LF_MEMBER.offset, fieldRecord->data.LF_MEMBER.lfEasy.kind);
			TAG_AND_CHECK(fieldRecord->data.LF_MEMBER.index);
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_NESTTYPE)
		{
			leafName = &fieldRecord->data.LF_NESTTYPE.name[0];
			TAG_AND_CHECK(fieldRecord->data.LF_NESTTYPE.index);
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_STMEMBER)
		{
			leafName = &fieldRecord->data.LF_STMEMBER.name[0];
			TAG_AND_CHECK(fieldRecord->data.LF_STMEMBER.index);
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_METHOD)
		{
			leafName = fieldRecord->data.LF_METHOD.name;
			setName(fieldRecord->data.LF_METHOD.mList);

			auto methodList = typeTable.GetTypeRecord(fieldRecord->data.LF_METHOD.mList);
			if (!methodList)
				break;

			// https://github.com/microsoft/microsoft-pdb/blob/master/PDB/include/symtypeutils.h#L220
			size_t offsetInMethodList = 0;
			for (size_t j = 0; j < fieldRecord->data.LF_METHOD.count; j++)
			{
				size_t entrySize = sizeof(PDB::CodeView::TPI::MethodListEntry);
				const PDB::CodeView::TPI::MethodListEntry* entry = (const PDB::CodeView::TPI::MethodListEntry*)(methodList->data.LF_METHODLIST.mList + offsetInMethodList);
				TAG_AND_CHECK(entry->index);
				PDB::CodeView::TPI::MethodProperty methodProp = (PDB::CodeView::TPI::MethodProperty)entry->attributes.mprop;
				if (methodProp == PDB::CodeView::TPI::MethodProperty::Intro || methodProp == PDB::CodeView::TPI::MethodProperty::PureIntro)
					entrySize += sizeof(uint32_t);
				offsetInMethodList += entrySize;
			}
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ONEMETHOD)
		{
			leafName = GetMethodName(fieldRecord);
			TAG_AND_CHECK(fieldRecord->data.LF_ONEMETHOD.index);
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_BCLASS)
		{
			leafName = GetLeafName(fieldRecord->data.LF_BCLASS.offset, fieldRecord->data.LF_BCLASS.lfEasy.kind);

			i += static_cast<size_t>(leafName - reinterpret_cast<const char*>(fieldRecord));
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VBCLASS || fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_IVBCLASS)
		{
			// virtual base pointer offset from address point
			// followed by virtual base offset from vbtable

			const PDB::CodeView::TPI::TypeRecordKind vbpOffsetAddressPointKind = *(const PDB::CodeView::TPI::TypeRecordKind*)(fieldRecord->data.LF_IVBCLASS.vbpOffset);
			const uint8_t vbpOffsetAddressPointSize = GetLeafSize(vbpOffsetAddressPointKind);

			const  PDB::CodeView::TPI::TypeRecordKind vbpOffsetVBTableKind = *(const PDB::CodeView::TPI::TypeRecordKind*)(fieldRecord->data.LF_IVBCLASS.vbpOffset + vbpOffsetAddressPointSize);
			const uint8_t vbpOffsetVBTableSize = GetLeafSize(vbpOffsetVBTableKind);

			TAG_AND_CHECK(fieldRecord->data.LF_VBCLASS.vbpIndex);

			i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VBCLASS);
			i += vbpOffsetAddressPointSize + vbpOffsetVBTableSize;
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_INDEX)
		{
			// this is continued elsewhere
			setName(fieldRecord->data.LF_INDEX.type);
			auto continued = typeTable.GetTypeRecord(fieldRecord->data.LF_INDEX.type);
			if (continued)
				TagChildren(typeTable, continued, setName);

			i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_INDEX);
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_VFUNCTAB)
		{
			TAG_AND_CHECK(fieldRecord->data.LF_VFUNCTAB.type);
			i += sizeof(PDB::CodeView::TPI::FieldList::Data::LF_VFUNCTAB);
			i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
			continue;
		}
		else if (fieldRecord->kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUMERATE)
		{
			leafName = GetLeafName(fieldRecord->data.LF_ENUMERATE.value, fieldRecord->data.LF_ENUMERATE.lfEasy.kind);
		}
		else
		{
			break;
		}

		i += static_cast<size_t>(leafName - reinterpret_cast<const char*>(fieldRecord));
		i += strnlen(leafName, maximumSize - i - 1) + 1;
		i = (i + (sizeof(uint32_t) - 1)) & (0 - sizeof(uint32_t));
	}
}

template<typename T>
static void TagRecursively(const TypeTable& typeTable, uint32_t typeIndex, T setName)
{
	const PDB::CodeView::TPI::Record* record = typeTable.GetTypeRecord(typeIndex);
	if (!record)
		return;
	switch (record->header.kind)
	{
		case PDB::CodeView::TPI::TypeRecordKind::LF_ARRAY:
			TAG_AND_CHECK(record->data.LF_ARRAY.elemtype);
			TAG_AND_CHECK(record->data.LF_ARRAY.idxtype);
			break;
		case PDB::CodeView::TPI::TypeRecordKind::LF_POINTER:
			TAG_AND_CHECK(record->data.LF_POINTER.utype);
			break;
		case PDB::CodeView::TPI::TypeRecordKind::LF_MODIFIER:
			TAG_AND_CHECK(record->data.LF_MODIFIER.type);
			break;
		case PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE:
			TAG_AND_CHECK(record->data.LF_PROCEDURE.rvtype);
			TAG_AND_CHECK(record->data.LF_PROCEDURE.arglist);
			break;
		case PDB::CodeView::TPI::TypeRecordKind::LF_ARGLIST:
		{
			size_t count = record->data.LF_ARGLIST.count;
			for (size_t i = 0; i < count; i++)
			{
				uint32_t type = record->data.LF_ARGLIST.arg[i];
				TAG_AND_CHECK(type);
			}
			break;
		}
		case PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION:
			TAG_AND_CHECK(record->data.LF_MFUNCTION.rvtype);
			TAG_AND_CHECK(record->data.LF_MFUNCTION.arglist);
			TAG_AND_CHECK(record->data.LF_MFUNCTION.thistype);
			break;
		case PDB::CodeView::TPI::TypeRecordKind::LF_FIELDLIST:
			TagChildren(typeTable, record, setName);
			break;
		default:
			break;
	}
}

// This example takes a PDB's TPI stream and prints out a CSV file that contains all records in the TPI stream.
// You can use it to figure out what's taking up space in the stream.
//
// The format of the CSV is Size; Kind; Name. "Size" is the size of the record in bytes, "Kind" is the kind of
// the entry, and "Name" is a name associated with this entry.Type - definitions, member functions, and member
// lists use their type as the name. The idea is that you can bucket by "Name" to get actionable information
//and insight.
//
// The Name is set to "???" if no name was found, and it is set to "!!!" if multiple names reference the entry.
void ExampleTPISize(const PDB::TPIStream& tpiStream, const char* outPath);
void ExampleTPISize(const PDB::TPIStream& tpiStream, const char* outPath)
{
	TimedScope total("\nRunning example \"TPI Size\"");

	FILE* f;
#ifndef __unix
	fopen_s(&f, outPath, "w");
#else
	f = fopen(outPath, "w");
#endif
	PDB_ASSERT(f, "Failed to open %s for writing", outPath);

	fprintf(f, "Size;Kind;Name\n");

	TimedScope typeTableScope("Create TypeTable");
	TypeTable typeTable(tpiStream);
	typeTableScope.Done();

	std::vector<const char*> names;
	names.resize(typeTable.GetTypeRecords().GetLength());

	const size_t minIndex = typeTable.GetFirstTypeIndex();
	// sets the name of an entry and returns whether the name changed (because it wasn't set, or because we've found
	// conflicting information).
	auto setNameGlobal = [&names, minIndex](uint32_t typeIndex, const char* name) -> bool {
		if (!name || typeIndex < minIndex)
			return false;
		size_t idx = typeIndex - minIndex;
		const char* prev = names[idx];
		if (names[idx] == nullptr)
		{
			names[idx] = name;
			return true;
		}
		else
		{
			names[idx] = "!!!"; // multiple references
			return names[idx] != prev;
		}
	};

	// collect base types and propagate their name
	auto typeRecords = typeTable.GetTypeRecords();
	for (size_t i = 0, n = typeRecords.GetLength(); i < n; i++)
	{
		const PDB::CodeView::TPI::Record* record = typeRecords[i];
		PDB::CodeView::TPI::TypeRecordKind kind = record->header.kind;
		if (kind == PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE)
		{
			names[i] = GetLeafName(record->data.LF_CLASS.data, record->data.LF_CLASS.lfEasy.kind);
			auto setName = [&setNameGlobal, names, i](uint32_t typeIndex) -> bool {
				return setNameGlobal(typeIndex, names[i]);
			};
			TAG_AND_CHECK(record->data.LF_CLASS.field);
		}
		else if (kind == PDB::CodeView::TPI::TypeRecordKind::LF_CLASS)
		{
			names[i] = GetLeafName(record->data.LF_CLASS.data, record->data.LF_CLASS.lfEasy.kind);
			auto setName = [&setNameGlobal, names, i](uint32_t typeIndex) -> bool {
				return setNameGlobal(typeIndex, names[i]);
			};
			TAG_AND_CHECK(record->data.LF_CLASS.field);
		}
		else if (kind == PDB::CodeView::TPI::TypeRecordKind::LF_UNION)
		{
			names[i] = GetLeafName(record->data.LF_UNION.data, static_cast<PDB::CodeView::TPI::TypeRecordKind>(0));
			auto setName = [&setNameGlobal, names, i](uint32_t typeIndex) -> bool {
				return setNameGlobal(typeIndex, names[i]);
			};
			TAG_AND_CHECK(record->data.LF_UNION.field);
		}
		else if (kind == PDB::CodeView::TPI::TypeRecordKind::LF_ENUM)
		{
			names[i] = record->data.LF_ENUM.name;
			auto setName = [&setNameGlobal, names, i](uint32_t typeIndex) -> bool {
				return setNameGlobal(typeIndex, names[i]);
			};
			TAG_AND_CHECK(record->data.LF_ENUM.field);
		}
		else if (kind == PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION)
		{
			const char* name = names[i];
			if (!name)
			{
				const PDB::CodeView::TPI::Record* containingRecord = typeTable.GetTypeRecord((record->data.LF_MFUNCTION.classtype));
				if (containingRecord) {
					if (containingRecord->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_CLASS ||
						containingRecord->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE)
						name = GetLeafName(containingRecord->data.LF_CLASS.data, containingRecord->data.LF_CLASS.lfEasy.kind);
					else if (containingRecord->header.kind == PDB::CodeView::TPI::TypeRecordKind::LF_UNION)
						name = GetLeafName(record->data.LF_UNION.data, static_cast<PDB::CodeView::TPI::TypeRecordKind>(0));
					else
						PDB_ASSERT(false, "unsupported");
				}
			}
			auto setName = [&setNameGlobal, name](uint32_t typeIndex) -> bool {
				return setNameGlobal(typeIndex, name);
			};
			uint32_t typeIndex = (uint32_t)(minIndex + i);
			TAG_AND_CHECK(typeIndex);
		}
	}

	for (size_t i = 0, n = typeRecords.GetLength(); i < n; i++)
	{
		const PDB::CodeView::TPI::Record* record = typeRecords[i];
		const char* kindName = nullptr;
		const char* typeName = i < names.size() ? names[i] : nullptr;
		switch (record->header.kind)
		{
			case PDB::CodeView::TPI::TypeRecordKind::LF_VTSHAPE: kindName = "LF_VTSHAPE;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_POINTER: kindName = "LF_POINTER;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_MODIFIER: kindName = "LF_MODIFIER;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_PROCEDURE: kindName = "LF_PROCEDURE;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_FIELDLIST: kindName = "LF_FIELDLIST;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_LABEL: kindName = "LF_LABEL;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_ARGLIST: kindName = "LF_ARGLIST;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_BITFIELD: kindName = "LF_BITFIELD;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_METHODLIST: kindName = "LF_METHODLIST;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_ARRAY: kindName = "LF_ARRAY;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_PRECOMP: kindName = "LF_PRECOMP;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_MFUNCTION: kindName = "LF_MFUNCTION;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_STRUCTURE: kindName = "LF_STRUCTURE;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_CLASS: kindName = "LF_CLASS;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_UNION: kindName = "LF_UNION;"; break;
			case PDB::CodeView::TPI::TypeRecordKind::LF_ENUM: kindName = "LF_ENUM;"; break;
			default: break;
		}

		fprintf(f, "%hu;", 2 + record->header.size);
		if (kindName)
			fprintf(f, "%s;", kindName);
		else
			fprintf(f, "0x%04X;", static_cast<uint16_t>(record->header.kind));

		if (typeName)
			fprintf(f, "%s\n", typeName);
		else
			fprintf(f, "???\n");
	}

	fclose(f);
	total.Done(tpiStream.GetTypeRecordCount());
}
#undef TAG_AND_CHECK

```

`third_party/raw_pdb/src/Examples/Examples_PCH.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "Examples_PCH.h"

```

`third_party/raw_pdb/src/Examples/Examples_PCH.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Warnings.h"

// The following clang warnings must be disabled for the examples to build with 0 warnings
#if PDB_COMPILER_CLANG
#	pragma clang diagnostic ignored "-Wformat-nonliteral" 	// format string is not a string literal
#	pragma clang diagnostic ignored "-Wswitch-default" 		// switch' missing 'default' label
#   pragma clang diagnostic ignored "-Wcast-align"		 	// increases required alignment from X to Y
#   pragma clang diagnostic ignored "-Wold-style-cast" 		// use of old-style cast
#endif

#if PDB_COMPILER_MSVC
#	pragma warning(push, 0)
#elif PDB_COMPILER_CLANG
#	pragma clang diagnostic push
#endif

#if PDB_COMPILER_MSVC
	// we compile without exceptions
#	define _ALLOW_RTCc_IN_STL

	// triggered by Windows.h
#	pragma warning (disable : 4668)

	// triggered by xlocale in VS 2017
#	pragma warning (disable : 4625)		// copy constructor was implicitly defined as deleted
#	pragma warning (disable : 4626)		// assignment operator was implicitly defined as deleted
#	pragma warning (disable : 5026)		// move constructor was implicitly defined as deleted
#	pragma warning (disable : 5027)		// move assignment operator was implicitly defined as deleted
#	pragma warning (disable : 4774)		// format string expected in argument 1 is not a string literal
#endif

#ifdef _WIN32
#	define NOMINMAX
#	include <Windows.h>
#	undef cdecl
#endif
#	include <vector>
#	include <unordered_set>
#	include <chrono>
#	include <string>
#	include <algorithm>
#	include <cstdarg>

#if PDB_COMPILER_MSVC
#	pragma warning(pop)
#elif PDB_COMPILER_CLANG
#	pragma clang diagnostic pop
#endif

```

`third_party/raw_pdb/src/Foundation/PDB_ArrayView.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Macros.h"
#include "PDB_Assert.h"


namespace PDB
{
	// A read-only view into arrays of any type and length.
	template <typename T>
	class PDB_NO_DISCARD ArrayView
	{
	public:
		// Constructs an array view from a C array with explicit length.
		inline constexpr explicit ArrayView(const T* const array, size_t length) PDB_NO_EXCEPT
			: m_data(array)
			, m_length(length)
		{
		}

		PDB_DEFAULT_COPY_CONSTRUCTOR(ArrayView);
		PDB_DEFAULT_MOVE_CONSTRUCTOR(ArrayView);

		// Provides read-only access to the underlying array.
		PDB_NO_DISCARD inline constexpr const T* Decay(void) const PDB_NO_EXCEPT
		{
			return m_data;
		}

		// Returns the length of the view.
		PDB_NO_DISCARD inline constexpr size_t GetLength(void) const PDB_NO_EXCEPT
		{
			return m_length;
		}

		// Returns the i-th element.
		PDB_NO_DISCARD inline const T& operator[](size_t i) const PDB_NO_EXCEPT
		{
			PDB_ASSERT(i < GetLength(), "Index %zu out of bounds [0, %zu).", i, GetLength());
			return m_data[i];
		}


		// ------------------------------------------------------------------------------------------------
		// Range-based for-loop support
		// ------------------------------------------------------------------------------------------------

		PDB_NO_DISCARD inline const T* begin(void) const PDB_NO_EXCEPT
		{
			return m_data;
		}

		PDB_NO_DISCARD inline const T* end(void) const PDB_NO_EXCEPT
		{
			return m_data + m_length;
		}

	private:
		const T* const m_data;
		const size_t m_length;

		PDB_DISABLE_MOVE_ASSIGNMENT(ArrayView);
		PDB_DISABLE_COPY_ASSIGNMENT(ArrayView);
	};
}

```

`third_party/raw_pdb/src/Foundation/PDB_Assert.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Macros.h"
#include "PDB_Log.h"


PDB_PUSH_WARNING_CLANG
PDB_DISABLE_WARNING_CLANG("-Wgnu-zero-variadic-macro-arguments")
PDB_DISABLE_WARNING_CLANG("-Wreserved-identifier")

#if PDB_COMPILER_MSVC
extern "C" void __cdecl __debugbreak(void);
#	pragma intrinsic(__debugbreak)
#elif defined(__has_builtin) && __has_builtin(__builtin_debugtrap)
#	define __debugbreak()	__builtin_debugtrap()
#else
#	include <signal.h>
#	define __debugbreak()	raise(SIGTRAP)
#endif


#ifdef _DEBUG
#	define PDB_ASSERT(_condition, _msg, ...)			(_condition) ? (void)true : (PDB_LOG_ERROR(_msg, ##__VA_ARGS__), __debugbreak())
#else
#	define PDB_ASSERT(_condition, _msg, ...)			PDB_NOOP(_condition, _msg, ##__VA_ARGS__)
#endif

PDB_POP_WARNING_CLANG

```

`third_party/raw_pdb/src/Foundation/PDB_BitOperators.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Macros.h"


#define PDB_DEFINE_BIT_OPERATORS(_type)															\
	PDB_NO_DISCARD inline constexpr _type operator|(_type lhs, _type rhs) PDB_NO_EXCEPT			\
	{																							\
		return static_cast<_type>(PDB_AS_UNDERLYING(lhs) | PDB_AS_UNDERLYING(rhs));				\
	}																							\
																								\
	PDB_NO_DISCARD inline constexpr _type operator&(_type lhs, _type rhs) PDB_NO_EXCEPT			\
	{																							\
		return static_cast<_type>(PDB_AS_UNDERLYING(lhs) & PDB_AS_UNDERLYING(rhs));				\
	}																							\
																								\
	PDB_NO_DISCARD inline constexpr _type operator~(_type value) PDB_NO_EXCEPT					\
	{																							\
		return static_cast<_type>(~PDB_AS_UNDERLYING(value));									\
	}

```

`third_party/raw_pdb/src/Foundation/PDB_BitUtil.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Assert.h"

#ifdef _WIN32
	PDB_PUSH_WARNING_CLANG
	PDB_DISABLE_WARNING_CLANG("-Wreserved-identifier")

	extern "C" unsigned char _BitScanForward(unsigned long* _Index, unsigned long _Mask);

	PDB_POP_WARNING_CLANG

#	if PDB_COMPILER_MSVC
#		pragma intrinsic(_BitScanForward)
#	endif
#endif


namespace PDB
{
	namespace BitUtil
	{
		// Returns whether the given unsigned value is a power of two.
		template <typename T>
		PDB_NO_DISCARD inline constexpr bool IsPowerOfTwo(T value) PDB_NO_EXCEPT
		{
			PDB_ASSERT(value != 0u, "Invalid value.");

			return (value & (value - 1u)) == 0u;
		}


		// Rounds the given unsigned value up to the next multiple.
		template <typename T>
		PDB_NO_DISCARD inline constexpr T RoundUpToMultiple(T numToRound, T multipleOf) PDB_NO_EXCEPT
		{
			PDB_ASSERT(IsPowerOfTwo(multipleOf), "Multiple must be a power-of-two.");

			return (numToRound + (multipleOf - 1u)) & ~(multipleOf - 1u);
		}


		// Finds the position of the first set bit in the given value starting from the LSB, e.g. FindFirstSetBit(0b00000010) == 1.
		// This operation is also known as CTZ (Count Trailing Zeros).
		template <typename T>
		PDB_NO_DISCARD inline uint32_t FindFirstSetBit(T value) PDB_NO_EXCEPT;

		template <>
		PDB_NO_DISCARD inline uint32_t FindFirstSetBit(uint32_t value) PDB_NO_EXCEPT
		{
			PDB_ASSERT(value != 0u, "Invalid value.");

#ifdef _WIN32
			unsigned long result = 0ul;

			_BitScanForward(&result, value);
#else
			unsigned int result = 0u;

			result = static_cast<unsigned int>(__builtin_ffs(static_cast<int>(value)));
			if (result)
			{
				--result;
			}
#endif

			return result;
		}
	}
}

```

`third_party/raw_pdb/src/Foundation/PDB_CRT.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

// Original raw_pdb forward-declares CRT functions to avoid pulling in headers,
// but this conflicts with MinGW's headers when compiled alongside Qt.
// Include the real headers instead.
#include <cstdio>
#include <cstring>

```

`third_party/raw_pdb/src/Foundation/PDB_Forward.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once


// See Jonathan Mueller's blog for replacing std::move and std::forward:
// https://foonathan.net/2021/09/move-forward/
#define PDB_FORWARD(...)				static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)

```

`third_party/raw_pdb/src/Foundation/PDB_Log.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Macros.h"
#include "PDB_CRT.h"


PDB_PUSH_WARNING_CLANG
PDB_DISABLE_WARNING_CLANG("-Wgnu-zero-variadic-macro-arguments")

#define PDB_LOG_ERROR(_format, ...)					printf(_format, ##__VA_ARGS__)

PDB_POP_WARNING_CLANG

```

`third_party/raw_pdb/src/Foundation/PDB_Macros.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Platform.h"
#include "PDB_TypeTraits.h"


// ------------------------------------------------------------------------------------------------
// ATTRIBUTES
// ------------------------------------------------------------------------------------------------

// Indicates to the compiler that the return value of a function or class should not be ignored.
#if PDB_CPP_17
#	define PDB_NO_DISCARD									[[nodiscard]]
#else
#	define PDB_NO_DISCARD
#endif

// Indicates to the compiler that a function does not throw an exception.
#define PDB_NO_EXCEPT										noexcept


// ------------------------------------------------------------------------------------------------
// SPECIAL MEMBER FUNCTIONS
// ------------------------------------------------------------------------------------------------

// Default special member functions.
#define PDB_DEFAULT_COPY_CONSTRUCTOR(_name)					_name(const _name&) PDB_NO_EXCEPT = default
#define PDB_DEFAULT_COPY_ASSIGNMENT(_name)					_name& operator=(const _name&) PDB_NO_EXCEPT = default
#define PDB_DEFAULT_MOVE_CONSTRUCTOR(_name)					_name(_name&&) PDB_NO_EXCEPT = default
#define PDB_DEFAULT_MOVE_ASSIGNMENT(_name)					_name& operator=(_name&&) PDB_NO_EXCEPT = default

// Default copy member functions.
#define PDB_DEFAULT_COPY(_name)								PDB_DEFAULT_COPY_CONSTRUCTOR(_name); PDB_DEFAULT_COPY_ASSIGNMENT(_name)

// Default move member functions.
#define PDB_DEFAULT_MOVE(_name)								PDB_DEFAULT_MOVE_CONSTRUCTOR(_name); PDB_DEFAULT_MOVE_ASSIGNMENT(_name)

// Single macro to default all copy and move member functions.
#define PDB_DEFAULT_COPY_MOVE(_name)						PDB_DEFAULT_COPY(_name); PDB_DEFAULT_MOVE(_name)

// Disable special member functions.
#define PDB_DISABLE_COPY_CONSTRUCTOR(_name)					_name(const _name&) PDB_NO_EXCEPT = delete
#define PDB_DISABLE_COPY_ASSIGNMENT(_name)					_name& operator=(const _name&) PDB_NO_EXCEPT = delete
#define PDB_DISABLE_MOVE_CONSTRUCTOR(_name)					_name(_name&&) PDB_NO_EXCEPT = delete
#define PDB_DISABLE_MOVE_ASSIGNMENT(_name)					_name& operator=(_name&&) PDB_NO_EXCEPT = delete

// Disable copy member functions.
#define PDB_DISABLE_COPY(_name)								PDB_DISABLE_COPY_CONSTRUCTOR(_name); PDB_DISABLE_COPY_ASSIGNMENT(_name)

// Disable move member functions.
#define PDB_DISABLE_MOVE(_name)								PDB_DISABLE_MOVE_CONSTRUCTOR(_name); PDB_DISABLE_MOVE_ASSIGNMENT(_name)

// Single macro to disable all copy and move member functions.
#define PDB_DISABLE_COPY_MOVE(_name)						PDB_DISABLE_COPY(_name); PDB_DISABLE_MOVE(_name)


// ------------------------------------------------------------------------------------------------
// COMPILER WARNINGS
// ------------------------------------------------------------------------------------------------

#if PDB_COMPILER_MSVC
#	define PDB_PRAGMA(_x)									__pragma(_x)

#	define PDB_PUSH_WARNING_MSVC							PDB_PRAGMA(warning(push))
#	define PDB_SUPPRESS_WARNING_MSVC(_number)				PDB_PRAGMA(warning(suppress : _number))
#	define PDB_DISABLE_WARNING_MSVC(_number)				PDB_PRAGMA(warning(disable : _number))
#	define PDB_POP_WARNING_MSVC								PDB_PRAGMA(warning(pop))

#	define PDB_PUSH_WARNING_CLANG
#	define PDB_DISABLE_WARNING_CLANG(_diagnostic)
#	define PDB_POP_WARNING_CLANG
#elif PDB_COMPILER_CLANG
#	define PDB_PRAGMA(_x)									_Pragma(#_x)

#	define PDB_PUSH_WARNING_MSVC
#	define PDB_SUPPRESS_WARNING_MSVC(_number)
#	define PDB_DISABLE_WARNING_MSVC(_number)
#	define PDB_POP_WARNING_MSVC

#	define PDB_PUSH_WARNING_CLANG							PDB_PRAGMA(clang diagnostic push)
#	define PDB_DISABLE_WARNING_CLANG(_diagnostic)			PDB_PRAGMA(clang diagnostic ignored _diagnostic)
#	define PDB_POP_WARNING_CLANG							PDB_PRAGMA(clang diagnostic pop)
#elif PDB_COMPILER_GCC
#	define PDB_PRAGMA(_x)									_Pragma(#_x)

#	define PDB_PUSH_WARNING_MSVC
#	define PDB_SUPPRESS_WARNING_MSVC(_number)
#	define PDB_DISABLE_WARNING_MSVC(_number)
#	define PDB_POP_WARNING_MSVC

#	define PDB_PUSH_WARNING_CLANG
#	define PDB_DISABLE_WARNING_CLANG(_diagnostic)
#	define PDB_POP_WARNING_CLANG
#endif


// ------------------------------------------------------------------------------------------------
// MISCELLANEOUS
// ------------------------------------------------------------------------------------------------

// Trick to make other macros require a semicolon at the end.
#define PDB_REQUIRE_SEMICOLON								static_assert(true, "")

// Defines a C-like flexible array member.
#define PDB_FLEXIBLE_ARRAY_MEMBER(_type, _name)				\
	PDB_PUSH_WARNING_MSVC									\
	PDB_PUSH_WARNING_CLANG									\
	PDB_DISABLE_WARNING_MSVC(4200)							\
	PDB_DISABLE_WARNING_CLANG("-Wzero-length-array")		\
	_type _name[0];											\
	PDB_POP_WARNING_MSVC									\
	PDB_POP_WARNING_CLANG									\
	PDB_REQUIRE_SEMICOLON

// Casts any value to the value of the underlying type.
#define PDB_AS_UNDERLYING(_value)							static_cast<typename PDB::underlying_type<decltype(_value)>::type>(_value)

// Signals to the compiler that a function should be ignored, but have its argument list parsed (and "used", so as to not generate "unused variable" warnings).
#if PDB_COMPILER_MSVC
#	define PDB_NOOP											__noop
#else
#	define PDB_NOOP(...)									(void)sizeof(__VA_ARGS__)
#endif

```

`third_party/raw_pdb/src/Foundation/PDB_Memory.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once


#define PDB_NEW(_type)							new _type
#define PDB_NEW_ARRAY(_type, _length)			new _type[_length]

#define PDB_DELETE(_ptr)						delete _ptr
#define PDB_DELETE_ARRAY(_ptr)					delete[] _ptr

```

`third_party/raw_pdb/src/Foundation/PDB_Move.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_TypeTraits.h"


// See Jonathan Mueller's blog for replacing std::move and std::forward:
// https://foonathan.net/2020/09/move-forward/
#define PDB_MOVE(...)		static_cast<PDB::remove_reference<decltype(__VA_ARGS__)>::type&&>(__VA_ARGS__)

```

`third_party/raw_pdb/src/Foundation/PDB_Platform.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once


// determine the compiler/toolchain used
#if defined(__clang__)
#	define PDB_COMPILER_MSVC				0
#	define PDB_COMPILER_CLANG				1
#	define PDB_COMPILER_GCC					0
#elif defined(_MSC_VER)
#	define PDB_COMPILER_MSVC				1
#	define PDB_COMPILER_CLANG				0
#	define PDB_COMPILER_GCC					0
#elif defined(__GNUC__)
#	define PDB_COMPILER_MSVC				0
#	define PDB_COMPILER_CLANG				0
#	define PDB_COMPILER_GCC					1
#else
#	error("Unknown compiler.");
#endif

// check whether C++17 is available
#if __cplusplus >= 201703L
#	define PDB_CPP_17						1
#else
#	define PDB_CPP_17						0
#endif

// define used standard types
typedef decltype(sizeof(0)) size_t;
static_assert(sizeof(sizeof(0)) == sizeof(size_t), "Wrong size.");

typedef int int32_t;
static_assert(sizeof(int32_t) == 4u, "Wrong size.");

typedef unsigned char uint8_t;
static_assert(sizeof(uint8_t) == 1u, "Wrong size.");

typedef unsigned short uint16_t;
static_assert(sizeof(uint16_t) == 2u, "Wrong size.");

typedef unsigned int uint32_t;
static_assert(sizeof(uint32_t) == 4u, "Wrong size.");

```

`third_party/raw_pdb/src/Foundation/PDB_PointerUtil.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Macros.h"
#include "PDB_TypeTraits.h"


namespace PDB
{
	namespace Pointer
	{
		// Offsets any pointer by a given number of bytes.
		template <typename T, typename U, typename V>
		PDB_NO_DISCARD inline T Offset(U* anyPointer, V howManyBytes) PDB_NO_EXCEPT
		{
			static_assert(PDB::is_pointer<T>::value == true, "Type T must be a pointer type.");

			union
			{
				T as_T;
				U* as_U_ptr;
				char* as_char_ptr;
			};

			as_U_ptr = anyPointer;
			as_char_ptr += howManyBytes;

			return as_T;
		}
	}
}

```

`third_party/raw_pdb/src/Foundation/PDB_TypeTraits.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once


// provide our own type traits to avoid pulling in unnecessary includes
namespace PDB
{
	template <class T>
	struct is_pointer
	{
		static constexpr bool value = false;
	};

	template <class T>
	struct is_pointer<T*>
	{
		static constexpr bool value = true;
	};

	template <class T>
	struct is_pointer<T* const>
	{
		static constexpr bool value = true;
	};

	template <class T>
	struct is_pointer<T* volatile>
	{
		static constexpr bool value = true;
	};

	template <class T>
	struct is_pointer<T* const volatile>
	{
		static constexpr bool value = true;
	};


	template <class T>
	struct remove_reference
	{
		using type = T;
	};

	template <class T>
	struct remove_reference<T&>
	{
		using type = T;
	};

	template <class T>
	struct remove_reference<T&&>
	{
		using type = T;
	};


	template <class T>
	struct underlying_type
	{
		using type = __underlying_type(T);
	};
}

```

`third_party/raw_pdb/src/Foundation/PDB_Warnings.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "PDB_Platform.h"

#if PDB_COMPILER_MSVC
	// some warnings were introduced with different versions of Visual Studio, so we disable this warning instead of using a bunch of #if/#endif
#	pragma warning (disable : 4619)		// there is no warning number N

	// we compile with exceptions disabled
#	pragma warning (disable : 4530)		// C++ exception handler used, but unwind semantics are not enabled.Specify / EHsc
#	pragma warning (disable : 4577)		// 'noexcept' used with no exception handling mode specified; termination on exception is not guaranteed. Specify /EHsc

	// ignore purely informational warnings
#	pragma warning (disable : 4514)		// unreferenced inline function has been removed
#	pragma warning (disable : 4710)		// function not inlined
#	pragma warning (disable : 4711)		// function selected for automatic inline expansion
#	pragma warning (disable : 4820)		// 'N' bytes padding added after data member 'm_member'
#	pragma warning (disable : 5045)		// Compiler will insert Spectre mitigation for memory load if /Qspectre switch specified
#elif PDB_COMPILER_CLANG
	// turn on absolutely all available Clang warnings
#	pragma clang diagnostic warning "-Wall"
#	pragma clang diagnostic warning "-Wextra"
#	pragma clang diagnostic warning "-Weverything"
#	pragma clang diagnostic warning "-Wpedantic"

	// these warnings contradict -Weverything
#	pragma clang diagnostic ignored "-Wc++98-compat"
#	pragma clang diagnostic ignored "-Wc++98-compat-pedantic"

	// this warning is triggered for templates which are explicitly instantiated.
	// forgetting to instantiate the template would trigger a linker error anyway, so we disable this warning.
#	pragma clang diagnostic ignored "-Wundefined-func-template"

	// we don't strive for C++20 compatibility
#	pragma clang diagnostic ignored "-Wc++20-compat"

	// some structures will have to be padded
#	pragma clang diagnostic ignored "-Wpadded"

	// it's impossible to write C++ code using raw pointers without triggering this warning
#	pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif

```

`third_party/raw_pdb/src/PDB.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB.h"
#include "PDB_Types.h"
#include "PDB_Util.h"
#include "PDB_RawFile.h"
#include "Foundation/PDB_PointerUtil.h"
#include "Foundation/PDB_CRT.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::ValidateFile(const void* data, size_t size) PDB_NO_EXCEPT
{
	// validate whether there is enough size for the super block
	if (size < sizeof(SuperBlock))
	{
		return ErrorCode::InvalidDataSize;
	}
	// validate the super block
	const SuperBlock* superBlock = Pointer::Offset<const SuperBlock*>(data, 0u);
	{
		// validate header magic
		if (memcmp(superBlock->fileMagic, SuperBlock::MAGIC, sizeof(SuperBlock::MAGIC)) != 0)
		{
			return ErrorCode::InvalidSuperBlock;
		}

		// validate whether enough size is provided for the PDB file
		// blockCount * blockSize is the size of the PDB file on disk
		if (size < superBlock->blockCount * superBlock->blockSize)
		{
			return ErrorCode::InvalidDataSize;
		}

		// validate free block map.
		// the free block map should always reside at either index 1 or 2.
		if (superBlock->freeBlockMapIndex != 1u && superBlock->freeBlockMapIndex != 2u)
		{
			return ErrorCode::InvalidFreeBlockMap;
		}
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::RawFile PDB::CreateRawFile(const void* data) PDB_NO_EXCEPT
{
	return RawFile(data);
}

```

`third_party/raw_pdb/src/PDB.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "PDB_ErrorCodes.h"


// https://llvm.org/docs/PDB/index.html
namespace PDB
{
	class RawFile;


	// Validates whether a PDB file is valid.
	PDB_NO_DISCARD ErrorCode ValidateFile(const void* data, size_t size) PDB_NO_EXCEPT;

	// Creates a raw PDB file that must have been validated.
	PDB_NO_DISCARD RawFile CreateRawFile(const void* data) PDB_NO_EXCEPT;
}

```

`third_party/raw_pdb/src/PDB_CoalescedMSFStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_CoalescedMSFStream.h"
#include "PDB_Util.h"
#include "PDB_DirectMSFStream.h"
#include "Foundation/PDB_PointerUtil.h"
#include "Foundation/PDB_Memory.h"
#include "Foundation/PDB_CRT.h"


namespace
{
	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static bool AreBlockIndicesContiguous(const uint32_t* blockIndices, uint32_t blockSize, uint32_t streamSize) PDB_NO_EXCEPT
	{
		const uint32_t blockCount = PDB::ConvertSizeToBlockCount(streamSize, blockSize);

		// start with the first index, checking if all following indices are contiguous (N, N+1, N+2, ...)
		uint32_t expectedIndex = blockIndices[0];
		for (uint32_t i = 1u; i < blockCount; ++i)
		{
			++expectedIndex;
			if (blockIndices[i] != expectedIndex)
			{
				return false;
			}
		}

		return true;
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::CoalescedMSFStream::CoalescedMSFStream(void) PDB_NO_EXCEPT
	: m_ownedData(nullptr)
	, m_data(nullptr)
	, m_size(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::CoalescedMSFStream::CoalescedMSFStream(CoalescedMSFStream&& other) PDB_NO_EXCEPT
	: m_ownedData(PDB_MOVE(other.m_ownedData))
	, m_data(PDB_MOVE(other.m_data))
	, m_size(PDB_MOVE(other.m_size))
{
	other.m_ownedData = nullptr;
	other.m_data = nullptr;
	other.m_size = 0u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::CoalescedMSFStream& PDB::CoalescedMSFStream::operator=(CoalescedMSFStream&& other) PDB_NO_EXCEPT
{
	if (this != &other)
	{
		PDB_DELETE_ARRAY(m_ownedData);

		m_ownedData = PDB_MOVE(other.m_ownedData);
		m_data = PDB_MOVE(other.m_data);
		m_size = PDB_MOVE(other.m_size);

		other.m_ownedData = nullptr;
		other.m_data = nullptr;
		other.m_size = 0u;
	}

	return *this;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::CoalescedMSFStream::CoalescedMSFStream(const void* data, uint32_t blockSize, const uint32_t* blockIndices, uint32_t streamSize) PDB_NO_EXCEPT
	: m_ownedData(nullptr)
	, m_data(nullptr)
	, m_size(streamSize)
{
	if (AreBlockIndicesContiguous(blockIndices, blockSize, streamSize))
	{
		// fast path, all block indices are contiguous, so we don't have to copy any data at all.
		// instead, we directly point into the memory-mapped file at the correct offset.
		const uint32_t index = blockIndices[0];
		const size_t fileOffset = PDB::ConvertBlockIndexToFileOffset(index, blockSize);
		m_data = Pointer::Offset<const Byte*>(data, fileOffset);
	}
	else
	{
		// slower path, we need to copy disjunct blocks into our own data array, block by block
		m_ownedData = PDB_NEW_ARRAY(Byte, streamSize);
		m_data = m_ownedData;

		Byte* destination = m_ownedData;

		// copy full blocks first
		const uint32_t fullBlockCount = streamSize / blockSize;
		for (uint32_t i = 0u; i < fullBlockCount; ++i)
		{
			const uint32_t index = blockIndices[i];

			// read one single block at the correct offset in the stream
			const size_t fileOffset = PDB::ConvertBlockIndexToFileOffset(index, blockSize);
			const void* sourceData = Pointer::Offset<const void*>(data, fileOffset);
			memcpy(destination, sourceData, blockSize);

			destination += blockSize;
		}

		// account for non-full blocks
		const uint32_t remainingBytes = streamSize - (fullBlockCount * blockSize);
		if (remainingBytes != 0u)
		{
			const uint32_t index = blockIndices[fullBlockCount];

			// read remaining bytes at correct offset in the stream
			const size_t fileOffset = PDB::ConvertBlockIndexToFileOffset(index, blockSize);
			const void* sourceData = Pointer::Offset<const void*>(data, fileOffset);
			memcpy(destination, sourceData, remainingBytes);
		}
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::CoalescedMSFStream::CoalescedMSFStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT
	: m_ownedData(nullptr)
	, m_data(nullptr)
	, m_size(size)
{
	const DirectMSFStream::IndexAndOffset indexAndOffset = directStream.GetBlockIndexForOffset(offset);

	// Note: we need to add the offset within the block to the size of the stream to determine if the block
	// indices are contiguous. This is needed to deal with the case where reading the requested number of bytes
	// from the specified offset would cross a block boundary. For example, if the offset within the block is
	// 64 and we want to read 4096 bytes with a block size of 4096, we need to consider *two* block indices,
	// not *one*, even though 4096 / 4096 = 1.
	if (AreBlockIndicesContiguous(directStream.GetBlockIndices() + indexAndOffset.index, directStream.GetBlockSize(), indexAndOffset.offsetWithinBlock + size))
	{
		// fast path, all block indices inside the direct stream from (data + offset) to (data + offset + size) are contiguous
		const size_t offsetWithinData = directStream.GetDataOffsetForIndexAndOffset(indexAndOffset);
		m_data = Pointer::Offset<const Byte*>(directStream.GetData(), offsetWithinData);
	}
	else
	{
		// slower path, we need to copy from disjunct blocks, which is performed by the direct stream
		m_ownedData = PDB_NEW_ARRAY(Byte, size);
		m_data = m_ownedData;

		directStream.ReadAtOffset(m_ownedData, size, offset);
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::CoalescedMSFStream::~CoalescedMSFStream(void) PDB_NO_EXCEPT
{
	PDB_DELETE_ARRAY(m_ownedData);
}

```

`third_party/raw_pdb/src/PDB_CoalescedMSFStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Assert.h"
#include "Foundation/PDB_Macros.h"
#include "PDB_Types.h"

// https://llvm.org/docs/PDB/index.html#the-msf-container
// https://llvm.org/docs/PDB/MsfFile.html
namespace PDB
{
	class PDB_NO_DISCARD DirectMSFStream;


	// provides access to a coalesced version of an MSF stream.
	// inherently thread-safe, the stream doesn't carry any internal offset or similar.
	// coalesces all blocks into a contiguous stream of data upon construction.
	// very fast individual reads, useful when almost all data of a stream is needed anyway.
	class PDB_NO_DISCARD CoalescedMSFStream
	{
	public:
		CoalescedMSFStream(void) PDB_NO_EXCEPT;
		CoalescedMSFStream(CoalescedMSFStream&& other) PDB_NO_EXCEPT;
		CoalescedMSFStream& operator=(CoalescedMSFStream&& other) PDB_NO_EXCEPT;

		explicit CoalescedMSFStream(const void* data, uint32_t blockSize, const uint32_t* blockIndices, uint32_t streamSize) PDB_NO_EXCEPT;

		// Creates a coalesced stream from a direct stream at any offset.
		explicit CoalescedMSFStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT;

		~CoalescedMSFStream(void) PDB_NO_EXCEPT;

		// Returns the size of the stream.
		PDB_NO_DISCARD inline size_t GetSize(void) const PDB_NO_EXCEPT
		{
			return m_size;
		}

		// Provides read-only access to the data.
		template <typename T>
		PDB_NO_DISCARD inline const T* GetDataAtOffset(size_t offset) const PDB_NO_EXCEPT
		{
			return reinterpret_cast<const T*>(m_data + offset);
		}

		template <typename T>
		PDB_NO_DISCARD inline size_t GetPointerOffset(const T* pointer) const PDB_NO_EXCEPT
		{
			const Byte* bytePointer = reinterpret_cast<const Byte*>(pointer);
			const Byte* dataEnd = m_data + m_size;

			PDB_ASSERT(bytePointer >= m_data && bytePointer <= dataEnd, "Pointer 0x%p not within stream range [0x%p:0x%p]",
				static_cast<const void*>(bytePointer), static_cast<const void*>(m_data), static_cast<const void*>(dataEnd));

			return static_cast<size_t>(bytePointer - m_data);
		}

	private:
		// contiguous, coalesced data, can be null
		Byte* m_ownedData;

		// either points to the owned data that has been copied from disjunct blocks, or points to the
		// memory-mapped data directly in case all stream blocks are contiguous.
		const Byte* m_data;
		size_t m_size;

		PDB_DISABLE_COPY(CoalescedMSFStream);
	};
}

```

`third_party/raw_pdb/src/PDB_DBIStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_DBIStream.h"
#include "PDB_RawFile.h"


namespace
{
	// the DBI stream always resides at index 3
	static constexpr const uint32_t DBIStreamIndex = 3u;


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetModuleInfoSubstreamOffset(const PDB::DBI::StreamHeader& /* dbiHeader */) PDB_NO_EXCEPT
	{
		return sizeof(PDB::DBI::StreamHeader);
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetSectionContributionSubstreamOffset(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return GetModuleInfoSubstreamOffset(dbiHeader) + dbiHeader.moduleInfoSize;
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetSectionMapSubstreamOffset(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return GetSectionContributionSubstreamOffset(dbiHeader) + dbiHeader.sectionContributionSize;
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetSourceInfoSubstreamOffset(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return GetSectionMapSubstreamOffset(dbiHeader) + dbiHeader.sectionMapSize;
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetTypeServerMapSubstreamOffset(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return GetSourceInfoSubstreamOffset(dbiHeader) + dbiHeader.sourceInfoSize;
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetECSubstreamOffset(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return GetTypeServerMapSubstreamOffset(dbiHeader) + dbiHeader.typeServerMapSize;
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline uint32_t GetDebugHeaderSubstreamOffset(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return GetECSubstreamOffset(dbiHeader) + dbiHeader.ecSize;
	}


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline bool HasDebugHeaderSubstream(const PDB::DBI::StreamHeader& dbiHeader) PDB_NO_EXCEPT
	{
		return dbiHeader.optionalDebugHeaderSize != 0u;
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::DBIStream::DBIStream(void) PDB_NO_EXCEPT
	: m_header()
	, m_stream()
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::DBIStream::DBIStream(const RawFile& file, const DBI::StreamHeader& header) PDB_NO_EXCEPT
	: m_header(header)
	, m_stream(file.CreateMSFStream<DirectMSFStream>(DBIStreamIndex))
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::HasValidDBIStream(const RawFile& file) PDB_NO_EXCEPT
{
	DirectMSFStream stream = file.CreateMSFStream<DirectMSFStream>(DBIStreamIndex);
	if (stream.GetSize() < sizeof(DBI::StreamHeader))
	{
		return ErrorCode::InvalidStream;
	}

	const DBI::StreamHeader header = stream.ReadAtOffset<DBI::StreamHeader>(0u);
	if (header.signature != DBI::StreamHeader::Signature)
	{
		return ErrorCode::InvalidSignature;
	}
	else if (header.version != DBI::StreamHeader::Version::V70)
	{
		return ErrorCode::UnknownVersion;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::DBIStream PDB::CreateDBIStream(const RawFile& file) PDB_NO_EXCEPT
{
	DirectMSFStream stream = file.CreateMSFStream<DirectMSFStream>(DBIStreamIndex);
	const DBI::StreamHeader header = stream.ReadAtOffset<DBI::StreamHeader>(0u);

	return DBIStream { file, header };
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::DBIStream::HasValidSymbolRecordStream(const RawFile& /* file */) const PDB_NO_EXCEPT
{
	return (m_header.symbolRecordStreamIndex != PDB::NilStreamIndex) ? ErrorCode::Success : ErrorCode::InvalidStreamIndex;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::DBIStream::HasValidImageSectionStream(const RawFile& /* file */) const PDB_NO_EXCEPT
{
	// the debug header stream is optional. if it's not there, we can't get the image section stream either.
	if (!HasDebugHeaderSubstream(m_header))
	{
		return ErrorCode::InvalidStreamIndex;
	}

	// find the debug header sub-stream
	const uint32_t debugHeaderOffset = GetDebugHeaderSubstreamOffset(m_header);

	// validate that we have enough data to read the debug header
	// (the header field optionalDebugHeaderSize might claim there's a debug header,
	// but the stream might not have enough data - this happens with some .ni.pdb files)
	if (debugHeaderOffset + sizeof(DBI::DebugHeader) > m_stream.GetSize())
	{
		return ErrorCode::InvalidStream;
	}

	const DBI::DebugHeader& debugHeader = m_stream.ReadAtOffset<DBI::DebugHeader>(debugHeaderOffset);

	if (debugHeader.sectionHeaderStreamIndex == DBI::DebugHeader::InvalidStreamIndex)
	{
		return ErrorCode::InvalidStreamIndex;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::DBIStream::HasValidPublicSymbolStream(const RawFile& file) const PDB_NO_EXCEPT
{
	if (m_header.publicStreamIndex == PDB::NilStreamIndex)
	{
		return ErrorCode::InvalidStreamIndex;
	}

	DirectMSFStream publicStream = file.CreateMSFStream<DirectMSFStream>(m_header.publicStreamIndex);

	// the public symbol stream always begins with a header, we are not interested in that.
	// following the public symbol stream header is a hash table header.
	const HashTableHeader hashHeader = publicStream.ReadAtOffset<HashTableHeader>(sizeof(PublicStreamHeader));
	if (hashHeader.signature != HashTableHeader::Signature)
	{
		return ErrorCode::InvalidSignature;
	}
	else if (hashHeader.version != HashTableHeader::Version)
	{
		return ErrorCode::UnknownVersion;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::DBIStream::HasValidGlobalSymbolStream(const RawFile& file) const PDB_NO_EXCEPT
{
	if (m_header.globalStreamIndex == PDB::NilStreamIndex)
	{
		return ErrorCode::InvalidStreamIndex;
	}

	DirectMSFStream globalStream = file.CreateMSFStream<DirectMSFStream>(m_header.globalStreamIndex);

	// the global symbol stream starts with a hash table header
	const HashTableHeader hashHeader = globalStream.ReadAtOffset<HashTableHeader>(0u);
	if (hashHeader.signature != HashTableHeader::Signature)
	{
		return ErrorCode::InvalidSignature;
	}
	else if (hashHeader.version != HashTableHeader::Version)
	{
		return ErrorCode::UnknownVersion;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::DBIStream::HasValidSectionContributionStream(const RawFile& /* file */) const PDB_NO_EXCEPT
{
	if (m_header.sectionContributionSize < sizeof(DBI::SectionContribution::Version))
	{
		return ErrorCode::InvalidStream;
	}

	// find the section contribution sub-stream
	// https://llvm.org/docs/PDB/DbiStream.html#section-contribution-substream
	const uint32_t streamOffset = GetSectionContributionSubstreamOffset(m_header);

	const DBI::SectionContribution::Version version = m_stream.ReadAtOffset<DBI::SectionContribution::Version>(streamOffset);
	if (version != DBI::SectionContribution::Version::Ver60)
	{
		return ErrorCode::UnknownVersion;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::CoalescedMSFStream PDB::DBIStream::CreateSymbolRecordStream(const RawFile& file) const PDB_NO_EXCEPT
{
	// the symbol record stream holds the actual CodeView data of the symbols
	return file.CreateMSFStream<CoalescedMSFStream>(m_header.symbolRecordStreamIndex);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ImageSectionStream PDB::DBIStream::CreateImageSectionStream(const RawFile& file) const PDB_NO_EXCEPT
{
	// find the debug header sub-stream
	const uint32_t debugHeaderOffset = GetDebugHeaderSubstreamOffset(m_header);
	const DBI::DebugHeader& debugHeader = m_stream.ReadAtOffset<DBI::DebugHeader>(debugHeaderOffset);

	// from there, grab the section header stream
	return ImageSectionStream(file, debugHeader.sectionHeaderStreamIndex);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::PublicSymbolStream PDB::DBIStream::CreatePublicSymbolStream(const RawFile& file) const PDB_NO_EXCEPT
{
	DirectMSFStream publicStream = file.CreateMSFStream<DirectMSFStream>(m_header.publicStreamIndex);

	// the public symbol stream always begins with a header, we are not interested in that.
	// following the public symbol stream header is a hash table header.
	// we use this to work out how many symbol records are referenced by the public symbol stream.
	const HashTableHeader hashHeader = publicStream.ReadAtOffset<HashTableHeader>(sizeof(PublicStreamHeader));
	const uint32_t recordCount = hashHeader.size / sizeof(HashRecord);

	return PublicSymbolStream(file, m_header.publicStreamIndex, recordCount);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::GlobalSymbolStream PDB::DBIStream::CreateGlobalSymbolStream(const RawFile& file) const PDB_NO_EXCEPT
{
	DirectMSFStream globalStream = file.CreateMSFStream<DirectMSFStream>(m_header.globalStreamIndex);

	// the global symbol stream starts with a hash table header.
	// we use this to work out how many symbol records are referenced by the global symbol stream.
	const HashTableHeader hashHeader = globalStream.ReadAtOffset<HashTableHeader>(0u);
	const uint32_t recordCount = hashHeader.size / sizeof(HashRecord);

	return GlobalSymbolStream(file, m_header.globalStreamIndex, recordCount);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::SourceFileStream PDB::DBIStream::CreateSourceFileStream(const RawFile& /* file */) const PDB_NO_EXCEPT
{
	// find the source info sub-stream
	// https://llvm.org/docs/PDB/DbiStream.html#file-info-substream
	const uint32_t streamOffset = GetSourceInfoSubstreamOffset(m_header);

	return SourceFileStream(m_stream, m_header.sourceInfoSize, streamOffset);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::SectionContributionStream PDB::DBIStream::CreateSectionContributionStream(const RawFile& /* file */) const PDB_NO_EXCEPT
{
	// find the section contribution sub-stream
	// https://llvm.org/docs/PDB/DbiStream.html#section-contribution-substream
	const uint32_t streamOffset = GetSectionContributionSubstreamOffset(m_header);

	return SectionContributionStream(m_stream, m_header.sectionContributionSize - sizeof(DBI::SectionContribution::Version), streamOffset + sizeof(DBI::SectionContribution::Version));
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ModuleInfoStream PDB::DBIStream::CreateModuleInfoStream(const RawFile& /* file */) const PDB_NO_EXCEPT
{
	// find the module info sub-stream
	// https://llvm.org/docs/PDB/DbiStream.html#module-info-substream
	const uint32_t streamOffset = GetModuleInfoSubstreamOffset(m_header);

	return ModuleInfoStream(m_stream, m_header.moduleInfoSize, streamOffset);
}

```

`third_party/raw_pdb/src/PDB_DBIStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "PDB_ErrorCodes.h"
#include "PDB_DBITypes.h"
#include "PDB_CoalescedMSFStream.h"
#include "PDB_DirectMSFStream.h"
#include "PDB_ImageSectionStream.h"
#include "PDB_PublicSymbolStream.h"
#include "PDB_GlobalSymbolStream.h"
#include "PDB_SourceFileStream.h"
#include "PDB_SectionContributionStream.h"
#include "PDB_ModuleInfoStream.h"


// PDB DBI Stream
// https://llvm.org/docs/PDB/DbiStream.html
namespace PDB
{
	class RawFile;


	class PDB_NO_DISCARD DBIStream
	{
	public:
		DBIStream(void) PDB_NO_EXCEPT;
		explicit DBIStream(const RawFile& file, const DBI::StreamHeader& header) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(DBIStream);

		PDB_NO_DISCARD ErrorCode HasValidSymbolRecordStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD ErrorCode HasValidImageSectionStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD ErrorCode HasValidPublicSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD ErrorCode HasValidGlobalSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD ErrorCode HasValidSectionContributionStream(const RawFile& file) const PDB_NO_EXCEPT;

		PDB_NO_DISCARD CoalescedMSFStream CreateSymbolRecordStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD ImageSectionStream CreateImageSectionStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD PublicSymbolStream CreatePublicSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD GlobalSymbolStream CreateGlobalSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD SourceFileStream CreateSourceFileStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD SectionContributionStream CreateSectionContributionStream(const RawFile& file) const PDB_NO_EXCEPT;
		PDB_NO_DISCARD ModuleInfoStream CreateModuleInfoStream(const RawFile& file) const PDB_NO_EXCEPT;

		PDB_NO_DISCARD const DBI::StreamHeader& GetHeader(void) const PDB_NO_EXCEPT
		{
			return m_header;
		}

	private:
		DBI::StreamHeader m_header;
		DirectMSFStream m_stream;

		PDB_DISABLE_COPY(DBIStream);
	};

	// Returns whether the given raw file provides a valid DBI stream.
	PDB_NO_DISCARD ErrorCode HasValidDBIStream(const RawFile& file) PDB_NO_EXCEPT;

	// Creates the DBI stream from a raw file.
	PDB_NO_DISCARD DBIStream CreateDBIStream(const RawFile& file) PDB_NO_EXCEPT;
}

```

`third_party/raw_pdb/src/PDB_DBITypes.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_DBITypes.h"


const uint32_t PDB::DBI::StreamHeader::Signature = 0xffffffffu;
const uint16_t PDB::DBI::DebugHeader::InvalidStreamIndex = 0xFFFFu;

```

`third_party/raw_pdb/src/PDB_DBITypes.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_BitOperators.h"


namespace PDB
{
	namespace DBI
	{
		// https://llvm.org/docs/PDB/DbiStream.html#stream-header
		// https://github.com/microsoft/microsoft-pdb/blob/master/PDB/dbi/dbi.h#L124
		struct StreamHeader
		{
			static const uint32_t Signature;

			enum class PDB_NO_DISCARD Version : uint32_t
			{
				VC41 = 930803u,
				V50 = 19960307u,
				V60 = 19970606u,
				V70 = 19990903u,
				V110 = 20091201u
			};

			uint32_t signature;
			Version version;
			uint32_t age;
			uint16_t globalStreamIndex;						// index of the global symbol stream
			uint16_t toolchain;
			uint16_t publicStreamIndex;						// index of the public symbol stream
			uint16_t pdbDllVersion;
			uint16_t symbolRecordStreamIndex;				// index of the symbol record stream
			uint16_t pdbDllRbld;
			uint32_t moduleInfoSize;
			uint32_t sectionContributionSize;
			uint32_t sectionMapSize;
			uint32_t sourceInfoSize;
			uint32_t typeServerMapSize;
			uint32_t mfcTypeServerIndex;
			uint32_t optionalDebugHeaderSize;
			uint32_t ecSize;
			uint16_t flags;
			uint16_t machine;
			uint32_t padding;
		};

		// https://llvm.org/docs/PDB/DbiStream.html#optional-debug-header-stream
		struct DebugHeader
		{
			static const uint16_t InvalidStreamIndex;

			uint16_t fpoDataStreamIndex;						// IMAGE_DEBUG_TYPE_FPO
			uint16_t exceptionDataStreamIndex;					// IMAGE_DEBUG_TYPE_EXCEPTION
			uint16_t fixupDataStreamIndex;						// IMAGE_DEBUG_TYPE_FIXUP
			uint16_t omapToSrcDataStreamIndex;					// IMAGE_DEBUG_TYPE_OMAP_TO_SRC
			uint16_t omapFromSrcDataStreamIndex;				// IMAGE_DEBUG_TYPE_OMAP_FROM_SRC
			uint16_t sectionHeaderStreamIndex;					// a dump of all section headers (IMAGE_SECTION_HEADER) from the original executable
			uint16_t tokenDataStreamIndex;
			uint16_t xdataStreamIndex;
			uint16_t pdataStreamIndex;
			uint16_t newFpoDataStreamIndex;
			uint16_t originalSectionHeaderDataStreamIndex;
		};

		// https://llvm.org/docs/PDB/DbiStream.html#section-contribution-substream
		struct SectionContribution
		{
			enum class PDB_NO_DISCARD Version : uint32_t
			{
				Ver60 = 0xeffe0000u + 19970605u,
				V2 = 0xeffe0000u + 20140516u
			};

			uint16_t section;
			uint16_t padding;
			uint32_t offset;
			uint32_t size;
			uint32_t characteristics;
			uint16_t moduleIndex;
			uint16_t padding2;
			uint32_t dataCrc;
			uint32_t relocationCrc;
		};

		// https://llvm.org/docs/PDB/DbiStream.html#module-info-substream
		struct ModuleInfo
		{
			uint32_t unused;
			SectionContribution sectionContribution;
			uint16_t flags;
			uint16_t moduleSymbolStreamIndex;
			uint32_t symbolSize;
			uint32_t c11Size;
			uint32_t c13Size;
			uint16_t sourceFileCount;
			uint16_t padding;
			uint32_t unused2;
			uint32_t sourceFileNameIndex;
			uint32_t pdbFilePathNameIndex;
		};
	}


	namespace CodeView
	{
		namespace DBI
		{
			// code view type records that can appear in a DBI stream.
			// this list is not exhaustive, but only contains what we need so far.
			// https://llvm.org/docs/PDB/CodeViewSymbols.html
			// https://llvm.org/docs/PDB/TpiStream.html#tpi-vs-ipi-stream
			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2735
			enum class PDB_NO_DISCARD SymbolRecordKind : uint16_t
			{
				S_END =										0x0006u,		// block, procedure, "with" or thunk end
				S_SKIP =									0x0007u,        // Reserve symbol space in $$Symbols table
				S_FRAMEPROC =								0x1012u,		// extra frame and proc information
				S_ANNOTATION =								0x1019u,		// annotation string literals ("__annotation" intrinsic, e.g. via NT_ASSERT)
				S_OBJNAME =									0x1101u,		// full path to the original compiled .obj. can point to remote locations and temporary files, not necessarily the file that was linked into the executable
				S_THUNK32 =									0x1102u,		// thunk start
				S_BLOCK32 =									0x1103u,		// block start
				S_LABEL32 =									0x1105u,		// code label
				S_REGISTER =								0x1106u,		// register variable
				S_CONSTANT =								0x1107u,		// constant symbol
				S_BPREL32 =									0x110Bu,		// BP-relative address (almost like S_REGREL32)
				S_LDATA32 =									0x110Cu,		// (static) local data
				S_GDATA32 =									0x110Du,		// global data
				S_PUB32 =									0x110Eu,		// public symbol
				S_LPROC32 =									0x110Fu,		// local procedure start
				S_GPROC32 =									0x1110u,		// global procedure start
				S_REGREL32 =								0x1111u,		// register relative address
				S_LTHREAD32 =								0x1112u,		// (static) thread-local data
				S_GTHREAD32 =								0x1113u,		// global thread-local data
				S_UNAMESPACE =								0x1124u,		// using namespace
				S_PROCREF =									0x1125u,		// reference to function in any compiland
				S_LPROCREF =								0x1127u,		// local reference to function in any compiland
				S_TRAMPOLINE =								0x112Cu,		// incremental linking trampoline
				S_SEPCODE =									0x1132u,		// separated code (from the compiler)
				S_SECTION =									0x1136u,		// a COFF section in an executable
				S_COFFGROUP =								0x1137u,		// original COFF group before it was merged into executable sections by the linker, e.g. .CRT$XCU, .rdata, .bss, .lpp_prepatch_hooks
				S_CALLSITEINFO = 							0x1139u,		// Indirect call site information
				S_FRAMECOOKIE = 							0x113Au, 		// Security cookie information
				S_COMPILE3 =								0x113Cu,		// replacement for S_COMPILE2, more info
				S_ENVBLOCK =								0x113Du,		// environment block split off from S_COMPILE2
				S_LOCAL =									0x113Eu,		// defines a local symbol in optimized code 
				S_DEFRANGE_REGISTER =						0x1141u,		// ranges for en-registered symbol
				S_DEFRANGE_FRAMEPOINTER_REL =				0x1142u,		// range for stack symbol.
				S_DEFRANGE_SUBFIELD_REGISTER =				0x1143u,		// ranges for en-registered field of symbol
				S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE =	0x1144u, 		// range for stack symbol span valid full scope of function body, gap might apply.
				S_DEFRANGE_REGISTER_REL = 					0x1145u, 		// range for symbol address as register + offset.
				S_LPROC32_ID =								0x1146u,		// S_PROC symbol that references ID instead of type
				S_GPROC32_ID =								0x1147u,		// S_PROC symbol that references ID instead of type
				S_BUILDINFO =								0x114Cu,		// build info/environment details of a compiland/translation unit
				S_INLINESITE =								0x114Du,		// inlined function callsite
				S_INLINESITE_END =							0x114Eu,
				S_PROC_ID_END =								0x114Fu,
				S_FILESTATIC =								0x1153u,
				S_LPROC32_DPC =								0x1155u,
				S_LPROC32_DPC_ID =							0x1156u,
				S_ARMSWITCHTABLE = 							0x1159u,
				S_CALLEES =									0x115Au,
				S_CALLERS =									0x115Bu,
				S_INLINESITE2 =								0x115Du,		// extended inline site information
				S_HEAPALLOCSITE = 							0x115Eu,		// heap allocation site
				S_INLINEES =			 					0x1168u,		// https://llvm.org/docs/PDB/CodeViewSymbols.html#s-inlinees-0x1168
				S_REGREL32_INDIR =							0x1171u,
				S_REGREL32_ENCTMP =							0x1179u,
				S_UDT =										0x1108u,		// user-defined type
				S_UDT_ST =									0x1003u,		// user-defined structured types
			};

			// https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/thunk-ordinal
			enum class PDB_NO_DISCARD ThunkOrdinal : uint8_t
			{
				NoType,
				ThisAdjustor,
				VirtualCall,
				PCode,
				DelayLoad,
				TrampolineIncremental,
				TrampolineBranchIsland
			};

			enum class PDB_NO_DISCARD TrampolineType : uint16_t
			{
				Incremental,
				BranchIsland
			};

			enum class PDB_NO_DISCARD CookieType : uint8_t
			{
			   COPY = 0, 
			   XOR_SP, 
			   XOR_BP,
			   XOR_R13,
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvconst.h#L392
			enum class PDB_NO_DISCARD Register : uint16_t
			{
				EAX = 17,
				ECX = 18,
				EDX = 19,
				EBX = 20,
				ESP = 21,
				EBP = 22,
				ESI = 23,
				EDI = 24,

				RAX = 328,
				RBX = 329,
				RCX = 330,
				RDX = 331,
				RSI = 332,
				RDI = 333,
				RBP = 334,
				RSP = 335,
				R8 = 336,
				R9 = 337,
				R10 = 338,
				R11 = 339,
				R12 = 340,
				R13 = 341,
				R14 = 342,
				R15 = 343,

				RIP = 33,		// also EIP for x32
				EFLAGS = 34,	// same for x64 and x32
			};


			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3038
			enum class PDB_NO_DISCARD ProcedureFlags : uint8_t
			{
				None = 0u,
				NoFPO = 1u << 0u,
				InterruptReturn = 1u << 1u,
				FarReturn = 1u << 2u,
				NoReturn = 1u << 3u,
				Unreachable = 1u << 4u,
				CustomCallingConvention = 1u << 5u,
				NoInline = 1u << 6u,
				OptimizedDebugInformation = 1u << 7u
			};
			PDB_DEFINE_BIT_OPERATORS(ProcedureFlags);


			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3676
			enum class PDB_NO_DISCARD PublicSymbolFlags : uint32_t
			{
				None = 0u,
				Code = 1u << 0u,					// set if public symbol refers to a code address
				Function = 1u << 1u,				// set if public symbol is a function
				ManagedCode = 1u << 2u,				// set if managed code (native or IL)
				ManagedILCode = 1u << 3u			// set if managed IL code
			};
			PDB_DEFINE_BIT_OPERATORS(PublicSymbolFlags);


			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3341
			enum class PDB_NO_DISCARD CompileSymbolFlags : uint32_t
			{
				None = 0u,
				SourceLanguageMask = 0xFFu,
				EC = 1u << 8u,
				NoDebugInfo = 1u << 9u,
				LTCG = 1u << 10u,
				NoDataAlign = 1u << 11u,
				ManagedCodeOrDataPresent = 1u << 12u,
				SecurityChecks = 1u << 13u,
				HotPatch = 1u << 14u,
				CVTCIL = 1u << 15u,
				MSILModule = 1u << 16u,
				SDL = 1u << 17u,
				PGO = 1u << 18u,
				Exp = 1u << 19u
			};
			PDB_DEFINE_BIT_OPERATORS(CompileSymbolFlags);


			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvconst.h#L324
			enum class PDB_NO_DISCARD CPUType : uint16_t
			{
				Intel8080 = 0x0,
				Intel8086 = 0x1,
				Intel80286 = 0x2,
				Intel80386 = 0x3,
				Intel80486 = 0x4,
				Pentium = 0x5,
				PentiumII = 0x6,
				PentiumPro = PentiumII,
				PentiumIII = 0x7,
				MIPS = 0x10,
				MIPSR4000 = MIPS,
				MIPS16 = 0x11,
				MIPS32 = 0x12,
				MIPS64 = 0x13,
				MIPSI = 0x14,
				MIPSII = 0x15,
				MIPSIII = 0x16,
				MIPSIV = 0x17,
				MIPSV = 0x18,
				M68000 = 0x20,
				M68010 = 0x21,
				M68020 = 0x22,
				M68030 = 0x23,
				M68040 = 0x24,
				Alpha = 0x30,
				Alpha21164 = 0x31,
				Alpha21164A = 0x32,
				Alpha21264 = 0x33,
				Alpha21364 = 0x34,
				PPC601 = 0x40,
				PPC603 = 0x41,
				PPC604 = 0x42,
				PPC620 = 0x43,
				PPCFP = 0x44,
				PPCBE = 0x45,
				SH3 = 0x50,
				SH3E = 0x51,
				SH3DSP = 0x52,
				SH4 = 0x53,
				SHMedia = 0x54,
				ARM3 = 0x60,
				ARM4 = 0x61,
				ARM4T = 0x62,
				ARM5 = 0x63,
				ARM5T = 0x64,
				ARM6 = 0x65,
				ARM_XMAC = 0x66,
				ARM_WMMX = 0x67,
				ARM7 = 0x68,
				Omni = 0x70,
				IA64 = 0x80,
				IA64_1 = 0x80,
				IA64_2 = 0x81,
				CEE = 0x90,
				AM33 = 0xA0,
				M32R = 0xB0,
				TriCore = 0xC0,
				X64 = 0xD0,
				AMD64 = X64,
				EBC = 0xE0,
				Thumb = 0xF0,
				ARMNT = 0xF4,
				ARM64 = 0xF6,
				HybridX86ARM64 = 0xF7,
				ARM64EC = 0xF8,
				ARM64X = 0xF9,
				D3D11_Shader = 0x100
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3100
			// represents an address range, used for optimized code debug info
			struct LocalVariableAddressRange // defines a range of addresses
			{
				uint32_t offsetStart;
				uint16_t isectionStart;
				uint16_t length;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3108
			// Represents the holes in overall address range, all address is pre-bbt. 
			// it is for compress and reduce the amount of relocations need.
			struct LocalVariableAddressGap
			{
				uint16_t offset; // relative offset from the beginning of the live range.
				uint16_t length; // length of this gap.
			};

			// https://github.com/microsoft/microsoft-pdb/blob/0fe89a942f9a0f8e061213313e438884f4c9b876/include/cvinfo.h#L4366
			// https://github.com/microsoft/microsoft-pdb/blob/0fe89a942f9a0f8e061213313e438884f4c9b876/cvdump/dumpsym7.cpp#L5518
			enum class ARMSwitchType : uint16_t
			{
				INT1 = 0, 			// signed byte
				UINT1 = 1, 			// unsigned byte
				INT2 = 2, 			// signed two byte
				UINT2 = 3, 			// unsigned two byte
				INT4 = 4,			// signed four byte
				UINT4 = 5,			// unsigned four byte
				POINTER = 6,
				UINT1SHL1 = 7,		// unsigned byte scaled by two
				UINT2SHL1 = 8,		// unsigned two byte scaled by two
				INT1SHL1 = 9,		// signed byte scaled by two
				INT2SHL1 = 10, 		// signed two byte scaled by two
				TBB = UINT1SHL1,
				TBH = UINT2SHL1, 
			};

			// https://llvm.org/docs/PDB/CodeViewTypes.html#leaf-types
			struct RecordHeader
			{
				uint16_t size;					// record length, not including this 2-byte field
				SymbolRecordKind kind;			// record kind
			};

			// all CodeView records are stored as a header, followed by variable-length data.
			// internal Record structs such as S_PUB32, S_GDATA32, etc. correspond to the data layout of a CodeView record of that kind.
			struct Record
			{
				RecordHeader header;
				union Data
				{
#pragma pack(push, 1)
					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4069
					struct
					{
						uint32_t cbFrame;		// count of bytes of total frame of procedure
						uint32_t cbPad;			// count of bytes of padding in the frame
						uint32_t offPad;		// offset (relative to frame poniter) to where
												//  padding starts
						uint32_t cbSaveRegs;	// count of bytes of callee save registers
						uint32_t offExHdlr;		// offset of exception handler
						uint16_t sectExHdlr;	// section id of exception handler

						struct {
							uint32_t fHasAlloca : 1;				// function uses _alloca()
							uint32_t fHasSetJmp : 1;				// function uses setjmp()
							uint32_t fHasLongJmp : 1;				// function uses longjmp()
							uint32_t fHasInlAsm : 1;				// function uses inline asm
							uint32_t fHasEH : 1;					// function has EH states
							uint32_t fInlSpec : 1;					// function was speced as inline
							uint32_t fHasSEH : 1;					// function has SEH
							uint32_t fNaked : 1;					// function is __declspec(naked)
							uint32_t fSecurityChecks : 1;			// function has buffer security check introduced by /GS.
							uint32_t fAsyncEH : 1;					// function compiled with /EHa
							uint32_t fGSNoStackOrdering : 1;		// function has /GS buffer checks, but stack ordering couldn't be done
							uint32_t fWasInlined : 1;				// function was inlined within another function
							uint32_t fGSCheck : 1;					// function is __declspec(strict_gs_check)
							uint32_t fSafeBuffers : 1;				// function is __declspec(safebuffers)
							uint32_t encodedLocalBasePointer : 2;	// record function's local pointer explicitly.
							uint32_t encodedParamBasePointer : 2;	// record function's parameter pointer explicitly.
							uint32_t fPogoOn : 1;					// function was compiled with PGO/PGU
							uint32_t fValidCounts : 1;				// Do we have valid Pogo counts?
							uint32_t fOptSpeed : 1;					// Did we optimize for speed?
							uint32_t fGuardCF : 1;					// function contains CFG checks (and no write checks)
							uint32_t fGuardCFW : 1;					// function contains CFW checks and/or instrumentation
							uint32_t pad : 9;						// must be zero
						} flags;
					} S_FRAMEPROC;

					struct
					{
						uint32_t offset;
						uint16_t section;
						uint16_t annotationsCount;						// number of zero-terminated annotation strings
						PDB_FLEXIBLE_ARRAY_MEMBER(char, annotations);	// sequence of zero-terminated annotation strings
					} S_ANNOTATIONSYM;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3696
					struct
					{
						PublicSymbolFlags flags;
						uint32_t offset;
						uint16_t section;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_PUB32;

					struct
					{
						uint32_t typeIndex;
						uint32_t offset;
						uint16_t section;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_GDATA32, S_GTHREAD32, S_LDATA32, S_LTHREAD32;

					struct
					{
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_UNAMESPACE;

					struct
					{
						uint32_t signature;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_OBJNAME;

					struct
					{
						TrampolineType type;
						uint16_t size;
						uint32_t thunkOffset;
						uint32_t targetOffset;
						uint16_t thunkSection;
						uint16_t targetSection;
					} S_TRAMPOLINE;

					struct
					{
						uint16_t sectionNumber;
						uint8_t alignment;
						uint32_t rva;
						uint32_t length;
						uint32_t characteristics;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_SECTION;

					struct
					{
						uint32_t size;
						uint32_t characteristics;
						uint32_t offset;
						uint16_t section;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_COFFGROUP;

					struct
					{
						uint32_t offset ;	// offset of call site
						uint16_t section; 	// section index of call site
						uint16_t padding; 	// alignment padding field, must be zero
						uint32_t typeIndex;	// type index describing function signature
					} S_CALLSITEINFO;

					struct
					{
						uint32_t offset; 		// Frame relative offset
						uint16_t reg;			// Register index
						CookieType cookietype;	// Type of the cookie
						uint8_t flags;			// Flags describing this cookie
					} S_FRAMECOOKIE;

					struct
					{
						uint32_t parent;
						uint32_t end;
						uint32_t next;
						uint32_t offset;
						uint16_t section;
						uint16_t length;
						ThunkOrdinal thunk;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_THUNK32;

					struct
					{
						uint32_t parent;
						uint32_t end;
						uint32_t next;
						uint32_t codeSize;
						uint32_t debugStart;
						uint32_t debugEnd;
						uint32_t typeIndex;
						uint32_t offset;
						uint16_t section;
						ProcedureFlags flags;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_LPROC32, S_GPROC32, S_LPROC32_ID, S_GPROC32_ID, S_LPROC32_DPC, S_LPROC32_DPC_ID;

					struct
					{
						uint32_t offset;
						uint32_t typeIndex;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_BPRELSYM32;

					struct
					{
						uint32_t offset;
						uint32_t typeIndex;
						Register reg;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_REGREL32, S_REGREL32_ENCTMP;

					struct
					{
						uint32_t typeIndex;
						Register reg;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_REGSYM;

					struct
					{
						uint32_t parent;
						uint32_t end;
						uint32_t codeSize;
						uint32_t offset;
						uint16_t section;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_BLOCK32;

					struct
					{
						uint32_t offset;
						uint16_t section;
						ProcedureFlags flags;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_LABEL32;

					struct
					{
						uint32_t typeIndex;
						uint16_t value;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_CONSTANT;

					struct
					{
						uint32_t typeIndex;	// refers to a type index in the IPI stream
					} S_BUILDINFO;

					struct
					{
						uint32_t parent; // pointer to the inliner
						uint32_t end; // pointer to this block's end
						uint32_t inlinee; // CV_ItemId of inlinee
						PDB_FLEXIBLE_ARRAY_MEMBER(uint8_t, binaryAnnotations);
					} S_INLINESITE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4199
					struct
					{
						uint32_t typeIndex; // type index
						uint32_t moduleFilenameOffset; // index of mod filename in stringtable

						struct 
						{
							uint16_t fIsParam : 1; 			// variable is a parameter
							uint16_t fAddrTaken : 1; 		// address is taken
							uint16_t fCompGenx : 1; 		// variable is compiler generated
							uint16_t fIsAggregate : 1;		// the symbol is splitted in temporaries,
															// which are treated by compiler as 
															// independent entities
							uint16_t fIsAggregated : 1;		// Counterpart of fIsAggregate - tells
															// that it is a part of a fIsAggregate symbol
							uint16_t fIsAliased : 1;		// variable has multiple simultaneous lifetimes
							uint16_t fIsAlias : 1; 			// represents one of the multiple simultaneous lifetimes
							uint16_t fIsRetValue : 1;		// represents a function return value
							uint16_t fIsOptimizedOut : 1;	// variable has no lifetimes
							uint16_t fIsEnregGlob : 1; 		// variable is an enregistered global
							uint16_t fIsEnregStat : 1; 		// variable is an enregistered static
							uint16_t unused : 5; 			// must be zero
						} flags;

						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_FILESTATIC;

					struct
					{
						CompileSymbolFlags flags;
						CPUType machine;
						uint16_t versionFrontendMajor;
						uint16_t versionFrontendMinor;
						uint16_t versionFrontendBuild;
						uint16_t versionFrontendQFE;
						uint16_t versionBackendMajor;
						uint16_t versionBackendMinor;
						uint16_t versionBackendBuild;
						uint16_t versionBackendQFE;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, version);
					} S_COMPILE3;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L3372
					struct
					{
						uint8_t flags;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, strings);
					} S_ENVBLOCK;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4190
					struct
					{
						uint32_t typeIndex;

						struct 
						{
							uint16_t fIsParam : 1; 			// variable is a parameter
							uint16_t fAddrTaken : 1; 		// address is taken
							uint16_t fCompGenx : 1; 		// variable is compiler generated
							uint16_t fIsAggregate : 1;		// the symbol is splitted in temporaries,
															// which are treated by compiler as 
															// independent entities
							uint16_t fIsAggregated : 1;		// Counterpart of fIsAggregate - tells
															// that it is a part of a fIsAggregate symbol
							uint16_t fIsAliased : 1;		// variable has multiple simultaneous lifetimes
							uint16_t fIsAlias : 1; 			// represents one of the multiple simultaneous lifetimes
							uint16_t fIsRetValue : 1;		// represents a function return value
							uint16_t fIsOptimizedOut : 1;	// variable has no lifetimes
							uint16_t fIsEnregGlob : 1; 		// variable is an enregistered global
							uint16_t fIsEnregStat : 1; 		// variable is an enregistered static
							uint16_t unused : 5; 			// must be zero
						} flags;

						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_LOCAL;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4236
					struct
					{
						uint16_t reg; // Register to hold the value of the symbol

						struct
						{
							uint16_t maybe : 1;		// May have no user name on one of control flow path.
							uint16_t padding : 15;	// Padding for future use.
						} attribute; // Attribute of the register range.

						LocalVariableAddressRange range; // Range of addresses where this program is valid
						PDB_FLEXIBLE_ARRAY_MEMBER(LocalVariableAddressGap, gaps); // The value is not available in following gaps.
					} S_DEFRANGE_REGISTER;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4245
					struct
					{
						uint32_t offsetFramePointer;
						LocalVariableAddressRange range; // Range of addresses where this program is valid
						PDB_FLEXIBLE_ARRAY_MEMBER(LocalVariableAddressGap, gaps); // The value is not available in following gaps.
					} S_DEFRANGE_FRAMEPOINTER_REL;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4265
					struct
					{
						uint16_t reg; // Register to hold the value of the symbol

						struct
						{
							uint16_t maybe : 1;		// May have no user name on one of control flow path.
							uint16_t padding : 15;	// Padding for future use.
						} attribute; // Attribute of the register range.

						uint32_t offsetParent : 12; // Offset in parent variable.
						uint32_t padding : 20; // Padding for future use.
						LocalVariableAddressRange range; // Range of addresses where this program is valid
						PDB_FLEXIBLE_ARRAY_MEMBER(LocalVariableAddressGap, gaps); // The value is not available in following gaps.
					} S_DEFRANGE_SUBFIELD_REGISTER;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4255
					struct
					{
						uint32_t offsetFramePointer;  // offset to frame pointer
					} S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4279
					struct
					{
						uint16_t baseRegister; // Register to hold the base pointer of the symbol
						uint16_t spilledUDTMember : 1; // Spilled member for s.i.
						uint16_t padding : 3; // Padding for future use.
						uint16_t offsetParent : 12; // Offset in parent variable.
						uint32_t offsetBasePointer; // offset to register
						LocalVariableAddressRange range;   // Range of addresses where this program is valid
						PDB_FLEXIBLE_ARRAY_MEMBER(LocalVariableAddressGap, gaps); // The value is not available in following gaps.
					} S_DEFRANGE_REGISTER_REL;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4500
					struct 
					{
						uint32_t offset;			// offset of call site
						uint16_t section;			// section index of call site
						uint16_t instructionLength; // length of heap allocation call instruction
						uint32_t typeIndex;			// type index describing function signature
					} S_HEAPALLOCSITE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4402
					struct
					{
						uint32_t offsetBase;		// Section-relative offset to the base for switch offsets
						uint16_t sectionBase;		// Section index of the base for switch offsets
						ARMSwitchType switchType;	// type of each entry
						uint32_t offsetBranch;		// Section-relative offset to the table branch instruction
						uint32_t offsetTable;		// Section-relative offset to the start of the table
						uint16_t sectionBranch;		// Section index of the table branch instruction
						uint16_t sectionTable;		// Section index of the table
						uint32_t numEntries;	  	// number of switch table entries
					} S_ARMSWITCHTABLE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4382
					struct
					{
						uint32_t count; // Number of functions
						PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, funcs); // List of functions, dim == count
						// uint32_t   invocations[CV_ZEROLEN]; Followed by a parallel array of
						// invocation counts. Counts > reclen are assumed to be zero
					} S_CALLERS, S_CALLEES, S_INLINEES;

					struct
					{
						uint32_t typeIndex;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} S_UDT, S_UDT_ST;

					struct
					{
						uint32_t unknown1;
						uint32_t typeIndex;
						uint32_t unknown2;
						Register reg;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);

					} S_REGREL32_INDIR;
#pragma pack(pop)
				} data;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4576
			enum class PDB_NO_DISCARD DebugSubsectionKind : uint32_t 
			{
				S_IGNORE = 0x80000000,    // if this bit is set in a subsection type then ignore the subsection contents

				S_SYMBOLS = 0xF1,
				S_LINES = 0xF2,
				S_STRINGTABLE = 0xF3,
				S_FILECHECKSUMS = 0xF4,
				S_FRAMEDATA = 0xF5,
				S_INLINEELINES = 0xF6,
				S_CROSSSCOPEIMPORTS = 0xF7,
				S_CROSSSCOPEEXPORTS = 0xF8,

				S_IL_LINES = 0xF9,
				S_FUNC_MDTOKEN_MAP = 0xFA,
				S_TYPE_MDTOKEN_MAP = 0xFB,
				S_MERGED_ASSEMBLYINPUT = 0xFC,

				S_COFF_SYMBOL_RVA = 0xFD,
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4596
			struct DebugSubsectionHeader
			{
				DebugSubsectionKind kind;
				uint32_t size;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4617
			struct Line
			{
				uint32_t offset;             // Offset to start of code bytes for line number
				uint32_t linenumStart : 24;  // line where statement/expression starts
				uint32_t deltaLineEnd : 7;   // delta to line where statement ends (optional)
				uint32_t fStatement : 1;     // true if a statement linenumber, else an expression line num
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4630
			struct Column
			{
				uint16_t start;
				uint16_t end;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4601
			struct LinesHeader 
			{
				uint32_t sectionOffset;
				uint16_t sectionIndex;
				struct
				{
					uint16_t fHasColumns : 1;
					uint16_t pad : 15;
				} flags;

				uint32_t  codeSize;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4608
			struct LinesFileBlockHeader
			{
				uint32_t fileChecksumOffset;
				uint32_t numLines;
				uint32_t size;
				// Line lines[numLines];
				// Column columns[numLines]; Might not be present
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvconst.h#L88
			enum class PDB_NO_DISCARD ChecksumKind : uint8_t
			{
				None = 0,
				MD5 = 1,
				SHA1 = 2,
				SHA256 = 3,
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/cvdump/dumpsym7.cpp#L1097
			struct FileChecksumHeader
			{
				uint32_t filenameOffset;
				uint8_t  checksumSize;
				ChecksumKind checksumKind;
				PDB_FLEXIBLE_ARRAY_MEMBER(uint8_t, checksum);
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4822
			enum class InlineeSourceLineKind : uint32_t
			{
				Signature = 0,
				SignatureEx = 1,
			};

			struct InlineeSourceLineHeader
			{
				InlineeSourceLineKind kind;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L4825
			struct InlineeSourceLine
			{
				uint32_t inlinee;
				uint32_t fileChecksumOffset;
				uint32_t lineNumber;
			};

			struct InlineeSourceLineEx
			{
				uint32_t inlinee;
				uint32_t fileChecksumOffset;
				uint32_t lineNumber;
				uint32_t extraLines;
				PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, extrafileChecksumOffsets);
			};

			// Combine DebugSubsectionHeader and first subsection header into one struct.
			struct LineSection
			{
				DebugSubsectionHeader header;
				union
				{
					LinesHeader linesHeader;
					FileChecksumHeader checksumHeader;
					InlineeSourceLineHeader inlineeHeader;
				};
			};
		}
	}
}

```

`third_party/raw_pdb/src/PDB_DirectMSFStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_DirectMSFStream.h"
#include "Foundation/PDB_PointerUtil.h"
#include "Foundation/PDB_BitUtil.h"
#include "Foundation/PDB_Assert.h"
#include "Foundation/PDB_CRT.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::DirectMSFStream::DirectMSFStream(void) PDB_NO_EXCEPT
	: m_data(nullptr)
	, m_blockIndices(nullptr)
	, m_blockSize(0u)
	, m_size(0u)
	, m_blockSizeLog2(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::DirectMSFStream::DirectMSFStream(const void* data, uint32_t blockSize, const uint32_t* blockIndices, uint32_t streamSize) PDB_NO_EXCEPT
	: m_data(data)
	, m_blockIndices(blockIndices)
	, m_blockSize(blockSize)
	, m_size(streamSize)
	, m_blockSizeLog2(BitUtil::FindFirstSetBit(blockSize))
{
	PDB_ASSERT(BitUtil::IsPowerOfTwo(blockSize), "MSF block size must be a power of two.");
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
void PDB::DirectMSFStream::ReadAtOffset(void* destination, size_t size, size_t offset) const PDB_NO_EXCEPT
{
	PDB_ASSERT(destination != nullptr, "Destination buffer not set");
	PDB_ASSERT(offset + size <= m_size, "Not enough data left to read.");

	// work out which block and offset within the block the read offset corresponds to
	size_t blockIndex = offset >> m_blockSizeLog2;
	const size_t offsetWithinBlock = offset & (m_blockSize - 1u);

	// work out the offset within the data based on the block indices
	size_t offsetWithinData = (static_cast<size_t>(m_blockIndices[blockIndex]) << m_blockSizeLog2) + offsetWithinBlock;
	const size_t bytesLeftInBlock = m_blockSize - offsetWithinBlock;

	if (bytesLeftInBlock >= size)
	{
		// fast path, all the data can be read in one go
		const void* const sourceData = Pointer::Offset<const void*>(m_data, offsetWithinData);
		memcpy(destination, sourceData, size);
	}
	else
	{
		// slower path, data is scattered across several blocks.
		// read remaining bytes in current block first.
		{
			const void* const sourceData = Pointer::Offset<const void*>(m_data, offsetWithinData);
			memcpy(destination, sourceData, bytesLeftInBlock);
		}

		// read remaining bytes from blocks
		size_t bytesLeftToRead = size - bytesLeftInBlock;
		while (bytesLeftToRead != 0u)
		{
			// advance to the next block
			++blockIndex;
			offsetWithinData = static_cast<size_t>(m_blockIndices[blockIndex]) << m_blockSizeLog2;

			void* const destinationData = Pointer::Offset<void*>(destination, size - bytesLeftToRead);
			const void* const sourceData = Pointer::Offset<const void*>(m_data, offsetWithinData);

			if (bytesLeftToRead > m_blockSize)
			{
				// copy a whole block at once
				memcpy(destinationData, sourceData, m_blockSize);
				bytesLeftToRead -= m_blockSize;
			}
			else
			{
				// copy remaining bytes
				memcpy(destinationData, sourceData, bytesLeftToRead);
				bytesLeftToRead -= bytesLeftToRead;
			}
		}
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::DirectMSFStream::IndexAndOffset PDB::DirectMSFStream::GetBlockIndexForOffset(uint32_t offset) const PDB_NO_EXCEPT
{
	// work out which block and offset within the block the offset corresponds to
	const uint32_t blockIndex = offset >> m_blockSizeLog2;
	const uint32_t offsetWithinBlock = offset & (m_blockSize - 1u);

	return IndexAndOffset { blockIndex, offsetWithinBlock };
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD size_t PDB::DirectMSFStream::GetDataOffsetForIndexAndOffset(const IndexAndOffset& indexAndOffset) const PDB_NO_EXCEPT
{
	// work out the offset within the data based on the block indices
	const size_t offsetWithinData = (static_cast<size_t>(m_blockIndices[indexAndOffset.index]) << m_blockSizeLog2) + indexAndOffset.offsetWithinBlock;

	return offsetWithinData;
}

```

`third_party/raw_pdb/src/PDB_DirectMSFStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"


// https://llvm.org/docs/PDB/index.html#the-msf-container
// https://llvm.org/docs/PDB/MsfFile.html
namespace PDB
{
	// provides direct access to the data of an MSF stream.
	// inherently thread-safe, the stream doesn't carry any internal offset or similar.
	// trivial to construct.
	// slower individual reads, but pays off when not all data of a stream is needed.
	class PDB_NO_DISCARD DirectMSFStream
	{
	public:
		DirectMSFStream(void) PDB_NO_EXCEPT;
		explicit DirectMSFStream(const void* data, uint32_t blockSize, const uint32_t* blockIndices, uint32_t streamSize) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(DirectMSFStream);

		// Reads a number of bytes from the stream.
		void ReadAtOffset(void* destination, size_t size, size_t offset) const PDB_NO_EXCEPT;

		// Reads from the stream.
		template <typename T>
		PDB_NO_DISCARD inline T ReadAtOffset(size_t offset) const PDB_NO_EXCEPT
		{
			T data;
			ReadAtOffset(&data, sizeof(T), offset);
			return data;
		}

		// Returns the block size of the stream.
		PDB_NO_DISCARD inline uint32_t GetBlockSize(void) const PDB_NO_EXCEPT
		{
			return m_blockSize;
		}

		// Returns the size of the stream.
		PDB_NO_DISCARD inline uint32_t GetSize(void) const PDB_NO_EXCEPT
		{
			return m_size;
		}

	private:
		friend class CoalescedMSFStream;

		struct IndexAndOffset
		{
			uint32_t index;
			uint32_t offsetWithinBlock;
		};

		// Returns the block index and offset within the block that correspond to the given offset.
		PDB_NO_DISCARD IndexAndOffset GetBlockIndexForOffset(uint32_t offset) const PDB_NO_EXCEPT;

		// Returns the offset into the data that corresponds to the given indices and offset within a block.
		PDB_NO_DISCARD size_t GetDataOffsetForIndexAndOffset(const IndexAndOffset& indexAndOffset) const PDB_NO_EXCEPT;

		// Provides read-only access to the memory-mapped data.
		PDB_NO_DISCARD inline const void* GetData(void) const PDB_NO_EXCEPT
		{
			return m_data;
		}

		// Provides read-only access to the block indices.
		PDB_NO_DISCARD inline const uint32_t* GetBlockIndices(void) const PDB_NO_EXCEPT
		{
			return m_blockIndices;
		}

		const void* m_data;
		const uint32_t* m_blockIndices;
		uint32_t m_blockSize;
		uint32_t m_size;
		uint32_t m_blockSizeLog2;

		PDB_DISABLE_COPY(DirectMSFStream);
	};
}

```

`third_party/raw_pdb/src/PDB_ErrorCodes.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"


namespace PDB
{
	enum class PDB_NO_DISCARD ErrorCode : unsigned int
	{
		Success = 0u,

		// main PDB validation
		InvalidDataSize,
		InvalidSuperBlock,
		InvalidFreeBlockMap,

		// stream validation
		InvalidStream,
		InvalidSignature,
		InvalidStreamIndex,
		UnknownVersion
	};
}

```

`third_party/raw_pdb/src/PDB_GlobalSymbolStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_GlobalSymbolStream.h"
#include "PDB_RawFile.h"
#include "PDB_Types.h"
#include "PDB_DBITypes.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::GlobalSymbolStream::GlobalSymbolStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_hashRecords(nullptr)
	, m_count(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::GlobalSymbolStream::GlobalSymbolStream(const RawFile& file, uint16_t streamIndex, uint32_t count) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(streamIndex))
	, m_hashRecords(m_stream.GetDataAtOffset<HashRecord>(sizeof(HashTableHeader)))
	, m_count(count)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD const PDB::CodeView::DBI::Record* PDB::GlobalSymbolStream::GetRecord(const CoalescedMSFStream& symbolRecordStream, const HashRecord& hashRecord) const PDB_NO_EXCEPT
{
	// hash record offsets start at 1, not at 0
	const uint32_t headerOffset = hashRecord.offset - 1u;

	// the offset doesn't point to the global symbol directly, but to the CodeView record:
	// https://llvm.org/docs/PDB/CodeViewSymbols.html
	const CodeView::DBI::Record* record = symbolRecordStream.GetDataAtOffset<const CodeView::DBI::Record>(headerOffset);

	return record;
}

```

`third_party/raw_pdb/src/PDB_GlobalSymbolStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class RawFile;
	struct HashRecord;

	namespace CodeView
	{
		namespace DBI
		{
			struct Record;
		}		
	}


	class PDB_NO_DISCARD GlobalSymbolStream
	{
	public:
		GlobalSymbolStream(void) PDB_NO_EXCEPT;
		explicit GlobalSymbolStream(const RawFile& file, uint16_t streamIndex, uint32_t count) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(GlobalSymbolStream);

		// Turns a given hash record into a DBI record using the given symbol stream.
		PDB_NO_DISCARD const CodeView::DBI::Record* GetRecord(const CoalescedMSFStream& symbolRecordStream, const HashRecord& hashRecord) const PDB_NO_EXCEPT;

		// Returns a view of all the records in the stream.
		PDB_NO_DISCARD inline ArrayView<HashRecord> GetRecords(void) const PDB_NO_EXCEPT
		{
			return ArrayView<HashRecord>(m_hashRecords, m_count);
		}

	private:
		CoalescedMSFStream m_stream;
		const HashRecord* m_hashRecords;
		uint32_t m_count;

		PDB_DISABLE_COPY(GlobalSymbolStream);
	};
}

```

`third_party/raw_pdb/src/PDB_IPIStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_IPIStream.h"
#include "PDB_RawFile.h"
#include "PDB_Util.h"
#include "PDB_DirectMSFStream.h"
#include "PDB_InfoStream.h"
#include "Foundation/PDB_Memory.h"

namespace
{
	// the IPI stream always resides at index 4
	static constexpr const uint32_t IPIStreamIndex = 4u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::IPIStream::IPIStream(void) PDB_NO_EXCEPT
	: m_header()
	, m_stream()
	, m_records(nullptr)
	, m_recordCount(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::IPIStream::IPIStream(IPIStream&& other) PDB_NO_EXCEPT
	: m_header(PDB_MOVE(other.m_header))
	, m_stream(PDB_MOVE(other.m_stream))
	, m_records(PDB_MOVE(other.m_records))
	, m_recordCount(PDB_MOVE(other.m_recordCount))
{
	other.m_records = nullptr;
	other.m_recordCount = 0u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::IPIStream& PDB::IPIStream::operator=(IPIStream&& other) PDB_NO_EXCEPT
{
	if (this != &other)
	{
		PDB_DELETE_ARRAY(m_records);

		m_header = PDB_MOVE(other.m_header);
		m_stream = PDB_MOVE(other.m_stream);
		m_records = PDB_MOVE(other.m_records);
		m_recordCount = PDB_MOVE(other.m_recordCount);

		other.m_records = nullptr;
		other.m_recordCount = 0u;
	}

	return *this;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::IPIStream::IPIStream(const RawFile& file, const IPI::StreamHeader& header) PDB_NO_EXCEPT
	: m_header(header)
	, m_stream(file.CreateMSFStream<CoalescedMSFStream>(IPIStreamIndex))
	, m_records(nullptr)
	, m_recordCount(GetLastTypeIndex() - GetFirstTypeIndex())
{
	// types in the IPI stream are accessed by their index from other streams.
	// however, the index is not stored with types in the IPI stream directly, but has to be built while walking the stream.
	// similarly, because types are variable-length records, there are no direct offsets to access individual types.
	// we therefore walk the IPI stream once, and store pointers to the records for trivial O(N) array lookup by index later.
	m_records = PDB_NEW_ARRAY(const CodeView::IPI::Record*, m_recordCount);

	// ignore the stream's header
	size_t offset = sizeof(IPI::StreamHeader);

	// parse the CodeView records
	uint32_t typeIndex = 0u;
	while (offset < m_stream.GetSize())
	{
		// https://llvm.org/docs/PDB/CodeViewTypes.html
		const CodeView::IPI::Record* record = m_stream.GetDataAtOffset<const CodeView::IPI::Record>(offset);
		const uint32_t recordSize = GetCodeViewRecordSize(record);
		m_records[typeIndex] = record;

		// position the stream offset at the next record
		offset += sizeof(CodeView::IPI::RecordHeader) + recordSize;

		++typeIndex;
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::IPIStream::~IPIStream(void) PDB_NO_EXCEPT
{
	PDB_DELETE_ARRAY(m_records);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::HasValidIPIStream(const RawFile& file) PDB_NO_EXCEPT
{
	const PDB::InfoStream infoStream(file);
	if (!infoStream.HasIPIStream())
	{
		return ErrorCode::InvalidStream;
	}

	DirectMSFStream stream = file.CreateMSFStream<DirectMSFStream>(IPIStreamIndex);
	if (stream.GetSize() < sizeof(IPI::StreamHeader))
	{
		return ErrorCode::InvalidStream;
	}

	const IPI::StreamHeader header = stream.ReadAtOffset<IPI::StreamHeader>(0u);
	if (header.version != IPI::StreamHeader::Version::V80)
	{
		return ErrorCode::UnknownVersion;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::IPIStream PDB::CreateIPIStream(const RawFile& file) PDB_NO_EXCEPT
{
	DirectMSFStream stream = file.CreateMSFStream<DirectMSFStream>(IPIStreamIndex);

	const IPI::StreamHeader header = stream.ReadAtOffset<IPI::StreamHeader>(0u);
	return IPIStream { file, header };
}

```

`third_party/raw_pdb/src/PDB_IPIStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_ErrorCodes.h"
#include "PDB_IPITypes.h"
#include "PDB_CoalescedMSFStream.h"


// PDB IPI stream
// https://llvm.org/docs/PDB/TpiStream.html
namespace PDB
{
	class RawFile;


	class PDB_NO_DISCARD IPIStream
	{
	public:
		IPIStream(void) PDB_NO_EXCEPT;
		IPIStream(IPIStream&& other) PDB_NO_EXCEPT;
		IPIStream& operator=(IPIStream&& other) PDB_NO_EXCEPT;

		explicit IPIStream(const RawFile& file, const IPI::StreamHeader& header) PDB_NO_EXCEPT;
		~IPIStream(void) PDB_NO_EXCEPT;

		// Returns the index of the first type, which is not necessarily zero.
		PDB_NO_DISCARD inline uint32_t GetFirstTypeIndex(void) const PDB_NO_EXCEPT
		{
			return m_header.typeIndexBegin;
		}

		// Returns the index of the last type.
		PDB_NO_DISCARD inline uint32_t GetLastTypeIndex(void) const PDB_NO_EXCEPT
		{
			return m_header.typeIndexEnd;
		}

		// Returns a view of all type records.
		// Records identified by a type index can be accessed via "allRecords[typeIndex - firstTypeIndex]".
		PDB_NO_DISCARD inline ArrayView<const CodeView::IPI::Record*> GetTypeRecords(void) const PDB_NO_EXCEPT
		{
			return ArrayView<const CodeView::IPI::Record*>(m_records, m_recordCount);
		}

	private:
		IPI::StreamHeader m_header;
		CoalescedMSFStream m_stream;
		const CodeView::IPI::Record** m_records;
		size_t m_recordCount;

		PDB_DISABLE_COPY(IPIStream);
	};


	// ------------------------------------------------------------------------------------------------
	// General
	// ------------------------------------------------------------------------------------------------

	PDB_NO_DISCARD ErrorCode HasValidIPIStream(const RawFile& file) PDB_NO_EXCEPT;

	PDB_NO_DISCARD IPIStream CreateIPIStream(const RawFile& file) PDB_NO_EXCEPT;
}

```

`third_party/raw_pdb/src/PDB_IPITypes.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"


namespace PDB
{
	namespace IPI
	{
		// https://llvm.org/docs/PDB/TpiStream.html#tpi-header
		struct StreamHeader
		{
			enum class PDB_NO_DISCARD Version : uint32_t
			{
				V40 = 19950410u,
				V41 = 19951122u,
				V50 = 19961031u,
				V70 = 19990903u,
				V80 = 20040203u
			};

			Version version;
			uint32_t headerSize;
			uint32_t typeIndexBegin;
			uint32_t typeIndexEnd;
			uint32_t typeRecordBytes;
			uint16_t hashStreamIndex;
			uint16_t hashAuxStreamIndex;
			uint32_t hashKeySize;
			uint32_t hashBucketCount;
			uint32_t hashValueBufferOffset;
			uint32_t hashValueBufferLength;
			uint32_t indexOffsetBufferOffset;
			uint32_t indexOffsetBufferLength;
			uint32_t hashAdjBufferOffset;
			uint32_t hashAdjBufferLength;
		};
	}


	namespace CodeView
	{
		namespace IPI
		{
			// code view type records that can appear in an IPI stream
			// https://llvm.org/docs/PDB/CodeViewTypes.html
			// https://llvm.org/docs/PDB/TpiStream.html#tpi-vs-ipi-stream
			enum class PDB_NO_DISCARD TypeRecordKind : uint16_t
			{
				LF_FUNC_ID = 0x1601u,					// global function ID
				LF_MFUNC_ID = 0x1602u,					// member function ID
				LF_BUILDINFO = 0x1603u,					// build information
				LF_SUBSTR_LIST = 0x1604u,				// similar to LF_ARGLIST for a list of substrings
				LF_STRING_ID = 0x1605u,					// string ID
				LF_UDT_SRC_LINE = 0x1606u,				// source and line on where an UDT (User Defined Type) is defined, generated by the compiler
				LF_UDT_MOD_SRC_LINE = 0x1607u			// module, source and line on where an UDT is defined, generated by the linker
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1715
			enum class PDB_NO_DISCARD BuildInfoType : uint8_t
			{
				CurrentDirectory,		// compiler working directory
				BuildTool,				// tool path
				SourceFile,				// path to source file, relative or absolute
				TypeServerPDB,			// path to PDB file
				CommandLine				// command-line used to build the source file
			};

			struct RecordHeader
			{
				uint16_t size;					// record length, not including this 2-byte field
				TypeRecordKind kind;			// record kind
			};

			// all CodeView records are stored as a header, followed by variable-length data.
			// internal Record structs such as S_PUB32, S_GDATA32, etc. correspond to the data layout of a CodeView record of that kind.
			struct Record
			{
				RecordHeader header;
				union Data
				{
#pragma pack(push, 1)
					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1680
					struct
					{
						uint32_t scopeId; // parent scope of the ID, 0 if global
						uint32_t typeIndex; // function type
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} LF_FUNC_ID;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1687
					struct
					{
						uint32_t parentTypeIndex; // parent scope of the ID, 0 if global
						uint32_t typeIndex; // function type
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} LF_MFUNC_ID;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1694
					struct
					{
						uint32_t id;	// ID to list of sub-string IDs
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} LF_STRING_ID;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1700
					struct
					{
						uint32_t typeIndex; // UDT's type index
						uint32_t stringIndex; // index to LF_STRING_ID record where source file name is saved
						uint32_t line;  // line number
					} LF_UDT_SRC_LINE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1707
					struct
					{
						uint32_t typeIndex; // UDT's type index
						uint32_t stringIndex; // index into '/names' string table where source file name is saved
						uint32_t line;  // line number
						uint16_t moduleIndex; // module that contributes this UDT definition
					} LF_UDT_MOD_SRC_LINE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2043
					struct
					{
						uint32_t count;
						PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, typeIndices);
					} LF_SUBSTR_LIST;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1726
					struct
					{
						uint16_t count;
						PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, typeIndices);
					} LF_BUILDINFO;
#pragma pack(pop)
				} data;
			};
		}
	}
}

```

`third_party/raw_pdb/src/PDB_ImageSectionStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_ImageSectionStream.h"
#include "PDB_RawFile.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ImageSectionStream::ImageSectionStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_headers(nullptr)
	, m_count(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ImageSectionStream::ImageSectionStream(const RawFile& file, uint16_t streamIndex) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(streamIndex))
	, m_headers(m_stream.GetDataAtOffset<IMAGE_SECTION_HEADER>(0u))
	, m_count(m_stream.GetSize() / sizeof(IMAGE_SECTION_HEADER))
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD uint32_t PDB::ImageSectionStream::ConvertSectionOffsetToRVA(uint16_t oneBasedSectionIndex, uint32_t offsetInSection) const PDB_NO_EXCEPT
{
	if (oneBasedSectionIndex == 0u)
	{
		// should never happen, but prevent underflow
		return 0u;
	}
	else if (oneBasedSectionIndex > m_count)
	{
		// this symbol is "contained" in a section that is neither part of the PDB, nor the EXE.
		// it is a special compiler-generated or linker-generated symbol such as CFG symbols (e.g. __guard_fids_count, __guard_flags).
		// we can safely ignore those symbols.
		return 0u;
	}

	return m_headers[oneBasedSectionIndex - 1u].VirtualAddress + offsetInSection;
}

```

`third_party/raw_pdb/src/PDB_ImageSectionStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_Types.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class RawFile;
	struct IMAGE_SECTION_HEADER;


	class PDB_NO_DISCARD ImageSectionStream
	{
	public:
		ImageSectionStream(void) PDB_NO_EXCEPT;
		explicit ImageSectionStream(const RawFile& file, uint16_t streamIndex) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(ImageSectionStream);

		// Converts a one-based section offset into an RVA.
		PDB_NO_DISCARD uint32_t ConvertSectionOffsetToRVA(uint16_t oneBasedSectionIndex, uint32_t offsetInSection) const PDB_NO_EXCEPT;

		// Returns a view of all the sections in the stream.
		PDB_NO_DISCARD inline ArrayView<IMAGE_SECTION_HEADER> GetImageSections(void) const PDB_NO_EXCEPT
		{
			return ArrayView<IMAGE_SECTION_HEADER>(m_headers, m_count);
		}

	private:
		CoalescedMSFStream m_stream;
		const IMAGE_SECTION_HEADER* m_headers;
		size_t m_count;

		PDB_DISABLE_COPY(ImageSectionStream);
	};
}

```

`third_party/raw_pdb/src/PDB_InfoStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_InfoStream.h"
#include "PDB_RawFile.h"
#include "Foundation/PDB_CRT.h"

namespace
{
	// the PDB info stream always resides at index 1
	static constexpr const uint32_t InfoStreamIndex = 1u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::InfoStream::InfoStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_header(nullptr)
	, m_namesStreamIndex(0)
	, m_usesDebugFastlink(false)
	, m_hasIPIStream(false)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::InfoStream::InfoStream(const RawFile& file) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(InfoStreamIndex))
	, m_header(m_stream.GetDataAtOffset<const Header>(0u))
	, m_namesStreamIndex(0)
	, m_usesDebugFastlink(false)
	, m_hasIPIStream(false)
{
	// the info stream starts with the header, followed by the named stream map, followed by the feature codes
	// https://llvm.org/docs/PDB/PdbStream.html#named-stream-map
	size_t streamOffset = sizeof(Header);

	const NamedStreamMap* namedStreamMap = m_stream.GetDataAtOffset<const NamedStreamMap>(streamOffset);
	streamOffset += sizeof(NamedStreamMap) + namedStreamMap->length;

	const SerializedHashTable::Header* hashTableHeader = m_stream.GetDataAtOffset<const SerializedHashTable::Header>(streamOffset);
	streamOffset += sizeof(SerializedHashTable::Header);

	const SerializedHashTable::BitVector* presentBitVector = m_stream.GetDataAtOffset<const SerializedHashTable::BitVector>(streamOffset);
	streamOffset += sizeof(SerializedHashTable::BitVector) + sizeof(uint32_t) * presentBitVector->wordCount;

	const SerializedHashTable::BitVector* deletedBitVector = m_stream.GetDataAtOffset<const SerializedHashTable::BitVector>(streamOffset);
	streamOffset += sizeof(SerializedHashTable::BitVector) + sizeof(uint32_t) * deletedBitVector->wordCount;

	// the hash table entries can be used to identify the indices of certain common streams like:
	//	"/UDTSRCLINEUNDONE"
	//	"/src/headerblock"
	//	"/LinkInfo"
	//	"/TMCache"
	//	"/names"

	const NamedStreamMap::HashTableEntry* namedStreamMapHashEntries = m_stream.GetDataAtOffset<const NamedStreamMap::HashTableEntry>(streamOffset);

	// Find "/names" stream, used to look up filenames for lines.
	for (uint32_t i = 0, size = hashTableHeader->size; i < size; ++i)
	{
		const NamedStreamMap::HashTableEntry& entry = namedStreamMapHashEntries[i];
		const char* streamName = &namedStreamMap->stringTable[entry.stringTableOffset];

		if (strcmp("/names", streamName) == 0)
		{
			m_namesStreamIndex = entry.streamIndex;
		}
	}

	streamOffset += sizeof(NamedStreamMap::HashTableEntry) * hashTableHeader->size;

	// read feature codes by consuming remaining bytes
	// https://llvm.org/docs/PDB/PdbStream.html#pdb-feature-codes
	const FeatureCode* featureCodes = m_stream.GetDataAtOffset<const FeatureCode>(streamOffset);
	const size_t remainingBytes = m_stream.GetSize() - streamOffset;
	const size_t count = remainingBytes / sizeof(FeatureCode);

	for (size_t i=0u; i < count; ++i)
	{
		FeatureCode code = featureCodes[i];
		if (code == PDB::FeatureCode::MinimalDebugInfo)
		{
			m_usesDebugFastlink = true;
		}
		else if (code == PDB::FeatureCode::VC110 || code == PDB::FeatureCode::VC140)
		{
			m_hasIPIStream = true;
		}
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::NamesStream PDB::InfoStream::CreateNamesStream(const RawFile& file) const PDB_NO_EXCEPT
{
	return NamesStream(file, m_namesStreamIndex);
}

```

`third_party/raw_pdb/src/PDB_InfoStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "PDB_Types.h"
#include "PDB_CoalescedMSFStream.h"
#include "PDB_NamesStream.h"

namespace PDB
{
	class RawFile;


	// PDB Info Stream
	// https://llvm.org/docs/PDB/PdbStream.html
	class PDB_NO_DISCARD InfoStream
	{
	public:
		InfoStream(void) PDB_NO_EXCEPT;
		explicit InfoStream(const RawFile& file) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(InfoStream);

		// Returns the header of the stream.
		PDB_NO_DISCARD inline const Header* GetHeader(void) const PDB_NO_EXCEPT
		{
			return m_header;
		}

		// Returns whether the module has a names stream.
		PDB_NO_DISCARD inline bool HasNamesStream(void) const PDB_NO_EXCEPT
		{
			return (m_namesStreamIndex != 0u);
		}

		// Returns whether the PDB file was linked using /DEBUG:FASTLINK.
		PDB_NO_DISCARD inline bool UsesDebugFastLink(void) const PDB_NO_EXCEPT
		{
			return m_usesDebugFastlink;
		}

		// Returns whether the PDB file has an IPI stream.
		PDB_NO_DISCARD inline bool HasIPIStream(void) const PDB_NO_EXCEPT
		{
			return m_hasIPIStream;
		}

		// Create names stream
		PDB_NO_DISCARD NamesStream CreateNamesStream(const RawFile& file) const PDB_NO_EXCEPT;

	private:
		CoalescedMSFStream m_stream;
		const Header* m_header;
		uint32_t m_namesStreamIndex;
		bool m_usesDebugFastlink;
		bool m_hasIPIStream;

		PDB_DISABLE_COPY(InfoStream);
	};
}

```

`third_party/raw_pdb/src/PDB_ModuleInfoStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_ModuleInfoStream.h"
#include "Foundation/PDB_Memory.h"
#include "Foundation/PDB_CRT.h"

namespace
{
	static constexpr const char* LinkerSymbolName("* Linker *");


	// ------------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------------
	PDB_NO_DISCARD static inline size_t EstimateModuleCount(size_t streamSize) PDB_NO_EXCEPT
	{
		// work out how many modules are stored in the stream at most.
		// the module info is stored in variable-length records, so we can't determine the exact number without walking the stream.
		return streamSize / sizeof(PDB::DBI::ModuleInfo);
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream::Module::Module(void) PDB_NO_EXCEPT
	: m_info(nullptr)
	, m_name(nullptr)
	, m_nameLength(0u)
	, m_objectName(nullptr)
	, m_objectNameLength(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream::Module::Module(const DBI::ModuleInfo* info, const char* name, size_t nameLength, const char* objectName, size_t objectNameLength) PDB_NO_EXCEPT
	: m_info(info)
	, m_name(name)
	, m_nameLength(nameLength)
	, m_objectName(objectName)
	, m_objectNameLength(objectNameLength)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD bool PDB::ModuleInfoStream::Module::HasSymbolStream(void) const PDB_NO_EXCEPT
{
	const uint16_t streamIndex = m_info->moduleSymbolStreamIndex;

	// some modules don't have a symbol stream, i.e. no additional debug information is present.
	// this usually happens when private symbols are stripped from a PDB.
	return (streamIndex != 0xFFFFu);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD bool PDB::ModuleInfoStream::Module::HasLineStream(void) const PDB_NO_EXCEPT
{
	return (m_info->c13Size > 0);
}

// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ModuleSymbolStream PDB::ModuleInfoStream::Module::CreateSymbolStream(const RawFile& file) const PDB_NO_EXCEPT
{
	PDB_ASSERT(HasSymbolStream(), "Module symbol stream index is invalid.");

	return ModuleSymbolStream(file, m_info->moduleSymbolStreamIndex, m_info->symbolSize);
}

PDB_NO_DISCARD PDB::ModuleLineStream PDB::ModuleInfoStream::Module::CreateLineStream(const RawFile& file) const PDB_NO_EXCEPT
{
	PDB_ASSERT(HasLineStream(), "Module line stream is not present.");

	return ModuleLineStream(file, m_info->moduleSymbolStreamIndex, m_info->symbolSize + m_info->c11Size + m_info->c13Size, m_info->symbolSize + m_info->c11Size);
}

// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream::ModuleInfoStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_modules(nullptr)
	, m_moduleCount(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream::ModuleInfoStream(ModuleInfoStream&& other) PDB_NO_EXCEPT
	: m_stream(PDB_MOVE(other.m_stream))
	, m_modules(PDB_MOVE(other.m_modules))
	, m_moduleCount(PDB_MOVE(other.m_moduleCount))
{
	other.m_modules = nullptr;
	other.m_moduleCount = 0u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream& PDB::ModuleInfoStream::operator=(ModuleInfoStream&& other) PDB_NO_EXCEPT
{
	if (this != &other)
	{
		PDB_DELETE_ARRAY(m_modules);

		m_stream = PDB_MOVE(other.m_stream);
		m_modules = PDB_MOVE(other.m_modules);
		m_moduleCount = PDB_MOVE(other.m_moduleCount);

		other.m_modules = nullptr;
		other.m_moduleCount = 0u;
	}

	return *this;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream::ModuleInfoStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT
	: m_stream(directStream, size, offset)
	, m_modules(nullptr)
	, m_moduleCount(0u)
{
	m_modules = PDB_NEW_ARRAY(Module, EstimateModuleCount(size));

	size_t streamOffset = 0u;
	while (streamOffset < size)
	{
		const DBI::ModuleInfo* moduleInfo = m_stream.GetDataAtOffset<const DBI::ModuleInfo>(streamOffset);
		streamOffset += sizeof(DBI::ModuleInfo);

		const char* name = m_stream.GetDataAtOffset<const char>(streamOffset);
		const size_t nameLength = strlen(name);
		streamOffset += nameLength + 1u;

		const char* objectName = m_stream.GetDataAtOffset<const char>(streamOffset);
		const size_t objectNameLength = strlen(objectName);
		streamOffset += objectNameLength + 1u;

		// the stream is aligned to 4 bytes
		streamOffset = BitUtil::RoundUpToMultiple<size_t>(streamOffset, 4ul);

		m_modules[m_moduleCount] = Module(moduleInfo, name, nameLength, objectName, objectNameLength);
		++m_moduleCount;
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleInfoStream::~ModuleInfoStream(void) PDB_NO_EXCEPT
{
	PDB_DELETE_ARRAY(m_modules);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD const PDB::ModuleInfoStream::Module* PDB::ModuleInfoStream::FindLinkerModule(void) const PDB_NO_EXCEPT
{
	const size_t count = m_moduleCount;
	for (size_t i = 0u; i < count; ++i)
	{
		// with both MSVC cl.exe and Clang, the linker symbol is the last one to be stored, so start searching from the end
		const Module& module = m_modules[count - i - 1u];

		// check if this is the linker symbol
		if (strcmp(module.GetName().Decay(), LinkerSymbolName) == 0)
		{
			return &module;
		}
	}

	return nullptr;
}

```

`third_party/raw_pdb/src/PDB_ModuleInfoStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_CoalescedMSFStream.h"
#include "PDB_ModuleSymbolStream.h"
#include "PDB_ModuleLineStream.h"

namespace PDB
{
	class PDB_NO_DISCARD DirectMSFStream;

	class PDB_NO_DISCARD ModuleInfoStream
	{
	public:
		class PDB_NO_DISCARD Module
		{
		public:
			Module(void) PDB_NO_EXCEPT;
			explicit Module(const DBI::ModuleInfo* info, const char* name, size_t nameLength, const char* objectName, size_t objectNameLength) PDB_NO_EXCEPT;

			PDB_DEFAULT_MOVE(Module);

			// Returns whether the module has a symbol stream.
			PDB_NO_DISCARD bool HasSymbolStream(void) const PDB_NO_EXCEPT;

			// Returns whether the module has a line stream.
			PDB_NO_DISCARD bool HasLineStream(void) const PDB_NO_EXCEPT;

			// Creates a symbol stream for the module.
			PDB_NO_DISCARD ModuleSymbolStream CreateSymbolStream(const RawFile& file) const PDB_NO_EXCEPT;

			// Create a line stream for the module
			PDB_NO_DISCARD ModuleLineStream CreateLineStream(const RawFile& file) const PDB_NO_EXCEPT;


			// Returns the PDB module info.
			PDB_NO_DISCARD inline const DBI::ModuleInfo* GetInfo(void) const PDB_NO_EXCEPT
			{
				return m_info;
			}

			// Returns the name of the module.
			PDB_NO_DISCARD inline ArrayView<char> GetName(void) const PDB_NO_EXCEPT
			{
				return ArrayView<char>(m_name, m_nameLength);
			}

			// Returns the name of the object file of the module.
			PDB_NO_DISCARD inline ArrayView<char> GetObjectName(void) const PDB_NO_EXCEPT
			{
				return ArrayView<char>(m_objectName, m_objectNameLength);
			}

		private:
			// the module info is stored in variable-length arrays inside the stream, so rather than store an array directly,
			// we need to store pointers to the individual data items inside the stream.
			const DBI::ModuleInfo* m_info;

			// the module name, e.g. the path to an object file or import library such as "Import:kernel32.dll"
			const char* m_name;
			size_t m_nameLength;
			
			// the name of the object file. either the same as the module name, or the path to the archive that contained the module
			const char* m_objectName;
			size_t m_objectNameLength;

			PDB_DISABLE_COPY(Module);
		};

		ModuleInfoStream(void) PDB_NO_EXCEPT;
		ModuleInfoStream(ModuleInfoStream&& other) PDB_NO_EXCEPT;
		ModuleInfoStream& operator=(ModuleInfoStream&& other) PDB_NO_EXCEPT;

		explicit ModuleInfoStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT;

		~ModuleInfoStream(void) PDB_NO_EXCEPT;

		// Tries to find the linker module corresponding to the linker, i.e. the module named "* Linker *".
		PDB_NO_DISCARD const Module* FindLinkerModule(void) const PDB_NO_EXCEPT;

		// Returns the module with the given index.
		PDB_NO_DISCARD inline const Module& GetModule(uint32_t index) const PDB_NO_EXCEPT
		{
			return m_modules[index];
		}

		// Returns a view of all modules in the info stream.
		PDB_NO_DISCARD inline ArrayView<Module> GetModules(void) const PDB_NO_EXCEPT
		{
			return ArrayView<Module>(m_modules, m_moduleCount);
		}

	private:
		CoalescedMSFStream m_stream;
		Module* m_modules;
		size_t m_moduleCount;

		PDB_DISABLE_COPY(ModuleInfoStream);
	};
}

```

`third_party/raw_pdb/src/PDB_ModuleLineStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_ModuleLineStream.h"
#include "PDB_RawFile.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleLineStream::ModuleLineStream(void) PDB_NO_EXCEPT
	: m_stream(), m_c13LineInfoOffset(0)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleLineStream::ModuleLineStream(const RawFile& file, uint16_t streamIndex, uint32_t streamSize, size_t c13LineInfoOffset) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(streamIndex, streamSize)), m_c13LineInfoOffset(c13LineInfoOffset)
{
	// https://llvm.org/docs/PDB/ModiStream.html
	// struct ModiStream {
	//	uint32_t Signature;
	//	uint8_t Symbols[SymbolSize - 4];
	//	uint8_t C11LineInfo[C11Size];
	//	uint8_t C13LineInfo[C13Size];
	//	uint32_t GlobalRefsSize;
	//	uint8_t GlobalRefs[GlobalRefsSize];
	// };
}

```

`third_party/raw_pdb/src/PDB_ModuleLineStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_BitUtil.h"
#include "PDB_DBITypes.h"
#include "PDB_Util.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class RawFile;

	class PDB_NO_DISCARD ModuleLineStream
	{
	public:
		ModuleLineStream(void) PDB_NO_EXCEPT;
		explicit ModuleLineStream(const RawFile& file, uint16_t streamIndex, uint32_t streamSize, size_t c13LineInfoOffset) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(ModuleLineStream);

		template <typename F>
		void ForEachSection(F&& functor) const PDB_NO_EXCEPT
		{
			size_t offset = m_c13LineInfoOffset;

			// read the line stream sections
			while (offset < m_stream.GetSize())
			{
				const CodeView::DBI::LineSection* section = m_stream.GetDataAtOffset<const CodeView::DBI::LineSection>(offset);

				functor(section);

				offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + section->header.size, 4u);
			}
		}

		template <typename F>
		void ForEachLinesBlock(const CodeView::DBI::LineSection* section, F&& functor) const PDB_NO_EXCEPT
		{
			PDB_ASSERT(section->header.kind == CodeView::DBI::DebugSubsectionKind::S_LINES,
				"DebugSubsectionHeader::Kind %X != S_LINES (%X)", 
				static_cast<uint32_t>(section->header.kind), static_cast<uint32_t>(CodeView::DBI::DebugSubsectionKind::S_LINES));

			size_t offset = m_stream.GetPointerOffset(section);
			const size_t headerEnd = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + section->header.size, 4u);

			offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + sizeof(CodeView::DBI::LinesHeader), 4u);

			// read all blocks of lines
			while (offset < headerEnd)
			{
				const CodeView::DBI::LinesFileBlockHeader* linesBlockHeader = m_stream.GetDataAtOffset<const CodeView::DBI::LinesFileBlockHeader>(offset);
				const CodeView::DBI::Line* blockLines = m_stream.GetDataAtOffset<const CodeView::DBI::Line>(offset + sizeof(CodeView::DBI::LinesFileBlockHeader));

				const size_t blockColumnsOffset = sizeof(CodeView::DBI::LinesFileBlockHeader) + (linesBlockHeader->numLines * (sizeof(CodeView::DBI::Line)));
				const CodeView::DBI::Column* blockColumns = blockColumnsOffset < linesBlockHeader->size ? m_stream.GetDataAtOffset<const CodeView::DBI::Column>(offset) : nullptr;

				functor(linesBlockHeader, blockLines, blockColumns);

				offset = BitUtil::RoundUpToMultiple<size_t>(offset + linesBlockHeader->size, 4u);
			}

			PDB_ASSERT(offset == headerEnd, "Mismatch between offset %zu and header end %zu when reading lines blocks", offset, headerEnd);
		}

		template <typename F>
		void ForEachFileChecksum(const CodeView::DBI::LineSection* section, F&& functor) const PDB_NO_EXCEPT
		{
			PDB_ASSERT(section->header.kind == CodeView::DBI::DebugSubsectionKind::S_FILECHECKSUMS,
				"DebugSubsectionHeader::Kind %X != S_FILECHECKSUMS (%X)", 
				static_cast<uint32_t>(section->header.kind), static_cast<uint32_t>(CodeView::DBI::DebugSubsectionKind::S_FILECHECKSUMS));

			size_t offset = m_stream.GetPointerOffset(section);
			const size_t headerEnd = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + section->header.size, 4u);

			offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader), 4u);

			// read all file checksums
			while (offset < headerEnd)
			{
				const CodeView::DBI::FileChecksumHeader* fileChecksumHeader = m_stream.GetDataAtOffset<const CodeView::DBI::FileChecksumHeader>(offset);

				functor(fileChecksumHeader);

				offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::FileChecksumHeader) + fileChecksumHeader->checksumSize, 4u);
			}

			PDB_ASSERT(offset == headerEnd, "Mismatch between offset %zu and header end %zu when reading file checksums", offset, headerEnd);
		}

		template <typename F>
		void ForEachInlineeSourceLine(const CodeView::DBI::LineSection* section, F&& functor) const PDB_NO_EXCEPT
		{
			PDB_ASSERT(section->header.kind == CodeView::DBI::DebugSubsectionKind::S_INLINEELINES,
				"DebugSubsectionHeader::Kind %X != S_INLINEELINES (%X)", 
				static_cast<uint32_t>(section->header.kind), static_cast<uint32_t>(CodeView::DBI::DebugSubsectionKind::S_INLINEELINES));

			PDB_ASSERT(section->inlineeHeader.kind == CodeView::DBI::InlineeSourceLineKind::Signature,
				"InlineeSourceLineKind %X != :InlineeSourceLineKind::Signature (%X)", static_cast<uint32_t>(section->header.kind), static_cast<uint32_t>(CodeView::DBI::InlineeSourceLineKind::Signature));

			size_t offset = m_stream.GetPointerOffset(section);
			const size_t headerEnd = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + section->header.size, 4u);

			offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + sizeof(CodeView::DBI::InlineeSourceLineHeader), 4u);

			// read all file checksums
			while (offset < headerEnd)
			{
				const CodeView::DBI::InlineeSourceLine* inlineeSourceLine = m_stream.GetDataAtOffset<const CodeView::DBI::InlineeSourceLine>(offset);

				functor(inlineeSourceLine);

				offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::InlineeSourceLine), 4u);
			}
		}

		template <typename F>
		void ForEachInlineeSourceLineEx(const CodeView::DBI::LineSection* section, F&& functor) const PDB_NO_EXCEPT
		{
			PDB_ASSERT(section->header.kind == CodeView::DBI::DebugSubsectionKind::S_INLINEELINES,
				"DebugSubsectionHeader::Kind %X != S_INLINEELINES (%X)", static_cast<uint32_t>(section->header.kind), static_cast<uint32_t>(CodeView::DBI::DebugSubsectionKind::S_INLINEELINES));

			PDB_ASSERT(section->inlineeHeader.kind == CodeView::DBI::InlineeSourceLineKind::SignatureEx,
				"InlineeSourceLineKind %X != :InlineeSourceLineKind::SignatureEx (%X)", static_cast<uint32_t>(section->header.kind), static_cast<uint32_t>(CodeView::DBI::InlineeSourceLineKind::SignatureEx));

			size_t offset = m_stream.GetPointerOffset(section);
			const size_t headerEnd = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + section->header.size, 4u);

			offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::DebugSubsectionHeader) + sizeof(CodeView::DBI::InlineeSourceLineHeader), 4u);

			// read all file checksums
			while (offset < headerEnd)
			{
				const CodeView::DBI::InlineeSourceLineEx* inlineeSourceLineEx = m_stream.GetDataAtOffset<const CodeView::DBI::InlineeSourceLineEx>(offset);

				functor(inlineeSourceLineEx);

				offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::InlineeSourceLineEx) + (inlineeSourceLineEx->extraLines * sizeof(uint32_t)), 4u);
			}
		}
	private:
		CoalescedMSFStream m_stream;
		size_t m_c13LineInfoOffset;

		PDB_DISABLE_COPY(ModuleLineStream);
	};
}

```

`third_party/raw_pdb/src/PDB_ModuleSymbolStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_ModuleSymbolStream.h"
#include "PDB_RawFile.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleSymbolStream::ModuleSymbolStream(void) PDB_NO_EXCEPT
	: m_stream()
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::ModuleSymbolStream::ModuleSymbolStream(const RawFile& file, uint16_t streamIndex, uint32_t symbolStreamSize) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(streamIndex, symbolStreamSize))
{
	// https://llvm.org/docs/PDB/ModiStream.html
	// struct ModiStream {
	//	uint32_t Signature;
	//	uint8_t Symbols[SymbolSize - 4];
	//	uint8_t C11LineInfo[C11Size];
	//	uint8_t C13LineInfo[C13Size];
	//	uint32_t GlobalRefsSize;
	//	uint8_t GlobalRefs[GlobalRefsSize];
	// };
	// we are only interested in the symbols, but not the line information or global refs.
	// the coalesced stream is therefore only built for the symbols, not all the data in the stream.
	// this potentially saves a lot of memory and performance on large PDBs.
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD const PDB::CodeView::DBI::Record* PDB::ModuleSymbolStream::FindRecord(CodeView::DBI::SymbolRecordKind kind) const PDB_NO_EXCEPT
{
	// ignore the stream's 4-byte signature
	size_t offset = sizeof(uint32_t);

	// parse the CodeView records
	while (offset < m_stream.GetSize())
	{
		// https://llvm.org/docs/PDB/CodeViewTypes.html
		const CodeView::DBI::Record* record = m_stream.GetDataAtOffset<const CodeView::DBI::Record>(offset);
		if (record->header.kind == kind)
		{
			return record;
		}

		const uint32_t recordSize = GetCodeViewRecordSize(record);

		// position the module stream offset at the next record
		offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::RecordHeader) + recordSize, 4u);
	}

	return nullptr;
}

```

`third_party/raw_pdb/src/PDB_ModuleSymbolStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_BitUtil.h"
#include "PDB_DBITypes.h"
#include "PDB_Util.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class RawFile;


	class PDB_NO_DISCARD ModuleSymbolStream
	{
	public:
		ModuleSymbolStream(void) PDB_NO_EXCEPT;
		explicit ModuleSymbolStream(const RawFile& file, uint16_t streamIndex, uint32_t symbolStreamSize) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(ModuleSymbolStream);

		// Returns a record's parent record.
		template <typename T>
		PDB_NO_DISCARD inline const CodeView::DBI::Record* GetParentRecord(const T& record) const PDB_NO_EXCEPT
		{
			return m_stream.GetDataAtOffset<const CodeView::DBI::Record>(record.parent);
		}

		// Returns a record's end record.
		template <typename T>
		PDB_NO_DISCARD inline const CodeView::DBI::Record* GetEndRecord(const T& record) const PDB_NO_EXCEPT
		{
			return m_stream.GetDataAtOffset<const CodeView::DBI::Record>(record.end);
		}

		// Finds a record of a certain kind.
		PDB_NO_DISCARD const CodeView::DBI::Record* FindRecord(CodeView::DBI::SymbolRecordKind Kind) const PDB_NO_EXCEPT;


		// Iterates all records in the stream.
		template <typename F>
		void ForEachSymbol(F&& functor) const PDB_NO_EXCEPT
		{
			// ignore the stream's 4-byte signature
			size_t offset = sizeof(uint32_t);

			// parse the CodeView records
			while (offset < m_stream.GetSize())
			{
				// https://llvm.org/docs/PDB/CodeViewTypes.html
				const CodeView::DBI::Record* record = m_stream.GetDataAtOffset<const CodeView::DBI::Record>(offset);
				const uint32_t recordSize = GetCodeViewRecordSize(record);

				functor(record);

				// position the module stream offset at the next record
				offset = BitUtil::RoundUpToMultiple<size_t>(offset + sizeof(CodeView::DBI::RecordHeader) + recordSize, 4u);
			}
		}

	private:
		CoalescedMSFStream m_stream;

		PDB_DISABLE_COPY(ModuleSymbolStream);
	};
}

```

`third_party/raw_pdb/src/PDB_NamesStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_NamesStream.h"
#include "PDB_RawFile.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::NamesStream::NamesStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_header(nullptr)
	, m_stringTable(nullptr)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::NamesStream::NamesStream(const RawFile& file, uint32_t streamIndex) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(streamIndex))
	, m_header(m_stream.GetDataAtOffset<const NamesHeader>(0u))
	, m_stringTable(nullptr)
{
	// grab a pointer into the string table
	m_stringTable = m_stream.GetDataAtOffset<char>(sizeof(NamesHeader));
}

```

`third_party/raw_pdb/src/PDB_NamesStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "PDB_Types.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class RawFile;

	struct NamesHeader
	{
		uint32_t magic;
		uint32_t hashVersion;
		uint32_t size;
	};

	class PDB_NO_DISCARD NamesStream
	{
	public:
		NamesStream(void) PDB_NO_EXCEPT;
		explicit NamesStream(const RawFile& file, uint32_t streamIndex) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(NamesStream);

		// Returns the header of the stream.
		PDB_NO_DISCARD inline const NamesHeader* GetHeader(void) const PDB_NO_EXCEPT
		{
			return m_header;
		}

		PDB_NO_DISCARD inline const char* GetFilename(uint32_t filenameOffset) const PDB_NO_EXCEPT
		{
			return m_stringTable + filenameOffset;
		}

	private:
		CoalescedMSFStream m_stream;
		const NamesHeader* m_header;
		const char* m_stringTable;

		PDB_DISABLE_COPY(NamesStream);
	};
}

```

`third_party/raw_pdb/src/PDB_PCH.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"

```

`third_party/raw_pdb/src/PDB_PCH.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

// this needs to be the first include, since it determines the platform/toolchain we're compiling for
#include "Foundation/PDB_Platform.h"
#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_Warnings.h"

// library includes
#include "Foundation/PDB_Log.h"
#include "Foundation/PDB_Assert.h"
#include "Foundation/PDB_Move.h"
#include "Foundation/PDB_Forward.h"
#include "Foundation/PDB_Memory.h"
#include "Foundation/PDB_ArrayView.h"
#include "Foundation/PDB_BitUtil.h"
#include "Foundation/PDB_BitOperators.h"
#include "Foundation/PDB_PointerUtil.h"

```

`third_party/raw_pdb/src/PDB_PublicSymbolStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_PublicSymbolStream.h"
#include "PDB_RawFile.h"
#include "PDB_Types.h"
#include "PDB_DBITypes.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::PublicSymbolStream::PublicSymbolStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_hashRecords(nullptr)
	, m_count(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::PublicSymbolStream::PublicSymbolStream(const RawFile& file, uint16_t streamIndex, uint32_t count) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<CoalescedMSFStream>(streamIndex))
	, m_hashRecords(m_stream.GetDataAtOffset<HashRecord>(sizeof(PublicStreamHeader) + sizeof(HashTableHeader)))
	, m_count(count)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD const PDB::CodeView::DBI::Record* PDB::PublicSymbolStream::GetRecord(const CoalescedMSFStream& symbolRecordStream, const HashRecord& hashRecord) const PDB_NO_EXCEPT
{
	// hash record offsets start at 1, not at 0
	const uint32_t headerOffset = hashRecord.offset - 1u;

	// the offset doesn't point to the public symbol directly, but to the CodeView record:
	// https://llvm.org/docs/PDB/CodeViewSymbols.html
	const CodeView::DBI::Record* record = symbolRecordStream.GetDataAtOffset<const CodeView::DBI::Record>(headerOffset);

	return record;
}

```

`third_party/raw_pdb/src/PDB_PublicSymbolStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class RawFile;
	struct HashRecord;

	namespace CodeView
	{
		namespace DBI
		{
			struct Record;
		}		
	}


	class PDB_NO_DISCARD PublicSymbolStream
	{
	public:
		PublicSymbolStream(void) PDB_NO_EXCEPT;
		explicit PublicSymbolStream(const RawFile& file, uint16_t streamIndex, uint32_t count) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(PublicSymbolStream);

		// Turns a given hash record into a DBI record using the given symbol stream.
		PDB_NO_DISCARD const CodeView::DBI::Record* GetRecord(const CoalescedMSFStream& symbolRecordStream, const HashRecord& hashRecord) const PDB_NO_EXCEPT;

		// Returns a view of all the records in the stream.
		PDB_NO_DISCARD inline ArrayView<HashRecord> GetRecords(void) const PDB_NO_EXCEPT
		{
			return ArrayView<HashRecord>(m_hashRecords, m_count);
		}

	private:
		CoalescedMSFStream m_stream;
		const HashRecord* m_hashRecords;
		uint32_t m_count;

		PDB_DISABLE_COPY(PublicSymbolStream);
	};
}

```

`third_party/raw_pdb/src/PDB_RawFile.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_RawFile.h"
#include "PDB_Types.h"
#include "PDB_Util.h"
#include "PDB_DirectMSFStream.h"
#include "Foundation/PDB_PointerUtil.h"
#include "Foundation/PDB_Memory.h"
#include "Foundation/PDB_Assert.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::RawFile::RawFile(RawFile&& other) PDB_NO_EXCEPT
	: m_data(PDB_MOVE(other.m_data))
	, m_superBlock(PDB_MOVE(other.m_superBlock))
	, m_directoryStream(PDB_MOVE(other.m_directoryStream))
	, m_streamCount(PDB_MOVE(other.m_streamCount))
	, m_streamSizes(PDB_MOVE(other.m_streamSizes))
	, m_streamBlocks(PDB_MOVE(other.m_streamBlocks))
{
	other.m_data = nullptr;
	other.m_superBlock = nullptr;
	other.m_streamCount = 0u;
	other.m_streamSizes = nullptr;
	other.m_streamBlocks = nullptr;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::RawFile& PDB::RawFile::operator=(RawFile&& other) PDB_NO_EXCEPT
{
	if (this != &other)
	{
		PDB_DELETE_ARRAY(m_streamBlocks);

		m_data = PDB_MOVE(other.m_data);
		m_superBlock = PDB_MOVE(other.m_superBlock);
		m_directoryStream = PDB_MOVE(other.m_directoryStream);
		m_streamCount = PDB_MOVE(other.m_streamCount);
		m_streamSizes = PDB_MOVE(other.m_streamSizes);
		m_streamBlocks = PDB_MOVE(other.m_streamBlocks);

		other.m_data = nullptr;
		other.m_superBlock = nullptr;
		other.m_streamCount = 0u;
		other.m_streamSizes = nullptr;
		other.m_streamBlocks = nullptr;
	}

	return *this;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::RawFile::RawFile(const void* data) PDB_NO_EXCEPT
	: m_data(data)
	, m_superBlock(Pointer::Offset<const SuperBlock*>(data, 0u))
	, m_directoryStream()
	, m_streamCount(0u)
	, m_streamSizes(nullptr)
	, m_streamBlocks(nullptr)
{
	// the SuperBlock stores an array of indices of blocks that make up the indices of directory blocks, which need to be stitched together to form the directory.
	// the blocks holding the indices of directory blocks are not necessarily contiguous, so they need to be coalesced first.
	const uint32_t directoryBlockCount = PDB::ConvertSizeToBlockCount(m_superBlock->directorySize, m_superBlock->blockSize);

	// the directory is made up of directoryBlockCount blocks, so we need that many indices to be read from the blocks that make up the indices
	CoalescedMSFStream directoryIndicesStream(data, m_superBlock->blockSize, m_superBlock->directoryBlockIndices, directoryBlockCount * sizeof(uint32_t));

	// these are the indices of blocks making up the directory stream, now guaranteed to be contiguous
	const uint32_t* directoryIndices = directoryIndicesStream.GetDataAtOffset<uint32_t>(0u);

	m_directoryStream = CoalescedMSFStream(data, m_superBlock->blockSize, directoryIndices, m_superBlock->directorySize);

	// https://llvm.org/docs/PDB/MsfFile.html#the-stream-directory
	// parse the directory from its contiguous version. the directory matches the following struct:
	//	struct StreamDirectory
	//	{
	//		uint32_t streamCount;
	//		uint32_t streamSizes[streamCount];
	//		uint32_t streamBlocks[streamCount][];
	//	};
	m_streamCount = *m_directoryStream.GetDataAtOffset<uint32_t>(0u);

	// we can assign pointers into the stream directly, since the RawFile keeps ownership of the directory stream
	m_streamSizes = m_directoryStream.GetDataAtOffset<uint32_t>(sizeof(uint32_t));
	const uint32_t* directoryStreamBlocks = m_directoryStream.GetDataAtOffset<uint32_t>(sizeof(uint32_t) + sizeof(uint32_t) * m_streamCount);

	// prepare indices for directly accessing individual streams
	m_streamBlocks = PDB_NEW_ARRAY(const uint32_t*, m_streamCount);

	const uint32_t* indicesForCurrentBlock = directoryStreamBlocks;
	for (uint32_t i = 0u; i < m_streamCount; ++i)
	{
		const uint32_t sizeInBytes = GetStreamSize(i);
		const uint32_t blockCount = ConvertSizeToBlockCount(sizeInBytes, m_superBlock->blockSize);
		m_streamBlocks[i] = indicesForCurrentBlock;
		
		indicesForCurrentBlock += blockCount;
	}
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::RawFile::~RawFile(void) PDB_NO_EXCEPT
{
	PDB_DELETE_ARRAY(m_streamBlocks);
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
template <typename T>
PDB_NO_DISCARD T PDB::RawFile::CreateMSFStream(uint32_t streamIndex) const PDB_NO_EXCEPT
{
	PDB_ASSERT(streamIndex != PDB::NilStreamIndex, "Invalid stream index.");
	PDB_ASSERT(streamIndex < m_streamCount, "Invalid stream index.");

	return T(m_data, m_superBlock->blockSize, m_streamBlocks[streamIndex], GetStreamSize(streamIndex));
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
template <typename T>
PDB_NO_DISCARD T PDB::RawFile::CreateMSFStream(uint32_t streamIndex, uint32_t streamSize) const PDB_NO_EXCEPT
{
	PDB_ASSERT(streamIndex != PDB::NilStreamIndex, "Invalid stream index.");
	PDB_ASSERT(streamIndex < m_streamCount, "Invalid stream index.");
	PDB_ASSERT(streamSize <= GetStreamSize(streamIndex), "Invalid stream size.");

	return T(m_data, m_superBlock->blockSize, m_streamBlocks[streamIndex], streamSize);
}


// explicit template instantiation
template PDB::CoalescedMSFStream PDB::RawFile::CreateMSFStream<PDB::CoalescedMSFStream>(uint32_t streamIndex) const PDB_NO_EXCEPT;
template PDB::DirectMSFStream PDB::RawFile::CreateMSFStream<PDB::DirectMSFStream>(uint32_t streamIndex) const PDB_NO_EXCEPT;

template PDB::CoalescedMSFStream PDB::RawFile::CreateMSFStream<PDB::CoalescedMSFStream>(uint32_t streamIndex, uint32_t streamSize) const PDB_NO_EXCEPT;
template PDB::DirectMSFStream PDB::RawFile::CreateMSFStream<PDB::DirectMSFStream>(uint32_t streamIndex, uint32_t streamSize) const PDB_NO_EXCEPT;

```

`third_party/raw_pdb/src/PDB_RawFile.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "PDB_CoalescedMSFStream.h"


// https://llvm.org/docs/PDB/index.html
namespace PDB
{
	struct SuperBlock;


	class PDB_NO_DISCARD RawFile
	{
	public:
		RawFile(RawFile&& other) PDB_NO_EXCEPT;
		RawFile& operator=(RawFile&& other) PDB_NO_EXCEPT;

		explicit RawFile(const void* data) PDB_NO_EXCEPT;
		~RawFile(void) PDB_NO_EXCEPT;

		// Creates any type of MSF stream.
		template <typename T>
		PDB_NO_DISCARD T CreateMSFStream(uint32_t streamIndex) const PDB_NO_EXCEPT;

		// Creates any type of MSF stream with the given size.
		template <typename T>
		PDB_NO_DISCARD T CreateMSFStream(uint32_t streamIndex, uint32_t streamSize) const PDB_NO_EXCEPT;


		// Returns the SuperBlock.
		PDB_NO_DISCARD inline const SuperBlock* GetSuperBlock(void) const PDB_NO_EXCEPT
		{
			return m_superBlock;
		}

		// Returns the number of streams in the PDB file.
		PDB_NO_DISCARD inline uint32_t GetStreamCount(void) const PDB_NO_EXCEPT
		{
			return m_streamCount;
		}

		// Returns the size of the stream with the given index, taking into account nil page sizes.
		PDB_NO_DISCARD inline uint32_t GetStreamSize(uint32_t streamIndex) const PDB_NO_EXCEPT
		{
			const uint32_t streamSize = m_streamSizes[streamIndex];

			return (streamSize == NilPageSize) ? 0u : streamSize;
		}

	private:
		const void* m_data;
		const SuperBlock* m_superBlock;
		CoalescedMSFStream m_directoryStream;

		// stream directory
		uint32_t m_streamCount;
		const uint32_t* m_streamSizes;
		const uint32_t** m_streamBlocks;

		PDB_DISABLE_COPY(RawFile);
	};
}

```

`third_party/raw_pdb/src/PDB_SectionContributionStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_SectionContributionStream.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::SectionContributionStream::SectionContributionStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_contributions(nullptr)
	, m_count(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::SectionContributionStream::SectionContributionStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT
	: m_stream(directStream, size, offset)
	, m_contributions(m_stream.GetDataAtOffset<DBI::SectionContribution>(0u))
	, m_count(size / sizeof(DBI::SectionContribution))
{
}

```

`third_party/raw_pdb/src/PDB_SectionContributionStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_DBITypes.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class PDB_NO_DISCARD DirectMSFStream;


	class PDB_NO_DISCARD SectionContributionStream
	{
	public:
		SectionContributionStream(void) PDB_NO_EXCEPT;
		explicit SectionContributionStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(SectionContributionStream);

		// Returns a view of all section contributions in the stream.
		PDB_NO_DISCARD inline ArrayView<DBI::SectionContribution> GetContributions(void) const PDB_NO_EXCEPT
		{
			return ArrayView<DBI::SectionContribution>(m_contributions, m_count);
		}

	private:
		CoalescedMSFStream m_stream;
		const DBI::SectionContribution* m_contributions;
		size_t m_count;

		PDB_DISABLE_COPY(SectionContributionStream);
	};
}

```

`third_party/raw_pdb/src/PDB_SourceFileStream.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_SourceFileStream.h"


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::SourceFileStream::SourceFileStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_moduleCount(0u)
	, m_moduleIndices(nullptr)
	, m_moduleFileCounts(nullptr)
	, m_fileNameOffsets(nullptr)
	, m_stringTable(nullptr)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::SourceFileStream::SourceFileStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT
	: m_stream(directStream, size, offset)
	, m_moduleCount(0u)
	, m_moduleIndices(nullptr)
	, m_moduleFileCounts(nullptr)
	, m_fileNameOffsets(nullptr)
	, m_stringTable(nullptr)
{
	// we are going to consume the whole source info sub-stream, so create a coalesced stream for faster read operations and direct access.
	// the sub-stream has the following layout:
	//	struct SourceInfoSubstream
	//	{
	//		uint16_t moduleCount;
	//		uint16_t sourceFileCount;
	//		uint16_t moduleIndices[moduleCount];
	//		uint16_t moduleFileCounts[moduleCount];
	//		uint32_t fileNameOffsets[realSourceFileCount];
	//		char stringTable[][realSourceFileCount];
	//	};
	m_moduleCount = *m_stream.GetDataAtOffset<uint16_t>(0u);
	size_t readOffset = sizeof(uint16_t);

	// skip number of source files. this would only support 64k unique files and is no longer used.
	// the number of source files is computed dynamically instead.
	readOffset += sizeof(uint16_t);

	// grab direct pointers into the stream data
	m_moduleIndices = m_stream.GetDataAtOffset<uint16_t>(readOffset);
	readOffset += sizeof(uint16_t) * m_moduleCount;

	m_moduleFileCounts = m_stream.GetDataAtOffset<uint16_t>(readOffset);
	readOffset += sizeof(uint16_t) * m_moduleCount;

	// count the actual number of source files
	size_t sourceFileCount = 0u;
	for (unsigned int i = 0u; i < m_moduleCount; ++i)
	{
		sourceFileCount += m_moduleFileCounts[i];
	}

	m_fileNameOffsets = m_stream.GetDataAtOffset<uint32_t>(readOffset);
	readOffset += sizeof(uint32_t) * sourceFileCount;

	// grab a pointer into the string table
	m_stringTable = m_stream.GetDataAtOffset<char>(readOffset);
}

```

`third_party/raw_pdb/src/PDB_SourceFileStream.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_CoalescedMSFStream.h"


namespace PDB
{
	class PDB_NO_DISCARD DirectMSFStream;


	class PDB_NO_DISCARD SourceFileStream
	{
	public:
		SourceFileStream(void) PDB_NO_EXCEPT;
		explicit SourceFileStream(const DirectMSFStream& directStream, uint32_t size, uint32_t offset) PDB_NO_EXCEPT;

		PDB_DEFAULT_MOVE(SourceFileStream);

		// Returns the number of modules.
		PDB_NO_DISCARD inline uint32_t GetModuleCount(void) const PDB_NO_EXCEPT
		{
			return m_moduleCount;
		}

		// Returns a view of all the filename offsets for the module with the given index.
		PDB_NO_DISCARD inline ArrayView<uint32_t> GetModuleFilenameOffsets(size_t moduleIndex) const PDB_NO_EXCEPT
		{
			const uint16_t moduleStartIndex = m_moduleIndices[moduleIndex];
			const uint16_t moduleFileCount = m_moduleFileCounts[moduleIndex];
			
			return ArrayView<uint32_t>(m_fileNameOffsets + moduleStartIndex, moduleFileCount);
		}

		// Returns a filename for the given filename offset.
		PDB_NO_DISCARD inline const char* GetFilename(uint32_t filenameOffset) const PDB_NO_EXCEPT
		{
			return m_stringTable + filenameOffset;
		}

	private:
		CoalescedMSFStream m_stream;

		// the number of modules
		uint32_t m_moduleCount;

		// the indices into the file name offsets, for each module
		const uint16_t* m_moduleIndices;

		// the number of files, for each module
		const uint16_t* m_moduleFileCounts;

		// the filename offsets into the string table, for all modules
		const uint32_t* m_fileNameOffsets;

		// the string table storing all filenames
		const char* m_stringTable;

		PDB_DISABLE_COPY(SourceFileStream);
	};
}

```

`third_party/raw_pdb/src/PDB_TPIStream.cpp`:

```cpp
#include "PDB_PCH.h"
#include "PDB_TPIStream.h"
#include "PDB_RawFile.h"
#include "PDB_DirectMSFStream.h"
#include "Foundation/PDB_Memory.h"

namespace
{
	// the TPI stream always resides at index 2
	static constexpr const uint32_t TPIStreamIndex = 2u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::TPIStream::TPIStream(void) PDB_NO_EXCEPT
	: m_stream()
	, m_header()
	, m_recordCount(0u)
{
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::TPIStream::TPIStream(TPIStream&& other) PDB_NO_EXCEPT
	: m_stream(PDB_MOVE(other.m_stream))
	, m_header(PDB_MOVE(other.m_header))
	, m_recordCount(PDB_MOVE(other.m_recordCount))
{
	other.m_recordCount = 0u;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::TPIStream& PDB::TPIStream::operator=(TPIStream&& other) PDB_NO_EXCEPT
{
	if (this != &other)
	{
		m_stream = PDB_MOVE(other.m_stream);
		m_header = PDB_MOVE(other.m_header);
		m_recordCount = PDB_MOVE(other.m_recordCount);

		other.m_recordCount = 0u;
	}

	return *this;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB::TPIStream::TPIStream(const RawFile& file) PDB_NO_EXCEPT
	: m_stream(file.CreateMSFStream<DirectMSFStream>(TPIStreamIndex)),
	  m_header(m_stream.ReadAtOffset<TPI::StreamHeader>(0u)),
	  m_recordCount(GetLastTypeIndex() - GetFirstTypeIndex())
{
}

// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::ErrorCode PDB::HasValidTPIStream(const RawFile& file) PDB_NO_EXCEPT
{
	DirectMSFStream stream = file.CreateMSFStream<DirectMSFStream>(TPIStreamIndex);
	if (stream.GetSize() < sizeof(TPI::StreamHeader))
	{
		return ErrorCode::InvalidStream;
	}

	const TPI::StreamHeader header = stream.ReadAtOffset<TPI::StreamHeader>(0u);
	if (header.version != TPI::StreamHeader::Version::V80)
	{
		return ErrorCode::UnknownVersion;
	}

	return ErrorCode::Success;
}


// ------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
PDB_NO_DISCARD PDB::TPIStream PDB::CreateTPIStream(const RawFile& file) PDB_NO_EXCEPT
{
	return TPIStream { file };
}

```

`third_party/raw_pdb/src/PDB_TPIStream.h`:

```h
#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_ArrayView.h"
#include "PDB_ErrorCodes.h"
#include "PDB_TPITypes.h"
#include "PDB_DirectMSFStream.h"
#include "PDB_Util.h"

// PDB TPI stream
// https://llvm.org/docs/PDB/TpiStream.html
namespace PDB
{
	class RawFile;


	class PDB_NO_DISCARD TPIStream
	{
	public:
		TPIStream(void) PDB_NO_EXCEPT;
		TPIStream(TPIStream&& other) PDB_NO_EXCEPT;
		TPIStream& operator=(TPIStream&& other) PDB_NO_EXCEPT;

		explicit TPIStream(const RawFile& file) PDB_NO_EXCEPT;

		PDB_NO_DISCARD inline const DirectMSFStream& GetDirectMSFStream(void) const PDB_NO_EXCEPT
		{
			return m_stream;
		}

		// Returns the index of the first type, which is not necessarily zero.
		PDB_NO_DISCARD inline uint32_t GetFirstTypeIndex(void) const PDB_NO_EXCEPT
		{
			return m_header.typeIndexBegin;
		}

		// Returns the index of the last type.
		PDB_NO_DISCARD inline uint32_t GetLastTypeIndex(void) const PDB_NO_EXCEPT
		{
			return m_header.typeIndexEnd;
		}

		// Returns the number of type records.
		PDB_NO_DISCARD inline size_t GetTypeRecordCount(void) const PDB_NO_EXCEPT
		{
			return m_recordCount;
		}

		CodeView::TPI::RecordHeader ReadTypeRecordHeader(size_t offset) const PDB_NO_EXCEPT
		{
			const CodeView::TPI::RecordHeader header = m_stream.ReadAtOffset<CodeView::TPI::RecordHeader>(offset);
			return header;
		}

		template <typename F>
		void ForEachTypeRecordHeaderAndOffset(F&& functor) const PDB_NO_EXCEPT
		{
			// ignore the stream's header
			size_t offset = sizeof(TPI::StreamHeader);

			while (offset < m_stream.GetSize())
			{
				const CodeView::TPI::RecordHeader header = ReadTypeRecordHeader(offset);

				functor(header, offset);

				// position the stream offset at the next record
				offset += sizeof(CodeView::TPI::RecordHeader) + header.size - sizeof(uint16_t);
			}
		}

	private:
		DirectMSFStream m_stream;
		TPI::StreamHeader m_header;
		size_t m_recordCount;

		PDB_DISABLE_COPY(TPIStream);
	};

	// Returns whether the given raw file provides a valid TPI stream.
	PDB_NO_DISCARD ErrorCode HasValidTPIStream(const RawFile& file) PDB_NO_EXCEPT;

	// Creates the TPI stream from a raw file.
	PDB_NO_DISCARD TPIStream CreateTPIStream(const RawFile& file) PDB_NO_EXCEPT;
}

```

`third_party/raw_pdb/src/PDB_TPITypes.h`:

```h
#pragma once

#include "Foundation/PDB_Macros.h"
#include "Foundation/PDB_BitOperators.h"

namespace PDB
{
	namespace TPI
	{
		// https://llvm.org/docs/PDB/TpiStream.html#stream-header
		struct StreamHeader
		{
			enum class PDB_NO_DISCARD Version : uint32_t
			{
				V40 = 19950410u,
				V41 = 19951122u,
				V50 = 19961031u,
				V70 = 19990903u,
				V80 = 20040203u
			};

			Version version;
			uint32_t headerSize;
			uint32_t typeIndexBegin;
			uint32_t typeIndexEnd;
			uint32_t typeRecordBytes;

			uint16_t hashStreamIndex;
			uint16_t hashAuxStreamIndex;
			uint32_t hashKeySize;
			uint32_t numHashBuckets;

			int32_t hashValueBufferOffset;
			uint32_t hashValueBufferLength;

			int32_t indexOffsetBufferOffset;
			uint32_t indexOffsetBufferLength;

			int32_t hashAdjBufferOffset;
			uint32_t hashAdjBufferLength;
		};
	}


	namespace CodeView
	{
		namespace TPI
		{
			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L772
			enum class PDB_NO_DISCARD TypeRecordKind : uint16_t
			{
				LF_POINTER = 0x1002u,
				LF_MODIFIER = 0x1001u,
				LF_PROCEDURE = 0x1008u,
				LF_MFUNCTION = 0x1009u,
				LF_LABEL = 0x000eu,
				LF_ARGLIST = 0x1201u,
				LF_FIELDLIST = 0x1203u,
				LF_VTSHAPE = 0x000au,
				LF_BITFIELD = 0x1205u,
				LF_METHODLIST = 0x1206u,
				LF_ENDPRECOMP = 0x0014u,

				LF_BCLASS = 0x001400u,
				LF_VBCLASS = 0x001401u,
				LF_IVBCLASS = 0x001402u,
				LF_FRIENDFCN_ST = 0x001403u,
				LF_INDEX = 0x001404u,
				LF_MEMBER_ST = 0x001405u,
				LF_STMEMBER_ST = 0x001406u,
				LF_METHOD_ST = 0x001407u,
				LF_NESTTYPE_ST = 0x001408u,
				LF_VFUNCTAB = 0x001409u,
				LF_FRIENDCLS = 0x00140Au,
				LF_ONEMETHOD_ST = 0x00140Bu,
				LF_VFUNCOFF = 0x00140Cu,
				LF_NESTTYPEEX_ST = 0x00140Du,
				LF_MEMBERMODIFY_ST = 0x00140Eu,
				LF_MANAGED_ST = 0x00140Fu,

				LF_SMAX = 0x001500u,
				LF_TYPESERVER = 0x001501u,
				LF_ENUMERATE = 0x001502u,
				LF_ARRAY = 0x001503u,
				LF_CLASS = 0x001504u,
				LF_STRUCTURE = 0x001505u,
				LF_UNION = 0x001506u,
				LF_ENUM = 0x001507u,
				LF_DIMARRAY = 0x001508u,
				LF_PRECOMP = 0x001509u,
				LF_ALIAS = 0x00150Au,
				LF_DEFARG = 0x00150Bu,
				LF_FRIENDFCN = 0x00150Cu,
				LF_MEMBER = 0x00150Du,
				LF_STMEMBER = 0x00150Eu,
				LF_METHOD = 0x00150Fu,
				LF_NESTTYPE = 0x001510u,
				LF_ONEMETHOD = 0x001511u,
				LF_NESTTYPEEX = 0x001512u,
				LF_MEMBERMODIFY = 0x001513u,
				LF_MANAGED = 0x001514u,
				LF_TYPESERVER2 = 0x001515u,
				LF_CLASS2 = 0x001608u,
				LF_STRUCTURE2 = 0x001609u,

				LF_NUMERIC = 0x8000u,
				LF_CHAR = 0x8000u,
				LF_SHORT = 0x8001u,
				LF_USHORT = 0x8002u,
				LF_LONG = 0x8003u,
				LF_ULONG = 0x8004u,
				LF_REAL32 = 0x8005u,
				LF_REAL64 = 0x8006u,
				LF_REAL80 = 0x8007u,
				LF_REAL128 = 0x8008u,
				LF_QUADWORD = 0x8009u,
				LF_UQUADWORD = 0x800au,
				LF_REAL48 = 0x800bu,
				LF_COMPLEX32 = 0x800cu,
				LF_COMPLEX64 = 0x800du,
				LF_COMPLEX80 = 0x800eu,
				LF_COMPLEX128 = 0x800fu,
				LF_VARSTRING = 0x8010u,

				LF_OCTWORD = 0x8017u,
				LF_UOCTWORD = 0x8018u,

				LF_DECIMAL = 0x8019u,
				LF_DATE = 0x801au,
				LF_UTF8STRING = 0x801bu,

				LF_REAL16 = 0x801cu
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L328
			// https://github.com/ValveSoftware/wine/blob/cd165953c8b379a78418711f07417022e503c81b/include/wine/mscvpdb.h
			enum class TypeIndexKind : uint16_t
			{
				T_NOTYPE = 0x0000u,				// uncharacterized type (no type)
				T_ABS = 0x0001u,				// absolute symbol
				T_SEGMENT = 0x0002u,			// segment type
				T_VOID = 0x0003u,				// void
				T_HRESULT = 0x0008u,			// OLE/COM HRESULT
				T_32PHRESULT = 0x0408u,			// OLE/COM HRESULT __ptr32 *
				T_64PHRESULT = 0x0608u,			// OLE/COM HRESULT __ptr64 *

				// Emitted due to a compiler bug? 
				// 0x0600 bits appears to indicate a 64-bit pointer, but it has no type?
				// Seen as type index for C11 "_Atomic uint32_t*" variable and constant.
				T_UNKNOWN_0600 = 0x0600u,

				T_PVOID = 0x0103u,				// near pointer to void
				T_PFVOID = 0x0203u,				// far pointer to void
				T_PHVOID = 0x0303u,				// huge pointer to void
				T_32PVOID = 0x0403u,			// 32 bit pointer to void
				T_32PFVOID = 0x0503u,			// 16:32 pointer to void
				T_64PVOID = 0x0603u,			// 64 bit pointer to void
				T_CURRENCY = 0x0004u,			// BASIC 8 byte currency value
				T_NBASICSTR = 0x0005u,			// Near BASIC string
				T_FBASICSTR = 0x0006u,			// Far BASIC string
				T_NOTTRANS = 0x0007u,			// type not translated by cvpack
				T_BIT = 0x0060u,				// bit
				T_PASCHAR = 0x0061u,			// Pascal CHAR
				T_BOOL32FF = 0x0062u,			// 32-bit BOOL where true is 0xffffffff

				T_CHAR = 0x0010u,				// 8 bit signed
				T_PCHAR = 0x0110u,				// 16 bit pointer to 8 bit signed
				T_PFCHAR = 0x0210u,				// 16:16 far pointer to 8 bit signed
				T_PHCHAR = 0x0310u,				// 16:16 huge pointer to 8 bit signed
				T_32PCHAR = 0x0410u,			// 32 bit pointer to 8 bit signed
				T_32PFCHAR = 0x0510u,			// 16:32 pointer to 8 bit signed
				T_64PCHAR = 0x0610u,			// 64 bit pointer to 8 bit signed

				T_UCHAR = 0x0020u,				// 8 bit unsigned
				T_PUCHAR = 0x0120u,				// 16 bit pointer to 8 bit unsigned
				T_PFUCHAR = 0x0220u,			// 16:16 far pointer to 8 bit unsigned
				T_PHUCHAR = 0x0320u,			// 16:16 huge pointer to 8 bit unsigned
				T_32PUCHAR = 0x0420u,			// 32 bit pointer to 8 bit unsigned
				T_32PFUCHAR = 0x0520u,			// 16:32 pointer to 8 bit unsigned
				T_64PUCHAR = 0x0620u,			// 64 bit pointer to 8 bit unsigned

				T_RCHAR = 0x0070u,				// really a char
				T_PRCHAR = 0x0170u,				// 16 bit pointer to a real char
				T_PFRCHAR = 0x0270u,			// 16:16 far pointer to a real char
				T_PHRCHAR = 0x0370u,			// 16:16 huge pointer to a real char
				T_32PRCHAR = 0x0470u,			// 32 bit pointer to a real char
				T_32PFRCHAR = 0x0570u,			// 16:32 pointer to a real char
				T_64PRCHAR = 0x0670u,			// 64 bit pointer to a real char

				// wide character types
				T_WCHAR = 0x0071u,				// wide char
				T_PWCHAR = 0x0171u,				// 16 bit pointer to a wide char
				T_PFWCHAR = 0x0271u,			// 16:16 far pointer to a wide char
				T_PHWCHAR = 0x0371u,			// 16:16 huge pointer to a wide char
				T_32PWCHAR = 0x0471u,			// 32 bit pointer to a wide char
				T_32PFWCHAR = 0x0571u,			// 16:32 pointer to a wide char
				T_64PWCHAR = 0x0671u,			// 64 bit pointer to a wide char

				// 8-bit unicode char
				T_CHAR8 = 0x007c,				// 8-bit unicode char (C++ 20)
				T_PCHAR8 = 0x017c,				// Near pointer to 8-bit unicode char
				T_PFCHAR8 = 0x027c,				// Far pointer to 8-bit unicode char
				T_PHCHAR8 = 0x037c,				// Huge pointer to 8-bit unicode char
				T_32PCHAR8 = 0x047c,			// 16:32 near pointer to 8-bit unicode char
				T_32PFCHAR8 = 0x057c,			// 16:32 far pointer to 8-bit unicode char
				T_64PCHAR8 = 0x067c,			// 64 bit near pointer to 8-bit unicode char

				// 16-bit unicode char
				T_CHAR16 = 0x007au,				// 16-bit unicode char
				T_PCHAR16 = 0x017au,			// 16 bit pointer to a 16-bit unicode char
				T_PFCHAR16 = 0x027au,			// 16:16 far pointer to a 16-bit unicode char
				T_PHCHAR16 = 0x037au,			// 16:16 huge pointer to a 16-bit unicode char
				T_32PCHAR16 = 0x047au,			// 32 bit pointer to a 16-bit unicode char
				T_32PFCHAR16 = 0x057au,			// 16:32 pointer to a 16-bit unicode char
				T_64PCHAR16 = 0x067au,			// 64 bit pointer to a 16-bit unicode char

				// 32-bit unicode char
				T_CHAR32 = 0x007bu,				// 32-bit unicode char
				T_PCHAR32 = 0x017bu,			// 16 bit pointer to a 32-bit unicode char
				T_PFCHAR32 = 0x027bu,			// 16:16 far pointer to a 32-bit unicode char
				T_PHCHAR32 = 0x037bu,			// 16:16 huge pointer to a 32-bit unicode char
				T_32PCHAR32 = 0x047bu,			// 32 bit pointer to a 32-bit unicode char
				T_32PFCHAR32 = 0x057bu,			// 16:32 pointer to a 32-bit unicode char
				T_64PCHAR32 = 0x067bu,			// 64 bit pointer to a 32-bit unicode char

				// 8 bit int types
				T_INT1 = 0x0068u,				// 8 bit signed int
				T_PINT1 = 0x0168u,				// 16 bit pointer to 8 bit signed int
				T_PFINT1 = 0x0268u,				// 16:16 far pointer to 8 bit signed int
				T_PHINT1 = 0x0368u,				// 16:16 huge pointer to 8 bit signed int
				T_32PINT1 = 0x0468u,			// 32 bit pointer to 8 bit signed int
				T_32PFINT1 = 0x0568u,			// 16:32 pointer to 8 bit signed int
				T_64PINT1 = 0x0668u,			// 64 bit pointer to 8 bit signed int

				T_UINT1 = 0x0069u,				// 8 bit unsigned int
				T_PUINT1 = 0x0169u,				// 16 bit pointer to 8 bit unsigned int
				T_PFUINT1 = 0x0269u,			// 16:16 far pointer to 8 bit unsigned int
				T_PHUINT1 = 0x0369u,			// 16:16 huge pointer to 8 bit unsigned int
				T_32PUINT1 = 0x0469u,			// 32 bit pointer to 8 bit unsigned int
				T_32PFUINT1 = 0x0569u,			// 16:32 pointer to 8 bit unsigned int
				T_64PUINT1 = 0x0669u,			// 64 bit pointer to 8 bit unsigned int

				// 16 bit short types
				T_SHORT = 0x0011u,				// 16 bit signed
				T_PSHORT = 0x0111u,				// 16 bit pointer to 16 bit signed
				T_PFSHORT = 0x0211u,			// 16:16 far pointer to 16 bit signed
				T_PHSHORT = 0x0311u,			// 16:16 huge pointer to 16 bit signed
				T_32PSHORT = 0x0411u,			// 32 bit pointer to 16 bit signed
				T_32PFSHORT = 0x0511u,			// 16:32 pointer to 16 bit signed
				T_64PSHORT = 0x0611u,			// 64 bit pointer to 16 bit signed

				T_USHORT = 0x0021u,
				T_PUSHORT = 0x0121u,
				T_PFUSHORT = 0x0221u,
				T_PHUSHORT = 0x0321u,
				T_32PUSHORT = 0x0421u,
				T_32PFUSHORT = 0x0521u,
				T_64PUSHORT = 0x0621u,

				T_INT2 = 0x0072u,
				T_PINT2 = 0x0172u,
				T_PFINT2 = 0x0272u,
				T_PHINT2 = 0x0372u,
				T_32PINT2 = 0x0472u,
				T_32PFINT2 = 0x0572u,
				T_64PINT2 = 0x0672u,

				T_UINT2 = 0x0073u,
				T_PUINT2 = 0x0173u,
				T_PFUINT2 = 0x0273u,
				T_PHUINT2 = 0x0373u,
				T_32PUINT2 = 0x0473u,
				T_32PFUINT2 = 0x0573u,
				T_64PUINT2 = 0x0673u,

				T_LONG = 0x0012u,
				T_PLONG = 0x0112u,
				T_PFLONG = 0x0212u,
				T_PHLONG = 0x0312u,
				T_32PLONG = 0x0412u,
				T_32PFLONG = 0x0512u,
				T_64PLONG = 0x0612u,

				T_ULONG = 0x0022u,
				T_PULONG = 0x0122u,
				T_PFULONG = 0x0222u,
				T_PHULONG = 0x0322u,
				T_32PULONG = 0x0422u,
				T_32PFULONG = 0x0522u,
				T_64PULONG = 0x0622u,

				T_INT4 = 0x0074u,
				T_PINT4 = 0x0174u,
				T_PFINT4 = 0x0274u,
				T_PHINT4 = 0x0374u,
				T_32PINT4 = 0x0474u,
				T_32PFINT4 = 0x0574u,
				T_64PINT4 = 0x0674u,

				T_UINT4 = 0x0075u,
				T_PUINT4 = 0x0175u,
				T_PFUINT4 = 0x0275u,
				T_PHUINT4 = 0x0375u,
				T_32PUINT4 = 0x0475u,
				T_32PFUINT4 = 0x0575u,
				T_64PUINT4 = 0x0675u,

				T_QUAD = 0x0013u,
				T_PQUAD = 0x0113u,
				T_PFQUAD = 0x0213u,
				T_PHQUAD = 0x0313u,
				T_32PQUAD = 0x0413u,
				T_32PFQUAD = 0x0513u,
				T_64PQUAD = 0x0613u,

				T_UQUAD = 0x0023u,
				T_PUQUAD = 0x0123u,
				T_PFUQUAD = 0x0223u,
				T_PHUQUAD = 0x0323u,
				T_32PUQUAD = 0x0423u,
				T_32PFUQUAD = 0x0523u,
				T_64PUQUAD = 0x0623u,

				T_INT8 = 0x0076u,
				T_PINT8 = 0x0176u,
				T_PFINT8 = 0x0276u,
				T_PHINT8 = 0x0376u,
				T_32PINT8 = 0x0476u,
				T_32PFINT8 = 0x0576u,
				T_64PINT8 = 0x0676u,

				T_UINT8 = 0x0077u,
				T_PUINT8 = 0x0177u,
				T_PFUINT8 = 0x0277u,
				T_PHUINT8 = 0x0377u,
				T_32PUINT8 = 0x0477u,
				T_32PFUINT8 = 0x0577u,
				T_64PUINT8 = 0x0677u,

				T_OCT = 0x0014u,
				T_POCT = 0x0114u,
				T_PFOCT = 0x0214u,
				T_PHOCT = 0x0314u,
				T_32POCT = 0x0414u,
				T_32PFOCT = 0x0514u,
				T_64POCT = 0x0614u,

				T_UOCT = 0x0024u,
				T_PUOCT = 0x0124u,
				T_PFUOCT = 0x0224u,
				T_PHUOCT = 0x0324u,
				T_32PUOCT = 0x0424u,
				T_32PFUOCT = 0x0524u,
				T_64PUOCT = 0x0624u,

				T_INT16 = 0x0078u,
				T_PINT16 = 0x0178u,
				T_PFINT16 = 0x0278u,
				T_PHINT16 = 0x0378u,
				T_32PINT16 = 0x0478u,
				T_32PFINT16 = 0x0578u,
				T_64PINT16 = 0x0678u,

				T_UINT16 = 0x0079u,
				T_PUINT16 = 0x0179u,
				T_PFUINT16 = 0x0279u,
				T_PHUINT16 = 0x0379u,
				T_32PUINT16 = 0x0479u,
				T_32PFUINT16 = 0x0579u,
				T_64PUINT16 = 0x0679u,

				T_REAL32 = 0x0040u,
				T_PREAL32 = 0x0140u,
				T_PFREAL32 = 0x0240u,
				T_PHREAL32 = 0x0340u,
				T_32PREAL32 = 0x0440u,
				T_32PFREAL32 = 0x0540u,
				T_64PREAL32 = 0x0640u,

				T_REAL48 = 0x0044u,
				T_PREAL48 = 0x0144u,
				T_PFREAL48 = 0x0244u,
				T_PHREAL48 = 0x0344u,
				T_32PREAL48 = 0x0444u,
				T_32PFREAL48 = 0x0544u,
				T_64PREAL48 = 0x0644u,

				T_REAL64 = 0x0041u,
				T_PREAL64 = 0x0141u,
				T_PFREAL64 = 0x0241u,
				T_PHREAL64 = 0x0341u,
				T_32PREAL64 = 0x0441u,
				T_32PFREAL64 = 0x0541u,
				T_64PREAL64 = 0x0641u,

				T_REAL80 = 0x0042u,
				T_PREAL80 = 0x0142u,
				T_PFREAL80 = 0x0242u,
				T_PHREAL80 = 0x0342u,
				T_32PREAL80 = 0x0442u,
				T_32PFREAL80 = 0x0542u,
				T_64PREAL80 = 0x0642u,

				T_REAL128 = 0x0043u,
				T_PREAL128 = 0x0143u,
				T_PFREAL128 = 0x0243u,
				T_PHREAL128 = 0x0343u,
				T_32PREAL128 = 0x0443u,
				T_32PFREAL128 = 0x0543u,
				T_64PREAL128 = 0x0643u,

				T_CPLX32 = 0x0050u,
				T_PCPLX32 = 0x0150u,
				T_PFCPLX32 = 0x0250u,
				T_PHCPLX32 = 0x0350u,
				T_32PCPLX32 = 0x0450u,
				T_32PFCPLX32 = 0x0550u,
				T_64PCPLX32 = 0x0650u,

				T_CPLX64 = 0x0051u,
				T_PCPLX64 = 0x0151u,
				T_PFCPLX64 = 0x0251u,
				T_PHCPLX64 = 0x0351u,
				T_32PCPLX64 = 0x0451u,
				T_32PFCPLX64 = 0x0551u,
				T_64PCPLX64 = 0x0651u,

				T_CPLX80 = 0x0052u,
				T_PCPLX80 = 0x0152u,
				T_PFCPLX80 = 0x0252u,
				T_PHCPLX80 = 0x0352u,
				T_32PCPLX80 = 0x0452u,
				T_32PFCPLX80 = 0x0552u,
				T_64PCPLX80 = 0x0652u,

				T_CPLX128 = 0x0053u,
				T_PCPLX128 = 0x0153u,
				T_PFCPLX128 = 0x0253u,
				T_PHCPLX128 = 0x0353u,
				T_32PCPLX128 = 0x0453u,
				T_32PFCPLX128 = 0x0553u,
				T_64PCPLX128 = 0x0653u,

				T_BOOL08 = 0x0030u,
				T_PBOOL08 = 0x0130u,
				T_PFBOOL08 = 0x0230u,
				T_PHBOOL08 = 0x0330u,
				T_32PBOOL08 = 0x0430u,
				T_32PFBOOL08 = 0x0530u,
				T_64PBOOL08 = 0x0630u,

				T_BOOL16 = 0x0031u,
				T_PBOOL16 = 0x0131u,
				T_PFBOOL16 = 0x0231u,
				T_PHBOOL16 = 0x0331u,
				T_32PBOOL16 = 0x0431u,
				T_32PFBOOL16 = 0x0531u,
				T_64PBOOL16 = 0x0631u,

				T_BOOL32 = 0x0032u,
				T_PBOOL32 = 0x0132u,
				T_PFBOOL32 = 0x0232u,
				T_PHBOOL32 = 0x0332u,
				T_32PBOOL32 = 0x0432u,
				T_32PFBOOL32 = 0x0532u,
				T_64PBOOL32 = 0x0632u,

				T_BOOL64 = 0x0033u,
				T_PBOOL64 = 0x0133u,
				T_PFBOOL64 = 0x0233u,
				T_PHBOOL64 = 0x0333u,
				T_32PBOOL64 = 0x0433u,
				T_32PFBOOL64 = 0x0533u,
				T_64PBOOL64 = 0x0633u,

				T_NCVPTR = 0x01F0u,
				T_FCVPTR = 0x02F0u,
				T_HCVPTR = 0x03F0u,
				T_32NCVPTR = 0x04F0u,
				T_32FCVPTR = 0x05F0u,
				T_64NCVPTR = 0x06F0u
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvconst.h#L31
			enum class CallingConvention : uint8_t
			{
				NEAR_C = 0x00u,		// near right to left pushu, caller pops stack
				FAR_C = 0x01u,		// far right to left pushu, caller pops stack
				NEAR_PASCAL = 0x02u,// near left to right pushu, callee pops stack
				FAR_PASCAL = 0x03u, // far left to right pushu, callee pops stack
				NEAR_FAST = 0x04u,	// near left to right push with regsu, callee pops stack
				FAR_FAST = 0x05u,	// far left to right push with regsu, callee pops stack
				SKIPPED = 0x06u,	// skipped (unused) call index
				NEAR_STD = 0x07u,	// near standard call
				FAR_STD = 0x08u,	// far standard call
				NEAR_SYS = 0x09u,	// near sys call
				FAR_SYS = 0x0au,	// far sys call
				THISCALL = 0x0bu,	// this call (this passed in register)
				MIPSCALL = 0x0cu,	// Mips call
				GENERIC = 0x0du,	// Generic call sequence
				ALPHACALL = 0x0eu,	// Alpha call
				PPCCALL = 0x0fu,	// PPC call
				SHCALL = 0x10u,		// Hitachi SuperH call
				ARMCALL = 0x11u,	// ARM call
				AM33CALL = 0x12u,	// AM33 call
				TRICALL = 0x13u,	// TriCore Call
				SH5CALL = 0x14u,	// Hitachi SuperH-5 call
				M32RCALL = 0x15u,	// M32R Call
				CLRCALL = 0x16u,	// clr call
				INLINE = 0x17u,		// Marker for routines always inlined and thus lacking a convention
				NEAR_VECTOR = 0x18u,// near left to right push with regsu, callee pops stack
				RESERVED = 0x19u	// first unused call enumeration

				// Do NOT add any more machine specific conventions.  This is to be used for
				// calling conventions in the source only (e.g. __cdeclu, __stdcall).
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1049
			enum class MethodProperty : uint8_t
			{
				Vanilla = 0x00u,
				Virtual = 0x01u,
				Static = 0x02u,
				Friend = 0x03u,
				Intro = 0x04u,
				PureVirt = 0x05u,
				PureIntro = 0x06u
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1120
			struct TypeProperty
			{
				uint16_t packed : 1;			// true if structure is packed
				uint16_t ctor : 1;				// true if constructors or destructors present
				uint16_t ovlops : 1;			// true if overloaded operators present
				uint16_t isnested : 1;			// true if this is a nested class
				uint16_t cnested : 1;			// true if this class contains nested types
				uint16_t opassign : 1;			// true if overloaded assignment (=)
				uint16_t opcast : 1;			// true if casting methods
				uint16_t fwdref : 1;			// true if forward reference (incomplete defn)
				uint16_t scoped : 1;			// scoped definition
				uint16_t hasuniquename : 1;		// true if there is a decorated name following the regular name
				uint16_t sealed : 1;			// true if class cannot be used as a base class
				uint16_t hfa : 2;				// CV_HFA_e
				uint16_t intrinsic : 1;			// true if class is an intrinsic type (e.g. __m128d)
				uint16_t mocom : 2;				// CV_MOCOM_UDe
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1142
			struct MemberAttributes
			{
				uint16_t access : 2;			// access protection CV_access_t
				uint16_t mprop : 3;				// method properties CV_methodprop_t
				uint16_t pseudo : 1;			// compiler generated fcn and does not exist
				uint16_t noinherit : 1;			// true if class cannot be inherited
				uint16_t noconstruct : 1;		// true if class cannot be constructed
				uint16_t compgenx : 1;			// compiler generated fcn and does exist
				uint16_t sealed : 1;			// true if method cannot be overridden
				uint16_t unused : 6;			// unused
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1156
			struct FunctionAttributes
			{
				uint8_t cxxreturnudt : 1;		// true if C++ style ReturnUDT
				uint8_t ctor : 1;				// true if func is an instance constructor
				uint8_t ctorvbase : 1;			// true if func is an instance constructor of a class with virtual bases
				uint8_t unused : 5;				// unused
			};

			struct RecordHeader
			{
				uint16_t size;					// record length, not including this 2-byte field
				TypeRecordKind kind;			// record kind
			};

			struct LeafEasy
			{
				TypeRecordKind kind;			// record kind
			};

			struct FieldList
			{
				TypeRecordKind kind;			// record kind
				union Data
				{
#pragma pack(push, 1)
					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2499
					struct
					{
						MemberAttributes attributes;					// method attribute
						uint32_t		index;							// type index of base class
						union
						{
							PDB_FLEXIBLE_ARRAY_MEMBER(char, offset);	// variable length offset of base within class
							LeafEasy lfEasy;
						};
					}LF_BCLASS;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2521
					struct
					{
						MemberAttributes	attributes;	// attribute
						uint32_t			index;		// type index of direct virtual base class
						uint32_t			vbpIndex;   // type index of virtual base pointer
						PDB_FLEXIBLE_ARRAY_MEMBER(char, vbpOffset); // virtual base pointer offset from address point
					} LF_VBCLASS, LF_IVBCLASS;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2483
					// index leaf - contains type index of another leaf
					// a major use of this leaf is to allow the compilers to emit a
					// long complex list (LF_FIELD) in smaller pieces.
					struct
					{
						uint16_t pad0; // internal padding, must be 0
						uint32_t type; // type index of referenced leaf
					} LF_INDEX;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2615
					struct
					{
						uint16_t		pad0;   // internal padding, must be 0.
						uint32_t        type;   // type index of pointer
					}LF_VFUNCTAB;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2683
					struct
					{
						MemberAttributes attributes;
						union
						{
							PDB_FLEXIBLE_ARRAY_MEMBER(char, value);
							LeafEasy lfEasy;
						};
					} LF_ENUMERATE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2693
					struct
					{
						uint16_t		pad0;	// internal padding, must be 0
						uint32_t		index;	// index of nested type definition
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					}LF_NESTTYPE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2650
					struct
					{
						uint16_t		count;	// number of occurrences of function
						uint32_t        mList;  // index to LF_METHODLIST record
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					}LF_METHOD;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2671
					struct
					{
						MemberAttributes attributes;					// method attribute
						uint32_t index;									// index to type record for procedure
						PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, vbaseoff);	// offset in vfunctable if
					}LF_ONEMETHOD;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2580
					struct
					{
						MemberAttributes attributes;
						uint32_t index;			// type index of referenced leaf
						union
						{
							PDB_FLEXIBLE_ARRAY_MEMBER(char, offset);
							LeafEasy lfEasy;
						};
					} LF_MEMBER;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2592
					struct
					{
						MemberAttributes attributes;
						uint32_t index;			// index of type record for field
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					}LF_STMEMBER;
#pragma pack(pop)
				} data;
			};

			// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2131
			struct MethodListEntry
			{
				MemberAttributes attributes;					// method attribute
				uint16_t		pad0;							// internal padding, must be 0
				uint32_t		index;							// index to type record for procedure
				PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, vbaseoff);	// offset in vfunctable if virtual, empty otherwise.
			};

			// all CodeView records are stored as a header, followed by variable-length data.
			// internal Record structs such as S_PUB32, S_GDATA32, etc. correspond to the data layout of a CodeView record of that kind.
			struct Record
			{
				RecordHeader header;
				union Data
				{
#pragma pack(push, 1)
					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2144
					struct
					{
						// This is actually a list of the MethodListEntry type above, but it has flexible
						// size, so you need to manually iterate.
						PDB_FLEXIBLE_ARRAY_MEMBER(char, mList);
					} LF_METHODLIST;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1801
					struct
					{
						uint32_t        rvtype;         // type index of return value
						uint32_t        classtype;      // type index of containing class
						uint32_t        thistype;       // type index of this pointer (model specific)
						uint8_t			calltype;       // calling convention (call_t)
						FunctionAttributes funcattr;	// attributes
						uint16_t		parmcount;      // number of parameters
						uint32_t        arglist;        // type index of argument list
						int32_t         thisadjust;     // this adjuster (long because pad required anyway)
					} LF_MFUNCTION;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1460
					struct
					{
						uint32_t type;					// modified type

						// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1090
						struct
						{
							uint16_t MOD_const : 1;
							uint16_t MOD_volatile : 1;
							uint16_t MOD_unaligned : 1;
							uint16_t MOD_unused : 13;
						} attr;							// modifier attribute modifier_t
					} LF_MODIFIER;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1508
					struct
					{
						uint32_t utype;					// type index of the underlying type
						struct PointerAttributes
						{
							uint32_t ptrtype : 5;		// ordinal specifying pointer type (CV_ptrtype_e)
							uint32_t ptrmode : 3;		// ordinal specifying pointer mode (CV_ptrmode_e)
							uint32_t isflat32 : 1;		// TRUE if 0:32 pointer
							uint32_t isvolatile : 1;	// TRUE if volatile pointer
							uint32_t isconst : 1;		// TRUE if const pointer
							uint32_t isunaligned : 1;	// TRUE if unaligned pointer
							uint32_t isrestrict : 1;	// TRUE if restricted pointer (allow agressive opts)
							uint32_t size : 6;			// size of pointer (in bytes)
							uint32_t ismocom : 1;		// TRUE if it is a MoCOM pointer (^ or %)
							uint32_t islref : 1;		// TRUE if it is this pointer of member function with & ref-qualifier
							uint32_t isrref : 1;		// TRUE if it is this pointer of member function with && ref-qualifier
							uint32_t unused : 10;		// pad out to 32-bits for following cv_typ_t's
						} attr;

						union
						{
							struct
							{
								uint32_t pmclass;						// index of containing class for pointer to member
								uint16_t pmenum;						// enumeration specifying pm format (CV_pmtype_e)
							} pm;

							uint16_t bseg;								// base segment if PTR_BASE_SEG
							PDB_FLEXIBLE_ARRAY_MEMBER(uint8_t, Sym);	// copy of base symbol record (including length)

							struct
							{
								uint32_t index;							// type index if CV_PTR_BASE_TYPE
								PDB_FLEXIBLE_ARRAY_MEMBER(char, name);	// name of base type
							} btype;
						} pbase;
					} LF_POINTER;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1775
					struct
					{
						uint32_t rvtype;				// type index of return value
						CallingConvention calltype;		// calling convention (CV_call_t)
						FunctionAttributes funcattr;	// attributes
						uint16_t parmcount;				// number of parameters
						uint32_t arglist;				// type index of argument list
					} LF_PROCEDURE;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2043
					struct
					{
						uint32_t count;					// number of arguments
						PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, arg);
					} LF_ARGLIST;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2164
					struct
					{
						uint32_t type;
						uint8_t length;
						uint8_t position;
						PDB_FLEXIBLE_ARRAY_MEMBER(char, data);
					} LF_BITFIELD;

					struct
					{
						uint32_t elemtype;							// type index of element type
						uint32_t idxtype;							// type index of indexing type
						PDB_FLEXIBLE_ARRAY_MEMBER(char, data);		// variable length data specifying size in bytes and name
					} LF_ARRAY;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1631
					struct
					{
						uint16_t count;			// count of number of elements in class
						TypeProperty property;	// property attribute field
						uint32_t field;			// type index of LF_FIELD descriptor list
						uint32_t derived;		// type index of derived from list if not zero
						uint32_t vshape;		// type index of vshape table for this class
						union
						{
							PDB_FLEXIBLE_ARRAY_MEMBER(char, data);
							LeafEasy lfEasy;
						};
					} LF_CLASS;

					struct
					{
						uint16_t count;			// count of number of elements in class
						uint32_t property;		// property attribute field
						uint32_t field;			// type index of LF_FIELD descriptor list
						uint32_t derived;		// type index of derived from list if not zero
						uint32_t vshape;		// type index of vshape table for this class
						union
						{
							PDB_FLEXIBLE_ARRAY_MEMBER(char, data);
							LeafEasy lfEasy;
						};
					} LF_CLASS2;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1647
					struct
					{
						uint16_t count;			// count of number of elements in class
						TypeProperty property;	// property attribute field
						uint32_t field;			// type index of LF_FIELD descriptor list
						PDB_FLEXIBLE_ARRAY_MEMBER(char, data);
					} LF_UNION;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L1752
					struct
					{
						uint16_t count;			// count of number of elements in class
						TypeProperty property;	// property attribute field
						uint32_t utype;			// underlying type of the enum
						uint32_t field;			// type index of LF_FIELD descriptor list
						PDB_FLEXIBLE_ARRAY_MEMBER(char, name);
					} LF_ENUM;

					// https://github.com/microsoft/microsoft-pdb/blob/master/include/cvinfo.h#L2112
					struct
					{
						FieldList list;
					} LF_FIELD;
#pragma pack(pop)
				} data;
			};
		}
	}
}

```

`third_party/raw_pdb/src/PDB_Types.cpp`:

```cpp
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#include "PDB_PCH.h"
#include "PDB_Types.h"


// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/msf/msf.cpp#L962
const char PDB::SuperBlock::MAGIC[30u] = "Microsoft C/C++ MSF 7.00\r\n\x1a\x44\x53";

const uint32_t PDB::HashTableHeader::Signature = 0xffffffffu;
const uint32_t PDB::HashTableHeader::Version = 0xeffe0000u + 19990810u;

```

`third_party/raw_pdb/src/PDB_Types.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"


namespace PDB
{
	// emulating std::byte from C++17 to make the intention clear that we're dealing with untyped data in certain cases, without actually requiring C++17
	enum class Byte : unsigned char {};

	// PDB files have the notion of "nil" pages, denoted by a special size
	// https://github.com/microsoft/microsoft-pdb/blob/master/PDB/msf/msf.cpp#L177
	const uint32_t NilPageSize = 0xffffffffu;

	// PDB files have the notion of a "nil" stream index
	// https://github.com/microsoft/microsoft-pdb/blob/master/PDB/include/msf.h#L45
	const uint16_t NilStreamIndex = 0xffffu;

	// this matches the definition in guiddef.h, but we don't want to pull that in
	struct GUID
	{
		uint32_t Data1;
		uint16_t Data2;
		uint16_t Data3;
		uint8_t  Data4[8];
	};

	static_assert(sizeof(GUID) == 16u, "Size mismatch.");

	// this matches the definition in winnt.h, but we don't want to pull that in
	struct IMAGE_SECTION_HEADER
	{
		uint8_t Name[8];
		union
		{
			uint32_t PhysicalAddress;
			uint32_t VirtualSize;
		} Misc;
		uint32_t VirtualAddress;
		uint32_t SizeOfRawData;
		uint32_t PointerToRawData;
		uint32_t PointerToRelocations;
		uint32_t PointerToLinenumbers;
		uint16_t NumberOfRelocations;
		uint16_t NumberOfLinenumbers;
		uint32_t Characteristics;
	};

	static_assert(sizeof(IMAGE_SECTION_HEADER) == 40u, "Size mismatch.");

	// https://llvm.org/docs/PDB/MsfFile.html#msf-superblock
	struct PDB_NO_DISCARD SuperBlock
	{
		static const char MAGIC[30u];

		char fileMagic[30u];
		char padding[2u];
		uint32_t blockSize;
		uint32_t freeBlockMapIndex;										// index of the free block map
		uint32_t blockCount;											// number of blocks in the file
		uint32_t directorySize;											// size of the stream directory in bytes
		uint32_t unknown;
		PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, directoryBlockIndices);		// indices of the blocks that make up the directory indices
	};

	// https://llvm.org/docs/PDB/PdbStream.html#stream-header
	struct Header
	{
		enum class PDB_NO_DISCARD Version : uint32_t
		{
			VC2 = 19941610u,
			VC4 = 19950623u,
			VC41 = 19950814u,
			VC50 = 19960307u,
			VC98 = 19970604u,
			VC70Dep = 19990604u,
			VC70 = 20000404u,
			VC80 = 20030901u,
			VC110 = 20091201u,
			VC140 = 20140508u
		};

		Version version;
		uint32_t signature;
		uint32_t age;
		GUID guid;
	};

	// https://llvm.org/docs/PDB/PdbStream.html
	struct NamedStreamMap
	{
		uint32_t length;
		PDB_FLEXIBLE_ARRAY_MEMBER(char, stringTable);

		struct HashTableEntry
		{
			uint32_t stringTableOffset;
			uint32_t streamIndex;
		};
	};

	// https://llvm.org/docs/PDB/HashTable.html
	struct SerializedHashTable
	{
		struct Header
		{
			uint32_t size;
			uint32_t capacity;
		};

		struct BitVector
		{
			uint32_t wordCount;
			PDB_FLEXIBLE_ARRAY_MEMBER(uint32_t, words);
		};
	};

	// https://llvm.org/docs/PDB/PdbStream.html#pdb-feature-codes
	enum class PDB_NO_DISCARD FeatureCode : uint32_t
	{
		VC110 = 20091201,
		VC140 = 20140508,

		// https://github.com/microsoft/microsoft-pdb/blob/master/PDB/include/pdbcommon.h#L23
		NoTypeMerge = 0x4D544F4E,				// "NOTM"
		MinimalDebugInfo = 0x494E494D			// "MINI", i.e. executable was linked with /DEBUG:FASTLINK
	};

	// header of the public stream, based on PSGSIHDR defined here:
	// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h#L240
	struct PublicStreamHeader
	{
		uint32_t symHash;
		uint32_t addrMap;
		uint32_t thunkCount;
		uint32_t sizeOfThunk;
		uint16_t isectThunkTable;
		uint16_t padding;
		uint32_t offsetThunkTable;
		uint16_t sectionCount;
		uint16_t padding2;
	};

	// header of the hash tables used by the public and global symbol stream, based on GSIHashHdr defined here:
	// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h#L62
	struct HashTableHeader
	{
		static const uint32_t Signature;
		static const uint32_t Version;

		uint32_t signature;
		uint32_t version;
		uint32_t size;
		uint32_t bucketCount;
	};

	// hash record, based on HRFile defined here:
	// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h#L8
	struct HashRecord
	{
		uint32_t offset;		// offset into the symbol record stream
		uint32_t cref;
	};
}

```

`third_party/raw_pdb/src/PDB_Util.h`:

```h
// Copyright 2011-2022, Molecular Matters GmbH <office@molecular-matters.com>
// See LICENSE.txt for licensing details (2-clause BSD License: https://opensource.org/licenses/BSD-2-Clause)

#pragma once

#include "Foundation/PDB_Macros.h"


namespace PDB
{
	// Converts a block index into a file offset, based on the block size of the PDB file
	PDB_NO_DISCARD inline size_t ConvertBlockIndexToFileOffset(uint32_t blockIndex, uint32_t blockSize) PDB_NO_EXCEPT
	{
		// cast to size_t to avoid potential overflow in 64-bit
		return static_cast<size_t>(blockIndex) * static_cast<size_t>(blockSize);
	}

	// Calculates how many blocks are needed for a certain number of bytes
	PDB_NO_DISCARD inline uint32_t ConvertSizeToBlockCount(uint32_t sizeInBytes, uint32_t blockSize) PDB_NO_EXCEPT
	{
		// integer ceil to account for non-full blocks
		return static_cast<uint32_t>((static_cast<size_t>(sizeInBytes) + blockSize - 1u) / blockSize);
	};

	// Returns the actual size of the data associated with a CodeView record, not including the size of the header
	template <typename T>
	PDB_NO_DISCARD inline uint32_t GetCodeViewRecordSize(const T* record) PDB_NO_EXCEPT
	{
		// the stored size includes the size of the 'kind' field, but not the size of the 'size' field itself
		return record->header.size - sizeof(uint16_t);
	}

	template <typename Header, typename T>
	PDB_NO_DISCARD inline size_t GetNameLength(const Header& header, const T& record) PDB_NO_EXCEPT
	{
		// we can estimate the length of the string from the size of the record
		const size_t estimatedLength = header.size - sizeof(uint16_t) - sizeof(T);
		if (estimatedLength == 0u)
		{
			return estimatedLength;
		}

		// we still need to account for padding after the string to find the real length
		size_t nullTerminatorCount = 0u;
		for (/* nothing */; nullTerminatorCount < estimatedLength; ++nullTerminatorCount)
		{
			if (record.name[estimatedLength - nullTerminatorCount - 1u] != '\0')
			{
				break;
			}
		}

		const size_t length = estimatedLength - nullTerminatorCount;
		return length;
	}
}

```

`tools/rcx-mcp-stdio.cpp`:

```cpp
// ReclassMcpBridge: Bridges stdin/stdout to QLocalSocket for MCP transport.
// Claude Desktop spawns this process; it connects to the ReclassMcpBridge named pipe
// inside the running Reclass application.
//
// stdin  (from Claude) → QLocalSocket → McpBridge (in Reclass)
// stdout (to Claude)   ← QLocalSocket ← McpBridge (in Reclass)

#include <QCoreApplication>
#include <QLocalSocket>
#include <QTimer>
#include <QTextStream>
#include <cstdio>

#ifdef _WIN32
#include <windows.h>
#include <io.h>
#include <fcntl.h>
#else
#include <unistd.h>
#include <sys/select.h>
#endif

int main(int argc, char* argv[]) {
    QCoreApplication app(argc, argv);

#ifdef _WIN32
    // Ensure stdin/stdout are in binary mode on Windows
    _setmode(_fileno(stdin), _O_BINARY);
    _setmode(_fileno(stdout), _O_BINARY);
#endif

    auto* socket = new QLocalSocket(&app);
    QByteArray readBuf;

    // Socket → stdout: forward lines from Reclass to Claude Desktop
    QObject::connect(socket, &QLocalSocket::readyRead, [&]() {
        readBuf.append(socket->readAll());
        while (true) {
            int idx = readBuf.indexOf('\n');
            if (idx < 0) break;
            QByteArray line = readBuf.left(idx + 1); // include newline
            readBuf.remove(0, idx + 1);
            fwrite(line.constData(), 1, line.size(), stdout);
            fflush(stdout);
        }
    });

    QObject::connect(socket, &QLocalSocket::disconnected, [&]() {
        fprintf(stderr, "[ReclassMcpBridge] Disconnected from server\n");
        app.quit();
    });

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    QObject::connect(socket, &QLocalSocket::errorOccurred, [&](QLocalSocket::LocalSocketError err) {
#else
    QObject::connect(socket, QOverload<QLocalSocket::LocalSocketError>::of(&QLocalSocket::error), [&](QLocalSocket::LocalSocketError err) {
#endif
        fprintf(stderr, "[ReclassMcpBridge] Socket error %d: %s\n",
                (int)err, socket->errorString().toUtf8().constData());
        app.quit();
    });

    // Connect to the named pipe
    socket->connectToServer("ReclassMcpBridge");
    if (!socket->waitForConnected(5000)) {
        fprintf(stderr, "[ReclassMcpBridge] Failed to connect to ReclassMcpBridge pipe: %s\n",
                socket->errorString().toUtf8().constData());
        return 1;
    }
    fprintf(stderr, "[ReclassMcpBridge] Connected to ReclassMcpBridge\n");

    // Stdin → socket: poll stdin with a timer (stdin isn't a socket on Windows)
    QByteArray stdinBuf;
    auto* stdinTimer = new QTimer(&app);
    stdinTimer->setInterval(10);

    QObject::connect(stdinTimer, &QTimer::timeout, [&]() {
#ifdef _WIN32
        HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
        DWORD avail = 0;
        if (!PeekNamedPipe(hStdin, nullptr, 0, nullptr, &avail, nullptr)) {
            // stdin closed (pipe broken)
            app.quit();
            return;
        }
        if (avail == 0) return;

        char buf[4096];
        DWORD bytesRead = 0;
        DWORD toRead = qMin(avail, (DWORD)sizeof(buf));
        if (!ReadFile(hStdin, buf, toRead, &bytesRead, nullptr) || bytesRead == 0) {
            app.quit();
            return;
        }
        stdinBuf.append(buf, (int)bytesRead);
#else
        // On Unix, we could use QSocketNotifier, but timer works fine too
        char buf[4096];
        fd_set fds;
        FD_ZERO(&fds);
        FD_SET(STDIN_FILENO, &fds);
        struct timeval tv = {0, 0};
        if (select(STDIN_FILENO + 1, &fds, nullptr, nullptr, &tv) <= 0) return;
        ssize_t n = ::read(STDIN_FILENO, buf, sizeof(buf));
        if (n <= 0) {
            app.quit();
            return;
        }
        stdinBuf.append(buf, (int)n);
#endif
        // Forward complete lines to socket
        while (true) {
            int idx = stdinBuf.indexOf('\n');
            if (idx < 0) break;
            QByteArray line = stdinBuf.left(idx + 1);
            stdinBuf.remove(0, idx + 1);
            socket->write(line);
            socket->flush();
        }
    });

    stdinTimer->start();
    return app.exec();
}

```

`tools/test_hover.py`:

```py
"""
Structural hover test: validate that all themes produce visible hover colors
and that the QProxyStyle code handles the required control elements.

No pixel sampling — checks theme JSON values and source code patterns.
"""
import json
import os
import re
import sys


def hex_to_rgb(h):
    h = h.lstrip('#')
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))


def color_dist(c1, c2):
    return sum(abs(a - b) for a, b in zip(c1, c2))


def lighter_130(rgb):
    """Approximate Qt's QColor::lighter(130) for dark grays."""
    r, g, b = rgb
    return (min(255, int(r * 1.3) + 1),
            min(255, int(g * 1.3) + 1),
            min(255, int(b * 1.3) + 1))


def load_themes():
    themes = {}
    theme_dir = os.path.join(os.path.dirname(__file__),
                             '..', 'src', 'themes', 'defaults')
    if not os.path.isdir(theme_dir):
        return themes
    for name in os.listdir(theme_dir):
        if name.endswith('.json'):
            with open(os.path.join(theme_dir, name)) as f:
                themes[name] = json.load(f)
    return themes


def test_hover_visibility(themes):
    """Every theme must have hover visually distinct from background.
    If raw values are identical, Theme::fromJson applies lighter(130)."""
    ok = True
    for name, data in sorted(themes.items()):
        bg = hex_to_rgb(data['background'])
        hover = hex_to_rgb(data['hover'])
        dist = color_dist(bg, hover)

        if dist < 20:
            # fromJson will fix this — verify the fix produces sufficient contrast
            fixed = lighter_130(bg)
            fixed_dist = color_dist(bg, fixed)
            if fixed_dist < 15:
                print(f"  FAIL: {name}: hover==bg and lighter(130) still too close "
                      f"(dist={fixed_dist})")
                ok = False
            else:
                print(f"  OK:   {name}: hover==bg, fromJson fixup -> "
                      f"dist {dist}->{fixed_dist}")
        else:
            print(f"  OK:   {name}: hover distinct (dist={dist})")
    return ok


def test_proxystyle_handlers():
    """Verify MenuBarStyle handles CE_MenuBarItem, CE_MenuItem, CE_MenuBarEmptyArea."""
    src = os.path.join(os.path.dirname(__file__), '..', 'src', 'main.cpp')
    with open(src) as f:
        code = f.read()

    required = {
        'CE_MenuBarItem':      r'element\s*==\s*CE_MenuBarItem',
        'CE_MenuItem':         r'element\s*==\s*CE_MenuItem',
        'CE_MenuBarEmptyArea': r'element\s*==\s*CE_MenuBarEmptyArea',
        'State_Selected':      r'State_Selected',
        'QPalette::Mid':       r'QPalette::Mid',
    }

    ok = True
    for label, pattern in required.items():
        if re.search(pattern, code):
            print(f"  OK:   MenuBarStyle handles {label}")
        else:
            print(f"  FAIL: MenuBarStyle missing {label}")
            ok = False
    return ok


def test_no_menubar_css():
    """Verify no CSS stylesheet is set on QMenuBar (would bypass QProxyStyle)."""
    src_dir = os.path.join(os.path.dirname(__file__), '..', 'src')
    ok = True
    for root, _, files in os.walk(src_dir):
        for fname in files:
            if not fname.endswith('.cpp'):
                continue
            path = os.path.join(root, fname)
            with open(path, encoding='utf-8', errors='replace') as f:
                for i, line in enumerate(f, 1):
                    # Check for menuBar/m_menuBar stylesheet calls
                    if ('menuBar' in line or 'm_menuBar' in line) and \
                       'setStyleSheet' in line:
                        print(f"  FAIL: CSS on QMenuBar at {fname}:{i}: "
                              f"{line.strip()}")
                        ok = False
    if ok:
        print("  OK:   No CSS on QMenuBar")
    return ok


def test_hover_fixup_in_fromjson():
    """Verify Theme::fromJson applies the hover fixup."""
    src = os.path.join(os.path.dirname(__file__),
                       '..', 'src', 'themes', 'theme.cpp')
    with open(src) as f:
        code = f.read()

    if 'lighter(130)' in code and 't.hover' in code:
        print("  OK:   Theme::fromJson has hover fixup")
        return True
    else:
        print("  FAIL: Theme::fromJson missing hover fixup")
        return False


def main():
    themes = load_themes()
    if not themes:
        print("FAIL: No theme files found")
        return 1

    all_ok = True

    print("--- Test 1: Hover visibility across themes ---")
    all_ok &= test_hover_visibility(themes)

    print("\n--- Test 2: QProxyStyle handles required elements ---")
    all_ok &= test_proxystyle_handlers()

    print("\n--- Test 3: No CSS on QMenuBar ---")
    all_ok &= test_no_menubar_css()

    print("\n--- Test 4: Theme::fromJson hover fixup ---")
    all_ok &= test_hover_fixup_in_fromjson()

    print(f"\n{'='*50}")
    if all_ok:
        print("ALL HOVER TESTS PASSED")
        return 0
    else:
        print("SOME HOVER TESTS FAILED")
        return 1


if __name__ == '__main__':
    sys.exit(main())

```