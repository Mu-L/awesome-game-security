Project Path: arc_PerformanC_ReZygisk_4ojflldj

Source Tree:

```txt
arc_PerformanC_ReZygisk_4ojflldj
├── LICENSE
├── README.md
├── READMEs
│   ├── README_ar-SA.md
│   ├── README_fr-FR.md
│   ├── README_id-ID.md
│   ├── README_ja-JP.md
│   ├── README_pt-BR.md
│   ├── README_vi-VN.md
│   └── README_zh_CN.md
├── TRANSLATOR.md
├── build.gradle.kts
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── loader
│   ├── build.gradle.kts
│   └── src
│       ├── CMakeLists.txt
│       ├── common
│       │   ├── daemon.c
│       │   ├── elf_util.c
│       │   ├── misc.c
│       │   └── socket_utils.c
│       ├── external
│       │   ├── CMakeLists.txt
│       │   ├── csoloader
│       │   └── lsplt
│       ├── include
│       │   ├── daemon.h
│       │   ├── elf_util.h
│       │   ├── logging.h
│       │   ├── misc.h
│       │   └── socket_utils.h
│       ├── injector
│       │   ├── art_method.h
│       │   ├── cpp_strings.c
│       │   ├── cpp_strings.h
│       │   ├── entry.c
│       │   ├── gen_jni_hooks.py
│       │   ├── hook.c
│       │   ├── hook.h
│       │   ├── jni_hooks.h
│       │   ├── module.h
│       │   ├── ptrace_clear.c
│       │   └── ptrace_clear.h
│       └── ptracer
│           ├── main.c
│           ├── monitor.c
│           ├── monitor.h
│           ├── ptracer.c
│           ├── remote_csoloader.c
│           ├── remote_csoloader.h
│           ├── utils.c
│           └── utils.h
├── module
│   ├── build.gradle.kts
│   └── src
│       ├── META-INF
│       │   └── com
│       │       └── google
│       │           └── android
│       │               ├── update-binary
│       │               └── updater-script
│       ├── customize.sh
│       ├── module.prop
│       ├── post-fs-data.sh
│       ├── sepolicy.rule
│       ├── service.sh
│       ├── uninstall.sh
│       └── verify.sh
├── settings.gradle.kts
├── webroot
│   ├── LICENSE
│   ├── assets
│   │   ├── actions
│   │   │   ├── filled.svg
│   │   │   └── outlined.svg
│   │   ├── back.svg
│   │   ├── close.svg
│   │   ├── content.svg
│   │   ├── delete.svg
│   │   ├── ec-icon.svg
│   │   ├── error.svg
│   │   ├── expand.svg
│   │   ├── home
│   │   │   ├── filled.svg
│   │   │   └── outlined.svg
│   │   ├── mark.svg
│   │   ├── modules
│   │   │   ├── filled.svg
│   │   │   └── outlined.svg
│   │   ├── settings
│   │   │   ├── filled.svg
│   │   │   └── outlined.svg
│   │   ├── tick.svg
│   │   └── warn.svg
│   ├── css
│   │   ├── error.css
│   │   ├── icons.css
│   │   └── index.css
│   ├── fonts
│   │   ├── header.css
│   │   └── poppins.ttf
│   ├── index.html
│   ├── js
│   │   ├── browserRedirect.js
│   │   ├── errorCatcher.js
│   │   ├── errorScreen.js
│   │   ├── kernelsu.js
│   │   ├── language.js
│   │   ├── main.js
│   │   ├── monitorActions.js
│   │   ├── navbar.js
│   │   ├── restoreError.js
│   │   ├── smallPage
│   │   │   ├── errorHistory.js
│   │   │   ├── language.js
│   │   │   └── theme.js
│   │   ├── smallPageDesabler.js
│   │   ├── switcher
│   │   │   └── fontChanger.js
│   │   ├── themes
│   │   │   ├── amoled.js
│   │   │   ├── dark.js
│   │   │   ├── darkNavbar.js
│   │   │   ├── light.js
│   │   │   ├── lightIcon.js
│   │   │   └── lightNavbar.js
│   │   └── translate
│   │       ├── actions.js
│   │       ├── home.js
│   │       ├── modules.js
│   │       └── settings.js
│   └── lang
│       ├── ar_EG.json
│       ├── de_DE.json
│       ├── en_US.json
│       ├── es_AR.json
│       ├── es_ES.json
│       ├── es_MX.json
│       ├── fr_FR.json
│       ├── id_ID.json
│       ├── it_IT.json
│       ├── ja_JP.json
│       ├── ms_MS.json
│       ├── nl_NL.json
│       ├── pt_BR.json
│       ├── ru_RU.json
│       ├── tr_TR.json
│       ├── uk_UA.json
│       ├── vi_VN.json
│       └── zh_CN.json
└── zygiskd
    ├── build.gradle.kts
    └── src
        ├── LICENSE
        ├── companion.c
        ├── companion.h
        ├── constants.h
        ├── main.c
        ├── root_impl
        │   ├── apatch.c
        │   ├── apatch.h
        │   ├── common.c
        │   ├── common.h
        │   ├── kernelsu.c
        │   ├── kernelsu.h
        │   ├── magisk.c
        │   └── magisk.h
        ├── utils.c
        ├── utils.h
        ├── zygiskd.c
        └── zygiskd.h

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# ReZygisk

[Bahasa Indonesia](/READMEs/README_id-ID.md)|[Tiếng Việt](/READMEs/README_vi-VN.md)|[Português Brasileiro](/READMEs/README_pt-BR.md)|[French](/READMEs/README_fr-FR.md)|[日本語](/READMEs/README_ja-JP.md)|[العربية السعودية](/READMEs/README_ar-SA.md)

ReZygisk is a fork of Zygisk Next, a standalone implementation of Zygisk, providing Zygisk API support for KernelSU, APatch and Magisk (Official and Kitsune).

It rewrites the codebase to C entirely, bringing not only a much cleaner codebase that is easier to follow, but also a lighter binaries that are also faster. Not only that, but also introduces the usage of custom linkers to future-proof ReZygisk against future detections, not using system linker at all in normal circunstances, defeating any linker-based detection.

## Why?

The latest releases of Zygisk Next are not open-source, reserving entirely the code for its developers. Not only does that limit our ability to contribute to the project, but also impossibilities the audit of the code, which is a major security concern, as Zygisk Next is a module that runs with superuser (root) privileges, having access to the entire system.

The Zygisk Next developers are famous and trusted in the Android community, however, this doesn't mean that the code is not malicious or vulnerable. We (PerformanC) understand they have their reasons to keep the code closed-source, but we believe the contrary.

## Advantages

- FOSS (Forever)

## Dependencies

| Tool            | Description                            |
|-----------------|----------------------------------------|
| `Android NDK`   | Native Development Kit for Android     |

### C Dependencies

| Dependency  | Description                   |
|-------------|-------------------------------|
| `LSPLt`     | Simple PLT Hook for Android   |
| `CSOLoader` | SOTA Linux custom linker      |

## Installation

### 1. Select the right zip

The selection of the build/zip is important, as it will determine how hidden and stable ReZygisk will be. This, however, is not a hard task:

- `release` should be the one chosen for most cases, it removes app-level logging and offers more optimized binaries.
- `debug`, however, offers the opposite, with heavy logging and no optimizations, For this reason, **you should only use it for debugging purposes** and **when obtaining logs for creating an Issue**.

As for branches, you should always use the `main` branch, unless told otherwise by the developers, or if you want to test upcoming features and are aware of the risks involved.

### 2. Flash the zip

After choosing the right build, you should flash it using your current root manager, like Magisk or KernelSU. You can do this by going to the `Modules` section of your root manager and selecting the zip you downloaded.

After flashing, check the installation logs to ensure there are no errors, and if everything is fine, you can reboot your device.

> [!WARNING]
> Magisk users should disable built-in Zygisk, as it will conflict with ReZygisk. This can be done by going to the `Settings` section of Magisk and disabling the `Zygisk` option.

### 3. Verify the installation

After rebooting, you can verify if ReZygisk is working properly by checking the module description in the `Modules` section of your root manager. The description should indicate that the necessary daemons are running. For example, if your environment supports both 64-bit and 32-bit, it should look similar to this: `[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

## Translation

There are currently two different ways to contribute translations for ReZygisk:

- For translations of the README, you can create a new file in the `READMEs` folder, following the naming convention of `README_<language>.md`, where `<language>` is the language code (e.g., `README_pt-BR.md` for Brazilian Portuguese), and open a pull request to the `main` branch with your changes.
- For translations of the ReZygisk WebUI, you should first contribute to our [Crowdin](https://crowdin.com/project/rezygisk). Once approved retrieve the `.json` file from there and open a pull request with your changes -- adding the `.json` file to the `webroot/lang` folder and your credits to the `TRANSLATOR.md` file, in alphabetic order.

## Support

For any question related to ReZygisk or other PerformanC projects, feel free to join any of the following channels below:

- Discord Channel: [PerformanC](https://discord.gg/uPveNfTuCJ)
- ReZygisk Telegram Channel: [@rezygisk](https://t.me/rezygisk)
- PerformanC Telegram Channel: [@performancorg](https://t.me/performancorg)
- PerformanC Signal Group: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## Contribution

It is mandatory to follow PerformanC's [Contribution Guidelines](https://github.com/PerformanC/contributing) to contribute to ReZygisk. Following its Security Policy, Code of Conduct, and syntax standard.

## License

ReZygisk is licensed majoritaly under GPL, by Dr-TSNG, but also AGPL 3.0, by The PerformanC Organization, for re-written code. You can read more about it on [Open Source Initiative](https://opensource.org/licenses/AGPL-3.0).

```

`READMEs/README_ar-SA.md`:

```md
# ReZygisk

[English](../README.md)

ReZygisk هو **فرع (fork)** من Zygisk Next، وهو تطبيق مستقل لـ Zygisk، يوفر دعم واجهة برمجة تطبيقات Zygisk (Zygisk API) لكل من **KernelSU** و **APatch** و **Magisk** (الرسمي و Kitsune).

يهدف المشروع إلى تحديث وإعادة كتابة قاعدة التعليمات البرمجية بالكامل إلى لغة **C**، مما يسمح بتطبيق أكثر كفاءة وسرعة لواجهة برمجة تطبيقات Zygisk بترخيص أكثر تساهلاً وداعمًا للبرمجيات الحرة ومفتوحة المصدر (**FOSS**).

---

## لماذا؟

الإصدارات الأخيرة من Zygisk Next ليست مفتوحة المصدر، مما يحصر التعليمات البرمجية بالكامل على مطوريها. هذا لا يحد فقط من قدرتنا على المساهمة في المشروع، بل يجعل أيضًا مراجعة التعليمات البرمجية أمرًا مستحيلاً، وهو مصدر قلق أمني كبير، حيث أن Zygisk Next هي وحدة نمطية تعمل بامتيازات المستخدم الخارق (**root**)، مما يتيح لها الوصول إلى النظام بأكمله.

مطورو Zygisk Next مشهورون وموثوق بهم في مجتمع Android، ولكن هذا لا يعني أن التعليمات البرمجية ليست ضارة أو عرضة للثغرات الأمنية. نحن (PerformanC) نتفهم أن لديهم أسبابهم للحفاظ على التعليمات البرمجية مغلقة المصدر، لكننا نؤمن بالعكس.

---

## المزايا

- **FOSS** (مفتوح المصدر وحر للأبد)

---

## التبعيات

| الأداة  |          الوصف                             |
|-----------------|------------------------------------|
| `Android NDK`   | مجموعة تطوير أصلية لنظام Android |

### تبعيات C++

| التبعية |   الوصف                           |
|---------|------------------------------------|
| `lsplt` | ربط PLT بسيط لنظام Android        |

---

## التثبيت

### 1. اختر ملف المضغوط الصحيح

يعد اختيار البناء/ملف المضغوط أمرًا مهمًا، حيث سيحدد مدى إخفاء وثبات ReZygisk. ومع ذلك، هذه ليست مهمة صعبة:

- يجب اختيار **`release`** في معظم الحالات، حيث يزيل تسجيل سجلات مستوى التطبيق ويوفر ثنائيات أكثر تحسينًا.
- في المقابل، توفر نسخة **`debug`** العكس، مع تسجيل سجلات مكثف وعدم وجود تحسينات. لهذا السبب، **يجب عليك استخدامها فقط لأغراض التصحيح** و **عند الحصول على السجلات لإنشاء تقرير مشكلة (Issue)**.

أما بالنسبة للفروع (branches)، فيجب عليك دائمًا استخدام الفرع **`main`**، ما لم يخبرك المطورون بخلاف ذلك، أو إذا كنت ترغب في اختبار الميزات القادمة وتدرك المخاطر التي تنطوي عليها.

### 2. تثبيت (Flash) ملف المضغوط

بعد اختيار البناء الصحيح، يجب عليك تثبيته باستخدام مدير الروت الحالي الخاص بك، مثل **Magisk** أو **KernelSU**. يمكنك القيام بذلك عن طريق الذهاب إلى قسم **`Modules`** (الوحدات النمطية) في مدير الروت الخاص بك واختيار ملف المضغوط الذي قمت بتنزيله.

بعد التثبيت، تحقق من سجلات التثبيت للتأكد من عدم وجود أخطاء، وإذا سار كل شيء على ما يرام، يمكنك إعادة تشغيل جهازك.

> [!WARNING]
> يجب على مستخدمي **Magisk** تعطيل Zygisk المدمج، حيث سيتعارض مع ReZygisk. يمكن القيام بذلك عن طريق الذهاب إلى قسم **`Settings`** (الإعدادات) في Magisk وتعطيل خيار **`Zygisk`**.

### 3. التحقق من التثبيت

بعد إعادة التشغيل، يمكنك التحقق مما إذا كان ReZygisk يعمل بشكل صحيح عن طريق فحص وصف الوحدة النمطية في قسم **`Modules`** (الوحدات النمطية) في مدير الروت الخاص بك. يجب أن يشير الوصف إلى أن العمليات الخلفية الضرورية قيد التشغيل. على سبيل المثال، إذا كانت بيئتك تدعم كلاً من 64 بت و 32 بت، فيجب أن تبدو مشابهة لما يلي: `[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

---

## الترجمة

يوجد حاليًا طريقتان مختلفتان للمساهمة في ترجمات ReZygisk:

- لترجمات ملف **README**، يمكنك إنشاء ملف جديد في مجلد **`READMEs`**، باتباع اصطلاح تسمية الملفات `README_<اللغة>.md`، حيث `<اللغة>` هو رمز اللغة (على سبيل المثال، `README_ar-SA.md` للغة العربية السعودية)، وفتح **طلب سحب (pull request)** إلى الفرع **`main`** بتعديلاتك.
- لترجمات **واجهة المستخدم الويب (WebUI)** الخاصة بـ ReZygisk، يجب عليك أولاً المساهمة في مشروعنا على [Crowdin](https://crowdin.com/project/rezygisk). بمجرد الموافقة، استرجع ملف **`.json`** من هناك وافتح طلب سحب بتعديلاتك -- بإضافة ملف **`.json`** إلى مجلد **`webroot/lang`** وإضافة رصيدك إلى ملف **`TRANSLATOR.md`**، بالترتيب الأبجدي.

---

## الدعم

لأي سؤال يتعلق بـ ReZygisk أو مشاريع PerformanC الأخرى، لا تتردد في الانضمام إلى أي من القنوات التالية أدناه:

- قناة Discord: [PerformanC](https://discord.gg/uPveNfTuCJ)
- قناة Telegram الخاصة بـ ReZygisk: [@rezygisk](https://t.me/rezygisk)
- قناة Telegram الخاصة بـ PerformanC: [@performancorg](https://t.me/performancorg)
- مجموعة Signal الخاصة بـ PerformanC: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

---

## المساهمة

من الضروري اتباع [إرشادات المساهمة](https://github.com/PerformanC/contributing) الخاصة بـ PerformanC للمساهمة في ReZygisk. مع اتباع سياسة الأمان الخاصة بها، ومدونة السلوك، ومعيار الصيغة (syntax).

---

## الترخيص

ReZygisk مرخص في الأغلب بموجب **GPL**، بواسطة Dr-TSNG، وأيضاً بموجب **AGPL 3.0**، بواسطة The PerformanC Organization، للتعليمات البرمجية التي تمت إعادة كتابتها. يمكنك قراءة المزيد حول ذلك على [Open Source Initiative](https://opensource.org/licenses/AGPL-3.0).

```

`READMEs/README_fr-FR.md`:

```md
# ReZygisk

[English](../README.md)

ReZygisk est un fork de Zygisk Next, une implémentation autonome de Zygisk. Il vise à fournir un support de l'API Zygisk pour KernelSU, APatch et Magisk (Officiel et Kitsune).

L'objectif est de moderniser et de réécrire la base du code initégralement en C. Cela permettra une meilleure efficacité et une implémentation plus rapide de l'API Zygisk, le tout sous une licence plus permissive et en faveur des logiciels libres (FOSS).

## Pourquoi ?

La dernière release de Zygisk Next n'est pas open source, le code est donc accessible uniquement à ses développeurs. Non seulement cela limite notre capacité à contribuer au projet, mais cela rend également impossible la vérification du code, ce qui constitue une préoccupation majeure en matière de sécurité. Zygisk Next est un module fonctionnant avec les permissions administrateur (root) et a donc accès à l'entièreté du système.

Les développeurs de Zygisk Next sont connus et reconnus dans la communauté Android. Toutefois, cela ne signifie pas que du code malveillant ou des vulnérabilités ne se cachent pas dans le code. Nous (PerfomanC) comprenons qu'ils aient des raisons de garder leur code en source fermée, mais nous pensons qu'avoir un code open source est mieux.

## Avantages

- FOSS (Pour toujours !)

## Dépendances

| Outil           | Description                            |
|-----------------|----------------------------------------|
| `Android NDK`   | Kit de développement natif d'Android   |

### Dépendances C++

| Dépendance | Description                   |
|------------|-------------------------------|
| `lsplt`    | Simple PLT Hook pour Android  |

## Installation

### 1. Choisi la bonne archive ZIP

La sélection du build/archive ZIP est important, car cela déterminera à quel point ReZygisk sera caché et stable. Toutefois, ce n'est pas compliqué :

- `release` doit être choisie dans la majorité des cas, car elle supprime les journaux au niveau application et offre des binaires plus optimisés.
- `debug`, en revanche, cette version offre l'inverse avec des journaux détaillés et aucune optimisation. C'est pour cela que **vous ne devriez n'utiliser cette version uniquement pour le débogage** et **l'obtention de journaux pour ouvrir un rapport d'incident (issue Github)**.

En ce qui concerne les branches, vous devriez toujours utiliser la branche `main`, sauf si les développeurs vous indiquent le contraire ou si vous souhaitez tester les fonctionnalités à venir et êtes conscient des risques encourus.

### 2. Flashez l'archive zip

Après avoir choisi le bon build, vous devez le flasher à l'aide de votre gestionnaire root, comme Magisk ou KernelSU. Vous pouvez le faire en allant dans la section `Modules` de votre gestionnaire root et en y sélectionnant l'archive zip que vous venez de télécharger.

Après le flash, vérifiez les journaux d'installation pour vous assurer qu'il n'y ait pas d'erreurs, et si tout va bien, vous pouvez redémarrer votre appareil.

> [!WARNING]
> Les utilisateurs de Magisk doivent désactiver Zygisk pré intégré, car sinon il entrera en conflit avec ReZygisk. Cela peut être fait en vous rendant dans la section `Paramètres` de Magisk et en désactivant l'option `Zygisk`

### 3. Vérifiez l'installation

Après le redémarrage, vous ne pouvez pas vérifier si ReZygisk fonctionne normalement en vérifiant la description du moudles dans la section `Modules` de votre gestionnaire root. La description doit indiquer que les processus en arrière plan nécessaire sont en cours d'exécution. Par exemple, si votre environnement prend en charge à la fois le 64 bits et le 32 bits, cela devrait ressembler à ceci :`[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

## Traduction

Il existe actuellement deux façons différentes de contribuer aux traductions pour ReZygisk:

- Pour les traductions du README, vous pouvez créer un nouveau fichier dans le dossier READMEs, en suivant la convention de dénomination des fichiers `README_<langue>.md`, où `<langue>` est le code de la langue (par exemple, `README_fr-FR.md` pour le franco français), puis ouvrir un pull request vers la branche `main` avec vos modifications.
- Pour les traductions de l'interface WebUI de ReZygisk, vous devez passer par le projet [Crowdin](https://crowdin.com/project/rezygisk). Une fois approuvé, récupérez le fichier `.json` et ouvrez un pull request avec vos modifications -- en ajoutant le fichier `.json` au dossier `webroot/lang` et vos crédits au fichier `TRANSLATOR.md`, par ordre alphabétique.

## Support

Pour toutes questions relatives a ReZygisk ou d'autres projets de PerformanC, n'hésitez pas à nous rejoindre via les différents moyens disponibles:

- Notre Discord: [PerformanC](https://discord.gg/uPveNfTuCJ)
- Le Telegram relatif a ReZygisk: [@rezygisk](https://t.me/rezygisk)
- Notre Telegram: [@performancorg](https://t.me/performancorg)
- Notre Signal: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## Contribution

Il est obligatoire de lire les instructions de PerformanC dans les [Contribution Guidelines](https://github.com/PerformanC/contributing) afin de contribuer au projet ReZygisk. Suivez la politique de sécurité, le code de conduite et les standards relatif à la syntaxe.

## License

ReZygisk est majoritairement sous la licence GPL pour la partie de Dr-TSNG, mais sous licence AGPL 3.0 pour la partie réécrite du code par PerformanC. Vous pouvez trouver plus d'information sur le lien suivant : [Open Source Initiative](https://opensource.org/licenses/AGPL-3.0).

```

`READMEs/README_id-ID.md`:

```md
# ReZygisk

[English](../README.md)

ReZygisk adalah turunan dari Zygisk Next, sebuah implementasi mandiri dari Zygisk, menyediakan dukungan API Zygisk untuk KernelSU, APatch, dan Magisk (Versi Resmi dan Kitsune).

Tujuannya adalah untuk memodernisasi dan menulis ulang kode sumber sepenuhnya dalam bahasa C, memungkinkan implementasi API Zygisk yang lebih efisien dan cepat dengan lisensi yang lebih permisif dan ramah terhadap FOSS (Free and Open Source Software).

## Mengapa?

Rilisan terbaru dari Zygisk Next tidak bersifat open-source, dengan kode yang sepenuhnya dikendalikan oleh developernya. Hal ini tidak hanya membatasi kemampuan kami untuk berkontribusi pada proyek ini, tetapi juga membuat kode tidak dapat diaudit, yang menjadi masalah utama keamanan karena Zygisk Next adalah modul yang berjalan dengan hak superuser (root), yang memiliki akses ke seluruh sistem.

Meskipun developer Zygisk Next terkenal dan dipercaya dalam komunitas Android, hal ini tidak menjamin bahwa kode tersebut bebas dari bahaya atau kerentanan. Kami (PerformanC) memahami alasan mereka untuk menjaga kode tetap tertutup, tetapi kami memiliki pandangan yang berbeda.

## Keunggulan

- FOSS (Free and Open Source Software) Selamanya.

## Komponen Pendukung

| Alat             | Deskripsi                                  |
|------------------|--------------------------------------------|
| `Android NDK`    | Native Development Kit untuk Android       |

### Komponen Pendukung C++

| Ketergantungan | Deskripsi                       |
|----------------|---------------------------------|
| `lsplt`        | Simple PLT Hook untuk Android   |

## Instalasi

### 1. Pilih file ZIP yang tepat

Pemilihan build/zip sangat penting, karena ini akan menentukan seberapa tersembunyi dan stabil ReZygisk. Namun, ini bukan tugas yang sulit:

- `release`: Direkomendasikan untuk penggunaan normal. Binary lebih optimal, logging minimal.
- `debug`: Untuk keperluan debug. Logging lengkap, tanpa optimasi.

Untuk branch, selalu gunakan main branch, kecuali diinstruksikan oleh pengembang, atau jika Anda ingin menguji fitur mendatang dan menyadari risikonya.

### 2. Flash file ZIP

Setelah memilih build yang tepat, Anda harus mem-flash-nya menggunakan pengelola root Anda saat ini, seperti Magisk atau KernelSU. Anda dapat melakukannya dengan masuk ke bagian Modules di pengelola root Anda dan memilih zip yang telah diunduh.

Setelah mem-flash, periksa log instalasi untuk memastikan tidak ada kesalahan, dan jika semuanya selesai, Anda dapat me-reboot perangkat Anda

> [!WARNING]
> Pengguna Magisk harus menonaktifkan Zygisk bawaan, karena ini akan bentrok dengan ReZygisk. Ini dapat dilakukan dengan masuk ke bagian `Settings` di Magisk dan menonaktifkan opsi `Zygisk`.

### 3. Verifikasi Instalasi

Setelah reboot, Anda dapat memverifikasi apakah ReZygisk bekerja dengan baik dengan memeriksa deskripsi modul di bagian Modules pada pengelola root Anda. Deskripsi tersebut harus menunjukkan bahwa daemon yang diperlukan sedang berjalan. Misalnya, jika lingkungan Anda mendukung 64-bit dan 32-bit, itu akan terlihat seperti ini:
`[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

## Terjemahan

Saat ini ada dua cara untuk berkontribusi dalam terjemahan untuk ReZygisk:

- Untuk terjemahan README, Anda dapat membuat file baru di folder `READMEs`, mengikuti konvensi penamaan `README_<bahasa>.md`, di mana `<bahasa>` adalah kode bahasa (misalnya, `README_id-ID.md` untuk Bahasa Indonesia), dan membuka pull request ke `main` branch.
- Untuk terjemahan WebUI ReZygisk, Anda harus berkontribusi terlebih dahulu di [Crowdin](https://crowdin.com/project/rezygisk). Setelah disetujui, ambil file `.json` dari sana dan buka pull request dengan perubahan Anda -- tambahkan file `.json` ke folder `webroot/lang` dan kredit Anda ke file TRANSLATOR.md, dalam urutan alfabet.

## Dukungan

Untuk pertanyaan terkait ReZygisk atau proyek PerformanC lainnya, jangan ragu untuk bergabung dengan salah satu saluran berikut:

Untuk pertanyaan terkait ReZygisk atau proyek PerformanC lainnya, silakan bergabung ke salah satu saluran berikut:

- Saluran Discord: [PerformanC](https://discord.gg/uPveNfTuCJ)
- Saluran Telegram ReZygisk: [@rezygisk](https://t.me/rezygisk)
- Saluran Telegram PerformanC: [@performancorg](https://t.me/performancorg)
- Grup Signal PerformanC: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## Kontribusi

Wajib mengikuti [Pedoman Kontribusi](https://github.com/PerformanC/contributing) PerformanC's untuk berkontribusi pada ReZygisk. Sesuai dengan Kebijakan Keamanan, Kode Etik, standar struktur dan format yang berlaku.

## Lisensi

ReZygisk sebagian besar berlisensi di bawah GPL, oleh Dr-TSNG, tetapi juga AGPL 3.0, oleh The PerformanC Organization, untuk kode yang ditulis ulang. Anda dapat juga membaca lebih lanjut di [Open Source Initiative](https://opensource.org/licenses/AGPL-3.0).

```

`READMEs/README_ja-JP.md`:

```md
# ReZygisk

[English](../README.md)

ReZygiskはZygiskのスタンドアローン実装であるZygisk Nextのフォークです。ReZygiskは、KernelSU、APatch、Magisk（オフィシャルバージョンとKitsuneバージョン両方）それぞれへのZygisk APIサポートを備えています。

ReZygiskはコードベースをCに移行し、よりモダンなコードで書き換えることを目標にしています。これにより、Zygisk APIのより効率的かつ高速な実装と、FOSSライセンスの両方を備えることができています。

## なぜReZygiskを選ぶべきか

Zygisk Nextの最新リリースはオープンソースではなく、コードをその開発者のみにアクセス可能にしています。これは我々のように一般の開発者の貢献を無下にするだけでなく、Zygisk Nextがroot権限で走るアプリなのにもかかわらずコードにアクセスできないため、セキュリティ上でも深刻な問題が有ります。

Zygisk Nextの開発者達は有名かつコミュニティからも信頼されていますが、これはコードが100%悪意が無いことや脆弱性が無いことを意味しません。我々（PerformanC）は彼らがZygisk Nextをクローズドソースにする理由も理解していますが、我々はその逆を信じます。

## メリット

- FOSS (無制限)

## 依存関係

| ツール           | 説明                                   |
|-----------------|----------------------------------------|
| `Android NDK`   | Native Development Kit for Android     |

### C++ 依存関係

| 依存関係    | 説明                          |
|------------|-------------------------------|
| `lsplt`    | Simple PLT Hook for Android   |

## インストール

### 1. 必要なZipファイルを選択

ReZygiskの安定性や匿名性のためには、ビルドファイル/Zipファイルの選択は**非常に重要**です。しかしながら、これはそこまで難しくもありません。

- `release` バージョンが基本的にはおすすめです。アプリレベルのログが出力されなかったりなど、より効率化されたバイナリが提供されるためです。
- `debug` バージョンはreleaseバージョンの反対です。重いログの出力がなされたり、高速化されていないバイナリが提供されます。このため、このバージョンは**デバッグ用に**、もしくは**Issueを作るためにログを入手する**ときのみに使われるべきです。

ブランチに関しては、基本的に`main`ブランチを選択すべきです。しかしながら、PerformanCの開発者に違うブランチを使うように言われたり、あなたがベータ版のコードを使うことのリスクを理解しかつ実装されたばかりの機能を使いたいのならば違うブランチを選択することも選択肢の一つでしょう。

### 2. Zipファイルをフラッシュ

正しいビルドを選択したあとは、ReZygiskのビルドを現在使用しているルートマネージャー（MagiskやKernelSU等）を使用してフラッシュしてください。これは、マネージャーで`Modules`セクションを開きダウンロードしたビルドファイルを選択することでできます。

フラッシュしたあとは、インストールログを確認して、エラーがないか確かめてください。なんのエラーも起きていなければ、デバイスを再起動してください。

> [!WARNING]
> Magiskを使用しているのならば、ビルトインのZygiskがReZygiskと競合するため無効化してください。Magiskの`設定`セクションを開き、Zygiskオプションを無効化することでできます。

### 3. インストールを確認

再起動後、ルートマネージャーの`Modules`セクションをチェックすることによりReZygiskが正常に動いているかどうか確認できます。
説明欄は、必要なデーモンが動作していることを示しているはずです。例えば、あなたの端末が64bitと32bitの両方をサポートしている場合、右記のように見えるはずです: `[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

## 翻訳

There are currently two different ways to contribute translations for ReZygisk:

- READMEの翻訳は、`READMEs`フォルダに`README_<language code>.md`というファイルを作り、そこに翻訳を書き込んでください。その後、プルリクエストを送信してくださいlang` folder and your credits to the `TRANSLATOR.md` file, in alphabetic order.
- ReZygisk WebUIの翻訳のためには、まず[Crowdin](https://crowdin.com/project/rezygisk)で貢献する必要が有ります。一度貢献を許可され、`.json`ファイルを入手したならば、そのファイルを元に新しい言語のファイルを作り、その`.json`ファイルを`webroot/lang`フォルダに入れてください。更に、TRANSLATOR.mdにあなたのクレジットを付与するのも忘れないでください！（なお名前の順番はアルファベット順です）

## サポート

ReZygiskやPerformanCのプロジェクトに関して質問がある場合、以下のいずれかに参加して質問してください。

- Discord チャンネル: [PerformanC](https://discord.gg/uPveNfTuCJ)
- ReZygisk Telegram チャンネル: [@rezygisk](https://t.me/rezygisk)
- PerformanC Telegram チャンネル: [@performancorg](https://t.me/performancorg)
- PerformanC Signal Group: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## 貢献

[Contribution Guidelines](https://github.com/PerformanC/contributing)に従ってください。セキュリティポリシー、コードスタイル等、すべて従う必要が有ります。

## ライセンス

ReZygiskはDr-TSNGによるGPLライセンスと、PerformanCが書き直したコードに関してはThe PerformanC OrganizationによるAGPL 3.0ライセンスの元に配布されます。[Open Source Initiative](https://opensource.org/licenses/AGPL-3.0)で、より詳しい情報を得ることができます。

```

`READMEs/README_pt-BR.md`:

```md
# ReZygisk

[English](../README.md)

ReZygisk é uma fork do Zygisk Next, uma implementação do Zygisk independente, fornecendo a API do Zygisk para o KernelSU, APatch e Magisk (além do embutido).

Ele foca em modernizar e re-escrever todo o código fonte para C, permitindo uma implementação da API do Zygisk com uma licença mais permissiva e amigável a FOSS.

## Por quê?

Os últimos lançamentos do Zygisk Next não possuem código aberto, reservando-o para os seus desenvolvedores. Isso não só limita nossa capacidade de contribuir com o projeto, mas também impossibilita a auditoria do código, uma preocupação grave de segurança, já que o Zygisk Next é um módulo que roda como superuser (super usuário/root), tendo acesso a todo o sistema.

Os desenvolvedores do Zygisk Next são famosos e confiados pela comunidade Android, mas isso não significa que o código não seja nem malicioso nem vulnerável. Nós (PerformanC) reconhecemos seus motivos de manterem o código recluso a eles, mas a gente acredita no contrário.

## Vantagens

- FOSS (Pra sempre)

## Dependências

| Ferramenta      | Descrição                                    |
|-----------------|----------------------------------------------|
| `Android NDK`   | Kit de Desenvolvimento Nativo para o Android |

### Dependências C++

| Dependência | Descrição                        |
|-------------|----------------------------------|
| `lsplt`     | PLT Hook simples para o Android  |

## Instalação

### 1. Selecionando o zip apropriado

A seleção da build/zip é importate, já que vai determinar o quão escondido e estável o ReZygisk vai ser. Isso, no entanto, não é uma tarefa difícil:

- `release` deve ser a escolha para a maioria dos casos, ele remove o log de nível de app e oferece binários mais otimizados.
- `debug`, no entanto, oferece o oposto, com logs extensos, e sem otimizações. Por isso, **você deve usar apenas para fins de depuração** e **ao obter logs para criar um Issue**.

### 2. "Flash"ando o zip

Depois de escolher a build apropriada, você deve "flashar" ela usando seu gerenciador de root atual, como o Magisk ou o KernelSU. Você pode fazer isso indo na seção `Módulos` do seu gerenciador de root e selecionando o zip que você fez download.

Depois de "flashar", confira os logs de instalação para garantir que não houve erros, e se tudo estiver certo, você pode reiniciar seu dispositivo.

> [!WARNING]
> Usuários do Magisk devem desabilitar o Zygisk embutido, já que ele vai conflitar com o ReZygisk. Isso pode ser feito indo na seção `Configurações` do Magisk e desabilitando a opção `Zygisk`.

### 3. Verificando a instalação

Depois de reiniciar, você pode verificar se o ReZygisk está funcionando corretamente indo na seção `Módulos` do seu gerenciador de root. A descrição deve indicar que os daemons necessários estão rodando. Por exemplo, se seu ambiente suporta tanto 64-bit quanto 32-bit, deve estar parecido com isso: `[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

## Tradução

Tem duas formas diferentes de contribuir com traduções para o ReZygisk:

- Para traduções do README, você pode criar um novo arquivo na pasta `READMEs`, seguindo a padronização de nome de `README_<idioma>.md`, onde `<idioma>` é o código do idioma (ex: `README_pt-BR.md` para português brasileiro), e abrir um pull request para o branch `main` com suas mudanças.
- Para traduções da WebUI do ReZygisk, você deve primeiro contribuir no nosso [Crowdin](https://crowdin.com/project/rezygisk). Depois de aprovado, pegue o arquivo `.json` de lá e abra um pull request com suas mudanças -- adicionando o arquivo `.json` na pasta `webroot/lang` e seus créditos no arquivo `TRANSLATOR.md`, em ordem alfabética.

## Suporte

Para quaisquer problemas no ReZygisk ou qualquer projeto da PerformanC, sinta-se livre para entrar em qualquer canal abaixo:

- Server do Discord: [PerformanC](https://discord.gg/uPveNfTuCJ)
- Canal do Telegram do ReZygisk: [@rezygisk](https://t.me/rezygisk)
- Canal do Telegram da PerformanC: [@performancorg](https://t.me/performancorg)
- Grupo do Signal da PerformanC: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## Contribuição

É obrigatório seguir as [Regras de Contribuição](https://github.com/PerformanC/contributing) da PerformanC para contribuir ao ReZygisk, seguindo sua Política de Segurança, Código de Conduta, e padronização de sintaxe.

## Licença

ReZygisk é majoritamente licenciado em GPL, por Dr-TSNG, mas também em AGPL 3.0, pela A Organização PerformanC (The PerformanC Organization) para código re-escrito. Você pode ler mais em [Open Source Initiative](https://opensource.org/licenses/AGPL-3.0).

```

`READMEs/README_vi-VN.md`:

```md
# ReZygisk

[English](../README.md)

ReZygisk làm một nhánh phát triển lấy từ ZygiskNext, một triển khai độc lập của Zygisk, cung cấp và hỗ trợ Zygisk API cho KernelSU, APatch và Magisk (chính thức và Kitsune).

Mục tiêu của ReZygisk là mô-đun hoá và viết lại toàn bộ codebase sang C, cho phép triển khai API Zygisk hiệu quả hơn và nhanh hơn với giấy phép dễ dàng tái sử dụng hơn.

## Tại sao nhánh phát triển này lại xuất hiện?

Bản ra mắt mới nhất của Zygisk Next không còn là mã nguồn mở, dành toàn bộ quyền phát triển phần mềm cho những nhà phát triển gốc. Không chỉ giới hạn chúng ta đóng gốp cho dự án, mà còn bất khả thi trong việc kiểm trả độ đảm bảo của mã, điều mà có thể coi là mối quan tâm lớn về tính bảo mật và độ an toàn, bởi Zygisk Next là mô-đun chạy dưới quyền quản trị (root), có khả năng truy cập vào toàn bộ hệ thống trong thiết bị của bạn.

Các nhà phát triển Zygisk Next đều là những người nổi tiếng và được tin tưởng bởi cộng đồng sử dụng Android, tuy nhiên, điều đó không có nghĩa là mã nguồn của họ không có lỗ hổng hoặc có nguy cơ bị tấn công. Chúng tôi (PerformanC) thông cảm được lý do mà học đóng mã nguồn của họ vào, tuy nhiễn chúng tôi tin vào điều ngược lại.

## Ưu điểm

- Mã nguồn mở (Vĩnh Viễn)

## Các công cụ/thư viện được sử dụng

| Công cụ / Thư Viện        | Mô tả                                     |
|---------------------------|-------------------------------------------|
| `Android NDK`             | Bộ công cụ phát triển cốt lõi cho Android |

### Các công cụ/thư viện của C được sử dụng

| Thư Viện    | Mô Tả                                        |
|-------------|----------------------------------------------|
| `lsplt`     | Công cụ **móc** vào PLT đơn giản cho Android |
| `CSOLoader` | Linker tùy biến **tối tân** của Linux        |

## Cài Đặt

### 1. Sử dụng đúng tệp zip

Chọn đúng tệp bản dựng / zip là một điều tất yếu, bởi nó sẽ xác định khả năng ẩn của ReZygisk. Về cơ bản đây không phải là một việc khó:

- `release` bản này sẽ được chọn trong hầy hết các trường hợp sử dụng, bản này loại bỏ nhật ký phát triển cấp độ ứng dụng và cung cấp các tệp nhị phân được tối ưu hóa hơn.
- `debug`,  bản này tuy nhiên không được tối ưu và đi kèm với nó là ghi lại nhật ký phát triển khá nhiều. Vì lý do này, **chỉ nên sử dụng khi cần gỡ lỗi** và **khi cần ghi lại nhật lý để tạo báo về lỗi hoặc gì đó**.

Đối với nhánh, bạn nên sử dụng nhánh `main` là chính, trừ khi các nhà phát triển nói bạn sử dụng nhánh khác, hoặc khi bạn muốn kiểm thử những tính năng mới và bạn đã biết được những rủi ro liên quan đến thiết bị của bạn.

### 2. Flash tệp zip

Sau khi chọn một bản dựng phù hợp với bạn, điều cần làm là flash nó bằng trình quản lý root như Magisk hay KernelSU. Bạn có thể làm điều này bằng cách vào mục `Mô-đun / Module` của trình quản lý root của bạn và chọn tệp zip vừa tải xuống.

Sau khi flash, kiểm tra lại nhật ký lỗi để chắc chắn rằng không có lỗi nào xảy ra, nếu mọi thứ xuôn sẻ, khởi động lại thiết bị.

> [!WARNING]
> Người dùng Magisk cần phải tắt `built-in Zygisk`, bởi nó sẽ xung đột với ReZygisk. Điều này có thể thực hiện bằng cách vào `Cài Đặt` và tắt tùy chọn `ZygiskZygisk`

### 3. Verify the installation

Sau khi khởi động lại, bạn có thể xác minh ReZygisk có hoạt động bình thường không bằng cách kiểm tra mô tả module trong phần `Modules` của trình quản lý gốc. Mô tả sẽ chỉ ra rằng các daemon cần thiết đang chạy. Ví dụ, nếu môi trường của bạn hỗ trợ cả cấu trúctrúc 64-bit và 32-bit, nó sẽ trông giống như thế này: `[Monitor: ✅, ReZygisk 64-bit: ✅, ReZygisk 32-bit: ✅] Standalone implementation of Zygisk.`

## Dịch WebUI cho mô-đun

Hiện tại có hai cách khác nhau để đóng góp bản dịch cho ReZygisk:

- Đối với bản dịch của README, bạn có thể tạo một tệp mới trong thư mục `READMEs`, theo quy ước đặt tên `README_<language>.md`, trong đó `<language>` là mã ngôn ngữ (ví dụ: `README_pt-BR.md` cho tiếng Bồ Đào Nha Brazil) và mở yêu cầu kéo đến nhánh `main` với các thay đổi của bạn.
- Đối với bản dịch của ReZygisk WebUI, trước tiên bạn phải đóng góp cho [Crowdin](https://crowdin.com/project/rezygisk) của chúng tôi. Sau khi được chấp thuận, hãy lấy tệp `.json` từ đó và mở yêu cầu kéo với các thay đổi của bạn -- thêm tệp `.json` vào thư mục `webroot/lang` và ghi công của bạn vào tệp `TRANSLATOR.md`, theo thứ tự bảng chữ cái.

## Hỗ trợ

Nếu bạn có những câu hỏi nào dành cho ReZygisk hoặc bất kì một dự án nào của PerformanC, hãy tự nhiên tham gia các kênh trò chuyện dưới đây:

- Kênh Discord: [PerformanC](https://discord.gg/uPveNfTuCJ)
- Kênh Telegram ReZygisk: [@rezygisk](https://t.me/rezygisk)
- Kênh Telegram PerformanC: [@performancorg](https://t.me/performancorg)
- Nhóm Signal PerformanC: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## Đóng góp cho dự án này

Tuân theo [hướng dẫn đóng góp](https://github.com/PerformanC/contributing) của PerformanC là một điều tất yếu mà bạn bắt buộc phải làm. Hãy tuân theo chính sách bảo mật, quy tắc ứng xử/đóng góp mã nguồn và tiêu chuẩn cú pháp riêng.

## Bản quyền

Hầu hết các thành phần của ReZygisk để dưới bản quyền GPL (bởi Dr-TSNG) và AGPL 3.0 (bởiThe PerformanC Organization) cho những phần được viết lại. Bạn có thể xem thêm trong trang [Open Source Initiative](https://opensource.org/licenses/AGPL-3.0).

```

`READMEs/README_zh_CN.md`:

```md
# ReZygisk

[English](../README.md)

ReZygisk 是 Zygisk Next 的一个分支，是 Zygisk 的独立实现，为 KernelSU、APatch 和 Magisk（官方版和 Kitsune 版）提供 Zygisk API 支持。

它旨在将代码库完全现代化并重写为 C 语言，以更宽松且对 FOSS（自由开源软件）友好的许可证，实现更高效、更快速的 Zygisk API。

## 为什么？

Zygisk Next 的最新版本不是开源的，其代码完全由其开发者保留。这不仅限制了我们为项目做出贡献的能力，也使得代码审计变得不可能，这是一个重大的安全隐患，因为 Zygisk Next 是一个以超级用户 (root) 权限运行的模块，可以访问整个系统。

Zygisk Next 的开发者是 Android 社区中著名且值得信赖的，然而，这并不意味着代码没有恶意或漏洞。我们 (PerformanC) 理解他们保留代码闭源的原因，但我们持相反的观点。

## 优势

- **FOSS (永远开源)**

## 依赖项

| 工具              | 描述                               |
|-------------------|-----------------------------------|
| `Android NDK`     | Android 原生开发工具包             |

### C++ 依赖项

| 依赖项        | 描述                             |
|--------------|----------------------------------|
| `lsplt`      | Android 的简单 PLT Hook 库        |

## 安装

### 1. 选择正确的 zip 文件

选择正确的构建版本/zip 文件很重要，因为它将决定 ReZygisk 的隐藏性和稳定性。不过，这并不是一项艰巨的任务：

- `release` 版本应该是大多数情况下的选择，它移除了应用层级的日志记录，并提供更优化的二进制文件。
- `debug` 版本则相反，它包含大量日志记录且没有优化。因此，**你应仅在调试目的**以及**为创建 Issue 而获取日志时**使用它。

至于分支，你应始终使用 `main` 分支，除非开发者另有说明，或者你想测试即将推出的功能并知晓其中涉及的风险。

### 2. 刷入 zip 文件

选择正确的版本后，你应该使用当前的 root 管理器（如 Magisk 或 KernelSU）刷入它。你可以进入 root 管理器的 `模块` 部分，然后选择你下载的 zip 文件来完成此操作。

刷入后，检查安装日志以确保没有错误。如果一切正常，你可以重启设备。

> [!WARNING]
> Magisk 用户应禁用内置的 Zygisk，因为它会与 ReZygisk 冲突。这可以通过进入 Magisk 的 `设置` 部分并禁用 `Zygisk` 选项来完成。

### 3. 验证安装

重启后，你可以通过检查 root 管理器 `模块` 部分中的模块描述来验证 ReZygisk 是否正常工作。描述应指示必要的守护进程正在运行。例如，如果你的环境同时支持 64 位和 32 位，它应类似于这样：`[monitor: 😋 tracing, zygote64: 😋 injected, daemon64: 😋 running (...) zygote32: 😋 injected, daemon32: 😋 running (...)] Standalone implementation of Zygisk.`

## 翻译

目前有两种不同的方式可以为 ReZygisk 贡献翻译：

- **README 的翻译**：你可以在 `READMEs` 文件夹中创建一个新文件，遵循命名约定 `README_<语言>.md`，其中 `<语言>` 是语言代码（例如，巴西葡萄牙语为 `README_pt-BR.md`），并向 `main` 分支提交一个包含你更改的 pull request。
- **ReZygisk WebUI 的翻译**：你应该首先贡献到我们的 [Crowdin](https://crowdin.com/project/rezygisk)。一旦获得批准，请从那里检索 `.json` 文件，并提交一个包含你更改的 pull request——将 `.json` 文件添加到 `webroot/lang` 文件夹，并将你的署名按字母顺序添加到 `TRANSLATOR.md` 文件中。

## 支持

对于任何与 ReZygisk 或其他 PerformanC 项目相关的问题，欢迎随时加入以下任一频道：

- Discord 频道: [PerformanC](https://discord.gg/uPveNfTuCJ)
- ReZygisk Telegram 频道: [@rezygisk](https://t.me/rezygisk)
- PerformanC Telegram 频道: [@performancorg](https://t.me/performancorg)
- PerformanC Signal 群组: [@performanc](https://signal.group/#CjQKID3SS8N5y4lXj3VjjGxVJnzNsTIuaYZjj3i8UhipAS0gEhAedxPjT5WjbOs6FUuXptcT)

## 贡献

向 ReZygisk 做贡献必须遵循 PerformanC 的 [贡献指南](https://github.com/PerformanC/contributing)。遵守其安全策略、行为准则和语法标准。

## 许可证

ReZygisk 主要根据 Dr-TSNG 的 GPL 授权，同时 PerformanC 组织对重写的代码也采用 AGPL 3.0 授权。你可以在 [开源倡议组织 (Open Source Initiative)](https://opensource.org/licenses/AGPL-3.0) 上了解更多相关信息。

```

`TRANSLATOR.md`:

```md
# 🌎 Translators
- **ar_EG** by [@ZG089](https://github.com/ZG089)
- **de_DE** by [@Blazzycrafer](https://github.com/Blazzycrafter)
- **en_US** by [@PerformanC (The PerformanC Organization)](https://github.com/PerformanC)
- **es_AR** by [@Flopster101](https://github.com/Flopster101)
- **es_ES** by [@LuchoModzzz](https://github.com/Lxchoooo)
- **es_MX** by [@LuchoModzzz](https://github.com/Lxchoooo)
- **fr_FR** by [@GhostFRR](https://github.com/GhostFRR)
- **ja_JP** by [@Fyphen1223](https://github.com/Fyphen1223) & [@reindex-ot](https://github.com/reindex-ot) 
- **id_ID** by [@bpanca05](https://github.com/bpanca05) & [@LuckyKiddos](https://github.com/GuitarHeroStyles)
- **it_IT** by [@thasave14](https://github.com/thasave14)
- **pt_BR** by [@ThePedroo](https://github.com/ThePedroo)
- **ro_RO** by [@ExtremeXT](https://github.com/ExtremeXT)
- **ru_RU** by [@Emulond](https://github.com/Emulond) & [@AJleKcAHgP68](https://github.com/AJleKcAHgP68)
- **tr_TR** by [@witchfuneral](https://github.com/witchfuneral)
- **uk_UA** by [@Kittyskj](https://github.com/Kittyskj)
- **vi_VN** by [@RainyXeon](https://github.com/RainyXeon)
- **zh_CN** by [@Meltartica](https://github.com/Meltartica) & [@SheepChef](https://github.com/SheepChef)
- **zh_TW** by [@Meltartica](https://github.com/Meltartica)

> [!NOTE]
> Want to add your translation? Go to [Crowdin](https://crowdin.com/project/rezygisk) and translate!

```

`build.gradle.kts`:

```kts
import com.android.build.gradle.LibraryExtension
import java.io.ByteArrayOutputStream

plugins {
    alias(libs.plugins.agp.lib) apply false
}

fun String.execute(currentWorkingDir: File = file("./")): String {
    val byteOut = ByteArrayOutputStream()
    project.exec {
        workingDir = currentWorkingDir
        commandLine = split("\\s".toRegex())
        standardOutput = byteOut
    }
    return String(byteOut.toByteArray()).trim()
}

val gitCommitCount = "git rev-list HEAD --count".execute().toInt()
val gitCommitHash = "git rev-parse --verify --short HEAD".execute()

val moduleId by extra("rezygisk")
val moduleName by extra("ReZygisk")
val verName by extra("v1.0.0")
val verCode by extra(gitCommitCount)
val commitHash by extra(gitCommitHash)
val minAPatchVersion by extra(10655)
val minKsuVersion by extra(10940)
val minKsudVersion by extra(11425)
val maxKsuVersion by extra(20000)
val minMagiskVersion by extra(26402)

val androidMinSdkVersion by extra(26)
val androidTargetSdkVersion by extra(34)
val androidCompileSdkVersion by extra(34)
val androidBuildToolsVersion by extra("34.0.0")
val androidCompileNdkVersion by extra("29.0.13113456")
val androidSourceCompatibility by extra(JavaVersion.VERSION_11)
val androidTargetCompatibility by extra(JavaVersion.VERSION_11)

tasks.register("Delete", Delete::class) {
    delete(layout.buildDirectory.get())
}

fun Project.configureBaseExtension() {
    extensions.findByType(LibraryExtension::class)?.run {
        namespace = "com.performanc.org.rezygisk"
        compileSdk = androidCompileSdkVersion
        ndkVersion = androidCompileNdkVersion
        buildToolsVersion = androidBuildToolsVersion

        defaultConfig {
            minSdk = androidMinSdkVersion
        }

        lint {
            abortOnError = true
        }
    }
}

subprojects {
    plugins.withId("com.android.library") {
        configureBaseExtension()
    }
}

```

`gradle.properties`:

```properties
android.useAndroidX=false

```

`gradle/libs.versions.toml`:

```toml
[versions]
agp = "8.2.0"
kotlin = "1.9.22"

[plugins]
agp-lib = { id = "com.android.library", version.ref = "agp" }
kotlin = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
lsplugin-jgit = { id = "org.lsposed.lsplugin.jgit", version = "1.1" }
rust-android = { id = "org.mozilla.rust-android-gradle.rust-android", version = "0.9.3" }

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`loader/build.gradle.kts`:

```kts
import java.nio.file.Paths
import org.gradle.internal.os.OperatingSystem

plugins {
    alias(libs.plugins.agp.lib)
}

val verCode: Int by rootProject.extra
val verName: String by rootProject.extra
val commitHash: String by rootProject.extra

fun Project.findInPath(executable: String, property: String): String? {
    val pathEnv = System.getenv("PATH")
    return pathEnv.split(File.pathSeparator).map { folder ->
        Paths.get("${folder}${File.separator}${executable}${if (OperatingSystem.current().isWindows) ".exe" else ""}")
            .toFile()
    }.firstOrNull { path ->
        path.exists()
    }?.absolutePath ?: properties.getOrDefault(property, null) as? String?
}

val ccachePath by lazy {
    project.findInPath("ccache", "ccache.path")?.also {
        println("loader: Use ccache: $it")
    }
}

val defaultCFlags = arrayOf(
    "-D_GNU_SOURCE", "-Wall",
    "-Wextra", "-fno-rtti", "-fno-exceptions",
    "-fno-stack-protector", "-fomit-frame-pointer",
    "-Wno-builtin-macro-redefined", "-D__FILE__=__FILE_NAME__"
)

val releaseFlags = arrayOf(
    "-O3", "-ffast-math", "-flto=thin",
    "-Wno-unused", "-Wno-unused-parameter",
    "-fvisibility=hidden", "-fvisibility-inlines-hidden",
    "-fno-unwind-tables", "-fno-asynchronous-unwind-tables",
    "-Wl,--exclude-libs,ALL", "-Wl,--gc-sections", "-Wl,--strip-all"
)

android {
    buildFeatures {
        androidResources = false
        buildConfig = false
        prefab = true
    }

    externalNativeBuild.cmake {
        path("src/CMakeLists.txt")
        buildStagingDirectory = layout.buildDirectory.get().asFile
    }

    defaultConfig {
        externalNativeBuild.cmake {
            cFlags("-std=c18", *defaultCFlags)
            ccachePath?.let {
                arguments += "-DNDK_CCACHE=$it"
            }
        }
    }

    buildTypes {
        debug {
            externalNativeBuild.cmake {
                arguments += "-DZKSU_VERSION=$verName-$verCode-$commitHash-debug"
            }
        }
        release {
            externalNativeBuild.cmake {
                cFlags += releaseFlags
                cppFlags += releaseFlags
                arguments += "-DZKSU_VERSION=$verName-$verCode-$commitHash-release"
            }
        }
    }
}

```

`loader/src/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22.1)
project("loader")

set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

add_definitions(-DZKSU_VERSION=\"${ZKSU_VERSION}\")

aux_source_directory(common COMMON_SRC_LIST)
add_library(common STATIC ${COMMON_SRC_LIST})
target_include_directories(common PRIVATE include)
target_link_libraries(common log)

aux_source_directory(injector INJECTOR_SRC_LIST)
add_library(zygisk SHARED ${INJECTOR_SRC_LIST})
target_include_directories(zygisk PRIVATE include)
target_link_libraries(zygisk log common lsplt_static csoloader)

# INFO: Reduce binary size by cleaning ELF dynsym
target_link_options(zygisk PRIVATE "-nostartfiles")

aux_source_directory(ptracer PTRACER_SRC_LIST)
add_executable(libzygisk_ptrace.so ${PTRACER_SRC_LIST})
target_include_directories(libzygisk_ptrace.so PRIVATE include)
target_link_libraries(libzygisk_ptrace.so log common)
add_subdirectory(external)

```

`loader/src/common/daemon.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/socket.h>

#include <linux/un.h>

#include "logging.h"
#include "socket_utils.h"

#include "daemon.h"

int rezygiskd_connect(uint8_t retry) {
  retry++;

  int fd = socket(PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0);
  if (fd == -1) {
    PLOGE("socket create");

    return -1;
  }

  struct sockaddr_un addr = {
    .sun_family = AF_UNIX,
    .sun_path = { 0 }
  };

  /* 
    INFO: Application must assume that sun_path can hold _POSIX_PATH_MAX characters.

    Sources:
     - https://pubs.opengroup.org/onlinepubs/009696699/basedefs/sys/un.h.html
  */
  strcpy(addr.sun_path, TMP_PATH "/" SOCKET_FILE_NAME);
  socklen_t socklen = sizeof(addr);

  while (--retry) {
    int ret = connect(fd, (struct sockaddr *)&addr, socklen);
    if (ret == 0) return fd;
    if (retry) {
      PLOGE("Retrying to connect to ReZygiskd, sleep 1s");

      sleep(1);
    }
  }

  close(fd);

  return -1;
}

bool rezygiskd_zygote_injected() {
  int fd = rezygiskd_connect(5);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    return false;
  }

  write_uint8_t(fd, (uint8_t)ZygoteInjected);

  close(fd);

  return true;
}

uint32_t rezygiskd_get_process_flags(uid_t uid, const char *const process) {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    return 0;
  }

  write_uint8_t(fd, (uint8_t)GetProcessFlags);
  write_uint32_t(fd, (uint32_t)uid);
  write_string(fd, process);

  uint32_t res = 0;
  read_uint32_t(fd, &res);

  close(fd);

  return res;
}

void rezygiskd_get_info(struct rezygisk_info *info) {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    info->running = false;

    return;
  }

  info->running = true;

  write_uint8_t(fd, (uint8_t)GetInfo);

  uint32_t flags = 0;
  read_uint32_t(fd, &flags);

  if (flags & (1 << 27)) info->root_impl = ROOT_IMPL_APATCH;
  else if (flags & (1 << 29)) info->root_impl = ROOT_IMPL_KERNELSU;
  else if (flags & (1 << 30)) info->root_impl = ROOT_IMPL_MAGISK;
  else info->root_impl = ROOT_IMPL_NONE;

  read_uint32_t(fd, (uint32_t *)&info->pid);

  read_size_t(fd, &info->modules.modules_count);
  if (info->modules.modules_count == 0) {
    info->modules.modules = NULL;

    close(fd);

    return;
  }

  info->modules.modules = (char **)malloc(sizeof(char *) * info->modules.modules_count);
  if (!info->modules.modules) {
    PLOGE("allocating modules name memory");

    info->modules.modules_count = 0;

    close(fd);

    return;
  }

  for (size_t i = 0; i < info->modules.modules_count; i++) {
    char *module_name = read_string(fd);
    if (module_name == NULL) {
      PLOGE("reading module name");

      goto info_cleanup;
    }

    char module_path[PATH_MAX];
    snprintf(module_path, sizeof(module_path), "/data/adb/modules/%s/module.prop", module_name);

    free(module_name);

    FILE *module_prop = fopen(module_path, "r");
    if (!module_prop) {
      PLOGE("failed to open module prop file %s", module_path);

      goto info_cleanup;
    }

    info->modules.modules[i] = NULL;

    char line[1024];
    while (fgets(line, sizeof(line), module_prop) != NULL) {
      if (strncmp(line, "name=", strlen("name=")) != 0) continue;

      info->modules.modules[i] = strndup(line + 5, strlen(line) - 6);

      break;
    }

    if (info->modules.modules[i] == NULL) {
      PLOGE("failed to read module name from %s", module_path);

      fclose(module_prop);

      goto info_cleanup;
    }

    fclose(module_prop);

    continue;

    info_cleanup:
      info->modules.modules_count = i;
      free_rezygisk_info(info);

      break;
  }

  close(fd);
}

void free_rezygisk_info(struct rezygisk_info *info) {
  for (size_t i = 0; i < info->modules.modules_count; i++) {
    free(info->modules.modules[i]);
  }

  free(info->modules.modules);
  info->modules.modules = NULL;
}

bool rezygiskd_read_modules(struct zygisk_modules *modules) {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    return false;
  }

  write_uint8_t(fd, (uint8_t)ReadModules);

  size_t len = 0;
  read_size_t(fd, &len);

  modules->modules = malloc(len * sizeof(char *));
  if (!modules->modules) {
    PLOGE("allocating modules name memory");

    close(fd);

    return false;
  }
  modules->modules_count = len;

  for (size_t i = 0; i < len; i++) {
    char *lib_path = read_string(fd);
    if (!lib_path) {
      PLOGE("reading module lib_path");

      close(fd);

      return false;
    }

    modules->modules[i] = lib_path;
  }

  close(fd);

  return true;
}

void free_modules(struct zygisk_modules *modules) {
  for (size_t i = 0; i < modules->modules_count; i++) {
    free(modules->modules[i]);
  }

  free(modules->modules);
}

int rezygiskd_connect_companion(size_t index) {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    return -1;
  }

  write_uint8_t(fd, (uint8_t)RequestCompanionSocket);
  write_size_t(fd, index);

  uint8_t res = 0;
  read_uint8_t(fd, &res);

  if (res == 1) return fd;
  else {
    close(fd);

    return -1;
  }
}

int rezygiskd_get_module_dir(size_t index) {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    return -1;
  }

  write_uint8_t(fd, (uint8_t)GetModuleDir);
  write_size_t(fd, index);

  int dirfd = read_fd(fd);

  close(fd);

  return dirfd;
}

void rezygiskd_zygote_restart() {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    if (errno == ENOENT) LOGD("Could not notify ZygoteRestart (maybe it hasn't been created)");
    else PLOGE("Could not notify ZygoteRestart");

    return;
  }

  if (!write_uint8_t(fd, (uint8_t)ZygoteRestart))
    PLOGE("Failed to request ZygoteRestart");

  close(fd);
}

void rezygiskd_system_server_started() {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("Failed to report system server started");

    return;
  }

  if (!write_uint8_t(fd, (uint8_t)SystemServerStarted))
    PLOGE("Failed to request SystemServerStarted");

  close(fd);
}

bool rezygiskd_update_mns(enum mount_namespace_state nms_state, char *buf, size_t buf_size) {
  int fd = rezygiskd_connect(1);
  if (fd == -1) {
    PLOGE("connection to ReZygiskd");

    return false;
  }

  write_uint8_t(fd, (uint8_t)UpdateMountNamespace);
  write_uint32_t(fd, (uint32_t)getpid());
  write_uint8_t(fd, (uint8_t)nms_state);

  uint32_t target_pid = 0;
  if (read_uint32_t(fd, &target_pid) < 0) {
    PLOGE("Failed to read target pid");

    close(fd);

    return false;
  }

  uint32_t target_fd = 0;
  if (read_uint32_t(fd, &target_fd) < 0) {
    PLOGE("Failed to read target fd");

    close(fd);

    return false;
  }

  if (target_fd == 0) {
    LOGE("Failed to get target fd");

    close(fd);

    return false;
  }

  snprintf(buf, buf_size, "/proc/%u/fd/%u", target_pid, target_fd);

  close(fd);

  return true;
}

```

`loader/src/common/elf_util.c`:

```c
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/auxv.h>

#include <unistd.h>

#ifdef __LP64__
  #define LOG_TAG "zygisk-elfutil64"
#else
  #define LOG_TAG "zygisk-elfutil32"
#endif

#include "logging.h"

#include "elf_util.h"

#define SHT_GNU_HASH 0x6ffffff6

uint32_t ElfHash(const char *name) {
  uint32_t h = 0, g = 0;

  while (*name) {
    h = (h << 4) + (unsigned char)*name++;
    g = h & 0xf0000000;

    if (g) {
      h ^= g >> 24;
    }

    h &= ~g;
  }

  return h;
}

uint32_t GnuHash(const char *name) {
  uint32_t h = 5381;

  while (*name) {
    h = (h << 5) + h + (unsigned char)(*name++);
  }

  return h;
}

ElfW(Shdr) *offsetOf_Shdr(ElfW(Ehdr) *head, ElfW(Off) off) {
  return (ElfW(Shdr) *)(((uintptr_t)head) + off);
}

char *offsetOf_char(ElfW(Ehdr) *head, ElfW(Off) off) {
  return (char *)(((uintptr_t)head) + off);
}

ElfW(Sym) *offsetOf_Sym(ElfW(Ehdr) *head, ElfW(Off) off) {
  return (ElfW(Sym) *)(((uintptr_t)head) + off);
}

ElfW(Word) *offsetOf_Word(ElfW(Ehdr) *head, ElfW(Off) off) {
  return (ElfW(Word) *)(((uintptr_t)head) + off);
}

int dl_cb(struct dl_phdr_info *info, size_t size, void *data) {
  (void) size;

  if (info->dlpi_name == NULL)
    return 0;

  ElfImg *img = (ElfImg *)data;

  if (strstr(info->dlpi_name, img->elf)) {
    img->base = (void *)info->dlpi_addr;

    return 1;
  }

  return 0;
}

bool _find_module_base(ElfImg *img) {
  dl_iterate_phdr(dl_cb, img);

  return img->base != NULL;
}

size_t calculate_valid_symtabs_amount(ElfImg *img) {
  size_t count = 0;

  if (img->symtab_start == NULL || img->symstr_offset_for_symtab == 0) {
    LOGE("Invalid symtab_start or symstr_offset_for_symtab, cannot count valid symbols");

    return 0;
  }

  char *symtab_strings = offsetOf_char(img->header, img->symstr_offset_for_symtab);

  for (ElfW(Off) i = 0; i < img->symtab_count; i++) {
    const char *sym_name = symtab_strings + img->symtab_start[i].st_name;
    if (!sym_name)
      continue;

    unsigned int st_type = ELF_ST_TYPE(img->symtab_start[i].st_info);

    if ((st_type == STT_FUNC || st_type == STT_OBJECT) && img->symtab_start[i].st_size > 0 && img->symtab_start[i].st_name != 0)
      count++;
  }

  return count;
}


void ElfImg_destroy(ElfImg *img) {
  if (!img) return;

  if (img->symtabs_) {
    size_t valid_symtabs_amount = calculate_valid_symtabs_amount(img);
    if (valid_symtabs_amount > 0) {
      for (size_t i = 0; i < valid_symtabs_amount; i++) {
        free(img->symtabs_[i].name);
      }
    }

    free(img->symtabs_);
    img->symtabs_ = NULL;
  }

  if (img->elf) {
    free(img->elf);
    img->elf = NULL;
  }

  if (img->header) {
    munmap(img->header, img->size);
    img->header = NULL;
  }

  free(img);
}


ElfImg *ElfImg_create(const char *elf, void *base) {
  ElfImg *img = (ElfImg *)calloc(1, sizeof(ElfImg));
  if (!img) {
    LOGE("Failed to allocate memory for ElfImg");

    return NULL;
  }

  img->elf = strdup(elf);
  if (!img->elf) {
    LOGE("Failed to duplicate elf path string");

    free(img);

    return NULL;
  }

  if (base) {
    /* INFO: Due to the use in zygisk-ptracer, we need to allow pre-
              fetched bases to be passed, as the linker (Android 7.1
              and below) is not loaded from dlopen, which makes it not
              be visible with dl_iterate_phdr.
    */
    img->base = base;

    LOGD("Using provided base address 0x%p for %s", base, elf);
  } else {
    if (!_find_module_base(img)) {
      LOGE("Failed to find module base for %s using dl_iterate_phdr", elf);

      ElfImg_destroy(img);

      return NULL;
    }
  }

  int fd = open(elf, O_RDONLY | O_CLOEXEC);
  if (fd < 0) {
    LOGE("failed to open %s", elf);

    ElfImg_destroy(img);

    return NULL;
  }

  struct stat st;
  if (fstat(fd, &st) != 0) {
    LOGE("fstat() failed for %s", elf);

    close(fd);
    ElfImg_destroy(img);

    return NULL;
  }

  img->size = st.st_size;

  if (img->size <= sizeof(ElfW(Ehdr))) {
    LOGE("Invalid file size %zu for %s", img->size, elf);

    close(fd);
    ElfImg_destroy(img);

    return NULL;
  }

  img->header = (ElfW(Ehdr) *)mmap(NULL, img->size, PROT_READ, MAP_PRIVATE, fd, 0);

  close(fd);

  if (img->header == MAP_FAILED) {
    LOGE("mmap() failed for %s", elf);

    img->header = NULL;
    ElfImg_destroy(img);

    return NULL;
  }

  if (memcmp(img->header->e_ident, ELFMAG, SELFMAG) != 0) {
    LOGE("Invalid ELF header for %s", elf);

    ElfImg_destroy(img);

    return NULL;
  }

  if (img->header->e_shoff == 0 || img->header->e_shentsize == 0 || img->header->e_shnum == 0) {
    LOGW("Section header table missing or invalid in %s", elf);
  } else {
    img->section_header = offsetOf_Shdr(img->header, img->header->e_shoff);
  }

  if (img->header->e_phoff == 0 || img->header->e_phentsize == 0 || img->header->e_phnum == 0) {
    LOGW("Program header table missing or invalid in %s", elf);
  }

  ElfW(Shdr) *dynsym_shdr = NULL;
  ElfW(Shdr) *symtab_shdr = NULL;

  char *section_str = NULL;
  if (img->section_header && img->header->e_shstrndx != SHN_UNDEF) {
    if (img->header->e_shstrndx < img->header->e_shnum) {
      ElfW(Shdr) *shstrtab_hdr = img->section_header + img->header->e_shstrndx;
      section_str = offsetOf_char(img->header, shstrtab_hdr->sh_offset);
    } else {
      LOGW("Section header string table index (%u) out of bounds (%u)", img->header->e_shstrndx, img->header->e_shnum);
    }
  } else {
    LOGW("Section header string table index not set or no section headers");
  }

  if (img->section_header) {
    uintptr_t shoff = (uintptr_t)img->section_header;
    for (int i = 0; i < img->header->e_shnum; i++, shoff += img->header->e_shentsize) {
      ElfW(Shdr) *section_h = (ElfW(Shdr *))shoff;
      char *sname = section_str ? (section_h->sh_name + section_str) : "<?>";
      size_t entsize = section_h->sh_entsize;

      switch (section_h->sh_type) {
        case SHT_DYNSYM: {
          dynsym_shdr = section_h;
          img->dynsym_offset = section_h->sh_offset;
          img->dynsym_start = offsetOf_Sym(img->header, img->dynsym_offset);

          break;
        }
        case SHT_SYMTAB: {
          if (strcmp(sname, ".symtab") == 0) {
            symtab_shdr = section_h;
            img->symtab_offset = section_h->sh_offset;
            img->symtab_size = section_h->sh_size;

            if (entsize > 0) img->symtab_count = img->symtab_size / entsize;
            else {
              LOGW("Section %s has zero sh_entsize", sname);
              img->symtab_count = 0;
            }

            img->symtab_start = offsetOf_Sym(img->header, img->symtab_offset);
          }

          break;
        }
        case SHT_STRTAB: break;
        case SHT_PROGBITS: break;
        case SHT_HASH: {
          ElfW(Word) *d_un = offsetOf_Word(img->header, section_h->sh_offset);

          if (section_h->sh_size >= 2 * sizeof(ElfW(Word))) {
            img->nbucket_ = d_un[0];

            if (img->nbucket_ > 0 && section_h->sh_size >= (2 + img->nbucket_ + d_un[1]) * sizeof(ElfW(Word))) {
              img->bucket_ = d_un + 2;
              img->chain_ = img->bucket_ + img->nbucket_;
            } else {
              LOGW("Invalid SHT_HASH size or nbucket count in section %s", sname);
              img->nbucket_ = 0;
            }
          } else {
            LOGW("SHT_HASH section %s too small", sname);
          }

          break;
        }
        case SHT_GNU_HASH: {
          ElfW(Word) *d_buf = offsetOf_Word(img->header, section_h->sh_offset);

          if (section_h->sh_size >= 4 * sizeof(ElfW(Word))) {
            img->gnu_nbucket_ = d_buf[0];
            img->gnu_symndx_ = d_buf[1];
            img->gnu_bloom_size_ = d_buf[2];
            img->gnu_shift2_ = d_buf[3];

            size_t expected_min_size = 4 * sizeof(ElfW(Word)) +
                                      img->gnu_bloom_size_ * sizeof(uintptr_t) +
                                      img->gnu_nbucket_ * sizeof(uint32_t);

            if (img->gnu_nbucket_ > 0 && img->gnu_bloom_size_ > 0 && section_h->sh_size >= expected_min_size) {
              img->gnu_bloom_filter_ = (uintptr_t *)(d_buf + 4);
              img->gnu_bucket_ = (uint32_t *)(img->gnu_bloom_filter_ + img->gnu_bloom_size_);
              img->gnu_chain_ = img->gnu_bucket_ + img->gnu_nbucket_;

              uintptr_t chain_start_offset = (uintptr_t)img->gnu_chain_ - (uintptr_t)img->header;
              if (chain_start_offset < section_h->sh_offset || chain_start_offset >= section_h->sh_offset + section_h->sh_size) {
                LOGW("Calculated GNU hash chain seems out of bounds for section %s", sname);

                img->gnu_nbucket_ = 0;
              }
            } else {
              LOGW("Invalid SHT_GNU_HASH size or parameters in section %s", sname);

              img->gnu_nbucket_ = 0;
            }
          } else {
            LOGW("SHT_GNU_HASH section %s too small", sname);
          }

          break;
        }
      }
    }
  }

  ElfW(Shdr) *shdr_base = img->section_header;

  if (dynsym_shdr && shdr_base) {
    img->dynsym = dynsym_shdr;

    if (dynsym_shdr->sh_link < img->header->e_shnum) {
      ElfW(Shdr) *linked_strtab = shdr_base + dynsym_shdr->sh_link;

      if (linked_strtab->sh_type == SHT_STRTAB) {
        img->strtab = linked_strtab;
        img->symstr_offset = linked_strtab->sh_offset;
        img->strtab_start = (void *)offsetOf_char(img->header, img->symstr_offset);
      } else {
        LOGW("Section %u linked by .dynsym is not SHT_STRTAB (type %u)", dynsym_shdr->sh_link, linked_strtab->sh_type);
      }
    } else {
      LOGE(".dynsym sh_link (%u) is out of bounds (%u)", dynsym_shdr->sh_link, img->header->e_shnum);
    }
  } else {
    LOGW("No .dynsym section found or section headers missing");
  }

  if (symtab_shdr && shdr_base) {
    img->symtab = symtab_shdr;

    if (symtab_shdr->sh_link < img->header->e_shnum) {
      ElfW(Shdr) *linked_strtab = shdr_base + symtab_shdr->sh_link;

      if (linked_strtab->sh_type == SHT_STRTAB) {
        /* INFO: For linear lookup */
        img->symstr_offset_for_symtab = linked_strtab->sh_offset;
      } else {
        LOGW("Section %u linked by .symtab is not SHT_STRTAB (type %u)", symtab_shdr->sh_link, linked_strtab->sh_type);

        img->symstr_offset_for_symtab = 0;
      }
    } else {
      LOGE(".symtab sh_link (%u) is out of bounds (%u)", symtab_shdr->sh_link, img->header->e_shnum);

      img->symstr_offset_for_symtab = 0;
    }
  } else {
    LOGD("No .symtab section found or section headers missing");

    img->symtab_start = NULL;
    img->symtab_count = 0;
    img->symstr_offset_for_symtab = 0;
  }

  bool bias_calculated = false;
  if (img->header->e_phoff > 0 && img->header->e_phnum > 0) {
    ElfW(Phdr) *phdr = (ElfW(Phdr) *)((uintptr_t)img->header + img->header->e_phoff);

    for (int i = 0; i < img->header->e_phnum; ++i) {
      if (phdr[i].p_type == PT_LOAD && phdr[i].p_offset == 0) {
        img->bias = phdr[i].p_vaddr - phdr[i].p_offset;
        bias_calculated = true;

        LOGD("Calculated bias %ld from PT_LOAD segment %d (vaddr %lx)", (long)img->bias, i, (unsigned long)phdr[i].p_vaddr);

        break;
      }
    }

    if (!bias_calculated) for (int i = 0; i < img->header->e_phnum; ++i) {
      if (phdr[i].p_type != PT_LOAD) continue;

      img->bias = phdr[i].p_vaddr - phdr[i].p_offset;
      bias_calculated = true;

      LOGD("Calculated bias %ld from first PT_LOAD segment %d (vaddr %lx, offset %lx)",
          (long)img->bias, i, (unsigned long)phdr[i].p_vaddr, (unsigned long)phdr[i].p_offset);

      break;
    }
  }

  if (!bias_calculated)
    LOGE("Failed to calculate bias for %s. Assuming bias is 0.", elf);

  if (!img->dynsym_start || !img->strtab_start) {
    if (img->header->e_type == ET_DYN) LOGE("Failed to find .dynsym or its string table (.dynstr) in %s", elf);
    else LOGW("No .dynsym or .dynstr found in %s (might be expected for ET_EXEC)", elf);
  }

  if (!img->gnu_bucket_ && !img->bucket_)
    LOGW("No hash table (.gnu.hash or .hash) found in %s. Dynamic symbol lookup might be slow or fail.", elf);

  return img;
}

bool _load_symtabs(ElfImg *img) {
  if (img->symtabs_) return true;

  if (!img->symtab_start || img->symstr_offset_for_symtab == 0 || img->symtab_count == 0) {
    LOGE("Cannot load symtabs: .symtab section or its string table not found/valid.");

    return false;
  }

  size_t valid_symtabs_amount = calculate_valid_symtabs_amount(img);
  if (valid_symtabs_amount == 0) {
    LOGW("No valid symbols (FUNC/OBJECT with size > 0) found in .symtab for %s", img->elf);

    return false;
  }

  img->symtabs_ = (struct symtabs *)calloc(valid_symtabs_amount, sizeof(struct symtabs));
  if (!img->symtabs_) {
    LOGE("Failed to allocate memory for symtabs array");

    return false;
  }

  char *symtab_strings = offsetOf_char(img->header, img->symstr_offset_for_symtab);
  size_t current_valid_index = 0;

  for (ElfW(Off) pos = 0; pos < img->symtab_count; pos++) {
    ElfW(Sym) *current_sym = &img->symtab_start[pos];
    unsigned int st_type = ELF_ST_TYPE(current_sym->st_info);

    if ((st_type == STT_FUNC || st_type == STT_OBJECT) && current_sym->st_size > 0 && current_sym->st_name != 0) {
      const char *st_name = symtab_strings + current_sym->st_name;
      if (!st_name)
        continue;

      ElfW(Shdr) *symtab_str_shdr = img->section_header + img->symtab->sh_link;
      if (current_sym->st_name >= symtab_str_shdr->sh_size) {
        LOGE("Symbol name offset out of bounds");

        continue;
      }

      img->symtabs_[current_valid_index].name = strdup(st_name);
      if (!img->symtabs_[current_valid_index].name) {
        LOGE("Failed to duplicate symbol name: %s", st_name);

        for(size_t k = 0; k < current_valid_index; ++k) {
          free(img->symtabs_[k].name);
        }

        free(img->symtabs_);
        img->symtabs_ = NULL;

        return false;
      }

      img->symtabs_[current_valid_index].sym = current_sym;

      current_valid_index++;
      if (current_valid_index == valid_symtabs_amount) break;
    }
  }

  return true;
}

ElfW(Addr) GnuLookup(ElfImg *restrict img, const char *name, uint32_t hash, unsigned char *sym_type) {
  if (img->gnu_nbucket_ == 0 || img->gnu_bloom_size_ == 0 || !img->gnu_bloom_filter_ || !img->gnu_bucket_ || !img->gnu_chain_ || !img->dynsym_start || !img->strtab_start)
    return 0;

  static const size_t bloom_mask_bits = sizeof(uintptr_t) * 8;

  size_t bloom_idx = (hash / bloom_mask_bits) % img->gnu_bloom_size_;
  uintptr_t bloom_word = img->gnu_bloom_filter_[bloom_idx];
  uintptr_t mask = ((uintptr_t)1 << (hash % bloom_mask_bits)) |
                   ((uintptr_t)1 << ((hash >> img->gnu_shift2_) % bloom_mask_bits));

  if ((mask & bloom_word) != mask) {
    /* INFO: Very loggy -- generates too much noise. GNU is rarely used for Zygisk context. */
    /* LOGW("Symbol '%s' (hash %u) filtered out by GNU Bloom Filter (idx %zu, mask 0x%lx, word 0x%lx)",
           name, hash, bloom_idx, (unsigned long)mask, (unsigned long)bloom_word);
    */

    return 0;
  }

  uint32_t sym_index = img->gnu_bucket_[hash % img->gnu_nbucket_];
  if (sym_index < img->gnu_symndx_) {
    LOGW("Symbol %s hash %u maps to bucket %u index %u (below gnu_symndx %u), not exported?", name, hash, hash % img->gnu_nbucket_, sym_index, img->gnu_symndx_);

    return 0;
  }

  char *strings = (char *)img->strtab_start;
  uint32_t chain_val = img->gnu_chain_[sym_index - img->gnu_symndx_];

  ElfW(Word) dynsym_count = img->dynsym->sh_size / img->dynsym->sh_entsize;
  if (sym_index >= dynsym_count) {
    LOGE("Symbol index %u out of bounds", sym_index);

    return 0;
  }

  ElfW(Sym) *sym = img->dynsym_start + sym_index;

  if (sym->st_name >= img->strtab->sh_size) {
    LOGE("Symbol name offset %u out of bounds", sym->st_name);

    return 0;
  }

  if ((((chain_val ^ hash) >> 1) == 0 && strcmp(name, strings + sym->st_name) == 0) && sym->st_shndx != SHN_UNDEF) {
    unsigned int type = ELF_ST_TYPE(sym->st_info);
    if (sym_type) *sym_type = type;

    return sym->st_value;
  }

  while ((chain_val & 1) == 0) {
    sym_index++;

    if (sym_index >= dynsym_count) {
      LOGE("Symbol index %u out of bounds during chain walk", sym_index);

      return 0;
    }

    chain_val = img->gnu_chain_[sym_index - img->gnu_symndx_];
    sym = img->dynsym_start + sym_index;

    if (sym->st_name >= img->strtab->sh_size) {
      LOGE("Symbol name offset %u out of bounds", sym->st_name);

      break;
    }

    if ((((chain_val ^ hash) >> 1) == 0 && strcmp(name, strings + sym->st_name) == 0) && sym->st_shndx != SHN_UNDEF) {
      unsigned int type = ELF_ST_TYPE(sym->st_info);
      if (sym_type) *sym_type = type;

      return sym->st_value;
    }
  }

  return 0;
}

ElfW(Addr) ElfLookup(ElfImg *restrict img, const char *restrict name, uint32_t hash, unsigned char *sym_type) {
  if (img->nbucket_ == 0 || !img->bucket_ || !img->chain_ || !img->dynsym_start || !img->strtab_start)
    return 0;

  char *strings = (char *)img->strtab_start;

  for (size_t n = img->bucket_[hash % img->nbucket_]; n != STN_UNDEF; n = img->chain_[n]) {
    ElfW(Sym) *sym = img->dynsym_start + n;

    if (strcmp(name, strings + sym->st_name) == 0 && sym->st_shndx != SHN_UNDEF) {
      unsigned int type = ELF_ST_TYPE(sym->st_info);
      if (sym_type) *sym_type = type;

      return sym->st_value;
    }
  }

  return 0;
}

ElfW(Addr) LinearLookup(ElfImg *img, const char *restrict name, unsigned char *sym_type) {
  if (!_load_symtabs(img)) {
    LOGE("Failed to load symtabs for linear lookup of %s", name);

    return 0;
  }

  size_t valid_symtabs_amount = calculate_valid_symtabs_amount(img);
  if (valid_symtabs_amount == 0) {
    LOGW("No valid symbols (FUNC/OBJECT with size > 0) found in .symtab for %s", img->elf);

    return 0;
  }

  for (size_t i = 0; i < valid_symtabs_amount; i++) {
    if (!img->symtabs_[i].name || strcmp(name, img->symtabs_[i].name) != 0)
      continue;

    if (img->symtabs_[i].sym->st_shndx == SHN_UNDEF)
      continue;

    unsigned int type = ELF_ST_TYPE(img->symtabs_[i].sym->st_info);
    if (sym_type) *sym_type = type;

    return img->symtabs_[i].sym->st_value;
  }

  return 0;
}

ElfW(Addr) LinearLookupByPrefix(ElfImg *img, const char *prefix, unsigned char *sym_type) {
  if (!_load_symtabs(img)) {
    LOGE("Failed to load symtabs for linear lookup by prefix of %s", prefix);

    return 0;
  }

  size_t valid_symtabs_amount = calculate_valid_symtabs_amount(img);
  if (valid_symtabs_amount == 0) {
    LOGW("No valid symbols (FUNC/OBJECT with size > 0) found in .symtab for %s", img->elf);

    return 0;
  }

  size_t prefix_len = strlen(prefix);
  if (prefix_len == 0) return 0;

  for (size_t i = 0; i < valid_symtabs_amount; i++) {
    if (!img->symtabs_[i].name || strlen(img->symtabs_[i].name) < prefix_len)
      continue;

    if (strncmp(img->symtabs_[i].name, prefix, prefix_len) != 0)
      continue;

    if (img->symtabs_[i].sym->st_shndx == SHN_UNDEF)
      continue;

    unsigned int type = ELF_ST_TYPE(img->symtabs_[i].sym->st_info);
    if (sym_type) *sym_type = type;

    return img->symtabs_[i].sym->st_value;
  }

  return 0;
}

ElfW(Addr) getSymbOffset(ElfImg *img, const char *name, unsigned char *sym_type) {
  ElfW(Addr) offset = 0;

  offset = GnuLookup(img, name, GnuHash(name), sym_type);
  if (offset != 0) return offset;

  offset = ElfLookup(img, name, ElfHash(name), sym_type);
  if (offset != 0) return offset;

  offset = LinearLookup(img, name, sym_type);
  if (offset != 0) return offset;

  return 0;
}

#ifdef __aarch64__
  /* INFO: Struct containing information about hardware capabilities used in resolver. This
             struct information is pulled directly from the AOSP code.

     SOURCES:
      - https://android.googlesource.com/platform/bionic/+/refs/tags/android-16.0.0_r1/libc/include/sys/ifunc.h#53
  */
  struct __ifunc_arg_t {
    unsigned long _size;
    unsigned long _hwcap;
    unsigned long _hwcap2;
  };

  /* INFO: This is a constant used in the AOSP code to indicate that the struct __ifunc_arg_t
             contains hardware capabilities.

     SOURCES:
      - https://android.googlesource.com/platform/bionic/+/refs/tags/android-16.0.0_r1/libc/include/sys/ifunc.h#74
  */
  #define _IFUNC_ARG_HWCAP (1ULL << 62)
#elif defined(__riscv)
  /* INFO: Struct used in Linux RISC-V architecture to probe hardware capabilities.

     SOURCES:
      - https://android.googlesource.com/platform/bionic/+/refs/tags/android-16.0.0_r1/libc/kernel/uapi/asm-riscv/asm/hwprobe.h#10
  */
  struct riscv_hwprobe {
    int64_t key;
    uint64_t value;
  };

  /* INFO: This function is used in the AOSP code to probe hardware capabilities on RISC-V architecture
             by calling the syscall __NR_riscv_hwprobe and passing the parameters that will filled with
             the device hardware capabilities.

     SOURCES:
      - https://android.googlesource.com/platform/bionic/+/refs/tags/android-16.0.0_r1/libc/bionic/vdso.cpp#86
  */
  int __riscv_hwprobe(struct riscv_hwprobe *pairs, size_t pair_count, size_t cpu_count, unsigned long *cpus, unsigned flags) {
    register long a0 __asm__("a0") = (long)pairs;
    register long a1 __asm__("a1") = pair_count;
    register long a2 __asm__("a2") = cpu_count;
    register long a3 __asm__("a3") = (long)cpus;
    register long a4 __asm__("a4") = flags;
    register long a7 __asm__("a7") = __NR_riscv_hwprobe;

    __asm__ volatile(
      "ecall"
      : "=r"(a0)
      : "r"(a0), "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a7)
    );

    return -a0;
  }

  /* INFO: This is a function pointer type that points how the signature of the __riscv_hwprobe
             function is.

     SOURCES:
      - https://android.googlesource.com/platform/bionic/+/refs/tags/android-16.0.0_r1/libc/include/sys/hwprobe.h#62
  */
  typedef int (*__riscv_hwprobe_t)(struct riscv_hwprobe *__pairs, size_t __pair_count, size_t __cpu_count, unsigned long *__cpus, unsigned __flags);
#endif

/* INFO: GNU ifuncs (indirect functions) are functions that does not execute the code by itself,
           but instead lead to other functions that may very according to hardware capabilities,
           or other reasons, depending of the architecture.

         This function is based on AOSP's (Android Open Source Project) code, and resolves the
           indirect symbol, leading to the correct, most appropriate for the hardware, symbol.

    SOURCES: 
     - https://android.googlesource.com/platform/bionic/+/refs/tags/android-16.0.0_r1/linker/linker.cpp#2594
     - https://android.googlesource.com/platform/bionic/+/tags/android-16.0.0_r1/libc/bionic/bionic_call_ifunc_resolver.cpp#41
*/
static ElfW(Addr) handle_indirect_symbol(ElfImg *img, ElfW(Off) offset) {
  ElfW(Addr) resolver_addr = (ElfW(Addr))((uintptr_t)img->base + offset - img->bias);

  #ifdef __aarch64__
    typedef ElfW(Addr) (*ifunc_resolver_t)(uint64_t, struct __ifunc_arg_t *);

    struct __ifunc_arg_t args = {
      ._size = sizeof(struct __ifunc_arg_t),
      ._hwcap = getauxval(AT_HWCAP),
      ._hwcap2 = getauxval(AT_HWCAP2)
    };

    return ((ifunc_resolver_t)resolver_addr)(args._hwcap | _IFUNC_ARG_HWCAP, &args);
  #elif defined(__arm__)
      typedef ElfW(Addr) (*ifunc_resolver_t)(unsigned long);

      return ((ifunc_resolver_t)resolver_addr)(getauxval(AT_HWCAP));
  #elif defined(__riscv)
    typedef ElfW(Addr) (*ifunc_resolver_t)(uint64_t, __riscv_hwprobe_t, void *);

    return ((ifunc_resolver_t)resolver_addr)(getauxval(AT_HWCAP), __riscv_hwprobe, NULL);
  #else
    typedef ElfW(Addr) (*ifunc_resolver_t)(void);

    return ((ifunc_resolver_t)resolver_addr)();
  #endif
}

ElfW(Addr) getSymbAddress(ElfImg *img, const char *name) {
  unsigned char sym_type = 0;
  ElfW(Addr) offset = getSymbOffset(img, name, &sym_type);

  if (offset == 0 || !img->base) return 0;

  if (sym_type == STT_GNU_IFUNC) {
    LOGD("Resolving STT_GNU_IFUNC symbol %s", name);

    return handle_indirect_symbol(img, offset);
  }

  return (ElfW(Addr))((uintptr_t)img->base + offset - img->bias);
}

ElfW(Addr) getSymbAddressByPrefix(ElfImg *img, const char *prefix) {
  unsigned char sym_type = 0;
  ElfW(Addr) offset = LinearLookupByPrefix(img, prefix, &sym_type);

  if (offset == 0 || !img->base) return 0;

  if (sym_type == STT_GNU_IFUNC) {
    LOGD("Resolving STT_GNU_IFUNC symbol by prefix %s", prefix);

    return handle_indirect_symbol(img, offset);
  }

  return (ElfW(Addr))((uintptr_t)img->base + offset - img->bias);
}

void *getSymbValueByPrefix(ElfImg *img, const char *prefix) {
  ElfW(Addr) address = getSymbAddressByPrefix(img, prefix);

  return address == 0 ? NULL : *((void **)address);
}

```

`loader/src/common/misc.c`:

```c
#include <stdio.h>
#include <sys/utsname.h>

#include "logging.h"

#include "misc.h"

int parse_int(const char *str) {
  int val = 0;

  char *c = (char *)str;
  while (*c) {
    if (*c > '9' || *c < '0')
      return -1;

    val = val * 10 + *c - '0';
    c++;
  }

  return val;
}

struct kernel_version parse_kversion() {
  struct utsname uts;
  if (uname(&uts) == -1) {
    PLOGE("uname");

    return (struct kernel_version) { 0 };
  }

  struct kernel_version version;
  sscanf(uts.release, "%hhu.%u.%u", &version.major, &version.minor, &version.patch);

  return version;
}

```

`loader/src/common/socket_utils.c`:

```c
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>

#include <unistd.h>

#include "logging.h"

#include "socket_utils.h"

ssize_t write_loop(int fd, const void *buf, size_t count) {
  ssize_t written = 0;
  while (written < (ssize_t)count) {
    ssize_t ret = write(fd, (const char *)buf + written, count - written);
    if (ret == -1) {
      if (errno == EINTR || errno == EAGAIN) continue;

      PLOGE("write");
    }

    if (ret == 0) {
      LOGE("write: 0 bytes written");

      return -1;
    }

    written += ret;
  }

  return written;
}

ssize_t read_loop_offset(int fd, void *buf, size_t count, off_t off) {
  if (off < 0) {
    LOGE("read_loop_offset: negative offset: %lld", (long long)off);

    return -1;
  }

  ssize_t read_bytes = 0;
  while (read_bytes < (ssize_t)count) {
    size_t remaining = count - (size_t)read_bytes;
    char *dst = (char *)buf + read_bytes;
    ssize_t ret = pread(fd, dst, remaining, off + read_bytes);
    if (ret == -1) {
      if (errno == EINTR || errno == EAGAIN) continue;

      PLOGE("read");

      return -1;
    }

    if (ret == 0) {
      LOGE("read: 0 bytes read");

      return -1;
    }

    read_bytes += ret;
  }

  return read_bytes;
}

ssize_t read_loop(int fd, void *buf, size_t count) {
  ssize_t read_bytes = 0;
  while (read_bytes < (ssize_t)count) {
    size_t remaining = count - (size_t)read_bytes;
    char *dst = (char *)buf + read_bytes;
    ssize_t ret = read(fd, dst, remaining);
    if (ret == -1) {
      if (errno == EINTR || errno == EAGAIN) continue;

      PLOGE("read");

      return -1;
    }

    if (ret == 0) {
      LOGE("read: 0 bytes read");

      return -1;
    }

    read_bytes += ret;
  }

  return read_bytes;
}

/* TODO: Standardize how to log errors */
int read_fd(int fd) {
  char cmsgbuf[CMSG_SPACE(sizeof(int))];

  int cnt = 1;
  struct iovec iov = {
    .iov_base = &cnt,
    .iov_len = sizeof(cnt)
  };

  struct msghdr msg = {
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = cmsgbuf,
    .msg_controllen = sizeof(cmsgbuf)
  };

  ssize_t ret = TEMP_FAILURE_RETRY(recvmsg(fd, &msg, MSG_WAITALL));
  if (ret == -1) {
    PLOGE("recvmsg");

    return -1;
  }

  struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
  if (cmsg == NULL) {
    PLOGE("CMSG_FIRSTHDR");

    return -1;
  }

  int sendfd;
  memcpy(&sendfd, CMSG_DATA(cmsg), sizeof(int));

  return sendfd;
}

ssize_t write_string(int fd, const char *str) {
  size_t str_len = strlen(str);
  ssize_t write_bytes = write_loop(fd, &str_len, sizeof(size_t));
  if (write_bytes != (ssize_t)sizeof(size_t)) {
    LOGE("Failed to write string length: Not all bytes were written (%zd != %zu).\n", write_bytes, sizeof(size_t));

    return -1;
  }

  write_bytes = write_loop(fd, str, str_len);
  if (write_bytes != (ssize_t)str_len) {
    LOGE("Failed to write string: Promised bytes doesn't exist (%zd != %zu).\n", write_bytes, str_len);

    return -1;
  }

  return write_bytes;
}

char *read_string(int fd) {
  size_t str_len = 0;
  ssize_t read_bytes = read_loop(fd, &str_len, sizeof(size_t));
  if (read_bytes != (ssize_t)sizeof(size_t)) {
    LOGE("Failed to read string length: Not all bytes were read (%zd != %zu).\n", read_bytes, sizeof(size_t));

    return NULL;
  }

  char *buf = malloc(str_len + 1);
  if (buf == NULL) {
    PLOGE("allocate memory for string");

    return NULL;
  }

  read_bytes = read_loop(fd, buf, str_len);
  if (read_bytes != (ssize_t)str_len) {
    LOGE("Failed to read string: Promised bytes doesn't exist (%zd != %zu).\n", read_bytes, str_len);

    free(buf);

    return NULL;
  }

  if (str_len > 0) buf[str_len] = '\0';

  return buf;
}

#define write_func(type)                       \
  ssize_t write_## type(int fd, type val) {    \
    return write_loop(fd, &val, sizeof(type)); \
  }

#define read_func(type)                      \
  ssize_t read_## type(int fd, type *val) {  \
    return read_loop(fd, val, sizeof(type)); \
  }

write_func(uint8_t)
read_func(uint8_t)

write_func(uint32_t)
read_func(uint32_t)

write_func(size_t)
read_func(size_t)

```

`loader/src/external/CMakeLists.txt`:

```txt
project(external)

OPTION(LSPLT_BUILD_SHARED OFF)
add_subdirectory(lsplt/lsplt/src/main/jni)
add_subdirectory(csoloader)
```

`loader/src/include/daemon.h`:

```h
#ifndef DAEMON_H
#define DAEMON_H

#include <stdbool.h>

#include <unistd.h>

#ifdef __LP64__
  #define LP_SELECT(lp32, lp64) lp64
#else
  #define LP_SELECT(lp32, lp64) lp32
#endif

#define SOCKET_FILE_NAME LP_SELECT("cp32", "cp64") ".sock"

enum rezygiskd_actions {
  ZygoteInjected,
  GetProcessFlags,
  GetInfo,
  ReadModules,
  RequestCompanionSocket,
  GetModuleDir,
  ZygoteRestart,
  SystemServerStarted,
  UpdateMountNamespace
};

struct zygisk_modules {
  char **modules;
  size_t modules_count;
};

enum root_impl {
  ROOT_IMPL_NONE,
  ROOT_IMPL_APATCH,
  ROOT_IMPL_KERNELSU,
  ROOT_IMPL_MAGISK
};

struct rezygisk_info {
  struct zygisk_modules modules;
  enum root_impl root_impl;
  pid_t pid;
  bool running;
};

enum mount_namespace_state {
  Clean,
  Mounted
};

#define TMP_PATH "/data/adb/rezygisk"

static inline const char *rezygiskd_get_path() {
  return TMP_PATH;
}

int rezygiskd_connect(uint8_t retry);

bool rezygiskd_zygote_injected();

uint32_t rezygiskd_get_process_flags(uid_t uid, const char *const process);

void rezygiskd_get_info(struct rezygisk_info *info);

void free_rezygisk_info(struct rezygisk_info *info);

bool rezygiskd_read_modules(struct zygisk_modules *modules);

void free_modules(struct zygisk_modules *modules);

int rezygiskd_connect_companion(size_t index);

int rezygiskd_get_module_dir(size_t index);

void rezygiskd_zygote_restart();

void rezygiskd_system_server_started();

bool rezygiskd_update_mns(enum mount_namespace_state nms_state, char *buf, size_t buf_size);

#endif /* DAEMON_H */
```

`loader/src/include/elf_util.h`:

```h
#ifndef ELF_UTIL_H
#define ELF_UTIL_H

#include <stdbool.h>
#include <string.h>
#include <link.h>
#include <sys/types.h>
#include <pthread.h>

#define SHT_GNU_HASH 0x6ffffff6

typedef void (*linker_simple_func_t)(void);
typedef void (*linker_ctor_function_t)(int, char **, char **);
typedef void (*linker_dtor_function_t)(void);


struct symtabs {
  char *name;
  ElfW(Sym) *sym;
};

typedef struct {
  char *elf;
  void *base;
  ElfW(Ehdr) *header;
  size_t size;
  off_t bias;
  ElfW(Shdr) *section_header;

  ElfW(Shdr) *dynsym;
  ElfW(Off) dynsym_offset;
  ElfW(Sym) *dynsym_start;
  ElfW(Shdr) *strtab;
  ElfW(Off) symstr_offset;
  void *strtab_start;

  uint32_t nbucket_;
  uint32_t *bucket_;
  uint32_t *chain_;

  uint32_t gnu_nbucket_;
  uint32_t gnu_symndx_;
  uint32_t gnu_bloom_size_;
  uint32_t gnu_shift2_;
  uintptr_t *gnu_bloom_filter_;
  uint32_t *gnu_bucket_;
  uint32_t *gnu_chain_;

  ElfW(Shdr) *symtab;
  ElfW(Off) symtab_offset;
  size_t symtab_size;
  size_t symtab_count;
  ElfW(Sym) *symtab_start;
  ElfW(Off) symstr_offset_for_symtab;

  struct symtabs *symtabs_;
} ElfImg;

void ElfImg_destroy(ElfImg *img);

ElfImg *ElfImg_create(const char *elf, void *base);

ElfW(Addr) getSymbOffset(ElfImg *img, const char *name, unsigned char *sym_type);

ElfW(Addr) getSymbAddress(ElfImg *img, const char *name);

ElfW(Addr) getSymbAddressByPrefix(ElfImg *img, const char *prefix);

void *getSymbValueByPrefix(ElfImg *img, const char *prefix);

#endif /* ELF_UTIL_H */

```

`loader/src/include/logging.h`:

```h
#ifndef LOGGING_H
#define LOGGING_H

#include <android/log.h>
#include <errno.h>
#include <string.h>

#ifndef LOG_TAG
  #ifdef __LP64__
    #define LOG_TAG "zygisk-core64"
  #else
    #define LOG_TAG "zygisk-core32"
  #endif
#endif

#ifndef NDEBUG
  #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
  #define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#else
  #define LOGD(...)
  #define LOGV(...)
#endif

#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)
#define PLOGE(fmt, args...) LOGE(fmt " failed with %d: %s", ##args, errno, strerror(errno))

#endif /* LOGGING_H */
```

`loader/src/include/misc.h`:

```h
#ifndef MISC_H
#define MISC_H

#include <inttypes.h>

#define IS_ISOLATED_SERVICE(uid)      \
  ((uid) >= 90000 && (uid) < 1000000)

struct kernel_version {
  uint8_t major;
  unsigned int minor;
  unsigned int patch;
};

int parse_int(const char *str);

struct kernel_version parse_kversion();

#endif /* MISC_H */
```

`loader/src/include/socket_utils.h`:

```h
#ifndef SOCKET_UTILS_H
#define SOCKET_UTILS_H

#include <stdint.h>

ssize_t write_loop(int fd, const void *buf, size_t count);

ssize_t read_loop_offset(int fd, void *buf, size_t len, off_t off);

ssize_t read_loop(int fd, void *buf, size_t len);

int read_fd(int fd);

ssize_t write_string(int fd, const char *str);
  
char *read_string(int fd);

#define write_func_def(type)              \
  ssize_t write_## type(int fd, type val)

#define read_func_def(type)               \
  ssize_t read_## type(int fd, type *val)

write_func_def(uint8_t);
read_func_def(uint8_t);

write_func_def(uint32_t);
read_func_def(uint32_t);

write_func_def(size_t);
read_func_def(size_t);

#endif /* SOCKET_UTILS_H */
```

`loader/src/injector/art_method.h`:

```h
#ifndef ART_METHOD_H
#define ART_METHOD_H

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include <jni.h>

#include "logging.h"

static jfieldID art_method_field = NULL;
static size_t art_method_size = 0;
static size_t entry_point_offset = 0;
static size_t data_offset = 0;

static inline void *amethod_from_reflected_method(JNIEnv *env, jobject method);

/*
  INFO: Inlining these methods to ensure multiple definitions, avoiding ODR violations.
          Check module.h for more info.

  SOURCES:
   - https://clang.llvm.org/extra/clang-tidy/checks/misc/definitions-in-headers.html
*/

static inline bool amethod_init(JNIEnv *env) {
  jclass clazz = (*env)->FindClass(env, "java/lang/reflect/Executable");
  if (!clazz) {
    LOGE("Failed to found Executable");

    return false;
  }

  art_method_field = (*env)->GetFieldID(env, clazz, "artMethod", "J");
  if (!art_method_field) {
    LOGE("Failed to find artMethod field");

    (*env)->DeleteLocalRef(env, clazz);

    return false;
  }

  jclass throwable = (*env)->FindClass(env, "java/lang/Throwable");
  if (!throwable) {
    LOGE("Failed to found Throwable");

    (*env)->DeleteLocalRef(env, clazz);

    return false;
  }

  jclass clz = (*env)->FindClass(env, "java/lang/Class");
  if (!clz) {
    LOGE("Failed to found Class");

    (*env)->DeleteLocalRef(env, clazz);
    (*env)->DeleteLocalRef(env, throwable);

    return false;
  }

  jmethodID get_declared_constructors = (*env)->GetMethodID(env, clz, "getDeclaredConstructors", "()[Ljava/lang/reflect/Constructor;");
  (*env)->DeleteLocalRef(env, clz);

  jobjectArray constructors = (jobjectArray)(*env)->CallObjectMethod(env, throwable, get_declared_constructors);
  (*env)->DeleteLocalRef(env, throwable);
  if (!constructors || (*env)->GetArrayLength(env, constructors) < 2) {
    LOGE("Throwable has less than 2 constructors");

    (*env)->DeleteLocalRef(env, clazz);

    return false;
  }

  jobject first_ctor = (*env)->GetObjectArrayElement(env, constructors, 0);
  jobject second_ctor = (*env)->GetObjectArrayElement(env, constructors, 1);

  uintptr_t first = (uintptr_t)amethod_from_reflected_method(env, first_ctor);
  uintptr_t second = (uintptr_t)amethod_from_reflected_method(env, second_ctor);

  (*env)->DeleteLocalRef(env, first_ctor);
  (*env)->DeleteLocalRef(env, second_ctor);
  (*env)->DeleteLocalRef(env, constructors);
  (*env)->DeleteLocalRef(env, clazz);

  art_method_size = second - first;
  LOGD("ArtMethod size: %zu", art_method_size);
  if ((4 * 9 + 3 * sizeof(void *)) < art_method_size) {
    LOGE("ArtMethod size exceeds maximum assume. There may be something wrong.");

    return false;
  }

  entry_point_offset = art_method_size - sizeof(void *);
  data_offset = entry_point_offset - sizeof(void *);
  LOGD("ArtMethod entrypoint offset: %zu", entry_point_offset);
  LOGD("ArtMethod data offset: %zu", data_offset);

  return true;
}

static inline void *amethod_get_data(uintptr_t self) {
  return *(void **)(self + data_offset);
}

static inline void *amethod_from_reflected_method(JNIEnv *env, jobject method) {
  if (art_method_field) {
    return (void *)(*env)->GetLongField(env, method, art_method_field);
  } else {
    return (void *)(*env)->FromReflectedMethod(env, method);
  }
}

#endif /* ART_METHOD_H */

```

`loader/src/injector/cpp_strings.c`:

```c
/* INFO: C implementation for reading C++ std::string from memory.
           Handles libc++ std::string layout with SSO (Small String Optimization).
   
         libc++ layout:
          - Short mode (LSB of first byte = 0): size = first_byte >> 1, data at byte 1
          - Long mode: capacity/size/pointer at platform-specific offsets */

#include "cpp_strings.h"
#include <stdint.h>

#ifdef __LP64__
  #define LONG_SIZE_OFFSET 8
  #define LONG_DATA_OFFSET 16
#else
  #define LONG_SIZE_OFFSET 4
  #define LONG_DATA_OFFSET 8
#endif

/* INFO: In libc++ little-endian: LSB of first byte = 0 means short mode */
static inline bool is_short_string(const unsigned char *bytes) {
  return (bytes[0] & 1) == 0;
}

size_t get_std_string_length(const void *std_string_ptr) {
  if (!std_string_ptr) return 0;

  const unsigned char *bytes = (const unsigned char *)std_string_ptr;

  if (is_short_string(bytes)) return bytes[0] >> 1;

  return *(const size_t *)((const char *)std_string_ptr + LONG_SIZE_OFFSET);
}

const char *read_std_string(const void *std_string_ptr) {
  if (!std_string_ptr) return NULL;

  const unsigned char *bytes = (const unsigned char *)std_string_ptr;

  if (is_short_string(bytes)) return (const char *)(bytes + 1);

  return *(const char **)((const char *)std_string_ptr + LONG_DATA_OFFSET);
}

```

`loader/src/injector/cpp_strings.h`:

```h
#ifndef CPP_STRINGS_H
#define CPP_STRINGS_H

#include <stddef.h>
#include <stdbool.h>

/* INFO: Read a C string pointer from a std::string object.
           The returned pointer is valid only as long as the std::string exists. */
const char *read_std_string(const void *std_string_ptr);

/* INFO: Get the length of a std::string object (not including null terminator). */
size_t get_std_string_length(const void *std_string_ptr);

#endif /* CPP_STRINGS_H */

```

`loader/src/injector/entry.c`:

```c
#include "misc.h"
#include "daemon.h"
#include "logging.h"

#include "hook.h"
#include "ptrace_clear.h"

#include <pthread.h>
#include <unistd.h>

__attribute__((visibility("default")))
void entry(void *addr, size_t size) {
  LOGD("ReZygisk library injected, version %s", ZKSU_VERSION);

  start_addr = addr;
  block_size = size;

  LOGD("start plt hooking");
  hook_functions();

  struct kernel_version version = parse_kversion();
  if (version.major > 3 || (version.major == 3 && version.minor >= 8)) {
    LOGD("Supported kernel version %d.%d.%d, sending seccomp event", version.major, version.minor, version.patch);

    perform_ptrace_message_clear();
  }

  if (!rezygiskd_zygote_injected()) {
    LOGE("ReZygiskd is not running");

    return;
  }

  LOGD("Zygisk library execution done, addr: %p, size: %zu", addr, size);
}

```

`loader/src/injector/gen_jni_hooks.py`:

```py
#!/usr/bin/env python3

primitives = ['jint', 'jboolean', 'jlong']

class JType:
    def __init__(self, cpp, jni):
        self.cpp = cpp
        self.jni = jni


class JArray(JType):
    def __init__(self, type):
        if type.cpp in primitives:
            name = type.cpp + 'Array'
        else:
            name = 'jobjectArray'
        super().__init__(name, '[' + type.jni)


class Argument:
    def __init__(self, name, type, set_arg = False):
        self.name = name
        self.type = type
        self.set_arg = set_arg

    def cpp(self):
        return f'{self.type.cpp} {self.name}'

# Args we don't care, give it an auto generated name
class Anon(Argument):
    cnt = 0
    def __init__(self, type):
        super().__init__(f'_{Anon.cnt}', type)
        Anon.cnt += 1

class Return:
    def __init__(self, value, type):
        self.value = value
        self.type = type

class Method:
    def __init__(self, name, ret, args):
        self.name = name
        self.ret = ret
        self.args = args

    def cpp(self):
        return ', '.join(x.cpp() for x in self.args)

    def name_list(self):
        return ', '.join(x.name for x in self.args)

    def jni(self):
        args = ''.join(x.type.jni for x in self.args)
        return f'({args}){self.ret.type.jni}'

    def body(self):
        return ''

class JNIHook(Method):
    def __init__(self, ver, ret, args):
        name = f'{self.base_name()}_{ver}'
        super().__init__(name, ret, args)

    def base_name(self):
        return ''

    def func_ptr_type(self):
        # Generate function pointer typedef name
        return f'{self.base_name()}_fn'

    def orig_method(self):
        return f'(({self.func_ptr_type()}){self.base_name()}_orig)'

def ind(i):
    return '\n' + '  ' * i

# Common types
jint = JType('jint', 'I')
jintArray = JArray(jint)
jstring = JType('jstring', 'Ljava/lang/String;')
jboolean = JType('jboolean', 'Z')
jlong = JType('jlong', 'J')
jlongArray = JArray(jlong)
void = JType('void', 'V')

class ForkAndSpec(JNIHook):
    def __init__(self, ver, args):
        super().__init__(ver, Return('ctx.pid', jint), args)

    def base_name(self):
        return 'nativeForkAndSpecialize'

    def init_args(self):
        return 'struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };'

    def body(self):
        decl = ''
        decl += ind(1) + self.init_args()
        for a in self.args:
            if a.set_arg:
                decl += ind(1) + f'args.{a.name} = &{a.name};'
        decl += ind(1) + 'struct zygisk_context ctx;'
        decl += ind(1) + 'rz_init(&ctx, env, &args);'
        decl += ind(1) + f'rz_{self.base_name()}_pre(&ctx);'
        decl += ind(1) + self.orig_method() + '('
        decl += ind(2) + f'env, clazz, {self.name_list()}'
        decl += ind(1) + ');'
        decl += ind(1) + f'rz_{self.base_name()}_post(&ctx);'
        decl += ind(1) + 'rz_cleanup(&ctx);'
        return decl

class SpecApp(ForkAndSpec):
    def __init__(self, ver, args):
        super().__init__(ver, args)
        self.ret = Return('', void)

    def base_name(self):
        return 'nativeSpecializeAppProcess'

class ForkServer(ForkAndSpec):
    def base_name(self):
        return 'nativeForkSystemServer'

    def init_args(self):
        return 'struct server_specialize_args_v1 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .permitted_capabilities = &permitted_capabilities, .effective_capabilities = &effective_capabilities };'

# Common args
uid = Argument('uid', jint)
gid = Argument('gid', jint)
gids = Argument('gids', jintArray)
runtime_flags = Argument('runtime_flags', jint)
rlimits = Argument('rlimits', JArray(jintArray))
mount_external = Argument('mount_external', jint)
se_info = Argument('se_info', jstring)
nice_name = Argument('nice_name', jstring)
fds_to_close = Argument('fds_to_close', jintArray)
instruction_set = Argument('instruction_set', jstring)
app_data_dir = Argument('app_data_dir', jstring)

# o
fds_to_ignore = Argument('fds_to_ignore', jintArray, True)

# p
is_child_zygote = Argument('is_child_zygote', jboolean, True)

# q_alt
is_top_app = Argument('is_top_app', jboolean, True)

# r
pkg_data_info_list = Argument('pkg_data_info_list', JArray(jstring), True)
whitelisted_data_info_list = Argument('whitelisted_data_info_list', JArray(jstring), True)
mount_data_dirs = Argument('mount_data_dirs', jboolean, True)
mount_storage_dirs = Argument('mount_storage_dirs', jboolean, True)

# u
mount_sysprop_overrides = Argument('mount_sysprop_overrides', jboolean, True)

# server
permitted_capabilities = Argument('permitted_capabilities', jlong)
effective_capabilities = Argument('effective_capabilities', jlong)

# Method definitions
fas_l = ForkAndSpec('l', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, nice_name, fds_to_close, instruction_set, app_data_dir])

fas_o = ForkAndSpec('o', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, nice_name, fds_to_close, fds_to_ignore, instruction_set, app_data_dir])

fas_p = ForkAndSpec('p', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info,
    nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir])

fas_q_alt = ForkAndSpec('q_alt', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info,
    nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app])

fas_r = ForkAndSpec('r', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info,
    nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app,
    pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs])

fas_u = ForkAndSpec('u', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info,
    nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app,
    pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides])

fas_samsung_m = ForkAndSpec('samsung_m', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, Anon(jint), Anon(jint), nice_name, fds_to_close, instruction_set, app_data_dir])

fas_samsung_n = ForkAndSpec('samsung_n', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, Anon(jint), Anon(jint), nice_name, fds_to_close, instruction_set, app_data_dir, Anon(jint)])

fas_samsung_o = ForkAndSpec('samsung_o', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, Anon(jint), Anon(jint), nice_name, fds_to_close, fds_to_ignore, instruction_set, app_data_dir])

fas_samsung_p = ForkAndSpec('samsung_p', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, Anon(jint), Anon(jint), nice_name, fds_to_close, fds_to_ignore, is_child_zygote,
    instruction_set, app_data_dir])

fas_samsung_b = ForkAndSpec('samsung_b', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir,
    Anon(jboolean), is_top_app, pkg_data_info_list, whitelisted_data_info_list,
    mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides])

spec_q = SpecApp('q', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info,
    nice_name, is_child_zygote, instruction_set, app_data_dir])

spec_q_alt = SpecApp('q_alt', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info,
    nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app])

spec_r = SpecApp('r', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name,
    is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list,
    whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs])

spec_u = SpecApp('u', [uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name,
    is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list,
    whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides])

spec_samsung_q = SpecApp('samsung_q', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, Anon(jint), Anon(jint), nice_name, is_child_zygote, instruction_set, app_data_dir])

server_l = ForkServer('l', [uid, gid, gids, runtime_flags, rlimits,
    permitted_capabilities, effective_capabilities])

server_samsung_q = ForkServer('samsung_q', [uid, gid, gids, runtime_flags, Anon(jint), Anon(jint), rlimits,
    permitted_capabilities, effective_capabilities])

# GrapheneOS Android 14 Support
server_grapheneos_u = ForkServer('grapheneos_u', [uid, gid, gids, runtime_flags, rlimits, permitted_capabilities, effective_capabilities])

fas_grapheneos_u = ForkAndSpec('grapheneos_u', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir,
    is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides, Anon(jlongArray)])

spec_grapheneos_u = SpecApp('grapheneos_u', [uid, gid, gids, runtime_flags, rlimits, mount_external,
    se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list,
    whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides, Anon(jlongArray)])

hook_map = {}

def gen_jni_def(clz, methods):
    if clz not in hook_map:
        hook_map[clz] = []

    decl = ''
    
    # Generate function pointer typedef for original function
    func_ptr_type = f'{methods[0].base_name()}_fn'
    # Use the first method's signature as the base (they differ only in args count)
    first_m = methods[0]
    decl += ind(0) + f'typedef {first_m.ret.type.cpp} (*{func_ptr_type})(JNIEnv *, jclass, ...);'
    
    for m in methods:
        decl += ind(0) + f'__attribute__((no_stack_protector)) static {m.ret.type.cpp} {m.name}(JNIEnv *env, jclass clazz, {m.cpp()}) {{'
        decl += m.body()
        if m.ret.value:
            decl += ind(1) + f'return {m.ret.value};'
        decl += ind(0) + '}'

    num_methods = len(methods)
    decl += ind(0) + f'static JNINativeMethod {m.base_name()}_methods[{num_methods}] = {{'
    for m in methods:
        decl += ind(1) + '{'
        decl += ind(2) + f'"{m.base_name()}",'
        decl += ind(2) + f'"{m.jni()}",'
        decl += ind(2) + f'(void *) &{m.name}'
        decl += ind(1) + '},'
    decl += ind(0) + '};'
    decl += ind(0) + f'static const int {m.base_name()}_methods_count = {num_methods};'
    decl = ind(0) + f'static void *{m.base_name()}_orig = NULL;' + decl
    decl += ind(0)

    hook_map[clz].append(m.base_name())

    return decl

with open('jni_hooks.h', 'w') as f:
    f.write('/* Generated by gen_jni_hooks.py */\n')
    f.write('#ifndef JNI_HOOKS_H\n')
    f.write('#define JNI_HOOKS_H\n\n')

    zygote = 'com/android/internal/os/Zygote'

    methods = [fas_l, fas_o, fas_p, fas_q_alt, fas_r, fas_u, fas_samsung_m, fas_samsung_n, fas_samsung_o, fas_samsung_p, fas_samsung_b, fas_grapheneos_u]
    f.write(gen_jni_def(zygote, methods))

    methods = [spec_q, spec_q_alt, spec_r, spec_u, spec_samsung_q, spec_grapheneos_u]
    f.write(gen_jni_def(zygote, methods))

    methods = [server_l, server_samsung_q, server_grapheneos_u]
    f.write(gen_jni_def(zygote, methods))

    f.write("""
static void do_hook_zygote(JNIEnv *env) {
  JNINativeMethod hooks[3];
  int hooks_count = 0;

  const char *clz = "com/android/internal/os/Zygote";
  hook_jni_methods(env, clz, nativeForkAndSpecialize_methods, nativeForkAndSpecialize_methods_count);
  for (int i = 0; i < nativeForkAndSpecialize_methods_count; i++) {
    if (!nativeForkAndSpecialize_methods[i].fnPtr) continue;

    nativeForkAndSpecialize_orig = nativeForkAndSpecialize_methods[i].fnPtr;
    hooks[hooks_count++] = nativeForkAndSpecialize_methods[i];

    break;
  }

  hook_jni_methods(env, clz, nativeSpecializeAppProcess_methods, nativeSpecializeAppProcess_methods_count);
  for (int i = 0; i < nativeSpecializeAppProcess_methods_count; i++) {
    if (!nativeSpecializeAppProcess_methods[i].fnPtr) continue;

    nativeSpecializeAppProcess_orig = nativeSpecializeAppProcess_methods[i].fnPtr;
    hooks[hooks_count++] = nativeSpecializeAppProcess_methods[i];

    break;
  }

  hook_jni_methods(env, clz, nativeForkSystemServer_methods, nativeForkSystemServer_methods_count);
  for (int i = 0; i < nativeForkSystemServer_methods_count; i++) {
    if (!nativeForkSystemServer_methods[i].fnPtr) continue;

    nativeForkSystemServer_orig = nativeForkSystemServer_methods[i].fnPtr;
    hooks[hooks_count++] = nativeForkSystemServer_methods[i];

    break;
  }

  jni_hook_list_add(clz, hooks, hooks_count);
}

#endif /* JNI_HOOKS_H */
""")

```

`loader/src/injector/hook.c`:

```c
#include <sys/mount.h>
#include <dlfcn.h>
#include <link.h>
#include <regex.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <lsplt.h>
#include <csoloader.h>

#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <signal.h>
#include <limits.h>

#include <unistd.h>
#include <pthread.h>

#include "daemon.h"
#include "module.h"
#include "misc.h"

#include "art_method.h"
#include "cpp_strings.h"

void *start_addr = NULL;
size_t block_size = 0;

/* INFO: Flag indices */
enum {
  POST_SPECIALIZE,
  APP_FORK_AND_SPECIALIZE,
  APP_SPECIALIZE,
  SERVER_FORK_AND_SPECIALIZE,
  DO_REVERT_UNMOUNT,
  SKIP_FD_SANITIZATION,

  FLAG_MAX
};

#define MAX_FD_SIZE 1024
#define MAX_REGISTER_INFO 64
#define MAX_IGNORE_INFO 64
#define MAX_EXEMPTED_FDS 128

struct register_info {
  regex_t regex;
  char *symbol;
  void *callback;
  void **backup;
};

struct ignore_info {
  regex_t regex;
  char *symbol;
};

struct zygisk_context {
  JNIEnv *env;
  union {
    void *ptr;
    struct app_specialize_args_v5 *app;
    struct server_specialize_args_v1 *server;
  } args;

  const char *process;

  int pid;
  uint32_t flags;
  uint32_t info_flags;
  uint8_t allowed_fds[MAX_FD_SIZE];
  int exempted_fds[MAX_EXEMPTED_FDS];
  size_t exempted_fds_count;

  pthread_mutex_t hook_info_lock;
  struct register_info register_info[MAX_REGISTER_INFO];
  size_t register_info_count;
  struct ignore_info ignore_info[MAX_IGNORE_INFO];
  size_t ignore_info_count;
};

/* INFO: Current context */
static struct zygisk_context *g_ctx = NULL;

/* INFO: Helper macros for flags */
#define FLAG_SET(ctx, f) ((ctx)->flags |= (1u << (f)))
#define FLAG_GET(ctx, f) (((ctx)->flags & (1u << (f))) != 0)
#define FLAG_CLEAR(ctx, f) ((ctx)->flags &= ~(1u << (f)))

#define DCL_PRE_POST(name)                                   \
  static void rz_## name ##_pre(struct zygisk_context *ctx); \
  static void rz_## name ##_post(struct zygisk_context *ctx)

/* INFO: Early declarations */
static void rz_init(struct zygisk_context *ctx, JNIEnv *env, void *args);
static void rz_cleanup(struct zygisk_context *ctx);

DCL_PRE_POST(run_modules);
DCL_PRE_POST(fork);
DCL_PRE_POST(app_specialize);
DCL_PRE_POST(nativeForkAndSpecialize);
DCL_PRE_POST(nativeSpecializeAppProcess);
DCL_PRE_POST(nativeForkSystemServer);

#undef DCL_PRE_POST

static inline bool is_zygote_child(struct zygisk_context *ctx) {
  return ctx->pid <= 0;
}

struct plt_hook_entry {
  dev_t dev;
  ino_t inode;
  const char *symbol;
  void **old_func;
};

struct jni_hook_entry {
  char *class_name;
  JNINativeMethod *methods;
  size_t methods_count;
};

static struct plt_hook_entry *plt_hook_list = NULL;
static size_t plt_hook_list_count = 0;
static size_t plt_hook_list_capacity = 0;

static struct jni_hook_entry *jni_hook_list = NULL;
static size_t jni_hook_list_count = 0;
static size_t jni_hook_list_capacity = 0;

static bool modules_loaded = false;
struct rezygisk_module *zygisk_modules = NULL;
size_t zygisk_module_length = 0;

static bool should_unmap_zygisk = false;
static bool enable_unloader = false;
static bool hooked_unloader = false;

/* INFO: Helper function to add to PLT hook list */
static void plt_hook_list_add(dev_t dev, ino_t inode, const char *symbol, void **old_func) {
  if (plt_hook_list_count >= plt_hook_list_capacity) {
    size_t new_capacity = plt_hook_list_capacity == 0 ? 16 : plt_hook_list_capacity * 2;
    struct plt_hook_entry *new_list = realloc(plt_hook_list, new_capacity * sizeof(struct plt_hook_entry));
    if (!new_list) {
      LOGE("Failed to reallocate buffer for hook list");

      return;
    }

    plt_hook_list = new_list;
    plt_hook_list_capacity = new_capacity;
  }

  plt_hook_list[plt_hook_list_count].dev = dev;
  plt_hook_list[plt_hook_list_count].inode = inode;
  plt_hook_list[plt_hook_list_count].symbol = symbol;
  plt_hook_list[plt_hook_list_count].old_func = old_func;
  plt_hook_list_count++;
}

/* INFO: Helper function to add to JNI hook list */
static void jni_hook_list_add(const char *class_name, JNINativeMethod *methods, size_t count) {
  if (jni_hook_list_count >= jni_hook_list_capacity) {
    size_t new_capacity = jni_hook_list_capacity == 0 ? 4 : jni_hook_list_capacity * 2;
    struct jni_hook_entry *new_list = realloc(jni_hook_list, new_capacity * sizeof(struct jni_hook_entry));
    if (!new_list) {
      LOGE("Failed to reallocate buffer for hook list");

      return;
    }

    jni_hook_list = new_list;
    jni_hook_list_capacity = new_capacity;
  }

  jni_hook_list[jni_hook_list_count].class_name = strdup(class_name);
  if (!jni_hook_list[jni_hook_list_count].class_name) {
    LOGE("Failed to duplicate class name for hook list");

    return;
  }

  jni_hook_list[jni_hook_list_count].methods = malloc(count * sizeof(JNINativeMethod));
  if (!jni_hook_list[jni_hook_list_count].methods) {
    LOGE("Failed to allocate memory for methods in hook list");

    free(jni_hook_list[jni_hook_list_count].class_name);

    return;
  }

  memcpy(jni_hook_list[jni_hook_list_count].methods, methods, count * sizeof(JNINativeMethod));

  jni_hook_list[jni_hook_list_count].methods_count = count;
  jni_hook_list_count++;
}

static bool update_mnt_ns(enum mount_namespace_state mns_state, bool dry_run) {
  char ns_path[PATH_MAX];
  if (!rezygiskd_update_mns(mns_state, ns_path, sizeof(ns_path))) {
    PLOGE("Failed to update mount namespace");

    return false;
  }

  if (dry_run) return true;

  int updated_ns = open(ns_path, O_RDONLY);
  if (updated_ns == -1) {
    PLOGE("Failed to open mount namespace [%s]", ns_path);

    return false;
  }

  char *mns_state_str = "unknown";
  if (mns_state == Clean) mns_state_str = "clean";
  if (mns_state == Mounted) mns_state_str = "mounted";

  LOGD("set mount namespace to [%s] fd=[%d]: %s", ns_path, updated_ns, mns_state_str);

  if (setns(updated_ns, CLONE_NEWNS) == -1) {
    PLOGE("Failed to set mount namespace [%s]", ns_path);

    close(updated_ns);

    return false;
  }

  close(updated_ns);

  return true;
}

/* INFO: Hook function declarations */
#define DCL_HOOK_FUNC(ret, func, ...) \
  ret (*old_##func)(__VA_ARGS__);     \
  ret new_##func(__VA_ARGS__)

/* INFO: ReZygisk already performs a fork in zygisk_context::fork_pre, because of that,
           we avoid duplicate fork in nativeForkAndSpecialize and nativeForkSystemServer
           by caching the pid in fork_pre function and only performing fork if the pid
           is non-0, or in other words, if we (libzygisk.so) already forked.
*/
DCL_HOOK_FUNC(int, fork) {
  return (g_ctx && g_ctx->pid >= 0) ? g_ctx->pid : old_fork();
}

/* INFO: file_path is a std::string in the actual class. We represent it as opaque bytes. */
#ifdef __LP64__
  #define STD_STRING_SIZE 24
#else
  #define STD_STRING_SIZE 12
#endif

struct FileDescriptorInfo {
  const int fd;
  const struct stat stat;
  /* INFO: std::string, actually */
  char file_path_storage[STD_STRING_SIZE];
  const int open_flags;
  const int fd_flags;
  const int fs_flags;
  const off_t offset;
  const bool is_sock;
};

/* INFO: This hook avoids that umounted overlays made by root modules lead to Zygote
           to Abort its operation as it cannot open anymore.

   SOURCES:
     - https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-14.0.0_r1/core/jni/fd_utils.cpp#346
     - https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-14.0.0_r1/core/jni/fd_utils.cpp#544
     - https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-14.0.0_r1/core/jni/com_android_internal_os_Zygote.cpp#2329
*/
DCL_HOOK_FUNC(void, _ZNK18FileDescriptorInfo14ReopenOrDetach, void *_this, void *fail_fn) {
  const int fd = *(const int *)((uintptr_t)_this + offsetof(struct FileDescriptorInfo, fd));
  const void *file_path_std_string = (const void *)((uintptr_t)_this + offsetof(struct FileDescriptorInfo, file_path_storage));
  const char *file_path = read_std_string(file_path_std_string);
  const bool is_sock = *(const bool *)((uintptr_t)_this + offsetof(struct FileDescriptorInfo, is_sock));

  if (is_sock)
    goto bypass_fd_check;

  if (strncmp(file_path, "/memfd:/boot-image-methods.art", strlen("/memfd:/boot-image-methods.art")) == 0)
    goto bypass_fd_check;

  if (access(file_path, F_OK) == -1) {
    LOGD("Failed to open file %s, detaching it", file_path);

    close(fd);

    return;
  }

  bypass_fd_check:
    old__ZNK18FileDescriptorInfo14ReopenOrDetach(_this, fail_fn);
}

static void unhook_functions(void);
/* INFO: Self-unloading is not a direct task, it requires the utilization of tail
           optimization, which requires the signature to be the same as munmap, or
           else munmap will be executed and will try to reach our code, leading to
           a segmentation fault.

         To counter that, we hook pthread_attr_setstacksize, which is called around
           when the VM daemon starts, to allow this to happen before the app can
           execute code.
*/
DCL_HOOK_FUNC(int, pthread_attr_setstacksize, void *target, size_t size) {
  int res = old_pthread_attr_setstacksize((pthread_attr_t *)target, size);
  LOGV("Call pthread_attr_setstacksize in [tid, pid]: %d, %d", gettid(), getpid());

  if (!enable_unloader) return res;

  /* INFO: Only perform unloading on the main thread */
  if (gettid() != getpid()) return res;

  if (should_unmap_zygisk) {
    unhook_functions();

    /* INFO: Modules might use libzygisk.so after postAppSpecialize. We can only
               free it when we are really before our unmap. */
    free(zygisk_modules);
    zygisk_modules = NULL;

    lsplt_free_resources();

    LOGD("unmap libzygisk.so loaded at %p with size %zu", start_addr, block_size);

    [[clang::musttail]] return munmap(start_addr, block_size);
  }

  return res;
}

static void initialize_jni_hook(void);
DCL_HOOK_FUNC(char *, strdup, const char *str) {
  if (strcmp(str, "com.android.internal.os.ZygoteInit") == 0) {
    LOGV("strdup %s", str);

    initialize_jni_hook();
  }

  return old_strdup(str);
}

static void hook_unloader(void);
/*
  INFO: Our goal is to get called after libart.so is loaded, but before ART actually starts running.
          If we are too early, we won't find libart.so in maps, and if we are too late, we could make other
          threads crash if they try to use the PLT while we are in the process of hooking it.
          For this task, hooking property_get was chosen as there are lots of calls to this, so it's
          relatively unlikely to break.

        After we succeed in getting called at a point where libart.so is already loaded, we will ignore
          the rest of the property_get calls.
  SOURCES:
   - https://github.com/aosp-mirror/platform_frameworks_base/blob/1cdfff555f4a21f71ccc978290e2e212e2f8b168/core/jni/AndroidRuntime.cpp#L1266
   - https://github.com/aosp-mirror/platform_frameworks_base/blob/1cdfff555f4a21f71ccc978290e2e212e2f8b168/core/jni/AndroidRuntime.cpp#L791
*/
DCL_HOOK_FUNC(int, property_get, const char *key, char *value, const char *default_value) {
  hook_unloader();

  return old_property_get(key, value, default_value);
}

#undef DCL_HOOK_FUNC

static bool can_hook_jni = false;
static jint MODIFIER_NATIVE = 0;
static jmethodID member_getModifiers = NULL;

void hook_jni_methods(JNIEnv *env, const char *clz, JNINativeMethod *methods, int numMethods) {
  if (!can_hook_jni) return;

  jclass clazz = (*env)->FindClass(env, clz);
  if (!clazz) {
    (*env)->ExceptionClear(env);

    memset(methods, 0, numMethods * sizeof(JNINativeMethod));

    return;
  }

  JNINativeMethod hooks[32];
  size_t hooks_count = 0;

  for (int i = 0; i < numMethods; i++) {
    bool is_static = false;

    JNINativeMethod *nm = &methods[i];
    jmethodID mid = (*env)->GetMethodID(env, clazz, nm->name, nm->signature);
    if (!mid) {
      (*env)->ExceptionClear(env);
      mid = (*env)->GetStaticMethodID(env, clazz, nm->name, nm->signature);
      is_static = true;
    }

    if (!mid) {
      (*env)->ExceptionClear(env);
      nm->fnPtr = NULL;

      continue;
    }

    jobject method = (*env)->ToReflectedMethod(env, clazz, mid, is_static);
    jint modifier = (*env)->CallIntMethod(env, method, member_getModifiers);
    if ((modifier & MODIFIER_NATIVE) == 0) {
      nm->fnPtr = NULL;

      continue;
    }

    void *art_method = amethod_from_reflected_method(env, method);
    if (hooks_count < 32)
      hooks[hooks_count++] = *nm;

    void *orig = amethod_get_data((uintptr_t)art_method);
    nm->fnPtr = orig;

    LOGV("replaced %s %s orig %p", clz, nm->name, orig);
  }

  if (hooks_count == 0) {
    (*env)->DeleteLocalRef(env, clazz);

    return;
  }

  (*env)->RegisterNatives(env, clazz, hooks, (jint)hooks_count);
  (*env)->DeleteLocalRef(env, clazz);
}

/* INFO: JNI method hook definitions */
#include "jni_hooks.h"

static void initialize_jni_hook(void) {
  jint (*get_created_java_vms)(JavaVM **, jsize, jsize *) = (jint (*)(JavaVM **, jsize, jsize *))dlsym(RTLD_DEFAULT, "JNI_GetCreatedJavaVMs");
  if (!get_created_java_vms) {
    struct lsplt_map_info *map_infos = lsplt_scan_maps("self");
    if (!map_infos) {
      LOGE("Failed to scan maps for self");

      return;
    }

    for (size_t i = 0; i < map_infos->length; i++) {
      struct lsplt_map_entry *map = &map_infos->maps[i];
      if (!strstr(map->path, "/libnativehelper.so")) continue;

      /* TODO: Add RTLD_NOLOAD? */
      void *handle = dlopen(map->path, RTLD_LAZY);
      if (!handle) {
        LOGE("Failed to dlopen %s: %s", map->path, dlerror());

        break;
      }
 
      get_created_java_vms = (jint (*)(JavaVM **, jsize, jsize *))dlsym(handle, "JNI_GetCreatedJavaVMs");
      dlclose(handle);

      break;
    }

    lsplt_free_maps(map_infos);

    if (!get_created_java_vms) {
      LOGE("Failed to find JNI_GetCreatedJavaVMs");

      return;
    }
  }

  JavaVM *vm = NULL;
  jsize num = 0;
  jint res = get_created_java_vms(&vm, 1, &num);
  if (res != JNI_OK || !vm) return;

  JNIEnv *env = NULL;
  res = (*vm)->GetEnv(vm, (void **)&env, JNI_VERSION_1_6);
  if (res != JNI_OK || !env) return;

  jclass classMember = (*env)->FindClass(env, "java/lang/reflect/Member");
  if (classMember) member_getModifiers = (*env)->GetMethodID(env, classMember, "getModifiers", "()I");

  jclass classModifier = (*env)->FindClass(env, "java/lang/reflect/Modifier");
  if (classModifier) {
    jfieldID fieldId = (*env)->GetStaticFieldID(env, classModifier, "NATIVE", "I");
    if (fieldId) MODIFIER_NATIVE = (*env)->GetStaticIntField(env, classModifier, fieldId);
  }

  (*env)->DeleteLocalRef(env, classMember);
  (*env)->DeleteLocalRef(env, classModifier);

  if (!member_getModifiers || MODIFIER_NATIVE == 0) return;

  if (!amethod_init(env)) {
    LOGE("failed to init amethod");

    return;
  }

  can_hook_jni = true;
  do_hook_zygote(env);
}

/* INFO: Module registration and API functions */
static void api_plt_hook_register(const char *regex, const char *symbol, void *fn, void **backup) {
  if (!g_ctx || !regex || !symbol || !fn || g_ctx->register_info_count >= MAX_REGISTER_INFO) return;

  regex_t re;
  if (regcomp(&re, regex, REG_NOSUB) != 0) return;

  pthread_mutex_lock(&g_ctx->hook_info_lock);

  g_ctx->register_info[g_ctx->register_info_count].regex = re;
  g_ctx->register_info[g_ctx->register_info_count].symbol = strdup(symbol);
  g_ctx->register_info[g_ctx->register_info_count].callback = fn;
  g_ctx->register_info[g_ctx->register_info_count].backup = backup;
  g_ctx->register_info_count++;

  pthread_mutex_unlock(&g_ctx->hook_info_lock);
}

static void api_plt_hook_exclude(const char *regex, const char *symbol) {
  if (!g_ctx || !regex || g_ctx->ignore_info_count >= MAX_IGNORE_INFO) return;

  regex_t re;
  if (regcomp(&re, regex, REG_NOSUB) != 0) return;

  pthread_mutex_lock(&g_ctx->hook_info_lock);

  g_ctx->ignore_info[g_ctx->ignore_info_count].regex = re;
  g_ctx->ignore_info[g_ctx->ignore_info_count].symbol = symbol ? strdup(symbol) : NULL;
  g_ctx->ignore_info_count++;

  pthread_mutex_unlock(&g_ctx->hook_info_lock);
}

static bool api_plt_hook_commit(void) {
  if (!g_ctx || g_ctx->register_info_count == 0) return false;

  pthread_mutex_lock(&g_ctx->hook_info_lock);

  struct lsplt_map_info *map_infos = lsplt_scan_maps("self");
  if (!map_infos) {
    LOGE("Failed to scan maps for self");

    pthread_mutex_unlock(&g_ctx->hook_info_lock);

    return false;
  }

  for (size_t i = 0; i < map_infos->length; i++) {
    struct lsplt_map_entry *map = &map_infos->maps[i];
    if (map->offset != 0 || !map->is_private || !(map->perms & PROT_READ)) continue;

    for (size_t r = 0; r < g_ctx->register_info_count; r++) {
      struct register_info *reg = &g_ctx->register_info[r];
      if (regexec(&reg->regex, map->path, 0, NULL, 0) != 0) continue;

      bool ignored = false;
      for (size_t ig = 0; ig < g_ctx->ignore_info_count; ig++) {
        struct ignore_info *ign = &g_ctx->ignore_info[ig];
        if (regexec(&ign->regex, map->path, 0, NULL, 0) != 0) continue;  
        if (ign->symbol && strcmp(ign->symbol, reg->symbol) != 0) continue;

        ignored = true;

        break;
      }

      if (!ignored)
        lsplt_register_hook(map->dev, map->inode, reg->symbol, reg->callback, reg->backup);
    }
  }

  lsplt_free_maps(map_infos);

  /* INFO: Clear register_info and ignore_info */
  for (size_t i = 0; i < g_ctx->register_info_count; i++) {
    regfree(&g_ctx->register_info[i].regex);
    free(g_ctx->register_info[i].symbol);
  }
  g_ctx->register_info_count = 0;

  for (size_t i = 0; i < g_ctx->ignore_info_count; i++) {
    regfree(&g_ctx->ignore_info[i].regex);
    free(g_ctx->ignore_info[i].symbol);
  }
  g_ctx->ignore_info_count = 0;

  pthread_mutex_unlock(&g_ctx->hook_info_lock);

  return lsplt_commit_hook();
}

static void api_plt_hook_register_v4(dev_t dev, ino_t inode, const char *symbol, void *fn, void **backup) {
  if (!g_ctx) return;

  if (dev == 0 || inode == 0 || !symbol || !fn) {
    LOGE("Invalid arguments to plt_hook_register");

    return;
  }

  lsplt_register_hook(dev, inode, symbol, fn, backup);
}

static void api_exempt_fd(int fd) {
  if (!g_ctx) return;

  if (FLAG_GET(g_ctx, POST_SPECIALIZE) || FLAG_GET(g_ctx, SKIP_FD_SANITIZATION)) return;
  if (!FLAG_GET(g_ctx, APP_FORK_AND_SPECIALIZE)) return;
  if (g_ctx->exempted_fds_count >= MAX_EXEMPTED_FDS) return;

  g_ctx->exempted_fds[g_ctx->exempted_fds_count++] = fd;

  return;
}

static bool api_plt_hook_commit_v4(void) {
  if (!g_ctx) return false;

  return lsplt_commit_hook();
}

static int api_connect_companion(void *id) {
  if (!g_ctx) return -1;

  if ((size_t)id >= zygisk_module_length) {
    LOGE("Invalid module id %zu", (size_t)id);

    return -1;
  }

  return rezygiskd_connect_companion((size_t)id);
}

static void api_set_option(void *id, enum rezygisk_options opt) {
  if (!g_ctx) return;

  if ((size_t)id >= zygisk_module_length) {
    LOGE("Invalid module id %zu", (size_t)id);

    return;
  }

  switch (opt) {
    case FORCE_DENYLIST_UNMOUNT: {
      FLAG_SET(g_ctx, DO_REVERT_UNMOUNT);

      break;
    }
    case DLCLOSE_MODULE_LIBRARY: {
      struct rezygisk_module *m_lib = &zygisk_modules[(size_t)id];
      m_lib->unload = true;

      break;
    }
  }
}

static int api_get_module_dir(void *id) {
  if (!g_ctx) return -1;

  if ((size_t)id >= zygisk_module_length) {
    LOGE("Invalid module id %zu", (size_t)id);

    return -1;
  }

  return rezygiskd_get_module_dir((size_t)id);
}

static uint32_t api_get_flags(void) {
  if (!g_ctx) return 0;

  return (g_ctx->info_flags & ~PRIVATE_MASK);
}

bool rezygisk_module_register(struct rezygisk_api *api, struct rezygisk_abi const *target_module) {
  if (!g_ctx || !api || !target_module || target_module->api_version > REZYGISK_API_VERSION) return false;

  LOGD("Registering module with API version %ld", target_module->api_version);

  struct rezygisk_module *m = &zygisk_modules[(size_t)api->impl];
  m->abi = *target_module;
  m->api = *api;

  api->hook_jni_native_methods = hook_jni_methods;
  if (target_module->api_version >= 4) {
    api->plt_hook_register_v4 = api_plt_hook_register_v4;
    api->exempt_fd = api_exempt_fd;
    api->plt_hook_commit = api_plt_hook_commit_v4;
  } else {
    api->plt_hook_register = api_plt_hook_register;
    api->plt_hook_exclude = api_plt_hook_exclude;
    api->plt_hook_commit = api_plt_hook_commit;
  }

  api->connect_companion = api_connect_companion;
  api->set_option = api_set_option;

  if (target_module->api_version >= 2) {
    api->get_module_dir = api_get_module_dir;
    api->get_flags = api_get_flags;
  }

  return true;
}

/* INFO: Signal mask helper */
static int sigmask(int how, int signum) {
  sigset_t set;
  sigemptyset(&set);
  sigaddset(&set, signum);

  return sigprocmask(how, &set, NULL);
}

static bool load_modules_only(void);

static void rz_fork_pre(struct zygisk_context *ctx) {
  /* INFO: Do our own fork before loading any 3rd party code.
              First block SIGCHLD, unblock after original fork is done.
  */
  sigmask(SIG_BLOCK, SIGCHLD);
  ctx->pid = old_fork();
  if (ctx->pid != 0 || FLAG_GET(ctx, SKIP_FD_SANITIZATION)) return;

  /* INFO: Record all open fds */
  DIR *dir = opendir("/proc/self/fd");
  if (!dir) {
    PLOGE("Failed to open /proc/self/fd");

    return;
  }

  struct dirent *entry;
  while ((entry = readdir(dir))) {
    int fd = parse_int(entry->d_name);
    if (fd < 0 || fd >= MAX_FD_SIZE) {
      close(fd);

      continue;
    }

    ctx->allowed_fds[fd] = 1;
  }

  /* INFO: The dirfd should not be allowed */
  int dfd = dirfd(dir);
  if (dfd >= 0 && dfd < MAX_FD_SIZE) ctx->allowed_fds[dfd] = 0;

  closedir(dir);
}

static void mark_fds_allowed(struct zygisk_context *ctx, JNIEnv *env, jintArray fdsArray) {
  if (!fdsArray) return;

  jint *arr = (*env)->GetIntArrayElements(env, fdsArray, NULL);
  jint len = (*env)->GetArrayLength(env, fdsArray);

  for (jint i = 0; i < len; ++i) {
    int fd = arr[i];
    if (fd >= 0 && fd < MAX_FD_SIZE) ctx->allowed_fds[fd] = 1;
  }

  (*env)->ReleaseIntArrayElements(env, fdsArray, arr, JNI_ABORT);
}

static void rz_sanitize_fds(struct zygisk_context *ctx) {
  if (FLAG_GET(ctx, SKIP_FD_SANITIZATION)) return;

  if (FLAG_GET(ctx, APP_FORK_AND_SPECIALIZE)) {
    jintArray fdsToIgnore = *ctx->args.app->fds_to_ignore;
    mark_fds_allowed(ctx, ctx->env, fdsToIgnore);

    if (ctx->exempted_fds_count > 0) {
      jint len = fdsToIgnore ? (*ctx->env)->GetArrayLength(ctx->env, fdsToIgnore) : 0;
      jintArray newArray = (*ctx->env)->NewIntArray(ctx->env, (jsize)(len + ctx->exempted_fds_count));
      if (newArray) {
        if (fdsToIgnore && len > 0) {
          jint *arr = (*ctx->env)->GetIntArrayElements(ctx->env, fdsToIgnore, NULL);
          (*ctx->env)->SetIntArrayRegion(ctx->env, newArray, 0, len, arr);
          (*ctx->env)->ReleaseIntArrayElements(ctx->env, fdsToIgnore, arr, JNI_ABORT);
          (*ctx->env)->DeleteLocalRef(ctx->env, fdsToIgnore);
        }

        (*ctx->env)->SetIntArrayRegion(ctx->env, newArray, len, (jsize)ctx->exempted_fds_count, ctx->exempted_fds);
        for (size_t i = 0; i < ctx->exempted_fds_count; i++) {
          int fd = ctx->exempted_fds[i];
          if (fd >= 0 && fd < MAX_FD_SIZE) ctx->allowed_fds[fd] = 1;
        }

        *ctx->args.app->fds_to_ignore = newArray;
        FLAG_SET(ctx, SKIP_FD_SANITIZATION);
      }
    }
  }

  if (ctx->pid != 0) return;

  /* INFO: Close all forbidden fds to prevent crashing */
  DIR *dir = opendir("/proc/self/fd");
  if (!dir) {
    PLOGE("Failed to open /proc/self/fd");

    return;
  }

  int dfd = dirfd(dir);
  struct dirent *entry;
  while ((entry = readdir(dir))) {
    int fd = parse_int(entry->d_name);
    if (fd < 0 || fd >= MAX_FD_SIZE || fd == dfd || ctx->allowed_fds[fd]) continue;

    close(fd);

    LOGW("Closed leaked fd: %d", fd);
  }

  closedir(dir);
}

static void rz_fork_post(struct zygisk_context *ctx __attribute__((unused))) {
  sigmask(SIG_UNBLOCK, SIGCHLD);
  g_ctx = NULL;
}

static bool load_modules_only(void) {
  struct zygisk_modules ms;
  if (!rezygiskd_read_modules(&ms)) {
    LOGE("Failed to read modules from ReZygiskd");

    return false;
  }

  zygisk_modules = (struct rezygisk_module *)malloc(ms.modules_count * sizeof(struct rezygisk_module));
  if (!zygisk_modules) {
    LOGE("Failed to allocate memory for modules");

    free_modules(&ms);

    return false;
  }

  for (size_t i = 0; i < ms.modules_count; i++) {
    const char *lib_path = ms.modules[i];

    if (!csoloader_load(&zygisk_modules[zygisk_module_length].lib, lib_path)) {
      LOGE("Failed to load module [%s]", lib_path);

      continue;
    }

    void *entry = csoloader_get_symbol(&zygisk_modules[zygisk_module_length].lib, "zygisk_module_entry");
    if (!entry) {
      LOGE("Failed to find entry point in module [%s]", lib_path);

      csoloader_unload(&zygisk_modules[zygisk_module_length].lib);

      continue;
    }

    zygisk_modules[zygisk_module_length].api.register_module = rezygisk_module_register;
    zygisk_modules[zygisk_module_length].api.impl = (void *)zygisk_module_length;
    zygisk_modules[zygisk_module_length].zygisk_module_entry = (void (*)(void *, void *))entry;

    LOGD("Loaded module [%s]. Entry: %p", lib_path, entry);

    zygisk_modules[zygisk_module_length].unload = false;
    zygisk_module_length++;
  }

  free_modules(&ms);

  return true;
}

static void rz_run_modules_pre(struct zygisk_context *ctx) {
  for (size_t i = 0; i < zygisk_module_length; i++) {
    rz_module_call_on_load(&zygisk_modules[i], ctx->env);

    if (FLAG_GET(ctx, APP_SPECIALIZE)) rz_module_call_pre_app_specialize(&zygisk_modules[i], ctx->args.app);
    else if (FLAG_GET(ctx, SERVER_FORK_AND_SPECIALIZE)) rz_module_call_pre_server_specialize(&zygisk_modules[i], ctx->args.server);
  }
}

static void rz_run_modules_post(struct zygisk_context *ctx) {
  FLAG_SET(ctx, POST_SPECIALIZE);

  size_t modules_unloaded = 0;
  for (size_t i = 0; i < zygisk_module_length; i++) {
    struct rezygisk_module *m = &zygisk_modules[i];

    if (FLAG_GET(ctx, APP_SPECIALIZE)) rz_module_call_post_app_specialize(m, ctx->args.app);
    else if (FLAG_GET(ctx, SERVER_FORK_AND_SPECIALIZE)) rz_module_call_post_server_specialize(m, ctx->args.server);

    if (!m->unload) {
      LOGD("Abandoning module library at %p", &m->lib);

      csoloader_abandon(&m->lib);

      continue;
    }

    if (!csoloader_unload(&m->lib)) {
      LOGE("Failed to unload module library");

      continue;
    }

    modules_unloaded++;
  }

  if (zygisk_module_length > 0)
    LOGD("Modules unloaded: %zu/%zu", modules_unloaded, zygisk_module_length);
}

static void rz_app_specialize_pre(struct zygisk_context *ctx) {
  FLAG_SET(ctx, APP_SPECIALIZE);


  /* INFO: Isolated services have different UIDs than the main apps. Because
              numerous root implementations base themselves in the UID of the
              app, we need to ensure that the UID sent to ReZygiskd to search
              is the app's and not the isolated service, or else it will be
              able to bypass DenyList.

           All apps, and isolated processes, of *third-party* applications will
             have their app_data_dir set. The system applications might not have
             one, however it is unlikely they will create an isolated process,
             and even if so, it should not impact in detections, performance or
             any area.
  */
  uid_t uid = *ctx->args.app->uid;
  if (IS_ISOLATED_SERVICE(uid) && ctx->args.app->app_data_dir) {
    /* INFO: If the app is an isolated service, we use the UID of the
               app's process data directory, which is the UID of the
               app itself, which root implementations actually use.
    */
    const char *data_dir = (*ctx->env)->GetStringUTFChars(ctx->env, *ctx->args.app->app_data_dir, NULL);
    if (!data_dir) {
      LOGE("Failed to get app data directory");

      return;
    }

    struct stat st;
    if (stat(data_dir, &st) == -1) {
      PLOGE("Failed to stat app data directory [%s]", data_dir);

      (*ctx->env)->ReleaseStringUTFChars(ctx->env, *ctx->args.app->app_data_dir, data_dir);

      return;
    }

    uid = st.st_uid;
    LOGD("Isolated service being related to UID %d, app data dir: %s", uid, data_dir);

    (*ctx->env)->ReleaseStringUTFChars(ctx->env, *ctx->args.app->app_data_dir, data_dir);
  }

  ctx->info_flags = rezygiskd_get_process_flags(uid, ctx->process);
  if (ctx->info_flags & PROCESS_IS_FIRST_STARTED) {
    /* INFO: To ensure we are really using a clean mount namespace, we use
               the first process it as reference for clean mount namespace,
               before it even does something, so that it will be clean yet
               with expected mounts.
    */
    update_mnt_ns(Clean, true);
  }

  if ((ctx->info_flags & PROCESS_IS_MANAGER) == PROCESS_IS_MANAGER) {
    LOGD("Manager process detected. Notifying that Zygisk has been enabled.");


    /* INFO: This environment variable is related to Magisk Zygisk/Manager. It
               it used by Magisk's Zygisk to communicate to Magisk Manager whether
               Zygisk is working or not, allowing Zygisk modules to both work properly
               and for the manager to mark Zygisk as enabled.

             However, to enhance capabilities of root managers, it is also set for
               any other supported manager, so that, if they wish, they can recognize
               if Zygisk is enabled.
    */
    setenv("ZYGISK_ENABLED", "1", 1);
  }

  /* INFO: Modules only have two "start off" points from Zygisk, preSpecialize and
             postSpecialize. In preSpecialize, the process still has privileged
             permissions, and therefore can execute mount/umount/setns functions.
             If we update the mount namespace AFTER executing them, any mounts made
             will be lost, and the process will not have access to them anymore.

           In postSpecialize, while still could have its mounts modified with the
             assistance of a Zygisk companion, it will already have the mount
             namespace switched by then, so there won't be issues.

           Knowing this, we update the mns before execution, so that they can still
             make changes to mounts in DenyListed processes without being reverted.
  */
  bool in_denylist = (ctx->info_flags & PROCESS_ON_DENYLIST) == PROCESS_ON_DENYLIST;
  if (in_denylist) {
    FLAG_SET(ctx, DO_REVERT_UNMOUNT);
    update_mnt_ns(Clean, false);
  }

  /* INFO: Executed after setns to ensure a module can update the mounts of an
              application without worrying about it being overwritten by setns.
  */
  rz_run_modules_pre(ctx);

  /* INFO: The modules may request that although the process is NOT in
              the DenyList, it has its mount namespace switched to the clean
              one.

              So to ensure this behavior happens, we must also check after the
              modules are loaded and executed, so that the modules can have
              the chance to request it.
  */
  if (!in_denylist && FLAG_GET(ctx, DO_REVERT_UNMOUNT))
    update_mnt_ns(Clean, false);
}

static void rz_app_specialize_post(struct zygisk_context *ctx) {
  rz_run_modules_post(ctx);

  /* INFO: Allow the process name string to be released */
  (*ctx->env)->ReleaseStringUTFChars(ctx->env, *ctx->args.app->nice_name, ctx->process);
  g_ctx = NULL;
}

static void rz_nativeSpecializeAppProcess_pre(struct zygisk_context *ctx) {
  ctx->process = (*ctx->env)->GetStringUTFChars(ctx->env, *ctx->args.app->nice_name, NULL);
  LOGV("pre specialize [%s]", ctx->process);

  FLAG_SET(ctx, SKIP_FD_SANITIZATION);
  rz_app_specialize_pre(ctx);
}

static void rz_nativeSpecializeAppProcess_post(struct zygisk_context *ctx) {
  LOGV("post specialize [%s]", ctx->process);
  rz_app_specialize_post(ctx);
}

static void rz_nativeForkSystemServer_pre(struct zygisk_context *ctx) {
  LOGV("pre forkSystemServer");
  FLAG_SET(ctx, SERVER_FORK_AND_SPECIALIZE);

  rz_fork_pre(ctx);
  if (!is_zygote_child(ctx)) return;

  rz_run_modules_pre(ctx);
  rezygiskd_system_server_started();

  rz_sanitize_fds(ctx);
}

static void rz_nativeForkSystemServer_post(struct zygisk_context *ctx) {
  if (ctx->pid == 0) {
    LOGV("post forkSystemServer");

    rz_run_modules_post(ctx);
  }

  rz_fork_post(ctx);
}

static void rz_nativeForkAndSpecialize_pre(struct zygisk_context *ctx) {
  ctx->process = (*ctx->env)->GetStringUTFChars(ctx->env, *ctx->args.app->nice_name, NULL);
  LOGV("pre forkAndSpecialize [%s]", ctx->process);
  FLAG_SET(ctx, APP_FORK_AND_SPECIALIZE);

  rz_fork_pre(ctx);
  if (!is_zygote_child(ctx)) return;

  rz_app_specialize_pre(ctx);
  rz_sanitize_fds(ctx);
}

static void rz_nativeForkAndSpecialize_post(struct zygisk_context *ctx) {
  if (ctx->pid == 0) {
    LOGV("post forkAndSpecialize [%s]", ctx->process);
    rz_app_specialize_post(ctx);
  }

  rz_fork_post(ctx);
}

static void rz_init(struct zygisk_context *ctx, JNIEnv *env, void *args) {
  memset(ctx, 0, sizeof(struct zygisk_context));

  ctx->env = env;
  ctx->args.ptr = args;
  ctx->pid = -1;
  pthread_mutex_init(&ctx->hook_info_lock, NULL);

  g_ctx = ctx;
}

static void rz_cleanup(struct zygisk_context *ctx) {
  g_ctx = NULL;

  if (!is_zygote_child(ctx)) return;

  should_unmap_zygisk = true;

  /* INFO: Unhook JNI methods */
  for (size_t i = 0; i < jni_hook_list_count; i++) {
    struct jni_hook_entry *entry = &jni_hook_list[i];
    jclass jc = (*ctx->env)->FindClass(ctx->env, entry->class_name);
    if (jc) {
      if (entry->methods_count > 0 && (*ctx->env)->RegisterNatives(ctx->env, jc, entry->methods, (jint)entry->methods_count) != 0) {
        LOGE("Failed to restore JNI hook of class [%s]", entry->class_name);

        should_unmap_zygisk = false;
      }

      (*ctx->env)->DeleteLocalRef(ctx->env, jc);
    }

    free(entry->class_name);
    free(entry->methods);
  }

  free(jni_hook_list);
  jni_hook_list = NULL;
  jni_hook_list_count = 0;
  jni_hook_list_capacity = 0;

  /* INFO: Strip out all API function pointers */
  for (size_t i = 0; i < zygisk_module_length; i++) {
    memset(&zygisk_modules[i], 0, sizeof(zygisk_modules[i]));
  }

  enable_unloader = true;
  pthread_mutex_destroy(&ctx->hook_info_lock);
}

/* INFO: PLT hook commit helper */
static bool hook_commit(struct lsplt_map_info *map_infos) {
  if (map_infos ? lsplt_commit_hook_manual(map_infos) : lsplt_commit_hook()) return true;
  else {
    LOGE("Failed to commit hook for %zu symbols", plt_hook_list_count);

    return false;
  }
}

static void hook_register(dev_t dev, ino_t inode, const char *symbol, bool is_prefix, void *new_func, void **old_func) {
  bool res = false;
  if (is_prefix) res = lsplt_register_hook_by_prefix(dev, inode, symbol, new_func, old_func);
  else res = lsplt_register_hook(dev, inode, symbol, new_func, old_func);

  if (!res) {
    LOGE("Failed to register plt_hook \"%s\"", symbol);

    return;
  }

  plt_hook_list_add(dev, inode, symbol, old_func);
}

#define PLT_HOOK_REGISTER_SYM(DEV, INODE, SYM, NAME, IS_PREFIX)                      \
  hook_register(DEV, INODE, SYM, IS_PREFIX, (void*)new_##NAME, (void **)&old_##NAME)

#define PLT_HOOK_REGISTER(DEV, INODE, NAME, IS_PREFIX)      \
  PLT_HOOK_REGISTER_SYM(DEV, INODE, #NAME, NAME, IS_PREFIX)

void hook_functions(void) {
  ino_t android_runtime_inode = 0;
  dev_t android_runtime_dev = 0;

  struct lsplt_map_info *map_infos = lsplt_scan_maps("self");
  if (!map_infos) {
    LOGE("Failed to scan maps for self");

    return;
  }

  for (size_t i = 0; i < map_infos->length; i++) {
    struct lsplt_map_entry map = map_infos->maps[i];

    if (!strstr(map.path, "libandroid_runtime.so")) continue;

    android_runtime_inode = map.inode;
    android_runtime_dev = map.dev;

    LOGD("Found libandroid_runtime.so at [%zu:%lu]", android_runtime_dev, android_runtime_inode);

    break;
  }

  PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, fork, false);
  PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, strdup, false);
  PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, property_get, false);
  PLT_HOOK_REGISTER_SYM(android_runtime_dev, android_runtime_inode, "_ZNK18FileDescriptorInfo14ReopenOrDetach", _ZNK18FileDescriptorInfo14ReopenOrDetach, true);

  if (!hook_commit(map_infos)) {
    plt_hook_list_count = 0;

    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, fork, false);
    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, strdup, false);
    PLT_HOOK_REGISTER(android_runtime_dev, android_runtime_inode, property_get, false);

    if (hook_commit(map_infos)) {
      LOGW("Hooked without ReopenOrDetach hook! Umounting overlays will cause problems");
    } else {
      LOGE("Failed to hook neccessary symbols to function");
    }
  }

  lsplt_free_maps(map_infos);
}

static void hook_unloader(void) {
  if (hooked_unloader) return;
  hooked_unloader = true;

  ino_t art_inode = 0;
  dev_t art_dev = 0;

  struct lsplt_map_info *map_infos = lsplt_scan_maps("self");
  if (!map_infos) {
    LOGE("Failed to scan maps for self");

    return;
  }

  for (size_t i = 0; i < map_infos->length; i++) {
    struct lsplt_map_entry *map = &map_infos->maps[i];
    if (!strstr(map->path, "/libart.so")) continue;

    art_inode = map->inode;
    art_dev = map->dev;

    LOGD("Found libart.so at [%zu:%lu]", art_dev, art_inode);

    break;
  }

  if (art_dev == 0 || art_inode == 0) {
    LOGE("Could not find libart.so. Unloader hook failed");

    hooked_unloader = false;
  } else {
    LOGD("Successfully found libart.so [%zu:%lu] for ReZygisk unloading", art_dev, art_inode);

    PLT_HOOK_REGISTER(art_dev, art_inode, pthread_attr_setstacksize, false);
    hook_commit(map_infos);
  }

  lsplt_free_maps(map_infos);

    /* INFO: Load modules early on (before system server fork) to spread through all Zygotes */
  if (!modules_loaded) {
    if (!load_modules_only()) {
      LOGE("Failed to load modules in hook_unloader");
    } else modules_loaded = true;
  }
}

static void unhook_functions(void) {
  /* INFO: Unhook plt_hook */
  for (size_t i = 0; i < plt_hook_list_count; i++) {
    struct plt_hook_entry *entry = &plt_hook_list[i];
    if (!lsplt_register_hook(entry->dev, entry->inode, entry->symbol, *entry->old_func, NULL)) {
      LOGE("Failed to register plt_hook [%s]", entry->symbol);
    }
  }

  free(plt_hook_list);
  plt_hook_list = NULL;
  plt_hook_list_count = 0;
  plt_hook_list_capacity = 0;

  if (!hook_commit(NULL)) {
    LOGE("Failed to restore plt_hook");

    should_unmap_zygisk = false;
  }
}

```

`loader/src/injector/hook.h`:

```h
#ifndef ZYGISK_H
#define ZYGISK_H

#include <stddef.h>

extern void *start_addr;
extern size_t block_size;

void hook_functions(void);

#endif /* ZYGISK_H */

```

`loader/src/injector/jni_hooks.h`:

```h
/* Generated by gen_jni_hooks.py */
#ifndef JNI_HOOKS_H
#define JNI_HOOKS_H


static void *nativeForkAndSpecialize_orig = NULL;
typedef jint (*nativeForkAndSpecialize_fn)(JNIEnv *, jclass, ...);
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_l(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, instruction_set, app_data_dir
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_o(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, instruction_set, app_data_dir
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_p(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_q_alt(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_r(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_u(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  args.mount_sysprop_overrides = &mount_sysprop_overrides;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_samsung_m(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _0, jint _1, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _0, _1, nice_name, fds_to_close, instruction_set, app_data_dir
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_samsung_n(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _2, jint _3, jstring nice_name, jintArray fds_to_close, jstring instruction_set, jstring app_data_dir, jint _4) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _2, _3, nice_name, fds_to_close, instruction_set, app_data_dir, _4
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_samsung_o(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _5, jint _6, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _5, _6, nice_name, fds_to_close, fds_to_ignore, instruction_set, app_data_dir
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_samsung_p(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _7, jint _8, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _7, _8, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_samsung_b(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean _9, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  args.mount_sysprop_overrides = &mount_sysprop_overrides;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, _9, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkAndSpecialize_grapheneos_u(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray fds_to_close, jintArray fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides, jlongArray _14) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.fds_to_ignore = &fds_to_ignore;
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  args.mount_sysprop_overrides = &mount_sysprop_overrides;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkAndSpecialize_pre(&ctx);
  ((nativeForkAndSpecialize_fn)nativeForkAndSpecialize_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, fds_to_close, fds_to_ignore, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides, _14
  );
  rz_nativeForkAndSpecialize_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
static JNINativeMethod nativeForkAndSpecialize_methods[12] = {
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[ILjava/lang/String;Ljava/lang/String;)I",
    (void *) &nativeForkAndSpecialize_l
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[ILjava/lang/String;Ljava/lang/String;)I",
    (void *) &nativeForkAndSpecialize_o
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;)I",
    (void *) &nativeForkAndSpecialize_p
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z)I",
    (void *) &nativeForkAndSpecialize_q_alt
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZ)I",
    (void *) &nativeForkAndSpecialize_r
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZ)I",
    (void *) &nativeForkAndSpecialize_u
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;IILjava/lang/String;[ILjava/lang/String;Ljava/lang/String;)I",
    (void *) &nativeForkAndSpecialize_samsung_m
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;IILjava/lang/String;[ILjava/lang/String;Ljava/lang/String;I)I",
    (void *) &nativeForkAndSpecialize_samsung_n
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;IILjava/lang/String;[I[ILjava/lang/String;Ljava/lang/String;)I",
    (void *) &nativeForkAndSpecialize_samsung_o
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;IILjava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;)I",
    (void *) &nativeForkAndSpecialize_samsung_p
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;ZZ[Ljava/lang/String;[Ljava/lang/String;ZZZ)I",
    (void *) &nativeForkAndSpecialize_samsung_b
  },
  {
    "nativeForkAndSpecialize",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZ[J)I",
    (void *) &nativeForkAndSpecialize_grapheneos_u
  },
};
static const int nativeForkAndSpecialize_methods_count = 12;

static void *nativeSpecializeAppProcess_orig = NULL;
typedef void (*nativeSpecializeAppProcess_fn)(JNIEnv *, jclass, ...);
__attribute__((no_stack_protector)) static void nativeSpecializeAppProcess_q(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.is_child_zygote = &is_child_zygote;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeSpecializeAppProcess_pre(&ctx);
  ((nativeSpecializeAppProcess_fn)nativeSpecializeAppProcess_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir
  );
  rz_nativeSpecializeAppProcess_post(&ctx);
  rz_cleanup(&ctx);
}
__attribute__((no_stack_protector)) static void nativeSpecializeAppProcess_q_alt(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeSpecializeAppProcess_pre(&ctx);
  ((nativeSpecializeAppProcess_fn)nativeSpecializeAppProcess_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app
  );
  rz_nativeSpecializeAppProcess_post(&ctx);
  rz_cleanup(&ctx);
}
__attribute__((no_stack_protector)) static void nativeSpecializeAppProcess_r(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeSpecializeAppProcess_pre(&ctx);
  ((nativeSpecializeAppProcess_fn)nativeSpecializeAppProcess_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs
  );
  rz_nativeSpecializeAppProcess_post(&ctx);
  rz_cleanup(&ctx);
}
__attribute__((no_stack_protector)) static void nativeSpecializeAppProcess_u(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  args.mount_sysprop_overrides = &mount_sysprop_overrides;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeSpecializeAppProcess_pre(&ctx);
  ((nativeSpecializeAppProcess_fn)nativeSpecializeAppProcess_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides
  );
  rz_nativeSpecializeAppProcess_post(&ctx);
  rz_cleanup(&ctx);
}
__attribute__((no_stack_protector)) static void nativeSpecializeAppProcess_samsung_q(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jint _10, jint _11, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.is_child_zygote = &is_child_zygote;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeSpecializeAppProcess_pre(&ctx);
  ((nativeSpecializeAppProcess_fn)nativeSpecializeAppProcess_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, _10, _11, nice_name, is_child_zygote, instruction_set, app_data_dir
  );
  rz_nativeSpecializeAppProcess_post(&ctx);
  rz_cleanup(&ctx);
}
__attribute__((no_stack_protector)) static void nativeSpecializeAppProcess_grapheneos_u(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs, jboolean mount_sysprop_overrides, jlongArray _15) {
  struct app_specialize_args_v5 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .rlimits = &rlimits, .mount_external = &mount_external, .se_info = &se_info, .nice_name = &nice_name, .instruction_set = &instruction_set, .app_data_dir = &app_data_dir };
  args.is_child_zygote = &is_child_zygote;
  args.is_top_app = &is_top_app;
  args.pkg_data_info_list = &pkg_data_info_list;
  args.whitelisted_data_info_list = &whitelisted_data_info_list;
  args.mount_data_dirs = &mount_data_dirs;
  args.mount_storage_dirs = &mount_storage_dirs;
  args.mount_sysprop_overrides = &mount_sysprop_overrides;
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeSpecializeAppProcess_pre(&ctx);
  ((nativeSpecializeAppProcess_fn)nativeSpecializeAppProcess_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, mount_external, se_info, nice_name, is_child_zygote, instruction_set, app_data_dir, is_top_app, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs, mount_storage_dirs, mount_sysprop_overrides, _15
  );
  rz_nativeSpecializeAppProcess_post(&ctx);
  rz_cleanup(&ctx);
}
static JNINativeMethod nativeSpecializeAppProcess_methods[6] = {
  {
    "nativeSpecializeAppProcess",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;)V",
    (void *) &nativeSpecializeAppProcess_q
  },
  {
    "nativeSpecializeAppProcess",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z)V",
    (void *) &nativeSpecializeAppProcess_q_alt
  },
  {
    "nativeSpecializeAppProcess",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZ)V",
    (void *) &nativeSpecializeAppProcess_r
  },
  {
    "nativeSpecializeAppProcess",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZ)V",
    (void *) &nativeSpecializeAppProcess_u
  },
  {
    "nativeSpecializeAppProcess",
    "(II[II[[IILjava/lang/String;IILjava/lang/String;ZLjava/lang/String;Ljava/lang/String;)V",
    (void *) &nativeSpecializeAppProcess_samsung_q
  },
  {
    "nativeSpecializeAppProcess",
    "(II[II[[IILjava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;[Ljava/lang/String;ZZZ[J)V",
    (void *) &nativeSpecializeAppProcess_grapheneos_u
  },
};
static const int nativeSpecializeAppProcess_methods_count = 6;

static void *nativeForkSystemServer_orig = NULL;
typedef jint (*nativeForkSystemServer_fn)(JNIEnv *, jclass, ...);
__attribute__((no_stack_protector)) static jint nativeForkSystemServer_l(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) {
  struct server_specialize_args_v1 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .permitted_capabilities = &permitted_capabilities, .effective_capabilities = &effective_capabilities };
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkSystemServer_pre(&ctx);
  ((nativeForkSystemServer_fn)nativeForkSystemServer_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, permitted_capabilities, effective_capabilities
  );
  rz_nativeForkSystemServer_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkSystemServer_samsung_q(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jint _12, jint _13, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) {
  struct server_specialize_args_v1 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .permitted_capabilities = &permitted_capabilities, .effective_capabilities = &effective_capabilities };
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkSystemServer_pre(&ctx);
  ((nativeForkSystemServer_fn)nativeForkSystemServer_orig)(
    env, clazz, uid, gid, gids, runtime_flags, _12, _13, rlimits, permitted_capabilities, effective_capabilities
  );
  rz_nativeForkSystemServer_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
__attribute__((no_stack_protector)) static jint nativeForkSystemServer_grapheneos_u(JNIEnv *env, jclass clazz, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) {
  struct server_specialize_args_v1 args = { .uid = &uid, .gid = &gid, .gids = &gids, .runtime_flags = &runtime_flags, .permitted_capabilities = &permitted_capabilities, .effective_capabilities = &effective_capabilities };
  struct zygisk_context ctx;
  rz_init(&ctx, env, &args);
  rz_nativeForkSystemServer_pre(&ctx);
  ((nativeForkSystemServer_fn)nativeForkSystemServer_orig)(
    env, clazz, uid, gid, gids, runtime_flags, rlimits, permitted_capabilities, effective_capabilities
  );
  rz_nativeForkSystemServer_post(&ctx);
  rz_cleanup(&ctx);
  return ctx.pid;
}
static JNINativeMethod nativeForkSystemServer_methods[3] = {
  {
    "nativeForkSystemServer",
    "(II[II[[IJJ)I",
    (void *) &nativeForkSystemServer_l
  },
  {
    "nativeForkSystemServer",
    "(II[IIII[[IJJ)I",
    (void *) &nativeForkSystemServer_samsung_q
  },
  {
    "nativeForkSystemServer",
    "(II[II[[IJJ)I",
    (void *) &nativeForkSystemServer_grapheneos_u
  },
};
static const int nativeForkSystemServer_methods_count = 3;

static void do_hook_zygote(JNIEnv *env) {
  JNINativeMethod hooks[3];
  int hooks_count = 0;

  const char *clz = "com/android/internal/os/Zygote";
  hook_jni_methods(env, clz, nativeForkAndSpecialize_methods, nativeForkAndSpecialize_methods_count);
  for (int i = 0; i < nativeForkAndSpecialize_methods_count; i++) {
    if (!nativeForkAndSpecialize_methods[i].fnPtr) continue;

    nativeForkAndSpecialize_orig = nativeForkAndSpecialize_methods[i].fnPtr;
    hooks[hooks_count++] = nativeForkAndSpecialize_methods[i];

    break;
  }

  hook_jni_methods(env, clz, nativeSpecializeAppProcess_methods, nativeSpecializeAppProcess_methods_count);
  for (int i = 0; i < nativeSpecializeAppProcess_methods_count; i++) {
    if (!nativeSpecializeAppProcess_methods[i].fnPtr) continue;

    nativeSpecializeAppProcess_orig = nativeSpecializeAppProcess_methods[i].fnPtr;
    hooks[hooks_count++] = nativeSpecializeAppProcess_methods[i];

    break;
  }

  hook_jni_methods(env, clz, nativeForkSystemServer_methods, nativeForkSystemServer_methods_count);
  for (int i = 0; i < nativeForkSystemServer_methods_count; i++) {
    if (!nativeForkSystemServer_methods[i].fnPtr) continue;

    nativeForkSystemServer_orig = nativeForkSystemServer_methods[i].fnPtr;
    hooks[hooks_count++] = nativeForkSystemServer_methods[i];

    break;
  }

  jni_hook_list_add(clz, hooks, hooks_count);
}

#endif /* JNI_HOOKS_H */

```

`loader/src/injector/module.h`:

```h
#ifndef MODULE_H
#define MODULE_H

#include <string.h>

#include <jni.h>

#include <csoloader.h>

#include "logging.h"

#define REZYGISK_API_VERSION 5

enum rezygiskd_flags : uint32_t {
  PROCESS_GRANTED_ROOT = (1u << 0),
  PROCESS_ON_DENYLIST = (1u << 1),

  PROCESS_IS_MANAGER = (1u << 27),
  PROCESS_ROOT_IS_APATCH = (1u << 28),
  PROCESS_ROOT_IS_KSU = (1u << 29),
  PROCESS_ROOT_IS_MAGISK = (1u << 30),
  PROCESS_IS_FIRST_STARTED = (1u << 31),

  PRIVATE_MASK = PROCESS_IS_FIRST_STARTED
};

struct app_specialize_args_v1 {
  jint *uid;
  jint *gid;
  jintArray *gids;
  jint *runtime_flags;
  jint *mount_external;
  jstring *se_info;
  jstring *nice_name;
  jstring *instruction_set;
  jstring *app_data_dir;

  jboolean *is_child_zygote;
  jboolean *is_top_app;
  jobjectArray *pkg_data_info_list;
  jobjectArray *whitelisted_data_info_list;
  jboolean *mount_data_dirs;
  jboolean *mount_storage_dirs;
};

struct app_specialize_args_v4 {
  jint *uid;
  jint *gid;
  jintArray *gids;
  jint *runtime_flags;
  jobjectArray *rlimits;
  jint *mount_external;
  jstring *se_info;
  jstring *nice_name;
  jstring *instruction_set;
  jstring *app_data_dir;

  jintArray *fds_to_ignore;
  jboolean *is_child_zygote;
  jboolean *is_top_app;
  jobjectArray *pkg_data_info_list;
  jobjectArray *whitelisted_data_info_list;
  jboolean *mount_data_dirs;
  jboolean *mount_storage_dirs;
};

struct app_specialize_args_v5 {
  jint *uid;
  jint *gid;
  jintArray *gids;
  jint *runtime_flags;
  jobjectArray *rlimits;
  jint *mount_external;
  jstring *se_info;
  jstring *nice_name;
  jstring *instruction_set;
  jstring *app_data_dir;

  jintArray *fds_to_ignore;
  jboolean *is_child_zygote;
  jboolean *is_top_app;
  jobjectArray *pkg_data_info_list;
  jobjectArray *whitelisted_data_info_list;
  jboolean *mount_data_dirs;
  jboolean *mount_storage_dirs;

  jboolean *mount_sysprop_overrides;
};

struct server_specialize_args_v1 {
  jint *uid;
  jint *gid;
  jintArray *gids;
  jint *runtime_flags;
  jlong *permitted_capabilities;
  jlong *effective_capabilities;
};

enum rezygisk_options {
  /* INFO: Force ReZygisk to umount the root related mounts on this process. This option
             will only take effect if set in pre...Specialize, as ReZygisk umounts at
             that point.

           ReZygisk Umount System will not umount all root related mounts, read ReZygiskd
             umount_root function in utils.c file to understand how it selects the ones
             to umount.
  */
  FORCE_DENYLIST_UNMOUNT = 0,

  /* INFO: Once set, ReZygisk will dlclose your library from the process, this is assured to
             happen after post...Specialize, but not at a specific moment due to different
             implementations.

           You should not use this option if you leave references in the process such as hooks,
             which will try to execute uninitialized memory.
  */
  DLCLOSE_MODULE_LIBRARY = 1
};

struct rezygisk_abi {
  long api_version;
  void *impl;

  void (*pre_app_specialize)(void *, void *);
  void (*post_app_specialize)(void *, const void *);
  void (*pre_server_specialize)(void *, void *);
  void (*post_server_specialize)(void *, const void *);
};

struct rezygisk_api {
  void *impl;
  bool (*register_module)(struct rezygisk_api *, struct rezygisk_abi const *);

  void (*hook_jni_native_methods)(JNIEnv *, const char *, JNINativeMethod *, int);
  union {
    void (*plt_hook_register)(const char *, const char *, void *, void **);    /* INFO: v3 and below */
    void (*plt_hook_register_v4)(dev_t, ino_t, const char *, void *, void **); /* INFO: v4 */
  };
  union {
    void (*plt_hook_exclude)(const char *, const char *); /* INFO: v3 and below */
    void (*exempt_fd)(int);                               /* INFO: v4 */
  };

  bool (*plt_hook_commit)();
  int (*connect_companion)(void *);
  void (*set_option)(void *, enum rezygisk_options opt);
  int (*get_module_dir)(void *);
  uint32_t (*get_flags)();
};

struct rezygisk_module {
  struct rezygisk_abi abi;
  struct rezygisk_api api;

  struct csoloader lib;
  void (*zygisk_module_entry)(void *, void *);

  bool unload;
};

/*
    INFO: What follows are function definitions to be included wherever necessary.
            As a reminder for best C practices, a function body should not be in a header
            since they lead to ODR violations, resulting in UB since the compiled code *can* have duplicate defintions.
            Therefore, we have only ONE of two choices:
              1. Put the function declarations here and their respective definitions in a separate .c file;
              2. Inline these function definitions in the header so as to allow multiple definitions.
          Doing otherwise, clang-tidy throws 'definitions-in-headers' warning.

    SOURCES:
     - https://clang.llvm.org/extra/clang-tidy/checks/misc/definitions-in-headers.html
*/
static inline void rz_module_call_on_load(struct rezygisk_module *m, void *env) {
  m->zygisk_module_entry((void *)&m->api, env);
}

static inline void rz_module_call_pre_app_specialize(struct rezygisk_module *m, struct app_specialize_args_v5 *args) {
  switch (m->abi.api_version) {
    case 1:
    case 2: {
      struct app_specialize_args_v1 versioned_args = {
        .uid = args->uid,
        .gid = args->gid,
        .gids = args->gids,
        .runtime_flags = args->runtime_flags,
        .mount_external = args->mount_external,
        .se_info = args->se_info,
        .nice_name = args->nice_name,
        .instruction_set = args->instruction_set,
        .app_data_dir = args->app_data_dir,
        .is_child_zygote = args->is_child_zygote,
        .is_top_app = args->is_top_app,
        .pkg_data_info_list = args->pkg_data_info_list,
        .whitelisted_data_info_list = args->whitelisted_data_info_list,
        .mount_data_dirs = args->mount_data_dirs,
        .mount_storage_dirs = args->mount_storage_dirs
      };

      m->abi.pre_app_specialize(m->abi.impl, &versioned_args);

      break;
    }
    case 3:
    case 4: {
      struct app_specialize_args_v4 versioned_args;
      memcpy(&versioned_args, args, sizeof(struct app_specialize_args_v4));

      m->abi.pre_app_specialize(m->abi.impl, &versioned_args);

      break;
    }
    case 5: {
      m->abi.pre_app_specialize(m->abi.impl, args);

      break;
    }
  }
}

static inline void rz_module_call_post_app_specialize(struct rezygisk_module *m, const struct app_specialize_args_v5 *args) {
  switch (m->abi.api_version) {
    case 1:
    case 2: {
      struct app_specialize_args_v1 versioned_args = {
        .uid = args->uid,
        .gid = args->gid,
        .gids = args->gids,
        .runtime_flags = args->runtime_flags,
        .mount_external = args->mount_external,
        .se_info = args->se_info,
        .nice_name = args->nice_name,
        .instruction_set = args->instruction_set,
        .app_data_dir = args->app_data_dir,
        .is_child_zygote = args->is_child_zygote,
        .is_top_app = args->is_top_app,
        .pkg_data_info_list = args->pkg_data_info_list,
        .whitelisted_data_info_list = args->whitelisted_data_info_list,
        .mount_data_dirs = args->mount_data_dirs,
        .mount_storage_dirs = args->mount_storage_dirs
      };

      m->abi.post_app_specialize(m->abi.impl, &versioned_args);

      break;
    }
    case 3:
    case 4: {
      struct app_specialize_args_v4 versioned_args;
      memcpy(&versioned_args, args, sizeof(struct app_specialize_args_v4));

      m->abi.post_app_specialize(m->abi.impl, &versioned_args);

      break;
    }
    case 5: {
      m->abi.post_app_specialize(m->abi.impl, args);

      break;
    }
  }
}

static inline void rz_module_call_pre_server_specialize(struct rezygisk_module *m, struct server_specialize_args_v1 *args) {
  m->abi.pre_server_specialize(m->abi.impl, args);
}

static inline void rz_module_call_post_server_specialize(struct rezygisk_module *m, const struct server_specialize_args_v1 *args) {
  m->abi.post_server_specialize(m->abi.impl, args);
}

#endif /* MODULE_H */

```

`loader/src/injector/ptrace_clear.c`:

```c
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/audit.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include "logging.h"

static bool seccomp_filters_visible() {
  FILE *status_file = fopen("/proc/self/status", "r");
  if (!status_file) {
    PLOGE("open /proc/self/status");

    return true;
  }

  char line[256];
  while (fgets(line, sizeof(line), status_file)) {
    if (strncmp(line, "Seccomp_filters:", strlen("Seccomp_filters:")) != 0) continue;

    fclose(status_file);

    return true;
  }

  fclose(status_file);

  return false;
}

void perform_ptrace_message_clear() {
  /* INFO: Since kernel 5.10, Seccomp filters are visible, making hiding via seccomp event unusable */
  if (seccomp_filters_visible()) {
    LOGD("Seccomp filters are visible, skipping using hiding via seccomp event");

    return;
  }

  int rnd_fd = open("/dev/urandom", O_RDONLY);
  if (rnd_fd == -1) {
    PLOGE("open /dev/urandom");

    return;
  }

  uint32_t args[4] = { 0 };
  if (read(rnd_fd, &args, sizeof(args)) != sizeof(args)) {
    PLOGE("read /dev/urandom");

    close(rnd_fd);

    return;
  }

  close(rnd_fd);

  args[0] |= 0x10000;

  struct sock_filter filter[] = {
    /* INFO: Check syscall number */
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, nr)),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_exit_group, 0, 9),

    /* INFO: Load and check arg0 (lower 32 bits) */
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, args[0], 0, 7),

    /* INFO: Load and check arg1 (lower 32 bits) */
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, args[1], 0, 5),

    /* INFO: Load and check arg2 (lower 32 bits) */
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, args[2], 0, 3),

    /* INFO: Load and check arg3 (lower 32 bits) */
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[3])),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, args[3], 0, 1),

    /* INFO: All match: return TRACE => will trigger PTRACE_EVENT_SECCOMP */
    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_TRACE),

    /* INFO: Default: allow */
    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
  };

  struct sock_fprog prog = {
    .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
    .filter = filter,
  };

  if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {
    PLOGE("prctl(SECCOMP)");

    return;
  }

  /* INFO: This will trigger a ptrace event, syscall will not execute due to tracee_skip_syscall */
  syscall(__NR_exit_group, args[0], args[1], args[2], args[3]);
}

```

`loader/src/injector/ptrace_clear.h`:

```h
#ifndef PTRACE_CLEAR_H
#define PTRACE_CLEAR_H

void perform_ptrace_message_clear(void);

#endif /* PTRACE_CLEAR_H */
```

`loader/src/ptracer/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>

#include "utils.h"
#include "monitor.h"
#include "daemon.h"

int main(int argc, char **argv) {
  printf("The ReZygisk Tracer %s\n\n", ZKSU_VERSION);

  if (argc >= 2 && strcmp(argv[1], "monitor") == 0) {
    init_monitor();

    return 0;
  } else if (argc >= 3 && strcmp(argv[1], "trace") == 0) {
      if (argc >= 4 && strcmp(argv[3], "--restart") == 0) rezygiskd_zygote_restart();

      long pid = strtol(argv[2], 0, 0);
      if (!trace_zygote(pid)) {
        kill(pid, SIGKILL);

        return 1;
      }

      return 0;
  } else if (argc >= 2 && strcmp(argv[1], "ctl") == 0) {
    enum rezygiskd_command command;

    if (strcmp(argv[2], "start") == 0) command = START;
    else if (strcmp(argv[2], "stop") == 0) command = STOP;
    else if (strcmp(argv[2], "exit") == 0) command = EXIT;
    else {
      printf("[ReZygisk]: Usage: %s ctl <start|stop|exit>\n", argv[0]);

      return 1;
    }

    if (send_control_command(command) == -1) {
      printf("[ReZygisk]: Failed to send the command, is the daemon running?\n");

      return 1;
    }

    printf("[ReZygisk]: command sent\n");

    return 0;
  } else if (argc >= 2 && strcmp(argv[1], "version") == 0) {
    /* INFO: Noop*/

    return 0;
  } else if (argc >= 2 && strcmp(argv[1], "info") == 0) {
    struct rezygisk_info info;
    rezygiskd_get_info(&info);

    printf("Daemon process PID: %d\n", info.pid);

    switch (info.root_impl) {
      case ROOT_IMPL_NONE: {
        printf("Root implementation: none\n");

        break;
      }
      case ROOT_IMPL_APATCH: {
        printf("Root implementation: APatch\n");

        break;
      }
      case ROOT_IMPL_KERNELSU: {
        printf("Root implementation: KernelSU\n");

        break;
      }
      case ROOT_IMPL_MAGISK: {
        printf("Root implementation: Magisk\n");

        break;
      }
    }

    if (info.modules.modules_count != 0) {
      printf("Modules: %zu\n", info.modules.modules_count);

      for (size_t i = 0; i < info.modules.modules_count; i++) {
        printf(" - %s\n", info.modules.modules[i]);
      }
    } else {
      printf("Modules: N/A\n");
    }

    free_rezygisk_info(&info);

    return 0;
  } else {
    printf(
      "Available commands:\n"
      " - monitor\n"
      " - trace <pid> [--restart]\n"
      " - ctl <start|stop|exit>\n"
      " - version: Shows the version of ReZygisk.\n"
      " - info: Shows information about the created daemon/injection.\n"
      "\n"
      "<...>: Obligatory\n"
      "[...]: Optional\n");

    return 1;
  }
}

```

`loader/src/ptracer/monitor.c`:

```c
#include <stdlib.h>

#include <time.h>

#include <sys/system_properties.h>
#include <sys/signalfd.h>
#include <err.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/epoll.h>
#include <sys/wait.h>
#include <sys/mount.h>
#include <fcntl.h>

#include <unistd.h>

#include "utils.h"
#include "daemon.h"
#include "misc.h"
#include "socket_utils.h"

#include "monitor.h"

#define PROP_PATH TMP_PATH "/module.prop"
#define SOCKET_NAME "init_monitor"

#define STOPPED_WITH(sig, event) WIFSTOPPED(sigchld_status) && (sigchld_status >> 8 == ((sig) | (event << 8)))

static bool update_status(const char *message);

char monitor_stop_reason[32];

struct environment_information {
  char *root_impl;
  char **modules;
  uint32_t modules_len;
};

static struct environment_information environment_information64;
static struct environment_information environment_information32;

enum ptracer_tracing_state {
  TRACING,
  STOPPING,
  STOPPED,
  EXITING
};

enum ptracer_tracing_state tracing_state = TRACING;

struct rezygiskd_status {
  bool supported;
  bool zygote_injected;
  bool daemon_running;
  pid_t daemon_pid;
  char *daemon_info;
  char *daemon_error_info;
};

struct rezygiskd_status status64 = {
  .supported = false,
  .zygote_injected = false,
  .daemon_running = false,
  .daemon_pid = -1,
  .daemon_info = NULL,
  .daemon_error_info = NULL
};
struct rezygiskd_status status32 = {
  .supported = false,
  .zygote_injected = false,
  .daemon_running = false,
  .daemon_pid = -1,
  .daemon_info = NULL,
  .daemon_error_info = NULL
};

int monitor_epoll_fd;
bool monitor_events_running = true;
typedef void (*monitor_event_callback_t)();

bool monitor_events_init() {
  monitor_epoll_fd = epoll_create(1);
  if (monitor_epoll_fd == -1) {
    PLOGE("epoll_create");

    return false;
  }

  return true;
}

bool monitor_events_register_event(monitor_event_callback_t event_cb, int fd, uint32_t events) {
  struct epoll_event ev = {
    .data.ptr = (void *)event_cb,
    .events = events
  };

  if (epoll_ctl(monitor_epoll_fd, EPOLL_CTL_ADD, fd, &ev) == -1) {
    PLOGE("epoll_ctl");

    return false;
  }

  return true;
}

bool monitor_events_unregister_event(int fd) {
  if (epoll_ctl(monitor_epoll_fd, EPOLL_CTL_DEL, fd, NULL) == -1) {
    PLOGE("epoll_ctl");

    return false;
  }

  return true;
}

void monitor_events_stop() {
  monitor_events_running = false;
};

void monitor_events_loop() {
  struct epoll_event events[2];
  while (monitor_events_running) {
    int nfds = epoll_wait(monitor_epoll_fd, events, 2, -1);
    if (nfds == -1 && errno != EINTR) {
      PLOGE("epoll_wait");

      monitor_events_running = false;

      break;
    }

    for (int i = 0; i < nfds; i++) { 
      ((monitor_event_callback_t)events[i].data.ptr)();

      if (!monitor_events_running) break;
    }
  }

  if (monitor_epoll_fd >= 0) close(monitor_epoll_fd);
  monitor_epoll_fd = -1;
}

int monitor_sock_fd;

bool rezygiskd_listener_init() {
  monitor_sock_fd = socket(PF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);
  if (monitor_sock_fd == -1) {
    PLOGE("socket create");

    return false;
  }

  struct sockaddr_un addr = {
    .sun_family = AF_UNIX,
    .sun_path = { 0 }
  };

  size_t sun_path_len = sprintf(addr.sun_path, "%s/%s", rezygiskd_get_path(), SOCKET_NAME);

  socklen_t socklen = sizeof(sa_family_t) + sun_path_len;
  if (bind(monitor_sock_fd, (struct sockaddr *)&addr, socklen) == -1) {
    PLOGE("bind socket");

    return false;
  }

  return true;
}

void rezygiskd_listener_callback() {
  while (1) {
    uint8_t cmd;
    ssize_t nread = TEMP_FAILURE_RETRY(read(monitor_sock_fd, &cmd, sizeof(cmd)));
    if (nread == -1) {
      PLOGE("read socket");

      continue;
    }

    switch (cmd) {
      case START: {
        if (tracing_state == STOPPING) {
          LOGI("Continue tracing init");

          tracing_state = TRACING;
        } else if (tracing_state == STOPPED) {
          LOGI("Start tracing init");

          ptrace(PTRACE_SEIZE, 1, 0, PTRACE_O_TRACEFORK);

          tracing_state = TRACING;
        }

        update_status(NULL);

        break;
      }
      case STOP: {
        if (tracing_state == TRACING) {
          LOGI("Stop tracing requested");

          tracing_state = STOPPING;
          strcpy(monitor_stop_reason, "user requested");

          ptrace(PTRACE_INTERRUPT, 1, 0, 0);
          update_status(NULL);
        }

        break;
      }
      case EXIT: {
        LOGI("Prepare for exit ...");

        tracing_state = EXITING;
        strcpy(monitor_stop_reason, "user requested");

        update_status(NULL);
        monitor_events_stop();

        break;
      }
      case ZYGOTE64_INJECTED: 
      case ZYGOTE32_INJECTED: {
        LOGI("Received Zygote%s injected command", cmd == ZYGOTE64_INJECTED ? "64" : "32");

        struct rezygiskd_status *status = cmd == ZYGOTE64_INJECTED ? &status64 : &status32;
        status->zygote_injected = true;

        update_status(NULL);

        break;
      }
      case DAEMON64_SET_INFO:
      case DAEMON32_SET_INFO: {
        LOGD("Received ReZygiskd%s info", cmd == DAEMON64_SET_INFO ? "64" : "32");

        uint32_t root_impl_len;
        if (read_uint32_t(monitor_sock_fd, &root_impl_len) != sizeof(root_impl_len)) {
          LOGE("read ReZygiskd%s root impl len", cmd == DAEMON64_SET_INFO ? "64" : "32");

          break;
        }

        struct environment_information *environment_information = cmd == DAEMON64_SET_INFO ? &environment_information64 : &environment_information32;
        if (environment_information->root_impl) {
          LOGD("freeing old ReZygiskd%s root impl", cmd == DAEMON64_SET_INFO ? "64" : "32");

          free((void *)environment_information->root_impl);
          environment_information->root_impl = NULL;
        }

        environment_information->root_impl = malloc(root_impl_len + 1);
        if (environment_information->root_impl == NULL) {
          PLOGE("malloc ReZygiskd%s root impl", cmd == DAEMON64_SET_INFO ? "64" : "32");

          break;
        }

        if (read_loop(monitor_sock_fd, (void *)environment_information->root_impl, root_impl_len) != (ssize_t)root_impl_len) {
          LOGE("read ReZygiskd%s root impl", cmd == DAEMON64_SET_INFO ? "64" : "32");

          free((void *)environment_information->root_impl);
          environment_information->root_impl = NULL;

          break;
        }

        environment_information->root_impl[root_impl_len] = '\0';
        LOGD("ReZygiskd%s root impl: %s", cmd == DAEMON64_SET_INFO ? "64" : "32", environment_information->root_impl);

        if (read_uint32_t(monitor_sock_fd, &environment_information->modules_len) != sizeof(environment_information->modules_len)) {
          LOGE("read ReZygiskd%s modules len", cmd == DAEMON64_SET_INFO ? "64" : "32");

          free((void *)environment_information->root_impl);
          environment_information->root_impl = NULL;

          break;
        }

        if (environment_information->modules) {
          LOGD("freeing old ReZygiskd%s modules", cmd == DAEMON64_SET_INFO ? "64" : "32");

          for (size_t i = 0; i < environment_information->modules_len; i++) {
            free((void *)environment_information->modules[i]);
          }

          free((void *)environment_information->modules);
          environment_information->modules = NULL;
        }

        environment_information->modules = malloc(environment_information->modules_len * sizeof(char *));
        if (environment_information->modules == NULL) {
          PLOGE("malloc ReZygiskd%s modules", cmd == DAEMON64_SET_INFO ? "64" : "32");

          free((void *)environment_information->root_impl);
          environment_information->root_impl = NULL;

          break;
        }

        for (size_t i = 0; i < environment_information->modules_len; i++) {
          uint32_t module_name_len;
          if (read_uint32_t(monitor_sock_fd, &module_name_len) != sizeof(module_name_len)) {
            LOGE("read ReZygiskd%s module name len", cmd == DAEMON64_SET_INFO ? "64" : "32");

            goto rezygiskd64_set_info_modules_cleanup;
          }

          environment_information->modules[i] = malloc(module_name_len + 1);
          if (environment_information->modules[i] == NULL) {
            PLOGE("malloc ReZygiskd%s module name", cmd == DAEMON64_SET_INFO ? "64" : "32");

            goto rezygiskd64_set_info_modules_cleanup;
          }

          if (read_loop(monitor_sock_fd, (void *)environment_information->modules[i], module_name_len) != (ssize_t)module_name_len) {
            LOGE("read ReZygiskd%s module name", cmd == DAEMON64_SET_INFO ? "64" : "32");

            goto rezygiskd64_set_info_modules_cleanup;
          }

          environment_information->modules[i][module_name_len] = '\0';
          LOGD("ReZygiskd%s module %zu: %s", cmd == DAEMON64_SET_INFO ? "64" : "32", i, environment_information->modules[i]);

          continue;

          rezygiskd64_set_info_modules_cleanup:
            free((void *)environment_information->root_impl);
            environment_information->root_impl = NULL;

            for (size_t j = 0; j < i; j++) {
              free((void *)environment_information->modules[j]);
            }

            free((void *)environment_information->modules);
            environment_information->modules = NULL;

            break;
        }

        update_status(NULL);

        break;
      }
      case DAEMON64_SET_ERROR_INFO:
      case DAEMON32_SET_ERROR_INFO: {
        LOGD("Received ReZygiskd%s error info", cmd == DAEMON64_SET_ERROR_INFO ? "64" : "32");

        uint32_t error_info_len;
        if (read_uint32_t(monitor_sock_fd, &error_info_len) != sizeof(error_info_len)) {
          LOGE("read ReZygiskd%s error info len", cmd == DAEMON64_SET_ERROR_INFO ? "64" : "32");

          break;
        }

        struct rezygiskd_status *status = cmd == DAEMON64_SET_ERROR_INFO ? &status64 : &status32;
        if (status->daemon_error_info) {
          LOGD("freeing old ReZygiskd%s error info", cmd == DAEMON64_SET_ERROR_INFO ? "64" : "32");

          free(status->daemon_error_info);
          status->daemon_error_info = NULL;
        }

        status->daemon_error_info = malloc(error_info_len + 1);
        if (status->daemon_error_info == NULL) {
          PLOGE("malloc ReZygiskd%s error info", cmd == DAEMON64_SET_ERROR_INFO ? "64" : "32");

          break;
        }

        if (read_loop(monitor_sock_fd, status->daemon_error_info, error_info_len) != (ssize_t)error_info_len) {
          LOGE("read ReZygiskd%s error info", cmd == DAEMON64_SET_ERROR_INFO ? "64" : "32");

          free(status->daemon_error_info);
          status->daemon_error_info = NULL;

          break;
        }

        status->daemon_error_info[error_info_len] = '\0';
        LOGD("ReZygiskd%s error info: %s", cmd == DAEMON64_SET_ERROR_INFO ? "64" : "32", status->daemon_error_info);

        update_status(NULL);

        break;
      }
      case SYSTEM_SERVER_STARTED: {
        LOGD("system server started, mounting prop");

        if (mount(PROP_PATH, "/data/adb/modules/rezygisk/module.prop", NULL, MS_BIND, NULL) == -1) {
          PLOGE("failed to mount prop");
        }

        break;
      }
    }

    break;
  }
}

void rezygiskd_listener_stop() {
  if (monitor_sock_fd >= 0) close(monitor_sock_fd);
  monitor_sock_fd = -1;
}

#define MAX_RETRY_COUNT 5

#define CREATE_ZYGOTE_START_COUNTER(abi)             \
  struct timespec last_zygote##abi = {               \
    .tv_sec = 0,                                     \
    .tv_nsec = 0                                     \
  };                                                 \
                                                     \
  int count_zygote ## abi = 0;                       \
  bool should_stop_inject ## abi() {                 \
    struct timespec now = {};                        \
    clock_gettime(CLOCK_MONOTONIC, &now);            \
    if (now.tv_sec - last_zygote ## abi.tv_sec < 30) \
      count_zygote ## abi++;                         \
    else                                             \
      count_zygote ## abi = 0;                       \
                                                     \
    last_zygote##abi = now;                          \
                                                     \
    return count_zygote##abi >= MAX_RETRY_COUNT;     \
  }

CREATE_ZYGOTE_START_COUNTER(64)
CREATE_ZYGOTE_START_COUNTER(32)

static bool ensure_daemon_created(bool is_64bit) {
  struct rezygiskd_status *status = is_64bit ? &status64 : &status32;

  if (is_64bit || (!is_64bit && !status64.supported)) {
    LOGD("new zygote started.");

    umount2("/data/adb/modules/rezygisk/module.prop", MNT_DETACH);
  }

  if (status->daemon_pid != -1) {
    LOGI("daemon%s already running", is_64bit ? "64" : "32");

    return status->daemon_running;
  }

  pid_t pid = fork();
  if (pid < 0) {
    PLOGE("create daemon%s", is_64bit ? "64" : "32");

    return false;
  }

  if (pid == 0) {
    char daemon_name[PATH_MAX] = "./bin/zygiskd";
    strcat(daemon_name, is_64bit ? "64" : "32");

    execl(daemon_name, daemon_name, NULL);

    PLOGE("exec daemon %s failed", daemon_name);

    exit(1);
  }

  status->supported = true;
  status->daemon_pid = pid;
  status->daemon_running = true;

  return true;
}

#define CHECK_DAEMON_EXIT(abi)                                    \
  if (status##abi.supported && pid == status##abi.daemon_pid) {   \
    char status_str[64];                                          \
    parse_status(sigchld_status, status_str, sizeof(status_str)); \
                                                                  \
    LOGW("daemon" #abi " pid %d exited: %s", pid, status_str);    \
    status##abi.daemon_running = false;                           \
                                                                  \
    if (!status##abi.daemon_error_info) {                         \
      status##abi.daemon_error_info = strdup(status_str);         \
      if (!status##abi.daemon_error_info) {                       \
        LOGE("malloc daemon" #abi " error info failed");          \
                                                                  \
        return;                                                   \
      }                                                           \
    }                                                             \
                                                                  \
    continue;                                                     \
  }

#define PRE_INJECT(abi, is_64)                                        \
  if (strcmp(program, "/system/bin/app_process" # abi) == 0) {        \
    tracer = "./bin/zygisk-ptrace" # abi;                             \
                                                                      \
    if (should_stop_inject ## abi()) {                                \
      LOGW("Zygote" # abi " restart too much times, stop injecting"); \
                                                                      \
      tracing_state = STOPPING;                                       \
      strcpy(monitor_stop_reason, "Zygote crashed");                  \
      ptrace(PTRACE_INTERRUPT, 1, 0, 0);                              \
                                                                      \
      break;                                                          \
    }                                                                 \
                                                                      \
    if (!ensure_daemon_created(is_64)) {                              \
      LOGW("ReZygiskd " #abi "-bit not running, stop injecting");     \
                                                                      \
      tracing_state = STOPPING;                                       \
      strcpy(monitor_stop_reason, "ReZygiskd not running");           \
      ptrace(PTRACE_INTERRUPT, 1, 0, 0);                              \
                                                                      \
      break;                                                          \
    }                                                                 \
  }

int sigchld_signal_fd;
struct signalfd_siginfo sigchld_fdsi;
int sigchld_status;

pid_t *sigchld_process;
size_t sigchld_process_count = 0;

bool sigchld_listener_init() {
  sigchld_process = NULL;

  sigset_t mask;
  sigemptyset(&mask);
  sigaddset(&mask, SIGCHLD);

  if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {
    PLOGE("set sigprocmask");

    return false;
  }

  sigchld_signal_fd = signalfd(-1, &mask, SFD_NONBLOCK | SFD_CLOEXEC);
  if (sigchld_signal_fd == -1) {
    PLOGE("create signalfd");

    return false;
  }

  ptrace(PTRACE_SEIZE, 1, 0, PTRACE_O_TRACEFORK);

  return true;
}

void sigchld_listener_callback() {
  while (1) {
    ssize_t s = read(sigchld_signal_fd, &sigchld_fdsi, sizeof(sigchld_fdsi));
    if (s == -1) {
      if (errno == EAGAIN) break;

      PLOGE("read signalfd");

      continue;
    }

    if (s != sizeof(sigchld_fdsi)) {
      LOGW("read %zu != %zu", s, sizeof(sigchld_fdsi));

      continue;
    }

    if (sigchld_fdsi.ssi_signo != SIGCHLD) {
      LOGW("no sigchld received");

      continue;
    }

    int pid;
    while ((pid = waitpid(-1, &sigchld_status, __WALL | WNOHANG)) != 0) {
      if (pid == -1) {
        if (tracing_state == STOPPED && errno == ECHILD) break;
        PLOGE("waitpid");
      }

      if (pid == 1) {
        if (STOPPED_WITH(SIGTRAP, PTRACE_EVENT_FORK)) {
          long child_pid;

          ptrace(PTRACE_GETEVENTMSG, pid, 0, &child_pid);

          LOGV("forked %ld", child_pid);
        } else if (STOPPED_WITH(SIGTRAP, PTRACE_EVENT_STOP) && tracing_state == STOPPING) {
          if (ptrace(PTRACE_DETACH, 1, 0, 0) == -1) PLOGE("failed to detach init");

          tracing_state = STOPPED;

          LOGI("stop tracing init");

          continue;
        }

        if (WIFSTOPPED(sigchld_status)) {
          if (WPTEVENT(sigchld_status) == 0) {
            if (WSTOPSIG(sigchld_status) != SIGSTOP && WSTOPSIG(sigchld_status) != SIGTSTP && WSTOPSIG(sigchld_status) != SIGTTIN && WSTOPSIG(sigchld_status) != SIGTTOU) {
              LOGW("inject signal sent to init: %s %d", sigabbrev_np(WSTOPSIG(sigchld_status)), WSTOPSIG(sigchld_status));

              ptrace(PTRACE_CONT, pid, 0, WSTOPSIG(sigchld_status));

              continue;
            } else {
              LOGW("suppress stopping signal sent to init: %s %d", sigabbrev_np(WSTOPSIG(sigchld_status)), WSTOPSIG(sigchld_status));
            }
          }

          ptrace(PTRACE_CONT, pid, 0, 0);
        }

        continue;
      }

      CHECK_DAEMON_EXIT(64)
      CHECK_DAEMON_EXIT(32)

      pid_t state = 0;
      for (size_t i = 0; i < sigchld_process_count; i++) {
        if (sigchld_process[i] != pid) continue;

        state = sigchld_process[i];

        break;
      }

      if (state == 0) {
        LOGV("new process %d attached", pid);

        for (size_t i = 0; i < sigchld_process_count; i++) {
          if (sigchld_process[i] != 0) continue;

          sigchld_process[i] = pid;

          goto ptrace_process;
        }

        sigchld_process = (pid_t *)realloc(sigchld_process, sizeof(pid_t) * (sigchld_process_count + 1));
        if (sigchld_process == NULL) {
          PLOGE("realloc sigchld_process");

          continue;
        }

        sigchld_process[sigchld_process_count] = pid;
        sigchld_process_count++;

        ptrace_process:

        ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACEEXEC);
        ptrace(PTRACE_CONT, pid, 0, 0);

        continue;
      } else {
        if (STOPPED_WITH(SIGTRAP, PTRACE_EVENT_EXEC)) {
          char program[PATH_MAX];
          if (get_program(pid, program, sizeof(program)) == -1) {
            LOGW("failed to get program %d", pid);

            continue;
          }

          LOGV("%d program %s", pid, program);
          const char* tracer = NULL;

          do {
            if (tracing_state != TRACING) {
              LOGW("stop injecting %d because not tracing", pid);

              break;
            }

            PRE_INJECT(64, true)
            PRE_INJECT(32, false)

            if (tracer != NULL) {
              LOGD("stopping %d", pid);

              kill(pid, SIGSTOP);
              ptrace(PTRACE_CONT, pid, 0, 0);
              waitpid(pid, &sigchld_status, __WALL);

              if (STOPPED_WITH(SIGSTOP, 0)) {
                LOGD("detaching %d", pid);

                ptrace(PTRACE_DETACH, pid, 0, SIGSTOP);
                sigchld_status = 0;
                int p = fork_dont_care();

                if (p == 0) {
                  char pid_str[32];
                  sprintf(pid_str, "%d", pid);

                  execl(tracer, basename(tracer), "trace", pid_str, "--restart", NULL);

                  PLOGE("failed to exec, kill");

                  kill(pid, SIGKILL);
                  exit(1);
                } else if (p == -1) {
                  PLOGE("failed to fork, kill");

                  kill(pid, SIGKILL);
                }
              }
            }
          } while (false);
        } else {
          char status_str[64];
          parse_status(sigchld_status, status_str, sizeof(status_str));

          LOGW("process %d received unknown sigchld_status %s", pid, status_str);
        }

        for (size_t i = 0; i < sigchld_process_count; i++) {
          if (sigchld_process[i] != pid) continue;

          sigchld_process[i] = 0;

          break;
        }

        if (WIFSTOPPED(sigchld_status)) {
          LOGV("detach process %d", pid);

          ptrace(PTRACE_DETACH, pid, 0, 0);
        }
      }
    }
  }
}

void sigchld_listener_stop() {
  if (sigchld_signal_fd >= 0) close(sigchld_signal_fd);
  sigchld_signal_fd = -1;

  if (sigchld_process != NULL) free(sigchld_process);
  sigchld_process = NULL;
  sigchld_process_count = 0;
}

static char pre_section[1024];
static char post_section[1024];

#define WRITE_STATUS_ABI(suffix)                                                     \
  if (status ## suffix.supported) {                                                  \
    strcat(status_text, ", ReZygisk " # suffix "-bit: ");                            \
                                                                                     \
    if (tracing_state != TRACING) strcat(status_text, "❌");                         \
    else if (status ## suffix.zygote_injected && status ## suffix.daemon_running)    \
      strcat(status_text, "✅");                                                     \
    else strcat(status_text, "⚠️");                                                  \
                                                                                     \
    if (!status ## suffix.daemon_running) {                                          \
      if (status ## suffix.daemon_error_info) {                                      \
        strcat(status_text, "(ReZygiskd: ");                                         \
        strcat(status_text, status ## suffix.daemon_error_info);                     \
        strcat(status_text, ")");                                                    \
      } else {                                                                       \
        strcat(status_text, "(ReZygiskd: not running)");                             \
      }                                                                              \
    }                                                                                \
  }

static bool update_status(const char *message) {
  FILE *prop = fopen(PROP_PATH, "w");
  if (prop == NULL) {
    PLOGE("failed to open prop");

    return false;
  }

  if (message) {
    fprintf(prop, "%s[%s] %s", pre_section, message, post_section);
    fclose(prop);

    return true;
  }

  char status_text[256] = "Monitor: ";
  switch (tracing_state) {
    case TRACING: {
      strcat(status_text, "✅");

      break;
    }
    case STOPPING: [[fallthrough]];
    case STOPPED: {
      strcat(status_text, "⛔");

      break;
    }
    case EXITING: {
      strcat(status_text, "❌");

      break;
    }
  }

  WRITE_STATUS_ABI(64)
  WRITE_STATUS_ABI(32)

  fprintf(prop, "%s[%s] %s", pre_section, status_text, post_section);
  fclose(prop);

  if (environment_information64.root_impl || environment_information32.root_impl) {
    FILE *json = fopen("/data/adb/rezygisk/state.json", "w");
    if (json == NULL) {
      PLOGE("failed to open state.json");

      return false;
    }

    fprintf(json, "{\n");
    fprintf(json, "  \"root\": \"%s\",\n", environment_information64.root_impl ? environment_information64.root_impl : environment_information32.root_impl);

    fprintf(json, "  \"monitor\": {\n");
    fprintf(json, "    \"state\": \"%d\"", tracing_state);
    if (monitor_stop_reason[0] != '\0') fprintf(json, ",\n    \"reason\": \"%s\",\n", monitor_stop_reason);
    else fprintf(json, "\n");
    fprintf(json, "  },\n");


    fprintf(json, "  \"rezygiskd\": {\n");
    if (status64.supported) {
      fprintf(json, "    \"64\": {\n");
      fprintf(json, "      \"state\": %d,\n", status64.daemon_running);
      if (status64.daemon_error_info) fprintf(json, "      \"reason\": \"%s\",\n", status64.daemon_error_info);
      fprintf(json, "      \"modules\": [");

      if (environment_information64.modules) for (uint32_t i = 0; i < environment_information64.modules_len; i++) {
        if (i > 0) fprintf(json, ", ");
        fprintf(json, "\"%s\"", environment_information64.modules[i]);
      }

      fprintf(json, "]\n");
      fprintf(json, "    }");
      if (status32.supported) fprintf(json, ",\n");
      else fprintf(json, "\n");
    }

    if (status32.supported) {
      fprintf(json, "    \"32\": {\n");
      fprintf(json, "      \"state\": %d,\n", status32.daemon_running);
      if (status32.daemon_error_info) fprintf(json, "      \"reason\": \"%s\",\n", status32.daemon_error_info);
      fprintf(json, "      \"modules\": [");

      if (environment_information32.modules) for (uint32_t i = 0; i < environment_information32.modules_len; i++) {
        if (i > 0) fprintf(json, ", ");
        fprintf(json, "\"%s\"", environment_information32.modules[i]);
      }

      fprintf(json, "]\n");
      fprintf(json, "    }\n");
    }

    fprintf(json, "  },\n");

    fprintf(json, "  \"zygote\": {\n");
    if (status64.supported) {
      fprintf(json, "    \"64\": %d", status64.zygote_injected);
      if (status32.zygote_injected) fprintf(json, ",\n");
      else fprintf(json, "\n");
    }
    if (status32.zygote_injected) {
      fprintf(json, "    \"32\": %d\n", status32.zygote_injected);
    }
    fprintf(json, "  }\n");
    fprintf(json, "}\n");

    fclose(json);
  } else {
    if (remove("/data/adb/rezygisk/state.json") == -1) {
      PLOGE("failed to remove state.json");
    }
  }

  LOGI("status updated: %s", status_text);

  return true;
}

static bool prepare_environment() {
  /* INFO: We need to create the file first, otherwise the mount will fail */
  close(open(PROP_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644));

  FILE *orig_prop = fopen("/data/adb/modules/rezygisk/module.prop", "r");
  if (orig_prop == NULL) {
    PLOGE("failed to open orig prop");

    return false;
  }

  bool after_description = false;

  char line[1024];
  while (fgets(line, sizeof(line), orig_prop) != NULL) {
    if (strncmp(line, "description=", strlen("description=")) == 0) {
      strcat(pre_section, "description=");
      strcat(post_section, line + strlen("description="));
      after_description = true;

      continue;
    }

    if (after_description) strcat(post_section, line);
    else strcat(pre_section, line);
  }

  fclose(orig_prop);

  /* INFO: This environment variable is related to Magisk Zygisk/Manager. It
             it used by Magisk's Zygisk to communicate to Magisk Manager whether
             Zygisk is working or not.

           Because of that behavior, we can knowledge built-in Zygisk is being
             used and stop the continuation of initialization of ReZygisk.*/
  if (getenv("ZYGISK_ENABLED")) {
    update_status("❌ Disable Magisk's built-in Zygisk");

    return false;
  }

  return true;
}

void init_monitor() {
  LOGI("ReZygisk %s", ZKSU_VERSION);

  if (!prepare_environment()) exit(1);

  monitor_events_init();

  if (!rezygiskd_listener_init()) {
    LOGE("failed to create socket");

    close(monitor_epoll_fd);

    exit(1);
  }

  monitor_events_register_event(rezygiskd_listener_callback, monitor_sock_fd, EPOLLIN | EPOLLET);

  if (sigchld_listener_init() == false) {
    LOGE("failed to create signalfd");

    rezygiskd_listener_stop();
    close(monitor_epoll_fd);

    exit(1);
  }

  monitor_events_register_event(sigchld_listener_callback, sigchld_signal_fd, EPOLLIN | EPOLLET);

  monitor_events_loop();

  /* INFO: Once it stops the loop, we cannot access the epool data, so we
             either manually call the stops or save to a structure. */
  rezygiskd_listener_stop();
  sigchld_listener_stop();

  if (status64.daemon_info) free(status64.daemon_info);
  if (status64.daemon_error_info) free(status64.daemon_error_info);
  if (status32.daemon_info) free(status32.daemon_info);
  if (status32.daemon_error_info) free(status32.daemon_error_info);

  if (environment_information64.root_impl) free((void *)environment_information64.root_impl);
  if (environment_information64.modules) {
    for (uint32_t i = 0; i < environment_information64.modules_len; i++) {
      free((void *)environment_information64.modules[i]);
    }
    free((void *)environment_information64.modules);
  }

  if (environment_information32.root_impl) free((void *)environment_information32.root_impl);
  if (environment_information32.modules) {
    for (uint32_t i = 0; i < environment_information32.modules_len; i++) {
      free((void *)environment_information32.modules[i]);
    }
    free((void *)environment_information32.modules);
  }

  LOGI("Terminating ReZygisk monitor");
}

int send_control_command(enum rezygiskd_command cmd) {
  int sockfd = socket(PF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0);
  if (sockfd == -1) return -1;

  struct sockaddr_un addr = {
    .sun_family = AF_UNIX,
    .sun_path = { 0 }
  };

  size_t sun_path_len = snprintf(addr.sun_path, sizeof(addr.sun_path), "%s/%s", rezygiskd_get_path(), SOCKET_NAME);

  socklen_t socklen = sizeof(sa_family_t) + sun_path_len;

  uint8_t cmd_op = cmd;
  ssize_t nsend = sendto(sockfd, (void *)&cmd_op, sizeof(cmd_op), 0, (struct sockaddr *)&addr, socklen);

  close(sockfd);

  return nsend != sizeof(cmd_op) ? -1 : 0;
}

```

`loader/src/ptracer/monitor.h`:

```h
#ifndef MONITOR_H
#define MONITOR_H

#include <stdbool.h>

void init_monitor();

bool trace_zygote(int pid);

enum rezygiskd_command {
  START = 1,
  STOP = 2,
  EXIT = 3,

  /* sent from daemon */
  ZYGOTE64_INJECTED = 4,
  ZYGOTE32_INJECTED = 5,
  DAEMON64_SET_INFO = 6,
  DAEMON32_SET_INFO = 7,
  DAEMON64_SET_ERROR_INFO = 8,
  DAEMON32_SET_ERROR_INFO = 9,
  SYSTEM_SERVER_STARTED = 10
};

int send_control_command(enum rezygiskd_command cmd);

#endif /* MONITOR_H */
```

`loader/src/ptracer/ptracer.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <fcntl.h>

#include <sys/ptrace.h>
#include <sys/auxv.h>
#include <elf.h>
#include <link.h>
#include <sys/wait.h>
#include <signal.h>

#include <unistd.h>

#include "utils.h"
#include "misc.h"

#include "remote_csoloader.h"

bool inject_on_main(int pid, const char *lib_path) {
  LOGI("injecting %s to zygote %d", lib_path, pid);

  /*
    parsing KernelArgumentBlock

    https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/private/KernelArgumentBlock.h;l=30;drc=6d1ee77ee32220e4202c3066f7e1f69572967ad8
  */

  struct user_regs_struct regs = { 0 };

  char pid_maps[PATH_MAX];
  snprintf(pid_maps, sizeof(pid_maps), "/proc/%d/maps", pid);

  struct maps *map = parse_maps(pid_maps);
  if (map == NULL) {
    LOGE("failed to parse remote maps");

    return false;
  }

  if (!get_regs(pid, &regs)) return false;

  uintptr_t arg = (uintptr_t)regs.REG_SP;

  char addr_mem_region[1024];
  get_addr_mem_region(map, arg, addr_mem_region, sizeof(addr_mem_region));

  LOGV("kernel argument %" PRIxPTR " %s", arg, addr_mem_region);

  int argc;
  char **argv = (char **)((uintptr_t *)arg + 1);
  LOGV("argv %p", (void *)argv);

  read_proc(pid, arg, &argc, sizeof(argc));
  LOGV("argc %d", argc);

  char **envp = argv + argc + 1;
  LOGV("envp %p", (void *)envp);

  char **p = envp;
  while (1) {
    uintptr_t *buf;
    read_proc(pid, (uintptr_t)p, &buf, sizeof(buf));

    if (buf == NULL) break;

    p++;
  }

  p++;

  ElfW(auxv_t) *auxv = (ElfW(auxv_t) *)p;

  get_addr_mem_region(map, (uintptr_t)auxv, addr_mem_region, sizeof(addr_mem_region));
  LOGV("auxv %p %s", auxv, addr_mem_region);

  ElfW(auxv_t) *v = auxv;
  uintptr_t entry_addr = 0;
  uintptr_t addr_of_entry_addr = 0;

  while (1) {
    ElfW(auxv_t) buf;

    read_proc(pid, (uintptr_t)v, &buf, sizeof(buf));

    if (buf.a_type == AT_ENTRY) {
      entry_addr = (uintptr_t)buf.a_un.a_val;
      addr_of_entry_addr = (uintptr_t)v + offsetof(ElfW(auxv_t), a_un);

      get_addr_mem_region(map, entry_addr, addr_mem_region, sizeof(addr_mem_region));
      LOGV("entry address %" PRIxPTR " %s (entry=%" PRIxPTR ", entry_addr=%" PRIxPTR ")", entry_addr,
            addr_mem_region, (uintptr_t)v, addr_of_entry_addr);

      break;
    }

    if (buf.a_type == AT_NULL) break;

    v++;
  }

  if (entry_addr == 0) {
    LOGE("failed to get entry");

    return false;
  }

  /* INFO: (-0x0F & ~1) is a value below zero, while the one after "|"
            is an unsigned (must be 0 or greater) value, so we must
            cast the second value to signed long (intptr_t) to avoid
            undefined behavior.

           Replace the program entry with an invalid address. For arm32 compatibility,
            we set the last bit to the same as the entry address.
  */
  uintptr_t break_addr = (uintptr_t)((intptr_t)(-0x0F & ~1) | (intptr_t)((uintptr_t)entry_addr & 1));
  if (!write_proc(pid, (uintptr_t)addr_of_entry_addr, &break_addr, sizeof(break_addr))) return false;

  ptrace(PTRACE_CONT, pid, 0, 0);

  int status;
  wait_for_trace(pid, &status, __WALL);
  if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGSEGV) {
    if (!get_regs(pid, &regs)) return false;

    if (((int)regs.REG_IP & ~1) != ((int)break_addr & ~1)) {
      LOGE("stopped at unknown addr %p", (void *) regs.REG_IP);

      return false;
    }

    /* INFO: The linker has been initialized now, we can do dlopen */
    LOGD("stopped at entry");

    /* INFO: Restore entry address */
    if (!write_proc(pid, (uintptr_t) addr_of_entry_addr, &entry_addr, sizeof(entry_addr))) return false;

    /* INFO: Backup registers */
    struct user_regs_struct backup;
    memcpy(&backup, &regs, sizeof(regs));

    free_maps(map);

    map = parse_maps(pid_maps);
    if (!map) {
      LOGE("failed to parse remote maps");

      return false;
    }

    struct maps *local_map = parse_maps("/proc/self/maps");
    if (!local_map) {
      LOGE("failed to parse local maps");

      return false;
    }

    void *libc_return_addr = find_module_return_addr(map, "libc.so");
    LOGD("libc return addr %p", libc_return_addr);

    const char *libc_path = NULL;
    for (size_t i = 0; i < map->size; i++) {
      if (map->maps[i].path == NULL) continue;

      const char *filename = position_after(map->maps[i].path, '/');
      if (strcmp(filename, "libc.so") == 0) {
        libc_path = map->maps[i].path;

        LOGD("found libc.so at %s", libc_path);

        break;
      }
    }

    uintptr_t remote_base = 0;
    size_t remote_size = 0;
    uintptr_t injector_entry = 0;

    if (!remote_csoloader_load_and_resolve_entry(pid, &regs, (uintptr_t)libc_return_addr, local_map, map, libc_path, lib_path,
                                                 &remote_base, &remote_size, &injector_entry)) {
      LOGE("remote CSOLoader mapping failed");

      free_maps(local_map);
      free_maps(map);

      return false;
    }

    free_maps(local_map);
    free_maps(map);

    long args[2];
    args[0] = (long)remote_base;
    args[1] = (long)remote_size;

    remote_call(pid, &regs, injector_entry, (uintptr_t)libc_return_addr, args, 2);

    /* INFO: remote_call uses a deliberate SIGSEGV on an invalid return address to regain control.
               If the call faults elsewhere (e.g., inside injector code), REG_IP won't match. */
    bool injector_ok = false;
    #if defined(__arm__)
      injector_ok = (((uintptr_t)regs.REG_IP & ~1u) == ((uintptr_t)libc_return_addr & ~1u));
    #else
      injector_ok = ((uintptr_t)regs.REG_IP == (uintptr_t)libc_return_addr);
    #endif
    if (!injector_ok) {
      char stopped_region[1024];
      struct maps *map_after = parse_maps(pid_maps);
      if (map_after) {
        get_addr_mem_region(map_after, (uintptr_t)regs.REG_IP, stopped_region, sizeof(stopped_region));

        free_maps(map_after);
      } else {
        snprintf(stopped_region, sizeof(stopped_region), "<maps unavailable>");
      }

      LOGE("injector entry faulted at %p (%s)", (void *)regs.REG_IP, stopped_region);

      /* INFO: Restore registers before reporting failure. */
      backup.REG_IP = (long)entry_addr;

      (void)set_regs(pid, &backup);

      return false;
    }

    /* INFO: Reset pc to entry */
    backup.REG_IP = (long) entry_addr;
    LOGD("invoke entry");

    /* INFO: Restore registers */
    if (!set_regs(pid, &backup)) return false;

    return true;
  } else {
    char status_str[64];
    parse_status(status, status_str, sizeof(status_str));

    LOGE("stopped by other reason: %s", status_str);
  }

  return false;
}

#define STOPPED_WITH(sig, event) (WIFSTOPPED(status) && WSTOPSIG(status) == (sig) && (status >> 16) == (event))
#define WAIT_OR_DIE wait_for_trace(pid, &status, __WALL);
#define CONT_OR_DIE                           \
  if (ptrace(PTRACE_CONT, pid, 0, 0) == -1) { \
    PLOGE("cont");                            \
                                              \
    return false;                             \
  }

bool trace_zygote(int pid) {
  LOGI("start tracing %d (tracer %d)", pid, getpid());

  int status;

  struct kernel_version version = parse_kversion();
  if (version.major > 3 || (version.major == 3 && version.minor >= 8)) {
    if (ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_EXITKILL | PTRACE_O_TRACESECCOMP) == -1) {
      PLOGE("seize");

      return false;
    }

    WAIT_OR_DIE;
  } else {
    if (ptrace(PTRACE_SEIZE, pid, 0, 0) == -1) {
      PLOGE("seize");

      return false;
    }

    WAIT_OR_DIE;
  }

  if (STOPPED_WITH(SIGSTOP, PTRACE_EVENT_STOP)) {
    char *lib_path = "/data/adb/modules/rezygisk/lib" LP_SELECT("", "64") "/libzygisk.so";
    if (!inject_on_main(pid, lib_path)) {
      LOGE("failed to inject");

      return false;
    }

    LOGD("inject done, continue process");
    if (kill(pid, SIGCONT)) {
      PLOGE("kill");

      return false;
    }

    CONT_OR_DIE
    WAIT_OR_DIE

    if (STOPPED_WITH(SIGTRAP, PTRACE_EVENT_STOP)) {
      CONT_OR_DIE
      WAIT_OR_DIE

      if (STOPPED_WITH(SIGCONT, 0)) {
        LOGD("received SIGCONT");

        /* INFO: Due to kernel bugs, fixed in 5.16+, ptrace_message (msg of
             PTRACE_GETEVENTMSG) may not represent the current state of
             the process. Because we set some options, which alters the
             ptrace_message, we need to call PTRACE_SYSCALL to reset the
             ptrace_message to 0, the default/normal state.
        */
        ptrace(PTRACE_SYSCALL, pid, 0, 0);

        WAIT_OR_DIE

        ptrace(PTRACE_DETACH, pid, 0, SIGCONT);
      }
    } else {
      char status_str[64];
      parse_status(status, status_str, sizeof(status_str));

      LOGE("unknown state %s, not SIGTRAP + EVENT_STOP", status_str);

      ptrace(PTRACE_DETACH, pid, 0, 0);

      return false;
    }
  } else {
    char status_str[64];
    parse_status(status, status_str, sizeof(status_str));

    LOGE("unknown state %s, not SIGSTOP + EVENT_STOP", status_str);

    ptrace(PTRACE_DETACH, pid, 0, 0);

    return false;
  }

  return true;
}

```

`loader/src/ptracer/remote_csoloader.c`:

```c
/* INFO: Remote CSOLoader, part of CSOLoader. Follows the same licensing
           as the original one (CSOLoader project). */

#include "remote_csoloader.h"

#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

#include <elf.h>
#include <link.h>

#include "logging.h"
#include "socket_utils.h"

#ifndef ALIGN_DOWN
  #define ALIGN_DOWN(x, a) ((x) & ~((a)-1))
#endif
#ifndef ALIGN_UP
  #define ALIGN_UP(x, a) (((x) + ((a)-1)) & ~((a)-1))
#endif

static uintptr_t page_start(uintptr_t addr, size_t page_size) {
  return ALIGN_DOWN(addr, page_size);
}

static uintptr_t page_end(uintptr_t addr, size_t page_size) {
  return ALIGN_DOWN(addr + page_size - 1, page_size);
}

/* INFO: Parse ELF headers and compute the total mapping size for PT_LOAD segments. */
static bool compute_load_layout(int fd, size_t page_size, ElfW(Ehdr) *eh,
                                ElfW(Phdr) **out_phdr, ElfW(Addr) *out_min_vaddr,
                                size_t *out_map_size) {
  if (!read_loop_offset(fd, eh, sizeof(*eh), 0)) {
    LOGE("Failed to read ELF header");

    return false;
  }

  if (memcmp(eh->e_ident, ELFMAG, SELFMAG) != 0) {
    LOGE("Invalid ELF magic");

    return false;
  }

  size_t phdr_sz = (size_t)eh->e_phnum * sizeof(ElfW(Phdr));
  ElfW(Phdr) *phdr = (ElfW(Phdr) *)malloc(phdr_sz);
  if (!phdr) {
    LOGE("Failed to allocate memory for program headers");

    return false;
  }

  if (!read_loop_offset(fd, phdr, phdr_sz, (off_t)eh->e_phoff)) {
    LOGE("Failed to read program headers");

    free(phdr);

    return false;
  }

  /* INFO: Find min/max vaddr across all PT_LOAD segments */
  ElfW(Addr) lo = (ElfW(Addr))UINTPTR_MAX;
  ElfW(Addr) hi = 0;

  for (int i = 0; i < eh->e_phnum; i++) {
    if (phdr[i].p_type != PT_LOAD) continue;
    if (phdr[i].p_vaddr < lo) lo = phdr[i].p_vaddr;

    ElfW(Addr) end = phdr[i].p_vaddr + phdr[i].p_memsz;
    if (end > hi) hi = end;
  }

  if (hi <= lo) {
    LOGE("Invalid PT_LOAD segments");

    free(phdr);

    return false;
  }

  /* INFO: Page-align the address range */
  lo = (ElfW(Addr))page_start((uintptr_t)lo, page_size);
  hi = (ElfW(Addr))page_end((uintptr_t)hi, page_size);

  *out_min_vaddr = lo;
  *out_map_size = (size_t)(hi - lo);
  *out_phdr = phdr;

  return true;
}

/* INFO: Convert a virtual address to file offset using PT_LOAD segment mapping. */
static bool vaddr_to_offset(const ElfW(Phdr) *phdr, int phnum, ElfW(Addr) vaddr, off_t *out_off) {
  for (int i = 0; i < phnum; i++) {
    if (phdr[i].p_type != PT_LOAD) continue;

    ElfW(Addr) seg_start = phdr[i].p_vaddr;
    ElfW(Addr) seg_end = phdr[i].p_vaddr + phdr[i].p_filesz;

    if (vaddr < seg_start || vaddr >= seg_end) continue;

    *out_off = (off_t)phdr[i].p_offset + (off_t)(vaddr - seg_start);

    return true;
  }

  LOGE("Failed to find vaddr to offset mapping for vaddr: 0x%" PRIxPTR, (uintptr_t)vaddr);

  return false;
}

/* INFO: Find the full path of a loaded module by its soname in remote maps. */
static const char *find_remote_module_path(struct maps *remote_map, const char *soname) {
  for (size_t i = 0; i < remote_map->size; i++) {
    const struct map *m = &remote_map->maps[i];

    if (!m->path) continue;
    if (m->offset != 0) continue;

    const char *filename = position_after(m->path, '/');
    if (!filename) filename = m->path;

    if (strcmp(filename, soname) == 0) return m->path;
  }

  return NULL;
}

struct elf_dyn_info {
  off_t dyn_off;
  size_t dyn_sz;

  off_t symtab_off;
  off_t strtab_off;
  off_t rel_off;
  size_t rel_sz;
  off_t rela_off;
  size_t rela_sz;
  off_t jmprel_off;
  size_t jmprel_sz;
  int pltrel_type;

  size_t syment;
  size_t strsz;
  size_t nsyms;

  char *strtab;
  size_t needed_count;
  size_t *needed_str_offsets;
};

static void elf_dyn_info_destroy(struct elf_dyn_info *info) {
  if (!info) return;

  free(info->strtab);
  free(info->needed_str_offsets);
  memset(info, 0, sizeof(*info));
}

/* INFO: Parse PT_DYNAMIC and extract relocation/symbol table info. */
static bool elf_load_dyn_info(int fd, const ElfW(Ehdr) *eh, const ElfW(Phdr) *phdr, struct elf_dyn_info *out) {
  memset(out, 0, sizeof(*out));
  out->pltrel_type = 0;

  ElfW(Dyn) *dyn = NULL;
  size_t *needed_str_offsets = NULL;
  bool success = false;

  /* INFO: Find PT_DYNAMIC segment */
  const ElfW(Phdr) *dyn_phdr = NULL;
  for (int i = 0; i < eh->e_phnum; i++) {
    if (phdr[i].p_type != PT_DYNAMIC) continue;

    dyn_phdr = &phdr[i];

    break;
  }

  if (!dyn_phdr || dyn_phdr->p_filesz == 0) {
    LOGE("Failed to find PT_DYNAMIC");

    return false;
  }

  out->dyn_off = (off_t)dyn_phdr->p_offset;
  out->dyn_sz = (size_t)dyn_phdr->p_filesz;

  size_t dyn_count = out->dyn_sz / sizeof(ElfW(Dyn));

  dyn = (ElfW(Dyn) *)calloc(dyn_count, sizeof(ElfW(Dyn)));
  if (!dyn) {
    LOGE("Failed to allocate memory for dynamic entries");

    return false;
  }

  if (!read_loop_offset(fd, dyn, dyn_count * sizeof(ElfW(Dyn)), out->dyn_off)) {
    LOGE("Failed to read dynamic entries");

    goto cleanup;
  }

  ElfW(Addr) symtab_vaddr = 0;
  ElfW(Addr) strtab_vaddr = 0;
  ElfW(Addr) gnu_hash_vaddr = 0;
  ElfW(Addr) rel_vaddr = 0;
  ElfW(Addr) rela_vaddr = 0;
  ElfW(Addr) jmprel_vaddr = 0;
  size_t rel_sz = 0;
  size_t rela_sz = 0;
  size_t jmprel_sz = 0;
  size_t strsz = 0;
  size_t syment = 0;

  size_t needed_count = 0;
  for (size_t i = 0; i < dyn_count; i++) {
    if (dyn[i].d_tag == DT_NEEDED) needed_count++;
    if (dyn[i].d_tag == DT_NULL) break;
  }

  if (needed_count) {
    needed_str_offsets = (size_t *)calloc(needed_count, sizeof(size_t));
    if (!needed_str_offsets) {
      LOGE("Failed to allocate memory for DT_NEEDED offsets");

      goto cleanup;
    }
  }

  size_t needed_i = 0;
  for (size_t i = 0; i < dyn_count; i++) {
    uintptr_t tag = (uintptr_t)dyn[i].d_tag;
    switch (tag) {
      case DT_SYMTAB:    symtab_vaddr = (ElfW(Addr))dyn[i].d_un.d_ptr; break;
      case DT_STRTAB:    strtab_vaddr = (ElfW(Addr))dyn[i].d_un.d_ptr; break;
      case DT_STRSZ:     strsz = (size_t)dyn[i].d_un.d_val; break;
      case DT_SYMENT:    syment = (size_t)dyn[i].d_un.d_val; break;
      case DT_REL:       rel_vaddr = (ElfW(Addr))dyn[i].d_un.d_ptr; break;
      case DT_RELSZ:     rel_sz = (size_t)dyn[i].d_un.d_val; break;
      case DT_RELA:      rela_vaddr = (ElfW(Addr))dyn[i].d_un.d_ptr; break;
      case DT_RELASZ:    rela_sz = (size_t)dyn[i].d_un.d_val; break;
      case DT_JMPREL:    jmprel_vaddr = (ElfW(Addr))dyn[i].d_un.d_ptr; break;
      case DT_PLTRELSZ:  jmprel_sz = (size_t)dyn[i].d_un.d_val; break;
      case DT_PLTREL:    out->pltrel_type = (int)dyn[i].d_un.d_val; break;
      case DT_GNU_HASH:  gnu_hash_vaddr = (ElfW(Addr))dyn[i].d_un.d_ptr; break;
      case DT_NEEDED: {
        if (needed_str_offsets && needed_i < needed_count)
          needed_str_offsets[needed_i++] = (size_t)dyn[i].d_un.d_val;

        break;
      }
      case DT_NULL: i = dyn_count; break;
    }
  }

  /* INFO: Validate required entries */
  if (!syment) syment = sizeof(ElfW(Sym));

  if (!symtab_vaddr || !strtab_vaddr || !strsz) {
    LOGE("Missing DT_SYMTAB/DT_STRTAB/DT_STRSZ");

    goto cleanup;
  }

  /* INFO: Convert virtual addresses to file offsets */
  if (!vaddr_to_offset(phdr, eh->e_phnum, symtab_vaddr, &out->symtab_off) ||
      !vaddr_to_offset(phdr, eh->e_phnum, strtab_vaddr, &out->strtab_off)) {
    LOGE("Failed vaddr_to_offset for symtab/strtab");

    goto cleanup;
  }

  /* INFO: Convert relocation table virtual addresses to file offsets */
  if (rel_vaddr && rel_sz) {
    if (!vaddr_to_offset(phdr, eh->e_phnum, rel_vaddr, &out->rel_off)) {
      LOGE("Failed vaddr_to_offset for DT_REL");

      goto cleanup;
    }
    out->rel_sz = rel_sz;
  }

  if (rela_vaddr && rela_sz) {
    if (!vaddr_to_offset(phdr, eh->e_phnum, rela_vaddr, &out->rela_off)) {
      LOGE("Failed vaddr_to_offset for DT_RELA");

      goto cleanup;
    }
    out->rela_sz = rela_sz;
  }

  if (jmprel_vaddr && jmprel_sz) {
    if (!vaddr_to_offset(phdr, eh->e_phnum, jmprel_vaddr, &out->jmprel_off)) {
      LOGE("Failed vaddr_to_offset for DT_JMPREL");

      goto cleanup;
    }
    out->jmprel_sz = jmprel_sz;
  }

  /* INFO: Read string table into memory */
  out->strtab = (char *)malloc(strsz + 1);
  if (!out->strtab) {
    LOGE("Failed to allocate memory for string table");

    goto cleanup;
  }

  if (!read_loop_offset(fd, out->strtab, strsz, out->strtab_off)) {
    LOGE("Failed to read string table");

    free(out->strtab);
    out->strtab = NULL;

    goto cleanup;
  }
  out->strtab[strsz] = '\0';

  out->syment = syment;
  out->strsz = strsz;
  out->needed_count = needed_count;
  out->needed_str_offsets = needed_str_offsets;

  out->nsyms = 0;

  if (gnu_hash_vaddr) {
    off_t gnu_hash_off = 0;

    if (vaddr_to_offset(phdr, eh->e_phnum, gnu_hash_vaddr, &gnu_hash_off)) {
      uint32_t header[4];

      if (read_loop_offset(fd, header, sizeof(header), gnu_hash_off)) {
        uint32_t nbuckets = header[0];
        uint32_t symoffset = header[1];
        uint32_t bloom_size = header[2];

        /* INFO: Calculate offset to buckets array (after bloom filter) */
        size_t bloom_words = bloom_size * sizeof(ElfW(Addr));
        off_t buckets_off = gnu_hash_off + 16 + (off_t)bloom_words;

        /* INFO: Find max bucket value to determine highest symbol index */
        uint32_t max_bucket = 0;

        for (uint32_t b = 0; b < nbuckets; b++) {
          uint32_t bucket_val;

          if (!read_loop_offset(fd, &bucket_val, sizeof(bucket_val), buckets_off + (off_t)(b * 4)))
            break;

          if (bucket_val > max_bucket) max_bucket = bucket_val;
        }

        if (max_bucket >= symoffset) {
          /* INFO: Walk chain from max_bucket to find last symbol */
          off_t chains_off = buckets_off + (off_t)(nbuckets * 4);
          uint32_t chain_idx = max_bucket - symoffset;
          uint32_t chain_val;

          while (read_loop_offset(fd, &chain_val, sizeof(chain_val), chains_off + (off_t)(chain_idx * 4))) {
            if (chain_val & 1) {
              out->nsyms = max_bucket + 1;

              break;
            }

            max_bucket++;
            chain_idx++;
          }

          if (!out->nsyms) out->nsyms = max_bucket + 1;
        } else {
          out->nsyms = symoffset;
        }
      }
    }
  }

  success = true;

cleanup:
  free(dyn);
  if (!success) free(needed_str_offsets);

  return success;
}

/* INFO: Look up a symbol by name in the dynamic symbol table. */
static bool find_dynsym_value(int fd, const struct elf_dyn_info *info, const char *sym_name, ElfW(Addr) *out_value) {
  for (size_t i = 0; i < info->nsyms; i++) {
    ElfW(Sym) sym;
    if (!read_loop_offset(fd, &sym, sizeof(sym), info->symtab_off + (off_t)(i * info->syment)))
      break;

    if (sym.st_name == 0 || sym.st_name >= info->strsz) continue;

    const char *name = &info->strtab[sym.st_name];
    if (strcmp(name, sym_name) != 0 || sym.st_shndx == SHN_UNDEF) continue;

    *out_value = sym.st_value;

    return true;
  }

  LOGE("Symbol not found in dynsym: %s", sym_name);

  return false;
}

#ifdef __LP64__
  #define ELF_R_TYPE ELF64_R_TYPE
  #define ELF_R_SYM ELF64_R_SYM
#else
  #define ELF_R_TYPE ELF32_R_TYPE
  #define ELF_R_SYM ELF32_R_SYM
#endif

/* INFO: Resolve a symbol address - either local or from DT_NEEDED libraries. */
static bool resolve_symbol_addr(int fd, const struct elf_dyn_info *info,
                                struct maps *local_map, struct maps *remote_map,
                                const char *const *needed_paths, uintptr_t load_bias,
                                size_t sym_idx, uintptr_t *out_addr) {
  ElfW(Sym) sym;

  if (!read_loop_offset(fd, &sym, sizeof(sym), info->symtab_off + (off_t)(sym_idx * info->syment)))
    return false;

  /* INFO: Defined symbol - use load_bias + value */
  if (sym.st_shndx != SHN_UNDEF) {
    *out_addr = (uintptr_t)load_bias + (uintptr_t)sym.st_value;

    return true;
  }

  /* INFO: Undefined symbol - resolve from external libraries */
  if (sym.st_name == 0 || sym.st_name >= info->strsz) return false;

  const char *name = &info->strtab[sym.st_name];
  if (!name || !*name) return false;

  /* TODO: In CSOLoader, they're optional. Since it's broken to solve those *ATM*, just bypass. */
  if (strcmp(name, "__register_frame") == 0 || strcmp(name, "__deregister_frame") == 0) {
    LOGW("Bypassing resolution of EH frame function: %s", name);

    *out_addr = 0;

    return true;
  }

  /* INFO: Search in DT_NEEDED libraries */
  for (size_t i = 0; i < info->needed_count; i++) {
    const char *mod_path = needed_paths ? needed_paths[i] : NULL;
    if (!mod_path) continue;

    void *addr = find_func_addr(local_map, remote_map, mod_path, name);
    if (addr) {
      *out_addr = (uintptr_t)addr;

      return true;
    }
  }

  LOGE("Failed to resolve external symbol %s", name);

  return false;
}

static bool write_remote_addr(int pid, uintptr_t addr, ElfW(Addr) value) {
  return write_proc(pid, addr, &value, sizeof(value)) == (ssize_t)sizeof(value);
}

static bool read_remote_addr(int pid, uintptr_t addr, ElfW(Addr) *out) {
  return read_proc(pid, addr, out, sizeof(*out)) == (ssize_t)sizeof(*out);
}

/* INFO: Process RELA-format relocations from a given offset/size. */
static bool apply_rela_section(int pid, int fd, const struct elf_dyn_info *info,
                               struct maps *local_map, struct maps *remote_map,
                               const char *const *needed_paths, uintptr_t load_bias,
                               off_t rela_off, size_t rela_sz) {
  size_t count = rela_sz / sizeof(ElfW(Rela));

  for (size_t i = 0; i < count; i++) {
    ElfW(Rela) r;
    if (!read_loop_offset(fd, &r, sizeof(r), rela_off + (off_t)(i * sizeof(r)))) return false;

    unsigned type = (unsigned)ELF_R_TYPE(r.r_info);
    unsigned sym = (unsigned)ELF_R_SYM(r.r_info);
    uintptr_t target = (uintptr_t)load_bias + (uintptr_t)r.r_offset;
    ElfW(Addr) value = 0;

    #if defined(__aarch64__)
      if (type == R_AARCH64_RELATIVE) {
        value = (ElfW(Addr))load_bias + (ElfW(Addr))r.r_addend;
      } else if (type == R_AARCH64_GLOB_DAT || type == R_AARCH64_JUMP_SLOT || type == R_AARCH64_ABS64) {
        uintptr_t sym_addr = 0;
        if (!resolve_symbol_addr(fd, info, local_map, remote_map, needed_paths, load_bias, sym, &sym_addr))
          return false;

        value = sym_addr ? (ElfW(Addr))sym_addr + (ElfW(Addr))r.r_addend : 0;
      } else {
        LOGE("Unsupported AArch64 RELA type %u", type);

        return false;
      }
    #elif defined(__x86_64__)
      if (type == R_X86_64_RELATIVE) {
        value = (ElfW(Addr))load_bias + (ElfW(Addr))r.r_addend;
      } else if (type == R_X86_64_GLOB_DAT || type == R_X86_64_JUMP_SLOT || type == R_X86_64_64) {
        uintptr_t sym_addr = 0;
        if (!resolve_symbol_addr(fd, info, local_map, remote_map, needed_paths, load_bias, sym, &sym_addr))
          return false;

        value = sym_addr ? (ElfW(Addr))sym_addr + (ElfW(Addr))r.r_addend : 0;
      } else {
        LOGE("Unsupported x86_64 RELA type %u", type);
        return false;
      }
    #else
      (void) info; (void) local_map; (void) remote_map; (void) sym; (void) type; (void) needed_paths;

      if (type == 0) value = (ElfW(Addr))load_bias + (ElfW(Addr))r.r_addend;
      else {
        LOGE("Unsupported RELA type %u", type);

        return false;
      }
    #endif

    if (!write_remote_addr(pid, target, value)) return false;
  }

  return true;
}

/* INFO: Process REL-format relocations from a given offset/size. */
static bool apply_rel_section(int pid, int fd, const struct elf_dyn_info *info,
                              struct maps *local_map, struct maps *remote_map,
                              const char *const *needed_paths, uintptr_t load_bias,
                              off_t rel_off, size_t rel_sz) {
  size_t count = rel_sz / sizeof(ElfW(Rel));

  for (size_t i = 0; i < count; i++) {
    ElfW(Rel) r;
    if (!read_loop_offset(fd, &r, sizeof(r), rel_off + (off_t)(i * sizeof(r)))) return false;

    unsigned type = (unsigned)ELF_R_TYPE(r.r_info);
    unsigned sym = (unsigned)ELF_R_SYM(r.r_info);
    uintptr_t target = (uintptr_t)load_bias + (uintptr_t)r.r_offset;
    ElfW(Addr) addend = 0;
    ElfW(Addr) value = 0;

    #if defined(__arm__)
      if (type == R_ARM_RELATIVE) {
        if (!read_remote_addr(pid, target, &addend)) return false;

        value = (ElfW(Addr))load_bias + addend;
      } else if (type == R_ARM_GLOB_DAT || type == R_ARM_JUMP_SLOT || type == R_ARM_ABS32) {
        uintptr_t sym_addr = 0;
        if (!resolve_symbol_addr(fd, info, local_map, remote_map, needed_paths, load_bias, sym, &sym_addr))
          return false;

        if (sym_addr == 0) value = 0;
        else if (type == R_ARM_ABS32) {
          if (!read_remote_addr(pid, target, &addend)) return false;

          value = (ElfW(Addr))sym_addr + addend;
        } else {
          value = (ElfW(Addr))sym_addr;
        }
      } else {
        LOGE("Unsupported ARM REL type %u", type);

        return false;
      }
    #elif defined(__i386__)
      if (type == R_386_RELATIVE) {
        if (!read_remote_addr(pid, target, &addend)) return false;

        value = (ElfW(Addr))load_bias + addend;
      } else if (type == R_386_GLOB_DAT || type == R_386_JMP_SLOT || type == R_386_32) {
        uintptr_t sym_addr = 0;
        if (!resolve_symbol_addr(fd, info, local_map, remote_map, needed_paths, load_bias, sym, &sym_addr))
          return false;

        if (sym_addr == 0) value = 0;
        else if (type == R_386_32) {
          if (!read_remote_addr(pid, target, &addend)) return false;

          value = (ElfW(Addr))sym_addr + addend;
        } else {
          value = (ElfW(Addr))sym_addr;
        }
      } else {
        LOGE("Unsupported i386 REL type %u", type);

        return false;
      }
    #else
      (void) info; (void) local_map; (void) remote_map; (void) sym; (void) type; (void) needed_paths; (void) addend; (void) read_remote_addr;

      LOGE("Unsupported REL relocation on this arch");

      return false;
    #endif

    if (!write_remote_addr(pid, target, value)) return false;
  }

  return true;
}

static bool apply_relocations(int pid, int fd, const struct elf_dyn_info *info,
                              struct maps *local_map, struct maps *remote_map,
                              const char *const *needed_paths, uintptr_t load_bias) {
  /* INFO: Process RELA section */
  if (info->rela_sz && info->rela_off) {
    if (!apply_rela_section(pid, fd, info, local_map, remote_map, needed_paths, load_bias, info->rela_off, info->rela_sz))
      return false;
  }

  /* INFO: Process REL section */
  if (info->rel_sz && info->rel_off) {
    if (!apply_rel_section(pid, fd, info, local_map, remote_map, needed_paths, load_bias, info->rel_off, info->rel_sz))
      return false;
  }

  /* INFO: Process JMPREL section (PLT relocations) - uses same format as RELA/REL */
  if (info->jmprel_sz && info->jmprel_off) {
    if (info->pltrel_type == DT_RELA) {
      if (!apply_rela_section(pid, fd, info, local_map, remote_map, needed_paths, load_bias, info->jmprel_off, info->jmprel_sz))
        return false;
    } else if (info->pltrel_type == DT_REL) {
      if (!apply_rel_section(pid, fd, info, local_map, remote_map, needed_paths, load_bias, info->jmprel_off, info->jmprel_sz))
        return false;
    } else {
      LOGE("Unknown DT_PLTREL type %d", info->pltrel_type);

      return false;
    }
  }

  return true;
}

bool remote_csoloader_load_and_resolve_entry(int pid, struct user_regs_struct *regs,
                                             uintptr_t libc_return_addr,
                                             struct maps *local_map, struct maps *remote_map,
                                             const char *libc_path, const char *lib_path,
                                             uintptr_t *out_base, size_t *out_total_size,
                                             uintptr_t *out_entry) {
  const struct user_regs_struct regs_saved = *regs;

  long page_size_long = sysconf(_SC_PAGESIZE);
  if (page_size_long <= 0) {
    LOGE("sysconf(_SC_PAGESIZE) failed");

    return false;
  }

  size_t page_size = (size_t)page_size_long;

  int fd = open(lib_path, O_RDONLY | O_CLOEXEC);
  if (fd < 0) {
    PLOGE("open %s", lib_path);

    return false;
  }

  /* INFO: Parse ELF headers and compute mapping size */
  ElfW(Ehdr) eh;
  ElfW(Phdr) *phdr = NULL;
  ElfW(Addr) min_vaddr = 0;
  size_t map_size = 0;

  if (!compute_load_layout(fd, page_size, &eh, &phdr, &min_vaddr, &map_size)) {
    LOGE("Failed to parse ELF phdrs for %s", lib_path);
    close(fd);

    return false;
  }

  /* INFO: Resolve required libc functions in remote process */
  void *mmap_addr = find_func_addr(local_map, remote_map, libc_path, "mmap");
  if (!mmap_addr) {
    LOGE("Failed to resolve remote mmap");

    free(phdr);
    close(fd);

    return false;
  }

  void *mprotect_addr = find_func_addr(local_map, remote_map, libc_path, "mprotect");
  if (!mprotect_addr) {
    LOGE("Failed to resolve remote mprotect");

    free(phdr);
    close(fd);

    return false;
  }

  void *open_addr = find_func_addr(local_map, remote_map, libc_path, "open");
  if (!open_addr) {
    LOGE("Failed to resolve remote open");

    free(phdr);
    close(fd);

    return false;
  }

  void *close_addr = find_func_addr(local_map, remote_map, libc_path, "close");
  if (!close_addr) {
    LOGE("Failed to resolve remote close");

    free(phdr);
    close(fd);

    return false;
  }

  long args[6];

  /* INFO: Copy library path into remote memory for file-backed mappings */
  size_t path_len = strlen(lib_path) + 1;
  args[0] = 0;
  args[1] = (long)path_len;
  args[2] = PROT_READ | PROT_WRITE;
  args[3] = MAP_PRIVATE | MAP_ANONYMOUS;
  args[4] = -1;
  args[5] = 0;

  struct user_regs_struct call_regs = regs_saved;
  uintptr_t remote_path = remote_call(pid, &call_regs, (uintptr_t)mmap_addr, libc_return_addr, args, 6);
  if (!remote_path || remote_path == (uintptr_t)MAP_FAILED) {
    LOGE("remote mmap for path failed: %p", (void *)remote_path);

    free(phdr);
    close(fd);

    return false;
  }

  if (write_proc(pid, remote_path, lib_path, path_len) != (ssize_t)path_len) {
    LOGE("Failed to write remote path string");

    free(phdr);
    close(fd);

    return false;
  }

  args[0] = (long)remote_path;
  args[1] = O_RDONLY | O_CLOEXEC;
  args[2] = 0;

  call_regs = regs_saved;
  long remote_fd = (long)remote_call(pid, &call_regs, (uintptr_t)open_addr, libc_return_addr, args, 3);
  if (remote_fd < 0) {
    LOGE("Failed to open remote file: %s", lib_path);

    free(phdr);
    close(fd);

    return false;
  }

  /* INFO: Reserve address space with PROT_NONE */
  args[0] = 0;
  args[1] = (long)map_size;
  args[2] = PROT_NONE;
  args[3] = MAP_PRIVATE | MAP_ANONYMOUS;
  args[4] = -1;
  args[5] = 0;

  call_regs = regs_saved;
  uintptr_t remote_base = remote_call(pid, &call_regs, (uintptr_t)mmap_addr, libc_return_addr, args, 6);
  if (!remote_base || remote_base == (uintptr_t)MAP_FAILED) {
    LOGE("remote mmap reserve failed: %p", (void *)remote_base);

    call_regs = regs_saved;

    args[0] = remote_fd;
  
    remote_call(pid, &call_regs, (uintptr_t)close_addr, libc_return_addr, args, 1);

    free(phdr);
    close(fd);

    return false;
  }

  uintptr_t load_bias = remote_base - (uintptr_t)min_vaddr;

  /* INFO: Track segments for later protection finalization */
  struct {
    uintptr_t addr;
    size_t len;
    int final_prot;
  } segs[64];

  size_t segs_count = 0;

  /* INFO: Map non-writable PT_LOAD from file */
  for (int i = 0; i < eh.e_phnum; i++) {
    if (phdr[i].p_type != PT_LOAD) continue;

    uintptr_t seg_start = (uintptr_t)phdr[i].p_vaddr + load_bias;
    uintptr_t seg_page = page_start(seg_start, page_size);
    uintptr_t seg_end = (uintptr_t)phdr[i].p_vaddr + (uintptr_t)phdr[i].p_memsz + load_bias;
    uintptr_t seg_page_end = page_end(seg_end, page_size);
    size_t seg_page_len = (size_t)(seg_page_end - seg_page);

    bool is_writable = (phdr[i].p_flags & PF_W) != 0;

    if (is_writable) {
      off_t seg_offset = (off_t)phdr[i].p_offset;
      off_t file_page_offset = (off_t)page_start((uintptr_t)seg_offset, page_size);
      uintptr_t file_end = (uintptr_t)phdr[i].p_vaddr + (uintptr_t)phdr[i].p_filesz + load_bias;
      uintptr_t file_page_end = page_end(file_end, page_size);

      if (phdr[i].p_filesz > 0) {
        call_regs = regs_saved;

        size_t file_map_len = (size_t)(file_page_end - seg_page);
        args[0] = (long)seg_page;
        args[1] = (long)file_map_len;
        args[2] = PROT_READ | PROT_WRITE;
        args[3] = MAP_FIXED | MAP_PRIVATE;
        args[4] = remote_fd;
        args[5] = (long)file_page_offset;

        uintptr_t seg_map = remote_call(pid, &call_regs, (uintptr_t)mmap_addr, libc_return_addr, args, 6);
        if (!seg_map || seg_map == (uintptr_t)MAP_FAILED) {
          LOGE("remote mmap writable file-backed segment failed for phdr %d", i);

          call_regs = regs_saved;

          args[0] = remote_fd;
  
          remote_call(pid, &call_regs, (uintptr_t)close_addr, libc_return_addr, args, 1);
          free(phdr);
          close(fd);

          return false;
        }

        /* INFO: Zero-fill the tail of the last page (p_memsz - p_filesz within page). */
        if (file_page_end > file_end) {
          size_t tail_len = (size_t)(file_page_end - file_end);
          char *zeros = (char *)calloc(1, tail_len);
          if (!zeros || write_proc(pid, file_end, zeros, tail_len) != (ssize_t)tail_len) {
            LOGE("Failed to zero tail for phdr %d", i);

            if (zeros) free(zeros);
            free(phdr);
            close(fd);

            return false;
          }

          free(zeros);
        }
      }

      if (seg_page_end > file_page_end) {
        call_regs = regs_saved;

        args[0] = (long)file_page_end;
        args[1] = (long)(seg_page_end - file_page_end);
        args[2] = PROT_READ | PROT_WRITE;
        args[3] = MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS;
        args[4] = -1;
        args[5] = 0;

        uintptr_t bss_map = remote_call(pid, &call_regs, (uintptr_t)mmap_addr, libc_return_addr, args, 6);
        if (!bss_map || bss_map == (uintptr_t)MAP_FAILED) {
          LOGE("remote mmap bss segment failed for phdr %d", i);

          call_regs = regs_saved;

          args[0] = remote_fd;

          call_regs = regs_saved;
          remote_call(pid, &call_regs, (uintptr_t)close_addr, libc_return_addr, args, 1);
          free(phdr);
          close(fd);

          return false;
        }
      }
    } else {
      off_t seg_offset = (off_t)phdr[i].p_offset;
      off_t file_page_offset = (off_t)page_start((uintptr_t)seg_offset, page_size);
      uintptr_t file_end = (uintptr_t)phdr[i].p_vaddr + (uintptr_t)phdr[i].p_filesz + load_bias;
      uintptr_t file_page_end = page_end(file_end, page_size);

      if (phdr[i].p_filesz > 0) {
        call_regs = regs_saved;

        size_t file_map_len = (size_t)(file_page_end - seg_page);
        args[0] = (long)seg_page;
        args[1] = (long)file_map_len;
        args[2] = PROT_READ | PROT_WRITE;
        args[3] = MAP_FIXED | MAP_PRIVATE;
        args[4] = remote_fd;
        args[5] = (long)file_page_offset;

        uintptr_t seg_map = remote_call(pid, &call_regs, (uintptr_t)mmap_addr, libc_return_addr, args, 6);
        if (!seg_map || seg_map == (uintptr_t)MAP_FAILED) {
          LOGE("remote mmap file-backed segment failed for phdr %d", i);

          call_regs = regs_saved;

          args[0] = remote_fd;

          remote_call(pid, &call_regs, (uintptr_t)close_addr, libc_return_addr, args, 1);
          free(phdr);
          close(fd);

          return false;
        }
      }

      if (seg_page_end > file_page_end) {
        call_regs = regs_saved;

        args[0] = (long)file_page_end;
        args[1] = (long)(seg_page_end - file_page_end);
        args[2] = PROT_READ | PROT_WRITE;
        args[3] = MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS;
        args[4] = -1;
        args[5] = 0;

        uintptr_t bss_map = remote_call(pid, &call_regs, (uintptr_t)mmap_addr, libc_return_addr, args, 6);
        if (!bss_map || bss_map == (uintptr_t)MAP_FAILED) {
          LOGE("remote mmap bss segment failed for phdr %d", i);

          call_regs = regs_saved;

          args[0] = remote_fd;

          call_regs = regs_saved;
          remote_call(pid, &call_regs, (uintptr_t)close_addr, libc_return_addr, args, 1);
          free(phdr);
          close(fd);

          return false;
        }
      }
    }

    /* INFO: Record segment info for later protection finalization */
    int prot = 0;

    if (phdr[i].p_flags & PF_R) prot |= PROT_READ;
    if (phdr[i].p_flags & PF_W) prot |= PROT_WRITE;
    if (phdr[i].p_flags & PF_X) prot |= PROT_EXEC;

    if (segs_count < (sizeof(segs) / sizeof(segs[0]))) {
      segs[segs_count].addr = seg_page;
      segs[segs_count].len = seg_page_len;
      segs[segs_count].final_prot = prot;
      segs_count++;
    }
  }

  call_regs = regs_saved;

  args[0] = remote_fd;

  remote_call(pid, &call_regs, (uintptr_t)close_addr, libc_return_addr, args, 1);

  struct elf_dyn_info dinfo;
  if (!elf_load_dyn_info(fd, &eh, phdr, &dinfo)) {
    LOGE("Failed to load ELF dynamic info");

    free(phdr);
    close(fd);

    return false;
  }

  const char **needed_paths = NULL;
  if (dinfo.needed_count) {
    needed_paths = (const char **)calloc(dinfo.needed_count, sizeof(char *));
    if (!needed_paths) {
      LOGE("Failed to allocate memory for needed paths");

      elf_dyn_info_destroy(&dinfo);
      free(phdr);
      close(fd);

      return false;
    }

    for (size_t i = 0; i < dinfo.needed_count; i++) {
      size_t off = dinfo.needed_str_offsets[i];

      if (off >= dinfo.strsz) continue;

      const char *soname = &dinfo.strtab[off];
      needed_paths[i] = find_remote_module_path(remote_map, soname);
    }
  }

  /* INFO: Apply all relocations */
  if (!apply_relocations(pid, fd, &dinfo, local_map, remote_map, needed_paths, load_bias)) {
    LOGE("Failed to apply relocations");

    free((void *)needed_paths);
    elf_dyn_info_destroy(&dinfo);
    free(phdr);
    close(fd);

    return false;
  }

  /* INFO: Finalize segment protections after relocations */
  for (size_t i = 0; i < segs_count; i++) {
    args[0] = (long)segs[i].addr;
    args[1] = (long)segs[i].len;
    args[2] = segs[i].final_prot;

    call_regs = regs_saved;
    remote_call(pid, &call_regs, (uintptr_t)mprotect_addr, libc_return_addr, args, 3);
  }

  ElfW(Addr) entry_value = 0;
  if (!find_dynsym_value(fd, &dinfo, "entry", &entry_value)) {
    LOGE("Failed to resolve entry from ELF dynsym");

    free((void *)needed_paths);
    elf_dyn_info_destroy(&dinfo);
    free(phdr);
    close(fd);

    return false;
  }

  uintptr_t remote_entry = (uintptr_t)load_bias + (uintptr_t)entry_value;

  free((void *)needed_paths);
  elf_dyn_info_destroy(&dinfo);
  free(phdr);
  close(fd);

  *out_base = remote_base;
  *out_total_size = map_size;
  *out_entry = remote_entry;

  LOGI("remote mapped %s at %p (size %zu), entry %p", lib_path, (void *)remote_base, map_size, (void *)remote_entry);

  return true;
}

```

`loader/src/ptracer/remote_csoloader.h`:

```h
#ifndef REMOTE_CSOLOADER_H
#define REMOTE_CSOLOADER_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "utils.h"

bool remote_csoloader_load_and_resolve_entry(int pid, struct user_regs_struct *regs,
                                             uintptr_t libc_return_addr, struct maps *local_map,
                                             struct maps *remote_map, const char *libc_path,
                                             const char *lib_path, uintptr_t *out_base,
                                             size_t *out_total_size, uintptr_t *out_entry);

#endif

```

`loader/src/ptracer/utils.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <ctype.h>

#include <sys/sysmacros.h>
#include <sys/ptrace.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/auxv.h>
#include <sys/uio.h>
#include <signal.h>
#include <dlfcn.h>
#include <sched.h>
#include <fcntl.h>
#include <link.h>

#include <unistd.h>
#include <linux/limits.h>

#include "elf_util.h"

#include "utils.h"

bool switch_mnt_ns(int pid, int *fd) {
  int nsfd, old_nsfd = -1;

  char path[PATH_MAX];
  if (pid == 0) {
    if (fd != NULL) {
      nsfd = *fd;
      *fd = -1;
    } else return false;

    snprintf(path, sizeof(path), "/proc/self/fd/%d", nsfd);
  } else {
    if (fd != NULL) {
      old_nsfd = open("/proc/self/ns/mnt", O_RDONLY | O_CLOEXEC);
      if (old_nsfd == -1) {
        PLOGE("get old nsfd");

        return false;
      }

      *fd = old_nsfd;
    }

    snprintf(path, sizeof(path), "/proc/%d/ns/mnt", pid);

    nsfd = open(path, O_RDONLY | O_CLOEXEC);
    if (nsfd == -1) {
      PLOGE("open nsfd %s", path);

      close(old_nsfd);

      return false;
    }
  }

  if (setns(nsfd, CLONE_NEWNS) == -1) {
    PLOGE("set ns to %s", path);

    close(nsfd);
    close(old_nsfd);

    return false;
  }

  close(nsfd);

  return true;
}

struct maps *parse_maps(const char *filename) {
  FILE *fp = fopen(filename, "r");
  if (!fp) {
    LOGE("Failed to open %s", filename);

    return NULL;
  }

  struct maps *maps = (struct maps *)malloc(sizeof(struct maps));
  if (!maps) {
    LOGE("Failed to allocate memory for maps");

    fclose(fp);

    return NULL;
  }

  /* INFO: To ensure in the realloc the libc will know it is meant
             to allocate, and not reallocate from a garbage address. */
  maps->maps = NULL;

  char line[4096 * 2];
  size_t i = 0;

  while (fgets(line, sizeof(line), fp) != NULL) {
    /* INFO: Remove line ending at the end */
    line[strlen(line) - 1] = '\0';

    uintptr_t addr_start;
    uintptr_t addr_end;
    uintptr_t addr_offset;
    ino_t inode;
    unsigned int dev_major;
    unsigned int dev_minor;
    char permissions[5] = "";
    int path_offset;

    sscanf(line,
           "%" PRIxPTR "-%" PRIxPTR " %4s %" PRIxPTR " %x:%x %lu %n%*s",
           &addr_start, &addr_end, permissions, &addr_offset, &dev_major, &dev_minor,
           &inode, &path_offset);

    while (isspace(line[path_offset])) {
      path_offset++;
    }

    struct map *tmp_maps = (struct map *)realloc(maps->maps, (i + 1) * sizeof(struct map));
    if (!tmp_maps) {
      LOGE("Failed to allocate memory for maps->maps");

      maps->size = i;

      fclose(fp);
      free_maps(maps);

      return NULL;
    }
    maps->maps = tmp_maps;

    maps->maps[i].start = addr_start;
    maps->maps[i].end = addr_end;
    maps->maps[i].offset = addr_offset;

    maps->maps[i].perms = 0;
    if (permissions[0] == 'r') maps->maps[i].perms |= PROT_READ;
    if (permissions[1] == 'w') maps->maps[i].perms |= PROT_WRITE;
    if (permissions[2] == 'x') maps->maps[i].perms |= PROT_EXEC;

    maps->maps[i].is_private = permissions[3] == 'p';
    maps->maps[i].dev = makedev(dev_major, dev_minor);
    maps->maps[i].inode = inode;
    maps->maps[i].path = strdup(line + path_offset);
    if (!maps->maps[i].path) {
      LOGE("Failed to allocate memory for maps->maps[%zu].path", i);

      maps->size = i;

      fclose(fp);
      free_maps(maps);

      return NULL;
    }

    i++;
  }

  fclose(fp);

  maps->size = i;

  return maps;
}

void free_maps(struct maps *maps) {
  if (!maps) {
    return;
  }

  for (size_t i = 0; i < maps->size; i++) {
    free((void *)maps->maps[i].path);
  }

  free(maps->maps);
  free(maps);
}

ssize_t write_proc(int pid, uintptr_t remote_addr, const void *buf, size_t len) {
  LOGV("write to remote addr %" PRIxPTR " size %zu", remote_addr, len);

  struct iovec local = {
    .iov_base = (void *)buf,
    .iov_len = len
  };

  struct iovec remote = {
    .iov_base = (void *)remote_addr,
    .iov_len = len
  };

  ssize_t l = process_vm_writev(pid, &local, 1, &remote, 1, 0);
  if (l == -1) PLOGE("process_vm_writev");
  else if ((size_t)l != len) LOGW("not fully written: %zu, excepted %zu", l, len);

  return l;
}

ssize_t read_proc(int pid, uintptr_t remote_addr, void *buf, size_t len) {
  struct iovec local = {
    .iov_base = (void *)buf,
    .iov_len = len
  };

  struct iovec remote = {
    .iov_base = (void *)remote_addr,
    .iov_len = len
  };

  ssize_t l = process_vm_readv(pid, &local, 1, &remote, 1, 0);
  if (l == -1) PLOGE("process_vm_readv");
  else if ((size_t)l != len) LOGW("not fully read: %zu, excepted %zu", l, len);

  return l;
}

bool get_regs(int pid, struct user_regs_struct *regs) {
  #if defined(__x86_64__) || defined(__i386__)
    if (ptrace(PTRACE_GETREGS, pid, 0, regs) == -1) {
      PLOGE("getregs");

      return false;
    }
  #elif defined(__aarch64__) || defined(__arm__)
    struct iovec iov = {
      .iov_base = regs,
      .iov_len = sizeof(struct user_regs_struct),
    };

    if (ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov) == -1) {
      PLOGE("GETREGSET failed, trying GETREGS");

      if (ptrace(/* PTRACE_GETREGS */ 12, pid, 0, regs) == -1) {
        PLOGE("GETREGS");

        return false;
      }

      return true;
    }
  #endif

  return true;
}

bool set_regs(int pid, struct user_regs_struct *regs) {
  #if defined(__x86_64__) || defined(__i386__)
    if (ptrace(PTRACE_SETREGS, pid, 0, regs) == -1) {
      PLOGE("setregs");

      return false;
    }
  #elif defined(__aarch64__) || defined(__arm__)
    struct iovec iov = {
      .iov_base = regs,
      .iov_len = sizeof(struct user_regs_struct),
    };

    if (ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov) == -1) {
      PLOGE("SETREGSET failed, trying SETREGS");

      if (ptrace(/* PTRACE_SETREGS */ 13, pid, 0, regs) == -1) {
        PLOGE("SETREGS");

        return false;
      }

      return true;
    }
  #endif

  return true;
}

void get_addr_mem_region(struct maps *info, uintptr_t addr, char *buf, size_t buf_size) {
  for (size_t i = 0; i < info->size; i++) {
    /* TODO: Early "leave" */
    if (info->maps[i].start <= addr && info->maps[i].end > addr) {
      snprintf(buf, buf_size, "%s %s%s%s",
               info->maps[i].path,
               info->maps[i].perms & PROT_READ ? "r" : "-",
               info->maps[i].perms & PROT_WRITE ? "w" : "-",
               info->maps[i].perms & PROT_EXEC ? "x" : "-");

      return;
    }
  }

  snprintf(buf, buf_size, "<unknown>");
}

/* INFO: strrchr but without modifying the string */
const char *position_after(const char *str, const char needle) {
  const char *positioned = str + strlen(str);

  int i = strlen(str);
  while (i != 0) {
    i--;
    if (str[i] == needle) {
      positioned = str + i + 1;

      break;
    }
  }

  return positioned;
}

void *find_module_return_addr(struct maps *map, const char *suffix) {
  for (size_t i = 0; i < map->size; i++) {
    /* TODO: Make it NULL in 1 length path */
    if (map->maps[i].path == NULL) continue;

    const char *file_name = position_after(map->maps[i].path, '/');
    if (!file_name) continue;

    if (strlen(file_name) < strlen(suffix) || (map->maps[i].perms & PROT_EXEC) != 0 || strncmp(file_name, suffix, strlen(suffix)) != 0) continue;

    return (void *)map->maps[i].start;
  }

  return NULL;
}

void *find_module_base(struct maps *map, const char *file) {
  for (size_t i = 0; i < map->size; i++) {
    if (map->maps[i].path == NULL) continue;

    const char *file_path = map->maps[i].path;

    if (strlen(file_path) != strlen(file) || map->maps[i].offset != 0 || strncmp(file_path, file, strlen(file)) != 0) continue;

    return (void *)map->maps[i].start;
  }

  return NULL;
}

void *find_func_addr(struct maps *local_info, struct maps *remote_info, const char *module, const char *func) {
  uint8_t *local_base = (uint8_t *)find_module_base(local_info, module);
  if (local_base == NULL) {
    LOGE("failed to find local base for module %s", module);

    return NULL;
  }

  uint8_t *remote_base = (uint8_t *)find_module_base(remote_info, module);
  if (remote_base == NULL) {
    LOGE("failed to find remote base for module %s", module);

    return NULL;
  }

  LOGD("found local base %p remote base %p", local_base, remote_base);

  ElfImg *mod = ElfImg_create(module, local_base);
  if (mod == NULL) {
    LOGE("failed to create elf img %s", module);

    return NULL;
  }

  uint8_t *sym = (uint8_t *)getSymbAddress(mod, func);
  if (sym == NULL) {
    LOGE("failed to find symbol %s in %s", func, module);

    ElfImg_destroy(mod);

    return NULL;
  }

  LOGD("found symbol %s in %s: %p", func, module, sym);

  uintptr_t addr = (uintptr_t)(sym - local_base) + (uintptr_t)remote_base;
  LOGD("addr %p", (void *)addr);

  ElfImg_destroy(mod);

  return (void *)addr;
}

void align_stack(struct user_regs_struct *regs, long preserve) {
  /* INFO: ~0xf is a negative value, and REG_SP is unsigned,
             so we must cast REG_SP to signed type before subtracting
             then cast back to unsigned type.
  */
  regs->REG_SP = (uintptr_t)((intptr_t)(regs->REG_SP - preserve) & ~0xf);
}

uintptr_t remote_call(int pid, struct user_regs_struct *regs, uintptr_t func_addr, uintptr_t return_addr, long *args, size_t args_size) {
  align_stack(regs, 0);

  LOGV("calling remote function %" PRIxPTR " args %zu", func_addr, args_size);

  for (size_t i = 0; i < args_size; i++) {
    LOGV("arg %p", (void *)args[i]);
  }

  #if defined(__x86_64__)
    if (args_size >= 1) regs->rdi = args[0];
    if (args_size >= 2) regs->rsi = args[1];
    if (args_size >= 3) regs->rdx = args[2];
    if (args_size >= 4) regs->rcx = args[3];
    if (args_size >= 5) regs->r8 = args[4];
    if (args_size >= 6) regs->r9 = args[5];
    if (args_size > 6) {
      long remain = (args_size - 6L) * sizeof(long);
      align_stack(regs, remain);

      if (!write_proc(pid, (uintptr_t) regs->REG_SP, &args[6], remain)) LOGE("failed to push arguments");
    }

    regs->REG_SP -= sizeof(long);

    if (!write_proc(pid, (uintptr_t) regs->REG_SP, &return_addr, sizeof(return_addr))) LOGE("failed to write return addr");

    regs->REG_IP = func_addr;
  #elif defined(__i386__)
    if (args_size > 0) {
      long remain = (args_size) * sizeof(long);
      align_stack(regs, remain);

      if (!write_proc(pid, (uintptr_t) regs->REG_SP, args, remain)) LOGE("failed to push arguments");
    }

    regs->REG_SP -= sizeof(long);

    if (!write_proc(pid, (uintptr_t) regs->REG_SP, &return_addr, sizeof(return_addr))) LOGE("failed to write return addr");

    regs->REG_IP = func_addr;
  #elif defined(__aarch64__)
    for (size_t i = 0; i < args_size && i < 8; i++) {
      regs->regs[i] = args[i];
    }

    if (args_size > 8) {
      long remain = (args_size - 8) * sizeof(long);
      align_stack(regs, remain);

      write_proc(pid, (uintptr_t)regs->REG_SP, &args[8], remain);
    }

    regs->regs[30] = return_addr;
    regs->REG_IP = func_addr;
  #elif defined(__arm__)
    for (size_t i = 0; i < args_size && i < 4; i++) {
      regs->uregs[i] = args[i];
    }

    if (args_size > 4) {
      long remain = (args_size - 4) * sizeof(long);
      align_stack(regs, remain);

      write_proc(pid, (uintptr_t)regs->REG_SP, &args[4], remain);
    }

    regs->uregs[14] = return_addr;
    regs->REG_IP = func_addr;

    unsigned long CPSR_T_MASK = 1lu << 5;

    if ((regs->REG_IP & 1) != 0) {
      regs->REG_IP = regs->REG_IP & ~1;
      regs->uregs[16] = regs->uregs[16] | CPSR_T_MASK;
    } else {
      regs->uregs[16] = regs->uregs[16] & ~CPSR_T_MASK;
    }
  #endif

  if (!set_regs(pid, regs)) {
    LOGE("failed to set regs");

    return 0;
  }

  ptrace(PTRACE_CONT, pid, 0, 0);

  int status;
  wait_for_trace(pid, &status, __WALL);
  if (!get_regs(pid, regs)) {
    LOGE("failed to get regs after call");

    return 0;
  }

  if (WSTOPSIG(status) == SIGSEGV) {
    if ((uintptr_t)regs->REG_IP != return_addr) {
      LOGE("wrong return addr %p", (void *) regs->REG_IP);

      return 0;
    }

    return regs->REG_RET;
  } else {
    char status_str[64];
    parse_status(status, status_str, sizeof(status_str));

    LOGE("stopped by other reason %s at addr %p", status_str, (void *)regs->REG_IP);
  }

  return 0;
}

int fork_dont_care() {
  pid_t pid = fork();

  if (pid < 0) PLOGE("fork 1");
  else if (pid == 0) {
    pid = fork();
    if (pid < 0) PLOGE("fork 2");
    else if (pid > 0) exit(0);
  } else {
    int status;
    waitpid(pid, &status, __WALL);
  }

  return pid;
}

void tracee_skip_syscall(int pid) {
  struct user_regs_struct regs;
  if (!get_regs(pid, &regs)) {
    LOGE("failed to get seccomp regs");
    exit(1);
  }
  regs.REG_SYSNR = -1;
  if (!set_regs(pid, &regs)) {
    LOGE("failed to set seccomp regs");
    exit(1);
  }

  /* INFO: It might not work, don't check for error */
#if defined(__aarch64__)
  int sysnr = -1;
  struct iovec iov = {
    .iov_base = &sysnr,
    .iov_len = sizeof (int),
  };
  ptrace(PTRACE_SETREGSET, pid, NT_ARM_SYSTEM_CALL, &iov);
#elif defined(__arm__)
  ptrace(PTRACE_SET_SYSCALL, pid, 0, (void*) -1);
#endif

}

void wait_for_trace(int pid, int *status, int flags) {
  while (1) {
    pid_t result = waitpid(pid, status, flags);
    if (result == -1) {
      if (errno == EINTR) continue;

      PLOGE("wait %d failed", pid);
      exit(1);
    }

    /* INFO: We'll fork there. This will signal SIGCHLD. We just ignore and continue
               to avoid blocking/not continuing. */
    if (WSTOPSIG(*status) == SIGCHLD) {
      LOGI("process %d stopped by SIGCHLD, continue", pid);

      ptrace(PTRACE_CONT, pid, 0, 0);

      continue;
    } else if (*status >> 8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP << 8))) {
      tracee_skip_syscall(pid);

      ptrace(PTRACE_CONT, pid, 0, 0);

      continue;
    } else if (!WIFSTOPPED(*status)) {
      char status_str[64];
      parse_status(*status, status_str, sizeof(status_str));

      LOGE("process %d not stopped for trace: %s, exit", pid, status_str);

      exit(1);
    }

    return;
  }
}

void parse_status(int status, char *buf, size_t len) {
  snprintf(buf, len, "0x%x ", status);

  if (WIFEXITED(status)) {
    snprintf(buf + strlen(buf), len - strlen(buf), "exited with %d", WEXITSTATUS(status));
  } else if (WIFSIGNALED(status)) {
    snprintf(buf + strlen(buf), len - strlen(buf), "signaled with %s(%d)", sigabbrev_np(WTERMSIG(status)), WTERMSIG(status));
  } else if (WIFSTOPPED(status)) {
    snprintf(buf + strlen(buf), len - strlen(buf), "stopped by ");

    int stop_sig = WSTOPSIG(status);
    snprintf(buf + strlen(buf), len - strlen(buf), "signal=%s(%d),", sigabbrev_np(stop_sig), stop_sig);
    snprintf(buf + strlen(buf), len - strlen(buf), "event=%s", parse_ptrace_event(status));
  } else {
    snprintf(buf + strlen(buf), len - strlen(buf), "unknown");
  }
}

int get_program(int pid, char *buf, size_t size) {
  char path[PATH_MAX];
  snprintf(path, sizeof(path), "/proc/%d/exe", pid);

  ssize_t sz = readlink(path, buf, size);

  if (sz == -1) {
    PLOGE("readlink /proc/%d/exe", pid);

    return -1;
  }

  buf[sz] = '\0';

  return 0;
}

```

`loader/src/ptracer/utils.h`:

```h
#ifndef UTILS_H
#define UTILS_H

#include <sys/ptrace.h>

#include "daemon.h"

#ifdef __LP64__
  #define LOG_TAG "zygisk-ptrace64"
#else
  #define LOG_TAG "zygisk-ptrace32"
#endif

#include "logging.h"

struct map {
  uintptr_t start;
  uintptr_t end;
  uint8_t perms;
  bool is_private;
  uintptr_t offset;
  dev_t dev;
  ino_t inode;
  const char *path;
};

struct maps {
  struct map *maps;
  size_t size;
};

struct maps *parse_maps(const char *filename);

void free_maps(struct maps *maps);

#if defined(__x86_64__)
  #define REG_SP rsp
  #define REG_IP rip
  #define REG_RET rax
  #define REG_SYSNR orig_rax
#elif defined(__i386__)
  #define REG_SP esp
  #define REG_IP eip
  #define REG_RET eax
  #define REG_SYSNR orig_eax
#elif defined(__aarch64__)
  #define REG_SP sp
  #define REG_IP pc
  #define REG_RET regs[0]
  #define REG_SYSNR regs[8]
#elif defined(__arm__)
  #define REG_SP uregs[13]
  #define REG_IP uregs[15]
  #define REG_RET uregs[0]
  #define REG_SYSNR uregs[7]
  #define user_regs_struct user_regs
#endif

ssize_t write_proc(int pid, uintptr_t remote_addr, const void *buf, size_t len);

ssize_t read_proc(int pid, uintptr_t remote_addr, void *buf, size_t len);

bool get_regs(int pid, struct user_regs_struct *regs);

bool set_regs(int pid, struct user_regs_struct *regs);

void get_addr_mem_region(struct maps *map, uintptr_t addr, char *buf, size_t buf_size);

const char *position_after(const char *str, const char needle);

void *find_module_return_addr(struct maps *map, const char *suffix);

void *find_func_addr(struct maps *local_info, struct maps *remote_info, const char *module, const char *func);

void align_stack(struct user_regs_struct *regs, long preserve);

uintptr_t remote_call(int pid, struct user_regs_struct *regs, uintptr_t func_addr, uintptr_t return_addr, long *args, size_t args_size);

int fork_dont_care();

void wait_for_trace(int pid, int* status, int flags);

void parse_status(int status, char *buf, size_t len);

#define WPTEVENT(x) (x >> 16)

#define CASE_CONST_RETURN(x) case x: return #x;

static inline const char *parse_ptrace_event(int status) {
  status = status >> 16;

  switch (status) {
    CASE_CONST_RETURN(PTRACE_EVENT_FORK)
    CASE_CONST_RETURN(PTRACE_EVENT_VFORK)
    CASE_CONST_RETURN(PTRACE_EVENT_CLONE)
    CASE_CONST_RETURN(PTRACE_EVENT_EXEC)
    CASE_CONST_RETURN(PTRACE_EVENT_VFORK_DONE)
    CASE_CONST_RETURN(PTRACE_EVENT_EXIT)
    CASE_CONST_RETURN(PTRACE_EVENT_SECCOMP)
    CASE_CONST_RETURN(PTRACE_EVENT_STOP)
    default:
      return "(no event)";
  }
}

static inline const char *sigabbrev_np(int sig) {
  if (sig > 0 && sig < NSIG) return sys_signame[sig];

  return "(unknown)";
}

int get_program(int pid, char *buf, size_t size);

/* INFO: pid = 0, fd != nullptr -> set to fd
         pid != 0, fd != nullptr -> set to pid ns, give orig ns in fd
*/
bool switch_mnt_ns(int pid, int *fd);

#endif /* UTILS_H */
```

`module/build.gradle.kts`:

```kts
import android.databinding.tool.ext.capitalizeUS
import java.security.MessageDigest
import org.apache.tools.ant.filters.ReplaceTokens

import org.apache.tools.ant.filters.FixCrLfFilter

import org.apache.commons.codec.binary.Hex
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.security.KeyFactory
import java.security.KeyPairGenerator
import java.security.Signature
import java.security.interfaces.EdECPrivateKey
import java.security.interfaces.EdECPublicKey
import java.security.spec.EdECPrivateKeySpec
import java.security.spec.NamedParameterSpec
import java.util.TreeSet

plugins {
    alias(libs.plugins.agp.lib)
}

val moduleId: String by rootProject.extra
val moduleName: String by rootProject.extra
val verCode: Int by rootProject.extra
val verName: String by rootProject.extra
val minAPatchVersion: Int by rootProject.extra
val minKsuVersion: Int by rootProject.extra
val minKsudVersion: Int by rootProject.extra
val maxKsuVersion: Int by rootProject.extra
val minMagiskVersion: Int by rootProject.extra
val commitHash: String by rootProject.extra

android.buildFeatures {
    androidResources = false
    buildConfig = false
}

androidComponents.onVariants { variant ->
    val variantLowered = variant.name.lowercase()
    val variantCapped = variant.name.capitalizeUS()
    val buildTypeLowered = variant.buildType?.lowercase()

    val moduleDir = layout.buildDirectory.dir("outputs/module/$variantLowered")
    val zipFileName = "$moduleName-$verName-$verCode-$commitHash-$buildTypeLowered.zip".replace(' ', '-')

    val prepareModuleFilesTask = task<Sync>("prepareModuleFiles$variantCapped") {
        group = "module"
        dependsOn(
            ":loader:assemble$variantCapped",
            ":zygiskd:buildAndStrip",
        )
        into(moduleDir)
        from("${rootProject.projectDir}/README.md")
        from("$projectDir/src") {
            exclude("module.prop", "customize.sh", "post-fs-data.sh", "service.sh", "uninstall.sh")
            filter<FixCrLfFilter>("eol" to FixCrLfFilter.CrLf.newInstance("lf"))
        }
        from("$projectDir/src") {
            include("module.prop")
            expand(
                "moduleId" to moduleId,
                "moduleName" to moduleName,
                "versionName" to "$verName ($verCode-$commitHash-$variantLowered)",
                "versionCode" to verCode
            )
        }
        from("$projectDir/src") {
            include("customize.sh", "post-fs-data.sh", "service.sh", "uninstall.sh")
            val tokens = mapOf(
                "DEBUG" to if (buildTypeLowered == "debug") "true" else "false",
                "MIN_APATCH_VERSION" to "$minAPatchVersion",
                "MIN_KSU_VERSION" to "$minKsuVersion",
                "MIN_KSUD_VERSION" to "$minKsudVersion",
                "MIN_MAGISK_VERSION" to "$minMagiskVersion",
            )
            filter<ReplaceTokens>("tokens" to tokens)
            filter<FixCrLfFilter>("eol" to FixCrLfFilter.CrLf.newInstance("lf"))
        }
        into("bin") {
            from(project(":zygiskd").layout.buildDirectory.getAsFile().get())
            include("**/zygiskd")
        }
        into("lib") {
            from(project(":loader").layout.buildDirectory.file("intermediates/stripped_native_libs/$variantLowered/out/lib"))
        }
        into("webroot") {
            from("${rootProject.projectDir}/webroot")
        }

        val root = moduleDir.get()

        doLast {
            if (file("private_key").exists()) {
                val privateKey = file("private_key").readBytes()
                val publicKey = file("public_key").readBytes()
                val namedSpec = NamedParameterSpec("ed25519")
                val privKeySpec = EdECPrivateKeySpec(namedSpec, privateKey)
                val kf = KeyFactory.getInstance("ed25519")
                val privKey = kf.generatePrivate(privKeySpec);
                val sig = Signature.getInstance("ed25519")
                fun File.sha(realFile: File? = null) {
                    sig.update(this.name.toByteArray())
                    sig.update(0) // null-terminated string
                    val real = realFile ?: this
                    val buffer = ByteBuffer.allocate(8)
                        .order(ByteOrder.LITTLE_ENDIAN)
                        .putLong(real.length())
                        .array()
                    sig.update(buffer)
                    real.forEachBlock { bytes, size ->
                        sig.update(bytes, 0, size)
                    }
                }

                /* INFO: Misaki is the file that holds signed hash of
                           all files of ReZygisk module, to ensure the
                           zip (runtime and non-runtime) files hasn't
                           been tampered with.
                */
                fun misakiSign() {
                    sig.initSign(privKey)

                    val filesToProcess = TreeSet<File> { f1, f2 ->
                        f1.path.replace("\\", "/")
                            .compareTo(f2.path.replace("\\", "/"))
                    }

                    root.asFile.walkTopDown().forEach { file ->
                        if (!file.isFile) return@forEach

                        val fileName = file.name
                        if (fileName == "misaki.sig") return@forEach

                        filesToProcess.add(file)
                    }

                    filesToProcess.forEach { file -> file.sha(file) }

                    val misakiSignatureFile = root.file("misaki.sig").asFile
                    misakiSignatureFile.writeBytes(sig.sign())
                    misakiSignatureFile.appendBytes(publicKey)
                }

                fun getSign(name: String, abi: String, is64Bit: Boolean) {
                    val set = TreeSet<Pair<File, File?>> { o1, o2 ->
                        o1.first.path.replace("\\", "/")
                            .compareTo(o2.first.path.replace("\\", "/"))
                    }

                    val archSuffix = if (is64Bit) "64" else "32"
                    val pathSuffix = if (is64Bit) "lib64" else "lib"

                    set.add(Pair(root.file("module.prop").asFile, null))
                    set.add(Pair(root.file("sepolicy.rule").asFile, null))
                    set.add(Pair(root.file("post-fs-data.sh").asFile, null))
                    set.add(Pair(root.file("service.sh").asFile, null))
                    set.add(
                        Pair(
                            root.file("$pathSuffix/libzygisk.so").asFile,
                            root.file("lib/$abi/libzygisk.so").asFile
                        )
                    )
                    set.add(
                        Pair(
                            root.file("bin/zygisk-ptrace$archSuffix").asFile,
                            root.file("lib/$abi/libzygisk_ptrace.so").asFile
                        )
                    )
                    set.add(
                        Pair(
                            root.file("bin/zygiskd$archSuffix").asFile,
                            root.file("bin/$abi/zygiskd").asFile
                        )
                    )

                    sig.initSign(privKey)
                    set.forEach { it.first.sha(it.second) }
                    val signFile = root.file(name).asFile
                    signFile.writeBytes(sig.sign())
                    signFile.appendBytes(publicKey)
                }

                /* INFO: Machikado is the name of files that holds signed hash of
                           all runtime files of ReZygisk module, to ensure the
                           runtime files hasn't been tampered with.
                */
                println("=== Guards the peace of Machikado ===")

                getSign("machikado.arm64", "arm64-v8a", true)
                getSign("machikado.arm", "armeabi-v7a", false)

                getSign("machikado.x86_64", "x86_64", true)
                getSign("machikado.x86", "x86", false)

                fileTree(moduleDir).visit {
                    if (isDirectory) return@visit

                    val md = MessageDigest.getInstance("SHA-256")
                    file.forEachBlock(4096) { bytes, size ->
                        md.update(bytes, 0, size)
                    }

                    file(file.path + ".sha256").writeText(Hex.encodeHexString(md.digest()))
                }

                println("===   At the kitsune's wedding   ===")

                misakiSign()
            } else {
                println("no private_key found, this build will not be signed")

                root.file("machikado.arm64").asFile.createNewFile()
                root.file("machikado.arm").asFile.createNewFile()

                root.file("machikado.x86_64").asFile.createNewFile()
                root.file("machikado.x86").asFile.createNewFile()

                fileTree(moduleDir).visit {
                    if (isDirectory) return@visit

                    val md = MessageDigest.getInstance("SHA-256")
                    file.forEachBlock(4096) { bytes, size ->
                        md.update(bytes, 0, size)
                    }

                    file(file.path + ".sha256").writeText(Hex.encodeHexString(md.digest()))
                }

                root.file("misaki.sig").asFile.createNewFile()
            }
        }
    }

    val zipTask = task<Zip>("zip$variantCapped") {
        group = "module"
        dependsOn(prepareModuleFilesTask)
        archiveFileName.set(zipFileName)
        destinationDirectory.set(layout.buildDirectory.file("outputs/release").get().asFile)
        from(moduleDir)
    }

    val pushTask = task<Exec>("push$variantCapped") {
        group = "module"
        dependsOn(zipTask)
        commandLine("adb", "push", zipTask.outputs.files.singleFile.path, "/data/local/tmp")
    }

    val installKsuTask = task("installKsu$variantCapped") {
        group = "module"
        dependsOn(pushTask)
        doLast {
            exec {
                commandLine(
                    "adb", "shell", "echo",
                    "/data/adb/ksud module install /data/local/tmp/$zipFileName",
                    "> /data/local/tmp/install.sh"
                )
            }
            exec { commandLine("adb", "shell", "chmod", "755", "/data/local/tmp/install.sh") }
            exec { commandLine("adb", "shell", "su", "-c", "/data/local/tmp/install.sh") }
        }
    }

    val installAPatchTask = task<Exec>("installAPatch$variantCapped") {
        group = "module"
        dependsOn(pushTask)
        commandLine("adb", "shell", "su", "-c", "/data/adb/apd module install /data/local/tmp/$zipFileName")
    }

    val installMagiskTask = task<Exec>("installMagisk$variantCapped") {
        group = "module"
        dependsOn(pushTask)
        commandLine("adb", "shell", "su", "-M", "-c", "magisk --install-module /data/local/tmp/$zipFileName")
    }

    task<Exec>("installAPatchAndReboot$variantCapped") {
        group = "module"
        dependsOn(installAPatchTask)
        commandLine("adb", "reboot")
    }

    task<Exec>("installKsuAndReboot$variantCapped") {
        group = "module"
        dependsOn(installKsuTask)
        commandLine("adb", "reboot")
    }

    task<Exec>("installMagiskAndReboot$variantCapped") {
        group = "module"
        dependsOn(installMagiskTask)
        commandLine("adb", "reboot")
    }
}

```

`module/src/META-INF/com/google/android/update-binary`:

```
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v19.0+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 19000 ] && require_new_magisk

if [ $MAGISK_VER_CODE -ge 20400 ]; then
  # New Magisk have complete installation logic within util_functions.sh
  install_module
  exit 0
fi

#################
# Legacy Support
#################

TMPDIR=/dev/tmp
PERSISTDIR=/sbin/.magisk/mirror/persist

is_legacy_script() {
  unzip -l "$ZIPFILE" install.sh | grep -q install.sh
  return $?
}

print_modname() {
  local len
  len=`echo -n $MODNAME | wc -c`
  len=$((len + 2))
  local pounds=`printf "%${len}s" | tr ' ' '*'`
  ui_print "$pounds"
  ui_print " $MODNAME "
  ui_print "$pounds"
  ui_print "*******************"
  ui_print " Powered by Magisk "
  ui_print "*******************"
}

# Override abort as old scripts have some issues
abort() {
  ui_print "$1"
  $BOOTMODE || recovery_cleanup
  [ -n $MODPATH ] && rm -rf $MODPATH
  rm -rf $TMPDIR
  exit 1
}

rm -rf $TMPDIR 2>/dev/null
mkdir -p $TMPDIR

# Preperation for flashable zips
setup_flashable

# Mount partitions
mount_partitions

# Detect version and architecture
api_level_arch_detect

# Setup busybox and binaries
$BOOTMODE && boot_actions || recovery_actions

##############
# Preparation
##############

# Extract prop file
unzip -o "$ZIPFILE" module.prop -d $TMPDIR >&2
[ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"

$BOOTMODE && MODDIRNAME=modules_update || MODDIRNAME=modules
MODULEROOT=$NVBASE/$MODDIRNAME
MODID=`grep_prop id $TMPDIR/module.prop`
MODPATH=$MODULEROOT/$MODID
MODNAME=`grep_prop name $TMPDIR/module.prop`

# Create mod paths
rm -rf $MODPATH 2>/dev/null
mkdir -p $MODPATH

##########
# Install
##########

if is_legacy_script; then
  unzip -oj "$ZIPFILE" module.prop install.sh uninstall.sh 'common/*' -d $TMPDIR >&2

  # Load install script
  . $TMPDIR/install.sh

  # Callbacks
  print_modname
  on_install

  # Custom uninstaller
  [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh

  # Skip mount
  $SKIPMOUNT && touch $MODPATH/skip_mount

  # prop file
  $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop

  # Module info
  cp -af $TMPDIR/module.prop $MODPATH/module.prop

  # post-fs-data scripts
  $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh

  # service scripts
  $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

  ui_print "- Setting permissions"
  set_permissions
else
  print_modname

  unzip -o "$ZIPFILE" customize.sh -d $MODPATH >&2

  if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
    ui_print "- Extracting module files"
    unzip -o "$ZIPFILE" -x 'META-INF/*' -d $MODPATH >&2

    # Default permissions
    set_perm_recursive $MODPATH 0 0 0755 0644
  fi

  # Load customization script
  [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
fi

# Handle replace folders
for TARGET in $REPLACE; do
  ui_print "- Replace target: $TARGET"
  mktouch $MODPATH$TARGET/.replace
done

if $BOOTMODE; then
  # Update info for Magisk Manager
  mktouch $NVBASE/modules/$MODID/update
  cp -af $MODPATH/module.prop $NVBASE/modules/$MODID/module.prop
fi

# Copy over custom sepolicy rules
if [ -f $MODPATH/sepolicy.rule -a -e $PERSISTDIR ]; then
  ui_print "- Installing custom sepolicy patch"
  PERSISTMOD=$PERSISTDIR/magisk/$MODID
  mkdir -p $PERSISTMOD
  cp -af $MODPATH/sepolicy.rule $PERSISTMOD/sepolicy.rule
fi

# Remove stuffs that don't belong to modules
rm -rf \
$MODPATH/system/placeholder $MODPATH/customize.sh \
$MODPATH/README.md $MODPATH/.git* 2>/dev/null

#############
# Finalizing
#############

cd /
$BOOTMODE || recovery_cleanup
rm -rf $TMPDIR

ui_print "- Done"
exit 0
```

`module/src/META-INF/com/google/android/updater-script`:

```
#MAGISK

```

`module/src/customize.sh`:

```sh
# shellcheck disable=SC2034
SKIPUNZIP=1

DEBUG=@DEBUG@
MIN_KSU_VERSION=@MIN_KSU_VERSION@
MIN_KSUD_VERSION=@MIN_KSUD_VERSION@
MIN_MAGISK_VERSION=@MIN_MAGISK_VERSION@
MIN_APATCH_VERSION=@MIN_APATCH_VERSION@

if [ "$BOOTMODE" ] && [ "$KSU" ]; then
  ui_print "- Installing from KernelSU app"
  ui_print "- KernelSU version: $KSU_KERNEL_VER_CODE (kernel) + $KSU_VER_CODE (ksud)"
  if ! [ "$KSU_KERNEL_VER_CODE" ] || [ "$KSU_KERNEL_VER_CODE" -lt "$MIN_KSU_VERSION" ]; then
    ui_print "*********************************************************"
    ui_print "! KernelSU version is too old!"
    ui_print "! Please update KernelSU to latest version"
    abort    "*********************************************************"
  fi
  if ! [ "$KSU_VER_CODE" ] || [ "$KSU_VER_CODE" -lt "$MIN_KSUD_VERSION" ]; then
    ui_print "*********************************************************"
    ui_print "! ksud version is too old!"
    ui_print "! Please update KernelSU Manager to latest version"
    abort    "*********************************************************"
  fi
  if [ "$(which magisk)" ]; then
    ui_print "*********************************************************"
    ui_print "! Multiple root implementation is NOT supported!"
    ui_print "! Please uninstall Magisk before installing ReZygisk"
    abort    "*********************************************************"
  fi
  elif [ "$BOOTMODE" ] && [ "$APATCH" ]; then
    ui_print "- Installing from APatch app"
    if ! [ "$APATCH_VER_CODE" ] || [ "$APATCH_VER_CODE" -lt "$MIN_APATCH_VERSION" ]; then
      ui_print "*********************************************************"
      ui_print "! APatch version is too old!"
      ui_print "! Please update APatch to latest version"
      abort    "*********************************************************"
    fi
elif [ "$BOOTMODE" ] && [ "$MAGISK_VER_CODE" ]; then
  ui_print "- Installing from Magisk app"
  if [ "$MAGISK_VER_CODE" -lt "$MIN_MAGISK_VERSION" ]; then
    ui_print "*********************************************************"
    ui_print "! Magisk version is too old!"
    ui_print "! Please update Magisk to latest version"
    abort    "*********************************************************"
  fi
else
  ui_print "*********************************************************"
  ui_print "! Install from recovery is not supported"
  ui_print "! Please install from KernelSU or Magisk app"
  abort    "*********************************************************"
fi

VERSION=$(grep_prop version "${TMPDIR}/module.prop")
ui_print "- Installing ReZygisk $VERSION"

# check android
if [ "$API" -lt 26 ]; then
  ui_print "! Unsupported sdk: $API"
  abort "! Minimal supported sdk is 26 (Android 8.0)"
else
  ui_print "- Device sdk: $API"
fi

# check architecture
if [ "$ARCH" != "arm" ] && [ "$ARCH" != "arm64" ] && [ "$ARCH" != "x86" ] && [ "$ARCH" != "x64" ]; then
  abort "! Unsupported platform: $ARCH"
else
  ui_print "- Device platform: $ARCH"
fi

ui_print "- Extracting verify.sh"
unzip -o "$ZIPFILE" 'verify.sh' -d "$TMPDIR" >&2
if [ ! -f "$TMPDIR/verify.sh" ]; then
  ui_print "*********************************************************"
  ui_print "! Unable to extract verify.sh!"
  ui_print "! This zip may be corrupted, please try downloading again"
  abort    "*********************************************************"
fi
. "$TMPDIR/verify.sh"
extract "$ZIPFILE" 'customize.sh'  "$TMPDIR/.vunzip"
extract "$ZIPFILE" 'verify.sh'     "$TMPDIR/.vunzip"
extract "$ZIPFILE" 'sepolicy.rule' "$TMPDIR"

if [ "$KSU" ]; then
  ui_print "- Checking SELinux patches"
  if ! check_sepolicy "$TMPDIR/sepolicy.rule"; then
    ui_print "*********************************************************"
    ui_print "! Unable to apply SELinux patches!"
    ui_print "! Your kernel may not support SELinux patch fully"
    abort    "*********************************************************"
  fi
fi

ui_print "- Extracting module files"
extract "$ZIPFILE" 'module.prop'     "$MODPATH"
extract "$ZIPFILE" 'post-fs-data.sh' "$MODPATH"
extract "$ZIPFILE" 'service.sh'      "$MODPATH"
extract "$ZIPFILE" 'uninstall.sh'    "$MODPATH"
mv "$TMPDIR/sepolicy.rule" "$MODPATH"

mkdir "$MODPATH/bin"
mkdir "$MODPATH/webroot"

ui_print "- Extracting webroot"
unzip -o "$ZIPFILE" "webroot/*" -x "*.sha256" -d "$MODPATH"

# INFO: Utilize the one with the biggest output, as some devices with Tango have the full list
#         in ro.product.cpu.abilist but others only have a subset there, and the full list in
#         ro.system.product.cpu.abilist
CPU_ABIS_PROP1=$(getprop ro.system.product.cpu.abilist)
CPU_ABIS_PROP2=$(getprop ro.product.cpu.abilist)

if [ "${#CPU_ABIS_PROP2}" -gt "${#CPU_ABIS_PROP1}" ]; then
  CPU_ABIS=$CPU_ABIS_PROP2
else
  CPU_ABIS=$CPU_ABIS_PROP1
fi

SUPPORTS_32BIT=false
SUPPORTS_64BIT=false

if [[ "$CPU_ABIS" == *"x86"* && "$CPU_ABIS" != "x86_64" || "$CPU_ABIS" == *"armeabi"* ]]; then
  SUPPORTS_32BIT=true
  ui_print "- Device supports 32-bit"
fi

if [[ "$CPU_ABIS" == *"x86_64"* || "$CPU_ABIS" == *"arm64-v8a"* ]]; then
  SUPPORTS_64BIT=true
  ui_print "- Device supports 64-bit"
fi

if [ "$SUPPORTS_32BIT" = true ]; then
  mkdir "$MODPATH/lib"
fi

if [ "$SUPPORTS_64BIT" = true ]; then
  mkdir "$MODPATH/lib64"
fi

if [ "$ARCH" = "x86" ] || [ "$ARCH" = "x64" ]; then
  if [ "$SUPPORTS_32BIT" = true ]; then
    ui_print "- Extracting x86 libraries"
    extract "$ZIPFILE" 'bin/x86/zygiskd' "$MODPATH/bin" true
    mv "$MODPATH/bin/zygiskd" "$MODPATH/bin/zygiskd32"
    extract "$ZIPFILE" 'lib/x86/libzygisk.so' "$MODPATH/lib" true
    extract "$ZIPFILE" 'lib/x86/libzygisk_ptrace.so' "$MODPATH/bin" true
    mv "$MODPATH/bin/libzygisk_ptrace.so" "$MODPATH/bin/zygisk-ptrace32"

    extract "$ZIPFILE" 'machikado.x86' "$MODPATH" true
  fi

  if [ "$SUPPORTS_64BIT" = true ]; then
    ui_print "- Extracting x64 libraries"
    extract "$ZIPFILE" 'bin/x86_64/zygiskd' "$MODPATH/bin" true
    mv "$MODPATH/bin/zygiskd" "$MODPATH/bin/zygiskd64"
    extract "$ZIPFILE" 'lib/x86_64/libzygisk.so' "$MODPATH/lib64" true
    extract "$ZIPFILE" 'lib/x86_64/libzygisk_ptrace.so' "$MODPATH/bin" true
    mv "$MODPATH/bin/libzygisk_ptrace.so" "$MODPATH/bin/zygisk-ptrace64"

    extract "$ZIPFILE" 'machikado.x86_64' "$MODPATH" true
  fi
else
  if [ "$SUPPORTS_32BIT" = true ]; then
    ui_print "- Extracting arm libraries"
    extract "$ZIPFILE" 'bin/armeabi-v7a/zygiskd' "$MODPATH/bin" true
    mv "$MODPATH/bin/zygiskd" "$MODPATH/bin/zygiskd32"
    extract "$ZIPFILE" 'lib/armeabi-v7a/libzygisk.so' "$MODPATH/lib" true
    extract "$ZIPFILE" 'lib/armeabi-v7a/libzygisk_ptrace.so' "$MODPATH/bin" true
    mv "$MODPATH/bin/libzygisk_ptrace.so" "$MODPATH/bin/zygisk-ptrace32"

    extract "$ZIPFILE" 'machikado.arm' "$MODPATH" true
  fi

  if [ "$SUPPORTS_64BIT" = true ]; then
    ui_print "- Extracting arm64 libraries"
    extract "$ZIPFILE" 'bin/arm64-v8a/zygiskd' "$MODPATH/bin" true
    mv "$MODPATH/bin/zygiskd" "$MODPATH/bin/zygiskd64"
    extract "$ZIPFILE" 'lib/arm64-v8a/libzygisk.so' "$MODPATH/lib64" true
    extract "$ZIPFILE" 'lib/arm64-v8a/libzygisk_ptrace.so' "$MODPATH/bin" true
    mv "$MODPATH/bin/libzygisk_ptrace.so" "$MODPATH/bin/zygisk-ptrace64"

    extract "$ZIPFILE" 'machikado.arm64' "$MODPATH" true
  fi
fi

ui_print "- Setting permissions"
set_perm_recursive "$MODPATH/bin" 0 0 0755 0755

if [ "$SUPPORTS_32BIT" = true ]; then
  set_perm_recursive "$MODPATH/lib" 0 0 0755 0644 u:object_r:system_lib_file:s0
fi

if [ "$SUPPORTS_64BIT" = true ]; then
  set_perm_recursive "$MODPATH/lib64" 0 0 0755 0644 u:object_r:system_lib_file:s0
fi

# If Huawei's Maple is enabled, system_server is created with a special way which is out of Zygisk's control
HUAWEI_MAPLE_ENABLED=$(grep_prop ro.maple.enable)
if [ "$HUAWEI_MAPLE_ENABLED" == "1" ]; then
  ui_print "- Add ro.maple.enable=0"
  echo "ro.maple.enable=0" >>"$MODPATH/system.prop"
fi

```

`module/src/module.prop`:

```prop
id=${moduleId}
name=${moduleName}
version=${versionName}
versionCode=${versionCode}
author=The PerformanC Organization
description=Standalone implementation of Zygisk.
updateJson=https://raw.githubusercontent.com/ThePedroo/RemoteFiles/refs/heads/main/ReZygisk/update.json
managedFeatures=kernel_umount

```

`module/src/post-fs-data.sh`:

```sh
#!/system/bin/sh

MODDIR=${0%/*}
if [ "$ZYGISK_ENABLED" ]; then
  exit 0
fi

cd "$MODDIR"

if [ "$(which magisk)" ]; then
  for file in ../*; do
    if [ -d "$file" ] && [ -d "$file/zygisk" ] && ! [ -f "$file/disable" ]; then
      if [ -f "$file/post-fs-data.sh" ]; then
        cd "$file"
        log -p i -t "zygisk-sh" "Manually trigger post-fs-data.sh for $file"
        sh "$(realpath ./post-fs-data.sh)"
        cd "$MODDIR"
      fi
    fi
  done
fi

create_sys_perm() {
  mkdir -p $1
  chmod 555 $1
  chcon u:object_r:system_file:s0 $1
}

export TMP_PATH=/data/adb/rezygisk
rm -rf $TMP_PATH

create_sys_perm $TMP_PATH

# INFO: Utilize the one with the biggest output, as some devices with Tango have the full list
#         in ro.product.cpu.abilist but others only have a subset there, and the full list in
#         ro.system.product.cpu.abilist
CPU_ABIS_PROP1=$(getprop ro.system.product.cpu.abilist)
CPU_ABIS_PROP2=$(getprop ro.product.cpu.abilist)

if [ "${#CPU_ABIS_PROP2}" -gt "${#CPU_ABIS_PROP1}" ]; then
  CPU_ABIS=$CPU_ABIS_PROP2
else
  CPU_ABIS=$CPU_ABIS_PROP1
fi

if [[ "$CPU_ABIS" == *"arm64-v8a"* || "$CPU_ABIS" == *"x86_64"* ]]; then
  ./bin/zygisk-ptrace64 monitor &
else
  # INFO: Device is 32-bit only

  ./bin/zygisk-ptrace32 monitor &
fi

```

`module/src/sepolicy.rule`:

```rule
type zygisk_file file_type
typeattribute zygisk_file mlstrustedobject
allow zygote zygisk_file sock_file {read write}

allow zygote magisk lnk_file read
allow zygote unlabeled file {read open}
allow zygote zygote capability sys_chroot
allow zygote su dir search
allow zygote su {lnk_file file} read

allow zygote adb_data_file dir search
allow zygote adb_data_file file *
allow zygote proc file {read open}
allow zygote nsfs file {read open}
allow zygote zygote process execmem
allow system_server system_server process execmem
allow zygote tmpfs file *
allow zygote appdomain_tmpfs file *

```

`module/src/service.sh`:

```sh
#!/system/bin/sh

DEBUG=@DEBUG@

MODDIR=${0%/*}
if [ "$ZYGISK_ENABLED" ]; then
  exit 0
fi

cd "$MODDIR"

if [ "$(which magisk)" ]; then
  for file in ../*; do
    if [ -d "$file" ] && [ -d "$file/zygisk" ] && ! [ -f "$file/disable" ]; then
      if [ -f "$file/service.sh" ]; then
        cd "$file"
        log -p i -t "zygisk-sh" "Manually trigger service.sh for $file"
        sh "$(realpath ./service.sh)" &
        cd "$MODDIR"
      fi
    fi
  done
fi

```

`module/src/uninstall.sh`:

```sh
#!/system/bin/sh

export TMP_PATH=/data/adb/rezygisk
rm -rf $TMP_PATH
```

`module/src/verify.sh`:

```sh
TMPDIR_FOR_VERIFY="$TMPDIR/.vunzip"
mkdir "$TMPDIR_FOR_VERIFY"

abort_verify() {
  ui_print "*********************************************************"
  ui_print "! $1"
  ui_print "! This zip may be corrupted, please try downloading again"
  abort    "*********************************************************"
}

# extract <zip> <file> <target dir> <junk paths>
extract() {
  zip=$1
  file=$2
  dir=$3
  junk_paths=$4
  [ -z "$junk_paths" ] && junk_paths=false
  opts="-o"
  [ $junk_paths = true ] && opts="-oj"

  file_path=""
  hash_path=""
  if [ $junk_paths = true ]; then
    file_path="$dir/$(basename "$file")"
    hash_path="$TMPDIR_FOR_VERIFY/$(basename "$file").sha256"
  else
    file_path="$dir/$file"
    hash_path="$TMPDIR_FOR_VERIFY/$file.sha256"
  fi

  unzip $opts "$zip" "$file" -d "$dir" >&2
  [ -f "$file_path" ] || abort_verify "$file not exists"

  unzip $opts "$zip" "$file.sha256" -d "$TMPDIR_FOR_VERIFY" >&2
  [ -f "$hash_path" ] || abort_verify "$file.sha256 not exists"

  (echo "$(cat "$hash_path")  $file_path" | sha256sum -c -s -) || abort_verify "Failed to verify $file"
  ui_print "- Verified $file" >&1
}

file="META-INF/com/google/android/update-binary"
file_path="$TMPDIR_FOR_VERIFY/$file"
hash_path="$file_path.sha256"
unzip -o "$ZIPFILE" "META-INF/com/google/android/*" -d "$TMPDIR_FOR_VERIFY" >&2
[ -f "$file_path" ] || abort_verify "$file not exists"
if [ -f "$hash_path" ]; then
  (echo "$(cat "$hash_path")  $file_path" | sha256sum -c -s -) || abort_verify "Failed to verify $file"
  ui_print "- Verified $file" >&1
else
  ui_print "- Download from Magisk app"
fi

```

`settings.gradle.kts`:

```kts
enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "ReZygisk"
include(
    ":loader",
    ":module",
    ":zygiskd",
)

```

`webroot/LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

```

`webroot/assets/actions/filled.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="m426-330 195-125q14-9 14-25t-14-25L426-630q-15-10-30.5-1.5T380-605v250q0 18 15.5 26.5T426-330Zm54 250q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"/></svg>
```

`webroot/assets/actions/outlined.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="m426-330 195-125q14-9 14-25t-14-25L426-630q-15-10-30.5-1.5T380-605v250q0 18 15.5 26.5T426-330Zm54 250q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>
```

`webroot/assets/back.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="36px" viewBox="0 -960 960 960" width="36px" fill="#e8eaed"><path d="m287-446.67 240 240L480-160 160-480l320-320 47 46.67-240 240h513v66.66H287Z"/></svg>
```

`webroot/assets/close.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="40px" viewBox="0 -960 960 960" width="40px" fill="#e8eaed"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg>
```

`webroot/assets/content.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="40px" viewBox="0 -960 960 960" width="40px" fill="#e8eaed"><path d="M320-213.33q-27 0-46.83-19.84Q253.33-253 253.33-280v-533.33q0-27 19.84-46.84Q293-880 320-880h413.33q27 0 46.84 19.83Q800-840.33 800-813.33V-280q0 27-19.83 46.83-19.84 19.84-46.84 19.84H320Zm0-66.67h413.33v-533.33H320V-280ZM186.67-80q-27 0-46.84-19.83Q120-119.67 120-146.67v-600h66.67v600h480V-80h-480ZM320-280v-533.33V-280Z"/></svg>
```

`webroot/assets/delete.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="40px" viewBox="0 -960 960 960" width="40px" fill="#e8eaed"><path d="M267.33-120q-27.5 0-47.08-19.58-19.58-19.59-19.58-47.09V-740H160v-66.67h192V-840h256v33.33h192V-740h-40.67v553.33q0 27-19.83 46.84Q719.67-120 692.67-120H267.33Zm425.34-620H267.33v553.33h425.34V-740Zm-328 469.33h66.66v-386h-66.66v386Zm164 0h66.66v-386h-66.66v386ZM267.33-740v553.33V-740Z"/></svg>
```

`webroot/assets/ec-icon.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="60px" viewBox="0 -960 960 960" width="60px" fill="#ba1a1a"><path d="M92-120q-9 0-15.65-4.13Q69.7-128.25 66-135q-4.17-6.6-4.58-14.3Q61-157 66-165l388-670q5-8 11.5-11.5T480-850q8 0 14.5 3.5T506-835l388 670q5 8 4.58 15.7-.41 7.7-4.58 14.3-3.7 6.75-10.35 10.87Q877-120 868-120H92Zm392.18-117q12.82 0 21.32-8.68 8.5-8.67 8.5-21.5 0-12.82-8.68-21.32-8.67-8.5-21.5-8.5-12.82 0-21.32 8.68-8.5 8.67-8.5 21.5 0 12.82 8.68 21.32 8.67 8.5 21.5 8.5Zm0-111q12.82 0 21.32-8.63 8.5-8.62 8.5-21.37v-164q0-12.75-8.68-21.38-8.67-8.62-21.5-8.62-12.82 0-21.32 8.62-8.5 8.63-8.5 21.38v164q0 12.75 8.68 21.37 8.67 8.63 21.5 8.63Z"/></svg>
```

`webroot/assets/error.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240Zm40 360q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>
```

`webroot/assets/expand.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="m480-340 180-180-57-56-123 123-123-123-57 56 180 180Zm0 260q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>
```

`webroot/assets/home/filled.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M160-200v-360q0-19 8.5-36t23.5-28l240-180q21-16 48-16t48 16l240 180q15 11 23.5 28t8.5 36v360q0 33-23.5 56.5T720-120H600q-17 0-28.5-11.5T560-160v-200q0-17-11.5-28.5T520-400h-80q-17 0-28.5 11.5T400-360v200q0 17-11.5 28.5T360-120H240q-33 0-56.5-23.5T160-200Z"/></svg>
```

`webroot/assets/home/outlined.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M240-200h120v-200q0-17 11.5-28.5T400-440h160q17 0 28.5 11.5T600-400v200h120v-360L480-740 240-560v360Zm-80 0v-360q0-19 8.5-36t23.5-28l240-180q21-16 48-16t48 16l240 180q15 11 23.5 28t8.5 36v360q0 33-23.5 56.5T720-120H560q-17 0-28.5-11.5T520-160v-200h-80v200q0 17-11.5 28.5T400-120H240q-33 0-56.5-23.5T160-200Zm320-270Z"/></svg>
```

`webroot/assets/mark.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q54 0 104-17.5t92-50.5L228-676q-33 42-50.5 92T160-480q0 134 93 227t227 93Zm252-124q33-42 50.5-92T800-480q0-134-93-227t-227-93q-54 0-104 17.5T284-732l448 448Z"/></svg>
```

`webroot/assets/modules/filled.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M440-91 160-252q-19-11-29.5-29T120-321v-318q0-22 10.5-40t29.5-29l280-161q19-11 40-11t40 11l280 161q19 11 29.5 29t10.5 40v318q0 22-10.5 40T800-252L520-91q-19 11-40 11t-40-11Zm0-366v274l40 23 40-23v-274l240-139v-42l-43-25-237 137-237-137-43 25v42l240 139Z"/></svg>
```

`webroot/assets/modules/outlined.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M440-183v-274L200-596v274l240 139Zm80 0 240-139v-274L520-457v274Zm-40-343 237-137-237-137-237 137 237 137ZM160-252q-19-11-29.5-29T120-321v-318q0-22 10.5-40t29.5-29l280-161q19-11 40-11t40 11l280 161q19 11 29.5 29t10.5 40v318q0 22-10.5 40T800-252L520-91q-19 11-40 11t-40-11L160-252Zm320-228Z"/></svg>
```

`webroot/assets/settings/filled.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M433-80q-27 0-46.5-18T363-142l-9-66q-13-5-24.5-12T307-235l-62 26q-25 11-50 2t-39-32l-47-82q-14-23-8-49t27-43l53-40q-1-7-1-13.5v-27q0-6.5 1-13.5l-53-40q-21-17-27-43t8-49l47-82q14-23 39-32t50 2l62 26q11-8 23-15t24-12l9-66q4-26 23.5-44t46.5-18h94q27 0 46.5 18t23.5 44l9 66q13 5 24.5 12t22.5 15l62-26q25-11 50-2t39 32l47 82q14 23 8 49t-27 43l-53 40q1 7 1 13.5v27q0 6.5-2 13.5l53 40q21 17 27 43t-8 49l-48 82q-14 23-39 32t-50-2l-60-26q-11 8-23 15t-24 12l-9 66q-4 26-23.5 44T527-80h-94Zm49-260q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Z"/></svg>
```

`webroot/assets/settings/outlined.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"><path d="M433-80q-27 0-46.5-18T363-142l-9-66q-13-5-24.5-12T307-235l-62 26q-25 11-50 2t-39-32l-47-82q-14-23-8-49t27-43l53-40q-1-7-1-13.5v-27q0-6.5 1-13.5l-53-40q-21-17-27-43t8-49l47-82q14-23 39-32t50 2l62 26q11-8 23-15t24-12l9-66q4-26 23.5-44t46.5-18h94q27 0 46.5 18t23.5 44l9 66q13 5 24.5 12t22.5 15l62-26q25-11 50-2t39 32l47 82q14 23 8 49t-27 43l-53 40q1 7 1 13.5v27q0 6.5-2 13.5l53 40q21 17 27 43t-8 49l-48 82q-14 23-39 32t-50-2l-60-26q-11 8-23 15t-24 12l-9 66q-4 26-23.5 44T527-80h-94Zm7-80h79l14-106q31-8 57.5-23.5T639-327l99 41 39-68-86-65q5-14 7-29.5t2-31.5q0-16-2-31.5t-7-29.5l86-65-39-68-99 42q-22-23-48.5-38.5T533-694l-13-106h-79l-14 106q-31 8-57.5 23.5T321-633l-99-41-39 68 86 64q-5 15-7 30t-2 32q0 16 2 31t7 30l-86 65 39 68 99-42q22 23 48.5 38.5T427-266l13 106Zm42-180q58 0 99-41t41-99q0-58-41-99t-99-41q-59 0-99.5 41T342-480q0 58 40.5 99t99.5 41Zm-2-140Z"/></svg>
```

`webroot/assets/tick.svg`:

```svg
<svg class="brightc" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed">
  <path d="m424-296 282-282-56-56-226 226-114-114-56 56 170 170Zm56 216q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
</svg>
```

`webroot/assets/warn.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240Zm40 360q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>
```

`webroot/css/error.css`:

```css
.e-container {
  background-color: black;
  z-index: 30;
  position: fixed;
  top: 0;
  bottom: 0; 
  left: 0; 
  right: 0; 
  color: #fff;
}

.e-main {
  background-color: black;
  color: #fff;
}

.e-wrap {
  display: flex;
  align-items: center;
  overflow: auto;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
} 

.e-bg {
  background-color: black;
  color: #fff;
}

.e-card {
  margin: 30px;
  color: #fff;
}

.e-font {
  color: #ba1a1a;
}

.e-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 120px;
  height: 40px;
  border-radius: 30px;
  background-color: #ba1a1a;
  color: black;
  transition: transform 0.1s ease-in-out;
}

.e-button:active {
  transform: scale(90%) 
}
```

`webroot/css/icons.css`:

```css
/* Dark */
#ni_home {
  background: url(../assets/home/outlined.svg);
  width: 24px;
  height: 24px;
  z-index: 10;
  filter: invert(1);
}

#ni_modules {
  background: url(../assets/modules/outlined.svg);
  width: 24px;
  height: 24px;
  z-index: 10;
  filter: invert(1);
}

#ni_actions {
  background: url(../assets/actions/outlined.svg);
  width: 24px;
  height: 24px;
  z-index: 10;
  filter: invert(1);
}

#ni_settings {
  background: url(../assets/settings/outlined.svg);
  width: 24px;
  height: 24px;
  z-index: 10;
  filter: invert(1);
}

/* Light */
.light_icon_mode {
  filter: invert(0) !important;
}

#ec_icon {
  background: url(../assets/ec-icon.svg);
  z-index: 40;
}

/* .fill {

} */
```

`webroot/css/index.css`:

```css
:root {
  --background: #141414;
  --font: #fff;
  --desc: #c9c9c9;
  --dim: #1c1c1c;
  --error: #8d1d19;
  --icon: #494949;
  --icon-bc: #292929;
  --small-card: var(--icon-bc);
  --button: var(--background);
  --desktop-navbar: #252525;
  --desktop-navicon: #3a3a3a;
  /* Locked Color */
  --lock-desc: #c9c9c9;
  --lock: #fff;
  --font-family: 'Poppins', sans-serif;
  /* Status bar color */
  --status-bar: #8d1d19;
}

* {
  background-color: var(--background);
  color: var(--font);
  font-family: var(--font-family)
}

body {
  margin: 0;
}

a {
  text-decoration: none !important;
}

/* Components */
.radios input[type=radio] {
  display: none;
}

.radio input[type=radio] {
  display: flex;
  align-items: center;
  justify-content: center;
}

.not_avaliable {
  position: fixed;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2em;
  text-align: center;
  top: 0; left: 30px; right: 30px; bottom: 0;
}

.load_screen {
  position: fixed;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  background: var(--background);
  z-index: 10;
  justify-content: center;
  display: flex;
  align-items: center;
}

.full_screen {
  position: fixed;
  overflow-y: scroll;
  z-index: 10;
  top: 0; bottom: 0; left: 0; right: 0;
  transition: top 0.35s ease-in-out;
}

.loader {
  border: 6px solid var(--icon-bc);
  border-top: 6px solid var(--icon);
  border-radius: 50%;
  width: 3em;
  height: 3em;
  animation: spin 0.8s linear infinite;
}

.header {
  display: flex;
  position: fixed;
  align-items: center;
  justify-content: space-between;
  left: 0;
  right: 0;
  padding: 20px 25px;
  font-size: 20px;
  border-bottom: #585b5d solid 1px;
  z-index: 5;
}

.panel {
  display: none;
  animation: fade-out 0.2s;
}

.navbar {
  display: flex;
  position: fixed;
  align-items: center;
  justify-content: space-between;
  background-color: var(--dim);
  left: 0; right: 0; bottom: 0;
  padding: 25px 25px;
  font-size: 20px;
}

.navtitle {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: small;
  margin-top: 8px;
  opacity: 1;
}

.navhidden {
  visibility: hidden;
}

.navicon {
  background: var(--small-card);
  display: flex;
  width: 0;
  height: 30px;
  align-items: center;
  justify-content: center;
  border-radius: 50px;
  animation: closeNav 0.15s;
}

.card {
  margin: 0 15px 10px 15px;
  padding: 15px 15px;
  border-radius: 15px;
  color: var(--lock);
}

.content {
  padding-bottom: 5px;
}

.desc {
  color: var(--desc);
}

.liste {
  justify-content: space-between;
  align-self: center;
  display: flex;
}

.center {
  justify-content: center;
  align-self: center;
  display: flex;
}

.list {
  max-height: 25px;
  overflow-y: hidden; 
  transition: max-height 0.25s ease;
}

.full {
  max-height: 100%;
}

.expander {
  transform: rotate(0deg);
  transition: 0.2s ease-out;
}

.button_list {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  column-gap: 20px;
}

.button {
  padding: 1em 0 1em 0;
  border-radius: 30px;
  transition: transform 0.1s ease-in-out;
  background-color: var(--button);
}

.button:active {
  transform: scale(90%) 
}

.small_card {
  background: var(--small-card);
  border-radius: 15px;
  padding: 5px 15px 0 15px;
  margin: 15px 15px 0 15px;
  padding-bottom: 5px;
}

.small_card_bg {
  background: var(--small-card);
}

.icon_animation {
  transition: transform 0.05s ease-in-out;
}

.icon_animation:active {
  transform: scale(80%) 
}

.element_animation {
  transition: transform 0.15s ease-in-out;
}

.element_animation:active {
  transform: scale(95%) 
}

.card_animation {
  transition: transform 0.05s ease-in-out;
}

.card_animation:active {
  transform: scale(95%) 
}

.errorh_textarea {
  resize: none; 
  border: none;
  outline: none;
  font-size: 14px;
  padding-bottom: 25px;
  font-family: monospace, monospace;
  position: fixed;
  bottom: 7em;
  top: 15.2em;
  left: 1em;
  right: 1em;
}

.errorh_button_container {
  position: fixed;
  top: 5.75em;
  left: 1em;
  right: 1em;
  display: grid;
  grid-template-columns: 1fr;
  column-gap: 1em;
}

.errorh_button {
  border-radius: 25px;
  background: var(--small-card);
  display: flex;
  padding: 0.7em;
  align-items: center;
  justify-content: center;
  margin-bottom: 1em;
  cursor: pointer;
  transition: transform 0.05s ease-in-out;
  user-select: none;
}

#errorh_small_panel_header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.errorh_button:active {
  transform: scale(80%) 
}

/* Card type */
.bright {
  border: 5px solid var(--status-bar);
  background: var(--status-bar);
}

.brightc {
  background: var(--status-bar);
  word-break: break-word;
}

.dim {
  border: 5px solid var(--dim);
  background: var(--dim);
}

.dimc {
  background: var(--dim);
  word-break: break-word;
}

.nav_dimc {
  background: var(--dim);
  word-break: break-word;
}

/* Locked */
.lock {
  color: var(--lock);
}

.lockd {
  color: var(--lock-desc);
}

/* Switch */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
  margin-left: 10px;
}

.switch input { 
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: var(--button);
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 23px;
  width: 23px;
  left: 6px;
  bottom: 6px;
  background-color: var(--desc);
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

/* Responsive CSS */
@media only screen and (max-width: 600px) {
  .button_list {
    display: grid;
    grid-template-columns: 1fr;
    column-gap: 20px;
  }
  .button {
    padding: 1em 0 1em 0;
    border-radius: 30px;
    margin: 0.6em 0 0.6em;
    transition: transform 0.15s ease-in-out;
    background-color: var(--button);
  }
}

/* Show set */
.panel.show {
  margin-bottom: 119px;
  display: block;
  animation: fade-in 0.2s;
}

.panel.showback {
  margin-bottom: 119px;
  display: block;
  animation: fade-in 0.2s;
  z-index: 30;
}

.navicon.show {
  width: 65px;
  animation: openNav 0.15s;
}

@media (min-width:961px)  {
  .navbar {
    background-color: var(--desktop-navbar);
    transform: scale(0.85);
    left: auto; 
    right: auto;
    margin-bottom: 15px;
    border-radius: 60px;
    padding: 10px 10px;
  }
  .navtitle {
    display: none;
  }
  .navicon_support {
    border-radius: 60px;
  }
  #navbar_support_div {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .navicon {
    background: var(--desktop-navicon);
    height: 65px;
    animation: closeNavDesktop 0.15s;
  }
  .navicon.show {
    animation: openNavDesktop 0.15s;
  }
  .nav_dimc {
    background: var(--desktop-navbar);
  }
  .errorh_button_container {
    grid-template-columns: 1fr 1fr;
  }
  .errorh_textarea {
    top: 11em;
  }
  .errorh_button {
    margin-bottom: 0;
  }
}

/* Animation KeyFrames */
@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes closeNav {
  0% {
    width: 65px;
  }
  75% {
    opacity: 0;
  }
  100% {
    width: 0px;
  }
}

@keyframes openNav {
  0% {
    width: 0px;
  }
  75% {
    opacity: 1;
  }
  100% {
    width: 65px;
  }
}

@keyframes closeNavDesktop {
  0% {
    transform: scale(1);
  }
  75% {
    opacity: 0;
  }
  100% {
    transform: scale(0);
  }
}
@keyframes openNavDesktop {
  0% {
    transform: scale(0);
  }
  75% {
    opacity: 1;
  }
  100% {
    transform: scale(1);
  }
}
```

`webroot/fonts/header.css`:

```css
@font-face {
  font-family: "Poppins";
  src: url("./poppins.ttf");
}
```

`webroot/index.html`:

```html
<!DOCTYPE html>
<html id="main_html" lang="en" dir="none">
  <head>
    <meta name="viewport" content="initial-scale=1, width=device-width" />
    <meta name="viewport" content="viewport-fit=cover" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta id="cache-navbar-previous" />
    <meta id="cache-page-small-previous" />
    <meta id="cache-fallback-open" />

    <link rel="stylesheet" href="fonts/header.css">
    <link rel="stylesheet" href="css/index.css">
    <link rel="stylesheet" href="css/error.css">
    <link rel="stylesheet" href="css/icons.css">

    <script>
      localStorage.setItem('/ReZygisk/boot-time', String(Date.now()))
    </script>
    <script src="js/errorCatcher.js" type="module"></script>
    <script src="js/errorScreen.js" type="module"></script>
    <script src="js/browserRedirect.js" type="module"></script>
    <script src="js/smallPage/theme.js" type="module"></script>
    <script src="js/smallPage/language.js" type="module"></script>
    <script src="js/smallPage/errorHistory.js" type="module"></script>
    <script src="js/restoreError.js" type="module"></script>
    <script src="js/navbar.js" type="module"></script>
    <script src="js/monitorActions.js" type="module"></script>
    <script src="js/switcher/fontChanger.js" type="module"></script>
    <script src="js/main.js" type="module"></script>
  </head>
  <body id="main_body">
    <!-- INFO: Error screen -->
    <div id="fatal-error-screen" class="e-container" style="display: none;">
      <div class="e-bg e-wrap">
        <div class="e-bg e-card e-main">
          <img class="e-bg" src="./assets/ec-icon.svg" style="margin-bottom: 10px;"/>
          <div class="e-bg">
            Your WebUI is corrupt. It can't be trusted and may not work properly.
          </div>
  
          <div class="e-bg" style="margin-top: 15px;">
            Please click the copy log button below and visit
            <div class="e-bg e-font" credit-link="t.me/performancorg">t.me/performancorg</div>
            for support.
          </div>
  
          <div id="esc-copy-button" class="e-button" style="margin-top: 25px;">COPY LOG</div>
          <textarea id="esc-log" style="display: none;"></textarea>
        </div>
      </div>
    </div>

    <!-- INFO: Loading screen -->
    <div id="loading_screen" class="load_screen">
      <div id="backport_errorh" class="loader"></div>
    </div>

    <!-- INFO: Home page -->
    <div id="panel_home" class="panel">
      <div class="header">ReZygisk</div>
      <div style="padding: 45px 0px;"></div>

      <!-- INFO: Status card -->
      <div id="info_card" class="bright card list">
        <div class="brightc" style="display: flex; align-items: center;">
          <div id="rezygisk_icon_state" class="brightc" style="margin-bottom: 1px;">
            <img class="brightc" src="assets/mark.svg">
          </div>
          <div id="rezygisk_state" class="brightc content lock" style="font-size: 1.2em; padding-bottom: 4px; padding-left: 5px;">
            Unknown
          </div>
        </div>
      </div>

      <!-- INFO: Info card -->
      <div class="dim card">
        <div class="dimc" style="margin-bottom: 14px;">
          <div class="dimc" style="font-size: 0.8em">ROM / Kernel</div>
        </div>

        <div id="android_version" class="dimc">
          <div class="dimc" style="font-size: 1.1em;">Android</div>
          <div class="dimc desc" id="android_version_div" style="font-size: 0.9em; line-height: 1.05em;">Unknown</div>
        </div>
        <div id="kernel_version" class="dimc" style="margin-top: 4px;">
          <div class="dimc" style="font-size: 1.1em;">Kernel</div>
          <div class="dimc desc" id="kernel_version_div" style="font-size: 0.9em; line-height: 1.05em;">Unknown</div>
        </div>

        <div class="dimc" style="margin-top: 18px; margin-bottom: 14px;">
          <div class="dimc" style="font-size: 0.8em;">Root / ReZygisk</div>
        </div>

        <div class="dimc content">
          <div id="version_info_title" class="dimc" style="font-size: 1.1em;">Version</div>
          <div class="dimc desc" id="version" style="font-size: 0.9em; line-height: 1.05em;">Unknown</div>
        </div>
        <div class="dimc content">
          <div id="root_info_title" class="dimc" style="font-size: 1.1em;">Root Implementation</div>
          <div class="dimc desc" id="root_impl" style="font-size: 0.9em; line-height: 1.05em;">Unknown</div>
        </div>

        <div class="dimc" style="margin-top: 12px; margin-bottom: 14px;">
          <div class="dimc" style="font-size: 0.8em">Zygotes</div>
        </div>

        <div id="zygote32" class="dimc content">
          <div class="dimc" style="font-size: 1.1em;">Zygote32</div>
          <div class="dimc desc" id="zygote32_status" style="font-size: 0.9em; line-height: 1.05em;">Unknown</div>
        </div>
        <div id="zygote64" class="dimc">
          <div class="dimc" style="font-size: 1.1em;">Zygote64</div>
          <div class="dimc desc" id="zygote64_status" style="font-size: 0.9em; line-height: 1.05em;">Unknown</div>
        </div>
      </div>
    </div>

    <!-- INFO: Module page -->
    <div id="panel_modules" class="panel">
      <div id="panel_modules_header" class="header">Modules</div>
      <div style="padding: 45px 0px;"></div>
      <div id="modules_list" style="width: 100%; height: fit-content; display: grid;">
        <div id="modules_list_not_avaliable" class="not_avaliable">
          No modules using Zygisk here.
        </div>
        <!-- N/A -->
      </div>
    </div>

    <!-- INFO: Action page -->
    <div id="panel_actions" class="panel">
      <div id="panel_actions_header" class="header">Actions</div>
      <div style="padding: 45px 0px;"></div>
      <!-- INFO: Settings card body (monitor) -->
      <div id="monitor" class="dimc" style="display: block; margin: 0 15px 0 15px; border-radius: 20px;">
        <div class="dimc liste" style="padding: 30px 22px 30px; border-radius: 20px;">
          <div id="monitor_title" class="dimc" style="font-size: 1.22em;">Monitor</div>
          <div id="monitor_status" class="dimc" style="font-size: 1.1em;">Unknown</div>
        </div>

        <div class="small_card_bg" style="padding: 25px 20px 25px 20px; border-radius: 20px;">
          <div class="small_card_bg button_list">
            <div id="monitor_stop_button" class="center button">Stop</div>
            <div id="monitor_start_button" class="center button">Start</div>
            <div id="monitor_pause_button" class="center button">Pause</div>
          </div>
        </div>
      </div>
    </div>

    <!-- INFO: Settings page -->
    <div id="panel_settings" class="panel">
      <div id="panel_settings_header" class="header">Settings</div>
      <div style="padding: 40px 0px;"></div>
      <!-- INFO: Enable system font option -->
      <div class="small_card dimc" style="margin-top: 15px; justify-content: space-between; display: flex; align-items: center;">
        <div class="dimc" style="display: inline-block; width: 80%;">
          <div id="sys_font_option_title" class="dimc content" style="font-size: 1.1em; padding-left: 5px; padding-top: 6px; padding-bottom: 2px;">
            Enable system font
          </div>
          <div id="sys_font_option_desc" class="dimc desc" style="font-size: 0.9em; padding-left: 5px; padding-bottom: 6px;">
            This option will enable system font in current WebUI. NOTE: May not be compatible with FlipFont
          </div>
        </div>

        <label class="switch dimc">
          <input id="font_switcher" type="checkbox">
          <span class="slider round"></span>
        </label>
      </div>

      <!-- INFO: Enable light theme option -->
      <div id="theme_page_toggle" class="small_card dimc card_animation" style="margin-top: 15px; justify-content: space-between; display: flex; align-items: center;">
        <div class="dimc" style="display: inline-block;">
          <div id="sys_theme_option_title" class="dimc content" style="font-size: 1.1em; padding-left: 5px; padding-top: 6px; padding-bottom: 2px;">
            System theme
          </div>
          <div id="sys_theme_option_desc" class="dimc desc" style="font-size: 0.9em; padding-left: 5px; padding-bottom: 6px;">
            Choose your system theme for current WebUI
          </div>
        </div>
      </div>

      <!-- INFO: Change language -->
      <div id="lang_page_toggle" class="small_card dimc card_animation" style="margin-top: 15px; justify-content: space-between; display: flex; align-items: center;">
        <div class="dimc" style="display: inline-block;">
          <div id="sys_lang_option_title" class="dimc content" style="font-size: 1.1em; padding-left: 5px; padding-top: 6px; padding-bottom: 2px;">
            Change language
          </div>
          <div id="sys_lang_option_desc" class="dimc desc" style="font-size: 0.9em; padding-left: 5px; padding-bottom: 6px;">
            Change to your new language
          </div>
        </div>
      </div>

      <!-- INFO: Error history -->
      <div id="errorh_page_toggle" class="small_card dimc card_animation" style="margin-top: 15px; justify-content: space-between; display: flex; align-items: center;">
        <div class="dimc" style="display: inline-block;">
          <div id="sys_errorh_title" class="dimc content" style="font-size: 1.1em; padding-left: 5px; padding-top: 6px; padding-bottom: 2px;">
            Error History
          </div>
          <div id="sys_errorh_desc" class="dimc desc" style="font-size: 0.9em; padding-left: 5px; padding-bottom: 6px;">
            View all of your error log
          </div>
        </div>
      </div>

      <!-- INFO: Credit card -->
      <div class="dim card" style="margin-top: 15px;">
        <div class="dimc content">
          <div id="mcre_title" class="dimc" style="font-size: 1.1em">Module Developer</div>
          <div  credit-link="github.com/PerformanC" class="dimc desc" style="font-size: 0.9em; margin-top: 3px; cursor: pointer;">
            The PerformanC Organization
          </div>
        </div>

        <div class="dimc content" style="margin-top: 6px;">
          <div id="omcre_title" class="dimc" style="font-size: 1.1em">Original Module Developer</div>
          <div class="dimc" style="font-size: 0.9em; margin-top: 3px; align-items: center; display: flex;">
            <div credit-link="github.com/Dr-TSNG" class="dimc desc" style="cursor: pointer;">
              Nullptr
            </div>
            <div class="dimc desc">,</div>
            <div credit-link="github.com/5ec1cff" class="dimc desc" style="margin-left: 2px; cursor: pointer;">
              5ec1cff
            </div>
          </div>
        </div>

        <div class="dimc" style="margin-top: 6px;">
          <div id="webcre_title" class="dimc" style="font-size: 1.1em">WebUI Developer</div>
          <div credit-link="github.com/RainyXeon" class="dimc desc" style="font-size: 0.9em; margin-top: 3px; cursor: pointer;">
            RainyXeon
          </div>
        </div>
      </div>

      <!-- INFO: License card -->
      <div class="dim card" style="margin-top: 15px;">
        <div class="dimc content">
          <div id="mlic_title" class="dimc" style="font-size: 1.1em">Module License</div>
          <div class="dimc desc" style="font-size: 0.9em; margin-top: 3px;">GPL (Nullptr), BSD 2-Clause</div>
        </div>

        <div class="dimc" style="margin-top: 6px;">
          <div id="mweb_title" class="dimc" style="font-size: 1.1em">WebUI License</div>
          <div class="dimc desc" style="font-size: 0.9em; margin-top: 3px;">BSD 2-Clause</div>
        </div>
      </div>

    </div>

    <!-- INFO: System theme small page -->
    <div id="small_panel_theme" class="panel">
      <div class="header" style="padding-left: 20px; display: flex; align-items: center; justify-content: initial;">
        <div id="sp_theme_close" style="width: 36px; height: 36px; margin-right: 6px;">
          <img src="./assets/back.svg"/>
        </div>
        <div id="small_panel_theme_title">Theme</div>
      </div>
      <div style="padding: 47px 0px;"></div>
      <div style="width: 100%; height: fit-content;">
        <div theme-data="amoled" class="dim card card_animation" style="padding: 25px 15px; cursor: pointer;">
          <div theme-data="amoled" id="small_panel_theme_amoled_option" class="dimc" style="font-size: 1.1em;">Amoled</div>
        </div>
        <div theme-data="dark" class="dim card card_animation" style="padding: 25px 15px; cursor: pointer;">
          <div theme-data="dark" id="small_panel_theme_dark_option" class="dimc" style="font-size: 1.1em;">Dark</div>
        </div>
        <div theme-data="light" class="dim card card_animation" style="padding: 25px 15px; cursor: pointer;">
          <div theme-data="light" id="small_panel_theme_light_option" class="dimc" style="font-size: 1.1em;">Light</div>
        </div>
        <div theme-data="system" class="dim card card_animation" style="padding: 25px 15px; cursor: pointer;">
          <div theme-data="system" id="small_panel_theme_system_option" class="dimc" style="font-size: 1.1em;">System Based</div>
        </div>
      </div>
    </div>

    <!-- INFO: Language small page -->
    <div id="small_panel_language" class="panel">
      <div class="header" style="padding-left: 20px; display: flex; align-items: center; justify-content: initial;">
        <div id="sp_lang_close" style="width: 36px; height: 36px; margin-right: 6px;">
          <img src="./assets/back.svg"/>
        </div>
        <div id="small_panel_lang_title">Choose your new language</div>
      </div>
      <div style="padding: 47px 0px;"></div>
      <div id="lang_modal_list" style="width: 100%; height: fit-content;">
        <!-- N/A -->
      </div>
    </div>

    <!-- INFO: Error small page -->
    <div id="small_panel_errorh" class="panel">
      <div id="errorh_small_panel_header" class="header" style="padding-left: 20px; display: flex; align-items: center; justify-content: initial;">
        <div id="sp_errorh_close" style="width: 36px; height: 36px; margin-right: 6px;">
          <img src="./assets/back.svg"/>
        </div>
        <div id="small_panel_errorh_title">Error History</div>
      </div>
      <div style="display: block; height: 100%;">
        <div class="errorh_button_container">
          <div id="errorh_copy" class="errorh_button">COPY</div>
          <div id="errorh_clear_all" class="errorh_button">CLEAR ALL LOG</div>
        </div>
        <textarea id="errorh_panel" class="errorh_textarea" placeholder="No error log recorded here!" disabled></textarea>
      </div>
    </div>
        

    <!-- INFO: Bottom navbar -->
    <div id="navbar_support_div" style="display: none;">
      <div id="navbar" class="navbar radios">
        <div class="navicon_support nav_dimc">
          <input id="n_home" type="radio" name="navbutton" value="home" checked/>
          <label class="navicon_support radio nav_dimc" for="n_home">
  
            <div class="navicon_support nav_dimc" style="display: grid; place-items: center;">
              <div class="navicon_support nav_dimc" style="display: grid; place-items: center; width: 65px;">
                <div style="grid-area: 1 / 1;" id="ni_home"></div>
                <div style="grid-area: 1 / 1;" id="nibg_home" class="navicon"></div>
              </div>
              <div id="nav_home_title" class="navtitle nav_dimc">Home</div>
            </div>
  
          </label>
        </div>
  
        <div class="nav_dimc">
          <input id="n_modules" type="radio" name="navbutton" value="modules"/>
          <label class="radio nav_dimc" for="n_modules">
  
            <div class="nav_dimc" style="display: grid; place-items: center;">
              <div class="nav_dimc" style="display: grid; place-items: center; width: 65px;">
                <div style="grid-area: 1 / 1;" id="ni_modules"></div>
                <div style="grid-area: 1 / 1;" id="nibg_modules" class="navicon"></div>
              </div>
              <div id="nav_modules_title" class="navtitle nav_dimc">Modules</div>
            </div>
  
          </label>
        </div>
  
        <div class="nav_dimc">
          <input id="n_actions" type="radio" name="navbutton" value="actions"/>
          <label class="radio nav_dimc" for="n_actions">
  
            <div class="nav_dimc" style="display: grid; place-items: center;">
              <div class="nav_dimc" style="display: grid; place-items: center; width: 65px;">
                <div style="grid-area: 1 / 1;" id="ni_actions"></div>
                <div style="grid-area: 1 / 1;" id="nibg_actions" class="navicon"></div>
              </div>
              <div id="nav_actions_title" class="navtitle nav_dimc">Actions</div>
            </div>
  
          </label>
        </div>
  
        <div class="navicon_support nav_dimc">
          <input id="n_settings" type="radio" name="navbutton" value="settings"/>
          <label class="navicon_support radio nav_dimc" for="n_settings">
  
            <div class="navicon_support nav_dimc" style="display: grid; place-items: center;">
              <div class="navicon_support nav_dimc" style="display: grid; place-items: center; width: 65px;">
                <div style="grid-area: 1 / 1;" id="ni_settings"></div>
                <div style="grid-area: 1 / 1;" id="nibg_settings" class="navicon"></div>
              </div>
              <div id="nav_settings_title" class="navtitle nav_dimc">Settings</div>
            </div>
  
          </label>
        </div>
      </div>

    </div>
    
  </body>
</html>

```

`webroot/js/browserRedirect.js`:

```js
import { exec } from './kernelsu.js'

document.addEventListener('click', async (event) => {
  const getLink = event.target.getAttribute('credit-link')
  if (!getLink || typeof getLink !== 'string') return;

  const ptrace64Cmd = await exec(`am start -a android.intent.action.VIEW -d https://${getLink}`).catch(() => {
    return window.open(`https://${getLink}`, "_blank", 'toolbar=0,location=0,menubar=0')
  })
  if (ptrace64Cmd.errno !== 0) return window.open(`https://${getLink}`, "_blank", 'toolbar=0,location=0,menubar=0')
}, false)
```

`webroot/js/errorCatcher.js`:

```js
function setError(place, issue) {
  const fullErrorLog = setErrorData(`${place}: ${issue}`)
  document.getElementById('errorh_panel').innerHTML = fullErrorLog
}

function setErrorData(errorLog) {
  const getPrevious = localStorage.getItem('/ReZygisk/error')
  const finalLog = getPrevious && getPrevious.length !== 0 ? getPrevious + `\n` + errorLog : errorLog

  localStorage.setItem('/ReZygisk/error', finalLog)
  return finalLog
}

if (window.onerror) window.onerror = (err) => { 
  setError('WebUI', err.stack ? err.stack : err.message) 
}
```

`webroot/js/errorScreen.js`:

```js
const button = document.getElementById('esc-copy-button')
const log = document.getElementById('esc-log')

button.addEventListener('click', () => {
  navigator.clipboard.writeText(log.innerHTML)
})
```

`webroot/js/kernelsu.js`:

```js
/* https://github.com/tiann/KernelSU/tree/main/js / https://www.npmjs.com/package/kernelsu */

let callbackCounter = 0;
function getUniqueCallbackName(prefix) {
  return `${prefix}_callback_${Date.now()}_${callbackCounter++}`;
}

export function exec(command, options) {
  if (typeof options === "undefined") {
    options = {};
  }

  return new Promise((resolve, reject) => {
    // Generate a unique callback function name
    const callbackFuncName = getUniqueCallbackName("exec");

    // Define the success callback function
    window[callbackFuncName] = (errno, stdout, stderr) => {
      resolve({ errno, stdout, stderr });
      cleanup(callbackFuncName);
    };

    function cleanup(successName) {
      delete window[successName];
    }

    try {
      ksu.exec(command, JSON.stringify(options), callbackFuncName);
    } catch (error) {
      reject(error);
      cleanup(callbackFuncName);
    }
  });
}

function Stdio() {
    this.listeners = {};
  }
  
  Stdio.prototype.on = function (event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  };
  
  Stdio.prototype.emit = function (event, ...args) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((listener) => listener(...args));
    }
  };
  
  function ChildProcess() {
    this.listeners = {};
    this.stdin = new Stdio();
    this.stdout = new Stdio();
    this.stderr = new Stdio();
  }
  
  ChildProcess.prototype.on = function (event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  };
  
  ChildProcess.prototype.emit = function (event, ...args) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((listener) => listener(...args));
    }
  };
  
  export function spawn(command, args, options) {
    if (typeof args === "undefined") {
      args = [];
    } else if (!(args instanceof Array)) {
        // allow for (command, options) signature
        options = args;
    }
    
    if (typeof options === "undefined") {
      options = {};
    }
  
    const child = new ChildProcess();
    const childCallbackName = getUniqueCallbackName("spawn");
    window[childCallbackName] = child;
  
    function cleanup(name) {
      delete window[name];
    }

    child.on("exit", code => {
        cleanup(childCallbackName);
    });

    try {
      ksu.spawn(
        command,
        JSON.stringify(args),
        JSON.stringify(options),
        childCallbackName
      );
    } catch (error) {
      child.emit("error", error);
      cleanup(childCallbackName);
    }
    return child;
  }

export function fullScreen(isFullScreen) {
  ksu.fullScreen(isFullScreen);
}

export function toast(message) {
  ksu.toast(message);
}
```

`webroot/js/language.js`:

```js
import { exec } from './kernelsu.js'

import { setError } from './main.js'
import { translateActionsPage } from './translate/actions.js'
import { translateHomePage } from './translate/home.js'
import { translateModulesPage } from './translate/modules.js'
import { translateSettingsPage } from './translate/settings.js'

export async function setNewLanguage(locate, initialize) {
  const main_html = document.getElementById('main_html')
  const old_translations = await getTranslations(initialize ? 'en_US' : localStorage.getItem('/ReZygisk/language'))
  const new_translations = await getTranslations(locate)

  if (locate.includes('ar_')) main_html.setAttribute("dir", "rtl");
  else main_html.setAttribute("dir", "none");

  translateHomePage(old_translations, new_translations)
  translateModulesPage(new_translations)
  translateActionsPage(old_translations, new_translations)
  translateSettingsPage(new_translations)

  /* INFO: navbar info */
  document.getElementById('nav_home_title').innerHTML = new_translations.page.home.header
  document.getElementById('nav_modules_title').innerHTML = new_translations.page.modules.header
  document.getElementById('nav_actions_title').innerHTML = new_translations.page.actions.header
  document.getElementById('nav_settings_title').innerHTML = new_translations.page.settings.header

  /* INFO: Language small page */
  document.getElementById('small_panel_lang_title').innerHTML = new_translations.smallPage.language.header

  /* INFO: Theme small page */
  document.getElementById('small_panel_theme_title').innerHTML = new_translations.smallPage.theme.header
  document.getElementById('small_panel_theme_dark_option').innerHTML = new_translations.smallPage.theme.dark
  document.getElementById('small_panel_theme_light_option').innerHTML = new_translations.smallPage.theme.light
  document.getElementById('small_panel_theme_system_option').innerHTML = new_translations.smallPage.theme.system

  /* INFO: Error history small page */
  document.getElementById('errorh_copy').innerHTML = new_translations.smallPage.errorh.buttons.copy
  document.getElementById('errorh_clear_all').innerHTML = new_translations.smallPage.errorh.buttons.clear
  document.getElementById('small_panel_errorh_title').innerHTML = new_translations.smallPage.errorh.header
  document.getElementById('errorh_panel').placeholder = new_translations.smallPage.errorh.placeholder
}

export async function getTranslations(locate) {
  const translateData = await fetch(`./lang/${locate}.json`)
    .catch((err) => setError('WebUI', err.stack ? err.stack : err.message))

  return translateData.json()
}

export async function getAvailableLanguages() {
  const lsCmd = await exec('ls /data/adb/modules/rezygisk/webroot/lang')

  if (lsCmd.errno !== 0) return setError('WebUI', lsCmd.stderr)

  const languages = []
  lsCmd.stdout.split('\n').forEach((lang) => {
    if (lang.length !== 0)
      languages.push(lang.replace('.json', ''))
  })

  return languages
}
```

`webroot/js/main.js`:

```js
import { fullScreen, exec, toast } from './kernelsu.js'

import { setNewLanguage, getTranslations } from './language.js'

export function setError(place, issue) {
  const fullErrorLog = setErrorData(`${place}: ${issue}`)
  document.getElementById('errorh_panel').innerHTML = fullErrorLog

  toast(`${place}: ${issue}`)
}

export function setLangData(mode) {
  localStorage.setItem('/ReZygisk/language', mode)

  return localStorage.getItem('/ReZygisk/language')
}

export function setErrorData(errorLog) {
  const getPrevious = localStorage.getItem('/ReZygisk/error')
  const finalLog = getPrevious && getPrevious.length !== 0 ? getPrevious + `\n` + errorLog : errorLog

  localStorage.setItem('/ReZygisk/error', finalLog)

  return finalLog
}

async function getModuleNames(modules) {
  const fullCommand = modules.map((mod) => {
    let propPath = `/data/adb/modules/${mod.id}/module.prop`

    return `printf % ; if test -f "${propPath}"; then /system/bin/grep '^name=' "${propPath}" | /system/bin/cut -d '=' -f 2- 2>/dev/null || true; else true; fi ; printf "\\n"`
  }).join(' ; ')

  const result = await exec(fullCommand)
  if (result.errno !== 0) {
    setError('getModuleNames', 'Failed to execute command to retrieve module list names')

    return null
  }

  return result.stdout.split('\n\n')
}

(async () => {
  /* INFO: Test ksu module availability */
  exec('echo "Hello world!"')
    .then(() => console.log('[kernelsu.js] Package is ready!'))
    .catch(err => {
      console.log('[kernelsu.js] Package is not ready! Below is error:')
      console.error(err)
    })

  fullScreen(true)

  let sys_lang = localStorage.getItem('/ReZygisk/language')

  if (!sys_lang) sys_lang = setLangData('en_US')
  if (sys_lang !== 'en_US') await setNewLanguage(sys_lang, true)

  const translations = await getTranslations(sys_lang)

  const loading_screen = document.getElementById('loading_screen')
  const bottom_nav = document.getElementById('navbar_support_div')

  const rootCss = document.querySelector(':root')

  const rezygisk_state = document.getElementById('rezygisk_state')
  const rezygisk_icon_state = document.getElementById('rezygisk_icon_state')

  const version = document.getElementById('version')
  const root_impl = document.getElementById('root_impl')

  const monitor_status = document.getElementById('monitor_status')

  const zygote_divs = [
    document.getElementById('zygote64'),
    document.getElementById('zygote32')
  ]

  const zygote_status_divs = [
    document.getElementById('zygote64_status'),
    document.getElementById('zygote32_status')
  ]

  const androidVersionCmd = await exec('/system/bin/getprop ro.build.version.release')
  if (androidVersionCmd.errno !== 0) return setError('WebUI', androidVersionCmd.stderr)

  document.getElementById('android_version_div').innerHTML = androidVersionCmd.stdout
  console.log('[rezygisk.js] Android version: ', androidVersionCmd.stdout)

  const unameCmd = await exec('/system/bin/uname -r')
  if (unameCmd.errno !== 0) return setError('WebUI', unameCmd.stderr)

  document.getElementById('kernel_version_div').innerHTML = unameCmd.stdout.trim()
  console.log('[rezygisk.js] Kernel version: ', unameCmd.stdout.trim())

  const catCmd = await exec('/system/bin/cat /data/adb/rezygisk/module.prop')
  console.log(`[rezygisk.js] ReZygisk module infomation:\n${catCmd.stdout}`)

  if (catCmd.errno !== 0) {
    console.error('[rezygisk.js] Failed to retrieve ReZygisk module information:', catCmd.stderr)

    rezygisk_state.innerHTML = translations.page.home.status.notWorking
    rezygisk_icon_state.innerHTML = '<img class="dimc" src="assets/cross.svg">'

    rootCss.style.setProperty('--status-bar', '#766000')

    /* INFO: Hide zygote divs */
    zygote_divs.forEach((zygote_div) => {
      zygote_div.style.display = 'none'
    })

    loading_screen.style.display = 'none'
    bottom_nav.style.display = 'flex'

    return;
  }

  /* INFO: Just ensure that they won't appear unless there's info */
  zygote_divs.forEach((zygote_div) => {
    zygote_div.style.display = 'none'
  })

  version.innerHTML = catCmd.stdout.split('\n').find((line) => line.startsWith('version=')).substring('version='.length).trim()

  const stateCmd = await exec('/system/bin/cat /data/adb/rezygisk/state.json')
  if (stateCmd.errno !== 0) {
    console.error('[rezygisk.js] Failed to retrieve ReZygisk state information:', stateCmd.stderr)

    rezygisk_state.innerHTML = translations.page.home.status.notWorking
    rezygisk_icon_state.innerHTML = '<img class="dimc" src="assets/cross.svg">'

    rootCss.style.setProperty('--status-bar', '#766000')

    /* INFO: Hide zygote divs */
    zygote_divs.forEach((zygote_div) => {
      zygote_div.style.display = 'none'
    })

    loading_screen.style.display = 'none'
    bottom_nav.style.display = 'flex'

    return;
  }

  const ReZygiskState = JSON.parse(stateCmd.stdout)

  root_impl.innerHTML = ReZygiskState.root

  switch (ReZygiskState.monitor.state) {
    case '0': monitor_status.innerHTML = translations.page.actions.status.tracing; break;
    case '1': monitor_status.innerHTML = translations.page.actions.status.stopping; break;
    case '2': monitor_status.innerHTML = translations.page.actions.status.stopped; break;
    case '3': monitor_status.innerHTML = translations.page.actions.status.exiting; break;
    default: monitor_status.innerHTML = translations.page.actions.status.unknown;
  }

  const expectedWorking = (ReZygiskState.zygote['64'] !== undefined ? 1 : 0) + (ReZygiskState.zygote['32'] !== undefined ? 1 : 0)
  let actuallyWorking = 0

  if (ReZygiskState.zygote['64'] !== undefined) {
    const zygote64 = ReZygiskState.zygote['64']

    zygote_divs[0].style.display = 'block'

    switch (zygote64) {
      case 1: {
        zygote_status_divs[0].innerHTML = translations.page.home.info.zygote.injected

        actuallyWorking++

        break
      }
      case 0: zygote_status_divs[0].innerHTML = translations.page.home.info.zygote.notInjected; break
      default: zygote_status_divs[0].innerHTML = translations.page.home.info.zygote.unknown
    }
  }

  if (ReZygiskState.zygote['32'] !== undefined) {
    const zygote32 = ReZygiskState.zygote['32']

    zygote_divs[1].style.display = 'block'

    switch (zygote32) {
      case 1: {
        zygote_status_divs[1].innerHTML = translations.page.home.info.zygote.injected

        actuallyWorking++

        break
      }
      case 0: zygote_status_divs[1].innerHTML = translations.page.home.info.zygote.notInjected; break
      default: zygote_status_divs[1].innerHTML = translations.page.home.info.zygote.unknown
    }
  }

  if (expectedWorking === 0 || actuallyWorking === 0) {
    rezygisk_state.innerHTML = translations.page.home.status.notWorking
  } else if (expectedWorking === actuallyWorking) {
    rezygisk_state.innerHTML = translations.page.home.status.ok

    rootCss.style.setProperty('--status-bar', '#545454')
    rezygisk_icon_state.innerHTML = '<img class="brightc" src="assets/tick.svg">'
  } else {
    rezygisk_state.innerHTML = translations.page.home.status.partially

    rootCss.style.setProperty('--status-bar', '#766000')
    rezygisk_icon_state.innerHTML = '<img class="brightc" src="assets/warn.svg">'
  }

  const all_modules = []
  Object.keys(ReZygiskState.rezygiskd).forEach((daemon_bit) => {
    const daemon = ReZygiskState.rezygiskd[daemon_bit]

    if (daemon.modules && daemon.modules.length > 0) {
      daemon.modules.forEach((module_id) => {
        const module = all_modules.find((mod) => mod.id === module_id)
        if (module) {
          module.bitsUsed.push(daemon_bit)
        } else {
          all_modules.push({
            id: module_id,
            name: null,
            bitsUsed: [ daemon_bit ]
          })
        }
      })
    }
  })

  if (all_modules.length !== 0) {
    document.getElementById('modules_list_not_avaliable').style.display = 'none'

    const module_names = await getModuleNames(all_modules)
    module_names.forEach((module_name, i) => all_modules[i].name = module_name)

    console.log(`[rezygisk.js] Module list:`)
    console.log(all_modules)

    const modules_list = document.getElementById('modules_list')

    all_modules.forEach((module) => {
      modules_list.innerHTML += 
        `<div class="dim card" style="padding: 25px 15px; cursor: pointer;">
          <div class="dimc" style="font-size: 1.1em;">${module.name}</div>
          <div class="dimc desc" style="font-size: 0.9em; margin-top: 3px; white-space: nowrap; align-items: center; display: flex;">
            <div class="dimc arch_desc">${translations.page.modules.arch}</div>
            <div class="dimc" style="margin-left: 5px;">${module.bitsUsed.join(' / ')}</div>
          </div>
        </div>`
    })
  
  }

  /* INFO: This hides the throbber screen */
  loading_screen.style.display = 'none'
  bottom_nav.style.display = 'flex'

  const start_time = Number(localStorage.getItem('/ReZygisk/boot-time'))
  console.log('[rezygisk.js] boot time: ', Date.now() - start_time, 'ms')
  localStorage.removeItem('/ReZygisk/boot_time')
})().catch((err) => setError('WebUI', err.stack ? err.stack : err.message))

```

`webroot/js/monitorActions.js`:

```js
import { exec, toast } from './kernelsu.js'

import { getTranslations } from './language.js'

const monitor_start = document.getElementById('monitor_start_button')
const monitor_stop = document.getElementById('monitor_stop_button')
const monitor_pause = document.getElementById('monitor_pause_button')

const monitor_status = document.getElementById('monitor_status');

(async () => {
  const sys_lang = localStorage.getItem('/ReZygisk/language')
  const translations = await getTranslations(sys_lang || 'en_US')

  if (monitor_start) {
    monitor_start.addEventListener('click', () => {
      if (![ translations.page.actions.status.tracing, translations.page.actions.status.stopping, translations.page.actions.status.stopped ].includes(monitor_status.innerHTML)) return;

      monitor_status.innerHTML = translations.page.actions.status.tracing

      exec('/data/adb/modules/rezygisk/bin/zygisk-ptrace64 ctl start')
    })

    monitor_stop.addEventListener('click', () => {
      monitor_status.innerHTML = translations.page.actions.status.exiting

      exec('/data/adb/modules/rezygisk/bin/zygisk-ptrace64 ctl exit')
    })

    monitor_pause.addEventListener('click', () => {
      if (![ translations.page.actions.status.tracing, translations.page.actions.status.stopping, translations.page.actions.status.stopped ].includes(monitor_status.innerHTML)) return;

      monitor_status.innerHTML = translations.page.actions.status.stopped

      exec('/data/adb/modules/rezygisk/bin/zygisk-ptrace64 ctl stop')
    })
  }
})()
```

`webroot/js/navbar.js`:

```js
const navbar_data_tag = document.getElementById('cache-navbar-previous')
const small_panel_data_tag = document.getElementById('cache-page-small-previous')

setData('home', navbar_data_tag)

document.getElementById('panel_home').classList.toggle('show')
document.getElementById(`nibg_home`).classList.toggle('show')
document.getElementById(`ni_home`).style.background = 'url(./assets/home/filled.svg)'

document.querySelectorAll('[name=navbutton]').forEach((element) => {
  element.addEventListener('click', (event) => {
    let smallPagePass = false

    const value = event.target.value
    const previous = !navbar_data_tag.getAttribute('content') 
      ? setData('home', navbar_data_tag) 
      : navbar_data_tag.getAttribute('content')

    const small_panel = small_panel_data_tag.getAttribute('content')

    if (small_panel && small_panel.length !== 0) {
      document.getElementById(`small_panel_${small_panel}`).classList.remove('show')
      small_panel_data_tag.removeAttribute('content')
      smallPagePass = true
    }

    if (previous === value && !smallPagePass) return;

    /* INFO: Disable icon on old state */
    const pre_input = document.getElementById(`n_${previous}`)
    const pre_icon = document.getElementById(`ni_${previous}`)
    const pre_background = document.getElementById(`nibg_${previous}`)

    document.getElementById(`panel_${previous}`).classList.remove('show')
    pre_input.removeAttribute('checked')
    pre_background.classList.remove('show')
    pre_icon.style.background = ''

    /* INFO: Enable icon on new state */
    const curr_input = document.getElementById(`n_${value}`)
    const curr_icon = document.getElementById(`ni_${value}`)
    const i_background = document.getElementById(`nibg_${value}`)

    document.getElementById(`panel_${value}`).classList.toggle('show')
    curr_input.setAttribute('checked', '')
    i_background.classList.toggle('show')
    curr_icon.style.background = `url(./assets/${value}/filled.svg)`

    setData(value, navbar_data_tag)
  })
})

function setData(data, tag) {
  tag.setAttribute('content', data)

  return data
}
```

`webroot/js/restoreError.js`:

```js
const errorh_panel = document.getElementById('errorh_panel')
let sys_error = localStorage.getItem('/ReZygisk/error')

if (!sys_error) {
  localStorage.setItem('/ReZygisk/error', '')

  sys_error = localStorage.getItem('/ReZygisk/error')
}

if (sys_error.length !== 0) errorh_panel.innerHTML = sys_error
```

`webroot/js/smallPage/errorHistory.js`:

```js
import { smallPageDisabler } from '../smallPageDesabler.js'
const panel = document.getElementById('errorh_panel')

/* INFO: Event setup */
const navbar_data_tag = document.getElementById('cache-navbar-previous')
const small_panel_data_tag = document.getElementById('cache-page-small-previous')
const fallback_open = document.getElementById('cache-fallback-open')

document.getElementById('errorh_page_toggle').addEventListener('click', () => {
  const previous = !navbar_data_tag.getAttribute('content') ? setData('home', small_panel_data_tag) : navbar_data_tag.getAttribute('content')
  document.getElementById(`panel_${previous}`).classList.remove('show')
  document.getElementById('small_panel_errorh').classList.toggle('show')
  small_panel_data_tag.setAttribute('content', 'errorh')
})

document.getElementById('backport_errorh').addEventListener('click', () => {
  const previous = !navbar_data_tag.getAttribute('content') ? setData('home', small_panel_data_tag) : navbar_data_tag.getAttribute('content')
  document.getElementById(`panel_${previous}`).classList.remove('show')
  document.getElementById('loading_screen').style.display = 'none'
  document.getElementById('small_panel_errorh').classList.toggle('show')
  document.getElementById('errorh_panel').style.bottom = '1em'
  fallback_open.setAttribute('content', 'opened')
  small_panel_data_tag.setAttribute('content', 'errorh')
})

document.getElementById('sp_errorh_close').addEventListener('click', () => {
  const is_fallback = fallback_open.getAttribute('content')
  if (is_fallback) {
    document.getElementById('errorh_panel').style.bottom = '1em'
    document.getElementById('loading_screen').style.display = 'flex'
  }
  smallPageDisabler('errorh', is_fallback ? 'home' : 'settings', is_fallback ? 'home' : null)
})
document.getElementById('errorh_copy').addEventListener('click', () => {
  navigator.clipboard.writeText(panel.innerHTML)
})

document.getElementById('errorh_clear_all').addEventListener('click', () => {
  panel.innerHTML = ''
  localStorage.setItem('/ReZygisk/error', '')
})

function setData(mode, tag) {
  tag.setAttribute('content', mode)

  return mode
}
```

`webroot/js/smallPage/language.js`:

```js
import { 
  getTranslations, 
  setNewLanguage,
  getAvailableLanguages
} from '../language.js'
import { smallPageDisabler } from '../smallPageDesabler.js'

/* INFO: Initial setup */
let index = 0

async function setAvailableLanguage() {
  const availableLanguages = await getAvailableLanguages()

  for (index; index < availableLanguages.length; index++) {
    const langCode = availableLanguages[index]
    const langData = await getTranslations(langCode)

    document.getElementById('lang_modal_list').innerHTML += `
    <div lang-data="${langCode}" class="dim card card_animation" style="padding: 25px 15px; cursor: pointer;">
      <div lang-data="${langCode}" class="dimc" style="font-size: 1.1em;">${langData.langName}</div>
    </div>
    `
  }
}
setAvailableLanguage()

/* INFO: Event setup */
const navbar_data_tag = document.getElementById('cache-navbar-previous')
const small_panel_data_tag = document.getElementById('cache-page-small-previous')

document.getElementById('lang_page_toggle').addEventListener('click', () => {
  const previous = !navbar_data_tag.getAttribute('content') ? setData('home', small_panel_data_tag) : navbar_data_tag.getAttribute('content')
  document.getElementById(`panel_${previous}`).classList.remove('show')
  document.getElementById('small_panel_language').classList.toggle('show')
  small_panel_data_tag.setAttribute('content', 'language')
})

document.getElementById('sp_lang_close').addEventListener('click', () => smallPageDisabler('language', 'settings'))

document.addEventListener('click', async (event) => {
  const getLangLocate = event.target.getAttribute('lang-data')
  if (!getLangLocate || typeof getLangLocate !== 'string') return

  smallPageDisabler('language', 'settings')
  await setNewLanguage(getLangLocate)

  localStorage.setItem('/ReZygisk/language', getLangLocate)
}, false)

function setData(data, tag) {
  tag.setAttribute('content', data)

  return data
}
```

`webroot/js/smallPage/theme.js`:

```js
import { smallPageDisabler } from '../smallPageDesabler.js'
import { setAmoled } from '../themes/amoled.js'
import { setDark } from '../themes/dark.js'
import { setLight } from '../themes/light.js'

// INFO: requirement variables
let sys_theme
const page_toggle = document.getElementById('theme_page_toggle')
const themeList = {
  amoled: () => setAmoled(true),
  dark: () => setDark(true),
  light: () => setLight(true),
  system: (unavaliable) => {
    const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
    if (isDark && unavaliable) setDark() 
    else setLight()
  },
}
const setData = (mode) => {
  localStorage.setItem('/ReZygisk/theme', mode)
  return mode
}

// INFO: Initial open logic
sys_theme = localStorage.getItem('/ReZygisk/theme')
if (!sys_theme) sys_theme = setData('dark')
themeList[sys_theme](true)

// INFO: Event logic
const navbar_data_tag = document.getElementById('cache-navbar-previous')
const small_panel_data_tag = document.getElementById('cache-page-small-previous')

document.getElementById('sp_theme_close').addEventListener('click', () => smallPageDisabler('theme', 'settings'))

document.addEventListener('click', async (event) => {
  const themeListKey = Object.keys(themeList)
  const getThemeMode = event.target.getAttribute('theme-data')

  if (!getThemeMode || typeof getThemeMode !== 'string' || !themeListKey.includes(getThemeMode)) return

  themeList[getThemeMode](true)

  smallPageDisabler('theme', 'settings')

  sys_theme = setData(getThemeMode)
}, false)

page_toggle.addEventListener('click', () => {
  const previous = !navbar_data_tag.getAttribute('content') ? setTagData('home', small_panel_data_tag) : navbar_data_tag.getAttribute('content')
  document.getElementById(`panel_${previous}`).classList.remove('show')
  document.getElementById('small_panel_theme').classList.toggle('show')
    small_panel_data_tag.setAttribute('content', 'theme')
})

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
  if (sys_theme !== "system") return
  const newColorScheme = event.matches ? "dark" : "light";

  switch (newColorScheme) {
    case 'dark':
      setDark()
      break
    case 'light':
      setLight()
      break
  }
});

function setTagData(data, tag) {
  tag.setAttribute('content', data)

  return data
}

```

`webroot/js/smallPageDesabler.js`:

```js
export function smallPageDisabler(page_name, new_page, custom_page) {
  const navbar_data_tag = document.getElementById('cache-navbar-previous')
  const small_panel_data_tag = document.getElementById('cache-page-small-previous')

  document.getElementById(`small_panel_${page_name}`).classList.remove('show')
  small_panel_data_tag.removeAttribute('content')

  const previous = navbar_data_tag.getAttribute('content')

  /* INFO: Disable icon on old state */
  const pre_input = document.getElementById(`n_${previous}`)
  const pre_background = document.getElementById(`nibg_${previous}`)

  pre_input.removeAttribute('checked')
  pre_background.classList.remove('show')

  /* INFO: Enable icon on new state */
  const curr_input = document.getElementById(`n_${new_page}`)
  const i_background = document.getElementById(`nibg_${new_page}`)

  document.getElementById(`panel_${new_page}`).classList.toggle('show')
  curr_input.setAttribute('checked', '')
  i_background.classList.toggle('show')

  navbar_data_tag.setAttribute('content', custom_page ? custom_page : 'settings')
}
```

`webroot/js/switcher/fontChanger.js`:

```js
const switcher = document.getElementById('font_switcher')
const rootCss = document.querySelector(':root')

let sys_font = localStorage.getItem('/ReZygisk/font')
if (!sys_font) sys_font = setData('false')
if (sys_font === 'true') {
  switcher.setAttribute('checked', '')

  setSystemFont()
}

switcher.addEventListener('click', () => {
  sys_font = setData(String(switcher.checked))

  switcher.checked ? setSystemFont() : document.getElementById('font-tag').remove()
})

function setSystemFont() {
  const headTag = document.getElementsByTagName('head')[0]
  const styleTag = document.createElement('style')

  styleTag.id = 'font-tag'
  headTag.appendChild(styleTag)
  styleTag.innerHTML = `
    :root {
      --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif
    }`
}

function setData(mode) {
  localStorage.setItem('/ReZygisk/font', mode)

  return mode
}
```

`webroot/js/themes/amoled.js`:

```js
import { setDarkNav } from './darkNavbar.js'

const rootCss = document.querySelector(':root')

/* INFO: Changes the icons to match the theme */
const close_icons = document.getElementsByClassName('close_icon')
const expand_icons = document.getElementsByClassName('expander')
const sp_lang_close = document.getElementById('sp_lang_close')
const sp_theme_close = document.getElementById('sp_theme_close')

export function setAmoled(chooseSet) {
  rootCss.style.setProperty('--background', '#000000')
  rootCss.style.setProperty('--font', '#d9d9d9')
  rootCss.style.setProperty('--desc', '#a9a9a9')
  rootCss.style.setProperty('--dim', '#0e0e0eff')
  rootCss.style.setProperty('--icon', '#292929ff')
  rootCss.style.setProperty('--icon-bc', '#202020ff')
  rootCss.style.setProperty('--desktop-navbar', '#161616ff')
  rootCss.style.setProperty('--desktop-navicon', '#242424ff')
  rootCss.style.setProperty('--button', 'var(--background)')

  if (chooseSet) setData('amoled')

  for (const close_icon of close_icons) {
    close_icon.innerHTML = '<img src="assets/close.svg">'
  }

  for (const expand_icon of expand_icons) {
    expand_icon.innerHTML = '<img class="dimc" src="assets/expand.svg">'
  }

  sp_lang_close.innerHTML = '<img src="./assets/back.svg"/>'
  sp_theme_close.innerHTML = '<img src="./assets/back.svg"/>'
  setDarkNav()
}

function setData(mode) {
  localStorage.setItem('/ReZygisk/theme', mode)

  return mode
}
```

`webroot/js/themes/dark.js`:

```js
import { setDarkNav } from './darkNavbar.js'

const rootCss = document.querySelector(':root')

/* INFO: Changes the icons to match the theme */
const close_icons = document.getElementsByClassName('close_icon')
const expand_icons = document.getElementsByClassName('expander')
const sp_lang_close = document.getElementById('sp_lang_close')
const sp_theme_close = document.getElementById('sp_theme_close')
const sp_errorh_close = document.getElementById('sp_errorh_close')

export function setDark(chooseSet) {
  rootCss.style.setProperty('--background', '#141414')
  rootCss.style.setProperty('--font', '#ffffff')
  rootCss.style.setProperty('--desc', '#c9c9c9')
  rootCss.style.setProperty('--dim', '#1c1c1c')
  rootCss.style.setProperty('--icon', '#494949')
  rootCss.style.setProperty('--icon-bc', '#292929')
  rootCss.style.setProperty('--desktop-navbar', '#252525')
  rootCss.style.setProperty('--desktop-navicon', '#3a3a3a')
  rootCss.style.setProperty('--button', 'var(--background)')

  if (chooseSet) setData('dark')

  for (const close_icon of close_icons) {
    close_icon.innerHTML = '<img src="assets/close.svg">'
  }

  for (const expand_icon of expand_icons) {
    expand_icon.innerHTML = '<img class="dimc" src="assets/expand.svg">'
  }

  sp_lang_close.innerHTML = '<img src="./assets/back.svg"/>'
  sp_theme_close.innerHTML = '<img src="./assets/back.svg"/>'
  sp_errorh_close.innerHTML = '<img src="./assets/back.svg"/>'
  setDarkNav()
}

function setData(mode) {
  localStorage.setItem('/ReZygisk/theme', mode)

  return mode
}
```

`webroot/js/themes/darkNavbar.js`:

```js
export function setDarkNav() {
  document.getElementById('ni_home').classList.remove('light_icon_mode')
  document.getElementById('ni_modules').classList.remove('light_icon_mode')
  document.getElementById('ni_actions').classList.remove('light_icon_mode')
  document.getElementById('ni_settings').classList.remove('light_icon_mode')
}
```

`webroot/js/themes/light.js`:

```js
import { 
  light_close_icon,
  light_expand_icon,
  light_page_exit_icon,
} from './lightIcon.js'
import { setLightNav } from './lightNavbar.js'

const rootCss = document.querySelector(':root')

/* INFO: Changes the icons to match the theme */
const close_icons = document.getElementsByClassName('close_icon')
const expand_icons = document.getElementsByClassName('expander')
const sp_lang_close = document.getElementById('sp_lang_close')
const sp_theme_close = document.getElementById('sp_theme_close')
const sp_errorh_close = document.getElementById('sp_errorh_close')

export function setLight(chooseSet) {
  rootCss.style.setProperty('--background', '#f2f2f2')
  rootCss.style.setProperty('--font', '#222222ff')
  rootCss.style.setProperty('--desc', '#535353ff')
  rootCss.style.setProperty('--dim', '#e0e0e0')
  rootCss.style.setProperty('--icon', '#acacac')
  rootCss.style.setProperty('--desktop-navbar', '#fefefe')
  rootCss.style.setProperty('--desktop-navicon', '#eeeeee')
  rootCss.style.setProperty('--icon-bc', '#c9c9c9')
  rootCss.style.setProperty('--button', '#b3b3b3')

  if (chooseSet) setData('light')

  for (const close_icon of close_icons) {
    close_icon.innerHTML = light_close_icon
  }

  for (const expand_icon of expand_icons) {
    expand_icon.innerHTML = light_expand_icon
  }

  sp_lang_close.innerHTML = light_page_exit_icon
  sp_theme_close.innerHTML = light_page_exit_icon
  sp_errorh_close.innerHTML = light_page_exit_icon
  setLightNav()
}

function setData(mode) {
  localStorage.setItem('/ReZygisk/theme', mode)

  return mode
}

```

`webroot/js/themes/lightIcon.js`:

```js
export const light_expand_icon = `
  <svg class="dimc" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#2c2c2c">
    <path d="m480-340 180-180-57-56-123 123-123-123-57 56 180 180Zm0 260q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
  </svg>
`
export const light_close_icon = `
  <svg xmlns="http://www.w3.org/2000/svg" height="40px" viewBox="0 -960 960 960" width="40px" fill="#2c2c2c">
    <path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/>
  </svg>
`
export const light_logs_icon = `
  <svg class="dimc" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#2c2c2c">
    <path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240Zm40 360q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
  </svg>
`
export const light_page_exit_icon = `
  <svg xmlns="http://www.w3.org/2000/svg" height="36px" viewBox="0 -960 960 960" width="36px" fill="#2c2c2c">
    <path d="m287-446.67 240 240L480-160 160-480l320-320 47 46.67-240 240h513v66.66H287Z"/>
  </svg>
`

```

`webroot/js/themes/lightNavbar.js`:

```js
export function setLightNav() {
  document.getElementById('ni_home').classList.add('light_icon_mode')
  document.getElementById('ni_modules').classList.add('light_icon_mode')
  document.getElementById('ni_actions').classList.add('light_icon_mode')
  document.getElementById('ni_settings').classList.add('light_icon_mode')
}

```

`webroot/js/translate/actions.js`:

```js
export function translateActionsPage(old_translations, new_translations) {
  /* INFO: actions card */
  document.getElementById('panel_actions_header').innerHTML = new_translations.page.actions.header

  /* INFO: monitor small card */
  document.getElementById('monitor_title').innerHTML = new_translations.page.actions.monitor
  if (document.getElementById('monitor_stop_button')) { /* INFO: Not all devices have 32-bit support */
    document.getElementById('monitor_stop_button').innerHTML = new_translations.page.actions.monitorButton.stop
    document.getElementById('monitor_start_button').innerHTML = new_translations.page.actions.monitorButton.start
    document.getElementById('monitor_pause_button').innerHTML = new_translations.page.actions.monitorButton.pause
  }

  /* INFO: monitor status card */
  const monitor_status = document.getElementById('monitor_status')
  switch (monitor_status.innerHTML.replace(/(\r\n|\n|\r)/gm, '').trim()) {
    case old_translations.page.actions.status.tracing: {
      monitor_status.innerHTML = new_translations.page.actions.status.tracing

      break
    }
    case old_translations.page.actions.status.stopping: {
      monitor_status.innerHTML = new_translations.page.actions.status.stopping

      break
    }
    case old_translations.page.actions.status.stopped: {
      monitor_status.innerHTML = new_translations.page.actions.status.stopped

      break
    }
    case old_translations.page.actions.status.exiting: {
      monitor_status.innerHTML = new_translations.page.actions.status.exiting

      break
    }
    default: monitor_status.innerHTML = new_translations.page.actions.status.unknown
  }
}
```

`webroot/js/translate/home.js`:

```js
export function translateHomePage(old_translations, new_translations) {
  /* INFO: Translate variables */
  const rezygisk_state = document.getElementById('rezygisk_state')
  const zygote32_status_div = document.getElementById('zygote32_status')
  const zygote64_status_div = document.getElementById('zygote64_status')

  switch (rezygisk_state.innerHTML.replace(/(\r\n|\n|\r)/gm, '').trim()) {
    case old_translations.page.home.status.ok: {
      rezygisk_state.innerHTML = new_translations.page.home.status.ok

      break
    }
    case old_translations.page.home.status.partially: {
      rezygisk_state.innerHTML = new_translations.page.home.status.partially

      break
    }
    case old_translations.page.home.status.notWorking: {
      rezygisk_state.innerHTML = new_translations.page.home.status.notWorking

      break
    }
    case old_translations.page.home.status.unknown: {
      rezygisk_state.innerHTML = new_translations.global.unknown

      break
    }
  }

  if (zygote32_status_div) {
    switch (zygote32_status_div.innerHTML.replace(/(\r\n|\n|\r)/gm, '').trim()) {
      case old_translations.page.home.info.zygote.injected: {
        zygote32_status_div.innerHTML = new_translations.page.home.info.zygote.injected

        break
      }
      case old_translations.page.home.info.zygote.notInjected: {
        zygote32_status_div.innerHTML = new_translations.page.home.info.zygote.notInjected

        break
      }
      case old_translations.page.home.info.zygote.unknown: {
        zygote32_status_div.innerHTML = new_translations.global.unknown

        break
      }
    }
  }

  if (zygote64_status_div) {
    switch (zygote64_status_div.innerHTML.replace(/(\r\n|\n|\r)/gm, '').trim()) {
      case old_translations.page.home.info.zygote.injected: {
        zygote64_status_div.innerHTML = new_translations.page.home.info.zygote.injected

        break
      }
      case old_translations.page.home.info.zygote.notInjected: {
        zygote64_status_div.innerHTML = new_translations.page.home.info.zygote.notInjected

        break
      }
      case old_translations.page.home.info.zygote.unknown: {
        zygote64_status_div.innerHTML = new_translations.global.unknown

        break
      }
    }
  }

  const android_version_div = document.getElementById('android_version_div')
  if (android_version_div.innerHTML === old_translations.global.unknown) 
    android_version_div.innerHTML = new_translations.global.unknown

  const kernel_version_div = document.getElementById('kernel_version_div')
  if (kernel_version_div.innerHTML === old_translations.global.unknown) 
    kernel_version_div.innerHTML = new_translations.global.unknown

  /* INFO: info card */
  document.getElementById('version_info_title').innerHTML = new_translations.page.home.info.version
  document.getElementById('root_info_title').innerHTML = new_translations.page.home.info.root

  // const version_code = document.getElementById('version_code')
  // const root_impl = document.getElementById('root_impl')

  // if (version_code.innerHTML.replace(/(\r\n|\n|\r)/gm, '').trim() === old_translations.global.unknown)
  //   version_code.innerHTML = new_translations.global.unknown

  // if (root_impl.innerHTML.replace(/(\r\n|\n|\r)/gm, '').trim() === old_translations.global.unknown)
  //   root_impl.innerHTML = new_translations.global.unknown
}
```

`webroot/js/translate/modules.js`:

```js
export function translateModulesPage(new_translations) {
  document.getElementById('panel_modules_header').innerHTML = new_translations.page.modules.header
  document.getElementById('modules_list_not_avaliable').innerHTML = new_translations.page.modules.notAvaliable

  /* INFO: arch type */
  const module_element_arch = document.getElementsByClassName('arch_desc')
  for (const module of module_element_arch) {
    module.innerHTML = new_translations.page.modules.arch
  }
}
```

`webroot/js/translate/settings.js`:

```js
export function translateSettingsPage(new_translations) {
  document.getElementById('panel_settings_header').innerHTML = new_translations.page.settings.header

  /* INFO: Change font option */
  document.getElementById('sys_font_option_title').innerHTML = new_translations.page.settings.font.header
  document.getElementById('sys_font_option_desc').innerHTML = new_translations.page.settings.font.description
  
  /* INFO: Change font option */
  document.getElementById('sys_theme_option_title').innerHTML = new_translations.page.settings.theme.header
  document.getElementById('sys_theme_option_desc').innerHTML = new_translations.page.settings.theme.description

  /* INFO: Change font option */
  document.getElementById('sys_lang_option_title').innerHTML = new_translations.page.settings.language.header
  document.getElementById('sys_lang_option_desc').innerHTML = new_translations.page.settings.language.description

  /* INFO: Change font option */
  document.getElementById('sys_errorh_title').innerHTML = new_translations.page.settings.logs.header
  document.getElementById('sys_errorh_desc').innerHTML = new_translations.page.settings.logs.description

  /* INFO: Credit card */
  document.getElementById('mcre_title').innerHTML = new_translations.page.settings.credits.module
  document.getElementById('omcre_title').innerHTML = new_translations.page.settings.credits.original
  document.getElementById('webcre_title').innerHTML = new_translations.page.settings.credits.web
  /* INFO: License card */
  document.getElementById('mlic_title').innerHTML = new_translations.page.settings.license.module
  document.getElementById('mweb_title').innerHTML = new_translations.page.settings.license.web
}
```

`webroot/lang/ar_EG.json`:

```json
{
  "langName": "العربية",
  "global": {
    "unknown": "غير معروف"
  },
  "smallPage": {
    "language": {
      "header": "اختر اللغة"
    },
    "theme": {
      "header": "اختر السمة",
      "dark": "مظلم",
      "light": "مضئ",
      "system": "تلقائي"
    },
    "errorh": {
      "buttons": {
        "copy": "نسخ",
        "clear": "حذف كل السجلات"
      },
      "header": "سجلات الأخطاء",
      "placeholder": "لا توجد أخطاء!"
    }
  },
  "page": {
    "home": {
      "header": "الصفحة الرئيسية",
      "status": {
        "notWorking": "لا يعمل",
        "ok": "يعمل",
        "partially": "يعمل بشكل جزئي"
      },
      "info": {
        "version": "الإصدار",
        "root": "مدير الروت",
        "zygote": {
          "injected": "محقن",
          "notInjected": "غير محقن",
          "unknown": "غير معروف"
        }
      }
    },
    "modules": {
      "header": "الإضافات",
      "notAvaliable": "لا توجد إضافات تستخدم zygisk.",
      "arch": "النواة: "
    },
    "actions": {
      "header": "زر الإجراء",
      "monitorButton": {
        "start": "تشغيل",
        "stop": "تعطيل",
        "pause": "إيقاف مؤقت"
      },
      "monitor": "المراقبة",
      "status": {
        "tracing": "يتم التتبع",
        "stopping": "يتم الإيقاف",
        "stopped": "متوقف",
        "exiting": "يتم الخروج",
        "unknown": "غير معروف"
      }
    },
    "settings": {
      "header": "الإعدادات",
      "font": {
        "header": "تشغيل خط النظام",
        "description": "هذا الخيار يقوم بعرض النص بخط النظام بدلا من خط WebUI. قد لا يتوافق مع FlipFont"
      },
      "theme": {
        "header": "الثيمات",
        "description": "اختر الثيم المناسب"
      },
      "language": {
        "header": "تغيير اللغة",
        "description": "غير إلى لغة أخرى"
      },
      "logs": {
        "header": "سجل الأخطاء",
        "description": "إعرض كل سجلات الأخطاء"
      },
      "credits": {
        "module": "مطور الإضافة",
        "original": "المطورون الأصليون",
        "web": "مطور واجهة الويب"
      },
      "license": {
        "module": "ترخيص الإضافة",
        "web": "ترخيص واجهة الويب"
      }
    }
  }
}

```

`webroot/lang/de_DE.json`:

```json
{
  "langName": "Deutsch",
  "global": {
    "unknown": "Unbekannt"
  },
  "smallPage": {
    "language": {
      "header": "Neue Sprache wählen"
    },
    "theme": {
      "header": "Neues Theme wählen",
      "dark": "Dunkel",
      "light": "Hell",
      "system": "System Basiert"
    },
    "errorh": {
      "buttons": {
        "copy": "Kopieren",
        "clear": "ALLE LOGS LÖSCHEN"
      },
      "header": "Fehler Verlauf",
      "placeholder": "Es wurde kein Fehlerprotokoll aufgezeichnet!"
    }
  },
  "page": {
    "home": {
      "header": "Startseite",
      "status": {
        "notWorking": "Funktioniert nicht",
        "ok": "Funktioniert",
        "partially": "Funktioniert zum Teil"
      },
      "info": {
        "version": "Version",
        "root": "Root Implementierung",
        "zygote": {
          "injected": "Injiziert",
          "notInjected": "Nicht Injiziert",
          "unknown": "Unbekannt"
        }
      }
    },
    "modules": {
      "header": "Module",
      "notAvaliable": "Kein Modul nutzt Zygisk.",
      "arch": "Architektur: "
    },
    "settings": {
      "header": "Einstellungen",
      "font": {
        "header": "Systemschriftart aktivieren",
        "description": "Diese Option aktiviert die Systemschriftart in der aktuellen WebUI. HINWEIS: Möglicherweise nicht kompatibel mit FlipFont"
      },
      "theme": {
        "header": "System Theme",
        "description": "Wählen Sie Ihr System-Theme für die aktuelle WebUI"
      },
      "language": {
        "header": "Sprache auswählen",
        "description": "Wechsel zu deiner neuen Sprache"
      },
      "logs": {
        "header": "Fehler Verlauf",
        "description": "Zeige den Fehler Verlauf"
      },
      "credits": {
        "module": "Modul Entwickler",
        "original": "Original Modul Entwickler",
        "web": "WebUI Entwickler"
      },
      "license": {
        "module": "Modul Lizenz",
        "web": "WebUI Lizenz"
      }
    },
    "actions": {
      "header": "Aktionen",
      "monitorButton": {
        "pause": "Pause",
        "stop": "Stopp",
        "start": "Start"
      },
      "monitor": "Überwachen",
      "status": {
        "tracing": "Nachverfolgung",
        "stopping": "Beenden",
        "stopped": "Beendet",
        "exiting": "Wird Beendet",
        "unknown": "Unbekannt"
      }
    }
  }
}

```

`webroot/lang/en_US.json`:

```json
{
  "langName": "English (United States)",
  "global": {
    "unknown": "Unknown"
  },
  "smallPage": {
    "language": {
      "header": "Choose your new language"
    },
    "theme": {
      "header": "Choose your new theme",
      "dark": "Dark",
      "light": "Light",
      "system": "System Based"
    },
    "errorh": {
      "buttons": {
        "copy": "COPY",
        "clear": "CLEAR ALL LOGS"
      },
      "header": "Error History",
      "placeholder": "No error log recorded here!"
    }
  },
  "page": {
    "home": {
      "header": "Home",
      "status": {
        "notWorking": "Not Working",
        "ok": "Working",
        "partially": "Partially Working"
      },
      "info": {
        "version": "Version",
        "root": "Root Implementation",
        "zygote": {
          "injected": "Injected",
          "notInjected": "Not Injected",
          "unknown": "Unknown"
        }
      }
    },
    "modules": {
      "header": "Modules",
      "notAvaliable": "No modules using Zygisk here.",
      "arch": "Architecture: "
    },
    "actions": {
      "header": "Action",
      "monitorButton": {
        "start": "Start",
        "stop": "Stop",
        "pause": "Pause"
      },
      "monitor": "Monitor",
      "status": {
        "tracing": "Tracing",
        "stopping": "Stopping",
        "stopped": "Stopped",
        "exiting": "Exiting",
        "unknown": "Unknown"
      }
    },
    "settings": {
      "header": "Settings",
      "font": {
        "header": "Enable system font",
        "description": "This option will enable system font in current WebUI. NOTE: May not be compatible with FlipFont"
      },
      "theme": {
        "header": "System theme",
        "description": "Choose your system theme for current WebUI"
      },
      "language": {
        "header": "Change language",
        "description": "Change to your new language"
      },
      "logs": {
        "header": "Error History",
        "description": "View all of your error log"
      },
      "credits": {
        "module": "Module Developer",
        "original": "Original Module Developer",
        "web": "WebUI Developer"
      },
      "license": {
        "module": "Module License",
        "web": "WebUI License"
      }
    }
  }
}

```

`webroot/lang/es_AR.json`:

```json
{
  "langName": "Español",
  "global": {
    "unknown": "Desconocido"
  },
  "smallPage": {
    "language": {
      "header": "Selecciona tu nuevo idioma"
    },
    "theme": {
      "header": "Elige tu nuevo tema",
      "dark": "Oscuro",
      "light": "Claro",
      "system": "Basado en el sistema"
    },
    "errorh": {
      "buttons": {
        "copy": "COPIAR",
        "clear": "BORRAR TODOS LOS REGISTROS"
      },
      "header": "Historial de errores",
      "placeholder": "¡No se registró ningún error aquí!"
    }
  },
  "page": {
    "home": {
      "header": "Inicio",
      "status": {
        "notWorking": "No funciona",
        "ok": "Funcionando",
        "partially": "Funciona parcialmente"
      },
      "info": {
        "version": "Versión",
        "root": "Implementación de root",
        "zygote": {
          "injected": "Inyectado",
          "notInjected": "No inyectado",
          "unknown": "Desconocido"
        }
      }
    },
    "modules": {
      "header": "Módulos",
      "notAvaliable": "No hay módulos que usen Zygisk aquí.",
      "arch": "Arquitectura: "
    },
    "settings": {
      "header": "Ajustes",
      "font": {
        "header": "Activar fuente del sistema",
        "description": "Esta opción habilitará la fuente del sistema en el WebUI actual. NOTA: Puede no ser compatible con FlipFont"
      },
      "theme": {
        "header": "Tema del sistema",
        "description": "Elija el tema del sistema para el WebUI actual"
      },
      "language": {
        "header": "Cambiar idioma",
        "description": "Selecciona tu nuevo idioma"
      },
      "logs": {
        "header": "Historial de errores",
        "description": "Ver todos tus registros de errores"
      },
      "credits": {
        "module": "Desarrollador del módulo",
        "original": "Desarrollador original del módulo",
        "web": "Desarrollador de la WebUI"
      },
      "license": {
        "module": "Licencia del módulo",
        "web": "Licencia de la WebUI"
      }
    },
    "actions": {
      "header": "Acciones",
      "monitorButton": {
        "pause": "Pausar",
        "stop": "Detener",
        "start": "Iniciar"
      },
      "monitor": "Monitor",
      "status": {
        "tracing": "Trazando",
        "stopping": "Deteniendo",
        "stopped": "Detenido",
        "exiting": "Saliendo",
        "unknown": "Desconocido"
      }
    }
  }
}

```

`webroot/lang/es_ES.json`:

```json
{
  "langName": "Español",
  "global": {
    "unknown": "Desconocido"
  },
  "smallPage": {
    "language": {
      "header": "Selecciona tu nuevo idioma"
    },
    "theme": {
      "header": "Elige tu nuevo tema",
      "dark": "Oscuro",
      "light": "Claro",
      "system": "Basado en el sistema"
    },
    "errorh": {
      "buttons": {
        "copy": "COPIAR",
        "clear": "BORRAR TODOS LOS REGISTROS"
      },
      "header": "Historial de errores",
      "placeholder": "¡No se registró ningún error aquí!"
    }
  },
  "page": {
    "home": {
      "header": "Inicio",
      "status": {
        "notWorking": "No funciona",
        "ok": "Funcionando",
        "partially": "Funciona parcialmente"
      },
      "info": {
        "version": "Versión",
        "root": "Implementación de root",
        "zygote": {
          "injected": "Inyectado",
          "notInjected": "No inyectado",
          "unknown": "Desconocido"
        }
      }
    },
    "modules": {
      "header": "Módulos",
      "notAvaliable": "No hay módulos que usen Zygisk aquí.",
      "arch": "Arquitectura: "
    },
    "settings": {
      "header": "Ajustes",
      "font": {
        "header": "Activar fuente del sistema",
        "description": "Esta opción habilitará la fuente del sistema en el WebUI actual. NOTA: Puede no ser compatible con FlipFont"
      },
      "theme": {
        "header": "Tema del sistema",
        "description": "Elija el tema del sistema para el WebUI actual"
      },
      "language": {
        "header": "Cambiar idioma",
        "description": "Selecciona tu nuevo idioma"
      },
      "logs": {
        "header": "Historial de errores",
        "description": "Ver todos tus registros de errores"
      },
      "credits": {
        "module": "Desarrollador del módulo",
        "original": "Desarrollador original del módulo",
        "web": "Desarrollador de la WebUI"
      },
      "license": {
        "module": "Licencia del módulo",
        "web": "Licencia de la WebUI"
      }
    },
    "actions": {
      "header": "Acciones",
      "monitorButton": {
        "pause": "Pausar",
        "stop": "Detener",
        "start": "Iniciar"
      },
      "monitor": "Monitor",
      "status": {
        "tracing": "Trazando",
        "stopping": "Deteniendo",
        "stopped": "Detenido",
        "exiting": "Saliendo",
        "unknown": "Desconocido"
      }
    }
  }
}

```

`webroot/lang/es_MX.json`:

```json
{
  "langName": "Español (México)",
  "global": {
    "unknown": "Desconocido"
  },
  "smallPage": {
    "language": {
      "header": "Elige tu nuevo tema"
    },
    "theme": {
      "header": "Elige tu nuevo tema",
      "dark": "Oscuro",
      "light": "Claro",
      "system": "Basado en el sistema"
    },
    "errorh": {
      "buttons": {
        "copy": "COPIAR",
        "clear": "BORRAR TODOS LOS REGISTROS"
      },
      "header": "Historial de errores",
      "placeholder": "¡No se registró ningún error aquí!"
    }
  },
  "page": {
    "home": {
      "header": "Inicio",
      "status": {
        "notWorking": "No funcionando",
        "ok": "Funcionando",
        "partially": "Funcionando parcialmente"
      },
      "info": {
        "version": "Versión",
        "root": "Implementación de root",
        "zygote": {
          "injected": "Inyectado",
          "notInjected": "No inyectado",
          "unknown": "Desconocido"
        }
      }
    },
    "modules": {
      "header": "Módulos",
      "notAvaliable": "No hay módulos que usen Zygisk aquí.",
      "arch": "Arquitectura: "
    },
    "settings": {
      "header": "Ajustes",
      "font": {
        "header": "Activar fuente del sistema",
        "description": "Esta opción habilitará la fuente del sistema en el WebUI actual. NOTA: Puede no ser compatible con FlipFont"
      },
      "theme": {
        "header": "Tema del sistema",
        "description": "Elige el tema del sistema para el WebUI actual"
      },
      "language": {
        "header": "Cambiar idioma",
        "description": "Cambia a tu nuevo idioma."
      },
      "logs": {
        "header": "Historial de errores",
        "description": "Ver todos tus registros de errores"
      },
      "credits": {
        "module": "Desarrollador del módulo",
        "original": "Desarrollador original del módulo",
        "web": "Desarrollador de la WebUI"
      },
      "license": {
        "module": "Licencia del módulo",
        "web": "Licencia de la WebUI"
      }
    },
    "actions": {
      "header": "Acciones",
      "monitorButton": {
        "pause": "Pausar",
        "stop": "Detener",
        "start": "Iniciar"
      },
      "monitor": "Monitor",
      "status": {
        "tracing": "Trazando",
        "stopping": "Deteniendo",
        "stopped": "Detenido",
        "exiting": "Saliendo",
        "unknown": "Desconocido"
      }
    }
  }
}

```

`webroot/lang/fr_FR.json`:

```json
{
  "langName": "Français (France)",
  "global": {
    "unknown": "Inconnu"
  },
  "smallPage": {
    "language": {
      "header": "Choisissez votre nouvelle langue"
    },
    "theme": {
      "header": "Choisissez votre nouveau thème",
      "dark": "Sombre",
      "light": "Clair",
      "system": "Basé sur le système"
    },
    "errorh": {
      "buttons": {
        "copy": "COPIER",
        "clear": "EFFACER TOUS LES JOURNEAUX"
      },
      "header": "Historique d'erreurs",
      "placeholder": "Pas de journal d'erreur enregistré ici !"
    }
  },
  "page": {
    "home": {
      "header": "Page d'accueil",
      "status": {
        "notWorking": "Inactif",
        "ok": "Actif",
        "partially": "Fonctionnement partiel"
      },
      "info": {
        "version": "Version",
        "root": "Implémentation root",
        "zygote": {
          "injected": "Injecté",
          "notInjected": "Non injecté",
          "unknown": "Inconnu"
        }
      }
    },
    "modules": {
      "header": "Modules",
      "notAvaliable": "Aucuns modules n'utilisent Zygisk actuellement.",
      "arch": " Architecture: "
    },
    "settings": {
      "header": "Paramètres",
      "font": {
        "header": "Activer la police du système",
        "description": "Cette option activera la police de caractère du système d'interface WebUI. NOTE: N'est peut-être pas compatible avec FlipFont"
      },
      "theme": {
        "header": "Thème système",
        "description": "Choisissez votre thème système pour le WebUI"
      },
      "language": {
        "header": "Changez de langue",
        "description": "Changez vers votre nouvelle langue"
      },
      "logs": {
        "header": "Historique d'erreur",
        "description": "Voir le détail du journal d'erreur"
      },
      "credits": {
        "module": "Module développeur",
        "original": "Module Original du Développeur",
        "web": "WebUI Développeur"
      },
      "license": {
        "module": "Module de licence",
        "web": "Licence WebUI"
      }
    },
    "actions": {
      "header": "Actions",
      "monitorButton": {
        "pause": "Mettre en Pause",
        "stop": "Arrêter",
        "start": "Démarrer"
      },
      "monitor": "Surveillance",
      "status": {
        "tracing": "Tracer",
        "stopping": "Stopper immédiatement",
        "stopped": "Arrêté",
        "exiting": "Sortir d'ici",
        "unknown": "Inconnu"
      }
    }
  }
}

```

`webroot/lang/id_ID.json`:

```json
{
  "langName": "Bahasa Indonesia (Indonesia)",
  "global": {
    "unknown": "Tidak diketahui"
  },
  "smallPage": {
    "language": {
      "header": "Pilih bahasa baru Anda"
    },
    "theme": {
      "header": "Pilih tema baru Anda",
      "dark": "Gelap",
      "light": "Terang",
      "system": "Bawaan Sistem"
    },
    "errorh": {
      "buttons": {
        "copy": "SALIN",
        "clear": "BERSIHKAN SEMUA LOG"
      },
      "header": "Log Error",
      "placeholder": "Tidak ada log error tercatat disini!"
    }
  },
  "page": {
    "home": {
      "header": "Beranda",
      "status": {
        "notWorking": "Tidak Bekerja",
        "ok": "Bekerja",
        "partially": "Bekerja Sebagian"
      },
      "info": {
        "version": "Versi",
        "root": "Implementasi Root",
        "zygote": {
          "injected": "Terinjeksi",
          "notInjected": "Tidak Terinjeksi",
          "unknown": "Tidak diketahui"
        }
      }
    },
    "modules": {
      "header": "Modul",
      "notAvaliable": "Tidak ada modul yang menggunakan Zygisk disini.",
      "arch": "Arsitektur: "
    },
    "settings": {
      "header": "Pengaturan",
      "font": {
        "header": "Gunakan Font Sistem",
        "description": "Opsi ini akan mengaktifkan font sistem pada WebUI saat ini. (Mungkin tidak kompatibel dengan FlipFont)"
      },
      "theme": {
        "header": "Tema Sistem",
        "description": "Pilih tema untuk tampilan WebUI Anda saat ini"
      },
      "language": {
        "header": "Ubah Bahasa",
        "description": "Ubah ke bahasa baru Anda"
      },
      "logs": {
        "header": "Log Error",
        "description": "Lihat semua log Error Anda"
      },
      "credits": {
        "module": "Developer Modul",
        "original": "Developer Modul Asli",
        "web": "Developer WebUI"
      },
      "license": {
        "module": "Lisensi Modul",
        "web": "Lisensi WebUI"
      }
    },
    "actions": {
      "header": "Tindakan",
      "monitorButton": {
        "pause": "Jeda",
        "stop": "Berhenti",
        "start": "Mulai"
      },
      "monitor": "Monitor",
      "status": {
        "tracing": "Melacak",
        "stopping": "Menghentikan",
        "stopped": "Terhenti",
        "exiting": "Terkeluar",
        "unknown": "Tidak diketahui"
      }
    }
  }
}

```

`webroot/lang/it_IT.json`:

```json
{
  "langName": "Italiano (Italia)",
  "global": {
    "unknown": "Sconosciuto"
  },
  "smallPage": {
    "language": {
      "header": "Scegli la tua nuova lingua"
    },
    "theme": {
      "header": "Scegli il tuo nuovo tema",
      "dark": "Scuro",
      "light": "Chiaro",
      "system": "Sistema"
    },
    "errorh": {
      "buttons": {
        "copy": "COPIA",
        "clear": "CANCELLA TUTTI I LOGS"
      },
      "header": "Storico degli Errori",
      "placeholder": "Nessun errore è stato registrato qui!"
    }
  },
  "page": {
    "home": {
      "header": "Home",
      "status": {
        "notWorking": "Non funzionante",
        "ok": "Funzionante",
        "partially": "Funzionante Parzialmente"
      },
      "info": {
        "version": "Versione",
        "root": "Implementazione root",
        "zygote": {
          "injected": "Iniettato",
          "notInjected": "Non Iniettato",
          "unknown": "Sconosciuto"
        }
      }
    },
    "modules": {
      "header": "Moduli",
      "notAvaliable": "Nessun modulo che utilizza Zygisk qui.",
      "arch": "Architettura: "
    },
    "settings": {
      "header": "Impostazioni",
      "font": {
        "header": "Abilita font di sistema",
        "description": "Questa opzione abiliterà il font di sistema nella WebUI. NOTA: Potrebbe non funzionare bene con FlipFont"
      },
      "theme": {
        "header": "Tema di sistema",
        "description": "Scegli il tuo tema di sistema per la WebUI"
      },
      "language": {
        "header": "Cambia lingua",
        "description": "Cambia alla tua nuova lingua"
      },
      "logs": {
        "header": "Storico degli errori",
        "description": "Visualizza tutto il log dell'errore"
      },
      "credits": {
        "module": "Programmatore del Modulo",
        "original": "Programmatore del Modulo Originale",
        "web": "Programmatore della WebUI"
      },
      "license": {
        "module": "Licenza del modulo",
        "web": "Licenza della WebUI"
      }
    },
    "actions": {
      "header": "Azioni",
      "monitorButton": {
        "pause": "Pausa",
        "stop": "Ferma",
        "start": "Avvia"
      },
      "monitor": "Controlla",
      "status": {
        "tracing": "Tracing",
        "stopping": "Fermando",
        "stopped": "Fermato",
        "exiting": "Uscendo",
        "unknown": "Sconosciuto"
      }
    }
  }
}

```

`webroot/lang/ja_JP.json`:

```json
{
  "langName": "日本語",
  "global": {
    "unknown": "不明"
  },
  "smallPage": {
    "language": {
      "header": "言語を選択してください"
    },
    "theme": {
      "header": "テーマを選択してください",
      "dark": "ダーク",
      "light": "ライト",
      "system": "システムベース"
    },
    "errorh": {
      "buttons": {
        "copy": "コピー",
        "clear": "すべてのログを消去"
      },
      "header": "エラーの履歴",
      "placeholder": "エラーログは記録されていません！"
    }
  },
  "page": {
    "home": {
      "header": "ホーム",
      "status": {
        "notWorking": "動作していません",
        "ok": "動作中",
        "partially": "部分的に動作中"
      },
      "info": {
        "version": "バージョン",
        "root": "Root の実装",
        "zygote": {
          "injected": "インジェクト済み",
          "notInjected": "未インジェクト",
          "unknown": "不明"
        }
      }
    },
    "modules": {
      "header": "モジュール",
      "notAvaliable": "Zygisk を使用するモジュールはありません。",
      "arch": "アーキテクチャ: "
    },
    "actions": {
      "header": "アクション",
      "monitorButton": {
        "start": "開始",
        "stop": "停止",
        "pause": "一時停止"
      },
      "monitor": "監視",
      "status": {
        "tracing": "トレース中",
        "stopping": "停止中",
        "stopped": "停止済み",
        "exiting": "終了中",
        "unknown": "不明"
      }
    },
    "settings": {
      "header": "設定",
      "font": {
        "header": "システムフォントを有効化",
        "description": "現在の WebUI でシステムフォントの使用を有効化します。注意: FlipFont との互換性がない場合があります"
      },
      "theme": {
        "header": "システムテーマ",
        "description": "WebUI のシステムテーマを変更します"
      },
      "language": {
        "header": "言語の変更",
        "description": "言語を変更します"
      },
      "logs": {
        "header": "エラーの履歴",
        "description": "すべてのエラーログを表示します"
      },
      "credits": {
        "module": "モジュールの開発者",
        "original": "オリジナルの開発者",
        "web": "WebUI の開発者"
      },
      "license": {
        "module": "モジュールのライセンス",
        "web": "WebUI のライセンス"
      }
    }
  }
}

```

`webroot/lang/ms_MS.json`:

```json
{
  "langName": "Malay (Malaysia)",
  "global": {
    "unknown": "Tidak diketahui"
  },
  "smallPage": {
    "language": {
      "header": "Pilih bahasa anda"
    },
    "theme": {
      "header": "Pilih tema anda",
      "dark": "Gelap",
      "light": "Cerah",
      "system": "Berasaskan Sistem"
    },
    "errorh": {
      "buttons": {
        "copy": "Salin",
        "clear": "KOSONGKAN SEMUA LOG"
      },
      "header": "Sejarah Ralat",
      "placeholder": "Tiada log ralat direkodkan di sini!"
    }
  },
  "page": {
    "home": {
      "header": "Home",
      "status": {
        "notWorking": "Tidak Berfungsi",
        "ok": "Berfungsi",
        "partially": "Separa Berfungsi"
      },
      "info": {
        "version": "Versi",
        "root": "Pelaksanaan Root",
        "zygote": {
          "injected": "Disuntik",
          "notInjected": "Tidak Disuntik",
          "unknown": "Tidak diketahui"
        }
      }
    },
    "modules": {
      "header": "Modul",
      "notAvaliable": "Tiada modul menggunakan Zygisk di sini.",
      "arch": "Arkitektur: "
    },
    "settings": {
      "header": "Tetapan",
      "font": {
        "header": "Hidupkan fon sistem",
        "description": "Pilihan ini akan menghidupkan fon sistem dalam WebUI semasa. NOTA: Mungkin tidak serasi dengan FlipFont"
      },
      "theme": {
        "header": "Tema sistem",
        "description": "Pilih tema sistem anda untuk WebUI semasa"
      },
      "language": {
        "header": "Tukar bahasa",
        "description": "Tukar kepada bahasa baharu anda"
      },
      "logs": {
        "header": "Sejarah Ralat",
        "description": "Lihat semua log ralat anda"
      },
      "credits": {
        "module": "Pembangun Modul",
        "original": "Pembangun Modul Asal",
        "web": "Pembangun WebUI"
      },
      "license": {
        "module": "Lesen Modul",
        "web": "Lesen WebUI"
      }
    },
    "actions": {
      "header": "Tindakan",
      "monitorButton": {
        "pause": "Berhenti sebentar",
        "stop": "Berhenti",
        "start": "Mula"
      },
      "monitor": "Pantau",
      "status": {
        "tracing": "Menjejak",
        "stopping": "Berhenti",
        "stopped": "Telah Berhenti",
        "exiting": "Keluar",
        "unknown": "Tidak diketahui"
      }
    }
  }
}

```

`webroot/lang/nl_NL.json`:

```json
{
  "langName": "Nederlands",
  "global": {
    "unknown": "Onbekend"
  },
  "smallPage": {
    "language": {
      "header": "Kies uw nieuwe taal"
    },
    "theme": {
      "header": "Kies uw nieuwe thema",
      "dark": "Donker",
      "light": "Licht",
      "system": "Systeem Gebaseerd"
    },
    "errorh": {
      "buttons": {
        "copy": "KOPIËREN",
        "clear": "VERWIJDER ALLE LOGS"
      },
      "header": "Foutmelding Geschiedenis",
      "placeholder": "Er is hier geen foutlogboek geregistreerd!"
    }
  },
  "page": {
    "home": {
      "header": "Thuis",
      "status": {
        "notWorking": "Werkt Niet",
        "ok": "Werkt",
        "partially": "Werkt Gedeeltelijk"
      },
      "info": {
        "version": "Versie",
        "root": "Root Implementatie",
        "zygote": {
          "injected": "Geïnjecteerd",
          "notInjected": "Niet Geïnjecteerd",
          "unknown": "Onbekend"
        }
      }
    },
    "modules": {
      "header": "Modules",
      "notAvaliable": "Geen modules die Zygisk gebruiken.",
      "arch": "Architectuur: "
    },
    "settings": {
      "header": "Instellingen",
      "font": {
        "header": "Systeem lettertype inschakelen",
        "description": "Deze optie zal het systeemlettertype inschakelen in huidige WebUI. Opmerking: Kan niet compatibel zijn met FlipFont"
      },
      "theme": {
        "header": "Systeem thema",
        "description": "Kies uw systeemthema voor huidige WebUI"
      },
      "language": {
        "header": "Taal wijzigen",
        "description": "Verander naar nieuwe taal"
      },
      "logs": {
        "header": "Foutmelding Geschiedenis",
        "description": "Al uw foutenlogboek weergeven"
      },
      "credits": {
        "module": "Module Ontwikkelaar",
        "original": "Originele Module Ontwikkelaar",
        "web": "WebUI Ontwikkelaar"
      },
      "license": {
        "module": "Module Licentie",
        "web": "WebUI Licentie"
      }
    },
    "actions": {
      "header": "Acties",
      "monitorButton": {
        "pause": "Pauzeren",
        "stop": "Stoppen",
        "start": "Starten"
      },
      "monitor": "Bewaken",
      "status": {
        "tracing": "Traceren",
        "stopping": "Bezig met Stoppen",
        "stopped": "Gestopt",
        "exiting": "Wordt Beëindigd",
        "unknown": "Onbekend"
      }
    }
  }
}

```

`webroot/lang/pt_BR.json`:

```json
{
  "langName": "Português (Brasil)",
  "global": {
    "unknown": "Desconhecido"
  },
  "smallPage": {
    "language": {
      "header": "Escolha o seu novo idioma"
    },
    "theme": {
      "header": "Escolha o seu novo tema",
      "dark": "Escuro",
      "light": "Claro",
      "system": "Baseado no do sistema"
    },
    "errorh": {
      "buttons": {
        "copy": "COPIAR",
        "clear": "LIMPAR TODOS OS REGISTROS"
      },
      "header": "Histórico de Erros",
      "placeholder": "Nenhum registro de erros aqui!"
    }
  },
  "page": {
    "home": {
      "header": "Início",
      "status": {
        "notWorking": "Não funcionando",
        "ok": "Funcionando",
        "partially": "Funcionando parcialmente"
      },
      "info": {
        "version": "Versão",
        "root": "Implementação de Root",
        "zygote": {
          "injected": "Injetado",
          "notInjected": "Não Injetado",
          "unknown": "Desconhecido"
        }
      }
    },
    "modules": {
      "header": "Módulos",
      "notAvaliable": "Nenhum módulo está usando Zygisk aqui.",
      "arch": "Arquitetura: "
    },
    "actions": {
      "header": "Ações",
      "monitorButton": {
        "start": "Iniciar",
        "stop": "Parar",
        "pause": "Pausar"
      },
      "monitor": "Monitor",
      "status": {
        "tracing": "Rastreando",
        "stopping": "Parando",
        "stopped": "Parado",
        "exiting": "Desligando",
        "unknown": "Desconhecido"
      }
    },
    "settings": {
      "header": "Configurações",
      "font": {
        "header": "Usar a fonte do sistema",
        "description": "Esta opção irá usar a fonte do sistema no WebUI atual. Observação: Talvez não seja compatível com o FlipFont"
      },
      "theme": {
        "header": "Tema do sistema",
        "description": "Escolha o tema do seu sistema para o WebUI atual"
      },
      "language": {
        "header": "Alterar a língua",
        "description": "Mude para sua nova língua"
      },
      "logs": {
        "header": "Histórico de Erros",
        "description": "Ver o histórico de erros inteiro"
      },
      "credits": {
        "module": "Desenvolvedora do módulo",
        "original": "Desenvolvedores do módulo original",
        "web": "Desenvolvedor do WebUI"
      },
      "license": {
        "module": "Licença do Módulo",
        "web": "Licença do WebUI"
      }
    }
  }
}

```

`webroot/lang/ru_RU.json`:

```json
{
  "langName": "Русский (Россия)",
  "global": {
    "unknown": "Неизвестно"
  },
  "smallPage": {
    "language": {
      "header": "Выберите ваш новый язык"
    },
    "theme": {
      "header": "Выберите свою новую тему",
      "dark": "Темная",
      "light": "Светлая",
      "system": "На основе системной темы"
    },
    "errorh": {
      "buttons": {
        "copy": "Копировать",
        "clear": "Очистить все логи"
      },
      "header": "Журнал ошибок",
      "placeholder": "Журнал ошибок здесь не ведется!"
    }
  },
  "page": {
    "home": {
      "header": "Главная",
      "status": {
        "notWorking": "Не работает",
        "ok": "Работает",
        "partially": "Частично работает"
      },
      "info": {
        "version": "Версия",
        "root": "Root реализация",
        "zygote": {
          "injected": "Инъецировано",
          "notInjected": "Не инъецировано",
          "unknown": "Неизвестно"
        }
      }
    },
    "modules": {
      "header": "Модули",
      "notAvaliable": "Здесь нет модулей, использующих Zygisk.",
      "arch": "Архитектура: "
    },
    "settings": {
      "header": "Настройки",
      "font": {
        "header": "Включить системный шрифт",
        "description": "Эта опция включит системный шрифт в текущем WebUI. ПРИМЕЧАНИЕ: Может быть несовместимо с FlipFont"
      },
      "theme": {
        "header": "Системная тема",
        "description": "Выберите вашу системную тему для текущего WebUI"
      },
      "language": {
        "header": "Сменить язык",
        "description": "Измените на ваш новый язык"
      },
      "logs": {
        "header": "История ошибок",
        "description": "Просмотреть весь журнал ваших ошибок"
      },
      "credits": {
        "module": "Разработчик модуля",
        "original": "Разработчик оригинального модуля",
        "web": "Разработчик WebUI"
      },
      "license": {
        "module": "Лицензия модуля",
        "web": "Лицензия WebUI"
      }
    },
    "actions": {
      "header": "Действия",
      "monitorButton": {
        "pause": "Пауза",
        "stop": "Стоп",
        "start": "Начать"
      },
      "monitor": "Обзор",
      "status": {
        "tracing": "Состояние",
        "stopping": "Остановка",
        "stopped": "Остановлено",
        "exiting": "Выход",
        "unknown": "Неизвестно"
      }
    }
  }
}

```

`webroot/lang/tr_TR.json`:

```json
{
  "langName": "Türkçe (Türkiye)",
  "global": {
    "unknown": "Bilinmiyor"
  },
  "smallPage": {
    "language": {
      "header": "Yeni dilinizi seçin"
    },
    "theme": {
      "header": "Yeni temanızı seçin",
      "dark": "Koyu",
      "light": "Açık",
      "system": "Sistem Tabanlı"
    },
    "errorh": {
      "buttons": {
        "copy": "KOPYALA",
        "clear": "BÜTÜN KAYITLARI SİL"
      },
      "header": "Hata Geçmişi",
      "placeholder": "Burada kaydedilmiş hata yok!"
    }
  },
  "page": {
    "home": {
      "header": "Anasayfa",
      "status": {
        "notWorking": "Aktif Değil",
        "ok": "Aktif",
        "partially": "Yarı-Aktif"
      },
      "info": {
        "version": "Versiyon",
        "root": "Root İmplementasyonu",
        "zygote": {
          "injected": "Enjekte",
          "notInjected": "Enjekte Değil",
          "unknown": "Bilinmiyor"
        }
      }
    },
    "modules": {
      "header": "Modüller",
      "notAvaliable": "Burada Zygisk kullanan modül yok.",
      "arch": "Mimari: "
    },
    "actions": {
      "header": "Hareketler",
      "monitorButton": {
        "start": "Başlat",
        "stop": "Bitir",
        "pause": "Durdur"
      },
      "monitor": "Monitör",
      "status": {
        "tracing": "İzleniyor",
        "stopping": "Durduluyor",
        "stopped": "Durdu",
        "exiting": "Çıkılıyor",
        "unknown": "Bilinmiyor"
      }
    },
    "settings": {
      "header": "Ayarlar",
      "font": {
        "header": "Sistem yazı tipini aktifleştir",
        "description": "Bu seçenek anlık WebUI (Web Arayüzü) için sistem yazıt tipini aktifleştirir. NOT: FlipFont ile uyumlu olmayabilir!"
      },
      "theme": {
        "header": "Sistem Teması",
        "description": "Anlık WebUI için sistem temanı seç"
      },
      "language": {
        "header": "Dil değiştir",
        "description": "Yeni dilini seç"
      },
      "logs": {
        "header": "Hata Geçmişi",
        "description": "Bütün hata kayıtlarını görüntüle"
      },
      "credits": {
        "module": "Modül Geliştiricisi",
        "original": "Orijinal Modül Geliştiricisi",
        "web": "WebUI Geliştiricisi"
      },
      "license": {
        "module": "Modül Lisansı",
        "web": "WebUI Lisansı"
      }
    }
  }
}

```

`webroot/lang/uk_UA.json`:

```json
{
  "langName": "Українська (Україна)",
  "global": {
    "unknown": "Невідомо"
  },
  "smallPage": {
    "language": {
      "header": "Оберіть нову мову"
    },
    "theme": {
      "header": "Оберіть нову тему",
      "dark": "Темна",
      "light": "Світла",
      "system": "За системною"
    },
    "errorh": {
      "buttons": {
        "copy": "Копіювати",
        "clear": "Очистити всі записи"
      },
      "header": "Історія помилок",
      "placeholder": "Жодної помилки не було записано тут!"
    }
  },
  "page": {
    "home": {
      "header": "Головна",
      "status": {
        "notWorking": "Не працює",
        "ok": "Працює",
        "partially": "Частково працює"
      },
      "info": {
        "version": "Версія",
        "root": "Root реалізація",
        "zygote": {
          "injected": "Ін'єктовано",
          "notInjected": "Не ін'єктовано",
          "unknown": "Невідомо"
        }
      }
    },
    "modules": {
      "header": "Модулі",
      "notAvaliable": "Немає модулів, які б використовували Zygisk.",
      "arch": "Архітектура: "
    },
    "actions": {
      "header": "Дії",
      "monitorButton": {
        "start": "Почати",
        "stop": "Зупинити",
        "pause": "Пауза"
      },
      "monitor": "Моніторинг",
      "status": {
        "tracing": "Відстежується",
        "stopping": "Зупиняється",
        "stopped": "Зупинено",
        "exiting": "Виходить",
        "unknown": "Невідомий"
      }
    },
    "settings": {
      "header": "Налаштування",
      "font": {
        "header": "Увімкнути системний шрифт",
        "description": "Ця опція увімкне системний шрифт у поточному WebUI. Примітка: Може бути несумісною з FlipFont"
      },
      "theme": {
        "header": "Системна тема",
        "description": "Виберіть системну тему для поточного WebUI"
      },
      "language": {
        "header": "Змінити мову",
        "description": "Змінити на вашу нову мову"
      },
      "logs": {
        "header": "Журнал помилок",
        "description": "Переглянути весь журнал помилок"
      },
      "credits": {
        "module": "Розробники модуля",
        "original": "Оригінальний розробник модуля",
        "web": "Розробник WebUI"
      },
      "license": {
        "module": "Ліцензія модуля",
        "web": "Ліцензія WebUI"
      }
    }
  }
}

```

`webroot/lang/vi_VN.json`:

```json
{
  "langName": "Tiếng Việt",
  "global": {
    "unknown": "Không xác định"
  },
  "smallPage": {
    "language": {
      "header": "Chọn ngôn ngữ mới của bạn"
    },
    "theme": {
      "header": "Chọn giao diện mới của bạn",
      "dark": "Tối",
      "light": "Sáng",
      "system": "Theo hệ thống"
    },
    "errorh": {
      "buttons": {
        "copy": "SAO CHÉP",
        "clear": "XOÁ TOÀN BỘ LOGS"
      },
      "header": "Lịch Sử Lỗi",
      "placeholder": "Không có lỗi nào được ghi ở đây!"
    }
  },
  "page": {
    "home": {
      "header": "Trang Chủ",
      "status": {
        "notWorking": "Không hoạt động",
        "ok": "Đang hoạt động",
        "partially": "Đang hoạt động một phần"
      },
      "info": {
        "version": "Phiên bản",
        "root": "Hệ thống root",
        "zygote": {
          "injected": "Đã can thiệp",
          "notInjected": "Chưa can thiệp",
          "unknown": "Không xác định"
        }
      }
    },
    "modules": {
      "header": "Mô Đun",
      "notAvaliable": "Không có mô-đun nào sử dụng Zygisk ở đây!",
      "arch": "Cấu trúc: "
    },
    "actions": {
      "header": "Trình điều khiển",
      "monitorButton": {
        "start": "Chạy",
        "stop": "Dừng",
        "pause": "Tạm Dừng"
      },
      "monitor": "Trình theo dõi",
      "status": {
        "tracing": "Đang chạy",
        "stopping": "Đang Dừng",
        "stopped": "Đã Dừng",
        "exiting": "Đã Thoát",
        "unknown": "Không Xác Định"
      }
    },
    "settings": {
      "header": "Cài đặt",
      "font": {
        "header": "Sử dụng phông chữ hệ thống",
        "description": "Tuỳ chọn này sẽ cho phép người dùng sử dụng phông chữ của hệ thống. LƯU Ý: Có thể sẽ không tương thích với FlipFont"
      },
      "theme": {
        "header": "Giao diện hệ thống",
        "description": "Chọn giao diện cho WebUI hiện tại của bạn"
      },
      "language": {
        "header": "Thay đổi ngôn ngữ",
        "description": "Thay đổi sang ngôn ngữ mới"
      },
      "logs": {
        "header": "Lịch sử lỗi",
        "description": "Xem tất cả các lỗi"
      },
      "credits": {
        "module": "Nhà phát triển mô-đun",
        "original": "Nhà phát triển mô-đun gốc",
        "web": "Nhà phát triển WebUI"
      },
      "license": {
        "module": "Giấy phép bản quyền mô-đun",
        "web": "Giấy phép bản quyền WebUI"
      }
    }
  }
}

```

`webroot/lang/zh_CN.json`:

```json
{
  "langName": "简体中文 (中国)",
  "global": {
    "unknown": "未知"
  },
  "smallPage": {
    "language": {
      "header": "选择语言"
    },
    "theme": {
      "header": "选择主题风格",
      "dark": "暗色",
      "light": "浅色",
      "system": "跟随系统"
    },
    "errorh": {
      "buttons": {
        "copy": "复制",
        "clear": "清空日志"
      },
      "header": "错误日志",
      "placeholder": "暂时没有错误日志"
    }
  },
  "page": {
    "home": {
      "header": "主页",
      "status": {
        "notWorking": "未运行",
        "ok": "运行中",
        "partially": "部分运行"
      },
      "info": {
        "version": "版本",
        "root": "Root实现",
        "zygote": {
          "injected": "已注入",
          "notInjected": "未注入",
          "unknown": "未知"
        }
      }
    },
    "modules": {
      "header": "模块",
      "notAvaliable": "目前没有模块使用Zygisk",
      "arch": "架构: "
    },
    "actions": {
      "header": "操作",
      "monitorButton": {
        "start": "启动",
        "stop": "停止",
        "pause": "暂停"
      },
      "monitor": "监视器",
      "status": {
        "tracing": "追踪中",
        "stopping": "正在停止",
        "stopped": "已停止",
        "exiting": "正在退出",
        "unknown": "未知"
      }
    },
    "settings": {
      "header": "设置",
      "font": {
        "header": "启用系统字体",
        "description": "此选项会在Web界面启用系统字体。可能与FlipFont不兼容。"
      },
      "theme": {
        "header": "主题",
        "description": "选择Web界面的主题风格"
      },
      "language": {
        "header": "语言",
        "description": "切换不同的语言"
      },
      "logs": {
        "header": "错误日志",
        "description": "浏览所有错误日志"
      },
      "credits": {
        "module": "模块开发者",
        "original": "源模块开发者",
        "web": "Web界面开发者"
      },
      "license": {
        "module": "模块开源许可",
        "web": "Web界面开源许可"
      }
    }
  }
}

```

`zygiskd/build.gradle.kts`:

```kts
import java.nio.file.Paths
import org.gradle.internal.os.OperatingSystem

fun getLatestNDKPath(): String {
  val android_home = System.getenv("ANDROID_HOME")
  if (android_home == null) {
    throw Exception("ANDROID_HOME not set")
  }

  val ndkPath = android_home + "/ndk"

  val ndkDir = Paths.get(ndkPath)
  if (!ndkDir.toFile().exists()) {
    throw Exception("NDK not found at $ndkPath")
  }

  val ndkVersion = ndkDir.toFile().listFiles().filter { it.isDirectory }.map { it.name }.sorted().last()
  return ndkPath + "/" + ndkVersion
}

val minAPatchVersion: Int by rootProject.extra
val minKsuVersion: Int by rootProject.extra
val maxKsuVersion: Int by rootProject.extra
val minMagiskVersion: Int by rootProject.extra
val verCode: Int by rootProject.extra
val verName: String by rootProject.extra
val commitHash: String by rootProject.extra

/* INFO: Due to a bug in NDK compiler, where it says "-Wno-fixed-enum-extension" option
           doesn't exist, we must utilize "-Wno-unknown-warning-option". */
val CStandardFlags = arrayOf(
  "-D_GNU_SOURCE", "-std=c99", "-Wpedantic", "-Wall", "-Wextra", "-Werror",
  "-Wformat", "-Wuninitialized", "-Wshadow", "-Wno-zero-length-array", 
  "-Wno-fixed-enum-extension", "-Wno-unknown-warning-option", "-Wno-c23-extensions",
  "-Wconversion", "-Iroot_impl", "-llog", "-DMIN_APATCH_VERSION=$minAPatchVersion",
  "-DMIN_KSU_VERSION=$minKsuVersion",
  "-DMIN_MAGISK_VERSION=$minMagiskVersion",
  "-DZKSU_VERSION=\"$verName\""
)

val CFlagsRelease = arrayOf(
  "-Wl,--strip-all", "-flto=thin", "-O3", "-ffast-math"
)

val CFlagsDebug = arrayOf(
  "-g", "-O0", "-DDEBUG"
)

val Files = arrayOf(
  "root_impl/apatch.c",
  "root_impl/common.c",
  "root_impl/kernelsu.c",
  "root_impl/magisk.c",
  "companion.c",
  "main.c",
  "utils.c",
  "zygiskd.c"
)

task("buildAndStrip") {
  group = "build"
  description = "Build the native library and strip the debug symbols."

  val isDebug = gradle.startParameter.taskNames.any { it.lowercase().contains("debug") }
  doLast {
    val ndkPath = getLatestNDKPath()

    val aarch64Compiler = Paths.get(ndkPath, "toolchains", "llvm", "prebuilt", "linux-x86_64", "bin", "aarch64-linux-android34-clang").toString()
    val armv7aCompiler = Paths.get(ndkPath, "toolchains", "llvm", "prebuilt", "linux-x86_64", "bin", "armv7a-linux-androideabi34-clang").toString()
    val x86Compiler = Paths.get(ndkPath, "toolchains", "llvm", "prebuilt", "linux-x86_64", "bin", "i686-linux-android34-clang").toString()
    val x86_64Compiler = Paths.get(ndkPath, "toolchains", "llvm", "prebuilt", "linux-x86_64", "bin", "x86_64-linux-android34-clang").toString()

    if (!Paths.get(aarch64Compiler).toFile().exists()) {
      throw Exception("aarch64 compiler not found at $aarch64Compiler")
    }

    if (!Paths.get(armv7aCompiler).toFile().exists()) {
      throw Exception("armv7a compiler not found at $armv7aCompiler")
    }

    if (!Paths.get(x86Compiler).toFile().exists()) {
      throw Exception("x86 compiler not found at $x86Compiler")
    }

    if (!Paths.get(x86_64Compiler).toFile().exists()) {
      throw Exception("x86_64 compiler not found at $x86_64Compiler")
    }

    val Files = Files.map { Paths.get(project.projectDir.toString(), "src", it).toString() }.toTypedArray()

    val buildDir = getLayout().getBuildDirectory().getAsFile().get()
    buildDir.mkdirs()

    val aarch64OutputDir = Paths.get(buildDir.toString(), "arm64-v8a").toFile()
    val armv7aOutputDir = Paths.get(buildDir.toString(), "armeabi-v7a").toFile()
    val x86OutputDir = Paths.get(buildDir.toString(), "x86").toFile()
    val x86_64OutputDir = Paths.get(buildDir.toString(), "x86_64").toFile()

    aarch64OutputDir.mkdirs()
    armv7aOutputDir.mkdirs()
    x86OutputDir.mkdirs()
    x86_64OutputDir.mkdirs()

    val compileArgs = (if (isDebug) CFlagsDebug else CFlagsRelease) + CStandardFlags

    exec {
      commandLine(aarch64Compiler, "-o", Paths.get(aarch64OutputDir.toString(), "zygiskd").toString(), *compileArgs, *Files)
    }
    exec {
      commandLine(armv7aCompiler, "-o", Paths.get(armv7aOutputDir.toString(), "zygiskd").toString(), *compileArgs, *Files)
    }
    exec {
      commandLine(x86Compiler, "-o", Paths.get(x86OutputDir.toString(), "zygiskd").toString(), *compileArgs, *Files)
    }
    exec {
      commandLine(x86_64Compiler, "-o", Paths.get(x86_64OutputDir.toString(), "zygiskd").toString(), *compileArgs, *Files)
    }
  }
}


```

`zygiskd/src/LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.

```

`zygiskd/src/companion.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>

#include <unistd.h>
#include <linux/limits.h>
#include <pthread.h>

#include <android/log.h>

#include "utils.h"

#undef LOG_TAG
#define LOG_TAG lp_select("zygiskd-companion32", "zygiskd-companion64")

typedef void (*zygisk_companion_entry)(int);

struct companion_module_thread_args {
  int fd;
  zygisk_companion_entry entry;
};

zygisk_companion_entry load_module(int fd) {
  char path[PATH_MAX];
  snprintf(path, sizeof(path), "/proc/self/fd/%d", fd);

  void *handle = dlopen(path, RTLD_NOW);
  if (!handle) {
    LOGE("Failed to dlopen module: %s\n", dlerror());

    return NULL;
  }

  void *entry = dlsym(handle, "zygisk_companion_entry");
  if (!entry) {
    LOGE("Failed to dlsym zygisk_companion_entry: %s\n", dlerror());

    dlclose(handle);

    return NULL;
  }

  return (zygisk_companion_entry)entry;
}

/* WARNING: Dynamic memory based */
void *entry_thread(void *arg) {
  struct companion_module_thread_args *args = (struct companion_module_thread_args *)arg;

  int fd = args->fd;
  zygisk_companion_entry module_entry = args->entry;

  struct stat st0 = { 0 };
  if (fstat(fd, &st0) == -1) {
    LOGE(" - Failed to get initial client fd stats: %s\n", strerror(errno));

    free(args);

    return NULL;
  }

  module_entry(fd);

  /* INFO: Only attempt to close the client fd if it appears to be the same file
             and if we can successfully stat it again. This prevents double closes
             if the module companion already closed the fd.
  */
  struct stat st1;
  if (fstat(fd, &st1) != -1 || st0.st_ino == st1.st_ino) {
    LOGI(" - Client fd changed after module entry\n");

    close(fd);
  }

  free(args);

  return NULL;
}

/* WARNING: Dynamic memory based */
void companion_entry(int fd) {
  LOGI("New companion entry.\n - Client fd: %d\n", fd);

  char name[256 + 1];
  ssize_t ret = read_string(fd, name, sizeof(name));
  if (ret == -1) {
    LOGE("Failed to read module name\n");

    goto cleanup;
  }

  LOGI(" - Module name: \"%s\"\n", name);

  int library_fd = read_fd(fd);
  if (library_fd == -1) {
    LOGE("Failed to receive library fd\n");

    goto cleanup;
  }

  LOGI(" - Library fd: %d\n", library_fd);

  zygisk_companion_entry module_entry = load_module(library_fd);
  close(library_fd);

  if (module_entry == NULL) {
    LOGE(" - No companion module entry for module: %s\n", name);

    ret = write_uint8_t(fd, 0);
    ASSURE_SIZE_WRITE("ZygiskdCompanion", "module_entry", ret, sizeof(uint8_t));

    goto cleanup;
  } else {
    LOGI(" - Module entry found\n");

    ret = write_uint8_t(fd, 1);
    ASSURE_SIZE_WRITE("ZygiskdCompanion", "module_entry", ret, sizeof(uint8_t));
  }

  struct sigaction sa = { .sa_handler = SIG_IGN };
  sigaction(SIGPIPE, &sa, NULL);

  while (1) {
    if (!check_unix_socket(fd, true)) {
      LOGE("Something went wrong in companion. Bye!\n");

      break;
    }

    int client_fd = read_fd(fd);
    if (client_fd == -1) {
      LOGE("Failed to receive client fd\n");

      break;
    }

    struct companion_module_thread_args *args = malloc(sizeof(struct companion_module_thread_args));
    if (args == NULL) {
      LOGE("Failed to allocate memory for thread args\n");

      close(client_fd);

      break;
    }

    args->fd = client_fd;
    args->entry = module_entry;

    LOGI("New companion request.\n - Module name: %s\n - Client fd: %d\n", name, client_fd);

    ret = write_uint8_t(client_fd, 1);
    if (ret != sizeof(uint8_t)) {
      LOGE("Failed to send client_fd in ZygiskdCompanion: Expected %zu, got %zd\n", sizeof(uint8_t), ret);

      free(args);
      close(client_fd);

      break;
    }

    pthread_t thread;
    if (pthread_create(&thread, NULL, entry_thread, (void *)args) == 0)
      continue;

    LOGE(" - Failed to create thread for companion module\n");

    close(client_fd);
    free(args);

    break;
  }

  cleanup:
    close(fd);
    LOGE("Companion thread exited\n");

    exit(0);
}

```

`zygiskd/src/companion.h`:

```h
#ifndef COMPANION_H
#define COMPANION_H

void companion_entry(int fd);

#endif /* COMPANION_H */

```

`zygiskd/src/constants.h`:

```h
#ifndef CONSTANTS_H
#define CONSTANTS_H

#include <stdbool.h>

#include <android/log.h>

#if (defined(__LP64__) || defined(_LP64))
  #define lp_select(a, b) b
#else
  #define lp_select(a, b) a
#endif

#define PROCESS_NAME_MAX_LEN 256 + 1

#define ZYGOTE_INJECTED lp_select(5, 4)
#define DAEMON_SET_INFO lp_select(7, 6)
#define DAEMON_SET_ERROR_INFO lp_select(9, 8)
#define SYSTEM_SERVER_STARTED 10

enum DaemonSocketAction {
  ZygoteInjected         = 0,
  GetProcessFlags        = 1,
  GetInfo                = 2,
  ReadModules            = 3,
  RequestCompanionSocket = 4,
  GetModuleDir           = 5,
  ZygoteRestart          = 6,
  SystemServerStarted    = 7,
  UpdateMountNamespace   = 8
};

enum ProcessFlags: uint32_t {
  PROCESS_GRANTED_ROOT = (1u << 0),
  PROCESS_ON_DENYLIST = (1u << 1),
  PROCESS_IS_MANAGER = (1u << 27),
  PROCESS_ROOT_IS_APATCH = (1u << 28),
  PROCESS_ROOT_IS_KSU = (1u << 29),
  PROCESS_ROOT_IS_MAGISK = (1u << 30),
  PROCESS_IS_FIRST_STARTED = (1u << 31)
};

enum RootImplState {
  Supported,
  TooOld,
  Inexistent,
  Abnormal
};

enum MountNamespaceState {
  Clean,
  Mounted
};

#endif /* CONSTANTS_H */

```

`zygiskd/src/main.c`:

```c
#include <stdlib.h>
#include <string.h>

#include <android/log.h>

#include "root_impl/common.h"
#include "companion.h"
#include "zygiskd.h"

#include "utils.h"

int __android_log_print(int prio, const char *tag, const char *fmt, ...);

int main(int argc, char *argv[]) {
  #ifdef __LP64__
    LOGI("Welcome to ReZygisk %s Zygiskd64!\n", ZKSU_VERSION);
  #else
    LOGI("Welcome to ReZygisk %s Zygiskd32!\n", ZKSU_VERSION);
  #endif

  if (argc > 1) {
    if (strcmp(argv[1], "companion") == 0) {
      if (argc < 3) {
        LOGI("Usage: zygiskd companion <fd>\n");

        return 1;
      }

      int fd = atoi(argv[2]);
      companion_entry(fd);

      return 0;
    }

    else if (strcmp(argv[1], "version") == 0) {
      LOGI("ReZygisk Daemon %s\n", ZKSU_VERSION);

      return 0;
    }

    else if (strcmp(argv[1], "root") == 0) {
      root_impls_setup();

      struct root_impl impl;
      get_impl(&impl);

      char impl_name[LONGEST_ROOT_IMPL_NAME];
      stringify_root_impl_name(impl, impl_name);

      LOGI("Root implementation: %s\n", impl_name);

      return 0;
    }

    else {
      LOGI("Usage: zygiskd [companion|version|root]\n");

      return 0;
    }
  }

  if (switch_mount_namespace(1) == false) {
    LOGE("Failed to switch mount namespace\n");

    return 1;
  }
  root_impls_setup();
  zygiskd_start(argv);

  return 0;
}

```

`zygiskd/src/root_impl/apatch.c`:

```c
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

#include "../constants.h"
#include "../utils.h"
#include "common.h"

#include "apatch.h"

void apatch_get_existence(struct root_impl_state *state) {
  struct stat s;
  if (stat("/data/adb/apd", &s) != 0) {
    if (errno != ENOENT) {
      LOGE("Failed to stat APatch apd binary: %s\n", strerror(errno));
    }
    errno = 0;

    state->state = Inexistent;

    return;
  }

  const char *PATH = getenv("PATH");
  if (PATH == NULL) {
    LOGE("Failed to get PATH environment variable: %s\n", strerror(errno));
    errno = 0;

    state->state = Inexistent;

    return;
  }

  if (strstr(PATH, "/data/adb/ap/bin") == NULL) {
    LOGE("APatch's APD binary is not in PATH\n");

    state->state = Inexistent;

    return;
  }

  char apatch_version[32];
  char *const argv[] = { "apd", "-V", NULL };

  if (!exec_command(apatch_version, sizeof(apatch_version), "/data/adb/apd", argv)) {
    LOGE("Failed to execute apd binary: %s\n", strerror(errno));
    errno = 0;

    state->state = Inexistent;

    return;
  }

  int version = atoi(apatch_version + strlen("apd "));

  if (version == 0) state->state = Abnormal;
  else if (version >= MIN_APATCH_VERSION && version <= 999999) state->state = Supported;
  else if (version >= 1 && version <= MIN_APATCH_VERSION - 1) state->state = TooOld;
  else state->state = Abnormal;
}

struct package_config {
  char *process;
  uid_t uid;
  bool root_granted;
  bool umount_needed;
};

struct packages_config {
  struct package_config *configs;
  size_t size;
};

void _apatch_free_package_config(struct packages_config *restrict config) {
  for (size_t i = 0; i < config->size; i++) {
    free(config->configs[i].process);
  }

  free(config->configs);
}

/* WARNING: Dynamic memory based */
bool _apatch_get_package_config(struct packages_config *restrict config) {
  config->configs = NULL;
  config->size = 0;

  FILE *fp = fopen("/data/adb/ap/package_config", "r");
  if (fp == NULL) {
    LOGE("Failed to open APatch's package_config: %s\n", strerror(errno));

    return false;
  }

  char line[1048];
  /* INFO: Skip the CSV header */
  if (fgets(line, sizeof(line), fp) == NULL) {
    LOGE("Failed to read APatch's package_config header: %s\n", strerror(errno));

    fclose(fp);

    return false;
  }

  while (fgets(line, sizeof(line), fp) != NULL) {
    struct package_config *tmp_configs = realloc(config->configs, (config->size + 1) * sizeof(struct package_config));
    if (tmp_configs == NULL) {
      LOGE("Failed to realloc APatch config struct: %s\n", strerror(errno));

      _apatch_free_package_config(config);
      fclose(fp);

      return false;
    }
    config->configs = tmp_configs;

    char *save_ptr = NULL;
    const char *process_str = strtok_r(line, ",", &save_ptr);
    if (process_str == NULL) continue;

    const char *exclude_str = strtok_r(NULL, ",", &save_ptr);
    if (exclude_str == NULL) continue;

    const char *allow_str = strtok_r(NULL, ",", &save_ptr);
    if (allow_str == NULL) continue;

    const char *uid_str = strtok_r(NULL, ",", &save_ptr);
    if (uid_str == NULL) continue;

    config->configs[config->size].process = strdup(process_str);
    if (config->configs[config->size].process == NULL) {
      LOGE("Failed to strdup for the process `%s`: %s\n", process_str, strerror(errno));

      _apatch_free_package_config(config);
      fclose(fp);

      return false;
    }
    config->configs[config->size].uid = (uid_t)atoi(uid_str);
    config->configs[config->size].root_granted = strcmp(allow_str, "1") == 0;
    config->configs[config->size].umount_needed = strcmp(exclude_str, "1") == 0;

    config->size++;
  }

  fclose(fp);

  return true;
}

bool apatch_uid_granted_root(uid_t uid) {
  struct packages_config config;
  if (!_apatch_get_package_config(&config)) return false;

  for (size_t i = 0; i < config.size; i++) {
    if (config.configs[i].uid != uid) continue;

    /* INFO: This allow us to copy the information to avoid use-after-free */
    bool root_granted = config.configs[i].root_granted;

    _apatch_free_package_config(&config);

    return root_granted;
  }

  _apatch_free_package_config(&config);

  return false;
}

bool apatch_uid_should_umount(uid_t uid, const char *const process) {
  struct packages_config config;
  if (!_apatch_get_package_config(&config)) return false;

  for (size_t i = 0; i < config.size; i++) {
    if (config.configs[i].uid != uid) continue;

    /* INFO: This allow us to copy the information to avoid use-after-free */
    bool umount_needed = config.configs[i].umount_needed;

    _apatch_free_package_config(&config);

    return umount_needed;
  }

  /* INFO: Isolated services have different UIDs than the main app, and
             while libzygisk.so has code to send the UID of the app related
             to the isolated service, we add this so that in case it fails,
             this should avoid it pass through as Mounted.
  */
  if (IS_ISOLATED_SERVICE(uid)) {
    size_t targeted_process_length = strlen(process);

    for (size_t i = 0; i < config.size; i++) {
      size_t config_process_length = strlen(config.configs[i].process);
      size_t smallest_process_length = targeted_process_length < config_process_length ? targeted_process_length : config_process_length;

      if (strncmp(config.configs[i].process, process, smallest_process_length) != 0) continue;

      /* INFO: This allow us to copy the information to avoid use-after-free */
      bool umount_needed = config.configs[i].umount_needed;

      _apatch_free_package_config(&config);

      return umount_needed;
    }
  }

  _apatch_free_package_config(&config);

  return false;
}

bool apatch_uid_is_manager(uid_t uid) {
  struct stat s;
  if (stat("/data/user_de/0/me.bmax.apatch", &s) == -1) {
    if (errno != ENOENT) {
      LOGE("Failed to stat APatch manager data directory: %s\n", strerror(errno));
    }
    errno = 0;

    return false;
  }

  return s.st_uid == uid;
}

```

`zygiskd/src/root_impl/apatch.h`:

```h
#ifndef APATCH_H
#define APATCH_H

#include "common.h"

void apatch_get_existence(struct root_impl_state *state);

bool apatch_uid_granted_root(uid_t uid);

bool apatch_uid_should_umount(uid_t uid, const char *const process);

bool apatch_uid_is_manager(uid_t uid);

#endif

```

`zygiskd/src/root_impl/common.c`:

```c
#include <sys/types.h>
#include <sys/stat.h>

#include "../utils.h"
#include "kernelsu.h"
#include "apatch.h"
#include "magisk.h"

#include "common.h"

static struct root_impl impl;

void root_impls_setup(void) {
  struct root_impl_state state_ksu;
  ksu_get_existence(&state_ksu);

  struct root_impl_state state_apatch;
  apatch_get_existence(&state_apatch);

  struct root_impl_state state_magisk;
  magisk_get_existence(&state_magisk);

  /* INFO: Check if it's only one supported, if not, it's multile and that's bad.
            Remember that true here is equal to the integer 1. */
  if ((state_ksu.state == Supported ? 1 : 0) + (state_apatch.state == Supported ? 1 : 0) + (state_magisk.state == Supported ? 1 : 0) >= 2) {
    impl.impl = Multiple;
  } else if (state_ksu.state == Supported) {
    impl.impl = KernelSU;
    impl.variant = state_ksu.variant;
  } else if (state_apatch.state == Supported) {
    impl.impl = APatch;
  } else if (state_magisk.state == Supported) {
    impl.impl = Magisk;
    impl.variant = state_magisk.variant;
  } else {
    impl.impl = None;
  }

  switch (impl.impl) {
    case None: {
      LOGI("No root implementation found.\n");

      break;
    }
    case Multiple: {
      LOGI("Multiple root implementations found.\n");

      break;
    }
    case KernelSU: {
      LOGI("KernelSU root implementation found.\n");

      break;
    }
    case APatch: {
      LOGI("APatch root implementation found.\n");

      break;
    }
    case Magisk: {
      if (state_magisk.variant == 0) {
        LOGI("Magisk Official root implementation found.\n");
      } else {
        LOGI("Magisk Kitsune root implementation found.\n");
      }

      break;
    }
  }
}

void get_impl(struct root_impl *uimpl) {
  *uimpl = impl;
}

bool uid_granted_root(uid_t uid) {
  switch (impl.impl) {
    case KernelSU: {
      return ksu_uid_granted_root(uid);
    }
    case APatch: {
      return apatch_uid_granted_root(uid);
    }
    case Magisk: {
      return magisk_uid_granted_root(uid);
    }
    default: {
      return false;
    }
  }
}

bool uid_should_umount(uid_t uid, const char *const process) {
  switch (impl.impl) {
    case KernelSU: {
      return ksu_uid_should_umount(uid);
    }
    case APatch: {
      return apatch_uid_should_umount(uid, process);
    }
    case Magisk: {
      return magisk_uid_should_umount(process);
    }
    default: {
      return false;
    }
  }
}

bool uid_is_manager(uid_t uid) {
  switch (impl.impl) {
    case KernelSU: {
      return ksu_uid_is_manager(uid);
    }
    case APatch: {
      return apatch_uid_is_manager(uid);
    }
    case Magisk: {
      return magisk_uid_is_manager(uid);
    }
    default: {
      return false;
    }
  }
}

void root_impl_cleanup(void) {
  if (impl.impl == KernelSU) ksu_cleanup();
}

```

`zygiskd/src/root_impl/common.h`:

```h
#ifndef COMMON_H
#define COMMON_H

#include <stdint.h>
#include <sys/types.h>

#include "../constants.h"

enum root_impls {
  None,
  Multiple,
  KernelSU,
  APatch,
  Magisk
};

struct root_impl_state {
  enum RootImplState state;
  uint8_t variant;
};

struct root_impl {
  enum root_impls impl;
  uint8_t variant;
};

#define LONGEST_ROOT_IMPL_NAME sizeof("Magisk Official")

void root_impls_setup(void);

void get_impl(struct root_impl *uimpl);

bool uid_granted_root(uid_t uid);

bool uid_should_umount(uid_t uid, const char *const process);

bool uid_is_manager(uid_t uid);

void root_impl_cleanup(void);

#endif /* COMMON_H */

```

`zygiskd/src/root_impl/kernelsu.c`:

```c
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>

#include <unistd.h>
#include <sys/syscall.h>

#include "../constants.h"
#include "../utils.h"
#include "common.h"

#include "kernelsu.h"

const char *ksu_manager_paths[] = {
  "/data/user_de/0/me.weishu.kernelsu",
  "/data/user_de/0/com.rifsxd.ksunext",
};

/* INFO: It would be presumed it is a unsigned int,
           so we need to cast it to signed int to
           avoid any potential UB.
*/
#define KSU_INSTALL_MAGIC1 (int)0xDEADBEEF
#define KSU_INSTALL_MAGIC2 (int)0xCAFEBABE

#define CMD_GET_VERSION 2
#define CMD_UID_GRANTED_ROOT 12
#define CMD_UID_SHOULD_UMOUNT 13
#define CMD_GET_MANAGER_UID 16
#define CMD_HOOK_MODE 0xC0DEAD1A

struct ksu_uid_granted_root_cmd {
  uint32_t uid;
  uint8_t granted;
};

struct ksu_uid_should_umount_cmd {
  uint32_t uid;
  uint8_t should_umount;
};

struct ksu_get_manager_uid_cmd {
  uint32_t uid;
};

struct ksu_set_feature_cmd {
  uint32_t feature_id;
  uint64_t value;
};

struct ksu_get_hook_mode_cmd {
	char mode[16];
};

#define KSU_IOCTL_UID_GRANTED_ROOT _IOC(_IOC_READ|_IOC_WRITE, 'K', 8, 0)
#define KSU_IOCTL_UID_SHOULD_UMOUNT _IOC(_IOC_READ|_IOC_WRITE, 'K', 9, 0)
#define KSU_IOCTL_GET_MANAGER_UID _IOC(_IOC_READ, 'K', 10, 0)
#define KSU_IOCTL_SET_FEATURE _IOC(_IOC_WRITE, 'K', 14, 0)

/* INFO: KernelSU-Next specific */
#define KSU_IOCTL_GET_HOOK_MODE _IOC(_IOC_READ, 'K', 98, 0)

static enum kernelsu_variants variant = KOfficial;

static int ksu_fd = -1;

static bool supports_manager_uid_retrieval = false;
static bool ksu_uses_new_ksuctl = false;

void ksu_get_existence(struct root_impl_state *state) {
  syscall(SYS_reboot, KSU_INSTALL_MAGIC1, KSU_INSTALL_MAGIC2, 0, (void *)&ksu_fd);
  if (ksu_fd == -1) {
    /* INFO: Perhaps it uses the old ksuctl interface */
    int reply_ok = 0;

    int version = 0;
    prctl(KSU_INSTALL_MAGIC1, CMD_GET_VERSION, &version, 0, &reply_ok);

    if (version == 0) state->state = Abnormal;
    else if (version >= MIN_KSU_VERSION) {
      /* INFO: Some custom kernels for custom ROMs have pre-installed KernelSU.
              Some users don't want to use KernelSU, but, for example, Magisk.
              This if allows this to happen, as it checks if "ksud" exists,
              which in case it doesn't, it won't be considered as supported. */
      struct stat s;
      if (stat("/data/adb/ksud", &s) == -1) {
        if (errno != ENOENT) {
          LOGE("Failed to stat KSU daemon: %s\n", strerror(errno));
        }
        errno = 0;
        state->state = Abnormal;

        return;
      }

      state->state = Supported;

      char mode[16] = { 0 };
      prctl(KSU_INSTALL_MAGIC1, CMD_HOOK_MODE, mode, NULL, &reply_ok);

      if (mode[0] != '\0') state->variant = KNext;
      else state->variant = KOfficial;

      variant = state->variant;

      /* INFO: CMD_GET_MANAGER_UID is a KernelSU Next feature, however we won't
                limit to KernelSU Next only in case other forks wish to implement
                it. */
      prctl(KSU_INSTALL_MAGIC1, CMD_GET_MANAGER_UID, NULL, NULL, &reply_ok);

      if (reply_ok == KSU_INSTALL_MAGIC1) {
        LOGI("KernelSU implementation supports CMD_GET_MANAGER_UID.\n");

        supports_manager_uid_retrieval = true;
      }
    }
    else if (version >= 1 && version <= MIN_KSU_VERSION - 1) state->state = TooOld;
    else state->state = Abnormal;

    return;
  }

  ksu_uses_new_ksuctl = true;

  struct ksu_set_feature_cmd cmd = {
    .feature_id = 1, /* INFO: kernel_umount */
    .value = 0
  };

  /* INFO: Tell KernelSU to not umount, and let us handle it */
  if (ioctl(ksu_fd, KSU_IOCTL_SET_FEATURE, &cmd) == -1) {
    LOGW("Failed to ioctl KSU_IOCTL_SET_FEATURE: %s\n", strerror(errno));

    /* INFO: Not a fatal error, just log and continue */
  }

  struct ksu_get_hook_mode_cmd hook_mode_cmd = { 0 };
  ioctl(ksu_fd, KSU_IOCTL_GET_HOOK_MODE, &hook_mode_cmd);

  if (hook_mode_cmd.mode[0] != '\0') state->variant = KNext;
  else state->variant = KOfficial;

  state->state = Supported;
}

bool ksu_uid_granted_root(uid_t uid) {
  if (!ksu_uses_new_ksuctl) {
    bool granted = false;
    uint32_t result = 0;
    prctl(KSU_INSTALL_MAGIC1, CMD_UID_GRANTED_ROOT, uid, &granted, &result);

    if ((int)result != KSU_INSTALL_MAGIC1) return false;

    return granted;
  }

  struct ksu_uid_granted_root_cmd cmd = {
    .uid = uid,
    .granted = 0
  };

  if (ioctl(ksu_fd, KSU_IOCTL_UID_GRANTED_ROOT, &cmd) == -1) {
    LOGE("Failed to ioctl KSU_IOCTL_UID_GRANTED_ROOT: %s\n", strerror(errno));

    return false;
  }

  return cmd.granted;
}

bool ksu_uid_should_umount(uid_t uid) {
  if (!ksu_uses_new_ksuctl) {
    bool should_umount = false;
    uint32_t result = 0;
    prctl(KSU_INSTALL_MAGIC1, CMD_UID_SHOULD_UMOUNT, uid, &should_umount, &result);

    if ((int)result != KSU_INSTALL_MAGIC1) return false;

    return should_umount;
  }

  struct ksu_uid_should_umount_cmd cmd = {
    .uid = uid,
    .should_umount = 0
  };

  if (ioctl(ksu_fd, KSU_IOCTL_UID_SHOULD_UMOUNT, &cmd) == -1) {
    LOGE("Failed to ioctl KSU_IOCTL_UID_SHOULD_UMOUNT: %s\n", strerror(errno));

    return false;
  }

  return cmd.should_umount;
}

bool ksu_uid_is_manager(uid_t uid) {
  /* INFO: If the manager UID is set, we can use it to check if the UID
             is the manager UID, which is more reliable than checking
             the KSU manager data directory, as spoofed builds of
             KernelSU Next have different package names.
  */
  if (!ksu_uses_new_ksuctl) {
    if (supports_manager_uid_retrieval) {
      int reply_ok = 0;

      uid_t manager_uid = 0;
      prctl(KSU_INSTALL_MAGIC1, CMD_GET_MANAGER_UID, &manager_uid, NULL, &reply_ok);

      return uid == manager_uid;
    }

    const char *manager_path = ksu_manager_paths[variant];
    struct stat s;
    if (stat(manager_path, &s) == -1) {
      if (errno != ENOENT) {
        LOGE("Failed to stat KSU manager data directory: %s\n", strerror(errno));
      }
      errno = 0;

      return false;
    }

    return s.st_uid == uid;
  }

  /* INFO: If it uses ioctl, it already has support to get manager UID operation */
  struct ksu_get_manager_uid_cmd cmd;
  if (ioctl(ksu_fd, KSU_IOCTL_GET_MANAGER_UID, &cmd) == -1) {
    LOGE("Failed to ioctl KSU_IOCTL_GET_MANAGER_UID: %s\n", strerror(errno));

    return false;
  }

  return uid == cmd.uid;
}

void ksu_cleanup(void) {
  if (ksu_fd != -1) {
    close(ksu_fd);
    ksu_fd = -1;
  }
}

```

`zygiskd/src/root_impl/kernelsu.h`:

```h
#ifndef KERNELSU_H
#define KERNELSU_H

#include "common.h"

enum kernelsu_variants {
  KOfficial,
  KNext,
  KNOVARIANT,
};

void ksu_get_existence(struct root_impl_state *state);

bool ksu_uid_granted_root(uid_t uid);

bool ksu_uid_should_umount(uid_t uid);

bool ksu_uid_is_manager(uid_t uid);

void ksu_cleanup(void);

#endif

```

`zygiskd/src/root_impl/magisk.c`:

```c
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <errno.h>

#include <unistd.h>

#include "../constants.h"
#include "../utils.h"
#include "common.h"

#include "magisk.h"

const char *supported_variants[] = {
  "kitsune"
};

const char *magisk_managers[] = {
  "com.topjohnwu.magisk",
  "io.github.huskydg.magisk"
};

#define SBIN_MAGISK lp_select("/sbin/magisk32", "/sbin/magisk64")
#define BITLESS_SBIN_MAGISK "/sbin/magisk"
#define DEBUG_RAMDISK_MAGISK lp_select("/debug_ramdisk/magisk32", "/debug_ramdisk/magisk64")
#define BITLESS_DEBUG_RAMDISK_MAGISK "/debug_ramdisk/magisk"

static enum magisk_variants variant = MOfficial;
/* INFO: Longest path */
static char path_to_magisk[sizeof(DEBUG_RAMDISK_MAGISK)] = { 0 };
bool is_using_sulist = false;

void magisk_get_existence(struct root_impl_state *state) {
  const char *magisk_files[] = {
    SBIN_MAGISK,
    BITLESS_SBIN_MAGISK,
    DEBUG_RAMDISK_MAGISK,
    BITLESS_DEBUG_RAMDISK_MAGISK
  };

  for (size_t i = 0; i < sizeof(magisk_files) / sizeof(magisk_files[0]); i++) {
    if (access(magisk_files[i], F_OK) != 0) {
      if (errno != ENOENT) {
        LOGE("Failed to access Magisk binary: %s\n", strerror(errno));
      }
      errno = 0;

      continue;
    }

    strcpy(path_to_magisk, magisk_files[i]);

    break;
  }

  if (path_to_magisk[0] == '\0') {
    state->state = Inexistent;

    return;
  }

  char *argv[4] = { "magisk", "-v", NULL, NULL };

  char magisk_info[128];
  if (!exec_command(magisk_info, sizeof(magisk_info), (const char *)path_to_magisk, argv)) {
    LOGE("Failed to execute magisk binary: %s\n", strerror(errno));
    errno = 0;

    state->state = Abnormal;

    return;
  }

  state->variant = (uint8_t)MOfficial;

  for (unsigned long i = 0; i < sizeof(supported_variants) / sizeof(supported_variants[0]); i++) {
    if (strstr(magisk_info, supported_variants[i])) {
      variant = (enum magisk_variants)(i + 1);
      state->variant = (uint8_t)variant;

      break;
    }
  }

  argv[1] = "-V";

  char magisk_version[32];
  if (!exec_command(magisk_version, sizeof(magisk_version), (const char *)path_to_magisk, argv)) {
    LOGE("Failed to execute magisk binary: %s\n", strerror(errno));
    errno = 0;

    state->state = Abnormal;

    return;
  }

  /* INFO: Magisk Kitsune has a feature called SuList, which is a whitelist of
             which processes are allowed to see root. Although only Kitsune has
             this option, there are Kitsune forks without "-kitsune" suffix, so
             to avoid excluding them from taking advantage of that feature, we
             will not check the variant.
  */
  argv[1] = "--sqlite";
  argv[2] = "select value from settings where key = 'sulist' limit 1";

  char sulist_enabled[32];
  if (!exec_command(sulist_enabled, sizeof(sulist_enabled), (const char *)path_to_magisk, argv)) {
    LOGE("Failed to execute magisk binary: %s\n", strerror(errno));
    errno = 0;

    state->state = Abnormal;

    return;
  }

  is_using_sulist = strcmp(sulist_enabled, "value=1") == 0;

  if (atoi(magisk_version) >= MIN_MAGISK_VERSION) state->state = Supported;
  else state->state = TooOld;
}

bool magisk_uid_granted_root(uid_t uid) {
  char sqlite_cmd[256];
  snprintf(sqlite_cmd, sizeof(sqlite_cmd), "select 1 from policies where uid=%d and policy=2 limit 1", uid);

  char *const argv[] = { "magisk", "--sqlite", sqlite_cmd, NULL };

  char result[32];
  if (!exec_command(result, sizeof(result), (const char *)path_to_magisk, argv)) {
    LOGE("Failed to execute magisk binary: %s\n", strerror(errno));
    errno = 0;

    return false;
  }

  return result[0] != '\0';
}

bool magisk_uid_should_umount(const char *const process) {
  /* INFO: PROCESS_NAME_MAX_LEN already has a +1 for NULL */
  char sqlite_cmd[51 + PROCESS_NAME_MAX_LEN];
  if (is_using_sulist)
    snprintf(sqlite_cmd, sizeof(sqlite_cmd), "SELECT 1 FROM sulist WHERE process=\"%s\" LIMIT 1", process);
  else /* INFO: Find if process string starts with any data in "process" column */
    snprintf(sqlite_cmd, sizeof(sqlite_cmd), "SELECT 1 FROM denylist WHERE \"%s\" LIKE process || '%%' LIMIT 1", process);

  char *const argv[] = { "magisk", "--sqlite", sqlite_cmd, NULL };

  char result[sizeof("1=1")];
  if (!exec_command(result, sizeof(result), (const char *)path_to_magisk, argv)) {
    LOGE("Failed to execute magisk binary: %s\n", strerror(errno));
    errno = 0;

    return false;
  }

  return is_using_sulist ? result[0] == '\0' : result[0] != '\0';
}

bool magisk_uid_is_manager(uid_t uid) {
  char *const argv[] = { "magisk", "--sqlite", "select value from strings where key=\"requester\" limit 1", NULL };

  char output[128];
  if (!exec_command(output, sizeof(output), (const char *)path_to_magisk, argv)) {
    LOGE("Failed to execute magisk binary: %s\n", strerror(errno));
    errno = 0;

    return false;
  }

  char stat_path[PATH_MAX];
  if (output[0] == '\0')
    snprintf(stat_path, sizeof(stat_path), "/data/user_de/0/%s", magisk_managers[(int)variant]);
  else
    snprintf(stat_path, sizeof(stat_path), "/data/user_de/0/%s", output + strlen("value="));

  struct stat s;
  if (stat(stat_path, &s) == -1) {
    LOGE("Failed to stat %s: %s\n", stat_path, strerror(errno));
    errno = 0;

    return false;
  }

  return s.st_uid == uid;
}

```

`zygiskd/src/root_impl/magisk.h`:

```h
#ifndef MAGISK_H
#define MAGISK_H

#include "common.h"

enum magisk_variants {
  MOfficial,
  MKitsune
};

void magisk_get_existence(struct root_impl_state *state);

bool magisk_uid_granted_root(uid_t uid);

bool magisk_uid_should_umount(const char *const process);

bool magisk_uid_is_manager(uid_t uid);

#endif

```

`zygiskd/src/utils.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <sys/sysmacros.h>
#include <sys/mount.h>

#include <unistd.h>
#include <linux/limits.h>
#include <sched.h>
#include <pthread.h>

#include <android/log.h>

#include "utils.h"
#include "root_impl/common.h"
#include "root_impl/kernelsu.h"
#include "root_impl/magisk.h"

int clean_namespace_fd = 0;
int mounted_namespace_fd = 0;

bool switch_mount_namespace(pid_t pid) {
  char path[PATH_MAX];
  snprintf(path, sizeof(path), "/proc/%d/ns/mnt", pid);

  int nsfd = open(path, O_RDONLY | O_CLOEXEC);
  if (nsfd == -1) {
    LOGE("Failed to open nsfd: %s\n", strerror(errno));

    return false;
  }

  if (setns(nsfd, CLONE_NEWNS) == -1) {
    LOGE("Failed to setns: %s\n", strerror(errno));

    close(nsfd);

    return false;
  }

  close(nsfd);

  return true;
}

int __system_property_get(const char *, char *);

void get_property(const char *restrict name, char *restrict output) {
  __system_property_get(name, output);
}

void set_socket_create_context(const char *restrict context) {
  char path[PATH_MAX];
  snprintf(path, PATH_MAX, "/proc/thread-self/attr/sockcreate");

  FILE *sockcreate = fopen(path, "w");
  if (sockcreate == NULL) {
    LOGE("Failed to open /proc/thread-self/attr/sockcreate: %s Now trying to via gettid().\n", strerror(errno));

    goto fail;
  }

  if (fwrite(context, 1, strlen(context), sockcreate) != strlen(context)) {
    LOGE("Failed to write to /proc/thread-self/attr/sockcreate: %s Now trying to via gettid().\n", strerror(errno));

    fclose(sockcreate);

    goto fail;
  }

  fclose(sockcreate);

  return;

  fail:
    snprintf(path, PATH_MAX, "/proc/self/task/%d/attr/sockcreate", gettid());

    sockcreate = fopen(path, "w");
    if (sockcreate == NULL) {
      LOGE("Failed to open %s: %s\n", path, strerror(errno));

      return;
    }

    if (fwrite(context, 1, strlen(context), sockcreate) != strlen(context)) {
      LOGE("Failed to write to %s: %s\n", path, strerror(errno));

      return;
    }

    fclose(sockcreate);
}

static void get_current_attr(char *restrict output, size_t size) {
  char path[PATH_MAX];
  snprintf(path, PATH_MAX, "/proc/self/attr/current");

  FILE *current = fopen(path, "r");
  if (current == NULL) {
    LOGE("fopen: %s\n", strerror(errno));

    return;
  }

  if (fread(output, 1, size, current) == 0)
    LOGE("fread: %s\n", strerror(errno));

  fclose(current);
}

void unix_datagram_sendto(const char *restrict path, const void *restrict buf, size_t len) {
  char current_attr[PATH_MAX];
  get_current_attr(current_attr, sizeof(current_attr));

  set_socket_create_context(current_attr);

  struct sockaddr_un addr;
  addr.sun_family = AF_UNIX;

  strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

  int socket_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
  if (socket_fd == -1) {
    LOGE("socket: %s\n", strerror(errno));

    return;
  }

  if (connect(socket_fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    LOGE("connect: %s\n", strerror(errno));

    return;
  }

  if (sendto(socket_fd, buf, len, 0, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    LOGE("sendto: %s\n", strerror(errno));

    return;
  }

  set_socket_create_context("u:r:zygote:s0");

  close(socket_fd);
}

int chcon(const char *restrict path, const char *context) {
  char command[PATH_MAX];
  snprintf(command, PATH_MAX, "chcon %s %s", context, path);

  return system(command);
}

int unix_listener_from_path(const char *restrict path) {
  if (remove(path) == -1 && errno != ENOENT) {
    LOGE("remove: %s\n", strerror(errno));

    return -1;
  }

  int socket_fd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (socket_fd == -1) {
    LOGE("socket: %s\n", strerror(errno));

    return -1;
  }

  struct sockaddr_un addr = {
    .sun_family = AF_UNIX
  };
  strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

  if (bind(socket_fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
    LOGE("bind: %s\n", strerror(errno));

    return -1;
  }

  if (listen(socket_fd, 2) == -1) {
    LOGE("listen: %s\n", strerror(errno));

    return -1;
  }

  if (chcon(path, "u:object_r:zygisk_file:s0") == -1) {
    LOGE("chcon: %s\n", strerror(errno));

    return -1;
  }

  return socket_fd;
}

ssize_t write_fd(int fd, int sendfd) {
  char cmsgbuf[CMSG_SPACE(sizeof(int))];
  char buf[1] = { 0 };

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = 1
  };

  struct msghdr msg = {
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = cmsgbuf,
    .msg_controllen = sizeof(cmsgbuf)
  };

  struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
  cmsg->cmsg_len = CMSG_LEN(sizeof(int));
  cmsg->cmsg_level = SOL_SOCKET;
  cmsg->cmsg_type = SCM_RIGHTS;

  memcpy(CMSG_DATA(cmsg), &sendfd, sizeof(int));

  ssize_t ret = sendmsg(fd, &msg, 0);
  if (ret == -1) {
    LOGE("sendmsg: %s\n", strerror(errno));

    return -1;
  }

  return ret;
}

int read_fd(int fd) {
  char cmsgbuf[CMSG_SPACE(sizeof(int))];

  int cnt = 1;
  struct iovec iov = {
    .iov_base = &cnt,
    .iov_len = sizeof(cnt)
  };

  struct msghdr msg = {
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = cmsgbuf,
    .msg_controllen = sizeof(cmsgbuf)
  };

  ssize_t ret = recvmsg(fd, &msg, MSG_WAITALL);
  if (ret == -1) {
    LOGE("recvmsg: %s\n", strerror(errno));

    return -1;
  }

  struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
  if (cmsg == NULL) {
    LOGE("CMSG_FIRSTHDR: %s\n", strerror(errno));

    return -1;
  }

  int sendfd;
  memcpy(&sendfd, CMSG_DATA(cmsg), sizeof(int));

  return sendfd;
}

#define write_func(type)                    \
  ssize_t write_## type(int fd, type val) { \
    return write(fd, &val, sizeof(type));   \
  }

#define read_func(type)                     \
  ssize_t read_## type(int fd, type *val) { \
    return read(fd, val, sizeof(type));     \
  }

write_func(size_t)
read_func(size_t)

write_func(uint32_t)
read_func(uint32_t)

write_func(uint8_t)
read_func(uint8_t)

ssize_t write_string(int fd, const char *restrict str) {
  size_t str_len = strlen(str);
  ssize_t written_bytes = write(fd, &str_len, sizeof(size_t));
  if (written_bytes != sizeof(size_t)) {
    LOGE("Failed to write string length: Not all bytes were written (%zd != %zu).\n", written_bytes, sizeof(size_t));

    return -1;
  }

  written_bytes = write(fd, str, str_len);
  if ((size_t)written_bytes != str_len) {
    LOGE("Failed to write string: Not all bytes were written.\n");

    return -1;
  }

  return written_bytes;
}

ssize_t read_string(int fd, char *restrict buf, size_t buf_size) {
  size_t str_len = 0;
  ssize_t read_bytes = read(fd, &str_len, sizeof(size_t));
  if (read_bytes != (ssize_t)sizeof(size_t)) {
    LOGE("Failed to read string length: Not all bytes were read (%zd != %zu).\n", read_bytes, sizeof(size_t));

    return -1;
  }

  if (str_len > buf_size - 1) {
    LOGE("Failed to read string: Buffer is too small (%zu > %zu - 1).\n", str_len, buf_size);

    return -1;
  }

  read_bytes = read(fd, buf, str_len);
  if (read_bytes != (ssize_t)str_len) {
    LOGE("Failed to read string: Promised bytes doesn't exist (%zd != %zu).\n", read_bytes, str_len);

    return -1;
  }

  if (str_len > 0) buf[str_len] = '\0';

  return read_bytes;
}

/* INFO: Cannot use restrict here as execv does not have restrict */
bool exec_command(char *restrict buf, size_t len, const char *restrict file, char *const argv[]) {
  int link[2];
  pid_t pid;

  if (pipe(link) == -1) {
    LOGE("pipe: %s\n", strerror(errno));

    return false;
  }

  if ((pid = fork()) == -1) {
    LOGE("fork: %s\n", strerror(errno));

    close(link[0]);
    close(link[1]);

    return false;
  }

  if (pid == 0) {
    dup2(link[1], STDOUT_FILENO);
    close(link[0]);
    close(link[1]);

    execv(file, argv);

    LOGE("execv failed: %s\n", strerror(errno));
    _exit(1);
  } else {
    close(link[1]);

    ssize_t nbytes = read(link[0], buf, len);
    if (nbytes > 0) buf[nbytes - 1] = '\0';
    /* INFO: If something went wrong, at least we must ensure it is NULL-terminated */
    else buf[0] = '\0';

    wait(NULL);

    close(link[0]);
  }

  return true;
}

bool check_unix_socket(int fd, bool block) {
  struct pollfd pfd = {
    .fd = fd,
    .events = POLLIN,
    .revents = 0
  };

  int timeout = block ? -1 : 0;
  poll(&pfd, 1, timeout);

  return pfd.revents & ~POLLIN ? false : true;
}

/* INFO: Cannot use restrict here as execv does not have restrict */
int non_blocking_execv(const char *restrict file, char *const argv[]) {
  int link[2];
  pid_t pid;

  if (pipe(link) == -1) {
    LOGE("pipe: %s\n", strerror(errno));

    return -1;
  }

  if ((pid = fork()) == -1) {
    LOGE("fork: %s\n", strerror(errno));

    return -1;
  }

  if (pid == 0) {
    dup2(link[1], STDOUT_FILENO);
    close(link[0]);
    close(link[1]);

    execv(file, argv);
  } else {
    close(link[1]);

    return link[0];
  }

  return -1;
}

void stringify_root_impl_name(struct root_impl impl, char *restrict output) {
  switch (impl.impl) {
    case None: {
      strcpy(output, "None");

      break;
    }
    case Multiple: {
      strcpy(output, "Multiple");

      break;
    }
    case KernelSU: {
      if (impl.variant == KOfficial) strcpy(output, "KernelSU");
      else strcpy(output, "KernelSU Next");

      break;
    }
    case APatch: {
      strcpy(output, "APatch");

      break;
    }
    case Magisk: {
      if (impl.variant == MOfficial) strcpy(output, "Magisk Official");
      else strcpy(output, "Magisk Kitsune");

      break;
    }
  }
}

struct mountinfo {
  unsigned int id;
  unsigned int parent;
  dev_t device;
  char *root;
  char *target;
  char *vfs_option;
  struct {
      unsigned int shared;
      unsigned int master;
      unsigned int propagate_from;
  } optional;
  char *type;
  char *source;
  char *fs_option;
};

struct mountinfos {
  struct mountinfo *mounts;
  size_t length;
};

char *strndup(const char *restrict str, size_t length) {
  char *restrict copy = malloc(length + 1);
  if (copy == NULL) return NULL;

  memcpy(copy, str, length);
  copy[length] = '\0';

  return copy;
}

void free_mounts(struct mountinfos *restrict mounts) {
  for (size_t i = 0; i < mounts->length; i++) {
    free(mounts->mounts[i].root);
    free(mounts->mounts[i].target);
    free(mounts->mounts[i].vfs_option);
    free(mounts->mounts[i].type);
    free(mounts->mounts[i].source);
    free(mounts->mounts[i].fs_option);
  }

  free(mounts->mounts);
}

bool parse_mountinfo(const char *restrict pid, struct mountinfos *restrict mounts) {
  char path[PATH_MAX];
  snprintf(path, PATH_MAX, "/proc/%s/mountinfo", pid);

  FILE *mountinfo = fopen(path, "r");
  if (mountinfo == NULL) {
    LOGE("fopen: %s\n", strerror(errno));

    return false;
  }

  char line[PATH_MAX];
  size_t i = 0;

  mounts->mounts = NULL;
  mounts->length = 0;

  while (fgets(line, sizeof(line), mountinfo) != NULL) {
    int root_start = 0, root_end = 0;
    int target_start = 0, target_end = 0;
    int vfs_option_start = 0, vfs_option_end = 0;
    int type_start = 0, type_end = 0;
    int source_start = 0, source_end = 0;
    int fs_option_start = 0, fs_option_end = 0;
    int optional_start = 0, optional_end = 0;
    unsigned int id, parent, maj, min;
    sscanf(line,
            "%u "           // (1) id
            "%u "           // (2) parent
            "%u:%u "        // (3) maj:min
            "%n%*s%n "      // (4) mountroot
            "%n%*s%n "      // (5) target
            "%n%*s%n"       // (6) vfs options (fs-independent)
            "%n%*[^-]%n - " // (7) optional fields
            "%n%*s%n "      // (8) FS type
            "%n%*s%n "      // (9) source
            "%n%*s%n",      // (10) fs options (fs specific)
            &id, &parent, &maj, &min, &root_start, &root_end, &target_start,
            &target_end, &vfs_option_start, &vfs_option_end,
            &optional_start, &optional_end, &type_start, &type_end,
            &source_start, &source_end, &fs_option_start, &fs_option_end);

    struct mountinfo *tmp_mounts = (struct mountinfo *)realloc(mounts->mounts, (i + 1) * sizeof(struct mountinfo));
    if (!tmp_mounts) {
      LOGE("Failed to allocate memory for mounts->mounts");

      goto cleanup_mount_allocs;
    }
    mounts->mounts = tmp_mounts;

    unsigned int shared = 0;
    unsigned int master = 0;
    unsigned int propagate_from = 0;
    if (strstr(line + optional_start, "shared:")) {
      shared = (unsigned int)atoi(strstr(line + optional_start, "shared:") + 7);
    }

    if (strstr(line + optional_start, "master:")) {
      master = (unsigned int)atoi(strstr(line + optional_start, "master:") + 7);
    }

    if (strstr(line + optional_start, "propagate_from:")) {
      propagate_from = (unsigned int)atoi(strstr(line + optional_start, "propagate_from:") + 15);
    }

    mounts->mounts[i].id = id;
    mounts->mounts[i].parent = parent;
    mounts->mounts[i].device = (dev_t)(makedev(maj, min));
    mounts->mounts[i].root = strndup(line + root_start, (size_t)(root_end - root_start));
    if (mounts->mounts[i].root == NULL) {
      LOGE("Failed to allocate memory for root\n");

      goto cleanup_mount_allocs;
    }
    mounts->mounts[i].target = strndup(line + target_start, (size_t)(target_end - target_start));
    if (mounts->mounts[i].target == NULL) {
      LOGE("Failed to allocate memory for target\n");

      goto cleanup_root;
    }
    mounts->mounts[i].vfs_option = strndup(line + vfs_option_start, (size_t)(vfs_option_end - vfs_option_start));
    if (mounts->mounts[i].vfs_option == NULL) {
      LOGE("Failed to allocate memory for vfs_option\n");

      goto cleanup_target;
    }
    mounts->mounts[i].optional.shared = shared;
    mounts->mounts[i].optional.master = master;
    mounts->mounts[i].optional.propagate_from = propagate_from;
    mounts->mounts[i].type = strndup(line + type_start, (size_t)(type_end - type_start));
    if (mounts->mounts[i].type == NULL) {
      LOGE("Failed to allocate memory for type\n");

      goto cleanup_vfs_option;
    }
    mounts->mounts[i].source = strndup(line + source_start, (size_t)(source_end - source_start));
    if (mounts->mounts[i].source == NULL) {
      LOGE("Failed to allocate memory for source\n");

      goto cleanup_type;
    }
    mounts->mounts[i].fs_option = strndup(line + fs_option_start, (size_t)(fs_option_end - fs_option_start));
    if (mounts->mounts[i].fs_option == NULL) {
      LOGE("Failed to allocate memory for fs_option\n");

      goto cleanup_source;
    }

    i++;

    continue;

    cleanup_source:
      free(mounts->mounts[i].source);
    cleanup_type:
      free(mounts->mounts[i].type);
    cleanup_vfs_option:
      free(mounts->mounts[i].vfs_option);
    cleanup_target:
      free(mounts->mounts[i].target);
    cleanup_root:
      free(mounts->mounts[i].root);
    cleanup_mount_allocs:
      fclose(mountinfo);
      free_mounts(mounts);

      return false;
  }

  fclose(mountinfo);

  mounts->length = i;

  return true;
}

bool umount_root(struct root_impl impl) {
  /* INFO: We are already in the target pid mount namespace, so actually,
             when we use self here, we meant its pid.
  */
  struct mountinfos mounts;
  if (!parse_mountinfo("self", &mounts)) {
    LOGE("Failed to parse mountinfo\n");

    return false;
  }

  /* INFO: "Magisk" is the longest word that will ever be put in source_name */
  char source_name[sizeof("magisk")];
  if (impl.impl == KernelSU) strcpy(source_name, "KSU");
  else if (impl.impl == APatch) strcpy(source_name, "APatch");
  else strcpy(source_name, "magisk");

  LOGI("[%s] Unmounting root", source_name);

  const char **targets_to_unmount = NULL;
  size_t num_targets = 0;

  for (size_t i = 0; i < mounts.length; i++) {
    struct mountinfo mount = mounts.mounts[i];

    bool should_unmount = false;
    if (strcmp(mount.source, source_name) == 0 || (impl.impl == Magisk && strcmp(mount.source, "worker") == 0)) should_unmount = true;
    if (strncmp(mount.target, "/data/adb/modules", strlen("/data/adb/modules")) == 0) should_unmount = true;
    if (strncmp(mount.root, "/adb/modules/", strlen("/adb/modules/")) == 0) should_unmount = true;

    if (!should_unmount) continue;

    num_targets++;
    targets_to_unmount = realloc(targets_to_unmount, num_targets * sizeof(char*));
    if (targets_to_unmount == NULL) {
      LOGE("[%s] Failed to allocate memory for targets_to_unmount\n", source_name);

      free(targets_to_unmount);
      free_mounts(&mounts);

      return false;
    }

    targets_to_unmount[num_targets - 1] = mount.target;
  }

  for (size_t i = num_targets; i > 0; i--) {
    const char *target = targets_to_unmount[i - 1];
    if (umount2(target, MNT_DETACH) == -1) {
      LOGE("[%s] Failed to unmount %s: %s\n", source_name, target, strerror(errno));
    } else {
      LOGI("[%s] Unmounted %s\n", source_name, target);
    }
  }
  free(targets_to_unmount);

  free_mounts(&mounts);

  return true;
}

int save_mns_fd(int pid, enum MountNamespaceState mns_state, struct root_impl impl) {
  if (mns_state == Clean && clean_namespace_fd != 0) return clean_namespace_fd;
  if (mns_state == Mounted && mounted_namespace_fd != 0) return mounted_namespace_fd;

  int sockets[2];
  if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) == -1) {
    LOGE("socketpair: %s\n", strerror(errno));

    return -1;
  }

  int socket_parent = sockets[0];
  int socket_child = sockets[1];

  pid_t fork_pid = fork();
  if (fork_pid < 0) {
    LOGE("fork: %s\n", strerror(errno));

    if (close(socket_parent) == -1)
      LOGE("Failed to close socket_parent: %s\n", strerror(errno));

    if (close(socket_child) == -1)
      LOGE("Failed to close socket_child: %s\n", strerror(errno));

    return -1;
  }

  if (fork_pid == 0) {
    close(socket_parent);

    if (switch_mount_namespace(pid) == false) {
      LOGE("Failed to switch mount namespace\n");

      if (write_uint8_t(socket_child, 0) == -1)
        LOGE("Failed to write to socket_child: %s\n", strerror(errno));

      goto finalize_mns_fork;
    }

    if (mns_state == Clean) {
      unshare(CLONE_NEWNS);

      if (!umount_root(impl)) {
        LOGE("Failed to umount root\n");

        if (write_uint8_t(socket_child, 0) == -1)
          LOGE("Failed to write to socket_child: %s\n", strerror(errno));

        goto finalize_mns_fork;
      }
    }

    if (write_uint8_t(socket_child, 1) == -1) {
      LOGE("Failed to write to socket_child: %s\n", strerror(errno));

      close(socket_child);

      _exit(1);
    }

    uint8_t has_opened = 0;
    if (read_uint8_t(socket_child, &has_opened) == -1)
      LOGE("Failed to read from socket_child: %s\n", strerror(errno));

    finalize_mns_fork:
      if (close(socket_child) == -1)
        LOGE("Failed to close socket_child: %s\n", strerror(errno));

      _exit(0);
  }

  close(socket_child);

  uint8_t has_succeeded = 0;
  if (read_uint8_t(socket_parent, &has_succeeded) == -1) {
    LOGE("Failed to read from socket_parent: %s\n", strerror(errno));

    close(socket_parent);

    return -1;
  }

  if (!has_succeeded) {
    LOGE("Failed to umount root\n");

    close(socket_parent);

    return -1;
  }

  char ns_path[PATH_MAX];
  snprintf(ns_path, PATH_MAX, "/proc/%d/ns/mnt", fork_pid);

  int ns_fd = open(ns_path, O_RDONLY);
  if (ns_fd == -1) {
    LOGE("open: %s\n", strerror(errno));

    close(socket_parent);

    return -1;
  }

  uint8_t opened_signal = 1;
  if (write_uint8_t(socket_parent, opened_signal) == -1) {
    LOGE("Failed to write to socket_parent: %s\n", strerror(errno));

    close(ns_fd);
    close(socket_parent);

    return -1;
  }

  if (close(socket_parent) == -1) {
    LOGE("Failed to close socket_parent: %s\n", strerror(errno));

    close(ns_fd);

    return -1;
  }

  if (waitpid(fork_pid, NULL, 0) == -1) {
    LOGE("waitpid: %s\n", strerror(errno));

    return -1;
  }

  if (impl.impl == Magisk && impl.variant == MKitsune && mns_state == Clean) {
    LOGI("[Magisk] Magisk Kitsune detected, will skip cache first.");

    /* INFO: MagiskSU of Kitsune has a special behavior: It is only mounted
               once system boots, because of that, we can only cache once
               that happens, or else it will clean the mounts, then later
               get MagiskSU mounted, resulting in a mount leak.

       SOURCES:
        - https://github.com/1q23lyc45/KitsuneMagisk/blob/8562a0b2ad142d21566c1ea41690ad64108ca14c/native/src/core/bootstages.cpp#L359
    */
    char boot_completed[2];
    get_property("sys.boot_completed", boot_completed);

    if (boot_completed[0] == '1') {
      LOGI("[Magisk] Appropriate mns found, caching clean namespace fd.");

      clean_namespace_fd = ns_fd;
    }

    /* BUG: For the case where it hasn't booted yet, we will need to
              keep creating mns that will be left behind, the issue is:
              they are not close'd. This is a problem, because we will
              have a leak of fds, although only from the period of booting.

            When trying to close the ns_fd from the libzygisk.so, fdsan
              will complain as it is owned by RandomAccessFile, and if
              we close from ReZygiskd, system will refuse to boot for
              some reason, even if we wait for setns in libzygisk.so,
              and that issue is related to setns, as it only happens
              with it.
    */

    return ns_fd;
  }

  if (mns_state == Clean) clean_namespace_fd = ns_fd;
  else if (mns_state == Mounted) mounted_namespace_fd = ns_fd;

  return ns_fd;
}

```

`zygiskd/src/utils.h`:

```h
#ifndef UTILS_H
#define UTILS_H

#include <stdio.h>
#include <sys/types.h>

#include "constants.h"
#include "root_impl/common.h"

#define CONCAT_(x,y) x##y
#define CONCAT(x,y) CONCAT_(x,y)

#define LOG_TAG lp_select("zygiskd32", "zygiskd64")

#define LOGI(...)                                              \
  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__); \
  printf(__VA_ARGS__)

#define LOGW(...)                                                \
  __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__);   \
  printf(__VA_ARGS__)

#define LOGE(...)                                                \
  __android_log_print(ANDROID_LOG_ERROR , LOG_TAG, __VA_ARGS__); \
  printf(__VA_ARGS__)

#define ASSURE_SIZE_WRITE(area_name, subarea_name, sent_size, expected_size)                                     \
  if (sent_size != (ssize_t)(expected_size)) {                                                                   \
    LOGE("Failed to sent " subarea_name " in " area_name ": Expected %zu, got %zd\n", expected_size, sent_size); \
                                                                                                                 \
    return;                                                                                                      \
  }

#define ASSURE_SIZE_READ(area_name, subarea_name, sent_size, expected_size)                                      \
  if (sent_size != (ssize_t)(expected_size)) {                                                                   \
    LOGE("Failed to read " subarea_name " in " area_name ": Expected %zu, got %zd\n", expected_size, sent_size); \
                                                                                                                 \
    return;                                                                                                      \
  }

#define ASSURE_SIZE_WRITE_BREAK(area_name, subarea_name, sent_size, expected_size)                               \
  if (sent_size != (ssize_t)(expected_size)) {                                                                   \
    LOGE("Failed to sent " subarea_name " in " area_name ": Expected %zu, got %zd\n", expected_size, sent_size); \
                                                                                                                 \
    break;                                                                                                       \
  }

#define ASSURE_SIZE_READ_BREAK(area_name, subarea_name, sent_size, expected_size)                                \
  if (sent_size != (ssize_t)(expected_size)) {                                                                   \
    LOGE("Failed to read " subarea_name " in " area_name ": Expected %zu, got %zd\n", expected_size, sent_size); \
                                                                                                                 \
    break;                                                                                                       \
  }

#define ASSURE_SIZE_WRITE_WR(area_name, subarea_name, sent_size, expected_size)                                  \
  if (sent_size != (ssize_t)(expected_size)) {                                                                   \
    LOGE("Failed to sent " subarea_name " in " area_name ": Expected %zu, got %zd\n", expected_size, sent_size); \
                                                                                                                 \
    return -1;                                                                                                   \
  }

#define ASSURE_SIZE_READ_WR(area_name, subarea_name, sent_size, expected_size)                                   \
  if (sent_size != (ssize_t)(expected_size)) {                                                                   \
    LOGE("Failed to read " subarea_name " in " area_name ": Expected %zu, got %zd\n", expected_size, sent_size); \
                                                                                                                 \
    return -1;                                                                                                   \
  }

#define IS_ISOLATED_SERVICE(uid)      \
  ((uid) >= 90000 && (uid) < 1000000)

#define write_func_def(type)              \
  ssize_t write_## type(int fd, type val)

#define read_func_def(type)               \
  ssize_t read_## type(int fd, type *val)

bool switch_mount_namespace(pid_t pid);

void get_property(const char *name, char *restrict output);

void set_socket_create_context(const char *restrict context);

void unix_datagram_sendto(const char *restrict path, const void *restrict buf, size_t len);

int chcon(const char *path, const char *restrict context);

int unix_listener_from_path(const char *path);

ssize_t write_fd(int fd, int sendfd);
int read_fd(int fd);

write_func_def(size_t);
read_func_def(size_t);

write_func_def(uint32_t);
read_func_def(uint32_t);

write_func_def(uint8_t);
read_func_def(uint8_t);

ssize_t write_string(int fd, const char *restrict str);

ssize_t read_string(int fd, char *restrict buf, size_t buf_size);

bool exec_command(char *restrict buf, size_t len, const char *restrict file, char *const argv[]);

bool check_unix_socket(int fd, bool block);

int non_blocking_execv(const char *restrict file, char *const argv[]);

void stringify_root_impl_name(struct root_impl impl, char *restrict output);

int save_mns_fd(int pid, enum MountNamespaceState mns_state, struct root_impl impl);

#endif /* UTILS_H */

```

`zygiskd/src/zygiskd.c`:

```c
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/sendfile.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>

#include <unistd.h>
#include <linux/limits.h>
#include <sys/syscall.h>
#include <linux/memfd.h>

#include <pthread.h>

#include "root_impl/common.h"
#include "constants.h"
#include "utils.h"

struct Module {
  char *name;
  int lib_fd;
  int companion;
};

struct Context {
  struct Module *modules;
  size_t len;
};

enum Architecture {
  ARM32,
  ARM64,
  X86,
  X86_64,
};

#define PATH_MODULES_DIR "/data/adb/modules"
#define TMP_PATH "/data/adb/rezygisk"
#define CONTROLLER_SOCKET TMP_PATH "/init_monitor"
#define PATH_CP_NAME TMP_PATH "/" lp_select("cp32.sock", "cp64.sock")
#define ZYGISKD_FILE PATH_MODULES_DIR "/rezygisk/bin/zygiskd" lp_select("32", "64")
#define ZYGISKD_PATH "/data/adb/modules/rezygisk/bin/zygiskd" lp_select("32", "64")

#ifdef __aarch64__
  #define ARCH_STR "arm64-v8a"
#elif __arm__
  #define ARCH_STR "armeabi-v7a"
#elif __x86_64__
  #define ARCH_STR "x86_64"
#elif __i386__
  #define ARCH_STR "x86"
#else
  #error "Unsupported architecture"
  #define ARCH_STR "unknown"
#endif

/* WARNING: Dynamic memory based */
static void load_modules(struct Context *restrict context) {
  context->len = 0;
  context->modules = NULL;

  DIR *dir = opendir(PATH_MODULES_DIR);
  if (dir == NULL) {
    LOGE("Failed opening modules directory: %s.", PATH_MODULES_DIR);

    return;
  }

  LOGI("Loading modules for architecture: " ARCH_STR);

  struct dirent *entry;
  while ((entry = readdir(dir)) != NULL) {
    if (entry->d_type != DT_DIR) continue; /* INFO: Only directories */
    if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0 || strcmp(entry->d_name, "rezygisk") == 0) continue;

    char *name = entry->d_name;
    char so_path[PATH_MAX];
    snprintf(so_path, PATH_MAX, "/data/adb/modules/%s/zygisk/" ARCH_STR ".so", name);

    struct stat st;
    if (stat(so_path, &st) == -1) {
      errno = 0;

      continue;
    }

    char disabled[PATH_MAX];
    snprintf(disabled, PATH_MAX, "/data/adb/modules/%s/disable", name);

    if (stat(disabled, &st) == -1) {
      if (errno != ENOENT) {
        LOGE("Failed checking if module `%s` is disabled: %s\n", name, strerror(errno));
        errno = 0;

        continue;
      }

      errno = 0;
    } else continue;

    int lib_fd = open(so_path, O_RDONLY | O_CLOEXEC);
    if (lib_fd == -1) {
      LOGE("Failed loading module `%s`\n", name);

      continue;
    }

    context->modules = realloc(context->modules, (context->len + 1) * sizeof(struct Module));
    if (context->modules == NULL) {
      LOGE("Failed reallocating memory for modules.\n");

      return;
    }

    context->modules[context->len].name = strdup(name);
    if (context->modules[context->len].name == NULL) {
      LOGE("Failed to strdup for the module `%s`: %s\n", name, strerror(errno));

      return;
    }
    context->modules[context->len].lib_fd = lib_fd;
    context->modules[context->len].companion = -1;
    context->len++;
  }

  closedir(dir);
}

static void free_modules(struct Context *restrict context) {
  for (size_t i = 0; i < context->len; i++) {
    free(context->modules[i].name);
    if (context->modules[i].companion >= 0) close(context->modules[i].companion);
  }

  free(context->modules);
}

static int create_daemon_socket(void) {
  set_socket_create_context("u:r:zygote:s0");

  return unix_listener_from_path(PATH_CP_NAME);
}

static int spawn_companion(char *restrict argv[], char *restrict name, int lib_fd) {
  int sockets[2];
  if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) == -1) {
    LOGE("Failed creating socket pair.\n");

    return -1;
  }

  int daemon_fd = sockets[0];
  int companion_fd = sockets[1];

  pid_t pid = fork();
  if (pid < 0) {
    LOGE("Failed forking companion: %s\n", strerror(errno));

    close(companion_fd);
    close(daemon_fd);

    exit(1);
  } else if (pid > 0) {
    close(companion_fd);

    int status = 0;
    waitpid(pid, &status, 0);

    if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
      if (write_string(daemon_fd, name) == -1) {
        LOGE("Failed writing module name.\n");

        close(daemon_fd);

        return -1;
      }
      if (write_fd(daemon_fd, lib_fd) == -1) {
        LOGE("Failed sending library fd.\n");

        close(daemon_fd);

        return -1;
      }

      uint8_t response = 0;
      ssize_t ret = read_uint8_t(daemon_fd, &response);
      if (ret <= 0) {
        LOGE("Failed reading companion response.\n");

        close(daemon_fd);

        return -1;
      }

      switch (response) {
        /* INFO: Even without any entry, we should still just deal with it */
        case 0: { return -2; }
        case 1: { return daemon_fd; }
        /* TODO: Should we be closing daemon socket here? (in non-0-and-1 case) */
        default: {
          return -1;
        }
      }
      /* TODO: Should we be closing daemon socket here? */
    } else {
      LOGE("Exited with status %d\n", status);

      return -1;
    }
  /* INFO: if pid == 0: */
  } else {
    /* INFO: There is no case where this will fail with a valid fd. */
    /* INFO: Remove FD_CLOEXEC flag to avoid closing upon exec */
    if (fcntl(companion_fd, F_SETFD, 0) == -1) {
      LOGE("Failed removing FD_CLOEXEC flag: %s\n", strerror(errno));

      close(companion_fd);
      close(daemon_fd);

      exit(1);
    }
  }

  char *process = argv[0];
  char nice_name[256];
  char *last = strrchr(process, '/');
  if (last == NULL) {
    snprintf(nice_name, sizeof(nice_name), "%s", process);
  } else {
    snprintf(nice_name, sizeof(nice_name), "%s", last + 1);
  }

  char process_name[256];
  snprintf(process_name, sizeof(process_name), "%s-%s", nice_name, name);

  char companion_fd_str[32];
  snprintf(companion_fd_str, sizeof(companion_fd_str), "%d", companion_fd);

  char *eargv[] = { process_name, "companion", companion_fd_str, NULL };
  if (non_blocking_execv(ZYGISKD_PATH, eargv) == -1) {
    LOGE("Failed executing companion: %s\n", strerror(errno));

    close(companion_fd);

    exit(1);
  }

  exit(0);
}

/* WARNING: Dynamic memory based */
void zygiskd_start(char *restrict argv[]) {
  /* INFO: When implementation is None or Multiple, it won't set the values
            for the context, causing it to have garbage values. In response
            to that, "= { 0 }" is used to ensure that the values are clean. */
  struct Context context = { 0 };

  struct root_impl impl;
  get_impl(&impl);
  if (impl.impl == None || impl.impl == Multiple) {
    unix_datagram_sendto(CONTROLLER_SOCKET, &(uint8_t){ DAEMON_SET_ERROR_INFO }, sizeof(uint8_t));

    const char *msg = NULL;
    if (impl.impl == None) msg = "Unsupported environment: Unknown root implementation";
    else msg = "Unsupported environment: Multiple root implementations found";

    LOGE("%s", msg);

    uint32_t msg_len = (uint32_t)strlen(msg);
    unix_datagram_sendto(CONTROLLER_SOCKET, &msg_len, sizeof(msg_len));
    unix_datagram_sendto(CONTROLLER_SOCKET, msg, msg_len);

    exit(EXIT_FAILURE);
  } else {
    load_modules(&context);

    unix_datagram_sendto(CONTROLLER_SOCKET, &(uint8_t){ DAEMON_SET_INFO }, sizeof(uint8_t));

    char impl_name[LONGEST_ROOT_IMPL_NAME];
    stringify_root_impl_name(impl, impl_name);

    uint32_t root_impl_len = (uint32_t)strlen(impl_name);
    unix_datagram_sendto(CONTROLLER_SOCKET, &root_impl_len, sizeof(root_impl_len));
    unix_datagram_sendto(CONTROLLER_SOCKET, impl_name, root_impl_len);

    uint32_t modules_len = (uint32_t)context.len;
    unix_datagram_sendto(CONTROLLER_SOCKET, &modules_len, sizeof(modules_len));

    for (size_t i = 0; i < context.len; i++) {
      uint32_t module_name_len = (uint32_t)strlen(context.modules[i].name);
      unix_datagram_sendto(CONTROLLER_SOCKET, &module_name_len, sizeof(module_name_len));
      unix_datagram_sendto(CONTROLLER_SOCKET, context.modules[i].name, module_name_len);
    }

    LOGI("Sent root implementation and modules information to controller socket");
  }

  int socket_fd = create_daemon_socket();
  if (socket_fd == -1) {
    LOGE("Failed creating daemon socket\n");

    free_modules(&context);

    root_impl_cleanup();

    return;
  }

  struct sigaction sa = { .sa_handler = SIG_IGN };
  sigaction(SIGPIPE, &sa, NULL);

  bool first_process = true;
  while (1) {
    int client_fd = accept(socket_fd, NULL, NULL);
    if (client_fd == -1) {
      LOGE("accept: %s\n", strerror(errno));

      break;
    }

    uint8_t action8 = 0;
    ssize_t len = read_uint8_t(client_fd, &action8);
    if (len == -1) {
      LOGE("read: %s\n", strerror(errno));

      break;
    } else if (len == 0) {
      LOGI("Client disconnected\n");

      break;
    }

    enum DaemonSocketAction action = (enum DaemonSocketAction)action8;

    switch (action) {
      case ZygoteInjected: {
        unix_datagram_sendto(CONTROLLER_SOCKET, &(uint8_t){ ZYGOTE_INJECTED }, sizeof(uint8_t));

        break;
      }
      case ZygoteRestart: {
        for (size_t i = 0; i < context.len; i++) {
          if (context.modules[i].companion <= -1) continue;

          close(context.modules[i].companion);
          context.modules[i].companion = -1;
        }

        break;
      }
      case SystemServerStarted: {
        unix_datagram_sendto(CONTROLLER_SOCKET, &(uint8_t){ SYSTEM_SERVER_STARTED }, sizeof(uint8_t));

        break;
      }
      case GetProcessFlags: {
        uint32_t uid = 0;
        ssize_t ret = read_uint32_t(client_fd, &uid);
        ASSURE_SIZE_READ_BREAK("GetProcessFlags", "uid", ret, sizeof(uid));

        /* INFO: Only used for Magisk, as it saves process names and not UIDs. */
        char process[PROCESS_NAME_MAX_LEN];
        ret = read_string(client_fd, process, sizeof(process));
        if (ret == -1) {
          LOGE("Failed reading process name.\n");

          break;
        }

        uint32_t flags = 0;
        if (first_process) {
          flags |= PROCESS_IS_FIRST_STARTED;

          first_process = false;
        } else {
          if (uid_is_manager(uid)) {
            flags |= PROCESS_IS_MANAGER;
          } else {
            if (uid_granted_root(uid)) {
              flags |= PROCESS_GRANTED_ROOT;
            }
            if (uid_should_umount(uid, (const char *const)process)) {
              flags |= PROCESS_ON_DENYLIST;
            }
          }
        }

        switch (impl.impl) {
          case None: { break; }
          case Multiple: { break; }
          case KernelSU: {
            flags |= PROCESS_ROOT_IS_KSU;

            break;
          }
          case APatch: {
            flags |= PROCESS_ROOT_IS_APATCH;

            break;
          }
          case Magisk: {
            flags |= PROCESS_ROOT_IS_MAGISK;

            break;
          }
        }

        ret = write_uint32_t(client_fd, flags);
        ASSURE_SIZE_WRITE_BREAK("GetProcessFlags", "flags", ret, sizeof(flags));

        break;
      }
      case GetInfo: {
        uint32_t flags = 0;

        switch (impl.impl) {
          case None: { break; }
          case Multiple: { break; }
          case KernelSU: {
            flags |= PROCESS_ROOT_IS_KSU;

            break;
          }
          case APatch: {
            flags |= PROCESS_ROOT_IS_APATCH;

            break;
          }
          case Magisk: {
            flags |= PROCESS_ROOT_IS_MAGISK;

            break;
          }
        }

        ssize_t ret = write_uint32_t(client_fd, flags);
        ASSURE_SIZE_WRITE_BREAK("GetInfo", "flags", ret, sizeof(flags));

        /* TODO: Use pid_t */
        uint32_t pid = (uint32_t)getpid();
        ret = write_uint32_t(client_fd, pid);
        ASSURE_SIZE_WRITE_BREAK("GetInfo", "pid", ret, sizeof(pid));

        size_t modules_len = context.len;
        ret = write_size_t(client_fd, modules_len);
        ASSURE_SIZE_WRITE_BREAK("GetInfo", "modules_len", ret, sizeof(modules_len));

        for (size_t i = 0; i < modules_len; i++) {
          ret = write_string(client_fd, context.modules[i].name);
          if (ret == -1) {
            LOGE("Failed writing module name.\n");

            break;
          }
        }

        break;
      }
      case ReadModules: {
        size_t clen = context.len;
        ssize_t ret = write_size_t(client_fd, clen);
        ASSURE_SIZE_WRITE_BREAK("ReadModules", "len", ret, sizeof(clen));

        for (size_t i = 0; i < clen; i++) {
          char lib_path[PATH_MAX];
          snprintf(lib_path, PATH_MAX, "/data/adb/modules/%s/zygisk/" ARCH_STR ".so", context.modules[i].name);

          if (write_string(client_fd, lib_path) == -1) {
            LOGE("Failed writing module path.\n");

            break;
          }
        }

        break;
      }
      case RequestCompanionSocket: {
        size_t index = 0;
        ssize_t ret = read_size_t(client_fd, &index);
        ASSURE_SIZE_READ_BREAK("RequestCompanionSocket", "index", ret, sizeof(index));

        if (index >= context.len) {
          LOGE("Invalid module index: %zu\n", index);

          ret = write_uint8_t(client_fd, 0);
          ASSURE_SIZE_WRITE_BREAK("RequestCompanionSocket", "response", ret, sizeof(uint8_t));

          close(client_fd);

          break;
        }

        struct Module *module = &context.modules[index];
        if (module->companion >= 0) {
          if (!check_unix_socket(module->companion, false)) {
            LOGE(" - Companion for module \"%s\" crashed\n", module->name);

            close(module->companion);
            module->companion = -1;
          }
        }

        if (module->companion <= -1) {
          module->companion = spawn_companion(argv, module->name, module->lib_fd);

          if (module->companion >= 0) {
            LOGI(" - Spawned companion for \"%s\": %d\n", module->name, module->companion);
          } else {
            if (module->companion == -2) {
              LOGE(" - No companion spawned for \"%s\" because it has no entry.\n", module->name);
            } else {
              LOGE(" - Failed to spawn companion for \"%s\": %s\n", module->name, strerror(errno));
            }
          }
        }

        /*
          INFO: Companion already exists or was created. In any way,
                 it should be in the while loop to receive fds now,
                 so just sending the file descriptor of the client is
                 safe.
        */
        if (module->companion >= 0) {
          LOGI(" - Sending companion fd socket of module \"%s\"\n", module->name);

          if (write_fd(module->companion, client_fd) == -1) {
            LOGE(" - Failed to send companion fd socket of module \"%s\"\n", module->name);

            ret = write_uint8_t(client_fd, 0);
            ASSURE_SIZE_WRITE_BREAK("RequestCompanionSocket", "response", ret, sizeof(uint8_t));

            close(module->companion);
            module->companion = -1;

            /* INFO: RequestCompanionSocket by default doesn't close the client_fd */
            close(client_fd);
          }
        } else {
          LOGE(" - Failed to spawn companion for module \"%s\"\n", module->name);

          ret = write_uint8_t(client_fd, 0);
          ASSURE_SIZE_WRITE_BREAK("RequestCompanionSocket", "response", ret, sizeof(uint8_t));

          /* INFO: RequestCompanionSocket by default doesn't close the client_fd */
          close(client_fd);
        }

        break;
      }
      case GetModuleDir: {
        size_t index = 0;
        ssize_t ret = read_size_t(client_fd, &index);
        ASSURE_SIZE_READ_BREAK("GetModuleDir", "index", ret, sizeof(index));

        if (index >= context.len) {
          LOGE("Invalid module index: %zu\n", index);

          ret = write_uint8_t(client_fd, 0);
          ASSURE_SIZE_WRITE_BREAK("GetModuleDir", "response", ret, sizeof(uint8_t));

          close(client_fd);

          break;
        }

        char module_dir[PATH_MAX];
        snprintf(module_dir, PATH_MAX, "%s/%s", PATH_MODULES_DIR, context.modules[index].name);

        int fd = open(module_dir, O_RDONLY);
        if (fd == -1) {
          LOGE("Failed opening module directory \"%s\": %s\n", module_dir, strerror(errno));

          break;
        }

        struct stat st;
        if (fstat(fd, &st) == -1) {
          LOGE("Failed getting module directory \"%s\" stats: %s\n", module_dir, strerror(errno));

          close(fd);

          break;
        }

        if (write_fd(client_fd, fd) == -1) {
          LOGE("Failed sending module directory \"%s\" fd: %s\n", module_dir, strerror(errno));

          close(fd);

          break;
        }

        break;
      }
      case UpdateMountNamespace: {
        pid_t pid = 0;
        ssize_t ret = read_uint32_t(client_fd, (uint32_t *)&pid);
        ASSURE_SIZE_READ_BREAK("UpdateMountNamespace", "pid", ret, sizeof(pid));

        uint8_t mns_state = 0;
        ret = read_uint8_t(client_fd, &mns_state);
        ASSURE_SIZE_READ_BREAK("UpdateMountNamespace", "mns_state", ret, sizeof(mns_state));

        uint32_t our_pid = (uint32_t)getpid();
        ret = write_uint32_t(client_fd, our_pid);
        ASSURE_SIZE_WRITE_BREAK("UpdateMountNamespace", "our_pid", ret, sizeof(our_pid));

        if ((enum MountNamespaceState)mns_state == Clean)
          save_mns_fd(pid, Mounted, impl);

        int ns_fd = save_mns_fd(pid, (enum MountNamespaceState)mns_state, impl);
        if (ns_fd == -1) {
          LOGE("Failed to save mount namespace fd for pid %d: %s\n", pid, strerror(errno));

          ret = write_uint32_t(client_fd, (uint32_t)0);
          ASSURE_SIZE_WRITE_BREAK("UpdateMountNamespace", "ns_fd", ret, sizeof(ns_fd));

          break;
        }

        ret = write_uint32_t(client_fd, (uint32_t)ns_fd);
        ASSURE_SIZE_WRITE_BREAK("UpdateMountNamespace", "ns_fd", ret, sizeof(ns_fd));

        break;
      }
    }

    if (action != RequestCompanionSocket) close(client_fd);

    continue;
  }

  close(socket_fd);
  free_modules(&context);
  root_impl_cleanup();
}

```

`zygiskd/src/zygiskd.h`:

```h
#ifndef ZYGISKD_H
#define ZYGISKD_H

void zygiskd_start(char *restrict argv[]);

#endif /* ZYGISKD_H */

```