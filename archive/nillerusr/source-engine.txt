Directory structure:
└── nillerusr-source-engine/
    ├── README.md
    ├── LICENSE
    ├── thirdpartylegalnotices.txt
    ├── app/
    │   └── legion/
    │       ├── basemenu.cpp
    │       ├── basemenu.h
    │       ├── gamemanager.cpp
    │       ├── gamemanager.h
    │       ├── heightfield.cpp
    │       ├── heightfield.h
    │       ├── hostgamemenu.cpp
    │       ├── inetworkmessagelistener.h
    │       ├── inputmanager.cpp
    │       ├── inputmanager.h
    │       ├── joingamemenu.cpp
    │       ├── legion.cpp
    │       ├── legion.h
    │       ├── legion.vcproj
    │       ├── mainmenu.cpp
    │       ├── menumanager.cpp
    │       ├── menumanager.h
    │       ├── networkmanager.cpp
    │       ├── networkmanager.h
    │       ├── networkmessages.cpp
    │       ├── networkmessages.h
    │       ├── physicsmanager.cpp
    │       ├── physicsmanager.h
    │       ├── rendermanager.cpp
    │       ├── rendermanager.h
    │       ├── uimanager.cpp
    │       ├── uimanager.h
    │       ├── worldmanager.cpp
    │       └── worldmanager.h
    ├── appframework/
    │   ├── appframework.vpc
    │   ├── AppSystemGroup.cpp
    │   ├── glmdisplaydb_linuxwin.inl
    │   ├── glmrendererinfo_osx.mm
    │   ├── posixapp.cpp
    │   ├── sdlmgr.cpp
    │   ├── VguiMatSysApp.cpp
    │   ├── WinApp.cpp
    │   └── wscript
    ├── bitmap/
    │   ├── bitmap.cpp
    │   ├── bitmap.vpc
    │   ├── colorconversion.cpp
    │   ├── float_bm.cpp
    │   ├── float_bm2.cpp
    │   ├── float_bm3.cpp
    │   ├── float_bm4.cpp
    │   ├── float_bm_bilateral_filter.cpp
    │   ├── float_cube.cpp
    │   ├── ImageByteSwap.cpp
    │   ├── imageformat.cpp
    │   ├── psd.cpp
    │   ├── resample.cpp
    │   ├── tgaloader.cpp
    │   ├── tgawriter.cpp
    │   └── wscript
    ├── choreoobjects/
    │   ├── choreoobjects.vpc
    │   └── wscript
    ├── common/
    │   ├── ClientNetMessage.cpp
    │   ├── ClientNetMessage.h
    │   ├── compiledcaptionswap.cpp
    │   ├── ConfigManager.cpp
    │   ├── ConfigManager.h
    │   ├── cserserverprotocol_engine.h
    │   ├── cstringhash.h
    │   ├── debug_dll_check.cpp
    │   ├── debug_lib_check.cpp
    │   ├── engine_launcher_api.h
    │   ├── FindSteamServers.h
    │   ├── hl2orange.spa.h
    │   ├── hl2orange.xml
    │   ├── IAdminServer.h
    │   ├── iappinformation.h
    │   ├── IFileSystemOpenDialog.h
    │   ├── igameserverdata.h
    │   ├── imageloadwrapper.cpp
    │   ├── imageloadwrapper.h
    │   ├── imageutils.cpp
    │   ├── imageutils.h
    │   ├── IManageServer.h
    │   ├── info_key.cpp
    │   ├── info_key.h
    │   ├── IObjectContainer.h
    │   ├── IRunGameEngine.h
    │   ├── IVguiModule.h
    │   ├── IVGuiModuleLoader.h
    │   ├── ivprofexport.h
    │   ├── jpegloader.cpp
    │   ├── jpegloader.h
    │   ├── jpegloader_common.cpp
    │   ├── language.cpp
    │   ├── language.h
    │   ├── lauxlib.h
    │   ├── lua.h
    │   ├── luaconf.h
    │   ├── lualib.h
    │   ├── netapi.cpp
    │   ├── netapi.h
    │   ├── netmessages.cpp
    │   ├── netmessages.h
    │   ├── pngloader.cpp
    │   ├── pngloader.h
    │   ├── proto_oob.h
    │   ├── proto_version.h
    │   ├── protocol.h
    │   ├── qlimits.h
    │   ├── randoverride.cpp
    │   ├── simplebitstring.cpp
    │   ├── simplebitstring.h
    │   ├── SourceAppInfo.cpp
    │   ├── SourceAppInfo.h
    │   ├── SteamAppStartup.cpp
    │   ├── SteamAppStartup.h
    │   ├── SteamBootStrapper.h
    │   ├── steamcommon.h
    │   ├── steamid.cpp
    │   ├── Steamlib.h
    │   ├── Steamlib_null.h
    │   ├── steamtypes.h
    │   ├── studiobyteswap.cpp
    │   ├── studiobyteswap.h
    │   ├── tgaloader.cpp
    │   ├── tgaloader.h
    │   ├── userid.h
    │   ├── ValidateNewValveCDKeyClient.h
    │   ├── valve_ipc_win32.h
    │   ├── ValveCDKeyGameAndTerritoryCodes.h
    │   ├── vtuneapi.h
    │   ├── android/
    │   │   ├── iconv.h
    │   │   └── freetype/
    │   │       ├── freetype.h
    │   │       ├── ftbbox.h
    │   │       ├── ftbdf.h
    │   │       ├── ftbitmap.h
    │   │       ├── ftcache.h
    │   │       ├── ftchapters.h
    │   │       ├── fterrdef.h
    │   │       ├── fterrors.h
    │   │       ├── ftgasp.h
    │   │       ├── ftglyph.h
    │   │       ├── ftgxval.h
    │   │       ├── ftgzip.h
    │   │       ├── ftimage.h
    │   │       ├── ftincrem.h
    │   │       ├── ftlcdfil.h
    │   │       ├── ftlist.h
    │   │       ├── ftlzw.h
    │   │       ├── ftmac.h
    │   │       ├── ftmm.h
    │   │       ├── ftmodapi.h
    │   │       ├── ftmoderr.h
    │   │       ├── ftotval.h
    │   │       ├── ftoutln.h
    │   │       ├── ftpfr.h
    │   │       ├── ftrender.h
    │   │       ├── ftsizes.h
    │   │       ├── ftsnames.h
    │   │       ├── ftstroke.h
    │   │       ├── ftsynth.h
    │   │       ├── ftsystem.h
    │   │       ├── fttrigon.h
    │   │       ├── fttypes.h
    │   │       ├── ftwinfnt.h
    │   │       ├── ftxf86.h
    │   │       ├── t1tables.h
    │   │       ├── ttnameid.h
    │   │       ├── tttables.h
    │   │       ├── tttags.h
    │   │       └── ttunpat.h
    │   ├── bugreporter/
    │   │   └── bugreporter.h
    │   ├── dx_proxy/
    │   │   └── dx_proxy.h
    │   ├── engine/
    │   │   ├── idownloadsystem.h
    │   │   └── requestcontext.h
    │   ├── GameUI/
    │   │   ├── cvarslider.cpp
    │   │   ├── cvarslider.h
    │   │   ├── IGameConsole.h
    │   │   ├── IGameUI.h
    │   │   ├── ObjectList.cpp
    │   │   ├── ObjectList.h
    │   │   ├── Random.cpp
    │   │   ├── Random.h
    │   │   ├── scriptobject.cpp
    │   │   └── scriptobject.h
    │   ├── GL/
    │   │   ├── gl.h
    │   │   ├── gl_mangle.h
    │   │   ├── glu.h
    │   │   └── glu_mangle.h
    │   ├── ihfx/
    │   │   ├── HFXConfig.h
    │   │   ├── IHFX.h
    │   │   ├── ihfxeffect.h
    │   │   ├── IHFXParam.h
    │   │   ├── types/
    │   │   │   ├── hfxvec3.h
    │   │   │   └── inl_hfxMath.h
    │   │   └── util/
    │   │       └── hfxinterfacehelper.h
    │   ├── lzma/
    │   │   └── lzma.h
    │   ├── movieobjects/
    │   │   └── timeutils.cpp
    │   ├── networksystem/
    │   │   ├── inetworkmessage.h
    │   │   └── inetworksystem.h
    │   ├── openal/
    │   │   └── alc.h
    │   ├── opengl/
    │   │   └── windows/
    │   │       └── gl.h
    │   ├── protobuf-2.3.0/
    │   │   └── src/
    │   │       └── google/
    │   │           └── protobuf/
    │   │               └── io/
    │   │                   └── coded_stream_unittest.cc
    │   ├── python/
    │   │   └── 2.5/
    │   │       ├── abstract.h
    │   │       ├── asdl.h
    │   │       ├── ast.h
    │   │       ├── bitset.h
    │   │       ├── boolobject.h
    │   │       ├── bufferobject.h
    │   │       ├── cellobject.h
    │   │       ├── ceval.h
    │   │       ├── classobject.h
    │   │       ├── cobject.h
    │   │       ├── code.h
    │   │       ├── codecs.h
    │   │       ├── compile.h
    │   │       ├── complexobject.h
    │   │       ├── cStringIO.h
    │   │       ├── datetime.h
    │   │       ├── descrobject.h
    │   │       ├── dictobject.h
    │   │       ├── enumobject.h
    │   │       ├── errcode.h
    │   │       ├── eval.h
    │   │       ├── fileobject.h
    │   │       ├── floatobject.h
    │   │       ├── frameobject.h
    │   │       ├── funcobject.h
    │   │       ├── genobject.h
    │   │       ├── graminit.h
    │   │       ├── grammar.h
    │   │       ├── import.h
    │   │       ├── intobject.h
    │   │       ├── intrcheck.h
    │   │       ├── iterobject.h
    │   │       ├── listobject.h
    │   │       ├── longintrepr.h
    │   │       ├── longobject.h
    │   │       ├── marshal.h
    │   │       ├── metagrammar.h
    │   │       ├── methodobject.h
    │   │       ├── modsupport.h
    │   │       ├── moduleobject.h
    │   │       ├── node.h
    │   │       ├── object.h
    │   │       ├── objimpl.h
    │   │       ├── opcode.h
    │   │       ├── osdefs.h
    │   │       ├── parsetok.h
    │   │       ├── patchlevel.h
    │   │       ├── pgen.h
    │   │       ├── pgenheaders.h
    │   │       ├── py_curses.h
    │   │       ├── pyarena.h
    │   │       ├── pyconfig.h
    │   │       ├── pydebug.h
    │   │       ├── pyerrors.h
    │   │       ├── pyexpat.h
    │   │       ├── pyfpe.h
    │   │       ├── pygetopt.h
    │   │       ├── pymactoolbox.h
    │   │       ├── pymem.h
    │   │       ├── pyport.h
    │   │       ├── pystate.h
    │   │       ├── pystrtod.h
    │   │       ├── Python-ast.h
    │   │       ├── Python.h
    │   │       ├── pythonrun.h
    │   │       ├── pythread.h
    │   │       ├── rangeobject.h
    │   │       ├── setobject.h
    │   │       ├── sliceobject.h
    │   │       ├── stringobject.h
    │   │       ├── structmember.h
    │   │       ├── structseq.h
    │   │       ├── swig_runtime.h
    │   │       ├── symtable.h
    │   │       ├── sysmodule.h
    │   │       ├── timefuncs.h
    │   │       ├── token.h
    │   │       ├── traceback.h
    │   │       ├── tupleobject.h
    │   │       ├── ucnhash.h
    │   │       ├── unicodeobject.h
    │   │       └── weakrefobject.h
    │   ├── quicktime_win32/
    │   │   ├── AE.h
    │   │   ├── AEDataModel.h
    │   │   ├── AEHelpers.h
    │   │   ├── AEInteraction.h
    │   │   ├── AEMach.h
    │   │   ├── AEObjects.h
    │   │   ├── AEPackObject.h
    │   │   ├── AERegistry.h
    │   │   ├── AEUserTermTypes.h
    │   │   ├── AIFF.h
    │   │   ├── Aliases.h
    │   │   ├── Appearance.h
    │   │   ├── AppleDiskPartitions.h
    │   │   ├── AppleEvents.h
    │   │   ├── AppleHelp.h
    │   │   ├── AppleScript.h
    │   │   ├── AppleTalk.h
    │   │   ├── ApplicationServices.h
    │   │   ├── ASDebugging.h
    │   │   ├── ASRegistry.h
    │   │   ├── AssertMacros.h
    │   │   ├── ATS.h
    │   │   ├── ATSFont.h
    │   │   ├── ATSLayoutTypes.h
    │   │   ├── ATSTypes.h
    │   │   ├── ATSUnicode.h
    │   │   ├── ATSUnicodeDirectAccess.h
    │   │   ├── ATSUnicodeFlattening.h
    │   │   ├── AvailabilityMacros.h
    │   │   ├── AVLTree.h
    │   │   ├── Balloons.h
    │   │   ├── Carbon.h
    │   │   ├── CarbonCore.h
    │   │   ├── CarbonEvents.h
    │   │   ├── CarbonEventsCore.h
    │   │   ├── CarbonSound.h
    │   │   ├── CFArray.h
    │   │   ├── CFBag.h
    │   │   ├── CFBase.h
    │   │   ├── CFBinaryHeap.h
    │   │   ├── CFBitVector.h
    │   │   ├── CFBundle.h
    │   │   ├── CFCharacterSet.h
    │   │   ├── CFData.h
    │   │   ├── CFDate.h
    │   │   ├── CFDictionary.h
    │   │   ├── CFMachPort.h
    │   │   ├── CFMessagePort.h
    │   │   ├── CFNetwork.h
    │   │   ├── CFNotificationCenter.h
    │   │   ├── CFNumber.h
    │   │   ├── CFPlugIn.h
    │   │   ├── CFPlugInCOM.h
    │   │   ├── CFPreferences.h
    │   │   ├── CFPropertyList.h
    │   │   ├── CFRunLoop.h
    │   │   ├── CFSet.h
    │   │   ├── CFSocket.h
    │   │   ├── CFStream.h
    │   │   ├── CFString.h
    │   │   ├── CFStringEncodingExt.h
    │   │   ├── CFTimeZone.h
    │   │   ├── CFTree.h
    │   │   ├── CFURL.h
    │   │   ├── CFURLAccess.h
    │   │   ├── CFUUID.h
    │   │   ├── CFXMLNode.h
    │   │   ├── CFXMLParser.h
    │   │   ├── CGAffineTransform.h
    │   │   ├── CGBase.h
    │   │   ├── CGBitmapContext.h
    │   │   ├── CGColorSpace.h
    │   │   ├── CGContext.h
    │   │   ├── CGDataConsumer.h
    │   │   ├── CGDataProvider.h
    │   │   ├── CGDirectDisplay.h
    │   │   ├── CGDirectPalette.h
    │   │   ├── CGError.h
    │   │   ├── CGFont.h
    │   │   ├── CGGeometry.h
    │   │   ├── CGImage.h
    │   │   ├── CGPattern.h
    │   │   ├── CGPDFContext.h
    │   │   ├── CGPDFDocument.h
    │   │   ├── CGRemoteOperation.h
    │   │   ├── CGWindowLevel.h
    │   │   ├── CMApplication.h
    │   │   ├── CMCalibrator.h
    │   │   ├── CMDeviceIntegration.h
    │   │   ├── CMICCProfile.h
    │   │   ├── CMMComponent.h
    │   │   ├── CMScriptingPlugin.h
    │   │   ├── CMTypes.h
    │   │   ├── CodeFragments.h
    │   │   ├── Collections.h
    │   │   ├── ColorPicker.h
    │   │   ├── ColorSync.h
    │   │   ├── CommonPanels.h
    │   │   ├── Components.h
    │   │   ├── conditionalmacros.h
    │   │   ├── ControlDefinitions.h
    │   │   ├── ControlManagerComponent.h
    │   │   ├── Controls.h
    │   │   ├── CoreAudioTypes.h
    │   │   ├── CoreFoundation.h
    │   │   ├── CoreGraphics.h
    │   │   ├── CoreServices.h
    │   │   ├── CoreVideo.h
    │   │   ├── CursorDevices.h
    │   │   ├── CVBase.h
    │   │   ├── CVBuffer.h
    │   │   ├── CVDirect3DBuffer.h
    │   │   ├── CVDirect3DBufferPool.h
    │   │   ├── CVDirect3DTexture.h
    │   │   ├── CVDirect3DTextureCache.h
    │   │   ├── CVHostTime.h
    │   │   ├── CVImageBuffer.h
    │   │   ├── CVPixelBuffer.h
    │   │   ├── CVPixelBufferPool.h
    │   │   ├── CVPixelFormatDescription.h
    │   │   ├── CVReturn.h
    │   │   ├── DateTimeUtils.h
    │   │   ├── Debugging.h
    │   │   ├── DeviceControl.h
    │   │   ├── Devices.h
    │   │   ├── Dialogs.h
    │   │   ├── Dictionary.h
    │   │   ├── DigitalHubRegistry.h
    │   │   ├── Displays.h
    │   │   ├── Drag.h
    │   │   ├── DrawSprocket.h
    │   │   ├── DriverServices.h
    │   │   ├── DriverSynchronization.h
    │   │   ├── Editions.h
    │   │   ├── Endian.h
    │   │   ├── Events.h
    │   │   ├── fenv.h
    │   │   ├── FindByContent.h
    │   │   ├── Finder.h
    │   │   ├── FinderRegistry.h
    │   │   ├── FixMath.h
    │   │   ├── Folders.h
    │   │   ├── FontPanel.h
    │   │   ├── Fonts.h
    │   │   ├── FontSync.h
    │   │   ├── fp.h
    │   │   ├── Gestalt.h
    │   │   ├── GXFonts.h
    │   │   ├── GXMath.h
    │   │   ├── GXTypes.h
    │   │   ├── Help.h
    │   │   ├── HFSVolumes.h
    │   │   ├── HIMovieView.h
    │   │   ├── HIObject.h
    │   │   ├── HIServices.h
    │   │   ├── HIShape.h
    │   │   ├── HITextUtils.h
    │   │   ├── HIToolbar.h
    │   │   ├── HIToolbox.h
    │   │   ├── HIView.h
    │   │   ├── HTMLRendering.h
    │   │   ├── IBCarbonRuntime.h
    │   │   ├── ICAApplication.h
    │   │   ├── ICACamera.h
    │   │   ├── ICADevice.h
    │   │   ├── Icons.h
    │   │   ├── IconStorage.h
    │   │   ├── ImageCapture.h
    │   │   ├── ImageCodec.h
    │   │   ├── InternetConfig.h
    │   │   ├── IntlResources.h
    │   │   ├── IsochronousDataHandler.h
    │   │   ├── JavaApplet.h
    │   │   ├── JavaControl.h
    │   │   ├── JavaEmbedding.h
    │   │   ├── Keyboards.h
    │   │   ├── Keychain.h
    │   │   ├── KeychainCore.h
    │   │   ├── KeychainHI.h
    │   │   ├── LangAnalysis.h
    │   │   ├── LanguageAnalysis.h
    │   │   ├── LaunchServices.h
    │   │   ├── ListManagerComponent.h
    │   │   ├── Lists.h
    │   │   ├── LowMem.h
    │   │   ├── MacApplication.h
    │   │   ├── MacErrors.h
    │   │   ├── MacHelp.h
    │   │   ├── MachineExceptions.h
    │   │   ├── MacLocales.h
    │   │   ├── MacMemory.h
    │   │   ├── MacTextEditor.h
    │   │   ├── MacTypes.h
    │   │   ├── MacWindows.h
    │   │   ├── Math64.h
    │   │   ├── MediaHandlers.h
    │   │   ├── Menus.h
    │   │   ├── MixedMode.h
    │   │   ├── MoviesFormat.h
    │   │   ├── Multiprocessing.h
    │   │   ├── MultiprocessingInfo.h
    │   │   ├── NameRegistry.h
    │   │   ├── Navigation.h
    │   │   ├── NavigationServices.h
    │   │   ├── Notification.h
    │   │   ├── NSL.h
    │   │   ├── NSLCore.h
    │   │   ├── NumberFormatting.h
    │   │   ├── OpenScripting.h
    │   │   ├── OpenTransport.h
    │   │   ├── OpenTransportProtocol.h
    │   │   ├── OpenTransportProviders.h
    │   │   ├── OSA.h
    │   │   ├── OSAComp.h
    │   │   ├── OSAGeneric.h
    │   │   ├── OSServices.h
    │   │   ├── OSUtils.h
    │   │   ├── OT.h
    │   │   ├── Packages.h
    │   │   ├── Palettes.h
    │   │   ├── Patches.h
    │   │   ├── PEFBinaryFormat.h
    │   │   ├── PictUtils.h
    │   │   ├── PLStringFuncs.h
    │   │   ├── PMApplication.h
    │   │   ├── PMCore.h
    │   │   ├── PMDefinitions.h
    │   │   ├── PMErrors.h
    │   │   ├── PMIOModule.h
    │   │   ├── PMPluginHeader.h
    │   │   ├── PMPrinterBrowsers.h
    │   │   ├── PMPrinterModule.h
    │   │   ├── PMPrintingDialogExtensions.h
    │   │   ├── PMRaster.h
    │   │   ├── PMTemplate.h
    │   │   ├── PMTicket.h
    │   │   ├── Power.h
    │   │   ├── Print.h
    │   │   ├── PrintCore.h
    │   │   ├── Printing.h
    │   │   ├── Processes.h
    │   │   ├── QD.h
    │   │   ├── QD3D.h
    │   │   ├── QD3DCamera.h
    │   │   ├── QD3DCustomElements.h
    │   │   ├── QD3DDrawContext.h
    │   │   ├── QD3DErrors.h
    │   │   ├── QD3DGeometry.h
    │   │   ├── QD3DGroup.h
    │   │   ├── QD3DIO.h
    │   │   ├── QD3DLight.h
    │   │   ├── QD3DMath.h
    │   │   ├── QD3DOld.h
    │   │   ├── QD3DPick.h
    │   │   ├── QD3DRenderer.h
    │   │   ├── QD3DSet.h
    │   │   ├── QD3DShader.h
    │   │   ├── QD3DStorage.h
    │   │   ├── QD3DString.h
    │   │   ├── QD3DStyle.h
    │   │   ├── QD3DTransform.h
    │   │   ├── QD3DView.h
    │   │   ├── QD3DViewer.h
    │   │   ├── QDOffscreen.h
    │   │   ├── QDPictToCGContext.h
    │   │   ├── QTLoadLibraryUtils.h
    │   │   ├── QTML.h
    │   │   ├── QTSMovie.h
    │   │   ├── QTStreamingComponents.h
    │   │   ├── Quickdraw.h
    │   │   ├── QuickdrawText.h
    │   │   ├── QuickTime.h
    │   │   ├── QuickTimeErrors.h
    │   │   ├── QuickTimeMusic.h
    │   │   ├── QuickTimeStreaming.h
    │   │   ├── QuickTimeVR.h
    │   │   ├── QuickTimeVRFormat.h
    │   │   ├── RAVE.h
    │   │   ├── ResourceForkComponent.h
    │   │   ├── Resources.h
    │   │   ├── Retrace.h
    │   │   ├── ROMDefs.h
    │   │   ├── ScalerStreamTypes.h
    │   │   ├── Scrap.h
    │   │   ├── Script.h
    │   │   ├── SCSI.h
    │   │   ├── SecurityCore.h
    │   │   ├── SecurityHI.h
    │   │   ├── SegLoad.h
    │   │   ├── SFNTLayoutTypes.h
    │   │   ├── SFNTTypes.h
    │   │   ├── Slots.h
    │   │   ├── Sound.h
    │   │   ├── SpeechRecognition.h
    │   │   ├── SpeechSynthesis.h
    │   │   ├── StandardFile.h
    │   │   ├── Streaming.h
    │   │   ├── StringCompare.h
    │   │   ├── Strings.h
    │   │   ├── SystemSound.h
    │   │   ├── TargetConditionals.h
    │   │   ├── TextCommon.h
    │   │   ├── TextEdit.h
    │   │   ├── TextEncodingConverter.h
    │   │   ├── TextEncodingPlugin.h
    │   │   ├── TextServices.h
    │   │   ├── TextUtils.h
    │   │   ├── Threads.h
    │   │   ├── Timer.h
    │   │   ├── ToolUtils.h
    │   │   ├── Translation.h
    │   │   ├── TranslationExtensions.h
    │   │   ├── Traps.h
    │   │   ├── TSMTE.h
    │   │   ├── TypeSelect.h
    │   │   ├── UnicodeConverter.h
    │   │   ├── UnicodeUtilities.h
    │   │   ├── URLAccess.h
    │   │   ├── UTCUtils.h
    │   │   ├── vBasicOps.h
    │   │   ├── vBigNum.h
    │   │   ├── vBLAS.h
    │   │   ├── vDSP.h
    │   │   ├── vecLib.h
    │   │   ├── vectorOps.h
    │   │   ├── vfp.h
    │   │   ├── Video.h
    │   │   ├── WebServicesCore.h
    │   │   ├── WSMethodInvocation.h
    │   │   ├── CoreFoundation/
    │   │   │   ├── CFArray.h
    │   │   │   ├── CFBase.h
    │   │   │   ├── CFCharacterSet.h
    │   │   │   ├── CFData.h
    │   │   │   ├── CFDictionary.h
    │   │   │   ├── CFLocale.h
    │   │   │   ├── CFNumber.h
    │   │   │   ├── CFString.h
    │   │   │   ├── CFStringEncodingExt.h
    │   │   │   └── CFURL.h
    │   │   └── GNUCompatibility/
    │   │       ├── stdbool.h
    │   │       └── stdint.h
    │   ├── replay/
    │   │   ├── basereplayserializeable.h
    │   │   ├── iclientreplay.h
    │   │   ├── iclientreplaycontext.h
    │   │   ├── iclientreplayhistorymanager.h
    │   │   ├── ienginereplay.h
    │   │   ├── iqueryablereplayitem.h
    │   │   ├── irecordingsession.h
    │   │   ├── irecordingsessionblockmanager.h
    │   │   ├── irecordingsessionmanager.h
    │   │   ├── ireplaycamera.h
    │   │   ├── ireplaycontext.h
    │   │   ├── ireplaydemoplayer.h
    │   │   ├── ireplayerrorsystem.h
    │   │   ├── ireplayfactory.h
    │   │   ├── ireplaymanager.h
    │   │   ├── ireplaymovie.h
    │   │   ├── ireplaymoviemanager.h
    │   │   ├── ireplaymovierenderer.h
    │   │   ├── ireplayperformancecontroller.h
    │   │   ├── ireplayperformanceeditor.h
    │   │   ├── ireplayperformancemanager.h
    │   │   ├── ireplayperformanceplaybackhandler.h
    │   │   ├── ireplayperformanceplayer.h
    │   │   ├── ireplayperformancerecorder.h
    │   │   ├── ireplayplayercache.h
    │   │   ├── ireplayrenderqueue.h
    │   │   ├── ireplayscreenshotmanager.h
    │   │   ├── ireplayscreenshotsystem.h
    │   │   ├── ireplayserializeable.h
    │   │   ├── ireplayserver.h
    │   │   ├── ireplaysessionrecorder.h
    │   │   ├── ireplaysystem.h
    │   │   ├── iserverengine.h
    │   │   ├── iserverreplay.h
    │   │   ├── iserverreplaycontext.h
    │   │   ├── performance.h
    │   │   ├── rendermovieparams.h
    │   │   ├── replay.h
    │   │   ├── replayhandle.h
    │   │   ├── replaylib.h
    │   │   ├── replaytime.h
    │   │   ├── replayutils.h
    │   │   ├── screenshot.h
    │   │   └── shared_defs.h
    │   ├── ServerBrowser/
    │   │   ├── blacklisted_server_manager.cpp
    │   │   ├── blacklisted_server_manager.h
    │   │   └── IServerBrowser.h
    │   ├── staticlink/
    │   │   ├── module.h
    │   │   └── system.h
    │   ├── vgui/
    │   │   ├── vgui_basebudgetpanel.cpp
    │   │   ├── vgui_basebudgetpanel.h
    │   │   ├── vgui_budgetbargraphpanel.cpp
    │   │   ├── vgui_budgetbargraphpanel.h
    │   │   ├── vgui_budgethistorypanel.cpp
    │   │   ├── vgui_budgethistorypanel.h
    │   │   ├── vgui_budgetpanelshared.cpp
    │   │   └── vgui_budgetpanelshared.h
    │   ├── vgui_surfacelib/
    │   │   ├── BitmapFont.h
    │   │   ├── FontAmalgam.h
    │   │   ├── FontManager.h
    │   │   ├── linuxfont.h
    │   │   ├── osxfont.h
    │   │   ├── vguifont.h
    │   │   └── Win32Font.h
    │   └── xbox/
    │       ├── xbox_console.h
    │       ├── xbox_core.h
    │       ├── xbox_launch.h
    │       ├── xbox_vxconsole.h
    │       ├── xbox_win32stubs.h
    │       └── xboxstubs.h
    ├── datacache/
    │   ├── datacache.cpp
    │   ├── datacache.h
    │   ├── datacache.vpc
    │   ├── datacache_common.h
    │   ├── mdlcache.cpp
    │   ├── wscript
    │   └── xbox/
    │       └── xbox.def
    ├── datamodel/
    │   ├── clipboardmanager.cpp
    │   ├── clipboardmanager.h
    │   ├── datamodel.cpp
    │   ├── datamodel.h
    │   ├── datamodel.vpc
    │   ├── dependencygraph.cpp
    │   ├── dependencygraph.h
    │   ├── dmattribute.cpp
    │   ├── dmattributeinternal.h
    │   ├── dmelement.cpp
    │   ├── dmelementdictionary.cpp
    │   ├── dmelementdictionary.h
    │   ├── dmelementfactoryhelper.cpp
    │   ├── DmElementFramework.cpp
    │   ├── DmElementFramework.h
    │   ├── dmserializerbinary.cpp
    │   ├── dmserializerbinary.h
    │   ├── dmserializerkeyvalues.cpp
    │   ├── dmserializerkeyvalues.h
    │   ├── dmserializerkeyvalues2.cpp
    │   ├── dmserializerkeyvalues2.h
    │   ├── undomanager.cpp
    │   ├── undomanager.h
    │   └── wscript
    ├── dedicated/
    │   ├── dedicated.h
    │   ├── dedicated.rc
    │   ├── dedicated.vpc
    │   ├── filesystem.cpp
    │   ├── isys.h
    │   ├── resource.h
    │   ├── sys_common.cpp
    │   ├── sys_ded.cpp
    │   ├── sys_linux.cpp
    │   ├── sys_windows.cpp
    │   ├── wscript
    │   ├── console/
    │   │   ├── conproc.cpp
    │   │   ├── conproc.h
    │   │   ├── textconsole.cpp
    │   │   ├── textconsole.h
    │   │   ├── TextConsoleUnix.cpp
    │   │   ├── TextConsoleUnix.h
    │   │   ├── TextConsoleWin32.cpp
    │   │   └── TextConsoleWin32.h
    │   └── vgui/
    │       ├── CreateMultiplayerGameServerPage.cpp
    │       ├── CreateMultiplayerGameServerPage.h
    │       ├── MainPanel.cpp
    │       ├── MainPanel.h
    │       ├── vguihelpers.cpp
    │       ├── vguihelpers.h
    │       └── vguihelpers_linux.cpp
    ├── dedicated_main/
    │   ├── dedicated_main.rc
    │   ├── dedicated_main.vpc
    │   ├── main.cpp
    │   ├── resource.h
    │   └── wscript
    ├── devtools/
    │   ├── AddFunctionPrologue.py
    │   ├── base.xcconfig
    │   ├── build_solution_remote.py
    │   ├── CheckSurfaceProps.py
    │   ├── debug.xcconfig
    │   ├── DisableAppVerifier.bat
    │   ├── DisableSrcdsAppVerifier.bat
    │   ├── dlexer.py
    │   ├── EnableAppVerifier.bat
    │   ├── EnableSrcdsAppVerifier.bat
    │   ├── FindClasses.py
    │   ├── fix_tlog.py
    │   ├── fix_tlogs.bat
    │   ├── GDPerf.sys
    │   ├── gendbg.sh
    │   ├── makefile_base_posix.mak
    │   ├── makemissinganims.pl
    │   ├── mat_check.pl
    │   ├── matcheck_dod.bat
    │   ├── p4debugscan.py
    │   ├── p4EditChangelist.py
    │   ├── p4helpers.py
    │   ├── p4sizes.py
    │   ├── p4submit.py
    │   ├── parse_analyze_errors.py
    │   ├── PME.reg
    │   ├── PMELib.htm
    │   ├── release.xcconfig
    │   ├── search_and_replace_template.py
    │   ├── shotmaker.pl
    │   ├── sourcesdk_def.mak
    │   ├── srcdsAppVerifierSettings.reg
    │   ├── steam_def.mak
    │   ├── tf2AppVerifierSettings.reg
    │   ├── vcodepickle.py
    │   ├── version_script.linux.txt
    │   ├── WildcardSearch.py
    │   ├── analyzeconfig/
    │   │   └── __init__.py
    │   ├── dbmon/
    │   │   ├── dbmon.c
    │   │   └── dbmon.vpc
    │   ├── devstudio macros/
    │   │   ├── autoexp.dat
    │   │   ├── comments.dsm
    │   │   └── usertype.dat
    │   ├── devstudio templates/
    │   │   ├── valvelib.awx
    │   │   └── valvelib.hlp
    │   ├── diffmemstats/
    │   │   ├── diffmemstats.cpp
    │   │   ├── diffmemstats.sln
    │   │   └── diffmemstats.vpc
    │   ├── ep2_deathmap/
    │   │   ├── ep2_deathmap.cpp
    │   │   └── ep2_deathmap.vpc
    │   ├── getmirror/
    │   │   ├── getmirror.cpp
    │   │   ├── getmirror.vpc
    │   │   ├── StdAfx.cpp
    │   │   ├── StdAfx.h
    │   │   └── syncfrommirror.bat
    │   ├── goldsrc_port_scripts/
    │   │   ├── find_game_sounds.py
    │   │   ├── goldsrc_qc_9way_blends.py
    │   │   ├── port_models.py
    │   │   ├── PySourceSafe.py
    │   │   ├── qc_origin_fix.py
    │   │   ├── VisitFiles.py
    │   │   └── WildcardSearch.py
    │   ├── macros/
    │   │   ├── EnvironmentEvents.VB
    │   │   ├── Module1.VB
    │   │   ├── Perforce.VB
    │   │   ├── Valve.VB
    │   │   ├── Valve.vsmacros
    │   │   ├── Valve.vsmproj
    │   │   ├── Valve.vsmprojex
    │   │   ├── Valve.vsmprojey
    │   │   ├── Valve2005.VB
    │   │   └── Valve2005.vsmacros
    │   ├── mapbuild/
    │   │   ├── readme.txt
    │   │   ├── buildall.bat
    │   │   ├── buildMaps.pl
    │   │   ├── buildmod.bat
    │   │   └── syncChangedMaps.pl
    │   ├── processgamestats/
    │   │   ├── base_gamestats_parse.h
    │   │   ├── cs_gamestats.h
    │   │   ├── cstrike_gamestats_parse.cpp
    │   │   ├── ep2_gamestats_parse.cpp
    │   │   ├── processgamestats.cpp
    │   │   ├── processgamestats.vpc
    │   │   ├── StdAfx.cpp
    │   │   ├── StdAfx.h
    │   │   └── tf_gamestats_parse.cpp
    │   ├── smtpmail/
    │   │   ├── simplesocket.cpp
    │   │   ├── simplesocket.h
    │   │   ├── smtpmail.cpp
    │   │   └── smtpmail.vpc
    │   ├── swigwin-1.3.34/
    │   │   ├── foo.bat
    │   │   └── Lib/
    │   │       ├── allkw.swg
    │   │       ├── attribute.i
    │   │       ├── carrays.i
    │   │       ├── cdata.i
    │   │       ├── cmalloc.i
    │   │       ├── constraints.i
    │   │       ├── cpointer.i
    │   │       ├── cstring.i
    │   │       ├── cwstring.i
    │   │       ├── exception.i
    │   │       ├── inttypes.i
    │   │       ├── linkruntime.c
    │   │       ├── math.i
    │   │       ├── pointer.i
    │   │       ├── runtime.swg
    │   │       ├── shared_ptr.i
    │   │       ├── std_except.i
    │   │       ├── stdint.i
    │   │       ├── stl.i
    │   │       ├── swig.swg
    │   │       ├── swigarch.i
    │   │       ├── swigerrors.swg
    │   │       ├── swiginit.swg
    │   │       ├── swiglabels.swg
    │   │       ├── swigrun.i
    │   │       ├── swigrun.swg
    │   │       ├── swigwarn.swg
    │   │       ├── swigwarnings.swg
    │   │       ├── wchar.i
    │   │       ├── windows.i
    │   │       ├── allegrocl/
    │   │       │   ├── allegrocl.swg
    │   │       │   ├── inout_typemaps.i
    │   │       │   ├── longlongs.i
    │   │       │   ├── std_list.i
    │   │       │   ├── std_string.i
    │   │       │   └── typemaps.i
    │   │       ├── cffi/
    │   │       │   └── cffi.swg
    │   │       ├── chicken/
    │   │       │   ├── chicken.swg
    │   │       │   ├── chickenkw.swg
    │   │       │   ├── chickenrun.swg
    │   │       │   ├── extra-install.list
    │   │       │   ├── multi-generic.scm
    │   │       │   ├── std_string.i
    │   │       │   ├── swigclosprefix.scm
    │   │       │   ├── tinyclos-multi-generic.patch
    │   │       │   └── typemaps.i
    │   │       ├── clisp/
    │   │       │   └── clisp.swg
    │   │       ├── csharp/
    │   │       │   ├── boost_shared_ptr.i
    │   │       │   ├── csharp.swg
    │   │       │   ├── csharphead.swg
    │   │       │   ├── csharpkw.swg
    │   │       │   ├── director.swg
    │   │       │   ├── enums.swg
    │   │       │   ├── enumsimple.swg
    │   │       │   ├── enumtypesafe.swg
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── std_wstring.i
    │   │       │   ├── stl.i
    │   │       │   ├── typemaps.i
    │   │       │   └── wchar.i
    │   │       ├── gcj/
    │   │       │   ├── cni.i
    │   │       │   ├── cni.swg
    │   │       │   └── javaprims.i
    │   │       ├── guile/
    │   │       │   ├── common.scm
    │   │       │   ├── cplusplus.i
    │   │       │   ├── extra-install.list
    │   │       │   ├── ghinterface.i
    │   │       │   ├── guile.i
    │   │       │   ├── guile_gh.swg
    │   │       │   ├── guile_gh_run.swg
    │   │       │   ├── guile_scm.swg
    │   │       │   ├── guile_scm_run.swg
    │   │       │   ├── guilemain.i
    │   │       │   ├── interpreter.i
    │   │       │   ├── list-vector.i
    │   │       │   ├── Makefile
    │   │       │   ├── pointer-in-out.i
    │   │       │   ├── ports.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   ├── swigrun.i
    │   │       │   └── typemaps.i
    │   │       ├── java/
    │   │       │   ├── arrays_java.i
    │   │       │   ├── boost_shared_ptr.i
    │   │       │   ├── director.swg
    │   │       │   ├── enums.swg
    │   │       │   ├── enumsimple.swg
    │   │       │   ├── enumtypesafe.swg
    │   │       │   ├── enumtypeunsafe.swg
    │   │       │   ├── java.swg
    │   │       │   ├── javahead.swg
    │   │       │   ├── javakw.swg
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── std_wstring.i
    │   │       │   ├── stl.i
    │   │       │   ├── typemaps.i
    │   │       │   └── various.i
    │   │       ├── lua/
    │   │       │   ├── _std_common.i
    │   │       │   ├── carrays.i
    │   │       │   ├── lua.swg
    │   │       │   ├── lua_fnptr.i
    │   │       │   ├── luarun.swg
    │   │       │   ├── luaruntime.swg
    │   │       │   ├── luatypemaps.swg
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   ├── typemaps.i
    │   │       │   └── wchar.i
    │   │       ├── modula3/
    │   │       │   ├── modula3.swg
    │   │       │   ├── modula3head.swg
    │   │       │   └── typemaps.i
    │   │       ├── mzscheme/
    │   │       │   ├── Makefile
    │   │       │   ├── mzrun.swg
    │   │       │   ├── mzscheme.swg
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   └── typemaps.i
    │   │       ├── ocaml/
    │   │       │   ├── carray.i
    │   │       │   ├── class.swg
    │   │       │   ├── cstring.i
    │   │       │   ├── director.swg
    │   │       │   ├── extra-install.list
    │   │       │   ├── libswigocaml.h
    │   │       │   ├── ocaml.i
    │   │       │   ├── ocaml.swg
    │   │       │   ├── ocamldec.swg
    │   │       │   ├── ocamlkw.swg
    │   │       │   ├── preamble.swg
    │   │       │   ├── std_common.i
    │   │       │   ├── std_complex.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_list.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   ├── swig.ml
    │   │       │   ├── swig.mli
    │   │       │   ├── swigp4.ml.in
    │   │       │   ├── typecheck.i
    │   │       │   ├── typemaps.i
    │   │       │   └── typeregister.swg
    │   │       ├── perl5/
    │   │       │   ├── attribute.i
    │   │       │   ├── carrays.i
    │   │       │   ├── cdata.i
    │   │       │   ├── cmalloc.i
    │   │       │   ├── cni.i
    │   │       │   ├── cpointer.i
    │   │       │   ├── cstring.i
    │   │       │   ├── exception.i
    │   │       │   ├── extra-install.list
    │   │       │   ├── factory.i
    │   │       │   ├── jstring.i
    │   │       │   ├── Makefile.in
    │   │       │   ├── Makefile.pl
    │   │       │   ├── noembed.h
    │   │       │   ├── perl5.swg
    │   │       │   ├── perlerrors.swg
    │   │       │   ├── perlfragments.swg
    │   │       │   ├── perlhead.swg
    │   │       │   ├── perlinit.swg
    │   │       │   ├── perlkw.swg
    │   │       │   ├── perlmacros.swg
    │   │       │   ├── perlmain.i
    │   │       │   ├── perlopers.swg
    │   │       │   ├── perlprimtypes.swg
    │   │       │   ├── perlrun.swg
    │   │       │   ├── perlruntime.swg
    │   │       │   ├── perlstrings.swg
    │   │       │   ├── perltypemaps.swg
    │   │       │   ├── perluserdir.swg
    │   │       │   ├── reference.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_list.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   └── typemaps.i
    │   │       ├── php4/
    │   │       │   ├── const.i
    │   │       │   ├── globalvar.i
    │   │       │   ├── php4.swg
    │   │       │   ├── php4init.swg
    │   │       │   ├── php4kw.swg
    │   │       │   ├── php4run.swg
    │   │       │   ├── phppointers.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   ├── typemaps.i
    │   │       │   └── utils.i
    │   │       ├── pike/
    │   │       │   ├── pike.swg
    │   │       │   ├── pikekw.swg
    │   │       │   ├── pikerun.swg
    │   │       │   └── std_string.i
    │   │       ├── python/
    │   │       │   ├── README
    │   │       │   ├── argcargv.i
    │   │       │   ├── attribute.i
    │   │       │   ├── boost_shared_ptr.i
    │   │       │   ├── carrays.i
    │   │       │   ├── ccomplex.i
    │   │       │   ├── cdata.i
    │   │       │   ├── cmalloc.i
    │   │       │   ├── cni.i
    │   │       │   ├── complex.i
    │   │       │   ├── cpointer.i
    │   │       │   ├── cstring.i
    │   │       │   ├── cwstring.i
    │   │       │   ├── defarg.swg
    │   │       │   ├── director.swg
    │   │       │   ├── embed.i
    │   │       │   ├── embed15.i
    │   │       │   ├── exception.i
    │   │       │   ├── factory.i
    │   │       │   ├── file.i
    │   │       │   ├── implicit.i
    │   │       │   ├── jstring.i
    │   │       │   ├── Makefile.in
    │   │       │   ├── pyapi.swg
    │   │       │   ├── pybackward.swg
    │   │       │   ├── pyclasses.swg
    │   │       │   ├── pycomplex.swg
    │   │       │   ├── pycontainer.swg
    │   │       │   ├── pydocs.swg
    │   │       │   ├── pyerrors.swg
    │   │       │   ├── pyfragments.swg
    │   │       │   ├── pyhead.swg
    │   │       │   ├── pyinit.swg
    │   │       │   ├── pyiterators.swg
    │   │       │   ├── pymacros.swg
    │   │       │   ├── pyopers.swg
    │   │       │   ├── pyprimtypes.swg
    │   │       │   ├── pyrun.swg
    │   │       │   ├── pyruntime.swg
    │   │       │   ├── pystdcommon.swg
    │   │       │   ├── pystrings.swg
    │   │       │   ├── python.swg
    │   │       │   ├── pythonkw.swg
    │   │       │   ├── pythreads.swg
    │   │       │   ├── pytuplehlp.swg
    │   │       │   ├── pytypemaps.swg
    │   │       │   ├── pyuserdir.swg
    │   │       │   ├── pywstrings.swg
    │   │       │   ├── std_alloc.i
    │   │       │   ├── std_basic_string.i
    │   │       │   ├── std_carray.i
    │   │       │   ├── std_char_traits.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_complex.i
    │   │       │   ├── std_container.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_ios.i
    │   │       │   ├── std_iostream.i
    │   │       │   ├── std_list.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_multimap.i
    │   │       │   ├── std_multiset.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_set.i
    │   │       │   ├── std_sstream.i
    │   │       │   ├── std_streambuf.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── std_vectora.i
    │   │       │   ├── std_wios.i
    │   │       │   ├── std_wiostream.i
    │   │       │   ├── std_wsstream.i
    │   │       │   ├── std_wstreambuf.i
    │   │       │   ├── std_wstring.i
    │   │       │   ├── stl.i
    │   │       │   ├── typemaps.i
    │   │       │   └── wchar.i
    │   │       ├── r/
    │   │       │   ├── cdata.i
    │   │       │   ├── exception.i
    │   │       │   ├── r.swg
    │   │       │   ├── rcontainer.swg
    │   │       │   ├── rfragments.swg
    │   │       │   ├── ropers.swg
    │   │       │   ├── rrun.swg
    │   │       │   ├── rstdcommon.swg
    │   │       │   ├── rtype.swg
    │   │       │   ├── srun.swg
    │   │       │   ├── std_alloc.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_container.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── stl.i
    │   │       │   └── typemaps.i
    │   │       ├── ruby/
    │   │       │   ├── argcargv.i
    │   │       │   ├── attribute.i
    │   │       │   ├── carrays.i
    │   │       │   ├── cdata.i
    │   │       │   ├── cmalloc.i
    │   │       │   ├── cni.i
    │   │       │   ├── cpointer.i
    │   │       │   ├── cstring.i
    │   │       │   ├── director.swg
    │   │       │   ├── embed.i
    │   │       │   ├── exception.i
    │   │       │   ├── extconf.rb
    │   │       │   ├── extra-install.list
    │   │       │   ├── factory.i
    │   │       │   ├── file.i
    │   │       │   ├── jstring.i
    │   │       │   ├── Makefile.swig
    │   │       │   ├── progargcargv.i
    │   │       │   ├── ruby.swg
    │   │       │   ├── rubyapi.swg
    │   │       │   ├── rubyautodoc.swg
    │   │       │   ├── rubyclasses.swg
    │   │       │   ├── rubycomplex.swg
    │   │       │   ├── rubycontainer.swg
    │   │       │   ├── rubycontainer_extended.swg
    │   │       │   ├── rubydef.swg
    │   │       │   ├── rubyerrors.swg
    │   │       │   ├── rubyfragments.swg
    │   │       │   ├── rubyhead.swg
    │   │       │   ├── rubyinit.swg
    │   │       │   ├── rubyiterators.swg
    │   │       │   ├── rubykw.swg
    │   │       │   ├── rubymacros.swg
    │   │       │   ├── rubyopers.swg
    │   │       │   ├── rubyprimtypes.swg
    │   │       │   ├── rubyrun.swg
    │   │       │   ├── rubyruntime.swg
    │   │       │   ├── rubystdautodoc.swg
    │   │       │   ├── rubystdcommon.swg
    │   │       │   ├── rubystdfunctors.swg
    │   │       │   ├── rubystrings.swg
    │   │       │   ├── rubytracking.swg
    │   │       │   ├── rubytypemaps.swg
    │   │       │   ├── rubyuserdir.swg
    │   │       │   ├── rubywstrings.swg
    │   │       │   ├── std_alloc.i
    │   │       │   ├── std_basic_string.i
    │   │       │   ├── std_char_traits.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_complex.i
    │   │       │   ├── std_container.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_functors.i
    │   │       │   ├── std_ios.i
    │   │       │   ├── std_iostream.i
    │   │       │   ├── std_list.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_multimap.i
    │   │       │   ├── std_multiset.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_queue.i
    │   │       │   ├── std_set.i
    │   │       │   ├── std_sstream.i
    │   │       │   ├── std_stack.i
    │   │       │   ├── std_streambuf.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── std_vectora.i
    │   │       │   ├── std_wstring.i
    │   │       │   ├── stl.i
    │   │       │   ├── timeval.i
    │   │       │   └── typemaps.i
    │   │       ├── std/
    │   │       │   ├── README
    │   │       │   ├── _std_deque.i
    │   │       │   ├── std_alloc.i
    │   │       │   ├── std_basic_string.i
    │   │       │   ├── std_carray.swg
    │   │       │   ├── std_char_traits.i
    │   │       │   ├── std_common.i
    │   │       │   ├── std_container.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_ios.i
    │   │       │   ├── std_iostream.i
    │   │       │   ├── std_list.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_multimap.i
    │   │       │   ├── std_multiset.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_queue.i
    │   │       │   ├── std_set.i
    │   │       │   ├── std_sstream.i
    │   │       │   ├── std_stack.i
    │   │       │   ├── std_streambuf.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── std_vectora.i
    │   │       │   ├── std_wios.i
    │   │       │   ├── std_wiostream.i
    │   │       │   ├── std_wsstream.i
    │   │       │   ├── std_wstreambuf.i
    │   │       │   └── std_wstring.i
    │   │       ├── tcl/
    │   │       │   ├── attribute.i
    │   │       │   ├── carrays.i
    │   │       │   ├── cdata.i
    │   │       │   ├── cmalloc.i
    │   │       │   ├── cni.i
    │   │       │   ├── cpointer.i
    │   │       │   ├── cstring.i
    │   │       │   ├── cwstring.i
    │   │       │   ├── exception.i
    │   │       │   ├── factory.i
    │   │       │   ├── jstring.i
    │   │       │   ├── mactclinit.c
    │   │       │   ├── mactkinit.c
    │   │       │   ├── Makefile.in
    │   │       │   ├── std_common.i
    │   │       │   ├── std_deque.i
    │   │       │   ├── std_except.i
    │   │       │   ├── std_map.i
    │   │       │   ├── std_pair.i
    │   │       │   ├── std_string.i
    │   │       │   ├── std_vector.i
    │   │       │   ├── std_wstring.i
    │   │       │   ├── stl.i
    │   │       │   ├── tcl8.swg
    │   │       │   ├── tclapi.swg
    │   │       │   ├── tclerrors.swg
    │   │       │   ├── tclfragments.swg
    │   │       │   ├── tclinit.swg
    │   │       │   ├── tclinterp.i
    │   │       │   ├── tclkw.swg
    │   │       │   ├── tclmacros.swg
    │   │       │   ├── tclopers.swg
    │   │       │   ├── tclprimtypes.swg
    │   │       │   ├── tclresult.i
    │   │       │   ├── tclrun.swg
    │   │       │   ├── tclruntime.swg
    │   │       │   ├── tclsh.i
    │   │       │   ├── tclstrings.swg
    │   │       │   ├── tcltypemaps.swg
    │   │       │   ├── tcluserdir.swg
    │   │       │   ├── tclwstrings.swg
    │   │       │   ├── typemaps.i
    │   │       │   └── wish.i
    │   │       ├── typemaps/
    │   │       │   ├── README
    │   │       │   ├── attribute.swg
    │   │       │   ├── carrays.swg
    │   │       │   ├── cdata.swg
    │   │       │   ├── cmalloc.swg
    │   │       │   ├── cpointer.swg
    │   │       │   ├── cstring.swg
    │   │       │   ├── cstrings.swg
    │   │       │   ├── cwstring.swg
    │   │       │   ├── enumint.swg
    │   │       │   ├── exception.swg
    │   │       │   ├── factory.swg
    │   │       │   ├── fragments.swg
    │   │       │   ├── implicit.swg
    │   │       │   ├── inoutlist.swg
    │   │       │   ├── misctypes.swg
    │   │       │   ├── primtypes.swg
    │   │       │   ├── ptrtypes.swg
    │   │       │   ├── std_except.swg
    │   │       │   ├── std_string.swg
    │   │       │   ├── std_strings.swg
    │   │       │   ├── std_wstring.swg
    │   │       │   ├── string.swg
    │   │       │   ├── strings.swg
    │   │       │   ├── swigmacros.swg
    │   │       │   ├── swigobject.swg
    │   │       │   ├── swigtype.swg
    │   │       │   ├── swigtypemaps.swg
    │   │       │   ├── traits.swg
    │   │       │   ├── typemaps.swg
    │   │       │   ├── valtypes.swg
    │   │       │   ├── void.swg
    │   │       │   └── wstring.swg
    │   │       ├── uffi/
    │   │       │   └── uffi.swg
    │   │       └── xml/
    │   │           ├── typemaps.i
    │   │           └── xml.swg
    │   ├── syncfrommirror/
    │   │   ├── Redir.cpp
    │   │   ├── Redir.h
    │   │   ├── Redirect.cpp
    │   │   ├── Redirect.h
    │   │   ├── resource.h
    │   │   ├── StdAfx.cpp
    │   │   ├── StdAfx.h
    │   │   ├── syncfrommirror.cpp
    │   │   ├── syncfrommirror.h
    │   │   ├── syncfrommirror.rc
    │   │   ├── syncfrommirror.vpc
    │   │   ├── syncfrommirrorDlg.cpp
    │   │   ├── syncfrommirrorDlg.h
    │   │   └── res/
    │   │       └── syncfrommirror.rc2
    │   ├── tagbuild/
    │   │   ├── StdAfx.cpp
    │   │   ├── StdAfx.h
    │   │   ├── tagbuild.cpp
    │   │   └── tagbuild.vpc
    │   ├── test_binaries/
    │   │   ├── COMMON.C
    │   │   ├── COMMON.H
    │   │   ├── EXEDUMP.C
    │   │   ├── EXEDUMP.H
    │   │   ├── EXTRNVAR.H
    │   │   ├── OBJDUMP.C
    │   │   ├── OBJDUMP.H
    │   │   ├── PEDUMP.C
    │   │   ├── test_binaries.cpp
    │   │   └── test_binaries.vpc
    │   ├── vs_nop_tools/
    │   │   └── readme.txt
    │   ├── vstools/
    │   │   └── readme.txt
    │   └── WiseInstallerHelpers/
    │       ├── LicenseViewed.cpp
    │       ├── LicenseViewed.vpc
    │       └── UpdateProgress/
    │           ├── UpdateProgress.cpp
    │           └── UpdateProgress.vpc
    ├── dmserializers/
    │   ├── dmebaseimporter.cpp
    │   ├── dmebaseimporter.h
    │   ├── dmserializers.cpp
    │   ├── dmserializers.h
    │   ├── dmserializers.vpc
    │   ├── importactbusy.cpp
    │   ├── importkeyvaluebase.cpp
    │   ├── importkeyvaluebase.h
    │   ├── importsfmv1.cpp
    │   ├── importsfmv2.cpp
    │   ├── importsfmv3.cpp
    │   ├── importsfmv4.cpp
    │   ├── importsfmv5.cpp
    │   ├── importsfmv6.cpp
    │   ├── importsfmv7.cpp
    │   ├── importsfmv8.cpp
    │   ├── importsfmv9.cpp
    │   ├── importvmf.cpp
    │   └── importvmt.cpp
    ├── dmxloader/
    │   ├── dmxattribute.cpp
    │   ├── dmxelement.cpp
    │   ├── dmxloader.cpp
    │   ├── dmxloader.vpc
    │   ├── dmxloadertext.cpp
    │   ├── dmxserializationdictionary.cpp
    │   ├── dmxserializationdictionary.h
    │   └── wscript
    ├── dx9sdk/
    │   └── include/
    │       ├── activecf.h
    │       ├── amaudio.h
    │       ├── amparse.h
    │       ├── amstream.h
    │       ├── amva.h
    │       ├── Amvideo.h
    │       ├── atsmedia.h
    │       ├── audevcod.h
    │       ├── austream.h
    │       ├── aviriff.h
    │       ├── bdaiface.h
    │       ├── bdamedia.h
    │       ├── Bdatif.h
    │       ├── bdatypes.h
    │       ├── comlite.h
    │       ├── control.h
    │       ├── d3d.h
    │       ├── d3d8.h
    │       ├── d3d8caps.h
    │       ├── d3d8types.h
    │       ├── d3d9.h
    │       ├── d3d9caps.h
    │       ├── d3d9types.h
    │       ├── d3dcaps.h
    │       ├── d3drm.h
    │       ├── d3drmdef.h
    │       ├── d3drmobj.h
    │       ├── d3drmwin.h
    │       ├── d3dtypes.h
    │       ├── d3dvec.inl
    │       ├── d3dx.h
    │       ├── d3dx8.h
    │       ├── d3dx8core.h
    │       ├── d3dx8effect.h
    │       ├── d3dx8math.h
    │       ├── d3dx8math.inl
    │       ├── d3dx8mesh.h
    │       ├── d3dx8shape.h
    │       ├── d3dx8tex.h
    │       ├── d3dx9.h
    │       ├── d3dx9anim.h
    │       ├── d3dx9core.h
    │       ├── d3dx9effect.h
    │       ├── d3dx9math.h
    │       ├── d3dx9math.inl
    │       ├── d3dx9mesh.h
    │       ├── d3dx9shader.h
    │       ├── d3dx9shape.h
    │       ├── d3dx9tex.h
    │       ├── d3dx9xof.h
    │       ├── d3dxcore.h
    │       ├── d3dxerr.h
    │       ├── d3dxmath.h
    │       ├── d3dxmath.inl
    │       ├── d3dxshapes.h
    │       ├── d3dxsprite.h
    │       ├── ddraw.h
    │       ├── ddstream.h
    │       ├── dinput.h
    │       ├── dinputd.h
    │       ├── dls1.h
    │       ├── dls2.h
    │       ├── dmdls.h
    │       ├── dmerror.h
    │       ├── dmksctrl.h
    │       ├── dmo.h
    │       ├── dmodshow.h
    │       ├── dmoimpl.h
    │       ├── dmoreg.h
    │       ├── dmort.h
    │       ├── dmplugin.h
    │       ├── dmusbuff.h
    │       ├── dmusicc.h
    │       ├── dmusicf.h
    │       ├── dmusici.h
    │       ├── dmusics.h
    │       ├── dpaddr.h
    │       ├── dplay.h
    │       ├── dplay8.h
    │       ├── dplobby.h
    │       ├── dplobby8.h
    │       ├── dpnathlp.h
    │       ├── dsconf.h
    │       ├── dsetup.h
    │       ├── DShow.h
    │       ├── dshowasf.h
    │       ├── dsound.h
    │       ├── dv.h
    │       ├── dvdevcod.h
    │       ├── dvdmedia.h
    │       ├── dvoice.h
    │       ├── dvp.h
    │       ├── dx7todx8.h
    │       ├── DxDiag.h
    │       ├── dxerr8.h
    │       ├── dxerr9.h
    │       ├── dxfile.h
    │       ├── dxtrans.h
    │       ├── dxva.h
    │       ├── edevctrl.h
    │       ├── edevdefs.h
    │       ├── errors.h
    │       ├── evcode.h
    │       ├── il21dec.h
    │       ├── Iwstdec.h
    │       ├── ks.h
    │       ├── ksguid.h
    │       ├── ksmedia.h
    │       ├── ksproxy.h
    │       ├── ksuuids.h
    │       ├── mediaerr.h
    │       ├── mediaobj.h
    │       ├── medparam.h
    │       ├── mixerocx.h
    │       ├── mmstream.h
    │       ├── mpconfig.h
    │       ├── Mpeg2Bits.h
    │       ├── mpeg2data.h
    │       ├── Mpeg2Error.h
    │       ├── mpegtype.h
    │       ├── Msvidctl.h
    │       ├── multimon.h
    │       ├── PixPlugin.h
    │       ├── playlist.h
    │       ├── qnetwork.h
    │       ├── regbag.h
    │       ├── rmxfguid.h
    │       ├── rmxftmpl.h
    │       ├── sbe.h
    │       ├── strsafe.h
    │       ├── tune.h
    │       ├── tvratings.h
    │       ├── uuids.h
    │       ├── vfwmsgs.h
    │       ├── vidcap.h
    │       ├── videoacc.h
    │       ├── vmr9.h
    │       ├── vpconfig.h
    │       ├── vpnotify.h
    │       ├── vptype.h
    │       ├── XInput.h
    │       └── xprtdefs.h
    ├── engine/
    │   ├── baseautocompletefilelist.cpp
    │   ├── baseautocompletefilelist.h
    │   ├── baseclient.cpp
    │   ├── baseclient.h
    │   ├── baseclientstate.cpp
    │   ├── baseclientstate.h
    │   ├── baseserver.cpp
    │   ├── baseserver.h
    │   ├── bitbuf_errorhandler.cpp
    │   ├── bitbuf_errorhandler.h
    │   ├── bugreporter.cpp
    │   ├── buildcubemaps.cpp
    │   ├── cbenchmark.cpp
    │   ├── cbenchmark.h
    │   ├── ccs.cpp
    │   ├── ccs.h
    │   ├── cdll_engine_int.cpp
    │   ├── cdll_engine_int.h
    │   ├── changeframelist.cpp
    │   ├── changeframelist.h
    │   ├── cheatcodes.cpp
    │   ├── cheatcodes.h
    │   ├── checksum_engine.cpp
    │   ├── checksum_engine.h
    │   ├── cl_bounded_cvars.cpp
    │   ├── cl_bounded_cvars.h
    │   ├── cl_check_process.cpp
    │   ├── cl_check_process.h
    │   ├── cl_demo.cpp
    │   ├── cl_demo.h
    │   ├── cl_demoaction.cpp
    │   ├── cl_demoaction.h
    │   ├── cl_demoaction_types.cpp
    │   ├── cl_demoaction_types.h
    │   ├── cl_demoactioneditors.cpp
    │   ├── cl_demoactioneditors.h
    │   ├── cl_demoactionmanager.cpp
    │   ├── cl_demoactionmanager.h
    │   ├── cl_demoeditorpanel.cpp
    │   ├── cl_demoeditorpanel.h
    │   ├── cl_demosmootherpanel.cpp
    │   ├── cl_demosmootherpanel.h
    │   ├── cl_demosmoothing.h
    │   ├── cl_demouipanel.cpp
    │   ├── cl_demouipanel.h
    │   ├── cl_entityreport.cpp
    │   ├── cl_entityreport.h
    │   ├── cl_ents_parse.cpp
    │   ├── cl_ents_parse.h
    │   ├── cl_foguipanel.cpp
    │   ├── cl_foguipanel.h
    │   ├── cl_localnetworkbackdoor.cpp
    │   ├── cl_localnetworkbackdoor.h
    │   ├── cl_main.cpp
    │   ├── cl_main.h
    │   ├── cl_null.cpp
    │   ├── cl_parse_event.cpp
    │   ├── cl_parse_event.h
    │   ├── cl_pluginhelpers.cpp
    │   ├── cl_pluginhelpers.h
    │   ├── cl_pred.cpp
    │   ├── cl_pred.h
    │   ├── cl_rcon.cpp
    │   ├── cl_rcon.h
    │   ├── cl_steamauth.cpp
    │   ├── cl_steamauth.h
    │   ├── cl_texturelistpanel.cpp
    │   ├── cl_texturelistpanel.h
    │   ├── cl_txviewpanel.cpp
    │   ├── cl_txviewpanel.h
    │   ├── client.cpp
    │   ├── client.h
    │   ├── client_pch.cpp
    │   ├── client_pch.h
    │   ├── clientframe.cpp
    │   ├── clientframe.h
    │   ├── clockdriftmgr.cpp
    │   ├── clockdriftmgr.h
    │   ├── cmd.cpp
    │   ├── cmd.h
    │   ├── cmodel.cpp
    │   ├── cmodel_bsp.cpp
    │   ├── cmodel_disp.cpp
    │   ├── cmodel_engine.h
    │   ├── cmodel_private.h
    │   ├── colorcorrectionpanel.cpp
    │   ├── common.cpp
    │   ├── common.h
    │   ├── conprint.h
    │   ├── console.cpp
    │   ├── console.h
    │   ├── cvar.cpp
    │   ├── cvar.h
    │   ├── debug_leafvis.cpp
    │   ├── debug_leafvis.h
    │   ├── debugoverlay.cpp
    │   ├── debugoverlay.h
    │   ├── decal.h
    │   ├── decal_clip.cpp
    │   ├── decal_clip.h
    │   ├── decal_private.h
    │   ├── decals.cpp
    │   ├── demo.h
    │   ├── demofile.cpp
    │   ├── demofile.h
    │   ├── DevShotGenerator.cpp
    │   ├── DevShotGenerator.h
    │   ├── disp.cpp
    │   ├── disp.h
    │   ├── disp_defs.cpp
    │   ├── disp_defs.h
    │   ├── disp_helpers.cpp
    │   ├── disp_helpers.h
    │   ├── disp_interface.cpp
    │   ├── disp_mapload.cpp
    │   ├── dispnode.h
    │   ├── download.cpp
    │   ├── download.h
    │   ├── download_internal.h
    │   ├── DownloadListGenerator.cpp
    │   ├── DownloadListGenerator.h
    │   ├── downloadthread.cpp
    │   ├── draw.h
    │   ├── dt.cpp
    │   ├── dt.h
    │   ├── dt_common_eng.cpp
    │   ├── dt_common_eng.h
    │   ├── dt_encode.cpp
    │   ├── dt_encode.h
    │   ├── dt_instrumentation.cpp
    │   ├── dt_instrumentation.h
    │   ├── dt_instrumentation_server.cpp
    │   ├── dt_instrumentation_server.h
    │   ├── dt_localtransfer.cpp
    │   ├── dt_localtransfer.h
    │   ├── dt_recv_decoder.cpp
    │   ├── dt_recv_decoder.h
    │   ├── dt_recv_eng.cpp
    │   ├── dt_recv_eng.h
    │   ├── dt_send_eng.cpp
    │   ├── dt_send_eng.h
    │   ├── dt_stack.cpp
    │   ├── dt_stack.h
    │   ├── dt_test.cpp
    │   ├── dt_test.h
    │   ├── engine.vpc
    │   ├── engine_replay_int.cpp
    │   ├── enginebugreporter.h
    │   ├── engineperftools.h
    │   ├── enginesingleuserfilter.cpp
    │   ├── enginesingleuserfilter.h
    │   ├── EngineSoundClient.cpp
    │   ├── EngineSoundInternal.h
    │   ├── EngineSoundServer.cpp
    │   ├── enginestats.cpp
    │   ├── enginestats.h
    │   ├── enginethreads.cpp
    │   ├── enginethreads.h
    │   ├── enginetool.cpp
    │   ├── enginetrace.cpp
    │   ├── enginetrace.h
    │   ├── engsoundservice.cpp
    │   ├── ents_shared.h
    │   ├── event_system.h
    │   ├── filesystem_engine.cpp
    │   ├── filesystem_engine.h
    │   ├── filetransfermgr.cpp
    │   ├── filetransfermgr.h
    │   ├── flat.mat
    │   ├── framesnapshot.h
    │   ├── GameEventManager.cpp
    │   ├── GameEventManager.h
    │   ├── GameEventManagerOld.cpp
    │   ├── gametrace_engine.cpp
    │   ├── getintersectingsurfaces_struct.h
    │   ├── gl_cvars.h
    │   ├── gl_draw.cpp
    │   ├── gl_drawlights.cpp
    │   ├── gl_drawlights.h
    │   ├── gl_lightmap.cpp
    │   ├── gl_lightmap.h
    │   ├── gl_matsysiface.cpp
    │   ├── gl_matsysiface.h
    │   ├── gl_model.h
    │   ├── gl_model_private.h
    │   ├── gl_rlight.cpp
    │   ├── gl_rmain.cpp
    │   ├── gl_rmain.h
    │   ├── gl_rmisc.cpp
    │   ├── gl_rsurf.cpp
    │   ├── gl_rsurf.h
    │   ├── gl_screen.cpp
    │   ├── gl_shader.cpp
    │   ├── gl_shader.h
    │   ├── gl_warp.cpp
    │   ├── gl_water.h
    │   ├── halflife.rc
    │   ├── hltvclient.cpp
    │   ├── hltvclient.h
    │   ├── hltvclientstate.cpp
    │   ├── hltvclientstate.h
    │   ├── hltvdemo.cpp
    │   ├── hltvdemo.h
    │   ├── hltvserver.cpp
    │   ├── hltvserver.h
    │   ├── hltvtest.cpp
    │   ├── hltvtest.h
    │   ├── host.cpp
    │   ├── host.h
    │   ├── host_cmd.cpp
    │   ├── host_cmd.h
    │   ├── host_jmp.h
    │   ├── host_listmaps.cpp
    │   ├── host_phonehome.cpp
    │   ├── host_phonehome.h
    │   ├── host_saverestore.cpp
    │   ├── host_saverestore.h
    │   ├── host_state.cpp
    │   ├── host_state.h
    │   ├── icolorcorrectiontools.h
    │   ├── idispinfo.h
    │   ├── iengine.h
    │   ├── ienginetoolinternal.h
    │   ├── igame.h
    │   ├── initmathlib.cpp
    │   ├── IOcclusionSystem.h
    │   ├── ipooledvballocator.h
    │   ├── ispatialpartitioninternal.h
    │   ├── ithread.h
    │   ├── ivideomode.h
    │   ├── keys.cpp
    │   ├── keys.h
    │   ├── l_studio.cpp
    │   ├── l_studio.h
    │   ├── lightcache.cpp
    │   ├── lightcache.h
    │   ├── LoadScreenUpdate.cpp
    │   ├── LoadScreenUpdate.h
    │   ├── LocalNetworkBackdoor.cpp
    │   ├── LocalNetworkBackdoor.h
    │   ├── logofile_shared.cpp
    │   ├── logofile_shared.h
    │   ├── lowpassstream.h
    │   ├── MapReslistGenerator.cpp
    │   ├── MapReslistGenerator.h
    │   ├── master.h
    │   ├── masterserver.cpp
    │   ├── matchmaking.h
    │   ├── matchmakingclient.cpp
    │   ├── matchmakinghost.cpp
    │   ├── matchmakingmigrate.cpp
    │   ├── matchmakingqos.cpp
    │   ├── matchmakingqos.h
    │   ├── matchmakingshared.cpp
    │   ├── MaterialBuckets.h
    │   ├── materialproxyfactory.cpp
    │   ├── materialproxyfactory.h
    │   ├── matsys_interface.cpp
    │   ├── mem.cpp
    │   ├── mem.h
    │   ├── mem_fgets.cpp
    │   ├── mem_fgets.h
    │   ├── mod_vis.cpp
    │   ├── mod_vis.h
    │   ├── ModelInfo.cpp
    │   ├── ModelInfo.h
    │   ├── modelloader.cpp
    │   ├── modelloader.h
    │   ├── net.h
    │   ├── net_chan.cpp
    │   ├── net_chan.h
    │   ├── net_synctags.cpp
    │   ├── net_synctags.h
    │   ├── net_ws.cpp
    │   ├── net_ws_headers.h
    │   ├── net_ws_queued_packet_sender.cpp
    │   ├── net_ws_queued_packet_sender.h
    │   ├── networkstringtable.cpp
    │   ├── networkstringtable.h
    │   ├── networkstringtableclient.cpp
    │   ├── networkstringtableclient.h
    │   ├── networkstringtablecontainerclient.h
    │   ├── networkstringtablecontainerserver.h
    │   ├── NetworkStringTableItem.cpp
    │   ├── networkstringtableitem.h
    │   ├── networkstringtableserver.cpp
    │   ├── networkstringtableserver.h
    │   ├── OcclusionSystem.cpp
    │   ├── Overlay.cpp
    │   ├── Overlay.h
    │   ├── packed_entity.cpp
    │   ├── packed_entity.h
    │   ├── perfuipanel.cpp
    │   ├── pr_edict.cpp
    │   ├── pr_edict.h
    │   ├── precache.cpp
    │   ├── precache.h
    │   ├── profile.h
    │   ├── profiling.h
    │   ├── progs.h
    │   ├── pure_server.cpp
    │   ├── pure_server.h
    │   ├── quakeasm.h
    │   ├── quakedef.cpp
    │   ├── quakedef.h
    │   ├── r_areaportal.cpp
    │   ├── r_areaportal.h
    │   ├── r_decal.cpp
    │   ├── r_decal.h
    │   ├── r_efx.cpp
    │   ├── r_efxextern.h
    │   ├── r_linefile.cpp
    │   ├── r_local.h
    │   ├── randomnormals.h
    │   ├── randomstream.cpp
    │   ├── render.h
    │   ├── render_pch.cpp
    │   ├── render_pch.h
    │   ├── replay_internal.cpp
    │   ├── replay_internal.h
    │   ├── replaydemo.cpp
    │   ├── replaydemo.h
    │   ├── replaydemoplayer.cpp
    │   ├── replaydemoplayer.h
    │   ├── replayserver.cpp
    │   ├── replayserver.h
    │   ├── resource.h
    │   ├── rpt_engine.cpp
    │   ├── saverestore_filesystem.cpp
    │   ├── saverestore_filesystem.h
    │   ├── sbar.h
    │   ├── screen.h
    │   ├── server.h
    │   ├── server_pch.cpp
    │   ├── server_pch.h
    │   ├── servermsghandler.cpp
    │   ├── Session.cpp
    │   ├── Session.h
    │   ├── shadowmgr.cpp
    │   ├── shadowmgr.h
    │   ├── snd_io.cpp
    │   ├── socketcreator.cpp
    │   ├── socketcreator.h
    │   ├── sound_shared.cpp
    │   ├── spatialpartition.cpp
    │   ├── staticpropmgr.cpp
    │   ├── staticpropmgr.h
    │   ├── studio_internal.h
    │   ├── surfacehandle.h
    │   ├── sv_client.cpp
    │   ├── sv_client.h
    │   ├── sv_ents_write.cpp
    │   ├── sv_filter.cpp
    │   ├── sv_filter.h
    │   ├── sv_framesnapshot.cpp
    │   ├── sv_ipratelimit.cpp
    │   ├── sv_ipratelimit.h
    │   ├── sv_log.cpp
    │   ├── sv_log.h
    │   ├── sv_logofile.cpp
    │   ├── sv_logofile.h
    │   ├── sv_main.cpp
    │   ├── sv_main.h
    │   ├── sv_master_legacy.h
    │   ├── sv_packedentities.cpp
    │   ├── sv_packedentities.h
    │   ├── sv_plugin.cpp
    │   ├── sv_plugin.h
    │   ├── sv_precache.cpp
    │   ├── sv_precache.h
    │   ├── sv_rcon.cpp
    │   ├── sv_rcon.h
    │   ├── sv_redirect.cpp
    │   ├── sv_remoteaccess.cpp
    │   ├── sv_remoteaccess.h
    │   ├── sv_steamauth.cpp
    │   ├── sv_steamauth.h
    │   ├── sv_uploaddata.cpp
    │   ├── sv_uploaddata.h
    │   ├── sv_uploadgamestats.cpp
    │   ├── sv_uploadgamestats.h
    │   ├── sv_user.h
    │   ├── SVConnectionlessHandler.h
    │   ├── sys.h
    │   ├── sys_dll.cpp
    │   ├── sys_dll.h
    │   ├── sys_dll2.cpp
    │   ├── sys_engine.cpp
    │   ├── sys_getmodes.cpp
    │   ├── sys_mainwind.cpp
    │   ├── sys_mainwind.h
    │   ├── sys_stubwind.cpp
    │   ├── sysexternal.h
    │   ├── testscriptmgr.cpp
    │   ├── testscriptmgr.h
    │   ├── tmessage.cpp
    │   ├── tmessage.h
    │   ├── toolframework.cpp
    │   ├── traceinit.cpp
    │   ├── traceinit.h
    │   ├── vengineserver_impl.cpp
    │   ├── vengineserver_impl.h
    │   ├── vfilter.h
    │   ├── vgui_askconnectpanel.cpp
    │   ├── vgui_askconnectpanel.h
    │   ├── vgui_basepanel.cpp
    │   ├── vgui_basepanel.h
    │   ├── vgui_baseui_interface.cpp
    │   ├── vgui_baseui_interface.h
    │   ├── vgui_budgetfpspanel.cpp
    │   ├── vgui_budgetpanel.cpp
    │   ├── vgui_budgetpanel.h
    │   ├── vgui_DebugSystemPanel.cpp
    │   ├── vgui_DebugSystemPanel.h
    │   ├── vgui_drawtreepanel.cpp
    │   ├── vgui_drawtreepanel.h
    │   ├── vgui_helpers.cpp
    │   ├── vgui_helpers.h
    │   ├── vgui_texturebudgetpanel.cpp
    │   ├── vgui_texturebudgetpanel.h
    │   ├── vgui_vprofgraphpanel.cpp
    │   ├── vgui_vprofgraphpanel.h
    │   ├── vgui_vprofpanel.cpp
    │   ├── vgui_vprofpanel.h
    │   ├── view.cpp
    │   ├── view.h
    │   ├── vmodes.h
    │   ├── voiceserver_impl.cpp
    │   ├── vprof_engine.cpp
    │   ├── vprof_engine.h
    │   ├── vprof_record.cpp
    │   ├── vprof_record.h
    │   ├── world.cpp
    │   ├── world.h
    │   ├── wscript
    │   ├── xboxsystem.cpp
    │   ├── zone.cpp
    │   ├── zone.h
    │   ├── audio/
    │   │   ├── audio_pch.h
    │   │   ├── circularbuffer.cpp
    │   │   ├── circularbuffer.h
    │   │   ├── eax.h
    │   │   ├── MPAFile.cpp
    │   │   ├── MPAFile.h
    │   │   ├── MPAHeader.cpp
    │   │   ├── MPAHeader.h
    │   │   ├── posix_stubs.h
    │   │   ├── snd_channels.h
    │   │   ├── snd_convars.h
    │   │   ├── snd_dev_common.cpp
    │   │   ├── snd_dev_common.h
    │   │   ├── snd_dev_direct.cpp
    │   │   ├── snd_dev_direct.h
    │   │   ├── snd_dev_mac_audioqueue.cpp
    │   │   ├── snd_dev_mac_audioqueue.h
    │   │   ├── snd_dev_openal.cpp
    │   │   ├── snd_dev_openal.h
    │   │   ├── snd_dev_sdl.cpp
    │   │   ├── snd_dev_sdl.h
    │   │   ├── snd_dev_wave.cpp
    │   │   ├── snd_dev_wave.h
    │   │   ├── snd_dev_xaudio.cpp
    │   │   ├── snd_dev_xaudio.h
    │   │   ├── snd_dma.cpp
    │   │   ├── snd_dma.h
    │   │   ├── snd_dsp.cpp
    │   │   ├── snd_env_fx.h
    │   │   ├── snd_mix.cpp
    │   │   ├── snd_mp3_source.cpp
    │   │   ├── snd_mp3_source.h
    │   │   ├── snd_posix.cpp
    │   │   ├── snd_sentence_mixer.cpp
    │   │   ├── snd_sfx.h
    │   │   ├── snd_stubs.cpp
    │   │   ├── snd_stubs.h
    │   │   ├── snd_wave_data.cpp
    │   │   ├── snd_wave_data.h
    │   │   ├── snd_wave_mixer.cpp
    │   │   ├── snd_wave_mixer.h
    │   │   ├── snd_wave_mixer_adpcm.cpp
    │   │   ├── snd_wave_mixer_adpcm.h
    │   │   ├── snd_wave_mixer_mp3.cpp
    │   │   ├── snd_wave_mixer_mp3.h
    │   │   ├── snd_wave_mixer_private.h
    │   │   ├── snd_wave_mixer_xma.cpp
    │   │   ├── snd_wave_mixer_xma.h
    │   │   ├── snd_wave_source.cpp
    │   │   ├── snd_wave_source.h
    │   │   ├── snd_wave_temp.cpp
    │   │   ├── snd_wave_temp.h
    │   │   ├── snd_win.cpp
    │   │   ├── sound_private.h
    │   │   ├── VBRHeader.cpp
    │   │   ├── VBRHeader.h
    │   │   ├── voice.cpp
    │   │   ├── voice_gain.cpp
    │   │   ├── voice_gain.h
    │   │   ├── voice_mixer_controls.cpp
    │   │   ├── voice_mixer_controls.h
    │   │   ├── voice_mixer_controls_openal.cpp
    │   │   ├── voice_record_dsound.cpp
    │   │   ├── voice_record_mac_audioqueue.cpp
    │   │   ├── voice_record_openal.cpp
    │   │   ├── voice_record_sdl.cpp
    │   │   ├── voice_sound_engine_interface.cpp
    │   │   ├── voice_sound_engine_interface.h
    │   │   ├── voice_wavefile.cpp
    │   │   ├── voice_wavefile.h
    │   │   ├── vox.cpp
    │   │   └── vox_private.h
    │   ├── voice_codecs/
    │   │   ├── celt/
    │   │   │   ├── vaudio_celt.vpc
    │   │   │   ├── voiceencoder_celt.cpp
    │   │   │   ├── wscript
    │   │   │   └── opus/
    │   │   │       ├── opus.h
    │   │   │       ├── opus_custom.h
    │   │   │       ├── opus_defines.h
    │   │   │       ├── opus_multistream.h
    │   │   │       ├── opus_projection.h
    │   │   │       ├── opus_types.h
    │   │   │       └── opusfile.h
    │   │   ├── frame_encoder/
    │   │   │   ├── iframeencoder.h
    │   │   │   └── voice_codec_frame.cpp
    │   │   ├── minimp3/
    │   │   │   ├── mp3codecs.cpp
    │   │   │   ├── vaudio_minimp3.vpc
    │   │   │   └── wscript
    │   │   ├── opus/
    │   │   │   ├── voiceencoder_opus.cpp
    │   │   │   ├── wscript
    │   │   │   └── opus/
    │   │   │       ├── opus.h
    │   │   │       ├── opus_custom.h
    │   │   │       ├── opus_defines.h
    │   │   │       ├── opus_multistream.h
    │   │   │       ├── opus_projection.h
    │   │   │       ├── opus_types.h
    │   │   │       └── opusfile.h
    │   │   └── speex/
    │   │       ├── speex.vcproj
    │   │       ├── vaudio_speex.vpc
    │   │       ├── VoiceEncoder_Speex.cpp
    │   │       ├── VoiceEncoder_Speex.h
    │   │       ├── wscript
    │   │       └── speex/
    │   │           ├── speex.h
    │   │           ├── speex_bits.h
    │   │           ├── speex_callbacks.h
    │   │           ├── speex_config_types.h
    │   │           ├── speex_echo.h
    │   │           ├── speex_header.h
    │   │           ├── speex_jitter.h
    │   │           ├── speex_preprocess.h
    │   │           ├── speex_resampler.h
    │   │           ├── speex_stereo.h
    │   │           ├── speex_types.h
    │   │           ├── speexdsp_config_types.h
    │   │           └── speexdsp_types.h
    │   └── xbox/
    │       └── xbox.def
    ├── external/
    │   ├── v8/
    │   │   └── include/
    │   │       ├── v8-debug.h
    │   │       ├── v8-platform.h
    │   │       ├── v8-profiler.h
    │   │       ├── v8-testing.h
    │   │       ├── v8-util.h
    │   │       ├── v8.h
    │   │       ├── v8config.h
    │   │       ├── v8stdint.h
    │   │       └── libplatform/
    │   │           └── libplatform.h
    │   └── vpc/
    │       ├── devtools/
    │       │   ├── base.xcconfig
    │       │   ├── debug.xcconfig
    │       │   ├── makefile_base_posix.mak
    │       │   └── release.xcconfig
    │       ├── interfaces/
    │       │   └── interfaces.cpp
    │       ├── p4lib/
    │       │   ├── p4.cpp
    │       │   └── p4lib.vpc
    │       ├── public/
    │       │   ├── color.h
    │       │   ├── datamap.h
    │       │   ├── filesystem.h
    │       │   ├── filesystem_passthru.h
    │       │   ├── icvar.h
    │       │   ├── ilaunchabledll.h
    │       │   ├── winlite.h
    │       │   ├── appframework/
    │       │   │   └── iappsystem.h
    │       │   ├── interfaces/
    │       │   │   └── interfaces.h
    │       │   ├── mathlib/
    │       │   │   ├── fltx4.h
    │       │   │   ├── math_pfns.h
    │       │   │   ├── mathlib.h
    │       │   │   ├── vector.h
    │       │   │   └── vector2d.h
    │       │   ├── p4lib/
    │       │   │   └── ip4.h
    │       │   ├── tier0/
    │       │   │   ├── annotations.h
    │       │   │   ├── basetypes.h
    │       │   │   ├── commonmacros.h
    │       │   │   ├── dbg.h
    │       │   │   ├── dbgflag.h
    │       │   │   ├── etwprof.h
    │       │   │   ├── eventmasks.h
    │       │   │   ├── eventmodes.h
    │       │   │   ├── fasttimer.h
    │       │   │   ├── ia32detect.h
    │       │   │   ├── icommandline.h
    │       │   │   ├── ioctlcodes.h
    │       │   │   ├── k8performancecounters.h
    │       │   │   ├── l2cache.h
    │       │   │   ├── logging.h
    │       │   │   ├── mem.h
    │       │   │   ├── memalloc.h
    │       │   │   ├── memdbgoff.h
    │       │   │   ├── memdbgon.h
    │       │   │   ├── memvirt.h
    │       │   │   ├── minidump.h
    │       │   │   ├── p4performancecounters.h
    │       │   │   ├── p5p6performancecounters.h
    │       │   │   ├── platform.h
    │       │   │   ├── pmelib.h
    │       │   │   ├── stackstats.h
    │       │   │   ├── stacktools.h
    │       │   │   ├── threadtools.h
    │       │   │   ├── threadtools.inl
    │       │   │   ├── tslist.h
    │       │   │   ├── validator.h
    │       │   │   ├── valobject.h
    │       │   │   ├── valve_off.h
    │       │   │   ├── valve_on.h
    │       │   │   ├── vprof.h
    │       │   │   ├── vprof_sn.h
    │       │   │   ├── wchartypes.h
    │       │   │   ├── win32consoleio.h
    │       │   │   └── xbox_codeline_defines.h
    │       │   ├── tier1/
    │       │   │   ├── byteswap.h
    │       │   │   ├── characterset.h
    │       │   │   ├── checksum_crc.h
    │       │   │   ├── checksum_md5.h
    │       │   │   ├── convar.h
    │       │   │   ├── convar_serverbounded.h
    │       │   │   ├── exprevaluator.h
    │       │   │   ├── fmtstr.h
    │       │   │   ├── functors.h
    │       │   │   ├── generichash.h
    │       │   │   ├── iconvar.h
    │       │   │   ├── interface.h
    │       │   │   ├── keyvalues.h
    │       │   │   ├── mempool.h
    │       │   │   ├── memstack.h
    │       │   │   ├── netadr.h
    │       │   │   ├── refcount.h
    │       │   │   ├── stringpool.h
    │       │   │   ├── strtools.h
    │       │   │   ├── tier1.h
    │       │   │   ├── utlblockmemory.h
    │       │   │   ├── utlbuffer.h
    │       │   │   ├── utldict.h
    │       │   │   ├── utlenvelope.h
    │       │   │   ├── utlfixedmemory.h
    │       │   │   ├── utlgraph.h
    │       │   │   ├── utlhash.h
    │       │   │   ├── utllinkedlist.h
    │       │   │   ├── utlmap.h
    │       │   │   ├── utlmemory.h
    │       │   │   ├── utlmultilist.h
    │       │   │   ├── utlqueue.h
    │       │   │   ├── utlrbtree.h
    │       │   │   ├── utlsortvector.h
    │       │   │   ├── utlstack.h
    │       │   │   ├── utlstring.h
    │       │   │   ├── utlsymbol.h
    │       │   │   └── utlvector.h
    │       │   ├── tier2/
    │       │   │   └── tier2.h
    │       │   ├── unitlib/
    │       │   │   └── unitlib.h
    │       │   └── vstdlib/
    │       │       ├── cvar.h
    │       │       ├── ikeyvaluessystem.h
    │       │       ├── pch_vstdlib.h
    │       │       ├── random.h
    │       │       ├── vstdlib.h
    │       │       └── vstrtools.h
    │       ├── tier0/
    │       │   ├── assert_dialog.cpp
    │       │   ├── commandline.cpp
    │       │   ├── cpu.cpp
    │       │   ├── cpu_posix.cpp
    │       │   ├── cputopology.cpp
    │       │   ├── cputopology.h
    │       │   ├── dbg.cpp
    │       │   ├── etwprof.cpp
    │       │   ├── fasttimer.cpp
    │       │   ├── logging.cpp
    │       │   ├── mem.cpp
    │       │   ├── mem_helpers.cpp
    │       │   ├── mem_helpers.h
    │       │   ├── mem_impl_type.h
    │       │   ├── memdbg.cpp
    │       │   ├── memstd.cpp
    │       │   ├── memstd.h
    │       │   ├── memvalidate.cpp
    │       │   ├── minidump.cpp
    │       │   ├── pch_tier0.cpp
    │       │   ├── pch_tier0.h
    │       │   ├── platform.cpp
    │       │   ├── platform_posix.cpp
    │       │   ├── pme.cpp
    │       │   ├── pme_posix.cpp
    │       │   ├── pmelib.cpp
    │       │   ├── resource.h
    │       │   ├── stacktools.cpp
    │       │   ├── threadtools.cpp
    │       │   ├── tier0_strtools.cpp
    │       │   ├── tier0_strtools.h
    │       │   ├── valobject.cpp
    │       │   ├── vprof.cpp
    │       │   └── win32consoleio.cpp
    │       ├── tier1/
    │       │   ├── characterset.cpp
    │       │   ├── checksum_crc.cpp
    │       │   ├── checksum_md5.cpp
    │       │   ├── convar.cpp
    │       │   ├── exprevaluator.cpp
    │       │   ├── generichash.cpp
    │       │   ├── interface.cpp
    │       │   ├── keyvalues.cpp
    │       │   ├── mempool.cpp
    │       │   ├── memstack.cpp
    │       │   ├── splitstring.cpp
    │       │   ├── stringpool.cpp
    │       │   ├── strtools.cpp
    │       │   ├── tier1.cpp
    │       │   ├── utlbuffer.cpp
    │       │   ├── utlstring.cpp
    │       │   └── utlsymbol.cpp
    │       ├── utils/
    │       │   ├── vpc/
    │       │   │   ├── baseprojectdatacollector.cpp
    │       │   │   ├── baseprojectdatacollector.h
    │       │   │   ├── conditionals.cpp
    │       │   │   ├── config_general.cpp
    │       │   │   ├── configuration.cpp
    │       │   │   ├── dependencies.cpp
    │       │   │   ├── dependencies.h
    │       │   │   ├── exprsimplifier.cpp
    │       │   │   ├── generatordefinition.cpp
    │       │   │   ├── generatordefinition.h
    │       │   │   ├── groupscript.cpp
    │       │   │   ├── ibaseprojectgenerator.h
    │       │   │   ├── ibasesolutiongenerator.h
    │       │   │   ├── macros.cpp
    │       │   │   ├── main.cpp
    │       │   │   ├── Makefile
    │       │   │   ├── p4sln.cpp
    │       │   │   ├── p4sln.h
    │       │   │   ├── projectgenerator_codelite.cpp
    │       │   │   ├── projectgenerator_codelite.h
    │       │   │   ├── projectgenerator_makefile.cpp
    │       │   │   ├── projectgenerator_ps3.cpp
    │       │   │   ├── projectgenerator_ps3.h
    │       │   │   ├── projectgenerator_ps3.inc
    │       │   │   ├── projectgenerator_vcproj.cpp
    │       │   │   ├── projectgenerator_vcproj.h
    │       │   │   ├── projectgenerator_win32.cpp
    │       │   │   ├── projectgenerator_win32.h
    │       │   │   ├── projectgenerator_win32.inc
    │       │   │   ├── projectgenerator_win32_2010.cpp
    │       │   │   ├── projectgenerator_win32_2010.h
    │       │   │   ├── projectgenerator_win32_2010.inc
    │       │   │   ├── projectgenerator_xbox360.cpp
    │       │   │   ├── projectgenerator_xbox360.h
    │       │   │   ├── projectgenerator_xbox360.inc
    │       │   │   ├── projectgenerator_xbox360_2010.cpp
    │       │   │   ├── projectgenerator_xbox360_2010.h
    │       │   │   ├── projectgenerator_xbox360_2010.inc
    │       │   │   ├── projectscript.cpp
    │       │   │   ├── scriptsource.cpp
    │       │   │   ├── scriptsource.h
    │       │   │   ├── solutiongenerator_codelite.cpp
    │       │   │   ├── solutiongenerator_makefile.cpp
    │       │   │   ├── solutiongenerator_win32.cpp
    │       │   │   ├── solutiongenerator_xcode.cpp
    │       │   │   ├── sys_utils.cpp
    │       │   │   ├── sys_utils.h
    │       │   │   ├── vpc.h
    │       │   │   ├── vpc.sln
    │       │   │   ├── vpc.vcxproj
    │       │   │   └── vpc.vcxproj.filters
    │       │   └── vpccrccheck/
    │       │       ├── crccheck_shared.cpp
    │       │       ├── crccheck_shared.h
    │       │       ├── vpccrccheck.cpp
    │       │       └── vpccrccheck.vpc
    │       └── vstdlib/
    │           ├── concommandhash.h
    │           ├── cvar.cpp
    │           ├── keyvaluessystem.cpp
    │           ├── random.cpp
    │           └── vstrtools.cpp
    ├── fgdlib/
    │   ├── fgdlib.vpc
    │   ├── gamedata.cpp
    │   ├── gdclass.cpp
    │   ├── gdvar.cpp
    │   ├── inputoutput.cpp
    │   └── wckeyvalues.cpp
    ├── filesystem/
    │   ├── basefilesystem.cpp
    │   ├── basefilesystem.h
    │   ├── filesystem_async.cpp
    │   ├── filesystem_stdio.cpp
    │   ├── filesystem_stdio.vpc
    │   ├── filesystem_steam.cpp
    │   ├── filesystem_steam.vpc
    │   ├── filetracker.cpp
    │   ├── filetracker.h
    │   ├── linux_support.cpp
    │   ├── linux_support.h
    │   ├── packfile.cpp
    │   ├── packfile.h
    │   ├── QueuedLoader.cpp
    │   ├── threadsaferefcountedobject.h
    │   ├── wscript
    │   ├── filesystem_stdio/
    │   │   └── ThreadSafeRefCountedObject.h
    │   └── xbox/
    │       └── xbox.def
    ├── game/
    │   ├── protobuf_include.vpc
    │   ├── client/
    │   │   ├── achievement_notification_panel.cpp
    │   │   ├── achievement_notification_panel.h
    │   │   ├── alphamaterialproxy.cpp
    │   │   ├── animatedentitytextureproxy.cpp
    │   │   ├── animatedoffsettextureproxy.cpp
    │   │   ├── animatedtextureproxy.cpp
    │   │   ├── AnimateSpecificTextureProxy.cpp
    │   │   ├── animationlayer.h
    │   │   ├── baseanimatedtextureproxy.cpp
    │   │   ├── baseanimatedtextureproxy.h
    │   │   ├── baseclientrendertargets.cpp
    │   │   ├── baseclientrendertargets.h
    │   │   ├── basepresence.cpp
    │   │   ├── basepresence.h
    │   │   ├── basepresence_xbox.cpp
    │   │   ├── beamdraw.cpp
    │   │   ├── beamdraw.h
    │   │   ├── bone_merge_cache.cpp
    │   │   ├── bone_merge_cache.h
    │   │   ├── bonetoworldarray.h
    │   │   ├── c_ai_basehumanoid.cpp
    │   │   ├── c_ai_basenpc.cpp
    │   │   ├── c_ai_basenpc.h
    │   │   ├── c_baseanimating.cpp
    │   │   ├── c_baseanimating.h
    │   │   ├── c_baseanimatingoverlay.cpp
    │   │   ├── c_baseanimatingoverlay.h
    │   │   ├── c_basecombatcharacter.cpp
    │   │   ├── c_basecombatcharacter.h
    │   │   ├── c_basecombatweapon.cpp
    │   │   ├── c_basecombatweapon.h
    │   │   ├── c_basedoor.cpp
    │   │   ├── c_basedoor.h
    │   │   ├── c_baseentity.cpp
    │   │   ├── c_baseentity.h
    │   │   ├── c_baseflex.cpp
    │   │   ├── c_baseflex.h
    │   │   ├── c_baseplayer.cpp
    │   │   ├── c_baseplayer.h
    │   │   ├── c_basetempentity.cpp
    │   │   ├── c_basetempentity.h
    │   │   ├── c_baseviewmodel.cpp
    │   │   ├── c_baseviewmodel.h
    │   │   ├── c_breakableprop.cpp
    │   │   ├── c_breakableprop.h
    │   │   ├── c_colorcorrection.cpp
    │   │   ├── c_colorcorrectionvolume.cpp
    │   │   ├── c_dynamiclight.cpp
    │   │   ├── c_effects.cpp
    │   │   ├── c_effects.h
    │   │   ├── c_entitydissolve.cpp
    │   │   ├── c_entitydissolve.h
    │   │   ├── c_entityparticletrail.cpp
    │   │   ├── c_env_fog_controller.cpp
    │   │   ├── c_env_fog_controller.h
    │   │   ├── c_env_particlescript.cpp
    │   │   ├── C_Env_Projected_Texture.h
    │   │   ├── c_env_projectedtexture.cpp
    │   │   ├── c_env_screenoverlay.cpp
    │   │   ├── c_env_tonemap_controller.cpp
    │   │   ├── c_fire_smoke.cpp
    │   │   ├── c_fire_smoke.h
    │   │   ├── c_fish.cpp
    │   │   ├── c_forcefeedback.cpp
    │   │   ├── c_func_areaportalwindow.cpp
    │   │   ├── c_func_breakablesurf.cpp
    │   │   ├── c_func_conveyor.cpp
    │   │   ├── c_func_dust.cpp
    │   │   ├── c_func_dust.h
    │   │   ├── c_func_lod.cpp
    │   │   ├── c_func_occluder.cpp
    │   │   ├── c_func_reflective_glass.cpp
    │   │   ├── c_func_reflective_glass.h
    │   │   ├── c_func_rotating.cpp
    │   │   ├── c_func_smokevolume.cpp
    │   │   ├── c_func_tracktrain.cpp
    │   │   ├── c_gib.cpp
    │   │   ├── c_gib.h
    │   │   ├── c_hairball.cpp
    │   │   ├── c_impact_effects.cpp
    │   │   ├── c_impact_effects.h
    │   │   ├── c_info_overlay_accessor.cpp
    │   │   ├── c_lightglow.cpp
    │   │   ├── C_MaterialModifyControl.cpp
    │   │   ├── c_movie_explosion.cpp
    │   │   ├── c_particle_fire.cpp
    │   │   ├── c_particle_smokegrenade.cpp
    │   │   ├── c_particle_system.cpp
    │   │   ├── c_physbox.cpp
    │   │   ├── c_physbox.h
    │   │   ├── c_physicsprop.cpp
    │   │   ├── c_physicsprop.h
    │   │   ├── c_physmagnet.cpp
    │   │   ├── c_pixel_visibility.cpp
    │   │   ├── c_pixel_visibility.h
    │   │   ├── c_plasma.cpp
    │   │   ├── c_playerlocaldata.h
    │   │   ├── c_playerresource.cpp
    │   │   ├── c_playerresource.h
    │   │   ├── c_point_camera.cpp
    │   │   ├── c_point_camera.h
    │   │   ├── c_point_commentary_node.cpp
    │   │   ├── c_prop_vehicle.cpp
    │   │   ├── c_prop_vehicle.h
    │   │   ├── c_props.cpp
    │   │   ├── c_props.h
    │   │   ├── c_ragdoll_manager.cpp
    │   │   ├── c_recipientfilter.cpp
    │   │   ├── c_recipientfilter.h
    │   │   ├── c_rope.cpp
    │   │   ├── c_rope.h
    │   │   ├── c_rumble.cpp
    │   │   ├── c_rumble.h
    │   │   ├── c_sceneentity.cpp
    │   │   ├── c_sceneentity.h
    │   │   ├── c_shadowcontrol.cpp
    │   │   ├── c_slideshow_display.cpp
    │   │   ├── c_slideshow_display.h
    │   │   ├── c_smoke_trail.cpp
    │   │   ├── c_smoke_trail.h
    │   │   ├── c_smokestack.cpp
    │   │   ├── c_soundscape.cpp
    │   │   ├── c_soundscape.h
    │   │   ├── c_spotlight_end.cpp
    │   │   ├── c_sprite.cpp
    │   │   ├── c_sprite.h
    │   │   ├── c_sprite_perfmonitor.cpp
    │   │   ├── c_steamjet.cpp
    │   │   ├── c_stickybolt.cpp
    │   │   ├── c_sun.cpp
    │   │   ├── c_sun.h
    │   │   ├── c_te.cpp
    │   │   ├── c_te_armorricochet.cpp
    │   │   ├── c_te_basebeam.cpp
    │   │   ├── c_te_basebeam.h
    │   │   ├── c_te_beamentpoint.cpp
    │   │   ├── c_te_beaments.cpp
    │   │   ├── c_te_beamfollow.cpp
    │   │   ├── c_te_beamlaser.cpp
    │   │   ├── c_te_beampoints.cpp
    │   │   ├── c_te_beamring.cpp
    │   │   ├── c_te_beamringpoint.cpp
    │   │   ├── c_te_beamspline.cpp
    │   │   ├── c_te_bloodsprite.cpp
    │   │   ├── c_te_bloodstream.cpp
    │   │   ├── c_te_breakmodel.cpp
    │   │   ├── c_te_bspdecal.cpp
    │   │   ├── c_te_bubbles.cpp
    │   │   ├── c_te_bubbletrail.cpp
    │   │   ├── c_te_clientprojectile.cpp
    │   │   ├── c_te_decal.cpp
    │   │   ├── c_te_dynamiclight.cpp
    │   │   ├── c_te_effect_dispatch.cpp
    │   │   ├── c_te_effect_dispatch.h
    │   │   ├── c_te_energysplash.cpp
    │   │   ├── c_te_explosion.cpp
    │   │   ├── c_te_fizz.cpp
    │   │   ├── c_te_footprint.cpp
    │   │   ├── c_te_glassshatter.cpp
    │   │   ├── c_te_glowsprite.cpp
    │   │   ├── c_te_impact.cpp
    │   │   ├── c_te_killplayerattachments.cpp
    │   │   ├── c_te_largefunnel.cpp
    │   │   ├── c_te_legacytempents.cpp
    │   │   ├── c_te_legacytempents.h
    │   │   ├── c_te_muzzleflash.cpp
    │   │   ├── c_te_particlesystem.cpp
    │   │   ├── c_te_particlesystem.h
    │   │   ├── c_te_physicsprop.cpp
    │   │   ├── c_te_playerdecal.cpp
    │   │   ├── c_te_projecteddecal.cpp
    │   │   ├── c_te_showline.cpp
    │   │   ├── c_te_smoke.cpp
    │   │   ├── c_te_sparks.cpp
    │   │   ├── c_te_sprite.cpp
    │   │   ├── c_te_spritespray.cpp
    │   │   ├── c_te_worlddecal.cpp
    │   │   ├── c_team.cpp
    │   │   ├── c_team.h
    │   │   ├── c_team_objectiveresource.cpp
    │   │   ├── c_team_objectiveresource.h
    │   │   ├── c_team_train_watcher.cpp
    │   │   ├── c_team_train_watcher.h
    │   │   ├── c_tesla.cpp
    │   │   ├── c_tesla.h
    │   │   ├── c_test_proxytoggle.cpp
    │   │   ├── c_testtraceline.cpp
    │   │   ├── c_tracer.cpp
    │   │   ├── c_tracer.h
    │   │   ├── c_user_message_register.cpp
    │   │   ├── c_user_message_register.h
    │   │   ├── c_vehicle_choreo_generic.cpp
    │   │   ├── c_vehicle_jeep.cpp
    │   │   ├── c_vehicle_jeep.h
    │   │   ├── c_vguiscreen.cpp
    │   │   ├── c_vguiscreen.h
    │   │   ├── c_vote_controller.cpp
    │   │   ├── c_vote_controller.h
    │   │   ├── C_WaterLODControl.cpp
    │   │   ├── c_weapon__stubs.h
    │   │   ├── c_world.cpp
    │   │   ├── c_world.h
    │   │   ├── camomaterialproxy.cpp
    │   │   ├── cbase.h
    │   │   ├── cdll_bounded_cvars.cpp
    │   │   ├── cdll_bounded_cvars.h
    │   │   ├── cdll_client_int.cpp
    │   │   ├── cdll_client_int.h
    │   │   ├── cdll_util.cpp
    │   │   ├── cdll_util.h
    │   │   ├── cl_animevent.h
    │   │   ├── cl_mat_stub.cpp
    │   │   ├── cl_mat_stub.h
    │   │   ├── classmap.cpp
    │   │   ├── client_base.vpc
    │   │   ├── client_cstrike.vpc
    │   │   ├── client_dod.vpc
    │   │   ├── client_episodic.vpc
    │   │   ├── client_factorylist.cpp
    │   │   ├── client_factorylist.h
    │   │   ├── client_hl1.vpc
    │   │   ├── client_hl1mp.vpc
    │   │   ├── client_hl2.vpc
    │   │   ├── client_hl2mp.vpc
    │   │   ├── client_portal.vpc
    │   │   ├── client_thinklist.cpp
    │   │   ├── client_thinklist.h
    │   │   ├── client_virtualreality.cpp
    │   │   ├── client_virtualreality.h
    │   │   ├── clienteffectprecachesystem.cpp
    │   │   ├── clienteffectprecachesystem.h
    │   │   ├── cliententitylist.cpp
    │   │   ├── cliententitylist.h
    │   │   ├── clientleafsystem.cpp
    │   │   ├── clientleafsystem.h
    │   │   ├── clientmode.h
    │   │   ├── clientmode_normal.cpp
    │   │   ├── clientmode_normal.h
    │   │   ├── clientmode_shared.cpp
    │   │   ├── clientmode_shared.h
    │   │   ├── clientshadowmgr.cpp
    │   │   ├── clientsideeffects.cpp
    │   │   ├── clientsideeffects.h
    │   │   ├── clientsideeffects_test.cpp
    │   │   ├── clientsteamcontext.cpp
    │   │   ├── clientsteamcontext.h
    │   │   ├── colorcorrectionmgr.cpp
    │   │   ├── colorcorrectionmgr.h
    │   │   ├── commentary_modelviewer.cpp
    │   │   ├── commentary_modelviewer.h
    │   │   ├── death.cpp
    │   │   ├── detailobjectsystem.cpp
    │   │   ├── detailobjectsystem.h
    │   │   ├── dummyproxy.cpp
    │   │   ├── EffectsClient.cpp
    │   │   ├── enginesprite.h
    │   │   ├── entity_client_tools.cpp
    │   │   ├── entityoriginmaterialproxy.cpp
    │   │   ├── flashlighteffect.cpp
    │   │   ├── flashlighteffect.h
    │   │   ├── fontabc.h
    │   │   ├── functionproxy.cpp
    │   │   ├── functionproxy.h
    │   │   ├── fx.cpp
    │   │   ├── fx.h
    │   │   ├── fx_blood.cpp
    │   │   ├── fx_blood.h
    │   │   ├── fx_cube.cpp
    │   │   ├── fx_discreetline.cpp
    │   │   ├── fx_discreetline.h
    │   │   ├── fx_envelope.cpp
    │   │   ├── fx_envelope.h
    │   │   ├── fx_explosion.cpp
    │   │   ├── fx_explosion.h
    │   │   ├── fx_fleck.cpp
    │   │   ├── fx_fleck.h
    │   │   ├── fx_impact.cpp
    │   │   ├── fx_impact.h
    │   │   ├── fx_interpvalue.cpp
    │   │   ├── fx_interpvalue.h
    │   │   ├── fx_line.cpp
    │   │   ├── fx_line.h
    │   │   ├── fx_quad.cpp
    │   │   ├── fx_quad.h
    │   │   ├── fx_shelleject.cpp
    │   │   ├── fx_sparks.cpp
    │   │   ├── fx_sparks.h
    │   │   ├── fx_staticline.cpp
    │   │   ├── fx_staticline.h
    │   │   ├── fx_tracer.cpp
    │   │   ├── fx_trail.cpp
    │   │   ├── fx_trail.h
    │   │   ├── fx_water.cpp
    │   │   ├── fx_water.h
    │   │   ├── gametrace_client.cpp
    │   │   ├── geiger.cpp
    │   │   ├── glow_outline_effect.cpp
    │   │   ├── glow_outline_effect.h
    │   │   ├── glow_overlay.cpp
    │   │   ├── glow_overlay.h
    │   │   ├── history_resource.cpp
    │   │   ├── history_resource.h
    │   │   ├── hltvcamera.cpp
    │   │   ├── hltvcamera.h
    │   │   ├── hud.cpp
    │   │   ├── hud.h
    │   │   ├── hud_animationinfo.cpp
    │   │   ├── hud_base_account.cpp
    │   │   ├── hud_base_account.h
    │   │   ├── hud_baseachievement_tracker.cpp
    │   │   ├── hud_baseachievement_tracker.h
    │   │   ├── hud_basechat.cpp
    │   │   ├── hud_basechat.h
    │   │   ├── hud_basedeathnotice.cpp
    │   │   ├── hud_basedeathnotice.h
    │   │   ├── hud_basetimer.cpp
    │   │   ├── hud_basetimer.h
    │   │   ├── hud_bitmapnumericdisplay.cpp
    │   │   ├── hud_bitmapnumericdisplay.h
    │   │   ├── hud_chat.cpp
    │   │   ├── hud_chat.h
    │   │   ├── hud_closecaption.cpp
    │   │   ├── hud_closecaption.h
    │   │   ├── hud_controlpointicons.cpp
    │   │   ├── hud_controlpointicons.h
    │   │   ├── hud_controlpointpanel.cpp
    │   │   ├── hud_crosshair.cpp
    │   │   ├── hud_crosshair.h
    │   │   ├── hud_element_helper.cpp
    │   │   ├── hud_element_helper.h
    │   │   ├── hud_hintdisplay.cpp
    │   │   ├── hud_lcd.cpp
    │   │   ├── hud_lcd.h
    │   │   ├── hud_macros.h
    │   │   ├── hud_msg.cpp
    │   │   ├── hud_numericdisplay.cpp
    │   │   ├── hud_numericdisplay.h
    │   │   ├── hud_pdump.cpp
    │   │   ├── hud_pdump.h
    │   │   ├── hud_posture.cpp
    │   │   ├── hud_redraw.cpp
    │   │   ├── hud_squadstatus.cpp
    │   │   ├── hud_vehicle.cpp
    │   │   ├── hud_vehicle.h
    │   │   ├── hud_vguiscreencursor.cpp
    │   │   ├── hud_voicestatus.cpp
    │   │   ├── hud_vote.cpp
    │   │   ├── hud_vote.h
    │   │   ├── hud_weapon.cpp
    │   │   ├── hudelement.h
    │   │   ├── hudtexturehandle.h
    │   │   ├── iclassmap.h
    │   │   ├── icliententityinternal.h
    │   │   ├── iclientmode.h
    │   │   ├── iclientshadowmgr.h
    │   │   ├── iclientvehicle.h
    │   │   ├── iconsole.h
    │   │   ├── idebugoverlaypanel.h
    │   │   ├── ifpspanel.h
    │   │   ├── ihudlcd.h
    │   │   ├── iinput.h
    │   │   ├── iloadingdisc.h
    │   │   ├── imessagechars.h
    │   │   ├── in_camera.cpp
    │   │   ├── in_forcefeedback.cpp
    │   │   ├── in_joystick.cpp
    │   │   ├── in_main.cpp
    │   │   ├── in_main.h
    │   │   ├── in_mouse.cpp
    │   │   ├── in_touch.cpp
    │   │   ├── inetgraphpanel.h
    │   │   ├── initializer.cpp
    │   │   ├── initializer.h
    │   │   ├── input.h
    │   │   ├── interpolatedvar.cpp
    │   │   ├── interpolatedvar.h
    │   │   ├── ipresence.h
    │   │   ├── iprofiling.h
    │   │   ├── IsNPCProxy.cpp
    │   │   ├── itextmessage.h
    │   │   ├── ivieweffects.h
    │   │   ├── iviewrender.h
    │   │   ├── iviewrender_beams.h
    │   │   ├── ivmodemanager.h
    │   │   ├── kbutton.h
    │   │   ├── lampbeamproxy.cpp
    │   │   ├── lamphaloproxy.cpp
    │   │   ├── lerp_functions.h
    │   │   ├── mathproxy.cpp
    │   │   ├── matrixproxy.cpp
    │   │   ├── menu.cpp
    │   │   ├── menu.h
    │   │   ├── message.cpp
    │   │   ├── MonitorMaterialProxy.cpp
    │   │   ├── movehelper_client.cpp
    │   │   ├── movehelper_client.h
    │   │   ├── mp3player.cpp
    │   │   ├── mp3player.h
    │   │   ├── mumble.cpp
    │   │   ├── mumble.h
    │   │   ├── networkstringtable_clientdll.h
    │   │   ├── panelmetaclassmgr.cpp
    │   │   ├── panelmetaclassmgr.h
    │   │   ├── particle_collision.cpp
    │   │   ├── particle_collision.h
    │   │   ├── particle_iterators.h
    │   │   ├── particle_litsmokeemitter.cpp
    │   │   ├── particle_litsmokeemitter.h
    │   │   ├── particle_prototype.cpp
    │   │   ├── particle_prototype.h
    │   │   ├── particle_proxies.cpp
    │   │   ├── particle_simple3d.cpp
    │   │   ├── particle_simple3d.h
    │   │   ├── particle_util.h
    │   │   ├── particledraw.h
    │   │   ├── particlemgr.cpp
    │   │   ├── particlemgr.h
    │   │   ├── particles_attractor.cpp
    │   │   ├── particles_attractor.h
    │   │   ├── particles_ez.cpp
    │   │   ├── particles_ez.h
    │   │   ├── particles_localspace.cpp
    │   │   ├── particles_localspace.h
    │   │   ├── particles_new.cpp
    │   │   ├── particles_new.h
    │   │   ├── particles_simple.cpp
    │   │   ├── particles_simple.h
    │   │   ├── particlesphererenderer.cpp
    │   │   ├── particlesphererenderer.h
    │   │   ├── perfvisualbenchmark.cpp
    │   │   ├── perfvisualbenchmark.h
    │   │   ├── physics.cpp
    │   │   ├── physics.h
    │   │   ├── physics_main_client.cpp
    │   │   ├── physpropclientside.cpp
    │   │   ├── physpropclientside.h
    │   │   ├── playerandobjectenumerator.cpp
    │   │   ├── playerandobjectenumerator.h
    │   │   ├── playerenumerator.h
    │   │   ├── playerspawncache.cpp
    │   │   ├── playerspawncache.h
    │   │   ├── prediction.cpp
    │   │   ├── prediction.h
    │   │   ├── prediction_private.h
    │   │   ├── proxyentity.cpp
    │   │   ├── proxyentity.h
    │   │   ├── ProxyHealth.cpp
    │   │   ├── proxyplayer.cpp
    │   │   ├── proxypupil.cpp
    │   │   ├── ragdoll.cpp
    │   │   ├── ragdoll.h
    │   │   ├── ragdollexplosionenumerator.h
    │   │   ├── recvproxy.cpp
    │   │   ├── recvproxy.h
    │   │   ├── rendertexture.cpp
    │   │   ├── rendertexture.h
    │   │   ├── ScreenSpaceEffects.cpp
    │   │   ├── ScreenSpaceEffects.h
    │   │   ├── simple_keys.cpp
    │   │   ├── simple_keys.h
    │   │   ├── smoke_fog_overlay.cpp
    │   │   ├── smoke_fog_overlay.h
    │   │   ├── splinepatch.cpp
    │   │   ├── splinepatch.h
    │   │   ├── spritemodel.cpp
    │   │   ├── stb_rect_pack.h
    │   │   ├── stdafx.cpp
    │   │   ├── studio_stats.cpp
    │   │   ├── studio_stats.h
    │   │   ├── TeamBitmapImage.cpp
    │   │   ├── TeamBitmapImage.h
    │   │   ├── tempent.h
    │   │   ├── text_message.cpp
    │   │   ├── text_message.h
    │   │   ├── texturescrollmaterialproxy.cpp
    │   │   ├── thermalmaterialproxy.cpp
    │   │   ├── timedevent.h
    │   │   ├── timematerialproxy.cpp
    │   │   ├── toggletextureproxy.cpp
    │   │   ├── toggletextureproxy.h
    │   │   ├── toolframework_client.cpp
    │   │   ├── toolframework_client.h
    │   │   ├── touch.cpp
    │   │   ├── touch.h
    │   │   ├── train.cpp
    │   │   ├── vgui_avatarimage.cpp
    │   │   ├── vgui_avatarimage.h
    │   │   ├── vgui_basepanel.cpp
    │   │   ├── vgui_basepanel.h
    │   │   ├── vgui_bitmapbutton.cpp
    │   │   ├── vgui_bitmapbutton.h
    │   │   ├── vgui_bitmapimage.cpp
    │   │   ├── vgui_bitmapimage.h
    │   │   ├── vgui_bitmappanel.cpp
    │   │   ├── vgui_bitmappanel.h
    │   │   ├── vgui_centerstringpanel.cpp
    │   │   ├── vgui_consolepanel.cpp
    │   │   ├── vgui_debugoverlaypanel.cpp
    │   │   ├── vgui_entityimagepanel.cpp
    │   │   ├── vgui_entityimagepanel.h
    │   │   ├── vgui_entitypanel.cpp
    │   │   ├── vgui_entitypanel.h
    │   │   ├── vgui_fpspanel.cpp
    │   │   ├── vgui_game_viewport.cpp
    │   │   ├── vgui_game_viewport.h
    │   │   ├── vgui_grid.cpp
    │   │   ├── vgui_grid.h
    │   │   ├── vgui_helpers.h
    │   │   ├── vgui_imagehealthpanel.cpp
    │   │   ├── vgui_imagehealthpanel.h
    │   │   ├── vgui_int.cpp
    │   │   ├── vgui_int.h
    │   │   ├── vgui_loadingdiscpanel.cpp
    │   │   ├── vgui_messagechars.cpp
    │   │   ├── vgui_netgraphpanel.cpp
    │   │   ├── vgui_schemevisualizer.cpp
    │   │   ├── vgui_schemevisualizer.h
    │   │   ├── vgui_slideshow_display_screen.cpp
    │   │   ├── vgui_textmessagepanel.cpp
    │   │   ├── vgui_video.cpp
    │   │   ├── vgui_video.h
    │   │   ├── vgui_video_player.cpp
    │   │   ├── vgui_video_player.h
    │   │   ├── vguicenterprint.h
    │   │   ├── view.cpp
    │   │   ├── view.h
    │   │   ├── view_beams.cpp
    │   │   ├── view_effects.cpp
    │   │   ├── view_scene.cpp
    │   │   ├── view_scene.h
    │   │   ├── viewangleanim.cpp
    │   │   ├── viewangleanim.h
    │   │   ├── ViewConeImage.cpp
    │   │   ├── ViewConeImage.h
    │   │   ├── viewdebug.cpp
    │   │   ├── viewdebug.h
    │   │   ├── viewpostprocess.cpp
    │   │   ├── viewpostprocess.h
    │   │   ├── viewrender.cpp
    │   │   ├── viewrender.h
    │   │   ├── voice_menu.cpp
    │   │   ├── warp_overlay.cpp
    │   │   ├── WaterLODMaterialProxy.cpp
    │   │   ├── weapon_selection.cpp
    │   │   ├── weapon_selection.h
    │   │   ├── weapons_resource.cpp
    │   │   ├── weapons_resource.h
    │   │   ├── WorldDimsProxy.cpp
    │   │   ├── wscript
    │   │   ├── cstrike/
    │   │   │   ├── c_cs_hostage.cpp
    │   │   │   ├── c_cs_hostage.h
    │   │   │   ├── c_cs_player.cpp
    │   │   │   ├── c_cs_player.h
    │   │   │   ├── c_cs_playerresource.cpp
    │   │   │   ├── c_cs_playerresource.h
    │   │   │   ├── c_cs_team.cpp
    │   │   │   ├── c_cs_team.h
    │   │   │   ├── c_csrootpanel.cpp
    │   │   │   ├── c_csrootpanel.h
    │   │   │   ├── c_plantedc4.cpp
    │   │   │   ├── c_plantedc4.h
    │   │   │   ├── c_te_radioicon.cpp
    │   │   │   ├── c_te_shotgun_shot.cpp
    │   │   │   ├── clientmode_csnormal.cpp
    │   │   │   ├── clientmode_csnormal.h
    │   │   │   ├── cs_client_gamestats.cpp
    │   │   │   ├── cs_client_gamestats.h
    │   │   │   ├── cs_hud_achievement_announce.cpp
    │   │   │   ├── cs_hud_achievement_announce.h
    │   │   │   ├── cs_hud_achievement_tracker.cpp
    │   │   │   ├── cs_hud_ammo.cpp
    │   │   │   ├── cs_hud_chat.cpp
    │   │   │   ├── cs_hud_chat.h
    │   │   │   ├── cs_hud_damageindicator.cpp
    │   │   │   ├── cs_hud_freezepanel.cpp
    │   │   │   ├── cs_hud_freezepanel.h
    │   │   │   ├── cs_hud_health.cpp
    │   │   │   ├── cs_hud_playerhealth.cpp
    │   │   │   ├── cs_hud_playerhealth.h
    │   │   │   ├── cs_hud_scope.cpp
    │   │   │   ├── cs_hud_target_id.cpp
    │   │   │   ├── cs_hud_weaponselection.cpp
    │   │   │   ├── cs_in_main.cpp
    │   │   │   ├── cs_prediction.cpp
    │   │   │   ├── cs_replay.cpp
    │   │   │   ├── cs_replay.h
    │   │   │   ├── cs_view_scene.cpp
    │   │   │   ├── cs_view_scene.h
    │   │   │   ├── fx_cs_blood.cpp
    │   │   │   ├── fx_cs_blood.h
    │   │   │   ├── fx_cs_impacts.cpp
    │   │   │   ├── fx_cs_knifeslash.cpp
    │   │   │   ├── fx_cs_muzzleflash.cpp
    │   │   │   ├── fx_cs_weaponfx.cpp
    │   │   │   ├── hud_account.cpp
    │   │   │   ├── hud_armor.cpp
    │   │   │   ├── hud_c4.cpp
    │   │   │   ├── hud_deathnotice.cpp
    │   │   │   ├── hud_defuser.cpp
    │   │   │   ├── hud_flashbang.cpp
    │   │   │   ├── hud_hostagerescue.cpp
    │   │   │   ├── hud_progressbar.cpp
    │   │   │   ├── hud_radar.cpp
    │   │   │   ├── hud_radar.h
    │   │   │   ├── hud_roundtimer.cpp
    │   │   │   ├── hud_scenarioicon.cpp
    │   │   │   ├── hud_shopping_cart.cpp
    │   │   │   ├── radio_status.cpp
    │   │   │   ├── radio_status.h
    │   │   │   ├── vgui_c4panel.cpp
    │   │   │   ├── vgui_rootpanel_cs.cpp
    │   │   │   ├── vgui_viewc4panel.cpp
    │   │   │   ├── buy_presets/
    │   │   │   │   ├── buy_preset.cpp
    │   │   │   │   ├── buy_preset_debug.cpp
    │   │   │   │   ├── buy_preset_debug.h
    │   │   │   │   ├── buy_preset_weapon_info.cpp
    │   │   │   │   ├── buy_presets.cpp
    │   │   │   │   └── buy_presets.h
    │   │   │   └── VGUI/
    │   │   │       ├── achievement_stats_summary.cpp
    │   │   │       ├── achievement_stats_summary.h
    │   │   │       ├── achievements_page.cpp
    │   │   │       ├── achievements_page.h
    │   │   │       ├── backgroundpanel.cpp
    │   │   │       ├── backgroundpanel.h
    │   │   │       ├── base_stats_page.cpp
    │   │   │       ├── base_stats_page.h
    │   │   │       ├── bordered_panel.cpp
    │   │   │       ├── bordered_panel.h
    │   │   │       ├── buymouseoverpanelbutton.h
    │   │   │       ├── buypreset_imageinfo.cpp
    │   │   │       ├── buypreset_listbox.cpp
    │   │   │       ├── buypreset_listbox.h
    │   │   │       ├── buypreset_panel.cpp
    │   │   │       ├── buypreset_weaponsetlabel.h
    │   │   │       ├── career_box.cpp
    │   │   │       ├── career_box.h
    │   │   │       ├── career_button.cpp
    │   │   │       ├── career_button.h
    │   │   │       ├── counterstrikeviewport.cpp
    │   │   │       ├── counterstrikeviewport.h
    │   │   │       ├── cstrikebuyequipmenu.cpp
    │   │   │       ├── cstrikebuyequipmenu.h
    │   │   │       ├── cstrikebuymenu.cpp
    │   │   │       ├── cstrikebuymenu.h
    │   │   │       ├── cstrikebuysubmenu.h
    │   │   │       ├── cstrikeclassmenu.cpp
    │   │   │       ├── cstrikeclassmenu.h
    │   │   │       ├── cstrikeclientscoreboard.cpp
    │   │   │       ├── cstrikeclientscoreboard.h
    │   │   │       ├── cstrikespectatorgui.cpp
    │   │   │       ├── cstrikespectatorgui.h
    │   │   │       ├── cstriketeammenu.cpp
    │   │   │       ├── cstriketeammenu.h
    │   │   │       ├── cstriketextwindow.cpp
    │   │   │       ├── cstriketextwindow.h
    │   │   │       ├── lifetime_stats_page.cpp
    │   │   │       ├── lifetime_stats_page.h
    │   │   │       ├── match_stats_page.cpp
    │   │   │       ├── match_stats_page.h
    │   │   │       ├── stat_card.cpp
    │   │   │       ├── stat_card.h
    │   │   │       ├── stats_summary.cpp
    │   │   │       ├── stats_summary.h
    │   │   │       ├── win_panel_round.cpp
    │   │   │       └── win_panel_round.h
    │   │   ├── dod/
    │   │   │   ├── c_dod_basegrenade.cpp
    │   │   │   ├── c_dod_basegrenade.h
    │   │   │   ├── c_dod_baserocket.cpp
    │   │   │   ├── c_dod_bombdispenser.cpp
    │   │   │   ├── c_dod_bombtarget.cpp
    │   │   │   ├── c_dod_bombtarget.h
    │   │   │   ├── c_dod_objective_resource.cpp
    │   │   │   ├── c_dod_objective_resource.h
    │   │   │   ├── c_dod_player.cpp
    │   │   │   ├── c_dod_player.h
    │   │   │   ├── c_dod_playerresource.cpp
    │   │   │   ├── c_dod_playerresource.h
    │   │   │   ├── c_dod_smokegrenade.cpp
    │   │   │   ├── c_dod_smokegrenade.h
    │   │   │   ├── c_dod_team.cpp
    │   │   │   ├── c_dod_team.h
    │   │   │   ├── c_grenadetrail.cpp
    │   │   │   ├── c_grenadetrail.h
    │   │   │   ├── c_te_firebullets.cpp
    │   │   │   ├── clientmode_dod.cpp
    │   │   │   ├── clientmode_dod.h
    │   │   │   ├── dod_fx_explosions.cpp
    │   │   │   ├── dod_headiconmanager.cpp
    │   │   │   ├── dod_headiconmanager.h
    │   │   │   ├── dod_hud_ammo.cpp
    │   │   │   ├── dod_hud_areacapicon.cpp
    │   │   │   ├── dod_hud_capturepanel.cpp
    │   │   │   ├── dod_hud_capturepanel.h
    │   │   │   ├── dod_hud_chat.cpp
    │   │   │   ├── dod_hud_chat.h
    │   │   │   ├── dod_hud_crosshair.cpp
    │   │   │   ├── dod_hud_crosshair.h
    │   │   │   ├── dod_hud_damageindicator.cpp
    │   │   │   ├── dod_hud_deathnotice.cpp
    │   │   │   ├── dod_hud_deathstats.cpp
    │   │   │   ├── dod_hud_deathstats.h
    │   │   │   ├── dod_hud_freezepanel.cpp
    │   │   │   ├── dod_hud_freezepanel.h
    │   │   │   ├── dod_hud_health.cpp
    │   │   │   ├── dod_hud_hintdisplay.cpp
    │   │   │   ├── dod_hud_history_resource.cpp
    │   │   │   ├── dod_hud_mgheaticon.cpp
    │   │   │   ├── dod_hud_objectiveicons.cpp
    │   │   │   ├── dod_hud_playerstatus_ammo.cpp
    │   │   │   ├── dod_hud_playerstatus_ammo.h
    │   │   │   ├── dod_hud_playerstatus_fireselect.cpp
    │   │   │   ├── dod_hud_playerstatus_fireselect.h
    │   │   │   ├── dod_hud_playerstatus_health.cpp
    │   │   │   ├── dod_hud_playerstatus_health.h
    │   │   │   ├── dod_hud_playerstatus_mgheat.cpp
    │   │   │   ├── dod_hud_playerstatus_mgheat.h
    │   │   │   ├── dod_hud_playerstatus_stamina.cpp
    │   │   │   ├── dod_hud_playerstatus_stamina.h
    │   │   │   ├── dod_hud_playerstatus_tnt.cpp
    │   │   │   ├── dod_hud_playerstatus_tnt.h
    │   │   │   ├── dod_hud_playerstatus_weapon.cpp
    │   │   │   ├── dod_hud_playerstatus_weapon.h
    │   │   │   ├── dod_hud_playerstatuspanel.cpp
    │   │   │   ├── dod_hud_readyrestart.cpp
    │   │   │   ├── dod_hud_restartround.cpp
    │   │   │   ├── dod_hud_scope.cpp
    │   │   │   ├── dod_hud_spec_crosshair.cpp
    │   │   │   ├── dod_hud_spec_crosshair.h
    │   │   │   ├── dod_hud_target_id.cpp
    │   │   │   ├── dod_hud_tnt_pickup.cpp
    │   │   │   ├── dod_hud_tnt_pickup.h
    │   │   │   ├── dod_hud_warmuplabel.cpp
    │   │   │   ├── dod_hud_weaponselection.cpp
    │   │   │   ├── dod_hud_winpanel.cpp
    │   │   │   ├── dod_hud_winpanel.h
    │   │   │   ├── dod_in_main.cpp
    │   │   │   ├── dod_playerstats.cpp
    │   │   │   ├── dod_playerstats.h
    │   │   │   ├── dod_prediction.cpp
    │   │   │   ├── dod_view_scene.cpp
    │   │   │   ├── dod_view_scene.h
    │   │   │   ├── fx_dod_blood.cpp
    │   │   │   ├── fx_dod_blood.h
    │   │   │   ├── fx_dod_ejectbrass.cpp
    │   │   │   ├── fx_dod_filmgrain.cpp
    │   │   │   ├── fx_dod_impact.cpp
    │   │   │   ├── fx_dod_knifeslash.cpp
    │   │   │   ├── fx_dod_muzzleflash.cpp
    │   │   │   ├── fx_dod_muzzleflash.h
    │   │   │   ├── fx_dod_tracers.cpp
    │   │   │   └── VGUI/
    │   │   │       ├── backgroundpanel.cpp
    │   │   │       ├── backgroundpanel.h
    │   │   │       ├── dodbutton.cpp
    │   │   │       ├── dodbutton.h
    │   │   │       ├── dodclassmenu.cpp
    │   │   │       ├── dodclassmenu.h
    │   │   │       ├── dodclientscoreboard.cpp
    │   │   │       ├── dodclientscoreboard.h
    │   │   │       ├── dodcornercutpanel.cpp
    │   │   │       ├── dodcornercutpanel.h
    │   │   │       ├── dodmenubackground.cpp
    │   │   │       ├── dodmenubackground.h
    │   │   │       ├── dodmouseoverpanelbutton.h
    │   │   │       ├── dodoverview.cpp
    │   │   │       ├── dodoverview.h
    │   │   │       ├── dodrandombutton.h
    │   │   │       ├── dodspectatorgui.cpp
    │   │   │       ├── dodspectatorgui.h
    │   │   │       ├── dodteammenu.cpp
    │   │   │       ├── dodteammenu.h
    │   │   │       ├── dodtextwindow.cpp
    │   │   │       ├── dodtextwindow.h
    │   │   │       ├── dodviewport.cpp
    │   │   │       ├── dodviewport.h
    │   │   │       ├── idodviewportmsgs.h
    │   │   │       ├── vgui_rootpanel_dod.cpp
    │   │   │       └── vgui_rootpanel_dod.h
    │   │   ├── episodic/
    │   │   │   ├── c_npc_advisor.cpp
    │   │   │   ├── c_npc_puppet.cpp
    │   │   │   ├── c_prop_coreball.cpp
    │   │   │   ├── c_prop_scalable.cpp
    │   │   │   ├── c_vehicle_jeep_episodic.cpp
    │   │   │   ├── c_vort_charge_token.cpp
    │   │   │   ├── c_weapon_hopwire.cpp
    │   │   │   ├── episodic_screenspaceeffects.cpp
    │   │   │   ├── episodic_screenspaceeffects.h
    │   │   │   └── flesh_internal_material_proxy.cpp
    │   │   ├── game_controls/
    │   │   │   ├── basemodel_panel.cpp
    │   │   │   ├── basemodel_panel.h
    │   │   │   ├── basemodelpanel.cpp
    │   │   │   ├── basemodelpanel.h
    │   │   │   ├── baseviewport.cpp
    │   │   │   ├── baseviewport.h
    │   │   │   ├── buymenu.cpp
    │   │   │   ├── buymenu.h
    │   │   │   ├── buysubmenu.cpp
    │   │   │   ├── buysubmenu.h
    │   │   │   ├── classmenu.cpp
    │   │   │   ├── classmenu.h
    │   │   │   ├── ClientScoreBoardDialog.cpp
    │   │   │   ├── clientscoreboarddialog.h
    │   │   │   ├── commandmenu.cpp
    │   │   │   ├── commandmenu.h
    │   │   │   ├── IconPanel.cpp
    │   │   │   ├── IconPanel.h
    │   │   │   ├── imagemouseoverbutton.h
    │   │   │   ├── intromenu.cpp
    │   │   │   ├── intromenu.h
    │   │   │   ├── MapOverview.cpp
    │   │   │   ├── mapoverview.h
    │   │   │   ├── mouseoverhtmlbutton.h
    │   │   │   ├── mouseoverpanelbutton.h
    │   │   │   ├── navigationpanel.cpp
    │   │   │   ├── navigationpanel.h
    │   │   │   ├── NavProgress.cpp
    │   │   │   ├── NavProgress.h
    │   │   │   ├── slideshowpanel.cpp
    │   │   │   ├── slideshowpanel.h
    │   │   │   ├── SpectatorGUI.cpp
    │   │   │   ├── spectatorgui.h
    │   │   │   ├── teammenu.cpp
    │   │   │   ├── teammenu.h
    │   │   │   ├── vguitextwindow.cpp
    │   │   │   └── vguitextwindow.h
    │   │   ├── hl1/
    │   │   │   ├── c_hl1mp_player.cpp
    │   │   │   ├── c_hl1mp_player.h
    │   │   │   ├── hl1_c_legacytempents.cpp
    │   │   │   ├── hl1_c_player.cpp
    │   │   │   ├── hl1_c_player.h
    │   │   │   ├── hl1_c_rpg_rocket.cpp
    │   │   │   ├── hl1_c_weapon__stubs.cpp
    │   │   │   ├── hl1_clientmode.cpp
    │   │   │   ├── hl1_clientmode.h
    │   │   │   ├── hl1_clientscoreboard.cpp
    │   │   │   ├── hl1_clientscoreboard.h
    │   │   │   ├── hl1_fx_gauss.cpp
    │   │   │   ├── hl1_fx_gibs.cpp
    │   │   │   ├── hl1_fx_impacts.cpp
    │   │   │   ├── hl1_fx_shelleject.cpp
    │   │   │   ├── hl1_hud_ammo.cpp
    │   │   │   ├── hl1_hud_battery.cpp
    │   │   │   ├── hl1_hud_damageindicator.cpp
    │   │   │   ├── hl1_hud_damagetiles.cpp
    │   │   │   ├── hl1_hud_deathnotice.cpp
    │   │   │   ├── hl1_hud_flashlight.cpp
    │   │   │   ├── hl1_hud_geiger.cpp
    │   │   │   ├── hl1_hud_health.cpp
    │   │   │   ├── hl1_hud_history_resource.cpp
    │   │   │   ├── hl1_hud_numbers.cpp
    │   │   │   ├── hl1_hud_numbers.h
    │   │   │   ├── hl1_hud_train.cpp
    │   │   │   └── hl1_hud_weaponselection.cpp
    │   │   ├── hl2/
    │   │   │   ├── c_antlion_dust.cpp
    │   │   │   ├── c_ar2_explosion.cpp
    │   │   │   ├── c_barnacle.cpp
    │   │   │   ├── c_barney.cpp
    │   │   │   ├── c_basehelicopter.cpp
    │   │   │   ├── c_basehelicopter.h
    │   │   │   ├── c_basehlcombatweapon.cpp
    │   │   │   ├── c_basehlcombatweapon.h
    │   │   │   ├── c_basehlplayer.cpp
    │   │   │   ├── c_basehlplayer.h
    │   │   │   ├── c_citadel_effects.cpp
    │   │   │   ├── c_corpse.cpp
    │   │   │   ├── c_corpse.h
    │   │   │   ├── c_energy_wave.cpp
    │   │   │   ├── c_env_alyxtemp.cpp
    │   │   │   ├── c_env_headcrabcanister.cpp
    │   │   │   ├── c_env_starfield.cpp
    │   │   │   ├── c_extinguisher.cpp
    │   │   │   ├── C_Func_Monitor.cpp
    │   │   │   ├── c_func_tankmortar.cpp
    │   │   │   ├── c_hl2_playerlocaldata.cpp
    │   │   │   ├── c_hl2_playerlocaldata.h
    │   │   │   ├── c_info_teleporter_countdown.cpp
    │   │   │   ├── c_npc_antlionguard.cpp
    │   │   │   ├── c_npc_combinegunship.cpp
    │   │   │   ├── c_npc_hydra.cpp
    │   │   │   ├── c_npc_manhack.cpp
    │   │   │   ├── c_npc_rollermine.cpp
    │   │   │   ├── c_plasma_beam_node.cpp
    │   │   │   ├── c_prop_combine_ball.cpp
    │   │   │   ├── c_prop_combine_ball.h
    │   │   │   ├── c_rotorwash.cpp
    │   │   │   ├── c_script_intro.cpp
    │   │   │   ├── c_strider.cpp
    │   │   │   ├── c_te_concussiveexplosion.cpp
    │   │   │   ├── c_te_flare.cpp
    │   │   │   ├── c_thumper_dust.cpp
    │   │   │   ├── c_vehicle_airboat.cpp
    │   │   │   ├── c_vehicle_cannon.cpp
    │   │   │   ├── c_vehicle_crane.cpp
    │   │   │   ├── c_vehicle_crane.h
    │   │   │   ├── c_vehicle_prisoner_pod.cpp
    │   │   │   ├── c_waterbullet.cpp
    │   │   │   ├── c_weapon__stubs_hl2.cpp
    │   │   │   ├── c_weapon_crossbow.cpp
    │   │   │   ├── c_weapon_gravitygun.cpp
    │   │   │   ├── c_weapon_physcannon.cpp
    │   │   │   ├── c_weapon_stunstick.cpp
    │   │   │   ├── clientmode_hlnormal.cpp
    │   │   │   ├── clientmode_hlnormal.h
    │   │   │   ├── fx_antlion.cpp
    │   │   │   ├── fx_bugbait.cpp
    │   │   │   ├── fx_hl2_impacts.cpp
    │   │   │   ├── fx_hl2_tracers.cpp
    │   │   │   ├── hl2_clientmode.cpp
    │   │   │   ├── hl_in_main.cpp
    │   │   │   ├── hl_prediction.cpp
    │   │   │   ├── hud_ammo.cpp
    │   │   │   ├── hud_autoaim.cpp
    │   │   │   ├── hud_battery.cpp
    │   │   │   ├── hud_blood.cpp
    │   │   │   ├── hud_bonusprogress.cpp
    │   │   │   ├── hud_credits.cpp
    │   │   │   ├── hud_damageindicator.cpp
    │   │   │   ├── hud_filmdemo.cpp
    │   │   │   ├── hud_flashlight.cpp
    │   │   │   ├── hud_hdrdemo.cpp
    │   │   │   ├── hud_health.cpp
    │   │   │   ├── hud_locator.cpp
    │   │   │   ├── hud_poisondamageindicator.cpp
    │   │   │   ├── hud_quickinfo.cpp
    │   │   │   ├── hud_radar.cpp
    │   │   │   ├── hud_radar.h
    │   │   │   ├── hud_suitpower.cpp
    │   │   │   ├── hud_suitpower.h
    │   │   │   ├── hud_weaponselection.cpp
    │   │   │   ├── hud_zoom.cpp
    │   │   │   ├── shieldproxy.cpp
    │   │   │   └── vgui_rootpanel_hl2.cpp
    │   │   ├── hl2mp/
    │   │   │   ├── c_hl2mp_player.cpp
    │   │   │   ├── c_hl2mp_player.h
    │   │   │   ├── c_te_hl2mp_shotgun_shot.cpp
    │   │   │   ├── clientmode_hl2mpnormal.cpp
    │   │   │   ├── clientmode_hl2mpnormal.h
    │   │   │   ├── hl2mp_hud_chat.cpp
    │   │   │   ├── hl2mp_hud_chat.h
    │   │   │   ├── hl2mp_hud_target_id.cpp
    │   │   │   ├── hl2mp_hud_team.cpp
    │   │   │   ├── hud_deathnotice.cpp
    │   │   │   └── ui/
    │   │   │       ├── backgroundpanel.cpp
    │   │   │       ├── backgroundpanel.h
    │   │   │       ├── hl2mpclientscoreboard.cpp
    │   │   │       ├── hl2mpclientscoreboard.h
    │   │   │       ├── hl2mptextwindow.cpp
    │   │   │       └── hl2mptextwindow.h
    │   │   ├── NextBot/
    │   │   │   ├── C_NextBot.cpp
    │   │   │   └── C_NextBot.h
    │   │   ├── portal/
    │   │   │   ├── c_env_lightraill_endpoint.cpp
    │   │   │   ├── c_env_portal_path_track.cpp
    │   │   │   ├── c_func_liquidportal.cpp
    │   │   │   ├── c_func_liquidportal.h
    │   │   │   ├── c_neurotoxin_countdown.cpp
    │   │   │   ├── c_neurotoxin_countdown.h
    │   │   │   ├── c_npc_portal_turret_floor.cpp
    │   │   │   ├── c_npc_rocket_turret.cpp
    │   │   │   ├── c_portal_player.cpp
    │   │   │   ├── c_portal_player.h
    │   │   │   ├── c_portal_radio.cpp
    │   │   │   ├── C_PortalGhostRenderable.cpp
    │   │   │   ├── C_PortalGhostRenderable.h
    │   │   │   ├── c_prop_energy_ball.cpp
    │   │   │   ├── c_prop_portal.cpp
    │   │   │   ├── c_prop_portal.h
    │   │   │   ├── c_prop_portal_stats_display.cpp
    │   │   │   ├── c_prop_portal_stats_display.h
    │   │   │   ├── c_weapon_physcannon.cpp
    │   │   │   ├── c_weapon_portalgun.cpp
    │   │   │   ├── c_weapon_portalgun.h
    │   │   │   ├── c_weapon_stubs_portal.cpp
    │   │   │   ├── clientmode_portal.cpp
    │   │   │   ├── clientmode_portal.h
    │   │   │   ├── fx_portal.cpp
    │   │   │   ├── hud_quickinfo.cpp
    │   │   │   ├── MaterialProxy_Portal_PickAlphaMask.cpp
    │   │   │   ├── materialproxy_portalstatic.cpp
    │   │   │   ├── portal_credits.cpp
    │   │   │   ├── Portal_DynamicMeshRenderingUtils.cpp
    │   │   │   ├── Portal_DynamicMeshRenderingUtils.h
    │   │   │   ├── portal_hud_crosshair.cpp
    │   │   │   ├── portal_hud_crosshair.h
    │   │   │   ├── portal_render_targets.cpp
    │   │   │   ├── portal_render_targets.h
    │   │   │   ├── PortalRender.cpp
    │   │   │   ├── PortalRender.h
    │   │   │   ├── portalrenderable_flatbasic.cpp
    │   │   │   ├── portalrenderable_flatbasic.h
    │   │   │   ├── vgui_neurotoxin_countdown_screen.cpp
    │   │   │   └── vgui_portal_stats_display_screen.cpp
    │   │   ├── replay/
    │   │   │   ├── cdll_replay.cpp
    │   │   │   ├── cdll_replay.h
    │   │   │   ├── gamedefs.cpp
    │   │   │   ├── gamedefs.h
    │   │   │   ├── genericclassbased_replay.cpp
    │   │   │   ├── genericclassbased_replay.h
    │   │   │   ├── replay_ragdoll.cpp
    │   │   │   ├── replay_ragdoll.h
    │   │   │   ├── replay_screenshot.cpp
    │   │   │   ├── replay_screenshot.h
    │   │   │   ├── replaycamera.cpp
    │   │   │   ├── replaycamera.h
    │   │   │   ├── replayperformanceplaybackhandler.cpp
    │   │   │   ├── replayperformanceplaybackhandler.h
    │   │   │   ├── replayrenderer.cpp
    │   │   │   ├── replayrenderer.h
    │   │   │   ├── replayvideo.cpp
    │   │   │   ├── replayvideo.h
    │   │   │   ├── replayyoutubeapi.cpp
    │   │   │   ├── replayyoutubeapi.h
    │   │   │   ├── replayyoutubeapi_key_sdk.cpp
    │   │   │   └── vgui/
    │   │   │       ├── replaybrowserbasepage.cpp
    │   │   │       ├── replaybrowserbasepage.h
    │   │   │       ├── replaybrowserbasepanel.cpp
    │   │   │       ├── replaybrowserbasepanel.h
    │   │   │       ├── replaybrowserdetailspanel.cpp
    │   │   │       ├── replaybrowserdetailspanel.h
    │   │   │       ├── replaybrowseritemmanager.cpp
    │   │   │       ├── replaybrowseritemmanager.h
    │   │   │       ├── replaybrowserlistitempanel.cpp
    │   │   │       ├── replaybrowserlistitempanel.h
    │   │   │       ├── replaybrowserlistpanel.cpp
    │   │   │       ├── replaybrowserlistpanel.h
    │   │   │       ├── replaybrowsermainpanel.cpp
    │   │   │       ├── replaybrowsermainpanel.h
    │   │   │       ├── replaybrowsermovieplayerpanel.cpp
    │   │   │       ├── replaybrowsermovieplayerpanel.h
    │   │   │       ├── replaybrowserpreviewpanel.cpp
    │   │   │       ├── replaybrowserpreviewpanel.h
    │   │   │       ├── replaybrowserrenderdialog.cpp
    │   │   │       ├── replaybrowserrenderdialog.h
    │   │   │       ├── replayconfirmquitdlg.cpp
    │   │   │       ├── replayconfirmquitdlg.h
    │   │   │       ├── replayinputpanel.cpp
    │   │   │       ├── replayinputpanel.h
    │   │   │       ├── replaymessagepanel.cpp
    │   │   │       ├── replaymessagepanel.h
    │   │   │       ├── replayperformanceeditor.cpp
    │   │   │       ├── replayperformanceeditor.h
    │   │   │       ├── replayperformancesavedlg.cpp
    │   │   │       ├── replayperformancesavedlg.h
    │   │   │       ├── replayreminderpanel.cpp
    │   │   │       ├── replayreminderpanel.h
    │   │   │       ├── replayrenderoverlay.cpp
    │   │   │       └── replayrenderoverlay.h
    │   │   ├── sdk/
    │   │   │   ├── c_sdk_env_sparkler.cpp
    │   │   │   ├── c_sdk_player.cpp
    │   │   │   ├── c_sdk_player.h
    │   │   │   ├── c_sdk_team.cpp
    │   │   │   ├── c_sdk_team.h
    │   │   │   ├── c_te_firebullets.cpp
    │   │   │   ├── clientmode_sdk.cpp
    │   │   │   ├── clientmode_sdk.h
    │   │   │   ├── sdk_fx_impacts.cpp
    │   │   │   ├── sdk_fx_weaponfx.cpp
    │   │   │   ├── sdk_hud_ammo.cpp
    │   │   │   ├── sdk_hud_chat.cpp
    │   │   │   ├── sdk_hud_chat.h
    │   │   │   ├── sdk_hud_health.cpp
    │   │   │   ├── sdk_hud_message.cpp
    │   │   │   ├── sdk_hud_weaponselection.cpp
    │   │   │   ├── sdk_in_main.cpp
    │   │   │   ├── sdk_prediction.cpp
    │   │   │   └── vgui/
    │   │   │       ├── sdkviewport.cpp
    │   │   │       ├── sdkviewport.h
    │   │   │       ├── vgui_rootpanel_sdk.cpp
    │   │   │       └── vgui_rootpanel_sdk.h
    │   │   └── sixense/
    │   │       ├── in_sixense.cpp
    │   │       ├── in_sixense.h
    │   │       ├── in_sixense_gesture_bindings.cpp
    │   │       └── in_sixense_gesture_bindings.h
    │   ├── server/
    │   │   ├── actanimating.cpp
    │   │   ├── actanimating.h
    │   │   ├── ai_activity.cpp
    │   │   ├── ai_baseactor.cpp
    │   │   ├── ai_baseactor.h
    │   │   ├── ai_basehumanoid.cpp
    │   │   ├── ai_basehumanoid.h
    │   │   ├── ai_basenpc.h
    │   │   ├── ai_basenpc_flyer.cpp
    │   │   ├── ai_basenpc_flyer.h
    │   │   ├── ai_basenpc_flyer_new.cpp
    │   │   ├── ai_basenpc_flyer_new.h
    │   │   ├── ai_basenpc_movement.cpp
    │   │   ├── ai_basenpc_physicsflyer.cpp
    │   │   ├── ai_basenpc_physicsflyer.h
    │   │   ├── ai_basenpc_schedule.cpp
    │   │   ├── ai_basenpc_squad.cpp
    │   │   ├── ai_behavior.cpp
    │   │   ├── ai_behavior.h
    │   │   ├── ai_behavior_assault.cpp
    │   │   ├── ai_behavior_assault.h
    │   │   ├── ai_behavior_fear.cpp
    │   │   ├── ai_behavior_fear.h
    │   │   ├── ai_behavior_follow.cpp
    │   │   ├── ai_behavior_follow.h
    │   │   ├── ai_behavior_lead.cpp
    │   │   ├── ai_behavior_lead.h
    │   │   ├── ai_behavior_passenger.cpp
    │   │   ├── ai_behavior_passenger.h
    │   │   ├── ai_behavior_rappel.cpp
    │   │   ├── ai_behavior_rappel.h
    │   │   ├── ai_behavior_standoff.cpp
    │   │   ├── ai_behavior_standoff.h
    │   │   ├── ai_blended_movement.cpp
    │   │   ├── ai_blended_movement.h
    │   │   ├── ai_component.h
    │   │   ├── ai_concommands.cpp
    │   │   ├── ai_condition.cpp
    │   │   ├── ai_condition.h
    │   │   ├── AI_Criteria.cpp
    │   │   ├── AI_Criteria.h
    │   │   ├── ai_debug.h
    │   │   ├── ai_default.cpp
    │   │   ├── ai_default.h
    │   │   ├── ai_dynamiclink.cpp
    │   │   ├── ai_dynamiclink.h
    │   │   ├── ai_event.cpp
    │   │   ├── ai_eventresponse.cpp
    │   │   ├── ai_eventresponse.h
    │   │   ├── ai_goalentity.cpp
    │   │   ├── ai_goalentity.h
    │   │   ├── ai_hint.cpp
    │   │   ├── ai_hint.h
    │   │   ├── ai_hull.cpp
    │   │   ├── ai_hull.h
    │   │   ├── ai_initutils.cpp
    │   │   ├── ai_initutils.h
    │   │   ├── AI_Interest_Target.cpp
    │   │   ├── AI_Interest_Target.h
    │   │   ├── ai_link.cpp
    │   │   ├── ai_link.h
    │   │   ├── ai_localnavigator.cpp
    │   │   ├── ai_localnavigator.h
    │   │   ├── ai_looktarget.cpp
    │   │   ├── ai_looktarget.h
    │   │   ├── ai_memory.cpp
    │   │   ├── ai_memory.h
    │   │   ├── ai_motor.cpp
    │   │   ├── ai_motor.h
    │   │   ├── ai_moveprobe.cpp
    │   │   ├── ai_moveprobe.h
    │   │   ├── ai_moveshoot.cpp
    │   │   ├── ai_moveshoot.h
    │   │   ├── ai_movesolver.cpp
    │   │   ├── ai_movesolver.h
    │   │   ├── ai_movetypes.h
    │   │   ├── ai_namespaces.cpp
    │   │   ├── ai_namespaces.h
    │   │   ├── ai_navgoaltype.h
    │   │   ├── ai_navigator.cpp
    │   │   ├── ai_navigator.h
    │   │   ├── ai_navtype.h
    │   │   ├── ai_network.cpp
    │   │   ├── ai_network.h
    │   │   ├── ai_networkmanager.cpp
    │   │   ├── ai_networkmanager.h
    │   │   ├── ai_node.cpp
    │   │   ├── ai_node.h
    │   │   ├── ai_npcstate.h
    │   │   ├── ai_obstacle_type.h
    │   │   ├── ai_pathfinder.cpp
    │   │   ├── ai_pathfinder.h
    │   │   ├── ai_planesolver.cpp
    │   │   ├── ai_planesolver.h
    │   │   ├── ai_playerally.cpp
    │   │   ├── ai_playerally.h
    │   │   ├── ai_relationship.cpp
    │   │   ├── AI_ResponseSystem.cpp
    │   │   ├── AI_ResponseSystem.h
    │   │   ├── ai_route.cpp
    │   │   ├── ai_route.h
    │   │   ├── ai_routedist.h
    │   │   ├── ai_saverestore.cpp
    │   │   ├── ai_saverestore.h
    │   │   ├── ai_schedule.cpp
    │   │   ├── ai_schedule.h
    │   │   ├── ai_scriptconditions.cpp
    │   │   ├── ai_scriptconditions.h
    │   │   ├── ai_senses.cpp
    │   │   ├── ai_senses.h
    │   │   ├── ai_sentence.cpp
    │   │   ├── ai_sentence.h
    │   │   ├── ai_speech.cpp
    │   │   ├── ai_speech.h
    │   │   ├── ai_speechfilter.cpp
    │   │   ├── ai_speechfilter.h
    │   │   ├── ai_squad.cpp
    │   │   ├── ai_squad.h
    │   │   ├── ai_squadslot.cpp
    │   │   ├── ai_squadslot.h
    │   │   ├── ai_tacticalservices.cpp
    │   │   ├── ai_tacticalservices.h
    │   │   ├── ai_task.cpp
    │   │   ├── ai_task.h
    │   │   ├── ai_trackpather.cpp
    │   │   ├── ai_trackpather.h
    │   │   ├── ai_utils.cpp
    │   │   ├── ai_utils.h
    │   │   ├── ai_waypoint.cpp
    │   │   ├── ai_waypoint.h
    │   │   ├── base_gameinterface.cpp
    │   │   ├── base_transmit_proxy.cpp
    │   │   ├── base_transmit_proxy.h
    │   │   ├── baseanimating.cpp
    │   │   ├── baseanimating.h
    │   │   ├── BaseAnimatingOverlay.cpp
    │   │   ├── BaseAnimatingOverlay.h
    │   │   ├── basebludgeonweapon.cpp
    │   │   ├── basebludgeonweapon.h
    │   │   ├── basecombatcharacter.cpp
    │   │   ├── basecombatcharacter.h
    │   │   ├── basecombatweapon.cpp
    │   │   ├── basecombatweapon.h
    │   │   ├── baseentity.cpp
    │   │   ├── baseentity.h
    │   │   ├── baseflex.cpp
    │   │   ├── baseflex.h
    │   │   ├── basegrenade_concussion.cpp
    │   │   ├── basegrenade_contact.cpp
    │   │   ├── basegrenade_timed.cpp
    │   │   ├── basemultiplayerplayer.cpp
    │   │   ├── basemultiplayerplayer.h
    │   │   ├── BasePropDoor.h
    │   │   ├── basetempentity.cpp
    │   │   ├── basetempentity.h
    │   │   ├── basetoggle.h
    │   │   ├── baseviewmodel.cpp
    │   │   ├── baseviewmodel.h
    │   │   ├── bitstring.cpp
    │   │   ├── bitstring.h
    │   │   ├── bmodels.cpp
    │   │   ├── buttons.cpp
    │   │   ├── buttons.h
    │   │   ├── cbase.cpp
    │   │   ├── cbase.h
    │   │   ├── client.cpp
    │   │   ├── client.h
    │   │   ├── colorcorrection.cpp
    │   │   ├── colorcorrectionvolume.cpp
    │   │   ├── CommentarySystem.cpp
    │   │   ├── controlentities.cpp
    │   │   ├── cplane.cpp
    │   │   ├── cplane.h
    │   │   ├── CRagdollMagnet.cpp
    │   │   ├── CRagdollMagnet.h
    │   │   ├── damagemodifier.cpp
    │   │   ├── damagemodifier.h
    │   │   ├── data_collector.cpp
    │   │   ├── data_collector.h
    │   │   ├── doors.cpp
    │   │   ├── doors.h
    │   │   ├── dynamiclight.cpp
    │   │   ├── effects.cpp
    │   │   ├── effects.h
    │   │   ├── EffectsServer.cpp
    │   │   ├── enginecallback.h
    │   │   ├── entity_tools_server.cpp
    │   │   ├── entityapi.h
    │   │   ├── entityblocker.cpp
    │   │   ├── entityblocker.h
    │   │   ├── EntityDissolve.cpp
    │   │   ├── EntityDissolve.h
    │   │   ├── EntityFlame.cpp
    │   │   ├── EntityFlame.h
    │   │   ├── entityinput.h
    │   │   ├── entitylist.cpp
    │   │   ├── entitylist.h
    │   │   ├── entityoutput.h
    │   │   ├── EntityParticleTrail.cpp
    │   │   ├── EntityParticleTrail.h
    │   │   ├── env_debughistory.cpp
    │   │   ├── env_debughistory.h
    │   │   ├── env_effectsscript.cpp
    │   │   ├── env_entity_maker.cpp
    │   │   ├── env_particlescript.cpp
    │   │   ├── env_player_surface_trigger.cpp
    │   │   ├── env_player_surface_trigger.h
    │   │   ├── env_projectedtexture.cpp
    │   │   ├── env_screenoverlay.cpp
    │   │   ├── env_texturetoggle.cpp
    │   │   ├── env_tonemap_controller.cpp
    │   │   ├── env_zoom.cpp
    │   │   ├── env_zoom.h
    │   │   ├── EnvBeam.cpp
    │   │   ├── EnvFade.cpp
    │   │   ├── EnvHudHint.cpp
    │   │   ├── EnvLaser.cpp
    │   │   ├── EnvLaser.h
    │   │   ├── EnvMessage.cpp
    │   │   ├── EnvMessage.h
    │   │   ├── envmicrophone.cpp
    │   │   ├── envmicrophone.h
    │   │   ├── EnvShake.cpp
    │   │   ├── EnvSpark.cpp
    │   │   ├── envspark.h
    │   │   ├── event_tempentity_tester.cpp
    │   │   ├── event_tempentity_tester.h
    │   │   ├── EventLog.cpp
    │   │   ├── EventLog.h
    │   │   ├── eventqueue.h
    │   │   ├── explode.cpp
    │   │   ├── explode.h
    │   │   ├── filters.cpp
    │   │   ├── filters.h
    │   │   ├── fire.cpp
    │   │   ├── fire.h
    │   │   ├── fire_smoke.cpp
    │   │   ├── fire_smoke.h
    │   │   ├── fish.cpp
    │   │   ├── fish.h
    │   │   ├── fogcontroller.cpp
    │   │   ├── fogcontroller.h
    │   │   ├── forcefeedback.cpp
    │   │   ├── fourwheelvehiclephysics.cpp
    │   │   ├── fourwheelvehiclephysics.h
    │   │   ├── func_areaportal.cpp
    │   │   ├── func_areaportalbase.cpp
    │   │   ├── func_areaportalbase.h
    │   │   ├── func_areaportalwindow.cpp
    │   │   ├── func_areaportalwindow.h
    │   │   ├── func_break.cpp
    │   │   ├── func_break.h
    │   │   ├── func_breakablesurf.cpp
    │   │   ├── func_breakablesurf.h
    │   │   ├── func_dust.cpp
    │   │   ├── func_ladder_endpoint.cpp
    │   │   ├── func_lod.cpp
    │   │   ├── func_movelinear.cpp
    │   │   ├── func_movelinear.h
    │   │   ├── func_occluder.cpp
    │   │   ├── func_reflective_glass.cpp
    │   │   ├── func_smokevolume.cpp
    │   │   ├── functorutils.h
    │   │   ├── game.cpp
    │   │   ├── game.h
    │   │   ├── game_ui.cpp
    │   │   ├── gamedll_replay.cpp
    │   │   ├── gamehandle.cpp
    │   │   ├── gameinterface.cpp
    │   │   ├── gameinterface.h
    │   │   ├── GameStats.cpp
    │   │   ├── GameStats_BasicStatsFunctions.cpp
    │   │   ├── gametrace_dll.cpp
    │   │   ├── gameweaponmanager.cpp
    │   │   ├── gameweaponmanager.h
    │   │   ├── genericactor.cpp
    │   │   ├── genericmonster.cpp
    │   │   ├── gib.cpp
    │   │   ├── gib.h
    │   │   ├── globals.cpp
    │   │   ├── globals.h
    │   │   ├── globalstate.cpp
    │   │   ├── globalstate.h
    │   │   ├── globalstate_private.h
    │   │   ├── grenadethrown.cpp
    │   │   ├── grenadethrown.h
    │   │   ├── guntarget.cpp
    │   │   ├── h_ai.cpp
    │   │   ├── h_cycler.cpp
    │   │   ├── h_cycler.h
    │   │   ├── h_export.cpp
    │   │   ├── hierarchy.cpp
    │   │   ├── hierarchy.h
    │   │   ├── hl1_CBaseHelicopter.h
    │   │   ├── hltvdirector.cpp
    │   │   ├── hltvdirector.h
    │   │   ├── ilagcompensationmanager.h
    │   │   ├── info_camera_link.cpp
    │   │   ├── info_camera_link.h
    │   │   ├── info_overlay_accessor.cpp
    │   │   ├── init_factory.cpp
    │   │   ├── init_factory.h
    │   │   ├── intermission.cpp
    │   │   ├── iscorer.h
    │   │   ├── iservervehicle.h
    │   │   ├── item_world.cpp
    │   │   ├── items.h
    │   │   ├── lightglow.cpp
    │   │   ├── lights.cpp
    │   │   ├── lights.h
    │   │   ├── locksounds.h
    │   │   ├── logic_achievement.cpp
    │   │   ├── logic_measure_movement.cpp
    │   │   ├── logic_mirror_movement.cpp
    │   │   ├── logic_navigation.cpp
    │   │   ├── logicauto.cpp
    │   │   ├── logicentities.cpp
    │   │   ├── logicrelay.cpp
    │   │   ├── logicrelay.h
    │   │   ├── mapentities.cpp
    │   │   ├── mapentities.h
    │   │   ├── maprules.cpp
    │   │   ├── maprules.h
    │   │   ├── MaterialModifyControl.cpp
    │   │   ├── message_entity.cpp
    │   │   ├── modelentities.cpp
    │   │   ├── modelentities.h
    │   │   ├── monstermaker.cpp
    │   │   ├── monstermaker.h
    │   │   ├── movehelper_server.cpp
    │   │   ├── movehelper_server.h
    │   │   ├── movement.cpp
    │   │   ├── movie_explosion.cpp
    │   │   ├── movie_explosion.h
    │   │   ├── nav.h
    │   │   ├── nav_area.cpp
    │   │   ├── nav_area.h
    │   │   ├── nav_colors.cpp
    │   │   ├── nav_colors.h
    │   │   ├── nav_edit.cpp
    │   │   ├── nav_entities.cpp
    │   │   ├── nav_entities.h
    │   │   ├── nav_file.cpp
    │   │   ├── nav_generate.cpp
    │   │   ├── nav_ladder.cpp
    │   │   ├── nav_ladder.h
    │   │   ├── nav_merge.cpp
    │   │   ├── nav_mesh.cpp
    │   │   ├── nav_mesh.h
    │   │   ├── nav_mesh.vpc
    │   │   ├── nav_mesh_factory.cpp
    │   │   ├── nav_node.cpp
    │   │   ├── nav_node.h
    │   │   ├── nav_pathfind.h
    │   │   ├── nav_simplify.cpp
    │   │   ├── ndebugoverlay.cpp
    │   │   ├── ndebugoverlay.h
    │   │   ├── networkstringtable_gamedll.h
    │   │   ├── npc_talker.cpp
    │   │   ├── npc_talker.h
    │   │   ├── npc_vehicledriver.cpp
    │   │   ├── npc_vehicledriver.h
    │   │   ├── particle_fire.cpp
    │   │   ├── particle_fire.h
    │   │   ├── particle_light.cpp
    │   │   ├── particle_light.h
    │   │   ├── particle_smokegrenade.cpp
    │   │   ├── particle_smokegrenade.h
    │   │   ├── particle_system.cpp
    │   │   ├── particle_system.h
    │   │   ├── pathcorner.cpp
    │   │   ├── pathtrack.cpp
    │   │   ├── pathtrack.h
    │   │   ├── phys_controller.cpp
    │   │   ├── phys_controller.h
    │   │   ├── physconstraint.cpp
    │   │   ├── physconstraint.h
    │   │   ├── physconstraint_sounds.h
    │   │   ├── physgun.cpp
    │   │   ├── physics.cpp
    │   │   ├── physics.h
    │   │   ├── physics_bone_follower.cpp
    │   │   ├── physics_bone_follower.h
    │   │   ├── physics_cannister.cpp
    │   │   ├── physics_cannister.h
    │   │   ├── physics_collisionevent.h
    │   │   ├── physics_fx.cpp
    │   │   ├── physics_fx.h
    │   │   ├── physics_impact_damage.cpp
    │   │   ├── physics_impact_damage.h
    │   │   ├── physics_main.cpp
    │   │   ├── physics_npc_solver.cpp
    │   │   ├── physics_npc_solver.h
    │   │   ├── physics_prop_ragdoll.cpp
    │   │   ├── physics_prop_ragdoll.h
    │   │   ├── physobj.cpp
    │   │   ├── physobj.h
    │   │   ├── plasma.cpp
    │   │   ├── plasma.h
    │   │   ├── player.h
    │   │   ├── player_command.cpp
    │   │   ├── player_command.h
    │   │   ├── player_lagcompensation.cpp
    │   │   ├── player_pickup.cpp
    │   │   ├── player_pickup.h
    │   │   ├── player_resource.cpp
    │   │   ├── player_resource.h
    │   │   ├── playerinfomanager.cpp
    │   │   ├── playerinfomanager.h
    │   │   ├── playerlocaldata.cpp
    │   │   ├── playerlocaldata.h
    │   │   ├── plugin_check.cpp
    │   │   ├── point_camera.cpp
    │   │   ├── point_camera.h
    │   │   ├── point_devshot_camera.cpp
    │   │   ├── point_playermoveconstraint.cpp
    │   │   ├── point_spotlight.cpp
    │   │   ├── point_template.cpp
    │   │   ├── point_template.h
    │   │   ├── pointanglesensor.cpp
    │   │   ├── PointAngularVelocitySensor.cpp
    │   │   ├── pointhurt.cpp
    │   │   ├── pointteleport.cpp
    │   │   ├── props.cpp
    │   │   ├── props.h
    │   │   ├── pushentity.h
    │   │   ├── ragdoll_manager.cpp
    │   │   ├── RagdollBoogie.cpp
    │   │   ├── RagdollBoogie.h
    │   │   ├── recipientfilter.cpp
    │   │   ├── recipientfilter.h
    │   │   ├── rope.cpp
    │   │   ├── rope.h
    │   │   ├── saverestore_gamedll.cpp
    │   │   ├── sceneentity.cpp
    │   │   ├── sceneentity.h
    │   │   ├── scratchpad_gamedll_helpers.cpp
    │   │   ├── scratchpad_gamedll_helpers.h
    │   │   ├── scripted.cpp
    │   │   ├── scripted.h
    │   │   ├── scriptedtarget.cpp
    │   │   ├── scriptedtarget.h
    │   │   ├── sendproxy.cpp
    │   │   ├── sendproxy.h
    │   │   ├── server_base.vpc
    │   │   ├── server_cstrike.vpc
    │   │   ├── server_dod.vpc
    │   │   ├── server_episodic.vpc
    │   │   ├── server_hl1.vpc
    │   │   ├── server_hl1mp.vpc
    │   │   ├── server_hl2.vpc
    │   │   ├── server_hl2mp.vpc
    │   │   ├── server_portal.vpc
    │   │   ├── serverbenchmark_base.cpp
    │   │   ├── serverbenchmark_base.h
    │   │   ├── ServerNetworkProperty.cpp
    │   │   ├── ServerNetworkProperty.h
    │   │   ├── shadowcontrol.cpp
    │   │   ├── SkyCamera.cpp
    │   │   ├── SkyCamera.h
    │   │   ├── slideshow_display.cpp
    │   │   ├── smoke_trail.cpp
    │   │   ├── smoke_trail.h
    │   │   ├── smokestack.cpp
    │   │   ├── smokestack.h
    │   │   ├── sound.cpp
    │   │   ├── soundent.cpp
    │   │   ├── soundent.h
    │   │   ├── soundscape.cpp
    │   │   ├── soundscape.h
    │   │   ├── soundscape_system.cpp
    │   │   ├── soundscape_system.h
    │   │   ├── spark.h
    │   │   ├── spotlightend.cpp
    │   │   ├── spotlightend.h
    │   │   ├── sprite_perfmonitor.cpp
    │   │   ├── stdafx.cpp
    │   │   ├── steamjet.cpp
    │   │   ├── steamjet.h
    │   │   ├── subs.cpp
    │   │   ├── sun.cpp
    │   │   ├── tactical_mission.cpp
    │   │   ├── tactical_mission.h
    │   │   ├── tanktrain.cpp
    │   │   ├── te.cpp
    │   │   ├── te.h
    │   │   ├── te_armorricochet.cpp
    │   │   ├── te_basebeam.cpp
    │   │   ├── te_basebeam.h
    │   │   ├── te_beamentpoint.cpp
    │   │   ├── te_beaments.cpp
    │   │   ├── te_beamfollow.cpp
    │   │   ├── te_beamlaser.cpp
    │   │   ├── te_beampoints.cpp
    │   │   ├── te_beamring.cpp
    │   │   ├── te_beamringpoint.cpp
    │   │   ├── te_beamspline.cpp
    │   │   ├── te_bloodsprite.cpp
    │   │   ├── te_bloodstream.cpp
    │   │   ├── te_breakmodel.cpp
    │   │   ├── te_bspdecal.cpp
    │   │   ├── te_bubbles.cpp
    │   │   ├── te_bubbletrail.cpp
    │   │   ├── te_clientprojectile.cpp
    │   │   ├── te_decal.cpp
    │   │   ├── te_dynamiclight.cpp
    │   │   ├── te_effect_dispatch.cpp
    │   │   ├── te_effect_dispatch.h
    │   │   ├── te_energysplash.cpp
    │   │   ├── te_explosion.cpp
    │   │   ├── te_fizz.cpp
    │   │   ├── te_footprintdecal.cpp
    │   │   ├── te_glassshatter.cpp
    │   │   ├── te_glowsprite.cpp
    │   │   ├── te_impact.cpp
    │   │   ├── te_killplayerattachments.cpp
    │   │   ├── te_largefunnel.cpp
    │   │   ├── te_muzzleflash.cpp
    │   │   ├── te_particlesystem.cpp
    │   │   ├── te_particlesystem.h
    │   │   ├── te_physicsprop.cpp
    │   │   ├── te_playerdecal.cpp
    │   │   ├── te_projecteddecal.cpp
    │   │   ├── te_showline.cpp
    │   │   ├── te_smoke.cpp
    │   │   ├── te_sparks.cpp
    │   │   ├── te_sprite.cpp
    │   │   ├── te_spritespray.cpp
    │   │   ├── te_worlddecal.cpp
    │   │   ├── team.cpp
    │   │   ├── team.h
    │   │   ├── team_control_point.cpp
    │   │   ├── team_control_point.h
    │   │   ├── team_control_point_master.cpp
    │   │   ├── team_control_point_master.h
    │   │   ├── team_control_point_round.cpp
    │   │   ├── team_control_point_round.h
    │   │   ├── team_objectiveresource.cpp
    │   │   ├── team_objectiveresource.h
    │   │   ├── team_spawnpoint.cpp
    │   │   ├── team_spawnpoint.h
    │   │   ├── team_train_watcher.cpp
    │   │   ├── team_train_watcher.h
    │   │   ├── TemplateEntities.cpp
    │   │   ├── TemplateEntities.h
    │   │   ├── tempmonster.cpp
    │   │   ├── tesla.cpp
    │   │   ├── tesla.h
    │   │   ├── test_proxytoggle.cpp
    │   │   ├── test_stressentities.cpp
    │   │   ├── test_stressentities.h
    │   │   ├── testfunctions.cpp
    │   │   ├── testtraceline.cpp
    │   │   ├── textstatsmgr.cpp
    │   │   ├── textstatsmgr.h
    │   │   ├── timedeventmgr.cpp
    │   │   ├── timedeventmgr.h
    │   │   ├── toolframework_server.cpp
    │   │   ├── toolframework_server.h
    │   │   ├── trains.cpp
    │   │   ├── trains.h
    │   │   ├── trigger_area_capture.cpp
    │   │   ├── trigger_area_capture.h
    │   │   ├── trigger_portal.cpp
    │   │   ├── triggers.cpp
    │   │   ├── triggers.h
    │   │   ├── util.cpp
    │   │   ├── util.h
    │   │   ├── variant_t.cpp
    │   │   ├── variant_t.h
    │   │   ├── vehicle_base.cpp
    │   │   ├── vehicle_base.h
    │   │   ├── vehicle_baseserver.cpp
    │   │   ├── vehicle_baseserver.h
    │   │   ├── vehicle_choreo_generic.cpp
    │   │   ├── vehicle_sounds.h
    │   │   ├── vguiscreen.cpp
    │   │   ├── vguiscreen.h
    │   │   ├── vote_controller.cpp
    │   │   ├── vote_controller.h
    │   │   ├── waterbullet.cpp
    │   │   ├── waterbullet.h
    │   │   ├── WaterLODControl.cpp
    │   │   ├── wcedit.cpp
    │   │   ├── wcedit.h
    │   │   ├── weapon_cubemap.cpp
    │   │   ├── weight_button.cpp
    │   │   ├── worker_scientist.h
    │   │   ├── world.cpp
    │   │   ├── world.h
    │   │   ├── wscript
    │   │   ├── cstrike/
    │   │   │   ├── cs_autobuy.cpp
    │   │   │   ├── cs_autobuy.h
    │   │   │   ├── cs_bot_temp.cpp
    │   │   │   ├── cs_bot_temp.h
    │   │   │   ├── cs_client.cpp
    │   │   │   ├── cs_client.h
    │   │   │   ├── cs_eventlog.cpp
    │   │   │   ├── cs_gameinterface.cpp
    │   │   │   ├── cs_gameinterface.h
    │   │   │   ├── cs_gamestats.cpp
    │   │   │   ├── cs_gamestats.h
    │   │   │   ├── cs_hltvdirector.cpp
    │   │   │   ├── cs_nav.h
    │   │   │   ├── cs_nav_area.cpp
    │   │   │   ├── cs_nav_area.h
    │   │   │   ├── cs_nav_edit.cpp
    │   │   │   ├── cs_nav_file.cpp
    │   │   │   ├── cs_nav_generate.cpp
    │   │   │   ├── cs_nav_mesh.cpp
    │   │   │   ├── cs_nav_mesh.h
    │   │   │   ├── cs_nav_node.cpp
    │   │   │   ├── cs_nav_node.h
    │   │   │   ├── cs_nav_path.cpp
    │   │   │   ├── cs_nav_path.h
    │   │   │   ├── cs_nav_pathfind.h
    │   │   │   ├── cs_player.cpp
    │   │   │   ├── cs_player.h
    │   │   │   ├── cs_player_resource.cpp
    │   │   │   ├── cs_player_resource.h
    │   │   │   ├── cs_playermove.cpp
    │   │   │   ├── cs_team.cpp
    │   │   │   ├── cs_team.h
    │   │   │   ├── cs_vehicle_jeep.cpp
    │   │   │   ├── func_bomb_target.cpp
    │   │   │   ├── func_bomb_target.h
    │   │   │   ├── func_buy_zone.cpp
    │   │   │   ├── func_hostage_rescue.cpp
    │   │   │   ├── funfact_cs.cpp
    │   │   │   ├── funfact_cs.h
    │   │   │   ├── funfactmgr_cs.cpp
    │   │   │   ├── funfactmgr_cs.h
    │   │   │   ├── holiday_gift.cpp
    │   │   │   ├── holiday_gift.h
    │   │   │   ├── info_view_parameters.cpp
    │   │   │   ├── info_view_parameters.h
    │   │   │   ├── item_ammo.cpp
    │   │   │   ├── item_assaultsuit.cpp
    │   │   │   ├── item_defuser.cpp
    │   │   │   ├── item_kevlar.cpp
    │   │   │   ├── item_nvgs.cpp
    │   │   │   ├── mapinfo.cpp
    │   │   │   ├── mapinfo.h
    │   │   │   ├── point_surroundtest.cpp
    │   │   │   ├── smokegrenade_projectile.cpp
    │   │   │   ├── smokegrenade_projectile.h
    │   │   │   ├── te_radioicon.cpp
    │   │   │   ├── te_shotgun_shot.cpp
    │   │   │   ├── te_shotgun_shot.h
    │   │   │   ├── bot/
    │   │   │   │   ├── cs_bot.cpp
    │   │   │   │   ├── cs_bot.h
    │   │   │   │   ├── cs_bot_chatter.cpp
    │   │   │   │   ├── cs_bot_chatter.h
    │   │   │   │   ├── cs_bot_event.cpp
    │   │   │   │   ├── cs_bot_event_bomb.cpp
    │   │   │   │   ├── cs_bot_event_player.cpp
    │   │   │   │   ├── cs_bot_event_weapon.cpp
    │   │   │   │   ├── cs_bot_init.cpp
    │   │   │   │   ├── cs_bot_listen.cpp
    │   │   │   │   ├── cs_bot_manager.cpp
    │   │   │   │   ├── cs_bot_manager.h
    │   │   │   │   ├── cs_bot_nav.cpp
    │   │   │   │   ├── cs_bot_pathfind.cpp
    │   │   │   │   ├── cs_bot_radio.cpp
    │   │   │   │   ├── cs_bot_statemachine.cpp
    │   │   │   │   ├── cs_bot_update.cpp
    │   │   │   │   ├── cs_bot_vision.cpp
    │   │   │   │   ├── cs_bot_weapon.cpp
    │   │   │   │   ├── cs_bot_weapon_id.cpp
    │   │   │   │   ├── cs_gamestate.cpp
    │   │   │   │   ├── cs_gamestate.h
    │   │   │   │   └── states/
    │   │   │   │       ├── cs_bot_attack.cpp
    │   │   │   │       ├── cs_bot_buy.cpp
    │   │   │   │       ├── cs_bot_defuse_bomb.cpp
    │   │   │   │       ├── cs_bot_escape_from_bomb.cpp
    │   │   │   │       ├── cs_bot_fetch_bomb.cpp
    │   │   │   │       ├── cs_bot_follow.cpp
    │   │   │   │       ├── cs_bot_hide.cpp
    │   │   │   │       ├── cs_bot_hunt.cpp
    │   │   │   │       ├── cs_bot_idle.cpp
    │   │   │   │       ├── cs_bot_investigate_noise.cpp
    │   │   │   │       ├── cs_bot_move_to.cpp
    │   │   │   │       ├── cs_bot_open_door.cpp
    │   │   │   │       ├── cs_bot_plant_bomb.cpp
    │   │   │   │       └── cs_bot_use_entity.cpp
    │   │   │   └── hostage/
    │   │   │       ├── cs_simple_hostage.cpp
    │   │   │       └── cs_simple_hostage.h
    │   │   ├── dod/
    │   │   │   ├── dod_ammo_box.cpp
    │   │   │   ├── dod_ammo_box.h
    │   │   │   ├── dod_area_capture.cpp
    │   │   │   ├── dod_area_capture.h
    │   │   │   ├── dod_basegrenade.cpp
    │   │   │   ├── dod_basegrenade.h
    │   │   │   ├── dod_baserocket.cpp
    │   │   │   ├── dod_baserocket.h
    │   │   │   ├── dod_bombdispenser.cpp
    │   │   │   ├── dod_bombtarget.cpp
    │   │   │   ├── dod_bombtarget.h
    │   │   │   ├── dod_bot_temp.cpp
    │   │   │   ├── dod_bot_temp.h
    │   │   │   ├── dod_client.cpp
    │   │   │   ├── dod_control_point.cpp
    │   │   │   ├── dod_control_point.h
    │   │   │   ├── dod_control_point_master.cpp
    │   │   │   ├── dod_control_point_master.h
    │   │   │   ├── dod_cvars.cpp
    │   │   │   ├── dod_cvars.h
    │   │   │   ├── dod_eventlog.cpp
    │   │   │   ├── dod_gameinterface.cpp
    │   │   │   ├── dod_gameinterface.h
    │   │   │   ├── dod_gamestats.cpp
    │   │   │   ├── dod_gamestats.h
    │   │   │   ├── dod_handgrenade.cpp
    │   │   │   ├── dod_handgrenade.h
    │   │   │   ├── dod_hltvdirector.cpp
    │   │   │   ├── dod_location.cpp
    │   │   │   ├── dod_location.h
    │   │   │   ├── dod_objective_resource.cpp
    │   │   │   ├── dod_objective_resource.h
    │   │   │   ├── dod_player.cpp
    │   │   │   ├── dod_player.h
    │   │   │   ├── dod_player_resource.cpp
    │   │   │   ├── dod_player_resource.h
    │   │   │   ├── dod_playermove.cpp
    │   │   │   ├── dod_riflegrenade_ger.cpp
    │   │   │   ├── dod_riflegrenade_ger.h
    │   │   │   ├── dod_riflegrenade_us.cpp
    │   │   │   ├── dod_riflegrenade_us.h
    │   │   │   ├── dod_smokegrenade.cpp
    │   │   │   ├── dod_smokegrenade.h
    │   │   │   ├── dod_smokegrenade_ger.cpp
    │   │   │   ├── dod_smokegrenade_ger.h
    │   │   │   ├── dod_smokegrenade_us.cpp
    │   │   │   ├── dod_smokegrenade_us.h
    │   │   │   ├── dod_statmgr.cpp
    │   │   │   ├── dod_statmgr.h
    │   │   │   ├── dod_stickgrenade.cpp
    │   │   │   ├── dod_stickgrenade.h
    │   │   │   ├── dod_team.cpp
    │   │   │   ├── dod_team.h
    │   │   │   ├── grenadetrail.cpp
    │   │   │   ├── grenadetrail.h
    │   │   │   ├── holiday_gift.cpp
    │   │   │   ├── holiday_gift.h
    │   │   │   ├── rocket_bazooka.cpp
    │   │   │   ├── rocket_bazooka.h
    │   │   │   ├── rocket_pschreck.cpp
    │   │   │   ├── rocket_pschreck.h
    │   │   │   ├── te_firebullets.cpp
    │   │   │   ├── te_firebullets.h
    │   │   │   └── unisignals.h
    │   │   ├── episodic/
    │   │   │   ├── ai_behavior_alyx_injured.cpp
    │   │   │   ├── ai_behavior_alyx_injured.h
    │   │   │   ├── ai_behavior_passenger_companion.cpp
    │   │   │   ├── ai_behavior_passenger_companion.h
    │   │   │   ├── ai_behavior_passenger_zombie.cpp
    │   │   │   ├── ai_behavior_passenger_zombie.h
    │   │   │   ├── ep1_gamestats.cpp
    │   │   │   ├── ep1_gamestats.h
    │   │   │   ├── ep2_gamestats.cpp
    │   │   │   ├── ep2_gamestats.h
    │   │   │   ├── grenade_hopwire.cpp
    │   │   │   ├── grenade_hopwire.h
    │   │   │   ├── npc_advisor.cpp
    │   │   │   ├── npc_combine_cannon.cpp
    │   │   │   ├── npc_hunter.cpp
    │   │   │   ├── npc_hunter.h
    │   │   │   ├── npc_magnusson.cpp
    │   │   │   ├── npc_puppet.cpp
    │   │   │   ├── prop_scalable.cpp
    │   │   │   ├── vehicle_jeep_episodic.cpp
    │   │   │   ├── vehicle_jeep_episodic.h
    │   │   │   ├── weapon_hopwire.cpp
    │   │   │   ├── weapon_oldmanharpoon.cpp
    │   │   │   ├── weapon_striderbuster.cpp
    │   │   │   └── weapon_striderbuster.h
    │   │   ├── hl1/
    │   │   │   ├── hl1_ai_basenpc.cpp
    │   │   │   ├── hl1_ai_basenpc.h
    │   │   │   ├── hl1_basecombatweapon.cpp
    │   │   │   ├── hl1_basegrenade.cpp
    │   │   │   ├── hl1_basegrenade.h
    │   │   │   ├── hl1_client.cpp
    │   │   │   ├── hl1_ents.cpp
    │   │   │   ├── hl1_ents.h
    │   │   │   ├── hl1_env_speaker.cpp
    │   │   │   ├── hl1_eventlog.cpp
    │   │   │   ├── hl1_func_recharge.cpp
    │   │   │   ├── hl1_func_tank.cpp
    │   │   │   ├── hl1_grenade_mp5.cpp
    │   │   │   ├── hl1_grenade_mp5.h
    │   │   │   ├── hl1_grenade_spit.cpp
    │   │   │   ├── hl1_grenade_spit.h
    │   │   │   ├── hl1_item_ammo.cpp
    │   │   │   ├── hl1_item_battery.cpp
    │   │   │   ├── hl1_item_healthkit.cpp
    │   │   │   ├── hl1_item_longjump.cpp
    │   │   │   ├── hl1_item_suit.cpp
    │   │   │   ├── hl1_items.cpp
    │   │   │   ├── hl1_items.h
    │   │   │   ├── hl1_monstermaker.cpp
    │   │   │   ├── hl1_monstermaker.h
    │   │   │   ├── hl1_npc_aflock.cpp
    │   │   │   ├── hl1_npc_agrunt.cpp
    │   │   │   ├── hl1_npc_apache.cpp
    │   │   │   ├── hl1_npc_barnacle.cpp
    │   │   │   ├── hl1_npc_barnacle.h
    │   │   │   ├── hl1_npc_barney.cpp
    │   │   │   ├── hl1_npc_barney.h
    │   │   │   ├── hl1_npc_bigmomma.cpp
    │   │   │   ├── hl1_npc_bloater.cpp
    │   │   │   ├── hl1_npc_bullsquid.cpp
    │   │   │   ├── hl1_npc_bullsquid.h
    │   │   │   ├── hl1_npc_controller.cpp
    │   │   │   ├── hl1_npc_controller.h
    │   │   │   ├── hl1_npc_gargantua.cpp
    │   │   │   ├── hl1_npc_gargantua.h
    │   │   │   ├── hl1_npc_gman.cpp
    │   │   │   ├── hl1_npc_hassassin.cpp
    │   │   │   ├── hl1_npc_headcrab.cpp
    │   │   │   ├── hl1_npc_headcrab.h
    │   │   │   ├── hl1_npc_hgrunt.cpp
    │   │   │   ├── hl1_npc_hgrunt.h
    │   │   │   ├── hl1_npc_hornet.cpp
    │   │   │   ├── hl1_npc_hornet.h
    │   │   │   ├── hl1_npc_houndeye.cpp
    │   │   │   ├── hl1_npc_houndeye.h
    │   │   │   ├── hl1_npc_ichthyosaur.cpp
    │   │   │   ├── hl1_npc_ichthyosaur.h
    │   │   │   ├── hl1_npc_leech.cpp
    │   │   │   ├── hl1_npc_nihilanth.cpp
    │   │   │   ├── hl1_npc_osprey.cpp
    │   │   │   ├── hl1_npc_roach.cpp
    │   │   │   ├── hl1_npc_scientist.cpp
    │   │   │   ├── hl1_npc_scientist.h
    │   │   │   ├── hl1_npc_snark.cpp
    │   │   │   ├── hl1_npc_snark.h
    │   │   │   ├── hl1_npc_talker.cpp
    │   │   │   ├── hl1_npc_talker.h
    │   │   │   ├── hl1_npc_tentacle.cpp
    │   │   │   ├── hl1_npc_turret.cpp
    │   │   │   ├── hl1_npc_vortigaunt.cpp
    │   │   │   ├── hl1_npc_vortigaunt.h
    │   │   │   ├── hl1_npc_zombie.cpp
    │   │   │   ├── hl1_npc_zombie.h
    │   │   │   ├── hl1_player.cpp
    │   │   │   ├── hl1_player.h
    │   │   │   ├── hl1_playermove.cpp
    │   │   │   ├── hl1_weapon_crowbar.cpp
    │   │   │   ├── hl1_weapon_snark.cpp
    │   │   │   ├── hl1_weapon_tripmine.cpp
    │   │   │   ├── hl1_weaponbox.cpp
    │   │   │   ├── hl1mp_bot_temp.cpp
    │   │   │   ├── hl1mp_bot_temp.h
    │   │   │   ├── hl1mp_gameinterface.cpp
    │   │   │   ├── hl1mp_player.cpp
    │   │   │   └── hl1mp_player.h
    │   │   ├── hl2/
    │   │   │   ├── ai_allymanager.cpp
    │   │   │   ├── ai_behavior_actbusy.cpp
    │   │   │   ├── ai_behavior_actbusy.h
    │   │   │   ├── ai_behavior_functank.cpp
    │   │   │   ├── ai_behavior_functank.h
    │   │   │   ├── ai_behavior_holster.cpp
    │   │   │   ├── ai_behavior_holster.h
    │   │   │   ├── ai_behavior_operator.cpp
    │   │   │   ├── ai_behavior_operator.h
    │   │   │   ├── ai_behavior_police.cpp
    │   │   │   ├── ai_behavior_police.h
    │   │   │   ├── ai_goal_police.cpp
    │   │   │   ├── ai_goal_police.h
    │   │   │   ├── ai_interactions.h
    │   │   │   ├── ai_spotlight.cpp
    │   │   │   ├── ai_spotlight.h
    │   │   │   ├── antlion_dust.cpp
    │   │   │   ├── antlion_dust.h
    │   │   │   ├── antlion_maker.cpp
    │   │   │   ├── antlion_maker.h
    │   │   │   ├── ar2_explosion.cpp
    │   │   │   ├── ar2_explosion.h
    │   │   │   ├── assassin_smoke.cpp
    │   │   │   ├── assassin_smoke.h
    │   │   │   ├── basehlcombatweapon.cpp
    │   │   │   ├── basehlcombatweapon.h
    │   │   │   ├── cbasehelicopter.cpp
    │   │   │   ├── cbasehelicopter.h
    │   │   │   ├── cbasespriteprojectile.cpp
    │   │   │   ├── cbasespriteprojectile.h
    │   │   │   ├── citadel_effects.cpp
    │   │   │   ├── combine_mine.cpp
    │   │   │   ├── combine_mine.h
    │   │   │   ├── energy_wave.h
    │   │   │   ├── env_alyxemp.cpp
    │   │   │   ├── env_headcrabcanister.cpp
    │   │   │   ├── env_speaker.cpp
    │   │   │   ├── env_speaker.h
    │   │   │   ├── env_starfield.cpp
    │   │   │   ├── extinguisherjet.cpp
    │   │   │   ├── extinguisherjet.h
    │   │   │   ├── func_bulletshield.cpp
    │   │   │   ├── func_bulletshield.h
    │   │   │   ├── Func_Monitor.cpp
    │   │   │   ├── func_recharge.cpp
    │   │   │   ├── func_tank.cpp
    │   │   │   ├── func_tank.h
    │   │   │   ├── grenade_ar2.cpp
    │   │   │   ├── grenade_ar2.h
    │   │   │   ├── grenade_beam.cpp
    │   │   │   ├── grenade_beam.h
    │   │   │   ├── grenade_brickbat.cpp
    │   │   │   ├── grenade_brickbat.h
    │   │   │   ├── grenade_bugbait.cpp
    │   │   │   ├── grenade_bugbait.h
    │   │   │   ├── grenade_energy.cpp
    │   │   │   ├── grenade_energy.h
    │   │   │   ├── grenade_frag.cpp
    │   │   │   ├── grenade_frag.h
    │   │   │   ├── grenade_homer.cpp
    │   │   │   ├── grenade_homer.h
    │   │   │   ├── grenade_molotov.cpp
    │   │   │   ├── grenade_molotov.h
    │   │   │   ├── grenade_pathfollower.cpp
    │   │   │   ├── grenade_pathfollower.h
    │   │   │   ├── grenade_satchel.cpp
    │   │   │   ├── grenade_satchel.h
    │   │   │   ├── grenade_spit.cpp
    │   │   │   ├── grenade_spit.h
    │   │   │   ├── grenade_tripmine.cpp
    │   │   │   ├── grenade_tripmine.h
    │   │   │   ├── grenade_tripwire.cpp
    │   │   │   ├── grenade_tripwire.h
    │   │   │   ├── hl2_ai_network.cpp
    │   │   │   ├── hl2_client.cpp
    │   │   │   ├── hl2_eventlog.cpp
    │   │   │   ├── hl2_gamestats.cpp
    │   │   │   ├── hl2_gamestats.h
    │   │   │   ├── hl2_player.cpp
    │   │   │   ├── hl2_player.h
    │   │   │   ├── hl2_playerlocaldata.cpp
    │   │   │   ├── hl2_playerlocaldata.h
    │   │   │   ├── hl2_triggers.cpp
    │   │   │   ├── hl_playermove.cpp
    │   │   │   ├── info_darknessmode_lightsource.cpp
    │   │   │   ├── info_darknessmode_lightsource.h
    │   │   │   ├── info_teleporter_countdown.cpp
    │   │   │   ├── item_ammo.cpp
    │   │   │   ├── item_antidote.cpp
    │   │   │   ├── item_battery.cpp
    │   │   │   ├── item_dynamic_resupply.cpp
    │   │   │   ├── item_dynamic_resupply.h
    │   │   │   ├── item_healthkit.cpp
    │   │   │   ├── item_itemcrate.cpp
    │   │   │   ├── item_longjump.cpp
    │   │   │   ├── item_security.cpp
    │   │   │   ├── item_suit.cpp
    │   │   │   ├── look_door.cpp
    │   │   │   ├── monster_dummy.cpp
    │   │   │   ├── npc_alyx.cpp
    │   │   │   ├── npc_alyx.h
    │   │   │   ├── npc_alyx_episodic.cpp
    │   │   │   ├── npc_alyx_episodic.h
    │   │   │   ├── npc_antlion.cpp
    │   │   │   ├── npc_antlion.h
    │   │   │   ├── npc_antliongrub.cpp
    │   │   │   ├── npc_antliongrub.h
    │   │   │   ├── npc_antlionguard.cpp
    │   │   │   ├── npc_apcdriver.cpp
    │   │   │   ├── npc_assassin.cpp
    │   │   │   ├── npc_assassin.h
    │   │   │   ├── npc_attackchopper.cpp
    │   │   │   ├── npc_attackchopper.h
    │   │   │   ├── npc_barnacle.cpp
    │   │   │   ├── npc_barnacle.h
    │   │   │   ├── npc_barney.cpp
    │   │   │   ├── npc_basescanner.cpp
    │   │   │   ├── npc_basescanner.h
    │   │   │   ├── npc_BaseZombie.cpp
    │   │   │   ├── npc_BaseZombie.h
    │   │   │   ├── npc_blob.cpp
    │   │   │   ├── npc_breen.cpp
    │   │   │   ├── npc_bullseye.cpp
    │   │   │   ├── npc_bullseye.h
    │   │   │   ├── npc_bullsquid.cpp
    │   │   │   ├── npc_bullsquid.h
    │   │   │   ├── npc_citizen17.cpp
    │   │   │   ├── npc_citizen17.h
    │   │   │   ├── npc_combine.cpp
    │   │   │   ├── npc_combine.h
    │   │   │   ├── npc_combinecamera.cpp
    │   │   │   ├── npc_combinedropship.cpp
    │   │   │   ├── npc_combinegunship.cpp
    │   │   │   ├── npc_combines.cpp
    │   │   │   ├── npc_combines.h
    │   │   │   ├── npc_cranedriver.cpp
    │   │   │   ├── npc_crow.cpp
    │   │   │   ├── npc_crow.h
    │   │   │   ├── npc_dog.cpp
    │   │   │   ├── npc_eli.cpp
    │   │   │   ├── npc_enemyfinder.cpp
    │   │   │   ├── npc_fastzombie.cpp
    │   │   │   ├── npc_fisherman.cpp
    │   │   │   ├── npc_gman.cpp
    │   │   │   ├── npc_headcrab.cpp
    │   │   │   ├── npc_headcrab.h
    │   │   │   ├── npc_houndeye.cpp
    │   │   │   ├── npc_houndeye.h
    │   │   │   ├── npc_hydra.cpp
    │   │   │   ├── npc_hydra.h
    │   │   │   ├── npc_ichthyosaur.cpp
    │   │   │   ├── npc_kleiner.cpp
    │   │   │   ├── npc_launcher.cpp
    │   │   │   ├── npc_manhack.cpp
    │   │   │   ├── npc_manhack.h
    │   │   │   ├── npc_metropolice.cpp
    │   │   │   ├── npc_metropolice.h
    │   │   │   ├── npc_missiledefense.cpp
    │   │   │   ├── npc_monk.cpp
    │   │   │   ├── npc_mossman.cpp
    │   │   │   ├── npc_playercompanion.cpp
    │   │   │   ├── npc_playercompanion.h
    │   │   │   ├── npc_PoisonZombie.cpp
    │   │   │   ├── npc_rollermine.cpp
    │   │   │   ├── npc_rollermine.h
    │   │   │   ├── npc_scanner.cpp
    │   │   │   ├── npc_scanner.h
    │   │   │   ├── npc_spotlight.cpp
    │   │   │   ├── npc_stalker.cpp
    │   │   │   ├── npc_stalker.h
    │   │   │   ├── npc_strider.cpp
    │   │   │   ├── npc_strider.h
    │   │   │   ├── npc_turret.cpp
    │   │   │   ├── npc_turret_ceiling.cpp
    │   │   │   ├── npc_turret_floor.cpp
    │   │   │   ├── npc_turret_floor.h
    │   │   │   ├── npc_turret_ground.cpp
    │   │   │   ├── npc_turret_ground.h
    │   │   │   ├── npc_vortigaunt_episodic.cpp
    │   │   │   ├── npc_vortigaunt_episodic.h
    │   │   │   ├── npc_zombie.cpp
    │   │   │   ├── npc_zombine.cpp
    │   │   │   ├── point_apc_controller.cpp
    │   │   │   ├── prop_combine_ball.cpp
    │   │   │   ├── prop_combine_ball.h
    │   │   │   ├── prop_thumper.cpp
    │   │   │   ├── proto_sniper.cpp
    │   │   │   ├── rotorwash.cpp
    │   │   │   ├── rotorwash.h
    │   │   │   ├── script_intro.cpp
    │   │   │   ├── script_intro.h
    │   │   │   ├── te_gaussexplosion.cpp
    │   │   │   ├── trigger_super_armor.cpp
    │   │   │   ├── vehicle_airboat.cpp
    │   │   │   ├── vehicle_apc.cpp
    │   │   │   ├── vehicle_apc.h
    │   │   │   ├── vehicle_cannon.cpp
    │   │   │   ├── vehicle_crane.cpp
    │   │   │   ├── vehicle_crane.h
    │   │   │   ├── vehicle_jeep.cpp
    │   │   │   ├── vehicle_jeep.h
    │   │   │   ├── vehicle_jetski.cpp
    │   │   │   ├── vehicle_prisoner_pod.cpp
    │   │   │   ├── vehicle_viewcontroller.cpp
    │   │   │   ├── weapon_357.cpp
    │   │   │   ├── weapon_alyxgun.cpp
    │   │   │   ├── weapon_alyxgun.h
    │   │   │   ├── weapon_annabelle.cpp
    │   │   │   ├── weapon_ar1.cpp
    │   │   │   ├── weapon_ar2.cpp
    │   │   │   ├── weapon_ar2.h
    │   │   │   ├── weapon_brickbat.cpp
    │   │   │   ├── weapon_brickbat.h
    │   │   │   ├── weapon_bugbait.cpp
    │   │   │   ├── weapon_cguard.cpp
    │   │   │   ├── weapon_citizenpackage.cpp
    │   │   │   ├── weapon_citizenpackage.h
    │   │   │   ├── weapon_crossbow.cpp
    │   │   │   ├── weapon_crowbar.cpp
    │   │   │   ├── weapon_crowbar.h
    │   │   │   ├── weapon_extinguisher.cpp
    │   │   │   ├── weapon_flaregun.cpp
    │   │   │   ├── weapon_flaregun.h
    │   │   │   ├── weapon_frag.cpp
    │   │   │   ├── weapon_gauss.h
    │   │   │   ├── weapon_immolator.cpp
    │   │   │   ├── weapon_irifle.cpp
    │   │   │   ├── weapon_manhack.cpp
    │   │   │   ├── weapon_molotov.cpp
    │   │   │   ├── weapon_molotov.h
    │   │   │   ├── weapon_physcannon.cpp
    │   │   │   ├── weapon_physcannon.h
    │   │   │   ├── weapon_pistol.cpp
    │   │   │   ├── weapon_rpg.cpp
    │   │   │   ├── weapon_rpg.h
    │   │   │   ├── weapon_shotgun.cpp
    │   │   │   ├── weapon_slam.cpp
    │   │   │   ├── weapon_slam.h
    │   │   │   ├── weapon_smg1.cpp
    │   │   │   ├── weapon_smg2.cpp
    │   │   │   ├── weapon_sniperrifle.cpp
    │   │   │   ├── weapon_stunstick.cpp
    │   │   │   ├── weapon_stunstick.h
    │   │   │   ├── weapon_thumper.cpp
    │   │   │   ├── weapon_tripwire.cpp
    │   │   │   └── weapon_tripwire.h
    │   │   ├── hl2mp/
    │   │   │   ├── grenade_satchel.cpp
    │   │   │   ├── grenade_satchel.h
    │   │   │   ├── grenade_tripmine.cpp
    │   │   │   ├── grenade_tripmine.h
    │   │   │   ├── hl2mp_bot_temp.cpp
    │   │   │   ├── hl2mp_bot_temp.h
    │   │   │   ├── hl2mp_client.cpp
    │   │   │   ├── hl2mp_cvars.cpp
    │   │   │   ├── hl2mp_cvars.h
    │   │   │   ├── hl2mp_gameinterface.cpp
    │   │   │   ├── hl2mp_gameinterface.h
    │   │   │   ├── hl2mp_player.cpp
    │   │   │   ├── hl2mp_player.h
    │   │   │   ├── te_hl2mp_shotgun_shot.cpp
    │   │   │   └── te_hl2mp_shotgun_shot.h
    │   │   ├── NextBot/
    │   │   │   ├── NextBot.cpp
    │   │   │   ├── NextBot.h
    │   │   │   ├── NextBotAttentionInterface.cpp
    │   │   │   ├── NextBotAttentionInterface.h
    │   │   │   ├── NextBotBehavior.h
    │   │   │   ├── NextBotBodyInterface.cpp
    │   │   │   ├── NextBotBodyInterface.h
    │   │   │   ├── NextBotComponentInterface.cpp
    │   │   │   ├── NextBotComponentInterface.h
    │   │   │   ├── NextBotContextualQueryInterface.h
    │   │   │   ├── NextBotDebug.h
    │   │   │   ├── NextBotEventResponderInterface.h
    │   │   │   ├── NextBotGroundLocomotion.cpp
    │   │   │   ├── NextBotGroundLocomotion.h
    │   │   │   ├── NextBotHearingInterface.h
    │   │   │   ├── NextBotIntentionInterface.cpp
    │   │   │   ├── NextBotIntentionInterface.h
    │   │   │   ├── NextBotInterface.cpp
    │   │   │   ├── NextBotInterface.h
    │   │   │   ├── NextBotKnownEntity.h
    │   │   │   ├── NextBotLocomotionInterface.cpp
    │   │   │   ├── NextBotLocomotionInterface.h
    │   │   │   ├── NextBotManager.cpp
    │   │   │   ├── NextBotManager.h
    │   │   │   ├── NextBotUtil.h
    │   │   │   ├── NextBotVisionInterface.cpp
    │   │   │   ├── NextBotVisionInterface.h
    │   │   │   ├── simple_bot.cpp
    │   │   │   ├── simple_bot.h
    │   │   │   ├── Behavior/
    │   │   │   │   ├── BehaviorBackUp.h
    │   │   │   │   └── BehaviorMoveTo.h
    │   │   │   ├── NavMeshEntities/
    │   │   │   │   ├── func_nav_prerequisite.cpp
    │   │   │   │   └── func_nav_prerequisite.h
    │   │   │   ├── Path/
    │   │   │   │   ├── NextBotChasePath.cpp
    │   │   │   │   ├── NextBotChasePath.h
    │   │   │   │   ├── NextBotPath.cpp
    │   │   │   │   ├── NextBotPath.h
    │   │   │   │   ├── NextBotPathFollow.cpp
    │   │   │   │   ├── NextBotPathFollow.h
    │   │   │   │   └── NextBotRetreatPath.h
    │   │   │   └── Player/
    │   │   │       ├── NextBotPlayer.cpp
    │   │   │       ├── NextBotPlayer.h
    │   │   │       ├── NextBotPlayerBody.cpp
    │   │   │       ├── NextBotPlayerBody.h
    │   │   │       ├── NextBotPlayerLocomotion.cpp
    │   │   │       └── NextBotPlayerLocomotion.h
    │   │   ├── portal/
    │   │   │   ├── cbaseanimatingprojectile.cpp
    │   │   │   ├── cbaseanimatingprojectile.h
    │   │   │   ├── env_lightrail_endpoint.cpp
    │   │   │   ├── env_portal_credits.cpp
    │   │   │   ├── env_portal_path_track.cpp
    │   │   │   ├── func_liquidportal.cpp
    │   │   │   ├── func_liquidportal.h
    │   │   │   ├── func_noportal_volume.cpp
    │   │   │   ├── func_noportal_volume.h
    │   │   │   ├── func_portal_bumper.cpp
    │   │   │   ├── func_portal_detector.cpp
    │   │   │   ├── func_portal_detector.h
    │   │   │   ├── func_portal_orientation.cpp
    │   │   │   ├── func_portal_orientation.h
    │   │   │   ├── neurotoxin_countdown.cpp
    │   │   │   ├── npc_portal_turret_floor.cpp
    │   │   │   ├── npc_portal_turret_ground.cpp
    │   │   │   ├── npc_rocket_turret.cpp
    │   │   │   ├── npc_security_camera.cpp
    │   │   │   ├── PhysicsCloneArea.cpp
    │   │   │   ├── PhysicsCloneArea.h
    │   │   │   ├── physicsshadowclone.cpp
    │   │   │   ├── physicsshadowclone.h
    │   │   │   ├── portal_client.cpp
    │   │   │   ├── Portal_CustomStatsVisualizer.cpp
    │   │   │   ├── portal_gamestats.cpp
    │   │   │   ├── portal_gamestats.h
    │   │   │   ├── portal_mp_client.cpp
    │   │   │   ├── portal_physics_collisionevent.cpp
    │   │   │   ├── portal_physics_collisionevent.h
    │   │   │   ├── portal_placement.cpp
    │   │   │   ├── portal_placement.h
    │   │   │   ├── portal_player.cpp
    │   │   │   ├── portal_player.h
    │   │   │   ├── portal_radio.cpp
    │   │   │   ├── prop_energy_ball.cpp
    │   │   │   ├── prop_glados_core.cpp
    │   │   │   ├── prop_portal.cpp
    │   │   │   ├── prop_portal.h
    │   │   │   ├── prop_portal_stats_display.cpp
    │   │   │   ├── prop_telescopic_arm.cpp
    │   │   │   ├── trigger_portal_cleanser.cpp
    │   │   │   ├── weapon_physcannon.cpp
    │   │   │   ├── weapon_physcannon.h
    │   │   │   ├── weapon_portalgun.cpp
    │   │   │   └── weapon_portalgun.h
    │   │   └── sdk/
    │   │       ├── sdk_bot_temp.cpp
    │   │       ├── sdk_bot_temp.h
    │   │       ├── sdk_brushentity.cpp
    │   │       ├── sdk_client.cpp
    │   │       ├── sdk_env_message.cpp
    │   │       ├── sdk_env_sparkler.cpp
    │   │       ├── sdk_eventlog.cpp
    │   │       ├── sdk_gameinterface.cpp
    │   │       ├── sdk_logicalentity.cpp
    │   │       ├── sdk_modelentity.cpp
    │   │       ├── sdk_player.cpp
    │   │       ├── sdk_player.h
    │   │       ├── sdk_playermove.cpp
    │   │       ├── sdk_team.cpp
    │   │       ├── sdk_team.h
    │   │       ├── sdk_vehicle_jeep.cpp
    │   │       ├── te_firebullets.cpp
    │   │       └── te_firebullets.h
    │   └── shared/
    │       ├── achievement_saverestore.cpp
    │       ├── achievement_saverestore.h
    │       ├── achievementmgr.cpp
    │       ├── achievementmgr.h
    │       ├── achievements_and_stats_interface.h
    │       ├── achievements_hlx.cpp
    │       ├── activitylist.cpp
    │       ├── activitylist.h
    │       ├── ai_activity.h
    │       ├── ai_debug_shared.h
    │       ├── ammodef.cpp
    │       ├── ammodef.h
    │       ├── animation.cpp
    │       ├── animation.h
    │       ├── apparent_velocity_helper.h
    │       ├── base_playeranimstate.cpp
    │       ├── base_playeranimstate.h
    │       ├── baseachievement.cpp
    │       ├── baseachievement.h
    │       ├── basecombatcharacter_shared.cpp
    │       ├── basecombatweapon_shared.cpp
    │       ├── basecombatweapon_shared.h
    │       ├── baseentity_shared.cpp
    │       ├── baseentity_shared.h
    │       ├── basegrenade_shared.cpp
    │       ├── basegrenade_shared.h
    │       ├── baseparticleentity.cpp
    │       ├── baseparticleentity.h
    │       ├── baseplayer_shared.cpp
    │       ├── baseplayer_shared.h
    │       ├── baseprojectile.cpp
    │       ├── baseprojectile.h
    │       ├── baseviewmodel_shared.cpp
    │       ├── baseviewmodel_shared.h
    │       ├── beam_flags.h
    │       ├── beam_shared.cpp
    │       ├── beam_shared.h
    │       ├── cam_thirdperson.cpp
    │       ├── cam_thirdperson.h
    │       ├── choreoactor.cpp
    │       ├── choreoactor.h
    │       ├── choreochannel.cpp
    │       ├── choreochannel.h
    │       ├── choreoevent.cpp
    │       ├── choreoevent.h
    │       ├── choreoscene.cpp
    │       ├── choreoscene.h
    │       ├── collisionproperty.cpp
    │       ├── collisionproperty.h
    │       ├── cs_achievements_and_stats_interface.cpp
    │       ├── cs_achievements_and_stats_interface.h
    │       ├── death_pose.cpp
    │       ├── death_pose.h
    │       ├── debugoverlay_null.cpp
    │       ├── debugoverlay_shared.cpp
    │       ├── debugoverlay_shared.h
    │       ├── decals.cpp
    │       ├── decals.h
    │       ├── effect_color_tables.h
    │       ├── effect_dispatch_data.cpp
    │       ├── effect_dispatch_data.h
    │       ├── ehandle.cpp
    │       ├── ehandle.h
    │       ├── entitydatainstantiator.h
    │       ├── entitylist_base.cpp
    │       ├── entitylist_base.h
    │       ├── EntityParticleTrail_Shared.cpp
    │       ├── entityparticletrail_shared.h
    │       ├── env_detail_controller.cpp
    │       ├── env_detail_controller.h
    │       ├── env_meteor_shared.cpp
    │       ├── env_meteor_shared.h
    │       ├── env_wind_shared.cpp
    │       ├── env_wind_shared.h
    │       ├── eventlist.cpp
    │       ├── eventlist.h
    │       ├── expressionsample.h
    │       ├── forcefeedback.h
    │       ├── func_dust_shared.h
    │       ├── func_ladder.cpp
    │       ├── func_ladder.h
    │       ├── gameeventdefs.h
    │       ├── GameEventListener.h
    │       ├── gamemovement.cpp
    │       ├── gamemovement.h
    │       ├── gamerules.cpp
    │       ├── gamerules.h
    │       ├── gamerules_register.cpp
    │       ├── gamerules_register.h
    │       ├── GameStats.cpp
    │       ├── gamestats.h
    │       ├── gamestringpool.cpp
    │       ├── gamestringpool.h
    │       ├── gamevars_shared.cpp
    │       ├── gamevars_shared.h
    │       ├── groundlink.h
    │       ├── hintmessage.cpp
    │       ├── hintmessage.h
    │       ├── hintsystem.cpp
    │       ├── hintsystem.h
    │       ├── ichoreoeventcallback.h
    │       ├── IEffects.h
    │       ├── igamemovement.h
    │       ├── igamesystem.cpp
    │       ├── igamesystem.h
    │       ├── imovehelper.h
    │       ├── in_buttons.h
    │       ├── interval.cpp
    │       ├── interval.h
    │       ├── iplayeranimstate.h
    │       ├── ipredictionsystem.h
    │       ├── iscenetokenprocessor.h
    │       ├── itempents.h
    │       ├── IVehicle.h
    │       ├── mapdata_shared.h
    │       ├── mapentities_shared.cpp
    │       ├── mapentities_shared.h
    │       ├── ModelSoundsCache.cpp
    │       ├── ModelSoundsCache.h
    │       ├── movetype_push.h
    │       ├── movevars_shared.cpp
    │       ├── movevars_shared.h
    │       ├── mp_shareddefs.cpp
    │       ├── mp_shareddefs.h
    │       ├── multiplay_gamerules.cpp
    │       ├── multiplay_gamerules.h
    │       ├── npcevent.h
    │       ├── obstacle_pushaway.cpp
    │       ├── obstacle_pushaway.h
    │       ├── particle_parse.cpp
    │       ├── particle_parse.h
    │       ├── particle_property.cpp
    │       ├── particle_property.h
    │       ├── particle_property_inlines.h
    │       ├── particlesystemquery.cpp
    │       ├── physics_main_shared.cpp
    │       ├── physics_saverestore.cpp
    │       ├── physics_saverestore.h
    │       ├── physics_shared.cpp
    │       ├── physics_shared.h
    │       ├── playerclass_info_parse.cpp
    │       ├── playerclass_info_parse.h
    │       ├── playernet_vars.h
    │       ├── point_bonusmaps_accessor.cpp
    │       ├── point_bonusmaps_accessor.h
    │       ├── point_posecontroller.cpp
    │       ├── point_posecontroller.h
    │       ├── positionwatcher.h
    │       ├── precache_register.cpp
    │       ├── precache_register.h
    │       ├── precipitation_shared.h
    │       ├── predictable_entity.h
    │       ├── predictableid.cpp
    │       ├── predictableid.h
    │       ├── predicted_viewmodel.cpp
    │       ├── predicted_viewmodel.h
    │       ├── predictioncopy.cpp
    │       ├── predictioncopy.h
    │       ├── props_shared.cpp
    │       ├── props_shared.h
    │       ├── querycache.cpp
    │       ├── querycache.h
    │       ├── ragdoll_shared.cpp
    │       ├── ragdoll_shared.h
    │       ├── rope_helpers.cpp
    │       ├── rope_helpers.h
    │       ├── rumble_shared.h
    │       ├── saverestore.cpp
    │       ├── saverestore.h
    │       ├── saverestore_bitstring.h
    │       ├── saverestore_stringtable.h
    │       ├── saverestore_utlclass.h
    │       ├── saverestore_utlmap.h
    │       ├── saverestore_utlrbtree.h
    │       ├── saverestore_utlsymbol.h
    │       ├── saverestore_utlvector.h
    │       ├── SceneCache.cpp
    │       ├── SceneCache.h
    │       ├── sceneentity_shared.cpp
    │       ├── sceneentity_shared.h
    │       ├── sceneimage.cpp
    │       ├── sceneimage.h
    │       ├── script_intro_shared.cpp
    │       ├── scriptevent.h
    │       ├── sequence_Transitioner.cpp
    │       ├── sequence_Transitioner.h
    │       ├── shared_classnames.h
    │       ├── shareddefs.h
    │       ├── SharedFunctorUtils.cpp
    │       ├── SharedFunctorUtils.h
    │       ├── sharedInterface.h
    │       ├── sheetsimulator.cpp
    │       ├── sheetsimulator.h
    │       ├── shot_manipulator.h
    │       ├── simtimer.cpp
    │       ├── simtimer.h
    │       ├── singleplay_gamerules.cpp
    │       ├── singleplay_gamerules.h
    │       ├── smoke_fog_overlay_shared.h
    │       ├── solidsetdefaults.h
    │       ├── SoundEmitterSystem.cpp
    │       ├── soundenvelope.cpp
    │       ├── soundenvelope.h
    │       ├── Sprite.cpp
    │       ├── Sprite.h
    │       ├── SpriteTrail.cpp
    │       ├── SpriteTrail.h
    │       ├── steamworks_gamestats.cpp
    │       ├── steamworks_gamestats.h
    │       ├── studio_shared.cpp
    │       ├── sun_shared.h
    │       ├── takedamageinfo.cpp
    │       ├── takedamageinfo.h
    │       ├── teamplay_gamerules.cpp
    │       ├── teamplay_gamerules.h
    │       ├── teamplay_round_timer.cpp
    │       ├── teamplay_round_timer.h
    │       ├── teamplayroundbased_gamerules.cpp
    │       ├── teamplayroundbased_gamerules.h
    │       ├── tempentity.h
    │       ├── test_ehandle.cpp
    │       ├── touchlink.h
    │       ├── usercmd.cpp
    │       ├── usercmd.h
    │       ├── usermessages.cpp
    │       ├── usermessages.h
    │       ├── util_shared.cpp
    │       ├── util_shared.h
    │       ├── vehicle_choreo_generic_shared.h
    │       ├── vehicle_viewblend_shared.cpp
    │       ├── vehicle_viewblend_shared.h
    │       ├── vgui_defaultinputsignal.h
    │       ├── viewport_panel_names.h
    │       ├── voice_banmgr.cpp
    │       ├── voice_banmgr.h
    │       ├── voice_common.h
    │       ├── voice_gamemgr.cpp
    │       ├── voice_gamemgr.h
    │       ├── voice_status.cpp
    │       ├── voice_status.h
    │       ├── vphysics_sound.h
    │       ├── vphysicsupdateai.h
    │       ├── weapon_ifmbase.cpp
    │       ├── weapon_ifmbase.h
    │       ├── weapon_ifmbasecamera.cpp
    │       ├── weapon_ifmbasecamera.h
    │       ├── weapon_ifmsteadycam.cpp
    │       ├── weapon_ifmsteadycam.h
    │       ├── weapon_parse.cpp
    │       ├── weapon_parse.h
    │       ├── weapon_parse_default.cpp
    │       ├── weapon_proficiency.cpp
    │       ├── weapon_proficiency.h
    │       ├── cstrike/
    │       │   ├── achievements_cs.cpp
    │       │   ├── achievements_cs.h
    │       │   ├── basecsgrenade_projectile.cpp
    │       │   ├── basecsgrenade_projectile.h
    │       │   ├── cs_achievement_constants.h
    │       │   ├── cs_achievementdefs.h
    │       │   ├── cs_ammodef.cpp
    │       │   ├── cs_ammodef.h
    │       │   ├── cs_blackmarket.cpp
    │       │   ├── cs_blackmarket.h
    │       │   ├── cs_gamemovement.cpp
    │       │   ├── cs_gamerules.cpp
    │       │   ├── cs_gamerules.h
    │       │   ├── cs_gamestats_shared.cpp
    │       │   ├── cs_gamestats_shared.h
    │       │   ├── cs_player_shared.cpp
    │       │   ├── cs_playeranimstate.cpp
    │       │   ├── cs_playeranimstate.h
    │       │   ├── cs_shareddefs.cpp
    │       │   ├── cs_shareddefs.h
    │       │   ├── cs_urlretrieveprices.cpp
    │       │   ├── cs_urlretrieveprices.h
    │       │   ├── cs_usermessages.cpp
    │       │   ├── cs_weapon_parse.cpp
    │       │   ├── cs_weapon_parse.h
    │       │   ├── flashbang_projectile.cpp
    │       │   ├── flashbang_projectile.h
    │       │   ├── fx_cs_shared.cpp
    │       │   ├── fx_cs_shared.h
    │       │   ├── hegrenade_projectile.cpp
    │       │   ├── hegrenade_projectile.h
    │       │   ├── weapon_ak47.cpp
    │       │   ├── weapon_aug.cpp
    │       │   ├── weapon_awp.cpp
    │       │   ├── weapon_basecsgrenade.cpp
    │       │   ├── weapon_basecsgrenade.h
    │       │   ├── weapon_c4.cpp
    │       │   ├── weapon_c4.h
    │       │   ├── weapon_csbase.cpp
    │       │   ├── weapon_csbase.h
    │       │   ├── weapon_csbasegun.cpp
    │       │   ├── weapon_csbasegun.h
    │       │   ├── weapon_deagle.cpp
    │       │   ├── weapon_elite.cpp
    │       │   ├── weapon_famas.cpp
    │       │   ├── weapon_fiveseven.cpp
    │       │   ├── weapon_flashbang.cpp
    │       │   ├── weapon_flashbang.h
    │       │   ├── weapon_g3sg1.cpp
    │       │   ├── weapon_galil.cpp
    │       │   ├── weapon_glock.cpp
    │       │   ├── weapon_hegrenade.cpp
    │       │   ├── weapon_hegrenade.h
    │       │   ├── weapon_knife.cpp
    │       │   ├── weapon_knife.h
    │       │   ├── weapon_m249.cpp
    │       │   ├── weapon_m3.cpp
    │       │   ├── weapon_m4a1.cpp
    │       │   ├── weapon_mac10.cpp
    │       │   ├── weapon_mp5navy.cpp
    │       │   ├── weapon_p228.cpp
    │       │   ├── weapon_p90.cpp
    │       │   ├── weapon_scout.cpp
    │       │   ├── weapon_sg550.cpp
    │       │   ├── weapon_sg552.cpp
    │       │   ├── weapon_smokegrenade.cpp
    │       │   ├── weapon_smokegrenade.h
    │       │   ├── weapon_tmp.cpp
    │       │   ├── weapon_ump45.cpp
    │       │   ├── weapon_usp.cpp
    │       │   ├── weapon_xm1014.cpp
    │       │   └── bot/
    │       │       ├── bot.cpp
    │       │       ├── bot.h
    │       │       ├── bot_constants.h
    │       │       ├── bot_hide.cpp
    │       │       ├── bot_manager.cpp
    │       │       ├── bot_manager.h
    │       │       ├── bot_profile.cpp
    │       │       ├── bot_profile.h
    │       │       ├── bot_util.cpp
    │       │       ├── bot_util.h
    │       │       ├── improv_locomotor.h
    │       │       ├── nav_path.cpp
    │       │       ├── nav_path.h
    │       │       ├── shared_util.cpp
    │       │       └── shared_util.h
    │       ├── dod/
    │       │   ├── achievements_dod.cpp
    │       │   ├── dod_gamemovement.cpp
    │       │   ├── dod_gamerules.cpp
    │       │   ├── dod_gamerules.h
    │       │   ├── dod_player_shared.cpp
    │       │   ├── dod_player_shared.h
    │       │   ├── dod_playeranimstate.cpp
    │       │   ├── dod_playeranimstate.h
    │       │   ├── dod_playerclass_info_parse.cpp
    │       │   ├── dod_playerclass_info_parse.h
    │       │   ├── dod_round_timer.cpp
    │       │   ├── dod_round_timer.h
    │       │   ├── dod_shareddefs.cpp
    │       │   ├── dod_shareddefs.h
    │       │   ├── dod_usermessages.cpp
    │       │   ├── dod_viewmodel.cpp
    │       │   ├── dod_viewmodel.h
    │       │   ├── dod_weapon_parse.cpp
    │       │   ├── dod_weapon_parse.h
    │       │   ├── fx_dod_shared.cpp
    │       │   ├── fx_dod_shared.h
    │       │   ├── weapon_30cal.cpp
    │       │   ├── weapon_amerknife.cpp
    │       │   ├── weapon_bar.cpp
    │       │   ├── weapon_bazooka.cpp
    │       │   ├── weapon_c96.cpp
    │       │   ├── weapon_colt.cpp
    │       │   ├── weapon_dodbase.cpp
    │       │   ├── weapon_dodbase.h
    │       │   ├── weapon_dodbasebomb.cpp
    │       │   ├── weapon_dodbasebomb.h
    │       │   ├── weapon_dodbasegrenade.cpp
    │       │   ├── weapon_dodbasegrenade.h
    │       │   ├── weapon_dodbasegun.cpp
    │       │   ├── weapon_dodbasegun.h
    │       │   ├── weapon_dodbasemelee.cpp
    │       │   ├── weapon_dodbasemelee.h
    │       │   ├── weapon_dodbaserpg.cpp
    │       │   ├── weapon_dodbaserpg.h
    │       │   ├── weapon_dodbipodgun.cpp
    │       │   ├── weapon_dodbipodgun.h
    │       │   ├── weapon_dodfireselect.cpp
    │       │   ├── weapon_dodfireselect.h
    │       │   ├── weapon_dodfullauto.cpp
    │       │   ├── weapon_dodfullauto.h
    │       │   ├── weapon_dodfullauto_punch.cpp
    │       │   ├── weapon_dodfullauto_punch.h
    │       │   ├── weapon_dodsemiauto.cpp
    │       │   ├── weapon_dodsemiauto.h
    │       │   ├── weapon_dodsniper.cpp
    │       │   ├── weapon_dodsniper.h
    │       │   ├── weapon_explodinghandgrenade.cpp
    │       │   ├── weapon_explodingstickgrenade.cpp
    │       │   ├── weapon_garand.cpp
    │       │   ├── weapon_gerknife.cpp
    │       │   ├── weapon_greasegun.cpp
    │       │   ├── weapon_handgrenade.cpp
    │       │   ├── weapon_k98.cpp
    │       │   ├── weapon_k98_scoped.cpp
    │       │   ├── weapon_m1carbine.cpp
    │       │   ├── weapon_mg34.cpp
    │       │   ├── weapon_mg42.cpp
    │       │   ├── weapon_mg42.h
    │       │   ├── weapon_mp40.cpp
    │       │   ├── weapon_mp44.cpp
    │       │   ├── weapon_p38.cpp
    │       │   ├── weapon_pschreck.cpp
    │       │   ├── weapon_riflegrenade.cpp
    │       │   ├── weapon_riflegrenade.h
    │       │   ├── weapon_riflegrenade_ger.cpp
    │       │   ├── weapon_riflegrenade_ger_live.cpp
    │       │   ├── weapon_riflegrenade_us.cpp
    │       │   ├── weapon_riflegrenade_us_live.cpp
    │       │   ├── weapon_smokegrenade_ger.cpp
    │       │   ├── weapon_smokegrenade_us.cpp
    │       │   ├── weapon_spade.cpp
    │       │   ├── weapon_spring.cpp
    │       │   ├── weapon_stickgrenade.cpp
    │       │   └── weapon_thompson.cpp
    │       ├── econ/
    │       │   └── ihasowner.h
    │       ├── episodic/
    │       │   ├── achievements_ep1.cpp
    │       │   ├── achievements_ep2.cpp
    │       │   ├── achievements_epx.cpp
    │       │   └── npc_advisor_shared.h
    │       ├── hl1/
    │       │   ├── hl1_basecombatweapon_shared.cpp
    │       │   ├── hl1_basecombatweapon_shared.h
    │       │   ├── hl1_gamemovement.cpp
    │       │   ├── hl1_gamemovement.h
    │       │   ├── hl1_gamerules.cpp
    │       │   ├── hl1_gamerules.h
    │       │   ├── hl1_player_shared.cpp
    │       │   ├── hl1_player_shared.h
    │       │   ├── hl1_shareddefs.h
    │       │   ├── hl1_usermessages.cpp
    │       │   ├── hl1mp_basecombatweapon_shared.cpp
    │       │   ├── hl1mp_basecombatweapon_shared.h
    │       │   ├── hl1mp_gamerules.cpp
    │       │   ├── hl1mp_gamerules.h
    │       │   ├── hl1mp_weapon_357.cpp
    │       │   ├── hl1mp_weapon_crossbow.cpp
    │       │   ├── hl1mp_weapon_egon.cpp
    │       │   ├── hl1mp_weapon_gauss.cpp
    │       │   ├── hl1mp_weapon_glock.cpp
    │       │   ├── hl1mp_weapon_handgrenade.cpp
    │       │   ├── hl1mp_weapon_hornetgun.cpp
    │       │   ├── hl1mp_weapon_mp5.cpp
    │       │   ├── hl1mp_weapon_mp5.h
    │       │   ├── hl1mp_weapon_rpg.cpp
    │       │   ├── hl1mp_weapon_rpg.h
    │       │   ├── hl1mp_weapon_sachel.cpp
    │       │   ├── hl1mp_weapon_satchel.h
    │       │   └── hl1mp_weapon_shotgun.cpp
    │       ├── hl2/
    │       │   ├── achievements_hl2.cpp
    │       │   ├── basehlcombatweapon_shared.cpp
    │       │   ├── basehlcombatweapon_shared.h
    │       │   ├── citadel_effects_shared.h
    │       │   ├── env_alyxemp_shared.h
    │       │   ├── env_headcrabcanister_shared.cpp
    │       │   ├── env_headcrabcanister_shared.h
    │       │   ├── hl2_gamerules.cpp
    │       │   ├── hl2_gamerules.h
    │       │   ├── hl2_player_shared.h
    │       │   ├── hl2_shareddefs.h
    │       │   ├── hl2_usermessages.cpp
    │       │   ├── hl2_vehicle_radar.h
    │       │   ├── hl_gamemovement.cpp
    │       │   ├── hl_gamemovement.h
    │       │   ├── hl_movedata.h
    │       │   └── survival_gamerules.cpp
    │       ├── hl2mp/
    │       │   ├── hl2mp_gamerules.cpp
    │       │   ├── hl2mp_gamerules.h
    │       │   ├── hl2mp_player_shared.cpp
    │       │   ├── hl2mp_player_shared.h
    │       │   ├── hl2mp_weapon_parse.cpp
    │       │   ├── hl2mp_weapon_parse.h
    │       │   ├── weapon_357.cpp
    │       │   ├── weapon_ar2.cpp
    │       │   ├── weapon_ar2.h
    │       │   ├── weapon_crossbow.cpp
    │       │   ├── weapon_crowbar.cpp
    │       │   ├── weapon_crowbar.h
    │       │   ├── weapon_frag.cpp
    │       │   ├── weapon_hl2mpbase.cpp
    │       │   ├── weapon_hl2mpbase.h
    │       │   ├── weapon_hl2mpbase_machinegun.cpp
    │       │   ├── weapon_hl2mpbase_machinegun.h
    │       │   ├── weapon_hl2mpbasebasebludgeon.cpp
    │       │   ├── weapon_hl2mpbasebasebludgeon.h
    │       │   ├── weapon_hl2mpbasehlmpcombatweapon.cpp
    │       │   ├── weapon_hl2mpbasehlmpcombatweapon.h
    │       │   ├── weapon_physcannon.cpp
    │       │   ├── weapon_physcannon.h
    │       │   ├── weapon_pistol.cpp
    │       │   ├── weapon_rpg.cpp
    │       │   ├── weapon_rpg.h
    │       │   ├── weapon_shotgun.cpp
    │       │   ├── weapon_slam.cpp
    │       │   ├── weapon_slam.h
    │       │   ├── weapon_smg1.cpp
    │       │   └── weapon_stunstick.cpp
    │       ├── Multiplayer/
    │       │   ├── multiplayer_animstate.cpp
    │       │   └── multiplayer_animstate.h
    │       ├── portal/
    │       │   ├── achievements_portal.cpp
    │       │   ├── env_lightrail_endpoint_shared.h
    │       │   ├── env_portal_path_track_shared.h
    │       │   ├── portal_collideable_enumerator.cpp
    │       │   ├── portal_collideable_enumerator.h
    │       │   ├── portal_game_account.h
    │       │   ├── portal_game_account_client.h
    │       │   ├── portal_gamemovement.cpp
    │       │   ├── portal_gamerules.cpp
    │       │   ├── portal_gamerules.h
    │       │   ├── portal_gcmessages.cpp
    │       │   ├── portal_gcmessages.h
    │       │   ├── portal_gcschema.cpp
    │       │   ├── portal_gcschema.h
    │       │   ├── portal_gcschema.sch
    │       │   ├── portal_mp_gamerules.cpp
    │       │   ├── portal_mp_gamerules.h
    │       │   ├── portal_player_shared.cpp
    │       │   ├── portal_player_shared.h
    │       │   ├── portal_playeranimstate.cpp
    │       │   ├── portal_playeranimstate.h
    │       │   ├── portal_shareddefs.cpp
    │       │   ├── portal_shareddefs.h
    │       │   ├── portal_usermessages.cpp
    │       │   ├── portal_util_shared.cpp
    │       │   ├── portal_util_shared.h
    │       │   ├── portal_weapon_parse.cpp
    │       │   ├── portal_weapon_parse.h
    │       │   ├── PortalSimulation.cpp
    │       │   ├── PortalSimulation.h
    │       │   ├── prop_portal_shared.cpp
    │       │   ├── prop_portal_shared.h
    │       │   ├── StaticCollisionPolyhedronCache.cpp
    │       │   ├── StaticCollisionPolyhedronCache.h
    │       │   ├── weapon_portalbase.cpp
    │       │   ├── weapon_portalbase.h
    │       │   ├── weapon_portalbasecombatweapon.cpp
    │       │   ├── weapon_portalbasecombatweapon.h
    │       │   ├── weapon_portalgun_shared.cpp
    │       │   └── weapon_portalgun_shared.h
    │       ├── sdk/
    │       │   ├── sdk_basegrenade_projectile.cpp
    │       │   ├── sdk_basegrenade_projectile.h
    │       │   ├── sdk_fx_shared.cpp
    │       │   ├── sdk_fx_shared.h
    │       │   ├── sdk_gamemovement.cpp
    │       │   ├── sdk_gamerules.cpp
    │       │   ├── sdk_gamerules.h
    │       │   ├── sdk_player_shared.cpp
    │       │   ├── sdk_player_shared.h
    │       │   ├── sdk_playeranimstate.cpp
    │       │   ├── sdk_playeranimstate.h
    │       │   ├── sdk_playerclass_info_parse.cpp
    │       │   ├── sdk_playerclass_info_parse.h
    │       │   ├── sdk_shareddefs.cpp
    │       │   ├── sdk_shareddefs.h
    │       │   ├── sdk_usermessages.cpp
    │       │   ├── sdk_weapon_melee.cpp
    │       │   ├── sdk_weapon_melee.h
    │       │   ├── sdk_weapon_parse.cpp
    │       │   ├── sdk_weapon_parse.h
    │       │   ├── weapon_basesdkgrenade.cpp
    │       │   ├── weapon_basesdkgrenade.h
    │       │   ├── weapon_crowbar.cpp
    │       │   ├── weapon_grenade.cpp
    │       │   ├── weapon_grenade.h
    │       │   ├── weapon_mp5.cpp
    │       │   ├── weapon_pistol.cpp
    │       │   ├── weapon_sdkbase.cpp
    │       │   ├── weapon_sdkbase.h
    │       │   └── weapon_shotgun.cpp
    │       └── sixense/
    │           ├── sixense_convars.cpp
    │           └── sixense_convars_extern.h
    ├── gameui/
    │   ├── BackgroundMenuButton.cpp
    │   ├── BackgroundMenuButton.h
    │   ├── BasePanel.cpp
    │   ├── BasePanel.h
    │   ├── BaseSaveGameDialog.cpp
    │   ├── BaseSaveGameDialog.h
    │   ├── BenchmarkDialog.cpp
    │   ├── BenchmarkDialog.h
    │   ├── BitmapImagePanel.cpp
    │   ├── BitmapImagePanel.h
    │   ├── BonusMapsDatabase.cpp
    │   ├── BonusMapsDatabase.h
    │   ├── BonusMapsDialog.cpp
    │   ├── BonusMapsDialog.h
    │   ├── CDKeyEntryDialog.cpp
    │   ├── CDKeyEntryDialog.h
    │   ├── ChangeGameDialog.cpp
    │   ├── ChangeGameDialog.h
    │   ├── CommandCheckButton.cpp
    │   ├── CommandCheckButton.h
    │   ├── CommentaryDialog.cpp
    │   ├── CommentaryDialog.h
    │   ├── CommentaryExplanationDialog.cpp
    │   ├── CommentaryExplanationDialog.h
    │   ├── ContentControlDialog.cpp
    │   ├── ContentControlDialog.h
    │   ├── ControllerDialog.cpp
    │   ├── ControllerDialog.h
    │   ├── CreateMultiplayerGameBotPage.cpp
    │   ├── CreateMultiplayerGameBotPage.h
    │   ├── CreateMultiplayerGameDialog.cpp
    │   ├── CreateMultiplayerGameDialog.h
    │   ├── CreateMultiplayerGameGameplayPage.cpp
    │   ├── CreateMultiplayerGameGameplayPage.h
    │   ├── CreateMultiplayerGameServerPage.cpp
    │   ├── CreateMultiplayerGameServerPage.h
    │   ├── CustomTabExplanationDialog.cpp
    │   ├── CustomTabExplanationDialog.h
    │   ├── CvarNegateCheckButton.cpp
    │   ├── CvarNegateCheckButton.h
    │   ├── CvarTextEntry.cpp
    │   ├── CvarTextEntry.h
    │   ├── CvarToggleCheckButton.cpp
    │   ├── CvarToggleCheckButton.h
    │   ├── EngineInterface.h
    │   ├── GameApp.cpp
    │   ├── GameApp.h
    │   ├── GameConsole.cpp
    │   ├── GameConsole.h
    │   ├── GameConsoleDialog.cpp
    │   ├── GameConsoleDialog.h
    │   ├── GameUI.h
    │   ├── GameUI.vpc
    │   ├── GameUI_Interface.cpp
    │   ├── GameUI_Interface.h
    │   ├── gameui_util.cpp
    │   ├── gameui_util.h
    │   ├── GameUIPanel.h
    │   ├── HapticControlBox.cpp
    │   ├── HapticControlBox.h
    │   ├── KeyToggleCheckButton.cpp
    │   ├── KeyToggleCheckButton.h
    │   ├── LabeledCommandComboBox.cpp
    │   ├── LabeledCommandComboBox.h
    │   ├── LoadCommentaryDialog.cpp
    │   ├── LoadCommentaryDialog.h
    │   ├── LoadGameDialog.cpp
    │   ├── LoadGameDialog.h
    │   ├── LoadGameDialog_Xbox.cpp
    │   ├── LoadingDialog.cpp
    │   ├── LoadingDialog.h
    │   ├── LogoFile.cpp
    │   ├── ModInfo.cpp
    │   ├── ModInfo.h
    │   ├── MouseMessageForwardingPanel.cpp
    │   ├── MouseMessageForwardingPanel.h
    │   ├── MultiplayerAdvancedDialog.cpp
    │   ├── MultiplayerAdvancedDialog.h
    │   ├── NewGameDialog.cpp
    │   ├── NewGameDialog.h
    │   ├── OptionsDialog.cpp
    │   ├── OptionsDialog.h
    │   ├── OptionsDialog_Xbox.cpp
    │   ├── OptionsSubAudio.cpp
    │   ├── OptionsSubAudio.h
    │   ├── OptionsSubDifficulty.cpp
    │   ├── OptionsSubDifficulty.h
    │   ├── OptionsSubGame.cpp
    │   ├── OptionsSubGame.h
    │   ├── OptionsSubHaptics.cpp
    │   ├── OptionsSubHaptics.h
    │   ├── OptionsSubKeyboard.cpp
    │   ├── OptionsSubKeyboard.h
    │   ├── OptionsSubMouse.cpp
    │   ├── OptionsSubMouse.h
    │   ├── OptionsSubMultiplayer.cpp
    │   ├── OptionsSubMultiplayer.h
    │   ├── OptionsSubPortal.cpp
    │   ├── OptionsSubPortal.h
    │   ├── OptionsSubTouch.cpp
    │   ├── OptionsSubTouch.h
    │   ├── OptionsSubVideo.cpp
    │   ├── OptionsSubVideo.h
    │   ├── OptionsSubVoice.cpp
    │   ├── OptionsSubVoice.h
    │   ├── PanelListPanel.cpp
    │   ├── PanelListPanel.h
    │   ├── PlayerListDialog.cpp
    │   ├── PlayerListDialog.h
    │   ├── RunGameEngine.cpp
    │   ├── RunGameEngine.h
    │   ├── SaveGameBrowserDialog.cpp
    │   ├── SaveGameBrowserDialog.h
    │   ├── SaveGameDialog.cpp
    │   ├── SaveGameDialog.h
    │   ├── SaveGameDialog_Xbox.cpp
    │   ├── Sys_Utils.cpp
    │   ├── Sys_Utils.h
    │   ├── TextEntryBox.cpp
    │   ├── TextEntryBox.h
    │   ├── TGAImagePanel.cpp
    │   ├── TGAImagePanel.h
    │   ├── URLButton.cpp
    │   ├── URLButton.h
    │   ├── vcontrolslistpanel.cpp
    │   ├── vcontrolslistpanel.h
    │   ├── VGuiSystemModuleLoader.cpp
    │   ├── VGuiSystemModuleLoader.h
    │   ├── wscript
    │   ├── matchmaking/
    │   │   ├── achievementsdialog.cpp
    │   │   ├── achievementsdialog.h
    │   │   ├── basedialog.cpp
    │   │   ├── basedialog.h
    │   │   ├── dialogmenu.cpp
    │   │   ├── dialogmenu.h
    │   │   ├── leaderboarddialog.cpp
    │   │   ├── leaderboarddialog.h
    │   │   ├── matchmakingbasepanel.cpp
    │   │   ├── matchmakingbasepanel.h
    │   │   ├── pausedialog.cpp
    │   │   ├── pausedialog.h
    │   │   ├── sessionbrowserdialog.cpp
    │   │   ├── sessionbrowserdialog.h
    │   │   ├── sessionlobbydialog.cpp
    │   │   ├── sessionlobbydialog.h
    │   │   ├── sessionoptionsdialog.cpp
    │   │   ├── sessionoptionsdialog.h
    │   │   ├── welcomedialog.cpp
    │   │   └── welcomedialog.h
    │   └── xbox/
    │       └── xbox.def
    ├── gcsdk/
    │   ├── accountdetails.cpp
    │   ├── bufferpool.cpp
    │   ├── directory.cpp
    │   ├── framefunction.cpp
    │   ├── gc_convar.cpp
    │   ├── gc_sharedobjectcache.cpp
    │   ├── gcbase.cpp
    │   ├── gcclient.cpp
    │   ├── gcclient_sharedobjectcache.cpp
    │   ├── gcconstants.cpp
    │   ├── gcdirtyfield.cpp
    │   ├── gchost.cpp
    │   ├── gcinterface.cpp
    │   ├── gcjob.cpp
    │   ├── gcleaderboardapi.cpp
    │   ├── gclogger.cpp
    │   ├── gcmsg.cpp
    │   ├── gcparalleljobfarm.cpp
    │   ├── gcreportprinter.cpp
    │   ├── gcsdk_game.vpc
    │   ├── gcsdk_game_include.vpc
    │   ├── gcsdk_gc.vpc
    │   ├── gcsdk_gc_include.vpc
    │   ├── gcsdk_gcmessages.proto
    │   ├── gcsdk_gcmessages_include.vpc
    │   ├── gcsdk_include.vpc
    │   ├── gcsession.cpp
    │   ├── gcsqlquery.cpp
    │   ├── gcsystemaccess.cpp
    │   ├── gcsystemmsgs.proto
    │   ├── gcwebapi.cpp
    │   ├── gcwebapikey.cpp
    │   ├── gcwgjobmgr.cpp
    │   ├── http.cpp
    │   ├── job.cpp
    │   ├── jobmgr.cpp
    │   ├── jobtime.cpp
    │   ├── messagelist.cpp
    │   ├── msgprotobuf.cpp
    │   ├── netpacket.cpp
    │   ├── netpacketpool.cpp
    │   ├── protobufsharedobject.cpp
    │   ├── scheduledfunction.cpp
    │   ├── schemasharedobject.cpp
    │   ├── sdocache.cpp
    │   ├── sharedobject.cpp
    │   ├── sharedobjectcache.cpp
    │   ├── sharedobjecttransaction.cpp
    │   ├── stackstring.h
    │   ├── stdafx.cpp
    │   ├── stdafx.h
    │   ├── steammessages.proto
    │   ├── steammessages_include.vpc
    │   ├── webapi_response.cpp
    │   ├── workthreadpool.cpp
    │   ├── sqlaccess/
    │   │   ├── columnset.cpp
    │   │   ├── record.cpp
    │   │   ├── recordinfo.cpp
    │   │   ├── schema.cpp
    │   │   ├── schemafull.cpp
    │   │   ├── schemaupdate.cpp
    │   │   ├── sqlaccess.cpp
    │   │   ├── sqlrecord.cpp
    │   │   └── sqlutil.cpp
    │   └── steamextra/
    │       ├── clientenums.h
    │       ├── misc.cpp
    │       ├── misc.h
    │       ├── rtime.cpp
    │       ├── rtime.h
    │       ├── steamid.cpp
    │       ├── gamecoordinator/
    │       │   ├── igamecoordinator.h
    │       │   ├── igamecoordinatorhost.h
    │       │   ├── igcsqlquery.h
    │       │   └── igcsqlresultsetlist.h
    │       ├── steam/
    │       │   └── isteamgamecoordinator.h
    │       ├── tier0/
    │       │   └── t0constants.h
    │       └── tier1/
    │           ├── hashglobals.cpp
    │           ├── murmurhash3.cpp
    │           ├── murmurhash3.h
    │           ├── pearsonshash.h
    │           ├── tsmempool.cpp
    │           ├── tsmempool.h
    │           ├── tsmultimempool.cpp
    │           ├── tsmultimempool.h
    │           └── utlhashmaplarge.h
    ├── hammer/
    │   ├── activeitemlist.h
    │   ├── AnchorMgr.cpp
    │   ├── AnchorMgr.h
    │   ├── anglebox.cpp
    │   ├── anglebox.h
    │   ├── archdlg.cpp
    │   ├── archdlg.h
    │   ├── autoselcombo.cpp
    │   ├── autoselcombo.h
    │   ├── axes2.cpp
    │   ├── axes2.h
    │   ├── blockarray.cpp
    │   ├── blockarray.h
    │   ├── boundbox.cpp
    │   ├── boundbox.h
    │   ├── box3d.cpp
    │   ├── box3d.h
    │   ├── brushops.cpp
    │   ├── brushops.h
    │   ├── bsplighting.cpp
    │   ├── bsplighting.h
    │   ├── bsplightingthread.cpp
    │   ├── bsplightingthread.h
    │   ├── buildnum.cpp
    │   ├── buildnum.h
    │   ├── camera.cpp
    │   ├── camera.h
    │   ├── childfrm.cpp
    │   ├── childfrm.h
    │   ├── clipcode.cpp
    │   ├── clipcode.h
    │   ├── clock.cpp
    │   ├── controlbarids.h
    │   ├── createarch.cpp
    │   ├── culltreenode.cpp
    │   ├── culltreenode.h
    │   ├── custommessages.h
    │   ├── detailobjects.cpp
    │   ├── detailobjects.h
    │   ├── dispdlg.cpp
    │   ├── dispdlg.h
    │   ├── dispmanager.cpp
    │   ├── dispmanager.h
    │   ├── dispmapimagefilter.cpp
    │   ├── dispmapimagefilter.h
    │   ├── disppaint.cpp
    │   ├── disppaint.h
    │   ├── dispsew.cpp
    │   ├── dispsew.h
    │   ├── DispShore.cpp
    │   ├── DispShore.h
    │   ├── dispsubdiv.cpp
    │   ├── dispsubdiv.h
    │   ├── dispview.h
    │   ├── dummytexture.cpp
    │   ├── dummytexture.h
    │   ├── dynamicdialogwnd.cpp
    │   ├── dynamicdialogwnd.h
    │   ├── editgameclass.cpp
    │   ├── editgameclass.h
    │   ├── editgameconfigs.cpp
    │   ├── editgameconfigs.h
    │   ├── editgroups.cpp
    │   ├── editgroups.h
    │   ├── editorkeys.txt
    │   ├── editpathdlg.cpp
    │   ├── editpathdlg.h
    │   ├── editpathnodedlg.cpp
    │   ├── editpathnodedlg.h
    │   ├── editprefabdlg.cpp
    │   ├── editprefabdlg.h
    │   ├── entityconnection.cpp
    │   ├── entityconnection.h
    │   ├── entityhelpdlg.cpp
    │   ├── entityhelpdlg.h
    │   ├── entityreportdlg.cpp
    │   ├── entityreportdlg.h
    │   ├── error3d.h
    │   ├── events.cpp
    │   ├── faceedit_disppage.cpp
    │   ├── faceedit_disppage.h
    │   ├── faceedit_materialpage.cpp
    │   ├── faceedit_materialpage.h
    │   ├── faceeditsheet.cpp
    │   ├── faceeditsheet.h
    │   ├── facepaint.cur
    │   ├── FileChangeWatcher.cpp
    │   ├── FileChangeWatcher.h
    │   ├── filtercontrol.cpp
    │   ├── filtercontrol.h
    │   ├── FilteredComboBox.cpp
    │   ├── FilteredComboBox.h
    │   ├── gameconfig.cpp
    │   ├── gameconfig.h
    │   ├── gamepalette.cpp
    │   ├── gamepalette.h
    │   ├── gizmo.cpp
    │   ├── gizmo.h
    │   ├── globalfunctions.h
    │   ├── gotobrushdlg.cpp
    │   ├── gotobrushdlg.h
    │   ├── grouplist.cpp
    │   ├── grouplist.h
    │   ├── hammer.cpp
    │   ├── hammer.def
    │   ├── hammer.h
    │   ├── hammer.rc
    │   ├── hammer_dll.vpc
    │   ├── hammer_mathlib.cpp
    │   ├── hammer_mathlib.h
    │   ├── hammerbar.cpp
    │   ├── hammerbar.h
    │   ├── HammerScene.cpp
    │   ├── HammerScene.h
    │   ├── HammerVGui.cpp
    │   ├── HammerVGui.h
    │   ├── helperfactory.cpp
    │   ├── helperfactory.h
    │   ├── history.cpp
    │   ├── history.h
    │   ├── ibsplighting.h
    │   ├── ibsplightingthread.h
    │   ├── iconcombobox.cpp
    │   ├── iconcombobox.h
    │   ├── ieditortexture.h
    │   ├── keyboard.cpp
    │   ├── keyboard.h
    │   ├── listboxex.cpp
    │   ├── listboxex.h
    │   ├── loadsave_map.cpp
    │   ├── loadsave_rmf.cpp
    │   ├── lpreview_thread.cpp
    │   ├── lpreview_thread.h
    │   ├── lprvwindow.cpp
    │   ├── lprvwindow.h
    │   ├── mainfrm.cpp
    │   ├── mainfrm.h
    │   ├── makeprefablibrary.cpp
    │   ├── manifest.cpp
    │   ├── manifest.h
    │   ├── manifestdialog.cpp
    │   ├── manifestdialog.h
    │   ├── mapalignedbox.cpp
    │   ├── mapalignedbox.h
    │   ├── mapanimationdlg.cpp
    │   ├── mapanimationdlg.h
    │   ├── mapanimator.cpp
    │   ├── mapanimator.h
    │   ├── mapatom.h
    │   ├── MapAxisHandle.cpp
    │   ├── MapAxisHandle.h
    │   ├── mapcheckdlg.cpp
    │   ├── mapcheckdlg.h
    │   ├── mapclass.cpp
    │   ├── mapclass.h
    │   ├── mapcylinder.cpp
    │   ├── mapcylinder.h
    │   ├── mapdecal.cpp
    │   ├── mapdecal.h
    │   ├── mapdefs.h
    │   ├── MapDiffDlg.cpp
    │   ├── MapDiffDlg.h
    │   ├── mapdisp.cpp
    │   ├── mapdisp.h
    │   ├── mapdoc.h
    │   ├── mapentity.cpp
    │   ├── mapentity.h
    │   ├── maperrorsdlg.cpp
    │   ├── maperrorsdlg.h
    │   ├── mapface.cpp
    │   ├── mapface.h
    │   ├── mapfrustum.cpp
    │   ├── mapfrustum.h
    │   ├── mapgroup.cpp
    │   ├── mapgroup.h
    │   ├── maphelper.cpp
    │   ├── MapHelper.h
    │   ├── mapinfodlg.cpp
    │   ├── mapinfodlg.h
    │   ├── mapinstance.cpp
    │   ├── mapinstance.h
    │   ├── mapkeyframe.cpp
    │   ├── mapkeyframe.h
    │   ├── maplight.cpp
    │   ├── maplight.h
    │   ├── maplightcone.cpp
    │   ├── maplightcone.h
    │   ├── mapline.cpp
    │   ├── mapline.h
    │   ├── mapoverlay.cpp
    │   ├── mapoverlay.h
    │   ├── mapoverlaytrans.cpp
    │   ├── mapoverlaytrans.h
    │   ├── mappath.cpp
    │   ├── mappath.h
    │   ├── mapplayerhullhandle.cpp
    │   ├── mapplayerhullhandle.h
    │   ├── mappoint.cpp
    │   ├── mappoint.h
    │   ├── mappointhandle.cpp
    │   ├── mappointhandle.h
    │   ├── mapquadbounds.cpp
    │   ├── mapquadbounds.h
    │   ├── mapsidelist.cpp
    │   ├── mapsidelist.h
    │   ├── mapsolid.cpp
    │   ├── mapsolid.h
    │   ├── mapsphere.cpp
    │   ├── mapsphere.h
    │   ├── mapsprite.cpp
    │   ├── mapsprite.h
    │   ├── mapstudiomodel.cpp
    │   ├── mapstudiomodel.h
    │   ├── mapsweptplayerhull.cpp
    │   ├── mapsweptplayerhull.h
    │   ├── mapview.cpp
    │   ├── mapview.h
    │   ├── mapview2d.cpp
    │   ├── mapview2d.h
    │   ├── mapview2dbase.cpp
    │   ├── mapview2dbase.h
    │   ├── mapview3d.cpp
    │   ├── mapview3d.h
    │   ├── mapviewlogical.cpp
    │   ├── mapviewlogical.h
    │   ├── mapworld.cpp
    │   ├── mapworld.h
    │   ├── material.cpp
    │   ├── material.h
    │   ├── materialdlg.cpp
    │   ├── materialdlg.h
    │   ├── materialproxyfactory_wc.cpp
    │   ├── materialproxyfactory_wc.h
    │   ├── mdiclientwnd.cpp
    │   ├── mdiclientwnd.h
    │   ├── messagewnd.cpp
    │   ├── messagewnd.h
    │   ├── misc.cpp
    │   ├── ModelBrowser.cpp
    │   ├── ModelBrowser.h
    │   ├── modelfactory.cpp
    │   ├── modelfactory.h
    │   ├── mychecklistbox.h
    │   ├── new16.txt
    │   ├── newdoctype.cpp
    │   ├── newdoctype.h
    │   ├── newkeyvalue.cpp
    │   ├── newkeyvalue.h
    │   ├── NewVisGroupDlg.cpp
    │   ├── NewVisGroupDlg.h
    │   ├── noise.cpp
    │   ├── objectbar.cpp
    │   ├── objectbar.h
    │   ├── ObjectPage.cpp
    │   ├── objectpage.h
    │   ├── objectproperties.cpp
    │   ├── objectproperties.h
    │   ├── op_entity.cpp
    │   ├── op_entity.h
    │   ├── op_flags.cpp
    │   ├── op_flags.h
    │   ├── op_groups.cpp
    │   ├── op_groups.h
    │   ├── op_input.cpp
    │   ├── op_input.h
    │   ├── OP_Model.cpp
    │   ├── OP_Model.h
    │   ├── op_output.cpp
    │   ├── op_output.h
    │   ├── optbuild.cpp
    │   ├── optbuild.h
    │   ├── optconfigs.cpp
    │   ├── optconfigs.h
    │   ├── optgeneral.cpp
    │   ├── optgeneral.h
    │   ├── optionproperties.cpp
    │   ├── optionproperties.h
    │   ├── options.cpp
    │   ├── options.h
    │   ├── opttextures.cpp
    │   ├── opttextures.h
    │   ├── optview2d.cpp
    │   ├── optview2d.h
    │   ├── optview3d.cpp
    │   ├── optview3d.h
    │   ├── osver.cpp
    │   ├── osver.h
    │   ├── pakdoc.cpp
    │   ├── pakdoc.h
    │   ├── pakframe.cpp
    │   ├── pakframe.h
    │   ├── pakviewdirec.cpp
    │   ├── pakviewdirec.h
    │   ├── pakviewfiles.cpp
    │   ├── pakviewfiles.h
    │   ├── pastespecialdlg.cpp
    │   ├── pastespecialdlg.h
    │   ├── PopupMenus.h
    │   ├── prefab3d.cpp
    │   ├── prefab3d.h
    │   ├── prefabs.cpp
    │   ├── prefabs.h
    │   ├── prefabsdlg.cpp
    │   ├── prefabsdlg.h
    │   ├── processwnd.cpp
    │   ├── processwnd.h
    │   ├── progdlg.cpp
    │   ├── progdlg.h
    │   ├── Render.cpp
    │   ├── Render.h
    │   ├── render2d.cpp
    │   ├── render2d.h
    │   ├── render3d.cpp
    │   ├── render3d.h
    │   ├── render3dms.cpp
    │   ├── render3dms.h
    │   ├── RenderUtils.cpp
    │   ├── RenderUtils.h
    │   ├── replacetexdlg.cpp
    │   ├── replacetexdlg.h
    │   ├── resource.h
    │   ├── richeditctrlex.cpp
    │   ├── richeditctrlex.h
    │   ├── runcommands.cpp
    │   ├── runcommands.h
    │   ├── runmap.cpp
    │   ├── runmap.h
    │   ├── runmapcfgdlg.cpp
    │   ├── runmapcfgdlg.h
    │   ├── runmapexpertdlg.cpp
    │   ├── runmapexpertdlg.h
    │   ├── saveinfo.cpp
    │   ├── saveinfo.h
    │   ├── scaleverticesdlg.cpp
    │   ├── scaleverticesdlg.h
    │   ├── ScenePreviewDlg.cpp
    │   ├── ScenePreviewDlg.h
    │   ├── sculptoptions.cpp
    │   ├── sculptoptions.h
    │   ├── searchbox.cpp
    │   ├── searchbox.h
    │   ├── SearchReplaceDlg.cpp
    │   ├── SearchReplaceDlg.h
    │   ├── selectentitydlg.cpp
    │   ├── selectentitydlg.h
    │   ├── Selection.cpp
    │   ├── Selection.h
    │   ├── selectmodedlgbar.cpp
    │   ├── SelectModeDlgBar.h
    │   ├── shell.cpp
    │   ├── shell.h
    │   ├── shellmessagewnd.cpp
    │   ├── shellmessagewnd.h
    │   ├── SmoothingGroupMgr.cpp
    │   ├── SmoothingGroupMgr.h
    │   ├── SoundBrowser.cpp
    │   ├── SoundBrowser.h
    │   ├── soundsystem.cpp
    │   ├── soundsystem.h
    │   ├── splash.cpp
    │   ├── splash.h
    │   ├── sprite.cpp
    │   ├── sprite.h
    │   ├── ssolid.cpp
    │   ├── ssolid.h
    │   ├── statusbarids.h
    │   ├── stdafx.cpp
    │   ├── stdafx.h
    │   ├── stocksolids.cpp
    │   ├── stocksolids.h
    │   ├── strdlg.cpp
    │   ├── strdlg.h
    │   ├── studiomodel.cpp
    │   ├── studiomodel.h
    │   ├── subdiv.cpp
    │   ├── subdiv.h
    │   ├── targetnamecombo.cpp
    │   ├── targetnamecombo.h
    │   ├── test.txt
    │   ├── texture.cpp
    │   ├── texture.h
    │   ├── texturebar.cpp
    │   ├── texturebar.h
    │   ├── texturebox.cpp
    │   ├── texturebox.h
    │   ├── texturebrowser.cpp
    │   ├── texturebrowser.h
    │   ├── textureconverter.cpp
    │   ├── textureconverter.h
    │   ├── texturesystem.cpp
    │   ├── texturesystem.h
    │   ├── texturewindow.cpp
    │   ├── texturewindow.h
    │   ├── titlewnd.cpp
    │   ├── titlewnd.h
    │   ├── tool3d.cpp
    │   ├── tool3d.h
    │   ├── ToolAxisHandle.cpp
    │   ├── ToolAxisHandle.h
    │   ├── ToolBase.cpp
    │   ├── ToolBlock.cpp
    │   ├── ToolBlock.h
    │   ├── ToolCamera.cpp
    │   ├── ToolCamera.h
    │   ├── ToolClipper.cpp
    │   ├── ToolClipper.h
    │   ├── ToolCordon.cpp
    │   ├── ToolCordon.h
    │   ├── ToolDecal.cpp
    │   ├── ToolDecal.h
    │   ├── tooldefs.h
    │   ├── tooldisplace.cpp
    │   ├── tooldisplace.h
    │   ├── ToolEntity.cpp
    │   ├── ToolEntity.h
    │   ├── toolinterface.h
    │   ├── ToolMagnify.cpp
    │   ├── ToolMagnify.h
    │   ├── ToolManager.cpp
    │   ├── ToolManager.h
    │   ├── ToolMaterial.cpp
    │   ├── ToolMaterial.h
    │   ├── ToolMorph.cpp
    │   ├── ToolMorph.h
    │   ├── ToolOverlay.cpp
    │   ├── ToolOverlay.h
    │   ├── ToolPickAngles.cpp
    │   ├── ToolPickAngles.h
    │   ├── ToolPickEntity.cpp
    │   ├── ToolPickEntity.h
    │   ├── toolpickface.cpp
    │   ├── toolpickface.h
    │   ├── ToolPointHandle.cpp
    │   ├── ToolPointHandle.h
    │   ├── ToolSelection.cpp
    │   ├── ToolSelection.h
    │   ├── ToolSphere.cpp
    │   ├── ToolSphere.h
    │   ├── toolswepthull.cpp
    │   ├── toolswepthull.h
    │   ├── TorusDlg.cpp
    │   ├── torusdlg.h
    │   ├── transformdlg.cpp
    │   ├── transformdlg.h
    │   ├── undowarningdlg.cpp
    │   ├── undowarningdlg.h
    │   ├── updatehint.cpp
    │   ├── updatehint.h
    │   ├── vgui_undef_end.h
    │   ├── VGuiWnd.cpp
    │   ├── VGuiWnd.h
    │   ├── viewersettings.cpp
    │   ├── viewersettings.h
    │   ├── visgroup.cpp
    │   ├── visgroup.h
    │   ├── wadtexture.cpp
    │   ├── wadtexture.h
    │   ├── whatsnew.txt
    │   ├── wndtex.h
    │   └── res/
    │       ├── crosshair.cur
    │       ├── cur00001.cur
    │       ├── cur00002.cur
    │       ├── cursor1.cur
    │       ├── cursor2.cur
    │       ├── cursor3.cur
    │       ├── entity.cur
    │       ├── eyedropper.cur
    │       ├── handclos.cur
    │       ├── handcurs.cur
    │       ├── magnify.cur
    │       ├── mapedit.bmp2
    │       ├── mapeditt.bmp2
    │       ├── new-1.pcx
    │       └── smartclick.cur
    ├── hammer_launcher/
    │   ├── hammer_launcher.rc
    │   ├── hammer_launcher.vpc
    │   ├── main.cpp
    │   └── resource.h
    ├── inputsystem/
    │   ├── inputsystem.cpp
    │   ├── inputsystem.h
    │   ├── inputsystem.vpc
    │   ├── joystick_sdl.cpp
    │   ├── key_translation.cpp
    │   ├── key_translation.h
    │   ├── novint.cpp
    │   ├── posix_stubs.h
    │   ├── steamcontroller.cpp
    │   ├── touch_sdl.cpp
    │   ├── wscript
    │   └── Xbox/
    │       └── xbox.def
    ├── launcher/
    │   ├── ifilesystem.h
    │   ├── launcher.cpp
    │   ├── launcher.vpc
    │   ├── reslistgenerator.cpp
    │   ├── reslistgenerator.h
    │   ├── wscript
    │   ├── android/
    │   │   ├── crashhandler.cpp
    │   │   ├── main.cpp
    │   │   ├── demangle/
    │   │   │   ├── COPYING.LIB
    │   │   │   ├── cp-demangle.c
    │   │   │   ├── cp-demangle.h
    │   │   │   ├── demangle.h
    │   │   │   ├── demangle_test.cpp
    │   │   │   ├── MODULE_LICENSE_GPL
    │   │   │   └── NOTICE
    │   │   └── libunwind/
    │   │       ├── __libunwind_config.h
    │   │       ├── libunwind.h
    │   │       ├── unwind.h
    │   │       └── mach-o/
    │   │           └── compact_unwind_encoding.h
    │   └── xbox/
    │       └── xbox.def
    ├── launcher_main/
    │   ├── launcher_main.rc
    │   ├── launcher_main.vpc
    │   ├── main.cpp
    │   ├── resource.h
    │   └── wscript
    ├── linux/
    │   ├── missingsymbols
    │   ├── srcds_run
    │   └── make_check/
    │       ├── check_differences
    │       └── cache/
    │           ├── dedicated.dsp.check
    │           ├── engine.dsp.check
    │           ├── filesystem_stdio.dsp.check
    │           ├── hk_base.dsp.check
    │           ├── hk_math.dsp.check
    │           ├── materialsystem.dsp.check
    │           ├── shaderempty.dsp.check
    │           ├── shaderlib.dsp.check
    │           ├── studiorender.dsp.check
    │           ├── tier0.dsp.check
    │           ├── unitlib.dsp.check
    │           ├── vphysics.dsp.check
    │           ├── vstdlib.dsp.check
    │           └── vtf.dsp.check
    ├── linux_sdk/
    │   ├── Makefile
    │   ├── Makefile.mod
    │   ├── Makefile.plugin
    │   └── Makefile.vcpm
    ├── materialsystem/
    │   ├── CColorCorrection.cpp
    │   ├── checkmaterials.cpp
    │   ├── cmaterial.cpp
    │   ├── cmaterial_queuefriendly.cpp
    │   ├── cmaterial_queuefriendly.h
    │   ├── cmaterialdict.cpp
    │   ├── cmaterialdict.h
    │   ├── CMaterialSubRect.cpp
    │   ├── cmaterialsystem.cpp
    │   ├── cmaterialsystem.h
    │   ├── cmaterialvar.cpp
    │   ├── cmatlightmaps.cpp
    │   ├── cmatlightmaps.h
    │   ├── cmatnullrendercontext.cpp
    │   ├── cmatnullrendercontext.h
    │   ├── cmatqueuedrendercontext.cpp
    │   ├── cmatqueuedrendercontext.h
    │   ├── cmatrendercontext.cpp
    │   ├── cmatrendercontext.h
    │   ├── colorspace.cpp
    │   ├── colorspace.h
    │   ├── ctexture.cpp
    │   ├── ctexturecompositor.cpp
    │   ├── ctexturecompositor.h
    │   ├── genshadermacro.pl
    │   ├── IHardwareConfigInternal.h
    │   ├── imagepacker.cpp
    │   ├── imagepacker.h
    │   ├── imaterialinternal.h
    │   ├── imaterialsysteminternal.h
    │   ├── imatrendercontextinternal.h
    │   ├── imorphinternal.h
    │   ├── IShaderSystem.h
    │   ├── itextureinternal.h
    │   ├── mat_stub.cpp
    │   ├── mat_stub.h
    │   ├── MaterialSystem.rc
    │   ├── materialsystem.vpc
    │   ├── materialsystem_global.cpp
    │   ├── materialsystem_global.h
    │   ├── morph.cpp
    │   ├── occlusionquerymgr.cpp
    │   ├── occlusionquerymgr.h
    │   ├── pch_materialsystem.cpp
    │   ├── pch_materialsystem.h
    │   ├── resource.h
    │   ├── Resource.rc
    │   ├── shader_dll_verify.cpp
    │   ├── shader_dll_verify.h
    │   ├── shadersystem.cpp
    │   ├── shadersystem.h
    │   ├── texturemanager.cpp
    │   ├── texturemanager.h
    │   ├── wireframe.cpp
    │   ├── wscript
    │   ├── shaderapidx9/
    │   │   ├── colorformatdx8.cpp
    │   │   ├── colorformatdx8.h
    │   │   ├── cvballoctracker.cpp
    │   │   ├── d3d_async.cpp
    │   │   ├── d3d_async.h
    │   │   ├── dx9hook.h
    │   │   ├── dynamicib.h
    │   │   ├── dynamicvb.h
    │   │   ├── gpubufferallocator.cpp
    │   │   ├── gpubufferallocator.h
    │   │   ├── hardwareconfig.cpp
    │   │   ├── hardwareconfig.h
    │   │   ├── imeshdx8.h
    │   │   ├── inputlayoutdx10.cpp
    │   │   ├── inputlayoutdx10.h
    │   │   ├── ivertexbufferdx8.h
    │   │   ├── locald3dtypes.h
    │   │   ├── meshbase.cpp
    │   │   ├── meshbase.h
    │   │   ├── meshdx10.cpp
    │   │   ├── meshdx10.h
    │   │   ├── meshdx8.cpp
    │   │   ├── recording.cpp
    │   │   ├── recording.h
    │   │   ├── shaderapi_global.h
    │   │   ├── shaderapibase.cpp
    │   │   ├── shaderapibase.h
    │   │   ├── shaderapidx10.cpp
    │   │   ├── shaderapidx10.h
    │   │   ├── shaderapidx10.vpc
    │   │   ├── shaderapidx10_global.h
    │   │   ├── shaderapidx8.h
    │   │   ├── shaderapidx8_global.h
    │   │   ├── shaderapidx9.vpc
    │   │   ├── shaderdevicebase.cpp
    │   │   ├── shaderdevicebase.h
    │   │   ├── shaderdevicedx10.cpp
    │   │   ├── shaderdevicedx10.h
    │   │   ├── shaderdevicedx8.cpp
    │   │   ├── shaderdevicedx8.h
    │   │   ├── shadershadowdx10.cpp
    │   │   ├── ShaderShadowDx10.h
    │   │   ├── shadershadowdx8.cpp
    │   │   ├── shadershadowdx8.h
    │   │   ├── stubd3ddevice.h
    │   │   ├── texturedx8.cpp
    │   │   ├── texturedx8.h
    │   │   ├── textureheap.cpp
    │   │   ├── textureheap.h
    │   │   ├── TransitionTable.cpp
    │   │   ├── TransitionTable.h
    │   │   ├── vertexdecl.cpp
    │   │   ├── vertexdecl.h
    │   │   ├── vertexshaderdx8.cpp
    │   │   ├── vertexshaderdx8.h
    │   │   ├── winutils.cpp
    │   │   ├── winutils.h
    │   │   ├── wmi.cpp
    │   │   ├── wmi.h
    │   │   ├── wscript
    │   │   └── xbox/
    │   │       └── xbox.def
    │   ├── shaderapiempty/
    │   │   ├── shaderapiempty.cpp
    │   │   ├── shaderapiempty.vpc
    │   │   └── wscript
    │   ├── shaderlib/
    │   │   ├── BaseShader.cpp
    │   │   ├── ShaderDLL.cpp
    │   │   ├── shaderDLL_Global.h
    │   │   ├── shaderlib.vpc
    │   │   ├── shaderlib_cvar.cpp
    │   │   ├── shaderlib_cvar.h
    │   │   └── wscript
    │   ├── stdshaders/
    │   │   ├── AccumBuff4Sample.cpp
    │   │   ├── AccumBuff4Sample_ps2x.fxc
    │   │   ├── accumbuff5sample.cpp
    │   │   ├── accumbuff5sample_ps2x.fxc
    │   │   ├── aftershock.cpp
    │   │   ├── aftershock_helper.cpp
    │   │   ├── aftershock_helper.h
    │   │   ├── aftershock_ps2x.fxc
    │   │   ├── aftershock_vs20.fxc
    │   │   ├── alphadist_ps11.fxc
    │   │   ├── appchooser360movie_ps2x.fxc
    │   │   ├── BaseVSShader.cpp
    │   │   ├── BaseVSShader.h
    │   │   ├── bik_dx80.cpp
    │   │   ├── bik_dx81.cpp
    │   │   ├── bik_dx90.cpp
    │   │   ├── bik_ps11.psh
    │   │   ├── bik_ps14.psh
    │   │   ├── bik_ps2x.fxc
    │   │   ├── bik_vs11.vsh
    │   │   ├── bik_vs20.fxc
    │   │   ├── Bloom.cpp
    │   │   ├── Bloom_ps2x.fxc
    │   │   ├── bloomadd_ps11.fxc
    │   │   ├── bloomadd_ps2x.fxc
    │   │   ├── BlurFilter_ps11.psh
    │   │   ├── BlurFilter_ps2x.fxc
    │   │   ├── BlurFilter_vs11.fxc
    │   │   ├── BlurFilter_vs20.fxc
    │   │   ├── BlurFilterX.cpp
    │   │   ├── BlurFilterX_dx80.cpp
    │   │   ├── BlurFilterY.cpp
    │   │   ├── BlurFilterY_dx80.cpp
    │   │   ├── BufferClearObeyStencil_dx6.cpp
    │   │   ├── BufferClearObeyStencil_dx8.cpp
    │   │   ├── BufferClearObeyStencil_dx9.cpp
    │   │   ├── BufferClearObeyStencil_ps11.psh
    │   │   ├── bufferclearobeystencil_ps2x.fxc
    │   │   ├── BufferClearObeyStencil_vs11.vsh
    │   │   ├── bufferclearobeystencil_vs20.fxc
    │   │   ├── buildallshaders.bat
    │   │   ├── builddynamic.bat
    │   │   ├── buildshaders.bat
    │   │   ├── BumpmappedEnvmap.psh
    │   │   ├── BumpmappedEnvmap.vsh
    │   │   ├── BumpmappedLightmap.vsh
    │   │   ├── BumpmappedLightmap_LightingOnly_OverBright2.psh
    │   │   ├── BumpmappedLightmap_OverBright2.psh
    │   │   ├── bumpmappedlightmap_vs11.fxc
    │   │   ├── Cable.psh
    │   │   ├── Cable.vsh
    │   │   ├── cable_dx6.cpp
    │   │   ├── cable_dx8.cpp
    │   │   ├── cable_dx9.cpp
    │   │   ├── cable_ps2x.fxc
    │   │   ├── cable_vs20.fxc
    │   │   ├── clean.bat
    │   │   ├── cleantemps.bat
    │   │   ├── cloak.cpp
    │   │   ├── cloak_blended_pass_dx8_helper.cpp
    │   │   ├── cloak_blended_pass_dx8_ps11.psh
    │   │   ├── cloak_blended_pass_dx8_vs11.vsh
    │   │   ├── cloak_blended_pass_helper.cpp
    │   │   ├── cloak_blended_pass_helper.h
    │   │   ├── cloak_blended_pass_ps2x.fxc
    │   │   ├── cloak_blended_pass_vs20.fxc
    │   │   ├── cloak_dx9_helper.cpp
    │   │   ├── cloak_dx9_helper.h
    │   │   ├── cloak_ps2x.fxc
    │   │   ├── cloak_vs20.fxc
    │   │   ├── cloud.cpp
    │   │   ├── cloud_dx8.cpp
    │   │   ├── cloud_dx9.cpp
    │   │   ├── cloud_ps11.psh
    │   │   ├── cloud_ps20.fxc
    │   │   ├── cloud_vs11.vsh
    │   │   ├── cloud_vs20.fxc
    │   │   ├── color_projection.cpp
    │   │   ├── color_projection_ps2x.fxc
    │   │   ├── color_projection_vs20.fxc
    │   │   ├── colorcorrection.cpp
    │   │   ├── colorcorrection_ps2x.fxc
    │   │   ├── commandbuilder.h
    │   │   ├── common_flashlight_fxc.h
    │   │   ├── common_fxc.h
    │   │   ├── common_fxc2.h
    │   │   ├── common_hlsl_cpp_consts.h
    │   │   ├── common_lightmappedgeneric_fxc.h
    │   │   ├── common_pragmas.h
    │   │   ├── common_ps_fxc.h
    │   │   ├── common_vertexlitgeneric_dx9.h
    │   │   ├── common_vertexlitgeneric_vs20.fxc
    │   │   ├── common_vs_fxc.h
    │   │   ├── compositor.cpp
    │   │   ├── compositor_ps2x.fxc
    │   │   ├── compositor_vs20.fxc
    │   │   ├── constant_color_ps2x.fxc
    │   │   ├── copy_fp_rt_ps2x.fxc
    │   │   ├── core_dx7.cpp
    │   │   ├── core_dx8.cpp
    │   │   ├── core_dx9.cpp
    │   │   ├── core_ps11.psh
    │   │   ├── core_ps2x.fxc
    │   │   ├── core_vs11.fxc
    │   │   ├── core_vs20.fxc
    │   │   ├── cpp_shader_constant_register_map.h
    │   │   ├── debugdepth.cpp
    │   │   ├── DebugDrawDepth_ps2x.fxc
    │   │   ├── DebugDrawDepth_vs20.fxc
    │   │   ├── DebugDrawEnvmapMask.cpp
    │   │   ├── DebugDrawEnvmapMask_ps2x.fxc
    │   │   ├── DebugDrawEnvmapMask_vs20.fxc
    │   │   ├── debugluxel.cpp
    │   │   ├── debugluxel_ps2x.fxc
    │   │   ├── debugluxel_vs20.fxc
    │   │   ├── debugmodifyvertex.cpp
    │   │   ├── debugmorphaccumulator_dx9.cpp
    │   │   ├── debugmorphaccumulator_ps30.fxc
    │   │   ├── debugmorphaccumulator_vs30.fxc
    │   │   ├── debugmrttexture.cpp
    │   │   ├── debugmrttexture_ps2x.fxc
    │   │   ├── debugmrttexture_vs20.fxc
    │   │   ├── debugnormalmap.cpp
    │   │   ├── debugsoftwarevertexshader.cpp
    │   │   ├── debugtangentspace.cpp
    │   │   ├── debugtangentspace.vsh
    │   │   ├── debugtangentspace_vs11.fxc
    │   │   ├── debugtangentspace_vs20.fxc
    │   │   ├── DebugTextureView.cpp
    │   │   ├── DebugTextureView_ps2x.fxc
    │   │   ├── DebugTextureView_vs20.fxc
    │   │   ├── decal.cpp
    │   │   ├── DecalBaseTimesLightmapAlphaBlendSelfIllum1_ps11.psh
    │   │   ├── DecalBaseTimesLightmapAlphaBlendSelfIllum2_ps11.psh
    │   │   ├── decalbasetimeslightmapalphablendselfillum2_ps2x.fxc
    │   │   ├── DecalBaseTimesLightmapAlphaBlendSelfIllum_dx6.cpp
    │   │   ├── DecalBaseTimesLightmapAlphaBlendSelfIllum_dx8.cpp
    │   │   ├── DecalBaseTimesLightmapAlphaBlendSelfIllum_dx9.cpp
    │   │   ├── decalmodulate.cpp
    │   │   ├── decalmodulate_dx8.cpp
    │   │   ├── DecalModulate_dx9.cpp
    │   │   ├── decalmodulate_ps11.psh
    │   │   ├── decalmodulate_ps2x.fxc
    │   │   ├── decalmodulate_vs11.vsh
    │   │   ├── depthtodestalpha_ps20b.fxc
    │   │   ├── depthtodestalpha_vs20.fxc
    │   │   ├── depthwrite.cpp
    │   │   ├── depthwrite_ps2x.fxc
    │   │   ├── depthwrite_vs20.fxc
    │   │   ├── detail.cpp
    │   │   ├── detail_ps11.psh
    │   │   ├── detail_vs11.vsh
    │   │   ├── Downsample.cpp
    │   │   ├── downsample_nohdr.cpp
    │   │   ├── downsample_nohdr_dx80.cpp
    │   │   ├── Downsample_nohdr_ps11.psh
    │   │   ├── Downsample_nohdr_ps2x.fxc
    │   │   ├── Downsample_ps2x.fxc
    │   │   ├── Downsample_vs11.fxc
    │   │   ├── Downsample_vs20.fxc
    │   │   ├── dx8fallbacks.cpp
    │   │   ├── emissive_scroll_blended_pass_dx8_helper.cpp
    │   │   ├── emissive_scroll_blended_pass_dx8_ps11.psh
    │   │   ├── emissive_scroll_blended_pass_dx8_vs11.vsh
    │   │   ├── emissive_scroll_blended_pass_helper.cpp
    │   │   ├── emissive_scroll_blended_pass_helper.h
    │   │   ├── emissive_scroll_blended_pass_ps2x.fxc
    │   │   ├── emissive_scroll_blended_pass_vs20.fxc
    │   │   ├── Engine_Post_dx9.cpp
    │   │   ├── Engine_Post_ps2x.fxc
    │   │   ├── example_model_dx9.cpp
    │   │   ├── example_model_dx9_helper.cpp
    │   │   ├── example_model_dx9_helper.h
    │   │   ├── example_model_ps20b.fxc
    │   │   ├── example_model_vs20.fxc
    │   │   ├── eye_refract.cpp
    │   │   ├── eye_refract_helper.cpp
    │   │   ├── eye_refract_helper.h
    │   │   ├── eye_refract_ps2x.fxc
    │   │   ├── eye_refract_vs20.fxc
    │   │   ├── eyeball.cpp
    │   │   ├── eyeglint_dx9.cpp
    │   │   ├── eyeglint_ps2x.fxc
    │   │   ├── eyeglint_vs20.fxc
    │   │   ├── eyes.cpp
    │   │   ├── Eyes.psh
    │   │   ├── eyes.vsh
    │   │   ├── eyes_dx6.cpp
    │   │   ├── eyes_dx8_dx9_helper.cpp
    │   │   ├── eyes_dx8_dx9_helper.h
    │   │   ├── eyes_dx9.cpp
    │   │   ├── eyes_flashlight2_ps11.psh
    │   │   ├── eyes_flashlight_inc.fxc
    │   │   ├── eyes_flashlight_ps11.fxc
    │   │   ├── eyes_flashlight_ps2x.fxc
    │   │   ├── eyes_flashlight_vs11.vsh
    │   │   ├── eyes_flashlight_vs20.fxc
    │   │   ├── Eyes_Overbright2.psh
    │   │   ├── eyes_ps2x.fxc
    │   │   ├── Eyes_vs20.fxc
    │   │   ├── fillrate.cpp
    │   │   ├── fillrate.psh
    │   │   ├── fillrate.vsh
    │   │   ├── fillrate_ps11.fxc
    │   │   ├── fillrate_ps2x.fxc
    │   │   ├── fillrate_vs11.fxc
    │   │   ├── fillrate_vs20.fxc
    │   │   ├── filmdust_dx7.cpp
    │   │   ├── filmdust_dx8_dx9.cpp
    │   │   ├── filmdust_ps11.fxc
    │   │   ├── filmdust_ps20.fxc
    │   │   ├── filmgrain_dx7.cpp
    │   │   ├── filmgrain_dx8_dx9.cpp
    │   │   ├── filmgrain_ps11.fxc
    │   │   ├── filmgrain_ps20.fxc
    │   │   ├── filmgrain_vs20.fxc
    │   │   ├── flashlight_ps11.fxc
    │   │   ├── flashlight_ps2x.fxc
    │   │   ├── flesh_interior_blended_pass_dx8_helper.cpp
    │   │   ├── flesh_interior_blended_pass_dx8_ps11.psh
    │   │   ├── flesh_interior_blended_pass_dx8_vs11.vsh
    │   │   ├── flesh_interior_blended_pass_helper.cpp
    │   │   ├── flesh_interior_blended_pass_helper.h
    │   │   ├── flesh_interior_blended_pass_ps2x.fxc
    │   │   ├── flesh_interior_blended_pass_vs20.fxc
    │   │   ├── floatcombine.cpp
    │   │   ├── floatcombine_autoexpose.cpp
    │   │   ├── floatcombine_autoexpose_ps2x.fxc
    │   │   ├── floatcombine_ps2x.fxc
    │   │   ├── floattoscreen.cpp
    │   │   ├── floattoscreen_notonemap_ps2x.fxc
    │   │   ├── floattoscreen_ps2x.fxc
    │   │   ├── floattoscreen_vanilla.cpp
    │   │   ├── floattoscreen_vanilla_ps2x.fxc
    │   │   ├── genwaterloop.pl
    │   │   ├── glowwarp.psh
    │   │   ├── gooinglass.cpp
    │   │   ├── haloadd1d_ps2x.fxc
    │   │   ├── haloadd_ps2x.fxc
    │   │   ├── haloaddoutline_ps2x.fxc
    │   │   ├── HDRCombineTo16Bit.cpp
    │   │   ├── HDRCombineTo16Bit_ps2x.fxc
    │   │   ├── HDRCombineTo16Bit_vs20.fxc
    │   │   ├── HDRSelectRange.cpp
    │   │   ├── HDRSelectRange_ps2x.fxc
    │   │   ├── HDRSelectRange_vs20.fxc
    │   │   ├── hsl_filmgrain_pass1.cpp
    │   │   ├── hsl_filmgrain_pass1_ps2x.fxc
    │   │   ├── hsl_filmgrain_pass2.cpp
    │   │   ├── hsl_filmgrain_pass2_ps2x.fxc
    │   │   ├── hsv.cpp
    │   │   ├── hsv_ps2x.fxc
    │   │   ├── introscreenspaceeffect.cpp
    │   │   ├── introscreenspaceeffect_dx60.cpp
    │   │   ├── introscreenspaceeffect_dx80.cpp
    │   │   ├── IntroScreenSpaceEffect_ps11.fxc
    │   │   ├── IntroScreenSpaceEffect_ps11_asm.psh
    │   │   ├── IntroScreenSpaceEffect_ps2x.fxc
    │   │   ├── jellyfish.cpp
    │   │   ├── JellyFish.psh
    │   │   ├── JellyFish.vsh
    │   │   ├── LightingOnly.vsh
    │   │   ├── lightingonly_vs20.fxc
    │   │   ├── lightmappedenvmappedbumpmappedtexture.psh
    │   │   ├── LightmappedGeneric.psh
    │   │   ├── LightmappedGeneric_AddBaseAlphaMaskedEnvMap.psh
    │   │   ├── LightmappedGeneric_AddEnvMapMaskNoTexture.psh
    │   │   ├── LightmappedGeneric_AddEnvMapNoTexture.psh
    │   │   ├── lightmappedgeneric_basealphamaskedenvmap.psh
    │   │   ├── LightmappedGeneric_BaseAlphaMaskedEnvMapV2.psh
    │   │   ├── LightmappedGeneric_BaseTexture.psh
    │   │   ├── LightmappedGeneric_BaseTexture.vsh
    │   │   ├── lightmappedgeneric_basetextureblend.psh
    │   │   ├── LightmappedGeneric_BaseTextureBlend.vsh
    │   │   ├── LightmappedGeneric_BumpmappedEnvmap.psh
    │   │   ├── LightmappedGeneric_BumpmappedEnvmap.vsh
    │   │   ├── LightmappedGeneric_BumpmappedEnvmap_ps14.psh
    │   │   ├── LightmappedGeneric_BumpmappedEnvmap_ps14.vsh
    │   │   ├── LightmappedGeneric_BumpmappedLightmap.psh
    │   │   ├── LightmappedGeneric_BumpmappedLightmap.vsh
    │   │   ├── LightmappedGeneric_BumpmappedLightmap_base_ps14.psh
    │   │   ├── LightmappedGeneric_BumpmappedLightmap_base_ps14.vsh
    │   │   ├── LightmappedGeneric_BumpmappedLightmap_blend_ps14.psh
    │   │   ├── LightmappedGeneric_BumpmappedLightmap_blend_ps14.vsh
    │   │   ├── lightmappedgeneric_decal.cpp
    │   │   ├── LightmappedGeneric_Decal.psh
    │   │   ├── LightmappedGeneric_Decal.vsh
    │   │   ├── lightmappedgeneric_decal_ps2x.fxc
    │   │   ├── lightmappedgeneric_decal_vs20.fxc
    │   │   ├── LightmappedGeneric_Detail.psh
    │   │   ├── LightmappedGeneric_DetailNoTexture.psh
    │   │   ├── LightmappedGeneric_DetailSelfIlluminated.psh
    │   │   ├── lightmappedgeneric_dx6.cpp
    │   │   ├── lightmappedgeneric_dx8.cpp
    │   │   ├── lightmappedgeneric_dx9.cpp
    │   │   ├── lightmappedgeneric_dx9_helper.cpp
    │   │   ├── lightmappedgeneric_dx9_helper.h
    │   │   ├── lightmappedgeneric_envmap.psh
    │   │   ├── LightmappedGeneric_EnvMapNoTexture.psh
    │   │   ├── LightmappedGeneric_EnvMapV2.psh
    │   │   ├── lightmappedgeneric_flashlight_vs11.fxc
    │   │   ├── lightmappedgeneric_flashlight_vs20.fxc
    │   │   ├── lightmappedgeneric_inc.vsh
    │   │   ├── LightmappedGeneric_LightingOnly.vsh
    │   │   ├── LightmappedGeneric_LightingOnly_Overbright2.psh
    │   │   ├── lightmappedgeneric_lightingonly_overbright2_ps11.fxc
    │   │   ├── lightmappedgeneric_lightingonly_vs11.fxc
    │   │   ├── lightmappedgeneric_maskedenvmap.psh
    │   │   ├── LightmappedGeneric_MaskedEnvMapNoTexture.psh
    │   │   ├── LightmappedGeneric_MaskedEnvMapV2.psh
    │   │   ├── LightmappedGeneric_MultiplyByLighting.psh
    │   │   ├── lightmappedgeneric_multiplybylightingbasealphamaskedselfillum.psh
    │   │   ├── lightmappedgeneric_multiplybylightingbasenotexture.psh
    │   │   ├── LightmappedGeneric_MultiplyByLightingNoTexture.psh
    │   │   ├── LightmappedGeneric_MultiplyByLightingSelfIllum.psh
    │   │   ├── LightmappedGeneric_NoTexture.psh
    │   │   ├── lightmappedgeneric_ps11.fxc
    │   │   ├── lightmappedgeneric_ps2_3_x.h
    │   │   ├── lightmappedgeneric_ps2x.fxc
    │   │   ├── LightmappedGeneric_SelfIlluminated.psh
    │   │   ├── lightmappedgeneric_selfilluminatedenvmap.psh
    │   │   ├── LightmappedGeneric_SelfIlluminatedEnvMapV2.psh
    │   │   ├── lightmappedgeneric_selfilluminatedmaskedenvmap.psh
    │   │   ├── LightmappedGeneric_SelfIlluminatedMaskedEnvMapV2.psh
    │   │   ├── LightmappedGeneric_SSBumpmappedLightmap.psh
    │   │   ├── LightmappedGeneric_VertexColor.vsh
    │   │   ├── lightmappedgeneric_vs11.vsh
    │   │   ├── lightmappedgeneric_vs20.fxc
    │   │   ├── lightmappedreflective.cpp
    │   │   ├── lightmappedreflective_ps2x.fxc
    │   │   ├── lightmappedreflective_vs20.fxc
    │   │   ├── lightmappedtexture.psh
    │   │   ├── LightmappedTranslucentTexture.psh
    │   │   ├── LightmappedTranslucentTexture.vsh
    │   │   ├── lightmappedtwotexture.cpp
    │   │   ├── lpreview1_ps2x.fxc
    │   │   ├── lpreview_output_ps2x.fxc
    │   │   ├── luminance_compare_ps2x.fxc
    │   │   ├── macros.vsh
    │   │   ├── modeldiffusebump.psh
    │   │   ├── modeldiffusebump2.psh
    │   │   ├── modelenvmappedbumpmapv2.psh
    │   │   ├── modelenvmappedbumpmapv2_multbyalpha.psh
    │   │   ├── modulate_dx6.cpp
    │   │   ├── modulate_dx8.cpp
    │   │   ├── modulate_dx9.cpp
    │   │   ├── Modulate_ps11.psh
    │   │   ├── modulate_ps2x.fxc
    │   │   ├── modulate_vs11.vsh
    │   │   ├── MonitorScreen.psh
    │   │   ├── MonitorScreen_dx8.cpp
    │   │   ├── MonitorScreen_dx9.cpp
    │   │   ├── monitorscreen_ps2x.fxc
    │   │   ├── morphaccumulate_dx9.cpp
    │   │   ├── morphaccumulate_ps30.fxc
    │   │   ├── morphaccumulate_vs30.fxc
    │   │   ├── morphweight_dx9.cpp
    │   │   ├── morphweight_ps30.fxc
    │   │   ├── morphweight_vs30.fxc
    │   │   ├── motion_blur_dx9.cpp
    │   │   ├── motion_blur_ps2x.fxc
    │   │   ├── motion_blur_vs20.fxc
    │   │   ├── occlusion_dx8.cpp
    │   │   ├── occlusion_dx9.cpp
    │   │   ├── overlay_fit.cpp
    │   │   ├── overlay_fit_ps11.psh
    │   │   ├── overlay_fit_vs11.vsh
    │   │   ├── particlelitgeneric_dx9.cpp
    │   │   ├── particlelitgeneric_dx9_helper.cpp
    │   │   ├── particlelitgeneric_dx9_helper.h
    │   │   ├── particlesphere.psh
    │   │   ├── ParticleSphere.vsh
    │   │   ├── particlesphere_dx8.cpp
    │   │   ├── particlesphere_dx9.cpp
    │   │   ├── particlesphere_ps11.fxc
    │   │   ├── particlesphere_ps2x.fxc
    │   │   ├── particlesphere_vs11.fxc
    │   │   ├── particlesphere_vs20.fxc
    │   │   ├── pbr_common_ps2_3_x.h
    │   │   ├── pbr_dx9.cpp
    │   │   ├── pbr_ps20b.fxc
    │   │   ├── pbr_ps30.fxc
    │   │   ├── pbr_vs20b.fxc
    │   │   ├── pbr_vs30.fxc
    │   │   ├── portal.cpp
    │   │   ├── portal_dx60.cpp
    │   │   ├── portal_dx80.cpp
    │   │   ├── portal_ps11.fxc
    │   │   ├── portal_ps2x.fxc
    │   │   ├── portal_refract.cpp
    │   │   ├── portal_refract_dx8.cpp
    │   │   ├── portal_refract_dx8_helper.cpp
    │   │   ├── portal_refract_dx8_helper.h
    │   │   ├── portal_refract_helper.cpp
    │   │   ├── portal_refract_helper.h
    │   │   ├── portal_refract_ps11.fxc
    │   │   ├── portal_refract_ps2x.fxc
    │   │   ├── portal_refract_vs11.fxc
    │   │   ├── portal_refract_vs20.fxc
    │   │   ├── portal_vs11.fxc
    │   │   ├── portal_vs20.fxc
    │   │   ├── portalstaticoverlay.cpp
    │   │   ├── portalstaticoverlay_dx60.cpp
    │   │   ├── portalstaticoverlay_dx80.cpp
    │   │   ├── portalstaticoverlay_ps11.fxc
    │   │   ├── portalstaticoverlay_ps2x.fxc
    │   │   ├── portalstaticoverlay_vs11.fxc
    │   │   ├── portalstaticoverlay_vs20.fxc
    │   │   ├── predator.cpp
    │   │   ├── predator.psh
    │   │   ├── predator.vsh
    │   │   ├── predator_envmap.psh
    │   │   ├── pyro_vision.cpp
    │   │   ├── pyro_vision_ps2x.fxc
    │   │   ├── pyro_vision_vs20.fxc
    │   │   ├── refract.cpp
    │   │   ├── refract_dx60.cpp
    │   │   ├── refract_dx80.cpp
    │   │   ├── refract_dx9_helper.cpp
    │   │   ├── refract_dx9_helper.h
    │   │   ├── Refract_model_vs11.vsh
    │   │   ├── Refract_ps11.psh
    │   │   ├── refract_ps2x.fxc
    │   │   ├── Refract_vs20.fxc
    │   │   ├── Refract_world_vs11.vsh
    │   │   ├── rendertargetblit_ps2x.fxc
    │   │   ├── rendertargetblit_vs20.fxc
    │   │   ├── rendertargetblit_x360.cpp
    │   │   ├── rift_dx6.cpp
    │   │   ├── rift_dx8.cpp
    │   │   ├── rift_ps11.psh
    │   │   ├── rift_vs11.vsh
    │   │   ├── sample4x4.cpp
    │   │   ├── sample4x4_blend.cpp
    │   │   ├── sample4x4_blend_ps2x.fxc
    │   │   ├── sample4x4_ps2x.fxc
    │   │   ├── sample4x4delog_ps2x.fxc
    │   │   ├── sample4x4log_ps2x.fxc
    │   │   ├── sample4x4maxmin_ps2x.fxc
    │   │   ├── screenspace_general.cpp
    │   │   ├── screenspace_general_dx8.cpp
    │   │   ├── ScreenSpaceEffect.vsh
    │   │   ├── screenspaceeffect_vs11.fxc
    │   │   ├── screenspaceeffect_vs20.fxc
    │   │   ├── SetZ.cpp
    │   │   ├── sfm_blurfilterx.cpp
    │   │   ├── sfm_blurfiltery.cpp
    │   │   ├── sfm_combine_vs20.fxc
    │   │   ├── sfm_downsample.cpp
    │   │   ├── sfm_integercombine.cpp
    │   │   ├── sfm_integercombine_ps2x.fxc
    │   │   ├── shader_constant_register_map.h
    │   │   ├── shadow.cpp
    │   │   ├── Shadow.psh
    │   │   ├── shadow_dx6.cpp
    │   │   ├── shadow_dx8.cpp
    │   │   ├── shadow_ps14.psh
    │   │   ├── shadow_ps2x.fxc
    │   │   ├── shadow_vs14.vsh
    │   │   ├── shadow_vs20.fxc
    │   │   ├── shadowbuild_dx6.cpp
    │   │   ├── shadowbuild_dx8.cpp
    │   │   ├── shadowbuild_dx9.cpp
    │   │   ├── ShadowBuildTexture.psh
    │   │   ├── shadowbuildtexture_ps2x.fxc
    │   │   ├── ShadowModel.psh
    │   │   ├── ShadowModel.vsh
    │   │   ├── shadowmodel_dx8.cpp
    │   │   ├── shadowmodel_dx9.cpp
    │   │   ├── shadowmodel_ps20.fxc
    │   │   ├── shadowmodel_vs20.fxc
    │   │   ├── shatteredglass.cpp
    │   │   ├── ShatteredGlass.psh
    │   │   ├── ShatteredGlass.vsh
    │   │   ├── shatteredglass_dx7.cpp
    │   │   ├── shatteredglass_dx8.cpp
    │   │   ├── ShatteredGlass_EnvMap.psh
    │   │   ├── ShatteredGlass_EnvMap.vsh
    │   │   ├── ShatteredGlass_EnvMapSphere.vsh
    │   │   ├── ShatteredGlass_inc.vsh
    │   │   ├── ShatteredGlass_ps2x.fxc
    │   │   ├── ShatteredGlass_vs20.fxc
    │   │   ├── showz.cpp
    │   │   ├── showz_ps2x.fxc
    │   │   ├── showz_vs20.fxc
    │   │   ├── skin_dx9_helper.cpp
    │   │   ├── skin_dx9_helper.h
    │   │   ├── skin_ps20b.fxc
    │   │   ├── skin_vs20.fxc
    │   │   ├── sky_dx6.cpp
    │   │   ├── sky_dx9.cpp
    │   │   ├── sky_hdr_compressed_ps2x.fxc
    │   │   ├── sky_hdr_compressed_rgbs_ps2x.fxc
    │   │   ├── sky_hdr_dx9.cpp
    │   │   ├── sky_ps2x.fxc
    │   │   ├── sky_vs20.fxc
    │   │   ├── splinecard_vsxx.fxc
    │   │   ├── sprite.cpp
    │   │   ├── sprite_dx6.cpp
    │   │   ├── sprite_dx9.cpp
    │   │   ├── sprite_ps11.psh
    │   │   ├── sprite_ps2x.fxc
    │   │   ├── sprite_vs11.vsh
    │   │   ├── sprite_vs20.fxc
    │   │   ├── spritecard.cpp
    │   │   ├── spritecard_ps11.fxc
    │   │   ├── spritecard_ps2x.fxc
    │   │   ├── spritecard_vsxx.fxc
    │   │   ├── SpriteRenderNormal.psh
    │   │   ├── SpriteRenderTransAdd.psh
    │   │   ├── SpriteRenderTransColor.psh
    │   │   ├── stdshader_dbg.vpc
    │   │   ├── stdshader_dx10.txt
    │   │   ├── stdshader_dx6.vpc
    │   │   ├── stdshader_dx7.vpc
    │   │   ├── stdshader_dx8.vpc
    │   │   ├── stdshader_dx9.vpc
    │   │   ├── stdshader_dx9_20b.txt
    │   │   ├── stdshader_dx9_20b_new.txt
    │   │   ├── stdshader_dx9_30.txt
    │   │   ├── teeth.cpp
    │   │   ├── Teeth.vsh
    │   │   ├── teeth_bump_ps2x.fxc
    │   │   ├── teeth_bump_vs20.fxc
    │   │   ├── teeth_dx6.cpp
    │   │   ├── teeth_dx8.cpp
    │   │   ├── teeth_flashlight_ps2x.fxc
    │   │   ├── teeth_flashlight_vs20.fxc
    │   │   ├── teeth_ps2x.fxc
    │   │   ├── teeth_vs20.fxc
    │   │   ├── TreeLeaf.cpp
    │   │   ├── TreeLeaf_ps2x.fxc
    │   │   ├── TreeLeaf_vs20.fxc
    │   │   ├── UnlitGeneric.psh
    │   │   ├── UnlitGeneric_BaseAlphaMaskedEnvMap.psh
    │   │   ├── unlitgeneric_basetimesdetail.psh
    │   │   ├── UnlitGeneric_Detail.psh
    │   │   ├── UnlitGeneric_DetailBaseAlphaMaskedEnvMap.psh
    │   │   ├── UnlitGeneric_DetailEnvMap.psh
    │   │   ├── UnlitGeneric_DetailEnvMapMask.psh
    │   │   ├── UnlitGeneric_DetailEnvMapMaskNoTexture.psh
    │   │   ├── UnlitGeneric_DetailEnvMapNoTexture.psh
    │   │   ├── UnlitGeneric_DetailNoTexture.psh
    │   │   ├── unlitgeneric_dx6.cpp
    │   │   ├── unlitgeneric_dx8.cpp
    │   │   ├── unlitgeneric_dx9.cpp
    │   │   ├── UnlitGeneric_EnvMap.psh
    │   │   ├── UnlitGeneric_EnvMapMask.psh
    │   │   ├── UnlitGeneric_EnvMapMaskNoTexture.psh
    │   │   ├── UnlitGeneric_EnvMapNoTexture.psh
    │   │   ├── unlitgeneric_inc.vsh
    │   │   ├── UnlitGeneric_LightingOnly.vsh
    │   │   ├── unlitgeneric_lightingonly_vs11.fxc
    │   │   ├── UnlitGeneric_MaskBaseByDetailAlpha_ps11.fxc
    │   │   ├── UnlitGeneric_NoTexture.psh
    │   │   ├── unlitgeneric_notexture_ps11.fxc
    │   │   ├── unlitgeneric_notexture_ps2x.fxc
    │   │   ├── unlitgeneric_ps11.fxc
    │   │   ├── unlitgeneric_ps2x.fxc
    │   │   ├── unlitgeneric_vs11.vsh
    │   │   ├── unlitgeneric_vs20.fxc
    │   │   ├── UnlitTwoTexture.psh
    │   │   ├── UnlitTwoTexture.vsh
    │   │   ├── unlittwotexture_dx6.cpp
    │   │   ├── unlittwotexture_dx8.cpp
    │   │   ├── unlittwotexture_dx9.cpp
    │   │   ├── unlittwotexture_inc.vsh
    │   │   ├── unlittwotexture_ps2x.fxc
    │   │   ├── unlittwotexture_vs20.fxc
    │   │   ├── vertexlit_and_unlit_generic_bump_ps2x.fxc
    │   │   ├── vertexlit_and_unlit_generic_bump_vs20.fxc
    │   │   ├── vertexlit_and_unlit_generic_ps2x.fxc
    │   │   ├── vertexlit_and_unlit_generic_vs20.fxc
    │   │   ├── vertexlit_lighting_only_ps2x.fxc
    │   │   ├── vertexlit_notexture.psh
    │   │   ├── VertexLitGeneric.psh
    │   │   ├── vertexlitgeneric_basealphamaskedenvmap.psh
    │   │   ├── VertexLitGeneric_BaseAlphaMaskedEnvMapV2.psh
    │   │   ├── VertexLitGeneric_BlendTint.psh
    │   │   ├── VertexLitGeneric_Detail.psh
    │   │   ├── VertexLitGeneric_Detail_additive.psh
    │   │   ├── VertexLitGeneric_Detail_additive_selfillum.psh
    │   │   ├── VertexLitGeneric_Detail_LerpBase.psh
    │   │   ├── vertexlitgeneric_detailbasealphamaskedenvmap.psh
    │   │   ├── VertexLitGeneric_DetailBaseAlphaMaskedEnvMapV2.psh
    │   │   ├── vertexlitgeneric_detailenvmap.psh
    │   │   ├── VertexLitGeneric_DetailEnvMapV2.psh
    │   │   ├── vertexlitgeneric_detailmaskedenvmap.psh
    │   │   ├── VertexLitGeneric_DetailMaskedEnvMapV2.psh
    │   │   ├── VertexLitGeneric_DetailNoTexture.psh
    │   │   ├── VertexLitGeneric_DetailSelfIlluminated.psh
    │   │   ├── vertexlitgeneric_detailselfilluminatedenvmap.psh
    │   │   ├── VertexLitGeneric_DetailSelfIlluminatedEnvMapV2.psh
    │   │   ├── vertexlitgeneric_detailselfilluminatedmaskedenvmap.psh
    │   │   ├── VertexLitGeneric_DetailSelfIlluminatedMaskedEnvMapV2.psh
    │   │   ├── vertexlitgeneric_dx6.cpp
    │   │   ├── vertexlitgeneric_dx7.cpp
    │   │   ├── vertexlitgeneric_dx8.cpp
    │   │   ├── vertexlitgeneric_dx9.cpp
    │   │   ├── vertexlitgeneric_dx95_helper.h
    │   │   ├── vertexlitgeneric_dx9_helper.cpp
    │   │   ├── vertexlitgeneric_dx9_helper.h
    │   │   ├── vertexlitgeneric_envmap.psh
    │   │   ├── VertexLitGeneric_EnvMapNoTexture.psh
    │   │   ├── VertexLitGeneric_EnvmappedBumpmap_NoLighting.vsh
    │   │   ├── VertexLitGeneric_EnvmappedBumpmap_NoLighting_ps14.vsh
    │   │   ├── VertexLitGeneric_EnvmappedBumpmapV2.psh
    │   │   ├── VertexLitGeneric_EnvmappedBumpmapV2_MultByAlpha.psh
    │   │   ├── VertexLitGeneric_EnvmappedBumpmapV2_MultByAlpha_ps14.psh
    │   │   ├── VertexLitGeneric_EnvmappedBumpmapV2_ps14.psh
    │   │   ├── VertexLitGeneric_EnvMapV2.psh
    │   │   ├── vertexlitgeneric_flashlight_vs11.vsh
    │   │   ├── vertexlitgeneric_inc.vsh
    │   │   ├── vertexlitgeneric_lightingonly_overbright2.psh
    │   │   ├── vertexlitgeneric_lightingonly_overbright2_ps11.fxc
    │   │   ├── vertexlitgeneric_maskedenvmap.psh
    │   │   ├── VertexLitGeneric_MaskedEnvMapNoTexture.psh
    │   │   ├── VertexLitGeneric_MaskedEnvMapV2.psh
    │   │   ├── VertexLitGeneric_NoTexture.psh
    │   │   ├── VertexLitGeneric_SelfIlluminated.psh
    │   │   ├── vertexlitgeneric_selfilluminatedenvmap.psh
    │   │   ├── VertexLitGeneric_SelfIlluminatedEnvMapV2.psh
    │   │   ├── vertexlitgeneric_selfilluminatedmaskedenvmap.psh
    │   │   ├── VertexLitGeneric_SelfIlluminatedMaskedEnvMapV2.psh
    │   │   ├── VertexLitGeneric_SelfIllumOnly.psh
    │   │   ├── VertexLitGeneric_SelfIllumOnly.vsh
    │   │   ├── vertexlitgeneric_vs11.vsh
    │   │   ├── VertexLitTexture.psh
    │   │   ├── VertexLitTexture_Overbright2.psh
    │   │   ├── VertexTextureTest.cpp
    │   │   ├── viewalpha.cpp
    │   │   ├── volume_clouds.cpp
    │   │   ├── volume_clouds_helper.cpp
    │   │   ├── volume_clouds_helper.h
    │   │   ├── volume_clouds_ps2x.fxc
    │   │   ├── volume_clouds_vs20.fxc
    │   │   ├── volumetricfog.cpp
    │   │   ├── vortwarp_dx7.cpp
    │   │   ├── vortwarp_dx8.cpp
    │   │   ├── vortwarp_dx9.cpp
    │   │   ├── vortwarp_ps11.psh
    │   │   ├── vortwarp_ps2x.fxc
    │   │   ├── vortwarp_vs11.vsh
    │   │   ├── vortwarp_vs20.fxc
    │   │   ├── vortwarp_vs20_helper.h
    │   │   ├── vr_distort_hud.cpp
    │   │   ├── vr_distort_hud_ps2x.fxc
    │   │   ├── vr_distort_hud_vs20.fxc
    │   │   ├── vr_distort_texture.cpp
    │   │   ├── vr_distort_texture_ps2x.fxc
    │   │   ├── vr_distort_texture_vs20.fxc
    │   │   ├── warp.cpp
    │   │   ├── warp_ps2x.fxc
    │   │   ├── warp_vs20.fxc
    │   │   ├── water.cpp
    │   │   ├── water_dudv.cpp
    │   │   ├── water_dx60.cpp
    │   │   ├── water_dx80.cpp
    │   │   ├── water_dx81.cpp
    │   │   ├── Water_ps14.psh
    │   │   ├── Water_ps14.vsh
    │   │   ├── water_ps2x.fxc
    │   │   ├── water_ps2x_helper.h
    │   │   ├── Water_vs11.vsh
    │   │   ├── Water_vs20.fxc
    │   │   ├── WaterCheap_ps11.psh
    │   │   ├── WaterCheap_ps14.psh
    │   │   ├── WaterCheap_ps2x.fxc
    │   │   ├── WaterCheap_vs11.vsh
    │   │   ├── WaterCheap_vs14.vsh
    │   │   ├── WaterCheap_vs20.fxc
    │   │   ├── WaterCheapFresnel_ps14.psh
    │   │   ├── WaterCheapFresnelOpaque_ps14.psh
    │   │   ├── WaterCheapNoFresnel_ps11.psh
    │   │   ├── WaterCheapNoFresnelOpaque_ps11.psh
    │   │   ├── WaterCheapOpaque_ps11.psh
    │   │   ├── WaterCheapOpaque_ps14.psh
    │   │   ├── WaterCheapPerVertexFresnel_vs11.vsh
    │   │   ├── WaterReflect_ps11.psh
    │   │   ├── waterreflect_ps14.psh
    │   │   ├── WaterRefract_ps11.psh
    │   │   ├── waterrefract_ps14.psh
    │   │   ├── WaterRefractFresnel_ps11.psh
    │   │   ├── weapon_sheen_pass_helper.cpp
    │   │   ├── weapon_sheen_pass_helper.h
    │   │   ├── weapon_sheen_pass_ps2x.fxc
    │   │   ├── weapon_sheen_pass_vs20.fxc
    │   │   ├── white.psh
    │   │   ├── white_ps2x.fxc
    │   │   ├── windowimposter_dx80.cpp
    │   │   ├── windowimposter_dx90.cpp
    │   │   ├── windowimposter_ps11.fxc
    │   │   ├── windowimposter_ps2x.fxc
    │   │   ├── windowimposter_vs11.fxc
    │   │   ├── windowimposter_vs20.fxc
    │   │   ├── wireframe_dx8.cpp
    │   │   ├── wireframe_dx9.cpp
    │   │   ├── WorldTexture.psh
    │   │   ├── worldtwotextureblend.cpp
    │   │   ├── WorldTwoTextureBlend.psh
    │   │   ├── WorldTwoTextureBlend_DetailAlpha.psh
    │   │   ├── worldtwotextureblend_dx6.cpp
    │   │   ├── worldtwotextureblend_dx8.cpp
    │   │   ├── worldtwotextureblend_ps2x.fxc
    │   │   ├── WorldTwoTextureBlend_SelfIlluminated.psh
    │   │   ├── worldvertexalpha.cpp
    │   │   ├── WorldVertexAlpha.psh
    │   │   ├── WorldVertexAlpha.vsh
    │   │   ├── worldvertexalpha_dx8.cpp
    │   │   ├── WorldVertexAlpha_ps2x.fxc
    │   │   ├── worldvertextransition.cpp
    │   │   ├── WorldVertexTransition.psh
    │   │   ├── WorldVertexTransition.vsh
    │   │   ├── WorldVertexTransition_BlendBase2.psh
    │   │   ├── worldvertextransition_dx6.cpp
    │   │   ├── worldvertextransition_dx6_helper.cpp
    │   │   ├── worldvertextransition_dx6_helper.h
    │   │   ├── WorldVertexTransition_dx8.cpp
    │   │   ├── worldvertextransition_dx8_helper.cpp
    │   │   ├── worldvertextransition_dx8_helper.h
    │   │   ├── WorldVertexTransition_Editor.psh
    │   │   ├── WorldVertexTransition_ps14.psh
    │   │   ├── WorldVertexTransition_ps2x.fxc
    │   │   ├── WorldVertexTransition_Seamless.psh
    │   │   ├── WorldVertexTransition_Seamless.vsh
    │   │   ├── WorldVertexTransition_vs14.vsh
    │   │   ├── WorldVertexTransition_vs20.fxc
    │   │   ├── writestencil_dx8.cpp
    │   │   ├── writestencil_dx9.cpp
    │   │   ├── writevertexalphatodestalpha_ps11.fxc
    │   │   ├── writevertexalphatodestalpha_vs11.fxc
    │   │   ├── writez.vsh
    │   │   ├── writez_dx6.cpp
    │   │   ├── writez_dx8.cpp
    │   │   ├── writez_dx9.cpp
    │   │   ├── writez_vs20.fxc
    │   │   ├── wscript
    │   │   ├── yuv.cpp
    │   │   ├── yuv.psh
    │   │   ├── fxctmp9/
    │   │   │   ├── accumbuff4sample_ps20.inc
    │   │   │   ├── accumbuff4sample_ps20b.inc
    │   │   │   ├── accumbuff5sample_ps20.inc
    │   │   │   ├── accumbuff5sample_ps20b.inc
    │   │   │   ├── aftershock_ps20.inc
    │   │   │   ├── aftershock_ps20b.inc
    │   │   │   ├── aftershock_vs20.inc
    │   │   │   ├── alphadist_ps11.inc
    │   │   │   ├── appchooser360movie_ps20.inc
    │   │   │   ├── appchooser360movie_ps20b.inc
    │   │   │   ├── bik_ps20.inc
    │   │   │   ├── bik_ps20b.inc
    │   │   │   ├── bik_vs20.inc
    │   │   │   ├── Bloom_ps20.inc
    │   │   │   ├── Bloom_ps20b.inc
    │   │   │   ├── bloomadd_ps11.inc
    │   │   │   ├── bloomadd_ps20.inc
    │   │   │   ├── bloomadd_ps20b.inc
    │   │   │   ├── BlurFilter_ps20.inc
    │   │   │   ├── BlurFilter_ps20b.inc
    │   │   │   ├── BlurFilter_vs11.inc
    │   │   │   ├── BlurFilter_vs20.inc
    │   │   │   ├── bufferclearobeystencil_ps20.inc
    │   │   │   ├── bufferclearobeystencil_ps20b.inc
    │   │   │   ├── bufferclearobeystencil_vs20.inc
    │   │   │   ├── bumpmappedlightmap_vs11.inc
    │   │   │   ├── cable_ps20.inc
    │   │   │   ├── cable_ps20b.inc
    │   │   │   ├── cable_vs20.inc
    │   │   │   ├── cloak_blended_pass_ps20.inc
    │   │   │   ├── cloak_blended_pass_ps20b.inc
    │   │   │   ├── cloak_blended_pass_ps30.inc
    │   │   │   ├── cloak_blended_pass_vs20.inc
    │   │   │   ├── cloak_blended_pass_vs30.inc
    │   │   │   ├── cloak_ps20.inc
    │   │   │   ├── cloak_ps20b.inc
    │   │   │   ├── cloak_ps30.inc
    │   │   │   ├── cloak_vs20.inc
    │   │   │   ├── cloak_vs30.inc
    │   │   │   ├── cloud_ps20.inc
    │   │   │   ├── cloud_vs20.inc
    │   │   │   ├── color_projection_ps20.inc
    │   │   │   ├── color_projection_ps20b.inc
    │   │   │   ├── color_projection_vs20.inc
    │   │   │   ├── colorcorrection_ps20.inc
    │   │   │   ├── colorcorrection_ps20b.inc
    │   │   │   ├── compositor_ps20.inc
    │   │   │   ├── compositor_ps20b.inc
    │   │   │   ├── compositor_vs20.inc
    │   │   │   ├── constant_color_ps20.inc
    │   │   │   ├── constant_color_ps20b.inc
    │   │   │   ├── copy_fp_rt_ps20.inc
    │   │   │   ├── copy_fp_rt_ps20b.inc
    │   │   │   ├── core_ps20.inc
    │   │   │   ├── core_ps20b.inc
    │   │   │   ├── core_vs11.inc
    │   │   │   ├── core_vs20.inc
    │   │   │   ├── debugbumpmappedlightmap_ps11.inc
    │   │   │   ├── debugbumpmappedlightmap_ps20.inc
    │   │   │   ├── debugbumpmappedlightmap_ps20b.inc
    │   │   │   ├── debugdrawdepth_ps20.inc
    │   │   │   ├── debugdrawdepth_ps20b.inc
    │   │   │   ├── debugdrawdepth_vs20.inc
    │   │   │   ├── debugdrawenvmapmask_ps20.inc
    │   │   │   ├── debugdrawenvmapmask_ps20b.inc
    │   │   │   ├── debugdrawenvmapmask_vs20.inc
    │   │   │   ├── debugluxel_ps20.inc
    │   │   │   ├── debugluxel_ps20b.inc
    │   │   │   ├── debugluxel_vs20.inc
    │   │   │   ├── debugmorphaccumulator_ps30.inc
    │   │   │   ├── debugmorphaccumulator_vs30.inc
    │   │   │   ├── debugmrttexture_ps20.inc
    │   │   │   ├── debugmrttexture_ps20b.inc
    │   │   │   ├── debugmrttexture_vs20.inc
    │   │   │   ├── debugtangentspace_vs11.inc
    │   │   │   ├── debugtangentspace_vs20.inc
    │   │   │   ├── debugtextureview_ps20.inc
    │   │   │   ├── debugtextureview_ps20b.inc
    │   │   │   ├── debugtextureview_vs20.inc
    │   │   │   ├── decalbasetimeslightmapalphablendselfillum2_ps20.inc
    │   │   │   ├── decalbasetimeslightmapalphablendselfillum2_ps20b.inc
    │   │   │   ├── decalmodulate_ps20.inc
    │   │   │   ├── decalmodulate_ps20b.inc
    │   │   │   ├── decalmodulate_ps30.inc
    │   │   │   ├── depthtodestalpha_ps20b.inc
    │   │   │   ├── depthtodestalpha_vs20.inc
    │   │   │   ├── depthwrite_ps20.inc
    │   │   │   ├── depthwrite_ps20b.inc
    │   │   │   ├── depthwrite_ps30.inc
    │   │   │   ├── depthwrite_vs20.inc
    │   │   │   ├── depthwrite_vs30.inc
    │   │   │   ├── Downsample_nohdr_ps20.inc
    │   │   │   ├── Downsample_nohdr_ps20b.inc
    │   │   │   ├── Downsample_ps20.inc
    │   │   │   ├── Downsample_ps20b.inc
    │   │   │   ├── Downsample_vs11.inc
    │   │   │   ├── Downsample_vs20.inc
    │   │   │   ├── emissive_scroll_blended_pass_ps20.inc
    │   │   │   ├── emissive_scroll_blended_pass_ps20b.inc
    │   │   │   ├── emissive_scroll_blended_pass_ps30.inc
    │   │   │   ├── emissive_scroll_blended_pass_vs20.inc
    │   │   │   ├── emissive_scroll_blended_pass_vs30.inc
    │   │   │   ├── engine_post_ps20.inc
    │   │   │   ├── engine_post_ps20b.inc
    │   │   │   ├── example_model_ps20b.inc
    │   │   │   ├── example_model_vs20.inc
    │   │   │   ├── eye_refract_ps20.inc
    │   │   │   ├── eye_refract_ps20b.inc
    │   │   │   ├── eye_refract_ps30.inc
    │   │   │   ├── eye_refract_vs20.inc
    │   │   │   ├── eye_refract_vs30.inc
    │   │   │   ├── eyeglint_ps20.inc
    │   │   │   ├── eyeglint_ps20b.inc
    │   │   │   ├── eyeglint_vs20.inc
    │   │   │   ├── eyes_cloak_ps20b.inc
    │   │   │   ├── eyes_cloak_vs20b.inc
    │   │   │   ├── eyes_flashlight_ps11.inc
    │   │   │   ├── eyes_flashlight_ps20.inc
    │   │   │   ├── eyes_flashlight_ps20b.inc
    │   │   │   ├── eyes_flashlight_ps30.inc
    │   │   │   ├── eyes_flashlight_vs20.inc
    │   │   │   ├── eyes_flashlight_vs30.inc
    │   │   │   ├── eyes_ps20.inc
    │   │   │   ├── eyes_ps20b.inc
    │   │   │   ├── eyes_ps30.inc
    │   │   │   ├── eyes_vs20.inc
    │   │   │   ├── eyes_vs30.inc
    │   │   │   ├── fillrate_ps11.inc
    │   │   │   ├── fillrate_ps20.inc
    │   │   │   ├── fillrate_ps20b.inc
    │   │   │   ├── fillrate_vs11.inc
    │   │   │   ├── fillrate_vs20.inc
    │   │   │   ├── filmdust_ps11.inc
    │   │   │   ├── filmdust_ps20.inc
    │   │   │   ├── filmgrain_ps11.inc
    │   │   │   ├── filmgrain_ps20.inc
    │   │   │   ├── filmgrain_vs20.inc
    │   │   │   ├── flashlight_ps11.inc
    │   │   │   ├── flashlight_ps20.inc
    │   │   │   ├── flashlight_ps20b.inc
    │   │   │   ├── flesh_interior_blended_pass_ps20.inc
    │   │   │   ├── flesh_interior_blended_pass_ps20b.inc
    │   │   │   ├── flesh_interior_blended_pass_vs20.inc
    │   │   │   ├── floatcombine_autoexpose_ps20.inc
    │   │   │   ├── floatcombine_autoexpose_ps20b.inc
    │   │   │   ├── floatcombine_ps20.inc
    │   │   │   ├── floatcombine_ps20b.inc
    │   │   │   ├── floattoscreen_notonemap_ps20.inc
    │   │   │   ├── floattoscreen_notonemap_ps20b.inc
    │   │   │   ├── floattoscreen_ps20.inc
    │   │   │   ├── floattoscreen_ps20b.inc
    │   │   │   ├── floattoscreen_vanilla_ps20.inc
    │   │   │   ├── floattoscreen_vanilla_ps20b.inc
    │   │   │   ├── haloadd1d_ps20.inc
    │   │   │   ├── haloadd1d_ps20b.inc
    │   │   │   ├── haloadd_ps20.inc
    │   │   │   ├── haloadd_ps20b.inc
    │   │   │   ├── haloaddoutline_ps20.inc
    │   │   │   ├── haloaddoutline_ps20b.inc
    │   │   │   ├── HDRCombineTo16Bit_ps20.inc
    │   │   │   ├── HDRCombineTo16Bit_ps20b.inc
    │   │   │   ├── HDRCombineTo16Bit_vs20.inc
    │   │   │   ├── HDRSelectRange_ps20.inc
    │   │   │   ├── HDRSelectRange_ps20b.inc
    │   │   │   ├── HDRSelectRange_vs20.inc
    │   │   │   ├── hsl_filmgrain_pass1_ps20.inc
    │   │   │   ├── hsl_filmgrain_pass1_ps20b.inc
    │   │   │   ├── hsl_filmgrain_pass2_ps20.inc
    │   │   │   ├── hsl_filmgrain_pass2_ps20b.inc
    │   │   │   ├── hsv_ps20.inc
    │   │   │   ├── hsv_ps20b.inc
    │   │   │   ├── introscreenspaceeffect_ps11.inc
    │   │   │   ├── IntroScreenSpaceEffect_ps20.inc
    │   │   │   ├── IntroScreenSpaceEffect_ps20b.inc
    │   │   │   ├── lightingonly_vs20.inc
    │   │   │   ├── lightmappedgeneric_decal_ps20.inc
    │   │   │   ├── lightmappedgeneric_decal_ps20b.inc
    │   │   │   ├── lightmappedgeneric_decal_vs20.inc
    │   │   │   ├── lightmappedgeneric_flashlight_vs11.inc
    │   │   │   ├── lightmappedgeneric_flashlight_vs20.inc
    │   │   │   ├── lightmappedgeneric_lightingonly_overbright2_ps11.inc
    │   │   │   ├── lightmappedgeneric_lightingonly_vs11.inc
    │   │   │   ├── lightmappedgeneric_ps20.inc
    │   │   │   ├── lightmappedgeneric_ps20b.inc
    │   │   │   ├── lightmappedgeneric_vs20.inc
    │   │   │   ├── lightmappedreflective_ps20.inc
    │   │   │   ├── lightmappedreflective_ps20b.inc
    │   │   │   ├── lightmappedreflective_vs20.inc
    │   │   │   ├── lpreview1_ps20.inc
    │   │   │   ├── lpreview1_ps20b.inc
    │   │   │   ├── lpreview_output_ps20.inc
    │   │   │   ├── lpreview_output_ps20b.inc
    │   │   │   ├── luminance_compare_ps20.inc
    │   │   │   ├── luminance_compare_ps20b.inc
    │   │   │   ├── modulate_ps20.inc
    │   │   │   ├── modulate_ps20b.inc
    │   │   │   ├── monitorscreen_ps20.inc
    │   │   │   ├── monitorscreen_ps20b.inc
    │   │   │   ├── morphaccumulate_ps30.inc
    │   │   │   ├── morphaccumulate_vs30.inc
    │   │   │   ├── morphweight_ps30.inc
    │   │   │   ├── morphweight_vs30.inc
    │   │   │   ├── motion_blur_ps20.inc
    │   │   │   ├── motion_blur_ps20b.inc
    │   │   │   ├── motion_blur_vs20.inc
    │   │   │   ├── particlelit_generic_ps30.inc
    │   │   │   ├── particlelit_generic_vs30.inc
    │   │   │   ├── ParticleSphere_ps11.inc
    │   │   │   ├── particlesphere_ps20.inc
    │   │   │   ├── particlesphere_ps20b.inc
    │   │   │   ├── ParticleSphere_vs11.inc
    │   │   │   ├── particlesphere_vs20.inc
    │   │   │   ├── pbr_ps20b.inc
    │   │   │   ├── pbr_ps30.inc
    │   │   │   ├── pbr_vs20b.inc
    │   │   │   ├── pbr_vs30.inc
    │   │   │   ├── portal_ps11.inc
    │   │   │   ├── portal_ps20.inc
    │   │   │   ├── portal_ps20b.inc
    │   │   │   ├── portal_refract_ps11.inc
    │   │   │   ├── portal_refract_ps20.inc
    │   │   │   ├── portal_refract_ps20b.inc
    │   │   │   ├── portal_refract_vs11.inc
    │   │   │   ├── portal_refract_vs20.inc
    │   │   │   ├── portal_vs11.inc
    │   │   │   ├── portal_vs20.inc
    │   │   │   ├── portalstaticoverlay_ps11.inc
    │   │   │   ├── portalstaticoverlay_ps20.inc
    │   │   │   ├── portalstaticoverlay_ps20b.inc
    │   │   │   ├── portalstaticoverlay_vs11.inc
    │   │   │   ├── portalstaticoverlay_vs20.inc
    │   │   │   ├── pyro_vision_ps20.inc
    │   │   │   ├── pyro_vision_ps20b.inc
    │   │   │   ├── pyro_vision_ps30.inc
    │   │   │   ├── pyro_vision_vs20.inc
    │   │   │   ├── pyro_vision_vs30.inc
    │   │   │   ├── Refract_ps20.inc
    │   │   │   ├── Refract_ps20b.inc
    │   │   │   ├── Refract_vs20.inc
    │   │   │   ├── rendertargetblit_ps20.inc
    │   │   │   ├── rendertargetblit_ps20b.inc
    │   │   │   ├── rendertargetblit_vs20.inc
    │   │   │   ├── sample4x4_blend_ps20.inc
    │   │   │   ├── sample4x4_blend_ps20b.inc
    │   │   │   ├── sample4x4_ps20.inc
    │   │   │   ├── sample4x4_ps20b.inc
    │   │   │   ├── sample4x4delog_ps20.inc
    │   │   │   ├── sample4x4delog_ps20b.inc
    │   │   │   ├── sample4x4log_ps20.inc
    │   │   │   ├── sample4x4log_ps20b.inc
    │   │   │   ├── sample4x4maxmin_ps20.inc
    │   │   │   ├── sample4x4maxmin_ps20b.inc
    │   │   │   ├── screenspaceeffect_vs11.inc
    │   │   │   ├── screenspaceeffect_vs20.inc
    │   │   │   ├── sfm_combine_vs20.inc
    │   │   │   ├── sfm_integercombine_ps20.inc
    │   │   │   ├── sfm_integercombine_ps20b.inc
    │   │   │   ├── shadow_ps20.inc
    │   │   │   ├── shadow_ps20b.inc
    │   │   │   ├── shadow_vs20.inc
    │   │   │   ├── shadowbuildtexture_ps20.inc
    │   │   │   ├── shadowbuildtexture_ps20b.inc
    │   │   │   ├── shadowmodel_ps20.inc
    │   │   │   ├── shadowmodel_vs20.inc
    │   │   │   ├── ShatteredGlass_ps20.inc
    │   │   │   ├── ShatteredGlass_ps20b.inc
    │   │   │   ├── ShatteredGlass_vs20.inc
    │   │   │   ├── showz_ps20.inc
    │   │   │   ├── showz_ps20b.inc
    │   │   │   ├── showz_vs20.inc
    │   │   │   ├── skin_ps20.inc
    │   │   │   ├── skin_ps20b.inc
    │   │   │   ├── skin_ps30.inc
    │   │   │   ├── skin_ps30b.inc
    │   │   │   ├── skin_vs20.inc
    │   │   │   ├── skin_vs30.inc
    │   │   │   ├── sky_hdr_compressed_ps20.inc
    │   │   │   ├── sky_hdr_compressed_ps20b.inc
    │   │   │   ├── sky_hdr_compressed_rgbs_ps20.inc
    │   │   │   ├── sky_hdr_compressed_rgbs_ps20b.inc
    │   │   │   ├── sky_ps20.inc
    │   │   │   ├── sky_ps20b.inc
    │   │   │   ├── sky_vs20.inc
    │   │   │   ├── splinecard_vs11.inc
    │   │   │   ├── splinecard_vs20.inc
    │   │   │   ├── sprite_ps20.inc
    │   │   │   ├── sprite_ps20b.inc
    │   │   │   ├── sprite_vs20.inc
    │   │   │   ├── spritecard_ps11.inc
    │   │   │   ├── spritecard_ps20.inc
    │   │   │   ├── spritecard_ps20b.inc
    │   │   │   ├── spritecard_vs11.inc
    │   │   │   ├── spritecard_vs20.inc
    │   │   │   ├── teeth_bump_ps20.inc
    │   │   │   ├── teeth_bump_ps20b.inc
    │   │   │   ├── teeth_bump_ps30.inc
    │   │   │   ├── teeth_bump_vs20.inc
    │   │   │   ├── teeth_bump_vs30.inc
    │   │   │   ├── teeth_flashlight_ps20.inc
    │   │   │   ├── teeth_flashlight_ps20b.inc
    │   │   │   ├── teeth_flashlight_ps30.inc
    │   │   │   ├── teeth_flashlight_vs20.inc
    │   │   │   ├── teeth_flashlight_vs30.inc
    │   │   │   ├── teeth_ps20.inc
    │   │   │   ├── teeth_ps20b.inc
    │   │   │   ├── teeth_ps30.inc
    │   │   │   ├── teeth_vs20.inc
    │   │   │   ├── teeth_vs30.inc
    │   │   │   ├── treeleaf_ps20.inc
    │   │   │   ├── treeleaf_ps20b.inc
    │   │   │   ├── treeleaf_vs20.inc
    │   │   │   ├── unlitgeneric_lightingonly_vs11.inc
    │   │   │   ├── unlitgeneric_maskbasebydetailalpha_ps11.inc
    │   │   │   ├── unlitgeneric_notexture_ps11.inc
    │   │   │   ├── unlitgeneric_notexture_ps20.inc
    │   │   │   ├── unlitgeneric_notexture_ps20b.inc
    │   │   │   ├── unlitgeneric_ps11.inc
    │   │   │   ├── unlitgeneric_ps20.inc
    │   │   │   ├── unlitgeneric_ps20b.inc
    │   │   │   ├── unlitgeneric_vs20.inc
    │   │   │   ├── unlittwotexture_ps20.inc
    │   │   │   ├── unlittwotexture_ps20b.inc
    │   │   │   ├── unlittwotexture_vs20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_bump_ps20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_bump_ps20b.inc
    │   │   │   ├── vertexlit_and_unlit_generic_bump_ps30.inc
    │   │   │   ├── VertexLit_and_unlit_Generic_bump_vs20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_bump_vs30.inc
    │   │   │   ├── vertexlit_and_unlit_generic_ps20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_ps20b.inc
    │   │   │   ├── vertexlit_and_unlit_generic_ps30.inc
    │   │   │   ├── VertexLit_and_unlit_Generic_vs20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_vs30.inc
    │   │   │   ├── vertexlit_lighting_only_ps20.inc
    │   │   │   ├── vertexlit_lighting_only_ps20b.inc
    │   │   │   ├── vertexlitgeneric_lightingonly_overbright2_ps11.inc
    │   │   │   ├── volume_clouds_ps20.inc
    │   │   │   ├── volume_clouds_ps20b.inc
    │   │   │   ├── volume_clouds_vs20.inc
    │   │   │   ├── vortwarp_ps20.inc
    │   │   │   ├── vortwarp_ps20b.inc
    │   │   │   ├── vortwarp_ps30.inc
    │   │   │   ├── vortwarp_vs20.inc
    │   │   │   ├── vortwarp_vs30.inc
    │   │   │   ├── vr_distort_hud_ps20.inc
    │   │   │   ├── vr_distort_hud_ps20b.inc
    │   │   │   ├── vr_distort_hud_ps30.inc
    │   │   │   ├── vr_distort_hud_vs20.inc
    │   │   │   ├── vr_distort_hud_vs30.inc
    │   │   │   ├── vr_distort_texture_ps20.inc
    │   │   │   ├── vr_distort_texture_ps20b.inc
    │   │   │   ├── vr_distort_texture_ps30.inc
    │   │   │   ├── vr_distort_texture_vs20.inc
    │   │   │   ├── vr_distort_texture_vs30.inc
    │   │   │   ├── warp_ps20.inc
    │   │   │   ├── warp_ps20b.inc
    │   │   │   ├── warp_ps30.inc
    │   │   │   ├── warp_vs20.inc
    │   │   │   ├── warp_vs30.inc
    │   │   │   ├── Water_ps20.inc
    │   │   │   ├── water_ps20b.inc
    │   │   │   ├── Water_vs20.inc
    │   │   │   ├── WaterCheap_ps20.inc
    │   │   │   ├── WaterCheap_ps20b.inc
    │   │   │   ├── WaterCheap_vs20.inc
    │   │   │   ├── weapon_sheen_pass_ps20.inc
    │   │   │   ├── weapon_sheen_pass_ps20b.inc
    │   │   │   ├── weapon_sheen_pass_ps30.inc
    │   │   │   ├── weapon_sheen_pass_vs20.inc
    │   │   │   ├── weapon_sheen_pass_vs30.inc
    │   │   │   ├── white_ps20.inc
    │   │   │   ├── white_ps20b.inc
    │   │   │   ├── windowimposter_ps11.inc
    │   │   │   ├── windowimposter_ps20.inc
    │   │   │   ├── windowimposter_ps20b.inc
    │   │   │   ├── windowimposter_vs11.inc
    │   │   │   ├── windowimposter_vs20.inc
    │   │   │   ├── WorldTwoTextureBlend_ps20.inc
    │   │   │   ├── WorldTwoTextureBlend_ps20b.inc
    │   │   │   ├── worldvertexalpha_ps20.inc
    │   │   │   ├── worldvertexalpha_ps20b.inc
    │   │   │   ├── writevertexalphatodestalpha_ps11.inc
    │   │   │   ├── writevertexalphatodestalpha_vs11.inc
    │   │   │   └── writez_vs20.inc
    │   │   ├── fxctmp9_360/
    │   │   │   ├── accumbuff4sample_ps20.inc
    │   │   │   ├── accumbuff4sample_ps20b.inc
    │   │   │   ├── accumbuff5sample_ps20.inc
    │   │   │   ├── accumbuff5sample_ps20b.inc
    │   │   │   ├── aftershock_ps20.inc
    │   │   │   ├── aftershock_ps20b.inc
    │   │   │   ├── aftershock_vs20.inc
    │   │   │   ├── alphadist_ps11.inc
    │   │   │   ├── appchooser360movie_ps20.inc
    │   │   │   ├── appchooser360movie_ps20b.inc
    │   │   │   ├── bik_ps20.inc
    │   │   │   ├── bik_ps20b.inc
    │   │   │   ├── bik_vs20.inc
    │   │   │   ├── Bloom_ps20.inc
    │   │   │   ├── Bloom_ps20b.inc
    │   │   │   ├── bloomadd_ps11.inc
    │   │   │   ├── bloomadd_ps20.inc
    │   │   │   ├── bloomadd_ps20b.inc
    │   │   │   ├── BlurFilter_ps20.inc
    │   │   │   ├── BlurFilter_ps20b.inc
    │   │   │   ├── BlurFilter_vs11.inc
    │   │   │   ├── BlurFilter_vs20.inc
    │   │   │   ├── bufferclearobeystencil_ps20.inc
    │   │   │   ├── bufferclearobeystencil_ps20b.inc
    │   │   │   ├── bufferclearobeystencil_vs20.inc
    │   │   │   ├── bumpmappedlightmap_vs11.inc
    │   │   │   ├── cable_ps20.inc
    │   │   │   ├── cable_ps20b.inc
    │   │   │   ├── cable_vs20.inc
    │   │   │   ├── cloak_blended_pass_ps20.inc
    │   │   │   ├── cloak_blended_pass_ps20b.inc
    │   │   │   ├── cloak_blended_pass_vs20.inc
    │   │   │   ├── cloak_ps20.inc
    │   │   │   ├── cloak_ps20b.inc
    │   │   │   ├── cloak_vs20.inc
    │   │   │   ├── cloud_ps20.inc
    │   │   │   ├── cloud_vs20.inc
    │   │   │   ├── color_projection_ps20.inc
    │   │   │   ├── color_projection_ps20b.inc
    │   │   │   ├── color_projection_vs20.inc
    │   │   │   ├── colorcorrection_ps20.inc
    │   │   │   ├── colorcorrection_ps20b.inc
    │   │   │   ├── constant_color_ps20.inc
    │   │   │   ├── constant_color_ps20b.inc
    │   │   │   ├── copy_fp_rt_ps20.inc
    │   │   │   ├── copy_fp_rt_ps20b.inc
    │   │   │   ├── core_ps20.inc
    │   │   │   ├── core_ps20b.inc
    │   │   │   ├── core_vs11.inc
    │   │   │   ├── core_vs20.inc
    │   │   │   ├── debugdrawdepth_ps20.inc
    │   │   │   ├── debugdrawdepth_ps20b.inc
    │   │   │   ├── debugdrawdepth_vs20.inc
    │   │   │   ├── debugdrawenvmapmask_ps20.inc
    │   │   │   ├── debugdrawenvmapmask_ps20b.inc
    │   │   │   ├── debugdrawenvmapmask_vs20.inc
    │   │   │   ├── debugmrttexture_ps20.inc
    │   │   │   ├── debugmrttexture_ps20b.inc
    │   │   │   ├── debugmrttexture_vs20.inc
    │   │   │   ├── debugtangentspace_vs11.inc
    │   │   │   ├── debugtangentspace_vs20.inc
    │   │   │   ├── debugtextureview_ps20.inc
    │   │   │   ├── debugtextureview_ps20b.inc
    │   │   │   ├── debugtextureview_vs20.inc
    │   │   │   ├── decalbasetimeslightmapalphablendselfillum2_ps20.inc
    │   │   │   ├── decalbasetimeslightmapalphablendselfillum2_ps20b.inc
    │   │   │   ├── decalmodulate_ps20.inc
    │   │   │   ├── decalmodulate_ps20b.inc
    │   │   │   ├── depthtodestalpha_ps20b.inc
    │   │   │   ├── depthtodestalpha_vs20.inc
    │   │   │   ├── depthwrite_ps20.inc
    │   │   │   ├── depthwrite_ps20b.inc
    │   │   │   ├── depthwrite_vs20.inc
    │   │   │   ├── Downsample_nohdr_ps20.inc
    │   │   │   ├── Downsample_nohdr_ps20b.inc
    │   │   │   ├── Downsample_ps20.inc
    │   │   │   ├── Downsample_ps20b.inc
    │   │   │   ├── Downsample_vs11.inc
    │   │   │   ├── Downsample_vs20.inc
    │   │   │   ├── emissive_scroll_blended_pass_ps20.inc
    │   │   │   ├── emissive_scroll_blended_pass_ps20b.inc
    │   │   │   ├── emissive_scroll_blended_pass_vs20.inc
    │   │   │   ├── engine_post_ps20.inc
    │   │   │   ├── engine_post_ps20b.inc
    │   │   │   ├── eye_refract_ps20.inc
    │   │   │   ├── eye_refract_ps20b.inc
    │   │   │   ├── eye_refract_vs20.inc
    │   │   │   ├── eyeglint_ps20.inc
    │   │   │   ├── eyeglint_ps20b.inc
    │   │   │   ├── eyeglint_vs20.inc
    │   │   │   ├── eyes_flashlight_ps11.inc
    │   │   │   ├── eyes_flashlight_ps20.inc
    │   │   │   ├── eyes_flashlight_ps20b.inc
    │   │   │   ├── eyes_flashlight_vs20.inc
    │   │   │   ├── eyes_ps20.inc
    │   │   │   ├── eyes_ps20b.inc
    │   │   │   ├── eyes_vs20.inc
    │   │   │   ├── fillrate_ps11.inc
    │   │   │   ├── fillrate_ps20.inc
    │   │   │   ├── fillrate_ps20b.inc
    │   │   │   ├── fillrate_vs11.inc
    │   │   │   ├── fillrate_vs20.inc
    │   │   │   ├── filmdust_ps11.inc
    │   │   │   ├── filmdust_ps20.inc
    │   │   │   ├── filmgrain_ps11.inc
    │   │   │   ├── filmgrain_ps20.inc
    │   │   │   ├── filmgrain_vs20.inc
    │   │   │   ├── flashlight_ps11.inc
    │   │   │   ├── flashlight_ps20.inc
    │   │   │   ├── flashlight_ps20b.inc
    │   │   │   ├── flesh_interior_blended_pass_ps20.inc
    │   │   │   ├── flesh_interior_blended_pass_ps20b.inc
    │   │   │   ├── flesh_interior_blended_pass_vs20.inc
    │   │   │   ├── floatcombine_autoexpose_ps20.inc
    │   │   │   ├── floatcombine_autoexpose_ps20b.inc
    │   │   │   ├── floatcombine_ps20.inc
    │   │   │   ├── floatcombine_ps20b.inc
    │   │   │   ├── floattoscreen_notonemap_ps20.inc
    │   │   │   ├── floattoscreen_notonemap_ps20b.inc
    │   │   │   ├── floattoscreen_ps20.inc
    │   │   │   ├── floattoscreen_ps20b.inc
    │   │   │   ├── floattoscreen_vanilla_ps20.inc
    │   │   │   ├── floattoscreen_vanilla_ps20b.inc
    │   │   │   ├── haloadd1d_ps20.inc
    │   │   │   ├── haloadd1d_ps20b.inc
    │   │   │   ├── haloadd_ps20.inc
    │   │   │   ├── haloadd_ps20b.inc
    │   │   │   ├── haloaddoutline_ps20.inc
    │   │   │   ├── haloaddoutline_ps20b.inc
    │   │   │   ├── HDRCombineTo16Bit_ps20.inc
    │   │   │   ├── HDRCombineTo16Bit_ps20b.inc
    │   │   │   ├── HDRCombineTo16Bit_vs20.inc
    │   │   │   ├── HDRSelectRange_ps20.inc
    │   │   │   ├── HDRSelectRange_ps20b.inc
    │   │   │   ├── HDRSelectRange_vs20.inc
    │   │   │   ├── hsl_filmgrain_pass1_ps20.inc
    │   │   │   ├── hsl_filmgrain_pass1_ps20b.inc
    │   │   │   ├── hsl_filmgrain_pass2_ps20.inc
    │   │   │   ├── hsl_filmgrain_pass2_ps20b.inc
    │   │   │   ├── hsv_ps20.inc
    │   │   │   ├── hsv_ps20b.inc
    │   │   │   ├── introscreenspaceeffect_ps11.inc
    │   │   │   ├── IntroScreenSpaceEffect_ps20.inc
    │   │   │   ├── IntroScreenSpaceEffect_ps20b.inc
    │   │   │   ├── lightmappedgeneric_decal_ps20.inc
    │   │   │   ├── lightmappedgeneric_decal_ps20b.inc
    │   │   │   ├── lightmappedgeneric_decal_vs20.inc
    │   │   │   ├── lightmappedgeneric_flashlight_vs11.inc
    │   │   │   ├── lightmappedgeneric_flashlight_vs20.inc
    │   │   │   ├── lightmappedgeneric_lightingonly_overbright2_ps11.inc
    │   │   │   ├── lightmappedgeneric_lightingonly_vs11.inc
    │   │   │   ├── lightmappedgeneric_ps20.inc
    │   │   │   ├── lightmappedgeneric_ps20b.inc
    │   │   │   ├── lightmappedgeneric_vs20.inc
    │   │   │   ├── lightmappedreflective_ps20.inc
    │   │   │   ├── lightmappedreflective_ps20b.inc
    │   │   │   ├── lightmappedreflective_vs20.inc
    │   │   │   ├── lpreview1_ps20.inc
    │   │   │   ├── lpreview1_ps20b.inc
    │   │   │   ├── lpreview_output_ps20.inc
    │   │   │   ├── lpreview_output_ps20b.inc
    │   │   │   ├── luminance_compare_ps20.inc
    │   │   │   ├── luminance_compare_ps20b.inc
    │   │   │   ├── modulate_ps20.inc
    │   │   │   ├── modulate_ps20b.inc
    │   │   │   ├── monitorscreen_ps20.inc
    │   │   │   ├── monitorscreen_ps20b.inc
    │   │   │   ├── motion_blur_ps20.inc
    │   │   │   ├── motion_blur_ps20b.inc
    │   │   │   ├── motion_blur_vs20.inc
    │   │   │   ├── ParticleSphere_ps11.inc
    │   │   │   ├── particlesphere_ps20.inc
    │   │   │   ├── particlesphere_ps20b.inc
    │   │   │   ├── ParticleSphere_vs11.inc
    │   │   │   ├── particlesphere_vs20.inc
    │   │   │   ├── portal_ps11.inc
    │   │   │   ├── portal_ps20.inc
    │   │   │   ├── portal_ps20b.inc
    │   │   │   ├── portal_refract_ps11.inc
    │   │   │   ├── portal_refract_ps20.inc
    │   │   │   ├── portal_refract_ps20b.inc
    │   │   │   ├── portal_refract_vs11.inc
    │   │   │   ├── portal_refract_vs20.inc
    │   │   │   ├── portal_vs11.inc
    │   │   │   ├── portal_vs20.inc
    │   │   │   ├── portalstaticoverlay_ps11.inc
    │   │   │   ├── portalstaticoverlay_ps20.inc
    │   │   │   ├── portalstaticoverlay_ps20b.inc
    │   │   │   ├── portalstaticoverlay_vs11.inc
    │   │   │   ├── portalstaticoverlay_vs20.inc
    │   │   │   ├── Refract_ps20.inc
    │   │   │   ├── refract_ps20b.inc
    │   │   │   ├── Refract_vs20.inc
    │   │   │   ├── rendertargetblit_ps20.inc
    │   │   │   ├── rendertargetblit_ps20b.inc
    │   │   │   ├── rendertargetblit_vs20.inc
    │   │   │   ├── sample4x4_blend_ps20.inc
    │   │   │   ├── sample4x4_blend_ps20b.inc
    │   │   │   ├── sample4x4_ps20.inc
    │   │   │   ├── sample4x4_ps20b.inc
    │   │   │   ├── sample4x4delog_ps20.inc
    │   │   │   ├── sample4x4delog_ps20b.inc
    │   │   │   ├── sample4x4log_ps20.inc
    │   │   │   ├── sample4x4log_ps20b.inc
    │   │   │   ├── sample4x4maxmin_ps20.inc
    │   │   │   ├── sample4x4maxmin_ps20b.inc
    │   │   │   ├── screenspaceeffect_vs11.inc
    │   │   │   ├── screenspaceeffect_vs20.inc
    │   │   │   ├── sfm_combine_vs20.inc
    │   │   │   ├── sfm_integercombine_ps20.inc
    │   │   │   ├── sfm_integercombine_ps20b.inc
    │   │   │   ├── shadow_ps20.inc
    │   │   │   ├── shadow_ps20b.inc
    │   │   │   ├── shadow_vs20.inc
    │   │   │   ├── shadowbuildtexture_ps20.inc
    │   │   │   ├── shadowbuildtexture_ps20b.inc
    │   │   │   ├── shadowmodel_ps20.inc
    │   │   │   ├── shadowmodel_vs20.inc
    │   │   │   ├── ShatteredGlass_ps20.inc
    │   │   │   ├── ShatteredGlass_ps20b.inc
    │   │   │   ├── ShatteredGlass_vs20.inc
    │   │   │   ├── showz_ps20.inc
    │   │   │   ├── showz_ps20b.inc
    │   │   │   ├── showz_vs11.inc
    │   │   │   ├── showz_vs20.inc
    │   │   │   ├── skin_ps20b.inc
    │   │   │   ├── skin_vs20.inc
    │   │   │   ├── sky_hdr_compressed_ps20.inc
    │   │   │   ├── sky_hdr_compressed_ps20b.inc
    │   │   │   ├── sky_hdr_compressed_rgbs_ps20.inc
    │   │   │   ├── sky_hdr_compressed_rgbs_ps20b.inc
    │   │   │   ├── sky_ps20.inc
    │   │   │   ├── sky_ps20b.inc
    │   │   │   ├── sky_vs20.inc
    │   │   │   ├── splinecard_vs11.inc
    │   │   │   ├── splinecard_vs20.inc
    │   │   │   ├── sprite_ps20.inc
    │   │   │   ├── sprite_ps20b.inc
    │   │   │   ├── sprite_vs20.inc
    │   │   │   ├── spritecard_ps11.inc
    │   │   │   ├── spritecard_ps20.inc
    │   │   │   ├── spritecard_ps20b.inc
    │   │   │   ├── spritecard_vs11.inc
    │   │   │   ├── spritecard_vs20.inc
    │   │   │   ├── teeth_bump_ps20.inc
    │   │   │   ├── teeth_bump_ps20b.inc
    │   │   │   ├── teeth_bump_vs20.inc
    │   │   │   ├── teeth_flashlight_ps20.inc
    │   │   │   ├── teeth_flashlight_ps20b.inc
    │   │   │   ├── teeth_flashlight_vs20.inc
    │   │   │   ├── teeth_ps20.inc
    │   │   │   ├── teeth_ps20b.inc
    │   │   │   ├── teeth_vs20.inc
    │   │   │   ├── treeleaf_ps20.inc
    │   │   │   ├── treeleaf_ps20b.inc
    │   │   │   ├── treeleaf_vs20.inc
    │   │   │   ├── unlitgeneric_maskbasebydetailalpha_ps11.inc
    │   │   │   ├── unlitgeneric_notexture_ps11.inc
    │   │   │   ├── unlitgeneric_notexture_ps20.inc
    │   │   │   ├── unlitgeneric_notexture_ps20b.inc
    │   │   │   ├── unlitgeneric_ps20.inc
    │   │   │   ├── unlitgeneric_ps20b.inc
    │   │   │   ├── unlitgeneric_vs20.inc
    │   │   │   ├── unlittwotexture_ps20.inc
    │   │   │   ├── unlittwotexture_ps20b.inc
    │   │   │   ├── unlittwotexture_vs20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_bump_ps20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_bump_ps20b.inc
    │   │   │   ├── VertexLit_and_unlit_Generic_bump_vs20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_ps20.inc
    │   │   │   ├── vertexlit_and_unlit_generic_ps20b.inc
    │   │   │   ├── VertexLit_and_unlit_Generic_vs20.inc
    │   │   │   ├── vertexlitgeneric_lightingonly_overbright2_ps11.inc
    │   │   │   ├── volume_clouds_ps20.inc
    │   │   │   ├── volume_clouds_ps20b.inc
    │   │   │   ├── volume_clouds_vs20.inc
    │   │   │   ├── vortwarp_ps20.inc
    │   │   │   ├── vortwarp_ps20b.inc
    │   │   │   ├── vortwarp_vs20.inc
    │   │   │   ├── Water_ps20.inc
    │   │   │   ├── water_ps20b.inc
    │   │   │   ├── Water_vs20.inc
    │   │   │   ├── WaterCheap_ps20.inc
    │   │   │   ├── WaterCheap_ps20b.inc
    │   │   │   ├── WaterCheap_vs20.inc
    │   │   │   ├── white_ps20.inc
    │   │   │   ├── white_ps20b.inc
    │   │   │   ├── windowimposter_ps11.inc
    │   │   │   ├── windowimposter_ps20.inc
    │   │   │   ├── windowimposter_ps20b.inc
    │   │   │   ├── windowimposter_vs11.inc
    │   │   │   ├── windowimposter_vs20.inc
    │   │   │   ├── WorldTwoTextureBlend_ps20.inc
    │   │   │   ├── WorldTwoTextureBlend_ps20b.inc
    │   │   │   ├── worldvertexalpha_ps20.inc
    │   │   │   ├── worldvertexalpha_ps20b.inc
    │   │   │   ├── writevertexalphatodestalpha_ps11.inc
    │   │   │   ├── writevertexalphatodestalpha_vs11.inc
    │   │   │   └── writez_vs20.inc
    │   │   ├── UPDB_X360/
    │   │   │   └── dummy.txt
    │   │   ├── vshtmp9/
    │   │   │   ├── bik_vs11.inc
    │   │   │   ├── BufferClearObeyStencil_vs11.inc
    │   │   │   ├── BumpmappedEnvmap.inc
    │   │   │   ├── BumpmappedLightmap.inc
    │   │   │   ├── Cable.inc
    │   │   │   ├── cloak_blended_pass_dx8_vs11.inc
    │   │   │   ├── cloud_vs11.inc
    │   │   │   ├── DebugTangentSpace.inc
    │   │   │   ├── emissive_scroll_blended_pass_dx8_vs11.inc
    │   │   │   ├── Eyes.inc
    │   │   │   ├── eyes_flashlight_vs11.inc
    │   │   │   ├── fillrate.inc
    │   │   │   ├── flesh_interior_blended_pass_dx8_vs11.inc
    │   │   │   ├── JellyFish.inc
    │   │   │   ├── Jojirium.inc
    │   │   │   ├── LightingOnly.inc
    │   │   │   ├── LightmappedGeneric_BaseTexture.inc
    │   │   │   ├── lightmappedgeneric_basetextureblend.inc
    │   │   │   ├── lightmappedgeneric_bumpmappedenvmap.inc
    │   │   │   ├── lightmappedgeneric_bumpmappedenvmap_ps14.inc
    │   │   │   ├── lightmappedgeneric_bumpmappedlightmap.inc
    │   │   │   ├── LightmappedGeneric_BumpmappedLightmap_Base_ps14.inc
    │   │   │   ├── LightmappedGeneric_BumpmappedLightmap_Blend_ps14.inc
    │   │   │   ├── LightmappedGeneric_Decal.inc
    │   │   │   ├── LightmappedGeneric_LightingOnly.inc
    │   │   │   ├── lightmappedgeneric_vs11.inc
    │   │   │   ├── overlay_fit_vs11.inc
    │   │   │   ├── predator.inc
    │   │   │   ├── Refract_model_vs11.inc
    │   │   │   ├── Refract_world_vs11.inc
    │   │   │   ├── rendertargetblit_vs11.inc
    │   │   │   ├── ScreenSpaceEffect.inc
    │   │   │   ├── shadow_vs14.inc
    │   │   │   ├── ShadowModel.inc
    │   │   │   ├── ShatteredGlass.inc
    │   │   │   ├── ShatteredGlass_EnvMap.inc
    │   │   │   ├── ShatteredGlass_EnvMapSphere.inc
    │   │   │   ├── sprite_vs11.inc
    │   │   │   ├── Teeth.inc
    │   │   │   ├── UnlitGeneric_LightingOnly.inc
    │   │   │   ├── unlitgeneric_vs11.inc
    │   │   │   ├── UnlitTwoTexture.inc
    │   │   │   ├── VertexLitGeneric_EnvmappedBumpmap_NoLighting.inc
    │   │   │   ├── VertexLitGeneric_EnvmappedBumpmap_NoLighting_ps14.inc
    │   │   │   ├── vertexlitgeneric_flashlight_vs11.inc
    │   │   │   ├── VertexLitGeneric_SelfIllumOnly.inc
    │   │   │   ├── VertexLitGeneric_vs11.inc
    │   │   │   ├── vortwarp_vs11.inc
    │   │   │   ├── Water_ps14.inc
    │   │   │   ├── Water_vs11.inc
    │   │   │   ├── WaterCheap_vs11.inc
    │   │   │   ├── WaterCheap_vs14.inc
    │   │   │   ├── WaterCheapPerVertexFresnel_vs11.inc
    │   │   │   ├── WorldVertexAlpha.inc
    │   │   │   ├── WorldVertexTransition.inc
    │   │   │   ├── worldvertextransition_seamless.inc
    │   │   │   ├── worldvertextransition_vs14.inc
    │   │   │   └── writez.inc
    │   │   ├── vshtmp9_360/
    │   │   │   ├── bik_vs11.inc
    │   │   │   ├── BufferClearObeyStencil_vs11.inc
    │   │   │   ├── BumpmappedEnvmap.inc
    │   │   │   ├── BumpmappedLightmap.inc
    │   │   │   ├── Cable.inc
    │   │   │   ├── cloak_blended_pass_dx8_vs11.inc
    │   │   │   ├── cloud_vs11.inc
    │   │   │   ├── DebugTangentSpace.inc
    │   │   │   ├── emissive_scroll_blended_pass_dx8_vs11.inc
    │   │   │   ├── Eyes.inc
    │   │   │   ├── eyes_flashlight_vs11.inc
    │   │   │   ├── fillrate.inc
    │   │   │   ├── flesh_interior_blended_pass_dx8_vs11.inc
    │   │   │   ├── JellyFish.inc
    │   │   │   ├── LightingOnly.inc
    │   │   │   ├── LightmappedGeneric_BaseTexture.inc
    │   │   │   ├── lightmappedgeneric_basetextureblend.inc
    │   │   │   ├── lightmappedgeneric_bumpmappedenvmap.inc
    │   │   │   ├── lightmappedgeneric_bumpmappedenvmap_ps14.inc
    │   │   │   ├── lightmappedgeneric_bumpmappedlightmap.inc
    │   │   │   ├── LightmappedGeneric_BumpmappedLightmap_Base_ps14.inc
    │   │   │   ├── LightmappedGeneric_BumpmappedLightmap_Blend_ps14.inc
    │   │   │   ├── LightmappedGeneric_Decal.inc
    │   │   │   ├── LightmappedGeneric_LightingOnly.inc
    │   │   │   ├── lightmappedgeneric_vs11.inc
    │   │   │   ├── overlay_fit_vs11.inc
    │   │   │   ├── predator.inc
    │   │   │   ├── Refract_model_vs11.inc
    │   │   │   ├── Refract_world_vs11.inc
    │   │   │   ├── ScreenSpaceEffect.inc
    │   │   │   ├── shadow_vs14.inc
    │   │   │   ├── ShadowModel.inc
    │   │   │   ├── ShatteredGlass.inc
    │   │   │   ├── ShatteredGlass_EnvMap.inc
    │   │   │   ├── ShatteredGlass_EnvMapSphere.inc
    │   │   │   ├── sprite_vs11.inc
    │   │   │   ├── Teeth.inc
    │   │   │   ├── UnlitGeneric_LightingOnly.inc
    │   │   │   ├── unlitgeneric_vs11.inc
    │   │   │   ├── UnlitTwoTexture.inc
    │   │   │   ├── VertexLitGeneric_EnvmappedBumpmap_NoLighting.inc
    │   │   │   ├── VertexLitGeneric_EnvmappedBumpmap_NoLighting_ps14.inc
    │   │   │   ├── vertexlitgeneric_flashlight_vs11.inc
    │   │   │   ├── VertexLitGeneric_SelfIllumOnly.inc
    │   │   │   ├── VertexLitGeneric_vs11.inc
    │   │   │   ├── vortwarp_vs11.inc
    │   │   │   ├── Water_ps14.inc
    │   │   │   ├── Water_vs11.inc
    │   │   │   ├── WaterCheap_vs11.inc
    │   │   │   ├── WaterCheap_vs14.inc
    │   │   │   ├── WaterCheapPerVertexFresnel_vs11.inc
    │   │   │   ├── WorldVertexAlpha.inc
    │   │   │   ├── WorldVertexTransition.inc
    │   │   │   ├── worldvertextransition_seamless.inc
    │   │   │   ├── worldvertextransition_vs14.inc
    │   │   │   └── writez.inc
    │   │   └── xbox/
    │   │       ├── xbox_dbg.def
    │   │       ├── xbox_dx8.def
    │   │       └── xbox_dx9.def
    │   └── xbox/
    │       └── xbox.def
    ├── mathlib/
    │   ├── 3dnow.cpp
    │   ├── 3dnow.h
    │   ├── almostequal.cpp
    │   ├── anorms.cpp
    │   ├── bumpvects.cpp
    │   ├── color_conversion.cpp
    │   ├── datagen.pl
    │   ├── halton.cpp
    │   ├── IceKey.cpp
    │   ├── imagequant.cpp
    │   ├── lightdesc.cpp
    │   ├── mathlib.vpc
    │   ├── mathlib_base.cpp
    │   ├── noisedata.h
    │   ├── polyhedron.cpp
    │   ├── powsse.cpp
    │   ├── quantize.cpp
    │   ├── randsse.cpp
    │   ├── simdvectormatrix.cpp
    │   ├── sparse_convolution_noise.cpp
    │   ├── spherical.cpp
    │   ├── sse.cpp
    │   ├── sse.h
    │   ├── sseconst.cpp
    │   ├── ssenoise.cpp
    │   ├── vector.cpp
    │   ├── vmatrix.cpp
    │   └── wscript
    ├── mdllib/
    │   ├── mdllib.cpp
    │   ├── mdllib.vpc
    │   ├── mdllib_common.h
    │   ├── mdllib_stripinfo.cpp
    │   ├── mdllib_stripinfo.h
    │   ├── mdllib_stripmodel.cpp
    │   ├── mdllib_utils.cpp
    │   └── mdllib_utils.h
    ├── mdlobjects/
    │   ├── dmeblankbodypart.cpp
    │   ├── dmebodygroup.cpp
    │   ├── dmebodygrouplist.cpp
    │   ├── dmebodypart.cpp
    │   ├── dmeboneflexdriver.cpp
    │   ├── dmebonemask.cpp
    │   ├── dmebonemasklist.cpp
    │   ├── dmeboneweight.cpp
    │   ├── dmecollisionmodel.cpp
    │   ├── dmehitbox.cpp
    │   ├── dmehitboxset.cpp
    │   ├── dmelod.cpp
    │   ├── dmelodlist.cpp
    │   ├── dmemdllist.cpp
    │   ├── dmesequence.cpp
    │   ├── dmesequencelist.cpp
    │   └── mdlobjects.vpc
    ├── movieobjects/
    │   ├── dmeanimationlist.cpp
    │   ├── dmeanimationset.cpp
    │   ├── dmeattachment.cpp
    │   ├── dmebalancetostereocalculatoroperator.cpp
    │   ├── dmebookmark.cpp
    │   ├── dmecamera.cpp
    │   ├── dmechannel.cpp
    │   ├── dmeclip.cpp
    │   ├── dmecombinationoperator.cpp
    │   ├── dmedag.cpp
    │   ├── dmedccmakefile.cpp
    │   ├── dmedrawsettings.cpp
    │   ├── dmeeditortypedictionary.cpp
    │   ├── dmeexpressionoperator.cpp
    │   ├── dmeeyeball.cpp
    │   ├── dmeeyeposition.cpp
    │   ├── dmefaceset.cpp
    │   ├── dmegamemodel.cpp
    │   ├── dmegamemodelinput.cpp
    │   ├── dmeimage.cpp
    │   ├── dmeinput.cpp
    │   ├── dmejoint.cpp
    │   ├── dmekeyboardinput.cpp
    │   ├── dmelight.cpp
    │   ├── dmelog.cpp
    │   ├── dmemakefile.cpp
    │   ├── dmemakefileutils.cpp
    │   ├── dmematerial.cpp
    │   ├── dmematerialoverlayfxclip.cpp
    │   ├── dmemdl.cpp
    │   ├── dmemdlmakefile.cpp
    │   ├── dmemesh.cpp
    │   ├── dmemodel.cpp
    │   ├── dmemorphoperator.cpp
    │   ├── dmemouseinput.cpp
    │   ├── dmeoperator.cpp
    │   ├── dmepackoperators.cpp
    │   ├── dmeparticlesystemdefinition.cpp
    │   ├── dmephonememapping.cpp
    │   ├── dmeselection.cpp
    │   ├── dmeshader.cpp
    │   ├── dmeshape.cpp
    │   ├── dmesound.cpp
    │   ├── dmetestmesh.cpp
    │   ├── dmetexture.cpp
    │   ├── dmetimeframe.cpp
    │   ├── dmetimeselection.cpp
    │   ├── dmetrack.cpp
    │   ├── dmetrackgroup.cpp
    │   ├── dmetransform.cpp
    │   ├── dmetransforminput.cpp
    │   ├── dmetransformlist.cpp
    │   ├── dmetransformoperator.cpp
    │   ├── dmeunpackoperators.cpp
    │   ├── dmevertexdata.cpp
    │   ├── dmmeshcomp.cpp
    │   ├── dmmeshutils.cpp
    │   ├── dmobjserializer.cpp
    │   ├── dmsmdserializer.cpp
    │   ├── dmx_to_vcd.cpp
    │   ├── importintovcd.cpp
    │   ├── movieobjects.vpc
    │   ├── movieobjects_interfaces.cpp
    │   └── movieobjects_interfaces.h
    ├── networksystem/
    │   ├── netchannel.cpp
    │   ├── netchannel.h
    │   ├── networkclient.cpp
    │   ├── networkclient.h
    │   ├── networkserver.cpp
    │   ├── networkserver.h
    │   ├── networksystem.cpp
    │   ├── networksystem.h
    │   ├── networksystem.vpc
    │   ├── sm_protocol.h
    │   ├── udp_process.cpp
    │   ├── udp_process.h
    │   ├── udp_socket.cpp
    │   └── udp_socket.h
    ├── particles/
    │   ├── addbuiltin_ops.cpp
    │   ├── builtin_constraints.cpp
    │   ├── builtin_initializers.cpp
    │   ├── builtin_particle_emitters.cpp
    │   ├── builtin_particle_forces.cpp
    │   ├── builtin_particle_ops.cpp
    │   ├── builtin_particle_render_ops.cpp
    │   ├── particle_sort.cpp
    │   ├── particles.cpp
    │   ├── particles.vpc
    │   ├── particles_internal.h
    │   ├── psheet.cpp
    │   ├── psheet.h
    │   ├── random_floats.h
    │   └── wscript
    ├── public/
    │   ├── arraystack.h
    │   ├── ATI_Compress.h
    │   ├── basehandle.h
    │   ├── BitmapFontFile.h
    │   ├── bitvec.h
    │   ├── blockingudpsocket.cpp
    │   ├── blockingudpsocket.h
    │   ├── bone_accessor.cpp
    │   ├── bone_accessor.h
    │   ├── bone_setup.cpp
    │   ├── bone_setup.h
    │   ├── bspfile.h
    │   ├── bspflags.h
    │   ├── bsptreedata.cpp
    │   ├── bsptreedata.h
    │   ├── builddisp.cpp
    │   ├── builddisp.h
    │   ├── captioncompiler.h
    │   ├── cdll_int.h
    │   ├── chunkfile.cpp
    │   ├── chunkfile.h
    │   ├── client_class.cpp
    │   ├── client_class.h
    │   ├── client_render_handle.h
    │   ├── client_textmessage.h
    │   ├── clientstats.h
    │   ├── cmodel.h
    │   ├── collisionutils.cpp
    │   ├── collisionutils.h
    │   ├── Color.h
    │   ├── con_nprint.h
    │   ├── const.h
    │   ├── coordsize.h
    │   ├── crtmemdebug.cpp
    │   ├── crtmemdebug.h
    │   ├── datamap.h
    │   ├── disp_common.cpp
    │   ├── disp_common.h
    │   ├── disp_powerinfo.cpp
    │   ├── disp_powerinfo.h
    │   ├── disp_tesselate.h
    │   ├── disp_vertindex.h
    │   ├── dispcoll.cpp
    │   ├── dispcoll.h
    │   ├── dispcoll_common.cpp
    │   ├── dispcoll_common.h
    │   ├── dlight.h
    │   ├── dt_common.h
    │   ├── dt_recv.cpp
    │   ├── dt_recv.h
    │   ├── dt_send.cpp
    │   ├── dt_send.h
    │   ├── dt_shared.cpp
    │   ├── dt_shared.h
    │   ├── dt_utlvector_common.cpp
    │   ├── dt_utlvector_common.h
    │   ├── dt_utlvector_recv.cpp
    │   ├── dt_utlvector_recv.h
    │   ├── dt_utlvector_send.cpp
    │   ├── dt_utlvector_send.h
    │   ├── edict.h
    │   ├── editor_sendcommand.cpp
    │   ├── editor_sendcommand.h
    │   ├── eiface.h
    │   ├── eifacev21.h
    │   ├── engine_hlds_api.h
    │   ├── event_flags.h
    │   ├── filesystem.h
    │   ├── filesystem_helpers.cpp
    │   ├── filesystem_helpers.h
    │   ├── filesystem_init.cpp
    │   ├── filesystem_init.h
    │   ├── filesystem_passthru.h
    │   ├── gamebspfile.h
    │   ├── gametrace.h
    │   ├── globalvars_base.h
    │   ├── iachievementmgr.h
    │   ├── ibsppack.h
    │   ├── iclient.h
    │   ├── icliententity.h
    │   ├── icliententitylist.h
    │   ├── iclientnetworkable.h
    │   ├── iclientrenderable.h
    │   ├── iclientthinkable.h
    │   ├── iclientunknown.h
    │   ├── iclientvirtualreality.h
    │   ├── icvar.h
    │   ├── idedicatedexports.h
    │   ├── iefx.h
    │   ├── ienginevgui.h
    │   ├── iexternaltest.h
    │   ├── ifilelist.h
    │   ├── igameevents.h
    │   ├── igameresources.h
    │   ├── IGameUIFuncs.h
    │   ├── IHammer.h
    │   ├── ihandleentity.h
    │   ├── ihltv.h
    │   ├── ihltvdirector.h
    │   ├── ilaunchabledll.h
    │   ├── imapoverview.h
    │   ├── inetchannel.h
    │   ├── inetchannelinfo.h
    │   ├── inetmessage.h
    │   ├── inetmsghandler.h
    │   ├── inetwork.h
    │   ├── interpolatortypes.cpp
    │   ├── interpolatortypes.h
    │   ├── iprediction.h
    │   ├── irecipientfilter.h
    │   ├── iregistry.h
    │   ├── isaverestore.h
    │   ├── iscratchpad3d.h
    │   ├── iserver.h
    │   ├── iserverentity.h
    │   ├── iservernetworkable.h
    │   ├── iserverunknown.h
    │   ├── ishadercompiledll.h
    │   ├── isoundcombiner.h
    │   ├── ispatialpartition.h
    │   ├── isqlwrapper.h
    │   ├── istudiorender.h
    │   ├── ivguicenterprint.h
    │   ├── ivoiceserver.h
    │   ├── ivoicetweak.h
    │   ├── ivraddll.h
    │   ├── ivrenderview.h
    │   ├── ivtex.h
    │   ├── ixboxsystem.h
    │   ├── jigglebones.cpp
    │   ├── jigglebones.h
    │   ├── kevvaluescompiler.cpp
    │   ├── keyvaluescompiler.h
    │   ├── list.h
    │   ├── loadcmdline.cpp
    │   ├── loadcmdline.h
    │   ├── localflexcontroller.h
    │   ├── lumpfiles.cpp
    │   ├── lumpfiles.h
    │   ├── map_utils.cpp
    │   ├── map_utils.h
    │   ├── measure_section.cpp
    │   ├── measure_section.h
    │   ├── minmax.h
    │   ├── model_types.h
    │   ├── modes.h
    │   ├── mouthinfo.h
    │   ├── networkstringtabledefs.h
    │   ├── networkvar.cpp
    │   ├── networkvar.h
    │   ├── nmatrix.h
    │   ├── ntree.h
    │   ├── nvector.h
    │   ├── nvtc.h
    │   ├── OfflineMode.h
    │   ├── optimize.h
    │   ├── overlaytext.h
    │   ├── phonemeconverter.cpp
    │   ├── phonemeconverter.h
    │   ├── phyfile.h
    │   ├── pixelwriter.h
    │   ├── PlayerState.h
    │   ├── posedebugger.cpp
    │   ├── posedebugger.h
    │   ├── r_efx.h
    │   ├── raytrace.h
    │   ├── registry.cpp
    │   ├── renamed_recvtable_compat.cpp
    │   ├── renamed_recvtable_compat.h
    │   ├── renderparm.h
    │   ├── rope_physics.cpp
    │   ├── rope_physics.h
    │   ├── rope_shared.h
    │   ├── savegame_version.h
    │   ├── saverestoretypes.h
    │   ├── scratchpad3d.cpp
    │   ├── scratchpad3d.h
    │   ├── ScratchPadUtils.cpp
    │   ├── ScratchPadUtils.h
    │   ├── sentence.cpp
    │   ├── sentence.h
    │   ├── server_class.cpp
    │   ├── server_class.h
    │   ├── shake.h
    │   ├── shattersurfacetypes.h
    │   ├── simple_physics.cpp
    │   ├── simple_physics.h
    │   ├── smooth_average.h
    │   ├── soundchars.h
    │   ├── soundcombiner.cpp
    │   ├── soundflags.h
    │   ├── soundinfo.h
    │   ├── SoundParametersInternal.cpp
    │   ├── stdstring.h
    │   ├── string_t.h
    │   ├── stringregistry.cpp
    │   ├── stringregistry.h
    │   ├── studio.cpp
    │   ├── studio.h
    │   ├── studio_generic_io.cpp
    │   ├── studio_virtualmodel.cpp
    │   ├── surfinfo.h
    │   ├── texture_group_names.h
    │   ├── trace.h
    │   ├── UnicodeFileHelpers.cpp
    │   ├── UnicodeFileHelpers.h
    │   ├── UtlCachedFileData.h
    │   ├── vallocator.cpp
    │   ├── vallocator.h
    │   ├── vcollide.h
    │   ├── vcollide_parse.h
    │   ├── view_shared.h
    │   ├── vphysics_interface.h
    │   ├── vphysics_interfaceV30.h
    │   ├── wadtypes.h
    │   ├── windows_default.manifest
    │   ├── winlite.h
    │   ├── worldsize.h
    │   ├── XUnzip.cpp
    │   ├── xwvfile.h
    │   ├── XZip.cpp
    │   ├── xzp.cpp
    │   ├── zip_uncompressed.h
    │   ├── zip_utils.cpp
    │   ├── zip_utils.h
    │   ├── appframework/
    │   │   ├── AppFramework.h
    │   │   ├── IAppSystem.h
    │   │   ├── IAppSystemGroup.h
    │   │   ├── ilaunchermgr.h
    │   │   ├── tier2app.h
    │   │   ├── tier3app.h
    │   │   └── VguiMatSysApp.h
    │   ├── avi/
    │   │   ├── iavi.h
    │   │   ├── ibik.h
    │   │   └── iquicktime.h
    │   ├── bitmap/
    │   │   ├── bitmap.h
    │   │   ├── cubemap.h
    │   │   ├── float_bm.h
    │   │   ├── imageformat.h
    │   │   ├── psd.h
    │   │   ├── tgaloader.h
    │   │   └── tgawriter.h
    │   ├── datacache/
    │   │   ├── idatacache.h
    │   │   └── imdlcache.h
    │   ├── datamodel/
    │   │   ├── attributeflags.h
    │   │   ├── dmattribute.h
    │   │   ├── dmattributetypes.h
    │   │   ├── dmattributevar.h
    │   │   ├── dmehandle.h
    │   │   ├── dmelement.h
    │   │   ├── dmelementfactoryhelper.h
    │   │   ├── dmelementhandle.h
    │   │   ├── dmvar.h
    │   │   └── idatamodel.h
    │   ├── demofile/
    │   │   └── demoformat.h
    │   ├── dme_controls/
    │   │   ├── AnimSetAttributeValue.h
    │   │   ├── AssetBuilder.h
    │   │   ├── attributeassetpickerpanel.h
    │   │   ├── AttributeBasePickerPanel.h
    │   │   ├── AttributeBoolChoicePanel.h
    │   │   ├── AttributeColorPickerPanel.h
    │   │   ├── attributedetailtypepickerpanel.h
    │   │   ├── AttributeElementPanel.h
    │   │   ├── AttributeElementPickerPanel.h
    │   │   ├── AttributeFilePickerPanel.h
    │   │   ├── AttributeIntChoicePanel.h
    │   │   ├── AttributeInterpolatorChoicePanel.h
    │   │   ├── AttributeMDLPickerPanel.h
    │   │   ├── AttributeSequencePickerPanel.h
    │   │   ├── attributeshaderpickerpanel.h
    │   │   ├── attributeslider.h
    │   │   ├── AttributeSoundPickerPanel.h
    │   │   ├── AttributeStringChoicePanel.h
    │   │   ├── attributesurfacepropertypickerpanel.h
    │   │   ├── AttributeTextEntry.h
    │   │   ├── AttributeTextPanel.h
    │   │   ├── AttributeWidgetFactory.h
    │   │   ├── BaseAnimationSetEditor.h
    │   │   ├── BaseAnimSetAttributeSliderPanel.h
    │   │   ├── BaseAnimSetControlGroupPanel.h
    │   │   ├── BaseAnimSetPresetFaderPanel.h
    │   │   ├── BaseAttributeChoicePanel.h
    │   │   ├── BaseAttributeDoubleChoicePanel.h
    │   │   ├── BaseAttributePanel.h
    │   │   ├── ChannelGraphPanel.h
    │   │   ├── dmecombinationsystemeditorpanel.h
    │   │   ├── dmecontrols.h
    │   │   ├── dmecontrols_utils.h
    │   │   ├── dmedageditpanel.h
    │   │   ├── dmedagrenderpanel.h
    │   │   ├── dmelogeditpanel.h
    │   │   ├── dmemdlpanel.h
    │   │   ├── dmepanel.h
    │   │   ├── dmepicker.h
    │   │   ├── dmepresetgroupeditorpanel.h
    │   │   ├── DmeSourceDCCFilePanel.h
    │   │   ├── DmeSourceSkinPanel.h
    │   │   ├── ElementPropertiesTree.h
    │   │   ├── FileListManager.h
    │   │   ├── filtercombobox.h
    │   │   ├── inotifyui.h
    │   │   ├── LogPreview.h
    │   │   ├── particlesystempanel.h
    │   │   ├── particlesystempropertiespanel.h
    │   │   ├── presetpicker.h
    │   │   ├── RecordingState.h
    │   │   ├── soundpicker.h
    │   │   └── soundrecordpanel.h
    │   ├── dmserializers/
    │   │   └── idmserializers.h
    │   ├── dmxloader/
    │   │   ├── dmxattribute.h
    │   │   ├── dmxelement.h
    │   │   └── dmxloader.h
    │   ├── engine/
    │   │   ├── http.h
    │   │   ├── IClientLeafSystem.h
    │   │   ├── ICollideable.h
    │   │   ├── IEngineSound.h
    │   │   ├── IEngineTrace.h
    │   │   ├── ienginevoice.h
    │   │   ├── imatchmaking.h
    │   │   ├── iserverplugin.h
    │   │   ├── iserversinfo.h
    │   │   ├── ishadowmgr.h
    │   │   ├── IStaticPropMgr.h
    │   │   ├── ivdebugoverlay.h
    │   │   ├── ivmodelinfo.h
    │   │   ├── ivmodelrender.h
    │   │   ├── SndInfo.h
    │   │   ├── thinktracecounter.h
    │   │   ├── view_sharedv1.h
    │   │   └── audio/
    │   │       ├── ivoicecodec.h
    │   │       ├── ivoicerecord.h
    │   │       ├── snd_audio_source.h
    │   │       ├── snd_device.h
    │   │       ├── snd_fixedint.h
    │   │       ├── snd_io.h
    │   │       ├── snd_mix_buf.h
    │   │       ├── sound.h
    │   │       ├── soundservice.h
    │   │       ├── voice.h
    │   │       └── vox.h
    │   ├── fgdlib/
    │   │   ├── entitydefs.h
    │   │   ├── fgdlib.h
    │   │   ├── gamedata.h
    │   │   ├── gdclass.h
    │   │   ├── gdvar.h
    │   │   ├── helperinfo.h
    │   │   ├── ieditortexture.h
    │   │   ├── inputoutput.h
    │   │   └── wckeyvalues.h
    │   ├── filesystem/
    │   │   └── IQueuedLoader.h
    │   ├── Friends/
    │   │   ├── IFriendsNET.h
    │   │   ├── IFriendsUser.h
    │   │   └── AddOns/
    │   │       ├── AddOnMessages.h
    │   │       ├── AddOnTypes.h
    │   │       └── ISteamAddOn.h
    │   ├── g15/
    │   │   └── ig15.h
    │   ├── game/
    │   │   ├── client/
    │   │   │   ├── iclientrendertargets.h
    │   │   │   ├── IGameClientExports.h
    │   │   │   └── iviewport.h
    │   │   └── server/
    │   │       ├── ientityinfo.h
    │   │       ├── igameinfo.h
    │   │       ├── iplayerinfo.h
    │   │       └── pluginvariant.h
    │   ├── gcsdk/
    │   │   ├── accountdetails.h
    │   │   ├── bufferpool.h
    │   │   ├── directory.h
    │   │   ├── enumutils.h
    │   │   ├── framefunction.h
    │   │   ├── gc_convar.h
    │   │   ├── gc_sharedobjectcache.h
    │   │   ├── gcbase.h
    │   │   ├── gcclient.h
    │   │   ├── gcclient_sharedobjectcache.h
    │   │   ├── gcclientjob.h
    │   │   ├── gcclientsdk.h
    │   │   ├── gcconstants.h
    │   │   ├── gcdirtyfield.h
    │   │   ├── gchost.h
    │   │   ├── gcinterface.h
    │   │   ├── gcjob.h
    │   │   ├── gcleaderboardapi.h
    │   │   ├── gclogger.h
    │   │   ├── gcmsg.h
    │   │   ├── gcparalleljobfarm.h
    │   │   ├── gcreportprinter.h
    │   │   ├── gcschema.h
    │   │   ├── gcsdk.h
    │   │   ├── gcsdk_auto.h
    │   │   ├── gcsession.h
    │   │   ├── gcsqlquery.h
    │   │   ├── gcsqlwritequeue.h
    │   │   ├── gcsteamdefines.h
    │   │   ├── gcsystemaccess.h
    │   │   ├── gcsystemmsgs.h
    │   │   ├── gcwebapi.h
    │   │   ├── gcwebapikey.h
    │   │   ├── gcwgjobmgr.h
    │   │   ├── http.h
    │   │   ├── job.h
    │   │   ├── jobmgr.h
    │   │   ├── jobtime.h
    │   │   ├── messagelist.h
    │   │   ├── msgbase.h
    │   │   ├── msgprotobuf.h
    │   │   ├── netpacket.h
    │   │   ├── netpacketpool.h
    │   │   ├── protobufsharedobject.h
    │   │   ├── refcount.h
    │   │   ├── scheduledfunction.h
    │   │   ├── schemasharedobject.h
    │   │   ├── sdocache.h
    │   │   ├── sharedobject.h
    │   │   ├── sharedobjectcache.h
    │   │   ├── sharedobjecttransaction.h
    │   │   ├── webapi_response.h
    │   │   ├── workthreadpool.h
    │   │   └── sqlaccess/
    │   │       ├── columnset.h
    │   │       ├── record.h
    │   │       ├── recordinfo.h
    │   │       ├── schema.h
    │   │       ├── schemafull.h
    │   │       ├── schemaupdate.h
    │   │       ├── sqlaccess.h
    │   │       ├── sqlrecord.h
    │   │       └── sqlutil.h
    │   ├── haptics/
    │   │   ├── haptic_msgs.cpp
    │   │   ├── haptic_msgs.h
    │   │   ├── haptic_utils.cpp
    │   │   ├── haptic_utils.h
    │   │   └── ihaptics.h
    │   ├── input/
    │   │   └── mousecursors.h
    │   ├── inputsystem/
    │   │   ├── AnalogCode.h
    │   │   ├── ButtonCode.h
    │   │   ├── iinputsystem.h
    │   │   └── InputEnums.h
    │   ├── itemtest/
    │   │   ├── itemtest.h
    │   │   └── itemtest_controls.h
    │   ├── jpeglib/
    │   │   ├── jconfig.h
    │   │   ├── jmorecfg.h
    │   │   └── jpeglib.h
    │   ├── keyframe/
    │   │   ├── keyframe.cpp
    │   │   └── keyframe.h
    │   ├── libpng/
    │   │   ├── png.h
    │   │   ├── pngconf.h
    │   │   ├── pnglibconf.h
    │   │   └── pngstruct.h
    │   ├── materialsystem/
    │   │   ├── combineoperations.h
    │   │   ├── deformations.h
    │   │   ├── hardwaretexels.h
    │   │   ├── hardwareverts.h
    │   │   ├── IColorCorrection.h
    │   │   ├── idebugtextureinfo.h
    │   │   ├── imaterial.h
    │   │   ├── imaterialproxy.h
    │   │   ├── imaterialproxyfactory.h
    │   │   ├── imaterialsystem.h
    │   │   ├── imaterialsystemhardwareconfig.h
    │   │   ├── imaterialsystemstub.h
    │   │   ├── imaterialvar.h
    │   │   ├── imesh.h
    │   │   ├── imorph.h
    │   │   ├── IShader.h
    │   │   ├── ishaderapi.h
    │   │   ├── ishadersystem_declarations.h
    │   │   ├── itexture.h
    │   │   ├── itexturecompositor.h
    │   │   ├── ivballoctracker.h
    │   │   ├── materialsystem_config.h
    │   │   ├── MaterialSystemUtil.cpp
    │   │   ├── MaterialSystemUtil.h
    │   │   ├── meshreader.h
    │   │   └── shader_vcs_version.h
    │   ├── mathlib/
    │   │   ├── amd3dx.h
    │   │   ├── anorms.h
    │   │   ├── bumpvects.h
    │   │   ├── compressed_3d_unitvec.h
    │   │   ├── compressed_light_cube.h
    │   │   ├── compressed_vector.h
    │   │   ├── halton.h
    │   │   ├── IceKey.H
    │   │   ├── lightdesc.h
    │   │   ├── math_pfns.h
    │   │   ├── mathlib.h
    │   │   ├── matrixmath.h
    │   │   ├── noise.h
    │   │   ├── polyhedron.h
    │   │   ├── quantize.h
    │   │   ├── simdvectormatrix.h
    │   │   ├── spherical_geometry.h
    │   │   ├── ssemath.h
    │   │   ├── ssequaternion.h
    │   │   ├── vector.h
    │   │   ├── vector2d.h
    │   │   ├── vector4d.h
    │   │   ├── vmatrix.h
    │   │   └── vplane.h
    │   ├── matsys_controls/
    │   │   ├── assetpicker.h
    │   │   ├── baseassetpicker.h
    │   │   ├── colorpickerpanel.h
    │   │   ├── curveeditorpanel.h
    │   │   ├── gamefiletreeview.h
    │   │   ├── manipulator.h
    │   │   ├── matsyscontrols.h
    │   │   ├── mdlpanel.h
    │   │   ├── mdlpicker.h
    │   │   ├── mdlsequencepicker.h
    │   │   ├── picker.h
    │   │   ├── potterywheelpanel.h
    │   │   ├── proceduraltexturepanel.h
    │   │   ├── QCGenerator.h
    │   │   ├── sequencepicker.h
    │   │   ├── tgapreviewpanel.h
    │   │   ├── vmtpanel.h
    │   │   ├── vmtpicker.h
    │   │   ├── vmtpreviewpanel.h
    │   │   ├── vtfpicker.h
    │   │   └── vtfpreviewpanel.h
    │   ├── mdllib/
    │   │   └── mdllib.h
    │   ├── mdlobjects/
    │   │   ├── dmeblankbodypart.h
    │   │   ├── dmebodygroup.h
    │   │   ├── dmebodygrouplist.h
    │   │   ├── dmebodypart.h
    │   │   ├── dmeboneflexdriver.h
    │   │   ├── dmebonemask.h
    │   │   ├── dmebonemasklist.h
    │   │   ├── dmeboneweight.h
    │   │   ├── dmecollisionmodel.h
    │   │   ├── dmehitbox.h
    │   │   ├── dmehitboxset.h
    │   │   ├── dmelod.h
    │   │   ├── dmelodlist.h
    │   │   ├── dmemdllist.h
    │   │   ├── dmesequence.h
    │   │   ├── dmesequencelist.h
    │   │   ├── mdlobjects.cpp
    │   │   └── mdlobjects.h
    │   ├── movieobjects/
    │   │   ├── dmeanimationlist.h
    │   │   ├── dmeanimationset.h
    │   │   ├── dmeattachment.h
    │   │   ├── dmebalancetostereocalculatoroperator.h
    │   │   ├── dmebookmark.h
    │   │   ├── dmecamera.h
    │   │   ├── dmechannel.h
    │   │   ├── dmeclip.h
    │   │   ├── dmecombinationoperator.h
    │   │   ├── dmedag.h
    │   │   ├── dmedccmakefile.h
    │   │   ├── dmedrawsettings.h
    │   │   ├── dmeeditortypedictionary.h
    │   │   ├── dmeexpressionoperator.h
    │   │   ├── dmeeyeball.h
    │   │   ├── dmeeyeposition.h
    │   │   ├── dmefaceset.h
    │   │   ├── dmegamemodel.h
    │   │   ├── dmegamemodelinput.h
    │   │   ├── dmeimage.h
    │   │   ├── dmeinput.h
    │   │   ├── dmejoint.h
    │   │   ├── dmekeyboardinput.h
    │   │   ├── dmelight.h
    │   │   ├── dmelog.h
    │   │   ├── dmemakefile.h
    │   │   ├── dmemakefileutils.h
    │   │   ├── dmematerial.h
    │   │   ├── dmematerialoverlayfxclip.h
    │   │   ├── dmemdl.h
    │   │   ├── dmemdlmakefile.h
    │   │   ├── dmemesh.h
    │   │   ├── dmemodel.h
    │   │   ├── dmemorphoperator.h
    │   │   ├── dmemouseinput.h
    │   │   ├── dmeoperator.h
    │   │   ├── dmepackoperators.h
    │   │   ├── dmeparticlesystemdefinition.h
    │   │   ├── dmephonememapping.h
    │   │   ├── dmeselection.h
    │   │   ├── dmeshader.h
    │   │   ├── dmeshape.h
    │   │   ├── dmesound.h
    │   │   ├── dmetestmesh.h
    │   │   ├── dmetexture.h
    │   │   ├── dmetimeframe.h
    │   │   ├── dmetimeselection.h
    │   │   ├── dmetimeselectiontimes.h
    │   │   ├── dmetrack.h
    │   │   ├── dmetrackgroup.h
    │   │   ├── dmetransform.h
    │   │   ├── dmetransforminput.h
    │   │   ├── dmetransformlist.h
    │   │   ├── dmetransformoperator.h
    │   │   ├── dmeunpackoperators.h
    │   │   ├── dmevertexdata.h
    │   │   ├── dmmeshcomp.h
    │   │   ├── dmmeshutils.h
    │   │   ├── dmobjserializer.h
    │   │   ├── dmsmdserializer.h
    │   │   ├── dmx_to_vcd.h
    │   │   ├── idmemakefileutils.h
    │   │   ├── importintovcd.h
    │   │   ├── movieobjects.cpp
    │   │   ├── movieobjects.h
    │   │   ├── movieobjects_compiletools.cpp
    │   │   ├── proceduralpresets.h
    │   │   └── timeutils.h
    │   ├── mxtk/
    │   │   ├── gl.h
    │   │   ├── mx.h
    │   │   ├── mxbmp.h
    │   │   ├── mxbutton.h
    │   │   ├── mxcheckbox.h
    │   │   ├── mxchoice.h
    │   │   ├── mxchoosecolor.h
    │   │   ├── mxevent.h
    │   │   ├── mxfiledialog.h
    │   │   ├── mxglwindow.h
    │   │   ├── mxgroupbox.h
    │   │   ├── mximage.h
    │   │   ├── mxinit.h
    │   │   ├── mxlabel.h
    │   │   ├── mxlineedit.h
    │   │   ├── mxlinkedlist.h
    │   │   ├── mxlistbox.h
    │   │   ├── mxlistview.h
    │   │   ├── mxmatsyswindow.h
    │   │   ├── mxmenu.h
    │   │   ├── mxmenubar.h
    │   │   ├── mxmessagebox.h
    │   │   ├── mxpath.h
    │   │   ├── mxpcx.h
    │   │   ├── mxpopupmenu.h
    │   │   ├── mxprogressbar.h
    │   │   ├── mxradiobutton.h
    │   │   ├── mxscrollbar.h
    │   │   ├── mxslider.h
    │   │   ├── mxstring.h
    │   │   ├── mxtab.h
    │   │   ├── mxtga.h
    │   │   ├── mxtogglebutton.h
    │   │   ├── mxtooltip.h
    │   │   ├── mxtreeview.h
    │   │   ├── mxwidget.h
    │   │   └── mxwindow.h
    │   ├── openvr/
    │   │   ├── openvr.h
    │   │   └── openvr_capi.h
    │   ├── p4lib/
    │   │   └── ip4.h
    │   ├── panorama/
    │   │   ├── iuiengine.h
    │   │   ├── iuifilesystem.h
    │   │   ├── iuilayoutmanager.h
    │   │   ├── iuipanel.h
    │   │   ├── iuipanelclient.h
    │   │   ├── iuipanelstyle.h
    │   │   ├── iuirenderengine.h
    │   │   ├── iuisoundsystem.h
    │   │   ├── iuistylefactory.h
    │   │   ├── iuiwindow.h
    │   │   ├── panorama.h
    │   │   ├── panoramacurves.h
    │   │   ├── panoramacxx.h
    │   │   ├── panoramasymbol.h
    │   │   ├── panoramatypes.h
    │   │   ├── transformations.h
    │   │   ├── uievent.h
    │   │   ├── uieventcodes.h
    │   │   ├── uievents.h
    │   │   ├── uifileresource.h
    │   │   ├── uijsregistration.h
    │   │   ├── uioverlaybuffersettype.h
    │   │   ├── uipbmsgbase.h
    │   │   ├── uischeduleddel.h
    │   │   ├── uisettings.h
    │   │   ├── uitoplevelwindow.h
    │   │   ├── uitoplevelwindowopenvroverlay.h
    │   │   ├── uitoplevelwindowoverlay.h
    │   │   ├── uiwebapiclient.h
    │   │   ├── vrevents.h
    │   │   ├── controls/
    │   │   │   ├── animatedimagestrip.h
    │   │   │   ├── button.h
    │   │   │   ├── carousel.h
    │   │   │   ├── contextmenu.h
    │   │   │   ├── dropdown.h
    │   │   │   ├── edgescroller.h
    │   │   │   ├── fileopendialog.h
    │   │   │   ├── grid.h
    │   │   │   ├── html.h
    │   │   │   ├── image.h
    │   │   │   ├── label.h
    │   │   │   ├── listsegmentview.h
    │   │   │   ├── mousescroll.h
    │   │   │   ├── movieplayer.h
    │   │   │   ├── panel2d.h
    │   │   │   ├── panelhandle.h
    │   │   │   ├── panelptr.h
    │   │   │   ├── progressbar.h
    │   │   │   ├── slider.h
    │   │   │   ├── slideshow.h
    │   │   │   ├── textentry.h
    │   │   │   ├── tooltip.h
    │   │   │   ├── verticalscrolllist.h
    │   │   │   ├── vumeter.h
    │   │   │   └── source2/
    │   │   │       └── renderpanel.h
    │   │   ├── data/
    │   │   │   ├── iimagesource.h
    │   │   │   ├── imageloader.h
    │   │   │   └── panoramavideoplayer.h
    │   │   ├── input/
    │   │   │   ├── gamepadcodes.h
    │   │   │   ├── iuiinput.h
    │   │   │   ├── keycodes.h
    │   │   │   ├── mousecodes.h
    │   │   │   └── mousecursors.h
    │   │   ├── layout/
    │   │   │   ├── backgroundimage.h
    │   │   │   ├── csshelpers.h
    │   │   │   ├── fillbrush.h
    │   │   │   ├── panel2dfactory.h
    │   │   │   ├── stylefiletypes.h
    │   │   │   ├── stylesymbol.h
    │   │   │   └── uilength.h
    │   │   ├── localization/
    │   │   │   └── ilocalize.h
    │   │   ├── source2/
    │   │   │   └── ipanoramaui.h
    │   │   ├── text/
    │   │   │   └── iuitextlayout.h
    │   │   └── textinput/
    │   │       ├── textinput.h
    │   │       ├── textinput_daisywheel.h
    │   │       ├── textinput_dualtouch.h
    │   │       ├── textinput_fullscreen.h
    │   │       └── textinput_settings.h
    │   ├── particles/
    │   │   └── particles.h
    │   ├── python/
    │   │   └── valvePython/
    │   │       └── valvePython.h
    │   ├── scenefilecache/
    │   │   ├── ISceneFileCache.h
    │   │   └── SceneImageFile.h
    │   ├── sdktoolslib/
    │   │   └── deltautils.h
    │   ├── sfmobjects/
    │   │   ├── exportfacialanimation.h
    │   │   ├── flexcontrolbuilder.h
    │   │   ├── sfmanimationsetutils.h
    │   │   ├── sfmphonemeextractor.h
    │   │   └── sfmsession.h
    │   ├── shaderapi/
    │   │   ├── commandbuffer.h
    │   │   ├── ishaderapi.h
    │   │   ├── IShaderDevice.h
    │   │   ├── ishaderdynamic.h
    │   │   ├── ishadershadow.h
    │   │   ├── ishaderutil.h
    │   │   └── shareddefs.h
    │   ├── shaderlib/
    │   │   ├── BaseShader.h
    │   │   ├── cshader.h
    │   │   └── ShaderDLL.h
    │   ├── socketlib/
    │   │   └── socketlib.h
    │   ├── SoundEmitterSystem/
    │   │   └── isoundemittersystembase.h
    │   ├── soundsystem/
    │   │   ├── isoundsystem.h
    │   │   ├── snd_audio_source.h
    │   │   └── snd_device.h
    │   ├── sourcevr/
    │   │   └── isourcevirtualreality.h
    │   ├── steam/
    │   │   ├── isteamapplist.h
    │   │   ├── isteamapps.h
    │   │   ├── isteamappticket.h
    │   │   ├── isteamclient.h
    │   │   ├── isteamcontroller.h
    │   │   ├── isteamfriends.h
    │   │   ├── isteamgamecoordinator.h
    │   │   ├── isteamgameserver.h
    │   │   ├── isteamgameserverstats.h
    │   │   ├── isteamgamestats.h
    │   │   ├── isteamhtmlsurface.h
    │   │   ├── isteamhttp.h
    │   │   ├── isteaminventory.h
    │   │   ├── isteammasterserverupdater.h
    │   │   ├── isteammatchmaking.h
    │   │   ├── isteammusic.h
    │   │   ├── isteammusicremote.h
    │   │   ├── isteamnetworking.h
    │   │   ├── isteamps3overlayrenderer.h
    │   │   ├── isteamremotestorage.h
    │   │   ├── isteamscreenshots.h
    │   │   ├── isteamstreamlauncher.h
    │   │   ├── isteamugc.h
    │   │   ├── isteamunifiedmessages.h
    │   │   ├── isteamuser.h
    │   │   ├── isteamuserstats.h
    │   │   ├── isteamutils.h
    │   │   ├── isteamvideo.h
    │   │   ├── matchmakingtypes.h
    │   │   ├── steam_api.h
    │   │   ├── steam_api.json
    │   │   ├── steam_api_flat.h
    │   │   ├── steam_gameserver.h
    │   │   ├── steamclientpublic.h
    │   │   ├── steamencryptedappticket.h
    │   │   ├── steamhttpenums.h
    │   │   ├── steamps3params.h
    │   │   ├── steamtypes.h
    │   │   ├── steamuniverse.h
    │   │   ├── steamvr_flat.h
    │   │   └── steamvr_interop.cs
    │   ├── steamnetworkingsockets/
    │   │   ├── isteamnetworkingsockets.h
    │   │   ├── isteamnetworkingutils.h
    │   │   ├── steamdatagram_stats.h
    │   │   ├── steamdatagram_ticketgen.h
    │   │   ├── steamdatagram_tickets.h
    │   │   └── steamnetworkingtypes.h
    │   ├── tier0/
    │   │   ├── afxmem_override.cpp
    │   │   ├── annotations.h
    │   │   ├── basetypes.h
    │   │   ├── commonmacros.h
    │   │   ├── cpumonitoring.h
    │   │   ├── dbg.h
    │   │   ├── dbgflag.h
    │   │   ├── dynfunction.h
    │   │   ├── etwprof.h
    │   │   ├── EventMasks.h
    │   │   ├── EventModes.h
    │   │   ├── fasttimer.h
    │   │   ├── ia32detect.h
    │   │   ├── icommandline.h
    │   │   ├── IOCTLCodes.h
    │   │   ├── K8PerformanceCounters.h
    │   │   ├── l2cache.h
    │   │   ├── mem.h
    │   │   ├── memalloc.h
    │   │   ├── memdbgoff.h
    │   │   ├── memdbgon.h
    │   │   ├── memoverride.cpp
    │   │   ├── memvirt.h
    │   │   ├── minidump.h
    │   │   ├── P4PerformanceCounters.h
    │   │   ├── P5P6PerformanceCounters.h
    │   │   ├── platform.h
    │   │   ├── pmc360.h
    │   │   ├── PMELib.h
    │   │   ├── pointeroverride.asm
    │   │   ├── progressbar.h
    │   │   ├── protected_things.h
    │   │   ├── stacktools.h
    │   │   ├── systeminformation.h
    │   │   ├── testthread.h
    │   │   ├── threadtools.h
    │   │   ├── threadtools.inl
    │   │   ├── tmapi_dummy.h
    │   │   ├── tslist.h
    │   │   ├── type_traits.h
    │   │   ├── validator.h
    │   │   ├── valobject.h
    │   │   ├── valve_minmax_off.h
    │   │   ├── valve_minmax_on.h
    │   │   ├── valve_off.h
    │   │   ├── valve_on.h
    │   │   ├── vcr_shared.h
    │   │   ├── vcrmode.h
    │   │   ├── vprof.h
    │   │   ├── vprof_telemetry.h
    │   │   ├── wchartypes.h
    │   │   └── xbox_codeline_defines.h
    │   ├── tier1/
    │   │   ├── bitbuf.h
    │   │   ├── byteswap.h
    │   │   ├── callqueue.h
    │   │   ├── characterset.h
    │   │   ├── checksum_crc.h
    │   │   ├── checksum_md5.h
    │   │   ├── checksum_sha1.h
    │   │   ├── CommandBuffer.h
    │   │   ├── convar.h
    │   │   ├── convar_serverbounded.h
    │   │   ├── datamanager.h
    │   │   ├── delegates.h
    │   │   ├── diff.h
    │   │   ├── fileio.h
    │   │   ├── fmtstr.h
    │   │   ├── functors.h
    │   │   ├── generichash.h
    │   │   ├── iconvar.h
    │   │   ├── ilocalize.h
    │   │   ├── instancelog.h
    │   │   ├── interface.h
    │   │   ├── KeyValues.h
    │   │   ├── keyvaluesjson.h
    │   │   ├── kvpacker.h
    │   │   ├── lzmaDecoder.h
    │   │   ├── lzss.h
    │   │   ├── memhelpers.h
    │   │   ├── mempool.h
    │   │   ├── memstack.h
    │   │   ├── netadr.h
    │   │   ├── passwordhash.h
    │   │   ├── processor_detect.h
    │   │   ├── rangecheckedvar.h
    │   │   ├── refcount.h
    │   │   ├── reliabletimer.h
    │   │   ├── smartptr.h
    │   │   ├── snappy-sinksource.h
    │   │   ├── snappy-stubs-public.h
    │   │   ├── snappy.h
    │   │   ├── sparsematrix.h
    │   │   ├── stringpool.h
    │   │   ├── strtools.h
    │   │   ├── thash.h
    │   │   ├── tier1.h
    │   │   ├── tokenreader.h
    │   │   ├── uniqueid.h
    │   │   ├── utlallocation.h
    │   │   ├── utlarray.h
    │   │   ├── utlbidirectionalset.h
    │   │   ├── utlbinaryblock.h
    │   │   ├── utlblockmemory.h
    │   │   ├── utlbuffer.h
    │   │   ├── utlbufferutil.h
    │   │   ├── utlcommon.h
    │   │   ├── utldelegate.h
    │   │   ├── utldelegateimpl.h
    │   │   ├── utldict.h
    │   │   ├── utlenvelope.h
    │   │   ├── utlfixedmemory.h
    │   │   ├── utlflags.h
    │   │   ├── utlhandletable.h
    │   │   ├── utlhash.h
    │   │   ├── utlhashdict.h
    │   │   ├── utlhashtable.h
    │   │   ├── utlintrusivelist.h
    │   │   ├── utllinkedlist.h
    │   │   ├── utlmap.h
    │   │   ├── utlmemory.h
    │   │   ├── utlmovingaverage.h
    │   │   ├── utlmultilist.h
    │   │   ├── utlntree.h
    │   │   ├── utlobjectreference.h
    │   │   ├── utlpair.h
    │   │   ├── utlpriorityqueue.h
    │   │   ├── utlqueue.h
    │   │   ├── utlrbtree.h
    │   │   ├── utlsoacontainer.h
    │   │   ├── UtlSortVector.h
    │   │   ├── utlstack.h
    │   │   ├── utlstring.h
    │   │   ├── UtlStringMap.h
    │   │   ├── utlsymbol.h
    │   │   ├── utlsymbollarge.h
    │   │   ├── utltshash.h
    │   │   └── utlvector.h
    │   ├── tier2/
    │   │   ├── beamsegdraw.h
    │   │   ├── camerautils.h
    │   │   ├── fileutils.h
    │   │   ├── keybindings.h
    │   │   ├── keyvaluesmacros.h
    │   │   ├── meshutils.h
    │   │   ├── p4helpers.h
    │   │   ├── renderutils.h
    │   │   ├── riff.h
    │   │   ├── soundutils.h
    │   │   ├── tier2.h
    │   │   ├── tier2dm.h
    │   │   ├── utlstreambuffer.h
    │   │   └── vconfig.h
    │   ├── tier3/
    │   │   ├── choreoutils.h
    │   │   ├── mdlutils.h
    │   │   ├── scenetokenprocessor.h
    │   │   ├── tier3.h
    │   │   └── tier3dm.h
    │   ├── togl/
    │   │   ├── glfuncs.inl
    │   │   ├── rendermechanism.h
    │   │   └── linuxwin/
    │   │       ├── cglmbuffer.h
    │   │       ├── cglmfbo.h
    │   │       ├── cglmprogram.h
    │   │       ├── cglmquery.h
    │   │       ├── cglmtex.h
    │   │       ├── dxabstract.h
    │   │       ├── dxabstract_types.h
    │   │       ├── glbase.h
    │   │       ├── glentrypoints.h
    │   │       ├── glfuncs.h
    │   │       ├── glmdebug.h
    │   │       ├── glmdisplay.h
    │   │       ├── glmdisplaydb.h
    │   │       ├── glmgr.h
    │   │       ├── glmgrbasics.h
    │   │       └── glmgrext.h
    │   ├── togles/
    │   │   ├── glfuncs.inl
    │   │   ├── rendermechanism.h
    │   │   └── linuxwin/
    │   │       ├── cglmbuffer.h
    │   │       ├── cglmfbo.h
    │   │       ├── cglmprogram.h
    │   │       ├── cglmquery.h
    │   │       ├── cglmtex.h
    │   │       ├── dxabstract.h
    │   │       ├── dxabstract_types.h
    │   │       ├── glbase.h
    │   │       ├── glentrypoints.h
    │   │       ├── glfuncs.h
    │   │       ├── glmdebug.h
    │   │       ├── glmdisplay.h
    │   │       ├── glmdisplaydb.h
    │   │       ├── glmgr.h
    │   │       ├── glmgrbasics.h
    │   │       └── glmgrext.h
    │   ├── toolframework/
    │   │   ├── iclientenginetools.h
    │   │   ├── ienginetool.h
    │   │   ├── iserverenginetools.h
    │   │   ├── itooldictionary.h
    │   │   ├── itoolentity.h
    │   │   ├── itoolframework.h
    │   │   ├── itoolsystem.h
    │   │   └── toolframework.cpp
    │   ├── tools/
    │   │   ├── bonelist.cpp
    │   │   └── bonelist.h
    │   ├── toolutils/
    │   │   ├── AttributeElementChoiceList.h
    │   │   ├── basepropertiescontainer.h
    │   │   ├── basestatusbar.h
    │   │   ├── BaseToolSystem.h
    │   │   ├── ConsolePage.h
    │   │   ├── DmeMdlRenderable.h
    │   │   ├── DmeRenderable.h
    │   │   ├── enginetools_int.h
    │   │   ├── miniviewport.h
    │   │   ├── recentfilelist.h
    │   │   ├── savewindowpositions.h
    │   │   ├── ToolEditMenuButton.h
    │   │   ├── ToolFileMenuButton.h
    │   │   ├── ToolHelpMenuButton.h
    │   │   ├── toolmenubar.h
    │   │   ├── ToolMenuButton.h
    │   │   ├── ToolSwitchMenuButton.h
    │   │   ├── toolwindowfactory.h
    │   │   └── vgui_tools.h
    │   ├── unicode/
    │   │   └── unicode.h
    │   ├── unitlib/
    │   │   └── unitlib.h
    │   ├── vaudio/
    │   │   └── ivaudio.h
    │   ├── vgui/
    │   │   ├── Cursor.h
    │   │   ├── Dar.h
    │   │   ├── IBorder.h
    │   │   ├── IClientPanel.h
    │   │   ├── IHTML.h
    │   │   ├── IImage.h
    │   │   ├── IInput.h
    │   │   ├── IInputInternal.h
    │   │   ├── ILocalize.h
    │   │   ├── ipainthtml.h
    │   │   ├── IPanel.h
    │   │   ├── IScheme.h
    │   │   ├── ISurface.h
    │   │   ├── ISurfaceV30.h
    │   │   ├── ISystem.h
    │   │   ├── IVGui.h
    │   │   ├── IVguiMatInfo.h
    │   │   ├── IVguiMatInfoVar.h
    │   │   ├── KeyCode.h
    │   │   ├── keyrepeat.h
    │   │   ├── MouseCode.h
    │   │   ├── Point.h
    │   │   └── VGUI.h
    │   ├── vgui_controls/
    │   │   ├── AnalogBar.h
    │   │   ├── AnimatingImagePanel.h
    │   │   ├── AnimationController.h
    │   │   ├── BitmapImagePanel.h
    │   │   ├── BuildGroup.h
    │   │   ├── BuildModeDialog.h
    │   │   ├── Button.h
    │   │   ├── CheckButton.h
    │   │   ├── CheckButtonList.h
    │   │   ├── CircularProgressBar.h
    │   │   ├── ComboBox.h
    │   │   ├── consoledialog.h
    │   │   ├── ControllerMap.h
    │   │   ├── Controls.h
    │   │   ├── cvartogglecheckbutton.h
    │   │   ├── DialogManager.h
    │   │   ├── DirectorySelectDialog.h
    │   │   ├── Divider.h
    │   │   ├── EditablePanel.h
    │   │   ├── ExpandButton.h
    │   │   ├── FileOpenDialog.h
    │   │   ├── FileOpenStateMachine.h
    │   │   ├── FocusNavGroup.h
    │   │   ├── Frame.h
    │   │   ├── GraphPanel.h
    │   │   ├── HTML.h
    │   │   ├── Image.h
    │   │   ├── ImageList.h
    │   │   ├── ImagePanel.h
    │   │   ├── InputDialog.h
    │   │   ├── KeyBindingHelpDialog.h
    │   │   ├── KeyBindingMap.h
    │   │   ├── KeyBoardEditorDialog.h
    │   │   ├── KeyRepeat.h
    │   │   ├── Label.h
    │   │   ├── ListPanel.h
    │   │   ├── ListViewPanel.h
    │   │   ├── Menu.h
    │   │   ├── MenuBar.h
    │   │   ├── MenuButton.h
    │   │   ├── MenuItem.h
    │   │   ├── MessageBox.h
    │   │   ├── MessageDialog.h
    │   │   ├── MessageMap.h
    │   │   ├── Panel.h
    │   │   ├── PanelAnimationVar.h
    │   │   ├── PanelListPanel.h
    │   │   ├── pch_vgui_controls.h
    │   │   ├── PerforceFileExplorer.h
    │   │   ├── PerforceFileList.h
    │   │   ├── perforcefilelistframe.h
    │   │   ├── PHandle.h
    │   │   ├── ProgressBar.h
    │   │   ├── ProgressBox.h
    │   │   ├── PropertyDialog.h
    │   │   ├── PropertyPage.h
    │   │   ├── PropertySheet.h
    │   │   ├── QueryBox.h
    │   │   ├── RadioButton.h
    │   │   ├── RichText.h
    │   │   ├── RotatingProgressBar.h
    │   │   ├── savedocumentquery.h
    │   │   ├── ScalableImagePanel.h
    │   │   ├── ScrollableEditablePanel.h
    │   │   ├── ScrollBar.h
    │   │   ├── ScrollBarSlider.h
    │   │   ├── SectionedListPanel.h
    │   │   ├── Slider.h
    │   │   ├── Splitter.h
    │   │   ├── subrectimage.h
    │   │   ├── TextEntry.h
    │   │   ├── TextImage.h
    │   │   ├── ToggleButton.h
    │   │   ├── Tooltip.h
    │   │   ├── ToolWindow.h
    │   │   ├── TreeView.h
    │   │   ├── TreeViewListControl.h
    │   │   ├── URLLabel.h
    │   │   ├── vgui_controls.cpp
    │   │   ├── WizardPanel.h
    │   │   └── WizardSubPanel.h
    │   ├── VGuiMatSurface/
    │   │   ├── IMatSystemSurface.h
    │   │   └── IMatSystemSurfaceV5.h
    │   ├── video/
    │   │   └── ivideoservices.h
    │   ├── vphysics/
    │   │   ├── collision_set.h
    │   │   ├── constraints.h
    │   │   ├── friction.h
    │   │   ├── object_hash.h
    │   │   ├── performance.h
    │   │   ├── player_controller.h
    │   │   ├── stats.h
    │   │   ├── vehicles.h
    │   │   └── virtualmesh.h
    │   ├── vpklib/
    │   │   └── packedstore.h
    │   ├── vstdlib/
    │   │   ├── coroutine.h
    │   │   ├── cvar.h
    │   │   ├── IKeyValuesSystem.h
    │   │   ├── iprocessutils.h
    │   │   ├── jobthread.h
    │   │   ├── osversion.h
    │   │   ├── pch_vstdlib.h
    │   │   ├── random.h
    │   │   ├── vcover.h
    │   │   └── vstdlib.h
    │   ├── vtf/
    │   │   └── vtf.h
    │   ├── windowssdk/
    │   │   └── evntprov.h
    │   ├── zip/
    │   │   ├── XUnzip.h
    │   │   └── XZip.h
    │   └── zlib/
    │       ├── zconf.h
    │       └── zlib.h
    ├── raytrace/
    │   ├── raytrace.cpp
    │   ├── raytrace.vpc
    │   ├── trace2.cpp
    │   └── trace3.cpp
    ├── replay/
    │   ├── baserecordingsession.cpp
    │   ├── baserecordingsession.h
    │   ├── baserecordingsessionblock.cpp
    │   ├── baserecordingsessionblock.h
    │   ├── baserecordingsessionblockmanager.cpp
    │   ├── baserecordingsessionblockmanager.h
    │   ├── baserecordingsessionmanager.cpp
    │   ├── baserecordingsessionmanager.h
    │   ├── basethinker.cpp
    │   ├── basethinker.h
    │   ├── cl_commands.cpp
    │   ├── cl_cvars.cpp
    │   ├── cl_downloader.cpp
    │   ├── cl_downloader.h
    │   ├── cl_performance_common.h
    │   ├── cl_performancecontroller.cpp
    │   ├── cl_performancecontroller.h
    │   ├── cl_performancemanager.cpp
    │   ├── cl_performancemanager.h
    │   ├── cl_recordingsession.cpp
    │   ├── cl_recordingsession.h
    │   ├── cl_recordingsessionblock.cpp
    │   ├── cl_recordingsessionblock.h
    │   ├── cl_recordingsessionblockmanager.cpp
    │   ├── cl_recordingsessionblockmanager.h
    │   ├── cl_recordingsessionmanager.cpp
    │   ├── cl_recordingsessionmanager.h
    │   ├── cl_renderqueue.cpp
    │   ├── cl_renderqueue.h
    │   ├── cl_replaycontext.cpp
    │   ├── cl_replaycontext.h
    │   ├── cl_replaymanager.cpp
    │   ├── cl_replaymanager.h
    │   ├── cl_replaymovie.cpp
    │   ├── cl_replaymovie.h
    │   ├── cl_replaymoviemanager.cpp
    │   ├── cl_replaymoviemanager.h
    │   ├── cl_screenshotmanager.cpp
    │   ├── cl_screenshotmanager.h
    │   ├── cl_sessionblockdownloader.cpp
    │   ├── cl_sessionblockdownloader.h
    │   ├── cl_sessioninfodownloader.cpp
    │   ├── cl_sessioninfodownloader.h
    │   ├── compression.cpp
    │   ├── compression.h
    │   ├── errorsystem.cpp
    │   ├── errorsystem.h
    │   ├── genericpersistentmanager.h
    │   ├── ithinker.h
    │   ├── ithinkmanager.h
    │   ├── managertest.cpp
    │   ├── managertest.h
    │   ├── replay.vpc
    │   ├── replay_dbg.cpp
    │   ├── replay_dbg.h
    │   ├── replay_reconstructor.cpp
    │   ├── replay_reconstructor.h
    │   ├── replaysystem.cpp
    │   ├── replaysystem.h
    │   ├── sessioninfoheader.cpp
    │   ├── sessioninfoheader.h
    │   ├── shared_cvars.cpp
    │   ├── shared_replaycontext.cpp
    │   ├── shared_replaycontext.h
    │   ├── spew.cpp
    │   ├── spew.h
    │   ├── sv_basejob.cpp
    │   ├── sv_basejob.h
    │   ├── sv_commands.cpp
    │   ├── sv_cvars.cpp
    │   ├── sv_filepublish.cpp
    │   ├── sv_filepublish.h
    │   ├── sv_fileservercleanup.cpp
    │   ├── sv_fileservercleanup.h
    │   ├── sv_publishtest.cpp
    │   ├── sv_publishtest.h
    │   ├── sv_recordingsession.cpp
    │   ├── sv_recordingsession.h
    │   ├── sv_recordingsessionblock.cpp
    │   ├── sv_recordingsessionblock.h
    │   ├── sv_recordingsessionblockmanager.cpp
    │   ├── sv_recordingsessionblockmanager.h
    │   ├── sv_recordingsessionmanager.cpp
    │   ├── sv_recordingsessionmanager.h
    │   ├── sv_replaycontext.cpp
    │   ├── sv_replaycontext.h
    │   ├── sv_sessionblockpublisher.cpp
    │   ├── sv_sessionblockpublisher.h
    │   ├── sv_sessioninfopublisher.cpp
    │   ├── sv_sessioninfopublisher.h
    │   ├── sv_sessionpublishmanager.cpp
    │   ├── sv_sessionpublishmanager.h
    │   ├── sv_sessionrecorder.cpp
    │   ├── sv_sessionrecorder.h
    │   ├── thinkmanager.cpp
    │   ├── thinkmanager.h
    │   └── common/
    │       ├── basereplayserializeable.cpp
    │       ├── headers.vpc
    │       ├── performance.cpp
    │       ├── replay.cpp
    │       ├── replay_common.vpc
    │       ├── replaylib.cpp
    │       ├── replaytime.cpp
    │       ├── replayutils.cpp
    │       └── screenshot.cpp
    ├── scenefilecache/
    │   ├── SceneFileCache.cpp
    │   ├── scenefilecache.vpc
    │   ├── wscript
    │   └── xbox/
    │       └── xbox.def
    ├── scripts/
    │   ├── build-android-armv7a.sh
    │   ├── build-macos-amd64.sh
    │   ├── build-ubuntu-amd64.sh
    │   ├── build-ubuntu-i386.sh
    │   ├── deploy.sh
    │   ├── tests-macos-amd64.sh
    │   ├── tests-ubuntu-amd64.sh
    │   ├── tests-ubuntu-i386.sh
    │   └── waifulib/
    │       ├── compiler_optimizations.py
    │       ├── conan.py
    │       ├── cxx11.py
    │       ├── enforce_pic.py
    │       ├── force_32bit.py
    │       ├── fwgslib.py
    │       ├── gitversion.py
    │       ├── masm.py
    │       ├── mm_hook.py
    │       ├── msdev.py
    │       ├── msvc_pdb_ext.py
    │       ├── reconfigure.py
    │       ├── sdl2.py
    │       ├── strip_on_install_v2.py
    │       ├── subproject.py
    │       ├── vpc_parser.py
    │       └── xcompile.py
    ├── sdklauncher/
    │   ├── configs.cpp
    │   ├── configs.h
    │   ├── CreateModWizard.cpp
    │   ├── CreateModWizard.h
    │   ├── Main.cpp
    │   ├── min_footprint_files.cpp
    │   ├── min_footprint_files.h
    │   ├── ModConfigsHelper.cpp
    │   ├── ModConfigsHelper.h
    │   ├── ModWizard_CopyFiles.cpp
    │   ├── ModWizard_CopyFiles.h
    │   ├── ModWizard_Finished.cpp
    │   ├── ModWizard_Finished.h
    │   ├── ModWizard_GetModInfo.cpp
    │   ├── ModWizard_GetModInfo.h
    │   ├── ModWizard_Intro.cpp
    │   ├── ModWizard_Intro.h
    │   ├── ModWizard_TemplateOptions.cpp
    │   ├── ModWizard_TemplateOptions.h
    │   ├── resource.h
    │   ├── script1.rc
    │   ├── SDKLauncher.vpc
    │   ├── sdklauncher_main.h
    │   ├── SDKLauncherDialog.cpp
    │   └── SDKLauncherDialog.h
    ├── serverbrowser/
    │   ├── BaseGamesPage.cpp
    │   ├── BaseGamesPage.h
    │   ├── DialogAddServer.cpp
    │   ├── DialogAddServer.h
    │   ├── DialogGameInfo.cpp
    │   ├── DialogGameInfo.h
    │   ├── DialogServerPassword.cpp
    │   ├── DialogServerPassword.h
    │   ├── FavoriteGames.cpp
    │   ├── FavoriteGames.h
    │   ├── HistoryGames.cpp
    │   ├── HistoryGames.h
    │   ├── igamelist.h
    │   ├── InternetGames.cpp
    │   ├── InternetGames.h
    │   ├── LanGames.cpp
    │   ├── LanGames.h
    │   ├── ModList.cpp
    │   ├── ModList.h
    │   ├── pch_serverbrowser.cpp
    │   ├── pch_serverbrowser.h
    │   ├── QuickListPanel.cpp
    │   ├── QuickListPanel.h
    │   ├── resource.h
    │   ├── ServerBrowser.cpp
    │   ├── ServerBrowser.h
    │   ├── ServerBrowser.vpc
    │   ├── ServerBrowserDialog.cpp
    │   ├── ServerBrowserDialog.h
    │   ├── ServerContextMenu.cpp
    │   ├── ServerContextMenu.h
    │   ├── ServerListCompare.cpp
    │   ├── ServerListCompare.h
    │   ├── VACBannedConnRefusedDialog.cpp
    │   ├── VACBannedConnRefusedDialog.h
    │   ├── wscript
    │   ├── unused/
    │   │   ├── BlacklistedServers.cpp
    │   │   ├── BlacklistedServers.h
    │   │   ├── CustomGames.cpp
    │   │   ├── CustomGames.h
    │   │   ├── FriendsGames.cpp
    │   │   ├── FriendsGames.h
    │   │   ├── SpectateGames.cpp
    │   │   └── SpectateGames.h
    │   └── xbox/
    │       └── xbox.def
    ├── sfmobjects/
    │   ├── exportfacialanimation.cpp
    │   ├── flexcontrolbuilder.cpp
    │   ├── sfmanimationsetutils.cpp
    │   ├── sfmobjects.vpc
    │   ├── sfmphonemeextractor.cpp
    │   └── sfmsession.cpp
    ├── soundemittersystem/
    │   ├── cbase.h
    │   ├── soundemittersystem.vpc
    │   ├── soundemittersystembase.cpp
    │   ├── soundemittersystembase.h
    │   ├── wscript
    │   └── xbox/
    │       └── xbox.def
    ├── soundsystem/
    │   ├── snd_audio_source.cpp
    │   ├── snd_dev_wave.cpp
    │   ├── snd_dev_wave.h
    │   ├── snd_io.cpp
    │   ├── snd_wave_mixer.cpp
    │   ├── snd_wave_mixer.h
    │   ├── snd_wave_mixer_adpcm.cpp
    │   ├── snd_wave_mixer_adpcm.h
    │   ├── snd_wave_mixer_private.h
    │   ├── snd_wave_source.cpp
    │   ├── snd_wave_source.h
    │   ├── soundsystem.cpp
    │   ├── soundsystem.h
    │   └── soundsystem.vpc
    ├── sourcevr/
    │   ├── cbase.h
    │   ├── sourcevirtualreality.cpp
    │   ├── sourcevirtualreality.h
    │   ├── sourcevr.vpc
    │   └── stdafx.cpp
    ├── stub_steam/
    │   ├── steam_api.cpp
    │   └── wscript
    ├── studiorender/
    │   ├── flexrenderdata.cpp
    │   ├── flexrenderdata.h
    │   ├── ihvtestcopy.pl
    │   ├── r_studio.cpp
    │   ├── r_studiodecal.cpp
    │   ├── r_studiodraw.cpp
    │   ├── r_studiodraw_computeflexedvertex.cpp
    │   ├── r_studioflex.cpp
    │   ├── r_studiogettriangles.cpp
    │   ├── r_studiolight.cpp
    │   ├── r_studiolight.h
    │   ├── r_studiostats.cpp
    │   ├── studiorender.cpp
    │   ├── studiorender.h
    │   ├── studiorender.vpc
    │   ├── studiorendercontext.cpp
    │   ├── studiorendercontext.h
    │   ├── wscript
    │   └── xbox/
    │       └── xbox.def
    ├── tier0/
    │   ├── assert_dialog.cpp
    │   ├── assert_dialog.rc
    │   ├── commandline.cpp
    │   ├── cpu.cpp
    │   ├── cpu_posix.cpp
    │   ├── cpu_usage.cpp
    │   ├── cpumonitoring.cpp
    │   ├── dbg.cpp
    │   ├── dynfunction.cpp
    │   ├── etwprof.cpp
    │   ├── extendedtrace.cpp
    │   ├── extendedtrace.h
    │   ├── fasttimer.cpp
    │   ├── InterlockedCompareExchange128.masm
    │   ├── mem.cpp
    │   ├── mem_helpers.cpp
    │   ├── mem_helpers.h
    │   ├── mem_impl_type.h
    │   ├── memdbg.cpp
    │   ├── meminit.cpp
    │   ├── memstd.cpp
    │   ├── memstd.h
    │   ├── memvalidate.cpp
    │   ├── minidump.cpp
    │   ├── pch_tier0.cpp
    │   ├── pch_tier0.h
    │   ├── platform.cpp
    │   ├── platform_posix.cpp
    │   ├── pmc360.cpp
    │   ├── pme.cpp
    │   ├── pme_posix.cpp
    │   ├── PMELib.cpp
    │   ├── progressbar.cpp
    │   ├── resource.h
    │   ├── security.cpp
    │   ├── security_linux.cpp
    │   ├── stacktools.cpp
    │   ├── systeminformation.cpp
    │   ├── thread.cpp
    │   ├── threadtools.cpp
    │   ├── tier0.vpc
    │   ├── tier0_exclude.vpc
    │   ├── tier0_staticlink.vpc
    │   ├── tier0_strtools.cpp
    │   ├── tier0_strtools.h
    │   ├── tslist.cpp
    │   ├── validator.cpp
    │   ├── valobject.cpp
    │   ├── valveetwprovider.man
    │   ├── vcrmode.cpp
    │   ├── vcrmode_posix.cpp
    │   ├── vcrmode_xbox.cpp
    │   ├── vprof.cpp
    │   ├── win32consoleio.cpp
    │   ├── wscript
    │   ├── DESKey/
    │   │   ├── ALGO.H
    │   │   ├── ALGO32.LIB
    │   │   ├── DK2WIN32.H
    │   │   └── DK2WIN32.LIB
    │   └── xbox/
    │       ├── xbox_console.cpp
    │       ├── xbox_profile.cpp
    │       ├── xbox_system.cpp
    │       └── xbox_win32stubs.cpp
    ├── tier1/
    │   ├── bitbuf.cpp
    │   ├── byteswap.cpp
    │   ├── characterset.cpp
    │   ├── checksum_crc.cpp
    │   ├── checksum_md5.cpp
    │   ├── checksum_sha1.cpp
    │   ├── commandbuffer.cpp
    │   ├── convar.cpp
    │   ├── datamanager.cpp
    │   ├── diff.cpp
    │   ├── fileio.cpp
    │   ├── generichash.cpp
    │   ├── ilocalize.cpp
    │   ├── interface.cpp
    │   ├── KeyValues.cpp
    │   ├── keyvaluesjson.cpp
    │   ├── kvpacker.cpp
    │   ├── lzmaDecoder.cpp
    │   ├── lzss.cpp
    │   ├── mempool.cpp
    │   ├── memstack.cpp
    │   ├── NetAdr.cpp
    │   ├── newbitbuf.cpp
    │   ├── pathmatch.cpp
    │   ├── pathmatch_casefolding.h
    │   ├── processor_detect.cpp
    │   ├── processor_detect_linux.cpp
    │   ├── qsort_s.cpp
    │   ├── rangecheckedvar.cpp
    │   ├── reliabletimer.cpp
    │   ├── snappy-internal.h
    │   ├── snappy-sinksource.cpp
    │   ├── snappy-stubs-internal.cpp
    │   ├── snappy-stubs-internal.h
    │   ├── snappy.cpp
    │   ├── sparsematrix.cpp
    │   ├── splitstring.cpp
    │   ├── stringpool.cpp
    │   ├── strtools.cpp
    │   ├── strtools_unicode.cpp
    │   ├── tier1.cpp
    │   ├── tier1.vpc
    │   ├── tier1_exclude.vpc
    │   ├── tokenreader.cpp
    │   ├── undiff.cpp
    │   ├── uniqueid.cpp
    │   ├── utlbinaryblock.cpp
    │   ├── utlbuffer.cpp
    │   ├── utlbufferutil.cpp
    │   ├── utlstring.cpp
    │   ├── utlsymbol.cpp
    │   └── wscript
    ├── tier2/
    │   ├── beamsegdraw.cpp
    │   ├── camerautils.cpp
    │   ├── defaultfilesystem.cpp
    │   ├── dmconnect.cpp
    │   ├── fileutils.cpp
    │   ├── keybindings.cpp
    │   ├── keyvaluesmacros.cpp
    │   ├── meshutils.cpp
    │   ├── p4helpers.cpp
    │   ├── renderutils.cpp
    │   ├── riff.cpp
    │   ├── soundutils.cpp
    │   ├── tier2.cpp
    │   ├── tier2.vpc
    │   ├── util_init.cpp
    │   ├── utlstreambuffer.cpp
    │   ├── vconfig.cpp
    │   └── wscript
    ├── tier3/
    │   ├── choreoutils.cpp
    │   ├── mdlutils.cpp
    │   ├── scenetokenprocessor.cpp
    │   ├── studiohdrstub.cpp
    │   ├── tier3.cpp
    │   ├── tier3.vpc
    │   └── wscript
    ├── togl/
    │   ├── togl.vpc
    │   ├── wscript
    │   └── linuxwin/
    │       ├── asanstubs.cpp
    │       ├── cglmbuffer.cpp
    │       ├── cglmfbo.cpp
    │       ├── cglmprogram.cpp
    │       ├── cglmquery.cpp
    │       ├── cglmtex.cpp
    │       ├── dx9asmtogl2.cpp
    │       ├── dx9asmtogl2.h
    │       ├── dxabstract.cpp
    │       ├── glentrypoints.cpp
    │       ├── glmgr.cpp
    │       ├── glmgr_flush.inl
    │       ├── glmgrbasics.cpp
    │       ├── glmgrcocoa.mm
    │       ├── glmtexinlines.h
    │       ├── intelglmallocworkaround.cpp
    │       ├── intelglmallocworkaround.h
    │       ├── mach_override.c
    │       └── mach_override.h
    ├── togles/
    │   ├── togl.vpc
    │   ├── wscript
    │   └── linuxwin/
    │       ├── asanstubs.cpp
    │       ├── cglmbuffer.cpp
    │       ├── cglmfbo.cpp
    │       ├── cglmprogram.cpp
    │       ├── cglmquery.cpp
    │       ├── cglmtex.cpp
    │       ├── decompress.c
    │       ├── decompress.h
    │       ├── dx9asmtogl2.cpp
    │       ├── dx9asmtogl2.h
    │       ├── dxabstract.cpp
    │       ├── glentrypoints.cpp
    │       ├── glmgr.cpp
    │       ├── glmgr_flush.inl
    │       ├── glmgrbasics.cpp
    │       ├── glmgrcocoa.mm
    │       ├── glmtexinlines.h
    │       ├── intelglmallocworkaround.cpp
    │       ├── intelglmallocworkaround.h
    │       ├── mach_override.c
    │       └── mach_override.h
    ├── tools/
    │   ├── actbusy/
    │   │   ├── actbusy.vpc
    │   │   ├── actbusydoc.cpp
    │   │   ├── actbusydoc.h
    │   │   ├── actbusytool.cpp
    │   │   └── actbusytool.h
    │   ├── commedit/
    │   │   ├── commedit.vpc
    │   │   ├── commeditdoc.cpp
    │   │   ├── commeditdoc.h
    │   │   ├── commedittool.cpp
    │   │   ├── commedittool.h
    │   │   ├── commentarynodebrowserpanel.cpp
    │   │   ├── commentarynodebrowserpanel.h
    │   │   ├── commentarypropertiespanel.cpp
    │   │   ├── commentarypropertiespanel.h
    │   │   ├── dmecommentarynodeentity.cpp
    │   │   ├── dmecommentarynodeentity.h
    │   │   └── entityreportpanel.cpp
    │   ├── foundry/
    │   │   ├── DmeVMFEntity.cpp
    │   │   ├── DmeVMFEntity.h
    │   │   ├── entityreportpanel.cpp
    │   │   ├── entityreportpanel.h
    │   │   ├── foundry.vpc
    │   │   ├── foundrydoc.cpp
    │   │   ├── foundrydoc.h
    │   │   ├── foundrytool.cpp
    │   │   └── foundrytool.h
    │   ├── gameevents/
    │   │   ├── gameeventeditdoc.cpp
    │   │   ├── gameeventeditdoc.h
    │   │   ├── gameeventeditpanel.cpp
    │   │   ├── gameeventeditpanel.h
    │   │   ├── gameevents.cpp
    │   │   └── gameevents.vpc
    │   ├── pet/
    │   │   ├── particlesystemdefinitionbrowser.cpp
    │   │   ├── particlesystemdefinitionbrowser.h
    │   │   ├── particlesystempropertiescontainer.cpp
    │   │   ├── particlesystempropertiescontainer.h
    │   │   ├── pet.vpc
    │   │   ├── petdoc.cpp
    │   │   ├── petdoc.h
    │   │   ├── pettool.cpp
    │   │   └── pettool.h
    │   ├── sampletool/
    │   │   ├── cbase.cpp
    │   │   ├── cbase.h
    │   │   ├── sampletool.cpp
    │   │   └── sampletool.vpc
    │   ├── toolutils/
    │   │   ├── attributeelementchoicelist.cpp
    │   │   ├── basepropertiescontainer.cpp
    │   │   ├── basestatusbar.cpp
    │   │   ├── BaseToolSystem.cpp
    │   │   ├── ConsolePage.cpp
    │   │   ├── miniviewport.cpp
    │   │   ├── recentfilelist.cpp
    │   │   ├── savewindowpositions.cpp
    │   │   ├── tool_main.cpp
    │   │   ├── tooleditmenubutton.cpp
    │   │   ├── ToolFileMenuButton.cpp
    │   │   ├── ToolHelpMenuButton.cpp
    │   │   ├── toolmenubar.cpp
    │   │   ├── ToolMenuButton.cpp
    │   │   ├── ToolSwitchMenuButton.cpp
    │   │   ├── ToolUI.cpp
    │   │   ├── ToolUI.h
    │   │   ├── toolutils.vpc
    │   │   └── vgui_tools.cpp
    │   ├── vcdblock/
    │   │   ├── dmevmfentity.cpp
    │   │   ├── dmevmfentity.h
    │   │   ├── infotargetbrowserpanel.cpp
    │   │   ├── infotargetbrowserpanel.h
    │   │   ├── infotargetpropertiespanel.cpp
    │   │   ├── infotargetpropertiespanel.h
    │   │   ├── vcdblock.vpc
    │   │   ├── vcdblockdoc.cpp
    │   │   ├── vcdblockdoc.h
    │   │   ├── vcdblocktool.cpp
    │   │   └── vcdblocktool.h
    │   └── vmt/
    │       ├── vmt.vpc
    │       ├── vmtdoc.cpp
    │       ├── vmtdoc.h
    │       ├── vmttool.cpp
    │       └── vmttool.h
    ├── tracker/
    │   ├── AdminServer/
    │   │   ├── AdminServer.cpp
    │   │   ├── AdminServer.h
    │   │   ├── AdminServer.vpc
    │   │   ├── ban.h
    │   │   ├── BanContextMenu.cpp
    │   │   ├── BanContextMenu.h
    │   │   ├── banlist.cpp
    │   │   ├── banlist.h
    │   │   ├── BanPanel.cpp
    │   │   ├── BanPanel.h
    │   │   ├── BaseGamesPage.cpp
    │   │   ├── BaseGamesPage.h
    │   │   ├── BudgetPanelContainer.cpp
    │   │   ├── BudgetPanelContainer.h
    │   │   ├── ChatContextMenu.h
    │   │   ├── ChatPanel.cpp
    │   │   ├── ChatPanel.h
    │   │   ├── ClickableTabbedPanel.cpp
    │   │   ├── ClickableTabbedPanel.h
    │   │   ├── cmdlist.cpp
    │   │   ├── cmdlist.h
    │   │   ├── ConfigPanel.cpp
    │   │   ├── ConfigPanel.h
    │   │   ├── DialogAddBan.cpp
    │   │   ├── DialogAddBan.h
    │   │   ├── DialogAddServer.cpp
    │   │   ├── DialogAddServer.h
    │   │   ├── DialogCvarChange.cpp
    │   │   ├── DialogCvarChange.h
    │   │   ├── DialogGameInfo.cpp
    │   │   ├── DialogGameInfo.h
    │   │   ├── DialogKickPlayer.cpp
    │   │   ├── DialogKickPlayer.h
    │   │   ├── DialogServerPassword.cpp
    │   │   ├── DialogServerPassword.h
    │   │   ├── FavoriteGames.cpp
    │   │   ├── FavoriteGames.h
    │   │   ├── GamePanelInfo.cpp
    │   │   ├── GamePanelInfo.h
    │   │   ├── GraphPanel.cpp
    │   │   ├── GraphPanel.h
    │   │   ├── HelpText.cpp
    │   │   ├── HelpText.h
    │   │   ├── IManageServer.h
    │   │   ├── Iresponse.h
    │   │   ├── logmsghandler.cpp
    │   │   ├── logmsghandler.h
    │   │   ├── MapCycleEditDialog.cpp
    │   │   ├── MapCycleEditDialog.h
    │   │   ├── maps.h
    │   │   ├── mapslist.cpp
    │   │   ├── mapslist.h
    │   │   ├── MasterMsgHandler.cpp
    │   │   ├── MOTDPanel.cpp
    │   │   ├── MOTDPanel.h
    │   │   ├── Player.h
    │   │   ├── PlayerContextMenu.cpp
    │   │   ├── PlayerContextMenu.h
    │   │   ├── playerlist.cpp
    │   │   ├── playerlist.h
    │   │   ├── PlayerListCompare.cpp
    │   │   ├── PlayerListCompare.h
    │   │   ├── playermsghandler.cpp
    │   │   ├── playermsghandler.h
    │   │   ├── PlayerPanel.cpp
    │   │   ├── PlayerPanel.h
    │   │   ├── point.h
    │   │   ├── RawLogPanel.cpp
    │   │   ├── RawLogPanel.h
    │   │   ├── rcon.cpp
    │   │   ├── rcon.h
    │   │   ├── rconmsghandler.cpp
    │   │   ├── rconmsghandler.h
    │   │   ├── RemoteServer.cpp
    │   │   ├── RemoteServer.h
    │   │   ├── RulesContextMenu.cpp
    │   │   ├── RulesContextMenu.h
    │   │   ├── rulesinfo.cpp
    │   │   ├── rulesinfo.h
    │   │   ├── rulesinfomsghandler.cpp
    │   │   ├── rulesinfomsghandler.h
    │   │   ├── ServerConfigPanel.cpp
    │   │   ├── ServerConfigPanel.h
    │   │   ├── ServerContextMenu.cpp
    │   │   ├── ServerContextMenu.h
    │   │   ├── serverinfo.cpp
    │   │   ├── serverinfo.h
    │   │   ├── serverinfomsghandler.cpp
    │   │   ├── serverinfomsghandler.h
    │   │   ├── serverinfopanel.cpp
    │   │   ├── serverinfopanel.h
    │   │   ├── ServerList.cpp
    │   │   ├── ServerList.h
    │   │   ├── ServerListCompare.cpp
    │   │   ├── ServerListCompare.h
    │   │   ├── serverpage.cpp
    │   │   ├── serverpage.h
    │   │   ├── serverping.cpp
    │   │   ├── serverping.h
    │   │   ├── serverpingmsghandler.cpp
    │   │   ├── serverpingmsghandler.h
    │   │   ├── TokenLine.cpp
    │   │   ├── TokenLine.h
    │   │   ├── VarEditDialog.cpp
    │   │   ├── VarEditDialog.h
    │   │   ├── VarListPropertyPage.cpp
    │   │   └── VarListPropertyPage.h
    │   └── common/
    │       ├── CompletionEvent.cpp
    │       ├── CompletionEvent.h
    │       ├── DebugConsole_Interface.h
    │       ├── DebugTimer.h
    │       ├── IceKey.cpp
    │       ├── IceKey.H
    │       ├── IGameList.h
    │       ├── inetapi.h
    │       ├── IServerRefreshResponse.h
    │       ├── MasterMsgHandler.h
    │       ├── msgbuffer.cpp
    │       ├── msgbuffer.h
    │       ├── netapi.cpp
    │       ├── server.h
    │       ├── Socket.cpp
    │       ├── Socket.h
    │       ├── TrackerMessageFlags.h
    │       ├── TrackerProtocol.h
    │       ├── util.cpp
    │       ├── util.h
    │       ├── UtlMsgBuffer.cpp
    │       └── UtlMsgBuffer.h
    ├── unicode/
    │   ├── unicode.cpp
    │   ├── unicode.vpc
    │   └── wscript
    ├── unitlib/
    │   ├── unitlib.cpp
    │   ├── unitlib.vpc
    │   └── wscript
    ├── unittests/
    │   ├── mathlibtest/
    │   │   ├── mathlib_performance_test.cpp
    │   │   ├── mathlib_test.cpp
    │   │   └── wscript
    │   ├── tier0test/
    │   │   ├── tier0test.cpp
    │   │   ├── tslisttests.cpp
    │   │   └── wscript
    │   ├── tier1test/
    │   │   ├── commandbuffertest.cpp
    │   │   ├── lzsstest.cpp
    │   │   ├── tier1test.cpp
    │   │   ├── tier1test.vpc
    │   │   ├── utlstringtest.cpp
    │   │   └── wscript
    │   ├── tier2test/
    │   │   ├── tier2test.cpp
    │   │   ├── tier2test.vpc
    │   │   └── wscript
    │   └── tier3test/
    │       ├── tier3test.cpp
    │       ├── tier3test.vpc
    │       └── wscript
    ├── utils/
    │   ├── blackmarket/
    │   │   ├── blackmarket.cpp
    │   │   ├── blackmarket.vcproj
    │   │   ├── stdafx.cpp
    │   │   └── stdafx.h
    │   ├── bsppack/
    │   │   ├── bsppack.cpp
    │   │   ├── bsppack.vpc
    │   │   └── xbox/
    │   │       └── xbox.def
    │   ├── bspzip/
    │   │   ├── bspzip.cpp
    │   │   └── bspzip.vpc
    │   ├── bugreporter/
    │   │   ├── bugreporter.cpp
    │   │   └── bugreporter.vpc
    │   ├── bugreporter_filequeue/
    │   │   ├── bugreporter.cpp
    │   │   └── bugreporter_filequeue.vpc
    │   ├── bugreporter_public/
    │   │   ├── bugreporter_public.cpp
    │   │   ├── bugreporter_public.vpc
    │   │   └── bugreporter_upload.cpp
    │   ├── bugreporter_text/
    │   │   ├── bugreporter.cpp
    │   │   └── bugreporter_text.vpc
    │   ├── build_res_list/
    │   │   ├── build_res_list.cpp
    │   │   ├── build_res_list.dsp
    │   │   ├── StdAfx.cpp
    │   │   └── StdAfx.h
    │   ├── bzip2/
    │   │   ├── blocksort.c
    │   │   ├── bzip2.c
    │   │   ├── bzip2.vpc
    │   │   ├── bzlib.c
    │   │   ├── bzlib.h
    │   │   ├── bzlib_private.h
    │   │   ├── compress.c
    │   │   ├── crctable.c
    │   │   ├── decompress.c
    │   │   ├── huffman.c
    │   │   ├── randtable.c
    │   │   └── wscript
    │   ├── captioncompiler/
    │   │   ├── captioncompiler.cpp
    │   │   ├── captioncompiler.vpc
    │   │   └── cbase.h
    │   ├── classcheck/
    │   │   ├── class.cpp
    │   │   ├── class.h
    │   │   ├── classcheck.cpp
    │   │   ├── classcheck.vpc
    │   │   ├── classcheck_util.cpp
    │   │   ├── classcheck_util.h
    │   │   ├── codeprocessor.h
    │   │   ├── icodeprocessor.h
    │   │   ├── processmodule.cpp
    │   │   ├── stdafx.cpp
    │   │   └── stdafx.h
    │   ├── common/
    │   │   ├── bsplib.cpp
    │   │   ├── bsplib.h
    │   │   ├── cmdlib.cpp
    │   │   ├── cmdlib.h
    │   │   ├── consolewnd.cpp
    │   │   ├── consolewnd.h
    │   │   ├── filesystem_tools.cpp
    │   │   ├── filesystem_tools.h
    │   │   ├── ISQLDBReplyTarget.h
    │   │   ├── map_shared.cpp
    │   │   ├── map_shared.h
    │   │   ├── movie.h
    │   │   ├── mpi_stats.cpp
    │   │   ├── mpi_stats.h
    │   │   ├── mstristrip.cpp
    │   │   ├── mstristrip.h
    │   │   ├── MySqlDatabase.cpp
    │   │   ├── MySqlDatabase.h
    │   │   ├── pacifier.cpp
    │   │   ├── pacifier.h
    │   │   ├── physdll.cpp
    │   │   ├── physdll.h
    │   │   ├── polylib.cpp
    │   │   ├── polylib.h
    │   │   ├── qfiles.h
    │   │   ├── scratchpad_helpers.cpp
    │   │   ├── scratchpad_helpers.h
    │   │   ├── scriplib.cpp
    │   │   ├── scriplib.h
    │   │   ├── threads.cpp
    │   │   ├── threads.h
    │   │   ├── tools_minidump.cpp
    │   │   ├── tools_minidump.h
    │   │   ├── utilmatlib.cpp
    │   │   ├── utilmatlib.h
    │   │   ├── vmpi_tools_shared.cpp
    │   │   ├── vmpi_tools_shared.h
    │   │   ├── wadlib.c
    │   │   └── wadlib.h
    │   ├── cubelight/
    │   │   ├── cubelight.cpp
    │   │   └── cubelight.vpc
    │   ├── demoinfo/
    │   │   ├── demoinfo.cpp
    │   │   ├── demoinfo.vcproj
    │   │   ├── demosmoothersamplesource.cpp
    │   │   ├── demosmoothersamplesource.h
    │   │   ├── demosmoothersamplesource.txt
    │   │   ├── tooldemofile.cpp
    │   │   └── tooldemofile.h
    │   ├── depcheck/
    │   │   ├── codeprocessor.h
    │   │   ├── depcheck.cpp
    │   │   ├── depcheck.vpc
    │   │   ├── depcheck_util.cpp
    │   │   ├── depcheck_util.h
    │   │   ├── icodeprocessor.h
    │   │   ├── processmodule.cpp
    │   │   ├── stdafx.cpp
    │   │   └── stdafx.h
    │   ├── dist2alpha/
    │   │   ├── dist2alpha.cpp
    │   │   └── dist2alpha.vpc
    │   ├── dmxconvert/
    │   │   ├── dmxconvert.cpp
    │   │   └── dmxconvert.vpc
    │   ├── dmxedit/
    │   │   ├── dmxedit.cpp
    │   │   ├── dmxedit.h
    │   │   ├── dmxedit.vpc
    │   │   ├── doit.h
    │   │   ├── luamain.cpp
    │   │   └── winstuff.cpp
    │   ├── dumpmatsyshelp/
    │   │   ├── dumpmatsyshelp.cpp
    │   │   └── dumpmatsyshelp.vpc
    │   ├── dx_proxy/
    │   │   ├── dx_proxy.cpp
    │   │   ├── dx_proxy.sln
    │   │   ├── dx_proxy_all.vgc
    │   │   ├── dx_proxy_base.vpc
    │   │   ├── dx_proxy_dx10_v00_pc.vpc
    │   │   ├── dx_proxy_dx9_v00_pc.vpc
    │   │   ├── dx_proxy_dx9_v00_x360.vpc
    │   │   ├── dx_proxy_dx9_v30_pc.vpc
    │   │   ├── dxincludeimpl.h
    │   │   ├── filememcache.cpp
    │   │   └── filememcache.h
    │   ├── dxsupportclean/
    │   │   ├── dxsupportclean.cpp
    │   │   └── dxsupportclean.vpc
    │   ├── elementviewer/
    │   │   ├── elementviewer.cpp
    │   │   ├── elementviewer.h
    │   │   ├── elementviewer.vpc
    │   │   └── elementviewerpanel.cpp
    │   ├── entcount/
    │   │   ├── entcount.cpp
    │   │   └── entcount.vpc
    │   ├── FileSystemOpenDialog/
    │   │   ├── FileDialogApp.cpp
    │   │   ├── FileDialogApp.h
    │   │   ├── FileSystemOpenDialog.rc
    │   │   ├── filesystemopendialog.vpc
    │   │   ├── FileSystemOpenDlg.cpp
    │   │   ├── FileSystemOpenDlg.h
    │   │   ├── resource.h
    │   │   ├── StdAfx.cpp
    │   │   ├── StdAfx.h
    │   │   └── res/
    │   │       └── SteamFileDialog.rc2
    │   ├── finddbgdll/
    │   │   ├── finddbgdll.cpp
    │   │   └── finddbgdll.vpc
    │   ├── gamestats_reader/
    │   │   ├── dod_gamestats.h
    │   │   ├── gamestats_reader.cpp
    │   │   └── gamestats_reader.vpc
    │   ├── genrandomvectors/
    │   │   ├── genrandomvectors.cpp
    │   │   └── genrandomvectors.vpc
    │   ├── getbugs/
    │   │   ├── getbugs.cpp
    │   │   └── getbugs.vpc
    │   ├── glview/
    │   │   ├── glos.h
    │   │   ├── glview.cpp
    │   │   └── glview.vpc
    │   ├── height2normal/
    │   │   ├── height2normal.cpp
    │   │   └── height2normal.vpc
    │   ├── height2ssbump/
    │   │   ├── height2ssbump.cpp
    │   │   └── height2ssbump.vpc
    │   ├── hlfaceposer/
    │   │   ├── actorproperties.cpp
    │   │   ├── actorproperties.h
    │   │   ├── addsoundentry.cpp
    │   │   ├── addsoundentry.h
    │   │   ├── AnimationBrowser.cpp
    │   │   ├── AnimationBrowser.h
    │   │   ├── audiowaveoutput.h
    │   │   ├── basedialogparams.cpp
    │   │   ├── basedialogparams.h
    │   │   ├── cbase.h
    │   │   ├── cclookup.cpp
    │   │   ├── cclookup.h
    │   │   ├── channelproperties.cpp
    │   │   ├── channelproperties.h
    │   │   ├── choiceproperties.cpp
    │   │   ├── choiceproperties.h
    │   │   ├── choreoactorwidget.cpp
    │   │   ├── choreoactorwidget.h
    │   │   ├── choreochannelwidget.cpp
    │   │   ├── choreochannelwidget.h
    │   │   ├── choreoeventwidget.cpp
    │   │   ├── choreoeventwidget.h
    │   │   ├── choreoglobaleventwidget.cpp
    │   │   ├── choreoglobaleventwidget.h
    │   │   ├── choreoview.h
    │   │   ├── choreoviewcolors.h
    │   │   ├── choreowidget.cpp
    │   │   ├── choreowidget.h
    │   │   ├── choreowidgetdrawhelper.cpp
    │   │   ├── choreowidgetdrawhelper.h
    │   │   ├── CloseCaptionTool.cpp
    │   │   ├── CloseCaptionTool.h
    │   │   ├── controlpanel.cpp
    │   │   ├── controlpanel.h
    │   │   ├── curveeditorhelpers.h
    │   │   ├── EdgeProperties.cpp
    │   │   ├── EdgeProperties.h
    │   │   ├── EditPhrase.cpp
    │   │   ├── EditPhrase.h
    │   │   ├── eventproperties.cpp
    │   │   ├── eventproperties.h
    │   │   ├── eventproperties_expression.cpp
    │   │   ├── eventproperties_expression.h
    │   │   ├── eventproperties_face.cpp
    │   │   ├── eventproperties_face.h
    │   │   ├── eventproperties_firetrigger.cpp
    │   │   ├── eventproperties_firetrigger.h
    │   │   ├── eventproperties_flexanimation.cpp
    │   │   ├── eventproperties_flexanimation.h
    │   │   ├── eventproperties_generic.cpp
    │   │   ├── eventproperties_generic.h
    │   │   ├── eventproperties_gesture.cpp
    │   │   ├── eventproperties_gesture.h
    │   │   ├── eventproperties_interrupt.cpp
    │   │   ├── eventproperties_interrupt.h
    │   │   ├── eventproperties_lookat.cpp
    │   │   ├── eventproperties_lookat.h
    │   │   ├── eventproperties_moveto.cpp
    │   │   ├── eventproperties_moveto.h
    │   │   ├── eventproperties_permitresponses.cpp
    │   │   ├── eventproperties_permitresponses.h
    │   │   ├── eventproperties_sequence.cpp
    │   │   ├── eventproperties_sequence.h
    │   │   ├── eventproperties_speak.cpp
    │   │   ├── eventproperties_speak.h
    │   │   ├── eventproperties_subscene.cpp
    │   │   ├── eventproperties_subscene.h
    │   │   ├── expclass.cpp
    │   │   ├── expclass.h
    │   │   ├── expression.cpp
    │   │   ├── expression.h
    │   │   ├── expressionproperties.cpp
    │   │   ├── expressionproperties.h
    │   │   ├── expressions.cpp
    │   │   ├── expressions.h
    │   │   ├── expressiontool.cpp
    │   │   ├── expressiontool.h
    │   │   ├── faceposer_models.cpp
    │   │   ├── faceposer_models.h
    │   │   ├── faceposer_vgui.cpp
    │   │   ├── faceposer_vgui.h
    │   │   ├── faceposertoolwindow.cpp
    │   │   ├── faceposertoolwindow.h
    │   │   ├── faceposerworkspace.cpp
    │   │   ├── fileloaderthread.cpp
    │   │   ├── flexpanel.cpp
    │   │   ├── flexpanel.h
    │   │   ├── GestureTool.cpp
    │   │   ├── GestureTool.h
    │   │   ├── globaleventproperties.cpp
    │   │   ├── globaleventproperties.h
    │   │   ├── hlfaceposer.cpp
    │   │   ├── hlfaceposer.h
    │   │   ├── hlfaceposer.rc
    │   │   ├── hlfaceposer.vpc
    │   │   ├── ICloseCaptionManager.h
    │   │   ├── ifaceposersound.h
    │   │   ├── ifaceposerworkspace.h
    │   │   ├── ifileloader.h
    │   │   ├── inputproperties.cpp
    │   │   ├── inputproperties.h
    │   │   ├── mapentities.h
    │   │   ├── matsyswin.cpp
    │   │   ├── matsyswin.h
    │   │   ├── mdlviewer.cpp
    │   │   ├── mdlviewer.h
    │   │   ├── mxbitmapbutton.cpp
    │   │   ├── mxbitmapbutton.h
    │   │   ├── mxbitmaptools.cpp
    │   │   ├── mxbitmaptools.h
    │   │   ├── mxbitmapwindow.cpp
    │   │   ├── mxbitmapwindow.h
    │   │   ├── mxexpressionslider.cpp
    │   │   ├── mxexpressionslider.h
    │   │   ├── mxexpressiontab.cpp
    │   │   ├── mxexpressiontab.h
    │   │   ├── mxexpressiontray.cpp
    │   │   ├── mxexpressiontray.h
    │   │   ├── mxstatuswindow.cpp
    │   │   ├── mxstatuswindow.h
    │   │   ├── phonemeeditor.cpp
    │   │   ├── phonemeeditor.h
    │   │   ├── phonemeeditorcolors.h
    │   │   ├── phonemeproperties.cpp
    │   │   ├── phonemeproperties.h
    │   │   ├── ProgressDialog.cpp
    │   │   ├── ProgressDialog.h
    │   │   ├── RampTool.cpp
    │   │   ├── RampTool.h
    │   │   ├── resource.h
    │   │   ├── SceneRampTool.cpp
    │   │   ├── SceneRampTool.h
    │   │   ├── snd_audio_source.cpp
    │   │   ├── snd_audio_source.h
    │   │   ├── snd_wave_mixer.cpp
    │   │   ├── snd_wave_mixer.h
    │   │   ├── snd_wave_mixer_adpcm.cpp
    │   │   ├── snd_wave_mixer_adpcm.h
    │   │   ├── snd_wave_mixer_private.h
    │   │   ├── snd_wave_source.cpp
    │   │   ├── snd_wave_source.h
    │   │   ├── sound.cpp
    │   │   ├── sound.h
    │   │   ├── soundlookup.cpp
    │   │   ├── soundlookup.h
    │   │   ├── tabwindow.cpp
    │   │   ├── tabwindow.h
    │   │   ├── timelineitem.cpp
    │   │   ├── timelineitem.h
    │   │   ├── vcdbrowser.cpp
    │   │   ├── vcdbrowser.h
    │   │   ├── VGuiWnd.cpp
    │   │   ├── VGuiWnd.h
    │   │   ├── wavebrowser.cpp
    │   │   ├── wavebrowser.h
    │   │   ├── wavefile.cpp
    │   │   └── wavefile.h
    │   ├── hlmv/
    │   │   ├── anorms.h
    │   │   ├── attachments_window.cpp
    │   │   ├── attachments_window.h
    │   │   ├── controlpanel.cpp
    │   │   ├── controlpanel.h
    │   │   ├── debugdrawmodel.cpp
    │   │   ├── debugdrawmodel.h
    │   │   ├── fileassociation.cpp
    │   │   ├── fileassociation.h
    │   │   └── hlmv.rc
    │   ├── QCGenerator/
    │   │   ├── CQCGenMain.cpp
    │   │   ├── CQCGenMain.h
    │   │   ├── main.cpp
    │   │   ├── QCGenerator.h
    │   │   └── qcgenerator_launcher.vpc
    │   ├── SteamDebugHelper/
    │   │   ├── DebugSourceBeta.cfg
    │   │   ├── resource.h
    │   │   ├── StdAfx.cpp
    │   │   ├── StdAfx.h
    │   │   ├── SteamDebugHelper.cpp
    │   │   ├── SteamDebugHelper.h
    │   │   ├── SteamDebugHelper.rc
    │   │   ├── SteamDebugHelper.vcproj
    │   │   ├── SteamDebugHelperDlg.cpp
    │   │   ├── SteamDebugHelperDlg.h
    │   │   └── res/
    │   │       └── SteamDebugHelper.rc2
    │   └── Texturesynth/
    │       ├── texturesynth.vpc
    │       └── tsynth.cpp
    └── .github/
        └── workflows/
            ├── build.yml
            └── tests.yml


(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# Source Engine
[![GitHub Actions Status](https://github.com/nillerusr/source-engine/actions/workflows/build.yml/badge.svg)](https://github.com/nillerusr/source-engine/actions/workflows/build.yml) [![GitHub Actions Status](https://github.com/nillerusr/source-engine/actions/workflows/tests.yml/badge.svg)](https://github.com/nillerusr/source-engine/actions/workflows/tests.yml)
 Discord: [![Discord Server](https://img.shields.io/discord/672055862608658432.svg)](https://discord.gg/hZRB7WMgGw)
 

Information from [wikipedia](https://wikipedia.org/wiki/Source_(game_engine)):

Source is a 3D game engine developed by Valve.
It debuted as the successor to GoldSrc with Half-Life: Source in June 2004,
followed by Counter-Strike: Source and Half-Life 2 later that year.
Source does not have a concise version numbering scheme; instead, it was released in incremental versions

Source code is based on TF2 2018 leak. Don't use it for commercial purposes.

This project is using waf buildsystem. If you have waf-related questions look https://waf.io/book

# Features:
- Android, OSX, FreeBSD, Windows, Linux( glibc, musl ) support
- Arm support( except windows )
- 64bit support
- Modern toolchains support
- Fixed many undefined behaviours
- Touch support( even on windows/linux/osx )
- VTF 7.5 support
- PBR support
- bsp v19-v21 support( bsp v21 support is partial, portal 2 and csgo maps works fine )
- mdl v46-49 support
- Removed useless/unnecessary dependencies
- Achivement system working without steam
- Fixed many bugs
- Serverbrowser works without steam

# Current tasks
- Rewrite materialsystem for OpenGL render
- dxvk-native support
- Elbrus port
- Bink audio support( for video_bink )

# How to Build?
- [Building instructions(EN)](https://github.com/nillerusr/source-engine/wiki/Source-Engine-(EN))
- [Building instructions(RU)](https://github.com/nillerusr/source-engine/wiki/Source-Engine-(RU))

# Support me
BTC: `bc1qnjq92jj9uqjtafcx2zvnwd48q89hgtd6w8a6na`

ETH: `0x5d0D561146Ed758D266E59B56e85Af0b03ABAF46`

XMR: `48iXvX61MU24m5VGc77rXQYKmoww3dZh6hn7mEwDaLVTfGhyBKq2teoPpeBq6xvqj4itsGh6EzNTzBty6ZDDevApCFNpsJ`



================================================
FILE: LICENSE
================================================
[Binary file]


================================================
FILE: thirdpartylegalnotices.txt
================================================
[Binary file]


================================================
FILE: app/legion/basemenu.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Base class menus should all inherit from 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "basemenu.h"
#include "menumanager.h"
#include <ctype.h>
#include "vgui/iinput.h"


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
CBaseMenu::CBaseMenu( vgui::Panel *pParent, const char *pPanelName ) :
	BaseClass( pParent, pPanelName )
{
	SetKeyBoardInputEnabled( true );
	SetMouseInputEnabled( true );
	SetSizeable( false );
	SetMoveable( false );
}

CBaseMenu::~CBaseMenu()
{
}


void CBaseMenu::OnKeyCodeTyped( vgui::KeyCode code )
{
	BaseClass::OnKeyCodeTyped( code );

	bool shift = (vgui::input()->IsKeyDown(vgui::KEY_LSHIFT) || vgui::input()->IsKeyDown(vgui::KEY_RSHIFT));
	bool ctrl = (vgui::input()->IsKeyDown(vgui::KEY_LCONTROL) || vgui::input()->IsKeyDown(vgui::KEY_RCONTROL));
	bool alt = (vgui::input()->IsKeyDown(vgui::KEY_LALT) || vgui::input()->IsKeyDown(vgui::KEY_RALT));
	
	if ( ctrl && shift && alt && code == vgui::KEY_B)
	{
		// enable build mode
		ActivateBuildMode();
	}

}
	
//-----------------------------------------------------------------------------
// Commands
//-----------------------------------------------------------------------------
void CBaseMenu::OnCommand( const char *pCommand )
{
	if ( !Q_stricmp( pCommand, "quit" ) )
	{
		IGameManager::Stop();
		return;
	}

	if ( !Q_stricmp( pCommand, "popmenu" ) )
	{
		g_pMenuManager->PopMenu();
		return;
	}

	if ( !Q_stricmp( pCommand, "popallmenus" ) )
	{
		g_pMenuManager->PopAllMenus();
		return;
	}

	if ( !Q_strnicmp( pCommand, "pushmenu ", 9 ) )
	{
		const char *pMenuName = pCommand + 9;
		while( isspace(*pMenuName) )
		{
			++pMenuName;
		}
		g_pMenuManager->PushMenu( pMenuName );
		return;
	}

	if ( !Q_strnicmp( pCommand, "switchmenu ", 11 ) )
	{
		const char *pMenuName = pCommand + 11;
		while( isspace(*pMenuName) )
		{
			++pMenuName;
		}
		g_pMenuManager->SwitchToMenu( pMenuName );
		return;
	}

	BaseClass::OnCommand( pCommand );
}




================================================
FILE: app/legion/basemenu.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Base class menus should all inherit from 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef BASEMENU_H
#define BASEMENU_H

#ifdef _WIN32
#pragma once
#endif

#include "vgui_controls/frame.h"
#include "vgui/keycode.h"


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
class CBaseMenu : public vgui::Frame
{
	DECLARE_CLASS_SIMPLE( CBaseMenu, vgui::Frame );

public:
	CBaseMenu( vgui::Panel *pParent, const char *pPanelName );
	virtual ~CBaseMenu();

	// Commands
	virtual void OnCommand( const char *pCommand );
	virtual void OnKeyCodeTyped( vgui::KeyCode code );

private:
};

#endif // BASEMENU_H




================================================
FILE: app/legion/gamemanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: List of game managers to update  
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "gamemanager.h"
#include "tier0/icommandline.h"

// FIXME: REMOVE (for Sleep)
#include <windows.h>


//-----------------------------------------------------------------------------
// globals
//-----------------------------------------------------------------------------
int IGameManager::m_nFrameNumber = 0;
bool IGameManager::m_bStopRequested = false;
bool IGameManager::m_bIsRunning = false;
bool IGameManager::m_bIsInitialized = false;
bool IGameManager::m_bLevelStartRequested = false;
bool IGameManager::m_bLevelShutdownRequested = false;
float IGameManager::m_flCurrentTime = 0.0f;
float IGameManager::m_flLastTime = 0.0f;
LevelState_t IGameManager::m_LevelState = NOT_IN_LEVEL;

CUtlVector< IGameManager* > IGameManager::m_GameManagers;


//-----------------------------------------------------------------------------
// Adds a system to the list of systems to run
//-----------------------------------------------------------------------------
void IGameManager::Add( IGameManager* pSys )
{
	Assert( !m_bIsRunning );
	m_GameManagers.AddToTail( pSys );
}


//-----------------------------------------------------------------------------
// Removes a system from the list of systems to update
//-----------------------------------------------------------------------------
void IGameManager::Remove( IGameManager* pSys )
{
	Assert( !m_bIsRunning );
	m_GameManagers.FindAndRemove( pSys );
}


//-----------------------------------------------------------------------------
// Removes *all* systems from the list of systems to update
//-----------------------------------------------------------------------------
void IGameManager::RemoveAll( )
{
	m_GameManagers.RemoveAll();
}


//-----------------------------------------------------------------------------
// Invokes a method on all installed game systems in proper order
//-----------------------------------------------------------------------------
void IGameManager::InvokeMethod( GameManagerFunc_t f )
{
	int i;
	int nCount = m_GameManagers.Count();
	for ( i = 0; i < nCount; ++i )
	{
		(m_GameManagers[i]->*f)();
	}
}

void IGameManager::InvokeMethodReverseOrder( GameManagerFunc_t f )
{
	int i;
	int nCount = m_GameManagers.Count();
	for ( i = nCount; --i >= 0; )
	{
		(m_GameManagers[i]->*f)();
	}
}

bool IGameManager::InvokeMethod( GameManagerInitFunc_t f )
{
	int i;
	int nCount = m_GameManagers.Count();
	for ( i = 0; i < nCount; ++i )
	{
		if ( !(m_GameManagers[i]->*f)() )
			return false;
	}
	return true;
}

LevelRetVal_t IGameManager::InvokeLevelMethod( GameManagerLevelFunc_t f, bool bFirstCall )
{
	LevelRetVal_t nRetVal = FINISHED;
	int i;
	int nCount = m_GameManagers.Count();
	for ( i = 0; i < nCount; ++i )
	{
		LevelRetVal_t val = (m_GameManagers[i]->*f)( bFirstCall );
		if ( val == FAILED )
			return FAILED;
		if ( val == MORE_WORK )
		{
			nRetVal = MORE_WORK;
		}
	}
	return nRetVal;
}

LevelRetVal_t IGameManager::InvokeLevelMethodReverseOrder( GameManagerLevelFunc_t f, bool bFirstCall )
{
	LevelRetVal_t nRetVal = FINISHED;
	int i;
	int nCount = m_GameManagers.Count();
	for ( i = 0; i < nCount; ++i )
	{
		LevelRetVal_t val = ( m_GameManagers[i]->*f )( bFirstCall );
		if ( val == FAILED )
		{
			nRetVal = FAILED;
		}
		if ( ( val == MORE_WORK ) && ( nRetVal != FAILED ) )
		{
			nRetVal = MORE_WORK;
		}
	}
	return nRetVal;
}


//-----------------------------------------------------------------------------
// Init, shutdown game system
//-----------------------------------------------------------------------------
bool IGameManager::InitAllManagers()
{
	m_nFrameNumber = 0;
	if ( !InvokeMethod( &IGameManager::Init ) )
		return false;

	m_bIsInitialized = true;
	return true;
}

void IGameManager::ShutdownAllManagers()
{
	if ( m_bIsInitialized )
	{
		InvokeMethodReverseOrder( &IGameManager::Shutdown );
		m_bIsInitialized = false;
	}
}


//-----------------------------------------------------------------------------
// Updates the state machine related to loading levels
//-----------------------------------------------------------------------------
void IGameManager::UpdateLevelStateMachine()
{
	// Do we want to switch into the level shutdown state?
	bool bFirstLevelShutdownFrame = false;
	if ( m_bLevelShutdownRequested )
	{
		if ( m_LevelState != LOADING_LEVEL )
		{
			m_bLevelShutdownRequested = false;
		}
		if ( m_LevelState == IN_LEVEL )
		{
			m_LevelState = SHUTTING_DOWN_LEVEL;
			bFirstLevelShutdownFrame = true;
		}
	}

	// Perform level shutdown
	if ( m_LevelState == SHUTTING_DOWN_LEVEL )
	{
		LevelRetVal_t val = InvokeLevelMethodReverseOrder( &IGameManager::LevelShutdown, bFirstLevelShutdownFrame );
		if ( val != MORE_WORK )
		{
			m_LevelState = NOT_IN_LEVEL;
		}
	}

	// Do we want to switch into the level startup state?
	bool bFirstLevelStartFrame = false;
	if ( m_bLevelStartRequested )
	{
		if ( m_LevelState != SHUTTING_DOWN_LEVEL )
		{
			m_bLevelStartRequested = false;
		}
		if ( m_LevelState == NOT_IN_LEVEL )
		{
			m_LevelState = LOADING_LEVEL;
			bFirstLevelStartFrame = true;
		}
	}

	// Perform level load
	if ( m_LevelState == LOADING_LEVEL )
	{
		LevelRetVal_t val = InvokeLevelMethod( &IGameManager::LevelInit, bFirstLevelStartFrame );
		if ( val == FAILED )
		{
			m_LevelState = NOT_IN_LEVEL;
		}
		else if ( val == FINISHED )
		{
			m_LevelState = IN_LEVEL;
		}
	}
}


//-----------------------------------------------------------------------------
// Runs the main loop.
//-----------------------------------------------------------------------------
void IGameManager::Start()
{
	Assert( !m_bIsRunning && m_bIsInitialized );

	m_bIsRunning = true;
	m_bStopRequested = false;

	// This option is useful when running the app twice on the same machine
	// It makes the 2nd instance of the app run a lot faster
	bool bPlayNice = ( CommandLine()->CheckParm( "-yieldcycles" ) != 0 );

	float flStartTime = m_flCurrentTime = m_flLastTime = Plat_FloatTime();
	int nFramesSimulated = 0;
	int nCount = m_GameManagers.Count();
	while ( !m_bStopRequested )
	{
		UpdateLevelStateMachine();

		m_flLastTime = m_flCurrentTime;
		m_flCurrentTime = Plat_FloatTime();
		int nSimulationFramesNeeded = 1 + (int)( ( m_flCurrentTime - flStartTime ) / TICK_INTERVAL );
		while( nSimulationFramesNeeded > nFramesSimulated )
		{
			for ( int i = 0; i < nCount; ++i )
			{
				if ( m_GameManagers[i]->PerformsSimulation() )
				{
					m_GameManagers[i]->Update();
				}
			}
			++m_nFrameNumber;
			++nFramesSimulated;
		}

		// Always do I/O related managers regardless of framerate
		for ( int i = 0; i < nCount; ++i )
		{
			if ( !m_GameManagers[i]->PerformsSimulation() )
			{
				m_GameManagers[i]->Update();
			}
		}

		if ( bPlayNice )
		{
			Sleep( 1 );
		}
	}

	m_bIsRunning = false;
}


//-----------------------------------------------------------------------------
// Stops the main loop at the next appropriate time
//-----------------------------------------------------------------------------
void IGameManager::Stop()
{
	if ( m_bIsRunning )
	{
		m_bStopRequested = true;
	}
}


//-----------------------------------------------------------------------------
// Returns the current frame number
//-----------------------------------------------------------------------------
int IGameManager::FrameNumber()
{
	return m_nFrameNumber;
}

float IGameManager::CurrentSimulationTime()
{
	return m_nFrameNumber * TICK_INTERVAL;
}

float IGameManager::SimulationDeltaTime()
{
	return TICK_INTERVAL;
}


//-----------------------------------------------------------------------------
// Used in rendering
//-----------------------------------------------------------------------------
float IGameManager::CurrentTime()
{
	return m_flCurrentTime;
}

float IGameManager::DeltaTime()
{
	return m_flCurrentTime - m_flLastTime;
}


//-----------------------------------------------------------------------------
// Returns the current level state
//-----------------------------------------------------------------------------
LevelState_t IGameManager::GetLevelState()
{
	return m_LevelState;
}


//-----------------------------------------------------------------------------
// Start loading a level
//-----------------------------------------------------------------------------
void IGameManager::StartNewLevel()
{
	m_bLevelShutdownRequested = true;
	m_bLevelStartRequested = true;
}

void IGameManager::ShutdownLevel()
{
	m_bLevelShutdownRequested = true;
}




================================================
FILE: app/legion/gamemanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
// $NoKeywords: $
//===========================================================================//

#ifndef GAMEMANAGER_H
#define GAMEMANAGER_H
#ifdef _WIN32
#pragma once
#endif

#include "tier1/utlvector.h"


//-----------------------------------------------------------------------------
// State we are in
//-----------------------------------------------------------------------------
enum LevelState_t
{
	NOT_IN_LEVEL = 0,
	LOADING_LEVEL,
	IN_LEVEL,
	SHUTTING_DOWN_LEVEL,
};


//-----------------------------------------------------------------------------
// State we are in
//-----------------------------------------------------------------------------
enum LevelRetVal_t
{
	FAILED = 0,
	MORE_WORK,
	FINISHED,
};


//-----------------------------------------------------------------------------
// Tick interval
//-----------------------------------------------------------------------------
#define TICK_INTERVAL	0.015f


//-----------------------------------------------------------------------------
// Game managers are singleton objects in the game code responsible for various tasks
// The order in which the server systems appear in this list are the
// order in which they are initialized and updated. They are shut down in
// reverse order from which they are initialized.
//-----------------------------------------------------------------------------
abstract_class IGameManager
{
public:
	// GameManagers are expected to implement these methods.
	virtual bool Init() = 0;
	virtual LevelRetVal_t LevelInit( bool bFirstCall ) = 0;
	virtual void Update( ) = 0;
	virtual LevelRetVal_t LevelShutdown( bool bFirstCall ) = 0;
	virtual void Shutdown() = 0;
	
	// Called during game save
	virtual void OnSave() = 0;

	// Called during game restore
	virtual void OnRestore() = 0;

	// This this game manager involved in I/O or simulation?
	virtual bool PerformsSimulation() = 0;

	// Add, remove game managers
	static void Add( IGameManager* pSys );
	static void Remove( IGameManager* pSys );
	static void RemoveAll( );

	// Init, shutdown game managers
	static bool InitAllManagers();
	static void ShutdownAllManagers();

	// Start, stop running game managers
	static void Start ();
	static void Stop ();
	static int FrameNumber();

	// Used in simulation
	static float CurrentSimulationTime();
	static float SimulationDeltaTime();

	// Used in rendering
	static float CurrentTime();
	static float DeltaTime();

	// Start loading a level
	static void StartNewLevel();
	static void ShutdownLevel();
	static LevelState_t GetLevelState();

protected:
	// Updates the state machine related to loading levels
	static void UpdateLevelStateMachine();	 

	virtual ~IGameManager() {}

	typedef LevelRetVal_t (IGameManager::*GameManagerLevelFunc_t)( bool bFirstCall );
	typedef bool (IGameManager::*GameManagerInitFunc_t)();
	typedef void (IGameManager::*GameManagerFunc_t)();

	// Used to invoke a method of all added game managers in order
	static void InvokeMethod( GameManagerFunc_t f );
	static void InvokeMethodReverseOrder( GameManagerFunc_t f );
	static bool InvokeMethod( GameManagerInitFunc_t f );
	static LevelRetVal_t InvokeLevelMethod( GameManagerLevelFunc_t f, bool bFirstCall );
	static LevelRetVal_t InvokeLevelMethodReverseOrder( GameManagerLevelFunc_t f, bool bFirstCall );

	static bool m_bLevelShutdownRequested;
	static bool m_bLevelStartRequested;
	static bool m_bStopRequested;
	static CUtlVector< IGameManager* > m_GameManagers;
	static bool m_bIsRunning;
	static bool m_bIsInitialized;
	static int  m_nFrameNumber;
	static float m_flCurrentTime;
	static float m_flLastTime;
	static LevelState_t m_LevelState;
};


//-----------------------------------------------------------------------------
// Default decorator base-class for IGameManager
//-----------------------------------------------------------------------------
template< class BaseClass = IGameManager >
class CGameManager : public BaseClass
{
public:
	virtual ~CGameManager();

	// GameManagers are expected to implement these methods.
	// NOTE: If Init or LevelInit fail, they are expected to call 
	virtual bool Init() { return true; }
	virtual LevelRetVal_t LevelInit( bool bFirstCall ) { return FINISHED; }
	virtual void Update( ) {}
	virtual LevelRetVal_t LevelShutdown( bool bFirstCall ) { return FINISHED; }
	virtual void Shutdown() {}
	virtual void OnSave() {}
	virtual void OnRestore() {}
	virtual bool PerformsSimulation() { return false; }
};


//-----------------------------------------------------------------------------
// Automatically remove the game system if it gets deleted.
//-----------------------------------------------------------------------------
template< class BaseClass >
inline CGameManager< BaseClass >::~CGameManager()
{
	Remove( this );
}


#endif // GAMEMANAGER_H



================================================
FILE: app/legion/heightfield.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Heightfield class
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "heightfield.h"
#include "materialsystem/imaterial.h"
#include "legion.h"
#include "materialsystem/imaterialsystem.h"
#include "materialsystem/imesh.h"
#include "tier2/tier2.h"
#include "tier2/utlstreambuffer.h"
#include "bitmap/bitmap.h"
#include "bitmap/psd.h"
#include "tier1/KeyValues.h"


//-----------------------------------------------------------------------------
// Utility macro
//-----------------------------------------------------------------------------
#define HEIGHT( _x, _y )	m_pHeightField[ ( (_y) << m_nPowX ) + (_x) ]
#define ROW( _y )			&m_pHeightField[ (_y) << m_nPowX ]


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
CHeightField::CHeightField( int nPowX, int nPowY, int nPowScale )
{
	m_nPowX = nPowX;
	m_nPowY = nPowY;
	m_nPowScale = nPowScale;
	m_nWidth = ( 1 << nPowX );
	m_nHeight = ( 1 << nPowY );
	m_nScale = ( 1 << nPowScale );
	m_flOOScale = 1.0f / m_nScale;
	m_pHeightField = (float*)malloc( m_nWidth * m_nHeight * sizeof(float) );
	memset( m_pHeightField, 0, m_nWidth * m_nHeight * sizeof(float) );

	KeyValues *pKeyValues = new KeyValues( "Wireframe" );
	pKeyValues->SetInt( "$nocull", 1 );
	m_Material.Init( "__Temp", pKeyValues );
}

CHeightField::~CHeightField()
{
	free( m_pHeightField );
}


//-----------------------------------------------------------------------------
// Bilinearly filters a sample out of a bitmap at a particular (x,y)
// NOTE: x,y are not normalized and are expected to go in the range of (0->w-1, 0->h-1)
//-----------------------------------------------------------------------------
float BilerpBitmap( Bitmap_t &bitmap, float x, float y )
{
	Assert( bitmap.m_ImageFormat == IMAGE_FORMAT_RGBA8888 );

    float w = (float)bitmap.m_nWidth;
    float h = (float)bitmap.m_nHeight;

    // Clamp to a valid range
	x = clamp( x, 0, w - 1.0f );
	y = clamp( y, 0, h - 1.0f );

    // pick bilerp coordinates
	int i0 = (int)floor( x );
	int i1 = i0 + 1;
	int j0 = (int)floor( y );
	int j1 = j0 + 1;
	if ( i1 >= bitmap.m_nWidth )
	{
		i1 = bitmap.m_nWidth - 1;
	}
	if ( j1 >= bitmap.m_nHeight )
	{
		j1 = bitmap.m_nHeight - 1;
	}

	float fx = x - i0;
	float fy = y - j0;

	RGBA8888_t* pPixel00 = (RGBA8888_t*)bitmap.GetPixel( i0, j0 );
	RGBA8888_t* pPixel10 = (RGBA8888_t*)bitmap.GetPixel( i1, j0 );
	RGBA8888_t* pPixel01 = (RGBA8888_t*)bitmap.GetPixel( i0, j1 );
	RGBA8888_t* pPixel11 = (RGBA8888_t*)bitmap.GetPixel( i1, j1 );

	float v00 = pPixel00->r / 255.0f;
    float v10 = pPixel10->r / 255.0f;
    float v01 = pPixel01->r / 255.0f;
    float v11 = pPixel11->r / 255.0f;

    // do the bilerp
    return (1-fx)*(1-fy)*v00 + fx*(1-fy)*v10 + (1-fx)*fy*v01 + fx*fy*v11;
}


//-----------------------------------------------------------------------------
// Loads the heightfield from a file
//-----------------------------------------------------------------------------
bool CHeightField::LoadHeightFromFile( const char *pFileName )
{
	Bitmap_t bitmap;
	CUtlStreamBuffer buf( pFileName, "GAME", CUtlBuffer::READ_ONLY );
	if ( IsPSDFile( buf ) )
	{
		if ( !PSDReadFileRGBA8888( buf, bitmap ) )
			return false;
	}

    // map from height field into map, ensuring corner pixel centers line up
    // hfx -> mapx:  0 -> 0.5, hfw-1 -> mapw-0.5
    // x (mapw - 1)/(hfw - 1) + 0.5
    // mapx -> worldx: 0 -> 0, mapw -> worldw
    float fx = (float)( bitmap.m_nWidth - 1) / (float)( m_nWidth - 1 );
    float fy = (float)( bitmap.m_nHeight - 1) / (float)( m_nHeight - 1 );

    for( int i = 0; i < m_nHeight; ++i ) 
	{
		float *pRow = ROW( i );
        for( int j = 0; j < m_nWidth; ++j, ++pRow ) 
		{
            *pRow = 50.0f * BilerpBitmap( bitmap, i * fx, j * fy );
        }
    }
	return true;
}


//-----------------------------------------------------------------------------
// Returns the height at a particular point
//-----------------------------------------------------------------------------
float CHeightField::GetHeight( float x, float y )
{
	x *= m_flOOScale;
	y *= m_flOOScale;

	int gx = (int)floor( x );
	int gy = (int)floor( y );
	x -= gx;
	y -= gy;

	// Check for out of range
	if ( gx < -1 || gy < -1 || gx >= m_nWidth || gy >= m_nHeight ) 
		return 0.0f;

	float h00 = ( gx >= 0 && gy >= 0 )					? HEIGHT(gx  , gy  ) : 0.0f;
	float h01 = ( gx < (m_nWidth-1) && gy >= 0 )		? HEIGHT(gx+1, gy  ) : 0.0f;
	float h10 = ( gx >= 0 && gy < (m_nHeight-1) )		? HEIGHT(gx  , gy+1) : 0.0f;
	float h11 = ( gx<(m_nWidth-1) && gy<(m_nHeight-1) )	? HEIGHT(gx+1, gy+1) : 0.0f;

	// This fixup accounts for the triangularization of the mesh
	if (x > y) 
	{
		h10 = h00 + h11 - h01;
	} 
	else 
	{
		h01 = h00 + h11 - h10;
	}

	// Bilinear filter
	float h0 = h00 + ( h01 - h00 ) * x;
	float h1 = h10 + ( h11 - h10 ) * x;
	float h = h0 + (h1-h0)*y;

	return h;
}


//-----------------------------------------------------------------------------
// Returns the height + slope at a particular point
//-----------------------------------------------------------------------------
float CHeightField::GetHeightAndSlope( float x, float y, float *dx, float *dy )
{
	x *= m_flOOScale;
	y *= m_flOOScale;

	int gx = (int)floor(x);
	int gy = (int)floor(y);
	x -= gx;
	y -= gy;

	if ( gx < -1 || gy < -1 || gx >= m_nWidth || gy >= m_nHeight )
	{
		*dx = 0;
		*dy = 0;
		return 0.0f;
	}

	float h00 = ( gx >= 0 && gy >= 0 )					? HEIGHT(gx  , gy  ) : 0.0f;
	float h01 = ( gx < (m_nWidth-1) && gy >= 0 )		? HEIGHT(gx+1, gy  ) : 0.0f;
	float h10 = ( gx >= 0 && gy < (m_nHeight-1) )		? HEIGHT(gx  , gy+1) : 0.0f;
	float h11 = ( gx<(m_nWidth-1) && gy<(m_nHeight-1) )	? HEIGHT(gx+1, gy+1) : 0.0f;

	if (x > y) 
	{
		h10 = h00 + h11 - h01;
	} 
	else 
	{
		h01 = h00 + h11 - h10;
	}

	*dx = ( h01 - h00 ) * m_flOOScale;
	*dy = ( h10 - h00 ) * m_flOOScale;

	// Bilinear filter
	float h0 = h00 + ( h01 - h00 ) * x;
	float h1 = h10 + ( h11 - h10 ) * x;
	float h = h0 + ( h1 - h0 )* y;

	return h;
}


//-----------------------------------------------------------------------------
// Draws the height field
//-----------------------------------------------------------------------------
void CHeightField::Draw( )
{
	int nVertexCount = m_nWidth * m_nHeight;
	int nIndexCount = 6 * ( m_nWidth - 1 ) * ( m_nHeight - 1 );

	float flOOTexWidth = 1.0f / m_Material->GetMappingWidth();
	float flOOTexHeight = 1.0f / m_Material->GetMappingHeight();
	float iu = 0.5f  * flOOTexWidth;
	float iv = 1.0f - ( 0.5f * flOOTexHeight );
	float du = ( 1.0f - flOOTexWidth ) / ( m_nWidth - 1 );
	float dv = -( 1.0f - flOOTexHeight ) / ( m_nHeight - 1 );

	CMatRenderContextPtr pRenderContext( g_pMaterialSystem );
	pRenderContext->Bind( m_Material );
	IMesh *pMesh = pRenderContext->GetDynamicMesh( );

	CMeshBuilder meshBuilder;
	meshBuilder.Begin( pMesh, MATERIAL_TRIANGLES, nVertexCount, nIndexCount );

	// Deal with vertices
	float v = iv;
	float y = 0.0f;
	for ( int i = 0; i < m_nHeight; ++i, y += m_nScale, v += dv )
	{
		float u = iu;
		float x = 0.0f;
		for ( int j = 0; j < m_nWidth; ++j, x += m_nScale, u += du )
		{
			meshBuilder.Position3f( x, y, HEIGHT( j, i ) );
			meshBuilder.TexCoord2f( 0, u, v );
			meshBuilder.AdvanceVertex();
		}
	}

	// Deal with indices
	for ( int i = 0; i < (m_nHeight - 1); ++i )
	{
		int nRow0 = m_nWidth * i; 
		int nRow1 = nRow0 + m_nWidth; 
		for ( int j = 0; j < (m_nWidth - 1); ++j )
		{
			meshBuilder.FastIndex( nRow0+j );
			meshBuilder.FastIndex( nRow0+j+1 );
			meshBuilder.FastIndex( nRow1+j+1 );

			meshBuilder.FastIndex( nRow0+j );
			meshBuilder.FastIndex( nRow1+j+1 );
			meshBuilder.FastIndex( nRow1+j );
		}
	}

	meshBuilder.End();
	pMesh->Draw();
}



================================================
FILE: app/legion/heightfield.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Heightfield class
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef HEIGHTFIELD_H
#define HEIGHTFIELD_H

#ifdef _WIN32
#pragma once
#endif

#include "materialsystem/MaterialSystemUtil.h"


//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class CMeshBuilder;


//-----------------------------------------------------------------------------
// Definition of a heightfield
//-----------------------------------------------------------------------------
class CHeightField
{
public:
	CHeightField( int nPowX, int nPowY, int nPowScale );
	~CHeightField();

	// Loads the heights from a file
	bool LoadHeightFromFile( const char *pFileName );

	// Returns the max range of x, y
	int GetWidth();
	int GetHeight();

	// Returns the height of the field at a paticular (x,y)
	float GetHeight( float x, float y );
	float GetHeightAndSlope( float x, float y, float *dx, float *dy );

	// Draws the heightfield
	void Draw( );

private:
	int m_nPowX;
	int m_nPowY;
	int m_nWidth;
	int m_nHeight;
	int m_nScale;
	int m_nPowScale;
	float m_flOOScale;
	float *m_pHeightField;

	CMaterialReference m_Material;
	CTextureReference m_Texture;
};


//-----------------------------------------------------------------------------
// Returns the max range of x, y (for use in GetHeight)
//-----------------------------------------------------------------------------
inline int CHeightField::GetWidth()
{
	return m_nWidth << m_nPowScale;
}

inline int CHeightField::GetHeight()
{
	return m_nHeight << m_nPowScale;
}


#endif // HEIGHTFIELD_H



================================================
FILE: app/legion/hostgamemenu.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The menu that allows a player to start a game  
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "menumanager.h"
#include "basemenu.h"
#include "vgui_controls/listpanel.h"
#include "vgui_controls/textentry.h"
#include "vgui_controls/Button.h"
#include "tier1/KeyValues.h"
#include "networkmanager.h"
#include "legion.h"
#include "inetworkmessagelistener.h"
#include "networkmessages.h"
#include "tier2/tier2.h"


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
class CHostGameMenu : public CBaseMenu, public INetworkMessageListener
{
	DECLARE_CLASS_SIMPLE( CHostGameMenu, CBaseMenu );

public:
	CHostGameMenu( vgui::Panel *pParent, const char *pPanelName );
	virtual ~CHostGameMenu();

	// Called when a particular network message occurs
	virtual void OnNetworkMessage( NetworkMessageRoute_t route, INetworkMessage *pNetworkMessage );
	virtual void OnCommand( const char *pCommand );

	MESSAGE_FUNC( OnTextNewLine, "TextNewLine" );

private:
	vgui::ListPanel *m_pPlayerList;
	vgui::TextEntry *m_pServerIP;
	vgui::TextEntry *m_pServerName;
	vgui::TextEntry *m_pChatLog;
	vgui::TextEntry *m_pChatEntry;
	vgui::TextEntry *m_pPlayerName;
	vgui::Button *m_pStartGame;
};


//-----------------------------------------------------------------------------
// Hooks the menu into the menu system
//-----------------------------------------------------------------------------
REGISTER_MENU( "HostGameMenu", CHostGameMenu );


//-----------------------------------------------------------------------------
// Sort by player name
//-----------------------------------------------------------------------------
static int __cdecl PlayerNameSortFunc( vgui::ListPanel *pPanel, const vgui::ListPanelItem &item1, const vgui::ListPanelItem &item2 )
{
	const char *string1 = item1.kv->GetString("player");
	const char *string2 = item2.kv->GetString("player");
	return stricmp( string1, string2 );
}


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
CHostGameMenu::CHostGameMenu( vgui::Panel *pParent, const char *pPanelName ) :
	BaseClass( pParent, pPanelName )
{
	m_pPlayerList = new vgui::ListPanel( this, "PlayerList" );
 	m_pPlayerList->AddColumnHeader( 0, "color", "Color", 52, 0 );
	m_pPlayerList->AddColumnHeader( 1, "player", "Player Name", 128, 0 );
    m_pPlayerList->SetSelectIndividualCells( false );
	m_pPlayerList->SetEmptyListText( "No Players" );
 	m_pPlayerList->SetDragEnabled( false );
 	m_pPlayerList->AddActionSignalTarget( this );
	m_pPlayerList->SetSortFunc( 0, PlayerNameSortFunc );
	m_pPlayerList->SetSortFunc( 1, PlayerNameSortFunc );
	m_pPlayerList->SetSortColumn( 1 );

	m_pServerIP = new vgui::TextEntry( this, "ServerIP" );
	m_pServerName = new vgui::TextEntry( this, "ServerName" );

	m_pPlayerName = new vgui::TextEntry( this, "PlayerName" );
	m_pPlayerName->SetMultiline( false );

	m_pChatLog = new vgui::TextEntry( this, "ChatLog" );
	m_pChatLog->SetMultiline( true );
	m_pChatLog->SetVerticalScrollbar( true );

	m_pChatEntry = new vgui::TextEntry( this, "ChatEntry" );
	m_pChatEntry->AddActionSignalTarget( this );
	m_pChatEntry->SetMultiline( false );
    m_pChatEntry->SendNewLine( true );

	m_pStartGame = new vgui::Button( this, "StartGame", "Start Game", this );

	LoadControlSettings( "resource/hostgamemenu.res", "GAME" );

	m_pPlayerName->SetText( "Unnamed" );

	if ( !g_pNetworkManager->HostGame() )
	{
		m_pStartGame->SetEnabled( false );
		return;
	}

	m_pServerIP->SetText( g_pNetworkSystem->GetLocalAddress() );
	m_pServerName->SetText( g_pNetworkSystem->GetLocalHostName() );

	g_pNetworkManager->AddListener( NETWORK_MESSAGE_SERVER_TO_CLIENT, LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, this );
	g_pNetworkManager->AddListener( NETWORK_MESSAGE_CLIENT_TO_SERVER, LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, this );
}

CHostGameMenu::~CHostGameMenu()
{
	g_pNetworkManager->RemoveListener( NETWORK_MESSAGE_SERVER_TO_CLIENT, LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, this );
	g_pNetworkManager->RemoveListener( NETWORK_MESSAGE_CLIENT_TO_SERVER, LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, this );
}


//-----------------------------------------------------------------------------
// Called when a particular network message occurs
//-----------------------------------------------------------------------------
void CHostGameMenu::OnNetworkMessage( NetworkMessageRoute_t route, INetworkMessage *pNetworkMessage )
{
	if ( route == NETWORK_MESSAGE_SERVER_TO_CLIENT )
	{
		CNetworkMessage_Chat *pChatMsg = static_cast<CNetworkMessage_Chat*>( pNetworkMessage );
		m_pChatLog->InsertString( pChatMsg->m_Message.Get() );
		m_pChatLog->InsertChar( '\n' );
	}
	else
	{
		// If this message was received from an client, broadcast it to all other clients
		g_pNetworkManager->BroadcastServerToClientMessage( pNetworkMessage );
	}
}


//-----------------------------------------------------------------------------
// Called when the enter key is hit in the chat entry window
//-----------------------------------------------------------------------------
void CHostGameMenu::OnTextNewLine()
{
	CNetworkMessage_Chat msg;
	 
	int nLen = m_pChatEntry->GetTextLength();
	if ( nLen > 0 )
	{
		char *pText = (char*)_alloca( (nLen+1) * sizeof(char) );
		m_pChatEntry->GetText( pText, nLen+1 );
		m_pChatEntry->SetText( "" );

		int nLenName = m_pPlayerName->GetTextLength();
		char *pName = (char*)_alloca( (nLenName+8) * sizeof(char) );
		if ( nLenName == 0 )
		{
			nLenName = 7;
			Q_strcpy( pName, "unnamed" );
		}
		else
		{
			m_pPlayerName->GetText( pName, nLenName+1 );
		}

		int nTotalLen = nLen + nLenName;
		msg.m_Message.SetLength( nTotalLen + 3 );
		Q_snprintf( msg.m_Message.Get(), nTotalLen+3, "[%s] %s", pName, pText );

		g_pNetworkManager->PostClientToServerMessage( &msg );
	}
}


//-----------------------------------------------------------------------------
// Called when the enter key is hit in the chat entry window
//-----------------------------------------------------------------------------
void CHostGameMenu::OnCommand( const char *pCommand )
{
	if ( !Q_stricmp( pCommand, "CancelHostGame" ) )
	{
		g_pNetworkManager->StopHostingGame();
		g_pMenuManager->PopMenu();
		return;
	}

	if ( !Q_stricmp( pCommand, "StartGame" ) )
	{
		IGameManager::StartNewLevel();
		g_pMenuManager->PopAllMenus();
		return;
	}

	BaseClass::OnCommand( pCommand );
}





================================================
FILE: app/legion/inetworkmessagelistener.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the networking code in the game 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef INETWORKMESSAGELISTENER_H
#define INETWORKMESSAGELISTENER_H

#ifdef _WIN32
#pragma once
#endif


//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class INetworkMessage;


//-----------------------------------------------------------------------------
// Message route type
//-----------------------------------------------------------------------------
enum NetworkMessageRoute_t
{
	NETWORK_MESSAGE_SERVER_TO_CLIENT = 0,
	NETWORK_MESSAGE_CLIENT_TO_SERVER,

	NETWORK_MESSAGE_ROUTE_COUNT,
};


//-----------------------------------------------------------------------------
// Interface used to listen to network messages
//-----------------------------------------------------------------------------
abstract_class INetworkMessageListener
{
public:
	// Called when a particular network message occurs
	virtual void OnNetworkMessage( NetworkMessageRoute_t route, INetworkMessage *pNetworkMessage ) = 0;
};


#endif // INETWORKMESSAGELISTENER_H




================================================
FILE: app/legion/inputmanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the UI 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "inputmanager.h"
#include "legion.h"
#include "uimanager.h"
#include "inputsystem/iinputsystem.h"
#include "tier2/tier2.h"
#include "tier1/convar.h"


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
static CInputManager s_InputManager;
extern CInputManager *g_pInputManager = &s_InputManager;

	
//-----------------------------------------------------------------------------
// Initialization 
//-----------------------------------------------------------------------------
bool CInputManager::Init()
{
	// FIXME: Read keybindings from a file
	m_KeyBindings.SetBinding( "w", "+forward" );
	m_KeyBindings.SetBinding( "s", "+back" );
	m_KeyBindings.SetBinding( "`", "toggleconsole" );
	m_ButtonUpToEngine.ClearAll();
	return true;
}


//-----------------------------------------------------------------------------
// Add a command into the command queue
//-----------------------------------------------------------------------------
void CInputManager::AddCommand( const char *pCommand )
{
	m_CommandBuffer.AddText( pCommand );
}


//-----------------------------------------------------------------------------
// FIXME! This is necessary only because of an artifact of how ConCommands used to work
//-----------------------------------------------------------------------------
static ConCommand *FindNamedCommand( char const *name )
{
	// look through the command list for all matches
	ConCommandBase const *cmd = (ConCommandBase const *)vgui::icvar()->GetCommands();
	while (cmd)
	{
		if (!Q_strcmp( name, cmd->GetName() ) )
		{
			if ( cmd->IsCommand() )
			{
				return ( ConCommand * )cmd;
			}
		}
		cmd = cmd->GetNext();
	}
	return NULL;
}


//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CInputManager::PrintConCommandBaseDescription( const ConCommandBase *pVar )
{
	bool bMin, bMax;
	float fMin, fMax;
	const char *pStr;

	Assert( pVar );

	Color clr;
	clr.SetColor( 255, 100, 100, 255 );

	if ( !pVar->IsCommand() )
	{
		ConVar *var = ( ConVar * )pVar;

		bMin = var->GetMin( fMin );
		bMax = var->GetMax( fMax );

		char const *value = NULL;
		char tempVal[ 32 ];

		if ( var->IsBitSet( FCVAR_NEVER_AS_STRING ) )
		{
			value = tempVal;

			if ( fabs( (float)var->GetInt() - var->GetFloat() ) < 0.000001 )
			{
				Q_snprintf( tempVal, sizeof( tempVal ), "%d", var->GetInt() );
			}
			else
			{
				Q_snprintf( tempVal, sizeof( tempVal ), "%f", var->GetFloat() );
			}
		}
		else
		{
			value = var->GetString();
		}

		if ( value )
		{
			Msg( "\"%s\" = \"%s\"", var->GetName(), value );

			if ( Q_stricmp( value, var->GetDefault() ) )
			{
				Msg( " ( def. \"%s\" )", var->GetDefault() );
			}
		}

		if ( bMin )
		{
			Msg( " min. %f", fMin );
		}
		if ( bMax )
		{
			Msg( " max. %f", fMax );
		}

		Msg( "\n" );
	}
	else
	{
		ConCommand *var = ( ConCommand * )pVar;

		Msg( "\"%s\"\n", var->GetName() );
	}

//	PrintConCommandBaseFlags( pVar );

	pStr = pVar->GetHelpText();
	if ( pStr && pStr[0] )
	{
		Msg( " - %s\n", pStr );
	}
}


//-----------------------------------------------------------------------------
// Per-frame update
//-----------------------------------------------------------------------------
void CInputManager::ProcessCommands( )
{
	m_CommandBuffer.BeginProcessingCommands( 1 );
	while ( m_CommandBuffer.DequeueNextCommand() )
	{
		const CCommand& args = m_CommandBuffer.GetCommand();
		const ConCommandBase *pCommand = FindNamedCommand( args[ 0 ] );
		if ( pCommand && pCommand->IsCommand() )
		{
			// FIXME: Um... yuck!?!
			ConCommand *pConCommand = const_cast<ConCommand*>( static_cast<const ConCommand*>( pCommand ) );
			pConCommand->Dispatch( args );
			continue;
		}

		ConVar *pConVar = g_pCVar->FindVar( args[0] );
		if ( !pConVar )
			continue;

		// perform a variable print or set
		if ( args.ArgC() == 1 )
		{
			PrintConCommandBaseDescription( pConVar );
			continue;
		}

		// Note that we don't want the tokenized list, send down the entire string
		// except for surrounding quotes
		char remaining[1024];
		const char *pArgS = args.ArgS();
		int nLen = Q_strlen( pArgS );
		bool bIsQuoted = pArgS[0] == '\"';
		if ( !bIsQuoted )
		{
			Q_strncpy( remaining, args.ArgS(), sizeof(remaining) );
		}
		else
		{
			--nLen;
			Q_strncpy( remaining, &pArgS[1], sizeof(remaining) );
		}

		// Now strip off any trailing spaces
		char *p = remaining + nLen - 1;
		while ( p >= remaining )
		{
			if ( *p > ' ' )
				break;

			*p-- = 0;
		}

		// Strip off ending quote
		if ( bIsQuoted && p >= remaining )
		{
			if ( *p == '\"' )
			{
				*p = 0;
			}
		}

		if ( pConVar->IsBitSet( FCVAR_NEVER_AS_STRING ) )
		{
			pConVar->SetValue( (float)atof( remaining ) );
		}
		else
		{
			pConVar->SetValue( remaining );
		}

	}
	m_CommandBuffer.EndProcessingCommands();
}


//-----------------------------------------------------------------------------
// Per-frame update
//-----------------------------------------------------------------------------
void CInputManager::Update( )
{
	char cmd[1024];

	g_pInputSystem->PollInputState();
	int nEventCount = g_pInputSystem->GetEventCount();
	const InputEvent_t* pEvents = g_pInputSystem->GetEventData( );
	for ( int i = 0; i < nEventCount; ++i )
	{
		if ( pEvents[i].m_nType == IE_Quit )
		{
			IGameManager::Stop();
			break;
		}

		bool bBypassVGui = false;
		switch( pEvents[i].m_nType )
		{
		case IE_AppActivated:
			if ( pEvents[i].m_nData == 0 )
			{
				m_ButtonUpToEngine.ClearAll();
			}
			break;

		case IE_ButtonReleased:
			{
				// This logic is necessary to deal with switching back + forth
				// between vgui + the engine. If we downclick in the engine,
				// the engine must get the upclick.
				ButtonCode_t code = (ButtonCode_t)pEvents[i].m_nData;
				if ( m_ButtonUpToEngine[ code ] )
				{
					m_ButtonUpToEngine.Clear( code );
					bBypassVGui = true;
				}
			}
			break;

		default:
			break;
		}


		if ( !bBypassVGui )
		{
			if ( g_pUIManager->ProcessInputEvent( pEvents[i] ) )
				continue;
		}

		// FIXME: Add game keybinding system here
		bool bButtonDown = ( pEvents[i].m_nType == IE_ButtonPressed );
		bool bButtonUp = ( pEvents[i].m_nType == IE_ButtonReleased );
		if ( bButtonDown || bButtonUp )
		{
			ButtonCode_t code = (ButtonCode_t)pEvents[i].m_nData;
			if ( bButtonDown )
			{
				m_ButtonUpToEngine.Set( code );
			}
			const char *pBinding = m_KeyBindings.GetBindingForButton( code );
			if ( !pBinding )
				continue;

			if ( pBinding[0] != '+' )
			{
				if ( bButtonDown )
				{
					m_CommandBuffer.AddText( pBinding );
				}
				continue;
			}

			Q_snprintf( cmd, sizeof(cmd), "%c%s %i\n", bButtonUp ? '-' : '+', &pBinding[1], code );
			m_CommandBuffer.AddText( cmd );
			continue;
		}
	}

	ProcessCommands();
}




================================================
FILE: app/legion/inputmanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the input 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef INPUTMANAGER_H
#define INPUTMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "tier2/keybindings.h"
#include "tier1/commandbuffer.h"
#include "bitvec.h"


//-----------------------------------------------------------------------------
// Input management
//-----------------------------------------------------------------------------
class CInputManager : public CGameManager<>
{
public:
	// Inherited from IGameManager
	virtual bool Init();
	virtual void Update( );

	// Add a command into the command queue
	void AddCommand( const char *pCommand );

private:
	// Per-frame update of commands
	void ProcessCommands( );

	// Purpose: 
	void PrintConCommandBaseDescription( const ConCommandBase *pVar );

	CKeyBindings m_KeyBindings;
	CBitVec<BUTTON_CODE_LAST> m_ButtonUpToEngine;
	CCommandBuffer m_CommandBuffer;
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CInputManager *g_pInputManager;


#endif // INPUTMANAGER_H




================================================
FILE: app/legion/joingamemenu.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Menu responsible for allowing players to join a game  
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "menumanager.h"
#include "basemenu.h"
#include "vgui_controls/listpanel.h"
#include "vgui_controls/textentry.h"
#include "vgui_controls/button.h"
#include "networkmessages.h"
#include "networkmanager.h"
#include "tier1/KeyValues.h"


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
class CJoinGameMenu : public CBaseMenu, public INetworkMessageListener
{
	DECLARE_CLASS_SIMPLE( CJoinGameMenu, CBaseMenu );

public:
	CJoinGameMenu( vgui::Panel *pParent, const char *pPanelName );
	virtual ~CJoinGameMenu();

	// Called when a particular network message occurs
	virtual void OnNetworkMessage( NetworkMessageRoute_t route, INetworkMessage *pNetworkMessage );
	virtual void OnCommand( const char *pCommand );

	MESSAGE_FUNC( OnTextNewLine, "TextNewLine" );

private:
	vgui::ListPanel *m_pPlayerList;
	vgui::TextEntry *m_pChatLog;
	vgui::TextEntry *m_pServerName;
	vgui::TextEntry *m_pServerPort;
	vgui::TextEntry *m_pChatEntry;
	vgui::TextEntry *m_pPlayerName;
	vgui::Button *m_pJoinGame;
	bool m_bJoiningGame;
};


//-----------------------------------------------------------------------------
// Hooks the menu into the menu manager
//-----------------------------------------------------------------------------
REGISTER_MENU( "JoinGameMenu", CJoinGameMenu );


//-----------------------------------------------------------------------------
// Sort by player name
//-----------------------------------------------------------------------------
static int __cdecl PlayerNameSortFunc( vgui::ListPanel *pPanel, const vgui::ListPanelItem &item1, const vgui::ListPanelItem &item2 )
{
	const char *string1 = item1.kv->GetString("player");
	const char *string2 = item2.kv->GetString("player");
	return stricmp( string1, string2 );
}


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
CJoinGameMenu::CJoinGameMenu( vgui::Panel *pParent, const char *pPanelName ) :
	BaseClass( pParent, pPanelName )
{
	m_pPlayerList = new vgui::ListPanel( this, "PlayerList" );
 	m_pPlayerList->AddColumnHeader( 0, "color", "Color", 52, 0 );
	m_pPlayerList->AddColumnHeader( 1, "player", "Player Name", 128, 0 );
    m_pPlayerList->SetSelectIndividualCells( false );
	m_pPlayerList->SetEmptyListText( "No Players" );
 	m_pPlayerList->SetDragEnabled( false );
 	m_pPlayerList->AddActionSignalTarget( this );
	m_pPlayerList->SetSortFunc( 0, PlayerNameSortFunc );
	m_pPlayerList->SetSortFunc( 1, PlayerNameSortFunc );
	m_pPlayerList->SetSortColumn( 1 );

	m_pServerName = new vgui::TextEntry( this, "ServerName" );

	m_pServerPort = new vgui::TextEntry( this, "ServerPort" );
	char pInitialPort[16];
	Q_snprintf( pInitialPort, sizeof(pInitialPort), "%d", NETWORKSYSTEM_DEFAULT_SERVER_PORT );
	m_pServerPort->SetText( pInitialPort );

	m_pPlayerName = new vgui::TextEntry( this, "PlayerName" );
	m_pPlayerName->SetMultiline( false );

	m_pChatLog = new vgui::TextEntry( this, "ChatLog" );
	m_pChatLog->SetMultiline( true );
	m_pChatLog->SetVerticalScrollbar( true );

	m_pChatEntry = new vgui::TextEntry( this, "ChatEntry" );
	m_pChatEntry->AddActionSignalTarget( this );
	m_pChatEntry->SetMultiline( false );
    m_pChatEntry->SendNewLine( true );

	m_pJoinGame = new vgui::Button( this, "JoinGame", "Join Game", this );

	LoadControlSettings( "resource/joingamemenu.res", "GAME" ); 

	m_pPlayerName->SetText( "Unnamed" );
	m_pChatEntry->SetEnabled( false );

	if ( !g_pNetworkManager->StartClient() )
	{
		m_pJoinGame->SetEnabled( false );
		return;
	}

	g_pNetworkManager->AddListener( NETWORK_MESSAGE_SERVER_TO_CLIENT, LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, this );
}

CJoinGameMenu::~CJoinGameMenu()
{
	g_pNetworkManager->RemoveListener( NETWORK_MESSAGE_SERVER_TO_CLIENT, LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, this );
}


//-----------------------------------------------------------------------------
// Called when a particular network message occurs
//-----------------------------------------------------------------------------
void CJoinGameMenu::OnNetworkMessage( NetworkMessageRoute_t route, INetworkMessage *pNetworkMessage )
{
	CNetworkMessage_Chat *pChatMsg = static_cast<CNetworkMessage_Chat*>( pNetworkMessage );
	m_pChatLog->InsertString( pChatMsg->m_Message.Get() );
	m_pChatLog->InsertChar( '\n' );
}


//-----------------------------------------------------------------------------
// Called when the enter key is hit in the chat entry window
//-----------------------------------------------------------------------------
void CJoinGameMenu::OnTextNewLine()
{
	CNetworkMessage_Chat msg;
	 
	int nLen = m_pChatEntry->GetTextLength();
	if ( nLen > 0 )
	{
		char *pText = (char*)_alloca( (nLen+1) * sizeof(char) );
		m_pChatEntry->GetText( pText, nLen+1 );
		m_pChatEntry->SetText( "" );

		int nLenName = m_pPlayerName->GetTextLength();
		char *pName = (char*)_alloca( (nLenName+8) * sizeof(char) );
		if ( nLenName == 0 )
		{
			nLenName = 7;
			Q_strcpy( pName, "unnamed" );
		}
		else
		{
			m_pPlayerName->GetText( pName, nLenName+1 );
		}

		int nTotalLen = nLen + nLenName;
		msg.m_Message.SetLength( nTotalLen + 3 );
		Q_snprintf( msg.m_Message.Get(), nTotalLen+3, "[%s] %s", pName, pText );

		g_pNetworkManager->PostClientToServerMessage( &msg );
	}
}


//-----------------------------------------------------------------------------
// Called when the enter key is hit in the chat entry window
//-----------------------------------------------------------------------------
void CJoinGameMenu::OnCommand( const char *pCommand )
{
	if ( !Q_stricmp( pCommand, "Cancel" ) )
	{
		g_pNetworkManager->ShutdownClient();
		g_pMenuManager->PopMenu();
		return;
	}

	if ( !Q_stricmp( pCommand, "JoinGame" ) )
	{
		if ( !m_bJoiningGame )
		{
			g_pNetworkManager->DisconnectClientFromServer();
			m_pChatEntry->SetEnabled( false );
			m_pChatEntry->SetText( "" );
			m_bJoiningGame = true;
			m_pJoinGame->SetText( "Join Game" );
		}
		else
		{
			int nLen = m_pServerName->GetTextLength();
			char *pServer = (char*)_alloca( (nLen+1) * sizeof(char) );
			m_pServerName->GetText( pServer, nLen+1 );

			char pPort[32];
			m_pServerPort->GetText( pPort, sizeof(pPort) );

			if ( g_pNetworkManager->ConnectClientToServer( pServer, atoi( pPort ) ) )
			{
				m_pChatEntry->SetEnabled( true );
				m_bJoiningGame = false;
				m_pJoinGame->SetText( "Leave Game" );
			}
		}
		return;
	}

	BaseClass::OnCommand( pCommand );
}





================================================
FILE: app/legion/legion.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// $Header: $
// $NoKeywords: $
//
// An RTS!
//=============================================================================

#include "legion.h"
#include <windows.h>
#include "inputsystem/iinputsystem.h"
#include "networksystem/inetworksystem.h"
#include "filesystem.h"
#include "materialsystem/imaterialsystem.h"
#include "vgui/IVGui.h"
#include "vgui/ISurface.h"
#include "VGuiMatSurface/IMatSystemSurface.h"
#include "vgui_controls/controls.h"
#include "vgui/ILocalize.h"
#include "vgui_controls/AnimationController.h"
#include "gamemanager.h"
#include "menumanager.h"
#include "physicsmanager.h"
#include "rendermanager.h"
#include "uimanager.h"
#include "inputmanager.h"
#include "networkmanager.h"
#include "worldmanager.h"
#include "tier3/tier3.h"


//-----------------------------------------------------------------------------
// Purpose: Warning/Msg call back through this API
// Input  : type - 
//			*pMsg - 
// Output : SpewRetval_t
//-----------------------------------------------------------------------------
SpewRetval_t SpewFunc( SpewType_t type, char const *pMsg )
{	
	OutputDebugString( pMsg );
	if ( type == SPEW_ASSERT )
	{
		DebuggerBreak();
	}
	return SPEW_CONTINUE;
}


static CLegionApp s_LegionApp;
extern CLegionApp *g_pApp = &s_LegionApp;
DEFINE_WINDOWED_STEAM_APPLICATION_OBJECT_GLOBALVAR( CLegionApp, s_LegionApp );


//-----------------------------------------------------------------------------
// Create all singleton systems
//-----------------------------------------------------------------------------
bool CLegionApp::Create()
{
	SpewOutputFunc( SpewFunc );

	// FIXME: Put this into tier1librariesconnect
	MathLib_Init( 2.2f, 2.2f, 0.0f, 2.0f, false );

	if ( !BaseClass::Create() )
		return false;

	AppSystemInfo_t appSystems[] = 
	{
		{ "networksystem.dll",		NETWORKSYSTEM_INTERFACE_VERSION },
		{ "", "" }	// Required to terminate the list
	};

	return AddSystems( appSystems );
}

bool CLegionApp::PreInit( )
{
	if ( !BaseClass::PreInit() )
		return false;

	if ( !g_pInputSystem || !g_pFullFileSystem || !g_pNetworkSystem || !g_pMaterialSystem || !g_pVGui || !g_pVGuiSurface || !g_pMatSystemSurface )
	{
		Warning( "Legion is missing a required interface!\n" );
		return false;
	}
	return true;
}


void CLegionApp::PostShutdown()
{
	BaseClass::PostShutdown();
}


bool CLegionApp::RegisterConCommandBase( ConCommandBase *pCommand )
{
	// Mark for easy removal
	pCommand->AddFlags( FCVAR_CLIENTDLL );
	pCommand->SetNext( 0 );

	// Link to variable list
	g_pCVar->RegisterConCommandBase( pCommand );
	return true;
}

void CLegionApp::UnregisterConCommandBase( ConCommandBase *pCommand )
{
	// Unlink from variable list
	g_pCVar->UnlinkVariable( pCommand );
}


//-----------------------------------------------------------------------------
// main application
//-----------------------------------------------------------------------------
int CLegionApp::Main()
{
	if (!SetVideoMode())
		return 0;

	ConCommandBaseMgr::OneTimeInit( this );

	g_pMaterialSystem->ModInit();

	// World database
	IGameManager::Add( g_pWorldManager );

	// Output
	IGameManager::Add( g_pRenderManager );

	// Input
	IGameManager::Add( g_pNetworkManager );
	IGameManager::Add( g_pInputManager );
	IGameManager::Add( g_pMenuManager );
	IGameManager::Add( g_pUIManager );

	// Simulation
	IGameManager::Add( g_pPhysicsManager );

	// Init the game managers
	if ( !IGameManager::InitAllManagers() )
		return 0;

	// First menu to start on
	g_pMenuManager->PushMenu( "MainMenu" );

	// This is the main game loop
	IGameManager::Start();

	// Shut down game systems
	IGameManager::ShutdownAllManagers();

 	g_pMaterialSystem->ModShutdown();

	g_pCVar->UnlinkVariables( FCVAR_CLIENTDLL );

	return 1;
}






================================================
FILE: app/legion/legion.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// $Header: $
// $NoKeywords: $
//
// An RTS!
//=============================================================================

#ifndef LEGION_H
#define LEGION_H

#ifdef _WIN32
#pragma once
#endif

#include "appframework/vguimatsysapp.h"
#include "tier1/convar.h"

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class CLegionApp;


//-----------------------------------------------------------------------------
// Singleton interfaces
//-----------------------------------------------------------------------------
extern CLegionApp *g_pApp;


//-----------------------------------------------------------------------------
// The application object
//-----------------------------------------------------------------------------
class CLegionApp : public CVguiMatSysApp, public IConCommandBaseAccessor
{
	typedef CVguiMatSysApp BaseClass;

public:
	// Methods of IApplication
	virtual bool Create();
	virtual bool PreInit( );
	virtual int Main();
	virtual void PostShutdown( );
	virtual const char *GetAppName() { return "Legion"; }

	// Methods of IConCommandBaseAccessor
	virtual bool RegisterConCommandBase( ConCommandBase *pCommand );
	virtual void UnregisterConCommandBase( ConCommandBase *pCommand );

	// Promote to public
	void AppPumpMessages() { BaseClass::AppPumpMessages(); }

private:
};


#endif // LEGION_H





================================================
FILE: app/legion/legion.vcproj
================================================
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="7.10"
	Name="legion"
	ProjectGUID="{B0B64755-2419-4946-A726-881A1D884F65}"
	Keyword="Win32Proj">
	<Platforms>
		<Platform
			Name="Win32"/>
	</Platforms>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="Debug"
			IntermediateDirectory="Debug"
			ConfigurationType="1"
			CharacterSet="2">
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\public;..\..\public\tier1;..\..\common"
				PreprocessorDefinitions="_WIN32;_DEBUG;_WINDOWS"
				MinimalRebuild="TRUE"
				ExceptionHandling="FALSE"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				ForceConformanceInForLoopScope="TRUE"
				RuntimeTypeInfo="TRUE"
				UsePrecompiledHeader="0"
				ProgramDataBaseFileName="$(IntDir)/legion.pdb"
				WarningLevel="4"
				Detect64BitPortabilityProblems="TRUE"
				DebugInformationFormat="4"/>
			<Tool
				Name="VCCustomBuildTool"
				CommandLine="if exist ..\..\..\game\bin\legion.exe attrib -r ..\..\..\game\bin\legion.exe
copy &quot;$(TargetPath)&quot; ..\..\..\game\bin
if exist ..\..\..\game\bin\legion.pdb attrib -r ..\..\..\game\bin\legion.pdb
copy &quot;$(TargetDir)&quot;legion.pdb ..\..\..\game\bin
"
				Outputs="..\..\..\game\bin\legion.exe;..\..\..\game\bin\legion.pdb"/>
			<Tool
				Name="VCLinkerTool"
				IgnoreImportLibrary="TRUE"
				OutputFile="$(OutDir)/legion.exe"
				LinkIncremental="2"
				SuppressStartupBanner="TRUE"
				AdditionalLibraryDirectories="..\..\lib\public;..\..\lib\common"
				IgnoreDefaultLibraryNames="libcmt.lib"
				GenerateDebugInformation="TRUE"
				ProgramDatabaseFile="$(OutDir)/legion.pdb"
				SubSystem="2"
				TargetMachine="1"/>
			<Tool
				Name="VCMIDLTool"/>
			<Tool
				Name="VCPostBuildEventTool"/>
			<Tool
				Name="VCPreBuildEventTool"/>
			<Tool
				Name="VCPreLinkEventTool"/>
			<Tool
				Name="VCResourceCompilerTool"/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"/>
			<Tool
				Name="VCXMLDataGeneratorTool"/>
			<Tool
				Name="VCWebDeploymentTool"/>
			<Tool
				Name="VCManagedWrapperGeneratorTool"/>
			<Tool
				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="Release"
			IntermediateDirectory="Release"
			ConfigurationType="1"
			CharacterSet="2">
			<Tool
				Name="VCCLCompilerTool"
				GlobalOptimizations="TRUE"
				InlineFunctionExpansion="2"
				EnableIntrinsicFunctions="TRUE"
				FavorSizeOrSpeed="1"
				OptimizeForProcessor="3"
				AdditionalIncludeDirectories="..\..\public;..\..\public\tier1;..\..\common"
				PreprocessorDefinitions="_WIN32;NDEBUG;_WINDOWS"
				ExceptionHandling="FALSE"
				RuntimeLibrary="0"
				ForceConformanceInForLoopScope="TRUE"
				RuntimeTypeInfo="TRUE"
				UsePrecompiledHeader="0"
				ProgramDataBaseFileName="$(IntDir)/legion.pdb"
				WarningLevel="4"
				Detect64BitPortabilityProblems="TRUE"
				DebugInformationFormat="3"/>
			<Tool
				Name="VCCustomBuildTool"
				CommandLine="if exist ..\..\..\game\bin\legion.exe attrib -r ..\..\..\game\bin\legion.exe
copy &quot;$(TargetPath)&quot; ..\..\..\game\bin
if exist ..\..\..\game\bin\legion.pdb attrib -r ..\..\..\game\bin\legion.pdb
copy &quot;$(TargetDir)&quot;legion.pdb ..\..\..\game\bin
"
				Outputs="..\..\..\game\bin\legion.exe;..\..\..\game\bin\legion.pdb"/>
			<Tool
				Name="VCLinkerTool"
				IgnoreImportLibrary="TRUE"
				OutputFile="$(OutDir)/legion.exe"
				LinkIncremental="1"
				SuppressStartupBanner="TRUE"
				AdditionalLibraryDirectories="..\..\lib\public;..\..\lib\common"
				IgnoreDefaultLibraryNames="libcmtd.lib"
				GenerateDebugInformation="TRUE"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"/>
			<Tool
				Name="VCMIDLTool"/>
			<Tool
				Name="VCPostBuildEventTool"/>
			<Tool
				Name="VCPreBuildEventTool"/>
			<Tool
				Name="VCPreLinkEventTool"/>
			<Tool
				Name="VCResourceCompilerTool"/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"/>
			<Tool
				Name="VCXMLDataGeneratorTool"/>
			<Tool
				Name="VCWebDeploymentTool"/>
			<Tool
				Name="VCManagedWrapperGeneratorTool"/>
			<Tool
				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
			<File
				RelativePath=".\basemenu.cpp">
			</File>
			<File
				RelativePath=".\gamemanager.cpp">
			</File>
			<File
				RelativePath=".\heightfield.cpp">
			</File>
			<File
				RelativePath=".\hostgamemenu.cpp">
			</File>
			<File
				RelativePath=".\inputmanager.cpp">
			</File>
			<File
				RelativePath=".\joingamemenu.cpp">
			</File>
			<File
				RelativePath=".\legion.cpp">
			</File>
			<File
				RelativePath=".\mainmenu.cpp">
			</File>
			<File
				RelativePath="..\..\public\tier0\memoverride.cpp">
			</File>
			<File
				RelativePath=".\menumanager.cpp">
			</File>
			<File
				RelativePath=".\networkmanager.cpp">
			</File>
			<File
				RelativePath=".\networkmessages.cpp">
			</File>
			<File
				RelativePath=".\networkmessages.h">
			</File>
			<File
				RelativePath=".\physicsmanager.cpp">
			</File>
			<File
				RelativePath=".\rendermanager.cpp">
			</File>
			<File
				RelativePath=".\uimanager.cpp">
			</File>
			<File
				RelativePath=".\worldmanager.cpp">
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
			<File
				RelativePath=".\basemenu.h">
			</File>
			<File
				RelativePath=".\gamemanager.h">
			</File>
			<File
				RelativePath=".\heightfield.h">
			</File>
			<File
				RelativePath=".\inetworkmessagelistener.h">
			</File>
			<File
				RelativePath=".\inputmanager.h">
			</File>
			<File
				RelativePath=".\legion.h">
			</File>
			<File
				RelativePath=".\menumanager.h">
			</File>
			<File
				RelativePath=".\networkmanager.h">
			</File>
			<File
				RelativePath=".\physicsmanager.h">
			</File>
			<File
				RelativePath=".\rendermanager.h">
			</File>
			<File
				RelativePath=".\uimanager.h">
			</File>
			<File
				RelativePath=".\worldmanager.h">
			</File>
		</Filter>
		<Filter
			Name="External Dependencies"
			Filter="">
			<File
				RelativePath="..\..\public\mathlib\math_base.h">
			</File>
			<File
				RelativePath="..\..\public\tier1\utlstack.h">
			</File>
			<File
				RelativePath="..\..\public\tier1\utlstring.h">
			</File>
		</Filter>
		<File
			RelativePath="..\..\lib\public\appframework.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\bitmap.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\mathlib.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\matsys_controls.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\tier0.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\tier1.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\tier2.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\tier3.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\vgui_controls.lib">
		</File>
		<File
			RelativePath="..\..\lib\public\vstdlib.lib">
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>



================================================
FILE: app/legion/mainmenu.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: List of game systems to update  
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "menumanager.h"
#include "basemenu.h"


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
class CMainMenu : public CBaseMenu
{
	DECLARE_CLASS_SIMPLE( CMainMenu, CBaseMenu );

public:
	CMainMenu( vgui::Panel *pParent, const char *pPanelName );
	virtual ~CMainMenu();

private:
};


//-----------------------------------------------------------------------------
// Hooks the menu into the menu manager
//-----------------------------------------------------------------------------
REGISTER_MENU( "MainMenu", CMainMenu );


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
CMainMenu::CMainMenu( vgui::Panel *pParent, const char *pPanelName ) :
	BaseClass( pParent, pPanelName )
{
	LoadControlSettings( "resource/mainmenu.res", "GAME" ); 
}

CMainMenu::~CMainMenu()
{
}




================================================
FILE: app/legion/menumanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The menu manager  
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "menumanager.h"
#include "vgui_controls/panel.h"
#include "vgui_controls/frame.h"
#include "uimanager.h"


//-----------------------------------------------------------------------------
// Singleton
//-----------------------------------------------------------------------------
static CMenuManager s_MenuManager;
extern CMenuManager *g_pMenuManager = &s_MenuManager;


//-----------------------------------------------------------------------------
// Static members.
// NOTE: Do *not* set this to 0; it could cause us to lose some registered
// menus since that list is set up during construction
//-----------------------------------------------------------------------------
IMenuFactory *CMenuManager::m_pFirstFactory;


//-----------------------------------------------------------------------------
// Call to register methods which can construct menus w/ particular names
//-----------------------------------------------------------------------------
IMenuFactory *CMenuManager::RegisterMenu( IMenuFactory *pMenuFactory )
{
	// NOTE: This method is expected to be called during global constructor
	// time, so it must not require any global constructors to be called to work
	IMenuFactory *pPrevFactory = m_pFirstFactory;
	m_pFirstFactory = pMenuFactory;
	return pPrevFactory;
}

	
//-----------------------------------------------------------------------------
// Init, shutdown
//-----------------------------------------------------------------------------
bool CMenuManager::Init()
{
	// Build a dictionary of all registered menus
	IMenuFactory *pFactory;
	for ( pFactory = m_pFirstFactory; pFactory; pFactory = pFactory->GetNextFactory() )
	{
		m_MenuFactories.Insert( pFactory->GetMenuName(), pFactory );
	}

	m_bPopRequested = false;
	m_bPopAllRequested = false;
	m_pPushRequested = NULL;

	return true;
}

void CMenuManager::Shutdown()
{
	CleanUpAllMenus();
}

	
//-----------------------------------------------------------------------------
// Push, pop menus
//-----------------------------------------------------------------------------
void CMenuManager::PushMenu( const char *pMenuName )
{
	AssertMsg( !m_pPushRequested, "Can't request to push two menus in a single frame!" );

	MenuFactoryIndex_t i = m_MenuFactories.Find( pMenuName );
	if ( i == m_MenuFactories.InvalidIndex() )
	{
		Warning( "Tried to push unknown menu %s\n", pMenuName );
		return;
	}
	m_pPushRequested = m_MenuFactories[i];
}

void CMenuManager::PopMenu( )
{
	AssertMsg( !m_bPopRequested, "Can't request to pop two menus in a single frame!" );
	AssertMsg( !m_pPushRequested, "Can't request to pop after requesting to push a menu in a single frame!" );
	m_bPopRequested = true;
}

void CMenuManager::PopAllMenus( )
{
	AssertMsg( !m_pPushRequested, "Can't request to pop after requesting to push a menu in a single frame!" );
	m_bPopAllRequested = true;
}


//-----------------------------------------------------------------------------
// Request a menu to switch to
//-----------------------------------------------------------------------------
void CMenuManager::SwitchToMenu( const char *pMenuName )
{
	AssertMsg( !m_bPopRequested, "Can't request to pop two menus in a single frame!" );
	AssertMsg( !m_pPushRequested, "Can't request to push two menus in a single frame!" );

	MenuFactoryIndex_t i = m_MenuFactories.Find( pMenuName );
	if ( i == m_MenuFactories.InvalidIndex() )
	{
		Warning( "Tried to switch to unknown menu %s\n", pMenuName );
		return;
	}
	m_bPopRequested = true;
	m_pPushRequested = m_MenuFactories[i];
}


//-----------------------------------------------------------------------------
// Returns the name of the topmost panel
//-----------------------------------------------------------------------------
const char *CMenuManager::GetTopmostPanelName()
{
	if ( !m_nActiveMenu.Count() )
		return NULL;
	return m_nActiveMenu.Top()->GetName();
}

	
//-----------------------------------------------------------------------------
// Request a menu to switch to
//-----------------------------------------------------------------------------
void CMenuManager::Update( )
{
	if ( m_bPopAllRequested )
	{
		CleanUpAllMenus();
		m_bPopAllRequested = false;
		return;
	}

	if ( m_bPopRequested )
	{
		AssertMsg( m_nActiveMenu.Count(), "Tried to pop a menu when no menus are active" );
		vgui::Panel *pTop = m_nActiveMenu.Top();
		pTop->MarkForDeletion();
		m_nActiveMenu.Pop();

		// Mark the new active menu as visible, attach it to hierarchy.
		if ( m_nActiveMenu.Count() > 0 )
		{
			vgui::Panel *pTop = m_nActiveMenu.Top();
			pTop->SetVisible( true );
			pTop->SetParent( g_pUIManager->GetRootPanel( UI_ROOT_MENU ) );
		}
		else
		{
			g_pUIManager->EnablePanel( UI_ROOT_MENU, false );
		}
		m_bPopRequested = false;
	}

	if ( m_pPushRequested )
	{
		// Mark the previous menu as not visible, detach it from hierarchy.
		if ( m_nActiveMenu.Count() > 0 )
		{
			vgui::Panel *pTop = m_nActiveMenu.Top();
			pTop->SetVisible( false );
			pTop->SetParent( (vgui::Panel*)NULL );
		}
		else
		{
			g_pUIManager->EnablePanel( UI_ROOT_MENU, true );
		}
		vgui::Panel *pMenu = m_pPushRequested->CreateMenu( g_pUIManager->GetRootPanel( UI_ROOT_MENU ) );
		m_nActiveMenu.Push( pMenu );
		static_cast<vgui::Frame*>( pMenu )->Activate();
		m_pPushRequested = NULL;
	}
}

	
//-----------------------------------------------------------------------------
// Cleans up all menus
//-----------------------------------------------------------------------------
void CMenuManager::CleanUpAllMenus()
{
	while ( m_nActiveMenu.Count() )
	{
		vgui::Panel *pTop = m_nActiveMenu.Top();
		pTop->MarkForDeletion();
		m_nActiveMenu.Pop();
	}
	g_pUIManager->EnablePanel( UI_ROOT_MENU, false );
}




================================================
FILE: app/legion/menumanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The manager that deals with menus
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef MENUMANAGER_H
#define MENUMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "tier1/utldict.h"
#include "tier1/utlstack.h"


//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
namespace vgui
{
	class Panel;
}


//-----------------------------------------------------------------------------
// Interface used to create menus
//-----------------------------------------------------------------------------
abstract_class IMenuFactory
{
public:
	// Returns the name of the menu it will create
	virtual const char *GetMenuName() = 0;

	// Creates the menu
	virtual vgui::Panel *CreateMenu( vgui::Panel *pParent ) = 0;
	
	// Used to build a list during construction
	virtual IMenuFactory *GetNextFactory( ) = 0;

protected:
	virtual ~IMenuFactory() {}
};


//-----------------------------------------------------------------------------
// Menu managemer
//-----------------------------------------------------------------------------
class CMenuManager : public CGameManager<>
{
public:
	typedef vgui::Panel* (*MenuFactory_t)( vgui::Panel *pParent );

	// Inherited from IGameManager
	virtual bool Init();
	virtual void Update( );
	virtual void Shutdown();

	// Push, pop menus
	void PushMenu( const char *pMenuName );
	void PopMenu( );
	void PopAllMenus( );

	// Pop the top menu, push specified menu
	void SwitchToMenu( const char *pMenuName );

	// Returns the name of the topmost panel
	const char *GetTopmostPanelName();

	// Call to register methods which can construct menus w/ particular ids
	// NOTE: This method is not expected to be called directly. Use the REGISTER_MENU macro instead
	// It returns the previous head of the list of factories
	static IMenuFactory* RegisterMenu( IMenuFactory *pMenuFactory );

private:
	void CleanUpAllMenus();

	typedef unsigned char MenuFactoryIndex_t;
	CUtlDict< IMenuFactory *, MenuFactoryIndex_t > m_MenuFactories;
	CUtlStack< vgui::Panel * > m_nActiveMenu;
	bool m_bPopRequested;
	bool m_bPopAllRequested;
	IMenuFactory *m_pPushRequested;
	static IMenuFactory *m_pFirstFactory;
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CMenuManager *g_pMenuManager;


//-----------------------------------------------------------------------------
// Macro used to register menus with the menu manager
// For example, add the line REGISTER_MENU( "MainMenu", CMainMenu );
// into the class defining the main menu
//-----------------------------------------------------------------------------
template < class T >
class CMenuFactory : public IMenuFactory
{
public:
	CMenuFactory( const char *pMenuName ) : m_pMenuName( pMenuName )
	{
		m_pNextFactory = CMenuManager::RegisterMenu( this );
	}

	// Returns the name of the menu it will create
	virtual const char *GetMenuName()
	{
		return m_pMenuName;
	}

	// Creates the menu
	virtual vgui::Panel *CreateMenu( vgui::Panel *pParent )
	{
		return new T( pParent, m_pMenuName );
	}

	// Used to build a list during construction
	virtual IMenuFactory *GetNextFactory( )
	{
		return m_pNextFactory;
	}

private:
	const char* m_pMenuName;
	IMenuFactory *m_pNextFactory;
};

#define REGISTER_MENU( _name, _className )	\
	static CMenuFactory< _className > s_Factory ## _className( _name )


#endif // MENUMANAGER_H




================================================
FILE: app/legion/networkmanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the networking code in the game 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "networkmanager.h"
#include "legion.h"
#include "networksystem/inetworkmessage.h"
#include "tier1/bitbuf.h"
#include "inetworkmessagelistener.h"
#include "tier0/icommandline.h"
#include "tier2/tier2.h"


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
static CNetworkManager s_NetworkManager;
extern CNetworkManager *g_pNetworkManager = &s_NetworkManager;


//-----------------------------------------------------------------------------
// Static members.
// NOTE: Do *not* set this to 0; it could cause us to lose some registered
// menus since that list is set up during construction
//-----------------------------------------------------------------------------
INetworkMessageFactory *CNetworkManager::m_pFirstFactory;


//-----------------------------------------------------------------------------
// Call to register methods to register network messages
//-----------------------------------------------------------------------------
INetworkMessageFactory *CNetworkManager::RegisterNetworkMessage( INetworkMessageFactory *pNetworkMessageFactory )
{
	// NOTE: This method is expected to be called during global constructor
	// time, so it must not require any global constructors to be called to work
	INetworkMessageFactory *pPrevFactory = m_pFirstFactory;
	m_pFirstFactory = pNetworkMessageFactory;
	return pPrevFactory;
}


//-----------------------------------------------------------------------------
// Init, shutdown
//-----------------------------------------------------------------------------
bool CNetworkManager::Init()
{
	m_bIsClient = m_bIsServer = false;
	m_pClientToServerConnection = NULL;

	// Make a listener array for each message type

	// Register all network messages
	INetworkMessageFactory *pFactory;
	for ( pFactory = m_pFirstFactory; pFactory; pFactory = pFactory->GetNextFactory() )
	{
		INetworkMessage *pNetworkMessage = pFactory->CreateNetworkMessage();
		g_pNetworkSystem->RegisterMessage( pNetworkMessage );
	}

	return true;
}

void CNetworkManager::Shutdown()
{
	ShutdownClient();
	ShutdownServer();
}


//-----------------------------------------------------------------------------
// Start a server up
//-----------------------------------------------------------------------------
bool CNetworkManager::StartServer( unsigned short nServerListenPort )
{
	ShutdownServer( );
	if ( nServerListenPort == LEGION_DEFAULT_SERVER_PORT )
	{
		nServerListenPort = CommandLine()->ParmValue( "-serverport", NETWORKSYSTEM_DEFAULT_SERVER_PORT );
	}
	m_bIsServer = g_pNetworkSystem->StartServer( nServerListenPort );
	return m_bIsServer;
}

void CNetworkManager::ShutdownServer( )
{
	if ( m_bIsServer )
	{
		g_pNetworkSystem->ShutdownServer( );
		m_bIsServer = false;
	}
}

	
//-----------------------------------------------------------------------------
// Start a client up
//-----------------------------------------------------------------------------
bool CNetworkManager::StartClient( unsigned short nClientListenPort )
{
	ShutdownClient( );

	if ( nClientListenPort == LEGION_DEFAULT_CLIENT_PORT )
	{
		nClientListenPort = CommandLine()->ParmValue( "-clientport", NETWORKSYSTEM_DEFAULT_CLIENT_PORT );
	}

	m_bIsClient = g_pNetworkSystem->StartClient( nClientListenPort );
	return m_bIsClient;
}

void CNetworkManager::ShutdownClient( )
{
	if ( m_bIsClient )
	{
		DisconnectClientFromServer();
		g_pNetworkSystem->ShutdownClient( );
		m_bIsClient = false;
	}
}


//-----------------------------------------------------------------------------
// Connects/disconnects the client to a server
//-----------------------------------------------------------------------------
bool CNetworkManager::ConnectClientToServer( const char *pServerName, unsigned short nServerListenPort )
{
	DisconnectClientFromServer();
	if ( !IsClient() )
		return false;

	if ( nServerListenPort == LEGION_DEFAULT_SERVER_PORT )
	{
		nServerListenPort = CommandLine()->ParmValue( "-serverport", NETWORKSYSTEM_DEFAULT_SERVER_PORT );
	}
	m_pClientToServerConnection = g_pNetworkSystem->ConnectClientToServer( pServerName, nServerListenPort );
	return ( m_pClientToServerConnection != NULL );
}

void CNetworkManager::DisconnectClientFromServer( )
{
	if ( m_pClientToServerConnection )
	{
		g_pNetworkSystem->DisconnectClientFromServer( m_pClientToServerConnection );	
		m_pClientToServerConnection = NULL;
	}
}


//-----------------------------------------------------------------------------
// Start up a game where the local player is playing
//-----------------------------------------------------------------------------
bool CNetworkManager::HostGame()
{
	if ( !StartServer() )
		return false;

	if ( !StartClient() )
	{
		ShutdownServer();
		return false;
	}

	if ( !ConnectClientToServer( "localhost" ) )
	{
		ShutdownClient();
		ShutdownServer();
		return false;
	}

	return true;
}

void CNetworkManager::StopHostingGame()
{
	ShutdownClient();
	ShutdownServer();
}


//-----------------------------------------------------------------------------
// Are we a client?/Are we a server? (we can be both)
//-----------------------------------------------------------------------------
bool CNetworkManager::IsClient()
{
	return m_bIsClient;
}

bool CNetworkManager::IsServer()
{
	return m_bIsServer;
}

	
//-----------------------------------------------------------------------------
// If we are a client, are we connected to the server?
//-----------------------------------------------------------------------------
bool CNetworkManager::IsClientConnected()
{
	return m_bIsClient && ( m_pClientToServerConnection != NULL ) && ( m_pClientToServerConnection->GetConnectionState() == CONNECTION_STATE_CONNECTED );
}


//-----------------------------------------------------------------------------
// Post a network message to the server
//-----------------------------------------------------------------------------
void CNetworkManager::PostClientToServerMessage( INetworkMessage *pMessage )
{
	if ( IsClientConnected() )
	{
		m_pClientToServerConnection->AddNetMsg( pMessage );
	}
}

	
//-----------------------------------------------------------------------------
// Broadcast a network message to all clients
//-----------------------------------------------------------------------------
void CNetworkManager::BroadcastServerToClientMessage( INetworkMessage *pMessage )
{
	if ( IsServer() )
	{
		int nCount = m_ServerToClientConnection.Count();
		for ( int i = 0; i < nCount; ++i )
		{
			m_ServerToClientConnection[i]->AddNetMsg( pMessage );
		}
	}
}

	
//-----------------------------------------------------------------------------
// Add, remove network message listeners
//-----------------------------------------------------------------------------
void CNetworkManager::AddListener( NetworkMessageRoute_t route, int nGroup, int nType, INetworkMessageListener *pListener )
{
	CUtlVector< CUtlVector< CUtlVector < INetworkMessageListener* > > > &listeners = m_Listeners[ route ];
	if ( listeners.Count() <= nGroup )
	{
		listeners.AddMultipleToTail( nGroup - listeners.Count() + 1 );
	}

	if ( listeners[nGroup].Count() <= nType )
	{
		listeners[nGroup].AddMultipleToTail( nType - listeners[nGroup].Count() + 1 );
	}

	Assert( listeners[nGroup][nType].Find( pListener ) < 0 );
	listeners[nGroup][nType].AddToTail( pListener );
}

void CNetworkManager::RemoveListener( NetworkMessageRoute_t route, int nGroup, int nType, INetworkMessageListener *pListener )
{
	CUtlVector< CUtlVector< CUtlVector < INetworkMessageListener* > > > &listeners = m_Listeners[ route ];
	if ( listeners.Count() > nGroup )
	{
		if( listeners[nGroup].Count() > nType )
		{
			// Maintain order of listeners (not sure if it matters)
			listeners[nGroup][nType].FindAndRemove( pListener );
		}
	}
}


//-----------------------------------------------------------------------------
// Notifies listeners about a network message
//-----------------------------------------------------------------------------
void CNetworkManager::NotifyListeners( NetworkMessageRoute_t route, INetworkMessage *pMessage )
{
	CUtlVector< CUtlVector< CUtlVector < INetworkMessageListener* > > > &listeners = m_Listeners[ route ];

	// based on id, search for installed listeners
	int nGroup = pMessage->GetGroup();
	if ( listeners.Count() > nGroup )
	{
		int nType = pMessage->GetType();
		if ( listeners[nGroup].Count() > nType )
		{
			CUtlVector< INetworkMessageListener* > &list = listeners[nGroup][nType];
			int nCount = list.Count();
			for ( int i = 0; i < nCount; ++i )
			{
				list[i]->OnNetworkMessage( route, pMessage );
			}
		}
	}
}


//-----------------------------------------------------------------------------
// Process messages received by the client
//-----------------------------------------------------------------------------
void CNetworkManager::ProcessClientMessages()
{
	NetworkEvent_t *pEvent = g_pNetworkSystem->FirstNetworkEvent();
	for ( ; pEvent; pEvent = g_pNetworkSystem->NextNetworkEvent( ) )
	{
		switch ( pEvent->m_nType )
		{
			/*
		case NETWORK_EVENT_CONNECTED:
			{
				NetworkConnectionEvent_t* pConnectEvent = static_cast<NetworkConnectionEvent_t*>( pEvent );
				m_pClientToServerConnection = pConnectEvent->m_pChannel;
			}
			break;

		case NETWORK_EVENT_DISCONNECTED:
			{
				NetworkDisconnectionEvent_t* pDisconnectEvent = static_cast<NetworkDisconnectionEvent_t*>( pEvent );
				Assert( m_pClientToServerConnection == pDisconnectEvent->m_pChannel );
				if ( m_pClientToServerConnection == pDisconnectEvent->m_pChannel )
				{
					m_pClientToServerConnection = NULL;
				}
			}
			break;
		*/

		case NETWORK_EVENT_MESSAGE_RECEIVED:
			{
				NetworkMessageReceivedEvent_t* pPacketEvent = static_cast<NetworkMessageReceivedEvent_t*>( pEvent );
				NotifyListeners( NETWORK_MESSAGE_SERVER_TO_CLIENT, pPacketEvent->m_pNetworkMessage );
			}
			break;
		}
	}
}


//-----------------------------------------------------------------------------
// Process messages received by the server
//-----------------------------------------------------------------------------
void CNetworkManager::ProcessServerMessages()
{
	NetworkEvent_t *pEvent = g_pNetworkSystem->FirstNetworkEvent();
	for ( ; pEvent; pEvent = g_pNetworkSystem->NextNetworkEvent( ) )
	{
		switch ( pEvent->m_nType )
		{
		case NETWORK_EVENT_CONNECTED:
			{
				NetworkConnectionEvent_t* pConnectEvent = static_cast<NetworkConnectionEvent_t*>( pEvent );
				m_ServerToClientConnection.AddToTail( pConnectEvent->m_pChannel );
			}
			break;

		case NETWORK_EVENT_DISCONNECTED:
			{
				NetworkDisconnectionEvent_t* pDisconnectEvent = static_cast<NetworkDisconnectionEvent_t*>( pEvent );
				m_ServerToClientConnection.FindAndRemove( pDisconnectEvent->m_pChannel );
			}
			break;
		
		case NETWORK_EVENT_MESSAGE_RECEIVED:
			{
				NetworkMessageReceivedEvent_t* pPacketEvent = static_cast<NetworkMessageReceivedEvent_t*>( pEvent );
				NotifyListeners( NETWORK_MESSAGE_CLIENT_TO_SERVER, pPacketEvent->m_pNetworkMessage );
			}
			break;
		}
	}
}


//-----------------------------------------------------------------------------
// Per-frame update
//-----------------------------------------------------------------------------
void CNetworkManager::Update( )
{
	if ( IsClient() )
	{
		g_pNetworkSystem->ClientSendMessages();
	}

	if ( IsServer() )
	{
		g_pNetworkSystem->ServerReceiveMessages();
		ProcessServerMessages();
		g_pNetworkSystem->ServerSendMessages();
	}

	if ( IsClient() )
	{
		g_pNetworkSystem->ClientReceiveMessages();
		ProcessClientMessages();
	}
}





================================================
FILE: app/legion/networkmanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the networking code in the game 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef NETWORKMANAGER_H
#define NETWORKMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "networksystem/inetworksystem.h"
#include "inetworkmessagelistener.h"


//-----------------------------------------------------------------------------
// Default ports
//-----------------------------------------------------------------------------
enum
{
	LEGION_DEFAULT_SERVER_PORT = 0xFFFF,
	LEGION_DEFAULT_CLIENT_PORT = 0xFFFF,
};


//-----------------------------------------------------------------------------
// Interface used to create network messages
//-----------------------------------------------------------------------------
abstract_class INetworkMessageFactory
{
public:
	// Creates the menu
	virtual INetworkMessage *CreateNetworkMessage( ) = 0;
	
	// Used to build a list during construction
	virtual INetworkMessageFactory *GetNextFactory( ) = 0;

protected:
	virtual ~INetworkMessageFactory() {}
};


//-----------------------------------------------------------------------------
// Network management system
//-----------------------------------------------------------------------------
class CNetworkManager : public CGameManager<>
{
public:
	// Inherited from IGameManager
	virtual bool Init();
	virtual void Update( );
	virtual void Shutdown();

	// Are we a client?/Are we a server? (we can be both)
	bool IsClient();
	bool IsServer();

	// If we are a client, are we connected to the server?
	bool IsClientConnected();

	// Start a server up
	bool StartServer( unsigned short nServerListenPort = LEGION_DEFAULT_SERVER_PORT );
	void ShutdownServer( );

	// Start a client up
	bool StartClient( unsigned short nClientListenPort = LEGION_DEFAULT_CLIENT_PORT );
	void ShutdownClient( );

	// Connects the client to a server
	bool ConnectClientToServer( const char *pServerName, unsigned short nServerListenPort = LEGION_DEFAULT_SERVER_PORT );
	void DisconnectClientFromServer();

	// Add, remove network message listeners
	void AddListener( NetworkMessageRoute_t route, int nGroup, int nType, INetworkMessageListener *pListener );
	void RemoveListener( NetworkMessageRoute_t route, int nGroup, int nType, INetworkMessageListener *hListener );

	// Post a network message to the server
	void PostClientToServerMessage( INetworkMessage *pMessage );

	// Broadcast a network message to all clients
	void BroadcastServerToClientMessage( INetworkMessage *pMessage );

	// Start up a game where the local player is playing
	bool HostGame();
	void StopHostingGame();

	// Call to register methods which can construct menus w/ particular ids
	// NOTE: This method is not expected to be called directly. Use the REGISTER_NETWORK_MESSAGE macro instead
	// It returns the previous head of the list of factories
	static INetworkMessageFactory* RegisterNetworkMessage( INetworkMessageFactory *pMenuFactory );

private:
	// Process messages received by the client
	void ProcessClientMessages();

	// Process messages received by the server
	void ProcessServerMessages();

	// Notifies listeners about a network message
	void NotifyListeners( NetworkMessageRoute_t route, INetworkMessage *pMessage );

	bool m_bIsClient;
	bool m_bIsServer;

	INetChannel *m_pClientToServerConnection;
	CUtlVector< INetChannel* > m_ServerToClientConnection;
	CUtlVector< CUtlVector< CUtlVector < INetworkMessageListener* > > > m_Listeners[ NETWORK_MESSAGE_ROUTE_COUNT ];
	static INetworkMessageFactory* m_pFirstFactory;
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CNetworkManager *g_pNetworkManager;


//-----------------------------------------------------------------------------
// Macro used to register menus with the menu system
// For example, add the line REGISTER_NETWORK_MESSAGE( CNetworkMessageChat );
// into the file defining the chat message
//-----------------------------------------------------------------------------
template < class T >
class CNetworkMessageFactory : public INetworkMessageFactory
{
public:
	CNetworkMessageFactory( )
	{
		m_pNextFactory = CNetworkManager::RegisterNetworkMessage( this );
	}

	// Creates the network message
	virtual INetworkMessage *CreateNetworkMessage( )
	{
		return new T;
	}

	// Used to build a list during construction
	virtual INetworkMessageFactory *GetNextFactory( )
	{
		return m_pNextFactory;
	}

private:
	INetworkMessage *m_pMessage;
	INetworkMessageFactory *m_pNextFactory;
};

#define REGISTER_NETWORK_MESSAGE( _className )	\
	static CNetworkMessageFactory< _className > __s_Factory ## _className


#endif // NETWORKMANAGER_H




================================================
FILE: app/legion/networkmessages.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: A network message that sends chat messages
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "networkmessages.h"
#include "networkmanager.h"
#include "tier1/bitbuf.h"


//-----------------------------------------------------------------------------
// Chat network message
//-----------------------------------------------------------------------------
REGISTER_NETWORK_MESSAGE( CNetworkMessage_Chat );

CNetworkMessage_Chat::CNetworkMessage_Chat()
{ 
	SetReliable( false ); 
}

bool CNetworkMessage_Chat::WriteToBuffer( bf_write &buffer )
{
	int nLen = m_Message.Length();
	buffer.WriteShort( nLen );
	if ( nLen )
	{
		buffer.WriteBytes( m_Message.Get(), nLen );
	}
	return !buffer.IsOverflowed();
}

bool CNetworkMessage_Chat::ReadFromBuffer( bf_read &buffer )
{
	int nLen = buffer.ReadShort();
	if ( nLen )
	{
		m_Message.SetLength( nLen + 1 );
		char *pDest = m_Message.Get();
		buffer.ReadBytes( pDest, nLen );
		pDest[ nLen ] = 0;
	}
	else
	{
		m_Message.Set( NULL );
	}
	return !buffer.IsOverflowed();
}




================================================
FILE: app/legion/networkmessages.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the networking code in the game 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef NETWORKMESSAGES_H
#define NETWORKMESSAGES_H

#ifdef _WIN32
#pragma once
#endif


#include "networksystem/inetworkmessage.h"
#include "tier1/utlstring.h"


//-----------------------------------------------------------------------------
// Network message group
//-----------------------------------------------------------------------------
enum LegionNetworkGroups_t
{
	LEGION_NETMESSAGE_GROUP = NETWORKSYSTEM_FIRST_GROUP,
};


//-----------------------------------------------------------------------------
// Network message types
//-----------------------------------------------------------------------------
enum LegionNetworkTypes_t
{
	CHAT_MESSAGE = 0,
};


//-----------------------------------------------------------------------------
// Chat network message
//-----------------------------------------------------------------------------
class CNetworkMessage_Chat : public CNetworkMessage
{
public:
	CNetworkMessage_Chat();

	DECLARE_BASE_MESSAGE( LEGION_NETMESSAGE_GROUP, CHAT_MESSAGE, "Chat Message" )

	CUtlString m_Message;
};

#endif // NETWORKMESSAGES_H





================================================
FILE: app/legion/physicsmanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the physics 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "physicsmanager.h"
#include "legion.h"
#include "tier2/tier2.h"
#include "tier1/convar.h"



//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
static CPhysicsManager s_PhysicsManager;
extern CPhysicsManager *g_pPhysicsManager = &s_PhysicsManager;

	
//-----------------------------------------------------------------------------
// Per-frame update
//-----------------------------------------------------------------------------
void CPhysicsManager::Update( )
{
}




================================================
FILE: app/legion/physicsmanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the physics 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef PHYSICSMANAGER_H
#define PHYSICSMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "tier2/keybindings.h"
#include "tier1/commandbuffer.h"
#include "bitvec.h"


//-----------------------------------------------------------------------------
// Input management
//-----------------------------------------------------------------------------
class CPhysicsManager : public CGameManager<>
{
public:
	// Inherited from IGameManager
	virtual void Update( );
	virtual bool PerformsSimulation() { return true; }

private:
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CPhysicsManager *g_pPhysicsManager;


#endif // PHYSICSMANAGER_H




================================================
FILE: app/legion/rendermanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the rendering 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "rendermanager.h"
#include "legion.h"
#include "uimanager.h"
#include "worldmanager.h"
#include "materialsystem/imaterialsystem.h"
#include "tier2/tier2.h"


//-----------------------------------------------------------------------------
// Camera property
//-----------------------------------------------------------------------------
DEFINE_FIXEDSIZE_ALLOCATOR( CCameraProperty, 1, CMemoryPool::GROW_SLOW );


CCameraProperty::CCameraProperty()
{
	m_Origin.Init();
	m_Angles.Init();
	m_Velocity.Init();
	m_AngVelocity.Init();
}

void CCameraProperty::GetForward( Vector *pForward )
{
	AngleVectors( m_Angles, pForward );
}


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
static CRenderManager s_RenderManager;
extern CRenderManager *g_pRenderManager = &s_RenderManager;

	
//-----------------------------------------------------------------------------
// Game initialization
//-----------------------------------------------------------------------------
bool CRenderManager::Init()
{
	m_bRenderWorldFullscreen = true;
	return true;
}

void CRenderManager::Shutdown()
{
}

	
//-----------------------------------------------------------------------------
// Level initialization
//-----------------------------------------------------------------------------
LevelRetVal_t CRenderManager::LevelInit( bool bFirstCall )
{
	return FINISHED;
}

LevelRetVal_t CRenderManager::LevelShutdown( bool bFirstCall )
{
	return FINISHED;
}

	
//-----------------------------------------------------------------------------
// Property allocation
//-----------------------------------------------------------------------------
CCameraProperty *CRenderManager::CreateCameraProperty()
{
	return new CCameraProperty;
}

void CRenderManager::DestroyCameraProperty( CCameraProperty *pProperty )
{
	delete pProperty;
}


//-----------------------------------------------------------------------------
// Sets the rectangle to draw into
//-----------------------------------------------------------------------------
void CRenderManager::RenderWorldFullscreen()
{
	m_bRenderWorldFullscreen = true;
}

void CRenderManager::RenderWorldInRect( int x, int y, int nWidth, int nHeight )
{
	m_bRenderWorldFullscreen = false;
	m_nRenderX = x;
	m_nRenderY = y;
	m_nRenderWidth = nWidth;
	m_nRenderHeight = nHeight;
}

	
//-----------------------------------------------------------------------------
// Done completely client-side, want total smoothness, so simulate at render interval
//-----------------------------------------------------------------------------
void CRenderManager::UpdateLocalPlayerCamera()
{
	float dt = IGameManager::DeltaTime();
	CCameraProperty *pCamera = g_pWorldManager->GetLocalPlayer()->m_pCameraProperty;
	VectorMA( pCamera->m_Origin, dt, pCamera->m_Velocity, pCamera->m_Origin );
	VectorMA( pCamera->m_Angles, dt, pCamera->m_AngVelocity, pCamera->m_Angles );
}


//-----------------------------------------------------------------------------
// Per-frame update
//-----------------------------------------------------------------------------
void CRenderManager::Update( )
{
	CMatRenderContextPtr pRenderContext( g_pMaterialSystem );
	if ( GetLevelState() == NOT_IN_LEVEL )
	{
		g_pMaterialSystem->BeginFrame( 0 );
		pRenderContext->ClearColor4ub( 76, 88, 68, 255 ); 
		pRenderContext->ClearBuffers( true, true );
		g_pUIManager->DrawUI();
		g_pMaterialSystem->EndFrame();
		g_pMaterialSystem->SwapBuffers();
		return;
	}

	UpdateLocalPlayerCamera();

	g_pMaterialSystem->BeginFrame( 0 );
	pRenderContext->ClearColor4ub( 0, 0, 0, 255 ); 
	pRenderContext->ClearBuffers( true, true );
	RenderWorld();
	g_pUIManager->DrawUI();
	g_pMaterialSystem->EndFrame();
	g_pMaterialSystem->SwapBuffers();
}


//-----------------------------------------------------------------------------
// Sets up the camera
//-----------------------------------------------------------------------------
void CRenderManager::SetupCameraRenderState( )
{
	CCameraProperty *pCamera = g_pWorldManager->GetLocalPlayer()->m_pCameraProperty;

	matrix3x4_t cameraToWorld;
	AngleMatrix( pCamera->m_Angles, pCamera->m_Origin, cameraToWorld );

	matrix3x4_t matRotate;
	matrix3x4_t matRotateZ;
	MatrixBuildRotationAboutAxis( Vector(0,0,1), -90, matRotateZ );
	MatrixMultiply( cameraToWorld, matRotateZ, matRotate );

	matrix3x4_t matRotateX;
	MatrixBuildRotationAboutAxis( Vector(1,0,0), 90, matRotateX );
	MatrixMultiply( matRotate, matRotateX, matRotate );

	matrix3x4_t view;
	MatrixInvert( matRotate, view );

	CMatRenderContextPtr pRenderContext( g_pMaterialSystem );
	pRenderContext->MatrixMode( MATERIAL_VIEW );
	pRenderContext->LoadMatrix( view );
}

	
//-----------------------------------------------------------------------------
// Set up a projection matrix for a 90 degree fov
//-----------------------------------------------------------------------------

// FIXME: Better control over Z range
#define ZNEAR 0.1f
#define ZFAR 10000.0f

void CRenderManager::SetupProjectionMatrix( int nWidth, int nHeight, float flFOV )
{
	VMatrix proj;
	float flZNear = ZNEAR;
	float flZFar = ZFAR;
	float flApsectRatio = (nHeight != 0.0f) ? (float)nWidth / (float)nHeight : 100.0f;

	float halfWidth = tan( flFOV * M_PI / 360.0 );
	float halfHeight = halfWidth / flApsectRatio;

	memset( proj.Base(), 0, sizeof( proj ) );
	proj[0][0]  = 1.0f / halfWidth;
	proj[1][1]  = 1.0f / halfHeight;
	proj[2][2] = flZFar / ( flZNear - flZFar );
	proj[3][2] = -1.0f;
	proj[2][3] = flZNear * flZFar / ( flZNear - flZFar );

	CMatRenderContextPtr pRenderContext( g_pMaterialSystem );
	pRenderContext->MatrixMode( MATERIAL_PROJECTION );
	pRenderContext->LoadMatrix( proj );
}


//-----------------------------------------------------------------------------
// Set up a orthographic projection matrix
//-----------------------------------------------------------------------------
void CRenderManager::SetupOrthoMatrix( int nWidth, int nHeight )
{
	CMatRenderContextPtr pRenderContext( g_pMaterialSystem );
	pRenderContext->MatrixMode( MATERIAL_PROJECTION );
	pRenderContext->LoadIdentity();
	pRenderContext->Ortho( 0, 0, nWidth, nHeight, -1.0f, 1.0f );
}


//-----------------------------------------------------------------------------
// Renders the world
//-----------------------------------------------------------------------------
void CRenderManager::RenderWorld()
{
	CMatRenderContextPtr pRenderContext( g_pMaterialSystem );
	pRenderContext->MatrixMode( MATERIAL_PROJECTION );
	pRenderContext->PushMatrix();

	pRenderContext->MatrixMode( MATERIAL_VIEW );
	pRenderContext->PushMatrix();

	pRenderContext->MatrixMode( MATERIAL_MODEL );
	pRenderContext->PushMatrix();
	pRenderContext->LoadIdentity();

	if ( m_bRenderWorldFullscreen )
	{
		m_nRenderX = m_nRenderY = 0;
		pRenderContext->GetRenderTargetDimensions( m_nRenderWidth, m_nRenderHeight );
	}

	pRenderContext->DepthRange( 0, 1 );
	pRenderContext->Viewport( m_nRenderX, m_nRenderY, m_nRenderWidth, m_nRenderHeight );

	SetupProjectionMatrix( m_nRenderWidth, m_nRenderHeight, 90 );

	SetupCameraRenderState();

	g_pWorldManager->DrawWorld();

	pRenderContext->MatrixMode( MATERIAL_PROJECTION );
	pRenderContext->PopMatrix();

	pRenderContext->MatrixMode( MATERIAL_VIEW );
	pRenderContext->PopMatrix();

	pRenderContext->MatrixMode( MATERIAL_MODEL );
	pRenderContext->PopMatrix();
}


================================================
FILE: app/legion/rendermanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of rendering 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef RENDERMANAGER_H
#define RENDERMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "tier1/mempool.h"
#include "mathlib/mathlib.h"


//-----------------------------------------------------------------------------
// Physics property for entities
//-----------------------------------------------------------------------------
class CCameraProperty
{
	DECLARE_FIXEDSIZE_ALLOCATOR( CCameraProperty );

public:
	CCameraProperty();
	void GetForward( Vector *pForward );

	// Array used for fixed-timestep simulation
	Vector m_Origin;
	QAngle m_Angles;
	Vector m_Velocity;
	QAngle m_AngVelocity;

private:
	friend class CRenderManager;
};


//-----------------------------------------------------------------------------
// Rendering management 
//-----------------------------------------------------------------------------
class CRenderManager : public CGameManager<>
{
public:
	// Inherited from IGameManager
	virtual bool Init();
	virtual LevelRetVal_t LevelInit( bool bFirstCall );
	virtual void Update( );
	virtual LevelRetVal_t LevelShutdown( bool bFirstCall );
	virtual void Shutdown();

	// Property allocation
	CCameraProperty *CreateCameraProperty();
	void DestroyCameraProperty( CCameraProperty *pProperty );

	void RenderWorldInRect( int x, int y, int nWidth, int nHeight );
	void RenderWorldFullscreen();

private:
	// Set up a projection matrix for a 90 degree fov
	void SetupProjectionMatrix( int nWidth, int nHeight, float flFOV );

	// Set up a orthographic projection matrix
	void SetupOrthoMatrix( int nWidth, int nHeight );

	// Sets up the camera
	void SetupCameraRenderState( );

	// Draws the world
	void RenderWorld();

	// Done completely client-side, want total smoothness, so simulate at render interval
	void UpdateLocalPlayerCamera();

	bool m_bRenderWorldFullscreen;
	int m_nRenderX;
	int m_nRenderY;
	int m_nRenderWidth;
	int m_nRenderHeight;
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CRenderManager *g_pRenderManager;


#endif // RENDERMANAGER_H




================================================
FILE: app/legion/uimanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the UI 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "uimanager.h"
#include "legion.h"
#include "appframework/vguimatsysapp.h"
#include "vgui/IVGui.h"
#include "vgui/ISurface.h"
#include "VGuiMatSurface/IMatSystemSurface.h"
#include "vgui_controls/controls.h"
#include "vgui/ILocalize.h"
#include "vgui_controls/EditablePanel.h"
#include "vgui_controls/AnimationController.h"
#include "filesystem.h"
#include "tier3/tier3.h"
#include "vgui_controls/consoledialog.h"
#include "inputmanager.h"


//-----------------------------------------------------------------------------
// Console dialog for use in legion
//-----------------------------------------------------------------------------
class CLegionConsoleDialog : public vgui::CConsoleDialog
{
	DECLARE_CLASS_SIMPLE( CLegionConsoleDialog, vgui::CConsoleDialog );

public:
	CLegionConsoleDialog( vgui::Panel *pParent, const char *pName );
	virtual ~CLegionConsoleDialog();

	virtual void OnClose();
	MESSAGE_FUNC_CHARPTR( OnCommandSubmitted, "CommandSubmitted", command );
};


CLegionConsoleDialog::CLegionConsoleDialog( vgui::Panel *pParent, const char *pName ) : BaseClass ( pParent, pName )
{
	AddActionSignalTarget( this );
}

CLegionConsoleDialog::~CLegionConsoleDialog()
{
	g_pUIManager->HideConsole( );
}


//-----------------------------------------------------------------------------
// A command was sent by the console
//-----------------------------------------------------------------------------
void CLegionConsoleDialog::OnCommandSubmitted( const char *pCommand )
{
	g_pInputManager->AddCommand( pCommand );
}


//-----------------------------------------------------------------------------
// Deals with close
//-----------------------------------------------------------------------------
void CLegionConsoleDialog::OnClose()
{	 
	g_pUIManager->HideConsole( );
}



//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
static CUIManager s_UIManager;
extern CUIManager *g_pUIManager = &s_UIManager;


static const char *s_pRootPanelNames[UI_ROOT_PANEL_COUNT] = 
{
	"RootGamePanel",
	"RootMenuPanel",
	"RootToolsPanel",
};


//-----------------------------------------------------------------------------
// Constructor
//-----------------------------------------------------------------------------
CUIManager::CUIManager()
{
}


//-----------------------------------------------------------------------------
// Init, shutdown
//-----------------------------------------------------------------------------
bool CUIManager::Init()
{
	COMPILE_TIME_ASSERT( sizeof(s_pRootPanelNames) / sizeof(const char*) == UI_ROOT_PANEL_COUNT );

	// load the base localization file
	if (! vgui::scheme()->LoadSchemeFromFile("resource/legion.res", "Legion" ) )
		return false;

	vgui::filesystem()->AddSearchPath( "platform", "PLATFORM" );
	vgui::localize()->AddFile( vgui::filesystem(), "Resource/vgui_%language%.txt" );

	// start vgui
	g_pVGui->Start();

	// Run a frame to get the embedded panel to be the right size
	g_pVGui->RunFrame();

	int w, h;
	m_hEmbeddedPanel = g_pVGuiSurface->GetEmbeddedPanel();
	vgui::ipanel()->GetSize( m_hEmbeddedPanel, w, h );

	// add our root panels
	for ( int i = 0; i < UI_ROOT_PANEL_COUNT; ++i )
	{
		m_pRootPanels[i] = new vgui::EditablePanel( NULL, s_pRootPanelNames[i] );
		m_pRootPanels[i]->SetParent( m_hEmbeddedPanel );
		m_pRootPanels[i]->SetZPos( i );
		m_pRootPanels[i]->SetBounds( 0, 0, w, h );
		m_pRootPanels[i]->SetPaintBorderEnabled( false );
		m_pRootPanels[i]->SetPaintBackgroundEnabled( false );
		m_pRootPanels[i]->SetPaintEnabled( false );
		m_pRootPanels[i]->SetKeyBoardInputEnabled( i != UI_ROOT_GAME );
		m_pRootPanels[i]->SetMouseInputEnabled( i != UI_ROOT_GAME );
		m_pRootPanels[i]->SetVisible( false );
		m_pRootPanels[i]->SetCursor( vgui::dc_crosshair );
		m_pRootPanels[i]->SetAutoResize( vgui::Panel::PIN_TOPLEFT, vgui::Panel::AUTORESIZE_DOWNANDRIGHT, 0, 0, 0, 0 );
	}

	m_hConsole = NULL;

	vgui::surface()->Invalidate( m_hEmbeddedPanel );
	return true;
}

void CUIManager::Shutdown()
{
	g_pVGui->Stop();
}


//-----------------------------------------------------------------------------
// Sets particular root panels to be visible
//-----------------------------------------------------------------------------
void CUIManager::EnablePanel( UIRootPanel_t id, bool bEnable )
{
	m_pRootPanels[id]->SetVisible( bEnable );
}

	
//-----------------------------------------------------------------------------
// Toggles the console
//-----------------------------------------------------------------------------
void CUIManager::ToggleConsole( const CCommand &args )
{
	if ( !m_hConsole.Get() )
	{
		m_hConsole = new CLegionConsoleDialog( m_pRootPanels[UI_ROOT_TOOLS], "Console" );

		// set the console to taking up most of the right-half of the screen
		int swide, stall;
		vgui::surface()->GetScreenSize(swide, stall);
		int offset = vgui::scheme()->GetProportionalScaledValue(16);

		m_hConsole->SetBounds(
			swide / 2 - (offset * 4),
			offset,
			(swide / 2) + (offset * 3),
			stall - (offset * 8));

		m_hConsole->SetVisible( false );
	}

	bool bMakeVisible = !m_hConsole->IsVisible();
	EnablePanel( UI_ROOT_TOOLS, bMakeVisible );
	if ( bMakeVisible )
	{
		m_hConsole->Activate();
	}
	else
	{
		m_hConsole->Hide();
	}
}


//-----------------------------------------------------------------------------
// Hides the console
//-----------------------------------------------------------------------------
void CUIManager::HideConsole()
{
	EnablePanel( UI_ROOT_TOOLS, false );
	if ( m_hConsole.Get() )
	{
		m_hConsole->SetVisible( false );
	}
}


//-----------------------------------------------------------------------------
// Per-frame update
//-----------------------------------------------------------------------------
void CUIManager::Update( )
{
	vgui::GetAnimationController()->UpdateAnimations( IGameManager::CurrentTime() );
	g_pVGui->RunFrame();
	if ( !g_pVGui->IsRunning() )
	{
		IGameManager::Stop();
	}
}


//-----------------------------------------------------------------------------
// Attempt to process an input event, return true if it sholdn't be chained to the rest of the game
//-----------------------------------------------------------------------------
bool CUIManager::ProcessInputEvent( const InputEvent_t& event )
{
	return g_pMatSystemSurface->HandleInputEvent( event );
}


//-----------------------------------------------------------------------------
// Draws the UI
//-----------------------------------------------------------------------------
void CUIManager::DrawUI()
{
	g_pVGuiSurface->PaintTraverseEx( m_hEmbeddedPanel, true );
}

	
//-----------------------------------------------------------------------------
// Push, pop menus
//-----------------------------------------------------------------------------
vgui::Panel *CUIManager::GetRootPanel( UIRootPanel_t id )
{
	return m_pRootPanels[id];
}




================================================
FILE: app/legion/uimanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: The main manager of the UI 
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef UIMANAGER_H
#define UIMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "vgui/vgui.h"
#include "tier1/convar.h"
#include "vgui_controls/panel.h"
#include "vgui_controls/phandle.h"


//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct InputEvent_t;
class CLegionConsoleDialog;

namespace vgui
{
	class Panel;
}


//-----------------------------------------------------------------------------
// Enum indicating the various main UI panels
// NOTE: The order in which they appear here is the order in which they will draw
//-----------------------------------------------------------------------------
enum UIRootPanel_t
{
	UI_ROOT_GAME = 0,
	UI_ROOT_MENU,
	UI_ROOT_TOOLS,

	UI_ROOT_PANEL_COUNT,
};


//-----------------------------------------------------------------------------
// UI management
//-----------------------------------------------------------------------------
class CUIManager : public CGameManager<>
{
public:
	CUIManager();

	// Inherited from IGameManager
	virtual bool Init();
	virtual void Update( );
	virtual void Shutdown();

	// Root panels
	vgui::Panel *GetRootPanel( UIRootPanel_t id );

	// Sets particular root panels to be visible
	void EnablePanel( UIRootPanel_t id, bool bEnable );

	// Attempt to process an input event, return true if it sholdn't be chained to the rest of the game
	bool ProcessInputEvent( const InputEvent_t& event );

	// Draws the UI
	void DrawUI();

	// Hides the console
	void HideConsole();

private:
	CON_COMMAND_MEMBER_F( CUIManager, "toggleconsole", ToggleConsole, "Toggle Console", 0 );

	vgui::VPANEL m_hEmbeddedPanel;
	vgui::Panel *m_pRootPanels[ UI_ROOT_PANEL_COUNT ];
	int m_nWindowWidth;
	int m_nWindowHeight;
	vgui::DHANDLE< CLegionConsoleDialog > m_hConsole;
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CUIManager *g_pUIManager;


#endif // UIMANAGER_H




================================================
FILE: app/legion/worldmanager.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Contains all world state--the main game database
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#include "worldmanager.h"
#include "legion.h"
#include "heightfield.h"
#include "rendermanager.h"

//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
static CWorldManager s_WorldManager;
extern CWorldManager *g_pWorldManager = &s_WorldManager;


//-----------------------------------------------------------------------------
// ConVars
//-----------------------------------------------------------------------------
static ConVar cam_forwardspeed( "cam_forwardspeed", "100", FCVAR_CHEAT, "Sets the camera forward speed" );
static ConVar cam_backwardspeed( "cam_backwardspeed", "100", FCVAR_CHEAT, "Sets the camera backward speed" );


//-----------------------------------------------------------------------------
// Constructor, destructor
//-----------------------------------------------------------------------------
CWorldManager::CWorldManager()
{
	m_pHeightField = NULL;
}

CWorldManager::~CWorldManager()
{
	Assert( m_pHeightField == NULL );
}


//-----------------------------------------------------------------------------
// Level init, shutdown
//-----------------------------------------------------------------------------
LevelRetVal_t CWorldManager::LevelInit( bool bFirstCall )
{
	if ( !bFirstCall )
		return FINISHED;

	Assert( !m_pHeightField );
	m_pHeightField = new CHeightField( 6, 6, 4 );
	if ( !m_pHeightField->LoadHeightFromFile( "maps/testheight.psd" ) )
		return FAILED;

	CreateEntities();
	SetInitialLocalPlayerPosition();
	return FINISHED;
}

LevelRetVal_t CWorldManager::LevelShutdown( bool bFirstCall )
{
	if ( !bFirstCall )
		return FINISHED;

	DestroyEntities();

	if ( m_pHeightField )
	{
		delete m_pHeightField;
		m_pHeightField = NULL;
	}
	return FINISHED;
}


//-----------------------------------------------------------------------------
// Create/ destroy entities
//-----------------------------------------------------------------------------
void CWorldManager::CreateEntities()
{
	m_PlayerEntity.m_pCameraProperty = g_pRenderManager->CreateCameraProperty();
}

void CWorldManager::DestroyEntities()
{
	g_pRenderManager->DestroyCameraProperty( m_PlayerEntity.m_pCameraProperty );
}


//-----------------------------------------------------------------------------
// Gets the camera to world matrix
//-----------------------------------------------------------------------------
CPlayerEntity* CWorldManager::GetLocalPlayer()
{
	return &m_PlayerEntity;
}


//-----------------------------------------------------------------------------
// Sets the initial camera position
//-----------------------------------------------------------------------------
void CWorldManager::SetInitialLocalPlayerPosition()
{
	float flDistance = 1024.0;
	Vector vecCameraDirection( 1.0f, 1.0f, -0.5f );
	VectorNormalize( vecCameraDirection );

	VectorMA( Vector( 512, 512, 0 ), -flDistance, vecCameraDirection, m_PlayerEntity.m_pCameraProperty->m_Origin );

	QAngle angles;
	VectorAngles( vecCameraDirection, m_PlayerEntity.m_pCameraProperty->m_Angles );

}


//-----------------------------------------------------------------------------
// Draws the UI
//-----------------------------------------------------------------------------
void CWorldManager::DrawWorld()
{
	m_pHeightField->Draw( );
}


//-----------------------------------------------------------------------------
// Commands
//-----------------------------------------------------------------------------
void CWorldManager::ForwardStart( const CCommand &args )
{
	CCameraProperty *pCamera = m_PlayerEntity.m_pCameraProperty;
	
	Vector vecForward;
	pCamera->GetForward( &vecForward );
	
	VectorMA( pCamera->m_Velocity, cam_forwardspeed.GetFloat(), vecForward, pCamera->m_Velocity );
}

void CWorldManager::ForwardStop( const CCommand &args )
{
	CCameraProperty *pCamera = m_PlayerEntity.m_pCameraProperty;

	Vector vecForward;
	pCamera->GetForward( &vecForward );

	VectorMA( pCamera->m_Velocity, -cam_forwardspeed.GetFloat(), vecForward, pCamera->m_Velocity );
}

void CWorldManager::BackwardStart( const CCommand &args )
{
	CCameraProperty *pCamera = m_PlayerEntity.m_pCameraProperty;

	Vector vecForward;
	pCamera->GetForward( &vecForward );

	VectorMA( pCamera->m_Velocity, -cam_backwardspeed.GetFloat(), vecForward, pCamera->m_Velocity );
}

void CWorldManager::BackwardStop( const CCommand &args )
{
	CCameraProperty *pCamera = m_PlayerEntity.m_pCameraProperty;

	Vector vecForward;
	pCamera->GetForward( &vecForward );

	VectorMA( pCamera->m_Velocity, cam_backwardspeed.GetFloat(), vecForward, pCamera->m_Velocity );
}


================================================
FILE: app/legion/worldmanager.h
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Contains all world state--the main game database
//
// $Revision: $
// $NoKeywords: $
//===========================================================================//

#ifndef WORLDMANAGER_H
#define WORLDMANAGER_H

#ifdef _WIN32
#pragma once
#endif

#include "gamemanager.h"
#include "mathlib/mathlib.h"
#include "tier1/convar.h"


//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class CHeightField;
class CCameraProperty;


//-----------------------------------------------------------------------------
// Entity types
//-----------------------------------------------------------------------------
class CPlayerEntity
{
public:
	CCameraProperty *m_pCameraProperty;
};


//-----------------------------------------------------------------------------
// World state
//-----------------------------------------------------------------------------
class CWorldManager : public CGameManager<>
{
public:
	CWorldManager();
	virtual ~CWorldManager();

	// Inherited from IGameManager
	virtual LevelRetVal_t LevelInit( bool bFirstCall );
//	virtual void Update( );
	virtual LevelRetVal_t LevelShutdown( bool bFirstCall );

	// Draws the world
	void DrawWorld();

	// Gets the local player
	CPlayerEntity *GetLocalPlayer();

private:
	CON_COMMAND_MEMBER_F( CWorldManager, "+forward", ForwardStart, "Start forward movement", 0 );
	CON_COMMAND_MEMBER_F( CWorldManager, "-forward", ForwardStop, "Stop forward movement", 0 );
	CON_COMMAND_MEMBER_F( CWorldManager, "+back", BackwardStart, "Start backward movement", 0 );
	CON_COMMAND_MEMBER_F( CWorldManager, "-back", BackwardStop, "Stop backward movement", 0 );

	// Creates, destroys entities
	void CreateEntities();
	void DestroyEntities();

	// Sets the initial camera position
	void SetInitialLocalPlayerPosition();

	CHeightField *m_pHeightField;

	CPlayerEntity m_PlayerEntity;
};


//-----------------------------------------------------------------------------
// Singleton accessor
//-----------------------------------------------------------------------------
extern CWorldManager *g_pWorldManager;


#endif // WORLDMANAGER_H




================================================
FILE: appframework/appframework.vpc
================================================
//-----------------------------------------------------------------------------
//	APPFRAMEWORK.VPC
//
//	Project Script
//-----------------------------------------------------------------------------

$macro SRCDIR		".."

$include "$SRCDIR\vpc_scripts\source_lib_base.vpc"

$Configuration
{
    $General
    {
		$AdditionalProjectDependencies                  "$BASE;togl"  [!$IS_LIB_PROJECT && $GL]
	}
		
	$Linker [$OSXALL]
	{
		$SystemFrameworks "Carbon;OpenGL;Quartz;Cocoa;IOKit"
	}
}

$Project "appframework"
{
	$Folder	"Source Files"
	{
		$File	"AppSystemGroup.cpp"
		$File	"$SRCDIR\public\filesystem_init.cpp"
		$File	"vguimatsysapp.cpp"	[$WIN32]
		$File	"winapp.cpp"		[$WIN32]
		$File	"posixapp.cpp"		[$POSIX]
		$File	"sdlmgr.cpp"		[$SDL]
		$File	"glmrendererinfo_osx.mm"		[$OSXALL]
	}

	$Folder	"Interface"
	{
		$File	"$SRCDIR\public\appframework\AppFramework.h"
		$File	"$SRCDIR\public\appframework\IAppSystem.h"
		$File	"$SRCDIR\public\appframework\IAppSystemGroup.h"
		$File	"$SRCDIR\public\appframework\tier2app.h"
		$File	"$SRCDIR\public\appframework\tier3app.h"
		$File	"$SRCDIR\public\appframework\VguiMatSysApp.h"
		$File	"$SRCDIR\public\appframework\ilaunchermgr.h"
	}

	$Folder	"Link Libraries"
	{
		$ImpLib togl [!$IS_LIB_PROJECT && $GL]
		$ImpLib SDL2 [!$IS_LIB_PROJECT && $SDL]
	}
}



================================================
FILE: appframework/AppSystemGroup.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Defines a group of app systems that all have the same lifetime
// that need to be connected/initialized, etc. in a well-defined order
//
// $Revision: $
// $NoKeywords: $
//=============================================================================//

#include "appframework/IAppSystemGroup.h"
#include "appframework/IAppSystem.h"
#include "interface.h"
#include "filesystem.h"
#include "filesystem_init.h"

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
//extern ILoggingListener *g_pDefaultLoggingListener;


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
CAppSystemGroup::CAppSystemGroup( CAppSystemGroup *pAppSystemParent ) : m_SystemDict(false, 0, 16)
{
	m_pParentAppSystem = pAppSystemParent;
}


//-----------------------------------------------------------------------------
// Actually loads a DLL
//-----------------------------------------------------------------------------
CSysModule *CAppSystemGroup::LoadModuleDLL( const char *pDLLName )
{
	return Sys_LoadModule( pDLLName );
}


//-----------------------------------------------------------------------------
// Methods to load + unload DLLs
//-----------------------------------------------------------------------------
AppModule_t CAppSystemGroup::LoadModule( const char *pDLLName )
{
	// Remove the extension when creating the name.
	int nLen = Q_strlen( pDLLName ) + 1;
	char *pModuleName = (char*)stackalloc( nLen );
	Q_StripExtension( pDLLName, pModuleName, nLen );

	// See if we already loaded it...
	for ( int i = m_Modules.Count(); --i >= 0; ) 
	{
		if ( m_Modules[i].m_pModuleName )
		{
			if ( !Q_stricmp( pModuleName, m_Modules[i].m_pModuleName ) )
				return i;
		}
	}

	CSysModule *pSysModule = LoadModuleDLL( pDLLName );
	if (!pSysModule)
	{
		Warning("AppFramework : Unable to load module %s!\n", pDLLName );
		return APP_MODULE_INVALID;
	}

	int nIndex = m_Modules.AddToTail();
	m_Modules[nIndex].m_pModule = pSysModule;
	m_Modules[nIndex].m_Factory = 0;
	m_Modules[nIndex].m_pModuleName = (char*)malloc( nLen );
	Q_strncpy( m_Modules[nIndex].m_pModuleName, pModuleName, nLen );

	return nIndex;
}

AppModule_t CAppSystemGroup::LoadModule( CreateInterfaceFn factory )
{
	if (!factory)
	{
		Warning("AppFramework : Unable to load module %p!\n", factory );
		return APP_MODULE_INVALID;
	}

	// See if we already loaded it...
	for ( int i = m_Modules.Count(); --i >= 0; ) 
	{
		if ( m_Modules[i].m_Factory )
		{
			if ( m_Modules[i].m_Factory == factory )
				return i;
		}
	}

	int nIndex = m_Modules.AddToTail();
	m_Modules[nIndex].m_pModule = NULL;
	m_Modules[nIndex].m_Factory = factory;
	m_Modules[nIndex].m_pModuleName = NULL; 
	return nIndex;
}

void CAppSystemGroup::UnloadAllModules()
{
	// NOTE: Iterate in reverse order so they are unloaded in opposite order
	// from loading
	for (int i = m_Modules.Count(); --i >= 0; )
	{
		if ( m_Modules[i].m_pModule )
		{
			Sys_UnloadModule( m_Modules[i].m_pModule );
		}
		if ( m_Modules[i].m_pModuleName )
		{
			free( m_Modules[i].m_pModuleName );
		}
	}
	m_Modules.RemoveAll();
}


//-----------------------------------------------------------------------------
// Methods to add/remove various global singleton systems 
//-----------------------------------------------------------------------------
IAppSystem *CAppSystemGroup::AddSystem( AppModule_t module, const char *pInterfaceName )
{
	if (module == APP_MODULE_INVALID)
		return NULL;

	Assert( (module >= 0) && (module < m_Modules.Count()) );
	CreateInterfaceFn pFactory = m_Modules[module].m_pModule ? Sys_GetFactory( m_Modules[module].m_pModule ) : m_Modules[module].m_Factory;

	int retval;
	void *pSystem = pFactory( pInterfaceName, &retval );
	if ((retval != IFACE_OK) || (!pSystem))
	{
		Warning("AppFramework : Unable to create system %s!\n", pInterfaceName );
		return NULL;
	}

	IAppSystem *pAppSystem = static_cast<IAppSystem*>(pSystem);
	
	int sysIndex = m_Systems.AddToTail( pAppSystem );

	// Inserting into the dict will help us do named lookup later
	MEM_ALLOC_CREDIT();
	m_SystemDict.Insert( pInterfaceName, sysIndex );
	return pAppSystem;
}

static char const *g_StageLookup[] = 
{
	"CREATION",
	"CONNECTION",
	"PREINITIALIZATION",
	"INITIALIZATION",
	"SHUTDOWN",
	"POSTSHUTDOWN",
	"DISCONNECTION",
	"DESTRUCTION",
	"NONE",
};

void CAppSystemGroup::ReportStartupFailure( int nErrorStage, int nSysIndex )
{
	char const *pszStageDesc = "Unknown";
	if ( nErrorStage >= 0 && nErrorStage < ARRAYSIZE( g_StageLookup ) )
	{
		pszStageDesc = g_StageLookup[ nErrorStage ];
	}

	char const *pszSystemName = "(Unknown)";
	for ( int i = m_SystemDict.First(); i != m_SystemDict.InvalidIndex(); i = m_SystemDict.Next( i ) )
	{
		if ( m_SystemDict[ i ] != nSysIndex )
			continue;

		pszSystemName = m_SystemDict.GetElementName( i );
		break;
	}
		 
	// Walk the dictionary
	Warning( "System (%s) failed during stage %s\n", pszSystemName, pszStageDesc );
}

void CAppSystemGroup::AddSystem( IAppSystem *pAppSystem, const char *pInterfaceName )
{
	if ( !pAppSystem )
		return;

	int sysIndex = m_Systems.AddToTail( pAppSystem );

	// Inserting into the dict will help us do named lookup later
	MEM_ALLOC_CREDIT();
	m_SystemDict.Insert( pInterfaceName, sysIndex );
}

void CAppSystemGroup::RemoveAllSystems()
{
	// NOTE: There's no deallcation here since we don't really know
	// how the allocation has happened. We could add a deallocation method
	// to the code in interface.h; although when the modules are unloaded
	// the deallocation will happen anyways
	m_Systems.RemoveAll();
	m_SystemDict.RemoveAll();
}


//-----------------------------------------------------------------------------
// Simpler method of doing the LoadModule/AddSystem thing.
//-----------------------------------------------------------------------------
bool CAppSystemGroup::AddSystems( AppSystemInfo_t *pSystemList )
{
	while ( pSystemList->m_pModuleName[0] )
	{
		AppModule_t module = LoadModule( pSystemList->m_pModuleName );
		IAppSystem *pSystem = AddSystem( module, pSystemList->m_pInterfaceName );
		if ( !pSystem )
		{
			Warning( "Unable to load interface %s from %s\n", pSystemList->m_pInterfaceName, pSystemList->m_pModuleName );
			return false;
		}
		++pSystemList;
	}

	return true;
}


//-----------------------------------------------------------------------------
// Methods to find various global singleton systems 
//-----------------------------------------------------------------------------
void *CAppSystemGroup::FindSystem( const char *pSystemName )
{
	unsigned short i = m_SystemDict.Find( pSystemName );
	if (i != m_SystemDict.InvalidIndex())
		return m_Systems[m_SystemDict[i]];

	// If it's not an interface we know about, it could be an older
	// version of an interface, or maybe something implemented by
	// one of the instantiated interfaces...

	// QUESTION: What order should we iterate this in?
	// It controls who wins if multiple ones implement the same interface
 	for ( i = 0; i < m_Systems.Count(); ++i )
	{
		void *pInterface = m_Systems[i]->QueryInterface( pSystemName );
		if (pInterface)
			return pInterface;
	}

	if ( m_pParentAppSystem )
	{
		void* pInterface = m_pParentAppSystem->FindSystem( pSystemName );
		if ( pInterface )
			return pInterface;
	}

	// No dice..
	return NULL;
}


//-----------------------------------------------------------------------------
// Gets at the parent appsystem group
//-----------------------------------------------------------------------------
CAppSystemGroup *CAppSystemGroup::GetParent()
{
	return m_pParentAppSystem;
}

	
//-----------------------------------------------------------------------------
// Method to connect/disconnect all systems
//-----------------------------------------------------------------------------
bool CAppSystemGroup::ConnectSystems()
{
	for (int i = 0; i < m_Systems.Count(); ++i )
	{
		IAppSystem *sys = m_Systems[i];

		if (!sys->Connect( GetFactory() ))
		{
			ReportStartupFailure( CONNECTION, i );
			return false;
		}
	}
	return true;
}

void CAppSystemGroup::DisconnectSystems()
{
	// Disconnect in reverse order of connection
	for (int i = m_Systems.Count(); --i >= 0; )
	{
		m_Systems[i]->Disconnect();
	}
}


//-----------------------------------------------------------------------------
// Method to initialize/shutdown all systems
//-----------------------------------------------------------------------------
InitReturnVal_t CAppSystemGroup::InitSystems()
{
	for (int i = 0; i < m_Systems.Count(); ++i )
	{
		InitReturnVal_t nRetVal = m_Systems[i]->Init();
		if ( nRetVal != INIT_OK )
		{
			ReportStartupFailure( INITIALIZATION, i );
			return nRetVal;
		}
	}
	return INIT_OK;
}

void CAppSystemGroup::ShutdownSystems()
{
	// Shutdown in reverse order of initialization
	for (int i = m_Systems.Count(); --i >= 0; )
	{
		m_Systems[i]->Shutdown();
	}
}


//-----------------------------------------------------------------------------
// Returns the stage at which the app system group ran into an error
//-----------------------------------------------------------------------------
CAppSystemGroup::AppSystemGroupStage_t CAppSystemGroup::GetErrorStage() const
{
	return m_nErrorStage;
}


//-----------------------------------------------------------------------------
// Gets at a factory that works just like FindSystem
//-----------------------------------------------------------------------------
// This function is used to make this system appear to the outside world to
// function exactly like the currently existing factory system
CAppSystemGroup *s_pCurrentAppSystem;
void *AppSystemCreateInterfaceFn(const char *pName, int *pReturnCode)
{
	void *pInterface = s_pCurrentAppSystem->FindSystem( pName );
	if ( pReturnCode )
	{
		*pReturnCode = pInterface ? IFACE_OK : IFACE_FAILED;
	}
	return pInterface;
}


//-----------------------------------------------------------------------------
// Gets at a class factory for the topmost appsystem group in an appsystem stack
//-----------------------------------------------------------------------------
CreateInterfaceFn CAppSystemGroup::GetFactory()
{
	return AppSystemCreateInterfaceFn;
}

	
//-----------------------------------------------------------------------------
// Main application loop
//-----------------------------------------------------------------------------
int CAppSystemGroup::Run()
{	
	// The factory now uses this app system group
	s_pCurrentAppSystem	= this;

	// Load, connect, init
	int nRetVal = OnStartup();
 	if ( m_nErrorStage != NONE )
		return nRetVal;

	// Main loop implemented by the application
	// FIXME: HACK workaround to avoid vgui porting
	nRetVal = Main();

	// Shutdown, disconnect, unload
	OnShutdown();

	// The factory now uses the parent's app system group
	s_pCurrentAppSystem	= GetParent();

	return nRetVal;
}


//-----------------------------------------------------------------------------
// Virtual methods for override
//-----------------------------------------------------------------------------
int CAppSystemGroup::Startup()
{
	return OnStartup();
}

void CAppSystemGroup::Shutdown()
{
	return OnShutdown();
}


//-----------------------------------------------------------------------------
// Use this version in cases where you can't control the main loop and
// expect to be ticked
//-----------------------------------------------------------------------------
int CAppSystemGroup::OnStartup()
{
	// The factory now uses this app system group
	s_pCurrentAppSystem	= this;

 	m_nErrorStage = NONE;

	// Call an installed application creation function
	if ( !Create() )
	{
		m_nErrorStage = CREATION;
		return -1;
	}

	// Let all systems know about each other
	if ( !ConnectSystems() )
	{
		m_nErrorStage = CONNECTION;
		return -1;
	}

	// Allow the application to do some work before init
	if ( !PreInit() )
	{
		m_nErrorStage = PREINITIALIZATION;
		return -1;
	}

	// Call Init on all App Systems
	int nRetVal = InitSystems();
	if ( nRetVal != INIT_OK )
	{
		m_nErrorStage = INITIALIZATION;
		return -1;
	}

	return nRetVal;
}

void CAppSystemGroup::OnShutdown()
{
	// The factory now uses this app system group
	s_pCurrentAppSystem	= this;

	switch( m_nErrorStage )
	{
	case NONE:
		break;

	case PREINITIALIZATION:
	case INITIALIZATION:
		goto disconnect;
	
	case CREATION:
	case CONNECTION:
		goto destroy;
	}

	// Cal Shutdown on all App Systems
	ShutdownSystems();

	// Allow the application to do some work after shutdown
	PostShutdown();

disconnect:
	// Systems should disconnect from each other
	DisconnectSystems();

destroy:
	// Unload all DLLs loaded in the AppCreate block
	RemoveAllSystems();

	// Have to do this because the logging listeners & response policies may live in modules which are being unloaded
	// @TODO: this seems like a bad legacy practice... app systems should unload their spew handlers gracefully.
//	LoggingSystem_ResetCurrentLoggingState();
//	Assert( g_pDefaultLoggingListener != NULL );
//	LoggingSystem_RegisterLoggingListener( g_pDefaultLoggingListener );

	UnloadAllModules();

	// Call an installed application destroy function
	Destroy();
}


	
//-----------------------------------------------------------------------------
//
// This class represents a group of app systems that are loaded through steam
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Constructor
//-----------------------------------------------------------------------------
CSteamAppSystemGroup::CSteamAppSystemGroup( IFileSystem *pFileSystem, CAppSystemGroup *pAppSystemParent )
{
	m_pFileSystem = pFileSystem;
	m_pGameInfoPath[0] = 0;
}


//-----------------------------------------------------------------------------
// Used by CSteamApplication to set up necessary pointers if we can't do it in the constructor
//-----------------------------------------------------------------------------
void CSteamAppSystemGroup::Setup( IFileSystem *pFileSystem, CAppSystemGroup *pParentAppSystem )
{
	m_pFileSystem = pFileSystem;
	m_pParentAppSystem = pParentAppSystem;
}


//-----------------------------------------------------------------------------
// Loads the module from Steam
//-----------------------------------------------------------------------------
CSysModule *CSteamAppSystemGroup::LoadModuleDLL( const char *pDLLName )
{
	return m_pFileSystem->LoadModule( pDLLName );
}


//-----------------------------------------------------------------------------
// Returns the game info path
//-----------------------------------------------------------------------------
const char *CSteamAppSystemGroup::GetGameInfoPath()	const
{
	return m_pGameInfoPath;
}


//-----------------------------------------------------------------------------
// Sets up the search paths
//-----------------------------------------------------------------------------
bool CSteamAppSystemGroup::SetupSearchPaths( const char *pStartingDir, bool bOnlyUseStartingDir, bool bIsTool )
{
	CFSSteamSetupInfo steamInfo;
	steamInfo.m_pDirectoryName = pStartingDir;
	steamInfo.m_bOnlyUseDirectoryName = bOnlyUseStartingDir;
	steamInfo.m_bToolsMode = bIsTool;
	steamInfo.m_bSetSteamDLLPath = true;
	steamInfo.m_bSteam = m_pFileSystem->IsSteam();
	if ( FileSystem_SetupSteamEnvironment( steamInfo ) != FS_OK )
		return false;

	CFSMountContentInfo fsInfo;
	fsInfo.m_pFileSystem = m_pFileSystem;
	fsInfo.m_bToolsMode = bIsTool;
	fsInfo.m_pDirectoryName = steamInfo.m_GameInfoPath;

	if ( FileSystem_MountContent( fsInfo ) != FS_OK )
		return false;

	// Finally, load the search paths for the "GAME" path.
	CFSSearchPathsInit searchPathsInit;
	searchPathsInit.m_pDirectoryName = steamInfo.m_GameInfoPath;
	searchPathsInit.m_pFileSystem = fsInfo.m_pFileSystem;
	if ( FileSystem_LoadSearchPaths( searchPathsInit ) != FS_OK )
		return false;

	FileSystem_AddSearchPath_Platform( fsInfo.m_pFileSystem, steamInfo.m_GameInfoPath );
	Q_strncpy( m_pGameInfoPath, steamInfo.m_GameInfoPath, sizeof(m_pGameInfoPath) );
	return true;
}



================================================
FILE: appframework/glmdisplaydb_linuxwin.inl
================================================
//========= Copyright  1996-2009, Valve Corporation, All rights reserved. ============//
//
// Purpose: Defines a group of app systems that all have the same lifetime
// that need to be connected/initialized, etc. in a well-defined order
//
// $Revision: $
// $NoKeywords: $
//=============================================================================//

//===============================================================================

GLMRendererInfo::GLMRendererInfo( void )
{
        m_display = NULL;
        Q_memset( &m_info, 0, sizeof( m_info ) );
}

GLMRendererInfo::~GLMRendererInfo( void )
{
        SDLAPP_FUNC;

        if (m_display)
        {
                delete m_display;
                m_display = NULL;
        }
}

// !!! FIXME: sync this function with the Mac version in case anything important has changed.
void GLMRendererInfo::Init( GLMRendererInfoFields *info )
{
        SDLAPP_FUNC;

        m_info = *info;
        m_display = NULL;

        m_info.m_fullscreen = 0;
        m_info.m_accelerated = 1;
        m_info.m_windowed = 1;
        
        m_info.m_ati = true;
        m_info.m_atiNewer = true;

        m_info.m_hasGammaWrites = true;
	m_info.m_cantAttachSRGB = false;

        // If you haven't created a GL context by now (and initialized gGL), you're about to crash.

        m_info.m_hasMixedAttachmentSizes = gGL->m_bHave_GL_EXT_framebuffer_object;
        m_info.m_hasBGRA = gGL->m_bHave_GL_EXT_vertex_array_bgra;

        // !!! FIXME: what do these do on the Mac?
        m_info.m_hasNewFullscreenMode = false;
        m_info.m_hasNativeClipVertexMode = true;

        // if user disabled them
        if (CommandLine()->FindParm("-glmdisableclipplanes"))
        {
                m_info.m_hasNativeClipVertexMode = false;
        }
        
        // or maybe enabled them..
        if (CommandLine()->FindParm("-glmenableclipplanes"))
        {
                m_info.m_hasNativeClipVertexMode = true;
        }
        
#ifdef TOGLES
        m_info.m_hasOcclusionQuery = true;
        m_info.m_hasFramebufferBlit = true;
        m_info.m_hasUniformBuffers = true;
#else
        m_info.m_hasOcclusionQuery = gGL->m_bHave_GL_ARB_occlusion_query;
        m_info.m_hasFramebufferBlit = gGL->m_bHave_GL_EXT_framebuffer_blit || gGL->m_bHave_GL_ARB_framebuffer_object;
        m_info.m_hasUniformBuffers =  gGL->m_bHave_GL_ARB_uniform_buffer;
#endif

        GLint nMaxAniso = 0;
        gGL->glGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &nMaxAniso );
        m_info.m_maxAniso = clamp<int>( nMaxAniso, 0, 16 );
        
        // We don't currently used bindable uniforms, but I've been experimenting with them so I might as well check this in just in case they turn out to be useful.
        m_info.m_hasBindableUniforms = gGL->m_bHave_GL_EXT_bindable_uniform;
        m_info.m_hasBindableUniforms = false;           // !!! FIXME hardwiring this path to false until we see how to accelerate it properly
        m_info.m_maxVertexBindableUniforms = 0;
        m_info.m_maxFragmentBindableUniforms = 0;
        m_info.m_maxBindableUniformSize = 0;
        
        if (m_info.m_hasBindableUniforms)
        {
                gGL->glGetIntegerv(GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT, &m_info.m_maxVertexBindableUniforms);
                gGL->glGetIntegerv(GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT, &m_info.m_maxFragmentBindableUniforms);
                gGL->glGetIntegerv(GL_MAX_BINDABLE_UNIFORM_SIZE_EXT, &m_info.m_maxBindableUniformSize);
                if ( ( m_info.m_maxVertexBindableUniforms < 1 ) || ( m_info.m_maxFragmentBindableUniforms < 1 ) || ( m_info.m_maxBindableUniformSize < ( sizeof( float ) * 4 * 256 ) ) )
                {
                        m_info.m_hasBindableUniforms = false;
                }
        }

        m_info.m_hasPerfPackage1 = true;  // this flag is Mac-specific. We do slower things if you don't have Mac OS X 10.x.y or later. Linux always does the fast path!

        //-------------------------------------------------------------------
        // runtime options that aren't negotiable once set

        m_info.m_hasDualShaders = CommandLine()->FindParm("-glmdualshaders") != 0;

        //-------------------------------------------------------------------
        // "can'ts "

#if defined( OSX )
        m_info.m_cantBlitReliably = m_info.m_intel;             //FIXME X3100&10.6.3 has problems blitting.. adjust this if bug fixed in 10.6.4
#else
    // m_cantBlitReliably path doesn't work right now, and the Intel path is different for us on Linux/Win7 anyway
        m_info.m_cantBlitReliably = false;
#endif
                
        if (CommandLine()->FindParm("-glmenabletrustblit"))
        {
                m_info.m_cantBlitReliably = false;                      // we trust the blit, so set the cant-blit cap to false
        }
        if (CommandLine()->FindParm("-glmdisabletrustblit"))
        {
                m_info.m_cantBlitReliably = true;                       // we do not trust the blit, so set the cant-blit cap to true
        }

        // MSAA resolve issues
        m_info.m_cantResolveFlipped     = false;
        

#if defined( OSX )
        m_info.m_cantResolveScaled = true;                                                              // generally true until new extension ships     
#else
        // DON'T just slam this to false and run without first testing with -gl_debug enabled on NVidia/AMD/etc.
        // This path needs the m_bHave_GL_EXT_framebuffer_multisample_blit_scaled extension.
        m_info.m_cantResolveScaled = true;
                
        if ( gGL->m_bHave_GL_EXT_framebuffer_multisample_blit_scaled )
        {
                m_info.m_cantResolveScaled = false;
        }
#endif
        
        // gamma decode impacting shader codegen
        m_info.m_costlyGammaFlips = false;
}

void    GLMRendererInfo::PopulateDisplays()
{
        SDLAPP_FUNC;

        Assert( !m_display );
        m_display = new GLMDisplayInfo;

        // Populate display mode table.
        m_display->PopulateModes();
}


void    GLMRendererInfo::Dump( int which )
{
        SDLAPP_FUNC;

        GLMPRINTF(("\n     #%d: GLMRendererInfo @ %p, renderer-id=(%08x)  display-mask=%08x  vram=%dMB",
                which, this,
                m_info.m_rendererID,
                m_info.m_displayMask,
                m_info.m_vidMemory >> 20
        ));
        GLMPRINTF(("\n       VendorID=%04x  DeviceID=%04x  Model=%s",
                m_info.m_pciVendorID,
                m_info.m_pciDeviceID,
                m_info.m_pciModelString
        ));

        m_display->Dump( which );
}




GLMDisplayDB::GLMDisplayDB ()
{
        SDLAPP_FUNC;

        m_renderer.m_display = NULL;    
}

GLMDisplayDB::~GLMDisplayDB     ( void )
{
        SDLAPP_FUNC;

        if ( m_renderer.m_display )
        {
                delete m_renderer.m_display;
                m_renderer.m_display = NULL;
        }
}

#ifndef GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX
#define GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX                 0x9047
#endif

#ifndef GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX
#define GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX    0x9048
#endif

#ifndef GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX 
#define GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX  0x9049
#endif

#ifndef GL_VBO_FREE_MEMORY_ATI
#define GL_VBO_FREE_MEMORY_ATI                                                  0x87FB
#endif

#ifndef GL_TEXTURE_FREE_MEMORY_ATI
#define GL_TEXTURE_FREE_MEMORY_ATI                                              0x87FC
#endif

#ifndef GL_RENDERBUFFER_FREE_MEMORY_ATI
#define GL_RENDERBUFFER_FREE_MEMORY_ATI                                 0x87FD
#endif
        
void GLMDisplayDB::PopulateRenderers( void )
{
        SDLAPP_FUNC;

        Assert( !m_renderer.m_display );

        GLMRendererInfoFields   fields;
        memset( &fields, 0, sizeof(fields) );

        // Assume 512MB of available video memory
        fields.m_vidMemory = 512 * 1024 * 1024;
        
        DebugPrintf( "GL_NVX_gpu_memory_info: %s\n", gGL->m_bHave_GL_NVX_gpu_memory_info ? "AVAILABLE" : "UNAVAILABLE" );
        DebugPrintf( "GL_ATI_meminfo: %s\n", gGL->m_bHave_GL_ATI_meminfo ? "AVAILABLE" : "UNAVAILABLE" );

        if ( gGL->m_bHave_GL_NVX_gpu_memory_info )
        {
                gGL->glGetError();

                GLint nTotalDedicated = 0, nTotalAvail = 0, nCurrentAvail = 0;
                gGL->glGetIntegerv( GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX, &nTotalDedicated );
                gGL->glGetIntegerv( GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX, &nTotalAvail );
                gGL->glGetIntegerv( GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX, &nCurrentAvail );

                if ( gGL->glGetError() )
                {
                        DebugPrintf( "GL_NVX_gpu_memory_info: Failed retrieving available GPU memory\n" );
                }
                else
                {
                        DebugPrintf( "GL_NVX_gpu_memory_info: Total Dedicated: %u, Total Avail: %u, Current Avail: %u\n", nTotalDedicated, nTotalAvail, nCurrentAvail );

                        // Try to do something reasonable. Should we report dedicated or total available to the engine here?
                        // For now, just take the MAX of both.
                        uint64 nActualAvail = static_cast<uint64>( MAX( nTotalAvail, nTotalDedicated ) ) * 1024;
                        fields.m_vidMemory = static_cast< GLint >( MIN( nActualAvail, 0x7FFFFFFF ) );
                }
        }
        else if ( gGL->m_bHave_GL_ATI_meminfo )
        {
                // As of 10/8/12 this extension is only available under Linux and Windows FireGL parts.
                gGL->glGetError();

                GLint nAvail[4] = { 0, 0, 0, 0 };
                gGL->glGetIntegerv( GL_TEXTURE_FREE_MEMORY_ATI, nAvail );

                if ( gGL->glGetError() )
                {
                        DebugPrintf( "GL_ATI_meminfo: Failed retrieving available GPU memory\n" );
                }
                else
                {
                        // param[0] - total memory free in the pool
                        // param[1] - largest available free block in the pool
                        // param[2] - total auxiliary memory free
                        // param[3] - largest auxiliary free block

                        DebugPrintf( "GL_ATI_meminfo: GL_TEXTURE_FREE_MEMORY_ATI: Total Free: %i, Largest Avail: %i, Total Aux: %i, Largest Aux Avail: %i\n", 
                                nAvail[0], nAvail[1], nAvail[2], nAvail[3] );

                        uint64 nActualAvail = static_cast<uint64>( nAvail[0] ) * 1024;
                        fields.m_vidMemory = static_cast< GLint >( MIN( nActualAvail, 0x7FFFFFFF ) );
                }
        }

        // Clamp the min amount of video memory to 256MB in case a query returned something bogus, or we interpreted it badly.
        fields.m_vidMemory = MAX( fields.m_vidMemory, 128 * 1024 * 1024 );
        fields.m_texMemory = fields.m_vidMemory;

        fields.m_pciVendorID = GLM_OPENGL_VENDOR_ID;
        fields.m_pciDeviceID = GLM_OPENGL_DEFAULT_DEVICE_ID;
        if ( ( gGL->m_nDriverProvider == cGLDriverProviderIntel ) || ( gGL->m_nDriverProvider == cGLDriverProviderIntelOpenSource ) )
        {
                fields.m_pciDeviceID = GLM_OPENGL_LOW_PERF_DEVICE_ID;
        }
        
/*      fields.m_colorModes = (uint)-1;
        fields.m_bufferModes = (uint)-1;
        fields.m_depthModes = (uint)-1;
        fields.m_stencilModes = (uint)-1;
        fields.m_maxAuxBuffers = (uint)128;
        fields.m_maxSampleBuffers = (uint)128;
        fields.m_maxSamples = (uint)2048;
        fields.m_sampleModes = (uint)128;
        fields.m_sampleAlpha = (uint)32;
*/

        GLint nMaxMultiSamples = 0;
        gGL->glGetIntegerv( GL_MAX_SAMPLES_EXT, &nMaxMultiSamples );
        fields.m_maxSamples = clamp<int>( nMaxMultiSamples, 0, 8 );
        DebugPrintf( "GL_MAX_SAMPLES_EXT: %i\n", nMaxMultiSamples );

        // We only have one GLMRendererInfo on Linux, unlike Mac OS X. Whatever libGL.so wants to do, we go with it.
        m_renderer.Init( &fields );

        // then go back and ask each renderer to populate its display info table.
        m_renderer.PopulateDisplays();
}



void    GLMDisplayDB::PopulateFakeAdapters( uint realRendererIndex )            // fake adapters = one real adapter times however many displays are on it
{
        SDLAPP_FUNC;

        Assert( realRendererIndex == 0 );
}

void    GLMDisplayDB::Populate(void)
{
        SDLAPP_FUNC;

        this->PopulateRenderers();
        
        this->PopulateFakeAdapters( 0 );

        #if GLMDEBUG
                this->Dump();
        #endif
}
        


int             GLMDisplayDB::GetFakeAdapterCount( void )
{
        SDLAPP_FUNC;

        return 1;
}

bool    GLMDisplayDB::GetFakeAdapterInfo( int fakeAdapterIndex, int *rendererOut, int *displayOut, GLMRendererInfoFields *rendererInfoOut, GLMDisplayInfoFields *displayInfoOut )
{
        SDLAPP_FUNC;

        if (fakeAdapterIndex >= GetFakeAdapterCount() )
        {
                *rendererOut = 0;
                *displayOut = 0;
                return true;            // fail
        }

        *rendererOut = 0;
        *displayOut = 0;

        bool rendResult = GetRendererInfo( *rendererOut, rendererInfoOut );
        bool dispResult = GetDisplayInfo( *rendererOut, *displayOut, displayInfoOut );
        
        return rendResult || dispResult;
}
        

int             GLMDisplayDB::GetRendererCount( void )
{
        SDLAPP_FUNC;

        return 1;
}

bool    GLMDisplayDB::GetRendererInfo( int rendererIndex, GLMRendererInfoFields *infoOut )
{
        SDLAPP_FUNC;

        memset( infoOut, 0, sizeof( GLMRendererInfoFields ) );

        if (rendererIndex >= GetRendererCount())
                return true; // fail
        
        *infoOut = m_renderer.m_info;

        return false;
}

int             GLMDisplayDB::GetDisplayCount( int rendererIndex )
{
        SDLAPP_FUNC;

        if (rendererIndex >= GetRendererCount())
        {
                Assert( 0 );
                return 0; // fail
        }
        
        return 1;
}

bool    GLMDisplayDB::GetDisplayInfo( int rendererIndex, int displayIndex, GLMDisplayInfoFields *infoOut )
{
        SDLAPP_FUNC;

        memset( infoOut, 0, sizeof( GLMDisplayInfoFields ) );
        
        if (rendererIndex >= GetRendererCount())
                return true; // fail
        
        if (displayIndex >= GetDisplayCount(rendererIndex))
                return true; // fail
        
        *infoOut = m_renderer.m_display->m_info;

        return false;
}

int             GLMDisplayDB::GetModeCount( int rendererIndex, int displayIndex )
{
        SDLAPP_FUNC;

        if (rendererIndex >= GetRendererCount())
                return 0; // fail
        
        if (displayIndex >= GetDisplayCount(rendererIndex))
                return 0; // fail
                
        return m_renderer.m_display->m_modes->Count();
}

bool    GLMDisplayDB::GetModeInfo( int rendererIndex, int displayIndex, int modeIndex, GLMDisplayModeInfoFields *infoOut )
{
        SDLAPP_FUNC;

        memset( infoOut, 0, sizeof( GLMDisplayModeInfoFields ) );
        
        if ( rendererIndex >= GetRendererCount())
                return true; // fail
        
        if (displayIndex >= GetDisplayCount( rendererIndex ) )
                return true; // fail
        
        if ( modeIndex >= GetModeCount( rendererIndex, displayIndex ) )
                return true; // fail
        
        if ( modeIndex >= 0 )
        {
                GLMDisplayMode *displayModeInfo = m_renderer.m_display->m_modes->Element( modeIndex );

                *infoOut = displayModeInfo->m_info;
        }
        else
        {
                const GLMDisplayInfoFields &info = m_renderer.m_display->m_info;

                infoOut->m_modePixelWidth = info.m_displayPixelWidth;
                infoOut->m_modePixelHeight = info.m_displayPixelHeight;
                infoOut->m_modeRefreshHz = 0;

                //return true; // fail
        }

        return false;
}


void    GLMDisplayDB::Dump( void )
{
        SDLAPP_FUNC;

        GLMPRINTF(("\n GLMDisplayDB @ %p ",this ));

        m_renderer.Dump( 0 );
}

//===============================================================================

GLMDisplayInfo::GLMDisplayInfo()
{
        SDLAPP_FUNC;

        m_modes = NULL;

        int Width, Height;
        GetLargestDisplaySize( Width, Height );

        m_info.m_displayPixelWidth = ( uint )Width;
        m_info.m_displayPixelHeight = ( uint )Height;
}

GLMDisplayInfo::~GLMDisplayInfo( void )
{
        SDLAPP_FUNC;
}

extern "C" int DisplayModeSortFunction( GLMDisplayMode * const *A, GLMDisplayMode * const *B )
{
        SDLAPP_FUNC;

        int bigger = -1;
        int smaller = 1;        // adjust these for desired ordering

        // check refreshrate - higher should win
        if ( (*A)->m_info.m_modeRefreshHz > (*B)->m_info.m_modeRefreshHz )
        {       
                return bigger;
        }
        else if ( (*A)->m_info.m_modeRefreshHz < (*B)->m_info.m_modeRefreshHz )
        {
                return smaller;
        }

        // check area - larger mode should win
        int areaa = (*A)->m_info.m_modePixelWidth * (*A)->m_info.m_modePixelHeight;
        int areab = (*B)->m_info.m_modePixelWidth * (*B)->m_info.m_modePixelHeight;

        if ( areaa > areab )
        {       
                return bigger;
        }
        else if ( areaa < areab )
        {
                return smaller;
        }
        
        return 0;       // equal rank
}


void    GLMDisplayInfo::PopulateModes( void )
{
        SDLAPP_FUNC;

        Assert( !m_modes );
        m_modes = new CUtlVector< GLMDisplayMode* >;

        int nummodes = SDL_GetNumVideoDisplays();

        for ( int i = 0; i < nummodes; i++ )
        {
                SDL_Rect rect = { 0, 0, 0, 0 };

                if ( !SDL_GetDisplayBounds( i, &rect ) && rect.w && rect.h )
                {
                        m_modes->AddToTail( new GLMDisplayMode( rect.w, rect.h, 0 ) );
                }
        }

        // Add a big pile of window resolutions.
        static const struct
        {
                uint w;
                uint h;
        } s_Resolutions[] =
        {
                { 640, 480 },   // 4x3
                { 800, 600 },
                { 1024, 768 },
                { 1152, 864 },
                { 1280, 960 },
                { 1600, 1200 },
                { 1920, 1440 },
                { 2048, 1536 },

                { 1280, 720 },  // 16x9
                { 1366, 768 },
                { 1600, 900 },
                { 1920, 1080 },

                { 720, 480 },   // 16x10
                { 1280, 800 },
                { 1680, 1050 },
                { 1920, 1200 },
                { 2560, 1600 },
        };

        for ( int i = 0; i < ARRAYSIZE( s_Resolutions ); i++ )
        {
                uint w = s_Resolutions[ i ].w;
                uint h = s_Resolutions[ i ].h;

                if ( ( w <= m_info.m_displayPixelWidth ) && ( h <= m_info.m_displayPixelHeight ) )
                {
                        m_modes->AddToTail( new GLMDisplayMode( w, h, 0 ) );

                        if ( ( w * 2 <= m_info.m_displayPixelWidth ) && ( h * 2 < m_info.m_displayPixelHeight ) )
                        {
                                // Add double of everything also - Retina proofing hopefully.
                                m_modes->AddToTail( new GLMDisplayMode( w * 2, h * 2, 0 ) );
                        }

                        m_modes->AddToTail( new GLMDisplayMode( w, w * ((float)m_info.m_displayPixelHeight/m_info.m_displayPixelWidth), 0 ) );
                }
        }

        m_modes->AddToTail( new GLMDisplayMode( m_info.m_displayPixelWidth / 2, m_info.m_displayPixelHeight / 2, 0 ) );

        m_modes->Sort( DisplayModeSortFunction );

        // remove dupes.
        nummodes = m_modes->Count();
        int i = 1;  // not zero!
        while (i < nummodes)
        {
                GLMDisplayModeInfoFields& info0 = m_modes->Element( i - 1 )->m_info;
                GLMDisplayModeInfoFields& info1 = m_modes->Element( i )->m_info;

                if ( ( info0.m_modePixelWidth == info1.m_modePixelWidth ) &&
                     ( info0.m_modePixelHeight == info1.m_modePixelHeight ) &&
                     ( info0.m_modeRefreshHz == info1.m_modeRefreshHz ) )
                {
                        m_modes->Remove(i);
                        nummodes--;
                }
                else
                {
                        i++;
                }
        }
}


void    GLMDisplayInfo::Dump( int which )
{
        SDLAPP_FUNC;

        GLMPRINTF(("\n         #%d: GLMDisplayInfo @ %p, pixwidth=%d  pixheight=%d",
                           which, this,  m_info.m_displayPixelWidth,  m_info.m_displayPixelHeight ));

        FOR_EACH_VEC( *m_modes, i )
        {
                ( *m_modes )[i]->Dump(i);
        }
}



================================================
FILE: appframework/glmrendererinfo_osx.mm
================================================
//========= Copyright  1996-2009, Valve Corporation, All rights reserved. ============//
//
// Purpose: Defines a group of app systems that all have the same lifetime
// that need to be connected/initialized, etc. in a well-defined order
//
// $Revision: $
// $NoKeywords: $
//=============================================================================//

#include <Cocoa/Cocoa.h>
#include <OpenGL/OpenGL.h>
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>
#include <IOKit/IOKitLib.h>


#undef MIN
#undef MAX
#define DONT_DEFINE_BOOL	// Don't define BOOL!
#include "tier0/threadtools.h"
#include "tier0/icommandline.h"
#include "tier1/interface.h"
#include "tier1/strtools.h"
#include "tier1/utllinkedlist.h"
#include "togl/rendermechanism.h"
#include "appframework/ilaunchermgr.h"	// gets pulled in from glmgr.h
#include "appframework/iappsystemgroup.h"
#include "inputsystem/ButtonCode.h"


// some helper functions, relocated out of GLM since they are used here

// this one makes a new context
bool	GLMDetectSLGU( void );
bool	GLMDetectSLGU( void )
{
	CGLError	cgl_error = (CGLError)0;
	bool		result = false;
	
	CGLContextObj oldctx = CGLGetCurrentContext();

	static CGLPixelFormatAttribute attribs[] = 
	{
		kCGLPFADoubleBuffer,
		kCGLPFANoRecovery,
		kCGLPFAAccelerated,
		kCGLPFADepthSize,
			(CGLPixelFormatAttribute)0,
		kCGLPFAColorSize,
			(CGLPixelFormatAttribute)32,

		(CGLPixelFormatAttribute)0	// list term
	};

	CGLPixelFormatObj	pixfmtobj = NULL;
	GLint				npix;
	
	CGLContextObj		ctxobj = NULL;
	
	cgl_error = CGLChoosePixelFormat( attribs, &pixfmtobj, &npix );
	if (!cgl_error)
	{
		// got pixel format, make a context
		
		cgl_error = CGLCreateContext( pixfmtobj, NULL, &ctxobj );
		if (!cgl_error)
		{
			CGLSetCurrentContext( ctxobj );

			// now do the test

			_CGLContextParameter	kCGLCPGCDMPEngine = ((_CGLContextParameter)1314);

			GLint dummyval = 0;
			cgl_error = CGLGetParameter( CGLGetCurrentContext(), kCGLCPGCDMPEngine, &dummyval );

			result = (!cgl_error);
			
			// all done, go back to old context, and destroy the temp one
			CGLSetCurrentContext( oldctx );
			CGLDestroyContext( ctxobj );
		}
		
		// destroy the pixel format obj
		CGLDestroyPixelFormat( pixfmtobj );
	}

	return result;
}


bool	GLMDetectScaledResolveMode( uint osComboVersion, bool hasSLGU );
bool	GLMDetectScaledResolveMode( uint osComboVersion, bool hasSLGU )
{
	bool result = false;
	
	// note this function assumes a current context on the renderer in question
	// and that FB blit and SLGU are present..
	
	if (!hasSLGU)
		return false;
		
	if (osComboVersion <= 0x000A0604)	// we know no one has it before 10.6.5
		return false;
	
	// in 10.6.6 and later, just check for the ext string.
	char *gl_ext_string = (char*)glGetString(GL_EXTENSIONS);
	// avoid crashing due to strstr'ing NULL pointer returned from glGetString
	if (!gl_ext_string)
		gl_ext_string = "";
	
	result = strstr(gl_ext_string, "GL_EXT_framebuffer_multisample_blit_scaled") != NULL;
	
	if ( !result )
	{
		// make two FBO's
		GLuint	fbos[2];
		GLuint	rbos[2];
		int extent = 64;
		
		// make two render buffers

		for( int fbi = 0; fbi < 2; fbi++ )
		{
			glGenFramebuffersEXT( 1, &fbos[fbi] ); CheckGLError( __LINE__ );
			glBindFramebufferEXT( fbi ? GL_DRAW_FRAMEBUFFER_EXT : GL_READ_FRAMEBUFFER_EXT , fbos[fbi] );  CheckGLError( __LINE__ );
			
			glGenRenderbuffersEXT( 1, &rbos[fbi] ); CheckGLError( __LINE__ );
			glBindRenderbufferEXT( GL_RENDERBUFFER_EXT, rbos[fbi] ); CheckGLError( __LINE__ );

			// make it multisampled if 0
			if (!fbi)
			{
				glRenderbufferStorageMultisampleEXT( GL_RENDERBUFFER_EXT, 2, GL_RGBA8, extent,extent );	  CheckGLError( __LINE__ );
			}
			else
			{
				glRenderbufferStorageEXT( GL_RENDERBUFFER_EXT, GL_RGBA8, extent,extent ); CheckGLError( __LINE__ );
			}

			// attach it 
			// #0 gets to be read and multisampled
			// #1 gets to be draw and multisampled
			glFramebufferRenderbufferEXT( fbi ? GL_DRAW_FRAMEBUFFER_EXT : GL_READ_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, rbos[fbi] ); CheckGLError( __LINE__ );
		}
		// now test
		while( glGetError() )	// clear error queue
		{
			;
		}

		// now do the dummy blit
		glBlitFramebufferEXT(	0,0,extent,extent, 0,0,extent,extent, GL_COLOR_BUFFER_BIT, XGL_SCALED_RESOLVE_FASTEST_EXT );

		// type of error we get back lets us know what the outcome is.
		// invalid enum error								-> unsupported
		// no error or invalid op							-> supported

		GLenum errorcode = (GLenum)glGetError();
		switch(errorcode)
		{
			// expected outcomes.
			
			// positive
			case GL_NO_ERROR:
			case GL_INVALID_OPERATION:
				result = true;			// new scaled resolve detected
				break;
				
			default:
				result = false;			// no scaled resolve
				break;
		}
		
		// unbind and wipe stuff
		
		glBindRenderbufferEXT( GL_RENDERBUFFER_EXT, 0 ); CheckGLError( __LINE__ );
		
		for( int xfbi = 0; xfbi < 2; xfbi++ )
		{
			// unbind FBO
			glBindFramebufferEXT( xfbi ? GL_DRAW_FRAMEBUFFER_EXT : GL_READ_FRAMEBUFFER_EXT , 0 ); CheckGLError( __LINE__ );

			// del FBO and RBO
			glDeleteFramebuffersEXT( 1, &fbos[xfbi] ); CheckGLError( __LINE__ );
			glDeleteRenderbuffersEXT( 1, &rbos[xfbi] ); CheckGLError( __LINE__ );
		}
	}

	return result; // no SLGU, no scaled resolve blit even possible
}

//===============================================================================

GLMRendererInfo::GLMRendererInfo( GLMRendererInfoFields *info )
{
	NSAutoreleasePool	*tempPool = [[NSAutoreleasePool alloc] init ];

	// absorb info obtained so far by caller
	m_info = *info;
	m_displays = NULL;

	// gather more info using a dummy context
	unsigned int attribs[] = 
	{
		kCGLPFADoubleBuffer, kCGLPFANoRecovery, kCGLPFAAccelerated,
		kCGLPFADepthSize, 0,
		kCGLPFAColorSize, 32,
		kCGLPFARendererID, (unsigned int)info->m_rendererID,
		0
	};

	NSOpenGLPixelFormat	*pixFmt		=	[[NSOpenGLPixelFormat alloc] initWithAttributes:(NSOpenGLPixelFormatAttribute*)attribs]; 
	NSOpenGLContext		*nsglCtx	=	[[NSOpenGLContext alloc] initWithFormat: pixFmt shareContext: NULL ];

	[nsglCtx makeCurrentContext];
		
	// run queries.
	char *gl_ext_string = (char*)glGetString(GL_EXTENSIONS);

	uint vers = m_info.m_osComboVersion;
	// avoid crashing due to strstr'ing NULL pointer returned from glGetString
	if (!gl_ext_string)
	  gl_ext_string = "";

	// effectively blacklist the renderer if it doesn't actually work; sort it to back of list
	if ( !nsglCtx )
	{
		m_info.m_vidMemory = 1;
		m_info.m_texMemory = 1;
	}
	
	//-------------------------------------------------------------------
	// booleans
	//-------------------------------------------------------------------
	// gamma writes.
	m_info.m_hasGammaWrites = true;
	if ( vers < 0x000A0600 )				// pre 10.6.0, no SRGB write - see http://developer.apple.com/graphicsimaging/opengl/capabilities/GLInfo_1058.html
	{
		m_info.m_hasGammaWrites = false;
	}
	
	if (m_info.m_atiR5xx)
	{
		m_info.m_hasGammaWrites = false;	// it just don't, even post 10.6.3
	}
	
	// if CLI option for fake SRGB mode is enabled, turn off this cap, act like we do not have EXT FB SRGB
	if (CommandLine()->FindParm("-glmenablefakesrgb"))
	{
		m_info.m_hasGammaWrites = false;
	}
	
	// extension string *could* be checked, but on 10.6.3 the ext string is not there, but the func *is*

	//-------------------------------------------------------------------
	// mixed attach sizes for FBO
	m_info.m_hasMixedAttachmentSizes = true;
	if ( vers < 0x000A0603 )	// pre 10.6.3, no mixed attach sizes
	{
		m_info.m_hasMixedAttachmentSizes = false;
	}
	else
	{
		if (!strstr(gl_ext_string, "GL_ARB_framebuffer_object"))
		{
			// ARB_framebuffer_object not available
			m_info.m_hasMixedAttachmentSizes = false;
		}
	}
	// also check ext string

	//-------------------------------------------------------------------
	// BGRA vert attribs
	m_info.m_hasBGRA = true;
	if ( vers < 0x000A0603 )	// pre 10.6.3, no BGRA attribs
	{
		m_info.m_hasBGRA = false;
	}
	else
	{
		if (!strstr(gl_ext_string, "EXT_vertex_array_bgra"))
		{
			// EXT_vertex_array_bgra not available
			m_info.m_hasBGRA = false;
		}
	}

	//-------------------------------------------------------------------
	m_info.m_hasNewFullscreenMode = true;
	if ( vers < 0x000A0600 )	// pre 10.6.0, no clever window server full screen mode
	{
		m_info.m_hasNewFullscreenMode = false;
	}
	
	//-------------------------------------------------------------------
	m_info.m_hasNativeClipVertexMode = true;
	// this one uses a heuristic, and allows overrides in case the heuristic is wrong
	// or someone wants to try a beta driver or something.

	// known bad combinations get turned off here..
	
	// any ATI hardware...
	// TURNED OFF OS CHECK if (m_info.m_osComboVersion <= 0x000A0603)
	// still believe to be broken in 10.6.4
	{
		if (m_info.m_ati)
		{
			m_info.m_hasNativeClipVertexMode = false;
		}
	}
	
	// R500, forever..
	if (m_info.m_atiR5xx)
	{
		m_info.m_hasNativeClipVertexMode = false;
	}

	// if user disabled them
	if (CommandLine()->FindParm("-glmdisableclipplanes"))
	{
		m_info.m_hasNativeClipVertexMode = false;
	}
	
	// or maybe enabled them..
	if (CommandLine()->FindParm("-glmenableclipplanes"))
	{
		m_info.m_hasNativeClipVertexMode = true;
	}
	
	//-------------------------------------------------------------------
	m_info.m_hasOcclusionQuery = true;
	if (!strstr(gl_ext_string, "ARB_occlusion_query"))
	{
		m_info.m_hasOcclusionQuery = false;		// you don't got it!
	}
	
	//-------------------------------------------------------------------
	m_info.m_hasFramebufferBlit = true;
	if (!strstr(gl_ext_string, "EXT_framebuffer_blit"))
	{
		m_info.m_hasFramebufferBlit = false;	// you know you don't got it!
	}
	
	//-------------------------------------------------------------------
	m_info.m_maxAniso = 4;			//FIXME needs real query
	
	//-------------------------------------------------------------------
	m_info.m_hasBindableUniforms = true;
	if (!strstr(gl_ext_string, "EXT_bindable_uniform"))
	{
		m_info.m_hasBindableUniforms = false;
	}
	m_info.m_hasBindableUniforms = false;		// hardwiring this path to false until we see how to accelerate it properly
	
	//-------------------------------------------------------------------
	m_info.m_hasUniformBuffers = true;
	if (!strstr(gl_ext_string, "ARB_uniform_buffer"))
	{
		m_info.m_hasUniformBuffers = false;
	}

	//-------------------------------------------------------------------
	// test for performance pack (10.6.4+)

	bool perfPackageDetected = GLMDetectSLGU();
	
	if (perfPackageDetected)
	{
		m_info.m_hasPerfPackage1 = true;
	}	

	if (CommandLine()->FindParm("-glmenableperfpackage"))	// force it on
	{
		m_info.m_hasPerfPackage1 = true;
	}
	
	if (CommandLine()->FindParm("-glmdisableperfpackage"))	// force it off
	{
		m_info.m_hasPerfPackage1 = false;
	}


	//-------------------------------------------------------------------
	// runtime options that aren't negotiable once set

	m_info.m_hasDualShaders = CommandLine()->FindParm("-glmdualshaders");

	//-------------------------------------------------------------------
	// "can'ts "
	
	m_info.m_cantBlitReliably = (m_info.m_osComboVersion < 0x000A0606) && m_info.m_intel;		//don't trust FBO blit on Intel before 10.6.6
	if (CommandLine()->FindParm("-glmenabletrustblit"))
	{
		m_info.m_cantBlitReliably = false;			// we trust the blit, so set the cant-blit cap to false
	}
	if (CommandLine()->FindParm("-glmdisabletrustblit"))
	{
		m_info.m_cantBlitReliably = true;			// we do not trust the blit, so set the cant-blit cap to true
	}

	//m_info.m_cantAttachSRGB = (m_info.m_nv && m_info.m_osComboVersion < 0x000A0600);	//NV drivers won't accept SRGB tex on an FBO color target in 10.5.8
	//m_info.m_cantAttachSRGB = (m_info.m_ati && m_info.m_osComboVersion < 0x000A0600);	//... does ATI have the same problem?
	m_info.m_cantAttachSRGB = (m_info.m_osComboVersion < 0x000A0600);	// across the board on 10.5.x actually..

	// MSAA resolve issues
	m_info.m_cantResolveFlipped	= false;	// initial stance
	
	if (m_info.m_ati)
	{
		//Jan 2011 - ATI says it's better to do two step blit than to try and resolve upside down
		m_info.m_cantResolveFlipped = true;
	}
	
	if (m_info.m_nv)
	{
		// we're going to mark it 'broken' unless perf package 1 (10.6.4+) is present
		if (!m_info.m_hasPerfPackage1)
		{
			m_info.m_cantResolveFlipped = true;
		}
	}
	
	// this is just the private assessment of whather scaled resolve is available.
	// the activation of it will stay tied to the gl_minify_resolve_mode / gl_magnify_resolve_mode convars in glmgr
	if 	(m_info.m_osComboVersion > 0x000A0700 || CommandLine()->FindParm("-gl_enable_scaled_resolve") )
	{
		bool scaledResolveDetected = GLMDetectScaledResolveMode( m_info.m_osComboVersion, m_info.m_hasPerfPackage1 );
		m_info.m_cantResolveScaled = !scaledResolveDetected;
	}
	else
	{
		m_info.m_cantResolveScaled = true;
	}

	// and you can force it to be "available" if you really want to..
	if ( CommandLine()->FindParm("-gl_force_enable_scaled_resolve") )
	{
		m_info.m_cantResolveScaled = false;
	}
	
	// gamma decode impacting shader codegen
	m_info.m_costlyGammaFlips = false;
	if (m_info.m_osComboVersion < 0x000A0600)		// if Leopard
		m_info.m_costlyGammaFlips = true;
		
	if (m_info.m_atiR5xx)							// or r5xx - always
		m_info.m_costlyGammaFlips = true;

	if ( (m_info.m_atiR6xx) && (m_info.m_osComboVersion < 0x000A0605) )	// or r6xx prior to 10.6.5
		m_info.m_costlyGammaFlips = true;

	// The OpenGL driver for Intel HD4000 on 10.8 has a bug in the GLSL compiler, which was fixed
	// in 10.9 (and unlikely to be fixed in 10.8). See intelglmallocworkaround.h for more info.
	bool mountainLion = (m_info.m_osComboVersion >= 0x000A0800) && (m_info.m_osComboVersion < 0x000A0900);
	m_info.m_badDriver108Intel = mountainLion && m_info.m_intelHD4000;
	if ( CommandLine()->FindParm("-glmenablemallocworkaround") )
	{
		m_info.m_badDriver108Intel = true;
	}
	if ( CommandLine()->FindParm("-glmdisablemallocworkaround") )
	{
		m_info.m_badDriver108Intel = false;
	}

	[nsglCtx release];
	[pixFmt release];
	
	[tempPool release];
}

GLMRendererInfo::~GLMRendererInfo( void )
{
	if (m_displays)
	{
		// delete all the new'd renderer infos that the table tracks
		FOR_EACH_VEC( *m_displays, i )
		{
			delete (*this->m_displays)[i];
		}
		delete m_displays;
		m_displays = NULL;
	}
}

extern "C" int DisplayInfoSortFunction( GLMDisplayInfo* const *A, GLMDisplayInfo* const *B )
{
	int bigger = -1;
	int smaller = 1;	// adjust these to get the ordering you want

	// check main-ness - main should win

	uint maskOfMainDisplay = CGDisplayIDToOpenGLDisplayMask( CGMainDisplayID() );
	//Assert( maskOfMainDisplay==1 );	// just curious
	
	int mainscreena = (*A)->m_info.m_glDisplayMask & maskOfMainDisplay;
	int mainscreenb = (*B)->m_info.m_glDisplayMask & maskOfMainDisplay;
	
	if ( mainscreena > mainscreenb )
	{
		return bigger;
	}
	else if ( mainscreena < mainscreenb )
	{
		return smaller;
	}
	
	// check area - larger screen should win
	int areaa = (*A)->m_info.m_displayPixelWidth * (*A)->m_info.m_displayPixelHeight;
	int areab = (*B)->m_info.m_displayPixelWidth * (*B)->m_info.m_displayPixelHeight;

	if ( areaa > areab )
	{	
		return bigger;
	}
	else if ( areaa < areab )
	{
		return smaller;
	}
	
	return 0;	// equal rank
}


void	GLMRendererInfo::PopulateDisplays( void )
{
	Assert( !m_displays );
	m_displays = new CUtlVector< GLMDisplayInfo* >;
	
	for( int i=0; i<32; i++)
	{
		// check mask to see if the selected display intersects this renderer
		CGOpenGLDisplayMask dspMask = (CGOpenGLDisplayMask)(1<<i);
		
		if ( m_info.m_displayMask & dspMask )
		{
			// exclude teeny displays (they may represent offline displays)
			// exclude inactive displays
			
			CGDirectDisplayID cgid = CGOpenGLDisplayMaskToDisplayID ( dspMask );

			if ( (cgid != kCGNullDirectDisplay) && CGDisplayIsActive( cgid ) && (CGDisplayPixelsWide( cgid ) >= 512) && (CGDisplayPixelsHigh( cgid ) >= 384) )
			{
				GLMDisplayInfo *newdisp = new GLMDisplayInfo( cgid, dspMask );
				m_displays->AddToTail( newdisp );			
			}
		}
	}
	
	// now sort the table of displays.
	m_displays->Sort( DisplayInfoSortFunction );

	// then go back and ask each display to populate its display mode table.
	FOR_EACH_VEC( *m_displays, i )
	{
		(*this->m_displays)[i]->PopulateModes();
	}
}

const char *CheesyRendererDecode( uint value )
{
	switch(value)
	{
		case 0x00020200 :  return "Generic";
		case 0x00020400 :  return "GenericFloat";
		case 0x00020600 :  return "AppleSW";
		case 0x00021000 :  return "ATIRage128";
		case 0x00021200 :  return "ATIRadeon";
		case 0x00021400 :  return "ATIRagePro";
		case 0x00021600 :  return "ATIRadeon8500";
		case 0x00021800 :  return "ATIRadeon9700";
		case 0x00021900 :  return "ATIRadeonX1000";
		case 0x00021A00 :  return "ATIRadeonX2000";
		case 0x00022000 :  return "NVGeForce2MX";
		case 0x00022200 :  return "NVGeForce3";
		case 0x00022400 :  return "NVGeForceFX";
		case 0x00022600 :  return "NVGeForce8xxx";
		case 0x00023000 :  return "VTBladeXP2";
		case 0x00024000 :  return "Intel900";
		case 0x00024200 :  return "IntelX3100";
		case 0x00040000 :  return "Mesa3DFX";

		default: return "UNKNOWN";
	}
}

extern const char *GLMDecode( GLMThing_t thingtype, unsigned long value );

void	GLMRendererInfo::Dump( int which )
{
	GLMPRINTF(("\n     #%d: GLMRendererInfo @ %08x, renderer-id=%s(%08x)  display-mask=%08x  vram=%dMB",
		which, this,
		CheesyRendererDecode( m_info.m_rendererID & 0x00FFFF00 ), m_info.m_rendererID,
		m_info.m_displayMask,
		m_info.m_vidMemory >> 20
	));
	GLMPRINTF(("\n       VendorID=%04x  DeviceID=%04x  Model=%s",
		m_info.m_pciVendorID,
		m_info.m_pciDeviceID,
		m_info.m_pciModelString
	));

	FOR_EACH_VEC( *m_displays, i )
	{
		(*m_displays)[i]->Dump(i);
	}
}


//===============================================================================


GLMDisplayDB::GLMDisplayDB	( void )
{
	m_renderers = NULL;	
}

GLMDisplayDB::~GLMDisplayDB	( void )
{
	if (m_renderers)
	{
		// delete all the new'd renderer infos that the table tracks
		FOR_EACH_VEC( *m_renderers, i )
		{
			delete (*this->m_renderers)[i];
		}
		delete m_renderers;
		m_renderers = NULL;
	}
}

extern "C" int RendererInfoSortFunction( GLMRendererInfo * const *A, GLMRendererInfo* const *B )
{
	int bigger = -1;
	int smaller = 1;
	
	// check VRAM
	if ( (*A)->m_info.m_vidMemory > (*B)->m_info.m_vidMemory )
	{	
		return bigger;
	}
	else if ( (*A)->m_info.m_vidMemory < (*B)->m_info.m_vidMemory )
	{
		return smaller;
	}
	
	// check MSAA limit
	if ( (*A)->m_info.m_maxSamples > (*B)->m_info.m_maxSamples )
	{	
		return bigger;
	}
	else if ( (*A)->m_info.m_maxSamples < (*B)->m_info.m_maxSamples )
	{
		return smaller;
	}
	
	/*
		// this was not a great idea here..
		
		// check if one has the main screen - is that index 0 in all cases?
		uint maskOfMainDisplay = CGDisplayIDToOpenGLDisplayMask( CGMainDisplayID() );
		Assert( maskOfMainDisplay==1 );	// just curious
		
		int mainscreena = (*A)->m_info.m_displayMask & maskOfMainDisplay;
		int mainscreenb = (*B)->m_info.m_displayMask & maskOfMainDisplay;
		
		if ( mainscreena > mainscreenb )
		{
			return bigger;
		}
		else if ( mainscreena < mainscreenb )
		{
			return smaller;
		}
	*/
	
	return 0;	// equal rank
}

/** some code that NV gave us.  more generalized approach below..

		static io_registry_entry_t lookup_dev_NV(char *name)
		{
			mach_port_t master_port = 0;
			io_iterator_t iterator;
			io_registry_entry_t nub = 0;
			kern_return_t ret;

			IOMasterPort(MACH_PORT_NULL, &master_port);

			ret = IOServiceGetMatchingServices(master_port, IOServiceMatching(name), &iterator);

			if (iterator) {
				nub = IOIteratorNext(iterator);

				if (IOIteratorNext(iterator)) {
					printf("warning: more than one card?\n");
				}
				IOObjectRelease(iterator);
			}
			IOObjectRelease(master_port);

			return nub;
		}


		void	GetDriverInfoString_NV( char *driverNameBuf, int driverNameBufLen )
		{
			// courtesy NVIDIA dev rel
			
			io_registry_entry_t registry;
			kern_return_t ret;

			//
			// Get NVKernel / IOGLBundleName
			//

			registry = lookup_dev_NV("NVKernel");
			if (!registry) {
				fprintf(stderr, "error: could not find NVKernel IORegistry entry!\n");
				return;
			}

			CFMutableDictionaryRef entry;
			ret = IORegistryEntryCreateCFProperties(registry, &entry, kCFAllocatorDefault, 0);
			if (ret != kIOReturnSuccess) {
				fprintf(stderr, "error: could not create CFProperties dictionary!\n");
				return;
			}

			CFStringRef bundle_name_ref = (CFStringRef) CFDictionaryGetValue(entry, CFSTR("IOGLBundleName"));
			if (!bundle_name_ref) {
				fprintf(stderr, "error: could not get IOGLBundleName reference!\n");
				return;
			}

			const char *bundle_name = CFStringGetCStringPtr(bundle_name_ref, CFStringGetSystemEncoding());
			if (!bundle_name) {
				fprintf(stderr, "error: could not get IOGLBundleName!\n");
				return;
			}

			CFStringRef identifier = CFStringCreateWithFormat(NULL, NULL, CFSTR("com.apple.%s"), bundle_name);

			//
			// Get bundle information
			//

			CFBundleRef bundle;
			bundle = CFBundleGetBundleWithIdentifier(identifier);
			if (!bundle) {
				fprintf(stderr, "error: could not get GL driver bundle!\n");
				return;
			}

			CFDictionaryRef dict;
			CFStringRef info;

			dict = CFBundleGetInfoDictionary(bundle);
			if (!dict) {
				fprintf(stderr, "error: could not get bundle info dictionary!\n");
				return;
			}

			info = (CFStringRef) CFDictionaryGetValue(dict, CFSTR("CFBundleGetInfoString"));
			if (!info) {
				fprintf(stderr, "error: could not get CFBundleGetInfoString!\n");
				return;
			}

			CFStringGetCString(info, driverNameBuf, driverNameBufLen, CFStringGetSystemEncoding());

			IOObjectRelease(registry);
		}
**/

void	GLMDisplayDB::PopulateRenderers( void )
{
	Assert( !m_renderers );
	m_renderers = new CUtlVector< GLMRendererInfo* >;
	
	// now walk the renderer list
	// find the eligible ones and insert them into vector
	// if more than one, sort the vector by desirability with favorite at 0
	// then ask each renderer object to populate its displays

	// turns out how you have to do this is to walk the display mask 1<<n..
	// and query at each one, what renderers can hit that one.
	
	// when you find one, see if it's already in the vector above. if not, add it.
	// later, we sort them.
	
	for( int i=0; i<32; i++ )
	{
		CGLError			cgl_err		= (CGLError)0;
		CGLRendererInfoObj	cgl_rend	= NULL;
		GLint				nrend;
	
		CGOpenGLDisplayMask	dspMask		= (CGOpenGLDisplayMask)(1<<i);	
		CGDirectDisplayID	cgid		= CGOpenGLDisplayMaskToDisplayID( dspMask );

		bool selected = true;	// assume the best		

		if (selected)
		{
			if ( (cgid == kCGNullDirectDisplay)  || (!CGDisplayIsActive( cgid )) )
			{
				selected = false;
			}
		}

		if (selected)
		{
			cgl_err = CGLQueryRendererInfo( dspMask, &cgl_rend, &nrend );	// FIXME this call spams the console if you ask about an out of bounds display mask
																			// "<Error>: unknown error code: invalid display"
																			// we can fix that by getting the active display mask first.
			if (!cgl_err)
			{
				// walk the renderers that can hit this display
				// add to table if not already in table, and minimums met

				for( int j=0; j<nrend; j++)
				{
					int problems = 0;
					
					GLMRendererInfoFields	fields;
					memset( &fields, 0, sizeof(fields) );

					// early out if renderer ID already in the table
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPRendererID, &fields.m_rendererID );			problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPDisplayMask, &fields.m_displayMask );		problems += (cgl_err != 0);

					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPFullScreen, &fields.m_fullscreen );			problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPAccelerated, &fields.m_accelerated );		problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPWindow, &fields.m_windowed );				problems += (cgl_err != 0);

					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPBufferModes, &fields.m_bufferModes );		problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPColorModes, &fields.m_colorModes );			problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPDepthModes, &fields.m_depthModes );			problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPStencilModes, &fields.m_stencilModes );		problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPMaxAuxBuffers, &fields.m_maxAuxBuffers );	problems += (cgl_err != 0);				
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPMaxSampleBuffers, &fields.m_maxSampleBuffers );	problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPMaxSamples, &fields.m_maxSamples );			problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPSampleModes, &fields.m_sampleModes );		problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPSampleAlpha, &fields.m_sampleAlpha );		problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPVideoMemory, &fields.m_vidMemory );			problems += (cgl_err != 0);
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPTextureMemory, &fields.m_texMemory );		problems += (cgl_err != 0);

					// Make sure the renderer is attached to a display.
					GLint online;
					cgl_err = CGLDescribeRenderer( cgl_rend, j,   kCGLRPOnline, &online );					problems += (cgl_err != 0);
					problems += ( online == 0 );

					// decide if this renderer goes in the table.

					bool	selected = !problems;
					
					if (selected)
					{
						// grab the OS version

                        SInt32 vMajor = 0;	SInt32 vMinor = 0;	SInt32 vMinorMinor = 0;
						
						OSStatus gestalt_err = 0;
						gestalt_err = Gestalt(gestaltSystemVersionMajor, &vMajor);
						Assert(!gestalt_err);
						
						gestalt_err = Gestalt(gestaltSystemVersionMinor, &vMinor);
						Assert(!gestalt_err);

						gestalt_err = Gestalt(gestaltSystemVersionBugFix, &vMinorMinor);
						Assert(!gestalt_err);

						//encode into one quantity - 10.6.3 becomes 0x000A0603
						fields.m_osComboVersion = (vMajor << 16) | (vMinor << 8) | (vMinorMinor);

						if (CommandLine()->FindParm("-fakeleopard"))
						{
							// lie
							fields.m_osComboVersion = 0x000A0508;
						}
						
						if (fields.m_osComboVersion < 0x000A0508)
						{
							// no support below 10.5.8
							// we'll wind up with no valid renderers and give up
							selected = false;
						}
					}
					
					if (selected)
					{
						// gather more info from IOKit
						// cribbed from http://developer.apple.com/mac/library/samplecode/VideoHardwareInfo/listing3.html
						
						CFTypeRef typeCode;
						CFDataRef vendorID, deviceID, model;
						io_registry_entry_t dspPort;
							
						// Get the I/O Kit service port for the display
						dspPort = CGDisplayIOServicePort( cgid );

						// Get the information for the device
						// The vendor ID, device ID, and model are all available as properties of the hardware's I/O Kit service port
						
						vendorID	= (CFDataRef)IORegistryEntrySearchCFProperty(dspPort,kIOServicePlane,CFSTR("vendor-id"),	kCFAllocatorDefault,kIORegistryIterateRecursively | kIORegistryIterateParents);
						deviceID	= (CFDataRef)IORegistryEntrySearchCFProperty(dspPort,kIOServicePlane,CFSTR("device-id"),	kCFAllocatorDefault,kIORegistryIterateRecursively | kIORegistryIterateParents);
						model		= (CFDataRef)IORegistryEntrySearchCFProperty(dspPort,kIOServicePlane,CFSTR("model"),		kCFAllocatorDefault,kIORegistryIterateRecursively | kIORegistryIterateParents);
						
						// Send the appropriate data to the outputs checking to validate the data
						if(vendorID)
						{
							fields.m_pciVendorID = *((UInt32*)CFDataGetBytePtr(vendorID));
						}
						else
						{
							fields.m_pciVendorID = 0;
						}
						
						if(deviceID)
						{
							fields.m_pciDeviceID = *((UInt32*)CFDataGetBytePtr(deviceID));
						}
						else
						{
							fields.m_pciDeviceID = 0;
						}
						
						if(model)
						{
							int length = CFDataGetLength(model);
							char *data = (char*)CFDataGetBytePtr(model);
							Q_strncpy( fields.m_pciModelString, data, sizeof(fields.m_pciModelString) );
						}
						else
						{
							Q_strncpy( fields.m_pciModelString, "UnknownModel", sizeof(fields.m_pciModelString) );
						}
						

						// iterate through IOAccelerators til we find one that matches the vendorid and deviceid of this renderer (ugh!)
						// this provides the driver version string which can in turn be used to uniquely identify bad drivers and special case for them
						// first example to date - forcing vsync on 10.6.4 + NV
						
						{
							io_iterator_t	ioIterator		= (io_iterator_t)0;
							io_service_t	ioAccelerator;
							kern_return_t	ioResult		= 0;
							bool			ioDone			= false;
														
							ioResult = IOServiceGetMatchingServices( kIOMasterPortDefault, IOServiceMatching("IOAccelerator"), &ioIterator );
							if( ioResult == KERN_SUCCESS )
							{
								ioAccelerator = 0;

								while( ( !ioDone ) && ( ioAccelerator = IOIteratorNext( ioIterator ) )  )
								{
									io_service_t ioDevice;
									
									ioDevice = 0;
									ioResult = IORegistryEntryGetParentEntry( ioAccelerator, kIOServicePlane, &ioDevice);
									
									CFDataRef this_vendorID, this_deviceID;

									if(ioResult == KERN_SUCCESS)
									{
										this_vendorID	=	(CFDataRef)IORegistryEntryCreateCFProperty(ioDevice, CFSTR("vendor-id"), kCFAllocatorDefault, kNilOptions );
										this_deviceID	=	(CFDataRef)IORegistryEntryCreateCFProperty(ioDevice, CFSTR("device-id"), kCFAllocatorDefault, kNilOptions );
										
										if (this_vendorID && this_deviceID)	// null check..
										{
											// see if it matches. if so, do our business (get the extended version string), set ioDone, call it a day
											unsigned short this_vendorIDValue = *(unsigned short*)CFDataGetBytePtr(this_vendorID);
											unsigned short this_deviceIDValue = *(unsigned short*)CFDataGetBytePtr(this_deviceID);
											
											if ( (fields.m_pciVendorID == this_vendorIDValue) && (fields.m_pciDeviceID == this_deviceIDValue) )
											{
												// see if it matches. if so, do our business (get the extended version string), set ioDone, call it a day
												unsigned short* this_vendorIDBytes = (unsigned short*)CFDataGetBytePtr( this_vendorID );
												unsigned short* this_deviceIDBytes = (unsigned short*)CFDataGetBytePtr( this_deviceID );
												
												if (this_vendorIDBytes && this_deviceIDBytes)	// null check...
												{
													unsigned short this_vendorIDValue = *this_vendorIDBytes;
													unsigned short this_deviceIDValue = *this_deviceIDBytes;
													
													if ( (fields.m_pciVendorID == this_vendorIDValue) && (fields.m_pciDeviceID == this_deviceIDValue) )
													{
														// match, stop looking
														ioDone = true;
														
														// get extended info
														CFStringRef this_ioglName = (CFStringRef)IORegistryEntryCreateCFProperty( ioAccelerator, CFSTR("IOGLBundleName"), kCFAllocatorDefault, kNilOptions );
	
														NSString *bundlePath = [ NSString stringWithFormat:@"/System/Library/Extensions/%@.bundle", this_ioglName ];
														
														NSDictionary* this_driverDict = [ [NSBundle bundleWithPath: bundlePath] infoDictionary ];
														if (this_driverDict)
														{
															NSString* this_driverInfo = [ this_driverDict objectForKey:@"CFBundleGetInfoString" ];
															if ( this_driverInfo )
															{
																const char* theString = [ this_driverInfo UTF8String ];
																
																strncpy(fields.m_driverInfoString, theString, sizeof( fields.m_driverInfoString )  );
															}												
														}
														
														// [bundlePath release];
														
														CFRelease(this_ioglName);
													}
												}
	
												CFRelease(this_vendorID);
												CFRelease(this_deviceID);
											}
										}
									}
								}
							}

							IOObjectRelease(ioAccelerator);
							IOObjectRelease(ioIterator);
						}

						// Release vendorID, deviceID, and model as appropriate
						if(vendorID)
							CFRelease(vendorID);
						if(deviceID)
							CFRelease(deviceID);
						if(model)
							CFRelease(model);

						// generate shorthand bools
						switch( fields.m_pciVendorID )
						{
							case	0x1002:	//ATI
							{
								fields.m_ati = true;

								// http://www.pcidatabase.com/search.php?device_search_str=radeon&device_search.x=0&device_search.y=0&device_search=search+devices
								
								// Mac-relevant ATI R5xx PCI device ID's lie in this range: 0x7100 - 0x72FF
								// X1600, X1900, X1950
								if ( (fields.m_pciDeviceID >= 0x7100) && (fields.m_pciDeviceID <= 0x72ff) )
								{
									fields.m_atiR5xx = true;
								}

								// R6xx PCI device ID's lie in these ranges:
									// 0x94C1 - 0x9515 ... also 0x9581 - 0x9713
									// 2400HD, 2600HD, 3870, et al
								if	( 
										( (fields.m_pciDeviceID >= 0x94C1) && (fields.m_pciDeviceID <= 0x9515) )
									||	( (fields.m_pciDeviceID >= 0x9581) && (fields.m_pciDeviceID <= 0x9713) )
									)
								{
									fields.m_atiR6xx = true;
								}

								// R7xx PCI device ID's lie in: 0x9440 - 0x9460, also 9480-94b5.
								// why there is an HD5000 at 9462, I dunno.  Don't think that's an R8xx part.
								if	( 
										( (fields.m_pciDeviceID >= 0x9440) && (fields.m_pciDeviceID <= 0x9460) )
									||	( (fields.m_pciDeviceID >= 0x9480) && (fields.m_pciDeviceID <= 0x94B5) )
									)
								{
									fields.m_atiR7xx = true;
								}
								
								// R8xx: 0x6898-0x68BE
								if ( (fields.m_pciDeviceID >= 0x6898) && (fields.m_pciDeviceID <= 0x68Be) )
								{
									fields.m_atiR8xx = true;
								}

								#if 0
										// turned off, but we could use this for cross check.
										// we could also use the bit encoding of the renderer ID to ferret out a geberation clue.
										
										// string-scan for each generation
										// this could be a lot better if we got the precise PCI ID's used and/or cross-ref'd that against the driver name
										if (strstr("X1600", fields.m_pciModelString) || strstr("X1900", fields.m_pciModelString) || strstr("X1950", fields.m_pciModelString) )
										{
											fields.m_atiR5xx = true;
										}

										if (strstr("2600", fields.m_pciModelString) || strstr("3870", fields.m_pciModelString) || strstr("X2000", fields.m_pciModelString) )
										{
											fields.m_atiR6xx = true;
										}

										if (strstr("4670", fields.m_pciModelString) || strstr("4650", fields.m_pciModelString) || strstr("4850", fields.m_pciModelString)|| strstr("4870", fields.m_pciModelString) )
										{
											fields.m_atiR7xx = true;
										}
								#endif
							}
							break;
							
							case	0x8086:	//INTC
							{
								fields.m_intel = true;
								
								switch( fields.m_pciDeviceID )
								{
									case	0x27A6:	fields.m_intel95x = true;		break;	// GMA 950
									case	0x2A02:	fields.m_intel3100 = true;		break;	// X3100
									case	0x0166: fields.m_intelHD4000 = true;	break;	// HD4000
								}
							}
							break;
							
							case	0x10DE:	//NV
							{
								fields.m_nv = true;

								// G7x: 0x0391 0x393 0x0395 (7300/7600 GT)  0x009D (Quadro FX)
								if	( (fields.m_pciDeviceID == 0x0391) || (fields.m_pciDeviceID == 0x0393) || (fields.m_pciDeviceID == 0x0395) || (fields.m_pciDeviceID == 0x009D) )
								{
									fields.m_nvG7x = true;
								}
								
								// G8x: 0400-04ff, also 0x5E1 (GTX280) through 0x08FF
								if	(
										( (fields.m_pciDeviceID >= 0x0400) && (fields.m_pciDeviceID <= 0x04ff) )
									||	( (fields.m_pciDeviceID >= 0x05E1) && (fields.m_pciDeviceID <= 0x08ff) )
									)
								{
									fields.m_nvG8x = true;
								}

								if ( fields.m_pciDeviceID > 0x0900 )
								{
									fields.m_nvNewer = true;
								}
								
								// detect the specific revision of NV driver in 10.6.4 that caused all the grief
								if (strstr(fields.m_driverInfoString, "1.6.16.11 (19.5.8f01)"))
								{
									fields.m_badDriver1064NV = true;
								}
							}
							break;
						}						
					}
					
					if (selected)
					{
						// dupe check
						FOR_EACH_VEC( *m_renderers, i )
						{
							uint rendid = (*m_renderers)[i]->m_info.m_rendererID;
							
							if ( rendid == fields.m_rendererID )
							{
								// don't add to table, it's a dupe
								selected = false;
							}
						}
					}
					
					if (selected)
					{
						// criteria check
						if (fields.m_fullscreen==0)
							selected = false;
						if (fields.m_accelerated==0)
							selected = false;
						if (fields.m_windowed==0)
							selected = false;
					}

					Assert( fields.m_displayMask != 0 );
					
					if (selected)
					{
						// add to table
						// note this constructor makes a dummy context just long enough to query remaining fields in the m_info.
						GLMRendererInfo *newinfo = new GLMRendererInfo( &fields );
						m_renderers->AddToTail( newinfo );
					}
				}
				if (cgl_rend)
				{
					CGLDestroyRendererInfo( cgl_rend );
				}
			}
		}
	}
	
	// now sort the table.
	m_renderers->Sort( RendererInfoSortFunction );

	// then go back and ask each renderer to populate its display info table.
	FOR_EACH_VEC( *m_renderers, i )
	{
		(*m_renderers)[i]->PopulateDisplays();
	}
}

void	GLMDisplayDB::PopulateFakeAdapters( uint realRendererIndex )		// fake adapters = one real adapter times however many displays are on it
{
	// presumption is that renderers have been populated.
	Assert( GetRendererCount() > 0 );
	Assert( realRendererIndex < GetRendererCount() );
	
	m_fakeAdapters.RemoveAll();
	
	// for( int r = 0; r < GetRendererCount(); r++ )
	int r = realRendererIndex;
	{
		for( int d = 0; d < GetDisplayCount( r ); d++ )
		{
			GLMFakeAdapter temp;
			
			temp.m_rendererIndex = r;
			temp.m_displayIndex = d;
			
			m_fakeAdapters.AddToTail( temp );
		}
	}
}

void	GLMDisplayDB::Populate(void)
{
	this->PopulateRenderers();
	
	// passing in zero here, constrains the set of fake adapters (GL renderer + a display) to the ones using the highest ranked renderer.
	//FIXME introduce some kind of convar allowing selection of other GPU's in the system.
	
	int realRendererIndex = 0;

	if (CommandLine()->FindParm("-glmrenderer0"))
		realRendererIndex = 0;
	if (CommandLine()->FindParm("-glmrenderer1"))
		realRendererIndex = 1;
	if (CommandLine()->FindParm("-glmrenderer2"))
		realRendererIndex = 2;
	if (CommandLine()->FindParm("-glmrenderer3"))
		realRendererIndex = 3;
		
	if (realRendererIndex >= GetRendererCount())
	{
		// fall back to 0
		realRendererIndex = 0;
	}
	
	this->PopulateFakeAdapters( 0 );

	#if GLMDEBUG
		this->Dump();
	#endif
}
	


int		GLMDisplayDB::GetFakeAdapterCount( void )
{
	return m_fakeAdapters.Count();
}

bool	GLMDisplayDB::GetFakeAdapterInfo( int fakeAdapterIndex, int *rendererOut, int *displayOut, GLMRendererInfoFields *rendererInfoOut, GLMDisplayInfoFields *displayInfoOut )
{
	if (fakeAdapterIndex >= GetFakeAdapterCount() )
	{
		*rendererOut = 0;
		*displayOut = 0;
		return true;		// fail
	}

	*rendererOut = m_fakeAdapters[fakeAdapterIndex].m_rendererIndex;
	*displayOut = m_fakeAdapters[fakeAdapterIndex].m_displayIndex;

	bool rendResult = GetRendererInfo( *rendererOut, rendererInfoOut );
	bool dispResult = GetDisplayInfo( *rendererOut, *displayOut, displayInfoOut );
	
	return rendResult || dispResult;
}
	

int		GLMDisplayDB::GetRendererCount( void )
{
	return	m_renderers->Count();
}

bool	GLMDisplayDB::GetRendererInfo( int rendererIndex, GLMRendererInfoFields *infoOut )
{
	memset( infoOut, 0, sizeof( GLMRendererInfoFields ) );

	if (rendererIndex >= GetRendererCount())
		return true; // fail
	
	GLMRendererInfo *rendInfo = (*m_renderers)[rendererIndex];		
	*infoOut = rendInfo->m_info;

	return false;
}

int		GLMDisplayDB::GetDisplayCount( int rendererIndex )
{
	if (rendererIndex >= GetRendererCount())
		return 0; // fail
	
	GLMRendererInfo *rendInfo = (*m_renderers)[rendererIndex];
		
	return	rendInfo->m_displays->Count();
}

bool	GLMDisplayDB::GetDisplayInfo( int rendererIndex, int displayIndex, GLMDisplayInfoFields *infoOut )
{
	memset( infoOut, 0, sizeof( GLMDisplayInfoFields ) );
	
	if (rendererIndex >= GetRendererCount())
		return true; // fail
	
	if (displayIndex >= GetDisplayCount(rendererIndex))
		return true; // fail
	
	GLMDisplayInfo *displayInfo = (*(*m_renderers)[rendererIndex]->m_displays)[displayIndex];
	*infoOut = displayInfo->m_info;

	return false;
}

int		GLMDisplayDB::GetModeCount( int rendererIndex, int displayIndex )
{
	if (rendererIndex >= GetRendererCount())
		return 0; // fail
	
	if (displayIndex >= GetDisplayCount(rendererIndex))
		return 0; // fail
		
	GLMDisplayInfo *displayInfo = (*(*m_renderers)[rendererIndex]->m_displays)[displayIndex];

	return displayInfo->m_modes->Count();
}

bool	GLMDisplayDB::GetModeInfo( int rendererIndex, int displayIndex, int modeIndex, GLMDisplayModeInfoFields *infoOut )
{
	memset( infoOut, 0, sizeof( GLMDisplayModeInfoFields ) );
	
	if (rendererIndex >= GetRendererCount())
		return true; // fail
	
	if (displayIndex >= GetDisplayCount(rendererIndex))
		return true; // fail
	
	if (modeIndex >= GetModeCount(rendererIndex,displayIndex))
		return true; // fail
	
	if (modeIndex>=0)
	{
		GLMDisplayMode *displayModeInfo = (*(*(*m_renderers)[rendererIndex]->m_displays)[displayIndex]->m_modes)[ modeIndex ];
		*infoOut = displayModeInfo->m_info;
	}
	else
	{
		// passing modeIndex = -1 means "tell me about current mode"..

		GLMRendererInfo		*rendInfo = (*m_renderers)[ rendererIndex ];
		GLMDisplayInfo		*dispinfo = (*rendInfo ->m_displays)[displayIndex];	
		CGDirectDisplayID	cgid = dispinfo->m_info.m_cgDisplayID;
		
		CFDictionaryRef		curModeDict = CGDisplayCurrentMode( cgid );
		CFNumberRef			number;
		CFBooleanRef		boolean;
		CFArrayRef			modeList;
		CGDisplayErr		cgderr;
		
		// get the mode number from the mode dict (using system mode numbering, not our sorted numbering)
		if (curModeDict)
		{
			int modeIndex=0;
			number = (CFNumberRef)CFDictionaryGetValue(curModeDict, kCGDisplayMode);
			CFNumberGetValue(number, kCFNumberIntType, &modeIndex);

			// grab the width and height, I am unclear on whether this is the displayed FB width or the display device width.
			int screenWidth=0;
			int screenHeight=0;
			int refreshHz=0;
			
			number = (CFNumberRef)CFDictionaryGetValue(curModeDict, kCGDisplayWidth);
			CFNumberGetValue(number, kCFNumberIntType, &screenWidth);
			number = (CFNumberRef)CFDictionaryGetValue(curModeDict, kCGDisplayHeight);
			CFNumberGetValue(number, kCFNumberIntType, &screenHeight);
			number = (CFNumberRef)CFDictionaryGetValue(curModeDict, kCGDisplayRefreshRate);
			CFNumberGetValue(number, kCFNumberIntType, &refreshHz);
			
			GLMPRINTF(( "-D- GLMDisplayDB::GetModeInfo sees mode-index=%d, width=%d, height=%d on CGID %08x (display index %d on rendererindex %d)", 
				modeIndex,
				screenWidth,
				screenHeight,
				cgid,
				displayIndex,
				rendererIndex ));

			// now match
			int foundIndex = -1;
			FOR_EACH_VEC( (*dispinfo->m_modes), i )
			{
				GLMDisplayMode *mode = (*dispinfo->m_modes)[i];
				
				if (mode->m_info.m_modePixelWidth == screenWidth)
				{
					if (mode->m_info.m_modePixelHeight == screenHeight)
					{
						if (mode->m_info.m_modeRefreshHz == refreshHz)
						{
							foundIndex = i;
							*infoOut = mode->m_info;
							return false;
						}
					}
				}
			}
		}

		// if we get here, we could not find the mode
		memset( infoOut, 0, sizeof( *infoOut ) );
		return true; // fail
	}
	return false;
}


void	GLMDisplayDB::Dump( void )
{
	GLMPRINTF(("\n GLMDisplayDB @ %08x ",this ));

	FOR_EACH_VEC( *m_renderers, i )
	{
		(*m_renderers)[i]->Dump(i);
	}
}

//===============================================================================

GLMDisplayInfo::GLMDisplayInfo( CGDirectDisplayID displayID, CGOpenGLDisplayMask displayMask )
{	
	m_info.m_cgDisplayID			= displayID;
	m_info.m_glDisplayMask			= displayMask;
	
	// extract info about this display such as pixel width and height
	m_info.m_displayPixelWidth		= (uint)CGDisplayPixelsWide( m_info.m_cgDisplayID );
	m_info.m_displayPixelHeight		= (uint)CGDisplayPixelsHigh( m_info.m_cgDisplayID );

	m_modes = NULL;
}

GLMDisplayInfo::~GLMDisplayInfo( void )
{
	if (m_modes)
	{
		// delete all the new'd display modes
		FOR_EACH_VEC( *m_modes, i )
		{
			delete (*this->m_modes)[i];
		}
		delete m_modes;
		m_modes = NULL;
	}
}


extern "C" int DisplayModeSortFunction( GLMDisplayMode * const *A, GLMDisplayMode * const *B )
{
	int bigger = -1;
	int smaller = 1;	// adjust these for desired ordering

	// check refreshrate - higher should win
	if ( (*A)->m_info.m_modeRefreshHz > (*B)->m_info.m_modeRefreshHz )
	{	
		return bigger;
	}
	else if ( (*A)->m_info.m_modeRefreshHz < (*B)->m_info.m_modeRefreshHz )
	{
		return smaller;
	}

	// check area - larger mode should win
	int areaa = (*A)->m_info.m_modePixelWidth * (*A)->m_info.m_modePixelHeight;
	int areab = (*B)->m_info.m_modePixelWidth * (*B)->m_info.m_modePixelHeight;

	if ( areaa > areab )
	{	
		return bigger;
	}
	else if ( areaa < areab )
	{
		return smaller;
	}
	
	return 0;	// equal rank
}


void	GLMDisplayInfo::PopulateModes( void )
{
	Assert( !m_modes );
	m_modes = new CUtlVector< GLMDisplayMode* >;
	
	CFArrayRef		modeList;
//	CGDisplayErr	cgderr;
	CFDictionaryRef cgvidmode;
	CFNumberRef		number;
	CFBooleanRef	boolean;
	
	modeList = CGDisplayAvailableModes( m_info.m_cgDisplayID );
	if ( modeList != NULL )
	{
		//  examine each mode
		CFIndex count = CFArrayGetCount( modeList );
		
		for (CFIndex i = 0; i < count; i++) 
		{
			long modeHeight = 0, modeWidth = 0;
			long depth = 0;
			long refreshrate = 0;
			Boolean usable, stretched = false;
			
			// grab the mode dictionary
			cgvidmode = (CFDictionaryRef)CFArrayGetValueAtIndex( modeList, i);
			
			// grab mode params we need
			number = (CFNumberRef)CFDictionaryGetValue(cgvidmode, kCGDisplayBitsPerPixel);
			CFNumberGetValue(number, kCFNumberLongType, &depth);
			
			boolean = (CFBooleanRef)CFDictionaryGetValue(cgvidmode, kCGDisplayModeUsableForDesktopGUI) ;
			usable = CFBooleanGetValue(boolean);
			
			boolean = (CFBooleanRef)CFDictionaryGetValue(cgvidmode, kCGDisplayModeIsStretched);
			if (NULL != boolean) 
			{
				stretched = CFBooleanGetValue(boolean);
			}
			
			if ( usable && (!stretched) && (depth==32) )
			{
				// we're going to log this mode to the mode table.
				
				// get height of mode
				number = (CFNumberRef)CFDictionaryGetValue( cgvidmode, kCGDisplayHeight );
				CFNumberGetValue(number, kCFNumberLongType, &modeHeight);
				
				// get width of mode
				number = (CFNumberRef)CFDictionaryGetValue( cgvidmode, kCGDisplayWidth );
				CFNumberGetValue(number, kCFNumberLongType, &modeWidth);
				
				// get refresh rate of mode
				number = (CFNumberRef)CFDictionaryGetValue( cgvidmode, kCGDisplayRefreshRate ); 
				double flrefreshrate = 0.0f;
				CFNumberGetValue( number, kCFNumberDoubleType, &flrefreshrate );
				refreshrate = (int)flrefreshrate;

				// exclude silly small modes
				if ( (modeHeight >= 384) && (modeWidth >= 512) )
				{
					GLMDisplayMode *newmode = new GLMDisplayMode( modeWidth, modeHeight, refreshrate );
					m_modes->AddToTail( newmode );
				}
			}
		}
	}
	
	// now sort the modes
	// primary key is refresh rate
	// secondary key is area

	m_modes->Sort( DisplayModeSortFunction );
}


void	GLMDisplayInfo::Dump( int which )
{
	GLMPRINTF(("\n         #%d: GLMDisplayInfo @ %08x, cg-id=%08x  display-mask=%08x  pixwidth=%d  pixheight=%d", which, (int)(intp)this, m_info.m_cgDisplayID, m_info.m_glDisplayMask, m_info.m_displayPixelWidth,  m_info.m_displayPixelHeight ));

	FOR_EACH_VEC( *m_modes, i )
	{
		(*m_modes)[i]->Dump(i);
	}
}



================================================
FILE: appframework/posixapp.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: Pieces of the application framework, shared between POSIX systems (Mac OS X, Linux, etc)
//
// $Revision: $
// $NoKeywords: $
//=============================================================================//
#include "appframework/AppFramework.h"
#include "tier0/dbg.h"
#include "tier0/icommandline.h"
#include "interface.h"
#include "filesystem.h"
#include "appframework/IAppSystemGroup.h"
#include "filesystem_init.h"
#include "tier1/convar.h"
#include "vstdlib/cvar.h"

#ifndef DEDICATED
#include "togl/rendermechanism.h"
#endif

// NOTE: This has to be the last file included! (turned off below, since this is included like a header)
#include "tier0/memdbgon.h"

//-----------------------------------------------------------------------------
// Globals...
//-----------------------------------------------------------------------------
HINSTANCE s_HInstance;

//#if !defined(LINUX)
//static CSimpleLoggingListener s_SimpleLoggingListener;
//ILoggingListener *g_pDefaultLoggingListener = &s_SimpleLoggingListener;
//#endif

//-----------------------------------------------------------------------------
// HACK: Since I don't want to refit vgui yet...
//-----------------------------------------------------------------------------
void *GetAppInstance()
{
	return s_HInstance;
}


//-----------------------------------------------------------------------------
// Sets the application instance, should only be used if you're not calling AppMain.
//-----------------------------------------------------------------------------
void SetAppInstance( void* hInstance )
{
	s_HInstance = (HINSTANCE)hInstance;
}


//-----------------------------------------------------------------------------
// Version of AppMain used by windows applications
//-----------------------------------------------------------------------------

int AppMain( void* hInstance, void* hPrevInstance, const char* lpCmdLine, int nCmdShow, CAppSystemGroup *pAppSystemGroup )
{
	Assert( 0 );
	return -1;
}

//#if !defined(LINUX)
//static CNonFatalLoggingResponsePolicy s_NonFatalLoggingResponsePolicy;
//#endif

//-----------------------------------------------------------------------------
// Version of AppMain used by console applications
//-----------------------------------------------------------------------------
int AppMain( int argc, char **argv, CAppSystemGroup *pAppSystemGroup )
{
	Assert( pAppSystemGroup );

	//#if !defined(LINUX)
	//	LoggingSystem_SetLoggingResponsePolicy( &s_NonFatalLoggingResponsePolicy );
	//#endif
	s_HInstance = NULL;
	CommandLine()->CreateCmdLine( argc, argv );

	return pAppSystemGroup->Run( );
}



//-----------------------------------------------------------------------------
//
// Default implementation of an application meant to be run using Steam
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Constructor
//-----------------------------------------------------------------------------
CSteamApplication::CSteamApplication( CSteamAppSystemGroup *pAppSystemGroup )
{
	m_pChildAppSystemGroup = pAppSystemGroup;
	m_pFileSystem = NULL;
}


//-----------------------------------------------------------------------------
// Create necessary interfaces
//-----------------------------------------------------------------------------
bool CSteamApplication::Create( )
{
	FileSystem_SetErrorMode( FS_ERRORMODE_NONE );

	char pFileSystemDLL[MAX_PATH];
	if ( FileSystem_GetFileSystemDLLName( pFileSystemDLL, MAX_PATH, m_bSteam ) != FS_OK )
		return false;

	// Add in the cvar factory
	AppModule_t cvarModule = LoadModule( VStdLib_GetICVarFactory() );
	AddSystem( cvarModule, CVAR_INTERFACE_VERSION );	

	AppModule_t fileSystemModule = LoadModule( pFileSystemDLL );
	m_pFileSystem = (IFileSystem*)AddSystem( fileSystemModule, FILESYSTEM_INTERFACE_VERSION );
	if ( !m_pFileSystem )
	{
		Error( "Unable to load %s", pFileSystemDLL );
		return false;
	}

	return true;
}


//-----------------------------------------------------------------------------
// The file system pointer is invalid at this point
//-----------------------------------------------------------------------------
void CSteamApplication::Destroy()
{
	m_pFileSystem = NULL;
}


//-----------------------------------------------------------------------------
// Pre-init, shutdown
//-----------------------------------------------------------------------------
bool CSteamApplication::PreInit( )
{
	return true;
}

void CSteamApplication::PostShutdown( )
{
}


//-----------------------------------------------------------------------------
// Run steam main loop
//-----------------------------------------------------------------------------
int CSteamApplication::Main( )
{
	// Now that Steam is loaded, we can load up main libraries through steam
	m_pChildAppSystemGroup->Setup( m_pFileSystem, this );
	return m_pChildAppSystemGroup->Run( );
}


int CSteamApplication::Startup()
{
	int nRetVal = BaseClass::Startup();
	if ( GetErrorStage() != NONE )
		return nRetVal;
	
	if ( FileSystem_SetBasePaths( m_pFileSystem ) != FS_OK )
		return 0;
	
	// Now that Steam is loaded, we can load up main libraries through steam
	m_pChildAppSystemGroup->Setup( m_pFileSystem, this );
	return m_pChildAppSystemGroup->Startup();
}


void CSteamApplication::Shutdown()
{
	m_pChildAppSystemGroup->Shutdown();
	BaseClass::Shutdown();
}

// Turn off memdbg macros (turned on up top) since this is included like a header
#include "tier0/memdbgoff.h"




================================================
FILE: appframework/sdlmgr.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: An application framework  
//
//=============================================================================//

#ifdef USE_SDL
#include "SDL.h"
#include "SDL_opengl.h"
#endif

#include "appframework/ilaunchermgr.h"
#include "inputsystem/ButtonCode.h"

#include "togl/rendermechanism.h"

#include "tier0/vprof_telemetry.h"
#include "tier0/icommandline.h"

#include "tier1/utllinkedlist.h"
#include "tier1/convar.h"
#ifdef TOGLES
#include <EGL/egl.h>
#endif

// NOTE: This has to be the last file included! (turned off below, since this is included like a header)
#include "tier0/memdbgon.h"

#ifdef GLMPRINTF
#undef GLMPRINTF
#endif

#if GLMDEBUG
#define GLMPRINTF(args)	printf args
#else
#define GLMPRINTF(args)
#endif

#if defined( OSX ) || defined( ANDROID )
ConVar rawinput_set_one_time( "rawinput_set_one_time", "0", FCVAR_ARCHIVE|FCVAR_HIDDEN, "");
#endif

ConVar gl_blit_halfx( "gl_blit_halfx", "0" );
ConVar gl_blit_halfy( "gl_blit_halfy", "0" );
ConVar gl_swapdebug( "gl_swapdebug", "0");
ConVar gl_swaplimit( "gl_swaplimit", "0");
ConVar gl_swapinterval( "gl_swapinterval", "0");
ConVar gl_swaplimit_mt( "gl_swaplimit_mt", "3");
ConVar gl_disable_forced_vsync( "gl_disable_forced_vsync", "0" );
ConVar gl_swaptear( "gl_swaptear", "1" );
ConVar gl_finish( "gl_finish", "0" );

ConVar sdl_double_click_size( "sdl_double_click_size", "2" );
ConVar sdl_double_click_time( "sdl_double_click_time", "400" );

#if defined( DX_TO_GL_ABSTRACTION )
COpenGLEntryPoints *gGL = NULL;
#endif

const int kBogusSwapInterval = INT_MAX;

#if defined ANDROID || defined TOGLES
static void *l_gl4es = NULL;
static void *l_egl = NULL;
static void *l_gles = NULL;

typedef void *(*t_glGetProcAddress)( const char * );
typedef EGLBoolean (*t_eglBindAPI)(EGLenum api);
typedef EGLBoolean (*t_eglInitialize)(EGLDisplay display, EGLint *major, EGLint *minor);
typedef EGLDisplay (*t_eglGetDisplay)(NativeDisplayType native_display);
typedef char const *(*t_eglQueryString)(EGLDisplay display, EGLint name);

t_eglBindAPI _eglBindAPI;
t_glGetProcAddress _glGetProcAddress;
t_eglInitialize _eglInitialize;
t_eglGetDisplay _eglGetDisplay;
t_eglQueryString _eglQueryString;
#endif

/*
From Ryan Gordon:
 
SDL's FULLSCREEN_DESKTOP mode on the mac now
puts the game in its own fullscreen Space on OS X 10.7 and later, as of
SDL 2.0.3, I think.

There were several benefits to this, but it's possible (likely even)
that Apple unhelpfully clamps you to vsync in this scenario, which would
explain the 60fps max.

There are a few options:
- SDL_WAINDOW_FULLSCREEN mode will not use this new magic (only
SDL_WINDOW_FULLSCREEN_DESKTOP), but that brings other problems and I
wouldn't recommend a drastic change like that.

- You can force the old behavior with this hint:

     SDL_SetHint(SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES, "1");

...which must be called before SDL_Init(SDL_INIT_VIDEO) at the moment
(that can be changed if you'd like to add a menu option that wants to
toggle this setting at runtime, though). One can also force this with an
environment variable, for what that's worth to most Mac users:

     export SDL_VIDEO_MAC_FULLSCREEN_SPACES=0

- I haven't tried it, but maybe one can force vsync off with
SDL_GL_SetSwapInterval(), and it's just that the default is different
for Fullscreen Spaces? Simplest solution if it works, but I don't know.

You can certainly just force it off to put the game back to the way it
worked before, but the user experience is much nicer when you can just
slide between the game and your desktop, etc. Discounting the clamp to
Vsync, we found that a Fullscreen Space got a slightly faster framerate,
too (plus it's how Apple "wants" you to do fullscreen at this point, etc).

And of course, this is Mac-specific: this is in the Cocoa backend, and
thus doesn't affect Windows or Linux, etc. 
*/

static void DebugPrintf( const char *pMsg, ... )
{
	va_list args;
	va_start( args, pMsg );
	char buf[2048];
	V_vsnprintf( buf, sizeof( buf ), pMsg, args );
	va_end( args );

	Plat_DebugString( buf );
}

// #define SDLAPP_DEBUG
#ifdef SDLAPP_DEBUG
class LinuxAppFuncLogger
{
	public:
		LinuxAppFuncLogger( const char *funcName ) : m_funcName( funcName )
		{
			printf( ">%s\n", m_funcName );
		};
		
		LinuxAppFuncLogger( const char *funcName, char *fmt, ... )
		{
			m_funcName = funcName;

			va_list	vargs;
			va_start(vargs, fmt);
			vprintf( fmt, vargs );
			va_end( vargs );
		}
		
		~LinuxAppFuncLogger( )
		{
			printf( "<%s\n", m_funcName );
		};
	
		const char *m_funcName;
};
#define	SDLAPP_FUNC			LinuxAppFuncLogger _logger_( __FUNCTION__ )
#else
#define SDLAPP_FUNC
#endif


#if defined( DX_TO_GL_ABSTRACTION )
void	CheckGLError( int line )
{
	SDLAPP_FUNC;

	// Don't check this in enabled! glGetError() is extremely slow with threaded drivers.
	return;
	//char errbuf[1024];

	//borrowed from GLMCheckError.. slightly different
	
	
	GLenum errorcode = (GLenum)gGL->glGetError();
	//GLenum errorcode2 = 0;
	if ( errorcode != GL_NO_ERROR )
	{
		const char	*decodedStr = GLMDecode( eGL_ERROR, errorcode );

		printf( "\n(%d) GL Error %08x = '%s'", line, errorcode, decodedStr );
	}
}
#endif

//-----------------------------------------------------------------------------
#if !defined( DEDICATED )

void *VoidFnPtrLookup_GlMgr(const char *fn, bool &okay, const bool bRequired, void *fallback)
{
	void *retval = NULL;

#ifndef TOGLES // TODO(nillerusr): remove this hack
	if ((!okay) && (!bRequired))  // always look up if required (so we get a complete list of crucial missing symbols).
		return NULL;
#endif

	// The SDL path would work on all these platforms, if we were using SDL there, too...


#if defined ANDROID || defined TOGLES
	// SDL does the right thing, so we never need to use tier0 in this case.
	if( _glGetProcAddress )
	{
		retval = _glGetProcAddress(fn);

		if( !retval && l_gles )
			retval = dlsym( l_gles, fn );
	}
	//printf("CDynamicFunctionOpenGL: SDL_GL_GetProcAddress(\"%s\") returned %p\n", fn, retval);
	if ((retval == NULL) && (fallback != NULL))
	{
		//printf("CDynamicFunctionOpenGL: Using fallback %p for \"%s\"\n", fallback, fn);
		retval = fallback;
	}
#elif defined( USE_SDL )
	// SDL does the right thing, so we never need to use tier0 in this case.
	retval = SDL_GL_GetProcAddress(fn);
	//printf("CDynamicFunctionOpenGL: SDL_GL_GetProcAddress(\"%s\") returned %p\n", fn, retval);
	if ((retval == NULL) && (fallback != NULL))
	{
		//printf("CDynamicFunctionOpenGL: Using fallback %p for \"%s\"\n", fallback, fn);
		retval = fallback;
	}
#else
	#error Unimplemented
#endif

	// Note that a non-NULL response doesn't mean it's safe to call the function!
	//  You always have to check that the extension is supported;
	//  an implementation MAY return NULL in this case, but it doesn't have to (and doesn't, with the DRI drivers).

#ifdef TOGLES // TODO(nillerusr): remove this hack
	okay = retval != NULL;
#else
	okay = (okay && (retval != NULL));
#endif
	if (bRequired && !okay)
	{
		// We can't continue execution, because one or more GL function pointers will be NULL.
		Error( "Could not find required OpenGL entry point '%s'! Either your video card is unsupported, or your OpenGL driver needs to be updated.\n", fn);
	}

	return retval;
}

class CSDLMgr : public ILauncherMgr
{
public:

	CSDLMgr();

// ILauncherMgr impls.
public:
	virtual bool Connect( CreateInterfaceFn factory );
	virtual void Disconnect();
	
	virtual void *QueryInterface( const char *pInterfaceName );
	
	// Init, shutdown
	virtual InitReturnVal_t Init();
	virtual void Shutdown();

	virtual bool CreateGameWindow( const char *pTitle, bool bWindowed, int width, int height );
	
	virtual void IncWindowRefCount();
	virtual void DecWindowRefCount();

	// Get the next N events. The function returns the number of events that were filled into your array.
	virtual int GetEvents( CCocoaEvent *pEvents, int nMaxEventsToReturn, bool debugEvents = false );
#if defined(LINUX) || defined(PLATFORM_BSD)
	virtual int PeekAndRemoveKeyboardEvents( bool *pbEsc, bool *pbReturn, bool *pbSpace, bool debugEvent = false );
#endif

	// Set the mouse cursor position.
	virtual void SetCursorPosition( int x, int y );
	
	virtual void *GetWindowRef() { return (void *)m_Window; }

	virtual void SetWindowFullScreen( bool bFullScreen, int nWidth, int nHeight );
	virtual bool IsWindowFullScreen() { return m_bFullScreen; }
	virtual void MoveWindow( int x, int y );
	virtual void SizeWindow( int width, int tall );
	virtual void PumpWindowsMessageLoop();
		
	virtual void DestroyGameWindow();
	virtual void SetApplicationIcon( const char *pchAppIconFile );
	
	virtual void GetMouseDelta( int &x, int &y, bool bIgnoreNextMouseDelta = false );

	virtual void GetNativeDisplayInfo( int nDisplay, uint &nWidth, uint &nHeight, uint &nRefreshHz ); // Retrieve the size of the monitor (desktop)
	virtual void RenderedSize( uint &width, uint &height, bool set );	// either set or retrieve rendered size value (from dxabstract)
	virtual void DisplayedSize( uint &width, uint &height );			// query backbuffer size (window size whether FS or windowed)

#if defined( DX_TO_GL_ABSTRACTION )
	virtual void GetDesiredPixelFormatAttribsAndRendererInfo( uint **ptrOut, uint *countOut, GLMRendererInfoFields *rendInfoOut );

	virtual PseudoGLContextPtr	GetMainContext();
	// Get the NSGLContext for a window's main view - note this is the carbon windowref as an argument
	virtual PseudoGLContextPtr GetGLContextForWindow( void* windowref ) { return (PseudoGLContextPtr)m_GLContext; }
	virtual PseudoGLContextPtr CreateExtraContext();
	virtual void DeleteContext( PseudoGLContextPtr hContext );
	virtual bool MakeContextCurrent( PseudoGLContextPtr hContext );
	virtual GLMDisplayDB *GetDisplayDB( void );

	virtual void ShowPixels( CShowPixelsParams *params );
#endif

	virtual void GetStackCrawl( CStackCrawlParams *params );

	virtual void WaitUntilUserInput( int msSleepTime );

	// Post an event to the input event queue.
	// if debugEvent is true, post it to the debug event queue.
	void PostEvent( const CCocoaEvent &theEvent, bool debugEvent=false );

	// ask if an event is debug flavor or not.
	bool IsDebugEvent( CCocoaEvent& event );

	virtual void SetMouseVisible( bool bState );
	virtual void SetMouseCursor( SDL_Cursor *hCursor );
	virtual void SetForbidMouseGrab( bool bForbidMouseGrab ) { m_bForbidMouseGrab = bForbidMouseGrab; }

	virtual void OnFrameRendered();

	virtual void SetGammaRamp( const uint16 *pRed, const uint16 *pGreen, const uint16 *pBlue );
			
	virtual double GetPrevGLSwapWindowTime() { return m_flPrevGLSwapWindowTime; }

	// Called to create a game window that will be hidden, designed for
	// getting an OpenGL context going so we can begin initializing things.
	bool CreateHiddenGameWindow( const char *pTitle, int width, int height );
					
private:
	void handleKeyInput( const SDL_Event &event );

#if defined( DX_TO_GL_ABSTRACTION )
	SDL_GLContext m_GLContext;
	GLuint m_readFBO;
	GLMDisplayDB *m_displayDB;
#endif

#if defined( OSX )
	// bool					m_leopard;					// true if <10.6.3 and we have to do extra work for fullscreen handling
	bool					m_force_vsync;				// true if 10.6.4 + bad NV driver
#endif

	uint m_nWindowRefCount;

	SDL_Window *m_Window;

	bool m_bCursorVisible;
	bool m_bSetMouseVisibleCalled;
	SDL_Cursor *m_hCursor;
	bool m_bSetMouseCursorCalled;

	bool m_bHasFocus;
	bool m_bFullScreen;
	bool m_SizeWindowFullScreenState; // fullscreen state when SizeWindow() was called.
	bool m_bForbidMouseGrab;

	bool m_WindowShownAndRaised;

	int m_nMouseXDelta;
	int m_nMouseYDelta;

	int m_ScreenWidth;
	int m_ScreenHeight;

	int m_renderedWidth;
	int m_rendererHeight;

	int m_WindowWidth;
	int m_WindowHeight;

  	bool m_bExpectSyntheticMouseMotion;
	int m_nMouseTargetX;
	int m_nMouseTargetY;
	int m_nWarpDelta;
	bool m_bRawInput;

	int m_lastKnownSwapInterval;	// -1 if unknown, 0/1 otherwise
	int m_lastKnownSwapLimit;		// -1 if unknown, 0/1 otherwise

	int m_pixelFormatAttribs[32];
	int m_pixelFormatAttribCount;

	float m_flMouseXScale;
	float m_flMouseYScale;

	// !!! FIXME: can we rename these from "Cocoa"?
	CThreadMutex m_CocoaEventsMutex;					// use for either queue below
	CUtlLinkedList<CCocoaEvent,int> m_CocoaEvents;
	CUtlLinkedList<CCocoaEvent,int> m_DebugEvents;		// intercepted keys which wil be passed over to GLM

	uint m_keyModifierMask;
	uint32_t m_keyModifiers;
	uint32_t m_mouseButtons;

	bool m_bGotMouseButtonDown;
	Uint32 m_MouseButtonDownTimeStamp;
	int m_MouseButtonDownX;
	int m_MouseButtonDownY;

	bool m_bResetVsync;
	int m_nFramesToSkip;

	double m_flPrevGLSwapWindowTime;
};

ILauncherMgr *g_pLauncherMgr = NULL;

void* CreateSDLMgr()
{
	if ( g_pLauncherMgr == NULL )
	{
		g_pLauncherMgr = new CSDLMgr();
	}
	return (void *)g_pLauncherMgr;
}

// Display index where we are currently fullscreen on (or -1).
ConVar sdl_displayindex_fullscreen( "sdl_displayindex_fullscreen", "-1", FCVAR_HIDDEN );

// Display index to show window on.
static bool g_bSDLDisplayindexSet = false;
static void sdl_displayindex_changed( IConVar *pConVar, const char *pOldString, float flOldValue );
ConVar sdl_displayindex( "sdl_displayindex", "0", FCVAR_HIDDEN, "SDL fullscreen display index.", sdl_displayindex_changed );
static void sdl_displayindex_changed( IConVar *pConVar, const char *pOldString, float flOldValue )
{
	int NumVideoDisplays = SDL_GetNumVideoDisplays();

	if ( ( sdl_displayindex.GetInt() < 0 ) || ( sdl_displayindex.GetInt() >= NumVideoDisplays ) )
	{
		sdl_displayindex.SetValue( 0 );
	}

	g_bSDLDisplayindexSet = true;
}


// Return display index of largest SDL display ( plus width & height ).
static int GetLargestDisplaySize( int& Width, int& Height )
{
	int nDisplay = 0;

	Width = 640;
	Height = 480;

	for ( int i = 0; i < SDL_GetNumVideoDisplays(); i++ )
	{
		SDL_Rect rect = { 0, 0, 0, 0 };

		SDL_GetDisplayBounds( i, &rect );

		if ( ( rect.w > Width ) || ( ( rect.w == Width ) && ( rect.h > Height ) ) )
		{
			Width = rect.w;
			Height = rect.h;

			nDisplay = i;
		}
	}

	return nDisplay;
}

CON_COMMAND( grab_window, "grab/ungrab window." )
{
	if ( g_pLauncherMgr && g_pLauncherMgr->GetWindowRef() )
	{
		SDL_bool bGrab;
		SDL_Window *pWindow = ( SDL_Window * )g_pLauncherMgr->GetWindowRef();

		if ( args.ArgC() >= 2 )
		{
			bGrab = ( args[ 1 ][ 0 ] == '1' ) ? SDL_TRUE : SDL_FALSE;
		}
		else
		{
			bGrab = SDL_GetWindowGrab( pWindow ) ? SDL_FALSE : SDL_TRUE;
		}

		g_pLauncherMgr->SetForbidMouseGrab( !bGrab );

		if ( bGrab != SDL_GetWindowGrab( pWindow ) )
		{
			Msg( "SetWindowGrab( %s )\n", bGrab ? "true" : "false" );
			SDL_SetWindowGrab( pWindow, bGrab );

			// force non-fullscreen windows to the foreground if grabbed, so you can't
			//  get your mouse locked to something in the background.
			if ( bGrab && !g_pLauncherMgr->IsWindowFullScreen() )
			{
				SDL_RaiseWindow( pWindow );
			}
		}
	}
}

CSDLMgr::CSDLMgr()
{
	m_Window = NULL;
	Init();
}

InitReturnVal_t CSDLMgr::Init()
{
	SDLAPP_FUNC;

	if (m_Window != NULL)
		return INIT_OK;  // already initialized.

	if (!SDL_WasInit(SDL_INIT_VIDEO))
	{
		if (SDL_Init(SDL_INIT_VIDEO) == -1)
			Error( "SDL_Init(SDL_INIT_VIDEO) failed: %s", SDL_GetError() );

#if defined( DX_TO_GL_ABSTRACTION )
		if ( CommandLine()->FindParm( "-gl_debug" ) )
		{
			SDL_GL_SetAttribute( SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG );
		}

#if defined( TOGLES )
		if (SDL_GL_LoadLibrary("libGLESv3.so") == -1)
#else
		if (SDL_GL_LoadLibrary(NULL) == -1)
#endif
			Error( "SDL_GL_LoadLibrary(NULL) failed: %s", SDL_GetError() );
#endif
	}

	fprintf(stderr, "SDL video target is '%s'\n", SDL_GetCurrentVideoDriver());
	Msg("SDL video target is '%s'\n", SDL_GetCurrentVideoDriver());

	m_bForbidMouseGrab = true;
	if ( !CommandLine()->FindParm("-nomousegrab") && CommandLine()->FindParm("-mousegrab") )
	{
		m_bForbidMouseGrab = false;
	}

	m_WindowShownAndRaised = false;

	m_bCursorVisible = true;
	m_bSetMouseVisibleCalled = false;
	m_hCursor = NULL;
	m_bSetMouseCursorCalled = false;

	m_bHasFocus = true;
	m_keyModifiers = 0;
	m_keyModifierMask = 0;
	m_mouseButtons = 0;
#if defined( DX_TO_GL_ABSTRACTION )
	m_GLContext = NULL;
	m_readFBO = 0;
	m_displayDB = NULL;
#endif
	m_nWindowRefCount = 0;
	m_Window = NULL;
	m_bFullScreen = false;
	m_SizeWindowFullScreenState = false;
	m_nMouseXDelta = 0;
	m_nMouseYDelta = 0;
	m_ScreenWidth = 0;
	m_ScreenHeight = 0;
	m_renderedWidth = 0;
	m_rendererHeight = 0;
	m_WindowWidth = 0;
	m_WindowHeight = 0;
	m_pixelFormatAttribCount = 0;
	m_lastKnownSwapInterval = kBogusSwapInterval;
	m_lastKnownSwapLimit = -1;
	m_flMouseXScale = 1.0f;
	m_flMouseYScale = 1.0f;

	m_bGotMouseButtonDown = false;
	m_MouseButtonDownTimeStamp = 0;
	m_MouseButtonDownX = 0;
	m_MouseButtonDownY = 0;

	m_bExpectSyntheticMouseMotion = false;
	m_nMouseTargetX = 0;
	m_nMouseTargetY = 0;
	m_nWarpDelta = 0;
	m_bRawInput = false;

	m_nFramesToSkip = 0;
	m_bResetVsync = false;

	m_flPrevGLSwapWindowTime = 0.0f;

	memset(m_pixelFormatAttribs, '\0', sizeof (m_pixelFormatAttribs));

	int *attCursor = m_pixelFormatAttribs;

#define SET_GL_ATTR(key,value) \
	*(attCursor++) = (int) (key); \
	*(attCursor++) = (int) (value);


#ifdef TOGLES
	l_egl = dlopen("libEGL.so", RTLD_LAZY);
	l_gles = dlopen("libGLESv3.so", RTLD_LAZY);

	if( l_egl )
	{
		_glGetProcAddress = (t_glGetProcAddress)dlsym(l_egl, "eglGetProcAddress");
	}

	SET_GL_ATTR(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
	SET_GL_ATTR(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SET_GL_ATTR(SDL_GL_CONTEXT_MINOR_VERSION, 0);

	_eglInitialize = (t_eglInitialize)dlsym(l_egl, "eglInitialize");
	_eglGetDisplay = (t_eglGetDisplay)dlsym(l_egl, "eglGetDisplay");
	_eglQueryString = (t_eglQueryString)dlsym(l_egl, "eglQueryString");

	if( _eglInitialize && _eglInitialize && _eglQueryString )
	{
		EGLDisplay display = _eglGetDisplay(EGL_DEFAULT_DISPLAY);
		if( _eglInitialize(display, NULL, NULL) != -1
			&& strstr(_eglQueryString(display, EGL_EXTENSIONS) ,"EGL_KHR_gl_colorspace") )
				SET_GL_ATTR(SDL_GL_FRAMEBUFFER_SRGB_CAPABLE, 1)
	}
#elif ANDROID
	bool m_bOGL = false;

	l_egl = dlopen("libEGL.so", RTLD_LAZY);

	if( l_egl )
	{
		_eglBindAPI = (t_eglBindAPI)dlsym(l_egl, "eglBindAPI");

		if( _eglBindAPI && _eglBindAPI(EGL_OPENGL_API) )
		{
			Msg("OpenGL support found!\n");
			m_bOGL = true;
		}
	}


	if( m_bOGL )
	{
		_glGetProcAddress = (t_glGetProcAddress)dlsym(l_egl, "eglGetProcAddress");
		SET_GL_ATTR(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
	}
	else
	{
		l_gl4es = dlopen("libgl4es.so", RTLD_LAZY);
		_glGetProcAddress = (t_glGetProcAddress)dlsym(l_gl4es, "gl4es_glGetProcAddress");
	}
#endif
	SET_GL_ATTR(SDL_GL_RED_SIZE, 8);
	SET_GL_ATTR(SDL_GL_GREEN_SIZE, 8);
	SET_GL_ATTR(SDL_GL_BLUE_SIZE, 8);
	SET_GL_ATTR(SDL_GL_ALPHA_SIZE, 8);
	SET_GL_ATTR(SDL_GL_DOUBLEBUFFER, 1);

#ifdef OSX
	SET_GL_ATTR(SDL_GL_DEPTH_SIZE, 0);
#else
	SET_GL_ATTR(SDL_GL_DEPTH_SIZE, 24);
	SET_GL_ATTR(SDL_GL_STENCIL_SIZE, 8);
#endif

	SET_GL_ATTR(SDL_GL_ACCELERATED_VISUAL, 1);

	#undef SET_GL_ATTR

	m_pixelFormatAttribCount = (attCursor - &m_pixelFormatAttribs[0]) / 2;

	// we need a GL context before we dig down further, since we're calling
	//  GL entry points, but the game hasn't made a window yet. So it's time
	//  to make a window! We make a 640x480 one here, and later, when asked
	//  to really actually make a window, we just resize the one we built here.
	if ( !CreateHiddenGameWindow( "", 1280, 720 ) )
		Error( "CreateGameWindow failed" );

	SDL_HideWindow( m_Window );

	return INIT_OK;
}

bool CSDLMgr::Connect( CreateInterfaceFn factory )
{
	SDLAPP_FUNC;

	return true;
}

void CSDLMgr::Disconnect()
{
	SDLAPP_FUNC;

}

void *CSDLMgr::QueryInterface( const char *pInterfaceName )
{
	SDLAPP_FUNC;
	if ( !Q_stricmp( pInterfaceName, SDLMGR_INTERFACE_VERSION ) )
		return this;
	return NULL;
}

void CSDLMgr::Shutdown()
{
	SDLAPP_FUNC;

	if (gGL && m_readFBO)
#ifdef TOGLES
		gGL->glDeleteFramebuffers(1, &m_readFBO);
#else
		gGL->glDeleteFramebuffersEXT(1, &m_readFBO);
#endif
	m_readFBO = 0;

	if ( m_Window )
	{
		// Slam down the window refcount to 1 to guarantee the main GL context and window are killed.
		m_nWindowRefCount = 1;
		DestroyGameWindow();
	}

	SDL_GL_UnloadLibrary();
	SDL_QuitSubSystem(SDL_INIT_VIDEO);
}

bool CSDLMgr::CreateGameWindow( const char *pTitle, bool bWindowed, int width, int height )
{
	SDLAPP_FUNC;

	// CreateGameWindow is being called. The the game initially calls this with width and height == 0.
	//  But we don't want to show the window until it gets resized to what it should be, so we keep track as to whether
	//  ShowWindow / RaiseWindow has been called yet in here, and if not we do the SDL_ShowWindow in
	//	the MoveWindow() function down below.
	bool bShowWindow = true;
	m_WindowShownAndRaised = false;

	if ( ( width <= 0 ) || ( height <= 0 ) )
	{
		bShowWindow = false;

		// Don't mess with current width, height - use current (or sane defaults).
		uint defaultWidth = 0;
		uint defaultHeight = 0;
		uint defaultRefreshHz = 0; // Not used

		this->GetNativeDisplayInfo( -1, defaultWidth, defaultHeight, defaultRefreshHz );

		if ( 0 == defaultWidth ) defaultWidth = 1024;
		if ( 0 == defaultHeight ) defaultHeight = 768;

		width = m_WindowWidth ? m_WindowWidth : defaultWidth;
		height = m_WindowHeight ? m_WindowHeight : defaultHeight;
	}

	if ( m_Window )
	{
		if ( pTitle )
		{
			SDL_SetWindowTitle( m_Window, pTitle );
		}

		if ( ( m_bFullScreen != !bWindowed ) ||
			 ( !bWindowed && ( sdl_displayindex.GetInt() != sdl_displayindex_fullscreen.GetInt() ) ) )
		{
			SetWindowFullScreen( !bWindowed, width, height );
		}
		else if ( bShowWindow )
		{
			SizeWindow( width, height );
		}

		if ( bShowWindow )
		{
			SDL_ShowWindow( m_Window );
			SDL_RaiseWindow( m_Window );

			m_WindowShownAndRaised = true;
		}

		return true;
	}

	if ( CreateHiddenGameWindow( pTitle, width, height ) )
	{
		SDL_ShowWindow( m_Window );
		return true;
	}
	else
	{
		return false;
	}
}

bool CSDLMgr::CreateHiddenGameWindow( const char *pTitle, int width, int height )
{
	Assert( !m_Window );
	Assert( !m_bFullScreen );

	m_bFullScreen = false;
	sdl_displayindex_fullscreen.SetValue( -1 );

#if defined( DX_TO_GL_ABSTRACTION )
	// Set up GL context...
	const int *attrib = m_pixelFormatAttribs;
	for (int i = 0; i < m_pixelFormatAttribCount; i++, attrib += 2)
		SDL_GL_SetAttribute((SDL_GLattr) attrib[0], attrib[1]);
#endif

	// no window yet? Create one now!
	m_nWindowRefCount = 1;

	int x = SDL_WINDOWPOS_CENTERED;
	int y = SDL_WINDOWPOS_CENTERED;
	int flags = SDL_WINDOW_HIDDEN;
#if defined( DX_TO_GL_ABSTRACTION )
	flags |= SDL_WINDOW_OPENGL;
#endif
	m_Window = SDL_CreateWindow( pTitle, x, y, width, height, flags );

	if (m_Window == NULL)
		Error( "Failed to create SDL window: %s", SDL_GetError() );
	SetAssertDialogParent( m_Window );

#ifdef OSX

	GLMRendererInfoFields rendererInfo;
	GetDisplayDB()->GetRendererInfo( 0, &rendererInfo );
	//-----------------------------------------------------------------------------------------
	//- enforce minimum system requirements for multiplayer branch (CSS / DOD / TF2) : no GMA950, X3100, or NV G7x.
	if (!CommandLine()->FindParm("-glmnosystemcheck"))	// escape hatch
	{
		if ( rendererInfo.m_osComboVersion < 0x0A0607 )
		{
			Error( "This game requires OS X version 10.6.7 or higher" );
			exit(1);
		}
		// forbidden chipsets
		if ( rendererInfo.m_atiR5xx || rendererInfo.m_intel95x || rendererInfo.m_intel3100 || rendererInfo.m_nvG7x )
		{
			Error( "This game does not support this type of graphics processor" );
			exit(1);
		}
	}
#endif

#if defined( DX_TO_GL_ABSTRACTION )
	m_GLContext = SDL_GL_CreateContext(m_Window);
	if (m_GLContext == NULL)
		Error( "Failed to create GL context: %s", SDL_GetError() );

	SDL_GL_MakeCurrent(m_Window, m_GLContext);

#if defined ANDROID && !defined TOGLES
	if( l_gl4es )
	{
		_glGetProcAddress = (t_glGetProcAddress)dlsym(l_gl4es, "gl4es_GetProcAddress" );
		void (*initialize_gl4es)( );
		initialize_gl4es = (void(*)())dlsym(l_gl4es, "initialize_gl4es" );
		initialize_gl4es();
	}
#endif

	// !!! FIXME: note for later...we never delete this context anywhere, I think.
	// !!! FIXME:  when we do get around to that, don't forget to delete/NULL gGL!

	static CDynamicFunctionOpenGL< true, const GLubyte *( APIENTRY *)(GLenum name), const GLubyte * > glGetString("glGetString");
	static CDynamicFunctionOpenGL< true, GLvoid ( APIENTRY *)(GLenum pname, GLint *params), GLvoid > glGetIntegerv("glGetIntegerv");

#ifdef DBGFLAG_ASSERT
	const char *pszString = ( const char * )glGetString(GL_VENDOR);
	pszString = ( const char * )glGetString(GL_RENDERER);
	pszString = ( const char * )glGetString(GL_VERSION);
	pszString = ( const char * )glGetString(GL_EXTENSIONS);

	// If we specified -gl_debug, make sure the extension string is present now.
	if ( CommandLine()->FindParm( "-gl_debug" ) )
	{
#ifndef TOGLES
		Assert( V_strstr(pszString, "GL_ARB_debug_output") );
#endif
	}
#endif // DBGFLAG_ASSERT

	gGL = GetOpenGLEntryPoints(VoidFnPtrLookup_GlMgr);

	// It is now safe to call any base GL entry point that's supplied by gGL.
	// You still need to explicitly test for extension entry points, though!

	if ( CommandLine()->FindParm( "-gl_dump_strings" ) )
	{
		DebugPrintf("GL_RENDERER: %s\n", (const char *) gGL->glGetString(GL_RENDERER));
		DebugPrintf("GL_VENDOR: %s\n", (const char *) gGL->glGetString(GL_VENDOR));
		DebugPrintf("GL_VERSION: %s\n", (const char *) gGL->glGetString(GL_VERSION));
		const char *exts = (const char *) gGL->glGetString(GL_EXTENSIONS);
		DebugPrintf("GL_EXTENSIONS:%s\n", exts ? "" : NULL);
		if (exts)
		{
			for (const char *ptr = exts; *ptr; ptr++)
				DebugPrintf("%c", *ptr == ' ' ? '\n' : *ptr);
			DebugPrintf("\n");
		}
		DebugPrintf("\n");
	}

#ifdef TOGLES
	gGL->glGenFramebuffers(1, &m_readFBO);
#else
	gGL->glGenFramebuffersEXT(1, &m_readFBO);
#endif

	gGL->glViewport(0, 0, width, height);    /* Reset The Current Viewport And Perspective Transformation */
	gGL->glScissor(0, 0, width, height);    /* Reset The Current Viewport And Perspective Transformation */

	// Blank out the initial window, so we're not looking at uninitialized
	//  video RAM trash until we start proper drawing.
	gGL->glClearColor(0,0,0,0);
	gGL->glClear(GL_COLOR_BUFFER_BIT);
	SDL_GL_SwapWindow(m_Window);
	gGL->glClear(GL_COLOR_BUFFER_BIT);
	SDL_GL_SwapWindow(m_Window);
	gGL->glClear(GL_COLOR_BUFFER_BIT);
	SDL_GL_SwapWindow(m_Window);
#endif // DX_TO_GL_ABSTRACTION

	m_WindowWidth = width;
	m_WindowHeight = height;

	// Update mouse warp targets (dependent on window size).
	m_nMouseTargetX = m_WindowWidth / 2;
	m_nMouseTargetY = m_WindowHeight / 2;
	m_nWarpDelta = Max( m_WindowHeight / 3, 200 );

	return true;
}

#if defined( DX_TO_GL_ABSTRACTION )

PseudoGLContextPtr	CSDLMgr::GetMainContext()
{
	SDLAPP_FUNC;

	return (PseudoGLContextPtr)m_GLContext;
}

PseudoGLContextPtr CSDLMgr::CreateExtraContext()
{
	SDLAPP_FUNC;

	const int *attrib = m_pixelFormatAttribs;
	for (int i = 0; i < m_pixelFormatAttribCount; i++, attrib += 2)
		SDL_GL_SetAttribute((SDL_GLattr) attrib[0], attrib[1]);

	return (PseudoGLContextPtr) SDL_GL_CreateContext(m_Window);
}

void CSDLMgr::DeleteContext( PseudoGLContextPtr hContext )
{
	SDLAPP_FUNC;
	Assert( (SDL_GLContext)hContext != m_GLContext );
	
	// Don't delete the main one.
	if ( (SDL_GLContext)hContext != m_GLContext )
	{
		if ( m_Window )
		{
			SDL_GL_MakeCurrent(m_Window, hContext);
		}
		SDL_GL_DeleteContext((SDL_GLContext) hContext);
	}
}

bool CSDLMgr::MakeContextCurrent( PseudoGLContextPtr hContext )
{
	SDLAPP_FUNC;

	// We only ever have one GL context on Linux at the moment, so don't spam these calls.
	return SDL_GL_MakeCurrent(m_Window, (SDL_GLContext)hContext ) == 0;
}

#endif // DX_TO_GL_ABSTRACTION


int CSDLMgr::GetEvents( CCocoaEvent *pEvents, int nMaxEventsToReturn, bool debugEvent )
{
	SDLAPP_FUNC;

	m_CocoaEventsMutex.Lock();

	CUtlLinkedList<CCocoaEvent,int> &queue = debugEvent ? m_CocoaEvents : m_DebugEvents;

	int nAvailable = queue.Count();
	int nToWrite = MIN( nAvailable, nMaxEventsToReturn );

	CCocoaEvent *pCurEvent = pEvents;
	for ( int i=0; i < nToWrite; i++ )
	{
		int iHead = queue.Head();
		memcpy( pCurEvent, &queue[iHead], sizeof( CCocoaEvent ) );
		queue.Remove( iHead );
		++pCurEvent;
	}

	m_CocoaEventsMutex.Unlock();

	return nToWrite;
}

#if defined(LINUX) || defined(PLATFORM_BSD)

int CSDLMgr::PeekAndRemoveKeyboardEvents( bool *pbEsc, bool *pbReturn, bool *pbSpace, bool debugEvent )
{
	SDLAPP_FUNC;

	m_CocoaEventsMutex.Lock();

	int nRead = 0;
	CUtlLinkedList<CCocoaEvent,int> &queue = debugEvent ? m_CocoaEvents : m_DebugEvents;
	int nEvents = queue.Count();

	for ( int iEvent=0; iEvent < nEvents; iEvent++ )
	{
		CCocoaEvent *pEvent = &queue[ iEvent ];

		switch( pEvent->m_EventType )
		{
			case CocoaEvent_KeyDown:
			{
				switch ( pEvent->m_VirtualKeyCode )
				{
				case SDL_SCANCODE_ESCAPE:
					nRead++;
					*pbEsc = true;
					pEvent->m_EventType = CocoaEvent_Deleted;
					break;
				case SDL_SCANCODE_RETURN:
				case SDL_SCANCODE_KP_ENTER:
					nRead++;
					*pbReturn = true;
					pEvent->m_EventType = CocoaEvent_Deleted;
					break;
				case SDL_SCANCODE_SPACE:
					nRead++;
					*pbSpace = true;
					pEvent->m_EventType = CocoaEvent_Deleted;
					break;
				}
			}
		}
	}

	m_CocoaEventsMutex.Unlock();
	return nRead;
}

#endif // LINUX

bool CSDLMgr::IsDebugEvent( CCocoaEvent& event )
{
	SDLAPP_FUNC;

	bool result = false;

	#if GLMDEBUG == 2
		// simple rule for now, if the option key is involved, it's a debug key
		// but only if GLM debugging is level 2 (specifically enabled) so we're
		// not stealing control for normal debug builds
		result |= ( (event.m_EventType == CocoaEvent_KeyDown) && ((event.m_ModifierKeyMask & (1<<eControlKey))!=0) );
	#endif

	return result;
}

	// Set the mouse cursor position.
void CSDLMgr::SetCursorPosition( int x, int y )
{
	SDLAPP_FUNC;

	SDL_WarpMouseInWindow(m_Window, x, y);
}

void CSDLMgr::PostEvent( const CCocoaEvent &theEvent, bool debugEvent )
{
	SDLAPP_FUNC;

	m_CocoaEventsMutex.Lock();

	CUtlLinkedList<CCocoaEvent,int> &queue = debugEvent ? m_CocoaEvents : m_DebugEvents;
	queue.AddToTail( theEvent );

	m_CocoaEventsMutex.Unlock();
}

void CSDLMgr::SetMouseVisible( bool bState )
{
	SDLAPP_FUNC;

	// If this is the first time we've been called in this frame or we're setting it to visible, then store it.
	// This is to handle the case where the game toggles the mouse state between visible and !visible 1 billion times
	//	in a frame.
	if ( !m_bSetMouseVisibleCalled || bState )
	{
		m_bCursorVisible = bState;
		m_bSetMouseVisibleCalled = true;
	}
}

void CSDLMgr::SetMouseCursor( SDL_Cursor *hCursor )
{
	SDLAPP_FUNC;

	if ( m_hCursor != hCursor )
	{
		if ( !hCursor )
		{
			// SDL_SetCursor( NULL ) just forces a cursor redraw, so don't ever bother doing that.
			SetMouseVisible( false );
		}
		else
		{
			m_hCursor = hCursor;
		}
		m_bSetMouseCursorCalled = true;
	}
}

void CSDLMgr::OnFrameRendered()
{
	SDLAPP_FUNC;

	if ( m_bCursorVisible && m_bSetMouseCursorCalled )
	{
		SDL_SetCursor( m_hCursor );

		m_bSetMouseCursorCalled = false;
	}

	if ( m_bSetMouseVisibleCalled )
	{


		ConVarRef rawinput( "m_rawinput" );

#if defined( OSX ) || defined( ANDROID )
		// We default raw input to on on Mac/Android and set it one time for all users since
		// it didn't used to be the default.
		if ( !rawinput_set_one_time.GetBool() )
		{
			rawinput_set_one_time.SetValue( 1 );
			rawinput.SetValue( 1 );
		}
#endif
		m_bRawInput = !m_bCursorVisible && rawinput.IsValid() && rawinput.GetBool();

		SDL_bool bWindowGrab = !m_bCursorVisible ? SDL_TRUE : SDL_FALSE;
		SDL_bool bRelativeMouseMode = bWindowGrab;

		if ( !m_bRawInput )
		{
			if ( m_bForbidMouseGrab )
				bWindowGrab = SDL_FALSE;

			bRelativeMouseMode = SDL_FALSE;
		}

		SDL_SetWindowGrab( m_Window, bWindowGrab );
		SDL_SetRelativeMouseMode( bRelativeMouseMode );

		SDL_ShowCursor( m_bCursorVisible ? 1 : 0 );

		// force non-fullscreen windows to the foreground if grabbed, so you can't get your mouse locked to something in the background.
		if ( bWindowGrab && !m_bFullScreen )
		{
			SDL_RaiseWindow( m_Window );
		}

		m_bSetMouseVisibleCalled = false;
	}
}

#if defined( DX_TO_GL_ABSTRACTION )
void CSDLMgr::ShowPixels( CShowPixelsParams *params )
{
	SDLAPP_FUNC;
	
	tmZone( TELEMETRY_LEVEL0, TMZF_NONE, __FUNCTION__ );

	if (params->m_onlySyncView)
		return;

	int swapInterval	= 0;
	int swapLimit		= 0;

	if (gl_swapdebug.GetInt())
	{
		// just jam through these debug convars every frame
		// but they will be shock absorbed below
			
		swapInterval	= gl_swapinterval.GetInt();
		swapLimit		= gl_swaplimit.GetInt();
	}
	else
	{
		// jam through (sync&limit) = 1 or 0..
		swapInterval	= params->m_vsyncEnable ? 1 : 0;
		swapLimit		= 1; // params->m_vsyncEnable ? 1 : 0;	// no good reason to turn off swap limit in normal user mode

#ifdef OSX
		// only do the funky forced vsync for NV on 10.6.4 and only if the bypass is not turned on
		if (m_force_vsync && (gl_disable_forced_vsync.GetInt()==0))
		{
			swapInterval	= 1;
			swapLimit		= 1;
		}
#else
		if (gl_swaptear.GetInt() && gGL->HasSwapTearExtension())
		{
			// For 0, do nothing. For 1, make it -1.
			swapInterval = -swapInterval;
		}
#endif
	}
		
	// only touch them on changes, or right after a change in windowed/FS state
	if ( (swapInterval!=m_lastKnownSwapInterval) || (swapLimit!=m_lastKnownSwapLimit) )
	{
		
		if (swapInterval!=m_lastKnownSwapInterval)
		{
			// This code hits when we turn on vsync, if we're going to swap tear.
			// We want to do one frame of real vsync to get the engine to sync at the top 
			// of the frame refresh.
			if (swapInterval < 0 && (m_lastKnownSwapInterval == 0 || m_lastKnownSwapInterval == kBogusSwapInterval))  {
				swapInterval = -swapInterval;
			}
			SDL_GL_SetSwapInterval(swapInterval);
		}

		m_lastKnownSwapInterval = swapInterval;
		m_lastKnownSwapLimit = swapLimit;

		printf("\n ##### swap interval = %d     swap limit = %d #####\n", m_lastKnownSwapInterval, m_lastKnownSwapLimit );
		fflush(stdout);

	}

#ifdef OSX
	if (!params->m_noBlit)
	{
		if ( params->m_useBlit ) // FBO blit path - which is what we *should* be using.  But if the params say no, then don't do it because the ext is not there.
		{
			// bind a quickie FBO to enclose the source texture
			GLint	myreadfb = 1000;

#ifdef TOGLES
			glBindFramebuffer( GL_READ_FRAMEBUFFER, myreadfb);
			CheckGLError( __LINE__ );

			glBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0);		// to the default FB/backbuffer
			CheckGLError( __LINE__ );

			// attach source tex to source FB
			glFramebufferTexture2D( GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, params->m_srcTexName, 0);
			CheckGLError( __LINE__ );
#else
			glBindFramebufferEXT( GL_READ_FRAMEBUFFER_EXT, myreadfb);
			CheckGLError( __LINE__ );

			glBindFramebufferEXT( GL_DRAW_FRAMEBUFFER_EXT, 0);		// to the default FB/backbuffer
			CheckGLError( __LINE__ );

			// attach source tex to source FB
			glFramebufferTexture2DEXT( GL_READ_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, params->m_srcTexName, 0);
			CheckGLError( __LINE__ );
#endif

			// blit

			int srcxmin = 0;
			int srcymin = 0;
			int srcxmax = params->m_width;
			int srcymax = params->m_height;

			// normal blit
			int dstxmin = 0;
			int dstymin = 0;
			int dstxmax = 0;
			int dstymax = 0;

			SDL_GetWindowSize(m_Window, &dstxmax, &dstymax);

			if (gl_blit_halfx.GetInt())
			{
				// blit right half
				srcxmin += srcxmax/2;
				dstxmin += dstxmax/2;
			}

			if (gl_blit_halfy.GetInt())
			{
				// blit top half
				// er, but top on screen is bottom of GL y coord range
				srcymax /= 2;
				dstymin += dstymax/2;
			}

			// go NEAREST if sizes match
			GLenum filter = ( ((srcxmax-srcxmin)==(dstxmax-dstxmin)) && ((srcymax-srcymin)==(dstymax-dstymin)) ) ? GL_NEAREST : GL_LINEAR;

#ifdef TOGLES
			glBlitFramebuffer(
					/* src min and maxes xy xy */ srcxmin, srcymin,				srcxmax,srcymax,
					/* dst min and maxes xy xy */ dstxmin, dstymax,				dstxmax,dstymin,		// note yflip here
					GL_COLOR_BUFFER_BIT, filter );
			CheckGLError( __LINE__ );

			// detach source tex
			glFramebufferTexture2D( GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, 0, 0);
			CheckGLError( __LINE__ );

			glBindFramebuffer( GL_READ_FRAMEBUFFER, 0);
			CheckGLError( __LINE__ );

			glBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0);		// to the default FB/backbuffer
			CheckGLError( __LINE__ );
#else
			glBlitFramebufferEXT(
					/* src min and maxes xy xy */ srcxmin, srcymin,				srcxmax,srcymax,
					/* dst min and maxes xy xy */ dstxmin, dstymax,				dstxmax,dstymin,		// note yflip here
					GL_COLOR_BUFFER_BIT, filter );
			CheckGLError( __LINE__ );

			// detach source tex
			glFramebufferTexture2DEXT( GL_READ_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, 0, 0);
			CheckGLError( __LINE__ );

			glBindFramebufferEXT( GL_READ_FRAMEBUFFER_EXT, 0);
			CheckGLError( __LINE__ );

			glBindFramebufferEXT( GL_DRAW_FRAMEBUFFER_EXT, 0);		// to the default FB/backbuffer
			CheckGLError( __LINE__ );
#endif

		}
		else
		{
			// old blit - gets very dark output with sRGB sources... not good
			bool texing = true;

			glUseProgram(NULL);

			glDisable( GL_DEPTH_TEST );
			glDepthMask( GL_FALSE );

			glActiveTexture( GL_TEXTURE0 );

			if (texing)
			{
				Assert( glIsTexture (params->m_srcTexName) );

				glEnable(GL_TEXTURE_2D);
				glBindTexture( GL_TEXTURE_2D, params->m_srcTexName );
				CheckGLError( __LINE__ );

				GLint width;
				glGetTexLevelParameteriv(	GL_TEXTURE_2D,			//target
						0,						//level,
						GL_TEXTURE_WIDTH,		//pname
						&width
						);
				CheckGLError( __LINE__ );
			}
			else
			{
				glBindTexture( GL_TEXTURE_2D, 0 );
				CheckGLError( __LINE__ );

				glDisable( GL_TEXTURE_2D );
				glColor4f( 1.0, 0.0, 0.0, 1.0 );
			}


			// immediate mode is fine for a simple textured quad
			// later if we switch the Valve side to render into an RBO, then this would turn into an FBO blit
			// note, do not check glGetError in between glBegin/glEnd, lol

			// flipped
			float topv = 0.0;
			float botv = 1.0;

			glBegin(GL_QUADS);

			if (texing)
				glTexCoord2f( 0.0, botv );
			glVertex3f		( -1.0, -1.0, 0.0 );

			if (texing)
				glTexCoord2f( 1.0, botv );
			glVertex3f		( 1.0, -1.0, 0.0 );

			if (texing)
				glTexCoord2f( 1.0, topv );
			glVertex3f		( 1.0, 1.0, 0.0 );

			if (texing)
				glTexCoord2f( 0.0, topv );
			glVertex3f		( -1.0, 1.0, 0.0 );
			glEnd();
			CheckGLError( __LINE__ );

			if (texing)
			{
				glBindTexture( GL_TEXTURE_2D, 0 );
				CheckGLError( __LINE__ );

				glDisable(GL_TEXTURE_2D);
			}

		}
	}
#endif

	if ( gl_finish.GetInt() )
	{
		gGL->glFinish();
	}
	CheckGLError( __LINE__ );

	CFastTimer tm;
	tm.Start();

	SDL_GL_SwapWindow( m_Window );

	m_flPrevGLSwapWindowTime = tm.GetDurationInProgress().GetMillisecondsF();

#ifdef ANDROID
	// ADRENO GPU MOMENT, SKIP 5 FRAMES
	if( m_bResetVsync )
	{
		if( m_nFramesToSkip <= 0 )
		{
			SDL_GL_SetSwapInterval(swapInterval);
			m_bResetVsync = false;
		}
		else
			m_nFramesToSkip--;
	}
#endif

	CheckGLError( __LINE__ );
}
#endif // DX_TO_GL_ABSTRACTION


void CSDLMgr::SetWindowFullScreen( bool bFullScreen, int nWidth, int nHeight )
{
	SDLAPP_FUNC;

	SDL_DisplayMode mode;
	int displayIndex = sdl_displayindex.GetInt();

	if ( bFullScreen )
	{
		if ( SDL_GetDesktopDisplayMode( displayIndex, &mode ) != 0 )
		{
			Assert( 0 );
			SDL_GetDesktopDisplayMode( 0, &mode );
		}

		mode.format = (Uint32)SDL_PIXELFORMAT_RGBX8888;

		m_flMouseXScale = ( float )nWidth / ( float )mode.w;
		m_flMouseYScale = ( float )nHeight / ( float )mode.h;
	}
	else
	{
		mode.format = ( Uint32 )SDL_PIXELFORMAT_RGBX8888;
		mode.refresh_rate = 0;
		mode.w = nWidth;
		mode.h = nHeight;
		mode.driverdata = 0;
		m_flMouseXScale = 1.0f;
		m_flMouseYScale = 1.0f;
	}

	SDL_SetWindowDisplayMode( m_Window, &mode );

	if ( ( m_bFullScreen != bFullScreen ) ||
		 ( bFullScreen && ( sdl_displayindex_fullscreen.GetInt() != displayIndex ) ) )
	{
		if ( bFullScreen )
		{
			int x = 0;
			int y = 0;

			// If we have more than one display, center the window in the one we've been assigned to.
			if ( SDL_GetNumVideoDisplays() > 1 )
			{
				SDL_Rect rect = { 0, 0, 0, 0 };

				SDL_GetDisplayBounds( displayIndex, &rect );

				x = rect.x;
				y = rect.y;
			}

			if ( m_bFullScreen == bFullScreen )
			{
				// TODO: Temporary workaround. SDL doesn't support going fullscreen on one monitor to fullscreen
				// on another. So we switch to windowed here, move our window, then go back fullscreen.
				SDL_SetWindowFullscreen( m_Window, SDL_FALSE );
				ThreadSleep( 15 );
			}

			// Move the window to the upper left of whatever display we're on, then size to fullscreen.
			SDL_SetWindowPosition( m_Window, x, y );
			SizeWindow( nWidth, nHeight );

			sdl_displayindex_fullscreen.SetValue( displayIndex );
		}
		else
		{
			sdl_displayindex_fullscreen.SetValue( -1 );
		}

		SDL_SetWindowFullscreen( m_Window, bFullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0 );

		m_bFullScreen = bFullScreen;
	}
}


void CSDLMgr::MoveWindow( int x, int y )
{
	SDLAPP_FUNC;

	SDL_SetWindowPosition(m_Window, x, y);
}

void CSDLMgr::SizeWindow( int width, int tall )
{
	SDLAPP_FUNC;

	if ( ( m_WindowWidth == width ) &&
		 ( m_WindowHeight == tall ) &&
		 ( m_SizeWindowFullScreenState == m_bFullScreen ) &&
		 m_WindowShownAndRaised )
	{
		return;
	}

	// Make sure we don't skip doing a SizeWindow when fullscreen state changes.
	m_SizeWindowFullScreenState = m_bFullScreen;

	m_WindowWidth = width;
	m_WindowHeight = tall;

	// Update mouse warp targets (dependent on window size).
	m_nMouseTargetX = m_WindowWidth / 2;
	m_nMouseTargetY = m_WindowHeight / 2;
	m_nWarpDelta = Max( m_WindowHeight / 3, 200 );

	SDL_SetWindowSize( m_Window, width, tall );

#if defined( DX_TO_GL_ABSTRACTION )
	gGL->glViewport(0, 0, (GLsizei) width, (GLsizei) tall);
	gGL->glScissor( 0,0, (GLsizei) width, (GLsizei) tall );
#endif

	// If the Window hasn't been shown yet, show it now.
	if ( !m_WindowShownAndRaised )
	{
		SDL_ShowWindow( m_Window );
		SDL_RaiseWindow( m_Window );

		m_WindowShownAndRaised = true;
	}
	else
	{
		SDL_RaiseWindow( m_Window );
	}
}


// key input handler
void CSDLMgr::handleKeyInput( const SDL_Event &event )
{
	SDLAPP_FUNC;

	Assert( ( event.type == SDL_KEYDOWN ) || ( event.type == SDL_KEYUP ) );

#ifdef OSX
	if ( event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_TAB &&
	     SDL_GetModState()&KMOD_GUI && CommandLine()->FindParm( "-exclusivefs" ) )
	{
		// If we're in exclusive fullscreen mode, and they command-tab, handle
		// that by forcing minimization of the window.
		SDL_MinimizeWindow( m_Window );
	}
#endif

	const bool bPressed = ( event.type == SDL_KEYDOWN );

	// !!! FIXME: we should be getting text input from a different event...
	CCocoaEvent theEvent;
	theEvent.m_EventType = ( bPressed ) ? CocoaEvent_KeyDown : CocoaEvent_KeyUp;
	theEvent.m_VirtualKeyCode = event.key.keysym.scancode;
	theEvent.m_UnicodeKey = 0;
	theEvent.m_UnicodeKeyUnmodified = 0;

	// Testing for non-qwerty keyboards: work out the key name and use this to
	// calculate the scancode.
	if ( CommandLine()->FindParm( "-nonqwerty" ) )
	{
		const char* keyname = SDL_GetKeyName( event.key.keysym.sym );
		if ( keyname != NULL && strlen( keyname ) == 1) {
			const char c = *keyname;
			if ( c >= 'A' && c <= 'Z' )
			{
				theEvent.m_VirtualKeyCode = SDL_SCANCODE_A + ( c - 'A' );
			}
			else
			{
				switch( c )
				{
					case '=': theEvent.m_VirtualKeyCode = SDL_SCANCODE_EQUALS; break;
					case '-': theEvent.m_VirtualKeyCode = SDL_SCANCODE_MINUS; break;
					case '[': theEvent.m_VirtualKeyCode = SDL_SCANCODE_LEFTBRACKET; break;
					case ']': theEvent.m_VirtualKeyCode = SDL_SCANCODE_RIGHTBRACKET; break;
					case ';': theEvent.m_VirtualKeyCode = SDL_SCANCODE_SEMICOLON; break;
					case '\'': theEvent.m_VirtualKeyCode = SDL_SCANCODE_APOSTROPHE; break;
					case ',': theEvent.m_VirtualKeyCode = SDL_SCANCODE_COMMA; break;
					case '.': theEvent.m_VirtualKeyCode = SDL_SCANCODE_PERIOD; break;
					case '/': theEvent.m_VirtualKeyCode = SDL_SCANCODE_SLASH; break;
				}
			}
		}
	}

	// key modifiers aren't necessarily reliable in all the cases we'd want, so track it ourselves.
	const uint32_t ModCAPSLOCK = (1 << 0);
	const uint32_t ModSHIFTR   = (1 << 1);
	const uint32_t ModSHIFTL   = (1 << 2);
	const uint32_t ModCTRLR    = (1 << 3);
	const uint32_t ModCTRLL    = (1 << 4);
	const uint32_t ModALTR     = (1 << 5);
	const uint32_t ModALTL     = (1 << 6);
	const uint32_t ModGUIR     = (1 << 7);
	const uint32_t ModGUIL     = (1 << 8);

	#define KEYSYMCASE(mod,side,op,key) \
		case SDLK_##side##mod: \
			m_keyModifiers op Mod##mod##side; \
			theEvent.m_VirtualKeyCode = -key; \
			break

	//bool bDropKey = false;
	if (bPressed)
	{
		switch (event.key.keysym.sym)
		{
			KEYSYMCASE(CAPSLOCK,,|=,KEY_CAPSLOCK);
			KEYSYMCASE(SHIFT,R,|=,KEY_RSHIFT);
			KEYSYMCASE(SHIFT,L,|=,KEY_LSHIFT);
			KEYSYMCASE(CTRL,R,|=,KEY_RCONTROL);
			KEYSYMCASE(CTRL,L,|=,KEY_LCONTROL);
			KEYSYMCASE(GUI,R,|=,KEY_RWIN);
			KEYSYMCASE(GUI,L,|=,KEY_LWIN);
			KEYSYMCASE(ALT,R,|=,KEY_RALT);
			KEYSYMCASE(ALT,L,|=,KEY_LALT);
			default: break;  // don't care.
		}
	}
	else
	{
		switch (event.key.keysym.sym)
		{
			KEYSYMCASE(CAPSLOCK,,&= ~,KEY_CAPSLOCK);
			KEYSYMCASE(SHIFT,R,&= ~,KEY_RSHIFT);
			KEYSYMCASE(SHIFT,L,&= ~,KEY_LSHIFT);
			KEYSYMCASE(CTRL,R,&= ~,KEY_RCONTROL);
			KEYSYMCASE(CTRL,L,&= ~,KEY_LCONTROL);
			KEYSYMCASE(GUI,R,&= ~,KEY_RWIN);
			KEYSYMCASE(GUI,L,&= ~,KEY_LWIN);
			KEYSYMCASE(ALT,R,&= ~,KEY_RALT);
			KEYSYMCASE(ALT,L,&= ~,KEY_LALT);
			default: break;  // don't care.
		}
	}

	#undef KEYSYMCASE

	m_keyModifierMask = 0;
	if (m_keyModifiers & ModCAPSLOCK)
		m_keyModifierMask |= (1<<eCapsLockKey);
	if (m_keyModifiers & (ModSHIFTR | ModSHIFTL))
		m_keyModifierMask |= (1<<eShiftKey);
	if (m_keyModifiers & (ModCTRLR | ModCTRLL))
		m_keyModifierMask |= (1<<eControlKey);
	if (m_keyModifiers & (ModALTR | ModALTL))
		m_keyModifierMask |= (1<<eAltKey);
	if (m_keyModifiers & (ModGUIR | ModGUIL))
		m_keyModifierMask |= (1<<eCommandKey);

	theEvent.m_ModifierKeyMask = m_keyModifierMask;

	// make a decision about this event - does it go in the normal evt queue or into the debug queue.
	bool debug = IsDebugEvent( theEvent );

#if GLMDEBUG
	bool bIsShifted = ( ((theEvent.m_ModifierKeyMask & (1<<eCapsLockKey))!=0) || ((theEvent.m_ModifierKeyMask & (1<<eShiftKey))!=0) );
	theEvent.m_UnicodeKeyUnmodified = event.key.keysym.sym;
	if ( bIsShifted )
	{
		switch ( event.key.keysym.sym )
		{
			case '[':
				theEvent.m_UnicodeKeyUnmodified = '{';
				break;
			case ']':
				theEvent.m_UnicodeKeyUnmodified = '}';
				break;
			case 'h':
				theEvent.m_UnicodeKeyUnmodified = 'H';
				break;
			case ',':
				theEvent.m_UnicodeKeyUnmodified = '<';
				break;
			case '.':
				theEvent.m_UnicodeKeyUnmodified = '>';
				break;
		}		
	}
#endif

	PostEvent( theEvent, debug );
}

void CSDLMgr::PumpWindowsMessageLoop()
{
	SDLAPP_FUNC;

	SDL_Event event;
	int nEventsProcessed = 0;
	while ( SDL_PollEvent(&event) && nEventsProcessed < 100 )
	{
		nEventsProcessed++;

		switch ( event.type )
		{
			case SDL_MOUSEMOTION:
			{
				if ( !m_bHasFocus )
					break;

				// We still handle WM_MOUSEMOVE in CInputSystem for regular mouse events, only raw goes through SDL.
				// This is done in order to maintain legacy mouse behaviour for Windows users.
				if ( IsWindows() && !m_bRawInput )
					break;

				// When SDL_WarpMouseInWindow is called, an SDL_MOUSEMOTION
				// event is sent. We want to ignore such 'synthetic'
				// mouse motion events.
				if ( m_bExpectSyntheticMouseMotion &&
					 event.motion.x == m_nMouseTargetX &&
					 event.motion.y == m_nMouseTargetY )
				{
					m_bExpectSyntheticMouseMotion = false;
					break;
				}

				m_nMouseXDelta += event.motion.xrel;
				m_nMouseYDelta += event.motion.yrel;

				if ( !m_bRawInput && !m_bCursorVisible &&
					(event.motion.x < m_nMouseTargetX - m_nWarpDelta ||
					 event.motion.x > m_nMouseTargetX + m_nWarpDelta ||
					 event.motion.y < m_nMouseTargetY - m_nWarpDelta ||
					 event.motion.y > m_nMouseTargetY + m_nWarpDelta) )
				{
					// We have strayed outside of our desired area, so
					// warp the cursor back to the middle of the window.
					SDL_WarpMouseInWindow( m_Window, m_nMouseTargetX, m_nMouseTargetY );
					m_bExpectSyntheticMouseMotion = true;
				}

				CCocoaEvent theEvent;
				theEvent.m_EventType = CocoaEvent_MouseMove;
				theEvent.m_MousePos[0] = event.motion.x * m_flMouseXScale;
				theEvent.m_MousePos[1] = event.motion.y * m_flMouseYScale;
				theEvent.m_MouseButtonFlags = m_mouseButtons;
				PostEvent( theEvent );
				break;
			}

			case SDL_MOUSEBUTTONUP:
			case SDL_MOUSEBUTTONDOWN:
			{
				// SDL buttons:
				//  1 = Left button
				//  2 = Middle button
				//  3 = Right button
				//  4 = Wheel Forward		; These events are handled by SDL_MOUSEWHEEL and don't come through here.
				//  5 = Wheel Back			;
				//  6 = Wheel Tilt Left		;
				//  7 = Wheel Tilt Right	;
				//  8 = Browser Back
				//  9 = Browser Forward
				//  10 = Task button (probably similar to Alt-Tab)

				// every other platform does left(1), right(2), middle(3)...
				int button;

				switch( event.button.button )
				{
				case 1:	button = 1; break;
				case 2: button = 3; break;
				case 3: button = 2; break;
				default:
					// For all buttons above 4, map them to 4 & 5 forever. This is because different mice
					//	will use different mappings. Ie, mousewheel mice can do this:
					//    4 = Wheel Forward		; These events are handled by SDL_MOUSEWHEEL and don't come through here.
					//    5 = Wheel Back		;
					//    6 = Wheel Tilt Left	;
					//    7 = Wheel Tilt Right	;
					//    8 = Browser Back
					//    9 = Browser Forward
					//    10 = Task button (probably similar to Alt-Tab)
					// Mice without wheels can do 4/5 as regular 4/5, etc.
					button = 4 + ( event.button.button & 0x1 );
					break;
				}

				const bool bPressed = (event.type == SDL_MOUSEBUTTONDOWN);
				const CocoaMouseButton_t cocoaButton = ( CocoaMouseButton_t )( 1 << (button - 1 ) );

				if (bPressed)
					m_mouseButtons |= cocoaButton;
				else
					m_mouseButtons &= ~cocoaButton;

				bool bDoublePress = false;

				if ( bPressed )
				{
					if ( m_bGotMouseButtonDown &&
						 ( (int)( event.button.timestamp - m_MouseButtonDownTimeStamp ) <= sdl_double_click_time.GetInt() ) &&
						 ( abs( event.button.x - m_MouseButtonDownX ) <= sdl_double_click_size.GetInt() ) &&
						 ( abs( event.button.y - m_MouseButtonDownY ) <= sdl_double_click_size.GetInt() ) )
					{
						bDoublePress = true;
						m_bGotMouseButtonDown = false;
					}
					else
					{
						m_MouseButtonDownTimeStamp = event.button.timestamp;
						m_MouseButtonDownX = event.button.x;
						m_MouseButtonDownY = event.button.y;
						m_bGotMouseButtonDown = true;
					}
				}

				CCocoaEvent theEvent;
				theEvent.m_EventType = (bPressed) ? CocoaEvent_MouseButtonDown : CocoaEvent_MouseButtonUp;
				theEvent.m_MousePos[0] = event.button.x * m_flMouseXScale;
				theEvent.m_MousePos[1] = event.button.y * m_flMouseYScale;
				theEvent.m_MouseButtonFlags = m_mouseButtons;
				theEvent.m_nMouseClickCount = bDoublePress ? 2 : 1;
				theEvent.m_MouseButton = cocoaButton;
				PostEvent( theEvent );

				break;
			}

			case SDL_MOUSEWHEEL:
			{
				if ( event.wheel.y )
				{
					CCocoaEvent theEvent;
					theEvent.m_EventType = CocoaEvent_MouseScroll;
					const int scroll = event.wheel.y;
					theEvent.m_MousePos[0] = scroll;
					theEvent.m_MousePos[1] = scroll;
					PostEvent( theEvent );
				}
				break;
			}

			case SDL_WINDOWEVENT:
				switch (event.window.event)
				{
					case SDL_WINDOWEVENT_EXPOSED:
					{
						/*if ( ev.xexpose.count > 0 )
							break; // multiple expose events queued
						EVENT_LOG( "Got event Expose\n" );
						int iPanel = m_mapWindowToVPanel.Find( ev.xexpose.window );
						if ( iPanel != m_mapWindowToVPanel.InvalidIndex() )
							drawVGUI( m_pXDisplay, ev.xexpose.window, m_mapWindowToVPanel[ iPanel ], m_GLContext );
						m_mapSentInvalidate.RemoveAll();*/
						break;
					}
					case SDL_WINDOWEVENT_FOCUS_GAINED:
					{
						m_bResetVsync = true; m_nFramesToSkip = 3;
						m_bHasFocus = true;
						SDL_ShowCursor( m_bCursorVisible ? 1 : 0 );
						CCocoaEvent theEvent;
						theEvent.m_EventType = CocoaEvent_AppActivate;
						theEvent.m_ModifierKeyMask = 1;
						PostEvent( theEvent );
						break;
					}
					case SDL_WINDOWEVENT_FOCUS_LOST:
					{
						m_bHasFocus = false;
						SDL_ShowCursor(1);
						CCocoaEvent theEvent;
						theEvent.m_EventType = CocoaEvent_AppActivate;
						theEvent.m_ModifierKeyMask = 0;
						PostEvent( theEvent );
						break;
					}
					case SDL_WINDOWEVENT_LEAVE:
					{
						if ( !IsWindows() && !m_bRawInput && !m_bCursorVisible && m_bHasFocus )
						{
							// If the cursor is not visible and the mouse
							// cursor somehow manages to escape the window
							// warp it back to the middle of the window.
							SDL_WarpMouseInWindow( m_Window, m_nMouseTargetX, m_nMouseTargetY );
							m_bExpectSyntheticMouseMotion = true;
						}
						break;
					}
				}
				break;

			case SDL_KEYUP:
			case SDL_KEYDOWN:
				handleKeyInput(event);
				break;

			case SDL_TEXTINPUT:
			{
				char *text = event.text.text;

				if ( text && text[ 0 ] )
				{
					wchar_t WBuf[ SDL_TEXTINPUTEVENT_TEXT_SIZE + 1 ];
					WBuf[ 0 ] = 0;
					V_UTF8ToUnicode( text, WBuf, sizeof( WBuf ) );

					for ( int i = 0; i < SDL_TEXTINPUTEVENT_TEXT_SIZE; i++ )
					{
						wchar_t ch = WBuf[ i ];
						if ( ch == '\0' )
							break;

						CCocoaEvent theEvent;
						theEvent.m_EventType = CocoaEvent_KeyDown;
						theEvent.m_VirtualKeyCode = 0;
						theEvent.m_UnicodeKey = ch;
						theEvent.m_UnicodeKeyUnmodified = ch;
						theEvent.m_ModifierKeyMask = m_keyModifierMask;
						PostEvent( theEvent, false );

						theEvent.m_EventType = CocoaEvent_KeyUp;
						theEvent.m_VirtualKeyCode = 0;
						theEvent.m_UnicodeKey = 0;
						theEvent.m_UnicodeKeyUnmodified = 0;
						theEvent.m_ModifierKeyMask = m_keyModifierMask;
						PostEvent( theEvent, false );
					}
				}
				break;
			}
			case SDL_QUIT:
			{
				CCocoaEvent theEvent;
				theEvent.m_EventType = CocoaEvent_AppQuit;
				PostEvent( theEvent );
				break;
			}
			default:
				break;
		}
	}
}

void CSDLMgr::IncWindowRefCount()
{
	if ( !m_Window )
		return;

	m_nWindowRefCount++;
}

void CSDLMgr::DecWindowRefCount()
{
	if ( !m_Window )
		return;

	Assert( m_nWindowRefCount >= 1 );
	if ( !m_nWindowRefCount )
		return;

	m_nWindowRefCount--;

	if ( !m_nWindowRefCount )
	{
#if defined( DX_TO_GL_ABSTRACTION )
		if ( m_Window )
		{
			SDL_GL_MakeCurrent( m_Window, m_GLContext );
		}

		if ( gGL && m_readFBO )
		{
#ifdef TOGLES
			gGL->glDeleteFramebuffers( 1, &m_readFBO );
#else
			gGL->glDeleteFramebuffersEXT( 1, &m_readFBO );
#endif
		}
		m_readFBO = 0;
								
		SDL_GL_DeleteContext( m_GLContext );
#if !defined( OSX ) && defined( DBGFLAG_ASSERT )
		// Clear the GL entrypoint pointers, ensuring we crash if someone tries to call GL after we delete the context.
		Msg( "%s: Calling ClearOpenGLEntryPoints. Should crash if someone calls GL after this.\n", __FUNCTION__ );
		ClearOpenGLEntryPoints();
#endif

		m_GLContext = NULL;
#endif // DX_TO_GL_ABSTRACTION

		SDL_SetWindowFullscreen(m_Window, SDL_FALSE);  // just in case.
		SDL_SetWindowGrab(m_Window, SDL_FALSE);  // just in case.
		SDL_DestroyWindow(m_Window);
		m_Window = NULL;
		SetAssertDialogParent( NULL );
	}
}

void CSDLMgr::DestroyGameWindow()
{
	SDLAPP_FUNC;

	if ( m_Window )
	{
		DecWindowRefCount();
	}
}

void CSDLMgr::SetApplicationIcon( const char *pchAppIconFile )
{
	SDLAPP_FUNC;

	SDL_Surface *icon = SDL_LoadBMP(pchAppIconFile);
	if (icon)
	{
		SDL_SetWindowIcon(m_Window, icon);
		SDL_FreeSurface(icon);
	}
}

void CSDLMgr::GetMouseDelta( int &x, int &y, bool bIgnoreNextMouseDelta )
{
	SDLAPP_FUNC;

	x = m_nMouseXDelta;
	y = m_nMouseYDelta;

	m_nMouseXDelta = m_nMouseYDelta = 0;
}

//  Returns the resolution of the nth display. 0 is the default display.
//
void CSDLMgr::GetNativeDisplayInfo( int nDisplay, uint &nWidth, uint &nHeight, uint &nRefreshHz )
{
	SDL_DisplayMode mode;

	if ( nDisplay == -1 )
	{
		if ( g_bSDLDisplayindexSet )
		{
			nDisplay = sdl_displayindex.GetInt();
		}
		else
		{
			// sdl_displayindex hasn't been parsed yet. This can happen in CMaterialSystem::ModInit()
			//	before the config files have been read, etc. So in this case, just grab the largest
			//	display we can find and return with that.
			int Width, Height;
			nDisplay = GetLargestDisplaySize( Width, Height );
		}
	}

	if ( SDL_GetDesktopDisplayMode( nDisplay, &mode ) != 0 )
	{
		Assert( 0 );
		SDL_GetDesktopDisplayMode( 0, &mode );
	}

	nRefreshHz = mode.refresh_rate;
	nWidth = mode.w;
	nHeight = mode.h;
}


void CSDLMgr::RenderedSize( uint &width, uint &height, bool set )
{
	SDLAPP_FUNC;

	if (set)
	{
		m_renderedWidth = width;
		m_rendererHeight = height;	// latched from NotifyRenderedSize
	}
	else
	{
		width = m_renderedWidth;
		height = m_rendererHeight;
	}
}

void CSDLMgr::DisplayedSize( uint &width, uint &height ) 
{
	SDLAPP_FUNC;

	int w, h;
	SDL_GetWindowSize(m_Window, &w, &h);
	width = (uint) w;
	height = (uint) h;
}

void CSDLMgr::GetStackCrawl( CStackCrawlParams *params )
{
	SDLAPP_FUNC;
}

void CSDLMgr::WaitUntilUserInput( int msSleepTime )
{
	SDLAPP_FUNC;

	SDL_WaitEventTimeout(NULL, msSleepTime);
}

//===============================================================================

void CSDLMgr::SetGammaRamp( const uint16 *pRed, const uint16 *pGreen, const uint16 *pBlue )
{
	if ( m_Window )
	{
		int nResult = SDL_SetWindowGammaRamp( m_Window, pRed, pGreen, pBlue );
		
		if ( nResult != 0 )
		{
			ConMsg( "SDL_SetWindowGammaRamp failed: %d\n", nResult );
		}
	}
}

//===============================================================================

#if defined( DX_TO_GL_ABSTRACTION )
void CSDLMgr::GetDesiredPixelFormatAttribsAndRendererInfo( uint **ptrOut, uint *countOut, GLMRendererInfoFields *rendInfoOut )
{
	SDLAPP_FUNC;

	Assert( m_pixelFormatAttribCount > 0 );

	if (ptrOut) *ptrOut = (uint *) m_pixelFormatAttribs;
	if (countOut) *countOut = m_pixelFormatAttribCount;
	if (rendInfoOut)
	{
		GLMDisplayDB *db = GetDisplayDB();
#ifdef OSX
		*rendInfoOut = db->m_renderers->Head()->m_info;
#else
		*rendInfoOut = db->m_renderer.m_info;
#endif
	}
}



GLMDisplayMode::GLMDisplayMode( uint width, uint height, uint refreshHz )
{
	SDLAPP_FUNC;

	Init( width, height, refreshHz );
}

GLMDisplayMode::~GLMDisplayMode()
{
	SDLAPP_FUNC;
	// empty
}

void GLMDisplayMode::Init( uint width, uint height, uint refreshHz )
{
	SDLAPP_FUNC;

	m_info.m_modePixelWidth = width;
	m_info.m_modePixelHeight = height;
	m_info.m_modeRefreshHz = refreshHz;
}

void GLMDisplayMode::Dump( int which )
{
	SDLAPP_FUNC;

	GLMPRINTF(("\n             # %-2d  width=%-4d  height=%-4d  refreshHz=%-2d",
			   which, m_info.m_modePixelWidth, m_info.m_modePixelHeight, m_info.m_modeRefreshHz ));
}

GLMDisplayDB *CSDLMgr::GetDisplayDB( void )
{
	SDLAPP_FUNC;

	if ( !m_displayDB )
	{
		m_displayDB = new GLMDisplayDB;		// creating the DB object does not do much other than init it to a good state.
		m_displayDB->Populate();			// populate the tree
#if defined( OSX )
		// side effect: we fill in m_force_vsync..
		{
			GLMRendererInfoFields	info;
			m_displayDB->GetRendererInfo( 0, &info );

			// m_leopard = (info.m_osComboVersion < 0x000A0600);

			m_force_vsync = info.m_badDriver1064NV;		// just force it if it's the bum NV driver
		}
#endif
	}
	return m_displayDB;
}

#ifndef OSX
#include "glmdisplaydb_linuxwin.inl"
#endif


#endif // DX_TO_GL_ABSTRACTION

#endif  // !DEDICATED




================================================
FILE: appframework/VguiMatSysApp.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
//=============================================================================
#ifdef _WIN32

#if defined( _WIN32 ) && !defined( _X360 )
#include <windows.h>
#endif
#include "appframework/vguimatsysapp.h"
#include "filesystem.h"
#include "materialsystem/imaterialsystem.h"
#include "vgui/ivgui.h"
#include "vgui/ISurface.h"
#include "vgui_controls/controls.h"
#include "vgui/ischeme.h"
#include "vgui/ilocalize.h"
#include "tier0/dbg.h"
#include "tier0/icommandline.h"
#include "materialsystem/materialsystem_config.h"
#include "filesystem_init.h"
#include "VGuiMatSurface/IMatSystemSurface.h"
#include "inputsystem/iinputsystem.h"
#include "tier3/tier3.h"


//-----------------------------------------------------------------------------
// Create all singleton systems
//-----------------------------------------------------------------------------
bool CVguiMatSysApp::Create()
{
	AppSystemInfo_t appSystems[] = 
	{
		{ "inputsystem.dll",		INPUTSYSTEM_INTERFACE_VERSION },
		{ "materialsystem.dll",		MATERIAL_SYSTEM_INTERFACE_VERSION },

		// NOTE: This has to occur before vgui2.dll so it replaces vgui2's surface implementation
		{ "vguimatsurface.dll",		VGUI_SURFACE_INTERFACE_VERSION },
		{ "vgui2.dll",				VGUI_IVGUI_INTERFACE_VERSION },

		// Required to terminate the list
		{ "", "" }
	};

	if ( !AddSystems( appSystems ) ) 
		return false;

	IMaterialSystem *pMaterialSystem = (IMaterialSystem*)FindSystem( MATERIAL_SYSTEM_INTERFACE_VERSION );

	if ( !pMaterialSystem )
	{
		Warning( "CVguiMatSysApp::Create: Unable to connect to necessary interface!\n" );
		return false;
	}

	pMaterialSystem->SetShaderAPI( "shaderapidx9.dll" );
	return true;
}

void CVguiMatSysApp::Destroy()
{
}



//-----------------------------------------------------------------------------
// Window management
//-----------------------------------------------------------------------------
void*CVguiMatSysApp::CreateAppWindow( char const *pTitle, bool bWindowed, int w, int h )
{
	WNDCLASSEX		wc;
	memset( &wc, 0, sizeof( wc ) );
	wc.cbSize		 = sizeof( wc );
    wc.style         = CS_OWNDC | CS_DBLCLKS;
    wc.lpfnWndProc   = DefWindowProc;
    wc.hInstance     = (HINSTANCE)GetAppInstance();
    wc.lpszClassName = "Valve001";
	wc.hIcon		 = NULL; //LoadIcon( s_HInstance, MAKEINTRESOURCE( IDI_LAUNCHER ) );
	wc.hIconSm		 = wc.hIcon;

    RegisterClassEx( &wc );

	// Note, it's hidden
	DWORD style = WS_POPUP | WS_CLIPSIBLINGS;
	
	if ( bWindowed )
	{
		// Give it a frame
		style |= WS_OVERLAPPEDWINDOW;
		style &= ~WS_THICKFRAME;
	}

	// Never a max box
	style &= ~WS_MAXIMIZEBOX;

	RECT windowRect;
	windowRect.top		= 0;
	windowRect.left		= 0;
	windowRect.right	= w;
	windowRect.bottom	= h;

	// Compute rect needed for that size client area based on window style
	AdjustWindowRectEx(&windowRect, style, FALSE, 0);

	// Create the window
	void *hWnd = CreateWindow( wc.lpszClassName, pTitle, style, 0, 0, 
		windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, 
		NULL, NULL, (HINSTANCE)GetAppInstance(), NULL );

	if (!hWnd)
		return NULL;

    int CenterX, CenterY;

	CenterX = (GetSystemMetrics(SM_CXSCREEN) - w) / 2;
	CenterY = (GetSystemMetrics(SM_CYSCREEN) - h) / 2;
	CenterX = (CenterX < 0) ? 0: CenterX;
	CenterY = (CenterY < 0) ? 0: CenterY;

	// In VCR modes, keep it in the upper left so mouse coordinates are always relative to the window.
	SetWindowPos( (HWND)hWnd, NULL, CenterX, CenterY, 0, 0,
				  SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW | SWP_DRAWFRAME);

	return hWnd;
}


//-----------------------------------------------------------------------------
// Pump messages
//-----------------------------------------------------------------------------
void CVguiMatSysApp::AppPumpMessages()
{
	g_pInputSystem->PollInputState();
}


//-----------------------------------------------------------------------------
// Sets up the game path
//-----------------------------------------------------------------------------
bool CVguiMatSysApp::SetupSearchPaths( const char *pStartingDir, bool bOnlyUseStartingDir, bool bIsTool )
{
	if ( !BaseClass::SetupSearchPaths( pStartingDir, bOnlyUseStartingDir, bIsTool ) )
		return false;

	g_pFullFileSystem->AddSearchPath( GetGameInfoPath(), "SKIN", PATH_ADD_TO_HEAD );
	return true;
}


//-----------------------------------------------------------------------------
// Init, shutdown
//-----------------------------------------------------------------------------
bool CVguiMatSysApp::PreInit( )
{
	if ( !BaseClass::PreInit() )
		return false;

	if ( !g_pFullFileSystem || !g_pMaterialSystem || !g_pInputSystem || !g_pMatSystemSurface )
	{
		Warning( "CVguiMatSysApp::PreInit: Unable to connect to necessary interface!\n" );
		return false;
	}

	// Add paths...
	if ( !SetupSearchPaths( NULL, false, true ) )
		return false;

	const char *pArg;
	int iWidth = 1024;
	int iHeight = 768;
	bool bWindowed = (CommandLine()->CheckParm( "-fullscreen" ) == NULL);
	if (CommandLine()->CheckParm( "-width", &pArg ))
	{
		iWidth = atoi( pArg );
	}
	if (CommandLine()->CheckParm( "-height", &pArg ))
	{
		iHeight = atoi( pArg );
	}

	m_nWidth = iWidth;
	m_nHeight = iHeight;
	m_HWnd = CreateAppWindow( GetAppName(), bWindowed, iWidth, iHeight );
	if ( !m_HWnd )
		return false;

	g_pInputSystem->AttachToWindow( m_HWnd );
	g_pMatSystemSurface->AttachToWindow( m_HWnd );

	// NOTE: If we specifically wanted to use a particular shader DLL, we set it here...
	//m_pMaterialSystem->SetShaderAPI( "shaderapidx8" );

	// Get the adapter from the command line....
	const char *pAdapterString;
	int adapter = 0;
	if (CommandLine()->CheckParm( "-adapter", &pAdapterString ))
	{
		adapter = atoi( pAdapterString );
	}

	int adapterFlags = 0;
	if ( CommandLine()->CheckParm( "-ref" ) )
	{
		adapterFlags |= MATERIAL_INIT_REFERENCE_RASTERIZER;
	}
	if ( AppUsesReadPixels() )
	{
		adapterFlags |= MATERIAL_INIT_ALLOCATE_FULLSCREEN_TEXTURE;
	}

	g_pMaterialSystem->SetAdapter( adapter, adapterFlags );

	return true; 
}

void CVguiMatSysApp::PostShutdown()
{
	if ( g_pMatSystemSurface && g_pInputSystem )
	{
		g_pMatSystemSurface->AttachToWindow( NULL );
		g_pInputSystem->DetachFromWindow( );
	}

	BaseClass::PostShutdown();
}


//-----------------------------------------------------------------------------
// Gets the window size
//-----------------------------------------------------------------------------
int CVguiMatSysApp::GetWindowWidth() const
{
	return m_nWidth;
}

int CVguiMatSysApp::GetWindowHeight() const
{
	return m_nHeight;
}


//-----------------------------------------------------------------------------
// Returns the window
//-----------------------------------------------------------------------------
void* CVguiMatSysApp::GetAppWindow()
{
	return m_HWnd;
}

	
//-----------------------------------------------------------------------------
// Sets the video mode
//-----------------------------------------------------------------------------
bool CVguiMatSysApp::SetVideoMode( )
{
	MaterialSystem_Config_t config;
	if ( CommandLine()->CheckParm( "-fullscreen" ) )
	{
		config.SetFlag( MATSYS_VIDCFG_FLAGS_WINDOWED, false );
	}
	else
	{
		config.SetFlag( MATSYS_VIDCFG_FLAGS_WINDOWED, true );
	}

	if ( CommandLine()->CheckParm( "-resizing" ) )
	{
		config.SetFlag( MATSYS_VIDCFG_FLAGS_RESIZING, true );
	}

	if ( CommandLine()->CheckParm( "-mat_vsync" ) )
	{
		config.SetFlag( MATSYS_VIDCFG_FLAGS_NO_WAIT_FOR_VSYNC, false );
	}

	config.m_nAASamples = CommandLine()->ParmValue( "-mat_antialias", 1 );
	config.m_nAAQuality = CommandLine()->ParmValue( "-mat_aaquality", 0 );

	config.m_VideoMode.m_Width = config.m_VideoMode.m_Height = 0;
	config.m_VideoMode.m_Format = IMAGE_FORMAT_BGRX8888;
	config.m_VideoMode.m_RefreshRate = 0;
	config.SetFlag(	MATSYS_VIDCFG_FLAGS_STENCIL, true );

	bool modeSet = g_pMaterialSystem->SetMode( m_HWnd, config );
	if (!modeSet)
	{
		Error( "Unable to set mode\n" );
		return false;
	}

	g_pMaterialSystem->OverrideConfig( config, false );
	return true;
}

#endif // _WIN32




================================================
FILE: appframework/WinApp.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: An application framework 
//
//=============================================================================//

#ifdef POSIX
#error
#else
#if defined( _WIN32 ) && !defined( _X360 )
#include <windows.h>
#endif
#include "appframework/appframework.h"
#include "tier0/dbg.h"
#include "tier0/icommandline.h"
#include "interface.h"
#include "filesystem.h"
#include "appframework/iappsystemgroup.h"
#include "filesystem_init.h"
#include "vstdlib/cvar.h"
#include "xbox/xbox_console.h"

// NOTE: This has to be the last file included!
#include "tier0/memdbgon.h"


//-----------------------------------------------------------------------------
// Globals...
//-----------------------------------------------------------------------------
HINSTANCE s_HInstance;

//static CSimpleWindowsLoggingListener s_SimpleWindowsLoggingListener;
//static CSimpleLoggingListener s_SimpleLoggingListener;
//ILoggingListener *g_pDefaultLoggingListener = &s_SimpleLoggingListener;

//-----------------------------------------------------------------------------
// HACK: Since I don't want to refit vgui yet...
//-----------------------------------------------------------------------------
void *GetAppInstance()
{
	return s_HInstance;
}


//-----------------------------------------------------------------------------
// Sets the application instance, should only be used if you're not calling AppMain.
//-----------------------------------------------------------------------------
void SetAppInstance( void* hInstance )
{
	s_HInstance = (HINSTANCE)hInstance;
}

//-----------------------------------------------------------------------------
// Specific 360 environment setup.
//-----------------------------------------------------------------------------
#if defined( _X360 )
bool SetupEnvironment360()
{
	CommandLine()->CreateCmdLine( GetCommandLine() );

	if ( !CommandLine()->FindParm( "-game" ) && !CommandLine()->FindParm( "-vproject" ) )
	{
		// add the default game name due to lack of vproject environment
		CommandLine()->AppendParm( "-game", "hl2" );
	}

	// success
	return true;
}
#endif

//-----------------------------------------------------------------------------
// Version of AppMain used by windows applications
//-----------------------------------------------------------------------------
int AppMain( void* hInstance, void* hPrevInstance, const char* lpCmdLine, int nCmdShow, CAppSystemGroup *pAppSystemGroup )
{
	Assert( pAppSystemGroup );

//	g_pDefaultLoggingListener = &s_SimpleWindowsLoggingListener;
	s_HInstance = (HINSTANCE)hInstance;
#if !defined( _X360 )
	CommandLine()->CreateCmdLine( ::GetCommandLine() );
#else
	SetupEnvironment360();
#endif

	return pAppSystemGroup->Run();
}

//-----------------------------------------------------------------------------
// Version of AppMain used by console applications
//-----------------------------------------------------------------------------
int AppMain( int argc, char **argv, CAppSystemGroup *pAppSystemGroup )
{
	Assert( pAppSystemGroup );

//	g_pDefaultLoggingListener = &s_SimpleLoggingListener;
	s_HInstance = NULL;
#if !defined( _X360 )
	CommandLine()->CreateCmdLine( argc, argv );
#else
	SetupEnvironment360();
#endif

	return pAppSystemGroup->Run();
}

//-----------------------------------------------------------------------------
// Used to startup/shutdown the application
//-----------------------------------------------------------------------------
int AppStartup( void* hInstance, void* hPrevInstance, const char* lpCmdLine, int nCmdShow, CAppSystemGroup *pAppSystemGroup )
{
	Assert( pAppSystemGroup );

//	g_pDefaultLoggingListener = &s_SimpleWindowsLoggingListener;
	s_HInstance = (HINSTANCE)hInstance;
#if !defined( _X360 )
	CommandLine()->CreateCmdLine( ::GetCommandLine() );
#else
	SetupEnvironment360();
#endif

	return pAppSystemGroup->Startup();
}

int AppStartup( int argc, char **argv, CAppSystemGroup *pAppSystemGroup )
{
	Assert( pAppSystemGroup );

//	g_pDefaultLoggingListener = &s_SimpleLoggingListener;
	s_HInstance = NULL;
#if !defined( _X360 )
	CommandLine()->CreateCmdLine( argc, argv );
#else
	SetupEnvironment360();
#endif

	return pAppSystemGroup->Startup();
}

void AppShutdown( CAppSystemGroup *pAppSystemGroup )
{
	Assert( pAppSystemGroup );
	pAppSystemGroup->Shutdown();
}


//-----------------------------------------------------------------------------
//
// Default implementation of an application meant to be run using Steam
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Constructor
//-----------------------------------------------------------------------------
CSteamApplication::CSteamApplication( CSteamAppSystemGroup *pAppSystemGroup )
{
	m_pChildAppSystemGroup = pAppSystemGroup;
	m_pFileSystem = NULL;
	m_bSteam = false;
}

//-----------------------------------------------------------------------------
// Create necessary interfaces
//-----------------------------------------------------------------------------
bool CSteamApplication::Create()
{
	FileSystem_SetErrorMode( FS_ERRORMODE_AUTO );

	char pFileSystemDLL[MAX_PATH];
	if ( FileSystem_GetFileSystemDLLName( pFileSystemDLL, MAX_PATH, m_bSteam ) != FS_OK )
		return false;
	
	// Add in the cvar factory
	AppModule_t cvarModule = LoadModule( VStdLib_GetICVarFactory() );
	AddSystem( cvarModule, CVAR_INTERFACE_VERSION );

	AppModule_t fileSystemModule = LoadModule( pFileSystemDLL );
	m_pFileSystem = (IFileSystem*)AddSystem( fileSystemModule, FILESYSTEM_INTERFACE_VERSION );
	if ( !m_pFileSystem )
	{
		Error( "Unable to load %s", pFileSystemDLL );
		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------
// The file system pointer is invalid at this point
//-----------------------------------------------------------------------------
void CSteamApplication::Destroy()
{
	m_pFileSystem = NULL;
}

//-----------------------------------------------------------------------------
// Pre-init, shutdown
//-----------------------------------------------------------------------------
bool CSteamApplication::PreInit()
{
	return true;
}

void CSteamApplication::PostShutdown()
{
}

//-----------------------------------------------------------------------------
// Run steam main loop
//-----------------------------------------------------------------------------
int CSteamApplication::Main()
{
	// Now that Steam is loaded, we can load up main libraries through steam
	if ( FileSystem_SetBasePaths( m_pFileSystem ) != FS_OK )
		return 0;

	m_pChildAppSystemGroup->Setup( m_pFileSystem, this );
	return m_pChildAppSystemGroup->Run();
}

//-----------------------------------------------------------------------------
// Use this version in cases where you can't control the main loop and
// expect to be ticked
//-----------------------------------------------------------------------------
int CSteamApplication::Startup()
{
	int nRetVal = BaseClass::Startup();
	if ( GetErrorStage() != NONE )
		return nRetVal;

	if ( FileSystem_SetBasePaths( m_pFileSystem ) != FS_OK )
		return 0;

	// Now that Steam is loaded, we can load up main libraries through steam
	m_pChildAppSystemGroup->Setup( m_pFileSystem, this );
	return m_pChildAppSystemGroup->Startup();
}

void CSteamApplication::Shutdown()
{
	m_pChildAppSystemGroup->Shutdown();
	BaseClass::Shutdown();
}

#endif



================================================
FILE: appframework/wscript
================================================
#! /usr/bin/env python
# encoding: utf-8

from waflib import Utils
import os

top = '.'
PROJECT_NAME = 'appframework'

def options(opt):
	# stub
	return

def configure(conf):
	return

def build(bld):
	source = [
		'AppSystemGroup.cpp',
		'../public/filesystem_init.cpp',
	]

	if bld.env.SDL:
		source += [
			'sdlmgr.cpp'
		]

	if bld.env.DEST_OS == 'darwin' and bld.env.GL:
		source += ['glmrendererinfo_osx.mm']


	if bld.env.DEST_OS == 'win32':
		source += [
			'vguimatsysapp.cpp',
			'winapp.cpp'
		]
	else:
		source += [
			'posixapp.cpp',#		[$POSIX]
		]

	includes = [
		'.',
		'../public',
		'../public/tier0',
		'../public/tier1'
	] + bld.env.INCLUDES_SDL2

	defines = []

	libs = []

	if bld.env.DEST_OS == 'darwin':
		libs += ['FOUNDATION', 'APPKIT', 'IOKIT']

	bld.stlib(
		source   = source,
		target   = PROJECT_NAME,
		name     = PROJECT_NAME,
		features = 'c cxx',
		includes = includes,
		defines  = defines,
		use      = libs,
		subsystem = bld.env.MSVC_SUBSYSTEM,
		idx      = bld.get_taskgen_count()
	)




================================================
FILE: bitmap/bitmap.cpp
================================================
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
//=============================================================================//

#include "bitmap/bitmap.h"
#include "dbg.h"

// Should be last include
#include "tier0/memdbgon.h"

bool Bitmap_t::IsValid() const
{
	if ( m_nWidth <= 0 || m_nHeight <= 0 || m_pBits == NULL )
	{
		Assert( m_nWidth == 0 );
		Assert( m_nHeight == 0 );
		Assert( m_pBits ==