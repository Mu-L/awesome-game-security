Project Path: arc_LeroyTechnologies_ProjectM_lar963ie

Source Tree:

```txt
arc_LeroyTechnologies_ProjectM_lar963ie
├── Content
│   └── Playgrounds
│       ├── Animations
│       │   └── Death_Ironsights_1_Montage.uasset
│       ├── Blueprints
│       │   ├── ABP_Soldier.uasset
│       │   ├── BP_FirstPersonGameModeCommander.uasset
│       │   ├── BP_FirstPersonGameModeSpectator.uasset
│       │   ├── BP_MovingActor.uasset
│       │   ├── BP_ProjectileWithoutProjectileMovementComponent.uasset
│       │   ├── BP_SoldierDeath.uasset
│       │   ├── BP_Soldier_Blue.uasset
│       │   ├── BP_Soldier_Red.uasset
│       │   ├── BP_SpawnTankProjectileExplosion.uasset
│       │   ├── BP_SpectatorPawn_Commander.uasset
│       │   ├── Deprecated_BP_SpectatorPawn_Commander.uasset
│       │   ├── Player
│       │   │   ├── Anims
│       │   │   │   ├── Aim_Down.uasset
│       │   │   │   ├── Aim_FWD.uasset
│       │   │   │   ├── Aim_Offset.uasset
│       │   │   │   ├── Aim_Up.uasset
│       │   │   │   ├── Crouch_Idle_Rifle_Ironsights.uasset
│       │   │   │   ├── Crouch_Idle_Rifle_Ironsights_L.uasset
│       │   │   │   ├── Crouch_Idle_Rifle_Ironsights_R.uasset
│       │   │   │   ├── Crouching_Locomotion.uasset
│       │   │   │   ├── Fire_GernadeLauncher_Hip_Montage.uasset
│       │   │   │   ├── Fire_Rifle_Ironsights_Montage.uasset
│       │   │   │   ├── Fire_Shotgun_Ironsights_Montage.uasset
│       │   │   │   ├── Hang_to_Crouch_fixed.uasset
│       │   │   │   ├── Hang_to_Crouch_fixed_Montage.uasset
│       │   │   │   ├── Jump_Loop.uasset
│       │   │   │   ├── Jump_Up.uasset
│       │   │   │   ├── Prone_Forward.uasset
│       │   │   │   ├── Prone_Idle.uasset
│       │   │   │   ├── Prone_Idle_L.uasset
│       │   │   │   ├── Prone_Idle_R.uasset
│       │   │   │   ├── Prone_Locomotion.uasset
│       │   │   │   ├── Prone_Reload_Rifle_Montage.uasset
│       │   │   │   ├── Prone_Reload_Shotgun_Montage.uasset
│       │   │   │   ├── Reload_Rifle_Ironsights_Montage.uasset
│       │   │   │   ├── Reload_Shotgun_Ironsights_Montage.uasset
│       │   │   │   ├── Rifle_Locomotion.uasset
│       │   │   │   ├── Stabalized_Rifle_Locomotion.uasset
│       │   │   │   ├── Steady_Rifle_Idle.uasset
│       │   │   │   ├── Steady_Rifle_Idle_L.uasset
│       │   │   │   └── Steady_Rifle_Idle_R.uasset
│       │   │   ├── PlayerCharacter.uasset
│       │   │   ├── Player_ABP.uasset
│       │   │   ├── Player_Drone.uasset
│       │   │   ├── Player_WBP.uasset
│       │   │   └── Weapons
│       │   │       ├── Master_Weapon_BP.uasset
│       │   │       ├── Player_Rifle.uasset
│       │   │       ├── Player_Shotgun.uasset
│       │   │       └── Player_Sniper.uasset
│       │   ├── Spawn_Particle_TankProjectileExplosion.uasset
│       │   └── Widgets
│       │       ├── BP_LoadingWidget.uasset
│       │       ├── BP_MapContextMenuWidget.uasset
│       │       ├── BP_MilitaryUnitTreeEntryWidget.uasset
│       │       ├── BP_ProjectMMapWidget.uasset
│       │       └── BP_SpawnSelectionWidget.uasset
│       ├── DataAssets
│       │   ├── DA_MassDeadSoldierBody_Team1.uasset
│       │   ├── DA_MassDeadSoldierBody_Team2.uasset
│       │   ├── DA_MassProjectile.uasset
│       │   ├── DA_MassSoldierBase.uasset
│       │   ├── DA_MassSoldier_Team1.uasset
│       │   ├── DA_MassSoldier_Team2.uasset
│       │   ├── DA_MassTank.uasset
│       │   ├── DA_MassTankProjectile.uasset
│       │   ├── DA_MassTankProjectileExplosion.uasset
│       │   ├── DA_MassTank_Team1.uasset
│       │   ├── DA_MassTank_Team2.uasset
│       │   ├── EQ_Circle.uasset
│       │   ├── EQ_CircleMedium.uasset
│       │   ├── EQ_CircleSmall.uasset
│       │   ├── EQ_Donut.uasset
│       │   ├── EQ_DonutSmall.uasset
│       │   ├── EQ_DonutTiny.uasset
│       │   ├── EQ_GridLarge.uasset
│       │   ├── EQ_GridLargeTanks.uasset
│       │   ├── EQ_GridSmall.uasset
│       │   ├── ST_CrowdRandomFire.uasset
│       │   ├── ST_SoldierFindTargetAndEngage.uasset
│       │   ├── ST_SoldierIdle.uasset
│       │   ├── ST_SoldierRandomFire.uasset
│       │   └── ST_TankFindTargetAndEngage.uasset
│       ├── Maps
│       │   ├── L_Large.umap
│       │   ├── L_MediumWithObstacles.umap
│       │   ├── L_MediumWithTanks.umap
│       │   ├── L_MediumWithTanks_BuiltData.uasset
│       │   ├── L_Small.umap
│       │   ├── L_SmallPlayerOnly.umap
│       │   ├── L_SmallWithTank.umap
│       │   └── L_Template.umap
│       ├── Materials
│       │   ├── MAT_Blue.uasset
│       │   ├── MAT_Map_UI.uasset
│       │   ├── MAT_Map_UI_Inst.uasset
│       │   ├── MAT_Red.uasset
│       │   ├── M_TankShellTracer.uasset
│       │   ├── M_Tracer.uasset
│       │   ├── PostProcess
│       │   │   ├── PPM_RadialBlur.uasset
│       │   │   └── PPM_RadialDamage.uasset
│       │   └── T_Dummy.uasset
│       └── Meshes
│           ├── SM_DeadSoldierBlue.uasset
│           ├── SM_DeadSoldierRed.uasset
│           ├── SM_M1A1Abrams.uasset
│           ├── SM_M1A1AbramsBlue.uasset
│           ├── SM_M1A1AbramsRed.uasset
│           ├── SM_TankShell.uasset
│           └── SM_Tracer.uasset
├── LICENSE
├── ProjectM.uplugin
├── README.md
└── Source
    └── ProjectM
        ├── Private
        │   ├── Character
        │   │   ├── CommanderCharacter.cpp
        │   │   └── MassCharacter.cpp
        │   ├── FirstPersonGameModeCommander.cpp
        │   ├── GameplayDebuggerCategory_ProjectM.cpp
        │   ├── InvalidTargetFinderProcessor.cpp
        │   ├── MassAgentLocationSyncTrait.cpp
        │   ├── MassAgentOrientNoCharSyncTrait.cpp
        │   ├── MassAgentRadiusTrait.cpp
        │   ├── MassAudioPerceptionProcessor.cpp
        │   ├── MassCollisionProcessor.cpp
        │   ├── MassDelayedDestructionProcessor.cpp
        │   ├── MassEnemyTargetFinderProcessor.cpp
        │   ├── MassFastAvoidanceProcessors.cpp
        │   ├── MassFastAvoidanceTrait.cpp
        │   ├── MassFireProjectileTask.cpp
        │   ├── MassGenericAnimTask.cpp
        │   ├── MassGenericAnimationProcessor.cpp
        │   ├── MassGenericUpdateISMVertexAnimationProcessor.cpp
        │   ├── MassGotTargetEvaluator.cpp
        │   ├── MassIdleForDurationTask.cpp
        │   ├── MassLookAtViaMoveTargetTask.cpp
        │   ├── MassMoveTargetForwardCompleteProcessor.cpp
        │   ├── MassMoveToCommandProcessor.cpp
        │   ├── MassMoveToCommandSubsystem.cpp
        │   ├── MassNavMeshMoveProcessor.cpp
        │   ├── MassOrderedSpawnLocationProcessor.cpp
        │   ├── MassPlayerSubsystem.cpp
        │   ├── MassProjectileDamageProcessor.cpp
        │   ├── MassProjectileRemoverProcessor.cpp
        │   ├── MassRifle.cpp
        │   ├── MassSimpleUpdateISMProcessor.cpp
        │   ├── MassSoldierDyingEvaluator.cpp
        │   ├── MassSoundPerceptionSubsystem.cpp
        │   ├── MassSwapEntityOnDestructionTrait.cpp
        │   ├── MassTargetFinderSubsystem.cpp
        │   ├── MassTargetGridProcessors.cpp
        │   ├── MassTrackTargetProcessor.cpp
        │   ├── MassTrackedVehicleOrientationProcessor.cpp
        │   ├── MassVisualEffectsSubsystem.cpp
        │   ├── MilitaryStructureSubsystem.cpp
        │   ├── MilitaryUnitMassSpawner.cpp
        │   ├── ProjectM.cpp
        │   ├── ProjectMMapWidget.cpp
        │   ├── ProjectMWorldInfo.cpp
        │   └── Tests
        │       └── MassMoveToCommandProcessorTest.cpp
        ├── ProjectM.Build.cs
        └── Public
            ├── Character
            │   ├── CommanderCharacter.h
            │   └── MassCharacter.h
            ├── FirstPersonGameModeCommander.h
            ├── GameplayDebuggerCategory_ProjectM.h
            ├── InvalidTargetFinderProcessor.h
            ├── MassAgentLocationSyncTrait.h
            ├── MassAgentOrientNoCharSyncTrait.h
            ├── MassAgentRadiusTrait.h
            ├── MassAudioPerceptionProcessor.h
            ├── MassCollisionProcessor.h
            ├── MassDelayedDestructionProcessor.h
            ├── MassEnemyTargetFinderProcessor.h
            ├── MassFastAvoidanceProcessors.h
            ├── MassFastAvoidanceTrait.h
            ├── MassFireProjectileTask.h
            ├── MassGenericAnimTask.h
            ├── MassGenericAnimationProcessor.h
            ├── MassGenericUpdateISMVertexAnimationProcessor.h
            ├── MassGotTargetEvaluator.h
            ├── MassIdleForDurationTask.h
            ├── MassLookAtViaMoveTargetTask.h
            ├── MassMoveTargetForwardCompleteProcessor.h
            ├── MassMoveToCommandProcessor.h
            ├── MassMoveToCommandSubsystem.h
            ├── MassNavMeshMoveProcessor.h
            ├── MassOrderedSpawnLocationProcessor.h
            ├── MassPlayerSubsystem.h
            ├── MassProjectileDamageProcessor.h
            ├── MassProjectileRemoverProcessor.h
            ├── MassRifle.h
            ├── MassSimpleUpdateISMProcessor.h
            ├── MassSoldierDyingEvaluator.h
            ├── MassSoundPerceptionSubsystem.h
            ├── MassSwapEntityOnDestructionTrait.h
            ├── MassTargetFinderSubsystem.h
            ├── MassTargetGridProcessors.h
            ├── MassTrackTargetProcessor.h
            ├── MassTrackedVehicleOrientationProcessor.h
            ├── MassVisualEffectsSubsystem.h
            ├── MilitaryStructureSubsystem.h
            ├── MilitaryUnitMassSpawner.h
            ├── ProjectM.h
            ├── ProjectMMapWidget.h
            └── ProjectMWorldInfo.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 LeroyTechnologies

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`ProjectM.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "ProjectM",
	"Description": "",
	"Category": "Other",
	"CreatedBy": "",
	"CreatedByURL": "",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "ProjectM",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		}
	],
	"Plugins": [
		{
			"Name": "MassAI",
			"Enabled": true
		},
		{
			"Name": "MassCrowd",
			"Enabled": true
		},
		{
			"Name": "MassEntity",
			"Enabled": true
		},
		{
			"Name": "MassGameplay",
			"Enabled": true
		},
		{
			"Name": "AnimToTexture",
			"Enabled": true
		},
		{
			"Name": "ContextualAnimation",
			"Enabled": true
		},
		{
			"Name": "MotionWarping",
			"Enabled": true
		}
	]
}

```

`README.md`:

```md
# On All Fronts

## Latest Demo

Check out our latest updates on our YouTube: https://www.youtube.com/@haywireinteractive/videos

## What is this?

On All Fronts is a tactical shooter and strategy FPS / RTS game developed with [Unreal Engine 5](https://www.unrealengine.com/en-US/unreal-engine-5), leveraging the new [Mass Entity](https://docs.unrealengine.com/5.0/en-US/overview-of-mass-entity-in-unreal-engine/) ([ECS](https://en.wikipedia.org/wiki/Entity_component_system)) framework to have a very large number of entities not seen in traditional FPS games (tens or hundreds of thousands). Think [Squad](https://joinsquad.com/) meets [Foxhole](https://www.foxholegame.com/) meets [PlanetSide 2](https://www.planetside2.com/home) mixed in with massive number of AI controlled soldiers.

Note that the project has transitioned to closed source so we could use paid assets, but this open source repo will stay around to help others learn the Mass Entity system which is not very well-documented/supported yet.

[Join our Discord Server here.](https://discord.gg/6Yj2MsQTjz)

## Motivation

In today's MilSim games players frequently end up doing things or seeing things that would not happen in an actual MilSim. Examples:
- Soldiers magically spawn onto the battlefield
- Areas of interest are captured by standing near them
- Areas that should be defended have little or no one defending them (because it's boring)
- Soldiers being revived who should be dead
- Soldiers being healed much faster than they should be able to

On All Fronts aims to eliminate these unrealistic occurrences while keeping the game fun. It mainly does this by leveraging AI to do the not-so-fun stuff such as:
- Moving soldiers to the frontlines
- Defending all areas of interest, even those with little activity
- Logistics
- Vehicle repairs
- Medical evacuation (medevac)

Human players will never spawn soldiers onto the battlefield. Instead they will possess an AI-controller soldier already on the battlefield. Each match will last until all soldiers of one team are dead or main objectives have been accomplished.

# Roadmap

The project is broken into multiple phases. For current status, see [Project Tracker](https://github.com/orgs/HaywireInteractive/projects/4/views/1).

## Phase 1: Demo
- Single player: One human player and thousands of AI soldiers (no vehicles)
- Epic's City Sample map

## Phase 2: Early Access

- Multiplayer FPS game with per-server battles
- Human and AI soldiers only (no vehicles)
- Epic's City Sample map

## Phase 3: Release

- Ground vehicles
- Commander assets (e.g. artillery)
- More maps

## Phase 4: Multiplayer MMO

All players in the game will be in a single battle at a time, across multiple servers.

This phase is split into two sub-phases below.

### Phase 4A: Server switching between zones

The map will be split up into zones. When a player reaches the border between zones, they load into a different server that manages that area of the map.

### Phase 4B: Server meshing across zones

Seamless switching between servers and players at the borders of servers will talk to all nearby servers to have a seamless experience across zones.

## End Game

The ultimate goal is to recreate a war at a scale such as in this video (with the teams a bit more balanced): https://youtu.be/RSqKx3FG0Lw

## Possible Features

These ideas below would be explored in one of the phases above.

1. Railroad system for logistics. Railroads can be damaged and repaired.
1. Oil pipelines for transfering oil to vehicles quicker.
1. Base building (FOBs and COPs)
1. Pontoon bridges which can be built for river crossings. Bridges can be destroyed.
1. Building destruction
1. Naval warfare
1. Helicopters
1. Airplanes (not player controlled initially, only AI)

# FAQ

- Where can I ask questions or get involved in the project? Join our Discord server: https://discord.gg/6Yj2MsQTjz

# Development Environment Setup

## Prerequisites
1. Install Git. Two recommended options:
    1. For Git beginners, [GitHub Desktop](https://desktop.github.com/) is recommended.
    1. For more advanced users, [Git for Windows](https://gitforwindows.org/) is recommended. Use the default options in installer.
1. Install Unreal Engine 5.0.3 from [Epic Games Launcher](https://store.epicgames.com/en-US/download).
1. Install [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/).
    1. Follow steps [here](https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/#optionsforanewvisualstudioinstallation) for which options to choose when installing.
    1. In Visual Studio Installer make sure to select a .NET Framework SDK version, at least 4.6. ![image](https://user-images.githubusercontent.com/108254625/198902032-370cc297-1a42-4b91-9c29-f37ee5922ce3.png)

    1. If you don't have it installed, install latest .NET Core 3.1: https://dotnet.microsoft.com/en-us/download/dotnet?cid=getdotnetcore
1. If you plan to modify C++/C# code: Launch Visual Studio > Tools > Options
    1. Text Editor > C/C++ > Tabs > select "Keep tabs"
    1. Text Editor > C# > Tabs > select "Keep tabs"
    1. Text Editor > Advanced > uncheck "Use adaptive formatting"

## Quick Start
The project is structured as an Unreal Engine plugin. To quickly get started, we have an Unreal Engine starter project that already includes a reference to plugin. To use it:
1. In GitHub Desktop:
    1. File > Clone repository > URL tab
    1. URL: https://github.com/Leroy231/ProjectMStarter.git
    1. Local path: choose a folder on your machine where you want the Unreal Engine project created
    1. Click Clone
1. In Windows Explorer double click the .uproject at the root of the folder where you cloned the project.
1. You should get a prompt about missing modules. Click Yes to build them.
1. Note that you won't see any progress while it's building, just be patient. If you want to make sure it's building, open Task Manager and you should see Microsoft C++ Compiler using CPU. On an Intel Core i7-9700K CPU @ 3.60GHz this took about 3 minutes.
1. When it's done, it should open the project in Unreal Engine. Now move onto the next section below.

### Add Assets
1. First confirm that the ProjectM folder shows up in your Content Drawer under Plugins. If you don't see Plugins, click Settings button on top right of Content Drawer > Show Plugin Content.
1. Add Content Packs from Content Drawer > Add > Add Feature or Content Pack > Blueprint
    1. First Person > Add to project.
    1. Third Person > Add to project.
1. Add Unreal Engine Marketplace free content to project. Note that some of this content hasn't been migrated to UE5 yet, so when you try to add it from the Epic Games Launcher, check "Show all projects" after clicking "Add to Project". Then in the "Select Version" dropdown select the newest version in the list.
    1. [Military Weapons Silver](https://www.unrealengine.com/marketplace/en-US/product/military-weapons-silver)
    1. [M1A1 Abrams Tank](https://www.unrealengine.com/marketplace/en-US/product/m1a1-abrams-tank)
    1. [Realistic Starter VFX Pack Vol 2](https://www.unrealengine.com/marketplace/en-US/product/realistic-starter-vfx-pack-vol)
    1. [Animation Starter Pack](https://www.unrealengine.com/marketplace/en-US/product/animation-starter-pack)
1. Now in Content Drawer open "Plugins/ProjectM Content/Playgrounds/Maps/L_MediumWithTanks" level and use PIE to test out the project.
    1. You might have to build NavMesh paths via menu for move commands to work: Build > Build Paths.
    
## Adding Plugin to Existing Project
1. If you want to use the [City Sample project](https://www.unrealengine.com/marketplace/en-US/product/city-sample) for developing in a large level, get the project from UE Marketplace and then create a project using that template.
1. If there is no .sln in the project folder, generate VS project from right clicking .uproject in project folder.
1. Open .sln in Visual Studio if it isn't already open.
1. If project isn't open yet in UE, run the project from VS.
1. Enable the required plugins in UE project if they are not already:
    1. Edit > Plugins
    1. Search for "mass"
    1. Check MassAI, MassCrowd, MassEntity, MassGameplay. Answer Yes if it asks if you're sure.
1. Quit UE.
1. In PowerShell:
    1. `cd` to project folder. This is the folder that has the .uproject file.
    1. If `Plugins` folder does not exist, `mkdir Plugins`.
    1. `cd Plugins`
    1. `git clone https://github.com/Leroy231/OnAllFronts.git`
	1. If in City Sample: `rmdir -recurse AnimToTexture`
	1. `git clone --branch projectm https://github.com/Leroy231/AnimToTexture.git`
1. Right click the .uproject file again and re-generate the solution to get the new files from the Plugins folder to show in VS.
1. In order to get Mass ParallelForEachEntityChunk to actually parallelize, it requires passing an argument to editor on launch:
    1. In VS Solution Explorer, right click the project under Games folder > Properties.
    1. Debugging > Command Arguments > Add " -ParallelMassQueries=1" to the end (without quotes).
1. Rerun project from VS.
1. Edit > Project Settings
    1. Engine - Input > Bindings
        1. Ensure you have all the AxisMappings and ActionMappings from here: https://github.com/Leroy231/ProjectMStarter/blob/main/Config/DefaultInput.ini
    1. Engine - Mass
		1. Search for "MassUpdateISMProcessor" > Mass > Module Settings > Mass Entity > Processor CDOs > Index (for MassUpdateISMProcessor) > Auto Register with Processing Phases > uncheck. Note this will already be unchecked in the City Sample project.
		1. Search for "MassGenericUpdateISMVertexAnimationProcessor" > Mass > Module Settings > Mass Entity > Processor CDOs > Index (for MassGenericUpdateISMVertexAnimationProcessor) > Auto Register with Processing Phases > check
		1. Do the same as previous for "MassSimpleUpdateISMProcessor".
    1. Engine - Navigation System > Agents > Supported Agents > Add agents based on the "SupportedAgents" towards bottom of this file: https://github.com/Leroy231/ProjectMStarter/blob/main/Config/DefaultEngine.ini
        1. Only the Name, Nav Agent Radius, and Nav Agent Height need to be set.
1. Follow steps above in [Add Assets](#add-assets) section.

## To add soldiers to City Sample Level
1. Duplicate Small_City_LVL and call it Small_City_ProjectM_LVL
1. Open Small_City_ProjectM_LVL
1. Delete Actors
    1. Mass Spawners: BP_MassTraffic* and BP_MassCrowdSpawner
    1. BP_CitySampleWorldInfo
    1. BP_Nightmode
    1. SmartObjectCollection
1. Open L_Template
1. Copy PM_* actors
1. Paste in Small_City_ProjectM_LVL. Ensure locations of all actors were preserved.
1. Set up world info
    1. Select actor "PM_WorldInfo"
    1. Details pane > Sim > Sunlight > set "Sun Light" to "DirectionalLight_WP"
    1. Set "Sky Dome" to "SM_dome"
1. From menu: Build > Build ZoneGraph
1. Select each PM_MilitaryUnitMassSpawner* actor > Details > World Partition > Is Spatially Loaded > uncheck
1. World Settings > GameMode Override > BP_FirstPersonGameModeCommander
1. We need to make collisions loaded all the time because AI soldiers rely on them to determine if they have line of sight to enemies:
    1. Load all cells in World Partition
    1. While we've got all cells loaded, build NavMesh from menu: Build > Build Paths
    1. In Outliner search for "coll"
    1. Click on any actor in the Outliner and select all (Ctrl+A)
    1. Details > World Partition > Is Spatially Loaded > uncheck
    1. World Partition: Unload all cells and load any if desired

```

`Source/ProjectM/Private/Character/CommanderCharacter.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Character/CommanderCharacter.h"
#include "MassMoveToCommandSubsystem.h"
#include "MassFireProjectileTask.h"
#include "MassEntityQuery.h"
#include "MassProjectileDamageProcessor.h"
#include "MassCommonFragments.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "MassAgentComponent.h"
#include "MassEntityView.h"
#include "MassSpawnerSubsystem.h"
#include "MassEntitySpawnDataGeneratorBase.h"
#include "MassSpawnLocationProcessor.h"
#include "MassAgentSubsystem.h"
#include <MilitaryStructureSubsystem.h>

//----------------------------------------------------------------------//
//  UMassPlayerControllableCharacterTrait
//----------------------------------------------------------------------//
void UMassPlayerControllableCharacterTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddTag<FMassPlayerControllableCharacterTag>();
}

//----------------------------------------------------------------------//
//  ACommanderCharacter
//----------------------------------------------------------------------//
ACommanderCharacter::ACommanderCharacter()
{
	PrimaryActorTick.bCanEverTick = false;
}

void ACommanderCharacter::BeginPlay()
{
	Super::BeginPlay();

	UWorld* World = GetWorld();
	check(World);
	MoveToCommandSystem = UWorld::GetSubsystem<UMassMoveToCommandSubsystem>(World);

	UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld());
	check(AgentSubsystem);

	OnMassAgentComponentEntityAssociatedHandle = AgentSubsystem->GetOnMassAgentComponentEntityAssociated().AddLambda([this, AgentSubsystem](const UMassAgentComponent& AgentComponent)
	{
		if (&AgentComponent == Cast<UMassAgentComponent>(GetComponentByClass(UMassAgentComponent::StaticClass())))
		{
			AgentSubsystem->GetOnMassAgentComponentEntityAssociated().Remove(OnMassAgentComponentEntityAssociatedHandle);
			OnMassAgentComponentEntityAssociatedHandle.Reset();
			InitializeFromMassSoldierInternal();
		}
	});
}

void ACommanderCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	if (OnMassAgentComponentEntityAssociatedHandle.IsValid())
	{
		UMassAgentSubsystem* AgentSubsystem = UWorld::GetSubsystem<UMassAgentSubsystem>(GetWorld());
		check(AgentSubsystem);
		AgentSubsystem->GetOnMassAgentComponentEntityAssociated().Remove(OnMassAgentComponentEntityAssociatedHandle);
		OnMassAgentComponentEntityAssociatedHandle.Reset();
	}

	Super::EndPlay(EndPlayReason);
}

UMilitaryUnit* ACommanderCharacter::GetMyMilitaryUnit() const
{
	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(GetWorld());
	check(MilitaryStructureSubsystem);

	return MilitaryStructureSubsystem->GetUnitForEntity(GetMassEntityHandle());
}

static FAutoConsoleCommand SetTeam2MoveToCommandToOrigin(
	TEXT("pm.SetTeam2MoveToCommandToOrigin"),
	TEXT("SetTeam2MoveToCommandToOrigin.")
	TEXT("Usage: \"pm.SetTeam2MoveToCommandToOrigin\""),
	FConsoleCommandWithWorldArgsAndOutputDeviceDelegate::CreateLambda([](const TArray<FString>& Args, UWorld* World, FOutputDevice& OutputDevice)
	{
		UMassMoveToCommandSubsystem* MoveToCommandSystem = World->GetSubsystem<UMassMoveToCommandSubsystem>();
		MoveToCommandSystem->EnqueueMoveToCommand(nullptr, FVector(0.f, 0.f, 20.f), false);
	}));

void ACommanderCharacter::SetMoveToCommand(FVector2D CommandLocation) const
{
	UMilitaryUnit* MyMilitaryUnit = GetMyMilitaryUnit();

	if (!MyMilitaryUnit)
	{
		UE_LOG(LogTemp, Warning, TEXT("Cannot find military unit for player when attempting to set move to command, setting command for all entities on team."));

		// TODO: don't hard-code 20.f below
		MoveToCommandSystem->EnqueueMoveToCommand(nullptr, FVector(CommandLocation.X, CommandLocation.Y, 20.f), IsPlayerOnTeam1());
		return;
	}

	if (!MyMilitaryUnit->bIsCommander)
	{
		UE_LOG(LogTemp, Warning, TEXT("Cannot set move to command from soldier who is not a commander."));
		return;
	}

	check(MyMilitaryUnit->Parent);
	// TODO: don't hard-code 20.f below
	MoveToCommandSystem->EnqueueMoveToCommand(MyMilitaryUnit->Parent, FVector(CommandLocation.X, CommandLocation.Y, 20.f), IsPlayerOnTeam1());
}

void ACommanderCharacter::ChangePlayerToAISoldier()
{
	UWorld* World = GetWorld();
	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
	check(EntitySubsystem);

	const FMassEntityHandle& PlayerEntityHandle = GetMassEntityHandle();
	FMassEntityView PlayerEntityView(*EntitySubsystem, PlayerEntityHandle);
	FTransformFragment* PlayerEntityTransformFragment = PlayerEntityView.GetFragmentDataPtr<FTransformFragment>();
	FMassHealthFragment* PlayerEntityHealthFragment = PlayerEntityView.GetFragmentDataPtr<FMassHealthFragment>();

	check(PlayerEntityTransformFragment);
	check(PlayerEntityHealthFragment);

	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
	check(SpawnerSystem);

	// TODO: A bit hacky to get first actor here.
	const FMassEntityTemplate* EntityTemplate = SoldierEntityConfig.GetOrCreateEntityTemplate(*World->GetLevel(0)->Actors[0], *SpawnerSystem); // TODO: passing SpawnerSystem is a hack
	check(EntityTemplate->IsValid());

	FMassEntitySpawnDataGeneratorResult Result;
	Result.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();
	Result.SpawnData.InitializeAs<FMassTransformsSpawnData>();
	Result.NumEntities = 1;
	FMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();

	Transforms.Transforms.Reserve(1);
	FTransform& SpawnDataTransform = Transforms.Transforms.AddDefaulted_GetRef();
	SpawnDataTransform = PlayerEntityTransformFragment->GetTransform();

	TArray<FMassEntityHandle> SpawnedEntities;
	SpawnerSystem->SpawnEntities(EntityTemplate->GetTemplateID(), Result.NumEntities, Result.SpawnData, Result.SpawnDataProcessor, SpawnedEntities);

	FMassHealthFragment* SpawnedEntityHealthFragment = EntitySubsystem->GetFragmentDataPtr<FMassHealthFragment>(SpawnedEntities[0]);
	check(SpawnedEntityHealthFragment);
	SpawnedEntityHealthFragment->Value = PlayerEntityHealthFragment->Value;

	UMilitaryUnit* MyMilitaryUnit = GetMyMilitaryUnit();
	MyMilitaryUnit->bIsPlayer = false;

	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(GetWorld());
	check(MilitaryStructureSubsystem);
	MilitaryStructureSubsystem->BindUnitToMassEntity(MyMilitaryUnit, SpawnedEntities[0]);
}

void ACommanderCharacter::DidDie_Implementation()
{
}

bool ACommanderCharacter::InitializeFromMassSoldier(const int32 MassEntityIndex, const int32 MassEntitySerialNumber)
{
	FMassEntityHandle MassSoldierEntity(MassEntityIndex, MassEntitySerialNumber);

	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld());
	check(EntitySubsystem);

	if (!EntitySubsystem->IsEntityValid(MassSoldierEntity))
	{
		return false;
	}

	this->MassSoldierEntityToInitializeWith = MassSoldierEntity;
	return true;
}

void ACommanderCharacter::InitializeFromMassSoldierInternal()
{
	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(GetWorld());
	check(MilitaryStructureSubsystem);

	// If we don't have a soldier entity to initialize with, set it to team's highest commander.
	if (!MassSoldierEntityToInitializeWith.IsSet())
	{
		UMilitaryUnit* RootUnit = MilitaryStructureSubsystem->GetRootUnitForTeam(IsPlayerOnTeam1());
		if (!RootUnit)
		{
			UE_LOG(LogTemp, Warning, TEXT("Cannot find root military unit for player's team on character initialization."));
			return;
		}

		UMilitaryUnit* TeamCommander = RootUnit->Commander;

		if (!TeamCommander)
		{
			UE_LOG(LogTemp, Warning, TEXT("Cannot find military unit for team commander on character initialization."));
			return;
		}
		MassSoldierEntityToInitializeWith = TeamCommander->GetMassEntityHandle();
	}

	if (!MassSoldierEntityToInitializeWith.IsSet())
	{
		UE_LOG(LogTemp, Warning, TEXT("Cannot find military unit for player on character initialization."));
		return;
	}

	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld());
	check(EntitySubsystem);

	const FMassHealthFragment& SoldierHealthFragment = EntitySubsystem->GetFragmentDataChecked<FMassHealthFragment>(MassSoldierEntityToInitializeWith);
	int16 NewPlayerHealth = SoldierHealthFragment.Value;

	const FTransformFragment& SoldierTransformFragment = EntitySubsystem->GetFragmentDataChecked<FTransformFragment>(MassSoldierEntityToInitializeWith);
	const FTransform& SoldierTransform = SoldierTransformFragment.GetTransform();
	const FVector& SoldierLocation = SoldierTransform.GetLocation();
	const FQuat& SoldierRotation = SoldierTransform.GetRotation();

	FMassEntityHandle PlayerEntityHandle = GetMassEntityHandle();

	UMilitaryUnit* SoldierMilitaryUnit = MilitaryStructureSubsystem->GetUnitForEntity(MassSoldierEntityToInitializeWith);
	SoldierMilitaryUnit->bIsPlayer = true;
	MilitaryStructureSubsystem->BindUnitToMassEntity(SoldierMilitaryUnit, PlayerEntityHandle);
	EntitySubsystem->DestroyEntity(MassSoldierEntityToInitializeWith);

	FMassHealthFragment* PlayerEntityHealthFragment = EntitySubsystem->GetFragmentDataPtr<FMassHealthFragment>(PlayerEntityHandle);
	check(PlayerEntityHealthFragment);
	
	PlayerEntityHealthFragment->Value = NewPlayerHealth;
	const FVector NewPlayerLocation = SoldierLocation + FVector(0.f, 0.f, RootComponent->Bounds.BoxExtent.Z);

	FTransform NewActorTransform(SoldierRotation, NewPlayerLocation, GetActorTransform().GetScale3D());
	SetActorTransform(NewActorTransform, false, nullptr, ETeleportType::ResetPhysics);
}

bool ACommanderCharacter::IsPlayerOnTeam1() const
{
	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld());
	check(EntitySubsystem);

	FMassEntityView PlayerEntityView(*EntitySubsystem, GetMassEntityHandle());

	FTeamMemberFragment* PlayerEntityTeamMemberFragment = PlayerEntityView.GetFragmentDataPtr<FTeamMemberFragment>();
	check(PlayerEntityTeamMemberFragment);

	return PlayerEntityTeamMemberFragment->IsOnTeam1;
}

FMassEntityHandle ACommanderCharacter::GetMassEntityHandle() const
{
	const UMassAgentComponent* AgentComponent = Cast<UMassAgentComponent>(GetComponentByClass(UMassAgentComponent::StaticClass()));
	if (!AgentComponent)
	{
		return FMassEntityHandle();
	}

	const FMassEntityHandle& AgentEntityHandle = AgentComponent->GetEntityHandle();
	check(AgentEntityHandle.IsValid());

	return AgentEntityHandle;
}

bool ACommanderCharacter::IsCommander() const
{
	UMilitaryUnit* MyMilitaryUnit = GetMyMilitaryUnit();

	if (!MyMilitaryUnit)
	{
		UE_LOG(LogTemp, Warning, TEXT("Cannot find military unit for player when attempting to check if commander."));
		return false;
	}

	return MyMilitaryUnit->bIsCommander;
}

float ACommanderCharacter_InitialProjectileVelocityZFudge = -2500.f;
FAutoConsoleVariableRef CVar_ACommanderCharacter_InitialProjectileVelocityZFudge(TEXT("pm.ACommanderCharacter_InitialProjectileVelocityZFudge"), ACommanderCharacter_InitialProjectileVelocityZFudge, TEXT("ACommanderCharacter_InitialProjectileVelocityZFudge"));

void ACommanderCharacter::SpawnProjectile(const FTransform SpawnTransform) const
{
	const UWorld* World = GetWorld();
	FVector InitialVelocity = SpawnTransform.GetRotation().Vector() * GetProjectileInitialXYVelocityMagnitude(true);
	// TODO: For some reason we need to adjust the initial velocity for it to align with muzzle. We shouldn't have to do this.
	InitialVelocity += FVector(0.f, 0.f, ACommanderCharacter_InitialProjectileVelocityZFudge);
	::SpawnProjectile(World, SpawnTransform.GetLocation(), SpawnTransform.GetRotation(), InitialVelocity, ProjectileEntityConfig, IsPlayerOnTeam1());
}

```

`Source/ProjectM/Private/Character/MassCharacter.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "Character/MassCharacter.h"

```

`Source/ProjectM/Private/FirstPersonGameModeCommander.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "FirstPersonGameModeCommander.h"

#include "Kismet/GameplayStatics.h"
#include "MilitaryUnitMassSpawner.h"

void AFirstPersonGameModeCommander::StartPlay()
{
  Super::StartPlay();

	TArray<AActor*> MilitaryUnitMassSpawners;
	UGameplayStatics::GetAllActorsOfClass(this, AMilitaryUnitMassSpawner::StaticClass(), MilitaryUnitMassSpawners);

	if (MilitaryUnitMassSpawners.Num() == 0)
	{
		AFirstPersonGameModeCommander::BP_OnCompletedAssigningEntitiesToMilitaryUnits();
		return;
	}

	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(GetWorld());
	check(MilitaryStructureSubsystem);
	MilitaryStructureSubsystem->OnCompletedAssigningEntitiesToMilitaryUnitsEvent.AddDynamic(this, &AFirstPersonGameModeCommander::BP_OnCompletedAssigningEntitiesToMilitaryUnits);
}

```

`Source/ProjectM/Private/GameplayDebuggerCategory_ProjectM.cpp`:

```cpp
// Adapted from GameplayDebuggerCategory_Mass.cpp.

#include "GameplayDebuggerCategory_ProjectM.h"

#if WITH_GAMEPLAY_DEBUGGER

#include "GameFramework/Actor.h"
#include "GameFramework/PlayerController.h"
#include "MassAudioPerceptionProcessor.h"
#include <MassEnemyTargetFinderProcessor.h>
#include <MassNavMeshMoveProcessor.h>
#include <MassMoveToCommandProcessor.h>
#include "NavigationSystem.h"
#include <MassCommonFragments.h>
#include <GameplayDebuggerConfig.h>
#include "CanvasItem.h"

FGameplayDebuggerCategory_ProjectM::FGameplayDebuggerCategory_ProjectM()
{
  bShowOnlyWithDebugActor = false;

  BindKeyPress(EKeys::T.GetFName(), FGameplayDebuggerInputModifier::Shift, this, &FGameplayDebuggerCategory_ProjectM::OnToggleEnemyTargetFinderDetails, EGameplayDebuggerInputMode::Replicated);
}

// Warning: This gets called on every tick before UMassProcessor::Execute.
void FGameplayDebuggerCategory_ProjectM::CollectData(APlayerController* OwnerPC, AActor* DebugActor)
{
	if (!OwnerPC)
	{
		return;
	}
	
	NearEntityDescriptions.Reset();

	FVector ViewLocation = FVector::ZeroVector;
	FVector ViewDirection = FVector::ForwardVector;
	ensureMsgf(GetViewPoint(OwnerPC, ViewLocation, ViewDirection), TEXT("GetViewPoint is expected to always succeed when passing a valid controller."));

	CollectDataForEntities(OwnerPC, ViewLocation, ViewDirection);

	FDebugEntityData& DebugEntityData = UMassEnemyTargetFinderProcessor_DebugEntityData;
	if (DebugEntityData.IsEntitySearching && bShowEnemyTargetFinderDetails)
	{
		AddTextLine(FString::Printf(TEXT("Enemy Target Finder Legend:")));
		AddTextLine(FString::Printf(TEXT("{red}Red: Same team\n{yellow}Yellow: Blocked by another entity\n{orange}Orange: Impenetrable\n{blue}Blue: Out of range\n{black}Black: No line of sight")));

		AddShape(FGameplayDebuggerShape::MakeBox(DebugEntityData.SearchCenter, DebugEntityData.SearchExtent, FColor::Purple));

		DrawTargetEntityLocations(DebugEntityData.TargetEntitiesCulledDueToSameTeam, FColor::Red, DebugEntityData.EntityLocation);
		DrawTargetEntityLocations(DebugEntityData.TargetEntitiesCulledDueToOtherEntityBlocking, FColor::Yellow, DebugEntityData.EntityLocation);
		DrawTargetEntityLocations(DebugEntityData.TargetEntitiesCulledDueToImpenetrable, FColor::Orange, DebugEntityData.EntityLocation);
		DrawTargetEntityLocations(DebugEntityData.TargetEntitiesCulledDueToOutOfRange, FColor::Blue, DebugEntityData.EntityLocation);
		DrawTargetEntityLocations(DebugEntityData.TargetEntitiesCulledDueToNoLineOfSight, FColor::Black, DebugEntityData.EntityLocation);

		if (DebugEntityData.HasTargetEntity)
		{
			TArray<FVector> TargetEntityLocationArray;
			TargetEntityLocationArray.Add(DebugEntityData.TargetEntityLocation);
			DrawTargetEntityLocations(TargetEntityLocationArray, FColor::Green, DebugEntityData.EntityLocation);
		}
	}
	DebugEntityData.Reset();
}

void FGameplayDebuggerCategory_ProjectM::DrawTargetEntityLocations(const TArray<FVector>& TargetEntityLocations, const FColor& Color, const FVector& EntityLocation)
{
	const FVector ZOffset(0.f, 0.f, 200.f);
	for (const FVector& TargetEntityLocation : TargetEntityLocations)
	{
		AddShape(FGameplayDebuggerShape::MakeArrow(EntityLocation + ZOffset, TargetEntityLocation + ZOffset, 10.0f, 2.0f, Color));
		AddShape(FGameplayDebuggerShape::MakeCylinder(TargetEntityLocation + ZOffset / 2.f, 50.f, 100.0f, Color));
	}
}

void FGameplayDebuggerCategory_ProjectM::CollectDataForEntities(const APlayerController* OwnerPC, const FVector& ViewLocation, const FVector& ViewDirection)
{
	UWorld* World = GetDataWorld(OwnerPC, nullptr);

	UMassEntitySubsystem* EntitySystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
	if (!EntitySystem)
	{
		return;
	}

	FMassEntityQuery EntityQuery;
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassNavMeshMoveFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);

	FMassExecutionContext Context(0.0f);

	EntityQuery.ForEachEntityChunk(*EntitySystem, Context, [this, &ViewLocation, &ViewDirection, World, &EntitySystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		const TConstArrayView<FMassNavMeshMoveFragment> NavMeshMoveList = Context.GetFragmentView<FMassNavMeshMoveFragment>();
		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();
		const TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();

		const UGameplayDebuggerUserSettings* Settings = GetDefault<UGameplayDebuggerUserSettings>();
		const float MaxViewDistance = Settings->MaxViewDistance;
		const float MinViewDirDot = FMath::Cos(FMath::DegreesToRadians(Settings->MaxViewAngle));

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			CollectDataForEntity(NavMeshMoveList[EntityIndex], TransformList[EntityIndex].GetTransform(), MinViewDirDot, ViewLocation, ViewDirection, MaxViewDistance, MoveTargetList[EntityIndex], RadiusList[EntityIndex].Radius, Context.GetEntity(EntityIndex), World, Context);
		}
	});
}

void FGameplayDebuggerCategory_ProjectM::CollectDataForEntity(const FMassNavMeshMoveFragment& NavMeshMoveFragment, const FTransform& Transform, const float MinViewDirDot, const FVector& ViewLocation, const FVector& ViewDirection, const float MaxViewDistance, const FMassMoveTargetFragment& MoveTargetFragment, const float AgentRadius, const FMassEntityHandle& Entity, const UWorld* World, FMassExecutionContext& Context)
{
	const bool bNeedsNavMeshMove = Context.DoesArchetypeHaveTag<FMassNeedsNavMeshMoveTag>();
	if (bNeedsNavMeshMove && UE::Mass::Debug::IsDebuggingEntity(Entity))
	{
		const TArray<FNavigationAction>& Actions = NavMeshMoveFragment.ActionList.Get()->Actions;
		int32 LineEndIndex = 1;
		int32 ActionIndex = 0;
		// Draw lines.
		for (const FNavigationAction& Action : Actions)
		{
			if (Action.Action == EMassMovementAction::Move)
			{
				const FNavigationAction& LineStartAction = Actions[ActionIndex - 1];
				const FColor& LineColor = ActionIndex < NavMeshMoveFragment.CurrentActionIndex ? FColor::Green : FColor::Red;
				AddShape(FGameplayDebuggerShape::MakeSegment(LineStartAction.TargetLocation, Action.TargetLocation, LineColor));
			}
			ActionIndex++;
		}
		ActionIndex = 0;
		// Draw points and forwards.
		for (const FNavigationAction& Action : Actions)
		{
			if (Action.Action == EMassMovementAction::Stand)
			{
				// Red = point not yet reached. Green = point already reached.
				const FColor& Color = ActionIndex < NavMeshMoveFragment.CurrentActionIndex ? FColor::Green : FColor::Red;
				const FVector StringLocation = Action.TargetLocation + FVector(0.f, 0.f, 50.f);
				AddShape(FGameplayDebuggerShape::MakePoint(Action.TargetLocation, 3.f, Color, FString::Printf(TEXT("{white}SMI %d, AI %d"), NavMeshMoveFragment.SquadMemberIndex, ActionIndex)));
				AddShape(FGameplayDebuggerShape::MakeArrow(Action.TargetLocation, Action.TargetLocation + Action.Forward * AgentRadius, 10.f, 2.f, FColor::Purple));
			}
			ActionIndex++;
		}
	}

	// Cull entity if needed
	const FVector& EntityLocation = Transform.GetLocation();
	const FVector DirToEntity = EntityLocation - ViewLocation;
	const float DistanceToEntitySq = DirToEntity.SquaredLength();
	if (DistanceToEntitySq > FMath::Square(MaxViewDistance))
	{
		return;
	}
	const float ViewDot = FVector::DotProduct(DirToEntity.GetSafeNormal(), ViewDirection);
	if (ViewDot < MinViewDirDot)
	{
		return;
	}

	if (DistanceToEntitySq < FMath::Square(MaxViewDistance * 0.5f))
	{
		AddShape(FGameplayDebuggerShape::MakeArrow(EntityLocation, MoveTargetFragment.Center, 10.f, 2.f, FColor::Black));

		UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(World);
		check(MilitaryStructureSubsystem);
		UMilitaryUnit* EntityUnit = MilitaryStructureSubsystem->GetUnitForEntity(Entity);

		FString Status;
		const bool bIsSearching = Context.DoesArchetypeHaveTag<FMassNeedsEnemyTargetTag>();
		const bool bIsEngaging = Context.DoesArchetypeHaveTag<FMassWillNeedEnemyTargetTag>();
		FString ContactState = FString(bIsSearching ? TEXT("Searching") : bIsEngaging ? TEXT("Engaging") : TEXT(""));
		Status += FString::Printf(TEXT("{pink}ContactState: %s\n"), *ContactState);
		if (EntityUnit)
		{
			Status += FString::Printf(TEXT("{red}SquadIndex: %d\n{orange}SquadMemberIndex: %d\n"), EntityUnit->SquadIndex, NavMeshMoveFragment.SquadMemberIndex);
		}
		if (bNeedsNavMeshMove)
		{
			Status += FString::Printf(TEXT("{white}CurrentActionIndex: %d\n{yellow}ActionsRemaining: %d\n{turquoise}ActionsNum: %d\n{cyan}IsWaitingOnSquadMates: %d"), NavMeshMoveFragment.CurrentActionIndex, NavMeshMoveFragment.ActionsRemaining, NavMeshMoveFragment.ActionList.Get()->Actions.Num(), NavMeshMoveFragment.bIsWaitingOnSquadMates);
		}

		FVector BasePos = EntityLocation + FVector(0.0f, 0.0f, 25.0f);
		constexpr float ViewWeight = 0.6f; // Higher the number the more the view angle affects the score.
		const float ViewScale = 1.f - (ViewDot / MinViewDirDot); // Zero at center of screen
		NearEntityDescriptions.Emplace(DistanceToEntitySq * ((1.0f - ViewWeight) + ViewScale * ViewWeight), BasePos, Status);
	}

	// Cap labels to closest ones.
	NearEntityDescriptions.Sort([](const FEntityDescription& LHS, const FEntityDescription& RHS) { return LHS.Score < RHS.Score; });
	constexpr int32 MaxLabels = 15;
	if (NearEntityDescriptions.Num() > MaxLabels)
	{
		NearEntityDescriptions.RemoveAt(MaxLabels, NearEntityDescriptions.Num() - MaxLabels);
	}
}

void FGameplayDebuggerCategory_ProjectM::DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext)
{
	CanvasContext.Printf(TEXT("\n[{yellow}%s{white}] %s Enemy Target Finder details"), *GetInputHandlerDescription(0), bShowEnemyTargetFinderDetails ? TEXT("Hide") : TEXT("Show"));


	const FDebugEntityData& DebugEntityData = UMassEnemyTargetFinderProcessor_DebugEntityData;
	if (DebugEntityData.IsEntitySearching)
	{
		const FVector2D EntityScreenLocation = CanvasContext.ProjectLocation(DebugEntityData.EntityLocation + FVector(0.f, 0.f, 300.f));
		CanvasContext.PrintAt(EntityScreenLocation.X, EntityScreenLocation.Y, FColor::Purple, 1.f, FString::Printf(TEXT("{purple}Number of close entities: %d"), DebugEntityData.NumCloseEntities));
	}

	struct FEntityLayoutRect
	{
		FVector2D Min = FVector2D::ZeroVector;
		FVector2D Max = FVector2D::ZeroVector;
		int32 Index = INDEX_NONE;
		float Alpha = 1.0f;
	};

	TArray<FEntityLayoutRect> Layout;

	// The loop below is O(N^2), make sure to keep the N small.
	constexpr int32 MaxDesc = 20;
	const int32 NumDescs = FMath::Min(NearEntityDescriptions.Num(), MaxDesc);

	// The labels are assumed to have been ordered in order of importance (i.e. front to back).
	for (int32 Index = 0; Index < NumDescs; Index++)
	{
		const FEntityDescription& Desc = NearEntityDescriptions[Index];
		if (Desc.Description.Len() && CanvasContext.IsLocationVisible(Desc.Location))
		{
			float SizeX = 0, SizeY = 0;
			const FVector2D ScreenLocation = CanvasContext.ProjectLocation(Desc.Location);
			CanvasContext.MeasureString(Desc.Description, SizeX, SizeY);

			FEntityLayoutRect Rect;
			Rect.Min = ScreenLocation + FVector2D(0, -SizeY * 0.5f);
			Rect.Max = Rect.Min + FVector2D(SizeX, SizeY);
			Rect.Index = Index;
			Rect.Alpha = 0.0f;

			// Calculate transparency based on how much more important rects are overlapping the new rect.
			const float Area = FMath::Max(0.0f, Rect.Max.X - Rect.Min.X) * FMath::Max(0.0f, Rect.Max.Y - Rect.Min.Y);
			const float InvArea = Area > KINDA_SMALL_NUMBER ? 1.0f / Area : 0.0f;
			float Coverage = 0.0;

			for (const FEntityLayoutRect& Other : Layout)
			{
				// Calculate rect intersection
				const float MinX = FMath::Max(Rect.Min.X, Other.Min.X);
				const float MinY = FMath::Max(Rect.Min.Y, Other.Min.Y);
				const float MaxX = FMath::Min(Rect.Max.X, Other.Max.X);
				const float MaxY = FMath::Min(Rect.Max.Y, Other.Max.Y);

				// return zero area if not overlapping
				const float IntersectingArea = FMath::Max(0.0f, MaxX - MinX) * FMath::Max(0.0f, MaxY - MinY);
				Coverage += (IntersectingArea * InvArea) * Other.Alpha;
			}

			Rect.Alpha = FMath::Square(1.0f - FMath::Min(Coverage, 1.0f));

			if (Rect.Alpha > KINDA_SMALL_NUMBER)
			{
				Layout.Add(Rect);
			}
		}
	}

	// Render back to front so that the most important item renders at top.
	const FVector2D Padding(5, 5);
	for (int32 Index = Layout.Num() - 1; Index >= 0; Index--)
	{
		const FEntityLayoutRect& Rect = Layout[Index];
		const FEntityDescription& Desc = NearEntityDescriptions[Rect.Index];

		const FVector2D BackgroundPosition(Rect.Min - Padding);
		FCanvasTileItem Background(Rect.Min - Padding, Rect.Max - Rect.Min + Padding * 2.0f, FLinearColor(0.0f, 0.0f, 0.0f, 0.35f * Rect.Alpha));
		Background.BlendMode = SE_BLEND_TranslucentAlphaOnly;
		CanvasContext.DrawItem(Background, BackgroundPosition.X, BackgroundPosition.Y);

		CanvasContext.PrintAt(Rect.Min.X, Rect.Min.Y, FColor::White, Rect.Alpha, Desc.Description);
	}

	FGameplayDebuggerCategory::DrawData(OwnerPC, CanvasContext);
}

TSharedRef<FGameplayDebuggerCategory> FGameplayDebuggerCategory_ProjectM::MakeInstance()
{
  return MakeShareable(new FGameplayDebuggerCategory_ProjectM());
}

#endif // WITH_GAMEPLAY_DEBUGGER
```

`Source/ProjectM/Private/InvalidTargetFinderProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "InvalidTargetFinderProcessor.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "MassTrackTargetProcessor.h"
#include "MassCommonFragments.h"
#include "MassMoveToCommandProcessor.h"
#include "MassSignalSubsystem.h"
#include "MassStateTreeTypes.h"
#include "MassEntityView.h"
#include "MassProjectileDamageProcessor.h"
#include "MassTargetFinderSubsystem.h"
#include <MassNavMeshMoveProcessor.h>

void UnstashMoveTarget(const FMassMoveTargetFragment& Source, FMassMoveTargetFragment& Destination, const UWorld& World, const FMassExecutionContext& Context, FMassNavMeshMoveFragment& NavMeshMoveFragment, const FTransform& EntityTransform)
{
	const bool bIsInNavMeshMove = Context.DoesArchetypeHaveTag<FMassNeedsNavMeshMoveTag>();
	// If entity is in a nav mesh move, add actions to get to the stashed move target instead of just copying since it might be impossible to get to directly.
	if (bIsInNavMeshMove)
	{
		const FVector& EntityLocation = EntityTransform.GetLocation();
		TArray<FNavigationAction>& Actions = NavMeshMoveFragment.ActionList.Get()->Actions;
		const FVector& ForwardToNewMoveTarget = (Source.Center - EntityLocation).GetSafeNormal();
		Actions.Insert(FNavigationAction(EntityLocation, ForwardToNewMoveTarget, EMassMovementAction::Stand), NavMeshMoveFragment.CurrentActionIndex);
		Actions.Insert(FNavigationAction(Source.Center, ForwardToNewMoveTarget, EMassMovementAction::Move), NavMeshMoveFragment.CurrentActionIndex + 1);
		Actions.Insert(FNavigationAction(Source.Center, Source.Forward, EMassMovementAction::Stand), NavMeshMoveFragment.CurrentActionIndex + 2);
		NavMeshMoveFragment.ActionsRemaining += 3;

		Destination.CreateNewAction(EMassMovementAction::Stand, World);
		Destination.Center = EntityLocation;
		Destination.Forward = ForwardToNewMoveTarget;
		Destination.DistanceToGoal = 0.f;
		Destination.bOffBoundaries = true;
		Destination.DesiredSpeed.Set(0.f);
		Destination.IntentAtGoal = EMassMovementAction::Move;
	}
	else
	{
		CopyMoveTarget(Source, Destination, World);
	}
}

void CopyMoveTarget(const FMassMoveTargetFragment& Source, FMassMoveTargetFragment& Destination, const UWorld& World)
{
	Destination.CreateNewAction(Source.GetCurrentAction(), World);
	Destination.bOffBoundaries = Source.bOffBoundaries;
	Destination.Center = Source.Center;
	Destination.Forward = Source.Forward;
	Destination.DistanceToGoal = Source.DistanceToGoal;
	Destination.DesiredSpeed = Source.DesiredSpeed;
	Destination.SlackRadius = Source.SlackRadius;
	Destination.bOffBoundaries = Source.bOffBoundaries;
	Destination.bSteeringFallingBehind = Source.bSteeringFallingBehind;
	Destination.IntentAtGoal = Source.IntentAtGoal;
}

UInvalidTargetFinderProcessor::UInvalidTargetFinderProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::All);
}

void UInvalidTargetFinderProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());
	TargetFinderSubsystem = UWorld::GetSubsystem<UMassTargetFinderSubsystem>(Owner.GetWorld());
}

void UInvalidTargetFinderProcessor::ConfigureQueries()
{
	BuildQueueEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BuildQueueEntityQuery.AddRequirement<FTargetEntityFragment>(EMassFragmentAccess::ReadWrite);
	BuildQueueEntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);
	BuildQueueEntityQuery.AddTagRequirement<FMassWillNeedEnemyTargetTag>(EMassFragmentPresence::All);

	BuildQueueForTrackTargetEntityQuery.AddRequirement<FTargetEntityFragment>(EMassFragmentAccess::ReadWrite);
	BuildQueueForTrackTargetEntityQuery.AddTagRequirement<FMassTrackTargetTag>(EMassFragmentPresence::All);

	InvalidateTargetsEntityQuery.AddRequirement<FTargetEntityFragment>(EMassFragmentAccess::ReadWrite);
	InvalidateTargetsEntityQuery.AddRequirement<FMassStashedMoveTargetFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	InvalidateTargetsEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite, EMassFragmentPresence::Optional);
	InvalidateTargetsEntityQuery.AddRequirement<FMassNavMeshMoveFragment>(EMassFragmentAccess::ReadWrite);
	InvalidateTargetsEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
}

bool IsTargetEntityOutOfRange(const FVector& TargetEntityLocation, const FVector &EntityLocation, const UMassEntitySubsystem& EntitySubsystem, const FMassEntityHandle Entity, const bool bIsEntitySoldier)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.IsTargetEntityOutOfRange);

	const double& DistanceBetweenEntities = (TargetEntityLocation - EntityLocation).Size();

	const float MaxRange = GetEntityRange(bIsEntitySoldier);

#if WITH_MASSGAMEPLAY_DEBUG
	if (UE::Mass::Debug::IsDebuggingEntity(Entity))
	{
		AsyncTask(ENamedThreads::GameThread, [World = EntitySubsystem.GetWorld(), EntityLocation, TargetEntityLocation]()
		{
			DrawDebugDirectionalArrow(World, EntityLocation, TargetEntityLocation, 10.f, FColor::Yellow, false, 0.1f);
		});
	}
#endif

	return DistanceBetweenEntities > MaxRange;
}

bool DidCapsulesCollide(const FCapsule& Capsule1, const FCapsule& Capsule2, const FMassEntityHandle& Entity, const UWorld& World)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(DidCapsulesCollide);
	return TestCapsuleCapsule(Capsule1, Capsule2);
}

bool IsTargetEntityObstructed(const FVector& EntityLocation, const FVector& TargetEntityLocation, const UMassTargetFinderSubsystem& TargetFinderSubsystem, const FMassEntityHandle& Entity, const UMassEntitySubsystem& EntitySubsystem, const bool& IsEntityOnTeam1, const bool bIsEntitySoldier, const float TargetMinCaliberForDamage, const FMassEntityView& TargetEntityView, const FTransform& EntityTransform)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.IsTargetEntityObstructed);

	const FVector Buffer(10.f, 10.f, 10.f); // We keep a buffer in case EntityLocation and TargetEntityLocation are same value on any axis.
	FBox QueryBounds(EntityLocation.ComponentMin(TargetEntityLocation) - Buffer, EntityLocation.ComponentMax(TargetEntityLocation) + Buffer);
	TArray<FMassTargetGridItem> CloseEntities;
	TargetFinderSubsystem.GetTargetGrid().Query(QueryBounds, CloseEntities);

#if WITH_MASSGAMEPLAY_DEBUG
	if (UE::Mass::Debug::IsDebuggingEntity(Entity))
	{
		AsyncTask(ENamedThreads::GameThread, [QueryBounds, World = EntitySubsystem.GetWorld()]()
		{
			const FVector QueryCenter = (QueryBounds.Min + QueryBounds.Max) / 2.f;
			const FVector VerticalOffset(0.f, 0.f, 1000.f);
			DrawDebugBox(World, QueryCenter, QueryBounds.Max - QueryCenter + VerticalOffset, FColor::Blue, false, 0.1f);
		});
	}
#endif

	const bool& bIsTargetEntitySoldier = TargetEntityView.HasTag<FMassProjectileDamagableSoldierTag>();
	const FCapsule& ProjectileTraceCapsule = GetProjectileTraceCapsuleToTarget(bIsEntitySoldier, bIsTargetEntitySoldier, EntityTransform, TargetEntityLocation);

	for (const FMassTargetGridItem& OtherEntity : CloseEntities)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.IsTargetEntityObstructed.ProcessCloseEntity);

		// Skip self.
		if (OtherEntity.Entity == Entity)
		{
			continue;
		}

		// Skip invalid entities.
		if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
		{
			continue;
		}

		// If same team or undamageable, check for collision.
		if (IsEntityOnTeam1 == OtherEntity.bIsOnTeam1 || !CanEntityDamageTargetEntity(TargetMinCaliberForDamage, OtherEntity.MinCaliberForDamage)) {
			const FCapsule& OtherEntityCapsule = TargetFinderSubsystem.GetTargetDynamicData()[OtherEntity.Entity].Capsule;
			if (DidCapsulesCollide(ProjectileTraceCapsule, OtherEntityCapsule, Entity, *EntitySubsystem.GetWorld()))
			{
				return true;
			}
		}
	}

	bool bIsTargetEntityVisibleViaSphereTrace;
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.IsTargetEntityObstructed.IsTargetEntityVisibleViaSphereTrace);
		bIsTargetEntityVisibleViaSphereTrace = IsTargetEntityVisibleViaSphereTrace(*EntitySubsystem.GetWorld(), ProjectileTraceCapsule.a, ProjectileTraceCapsule.b, false);
	}
	return !bIsTargetEntityVisibleViaSphereTrace;
}

bool UInvalidTargetFinderProcessor_ShouldInvalidateAllTargets = false;

static void InvalidateAllTargets()
{
	UInvalidTargetFinderProcessor_ShouldInvalidateAllTargets = true;
}

static FAutoConsoleCommand InvalidateAllTargetsCmd(
	TEXT("pm.InvalidateAllTargets"),
	TEXT("InvalidateAllTargets"),
	FConsoleCommandDelegate::CreateStatic(InvalidateAllTargets)
);

bool IsTargetValid(const FMassEntityHandle& Entity, const FMassEntityHandle& TargetEntity, const UMassEntitySubsystem& EntitySubsystem, const float TargetMinCaliberForDamage, const UMassTargetFinderSubsystem& TargetFinderSubsystem, const bool& IsEntityOnTeam1, const bool bIsEntitySoldier, const FTransform& EntityTransform, const bool bInvalidateAllTargets, const bool bOnlyCheckIfTargetEntityValidInEntitySubsystem, const bool bIsSoldierDying)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.IsTargetValid);

	const FVector& EntityLocation = EntityTransform.GetLocation();

	if (bInvalidateAllTargets)
	{
		return false;
	}

	if (!EntitySubsystem.IsEntityValid(TargetEntity))
	{
		return false;
	}

	if (bOnlyCheckIfTargetEntityValidInEntitySubsystem)
	{
		return true;
	}

	if (bIsSoldierDying)
	{
		return false;
	}

	const FMassEntityView TargetEntityView(EntitySubsystem, TargetEntity);
	if (TargetEntityView.HasTag<FMassSoldierIsDyingTag>())
	{
		return false;
	}

	const FVector& TargetEntityLocation = TargetEntityView.GetFragmentData<FTransformFragment>().GetTransform().GetLocation();
	if (IsTargetEntityOutOfRange(TargetEntityLocation, EntityLocation, EntitySubsystem, Entity, bIsEntitySoldier))
	{
		return false;
	}

	if (IsTargetEntityObstructed(EntityLocation, TargetEntityLocation, TargetFinderSubsystem, Entity, EntitySubsystem, IsEntityOnTeam1, bIsEntitySoldier, TargetMinCaliberForDamage, TargetEntityView, EntityTransform))
	{
		return false;
	}

	return true;
}

struct FProcessEntityData
{
	FMassEntityHandle Entity;
	FMassEntityHandle TargetEntity;
	float TargetMinCaliberForDamage;
	FTransform EntityTransform;
	bool bIsEntityOnTeam1;
	bool bIsEntitySoldier;
	bool bIsSoldierDying;
	bool bOnlyCheckIfTargetEntityValidInEntitySubsystem = false;
};

/** Returns true if entity has invalid target. */
bool ProcessEntity(const FProcessEntityData& ProcessEntityData, const bool bInvalidateAllTargets, const UMassEntitySubsystem& EntitySubsystem, const UMassTargetFinderSubsystem& TargetFinderSubsystem, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& EntitiesWithInvalidTargetQueue)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.ProcessEntity);

	const FMassEntityHandle& TargetEntity = ProcessEntityData.TargetEntity;
	if (!IsTargetValid(ProcessEntityData.Entity, TargetEntity, EntitySubsystem, ProcessEntityData.TargetMinCaliberForDamage, TargetFinderSubsystem, ProcessEntityData.bIsEntityOnTeam1, ProcessEntityData.bIsEntitySoldier, ProcessEntityData.EntityTransform, bInvalidateAllTargets, ProcessEntityData.bOnlyCheckIfTargetEntityValidInEntitySubsystem, ProcessEntityData.bIsSoldierDying))
	{
		EntitiesWithInvalidTargetQueue.Enqueue(ProcessEntityData.Entity);
		return true;
	}
	return false;
}

void UInvalidTargetFinderProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute);

	if (!TargetFinderSubsystem)
	{
		return;
	}

	TQueue<FProcessEntityData, EQueueMode::Mpsc> EntitiesToCheckQueue;
	std::atomic<int32> TotalNumEntities = 0;

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.BuildQueue);

		BuildQueueEntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [&EntitiesToCheckQueue, &TotalNumEntities](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();

			const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
			const TArrayView<FTargetEntityFragment> TargetEntityList = Context.GetMutableFragmentView<FTargetEntityFragment>();
			const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();

			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				FProcessEntityData ProcessEntityData;
				ProcessEntityData.Entity = Context.GetEntity(EntityIndex);
				ProcessEntityData.TargetEntity = TargetEntityList[EntityIndex].Entity;
				ProcessEntityData.TargetMinCaliberForDamage = TargetEntityList[EntityIndex].TargetMinCaliberForDamage;
				ProcessEntityData.EntityTransform = TransformList[EntityIndex].GetTransform();
				ProcessEntityData.bIsEntityOnTeam1 = TeamMemberList[EntityIndex].IsOnTeam1;
				ProcessEntityData.bIsEntitySoldier = Context.DoesArchetypeHaveTag<FMassProjectileDamagableSoldierTag>();
				ProcessEntityData.bIsSoldierDying = Context.DoesArchetypeHaveTag<FMassSoldierIsDyingTag>();
				EntitiesToCheckQueue.Enqueue(ProcessEntityData);
				TotalNumEntities++;
			}
		});
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.BuildQueueForTrackTarget);

		BuildQueueForTrackTargetEntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [&EntitiesToCheckQueue, &TotalNumEntities](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();

			const TArrayView<FTargetEntityFragment> TargetEntityList = Context.GetMutableFragmentView<FTargetEntityFragment>();

			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				FProcessEntityData ProcessEntityData;
				ProcessEntityData.Entity = Context.GetEntity(EntityIndex);
				ProcessEntityData.TargetEntity = TargetEntityList[EntityIndex].Entity;
				ProcessEntityData.bOnlyCheckIfTargetEntityValidInEntitySubsystem = true;
				EntitiesToCheckQueue.Enqueue(ProcessEntityData);
				TotalNumEntities++;
			}
		});
	}

	TArray<FProcessEntityData> EntitiesToCheck;
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.ConvertQueueToArray);

		EntitiesToCheck.Reserve(TotalNumEntities);
		while (!EntitiesToCheckQueue.IsEmpty())
		{
			FProcessEntityData ProcessEntityData;
			const bool bSuccess = EntitiesToCheckQueue.Dequeue(ProcessEntityData);
			check(bSuccess);
			EntitiesToCheck.Add(ProcessEntityData);
		}
	}

	TQueue<FMassEntityHandle, EQueueMode::Mpsc> EntitiesWithInvalidTargetQueue;
	std::atomic<int32> NumEntitiesWithInvalidTarget = 0;

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.ProcessEntities);

		const bool bInvalidateAllTargets = UInvalidTargetFinderProcessor_ShouldInvalidateAllTargets;

		ParallelFor(EntitiesToCheck.Num(), [&](const int32 JobIndex)
		{
			if (ProcessEntity(EntitiesToCheck[JobIndex], bInvalidateAllTargets, EntitySubsystem, *TargetFinderSubsystem.Get(), EntitiesWithInvalidTargetQueue))
			{
				NumEntitiesWithInvalidTarget++;
			}
		});
	}

	TSet<FMassEntityHandle> EntitiesWithInvalidTargets;
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.BuildInvalidTargetsSet);

		EntitiesWithInvalidTargets.Reserve(NumEntitiesWithInvalidTarget);
		while (!EntitiesWithInvalidTargetQueue.IsEmpty())
		{
			FMassEntityHandle Entity;
			const bool bSuccess = EntitiesWithInvalidTargetQueue.Dequeue(Entity);
			check(bSuccess);
			EntitiesWithInvalidTargets.Add(Entity);
		}
	}

	TQueue<FMassEntityHandle, EQueueMode::Mpsc> EntitiesWithUnstashedMoveTargetQueue;

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.ProcessInvalidTargets);

		const UWorld& World = *EntitySubsystem.GetWorld();
		InvalidateTargetsEntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [&World, &EntitiesWithInvalidTargets, &EntitiesWithUnstashedMoveTargetQueue](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();

			const TArrayView<FTargetEntityFragment> TargetEntityList = Context.GetMutableFragmentView<FTargetEntityFragment>();
			const TConstArrayView<FMassStashedMoveTargetFragment> StashedMoveTargetList = Context.GetFragmentView<FMassStashedMoveTargetFragment>();
			const TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();
			const TArrayView<FMassNavMeshMoveFragment> NavMeshMoveList = Context.GetMutableFragmentView<FMassNavMeshMoveFragment>();
			const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();

			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				const FMassEntityHandle& Entity = Context.GetEntity(EntityIndex);
				const bool bIsInvalid = EntitiesWithInvalidTargets.Contains(Entity);
				if (bIsInvalid)
				{
					TargetEntityList[EntityIndex].Entity.Reset();
					const FMassStashedMoveTargetFragment* StashedMoveTargetFragment = StashedMoveTargetList.Num() > 0 ? &StashedMoveTargetList[EntityIndex] : nullptr;
					FMassMoveTargetFragment* MoveTargetFragment = MoveTargetList.Num() > 0 ? &MoveTargetList[EntityIndex] : nullptr;
					if (Context.DoesArchetypeHaveTag<FMassHasStashedMoveTargetTag>() && StashedMoveTargetFragment && MoveTargetFragment)
					{
						UnstashMoveTarget(*StashedMoveTargetFragment, *MoveTargetFragment, World, Context, NavMeshMoveList[EntityIndex], TransformList[EntityIndex].GetTransform());
						EntitiesWithUnstashedMoveTargetQueue.Enqueue(Entity);
					}
				}
			}
		});
	}


	UInvalidTargetFinderProcessor_ShouldInvalidateAllTargets = false;

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UInvalidTargetFinderProcessor.Execute.ProcessQueues);

		TransientEntitiesToSignal.Reset();

		for (const FMassEntityHandle& Entity : EntitiesWithInvalidTargets)
		{
			Context.Defer().AddTag<FMassNeedsEnemyTargetTag>(Entity);
			Context.Defer().RemoveTag<FMassWillNeedEnemyTargetTag>(Entity);
			Context.Defer().RemoveTag<FMassTrackTargetTag>(Entity);
			TransientEntitiesToSignal.Add(Entity);
		}

		while (!EntitiesWithUnstashedMoveTargetQueue.IsEmpty())
		{
			FMassEntityHandle Entity;
			const bool bSuccess = EntitiesWithUnstashedMoveTargetQueue.Dequeue(Entity);
			check(bSuccess);

			Context.Defer().RemoveTag<FMassHasStashedMoveTargetTag>(Entity);
		}

		if (TransientEntitiesToSignal.Num())
		{
			SignalSubsystem->SignalEntities(UE::Mass::Signals::NewStateTreeTaskRequired, TransientEntitiesToSignal);
		}
	}
}

```

`Source/ProjectM/Private/MassAgentLocationSyncTrait.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassAgentLocationSyncTrait.h"

#include "MassVisualizer.h"
#include "Components/InstancedStaticMeshComponent.h"
#include "MassSimulationSubsystem.h"
#include "MassCommonFragments.h"
#include "MassEntityTemplateRegistry.h"
#include "MassActorSubsystem.h"
#include "MassSimpleUpdateISMProcessor.h"

//----------------------------------------------------------------------//
//  UMassProjectileTrait
//----------------------------------------------------------------------//
void UMassProjectileTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddTag<FMassProjectileTag>();
}

//----------------------------------------------------------------------//
//  UMassProjectileUpdateCollisionTrait
//----------------------------------------------------------------------//
void UMassProjectileUpdateCollisionTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddTag<FMassProjectileUpdateCollisionTag>();
}

//----------------------------------------------------------------------//
//  UMassAgentLocationSyncTrait
//----------------------------------------------------------------------//
void UMassAgentLocationSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddFragment<FTransformFragment>();

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass))
	{
		// TODO
	}

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor))
	{
		BuildContext.AddTranslator<ULocationToActorTranslator>();
	}
}

//----------------------------------------------------------------------//
//  ULocationToActorTranslator
//----------------------------------------------------------------------//
ULocationToActorTranslator::ULocationToActorTranslator()
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
	RequiredTags.Add<FMassLocationCopyToActorTag>();
}

void ULocationToActorTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
}

void ULocationToActorTranslator::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this](FMassExecutionContext& Context)
		{
			const TArrayView<FMassActorFragment> ActorList = Context.GetMutableFragmentView<FMassActorFragment>();
			const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();

			const int32 NumEntities = Context.GetNumEntities();

			for (int32 EntityIdx = 0; EntityIdx < NumEntities; ++EntityIdx)
			{
				FMassActorFragment& ActorInfo = ActorList[EntityIdx];
				const FTransformFragment& TransformFragment = TransformList[EntityIdx];
				AActor* Actor = ActorInfo.GetMutable();
				if (Actor) {
					Actor->SetActorLocation(TransformFragment.GetTransform().GetLocation());
				}
			}
		});
}

//----------------------------------------------------------------------//
//  UMassProjectileUpdateISMCollisionsProcessor
//----------------------------------------------------------------------//
UMassProjectileUpdateISMCollisionsProcessor::UMassProjectileUpdateISMCollisionsProcessor()
{
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Tasks);
}

void UMassProjectileUpdateISMCollisionsProcessor::ConfigureQueries()
{
	Super::ConfigureQueries();

	EntityQuery.AddTagRequirement<FMassProjectileUpdateCollisionTag>(EMassFragmentPresence::All);
}

void UMassProjectileUpdateISMCollisionsProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	AMassVisualizer* Visualizer = nullptr;

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [&Visualizer](FMassExecutionContext& Context)
	{
		if (Visualizer)
		{
			return;
		}

		UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
		check(RepresentationSubsystem);
		FMassInstancedStaticMeshInfoArrayView ISMInfo = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();

		if (UMassProjectileRepresentationSubsystem* ProjectileRepresentationSubsystem = dynamic_cast<UMassProjectileRepresentationSubsystem*>(RepresentationSubsystem))
		{
			Visualizer = ProjectileRepresentationSubsystem->GetVisualizer();
		}
	});

	if (Visualizer)
	{
		const TArray<USceneComponent*>& childComponents = Visualizer->GetRootComponent()->GetAttachChildren();
		for (USceneComponent* component : childComponents)
		{
			UInstancedStaticMeshComponent* ismComponent = static_cast<UInstancedStaticMeshComponent*>(component);

			// Workaround issue with ISMs transformed with UpdateInstances where collisions only update by disabling and enabling collision
			ismComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);
			ismComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
		}
	}
}

//----------------------------------------------------------------------//
//  UMassProjectileRepresentationSubsystem
//----------------------------------------------------------------------//
AMassVisualizer* UMassProjectileRepresentationSubsystem::GetVisualizer()
{
	return Visualizer;
}

void UMassProjectileRepresentationSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	if (UWorld* World = GetWorld())
	{
		UMassSimulationSubsystem* SimSystem = World->GetSubsystem<UMassSimulationSubsystem>();
		check(SimSystem);
		SimSystem->GetOnProcessingPhaseStarted(EMassProcessingPhase::PrePhysics).AddUObject(this, &UMassProjectileRepresentationSubsystem::OnPrePhysicsProcessingPhaseStarted, EMassProcessingPhase::PrePhysics);
	}
}

void UMassProjectileRepresentationSubsystem::OnPrePhysicsProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase)
{
	if (!bNeedUpdateCollisions) {
		return;
	}

	const TArray<USceneComponent*>& childComponents = Visualizer->GetRootComponent()->GetAttachChildren();
	for (USceneComponent* component : childComponents)
	{
		bNeedUpdateCollisions = false;
		UInstancedStaticMeshComponent* ismComponent = static_cast<UInstancedStaticMeshComponent*>(component);
		ismComponent->SetCollisionProfileName(TEXT("OverlapAll"));
		ismComponent->SetGenerateOverlapEvents(true);
	}
}

//----------------------------------------------------------------------//
//  UMassProjectileVisualizationTrait
//----------------------------------------------------------------------//
UMassProjectileVisualizationTrait::UMassProjectileVisualizationTrait()
{
	Params.LODRepresentation[EMassLOD::High] = EMassRepresentationType::StaticMeshInstance;
	Params.LODRepresentation[EMassLOD::Medium] = EMassRepresentationType::StaticMeshInstance;
	Params.LODRepresentation[EMassLOD::Low] = EMassRepresentationType::StaticMeshInstance;
	Params.LODRepresentation[EMassLOD::Off] = EMassRepresentationType::StaticMeshInstance;
	Params.bKeepLowResActors = false;
	Params.bKeepActorExtraFrame = false;
	Params.bSpreadFirstVisualizationUpdate = false;
	Params.WorldPartitionGridNameContainingCollision = NAME_None;
	Params.NotVisibleUpdateRate = 0.5f;

	LODParams.BaseLODDistance[EMassLOD::High] = 0.f;
	LODParams.BaseLODDistance[EMassLOD::Medium] = 0.f;
	LODParams.BaseLODDistance[EMassLOD::Low] = 3000.f;
	LODParams.BaseLODDistance[EMassLOD::Off] = 6000.f;

	LODParams.VisibleLODDistance[EMassLOD::High] = 0.f;
	LODParams.VisibleLODDistance[EMassLOD::Medium] = 0.f;
	LODParams.VisibleLODDistance[EMassLOD::Low] = 6000.f;
	LODParams.VisibleLODDistance[EMassLOD::Off] = 50000.f;

	LODParams.LODMaxCount[EMassLOD::High] = 10;
	LODParams.LODMaxCount[EMassLOD::Medium] = 20;
	LODParams.LODMaxCount[EMassLOD::Low] = 500;
	LODParams.LODMaxCount[EMassLOD::Off] = TNumericLimits<int32>::Max();

	LODParams.BufferHysteresisOnDistancePercentage = 20.0f;
	LODParams.DistanceToFrustum = 0.0f;
	LODParams.DistanceToFrustumHysteresis = 0.0f;

	LODParams.FilterTag = FMassProjectileVisualizationTag::StaticStruct();
}

void UMassProjectileVisualizationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	Super::BuildTemplate(BuildContext, World);
	BuildContext.AddTag<FMassProjectileVisualizationTag>();
	BuildContext.AddTag<FMassSimpleUpdateISMTag>();
}

//----------------------------------------------------------------------//
// UMassProjectileVisualizationProcessor
//----------------------------------------------------------------------//
UMassProjectileVisualizationProcessor::UMassProjectileVisualizationProcessor()
{
	ExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);

	bAutoRegisterWithProcessingPhases = true;

	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);

	bRequiresGameThreadExecution = true;
}

void UMassProjectileVisualizationProcessor::ConfigureQueries()
{
	Super::ConfigureQueries();
	EntityQuery.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
}

//----------------------------------------------------------------------//
// UMassProjectileVisualizationLODProcessor
//----------------------------------------------------------------------//
UMassProjectileVisualizationLODProcessor::UMassProjectileVisualizationLODProcessor()
{
	bAutoRegisterWithProcessingPhases = true;

	ExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);

	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LODCollector);
}

void UMassProjectileVisualizationLODProcessor::ConfigureQueries()
{
	Super::ConfigureQueries();

	CloseEntityQuery.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
	CloseEntityAdjustDistanceQuery.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
	FarEntityQuery.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
	DebugEntityQuery.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);

	FilterTag = FMassProjectileVisualizationTag::StaticStruct();
}

void UMassProjectileVisualizationLODProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(TEXT("ProjectileVisualizationLOD"))

	Super::Execute(EntitySubsystem, Context);
}

//----------------------------------------------------------------------//
// UMassProjectileLODCollectorProcessor
//----------------------------------------------------------------------//
UMassProjectileLODCollectorProcessor::UMassProjectileLODCollectorProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
}

void UMassProjectileLODCollectorProcessor::ConfigureQueries()
{
	Super::ConfigureQueries();

	EntityQuery_VisibleRangeAndOnLOD.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
	EntityQuery_VisibleRangeOnly.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
	EntityQuery_OnLODOnly.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
	EntityQuery_NotVisibleRangeAndOffLOD.AddTagRequirement<FMassProjectileVisualizationTag>(EMassFragmentPresence::All);
}

```

`Source/ProjectM/Private/MassAgentOrientNoCharSyncTrait.cpp`:

```cpp
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.


#include "MassAgentOrientNoCharSyncTrait.h"
#include "Translators/MassSceneComponentLocationTranslator.h"
#include "MassCommonTypes.h"
#include "Components/SceneComponent.h"
#include "MassEntitySubsystem.h"
#include "MassEntityTemplateRegistry.h"

//----------------------------------------------------------------------//
//  UMassAgentOrientNoCharSyncTrait
//----------------------------------------------------------------------//
void UMassAgentOrientNoCharSyncTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddFragment<FMassSceneComponentWrapperFragment>();
	BuildContext.AddFragment<FTransformFragment>();

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::ActorToMass))
	{
		BuildContext.AddTranslator<UMassSceneComponentOrientationToMassTranslator>();
	}

	if (EnumHasAnyFlags(SyncDirection, EMassTranslationDirection::MassToActor))
	{
		BuildContext.AddTranslator<UMassSceneComponentOrientationToActorTranslator>();
	}
}

//----------------------------------------------------------------------//
//  UMassSceneComponentOrientationToMassTranslator
//----------------------------------------------------------------------//
UMassSceneComponentOrientationToMassTranslator::UMassSceneComponentOrientationToMassTranslator()
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorldToMass;
	RequiredTags.Add<FMassSceneComponentOrientationCopyToMassTag>();
}

void UMassSceneComponentOrientationToMassTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FMassSceneComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassSceneComponentOrientationToMassTranslator::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this](FMassExecutionContext& Context)
		{
			const TConstArrayView<FMassSceneComponentWrapperFragment> ComponentList = Context.GetFragmentView<FMassSceneComponentWrapperFragment>();
			const TArrayView<FTransformFragment> TransformList = Context.GetMutableFragmentView<FTransformFragment>();

			const int32 NumEntities = Context.GetNumEntities();
			for (int32 i = 0; i < NumEntities; ++i)
			{
				if (const USceneComponent* AsComponent = ComponentList[i].Component.Get())
				{
					TransformList[i].GetMutableTransform().SetRotation(AsComponent->GetComponentTransform().GetRotation());
				}
			}
		});
}

//----------------------------------------------------------------------//
//  UMassSceneComponentOrientationToActorTranslator
//----------------------------------------------------------------------//
UMassSceneComponentOrientationToActorTranslator::UMassSceneComponentOrientationToActorTranslator()
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::UpdateWorldFromMass;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
	RequiredTags.Add<FMassSceneComponentOrientationCopyToActorTag>();
	bRequiresGameThreadExecution = true;
}

void UMassSceneComponentOrientationToActorTranslator::ConfigureQueries()
{
	AddRequiredTagsToQuery(EntityQuery);
	EntityQuery.AddRequirement<FMassSceneComponentWrapperFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassSceneComponentOrientationToActorTranslator::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this](FMassExecutionContext& Context)
		{
			const TConstArrayView<FMassSceneComponentWrapperFragment> ComponentList = Context.GetFragmentView<FMassSceneComponentWrapperFragment>();
			const TArrayView<FTransformFragment> TransformList = Context.GetMutableFragmentView<FTransformFragment>();

			const int32 NumEntities = Context.GetNumEntities();
			for (int32 i = 0; i < NumEntities; ++i)
			{
				if (USceneComponent* AsComponent = ComponentList[i].Component.Get())
				{
					AsComponent->SetWorldRotation(TransformList[i].GetTransform().GetRotation());
				}
			}
		});
}
```

`Source/ProjectM/Private/MassAgentRadiusTrait.cpp`:

```cpp
#include "MassAgentRadiusTrait.h"

#include "MassCommonFragments.h"

void UMassAgentRadiusTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	FAgentRadiusFragment& AgentRadiusFragment = BuildContext.AddFragment_GetRef<FAgentRadiusFragment>();
	AgentRadiusFragment.Radius = Radius;
}

```

`Source/ProjectM/Private/MassAudioPerceptionProcessor.cpp`:

```cpp
#include "MassAudioPerceptionProcessor.h"

#include "MassEnemyTargetFinderProcessor.h"
#include "MassLookAtViaMoveTargetTask.h"
#include "MassMoveTargetForwardCompleteProcessor.h"
#include "MassMoveToCommandProcessor.h"
#include "MassProjectileDamageProcessor.h"
#include "MassRepresentationTypes.h"
#include "MassTrackedVehicleOrientationProcessor.h"
#include "Containers/BinaryHeap.h"

UMassAudioPerceptionProcessor::UMassAudioPerceptionProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::All);
	ProcessingPhase = EMassProcessingPhase::StartPhysics; // TODO: Find a better way to ensure this runs after UMassEnemyTargetFinderProcessor
}

void UMassAudioPerceptionProcessor::Initialize(UObject& Owner)
{
	SoundPerceptionSubsystem = UWorld::GetSubsystem<UMassSoundPerceptionSubsystem>(Owner.GetWorld());
}

void UMassAudioPerceptionProcessor::ConfigureQueries()
{
	PreLineTracesEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	PreLineTracesEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);
	PreLineTracesEntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);
	PreLineTracesEntityQuery.AddTagRequirement<FMassNeedsEnemyTargetTag>(EMassFragmentPresence::All);
	PreLineTracesEntityQuery.AddTagRequirement<FMassTrackSoundTag>(EMassFragmentPresence::None);

	PostLineTracesEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	PostLineTracesEntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);
	PostLineTracesEntityQuery.AddRequirement<FMassStashedMoveTargetFragment>(EMassFragmentAccess::ReadWrite);
	PostLineTracesEntityQuery.AddRequirement<FMassMoveForwardCompleteSignalFragment>(EMassFragmentAccess::ReadWrite);
	PostLineTracesEntityQuery.AddTagRequirement<FMassNeedsEnemyTargetTag>(EMassFragmentPresence::All);
	PostLineTracesEntityQuery.AddTagRequirement<FMassTrackSoundTag>(EMassFragmentPresence::None);
}

void EnqueueClosestSoundToTraceQueue(TArray<FVector>& CloseSounds, TQueue<FSoundTraceData, EQueueMode::Mpsc>& SoundTraceQueue, const FVector& EntityLocation, const bool bIsEntitySoldier, const FMassEntityHandle& Entity)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(EnqueueClosestSoundToTraceQueue);

	check(CloseSounds.Num() > 0);
	const FVector TraceStart = EntityLocation + FVector(0.f, 0.f, UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationZOffset(bIsEntitySoldier));
	int32 MinIndex = -1;

  {
		TRACE_CPUPROFILER_EVENT_SCOPE(EnqueueClosestSoundToTraceQueue.FindMin);

		auto DistanceSqToLocation = [&TraceStart](const FVector& SoundSource) {
			return (SoundSource - TraceStart).SizeSquared();
		};

		int32 i = 0;
		float MinDistanceSq = BIG_NUMBER;
		for (const FVector& SoundSource : CloseSounds)
		{
			const float& DistanceSq = DistanceSqToLocation(SoundSource);
			if (DistanceSq < MinDistanceSq)
			{
				MinIndex = i;
				MinDistanceSq = DistanceSq;
			}
			i++;
		}
		check(MinIndex != -1);
	}

  {
		TRACE_CPUPROFILER_EVENT_SCOPE(EnqueueClosestSoundToTraceQueue.Enqueue);
		SoundTraceQueue.Enqueue(FSoundTraceData(Entity, TraceStart, CloseSounds[MinIndex]));
  }
}

void ProcessEntityForAudioTarget(UMassSoundPerceptionSubsystem* SoundPerceptionSubsystem, const FTransform& EntityTransform, const FMassMoveTargetFragment& MoveTargetFragment, const bool& bIsEntityOnTeam1, const FMassEntityHandle& Entity, const bool bIsEntitySoldier, TQueue<FSoundTraceData, EQueueMode::Mpsc>& SoundTraceQueue)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.ProcessEntityForAudioTarget);

	const FVector& EntityLocation = EntityTransform.GetLocation();
	const bool& bIsFacingMoveTarget = IsTransformFacingDirection(EntityTransform, MoveTargetFragment.Forward);
	if (!bIsFacingMoveTarget)
	{
		return;
	}
	TArray<FVector> CloseSounds;
	if (SoundPerceptionSubsystem->GetSoundsNearLocation(EntityLocation, CloseSounds, !bIsEntityOnTeam1))
	{
		EnqueueClosestSoundToTraceQueue(CloseSounds, SoundTraceQueue, EntityLocation, bIsEntitySoldier, Entity);
	}
}

struct FSoundTraceResult
{
	FMassEntityHandle Entity;
	FVector BestSoundLocation;
	FSoundTraceResult(const FMassEntityHandle& Entity, const FVector& BestSoundLocation)
		: Entity(Entity), BestSoundLocation(BestSoundLocation)
	{
	}
	FSoundTraceResult() = default;
};

void DoLineTraces(TQueue<FSoundTraceData, EQueueMode::Mpsc>& SoundTraceQueue, const UWorld& World, TMap<FMassEntityHandle, FVector>& OutEntityToBestSoundLocation)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.DoLineTraces);

	TArray<FSoundTraceData> SoundTraces;
  {
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.DoLineTraces.BuildArray);
		while (!SoundTraceQueue.IsEmpty())
    {
      FSoundTraceData SoundTraceData;
      const bool bSuccess = SoundTraceQueue.Dequeue(SoundTraceData);
      check(bSuccess);
      SoundTraces.Add(SoundTraceData);
    }
  }

	TQueue<FSoundTraceResult, EQueueMode::Mpsc> BestSoundLocations;

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.ParallelFor);
		ParallelFor(SoundTraces.Num(), [&](const int32 JobIndex)
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.ParallelForBody);

			const FSoundTraceData& SoundTrace = SoundTraces[JobIndex];

			bool bHasBlockingHit;
			{
				TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.DoLineTraces.LineTraceTestByChannel);
				const FCollisionQueryParams CollisionQueryParams(SCENE_QUERY_STAT(DefaultQueryParam), false);
				bHasBlockingHit = World.LineTraceTestByChannel(SoundTrace.TraceStart, SoundTrace.TraceEnd, ECollisionChannel::ECC_Visibility, CollisionQueryParams);
			}
			if (!bHasBlockingHit)
			{
				BestSoundLocations.Enqueue(FSoundTraceResult(SoundTrace.Entity, SoundTrace.TraceEnd));
			}
		});
	}

	while (!BestSoundLocations.IsEmpty())
	{
		FSoundTraceResult SoundTraceResult;
		const bool bSuccess = BestSoundLocations.Dequeue(SoundTraceResult);
		check(bSuccess);
		OutEntityToBestSoundLocation.Add(SoundTraceResult.Entity, SoundTraceResult.BestSoundLocation);
	}
}

void PostLineTracesProcessEntity(const FVector& BestSoundLocation, FMassMoveTargetFragment& MoveTargetFragment, FMassStashedMoveTargetFragment& StashedMoveTargetFragment, const UWorld& World, const UMassEntitySubsystem& EntitySubsystem, const FMassEntityHandle& Entity, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& TrackingSoundWhileNavigatingQueue, FMassMoveForwardCompleteSignalFragment& MoveForwardCompleteSignalFragment, const FVector& EntityLocation, const FMassExecutionContext& Context)
{
	const bool bDidStashCurrentMoveTarget = StashCurrentMoveTargetIfNeeded(MoveTargetFragment, StashedMoveTargetFragment, World, EntitySubsystem, Entity, Context, false);
	if (bDidStashCurrentMoveTarget)
	{
		TrackingSoundWhileNavigatingQueue.Enqueue(Entity);
		MoveForwardCompleteSignalFragment.SignalType = EMassMoveForwardCompleteSignalType::TrackSoundComplete;
	}

	const FVector& NewGlobalDirection = (BestSoundLocation - EntityLocation).GetSafeNormal();
	MoveTargetFragment.CreateNewAction(EMassMovementAction::Stand, World);
	MoveTargetFragment.Center = EntityLocation;
	MoveTargetFragment.Forward = NewGlobalDirection;
	MoveTargetFragment.DistanceToGoal = 0.f;
	MoveTargetFragment.bOffBoundaries = true;
	MoveTargetFragment.DesiredSpeed.Set(0.f);
	MoveTargetFragment.IntentAtGoal = bDidStashCurrentMoveTarget ? EMassMovementAction::Move : EMassMovementAction::Stand;
}

void UMassAudioPerceptionProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor);

	if (UMassEnemyTargetFinderProcessor_SkipFindingTargets)
	{
		return;
	}

	TQueue<FSoundTraceData, EQueueMode::Mpsc> SoundTraceQueue;

  {
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.Execute.PreLineTracesEntityQuery.ParallelForEachEntityChunk);
		PreLineTracesEntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [&SoundPerceptionSubsystem = SoundPerceptionSubsystem, &SoundTraceQueue = SoundTraceQueue](const FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();

			const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();
			const TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();

			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				const FMassEntityHandle& Entity = Context.GetEntity(EntityIndex);
				const bool& bIsEntitySoldier = Context.DoesArchetypeHaveTag<FMassProjectileDamagableSoldierTag>();
				ProcessEntityForAudioTarget(SoundPerceptionSubsystem, LocationList[EntityIndex].GetTransform(), MoveTargetList[EntityIndex], TeamMemberList[EntityIndex].IsOnTeam1, Entity, bIsEntitySoldier, SoundTraceQueue);
			}
		});
	}

	if (SoundTraceQueue.IsEmpty())
	{
		return;
	}

	TMap<FMassEntityHandle, FVector> EntityToBestSoundLocation;
	DoLineTraces(SoundTraceQueue, *EntitySubsystem.GetWorld(), EntityToBestSoundLocation);

	if (EntityToBestSoundLocation.IsEmpty())
	{
		return;
	}

	TQueue<FMassEntityHandle, EQueueMode::Mpsc> TrackingSoundWhileNavigatingQueue;

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.Execute.PostLineTracesEntityQuery.ParallelForEachEntityChunk);
		PostLineTracesEntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [&EntityToBestSoundLocation, &EntitySubsystem, &TrackingSoundWhileNavigatingQueue](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();

			const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			const TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();
			const TArrayView<FMassStashedMoveTargetFragment> StashedMoveTargetList = Context.GetMutableFragmentView<FMassStashedMoveTargetFragment>();
			const TArrayView<FMassMoveForwardCompleteSignalFragment> MoveForwardCompleteSignalList = Context.GetMutableFragmentView<FMassMoveForwardCompleteSignalFragment>();

			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				const FMassEntityHandle& Entity = Context.GetEntity(EntityIndex);
				if (EntityToBestSoundLocation.Contains(Entity))
				{
					PostLineTracesProcessEntity(EntityToBestSoundLocation[Entity], MoveTargetList[EntityIndex], StashedMoveTargetList[EntityIndex], *EntitySubsystem.GetWorld(), EntitySubsystem, Entity, TrackingSoundWhileNavigatingQueue, MoveForwardCompleteSignalList[EntityIndex], LocationList[EntityIndex].GetTransform().GetLocation(), Context);
				}
			}
		});
	}

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassAudioPerceptionProcessor.Execute.ProcessQueues);
		while (!TrackingSoundWhileNavigatingQueue.IsEmpty())
		{
			FMassEntityHandle Entity;
      const bool bSuccess = TrackingSoundWhileNavigatingQueue.Dequeue(Entity);
			check(bSuccess);

			Context.Defer().AddTag<FMassHasStashedMoveTargetTag>(Entity);
			Context.Defer().AddTag<FMassTrackSoundTag>(Entity);
			Context.Defer().AddTag<FMassNeedsMoveTargetForwardCompleteSignalTag>(Entity);
		}
	}
}

```

`Source/ProjectM/Private/MassCollisionProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassCollisionProcessor.h"

#include <MassMovementFragments.h>
#include <MassCommonFragments.h>
#include "MassEntityView.h"
#include <MassLODTypes.h>

static const uint32 GUMassCollisionProcessor_MaxClosestEntitiesToFind = 3;
typedef TArray<FMassNavigationObstacleItem, TFixedAllocator<GUMassCollisionProcessor_MaxClosestEntitiesToFind>> TCollisionItemArray;

//----------------------------------------------------------------------//
//  UMassCollisionTrait
//----------------------------------------------------------------------//
void UMassCollisionTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	FCollisionCapsuleParametersFragment& CollisionCapsuleParametersFragment = BuildContext.AddFragment_GetRef<FCollisionCapsuleParametersFragment>();
	CollisionCapsuleParametersFragment.bIsCapsuleAlongForwardVector = bIsCapsuleAlongForwardVector;
	CollisionCapsuleParametersFragment.CapsuleRadius = CapsuleRadius;
	CollisionCapsuleParametersFragment.CapsuleLength = CapsuleLength;
	CollisionCapsuleParametersFragment.CapsuleCenterOffset = CapsuleCenterOffset;

	if (bEnableCollisionProcessor)
	{
		BuildContext.AddTag<FMassCollisionTag>();
	}
}

//----------------------------------------------------------------------//
//  UMassCollisionProcessor
//----------------------------------------------------------------------//
UMassCollisionProcessor::UMassCollisionProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	
	// Needs to execute right before UMassApplyMovementProcessor. By copying the ExecutionOrder from that processor, we'll run right before it.
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Avoidance);
}

void UMassCollisionProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FCollisionCapsuleParametersFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddTagRequirement<FMassCollisionTag>(EMassFragmentPresence::All);
}

void UMassCollisionProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	NavigationSubsystem = UWorld::GetSubsystem<UMassNavigationSubsystem>(Owner.GetWorld());
}

FCapsule MakeCapsuleForEntity(const FCollisionCapsuleParametersFragment& CollisionCapsuleParametersFragment, const FTransform& EntityTransform)
{
	FCapsule Capsule;
	const FVector& EntityLocation = EntityTransform.GetLocation();

	if (CollisionCapsuleParametersFragment.bIsCapsuleAlongForwardVector)
	{
		FVector Center = EntityLocation + CollisionCapsuleParametersFragment.CapsuleCenterOffset;
		FVector Forward = EntityTransform.GetRotation().GetForwardVector();

		Capsule.a = Center + Forward * (CollisionCapsuleParametersFragment.CapsuleLength / 2.f);
		Capsule.b = Center + Forward * (-CollisionCapsuleParametersFragment.CapsuleLength / 2.f);
		Capsule.r = CollisionCapsuleParametersFragment.CapsuleRadius;
	}
	else
	{
		Capsule.a = EntityLocation;
		Capsule.b = EntityLocation + FVector(0.f, 0.f, CollisionCapsuleParametersFragment.CapsuleLength);
		Capsule.r = CollisionCapsuleParametersFragment.CapsuleRadius;
	}

	return Capsule;
}

FCapsule MakeCapsuleForEntity(const FMassEntityView& EntityView)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("MakeCapsuleForEntity");

	FCollisionCapsuleParametersFragment* CollisionCapsuleParametersFragment = EntityView.GetFragmentDataPtr<FCollisionCapsuleParametersFragment>();
	FTransformFragment* TransformFragment = EntityView.GetFragmentDataPtr<FTransformFragment>();
	if (!CollisionCapsuleParametersFragment || !TransformFragment)
	{
		UE_LOG(LogTemp, Error, TEXT("MakeCapsuleForEntity: Expected FCollisionCapsuleParametersFragment and FTransformFragment on Entity."));
		return FCapsule();
	}

	return MakeCapsuleForEntity(*CollisionCapsuleParametersFragment, TransformFragment->GetTransform());
}

float ClosestPtSegmentSegment(FVector p1, FVector q1, FVector p2, FVector q2,
	float& s, float& t, FVector& c1, FVector& c2)
{
	FVector d1 = q1 - p1; // Direction vector of segment S1
	FVector d2 = q2 - p2; // Direction vector of segment S2
	FVector r = p1 - p2;
	float a = FVector::DotProduct(d1, d1); // Squared length of segment S1, always nonnegative
	float e = FVector::DotProduct(d2, d2); // Squared length of segment S2, always nonnegative
	float f = FVector::DotProduct(d2, r);
	// Check if either or both segments degenerate into points
	if (a <= SMALL_NUMBER && e <= SMALL_NUMBER) {
		// Both segments degenerate into points
		s = t = 0.0f;
		c1 = p1;
		c2 = p2;
		return FVector::DotProduct(c1 - c2, c1 - c2);
	}
	if (a <= SMALL_NUMBER) {
		// First segment degenerates into a point
		s = 0.0f;
		t = f / e; // s = 0 => t = (b*s + f) / e = f / e
		t = FMath::Clamp(t, 0.0f, 1.0f);
	}
	else {
		float c = FVector::DotProduct(d1, r);
		if (e <= SMALL_NUMBER) {
			// Second segment degenerates into a point
			t = 0.0f;
			s = FMath::Clamp(-c / a, 0.0f, 1.0f); // t = 0 => s = (b*t - c) / a = -c / a
		}
		else {
			// The general nondegenerate case starts here
			float b = FVector::DotProduct(d1, d2);
			float denom = a * e - b * b; // Always nonnegative
			// If segments not parallel, compute closest point on L1 to L2 and
			// clamp to segment S1. Else pick arbitrary s (here 0)
			if (denom != 0.0f) {
				s = FMath::Clamp((b * f - c * e) / denom, 0.0f, 1.0f);
			}
			else s = 0.0f;
			// Compute point on L2 closest to S1(s) using
			// t = Dot((P1 + D1*s) - P2,D2) / Dot(D2,D2) = (b*s + f) / e
			t = (b * s + f) / e;
			// If t in [0,1] done. Else clamp t, recompute s for the new value
			// of t using s = Dot((P2 + D2*t) - P1,D1) / Dot(D1,D1)= (t*b - c) / a
			// and clamp s to [0, 1]
			if (t < 0.0f) {
				t = 0.0f;
				s = FMath::Clamp(-c / a, 0.0f, 1.0f);
			}
			else if (t > 1.0f) {
				t = 1.0f;
				s = FMath::Clamp((b - c) / a, 0.0f, 1.0f);
			}
		}
	}
	c1 = p1 + d1 * s;
	c2 = p2 + d2 * t;
	return FVector::DotProduct(c1 - c2, c1 - c2);
}

bool TestCapsuleCapsule(FCapsule capsule1, FCapsule capsule2)
{
	// Compute (squared) distance between the inner structures of the capsules
	float s, t;
	FVector c1, c2;
	float dist2 = ClosestPtSegmentSegment(capsule1.a, capsule1.b,
		capsule2.a, capsule2.b, s, t, c1, c2);
	// If (squared) distance smaller than (squared) sum of radii, they collide
	float radius = capsule1.r + capsule2.r;
	return dist2 <= radius * radius;
}

FVector GetCapsuleCenter(const FCapsule& Capsule)
{
	return (Capsule.b - Capsule.a) / 2.f + Capsule.a;
}

float GetCapsuleHalfHeight(const FCapsule& Capsule)
{
	return (Capsule.b - Capsule.a).Size() / 2.f;
}

void DrawCapsule(const FCapsule& Capsule, const UWorld& World, const FLinearColor& Color, const bool bPersistentLines, float LifeTime)
{
	FQuat const CapsuleRot = FRotationMatrix::MakeFromZ(Capsule.b - Capsule.a).ToQuat();
	DrawDebugCapsule(&World, GetCapsuleCenter(Capsule), GetCapsuleHalfHeight(Capsule), Capsule.r, CapsuleRot, Color.ToFColor(true), bPersistentLines, LifeTime);
}

// TODO: DRY with other processors
static void FindCloseObstacles(const FVector& Center, const float SearchRadius, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid,
	TCollisionItemArray& OutCloseEntities, const FMassEntityHandle& EntityToIgnore, const UMassEntitySubsystem& EntitySubsystem)
{
	OutCloseEntities.Reset();
	const FVector Extent(SearchRadius, SearchRadius, 0.f);
	const FBox QueryBox = FBox(Center - Extent, Center + Extent);

	struct FSortingCell
	{
		int32 X;
		int32 Y;
		int32 Level;
		float SqDist;
	};
	TArray<FSortingCell, TInlineAllocator<64>> Cells;
	const FVector QueryCenter = QueryBox.GetCenter();

	for (int32 Level = 0; Level < AvoidanceObstacleGrid.NumLevels; Level++)
	{
		const float CellSize = AvoidanceObstacleGrid.GetCellSize(Level);
		const FNavigationObstacleHashGrid2D::FCellRect Rect = AvoidanceObstacleGrid.CalcQueryBounds(QueryBox, Level);
		for (int32 Y = Rect.MinY; Y <= Rect.MaxY; Y++)
		{
			for (int32 X = Rect.MinX; X <= Rect.MaxX; X++)
			{
				const float CenterX = (X + 0.5f) * CellSize;
				const float CenterY = (Y + 0.5f) * CellSize;
				const float DX = CenterX - QueryCenter.X;
				const float DY = CenterY - QueryCenter.Y;
				const float SqDist = DX * DX + DY * DY;
				FSortingCell SortCell;
				SortCell.X = X;
				SortCell.Y = Y;
				SortCell.Level = Level;
				SortCell.SqDist = SqDist;
				Cells.Add(SortCell);
			}
		}
	}

	Cells.Sort([](const FSortingCell& A, const FSortingCell& B) { return A.SqDist < B.SqDist; });

	for (const FSortingCell& SortedCell : Cells)
	{
		if (const FNavigationObstacleHashGrid2D::FCell* Cell = AvoidanceObstacleGrid.FindCell(SortedCell.X, SortedCell.Y, SortedCell.Level))
		{
			const TSparseArray<FNavigationObstacleHashGrid2D::FItem>& Items = AvoidanceObstacleGrid.GetItems();
			for (int32 Idx = Cell->First; Idx != INDEX_NONE; Idx = Items[Idx].Next)
			{
				if (Items[Idx].ID.Entity != EntityToIgnore && EntitySubsystem.IsEntityValid(Items[Idx].ID.Entity))
				{
					OutCloseEntities.Add(Items[Idx].ID);
					if (OutCloseEntities.Num() >= GUMassCollisionProcessor_MaxClosestEntitiesToFind)
					{
						return;
					}
				}
			}
		}
	}
}

bool UMassCollisionProcessor_DrawCapsules = false;
FAutoConsoleVariableRef CVarUMassCollisionProcessor_DrawCapsules(TEXT("pm.UMassCollisionProcessor_DrawCapsules"), UMassCollisionProcessor_DrawCapsules, TEXT("UMassCollisionProcessor: Debug draw capsules used for collisions detection"));

void ProcessEntity(FMassExecutionContext& Context, FMassEntityHandle Entity, const FTransform& Transform, TCollisionItemArray& OutCloseEntities, const float& AgentRadius, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid, UMassEntitySubsystem& EntitySubsystem, const FCollisionCapsuleParametersFragment& CollisionCapsuleParametersFragment, FMassForceFragment& ForceFragment, FMassVelocityFragment& VelocityFragment)
{
	FCapsule EntityCapsule = MakeCapsuleForEntity(CollisionCapsuleParametersFragment, Transform);

	FindCloseObstacles(Transform.GetLocation(), AgentRadius * 2, AvoidanceObstacleGrid, OutCloseEntities, Entity, EntitySubsystem);

	for (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : OutCloseEntities)
	{
		FMassEntityView OtherEntityView(EntitySubsystem, OtherEntity.Entity);
		FTransformFragment* OtherTransformFragment = OtherEntityView.GetFragmentDataPtr<FTransformFragment>();
		FCollisionCapsuleParametersFragment* OtherCollisionCapsuleParametersFragment = OtherEntityView.GetFragmentDataPtr<FCollisionCapsuleParametersFragment>();
		FMassForceFragment* OtherForceFragment = OtherEntityView.GetFragmentDataPtr<FMassForceFragment>();
		FMassVelocityFragment* OtherVelocityFragment = OtherEntityView.GetFragmentDataPtr<FMassVelocityFragment>();

		// We don't check OtherForceFragment for null because players don't have that fragment.
		if (!OtherTransformFragment || !OtherCollisionCapsuleParametersFragment || !OtherVelocityFragment)
		{
			UE_LOG(LogTemp, Warning, TEXT("[MassCollisionProcessor] ProcessEntity: OtherEntity (idx=%d,sn=%d) does not have one of FTransformFragment, FCollisionCapsuleParametersFragment, FMassVelocityFragment."), OtherEntity.Entity.Index, OtherEntity.Entity.SerialNumber);
			continue;
		}

		const FTransform& OtherTransform = OtherTransformFragment->GetTransform();
		FCapsule OtherEntityCapsule = MakeCapsuleForEntity(*OtherCollisionCapsuleParametersFragment, OtherTransform);

		if (TestCapsuleCapsule(EntityCapsule, OtherEntityCapsule))
		{
			const auto& OtherLocation = OtherTransform.GetLocation();
			const auto NewForce = FMath::IsNearlyEqual(VelocityFragment.Value.Size(), 0.f) ? Transform.GetLocation() - OtherLocation : -VelocityFragment.Value;
			ForceFragment.Value = NewForce;
			//VelocityFragment.Value = FVector::ZeroVector;

			const auto NewOtherForce = FMath::IsNearlyEqual(OtherVelocityFragment->Value.Size(), 0.f) ? OtherLocation - Transform.GetLocation() : -OtherVelocityFragment->Value;
			if (OtherForceFragment)
			{
				OtherForceFragment->Value = NewOtherForce;
				//OtherVelocityFragment->Value = FVector::ZeroVector;
			}

			if (UMassCollisionProcessor_DrawCapsules)
			{
				DrawCapsule(EntityCapsule, *EntitySubsystem.GetWorld());
				DrawCapsule(OtherEntityCapsule, *EntitySubsystem.GetWorld(), FLinearColor::Yellow);

				DrawDebugDirectionalArrow(EntitySubsystem.GetWorld(), Transform.GetLocation(), Transform.GetLocation() + NewForce, 30.f, FColor::Red, true);
				DrawDebugDirectionalArrow(EntitySubsystem.GetWorld(), OtherLocation, OtherLocation + NewOtherForce, 30.f, FColor::Yellow, true);
			}
		}
	}
}

// TODO: To make this work, we probably need to use a queue for updating fragments.
bool UMassCollisionProcessor_UseParallelForEachEntityChunk = false;

void UMassCollisionProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("UMassCollisionProcessor");

	if (!NavigationSubsystem)
	{
		return;
	}

	auto ExecuteFunction = [&EntitySubsystem, &NavigationSubsystem = NavigationSubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		const TArrayView<FMassVelocityFragment> VelocityList = Context.GetMutableFragmentView<FMassVelocityFragment>();
		const TArrayView<FMassForceFragment> ForceList = Context.GetMutableFragmentView<FMassForceFragment>();
		const TConstArrayView<FCollisionCapsuleParametersFragment> CollisionCapsuleParametersList = Context.GetFragmentView<FCollisionCapsuleParametersFragment>();

		TCollisionItemArray CloseEntities;

		// Used for storing sorted list of nearest obstacles.
		struct FSortedObstacle
		{
			FVector LocationCached;
			FVector Forward;
			FMassNavigationObstacleItem ObstacleItem;
			float SqDist;
		};

		const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid = NavigationSubsystem->GetObstacleGridMutable();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			ProcessEntity(Context, Context.GetEntity(EntityIndex), TransformList[EntityIndex].GetTransform(), CloseEntities, RadiusList[EntityIndex].Radius, AvoidanceObstacleGrid, EntitySubsystem, CollisionCapsuleParametersList[EntityIndex], ForceList[EntityIndex], VelocityList[EntityIndex]);
		}
	};

	if (UMassCollisionProcessor_UseParallelForEachEntityChunk)
	{
		EntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, ExecuteFunction);
	}
	else
	{
		EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, ExecuteFunction);
	}
}

```

`Source/ProjectM/Private/MassDelayedDestructionProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassDelayedDestructionProcessor.h"

//----------------------------------------------------------------------//
//  UMassDelayedDestructionTrait
//----------------------------------------------------------------------//
void UMassDelayedDestructionTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	FMassDelayedDestructionFragment& DelayedDestructionFragment = BuildContext.AddFragment_GetRef<FMassDelayedDestructionFragment>();
	DelayedDestructionFragment.SecondsLeftTilDestruction = SecondsDelay;
}

//----------------------------------------------------------------------//
//  UMassDelayedDestructionProcessor
//----------------------------------------------------------------------//
UMassDelayedDestructionProcessor::UMassDelayedDestructionProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ProcessingPhase = EMassProcessingPhase::PostPhysics;
}

void UMassDelayedDestructionProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassDelayedDestructionFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassDelayedDestructionProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	UWorld* World = EntitySubsystem.GetWorld();
	float DeltaTimeSeconds = World->DeltaTimeSeconds;

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [DeltaTimeSeconds](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const TArrayView<FMassDelayedDestructionFragment> DelayedDestructionList = Context.GetMutableFragmentView<FMassDelayedDestructionFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			FMassDelayedDestructionFragment& DelayedDestructionFragment = DelayedDestructionList[EntityIndex];
			DelayedDestructionFragment.SecondsLeftTilDestruction -= DeltaTimeSeconds;
			if (DelayedDestructionFragment.SecondsLeftTilDestruction <= 0.f)
			{
				Context.Defer().DestroyEntity(Context.GetEntity(EntityIndex));
			}
		}
	});
}

```

`Source/ProjectM/Private/MassEnemyTargetFinderProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassEnemyTargetFinderProcessor.h"

#include "MassEntityView.h"
#include "MassTargetFinderSubsystem.h"
#include "MassLODTypes.h"
#include "MassCommonFragments.h"
#include "MassTrackTargetProcessor.h"
#include "Kismet/KismetSystemLibrary.h"
#include "MassProjectileDamageProcessor.h"
#include <MassNavigationTypes.h>
#include "MassMoveTargetForwardCompleteProcessor.h"
#include "InvalidTargetFinderProcessor.h"
#include "MassRepresentationTypes.h"
#include "MassTargetGridProcessors.h"

const FVector& GetEntityLocationViaTargetFinderSubsystem(const FMassEntityHandle& Entity, const UMassTargetFinderSubsystem& TargetFinderSubsystem)
{
	return TargetFinderSubsystem.GetTargetDynamicData()[Entity].Location;
}

struct FPotentialTargetSphereTraceData
{
	FPotentialTargetSphereTraceData(FMassEntityHandle InEntity, FMassEntityHandle InTargetEntity, FVector InTraceStart, FVector InTraceEnd, float InMinCaliberForDamage, FVector InLocation, bool bInIsSoldier)
		: Entity(InEntity), TargetEntity(InTargetEntity), TraceStart(InTraceStart), TraceEnd(InTraceEnd), MinCaliberForDamage(InMinCaliberForDamage), Location(InLocation), bIsSoldier(bInIsSoldier)
	{
	}

	FPotentialTargetSphereTraceData() = default;

	FMassEntityHandle Entity;
	FMassEntityHandle TargetEntity;
	FVector TraceStart;
	FVector TraceEnd;
	float MinCaliberForDamage;
	FVector Location;
	bool bIsSoldier;
};

//----------------------------------------------------------------------//
//  UMassTeamMemberTrait
//----------------------------------------------------------------------//
void UMassTeamMemberTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	FTeamMemberFragment& TeamMemberTemplate = BuildContext.AddFragment_GetRef<FTeamMemberFragment>();
	TeamMemberTemplate.IsOnTeam1 = IsOnTeam1;
}

//----------------------------------------------------------------------//
//  UMassNeedsEnemyTargetTrait
//----------------------------------------------------------------------//
void UMassNeedsEnemyTargetTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	FTargetEntityFragment& TargetEntityTemplate = BuildContext.AddFragment_GetRef<FTargetEntityFragment>();
	TargetEntityTemplate.TargetMinCaliberForDamage = ProjectileCaliber;

	BuildContext.AddFragment<FMassMoveForwardCompleteSignalFragment>();
	BuildContext.AddFragment<FMassTargetGridCellLocationFragment>();
	BuildContext.AddTag<FMassNeedsEnemyTargetTag>();
}

//----------------------------------------------------------------------//
//  UMassEnemyTargetFinderProcessor
//----------------------------------------------------------------------//
UMassEnemyTargetFinderProcessor::UMassEnemyTargetFinderProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
}

void UMassEnemyTargetFinderProcessor::ConfigureQueries()
{
	FMassEntityQuery BaseEntityQuery;

	BaseEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BaseEntityQuery.AddRequirement<FTargetEntityFragment>(EMassFragmentAccess::ReadWrite);
	BaseEntityQuery.AddTagRequirement<FMassNeedsEnemyTargetTag>(EMassFragmentPresence::All);

	PreSphereTraceEntityQuery = BaseEntityQuery;
	PreSphereTraceEntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);

	PostSphereTraceEntityQuery = BaseEntityQuery;
}

void UMassEnemyTargetFinderProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	TargetFinderSubsystem = UWorld::GetSubsystem<UMassTargetFinderSubsystem>(Owner.GetWorld());
}

bool CanEntityDamageTargetEntity(const float TargetMinCaliberForDamage, const float MinCaliberForDamage)
{
	return TargetMinCaliberForDamage >= MinCaliberForDamage;
}

FCapsule GetProjectileTraceCapsuleToTarget(const bool bIsEntitySoldier, const bool bIsTargetEntitySoldier, const FTransform& EntityTransform, const FVector& TargetEntityLocation)
{
	const FVector& EntityLocation = EntityTransform.GetLocation();
	const FVector ProjectileZOffset(0.f, 0.f, UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationZOffset(bIsEntitySoldier));
	const FVector ProjectileSpawnLocation = EntityLocation + UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationOffset(EntityTransform, bIsEntitySoldier);

	const bool bShouldAimAtFeet = !bIsEntitySoldier && bIsTargetEntitySoldier;
	static constexpr float VerticalBuffer = 50.f; // This is needed because otherwise for tanks we always hit the ground when doing trace. TODO: Come up with a better way to handle this.
	const FVector ProjectileTargetLocation = bShouldAimAtFeet ? TargetEntityLocation + FVector(0.f, 0.f, ProjectileRadius + VerticalBuffer) : TargetEntityLocation + ProjectileZOffset;
	return FCapsule(ProjectileSpawnLocation, ProjectileTargetLocation, ProjectileRadius);
}

void GetSearchPointsAlongTrace(const FCapsule& ProjectileTraceCapsule, TArray<FVector>& OutSearchPoints)
{
	static constexpr float DistanceBetweenPoints = 1000.f; // 10m

	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.GetSearchPointsAlongTrace);

	const int32 NumPoints = FMath::CeilToInt((ProjectileTraceCapsule.b - ProjectileTraceCapsule.a).Size() / DistanceBetweenPoints) + 1;
	OutSearchPoints.Reserve(NumPoints);

	const FVector& NormalVector = (ProjectileTraceCapsule.b - ProjectileTraceCapsule.a).GetSafeNormal();

	for (int32 i = 0; i < NumPoints; i++)
	{
		OutSearchPoints.Add(ProjectileTraceCapsule.a + NormalVector * i * DistanceBetweenPoints);
	}
}

bool AreEntitiesBlockingTarget(const FCapsule& ProjectileTraceCapsule, const FMassEntityHandle& Entity, const FMassEntityHandle& TargetEntity, const UWorld& World, const UMassTargetFinderSubsystem& TargetFinderSubsystem)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.AreEntitiesBlockingTarget);

	TArray<FVector> SearchPoints;
	GetSearchPointsAlongTrace(ProjectileTraceCapsule, SearchPoints);

	bool bDidAnyCapsulesCollide(false);
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.AreEntitiesBlockingTarget.For);
		for (int32 i = 0; i < SearchPoints.Num() - 1; i++)
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.AreEntitiesBlockingTarget.ForBody);

			const FVector& SearchBoxStart = SearchPoints[i];
			const FVector& SearchBoxEnd = SearchPoints[i + 1];
			const FBox SearchBounds(SearchBoxStart.ComponentMin(SearchBoxEnd), SearchBoxStart.ComponentMax(SearchBoxEnd));

			TArray<FMassTargetGridItem> EntitiesInSearchBox;
			EntitiesInSearchBox.Reserve(5);

			{
				TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.AreEntitiesBlockingTarget.ForBody.TargetGridQuery);
				TargetFinderSubsystem.GetTargetGrid().Query(SearchBounds, EntitiesInSearchBox);
			}

			for (const FMassTargetGridItem& TargetGridItem : EntitiesInSearchBox)
			{
				if (TargetGridItem.Entity == Entity || TargetGridItem.Entity == TargetEntity)
				{
					continue;
				}
				const FCapsule& TargetGridItemCapsule = TargetFinderSubsystem.GetTargetDynamicData()[TargetGridItem.Entity].Capsule;
				if (DidCapsulesCollide(ProjectileTraceCapsule, TargetGridItemCapsule, Entity, World))
				{
					bDidAnyCapsulesCollide = true;
					break;
				}
			}

			if (bDidAnyCapsulesCollide)
			{
				break;
			}
		}
	}

#if WITH_MASSGAMEPLAY_DEBUG
	if (UE::Mass::Debug::IsDebuggingEntity(Entity) && bDidAnyCapsulesCollide)
	{
		AsyncTask(ENamedThreads::GameThread, [&World, TargetEntity]()
		{
			UMassEnemyTargetFinderProcessor_DebugEntityData.TargetEntitiesCulledDueToOtherEntityBlocking.Add(GetEntityLocationViaTargetFinderSubsystem(TargetEntity, *UWorld::GetSubsystem<UMassTargetFinderSubsystem>(&World)));
		});
	}
#endif

	return bDidAnyCapsulesCollide;
}

bool IsTargetEntityVisibleViaSphereTrace(const UWorld& World, const FVector& StartLocation, const FVector& EndLocation, const bool DrawTrace)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor_IsTargetEntityVisibleViaSphereTrace);
	FHitResult Result;
	static constexpr float Radius = 20.f; // TODO: don't hard-code
	const bool bFoundBlockingHit = UKismetSystemLibrary::SphereTraceSingle(World.GetLevel(0)->Actors[0], StartLocation, EndLocation, Radius, TraceTypeQuery1, false, TArray<AActor*>(), EDrawDebugTrace::Type::None, Result, false);

#if WITH_MASSGAMEPLAY_DEBUG
	// We can't use SphereTraceSingle's ability to draw trace because this function may run in a background thread which isn't allowed to draw. So we do it ourselves async.
	if (DrawTrace)
	{
		AsyncTask(ENamedThreads::GameThread, [StartLocation, EndLocation, Radius = Radius, &World, bFoundBlockingHit]()
		{
			const FLinearColor& Color = bFoundBlockingHit ? FLinearColor::Red : FLinearColor::Green;
			FCapsule Capsule(StartLocation, EndLocation, Radius);
			DrawCapsule(Capsule, World, Color, false, 0.1f);
		});
	}
#endif

	return !bFoundBlockingHit;
}

// TODO: Don't hard-code, get from data asset.
float GetEntityRange(const bool bIsEntitySoldier)
{
	constexpr float SoldierMaxRangeMeters = 100.f; 
	constexpr float SoldierMaxRangeCm = SoldierMaxRangeMeters * 100.f;
	return bIsEntitySoldier ? SoldierMaxRangeCm : SoldierMaxRangeCm * 2.f;
}

bool IsTargetEntityOutOfRange(const FVector& EntityLocation, const bool bIsEntitySoldier, const FVector& TargetEntityLocation)
{
	const float DistanceToTarget = (TargetEntityLocation - EntityLocation).Size();
	return DistanceToTarget > GetEntityRange(bIsEntitySoldier);
}

bool IsTargetEntityOutOfRange(const FVector& EntityLocation, const bool bIsEntitySoldier, const FMassEntityView& TargetEntityView)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.IsTargetEntityOutOfRange);

	const FTransformFragment& TargetEntityTransformFragment = TargetEntityView.GetFragmentData<FTransformFragment>();
	const FVector& TargetEntityLocation = TargetEntityTransformFragment.GetTransform().GetLocation();
	return IsTargetEntityOutOfRange(EntityLocation, bIsEntitySoldier, TargetEntityLocation);
}

struct FPotentialTarget
{
	FPotentialTarget(FMassEntityHandle InEntity, FVector InLocation, float InMinCaliberForDamage, bool bIsSoldier)
		: Entity(InEntity), Location(InLocation), MinCaliberForDamage(InMinCaliberForDamage), bIsSoldier(bIsSoldier)
	{
	}

	FMassEntityHandle Entity;
	FVector Location;
	float MinCaliberForDamage;
	bool bIsSoldier;
};

bool IsValidVector(const FVector& Vector)
{
	const bool bHasAnyInvalidComponents = FMath::IsNaN(Vector.X) || FMath::IsNaN(Vector.Y) || FMath::IsNaN(Vector.Z);
	return !bHasAnyInvalidComponents;
}

void GetPotentialTargetSphereTraces(const FMassEntityHandle& Entity, const UMassEntitySubsystem& EntitySubsystem, const UMassTargetFinderSubsystem& TargetFinderSubsystem, const FTransform& EntityTransform, const bool& IsEntityOnTeam1, const FTargetEntityFragment& TargetEntityFragment, const bool bIsEntitySoldier, TQueue<FPotentialTargetSphereTraceData, EQueueMode::Mpsc>& OutPotentialTargetsNeedingSphereTrace)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.GetPotentialTargetSphereTraces);

	const UWorld* World = EntitySubsystem.GetWorld();

	const FVector& EntityLocation = EntityTransform.GetLocation();
	const FVector& EntityForwardVector = EntityTransform.GetRotation().GetForwardVector();
	
	const float OffsetMagnitude = GetEntityRange(bIsEntitySoldier) / 2.f; 
	const FVector SearchOffset = EntityForwardVector * OffsetMagnitude;
	const FVector SearchCenter = EntityLocation + SearchOffset;
	const FVector SearchOffsetAbs = SearchOffset.GetAbs();
	const FVector SearchExtent(FMath::Max(SearchOffsetAbs.X, SearchOffsetAbs.Y));

	const FBox SearchBounds(SearchCenter - SearchExtent, SearchCenter + SearchExtent);
	TArray<FMassTargetGridItem> CloseEntities;
	CloseEntities.Reserve(300);

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.GetPotentialTargetSphereTraces.TargetGridQuery);
		TargetFinderSubsystem.GetTargetGrid().Query(SearchBounds, CloseEntities);
	}

	int32 NumPotentialTargetsNeedingSphereTraceEnqueued = 0;

#if WITH_MASSGAMEPLAY_DEBUG
	TArray<FVector> TargetEntitiesCulledDueToSameTeam;
	TArray<FVector> TargetEntitiesCulledDueToImpenetrable;
	TArray<FVector> TargetEntitiesCulledDueToOutOfRange;
#endif

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.GetPotentialTargetSphereTraces.ProcessCloseEntities);

		for (const FMassTargetGridItem& OtherEntity : CloseEntities)
		{
			// Skip self.
			if (OtherEntity.Entity == Entity)
			{
				continue;
			}

			// Skip invalid entities.
			if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
			{
				continue;
			}

			// Skip same team.
			if (IsEntityOnTeam1 == OtherEntity.bIsOnTeam1) {
#if WITH_MASSGAMEPLAY_DEBUG
				if (UE::Mass::Debug::IsDebuggingEntity(Entity))
				{
					TargetEntitiesCulledDueToSameTeam.Add(GetEntityLocationViaTargetFinderSubsystem(OtherEntity.Entity, TargetFinderSubsystem));
				}
#endif

				continue;
			}

			if (!CanEntityDamageTargetEntity(TargetEntityFragment.TargetMinCaliberForDamage, OtherEntity.MinCaliberForDamage))
			{
#if WITH_MASSGAMEPLAY_DEBUG
				if (UE::Mass::Debug::IsDebuggingEntity(Entity))
				{
					TargetEntitiesCulledDueToImpenetrable.Add(GetEntityLocationViaTargetFinderSubsystem(OtherEntity.Entity, TargetFinderSubsystem));
				}
#endif
				continue;
			}

			const FVector& OtherEntityLocation = GetEntityLocationViaTargetFinderSubsystem(OtherEntity.Entity, TargetFinderSubsystem);
			if (IsTargetEntityOutOfRange(EntityLocation, bIsEntitySoldier, OtherEntityLocation))
			{
#if WITH_MASSGAMEPLAY_DEBUG
				if (UE::Mass::Debug::IsDebuggingEntity(Entity))
				{
					TargetEntitiesCulledDueToOutOfRange.Add(GetEntityLocationViaTargetFinderSubsystem(OtherEntity.Entity, TargetFinderSubsystem));
				}
#endif
				continue;
			}

			const FCapsule& ProjectileTraceCapsule = GetProjectileTraceCapsuleToTarget(bIsEntitySoldier, OtherEntity.bIsSoldier, EntityTransform, OtherEntityLocation);

			if (IsValidVector(ProjectileTraceCapsule.a) && IsValidVector(ProjectileTraceCapsule.b))
			{
				OutPotentialTargetsNeedingSphereTrace.Enqueue(FPotentialTargetSphereTraceData(Entity, OtherEntity.Entity, ProjectileTraceCapsule.a, ProjectileTraceCapsule.b, OtherEntity.MinCaliberForDamage, OtherEntityLocation, OtherEntity.bIsSoldier));
				NumPotentialTargetsNeedingSphereTraceEnqueued++;
			}
			else
			{
				UE_LOG(LogTemp, Warning, TEXT("Got invalid vector."));
			}
		}
	}

#if WITH_MASSGAMEPLAY_DEBUG
	if (UE::Mass::Debug::IsDebuggingEntity(Entity))
	{
		AsyncTask(ENamedThreads::GameThread, [EntityLocation, SearchCenter, SearchExtent, World, NumCloseEntities = CloseEntities.Num(), NumPotentialTargetsNeedingSphereTraceEnqueued, TargetEntitiesCulledDueToSameTeam, TargetEntitiesCulledDueToImpenetrable, TargetEntitiesCulledDueToOutOfRange]()
		{
			UMassEnemyTargetFinderProcessor_DebugEntityData.IsEntitySearching = true;
			UMassEnemyTargetFinderProcessor_DebugEntityData.EntityLocation = EntityLocation;
			UMassEnemyTargetFinderProcessor_DebugEntityData.SearchCenter = SearchCenter;
			UMassEnemyTargetFinderProcessor_DebugEntityData.SearchExtent = SearchExtent;
			UMassEnemyTargetFinderProcessor_DebugEntityData.NumCloseEntities = NumCloseEntities;
			UMassEnemyTargetFinderProcessor_DebugEntityData.NumPotentialTargetsNeedingSphereTrace = NumPotentialTargetsNeedingSphereTraceEnqueued;
			UMassEnemyTargetFinderProcessor_DebugEntityData.TargetEntitiesCulledDueToSameTeam.Append(TargetEntitiesCulledDueToSameTeam);
			UMassEnemyTargetFinderProcessor_DebugEntityData.TargetEntitiesCulledDueToImpenetrable.Append(TargetEntitiesCulledDueToImpenetrable);
			UMassEnemyTargetFinderProcessor_DebugEntityData.TargetEntitiesCulledDueToOutOfRange.Append(TargetEntitiesCulledDueToOutOfRange);
		});
	}
#endif
}

float GetProjectileInitialXYVelocityMagnitude(const bool bIsEntitySoldier)
{
	return bIsEntitySoldier ? 90525.6f : 10000.f; // TODO: make this configurable in data asset and get from there?
}

void ProcessEntityForVisualTarget(FMassEntityHandle Entity, const UMassEntitySubsystem& EntitySubsystem, const FTransformFragment& TransformFragment, const FTargetEntityFragment& TargetEntityFragment, const bool IsEntityOnTeam1, const UMassTargetFinderSubsystem& TargetFinderSubsystem, const bool bIsEntitySoldier, TQueue<FPotentialTargetSphereTraceData, EQueueMode::Mpsc>& PotentialTargetsNeedingSphereTrace)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.ProcessEntityForVisualTarget);

	const FTransform& EntityTransform = TransformFragment.GetTransform();
	GetPotentialTargetSphereTraces(Entity, EntitySubsystem, TargetFinderSubsystem, EntityTransform, IsEntityOnTeam1, TargetEntityFragment, bIsEntitySoldier, PotentialTargetsNeedingSphereTrace);
}

bool UMassEnemyTargetFinderProcessor_UseParallelForEachEntityChunk = true;
FAutoConsoleVariableRef CVarUMassEnemyTargetFinderProcessor_UseParallelForEachEntityChunk(TEXT("pm.UMassEnemyTargetFinderProcessor_UseParallelForEachEntityChunk"), UMassEnemyTargetFinderProcessor_UseParallelForEachEntityChunk, TEXT("Use ParallelForEachEntityChunk in UMassEnemyTargetFinderProcessor to improve performance"));

bool UMassEnemyTargetFinderProcessor_SkipUpdatingTargetEntity = false;
FAutoConsoleVariableRef CVarUMassEnemyTargetFinderProcessor_SkipUpdatingTargetEntity(TEXT("pm.UMassEnemyTargetFinderProcessor_SkipUpdatingTargetEntity"), UMassEnemyTargetFinderProcessor_SkipUpdatingTargetEntity, TEXT("UMassEnemyTargetFinderProcessor_SkipUpdatingTargetEntity"));

struct FProcessSphereTracesContext
{
	FProcessSphereTracesContext(TQueue<FPotentialTargetSphereTraceData, EQueueMode::Mpsc>& PotentialTargetsNeedingSphereTraceQueue, UWorld& World, TMap<FMassEntityHandle, TArray<FPotentialTarget>>& OutEntityToPotentialTargetEntities, const UMassTargetFinderSubsystem& TargetFinderSubsystem)
		: PotentialTargetsNeedingSphereTraceQueue(PotentialTargetsNeedingSphereTraceQueue), World(World), EntityToPotentialTargetEntities(OutEntityToPotentialTargetEntities), TargetFinderSubsystem(TargetFinderSubsystem)
	{
	}

	void Execute()
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(FProcessSphereTracesContext.Execute);

		ConvertSphereTraceQueueToArray();
		ProcessSphereTraces();
		ConvertPotentialVisibleTargetsQueueToMap();
	}

private:

	void ConvertSphereTraceQueueToArray()
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(FProcessSphereTracesContext.ConvertSphereTraceQueueToArray);

		while (!PotentialTargetsNeedingSphereTraceQueue.IsEmpty())
		{
			FPotentialTargetSphereTraceData PotentialTarget;
			const bool bSuccess = PotentialTargetsNeedingSphereTraceQueue.Dequeue(PotentialTarget);
			check(bSuccess);
			PotentialTargetsNeedingSphereTrace.Add(PotentialTarget);
		}
	}

	void ProcessSphereTraces()
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(FProcessSphereTracesContext.ProcessSphereTraces);

		ParallelFor(PotentialTargetsNeedingSphereTrace.Num(), [&](const int32 JobIndex)
		{
			const FCapsule TraceCapsule(PotentialTargetsNeedingSphereTrace[JobIndex].TraceStart, PotentialTargetsNeedingSphereTrace[JobIndex].TraceEnd, 1.f);
			const bool bAreEntitiesBlockingTarget = AreEntitiesBlockingTarget(TraceCapsule, PotentialTargetsNeedingSphereTrace[JobIndex].Entity, PotentialTargetsNeedingSphereTrace[JobIndex].TargetEntity, World, TargetFinderSubsystem);
			if (!bAreEntitiesBlockingTarget)
			{
				if (IsTargetEntityVisibleViaSphereTrace(World, PotentialTargetsNeedingSphereTrace[JobIndex].TraceStart, PotentialTargetsNeedingSphereTrace[JobIndex].TraceEnd))
				{
					PotentialVisibleTargets.Enqueue(PotentialTargetsNeedingSphereTrace[JobIndex]);
				}
#if WITH_MASSGAMEPLAY_DEBUG
				else
				{
					if (UE::Mass::Debug::IsDebuggingEntity(PotentialTargetsNeedingSphereTrace[JobIndex].Entity))
					{
						AsyncTask(ENamedThreads::GameThread, [TargetEntityLocation = PotentialTargetsNeedingSphereTrace[JobIndex].Location]()
						{
							UMassEnemyTargetFinderProcessor_DebugEntityData.TargetEntitiesCulledDueToNoLineOfSight.Add(TargetEntityLocation);
						});
					}
				}
#endif
			}
		});
	}

	void ConvertPotentialVisibleTargetsQueueToMap()
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(FProcessSphereTracesContext.ConvertPotentialVisibleTargetsQueueToMap);

		while (!PotentialVisibleTargets.IsEmpty())
		{
			FPotentialTargetSphereTraceData PotentialTarget;
			const bool bSuccess = PotentialVisibleTargets.Dequeue(PotentialTarget);
			check(bSuccess);
			if (!EntityToPotentialTargetEntities.Contains(PotentialTarget.Entity))
			{
				EntityToPotentialTargetEntities.Add(PotentialTarget.Entity, TArray<FPotentialTarget>());
			}
			EntityToPotentialTargetEntities[PotentialTarget.Entity].Add(FPotentialTarget(PotentialTarget.TargetEntity, PotentialTarget.Location, PotentialTarget.MinCaliberForDamage, PotentialTarget.bIsSoldier));
		}
	}

	TQueue<FPotentialTargetSphereTraceData, EQueueMode::Mpsc>& PotentialTargetsNeedingSphereTraceQueue;
	UWorld& World;
	TMap<FMassEntityHandle, TArray<FPotentialTarget>>& EntityToPotentialTargetEntities;
	TArray<FPotentialTargetSphereTraceData> PotentialTargetsNeedingSphereTrace;
	TQueue<FPotentialTargetSphereTraceData, EQueueMode::Mpsc> PotentialVisibleTargets;
	const UMassTargetFinderSubsystem& TargetFinderSubsystem;
};

struct FSelectBestTargetProcessEntityContext
{
	FSelectBestTargetProcessEntityContext(UMassEntitySubsystem& EntitySubsystem, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& TargetFinderEntityQueue, const FMassEntityHandle& Entity, const FTransform& EntityTransform, FTargetEntityFragment& TargetEntityFragment, TArray<FPotentialTarget>& PotentialTargets, const bool bIsEntitySoldier)
		: EntitySubsystem(EntitySubsystem), TargetFinderEntityQueue(TargetFinderEntityQueue), Entity(Entity), EntityLocation(EntityTransform.GetLocation()), EntityTransform(EntityTransform), bIsEntitySoldier(bIsEntitySoldier), TargetEntityFragment(TargetEntityFragment), PotentialTargets(PotentialTargets)
	{
	}

	void ProcessEntity() const
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(FSelectBestTargetProcessEntityContext.ProcessEntity);

		TSortedMap<float, TArray<FPotentialTarget>> PotentialTargetsByCaliber;
		GroupByCaliber(PotentialTargetsByCaliber);

		FMassEntityHandle TargetEntity;
		FVector TargetEntityLocation;
		bool bIsTargetEntitySoldier;
		if (SelectBestTarget(PotentialTargetsByCaliber, TargetEntity, TargetEntityLocation, bIsTargetEntitySoldier))
		{
			if (!UMassEnemyTargetFinderProcessor_SkipUpdatingTargetEntity)
			{
				TargetEntityFragment.Entity = TargetEntity;
				TargetEntityFragment.VerticalAimOffset = GetVerticalAimOffset(TargetEntityLocation, bIsTargetEntitySoldier);
				TargetFinderEntityQueue.Enqueue(Entity);
			}

#if WITH_MASSGAMEPLAY_DEBUG
			if (UE::Mass::Debug::IsDebuggingEntity(Entity))
			{
				AsyncTask(ENamedThreads::GameThread, [World = EntitySubsystem.GetWorld(), EntityLocation = EntityLocation, TargetEntityLocation]()
				{
					UMassEnemyTargetFinderProcessor_DebugEntityData.TargetEntityLocation = TargetEntityLocation;
					UMassEnemyTargetFinderProcessor_DebugEntityData.HasTargetEntity = true;
				});
			}
#endif
		}
	}

	void GroupByCaliber(TSortedMap<float, TArray<FPotentialTarget>>& OutPotentialTargetsByCaliber) const
	{
		for (FPotentialTarget& PotentialTarget : PotentialTargets)
		{
			if (!OutPotentialTargetsByCaliber.Contains(PotentialTarget.MinCaliberForDamage))
			{
				OutPotentialTargetsByCaliber.Add(PotentialTarget.MinCaliberForDamage, TArray<FPotentialTarget>());
			}
			OutPotentialTargetsByCaliber[PotentialTarget.MinCaliberForDamage].Add(PotentialTarget);
		}
	}

	bool SelectBestTarget(TSortedMap<float, TArray<FPotentialTarget>>& PotentialTargetsByCaliber, FMassEntityHandle& OutTargetEntity, FVector& OutTargetEntityLocation, bool& bIsTargetEntitySoldier) const
	{
		if (PotentialTargetsByCaliber.Num() == 0)
		{
			OutTargetEntity = UMassEntitySubsystem::InvalidEntity;
			return false;
		}

		TArray<float> OutKeys;
		PotentialTargetsByCaliber.GetKeys(OutKeys);
		TArray<FPotentialTarget> PotentialTargetsWithBestCaliber = PotentialTargetsByCaliber[OutKeys.Last()];

		auto DistanceSqFromEntityToLocation = [&EntityLocation = EntityLocation](const FVector& OtherLocation) {
			return (OtherLocation - EntityLocation).SizeSquared();
		};

		PotentialTargetsWithBestCaliber.Sort([&DistanceSqFromEntityToLocation](const FPotentialTarget& A, const FPotentialTarget& B) { return DistanceSqFromEntityToLocation(A.Location) < DistanceSqFromEntityToLocation(B.Location); });

		OutTargetEntity = PotentialTargetsWithBestCaliber[0].Entity;
		OutTargetEntityLocation = PotentialTargetsWithBestCaliber[0].Location;
		bIsTargetEntitySoldier = PotentialTargetsWithBestCaliber[0].bIsSoldier;

		return true;
	}

	float GetVerticalAimOffset(const FVector& TargetEntityLocation, const bool bIsTargetEntitySoldier) const
	{
		const bool bShouldAimAtFeet = !bIsEntitySoldier && bIsTargetEntitySoldier;
		const FVector ProjectileSpawnLocation = EntityLocation + UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationOffset(EntityTransform, bIsEntitySoldier);
		const FVector ProjectileTargetLocation = bShouldAimAtFeet ? TargetEntityLocation : FVector(TargetEntityLocation.X, TargetEntityLocation.Y, ProjectileSpawnLocation.Z);
		const float XYDistanceToTarget = (FVector2D(ProjectileTargetLocation) - FVector2D(ProjectileSpawnLocation)).Size();
		const float ProjectileInitialXYVelocityMagnitude = GetProjectileInitialXYVelocityMagnitude(bIsEntitySoldier);
		const UWorld* World = EntitySubsystem.GetWorld();
		const float TimeToTarget = XYDistanceToTarget / ProjectileInitialXYVelocityMagnitude;
		const float VerticalDistanceToTravel = ProjectileTargetLocation.Z - UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationZOffset(bIsEntitySoldier);
		const float& GravityZ = EntitySubsystem.GetWorld()->GetGravityZ();
		const float VerticalDistanceTraveledDueToGravity = (1.f / 2.f) * GravityZ * TimeToTarget * TimeToTarget;
		const float Result = (VerticalDistanceToTravel - VerticalDistanceTraveledDueToGravity) / TimeToTarget;

		return Result;
	}

private:
	UMassEntitySubsystem& EntitySubsystem;
	TQueue<FMassEntityHandle, EQueueMode::Mpsc>& TargetFinderEntityQueue;
	const FMassEntityHandle& Entity;
	const FVector EntityLocation;
	const FTransform& EntityTransform;
	const bool bIsEntitySoldier;
	FTargetEntityFragment& TargetEntityFragment;
	TArray<FPotentialTarget>& PotentialTargets;
};

struct FSelectBestTargetContext
{
	FSelectBestTargetContext(FMassEntityQuery& EntityQuery, UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context, TMap<FMassEntityHandle, TArray<FPotentialTarget>>& EntityToPotentialTargetEntities, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& TargetFinderEntityQueue)
		: EntityQuery(EntityQuery), EntitySubsystem(EntitySubsystem), Context(Context), EntityToPotentialTargetEntities(EntityToPotentialTargetEntities), TargetFinderEntityQueue(TargetFinderEntityQueue)
	{
	}

	void Execute() const
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(FSelectBestTargetContext.Execute);

		EntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [this](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();

			const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
			const TArrayView<FTargetEntityFragment> TargetEntityList = Context.GetMutableFragmentView<FTargetEntityFragment>();

			for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
			{
				const FMassEntityHandle& Entity = Context.GetEntity(EntityIndex);
				if (EntityToPotentialTargetEntities.Contains(Entity))
				{
					const bool bIsEntitySoldier = Context.DoesArchetypeHaveTag<FMassProjectileDamagableSoldierTag>();
					FSelectBestTargetProcessEntityContext(EntitySubsystem, TargetFinderEntityQueue, Entity, LocationList[EntityIndex].GetTransform(), TargetEntityList[EntityIndex], EntityToPotentialTargetEntities[Entity], bIsEntitySoldier).ProcessEntity();
				}
			}
		});
	}

private:
	FMassEntityQuery& EntityQuery;
	UMassEntitySubsystem& EntitySubsystem;
	FMassExecutionContext& Context;
	TMap<FMassEntityHandle, TArray<FPotentialTarget>>& EntityToPotentialTargetEntities;
	TQueue<FMassEntityHandle, EQueueMode::Mpsc>& TargetFinderEntityQueue;
};

void UMassEnemyTargetFinderProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor);

	if (UMassEnemyTargetFinderProcessor_SkipFindingTargets)
	{
		return;
	}

	TQueue<FPotentialTargetSphereTraceData, EQueueMode::Mpsc> PotentialTargetsNeedingSphereTrace;

	auto ExecuteFunction = [&EntitySubsystem, &PotentialTargetsNeedingSphereTrace, TargetFinderSubsystem = TargetFinderSubsystem](FMassExecutionContext& Context)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.ForEachEntityChunk.Body);

		const int32 NumEntities = Context.GetNumEntities();

		const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();
		const TArrayView<FTargetEntityFragment> TargetEntityList = Context.GetMutableFragmentView<FTargetEntityFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; EntityIndex++)
		{
			const FMassEntityHandle& Entity = Context.GetEntity(EntityIndex);
			const bool& bIsEntitySoldier = Context.DoesArchetypeHaveTag<FMassProjectileDamagableSoldierTag>();
			ProcessEntityForVisualTarget(Entity, EntitySubsystem, LocationList[EntityIndex], TargetEntityList[EntityIndex], TeamMemberList[EntityIndex].IsOnTeam1, *TargetFinderSubsystem.Get(), bIsEntitySoldier, PotentialTargetsNeedingSphereTrace);
		}
	};

	if (UMassEnemyTargetFinderProcessor_UseParallelForEachEntityChunk)
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.ParallelForEachEntityChunk);

		PreSphereTraceEntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, ExecuteFunction);
	} else {
		PreSphereTraceEntityQuery.ForEachEntityChunk(EntitySubsystem, Context, ExecuteFunction);
	}

	if (PotentialTargetsNeedingSphereTrace.IsEmpty())
	{
		return;
	}

	TMap<FMassEntityHandle, TArray<FPotentialTarget>> EntityToPotentialTargetEntities;
	TQueue<FMassEntityHandle, EQueueMode::Mpsc> TargetFinderEntityQueue;
	FProcessSphereTracesContext(PotentialTargetsNeedingSphereTrace, *EntitySubsystem.GetWorld(), EntityToPotentialTargetEntities, *TargetFinderSubsystem.Get()).Execute();
	FSelectBestTargetContext(PostSphereTraceEntityQuery, EntitySubsystem, Context, EntityToPotentialTargetEntities, TargetFinderEntityQueue).Execute();

	{
		TRACE_CPUPROFILER_EVENT_SCOPE(UMassEnemyTargetFinderProcessor.ProcessQueues);
		while (!TargetFinderEntityQueue.IsEmpty())
		{
			FMassEntityHandle TargetFinderEntity;
			const bool bSuccess = TargetFinderEntityQueue.Dequeue(TargetFinderEntity);
			check(bSuccess);

			Context.Defer().AddTag<FMassWillNeedEnemyTargetTag>(TargetFinderEntity);
			Context.Defer().RemoveTag<FMassNeedsEnemyTargetTag>(TargetFinderEntity);
		}
	}
}

/*static*/ float UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationZOffset(const bool& bIsSoldier)
{
	return bIsSoldier ? 150.f : 180.f; // TODO: don't hard-code
}

/*static*/ FVector UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationOffset(const FTransform& EntityTransform, const bool& bIsSoldier)
{
	const float ForwardVectorMagnitude = bIsSoldier ? 300.f : 800.f; // TODO: don't hard-code
	const FVector& ProjectileZOffset = FVector(0.f, 0.f, UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationZOffset(bIsSoldier));
	return EntityTransform.GetRotation().GetForwardVector() * ForwardVectorMagnitude + ProjectileZOffset;
}

```

`Source/ProjectM/Private/MassFastAvoidanceProcessors.cpp`:

```cpp
// Copied from engine except uses ParallelForEachEntityChunk.

#include "MassFastAvoidanceProcessors.h"
#include "MassFastAvoidanceTrait.h"
#include "Avoidance/MassAvoidanceFragments.h"
#include "DrawDebugHelpers.h"
#include "MassEntityView.h"
#include "VisualLogger/VisualLogger.h"
#include "Math/Vector2D.h"
#include "Logging/LogMacros.h"
#include "MassSimulationLOD.h"
#include "MassCommonFragments.h"
#include "MassMovementFragments.h"
#include "MassNavigationSubsystem.h"
#include "MassNavigationFragments.h"
#include "MassNavigationUtils.h"
#include "Engine/World.h"

#define UNSAFE_FOR_MT 1

DEFINE_LOG_CATEGORY(LogAvoidance);
DEFINE_LOG_CATEGORY(LogAvoidanceVelocities);
DEFINE_LOG_CATEGORY(LogAvoidanceAgents);
DEFINE_LOG_CATEGORY(LogAvoidanceObstacles);

namespace UE::MassFastAvoidance
{
	namespace Tweakables
	{
		bool bEnableEnvironmentAvoidance = true;
		bool bEnableSettingsforExtendingColliders = true;
		bool bUseAdjacentCorridors = true;
		bool bUseDrawDebugHelpers = false;
	} // Tweakables

	FAutoConsoleVariableRef Vars[] = 
	{
		FAutoConsoleVariableRef(TEXT("pm.ai.mass.avoidance.EnableEnvironmentAvoidance"), Tweakables::bEnableEnvironmentAvoidance, TEXT("Set to false to disable avoidance forces for environment (for debug purposes)."), ECVF_Cheat),
		FAutoConsoleVariableRef(TEXT("pm.ai.mass.avoidance.EnableSettingsforExtendingColliders"), Tweakables::bEnableSettingsforExtendingColliders, TEXT("Set to false to disable using different settings for extending obstacles (for debug purposes)."), ECVF_Cheat),
		FAutoConsoleVariableRef(TEXT("pm.ai.mass.avoidance.UseAdjacentCorridors"), Tweakables::bUseAdjacentCorridors, TEXT("Set to false to disable usage of adjacent lane width."), ECVF_Cheat),
		FAutoConsoleVariableRef(TEXT("pm.ai.mass.avoidance.UseDrawDebugHelpers"), Tweakables::bUseDrawDebugHelpers, TEXT("Use debug draw helpers in addition to visual logs."), ECVF_Cheat)
	};

	constexpr int32 MaxExpectedAgentsPerCell = 6;
	constexpr int32 MinTouchingCellCount = 4;
	constexpr int32 MaxObstacleResults = MaxExpectedAgentsPerCell * MinTouchingCellCount;

	static void FindCloseObstacles(const FVector& Center, const float SearchRadius, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid,
									TArray<FMassNavigationObstacleItem, TFixedAllocator<MaxObstacleResults>>& OutCloseEntities, const int32 MaxResults)
	{
		OutCloseEntities.Reset();
		const FVector Extent(SearchRadius, SearchRadius, 0.f);
		const FBox QueryBox = FBox(Center - Extent, Center + Extent);

		struct FSortingCell
		{
			int32 X;
			int32 Y;
			int32 Level;
			float SqDist;
		};
		TArray<FSortingCell, TInlineAllocator<64>> Cells;
		const FVector QueryCenter = QueryBox.GetCenter();
		
		for (int32 Level = 0; Level < AvoidanceObstacleGrid.NumLevels; Level++)
		{
			const float CellSize = AvoidanceObstacleGrid.GetCellSize(Level);
			const FNavigationObstacleHashGrid2D::FCellRect Rect = AvoidanceObstacleGrid.CalcQueryBounds(QueryBox, Level);
			for (int32 Y = Rect.MinY; Y <= Rect.MaxY; Y++)
			{
				for (int32 X = Rect.MinX; X <= Rect.MaxX; X++)
				{
					const float CenterX = (X + 0.5f) * CellSize;
					const float CenterY = (Y + 0.5f) * CellSize;
					const float DX = CenterX - QueryCenter.X;
					const float DY = CenterY - QueryCenter.Y;
					const float SqDist = DX * DX + DY * DY;
					FSortingCell SortCell;
					SortCell.X = X;
					SortCell.Y = Y;
					SortCell.Level = Level;
					SortCell.SqDist = SqDist;
					Cells.Add(SortCell);
				}
			}
		}

		Cells.Sort([](const FSortingCell& A, const FSortingCell& B) { return A.SqDist < B.SqDist; });

		for (const FSortingCell& SortedCell : Cells)
		{
			if (const FNavigationObstacleHashGrid2D::FCell* Cell = AvoidanceObstacleGrid.FindCell(SortedCell.X, SortedCell.Y, SortedCell.Level))
			{
				const TSparseArray<FNavigationObstacleHashGrid2D::FItem>&  Items = AvoidanceObstacleGrid.GetItems();
				for (int32 Idx = Cell->First; Idx != INDEX_NONE; Idx = Items[Idx].Next)
				{
					OutCloseEntities.Add(Items[Idx].ID);
					if (OutCloseEntities.Num() >= MaxResults)
					{
						return;
					}
				}
			}
		}
	}

	// Adapted from ray-capsule intersection: https://iquilezles.org/www/articles/intersectors/intersectors.htm
	static float ComputeClosestPointOfApproach(const FVector2D Pos, const FVector2D Vel, const float Rad, const FVector2D SegStart, const FVector2D SegEnd, const float TimeHoriz)
	{
		const FVector2D SegDir = SegEnd - SegStart;
		const FVector2D RelPos = Pos - SegStart;
		const float VelSq = FVector2D::DotProduct(Vel, Vel);
		const float SegDirSq = FVector2D::DotProduct(SegDir, SegDir);
		const float DirVelSq = FVector2D::DotProduct(SegDir, Vel);
		const float DirRelPosSq = FVector2D::DotProduct(SegDir, RelPos);
		const float VelRelPosSq = FVector2D::DotProduct(Vel, RelPos);
		const float RelPosSq = FVector2D::DotProduct(RelPos, RelPos);
		const float A = SegDirSq * VelSq - DirVelSq * DirVelSq;
		const float B = SegDirSq * VelRelPosSq - DirRelPosSq * DirVelSq;
		const float C = SegDirSq * RelPosSq - DirRelPosSq * DirRelPosSq - FMath::Square(Rad) * SegDirSq;
		const float H = FMath::Max<float>(0.f, B*B - A*C); // b^2 - ac, Using max for closest point of arrival result when no hit.
		const float T = FMath::Abs(A) > SMALL_NUMBER ? (-B - FMath::Sqrt(H)) / A : 0.f;
		const float Y = DirRelPosSq + T * DirVelSq;
		
		if (Y > 0.f && Y < SegDirSq) 
		{
			return FMath::Clamp(T, 0.f, TimeHoriz);
		}
		else 
		{
			// caps
			const FVector2D CapRelPos = (Y <= 0.f) ? RelPos : Pos - SegEnd;
			const float Cb = FVector2D::DotProduct(Vel, CapRelPos);
			const float Cc = FVector2D::DotProduct(CapRelPos, CapRelPos) - FMath::Square(Rad);
			const float Ch = FMath::Max<float>(0.0f, Cb * Cb - VelSq * Cc);
			const float T1 = VelSq > SMALL_NUMBER ? (-Cb - FMath::Sqrt(Ch)) / VelSq : 0.f;
			return FMath::Clamp(T1, 0.f, TimeHoriz);
		}
	}

	static float ComputeClosestPointOfApproach(const FVector RelPos, const FVector RelVel, const float TotalRadius, const float TimeHoriz)
	{
		// Calculate time of impact based on relative agent positions and velocities.
		const float A = FVector::DotProduct(RelVel, RelVel);
		const float Inv2A = A > SMALL_NUMBER ? 1.f / (2.f * A) : 0.f;
		const float B = FMath::Min(0.f, 2.f * FVector::DotProduct(RelVel, RelPos));
		const float C = FVector::DotProduct(RelPos, RelPos) - FMath::Square(TotalRadius);
		// Using max() here gives us CPA (closest point on arrival) when there is no hit.
		const float Discr = FMath::Sqrt(FMath::Max(0.f, B * B - 4.f * A * C));
		const float T = (-B - Discr) * Inv2A;
		return FMath::Clamp(T, 0.f, TimeHoriz);
	}

	static bool UseDrawDebugHelper()
	{
		return Tweakables::bUseDrawDebugHelpers;
	}

#if WITH_MASSGAMEPLAY_DEBUG	

	// Colors
	static const FColor CurrentAgentColor = FColor::Emerald;

	static const FColor VelocityColor = FColor::Black;
	static const FColor PrefVelocityColor = FColor::Red;
	static const FColor DesiredVelocityColor = FColor::Yellow;
	static const FColor FinalSteeringForceColor = FColor::Cyan;
	static constexpr float BigArrowThickness = 6.f;
	static constexpr float BigArrowHeadSize = 12.f;

	// Agents colors
	static const FColor AgentsColor = FColor::Orange;
	static const FColor AgentSeparationForceColor = FColor(255, 145, 71);	// Orange red
	static const FColor AgentAvoidForceColor = AgentsColor;
	
	// Obstacles colors
	static const FColor ObstacleColor = FColor::Blue;
	static const FColor ObstacleContactNormalColor = FColor::Silver;
	static const FColor ObstacleAvoidForceColor = FColor::Magenta;
	static const FColor ObstacleSeparationForceColor = FColor(255, 66, 66);	// Bright red
	
	static const FVector DebugAgentHeightOffset = FVector(0.f, 0.f, 185.f);
	static const FVector DebugLowCylinderOffset = FVector(0.f, 0.f, 20.f);

	//----------------------------------------------------------------------//
	// Begin MassDebugUtils
	// @todo: Extract those generic debug functions to a separate location
	//----------------------------------------------------------------------//
	struct FDebugContext
	{
		FDebugContext(const UObject* InLogOwner, const FLogCategoryBase& InCategory, const UWorld* InWorld, const FMassEntityHandle InEntity)
			: LogOwner(InLogOwner)
			, Category(InCategory)
			, World(InWorld)
			, Entity(InEntity)
		{}

		const UObject* LogOwner;
		const FLogCategoryBase& Category;
		const UWorld* World;
		const FMassEntityHandle Entity;
	};

	static bool DebugIsSelected(const FMassEntityHandle Entity)
	{
		FColor Color;
		return UE::Mass::Debug::IsDebuggingEntity(Entity, &Color);
	}

	static void DebugDrawLine(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color, const float Thickness = 0.f, const bool bPersistent = false)
	{
		if (!DebugIsSelected(Context.Entity))
		{
			return;
		}

		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, Start, End, Color, (int16)Thickness, TEXT(""));

		if (UseDrawDebugHelper() && Context.World)
		{
			DrawDebugLine(Context.World, Start, End, Color, bPersistent, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
		}
	}

	static void DebugDrawArrow(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color, const float HeadSize = 8.f, const float Thickness = 1.5f)
	{
		if (!DebugIsSelected(Context.Entity))
		{
			return;
		}

		const float Pointyness = 1.8f;
		const FVector Line = End - Start;
		const FVector UnitV = Line.GetSafeNormal();
		const FVector Perp = FVector::CrossProduct(UnitV, FVector::UpVector);
		const FVector Left = Perp - (Pointyness*UnitV);
		const FVector Right = -Perp - (Pointyness*UnitV);
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, Start, End, Color, (int16)Thickness, TEXT(""));
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Left, Color, (int16)Thickness, TEXT(""));
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Right, Color, (int16)Thickness, TEXT(""));

		if (UseDrawDebugHelper() && Context.World)
		{
			DrawDebugLine(Context.World, Start, End, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
			DrawDebugLine(Context.World, End, End + HeadSize * Left, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
			DrawDebugLine(Context.World, End, End + HeadSize * Right, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
		}
	}

	static void DebugDrawSphere(const FDebugContext& Context, const FVector& Center, const float Radius, const FColor& Color)
	{
		if (!DebugIsSelected(Context.Entity))
		{
			return;
		}

		UE_VLOG_LOCATION(Context.LogOwner, Context.Category, Log, Center, Radius, Color, TEXT(""));

		if (UseDrawDebugHelper() && Context.World)
		{
			DrawDebugSphere(Context.World, Center, Radius, /*segments = */16, Color);
		}
	}

	static void DebugDrawBox(const FDebugContext& Context, const FBox& Box, const FColor& Color)
	{
		if (!DebugIsSelected(Context.Entity))
		{
			return;
		}

		UE_VLOG_BOX(Context.LogOwner, Context.Category, Log, Box, Color, TEXT(""));
		
		if (UseDrawDebugHelper() && Context.World)
		{
			DrawDebugBox(Context.World, Box.GetCenter(), Box.GetExtent(), Color);
		}
	}
	
	static void DebugDrawCylinder(const FDebugContext& Context, const FVector& Bottom, const FVector& Top, const float Radius, const FColor& Color, const FString& Text = FString())
	{
		if (!DebugIsSelected(Context.Entity))
		{
			return;
		}

		UE_VLOG_CYLINDER(Context.LogOwner, Context.Category, Log, Bottom, Top, Radius, Color, TEXT("%s"), *Text);

		if (UseDrawDebugHelper() && Context.World)
		{
			DrawDebugCylinder(Context.World, Bottom, Top, Radius, /*segments = */24, Color);
		}
	}
	//----------------------------------------------------------------------//
	// End MassDebugUtils
	//----------------------------------------------------------------------//


	// Local debug utils
	static void DebugDrawVelocity(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color)
	{
		// Different arrow than DebugDrawArrow()
		if (!DebugIsSelected(Context.Entity))
		{
			return;
		}

		const float Thickness = 3.f;
		const float Pointyness = 1.8f;
		const FVector Line = End - Start;
		const FVector UnitV = Line.GetSafeNormal();
		const FVector Perp = FVector::CrossProduct(UnitV, FVector::UpVector);
		const FVector Left = Perp - (Pointyness * UnitV);
		const FVector Right = -Perp - (Pointyness * UnitV);
		const float HeadSize = 0.08f * Line.Size();
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, Start, End, Color, (int16)Thickness, TEXT(""));
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Left, Color, (int16)Thickness, TEXT(""));
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End, End + HeadSize * Right, Color, (int16)Thickness, TEXT(""));
		UE_VLOG_SEGMENT_THICK(Context.LogOwner, Context.Category, Log, End + HeadSize * Left, End + HeadSize * Right, Color, (int16)Thickness, TEXT(""));

		if (UseDrawDebugHelper() && Context.World)
		{
			DrawDebugLine(Context.World, Start, End, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
			DrawDebugLine(Context.World, End, End + HeadSize * Left, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
			DrawDebugLine(Context.World, End, End + HeadSize * Right, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
			DrawDebugLine(Context.World, End + HeadSize * Left, End + HeadSize * Right, Color, /*bPersistent=*/ false, /*LifeTime =*/ -1.f, /*DepthPriority =*/ 0, Thickness);
		}
	}

	static void DebugDrawForce(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color)
	{
		DebugDrawArrow(Context, Start, End, Color, /*HeadSize*/4.f, /*Thickness*/3.f);
	}

	static void DebugDrawSummedForce(const FDebugContext& Context, const FVector& Start, const FVector& End, const FColor& Color)
	{
		DebugDrawArrow(Context, Start + FVector(0.f,0.f,1.f), End + FVector(0.f, 0.f, 1.f), Color, /*HeadSize*/8.f, /*Thickness*/6.f);
	}

#endif // WITH_MASSGAMEPLAY_DEBUG

} // namespace UE::MassFastAvoidance


//----------------------------------------------------------------------//
//  UMassFastMovingAvoidanceProcessor
//----------------------------------------------------------------------//
UMassFastMovingAvoidanceProcessor::UMassFastMovingAvoidanceProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Avoidance;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::LOD);
}

void UMassFastMovingAvoidanceProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassForceFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassNavigationEdgesFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddTagRequirement<FMassMediumLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddTagRequirement<FMassLowLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddConstSharedRequirement<FMassFastMovingAvoidanceParameters>(EMassFragmentPresence::All);
	EntityQuery.AddConstSharedRequirement<FMassMovementParameters>(EMassFragmentPresence::All);
}

void UMassFastMovingAvoidanceProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	World = Owner.GetWorld();
	NavigationSubsystem = UWorld::GetSubsystem<UMassNavigationSubsystem>(Owner.GetWorld());
}

void UMassFastMovingAvoidanceProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	QUICK_SCOPE_CYCLE_COUNTER(UMassFastMovingAvoidanceProcessor);

	if (!World || !NavigationSubsystem)
	{
		return;
	}

	EntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const float DeltaTime = Context.GetDeltaTimeSeconds();
		const float CurrentTime = World->GetTimeSeconds();
		const int32 NumEntities = Context.GetNumEntities();
		
		const TArrayView<FMassForceFragment> ForceList = Context.GetMutableFragmentView<FMassForceFragment>();
		const TConstArrayView<FMassNavigationEdgesFragment> NavEdgesList = Context.GetFragmentView<FMassNavigationEdgesFragment>();
		const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();
		const TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		const TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();
		const FMassFastMovingAvoidanceParameters& MovingAvoidanceParams = Context.GetConstSharedFragment<FMassFastMovingAvoidanceParameters>();
		const FMassMovementParameters& MovementParams = Context.GetConstSharedFragment<FMassMovementParameters>();

		const float InvPredictiveAvoidanceTime = 1.0f / MovingAvoidanceParams.PredictiveAvoidanceTime;

		// Arrays used to store close obstacles
		TArray<FMassNavigationObstacleItem, TFixedAllocator<UE::MassFastAvoidance::MaxObstacleResults>> CloseEntities;

		// Used for storing sorted list or nearest obstacles.
		struct FSortedObstacle
		{
			FVector LocationCached;
			FVector Forward;
			FMassNavigationObstacleItem ObstacleItem;
			float SqDist;
		};
		TArray<FSortedObstacle, TFixedAllocator<UE::MassFastAvoidance::MaxObstacleResults>> ClosestObstacles;

		// Potential contact between agent and environment. 
		struct FEnvironmentContact
		{
			FVector Position = FVector::ZeroVector;
			FVector Normal = FVector::ZeroVector;
			float Distance = 0.f;
		};
		TArray<FEnvironmentContact, TInlineAllocator<16>> Contacts;

		// Describes collider to avoid, collected from neighbour obstacles.
		struct FCollider
		{
			FVector Location = FVector::ZeroVector;
			FVector Velocity = FVector::ZeroVector;
			float Radius = 0.f;
			bool bCanAvoid = true;
			bool bIsMoving = false;
		};
		TArray<FCollider, TInlineAllocator<16>> Colliders;

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			// @todo: this check should eventually be part of the query (i.e. only handle moving agents).
			const FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];
			if (MoveTarget.GetCurrentAction() == EMassMovementAction::Animate || MoveTarget.GetCurrentAction() == EMassMovementAction::Stand)
			{
				continue;
			}

			FMassEntityHandle Entity = Context.GetEntity(EntityIndex);
			const FMassNavigationEdgesFragment& NavEdges = NavEdgesList[EntityIndex];
			const FTransformFragment& Location = LocationList[EntityIndex];
			const FMassVelocityFragment& Velocity = VelocityList[EntityIndex];
			const FAgentRadiusFragment& Radius = RadiusList[EntityIndex];
			FMassForceFragment& Force = ForceList[EntityIndex];

			// Smaller steering max accel makes the steering more "calm" but less opportunistic, may not find solution, or gets stuck.
			// Max contact accel should be quite a big bigger than steering so that collision response is firm. 
			const float MaxSteerAccel = MovementParams.MaxAcceleration;
			const float MaximumSpeed = MovementParams.MaxSpeed;

			const FVector AgentLocation = Location.GetTransform().GetTranslation();
			const FVector AgentVelocity = FVector(Velocity.Value.X, Velocity.Value.Y, 0.0f);
			
			const float AgentRadius = Radius.Radius;
			const float SeparationAgentRadius = Radius.Radius * MovingAvoidanceParams.SeparationRadiusScale;
			const float PredictiveAvoidanceAgentRadius = Radius.Radius * MovingAvoidanceParams.PredictiveAvoidanceRadiusScale;
			
			FVector SteeringForce = Force.Value;

			// Near start and end fades are used to subdue the avoidance at the start and end of the path.
			float NearStartFade = 1.0f;
			float NearEndFade = 1.0f;

			if (MoveTarget.GetPreviousAction() != EMassMovementAction::Move)
			{
				// Fade in avoidance when transitioning from other than move action.
				// I.e. the standing behavior may move the agents so close to each,
				// and that causes the separation to push them out quickly when avoidance is activated. 
				NearStartFade = FMath::Min((CurrentTime - MoveTarget.GetCurrentActionStartTime()) / MovingAvoidanceParams.StartOfPathDuration, 1.0f);
			}

			if (MoveTarget.IntentAtGoal == EMassMovementAction::Stand)
			{
				// Estimate approach based on current desired speed.
				const float ApproachDistance = FMath::Max(1.0f, MovingAvoidanceParams.EndOfPathDuration * MoveTarget.DesiredSpeed.Get());
				NearEndFade = FMath::Clamp(MoveTarget.DistanceToGoal / ApproachDistance, 0.f, 1.f);
			}
			
			const float NearStartScaling = FMath::Lerp(MovingAvoidanceParams.StartOfPathAvoidanceScale, 1.0f, NearStartFade);
			const float NearEndScaling = FMath::Lerp(MovingAvoidanceParams.EndOfPathAvoidanceScale, 1.0f, NearEndFade);
			
#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
			const UE::MassFastAvoidance::FDebugContext BaseDebugContext(this, LogAvoidance, World, Entity);
			const UE::MassFastAvoidance::FDebugContext VelocitiesDebugContext(this, LogAvoidanceVelocities, World, Entity);
			const UE::MassFastAvoidance::FDebugContext ObstacleDebugContext(this, LogAvoidanceObstacles, World, Entity);
			const UE::MassFastAvoidance::FDebugContext AgentDebugContext(this, LogAvoidanceAgents, World, Entity);
			
			if (UE::MassFastAvoidance::DebugIsSelected(Entity))
			{
				// Draw agent
				const FString Text = FString::Printf(TEXT("%i"), Entity.Index);
				DebugDrawCylinder(BaseDebugContext, AgentLocation, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentRadius+1.f, UE::MassFastAvoidance::CurrentAgentColor, Text);

				DebugDrawSphere(BaseDebugContext, AgentLocation, 10.f, UE::MassFastAvoidance::CurrentAgentColor);

				// Draw current velocity (black)
				DebugDrawVelocity(VelocitiesDebugContext, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + AgentVelocity, UE::MassFastAvoidance::VelocityColor);

				// Draw preferred velocity (red)
//				DebugDrawVelocity(VelocitiesDebugContext, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + PrefVelocity, UE::MassFastAvoidance::PrefVelocityColor);

				// Draw initial steering force
				DebugDrawArrow(BaseDebugContext, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentLocation +UE::MassFastAvoidance:: DebugAgentHeightOffset + SteeringForce, UE::MassFastAvoidance::CurrentAgentColor, UE::MassFastAvoidance::BigArrowHeadSize, UE::MassFastAvoidance::BigArrowThickness);

				// Draw center
				DebugDrawSphere(BaseDebugContext, AgentLocation, /*Radius*/2.f, UE::MassFastAvoidance::CurrentAgentColor);
			}
#endif // WITH_MASSGAMEPLAY_DEBUG

			FVector OldSteeringForce = FVector::ZeroVector;

			//////////////////////////////////////////////////////////////////////////
			// Environment avoidance.
			//
			
			if (!MoveTarget.bOffBoundaries && UE::MassFastAvoidance::Tweakables::bEnableEnvironmentAvoidance)
			{
				const FVector DesiredAcceleration = UE::MassNavigation::ClampVector(SteeringForce, MaxSteerAccel);
				const FVector DesiredVelocity = UE::MassNavigation::ClampVector(AgentVelocity + DesiredAcceleration * DeltaTime, MaximumSpeed);

#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
				// Draw desired velocity (yellow)
				UE::MassFastAvoidance::DebugDrawVelocity(VelocitiesDebugContext, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + DesiredVelocity, UE::MassFastAvoidance::DesiredVelocityColor);
#endif // WITH_MASSGAMEPLAY_DEBUG

				OldSteeringForce = SteeringForce;
				Contacts.Reset();

				// Collect potential contacts between agent and environment edges.
				for (const FNavigationAvoidanceEdge& Edge : NavEdges.AvoidanceEdges)
				{
					const FVector EdgeDiff = Edge.End - Edge.Start;
					FVector EdgeDir = FVector::ZeroVector;
					float EdgeLength = 0.0f;
					EdgeDiff.ToDirectionAndLength(EdgeDir, EdgeLength);

					const FVector AgentToEdgeStart = AgentLocation - Edge.Start;
					const float DistAlongEdge = FVector::DotProduct(EdgeDir, AgentToEdgeStart);
					const float DistAwayFromEdge = FVector::DotProduct(Edge.LeftDir, AgentToEdgeStart);

					float ConDist = 0.0f;
					FVector ConNorm = FVector::ForwardVector;
					FVector ConPos = FVector::ZeroVector;
					bool bDirectlyBehindEdge = false;
					
					if (DistAwayFromEdge < 0.0f)
					{
						// Inside or behind the edge
						if (DistAlongEdge < 0.0f)
						{
							ConPos = Edge.Start;
							ConNorm = -EdgeDir;
							ConDist = -DistAlongEdge;
						}
						else if (DistAlongEdge > EdgeLength)
						{
							ConPos = Edge.End;
							ConNorm = EdgeDir;
							ConDist = DistAlongEdge;
						}
						else
						{
							ConPos = Edge.Start + EdgeDir * DistAlongEdge;
							ConNorm = Edge.LeftDir;
							ConDist = 0.0f;
							bDirectlyBehindEdge = true;
						}
					}
					else
					{
						if (DistAlongEdge < 0.0f)
						{
							// Start Corner
							ConPos = Edge.Start;
							EdgeDiff.ToDirectionAndLength(ConNorm, ConDist);
						}
						else if (DistAlongEdge > EdgeLength)
						{
							// End Corner
							ConPos = Edge.End;
							EdgeDiff.ToDirectionAndLength(ConNorm, ConDist);
						}
						else
						{
							// Front
							ConPos = Edge.Start + EdgeDir * DistAlongEdge;
							ConNorm = Edge.LeftDir;
							ConDist = DistAwayFromEdge;
						}
					}
					
					// Check to merge contacts
					bool bAdd = true;
					for (int ContactIndex = 0; ContactIndex < Contacts.Num(); ContactIndex++)
					{
						if (FVector::DotProduct(Contacts[ContactIndex].Normal, ConNorm) > 0.f && FMath::Abs(FVector::DotProduct(ConNorm, Contacts[ContactIndex].Position - ConPos)) < (10.f/*cm*/))
						{
							// Contacts are on same place, merge
							if (ConDist < Contacts[ContactIndex].Distance)
							{
								// New is closer, override.
								Contacts[ContactIndex].Position = ConPos;
								Contacts[ContactIndex].Normal = ConNorm;
								Contacts[ContactIndex].Distance = ConDist;
							}
							bAdd = false;
							break;
						}
					}

					// Not found, add new contact
					if (bAdd)
					{
						FEnvironmentContact Contact;
						Contact.Position = ConPos;
						Contact.Normal = ConNorm;
						Contact.Distance = ConDist;
						Contacts.Add(Contact);
					}

					// Skip predictive avoidance when behind the edge.
					if (!bDirectlyBehindEdge)
					{
						// Avoid edges
						const float CPA = UE::MassFastAvoidance::ComputeClosestPointOfApproach(FVector2D(AgentLocation), FVector2D(DesiredVelocity), AgentRadius,
							FVector2D(Edge.Start), FVector2D(Edge.End), MovingAvoidanceParams.PredictiveAvoidanceTime);
						const FVector HitAgentPos = AgentLocation + DesiredVelocity * CPA;
						const float EdgeT = UE::MassNavigation::ProjectPtSeg(FVector2D(HitAgentPos), FVector2D(Edge.Start), FVector2D(Edge.End));
						const FVector HitObPos = FMath::Lerp(Edge.Start, Edge.End, EdgeT);

						// Calculate penetration at CPA
						FVector AvoidRelPos = HitAgentPos - HitObPos;
						AvoidRelPos.Z = 0.f;	// @todo AT: ignore the z component for now until we clamp the height of obstacles
						const float AvoidDist = AvoidRelPos.Size();
						const FVector AvoidNormal = AvoidDist > 0.0f ? (AvoidRelPos / AvoidDist) : FVector::ForwardVector;

						const float AvoidPen = (PredictiveAvoidanceAgentRadius + MovingAvoidanceParams.PredictiveAvoidanceDistance) - AvoidDist;
						const float AvoidMag = FMath::Square(FMath::Clamp(AvoidPen / MovingAvoidanceParams.PredictiveAvoidanceDistance, 0.f, 1.f));
						const float AvoidMagDist = 1.f + FMath::Square(1.f - CPA * InvPredictiveAvoidanceTime);
						const FVector AvoidForce = AvoidNormal * AvoidMag * AvoidMagDist * MovingAvoidanceParams.EnvironmentPredictiveAvoidanceStiffness * NearEndScaling; // Predictive avoidance against environment is tuned down towards the end of the path

						SteeringForce += AvoidForce;

#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
						// Draw contact normal
						UE::MassFastAvoidance::DebugDrawArrow(ObstacleDebugContext, ConPos, ConPos + 50.f * ConNorm, UE::MassFastAvoidance::ObstacleContactNormalColor, /*HeadSize=*/ 5.f);
						UE::MassFastAvoidance::DebugDrawSphere(ObstacleDebugContext, ConPos, 2.5f, UE::MassFastAvoidance::ObstacleContactNormalColor);

						// Draw hit pos with edge
						UE::MassFastAvoidance::DebugDrawLine(ObstacleDebugContext, AgentLocation, HitAgentPos, UE::MassFastAvoidance::ObstacleAvoidForceColor);
						UE::MassFastAvoidance::DebugDrawCylinder(ObstacleDebugContext, HitAgentPos, HitAgentPos + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentRadius, UE::MassFastAvoidance::ObstacleAvoidForceColor);

						// Draw avoid obstacle force
						UE::MassFastAvoidance::DebugDrawForce(ObstacleDebugContext, HitObPos, HitObPos + AvoidForce, UE::MassFastAvoidance::ObstacleAvoidForceColor);
#endif // WITH_MASSGAMEPLAY_DEBUG
					}
				} // edge loop

#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
				// Draw total steering force to avoid obstacles
				const FVector EnvironmentAvoidSteeringForce = SteeringForce - OldSteeringForce;
				UE::MassFastAvoidance::DebugDrawSummedForce(ObstacleDebugContext,
					AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset,
					AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + EnvironmentAvoidSteeringForce,
					UE::MassFastAvoidance::ObstacleAvoidForceColor);
#endif // WITH_MASSGAMEPLAY_DEBUG

				// Process contacts to add edge separation force
				const FVector SteeringForceBeforeSeparation = SteeringForce;
				for (int ContactIndex = 0; ContactIndex < Contacts.Num(); ContactIndex++) 
				{
					const FVector ConNorm = Contacts[ContactIndex].Normal.GetSafeNormal();
					const float ContactDist = Contacts[ContactIndex].Distance;

					// Separation force (stay away from obstacles if possible)
					const float SeparationPenalty = (SeparationAgentRadius + MovingAvoidanceParams.EnvironmentSeparationDistance) - ContactDist;
					const float SeparationMag = UE::MassNavigation::Smooth(FMath::Clamp(SeparationPenalty / MovingAvoidanceParams.EnvironmentSeparationDistance, 0.f, 1.f));
					const FVector SeparationForce = ConNorm * MovingAvoidanceParams.EnvironmentSeparationStiffness * SeparationMag;

					SteeringForce += SeparationForce;

#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
					// Draw individual contact forces
					DebugDrawForce(ObstacleDebugContext, Contacts[ContactIndex].Position + UE::MassFastAvoidance::DebugAgentHeightOffset,
					Contacts[ContactIndex].Position + SeparationForce + UE::MassFastAvoidance::DebugAgentHeightOffset, UE::MassFastAvoidance::ObstacleSeparationForceColor);
#endif // WITH_MASSGAMEPLAY_DEBUG
				}
				
#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
				// Draw total steering force to separate from close edges
				const FVector TotalSeparationForce = SteeringForce - SteeringForceBeforeSeparation;
				DebugDrawSummedForce(ObstacleDebugContext,
					AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset,
					AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + TotalSeparationForce,
					UE::MassFastAvoidance::ObstacleSeparationForceColor);

				// Display close obstacle edges
				if (UE::MassFastAvoidance::DebugIsSelected(Entity))
				{
					for (const FNavigationAvoidanceEdge& Edge : NavEdges.AvoidanceEdges)
					{
						DebugDrawLine(ObstacleDebugContext, UE::MassFastAvoidance::DebugAgentHeightOffset + Edge.Start,
							UE::MassFastAvoidance::DebugAgentHeightOffset + Edge.End, UE::MassFastAvoidance::ObstacleColor, /*Thickness=*/2.f);
						const FVector Middle = UE::MassFastAvoidance::DebugAgentHeightOffset + 0.5f * (Edge.Start + Edge.End);
						DebugDrawArrow(ObstacleDebugContext, Middle, Middle + 10.f * FVector::CrossProduct((Edge.End - Edge.Start), FVector::UpVector).GetSafeNormal(), UE::MassFastAvoidance::ObstacleColor, /*HeadSize=*/2.f);
					}
				}
#endif // WITH_MASSGAMEPLAY_DEBUG
			}

			//////////////////////////////////////////////////////////////////////////
			// Avoid close agents

			// Update desired velocity based on avoidance so far.
			const FVector DesAcc = UE::MassNavigation::ClampVector(SteeringForce, MaxSteerAccel);
			const FVector DesVel = UE::MassNavigation::ClampVector(AgentVelocity + DesAcc * DeltaTime, MaximumSpeed);

			// Find close obstacles
			const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid = NavigationSubsystem->GetObstacleGridMutable();
			UE::MassFastAvoidance::FindCloseObstacles(AgentLocation, MovingAvoidanceParams.ObstacleDetectionDistance, AvoidanceObstacleGrid, CloseEntities, UE::MassFastAvoidance::MaxObstacleResults);

			// Remove unwanted and find the closests in the CloseEntities
			const float DistanceCutOffSqr = FMath::Square(MovingAvoidanceParams.ObstacleDetectionDistance);
			ClosestObstacles.Reset();
			for (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : CloseEntities)
			{
				// Skip self
				if (OtherEntity.Entity == Entity)
				{
					continue;
				}

				// Skip invalid entities.
				if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
				{
					UE_LOG(LogAvoidanceObstacles, VeryVerbose, TEXT("Close entity is invalid, skipped."));
					continue;
				}
				
				// Skip too far
				const FTransform& Transform = EntitySubsystem.GetFragmentDataChecked<FTransformFragment>(OtherEntity.Entity).GetTransform();
				const FVector OtherLocation = Transform.GetLocation();
				
				const float SqDist = FVector::DistSquared(AgentLocation, OtherLocation);
				if (SqDist > DistanceCutOffSqr)
				{
					continue;
				}

				FSortedObstacle Obstacle;
				Obstacle.LocationCached = OtherLocation;
				Obstacle.Forward = Transform.GetRotation().GetForwardVector();
				Obstacle.ObstacleItem = OtherEntity;
				Obstacle.SqDist = SqDist;
				ClosestObstacles.Add(Obstacle);
			}
			ClosestObstacles.Sort([](const FSortedObstacle& A, const FSortedObstacle& B) { return A.SqDist < B.SqDist; });

			// Compute forces
			OldSteeringForce = SteeringForce;
			FVector TotalAgentSeparationForce = FVector::ZeroVector;

			// Fill collider list from close agents
			Colliders.Reset();
			constexpr int32 MaxColliders = 6;
			for (int32 Index = 0; Index < ClosestObstacles.Num(); Index++)
			{
				if (Colliders.Num() >= MaxColliders)
				{
					break;
				}

				FSortedObstacle& Obstacle = ClosestObstacles[Index];
				FMassEntityView OtherEntityView(EntitySubsystem, Obstacle.ObstacleItem.Entity);

				const FMassVelocityFragment* OtherVelocityFragment = OtherEntityView.GetFragmentDataPtr<FMassVelocityFragment>();
				const FVector OtherVelocity = OtherVelocityFragment != nullptr ? OtherVelocityFragment->Value : FVector::ZeroVector; // Get velocity from FAvoidanceComponent

				// @todo: this is heavy fragment to access, see if we could handle this differently.
				const FMassMoveTargetFragment* OtherMoveTarget = OtherEntityView.GetFragmentDataPtr<FMassMoveTargetFragment>();
				const bool bCanAvoid = OtherMoveTarget != nullptr;
				const bool bOtherIsMoving = OtherMoveTarget ? OtherMoveTarget->GetCurrentAction() == EMassMovementAction::Move : true; // Assume moving if other does not have move target.
				
				// Check for colliders data
				if (EnumHasAnyFlags(Obstacle.ObstacleItem.ItemFlags, EMassNavigationObstacleFlags::HasColliderData))
				{
					if (const FMassAvoidanceColliderFragment* ColliderFragment = OtherEntityView.GetFragmentDataPtr<FMassAvoidanceColliderFragment>())
					{
						if (ColliderFragment->Type == EMassColliderType::Circle)
						{
							const FMassCircleCollider Circle = ColliderFragment->GetCircleCollider();
							
							FCollider& Collider = Colliders.AddDefaulted_GetRef();
							Collider.Velocity = OtherVelocity;
							Collider.bCanAvoid = bCanAvoid;
							Collider.bIsMoving = bOtherIsMoving;
							Collider.Radius = Circle.Radius;
							Collider.Location = Obstacle.LocationCached;
						}
						else if (ColliderFragment->Type == EMassColliderType::Pill)
						{
							const FMassPillCollider Pill = ColliderFragment->GetPillCollider(); 

							FCollider& Collider = Colliders.AddDefaulted_GetRef();
							Collider.Velocity = OtherVelocity;
							Collider.bCanAvoid = bCanAvoid;
							Collider.bIsMoving = bOtherIsMoving;
							Collider.Radius = Pill.Radius;
							Collider.Location = Obstacle.LocationCached + (Pill.HalfLength * Obstacle.Forward);

							if (Colliders.Num() < MaxColliders)
							{
								FCollider& Collider2 = Colliders.AddDefaulted_GetRef();
								Collider2.Velocity = OtherVelocity;
								Collider2.bCanAvoid = bCanAvoid;
								Collider2.bIsMoving = bOtherIsMoving;
								Collider2.Radius = Pill.Radius;
								Collider2.Location = Obstacle.LocationCached + (-Pill.HalfLength * Obstacle.Forward);
							}
						}
					}
				}
				else
				{
					FCollider& Collider = Colliders.AddDefaulted_GetRef();
					Collider.Location = Obstacle.LocationCached;
					Collider.Velocity = OtherVelocity;
					Collider.Radius = OtherEntityView.GetFragmentData<FAgentRadiusFragment>().Radius;
					Collider.bCanAvoid = bCanAvoid;
					Collider.bIsMoving = bOtherIsMoving;
				}
			}

			// Process colliders for avoidance
			for (const FCollider& Collider : Colliders)
			{
				bool bHasForcedNormal = false;
				FVector ForcedNormal = FVector::ZeroVector;

				if (Collider.bCanAvoid == false)
				{
					// If the other obstacle cannot avoid us, try to avoid the local minima they create between the wall and their collider.
					// If the space between edge and collider is less than MinClearance, make the agent to avoid the gap.
					const float MinClearance = 2.f * AgentRadius * MovingAvoidanceParams. StaticObstacleClearanceScale;
					
					// Find the maximum distance from edges that are too close.
					float MaxDist = -1.f;
					FVector ClosestPoint;
					for (const FNavigationAvoidanceEdge& Edge : NavEdges.AvoidanceEdges)
					{
						const FVector Point = FMath::ClosestPointOnSegment(Collider.Location, Edge.Start, Edge.End);
						const FVector Offset = Collider.Location - Point;
						if (FVector::DotProduct(Offset, Edge.LeftDir) < 0.f)
						{
							// Behind the edge, ignore.
							continue;
						}

						const float OffsetLength = Offset.Length();
						const bool bTooNarrow = (OffsetLength - Collider.Radius) < MinClearance; 
						if (bTooNarrow)
						{
							if (OffsetLength > MaxDist)
							{
								MaxDist = OffsetLength;
								ClosestPoint = Point;
							}
						}
					}

					if (MaxDist != -1.f)
					{
						// Set up forced normal to avoid the gap between collider and edge.
						ForcedNormal = (Collider.Location - ClosestPoint).GetSafeNormal();
						bHasForcedNormal = true;
					}
				}

				FVector RelPos = AgentLocation - Collider.Location;
				RelPos.Z = 0.f; // we assume we work on a flat plane for now
				const FVector RelVel = DesVel - Collider.Velocity;
				const float ConDist = RelPos.Size();
				const FVector ConNorm = ConDist > 0.f ? RelPos / ConDist : FVector::ForwardVector;

				FVector SeparationNormal = ConNorm;
				if (bHasForcedNormal)
				{
					// The more head on the collisions is, the more we should avoid towards the forced direction.
					const FVector RelVelNorm = RelVel.GetSafeNormal();
					const float Blend = FMath::Max(0.0f, -FVector::DotProduct(ConNorm, RelVelNorm));
					SeparationNormal = FMath::Lerp(ConNorm, ForcedNormal, Blend).GetSafeNormal();
				}
				
				const float StandingScaling = Collider.bIsMoving ? 1.0f : MovingAvoidanceParams.StandingObstacleAvoidanceScale; // Care less about standing agents so that we can push through standing crowd.
				
				// Separation force (stay away from agents if possible)
				const float PenSep = (SeparationAgentRadius + Collider.Radius + MovingAvoidanceParams.ObstacleSeparationDistance) - ConDist;
				const float SeparationMag = FMath::Square(FMath::Clamp(PenSep / MovingAvoidanceParams.ObstacleSeparationDistance, 0.f, 1.f));
				const FVector SepForce = SeparationNormal * MovingAvoidanceParams.ObstacleSeparationStiffness;
				const FVector SeparationForce = SepForce * SeparationMag * StandingScaling;

				SteeringForce += SeparationForce;
				TotalAgentSeparationForce += SeparationForce;

				// Calculate closest point of approach based on relative agent positions and velocities.
				const float CPA = UE::MassFastAvoidance::ComputeClosestPointOfApproach(RelPos, RelVel, PredictiveAvoidanceAgentRadius + Collider.Radius, MovingAvoidanceParams.PredictiveAvoidanceTime);

				// Calculate penetration at CPA
				const FVector AvoidRelPos = RelPos + RelVel * CPA;
				const float AvoidDist = AvoidRelPos.Size();
				const FVector AvoidConNormal = AvoidDist > 0.0f ? (AvoidRelPos / AvoidDist) : FVector::ForwardVector;

				FVector AvoidNormal = AvoidConNormal;
				if (bHasForcedNormal)
				{
					// The more head on the predicted collisions is, the more we should avoid towards the forced direction.
					const FVector RelVelNorm = RelVel.GetSafeNormal();
					const float Blend = FMath::Max(0.0f, -FVector::DotProduct(AvoidConNormal, RelVelNorm));
					AvoidNormal = FMath::Lerp(AvoidConNormal, ForcedNormal, Blend).GetSafeNormal();
				}
				
				const float AvoidPenetration = (PredictiveAvoidanceAgentRadius + Collider.Radius + MovingAvoidanceParams.PredictiveAvoidanceDistance) - AvoidDist; // Based on future agents distance
				const float AvoidMag = FMath::Square(FMath::Clamp(AvoidPenetration / MovingAvoidanceParams.PredictiveAvoidanceDistance, 0.f, 1.f));
				const float AvoidMagDist = (1.f - (CPA * InvPredictiveAvoidanceTime)); // No clamp, CPA is between 0 and PredictiveAvoidanceTime
				const FVector AvoidForce = AvoidNormal * AvoidMag * AvoidMagDist * MovingAvoidanceParams.ObstaclePredictiveAvoidanceStiffness * StandingScaling;

				SteeringForce += AvoidForce;

#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
				// Display close agent
				UE::MassFastAvoidance::DebugDrawCylinder(AgentDebugContext, Collider.Location, Collider.Location + UE::MassFastAvoidance::DebugLowCylinderOffset, Collider.Radius, UE::MassFastAvoidance::AgentsColor);

				if (bHasForcedNormal)
				{
					UE::MassFastAvoidance::DebugDrawCylinder(BaseDebugContext, Collider.Location, Collider.Location + UE::MassFastAvoidance::DebugAgentHeightOffset, Collider.Radius, FColor::Red);
				}

				// Draw agent contact separation force
				UE::MassFastAvoidance::DebugDrawSummedForce(AgentDebugContext,
					Collider.Location + UE::MassFastAvoidance::DebugAgentHeightOffset,
					Collider.Location + UE::MassFastAvoidance::DebugAgentHeightOffset + SeparationForce,
					UE::MassFastAvoidance::AgentSeparationForceColor); 
				
				if (AvoidForce.Size() > 0.f)
				{
					// Draw agent vs agent hit positions
					const FVector HitPosition = AgentLocation + (DesVel * CPA);
					const FVector LeftOffset = PredictiveAvoidanceAgentRadius * UE::MassNavigation::GetLeftDirection(DesVel.GetSafeNormal(), FVector::UpVector);
					UE::MassFastAvoidance::DebugDrawLine(AgentDebugContext, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + LeftOffset, HitPosition + UE::MassFastAvoidance::DebugAgentHeightOffset + LeftOffset, UE::MassFastAvoidance::CurrentAgentColor, 1.5f);
					UE::MassFastAvoidance::DebugDrawLine(AgentDebugContext, AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset - LeftOffset, HitPosition + UE::MassFastAvoidance::DebugAgentHeightOffset - LeftOffset, UE::MassFastAvoidance::CurrentAgentColor, 1.5f);
					UE::MassFastAvoidance::DebugDrawCylinder(AgentDebugContext, HitPosition, HitPosition + UE::MassFastAvoidance::DebugAgentHeightOffset, PredictiveAvoidanceAgentRadius, UE::MassFastAvoidance::CurrentAgentColor);

					const FVector OtherHitPosition = Collider.Location + (Collider.Velocity * CPA);
					const FVector OtherLeftOffset = Collider.Radius * UE::MassNavigation::GetLeftDirection(Collider.Velocity.GetSafeNormal(), FVector::UpVector);
					const FVector Left = UE::MassFastAvoidance::DebugAgentHeightOffset + OtherLeftOffset;
					const FVector Right = UE::MassFastAvoidance::DebugAgentHeightOffset - OtherLeftOffset;
					UE::MassFastAvoidance::DebugDrawLine(AgentDebugContext, Collider.Location + Left, OtherHitPosition + Left, UE::MassFastAvoidance::AgentsColor, 1.5f);
					UE::MassFastAvoidance::DebugDrawLine(AgentDebugContext, Collider.Location + Right, OtherHitPosition + Right, UE::MassFastAvoidance::AgentsColor, 1.5f);
					UE::MassFastAvoidance::DebugDrawCylinder(AgentDebugContext, Collider.Location, Collider.Location + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentRadius, UE::MassFastAvoidance::AgentsColor);
					UE::MassFastAvoidance::DebugDrawCylinder(AgentDebugContext, OtherHitPosition, OtherHitPosition + UE::MassFastAvoidance::DebugAgentHeightOffset, AgentRadius, UE::MassFastAvoidance::AgentsColor);

					// Draw agent avoid force
					UE::MassFastAvoidance::DebugDrawForce(AgentDebugContext,
						OtherHitPosition + UE::MassFastAvoidance::DebugAgentHeightOffset,
						OtherHitPosition + UE::MassFastAvoidance::DebugAgentHeightOffset + AvoidForce,
						UE::MassFastAvoidance::AgentAvoidForceColor);
				}
#endif // WITH_MASSGAMEPLAY_DEBUG
			} // close entities loop

			SteeringForce *= NearStartScaling * NearEndScaling;
			
			Force.Value = UE::MassNavigation::ClampVector(SteeringForce, MaxSteerAccel); // Assume unit mass

#if WITH_MASSGAMEPLAY_DEBUG && UNSAFE_FOR_MT
			const FVector AgentAvoidSteeringForce = SteeringForce - OldSteeringForce;

			// Draw total steering force to separate agents
			UE::MassFastAvoidance::DebugDrawSummedForce(AgentDebugContext,
				AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset,
				AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + TotalAgentSeparationForce,
				UE::MassFastAvoidance::AgentSeparationForceColor);

			// Draw total steering force to avoid agents
			UE::MassFastAvoidance::DebugDrawSummedForce(AgentDebugContext,
				AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset,
				AgentLocation + UE::MassFastAvoidance::DebugAgentHeightOffset + AgentAvoidSteeringForce,
				UE::MassFastAvoidance::AgentAvoidForceColor);

			// Draw final steering force adding to the agent velocity
			UE::MassFastAvoidance::DebugDrawArrow(BaseDebugContext, 
				AgentLocation + AgentVelocity + UE::MassFastAvoidance::DebugAgentHeightOffset,
				AgentLocation + AgentVelocity + UE::MassFastAvoidance::DebugAgentHeightOffset + Force.Value,
				UE::MassFastAvoidance::FinalSteeringForceColor, UE::MassFastAvoidance::BigArrowHeadSize, UE::MassFastAvoidance::BigArrowThickness);
#endif // WITH_MASSGAMEPLAY_DEBUG
		}
	});
}

//----------------------------------------------------------------------//
//  UMassFastStandingAvoidanceProcessor
//----------------------------------------------------------------------//
UMassFastStandingAvoidanceProcessor::UMassFastStandingAvoidanceProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Avoidance;
	ExecutionOrder.ExecuteAfter.Add(TEXT("MassFastMovingAvoidanceProcessor"));
}

void UMassFastStandingAvoidanceProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassGhostLocationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassNavigationEdgesFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddTagRequirement<FMassMediumLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddTagRequirement<FMassLowLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddTagRequirement<FMassOffLODTag>(EMassFragmentPresence::None);
	EntityQuery.AddConstSharedRequirement<FMassFastStandingAvoidanceParameters>(EMassFragmentPresence::All);
}

void UMassFastStandingAvoidanceProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	World = Owner.GetWorld();
	NavigationSubsystem = UWorld::GetSubsystem<UMassNavigationSubsystem>(Owner.GetWorld());
}

void UMassFastStandingAvoidanceProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	QUICK_SCOPE_CYCLE_COUNTER(UMassFastStandingAvoidanceProcessor);

	if (!World || !NavigationSubsystem)
	{
		return;
	}

	// Avoidance while standing
	EntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		const float DeltaTime = Context.GetDeltaTimeSeconds();

		const TArrayView<FMassGhostLocationFragment> GhostList = Context.GetMutableFragmentView<FMassGhostLocationFragment>();
		const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		const TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();
		const FMassFastStandingAvoidanceParameters& StandingParams = Context.GetConstSharedFragment<FMassFastStandingAvoidanceParameters>();

		const float GhostSeparationDistance = StandingParams.GhostSeparationDistance;
		const float GhostSeparationStiffness = StandingParams.GhostSeparationStiffness;

		const float MovingSeparationDistance = StandingParams.GhostSeparationDistance * StandingParams.MovingObstacleAvoidanceScale;
		const float MovingSeparationStiffness = StandingParams.GhostSeparationStiffness * StandingParams.MovingObstacleAvoidanceScale;

		// Arrays used to store close agents
		TArray<FMassNavigationObstacleItem, TFixedAllocator<UE::MassFastAvoidance::MaxObstacleResults>> CloseEntities;

		struct FSortedObstacle
		{
			FSortedObstacle() = default;
			FSortedObstacle(const FMassEntityHandle InEntity, const FVector InLocation, const FVector InForward, const float InDistSq) : Entity(InEntity), Location(InLocation), Forward(InForward), DistSq(InDistSq) {}
			
			FMassEntityHandle Entity;
			FVector Location = FVector::ZeroVector;
			FVector Forward = FVector::ForwardVector;
			float DistSq = 0.0f;
		};
		TArray<FSortedObstacle, TFixedAllocator<UE::MassFastAvoidance::MaxObstacleResults>> ClosestObstacles;

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			// @todo: this check should eventually be part of the query.
			const FMassMoveTargetFragment& MoveTarget = MoveTargetList[EntityIndex];
			if (MoveTarget.GetCurrentAction() != EMassMovementAction::Stand)
			{
				continue;
			}
			
			FMassGhostLocationFragment& Ghost = GhostList[EntityIndex];
			// Skip if the ghost is not valid for this movement action yet.
			if (Ghost.IsValid(MoveTarget.GetCurrentActionID()) == false)
			{
				continue;
			}

			const FTransformFragment& Location = LocationList[EntityIndex];
			const FAgentRadiusFragment& Radius = RadiusList[EntityIndex];

			FMassEntityHandle Entity = Context.GetEntity(EntityIndex);
			const FVector AgentLocation = Location.GetTransform().GetTranslation();
			const float AgentRadius = Radius.Radius;

			// Steer ghost to move target.
			const float SteerK = 1.f / StandingParams.GhostSteeringReactionTime;
			constexpr float SteeringMinDistance = 1.0f; // Do not bother to steer if the distance is less than this.

			FVector SteerDirection = FVector::ZeroVector;
			FVector Delta = MoveTarget.Center - Ghost.Location;
			Delta.Z = 0.0f;
			const float Distance = Delta.Size();
			float SpeedFade = 0.0;
			if (Distance > SteeringMinDistance)
			{
				SteerDirection = Delta / Distance;
				SpeedFade = FMath::Clamp(Distance / FMath::Max(KINDA_SMALL_NUMBER, StandingParams.GhostStandSlowdownRadius), 0.0f, 1.0f);
			}

			const FVector GhostDesiredVelocity = SteerDirection * StandingParams.GhostMaxSpeed * SpeedFade;
			FVector GhostSteeringForce = SteerK * (GhostDesiredVelocity - Ghost.Velocity); // Goal force
			
			// Find close obstacles
			// @todo: optimize FindCloseObstacles() and cache results. We're intentionally using agent location here, to allow to share the results with moving avoidance.
			const FNavigationObstacleHashGrid2D& ObstacleGrid = NavigationSubsystem->GetObstacleGridMutable();
			UE::MassFastAvoidance::FindCloseObstacles(AgentLocation, StandingParams.GhostObstacleDetectionDistance, ObstacleGrid, CloseEntities, UE::MassFastAvoidance::MaxObstacleResults);

			// Remove unwanted and find the closest in the CloseEntities
			const float DistanceCutOffSqr = FMath::Square(StandingParams.GhostObstacleDetectionDistance);
			ClosestObstacles.Reset();
			for (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : CloseEntities)
			{
				// Skip self
				if (OtherEntity.Entity == Entity)
				{
					continue;
				}

				// Skip invalid entities.
				if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
				{
					UE_LOG(LogAvoidanceObstacles, VeryVerbose, TEXT("Close entity is invalid, skipped."));
					continue;
				}

				// Skip too far
				const FTransformFragment& OtherTransform = EntitySubsystem.GetFragmentDataChecked<FTransformFragment>(OtherEntity.Entity);
				const FVector OtherLocation = OtherTransform.GetTransform().GetLocation();
				const float DistSq = FVector::DistSquared(AgentLocation, OtherLocation);
				if (DistSq > DistanceCutOffSqr)
				{
					continue;
				}

				ClosestObstacles.Emplace(OtherEntity.Entity, OtherLocation, OtherTransform.GetTransform().GetRotation().GetForwardVector(), DistSq);
			}
			ClosestObstacles.Sort([](const FSortedObstacle& A, const FSortedObstacle& B) { return A.DistSq < B.DistSq; });

			const float GhostRadius = AgentRadius * StandingParams.GhostSeparationRadiusScale;
			
			// Compute forces
			constexpr int32 MaxCloseObstacleTreated = 6;
			const int32 NumCloseObstacles = FMath::Min(ClosestObstacles.Num(), MaxCloseObstacleTreated);
			for (int32 Index = 0; Index < NumCloseObstacles; Index++)
			{
				FSortedObstacle& OtherAgent = ClosestObstacles[Index];
				FMassEntityView OtherEntityView(EntitySubsystem, OtherAgent.Entity);

				const float OtherRadius = OtherEntityView.GetFragmentData<FAgentRadiusFragment>().Radius;
				const float TotalRadius = GhostRadius + OtherRadius;

				// @todo: this is heavy fragment to access, see if we could handle this differently.
				const FMassMoveTargetFragment* OtherMoveTarget = OtherEntityView.GetFragmentDataPtr<FMassMoveTargetFragment>();
				const FMassGhostLocationFragment* OtherGhost = OtherEntityView.GetFragmentDataPtr<FMassGhostLocationFragment>();

				const bool bOtherHasGhost = OtherMoveTarget != nullptr && OtherGhost != nullptr
											&& OtherMoveTarget->GetCurrentAction() == EMassMovementAction::Stand
											&& OtherGhost->IsValid(OtherMoveTarget->GetCurrentActionID());

				// If other has ghost active, avoid that, else avoid the actual agent.
				if (bOtherHasGhost)
				{
					// Avoid the other agent more, when it is further away from it's goal location.
					const float OtherDistanceToGoal = FVector::Distance(OtherGhost->Location, OtherMoveTarget->Center);
					const float OtherSteerFade = FMath::Clamp(OtherDistanceToGoal / StandingParams.GhostToTargetMaxDeviation, 0.0f, 1.0f);
					const float SeparationStiffness = FMath::Lerp(GhostSeparationStiffness, MovingSeparationStiffness, OtherSteerFade);

					// Ghost separation
					FVector RelPos = Ghost.Location - OtherGhost->Location;
					RelPos.Z = 0.f; // we assume we work on a flat plane for now
					const float ConDist = RelPos.Size();
					const FVector ConNorm = ConDist > 0.f ? RelPos / ConDist : FVector::ForwardVector;

					// Separation force (stay away from obstacles if possible)
					const float PenSep = (TotalRadius + GhostSeparationDistance) - ConDist;
					const float SeparationMag = UE::MassNavigation::Smooth(FMath::Clamp(PenSep / GhostSeparationDistance, 0.f, 1.f));
					const FVector SeparationForce = ConNorm * SeparationStiffness * SeparationMag;

					GhostSteeringForce += SeparationForce;
				}
				else
				{
					// Avoid more when the avoidance other is in front,
					const FVector DirToOther = (OtherAgent.Location - Ghost.Location).GetSafeNormal();
					const float DirectionalFade = FMath::Square(FMath::Max(0.0f, FVector::DotProduct(MoveTarget.Forward, DirToOther)));
					const float DirectionScale = FMath::Lerp(StandingParams.MovingObstacleDirectionalScale, 1.0f, DirectionalFade);

					// Treat the other agent as a 2D capsule protruding towards forward.
 					const FVector OtherBasePosition = OtherAgent.Location;
					const FVector OtherPersonalSpacePosition = OtherAgent.Location + OtherAgent.Forward * OtherRadius * StandingParams.MovingObstaclePersonalSpaceScale * DirectionScale;
					const FVector OtherLocation = FMath::ClosestPointOnSegment(Ghost.Location, OtherBasePosition, OtherPersonalSpacePosition);

					FVector RelPos = Ghost.Location - OtherLocation;
					RelPos.Z = 0.f;
					const float ConDist = RelPos.Size();
					const FVector ConNorm = ConDist > 0.f ? RelPos / ConDist : FVector::ForwardVector;

					// Separation force (stay away from obstacles if possible)
					const float PenSep = (TotalRadius + MovingSeparationDistance) - ConDist;
					const float SeparationMag = UE::MassNavigation::Smooth(FMath::Clamp(PenSep / MovingSeparationDistance, 0.f, 1.f));
					const FVector SeparationForce = ConNorm * MovingSeparationStiffness * SeparationMag;

					GhostSteeringForce += SeparationForce;
				}
			}

			GhostSteeringForce.Z = 0.0f;
			GhostSteeringForce = UE::MassNavigation::ClampVector(GhostSteeringForce, StandingParams.GhostMaxAcceleration); // Assume unit mass
			Ghost.Velocity += GhostSteeringForce * DeltaTime;
			Ghost.Velocity.Z = 0.0f;
			
			// Damping
			FMath::ExponentialSmoothingApprox(Ghost.Velocity, FVector::ZeroVector, DeltaTime, StandingParams.GhostVelocityDampingTime);
			
			Ghost.Location += Ghost.Velocity * DeltaTime;

			// Dont let the ghost location too far from move target center.
			const FVector DirToCenter = Ghost.Location - MoveTarget.Center;
			const float DistToCenter = DirToCenter.Length();
			if (DistToCenter > StandingParams.GhostToTargetMaxDeviation)
			{
				Ghost.Location = MoveTarget.Center + DirToCenter * (StandingParams.GhostToTargetMaxDeviation / DistToCenter);
			}

		}
	});
	
}

#undef UNSAFE_FOR_MT

```

`Source/ProjectM/Private/MassFastAvoidanceTrait.cpp`:

```cpp
// Copied from engine except uses ParallelForEachEntityChunk.

#include "MassFastAvoidanceTrait.h"
#include "Avoidance/MassAvoidanceFragments.h"
#include "MassEntityTemplateRegistry.h"
#include "MassMovementFragments.h"
#include "MassCommonFragments.h"
#include "MassNavigationFragments.h"
#include "Engine/World.h"

void UMassFastObstacleAvoidanceTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);
	check(EntitySubsystem);

	BuildContext.AddFragment<FAgentRadiusFragment>();
	BuildContext.AddFragment<FMassNavigationEdgesFragment>();
	BuildContext.AddFragment<FTransformFragment>();
	BuildContext.AddFragment<FMassVelocityFragment>();
	BuildContext.AddFragment<FMassForceFragment>();
	BuildContext.AddFragment<FMassMoveTargetFragment>();

	const FMassFastMovingAvoidanceParameters MovingValidated = MovingParameters.GetValidated();
	const uint32 MovingHash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(MovingValidated));
	const FConstSharedStruct MovingFragment = EntitySubsystem->GetOrCreateConstSharedFragment(MovingHash, MovingValidated);
	BuildContext.AddConstSharedFragment(MovingFragment);

	const FMassFastStandingAvoidanceParameters StandingValidated = StandingParameters.GetValidated();
	const uint32 StandingHash = UE::StructUtils::GetStructCrc32(FConstStructView::Make(StandingValidated));
	const FConstSharedStruct StandingFragment = EntitySubsystem->GetOrCreateConstSharedFragment(StandingHash, StandingValidated);
	BuildContext.AddConstSharedFragment(StandingFragment);
}

```

`Source/ProjectM/Private/MassFireProjectileTask.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "MassFireProjectileTask.h"

#include "StateTreeExecutionContext.h"
#include "MassAIBehaviorTypes.h"
#include "MassStateTreeExecutionContext.h"
#include "MassSpawnerSubsystem.h"
#include "MassEntitySpawnDataGeneratorBase.h"
#include "MassEntityConfigAsset.h"
#include "MassSpawnLocationProcessor.h"
#include "MassCommonFragments.h"
#include "MassMovementFragments.h"
#include "MassSignalSubsystem.h"
#include "Async/Async.h"
#include "MassProjectileDamageProcessor.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "MassSoundPerceptionSubsystem.h"
#include "MassEntityView.h"

void SpawnProjectile(const UWorld* World, const FVector& SpawnLocation, const FQuat& SpawnRotation, const FVector& InitialVelocity, const FMassEntityConfig& EntityConfig, const bool& bIsProjectileFromTeam1)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
	if (SpawnerSystem == nullptr)
	{
		return;
	}

	// TODO: A bit hacky to get first actor here.
	const FMassEntityTemplate* EntityTemplate = EntityConfig.GetOrCreateEntityTemplate(*World->GetLevel(0)->Actors[0], *SpawnerSystem); // TODO: passing SpawnerSystem is a hack
	if (!EntityTemplate->IsValid())
	{
		return;
	}
	FMassEntitySpawnDataGeneratorResult Result;
	Result.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();
	Result.SpawnData.InitializeAs<FMassTransformsSpawnData>();
	Result.NumEntities = 1;
	FMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();

	Transforms.Transforms.Reserve(1);
	FTransform& SpawnDataTransform = Transforms.Transforms.AddDefaulted_GetRef();
	SpawnDataTransform.SetLocation(SpawnLocation);
	SpawnDataTransform.SetRotation(SpawnRotation);

	TArray<FMassEntityHandle> SpawnedEntities;
	SpawnerSystem->SpawnEntities(EntityTemplate->GetTemplateID(), Result.NumEntities, Result.SpawnData, Result.SpawnDataProcessor, SpawnedEntities);

	const UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
	check(EntitySubsystem);

	FMassVelocityFragment* SpawnedEntityVelocityFragment = EntitySubsystem->GetFragmentDataPtr<FMassVelocityFragment>(SpawnedEntities[0]);
	if (ensureMsgf(SpawnedEntityVelocityFragment, TEXT("SpawnProjectile: Spawned entity has no FMassVelocityFragment")))
	{
		SpawnedEntityVelocityFragment->Value = InitialVelocity;
	}

	FMassPreviousLocationFragment* SpawnedEntityPreviousLocationFragment = EntitySubsystem->GetFragmentDataPtr<FMassPreviousLocationFragment>(SpawnedEntities[0]);
	if (ensureMsgf(SpawnedEntityPreviousLocationFragment, TEXT("SpawnProjectile: Spawned entity has no FMassPreviousLocationFragment")))
	{
		SpawnedEntityPreviousLocationFragment->Location = SpawnLocation;
	}

	FMassForceFragment* SpawnedEntityForceFragment = EntitySubsystem->GetFragmentDataPtr<FMassForceFragment>(SpawnedEntities[0]);
	if (ensureMsgf(SpawnedEntityForceFragment, TEXT("SpawnProjectile: Spawned entity has no FMassForceFragment")))
	{
		SpawnedEntityForceFragment->Value = FVector(0.f, 0.f, World->GetGravityZ());
	}

	UMassSoundPerceptionSubsystem* SoundPerceptionSubsystem = UWorld::GetSubsystem<UMassSoundPerceptionSubsystem>(World);
	check(SoundPerceptionSubsystem);
	SoundPerceptionSubsystem->AddSoundPerception(SpawnLocation, bIsProjectileFromTeam1);
}

bool FMassFireProjectileTask::Link(FStateTreeLinker& Linker)
{
	Linker.LinkExternalData(MassSignalSubsystemHandle);
	Linker.LinkExternalData(EntityTransformHandle);
	Linker.LinkExternalData(TargetEntityHandle);
	Linker.LinkExternalData(TeamMemberHandle);

	Linker.LinkInstanceDataProperty(EntityConfigHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassFireProjectileTaskInstanceData, EntityConfig));
	Linker.LinkInstanceDataProperty(WeaponCoolDownSecondsHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassFireProjectileTaskInstanceData, WeaponCoolDownSeconds));
	Linker.LinkInstanceDataProperty(LastWeaponFireTimeSecondsHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassFireProjectileTaskInstanceData, LastWeaponFireTimeSeconds));

	return true;
}

EStateTreeRunStatus FMassFireProjectileTask::EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const
{
	const FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);
	UMassSignalSubsystem& MassSignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);
	const UWorld* World = Context.GetWorld();

	const float& WorldRealTimeSeconds = World->GetRealTimeSeconds();
	const float& WeaponCoolDownSeconds = Context.GetInstanceData(WeaponCoolDownSecondsHandle);
	float& LastWeaponFireTimeSeconds = Context.GetInstanceData(LastWeaponFireTimeSecondsHandle);

	if (LastWeaponFireTimeSeconds > 0.f && WorldRealTimeSeconds - LastWeaponFireTimeSeconds < WeaponCoolDownSeconds)
	{
		MassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::NewStateTreeTaskRequired, MassContext.GetEntity(), 1.0f); // TODO: needed?
		return EStateTreeRunStatus::Running;
	}

	const UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(World);
	check(EntitySubsystem);

	const FMassEntityView StateTreeEntityView(*EntitySubsystem, MassContext.GetEntity());
	const FTransformFragment& StateTreeEntityTransformFragment = Context.GetExternalData(EntityTransformHandle);
	const FTransform& StateTreeEntityTransform = StateTreeEntityTransformFragment.GetTransform();
	const FVector StateTreeEntityLocation = StateTreeEntityTransform.GetLocation();
	const FVector StateTreeEntityCurrentForward = StateTreeEntityTransform.GetRotation().GetForwardVector();

	const FMassEntityConfig& EntityConfig = Context.GetInstanceData(EntityConfigHandle);
	const bool bIsFromSoldier = StateTreeEntityView.HasTag< FMassProjectileDamagableSoldierTag>();
	const float InitialVelocityMagnitude = GetProjectileInitialXYVelocityMagnitude(bIsFromSoldier);
	const FTargetEntityFragment& StateTreeEntityTargetEntityFragment = Context.GetExternalData(TargetEntityHandle);
	const float InitialVelocityZMagnitude = StateTreeEntityTargetEntityFragment.VerticalAimOffset;
	const FVector InitialVelocity = (StateTreeEntityCurrentForward * InitialVelocityMagnitude) + FVector(0.f, 0.f, InitialVelocityZMagnitude);

	const FVector SpawnLocation = StateTreeEntityLocation + UMassEnemyTargetFinderProcessor::GetProjectileSpawnLocationOffset(StateTreeEntityTransform, bIsFromSoldier);
	const FQuat SpawnRotation = StateTreeEntityTransform.GetRotation();

	const FTeamMemberFragment& StateTreeEntityTeamMemberFragment = Context.GetExternalData(TeamMemberHandle);
	const bool& bIsProjectileSourceTeam1 = StateTreeEntityTeamMemberFragment.IsOnTeam1;

	AsyncTask(ENamedThreads::GameThread, [EntityConfig, InitialVelocity, SpawnLocation, World, SpawnRotation, bIsProjectileSourceTeam1]()
	{
		SpawnProjectile(World, SpawnLocation, SpawnRotation, InitialVelocity, EntityConfig, bIsProjectileSourceTeam1);
	});

	MassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::NewStateTreeTaskRequired, MassContext.GetEntity(), 1.0f); // TODO: needed?

	LastWeaponFireTimeSeconds = WorldRealTimeSeconds;
	return EStateTreeRunStatus::Running;
}

EStateTreeRunStatus FMassFireProjectileTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const
{
	return EStateTreeRunStatus::Succeeded;
}

```

`Source/ProjectM/Private/MassGenericAnimTask.cpp`:

```cpp
// Mostly a copy of City Sample MassContextualAnimTask.cpp

#include "MassGenericAnimTask.h"

#include "MassSignalSubsystem.h"
#include "MassStateTreeExecutionContext.h"
#include "MassCommandBuffer.h"
#include "Animation/AnimMontage.h"
#include "MassNavigationFragments.h"
#include "MassZoneGraphNavigationUtils.h"

FMassGenericAnimTask::FMassGenericAnimTask()
{
}

bool FMassGenericAnimTask::Link(FStateTreeLinker& Linker)
{
	Linker.LinkExternalData(MassSignalSubsystemHandle);
	Linker.LinkExternalData(MontageRequestHandle);
	Linker.LinkExternalData(TransformHandle);
	Linker.LinkExternalData(MoveTargetHandle);

	Linker.LinkInstanceDataProperty(TargetEntityHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassGenericAnimTaskInstanceData, TargetEntity));
	Linker.LinkInstanceDataProperty(DurationHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassGenericAnimTaskInstanceData, Duration));
	Linker.LinkInstanceDataProperty(ComputedDurationHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassGenericAnimTaskInstanceData, ComputedDuration));
	Linker.LinkInstanceDataProperty(TimeHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassGenericAnimTaskInstanceData, Time));

	return true;
}

EStateTreeRunStatus FMassGenericAnimTask::EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const
{
	const FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);
	
	float& Time = Context.GetInstanceData(TimeHandle);
	Time = 0.f;

	UE::CrowdInteractionAnim::FRequest AnimRequest;
	AnimRequest.ContextualAnimAsset = ContextualAnimAsset;
	AnimRequest.InteractorRole = InteractorRole;
	AnimRequest.AlignmentTrack = AlignmentTrack;

	FContextualAnimQueryResult& ContextualAnimQueryResult = AnimRequest.QueryResult;
	// If we have a target entity associated, use that to find the best contextual anim to play
	FMassEntityHandle* TargetEntity = Context.GetInstanceDataPtr(TargetEntityHandle); // Optional input
	if (ContextualAnimAsset != nullptr && TargetEntity != nullptr && TargetEntity->IsSet())
	{
		if (const FTransformFragment* TargetTransformFragment = MassContext.GetEntitySubsystem().GetFragmentDataPtr<FTransformFragment>(*TargetEntity))
		{
			const FTransform& TargetTransform = TargetTransformFragment->GetTransform();
			const FTransform& EntityTransform = MassContext.GetExternalData(TransformHandle).GetTransform();

			FContextualAnimQueryParams ContextualAnimQueryParams;
			ContextualAnimQueryParams.bComplexQuery = true;
			ContextualAnimQueryParams.bFindAnimStartTime = true;
			ContextualAnimQueryParams.QueryTransform = EntityTransform;

			// If we don't find a good sync point, grab the closest one.
			if (!ContextualAnimAsset->Query(InteractorRole, ContextualAnimQueryResult, ContextualAnimQueryParams, TargetTransform))
			{
				ContextualAnimQueryParams.bComplexQuery = false;
				ContextualAnimAsset->Query(InteractorRole, ContextualAnimQueryResult, ContextualAnimQueryParams, TargetTransform);
			}
		}
	}
	
	// If we didn't find a proper contextual anim, or it was not set, use a simple montage instead
	if (!ContextualAnimQueryResult.Animation.IsValid())
	{
		ContextualAnimQueryResult.Animation = FallbackMontage;
	}

	float& ComputedDuration = Context.GetInstanceData(ComputedDurationHandle);
	ComputedDuration = Context.GetInstanceData(DurationHandle);
	
	if (const UAnimMontage* Montage = ContextualAnimQueryResult.Animation.Get())
	{
		// Only override movement mode if we have root motion
		if (Montage->HasRootMotion())
		{
			const UWorld* World = Context.GetWorld();
			checkf(World != nullptr, TEXT("A valid world is expected from the execution context"));

			FMassMoveTargetFragment& MoveTarget = Context.GetExternalData(MoveTargetHandle);
			MoveTarget.CreateNewAction(EMassMovementAction::Animate, *World);
			if (!UE::MassNavigation::ActivateActionAnimate(*World, Context.GetOwner(), MassContext.GetEntity(), MoveTarget))
			{
				return EStateTreeRunStatus::Failed;
			}
		}

		// Grab the task duration from the montage.
		ComputedDuration = Montage->GetPlayLength();
		// Use existing fragment or push one
		FMassGenericMontageFragment* MontageFragment = MassContext.GetExternalDataPtr(MontageRequestHandle);
		if (MontageFragment != nullptr)
		{
			MontageFragment->Request(AnimRequest);
		}
		else
		{
			FMassGenericMontageFragment MontageData;
			MontageData.Request(AnimRequest);
			MassContext.GetEntitySubsystemExecutionContext().Defer().PushCommand(FCommandAddFragmentInstance(MassContext.GetEntity(), FInstancedStruct::Make(MontageData)));
		}
	}

	// A Duration <= 0 indicates that the task runs until a transition in the state tree stops it.
	// Otherwise we schedule a signal to end the task.
	if (ComputedDuration > 0.0f)
	{
		UMassSignalSubsystem& MassSignalSubsystem = MassContext.GetExternalData(MassSignalSubsystemHandle);
		MassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::ContextualAnimTaskFinished, MassContext.GetEntity(), ComputedDuration);
	}

	return EStateTreeRunStatus::Running;
}

EStateTreeRunStatus FMassGenericAnimTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const
{
	const float ComputedDuration = Context.GetInstanceData(ComputedDurationHandle);
	float& Time = Context.GetInstanceData(TimeHandle);

	Time += DeltaTime;
	return ComputedDuration <= 0.0f ? EStateTreeRunStatus::Running : (Time < ComputedDuration ? EStateTreeRunStatus::Running : EStateTreeRunStatus::Succeeded);
}

```

`Source/ProjectM/Private/MassGenericAnimationProcessor.cpp`:

```cpp
// Mostly a copy of City Sample MassCrowdAnimationProcessor.cpp

#include "MassGenericAnimationProcessor.h"
#include "Animation/AnimInstance.h"
#include "Components/SkeletalMeshComponent.h"
#include "AnimToTextureInstancePlaybackHelpers.h"
#include "MassVisualizationComponent.h"
#include "MassRepresentationFragments.h"
#include "ContextualAnimSceneAsset.h"
#include "AnimToTextureDataAsset.h"
#include "MassActorSubsystem.h"
#include "MassCommonFragments.h"
#include "MassLookAtFragments.h"
#include "MassLODFragments.h"
#include "MassRepresentationTypes.h"
#include "MotionWarpingComponent.h"
#include "MassEntityView.h"
#include "MassAIBehaviorTypes.h"
#include "MassNavigationFragments.h"
#include "Steering/MassSteeringFragments.h"
#include "MassMovementFragments.h"
#include "GameFramework/Character.h"
#include "Kismet/GameplayStatics.h"
#include "MassCrowdRepresentationSubsystem.h"
#include "Character/MassCharacter.h"

void FMassGenericMontageFragment::Request(const UE::CrowdInteractionAnim::FRequest& InRequest)
{
	InteractionRequest = InRequest;
	SkippedTime = 0.0f;
	MontageInstance.Initialize(InRequest.QueryResult.Animation.Get(), InteractionRequest.QueryResult.AnimStartTime);
}

void FMassGenericMontageFragment::Clear()
{
	*this = FMassGenericMontageFragment();
}

UMassGenericAnimationProcessor::UMassGenericAnimationProcessor()
{
	ExecutionFlags = (int32)(EProcessorExecutionFlags::Client | EProcessorExecutionFlags::Standalone);
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Tasks;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorldToMass);
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Representation);

	bRequiresGameThreadExecution = true;
}

void UMassGenericAnimationProcessor::UpdateAnimationFragmentData(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context, float GlobalTime, TArray<FMassEntityHandle, TInlineAllocator<32>>& ActorEntities)
{
	TArrayView<FGenericAnimationFragment> AnimationDataList = Context.GetMutableFragmentView<FGenericAnimationFragment>();
	TConstArrayView<FMassGenericMontageFragment> MontageDataList = Context.GetFragmentView<FMassGenericMontageFragment>();
	TConstArrayView<FMassRepresentationFragment> VisualizationList = Context.GetFragmentView<FMassRepresentationFragment>();
	TConstArrayView<FMassActorFragment> ActorInfoList = Context.GetFragmentView<FMassActorFragment>();

	const int32 NumEntities = Context.GetNumEntities();
	for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		FGenericAnimationFragment& AnimationData = AnimationDataList[EntityIdx];
		const FMassRepresentationFragment& Visualization = VisualizationList[EntityIdx];
		const FMassActorFragment& ActorFragment = ActorInfoList[EntityIdx];

		if (!ActorFragment.IsOwnedByMass())
		{
			continue;
		}

		const bool bWasActor = (Visualization.PrevRepresentation == EMassRepresentationType::HighResSpawnedActor) || (Visualization.PrevRepresentation == EMassRepresentationType::LowResSpawnedActor);
		const bool bIsActor = (Visualization.CurrentRepresentation == EMassRepresentationType::HighResSpawnedActor) || (Visualization.CurrentRepresentation == EMassRepresentationType::LowResSpawnedActor);
		AnimationData.bSwappedThisFrame = (bWasActor != bIsActor);

		if (!MontageDataList.IsEmpty() && MontageDataList[EntityIdx].MontageInstance.SequenceChangedThisFrame())
		{
			AnimationData.GlobalStartTime = GlobalTime - MontageDataList[EntityIdx].MontageInstance.GetPositionInSection();
		}

		switch (Visualization.CurrentRepresentation)
		{
		case EMassRepresentationType::LowResSpawnedActor:
		case EMassRepresentationType::HighResSpawnedActor:
		{
			FMassEntityHandle Entity = Context.GetEntity(EntityIdx);
			ActorEntities.Add(Entity);
			break;
		}
		default:
			break;
		}
	}
}

void UMassGenericAnimationProcessor::UpdateVertexAnimationState(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context, float GlobalTime)
{
	const int32 NumEntities = Context.GetNumEntities();
	TArrayView<FGenericAnimationFragment> AnimationDataList = Context.GetMutableFragmentView<FGenericAnimationFragment>();
	TConstArrayView<FMassGenericMontageFragment> MontageDataList = Context.GetFragmentView<FMassGenericMontageFragment>();
	TConstArrayView<FMassRepresentationFragment> VisualizationList = Context.GetFragmentView<FMassRepresentationFragment>();
	TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
	TConstArrayView<FMassVelocityFragment> VelocityList = Context.GetFragmentView<FMassVelocityFragment>();

	for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
	{
		FGenericAnimationFragment& AnimationData = AnimationDataList[EntityIdx];

		const FMassRepresentationFragment& Visualization = VisualizationList[EntityIdx];
		const FMassVelocityFragment& Velocity = VelocityList[EntityIdx];

		// Need current anim state to update for skeletal meshes to do a smooth blend between poses
		if (Visualization.CurrentRepresentation != EMassRepresentationType::None)
		{
			int32 StateIndex = 0;

			FMassEntityHandle Entity = Context.GetEntity(EntityIdx);
			const UAnimSequence* Sequence = MontageDataList.IsEmpty() ? nullptr : MontageDataList[EntityIdx].MontageInstance.GetSequence();
			if (Sequence)
			{
				StateIndex = AnimationData.AnimToTextureData.IsValid() ? AnimationData.AnimToTextureData->GetIndexFromAnimSequence(Sequence) : 0;
				if (AnimationData.AnimationStateIndex != StateIndex)
				{
					// Setting this tells the animation when to start and since this animation doesn't loop we need to make sure we're not constantly setting this.
					// Hence we only do this once, when first going into the animation.
					AnimationData.GlobalStartTime = GlobalTime;
				}
			}
			else
			{
				// @todo: Make a better way to map desired anim states here. Currently the anim texture index to access is hard-coded.
				const float VelocitySizeSq = Velocity.Value.SizeSquared();
				const bool bIsWalking = Velocity.Value.SizeSquared() > MoveThresholdSq;
				if (bIsWalking)
				{
					StateIndex = 1;
					const float AuthoredAnimSpeed = 140.0f;
					const float PrevPlayRate = AnimationData.PlayRate;
					AnimationData.PlayRate = FMath::Clamp(FMath::Sqrt(VelocitySizeSq / (AuthoredAnimSpeed * AuthoredAnimSpeed)), 0.8f, 2.0f);

					// Need to conserve current frame on a playrate switch so (GlobalTime - Offset1) * Playrate1 == (GlobalTime - Offset2) * Playrate2
					AnimationData.GlobalStartTime = GlobalTime - PrevPlayRate * (GlobalTime - AnimationData.GlobalStartTime) / AnimationData.PlayRate;
				}
				else
				{
					AnimationData.PlayRate = 1.0f;
					StateIndex = 0;
				}
			}
			AnimationData.AnimationStateIndex = StateIndex;
		}
	}
}

void UMassGenericAnimationProcessor::UpdateSkeletalAnimation(UMassEntitySubsystem& EntitySubsystem, float GlobalTime, TArrayView<FMassEntityHandle> ActorEntities)
{
	if (ActorEntities.Num() <= 0)
	{
		return;
	}

	for (FMassEntityHandle& Entity : ActorEntities)
	{
		FMassEntityView EntityView(EntitySubsystem, Entity);

		FGenericAnimationFragment& AnimationData = EntityView.GetFragmentData<FGenericAnimationFragment>();
		FTransformFragment& TransformFragment = EntityView.GetFragmentData<FTransformFragment>();
		FMassRepresentationFragment& Visualization = EntityView.GetFragmentData<FMassRepresentationFragment>();

		const FMassActorFragment& ActorFragment = EntityView.GetFragmentData<FMassActorFragment>();
		const FMassLookAtFragment* LookAtFragment = EntityView.GetFragmentDataPtr<FMassLookAtFragment>();
		const FMassMoveTargetFragment* MovementTargetFragment = EntityView.GetFragmentDataPtr<FMassMoveTargetFragment>();
		const FMassSteeringFragment* SteeringFragment = EntityView.GetFragmentDataPtr<FMassSteeringFragment>();

		const AActor* Actor = ActorFragment.Get();
		UAnimInstance* AnimInstance = GetAnimInstanceFromActor(Actor);

		const FMassGenericMontageFragment* MontageFragment = EntitySubsystem.GetFragmentDataPtr<FMassGenericMontageFragment>(Entity);
		UAnimMontage* Montage = MontageFragment ? MontageFragment->MontageInstance.GetMontage() : nullptr;

		if (Montage == nullptr)
		{
			continue;
		}

		if (AnimInstance && Actor)
		{
			// Don't play the montage again, even if it's blending out. UAnimInstance::GetCurrentActiveMontage and AnimInstance::Montage_IsPlaying return false if the montage is blending out.
			bool bMontageAlreadyPlaying = false;
			for (int32 InstanceIndex = 0; InstanceIndex < AnimInstance->MontageInstances.Num(); InstanceIndex++)
			{
				FAnimMontageInstance* MontageInstance = AnimInstance->MontageInstances[InstanceIndex];
				if (MontageInstance && MontageInstance->Montage == Montage && MontageInstance->IsPlaying())
				{
					bMontageAlreadyPlaying = true;
				}
			}

			if (!bMontageAlreadyPlaying)
			{
				UMotionWarpingComponent* MotionWarpingComponent = Actor->FindComponentByClass<UMotionWarpingComponent>();
				if (MotionWarpingComponent && MontageFragment->InteractionRequest.AlignmentTrack != NAME_None)
				{
					const FName SyncPointName = MontageFragment->InteractionRequest.AlignmentTrack;
					const FTransform& SyncTransform = MontageFragment->InteractionRequest.QueryResult.SyncTransform;
					MotionWarpingComponent->AddOrUpdateWarpTargetFromTransform(SyncPointName, SyncTransform);
				}

				FAlphaBlendArgs BlendIn;
				BlendIn = Montage->GetBlendInArgs();
				// Instantly blend in if we swapped to skeletal mesh this frame to avoid pop
				BlendIn.BlendTime = AnimationData.bSwappedThisFrame ? 0.0f : BlendIn.BlendTime;

				AnimInstance->Montage_PlayWithBlendIn(Montage, BlendIn, 1.0f, EMontagePlayReturnType::MontageLength, MontageFragment->MontageInstance.GetPosition());
			}

			// Force an animation update if we swapped this frame to prevent t-posing
			if (AnimationData.bSwappedThisFrame)
			{
				if (USkeletalMeshComponent* OwningComp = AnimInstance->GetOwningComponent())
				{
					TArray<USkeletalMeshComponent*> MeshComps;

					// Tick main component and all attached parts to avoid a frame of t-posing
					// We have to refresh bone transforms too because this can happen after the render state has been updated					

					OwningComp->TickAnimation(0.0f, false);
					OwningComp->RefreshBoneTransforms();

					Actor->GetComponents<USkeletalMeshComponent>(MeshComps, true);
					MeshComps.Remove(OwningComp);
					for (USkeletalMeshComponent* MeshComp : MeshComps)
					{
						MeshComp->TickAnimation(0.0f, false);
						MeshComp->RefreshBoneTransforms();
					}
				}
			}
		}
	}
}

void UMassGenericAnimationProcessor::ConfigureQueries()
{
	AnimationEntityQuery_Conditional.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	AnimationEntityQuery_Conditional.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadOnly);
	AnimationEntityQuery_Conditional.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);
	AnimationEntityQuery_Conditional.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);
	AnimationEntityQuery_Conditional.AddRequirement<FMassVelocityFragment>(EMassFragmentAccess::ReadOnly);
	AnimationEntityQuery_Conditional.AddRequirement<FMassLookAtFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	AnimationEntityQuery_Conditional.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	AnimationEntityQuery_Conditional.AddRequirement<FGenericAnimationFragment>(EMassFragmentAccess::ReadWrite);
	AnimationEntityQuery_Conditional.AddRequirement<FMassGenericMontageFragment>(EMassFragmentAccess::ReadWrite, EMassFragmentPresence::Optional);
	AnimationEntityQuery_Conditional.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);
	AnimationEntityQuery_Conditional.SetChunkFilter(&FMassVisualizationChunkFragment::AreAnyEntitiesVisibleInChunk);

	MontageEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	MontageEntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadOnly);
	MontageEntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadOnly);
	MontageEntityQuery.AddRequirement<FMassActorFragment>(EMassFragmentAccess::ReadWrite);
	MontageEntityQuery.AddRequirement<FGenericAnimationFragment>(EMassFragmentAccess::ReadOnly);
	MontageEntityQuery.AddRequirement<FMassGenericMontageFragment>(EMassFragmentAccess::ReadWrite);
	MontageEntityQuery.AddChunkRequirement<FMassVisualizationChunkFragment>(EMassFragmentAccess::ReadOnly);

	MontageEntityQuery_Conditional = MontageEntityQuery;
	MontageEntityQuery_Conditional.SetChunkFilter(&FMassVisualizationChunkFragment::AreAnyEntitiesVisibleInChunk);
}

void UMassGenericAnimationProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	World = Owner.GetWorld();
	check(World);
}

void UMassGenericAnimationProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	check(World);

	QUICK_SCOPE_CYCLE_COUNTER(UMassGenericAnimationProcessor_Run);

	const float GlobalTime = World->GetTimeSeconds();

	TArray<FMassEntityHandle, TInlineAllocator<32>> ActorEntities;
	
	{
		QUICK_SCOPE_CYCLE_COUNTER(UMassGenericAnimationProcessor_UpdateMontage);
		MontageEntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, GlobalTime, &ActorEntities, &EntitySubsystem](FMassExecutionContext& Context)
		{
			const int32 NumEntities = Context.GetNumEntities();
			TArrayView<FMassGenericMontageFragment> MontageDataList = Context.GetMutableFragmentView<FMassGenericMontageFragment>();
			if (!FMassVisualizationChunkFragment::AreAnyEntitiesVisibleInChunk(Context))
			{
				for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
				{
					// If we are not updating animation, we still need to accumulate skipped time to fixup animation on the next update.
					FMassGenericMontageFragment& MontageData = MontageDataList[EntityIdx];

					MontageData.SkippedTime += Context.GetDeltaTimeSeconds();
				}
			}
			else
			{
				TConstArrayView<FMassRepresentationFragment> VisualizationList = Context.GetFragmentView<FMassRepresentationFragment>();
				for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
				{
					const FMassRepresentationFragment& Visualization = VisualizationList[EntityIdx];
					if (Visualization.CurrentRepresentation == EMassRepresentationType::None)
					{
						continue;
					}

					FMassGenericMontageFragment& MontageFragment = MontageDataList[EntityIdx];

					const float MontagePositionPreAdvance = MontageFragment.MontageInstance.GetPosition();
					const float MontageLength = MontageFragment.MontageInstance.GetLength();
					float AdjustedDeltaTime = Context.GetDeltaTimeSeconds() + MontageFragment.SkippedTime;
					const float AdjustedPositionPostAdvance = MontagePositionPreAdvance + AdjustedDeltaTime;
					if (AdjustedPositionPostAdvance > MontageLength)
					{
						// If we've skipped over the remaining duration of the montage clear our fragment
						MontageFragment.Clear();
						Context.Defer().PushCommand(FCommandRemoveFragment(Context.GetEntity(EntityIdx), FMassGenericMontageFragment::StaticStruct()));
					}
					else
					{
						MontageFragment.RootMotionParams.Clear();

						UE::VertexAnimation::FLightWeightMontageExtractionSettings ExtractionSettings;

						if (MontageFragment.InteractionRequest.AlignmentTrack != NAME_None && MontageFragment.SkippedTime > 0.0f)
						{
							const UContextualAnimSceneAsset* ContextualAnimAsset = MontageFragment.InteractionRequest.ContextualAnimAsset.Get();
							if (ContextualAnimAsset)
							{
								FContextualAnimQueryResult& QueryResult = MontageFragment.InteractionRequest.QueryResult;

								const FContextualAnimData* AnimData = ContextualAnimAsset->GetAnimDataForRoleAtIndex(MontageFragment.InteractionRequest.InteractorRole, QueryResult.DataIndex);

								const float WarpDuration = AnimData ? AnimData->GetSyncTimeForWarpSection(0) : 0.f;

								const float WarpDurationSkippedDelta = WarpDuration - MontagePositionPreAdvance;
								if (MontageFragment.SkippedTime > WarpDurationSkippedDelta)
								{
									// If we skipped past the warp, don't extract root motion for that portion, because we want to snap to the warp target before applying root motion.
									ExtractionSettings.bExtractRootMotion = false;
									MontageFragment.MontageInstance.Advance(WarpDurationSkippedDelta, GlobalTime, MontageFragment.RootMotionParams, ExtractionSettings);

									// Remaining time delta should not include warp duration we skipped
									AdjustedDeltaTime -= WarpDurationSkippedDelta;
								}
							}
						}

						ExtractionSettings.bExtractRootMotion = true;
						MontageFragment.MontageInstance.Advance(AdjustedDeltaTime, GlobalTime, MontageFragment.RootMotionParams, ExtractionSettings);
					}
				}
			}
		});
	}

	{
		QUICK_SCOPE_CYCLE_COUNTER(UMassGenericAnimationProcessor_UpdateAnimationFragmentData);
		AnimationEntityQuery_Conditional.ForEachEntityChunk(EntitySubsystem, Context, [this, GlobalTime, &ActorEntities, &EntitySubsystem](FMassExecutionContext& Context)
		{
			UMassGenericAnimationProcessor::UpdateAnimationFragmentData(EntitySubsystem, Context, GlobalTime, ActorEntities);
		});
	}
	{
		QUICK_SCOPE_CYCLE_COUNTER(UMassGenericAnimationProcessor_UpdateVertexAnimationState);
		AnimationEntityQuery_Conditional.ForEachEntityChunk(EntitySubsystem, Context, [this, GlobalTime, &EntitySubsystem](FMassExecutionContext& Context)
		{
			UMassGenericAnimationProcessor::UpdateVertexAnimationState(EntitySubsystem, Context, GlobalTime);
		});
	}

	{
		QUICK_SCOPE_CYCLE_COUNTER(UMassGenericAnimationProcessor_ConsumeRootMotion);
		MontageEntityQuery_Conditional.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
		{
			TArrayView<FTransformFragment> TransformList = Context.GetMutableFragmentView<FTransformFragment>();
			TConstArrayView<FMassRepresentationFragment> VisualizationList = Context.GetFragmentView<FMassRepresentationFragment>();
			TConstArrayView<FGenericAnimationFragment> AnimationDataList = Context.GetFragmentView<FGenericAnimationFragment>();
			TArrayView<FMassGenericMontageFragment> MontageDataList = Context.GetMutableFragmentView<FMassGenericMontageFragment>();

			const int32 NumEntities = Context.GetNumEntities();
			for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
			{
				const FMassRepresentationFragment& Visualization = VisualizationList[EntityIdx];
				if (Visualization.CurrentRepresentation == EMassRepresentationType::None)
				{
					continue;
				}

				const FGenericAnimationFragment& AnimationData = AnimationDataList[EntityIdx];
				FTransformFragment& TransformFragment = TransformList[EntityIdx];
				FMassGenericMontageFragment& MontageFragment = MontageDataList[EntityIdx];

				const UContextualAnimSceneAsset* ContextualAnimAsset = MontageFragment.InteractionRequest.ContextualAnimAsset.Get();
				if (MontageFragment.InteractionRequest.AlignmentTrack != NAME_None && MontageFragment.MontageInstance.IsValid() && ContextualAnimAsset)
				{
					FContextualAnimQueryResult& QueryResult = MontageFragment.InteractionRequest.QueryResult;

					const FContextualAnimData* AnimData = ContextualAnimAsset->GetAnimDataForRoleAtIndex(MontageFragment.InteractionRequest.InteractorRole, QueryResult.DataIndex);

					const float WarpDuration = AnimData ? AnimData->GetSyncTimeForWarpSection(0) : 0.f;
					const float MontagePosition = MontageFragment.MontageInstance.GetPosition();

					FVector TargetLocation;
					FQuat TargetRotation;

					const FTransform& PrevTransform = TransformFragment.GetTransform();
					FQuat PrevRot = PrevTransform.GetRotation();
					FVector PrevLoc = PrevTransform.GetTranslation();

					// Simple lerp towards interaction sync point
					UE::CrowdInteractionAnim::FMotionWarpingScratch& Scratch = MontageFragment.MotionWarpingScratch;

					if (MontagePosition < WarpDuration)
					{
						if (Scratch.Duration < 0.0f)
						{
							Scratch.InitialLocation = PrevLoc;
							Scratch.InitialRotation = PrevRot;
							Scratch.TimeRemaining = WarpDuration - MontagePosition;
							Scratch.Duration = Scratch.TimeRemaining;
						}
						Scratch.TimeRemaining -= Context.GetDeltaTimeSeconds();

						const FTransform& SyncTransform = QueryResult.SyncTransform;

						const float Alpha = FMath::Clamp((Scratch.Duration - Scratch.TimeRemaining) / Scratch.Duration, 0.0f, 1.0f);
						TargetLocation = FMath::Lerp(Scratch.InitialLocation, SyncTransform.GetLocation(), Alpha);

						TargetRotation = FQuat::Slerp(Scratch.InitialRotation, SyncTransform.GetRotation(), FMath::Pow(Alpha, 1.5f));
						TargetRotation.Normalize();
					}
					// Apply root motion
					else
					{
						if (MontagePosition - MontageFragment.SkippedTime < WarpDuration)
						{
							// If we skipped past the warp duration, snap to our sync point before applying root motion
							const FTransform& SyncTransform = QueryResult.SyncTransform;
							PrevLoc = SyncTransform.GetLocation();
							PrevRot = SyncTransform.GetRotation();
						}

						Scratch.Duration = -1.0f;

						const FTransform& RootMotionTransform = MontageFragment.RootMotionParams.GetRootMotionTransform();

						const FQuat ComponentRot = PrevRot * FQuat(FVector::UpVector, -90.0f);
						TargetLocation = PrevLoc + ComponentRot.RotateVector(RootMotionTransform.GetTranslation());
						TargetRotation = RootMotionTransform.GetRotation() * PrevRot;
					}

					MontageFragment.SkippedTime = 0.0f;
					TransformFragment.GetMutableTransform().SetLocation(TargetLocation);
					TransformFragment.GetMutableTransform().SetRotation(TargetRotation);
				}
			}
		});
	}

	{
		QUICK_SCOPE_CYCLE_COUNTER(UMassGenericAnimationProcessor_UpdateSkeletalAnimation);
		// Pull out UAnimToTextureDataAsset from the inner loop to avoid the resolve cost, which is extremely high in PIE.
		UMassGenericAnimationProcessor::UpdateSkeletalAnimation(EntitySubsystem, GlobalTime, MakeArrayView(ActorEntities));
	}
}

class UAnimInstance* UMassGenericAnimationProcessor::GetAnimInstanceFromActor(const AActor* Actor)
{
	const USkeletalMeshComponent* SkeletalMeshComponent = nullptr;
	if (const ACharacter* Character = Cast<ACharacter>(Actor))
	{
		SkeletalMeshComponent = Character->GetMesh();
	}
	else if (Actor)
	{
		SkeletalMeshComponent = Actor->FindComponentByClass<USkeletalMeshComponent>();
	}

	if (SkeletalMeshComponent)
	{
		return SkeletalMeshComponent->GetAnimInstance();
	}

	return nullptr;
}

UGenericAnimationFragmentInitializer::UGenericAnimationFragmentInitializer()
{
	ObservedType = FGenericAnimationFragment::StaticStruct();
	Operation = EMassObservedOperation::Add;
}

void UGenericAnimationFragmentInitializer::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassRepresentationFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FGenericAnimationFragment>(EMassFragmentAccess::ReadWrite);
}

void UGenericAnimationFragmentInitializer::Initialize(UObject& Owner)
{
	World = Owner.GetWorld();
}

void UGenericAnimationFragmentInitializer::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	check(World);
	const float GlobalTime = World->GetTimeSeconds();

	UMassCrowdRepresentationSubsystem* RepresentationSubsystem = UWorld::GetSubsystem<UMassCrowdRepresentationSubsystem>(EntitySubsystem.GetWorld());

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, RepresentationSubsystem, GlobalTime](FMassExecutionContext& Context)
	{
		const TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();
		const TArrayView<FGenericAnimationFragment> AnimationDataList = Context.GetMutableFragmentView<FGenericAnimationFragment>();
		const int32 NumEntities = Context.GetNumEntities();
		for (int32 i = 0; i < NumEntities; ++i)
		{
			FGenericAnimationFragment& AnimationFragment = AnimationDataList[i];
			AnimationFragment.GlobalStartTime = GlobalTime;
			AMassCharacter* MassCharacter = nullptr;
			UAnimToTextureDataAsset* AnimToTextureDataAsset = nullptr;
			TSubclassOf<AActor> TemplateActorClass = RepresentationSubsystem->GetTemplateActorClass(RepresentationList[i].HighResTemplateActorIndex);
			if (TemplateActorClass)
			{
				MassCharacter = Cast<AMassCharacter>(TemplateActorClass->GetDefaultObject());
				if (MassCharacter)
				{
					AnimToTextureDataAsset = MassCharacter->AnimToTextureDataAsset.Get();
				}
			}

			if (RepresentationSubsystem)
			{
				if (AnimToTextureDataAsset)
				{
					ensureMsgf(AnimToTextureDataAsset->GetStaticMesh(), TEXT("%s is missing static mesh %s"), *AnimToTextureDataAsset->GetName(), *AnimToTextureDataAsset->StaticMesh.ToString());
					AnimationFragment.AnimToTextureData = AnimToTextureDataAsset;
				}
			}
		}
	});
};
```

`Source/ProjectM/Private/MassGenericUpdateISMVertexAnimationProcessor.cpp`:

```cpp
// Mostly copied from CitySample MassCrowdUpdateISMVertexAnimationProcessor.cpp 

#include "MassGenericUpdateISMVertexAnimationProcessor.h"
#include "MassVisualizationComponent.h"
#include "MassRepresentationSubsystem.h"
#include "MassEntitySubsystem.h"
#include "MassRepresentationFragments.h"
#include "MassCommonFragments.h"
#include "MassLODFragments.h"
#include "AnimToTextureInstancePlaybackHelpers.h"
#include "MassCommonTypes.h"

//----------------------------------------------------------------------//
//  UMassGenericUpdateISMVertexAnimationProcessor
//----------------------------------------------------------------------//
UMassGenericUpdateISMVertexAnimationProcessor::UMassGenericUpdateISMVertexAnimationProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Tasks);
}

void UMassGenericUpdateISMVertexAnimationProcessor::ConfigureQueries()
{
	Super::ConfigureQueries();

	EntityQuery.AddRequirement<FGenericAnimationFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassGenericUpdateISMVertexAnimationProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [](FMassExecutionContext& Context)
	{
		UMassRepresentationSubsystem* RepresentationSubsystem = Context.GetSharedFragment<FMassRepresentationSubsystemSharedFragment>().RepresentationSubsystem;
		check(RepresentationSubsystem);
		FMassInstancedStaticMeshInfoArrayView ISMInfo = RepresentationSubsystem->GetMutableInstancedStaticMeshInfos();

		TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		TArrayView<FMassRepresentationFragment> RepresentationList = Context.GetMutableFragmentView<FMassRepresentationFragment>();
		TConstArrayView<FMassRepresentationLODFragment> RepresentationLODList = Context.GetFragmentView<FMassRepresentationLODFragment>();
		TArrayView<FGenericAnimationFragment> AnimationDataList = Context.GetMutableFragmentView<FGenericAnimationFragment>();

		const int32 NumEntities = Context.GetNumEntities();
		for (int32 EntityIdx = 0; EntityIdx < NumEntities; EntityIdx++)
		{
			const FMassEntityHandle Entity = Context.GetEntity(EntityIdx);
			const FTransformFragment& TransformFragment = TransformList[EntityIdx];
			const FMassRepresentationLODFragment& RepresentationLOD = RepresentationLODList[EntityIdx];
			FMassRepresentationFragment& Representation = RepresentationList[EntityIdx];
			FGenericAnimationFragment& AnimationData = AnimationDataList[EntityIdx];

			if (Representation.CurrentRepresentation == EMassRepresentationType::StaticMeshInstance)
			{
				UpdateISMTransform(GetTypeHash(Context.GetEntity(EntityIdx)), ISMInfo[Representation.StaticMeshDescIndex], TransformFragment.GetTransform(), Representation.PrevTransform, RepresentationLOD.LODSignificance, Representation.PrevLODSignificance);
				UpdateISMVertexAnimation(ISMInfo[Representation.StaticMeshDescIndex], AnimationData, RepresentationLOD.LODSignificance, Representation.PrevLODSignificance);
			}
			Representation.PrevTransform = TransformFragment.GetTransform();
			Representation.PrevLODSignificance = RepresentationLOD.LODSignificance;
		}
	});
}

void UMassGenericUpdateISMVertexAnimationProcessor::UpdateISMVertexAnimation(FMassInstancedStaticMeshInfo& ISMInfo, FGenericAnimationFragment& AnimationData, const float LODSignificance, const float PrevLODSignificance, const int32 NumFloatsToPad /*= 0*/)
{
	FAnimToTextureInstancePlaybackData InstanceData;
	UAnimToTextureInstancePlaybackLibrary::AnimStateFromDataAsset(AnimationData.AnimToTextureData.Get(), AnimationData.AnimationStateIndex, InstanceData.CurrentState);
	InstanceData.CurrentState.GlobalStartTime = AnimationData.GlobalStartTime;
	InstanceData.CurrentState.PlayRate = AnimationData.PlayRate;
	ISMInfo.AddBatchedCustomData<FAnimToTextureInstancePlaybackData>(InstanceData, LODSignificance, PrevLODSignificance, NumFloatsToPad);
}

```

`Source/ProjectM/Private/MassGotTargetEvaluator.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassGotTargetEvaluator.h"
#include "MassAIBehaviorTypes.h"
#include "MassStateTreeExecutionContext.h"

bool FMassGotTargetEvaluator::Link(FStateTreeLinker& Linker)
{
	Linker.LinkExternalData(TargetEntityFragmentHandle);

	Linker.LinkInstanceDataProperty(GotTargetHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassGotTargetEvaluatorInstanceData, bGotTarget));
	Linker.LinkInstanceDataProperty(TargetEntityHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassGotTargetEvaluatorInstanceData, TargetEntity));

	return true;
}

void FMassGotTargetEvaluator::Evaluate(FStateTreeExecutionContext& Context, const EStateTreeEvaluationType EvalType, const float DeltaTime) const
{
	bool& bGotTarget = Context.GetInstanceData(GotTargetHandle);
	FMassEntityHandle& TargetEntity = Context.GetInstanceData(TargetEntityHandle);

	bGotTarget = false;
	TargetEntity.Reset();

	const FTargetEntityFragment& TargetEntityFragment = Context.GetExternalData(TargetEntityFragmentHandle);

	if (TargetEntityFragment.Entity.IsValid())
	{
		bGotTarget = true;
		TargetEntity = TargetEntityFragment.Entity;
	}
}

```

`Source/ProjectM/Private/MassIdleForDurationTask.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassIdleForDurationTask.h"

#include "StateTreeExecutionContext.h"
#include "MassAIBehaviorTypes.h"
#include "MassStateTreeExecutionContext.h"
#include "MassSignalSubsystem.h"

bool FMassIdleForDurationTask::Link(FStateTreeLinker& Linker)
{
	Linker.LinkExternalData(MassSignalSubsystemHandle);

	Linker.LinkInstanceDataProperty(DurationHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassIdleForDurationTaskInstanceData, Duration));
	Linker.LinkInstanceDataProperty(TimeHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassIdleForDurationTaskInstanceData, Time));

	return true;
}

EStateTreeRunStatus FMassIdleForDurationTask::EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const
{
	float& Time = Context.GetInstanceData(TimeHandle);
	Time = 0.f;

	const FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);

	const float Duration = Context.GetInstanceData(DurationHandle);

	UMassSignalSubsystem& MassSignalSubsystem = Context.GetExternalData(MassSignalSubsystemHandle);
	MassSignalSubsystem.DelaySignalEntity(UE::Mass::Signals::NewStateTreeTaskRequired, MassContext.GetEntity(), Duration);

	return EStateTreeRunStatus::Running;
}

EStateTreeRunStatus FMassIdleForDurationTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const
{
	float& Time = Context.GetInstanceData(TimeHandle);
	const float Duration = Context.GetInstanceData(DurationHandle);

	Time += DeltaTime;

	// TODO: If we don't subtract 1 here, we sometimes tick before duration has elapsed and never tick again. Need to figure out why. 
	return (Time < Duration - 1) ? EStateTreeRunStatus::Running : EStateTreeRunStatus::Succeeded;
}

```

`Source/ProjectM/Private/MassLookAtViaMoveTargetTask.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "MassLookAtViaMoveTargetTask.h"
#include "MassAIBehaviorTypes.h"
#include "MassStateTreeExecutionContext.h"
#include "MassEntitySubsystem.h"
#include "MassMoveTargetForwardCompleteProcessor.h"
#include "InvalidTargetFinderProcessor.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "MassTrackTargetProcessor.h"
#include "MassNavigationTypes.h"

bool FMassLookAtViaMoveTargetTask::Link(FStateTreeLinker& Linker)
{
	Linker.LinkExternalData(MoveTargetHandle);
	Linker.LinkExternalData(StashedMoveTargetHandle);
	Linker.LinkExternalData(TransformHandle);
	Linker.LinkExternalData(MoveForwardCompleteSignalHandle);

	Linker.LinkInstanceDataProperty(TargetEntityHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassLookAtViaMoveTargetTaskInstanceData, TargetEntity));

	return true;
}

bool StashCurrentMoveTargetIfNeeded(const FMassMoveTargetFragment& MoveTargetFragment, FMassStashedMoveTargetFragment& StashedMoveTargetFragment, const UWorld& World, const UMassEntitySubsystem&  EntitySubsystem, const FMassEntityHandle& Entity, const FMassExecutionContext& Context, const bool AddHasStashTag)
{
	const bool bIsEntityCurrentMoving = MoveTargetFragment.GetCurrentAction() == EMassMovementAction::Move && MoveTargetFragment.GetCurrentActionID() > 0;
	if (!bIsEntityCurrentMoving || Context.DoesArchetypeHaveTag<FMassTrackSoundTag>())
	{
		return false;
	}

	if(Context.DoesArchetypeHaveTag<FMassHasStashedMoveTargetTag>())
	{
		UE_LOG(LogTemp, Warning, TEXT("Stashing move target when entity (idx=%d,sn=%d) already has stashed move target"), Entity.Index, Entity.SerialNumber);
	}

	CopyMoveTarget(MoveTargetFragment, StashedMoveTargetFragment, World);
	if (AddHasStashTag)
	{
		EntitySubsystem.Defer().AddTag<FMassHasStashedMoveTargetTag>(Entity);
	}
	return true;
}

EStateTreeRunStatus FMassLookAtViaMoveTargetTask::EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const
{
	const FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);
	FMassMoveTargetFragment& MoveTargetFragment = MassContext.GetExternalData(MoveTargetHandle);
	FMassStashedMoveTargetFragment& StashedMoveTargetFragment = MassContext.GetExternalData(StashedMoveTargetHandle);
	const FTransformFragment& TransformFragment = MassContext.GetExternalData(TransformHandle);
	FMassMoveForwardCompleteSignalFragment& MoveForwardCompleteSignalFragment = MassContext.GetExternalData(MoveForwardCompleteSignalHandle);

	const FMassEntityHandle* TargetEntity = Context.GetInstanceDataPtr(TargetEntityHandle);
	if (TargetEntity == nullptr || !TargetEntity->IsSet()) {
		return EStateTreeRunStatus::Failed;
	}
	const UMassEntitySubsystem& EntitySubsystem = MassContext.GetEntitySubsystem();
	if (!EntitySubsystem.IsEntityValid(*TargetEntity)) {
		return EStateTreeRunStatus::Failed;
	}
	const FTransformFragment* TargetTransformFragment = EntitySubsystem.GetFragmentDataPtr<FTransformFragment>(*TargetEntity);
	if (!TargetTransformFragment) {
		return EStateTreeRunStatus::Failed;
	}

	const FTransform& EntityTransform = TransformFragment.GetTransform();
	const FVector EntityLocation = EntityTransform.GetLocation();
	const FVector NewGlobalDirection = (TargetTransformFragment->GetTransform().GetLocation() - EntityLocation).GetSafeNormal();

	const UWorld* World = Context.GetWorld();

	const FMassEntityHandle& Entity = MassContext.GetEntity();
	StashCurrentMoveTargetIfNeeded(MoveTargetFragment, StashedMoveTargetFragment, *World, EntitySubsystem, Entity, MassContext.GetEntitySubsystemExecutionContext());

	MoveTargetFragment.CreateNewAction(EMassMovementAction::Stand, *World);
	MoveTargetFragment.Center = EntityLocation;
	MoveTargetFragment.Forward = NewGlobalDirection;

	EntitySubsystem.Defer().AddTag<FMassTrackTargetTag>(Entity);
	EntitySubsystem.Defer().AddTag<FMassNeedsMoveTargetForwardCompleteSignalTag>(Entity);
	MoveForwardCompleteSignalFragment.SignalType = EMassMoveForwardCompleteSignalType::NewStateTreeTask;

	return EStateTreeRunStatus::Running;
}

// TODO: Likely not needed (if superclass does same thing).
EStateTreeRunStatus FMassLookAtViaMoveTargetTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const
{
	return EStateTreeRunStatus::Succeeded;
}

```

`Source/ProjectM/Private/MassMoveTargetForwardCompleteProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassMoveTargetForwardCompleteProcessor.h"

#include "MassCommonFragments.h"
#include "MassNavigationFragments.h"
#include "MassNavigationUtils.h"
#include "MassSignalSubsystem.h"
#include "MassStateTreeTypes.h"
#include <MassMoveToCommandProcessor.h>
#include "MassTrackedVehicleOrientationProcessor.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "InvalidTargetFinderProcessor.h"

UMassMoveTargetForwardCompleteProcessor::UMassMoveTargetForwardCompleteProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteBefore.Add(UE::Mass::ProcessorGroupNames::Behavior);
}

void UMassMoveTargetForwardCompleteProcessor::Initialize(UObject& Owner)
{
	SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());
}

void UMassMoveTargetForwardCompleteProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassStashedMoveTargetFragment>(EMassFragmentAccess::ReadOnly, EMassFragmentPresence::Optional);
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassMoveForwardCompleteSignalFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassNavMeshMoveFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassNeedsMoveTargetForwardCompleteSignalTag>(EMassFragmentPresence::All);
}

void UMassMoveTargetForwardCompleteProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("UMassMoveTargetForwardCompleteProcessor");

	TransientEntitiesToSignal.Reset();

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FMassMoveForwardCompleteSignalFragment> MoveForwardCompleteSignalList = Context.GetFragmentView<FMassMoveForwardCompleteSignalFragment>();
		const TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();
		const TConstArrayView<FMassStashedMoveTargetFragment> StashedMoveTargetList = Context.GetFragmentView<FMassStashedMoveTargetFragment>();
		const TArrayView<FMassNavMeshMoveFragment> NavMeshMoveList = Context.GetMutableFragmentView<FMassNavMeshMoveFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			const bool& bAtMoveTargetForward = IsTransformFacingDirection(LocationList[EntityIndex].GetTransform(), MoveTargetList[EntityIndex].Forward);

			if (bAtMoveTargetForward) {
				const FMassEntityHandle& Entity = Context.GetEntity(EntityIndex);

				const auto SignalType = MoveForwardCompleteSignalList[EntityIndex].SignalType;
				if (SignalType == EMassMoveForwardCompleteSignalType::NewStateTreeTask)
				{
					TransientEntitiesToSignal.Add(Entity);
				}
				else if (SignalType == EMassMoveForwardCompleteSignalType::TrackSoundComplete && StashedMoveTargetList.Num() > 0 && MoveTargetList.Num() > 0)
				{
					UnstashMoveTarget(StashedMoveTargetList[EntityIndex], MoveTargetList[EntityIndex], *EntitySubsystem.GetWorld(), Context, NavMeshMoveList[EntityIndex], LocationList[EntityIndex].GetTransform());
					Context.Defer().RemoveTag<FMassHasStashedMoveTargetTag>(Entity);
				}
				Context.Defer().RemoveTag<FMassTrackSoundTag>(Entity);
				Context.Defer().RemoveTag<FMassNeedsMoveTargetForwardCompleteSignalTag>(Entity);
			}
		}
	});

	if (TransientEntitiesToSignal.Num())
	{
		SignalSubsystem->SignalEntities(UE::Mass::Signals::NewStateTreeTaskRequired, TransientEntitiesToSignal);
	}
}

```

`Source/ProjectM/Private/MassMoveToCommandProcessor.cpp`:

```cpp
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.


#include "MassMoveToCommandProcessor.h"

#include "MassEnemyTargetFinderProcessor.h"
#include "MassMoveToCommandSubsystem.h"
#include "MassCommonFragments.h"
#include "NavigationSystem.h"
#include <MassNavMeshMoveProcessor.h>
#include "MassEntityView.h"
#include <MassNavigationUtils.h>

//----------------------------------------------------------------------//
//  UMassCommandableTrait
//----------------------------------------------------------------------//
void UMassCommandableTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddFragment<FMassStashedMoveTargetFragment>();
	BuildContext.AddFragment<FMassNavMeshMoveFragment>();
	BuildContext.AddTag<FMassCommandableTag>();

	FMassCommandableMovementSpeedFragment& CommandableMovementSpeedTemplate = BuildContext.AddFragment_GetRef<FMassCommandableMovementSpeedFragment>();
	CommandableMovementSpeedTemplate.MovementSpeed = MovementSpeed;

	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);
	check(EntitySubsystem);
	const FConstSharedStruct NavMeshParamsFragment = EntitySubsystem->GetOrCreateConstSharedFragment(UE::StructUtils::GetStructCrc32(FConstStructView::Make(NavMeshParams)), NavMeshParams);
	BuildContext.AddConstSharedFragment(NavMeshParamsFragment);
}

//----------------------------------------------------------------------//
//  UMassMoveToCommandProcessor
//----------------------------------------------------------------------//
UMassMoveToCommandProcessor::UMassMoveToCommandProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::All);
}

void UMassMoveToCommandProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassNavMeshMoveFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassCommandableTag>(EMassFragmentPresence::All);
	EntityQuery.AddConstSharedRequirement<FNavMeshParamsFragment>(EMassFragmentPresence::All);
}

void UMassMoveToCommandProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	MoveToCommandSubsystem = UWorld::GetSubsystem<UMassMoveToCommandSubsystem>(Owner.GetWorld());
}

bool IsEntityCommandableByUnit(const FMassEntityHandle& Entity, const UMilitaryUnit* ParentUnit, const UWorld* World)
{
	// This is more for debugging in levels without a military unit spawner, to allow setting move to command to all soldiers on team.
	if (!ParentUnit)
	{
		return true;
	}

	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(World);
	check(MilitaryStructureSubsystem);
	UMilitaryUnit* EntityUnit =	MilitaryStructureSubsystem->GetUnitForEntity(Entity);
	return EntityUnit->IsChildOfUnit(ParentUnit);
}

bool IsSquadMember(const UMilitaryUnit* MilitaryUnit)
{
	return MilitaryUnit->Depth > GSquadUnitDepth;
}

/*static*/ FVector2D UMassMoveToCommandProcessor::GetSoldierOffsetFromSquadLeaderUnscaledMeters(const int8 SquadMemberIndex, const FVector& SquadLeaderForward)
{
	const float YawRadians = UE::MassNavigation::GetYawFromDirection(SquadLeaderForward);
	float YawDegrees = FMath::RadiansToDegrees(YawRadians);
	// We subtract 90 because:
	// GetYawFromDirection((1,0)) = 0, should be 90 deg
	// GetYawFromDirection((0,1)) = 90 deg, should be 0 deg
	// Then because GetRotated rotates counter clockwise, we can leave as-is.
	YawDegrees -= 90.f;
	const FVector2D& UnrotatedOffset = GSquadMemberOffsetsMeters[SquadMemberIndex];
	const FVector2D& RotatedOffset = UnrotatedOffset.GetRotated(YawDegrees);
	return RotatedOffset;
}

/*static*/ FVector UMassMoveToCommandProcessor::GetSoldierOffsetFromSquadLeader(const int8 SquadMemberIndex, const FVector& SquadLeaderLocation, const FVector& SquadLeaderForward)
{
	const FVector2D& Offset = GetSoldierOffsetFromSquadLeaderUnscaledMeters(SquadMemberIndex, SquadLeaderForward) * 100.f * GSquadSpacingScalingFactor;
	return SquadLeaderLocation + FVector(Offset, 0.f);
}

void SetSquadMemberPaths(const UMilitaryUnit* MilitaryUnit, const UMassEntitySubsystem& EntitySubsystem, FNavActionListSharedPtr SquadLeaderActionList, const FMassExecutionContext& Context)
{
	const bool bIsSquadLeader = MilitaryUnit->SquadMemberIndex == 0;
	const bool bIsValidSquadMember = MilitaryUnit->SquadMemberIndex >= 0;
	if (MilitaryUnit->bIsSoldier && !MilitaryUnit->bIsPlayer && !bIsSquadLeader && bIsValidSquadMember)
	{
		FMassEntityView SoldierEntityView(EntitySubsystem, MilitaryUnit->GetMassEntityHandle());
		FMassNavMeshMoveFragment& SoldierNavMeshMoveFragment = SoldierEntityView.GetFragmentData<FMassNavMeshMoveFragment>();
		SoldierNavMeshMoveFragment.Reset();
		FTransformFragment& SoldierTransformFragment = SoldierEntityView.GetFragmentData<FTransformFragment>();
		const TArray<FNavigationAction>& SquadLeaderActions = SquadLeaderActionList.Get()->Actions;
		TArray<FNavigationAction> SquadMemberActions;
		const FVector& SoldierLocation = SoldierTransformFragment.GetTransform().GetLocation();
		const FVector& SoldierFirstMoveTarget = UMassMoveToCommandProcessor::GetSoldierOffsetFromSquadLeader(MilitaryUnit->SquadMemberIndex, SquadLeaderActions[0].TargetLocation, SquadLeaderActions[0].Forward);
		const FVector& SquadMemberFirstForward = (SoldierFirstMoveTarget - SoldierLocation).GetSafeNormal();
		SquadMemberActions.Add(FNavigationAction(SoldierLocation, SquadMemberFirstForward, EMassMovementAction::Stand));
		SquadMemberActions.Add(FNavigationAction(SoldierFirstMoveTarget, SquadMemberFirstForward, EMassMovementAction::Move));
		for (int32 i = 0; i < SquadLeaderActions.Num(); i++)
		{
			const FNavigationAction& SquadLeaderAction = SquadLeaderActions[i];
			const FNavigationAction& NextSquadLeaderAction = i + 1 < SquadLeaderActions.Num() ? SquadLeaderActions[i + 1] : SquadLeaderActions.Last();
			const FVector& Forward = SquadLeaderAction.Action == EMassMovementAction::Move ? NextSquadLeaderAction.Forward : SquadLeaderAction.Forward;
			const FVector& SoldierOffset = UMassMoveToCommandProcessor::GetSoldierOffsetFromSquadLeader(MilitaryUnit->SquadMemberIndex, SquadLeaderAction.TargetLocation, Forward);
			const FVector& SoldierForward = SquadLeaderAction.Action == EMassMovementAction::Move ? (SoldierOffset - SquadMemberActions.Last().TargetLocation).GetSafeNormal() : SquadLeaderAction.Forward;
			SquadMemberActions.Add(FNavigationAction(SoldierOffset, SoldierForward, SquadLeaderAction.Action));
		}

		check(SquadLeaderActions.Num() + 2 == SquadMemberActions.Num());
		SoldierNavMeshMoveFragment.ActionList = MakeShareable(new FNavigationActionList(SquadMemberActions));
		SoldierNavMeshMoveFragment.CurrentActionIndex = 0;
		SoldierNavMeshMoveFragment.ActionsRemaining = SquadMemberActions.Num();
		SoldierNavMeshMoveFragment.SquadMemberIndex = MilitaryUnit->SquadMemberIndex;

		Context.Defer().AddTag<FMassNeedsNavMeshMoveTag>(MilitaryUnit->GetMassEntityHandle());
	}
	for (const UMilitaryUnit* SubUnit : MilitaryUnit->SubUnits)
	{
		SetSquadMemberPaths(SubUnit, EntitySubsystem, SquadLeaderActionList, Context);
	}
}

FNavActionListSharedPtr CreateNavActionList(FNavPathSharedPtr NavPath)
{
	const TArray<FNavPathPoint>& PathPoints = NavPath.Get()->GetPathPoints();
	TArray<FNavigationAction> Actions;
	Actions.Reserve(PathPoints.Num() * 2);

	// We skip the first point since it's where entity is currently located.
	for (int32 Index = 1; Index < PathPoints.Num(); Index++)
	{
		const FNavPathPoint& PathPoint = PathPoints[Index];
		const FNavPathPoint& PreviousPathPoint = PathPoints[Index - 1];
		FVector Forward = (PathPoint.Location - PreviousPathPoint.Location).GetSafeNormal();
		Actions.Add(FNavigationAction(PreviousPathPoint.Location, Forward, EMassMovementAction::Stand));
		Actions.Add(FNavigationAction(PathPoint.Location, Forward));
	}

	return MakeShareable(new FNavigationActionList(Actions));
}

bool UMassMoveToCommandProcessor_ProjectMoveToCommandTarget = false;
FAutoConsoleVariableRef CVar_UMassMoveToCommandProcessor_ProjectMoveToCommandTarget(TEXT("pm.UMassMoveToCommandProcessor_ProjectMoveToCommandTarget"), UMassMoveToCommandProcessor_ProjectMoveToCommandTarget, TEXT("UMassMoveToCommandProcessor_ProjectMoveToCommandTarget"));

UENUM()
enum class EMoveToCommandProcessEntityResult : uint8
{
	Error,
	Success,
	SkippedDueToSquadMember,
};

EMoveToCommandProcessEntityResult ProcessEntity(const UMassMoveToCommandProcessor* Processor, const FTeamMemberFragment& TeamMemberFragment, const bool& IsLastMoveToCommandForTeam1, const FVector& LastMoveToCommandTarget, const FTransform& EntityTransform, const FMassEntityHandle &Entity, UNavigationSystemV1* NavSys, FMassNavMeshMoveFragment& NavMeshMoveFragment, const FMassExecutionContext& Context, const UMilitaryUnit* LastMoveToCommandMilitaryUnit, const UWorld* World, const float& NavMeshRadius, const UMassEntitySubsystem& EntitySubsystem)
{
	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(World);
	check(MilitaryStructureSubsystem);
	UMilitaryUnit* EntityUnit = MilitaryStructureSubsystem->GetUnitForEntity(Entity);

	const bool bIsSquadLeader = EntityUnit->IsSquadLeader();
	if (bIsSquadLeader)
	{
		NavMeshMoveFragment.Reset();
		NavMeshMoveFragment.SquadMemberIndex = 0;
	}
	else if (IsSquadMember(EntityUnit))
	{
		return EMoveToCommandProcessEntityResult::SkippedDueToSquadMember; // return since squad leader will have set NavMeshMoveFragment on squad members
	}
	else {
		NavMeshMoveFragment.Reset();
		NavMeshMoveFragment.SquadMemberIndex = -1;
	}

	static constexpr float AgentHeight = 200.f; // TODO: Don't hard-code
	const FVector& EntityLocation = EntityTransform.GetLocation();
	const ANavigationData* NavData = NavSys->GetNavDataForProps(FNavAgentProperties(NavMeshRadius, AgentHeight), EntityLocation);

	if (!NavData)
	{
		UE_LOG(LogTemp, Warning, TEXT("UMassMoveToCommandProcessor: Could not get navigation data. Likely there is no NavMesh in level."));
		return EMoveToCommandProcessEntityResult::Error;
	}

	FVector CommandTarget = LastMoveToCommandTarget;

	if (UMassMoveToCommandProcessor_ProjectMoveToCommandTarget)
	{
		FNavLocation ClosestValidLocation;
		const FVector Extent(8000.f, 8000.f, 1000.f); // TODO: don't hard-code
		const bool bProjectResult = NavSys->ProjectPointToNavigation(LastMoveToCommandTarget, ClosestValidLocation, Extent, NavData);

		if (!bProjectResult)
		{
			UE_LOG(LogTemp, Warning, TEXT("UMassMoveToCommandProcessor: Could not find closest valid location to move to command location from %s to %s"), *EntityLocation.ToString(), *LastMoveToCommandTarget.ToString());
			return EMoveToCommandProcessEntityResult::Error;
		}

		const float ProjectedDeltaSquared = (ClosestValidLocation.Location - LastMoveToCommandTarget).SizeSquared();

		constexpr float MaxGoodProjectedDelta = 1000.f;
		constexpr float MaxGoodProjectedDeltaSquared = MaxGoodProjectedDelta * MaxGoodProjectedDelta;
		if (ProjectedDeltaSquared > MaxGoodProjectedDeltaSquared)
		{
			UE_LOG(LogTemp, Warning, TEXT("UMassMoveToCommandProcessor: Projected point is far from original. Original = %s, Projected = %s, DeltaSquared = %.0f"), *LastMoveToCommandTarget.ToString(), *ClosestValidLocation.Location.ToString(), MaxGoodProjectedDeltaSquared);
		}

		CommandTarget = ClosestValidLocation.Location;
	}

	const FPathFindingQuery Query(Processor, *NavData, EntityLocation, CommandTarget);
	const FPathFindingResult Result = NavSys->FindPathSync(Query);

	if (!Result.IsSuccessful())
	{
		UE_LOG(LogTemp, Warning, TEXT("UMassMoveToCommandProcessor: Could not find path to target. NavMeshRadius = %.0f, Start = %s, End = %s"), NavMeshRadius, *EntityLocation.ToString(), *CommandTarget.ToString());
		return EMoveToCommandProcessEntityResult::Error;
	}

	NavMeshMoveFragment.ActionList = CreateNavActionList(Result.Path);
	NavMeshMoveFragment.ActionsRemaining = NavMeshMoveFragment.ActionList.Get()->Actions.Num();
	NavMeshMoveFragment.CurrentActionIndex = 0;

	if (bIsSquadLeader)
	{
		const UMilitaryUnit* SquadMilitaryUnit = EntityUnit->Parent;
		SetSquadMemberPaths(SquadMilitaryUnit, EntitySubsystem, NavMeshMoveFragment.ActionList, Context);
	}

	Context.Defer().AddTag<FMassNeedsNavMeshMoveTag>(Entity);

	return EMoveToCommandProcessEntityResult::Success;
}

void UMassMoveToCommandProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassMoveToCommandProcessor.Execute);

	if (!MoveToCommandSubsystem)
	{
		return;
	}

	FMoveToCommand MoveToCommand;
	if (!MoveToCommandSubsystem->DequeueMoveToCommand(MoveToCommand))
	{
		return;
	}

	int32 NumEntitiesSetMoveTarget = 0;
	int32 NumEntitiesAttemptedSetMoveTarget = 0;

	const bool IsLastMoveToCommandForTeam1 = MoveToCommand.bIsOnTeam1;
	const UMilitaryUnit* LastMoveToCommandMilitaryUnit = MoveToCommand.MilitaryUnit;
	const FVector LastMoveToCommandTarget = MoveToCommand.Target;

	UNavigationSystemV1* NavSys = FNavigationSystem::GetCurrent<UNavigationSystemV1>(GetWorld());

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &IsLastMoveToCommandForTeam1, LastMoveToCommandTarget, NavSys, LastMoveToCommandMilitaryUnit, &NumEntitiesSetMoveTarget, &NumEntitiesAttemptedSetMoveTarget , &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();
		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		const TArrayView<FMassNavMeshMoveFragment> NavMeshMoveList = Context.GetMutableFragmentView<FMassNavMeshMoveFragment>();
		const FNavMeshParamsFragment& NavMeshParams = Context.GetConstSharedFragment<FNavMeshParamsFragment>();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			// Change move to command target Z to make current entity's Z value since we don't know ground height.
			const FVector& EntityLocation = TransformList[i].GetTransform().GetLocation();
			FVector MoveToCommandTarget = LastMoveToCommandTarget;
			MoveToCommandTarget.Z = EntityLocation.Z;

			const FTeamMemberFragment& TeamMemberFragment = TeamMemberList[i];
			if (TeamMemberFragment.IsOnTeam1 != IsLastMoveToCommandForTeam1)
			{
				continue;
			}

			const FMassEntityHandle& Entity = Context.GetEntity(i);
			const UWorld* World = GetWorld();
			if (!IsEntityCommandableByUnit(Entity, LastMoveToCommandMilitaryUnit, World))
			{
				continue;
			}

			FMassNavMeshMoveFragment& NavMeshMoveFragment = NavMeshMoveList[i];
			const EMoveToCommandProcessEntityResult Result = ProcessEntity(this, TeamMemberList[i], IsLastMoveToCommandForTeam1, MoveToCommandTarget, TransformList[i].GetTransform(), Entity, NavSys, NavMeshMoveFragment, Context, LastMoveToCommandMilitaryUnit, World, NavMeshParams.NavMeshRadius, EntitySubsystem);

			NumEntitiesAttemptedSetMoveTarget++;
			if (Result != EMoveToCommandProcessEntityResult::Error)
			{
				NumEntitiesSetMoveTarget++;
			}
		}
	});

	UE_LOG(LogTemp, Log, TEXT("UMassMoveToCommandProcessor: Set move target to %d/%d entities to %s."), NumEntitiesSetMoveTarget, NumEntitiesAttemptedSetMoveTarget, *LastMoveToCommandTarget.ToCompactString());
}

```

`Source/ProjectM/Private/MassMoveToCommandSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassMoveToCommandSubsystem.h"

#include <MilitaryStructureSubsystem.h>

void UMassMoveToCommandSubsystem::EnqueueMoveToCommand(const UMilitaryUnit* MilitaryUnit, const FVector Target, const bool bIsOnTeam1)
{
	MoveToCommandQueue.Enqueue(FMoveToCommand(MilitaryUnit, Target, bIsOnTeam1));
}

bool UMassMoveToCommandSubsystem::DequeueMoveToCommand(FMoveToCommand& OutMoveToCommand)
{
	if (MoveToCommandQueue.IsEmpty())
	{
		return false;
	}

	const bool bDidDequeue = MoveToCommandQueue.Dequeue(OutMoveToCommand);
	check(bDidDequeue);
	return true;
}

```

`Source/ProjectM/Private/MassNavMeshMoveProcessor.cpp`:

```cpp
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.


#include "MassNavMeshMoveProcessor.h"

#include "MassEnemyTargetFinderProcessor.h"
#include "MassTrackTargetProcessor.h"
#include "MassCommonFragments.h"
#include "NavigationSystem.h"
#include <MassMoveToCommandProcessor.h>
#include <MassTrackedVehicleOrientationProcessor.h>
#include "MassEntityView.h"
#include "MassMoveToCommandSubsystem.h"

UMassNavMeshMoveProcessor::UMassNavMeshMoveProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::All);
}

void UMassNavMeshMoveProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassStashedMoveTargetFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassNavMeshMoveFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddRequirement<FMassCommandableMovementSpeedFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddTagRequirement<FMassNeedsNavMeshMoveTag>(EMassFragmentPresence::All);
}

bool DoesSoldierHaveSameActionsRemaining(int32 ActionsRemaining, const UMilitaryUnit* SoldierMilitaryUnit, const UMassEntitySubsystem& EntitySubsystem)
{
	const FMassEntityHandle& SoldierEntity = SoldierMilitaryUnit->GetMassEntityHandle();
	if (!EntitySubsystem.IsEntityValid(SoldierEntity))
	{
		return true;
	}
	FMassEntityView SoldierEntityView(EntitySubsystem, SoldierEntity);
	const FMassNavMeshMoveFragment& NavMeshMoveFragment = SoldierEntityView.GetFragmentData<FMassNavMeshMoveFragment>();
	return NavMeshMoveFragment.ActionsRemaining <= ActionsRemaining;
}

bool HaveAllSquadMembersReachedSameAction(int32 ActionsRemaining, const UMilitaryUnit* MilitaryUnit, const UMassEntitySubsystem& EntitySubsystem, UMilitaryUnit* UnitToIgnore)
{
	if (MilitaryUnit == UnitToIgnore)
	{
		return true;
	}

	if (MilitaryUnit->bIsSoldier && !MilitaryUnit->bIsPlayer)
	{
		if (!DoesSoldierHaveSameActionsRemaining(ActionsRemaining, MilitaryUnit, EntitySubsystem))
		{
			return false;
		}
	}
	
	for (UMilitaryUnit* SubUnit : MilitaryUnit->SubUnits)
	{
		if (!HaveAllSquadMembersReachedSameAction(ActionsRemaining, SubUnit, EntitySubsystem, UnitToIgnore))
		{
			return false;
		}
	}

	return true;
}

void CompleteNavMeshMove(FMassMoveTargetFragment& MoveTargetFragmentToModify, UWorld* World, const FMassExecutionContext& Context, const FMassEntityHandle& Entity, const bool bUseStashedMoveTarget)
{
	MoveTargetFragmentToModify.CreateNewAction(EMassMovementAction::Stand, *World);
	MoveTargetFragmentToModify.DistanceToGoal = 0.f;
	MoveTargetFragmentToModify.DesiredSpeed.Set(0.f);

	Context.Defer().RemoveTag<FMassNeedsNavMeshMoveTag>(Entity);

	if (bUseStashedMoveTarget) {
		Context.Defer().AddTag<FMassHasStashedMoveTargetTag>(Entity);
	}
}

void CompleteNavMeshMoveForAllSquadMembers(const UMilitaryUnit* MilitaryUnit, const UMassEntitySubsystem& EntitySubsystem, UWorld* World, const FMassExecutionContext& Context)
{
	if (MilitaryUnit->bIsSoldier && !MilitaryUnit->bIsPlayer)
	{
		const FMassEntityHandle& SoldierEntity = MilitaryUnit->GetMassEntityHandle();
		if (EntitySubsystem.IsEntityValid(SoldierEntity))
		{
			FMassEntityView SoldierEntityView(EntitySubsystem, SoldierEntity);
			const bool bUseStashedMoveTarget = SoldierEntityView.HasTag<FMassTrackTargetTag>() || SoldierEntityView.HasTag<FMassTrackSoundTag>();
			FMassMoveTargetFragment& MoveTargetFragmentToModify = bUseStashedMoveTarget ? SoldierEntityView.GetFragmentData<FMassStashedMoveTargetFragment>() : SoldierEntityView.GetFragmentData<FMassMoveTargetFragment>();
			CompleteNavMeshMove(MoveTargetFragmentToModify, World, Context, SoldierEntity, bUseStashedMoveTarget);
		}
	}

	for (UMilitaryUnit* SubUnit : MilitaryUnit->SubUnits)
	{
		CompleteNavMeshMoveForAllSquadMembers(SubUnit, EntitySubsystem, World, Context);
	}
}

void EnqueueNewMoveToCommand(const UMilitaryUnit* MilitaryUnit, UWorld* World, const FVector& Target, const bool bIsOnTeam1)
{
	UMassMoveToCommandSubsystem* MoveToCommandSubsystem = UWorld::GetSubsystem<UMassMoveToCommandSubsystem>(World);
	MoveToCommandSubsystem->EnqueueMoveToCommand(MilitaryUnit, Target, bIsOnTeam1);
}

void ProcessEntity(FMassMoveTargetFragment& MoveTargetFragment, UWorld* World, const FTransform& EntityTransform, const FMassExecutionContext& Context, FMassStashedMoveTargetFragment& StashedMoveTargetFragment, const FMassEntityHandle& Entity, FMassNavMeshMoveFragment& NavMeshMoveFragment, const float MovementSpeed, const float AgentRadius, const UMassEntitySubsystem& EntitySubsystem, const FTeamMemberFragment& TeamMemberFragment)
{
	const FVector& EntityLocation = EntityTransform.GetLocation();

	// TODO: would it be faster to have two separate entity queries instead of checking tag here?
	const bool bUseStashedMoveTarget = Context.DoesArchetypeHaveTag<FMassTrackTargetTag>() || Context.DoesArchetypeHaveTag<FMassTrackSoundTag>();
	FMassMoveTargetFragment& MoveTargetFragmentToModify = bUseStashedMoveTarget ? StashedMoveTargetFragment : MoveTargetFragment;

	const TArray<FNavigationAction>& Actions = NavMeshMoveFragment.ActionList.Get()->Actions;
	const FNavigationAction& CurrentAction = Actions[NavMeshMoveFragment.CurrentActionIndex];

	if (!NavMeshMoveFragment.bIsWaitingOnSquadMates)
	{
		bool bFinishedCurrentAction = false;

		const float DistanceFromTarget = (EntityLocation - CurrentAction.TargetLocation).Size();
		if (CurrentAction.Action == EMassMovementAction::Stand)
		{
			bFinishedCurrentAction = IsTransformFacingDirection(EntityTransform, MoveTargetFragment.Forward);
		}
		else
		{
			bFinishedCurrentAction = DistanceFromTarget < AgentRadius;
		}

		if (!bFinishedCurrentAction)
		{
			const FVector& DeltaToMoveTargetNormal = (MoveTargetFragmentToModify.Center - EntityLocation).GetSafeNormal();
			const float SumSizeSquared = (FVector2D(MoveTargetFragmentToModify.Forward) + FVector2D(DeltaToMoveTargetNormal)).SizeSquared();
			const bool bHasInvalidMoveTarget = MoveTargetFragmentToModify.GetCurrentAction() == EMassMovementAction::Move && FMath::IsNearlyZero(SumSizeSquared, 0.1f); // Note we can't use default tolerance as there are cases where SizeSquared returns kinda small numbers when invalid (not extremely small).
			const bool bHasActionMismatch = !bUseStashedMoveTarget && CurrentAction.Action != MoveTargetFragmentToModify.GetCurrentAction();
			const bool bIsStuck = bHasInvalidMoveTarget || bHasActionMismatch;
			if (bIsStuck)
			{
				UE_LOG(LogTemp, Log, TEXT("UMassNavMeshMoveProcessor: Entity (i: %d sn: %d) got stuck, restarting nav mesh move."), Entity.Index, Entity.SerialNumber);
				UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(World);
				check(MilitaryStructureSubsystem);
				UMilitaryUnit* EntityUnit = MilitaryStructureSubsystem->GetUnitForEntity(Entity);
				if (NavMeshMoveFragment.IsSquadMember())
				{
					CompleteNavMeshMoveForAllSquadMembers(EntityUnit->SquadMilitaryUnit, EntitySubsystem, World, Context);
					const FVector& SoldierOffsetFromSquadLeader = UMassMoveToCommandProcessor::GetSoldierOffsetFromSquadLeader(NavMeshMoveFragment.SquadMemberIndex, FVector::ZeroVector, Actions.Last().Forward);
					// We have to negate below because we're calculating squad leader's target, not soldier's.
					const FVector& SquadLeaderNavMeshFinalTarget = Actions.Last().TargetLocation - SoldierOffsetFromSquadLeader;
					EnqueueNewMoveToCommand(EntityUnit->SquadMilitaryUnit, World, SquadLeaderNavMeshFinalTarget, TeamMemberFragment.IsOnTeam1);
				}
				else
				{
					CompleteNavMeshMove(MoveTargetFragmentToModify, World, Context, Entity, bUseStashedMoveTarget);
					EnqueueNewMoveToCommand(EntityUnit, World, Actions.Last().TargetLocation, TeamMemberFragment.IsOnTeam1);
				}
				return;
			}
			// Wait for UMassSteerToMoveTargetProcessor to move entity to next point.
			MoveTargetFragmentToModify.DistanceToGoal = DistanceFromTarget;
			return;
		}

		NavMeshMoveFragment.ActionsRemaining = NavMeshMoveFragment.ActionList.Get()->Actions.Num() - (NavMeshMoveFragment.CurrentActionIndex + 1);
	}

	const bool bIsNextActionMove = NavMeshMoveFragment.CurrentActionIndex + 1 < Actions.Num() ? Actions[NavMeshMoveFragment.CurrentActionIndex + 1].Action == EMassMovementAction::Move : false;
	if (NavMeshMoveFragment.IsSquadMember() && bIsNextActionMove) // Only wait on squad mates if next action is move.
	{
		UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(World);
		check(MilitaryStructureSubsystem);
		UMilitaryUnit* EntityUnit = MilitaryStructureSubsystem->GetUnitForEntity(Entity);
		if (!HaveAllSquadMembersReachedSameAction(NavMeshMoveFragment.ActionsRemaining, EntityUnit->SquadMilitaryUnit, EntitySubsystem, EntityUnit))
		{
			NavMeshMoveFragment.bIsWaitingOnSquadMates = true;
			return; // Wait for squad mates.
		}
		NavMeshMoveFragment.bIsWaitingOnSquadMates = false;
	}

	NavMeshMoveFragment.CurrentActionIndex++;

	const bool bFinishedNavMeshMove = NavMeshMoveFragment.CurrentActionIndex >= Actions.Num();
	if (bFinishedNavMeshMove)
	{
		CompleteNavMeshMove(MoveTargetFragmentToModify, World, Context, Entity, bUseStashedMoveTarget);
		return;
	}

	// Update move target to next action.
	
	const FNavigationAction& NextAction = Actions[NavMeshMoveFragment.CurrentActionIndex];

	MoveTargetFragmentToModify.CreateNewAction(NextAction.Action, *World);
	MoveTargetFragmentToModify.Center = NextAction.TargetLocation;
	MoveTargetFragmentToModify.Forward = NextAction.Forward;
	const float Distance = (NextAction.TargetLocation - EntityLocation).Size();
	MoveTargetFragmentToModify.DistanceToGoal = Distance;
	MoveTargetFragmentToModify.bOffBoundaries = true;
	MoveTargetFragmentToModify.DesiredSpeed.Set(NextAction.Action == EMassMovementAction::Stand ? 0.f : MovementSpeed);
	MoveTargetFragmentToModify.IntentAtGoal = EMassMovementAction::Stand;

	if (bUseStashedMoveTarget) {
		Context.Defer().AddTag<FMassHasStashedMoveTargetTag>(Entity);
	}
}

void UMassNavMeshMoveProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassNavMeshMoveProcessor.Execute);

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FMassCommandableMovementSpeedFragment> MovementSpeedList = Context.GetFragmentView<FMassCommandableMovementSpeedFragment>();
		const TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();
		const TArrayView<FMassStashedMoveTargetFragment> StashedMoveTargetList = Context.GetMutableFragmentView<FMassStashedMoveTargetFragment>();
		const TArrayView<FMassNavMeshMoveFragment> NavMeshMoveList = Context.GetMutableFragmentView<FMassNavMeshMoveFragment>();
		const TConstArrayView<FAgentRadiusFragment> AgentRadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			ProcessEntity(MoveTargetList[i], GetWorld(), TransformList[i].GetTransform(), Context, StashedMoveTargetList[i], Context.GetEntity(i), NavMeshMoveList[i], MovementSpeedList[i].MovementSpeed, AgentRadiusList[i].Radius, EntitySubsystem, TeamMemberList[i]);
		}
	});
}

```

`Source/ProjectM/Private/MassOrderedSpawnLocationProcessor.cpp`:

```cpp
// Adapted from MassSpawnLocationProcessor.cpp, just without randomness.

#include "MassOrderedSpawnLocationProcessor.h"
#include "MassCommonFragments.h"
#include "MassEntitySubsystem.h"
#include "MassSpawnerTypes.h"
#include "Engine/World.h"
#include "VisualLogger/VisualLogger.h"

//----------------------------------------------------------------------//
// UMassOrderedSpawnLocationProcessor 
//----------------------------------------------------------------------//
UMassOrderedSpawnLocationProcessor::UMassOrderedSpawnLocationProcessor()
{
	bAutoRegisterWithProcessingPhases = false;
}

void UMassOrderedSpawnLocationProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassOrderedSpawnLocationProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	if (!ensure(Context.ValidateAuxDataType<FMassTransformsSpawnData>()))
	{
		UE_VLOG_UELOG(this, LogMass, Log, TEXT("Execution context has invalid AuxData or it's not FMassSpawnAuxData. Entity transforms won't be initialized."));
		return;
	}

	const UWorld* World = EntitySubsystem.GetWorld();

	check(World);

	const ENetMode NetMode = World->GetNetMode();

	if (NetMode != NM_Client)
	{
		FMassTransformsSpawnData& AuxData = Context.GetMutableAuxData().GetMutable<FMassTransformsSpawnData>();
		TArray<FTransform>& Transforms = AuxData.Transforms;

		const int32 NumSpawnTransforms = Transforms.Num();
		if (NumSpawnTransforms == 0)
		{
			UE_VLOG_UELOG(this, LogMass, Error, TEXT("No spawn transforms provided. Entity transforms won't be initialized."));
			return;
		}

		int32 NumRequiredSpawnTransforms = 0;
		EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [&NumRequiredSpawnTransforms](const FMassExecutionContext& Context)
			{
				NumRequiredSpawnTransforms += Context.GetNumEntities();
			});

		const int32 NumToAdd = NumRequiredSpawnTransforms - NumSpawnTransforms;
		if (NumToAdd > 0)
		{
			UE_VLOG_UELOG(this, LogMass, Warning,
				TEXT("Not enough spawn locations provided (%d) for all entities (%d). Existing locations will be reused randomly to fill the %d missing positions."),
				NumSpawnTransforms, NumRequiredSpawnTransforms, NumToAdd);

			Transforms.AddUninitialized(NumToAdd);
			for (int i = 0; i < NumToAdd; ++i)
			{
				Transforms[NumSpawnTransforms + i] = Transforms[FMath::RandRange(0, NumSpawnTransforms - 1)];
			}
		}

		int32 TransformIndex = 0;
		EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [&Transforms, this, &TransformIndex](FMassExecutionContext& Context)
		{
			const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();
			const int32 NumEntities = Context.GetNumEntities();
			for (int32 i = 0; i < NumEntities; ++i)
			{
				LocationList[i].GetMutableTransform() = Transforms[TransformIndex++];
			}
		});
	}
}

```

`Source/ProjectM/Private/MassPlayerSubsystem.cpp`:

```cpp
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.


#include "MassPlayerSubsystem.h"

#include "MassAgentComponent.h"
#include "MassAgentSubsystem.h"
#include "MassSimulationSubsystem.h"

void UMassPlayerSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	Collection.InitializeDependency<UMassSimulationSubsystem>();

	AgentSubsystem = Collection.InitializeDependency<UMassAgentSubsystem>();
	check(AgentSubsystem);

	AgentSubsystem->GetOnMassAgentComponentEntityAssociated().AddLambda([this](const UMassAgentComponent& AgentComponent)
	{
		EntityToActorMap.Add(AgentComponent.GetEntityHandle(), AgentComponent.GetOwner());
	});

	AgentSubsystem->GetOnMassAgentComponentEntityDetaching().AddLambda([this](const UMassAgentComponent& AgentComponent)
	{
			EntityToActorMap.Remove(AgentComponent.GetEntityHandle());
	});
}

void UMassPlayerSubsystem::Deinitialize()
{
	check(AgentSubsystem);
	AgentSubsystem->GetOnMassAgentComponentEntityAssociated().RemoveAll(this);
	AgentSubsystem->GetOnMassAgentComponentEntityDetaching().RemoveAll(this);

	Super::Deinitialize();
}

AActor* UMassPlayerSubsystem::GetActorForEntity(const FMassEntityHandle Entity)
{
	AActor** resultPtr = EntityToActorMap.Find(Entity);
	if (resultPtr)
	{
		return *resultPtr;
	}	else {
		return nullptr;
	}
}

```

`Source/ProjectM/Private/MassProjectileDamageProcessor.cpp`:

```cpp
#include "MassProjectileDamageProcessor.h"

#include "MassEntityView.h"
#include "MassLODTypes.h"
#include "MassCommonFragments.h"
#include "Kismet/KismetSystemLibrary.h"
#include "MassPlayerSubsystem.h"
#include "Character/CommanderCharacter.h"
#include "MilitaryStructureSubsystem.h"
#include <MassVisualEffectsSubsystem.h>
#include "MassCollisionProcessor.h"
#include <MassEnemyTargetFinderProcessor.h>
#include <MassSoundPerceptionSubsystem.h>
#include <MassDelayedDestructionProcessor.h>
#include <MassTargetGridProcessors.h>
#include <MassActorSubsystem.h>
#include "Character/MassCharacter.h"
#include "MassNavigationFragments.h"
#include <MassNavMeshMoveProcessor.h>
#include <MassMoveToCommandProcessor.h>
#include "MassSignalSubsystem.h"
#include <MassStateTreeTypes.h>

static constexpr uint32 GUMassProjectileWithDamageTrait_MaxClosestEntitiesToFind = 20;
typedef TArray<FMassNavigationObstacleItem, TFixedAllocator<GUMassProjectileWithDamageTrait_MaxClosestEntitiesToFind>> TProjectileDamageObstacleItemArray;

//----------------------------------------------------------------------//
//	UMassProjectileWithDamageTrait
//----------------------------------------------------------------------//
void UMassProjectileWithDamageTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	BuildContext.AddFragment<FMassPreviousLocationFragment>();

	FProjectileDamageFragment& ProjectileDamageFragment = BuildContext.AddFragment_GetRef<FProjectileDamageFragment>();
	ProjectileDamageFragment.DamagePerHit = DamagePerHit;
	ProjectileDamageFragment.Caliber = Caliber;
	ProjectileDamageFragment.SplashDamageRadius = SplashDamageRadius;

	if (ExplosionEntityConfig)
	{
		UMassVisualEffectsSubsystem* MassVisualEffectsSubsystem = UWorld::GetSubsystem<UMassVisualEffectsSubsystem>(&World);
		ProjectileDamageFragment.ExplosionEntityConfigIndex = MassVisualEffectsSubsystem->FindOrAddEntityConfig(ExplosionEntityConfig);
	}

	BuildContext.AddTag<FMassProjectileWithDamageTag>();

	BuildContext.AddFragment<FTransformFragment>();
	BuildContext.AddFragment<FMassVelocityFragment>();
	FMassForceFragment& ForceTemplate = BuildContext.AddFragment_GetRef<FMassForceFragment>();
	ForceTemplate.Value = FVector(0.f, 0.f, GravityMagnitude);

	// Needed because of UMassApplyMovementProcessor::ConfigureQueries requirements even though it's not used
	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);
	check(EntitySubsystem);
	const FConstSharedStruct MovementFragment = EntitySubsystem->GetOrCreateConstSharedFragment(UE::StructUtils::GetStructCrc32(FConstStructView::Make(Movement)), Movement);
	BuildContext.AddConstSharedFragment(MovementFragment);

	const FConstSharedStruct MinZFragment = EntitySubsystem->GetOrCreateConstSharedFragment(UE::StructUtils::GetStructCrc32(FConstStructView::Make(MinZ)), MinZ);
	BuildContext.AddConstSharedFragment(MinZFragment);

	const FConstSharedStruct DebugParametersFragment = EntitySubsystem->GetOrCreateConstSharedFragment(UE::StructUtils::GetStructCrc32(FConstStructView::Make(DebugParameters)), DebugParameters);
	BuildContext.AddConstSharedFragment(DebugParametersFragment);
}

//----------------------------------------------------------------------//
//	UMassProjectileDamagableTrait
//----------------------------------------------------------------------//
void UMassProjectileDamagableTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	if (bIsSoldier)
	{
		BuildContext.AddTag<FMassProjectileDamagableSoldierTag>();
	}

	FProjectileDamagableFragment& ProjectileDamagableTemplate = BuildContext.AddFragment_GetRef<FProjectileDamagableFragment>();
	ProjectileDamagableTemplate.MinCaliberForDamage = MinCaliberForDamage;
}

//----------------------------------------------------------------------//
//	UMassProjectileDamageProcessor
//----------------------------------------------------------------------//
UMassProjectileDamageProcessor::UMassProjectileDamageProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = static_cast<int32>(EProcessorExecutionFlags::All);
	ProcessingPhase = EMassProcessingPhase::PostPhysics;
}

void UMassProjectileDamageProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FProjectileDamageFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassPreviousLocationFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassProjectileWithDamageTag>(EMassFragmentPresence::All);
	EntityQuery.AddConstSharedRequirement<FDebugParameters>(EMassFragmentPresence::All);
}

void UMassProjectileDamageProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	NavigationSubsystem = UWorld::GetSubsystem<UMassNavigationSubsystem>(Owner.GetWorld());
	SignalSubsystem = UWorld::GetSubsystem<UMassSignalSubsystem>(Owner.GetWorld());
}

static void FindCloseObstacles(const FVector& Center, const float SearchRadius, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid,
	TProjectileDamageObstacleItemArray& OutCloseEntities)
{
	OutCloseEntities.Reset();
	const FVector Extent(SearchRadius, SearchRadius, 0.f);
	const FBox QueryBox = FBox(Center - Extent, Center + Extent);

	struct FSortingCell
	{
		int32 X;
		int32 Y;
		int32 Level;
		float SqDist;
	};
	TArray<FSortingCell, TInlineAllocator<64>> Cells;
	const FVector QueryCenter = QueryBox.GetCenter();

	for (int32 Level = 0; Level < AvoidanceObstacleGrid.NumLevels; Level++)
	{
		const float CellSize = AvoidanceObstacleGrid.GetCellSize(Level);
		const FNavigationObstacleHashGrid2D::FCellRect Rect = AvoidanceObstacleGrid.CalcQueryBounds(QueryBox, Level);
		for (int32 Y = Rect.MinY; Y <= Rect.MaxY; Y++)
		{
			for (int32 X = Rect.MinX; X <= Rect.MaxX; X++)
			{
				const float CenterX = (X + 0.5f) * CellSize;
				const float CenterY = (Y + 0.5f) * CellSize;
				const float DX = CenterX - QueryCenter.X;
				const float DY = CenterY - QueryCenter.Y;
				const float SqDist = DX * DX + DY * DY;
				FSortingCell SortCell;
				SortCell.X = X;
				SortCell.Y = Y;
				SortCell.Level = Level;
				SortCell.SqDist = SqDist;
				Cells.Add(SortCell);
			}
		}
	}

	Cells.Sort([](const FSortingCell& A, const FSortingCell& B) { return A.SqDist < B.SqDist; });

	for (const FSortingCell& SortedCell : Cells)
	{
		if (const FNavigationObstacleHashGrid2D::FCell* Cell = AvoidanceObstacleGrid.FindCell(SortedCell.X, SortedCell.Y, SortedCell.Level))
		{
			const TSparseArray<FNavigationObstacleHashGrid2D::FItem>& Items = AvoidanceObstacleGrid.GetItems();
			for (int32 Idx = Cell->First; Idx != INDEX_NONE; Idx = Items[Idx].Next)
			{
				OutCloseEntities.Add(Items[Idx].ID);
				if (OutCloseEntities.Num() >= GUMassProjectileWithDamageTrait_MaxClosestEntitiesToFind)
				{
					return;
				}
			}
		}
	}
}

// Returns true if found at least one close entity that is not Entity. Note that OutCloseEntities may include Entity if it is a navigation obstacle.
bool GetClosestEntities(const FMassEntityHandle& Entity, const UMassEntitySubsystem& EntitySubsystem, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid, const FVector& Location, const float Radius, TProjectileDamageObstacleItemArray& OutCloseEntities)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassProjectileDamageProcessor.GetClosestEntity);

	// TODO: Assumes that all avoidance obstacles are entities that could be damaged. Change instead to the same hash grid used for enemy target finder?
	FindCloseObstacles(Location, Radius, AvoidanceObstacleGrid, OutCloseEntities);

	for (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : OutCloseEntities)
	{
		// Skip self
		if (OtherEntity.Entity == Entity)
		{
			continue;
		}

		// Skip invalid entities.
		if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
		{
			continue;
		}
		return true;
	}

	return false;
}

bool DidCollideViaLineTrace(const UWorld &World, const FVector& StartLocation, const FVector &EndLocation, const bool& DrawLineTraces)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassProjectileDamageProcessor.DidCollideViaLineTrace);

	FHitResult HitResult;
	bool const bSuccess = World.LineTraceSingleByChannel(HitResult, StartLocation, EndLocation, ECollisionChannel::ECC_Visibility);
	if (DrawLineTraces)
	{
		AsyncTask(ENamedThreads::GameThread, [HitResult, &World]()
		{
			static const FLinearColor TraceColor = FLinearColor::Red;
			static const FLinearColor TraceHitColor = FLinearColor::Green;

			if (HitResult.bBlockingHit)
			{
				// Red up to the blocking hit, green thereafter
				::DrawDebugLine(&World, HitResult.TraceStart, HitResult.ImpactPoint, TraceColor.ToFColor(true), true);
				::DrawDebugLine(&World, HitResult.ImpactPoint, HitResult.TraceEnd, TraceHitColor.ToFColor(true), true);
				::DrawDebugPoint(&World, HitResult.ImpactPoint, 16.f, TraceColor.ToFColor(true), true);
			}
			else
			{
				// no hit means all red
				::DrawDebugLine(&World, HitResult.TraceStart, HitResult.TraceEnd, TraceColor.ToFColor(true), true);
			}
		});
	}

	return bSuccess;
}

bool UMassProjectileDamageProcessor_DrawCapsules = false;
FAutoConsoleVariableRef CVarUMassProjectileDamageProcessor_DrawCapsules(TEXT("pm.UMassProjectileDamageProcessor_DrawCapsules"), UMassProjectileDamageProcessor_DrawCapsules, TEXT("UMassProjectileDamageProcessor: Debug draw capsules used for collisions detection"));

bool DidCollideWithEntity(const FVector& StartLocation, const FVector& EndLocation, const float Radius, const bool& DrawCapsules, const UWorld& World, const FMassEntityView& OtherEntityView)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassProjectileDamageProcessor.DidCollideWithEntity);

	const FCapsule ProjectileCapsule(StartLocation, EndLocation, Radius);
	const FCapsule& OtherEntityCapsule = MakeCapsuleForEntity(OtherEntityView);
	const bool& bDidCollide = TestCapsuleCapsule(ProjectileCapsule, OtherEntityCapsule);

	if (DrawCapsules || UMassProjectileDamageProcessor_DrawCapsules)
	{
		AsyncTask(ENamedThreads::GameThread, [&World, bDidCollide, ProjectileCapsule, OtherEntityCapsule]()
		{
			const auto& CapsuleColor = bDidCollide ? FLinearColor::Green : FLinearColor::Red;
			DrawCapsule(ProjectileCapsule, World, CapsuleColor);
			DrawCapsule(OtherEntityCapsule, World, CapsuleColor);
		});
	}

	return bDidCollide;
}

bool CanProjectileDamageEntity(const FProjectileDamagableFragment* ProjectileDamagableFragment, const float& ProjectileCaliber)
{
	return ProjectileDamagableFragment && ProjectileCaliber >= ProjectileDamagableFragment->MinCaliberForDamage;
}

bool UMassProjectileDamageProcessor_SkipDealingDamage = false;
FAutoConsoleVariableRef CVarUMassProjectileDamageProcessor_SkipDealingDamage(TEXT("pm.UMassProjectileDamageProcessor_SkipDealingDamage"), UMassProjectileDamageProcessor_SkipDealingDamage, TEXT("UMassProjectileDamageProcessor: Skip dealing damage"));

bool UMassProjectileDamageProcessor_DrawDamageDealt = false;
FAutoConsoleVariableRef CVarUUMassProjectileDamageProcessor_DrawDamageDealt(TEXT("pm.UMassProjectileDamageProcessor_DrawDamageDealt"), UMassProjectileDamageProcessor_DrawDamageDealt, TEXT("UMassProjectileDamageProcessor: Debug draw damage dealt"));

AMassCharacter* GetMassCharacterForEntity(const FMassEntityView EntityView)
{
	FMassActorFragment* ActorFragment = EntityView.GetFragmentDataPtr<FMassActorFragment>();
	if (ActorFragment)
	{
		AActor* Actor = ActorFragment->GetMutable();

		if (AMassCharacter* MassCharacter = Cast<AMassCharacter>(Actor))
		{
			return MassCharacter;
		}
	}

	return nullptr;
}

void DealDamage(const FVector& ImpactLocation, const FMassEntityView EntityToDealDamageToView, const FProjectileDamageFragment& ProjectileDamageFragment, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& SoldiersThatHaveDied, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& PlayersToDestroy, UWorld* World, const bool OverrideSplashDamageWithRegularDamage = false)
{
	FMassHealthFragment* EntityToDealDamageToHealthFragment = EntityToDealDamageToView.GetFragmentDataPtr<FMassHealthFragment>();
	if (!EntityToDealDamageToHealthFragment)
	{
		return;
	}

	const bool& bCanProjectileDamageOtherEntity = CanProjectileDamageEntity(EntityToDealDamageToView.GetFragmentDataPtr<FProjectileDamagableFragment>(), ProjectileDamageFragment.Caliber);
	if (!bCanProjectileDamageOtherEntity)
	{
		return;
	}

	const FTransformFragment* EntityToDealDamageToTransformFragment = EntityToDealDamageToView.GetFragmentDataPtr<FTransformFragment>();
	if (!EntityToDealDamageToTransformFragment)
	{
		return;
	}
	const auto EntityToDealDamageToLocation = EntityToDealDamageToTransformFragment->GetTransform().GetLocation();

	// If splash damage calculate scaled amount of damage based on distance from impact.
	int16 DamageToDeal = ProjectileDamageFragment.DamagePerHit;
	if (ProjectileDamageFragment.SplashDamageRadius > 0 && !OverrideSplashDamageWithRegularDamage)
	{
		const auto DistanceBetweenImpactAndEntityToDealDamageTo = (ImpactLocation - EntityToDealDamageToLocation).Size();
		const auto SplashDamageScale = ProjectileDamageFragment.SplashDamageRadius - DistanceBetweenImpactAndEntityToDealDamageTo;
		if (SplashDamageScale <= 0)
		{
			return;
		}

		DamageToDeal = SplashDamageScale / ProjectileDamageFragment.SplashDamageRadius * ProjectileDamageFragment.DamagePerHit;
	}

	EntityToDealDamageToHealthFragment->Value -= DamageToDeal;

	// Handle health reaching 0.
	if (EntityToDealDamageToHealthFragment->Value <= 0)
	{
		const bool bHasPlayerTag = EntityToDealDamageToView.HasTag<FMassPlayerControllableCharacterTag>();
		if (!bHasPlayerTag)
		{
			if (AMassCharacter* MassCharacter = GetMassCharacterForEntity(EntityToDealDamageToView))
			{
				AsyncTask(ENamedThreads::GameThread, [MassCharacter](){
					MassCharacter->BP_OnCharacterDeath();
				});
			}
			SoldiersThatHaveDied.Enqueue(EntityToDealDamageToView.GetEntity());
		}
		else {
			PlayersToDestroy.Enqueue(EntityToDealDamageToView.GetEntity());
		}
	}

	if (UMassProjectileDamageProcessor_DrawDamageDealt)
	{
		AsyncTask(ENamedThreads::GameThread, [World, DamageToDeal, EntityToDealDamageToLocation]()
		{
			DrawDebugString(World, EntityToDealDamageToLocation, FString::FromInt(DamageToDeal), nullptr, FColor::Red, 5.f);
		});
	}
}

void HandleProjectImpactSoundPerception(UWorld* World, const FVector& Location, const FMassEntityHandle& CollidedEntity, const UMassEntitySubsystem& EntitySubsystem)
{
	const bool& bHasCollidedEntity = CollidedEntity.IsSet();
	bool bIsCollidedEntityOnTeam1;

	if (bHasCollidedEntity)
	{
		const FMassEntityView CollidedEntityView(EntitySubsystem, CollidedEntity);
		const FTeamMemberFragment* CollidedEntityTeamMemberFragment = CollidedEntityView.GetFragmentDataPtr<FTeamMemberFragment>();
		if (CollidedEntityTeamMemberFragment)
		{
			bIsCollidedEntityOnTeam1 = CollidedEntityTeamMemberFragment->IsOnTeam1;
		}
		else
		{
			UE_LOG(LogTemp, Error, TEXT("HandleProjectImpactSoundPerception: Collided Entity does not have expected FTeamMemberFragment."));
		}
	}

	AsyncTask(ENamedThreads::GameThread, [World, Location = Location, bHasCollidedEntity, bIsCollidedEntityOnTeam1]()
	{
		UMassSoundPerceptionSubsystem* SoundPerceptionSubsystem = UWorld::GetSubsystem<UMassSoundPerceptionSubsystem>(World);
		check(SoundPerceptionSubsystem);
		if (bHasCollidedEntity)
		{
			SoundPerceptionSubsystem->AddSoundPerception(Location, bIsCollidedEntityOnTeam1);
		}
		else
		{
			SoundPerceptionSubsystem->AddSoundPerception(Location);
		}
	});
}

void HandleProjectileImpact(TQueue<FMassEntityHandle, EQueueMode::Mpsc>& ProjectilesToDestroy, const FMassEntityHandle Entity, UWorld* World, const FProjectileDamageFragment& ProjectileDamageFragment, const FVector& Location, const TProjectileDamageObstacleItemArray& CloseEntities, const bool& DrawLineTraces, const UMassEntitySubsystem& EntitySubsystem, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& SoldiersThatHaveDied, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& PlayersToDestroy, const FMassEntityHandle& CollidedEntity)
{
	ProjectilesToDestroy.Enqueue(Entity);

	HandleProjectImpactSoundPerception(World, Location, CollidedEntity, EntitySubsystem);

	if (ProjectileDamageFragment.ExplosionEntityConfigIndex >= 0)
	{
		UMassVisualEffectsSubsystem* MassVisualEffectsSubsystem = UWorld::GetSubsystem<UMassVisualEffectsSubsystem>(World);
		check(MassVisualEffectsSubsystem);

		// Must be done async because we can't spawn Mass entities in the middle of a Mass processor's Execute method.
		AsyncTask(ENamedThreads::GameThread, [MassVisualEffectsSubsystem, ExplosionEntityConfigIndex = ProjectileDamageFragment.ExplosionEntityConfigIndex, Location]()
		{
			MassVisualEffectsSubsystem->SpawnEntity(ExplosionEntityConfigIndex, Location);
		});
	}

	if (UMassProjectileDamageProcessor_SkipDealingDamage)
	{
		return;
	}

	if (CloseEntities.Num() == 0)
	{
		return;
	}

	const bool bDealSplashDamage = ProjectileDamageFragment.SplashDamageRadius > 0;
	if (bDealSplashDamage)
	{
		for (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : CloseEntities)
		{
			if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
			{
				continue;
			}
			FMassEntityView OtherEntityEntityView(EntitySubsystem, OtherEntity.Entity);
			if (CollidedEntity.IsValid() && CollidedEntity == OtherEntity.Entity)
			{
				// Deal full damage (not splash damage) to entity which was collided with.
				DealDamage(Location, OtherEntityEntityView, ProjectileDamageFragment, SoldiersThatHaveDied, PlayersToDestroy, World, true);
				continue;
			}
			const FTransformFragment* OtherEntityTransformFragment = OtherEntityEntityView.GetFragmentDataPtr<FTransformFragment>();
			if (!OtherEntityTransformFragment)
			{
				continue;
			}

			if (!DidCollideViaLineTrace(*World, Location, OtherEntityTransformFragment->GetTransform().GetLocation(), DrawLineTraces))
			{
				DealDamage(Location, OtherEntityEntityView, ProjectileDamageFragment, SoldiersThatHaveDied, PlayersToDestroy, World);
			}

		}
	}
	else if (CollidedEntity.IsValid())
	{
		const FMassEntityView OtherEntityEntityView(EntitySubsystem, CollidedEntity);
		DealDamage(Location, OtherEntityEntityView, ProjectileDamageFragment, SoldiersThatHaveDied, PlayersToDestroy, World);
	}
}

void ProcessProjectileDamageEntity(FMassExecutionContext& Context, FMassEntityHandle Entity, const UMassEntitySubsystem& EntitySubsystem, const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid, const FTransformFragment& Location, const FAgentRadiusFragment& Radius, const FProjectileDamageFragment& ProjectileDamageFragment, TProjectileDamageObstacleItemArray& OutCloseEntities, const FMassPreviousLocationFragment& PreviousLocationFragment, const bool& DrawLineTraces, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& ProjectilesToDestroy, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& SoldiersThatHaveDied, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& PlayersToDestroy)
{
	UWorld* World = EntitySubsystem.GetWorld();

	const FVector& CurrentLocation = Location.GetTransform().GetLocation();
	const float DistanceFromLastFrameToCurrentFrame = (CurrentLocation - PreviousLocationFragment.Location).Size();
	const bool bHasCloseEntity = GetClosestEntities(Entity, EntitySubsystem, AvoidanceObstacleGrid, CurrentLocation, DistanceFromLastFrameToCurrentFrame, OutCloseEntities);

	// If collide via line trace, we hit the environment, so destroy projectile and deal splash damage if needed.
	if (DidCollideViaLineTrace(*World, PreviousLocationFragment.Location, CurrentLocation, DrawLineTraces))
	{
		HandleProjectileImpact(ProjectilesToDestroy, Entity, World, ProjectileDamageFragment, CurrentLocation, OutCloseEntities, DrawLineTraces, EntitySubsystem, SoldiersThatHaveDied, PlayersToDestroy, FMassEntityHandle());
		return;
	}

	if (!bHasCloseEntity) {
		return;
	}
	
	for (const FNavigationObstacleHashGrid2D::ItemIDType OtherEntity : OutCloseEntities)
	{
		if (!EntitySubsystem.IsEntityValid(OtherEntity.Entity))
		{
			continue;
		}

		FMassEntityView OtherEntityView(EntitySubsystem, OtherEntity.Entity);
		if (OtherEntityView.HasTag<FMassSoldierIsDyingTag>())
		{
			continue;
		}

		if (!DidCollideWithEntity(PreviousLocationFragment.Location, CurrentLocation, Radius.Radius, DrawLineTraces, *World, OtherEntityView))
		{
			continue;
		}

		HandleProjectileImpact(ProjectilesToDestroy, Entity, World, ProjectileDamageFragment, CurrentLocation, OutCloseEntities, DrawLineTraces, EntitySubsystem, SoldiersThatHaveDied, PlayersToDestroy, OtherEntity.Entity);

		// If we got here, we've collided with an entity, so no need to check other close entities.
		return;
	}
}

bool UMassProjectileDamageProcessor_UseParallelForEachEntityChunk = true;
FAutoConsoleVariableRef CVarUMassProjectileDamageProcessor_UseParallelForEachEntityChunk(TEXT("pm.UMassProjectileDamageProcessor_UseParallelForEachEntityChunk"), UMassProjectileDamageProcessor_UseParallelForEachEntityChunk, TEXT("Use ParallelForEachEntityChunk in UMassProjectileDamageProcessor::Execute to improve performance"));

void ProcessQueues(TQueue<FMassEntityHandle, EQueueMode::Mpsc>& ProjectilesToDestroy, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& SoldiersThatHaveDied, TQueue<FMassEntityHandle, EQueueMode::Mpsc>& PlayersToDestroy, UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context, TObjectPtr<UMassSignalSubsystem> SignalSubsystem)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassProjectileDamageProcessor.ProcessQueues);

	const UWorld* World = EntitySubsystem.GetWorld();

	// Destroy projectiles.
	while (!ProjectilesToDestroy.IsEmpty())
	{
		FMassEntityHandle EntityToDestroy;
		const bool bSuccess = ProjectilesToDestroy.Dequeue(EntityToDestroy);
		check(bSuccess);
		Context.Defer().DestroyEntity(EntityToDestroy);
	}

	// Destroy AI soldiers.
	UMilitaryStructureSubsystem* MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(World);
	check(MilitaryStructureSubsystem);
	TArray<FMassEntityHandle> EntitiesToSignalDeath;
	while (!SoldiersThatHaveDied.IsEmpty())
	{
		FMassEntityHandle SoldierEntityThatHasDied;
		const bool bSuccess = SoldiersThatHaveDied.Dequeue(SoldierEntityThatHasDied);
		check(bSuccess);

		Context.Defer().AddTag<FMassSoldierIsDyingTag>(SoldierEntityThatHasDied);
		
		Context.Defer().RemoveTag<FMassNeedsEnemyTargetTag>(SoldierEntityThatHasDied); // Ensure soldier no longer looks for enemy targets.
		Context.Defer().RemoveTag<FMassWillNeedEnemyTargetTag>(SoldierEntityThatHasDied); // Ensure soldier no longer will get tag to look for enemy targets in future.

		Context.Defer().RemoveTag<FMassNeedsNavMeshMoveTag>(SoldierEntityThatHasDied); // Ensure soldier no longer moves to next action in Nav Mesh.
		Context.Defer().RemoveTag<FMassCommandableTag>(SoldierEntityThatHasDied); // Ensure soldier no longer follows commands.

		Context.Defer().PushCommand(FCommandRemoveFragmentList(SoldierEntityThatHasDied,
			{FProjectileDamagableFragment::StaticStruct(), // If a projectile hits soldier during death montage we won't try to restart death montage.
			FMassNavigationObstacleGridCellLocationFragment::StaticStruct(), // We currently rely on avoidance obstacle grid to decide entities that projectiles can damage. TODO: Change to use target grid, then delete this line.
			FMassTargetGridCellLocationFragment::StaticStruct()})); // Ensure soldier is no longer considered a potential target.

		FMassDelayedDestructionFragment DelayedDestructionFragment;
		DelayedDestructionFragment.SecondsLeftTilDestruction = 2.1f; // TODO: Make this configurable via ProjectileDamagable Trait?
		Context.Defer().PushCommand(FCommandAddFragmentInstance(SoldierEntityThatHasDied, FConstStructView::Make(DelayedDestructionFragment)));
		
		EntitiesToSignalDeath.Add(SoldierEntityThatHasDied); // Required for soldier to start playing death animation.

		MilitaryStructureSubsystem->DestroyEntity(SoldierEntityThatHasDied);
	}

	if (EntitiesToSignalDeath.Num())
	{
		SignalSubsystem->SignalEntities(UE::Mass::Signals::NewStateTreeTaskRequired, EntitiesToSignalDeath);
	}

	// Destroy player soldiers.
	UMassPlayerSubsystem* PlayerSubsystem = UWorld::GetSubsystem<UMassPlayerSubsystem>(World);
	check(PlayerSubsystem);
	while (!PlayersToDestroy.IsEmpty())
	{
		FMassEntityHandle EntityToDestroy;
		const bool bSuccess = PlayersToDestroy.Dequeue(EntityToDestroy);
		check(bSuccess);
		AActor* OtherActor = PlayerSubsystem->GetActorForEntity(EntityToDestroy);
		check(OtherActor);
		ACommanderCharacter* Character = CastChecked<ACommanderCharacter>(OtherActor);
		AsyncTask(ENamedThreads::GameThread, [Character]()
		{
			Character->DidDie();
		});
	}
}

void UMassProjectileDamageProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UMassProjectileDamageProcessor);

	if (!NavigationSubsystem)
	{
		return;
	}

	TQueue<FMassEntityHandle, EQueueMode::Mpsc> ProjectilesToDestroy;
	TQueue<FMassEntityHandle, EQueueMode::Mpsc> SoldiersThatHaveDied;
	TQueue<FMassEntityHandle, EQueueMode::Mpsc> PlayersToDestroy;

	auto ExecuteFunction = [&EntitySubsystem, &NavigationSubsystem = NavigationSubsystem, &ProjectilesToDestroy, &SoldiersThatHaveDied, &PlayersToDestroy](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FAgentRadiusFragment> RadiusList = Context.GetFragmentView<FAgentRadiusFragment>();
		const TConstArrayView<FProjectileDamageFragment> ProjectileDamageList = Context.GetFragmentView<FProjectileDamageFragment>();
		const TArrayView<FMassPreviousLocationFragment> PreviousLocationList = Context.GetMutableFragmentView<FMassPreviousLocationFragment>();
		const FDebugParameters& DebugParameters = Context.GetConstSharedFragment<FDebugParameters>();

		TProjectileDamageObstacleItemArray CloseEntities;

		// Used for storing sorted list of nearest obstacles.
		struct FSortedObstacle
		{
			FVector LocationCached;
			FVector Forward;
			FMassNavigationObstacleItem ObstacleItem;
			float SqDist;
		};

		// TODO: We're incorrectly assuming all obstacles can get damaged by projectile.
		const FNavigationObstacleHashGrid2D& AvoidanceObstacleGrid = NavigationSubsystem->GetObstacleGridMutable();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			ProcessProjectileDamageEntity(Context, Context.GetEntity(EntityIndex), EntitySubsystem, AvoidanceObstacleGrid, LocationList[EntityIndex], RadiusList[EntityIndex], ProjectileDamageList[EntityIndex], CloseEntities, PreviousLocationList[EntityIndex], DebugParameters.DrawLineTraces, ProjectilesToDestroy, SoldiersThatHaveDied, PlayersToDestroy);
			PreviousLocationList[EntityIndex].Location = LocationList[EntityIndex].GetTransform().GetLocation();
		}
	};

	if (UMassProjectileDamageProcessor_UseParallelForEachEntityChunk)
	{
		EntityQuery.ParallelForEachEntityChunk(EntitySubsystem, Context, ExecuteFunction);
	}
	else
	{
		EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, ExecuteFunction);
	}

	ProcessQueues(ProjectilesToDestroy, SoldiersThatHaveDied, PlayersToDestroy, EntitySubsystem, Context, SignalSubsystem);
}

```

`Source/ProjectM/Private/MassProjectileRemoverProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassProjectileRemoverProcessor.h"
#include "MassProjectileDamageProcessor.h"
#include "MassCommonFragments.h"

UMassProjectileRemoverProcessor::UMassProjectileRemoverProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ProcessingPhase = EMassProcessingPhase::PostPhysics;
}

void UMassProjectileRemoverProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddTagRequirement<FMassProjectileWithDamageTag>(EMassFragmentPresence::All);
	EntityQuery.AddConstSharedRequirement<FMinZParameters>(EMassFragmentPresence::All);
}

void UMassProjectileRemoverProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [&EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		const FMinZParameters& MinZParams = Context.GetConstSharedFragment<FMinZParameters>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			const FTransformFragment& Location = LocationList[EntityIndex];
			if (Location.GetTransform().GetTranslation().Z <= MinZParams.Value)
			{
				Context.Defer().DestroyEntity(Context.GetEntity(EntityIndex));
			}
		}
	});
}

```

`Source/ProjectM/Private/MassRifle.cpp`:

```cpp
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.


#include "MassRifle.h"
#include "MassFireProjectileTask.h"
#include "MassEnemyTargetFinderProcessor.h"

AMassRifle::AMassRifle()
{
	PrimaryActorTick.bCanEverTick = false;
}

void AMassRifle::SpawnProjectile(const FTransform SpawnTransform, const bool bIsPlayerTeam1) const
{
	const UWorld* World = GetWorld();
	const FVector InitialVelocity = SpawnTransform.GetRotation().Vector() * GetProjectileInitialXYVelocityMagnitude(true);
	::SpawnProjectile(World, SpawnTransform.GetLocation(), SpawnTransform.GetRotation(), InitialVelocity, ProjectileEntityConfig, bIsPlayerTeam1);
}

```

`Source/ProjectM/Private/MassSimpleUpdateISMProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassSimpleUpdateISMProcessor.h"

bool UMassSimpleUpdateISMProcessor_SkipRendering = false;
FAutoConsoleVariableRef CVarUMassSimpleUpdateISMProcessor_SkipRendering(TEXT("pm.UMassSimpleUpdateISMProcessor_SkipRendering"), UMassSimpleUpdateISMProcessor_SkipRendering, TEXT("UMassSimpleUpdateISMProcessor: Skip Rendering"));

//----------------------------------------------------------------------//
//  UMassSimpleUpdateISMTrait
//----------------------------------------------------------------------//
void UMassSimpleUpdateISMTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
  if (!UMassSimpleUpdateISMProcessor_SkipRendering)
  {
    BuildContext.AddTag<FMassSimpleUpdateISMTag>();
  }
}

//----------------------------------------------------------------------//
//  UMassSimpleUpdateISMProcessor
//----------------------------------------------------------------------//
UMassSimpleUpdateISMProcessor::UMassSimpleUpdateISMProcessor()
{
  bAutoRegisterWithProcessingPhases = true;
}

void UMassSimpleUpdateISMProcessor::ConfigureQueries()
{
  Super::ConfigureQueries();

  EntityQuery.AddTagRequirement<FMassSimpleUpdateISMTag>(EMassFragmentPresence::All);
}
```

`Source/ProjectM/Private/MassSoldierDyingEvaluator.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassSoldierDyingEvaluator.h"

#include "MassAIBehaviorTypes.h"
#include "MassStateTreeExecutionContext.h"

bool FMassSoldierDyingEvaluator::Link(FStateTreeLinker& Linker)
{
	Linker.LinkInstanceDataProperty(IsDyingHandle, STATETREE_INSTANCEDATA_PROPERTY(FMassSoldierDyingEvaluatorInstanceData, bIsDying));

	return true;
}

void FMassSoldierDyingEvaluator::Evaluate(FStateTreeExecutionContext& Context, const EStateTreeEvaluationType EvalType, const float DeltaTime) const
{
	bool& bIsDying = Context.GetInstanceData(IsDyingHandle);

	const FMassStateTreeExecutionContext& MassContext = static_cast<FMassStateTreeExecutionContext&>(Context);
	bIsDying = MassContext.GetEntitySubsystemExecutionContext().DoesArchetypeHaveTag<FMassSoldierIsDyingTag>();
}

```

`Source/ProjectM/Private/MassSoundPerceptionSubsystem.cpp`:

```cpp
#include "MassSoundPerceptionSubsystem.h"

#include "HAL/IConsoleManager.h"
#include "DrawDebugHelpers.h"
#include <MassEnemyTargetFinderProcessor.h>

static int32 GMassSoundPerceptionSubsystemCounter = 0;
static constexpr float GUMassSoundPerceptionSubsystem_GridCellSize = 100000.f; // TODO: value here may not be optimal for performance.

UMassSoundPerceptionSubsystem::UMassSoundPerceptionSubsystem()
	: SoundPerceptionGridForTeam1(GUMassSoundPerceptionSubsystem_GridCellSize), SoundPerceptionGridForTeam2(GUMassSoundPerceptionSubsystem_GridCellSize)
{
}

void UMassSoundPerceptionSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	Collection.InitializeDependency<UMassSimulationSubsystem>();
}

void UMassSoundPerceptionSubsystem::Tick(float DeltaTime)
{
	TArray<uint32> ItemsToRemove;
	for (const auto& Item : SoundPerceptionGridForTeam1.GetItems())
	{
		uint8& TicksLeftTilDestruction = IdsToMetaDataForTeam1[Item.ID].TicksLeftTilDestruction;
		TicksLeftTilDestruction--;
		if (TicksLeftTilDestruction <= 0)
		{
			ItemsToRemove.Add(Item.ID);
		}
	}
	for (const int32& ItemID : ItemsToRemove)
	{
		SoundPerceptionGridForTeam1.Remove(ItemID, IdsToMetaDataForTeam1[ItemID].CellLocation);
		IdsToMetaDataForTeam1.Remove(ItemID);
	}

	ItemsToRemove.Reset();

	for (const auto& Item : SoundPerceptionGridForTeam2.GetItems())
	{
		uint8& TicksLeftTilDestruction = IdsToMetaDataForTeam2[Item.ID].TicksLeftTilDestruction;
		TicksLeftTilDestruction--;
		if (TicksLeftTilDestruction <= 0)
		{
			ItemsToRemove.Add(Item.ID);
		}
	}
	for (const int32& ItemID : ItemsToRemove)
	{
		SoundPerceptionGridForTeam2.Remove(ItemID, IdsToMetaDataForTeam2[ItemID].CellLocation);
		IdsToMetaDataForTeam2.Remove(ItemID);
	}
}

bool UMassSoundPerceptionSubsystem_DrawOnAddSoundPerception = false;
FAutoConsoleVariableRef CVarUMassSoundPerceptionSubsystem_DrawOnAddSoundPerception(TEXT("pm.UMassSoundPerceptionSubsystem_DrawOnAddSoundPerception"), UMassSoundPerceptionSubsystem_DrawOnAddSoundPerception, TEXT("UMassSoundPerceptionSubsystem: Draw On AddSoundPerception"));

void UMassSoundPerceptionSubsystem::AddSoundPerception(const FVector Location, const bool& bIsSourceFromTeam1, const bool SkipDebugDraw)
{
	auto& SoundPerceptionGrid = bIsSourceFromTeam1 ? SoundPerceptionGridForTeam1 : SoundPerceptionGridForTeam2;
	uint32 ItemID = GMassSoundPerceptionSubsystemCounter++;
	static const float Extent = 3.f;
	const FBox Bounds(Location - FVector(Extent, Extent, 0.f), Location + FVector(Extent, Extent, 0.f));
	const FSoundPerceptionHashGrid2D::FCellLocation& CellLocation = SoundPerceptionGrid.Add(ItemID, Bounds);


  const FMassSoundPerceptionItemMetaData ItemMetaData(FramesUntilSoundPerceptionDestruction, CellLocation, Location);
	auto& IdsToMetaData = bIsSourceFromTeam1 ? IdsToMetaDataForTeam1 : IdsToMetaDataForTeam2;
	IdsToMetaData.Add(ItemID, ItemMetaData);

	if (UMassSoundPerceptionSubsystem_DrawOnAddSoundPerception && !SkipDebugDraw)
	{
		::DrawDebugSphere(GetWorld(), Location, 200.f, 10, bIsSourceFromTeam1 ? FColor::Red : FColor::Blue, false, 0.1f);
	}
}

// TODO: This isn't on by default yet because it makes the AI do pretty dumb stuff like turn away from enemies if there's an explosion behind them. Need to improve.
bool UMassSoundPerceptionSubsystem_AddEnvironmentImpactSounds = false;
FAutoConsoleVariableRef CVar_UMassSoundPerceptionSubsystem_AddEnvironmentImpactSounds(TEXT("pm.UMassSoundPerceptionSubsystem_AddEnvironmentImpactSounds"), UMassSoundPerceptionSubsystem_AddEnvironmentImpactSounds, TEXT("UMassSoundPerceptionSubsystem_AddEnvironmentImpactSounds"));

void UMassSoundPerceptionSubsystem::AddSoundPerception(const FVector Location)
{
	if (!UMassSoundPerceptionSubsystem_AddEnvironmentImpactSounds)
	{
		return;
	}

	AddSoundPerception(Location, true, true);
	AddSoundPerception(Location, false, true);

	if (UMassSoundPerceptionSubsystem_DrawOnAddSoundPerception)
	{
		::DrawDebugSphere(GetWorld(), Location, 200.f, 10, FColor::White, false, 0.1f);
	}
}

TStatId UMassSoundPerceptionSubsystem::GetStatId() const
{
	RETURN_QUICK_DECLARE_CYCLE_STAT(UMassSoundPerceptionSubsystem, STATGROUP_Tickables);
}

bool UMassSoundPerceptionSubsystem::GetSoundsNearLocation(const FVector& Location, TArray<FVector>& OutCloseSounds, const bool bFilterToTeam1)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("UMassSoundPerceptionSubsystem.GetSoundsNearLocation");

  const auto& SoundPerceptionGrid = bFilterToTeam1 ? SoundPerceptionGridForTeam1 : SoundPerceptionGridForTeam2;
	TArray<FSoundPerceptionHashGrid2D::ItemIDType> NearbySounds;
	static constexpr float QueryRadius = GUMassSoundPerceptionSubsystem_GridCellSize / 2.f;
	const FVector Extent(QueryRadius, QueryRadius, QueryRadius);
	const FBox QueryBox = FBox(Location - Extent, Location + Extent);

	SoundPerceptionGrid.Query(QueryBox, NearbySounds);

	auto& IdsToMetaData = bFilterToTeam1 ? IdsToMetaDataForTeam1 : IdsToMetaDataForTeam2;

	for (const FSoundPerceptionHashGrid2D::ItemIDType& SoundID : NearbySounds)
	{
		OutCloseSounds.Add(IdsToMetaData[SoundID].SoundSource);
	};

	return !OutCloseSounds.IsEmpty();
}

```

`Source/ProjectM/Private/MassSwapEntityOnDestructionTrait.cpp`:

```cpp
#include "MassSwapEntityOnDestructionTrait.h"

#include <MassVisualEffectsSubsystem.h>
#include <MassCommonFragments.h>

//----------------------------------------------------------------------//
//  UMassSwapEntityOnDestructionTrait
//----------------------------------------------------------------------//
void UMassSwapEntityOnDestructionTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	if (SwappedEntityConfig)
	{
		FMassSwapEntityOnDestructionFragment& SwapEntityOnDestructionFragment = BuildContext.AddFragment_GetRef<FMassSwapEntityOnDestructionFragment>();
		UMassVisualEffectsSubsystem* MassVisualEffectsSubsystem = UWorld::GetSubsystem<UMassVisualEffectsSubsystem>(&World);
		SwapEntityOnDestructionFragment.SwappedEntityConfigIndex = MassVisualEffectsSubsystem->FindOrAddEntityConfig(SwappedEntityConfig);
	}
}

//----------------------------------------------------------------------//
//  UMassSwapEntityOnDestructionProcessor
//----------------------------------------------------------------------//
UMassSwapEntityOnDestructionProcessor::UMassSwapEntityOnDestructionProcessor()
{
	ObservedType = FMassSwapEntityOnDestructionFragment::StaticStruct();
	Operation = EMassObservedOperation::Remove;
	ExecutionFlags = (int32)(EProcessorExecutionFlags::All);
}

void UMassSwapEntityOnDestructionProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassSwapEntityOnDestructionFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
}

void UMassSwapEntityOnDestructionProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		TConstArrayView<FMassSwapEntityOnDestructionFragment> SwapEntityOnDestructionList = Context.GetFragmentView<FMassSwapEntityOnDestructionFragment>();
		TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			const int16 SwappedEntityConfigIndex = SwapEntityOnDestructionList[i].SwappedEntityConfigIndex;
			if (SwappedEntityConfigIndex >= 0)
			{
				UMassVisualEffectsSubsystem* MassVisualEffectsSubsystem = UWorld::GetSubsystem<UMassVisualEffectsSubsystem>(EntitySubsystem.GetWorld());
				check(MassVisualEffectsSubsystem);

				const FTransform& EntityTransform = TransformList[i].GetTransform();

				// Must be done async because we can't spawn Mass entities in the middle of a Mass processor's Execute method.
				AsyncTask(ENamedThreads::GameThread, [MassVisualEffectsSubsystem, SwappedEntityConfigIndex = SwappedEntityConfigIndex, EntityTransform]()
				{
					MassVisualEffectsSubsystem->SpawnEntity(SwappedEntityConfigIndex, EntityTransform);
				});
			}
		}
	});
}

```

`Source/ProjectM/Private/MassTargetFinderSubsystem.cpp`:

```cpp
#include "MassTargetFinderSubsystem.h"

#include "MassSimulationSubsystem.h"

UMassTargetFinderSubsystem::UMassTargetFinderSubsystem()
	// TODO: Constant here may not be optimal for performance.
	: TargetGrid(UMassEnemyTargetFinder_FinestCellSize)
{
}

void UMassTargetFinderSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	Collection.InitializeDependency<UMassSimulationSubsystem>();
}

```

`Source/ProjectM/Private/MassTargetGridProcessors.cpp`:

```cpp
#include "MassTargetGridProcessors.h"

#include "MassCommonUtils.h"
#include "MassCommandBuffer.h"
#include "MassCommonFragments.h"
#include "MassSimulationLOD.h"
#include "MassMovementTypes.h"
#include "MassMovementFragments.h"
#include "MassEntityView.h"
#include "Engine/World.h"

//----------------------------------------------------------------------//
//  UMassTargetGridProcessor
//----------------------------------------------------------------------//
UMassTargetGridProcessor::UMassTargetGridProcessor()
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Movement);
}

void UMassTargetGridProcessor::ConfigureQueries()
{
	FMassEntityQuery BaseEntityQuery;
	BaseEntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	BaseEntityQuery.AddRequirement<FAgentRadiusFragment>(EMassFragmentAccess::ReadOnly);
	BaseEntityQuery.AddRequirement<FMassTargetGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);
	BaseEntityQuery.AddRequirement<FCollisionCapsuleParametersFragment>(EMassFragmentAccess::ReadOnly);
	BaseEntityQuery.AddRequirement<FProjectileDamagableFragment>(EMassFragmentAccess::ReadOnly);
	BaseEntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);

	AddToGridEntityQuery = BaseEntityQuery;
	AddToGridEntityQuery.AddTagRequirement<FMassInTargetGridTag>(EMassFragmentPresence::None);

	UpdateGridEntityQuery = BaseEntityQuery;
	UpdateGridEntityQuery.AddTagRequirement<FMassInTargetGridTag>(EMassFragmentPresence::All);
}

void UMassTargetGridProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);

	TargetFinderSubsystem = UWorld::GetSubsystem<UMassTargetFinderSubsystem>(Owner.GetWorld());
}

void UMassTargetGridProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	if (!TargetFinderSubsystem)
	{
		return;
	}

	// can't be ParallelFor due to GetTargetGridMutable().Add() not being thread-safe
	AddToGridEntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		TConstArrayView<FAgentRadiusFragment> RadiiList = Context.GetFragmentView<FAgentRadiusFragment>();
		TArrayView<FMassTargetGridCellLocationFragment> TargetGridCellLocationList = Context.GetMutableFragmentView<FMassTargetGridCellLocationFragment>();
		const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();
		const TConstArrayView<FProjectileDamagableFragment> ProjectileDamagableList = Context.GetFragmentView<FProjectileDamagableFragment>();
		const TConstArrayView<FCollisionCapsuleParametersFragment> CollisionCapsuleParametersList = Context.GetFragmentView<FCollisionCapsuleParametersFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			// Add to the grid
			const FTransform& EntityTransform = LocationList[EntityIndex].GetTransform();
			const FVector EntityLocation = EntityTransform.GetLocation();
			const float Radius = RadiiList[EntityIndex].Radius;

			const FMassEntityHandle& TargetEntity = Context.GetEntity(EntityIndex);
			const bool& bIsEntitySolder = Context.DoesArchetypeHaveTag<FMassProjectileDamagableSoldierTag>();
			FMassTargetGridItem TargetGridItem(TargetEntity, TeamMemberList[EntityIndex].IsOnTeam1, ProjectileDamagableList[EntityIndex].MinCaliberForDamage, bIsEntitySolder);

			const FBox NewBounds(EntityLocation - FVector(Radius, Radius, 0.f), EntityLocation + FVector(Radius, Radius, 0.f));
			TargetGridCellLocationList[EntityIndex].CellLoc = TargetFinderSubsystem->GetTargetGridMutable().Add(TargetGridItem, NewBounds);
			
			FCapsule Capsule = MakeCapsuleForEntity(CollisionCapsuleParametersList[EntityIndex], EntityTransform);
			FMassTargetGridItemDynamicData DynamicData(EntityLocation, Capsule);
			TargetFinderSubsystem->GetTargetDynamicDataMutable().Emplace(TargetEntity, DynamicData);

			Context.Defer().AddTag<FMassInTargetGridTag>(TargetEntity);
		}
	});

	UpdateGridEntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		TConstArrayView<FTransformFragment> LocationList = Context.GetFragmentView<FTransformFragment>();
		TConstArrayView<FAgentRadiusFragment> RadiiList = Context.GetFragmentView<FAgentRadiusFragment>();
		TArrayView<FMassTargetGridCellLocationFragment> TargetGridCellLocationList = Context.GetMutableFragmentView<FMassTargetGridCellLocationFragment>();
		const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();
		const TConstArrayView<FProjectileDamagableFragment> ProjectileDamagableList = Context.GetFragmentView<FProjectileDamagableFragment>();
		const TConstArrayView<FCollisionCapsuleParametersFragment> CollisionCapsuleParametersList = Context.GetFragmentView<FCollisionCapsuleParametersFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			// Update position in grid
			const FTransform& EntityTransform = LocationList[EntityIndex].GetTransform();
			const FVector EntityLocation = EntityTransform.GetLocation();
			const float Radius = RadiiList[EntityIndex].Radius;
			
			const FMassEntityHandle& TargetEntity = Context.GetEntity(EntityIndex);
			const bool& bIsEntitySolder = Context.DoesArchetypeHaveTag<FMassProjectileDamagableSoldierTag>();
			FCapsule Capsule = MakeCapsuleForEntity(CollisionCapsuleParametersList[EntityIndex], EntityTransform);
			FMassTargetGridItem TargetGridItem(TargetEntity, TeamMemberList[EntityIndex].IsOnTeam1, ProjectileDamagableList[EntityIndex].MinCaliberForDamage, bIsEntitySolder);
			const FBox NewBounds(EntityLocation - FVector(Radius, Radius, 0.f), EntityLocation + FVector(Radius, Radius, 0.f));

			TargetGridCellLocationList[EntityIndex].CellLoc = TargetFinderSubsystem->GetTargetGridMutable().Move(TargetGridItem, TargetGridCellLocationList[EntityIndex].CellLoc, NewBounds);
			FMassTargetGridItemDynamicData& TargetDynamicData = TargetFinderSubsystem->GetTargetDynamicDataMutable().FindOrAdd(TargetEntity);
			TargetDynamicData.Location = EntityLocation;
			TargetDynamicData.Capsule = Capsule;
		}
	});
}

//----------------------------------------------------------------------//
//  UMassTargetRemoverProcessor
//----------------------------------------------------------------------//
UMassTargetRemoverProcessor::UMassTargetRemoverProcessor()
{
	ObservedType = FMassTargetGridCellLocationFragment::StaticStruct();
	Operation = EMassObservedOperation::Remove;
	ExecutionFlags = (int32)(EProcessorExecutionFlags::All);
}

void UMassTargetRemoverProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassTargetGridCellLocationFragment>(EMassFragmentAccess::ReadWrite);
}

void UMassTargetRemoverProcessor::Initialize(UObject& Owner)
{
	Super::Initialize(Owner);
	TargetFinderSubsystem = UWorld::GetSubsystem<UMassTargetFinderSubsystem>(Owner.GetWorld());
}

void UMassTargetRemoverProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	if (!TargetFinderSubsystem)
	{
		return;
	}

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		TArrayView<FMassTargetGridCellLocationFragment> TargetGridCellLocationList = Context.GetMutableFragmentView<FMassTargetGridCellLocationFragment>();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			FMassTargetGridItem TargetGridItem;
			TargetGridItem.Entity = Context.GetEntity(i);
			TargetFinderSubsystem->GetTargetGridMutable().Remove(TargetGridItem, TargetGridCellLocationList[i].CellLoc);
			TargetFinderSubsystem->GetTargetDynamicDataMutable().Remove(TargetGridItem.Entity);
		}
	});
}

```

`Source/ProjectM/Private/MassTrackTargetProcessor.cpp`:

```cpp
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.


#include "MassTrackTargetProcessor.h"
#include "MassCommonFragments.h"
#include "MassCommonTypes.h"
#include "MassRepresentationTypes.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "MassNavigationFragments.h"

UMassTrackTargetProcessor::UMassTrackTargetProcessor()
{
	bAutoRegisterWithProcessingPhases = true;
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Tasks;
	ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::Representation);
}

void UMassTrackTargetProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTargetEntityFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddTagRequirement<FMassTrackTargetTag>(EMassFragmentPresence::All);
}

void UMassTrackTargetProcessor::Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("UMassTrackTargetProcessor_Execute");

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [this, &EntitySubsystem](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();
		const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
		const TConstArrayView<FTargetEntityFragment> TargetEntityList = Context.GetFragmentView<FTargetEntityFragment>();
		const TArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetMutableFragmentView<FMassMoveTargetFragment>();

		for (int32 i = 0; i < NumEntities; ++i)
		{
			UpdateLookAtTrackedEntity(EntitySubsystem, TransformList[i], TargetEntityList[i], MoveTargetList[i]);
		}
	});
}

void UMassTrackTargetProcessor::UpdateLookAtTrackedEntity(const UMassEntitySubsystem& EntitySubsystem, const FTransformFragment& TransformFragment, const FTargetEntityFragment& TargetEntityFragment, FMassMoveTargetFragment& MoveTargetFragment) const
{
	const FMassEntityHandle& TargetEntity = TargetEntityFragment.Entity;
	if (!TargetEntity.IsSet()) {
		return;
	}

	if (!EntitySubsystem.IsEntityValid(TargetEntity)) {
		return;
	}
	const FTransformFragment* TargetTransformFragment = EntitySubsystem.GetFragmentDataPtr<FTransformFragment>(TargetEntity);
	check(TargetTransformFragment);

	const FTransform& EntityTransform = TransformFragment.GetTransform();
	const FVector& EntityLocation = EntityTransform.GetLocation();
	const FVector NewGlobalDirection = (TargetTransformFragment->GetTransform().GetLocation() - EntityLocation).GetSafeNormal();

	UWorld* World = EntitySubsystem.GetWorld();
	MoveTargetFragment.Forward = NewGlobalDirection;
}

```

`Source/ProjectM/Private/MassTrackedVehicleOrientationProcessor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassTrackedVehicleOrientationProcessor.h"

void UMassTrackedVehicleOrientationTrait::BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const
{
	UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(&World);
	check(EntitySubsystem);

	BuildContext.AddFragment<FMassMoveTargetFragment>();
	BuildContext.AddFragment<FTransformFragment>();
	BuildContext.AddTag<FMassTrackedVehicleOrientationTag>();

	const FConstSharedStruct OrientationFragment = EntitySubsystem->GetOrCreateConstSharedFragment(UE::StructUtils::GetStructCrc32(FConstStructView::Make(Orientation)), Orientation);
	BuildContext.AddConstSharedFragment(OrientationFragment);
}

UMassTrackedVehicleOrientationProcessor::UMassTrackedVehicleOrientationProcessor()
{
	ExecutionFlags = (int32)EProcessorExecutionFlags::All;
	ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;
}

void UMassTrackedVehicleOrientationProcessor::ConfigureQueries()
{
	EntityQuery.AddRequirement<FMassMoveTargetFragment>(EMassFragmentAccess::ReadOnly);
	EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadWrite);
	EntityQuery.AddConstSharedRequirement<FMassTrackedVehicleOrientationParameters>(EMassFragmentPresence::All);
}

bool IsTransformFacingDirection(const FTransform& Transform, const FVector& TargetDirection, float* OutCurrentHeadingRadians, float* OutDesiredHeadingRadians, float* OutDeltaAngleRadians, float* OutAbsDeltaAngleRadians)
{
	const FVector CurrentForward = Transform.GetRotation().GetForwardVector();

	// These are in range of (-PI, PI].
	const float& CurrentHeadingRadians = UE::MassNavigation::GetYawFromDirection(CurrentForward);
	const float& DesiredHeadingRadians = UE::MassNavigation::GetYawFromDirection(TargetDirection);

	// In Range [-PI, PI].
	const float& DeltaAngleRadians = (FMath::FindDeltaAngleRadians(CurrentHeadingRadians, DesiredHeadingRadians));
	// In Range [0, PI].
	const float& AbsDeltaAngleRadians = FMath::Abs(DeltaAngleRadians);

	if (OutCurrentHeadingRadians)
	{
		*OutCurrentHeadingRadians = CurrentHeadingRadians;
	}
	if (OutDesiredHeadingRadians)
	{
		*OutDesiredHeadingRadians = DesiredHeadingRadians;
	}
	if (OutDeltaAngleRadians)
	{
		*OutDeltaAngleRadians = DeltaAngleRadians;
	}
	if (OutAbsDeltaAngleRadians)
	{
		*OutAbsDeltaAngleRadians = AbsDeltaAngleRadians;
	}

	return FMath::IsNearlyEqual(AbsDeltaAngleRadians, 0.f, 0.01f); // TODO: Is this a good tolerance?
}

struct FProcessEntityContext
{
	FProcessEntityContext(const FMassMoveTargetFragment& InMoveTarget, FTransform& InTransform, const FMassTrackedVehicleOrientationParameters& InOrientationParams, const float& InDeltaTime, const FMassEntityHandle& InEntity) : MoveTarget(InMoveTarget), Transform(InTransform), OrientationParams(InOrientationParams), DeltaTime(InDeltaTime), Entity(InEntity) {}

	const FMassMoveTargetFragment& MoveTarget;
	FTransform& Transform;
	const FMassTrackedVehicleOrientationParameters& OrientationParams;
	const float& DeltaTime;
	const FMassEntityHandle& Entity;

	void ProcessEntity()
	{
		// These are in range of (-PI, PI].
		float OutCurrentHeadingRadians;
		float OutDesiredHeadingRadians;

		// In Range [-PI, PI].
		float OutTotalDeltaAngleRadians;

		// In Range [0, PI].
		float OutAbsTotalDeltaAngleRadians;

		const bool& bIsAtDesiredHeading = IsTransformFacingDirection(Transform, MoveTarget.Forward, &OutCurrentHeadingRadians, &OutDesiredHeadingRadians, &OutTotalDeltaAngleRadians, &OutAbsTotalDeltaAngleRadians);
		if (bIsAtDesiredHeading)
		{
			return;
		}

		float NewHeadingRadians;
		float DeltaHeadingRadians = FMath::DegreesToRadians(OrientationParams.TurningSpeed) * DeltaTime;
		if (OutAbsTotalDeltaAngleRadians <= DeltaHeadingRadians)
		{
			NewHeadingRadians = OutDesiredHeadingRadians;
		}
		else
		{
			NewHeadingRadians = OutCurrentHeadingRadians + (OutTotalDeltaAngleRadians > 0.f ? DeltaHeadingRadians : -DeltaHeadingRadians);
		}

		FQuat Rotation(FVector::UpVector, NewHeadingRadians);
		Transform.SetRotation(Rotation);
	}
};

void UMassTrackedVehicleOrientationProcessor::Execute(UMassEntitySubsystem& EntitySubsystem,
	FMassExecutionContext& Context)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("UMassTrackedVehicleOrientationProcessor_Execute");

	// Clamp max delta time to avoid large values during initialization.
	const float DeltaTime = FMath::Min(0.1f, Context.GetDeltaTimeSeconds());

	EntityQuery.ForEachEntityChunk(EntitySubsystem, Context, [DeltaTime](FMassExecutionContext& Context)
	{
		const int32 NumEntities = Context.GetNumEntities();

		const FMassTrackedVehicleOrientationParameters& OrientationParams = Context.GetConstSharedFragment<FMassTrackedVehicleOrientationParameters>();
		const TConstArrayView<FMassMoveTargetFragment> MoveTargetList = Context.GetFragmentView<FMassMoveTargetFragment>();
		const TArrayView<FTransformFragment> LocationList = Context.GetMutableFragmentView<FTransformFragment>();

		for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
		{
			FProcessEntityContext(MoveTargetList[EntityIndex], LocationList[EntityIndex].GetMutableTransform(), OrientationParams, DeltaTime, Context.GetEntity(EntityIndex)).ProcessEntity();
		}
	});
}

```

`Source/ProjectM/Private/MassVisualEffectsSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MassVisualEffectsSubsystem.h"

int16 UMassVisualEffectsSubsystem::FindOrAddEntityConfig(UMassEntityConfigAsset* EntityConfigAsset)
{
	int32 Index = MassEntityConfigAssets.IndexOfByPredicate([EntityConfigAsset](UMassEntityConfigAsset* EntityConfigAssetInArray) { return EntityConfigAssetInArray == EntityConfigAsset; });
	if (Index == INDEX_NONE)
	{
		Index = MassEntityConfigAssets.Emplace(EntityConfigAsset);
	}
	check(Index < INT16_MAX);
	return (int16)Index;
}

void UMassVisualEffectsSubsystem::SpawnEntity(const int16 EntityConfigIndex, const FVector& Location)
{
	FTransform Transform;
	Transform.SetLocation(Location);
	SpawnEntity(EntityConfigIndex, Transform);
}

void UMassVisualEffectsSubsystem::SpawnEntity(const int16 EntityConfigIndex, const FTransform& Transform)
{
	UWorld* World = GetWorld();
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogTemp, Warning, TEXT("UMassVisualEffectsSubsystem: Invalid SpawnerSystem"));
		return;
	}

	if (EntityConfigIndex < 0 || EntityConfigIndex >= MassEntityConfigAssets.Num())
	{
		UE_LOG(LogTemp, Warning, TEXT("UMassVisualEffectsSubsystem: Invalid EntityConfigIndex"));
		return;
	}

	// TODO: A bit hacky to get first actor here.
	const FMassEntityTemplate* EntityTemplate = MassEntityConfigAssets[EntityConfigIndex]->GetConfig().GetOrCreateEntityTemplate(*World->GetLevel(0)->Actors[0], *SpawnerSystem); // TODO: passing SpawnerSystem is a hack

	if (!EntityTemplate->IsValid())
	{
		UE_LOG(LogTemp, Warning, TEXT("UMassVisualEffectsSubsystem: Invalid entity template"));
		return;
	}

	FMassEntitySpawnDataGeneratorResult Result;
	Result.SpawnDataProcessor = UMassSpawnLocationProcessor::StaticClass();
	Result.SpawnData.InitializeAs<FMassTransformsSpawnData>();
	Result.NumEntities = 1;
	FMassTransformsSpawnData& Transforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>();

	Transforms.Transforms.Reserve(1);
	FTransform& SpawnDataTransform = Transforms.Transforms.AddDefaulted_GetRef();
	SpawnDataTransform.SetLocation(Transform.GetLocation());
	SpawnDataTransform.SetRotation(Transform.GetRotation());
	SpawnDataTransform.SetScale3D(Transform.GetScale3D());

	TArray<FMassEntityHandle> SpawnedEntities;
	SpawnerSystem->SpawnEntities(EntityTemplate->GetTemplateID(), Result.NumEntities, Result.SpawnData, Result.SpawnDataProcessor, SpawnedEntities);
}

```

`Source/ProjectM/Private/MilitaryStructureSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MilitaryStructureSubsystem.h"

#include "Internationalization/Internationalization.h"
#include <Kismet/GameplayStatics.h>
#include "MilitaryUnitMassSpawner.h"

#define LOCTEXT_NAMESPACE "MyNamespace" // TODO

struct FMilitaryUnitLevel
{
	FMilitaryUnitLevel(uint8 SubUnitCount, FName Name, uint8 ArmorSubUnitCount = 0)
	{
		this->SubUnitCount = SubUnitCount;
		this->Name = Name;
		this->ArmorSubUnitCount = ArmorSubUnitCount;
	}
	uint8 SubUnitCount;
	FName Name;
	uint8 ArmorSubUnitCount;
};

static const FName GSquadLevelName = TEXT("Squad");

static const FMilitaryUnitLevel GMilitaryUnitLevels[] = {
	FMilitaryUnitLevel(3, TEXT("Corps")),
	FMilitaryUnitLevel(3, TEXT("Division")),
	FMilitaryUnitLevel(4, TEXT("Brigade")),
	FMilitaryUnitLevel(3, TEXT("Battalion"), 2),
	FMilitaryUnitLevel(3, TEXT("Company")),
	FMilitaryUnitLevel(3, TEXT("Platoon")),
	FMilitaryUnitLevel(2, GSquadLevelName),
	FMilitaryUnitLevel(3, TEXT("Fire team")),
	FMilitaryUnitLevel(0, TEXT("Soldier")),
};

static const FMilitaryUnitLevel GArmorUnitLevels[] = {
	FMilitaryUnitLevel(3, TEXT("Company")),
	FMilitaryUnitLevel(2, TEXT("Platoon")),
	FMilitaryUnitLevel(2, TEXT("Section")),
	FMilitaryUnitLevel(0, TEXT("Tank")),
};

static const uint8 GMilitaryUnitLevels_Count = sizeof(GMilitaryUnitLevels) / sizeof(GMilitaryUnitLevels[0]);

FMilitaryUnitCounts RecursivelyCreateArmorUnits(UMilitaryUnit* Unit, UMilitaryUnit* Parent, uint8 GlobalDepth = 0, uint8 ArmorDepth = 0, uint8 Index = 1);

FMilitaryUnitCounts RecursivelyCreateUnits(UMilitaryUnit* Unit, UMilitaryUnit* Parent, uint8 Depth = 0, uint8 Index = 1)
{
	Unit->Parent = Parent;
	Unit->Depth = Depth;
	Unit->Name = FText::Format(LOCTEXT("TODO", "{0} {1}"), FText::FromName(GMilitaryUnitLevels[Depth].Name), Index);
	
	uint8 SubUnitCount = GMilitaryUnitLevels[Depth].SubUnitCount;
	uint8 ArmorSubUnitCount = GMilitaryUnitLevels[Depth].ArmorSubUnitCount;

	FMilitaryUnitCounts Result;

	if (GMilitaryUnitLevels[Depth].Name.IsEqual(GSquadLevelName))
	{
		Result.SquadCount++;
	}

	if (SubUnitCount == 0)
	{
		Unit->bIsSoldier = true;
		Result.SoldierCount += 1;
		return Result;
	}

	UMilitaryUnit* Commander = NewObject<UMilitaryUnit>();
	Commander->bIsSoldier = true;
	Commander->bIsCommander = true;
	Commander->Depth = Depth + 1;
	Commander->Name = FText::Format(LOCTEXT("TODO", "{0} Commander"), Unit->Name);
	Commander->Parent = Unit;
	Unit->Commander = Commander;
	Unit->SubUnits.Add(Commander);
	Result.SoldierCount += 1;

	uint8 IndexOffset = 0;
	if (ArmorSubUnitCount > 0 && !AMilitaryUnitMassSpawner_SpawnSoldiersOnly)
	{
		IndexOffset++;
		UMilitaryUnit* RootArmorUnit = NewObject<UMilitaryUnit>();
		FMilitaryUnitCounts UnitCounts = RecursivelyCreateArmorUnits(RootArmorUnit, Unit, Depth + 1);
		Result.SoldierCount += UnitCounts.SoldierCount;
		Result.VehicleCount += UnitCounts.VehicleCount;
		Result.SquadCount += UnitCounts.SquadCount;
		Unit->SubUnits.Add(RootArmorUnit);
	}

	for (uint8 i = 0; i < SubUnitCount; i++)
	{
		UMilitaryUnit* SubUnit = NewObject<UMilitaryUnit>();
		FMilitaryUnitCounts UnitCounts = RecursivelyCreateUnits(SubUnit, Unit, Depth + 1, IndexOffset + i + 1);
		Result.SoldierCount += UnitCounts.SoldierCount;
		Result.VehicleCount += UnitCounts.VehicleCount;
		Result.SquadCount += UnitCounts.SquadCount;
		Unit->SubUnits.Add(SubUnit);
	}

	return Result;
}

FMilitaryUnitCounts RecursivelyCreateArmorUnits(UMilitaryUnit* Unit, UMilitaryUnit* Parent, uint8 GlobalDepth, uint8 ArmorDepth, uint8 Index)
{
	Unit->Parent = Parent;
	Unit->Depth = GlobalDepth;
	Unit->Name = FText::Format(LOCTEXT("TODO", "{0} {1}"), FText::FromName(GArmorUnitLevels[ArmorDepth].Name), Index);

	uint8 SubUnitCount = GArmorUnitLevels[ArmorDepth].SubUnitCount;

	FMilitaryUnitCounts Result;

	if (SubUnitCount == 0)
	{
		Unit->bIsVehicle = true;
		Result.VehicleCount += 1;
		return Result;
	}

	UMilitaryUnit* Commander = NewObject<UMilitaryUnit>();
	Commander->bIsSoldier = true;
	Commander->bIsCommander = true;
	Commander->Depth = GlobalDepth + 1;
	Commander->Name = FText::Format(LOCTEXT("TODO", "{0} Commander"), Unit->Name);
	Commander->Parent = Unit;
	Unit->Commander = Commander;
	Unit->SubUnits.Add(Commander);
	Result.SoldierCount += 1;

	for (uint8 i = 0; i < SubUnitCount; i++)
	{
		UMilitaryUnit* SubUnit = NewObject<UMilitaryUnit>();
		FMilitaryUnitCounts UnitCounts = RecursivelyCreateArmorUnits(SubUnit, Unit, GlobalDepth + 1, ArmorDepth + 1, i + 1);
		Result.SoldierCount += UnitCounts.SoldierCount;
		Result.VehicleCount += UnitCounts.VehicleCount;
		Unit->SubUnits.Add(SubUnit);
	}

	return Result;
}

//----------------------------------------------------------------------//
//  UMilitaryStructureSubsystem
//----------------------------------------------------------------------//
FMilitaryUnitCounts UMilitaryStructureSubsystem::CreateMilitaryUnit(uint8 MilitaryUnitIndex, bool bIsTeam1)
{
	UMilitaryUnit* RootUnit = NewObject<UMilitaryUnit>();
	FMilitaryUnitCounts Counts = RecursivelyCreateUnits(RootUnit, nullptr, MilitaryUnitIndex);
	if (bIsTeam1)
	{
		Team1RootUnit = RootUnit;
	}
	else
	{
		Team2RootUnit = RootUnit;
	}
	return Counts;
}

void PrintMilitaryStructure(UMilitaryUnit* Unit, FString Prefix = FString(""))
{
	UE_LOG(LogTemp, Warning, TEXT("%sName: %s"), *Prefix, *Unit->Name.ToString());

	for (UMilitaryUnit* SubUnit : Unit->SubUnits)
	{
		PrintMilitaryStructure(SubUnit, Prefix + FString("  "));
	}
}

void UMilitaryStructureSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
}

void UMilitaryStructureSubsystem::BindUnitToMassEntity(UMilitaryUnit* MilitaryUnit, FMassEntityHandle Entity)
{
	if (EntityToUnitMap.Contains(Entity))
	{
		EntityToUnitMap.Remove(Entity);
	}
	MilitaryUnit->MassEntityIndex = Entity.Index;
	MilitaryUnit->MassEntitySerialNumber = Entity.SerialNumber;
	EntityToUnitMap.Add(Entity, MilitaryUnit);
}

void UMilitaryStructureSubsystem::DestroyEntity(FMassEntityHandle Entity)
{
	UMilitaryUnit** MilitaryUnitPtr = EntityToUnitMap.Find(Entity);
	if (!MilitaryUnitPtr)
	{
		return;
	}

	UMilitaryUnit* MilitaryUnit = *MilitaryUnitPtr;
	if (MilitaryUnit->SquadMilitaryUnit)
	{
		PromoteNewLeaderIfNeeded(MilitaryUnit);
	}
	MilitaryUnit->RemoveFromParent();
	EntityToUnitMap.Remove(Entity);
}

UMilitaryUnit* FindBestReplacementForLeader(UMilitaryUnit* Leader, UMilitaryUnit* LeaderParentUnit)
{
	TQueue<UMilitaryUnit*> UnitsToConsider;
	UnitsToConsider.Enqueue(LeaderParentUnit);
	// BFS to find first soldier.
	while (!UnitsToConsider.IsEmpty())
	{
		UMilitaryUnit* Unit;
		const bool bDidDequeue = UnitsToConsider.Dequeue(Unit);
		check(bDidDequeue);

		if (Unit->bIsSoldier && Unit != Leader)
		{
			return Unit;
		}

		for (UMilitaryUnit* SubUnit : Unit->SubUnits)
		{
			UnitsToConsider.Enqueue(SubUnit);
		}

	}

	return nullptr;
}

void UMilitaryStructureSubsystem::PromoteNewLeaderIfNeeded(UMilitaryUnit* SoldierToRemoveFromUnit)
{
	if (!SoldierToRemoveFromUnit->bIsCommander)
	{
		return;
	}

	UMilitaryUnit* SoldierToRemoveParentUnit = SoldierToRemoveFromUnit->Parent;
	UMilitaryUnit* NewLeader = FindBestReplacementForLeader(SoldierToRemoveFromUnit, SoldierToRemoveParentUnit);
	if (!NewLeader)
	{
		return;
	}

	if (NewLeader->bIsCommander)
	{
		PromoteNewLeaderIfNeeded(NewLeader);
	}

	NewLeader->RemoveFromParent();
	NewLeader->Parent = SoldierToRemoveParentUnit;
	NewLeader->bIsCommander = true;
	NewLeader->SquadMemberIndex = SoldierToRemoveFromUnit->SquadMemberIndex;
	NewLeader->Depth = SoldierToRemoveFromUnit->Depth;
	NewLeader->Name = SoldierToRemoveFromUnit->Name;
	SoldierToRemoveParentUnit->SubUnits.Add(NewLeader);
	SoldierToRemoveParentUnit->Commander = NewLeader;
}

UMilitaryUnit* UMilitaryStructureSubsystem::GetRootUnitForTeam(const bool bIsTeam1)
{
	return bIsTeam1 ? Team1RootUnit : Team2RootUnit;
}

UMilitaryUnit* UMilitaryStructureSubsystem::GetUnitForEntity(const FMassEntityHandle Entity)
{
	UMilitaryUnit** MilitaryUnit = EntityToUnitMap.Find(Entity);
	if (!MilitaryUnit)
	{
		return nullptr;
	}

	return *MilitaryUnit;
}

void UMilitaryStructureSubsystem::DidCompleteAssigningEntitiesToMilitaryUnits(const bool bIsTeam1)
{
	TArray<AActor*> MilitaryUnitMassSpawners;
	UGameplayStatics::GetAllActorsOfClass(this, AMilitaryUnitMassSpawner::StaticClass(), MilitaryUnitMassSpawners);


	(bIsTeam1 ? bDidCompleteAssigningEntitiesToMilitaryUnitsForTeam1 : bDidCompleteAssigningEntitiesToMilitaryUnitsForTeam2) = true;

	if (MilitaryUnitMassSpawners.Num() == 1)
	{
		OnCompletedAssigningEntitiesToMilitaryUnitsEvent.Broadcast();
	}
	else if (bDidCompleteAssigningEntitiesToMilitaryUnitsForTeam1 && bDidCompleteAssigningEntitiesToMilitaryUnitsForTeam2)
	{
		OnCompletedAssigningEntitiesToMilitaryUnitsEvent.Broadcast();
	}
}

//----------------------------------------------------------------------//
//  UMilitaryUnit
//----------------------------------------------------------------------//
void UMilitaryUnit::RemoveFromParent()
{
	if (Parent->Commander == this)
	{
		Parent->Commander = nullptr;
	}
	Parent->SubUnits.Remove(this);
}

FMassEntityHandle UMilitaryUnit::GetMassEntityHandle() const
{
	return FMassEntityHandle(MassEntityIndex, MassEntitySerialNumber);
}

bool UMilitaryUnit::IsChildOfUnit(const UMilitaryUnit* ParentUnit)
{
	if (!ParentUnit) {
		return false;
	}

	UMilitaryUnit* ChildUnit = this;
	if (ParentUnit->bIsSoldier)
	{
		return ChildUnit == ParentUnit;
	}

	// If we got here, ParentUnit is set to a non-soldier.

	while (ChildUnit)
	{
		if (ChildUnit == ParentUnit) {
			return true;
		}
		ChildUnit = ChildUnit->Parent;
	}

	return false;
}

bool UMilitaryUnit::IsLeafUnit() const
{
	return bIsSoldier || bIsVehicle;
}

// TODO: Move the data needed to compute this into Mass fragment so we don't need inefficient RAM hits.
bool UMilitaryUnit::IsSquadLeader() const
{
	return bIsCommander && Depth == GSquadUnitDepth + 1;
}


```

`Source/ProjectM/Private/MilitaryUnitMassSpawner.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MilitaryUnitMassSpawner.h"

#include "MassSpawner.h"
#include "MilitaryStructureSubsystem.h"
#include "MassEntityTraitBase.h"
#include "MassEntityConfigAsset.h"
#include "MassEnemyTargetFinderProcessor.h"
#include <Engine/AssetManager.h>
#include <MassSimulationSubsystem.h>
#include "VisualLogger/VisualLogger.h"
#include "Engine/StreamableManager.h"
#include "MassSpawnLocationProcessor.h"
#include "MassOrderedSpawnLocationProcessor.h"

AMilitaryUnitMassSpawner::AMilitaryUnitMassSpawner()
{
	bAutoSpawnOnBeginPlay = false;
}

void AMilitaryUnitMassSpawner::BeginPlay()
{
	Super::BeginPlay();

	// We need this check because it seems that this binding may have been serialized to disk on older versions of this actor in certain levels.
	if (!OnSpawningFinishedEvent.IsAlreadyBound(this, &AMilitaryUnitMassSpawner::BeginAssignEntitiesToMilitaryUnits))
	{
		OnSpawningFinishedEvent.AddDynamic(this, &AMilitaryUnitMassSpawner::BeginAssignEntitiesToMilitaryUnits);
	}

	const UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());
	if (MassSimulationSubsystem == nullptr || MassSimulationSubsystem->IsSimulationStarted())
	{
		DoMilitaryUnitSpawning();
	}
	else
	{

		SimulationStartedHandle = UMassSimulationSubsystem::GetOnSimulationStarted().AddLambda([this](UWorld* InWorld)
		{
			UWorld* World = GetWorld();

			if (World == InWorld)
			{
				DoMilitaryUnitSpawning();
			}
		});
	}
}

bool AMilitaryUnitMassSpawner_SpawnVehiclesOnly = false;
FAutoConsoleVariableRef CVar_AMilitaryUnitMassSpawner_SpawnVehiclesOnly(TEXT("pm.AMilitaryUnitMassSpawner_SpawnVehiclesOnly"), AMilitaryUnitMassSpawner_SpawnVehiclesOnly, TEXT("AMilitaryUnitMassSpawner_SpawnVehiclesOnly"));

bool AMilitaryUnitMassSpawner_SpawnTeam1SoldiersOnly = false;
FAutoConsoleVariableRef CVar_AMilitaryUnitMassSpawner_SpawnTeam1SoldiersOnly(TEXT("pm.AMilitaryUnitMassSpawner_SpawnTeam1SoldiersOnly"), AMilitaryUnitMassSpawner_SpawnTeam1SoldiersOnly, TEXT("AMilitaryUnitMassSpawner_SpawnTeam1SoldiersOnly"));

void AMilitaryUnitMassSpawner::DoMilitaryUnitSpawning()
{
	// TODO: Get team from EntityTypes (UMassEntityConfigAsset) once figure out linker issue with using FMassSpawnedEntityType::GetEntityConfig(). Then replace bIsTeam1 below.
	// https://forums.unrealengine.com/t/how-to-resolve-unresolved-external-symbol-fmassspawnedentitytype-getentityconfig-error/636923
	// Error	LNK2019	unresolved external symbol "public: class UMassEntityConfigAsset * __cdecl FMassSpawnedEntityType::GetEntityConfig(void)" (? GetEntityConfig@FMassSpawnedEntityType@@QEAAPEAVUMassEntityConfigAsset@@XZ) referenced in function "protected: virtual void __cdecl AMilitaryUnitMassSpawner::BeginPlay(void)" (? BeginPlay@AMilitaryUnitMassSpawner@@MEAAXXZ)

	//bool bFoundTeamMemberTrait = false;
	//const UMassEntityConfigAsset* EntityConfig = EntityTypes[0].GetEntityConfig();
	//TConstArrayView<UMassEntityTraitBase*> Traits = EntityConfig->GetConfig().GetTraits();
	//for (UMassEntityTraitBase* Trait : Traits)
	//{
	//	if (UMassTeamMemberTrait* TeamMemberTrait = Cast<UMassTeamMemberTrait>(Trait))
	//	{
	//		bIsTeam1 = TeamMemberTrait->IsOnTeam1;
	//		bFoundTeamMemberTrait = true;
	//		break;
	//	}
	//}

	//if (!bFoundTeamMemberTrait)
	//{
	//	UE_LOG(LogTemp, Warning, TEXT("Could not find UMassTeamMemberTrait, defaulting to team 1"));
	//}

	MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(GetWorld());
	check(MilitaryStructureSubsystem);

	UnitCounts = MilitaryStructureSubsystem->CreateMilitaryUnit(MilitaryUnitIndex, bIsTeam1);

	// No spawn point generators configured. Let user know and fall back to the spawner's location.
	if (SpawnDataGenerators.Num() == 0)
	{
		UE_VLOG_UELOG(this, LogTemp, Error, TEXT("No Spawn Data Generators configured."));
		return;
	}

	AllGeneratedResults.Reset();

	for (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)
	{
		if (Generator.GeneratorInstance)
		{
			Generator.bDataGenerated = false;
		}
	}

	// Check if it needs loading
	if (StreamingHandle.IsValid() && StreamingHandle->IsActive())
	{
		// @todo, instead of blindly canceling, we should remember what was asked to load with that handle and compare if more is needed?
		StreamingHandle->CancelHandle();
	}
	TArray<FSoftObjectPath> AssetsToLoad;
	for (const FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (!EntityType.IsLoaded())
		{
			AssetsToLoad.Add(EntityType.EntityConfig.ToSoftObjectPath());
		}
	}

	bDidSpawnSoldiersOnly = AMilitaryUnitMassSpawner_SpawnSoldiersOnly || (bIsTeam1 && AMilitaryUnitMassSpawner_SpawnTeam1SoldiersOnly);
	bDidSpawnVehiclesOnly = bSpawnVehiclesOnly || AMilitaryUnitMassSpawner_SpawnVehiclesOnly;

	auto GenerateSpawningPoints = [this, &UnitCounts = UnitCounts]()
	{
		if (SpawnDataGenerators.Num() != 2 || EntityTypes.Num() != 2)
		{
			UE_VLOG_UELOG(this, LogTemp, Error, TEXT("AMilitaryUnitMassSpawner needs exactly two EntityTypes and SpawnDataGenerators, first for soldiers, second for vehicles."));
			return;
		}

		uint8 Index = 0;
		for (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)
		{
			if (Generator.GeneratorInstance)
			{
				const int32 UpperCommandSoldierCount = UnitCounts.SoldierCount - UnitCounts.SquadCount * GNumSoldiersInSquad;
				const int32 SpawnCount = Index == 0 ? (bDidSpawnVehiclesOnly ? 0 : UnitCounts.SquadCount + UpperCommandSoldierCount) : (bDidSpawnSoldiersOnly ? 0 : UnitCounts.VehicleCount);
				const int32 OtherIndex = Index == 0 ? 1 : 0;
				EntityTypes[Index].Proportion = 1.f;
				EntityTypes[OtherIndex].Proportion = 0.f;

				FFinishedGeneratingSpawnDataSignature Delegate = FFinishedGeneratingSpawnDataSignature::CreateUObject(this, &AMilitaryUnitMassSpawner::OnMilitaryUnitSpawnDataGenerationFinished, &Generator);
				Generator.GeneratorInstance->Generate(*this, EntityTypes, SpawnCount, Delegate);
			}
			Index++;
		}
	};

	if (AssetsToLoad.Num())
	{
		FStreamableManager& StreamableManager = UAssetManager::GetStreamableManager();
		StreamingHandle = StreamableManager.RequestAsyncLoad(AssetsToLoad, GenerateSpawningPoints);
	}
	else
	{
		GenerateSpawningPoints();
	}
}

TArray<FVector> GetRelativePointsForSquad(const FVector& SquadOrigin)
{
	TArray<FVector> Result;

	for (int i = 0; i < GNumSoldiersInSquad; i++)
	{
		const FVector2D Offset(GSquadMemberOffsetsMeters[i] * 100.f * GSquadSpacingScalingFactor);
		Result.Add(SquadOrigin + FVector(Offset, 0.f));
	}

	return Result;
}

void AMilitaryUnitMassSpawner::OnMilitaryUnitSpawnDataGenerationFinished(TConstArrayView<FMassEntitySpawnDataGeneratorResult> ConstResults, FMassSpawnDataGenerator* FinishedGenerator)
{
	const FMassEntitySpawnDataGeneratorResult* Data = ConstResults.GetData();
	int32 ResultsCount = ConstResults.Num();

	TArray<FMassEntitySpawnDataGeneratorResult> ResultArray;

	for (int i = 0; i < ResultsCount; i++)
	{
		const FMassEntitySpawnDataGeneratorResult& Result = Data[i];
		FMassEntitySpawnDataGeneratorResult SquadResult;
		if (!Result.SpawnData.IsValid())
		{
			UE_VLOG_UELOG(this, LogTemp, Error, TEXT("AMilitaryUnitMassSpawner: Invalid spawn data."));
			return;
		}
		const TArray<FTransform>& ResultTransforms = Result.SpawnData.GetMutable<FMassTransformsSpawnData>().Transforms;
		SquadResult.NumEntities = UnitCounts.SoldierCount;
		SquadResult.EntityConfigIndex = Result.EntityConfigIndex;

		SquadResult.SpawnDataProcessor = UMassOrderedSpawnLocationProcessor::StaticClass();
		SquadResult.SpawnData.InitializeAs<FMassTransformsSpawnData>();
		FMassTransformsSpawnData& Transforms = SquadResult.SpawnData.GetMutable<FMassTransformsSpawnData>();

		Transforms.Transforms.Reserve(SquadResult.NumEntities);
		for (int SquadIndex = 0; SquadIndex < UnitCounts.SquadCount; SquadIndex++)
		{
			const TArray<FVector>& SquadMemberSpawnLocations = GetRelativePointsForSquad(ResultTransforms[SquadIndex].GetLocation());
			for (const FVector& SquadMemberSpawnLocation : SquadMemberSpawnLocations)
			{
				FTransform& Transform = Transforms.Transforms.AddDefaulted_GetRef();
				Transform.SetLocation(SquadMemberSpawnLocation);
			}
		}
		int32 NumHigherCommandSoldiers = UnitCounts.SoldierCount - GNumSoldiersInSquad * UnitCounts.SquadCount;
		for (int CommandIndex = 0; CommandIndex < NumHigherCommandSoldiers; CommandIndex++)
		{
			FTransform& Transform = Transforms.Transforms.AddDefaulted_GetRef();
			Transform = ResultTransforms[CommandIndex + UnitCounts.SquadCount];
		}

		ResultArray.Add(SquadResult);
	}
	TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results(ResultArray);

	// Rest is copied from AMassSpawner::OnSpawnDataGenerationFinished.

	// @todo: this can be potentially expensive copy for the instanced structs, could there be a way to use move gere instead?
	AllGeneratedResults.Append(Results.GetData(), Results.Num());

	bool bAllSpawnPointsGenerated = true;
	bool bFoundFinishedGenerator = false;
	for (FMassSpawnDataGenerator& Generator : SpawnDataGenerators)
	{
		if (&Generator == FinishedGenerator)
		{
			Generator.bDataGenerated = true;
			bFoundFinishedGenerator = true;
		}

		bAllSpawnPointsGenerated &= Generator.bDataGenerated;
	}

	checkf(bFoundFinishedGenerator, TEXT("Something went wrong, we are receiving a callback on an unknow spawn point generator"));

	if (bAllSpawnPointsGenerated)
	{
		SpawnGeneratedEntities(AllGeneratedResults);
		AllGeneratedResults.Reset();
	}
}

void GatherSquadsAndHigherCommand(UMilitaryUnit* MilitaryUnit, TArray<UMilitaryUnit*>& OutSquads, TArray<UMilitaryUnit*>& OutHigherCommandSoldiers)
{
	if (MilitaryUnit->bIsVehicle)
	{
		UE_LOG(LogTemp, Error, TEXT("GatherSquadsAndHigherCommand does not support vehicles yet."));
		return;
	}

	if (MilitaryUnit->bIsSoldier)
	{
		if (MilitaryUnit->Depth <= GSquadUnitDepth)
		{
			OutHigherCommandSoldiers.Add(MilitaryUnit);
		}
		return;
	}

	// Not a soldier.
	if (MilitaryUnit->Depth == GSquadUnitDepth)
	{
		OutSquads.Add(MilitaryUnit);
	}
	else
	{
		for (UMilitaryUnit* SubUnit : MilitaryUnit->SubUnits)
		{
			GatherSquadsAndHigherCommand(SubUnit, OutSquads, OutHigherCommandSoldiers);
		}
	}
}

void AMilitaryUnitMassSpawner::BeginAssignEntitiesToMilitaryUnits()
{
	// TODO: This is a bit hacky, refactor.
	if (const UMassEntityConfigAsset* SoldierEntityConfig = EntityTypes[0].EntityConfig.LoadSynchronous())
	{
		const FMassEntityTemplate* SoldierEntityTemplate = SoldierEntityConfig->GetConfig().GetOrCreateEntityTemplate(*this, *SoldierEntityConfig);
		check(SoldierEntityTemplate);
		if (AllSpawnedEntities[0].TemplateID == SoldierEntityTemplate->GetTemplateID())
		{
			AllSpawnedEntitiesSoldierIndex = 0;
			AllSpawnedEntitiesVehicleIndex = 1;
		}
		else
		{
			AllSpawnedEntitiesSoldierIndex = 1;
			AllSpawnedEntitiesVehicleIndex = 0;
		}
	}

	int32 VehicleIndex = 0;

	TArray<UMilitaryUnit*> Squads;
	TArray<UMilitaryUnit*> HigherCommandSoldiers;
	GatherSquadsAndHigherCommand(MilitaryStructureSubsystem->GetRootUnitForTeam(bIsTeam1), Squads, HigherCommandSoldiers);
	AssignEntitiesToMilitaryUnits(Squads, HigherCommandSoldiers);

	MilitaryStructureSubsystem->DidCompleteAssigningEntitiesToMilitaryUnits(bIsTeam1);
}

void AMilitaryUnitMassSpawner::SafeBindSoldier(UMilitaryUnit* SoldierMilitaryUnit, const TArray<FMassEntityHandle>& SpawnedEntities, int32& EntityIndex)
{
	if (EntityIndex < SpawnedEntities.Num())
	{
		MilitaryStructureSubsystem->BindUnitToMassEntity(SoldierMilitaryUnit, SpawnedEntities[EntityIndex++]);
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT("AMilitaryUnitMassSpawner::SafeBindSoldier: Invalid index."));
	}
}

void AMilitaryUnitMassSpawner::AssignEntitiesToMilitaryUnits(TArray<UMilitaryUnit*>& Squads, TArray<UMilitaryUnit*>& HigherCommandSoldiers)
{
	int32 SoldierIndex = 0;
	for (int32 SquadIndex = 0; SquadIndex < Squads.Num(); SquadIndex++)
	{
		UMilitaryUnit* Squad = Squads[SquadIndex];
		Squad->SquadIndex = SquadIndex;
		int32 SquadMemberIndex = 0;
		AssignEntitiesToSquad(SoldierIndex, Squad, Squad, SquadMemberIndex);
	}

	for (UMilitaryUnit* Soldier : HigherCommandSoldiers)
	{
		SafeBindSoldier(Soldier, AllSpawnedEntities[AllSpawnedEntitiesSoldierIndex].Entities, SoldierIndex);
	}
}

void AMilitaryUnitMassSpawner::AssignEntitiesToSquad(int32& SoldierIndex, UMilitaryUnit* MilitaryUnit, UMilitaryUnit* SquadMilitaryUnit, int32& SquadMemberIndex)
{
	if (MilitaryUnit->bIsSoldier)
	{
		SafeBindSoldier(MilitaryUnit, AllSpawnedEntities[AllSpawnedEntitiesSoldierIndex].Entities, SoldierIndex);
		MilitaryUnit->SquadMemberIndex = SquadMemberIndex++;
		MilitaryUnit->SquadMilitaryUnit = SquadMilitaryUnit;
		MilitaryUnit->SquadIndex = SquadMilitaryUnit->SquadIndex;
	}
	else
	{
		for (UMilitaryUnit* SubUnit : MilitaryUnit->SubUnits)
		{
 			AssignEntitiesToSquad(SoldierIndex, SubUnit, SquadMilitaryUnit, SquadMemberIndex);
		}
	}
}

```

`Source/ProjectM/Private/ProjectM.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "ProjectM.h"

#define LOCTEXT_NAMESPACE "FProjectMModule"

#if WITH_GAMEPLAY_DEBUGGER
#include "GameplayDebugger.h"
#include "GameplayDebuggerCategory_ProjectM.h"
#endif // WITH_GAMEPLAY_DEBUGGER

void FProjectMModule::StartupModule()
{
#if WITH_GAMEPLAY_DEBUGGER
  IGameplayDebugger& GameplayDebuggerModule = IGameplayDebugger::Get();
  GameplayDebuggerModule.RegisterCategory("ProjectM", IGameplayDebugger::FOnGetCategory::CreateStatic(&FGameplayDebuggerCategory_ProjectM::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate, 1);
  GameplayDebuggerModule.NotifyCategoriesChanged();
#endif
}

void FProjectMModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FProjectMModule, ProjectM)

```

`Source/ProjectM/Private/ProjectMMapWidget.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ProjectMMapWidget.h"

#include "Components/Border.h"
#include "Components/CanvasPanel.h"
#include "Components/CanvasPanelSlot.h"
#include "Components/Button.h"
#include "Components/Image.h"
#include "Components/TextBlock.h"
#include "Components/TreeView.h"
#include "Components/SceneCaptureComponent2D.h"
#include "MassEntitySubsystem.h"
#include "MassEntityQuery.h"
#include "ProjectMWorldInfo.h"
#include "Kismet/GameplayStatics.h"
#include "Engine/TextureRenderTarget2D.h"
#include "MassCommonFragments.h"
#include "MassEnemyTargetFinderProcessor.h"

#include <Character/CommanderCharacter.h>
#include <MassProjectileDamageProcessor.h>

#define LOCTEXT_NAMESPACE "MyNamespace" // TODO

static const float GSoldierButtonSize = 10.f;
static const float GTankButtonSize = 20.f;

// TODO: don't hard-code
static const FLinearColor GSelectedUnitColor = FLinearColor(0.f, 1.f, 0.f);
static const FLinearColor GPlayerSoldierColor = FLinearColor(1.f, 1.f, 0.f);
static const FLinearColor GTeamColors[] = {
  FLinearColor(0.f, 0.f, 1.f),
  FLinearColor(1.f, 0.f, 0.f),
};

//----------------------------------------------------------------------//
//  UProjectMMapWidget
//----------------------------------------------------------------------//
void UProjectMMapWidget::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)
{
  Super::NativeTick(MyGeometry, InDeltaTime);

  if (!CanvasPanel)
  {
    return;
  }

  if (!bCreatedButtons)
  {
    CreateMapButtons();
  }
  else
  {
    UpdateMapButtons();
  }

  UpdateSoldierCountLabels();
}

void UProjectMMapWidget::UpdateSoldierCountLabels()
{
  if (TextBlock_Team1Count)
  {
    TextBlock_Team1Count->SetText(FText::Format(LOCTEXT("TODO", "Team 1: {0}"), CachedTeam1AliveSoldierCount));
  }
  if (TextBlock_Team2Count)
  {
    TextBlock_Team2Count->SetText(FText::Format(LOCTEXT("TODO", "Team 2: {0}"), CachedTeam2AliveSoldierCount));
  }
}

void UProjectMMapWidget::CreateMapButtons()
{
  ForEachMapDisplayableEntity([this](const FVector& EntityLocation, const bool& bIsOnTeam1, const bool& bIsPlayer, const FMassEntityHandle& Entity)
  {
    UMilitaryUnit* Unit = MilitaryStructureSubsystem->GetUnitForEntity(Entity);

    if (!Unit)
    {
      UE_LOG(LogTemp, Warning, TEXT("UProjectMMapWidget: Could not find UMilitaryUnit for entity, not creating button"));
      return;
    }

    FLinearColor Color = GTeamColors[bIsOnTeam1];
    (bIsOnTeam1 ? CachedTeam1AliveSoldierCount : CachedTeam2AliveSoldierCount)++;
    UButton* Button = CreateButton(Unit->bIsSoldier);
    UpdateButton(Button, WorldPositionToMapPosition(EntityLocation), Unit, bIsOnTeam1, bIsPlayer);
    ButtonToMilitaryUnitMap.Add(Button, Unit);
    MilitaryUnitToButtonMap.Add(Unit, Button);
  });

  bCreatedButtons = true;
}

void UProjectMMapWidget::ForEachMapDisplayableEntity(const FMapDisplayableEntityFunction& EntityExecuteFunction)
{
  UMassEntitySubsystem* EntitySubsystem = UWorld::GetSubsystem<UMassEntitySubsystem>(GetWorld());
  FMassEntityQuery EntityQuery;
  EntityQuery.AddRequirement<FTransformFragment>(EMassFragmentAccess::ReadOnly);
  EntityQuery.AddRequirement<FTeamMemberFragment>(EMassFragmentAccess::ReadOnly);
  EntityQuery.AddTagRequirement<FMassSoldierIsDyingTag>(EMassFragmentPresence::None);
  FMassExecutionContext Context(0.0f);

  EntityQuery.ForEachEntityChunk(*EntitySubsystem, Context, [&EntityExecuteFunction](FMassExecutionContext& Context)
  {
    const int32 NumEntities = Context.GetNumEntities();

    const TConstArrayView<FTransformFragment> TransformList = Context.GetFragmentView<FTransformFragment>();
    const TConstArrayView<FTeamMemberFragment> TeamMemberList = Context.GetFragmentView<FTeamMemberFragment>();

    for (int32 EntityIndex = 0; EntityIndex < NumEntities; ++EntityIndex)
    {
      const bool& bIsPlayer = Context.DoesArchetypeHaveTag<FMassPlayerControllableCharacterTag>();
      EntityExecuteFunction(TransformList[EntityIndex].GetTransform().GetLocation(), TeamMemberList[EntityIndex].IsOnTeam1, bIsPlayer, Context.GetEntity(EntityIndex));
    }
  });
}

UButton* UProjectMMapWidget::CreateButton(const bool& bIsSolder)
{
  UButton* Button = NewObject<UButton>();

  if (bIsSolder)
  {
    Button->WidgetStyle.Normal.OutlineSettings.RoundingType = ESlateBrushRoundingType::HalfHeightRadius;
    Button->WidgetStyle.Normal.OutlineSettings.RoundingType = ESlateBrushRoundingType::HalfHeightRadius;
  }

  UCanvasPanelSlot* CanvasPanelSlot = CanvasPanel->AddChildToCanvas(Button);
  CanvasPanelSlot->SetAnchors(FAnchors(0.5f));
  CanvasPanelSlot->SetAlignment(FVector2D(0.5f, 0.5f));
  const float& ButtonSize = bIsSolder ? GSoldierButtonSize : GTankButtonSize;
  CanvasPanelSlot->SetSize(FVector2D(ButtonSize, ButtonSize));

  SButton* ButtonWidget = (SButton*)&(Button->TakeWidget().Get());
  ButtonWidget->SetOnClicked(FOnClicked::CreateLambda([this, Button]()
  {
    if (ButtonToMilitaryUnitMap.Contains(Button))
    {
      BP_OnSoldierButtonClicked(ButtonToMilitaryUnitMap[Button]);
    }
    return FReply::Handled();
  }));

  return Button;
}

void UProjectMMapWidget::UpdateButton(UButton* Button, const FVector2D& Position, UMilitaryUnit* Unit, const bool& bIsOnTeam1, const bool& bIsPlayer)
{
  Button->WidgetStyle.Normal.TintColor = bIsPlayer ? GPlayerSoldierColor : (Unit->IsChildOfUnit(SelectedUnit) ? GSelectedUnitColor : GTeamColors[bIsOnTeam1]);

  UCanvasPanelSlot* CanvasPanelSlot = CastChecked<UCanvasPanelSlot>(Button->Slot.Get());
  CanvasPanelSlot->SetPosition(Position);
}

void UProjectMMapWidget::UpdateMapButtons()
{
  CachedTeam1AliveSoldierCount = CachedTeam2AliveSoldierCount = 0;

  TSet<UButton*> UpdatedButtons;
  ForEachMapDisplayableEntity([this, &UpdatedButtons](const FVector& EntityLocation, const bool& bIsOnTeam1, const bool& bIsPlayer, const FMassEntityHandle& Entity)
  {
    (bIsOnTeam1 ? CachedTeam1AliveSoldierCount : CachedTeam2AliveSoldierCount)++;
    UMilitaryUnit* Unit = MilitaryStructureSubsystem->GetUnitForEntity(Entity);

    if (!Unit)
    {
      UE_LOG(LogTemp, Warning, TEXT("UProjectMMapWidget: Could not find UMilitaryUnit for entity, not updating button"));
      return;
    }
    UButton* Button = MilitaryUnitToButtonMap[Unit];
    UpdateButton(Button, WorldPositionToMapPosition(EntityLocation), Unit, bIsOnTeam1, bIsPlayer);
    UpdatedButtons.Add(Button);
    UCanvasPanelSlot* ButtonSlot = CastChecked<UCanvasPanelSlot>(Button->Slot.Get());
    const FVector2D& MapPosition = WorldPositionToMapPosition(EntityLocation);
    ButtonSlot->SetPosition(MapPosition);
  });

  // Hide buttons for destroyed units.
  for (int32 CanvasPanelChildIndex = 0; CanvasPanelChildIndex < CanvasPanel->GetChildrenCount(); CanvasPanelChildIndex++)
  {
    UButton* Button = Cast<UButton>(CanvasPanel->GetChildAt(CanvasPanelChildIndex));
    if (Button && !UpdatedButtons.Contains(Button))
    {
      Button->SetVisibility(ESlateVisibility::Collapsed);
    }
  }
}

FVector2D UProjectMMapWidget::WorldPositionToMapPosition(const FVector& WorldLocation)
{
  FVector2D MapPosition;
  FSceneView::ProjectWorldToScreen(WorldLocation, MapRect, MapViewProjectionMatrix, MapPosition);
  return MapPosition;
}

FVector UProjectMMapWidget::MapPositionToWorldPosition(const FVector2D& MapPosition) const
{
  FVector WorldPosition, WorldDirection;
  FSceneView::DeprojectScreenToWorld(MapPosition, MapRect, MapViewProjectionMatrix.Inverse(), WorldPosition, WorldDirection);
  return WorldPosition;
}

void UProjectMMapWidget::NativeOnInitialized()
{
  Super::NativeOnInitialized();

  MilitaryStructureSubsystem = UWorld::GetSubsystem<UMilitaryStructureSubsystem>(GetWorld());
  check(MilitaryStructureSubsystem);

  const AProjectMWorldInfo* const WorldInfo = Cast<AProjectMWorldInfo>(UGameplayStatics::GetActorOfClass(GetWorld(), AProjectMWorldInfo::StaticClass()));
  USceneCaptureComponent2D* const SceneCapture = WorldInfo ? WorldInfo->GetWorldMapSceneCapture() : nullptr;

  if (!SceneCapture)
  {
    return;
  }

  InitializeMapViewProjectionMatrix(SceneCapture);

  if (UTextureRenderTarget2D* const Texture = SceneCapture->TextureTarget)
  {
    const FIntPoint MapBaseSize = { Texture->SizeX / 2, Texture->SizeY / 2 };
    MapRect = { -MapBaseSize.X, -MapBaseSize.Y, MapBaseSize.X, MapBaseSize.Y };

    if (Border)
    {
      UCanvasPanelSlot* BorderSlot = CastChecked<UCanvasPanelSlot>(Border->Slot.Get());
      BorderSlot->SetSize(MapRect.Size());
    }

	if (MapImage)
	{
		// Set the brush size to match the render target dimensions
		MapImage->Brush.SetImageSize(MapRect.Size());

		if (UMaterialInstanceDynamic* MapMaterial = MapImage->GetDynamicMaterial())
		{
			// Set the texture on the map image to the scene capture render target
			MapMaterial->SetTextureParameterValue(MapTextureParameterName, Texture);
		}
	}
  }
}

void UProjectMMapWidget::OnHide()
{
  for (auto& KeyValuePair : ButtonToMilitaryUnitMap)
  {
    UButton* Button = KeyValuePair.Key;
    Button->RemoveFromParent();
  }

  ButtonToMilitaryUnitMap.Reset();
  MilitaryUnitToButtonMap.Reset();
  bCreatedButtons = false;
}

void UProjectMMapWidget::InitializeMapViewProjectionMatrix(USceneCaptureComponent2D* const SceneCapture2D)
{
  check(SceneCapture2D);

  // Cache the MapViewProjection matrix for world to render target (map) space projections
  FMinimalViewInfo InMapViewInfo;
  SceneCapture2D->GetCameraView(0.0f, InMapViewInfo);

  // Get custom projection matrix, if it exists
  TOptional<FMatrix> InCustomProjectionMatrix;
  if (SceneCapture2D->bUseCustomProjectionMatrix)
  {
    InCustomProjectionMatrix = SceneCapture2D->CustomProjectionMatrix;
  }

  // The out parameters for the individual view and projection matrix will not be needed
  FMatrix MapViewMatrix, MapProjectionMatrix;

  // Cache the MapViewProjection matrix
  UGameplayStatics::CalculateViewProjectionMatricesFromMinimalView(
    InMapViewInfo,
    InCustomProjectionMatrix,
    MapViewMatrix,
    MapProjectionMatrix,
    MapViewProjectionMatrix
  );
}

void UProjectMMapWidget::SetSelectedUnit(UMilitaryUnit* Unit)
{
  SelectedUnit = Unit;
}

UCanvasPanel* UProjectMMapWidget::GetCanvasPanel() const
{
  return CanvasPanel;
}

UBorder* UProjectMMapWidget::GetBorder() const
{
  return Border;
}

//----------------------------------------------------------------------//
//  UProjectMMapWidgetLibrary
//----------------------------------------------------------------------//
void UProjectMMapWidgetLibrary::RecursivelyExpandTreeViewUnitParents(UTreeView* TreeView, UMilitaryUnit* Unit)
{
  while (Unit)
  {
    TreeView->SetItemExpansion(Unit, true);
    Unit = Unit->Parent;
  }
}

```

`Source/ProjectM/Private/ProjectMWorldInfo.cpp`:

```cpp
#include "ProjectMWorldInfo.h"

#include "Components/BoxComponent.h"
#include "Components/DirectionalLightComponent.h"
#include "Components/SceneCaptureComponent2D.h"
#include "Engine/DirectionalLight.h"
#include "Engine/PostProcessVolume.h"
#include "Engine/StaticMeshActor.h"
#include "Engine/TextureRenderTarget2D.h"


AProjectMWorldInfo::AProjectMWorldInfo()
{
	PrimaryActorTick.bCanEverTick = false;

	WorldMapBoundingBox = CreateDefaultSubobject<UBoxComponent>("WorldMapBoundingBox");
	WorldMapBoundingBox->PrimaryComponentTick.bCanEverTick = false;
	WorldMapBoundingBox->SetGenerateOverlapEvents(false);
	WorldMapBoundingBox->CanCharacterStepUpOn = ECanBeCharacterBase::ECB_No;
	WorldMapBoundingBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	WorldMapBoundingBox->bVisibleInReflectionCaptures = false;
	WorldMapBoundingBox->bVisibleInRealTimeSkyCaptures = false;
	WorldMapBoundingBox->bVisibleInRayTracing = false;
	WorldMapBoundingBox->bRenderInMainPass = false;
	WorldMapBoundingBox->bRenderInDepthPass = false;
	WorldMapBoundingBox->bReceivesDecals = false;
	WorldMapBoundingBox->bHiddenInSceneCapture = false;
	WorldMapBoundingBox->bReceiveMobileCSMShadows = false;

	RootComponent = WorldMapBoundingBox;

	WorldMapSceneCaptureComponent2D = CreateDefaultSubobject<USceneCaptureComponent2D>("WorldMapSceneCaptureComponent");
	WorldMapSceneCaptureComponent2D->PrimaryComponentTick.bCanEverTick = false;
	WorldMapSceneCaptureComponent2D->ProjectionType = ECameraProjectionMode::Orthographic;
	WorldMapSceneCaptureComponent2D->CaptureSource = SCS_BaseColor;
	WorldMapSceneCaptureComponent2D->bCaptureEveryFrame = false;
	WorldMapSceneCaptureComponent2D->bCaptureOnMovement = false;
	MapResolution = 1024;

	InitialSunlightYaw = 0.0f;
	SunlightYaw = 0.0f;
	SkyDomeYawOffset = 0.0f;
}

void AProjectMWorldInfo::BeginPlay()
{
	Super::BeginPlay();

	InitializeMapSceneCapture();
	InitializeSunlightSettings();

	SetSunlightAngle(0.f);
}

void AProjectMWorldInfo::InitializeMapSceneCapture()
{
	// If there is no bounding box or scene capture for initialization, do nothing
	if (!IsValid(WorldMapBoundingBox) || !IsValid(WorldMapSceneCaptureComponent2D))
	{
		return;
	}

	//Calculate bounds of the World
	const FVector& Center = WorldMapBoundingBox->GetComponentLocation();
	const FVector& Extents = WorldMapBoundingBox->GetScaledBoxExtent();
	FBox MapBounds(Center - Extents, Center + Extents);

	//Calculate Viewport size
	FBox2D WorldBounds2D(FVector2D(MapBounds.Min), FVector2D(MapBounds.Max));
	FVector2D ViewSize = WorldBounds2D.Max - WorldBounds2D.Min;
	float AspectRatio = FMath::Abs(ViewSize.X) / FMath::Abs(ViewSize.Y);
	uint32 ViewportWidth = MapResolution;
	uint32 ViewportHeight = MapResolution * AspectRatio;

	//Calculate Projection matrix based on world bounds.
	FMatrix CustomViewProjectionMatrix;
	AProjectMWorldInfo::CalculateTopWorldView(CustomViewProjectionMatrix, MapBounds, ViewportWidth, ViewportHeight);

	// Create a render target and set the world map scene capture
	if (!IsValid(WorldMapSceneCaptureComponent2D->TextureTarget))
	{
		UTextureRenderTarget2D* RenderTargetTexture = NewObject<UTextureRenderTarget2D>();
		RenderTargetTexture->ClearColor = FLinearColor::Transparent;
		RenderTargetTexture->TargetGamma = 2.2f;
		RenderTargetTexture->InitCustomFormat(ViewportWidth, ViewportHeight, PF_B8G8R8A8, false);
		RenderTargetTexture->UpdateResourceImmediate(true);
		WorldMapSceneCaptureComponent2D->TextureTarget = RenderTargetTexture;
	}

	float CaptureActorZ;
	if (WorldMapSceneCaptureComponent2D->ProjectionType == ECameraProjectionMode::Perspective)
	{
		// Calculate distance required for scene capture component to capture entire bounded area
		const float FOVAngle = WorldMapSceneCaptureComponent2D->FOVAngle;
		CaptureActorZ = Extents.Y / FMath::Tan(FMath::DegreesToRadians(FOVAngle * 0.5f));
	}
	else
	{
		CaptureActorZ = MapBounds.GetCenter().Z + MapBounds.GetExtent().Z;
		WorldMapSceneCaptureComponent2D->bUseCustomProjectionMatrix = true;
		WorldMapSceneCaptureComponent2D->CustomProjectionMatrix = CustomViewProjectionMatrix;
		WorldMapSceneCaptureComponent2D->OrthoWidth = ViewportWidth;
	}

	const FVector CaptureActorLocation(MapBounds.GetCenter().X, MapBounds.GetCenter().Y, CaptureActorZ);
	// TODO: figure out why CaptureActorRotation had to be changed from ACitySampleWorldInfo. Without the Yaw change, the map is rotated.
	const FRotator CaptureActorRotation(-90.f, -90.f, 0.f);
	WorldMapSceneCaptureComponent2D->SetWorldLocationAndRotation(CaptureActorLocation, CaptureActorRotation);
	WorldMapSceneCaptureComponent2D->CaptureScene();
}

void AProjectMWorldInfo::CalculateTopWorldView(FMatrix& OutProjectionMatrix, const FBox& WorldBox, uint32 ViewportWidth, uint32 ViewportHeight)
{
	const FVector2D WorldSizeMin2D(WorldBox.Min.X, WorldBox.Min.Y);
	const FVector2D WorldSizeMax2D(WorldBox.Max.X, WorldBox.Max.Y);

	FVector2D WorldSize2D = (WorldSizeMax2D - WorldSizeMin2D);
	WorldSize2D.X = FMath::Abs(WorldSize2D.X);
	WorldSize2D.Y = FMath::Abs(WorldSize2D.Y);
	const bool bUseXAxis = (WorldSize2D.X / WorldSize2D.Y) > 1.f;
	const float WorldAxisSize = bUseXAxis ? WorldSize2D.X : WorldSize2D.Y;
	const uint32 ViewportAxisSize = bUseXAxis ? ViewportWidth : ViewportHeight;
	const float OrthoZoom = WorldAxisSize / ViewportAxisSize / 2.f;
	const float OrthoWidth = FMath::Max(1.f, ViewportWidth * OrthoZoom);
	const float OrthoHeight = FMath::Max(1.f, ViewportHeight * OrthoZoom);

	const float ZOffset = HALF_WORLD_MAX;
	OutProjectionMatrix = FReversedZOrthoMatrix(
		OrthoWidth,
		OrthoHeight,
		0.5f / ZOffset,
		ZOffset
	);

	ensureMsgf(!OutProjectionMatrix.ContainsNaN(), TEXT("Nans found on ProjectionMatrix"));
	if (OutProjectionMatrix.ContainsNaN())
	{
		OutProjectionMatrix.SetIdentity();
	}
}

void AProjectMWorldInfo::InitializeSunlightSettings()
{
	if (ADirectionalLight* const Light = SunLight.Get())
	{
		UDirectionalLightComponent* const LightComponent = Cast<UDirectionalLightComponent>(Light->GetLightComponent());
		check(LightComponent != nullptr);
		
		// Set the initial and current sunlight yaw using the current yaw of the directional "sun" light component
		InitialSunlightYaw = SunlightYaw = FRotator::ClampAxis(LightComponent->GetComponentRotation().Yaw);
	}

	if (AStaticMeshActor* const Sky = SkyDome.Get())
	{
		// Set the sky dome yaw offset using the current sunlight yaw and the set sky dome
		const float SkyDomeYaw = FRotator::ClampAxis(Sky->GetActorRotation().Yaw);
		SkyDomeYawOffset = SkyDomeYawOffset = FRotator::ClampAxis(SkyDomeYaw - SunlightYaw);
	}
}

void AProjectMWorldInfo::SetSunlightAngle(const float Angle)
{
	SunlightYaw = FRotator::ClampAxis(Angle);

	if (ADirectionalLight* const Light = SunLight.Get())
	{
		UDirectionalLightComponent* const LightComponent = Cast<UDirectionalLightComponent>(Light->GetLightComponent());
		check(LightComponent != nullptr);

		const FRotator& SunlightRotation = LightComponent->GetComponentRotation();
		LightComponent->SetWorldRotation(FRotator(SunlightRotation.Pitch, SunlightYaw, SunlightRotation.Roll));
	}

	if (AStaticMeshActor* const Sky = SkyDome.Get())
	{
		const FRotator& SkyRotation = Sky->GetActorRotation();
		const float SkyDomeYaw = FRotator::ClampAxis(SunlightYaw + SkyDomeYawOffset);
		Sky->SetActorRotation(FRotator(SkyRotation.Pitch, SkyDomeYaw, SkyRotation.Roll));
	}
}

void AProjectMWorldInfo::ResetSunlightAngle()
{
	SetSunlightAngle(InitialSunlightYaw);
}

float AProjectMWorldInfo::GetPostProcessingFilterBlendWeight() const
{
	return PostProcessingFilter.IsValid() ? PostProcessingFilter->BlendWeight : 0.0f;
}

void AProjectMWorldInfo::SetPostProcessingFilterBlendWeight(const float BlendWeight)
{
	if (PostProcessingFilter.IsValid())
	{
		PostProcessingFilter->BlendWeight = FMath::Clamp(BlendWeight, 0.0f, 1.0f);
	}
}

```

`Source/ProjectM/Private/Tests/MassMoveToCommandProcessorTest.cpp`:

```cpp
#include "CoreTypes.h"
#include "Containers/UnrealString.h"
#include "Misc/AutomationTest.h"


#if WITH_DEV_AUTOMATION_TESTS

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMassMoveToCommandProcessorTest, "ProjectM.MassMoveToCommandProcessor", EAutomationTestFlags::ApplicationContextMask | EAutomationTestFlags::SmokeFilter)


bool FMassMoveToCommandProcessorTest::RunTest(const FString& Parameters)
{
	auto GetOffset = [](const float ForwardX, const float ForwardY) -> FVector {
		return FVector(UMassMoveToCommandProcessor::GetSoldierOffsetFromSquadLeaderUnscaledMeters(6, FVector(ForwardX, ForwardY, 0.f)), 0.f);
	};
	auto V3D = [](const float X, const float Y) -> FVector {
		return FVector(X, Y, 0.f);
	};
	{
		// All tests here assume (X,Y) of (0,1) is 0 degrees.
		TestEqual(TEXT("Rotate right 90 deg must create correct value"), GetOffset(1.f, 0.f), V3D(-30.f, 10.f));
		TestEqual(TEXT("Rotate left 90 deg must create correct value"), GetOffset(-1.f, 0.f), V3D(30.f, -10.f));
		TestEqual(TEXT("Rotate right 45 deg must create correct value"), GetOffset(1.f, 1.f), V3D(-28.28427f, -14.14214f));
		TestEqual(TEXT("Rotate 0 deg must create correct value"), GetOffset(0.f, 1.f), V3D(-10.f, -30.f));
		TestEqual(TEXT("Rotate 180 deg must create correct value"), GetOffset(0.f, -1.f), V3D(10.f, 30.f));
		TestEqual(TEXT("Rotate right 135 deg must create correct value"), GetOffset(1.f, -1.f), V3D(-14.14214f, 28.28427f));
	}

	return true;
}


#endif //WITH_DEV_AUTOMATION_TESTS

```

`Source/ProjectM/ProjectM.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class ProjectM : ModuleRules
{
	public ProjectM(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore",
			"Niagara",
			"StateTreeModule",
			"StructUtils",
			"UMG",
			"MotionWarping",
			"ContextualAnimation",
			"AnimToTexture",
		});

		PrivateDependencyModuleNames.AddRange(new string[] {
			// AI/MassAI Plugin Modules
			"MassAIBehavior",
			"MassAIDebug",
			"MassZoneGraphNavigation",

			// AI/MassCrowd Plugin Modules
			"MassCrowd",

			// Runtime/MassEntity Plugin Modules
			"MassEntity",

			// Runtime/MassGameplay Plugin Modules
			"MassActors",
			"MassCommon",
			"MassGameplayDebug",
			"MassLOD",
			"MassMovement",
			"MassNavigation",
			"MassRepresentation",
			"MassReplication",
			"MassSpawner",
			"MassSimulation",
			"MassSignals",

			"Slate",
			"SlateCore",

			"NavigationSystem",
		});

		if (Target.bBuildDeveloperTools || (Target.Configuration != UnrealTargetConfiguration.Shipping && Target.Configuration != UnrealTargetConfiguration.Test))
		{
				PrivateDependencyModuleNames.Add("GameplayDebugger");
				PublicDefinitions.Add("WITH_GAMEPLAY_DEBUGGER=1");
		}
		else
		{
				PublicDefinitions.Add("WITH_GAMEPLAY_DEBUGGER=0");
		}
	}
}

```

`Source/ProjectM/Public/Character/CommanderCharacter.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "MassEntityConfigAsset.h"
#include "MassEntityTraitBase.h"
#include "CommanderCharacter.generated.h"

class UMassMoveToCommandSubsystem;

UCLASS(meta = (DisplayName = "PlayerControllableCharacter"))
class PROJECTM_API UMassPlayerControllableCharacterTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

USTRUCT()
struct FMassPlayerControllableCharacterTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class PROJECTM_API ACommanderCharacter : public ACharacter
{
	GENERATED_BODY()

private:
	void InitializeFromMassSoldierInternal();
	FMassEntityHandle GetMassEntityHandle() const;

	FDelegateHandle OnMassAgentComponentEntityAssociatedHandle;
	FMassEntityHandle MassSoldierEntityToInitializeWith;

protected:
	UPROPERTY()
	UMassMoveToCommandSubsystem* MoveToCommandSystem;

	UPROPERTY(EditAnywhere, Category = "Mass")
	FMassEntityConfig ProjectileEntityConfig;

	UPROPERTY(EditAnywhere, Category = "Mass")
	FMassEntityConfig SoldierEntityConfig;

	UFUNCTION(BlueprintCallable)
	void SpawnProjectile(const FTransform SpawnTransform) const;

	virtual void BeginPlay() override;
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	UFUNCTION(BlueprintCallable)
	void SetMoveToCommand(FVector2D CommandLocation) const;

	UFUNCTION(BlueprintCallable)
	class UMilitaryUnit* GetMyMilitaryUnit() const;

public:
	ACommanderCharacter();

	UFUNCTION(BlueprintCallable)
	void ChangePlayerToAISoldier();

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable)
	void DidDie();

	UFUNCTION(BlueprintCallable)
	bool InitializeFromMassSoldier(const int32 MassEntityIndex, const int32 MassEntitySerialNumber);

	UFUNCTION(BlueprintCallable)
	bool IsPlayerOnTeam1() const;

	UFUNCTION(BlueprintCallable)
	bool IsCommander() const;
};

```

`Source/ProjectM/Public/Character/MassCharacter.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "AnimToTextureDataAsset.h"
#include "MassCharacter.generated.h"

UCLASS()
class PROJECTM_API AMassCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, Category = "Mass")
	TObjectPtr<UAnimToTextureDataAsset> AnimToTextureDataAsset;

	UFUNCTION(BlueprintImplementableEvent)
	void BP_OnCharacterDeath();
};

```

`Source/ProjectM/Public/FirstPersonGameModeCommander.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "FirstPersonGameModeCommander.generated.h"

/**
 * 
 */
UCLASS()
class PROJECTM_API AFirstPersonGameModeCommander : public AGameModeBase
{
	GENERATED_BODY()

public:
	virtual void StartPlay() override;

	UFUNCTION(BlueprintImplementableEvent)
	void BP_OnCompletedAssigningEntitiesToMilitaryUnits();
};

```

`Source/ProjectM/Public/GameplayDebuggerCategory_ProjectM.h`:

```h
// Adapted from GameplayDebuggerCategory_Mass.h.

#pragma once

#if WITH_GAMEPLAY_DEBUGGER

#include "CoreMinimal.h"
#include "GameplayDebuggerCategory.h"

class APlayerController;
class AActor;
struct FMassNavMeshMoveFragment;

class FGameplayDebuggerCategory_ProjectM : public FGameplayDebuggerCategory
{
public:
  FGameplayDebuggerCategory_ProjectM();
  void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;
  void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext) override;

  static TSharedRef<FGameplayDebuggerCategory> MakeInstance();

protected:
	void DrawTargetEntityLocations(const TArray<FVector>& TargetEntityLocations, const FColor& Color, const FVector& EntityLocation);
	void CollectDataForEntities(const APlayerController* OwnerPC, const FVector& ViewLocation, const FVector& ViewDirection);
	void CollectDataForEntity(const FMassNavMeshMoveFragment& NavMeshMoveFragment, const FTransform& Transform, const float MinViewDirDot, const FVector& ViewLocation, const FVector& ViewDirection, const float MaxViewDistance, const struct FMassMoveTargetFragment& MoveTargetFragment, const float AgentRadius, const FMassEntityHandle& Entity, const UWorld* World, FMassExecutionContext& Context);

	void OnToggleEnemyTargetFinderDetails() { bShowEnemyTargetFinderDetails = !bShowEnemyTargetFinderDetails; }

	bool bShowEnemyTargetFinderDetails = false;

	struct FEntityDescription
	{
		FEntityDescription() = default;
		FEntityDescription(const float InScore, const FVector& InLocation, const FString& InDescription) : Score(InScore), Location(InLocation), Description(InDescription) {}

		float Score = 0.0f;
		FVector Location = FVector::ZeroVector;
		FString Description;
	};
	TArray<FEntityDescription> NearEntityDescriptions;
};

#endif // WITH_GAMEPLAY_DEBUGGER
```

`Source/ProjectM/Public/InvalidTargetFinderProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassNavigationFragments.h"
#include "InvalidTargetFinderProcessor.generated.h"

class UMassTargetFinderSubsystem;
class UMassSignalSubsystem;
struct FCapsule;
struct FMassNavMeshMoveFragment;

void UnstashMoveTarget(const FMassMoveTargetFragment& Source, FMassMoveTargetFragment& Destination, const UWorld& World, const FMassExecutionContext& Context, FMassNavMeshMoveFragment& NavMeshMoveFragment, const FTransform& EntityTransform);
void CopyMoveTarget(const FMassMoveTargetFragment& Source, FMassMoveTargetFragment& Destination, const UWorld& World);
bool DidCapsulesCollide(const FCapsule& Capsule1, const FCapsule& Capsule2, const FMassEntityHandle& Entity, const UWorld& World);

UCLASS()
class PROJECTM_API UInvalidTargetFinderProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UInvalidTargetFinderProcessor();

protected:
	virtual void Initialize(UObject& Owner) override;
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	TObjectPtr<UMassSignalSubsystem> SignalSubsystem;
	TObjectPtr<UMassTargetFinderSubsystem> TargetFinderSubsystem;

private:
	FMassEntityQuery BuildQueueEntityQuery;
	FMassEntityQuery BuildQueueForTrackTargetEntityQuery;
	FMassEntityQuery InvalidateTargetsEntityQuery;

	// Frame buffer, it gets reset every frame.
	TArray<FMassEntityHandle> TransientEntitiesToSignal;
};

```

`Source/ProjectM/Public/MassAgentLocationSyncTrait.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassAgentTraits.h"
#include "MassVisualizationTrait.h"
#include "MassVisualizationComponent.h"
#include "MassUpdateISMProcessor.h"
#include "MassRepresentationSubsystem.h"
#include "MassRepresentationProcessor.h"
#include "MassVisualizationLODProcessor.h"
#include "MassLODCollectorProcessor.h"
#include "MassAgentLocationSyncTrait.generated.h"

class UMassNavigationSubsystem;
struct FMassNavigationObstacleItem;

// TODO: split up this file into more cohesive units

USTRUCT()
struct FMassProjectileTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassProjectileVisualizationTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassLocationCopyToActorTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassProjectileUpdateCollisionTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS(meta = (DisplayName = "Projectile"))
class PROJECTM_API UMassProjectileTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

UCLASS(meta = (DisplayName = "ProjectileUpdateCollision"))
class PROJECTM_API UMassProjectileUpdateCollisionTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Agent Location Sync"))
class PROJECTM_API UMassAgentLocationSyncTrait : public UMassAgentSyncTrait
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

UCLASS()
class PROJECTM_API ULocationToActorTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	ULocationToActorTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

UCLASS()
class PROJECTM_API UMassProjectileUpdateISMCollisionsProcessor : public UMassUpdateISMProcessor
{
	GENERATED_BODY()
public:
	UMassProjectileUpdateISMCollisionsProcessor();

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;
};

UCLASS()
class PROJECTM_API UMassProjectileRepresentationSubsystem : public UMassRepresentationSubsystem
{
	GENERATED_BODY()

public:
	AMassVisualizer* GetVisualizer();

protected:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	// USubsystem END

	void OnPrePhysicsProcessingPhaseStarted(const float DeltaSeconds, const EMassProcessingPhase Phase);

	bool bNeedUpdateCollisions = true;
};

UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Projectile Visualization"))
class PROJECTM_API UMassProjectileVisualizationTrait : public UMassVisualizationTrait
{
	GENERATED_BODY()
public:
	UMassProjectileVisualizationTrait();

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

UCLASS(meta = (DisplayName = "Mass Projectile Visualization"))
class PROJECTM_API UMassProjectileVisualizationProcessor : public UMassVisualizationProcessor
{
	GENERATED_BODY()
public:
	UMassProjectileVisualizationProcessor();

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;
};

UCLASS(meta = (DisplayName = "Projectile visualization LOD"))
class PROJECTM_API UMassProjectileVisualizationLODProcessor : public UMassVisualizationLODProcessor
{
	GENERATED_BODY()
public:
	UMassProjectileVisualizationLODProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;
};

UCLASS(meta = (DisplayName = "Projectile LOD Collector"))
class PROJECTM_API UMassProjectileLODCollectorProcessor : public UMassLODCollectorProcessor
{
	GENERATED_BODY()

	UMassProjectileLODCollectorProcessor();

protected:
	virtual void ConfigureQueries() override;
};

```

`Source/ProjectM/Public/MassAgentOrientNoCharSyncTrait.h`:

```h
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.

#pragma once

#include "MassAgentTraits.h"
#include "MassCommonFragments.h"
#include "MassTranslator.h"
#include "MassAgentOrientNoCharSyncTrait.generated.h"

USTRUCT()
struct FMassSceneComponentOrientationCopyToMassTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassSceneComponentOrientationCopyToActorTag : public FMassTag
{
	GENERATED_BODY()
};

// Unlike UMassAgentOrientationSyncTrait, this trait doesn't depend on actor being a Character subclass.
UCLASS(BlueprintType, EditInlineNew, CollapseCategories, meta = (DisplayName = "Agent Orientation (Without Character) Sync"))
class PROJECTM_API UMassAgentOrientNoCharSyncTrait : public UMassAgentSyncTrait
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

UCLASS()
class PROJECTM_API UMassSceneComponentOrientationToMassTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassSceneComponentOrientationToMassTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

UCLASS()
class PROJECTM_API UMassSceneComponentOrientationToActorTranslator : public UMassTranslator
{
	GENERATED_BODY()

public:
	UMassSceneComponentOrientationToActorTranslator();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassAgentRadiusTrait.h`:

```h
#pragma once

#include "MassEntityTraitBase.h"

#include "MassAgentRadiusTrait.generated.h"

// Usually you can add the FAgentRadiusFragment via UMassAssortedFragmentsTrait but if you want to use inheritance in data assets just for agent radius, you need a trait.
UCLASS(meta = (DisplayName = "AgentRadius"))
class PROJECTM_API UMassAgentRadiusTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

public:
	UPROPERTY(EditAnywhere, Category = "")
	float Radius = 40.f;
};


```

`Source/ProjectM/Public/MassAudioPerceptionProcessor.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"

#include "MassAudioPerceptionProcessor.generated.h"

class UMassSoundPerceptionSubsystem;

struct FSoundTraceData
{
	FSoundTraceData() = default;
	FSoundTraceData(const FMassEntityHandle& Entity, const FVector& TraceStart, const FVector& TraceEnd)
		: Entity(Entity), TraceStart(TraceStart), TraceEnd(TraceEnd)
	{
	}
	FMassEntityHandle Entity;
	FVector TraceStart;
	FVector TraceEnd;
};

UCLASS()
class PROJECTM_API UMassAudioPerceptionProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassAudioPerceptionProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery PreLineTracesEntityQuery;
	FMassEntityQuery PostLineTracesEntityQuery;
	TObjectPtr<UMassSoundPerceptionSubsystem> SoundPerceptionSubsystem;
};

```

`Source/ProjectM/Public/MassCollisionProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassEntityTraitBase.h"
#include "MassEntityTemplateRegistry.h"
#include "MassEntityTypes.h"
#include "MassNavigationSubsystem.h"

#include "MassCollisionProcessor.generated.h"

USTRUCT()
struct FMassCollisionTag : public FMassTag
{
	GENERATED_BODY()
};

struct FCapsule
{
	FCapsule(FVector InA, FVector InB, float InR) : a(InA), b(InB), r(InR) {}
	FCapsule() {}
	FVector a; // One edge of Capsule.
	FVector b; // Other edge of Capsule.
	float r; // Radius
};

USTRUCT()
struct PROJECTM_API FCollisionCapsuleParametersFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(Category = "", EditAnywhere)
	bool bIsCapsuleAlongForwardVector;

	UPROPERTY(Category = "", EditAnywhere)
	float CapsuleRadius;

	UPROPERTY(Category = "", EditAnywhere)
	float CapsuleLength;

	UPROPERTY(Category = "", EditAnywhere)
	FVector CapsuleCenterOffset;
};

FCapsule MakeCapsuleForEntity(const FCollisionCapsuleParametersFragment& CollisionCapsuleParametersFragment, const FTransform& EntityTransform);
FCapsule MakeCapsuleForEntity(const FMassEntityView& EntityView);

// Returns true if capsules collide.
bool TestCapsuleCapsule(FCapsule capsule1, FCapsule capsule2);

void DrawCapsule(const FCapsule& Capsule, const UWorld& World, const FLinearColor& Color = FLinearColor::Red, const bool bPersistentLines = true, float LifeTime = -1.f);

UCLASS(meta = (DisplayName = "Collision"))
class PROJECTM_API UMassCollisionTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(Category = "", EditAnywhere)
	bool bIsCapsuleAlongForwardVector;

	UPROPERTY(Category = "", EditAnywhere)
	float CapsuleRadius;

	UPROPERTY(Category = "", EditAnywhere)
	float CapsuleLength;

	UPROPERTY(Category = "", EditAnywhere)
	FVector CapsuleCenterOffset;

	UPROPERTY(Category = "", EditAnywhere)
	bool bEnableCollisionProcessor;
};

UCLASS()
class PROJECTM_API UMassCollisionProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassCollisionProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	TObjectPtr<UMassNavigationSubsystem> NavigationSubsystem;
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassDelayedDestructionProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassEntityTraitBase.h"
#include "MassEntityTypes.h"

#include "MassDelayedDestructionProcessor.generated.h"

USTRUCT()
struct PROJECTM_API FMassDelayedDestructionFragment : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = "")
	float SecondsLeftTilDestruction;
};

UCLASS(meta = (DisplayName = "DelayedDestruction"))
class PROJECTM_API UMassDelayedDestructionTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(Category = "", EditAnywhere)
	float SecondsDelay = 3.0f;
};

UCLASS()
class PROJECTM_API UMassDelayedDestructionProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassDelayedDestructionProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassEnemyTargetFinderProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassEntityTraitBase.h"
#include "MassEntityTemplateRegistry.h"
#include "MassSoundPerceptionSubsystem.h"
#include "MassCollisionProcessor.h"

#include "MassEnemyTargetFinderProcessor.generated.h"

struct FTargetEntityFragment;
class UMassNavigationSubsystem;
class UMassTargetFinderSubsystem;

inline bool UMassEnemyTargetFinderProcessor_SkipFindingTargets = false;
inline FAutoConsoleVariableRef CVarUMassEnemyTargetFinderProcessor_SkipFindingTargets(TEXT("pm.UMassEnemyTargetFinderProcessor_SkipFindingTargets"), UMassEnemyTargetFinderProcessor_SkipFindingTargets, TEXT("UMassEnemyTargetFinderProcessor: Skip Finding Targets"));

inline float UMassEnemyTargetFinder_FinestCellSize = 5000.f;
inline FAutoConsoleVariableRef CVarUMassEnemyTargetFinder_FinestCellSize(TEXT("pm.UMassEnemyTargetFinder_FinestCellSize"), UMassEnemyTargetFinder_FinestCellSize, TEXT("CVarUMassEnemyTargetFinder_FinestCellSize"));

constexpr float ProjectileRadius = 3.f; // TODO: Use Radius from projectile Data Asset.

bool CanEntityDamageTargetEntity(const float TargetMinCaliberForDamage, const float MinCaliberForDamage);
FCapsule GetProjectileTraceCapsuleToTarget(const bool bIsEntitySoldier, const bool bIsTargetEntitySoldier, const FTransform& EntityTransform, const FVector& TargetEntityLocation);
float GetProjectileInitialXYVelocityMagnitude(const bool bIsEntitySoldier);
float GetEntityRange(const bool bIsEntitySoldier);
bool IsTargetEntityVisibleViaSphereTrace(const UWorld& World, const FVector& StartLocation, const FVector& EndLocation, const bool DrawTrace = false);

#if WITH_MASSGAMEPLAY_DEBUG
struct FDebugEntityData
{
	FVector SearchCenter = FVector::ZeroVector;
	FVector SearchExtent = FVector::ZeroVector;
	FVector EntityLocation = FVector::ZeroVector;
	FVector TargetEntityLocation = FVector::ZeroVector;
	int32 NumCloseEntities = 0;
	int32 NumPotentialTargetsNeedingSphereTrace = 0;
	bool IsEntitySearching = true;
	bool HasTargetEntity = false;
	TArray<FVector> TargetEntitiesCulledDueToOtherEntityBlocking;
	TArray<FVector> TargetEntitiesCulledDueToSameTeam;
	TArray<FVector> TargetEntitiesCulledDueToImpenetrable;
	TArray<FVector> TargetEntitiesCulledDueToOutOfRange;
	TArray<FVector> TargetEntitiesCulledDueToNoLineOfSight;

	void Reset()
	{
		*this = FDebugEntityData();
	}
};

inline FDebugEntityData UMassEnemyTargetFinderProcessor_DebugEntityData;
#endif

USTRUCT()
struct PROJECTM_API FTargetEntityFragment : public FMassFragment
{
	GENERATED_BODY()

	/** The entity that the fragment owner is targeting. */
	FMassEntityHandle Entity;
	
	float TargetMinCaliberForDamage;

	float VerticalAimOffset = 0.f;
};

USTRUCT()
struct PROJECTM_API FTeamMemberFragment : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = "")
	bool IsOnTeam1 = true;
};

UCLASS(meta = (DisplayName = "TeamMember"))
class PROJECTM_API UMassTeamMemberTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

public:
	UPROPERTY(Category = "Team", EditAnywhere)
	bool IsOnTeam1 = true;
};

USTRUCT()
struct FMassTrackSoundTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassNeedsEnemyTargetTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassWillNeedEnemyTargetTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS(meta = (DisplayName = "NeedsEnemyTarget"))
class PROJECTM_API UMassNeedsEnemyTargetTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(Category = "", EditAnywhere)
	float ProjectileCaliber = 5.f; // TODO: DRY this with the Caliber value in projectile data assets.
};

UCLASS()
class PROJECTM_API UMassEnemyTargetFinderProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassEnemyTargetFinderProcessor();
	static float GetProjectileSpawnLocationZOffset(const bool& bIsSoldier);
	static FVector GetProjectileSpawnLocationOffset(const FTransform& EntityTransform, const bool& bIsSoldier);

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	TObjectPtr<UMassTargetFinderSubsystem> TargetFinderSubsystem;
	FMassEntityQuery PreSphereTraceEntityQuery;
	FMassEntityQuery PostSphereTraceEntityQuery;
};

```

`Source/ProjectM/Public/MassFastAvoidanceProcessors.h`:

```h
// Copied from engine except uses ParallelForEachEntityChunk.

#pragma once

#include "MassProcessor.h"
#include "MassFastAvoidanceProcessors.generated.h"

PROJECTM_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidance, Warning, All);
PROJECTM_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidanceVelocities, Warning, All);
PROJECTM_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidanceAgents, Warning, All);
PROJECTM_API DECLARE_LOG_CATEGORY_EXTERN(LogAvoidanceObstacles, Warning, All);

class UMassNavigationSubsystem;

/** Experimental: move using cumulative forces to avoid close agents */
UCLASS()
class PROJECTM_API UMassFastMovingAvoidanceProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassFastMovingAvoidanceProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	TObjectPtr<UWorld> World;
	TObjectPtr<UMassNavigationSubsystem> NavigationSubsystem;
	FMassEntityQuery EntityQuery;
};

/** Avoidance while standing. */
UCLASS()
class PROJECTM_API UMassFastStandingAvoidanceProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassFastStandingAvoidanceProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	TObjectPtr<UWorld> World;
	TObjectPtr<UMassNavigationSubsystem> NavigationSubsystem;
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassFastAvoidanceTrait.h`:

```h
// Copied from engine except uses ParallelForEachEntityChunk.

#pragma once 

#include "MassEntityTraitBase.h"
#include "Avoidance/MassAvoidanceFragments.h"
#include "MassFastAvoidanceTrait.generated.h"

USTRUCT()
struct PROJECTM_API FMassFastMovingAvoidanceParameters : public FMassMovingAvoidanceParameters
{
	GENERATED_BODY()

	FMassFastMovingAvoidanceParameters GetValidated() const
	{
		FMassFastMovingAvoidanceParameters Copy = *this;
		Copy.PredictiveAvoidanceTime = FMath::Max(Copy.PredictiveAvoidanceTime, KINDA_SMALL_NUMBER);
		Copy.ObstacleSeparationDistance = FMath::Max(Copy.ObstacleSeparationDistance, KINDA_SMALL_NUMBER);
		Copy.PredictiveAvoidanceDistance = FMath::Max(Copy.PredictiveAvoidanceDistance, KINDA_SMALL_NUMBER);
		Copy.EnvironmentSeparationDistance = FMath::Max(Copy.EnvironmentSeparationDistance, KINDA_SMALL_NUMBER);
		Copy.StartOfPathDuration = FMath::Max(Copy.StartOfPathDuration, KINDA_SMALL_NUMBER);
		Copy.EndOfPathDuration = FMath::Max(Copy.EndOfPathDuration, KINDA_SMALL_NUMBER);

		return Copy;
	}
};

USTRUCT()
struct PROJECTM_API FMassFastStandingAvoidanceParameters : public FMassStandingAvoidanceParameters
{
	GENERATED_BODY()

	FMassFastStandingAvoidanceParameters GetValidated() const
	{
		FMassFastStandingAvoidanceParameters Copy = *this;

		Copy.GhostSteeringReactionTime = FMath::Max(Copy.GhostSteeringReactionTime, KINDA_SMALL_NUMBER);

		return Copy;
	}
};

UCLASS(meta = (DisplayName = "FastAvoidance"))
class PROJECTM_API UMassFastObstacleAvoidanceTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(EditAnywhere, Category="")
	FMassFastMovingAvoidanceParameters MovingParameters;
	
	UPROPERTY(EditAnywhere, Category="")
	FMassFastStandingAvoidanceParameters StandingParameters;
};

```

`Source/ProjectM/Public/MassFireProjectileTask.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.


#pragma once

#include "MassStateTreeTypes.h"
#include "MassEntityConfigAsset.h"
#include "MassFireProjectileTask.generated.h"

class UMassSignalSubsystem;
struct FTransformFragment;
struct FTeamMemberFragment;
struct FTargetEntityFragment;

void SpawnProjectile(const UWorld* World, const FVector& SpawnLocation, const FQuat& SpawnRotation, const FVector& InitialVelocity, const FMassEntityConfig& EntityConfig, const bool& bIsProjectileFromTeam1);

USTRUCT()
struct PROJECTM_API FMassFireProjectileTaskInstanceData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = Parameter)
	FMassEntityConfig EntityConfig;

	UPROPERTY(EditAnywhere, Category = Parameter)
	float WeaponCoolDownSeconds = 1.f;

	UPROPERTY(VisibleAnywhere, Category = Parameter)
	float LastWeaponFireTimeSeconds = -1.f;
};

USTRUCT(meta = (DisplayName = "Fire Projectile"))
struct PROJECTM_API FMassFireProjectileTask : public FMassStateTreeTaskBase
{
	GENERATED_BODY()

protected:
	virtual bool Link(FStateTreeLinker& Linker) override;
	virtual const UStruct* GetInstanceDataType() const override { return FMassFireProjectileTaskInstanceData::StaticStruct(); }
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const override;
	virtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;

	TStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;
	TStateTreeExternalDataHandle<FTransformFragment> EntityTransformHandle;
	TStateTreeExternalDataHandle<FTeamMemberFragment> TeamMemberHandle;
	TStateTreeExternalDataHandle<FTargetEntityFragment> TargetEntityHandle;

	TStateTreeInstanceDataPropertyHandle<FMassEntityConfig> EntityConfigHandle;
	TStateTreeInstanceDataPropertyHandle<float> WeaponCoolDownSecondsHandle;
	TStateTreeInstanceDataPropertyHandle<float> LastWeaponFireTimeSecondsHandle;
};

```

`Source/ProjectM/Public/MassGenericAnimTask.h`:

```h
// Mostly a copy of City Sample MassContextualAnimTask.h

#pragma once

#include "MassEntityTypes.h"
#include "MassStateTreeTypes.h"
#include "MassGenericAnimTask.generated.h"

class UAnimMontage;

class UMassSignalSubsystem;
struct FMassGenericMontageFragment; 
struct FTransformFragment;
struct FMassMoveTargetFragment;

USTRUCT()
struct FMassGenericAnimTaskInstanceData
{
	GENERATED_BODY()
	
	UPROPERTY(VisibleAnywhere, Category = Input, meta = (Optional))
	FMassEntityHandle TargetEntity;

	UPROPERTY(EditAnywhere, Category = Parameter)
	float Duration = 0.0f;

	UPROPERTY()
	float ComputedDuration = 0.0f;

	/** Accumulated time used to stop task if a montage is set */
	UPROPERTY()
	float Time = 0.f;
};

USTRUCT(meta = (DisplayName = "Mass Generic Anim Task"))
struct FMassGenericAnimTask : public FMassStateTreeTaskBase
{
	GENERATED_BODY()

	FMassGenericAnimTask();

protected:
	virtual bool Link(FStateTreeLinker& Linker) override;
	virtual const UStruct* GetInstanceDataType() const override { return FMassGenericAnimTaskInstanceData::StaticStruct(); }

	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const override;
	virtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;

	TStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;
	TStateTreeExternalDataHandle<FMassGenericMontageFragment, EStateTreeExternalDataRequirement::Optional> MontageRequestHandle; 
	TStateTreeExternalDataHandle<FTransformFragment> TransformHandle;
	TStateTreeExternalDataHandle<FMassMoveTargetFragment> MoveTargetHandle;
	
	TStateTreeInstanceDataPropertyHandle<FMassEntityHandle> TargetEntityHandle;
	TStateTreeInstanceDataPropertyHandle<float> DurationHandle;
	TStateTreeInstanceDataPropertyHandle<float> ComputedDurationHandle;
	TStateTreeInstanceDataPropertyHandle<float> TimeHandle;

	UPROPERTY(EditAnywhere, Category = Parameter)
	class UContextualAnimSceneAsset* ContextualAnimAsset = nullptr;

	UPROPERTY(EditAnywhere, Category = Parameter)
	FName AlignmentTrack;

	UPROPERTY(EditAnywhere, Category = Parameter)
	FName InteractorRole;

	UPROPERTY(EditAnywhere, Category = Parameter)
	UAnimMontage* FallbackMontage = nullptr;
};

```

`Source/ProjectM/Public/MassGenericAnimationProcessor.h`:

```h
// Mostly a copy of City Sample MassCrowdAnimationProcessor.h

#pragma once

#include "MassObserverProcessor.h"
#include "MassRepresentationTypes.h"
#include "LightweightMontageInstance.h"
#include "ContextualAnimSceneAsset.h"

#include "MassGenericAnimationProcessor.generated.h"

class UAnimToTextureDataAsset;
struct FMassActorFragment;

// TODO: Rename to remove "Crowd"
namespace UE::CrowdInteractionAnim
{
	struct FRequest
	{
		TWeakObjectPtr<class UContextualAnimSceneAsset> ContextualAnimAsset = nullptr;
		FContextualAnimQueryResult QueryResult = FContextualAnimQueryResult();
		FName InteractorRole;
		FName AlignmentTrack;
	};

	struct FMotionWarpingScratch
	{
		float TimeRemaining = -1.0f;
		float Duration = -1.0f;
		FVector InitialLocation = FVector::ZeroVector;
		FQuat InitialRotation = FQuat::Identity;
	};
} // namespace UE::CrowdInteractionAnim

USTRUCT()
struct PROJECTM_API FMassGenericMontageFragment : public FMassFragment
{
	GENERATED_BODY()

	UE::VertexAnimation::FLightweightMontageInstance MontageInstance = UE::VertexAnimation::FLightweightMontageInstance();
	UE::CrowdInteractionAnim::FRequest InteractionRequest = UE::CrowdInteractionAnim::FRequest();
	UE::CrowdInteractionAnim::FMotionWarpingScratch MotionWarpingScratch = UE::CrowdInteractionAnim::FMotionWarpingScratch();
	FRootMotionMovementParams RootMotionParams = FRootMotionMovementParams();
	float SkippedTime = 0.0f;

	void Request(const UE::CrowdInteractionAnim::FRequest& InRequest);
	void Clear();
};

USTRUCT()
struct PROJECTM_API FGenericAnimationFragment : public FMassFragment
{
	GENERATED_BODY()

	TWeakObjectPtr<UAnimToTextureDataAsset> AnimToTextureData;
	float GlobalStartTime = 0.0f;
	float PlayRate = 1.0f;
	int32 AnimationStateIndex = 0;
	bool bSwappedThisFrame = false;
};

UCLASS()
class PROJECTM_API UMassGenericAnimationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassGenericAnimationProcessor();

	UPROPERTY(EditAnywhere, Category="Animation", meta=(ClampMin=0.0, UIMin=0.0))
	float MoveThresholdSq = 750.0f;

private:
	void UpdateAnimationFragmentData(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context, float GlobalTime, TArray<FMassEntityHandle, TInlineAllocator<32>>& ActorEntities);
	void UpdateVertexAnimationState(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context, float GlobalTime);
	void UpdateSkeletalAnimation(UMassEntitySubsystem& EntitySubsystem, float GlobalTime, TArrayView<FMassEntityHandle> ActorEntities);

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	static class UAnimInstance* GetAnimInstanceFromActor(const class AActor* Actor);

	UPROPERTY(Transient)
	UWorld* World = nullptr;

	FMassEntityQuery AnimationEntityQuery_Conditional;
	FMassEntityQuery MontageEntityQuery;
	FMassEntityQuery MontageEntityQuery_Conditional;
};

// Adapted from CitySample UCitySampleCrowdVisualizationFragmentInitializer.
UCLASS()
class PROJECTM_API UGenericAnimationFragmentInitializer : public UMassObserverProcessor
{
	GENERATED_BODY()

public:
	UGenericAnimationFragmentInitializer();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

protected:
	FMassEntityQuery EntityQuery;
	UWorld* World = nullptr;
};
```

`Source/ProjectM/Public/MassGenericUpdateISMVertexAnimationProcessor.h`:

```h
// Mostly copied from CitySample MassCrowdUpdateISMVertexAnimationProcessor.h

#pragma once

#include "MassUpdateISMProcessor.h"

#include "MassGenericUpdateISMVertexAnimationProcessor.generated.h"

struct FMassInstancedStaticMeshInfo;
struct FGenericAnimationFragment;

UCLASS()
class PROJECTM_API UMassGenericUpdateISMVertexAnimationProcessor : public UMassUpdateISMProcessor
{
	GENERATED_BODY()
public:
	UMassGenericUpdateISMVertexAnimationProcessor();

	static void UpdateISMVertexAnimation(FMassInstancedStaticMeshInfo& ISMInfo, FGenericAnimationFragment& AnimationData, const float LODSignificance, const float PrevLODSignificance, const int32 NumFloatsToPad = 0);

protected:

	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;

	/**
	 * Execution method for this processor
	 * @param EntitySubsystem is the system to execute the lambdas on each entity chunk
	 * @param Context is the execution context to be passed when executing the lambdas */
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;
};

```

`Source/ProjectM/Public/MassGotTargetEvaluator.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "MassStateTreeTypes.h"
#include "MassEntityTypes.h"
#include "MassEnemyTargetFinderProcessor.h"
#include "MassGotTargetEvaluator.generated.h"

USTRUCT()
struct PROJECTM_API FMassGotTargetEvaluatorInstanceData
{
	GENERATED_BODY()

	UPROPERTY(VisibleAnywhere, Category = Output)
	bool bGotTarget = false;

	UPROPERTY(VisibleAnywhere, Category = Output)
	FMassEntityHandle TargetEntity;
};

USTRUCT(meta = (DisplayName = "Mass GotTarget Eval"))
struct PROJECTM_API FMassGotTargetEvaluator : public FMassStateTreeEvaluatorBase
{
	GENERATED_BODY()

protected:
	virtual bool Link(FStateTreeLinker& Linker) override;
	virtual const UStruct* GetInstanceDataType() const override { return FMassGotTargetEvaluatorInstanceData::StaticStruct(); }
	virtual void Evaluate(FStateTreeExecutionContext& Context, const EStateTreeEvaluationType EvalType, const float DeltaTime) const override;

	TStateTreeExternalDataHandle<FTargetEntityFragment> TargetEntityFragmentHandle;

	TStateTreeInstanceDataPropertyHandle<bool> GotTargetHandle;
	TStateTreeInstanceDataPropertyHandle<FMassEntityHandle> TargetEntityHandle;
};

```

`Source/ProjectM/Public/MassIdleForDurationTask.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "MassStateTreeTypes.h"
#include "MassIdleForDurationTask.generated.h"

class UMassSignalSubsystem;

USTRUCT()
struct PROJECTM_API FMassIdleForDurationTaskInstanceData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = Parameter)
	float Duration = 0.0f;

	/** Accumulated time used to stop task if duration is set */
	UPROPERTY()
	float Time = 0.f;
};

USTRUCT(meta = (DisplayName = "Idle for Duration"))
struct PROJECTM_API FMassIdleForDurationTask : public FMassStateTreeTaskBase
{
	GENERATED_BODY()

protected:
	virtual bool Link(FStateTreeLinker& Linker) override;
	virtual const UStruct* GetInstanceDataType() const override { return FMassIdleForDurationTaskInstanceData::StaticStruct(); }
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const override;
	virtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;

	TStateTreeExternalDataHandle<UMassSignalSubsystem> MassSignalSubsystemHandle;

	TStateTreeInstanceDataPropertyHandle<float> DurationHandle;
	TStateTreeInstanceDataPropertyHandle<float> TimeHandle;
};

```

`Source/ProjectM/Public/MassLookAtViaMoveTargetTask.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "MassEntityTypes.h"
#include "MassStateTreeTypes.h"
#include "MassNavigationFragments.h"
#include "MassCommonFragments.h"
#include "MassMoveToCommandProcessor.h"
#include "MassLookAtViaMoveTargetTask.generated.h"

struct FMassMoveTargetFragment;
struct FMassStashedMoveTargetFragment;
struct FMassMoveForwardCompleteSignalFragment;
class UMassEntitySubsystem;

/** Returns true if stashed move target. */
bool StashCurrentMoveTargetIfNeeded(const FMassMoveTargetFragment& MoveTargetFragment, FMassStashedMoveTargetFragment& StashedMoveTargetFragment, const UWorld& World, const UMassEntitySubsystem& EntitySubsystem, const FMassEntityHandle& Entity, const FMassExecutionContext& Context, const bool AddHasStashTag = true);

USTRUCT()
struct PROJECTM_API FMassLookAtViaMoveTargetTaskInstanceData
{
	GENERATED_BODY()

		UPROPERTY(EditAnywhere, Category = Input)
		FMassEntityHandle TargetEntity;
};

USTRUCT(meta = (DisplayName = "Mass LookAtViaMoveTarget Task"))
struct PROJECTM_API FMassLookAtViaMoveTargetTask : public FMassStateTreeTaskBase
{
	GENERATED_BODY()

protected:
	virtual bool Link(FStateTreeLinker& Linker) override;
	virtual const UStruct* GetInstanceDataType() const override { return FMassLookAtViaMoveTargetTaskInstanceData::StaticStruct(); }
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const EStateTreeStateChangeType ChangeType, const FStateTreeTransitionResult& Transition) const override;
	virtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;

	TStateTreeExternalDataHandle<FMassMoveTargetFragment> MoveTargetHandle;
	TStateTreeExternalDataHandle<FMassStashedMoveTargetFragment> StashedMoveTargetHandle;
	TStateTreeExternalDataHandle<FTransformFragment> TransformHandle;
	TStateTreeExternalDataHandle<FMassMoveForwardCompleteSignalFragment> MoveForwardCompleteSignalHandle;

	TStateTreeInstanceDataPropertyHandle<FMassEntityHandle> TargetEntityHandle;
};

```

`Source/ProjectM/Public/MassMoveTargetForwardCompleteProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassEntityTraitBase.h"
#include "MassEntityTemplateRegistry.h"
#include "MassEntityTypes.h"
#include "MassMoveTargetForwardCompleteProcessor.generated.h"

class UMassSignalSubsystem;

UENUM()
enum class EMassMoveForwardCompleteSignalType : uint8
{
	NewStateTreeTask,
	TrackSoundComplete,
};

USTRUCT()
struct PROJECTM_API FMassMoveForwardCompleteSignalFragment : public FMassFragment
{
	GENERATED_BODY()

	EMassMoveForwardCompleteSignalType SignalType = EMassMoveForwardCompleteSignalType::NewStateTreeTask;
};

USTRUCT()
struct FMassNeedsMoveTargetForwardCompleteSignalTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class PROJECTM_API UMassMoveTargetForwardCompleteProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassMoveTargetForwardCompleteProcessor();

protected:
	virtual void Initialize(UObject& Owner) override;
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	UPROPERTY(Transient)
	UMassSignalSubsystem* SignalSubsystem;

private:
	FMassEntityQuery EntityQuery;

	// Frame buffer, it gets reset every frame.
	TArray<FMassEntityHandle> TransientEntitiesToSignal;
};

```

`Source/ProjectM/Public/MassMoveToCommandProcessor.h`:

```h
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassNavigationFragments.h"
#include "MassEntityTraitBase.h"
#include <MilitaryStructureSubsystem.h>

#include "MassMoveToCommandProcessor.generated.h"

class UMassMoveToCommandSubsystem;

bool IsSquadMember(const UMilitaryUnit* MilitaryUnit);

USTRUCT()
struct FMassHasStashedMoveTargetTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassCommandableTag : public FMassTag
{
	GENERATED_BODY()
};

// This fragment should not be shared across entities because movement speed may get affected by damage in the future.
USTRUCT()
struct PROJECTM_API FMassCommandableMovementSpeedFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(Category = "", EditAnywhere)
	float MovementSpeed;
};

USTRUCT()
struct PROJECTM_API FNavMeshParamsFragment : public FMassSharedFragment
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Movement")
	float NavMeshRadius = 50.f;
};

UCLASS(meta = (DisplayName = "Commandable"))
class PROJECTM_API UMassCommandableTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(Category = "", EditAnywhere)
	float MovementSpeed = 500.f;

	UPROPERTY(Category = "", EditAnywhere)
	FNavMeshParamsFragment NavMeshParams;
};

USTRUCT()
struct PROJECTM_API FMassStashedMoveTargetFragment : public FMassMoveTargetFragment
{
	GENERATED_BODY()
};

struct FNavigationAction
{
	FNavigationAction(const FVector TargetLocation, const FVector Forward, const EMassMovementAction Action = EMassMovementAction::Move)
		: TargetLocation(TargetLocation), Forward(Forward), Action(Action)
	{
	}
	FVector TargetLocation;
	FVector Forward;
	EMassMovementAction Action;
};

struct FNavigationActionList
{
	FNavigationActionList(const TArray<FNavigationAction> Actions)
		: Actions(Actions)
	{
	}
	FNavigationActionList() = default;
	TArray<FNavigationAction> Actions;
};

typedef TSharedPtr<FNavigationActionList, ESPMode::ThreadSafe> FNavActionListSharedPtr;

USTRUCT()
struct PROJECTM_API FMassNavMeshMoveFragment : public FMassFragment
{
	GENERATED_BODY()

	bool IsSquadMember()
	{
		return SquadMemberIndex >= 0;
	}

	void Reset()
	{
		ActionList = MakeShareable(new FNavigationActionList());
		CurrentActionIndex = 0;
		ActionsRemaining = -1;
		SquadMemberIndex = -1;
		bIsWaitingOnSquadMates = false;
	}

	FNavActionListSharedPtr ActionList;
	int32 CurrentActionIndex = 0; // This gets incremented when completing the next action AND all squad members have completed that action as well.
	int32 ActionsRemaining = -1; // This gets decremented when completing the next action BEFORE all squad members have completed that action as well.
	int8 SquadMemberIndex = -1;
	bool bIsWaitingOnSquadMates = false;
};

UCLASS()
class PROJECTM_API UMassMoveToCommandProcessor : public UMassProcessor
{
	GENERATED_BODY()

	UMassMoveToCommandProcessor();
public:
	static FVector2D GetSoldierOffsetFromSquadLeaderUnscaledMeters(const int8 SquadMemberIndex, const FVector& SquadLeaderForward);
	static FVector GetSoldierOffsetFromSquadLeader(const int8 SquadMemberIndex, const FVector& SquadLeaderLocation, const FVector& SquadLeaderForward);

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	TObjectPtr<UMassMoveToCommandSubsystem> MoveToCommandSubsystem;
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassMoveToCommandSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "MassEntityTypes.h"
#include "Subsystems/WorldSubsystem.h"
#include "MassMoveToCommandSubsystem.generated.h"

class UMassAgentSubsystem;
class UMassSignalSubsystem;
class UMilitaryUnit;

struct FMoveToCommand
{
	FMoveToCommand(const UMilitaryUnit* MilitaryUnit, FVector Target, bool bIsOnTeam1)
		: MilitaryUnit(MilitaryUnit), Target(Target), bIsOnTeam1(bIsOnTeam1)
	{
	}
	FMoveToCommand() = default;
	const UMilitaryUnit* MilitaryUnit;
	FVector Target;
	bool bIsOnTeam1;
};

UCLASS()
class PROJECTM_API UMassMoveToCommandSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

public:
	void EnqueueMoveToCommand(const UMilitaryUnit* MilitaryUnit, const FVector Target, const bool bIsOnTeam1);
	bool DequeueMoveToCommand(FMoveToCommand& OutMoveToCommand);

protected:
	TQueue<FMoveToCommand> MoveToCommandQueue;
};

```

`Source/ProjectM/Public/MassNavMeshMoveProcessor.h`:

```h
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassNavMeshMoveProcessor.generated.h"

USTRUCT()
struct FMassNeedsNavMeshMoveTag : public FMassTag
{
	GENERATED_BODY()
};


UCLASS()
class PROJECTM_API UMassNavMeshMoveProcessor : public UMassProcessor
{
	GENERATED_BODY()

		UMassNavMeshMoveProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassOrderedSpawnLocationProcessor.h`:

```h
// Adapted from MassSpawnLocationProcessor.h, just without randomness.

#pragma once 

#include "MassProcessor.h"
#include "MassOrderedSpawnLocationProcessor.generated.h"

UCLASS()
class PROJECTM_API UMassOrderedSpawnLocationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassOrderedSpawnLocationProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassPlayerSubsystem.h`:

```h
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.

#pragma once

#include "MassEntityTypes.h"
#include "Subsystems/WorldSubsystem.h"
#include "MassPlayerSubsystem.generated.h"

class UMassAgentSubsystem;

UCLASS()
class PROJECTM_API UMassPlayerSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

public:
	AActor* GetActorForEntity(const FMassEntityHandle Entity);

protected:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

	UPROPERTY()
	UMassAgentSubsystem* AgentSubsystem;

	UPROPERTY()
	TMap<FMassEntityHandle, AActor*> EntityToActorMap;
};

```

`Source/ProjectM/Public/MassProjectileDamageProcessor.h`:

```h
#pragma once

#include "MassProcessor.h"
#include "MassEntityTraitBase.h"
#include "MassEntityTemplateRegistry.h"
#include "MassMovementFragments.h"
#include "MassEntityTypes.h"
#include "MassNavigationSubsystem.h"

#include "MassProjectileDamageProcessor.generated.h"

class UMassNavigationSubsystem;
class UMassSignalSubsystem;

USTRUCT()
struct FMassSoldierIsDyingTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassProjectileWithDamageTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct FMassProjectileDamagableSoldierTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct PROJECTM_API FMassPreviousLocationFragment : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = "")
	FVector Location = FVector::ZeroVector;
};

USTRUCT()
struct PROJECTM_API FMassHealthFragment : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = "")
	int16 Value = 100;
};

USTRUCT()
struct PROJECTM_API FProjectileDamageFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "")
	int16 DamagePerHit = 10;
	
	UPROPERTY(EditAnywhere, Category = "")
	float Caliber;

	UPROPERTY(EditAnywhere, Category = "")
	int16 ExplosionEntityConfigIndex = -1;

	UPROPERTY(EditAnywhere, Category = "")
	uint32 SplashDamageRadius;
};

USTRUCT()
struct PROJECTM_API FProjectileDamagableFragment : public FMassFragment
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "")
	float MinCaliberForDamage;
};

USTRUCT()
struct PROJECTM_API FMinZParameters : public FMassSharedFragment
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Movement")
	float Value = 0.f;
};

USTRUCT()
struct PROJECTM_API FDebugParameters : public FMassSharedFragment
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Debug")
	bool DrawLineTraces = false;
};

// TODO: Consider moving params that are shared across all instances of a projectile type into a new UDataAsset subclass and having this trait just set on fragment an index into an array of these UDataAsset instances.
UCLASS(meta = (DisplayName = "ProjectileWithDamage"))
class PROJECTM_API UMassProjectileWithDamageTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(Category = "Damage", EditAnywhere)
	int16 DamagePerHit = 10;

	UPROPERTY(Category = "Damage", EditAnywhere)
	float Caliber = 5.0f;

	/** 0 means no splash damage. */
	UPROPERTY(Category = "Damage", EditAnywhere)
	uint32 SplashDamageRadius = 0;

	FMassMovementParameters Movement;

	UPROPERTY(Category = "Movement", EditAnywhere)
	float GravityMagnitude = 0.f;

	/** Minimum Z value for projectiles at which they get destroyed */
	UPROPERTY(Category = "Movement", EditAnywhere)
	FMinZParameters MinZ;

	UPROPERTY(Category = "Effects", EditAnywhere)
	UMassEntityConfigAsset* ExplosionEntityConfig = nullptr;

	UPROPERTY(Category = "Debug", EditAnywhere)
	FDebugParameters DebugParameters;
};

UCLASS(meta = (DisplayName = "ProjectileDamagable"))
class PROJECTM_API UMassProjectileDamagableTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(Category = "", EditAnywhere)
	bool bIsSoldier = true;

	UPROPERTY(Category = "", EditAnywhere)
	float MinCaliberForDamage = 5.0f;
};

UCLASS()
class PROJECTM_API UMassProjectileDamageProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassProjectileDamageProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	TObjectPtr<UMassSignalSubsystem> SignalSubsystem;

private:
	TObjectPtr<UMassNavigationSubsystem> NavigationSubsystem;
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassProjectileRemoverProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassProjectileRemoverProcessor.generated.h"

/**
 *
 */
UCLASS()
class PROJECTM_API UMassProjectileRemoverProcessor : public UMassProcessor
{
	GENERATED_BODY()
public:
	UMassProjectileRemoverProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassRifle.h`:

```h
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "MassEntityConfigAsset.h"
#include "MassRifle.generated.h"

UCLASS()
class PROJECTM_API AMassRifle : public AActor
{
	GENERATED_BODY()

public:
	AMassRifle();

protected:
	UFUNCTION(BlueprintCallable)
	void SpawnProjectile(const FTransform SpawnTransform, const bool bIsPlayerTeam1) const;

	UPROPERTY(EditAnywhere, Category = "Mass")
	FMassEntityConfig ProjectileEntityConfig;
};

```

`Source/ProjectM/Public/MassSimpleUpdateISMProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassUpdateISMProcessor.h"
#include "MassEntityTypes.h"
#include "MassSimpleUpdateISMProcessor.generated.h"

USTRUCT()
struct FMassSimpleUpdateISMTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS(meta = (DisplayName = "SimpleUpdateISM"))
class PROJECTM_API UMassSimpleUpdateISMTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;
};

// We need this processor to update ISMs because UMassUpdateISMProcessor is not auto registered and if you try to auto register it, City Sample will crash because it already has its own UMassUpdateISMProcessor replacement (UMassProcessor_CrowdVisualizationCustomData).
UCLASS()
class PROJECTM_API UMassSimpleUpdateISMProcessor : public UMassUpdateISMProcessor
{
	GENERATED_BODY()

	UMassSimpleUpdateISMProcessor();
protected:
	/** Configure the owned FMassEntityQuery instances to express processor's requirements */
	virtual void ConfigureQueries() override;
};

```

`Source/ProjectM/Public/MassSoldierDyingEvaluator.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "MassStateTreeTypes.h"
#include "MassEntityTypes.h"
#include "MassEnemyTargetFinderProcessor.h"

#include "MassSoldierDyingEvaluator.generated.h"

USTRUCT()
struct PROJECTM_API FMassSoldierDyingEvaluatorInstanceData
{
	GENERATED_BODY()

	UPROPERTY(VisibleAnywhere, Category = Output)
	bool bIsDying = false;
};

USTRUCT(meta = (DisplayName = "Mass SoldierDying Eval"))
struct PROJECTM_API FMassSoldierDyingEvaluator : public FMassStateTreeEvaluatorBase
{
	GENERATED_BODY()

protected:
	virtual bool Link(FStateTreeLinker& Linker) override;
	virtual const UStruct* GetInstanceDataType() const override { return FMassSoldierDyingEvaluatorInstanceData::StaticStruct(); }
	virtual void Evaluate(FStateTreeExecutionContext& Context, const EStateTreeEvaluationType EvalType, const float DeltaTime) const override;

	TStateTreeInstanceDataPropertyHandle<bool> IsDyingHandle;
};

```

`Source/ProjectM/Public/MassSoundPerceptionSubsystem.h`:

```h
#pragma once

#include "MassEntityTypes.h"
#include "HierarchicalHashGrid2D.h"
#include "Subsystems/WorldSubsystem.h"

#include "MassSoundPerceptionSubsystem.generated.h"

// TODO: values of 2,4 here may not be optimal for performance.
typedef THierarchicalHashGrid2D<2, 4> FSoundPerceptionHashGrid2D;	// 2 levels of hierarchy, 4 ratio between levels

struct FMassSoundPerceptionItemMetaData
{
	FMassSoundPerceptionItemMetaData(uint8 InTicksLeftTilDestruction, const FSoundPerceptionHashGrid2D::FCellLocation InCellLocation, const FVector InSoundSource)
		: TicksLeftTilDestruction(InTicksLeftTilDestruction), CellLocation(InCellLocation), SoundSource(InSoundSource) {}
	uint8 TicksLeftTilDestruction;
	const FSoundPerceptionHashGrid2D::FCellLocation CellLocation;
	const FVector SoundSource;
};

UCLASS()
class PROJECTM_API UMassSoundPerceptionSubsystem : public UTickableWorldSubsystem
{
	GENERATED_BODY()

public:
	UMassSoundPerceptionSubsystem();

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	void AddSoundPerception(const FVector Location, const bool& bIsSourceFromTeam1, const bool SkipDebugDraw = false);
	void AddSoundPerception(const FVector Location); // Use this overload for sounds that are not specific to a team.
	bool GetSoundsNearLocation(const FVector& Location, TArray<FVector>& OutCloseSounds, const bool bFilterToTeam1);

protected:
	virtual void Tick(float DeltaTime) override;
	virtual TStatId GetStatId() const override;

	FSoundPerceptionHashGrid2D SoundPerceptionGridForTeam1;
	FSoundPerceptionHashGrid2D SoundPerceptionGridForTeam2;
	TMap<uint32, FMassSoundPerceptionItemMetaData> IdsToMetaDataForTeam1;
	TMap<uint32, FMassSoundPerceptionItemMetaData> IdsToMetaDataForTeam2;

	static constexpr int FramesUntilSoundPerceptionDestruction = 2; // We don't use 1 to avoid having to deal with ordering of various events in single game tick.
};

```

`Source/ProjectM/Public/MassSwapEntityOnDestructionTrait.h`:

```h
#pragma once

#include "MassEntityTraitBase.h"
#include "MassObserverProcessor.h"
#include "MassEntityConfigAsset.h"

#include "MassSwapEntityOnDestructionTrait.generated.h"

USTRUCT()
struct PROJECTM_API FMassSwapEntityOnDestructionFragment : public FMassFragment
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, Category = "")
	int16 SwappedEntityConfigIndex = -1;
};

UCLASS(meta = (DisplayName = "SwapEntityOnDestruction"))
class PROJECTM_API UMassSwapEntityOnDestructionTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(EditAnywhere)
	UMassEntityConfigAsset* SwappedEntityConfig = nullptr;
};

UCLASS()
class PROJECTM_API UMassSwapEntityOnDestructionProcessor : public UMassObserverProcessor
{
	GENERATED_BODY()

	UMassSwapEntityOnDestructionProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassTargetFinderSubsystem.h`:

```h
#pragma once

#include "MassEntityTypes.h"
#include "HierarchicalHashGrid2D.h"
#include "Subsystems/WorldSubsystem.h"

#include "MassTargetFinderSubsystem.generated.h"

struct FMassTargetGridItem
{
	FMassTargetGridItem(FMassEntityHandle InEntity, bool bInIsOnTeam1,float InMinCaliberForDamage, bool bInIsSoldier) 
		: Entity(InEntity), bIsOnTeam1(bInIsOnTeam1), MinCaliberForDamage(InMinCaliberForDamage), bIsSoldier(bInIsSoldier)
	{
	}

	FMassTargetGridItem() = default;

	bool operator==(const FMassTargetGridItem& Other) const
	{
		return Entity == Other.Entity;
	}

	FMassEntityHandle Entity;
	bool bIsOnTeam1;
	float MinCaliberForDamage;
	bool bIsSoldier;
};

// We cannot store this data in FMassTargetGridItem because the grid gets updated only when entities move to a new cell.
struct FMassTargetGridItemDynamicData
{
	FMassTargetGridItemDynamicData(FVector Location, FCapsule Capsule)
		: Location(Location), Capsule(Capsule)
	{
	}

	FMassTargetGridItemDynamicData() = default;

	FVector Location;
	FCapsule Capsule;
};

// TODO: Constants here may not be optimal for performance.
typedef THierarchicalHashGrid2D<2, 2, FMassTargetGridItem> FTargetHashGrid2D;

UCLASS()
class PROJECTM_API UMassTargetFinderSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

public:
	UMassTargetFinderSubsystem();

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	const FTargetHashGrid2D& GetTargetGrid() const { return TargetGrid; }
	FTargetHashGrid2D& GetTargetGridMutable() { return TargetGrid; }

	const TMap<FMassEntityHandle, FMassTargetGridItemDynamicData>& GetTargetDynamicData() const { return TargetDynamicData; }
	TMap<FMassEntityHandle, FMassTargetGridItemDynamicData>& GetTargetDynamicDataMutable() { return TargetDynamicData; }

protected:
	FTargetHashGrid2D TargetGrid;
	TMap<FMassEntityHandle, FMassTargetGridItemDynamicData> TargetDynamicData;
};

```

`Source/ProjectM/Public/MassTargetGridProcessors.h`:

```h
#pragma once

#include "MassProcessor.h"
#include "MassObserverProcessor.h"
#include "MassTargetGridProcessors.generated.h"

class UMassTargetFinderSubsystem;

USTRUCT()
struct PROJECTM_API FMassInTargetGridTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct PROJECTM_API FMassTargetGridCellLocationFragment : public FMassFragment
{
	GENERATED_BODY()
	FTargetHashGrid2D::FCellLocation CellLoc;
};

/** Processor to update target grid. Mosty a copy of UMassNavigationObstacleGridProcessor. */
UCLASS()
class PROJECTM_API UMassTargetGridProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassTargetGridProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	TObjectPtr<UMassTargetFinderSubsystem> TargetFinderSubsystem;
	FMassEntityQuery AddToGridEntityQuery;
	FMassEntityQuery UpdateGridEntityQuery;
};

/** Deinitializer processor to remove targets from the target grid. Mostly a copy of UMassNavigationObstacleRemoverProcessor. */
UCLASS()
class PROJECTM_API UMassTargetRemoverProcessor : public UMassObserverProcessor
{
	GENERATED_BODY()

	UMassTargetRemoverProcessor();
	TObjectPtr<UMassTargetFinderSubsystem> TargetFinderSubsystem;

protected:
	virtual void ConfigureQueries() override;
	virtual void Initialize(UObject& Owner) override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassTrackTargetProcessor.h`:

```h
// Copyright (c) 2022 Leroy Technologies. Licensed under MIT License.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassTrackTargetProcessor.generated.h"

struct FMassMoveTargetFragment;
struct FTransformFragment;
struct FTargetEntityFragment;
class UMassEntitySubsystem;

USTRUCT()
struct FMassTrackTargetTag : public FMassTag
{
	GENERATED_BODY()
};

UCLASS()
class PROJECTM_API UMassTrackTargetProcessor : public UMassProcessor
{
	GENERATED_BODY()

	UMassTrackTargetProcessor();

protected:

	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

	void UpdateLookAtTrackedEntity(const UMassEntitySubsystem& EntitySubsystem, const FTransformFragment& TransformFragment, const FTargetEntityFragment& TargetEntityFragment, FMassMoveTargetFragment& MoveTargetFragment) const;

	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassTrackedVehicleOrientationProcessor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "MassTrackedVehicleOrientationProcessor.generated.h"

bool IsTransformFacingDirection(const FTransform& Transform, const FVector& TargetDirection, float* OutCurrentHeadingRadians = nullptr, float* OutDesiredHeadingRadians = nullptr, float* OutDeltaAngleRadians = nullptr, float* OutAbsDeltaAngleRadians = nullptr);

USTRUCT()
struct FMassTrackedVehicleOrientationTag : public FMassTag
{
	GENERATED_BODY()
};

USTRUCT()
struct PROJECTM_API FMassTrackedVehicleOrientationParameters : public FMassSharedFragment
{
	GENERATED_BODY()

	/** Measured in degrees per second. */
	UPROPERTY(EditAnywhere, Category = "Orientation")
	float TurningSpeed;
};

UCLASS(meta = (DisplayName = "Tracked Vehicle Orientation"))
class PROJECTM_API UMassTrackedVehicleOrientationTrait : public UMassEntityTraitBase
{
	GENERATED_BODY()

protected:
	virtual void BuildTemplate(FMassEntityTemplateBuildContext& BuildContext, UWorld& World) const override;

	UPROPERTY(EditAnywhere, Category = "")
	FMassTrackedVehicleOrientationParameters Orientation;
};

/** Processor for turning trached vehicles towards their MoveTarget at a constant turning speed. The one used for soldiers UMassSmoothOrientationProcessor cannot be used because it does not turn entity at constant speed. */
UCLASS()
class PROJECTM_API UMassTrackedVehicleOrientationProcessor : public UMassProcessor
{
	GENERATED_BODY()

public:
	UMassTrackedVehicleOrientationProcessor();

protected:
	virtual void ConfigureQueries() override;
	virtual void Execute(UMassEntitySubsystem& EntitySubsystem, FMassExecutionContext& Context) override;

private:
	FMassEntityQuery EntityQuery;
};

```

`Source/ProjectM/Public/MassVisualEffectsSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "MassVisualEffectsSubsystem.generated.h"

/**
 * 
 */
UCLASS()
class PROJECTM_API UMassVisualEffectsSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	TArray<UMassEntityConfigAsset*> MassEntityConfigAssets;

public:
	int16 FindOrAddEntityConfig(UMassEntityConfigAsset* ExplosionEntityConfig);

	void SpawnEntity(const int16 EntityConfigIndex, const FVector& Location);
	void SpawnEntity(const int16 EntityConfigIndex, const FTransform& Transform);
};

```

`Source/ProjectM/Public/MilitaryStructureSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "MassEntityTypes.h"
#include "MilitaryStructureSubsystem.generated.h"

struct FMilitaryUnitCounts
{
	int32 SoldierCount = 0;
	int32 VehicleCount = 0;
	int32 SquadCount = 0;
};

constexpr int32 GSquadUnitDepth = 6; // TODO: calculate dynamically?
constexpr int32 GNumSoldiersInSquad = 9;
constexpr float GSquadSpacingScalingFactor = 0.25f;

inline const FVector2D GSquadMemberOffsetsMeters[] = {
	FVector2D(0.f, 0.f), // SL
	FVector2D(0.f, 30.f), // FT1,L
	FVector2D(-20.f, 15.f), // FT1,S1
	FVector2D(-10.f, 20.f), // FT1,S2
	FVector2D(10.f, 20.f), // FT1,S3
	FVector2D(0.f, -20.f), // FT2,L
	FVector2D(-10.f, -30.f), // FT2,S1
	FVector2D(10.f, -30.f), // FT2,S2
	FVector2D(20.f, -40.f), // FT2,S3
};

UCLASS(BlueprintType)
class PROJECTM_API UTreeViewItem : public UObject
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText Text;
};

USTRUCT(BlueprintType)
struct PROJECTM_API FSoldier
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText Name;
};

UCLASS(BlueprintType)
class PROJECTM_API UMilitaryUnit : public UObject
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FText Name;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<UMilitaryUnit*> SubUnits;

	UPROPERTY(BlueprintReadOnly)
	uint8 Depth;

	UPROPERTY(BlueprintReadOnly)
	int32 MassEntityIndex;

	UPROPERTY(BlueprintReadOnly)
	int32 MassEntitySerialNumber;

	UPROPERTY(BlueprintReadOnly)
	UMilitaryUnit* Parent;

	UPROPERTY(BlueprintReadOnly)
	UMilitaryUnit* Commander;

	// TODO: make private and expose getter
	UPROPERTY(BlueprintReadOnly)
	bool bIsSoldier = false;

	// TODO: make private and expose getter
	UPROPERTY(BlueprintReadOnly)
	bool bIsVehicle = false;

	// TODO: make private and expose getter
	UPROPERTY(BlueprintReadOnly)
	bool bIsCommander = false;

	// TODO: make private and expose getter
	UPROPERTY(BlueprintReadOnly)
	bool bIsPlayer = false;

	int8 SquadMemberIndex = -1; // Index into GSquadMemberOffsetsMeters
	int8 SquadIndex = -1;
	UMilitaryUnit* SquadMilitaryUnit;

	void RemoveFromParent();
	FMassEntityHandle GetMassEntityHandle() const;
	bool IsChildOfUnit(const UMilitaryUnit* ParentUnit);
	bool IsSquadLeader() const;

	UFUNCTION(BlueprintCallable)
	bool IsLeafUnit() const;
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FCompletedAssigningEntitiesToMilitaryUnitsEvent);

UCLASS(BlueprintType)
class PROJECTM_API UMilitaryStructureSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

private:
	bool bDidCompleteAssigningEntitiesToMilitaryUnitsForTeam1;
	bool bDidCompleteAssigningEntitiesToMilitaryUnitsForTeam2;

protected:
	void PromoteNewLeaderIfNeeded(UMilitaryUnit* SoldierMilitaryUnitToDestroy);

	UPROPERTY()
	TMap<FMassEntityHandle, UMilitaryUnit*> EntityToUnitMap;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	UMilitaryUnit* Team1RootUnit;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	UMilitaryUnit* Team2RootUnit;

public:
	// USubsystem BEGIN
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	// USubsystem END

	FMilitaryUnitCounts CreateMilitaryUnit(uint8 MilitaryUnitIndex, bool bIsTeam1);

	void BindUnitToMassEntity(UMilitaryUnit* MilitaryUnit, FMassEntityHandle Entity);
	void DestroyEntity(FMassEntityHandle Entity);

	UMilitaryUnit* GetUnitForEntity(const FMassEntityHandle Entity);
	UMilitaryUnit* GetRootUnitForTeam(const bool bIsTeam1);

	void DidCompleteAssigningEntitiesToMilitaryUnits(const bool bIsTeam1);

	FCompletedAssigningEntitiesToMilitaryUnitsEvent OnCompletedAssigningEntitiesToMilitaryUnitsEvent;
};

```

`Source/ProjectM/Public/MilitaryUnitMassSpawner.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "MassSpawner.h"

#include "MilitaryUnitMassSpawner.generated.h"

inline bool AMilitaryUnitMassSpawner_SpawnSoldiersOnly = true;
inline FAutoConsoleVariableRef CVar_AMilitaryUnitMassSpawner_SpawnSoldiersOnly(TEXT("pm.AMilitaryUnitMassSpawner_SpawnSoldiersOnly"), AMilitaryUnitMassSpawner_SpawnSoldiersOnly, TEXT("AMilitaryUnitMassSpawner_SpawnSoldiersOnly"));

// Note that setting Count inherited from AMassSpawner gets ignored.
UCLASS()
class PROJECTM_API AMilitaryUnitMassSpawner : public AMassSpawner
{
	GENERATED_BODY()
	
protected:
	virtual void BeginPlay() override;

	UFUNCTION()
	void BeginAssignEntitiesToMilitaryUnits();

	void AssignEntitiesToMilitaryUnits(TArray<UMilitaryUnit*>& Squads, TArray<UMilitaryUnit*>& HigherCommandSoldiers);
	void AssignEntitiesToSquad(int32& SoldierIndex, UMilitaryUnit* MilitaryUnit, UMilitaryUnit* SquadMilitaryUnit, int32& SquadMemberIndex);
	void SafeBindSoldier(UMilitaryUnit* SoldierMilitaryUnit, const TArray<FMassEntityHandle>& SpawnedEntities, int32& EntityIndex);
	void DoMilitaryUnitSpawning();
	void OnMilitaryUnitSpawnDataGenerationFinished(TConstArrayView<FMassEntitySpawnDataGeneratorResult> Results, FMassSpawnDataGenerator* FinishedGenerator);

	UMilitaryStructureSubsystem* MilitaryStructureSubsystem;
	
	// Indices into AMassSpawner's AllSpawnedEntities.
	int32 AllSpawnedEntitiesSoldierIndex;
	int32 AllSpawnedEntitiesVehicleIndex;

	bool bDidSpawnVehiclesOnly = false;
	bool bDidSpawnSoldiersOnly = false;
	FMilitaryUnitCounts UnitCounts;

public:
	AMilitaryUnitMassSpawner();

	UPROPERTY(EditAnywhere)
	uint8 MilitaryUnitIndex = 0; // Index into MilitaryUnits in MilitaryStructureSubsystem.cpp; TODO: make this an enum

	UPROPERTY(EditAnywhere)
	bool bIsTeam1;

	UPROPERTY(EditAnywhere)
	bool bSpawnVehiclesOnly;
};

```

`Source/ProjectM/Public/ProjectM.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FProjectMModule : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Source/ProjectM/Public/ProjectMMapWidget.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "MilitaryStructureSubsystem.h"

#include "ProjectMMapWidget.generated.h"

class USceneCaptureComponent2D;
class UImage;

typedef TFunction< void(const FVector& /*EntityLocation*/, const bool& /*bIsOnTeam1*/, const bool& /*bIsPlayer*/, const FMassEntityHandle& /*Entity*/) > FMapDisplayableEntityFunction;

// Adapted from UCitySampleMapWidget.
UCLASS()
class PROJECTM_API UProjectMMapWidget : public UUserWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, meta = (BindWidget))
	class UCanvasPanel* CanvasPanel;

	UPROPERTY(EditAnywhere, meta = (BindWidget))
	class UBorder* Border;

	UPROPERTY(EditAnywhere, meta = (BindWidget))
	class UTextBlock* TextBlock_Team1Count;

	UPROPERTY(EditAnywhere, meta = (BindWidget))
	class UTextBlock* TextBlock_Team2Count;

	UFUNCTION(BlueprintCallable)
	void SetSelectedUnit(UMilitaryUnit* Unit);

	UFUNCTION(BlueprintCallable)
	void OnHide();

	UFUNCTION(BlueprintImplementableEvent)
	void BP_OnSoldierButtonClicked(UMilitaryUnit* Unit);

	virtual void NativeOnInitialized() override;

	UPROPERTY(Transient, VisibleAnywhere)
	int32 CachedTeam1AliveSoldierCount;
	
	UPROPERTY(Transient, VisibleAnywhere)
	int32 CachedTeam2AliveSoldierCount;

protected:
	virtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override;

	UFUNCTION(BlueprintCallable)
	class UCanvasPanel* GetCanvasPanel() const;

	UFUNCTION(BlueprintCallable)
	class UBorder* GetBorder() const;

	UFUNCTION(BlueprintCallable)
	FVector MapPositionToWorldPosition(const FVector2D& MapPosition) const;

	/** The UImage widget whose material is used when setting the scene render target as a texture parameter. */
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget), Category = "Map Widget")
	UImage* MapImage;

	/** Name of the texture parameter on the image material to be set to the scene render target texture. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Map Widget")
	FName MapTextureParameterName = FName(TEXT("MapTexture")); // TODO: For some reason this variable is not getting set with value specified in Blueprint.

private:
	FVector2D WorldPositionToMapPosition(const FVector& WorldLocation);
	void InitializeMapViewProjectionMatrix(USceneCaptureComponent2D* const SceneCapture2D);
	void CreateMapButtons();
	void UpdateMapButtons();
	class UButton* CreateButton(const bool& bIsSolder);
	void UpdateButton(class UButton* Button, const FVector2D& Position, UMilitaryUnit* Unit, const bool& bIsOnTeam1, const bool& bIsPlayer);
	void ForEachMapDisplayableEntity(const FMapDisplayableEntityFunction& EntityExecuteFunction);
	void UpdateSoldierCountLabels();

	/** Rect representing render target (map) space. */
	FIntRect MapRect;

	/** ViewProjection matrix used to project from world space to render target (map) space. */
	UPROPERTY(Transient, VisibleAnywhere, Category = "Map Widget|Transient")
	FMatrix MapViewProjectionMatrix;

	bool bCreatedButtons = false;
	UMilitaryUnit* SelectedUnit = nullptr;
	TMap<UButton*, UMilitaryUnit*> ButtonToMilitaryUnitMap;
	TMap<UMilitaryUnit*, UButton*> MilitaryUnitToButtonMap;
	UMilitaryStructureSubsystem* MilitaryStructureSubsystem;
};

// Static helper methods for Blueprints.
UCLASS()
class PROJECTM_API UProjectMMapWidgetLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable)
	static void RecursivelyExpandTreeViewUnitParents(class UTreeView* TreeView, UMilitaryUnit* Unit);
};

```

`Source/ProjectM/Public/ProjectMWorldInfo.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Info.h"
#include "ProjectMWorldInfo.generated.h"

class UBoxComponent;
class USceneCaptureComponent2D;
class ADirectionalLight;
class AStaticMeshActor;
class APostProcessVolume;

/**
 * Actor for storing world data and whose bounds represent the world bounds. Adapted from ACitySampleWorldInfo.
 */
UCLASS(Blueprintable)
class PROJECTM_API AProjectMWorldInfo : public AInfo
{
	GENERATED_BODY()

public:
	AProjectMWorldInfo();

	//~ Begin AActor Interface
	virtual void BeginPlay() override;
	//~ End AActor Interface

	//////////////////////////////////////////////////////////////////////////
	// World Map

public:
	UFUNCTION(BlueprintPure, Category = "UI|World Map")
	UBoxComponent* GetWorldMapBounds() const
	{
		return WorldMapBoundingBox;
	}

	UFUNCTION(BlueprintPure, Category = "UI|World Map")
	USceneCaptureComponent2D* GetWorldMapSceneCapture() const
	{
		return WorldMapSceneCaptureComponent2D;
	}

protected:	
	/** Bounding box representing the world map bounds. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI|World Map")
	UBoxComponent* WorldMapBoundingBox;

	/** SceneCapture2D actor whose render target is used by the UI to represent the World Map. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI|World Map")
	USceneCaptureComponent2D* WorldMapSceneCaptureComponent2D;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI|World Map")
	int32 MapResolution;

private:
	void InitializeMapSceneCapture();
	void CalculateTopWorldView(FMatrix& OutProjectionMatrix, const FBox& WorldBox, uint32 ViewportWidth, uint32 ViewportHeight);

	//////////////////////////////////////////////////////////////////////////
	// Sun Rotation

public:
	/** Sets the sunlight settings using the angle of the directional light and sky dome. */
	UFUNCTION(BlueprintCallable, Category = "Sim|Sunlight")
	void InitializeSunlightSettings();

	UFUNCTION(BlueprintPure, Category = "Sim|Sunlight")
	float GetSunlightAngle() const
	{
		return SunlightYaw;
	}

	/** Sets the directional "sun" light and sky dome to match the given angle. */
	UFUNCTION(BlueprintCallable, Category = "Sim|Sunlight")
	void SetSunlightAngle(const float Angle);

	/** Resets the directional "sun" light and sky dome to match the initial angles. */
	UFUNCTION(BlueprintCallable, Category = "Sim|Sunlight")
	void ResetSunlightAngle();

protected:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Sim|Sunlight")
	TSoftObjectPtr<ADirectionalLight> SunLight;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Sim|Sunlight")
	TSoftObjectPtr<AStaticMeshActor> SkyDome;

private:
	/** Initial yaw set during InitializeSunlightSettings using the directional "sun" light. */
	UPROPERTY(Transient, VisibleAnywhere, Category = "Sim|Sunlight")
	float InitialSunlightYaw;
	
	/** The yaw of the "sun" light last set by SetSunlightAngle. */
	UPROPERTY(Transient, VisibleAnywhere, Category = "Sim|Sunlight")
	float SunlightYaw;

	/** Offset to align the sky dome "sun" with the sunlight direction. */
	UPROPERTY(Transient, VisibleAnywhere, Category = "Sim|Sunlight")
	float SkyDomeYawOffset;

	//////////////////////////////////////////////////////////////////////////
	// Post-Processing Filter

public:
	UFUNCTION(BlueprintPure, Category="Sim|Post-Processing Filter")
	float GetPostProcessingFilterBlendWeight() const;

	UFUNCTION(BlueprintCallable, Category="Sim|Post-Processing Filter")
	void SetPostProcessingFilterBlendWeight(const float BlendWeight);

protected:
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Sim|Post-Processing Filter")
	TSoftObjectPtr<APostProcessVolume> PostProcessingFilter;
};

```