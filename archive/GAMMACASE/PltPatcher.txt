Project Path: arc_GAMMACASE_PltPatcher_1d14fe91

Source Tree:

```txt
arc_GAMMACASE_PltPatcher_1d14fe91
├── LICENSE
├── README.md
├── plt_patcher.py
└── thunk_type_preserver.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 GAMMACASE

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# PLT Patcher
Plugin for IDA Pro that uses ida python to patch plt sections when IDA fails to do so automatically.

Only supports ``ELF64`` binaries, where ``ELF32`` support could be easily added I don't have any binary of that sort to test on.

Additionaly this repository has ``thunk_type_preserver.py`` plugin that force preserves guessed type for thunks around extern functions.

## Installation
To install plugins from this repository, press ``Code -> Download ZIP`` to download python plugins, then extract ``.py`` files to ``IDA Folder/plugins``. Start\Restart IDA instance, then you should be able to see ``Edit->Plugins->Patch Plt Section`` button.

For ``thunk_type_preserver.py`` you don't need to press anything it should run automatically on the background, additionaly you might see double decompilations (especially noticable on big functions) which is expected behaviour and have an instance lifespan (so you'd see that again once IDA is restarted).

## Use cases
* ``plt_patcher.py`` - if you get IDA warning at analyzing step ``Could not patch the PLT stub; unexpected PLT format or the file has been modified after linking!``, this should help to patch PLT section correctly. Binaries compiled with [mold](https://github.com/rui314/mold) linker will most likely produce this error.

* ``thunk_type_preserver.py`` - useful in pseudocode static analysis as otherwise when you traverse to these thunk functions their args type info would be wiped if extern function doesn't have any type info (i.e. c style extern).

## IDA Support
* Requires IDA Pro for idapython;
* Tested on ida 7.7 and 9.0, versions in between should also work just fine, previous versions are unsupported!
* ``thunk_type_preserver.py`` also requires hexrays plugin to be installed;

```

`plt_patcher.py`:

```py
# MIT License
# 
# Copyright (c) 2025 GAMMACASE
# https://github.com/GAMMACASE/PltPatcher

import idc
import idaapi
import idautils
import ida_segment

def get_dynamic_struct():
	if get_dynamic_struct.dyn_data is None:
		phoff = idaapi.get_qword(idaapi.inf_get_min_ea() + 0x20) + idaapi.inf_get_min_ea()
		phnum = idaapi.get_word(idaapi.inf_get_min_ea() + 0x38)
		phentsize = idaapi.get_word(idaapi.inf_get_min_ea() + 0x36)
		for i in range(phnum):
			p_type = idaapi.get_dword(phoff + phentsize * i)
			if p_type == 2: # PY_DYNAMIC
				dyn_addr = idaapi.get_qword(phoff + phentsize * i + 0x10)
				dyn_size = idaapi.get_qword(phoff + phentsize * i + 0x18)
				get_dynamic_struct.dyn_data = (dyn_addr, dyn_size)

	return get_dynamic_struct.dyn_data
get_dynamic_struct.dyn_data = None

def find_dynamic_entry(search_tag):
	dyn, dyn_size = get_dynamic_struct()
	for i in range(0, dyn_size, 16):
		tag = idaapi.get_qword(dyn + i)
		ptr = idaapi.get_qword(dyn + i + 8)

		if tag == 0 and ptr == 0:
			break
		
		if tag == search_tag:
			return ptr
	return None

def read_string(ea):
	return idaapi.get_strlit_contents(ea, -1, idaapi.STRTYPE_C).decode('utf-8')

def find_func_in_extern(name):
	seg = idaapi.get_segm_by_name("extern")

	if not seg:
		return None
	
	ea = seg.start_ea
	while ea < seg.end_ea:
		if idc.get_func_name(ea) == name:
			return ea
		ea = idc.next_head(ea)
	
	return None

def add_extern_entry(name):
	seg = idaapi.get_segm_by_name("extern")
	
	if not seg:
		return None

	target_ea = seg.end_ea
	idaapi.set_segm_end(seg.start_ea, seg.end_ea + 8, ida_segment.SEGMOD_KEEP)

	idaapi.put_qword(target_ea, 0)

	if idaapi.add_func(target_ea):
		idaapi.set_name(target_ea, name, idaapi.SN_FORCE)
		return target_ea
	
	return None

def patch_plt():
	jmprel = find_dynamic_entry(0x17)
	strtab = find_dynamic_entry(0x5)
	symtab = find_dynamic_entry(0x6)
	relsz = find_dynamic_entry(0x2)

	if jmprel is None:
		print("!!! Failed to find 'DT_JMPREL' in '_DYNAMIC'")
		return
	if strtab is None:
		print("!!! Failed to find 'DT_STRTAB' in '_DYNAMIC'")
		return
	if symtab is None:
		print("!!! Failed to find 'DT_SYMTAB' in '_DYNAMIC'")
		return
	if relsz is None:
		rel_seg = idaapi.getseg(jmprel)
		relsz = rel_seg.end_ea - jmprel

	for i in range(0, relsz, 24):
		got_plt_offs = idaapi.get_qword(jmprel + i)
		type = idaapi.get_dword(jmprel + i + 0x8)
		sym_offs = idaapi.get_dword(jmprel + i + 0xC)

		if type == 7:
			sym_name_offs = idaapi.get_dword(symtab + sym_offs * 0x18)
			func_name = read_string(strtab + sym_name_offs)

			# Attempt to lookup function in case it's already exists
			target_ea = idc.get_name_ea_simple(func_name)

			if target_ea == idc.BADADDR:
				# Do additional lookup in extern segment in case previous lookup failed
				target_ea = find_func_in_extern(func_name)

				# If it's still not found, add new extern entry
				if target_ea is None:
					target_ea = add_extern_entry(func_name)

			idc.set_name(got_plt_offs, f'{func_name}_ptr', idaapi.SN_FORCE)

			if target_ea is not None:
				# Patch .got.plt entry to point to extern function
				idaapi.put_qword(got_plt_offs, target_ea)
				idaapi.add_dref(got_plt_offs, target_ea, idaapi.dr_O)

				tinfo = idaapi.tinfo_t()

				# Rename and mark as thunk all references to this plt entry
				for addr in idautils.DataRefsTo(got_plt_offs):
					idaapi.add_cref(addr, target_ea, idaapi.fl_CN)
					ref_func = idaapi.get_func(addr)
					if ref_func:
						idc.set_name(ref_func.start_ea, f'_{func_name}', idaapi.SN_FORCE)
						idc.set_func_flags(ref_func.start_ea, ref_func.flags | idaapi.FUNC_THUNK)

					if idaapi.get_tinfo(tinfo, addr):
						idaapi.set_tinfo(target_ea, tinfo, idaapi.TINFO_DEFINITE)
			else:
				print(f'!!! Failed to find/create {got_plt_offs:x} [{func_name}] function in exports')

class PltPatcher(idaapi.plugin_t):
	flags = idaapi.PLUGIN_UNL
	comment = 'Plt Patcher'
	help = 'Patches plt sections when IDA fails'
	wanted_name = 'Patch Plt Section'

	def init(self):
		if 'ELF64' not in idaapi.get_file_type_name():
			return idaapi.PLUGIN_SKIP

		return idaapi.PLUGIN_KEEP

	def run(self, arg):
		print('Starting patching plt section...')

		patch_plt()

		print('Plt patcher finished.')

	def term(self):
		pass


def PLUGIN_ENTRY():
	return PltPatcher()
```

`thunk_type_preserver.py`:

```py
# MIT License
# 
# Copyright (c) 2025 GAMMACASE
# https://github.com/GAMMACASE/PltPatcher

import idaapi
import ida_hexrays

class HexRaysHooks(ida_hexrays.Hexrays_Hooks):
	traversed_ea = set()

	def __init__(self):
		super().__init__()

	def _freeze_tinfo(self, ea):
		if ea in self.traversed_ea:
			return

		func = idaapi.get_func(ea)
		if func and (func.flags & idaapi.FUNC_THUNK):
			tinfo = idaapi.tinfo_t()
			if idaapi.get_tinfo(tinfo, ea):
				# Mark as user-defined to preserve
				self.traversed_ea.add(ea)
				idaapi.apply_tinfo(ea, tinfo, idaapi.TINFO_DEFINITE)
		return

	def _get_called_functions(self, cfunc):
		callees = set()
		
		for x in cfunc.treeitems:
			self._find_calls_in_expr(x, callees)
		return callees

	def _find_calls_in_expr(self, expr, callees):
		if expr is None:
			return
		
		if expr.op == ida_hexrays.cot_call:
			callees.add(expr.cexpr.x.obj_ea)

	def func_printed(self, cfunc):
		if not cfunc:
			return 0

		for callee_ea in self._get_called_functions(cfunc):
			self._freeze_tinfo(callee_ea)
		
		return 0

class ThunkTypePreserver(idaapi.plugin_t):
	flags = 0
	comment = 'Thunk Type Preserver'
	help = 'Preserves thunk guessed type information'
	wanted_name = 'Thunk Type Preserver'

	thunk_hook = None

	def init(self):
		if 'ELF64' not in idaapi.get_file_type_name():
			return idaapi.PLUGIN_SKIP

		if not ida_hexrays.init_hexrays_plugin():
			print('Failed to initialize plugin, missing hexrays decompiler.')
			return idaapi.PLUGIN_SKIP

		self.thunk_hook = HexRaysHooks()
		self.thunk_hook.hook()

		return idaapi.PLUGIN_KEEP

	def run(self, arg):
		pass

	def term(self):
		if self.thunk_hook is not None:
			self.thunk_hook.unhook()


def PLUGIN_ENTRY():
	return ThunkTypePreserver()
```