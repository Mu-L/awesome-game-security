Project Path: arc_DennyDai_headless-ida_8aem2dyi

Source Tree:

```txt
arc_DennyDai_headless-ida_8aem2dyi
├── LICENSE
├── README.md
├── examples
│   ├── decompile_main.py
│   ├── decompile_main_multibins.py
│   ├── list_functions.py
│   ├── list_strings.py
│   ├── save_idb.py
│   └── search_string_refs.py
├── headless-ida.png
├── pyproject.toml
└── src
    └── headless_ida
        ├── __init__.py
        ├── cli.py
        ├── client.py
        ├── helpers.py
        ├── ida_headers.py
        ├── ida_script.py
        └── server.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Han Dai

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<p align="center">
  <img alt="Headless IDA" src="https://raw.githubusercontent.com/DennyDai/headless-ida/main/headless-ida.png" width="128">
</p>
<h1 align="center">Headless IDA</h1>

[![Latest Release](https://img.shields.io/pypi/v/headless-ida.svg)](https://pypi.python.org/pypi/headless-ida/)
[![PyPI Statistics](https://img.shields.io/pypi/dm/headless-ida.svg)](https://pypistats.org/packages/headless-ida)
[![License](https://img.shields.io/github/license/DennyDai/headless-ida.svg)](https://github.com/DennyDai/headless-ida/blob/main/LICENSE)

# Install
```bash
pip install headless-ida
```

# Usage

> [!TIP]
> Headless IDA supports the latest [idalib](https://docs.hex-rays.com/user-guide/idalib). Just provide the idalib path instead of idat64 to use it as the backend.

### Use it as a normal Python module.
```python
# Initialize HeadlessIda
from headless_ida import HeadlessIda
headlessida = HeadlessIda("/path/to/idat64", "/path/to/binary")

# Import IDA Modules (make sure you have initialized HeadlessIda first)
import idautils
import ida_name

# Or Import All IDA Modules at Once (idaapi is not imported by default)
# from headless_ida.ida_headers import *

# Have Fun
for func in idautils.Functions():
    print(f"{hex(func)} {ida_name.get_ea_name(func)}")
```

### Use it as a command line tool.
```bash
# Interactive Console
$ headless-ida /path/to/idat64 /path/to/binary
Python 3.8.10 (default, Nov 14 2022, 12:59:47) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> import idautils
>>> list(idautils.Functions())[0:10]
[16384, 16416, 16432, 16448, 16464, 16480, 16496, 16512, 16528, 16544]
>>> 


# Run IDAPython Script
$ headless-ida /path/to/idat64 /path/to/binary idascript.py


# One-liner
$ headless-ida /path/to/idat64 /path/to/binary -c "import idautils; print(list(idautils.Functions())[0:10])"


# In case you like IPython
$ headless-ida /path/to/idat64 /path/to/binary -c "import IPython; IPython.embed();"
```

# Advanced Usage
## Remote Server

### Start a Headless IDA server
```bash
$ headless-ida-server /path/to/idat64 localhost 1337 &
```

### Connect to the server in Python script
```python
# Initialize HeadlessIda
from headless_ida import HeadlessIdaRemote
headlessida = HeadlessIdaRemote("localhost", 1337, "/path/to/local/binary")

# Import IDA Modules (make sure you have initialized HeadlessIda first)
import idautils
import ida_name

# Have Fun
for func in idautils.Functions():
    print(f"{hex(func)} {ida_name.get_ea_name(func)}")
```

### Connect to the server in command line
```bash
# Interactive Console
$ headless-ida localhost:1337 /path/to/local/binary
# Run IDAPython Script
$ headless-ida localhost:1337 /path/to/local/binary idascript.py
# One-liner
$ headless-ida localhost:1337 /path/to/local/binary -c "import idautils; print(list(idautils.Functions())[0:10])"
```


# Resources
- [Headless IDA Examples](https://github.com/DennyDai/headless-ida/tree/main/examples)
- [IDAPython Official Documentation](https://docs.hex-rays.com/developer-guide/idapython)
- IDAPython Official Examples: [1](https://docs.hex-rays.com/developer-guide/idapython/idapython-examples), [2](https://github.com/idapython/src/tree/master/examples)
# Known Issues
### `from XXX import *`
 - Using `from XXX import *` syntax with certain ida modules (like idaapi, ida_ua, etc.) is currently unsupported due to SWIG and RPyC compatibility issues. We recommend importing specific items with `from XXX import YYY, ZZZ`, or importing the entire module using `import XXX`.
 - The issue arises because SWIG, employed for creating Python bindings for C/C++ code, generates intermediary objects (SwigVarlink) that RPyC, our remote procedure call mechanism, cannot serialize or transmit correctly.

```

`examples/decompile_main.py`:

```py

# run with `headless-ida /path/to/idat64 /bin/ls decompile_main.py`

import idautils, ida_funcs, ida_hexrays

def get_function_by_name(name):
    for ea in idautils.Functions():
        if ida_funcs.get_func_name(ea) == name:
            return ea
    return None

def decompile_function(ea):
    cfunc = ida_hexrays.decompile(ea)
    if cfunc is None:
        return None
    return str(cfunc)

print(decompile_function(get_function_by_name("main")))


```

`examples/decompile_main_multibins.py`:

```py
from headless_ida import HeadlessIda

IDAT_PATH = "/path/to/idat64"


class IDA:
    def __init__(self, binary_path):
        self.headless_ida = HeadlessIda(IDAT_PATH, binary_path)
        self.idautils = self.headless_ida.import_module("idautils")
        self.ida_funcs = self.headless_ida.import_module("ida_funcs")
        self.ida_hexrays = self.headless_ida.import_module("ida_hexrays")

    def get_function_by_name(self, name):
        for ea in self.idautils.Functions():
            if self.ida_funcs.get_func_name(ea) == name:
                return ea
        return None

    def decompile_function(self, ea):
        cfunc = self.ida_hexrays.decompile(ea)
        if cfunc is None:
            return None
        return str(cfunc)


ls = IDA("/bin/ls")
cat = IDA("/bin/cat")

print(ls.decompile_function(ls.get_function_by_name("main")))
print(cat.decompile_function(cat.get_function_by_name("main")))

```

`examples/list_functions.py`:

```py

# run with `headless-ida /path/to/idat64 /bin/ls list_functions.py`

import idautils, ida_name

for func in idautils.Functions():
    print(f"{hex(func)} {ida_name.get_ea_name(func)}")

```

`examples/list_strings.py`:

```py

# run with `headless-ida /path/to/idat64 /bin/ls list_strings.py`

import idautils

for string in idautils.Strings():
    print(f"\033[92m{hex(string.ea)}\033[0m", end="\t")
    print(f"\033[93m{str(string).encode()}\033[0m", end="\t")
    print(f"\033[94m{[hex(ref) for ref in idautils.DataRefsTo(string.ea)]}\033[0m")

```

`examples/save_idb.py`:

```py

# run with `headless-ida /path/to/idat64 /bin/ls save_idb.py`

import ida_loader

ida_loader.save_database("/tmp/ls.idb", 0)


```

`examples/search_string_refs.py`:

```py

# run with `headless-ida /path/to/idat64 /bin/ls search_string_refs.py`

import idautils, ida_name, ida_funcs

def search_string(search):
    result = {}
    for string in idautils.Strings():
        if search in str(string):
            result[string.ea] = str(string)
    return result

def get_string_references(ea):
    result = []
    for ref in idautils.DataRefsTo(ea):
        result.append(ref)
    return result

for ea, string in search_string("Usage:").items():
    print(f"{hex(ea)} {string.encode('utf-8')}")
    print(f"References: ")
    for ref in get_string_references(ea):
        func = ida_funcs.get_func(ref)
        if func:
            print(f"\t{hex(func.start_ea)} {ida_name.get_ea_name(func.start_ea)}")

```

`pyproject.toml`:

```toml
[build-system]
requires = ["setuptools>=64", "setuptools-scm>=8"]
build-backend = "setuptools.build_meta"

[project]
name = "headless-ida"
dependencies = [
    "rpyc",
]
readme = "README.md"
description = "Headless IDA"
authors = [
    {name = "Han Dai", email = "pypi@han.do"},
]
license = {file = "LICENSE"}
keywords = ["ida", "headless", "idapro", "hexrays"]
requires-python = ">=3"
dynamic = ["version"]

[project.scripts]
headless-ida = "headless_ida:headlessida_cli"
headless-ida-server = "headless_ida:headlessida_server_cli"

[project.urls]
homepage = "https://github.com/DennyDai/headless-ida"
documentation = "https://github.com/DennyDai/headless-ida"
repository = "https://github.com/DennyDai/headless-ida"

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools_scm]
# empty

```

`src/headless_ida/__init__.py`:

```py
from importlib import metadata

from .client import HeadlessIda, HeadlessIdaRemote
from .server import HeadlessIdaServer

from .cli import headlessida_cli, headlessida_server_cli

__version__ = metadata.version("headless-ida")

```

`src/headless_ida/cli.py`:

```py
import argparse
import code

from rpyc.utils.server import ThreadedServer
from . import HeadlessIda, HeadlessIdaRemote, HeadlessIdaServer


def headlessida_cli():
    parser = argparse.ArgumentParser(description='Headless IDA')
    parser.add_argument(
        'idat_path', help='Path to IDA Pro TUI executable / Host:Port of remote HeadlessIDA server')
    parser.add_argument('binary_path', help='Path to binary to analyze')
    parser.add_argument('script_path', nargs='?', help='Path to script to run')
    parser.add_argument('-f', '--ftype', nargs='?',
                        help='interpret the input file as the specified file type The file type is specified as a '
                             'prefix of a file type visible in the "load file" dialog box')
    parser.add_argument('-p', '--processor', nargs='?',
                        help='specify processor type (e.g., arm:ARMv6, arm:ARMv7-A, mips:R3000, etc.)')
    parser.add_argument('-c', '--command', help='Command to run after script')

    args = parser.parse_args()

    if ":" in args.idat_path:
        host, port = args.idat_path.split(":")
        headlessida = HeadlessIdaRemote(host, int(port), args.binary_path, ftype=args.ftype, processor=args.processor)
    else:
        headlessida = HeadlessIda(args.idat_path, args.binary_path, ftype=args.ftype, processor=args.processor)
    headlessida_dict = {"headlessida": headlessida, "HeadlessIda": HeadlessIda}

    if args.script_path:
        with open(args.script_path) as f:
            exec(compile(f.read(), args.script_path, 'exec'), headlessida_dict)
    elif args.command:
        exec(compile(args.command, '<string>', 'single'), headlessida_dict)

    else:
        code.interact(local=locals())


def headlessida_server_cli():
    parser = argparse.ArgumentParser(description='Headless IDA Server')
    parser.add_argument('idat_path', help='Path to IDA Pro TUI executable')
    parser.add_argument('host', help='Host to bind to')
    parser.add_argument('port', type=int, help='Port to listen on')

    args = parser.parse_args()

    ThreadedServer(HeadlessIdaServer(args.idat_path), hostname=args.host, port=args.port,
                   protocol_config={"allow_all_attrs": True}).start()
```

`src/headless_ida/client.py`:

```py
import atexit
import builtins
import ctypes
import os
import shutil
import site
import socket
import subprocess
import sys
import importlib
import tempfile
from typing import Optional

import rpyc

from .helpers import ForwardIO, IDABackendType, escape_path, resolve_ida_path


class HeadlessIda:
    IDA_MODULES = [
        "ida_allins",
        "ida_auto",
        "ida_bitrange",
        "ida_bytes",
        "ida_dbg",
        "ida_dirtree",
        "ida_diskio",
        "ida_entry",
        "ida_enum",
        "ida_expr",
        "ida_fixup",
        "ida_fpro",
        "ida_frame",
        "ida_funcs",
        "ida_gdl",
        "ida_graph",
        "ida_hexrays",
        "ida_ida",
        "ida_idaapi",
        "ida_idc",
        "ida_idd",
        "ida_idp",
        "ida_ieee",
        "ida_kernwin",
        "ida_lines",
        "ida_loader",
        "ida_merge",
        "ida_mergemod",
        "ida_moves",
        "ida_nalt",
        "ida_name",
        "ida_netnode",
        "ida_offset",
        "ida_pro",
        "ida_problems",
        "ida_range",
        "ida_registry",
        "ida_search",
        "ida_segment",
        "ida_segregs",
        "ida_srclang",
        "ida_strlist",
        "ida_struct",
        "ida_tryblks",
        "ida_typeinf",
        "ida_ua",
        "ida_xref",
        "idc",
        "idautils",
        "idaapi",
    ]

    def __init__(
        self,
        ida_dir,
        binary_path,
        override_import=True,
        bits=64,
        ftype: Optional[str] = None,
        processor: Optional[str] = None,
    ) -> None:
        self.backend_type, self.ida_path = resolve_ida_path(ida_dir, bits)
        self.cleaned_up = False
        atexit.register(self.clean_up)

        if self.backend_type == IDABackendType.IDALIB:
            return self._idalib_backend(
                self.ida_path, binary_path, override_import, ftype=ftype, processor=processor
            )
        elif self.backend_type in [IDABackendType.IDA, IDABackendType.IDAT]:
            return self._ida_backend(
                self.ida_path, binary_path, override_import, ftype=ftype, processor=processor
            )

    def _idalib_backend(
        self,
        idalib_path,
        binary_path,
        override_import=True,
        ftype: Optional[str] = None,
        processor: Optional[str] = None,
    ):
        self.libida = ctypes.cdll.LoadLibrary(idalib_path)
        self.libida.init_library(0, None)

        # check if get_library_version is available
        if not hasattr(self.libida, "get_library_version"):
            major, minor, build = 9, 0, 0
        else:
            major, minor, build = ctypes.c_int(), ctypes.c_int(), ctypes.c_int()
            self.libida.get_library_version(
                ctypes.byref(major), ctypes.byref(minor), ctypes.byref(build)
            )
            major, minor, build = major.value, minor.value, build.value

        if major == 9 and minor == 0:
            sys.path.insert(
                0, os.path.join(os.path.dirname(idalib_path), "python/3/ida_64")
            )
            sys.path.insert(1, os.path.join(os.path.dirname(idalib_path), "python/3"))
        else:
            sys.path.insert(
                0, os.path.join(os.path.dirname(idalib_path), "python/lib-dynload")
            )
            sys.path.insert(1, os.path.join(os.path.dirname(idalib_path), "python"))

        # TODO: idalib doesn't support saving database to other location, so we need to copy the file manually
        tempdir = tempfile.mkdtemp()
        shutil.copy(binary_path, tempdir)
        
        target_file = os.path.join(tempdir, os.path.basename(binary_path))

        if major == 9 and minor == 0:
            self.libida.open_database(
                str(target_file).encode(),
                True,
            )
        else:
            ida_args = []
            if processor is not None:
                ida_args.append(f'-p{processor}')
            if ftype is not None:
                ida_args.append(f'-T{ftype}')
            if ida_args:
                cmd_line = ' '.join(ida_args)
                self.libida.open_database(
                    str(target_file).encode(),
                    True,
                    cmd_line.encode(),
                )
            else:
                self.libida.open_database(
                    str(target_file).encode(),
                    True,
                    None,
                )

    def _ida_backend(
        self, idat_path, binary_path, override_import=True, ftype: Optional[str] = None, processor: Optional[str] = None
    ) -> None:
        server_path = os.path.join(
            os.path.realpath(os.path.dirname(__file__)), "ida_script.py"
        )
        port = 8000
        with socket.socket() as s:
            s.bind(("", 0))
            port = s.getsockname()[1]
        os.environ["PYTHONPATH"] = (
            os.pathsep.join(site.getsitepackages() + [site.getusersitepackages()])
            + os.pathsep
            + os.environ.get("PYTHONPATH", "")
        )
        if binary_path.endswith(".i64") or binary_path.endswith(".idb"):
            tempidb = tempfile.NamedTemporaryFile(suffix=binary_path[-4:])
            with open(binary_path, "rb") as f:
                tempidb.write(f.read())
            tempidb.flush()
            binary_path = tempidb.name
            command = f'"{idat_path}" -A -S"{escape_path(server_path)} {port}" -P+'
            if ftype is not None:
                command += f' -T "{ftype}"'
            if processor is not None:
                command += f' -p{processor}'
            command += f' "{binary_path}"'
        else:
            tempidb = tempfile.NamedTemporaryFile()
            command = f'"{idat_path}" -o"{tempidb.name}" -A -S"{escape_path(server_path)} {port}"'
            if ftype is not None:
                command += f' -T "{ftype}"'
            if processor is not None:
                command += f' -p{processor}'
            command += f' "{binary_path}"'
        p = subprocess.Popen(
            command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        while True:
            if p.poll() is not None:
                raise Exception(
                    f"IDA failed to start: return code {p.poll()}\n"
                    f"Command: {command}\n"
                    f"=============== STDOUT ===============\n{p.stdout.read().decode()}"
                    f"=============== STDERR ===============\n{p.stderr.read().decode()}"
                )
            try:
                self.conn = rpyc.connect(
                    "localhost",
                    port,
                    service=ForwardIO,
                    config={"sync_request_timeout": 60 * 60 * 24},
                )
            except Exception:
                continue
            break

        if override_import:
            self.override_import()

    def override_import(self):
        original_import = builtins.__import__

        def ida_import(name, *args, **kwargs):
            if name in self.IDA_MODULES:
                return self.import_module(name)
            return original_import(name, *args, **kwargs)

        builtins.__import__ = ida_import

    def import_module(self, mod):
        if hasattr(self, "libida"):
            return importlib.import_module(mod)
        if hasattr(self, "conn"):
            return self.conn.root.import_module(mod)
        else:
            raise RuntimeError("No IDA backend initialized")

    def clean_up(self):
        if self.cleaned_up:
            return
        if hasattr(self, "libida"):
            self.libida.close_database(True)
        if hasattr(self, "conn"):
            self.conn.close()
        self.cleaned_up = True

    def __del__(self):
        self.clean_up()


class HeadlessIdaRemote(HeadlessIda):
    def __init__(self, host, port, binary_path, override_import=True, ftype=None, processor=None):
        self.cleaned_up = False
        atexit.register(self.clean_up)
        self.conn = rpyc.connect(
            host,
            int(port),
            service=ForwardIO,
            config={"sync_request_timeout": 60 * 60 * 24},
        )
        with open(binary_path, "rb") as f:
            self.conn.root.init(f.read(), ftype=ftype, processor=processor)
        if override_import:
            self.override_import()

```

`src/headless_ida/helpers.py`:

```py
import ctypes
import os
import platform
import sys
from enum import Enum, auto

import rpyc


class ForwardIO(rpyc.Service):
    def exposed_stdout_write(self, data):
        print(data, end="", file=sys.stdout)

    def exposed_stderr_write(self, data):
        print(data, end="", file=sys.stderr)


def escape_path(path):
    if os.name == "nt":
        _GetShortPathName = ctypes.windll.kernel32.GetShortPathNameW
        _GetShortPathName.argtypes = [ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint]
        _GetShortPathName.restype = ctypes.c_uint

        buffer = ctypes.create_unicode_buffer(len(path) + 1)
        if _GetShortPathName(path, buffer, len(buffer)):
            return buffer.value
        else:
            raise Exception("Failed to get short path")
    else:
        return f'\\"{path}\\"'


class IDABackendType(Enum):
    IDA = auto()
    IDAT = auto()
    IDALIB = auto()


def resolve_ida_path(path, bits=64):
    IDA_BINARIES = {
        "Windows": {
            "idalib": ["idalib64.dll", "idalib.dll"],
            "ida": ["ida64.exe", "ida.exe"],
            "idat": ["idat64.exe", "idat.exe"],
        },
        "Linux": {
            "idalib": ["libidalib64.so", "libidalib.so"],
            "ida": ["ida64", "ida"],
            "idat": ["idat64", "idat"],
        },
        "Darwin": {
            "idalib": ["libidalib64.dylib", "libidalib.dylib"],
            "ida": ["ida64", "ida"],
            "idat": ["idat64", "idat"],
        },
    }

    system = platform.system()
    if system not in IDA_BINARIES:
        raise ValueError(f"Unsupported platform: {system}")

    binaries = IDA_BINARIES[system]

    if os.path.isfile(path):
        filename = os.path.basename(path)
        if filename in binaries["idalib"]:
            return IDABackendType.IDALIB, path
        if filename in binaries["ida"]:
            return IDABackendType.IDA, path
        if filename in binaries["idat"]:
            return IDABackendType.IDAT, path

    elif os.path.isdir(path):
        # Check for idalib variants
        for idalib_binary in binaries["idalib"]:
            idalib_path = os.path.join(path, idalib_binary)
            if os.path.exists(idalib_path):
                return IDABackendType.IDALIB, idalib_path

        idat_binary = binaries["idat"][0 if bits == 64 else 1]
        idat_path = os.path.join(path, idat_binary)
        if os.path.exists(idat_path):
            return IDABackendType.IDAT, idat_path

        ida_binary = binaries["ida"][0 if bits == 64 else 1]
        ida_path = os.path.join(path, ida_binary)
        if os.path.exists(ida_path):
            return IDABackendType.IDA, ida_path

    raise ValueError(f"Invalid IDA path: {path}")

```

`src/headless_ida/ida_headers.py`:

```py
import ida_allins
import ida_auto
import ida_bitrange
import ida_bytes
import ida_dbg
import ida_dirtree
import ida_diskio
import ida_entry
import ida_enum
import ida_expr
import ida_fixup
import ida_fpro
import ida_frame
import ida_funcs
import ida_gdl
import ida_graph
import ida_hexrays
import ida_ida
import ida_idaapi
import ida_idc
import ida_idd
import ida_idp
import ida_ieee
import ida_kernwin
import ida_lines
import ida_loader
import ida_moves
import ida_nalt
import ida_name
import ida_netnode
import ida_offset
import ida_pro
import ida_problems
import ida_range
import ida_registry
import ida_search
import ida_segment
import ida_segregs
import ida_srclang
import ida_strlist
import ida_struct
import ida_tryblks
import ida_typeinf
import ida_ua
import ida_xref
import idc
import idautils
# import idaapi

```

`src/headless_ida/ida_script.py`:

```py
import rpyc
import importlib
import ida_auto
import ida_loader
import ida_pro
import idc
import sys

class HeadlessIda(rpyc.Service):
    def __init__(self):
        super().__init__()
        ida_auto.auto_wait()

    def on_connect(self, conn):
        ida_loader.set_database_flag(ida_loader.DBFL_KILL)
        sys.stdout.write = conn.root.stdout_write
        sys.stderr.write = conn.root.stderr_write

    def on_disconnect(self, conn):
        ida_pro.qexit(0)
        sys.stdout = sys.__stdout__
        sys.stderr = sys.__stderr__

    def exposed_import_module(self, mod):
        return importlib.import_module(mod)


if __name__ == "__main__":
    t = rpyc.utils.server.OneShotServer(HeadlessIda, port=int(
        idc.ARGV[1]), protocol_config={"allow_all_attrs": True})
    t.start()

```

`src/headless_ida/server.py`:

```py
import ctypes
import importlib
import os
import shutil
import site
import socket
import subprocess
import sys
import tempfile

import rpyc

from .helpers import ForwardIO, IDABackendType, escape_path, resolve_ida_path


def HeadlessIdaServer(idat_path):
    backend_type, ida_path = resolve_ida_path(idat_path)
    
    # Check if trying to use idalib with the server
    if backend_type == IDABackendType.IDALIB:
        raise RuntimeError(
            "idalib cannot be used with server mode (requires main thread). "
            "Use regular IDA instead: headless-ida-server /path/to/idat host port"
        )

    class _HeadlessIdaServer(rpyc.Service):
        def exposed_init(self, binary, ftype=None, processor=None):
            if backend_type == IDABackendType.IDALIB:
                return self._idalib_backend(ida_path, binary, ftype=ftype, processor=processor)
            elif backend_type in [IDABackendType.IDA, IDABackendType.IDAT]:
                return self._ida_backend(ida_path, binary, ftype=ftype, processor=processor)

        def _idalib_backend(self, idalib_path, binary, ftype=None, processor=None):
            # This should never be reached due to the check in HeadlessIdaServer()
            # but keeping as a safety check
            self.libida = ctypes.cdll.LoadLibrary(idalib_path)
            self.libida.init_library(0, None)
            
            # check if get_library_version is available
            if not hasattr(self.libida, "get_library_version"):
                major, minor, build = 9, 0, 0
            else:
                major, minor, build = ctypes.c_int(), ctypes.c_int(), ctypes.c_int()
                self.libida.get_library_version(
                    ctypes.byref(major), ctypes.byref(minor), ctypes.byref(build)
                )
                major, minor, build = major.value, minor.value, build.value
            
            if major == 9 and minor == 0:
                sys.path.insert(
                    0, os.path.join(os.path.dirname(idalib_path), "python/3/ida_64")
                )
                sys.path.insert(1, os.path.join(os.path.dirname(idalib_path), "python/3"))
            else:
                sys.path.insert(
                    0, os.path.join(os.path.dirname(idalib_path), "python/lib-dynload")
                )
                sys.path.insert(1, os.path.join(os.path.dirname(idalib_path), "python"))
            
            # Create temp directory and save binary
            tempdir = tempfile.mkdtemp()
            binary_file = os.path.join(tempdir, "temp_binary")
            with open(binary_file, 'wb') as f:
                f.write(binary)
            
            if major == 9 and minor == 0:
                self.libida.open_database(
                    str(binary_file).encode(),
                    True,
                )
            else:
                ida_args = []
                if processor is not None:
                    ida_args.append(f'-p{processor}')
                if ftype is not None:
                    ida_args.append(f'-T{ftype}')
                if ida_args:
                    cmd_line = ' '.join(ida_args)
                    self.libida.open_database(
                        str(binary_file).encode(),
                        True,
                        cmd_line.encode(),
                    )
                else:
                    self.libida.open_database(
                        str(binary_file).encode(),
                        True,
                        None,
                    )

        def _ida_backend(self, idat_path, binary, ftype=None, processor=None):
            binary_file = tempfile.NamedTemporaryFile(delete=False)
            binary_file.write(binary)
            binary_file.flush()
            binary_file.close()
            binary_path = binary_file.name

            server_path = os.path.join(
                os.path.realpath(os.path.dirname(__file__)), "ida_script.py"
            )
            port = 8000
            with socket.socket() as s:
                s.bind(("", 0))
                port = s.getsockname()[1]
            os.environ["PYTHONPATH"] = (
                os.pathsep.join(site.getsitepackages() + [site.getusersitepackages()])
                + os.pathsep
                + os.environ.get("PYTHONPATH", "")
            )
            if binary_path.endswith(".i64") or binary_path.endswith(".idb"):
                tempidb = tempfile.NamedTemporaryFile(suffix=binary_path[-4:])
                with open(binary_path, "rb") as f:
                    tempidb.write(f.read())
                tempidb.flush()
                binary_path = tempidb.name
                command = f'"{idat_path}" -A -S"{escape_path(server_path)} {port}" -P+'
                if ftype is not None:
                    command += f' -T "{ftype}"'
                if processor is not None:
                    command += f' -p{processor}'
                command += f' "{binary_path}"'
            else:
                tempidb = tempfile.NamedTemporaryFile()
                command = f'"{idat_path}" -o"{tempidb.name}" -A -S"{escape_path(server_path)} {port}"'
                if ftype is not None:
                    command += f' -T "{ftype}"'
                if processor is not None:
                    command += f' -p{processor}'
                command += f' "{binary_path}"'
            p = subprocess.Popen(
                command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
            while True:
                if p.poll() is not None:
                    raise Exception(
                        f"IDA failed to start: return code {p.poll()}\n"
                        f"Command: {command}\n"
                        f"=============== STDOUT ===============\n{p.stdout.read().decode()}"
                        f"=============== STDERR ===============\n{p.stderr.read().decode()}"
                    )
                try:
                    self.conn = rpyc.connect(
                        "localhost",
                        port,
                        service=ForwardIO,
                        config={"sync_request_timeout": 60 * 60 * 24},
                    )
                except:
                    continue
                break

        def exposed_import_module(self, mod):
            # return self.conn.root.import_module(mod)
            if hasattr(self, "conn"):
                return self.conn.root.import_module(mod)
            else:
                return importlib.import_module(mod)

        def on_connect(self, conn):
            sys.stdout.write = conn.root.stdout_write
            sys.stderr.write = conn.root.stderr_write

        def on_disconnect(self, conn):
            if hasattr(self, "libida"):
                self.libida.close_database()
            if hasattr(self, "conn"):
                self.conn.close()
            sys.stdout = sys.__stdout__
            sys.stderr = sys.__stderr__

    return _HeadlessIdaServer

```