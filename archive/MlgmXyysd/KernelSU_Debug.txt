Project Path: arc_MlgmXyysd_KernelSU_Debug_uuo5s7yg

Source Tree:

```txt
arc_MlgmXyysd_KernelSU_Debug_uuo5s7yg
├── LICENSE
├── README.md
├── README_CN.md
├── kernel
│   ├── Kconfig
│   ├── LICENSE
│   ├── Makefile
│   ├── allowlist.c
│   ├── allowlist.h
│   ├── apk_sign.c
│   ├── apk_sign.h
│   ├── arch.h
│   ├── core_hook.c
│   ├── core_hook.h
│   ├── embed_ksud.c
│   ├── export_symbol.txt
│   ├── include
│   │   └── ksu_hook.h
│   ├── kernel_compat.c
│   ├── kernel_compat.h
│   ├── klog.h
│   ├── ksu.c
│   ├── ksu.h
│   ├── ksud.c
│   ├── ksud.h
│   ├── manager.c
│   ├── manager.h
│   ├── module_api.c
│   ├── selinux
│   │   ├── Makefile
│   │   ├── rules.c
│   │   ├── selinux.c
│   │   ├── selinux.h
│   │   ├── sepolicy.c
│   │   └── sepolicy.h
│   ├── setup.sh
│   ├── sucompat.c
│   ├── uid_observer.c
│   └── uid_observer.h
├── manager
│   ├── app
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── aidl
│   │           │   └── me
│   │           │       └── weishu
│   │           │           └── kernelsu
│   │           │               └── IKsuInterface.aidl
│   │           ├── cpp
│   │           │   ├── CMakeLists.txt
│   │           │   ├── jni.cc
│   │           │   ├── ksu.cc
│   │           │   └── ksu.h
│   │           ├── java
│   │           │   └── me
│   │           │       └── weishu
│   │           │           └── kernelsu
│   │           │               ├── KernelSUApplication.kt
│   │           │               ├── Kernels.kt
│   │           │               ├── Natives.kt
│   │           │               ├── profile
│   │           │               │   ├── Capabilities.kt
│   │           │               │   └── Groups.kt
│   │           │               └── ui
│   │           │                   ├── KsuService.java
│   │           │                   ├── MainActivity.kt
│   │           │                   ├── component
│   │           │                   │   ├── AboutCard.kt
│   │           │                   │   ├── Dialog.kt
│   │           │                   │   ├── KeyEventBlocker.kt
│   │           │                   │   ├── SearchBar.kt
│   │           │                   │   ├── SettingsItem.kt
│   │           │                   │   └── profile
│   │           │                   │       ├── AppProfileConfig.kt
│   │           │                   │       └── RootProfileConfig.kt
│   │           │                   ├── screen
│   │           │                   │   ├── AppProfile.kt
│   │           │                   │   ├── BottomBarDestination.kt
│   │           │                   │   ├── Home.kt
│   │           │                   │   ├── Install.kt
│   │           │                   │   ├── Module.kt
│   │           │                   │   ├── Settings.kt
│   │           │                   │   └── SuperUser.kt
│   │           │                   ├── theme
│   │           │                   │   ├── Color.kt
│   │           │                   │   ├── Theme.kt
│   │           │                   │   └── Type.kt
│   │           │                   ├── util
│   │           │                   │   ├── CompositionProvider.kt
│   │           │                   │   ├── Downloader.kt
│   │           │                   │   ├── HanziToPinyin.java
│   │           │                   │   ├── HyperlinkText.kt
│   │           │                   │   ├── KsuCli.kt
│   │           │                   │   ├── LogEvent.kt
│   │           │                   │   └── SELinuxChecker.kt
│   │           │                   └── viewmodel
│   │           │                       ├── ModuleViewModel.kt
│   │           │                       └── SuperUserViewModel.kt
│   │           ├── jniLibs
│   │           └── res
│   │               ├── drawable
│   │               │   ├── ic_launcher_background.xml
│   │               │   ├── ic_launcher_foreground.xml
│   │               │   └── ic_launcher_monochrome.xml
│   │               ├── mipmap-anydpi-v26
│   │               │   └── ic_launcher.xml
│   │               ├── mipmap-hdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-ldpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-mdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-xhdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-xxhdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-xxxhdpi
│   │               │   └── ic_launcher.png
│   │               ├── values
│   │               │   ├── strings.xml
│   │               │   └── themes.xml
│   │               ├── values-ar
│   │               │   └── strings.xml
│   │               ├── values-az
│   │               │   └── strings.xml
│   │               ├── values-bn
│   │               │   └── strings.xml
│   │               ├── values-bn-rBD
│   │               │   └── strings.xml
│   │               ├── values-da
│   │               │   └── strings.xml
│   │               ├── values-de
│   │               │   └── strings.xml
│   │               ├── values-es
│   │               │   └── strings.xml
│   │               ├── values-fa
│   │               │   └── strings.xml
│   │               ├── values-fr
│   │               │   └── strings.xml
│   │               ├── values-in
│   │               │   └── strings.xml
│   │               ├── values-it
│   │               │   └── strings.xml
│   │               ├── values-ja
│   │               │   └── strings.xml
│   │               ├── values-ko
│   │               │   └── strings.xml
│   │               ├── values-lt
│   │               │   └── strings.xml
│   │               ├── values-mr
│   │               │   └── strings.xml
│   │               ├── values-nl
│   │               │   └── strings.xml
│   │               ├── values-pl
│   │               │   └── strings.xml
│   │               ├── values-pt
│   │               │   └── strings.xml
│   │               ├── values-pt-rBR
│   │               │   └── strings.xml
│   │               ├── values-ro
│   │               │   └── strings.xml
│   │               ├── values-ru
│   │               │   └── strings.xml
│   │               ├── values-th
│   │               │   └── strings.xml
│   │               ├── values-tr
│   │               │   └── strings.xml
│   │               ├── values-uk
│   │               │   └── strings.xml
│   │               ├── values-vi
│   │               │   └── strings.xml
│   │               ├── values-zh-rCN
│   │               │   └── strings.xml
│   │               ├── values-zh-rHK
│   │               │   └── strings.xml
│   │               ├── values-zh-rTW
│   │               │   └── strings.xml
│   │               └── xml
│   │                   ├── backup_rules.xml
│   │                   ├── data_extraction_rules.xml
│   │                   └── filepaths.xml
│   ├── build.gradle.kts
│   ├── gradle
│   │   ├── libs.versions.toml
│   │   └── wrapper
│   │       ├── gradle-wrapper.jar
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   ├── settings.gradle.kts
│   └── sign.example.properties
├── scripts
│   ├── abi_gki_all.py
│   ├── add_device_handler.py
│   ├── bin2c.py
│   └── check_v2.c
└── userspace
    ├── ksud
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── bin
    │   │   ├── aarch64
    │   │   │   ├── busybox
    │   │   │   └── resetprop
    │   │   └── x86_64
    │   │       ├── busybox
    │   │       └── resetprop
    │   ├── build.rs
    │   └── src
    │       ├── apk_sign.rs
    │       ├── assets.rs
    │       ├── cli.rs
    │       ├── debug.rs
    │       ├── defs.rs
    │       ├── event.rs
    │       ├── ksu.rs
    │       ├── main.rs
    │       ├── module.rs
    │       ├── profile.rs
    │       ├── restorecon.rs
    │       ├── sepolicy.rs
    │       └── utils.rs
    └── su
        └── jni
            ├── Android.mk
            ├── Application.mk
            └── su.c

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
**English** | [简体中文](README_CN.md)

# KernelSU Debug

A Kernel based root solution for Android devices. Modified for development debugging.

## Features

1. Kernel-based `su` and root access management.
2. [App Profile](https://kernelsu.org/guide/app-profile.html): Lock up the root power in a cage.

3. Remove redundant module functions, to make the root access management cleaner. [1]
4. Remove the unnecessary manager signature validation, only keep package name validation as basic security. Now you can modify the manager as much as you want. [2]
5. Set SELinux Permissive by default for **highest privileges**. [3]
6. Disabled the seccomp **non-security** Privilege Escalation, even if SELinux is set to Permissive on boot. [3]
7. Forced spoofing of SELinux state to Enforcing, even if it was actually Permissive, used to spoof authentication through Play Integrity.  [3]
8. Always allow adb shell root. [4]
9. Allow all APPs root, same as Magisk's auto response feature.
10. `init.d` support，ksud will parse or execute [stage].sh/system.prop/sepolicy.rule under `/data/ksu/common`.
11. Allow user to modify the target manager package name via the cli command.

## Compatibility State

KernelSU officially supports Android GKI 2.0 devices(with kernel 5.10+), old kernels(4.14+) are also compatible, but you need to build the kernel yourself.

WSA, ChromeOS and container-based Android can also work with KernelSU integrated.

And the current supported ABIs are: `arm64-v8a` and `x86_64`

## Discussion

- Telegram: [@MlgmXyysd_bibilailai](https://t.me/MlgmXyysd_bibilailai) (Channel Discussion Group)

## To-Dos

- Root access authorization dialog
- Allow modify manager package name in manager
- Allow enable SELinux Enforcing in manager
- Allow disable seccomp in manager
- Allow disable SELinux Enforcing proof in manager
- Install KernelSU as kernel module

## Workaround

1. KernelSU **SHOULD ONLY** provide root access related features, module features are redundant and poorly implemented for compatibility. So drop the redundant modules feature (but keep boot stage scripts) to keep it clean and improves runtime performance.

2. Restricting users from modifying the distribution manager in root access tools is pointless, and defeats the purpose of unlocking and rooting devices. Users should be able to verify that the software they are installing is trustworthy, otherwise any security measures are meaningless. It's enough to keep only the package name verification in the kernel as a basic security check, and leave the signature verification to the Android's PackageManager, which puts the manager's license in a first-install-first-out state. What? Core patch? Why do I need to consider users installing untrusted software on their own?

3. If you only got the root access, in some cases you will still be prevented by the Enforcing SELinux policy. The only way to do this is to disable SELinux (not allowed in Android) or set it to Permissive. So we believe that setting SELinux to Permissive mode (ROOT + Permissive) is the only way to really get the highest privileges on Android device. Google doesn't consider automatically disabling seccomp after setting SELinux Permissive to be a security issue, so we don't care too.

4. KernelSU does not provide a dialog for authorization, which is annoying. Adb shell is one of the core components of Android, there is no need to confirm its security. Trusting and authorizing it preserves relative application security as well as convenient user operation for terminal debugging.


	If you believe that the above features undermine the security of a device that has been flashed with custom firmware, please review the BootLoader's unlock warning first:

> <!>
> 
> By unlocking the bootloader, you will be able to install custom operating system on this phone. A custom OS is not subject to the same level of testing as the original OS, and can cause your phone and installed applications to stop working properly.
> 
> **Software integrity cannot be guaranteed with a custom OS, so any data stored on the phone while the bootloader is unlocked may be at risk.**
> 
> To prevent unauthorized access to your personal data, unlocking the bootloader will also delete all personal data on your phone.
> 
> Press the Volume keys to select whether to unlock the bootloader, then the Power Button to continue.
> 
> __________
> DO NOT UNLOCK THE BOOTLOADER
> __________
> UNLOCK THE BOOTLOADER
> __________

	And

> <!>
> 
> The boot loader is unlocked and software integrity cannot be guaranteed. **Any data stored on the device may be available to attackers. Do not store any sensitive data on the device.**
> 
> Visit this link on another device:
> 
> g.co/ABH

	If this still does not solve your problem, please click on the X button in the upper right corner of the window.

## Usage

- [Installation Instruction](https://kernelsu.org/guide/installation.html)
- [How to build?](https://kernelsu.org/guide/how-to-build.html)

## License

- Files under the `kernel` directory are [GPL-2](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
- All other parts except the `kernel` directory are [GPL-3](https://www.gnu.org/licenses/gpl-3.0.html)

## Credits

- [KernelSU](https://github.com/tiann/KernelSU): fork source
- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): the KernelSU idea
- [Magisk](https://github.com/topjohnwu/Magisk): the powerful root tool
- [Diamorphine](https://github.com/m0nad/Diamorphine): some rootkit skills

```

`README_CN.md`:

```md
[English](README.md) | **简体中文** 

# KernelSU Debug

一个 Android 上基于内核的 root 方案。为调试用途做了一些修改。

## 特性

1. 基于内核的 su 和权限管理。
2. [App Profile](https://kernelsu.org/guide/app-profile.html): 把 Root 权限关进笼子里。

3. 去除无用的模块功能，让授权管理更干净。[1]
4. 去除无用的管理器签名验证，仅保留包名验证作为基础的安全校验，允许用户自行修改管理器 app。[2]
5. 默认设置 SELinux 为宽容模式，为使用 bootconfig 作为启动参数的设备提供一种永久获取**最高权限**的方式。[3]
6. 禁用了 seccomp **非安全性**权限提升，即使 SELinux 在开机时已设置为 Permissive。[3]
7. 强制伪装 SELinux 状态为 Enforcing，即使实际为 Permissive，用于欺骗通过 Play Integrity 认证。[3]
8. 永远信任 adb shell，为其提供 su 授权。[4]
9. 允许用户设置默认授予全部应用 su 授权功能，与 Magisk 自动响应功能一致。
10. init.d 支持，ksud 会在开机时各阶段解析或执行 `/data/ksu/common` 下的 [stage].sh/system.prop/sepolicy.rule 文件。
11. 允许用户通过 cli 指令修改管理器目标包名。

## 兼容状态

KernelSU 官方支持 GKI 2.0 的设备（内核版本5.10以上）；旧内核也是兼容的（最低4.14+），不过需要自己编译内核。

WSA, ChromeOS 和运行在容器上的 Android 也可以与 KernelSU 一起工作。

目前支持架构 : `arm64-v8a` 和 `x86_64`

## 讨论

- Telegram: [@MlgmXyysd_bibilailai](https://t.me/MlgmXyysd_bibilailai) (频道评论群)

## To-Dos

- Root 授权对话框
- 允许用户在管理器中修改管理器目标包名（转移权限）
- 允许用户在管理器中开启严格执行的 SELinux
- 允许用户在管理器中开关 seccomp 功能
- 允许用户在管理器中开关 SELinux Enforcing 伪装功能
- 使用内核模块方式安装 KernelSU

## 修改解释

1. KernelSU **只应该**提供 su 功能。模块功能是多余的，并且兼容性不佳。所以去除模块功能（保留启动脚本），让其只做应该做的事，还可以提升运行性能，没什么好解释的。

2. 在获取 root 权限的应用中限制用户自行修改分发版管理器是没有意义的，限制用户也违背了解锁刷机的初衷。用户应该有能力确认自己所安装的软件的自己可信的，否则任何的安全措施都没有意义。内核中仅保留包名验证做为基础安全校验，将签名验证交给 Android 系统的 PackageManager，使管理器授权处于一种先装先得的状态已足够。什么？核心破解？自己瞎装东西关我毛事？

3. 仅获取到 root 权限，在一些情况下执行操作仍然会被严格执行的 SELinux 策略挡掉，只有关闭 SELinux 或设置为宽容模式才允许执行，而 Android 无法直接关闭 SELinux。所以我们认为，在取得 root 的同时将 SELinux 设置为宽容模式（ROOT + Permissive），才是真正获取到了设备的最高权限。谷歌并不认为开启 SELinux Permissive 后关闭 seccomp 是安全问题，因此我们也不关心。

4. KernelSU 不提供询问授权弹窗，在授权时会很麻烦。adb shell 是系统核心组件之一，无需确认其安全性，信任并授权既保留了相对的应用安全，也方便用户操作终端调试。


	如果您认为上述功能破坏了已刷入自定义固件设备的安全性，请先回顾一下 BootLoader 的解锁警告：

> <!>
> 
> By unlocking the bootloader, you will be able to install custom operating system on this phone. A custom OS is not subject to the same level of testing as the original OS, and can cause your phone and installed applications to stop working properly.
> 
> **Software integrity cannot be guaranteed with a custom OS, so any data stored on the phone while the bootloader is unlocked may be at risk.**
> 
> To prevent unauthorized access to your personal data, unlocking the bootloader will also delete all personal data on your phone.
> 
> Press the Volume keys to select whether to unlock the bootloader, then the Power Button to continue.
> 
> __________
> DO NOT UNLOCK THE BOOTLOADER
> __________
> UNLOCK THE BOOTLOADER
> __________

	以及

> <!>
> 
> The boot loader is unlocked and software integrity cannot be guaranteed. **Any data stored on the device may be available to attackers. Do not store any sensitive data on the device.**
> 
> Visit this link on another device:
> 
> g.co/ABH

	如果这仍然不能解决您的疑惑，请您点击窗口右上角的 X 按钮

## 使用方法

- [安装教程](https://kernelsu.org/zh_CN/guide/installation.html)
- [如何构建？](https://kernelsu.org/zh_CN/guide/how-to-build.html)

## 许可证

- 目录 `kernel` 下所有文件为 [GPL-2](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
- 除 `kernel` 目录的其他部分均为 [GPL-3](https://www.gnu.org/licenses/gpl-3.0.html)

## 鸣谢

- [KernelSU](https://github.com/tiann/KernelSU): fork 源
- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): KernelSU 的灵感
- [Magisk](https://github.com/topjohnwu/Magisk): 强大的 root 工具箱
- [Diamorphine](https://github.com/m0nad/Diamorphine): 一些 rootkit 技巧

```

`kernel/Kconfig`:

```
menu "KernelSU"

config KSU
	tristate "KernelSU function support"
	select OVERLAY_FS
	default y
	help
	Enable kernel-level root privileges on Android System.

config KSU_DEBUG
	bool "KernelSU debug mode"
	depends on KSU
	default n
	help
	Enable KernelSU debug mode

endmenu

```

`kernel/LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`kernel/Makefile`:

```
obj-y += ksu.o
obj-y += allowlist.o
kernelsu-objs := apk_sign.o
obj-y += kernelsu.o
obj-y += module_api.o
obj-y += sucompat.o
obj-y += uid_observer.o
obj-y += manager.o
obj-y += core_hook.o
obj-y += ksud.o
obj-y += embed_ksud.o
obj-y += kernel_compat.o

obj-y += selinux/
# .git is a text file while the module is imported by 'git submodule add'.
ifeq ($(shell test -e $(srctree)/$(src)/../.git; echo $$?),0)
KSU_GIT_VERSION := $(shell cd $(srctree)/$(src); /usr/bin/env PATH="$$PATH":/usr/bin:/usr/local/bin git rev-list --count HEAD)
# ksu_version: major * 10000 + git version + 200 for historical reasons
$(eval KSU_VERSION=$(shell expr 10000 + $(KSU_GIT_VERSION) + 200))
$(info -- KernelSU version: $(KSU_VERSION))
ccflags-y += -DKSU_VERSION=$(KSU_VERSION)
else # If there is no .git file, the default version will be passed.
$(warning "KSU_GIT_VERSION not defined! It is better to make KernelSU a git submodule!")
ccflags-y += -DKSU_VERSION=16
endif

ifndef KSU_EXPECTED_SIZE
KSU_EXPECTED_SIZE := 0x033b
endif

ifndef KSU_EXPECTED_HASH
KSU_EXPECTED_HASH := 0xb0b91415
endif

$(info -- KernelSU Manager signature size: $(KSU_EXPECTED_SIZE))
$(info -- KernelSU Manager signature hash: $(KSU_EXPECTED_HASH))

ccflags-y += -DEXPECTED_SIZE=$(KSU_EXPECTED_SIZE)
ccflags-y += -DEXPECTED_HASH=$(KSU_EXPECTED_HASH)
ccflags-y += -Wno-implicit-function-declaration -Wno-strict-prototypes -Wno-int-conversion -Wno-gcc-compat
ccflags-y += -Wno-declaration-after-statement

```

`kernel/allowlist.c`:

```c
#include "ksu.h"
#include "linux/compiler.h"
#include "linux/fs.h"
#include "linux/gfp.h"
#include "linux/kernel.h"
#include "linux/list.h"
#include "linux/printk.h"
#include "linux/slab.h"
#include "linux/types.h"
#include "linux/version.h"
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
#include "linux/compiler_types.h"
#endif

#include "klog.h" // IWYU pragma: keep
#include "selinux/selinux.h"
#include "kernel_compat.h"
#include "allowlist.h"

#define FILE_MAGIC 0x7f4b5355 // ' KSU', u32
#define FILE_FORMAT_VERSION 3 // u32

#define KSU_APP_PROFILE_PRESERVE_UID 9999 // NOBODY_UID
#define KSU_DEFAULT_SELINUX_DOMAIN "u:r:su:s0"

static DEFINE_MUTEX(allowlist_mutex);

// default profiles, these may be used frequently, so we cache it
static struct root_profile default_root_profile;
static struct non_root_profile default_non_root_profile;

static int allow_list_arr[PAGE_SIZE / sizeof(int)] __read_mostly __aligned(PAGE_SIZE);
static int allow_list_pointer __read_mostly = 0;

static void remove_uid_from_arr(uid_t uid)
{
	int *temp_arr;
	int i, j;

	if (allow_list_pointer == 0)
		return;

	temp_arr = kmalloc(sizeof(allow_list_arr), GFP_KERNEL);
	if (temp_arr == NULL) {
		pr_err("%s: unable to allocate memory\n", __func__);
		return;
	}

	for (i = j = 0; i < allow_list_pointer; i++) {
		if (allow_list_arr[i] == uid)
			continue;
		temp_arr[j++] = allow_list_arr[i];
	}

	allow_list_pointer = j;

	for (; j < ARRAY_SIZE(allow_list_arr); j++)
		temp_arr[j] = -1;

	memcpy(&allow_list_arr, temp_arr, PAGE_SIZE);
	kfree(temp_arr);
}

static void init_default_profiles()
{
	default_root_profile.uid = 0;
	default_root_profile.gid = 0;
	default_root_profile.groups_count = 1;
	default_root_profile.groups[0] = 0;
	memset(&default_root_profile.capabilities, 0xff,
	       sizeof(default_root_profile.capabilities));
	default_root_profile.namespaces = 0;
	strcpy(default_root_profile.selinux_domain, KSU_DEFAULT_SELINUX_DOMAIN);

	// This means that we will umount modules by default!
	default_non_root_profile.umount_modules = true;
}

struct perm_data {
	struct list_head list;
	struct app_profile profile;
};

static struct list_head allow_list;

static uint8_t allow_list_bitmap[PAGE_SIZE] __read_mostly __aligned(PAGE_SIZE);
#define BITMAP_UID_MAX ((sizeof(allow_list_bitmap) * BITS_PER_BYTE) - 1)

#define KERNEL_SU_ALLOWLIST "/data/adb/ksu/.allowlist"

static struct work_struct ksu_save_work;
static struct work_struct ksu_load_work;

bool persistent_allow_list(void);

void ksu_show_allow_list(void)
{
	struct perm_data *p = NULL;
	struct list_head *pos = NULL;
	pr_info("ksu_show_allow_list");
	list_for_each (pos, &allow_list) {
		p = list_entry(pos, struct perm_data, list);
		pr_info("uid :%d, allow: %d\n", p->profile.current_uid,
			p->profile.allow_su);
	}
}

static void ksu_grant_root_to_shell()
{
	struct app_profile profile = {
		.allow_su = true,
		.current_uid = 2000,
	};
	strcpy(profile.key, "com.android.shell");
	strcpy(profile.rp_config.profile.selinux_domain, KSU_DEFAULT_SELINUX_DOMAIN);
	ksu_set_app_profile(&profile, false);
}

bool ksu_get_app_profile(struct app_profile *profile)
{
	struct perm_data *p = NULL;
	struct list_head *pos = NULL;
	bool found = false;

	list_for_each (pos, &allow_list) {
		p = list_entry(pos, struct perm_data, list);
		bool uid_match = profile->current_uid == p->profile.current_uid;
		if (uid_match) {
			// found it, override it with ours
			memcpy(profile, &p->profile, sizeof(*profile));
			found = true;
			goto exit;
		}
	}

exit:
	return found;
}

static inline bool forbid_system_uid(uid_t uid) {
	#define SHELL_UID 2000
	#define SYSTEM_UID 1000
	return uid < SHELL_UID && uid != SYSTEM_UID;
}

static bool profile_valid(struct app_profile *profile)
{
	if (!profile) {
		return false;
	}

	if (forbid_system_uid(profile->current_uid)) {
		pr_err("uid lower than 2000 is unsupported: %d\n", profile->current_uid);
		return false;
	}

	if (profile->version < KSU_APP_PROFILE_VER) {
		pr_info("Unsupported profile version: %d\n", profile->version);
		return false;
	}

	if (profile->allow_su) {
		if (profile->rp_config.profile.groups_count > KSU_MAX_GROUPS) {
			return false;
		}

		if (strlen(profile->rp_config.profile.selinux_domain) == 0) {
			return false;
		}
	}

	return true;
}

bool ksu_set_app_profile(struct app_profile *profile, bool persist)
{
	struct perm_data *p = NULL;
	struct list_head *pos = NULL;
	bool result = false;

	if (!profile_valid(profile)) {
		pr_err("Failed to set app profile: invalid profile!\n");
		return false;
	}

	list_for_each (pos, &allow_list) {
		p = list_entry(pos, struct perm_data, list);
		// both uid and package must match, otherwise it will break multiple package with different user id
		if (profile->current_uid == p->profile.current_uid &&
		    !strcmp(profile->key, p->profile.key)) {
			// found it, just override it all!
			memcpy(&p->profile, profile, sizeof(*profile));
			result = true;
			goto out;
		}
	}

	// not found, alloc a new node!
	p = (struct perm_data *)kmalloc(sizeof(struct perm_data), GFP_KERNEL);
	if (!p) {
		pr_err("ksu_set_app_profile alloc failed\n");
		return false;
	}

	memcpy(&p->profile, profile, sizeof(*profile));
	if (profile->allow_su) {
		pr_info("set root profile, key: %s, uid: %d, gid: %d, context: %s\n",
			profile->key, profile->current_uid,
			profile->rp_config.profile.gid,
			profile->rp_config.profile.selinux_domain);
	} else {
		pr_info("set app profile, key: %s, uid: %d, umount modules: %d\n",
			profile->key, profile->current_uid,
			profile->nrp_config.profile.umount_modules);
	}
	list_add_tail(&p->list, &allow_list);

out:
	if (profile->current_uid <= BITMAP_UID_MAX) {
		if (profile->allow_su)
			allow_list_bitmap[profile->current_uid / BITS_PER_BYTE] |= 1 << (profile->current_uid % BITS_PER_BYTE);
		else
			allow_list_bitmap[profile->current_uid / BITS_PER_BYTE] &= ~(1 << (profile->current_uid % BITS_PER_BYTE));
	} else {
		if (profile->allow_su) {
			/*
			 * 1024 apps with uid higher than BITMAP_UID_MAX
			 * registered to request superuser?
			 */
			if (allow_list_pointer >= ARRAY_SIZE(allow_list_arr)) {
				pr_err("too many apps registered\n");
				WARN_ON(1);
				return false;
			}
			allow_list_arr[allow_list_pointer++] = profile->current_uid;
		} else {
			remove_uid_from_arr(profile->current_uid);
		}
	}
	result = true;

	// check if the default profiles is changed, cache it to a single struct to accelerate access.
	if (unlikely(!strcmp(profile->key, "$"))) {
		// set default non root profile
		memcpy(&default_non_root_profile, &profile->nrp_config.profile,
		       sizeof(default_non_root_profile));
	}

	if (unlikely(!strcmp(profile->key, "#"))) {
		// set default root profile
		memcpy(&default_root_profile, &profile->rp_config.profile,
		       sizeof(default_root_profile));
	}

	if (persist)
		persistent_allow_list();

	return result;
}

bool __ksu_is_allow_uid(uid_t uid)
{
	if (unlikely(uid == 0)) {
		// already root, but only allow our domain.
		return is_ksu_domain();
	}

	if (unlikely(uid == 2000)) {
		// shell, let's root
		return true;
	}

	if (forbid_system_uid(uid)) {
		// do not bother going through the list if it's system
		return false;
	}

	if (default_non_root_profile.umount_modules) {
		// default umount modules is ON (default value), check the allowlist normally
		if (likely(uid <= BITMAP_UID_MAX)) {
			return !!(allow_list_bitmap[uid / BITS_PER_BYTE] & (1 << (uid % BITS_PER_BYTE)));
		} else {
			for (int i = 0; i < allow_list_pointer; i++) {
				if (allow_list_arr[i] == uid)
					return true;
			}
		}

		return false;
	} else {
		// default umount modules is OFF, check the app profile
		struct app_profile profile = { .current_uid = uid };
		bool found = ksu_get_app_profile(&profile);
		if (found) {
			// found app custom profile settings, let's check if it is default profile
			if (!profile.nrp_config.use_default) {
				// not default profile, disable root
				return false;
			}
		}
			
		return true;
	}
}

bool ksu_uid_should_umount(uid_t uid)
{
	struct app_profile profile = { .current_uid = uid };
	bool found = ksu_get_app_profile(&profile);
	if (!found) {
		// no app profile found, it must be non root app
		return default_non_root_profile.umount_modules;
	}
	if (profile.allow_su) {
		// if found and it is granted to su, we shouldn't umount for it
		return false;
	} else {
		// found an app profile
		if (profile.nrp_config.use_default) {
			return default_non_root_profile.umount_modules;
		} else {
			return profile.nrp_config.profile.umount_modules;
		}
	}
}

struct root_profile *ksu_get_root_profile(uid_t uid)
{
	struct perm_data *p = NULL;
	struct list_head *pos = NULL;

	list_for_each (pos, &allow_list) {
		p = list_entry(pos, struct perm_data, list);
		if (uid == p->profile.current_uid && p->profile.allow_su) {
			if (!p->profile.rp_config.use_default) {
				return &p->profile.rp_config.profile;
			}
		}
	}

	// use default profile
	return &default_root_profile;
}

bool ksu_get_allow_list(int *array, int *length, bool allow)
{
	struct perm_data *p = NULL;
	struct list_head *pos = NULL;
	int i = 0;
	list_for_each (pos, &allow_list) {
		p = list_entry(pos, struct perm_data, list);
		// pr_info("get_allow_list uid: %d allow: %d\n", p->uid, p->allow);
		if (p->profile.allow_su == allow) {
			array[i++] = p->profile.current_uid;
		}
	}
	*length = i;

	return true;
}

void do_save_allow_list(struct work_struct *work)
{
	u32 magic = FILE_MAGIC;
	u32 version = FILE_FORMAT_VERSION;
	struct perm_data *p = NULL;
	struct list_head *pos = NULL;
	loff_t off = 0;

	struct file *fp =
		ksu_filp_open_compat(KERNEL_SU_ALLOWLIST, O_WRONLY | O_CREAT, 0644);
	if (IS_ERR(fp)) {
		pr_err("save_allow_list create file failed: %ld\n", PTR_ERR(fp));
		return;
	}

	// store magic and version
	if (ksu_kernel_write_compat(fp, &magic, sizeof(magic), &off) !=
	    sizeof(magic)) {
		pr_err("save_allow_list write magic failed.\n");
		goto exit;
	}

	if (ksu_kernel_write_compat(fp, &version, sizeof(version), &off) !=
	    sizeof(version)) {
		pr_err("save_allow_list write version failed.\n");
		goto exit;
	}

	list_for_each (pos, &allow_list) {
		p = list_entry(pos, struct perm_data, list);
		pr_info("save allow list, name: %s uid :%d, allow: %d\n",
			p->profile.key, p->profile.current_uid,
			p->profile.allow_su);

		ksu_kernel_write_compat(fp, &p->profile, sizeof(p->profile),
					&off);
	}

exit:
	filp_close(fp, 0);
}

void do_load_allow_list(struct work_struct *work)
{
	loff_t off = 0;
	ssize_t ret = 0;
	struct file *fp = NULL;
	u32 magic;
	u32 version;

	// always allow adb shell by default
	ksu_grant_root_to_shell();

	// load allowlist now!
	fp = ksu_filp_open_compat(KERNEL_SU_ALLOWLIST, O_RDONLY, 0);
	if (IS_ERR(fp)) {
		pr_err("load_allow_list open file failed: %ld\n", PTR_ERR(fp));
		return;
	}

	// verify magic
	if (ksu_kernel_read_compat(fp, &magic, sizeof(magic), &off) !=
		    sizeof(magic) ||
	    magic != FILE_MAGIC) {
		pr_err("allowlist file invalid: %d!\n", magic);
		goto exit;
	}

	if (ksu_kernel_read_compat(fp, &version, sizeof(version), &off) !=
	    sizeof(version)) {
		pr_err("allowlist read version: %d failed\n", version);
		goto exit;
	}

	pr_info("allowlist version: %d\n", version);

	while (true) {
		struct app_profile profile;

		ret = ksu_kernel_read_compat(fp, &profile, sizeof(profile),
					     &off);

		if (ret <= 0) {
			pr_info("load_allow_list read err: %zd\n", ret);
			break;
		}

		pr_info("load_allow_uid, name: %s, uid: %d, allow: %d\n",
			profile.key, profile.current_uid, profile.allow_su);
		ksu_set_app_profile(&profile, false);
	}

exit:
	ksu_show_allow_list();
	filp_close(fp, 0);
}

void ksu_prune_allowlist(bool (*is_uid_exist)(uid_t, void *), void *data)
{
	struct perm_data *np = NULL;
	struct perm_data *n = NULL;

	bool modified = false;
	// TODO: use RCU!
	mutex_lock(&allowlist_mutex);
	list_for_each_entry_safe (np, n, &allow_list, list) {
		uid_t uid = np->profile.current_uid;
		// we use this uid for special cases, don't prune it!
		bool is_preserved_uid = uid == KSU_APP_PROFILE_PRESERVE_UID;
		if (!is_preserved_uid && !is_uid_exist(uid, data)) {
			modified = true;
			pr_info("prune uid: %d\n", uid);
			list_del(&np->list);
			allow_list_bitmap[uid / BITS_PER_BYTE] &= ~(1 << (uid % BITS_PER_BYTE));
			remove_uid_from_arr(uid);
			smp_mb();
			kfree(np);
		}
	}
	mutex_unlock(&allowlist_mutex);

	if (modified) {
		persistent_allow_list();
	}
}

// make sure allow list works cross boot
bool persistent_allow_list(void)
{
	return ksu_queue_work(&ksu_save_work);
}

bool ksu_load_allow_list(void)
{
	return ksu_queue_work(&ksu_load_work);
}

void ksu_allowlist_init(void)
{
	int i;

	BUILD_BUG_ON(sizeof(allow_list_bitmap) != PAGE_SIZE);
	BUILD_BUG_ON(sizeof(allow_list_arr) != PAGE_SIZE);

	for (i = 0; i < ARRAY_SIZE(allow_list_arr); i++)
		allow_list_arr[i] = -1;

	INIT_LIST_HEAD(&allow_list);

	INIT_WORK(&ksu_save_work, do_save_allow_list);
	INIT_WORK(&ksu_load_work, do_load_allow_list);

	init_default_profiles();
}

void ksu_allowlist_exit(void)
{
	struct perm_data *np = NULL;
	struct perm_data *n = NULL;

	do_save_allow_list(NULL);

	// free allowlist
	mutex_lock(&allowlist_mutex);
	list_for_each_entry_safe (np, n, &allow_list, list) {
		list_del(&np->list);
		kfree(np);
	}
	mutex_unlock(&allowlist_mutex);
}

```

`kernel/allowlist.h`:

```h
#ifndef __KSU_H_ALLOWLIST
#define __KSU_H_ALLOWLIST

#include "linux/types.h"
#include "ksu.h"

void ksu_allowlist_init(void);

void ksu_allowlist_exit(void);

bool ksu_load_allow_list(void);

void ksu_show_allow_list(void);

bool __ksu_is_allow_uid(uid_t uid);
#define ksu_is_allow_uid(uid) unlikely(__ksu_is_allow_uid(uid))

bool ksu_get_allow_list(int *array, int *length, bool allow);

void ksu_prune_allowlist(bool (*is_uid_exist)(uid_t, void *), void *data);

bool ksu_get_app_profile(struct app_profile *);
bool ksu_set_app_profile(struct app_profile *, bool persist);

bool ksu_uid_should_umount(uid_t uid);
struct root_profile *ksu_get_root_profile(uid_t uid);
#endif

```

`kernel/apk_sign.c`:

```c
#include "linux/fs.h"
#include "linux/moduleparam.h"

#include "apk_sign.h"
#include "klog.h" // IWYU pragma: keep
#include "kernel_compat.h"

static __always_inline int
check_v2_signature(char *path, unsigned expected_size, unsigned expected_hash)
{
	return 0;
}

#ifdef CONFIG_KSU_DEBUG

unsigned ksu_expected_size = EXPECTED_SIZE;
unsigned ksu_expected_hash = EXPECTED_HASH;

#include "manager.h"

static int set_expected_size(const char *val, const struct kernel_param *kp)
{
	int rv = param_set_uint(val, kp);
	ksu_invalidate_manager_uid();
	pr_info("ksu_expected_size set to %x", ksu_expected_size);
	return rv;
}

static int set_expected_hash(const char *val, const struct kernel_param *kp)
{
	int rv = param_set_uint(val, kp);
	ksu_invalidate_manager_uid();
	pr_info("ksu_expected_hash set to %x", ksu_expected_hash);
	return rv;
}

static struct kernel_param_ops expected_size_ops = {
	.set = set_expected_size,
	.get = param_get_uint,
};

static struct kernel_param_ops expected_hash_ops = {
	.set = set_expected_hash,
	.get = param_get_uint,
};

module_param_cb(ksu_expected_size, &expected_size_ops, &ksu_expected_size,
		S_IRUSR | S_IWUSR);
module_param_cb(ksu_expected_hash, &expected_hash_ops, &ksu_expected_hash,
		S_IRUSR | S_IWUSR);

int is_manager_apk(char *path)
{
	return check_v2_signature(path, ksu_expected_size, ksu_expected_hash);
}

#else

int is_manager_apk(char *path)
{
	return check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH);
}

#endif

```

`kernel/apk_sign.h`:

```h
#ifndef __KSU_H_APK_V2_SIGN
#define __KSU_H_APK_V2_SIGN

// return 0 if signature match
int is_manager_apk(char *path);

#endif

```

`kernel/arch.h`:

```h
#ifndef __KSU_H_ARCH
#define __KSU_H_ARCH

#include "linux/version.h"

#if defined(__aarch64__)

#define __PT_PARM1_REG regs[0]
#define __PT_PARM2_REG regs[1]
#define __PT_PARM3_REG regs[2]
#define __PT_SYSCALL_PARM4_REG regs[3]
#define __PT_CCALL_PARM4_REG regs[3]
#define __PT_PARM5_REG regs[4]
#define __PT_PARM6_REG regs[5]
#define __PT_RET_REG regs[30]
#define __PT_FP_REG regs[29] /* Works only with CONFIG_FRAME_POINTER */
#define __PT_RC_REG regs[0]
#define __PT_SP_REG sp
#define __PT_IP_REG pc

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
#define PRCTL_SYMBOL "__arm64_sys_prctl"
#else
#define PRCTL_SYMBOL "sys_prctl"
#endif

#elif defined(__x86_64__)

#define __PT_PARM1_REG di
#define __PT_PARM2_REG si
#define __PT_PARM3_REG dx
/* syscall uses r10 for PARM4 */
#define __PT_SYSCALL_PARM4_REG r10
#define __PT_CCALL_PARM4_REG cx
#define __PT_PARM5_REG r8
#define __PT_PARM6_REG r9
#define __PT_RET_REG sp
#define __PT_FP_REG bp
#define __PT_RC_REG ax
#define __PT_SP_REG sp
#define __PT_IP_REG ip
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
#define PRCTL_SYMBOL "__x64_sys_prctl"
#else
#define PRCTL_SYMBOL "sys_prctl"
#endif

#else
#error "Unsupported arch"
#endif

/* allow some architecutres to override `struct pt_regs` */
#ifndef __PT_REGS_CAST
#define __PT_REGS_CAST(x) (x)
#endif

#define PT_REGS_PARM1(x) (__PT_REGS_CAST(x)->__PT_PARM1_REG)
#define PT_REGS_PARM2(x) (__PT_REGS_CAST(x)->__PT_PARM2_REG)
#define PT_REGS_PARM3(x) (__PT_REGS_CAST(x)->__PT_PARM3_REG)
#define PT_REGS_SYSCALL_PARM4(x) (__PT_REGS_CAST(x)->__PT_SYSCALL_PARM4_REG)
#define PT_REGS_CCALL_PARM4(x) (__PT_REGS_CAST(x)->__PT_CCALL_PARM4_REG)
#define PT_REGS_PARM5(x) (__PT_REGS_CAST(x)->__PT_PARM5_REG)
#define PT_REGS_PARM6(x) (__PT_REGS_CAST(x)->__PT_PARM6_REG)
#define PT_REGS_RET(x) (__PT_REGS_CAST(x)->__PT_RET_REG)
#define PT_REGS_FP(x) (__PT_REGS_CAST(x)->__PT_FP_REG)
#define PT_REGS_RC(x) (__PT_REGS_CAST(x)->__PT_RC_REG)
#define PT_REGS_SP(x) (__PT_REGS_CAST(x)->__PT_SP_REG)
#define PT_REGS_IP(x) (__PT_REGS_CAST(x)->__PT_IP_REG)

#endif

```

`kernel/core_hook.c`:

```c
#include "linux/capability.h"
#include "linux/cred.h"
#include "linux/dcache.h"
#include "linux/err.h"
#include "linux/init.h"
#include "linux/kernel.h"
#include "linux/kprobes.h"
#include "linux/lsm_hooks.h"
#include "linux/nsproxy.h"
#include "linux/path.h"
#include "linux/printk.h"
#include "linux/uaccess.h"
#include "linux/uidgid.h"
#include "linux/version.h"
#include "linux/mount.h"

#include "linux/fs.h"
#include "linux/namei.h"
#include "linux/rcupdate.h"

#include "allowlist.h"
#include "arch.h"
#include "core_hook.h"
#include "klog.h" // IWYU pragma: keep
#include "ksu.h"
#include "ksud.h"
#include "manager.h"
#include "selinux/selinux.h"
#include "uid_observer.h"
#include "kernel_compat.h"

extern int handle_sepolicy(unsigned long arg3, void __user *arg4);

static inline bool is_allow_su()
{
	if (is_manager()) {
		// we are manager, allow!
		return true;
	}
	return ksu_is_allow_uid(current_uid().val);
}

static inline bool is_isolated_uid(uid_t uid)
{
#define FIRST_ISOLATED_UID 99000
#define LAST_ISOLATED_UID 99999
#define FIRST_APP_ZYGOTE_ISOLATED_UID 90000
#define LAST_APP_ZYGOTE_ISOLATED_UID 98999
	uid_t appid = uid % 100000;
	return (appid >= FIRST_ISOLATED_UID && appid <= LAST_ISOLATED_UID) ||
	       (appid >= FIRST_APP_ZYGOTE_ISOLATED_UID &&
		appid <= LAST_APP_ZYGOTE_ISOLATED_UID);
}

static struct group_info root_groups = { .usage = ATOMIC_INIT(2) };

static void setup_groups(struct root_profile *profile, struct cred *cred)
{
	if (profile->groups_count > KSU_MAX_GROUPS) {
		pr_warn("Failed to setgroups, too large group: %d!\n",
			profile->uid);
		return;
	}

	if (profile->groups_count == 1 && profile->groups[0] == 0) {
		// setgroup to root and return early.
		if (cred->group_info)
			put_group_info(cred->group_info);
		cred->group_info = get_group_info(&root_groups);
		return;
	}

	u32 ngroups = profile->groups_count;
	struct group_info *group_info = groups_alloc(ngroups);
	if (!group_info) {
		pr_warn("Failed to setgroups, ENOMEM for: %d\n", profile->uid);
		return;
	}

	int i;
	for (i = 0; i < ngroups; i++) {
		gid_t gid = profile->groups[i];
		kgid_t kgid = make_kgid(current_user_ns(), gid);
		if (!gid_valid(kgid)) {
			pr_warn("Failed to setgroups, invalid gid: %d\n", gid);
			put_group_info(group_info);
			return;
		}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
		group_info->gid[i] = kgid;
#else
		GROUP_AT(group_info, i) = kgid;
#endif
	}

	groups_sort(group_info);
	set_groups(cred, group_info);
}

void escape_to_root(void)
{
	struct cred *cred;

	cred = (struct cred *)__task_cred(current);

	if (cred->euid.val == 0) {
		pr_warn("Already root, don't escape!\n");
		return;
	}
	struct root_profile *profile = ksu_get_root_profile(cred->uid.val);

	cred->uid.val = profile->uid;
	cred->suid.val = profile->uid;
	cred->euid.val = profile->uid;
	cred->fsuid.val = profile->uid;

	cred->gid.val = profile->gid;
	cred->fsgid.val = profile->gid;
	cred->sgid.val = profile->gid;
	cred->egid.val = profile->gid;

	BUILD_BUG_ON(sizeof(profile->capabilities.effective) !=
		     sizeof(kernel_cap_t));

	// capabilities
	memcpy(&cred->cap_effective, &profile->capabilities.effective,
	       sizeof(cred->cap_effective));
	memcpy(&cred->cap_inheritable, &profile->capabilities.effective,
	       sizeof(cred->cap_inheritable));
	memcpy(&cred->cap_permitted, &profile->capabilities.effective,
	       sizeof(cred->cap_permitted));
	memcpy(&cred->cap_bset, &profile->capabilities.effective,
	       sizeof(cred->cap_bset));
	memcpy(&cred->cap_ambient, &profile->capabilities.effective,
	       sizeof(cred->cap_ambient));

	// disable seccomp
#if defined(CONFIG_GENERIC_ENTRY) &&                                           \
	LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
	current_thread_info()->syscall_work &= ~SYSCALL_WORK_SECCOMP;
#else
	current_thread_info()->flags &= ~(TIF_SECCOMP | _TIF_SECCOMP);
#endif

#ifdef CONFIG_SECCOMP
	current->seccomp.mode = 0;
	current->seccomp.filter = NULL;
#else
#endif

	setup_groups(profile, cred);

	setup_selinux(profile->selinux_domain);
}

int ksu_handle_rename(struct dentry *old_dentry, struct dentry *new_dentry)
{
	if (!current->mm) {
		// skip kernel threads
		return 0;
	}

	if (current_uid().val != 1000) {
		// skip non system uid
		return 0;
	}

	if (!old_dentry || !new_dentry) {
		return 0;
	}

	// /data/system/packages.list.tmp -> /data/system/packages.list
	if (strcmp(new_dentry->d_iname, "packages.list")) {
		return 0;
	}

	char path[128];
	char *buf = dentry_path_raw(new_dentry, path, sizeof(path));
	if (IS_ERR(buf)) {
		pr_err("dentry_path_raw failed.\n");
		return 0;
	}

	if (strcmp(buf, "/system/packages.list")) {
		return 0;
	}
	pr_info("renameat: %s -> %s, new path: %s", old_dentry->d_iname,
		new_dentry->d_iname, buf);

	update_uid();

	return 0;
}

int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
		     unsigned long arg4, unsigned long arg5)
{
	// if success, we modify the arg5 as result!
	u32 *result = (u32 *)arg5;
	u32 reply_ok = KERNEL_SU_OPTION;

	if (KERNEL_SU_OPTION != option) {
		return 0;
	}

	// always ignore isolated app uid
	if (is_isolated_uid(current_uid().val)) {
		return 0;
	}

	static uid_t last_failed_uid = -1;
	if (last_failed_uid == current_uid().val) {
		return 0;
	}

	// pr_info("option: 0x%x, cmd: %ld\n", option, arg2);

	if (arg2 == CMD_BECOME_MANAGER) {
		// quick check
		if (is_manager()) {
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("become_manager: prctl reply error\n");
			}
			return 0;
		}
		if (ksu_is_manager_uid_valid()) {
			pr_info("manager already exist: %d\n",
				ksu_get_manager_uid());
			return 0;
		}

		// someone wants to be root manager, just check it!
		// arg3 should be `/data/user/<userId>/<manager_package_name>`
		char param[128];
		if (ksu_strncpy_from_user_nofault(param, arg3, sizeof(param)) == -EFAULT) {
#ifdef CONFIG_KSU_DEBUG
			pr_err("become_manager: copy param err\n");
#endif
			return 0;
		}

		// for user 0, it is /data/data
		// for user 999, it is /data/user/999
		const char *prefix;
		char prefixTmp[64];
		int userId = current_uid().val / 100000;
		if (userId == 0) {
			prefix = "/data/data";
		} else {
			snprintf(prefixTmp, sizeof(prefixTmp), "/data/user/%d",
				 userId);
			prefix = prefixTmp;
		}

		if (startswith(param, (char *)prefix) != 0) {
			pr_info("become_manager: invalid param: %s\n", param);
			return 0;
		}

		// stat the param, app must have permission to do this
		// otherwise it may fake the path!
		struct path path;
		if (kern_path(param, LOOKUP_DIRECTORY, &path)) {
			pr_err("become_manager: kern_path err\n");
			return 0;
		}
		if (path.dentry->d_inode->i_uid.val != current_uid().val) {
			pr_err("become_manager: path uid != current uid\n");
			path_put(&path);
			return 0;
		}
		char *pkg = param + strlen(prefix);
		pr_info("become_manager: param pkg: %s\n", pkg);

		bool success = become_manager(pkg);
		if (success) {
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("become_manager: prctl reply error\n");
			}
		}
		path_put(&path);
		return 0;
	}

	if (arg2 == CMD_GRANT_ROOT) {
		if (is_allow_su()) {
			pr_info("allow root for: %d\n", current_uid());
			escape_to_root();
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("grant_root: prctl reply error\n");
			}
		}
		return 0;
	}

	// Both root manager and root processes should be allowed to get version
	if (arg2 == CMD_GET_VERSION) {
		if (is_manager() || 0 == current_uid().val) {
			u32 version = KERNEL_SU_VERSION;
			if (copy_to_user(arg3, &version, sizeof(version))) {
				pr_err("prctl reply error, cmd: %d\n", arg2);
			}
		}
		return 0;
	}

	if (arg2 == CMD_REPORT_EVENT) {
		if (0 != current_uid().val) {
			return 0;
		}
		switch (arg3) {
		case EVENT_POST_FS_DATA: {
			static bool post_fs_data_lock = false;
			if (!post_fs_data_lock) {
				post_fs_data_lock = true;
				pr_info("post-fs-data triggered");
				on_post_fs_data();
			}
			break;
		}
		case EVENT_BOOT_COMPLETED: {
			static bool boot_complete_lock = false;
			if (!boot_complete_lock) {
				boot_complete_lock = true;
				pr_info("boot_complete triggered");
			}
			break;
		}
		default:
			break;
		}
		return 0;
	}

	if (arg2 == CMD_SET_SEPOLICY) {
		if (0 != current_uid().val) {
			return 0;
		}
		if (!handle_sepolicy(arg3, arg4)) {
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("sepolicy: prctl reply error\n");
			}
		}

		return 0;
	}

	if (arg2 == CMD_CHECK_SAFEMODE) {
		if (!is_manager() && 0 != current_uid().val) {
			return 0;
		}
		if (ksu_is_safe_mode()) {
			pr_warn("safemode enabled!\n");
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("safemode: prctl reply error\n");
			}
		}
		return 0;
	}

	if (arg2 == CMD_GET_ALLOW_LIST || arg2 == CMD_GET_DENY_LIST) {
		if (is_manager() || 0 == current_uid().val) {
			u32 array[128];
			u32 array_length;
			bool success =
				ksu_get_allow_list(array, &array_length,
						   arg2 == CMD_GET_ALLOW_LIST);
			if (success) {
				if (!copy_to_user(arg4, &array_length,
						  sizeof(array_length)) &&
				    !copy_to_user(arg3, array,
						  sizeof(u32) * array_length)) {
					if (copy_to_user(result, &reply_ok,
							 sizeof(reply_ok))) {
						pr_err("prctl reply error, cmd: %d\n",
						       arg2);
					}
				} else {
					pr_err("prctl copy allowlist error\n");
				}
			}
		}
		return 0;
	}

	if (arg2 == CMD_UID_GRANTED_ROOT || arg2 == CMD_UID_SHOULD_UMOUNT) {
		if (is_manager() || 0 == current_uid().val) {
			uid_t target_uid = (uid_t)arg3;
			bool allow = false;
			if (arg2 == CMD_UID_GRANTED_ROOT) {
				allow = ksu_is_allow_uid(target_uid);
			} else if (arg2 == CMD_UID_SHOULD_UMOUNT) {
				allow = ksu_uid_should_umount(target_uid);
			} else {
				pr_err("unknown cmd: %d\n", arg2);
			}
			if (!copy_to_user(arg4, &allow, sizeof(allow))) {
				if (copy_to_user(result, &reply_ok,
						 sizeof(reply_ok))) {
					pr_err("prctl reply error, cmd: %d\n",
					       arg2);
				}
			} else {
				pr_err("prctl copy err, cmd: %d\n", arg2);
			}
		}
		return 0;
	}

	// all other cmds are for 'root manager'
	if (!is_manager()) {
		last_failed_uid = current_uid().val;
		return 0;
	}

	// we are already manager
	if (arg2 == CMD_GET_APP_PROFILE) {
		struct app_profile profile;
		if (copy_from_user(&profile, arg3, sizeof(profile))) {
			pr_err("copy profile failed\n");
			return 0;
		}

		bool success = ksu_get_app_profile(&profile);
		if (success) {
			if (copy_to_user(arg3, &profile, sizeof(profile))) {
				pr_err("copy profile failed\n");
				return 0;
			}
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("prctl reply error, cmd: %d\n", arg2);
			}
		}
		return 0;
	}

	if (arg2 == CMD_SET_APP_PROFILE) {
		struct app_profile profile;
		if (copy_from_user(&profile, arg3, sizeof(profile))) {
			pr_err("copy profile failed\n");
			return 0;
		}

		// todo: validate the params
		if (ksu_set_app_profile(&profile, true)) {
			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
				pr_err("prctl reply error, cmd: %d\n", arg2);
			}
		}
		return 0;
	}

	return 0;
}

static bool is_appuid(kuid_t uid)
{
#define PER_USER_RANGE 100000
#define FIRST_APPLICATION_UID 10000
#define LAST_APPLICATION_UID 19999

	uid_t appid = uid.val % PER_USER_RANGE;
	return appid >= FIRST_APPLICATION_UID && appid <= LAST_APPLICATION_UID;
}

static bool should_umount(struct path *path)
{
	if (!path) {
		return false;
	}

	if (current->nsproxy->mnt_ns == init_nsproxy.mnt_ns) {
		pr_info("ignore global mnt namespace process: %d\n",
			current_uid().val);
		return false;
	}

	if (path->mnt && path->mnt->mnt_sb && path->mnt->mnt_sb->s_type) {
		const char *fstype = path->mnt->mnt_sb->s_type->name;
		return strcmp(fstype, "overlay") == 0;
	}
	return false;
}

static void try_umount(const char *mnt)
{
	struct path path;
	int err = kern_path(mnt, 0, &path);
	if (err) {
		return;
	}

	// we are only interest in some specific mounts
	if (!should_umount(&path)) {
		return;
	}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
	err = path_umount(&path, 0);
	if (err) {
		pr_info("umount %s failed: %d\n", mnt, err);
	}
#endif
}

int ksu_handle_setuid(struct cred *new, const struct cred *old)
{
	if (!new || !old) {
		return 0;
	}

	kuid_t new_uid = new->uid;
	kuid_t old_uid = old->uid;

	if (0 != old_uid.val) {
		// old process is not root, ignore it.
		return 0;
	}

	// todo: check old process's selinux context, if it is not zygote, ignore it!

	if (!is_appuid(new_uid)) {
		// pr_info("handle setuid ignore non application uid: %d\n", new_uid.val);
		return 0;
	}

	if (ksu_is_allow_uid(new_uid.val)) {
		// pr_info("handle setuid ignore allowed application: %d\n", new_uid.val);
		return 0;
	}

	if (!ksu_uid_should_umount(new_uid.val)) {
		return 0;
	} else {
#ifdef CONFIG_KSU_DEBUG
		pr_info("uid: %d should not umount!\n", current_uid().val);
#endif
	}

	// umount the target mnt
	pr_info("handle umount for uid: %d\n", new_uid.val);

	// fixme: use `collect_mounts` and `iterate_mount` to iterate all mountpoint and
	// filter the mountpoint whose target is `/data/adb`
	try_umount("/system");
	try_umount("/vendor");
	try_umount("/product");

	return 0;
}

// Init functons

static int handler_pre(struct kprobe *p, struct pt_regs *regs)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
	struct pt_regs *real_regs = (struct pt_regs *)PT_REGS_PARM1(regs);
#else
	struct pt_regs *real_regs = regs;
#endif
	int option = (int)PT_REGS_PARM1(real_regs);
	unsigned long arg2 = (unsigned long)PT_REGS_PARM2(real_regs);
	unsigned long arg3 = (unsigned long)PT_REGS_PARM3(real_regs);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
	// PRCTL_SYMBOL is the arch-specificed one, which receive raw pt_regs from syscall
	unsigned long arg4 = (unsigned long)PT_REGS_SYSCALL_PARM4(real_regs);
#else
	// PRCTL_SYMBOL is the common one, called by C convention in do_syscall_64
	// https://elixir.bootlin.com/linux/v4.15.18/source/arch/x86/entry/common.c#L287
	unsigned long arg4 = (unsigned long)PT_REGS_CCALL_PARM4(real_regs);
#endif
	unsigned long arg5 = (unsigned long)PT_REGS_PARM5(real_regs);

	return ksu_handle_prctl(option, arg2, arg3, arg4, arg5);
}

static struct kprobe prctl_kp = {
	.symbol_name = PRCTL_SYMBOL,
	.pre_handler = handler_pre,
};

static int renameat_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
	// https://elixir.bootlin.com/linux/v5.12-rc1/source/include/linux/fs.h
	struct renamedata *rd = PT_REGS_PARM1(regs);
	struct dentry *old_entry = rd->old_dentry;
	struct dentry *new_entry = rd->new_dentry;
#else
	struct dentry *old_entry = (struct dentry *)PT_REGS_PARM2(regs);
	struct dentry *new_entry = (struct dentry *)PT_REGS_CCALL_PARM4(regs);
#endif

	return ksu_handle_rename(old_entry, new_entry);
}

static struct kprobe renameat_kp = {
	.symbol_name = "vfs_rename",
	.pre_handler = renameat_handler_pre,
};

__maybe_unused int ksu_kprobe_init(void)
{
	int rc = 0;
	rc = register_kprobe(&prctl_kp);

	if (rc) {
		pr_info("prctl kprobe failed: %d.\n", rc);
		return rc;
	}

	rc = register_kprobe(&renameat_kp);
	pr_info("renameat kp: %d\n", rc);

	return rc;
}

__maybe_unused int ksu_kprobe_exit(void)
{
	unregister_kprobe(&prctl_kp);
	unregister_kprobe(&renameat_kp);
	return 0;
}

static int ksu_task_prctl(int option, unsigned long arg2, unsigned long arg3,
			  unsigned long arg4, unsigned long arg5)
{
	ksu_handle_prctl(option, arg2, arg3, arg4, arg5);
	return -ENOSYS;
}
// kernel 4.4 and 4.9
#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
static int ksu_key_permission(key_ref_t key_ref, const struct cred *cred,
			      unsigned perm)
{
	if (init_session_keyring != NULL) {
		return 0;
	}
	if (strcmp(current->comm, "init")) {
		// we are only interested in `init` process
		return 0;
	}
	init_session_keyring = cred->session_keyring;
	pr_info("kernel_compat: got init_session_keyring");
	return 0;
}
#endif
static int ksu_inode_rename(struct inode *old_inode, struct dentry *old_dentry,
			    struct inode *new_inode, struct dentry *new_dentry)
{
	return ksu_handle_rename(old_dentry, new_dentry);
}

static int ksu_task_fix_setuid(struct cred *new, const struct cred *old,
			       int flags)
{
	return ksu_handle_setuid(new, old);
}

static struct security_hook_list ksu_hooks[] = {
	LSM_HOOK_INIT(task_prctl, ksu_task_prctl),
	LSM_HOOK_INIT(inode_rename, ksu_inode_rename),
	LSM_HOOK_INIT(task_fix_setuid, ksu_task_fix_setuid),
#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
	LSM_HOOK_INIT(key_permission, ksu_key_permission)
#endif
};

void __init ksu_lsm_hook_init(void)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
	security_add_hooks(ksu_hooks, ARRAY_SIZE(ksu_hooks), "ksu");
#else
	// https://elixir.bootlin.com/linux/v4.10.17/source/include/linux/lsm_hooks.h#L1892
	security_add_hooks(ksu_hooks, ARRAY_SIZE(ksu_hooks));
#endif
}

void __init ksu_core_init(void)
{
#ifndef MODULE
	pr_info("ksu_lsm_hook_init\n");
	ksu_lsm_hook_init();
#else
	pr_info("ksu_kprobe_init\n");
	ksu_kprobe_init();
#endif
}

void ksu_core_exit(void)
{
#ifndef MODULE
	pr_info("ksu_kprobe_exit\n");
	ksu_kprobe_exit();
#endif
}

```

`kernel/core_hook.h`:

```h
#ifndef __KSU_H_KSU_CORE
#define __KSU_H_KSU_CORE

#include "linux/init.h"

void __init ksu_core_init(void);
void ksu_core_exit(void);

#endif

```

`kernel/embed_ksud.c`:

```c
// WARNING: THIS IS A STUB FILE
// This file will be regenerated by CI

unsigned int ksud_size = 0;
const char ksud[0] = {};

```

`kernel/export_symbol.txt`:

```txt
register_kprobe
unregister_kprobe

```

`kernel/include/ksu_hook.h`:

```h
#ifndef __KSU_H_KSHOOK
#define __KSU_H_KSHOOK

#include "linux/fs.h"
#include "linux/types.h"

// For sucompat

int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
			 int *flags);

int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);

// For ksud

int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
			size_t *count_ptr, loff_t **pos);

// For ksud and sucompat

int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
			void *envp, int *flags);

// For volume button
int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, 
				  int *value);

#endif

```

`kernel/kernel_compat.c`:

```c
#include "linux/version.h"
#include "linux/fs.h"
#include "linux/nsproxy.h"
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
#include "linux/sched/task.h"
#include "linux/uaccess.h"
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
#include "linux/uaccess.h"
#include "linux/sched.h"
#else
#include "linux/sched.h"
#endif
#include "klog.h" // IWYU pragma: keep

#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
#include "linux/key.h"
#include "linux/errno.h"
struct key *init_session_keyring = NULL;

static inline int install_session_keyring(struct key *keyring)
{
	struct cred *new;
	int ret;

	new = prepare_creds();
	if (!new)
		return -ENOMEM;

	ret = install_session_keyring_to_cred(new, keyring);
	if (ret < 0) {
		abort_creds(new);
		return ret;
	}

	return commit_creds(new);
}
#endif

extern struct task_struct init_task;

// mnt_ns context switch for environment that android_init->nsproxy->mnt_ns != init_task.nsproxy->mnt_ns, such as WSA
struct ksu_ns_fs_saved {
	struct nsproxy *ns;
	struct fs_struct *fs;
};

static void ksu_save_ns_fs(struct ksu_ns_fs_saved *ns_fs_saved)
{
	ns_fs_saved->ns = current->nsproxy;
	ns_fs_saved->fs = current->fs;
}

static void ksu_load_ns_fs(struct ksu_ns_fs_saved *ns_fs_saved)
{
	current->nsproxy = ns_fs_saved->ns;
	current->fs = ns_fs_saved->fs;
}

static bool android_context_saved_checked = false;
static bool android_context_saved_enabled = false;
static struct ksu_ns_fs_saved android_context_saved;

void ksu_android_ns_fs_check()
{
	if (android_context_saved_checked)
		return;
	android_context_saved_checked = true;
	task_lock(current);
	if (current->nsproxy && current->fs &&
	    current->nsproxy->mnt_ns != init_task.nsproxy->mnt_ns) {
		android_context_saved_enabled = true;
		pr_info("android context saved enabled due to init mnt_ns(%p) != android mnt_ns(%p)\n",
			current->nsproxy->mnt_ns, init_task.nsproxy->mnt_ns);
		ksu_save_ns_fs(&android_context_saved);
	} else {
		pr_info("android context saved disabled\n");
	}
	task_unlock(current);
}

struct file *ksu_filp_open_compat(const char *filename, int flags, umode_t mode)
{
#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
	if (init_session_keyring != NULL && !current_cred()->session_keyring &&
	    (current->flags & PF_WQ_WORKER)) {
		pr_info("installing init session keyring for older kernel\n");
		install_session_keyring(init_session_keyring);
	}
#endif
	// switch mnt_ns even if current is not wq_worker, to ensure what we open is the correct file in android mnt_ns, rather than user created mnt_ns
	struct ksu_ns_fs_saved saved;
	if (android_context_saved_enabled) {
		pr_info("start switch current nsproxy and fs to android context\n");
		task_lock(current);
		ksu_save_ns_fs(&saved);
		ksu_load_ns_fs(&android_context_saved);
		task_unlock(current);
	}
	struct file *fp = filp_open(filename, flags, mode);
	if (android_context_saved_enabled) {
		task_lock(current);
		ksu_load_ns_fs(&saved);
		task_unlock(current);
		pr_info("switch current nsproxy and fs back to saved successfully\n");
	}
	return fp;
}

ssize_t ksu_kernel_read_compat(struct file *p, void *buf, size_t count,
			       loff_t *pos)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
	return kernel_read(p, buf, count, pos);
#else
	loff_t offset = pos ? *pos : 0;
	ssize_t result = kernel_read(p, offset, (char *)buf, count);
	if (pos && result > 0) {
		*pos = offset + result;
	}
	return result;
#endif
}

ssize_t ksu_kernel_write_compat(struct file *p, const void *buf, size_t count,
				loff_t *pos)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
	return kernel_write(p, buf, count, pos);
#else
	loff_t offset = pos ? *pos : 0;
	ssize_t result = kernel_write(p, buf, count, offset);
	if (pos && result > 0) {
		*pos = offset + result;
	}
	return result;
#endif
}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
long ksu_strncpy_from_user_nofault(char *dst, const void __user *unsafe_addr,
				   long count)
{
	return strncpy_from_user_nofault(dst, unsafe_addr, count);
}
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
long ksu_strncpy_from_user_nofault(char *dst, const void __user *unsafe_addr,
				   long count)
{
	return strncpy_from_unsafe_user(dst, unsafe_addr, count);
}
#else
// Copied from: https://elixir.bootlin.com/linux/v4.9.337/source/mm/maccess.c#L201
long ksu_strncpy_from_user_nofault(char *dst, const void __user *unsafe_addr,
				   long count)
{
	mm_segment_t old_fs = get_fs();
	long ret;

	if (unlikely(count <= 0))
		return 0;

	set_fs(USER_DS);
	pagefault_disable();
	ret = strncpy_from_user(dst, unsafe_addr, count);
	pagefault_enable();
	set_fs(old_fs);

	if (ret >= count) {
		ret = count;
		dst[ret - 1] = '\0';
	} else if (ret > 0) {
		ret++;
	}

	return ret;
}
#endif
```

`kernel/kernel_compat.h`:

```h
#ifndef __KSU_H_KERNEL_COMPAT
#define __KSU_H_KERNEL_COMPAT

#include "linux/fs.h"
#include "linux/key.h"
#include "linux/version.h"

extern long ksu_strncpy_from_user_nofault(char *dst,
					  const void __user *unsafe_addr,
					  long count);

#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
extern struct key *init_session_keyring;
#endif

extern void ksu_android_ns_fs_check();
extern struct file *ksu_filp_open_compat(const char *filename, int flags,
					 umode_t mode);
extern ssize_t ksu_kernel_read_compat(struct file *p, void *buf, size_t count,
				      loff_t *pos);
extern ssize_t ksu_kernel_write_compat(struct file *p, const void *buf,
				       size_t count, loff_t *pos);

#endif

```

`kernel/klog.h`:

```h
#ifndef __KSU_H_KLOG
#define __KSU_H_KLOG

#include <linux/printk.h>

#ifdef pr_fmt
#undef pr_fmt
#define pr_fmt(fmt) "KernelSU: " fmt
#endif

#endif

```

`kernel/ksu.c`:

```c
#include "linux/fs.h"
#include "linux/module.h"
#include "linux/workqueue.h"

#include "allowlist.h"
#include "arch.h"
#include "core_hook.h"
#include "klog.h" // IWYU pragma: keep
#include "ksu.h"
#include "uid_observer.h"

static struct workqueue_struct *ksu_workqueue;

bool ksu_queue_work(struct work_struct *work)
{
	return queue_work(ksu_workqueue, work);
}

extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
					void *argv, void *envp, int *flags);

extern int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
				    void *argv, void *envp, int *flags);

int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
			void *envp, int *flags)
{
	ksu_handle_execveat_ksud(fd, filename_ptr, argv, envp, flags);
	return ksu_handle_execveat_sucompat(fd, filename_ptr, argv, envp,
					    flags);
}

extern void ksu_enable_sucompat();
extern void ksu_enable_ksud();

int __init kernelsu_init(void)
{
#ifdef CONFIG_KSU_DEBUG
	pr_alert("*************************************************************");
	pr_alert("**     NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE    **");
	pr_alert("**                                                         **");
	pr_alert("**         You are running KernelSU in DEBUG mode          **");
	pr_alert("**                                                         **");
	pr_alert("**     NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE    **");
	pr_alert("*************************************************************");
#endif

	ksu_core_init();

	ksu_workqueue = alloc_ordered_workqueue("kernelsu_work_queue", 0);

	ksu_allowlist_init();

	ksu_uid_observer_init();

#ifdef CONFIG_KPROBES
	ksu_enable_sucompat();
	ksu_enable_ksud();
#else
	pr_alert("KPROBES is disabled, KernelSU may not work, please check https://kernelsu.org/guide/how-to-integrate-for-non-gki.html");
#endif

	return 0;
}

void kernelsu_exit(void)
{
	ksu_allowlist_exit();

	ksu_uid_observer_exit();

	destroy_workqueue(ksu_workqueue);

	ksu_core_exit();
}

module_init(kernelsu_init);
module_exit(kernelsu_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("NekoYuzu");
MODULE_DESCRIPTION("KernelSU Debug");

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
#endif

```

`kernel/ksu.h`:

```h
#ifndef __KSU_H_KSU
#define __KSU_H_KSU

#include "linux/types.h"
#include "linux/workqueue.h"

#define KERNEL_SU_VERSION KSU_VERSION
#define KERNEL_SU_OPTION 0xDEADBEEF

#define CMD_GRANT_ROOT 0
#define CMD_BECOME_MANAGER 1
#define CMD_GET_VERSION 2
#define CMD_ALLOW_SU 3
#define CMD_DENY_SU 4
#define CMD_GET_ALLOW_LIST 5
#define CMD_GET_DENY_LIST 6
#define CMD_REPORT_EVENT 7
#define CMD_SET_SEPOLICY 8
#define CMD_CHECK_SAFEMODE 9
#define CMD_GET_APP_PROFILE 10
#define CMD_SET_APP_PROFILE 11
#define CMD_UID_GRANTED_ROOT 12
#define CMD_UID_SHOULD_UMOUNT 13

#define EVENT_POST_FS_DATA 1
#define EVENT_BOOT_COMPLETED 2

#define KSU_APP_PROFILE_VER 2
#define KSU_MAX_PACKAGE_NAME 256
// NGROUPS_MAX for Linux is 65535 generally, but we only supports 32 groups.
#define KSU_MAX_GROUPS 32
#define KSU_SELINUX_DOMAIN 64

struct root_profile {
	int32_t uid;
	int32_t gid;

	int32_t groups_count;
	int32_t groups[KSU_MAX_GROUPS];

	// kernel_cap_t is u32[2] for capabilities v3
	struct {
		u64 effective;
		u64 permitted;
		u64 inheritable;
	} capabilities;

	char selinux_domain[KSU_SELINUX_DOMAIN];

	int32_t namespaces;
};

struct non_root_profile {
	bool umount_modules;
};

struct app_profile {
	// It may be utilized for backward compatibility, although we have never explicitly made any promises regarding this.
	u32 version;

	// this is usually the package of the app, but can be other value for special apps
	char key[KSU_MAX_PACKAGE_NAME];
	int32_t current_uid;
	bool allow_su;

	union {
		struct {
			bool use_default;
			char template_name[KSU_MAX_PACKAGE_NAME];

			struct root_profile profile;
		} rp_config;

		struct {
			bool use_default;

			struct non_root_profile profile;
		} nrp_config;
	};
};

bool ksu_queue_work(struct work_struct *work);

static inline int startswith(char *s, char *prefix)
{
	return strncmp(s, prefix, strlen(prefix));
}

static inline int endswith(const char *s, const char *t)
{
	size_t slen = strlen(s);
	size_t tlen = strlen(t);
	if (tlen > slen)
		return 1;
	return strcmp(s + slen - tlen, t);
}

#endif

```

`kernel/ksud.c`:

```c
#include "asm/current.h"
#include "linux/compat.h"
#include "linux/dcache.h"
#include "linux/err.h"
#include "linux/fs.h"
#include "linux/input-event-codes.h"
#include "linux/kprobes.h"
#include "linux/printk.h"
#include "linux/types.h"
#include "linux/uaccess.h"
#include "linux/version.h"
#include "linux/workqueue.h"

#include "allowlist.h"
#include "arch.h"
#include "klog.h" // IWYU pragma: keep
#include "ksud.h"
#include "kernel_compat.h"
#include "selinux/selinux.h"

static const char KERNEL_SU_RC[] =
	"\n"

	"on post-fs-data\n"
	"    start logd\n"
	// We should wait for the post-fs-data finish
	"    exec u:r:su:s0 root -- " KSUD_PATH " post-fs-data\n"
	"\n"

	"on nonencrypted\n"
	"    exec u:r:su:s0 root -- " KSUD_PATH " services\n"
	"\n"

	"on property:vold.decrypt=trigger_restart_framework\n"
	"    exec u:r:su:s0 root -- " KSUD_PATH " services\n"
	"\n"

	"on property:sys.boot_completed=1\n"
	"    exec u:r:su:s0 root -- " KSUD_PATH " boot-completed\n"
	"\n"

	"\n";

static void stop_vfs_read_hook();
static void stop_execve_hook();
static void stop_input_hook();

#ifdef CONFIG_KPROBES
static struct work_struct stop_vfs_read_work;
static struct work_struct stop_execve_hook_work;
static struct work_struct stop_input_hook_work;
#else
bool ksu_vfs_read_hook __read_mostly = true;
bool ksu_execveat_hook __read_mostly = true;
bool ksu_input_hook __read_mostly = true;
#endif

void on_post_fs_data(void)
{
	static bool done = false;
	if (done) {
		pr_info("on_post_fs_data already done");
		return;
	}
	done = true;
	pr_info("on_post_fs_data!");
	ksu_load_allow_list();
	// sanity check, this may influence the performance
	stop_input_hook();
}

#define MAX_ARG_STRINGS 0x7FFFFFFF
struct user_arg_ptr {
#ifdef CONFIG_COMPAT
	bool is_compat;
#endif
	union {
		const char __user *const __user *native;
#ifdef CONFIG_COMPAT
		const compat_uptr_t __user *compat;
#endif
	} ptr;
};

static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)
{
	const char __user *native;

#ifdef CONFIG_COMPAT
	if (unlikely(argv.is_compat)) {
		compat_uptr_t compat;

		if (get_user(compat, argv.ptr.compat + nr))
			return ERR_PTR(-EFAULT);

		return compat_ptr(compat);
	}
#endif

	if (get_user(native, argv.ptr.native + nr))
		return ERR_PTR(-EFAULT);

	return native;
}

/*
 * count() counts the number of strings in array ARGV.
 */

 /*
 * Make sure old GCC compiler can use __maybe_unused,
 * Test passed in 4.4.x ~ 4.9.x when use GCC.
 */

static int __maybe_unused count(struct user_arg_ptr argv, int max)
{
	int i = 0;

	if (argv.ptr.native != NULL) {
		for (;;) {
			const char __user *p = get_user_arg_ptr(argv, i);

			if (!p)
				break;

			if (IS_ERR(p))
				return -EFAULT;

			if (i >= max)
				return -E2BIG;
			++i;

			if (fatal_signal_pending(current))
				return -ERESTARTNOHAND;
			cond_resched();
		}
	}
	return i;
}

// the call from execve_handler_pre won't provided correct value for __never_use_argument, use them after fix execve_handler_pre, keeping them for consistence for manually patched code
int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
			     struct user_arg_ptr *argv, void *__never_use_envp, int *__never_use_flags)
{
#ifndef CONFIG_KPROBES
	if (!ksu_execveat_hook) {
		return 0;
	}
#endif
	struct filename *filename;

	static const char app_process[] = "/system/bin/app_process";
	static bool first_app_process = true;
	static const char system_bin_init[] = "/system/bin/init";
	static bool init_second_stage_executed = false;

	if (!filename_ptr)
		return 0;

	filename = *filename_ptr;
	if (IS_ERR(filename)) {
		return 0;
	}

	if (unlikely(!memcmp(filename->name, system_bin_init,
		    sizeof(system_bin_init) - 1))) {
		// /system/bin/init executed
		int argc = count(*argv, MAX_ARG_STRINGS);
		pr_info("/system/bin/init argc: %d\n", argc);
		if (argc > 1 && !init_second_stage_executed) {
			const char __user *p = get_user_arg_ptr(*argv, 1);
			if (p && !IS_ERR(p)) {
				char first_arg[16];
                                ksu_strncpy_from_user_nofault(first_arg, p, sizeof(first_arg));
				pr_info("first arg: %s\n", first_arg);
				if (!strcmp(first_arg, "second_stage")) {
					pr_info("/system/bin/init second_stage executed\n");
					apply_kernelsu_rules();
					init_second_stage_executed = true;
					ksu_android_ns_fs_check();
				}
			} else {
				pr_err("/system/bin/init parse args err!\n");
			}
		}
	}

	if (unlikely(first_app_process &&
	    !memcmp(filename->name, app_process, sizeof(app_process) - 1))) {
		first_app_process = false;
		pr_info("exec app_process, /data prepared, second_stage: %d\n", init_second_stage_executed);
		on_post_fs_data(); // we keep this for old ksud
		stop_execve_hook();
	}

	return 0;
}

static ssize_t (*orig_read)(struct file *, char __user *, size_t, loff_t *);
static ssize_t (*orig_read_iter)(struct kiocb *, struct iov_iter *);
static struct file_operations fops_proxy;
static ssize_t read_count_append = 0;

static ssize_t read_proxy(struct file *file, char __user *buf, size_t count,
			  loff_t *pos)
{
	bool first_read = file->f_pos == 0;
	ssize_t ret = orig_read(file, buf, count, pos);
	if (first_read) {
		pr_info("read_proxy append %ld + %ld", ret, read_count_append);
		ret += read_count_append;
	}
	return ret;
}

static ssize_t read_iter_proxy(struct kiocb *iocb, struct iov_iter *to)
{
	bool first_read = iocb->ki_pos == 0;
	ssize_t ret = orig_read_iter(iocb, to);
	if (first_read) {
		pr_info("read_iter_proxy append %ld + %ld", ret,
			read_count_append);
		ret += read_count_append;
	}
	return ret;
}

int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
			size_t *count_ptr, loff_t **pos)
{
#ifndef CONFIG_KPROBES
	if (!ksu_vfs_read_hook) {
		return 0;
	}
#endif
	struct file *file;
	char __user *buf;
	size_t count;

	if (strcmp(current->comm, "init")) {
		// we are only interest in `init` process
		return 0;
	}

	file = *file_ptr;
	if (IS_ERR(file)) {
		return 0;
	}

	if (!d_is_reg(file->f_path.dentry)) {
		return 0;
	}

	const char *short_name = file->f_path.dentry->d_name.name;
	if (strcmp(short_name, "atrace.rc")) {
		// we are only interest `atrace.rc` file name file
		return 0;
	}
	char path[256];
	char *dpath = d_path(&file->f_path, path, sizeof(path));

	if (IS_ERR(dpath)) {
		return 0;
	}

	if (strcmp(dpath, "/system/etc/init/atrace.rc")) {
		return 0;
	}

	// we only process the first read
	static bool rc_inserted = false;
	if (rc_inserted) {
		// we don't need this kprobe, unregister it!
		stop_vfs_read_hook();
		return 0;
	}
	rc_inserted = true;

	// now we can sure that the init process is reading
	// `/system/etc/init/atrace.rc`
	buf = *buf_ptr;
	count = *count_ptr;

	size_t rc_count = strlen(KERNEL_SU_RC);

	pr_info("vfs_read: %s, comm: %s, count: %d, rc_count: %d\n", dpath,
		current->comm, count, rc_count);

	if (count < rc_count) {
		pr_err("count: %d < rc_count: %d", count, rc_count);
		return 0;
	}

	size_t ret = copy_to_user(buf, KERNEL_SU_RC, rc_count);
	if (ret) {
		pr_err("copy ksud.rc failed: %d\n", ret);
		return 0;
	}

	// we've succeed to insert ksud.rc, now we need to proxy the read and modify the result!
	// But, we can not modify the file_operations directly, because it's in read-only memory.
	// We just replace the whole file_operations with a proxy one.
	memcpy(&fops_proxy, file->f_op, sizeof(struct file_operations));
	orig_read = file->f_op->read;
	if (orig_read) {
		fops_proxy.read = read_proxy;
	}
	orig_read_iter = file->f_op->read_iter;
	if (orig_read_iter) {
		fops_proxy.read_iter = read_iter_proxy;
	}
	// replace the file_operations
	file->f_op = &fops_proxy;
	read_count_append = rc_count;

	*buf_ptr = buf + rc_count;
	*count_ptr = count - rc_count;

	return 0;
}

static unsigned int volumedown_pressed_count = 0;

static bool is_volumedown_enough(unsigned int count)
{
	return count >= 3;
}

int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code,
				  int *value)
{
#ifndef CONFIG_KPROBES
	if (!ksu_input_hook) {
		return 0;
	}
#endif
	if (*type == EV_KEY && *code == KEY_VOLUMEDOWN) {
		int val = *value;
		pr_info("KEY_VOLUMEDOWN val: %d\n", val);
		if (val) {
			// key pressed, count it
			volumedown_pressed_count += 1;
			if (is_volumedown_enough(volumedown_pressed_count)) {
				stop_input_hook();
			}
		}
	}

	return 0;
}

bool ksu_is_safe_mode()
{
	static bool safe_mode = false;
	if (safe_mode) {
		// don't need to check again, userspace may call multiple times
		return true;
	}

	// stop hook first!
	stop_input_hook();

	pr_info("volumedown_pressed_count: %d\n", volumedown_pressed_count);
	if (is_volumedown_enough(volumedown_pressed_count)) {
		// pressed over 3 times
		pr_info("KEY_VOLUMEDOWN pressed max times, safe mode detected!\n");
		safe_mode = true;
		return true;
	}

	return false;
}

#ifdef CONFIG_KPROBES

// https://elixir.bootlin.com/linux/v5.10.158/source/fs/exec.c#L1864
static int execve_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	int *fd = (int *)&PT_REGS_PARM1(regs);
	struct filename **filename_ptr =
		(struct filename **)&PT_REGS_PARM2(regs);
	struct user_arg_ptr argv;
#ifdef CONFIG_COMPAT
	argv.is_compat = PT_REGS_PARM3(regs);
	if (unlikely(argv.is_compat)) {
		argv.ptr.compat = PT_REGS_CCALL_PARM4(regs);
	} else {
		argv.ptr.native = PT_REGS_CCALL_PARM4(regs);
	}
#else
	argv.ptr.native = PT_REGS_PARM3(regs);
#endif

	return ksu_handle_execveat_ksud(fd, filename_ptr, &argv, NULL, NULL);
}

static int read_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	struct file **file_ptr = (struct file **)&PT_REGS_PARM1(regs);
	char __user **buf_ptr = (char **)&PT_REGS_PARM2(regs);
	size_t *count_ptr = (size_t *)&PT_REGS_PARM3(regs);
	loff_t **pos_ptr = (loff_t **)&PT_REGS_CCALL_PARM4(regs);

	return ksu_handle_vfs_read(file_ptr, buf_ptr, count_ptr, pos_ptr);
}

static int input_handle_event_handler_pre(struct kprobe *p,
					  struct pt_regs *regs)
{
	unsigned int *type = (unsigned int *)&PT_REGS_PARM2(regs);
	unsigned int *code = (unsigned int *)&PT_REGS_PARM3(regs);
	int *value = (int *)&PT_REGS_CCALL_PARM4(regs);
	return ksu_handle_input_handle_event(type, code, value);
}

static struct kprobe execve_kp = {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
	.symbol_name = "do_execveat_common",
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
	.symbol_name = "__do_execve_file",
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
	.symbol_name = "do_execveat_common",
#endif
	.pre_handler = execve_handler_pre,
};

static struct kprobe vfs_read_kp = {
	.symbol_name = "vfs_read",
	.pre_handler = read_handler_pre,
};

static struct kprobe input_handle_event_kp = {
	.symbol_name = "input_handle_event",
	.pre_handler = input_handle_event_handler_pre,
};

static void do_stop_vfs_read_hook(struct work_struct *work)
{
	unregister_kprobe(&vfs_read_kp);
}

static void do_stop_execve_hook(struct work_struct *work)
{
	unregister_kprobe(&execve_kp);
}

static void do_stop_input_hook(struct work_struct *work)
{
	unregister_kprobe(&input_handle_event_kp);
}
#endif

static void stop_vfs_read_hook()
{
#ifdef CONFIG_KPROBES
	bool ret = schedule_work(&stop_vfs_read_work);
	pr_info("unregister vfs_read kprobe: %d!\n", ret);
#else
	ksu_vfs_read_hook = false;
#endif
}

static void stop_execve_hook()
{
#ifdef CONFIG_KPROBES
	bool ret = schedule_work(&stop_execve_hook_work);
	pr_info("unregister execve kprobe: %d!\n", ret);
#else
	ksu_execveat_hook = false;
#endif
}

static void stop_input_hook()
{
	static bool input_hook_stopped = false;
	if (input_hook_stopped) {
		return;
	}
	input_hook_stopped = true;
#ifdef CONFIG_KPROBES
	bool ret = schedule_work(&stop_input_hook_work);
	pr_info("unregister input kprobe: %d!\n", ret);
#else
	ksu_input_hook = false;
#endif
}

// ksud: module support
void ksu_enable_ksud()
{
#ifdef CONFIG_KPROBES
	int ret;

	ret = register_kprobe(&execve_kp);
	pr_info("ksud: execve_kp: %d\n", ret);

	ret = register_kprobe(&vfs_read_kp);
	pr_info("ksud: vfs_read_kp: %d\n", ret);

	ret = register_kprobe(&input_handle_event_kp);
	pr_info("ksud: input_handle_event_kp: %d\n", ret);

	INIT_WORK(&stop_vfs_read_work, do_stop_vfs_read_hook);
	INIT_WORK(&stop_execve_hook_work, do_stop_execve_hook);
	INIT_WORK(&stop_input_hook_work, do_stop_input_hook);
#endif
}

```

`kernel/ksud.h`:

```h
#ifndef __KSU_H_KSUD
#define __KSU_H_KSUD

#define KSUD_PATH "/data/adb/ksud"

void on_post_fs_data(void);

bool ksu_is_safe_mode(void);

#endif

```

`kernel/manager.c`:

```c
#include "linux/cred.h"
#include "linux/gfp.h"
#include "linux/slab.h"
#include "linux/uidgid.h"
#include "linux/version.h"

#include "linux/fdtable.h"
#include "linux/fs.h"
#include "linux/rcupdate.h"

#include "apk_sign.h"
#include "klog.h" // IWYU pragma: keep
#include "ksu.h"
#include "manager.h"

uid_t ksu_manager_uid = KSU_INVALID_UID;

bool become_manager(char *pkg)
{
	struct fdtable *files_table;
	int i = 0;
	struct path files_path;
	char *cwd;
	char *buf;
	bool result = false;

	// must be zygote's direct child, otherwise any app can fork a new process and
	// open manager's apk
	if (task_uid(current->real_parent).val != 0) {
		pr_info("parent is not zygote!\n");
		return false;
	}

	buf = (char *)kmalloc(PATH_MAX, GFP_ATOMIC);
	if (!buf) {
		pr_err("kalloc path failed.\n");
		return false;
	}

	files_table = files_fdtable(current->files);

	int pkg_len = strlen(pkg);
	// todo: use iterate_fd
	for (i = 0; files_table->fd[i] != NULL; i++) {
		files_path = files_table->fd[i]->f_path;
		if (!d_is_reg(files_path.dentry)) {
			continue;
		}
		cwd = d_path(&files_path, buf, PATH_MAX);
		if (startswith(cwd, "/data/app/") != 0 ||
		    endswith(cwd, "/base.apk") != 0) {
			continue;
		}
		// we have found the apk!
		pr_info("found apk: %s", cwd);
		char *pkg_index = strstr(cwd, pkg);
		if (!pkg_index) {
			pr_info("apk path not match package name!\n");
			continue;
		}
		char *next_char = pkg_index + pkg_len;
		// because we ensure the cwd must startswith `/data/app` and endswith `base.apk`
		// we don't need to check if the pointer is out of bounds
		if (*next_char != '-') {
			// from android 8.1: http://aospxref.com/android-8.1.0_r81/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java#17612
			// to android 13: http://aospxref.com/android-13.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerServiceUtils.java#1208
			// /data/app/~~[randomStringA]/[packageName]-[randomStringB]
			// the previous char must be `/` and the next char must be `-`
			// because we use strstr instead of equals, this is a strong verfication.
			pr_info("invalid pkg: %s\n", pkg);
			continue;
		}
		if (is_manager_apk(cwd) == 0) {
			// check passed
			uid_t uid = current_uid().val;
			pr_info("manager uid: %d\n", uid);

			ksu_set_manager_uid(uid);

			result = true;
			goto clean;
		} else {
			pr_info("manager signature invalid!");
		}

		break;
	}

clean:
	kfree(buf);
	return result;
}

```

`kernel/manager.h`:

```h
#ifndef __KSU_H_KSU_MANAGER
#define __KSU_H_KSU_MANAGER

#include "linux/cred.h"
#include "linux/types.h"

#define KSU_INVALID_UID -1

extern uid_t ksu_manager_uid; // DO NOT DIRECT USE

static inline bool ksu_is_manager_uid_valid()
{
	return ksu_manager_uid != KSU_INVALID_UID;
}

static inline bool is_manager()
{
	return unlikely(ksu_manager_uid == current_uid().val);
}

static inline uid_t ksu_get_manager_uid()
{
	return ksu_manager_uid;
}

static inline void ksu_set_manager_uid(uid_t uid)
{
	ksu_manager_uid = uid;
}

static inline void ksu_invalidate_manager_uid()
{
	ksu_manager_uid = KSU_INVALID_UID;
}

bool become_manager(char *pkg);

#endif

```

`kernel/module_api.c`:

```c
#include "linux/kallsyms.h"

#define RE_EXPORT_SYMBOL1(ret, func, t1, v1)                                   \
	ret ksu_##func(t1 v1)                                                  \
	{                                                                      \
		return func(v1);                                               \
	}                                                                      \
	EXPORT_SYMBOL(ksu_##func);

#define RE_EXPORT_SYMBOL2(ret, func, t1, v1, t2, v2)                           \
	ret ksu_##func(t1 v1, t2 v2)                                           \
	{                                                                      \
		return func(v1, v2);                                           \
	}                                                                      \
	EXPORT_SYMBOL(ksu_##func);

RE_EXPORT_SYMBOL1(unsigned long, kallsyms_lookup_name, const char *, name)

// RE_EXPORT_SYMBOL2(int, register_kprobe, struct kprobe *, p)
// RE_EXPORT_SYMBOL2(void, unregister_kprobe, struct kprobe *, p)

// RE_EXPORT_SYMBOL2(int, register_kprobe, struct kprobe *, p)
// RE_EXPORT_SYMBOL2(void, unregister_kprobe, struct kprobe *, p)

// int ksu_register_kprobe(struct kprobe *p);
// void ksu_unregister_kprobe(struct kprobe *p);
// int ksu_register_kprobes(struct kprobe **kps, int num);
// void ksu_unregister_kprobes(struct kprobe **kps, int num);

// int ksu_register_kretprobe(struct kretprobe *rp);
// void unregister_kretprobe(struct kretprobe *rp);
// int register_kretprobes(struct kretprobe **rps, int num);
// void unregister_kretprobes(struct kretprobe **rps, int num);

```

`kernel/selinux/Makefile`:

```
obj-y += selinux.o
obj-y += sepolicy.o
obj-y += rules.o

ifeq ($(shell grep -q " current_sid(void)" $(srctree)/security/selinux/include/objsec.h; echo $$?),0)
ccflags-y += -DKSU_COMPAT_HAS_CURRENT_SID
endif

ifeq ($(shell grep -q "struct selinux_state " $(srctree)/security/selinux/include/security.h; echo $$?),0)
ccflags-y += -DKSU_COMPAT_HAS_SELINUX_STATE
endif

ccflags-y += -Wno-implicit-function-declaration -Wno-strict-prototypes -Wno-int-conversion
ccflags-y += -Wno-declaration-after-statement -Wno-unused-function
ccflags-y += -I$(srctree)/security/selinux -I$(srctree)/security/selinux/include
ccflags-y += -I$(objtree)/security/selinux -include $(srctree)/include/uapi/asm-generic/errno.h

```

`kernel/selinux/rules.c`:

```c
#include "linux/uaccess.h"
#include "linux/types.h"
#include "linux/version.h"

#include "../klog.h" // IWYU pragma: keep
#include "selinux.h"
#include "sepolicy.h"
#include "ss/services.h"
#include "linux/lsm_audit.h"
#include "xfrm.h"

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
#define SELINUX_POLICY_INSTEAD_SELINUX_SS
#endif

#define KERNEL_SU_DOMAIN "su"
#define KERNEL_SU_FILE "ksu_file"
#define KERNEL_EXEC_TYPE "ksu_exec"
#define ALL NULL

static struct policydb *get_policydb(void)
{
	struct policydb *db;
// selinux_state does not exists before 4.19
#ifdef KSU_COMPAT_USE_SELINUX_STATE
#ifdef SELINUX_POLICY_INSTEAD_SELINUX_SS
	struct selinux_policy *policy = rcu_dereference(selinux_state.policy);
	db = &policy->policydb;
#else
	struct selinux_ss *ss = rcu_dereference(selinux_state.ss);
	db = &ss->policydb;
#endif
#else
	db = &policydb;
#endif
	return db;
}

void apply_kernelsu_rules()
{
	if (!getenforce()) {
		pr_info("SELinux permissive or disabled, apply rules!");
	}
	
	setenforce(false);

	rcu_read_lock();
	struct policydb *db = get_policydb();

	ksu_permissive(db, KERNEL_SU_DOMAIN);
	ksu_typeattribute(db, KERNEL_SU_DOMAIN, "mlstrustedsubject");
	ksu_typeattribute(db, KERNEL_SU_DOMAIN, "netdomain");
	ksu_typeattribute(db, KERNEL_SU_DOMAIN, "bluetoothdomain");

	// Create unconstrained file type
	ksu_type(db, KERNEL_SU_FILE, "file_type");
	ksu_typeattribute(db, KERNEL_SU_FILE, "mlstrustedobject");
	ksu_allow(db, ALL, KERNEL_SU_FILE, ALL, ALL);

	// allow all!
	ksu_allow(db, KERNEL_SU_DOMAIN, ALL, ALL, ALL);

	// allow us do any ioctl
	if (db->policyvers >= POLICYDB_VERSION_XPERMS_IOCTL) {
		ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "blk_file", ALL);
		ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "fifo_file", ALL);
		ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "chr_file", ALL);
	}

	// we need to save allowlist in /data/adb/ksu
	ksu_allow(db, "kernel", "adb_data_file", "dir", ALL);
	ksu_allow(db, "kernel", "adb_data_file", "file", ALL);
	// we may need to do mount on shell
	ksu_allow(db, "kernel", "shell_data_file", "file", ALL);
	// we need to read /data/system/packages.list
	ksu_allow(db, "kernel", "kernel", "capability", "dac_override");
	// Android 10+:
	// http://aospxref.com/android-12.0.0_r3/xref/system/sepolicy/private/file_contexts#512
	ksu_allow(db, "kernel", "packages_list_file", "file", ALL);
	// Kernel 4.4
	ksu_allow(db, "kernel", "packages_list_file", "dir", ALL);
	// Android 9-:
	// http://aospxref.com/android-9.0.0_r61/xref/system/sepolicy/private/file_contexts#360
	ksu_allow(db, "kernel", "system_data_file", "file", ALL);
	ksu_allow(db, "kernel", "system_data_file", "dir", ALL);
	// our ksud triggered by init
	ksu_allow(db, "init", "adb_data_file", "file", ALL);
	ksu_allow(db, "init", KERNEL_SU_DOMAIN, ALL, ALL);

	// copied from Magisk rules
	// suRights
	ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "dir", "search");
	ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "dir", "read");
	ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "file", "open");
	ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "file", "read");
	ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "process", "getattr");
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "process", "sigchld");

	// allowLog
	ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "dir", "search");
	ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "file", "read");
	ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "file", "open");
	ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "file", "getattr");

	// dumpsys
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fd", "use");
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "write");
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "read");
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "open");
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "getattr");

	// bootctl
	ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "dir", "search");
	ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "file", "read");
	ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "file", "open");
	ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "process",
		  "getattr");

	// For mounting loop devices, mirrors, tmpfs
	ksu_allow(db, "kernel", ALL, "file", "read");
	ksu_allow(db, "kernel", ALL, "file", "write");

	// Allow all binder transactions
	ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "binder", ALL);

	// Allow system server devpts
	ksu_allow(db, "system_server", "untrusted_app_all_devpts", "chr_file",
		  "read");
	ksu_allow(db, "system_server", "untrusted_app_all_devpts", "chr_file",
		  "write");

	rcu_read_unlock();
}

#define MAX_SEPOL_LEN 128

#define CMD_NORMAL_PERM 1
#define CMD_XPERM 2
#define CMD_TYPE_STATE 3
#define CMD_TYPE 4
#define CMD_TYPE_ATTR 5
#define CMD_ATTR 6
#define CMD_TYPE_TRANSITION 7
#define CMD_TYPE_CHANGE 8
#define CMD_GENFSCON 9

struct sepol_data {
	u32 cmd;
	u32 subcmd;
	char __user *sepol1;
	char __user *sepol2;
	char __user *sepol3;
	char __user *sepol4;
	char __user *sepol5;
	char __user *sepol6;
	char __user *sepol7;
};

static int get_object(char *buf, char __user *user_object, size_t buf_sz,
		      char **object)
{
	if (!user_object) {
		*object = ALL;
		return 0;
	}

	if (strncpy_from_user(buf, user_object, buf_sz) < 0) {
		return -1;
	}

	*object = buf;

	return 0;
}

// reset avc cache table, otherwise the new rules will not take effect if already denied
static void reset_avc_cache()
{
#ifndef KSU_COMPAT_USE_SELINUX_STATE
	avc_ss_reset(0);
	selnl_notify_policyload(0);
	selinux_status_update_policyload(0);
#else
	struct selinux_avc *avc = selinux_state.avc;
	avc_ss_reset(avc, 0);
	selnl_notify_policyload(0);
	selinux_status_update_policyload(&selinux_state, 0);
#endif
	selinux_xfrm_notify_policyload();
}

int handle_sepolicy(unsigned long arg3, void __user *arg4)
{
	if (!arg4) {
		return -1;
	}

	if (!getenforce()) {
		pr_info("SELinux permissive or disabled when handle policy!\n");
	}

	struct sepol_data data;
	if (copy_from_user(&data, arg4, sizeof(struct sepol_data))) {
		pr_err("sepol: copy sepol_data failed.\n");
		return -1;
	}

	u32 cmd = data.cmd;
	u32 subcmd = data.subcmd;

	rcu_read_lock();

	struct policydb *db = get_policydb();

	int ret = -1;
	if (cmd == CMD_NORMAL_PERM) {
		char src_buf[MAX_SEPOL_LEN];
		char tgt_buf[MAX_SEPOL_LEN];
		char cls_buf[MAX_SEPOL_LEN];
		char perm_buf[MAX_SEPOL_LEN];

		char *s, *t, *c, *p;
		if (get_object(src_buf, data.sepol1, sizeof(src_buf), &s) < 0) {
			pr_err("sepol: copy src failed.\n");
			goto exit;
		}

		if (get_object(tgt_buf, data.sepol2, sizeof(tgt_buf), &t) < 0) {
			pr_err("sepol: copy tgt failed.\n");
			goto exit;
		}

		if (get_object(cls_buf, data.sepol3, sizeof(cls_buf), &c) < 0) {
			pr_err("sepol: copy cls failed.\n");
			goto exit;
		}

		if (get_object(perm_buf, data.sepol4, sizeof(perm_buf), &p) <
		    0) {
			pr_err("sepol: copy perm failed.\n");
			goto exit;
		}

		bool success = false;
		if (subcmd == 1) {
			success = ksu_allow(db, s, t, c, p);
		} else if (subcmd == 2) {
			success = ksu_deny(db, s, t, c, p);
		} else if (subcmd == 3) {
			success = ksu_auditallow(db, s, t, c, p);
		} else if (subcmd == 4) {
			success = ksu_dontaudit(db, s, t, c, p);
		} else {
			pr_err("sepol: unknown subcmd: %d", subcmd);
		}
		ret = success ? 0 : -1;

	} else if (cmd == CMD_XPERM) {
		char src_buf[MAX_SEPOL_LEN];
		char tgt_buf[MAX_SEPOL_LEN];
		char cls_buf[MAX_SEPOL_LEN];

		char __maybe_unused
			operation[MAX_SEPOL_LEN]; // it is always ioctl now!
		char perm_set[MAX_SEPOL_LEN];

		char *s, *t, *c;
		if (get_object(src_buf, data.sepol1, sizeof(src_buf), &s) < 0) {
			pr_err("sepol: copy src failed.\n");
			goto exit;
		}
		if (get_object(tgt_buf, data.sepol2, sizeof(tgt_buf), &t) < 0) {
			pr_err("sepol: copy tgt failed.\n");
			goto exit;
		}
		if (get_object(cls_buf, data.sepol3, sizeof(cls_buf), &c) < 0) {
			pr_err("sepol: copy cls failed.\n");
			goto exit;
		}
		if (strncpy_from_user(operation, data.sepol4,
				      sizeof(operation)) < 0) {
			pr_err("sepol: copy operation failed.\n");
			goto exit;
		}
		if (strncpy_from_user(perm_set, data.sepol5, sizeof(perm_set)) <
		    0) {
			pr_err("sepol: copy perm_set failed.\n");
			goto exit;
		}

		bool success = false;
		if (subcmd == 1) {
			success = ksu_allowxperm(db, s, t, c, perm_set);
		} else if (subcmd == 2) {
			success = ksu_auditallowxperm(db, s, t, c, perm_set);
		} else if (subcmd == 3) {
			success = ksu_dontauditxperm(db, s, t, c, perm_set);
		} else {
			pr_err("sepol: unknown subcmd: %d", subcmd);
		}
		ret = success ? 0 : -1;
	} else if (cmd == CMD_TYPE_STATE) {
		char src[MAX_SEPOL_LEN];

		if (strncpy_from_user(src, data.sepol1, sizeof(src)) < 0) {
			pr_err("sepol: copy src failed.\n");
			goto exit;
		}

		bool success = false;
		if (subcmd == 1) {
			success = ksu_permissive(db, src);
		} else if (subcmd == 2) {
			success = ksu_enforce(db, src);
		} else {
			pr_err("sepol: unknown subcmd: %d", subcmd);
		}
		if (success)
			ret = 0;

	} else if (cmd == CMD_TYPE || cmd == CMD_TYPE_ATTR) {
		char type[MAX_SEPOL_LEN];
		char attr[MAX_SEPOL_LEN];

		if (strncpy_from_user(type, data.sepol1, sizeof(type)) < 0) {
			pr_err("sepol: copy type failed.\n");
			goto exit;
		}
		if (strncpy_from_user(attr, data.sepol2, sizeof(attr)) < 0) {
			pr_err("sepol: copy attr failed.\n");
			goto exit;
		}

		bool success = false;
		if (cmd == CMD_TYPE) {
			success = ksu_type(db, type, attr);
		} else {
			success = ksu_typeattribute(db, type, attr);
		}
		if (!success) {
			pr_err("sepol: %d failed.\n", cmd);
			goto exit;
		}
		ret = 0;

	} else if (cmd == CMD_ATTR) {
		char attr[MAX_SEPOL_LEN];

		if (strncpy_from_user(attr, data.sepol1, sizeof(attr)) < 0) {
			pr_err("sepol: copy attr failed.\n");
			goto exit;
		}
		if (!ksu_attribute(db, attr)) {
			pr_err("sepol: %d failed.\n", cmd);
			goto exit;
		}
		ret = 0;

	} else if (cmd == CMD_TYPE_TRANSITION) {
		char src[MAX_SEPOL_LEN];
		char tgt[MAX_SEPOL_LEN];
		char cls[MAX_SEPOL_LEN];
		char default_type[MAX_SEPOL_LEN];
		char object[MAX_SEPOL_LEN];

		if (strncpy_from_user(src, data.sepol1, sizeof(src)) < 0) {
			pr_err("sepol: copy src failed.\n");
			goto exit;
		}
		if (strncpy_from_user(tgt, data.sepol2, sizeof(tgt)) < 0) {
			pr_err("sepol: copy tgt failed.\n");
			goto exit;
		}
		if (strncpy_from_user(cls, data.sepol3, sizeof(cls)) < 0) {
			pr_err("sepol: copy cls failed.\n");
			goto exit;
		}
		if (strncpy_from_user(default_type, data.sepol4,
				      sizeof(default_type)) < 0) {
			pr_err("sepol: copy default_type failed.\n");
			goto exit;
		}
		char *real_object;
		if (data.sepol5 == NULL) {
			real_object = NULL;
		} else {
			if (strncpy_from_user(object, data.sepol5,
					      sizeof(object)) < 0) {
				pr_err("sepol: copy object failed.\n");
				goto exit;
			}
			real_object = object;
		}

		bool success = ksu_type_transition(db, src, tgt, cls,
						   default_type, real_object);
		if (success)
			ret = 0;

	} else if (cmd == CMD_TYPE_CHANGE) {
		char src[MAX_SEPOL_LEN];
		char tgt[MAX_SEPOL_LEN];
		char cls[MAX_SEPOL_LEN];
		char default_type[MAX_SEPOL_LEN];

		if (strncpy_from_user(src, data.sepol1, sizeof(src)) < 0) {
			pr_err("sepol: copy src failed.\n");
			goto exit;
		}
		if (strncpy_from_user(tgt, data.sepol2, sizeof(tgt)) < 0) {
			pr_err("sepol: copy tgt failed.\n");
			goto exit;
		}
		if (strncpy_from_user(cls, data.sepol3, sizeof(cls)) < 0) {
			pr_err("sepol: copy cls failed.\n");
			goto exit;
		}
		if (strncpy_from_user(default_type, data.sepol4,
				      sizeof(default_type)) < 0) {
			pr_err("sepol: copy default_type failed.\n");
			goto exit;
		}
		bool success = false;
		if (subcmd == 1) {
			success = ksu_type_change(db, src, tgt, cls,
						  default_type);
		} else if (subcmd == 2) {
			success = ksu_type_member(db, src, tgt, cls,
						  default_type);
		} else {
			pr_err("sepol: unknown subcmd: %d", subcmd);
		}
		if (success)
			ret = 0;
	} else if (cmd == CMD_GENFSCON) {
		char name[MAX_SEPOL_LEN];
		char path[MAX_SEPOL_LEN];
		char context[MAX_SEPOL_LEN];
		if (strncpy_from_user(name, data.sepol1, sizeof(name)) < 0) {
			pr_err("sepol: copy name failed.\n");
			goto exit;
		}
		if (strncpy_from_user(path, data.sepol2, sizeof(path)) < 0) {
			pr_err("sepol: copy path failed.\n");
			goto exit;
		}
		if (strncpy_from_user(context, data.sepol3, sizeof(context)) <
		    0) {
			pr_err("sepol: copy context failed.\n");
			goto exit;
		}

		if (!ksu_genfscon(db, name, path, context)) {
			pr_err("sepol: %d failed.\n", cmd);
			goto exit;
		}
		ret = 0;
	} else {
		pr_err("sepol: unknown cmd: %d\n", cmd);
	}

exit:
	rcu_read_unlock();

	// only allow and xallow needs to reset avc cache, but we cannot do that because
	// we are in atomic context. so we just reset it every time.
	reset_avc_cache();

	return ret;
}

```

`kernel/selinux/selinux.c`:

```c
#include "selinux.h"
#include "objsec.h"
#include "linux/version.h"
#include "../klog.h" // IWYU pragma: keep
#ifndef KSU_COMPAT_USE_SELINUX_STATE
#include "avc.h"
#endif

#define KERNEL_SU_DOMAIN "u:r:su:s0"

static u32 ksu_sid;

static int transive_to_domain(const char *domain)
{
	struct cred *cred;
	struct task_security_struct *tsec;
	u32 sid;
	int error;

	cred = (struct cred *)__task_cred(current);

	tsec = cred->security;
	if (!tsec) {
		pr_err("tsec == NULL!\n");
		return -1;
	}

	error = security_secctx_to_secid(domain, strlen(domain), &sid);
	if (error) {
		pr_info("security_secctx_to_secid %s -> sid: %d, error: %d\n", domain, sid, error);
	}
	if (!error) {
		if (!ksu_sid)
			ksu_sid = sid;

		tsec->sid = sid;
		tsec->create_sid = 0;
		tsec->keycreate_sid = 0;
		tsec->sockcreate_sid = 0;
	}
	return error;
}

void setup_selinux(const char *domain)
{
	if (transive_to_domain(domain)) {
		pr_err("transive domain failed.");
		return;
	}

	/* we didn't need this now, we have change selinux rules when boot!
if (!is_domain_permissive) {
  if (set_domain_permissive() == 0) {
      is_domain_permissive = true;
  }
}*/
}

void setenforce(bool enforce)
{
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
#ifdef KSU_COMPAT_USE_SELINUX_STATE
	selinux_state.enforcing = enforce;
#else
	selinux_enforcing = enforce;
#endif
#endif
}

bool getenforce()
{
#ifdef CONFIG_SECURITY_SELINUX_DISABLE
#ifdef KSU_COMPAT_USE_SELINUX_STATE
	if (selinux_state.disabled) {
#else
	if (selinux_disabled) {
#endif
		return false;
	}
#endif

#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
#ifdef KSU_COMPAT_USE_SELINUX_STATE
	return selinux_state.enforcing;
#else
	return selinux_enforcing;
#endif
#else
	return true;
#endif
}

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)) &&                         \
	!defined(KSU_COMPAT_HAS_CURRENT_SID)
/*
 * get the subjective security ID of the current task
 */
static inline u32 current_sid(void)
{
	const struct task_security_struct *tsec = current_security();

	return tsec->sid;
}
#endif

bool is_ksu_domain()
{
	return ksu_sid && current_sid() == ksu_sid;
}

```

`kernel/selinux/selinux.h`:

```h
#ifndef __KSU_H_SELINUX
#define __KSU_H_SELINUX

#include "linux/types.h"
#include "linux/version.h"

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)) || defined(KSU_COMPAT_HAS_SELINUX_STATE)
#define KSU_COMPAT_USE_SELINUX_STATE
#endif

void setup_selinux(const char *);

void setenforce(bool);

bool getenforce();

bool is_ksu_domain();

void apply_kernelsu_rules();

#endif

```

`kernel/selinux/sepolicy.c`:

```c
#include "sepolicy.h"
#include "linux/gfp.h"
#include "linux/printk.h"
#include "linux/slab.h"
#include "linux/version.h"

#include "../klog.h" // IWYU pragma: keep
#include "ss/symtab.h"

#define KSU_SUPPORT_ADD_TYPE

/*
 * Adapt to Huawei HISI kernel without affecting other kernels ,
 * Huawei Hisi Kernel EBITMAP Enable or Disable Flag ,
 * From ss/ebitmap.h
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) &&                           \
	LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
#ifdef HISI_SELINUX_EBITMAP_RO
#define CONFIG_IS_HW_HISI
#endif
#endif

//////////////////////////////////////////////////////
// Declaration
//////////////////////////////////////////////////////

static struct avtab_node *get_avtab_node(struct policydb *db,
					 struct avtab_key *key,
					 struct avtab_extended_perms *xperms);

static bool add_rule(struct policydb *db, const char *s, const char *t,
		     const char *c, const char *p, int effect, bool invert);

static void add_rule_raw(struct policydb *db, struct type_datum *src,
			 struct type_datum *tgt, struct class_datum *cls,
			 struct perm_datum *perm, int effect, bool invert);

static void add_xperm_rule_raw(struct policydb *db, struct type_datum *src,
			       struct type_datum *tgt, struct class_datum *cls,
			       uint16_t low, uint16_t high, int effect,
			       bool invert);
static bool add_xperm_rule(struct policydb *db, const char *s, const char *t,
			   const char *c, const char *range, int effect,
			   bool invert);

static bool add_type_rule(struct policydb *db, const char *s, const char *t,
			  const char *c, const char *d, int effect);

static bool add_filename_trans(struct policydb *db, const char *s,
			       const char *t, const char *c, const char *d,
			       const char *o);

static bool add_genfscon(struct policydb *db, const char *fs_name,
			 const char *path, const char *context);

static bool add_type(struct policydb *db, const char *type_name, bool attr);

static bool set_type_state(struct policydb *db, const char *type_name,
			   bool permissive);

static void add_typeattribute_raw(struct policydb *db, struct type_datum *type,
				  struct type_datum *attr);

static bool add_typeattribute(struct policydb *db, const char *type,
			      const char *attr);

//////////////////////////////////////////////////////
// Implementation
//////////////////////////////////////////////////////

// Invert is adding rules for auditdeny; in other cases, invert is removing
// rules
#define strip_av(effect, invert) ((effect == AVTAB_AUDITDENY) == !invert)

#define ksu_hash_for_each(node_ptr, n_slot, cur)                               \
	int i;                                                                 \
	for (i = 0; i < n_slot; ++i)                                           \
		for (cur = node_ptr[i]; cur; cur = cur->next)

// htable is a struct instead of pointer above 5.8.0:
// https://elixir.bootlin.com/linux/v5.8-rc1/source/security/selinux/ss/symtab.h
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
#define ksu_hashtab_for_each(htab, cur)                                        \
	ksu_hash_for_each(htab.htable, htab.size, cur)
#else
#define ksu_hashtab_for_each(htab, cur)                                        \
	ksu_hash_for_each(htab->htable, htab->size, cur)
#endif

// symtab_search is introduced on 5.9.0:
// https://elixir.bootlin.com/linux/v5.9-rc1/source/security/selinux/ss/symtab.h
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
#define symtab_search(s, name) hashtab_search((s)->table, name)
#define symtab_insert(s, name, datum) hashtab_insert((s)->table, name, datum)
#endif

#define avtab_for_each(avtab, cur)                                             \
	ksu_hash_for_each(avtab.htable, avtab.nslot, cur);

static struct avtab_node *get_avtab_node(struct policydb *db,
					 struct avtab_key *key,
					 struct avtab_extended_perms *xperms)
{
	struct avtab_node *node;

	/* AVTAB_XPERMS entries are not necessarily unique */
	if (key->specified & AVTAB_XPERMS) {
		bool match = false;
		node = avtab_search_node(&db->te_avtab, key);
		while (node) {
			if ((node->datum.u.xperms->specified ==
			     xperms->specified) &&
			    (node->datum.u.xperms->driver == xperms->driver)) {
				match = true;
				break;
			}
			node = avtab_search_node_next(node, key->specified);
		}
		if (!match)
			node = NULL;
	} else {
		node = avtab_search_node(&db->te_avtab, key);
	}

	if (!node) {
		struct avtab_datum avdatum = {};
		/*
     * AUDITDENY, aka DONTAUDIT, are &= assigned, versus |= for
     * others. Initialize the data accordingly.
     */
		if (key->specified & AVTAB_XPERMS) {
			avdatum.u.xperms = xperms;
		} else {
			avdatum.u.data =
				key->specified == AVTAB_AUDITDENY ? ~0U : 0U;
		}
		/* this is used to get the node - insertion is actually unique */
		node = avtab_insert_nonunique(&db->te_avtab, key, &avdatum);

		int grow_size = sizeof(struct avtab_key);
		grow_size += sizeof(struct avtab_datum);
		if (key->specified & AVTAB_XPERMS) {
			grow_size += sizeof(u8);
			grow_size += sizeof(u8);
			grow_size += sizeof(u32) *
				     ARRAY_SIZE(avdatum.u.xperms->perms.p);
		}
		db->len += grow_size;
	}

	return node;
}

static bool add_rule(struct policydb *db, const char *s, const char *t,
		     const char *c, const char *p, int effect, bool invert)
{
	struct type_datum *src = NULL, *tgt = NULL;
	struct class_datum *cls = NULL;
	struct perm_datum *perm = NULL;

	if (s) {
		src = symtab_search(&db->p_types, s);
		if (src == NULL) {
			pr_info("source type %s does not exist\n", s);
			return false;
		}
	}

	if (t) {
		tgt = symtab_search(&db->p_types, t);
		if (tgt == NULL) {
			pr_info("target type %s does not exist\n", t);
			return false;
		}
	}

	if (c) {
		cls = symtab_search(&db->p_classes, c);
		if (cls == NULL) {
			pr_info("class %s does not exist\n", c);
			return false;
		}
	}

	if (p) {
		if (c == NULL) {
			pr_info("No class is specified, cannot add perm [%s] \n",
				p);
			return false;
		}

		perm = symtab_search(&cls->permissions, p);
		if (perm == NULL && cls->comdatum != NULL) {
			perm = symtab_search(&cls->comdatum->permissions, p);
		}
		if (perm == NULL) {
			pr_info("perm %s does not exist in class %s\n", p, c);
			return false;
		}
	}
	add_rule_raw(db, src, tgt, cls, perm, effect, invert);
	return true;
}

static void add_rule_raw(struct policydb *db, struct type_datum *src,
			 struct type_datum *tgt, struct class_datum *cls,
			 struct perm_datum *perm, int effect, bool invert)
{
	if (src == NULL) {
		struct hashtab_node *node;
		if (strip_av(effect, invert)) {
			ksu_hashtab_for_each(db->p_types.table, node)
			{
				add_rule_raw(db,
					     (struct type_datum *)node->datum,
					     tgt, cls, perm, effect, invert);
			};
		} else {
			ksu_hashtab_for_each(db->p_types.table, node)
			{
				struct type_datum *type =
					(struct type_datum *)(node->datum);
				if (type->attribute) {
					add_rule_raw(db, type, tgt, cls, perm,
						     effect, invert);
				}
			};
		}
	} else if (tgt == NULL) {
		struct hashtab_node *node;
		if (strip_av(effect, invert)) {
			ksu_hashtab_for_each(db->p_types.table, node)
			{
				add_rule_raw(db, src,
					     (struct type_datum *)node->datum,
					     cls, perm, effect, invert);
			};
		} else {
			ksu_hashtab_for_each(db->p_types.table, node)
			{
				struct type_datum *type =
					(struct type_datum *)(node->datum);
				if (type->attribute) {
					add_rule_raw(db, src, type, cls, perm,
						     effect, invert);
				}
			};
		}
	} else if (cls == NULL) {
		struct hashtab_node *node;
		ksu_hashtab_for_each(db->p_classes.table, node)
		{
			add_rule_raw(db, src, tgt,
				     (struct class_datum *)node->datum, perm,
				     effect, invert);
		}
	} else {
		struct avtab_key key;
		key.source_type = src->value;
		key.target_type = tgt->value;
		key.target_class = cls->value;
		key.specified = effect;

		struct avtab_node *node = get_avtab_node(db, &key, NULL);
		if (invert) {
			if (perm)
				node->datum.u.data &=
					~(1U << (perm->value - 1));
			else
				node->datum.u.data = 0U;
		} else {
			if (perm)
				node->datum.u.data |= 1U << (perm->value - 1);
			else
				node->datum.u.data = ~0U;
		}
	}
}

#define ioctl_driver(x) (x >> 8 & 0xFF)
#define ioctl_func(x) (x & 0xFF)

#define xperm_test(x, p) (1 & (p[x >> 5] >> (x & 0x1f)))
#define xperm_set(x, p) (p[x >> 5] |= (1 << (x & 0x1f)))
#define xperm_clear(x, p) (p[x >> 5] &= ~(1 << (x & 0x1f)))

static void add_xperm_rule_raw(struct policydb *db, struct type_datum *src,
			       struct type_datum *tgt, struct class_datum *cls,
			       uint16_t low, uint16_t high, int effect,
			       bool invert)
{
	if (src == NULL) {
		struct hashtab_node *node;
		ksu_hashtab_for_each(db->p_types.table, node)
		{
			struct type_datum *type =
				(struct type_datum *)(node->datum);
			if (type->attribute) {
				add_xperm_rule_raw(db, type, tgt, cls, low,
						   high, effect, invert);
			}
		};
	} else if (tgt == NULL) {
		struct hashtab_node *node;
		ksu_hashtab_for_each(db->p_types.table, node)
		{
			struct type_datum *type =
				(struct type_datum *)(node->datum);
			if (type->attribute) {
				add_xperm_rule_raw(db, src, type, cls, low,
						   high, effect, invert);
			}
		};
	} else if (cls == NULL) {
		struct hashtab_node *node;
		ksu_hashtab_for_each(db->p_classes.table, node)
		{
			add_xperm_rule_raw(db, src, tgt,
					   (struct class_datum *)(node->datum),
					   low, high, effect, invert);
		};
	} else {
		struct avtab_key key;
		key.source_type = src->value;
		key.target_type = tgt->value;
		key.target_class = cls->value;
		key.specified = effect;

		struct avtab_datum *datum;
		struct avtab_node *node;
		struct avtab_extended_perms xperms;

		memset(&xperms, 0, sizeof(xperms));
		if (ioctl_driver(low) != ioctl_driver(high)) {
			xperms.specified = AVTAB_XPERMS_IOCTLDRIVER;
			xperms.driver = 0;
		} else {
			xperms.specified = AVTAB_XPERMS_IOCTLFUNCTION;
			xperms.driver = ioctl_driver(low);
		}
		int i;
		if (xperms.specified == AVTAB_XPERMS_IOCTLDRIVER) {
			for (i = ioctl_driver(low); i <= ioctl_driver(high);
			     ++i) {
				if (invert)
					xperm_clear(i, xperms.perms.p);
				else
					xperm_set(i, xperms.perms.p);
			}
		} else {
			for (i = ioctl_func(low); i <= ioctl_func(high); ++i) {
				if (invert)
					xperm_clear(i, xperms.perms.p);
				else
					xperm_set(i, xperms.perms.p);
			}
		}

		node = get_avtab_node(db, &key, &xperms);
		if (!node) {
			pr_warn("add_xperm_rule_raw cannot found node!\n");
			return;
		}
		datum = &node->datum;

		if (datum->u.xperms == NULL) {
			datum->u.xperms =
				(struct avtab_extended_perms *)(kmalloc(
					sizeof(xperms), GFP_KERNEL));
			if (!datum->u.xperms) {
				pr_err("alloc xperms failed\n");
				return;
			}
			memcpy(datum->u.xperms, &xperms, sizeof(xperms));
		}
	}
}

static bool add_xperm_rule(struct policydb *db, const char *s, const char *t,
			   const char *c, const char *range, int effect,
			   bool invert)
{
	struct type_datum *src = NULL, *tgt = NULL;
	struct class_datum *cls = NULL;

	if (s) {
		src = symtab_search(&db->p_types, s);
		if (src == NULL) {
			pr_info("source type %s does not exist\n", s);
			return false;
		}
	}

	if (t) {
		tgt = symtab_search(&db->p_types, t);
		if (tgt == NULL) {
			pr_info("target type %s does not exist\n", t);
			return false;
		}
	}

	if (c) {
		cls = symtab_search(&db->p_classes, c);
		if (cls == NULL) {
			pr_info("class %s does not exist\n", c);
			return false;
		}
	}

	u16 low, high;

	if (range) {
		if (strchr(range, '-')) {
			sscanf(range, "%hx-%hx", &low, &high);
		} else {
			sscanf(range, "%hx", &low);
			high = low;
		}
	} else {
		low = 0;
		high = 0xFFFF;
	}

	add_xperm_rule_raw(db, src, tgt, cls, low, high, effect, invert);
	return true;
}

static bool add_type_rule(struct policydb *db, const char *s, const char *t,
			  const char *c, const char *d, int effect)
{
	struct type_datum *src, *tgt, *def;
	struct class_datum *cls;

	src = symtab_search(&db->p_types, s);
	if (src == NULL) {
		pr_info("source type %s does not exist\n", s);
		return false;
	}
	tgt = symtab_search(&db->p_types, t);
	if (tgt == NULL) {
		pr_info("target type %s does not exist\n", t);
		return false;
	}
	cls = symtab_search(&db->p_classes, c);
	if (cls == NULL) {
		pr_info("class %s does not exist\n", c);
		return false;
	}
	def = symtab_search(&db->p_types, d);
	if (def == NULL) {
		pr_info("default type %s does not exist\n", d);
		return false;
	}

	struct avtab_key key;
	key.source_type = src->value;
	key.target_type = tgt->value;
	key.target_class = cls->value;
	key.specified = effect;

	struct avtab_node *node = get_avtab_node(db, &key, NULL);
	node->datum.u.data = def->value;

	return true;
}

// 5.9.0 : static inline int hashtab_insert(struct hashtab *h, void *key, void
// *datum, struct hashtab_key_params key_params) 5.8.0: int
// hashtab_insert(struct hashtab *h, void *k, void *d);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
static u32 filenametr_hash(const void *k)
{
	const struct filename_trans_key *ft = k;
	unsigned long hash;
	unsigned int byte_num;
	unsigned char focus;

	hash = ft->ttype ^ ft->tclass;

	byte_num = 0;
	while ((focus = ft->name[byte_num++]))
		hash = partial_name_hash(focus, hash);
	return hash;
}

static int filenametr_cmp(const void *k1, const void *k2)
{
	const struct filename_trans_key *ft1 = k1;
	const struct filename_trans_key *ft2 = k2;
	int v;

	v = ft1->ttype - ft2->ttype;
	if (v)
		return v;

	v = ft1->tclass - ft2->tclass;
	if (v)
		return v;

	return strcmp(ft1->name, ft2->name);
}

static const struct hashtab_key_params filenametr_key_params = {
	.hash = filenametr_hash,
	.cmp = filenametr_cmp,
};
#endif

static bool add_filename_trans(struct policydb *db, const char *s,
			       const char *t, const char *c, const char *d,
			       const char *o)
{
	struct type_datum *src, *tgt, *def;
	struct class_datum *cls;

	src = symtab_search(&db->p_types, s);
	if (src == NULL) {
		pr_warn("source type %s does not exist\n", s);
		return false;
	}
	tgt = symtab_search(&db->p_types, t);
	if (tgt == NULL) {
		pr_warn("target type %s does not exist\n", t);
		return false;
	}
	cls = symtab_search(&db->p_classes, c);
	if (cls == NULL) {
		pr_warn("class %s does not exist\n", c);
		return false;
	}
	def = symtab_search(&db->p_types, d);
	if (def == NULL) {
		pr_warn("default type %s does not exist\n", d);
		return false;
	}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
	struct filename_trans_key key;
	key.ttype = tgt->value;
	key.tclass = cls->value;
	key.name = (char *)o;

	struct filename_trans_datum *last = NULL;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
	struct filename_trans_datum *trans =
		policydb_filenametr_search(db, &key);
#else
	struct filename_trans_datum *trans =
		hashtab_search(&db->filename_trans, &key);
#endif
	while (trans) {
		if (ebitmap_get_bit(&trans->stypes, src->value - 1)) {
			// Duplicate, overwrite existing data and return
			trans->otype = def->value;
			return true;
		}
		if (trans->otype == def->value)
			break;
		last = trans;
		trans = trans->next;
	}

	if (trans == NULL) {
		trans = (struct filename_trans_datum *)kcalloc(sizeof(*trans),
							       1, GFP_ATOMIC);
		struct filename_trans_key *new_key =
			(struct filename_trans_key *)kmalloc(sizeof(*new_key),
							     GFP_ATOMIC);
		*new_key = key;
		new_key->name = kstrdup(key.name, GFP_ATOMIC);
		trans->next = last;
		trans->otype = def->value;
		hashtab_insert(&db->filename_trans, new_key, trans,
			       filenametr_key_params);
	}

	db->compat_filename_trans_count++;
	return ebitmap_set_bit(&trans->stypes, src->value - 1, 1) == 0;
#else // < 5.7.0, has no filename_trans_key, but struct filename_trans

	struct filename_trans key;
	key.ttype = tgt->value;
	key.tclass = cls->value;
	key.name = (char *)o;

	struct filename_trans_datum *trans =
		hashtab_search(db->filename_trans, &key);

	if (trans == NULL) {
		trans = (struct filename_trans_datum *)kcalloc(sizeof(*trans),
							       1, GFP_ATOMIC);
		if (!trans) {
			pr_err("add_filename_trans: Failed to alloc datum");
			return false;
		}
		struct filename_trans *new_key =
			(struct filename_trans *)kmalloc(sizeof(*new_key),
							 GFP_ATOMIC);
		if (!new_key) {
			pr_err("add_filename_trans: Failed to alloc new_key");
			return false;
		}
		*new_key = key;
		new_key->name = kstrdup(key.name, GFP_ATOMIC);
		trans->otype = def->value;
		hashtab_insert(db->filename_trans, new_key, trans);
	}

	return ebitmap_set_bit(&db->filename_trans_ttypes, src->value - 1, 1) ==
	       0;
#endif
}

static bool add_genfscon(struct policydb *db, const char *fs_name,
			 const char *path, const char *context)
{
	return false;
}

static bool add_type(struct policydb *db, const char *type_name, bool attr)
{
#ifdef KSU_SUPPORT_ADD_TYPE
	struct type_datum *type = symtab_search(&db->p_types, type_name);
	if (type) {
		pr_warn("Type %s already exists\n", type_name);
		return true;
	}

	u32 value = ++db->p_types.nprim;
	type = (struct type_datum *)kzalloc(sizeof(struct type_datum),
					    GFP_ATOMIC);
	if (!type) {
		pr_err("add_type: alloc type_datum failed.\n");
		return false;
	}

	type->primary = 1;
	type->value = value;
	type->attribute = attr;

	char *key = kstrdup(type_name, GFP_ATOMIC);
	if (!key) {
		pr_err("add_type: alloc key failed.\n");
		return false;
	}

	if (symtab_insert(&db->p_types, key, type)) {
		pr_err("add_type: insert symtab failed.\n");
		return false;
	}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
	size_t new_size = sizeof(struct ebitmap) * db->p_types.nprim;
	struct ebitmap *new_type_attr_map_array =
		(krealloc(db->type_attr_map_array, new_size, GFP_ATOMIC));

	struct type_datum **new_type_val_to_struct =
		krealloc(db->type_val_to_struct,
			 sizeof(*db->type_val_to_struct) * db->p_types.nprim,
			 GFP_ATOMIC);

	if (!new_type_attr_map_array) {
		pr_err("add_type: alloc type_attr_map_array failed\n");
		return false;
	}

	if (!new_type_val_to_struct) {
		pr_err("add_type: alloc type_val_to_struct failed\n");
		return false;
	}

	char **new_val_to_name_types =
		krealloc(db->sym_val_to_name[SYM_TYPES],
			 sizeof(char *) * db->symtab[SYM_TYPES].nprim,
			 GFP_KERNEL);
	if (!new_val_to_name_types) {
		pr_err("add_type: alloc val_to_name failed\n");
		return false;
	}

	db->type_attr_map_array = new_type_attr_map_array;
	ebitmap_init(&db->type_attr_map_array[value - 1]);
	ebitmap_set_bit(&db->type_attr_map_array[value - 1], value - 1, 1);

	db->type_val_to_struct = new_type_val_to_struct;
	db->type_val_to_struct[value - 1] = type;

	db->sym_val_to_name[SYM_TYPES] = new_val_to_name_types;
	db->sym_val_to_name[SYM_TYPES][value - 1] = key;

	int i;
	for (i = 0; i < db->p_roles.nprim; ++i) {
		ebitmap_set_bit(&db->role_val_to_struct[i]->types, value - 1,
				1);
	}

	return true;
#elif defined(CONFIG_IS_HW_HISI)
	/*
   * Huawei use type_attr_map and type_val_to_struct.
   * And use ebitmap not flex_array.
   */
	size_t new_size = sizeof(struct ebitmap) * db->p_types.nprim;
	struct ebitmap *new_type_attr_map =
		(krealloc(db->type_attr_map, new_size, GFP_ATOMIC));

	struct type_datum **new_type_val_to_struct =
		krealloc(db->type_val_to_struct,
			 sizeof(*db->type_val_to_struct) * db->p_types.nprim,
			 GFP_ATOMIC);

	if (!new_type_attr_map) {
		pr_err("add_type: alloc type_attr_map failed\n");
		return false;
	}

	if (!new_type_val_to_struct) {
		pr_err("add_type: alloc type_val_to_struct failed\n");
		return false;
	}

	char **new_val_to_name_types =
		krealloc(db->sym_val_to_name[SYM_TYPES],
			 sizeof(char *) * db->symtab[SYM_TYPES].nprim,
			 GFP_KERNEL);
	if (!new_val_to_name_types) {
		pr_err("add_type: alloc val_to_name failed\n");
		return false;
	}

	db->type_attr_map = new_type_attr_map;
	ebitmap_init(&db->type_attr_map[value - 1], HISI_SELINUX_EBITMAP_RO);
	ebitmap_set_bit(&db->type_attr_map[value - 1], value - 1, 1);

	db->type_val_to_struct = new_type_val_to_struct;
	db->type_val_to_struct[value - 1] = type;

	db->sym_val_to_name[SYM_TYPES] = new_val_to_name_types;
	db->sym_val_to_name[SYM_TYPES][value - 1] = key;

	int i;
	for (i = 0; i < db->p_roles.nprim; ++i) {
		ebitmap_set_bit(&db->role_val_to_struct[i]->types, value - 1,
				1);
	}

	return true;
#else
	// flex_array is not extensible, we need to create a new bigger one instead
	struct flex_array *new_type_attr_map_array =
		flex_array_alloc(sizeof(struct ebitmap), db->p_types.nprim,
				 GFP_ATOMIC | __GFP_ZERO);

	struct flex_array *new_type_val_to_struct =
		flex_array_alloc(sizeof(struct type_datum *), db->p_types.nprim,
				 GFP_ATOMIC | __GFP_ZERO);

	struct flex_array *new_val_to_name_types =
		flex_array_alloc(sizeof(char *), db->symtab[SYM_TYPES].nprim,
				 GFP_ATOMIC | __GFP_ZERO);

	if (!new_type_attr_map_array) {
		pr_err("add_type: alloc type_attr_map_array failed\n");
		return false;
	}

	if (!new_type_val_to_struct) {
		pr_err("add_type: alloc type_val_to_struct failed\n");
		return false;
	}

	if (!new_val_to_name_types) {
		pr_err("add_type: alloc val_to_name failed\n");
		return false;
	}

	// preallocate so we don't have to worry about the put ever failing
	if (flex_array_prealloc(new_type_attr_map_array, 0, db->p_types.nprim,
				GFP_ATOMIC | __GFP_ZERO)) {
		pr_err("add_type: prealloc type_attr_map_array failed\n");
		return false;
	}

	if (flex_array_prealloc(new_type_val_to_struct, 0, db->p_types.nprim,
				GFP_ATOMIC | __GFP_ZERO)) {
		pr_err("add_type: prealloc type_val_to_struct_array failed\n");
		return false;
	}

	if (flex_array_prealloc(new_val_to_name_types, 0,
				db->symtab[SYM_TYPES].nprim,
				GFP_ATOMIC | __GFP_ZERO)) {
		pr_err("add_type: prealloc val_to_name_types failed\n");
		return false;
	}

	int j;
	void *old_elem;
	// copy the old data or pointers to new flex arrays
	for (j = 0; j < db->type_attr_map_array->total_nr_elements; j++) {
		old_elem = flex_array_get(db->type_attr_map_array, j);
		if (old_elem)
			flex_array_put(new_type_attr_map_array, j, old_elem,
				       GFP_ATOMIC | __GFP_ZERO);
	}

	for (j = 0; j < db->type_val_to_struct_array->total_nr_elements; j++) {
		old_elem = flex_array_get_ptr(db->type_val_to_struct_array, j);
		if (old_elem)
			flex_array_put_ptr(new_type_val_to_struct, j, old_elem,
					   GFP_ATOMIC | __GFP_ZERO);
	}

	for (j = 0; j < db->symtab[SYM_TYPES].nprim; j++) {
		old_elem =
			flex_array_get_ptr(db->sym_val_to_name[SYM_TYPES], j);
		if (old_elem)
			flex_array_put_ptr(new_val_to_name_types, j, old_elem,
					   GFP_ATOMIC | __GFP_ZERO);
	}

	// store the pointer of old flex arrays first, when assigning new ones we
	// should free it
	struct flex_array *old_fa;

	old_fa = db->type_attr_map_array;
	db->type_attr_map_array = new_type_attr_map_array;
	if (old_fa) {
		flex_array_free(old_fa);
	}

	ebitmap_init(flex_array_get(db->type_attr_map_array, value - 1));
	ebitmap_set_bit(flex_array_get(db->type_attr_map_array, value - 1),
			value - 1, 1);

	old_fa = db->type_val_to_struct_array;
	db->type_val_to_struct_array = new_type_val_to_struct;
	if (old_fa) {
		flex_array_free(old_fa);
	}
	flex_array_put_ptr(db->type_val_to_struct_array, value - 1, type,
			   GFP_ATOMIC | __GFP_ZERO);

	old_fa = db->sym_val_to_name[SYM_TYPES];
	db->sym_val_to_name[SYM_TYPES] = new_val_to_name_types;
	if (old_fa) {
		flex_array_free(old_fa);
	}
	flex_array_put_ptr(db->sym_val_to_name[SYM_TYPES], value - 1, key,
			   GFP_ATOMIC | __GFP_ZERO);

	int i;
	for (i = 0; i < db->p_roles.nprim; ++i) {
		ebitmap_set_bit(&db->role_val_to_struct[i]->types, value - 1,
				1);
	}
	return true;
#endif

#else
	return false;
#endif
}

static bool set_type_state(struct policydb *db, const char *type_name,
			   bool permissive)
{
	struct type_datum *type;
	if (type_name == NULL) {
		struct hashtab_node *node;
		ksu_hashtab_for_each(db->p_types.table, node)
		{
			type = (struct type_datum *)(node->datum);
			if (ebitmap_set_bit(&db->permissive_map, type->value,
					    permissive))
				pr_info("Could not set bit in permissive map\n");
		};
	} else {
		type = (struct type_datum *)symtab_search(&db->p_types,
							  type_name);
		if (type == NULL) {
			pr_info("type %s does not exist\n", type_name);
			return false;
		}
		if (ebitmap_set_bit(&db->permissive_map, type->value,
				    permissive)) {
			pr_info("Could not set bit in permissive map\n");
			return false;
		}
	}
	return true;
}

static void add_typeattribute_raw(struct policydb *db, struct type_datum *type,
				  struct type_datum *attr)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
	struct ebitmap *sattr = &db->type_attr_map_array[type->value - 1];
#elif defined(CONFIG_IS_HW_HISI)
	/*
   *   HISI_SELINUX_EBITMAP_RO is Huawei's unique features.
   */
	struct ebitmap *sattr = &db->type_attr_map[type->value - 1],
		       HISI_SELINUX_EBITMAP_RO;
#else
	struct ebitmap *sattr =
		flex_array_get(db->type_attr_map_array, type->value - 1);
#endif
	ebitmap_set_bit(sattr, attr->value - 1, 1);

	struct hashtab_node *node;
	struct constraint_node *n;
	struct constraint_expr *e;
	ksu_hashtab_for_each(db->p_classes.table, node)
	{
		struct class_datum *cls = (struct class_datum *)(node->datum);
		for (n = cls->constraints; n; n = n->next) {
			for (e = n->expr; e; e = e->next) {
				if (e->expr_type == CEXPR_NAMES &&
				    ebitmap_get_bit(&e->type_names->types,
						    attr->value - 1)) {
					ebitmap_set_bit(&e->names,
							type->value - 1, 1);
				}
			}
		}
	};
}

static bool add_typeattribute(struct policydb *db, const char *type,
			      const char *attr)
{
	struct type_datum *type_d = symtab_search(&db->p_types, type);
	if (type_d == NULL) {
		pr_info("type %s does not exist\n", type);
		return false;
	} else if (type_d->attribute) {
		pr_info("type %s is an attribute\n", attr);
		return false;
	}

	struct type_datum *attr_d = symtab_search(&db->p_types, attr);
	if (attr_d == NULL) {
		pr_info("attribute %s does not exist\n", type);
		return false;
	} else if (!attr_d->attribute) {
		pr_info("type %s is not an attribute \n", attr);
		return false;
	}

	add_typeattribute_raw(db, type_d, attr_d);
	return true;
}

//////////////////////////////////////////////////////////////////////////

// Operation on types
bool ksu_type(struct policydb *db, const char *name, const char *attr)
{
	return add_type(db, name, false) && add_typeattribute(db, name, attr);
}

bool ksu_attribute(struct policydb *db, const char *name)
{
	return add_type(db, name, true);
}

bool ksu_permissive(struct policydb *db, const char *type)
{
	return set_type_state(db, type, true);
}

bool ksu_enforce(struct policydb *db, const char *type)
{
	return set_type_state(db, type, false);
}

bool ksu_typeattribute(struct policydb *db, const char *type, const char *attr)
{
	return add_typeattribute(db, type, attr);
}

bool ksu_exists(struct policydb *db, const char *type)
{
	return symtab_search(&db->p_types, type) != NULL;
}

// Access vector rules
bool ksu_allow(struct policydb *db, const char *src, const char *tgt,
	       const char *cls, const char *perm)
{
	return add_rule(db, src, tgt, cls, perm, AVTAB_ALLOWED, false);
}

bool ksu_deny(struct policydb *db, const char *src, const char *tgt,
	      const char *cls, const char *perm)
{
	return add_rule(db, src, tgt, cls, perm, AVTAB_ALLOWED, true);
}

bool ksu_auditallow(struct policydb *db, const char *src, const char *tgt,
		    const char *cls, const char *perm)
{
	return add_rule(db, src, tgt, cls, perm, AVTAB_AUDITALLOW, false);
}
bool ksu_dontaudit(struct policydb *db, const char *src, const char *tgt,
		   const char *cls, const char *perm)
{
	return add_rule(db, src, tgt, cls, perm, AVTAB_AUDITDENY, true);
}

// Extended permissions access vector rules
bool ksu_allowxperm(struct policydb *db, const char *src, const char *tgt,
		    const char *cls, const char *range)
{
	return add_xperm_rule(db, src, tgt, cls, range, AVTAB_XPERMS_ALLOWED,
			      false);
}

bool ksu_auditallowxperm(struct policydb *db, const char *src, const char *tgt,
			 const char *cls, const char *range)
{
	return add_xperm_rule(db, src, tgt, cls, range, AVTAB_XPERMS_AUDITALLOW,
			      false);
}

bool ksu_dontauditxperm(struct policydb *db, const char *src, const char *tgt,
			const char *cls, const char *range)
{
	return add_xperm_rule(db, src, tgt, cls, range, AVTAB_XPERMS_DONTAUDIT,
			      false);
}

// Type rules
bool ksu_type_transition(struct policydb *db, const char *src, const char *tgt,
			 const char *cls, const char *def, const char *obj)
{
	if (obj) {
		return add_filename_trans(db, src, tgt, cls, def, obj);
	} else {
		return add_type_rule(db, src, tgt, cls, def, AVTAB_TRANSITION);
	}
}

bool ksu_type_change(struct policydb *db, const char *src, const char *tgt,
		     const char *cls, const char *def)
{
	return add_type_rule(db, src, tgt, cls, def, AVTAB_CHANGE);
}

bool ksu_type_member(struct policydb *db, const char *src, const char *tgt,
		     const char *cls, const char *def)
{
	return add_type_rule(db, src, tgt, cls, def, AVTAB_MEMBER);
}

// File system labeling
bool ksu_genfscon(struct policydb *db, const char *fs_name, const char *path,
		  const char *ctx)
{
	return add_genfscon(db, fs_name, path, ctx);
}

```

`kernel/selinux/sepolicy.h`:

```h
#ifndef __KSU_H_SEPOLICY
#define __KSU_H_SEPOLICY

#include "linux/types.h"

#include "ss/policydb.h"

// Operation on types
bool ksu_type(struct policydb *db, const char *name, const char *attr);
bool ksu_attribute(struct policydb *db, const char *name);
bool ksu_permissive(struct policydb *db, const char *type);
bool ksu_enforce(struct policydb *db, const char *type);
bool ksu_typeattribute(struct policydb *db, const char *type, const char *attr);
bool ksu_exists(struct policydb *db, const char *type);

// Access vector rules
bool ksu_allow(struct policydb *db, const char *src, const char *tgt,
	       const char *cls, const char *perm);
bool ksu_deny(struct policydb *db, const char *src, const char *tgt,
	      const char *cls, const char *perm);
bool ksu_auditallow(struct policydb *db, const char *src, const char *tgt,
		    const char *cls, const char *perm);
bool ksu_dontaudit(struct policydb *db, const char *src, const char *tgt,
		   const char *cls, const char *perm);

// Extended permissions access vector rules
bool ksu_allowxperm(struct policydb *db, const char *src, const char *tgt,
		    const char *cls, const char *range);
bool ksu_auditallowxperm(struct policydb *db, const char *src, const char *tgt,
			 const char *cls, const char *range);
bool ksu_dontauditxperm(struct policydb *db, const char *src, const char *tgt,
			const char *cls, const char *range);

// Type rules
bool ksu_type_transition(struct policydb *db, const char *src, const char *tgt,
			 const char *cls, const char *def, const char *obj);
bool ksu_type_change(struct policydb *db, const char *src, const char *tgt,
		     const char *cls, const char *def);
bool ksu_type_member(struct policydb *db, const char *src, const char *tgt,
		     const char *cls, const char *def);

// File system labeling
bool ksu_genfscon(struct policydb *db, const char *fs_name, const char *path,
		  const char *ctx);

#endif

```

`kernel/setup.sh`:

```sh
#!/bin/sh
set -eux

GKI_ROOT=$(pwd)

echo "[+] GKI_ROOT: $GKI_ROOT"

if test -d "$GKI_ROOT/common/drivers"; then
     DRIVER_DIR="$GKI_ROOT/common/drivers"
elif test -d "$GKI_ROOT/drivers"; then
     DRIVER_DIR="$GKI_ROOT/drivers"
else
     echo '[ERROR] "drivers/" directory is not found.'
     echo '[+] You should modify this script by yourself.'
     exit 127
fi

test -d "$GKI_ROOT/KernelSU" || git clone https://github.com/MlgmXyysd/KernelSU_Debug KernelSU
cd "$GKI_ROOT/KernelSU"
git stash
if [ "$(git status | grep -Po 'v\d+(\.\d+)*' | head -n1)" ]; then
     git checkout main
fi
git pull
if [ -z "${1-}" ]; then
    git checkout "$(git describe --abbrev=0 --tags)"
else
    git checkout "$1"
fi
cd "$GKI_ROOT"

echo "[+] GKI_ROOT: $GKI_ROOT"
echo "[+] Copy kernel su driver to $DRIVER_DIR"

cd "$DRIVER_DIR"
if test -d "$GKI_ROOT/common/drivers"; then
     ln -sf "../../KernelSU/kernel" "kernelsu"
elif test -d "$GKI_ROOT/drivers"; then
     ln -sf "../KernelSU/kernel" "kernelsu"
fi
cd "$GKI_ROOT"

echo '[+] Add kernel su driver to Makefile'

DRIVER_MAKEFILE=$DRIVER_DIR/Makefile
DRIVER_KCONFIG=$DRIVER_DIR/Kconfig
grep -q "kernelsu" "$DRIVER_MAKEFILE" || printf "obj-\$(CONFIG_KSU) += kernelsu/\n" >> "$DRIVER_MAKEFILE"
grep -q "kernelsu" "$DRIVER_KCONFIG" || sed -i "/endmenu/i\\source \"drivers/kernelsu/Kconfig\"" "$DRIVER_KCONFIG"

echo '[+] Done.'
```

`kernel/sucompat.c`:

```c
#include "asm/current.h"
#include "linux/cred.h"
#include "linux/err.h"
#include "linux/fs.h"
#include "linux/kprobes.h"
#include "linux/types.h"
#include "linux/uaccess.h"
#include "linux/version.h"
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
#include "linux/sched/task_stack.h"
#else
#include "linux/sched.h"
#endif

#include "allowlist.h"
#include "arch.h"
#include "klog.h" // IWYU pragma: keep
#include "ksud.h"
#include "kernel_compat.h"

#define SU_PATH "/system/bin/su"
#define SH_PATH "/system/bin/sh"

extern void escape_to_root();

static void __user *userspace_stack_buffer(const void *d, size_t len)
{
	/* To avoid having to mmap a page in userspace, just write below the stack
   * pointer. */
	char __user *p = (void __user *)current_user_stack_pointer() - len;

	return copy_to_user(p, d, len) ? NULL : p;
}

static char __user *sh_user_path(void)
{
	static const char sh_path[] = "/system/bin/sh";

	return userspace_stack_buffer(sh_path, sizeof(sh_path));
}

int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
			 int *flags)
{
	const char su[] = SU_PATH;

	if (!ksu_is_allow_uid(current_uid().val)) {
		return 0;
	}

	char path[sizeof(su)];
	memset(path, 0, sizeof(path));
	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));

	if (unlikely(!memcmp(path, su, sizeof(su)))) {
		pr_info("faccessat su->sh!\n");
		*filename_user = sh_user_path();
	}

	return 0;
}

int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
{
	// const char sh[] = SH_PATH;
	const char su[] = SU_PATH;

	if (!ksu_is_allow_uid(current_uid().val)) {
		return 0;
	}

	if (unlikely(!filename_user)) {
		return 0;
	}

	char path[sizeof(su)];
	memset(path, 0, sizeof(path));
	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));

	if (unlikely(!memcmp(path, su, sizeof(su)))) {
		pr_info("newfstatat su->sh!\n");
		*filename_user = sh_user_path();
	}

	return 0;
}

// the call from execve_handler_pre won't provided correct value for __never_use_argument, use them after fix execve_handler_pre, keeping them for consistence for manually patched code
int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
				 void *__never_use_argv, void *__never_use_envp, int *__never_use_flags)
{
	struct filename *filename;
	const char sh[] = KSUD_PATH;
	const char su[] = SU_PATH;

	if (unlikely(!filename_ptr))
		return 0;

	filename = *filename_ptr;
	if (IS_ERR(filename)) {
		return 0;
	}

	if (likely(memcmp(filename->name, su, sizeof(su))))
		return 0;

	if (!ksu_is_allow_uid(current_uid().val))
		return 0;

	pr_info("do_execveat_common su found\n");
	memcpy((void *)filename->name, sh, sizeof(sh));

	escape_to_root();

	return 0;
}

#ifdef CONFIG_KPROBES

static int faccessat_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	int *dfd = (int *)PT_REGS_PARM1(regs);
	const char __user **filename_user = (const char **)&PT_REGS_PARM2(regs);
	int *mode = (int *)&PT_REGS_PARM3(regs);
	// Both sys_ and do_ is C function
	int *flags = (int *)&PT_REGS_CCALL_PARM4(regs);

	return ksu_handle_faccessat(dfd, filename_user, mode, flags);
}

static int newfstatat_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	int *dfd = (int *)&PT_REGS_PARM1(regs);
	const char __user **filename_user = (const char **)&PT_REGS_PARM2(regs);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
// static int vfs_statx(int dfd, const char __user *filename, int flags, struct kstat *stat, u32 request_mask)
	int *flags = (int *)&PT_REGS_PARM3(regs);
#else
// int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,int flag)
	int *flags = (int *)&PT_REGS_CCALL_PARM4(regs);
#endif

	return ksu_handle_stat(dfd, filename_user, flags);
}

// https://elixir.bootlin.com/linux/v5.10.158/source/fs/exec.c#L1864
static int execve_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	int *fd = (int *)&PT_REGS_PARM1(regs);
	struct filename **filename_ptr =
		(struct filename **)&PT_REGS_PARM2(regs);

	return ksu_handle_execveat_sucompat(fd, filename_ptr, NULL, NULL, NULL);
}

static loff_t enforce_handler_pos_val;

static int enforce_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
	loff_t **pos_ptr = (loff_t **)&PT_REGS_CCALL_PARM4(regs);
	enforce_handler_pos_val = **pos_ptr;
	return 0;
}
static void enforce_handler_post(struct kprobe *p, struct pt_regs *regs, unsigned long i)
{
	char __user **buf_ptr = (char **)&PT_REGS_PARM2(regs);
	size_t *count_ptr = (size_t *)&PT_REGS_PARM3(regs);
	loff_t **pos_ptr = (loff_t **)&PT_REGS_CCALL_PARM4(regs);
	**pos_ptr = enforce_handler_pos_val;
 	simple_read_from_buffer(*buf_ptr, *count_ptr, *pos_ptr, "1", 1);
}

static struct kprobe faccessat_kp = {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0)
	.symbol_name = "do_faccessat",
#else
	.symbol_name = "sys_faccessat",
#endif
	.pre_handler = faccessat_handler_pre,
};

static struct kprobe newfstatat_kp = {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
	.symbol_name = "vfs_statx",
#else
	.symbol_name = "vfs_fstatat",
#endif
	.pre_handler = newfstatat_handler_pre,
};

static struct kprobe execve_kp = {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
	.symbol_name = "do_execveat_common",
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
	.symbol_name = "__do_execve_file",
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
	.symbol_name = "do_execveat_common",
#endif
	.pre_handler = execve_handler_pre,
};

static struct kprobe sel_read_enforce_kp = {
	.symbol_name = "sel_read_enforce",
	.pre_handler = enforce_handler_pre,
	.post_handler = enforce_handler_post,
};

#endif

// sucompat: permited process can execute 'su' to gain root access.
void ksu_enable_sucompat()
{
#ifdef CONFIG_KPROBES
	int ret;
	ret = register_kprobe(&execve_kp);
	pr_info("sucompat: execve_kp: %d\n", ret);
	ret = register_kprobe(&newfstatat_kp);
	pr_info("sucompat: newfstatat_kp: %d\n", ret);
	ret = register_kprobe(&faccessat_kp);
	pr_info("sucompat: faccessat_kp: %d\n", ret);
	ret = register_kprobe(&sel_read_enforce_kp);
	pr_info("sucompat: sel_read_enforce_kp: %d\n", ret);
#endif
}

```

`kernel/uid_observer.c`:

```c
#include "linux/err.h"
#include "linux/fs.h"
#include "linux/list.h"
#include "linux/slab.h"
#include "linux/string.h"
#include "linux/types.h"
#include "linux/version.h"
#include "linux/workqueue.h"

#include "allowlist.h"
#include "klog.h" // IWYU pragma: keep
#include "ksu.h"
#include "manager.h"
#include "uid_observer.h"
#include "kernel_compat.h"

#define SYSTEM_PACKAGES_LIST_PATH "/data/system/packages.list"
static struct work_struct ksu_update_uid_work;

struct uid_data {
	struct list_head list;
	u32 uid;
};

static bool is_uid_exist(uid_t uid, void *data)
{
	struct list_head *list = (struct list_head *)data;
	struct uid_data *np;

	bool exist = false;
	list_for_each_entry (np, list, list) {
		if (np->uid == uid % 100000) {
			exist = true;
			break;
		}
	}
	return exist;
}

static void do_update_uid(struct work_struct *work)
{
	struct file *fp = ksu_filp_open_compat(SYSTEM_PACKAGES_LIST_PATH, O_RDONLY, 0);
	if (IS_ERR(fp)) {
		pr_err("do_update_uid, open " SYSTEM_PACKAGES_LIST_PATH
		       " failed: %d\n",
		       PTR_ERR(fp));
		return;
	}

	struct list_head uid_list;
	INIT_LIST_HEAD(&uid_list);

	char chr = 0;
	loff_t pos = 0;
	loff_t line_start = 0;
	char buf[128];
	for (;;) {
		ssize_t count =
			ksu_kernel_read_compat(fp, &chr, sizeof(chr), &pos);
		if (count != sizeof(chr))
			break;
		if (chr != '\n')
			continue;

		count = ksu_kernel_read_compat(fp, buf, sizeof(buf),
					       &line_start);

		struct uid_data *data =
			kmalloc(sizeof(struct uid_data), GFP_ATOMIC);
		if (!data) {
			goto out;
		}

		char *tmp = buf;
		const char *delim = " ";
		strsep(&tmp, delim); // skip package
		char *uid = strsep(&tmp, delim);
		if (!uid) {
			pr_err("update_uid: uid is NULL!\n");
			continue;
		}

		u32 res;
		if (kstrtou32(uid, 10, &res)) {
			pr_err("update_uid: uid parse err\n");
			continue;
		}
		data->uid = res;
		list_add_tail(&data->list, &uid_list);
		// reset line start
		line_start = pos;
	}

	// now update uid list
	struct uid_data *np;
	struct uid_data *n;

	// first, check if manager_uid exist!
	bool manager_exist = false;
	list_for_each_entry (np, &uid_list, list) {
		// if manager is installed in work profile, the uid in packages.list is still equals main profile
		// don't delete it in this case!
		int manager_uid = ksu_get_manager_uid() % 100000;
		if (np->uid == manager_uid) {
			manager_exist = true;
			break;
		}
	}

	if (!manager_exist && ksu_is_manager_uid_valid()) {
		pr_info("manager is uninstalled, invalidate it!\n");
		ksu_invalidate_manager_uid();
	}

	// then prune the allowlist
	ksu_prune_allowlist(is_uid_exist, &uid_list);
out:
	// free uid_list
	list_for_each_entry_safe (np, n, &uid_list, list) {
		list_del(&np->list);
		kfree(np);
	}
	filp_close(fp, 0);
}

void update_uid()
{
	ksu_queue_work(&ksu_update_uid_work);
}

int ksu_uid_observer_init()
{
	INIT_WORK(&ksu_update_uid_work, do_update_uid);
	return 0;
}

int ksu_uid_observer_exit()
{
	return 0;
}

```

`kernel/uid_observer.h`:

```h
#ifndef __KSU_H_UID_OBSERVER
#define __KSU_H_UID_OBSERVER

int ksu_uid_observer_init();

int ksu_uid_observer_exit();

void update_uid();

#endif

```

`manager/app/build.gradle.kts`:

```kts
import com.android.build.gradle.internal.api.BaseVariantOutputImpl

plugins {
    alias(libs.plugins.agp.app)
    alias(libs.plugins.kotlin)
    alias(libs.plugins.ksp)
    alias(libs.plugins.lsplugin.apksign)
    id("kotlin-parcelize")
}

val managerVersionCode: Int by rootProject.extra
val managerVersionName: String by rootProject.extra

apksign {
    storeFileProperty = "KEYSTORE_FILE"
    storePasswordProperty = "KEYSTORE_PASSWORD"
    keyAliasProperty = "KEY_ALIAS"
    keyPasswordProperty = "KEY_PASSWORD"
}

android {
    namespace = "me.weishu.kernelsu"

    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }

    buildFeatures {
        aidl = true
        buildConfig = true
        compose = true
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.4.3"
    }

    packaging {
        jniLibs {
            useLegacyPackaging = true
        }
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }

    externalNativeBuild {
        cmake {
            path("src/main/cpp/CMakeLists.txt")
        }
    }

    applicationVariants.all {
        outputs.forEach {
            val output = it as BaseVariantOutputImpl
            output.outputFileName = "KernelSU_${managerVersionName}_${managerVersionCode}-$name.apk"
        }

        kotlin.sourceSets {
            getByName(name) {
                kotlin.srcDir("build/generated/ksp/$name/kotlin")
            }
        }
    }
}

dependencies {
    implementation(libs.androidx.activity.compose)
    implementation(libs.androidx.navigation.compose)

    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.compose.material.icons.extended)
    implementation(libs.androidx.compose.material)
    implementation(libs.androidx.compose.material3)
    implementation(libs.androidx.compose.ui)
    implementation(libs.androidx.compose.ui.tooling.preview)

    debugImplementation(libs.androidx.compose.ui.test.manifest)
    debugImplementation(libs.androidx.compose.ui.tooling)

    implementation(libs.androidx.lifecycle.runtime.compose)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.lifecycle.viewmodel.compose)

    implementation(libs.com.google.accompanist.drawablepainter)
    implementation(libs.com.google.accompanist.navigation.animation)
    implementation(libs.com.google.accompanist.systemuicontroller)

    implementation(libs.compose.destinations.animations.core)
    ksp(libs.compose.destinations.ksp)

    implementation(libs.com.github.topjohnwu.libsu.core)
    implementation(libs.com.github.topjohnwu.libsu.service)

    implementation(libs.dev.rikka.rikkax.parcelablelist)

    implementation(libs.io.coil.kt.coil.compose)

    implementation(libs.kotlinx.coroutines.core)

    implementation(libs.me.zhanghai.android.appiconloader.coil)

    implementation(libs.sheet.compose.dialogs.core)
    implementation(libs.sheet.compose.dialogs.list)
    implementation(libs.sheet.compose.dialogs.input)
}

```

`manager/app/proguard-rules.pro`:

```pro
-dontwarn org.bouncycastle.jsse.BCSSLParameters
-dontwarn org.bouncycastle.jsse.BCSSLSocket
-dontwarn org.bouncycastle.jsse.provider.BouncyCastleJsseProvider
-dontwarn org.conscrypt.Conscrypt$Version
-dontwarn org.conscrypt.Conscrypt
-dontwarn org.conscrypt.ConscryptHostnameVerifier
-dontwarn org.openjsse.javax.net.ssl.SSLParameters
-dontwarn org.openjsse.javax.net.ssl.SSLSocket
-dontwarn org.openjsse.net.ssl.OpenJSSE

```

`manager/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:name=".KernelSUApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:enableOnBackInvokedCallback="true"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.KernelSU"
        tools:targetApi="33">
        <activity
            android:name=".ui.MainActivity"
            android:exported="true"
            android:theme="@style/Theme.KernelSU">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <meta-data
                android:name="android.app.lib_name"
                android:value="" />
        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths" />
        </provider>
    </application>

</manifest>

```

`manager/app/src/main/aidl/me/weishu/kernelsu/IKsuInterface.aidl`:

```aidl
// IKsuInterface.aidl
package me.weishu.kernelsu;

import android.content.pm.PackageInfo;
import rikka.parcelablelist.ParcelableListSlice;

interface IKsuInterface {
    ParcelableListSlice<PackageInfo> getPackages(int flags);
}
```

`manager/app/src/main/cpp/CMakeLists.txt`:

```txt

# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.
cmake_minimum_required(VERSION 3.18.1)

project("kernelsu")

add_library(kernelsu
        SHARED
        jni.cc
        ksu.cc
        )

find_library(log-lib log)

target_link_libraries(kernelsu ${log-lib})
```

`manager/app/src/main/cpp/jni.cc`:

```cc
#include <jni.h>

#include <sys/prctl.h>

#include <android/log.h>
#include <cstring>

#include "ksu.h"

#define LOG_TAG "KernelSU"
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_becomeManager(JNIEnv *env, jobject, jstring pkg) {
    auto cpkg = env->GetStringUTFChars(pkg, nullptr);
    auto result = become_manager(cpkg);
    env->ReleaseStringUTFChars(pkg, cpkg);
    return result;
}

extern "C"
JNIEXPORT jint JNICALL
Java_me_weishu_kernelsu_Natives_getVersion(JNIEnv *env, jobject) {
    return get_version();
}

extern "C"
JNIEXPORT jintArray JNICALL
Java_me_weishu_kernelsu_Natives_getAllowList(JNIEnv *env, jobject) {
    int uids[1024];
    int size = 0;
    bool result = get_allow_list(uids, &size);
    LOGD("getAllowList: %d, size: %d", result, size);
    if (result) {
        auto array = env->NewIntArray(size);
        env->SetIntArrayRegion(array, 0, size, uids);
        return array;
    }
    return env->NewIntArray(0);
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_isSafeMode(JNIEnv *env, jclass clazz) {
    return is_safe_mode();
}

static void fillIntArray(JNIEnv *env, jobject list, int *data, int count) {
    auto cls = env->GetObjectClass(list);
    auto add = env->GetMethodID(cls, "add", "(Ljava/lang/Object;)Z");
    auto integerCls = env->FindClass("java/lang/Integer");
    auto constructor = env->GetMethodID(integerCls, "<init>", "(I)V");
    for (int i = 0; i < count; ++i) {
        auto integer = env->NewObject(integerCls, constructor, data[i]);
        env->CallBooleanMethod(list, add, integer);
    }
}

static void addIntToList(JNIEnv *env, jobject list, int ele) {
    auto cls = env->GetObjectClass(list);
    auto add = env->GetMethodID(cls, "add", "(Ljava/lang/Object;)Z");
    auto integerCls = env->FindClass("java/lang/Integer");
    auto constructor = env->GetMethodID(integerCls, "<init>", "(I)V");
    auto integer = env->NewObject(integerCls, constructor, ele);
    env->CallBooleanMethod(list, add, integer);
}

static uint64_t capListToBits(JNIEnv *env, jobject list) {
    auto cls = env->GetObjectClass(list);
    auto get = env->GetMethodID(cls, "get", "(I)Ljava/lang/Object;");
    auto size = env->GetMethodID(cls, "size", "()I");
    auto listSize = env->CallIntMethod(list, size);
    auto integerCls = env->FindClass("java/lang/Integer");
    auto intValue = env->GetMethodID(integerCls, "intValue", "()I");
    uint64_t result = 0;
    for (int i = 0; i < listSize; ++i) {
        auto integer = env->CallObjectMethod(list, get, i);
        int data = env->CallIntMethod(integer, intValue);

        if (cap_valid(data)) {
            result |= (1ULL << data);
        }
    }

    return result;
}

static int getListSize(JNIEnv *env, jobject list) {
    auto cls = env->GetObjectClass(list);
    auto size = env->GetMethodID(cls, "size", "()I");
    return env->CallIntMethod(list, size);
}

static void fillArrayWithList(JNIEnv *env, jobject list, int *data, int count) {
    auto cls = env->GetObjectClass(list);
    auto get = env->GetMethodID(cls, "get", "(I)Ljava/lang/Object;");
    auto integerCls = env->FindClass("java/lang/Integer");
    auto intValue = env->GetMethodID(integerCls, "intValue", "()I");
    for (int i = 0; i < count; ++i) {
        auto integer = env->CallObjectMethod(list, get, i);
        data[i] = env->CallIntMethod(integer, intValue);
    }
}

extern "C"
JNIEXPORT jobject JNICALL
Java_me_weishu_kernelsu_Natives_getAppProfile(JNIEnv *env, jobject, jstring pkg, jint uid) {
    if (env->GetStringLength(pkg) > KSU_MAX_PACKAGE_NAME) {
        return nullptr;
    }

    p_key_t key = {};
    auto cpkg = env->GetStringUTFChars(pkg, nullptr);
    strcpy(key, cpkg);
    env->ReleaseStringUTFChars(pkg, cpkg);

    app_profile profile = {};
    profile.version = KSU_APP_PROFILE_VER;

    strcpy(profile.key, key);
    profile.current_uid = uid;

    bool useDefaultProfile = !get_app_profile(key, &profile);

    auto cls = env->FindClass("me/weishu/kernelsu/Natives$Profile");
    auto constructor = env->GetMethodID(cls, "<init>", "()V");
    auto obj = env->NewObject(cls, constructor);
    auto keyField = env->GetFieldID(cls, "name", "Ljava/lang/String;");
    auto currentUidField = env->GetFieldID(cls, "currentUid", "I");
    auto allowSuField = env->GetFieldID(cls, "allowSu", "Z");

    auto rootUseDefaultField = env->GetFieldID(cls, "rootUseDefault", "Z");
    auto rootTemplateField = env->GetFieldID(cls, "rootTemplate", "Ljava/lang/String;");

    auto uidField = env->GetFieldID(cls, "uid", "I");
    auto gidField = env->GetFieldID(cls, "gid", "I");
    auto groupsField = env->GetFieldID(cls, "groups", "Ljava/util/List;");
    auto capabilitiesField = env->GetFieldID(cls, "capabilities", "Ljava/util/List;");
    auto domainField = env->GetFieldID(cls, "context", "Ljava/lang/String;");
    auto namespacesField = env->GetFieldID(cls, "namespace", "I");

    auto nonRootUseDefaultField = env->GetFieldID(cls, "nonRootUseDefault", "Z");
    auto umountModulesField = env->GetFieldID(cls, "umountModules", "Z");

    env->SetObjectField(obj, keyField, env->NewStringUTF(profile.key));
    env->SetIntField(obj, currentUidField, profile.current_uid);

    if (useDefaultProfile) {
        // no profile found, so just use default profile:
        // don't allow root and use default profile!
        LOGD("use default profile for: %s, %d", key, uid);

        // allow_su = false
        // non root use default = true
        env->SetBooleanField(obj, allowSuField, false);
        env->SetBooleanField(obj, nonRootUseDefaultField, true);

        jobject capList = env->GetObjectField(obj, capabilitiesField);
        int DEFAULT_CAPS[] = {CAP_DAC_READ_SEARCH};

        for (auto i: DEFAULT_CAPS) {
            addIntToList(env, capList, i);
        }

        return obj;
    }

    auto allowSu = profile.allow_su;

    if (allowSu) {
        env->SetBooleanField(obj, rootUseDefaultField, (jboolean) profile.rp_config.use_default);
        if (strlen(profile.rp_config.template_name) > 0) {
            env->SetObjectField(obj, rootTemplateField,
                                env->NewStringUTF(profile.rp_config.template_name));
        }

        env->SetIntField(obj, uidField, profile.rp_config.profile.uid);
        env->SetIntField(obj, gidField, profile.rp_config.profile.gid);

        jobject groupList = env->GetObjectField(obj, groupsField);
        int groupCount = profile.rp_config.profile.groups_count;
        if (groupCount > KSU_MAX_GROUPS) {
            LOGD("kernel group count too large: %d???", groupCount);
            groupCount = KSU_MAX_GROUPS;
        }
        fillIntArray(env, groupList, profile.rp_config.profile.groups, groupCount);

        jobject capList = env->GetObjectField(obj, capabilitiesField);
        for (int i = 0; i <= CAP_LAST_CAP; i++) {
            if (profile.rp_config.profile.capabilities.effective & (1ULL << i)) {
                addIntToList(env, capList, i);
            }
        }

        env->SetObjectField(obj, domainField,
                            env->NewStringUTF(profile.rp_config.profile.selinux_domain));
        env->SetIntField(obj, namespacesField, profile.rp_config.profile.namespaces);
        env->SetBooleanField(obj, allowSuField, profile.allow_su);
    } else {
        env->SetBooleanField(obj, nonRootUseDefaultField,
                             (jboolean) profile.nrp_config.use_default);
        env->SetBooleanField(obj, umountModulesField, profile.nrp_config.profile.umount_modules);
    }

    return obj;
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_setAppProfile(JNIEnv *env, jobject clazz, jobject profile) {
    auto cls = env->FindClass("me/weishu/kernelsu/Natives$Profile");

    auto keyField = env->GetFieldID(cls, "name", "Ljava/lang/String;");
    auto currentUidField = env->GetFieldID(cls, "currentUid", "I");
    auto allowSuField = env->GetFieldID(cls, "allowSu", "Z");

    auto rootUseDefaultField = env->GetFieldID(cls, "rootUseDefault", "Z");
    auto rootTemplateField = env->GetFieldID(cls, "rootTemplate", "Ljava/lang/String;");

    auto uidField = env->GetFieldID(cls, "uid", "I");
    auto gidField = env->GetFieldID(cls, "gid", "I");
    auto groupsField = env->GetFieldID(cls, "groups", "Ljava/util/List;");
    auto capabilitiesField = env->GetFieldID(cls, "capabilities", "Ljava/util/List;");
    auto domainField = env->GetFieldID(cls, "context", "Ljava/lang/String;");
    auto namespacesField = env->GetFieldID(cls, "namespace", "I");

    auto nonRootUseDefaultField = env->GetFieldID(cls, "nonRootUseDefault", "Z");
    auto umountModulesField = env->GetFieldID(cls, "umountModules", "Z");

    auto key = env->GetObjectField(profile, keyField);
    if (!key) {
        return false;
    }
    if (env->GetStringLength((jstring) key) > KSU_MAX_PACKAGE_NAME) {
        return false;
    }

    auto cpkg = env->GetStringUTFChars((jstring) key, nullptr);
    p_key_t p_key = {};
    strcpy(p_key, cpkg);
    env->ReleaseStringUTFChars((jstring) key, cpkg);

    auto currentUid = env->GetIntField(profile, currentUidField);

    auto uid = env->GetIntField(profile, uidField);
    auto gid = env->GetIntField(profile, gidField);
    auto groups = env->GetObjectField(profile, groupsField);
    auto capabilities = env->GetObjectField(profile, capabilitiesField);
    auto domain = env->GetObjectField(profile, domainField);
    auto allowSu = env->GetBooleanField(profile, allowSuField);
    auto umountModules = env->GetBooleanField(profile, umountModulesField);

    app_profile p = {};
    p.version = KSU_APP_PROFILE_VER;

    strcpy(p.key, p_key);
    p.allow_su = allowSu;
    p.current_uid = currentUid;

    if (allowSu) {
        p.rp_config.use_default = env->GetBooleanField(profile, rootUseDefaultField);
        auto templateName = env->GetObjectField(profile, rootTemplateField);
        if (templateName) {
            auto ctemplateName = env->GetStringUTFChars((jstring) templateName, nullptr);
            strcpy(p.rp_config.template_name, ctemplateName);
            env->ReleaseStringUTFChars((jstring) templateName, ctemplateName);
        }

        p.rp_config.profile.uid = uid;
        p.rp_config.profile.gid = gid;

        int groups_count = getListSize(env, groups);
        if (groups_count > KSU_MAX_GROUPS) {
            LOGD("groups count too large: %d", groups_count);
            return false;
        }
        p.rp_config.profile.groups_count = groups_count;
        fillArrayWithList(env, groups, p.rp_config.profile.groups, groups_count);

        p.rp_config.profile.capabilities.effective = capListToBits(env, capabilities);

        auto cdomain = env->GetStringUTFChars((jstring) domain, nullptr);
        strcpy(p.rp_config.profile.selinux_domain, cdomain);
        env->ReleaseStringUTFChars((jstring) domain, cdomain);

        p.rp_config.profile.namespaces = env->GetIntField(profile, namespacesField);
    } else {
        p.nrp_config.use_default = env->GetBooleanField(profile, nonRootUseDefaultField);
        p.nrp_config.profile.umount_modules = umountModules;
    }

    return set_app_profile(&p);
}
extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_uidShouldUmount(JNIEnv *env, jobject thiz, jint uid) {
    return uid_should_umount(uid);
}
```

`manager/app/src/main/cpp/ksu.cc`:

```cc
//
// Created by weishu on 2022/12/9.
//

#include <sys/prctl.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

#include "ksu.h"

#define KERNEL_SU_OPTION 0xDEADBEEF

#define CMD_GRANT_ROOT 0

#define CMD_BECOME_MANAGER 1
#define CMD_GET_VERSION 2
#define CMD_ALLOW_SU 3
#define CMD_DENY_SU 4
#define CMD_GET_SU_LIST 5
#define CMD_GET_DENY_LIST 6
#define CMD_CHECK_SAFEMODE 9

#define CMD_GET_APP_PROFILE 10
#define CMD_SET_APP_PROFILE 11

#define CMD_IS_UID_GRANTED_ROOT 12
#define CMD_IS_UID_SHOULD_UMOUNT 13

static bool ksuctl(int cmd, void* arg1, void* arg2) {
    int32_t result = 0;
    prctl(KERNEL_SU_OPTION, cmd, arg1, arg2, &result);
    return result == KERNEL_SU_OPTION;
}

bool become_manager(const char* pkg) {
    char param[128];
    uid_t uid = getuid();
    uint32_t userId = uid / 100000;
    if (userId == 0) {
        sprintf(param, "/data/data/%s", pkg);
    } else {
        snprintf(param, sizeof(param), "/data/user/%d/%s", userId, pkg);
    }

    return ksuctl(CMD_BECOME_MANAGER, param, nullptr);
}

int get_version() {
    int32_t version = -1;
    if (ksuctl(CMD_GET_VERSION, &version, nullptr)) {
        return version;
    }
    return version;
}

bool get_allow_list(int *uids, int *size) {
    return ksuctl(CMD_GET_SU_LIST, uids, size);
}

bool is_safe_mode() {
    return ksuctl(CMD_CHECK_SAFEMODE, nullptr, nullptr);
}

bool uid_should_umount(int uid) {
    bool should;
    return ksuctl(CMD_IS_UID_SHOULD_UMOUNT, reinterpret_cast<void*>(uid), &should) && should;
}

bool set_app_profile(const app_profile *profile) {
    return ksuctl(CMD_SET_APP_PROFILE, (void*) profile, nullptr);
}

bool get_app_profile(p_key_t key, app_profile *profile) {
    return ksuctl(CMD_GET_APP_PROFILE, (void*) profile, nullptr);
}

```

`manager/app/src/main/cpp/ksu.h`:

```h
//
// Created by weishu on 2022/12/9.
//

#ifndef KERNELSU_KSU_H
#define KERNELSU_KSU_H

#include <linux/capability.h>

bool become_manager(const char *);

int get_version();

bool get_allow_list(int *uids, int *size);

bool uid_should_umount(int uid);

bool is_safe_mode();

#define KSU_APP_PROFILE_VER 2
#define KSU_MAX_PACKAGE_NAME 256
// NGROUPS_MAX for Linux is 65535 generally, but we only supports 32 groups.
#define KSU_MAX_GROUPS 32
#define KSU_SELINUX_DOMAIN 64

using p_key_t = char[KSU_MAX_PACKAGE_NAME];

struct root_profile {
    int32_t uid;
    int32_t gid;

    int32_t groups_count;
    int32_t groups[KSU_MAX_GROUPS];

    // kernel_cap_t is u32[2] for capabilities v3
    struct {
        uint64_t effective;
        uint64_t permitted;
        uint64_t inheritable;
    } capabilities;

    char selinux_domain[KSU_SELINUX_DOMAIN];

    int32_t namespaces;
};

struct non_root_profile {
    bool umount_modules;
};

struct app_profile {
    // It may be utilized for backward compatibility, although we have never explicitly made any promises regarding this.
    uint32_t version;

    // this is usually the package of the app, but can be other value for special apps
    char key[KSU_MAX_PACKAGE_NAME];
    int32_t current_uid;
    bool allow_su;

    union {
        struct {
            bool use_default;
            char template_name[KSU_MAX_PACKAGE_NAME];

            struct root_profile profile;
        } rp_config;

        struct {
            bool use_default;

            struct non_root_profile profile;
        } nrp_config;
    };
};

bool set_app_profile(const app_profile *profile);

bool get_app_profile(p_key_t key, app_profile *profile);

#endif //KERNELSU_KSU_H

```

`manager/app/src/main/java/me/weishu/kernelsu/KernelSUApplication.kt`:

```kt
package me.weishu.kernelsu

import android.app.Application
import coil.Coil
import coil.ImageLoader
import me.zhanghai.android.appiconloader.coil.AppIconFetcher
import me.zhanghai.android.appiconloader.coil.AppIconKeyer

lateinit var ksuApp: KernelSUApplication

class KernelSUApplication : Application() {

    override fun onCreate() {
        super.onCreate()
        ksuApp = this

        val context = this
        val iconSize = resources.getDimensionPixelSize(android.R.dimen.app_icon_size)
        Coil.setImageLoader(
            ImageLoader.Builder(context)
                .components {
                    add(AppIconKeyer())
                    add(AppIconFetcher.Factory(iconSize, false, context))
                }
                .build()
        )
    }


}
```

`manager/app/src/main/java/me/weishu/kernelsu/Kernels.kt`:

```kt
package me.weishu.kernelsu

import android.system.Os

/**
 * @author weishu
 * @date 2022/12/10.
 */

data class KernelVersion(val major: Int, val patchLevel: Int, val subLevel: Int) {
    override fun toString(): String {
        return "$major.$patchLevel.$subLevel"
    }

    fun isGKI(): Boolean {

        // kernel 6.x
        if (major > 5) {
            return true
        }

        // kernel 5.10.x
        if (major == 5) {
            return patchLevel >= 10
        }

        return false
    }
}

fun parseKernelVersion(version: String): KernelVersion {
    val find = "(\\d+)\\.(\\d+)\\.(\\d+)".toRegex().find(version)
    return if (find != null) {
        KernelVersion(find.groupValues[1].toInt(), find.groupValues[2].toInt(), find.groupValues[3].toInt())
    } else {
        KernelVersion(-1, -1, -1)
    }
}

fun getKernelVersion(): KernelVersion {
    Os.uname().release.let {
        return parseKernelVersion(it)
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/Natives.kt`:

```kt
package me.weishu.kernelsu

import android.os.Parcelable
import androidx.annotation.Keep
import androidx.compose.runtime.Immutable
import kotlinx.parcelize.Parcelize

/**
 * @author weishu
 * @date 2022/12/8.
 */
object Natives {
    // minimal supported kernel version
    // 10915: allowlist breaking change, add app profile
    // 10931: app profile struct add 'version' field
    // 10946: add capabilities
    // 10977: change groups_count and groups to avoid overflow write
    // 11071: Fix the issue of failing to set a custom SELinux type.
    const val MINIMAL_SUPPORTED_KERNEL = 11071

    init {
        System.loadLibrary("kernelsu")
    }

    // become root manager, return true if success.
    external fun becomeManager(pkg: String?): Boolean
    val version: Int
        external get

    // get the uid list of allowed su processes.
    val allowList: IntArray
        external get

    val isSafeMode: Boolean
        external get

    external fun uidShouldUmount(uid: Int): Boolean

    /**
     * Get the profile of the given package.
     * @param key usually the package name
     * @return return null if failed.
     */
    external fun getAppProfile(key: String?, uid: Int): Profile
    external fun setAppProfile(profile: Profile?): Boolean

    private const val NON_ROOT_DEFAULT_PROFILE_KEY = "$"
    private const val ROOT_DEFAULT_PROFILE_KEY = "#"
    private const val NOBODY_UID = 9999

    fun setDefaultUmountModules(umountModules: Boolean): Boolean {
        Profile(
            NON_ROOT_DEFAULT_PROFILE_KEY,
            NOBODY_UID,
            false,
            umountModules = umountModules
        ).let {
            return setAppProfile(it)
        }
    }

    fun isDefaultUmountModules(): Boolean {
        getAppProfile(NON_ROOT_DEFAULT_PROFILE_KEY, NOBODY_UID).let {
            return it.umountModules
        }
    }

    fun requireNewKernel(): Boolean {
        return version < MINIMAL_SUPPORTED_KERNEL
    }

    @Immutable
    @Parcelize
    @Keep
    data class Profile(
        // and there is a default profile for root and non-root
        val name: String,
        // current uid for the package, this is convivent for kernel to check
        // if the package name doesn't match uid, then it should be invalidated.
        val currentUid: Int = 0,

        // if this is true, kernel will grant root permission to this package
        val allowSu: Boolean = false,

        // these are used for root profile
        val rootUseDefault: Boolean = true,
        val rootTemplate: String? = null,
        val uid: Int = 0,
        val gid: Int = 0,
        val groups: List<Int> = mutableListOf(),
        val capabilities: List<Int> = mutableListOf(),
        val context: String = "u:r:su:s0",
        val namespace: Int = Namespace.Inherited.ordinal,

        val nonRootUseDefault: Boolean = true,
        val umountModules: Boolean = true,
        var rules: String = "", // this field is save in ksud!!
    ) : Parcelable {
        enum class Namespace {
            Inherited,
            Global,
            Individual,
        }

        constructor() : this("")
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/profile/Capabilities.kt`:

```kt
package me.weishu.kernelsu.profile

/**
 * @author weishu
 * @date 2023/6/3.
 */
enum class Capabilities(val cap: Int, val display: String, val desc: String) {
    CAP_CHOWN(0, "CHOWN", "Make arbitrary changes to file UIDs and GIDs (see chown(2))"),
    CAP_DAC_OVERRIDE(1, "DAC_OVERRIDE", "Bypass file read, write, and execute permission checks"),
    CAP_DAC_READ_SEARCH(2, "DAC_READ_SEARCH", "Bypass file read permission checks and directory read and execute permission checks"),
    CAP_FOWNER(3, "FOWNER", "Bypass permission checks on operations that normally require the filesystem UID of the process to match the UID of the file (e.g., chmod(2), utime(2)), excluding those operations covered by CAP_DAC_OVERRIDE and CAP_DAC_READ_SEARCH"),
    CAP_FSETID(4, "FSETID", "Don’t clear set-user-ID and set-group-ID permission bits when a file is modified; set the set-group-ID bit for a file whose GID does not match the filesystem or any of the supplementary GIDs of the calling process"),
    CAP_KILL(5, "KILL", "Bypass permission checks for sending signals (see kill(2))."),
    CAP_SETGID(6, "SETGID", "Make arbitrary manipulations of process GIDs and supplementary GID list; allow setgid(2) manipulation of the caller’s effective and real group IDs"),
    CAP_SETUID(7, "SETUID", "Make arbitrary manipulations of process UIDs (setuid(2), setreuid(2), setresuid(2), setfsuid(2)); allow changing the current process user IDs; allow changing of the current process group ID to any value in the system’s range of legal group IDs"),
    CAP_SETPCAP(8, "SETPCAP", "If file capabilities are supported: grant or remove any capability in the caller’s permitted capability set to or from any other process. (This property supersedes the obsolete notion of giving a process all capabilities by granting all capabilities in its permitted set, and of removing all capabilities from a process by granting no capabilities in its permitted set. It does not permit any actions that were not permitted before.)"),
    CAP_LINUX_IMMUTABLE(9, "LINUX_IMMUTABLE", "Set the FS_APPEND_FL and FS_IMMUTABLE_FL inode flags (see chattr(1))."),
    CAP_NET_BIND_SERVICE(10, "NET_BIND_SERVICE", "Bind a socket to Internet domain"),
    CAP_NET_BROADCAST(11, "NET_BROADCAST", "Make socket broadcasts, and listen to multicasts"),
    CAP_NET_ADMIN(12, "NET_ADMIN", "Perform various network-related operations: interface configuration, administration of IP firewall, masquerading, and accounting, modify routing tables, bind to any address for transparent proxying, set type-of-service (TOS), clear driver statistics, set promiscuous mode, enabling multicasting, use setsockopt(2) to set the following socket options: SO_DEBUG, SO_MARK, SO_PRIORITY (for a priority outside the range 0 to 6), SO_RCVBUFFORCE, and SO_SNDBUFFORCE"),
    CAP_NET_RAW(13, "NET_RAW", "Use RAW and PACKET sockets"),
    CAP_IPC_LOCK(14, "IPC_LOCK", "Lock memory (mlock(2), mlockall(2), mmap(2), shmctl(2))"),
    CAP_IPC_OWNER(15, "IPC_OWNER", "Bypass permission checks for operations on System V IPC objects"),
    CAP_SYS_MODULE(16, "SYS_MODULE", "Load and unload kernel modules (see init_module(2) and delete_module(2)); in kernels before 2.6.25, this also granted rights for various other operations related to kernel modules"),
    CAP_SYS_RAWIO(17, "SYS_RAWIO", "Perform I/O port operations (iopl(2) and ioperm(2)); access /proc/kcore"),
    CAP_SYS_CHROOT(18, "SYS_CHROOT", "Use chroot(2)"),
    CAP_SYS_PTRACE(19, "SYS_PTRACE", "Trace arbitrary processes using ptrace(2)"),
    CAP_SYS_PACCT(20, "SYS_PACCT", "Use acct(2)"),
    CAP_SYS_ADMIN(21, "SYS_ADMIN", "Perform a range of system administration operations including: quotactl(2), mount(2), umount(2), swapon(2), swapoff(2), sethostname(2), and setdomainname(2); set and modify process resource limits (setrlimit(2)); perform various network-related operations (e.g., setting privileged socket options, enabling multicasting, interface configuration); perform various IPC operations (e.g., SysV semaphores, POSIX message queues, System V shared memory); allow reboot and kexec_load(2); override /proc/sys kernel tunables; perform ptrace(2) PTRACE_SECCOMP_GET_FILTER operation; perform some tracing and debugging operations (see ptrace(2)); administer the lifetime of kernel tracepoints (tracefs(5)); perform the KEYCTL_CHOWN and KEYCTL_SETPERM keyctl(2) operations; perform the following keyctl(2) operations: KEYCTL_CAPABILITIES, KEYCTL_CAPSQUASH, and KEYCTL_PKEY_ OPERATIONS; set state for the Extensible Authentication Protocol (EAP) kernel module; and override the RLIMIT_NPROC resource limit; allow ioperm/iopl access to I/O ports"),
    CAP_SYS_BOOT(22, "SYS_BOOT", "Use reboot(2) and kexec_load(2), reboot and load a new kernel for later execution"),
    CAP_SYS_NICE(23, "SYS_NICE", "Raise process nice value (nice(2), setpriority(2)) and change the nice value for arbitrary processes; set real-time scheduling policies for calling process, and set scheduling policies and priorities for arbitrary processes (sched_setscheduler(2), sched_setparam(2)"),
    CAP_SYS_RESOURCE(24, "SYS_RESOURCE", "Override resource Limits. Set resource limits (setrlimit(2), prlimit(2)), override quota limits (quota(2), quotactl(2)), override reserved space on ext2 filesystem (ext2_ioctl(2)), override size restrictions on IPC message queues (msg(2)) and system V shared memory segments (shmget(2)), and override the /proc/sys/fs/pipe-size-max limit"),
    CAP_SYS_TIME(25, "SYS_TIME", "Set system clock (settimeofday(2), stime(2), adjtimex(2)); set real-time (hardware) clock"),
    CAP_SYS_TTY_CONFIG(26, "SYS_TTY_CONFIG", "Use vhangup(2); employ various privileged ioctl(2) operations on virtual terminals"),
    CAP_MKNOD(27, "MKNOD", "Create special files using mknod(2)"),
    CAP_LEASE(28, "LEASE", "Establish leases on arbitrary files (see fcntl(2))"),
    CAP_AUDIT_WRITE(29, "AUDIT_WRITE", "Write records to kernel auditing log"),
    CAP_AUDIT_CONTROL(30, "AUDIT_CONTROL", "Enable and disable kernel auditing; change auditing filter rules; retrieve auditing status and filtering rules"),
    CAP_SETFCAP(31, "SETFCAP", "If file capabilities are supported: grant or remove any capability in any capability set to any file"),
    CAP_MAC_OVERRIDE(32, "MAC_OVERRIDE", "Override Mandatory Access Control (MAC). Implemented for the Smack Linux Security Module (LSM)"),
    CAP_MAC_ADMIN(33, "MAC_ADMIN", "Allow MAC configuration or state changes. Implemented for the Smack LSM"),
    CAP_SYSLOG(34, "SYSLOG", "Perform privileged syslog(2) operations. See syslog(2) for information on which operations require privilege"),
    CAP_WAKE_ALARM(35, "WAKE_ALARM", "Trigger something that will wake up the system"),
    CAP_BLOCK_SUSPEND(36, "BLOCK_SUSPEND", "Employ features that can block system suspend"),
    CAP_AUDIT_READ(37, "AUDIT_READ", "Allow reading the audit log via a multicast netlink socket"),
    CAP_PERFMON(38, "PERFMON", "Allow performance monitoring via perf_event_open(2)"),
    CAP_BPF(39, "BPF", "Allow BPF operations via bpf(2)"),
    CAP_CHECKPOINT_RESTORE(40, "CHECKPOINT_RESTORE", "Allow processes to be checkpointed via checkpoint/restore in user namespace(2)"),
}
```

`manager/app/src/main/java/me/weishu/kernelsu/profile/Groups.kt`:

```kt
package me.weishu.kernelsu.profile

/**
 * @author weishu
 * @date 2023/6/3.
 */
enum class Groups(val gid: Int, val display: String, val desc: String) {
    ROOT(0, "root", "traditional unix root user"),
    DAEMON(1, "daemon", "Traditional unix daemon owner."),
    BIN(2, "bin", "Traditional unix binaries owner."),
    SYS(3, "sys", "A group with the same gid on Linux/macOS/Android."),
    SYSTEM(1000, "system", "system server"),
    RADIO(1001, "radio", "telephony subsystem, RIL"),
    BLUETOOTH(1002, "bluetooth", "bluetooth subsystem"),
    GRAPHICS(1003, "graphics", "graphics devices"),
    INPUT(1004, "input", "input devices"),
    AUDIO(1005, "audio", "audio devices"),
    CAMERA(1006, "camera", "camera devices"),
    LOG(1007, "log", "log devices"),
    COMPASS(1008, "compass", "compass device"),
    MOUNT(1009, "mount", "mountd socket"),
    WIFI(1010, "wifi", "wifi subsystem"),
    ADB(1011, "adb", "android debug bridge (adbd)"),
    INSTALL(1012, "install", "group for installing packages"),
    MEDIA(1013, "media", "mediaserver process"),
    DHCP(1014, "dhcp", "dhcp client"),
    SDCARD_RW(1015, "sdcard_rw", "external storage write access"),
    VPN(1016, "vpn", "vpn system"),
    KEYSTORE(1017, "keystore", "keystore subsystem"),
    USB(1018, "usb", "USB devices"),
    DRM(1019, "drm", "DRM server"),
    MDNSR(1020, "mdnsr", "MulticastDNSResponder (service discovery)"),
    GPS(1021, "gps", "GPS daemon"),
    UNUSED1(1022, "unused1", "deprecated, DO NOT USE"),
    MEDIA_RW(1023, "media_rw", "internal media storage write access"),
    MTP(1024, "mtp", "MTP USB driver access"),
    UNUSED2(1025, "unused2", "deprecated, DO NOT USE"),
    DRMRPC(1026, "drmrpc", "group for drm rpc"),
    NFC(1027, "nfc", "nfc subsystem"),
    SDCARD_R(1028, "sdcard_r", "external storage read access"),
    CLAT(1029, "clat", "clat part of nat464"),
    LOOP_RADIO(1030, "loop_radio", "loop radio devices"),
    MEDIA_DRM(1031, "media_drm", "MediaDrm plugins"),
    PACKAGE_INFO(1032, "package_info", "access to installed package details"),
    SDCARD_PICS(1033, "sdcard_pics", "external storage photos access"),
    SDCARD_AV(1034, "sdcard_av", "external storage audio/video access"),
    SDCARD_ALL(1035, "sdcard_all", "access all users external storage"),
    LOGD(1036, "logd", "log daemon"),
    SHARED_RELRO(1037, "shared_relro", "creator of shared GNU RELRO files"),
    DBUS(1038, "dbus", "dbus-daemon IPC broker process"),
    TLSDATE(1039, "tlsdate", "tlsdate unprivileged user"),
    MEDIA_EX(1040, "media_ex", "mediaextractor process"),
    AUDIOSERVER(1041, "audioserver", "audioserver process"),
    METRICS_COLL(1042, "metrics_coll", "metrics_collector process"),
    METRICSD(1043, "metricsd", "metricsd process"),
    WEBSERV(1044, "webserv", "webservd process"),
    DEBUGGERD(1045, "debuggerd", "debuggerd unprivileged user"),
    MEDIA_CODEC(1046, "media_codec", "media_codec process"),
    CAMERASERVER(1047, "cameraserver", "cameraserver process"),
    FIREWALL(1048, "firewall", "firewall process"),
    TRUNKS(1049, "trunks", "trunksd process"),
    NVRAM(1050, "nvram", "nvram daemon"),
    DNS_TETHER(1051, "dns_tether", "dns_tether device"),
    DNS_TETHER_RESERVED(1052, "dns_tether_reserved", "Reserved range for dns_tether"),
    WEBVIEW_ZYGOTE(1053, "webview_zygote", "zygote process"),
    WEBVIEW_USER(1054, "webview_user", "webview chromium user"),
    ETHERNET(1055, "ethernet", "Ethernet"),
    TOMBSTONED(1056, "tombstoned", "tombstoned process"),
    GRAPHICS_RW(1057, "graphics_rw", "graphics devices"),

    SHELL(2000, "shell", "adb and debug shell user"),
    CACHE(2001, "cache", "cache access"),
    DIAG(2002, "diag", "diagnostics"),
    NET_BT_ADMIN(3001, "net_bt_admin", "bluetooth: create any socket"),
    NET_BT(3002, "net_bt", "bluetooth: create sco, rfcomm or l2cap sockets"),
    INET(3003, "inet", "can create AF_INET and AF_INET6 sockets"),
    NET_RAW(3004, "net_raw", "can create raw INET sockets"),
    NET_ADMIN(3005, "net_admin", "can configure interfaces and routing tables."),
    NET_BW_STATS(3006, "net_bw_stats", "read bandwidth statistics"),
    NET_BW_ACCT(3007, "net_bw_acct", "change bandwidth statistics accounting"),
    NET_BT_STACK(3008, "net_bt_stack", "access to various bluetooth management functions"),
    QCOM_DIAG(3009, "qcom_diag", "allow msm specific diag commands"),
    EVERYBODY(9997, "everybody", "Shared external storage read/write"),
    MISC(9998, "misc", "Access to misc storage"),
    NOBODY(9999, "nobody", "Reserved"),
    APP(10000, "app", "Access to app data"),
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/KsuService.java`:

```java
package me.weishu.kernelsu.ui;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.UserHandle;
import android.os.UserManager;
import android.util.Log;

import androidx.annotation.NonNull;

import com.topjohnwu.superuser.ipc.RootService;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import me.weishu.kernelsu.IKsuInterface;
import rikka.parcelablelist.ParcelableListSlice;

/**
 * @author weishu
 * @date 2023/4/18.
 */

public class KsuService extends RootService {

    private static final String TAG = "KsuService";

    class Stub extends IKsuInterface.Stub {
        @Override
        public ParcelableListSlice<PackageInfo> getPackages(int flags) {
            List<PackageInfo> list = getInstalledPackagesAll(flags);
            Log.i(TAG, "getPackages: " + list.size());
            return new ParcelableListSlice<>(list);
        }
    }

    @Override
    public IBinder onBind(@NonNull Intent intent) {
        return new Stub();
    }

    List<Integer> getUserIds() {
        List<Integer> result = new ArrayList<>();
        UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
        List<UserHandle> userProfiles = um.getUserProfiles();
        for (UserHandle userProfile : userProfiles) {
            int userId = userProfile.hashCode();
            result.add(userProfile.hashCode());
        }
        return result;
    }

    ArrayList<PackageInfo> getInstalledPackagesAll(int flags) {
        ArrayList<PackageInfo> packages = new ArrayList<>();
        for (Integer userId : getUserIds()) {
            Log.i(TAG, "getInstalledPackagesAll: " + userId);
            packages.addAll(getInstalledPackagesAsUser(flags, userId));
        }
        return packages;
    }

    List<PackageInfo> getInstalledPackagesAsUser(int flags, int userId) {
        try {
            PackageManager pm = getPackageManager();
            Method getInstalledPackagesAsUser = pm.getClass().getDeclaredMethod("getInstalledPackagesAsUser", int.class, int.class);
            return (List<PackageInfo>) getInstalledPackagesAsUser.invoke(pm, flags, userId);
        } catch (Throwable e) {
            Log.e(TAG, "err", e);
        }

        return new ArrayList<>();
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/MainActivity.kt`:

```kt
package me.weishu.kernelsu.ui

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Icon
import androidx.compose.material3.NavigationBar
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import com.google.accompanist.navigation.animation.rememberAnimatedNavController
import com.ramcosta.composedestinations.DestinationsNavHost
import com.ramcosta.composedestinations.navigation.popBackStack
import com.ramcosta.composedestinations.utils.isRouteOnBackStackAsState
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.component.rememberDialogHostState
import me.weishu.kernelsu.ui.screen.BottomBarDestination
import me.weishu.kernelsu.ui.screen.NavGraphs
import me.weishu.kernelsu.ui.theme.KernelSUTheme
import me.weishu.kernelsu.ui.util.LocalDialogHost
import me.weishu.kernelsu.ui.util.LocalSnackbarHost

class MainActivity : ComponentActivity() {

    @OptIn(ExperimentalAnimationApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            KernelSUTheme {
                val navController = rememberAnimatedNavController()
                val snackbarHostState = remember { SnackbarHostState() }
                Scaffold(
                    bottomBar = { BottomBar(navController) },
                    snackbarHost = { SnackbarHost(snackbarHostState) }
                ) { innerPadding ->
                    CompositionLocalProvider(
                        LocalSnackbarHost provides snackbarHostState,
                        LocalDialogHost provides rememberDialogHostState(),
                    ) {
                        DestinationsNavHost(
                            modifier = Modifier.padding(innerPadding),
                            navGraph = NavGraphs.root,
                            navController = navController
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun BottomBar(navController: NavHostController) {
    val isManager = Natives.becomeManager(ksuApp.packageName)
    val fullFeatured = isManager && !Natives.requireNewKernel()
    NavigationBar(tonalElevation = 8.dp) {
        BottomBarDestination.values().forEach { destination ->
            if (!fullFeatured && destination.rootRequired) return@forEach
            val isCurrentDestOnBackStack by navController.isRouteOnBackStackAsState(destination.direction)
            NavigationBarItem(
                selected = isCurrentDestOnBackStack,
                onClick = {
                    if (isCurrentDestOnBackStack) {
                        navController.popBackStack(destination.direction, false)
                    }

                    navController.navigate(destination.direction.route) {
                        popUpTo(NavGraphs.root.route) {
                            saveState = true
                        }
                        launchSingleTop = true
                        restoreState = true
                    }
                },
                icon = {
                    if (isCurrentDestOnBackStack) {
                        Icon(destination.iconSelected, stringResource(destination.label))
                    } else {
                        Icon(destination.iconNotSelected, stringResource(destination.label))
                    }
                },
                label = { Text(stringResource(destination.label)) },
                alwaysShowLabel = false
            )
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/AboutCard.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.text.method.LinkMovementMethod
import android.widget.TextView
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.LocalContentColor
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.compose.ui.window.Dialog
import androidx.core.content.res.ResourcesCompat
import androidx.core.text.HtmlCompat
import com.google.accompanist.drawablepainter.rememberDrawablePainter
import me.weishu.kernelsu.BuildConfig
import me.weishu.kernelsu.R

@Preview
@Composable
fun AboutCard() {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth(),
        shape = RoundedCornerShape(8.dp),
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp)
        ) {
            AboutCardContent()
        }
    }
}

@Composable
fun AboutDialog(showAboutDialog: MutableState<Boolean>) {
    if (showAboutDialog.value) {
        Dialog(onDismissRequest = { showAboutDialog.value = false }) {
            AboutCard()
        }
    }
}

@Composable
private fun AboutCardContent() {
    Column(
        modifier = Modifier
            .fillMaxWidth()
    ) {
        val drawable = ResourcesCompat.getDrawable(
            LocalContext.current.resources,
            R.mipmap.ic_launcher,
            LocalContext.current.theme
        )

        Row {
            Image(
                painter = rememberDrawablePainter(drawable),
                contentDescription = "icon",
                modifier = Modifier.size(40.dp)
            )

            Spacer(modifier = Modifier.width(12.dp))

            Column {

                Text(
                    stringResource(id = R.string.app_name),
                    style = MaterialTheme.typography.titleSmall,
                    fontSize = 18.sp
                )
                Text(
                    BuildConfig.VERSION_NAME,
                    style = MaterialTheme.typography.bodySmall,
                    fontSize = 14.sp
                )

                Spacer(modifier = Modifier.height(8.dp))

                HtmlText(
                    html = stringResource(
                        id = R.string.about_source_code,
                        "<b><a href=\"https://github.com/tiann/KernelSU\">GitHub</a></b>",
                        "<b><a href=\"https://t.me/KernelSU\">Telegram</a></b>"
                    )
                )
            }
        }
    }
}

@Composable
fun HtmlText(html: String, modifier: Modifier = Modifier) {
    val contentColor = LocalContentColor.current
    AndroidView(
        modifier = modifier,
        factory = { context ->
            TextView(context).also {
                it.movementMethod = LinkMovementMethod.getInstance()
            }
        },
        update = {
            it.text = HtmlCompat.fromHtml(html, HtmlCompat.FROM_HTML_MODE_COMPACT)
            it.setTextColor(contentColor.toArgb())
        }
    )
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/Dialog.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import me.weishu.kernelsu.ui.util.LocalDialogHost
import kotlin.coroutines.resume

interface DialogVisuals

interface LoadingDialogVisuals : DialogVisuals

interface PromptDialogVisuals : DialogVisuals {
    val title: String
    val content: String
}

interface ConfirmDialogVisuals : PromptDialogVisuals {
    val confirm: String?
    val dismiss: String?
}


sealed interface DialogData {
    val visuals: DialogVisuals
}

interface LoadingDialogData : DialogData {
    override val visuals: LoadingDialogVisuals
    fun dismiss()
}

interface PromptDialogData : DialogData {
    override val visuals: PromptDialogVisuals
    fun dismiss()
}

interface ConfirmDialogData : PromptDialogData {
    override val visuals: ConfirmDialogVisuals
    fun confirm()
}

sealed interface ConfirmResult {
    object Confirmed : ConfirmResult
    object Canceled : ConfirmResult
}

class DialogHostState {

    private object LoadingDialogVisualsImpl : LoadingDialogVisuals

    private data class PromptDialogVisualsImpl(
        override val title: String,
        override val content: String
    ) : PromptDialogVisuals

    private data class ConfirmDialogVisualsImpl(
        override val title: String,
        override val content: String,
        override val confirm: String?,
        override val dismiss: String?
    ) : ConfirmDialogVisuals

    private data class LoadingDialogDataImpl(
        override val visuals: LoadingDialogVisuals,
        private val continuation: CancellableContinuation<Unit>,
    ) : LoadingDialogData {
        override fun dismiss() {
            if (continuation.isActive) continuation.resume(Unit)
        }
    }

    private data class PromptDialogDataImpl(
        override val visuals: PromptDialogVisuals,
        private val continuation: CancellableContinuation<Unit>,
    ) : PromptDialogData {
        override fun dismiss() {
            if (continuation.isActive) continuation.resume(Unit)
        }
    }

    private data class ConfirmDialogDataImpl(
        override val visuals: ConfirmDialogVisuals,
        private val continuation: CancellableContinuation<ConfirmResult>
    ) : ConfirmDialogData {

        override fun confirm() {
            if (continuation.isActive) continuation.resume(ConfirmResult.Confirmed)
        }

        override fun dismiss() {
            if (continuation.isActive) continuation.resume(ConfirmResult.Canceled)
        }
    }

    private val mutex = Mutex()

    var currentDialogData by mutableStateOf<DialogData?>(null)
        private set

    suspend fun showLoading() {
        try {
            mutex.withLock {
                suspendCancellableCoroutine { continuation ->
                    currentDialogData = LoadingDialogDataImpl(
                        visuals = LoadingDialogVisualsImpl,
                        continuation = continuation
                    )
                }
            }
        } finally {
            currentDialogData = null
        }
    }

    suspend fun <R> withLoading(block: suspend () -> R) = coroutineScope {
        val showLoading = launch {
            showLoading()
        }

        val result = block()

        showLoading.cancel()

        result
    }

    suspend fun showPrompt(title: String, content: String) {
        try {
            mutex.withLock {
                suspendCancellableCoroutine { continuation ->
                    currentDialogData = PromptDialogDataImpl(
                        visuals = PromptDialogVisualsImpl(title, content),
                        continuation = continuation
                    )
                }
            }
        } finally {
            currentDialogData = null
        }
    }

    suspend fun showConfirm(
        title: String,
        content: String,
        confirm: String? = null,
        dismiss: String? = null
    ): ConfirmResult = mutex.withLock {
        try {
            return@withLock suspendCancellableCoroutine { continuation ->
                currentDialogData = ConfirmDialogDataImpl(
                    visuals = ConfirmDialogVisualsImpl(title, content, confirm, dismiss),
                    continuation = continuation
                )
            }
        } finally {
            currentDialogData = null
        }
    }
}

@Composable
fun rememberDialogHostState(): DialogHostState {
    return remember {
        DialogHostState()
    }
}

private inline fun <reified T : DialogData> DialogData?.tryInto(): T? {
    return when (this) {
        is T -> this
        else -> null
    }
}

@Composable
fun LoadingDialog(
    state: DialogHostState = LocalDialogHost.current,
) {
    state.currentDialogData.tryInto<LoadingDialogData>() ?: return
    val dialogProperties = remember {
        DialogProperties(dismissOnClickOutside = false, dismissOnBackPress = false)
    }
    Dialog(onDismissRequest = {}, properties = dialogProperties) {
        Surface(
            modifier = Modifier
                .size(100.dp),
            shape = RoundedCornerShape(8.dp)
        ) {
            Box(
                contentAlignment = Alignment.Center,
            ) {
                CircularProgressIndicator()
            }
        }
    }
}

@Composable
fun PromptDialog(
    state: DialogHostState = LocalDialogHost.current,
) {
    val promptDialogData = state.currentDialogData.tryInto<PromptDialogData>() ?: return

    val visuals = promptDialogData.visuals
    AlertDialog(
        onDismissRequest = {
            promptDialogData.dismiss()
        },
        title = {
            Text(text = visuals.title)
        },
        text = {
            Text(text = visuals.content)
        },
        confirmButton = {
            TextButton(onClick = { promptDialogData.dismiss() }) {
                Text(text = stringResource(id = android.R.string.ok))
            }
        },
        dismissButton = null,
    )
}

@Composable
fun ConfirmDialog(state: DialogHostState = LocalDialogHost.current) {
    val confirmDialogData = state.currentDialogData.tryInto<ConfirmDialogData>() ?: return

    val visuals = confirmDialogData.visuals
    AlertDialog(
        onDismissRequest = {
            confirmDialogData.dismiss()
        },
        title = {
            Text(text = visuals.title)
        },
        text = {
            Text(text = visuals.content)
        },
        confirmButton = {
            TextButton(onClick = { confirmDialogData.confirm() }) {
                Text(text = visuals.confirm ?: stringResource(id = android.R.string.ok))
            }
        },
        dismissButton = {
            TextButton(onClick = { confirmDialogData.dismiss() }) {
                Text(text = visuals.dismiss ?: stringResource(id = android.R.string.cancel))
            }
        },
    )
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/KeyEventBlocker.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.focusable
import androidx.compose.foundation.layout.Box
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.input.key.KeyEvent
import androidx.compose.ui.input.key.onKeyEvent

@Composable
fun KeyEventBlocker(predicate: (KeyEvent) -> Boolean) {
    val requester = remember { FocusRequester() }
    Box(
        Modifier
            .onKeyEvent {
                predicate(it)
            }
            .focusRequester(requester)
            .focusable()
    )
    LaunchedEffect(Unit) {
        requester.requestFocus()
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/SearchBar.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.outlined.ArrowBack
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.focus.onFocusChanged
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp

private const val TAG = "SearchBar"

@OptIn(ExperimentalComposeUiApi::class, ExperimentalMaterial3Api::class)
@Composable
fun SearchAppBar(
    title: @Composable () -> Unit,
    searchText: String,
    onSearchTextChange: (String) -> Unit,
    onClearClick: () -> Unit,
    onBackClick: (() -> Unit)? = null,
    onConfirm: (() -> Unit)? = null,
    dropdownContent: @Composable (() -> Unit)? = null,
) {
    val keyboardController = LocalSoftwareKeyboardController.current
    val focusRequester = remember { FocusRequester() }
    var onSearch by remember { mutableStateOf(false) }

    if (onSearch) {
        LaunchedEffect(Unit) { focusRequester.requestFocus() }
    }
    DisposableEffect(Unit) {
        onDispose {
            keyboardController?.hide()
        }
    }

    TopAppBar(
        title = {
            Box {
                AnimatedVisibility(
                    modifier = Modifier.align(Alignment.CenterStart),
                    visible = !onSearch,
                    enter = fadeIn(),
                    exit = fadeOut(),
                    content = { title() }
                )

                AnimatedVisibility(
                    visible = onSearch,
                    enter = fadeIn(),
                    exit = fadeOut()
                ) {
                    OutlinedTextField(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(top = 2.dp, bottom = 2.dp, end = if (onBackClick != null) 0.dp else 14.dp)
                            .focusRequester(focusRequester)
                            .onFocusChanged { focusState ->
                                if (focusState.isFocused) onSearch = true
                                Log.d(TAG, "onFocusChanged: $focusState")
                            },
                        value = searchText,
                        onValueChange = onSearchTextChange,
                        trailingIcon = {
                            IconButton(
                                onClick = {
                                    onSearch = false
                                    keyboardController?.hide()
                                    onClearClick()
                                },
                                content = { Icon(Icons.Filled.Close, null) }
                            )
                        },
                        maxLines = 1,
                        singleLine = true,
                        keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Done),
                        keyboardActions = KeyboardActions(onDone = {
                            keyboardController?.hide()
                            onConfirm?.invoke()
                        })
                    )
                }
            }
        },
        navigationIcon = {
            if (onBackClick != null) {
                IconButton(
                    onClick = onBackClick,
                    content = { Icon(Icons.Outlined.ArrowBack, null) }
                )
            }
        },
        actions = {
            AnimatedVisibility(
                visible = !onSearch
            ) {
                IconButton(
                    onClick = { onSearch = true },
                    content = { Icon(Icons.Filled.Search, null) }
                )
            }

            if (dropdownContent != null) {
                dropdownContent()
            }

        }
    )
}

@Preview
@Composable
private fun SearchAppBarPreview() {
    var searchText by remember { mutableStateOf("") }
    SearchAppBar(
        title = { Text("Search text") },
        searchText = searchText,
        onSearchTextChange = { searchText = it },
        onClearClick = { searchText = "" }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/SettingsItem.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.material3.Icon
import androidx.compose.material3.ListItem
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.vector.ImageVector

@Composable
fun SwitchItem(
    icon: ImageVector? = null,
    title: String,
    summary: String? = null,
    checked: Boolean,
    enabled: Boolean = true,
    onCheckedChange: (Boolean) -> Unit
) {
    ListItem(
        headlineContent = {
            Text(title)
        },
        leadingContent = icon?.let {
            { Icon(icon, title) }
        },
        trailingContent = {
            Switch(checked = checked, enabled = enabled, onCheckedChange = onCheckedChange)
        },
        supportingContent = {
            if (summary != null) {
                Text(summary)
            }
        }
    )
}

@Composable
fun RadioItem(
    title: String,
    selected: Boolean,
    onClick: () -> Unit,
) {
    ListItem(
        headlineContent = {
            Text(title)
        },
        leadingContent = {
            RadioButton(selected = selected, onClick = onClick)
        },
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/profile/AppProfileConfig.kt`:

```kt
package me.weishu.kernelsu.ui.component.profile

import androidx.compose.foundation.layout.Column
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.SwitchItem

@Composable
fun AppProfileConfig(
    modifier: Modifier = Modifier,
    fixedName: Boolean,
    enabled: Boolean,
    profile: Natives.Profile,
    onProfileChange: (Natives.Profile) -> Unit,
) {
    Column(modifier = modifier) {
        if (!fixedName) {
            OutlinedTextField(
                label = { Text(stringResource(R.string.profile_name)) },
                value = profile.name,
                onValueChange = { onProfileChange(profile.copy(name = it)) }
            )
        }

        SwitchItem(
            title = stringResource(R.string.profile_umount_modules),
            summary = stringResource(R.string.profile_umount_modules_summary),
            checked = if (enabled) {
                profile.umountModules
            } else {
                Natives.isDefaultUmountModules()
            },
            enabled = enabled,
            onCheckedChange = {
                onProfileChange(
                    profile.copy(
                        umountModules = it,
                        nonRootUseDefault = false
                    )
                )
            }
        )
    }
}

@Preview
@Composable
private fun AppProfileConfigPreview() {
    var profile by remember { mutableStateOf(Natives.Profile("")) }
    AppProfileConfig(fixedName = true, enabled = false, profile = profile) {
        profile = it
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/profile/RootProfileConfig.kt`:

```kt
@file:OptIn(ExperimentalMaterial3Api::class)

package me.weishu.kernelsu.ui.component.profile

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.ArrowDropUp
import androidx.compose.material3.AssistChip
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.Icon
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedCard
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.core.text.isDigitsOnly
import com.maxkeppeker.sheets.core.models.base.Header
import com.maxkeppeker.sheets.core.models.base.rememberUseCaseState
import com.maxkeppeler.sheets.input.InputDialog
import com.maxkeppeler.sheets.input.models.InputHeader
import com.maxkeppeler.sheets.input.models.InputSelection
import com.maxkeppeler.sheets.input.models.InputTextField
import com.maxkeppeler.sheets.input.models.InputTextFieldType
import com.maxkeppeler.sheets.input.models.ValidationResult
import com.maxkeppeler.sheets.list.ListDialog
import com.maxkeppeler.sheets.list.models.ListOption
import com.maxkeppeler.sheets.list.models.ListSelection
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.profile.Capabilities
import me.weishu.kernelsu.profile.Groups
import me.weishu.kernelsu.ui.util.isSepolicyValid

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RootProfileConfig(
    modifier: Modifier = Modifier,
    fixedName: Boolean,
    profile: Natives.Profile,
    onProfileChange: (Natives.Profile) -> Unit,
) {
    Column(modifier = modifier) {
        if (!fixedName) {
            OutlinedTextField(
                label = { Text(stringResource(R.string.profile_name)) },
                value = profile.name,
                onValueChange = { onProfileChange(profile.copy(name = it)) }
            )
        }

        var expanded by remember { mutableStateOf(false) }
        val currentNamespace = when (profile.namespace) {
            Natives.Profile.Namespace.Inherited.ordinal -> stringResource(R.string.profile_namespace_inherited)
            Natives.Profile.Namespace.Global.ordinal -> stringResource(R.string.profile_namespace_global)
            Natives.Profile.Namespace.Individual.ordinal -> stringResource(R.string.profile_namespace_individual)
            else -> stringResource(R.string.profile_namespace_inherited)
        }
        ListItem(headlineContent = {
            ExposedDropdownMenuBox(
                expanded = expanded,
                onExpandedChange = { expanded = !expanded }
            ) {
                OutlinedTextField(
                    modifier = Modifier
                        .menuAnchor()
                        .fillMaxWidth(),
                    readOnly = true,
                    label = { Text(stringResource(R.string.profile_namespace)) },
                    value = currentNamespace,
                    onValueChange = {},
                    trailingIcon = {
                        if (expanded) Icon(Icons.Filled.ArrowDropUp, null)
                        else Icon(Icons.Filled.ArrowDropDown, null)
                    },
                )
                ExposedDropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }
                ) {
                    DropdownMenuItem(
                        text = { Text(stringResource(R.string.profile_namespace_inherited)) },
                        onClick = {
                            onProfileChange(profile.copy(namespace = Natives.Profile.Namespace.Inherited.ordinal))
                            expanded = false
                        },
                    )
                    DropdownMenuItem(
                        text = { Text(stringResource(R.string.profile_namespace_global)) },
                        onClick = {
                            onProfileChange(profile.copy(namespace = Natives.Profile.Namespace.Global.ordinal))
                            expanded = false
                        },
                    )
                    DropdownMenuItem(
                        text = { Text(stringResource(R.string.profile_namespace_individual)) },
                        onClick = {
                            onProfileChange(profile.copy(namespace = Natives.Profile.Namespace.Individual.ordinal))
                            expanded = false
                        },
                    )
                }
            }
        })

        UidPanel(uid = profile.uid, label = "uid", onUidChange = {
            onProfileChange(
                profile.copy(
                    uid = it,
                    rootUseDefault = false
                )
            )
        })

        UidPanel(uid = profile.gid, label = "gid", onUidChange = {
            onProfileChange(
                profile.copy(
                    gid = it,
                    rootUseDefault = false
                )
            )
        })

        val selectedGroups = profile.groups.ifEmpty { listOf(0) }.let { e ->
            e.mapNotNull { g ->
                Groups.values().find { it.gid == g }
            }
        }
        GroupsPanel(selectedGroups) {
            onProfileChange(
                profile.copy(
                    groups = it.map { group -> group.gid }.ifEmpty { listOf(0) },
                    rootUseDefault = false
                )
            )
        }

        val selectedCaps = profile.capabilities.mapNotNull { e ->
            Capabilities.values().find { it.cap == e }
        }

        CapsPanel(selectedCaps) {
            onProfileChange(
                profile.copy(
                    capabilities = it.map { cap -> cap.cap },
                    rootUseDefault = false
                )
            )
        }

        SELinuxPanel(profile = profile, onSELinuxChange = { domain, rules ->
            onProfileChange(
                profile.copy(
                    context = domain,
                    rules = rules,
                    rootUseDefault = false
                )
            )
        })

    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun GroupsPanel(selected: List<Groups>, closeSelection: (selection: Set<Groups>) -> Unit) {

    var showDialog by remember { mutableStateOf(false) }

    if (showDialog) {
        val groups = Groups.values()
        val options = groups.map { value ->
            ListOption(
                titleText = value.display,
                subtitleText = value.desc,
                selected = selected.contains(value),
            )
        }

        val selection = HashSet(selected)
        ListDialog(
            state = rememberUseCaseState(visible = true, onFinishedRequest = {
                closeSelection(selection)
            }, onCloseRequest = {
                showDialog = false
            }),
            header = Header.Default(
                title = stringResource(R.string.profile_groups),
            ),
            selection = ListSelection.Multiple(
                showCheckBoxes = true,
                options = options,
                maxChoices = 32, // Kernel only supports 32 groups at most
            ) { indecies, _ ->
                // Handle selection
                selection.clear()
                indecies.forEach { index ->
                    val group = groups[index]
                    selection.add(group)
                }
            }
        )
    }

    OutlinedCard(modifier = Modifier
        .fillMaxWidth()
        .padding(16.dp)
        .clickable {
            showDialog = true
        }) {

        Column(modifier = Modifier.padding(16.dp)) {
            Text(stringResource(R.string.profile_groups))
            FlowRow {
                selected.forEach { group ->
                    AssistChip(
                        modifier = Modifier.padding(3.dp),
                        onClick = { /*TODO*/ },
                        label = { Text(group.display) })
                }
            }
        }

    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun CapsPanel(
    selected: Collection<Capabilities>,
    closeSelection: (selection: Set<Capabilities>) -> Unit
) {

    var showDialog by remember { mutableStateOf(false) }

    if (showDialog) {
        val caps = Capabilities.values()
        val options = caps.map { value ->
            ListOption(
                titleText = value.display,
                subtitleText = value.desc,
                selected = selected.contains(value),
            )
        }

        val selection = HashSet(selected)
        ListDialog(
            state = rememberUseCaseState(visible = true, onFinishedRequest = {
                closeSelection(selection)
            }, onCloseRequest = {
                showDialog = false
            }),
            header = Header.Default(
                title = stringResource(R.string.profile_capabilities),
            ),
            selection = ListSelection.Multiple(
                showCheckBoxes = true,
                options = options
            ) { indecies, _ ->
                // Handle selection
                selection.clear()
                indecies.forEach { index ->
                    val group = caps[index]
                    selection.add(group)
                }
            }
        )
    }

    OutlinedCard(modifier = Modifier
        .fillMaxWidth()
        .padding(16.dp)
        .clickable {
            showDialog = true
        }) {

        Column(modifier = Modifier.padding(16.dp)) {
            Text(stringResource(R.string.profile_capabilities))
            FlowRow {
                selected.forEach { group ->
                    AssistChip(
                        modifier = Modifier.padding(3.dp),
                        onClick = { /*TODO*/ },
                        label = { Text(group.display) })
                }
            }
        }

    }
}

@OptIn(ExperimentalComposeUiApi::class)
@Composable
private fun UidPanel(uid: Int, label: String, onUidChange: (Int) -> Unit) {

    ListItem(headlineContent = {
        var isError by remember {
            mutableStateOf(false)
        }
        var lastValidUid by remember {
            mutableStateOf(uid)
        }

        val keyboardController = LocalSoftwareKeyboardController.current
        OutlinedTextField(
            modifier = Modifier.fillMaxWidth(),
            label = { Text(label) },
            value = uid.toString(),
            isError = isError,
            keyboardOptions = KeyboardOptions(
                keyboardType = KeyboardType.Number,
                imeAction = ImeAction.Done
            ),
            keyboardActions = KeyboardActions(onDone = {
                keyboardController?.hide()
            }),
            onValueChange = {
                if (it.isEmpty()) {
                    onUidChange(0)
                    return@OutlinedTextField
                }
                val valid = isTextValidUid(it)

                val targetUid = if (valid) it.toInt() else lastValidUid
                if (valid) {
                    lastValidUid = it.toInt()
                }

                onUidChange(targetUid)

                isError = !valid
            }
        )
    })
}

@Composable
private fun SELinuxPanel(
    profile: Natives.Profile,
    onSELinuxChange: (domain: String, rules: String) -> Unit
) {
    var showDialog by remember { mutableStateOf(false) }
    if (showDialog) {
        var domain by remember { mutableStateOf(profile.context) }
        var rules by remember { mutableStateOf(profile.rules) }

        val inputOptions = listOf(
            InputTextField(
                text = domain,
                header = InputHeader(
                    title = stringResource(id = R.string.profile_selinux_domain),
                ),
                type = InputTextFieldType.OUTLINED,
                required = true,
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Ascii,
                    imeAction = ImeAction.Next
                ),
                resultListener = {
                    domain = it ?: ""
                },
                validationListener = { value ->
                    // value can be a-zA-Z0-9_
                    val regex = Regex("^[a-z_]+:[a-z0-9_]+:[a-z0-9_]+(:[a-z0-9_]+)?$")
                    if (value?.matches(regex) == true) ValidationResult.Valid
                    else ValidationResult.Invalid("Domain must be in the format of \"user:role:type:level\"")
                }
            ),
            InputTextField(
                text = rules,
                header = InputHeader(
                    title = stringResource(id = R.string.profile_selinux_rules),
                ),
                type = InputTextFieldType.OUTLINED,
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Ascii,
                ),
                singleLine = false,
                resultListener = {
                    rules = it ?: ""
                },
                validationListener = { value ->
                    if (isSepolicyValid(value)) ValidationResult.Valid
                    else ValidationResult.Invalid("SELinux rules is invalid!")
                }
            )
        )

        InputDialog(
            state = rememberUseCaseState(visible = true,
                onFinishedRequest = {
                    onSELinuxChange(domain, rules)
                },
                onCloseRequest = {
                    showDialog = false
                }),
            header = Header.Default(
                title = stringResource(R.string.profile_selinux_context),
            ),
            selection = InputSelection(
                input = inputOptions,
                onPositiveClick = { result ->
                    // Handle selection
                },
            )
        )
    }

    ListItem(headlineContent = {
        OutlinedTextField(
            modifier = Modifier
                .fillMaxWidth()
                .clickable {
                    showDialog = true
                },
            enabled = false,
            colors = TextFieldDefaults.outlinedTextFieldColors(
                disabledTextColor = MaterialTheme.colorScheme.onSurface,
                disabledBorderColor = MaterialTheme.colorScheme.outline,
                disabledPlaceholderColor = MaterialTheme.colorScheme.onSurfaceVariant,
                disabledLabelColor = MaterialTheme.colorScheme.onSurfaceVariant
            ),
            label = { Text(text = stringResource(R.string.profile_selinux_context)) },
            value = profile.context,
            onValueChange = { },
        )
    })
}

@Preview
@Composable
private fun RootProfileConfigPreview() {
    var profile by remember { mutableStateOf(Natives.Profile("")) }
    RootProfileConfig(fixedName = true, profile = profile) {
        profile = it
    }
}

private fun isTextValidUid(text: String): Boolean {
    return text.isNotEmpty() && text.isDigitsOnly() && text.toInt() >= 0 && text.toInt() <= Int.MAX_VALUE
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/AppProfile.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import androidx.annotation.StringRes
import androidx.compose.animation.Crossfade
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AccountCircle
import androidx.compose.material.icons.filled.Android
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.ArrowDropUp
import androidx.compose.material.icons.filled.Security
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.FilterChip
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.DpOffset
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.ramcosta.composedestinations.annotation.Destination
import com.ramcosta.composedestinations.navigation.DestinationsNavigator
import kotlinx.coroutines.launch
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.SwitchItem
import me.weishu.kernelsu.ui.component.profile.AppProfileConfig
import me.weishu.kernelsu.ui.component.profile.RootProfileConfig
import me.weishu.kernelsu.ui.util.LocalSnackbarHost
import me.weishu.kernelsu.ui.util.forceStopApp
import me.weishu.kernelsu.ui.util.getSepolicy
import me.weishu.kernelsu.ui.util.launchApp
import me.weishu.kernelsu.ui.util.restartApp
import me.weishu.kernelsu.ui.util.setSepolicy
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel

/**
 * @author weishu
 * @date 2023/5/16.
 */
@Destination
@Composable
fun AppProfileScreen(
    navigator: DestinationsNavigator,
    appInfo: SuperUserViewModel.AppInfo,
) {
    val context = LocalContext.current
    val snackbarHost = LocalSnackbarHost.current
    val scope = rememberCoroutineScope()
    val failToUpdateAppProfile =
        stringResource(R.string.failed_to_update_app_profile).format(appInfo.label)
    val failToUpdateSepolicy =
        stringResource(R.string.failed_to_update_sepolicy).format(appInfo.label)

    val packageName = appInfo.packageName
    val initialProfile = Natives.getAppProfile(packageName, appInfo.uid)
    if (initialProfile.allowSu) {
        initialProfile.rules = getSepolicy(packageName)
    }
    var profile by rememberSaveable {
        mutableStateOf(initialProfile)
    }

    Scaffold(
        topBar = { TopBar { navigator.popBackStack() } },
    ) { paddingValues ->
        AppProfileInner(
            modifier = Modifier
                .padding(paddingValues)
                .verticalScroll(rememberScrollState()),
            packageName = appInfo.packageName,
            appLabel = appInfo.label,
            appIcon = {
                AsyncImage(
                    model = ImageRequest.Builder(context)
                        .data(appInfo.packageInfo)
                        .crossfade(true)
                        .build(),
                    contentDescription = appInfo.label,
                    modifier = Modifier
                        .padding(4.dp)
                        .width(48.dp)
                        .height(48.dp)
                )
            },
            profile = profile,
            onProfileChange = {
                scope.launch {
                    if (it.allowSu && !it.rootUseDefault && it.rules.isNotEmpty()) {
                        if (!setSepolicy(profile.name, it.rules)) {
                            snackbarHost.showSnackbar(failToUpdateSepolicy)
                            return@launch
                        }
                    }
                    if (!Natives.setAppProfile(it)) {
                        snackbarHost.showSnackbar(failToUpdateAppProfile.format(appInfo.uid))
                    } else {
                        profile = it
                    }
                }
            },
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun AppProfileInner(
    modifier: Modifier = Modifier,
    packageName: String,
    appLabel: String,
    appIcon: @Composable () -> Unit,
    profile: Natives.Profile,
    onProfileChange: (Natives.Profile) -> Unit,
) {
    val isRootGranted = profile.allowSu

    Column(modifier = modifier) {
        AppMenuBox(packageName) {
            ListItem(
                headlineContent = { Text(appLabel) },
                supportingContent = { Text(packageName) },
                leadingContent = appIcon,
            )
        }

        SwitchItem(
            icon = Icons.Filled.Security,
            title = stringResource(id = R.string.superuser),
            checked = isRootGranted,
            onCheckedChange = { onProfileChange(profile.copy(allowSu = it)) },
        )

        Crossfade(targetState = isRootGranted, label = "") { current ->
            Column {
                if (current) {
                    val initialMode = if (profile.rootUseDefault) {
                        Mode.Default
                    } else if (profile.rootTemplate != null) {
                        Mode.Template
                    } else {
                        Mode.Custom
                    }
                    var mode by remember {
                        mutableStateOf(initialMode)
                    }
                    ProfileBox(mode, false) {
                        // template mode shouldn't change profile here!
                        if (it == Mode.Default || it == Mode.Custom) {
                            onProfileChange(profile.copy(rootUseDefault = it == Mode.Default))
                        }
                        mode = it
                    }
                    Crossfade(targetState = mode, label = "") { currentMode ->
                        if (currentMode == Mode.Template) {
                            var expanded by remember { mutableStateOf(false) }
                            val templateNone = "None"
                            var template by rememberSaveable {
                                mutableStateOf(
                                    profile.rootTemplate
                                        ?: templateNone
                                )
                            }
                            ListItem(headlineContent = {
                                ExposedDropdownMenuBox(
                                    expanded = expanded,
                                    onExpandedChange = { expanded = it },
                                ) {
                                    OutlinedTextField(
                                        modifier = Modifier.menuAnchor(),
                                        readOnly = true,
                                        label = { Text(stringResource(R.string.profile_template)) },
                                        value = template,
                                        onValueChange = {
                                            if (template != templateNone) {
                                                onProfileChange(
                                                    profile.copy(
                                                        rootTemplate = it,
                                                        rootUseDefault = false
                                                    )
                                                )
                                                template = it
                                            }
                                        },
                                        trailingIcon = {
                                            if (expanded) Icon(Icons.Filled.ArrowDropUp, null)
                                            else Icon(Icons.Filled.ArrowDropDown, null)
                                        },
                                    )
                                    // TODO: Template
                                }
                            })
                        } else if (mode == Mode.Custom) {
                            RootProfileConfig(
                                fixedName = true,
                                profile = profile,
                                onProfileChange = onProfileChange
                            )
                        }
                    }
                } else {
                    val mode = if (profile.nonRootUseDefault) Mode.Default else Mode.Custom
                    ProfileBox(mode, false) {
                        onProfileChange(profile.copy(nonRootUseDefault = (it == Mode.Default)))
                    }
                    Crossfade(targetState = mode, label = "") { currentMode ->
                        val modifyEnabled = currentMode == Mode.Custom
                        AppProfileConfig(
                            fixedName = true,
                            profile = profile,
                            enabled = modifyEnabled,
                            onProfileChange = onProfileChange
                        )
                    }
                }
            }
        }
    }
}

private enum class Mode(@StringRes private val res: Int) {
    Default(R.string.profile_default),
    Template(R.string.profile_template),
    Custom(R.string.profile_custom);

    val text: String
        @Composable get() = stringResource(res)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TopBar(onBack: () -> Unit) {
    TopAppBar(
        title = {
            Text(stringResource(R.string.profile))
        },
        navigationIcon = {
            IconButton(
                onClick = onBack
            ) { Icon(Icons.Filled.ArrowBack, contentDescription = null) }
        },
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun ProfileBox(
    mode: Mode,
    hasTemplate: Boolean,
    onModeChange: (Mode) -> Unit,
) {
    ListItem(
        headlineContent = { Text(stringResource(R.string.profile)) },
        supportingContent = { Text(mode.text) },
        leadingContent = { Icon(Icons.Filled.AccountCircle, null) },
    )
    Divider(thickness = Dp.Hairline)
    ListItem(headlineContent = {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            FilterChip(
                selected = mode == Mode.Default,
                label = { Text(stringResource(R.string.profile_default)) },
                onClick = { onModeChange(Mode.Default) },
            )
            if (hasTemplate) {
                FilterChip(
                    selected = mode == Mode.Template,
                    label = { Text(stringResource(R.string.profile_template)) },
                    onClick = { onModeChange(Mode.Template) },
                )
            }
            FilterChip(
                selected = mode == Mode.Custom,
                label = { Text(stringResource(R.string.profile_custom)) },
                onClick = { onModeChange(Mode.Custom) },
            )
        }
    })
}

@Composable
private fun AppMenuBox(packageName: String, content: @Composable () -> Unit) {

    var expanded by remember { mutableStateOf(false) }
    var touchPoint: Offset by remember { mutableStateOf(Offset.Zero) }
    val density = LocalDensity.current

    BoxWithConstraints(
        Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                detectTapGestures {
                    touchPoint = it
                    expanded = true
                }
            }
    ) {

        content()

        val (offsetX, offsetY) = with(density) {
            (touchPoint.x.toDp()) to (touchPoint.y.toDp())
        }

        DropdownMenu(
            expanded = expanded,
            offset = DpOffset(offsetX, -offsetY),
            onDismissRequest = {
                expanded = false
            },
        ) {
            DropdownMenuItem(
                text = { Text(stringResource(id = R.string.launch_app)) },
                onClick = {
                    expanded = false
                    launchApp(packageName)
                },
            )
            DropdownMenuItem(
                text = { Text(stringResource(id = R.string.force_stop_app)) },
                onClick = {
                    expanded = false
                    forceStopApp(packageName)
                },
            )
            DropdownMenuItem(
                text = { Text(stringResource(id = R.string.restart_app)) },
                onClick = {
                    expanded = false
                    restartApp(packageName)
                },
            )
        }
    }


}

@Preview
@Composable
private fun AppProfilePreview() {
    var profile by remember { mutableStateOf(Natives.Profile("")) }
    AppProfileInner(
        packageName = "icu.nullptr.test",
        appLabel = "Test",
        appIcon = { Icon(Icons.Filled.Android, null) },
        profile = profile,
        onProfileChange = {
            profile = it
        },
    )
}


```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/BottomBarDestination.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import androidx.annotation.StringRes
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.*
import androidx.compose.ui.graphics.vector.ImageVector
import com.ramcosta.composedestinations.spec.DirectionDestinationSpec
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.screen.destinations.HomeScreenDestination
import me.weishu.kernelsu.ui.screen.destinations.SuperUserScreenDestination
import me.weishu.kernelsu.ui.screen.destinations.ModuleScreenDestination

enum class BottomBarDestination(
    val direction: DirectionDestinationSpec,
    @StringRes val label: Int,
    val iconSelected: ImageVector,
    val iconNotSelected: ImageVector,
    val rootRequired: Boolean,
) {
    Home(HomeScreenDestination, R.string.home, Icons.Filled.Home, Icons.Outlined.Home, false),
    SuperUser(SuperUserScreenDestination, R.string.superuser, Icons.Filled.Security, Icons.Outlined.Security, true),
    Module(ModuleScreenDestination, R.string.module, Icons.Filled.Apps, Icons.Outlined.Apps, true)
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Home.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.content.Context
import android.os.Build
import android.os.PowerManager
import android.system.Os
import androidx.annotation.StringRes
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.outlined.Block
import androidx.compose.material.icons.outlined.CheckCircle
import androidx.compose.material.icons.outlined.Warning
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.ramcosta.composedestinations.annotation.Destination
import com.ramcosta.composedestinations.annotation.RootNavGraph
import com.ramcosta.composedestinations.navigation.DestinationsNavigator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.*
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.screen.destinations.SettingScreenDestination
import me.weishu.kernelsu.ui.util.*

@RootNavGraph(start = true)
@Destination
@Composable
fun HomeScreen(navigator: DestinationsNavigator) {
    Scaffold(topBar = {
        TopBar(onSettingsClick = {
            navigator.navigate(SettingScreenDestination)
        })
    }) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .padding(horizontal = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            val kernelVersion = getKernelVersion()
            val isManager = Natives.becomeManager(ksuApp.packageName)
            SideEffect {
                if (isManager) install()
            }
            val ksuVersion = if (isManager) Natives.version else null

            StatusCard(kernelVersion, ksuVersion)
            if (isManager && Natives.requireNewKernel()) {
                WarningCard(
                    stringResource(id = R.string.require_kernel_version).format(
                        ksuVersion, Natives.MINIMAL_SUPPORTED_KERNEL
                    )
                )
            }
            UpdateCard()
            InfoCard()
            DonateCard()
            LearnMoreCard()
            Spacer(Modifier)
        }
    }
}

@Composable
fun UpdateCard() {
    val context = LocalContext.current
    val newVersion by produceState(initialValue = 0 to "") {
        value = withContext(Dispatchers.IO) { checkNewVersion() }
    }
    val currentVersionCode = getManagerVersion(context).second
    val newVersionCode = newVersion.first
    val newVersionUrl = newVersion.second
    if (newVersionCode <= currentVersionCode) {
        return
    }

    val uriHandler = LocalUriHandler.current
    WarningCard(
        message = stringResource(id = R.string.new_version_available).format(newVersionCode),
        MaterialTheme.colorScheme.outlineVariant
    ) {
        uriHandler.openUri(newVersionUrl)
    }
}

@Composable
fun RebootDropdownItem(@StringRes id: Int, reason: String = "") {
    DropdownMenuItem(text = {
        Text(stringResource(id))
    }, onClick = {
        reboot(reason)
    })
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TopBar(onSettingsClick: () -> Unit) {
    TopAppBar(title = { Text(stringResource(R.string.app_name)) }, actions = {
        var showDropdown by remember { mutableStateOf(false) }
        IconButton(onClick = {
            showDropdown = true
        }) {
            Icon(
                imageVector = Icons.Filled.Refresh,
                contentDescription = stringResource(id = R.string.reboot)
            )

            DropdownMenu(expanded = showDropdown, onDismissRequest = {
                showDropdown = false
            }) {

                RebootDropdownItem(id = R.string.reboot)

                val pm =
                    LocalContext.current.getSystemService(Context.POWER_SERVICE) as PowerManager?
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R && pm?.isRebootingUserspaceSupported == true) {
                    RebootDropdownItem(id = R.string.reboot_userspace, reason = "userspace")
                }
                RebootDropdownItem(id = R.string.reboot_recovery, reason = "recovery")
                RebootDropdownItem(id = R.string.reboot_bootloader, reason = "bootloader")
                RebootDropdownItem(id = R.string.reboot_download, reason = "download")
                RebootDropdownItem(id = R.string.reboot_edl, reason = "edl")
            }
        }

        IconButton(onClick = onSettingsClick) {
            Icon(
                imageVector = Icons.Filled.Settings,
                contentDescription = stringResource(id = R.string.settings)
            )
        }
    })
}

@Composable
private fun StatusCard(kernelVersion: KernelVersion, ksuVersion: Int?) {
    ElevatedCard(
        colors = CardDefaults.elevatedCardColors(containerColor = run {
            if (ksuVersion != null) MaterialTheme.colorScheme.secondaryContainer
            else MaterialTheme.colorScheme.errorContainer
        })
    ) {
        val uriHandler = LocalUriHandler.current
        Row(modifier = Modifier
            .fillMaxWidth()
            .clickable {
                if (kernelVersion.isGKI() && ksuVersion == null) {
                    uriHandler.openUri("https://kernelsu.org/guide/installation.html")
                }
            }
            .padding(24.dp), verticalAlignment = Alignment.CenterVertically) {
            when {
                ksuVersion != null -> {
                    val appendText = if (Natives.isSafeMode) {
                        " [${stringResource(id = R.string.safe_mode)}]"
                    } else {
                        ""
                    }
                    Icon(Icons.Outlined.CheckCircle, stringResource(R.string.home_working))
                    Column(Modifier.padding(start = 20.dp)) {
                        Text(
                            text = stringResource(R.string.home_working) + appendText,
                            style = MaterialTheme.typography.titleMedium
                        )
                        Spacer(Modifier.height(4.dp))
                        Text(
                            text = stringResource(R.string.home_working_version, ksuVersion),
                            style = MaterialTheme.typography.bodyMedium
                        )
                        Spacer(Modifier.height(4.dp))
                        Text(
                            text = stringResource(
                                R.string.home_superuser_count, getSuperuserCount()
                            ), style = MaterialTheme.typography.bodyMedium
                        )
                        Spacer(Modifier.height(4.dp))
                        Text(
                            text = stringResource(R.string.home_module_count, getModuleCount()),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }

                kernelVersion.isGKI() -> {
                    Icon(Icons.Outlined.Warning, stringResource(R.string.home_not_installed))
                    Column(Modifier.padding(start = 20.dp)) {
                        Text(
                            text = stringResource(R.string.home_not_installed),
                            style = MaterialTheme.typography.titleMedium
                        )
                        Spacer(Modifier.height(4.dp))
                        Text(
                            text = stringResource(R.string.home_click_to_install),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }

                else -> {
                    Icon(Icons.Outlined.Block, stringResource(R.string.home_unsupported))
                    Column(Modifier.padding(start = 20.dp)) {
                        Text(
                            text = stringResource(R.string.home_unsupported),
                            style = MaterialTheme.typography.titleMedium
                        )
                        Spacer(Modifier.height(4.dp))
                        Text(
                            text = stringResource(R.string.home_unsupported_reason),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun WarningCard(
    message: String, color: Color = MaterialTheme.colorScheme.error, onClick: (() -> Unit)? = null
) {
    ElevatedCard(
        colors = CardDefaults.elevatedCardColors(
            containerColor = color
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .then(onClick?.let { Modifier.clickable { it() } } ?: Modifier)
                .padding(24.dp)
        ) {
            Text(
                text = message, style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}

@Composable
fun LearnMoreCard() {
    val uriHandler = LocalUriHandler.current
    val url = stringResource(R.string.home_learn_kernelsu_url)

    ElevatedCard {

        Row(modifier = Modifier
            .fillMaxWidth()
            .clickable {
                uriHandler.openUri(url)
            }
            .padding(24.dp), verticalAlignment = Alignment.CenterVertically) {
            Column() {
                Text(
                    text = stringResource(R.string.home_learn_kernelsu),
                    style = MaterialTheme.typography.titleSmall
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = stringResource(R.string.home_click_to_learn_kernelsu),
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}

@Composable
fun DonateCard() {
    val uriHandler = LocalUriHandler.current

    ElevatedCard {

        Row(modifier = Modifier
            .fillMaxWidth()
            .clickable {
                uriHandler.openUri("https://patreon.com/weishu")
            }
            .padding(24.dp), verticalAlignment = Alignment.CenterVertically) {
            Column() {
                Text(
                    text = stringResource(R.string.home_support_title),
                    style = MaterialTheme.typography.titleSmall
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = stringResource(R.string.home_support_content),
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}

@Composable
private fun InfoCard() {
    val context = LocalContext.current

    ElevatedCard {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(start = 24.dp, top = 24.dp, end = 24.dp, bottom = 16.dp)
        ) {
            val contents = StringBuilder()
            val uname = Os.uname()

            @Composable
            fun InfoCardItem(label: String, content: String) {
                contents.appendLine(label).appendLine(content).appendLine()
                Text(text = label, style = MaterialTheme.typography.bodyLarge)
                Text(text = content, style = MaterialTheme.typography.bodyMedium)
            }

            InfoCardItem(stringResource(R.string.home_kernel), uname.release)

            Spacer(Modifier.height(16.dp))
            val managerVersion = getManagerVersion(context)
            InfoCardItem(
                stringResource(R.string.home_manager_version),
                "${managerVersion.first} (${managerVersion.second})"
            )

            Spacer(Modifier.height(16.dp))
            InfoCardItem(stringResource(R.string.home_fingerprint), Build.FINGERPRINT)

            Spacer(Modifier.height(16.dp))
            InfoCardItem(stringResource(R.string.home_selinux_status), getSELinuxStatus())
        }
    }
}

fun getManagerVersion(context: Context): Pair<String, Int> {
    val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
    return Pair(packageInfo.versionName, packageInfo.versionCode)
}

@Preview
@Composable
private fun StatusCardPreview() {
    Column {
        StatusCard(KernelVersion(5, 10, 101), 1)
        StatusCard(KernelVersion(5, 10, 101), null)
        StatusCard(KernelVersion(4, 10, 101), null)
    }
}

@Preview
@Composable
private fun WarningCardPreview() {
    Column {
        WarningCard(message = "Warning message")
        WarningCard(message =  "Warning message ", MaterialTheme.colorScheme.outlineVariant, onClick = {})
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Install.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.net.Uri
import android.os.Environment
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Save
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.key.Key
import androidx.compose.ui.input.key.key
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.ramcosta.composedestinations.annotation.Destination
import com.ramcosta.composedestinations.navigation.DestinationsNavigator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.KeyEventBlocker
import me.weishu.kernelsu.ui.util.LocalSnackbarHost
import me.weishu.kernelsu.ui.util.installModule
import me.weishu.kernelsu.ui.util.reboot
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

/**
 * @author weishu
 * @date 2023/1/1.
 */
@OptIn(ExperimentalComposeUiApi::class)
@Composable
@Destination
fun InstallScreen(navigator: DestinationsNavigator, uri: Uri) {

    var text by rememberSaveable { mutableStateOf("") }
    val logContent = StringBuilder()
    var showFloatAction by rememberSaveable { mutableStateOf(false) }

    val snackBarHost = LocalSnackbarHost.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    LaunchedEffect(Unit) {
        if (text.isNotEmpty()) {
            return@LaunchedEffect
        }
        withContext(Dispatchers.IO) {
            installModule(uri, onFinish = { success ->
                if (success) {
                    showFloatAction = true
                }
            }, onStdout = {
                text += "$it\n"
                scope.launch {
                    scrollState.animateScrollTo(scrollState.maxValue)
                }
                logContent.append(it).append("\n")
            }, onStderr = {
                logContent.append(it).append("\n")
            });
        }
    }

    Scaffold(
        topBar = {
            TopBar(
                onBack = {
                    navigator.popBackStack()
                },
                onSave = {
                    scope.launch {
                        val format = SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.getDefault())
                        val date = format.format(Date())
                        val file = File(
                            Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                            "KernelSU_install_log_${date}.log"
                        )
                        file.writeText(logContent.toString())
                        snackBarHost.showSnackbar("Log saved to ${file.absolutePath}")
                    }
                }
            )
        },
        floatingActionButton = {
            if (showFloatAction) {
                val reboot = stringResource(id = R.string.reboot)
                ExtendedFloatingActionButton(
                    onClick = {
                        scope.launch {
                            withContext(Dispatchers.IO) {
                                reboot()
                            }
                        }
                    },
                    icon = { Icon(Icons.Filled.Refresh, reboot) },
                    text = { Text(text = reboot) },
                )
            }

        }
    ) { innerPadding ->
        KeyEventBlocker {
            it.key == Key.VolumeDown || it.key == Key.VolumeUp
        }
        Column(
            modifier = Modifier
                .fillMaxSize(1f)
                .padding(innerPadding)
                .verticalScroll(scrollState),
        ) {
            Text(
                modifier = Modifier.padding(8.dp),
                text = text,
                fontSize = MaterialTheme.typography.bodySmall.fontSize,
                fontFamily = MaterialTheme.typography.bodySmall.fontFamily,
                lineHeight = MaterialTheme.typography.bodySmall.lineHeight,
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TopBar(onBack: () -> Unit = {}, onSave: () -> Unit = {}) {
    TopAppBar(
        title = { Text(stringResource(R.string.install)) },
        navigationIcon = {
            IconButton(
                onClick = onBack
            ) { Icon(Icons.Filled.ArrowBack, contentDescription = null) }
        },
        actions = {
            IconButton(onClick = onSave) {
                Icon(
                    imageVector = Icons.Filled.Save,
                    contentDescription = "Localized description"
                )
            }
        }
    )
}

@Preview
@Composable
fun InstallPreview() {
//    InstallScreen(DestinationsNavigator(), uri = Uri.EMPTY)
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Module.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.app.Activity.RESULT_OK
import android.content.Intent
import android.net.Uri
import android.util.Log
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.pullrefresh.PullRefreshIndicator
import androidx.compose.material.pullrefresh.pullRefresh
import androidx.compose.material.pullrefresh.rememberPullRefreshState
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.ramcosta.composedestinations.annotation.Destination
import com.ramcosta.composedestinations.navigation.DestinationsNavigator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.ConfirmDialog
import me.weishu.kernelsu.ui.component.ConfirmResult
import me.weishu.kernelsu.ui.component.LoadingDialog
import me.weishu.kernelsu.ui.screen.destinations.InstallScreenDestination
import me.weishu.kernelsu.ui.util.*
import me.weishu.kernelsu.ui.viewmodel.ModuleViewModel

@Destination
@Composable
fun ModuleScreen(navigator: DestinationsNavigator) {
    val viewModel = viewModel<ModuleViewModel>()

    LaunchedEffect(Unit) {
        if (viewModel.moduleList.isEmpty() || viewModel.isNeedRefresh) {
            viewModel.fetchModuleList()
        }
    }

    val isSafeMode = Natives.isSafeMode
    val hasMagisk = hasMagisk()

    val hideInstallButton = isSafeMode || hasMagisk

    Scaffold(topBar = {
        TopBar()
    }, floatingActionButton = if (hideInstallButton) {
        { /* Empty */ }
    } else {
        {
            val moduleInstall = stringResource(id = R.string.module_install)
            val selectZipLauncher = rememberLauncherForActivityResult(
                contract = ActivityResultContracts.StartActivityForResult()
            ) {
                if (it.resultCode != RESULT_OK) {
                    return@rememberLauncherForActivityResult
                }
                val data = it.data ?: return@rememberLauncherForActivityResult
                val uri = data.data ?: return@rememberLauncherForActivityResult

                navigator.navigate(InstallScreenDestination(uri))

                viewModel.markNeedRefresh()

                Log.i("ModuleScreen", "select zip result: ${it.data}")
            }

            ExtendedFloatingActionButton(
                onClick = {
                    // select the zip file to install
                    val intent = Intent(Intent.ACTION_GET_CONTENT)
                    intent.type = "application/zip"
                    selectZipLauncher.launch(intent)
                },
                icon = { Icon(Icons.Filled.Add, moduleInstall) },
                text = { Text(text = moduleInstall) },
            )
        }
    }) { innerPadding ->

        ConfirmDialog()

        LoadingDialog()

        when {
            hasMagisk -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(24.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        stringResource(R.string.module_magisk_conflict),
                        textAlign = TextAlign.Center,
                    )
                }
            }

            else -> {
                ModuleList(
                    viewModel = viewModel, modifier = Modifier
                        .padding(innerPadding)
                        .fillMaxSize()
                ) {
                    navigator.navigate(InstallScreenDestination(it))
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterialApi::class)
@Composable
private fun ModuleList(
    viewModel: ModuleViewModel, modifier: Modifier = Modifier, onInstallModule: (Uri) -> Unit
) {
    val failedEnable = stringResource(R.string.module_failed_to_enable)
    val failedDisable = stringResource(R.string.module_failed_to_disable)
    val failedUninstall = stringResource(R.string.module_uninstall_failed)
    val successUninstall = stringResource(R.string.module_uninstall_success)
    val reboot = stringResource(id = R.string.reboot)
    val rebootToApply = stringResource(id = R.string.reboot_to_apply)
    val moduleStr = stringResource(id = R.string.module)
    val uninstall = stringResource(id = R.string.uninstall)
    val cancel = stringResource(id = android.R.string.cancel)
    val moduleUninstallConfirm = stringResource(id = R.string.module_uninstall_confirm)

    val dialogHost = LocalDialogHost.current
    val snackBarHost = LocalSnackbarHost.current

    suspend fun onModuleUninstall(module: ModuleViewModel.ModuleInfo) {
        val confirmResult = dialogHost.showConfirm(
            moduleStr,
            content = moduleUninstallConfirm.format(module.name),
            confirm = uninstall,
            dismiss = cancel
        )
        if (confirmResult != ConfirmResult.Confirmed) {
            return
        }

        val success = dialogHost.withLoading {
            withContext(Dispatchers.IO) {
                uninstallModule(module.id)
            }
        }

        if (success) {
            viewModel.fetchModuleList()
        }
        val message = if (success) {
            successUninstall.format(module.name)
        } else {
            failedUninstall.format(module.name)
        }
        val actionLabel = if (success) {
            reboot
        } else {
            null
        }
        val result = snackBarHost.showSnackbar(message, actionLabel = actionLabel)
        if (result == SnackbarResult.ActionPerformed) {
            reboot()
        }
    }

    val refreshState = rememberPullRefreshState(refreshing = viewModel.isRefreshing,
        onRefresh = { viewModel.fetchModuleList() })
    Box(modifier.pullRefresh(refreshState)) {
        val context = LocalContext.current

        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.spacedBy(16.dp),
            contentPadding = remember {
                PaddingValues(
                    start = 16.dp,
                    top = 16.dp,
                    end = 16.dp,
                    bottom = 16.dp + 16.dp + 56.dp /*  Scaffold Fab Spacing + Fab container height */
                )
            },
        ) {
            when {
                !viewModel.isOverlayAvailable -> {
                    item {
                        Box(
                            modifier = Modifier.fillParentMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(stringResource(R.string.module_overlay_fs_not_available), textAlign = TextAlign.Center)
                        }
                    }
                }
                viewModel.moduleList.isEmpty() -> {
                    item {
                        Box(
                            modifier = Modifier.fillParentMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(stringResource(R.string.module_empty), textAlign = TextAlign.Center)
                        }
                    }
                }
                else -> {
                    items(viewModel.moduleList) { module ->
                        var isChecked by rememberSaveable(module) { mutableStateOf(module.enabled) }
                        val scope = rememberCoroutineScope()
                        val updateUrl by produceState(initialValue = "") {
                            viewModel.checkUpdate(module) { value = it.orEmpty() }
                        }

                        val downloadingText = stringResource(R.string.module_downloading)
                        val startDownloadingText = stringResource(R.string.module_start_downloading)

                        ModuleItem(module, isChecked, updateUrl, onUninstall = {
                            scope.launch { onModuleUninstall(module) }
                        }, onCheckChanged = {
                            scope.launch {
                                val success = dialogHost.withLoading {
                                    withContext(Dispatchers.IO) {
                                        toggleModule(module.id, !isChecked)
                                    }
                                }
                                if (success) {
                                    isChecked = it
                                    viewModel.fetchModuleList()

                                    val result = snackBarHost.showSnackbar(
                                        rebootToApply, actionLabel = reboot
                                    )
                                    if (result == SnackbarResult.ActionPerformed) {
                                        reboot()
                                    }
                                } else {
                                    val message = if (isChecked) failedDisable else failedEnable
                                    snackBarHost.showSnackbar(message.format(module.name))
                                }
                            }
                        }, onUpdate = {

                            scope.launch {
                                Toast.makeText(
                                    context,
                                    startDownloadingText.format(module.name),
                                    Toast.LENGTH_SHORT
                                ).show()
                            }

                            val downloading = downloadingText.format(module.name)
                            download(
                                context,
                                updateUrl,
                                "${module.name}-${module.version}.zip",
                                downloading,
                                onDownloaded = onInstallModule,
                                onDownloading = {
                                    Toast.makeText(context, downloading, Toast.LENGTH_SHORT).show()
                                }
                            )
                        })

                        // fix last item shadow incomplete in LazyColumn
                        Spacer(Modifier.height(1.dp))
                    }
                }
            }
        }

        DownloadListener(context, onInstallModule)

        PullRefreshIndicator(
            refreshing = viewModel.isRefreshing, state = refreshState, modifier = Modifier.align(
                Alignment.TopCenter
            )
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TopBar() {
    TopAppBar(title = { Text(stringResource(R.string.module)) })
}

@Composable
private fun ModuleItem(
    module: ModuleViewModel.ModuleInfo,
    isChecked: Boolean,
    updateUrl: String,
    onUninstall: (ModuleViewModel.ModuleInfo) -> Unit,
    onCheckChanged: (Boolean) -> Unit,
    onUpdate: (ModuleViewModel.ModuleInfo) -> Unit,
) {
    ElevatedCard(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.elevatedCardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {

        val textDecoration = if (!module.remove) null else TextDecoration.LineThrough

        Column(modifier = Modifier.padding(24.dp, 16.dp, 24.dp, 0.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
            ) {
                val moduleVersion = stringResource(id = R.string.module_version)
                val moduleAuthor = stringResource(id = R.string.module_author)

                Column(modifier = Modifier.fillMaxWidth(0.8f)) {
                    Text(
                        text = module.name,
                        fontSize = MaterialTheme.typography.titleMedium.fontSize,
                        fontWeight = FontWeight.SemiBold,
                        lineHeight = MaterialTheme.typography.bodySmall.lineHeight,
                        fontFamily = MaterialTheme.typography.titleMedium.fontFamily,
                        textDecoration = textDecoration,
                    )

                    Text(
                        text = "$moduleVersion: ${module.version}",
                        fontSize = MaterialTheme.typography.bodySmall.fontSize,
                        lineHeight = MaterialTheme.typography.bodySmall.lineHeight,
                        fontFamily = MaterialTheme.typography.bodySmall.fontFamily,
                        textDecoration = textDecoration
                    )

                    Text(
                        text = "$moduleAuthor: ${module.author}",
                        fontSize = MaterialTheme.typography.bodySmall.fontSize,
                        lineHeight = MaterialTheme.typography.bodySmall.lineHeight,
                        fontFamily = MaterialTheme.typography.bodySmall.fontFamily,
                        textDecoration = textDecoration
                    )
                }

                Spacer(modifier = Modifier.weight(1f))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End,
                ) {
                    Switch(
                        enabled = !module.update,
                        checked = isChecked,
                        onCheckedChange = onCheckChanged
                    )
                }
            }

            Spacer(modifier = Modifier.height(12.dp))

            Text(
                text = module.description,
                fontSize = MaterialTheme.typography.bodySmall.fontSize,
                fontFamily = MaterialTheme.typography.bodySmall.fontFamily,
                lineHeight = MaterialTheme.typography.bodySmall.lineHeight,
                fontWeight = MaterialTheme.typography.bodySmall.fontWeight,
                overflow = TextOverflow.Ellipsis,
                maxLines = 4,
                textDecoration = textDecoration
            )


            Spacer(modifier = Modifier.height(16.dp))

            Divider(thickness = Dp.Hairline)

            Row(
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Spacer(modifier = Modifier.weight(1f, true))

                if (updateUrl.isNotEmpty()) {
                    Button(
                        modifier = Modifier
                            .padding(0.dp)
                            .defaultMinSize(52.dp, 32.dp),
                        onClick = { onUpdate(module) },
                        shape = RoundedCornerShape(6.dp),
                        contentPadding = PaddingValues(0.dp)
                    ) {
                        Text(
                            fontFamily = MaterialTheme.typography.labelMedium.fontFamily,
                            fontSize = MaterialTheme.typography.labelMedium.fontSize,
                            text = stringResource(R.string.module_update),
                        )
                    }
                }

                TextButton(
                    enabled = !module.remove,
                    onClick = { onUninstall(module) },
                ) {
                    Text(
                        fontFamily = MaterialTheme.typography.labelMedium.fontFamily,
                        fontSize = MaterialTheme.typography.labelMedium.fontSize,
                        text = stringResource(R.string.uninstall),
                    )
                }
            }
        }
    }
}

@Preview
@Composable
fun ModuleItemPreview() {
    val module = ModuleViewModel.ModuleInfo(
        id = "id",
        name = "name",
        version = "version",
        versionCode = 1,
        author = "author",
        description = "I am a test module and i do nothing but show a very long description",
        enabled = true,
        update = true,
        remove = true,
        updateJson = ""
    )
    ModuleItem(module, true, "", {}, {}, {})
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Settings.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.content.Intent
import android.net.Uri
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.BugReport
import androidx.compose.material.icons.filled.ContactPage
import androidx.compose.material.icons.filled.RemoveModerator
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.core.content.FileProvider
import com.ramcosta.composedestinations.annotation.Destination
import com.ramcosta.composedestinations.navigation.DestinationsNavigator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.BuildConfig
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.AboutDialog
import me.weishu.kernelsu.ui.component.LoadingDialog
import me.weishu.kernelsu.ui.component.SwitchItem
import me.weishu.kernelsu.ui.util.LocalDialogHost
import me.weishu.kernelsu.ui.util.getBugreportFile

/**
 * @author weishu
 * @date 2023/1/1.
 */
@Destination
@Composable
fun SettingScreen(navigator: DestinationsNavigator) {

    Scaffold(
        topBar = {
            TopBar(onBack = {
                navigator.popBackStack()
            })
        }
    ) { paddingValues ->
        LoadingDialog()

        val showAboutDialog = remember { mutableStateOf(false) }
        AboutDialog(showAboutDialog)

        Column(modifier = Modifier.padding(paddingValues)) {

            val context = LocalContext.current
            val scope = rememberCoroutineScope()
            val dialogHost = LocalDialogHost.current

            var umountChecked by rememberSaveable {
                mutableStateOf(Natives.isDefaultUmountModules())
            }
            SwitchItem(
                icon = Icons.Filled.RemoveModerator,
                title = stringResource(id = R.string.settings_umount_modules_default),
                summary = stringResource(id = R.string.settings_umount_modules_default_summary),
                checked = umountChecked
            ) {
                if (Natives.setDefaultUmountModules(it)) {
                    umountChecked = it
                }
            }

            ListItem(
                leadingContent = { Icon(Icons.Filled.BugReport, stringResource(id = R.string.send_log)) },
                headlineContent = { Text(stringResource(id = R.string.send_log)) },
                modifier = Modifier.clickable {
                    scope.launch {
                        val bugreport = dialogHost.withLoading {
                            withContext(Dispatchers.IO) {
                                getBugreportFile(context)
                            }
                        }

                        val uri: Uri =
                            FileProvider.getUriForFile(
                                context,
                                "${BuildConfig.APPLICATION_ID}.fileprovider",
                                bugreport
                            )

                        val shareIntent = Intent(Intent.ACTION_SEND)
                        shareIntent.putExtra(Intent.EXTRA_STREAM, uri)
                        shareIntent.setDataAndType(uri, "application/zip")
                        shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)

                        context.startActivity(
                            Intent.createChooser(
                                shareIntent,
                                context.getString(R.string.send_log)
                            )
                        )
                    }
                }
            )

            val about = stringResource(id = R.string.about)
            ListItem(
                leadingContent = { Icon(Icons.Filled.ContactPage, stringResource(id = R.string.about)) },
                headlineContent = { Text(about) },
                modifier = Modifier.clickable {
                    showAboutDialog.value = true
                }
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TopBar(onBack: () -> Unit = {}) {
    TopAppBar(
        title = { Text(stringResource(R.string.settings)) },
        navigationIcon = {
            IconButton(
                onClick = onBack
            ) { Icon(Icons.Filled.ArrowBack, contentDescription = null) }
        },
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/SuperUser.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.pullrefresh.PullRefreshIndicator
import androidx.compose.material.pullrefresh.pullRefresh
import androidx.compose.material.pullrefresh.rememberPullRefreshState
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.ramcosta.composedestinations.annotation.Destination
import com.ramcosta.composedestinations.navigation.DestinationsNavigator
import kotlinx.coroutines.launch
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.ConfirmDialog
import me.weishu.kernelsu.ui.component.SearchAppBar
import me.weishu.kernelsu.ui.screen.destinations.AppProfileScreenDestination
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel

@OptIn(ExperimentalMaterialApi::class)
@Destination
@Composable
fun SuperUserScreen(navigator: DestinationsNavigator) {
    val viewModel = viewModel<SuperUserViewModel>()
    val scope = rememberCoroutineScope()

    LaunchedEffect(Unit) {
        if (viewModel.appList.isEmpty()) {
            viewModel.fetchAppList()
        }
    }

    Scaffold(
        topBar = {
            SearchAppBar(
                title = { Text(stringResource(R.string.superuser)) },
                searchText = viewModel.search,
                onSearchTextChange = { viewModel.search = it },
                onClearClick = { viewModel.search = "" },
                dropdownContent = {
                    var showDropdown by remember { mutableStateOf(false) }

                    IconButton(
                        onClick = { showDropdown = true },
                    ) {
                        Icon(
                            imageVector = Icons.Filled.MoreVert,
                            contentDescription = stringResource(id = R.string.settings)
                        )

                        DropdownMenu(expanded = showDropdown, onDismissRequest = {
                            showDropdown = false
                        }) {
                            DropdownMenuItem(text = {
                                Text(stringResource(R.string.refresh))
                            }, onClick = {
                                scope.launch {
                                    viewModel.fetchAppList()
                                }
                                showDropdown = false
                            })
                            DropdownMenuItem(text = {
                                Text(
                                    if (viewModel.showSystemApps) {
                                        stringResource(R.string.hide_system_apps)
                                    } else {
                                        stringResource(R.string.show_system_apps)
                                    }
                                )
                            }, onClick = {
                                viewModel.showSystemApps = !viewModel.showSystemApps
                                showDropdown = false
                            })
                        }
                    }
                },
            )
        }
    ) { innerPadding ->

        ConfirmDialog()

        val refreshState = rememberPullRefreshState(
            refreshing = viewModel.isRefreshing,
            onRefresh = { scope.launch { viewModel.fetchAppList() } },
        )
        Box(
            modifier = Modifier
                .padding(innerPadding)
                .pullRefresh(refreshState)
        ) {
            LazyColumn(Modifier.fillMaxSize()) {
                items(viewModel.appList, key = { it.packageName + it.uid }) { app ->
                    AppItem(app) {
                        navigator.navigate(AppProfileScreenDestination(app))
                    }

                }
            }

            PullRefreshIndicator(
                refreshing = viewModel.isRefreshing,
                state = refreshState,
                modifier = Modifier.align(Alignment.TopCenter)
            )
        }
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun AppItem(
    app: SuperUserViewModel.AppInfo,
    onClickListener: () -> Unit,
) {
    ListItem(
        modifier = Modifier.clickable(onClick = onClickListener),
        headlineContent = { Text(app.label) },
        supportingContent = {
            Column {
                Text(app.packageName)
                FlowRow {
                    if (app.allowSu) {
                        LabelText(label = "ROOT")
                    } else {
                        if (Natives.uidShouldUmount(app.uid)) {
                            LabelText(label = "UMOUNT")
                        }
                    }
                    if (app.hasCustomProfile) {
                        LabelText(label = "CUSTOM")
                    }
                }
            }
        },
        leadingContent = {
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(app.packageInfo)
                    .crossfade(true)
                    .build(),
                contentDescription = app.label,
                modifier = Modifier
                    .padding(4.dp)
                    .width(48.dp)
                    .height(48.dp)
            )
        },
    )
}

@Composable
fun LabelText(label: String) {
    Box(
        modifier = Modifier
            .padding(top = 4.dp, end = 4.dp)
            .background(
                Color.Black,
                shape = RoundedCornerShape(4.dp)
            )
    ) {
        Text(
            text = label,
            modifier = Modifier.padding(vertical = 2.dp, horizontal = 5.dp),
            style = TextStyle(
                fontSize = 8.sp,
                color = Color.White,
            )
        )
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/theme/Color.kt`:

```kt
package me.weishu.kernelsu.ui.theme

import androidx.compose.ui.graphics.Color

val YELLOW = Color(0xFFeed502)
val YELLOW_LIGHT = Color(0xFFffff52)
val SECONDARY_LIGHT = Color(0xffa9817f)

val YELLOW_DARK = Color(0xFFb7a400)
val SECONDARY_DARK = Color(0xFF4c2b2b)
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/theme/Theme.kt`:

```kt
package me.weishu.kernelsu.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.unit.dp
import androidx.core.view.ViewCompat
import com.google.accompanist.systemuicontroller.rememberSystemUiController

private val DarkColorScheme = darkColorScheme(
    primary = YELLOW,
    secondary = YELLOW_DARK,
    tertiary = SECONDARY_DARK
)

private val LightColorScheme = lightColorScheme(
    primary = YELLOW,
    secondary = YELLOW_LIGHT,
    tertiary = SECONDARY_LIGHT
)

@Composable
fun KernelSUTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    val systemUiController = rememberSystemUiController()
    SideEffect {
        systemUiController.setStatusBarColor(
            color = colorScheme.surface,
            darkIcons = !darkTheme
        )

        // To match the App Navbar color
        systemUiController.setNavigationBarColor(
            color = colorScheme.surfaceColorAtElevation(8.dp),
            darkIcons = !darkTheme,
        )
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/theme/Type.kt`:

```kt
package me.weishu.kernelsu.ui.theme

import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = androidx.compose.material3.Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/CompositionProvider.kt`:

```kt
package me.weishu.kernelsu.ui.util

import androidx.compose.material3.SnackbarHostState
import androidx.compose.runtime.compositionLocalOf
import me.weishu.kernelsu.ui.component.DialogHostState

val LocalSnackbarHost = compositionLocalOf<SnackbarHostState> {
    error("CompositionLocal LocalSnackbarController not present")
}

val LocalDialogHost = compositionLocalOf<DialogHostState> {
    error("CompositionLocal LocalDialogController not present")
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/Downloader.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.annotation.SuppressLint
import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.Uri
import android.os.Environment
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect

/**
 * @author weishu
 * @date 2023/6/22.
 */
@SuppressLint("Range")
fun download(
    context: Context,
    url: String,
    fileName: String,
    description: String,
    onDownloaded: (Uri) -> Unit = {},
    onDownloading: () -> Unit = {}
) {
    val downloadManager =
        context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager

    val query = DownloadManager.Query()
    query.setFilterByStatus(DownloadManager.STATUS_RUNNING or DownloadManager.STATUS_PAUSED or DownloadManager.STATUS_PENDING)
    downloadManager.query(query).use { cursor ->
        while (cursor.moveToNext()) {
            val uri = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_URI))
            val localUri = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI))
            val status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS))
            val columnTitle = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_TITLE))
            if (url == uri || fileName == columnTitle) {
                if (status == DownloadManager.STATUS_RUNNING || status == DownloadManager.STATUS_PENDING) {
                    onDownloading()
                    return
                } else if (status == DownloadManager.STATUS_SUCCESSFUL) {
                    onDownloaded(Uri.parse(localUri))
                    return
                }
            }
        }
    }

    val request = DownloadManager.Request(Uri.parse(url))
        .setDestinationInExternalPublicDir(
            Environment.DIRECTORY_DOWNLOADS,
            fileName
        )
        .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
        .setMimeType("application/zip")
        .setTitle(fileName)
        .setDescription(description)

    downloadManager.enqueue(request)
}

fun checkNewVersion(): Pair<Int, String> {
    val url = "https://api.github.com/repos/tiann/KernelSU/releases/latest"
    val defaultValue = 0 to ""
    runCatching {
        okhttp3.OkHttpClient().newCall(okhttp3.Request.Builder().url(url).build()).execute()
            .use { response ->
                if (!response.isSuccessful) {
                    return defaultValue
                }
                val body = response.body?.string() ?: return defaultValue
                val json = org.json.JSONObject(body)

                val assets = json.getJSONArray("assets")
                for (i in 0 until assets.length()) {
                    val asset = assets.getJSONObject(i)
                    val name = asset.getString("name")
                    if (!name.endsWith(".apk")) {
                        continue
                    }

                    val regex = Regex("v(.+?)_(\\d+)-")
                    val matchResult = regex.find(name) ?: continue
                    val versionName = matchResult.groupValues[1]
                    val versionCode = matchResult.groupValues[2].toInt()
                    val downloadUrl = asset.getString("browser_download_url")

                    return versionCode to downloadUrl
                }

            }
    }
    return defaultValue
}

@Composable
fun DownloadListener(context: Context, onDownloaded: (Uri) -> Unit) {
    DisposableEffect(context) {
        val receiver = object : BroadcastReceiver() {
            @SuppressLint("Range")
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == DownloadManager.ACTION_DOWNLOAD_COMPLETE) {
                    val id = intent.getLongExtra(
                        DownloadManager.EXTRA_DOWNLOAD_ID, -1
                    )
                    val query = DownloadManager.Query().setFilterById(id)
                    val downloadManager =
                        context?.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
                    val cursor = downloadManager.query(query)
                    if (cursor.moveToFirst()) {
                        val status = cursor.getInt(
                            cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                        )
                        if (status == DownloadManager.STATUS_SUCCESSFUL) {
                            val uri = cursor.getString(
                                cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)
                            )
                            onDownloaded(Uri.parse(uri))
                        }
                    }
                }
            }
        }
        context.registerReceiver(
            receiver,
            IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)
        )
        onDispose {
            context.unregisterReceiver(receiver)
        }
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/HanziToPinyin.java`:

```java
package me.weishu.kernelsu.ui.util;
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import android.text.TextUtils;
import android.util.Log;

import java.text.Collator;
import java.util.ArrayList;
import java.util.Locale;

/**
 * An object to convert Chinese character to its corresponding pinyin string. For characters with
 * multiple possible pinyin string, only one is selected according to collator. Polyphone is not
 * supported in this implementation. This class is implemented to achieve the best runtime
 * performance and minimum runtime resources with tolerable sacrifice of accuracy. This
 * implementation highly depends on zh_CN ICU collation data and must be always synchronized with
 * ICU.
 * <p>
 * Currently this file is aligned to zh.txt in ICU 4.6
 */
public class HanziToPinyin {
    private static final String TAG = "HanziToPinyin";

    // Turn on this flag when we want to check internal data structure.
    private static final boolean DEBUG = false;

    /**
     * Unihans array.
     * <p>
     * Each unihans is the first one within same pinyin when collator is zh_CN.
     */
    public static final char[] UNIHANS = {
            '\u963f', '\u54ce', '\u5b89', '\u80ae', '\u51f9', '\u516b',
            '\u6300', '\u6273', '\u90a6', '\u52f9', '\u9642', '\u5954',
            '\u4f3b', '\u5c44', '\u8fb9', '\u706c', '\u618b', '\u6c43',
            '\u51ab', '\u7676', '\u5cec', '\u5693', '\u5072', '\u53c2',
            '\u4ed3', '\u64a1', '\u518a', '\u5d7e', '\u66fd', '\u66fe',
            '\u5c64', '\u53c9', '\u8286', '\u8fbf', '\u4f25', '\u6284',
            '\u8f66', '\u62bb', '\u6c88', '\u6c89', '\u9637', '\u5403',
            '\u5145', '\u62bd', '\u51fa', '\u6b3b', '\u63e3', '\u5ddb',
            '\u5205', '\u5439', '\u65fe', '\u9034', '\u5472', '\u5306',
            '\u51d1', '\u7c97', '\u6c46', '\u5d14', '\u90a8', '\u6413',
            '\u5491', '\u5446', '\u4e39', '\u5f53', '\u5200', '\u561a',
            '\u6265', '\u706f', '\u6c10', '\u55f2', '\u7538', '\u5201',
            '\u7239', '\u4e01', '\u4e1f', '\u4e1c', '\u543a', '\u53be',
            '\u8011', '\u8968', '\u5428', '\u591a', '\u59b8', '\u8bf6',
            '\u5940', '\u97a5', '\u513f', '\u53d1', '\u5e06', '\u531a',
            '\u98de', '\u5206', '\u4e30', '\u8985', '\u4ecf', '\u7d11',
            '\u4f15', '\u65ee', '\u4f85', '\u7518', '\u5188', '\u768b',
            '\u6208', '\u7ed9', '\u6839', '\u522f', '\u5de5', '\u52fe',
            '\u4f30', '\u74dc', '\u4e56', '\u5173', '\u5149', '\u5f52',
            '\u4e28', '\u5459', '\u54c8', '\u548d', '\u4f44', '\u592f',
            '\u8320', '\u8bc3', '\u9ed2', '\u62eb', '\u4ea8', '\u5677',
            '\u53ff', '\u9f41', '\u4e6f', '\u82b1', '\u6000', '\u72bf',
            '\u5ddf', '\u7070', '\u660f', '\u5419', '\u4e0c', '\u52a0',
            '\u620b', '\u6c5f', '\u827d', '\u9636', '\u5dfe', '\u5755',
            '\u5182', '\u4e29', '\u51e5', '\u59e2', '\u5658', '\u519b',
            '\u5494', '\u5f00', '\u520a', '\u5ffc', '\u5c3b', '\u533c',
            '\u808e', '\u52a5', '\u7a7a', '\u62a0', '\u625d', '\u5938',
            '\u84af', '\u5bbd', '\u5321', '\u4e8f', '\u5764', '\u6269',
            '\u5783', '\u6765', '\u5170', '\u5577', '\u635e', '\u808b',
            '\u52d2', '\u5d1a', '\u5215', '\u4fe9', '\u5941', '\u826f',
            '\u64a9', '\u5217', '\u62ce', '\u5222', '\u6e9c', '\u56d6',
            '\u9f99', '\u779c', '\u565c', '\u5a08', '\u7567', '\u62a1',
            '\u7f57', '\u5463', '\u5988', '\u57cb', '\u5ada', '\u7264',
            '\u732b', '\u4e48', '\u5445', '\u95e8', '\u753f', '\u54aa',
            '\u5b80', '\u55b5', '\u4e5c', '\u6c11', '\u540d', '\u8c2c',
            '\u6478', '\u54de', '\u6bea', '\u55ef', '\u62cf', '\u8149',
            '\u56e1', '\u56d4', '\u5b6c', '\u7592', '\u5a1e', '\u6041',
            '\u80fd', '\u59ae', '\u62c8', '\u5b22', '\u9e1f', '\u634f',
            '\u56dc', '\u5b81', '\u599e', '\u519c', '\u7fba', '\u5974',
            '\u597b', '\u759f', '\u9ec1', '\u90cd', '\u5594', '\u8bb4',
            '\u5991', '\u62cd', '\u7705', '\u4e53', '\u629b', '\u5478',
            '\u55b7', '\u5309', '\u4e15', '\u56e8', '\u527d', '\u6c15',
            '\u59d8', '\u4e52', '\u948b', '\u5256', '\u4ec6', '\u4e03',
            '\u6390', '\u5343', '\u545b', '\u6084', '\u767f', '\u4eb2',
            '\u72c5', '\u828e', '\u4e18', '\u533a', '\u5cd1', '\u7f3a',
            '\u590b', '\u5465', '\u7a63', '\u5a06', '\u60f9', '\u4eba',
            '\u6254', '\u65e5', '\u8338', '\u53b9', '\u909a', '\u633c',
            '\u5827', '\u5a51', '\u77a4', '\u637c', '\u4ee8', '\u6be2',
            '\u4e09', '\u6852', '\u63bb', '\u95aa', '\u68ee', '\u50e7',
            '\u6740', '\u7b5b', '\u5c71', '\u4f24', '\u5f30', '\u5962',
            '\u7533', '\u8398', '\u6552', '\u5347', '\u5c38', '\u53ce',
            '\u4e66', '\u5237', '\u8870', '\u95e9', '\u53cc', '\u8c01',
            '\u542e', '\u8bf4', '\u53b6', '\u5fea', '\u635c', '\u82cf',
            '\u72fb', '\u590a', '\u5b59', '\u5506', '\u4ed6', '\u56fc',
            '\u574d', '\u6c64', '\u5932', '\u5fd1', '\u71a5', '\u5254',
            '\u5929', '\u65eb', '\u5e16', '\u5385', '\u56f2', '\u5077',
            '\u51f8', '\u6e4d', '\u63a8', '\u541e', '\u4e47', '\u7a75',
            '\u6b6a', '\u5f2f', '\u5c23', '\u5371', '\u6637', '\u7fc1',
            '\u631d', '\u4e4c', '\u5915', '\u8672', '\u4eda', '\u4e61',
            '\u7071', '\u4e9b', '\u5fc3', '\u661f', '\u51f6', '\u4f11',
            '\u5401', '\u5405', '\u524a', '\u5743', '\u4e2b', '\u6079',
            '\u592e', '\u5e7a', '\u503b', '\u4e00', '\u56d9', '\u5e94',
            '\u54df', '\u4f63', '\u4f18', '\u625c', '\u56e6', '\u66f0',
            '\u6655', '\u7b60', '\u7b7c', '\u5e00', '\u707d', '\u5142',
            '\u5328', '\u50ae', '\u5219', '\u8d3c', '\u600e', '\u5897',
            '\u624e', '\u635a', '\u6cbe', '\u5f20', '\u957f', '\u9577',
            '\u4f4b', '\u8707', '\u8d1e', '\u4e89', '\u4e4b', '\u5cd9',
            '\u5ea2', '\u4e2d', '\u5dde', '\u6731', '\u6293', '\u62fd',
            '\u4e13', '\u5986', '\u96b9', '\u5b92', '\u5353', '\u4e72',
            '\u5b97', '\u90b9', '\u79df', '\u94bb', '\u539c', '\u5c0a',
            '\u6628', '\u5159', '\u9fc3', '\u9fc4',};

    /**
     * Pinyin array.
     * <p>
     * Each pinyin is corresponding to unihans of same
     * offset in the unihans array.
     */
    public static final byte[][] PINYINS = {
            {65, 0, 0, 0, 0, 0}, {65, 73, 0, 0, 0, 0},
            {65, 78, 0, 0, 0, 0}, {65, 78, 71, 0, 0, 0},
            {65, 79, 0, 0, 0, 0}, {66, 65, 0, 0, 0, 0},
            {66, 65, 73, 0, 0, 0}, {66, 65, 78, 0, 0, 0},
            {66, 65, 78, 71, 0, 0}, {66, 65, 79, 0, 0, 0},
            {66, 69, 73, 0, 0, 0}, {66, 69, 78, 0, 0, 0},
            {66, 69, 78, 71, 0, 0}, {66, 73, 0, 0, 0, 0},
            {66, 73, 65, 78, 0, 0}, {66, 73, 65, 79, 0, 0},
            {66, 73, 69, 0, 0, 0}, {66, 73, 78, 0, 0, 0},
            {66, 73, 78, 71, 0, 0}, {66, 79, 0, 0, 0, 0},
            {66, 85, 0, 0, 0, 0}, {67, 65, 0, 0, 0, 0},
            {67, 65, 73, 0, 0, 0}, {67, 65, 78, 0, 0, 0},
            {67, 65, 78, 71, 0, 0}, {67, 65, 79, 0, 0, 0},
            {67, 69, 0, 0, 0, 0}, {67, 69, 78, 0, 0, 0},
            {67, 69, 78, 71, 0, 0}, {90, 69, 78, 71, 0, 0},
            {67, 69, 78, 71, 0, 0}, {67, 72, 65, 0, 0, 0},
            {67, 72, 65, 73, 0, 0}, {67, 72, 65, 78, 0, 0},
            {67, 72, 65, 78, 71, 0}, {67, 72, 65, 79, 0, 0},
            {67, 72, 69, 0, 0, 0}, {67, 72, 69, 78, 0, 0},
            {83, 72, 69, 78, 0, 0}, {67, 72, 69, 78, 0, 0},
            {67, 72, 69, 78, 71, 0}, {67, 72, 73, 0, 0, 0},
            {67, 72, 79, 78, 71, 0}, {67, 72, 79, 85, 0, 0},
            {67, 72, 85, 0, 0, 0}, {67, 72, 85, 65, 0, 0},
            {67, 72, 85, 65, 73, 0}, {67, 72, 85, 65, 78, 0},
            {67, 72, 85, 65, 78, 71}, {67, 72, 85, 73, 0, 0},
            {67, 72, 85, 78, 0, 0}, {67, 72, 85, 79, 0, 0},
            {67, 73, 0, 0, 0, 0}, {67, 79, 78, 71, 0, 0},
            {67, 79, 85, 0, 0, 0}, {67, 85, 0, 0, 0, 0},
            {67, 85, 65, 78, 0, 0}, {67, 85, 73, 0, 0, 0},
            {67, 85, 78, 0, 0, 0}, {67, 85, 79, 0, 0, 0},
            {68, 65, 0, 0, 0, 0}, {68, 65, 73, 0, 0, 0},
            {68, 65, 78, 0, 0, 0}, {68, 65, 78, 71, 0, 0},
            {68, 65, 79, 0, 0, 0}, {68, 69, 0, 0, 0, 0},
            {68, 69, 78, 0, 0, 0}, {68, 69, 78, 71, 0, 0},
            {68, 73, 0, 0, 0, 0}, {68, 73, 65, 0, 0, 0},
            {68, 73, 65, 78, 0, 0}, {68, 73, 65, 79, 0, 0},
            {68, 73, 69, 0, 0, 0}, {68, 73, 78, 71, 0, 0},
            {68, 73, 85, 0, 0, 0}, {68, 79, 78, 71, 0, 0},
            {68, 79, 85, 0, 0, 0}, {68, 85, 0, 0, 0, 0},
            {68, 85, 65, 78, 0, 0}, {68, 85, 73, 0, 0, 0},
            {68, 85, 78, 0, 0, 0}, {68, 85, 79, 0, 0, 0},
            {69, 0, 0, 0, 0, 0}, {69, 73, 0, 0, 0, 0},
            {69, 78, 0, 0, 0, 0}, {69, 78, 71, 0, 0, 0},
            {69, 82, 0, 0, 0, 0}, {70, 65, 0, 0, 0, 0},
            {70, 65, 78, 0, 0, 0}, {70, 65, 78, 71, 0, 0},
            {70, 69, 73, 0, 0, 0}, {70, 69, 78, 0, 0, 0},
            {70, 69, 78, 71, 0, 0}, {70, 73, 65, 79, 0, 0},
            {70, 79, 0, 0, 0, 0}, {70, 79, 85, 0, 0, 0},
            {70, 85, 0, 0, 0, 0}, {71, 65, 0, 0, 0, 0},
            {71, 65, 73, 0, 0, 0}, {71, 65, 78, 0, 0, 0},
            {71, 65, 78, 71, 0, 0}, {71, 65, 79, 0, 0, 0},
            {71, 69, 0, 0, 0, 0}, {71, 69, 73, 0, 0, 0},
            {71, 69, 78, 0, 0, 0}, {71, 69, 78, 71, 0, 0},
            {71, 79, 78, 71, 0, 0}, {71, 79, 85, 0, 0, 0},
            {71, 85, 0, 0, 0, 0}, {71, 85, 65, 0, 0, 0},
            {71, 85, 65, 73, 0, 0}, {71, 85, 65, 78, 0, 0},
            {71, 85, 65, 78, 71, 0}, {71, 85, 73, 0, 0, 0},
            {71, 85, 78, 0, 0, 0}, {71, 85, 79, 0, 0, 0},
            {72, 65, 0, 0, 0, 0}, {72, 65, 73, 0, 0, 0},
            {72, 65, 78, 0, 0, 0}, {72, 65, 78, 71, 0, 0},
            {72, 65, 79, 0, 0, 0}, {72, 69, 0, 0, 0, 0},
            {72, 69, 73, 0, 0, 0}, {72, 69, 78, 0, 0, 0},
            {72, 69, 78, 71, 0, 0}, {72, 77, 0, 0, 0, 0},
            {72, 79, 78, 71, 0, 0}, {72, 79, 85, 0, 0, 0},
            {72, 85, 0, 0, 0, 0}, {72, 85, 65, 0, 0, 0},
            {72, 85, 65, 73, 0, 0}, {72, 85, 65, 78, 0, 0},
            {72, 85, 65, 78, 71, 0}, {72, 85, 73, 0, 0, 0},
            {72, 85, 78, 0, 0, 0}, {72, 85, 79, 0, 0, 0},
            {74, 73, 0, 0, 0, 0}, {74, 73, 65, 0, 0, 0},
            {74, 73, 65, 78, 0, 0}, {74, 73, 65, 78, 71, 0},
            {74, 73, 65, 79, 0, 0}, {74, 73, 69, 0, 0, 0},
            {74, 73, 78, 0, 0, 0}, {74, 73, 78, 71, 0, 0},
            {74, 73, 79, 78, 71, 0}, {74, 73, 85, 0, 0, 0},
            {74, 85, 0, 0, 0, 0}, {74, 85, 65, 78, 0, 0},
            {74, 85, 69, 0, 0, 0}, {74, 85, 78, 0, 0, 0},
            {75, 65, 0, 0, 0, 0}, {75, 65, 73, 0, 0, 0},
            {75, 65, 78, 0, 0, 0}, {75, 65, 78, 71, 0, 0},
            {75, 65, 79, 0, 0, 0}, {75, 69, 0, 0, 0, 0},
            {75, 69, 78, 0, 0, 0}, {75, 69, 78, 71, 0, 0},
            {75, 79, 78, 71, 0, 0}, {75, 79, 85, 0, 0, 0},
            {75, 85, 0, 0, 0, 0}, {75, 85, 65, 0, 0, 0},
            {75, 85, 65, 73, 0, 0}, {75, 85, 65, 78, 0, 0},
            {75, 85, 65, 78, 71, 0}, {75, 85, 73, 0, 0, 0},
            {75, 85, 78, 0, 0, 0}, {75, 85, 79, 0, 0, 0},
            {76, 65, 0, 0, 0, 0}, {76, 65, 73, 0, 0, 0},
            {76, 65, 78, 0, 0, 0}, {76, 65, 78, 71, 0, 0},
            {76, 65, 79, 0, 0, 0}, {76, 69, 0, 0, 0, 0},
            {76, 69, 73, 0, 0, 0}, {76, 69, 78, 71, 0, 0},
            {76, 73, 0, 0, 0, 0}, {76, 73, 65, 0, 0, 0},
            {76, 73, 65, 78, 0, 0}, {76, 73, 65, 78, 71, 0},
            {76, 73, 65, 79, 0, 0}, {76, 73, 69, 0, 0, 0},
            {76, 73, 78, 0, 0, 0}, {76, 73, 78, 71, 0, 0},
            {76, 73, 85, 0, 0, 0}, {76, 79, 0, 0, 0, 0},
            {76, 79, 78, 71, 0, 0}, {76, 79, 85, 0, 0, 0},
            {76, 85, 0, 0, 0, 0}, {76, 85, 65, 78, 0, 0},
            {76, 85, 69, 0, 0, 0}, {76, 85, 78, 0, 0, 0},
            {76, 85, 79, 0, 0, 0}, {77, 0, 0, 0, 0, 0},
            {77, 65, 0, 0, 0, 0}, {77, 65, 73, 0, 0, 0},
            {77, 65, 78, 0, 0, 0}, {77, 65, 78, 71, 0, 0},
            {77, 65, 79, 0, 0, 0}, {77, 69, 0, 0, 0, 0},
            {77, 69, 73, 0, 0, 0}, {77, 69, 78, 0, 0, 0},
            {77, 69, 78, 71, 0, 0}, {77, 73, 0, 0, 0, 0},
            {77, 73, 65, 78, 0, 0}, {77, 73, 65, 79, 0, 0},
            {77, 73, 69, 0, 0, 0}, {77, 73, 78, 0, 0, 0},
            {77, 73, 78, 71, 0, 0}, {77, 73, 85, 0, 0, 0},
            {77, 79, 0, 0, 0, 0}, {77, 79, 85, 0, 0, 0},
            {77, 85, 0, 0, 0, 0}, {78, 0, 0, 0, 0, 0},
            {78, 65, 0, 0, 0, 0}, {78, 65, 73, 0, 0, 0},
            {78, 65, 78, 0, 0, 0}, {78, 65, 78, 71, 0, 0},
            {78, 65, 79, 0, 0, 0}, {78, 69, 0, 0, 0, 0},
            {78, 69, 73, 0, 0, 0}, {78, 69, 78, 0, 0, 0},
            {78, 69, 78, 71, 0, 0}, {78, 73, 0, 0, 0, 0},
            {78, 73, 65, 78, 0, 0}, {78, 73, 65, 78, 71, 0},
            {78, 73, 65, 79, 0, 0}, {78, 73, 69, 0, 0, 0},
            {78, 73, 78, 0, 0, 0}, {78, 73, 78, 71, 0, 0},
            {78, 73, 85, 0, 0, 0}, {78, 79, 78, 71, 0, 0},
            {78, 79, 85, 0, 0, 0}, {78, 85, 0, 0, 0, 0},
            {78, 85, 65, 78, 0, 0}, {78, 85, 69, 0, 0, 0},
            {78, 85, 78, 0, 0, 0}, {78, 85, 79, 0, 0, 0},
            {79, 0, 0, 0, 0, 0}, {79, 85, 0, 0, 0, 0},
            {80, 65, 0, 0, 0, 0}, {80, 65, 73, 0, 0, 0},
            {80, 65, 78, 0, 0, 0}, {80, 65, 78, 71, 0, 0},
            {80, 65, 79, 0, 0, 0}, {80, 69, 73, 0, 0, 0},
            {80, 69, 78, 0, 0, 0}, {80, 69, 78, 71, 0, 0},
            {80, 73, 0, 0, 0, 0}, {80, 73, 65, 78, 0, 0},
            {80, 73, 65, 79, 0, 0}, {80, 73, 69, 0, 0, 0},
            {80, 73, 78, 0, 0, 0}, {80, 73, 78, 71, 0, 0},
            {80, 79, 0, 0, 0, 0}, {80, 79, 85, 0, 0, 0},
            {80, 85, 0, 0, 0, 0}, {81, 73, 0, 0, 0, 0},
            {81, 73, 65, 0, 0, 0}, {81, 73, 65, 78, 0, 0},
            {81, 73, 65, 78, 71, 0}, {81, 73, 65, 79, 0, 0},
            {81, 73, 69, 0, 0, 0}, {81, 73, 78, 0, 0, 0},
            {81, 73, 78, 71, 0, 0}, {81, 73, 79, 78, 71, 0},
            {81, 73, 85, 0, 0, 0}, {81, 85, 0, 0, 0, 0},
            {81, 85, 65, 78, 0, 0}, {81, 85, 69, 0, 0, 0},
            {81, 85, 78, 0, 0, 0}, {82, 65, 78, 0, 0, 0},
            {82, 65, 78, 71, 0, 0}, {82, 65, 79, 0, 0, 0},
            {82, 69, 0, 0, 0, 0}, {82, 69, 78, 0, 0, 0},
            {82, 69, 78, 71, 0, 0}, {82, 73, 0, 0, 0, 0},
            {82, 79, 78, 71, 0, 0}, {82, 79, 85, 0, 0, 0},
            {82, 85, 0, 0, 0, 0}, {82, 85, 65, 0, 0, 0},
            {82, 85, 65, 78, 0, 0}, {82, 85, 73, 0, 0, 0},
            {82, 85, 78, 0, 0, 0}, {82, 85, 79, 0, 0, 0},
            {83, 65, 0, 0, 0, 0}, {83, 65, 73, 0, 0, 0},
            {83, 65, 78, 0, 0, 0}, {83, 65, 78, 71, 0, 0},
            {83, 65, 79, 0, 0, 0}, {83, 69, 0, 0, 0, 0},
            {83, 69, 78, 0, 0, 0}, {83, 69, 78, 71, 0, 0},
            {83, 72, 65, 0, 0, 0}, {83, 72, 65, 73, 0, 0},
            {83, 72, 65, 78, 0, 0}, {83, 72, 65, 78, 71, 0},
            {83, 72, 65, 79, 0, 0}, {83, 72, 69, 0, 0, 0},
            {83, 72, 69, 78, 0, 0}, {88, 73, 78, 0, 0, 0},
            {83, 72, 69, 78, 0, 0}, {83, 72, 69, 78, 71, 0},
            {83, 72, 73, 0, 0, 0}, {83, 72, 79, 85, 0, 0},
            {83, 72, 85, 0, 0, 0}, {83, 72, 85, 65, 0, 0},
            {83, 72, 85, 65, 73, 0}, {83, 72, 85, 65, 78, 0},
            {83, 72, 85, 65, 78, 71}, {83, 72, 85, 73, 0, 0},
            {83, 72, 85, 78, 0, 0}, {83, 72, 85, 79, 0, 0},
            {83, 73, 0, 0, 0, 0}, {83, 79, 78, 71, 0, 0},
            {83, 79, 85, 0, 0, 0}, {83, 85, 0, 0, 0, 0},
            {83, 85, 65, 78, 0, 0}, {83, 85, 73, 0, 0, 0},
            {83, 85, 78, 0, 0, 0}, {83, 85, 79, 0, 0, 0},
            {84, 65, 0, 0, 0, 0}, {84, 65, 73, 0, 0, 0},
            {84, 65, 78, 0, 0, 0}, {84, 65, 78, 71, 0, 0},
            {84, 65, 79, 0, 0, 0}, {84, 69, 0, 0, 0, 0},
            {84, 69, 78, 71, 0, 0}, {84, 73, 0, 0, 0, 0},
            {84, 73, 65, 78, 0, 0}, {84, 73, 65, 79, 0, 0},
            {84, 73, 69, 0, 0, 0}, {84, 73, 78, 71, 0, 0},
            {84, 79, 78, 71, 0, 0}, {84, 79, 85, 0, 0, 0},
            {84, 85, 0, 0, 0, 0}, {84, 85, 65, 78, 0, 0},
            {84, 85, 73, 0, 0, 0}, {84, 85, 78, 0, 0, 0},
            {84, 85, 79, 0, 0, 0}, {87, 65, 0, 0, 0, 0},
            {87, 65, 73, 0, 0, 0}, {87, 65, 78, 0, 0, 0},
            {87, 65, 78, 71, 0, 0}, {87, 69, 73, 0, 0, 0},
            {87, 69, 78, 0, 0, 0}, {87, 69, 78, 71, 0, 0},
            {87, 79, 0, 0, 0, 0}, {87, 85, 0, 0, 0, 0},
            {88, 73, 0, 0, 0, 0}, {88, 73, 65, 0, 0, 0},
            {88, 73, 65, 78, 0, 0}, {88, 73, 65, 78, 71, 0},
            {88, 73, 65, 79, 0, 0}, {88, 73, 69, 0, 0, 0},
            {88, 73, 78, 0, 0, 0}, {88, 73, 78, 71, 0, 0},
            {88, 73, 79, 78, 71, 0}, {88, 73, 85, 0, 0, 0},
            {88, 85, 0, 0, 0, 0}, {88, 85, 65, 78, 0, 0},
            {88, 85, 69, 0, 0, 0}, {88, 85, 78, 0, 0, 0},
            {89, 65, 0, 0, 0, 0}, {89, 65, 78, 0, 0, 0},
            {89, 65, 78, 71, 0, 0}, {89, 65, 79, 0, 0, 0},
            {89, 69, 0, 0, 0, 0}, {89, 73, 0, 0, 0, 0},
            {89, 73, 78, 0, 0, 0}, {89, 73, 78, 71, 0, 0},
            {89, 79, 0, 0, 0, 0}, {89, 79, 78, 71, 0, 0},
            {89, 79, 85, 0, 0, 0}, {89, 85, 0, 0, 0, 0},
            {89, 85, 65, 78, 0, 0}, {89, 85, 69, 0, 0, 0},
            {89, 85, 78, 0, 0, 0}, {74, 85, 78, 0, 0, 0},
            {89, 85, 78, 0, 0, 0}, {90, 65, 0, 0, 0, 0},
            {90, 65, 73, 0, 0, 0}, {90, 65, 78, 0, 0, 0},
            {90, 65, 78, 71, 0, 0}, {90, 65, 79, 0, 0, 0},
            {90, 69, 0, 0, 0, 0}, {90, 69, 73, 0, 0, 0},
            {90, 69, 78, 0, 0, 0}, {90, 69, 78, 71, 0, 0},
            {90, 72, 65, 0, 0, 0}, {90, 72, 65, 73, 0, 0},
            {90, 72, 65, 78, 0, 0}, {90, 72, 65, 78, 71, 0},
            {67, 72, 65, 78, 71, 0}, {90, 72, 65, 78, 71, 0},
            {90, 72, 65, 79, 0, 0}, {90, 72, 69, 0, 0, 0},
            {90, 72, 69, 78, 0, 0}, {90, 72, 69, 78, 71, 0},
            {90, 72, 73, 0, 0, 0}, {83, 72, 73, 0, 0, 0},
            {90, 72, 73, 0, 0, 0}, {90, 72, 79, 78, 71, 0},
            {90, 72, 79, 85, 0, 0}, {90, 72, 85, 0, 0, 0},
            {90, 72, 85, 65, 0, 0}, {90, 72, 85, 65, 73, 0},
            {90, 72, 85, 65, 78, 0}, {90, 72, 85, 65, 78, 71},
            {90, 72, 85, 73, 0, 0}, {90, 72, 85, 78, 0, 0},
            {90, 72, 85, 79, 0, 0}, {90, 73, 0, 0, 0, 0},
            {90, 79, 78, 71, 0, 0}, {90, 79, 85, 0, 0, 0},
            {90, 85, 0, 0, 0, 0}, {90, 85, 65, 78, 0, 0},
            {90, 85, 73, 0, 0, 0}, {90, 85, 78, 0, 0, 0},
            {90, 85, 79, 0, 0, 0}, {0, 0, 0, 0, 0, 0},
            {83, 72, 65, 78, 0, 0}, {0, 0, 0, 0, 0, 0},};

    /**
     * First and last Chinese character with known Pinyin according to zh collation
     */
    private static final String FIRST_PINYIN_UNIHAN = "\u963F";
    private static final String LAST_PINYIN_UNIHAN = "\u9FFF";

    private static final Collator COLLATOR = Collator.getInstance(Locale.CHINA);

    private static HanziToPinyin sInstance;
    private final boolean mHasChinaCollator;

    public static class Token {
        /**
         * Separator between target string for each source char
         */
        public static final String SEPARATOR = " ";

        public static final int LATIN = 1;
        public static final int PINYIN = 2;
        public static final int UNKNOWN = 3;

        public Token() {
        }

        public Token(int type, String source, String target) {
            this.type = type;
            this.source = source;
            this.target = target;
        }

        /**
         * Type of this token, ASCII, PINYIN or UNKNOWN.
         */
        public int type;
        /**
         * Original string before translation.
         */
        public String source;
        /**
         * Translated string of source. For Han, target is corresponding Pinyin. Otherwise target is
         * original string in source.
         */
        public String target;
    }

    protected HanziToPinyin(boolean hasChinaCollator) {
        mHasChinaCollator = hasChinaCollator;
    }

    public static HanziToPinyin getInstance() {
        synchronized (HanziToPinyin.class) {
            if (sInstance != null) {
                return sInstance;
            }
            // Check if zh_CN collation data is available
            final Locale locale[] = Collator.getAvailableLocales();
            for (int i = 0; i < locale.length; i++) {
                if (locale[i].equals(Locale.CHINA) || locale[i].getLanguage().contains("zh")) {
                    // Do self validation just once.
                    if (DEBUG) {
                        Log.d(TAG, "Self validation. Result: " + doSelfValidation());
                    }
                    sInstance = new HanziToPinyin(true);
                    return sInstance;
                }
            }
            if (sInstance == null){//这个判断是用于处理国产ROM的兼容性问题
                if (Locale.CHINA.equals(Locale.getDefault())){
                    sInstance = new HanziToPinyin(true);
                    return sInstance;
                }
            }
            Log.w(TAG, "There is no Chinese collator, HanziToPinyin is disabled");
            sInstance = new HanziToPinyin(false);
            return sInstance;
        }
    }

    /**
     * Validate if our internal table has some wrong value.
     *
     * @return true when the table looks correct.
     */
    private static boolean doSelfValidation() {
        char lastChar = UNIHANS[0];
        String lastString = Character.toString(lastChar);
        for (char c : UNIHANS) {
            if (lastChar == c) {
                continue;
            }
            final String curString = Character.toString(c);
            int cmp = COLLATOR.compare(lastString, curString);
            if (cmp >= 0) {
                Log.e(TAG, "Internal error in Unihan table. " + "The last string \"" + lastString
                        + "\" is greater than current string \"" + curString + "\".");
                return false;
            }
            lastString = curString;
        }
        return true;
    }

    private Token getToken(char character) {
        Token token = new Token();
        final String letter = Character.toString(character);
        token.source = letter;
        int offset = -1;
        int cmp;
        if (character < 256) {
            token.type = Token.LATIN;
            token.target = letter;
            return token;
        } else {
            cmp = COLLATOR.compare(letter, FIRST_PINYIN_UNIHAN);
            if (cmp < 0) {
                token.type = Token.UNKNOWN;
                token.target = letter;
                return token;
            } else if (cmp == 0) {
                token.type = Token.PINYIN;
                offset = 0;
            } else {
                cmp = COLLATOR.compare(letter, LAST_PINYIN_UNIHAN);
                if (cmp > 0) {
                    token.type = Token.UNKNOWN;
                    token.target = letter;
                    return token;
                } else if (cmp == 0) {
                    token.type = Token.PINYIN;
                    offset = UNIHANS.length - 1;
                }
            }
        }

        token.type = Token.PINYIN;
        if (offset < 0) {
            int begin = 0;
            int end = UNIHANS.length - 1;
            while (begin <= end) {
                offset = (begin + end) / 2;
                final String unihan = Character.toString(UNIHANS[offset]);
                cmp = COLLATOR.compare(letter, unihan);
                if (cmp == 0) {
                    break;
                } else if (cmp > 0) {
                    begin = offset + 1;
                } else {
                    end = offset - 1;
                }
            }
        }
        if (cmp < 0) {
            offset--;
        }
        StringBuilder pinyin = new StringBuilder();
        for (int j = 0; j < PINYINS[offset].length && PINYINS[offset][j] != 0; j++) {
            pinyin.append((char) PINYINS[offset][j]);
        }
        token.target = pinyin.toString();
        if (TextUtils.isEmpty(token.target)) {
            token.type = Token.UNKNOWN;
            token.target = token.source;
        }
        return token;
    }

    /**
     * Convert the input to a array of tokens. The sequence of ASCII or Unknown characters without
     * space will be put into a Token, One Hanzi character which has pinyin will be treated as a
     * Token. If these is no China collator, the empty token array is returned.
     */
    public ArrayList<Token> get(final String input) {
        ArrayList<Token> tokens = new ArrayList<Token>();
        if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
            // return empty tokens.
            return tokens;
        }
        final int inputLength = input.length();
        final StringBuilder sb = new StringBuilder();
        int tokenType = Token.LATIN;
        // Go through the input, create a new token when
        // a. Token type changed
        // b. Get the Pinyin of current charater.
        // c. current character is space.
        for (int i = 0; i < inputLength; i++) {
            final char character = input.charAt(i);
            if (character == ' ') {
                if (sb.length() > 0) {
                    addToken(sb, tokens, tokenType);
                }
            } else if (character < 256) {
                if (tokenType != Token.LATIN && sb.length() > 0) {
                    addToken(sb, tokens, tokenType);
                }
                tokenType = Token.LATIN;
                sb.append(character);
            } else {
                Token t = getToken(character);
                if (t.type == Token.PINYIN) {
                    if (sb.length() > 0) {
                        addToken(sb, tokens, tokenType);
                    }
                    tokens.add(t);
                    tokenType = Token.PINYIN;
                } else {
                    if (tokenType != t.type && sb.length() > 0) {
                        addToken(sb, tokens, tokenType);
                    }
                    tokenType = t.type;
                    sb.append(character);
                }
            }
        }
        if (sb.length() > 0) {
            addToken(sb, tokens, tokenType);
        }
        return tokens;
    }

    private void addToken(
            final StringBuilder sb, final ArrayList<Token> tokens, final int tokenType) {
        String str = sb.toString();
        tokens.add(new Token(tokenType, str, str));
        sb.setLength(0);
    }

    public String toPinyinString(String string) {
        if (string == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        ArrayList<Token> tokens = get(string);
        for (Token token : tokens) {
            sb.append(token.target);
        }
        return sb.toString().toLowerCase();
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/HyperlinkText.kt`:

```kt
package me.weishu.kernelsu.ui.util

import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.TextLayoutResult
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.style.TextDecoration
import java.util.regex.Pattern

@Composable
fun LinkifyText(
    text: String,
    modifier: Modifier = Modifier
) {
    val uriHandler = LocalUriHandler.current
    val layoutResult = remember {
        mutableStateOf<TextLayoutResult?>(null)
    }
    val linksList = extractUrls(text)
    val annotatedString = buildAnnotatedString {
        append(text)
        linksList.forEach {
            addStyle(
                style = SpanStyle(
                    color = MaterialTheme.colorScheme.primary,
                    textDecoration = TextDecoration.Underline
                ),
                start = it.start,
                end = it.end
            )
            addStringAnnotation(
                tag = "URL",
                annotation = it.url,
                start = it.start,
                end = it.end
            )
        }
    }
    Text(
        text = annotatedString,
        modifier = modifier.pointerInput(Unit) {
            detectTapGestures { offsetPosition ->
                layoutResult.value?.let {
                    val position = it.getOffsetForPosition(offsetPosition)
                    annotatedString.getStringAnnotations(position, position).firstOrNull()
                        ?.let { result ->
                            if (result.tag == "URL") {
                                uriHandler.openUri(result.item)
                            }
                        }
                }
            }
        },
        onTextLayout = { layoutResult.value = it }
    )
}

private val urlPattern: Pattern = Pattern.compile(
    "(?:^|[\\W])((ht|f)tp(s?):\\/\\/|www\\.)"
            + "(([\\w\\-]+\\.){1,}?([\\w\\-.~]+\\/?)*"
            + "[\\p{Alnum}.,%_=?&#\\-+()\\[\\]\\*$~@!:/{};']*)",
    Pattern.CASE_INSENSITIVE or Pattern.MULTILINE or Pattern.DOTALL
)

private data class LinkInfo(
    val url: String,
    val start: Int,
    val end: Int
)

private fun extractUrls(text: String): List<LinkInfo> = buildList {
    val matcher = urlPattern.matcher(text)
    while (matcher.find()) {
        val matchStart = matcher.start(1)
        val matchEnd = matcher.end()
        val url = text.substring(matchStart, matchEnd).replaceFirst("http://", "https://")
        add(LinkInfo(url, matchStart, matchEnd))
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/KsuCli.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.net.Uri
import android.os.SystemClock
import android.util.Log
import com.topjohnwu.superuser.CallbackList
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.ShellUtils
import me.weishu.kernelsu.BuildConfig
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import org.json.JSONArray
import java.io.File


/**
 * @author weishu
 * @date 2023/1/1.
 */
private const val TAG = "KsuCli"

private fun getKsuDaemonPath(): String {
    return ksuApp.applicationInfo.nativeLibraryDir + File.separator + "libksud.so"
}

object KsuCli {
    val SHELL: Shell = createRootShell()
}

fun getRootShell(): Shell {
    return KsuCli.SHELL
}

fun createRootShell(): Shell {
    Shell.enableVerboseLogging = BuildConfig.DEBUG
    val builder = Shell.Builder.create()
    return try {
        builder.build(getKsuDaemonPath(), "debug", "su")
    } catch (e: Throwable) {
        Log.e(TAG, "su failed: ", e)
        builder.build("sh")
    }
}

fun execKsud(args: String): Boolean {
    val shell = getRootShell()
    return ShellUtils.fastCmdResult(shell, "${getKsuDaemonPath()} $args")
}

fun install() {
    val start = SystemClock.elapsedRealtime()
    val result = execKsud("install")
    Log.w(TAG, "install result: $result, cost: ${SystemClock.elapsedRealtime() - start}ms")
}

fun listModules(): String {
    val shell = getRootShell()

    val out =
        shell.newJob().add("${getKsuDaemonPath()} module list").to(ArrayList(), null).exec().out
    return out.joinToString("\n").ifBlank { "[]" }
}

fun getModuleCount(): Int {
    val result = listModules()
    runCatching {
        val array = JSONArray(result)
        return array.length()
    }.getOrElse { return 0 }
}

fun getSuperuserCount(): Int {
    return Natives.allowList.size
}

fun toggleModule(id: String, enable: Boolean): Boolean {
    val cmd = if (enable) {
        "module enable $id"
    } else {
        "module disable $id"
    }
    val result = execKsud(cmd)
    Log.i(TAG, "$cmd result: $result")
    return result
}

fun uninstallModule(id: String): Boolean {
    val cmd = "module uninstall $id"
    val result = execKsud(cmd)
    Log.i(TAG, "uninstall module $id result: $result")
    return result
}

fun installModule(uri: Uri, onFinish: (Boolean) -> Unit, onStdout: (String) -> Unit, onStderr: (String) -> Unit): Boolean {
    val resolver = ksuApp.contentResolver
    with(resolver.openInputStream(uri)) {
        val file = File(ksuApp.cacheDir, "module.zip")
        file.outputStream().use { output ->
            this?.copyTo(output)
        }
        val cmd = "module install ${file.absolutePath}"

        val shell = getRootShell()

        val stdoutCallback: CallbackList<String?> = object : CallbackList<String?>() {
            override fun onAddElement(s: String?) {
                onStdout(s ?: "")
            }
        }

        val stderrCallback: CallbackList<String?> = object : CallbackList<String?>() {
            override fun onAddElement(s: String?) {
                onStderr(s ?: "")
            }
        }

        val result =
            shell.newJob().add("${getKsuDaemonPath()} $cmd").to(stdoutCallback, stderrCallback).exec()
        Log.i("KernelSU", "install module $uri result: $result")

        file.delete()

        onFinish(result.isSuccess)
        return result.isSuccess
    }
}

fun reboot(reason: String = "") {
    val shell = getRootShell()
    if (reason == "recovery") {
        // KEYCODE_POWER = 26, hide incorrect "Factory data reset" message
        ShellUtils.fastCmd(shell, "/system/bin/input keyevent 26")
    }
    ShellUtils.fastCmd(shell, "/system/bin/svc power reboot $reason || /system/bin/reboot $reason")
}

fun overlayFsAvailable(): Boolean {
    val shell = getRootShell()
    // check /proc/filesystems
    return ShellUtils.fastCmdResult(shell, "cat /proc/filesystems | grep overlay")
}

fun hasMagisk(): Boolean {
    val shell = getRootShell()
    val result = shell.newJob().add("nsenter --mount=/proc/1/ns/mnt which magisk").exec()
    Log.i(TAG, "has magisk: ${result.isSuccess}")
    return result.isSuccess
}

fun isSepolicyValid(rules: String?): Boolean {
    if (rules == null) {
        return true
    }
    val shell = getRootShell()
    val result =
        shell.newJob().add("${getKsuDaemonPath()} sepolicy check '$rules'").to(ArrayList(), null).exec()
    return result.isSuccess
}

fun getSepolicy(pkg: String): String {
    val shell = getRootShell()
    val result =
        shell.newJob().add("${getKsuDaemonPath()} profile get-sepolicy $pkg").to(ArrayList(), null).exec()
    Log.i(TAG, "code: ${result.code}, out: ${result.out}, err: ${result.err}")
    return result.out.joinToString("\n")
}

fun setSepolicy(pkg: String, rules: String): Boolean {
    val shell = getRootShell()
    val result =
        shell.newJob().add("${getKsuDaemonPath()} profile set-sepolicy $pkg '$rules'").to(ArrayList(), null).exec()
    Log.i(TAG, "set sepolicy result: ${result.code}")
    return result.isSuccess
}

fun forceStopApp(packageName: String) {
    val shell = getRootShell()
    val result = shell.newJob().add("am force-stop $packageName").exec()
    Log.i(TAG, "force stop $packageName result: $result")
}

fun launchApp(packageName: String) {

    val shell = getRootShell()
    val result = shell.newJob().add("monkey -p $packageName -c android.intent.category.LAUNCHER 1").exec()
    Log.i(TAG, "launch $packageName result: $result")
}

fun restartApp(packageName: String) {
    forceStopApp(packageName)
    launchApp(packageName)
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/LogEvent.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.content.Context
import android.os.Build
import android.system.Os
import com.topjohnwu.superuser.ShellUtils
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ui.screen.getManagerVersion
import java.io.File
import java.io.FileWriter
import java.io.PrintWriter
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

fun getBugreportFile(context: Context): File {

    val bugreportDir = File(context.cacheDir, "bugreport")
    bugreportDir.mkdirs()

    val dmesgFile = File(bugreportDir, "dmesg.txt")
    val logcatFile = File(bugreportDir, "logcat.txt")
    val tombstonesFile = File(bugreportDir, "tombstones.tar.gz")
    val dropboxFile = File(bugreportDir, "dropbox.tar.gz")
    val pstoreFile = File(bugreportDir, "pstore.tar.gz")
    val diagFile = File(bugreportDir, "diag.tar.gz")
    val bootlogFile = File(bugreportDir, "bootlog.tar.gz")
    val mountsFile = File(bugreportDir, "mounts.txt")
    val fileSystemsFile = File(bugreportDir, "filesystems.txt")
    val ksuFileTree = File(bugreportDir, "ksu_tree.txt")
    val appListFile = File(bugreportDir, "packages.txt")
    val propFile = File(bugreportDir, "props.txt")
    val allowListFile = File(bugreportDir, "allowlist.bin")

    val shell = getRootShell()

    shell.newJob().add("dmesg > ${dmesgFile.absolutePath}").exec()
    shell.newJob().add("logcat -d > ${logcatFile.absolutePath}").exec()
    shell.newJob().add("tar -czf ${tombstonesFile.absolutePath} -C /data/tombstones .").exec()
    shell.newJob().add("tar -czf ${dropboxFile.absolutePath} -C /data/system/dropbox .").exec()
    shell.newJob().add("tar -czf ${pstoreFile.absolutePath} -C /sys/fs/pstore .").exec()
    shell.newJob().add("tar -czf ${diagFile.absolutePath} -C /data/vendor/diag .").exec()
    shell.newJob().add("tar -czf ${bootlogFile.absolutePath} -C /data/adb/ksu/log .").exec()

    shell.newJob().add("cat /proc/1/mountinfo > ${mountsFile.absolutePath}").exec()
    shell.newJob().add("cat /proc/filesystems > ${fileSystemsFile.absolutePath}").exec()
    shell.newJob().add("ls -alRZ /data/adb > ${ksuFileTree.absolutePath}").exec()
    shell.newJob().add("cp /data/system/packages.list ${appListFile.absolutePath}").exec()
    shell.newJob().add("getprop > ${propFile.absolutePath}").exec()
    shell.newJob().add("cp /data/adb/ksu/.allowlist ${allowListFile.absolutePath}").exec()

    val selinux = ShellUtils.fastCmd(shell, "getenforce");

    // basic information
    val buildInfo = File(bugreportDir, "basic.txt")
    PrintWriter(FileWriter(buildInfo)).use { pw ->
        pw.println("Kernel: ${System.getProperty("os.version")}")
        pw.println("BRAND: " + Build.BRAND)
        pw.println("MODEL: " + Build.MODEL)
        pw.println("PRODUCT: " + Build.PRODUCT)
        pw.println("MANUFACTURER: " + Build.MANUFACTURER)
        pw.println("SDK: " + Build.VERSION.SDK_INT)
        pw.println("PREVIEW_SDK: " + Build.VERSION.PREVIEW_SDK_INT)
        pw.println("FINGERPRINT: " + Build.FINGERPRINT)
        pw.println("DEVICE: " + Build.DEVICE)
        pw.println("Manager: " + getManagerVersion(context))
        pw.println("SELinux: $selinux")

        val uname = Os.uname()
        pw.println("KernelRelease: ${uname.release}")
        pw.println("KernelVersion: ${uname.version}")
        pw.println("Mahcine: ${uname.machine}")
        pw.println("Nodename: ${uname.nodename}")
        pw.println("Sysname: ${uname.sysname}")

        val ksuKernel = Natives.version
        pw.println("KernelSU: $ksuKernel")
        val safeMode = Natives.isSafeMode
        pw.println("SafeMode: $safeMode")
    }

    // modules
    val modulesFile = File(bugreportDir, "modules.json")
    modulesFile.writeText(listModules())

    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH_mm")
    val current = LocalDateTime.now().format(formatter)

    val targetFile = File(context.cacheDir, "KernelSU_bugreport_${current}.tar.gz")

    shell.newJob().add("tar czf ${targetFile.absolutePath} -C ${bugreportDir.absolutePath} .").exec()
    shell.newJob().add("rm -rf ${bugreportDir.absolutePath}").exec()
    shell.newJob().add("chmod 0644 ${targetFile.absolutePath}").exec()

    return targetFile
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/SELinuxChecker.kt`:

```kt
package me.weishu.kernelsu.ui.util

import androidx.compose.ui.res.stringResource
import androidx.compose.runtime.Composable
import com.topjohnwu.superuser.Shell
import me.weishu.kernelsu.R

@Composable
fun getSELinuxStatus(): String {
    val shell = Shell.Builder.create()
        .setFlags(Shell.FLAG_REDIRECT_STDERR)
        .build("sh")

    val list = ArrayList<String>()
    val result = shell.newJob().add("getenforce").to(list, list).exec()
    val output = result.out.joinToString("\n").trim()

    if (result.isSuccess) {
        return when (output) {
            "Enforcing" -> stringResource(R.string.selinux_status_enforcing)
            "Permissive" -> stringResource(R.string.selinux_status_permissive)
            "Disabled" -> stringResource(R.string.selinux_status_disabled)
            else -> stringResource(R.string.selinux_status_unknown)
        }
    }

    return if (output.endsWith("Permission denied")) {
        stringResource(R.string.selinux_status_enforcing)
    } else {
        stringResource(R.string.selinux_status_unknown)
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/viewmodel/ModuleViewModel.kt`:

```kt
package me.weishu.kernelsu.ui.viewmodel

import android.net.Uri
import android.os.SystemClock
import android.util.Log
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import me.weishu.kernelsu.ui.util.listModules
import me.weishu.kernelsu.ui.util.overlayFsAvailable
import org.json.JSONArray
import org.json.JSONObject
import java.text.Collator
import java.util.*

class ModuleViewModel : ViewModel() {

    companion object {
        private const val TAG = "ModuleViewModel"
        private var modules by mutableStateOf<List<ModuleInfo>>(emptyList())
    }

    class ModuleInfo(
        val id: String,
        val name: String,
        val author: String,
        val version: String,
        val versionCode: Int,
        val description: String,
        val enabled: Boolean,
        val update: Boolean,
        val remove: Boolean,
        val updateJson: String,
    )

    data class ModuleUpdateInfo(
        val version: String,
        val versionCode: Int,
        val zipUrl: String,
        val changelog: String,
    )

    var isRefreshing by mutableStateOf(false)
        private set

    var isOverlayAvailable by mutableStateOf(overlayFsAvailable())
        private set

    val moduleList by derivedStateOf {
        val comparator = compareBy(Collator.getInstance(Locale.getDefault()), ModuleInfo::id)
        modules.sortedWith(comparator).also {
            isRefreshing = false
        }
    }

    var isNeedRefresh by mutableStateOf(false)
        private set

    fun markNeedRefresh() {
        isNeedRefresh = true
    }

    fun fetchModuleList() {
        viewModelScope.launch(Dispatchers.IO) {
            isRefreshing = true

            val oldModuleList = modules

            val start = SystemClock.elapsedRealtime()

            kotlin.runCatching {
                isOverlayAvailable = overlayFsAvailable()

                val result = listModules()

                Log.i(TAG, "result: $result")

                val array = JSONArray(result)
                modules = (0 until array.length())
                    .asSequence()
                    .map { array.getJSONObject(it) }
                    .map { obj ->
                        ModuleInfo(
                            obj.getString("id"),

                            obj.optString("name"),
                            obj.optString("author", "Unknown"),
                            obj.optString("version", "Unknown"),
                            obj.optInt("versionCode", 0),
                            obj.optString("description"),
                            obj.getBoolean("enabled"),
                            obj.getBoolean("update"),
                            obj.getBoolean("remove"),
                            obj.optString("updateJson")
                        )
                    }.toList()
                isNeedRefresh = false
            }.onFailure { e ->
                Log.e(TAG, "fetchModuleList: ", e)
                isRefreshing = false
            }

            // when both old and new is kotlin.collections.EmptyList
            // moduleList update will don't trigger
            if (oldModuleList === modules) {
                isRefreshing = false
            }

            Log.i(TAG, "load cost: ${SystemClock.elapsedRealtime() - start}, modules: $modules")
        }
    }

    fun checkUpdate(m: ModuleInfo, callback: (String?) -> Unit) {
        if (m.updateJson.isEmpty() || m.remove || m.update || !m.enabled) {
            callback(null)
            return
        }
        viewModelScope.launch(Dispatchers.IO) {
            // download updateJson
            val result = kotlin.runCatching {
                val url = m.updateJson
                Log.i(TAG, "checkUpdate url: $url")
                val response = okhttp3.OkHttpClient()
                    .newCall(
                    okhttp3.Request.Builder()
                        .url(url)
                        .build()
                ).execute()
                Log.d(TAG, "checkUpdate code: ${response.code}")
                if (response.isSuccessful) {
                    response.body?.string() ?: ""
                } else {
                    ""
                }
            }.getOrDefault("")
            Log.i(TAG, "checkUpdate result: $result")

            if (result.isEmpty()) {
                callback(null)
                return@launch
            }

            val updateJson = kotlin.runCatching {
                JSONObject(result)
            }.getOrNull()

            if (updateJson == null) {
                callback(null)
                return@launch
            }

            val version = updateJson.optString("version", "")
            val versionCode = updateJson.optInt("versionCode", 0)
            val zipUrl = updateJson.optString("zipUrl", "")
            val changelog = updateJson.optString("changelog", "")
            if (versionCode <= m.versionCode || zipUrl.isEmpty()) {
                callback(null)
                return@launch
            }

            callback(zipUrl)
        }
    }

}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/viewmodel/SuperUserViewModel.kt`:

```kt
package me.weishu.kernelsu.ui.viewmodel

import android.content.ComponentName
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.ApplicationInfo
import android.content.pm.PackageInfo
import android.os.IBinder
import android.os.Parcelable
import android.os.SystemClock
import android.util.Log
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.IKsuInterface
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.KsuService
import me.weishu.kernelsu.ui.util.HanziToPinyin
import me.weishu.kernelsu.ui.util.KsuCli
import java.text.Collator
import java.util.*
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

class SuperUserViewModel : ViewModel() {

    companion object {
        private const val TAG = "SuperUserViewModel"
        private var apps by mutableStateOf<List<AppInfo>>(emptyList())
    }

    @Parcelize
    data class AppInfo(
        val label: String,
        val packageInfo: PackageInfo,
        val profile: Natives.Profile?,
    ) : Parcelable {
        val packageName: String
            get() = packageInfo.packageName
        val uid: Int
            get() = packageInfo.applicationInfo.uid

        val allowSu: Boolean
            get() = profile != null && profile.allowSu
        val hasCustomProfile: Boolean
            get() {
                if (profile == null) {
                    return false
                }

                return if (profile.allowSu) {
                    !profile.rootUseDefault
                } else {
                    !profile.nonRootUseDefault
                }
            }
    }

    var search by mutableStateOf("")
    var showSystemApps by mutableStateOf(false)
    var isRefreshing by mutableStateOf(false)
        private set

    private val sortedList by derivedStateOf {
        val comparator = compareBy<AppInfo> {
            when {
                it.allowSu -> 0
                it.hasCustomProfile -> 1
                else -> 2
            }
        }.then(compareBy(Collator.getInstance(Locale.getDefault()), AppInfo::label))
        apps.sortedWith(comparator).also {
            isRefreshing = false
        }
    }

    val appList by derivedStateOf {
        sortedList.filter {
            it.label.contains(search) || it.packageName.contains(search) || HanziToPinyin.getInstance()
                .toPinyinString(it.label).contains(search)
        }.filter {
            it.uid == 2000 // Always show shell
                    || showSystemApps || it.packageInfo.applicationInfo.flags.and(ApplicationInfo.FLAG_SYSTEM) == 0
        }
    }

    private suspend inline fun connectKsuService(
        crossinline onDisconnect: () -> Unit = {}
    ): Pair<IBinder, ServiceConnection> = suspendCoroutine {
        val connection = object : ServiceConnection {
            override fun onServiceDisconnected(name: ComponentName?) {
                onDisconnect()
            }

            override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
                it.resume(binder as IBinder to this)
            }
        }

        val intent = Intent(ksuApp, KsuService::class.java);

        val task = KsuService.bindOrTask(
            intent,
            Shell.EXECUTOR,
            connection,
        )
        val shell = KsuCli.SHELL
        task?.let { it1 -> shell.execTask(it1) }
    }

    private fun stopKsuService() {
        val intent = Intent(ksuApp, KsuService::class.java);
        KsuService.stop(intent)
    }

    suspend fun fetchAppList() {

        isRefreshing = true

        val result = connectKsuService {
            Log.w(TAG, "KsuService disconnected")
        }

        withContext(Dispatchers.IO) {
            val pm = ksuApp.packageManager
            val start = SystemClock.elapsedRealtime()

            val binder = result.first
            val allPackages = IKsuInterface.Stub.asInterface(binder).getPackages(0)

            withContext(Dispatchers.Main) {
                stopKsuService()
            }

            val packages = allPackages.list

            apps = packages.map {
                val appInfo = it.applicationInfo
                val uid = appInfo.uid
                val profile = Natives.getAppProfile(it.packageName, uid)
                AppInfo(
                    label = appInfo.loadLabel(pm).toString(),
                    packageInfo = it,
                    profile = profile,
                )
            }.filter { it.packageName != ksuApp.packageName }
            Log.i(TAG, "load cost: ${SystemClock.elapsedRealtime() - start}")
        }
    }
}

```

`manager/app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">

    <group
        android:scaleX="0.135"
        android:scaleY="0.135">
        <path
            android:fillColor="#ffffff"
            android:pathData="M 0 0 H 800 V 800 H 0 V 0 Z" />
    </group>
</vector>
```

`manager/app/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">

    <group
        android:scaleX="0.135"
        android:scaleY="0.135">
        <path
            android:pathData="M 259 259 H 541 V 541 H 259 V 259 Z"
            android:strokeWidth="18"
            android:strokeColor="#1e110d" />
        <path
            android:fillColor="#1e110d"
            android:pathData="M 257 257 H 407 V 407 H 257 V 257 Z" />
        <path
            android:fillColor="#1e110d"
            android:pathData="M 393 393 H 543 V 543 H 393 V 393 Z" />
    </group>
</vector>
```

`manager/app/src/main/res/drawable/ic_launcher_monochrome.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">

    <group
        android:scaleX="0.135"
        android:scaleY="0.135">
        <path
            android:pathData="M 259 259 H 541 V 541 H 259 V 259 Z"
            android:strokeWidth="18"
            android:strokeColor="#000000" />
        <path
            android:fillColor="#000000"
            android:pathData="M 257 257 H 407 V 407 H 257 V 257 Z" />
        <path
            android:fillColor="#000000"
            android:pathData="M 393 393 H 543 V 543 H 393 V 393 Z" />
    </group>
</vector>
```

`manager/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_monochrome" />
</adaptive-icon>
```

`manager/app/src/main/res/values-ar/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">الرئيسية</string>
    <string name="home_not_installed">غير مثبت</string>
    <string name="home_click_to_install">إضغط للتثبيت</string>
    <string name="home_working">يعمل</string>
    <string name="home_working_version">الإصدار: %d</string>
    <string name="home_superuser_count">مستخدمين الجذر: %d</string>
    <string name="home_module_count">الوحدات: %d</string>
    <string name="home_unsupported">غير مدعوم</string>
    <string name="home_unsupported_reason">KernelSU يدعم GKI kernels فقط</string>
    <string name="home_kernel">إصدار النواة</string>
    <string name="home_manager_version">إصدار المدير</string>
    <string name="home_fingerprint">البصمة</string>
    <string name="home_selinux_status">وضع SELinux</string>
    <string name="selinux_status_disabled">غير مفعل</string>
    <string name="selinux_status_enforcing">مفروض</string>
    <string name="selinux_status_permissive">متساهل</string>
    <string name="selinux_status_unknown">مجهول</string>
    <string name="superuser">مستخدم خارق</string>
    <string name="module_failed_to_enable">فشل في تمكين الوحدة: %s</string>
    <string name="module_failed_to_disable">فشل تعطيل الوحدة : %s</string>
    <string name="module_empty">لا توجد وحدة مثبتة</string>
    <string name="module">وحدة</string>
    <string name="uninstall">إلغاء التثبيت</string>
    <string name="module_install">تثبيت الوحدة</string>
    <string name="install">تثبيت</string>
    <string name="reboot">إعادة تشغيل</string>
    <string name="settings">الإعدادات</string>
    <string name="reboot_userspace">إعادة تشغيل سريعة</string>
    <string name="reboot_recovery">إعادة تشغيل إلى وضع Recovery</string>
    <string name="reboot_bootloader">إعادة تشغيل إلى وضع Bootloader</string>
    <string name="reboot_download">إعادة تشغيل إلى وضع Download</string>
    <string name="reboot_edl">إعادة تشغيل إلى وضع EDL</string>
    <string name="about">من نحن</string>
    <string name="module_uninstall_confirm">هل أنت متأكد أنك تريد إلغاء تثبيت الوحدة  %s ?</string>
    <string name="module_uninstall_success">تم إلغاء التثبيت %s</string>
    <string name="module_uninstall_failed">فشل إلغاء التثبيت: %s</string>
    <string name="module_version">الإصدار</string>
    <string name="module_author">المطور</string>
    <string name="module_overlay_fs_not_available">التراكبات غير متوفرة ، لا يمكن للوحدة أن تعمل!</string>
    <string name="refresh">إنعاش</string>
    <string name="show_system_apps">إظهار تطبيقات النظام</string>
    <string name="hide_system_apps">إخفاء تطبيقات النظام</string>
    <string name="send_log">إرسال السجلات</string>
    <string name="safe_mode">الوضع الآمن</string>
    <string name="reboot_to_apply">إعادة التشغيل لتطبيق التغييرات</string>
    <string name="module_magisk_conflict">تم تعطيل الوحدات النمطية لأنها تتعارض مع Magisk!</string>
    <string name="home_learn_kernelsu">تعلم KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">تعرف على كيفية تثبيت KernelSU واستخدام الوحدات</string>
    <string name="home_support_title">إدعمنا</string>
    <string name="home_support_content">KernelSU سيظل دائماً مجانياً ومفتوح المصدر. مع ذلك، يمكنك أن تظهر لنا أنك تهتم بالتبرع.</string>
    <string name="about_source_code"><![CDATA[أنظر إلى مصدر البرمجة في %1$s<br/>إنضم إلى قناتنا في %2$s ]]></string>
    <string name="profile_capabilities">القدرات</string>
    <string name="module_update">تحديث</string>
    <string name="module_downloading">تحمبل الوحدة : %s</string>
    <string name="module_start_downloading">ابدأ التنزيل: %s</string>
    <string name="new_version_available">الإصدار الجديد: %s متاح ، انقر للتنزيل</string>
    <string name="launch_app">تشغيل</string>
    <string name="profile_default">الإفتراضي</string>
    <string name="profile_template">نموذج</string>
    <string name="profile_namespace_inherited">موروث</string>
    <string name="profile_namespace_global">عالمي</string>
    <string name="profile_namespace_individual">فردي</string>
    <string name="profile_groups">مجموعات</string>
    <string name="profile_custom">مُخصّص</string>
    <string name="profile_namespace">تركيب مساحة الاسم</string>
    <string name="profile_umount_modules">الغاء تحميل الوحدات</string>
    <string name="failed_to_update_app_profile">فشل تحديث ملف تعريف التطبيق لـ %s</string>
    <string name="profile_selinux_context">سياق SELinux</string>
    <string name="force_stop_app">ايقاف إجباري</string>
    <string name="settings_umount_modules_default">الغاء تحميل الوحدات بشكل افتراضي</string>
    <string name="settings_umount_modules_default_summary">القيمة الافتراضية العامة ل \"إلغاء تحميل الوحدات \" في ملفات تعريف التطبيقات. إذا تم تمكينه ، إزالة جميع تعديلات الوحدة النمطية على النظام للتطبيقات التي لا تحتوي على مجموعة ملف تعريف.</string>
    <string name="profile_umount_modules_summary">سيسمح تمكين هذا الخيار ل KernelSU باستعادة أي ملفات معدلة بواسطة الوحدات النمطية لهذا التطبيق.</string>
    <string name="profile_selinux_domain">المجال</string>
    <string name="profile_selinux_rules">القواعد</string>
    <string name="restart_app">إعادة تشغيل التطبيق</string>
    <string name="failed_to_update_sepolicy">فشل تحديث قواعد SELinux لما يلي: %s</string>
    <string name="profile_name">اسم الملف الشخصي</string>
    <string name="require_kernel_version">إصدار KernelSU الحالي %d منخفض جدًا بحيث لا يعمل المدير بشكل صحيح. الرجاء الترقية إلى الإصدار %d أو أعلى!</string>
</resources>
```

`manager/app/src/main/res/values-az/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Ana səhifə</string>
    <string name="home_superuser_count">Super istifadəçilər: %d</string>
    <string name="home_kernel">Nüvə</string>
    <string name="home_not_installed">Yüklənmədi</string>
    <string name="home_click_to_install">Yükləmək üçün toxunun</string>
    <string name="home_working">İşləyir</string>
    <string name="home_working_version">Versiya: %d</string>
    <string name="home_module_count">Modullar: %d</string>
    <string name="home_unsupported_reason">Hal-hazırda KernelSU yalnız GKI nüvələrini dəstəkləyir</string>
    <string name="home_unsupported">Dəstəklənmir</string>
    <string name="module_install">Yüklə</string>
    <string name="install">Yüklə</string>
    <string name="selinux_status_unknown">Naməlum</string>
    <string name="home_fingerprint">Barmaq izi</string>
    <string name="home_manager_version">Menecer versiyası</string>
    <string name="selinux_status_disabled">Qeyri-aktiv</string>
    <string name="home_selinux_status">SELinux vəziyyəti</string>
    <string name="selinux_status_permissive">Sərbəst</string>
    <string name="selinux_status_enforcing">Məcburi</string>
    <string name="superuser">Super istifadəçi</string>
    <string name="uninstall">Sil</string>
    <string name="module_failed_to_enable">Modulu aktiv etmək mümkün olmadı: %s</string>
    <string name="module_failed_to_disable">Modulu deaktiv etmək mümkün olmadı: %s</string>
    <string name="module_empty">Heç bir modul quraşdırılmayıb</string>
    <string name="module">Modul</string>
    <string name="reboot">Yenidən başlat</string>
    <string name="settings">Parametrlər</string>
    <string name="reboot_recovery">Bərpa rejimində yenidən başlat</string>
    <string name="reboot_userspace">Yüngül vəziyyətdə yenodən başlat</string>
    <string name="reboot_bootloader">Bootloader rejimində yenidən başlat</string>
    <string name="reboot_download">Yükləmə rejimində yenidən başlat</string>
    <string name="module_version">Versiya</string>
    <string name="module_author">Sahib</string>
    <string name="module_uninstall_confirm">Modulu silmək istədiyinizdən əminsiniz %s\?</string>
    <string name="show_system_apps">Sistem proqramlarını göstər</string>
    <string name="about">Haqqında</string>
    <string name="reboot_edl">EDL rejimində yenidən başlat</string>
    <string name="module_uninstall_failed">Silmək mümkün olmadı: %s</string>
    <string name="module_uninstall_success">%s silindi</string>
    <string name="hide_system_apps">Sistem proqramlarını gizlət</string>
    <string name="module_overlay_fs_not_available">overlayfs mövcud deyil,modul işləyə bilməyəcək!</string>
    <string name="send_log">Log-u göndər</string>
    <string name="refresh">Yenilə</string>
    <string name="safe_mode">Təhlükəsiz rejimi</string>
    <string name="reboot_to_apply">Qüvvəyə minməsi üçün yenidən başlat</string>
    <string name="module_magisk_conflict">Modular deaktiv edilir,çünki o Magisk-in modulları ilə toqquşur!</string>
    <string name="home_learn_kernelsu">KernelSU-yu öyrən</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_support_title">Bizi dəstəkləyin</string>
    <string name="home_click_to_learn_kernelsu">KernelSU-yu necə quraşdırılacağını və modulların necə istifadə ediləcəyini öyrən</string>
    <string name="profile_template">Şablon</string>
    <string name="profile_default">Defolt</string>
    <string name="profile_custom">Özəl</string>
    <string name="home_support_content">KernelSU pulsuz və açıq mənbəlidir,həmişə belə olacaqdır. Bununla belə, ianə etməklə bizə qayğı göstərdiyinizi göstərə bilərsiniz.</string>
    <string name="about_source_code">Mənbə kodlarımıza baxın %1$s<br/>Kanalımıza %2$s qoşulun</string>
    <string name="profile_name">Profil adı</string>
    <string name="profile_capabilities">Bacarıqlar</string>
    <string name="profile_umount_modules">Modulları umount et</string>
    <string name="profile_namespace_inherited">Miras qalmış</string>
    <string name="profile_namespace_global">Qlobal</string>
    <string name="profile_namespace">Bölmənin ad sahəsi</string>
    <string name="profile_namespace_individual">Fərdi</string>
    <string name="profile_groups">Qruplar</string>
    <string name="settings_umount_modules_default">Defolt olaraq modulları umount et</string>
    <string name="profile_selinux_context">SELinux konteksi</string>
    <string name="failed_to_update_app_profile">%s görə tətbiq profillərini güncəlləmək mümkün olmadı</string>
    <string name="settings_umount_modules_default_summary">Tətbiq Profillərində \"Umount modulları\" üçün qlobal standart dəyər. Aktivləşdirilərsə, o, Profil dəsti olmayan proqramlar üçün sistemdəki bütün modul dəyişikliklərini siləcək.</string>
    <string name="profile_selinux_domain">Domen</string>
    <string name="profile_selinux_rules">Qaydalar</string>
    <string name="module_update">Güncəllə</string>
    <string name="module_start_downloading">Endirməni başlat: %s</string>
    <string name="new_version_available">Yeni versiya: %s əlçatandır, endirmək üçün toxunun</string>
    <string name="module_downloading">Modul yüklənir: %s</string>
    <string name="profile_umount_modules_summary">Bu seçimi aktivləşdirmək KernelSU-ya bu proqram üçün modullar tərəfindən hər hansı dəyişdirilmiş faylları bərpa etməyə imkan verəcək.</string>
    <string name="launch_app">Aç</string>
    <string name="force_stop_app">Məcburi dayandır</string>
    <string name="restart_app">Yenidən başlat</string>
    <string name="failed_to_update_sepolicy">%s görə SELinux qaydalarını güncəlləmək mümkün olmadı</string>
</resources>
```

`manager/app/src/main/res/values-bn-rBD/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_unsupported_reason">কর্নেল এস ইউ কেবল মাত্র জিকআই কর্নেল সাপোর্ট করে</string>
    <string name="home_selinux_status">এসইলিনাক্স স্টেটাস</string>
    <string name="selinux_status_unknown">আননোন</string>
    <string name="module_failed_to_enable">মোডিউল ইনেবল করা যায়নি: %s</string>
    <string name="home_click_to_install">ইন্সটল করটে চাপুন</string>
    <string name="home_working">কাজ করছে</string>
    <string name="home_module_count">মোডিউল: %d</string>
    <string name="home_unsupported">অমূলক</string>
    <string name="home_kernel">কর্নেল</string>
    <string name="home_manager_version">ম্যানেজার ভারসন</string>
    <string name="home_fingerprint">ফিঙ্গারপ্রিন্ট</string>
    <string name="selinux_status_disabled">ডিসেবল</string>
    <string name="selinux_status_enforcing">এনফোর্সিং</string>
    <string name="superuser">সুপার ইউজার</string>
    <string name="module">মোডিউল</string>
    <string name="uninstall">আনইন্সটল</string>
    <string name="module_install">ইন্সটল</string>
    <string name="install">ইন্সটল</string>
    <string name="reboot">রিবুট</string>
    <string name="settings">সেটিংস</string>
    <string name="reboot_userspace">সফট রিবুট</string>
    <string name="profile_namespace_global">গ্লোবাল</string>
    <string name="profile_groups">গ্রুপস</string>
    <string name="profile_selinux_context">এসইলিনাক্স কন্টেক্সট</string>
    <string name="failed_to_update_app_profile">%s এর জন্য অ্যাপ প্রফাইল আপডেট করা যায়নি</string>
    <string name="settings_umount_modules_default">বাইডিফল্ট মোডিউল আনমাউন্ট</string>
    <string name="home">হোম</string>
    <string name="home_not_installed">ইন্সটল হয়নী</string>
    <string name="selinux_status_permissive">পারমিসিভ</string>
    <string name="module_failed_to_disable">মোডিউল ডিসেবল করা যায়নি: %s</string>
    <string name="module_empty">কোনো মোডিউল ইন্সটল করা নেই</string>
    <string name="home_working_version">ভারসন: %d</string>
    <string name="home_superuser_count">সুপার ইউজার: %d</string>
    <string name="profile_namespace">নেইম স্পেস মাউন্ট</string>
    <string name="profile_namespace_inherited">ইনহেরিটেড</string>
    <string name="profile_namespace_individual">ইন্ডিভিজুয়াল</string>
    <string name="profile_capabilities">ক্যাপাবিলিটিস</string>
    <string name="profile_umount_modules">আনমাউন্ট মোডিউলস</string>
    <string name="reboot_recovery">রিকভারিতে বুট</string>
    <string name="reboot_bootloader">বুটলোডারে বুট</string>
    <string name="reboot_download">ডাউনলোড মডে বুট</string>
    <string name="reboot_edl">ইমারজেন্সি ডাউনলোড মডে বুট</string>
    <string name="about">অ্যাবাউট</string>
    <string name="module_uninstall_confirm">%s মোডিউল আনইনস্টলের বেপারে নিশ্চিৎ\?</string>
    <string name="module_uninstall_success">%s আনইনস্টলড</string>
    <string name="module_uninstall_failed">%s আনইনস্টল করা যায়নি</string>
    <string name="module_version">ভার্সন</string>
    <string name="module_author">অথার</string>
</resources>
```

`manager/app/src/main/res/values-bn/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">হোম</string>
    <string name="home_not_installed">ইনস্টল করা হয়নি</string>
    <string name="home_click_to_install">ইনস্টল করার জন্য ক্লিক করুন</string>
    <string name="home_working"> ওয়ার্কিং</string>
    <string name="home_working_version">ওয়ার্কিং সংস্করণ: %d</string>
    <string name="home_superuser_count">সুপার ইউজার: %d</string>
    <string name="home_module_count">মডিউল: %d</string>
    <string name="home_unsupported">অসমর্থিত</string>
    <string name="home_unsupported_reason">কার্নেলএসইউ শুধুমাত্র জিকেআই কার্নেল সমর্থন করে</string>

    <string name="home_kernel">কার্নেল</string>
    <string name="home_manager_version">ম্যানেজার সংস্করণ</string>
    <string name="home_fingerprint">ফিঙ্গারপ্রিন্ট</string>

    <string name="home_selinux_status">সেলিনাক্স স্ট্যাটাস</string>
    <string name="selinux_status_disabled">ডিজেবল</string>
    <string name="selinux_status_enforcing">এনফোর্সিং</string>
    <string name="selinux_status_permissive">অনুমতিমূলক</string>
    <string name="selinux_status_unknown">অপরিচিত</string>
    <string name="superuser">সুপার ইউজার</string>
    <string name="module_failed_to_enable">মডিউল সক্ষম করতে ব্যর্থ হয়েছে: %s</string>
    <string name="module_failed_to_disable">মডিউল নিষ্ক্রিয় করতে ব্যর্থ হয়েছে: %s</string>
    <string name="module_empty">কোন মডিউল ইনস্টল করা নেই</string>

    <string name="module">মডিউল</string>
    <string name="uninstall">আনইন্সটল</string>
    <string name="module_install">মডিউল ইনস্টল</string>
    <string name="install">ইনস্টল</string>
    <string name="reboot">রিবুট</string>
    <string name="settings">সেটিংস</string>
    <string name="reboot_userspace">সফট রিবুট</string>
    <string name="reboot_recovery">রিবুট রিকোভারি</string>
    <string name="reboot_bootloader">রিবুট বুটলোডার</string>
    <string name="reboot_download">রিবুট ডাউনলোড</string>
    <string name="reboot_edl">রিবুট ইডিএল</string>
    <string name="about">এবাউট</string>
    <string name="module_uninstall_confirm">মডিউল আনইনস্টল নিশ্চিত করুন %s?</string>
    <string name="module_uninstall_success">%s আনইনস্টল সফল</string>
    <string name="module_uninstall_failed">আনইন্সটল ব্যর্থ: %s</string>
    <string name="module_version">ভার্সন</string>
    <string name="module_author">লেখক</string>
    <string name="module_overlay_fs_not_available">ওভারলেএফএস উপলব্ধ নয়, মডিউল কাজ করতে পারে না!</string>
    <string name="refresh">রিফ্রেশ</string>
    <string name="show_system_apps">শো সিস্টেম অ্যাপস</string>
    <string name="hide_system_apps">হাইড সিস্টেম অ্যাপস</string>
    <string name="send_log">সেন্ড লগ</string>
    <string name="safe_mode">সেইফ মোড</string>
    <string name="reboot_to_apply">রিবুট এপ্লাই</string>
    <string name="module_magisk_conflict">মডিউলগুলি অক্ষম কারণ তারা ম্যাজিস্কের সাথে বিরোধিতা করে!</string>
    <string name="home_learn_kernelsu">লার্ন কার্নেলএসইউ</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">কিভাবে কার্নেলএসইউ ইনস্টল করতে হয় এবং মডিউল ব্যবহার করতে হয় তা শিখুন</string>
    <string name="home_support_title">সাপোর্ট টাইটেল</string>
    <string name="home_support_content">কার্নেলএসইউ বিনামূল্যে এবং ওপেন সোর্স, এবং সবসময় থাকবে। আপনি সবসময় একটি অনুদান দিয়ে আপনার কৃতজ্ঞতা প্রদর্শন করতে পারেন.</string>
    <string name="about_source_code"><![CDATA[Bekijk source code op %1$s<br/>আমাদের %2$s চ্যানেল মার্জ করুন]]></string>
</resources>

```

`manager/app/src/main/res/values-da/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_working">Arbejder</string>
    <string name="home_module_count">Moduler: %d</string>
    <string name="home_unsupported">Ikke understøttet</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_unsupported_reason">KernelSU understøtter kun GKI kernels</string>
    <string name="home_manager_version">Manager Version</string>
    <string name="home_selinux_status">SELinux-status</string>
    <string name="selinux_status_disabled">Deaktiveret</string>
    <string name="selinux_status_permissive">Tilladende</string>
    <string name="superuser">Superbruger</string>
    <string name="selinux_status_enforcing">Håndhævende</string>
    <string name="module_failed_to_disable">Deaktivering af modul fejlede: %s</string>
    <string name="module_empty">Intet modul installeret</string>
    <string name="uninstall">Afinstaller</string>
    <string name="module_install">Installer</string>
    <string name="install">Installer</string>
    <string name="reboot">Genstart</string>
    <string name="settings">Indstillinger</string>
    <string name="reboot_userspace">Blød Genstart</string>
    <string name="reboot_download">Genstart til Download</string>
    <string name="reboot_edl">Genstart til EDL</string>
    <string name="about">Om</string>
    <string name="module_uninstall_confirm">Er du sikker på, at du vil afinstallere modulet %s\?</string>
    <string name="module_uninstall_success">%s afinstalleret</string>
    <string name="module_uninstall_failed">Afinstallation af: %s fejlede</string>
    <string name="module_overlay_fs_not_available">overlayfs er ikke tilgængeligt, modulet kan ikke fungere!</string>
    <string name="refresh">Opdater</string>
    <string name="send_log">Send Log</string>
    <string name="safe_mode">Sikker tilstand</string>
    <string name="reboot_to_apply">Genstart for at tage effekt</string>
    <string name="home_learn_kernelsu">Lær KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Lær hvordan man installerer KernelSU og moduler</string>
    <string name="about_source_code">Se source koden ved %1$s<br/>Deltage i vores %2$s kanal</string>
    <string name="profile_default">Standard</string>
    <string name="profile_template">Skabelon</string>
    <string name="profile_namespace">Monter navnerum</string>
    <string name="profile_namespace_inherited">Arvet</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_groups">Grupper</string>
    <string name="profile_capabilities">Evner</string>
    <string name="profile_selinux_context">SELinux-kontext</string>
    <string name="profile_umount_modules">Afmonteret moduler</string>
    <string name="settings_umount_modules_default">Afmontere moduler som standard</string>
    <string name="profile_umount_modules_summary">Aktivering af denne indstilling vil tillade KernelSU at gendanne hvilken som helst modificeret filer af modulet for denne applikation.</string>
    <string name="module_update">Opdatering</string>
    <string name="module_downloading">Downloader modulet: %s</string>
    <string name="new_version_available">Ny version: %s er tilgængelig, kilk for at downloade</string>
    <string name="launch_app">Start</string>
    <string name="force_stop_app">Tving Stop</string>
    <string name="failed_to_update_sepolicy">Opdatering af SELinux-regler for: %s fejlede</string>
    <string name="module_start_downloading">Start download: %s</string>
    <string name="home_click_to_install">Klik for at installere</string>
    <string name="home_working_version">Version: %d</string>
    <string name="home">Hjem</string>
    <string name="home_not_installed">Ikke installeret</string>
    <string name="home_superuser_count">Superbrugere: %d</string>
    <string name="home_fingerprint">Fingeraftryk</string>
    <string name="selinux_status_unknown">Ukendt</string>
    <string name="module_failed_to_enable">Aktivering af modul fejlede: %s</string>
    <string name="reboot_recovery">Genstart til Recovery</string>
    <string name="module">Modul</string>
    <string name="module_author">Forfatter</string>
    <string name="reboot_bootloader">Genstart til Bootloader</string>
    <string name="module_version">Version</string>
    <string name="hide_system_apps">Gem system-apps</string>
    <string name="show_system_apps">Vis system-apps</string>
    <string name="module_magisk_conflict">Moduler er deaktiveret, fordi der er konflikt med Magiskes!</string>
    <string name="home_support_title">Støt Os</string>
    <string name="home_support_content">KernelSU er, og vil altid være gratis og open source. Du kan stadig vise os din støtte ved at donere.</string>
    <string name="profile_custom">Brugerdefineret</string>
    <string name="profile_name">Profilnavn</string>
    <string name="profile_namespace_individual">Individuel</string>
    <string name="failed_to_update_app_profile">Opdatering af App Profil for %s fejlede</string>
    <string name="settings_umount_modules_default_summary">Den globale standard værdi for \"Afmonter moduler\" i App Profiler. Hvis aktiveret vil den fjerne alle modulers modifikationer til system applikationerne der ikke har en sat Profil.</string>
    <string name="profile_selinux_domain">Domæne</string>
    <string name="profile_selinux_rules">Regler</string>
    <string name="restart_app">Genstart</string>
    <string name="require_kernel_version">Den nuværende KernelSU version %d er for lav til manageren for at fungere ordentligt. Opgrader til version %d eller højere!</string>
</resources>
```

`manager/app/src/main/res/values-de/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Startseite</string>
    <string name="home_not_installed">Nicht installiert</string>
    <string name="selinux_status_permissive">Permissiv</string>
    <string name="home_working">Funktioniert</string>
    <string name="home_working_version">Version: %d</string>
    <string name="superuser">Superuser</string>
    <string name="home_click_to_install">Klicken Sie zum Installieren</string>
    <string name="home_superuser_count">Superusers: %d</string>
    <string name="selinux_status_unknown">Unbekannt</string>
    <string name="selinux_status_enforcing">erzwingen</string>
    <string name="reboot_bootloader">Zum Bootloader-Modus neustarten</string>
    <string name="reboot_download">Zum Download-Modus neustarten</string>
    <string name="reboot_edl">Zum EDL-Modus neustarten</string>
    <string name="module_author">Autor</string>
    <string name="module_overlay_fs_not_available">overlayfs ist nicht verfügbar, Modul kann nicht funktionieren!</string>
    <string name="about">Über</string>
    <string name="module_magisk_conflict">Module sind deaktiviert, weil es einen Konflikt mit Magisks gibt!</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Erfahren Sie, wie Sie KernelSU installieren und Module verwenden</string>
    <string name="home_support_title">Unterstütze uns</string>
    <string name="home_support_content">"KernelSU ist und bleibt kostenlos und Open Source.  Sie können uns jedoch zeigen, dass Sie sich für uns interessieren, indem Sie eine Spende tätigen."</string>
    <string name="profile_selinux_context">SELinux-Kontext</string>
    <string name="settings_umount_modules_default">Demontiere Module als Standard</string>
    <string name="settings_umount_modules_default_summary">Der globale Standard-Wert für „Demontiere Module“ in App-Profilen. Falls aktiviert, werden alle Modul-Modifikationen zu dem System deaktiviert; für Applikationen, welche kein Profil gesetzt haben.</string>
    <string name="profile_default">Standard</string>
    <string name="profile_template">Vorlage</string>
    <string name="profile_custom">Benutzerdefiniert</string>
    <string name="failed_to_update_app_profile">Aktualisierung des App-Profils fehlgeschlagen für %s</string>
    <string name="profile_namespace_inherited">Übernommen</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individuell</string>
    <string name="profile_selinux_domain">Domain</string>
    <string name="module_update">Aktualisierung</string>
    <string name="profile_umount_modules_summary">Aktivierung dieser Option erlaubt KernelSU, alle modifizierten Dateien von den Modulen dieser Applikation wiederherstellen.</string>
    <string name="profile_selinux_rules">Regeln</string>
    <string name="module_start_downloading">Starte herunterladen: %s</string>
    <string name="failed_to_update_sepolicy">Aktualisierung der SELinux-Regeln fehlgeschlagen für: %s</string>
    <string name="launch_app">Start</string>
    <string name="new_version_available">Neue Version: %s ist verfügbar, klicke zum herunterladen</string>
    <string name="force_stop_app">Erzwinge Stopp</string>
    <string name="restart_app">Neustart</string>
    <string name="home_module_count">Module: %d</string>
    <string name="home_manager_version">Verwalter-Version</string>
    <string name="home_selinux_status">SELinux-Status</string>
    <string name="selinux_status_disabled">Deaktiviert</string>
    <string name="module_failed_to_enable">Modulaktivierung fehlgeschlagen: %s</string>
    <string name="module_failed_to_disable">Moduldeaktivierung fehlgeschlagen: %s</string>
    <string name="module_empty">Kein Modul installiert</string>
    <string name="module">Modul</string>
    <string name="uninstall">Deinstallieren</string>
    <string name="install">Installieren</string>
    <string name="reboot">Neustart</string>
    <string name="settings">Einstellungen</string>
    <string name="reboot_recovery">Neustart zur Recovery</string>
    <string name="module_uninstall_success">%s deinstalliert</string>
    <string name="module_version">Version</string>
    <string name="refresh">Neu laden</string>
    <string name="show_system_apps">Zeige System-Apps</string>
    <string name="hide_system_apps">Verstecke System-Apps</string>
    <string name="send_log">Sende Verlauf</string>
    <string name="home_learn_kernelsu">Lerne KernelSU</string>
    <string name="safe_mode">Sicherer Modus</string>
    <string name="reboot_to_apply">Starte neu, damit die Effekte auftreten</string>
    <string name="about_source_code">Sehe den Quellcode bei %1$s<br/>Trete unserem %2$s Kanal bei</string>
    <string name="profile_name">Profilname</string>
    <string name="profile_namespace">Montiere Namensraum</string>
    <string name="profile_groups">Gruppen</string>
    <string name="profile_capabilities">Fähigkeiten</string>
    <string name="profile_umount_modules">Demontiere Module</string>
    <string name="module_downloading">Lädt Modul herunter: %s</string>
    <string name="home_unsupported">Nicht unterstützt</string>
    <string name="home_unsupported_reason">KernelSU unterstützt nun nur GKI kernels</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_fingerprint">Fingerabdruck</string>
    <string name="module_install">Installieren</string>
    <string name="reboot_userspace">Leichter Neustart</string>
    <string name="module_uninstall_confirm">Bist du dir sicher, dass du das Modul %s deinstallieren möchtest\?</string>
    <string name="module_uninstall_failed">Deinstallation fehlgeschlagen: %s</string>
</resources>
```

`manager/app/src/main/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Inicio</string>
    <string name="home_not_installed">No instalado</string>
    <string name="home_click_to_install">Instalar</string>
    <string name="home_working">Activo</string>
    <string name="home_working_version">Versión: %d</string>
    <string name="home_superuser_count">Superusuarios: %d</string>
    <string name="home_module_count">Módulos: %d</string>
    <string name="home_unsupported">No soportado</string>
    <string name="home_unsupported_reason">Por el momento, KernelSU solo es compatible con kernels genéricos (GKIs)</string>
    <string name="home_kernel">Versión del kernel</string>
    <string name="home_manager_version">Versión del manager</string>
    <string name="home_fingerprint">Huella del dispositivo</string>
    <string name="home_selinux_status">Estado de SELinux</string>
    <!-- It may be better to leave SELinux statuses untranslated -->
    <string name="selinux_status_disabled">Disabled</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Unknown</string>
    <string name="superuser">Superusuario</string>
    <string name="module_failed_to_enable">No se pudo habilitar el módulo \"%s\"</string>
    <string name="module_failed_to_disable">No se pudo deshabilitar el módulo \"%s\"</string>
    <string name="module_empty">No hay ningún módulo instalado</string>
    <string name="module">Módulo</string>
    <string name="uninstall">Desinstalar</string>
    <string name="module_install">Instalar módulo</string>
    <string name="install">Instalar</string>
    <string name="reboot">Reiniciar</string>
    <string name="settings">Ajustes</string>
    <string name="reboot_userspace">Reinicio suave</string>
    <string name="reboot_recovery">Reiniciar en modo recovery</string>
    <string name="reboot_bootloader">Reiniciar en modo bootloader</string>
    <string name="reboot_download">Reiniciar en modo download</string>
    <string name="reboot_edl">Reiniciar en modo EDL</string>
    <string name="about">Acerca de</string>
    <string name="module_uninstall_confirm">¿Estás seguro de que quieres desinstalar el módulo \"%s\"?</string>
    <string name="module_uninstall_success">\"%s\" desinstalado.</string>
    <string name="module_uninstall_failed">No se pudo desinstalar \"%s\".</string>
    <string name="module_version">Versión</string>
    <string name="module_author">Autor</string>
    <string name="module_overlay_fs_not_available">El módulo no puede funcionar ya que OverlayFS no está disponible</string>
    <string name="refresh">Recargar</string>
    <string name="show_system_apps">Mostrar apps del sistema</string>
    <string name="hide_system_apps">Ocultar apps del sistema</string>
    <string name="send_log">Enviar registro</string>
    <string name="safe_mode">Modo seguro</string>
    <string name="reboot_to_apply">Reiniciar para aplicar cambios</string>
    <string name="module_magisk_conflict">Se deshabilitaron los módulos ya que entran en conflicto con Magisk.</string>
    <string name="home_learn_kernelsu">Descubre KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Descubre cómo instalar KernelSU y utilizar módulos</string>
    <string name="home_support_title">Apóyanos</string>
    <string name="home_support_content">KernelSU es y siempre será, libre y de código abierto. De todas formas, puedes mostrarnos tu apoyo mediante una donación.</string>
    <string name="about_source_code"><![CDATA[Ver código fuente en %1$s<br/>Únete a nuestro canal de %2$s]]></string>
    <string name="profile_default">Predeterminado</string>
    <string name="profile_template">Plantilla</string>
    <string name="profile_custom">Personalizado</string>
    <string name="profile_name">Nombre de perfil</string>
    <string name="profile_namespace">Modo de montaje del espacio de nombres</string>
    <string name="profile_namespace_inherited">Heredado</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Grupos</string>
    <string name="profile_capabilities">Capacidades</string>
    <string name="profile_selinux_context">Contexto de SELinux</string>
    <string name="profile_umount_modules">Desmontar módulos</string>
    <string name="failed_to_update_app_profile">No se pudo actualizar el perfil de la app para %s</string>
    <string name="settings_umount_modules_default">Desmontar módulos por defecto</string>
    <string name="settings_umount_modules_default_summary">El valor global predeterminado para \"Desmontar módulos\" en los perfiles de las aplicaciones. Si la habilitas, se desharán todas las modificaciones al sistema hechas por el módulo para las apps que no tengan un perfil establecido.</string>
    <string name="profile_umount_modules_summary">Si habilitas esta opción, KernelSU podrá restaurar cualquier archivo modificado por los módulos para esta app.</string>
    <string name="profile_selinux_domain">Dominio</string>
    <string name="profile_selinux_rules">Reglas</string>
    <string name="module_update">Actualizar</string>
    <string name="module_downloading">Descargando módulo: \"%s\"</string>
    <string name="module_start_downloading">Descargar</string>
    <string name="new_version_available">Hay una nueva versión disponible (%s). Toca para descargar</string>
    <string name="launch_app">Lanzar Aplicacion</string>
    <string name="force_stop_app">Forzar cierre de la aplicacion</string>
    <string name="restart_app">Reiniciar aplicacion</string>
    <string name="failed_to_update_sepolicy">Falló al actualizar reglas de SEpolicy por: %s</string>
</resources>
```

`manager/app/src/main/res/values-fa/strings.xml`:

```xml
<resources>
<string name="home">خانه</string>
<string name="home_not_installed">نصب نشده است</string>
<string name="home_click_to_install">برای نصب ضربه بزنید</string>
<string name="home_working">به درستی کار می‌کند</string>
<string name="home_working_version">نسخه: %d</string>
<string name="home_superuser_count">برنامه های با دسترسی روت: %d</string>
<string name="home_module_count">ماژول‌ها: %d</string>
<string name="home_unsupported">پشتیبانی نشده</string>
<string name="home_unsupported_reason">کرنل اس یو فقط هسته های gki را پشتیبانی میکند</string>
    <string name="home_kernel">هسته</string>
    <string name="home_manager_version">نسخه برنامه</string>
    <string name="home_fingerprint">اثرانگشت</string>
    <string name="home_selinux_status">وضعیت SELinux</string>
<string name="selinux_status_disabled">غیرفعال</string>
<string name="selinux_status_enforcing">قانونمند</string>
<string name="selinux_status_permissive">آزاد</string>
<string name="selinux_status_unknown">ناشناخته</string>
<string name="superuser">دسترسی روت</string>
    <string name="module_failed_to_enable">فعال کردن ماژول ناموفق بود: %s</string>
<string name="module_failed_to_disable">غیرفعال کردن ماژول ناموفق بود: %s</string>
<string name="module_empty">هیچ ماژولی نصب نشده است</string>
<string name="module">ماژول</string>
<string name="uninstall">لغو نصب</string>
<string name="module_install">نصب</string>
<string name="install">نصب</string>
<string name="reboot">راه اندازی دوباره</string>
<string name="settings">تنظیمات</string>
<string name="reboot_userspace">راه اندازی نرم</string>
<string name="reboot_recovery">راه اندازی به ریکاوری </string>
<string name="reboot_bootloader">راه اندازی به بوتلودر</string>
<string name="reboot_download">راه اندازی به حالت دانلود</string>
<string name="reboot_edl">راه اندازی به EDL</string>
<string name="about">درباره</string>
    <string name="module_uninstall_confirm">آیا مطمئنید که میخواهید ماژول %s را پاک کنید؟</string>
<string name="module_uninstall_success">%s پاک شد</string>
<string name="module_uninstall_failed">پاک کردن ناموفق بود: %s</string>
<string name="module_version">نسخه</string>
<string name="module_author">سازنده</string>
<string name="module_overlay_fs_not_available">overlayfs موجود نیست. مازول کار نمیکند!!</string>
<string name="refresh">تازه‌سازی</string>
<string name="show_system_apps">نمایش برنامه های سیستمی</string>
<string name="hide_system_apps">مخفی کردن برنامه های سیستمی</string>
<string name="send_log">ارسال وقایع</string>
<string name="safe_mode">حالت امن</string>
<string name="reboot_to_apply">راه‌اندازی مجدد برای تاثیرگذاری</string>
<string name="module_magisk_conflict">مازول به دلیل تعارض با مجیسک غیرفعال شده اند\'s!</string>
<string name="home_learn_kernelsu">یادگیری کرنل اس یو</string>
<string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
<string name="home_click_to_learn_kernelsu">یاد بگیرید چگونه از کرنل اس یو و ماژول ها استفاده کنید</string>
<string name="home_support_title">از ما حمایت کنید</string>
<string name="home_support_content">KernelSU رایگان است و همیشه خواهد بود و منبع باز است. با این حال، می توانید با اهدای کمک مالی به ما نشان دهید که برایتان مهم است.</string>
<string name="about_source_code">
<![CDATA[ View source code at %1$s<br/>Join our %2$s channel ]]>
</string>
<string name="profile">پروفایل برنامه</string>
<string name="profile_default">پیش‌فرض</string>
<string name="profile_template">قالب</string>
<string name="profile_custom">شخصی سازی شده</string>
<string name="profile_name">اسم پروفایل</string>
<string name="profile_namespace">Mount namespace</string>
<string name="profile_namespace_inherited">اثر گرفته</string>
<string name="profile_namespace_global">گلوبال</string>
<string name="profile_namespace_individual">تکی</string>
<string name="profile_umount_modules">جداکردن ماژول ها</string>
</resources>

```

`manager/app/src/main/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_not_installed">Non installé</string>
    <string name="home_working">Fonctionnel</string>
    <string name="home_working_version">Version : %d</string>
    <string name="home_superuser_count">Superutilisateurs : %d</string>
    <string name="home_module_count">Modules : %d</string>
    <string name="home_unsupported_reason">Actuellement, KernelSU ne supporte que les noyaux GKI.</string>
    <string name="home_kernel">Noyau</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">Statut de SELinux</string>
    <string name="selinux_status_disabled">Désactivé</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Inconnu</string>
    <string name="superuser">Superutilisateur</string>
    <string name="module_empty">Aucun module installé</string>
    <string name="home">Accueil</string>
    <string name="home_click_to_install">Cliquez ici pour installer</string>
    <string name="home_unsupported">Non supporté</string>
    <string name="module_uninstall_failed">Échec de la désinstallation : %s</string>
    <string name="module_version">Version</string>
    <string name="home_manager_version">Version du gestionnaire</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="module_failed_to_enable">Échec de l\'activation du module : %s</string>
    <string name="module">Module</string>
    <string name="uninstall">Désinstaller</string>
    <string name="module_install">Installer</string>
    <string name="module_failed_to_disable">Échec de la désactivation du module : %s</string>
    <string name="reboot">Redémarrer</string>
    <string name="install">Installer</string>
    <string name="settings">Paramètres</string>
    <string name="reboot_bootloader">Redémarrer vers le bootloader</string>
    <string name="reboot_userspace">Redémarrage logiciel</string>
    <string name="reboot_recovery">Redémarrer en mode récupération</string>
    <string name="reboot_edl">Redémarrer en mode EDL</string>
    <string name="about">À propos</string>
    <string name="module_uninstall_success">%s désinstallé</string>
    <string name="reboot_download">Redémarrer en mode téléchargement</string>
    <string name="module_author">Auteur</string>
    <string name="module_uninstall_confirm">Êtes-vous sûr(e) de vouloir désinstaller le module %s \?</string>
    <string name="home_learn_kernelsu">Découvrir KernelSU</string>
    <string name="module_overlay_fs_not_available">overlayfs n\'est pas disponible, impossible de faire fonctionner le module !</string>
    <string name="refresh">Rafraîchir</string>
    <string name="show_system_apps">Afficher les applications système</string>
    <string name="hide_system_apps">Masquer les applications système</string>
    <string name="safe_mode">Mode sécurisé</string>
    <string name="send_log">Envoyer les logs</string>
    <string name="reboot_to_apply">Redémarrez pour appliquer les modifications</string>
    <string name="module_magisk_conflict">Les modules sont désactivés car ils sont en conflit avec ceux de Magisk !</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_support_title">Soutenez-nous</string>
    <string name="home_click_to_learn_kernelsu">Découvrez comment installer KernelSU et utiliser les modules.</string>
    <string name="home_support_content">KernelSU est gratuit et open-source et le restera toujours. Vous pouvez néanmoins montrer votre soutien en faisant un don.</string>
    <string name="about_source_code">Voir le code source sur %1$s<br/>Rejoindre notre chaîne %2$s</string>
    <string name="profile_template">Modèle</string>
    <string name="profile_default">Par défaut</string>
    <string name="profile_custom">Personnalisé</string>
    <string name="profile_name">Nom du profil</string>
    <string name="profile_namespace">Espace de noms de montage</string>
    <string name="profile_namespace_inherited">Hérité</string>
    <string name="profile_namespace_individual">Individuel</string>
    <string name="profile_selinux_context">Contexte SELinux</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_groups">Groupes</string>
    <string name="profile_capabilities">Capabilities</string>
    <string name="profile_umount_modules">Démonter les modules</string>
    <string name="failed_to_update_app_profile">Échec de la modification du profil d\'application de %s</string>
    <string name="profile_umount_modules_summary">L\'activation de cette option permettra à KernelSU de restaurer tous les fichiers modifiés par les modules pour cette application.</string>
    <string name="settings_umount_modules_default">Démonter par défaut les modules</string>
    <string name="settings_umount_modules_default_summary">Valeur globale par défaut de « Démonter les modules » dans les App Profiles. Si l\'option est activée, toutes les modifications des modules apportées au système seront enlevées pour les applications qui n\'ont pas de profil défini.</string>
    <string name="profile_selinux_domain">Domaine</string>
    <string name="profile_selinux_rules">Règles</string>
    <string name="module_update">Mettre à jour</string>
    <string name="module_downloading">Téléchargement du module : %s</string>
    <string name="launch_app">Lancer</string>
    <string name="new_version_available">Nouvelle version : la %s est disponible, cliquez ici pour la télécharger</string>
    <string name="module_start_downloading">Début du téléchargement de : %s</string>
    <string name="force_stop_app">Forcer l\'arrêt</string>
    <string name="restart_app">Relancer l\'application</string>
    <string name="failed_to_update_sepolicy">Échec de la mise à jour des règles SELinux pour : %s</string>
</resources>
```

`manager/app/src/main/res/values-in/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Beranda</string>
    <string name="home_not_installed">Tidak terpasang</string>
    <string name="home_click_to_install">Klik untuk memasang</string>
    <string name="home_working">Bekerja</string>
    <string name="home_working_version">Versi: %d</string>
    <string name="home_superuser_count">Superusers: %d</string>
    <string name="home_module_count">Modul: %d</string>
    <string name="home_unsupported">Tidak didukung</string>
    <string name="home_unsupported_reason">KernelSU hanya mendukung kernel GKI saat ini</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Versi Manager</string>
    <string name="home_fingerprint">Sidik jari</string>
    <string name="home_selinux_status">Status SELinux</string>
    <string name="selinux_status_disabled">Dinonaktifkan</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Tidak dikenal</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Gagal mengaktifkan modul: %s</string>
    <string name="module_failed_to_disable">Gagal menonaktifkan modul: %s</string>
    <string name="module_empty">Tidak ada modul terpasang</string>
    <string name="module">Modul</string>
    <string name="uninstall">Copot</string>
    <string name="module_install">Pasang</string>
    <string name="install">Pasang</string>
    <string name="reboot">Mulai ulang</string>
    <string name="settings">Pengaturan</string>
    <string name="reboot_userspace">Soft Reboot</string>
    <string name="reboot_recovery">Mulai ulang ke Pemulihan</string>
    <string name="reboot_bootloader">Mulai ulang ke Bootloader</string>
    <string name="reboot_download">Mulai ulang ke Download</string>
    <string name="reboot_edl">Mulai ulang ke EDL</string>
    <string name="about">Tentang</string>
    <string name="module_uninstall_confirm">Apakah Anda yakin ingin mencopot modul %s?</string>
    <string name="module_uninstall_success">%s Tercopot</string>
    <string name="module_uninstall_failed">Gagal untuk mencopot: %s</string>
    <string name="module_version">Versi</string>
    <string name="module_author">Pembuat</string>
    <string name="module_overlay_fs_not_available">overlayfs tidak tersedia, modul tidak dapat bekerja!</string>
    <string name="refresh">Segarkan</string>
    <string name="show_system_apps">Tampilkan apl sistem</string>
    <string name="hide_system_apps">Sembunyikan apl sistem</string>
    <string name="send_log">Kirim Log</string>
    <string name="safe_mode">Mode aman</string>
    <string name="reboot_to_apply">Mulai ulang untuk menerapkan</string>
    <string name="module_magisk_conflict">Modul dinonaktifkan karena bertentangan dengan Magisk!</string>
    <string name="home_learn_kernelsu">Pelajari KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/id_ID/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Pelajari cara memasang KernelSU dan menggunakan modul</string>
    <string name="home_support_title">Dukung Kami</string>
    <string name="home_support_content">KernelSU gratis dan bersumber terbuka, dan akan selalu seperti itu. Bagaimanapun juga Anda dapat menunjukan kepedulian Anda kepada kami dengan mengirimkan sedikit donasi.</string>
    <string name="about_source_code"><![CDATA[Lihat sumber code di %1$s<br/>Gabung kanal %2$s kami]]></string>
    <string name="profile">Profil Apl</string>
    <string name="profile_default">Bawaan</string>
    <string name="profile_template">Templat</string>
    <string name="profile_custom">Khusus</string>
    <string name="profile_name">Nama profil</string>
    <string name="profile_namespace">Ikat ruang-nama</string>
    <string name="profile_namespace_inherited">Diwariskan</string>
    <string name="profile_namespace_global">Universal</string>
    <string name="profile_namespace_individual">Personal</string>
    <string name="profile_groups">Kelompok</string>
    <string name="profile_capabilities">Kemampuan</string>
    <string name="profile_selinux_context">Konteks SELinux</string>
    <string name="profile_umount_modules">Lepas modul</string>
    <string name="failed_to_update_app_profile">Gagal memperbarui Profil Apl untuk %s</string>
    <string name="settings_umount_modules_default">Lepas modul secara bawaan</string>
    <string name="settings_umount_modules_default_summary">Nilai bawaan universal untuk \"Lepas modul\" di Profil-profil Apl. Jika diaktifkan, ini akan menghapus semua modifikasi modul pada sistem untuk aplikasi yang tidak memiliki set Profil.</string>
    <string name="profile_umount_modules_summary">Mengaktifkan opsi ini akan mengizinkan KernelSU memulihkan file-file yang dimodifikasi oleh modul untuk aplikasi ini.</string>
    <string name="profile_selinux_domain">Domain</string>
    <string name="profile_selinux_rules">Aturan</string>
    <string name="module_update">Perbarui</string>
    <string name="module_downloading">Mengunduh module: %s</string>
    <string name="module_start_downloading">Mulai mengunduh: %s</string>
    <string name="new_version_available">Versi baru: %s telah tersedia, tap untuk mengunduh</string>
    <string name="launch_app">Jalankan</string>
    <string name="force_stop_app">Paksa Berhenti</string>
    <string name="restart_app">Mulai ulang</string>
    <string name="failed_to_update_sepolicy">Gagal memperbarui aturan SELinux untuk: %s</string>
</resources>
```

`manager/app/src/main/res/values-it/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Home</string>
    <string name="home_not_installed">Non installato</string>
    <string name="home_click_to_install">Clicca per installare</string>
    <string name="home_working">In esecuzione</string>
    <string name="home_working_version">Versione: %d</string>
    <string name="home_superuser_count">Superuser: %d</string>
    <string name="home_module_count">Moduli: %d</string>
    <string name="home_unsupported">Non supportato</string>
    <string name="home_unsupported_reason">KernelSU ora supporta solo i kernel GKI</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Versione del manager</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">Stato SELinux</string>
    <string name="selinux_status_disabled">Disabilitato</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Sconosciuto</string>
    <string name="superuser">Accesso root</string>
    <string name="module_failed_to_enable">Impossibile abilitare il modulo: %s</string>
    <string name="module_failed_to_disable">Impossibile disabilitare il modulo: %s</string>
    <string name="module_empty">Nessun modulo installato</string>
    <string name="module">Moduli</string>
    <string name="uninstall">Disinstalla</string>
    <string name="module_install">Installa</string>
    <string name="install">Installa</string>
    <string name="reboot">Riavvia</string>
    <string name="settings">Impostazioni</string>
    <string name="reboot_userspace">Riavvio veloce</string>
    <string name="reboot_recovery">Riavvia in Recovery</string>
    <string name="reboot_bootloader">Riavvia in modalità Bootloader</string>
    <string name="reboot_download">Riavvia in modalità Download</string>
    <string name="reboot_edl">Riavvia in modalità EDL</string>
    <string name="about">Informazioni</string>
    <string name="module_uninstall_confirm">Sei sicuro di voler disinstallare il modulo %s?</string>
    <string name="module_uninstall_success">%s disinstallato</string>
    <string name="module_uninstall_failed">Impossibile disinstallare: %s</string>
    <string name="module_version">Versione</string>
    <string name="module_author">Autore</string>
    <string name="module_overlay_fs_not_available">overlayfs non è disponibile, il modulo non può funzionare!</string>
    <string name="refresh">Aggiorna</string>
    <string name="show_system_apps">Mostra app di sistema</string>
    <string name="hide_system_apps">Nascondi app di sistema</string>
    <string name="send_log">Invia log</string>
    <string name="safe_mode">Modalità provvisoria</string>
    <string name="reboot_to_apply">Riavvia per applicare la modifica</string>
    <string name="module_magisk_conflict">I moduli sono disabilitati perché in conflitto con quelli di Magisk!</string>
    <string name="home_learn_kernelsu">Scopri KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Scopri come installare KernelSU e utilizzare i moduli</string>
    <string name="home_support_title">Supportaci</string>
    <string name="home_support_content">KernelSU è, e sempre sarà, gratuito e open source. Puoi comunque mostrarci il tuo apprezzamento facendo una donazione.</string>
    <string name="about_source_code"><![CDATA[Visualizza il codice sorgente su %1$s<br/>Unisciti al nostro canale %2$s]]></string>
    <string name="profile_name">Nome profilo</string>
    <string name="profile_namespace">Namespace di mount</string>
    <string name="profile_namespace_global">Globale</string>
    <string name="profile_groups">Gruppi</string>
    <string name="profile_namespace_inherited">Ereditato</string>
    <string name="profile_namespace_individual">Individuale</string>
    <string name="profile_default">Predefinito</string>
    <string name="profile_custom">Personalizzato</string>
    <string name="profile_template">Template</string>
    <string name="profile_umount_modules">Scollega moduli</string>
    <string name="profile_selinux_context">Contesto SELinux</string>
    <string name="failed_to_update_app_profile">Aggiornamento Profilo per %s fallito</string>
    <string name="module_update">Aggiorna</string>
    <string name="launch_app">Apri</string>
    <string name="profile_capabilities">Capacità</string>
    <string name="settings_umount_modules_default">Scollega moduli da default</string>
    <string name="profile_selinux_rules">Regole</string>
    <string name="module_downloading">Sto scaricando il modulo: %s</string>
    <string name="module_start_downloading">Inizia a scaricare:%s</string>
    <string name="new_version_available">Nuova versione: %s disponibile, tocca per scaricare</string>
    <string name="force_stop_app">Arresto forzato</string>
    <string name="restart_app">Riavvia</string>
    <string name="failed_to_update_sepolicy">Aggiornamento regole SELinux per %s fallito</string>
    <string name="profile_umount_modules_summary">Attivando questa opzione permetterai a KernelSU di ripristinare ogni file modificato dai moduli per questa app.</string>
    <string name="profile_selinux_domain">Dominio</string>
    <string name="settings_umount_modules_default_summary">Il valore predefinito per \"Scollega moduli\" in Profili App. Se attivato, rimuoverà tutte le modifiche al sistema da parte dei moduli per le applicazioni che non hanno un profilo impostato.</string>
</resources>
```

`manager/app/src/main/res/values-ja/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">ホーム</string>
    <string name="home_not_installed">未インストール</string>
    <string name="home_click_to_install">タップでインストール</string>
    <string name="home_working">動作中</string>
    <string name="home_working_version">バージョン: %d</string>
    <string name="home_superuser_count">スーパーユーザー: %d</string>
    <string name="home_module_count">モジュール: %d</string>
    <string name="home_unsupported">非対応</string>
    <string name="home_unsupported_reason">KernelSU は現在、GKI カーネルにのみ対応しています</string>
    <string name="home_kernel">カーネル</string>
    <string name="home_manager_version">バージョン</string>
    <string name="home_fingerprint">フィンガープリント</string>
    <string name="home_selinux_status">SELinux の状態</string>
    <string name="selinux_status_disabled">無効</string>
    <string name="selinux_status_enforcing">強制実施</string>
    <string name="selinux_status_permissive">寛容</string>
    <string name="selinux_status_unknown">不明</string>
    <string name="superuser">スーパーユーザー</string>
    <string name="module_failed_to_enable">モジュールの有効化に失敗: %s</string>
    <string name="module_failed_to_disable">モジュールの無効化に失敗: %s</string>
    <string name="module_empty">モジュールをインストールしていません</string>
    <string name="module">モジュール</string>
    <string name="uninstall">アンインストール</string>
    <string name="module_install">インストール</string>
    <string name="install">インストール</string>
    <string name="reboot">再起動</string>
    <string name="settings">設定</string>
    <string name="reboot_userspace">ソフトリブート</string>
    <string name="reboot_recovery">リカバリーへ再起動</string>
    <string name="reboot_bootloader">Bootloader へ再起動</string>
    <string name="reboot_download">ダウンロードモードへ再起動</string>
    <string name="reboot_edl">EDLへ再起動</string>
    <string name="about">アプリについて</string>
    <string name="module_uninstall_confirm">モジュール %s をアンインストールしますか?</string>
    <string name="module_uninstall_success">%sをアンインストールしました</string>
    <string name="module_uninstall_failed">アンインストールに失敗: %s</string>
    <string name="module_version">バージョン</string>
    <string name="module_author">制作者</string>
    <string name="module_overlay_fs_not_available">OverlayFS が有効でないためモジュールは動作しません！</string>
    <string name="refresh">更新</string>
    <string name="show_system_apps">システムアプリを表示</string>
    <string name="hide_system_apps">システムアプリを非表示</string>
    <string name="send_log">ログを送信</string>
    <string name="safe_mode">セーフモード</string>
    <string name="reboot_to_apply">再起動すると有効化されます</string>
    <string name="module_magisk_conflict">Magisk と競合しているためモジュールは無効になっています!</string>
    <string name="home_learn_kernelsu">KernelSU の詳細</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/ja_JP/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">KernelSU のインストール方法やモジュールの使い方はこちら</string>
    <string name="home_support_title">支援する</string>
    <string name="home_support_content">KernelSU は、現在も、今後も、無料のオープン ソースです。ただし、寄付をすることで私たちを気にかけていることを示すことができます。</string>
    <string name="about_source_code"><![CDATA[%1$s でソースコードを表示<br/>%2$s チャンネルに参加]]></string>
    <string name="profile">アプリのプロファイル</string>
    <string name="profile_default">デフォルト</string>
    <string name="profile_template">テンプレート</string>
    <string name="profile_custom">カスタム</string>
    <string name="profile_name">プロファイル名</string>
    <string name="profile_namespace">マウント名前空間</string>
    <string name="profile_namespace_inherited">継承</string>
    <string name="profile_namespace_global">グローバル</string>
    <string name="profile_namespace_individual">分離</string>
    <string name="profile_umount_modules">モジュールのアンマウント</string>
    <string name="profile_groups">グループ</string>
    <string name="profile_selinux_context">SELinux コンテキスト</string>
    <string name="failed_to_update_app_profile">%sのアプリのプロファイルの更新をできませでした</string>
    <string name="profile_selinux_domain">ドメイン</string>
    <string name="profile_selinux_rules">ルール</string>
    <string name="new_version_available">新しいバージョン: %s が利用可能です。クリックしてダウンロードしてください</string>
    <string name="module_update">アップデート</string>
    <string name="module_start_downloading">ダウンロードを開始:%s</string>
    <string name="launch_app">起動</string>
    <string name="force_stop_app">強制停止</string>
    <string name="restart_app">再起動</string>
    <string name="failed_to_update_sepolicy">SELinux ルールの更新に失敗しました: %s</string>
    <string name="profile_capabilities">ケイパビリティ</string>
    <string name="module_downloading">ダウンロードモジュール:%s</string>
    <string name="profile_umount_modules_summary">このオプションを有効にすると、KernelSU はこのアプリケーションのモジュールによって変更されたファイルを復元できるようになります。</string>
    <string name="settings_umount_modules_default">デフォルトでモジュールをアンインストールする</string>
    <string name="settings_umount_modules_default_summary">アプリプロファイルの「モジュールのマウント解除」のグローバルデフォルト値。 有効にすると、プロファイル セットを持たないアプリケーションのシステムに対するすべてのモジュール変更が削除されます。</string>
    <string name="require_kernel_version">現在の KernelSU バージョン %d はマネージャーが適切に機能するには低すぎます。 バージョン %d 以降にアップグレードしてください！</string>
</resources>
```

`manager/app/src/main/res/values-ko/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">홈</string>
    <string name="home_not_installed">설치되지 않음</string>
    <string name="home_click_to_install">이 곳을 눌러 설치하기</string>
    <string name="home_working">정상 작동 중</string>
    <string name="home_working_version">버전: %d</string>
    <string name="home_superuser_count">루트 권한: %d개</string>
    <string name="home_module_count">설치된 모듈: %d개</string>
    <string name="home_unsupported">지원되지 않음</string>
    <string name="home_unsupported_reason">KernelSU는 현재 GKI 커널만 지원합니다</string>
    <string name="home_kernel">커널</string>
    <string name="home_manager_version">매니저 버전</string>
    <string name="home_fingerprint">빌드 정보</string>
    <string name="home_selinux_status">SELinux 상태</string>
    <string name="selinux_status_disabled">비활성화됨</string>
    <string name="selinux_status_enforcing">적용</string>
    <string name="selinux_status_permissive">허용</string>
    <string name="selinux_status_unknown">알 수 없음</string>
    <string name="superuser">슈퍼유저</string>
    <string name="module_failed_to_enable">모듈 활성화 실패: %s</string>
    <string name="module_failed_to_disable">모듈 비활성화 실패: %s</string>
    <string name="module_empty">설치된 모듈 없음</string>
    <string name="module">모듈</string>
    <string name="uninstall">삭제</string>
    <string name="module_install">설치</string>
    <string name="install">설치</string>
    <string name="reboot">다시 시작</string>
    <string name="settings">설정</string>
    <string name="reboot_userspace">빠른 다시 시작</string>
    <string name="reboot_recovery">복구 모드로 다시 시작</string>
    <string name="reboot_bootloader">부트로더로 다시 시작</string>
    <string name="reboot_download">다운로드 모드로 다시 시작</string>
    <string name="reboot_edl">EDL 모드로 다시 시작</string>
    <string name="about">정보</string>
    <string name="module_uninstall_confirm">%s 모듈을 삭제할까요?</string>
    <string name="module_uninstall_success">%s 모듈 삭제됨</string>
    <string name="module_uninstall_failed">모듈 삭제 실패: %s</string>
    <string name="module_version">버전</string>
    <string name="module_author">제작자</string>
    <string name="module_overlay_fs_not_available">overlayfs 사용 불가, 모듈을 사용할 수 없습니다!</string>
    <string name="refresh">새로고침</string>
    <string name="show_system_apps">시스템 앱 보이기</string>
    <string name="hide_system_apps">시스템 앱 숨기기</string>
    <string name="send_log">로그 보내기</string>
    <string name="safe_mode">안전 모드</string>
    <string name="reboot_to_apply">다시 시작하여 변경 사항 적용</string>
    <string name="module_magisk_conflict">Magisk와의 충돌로 인해 모듈을 사용할 수 없습니다!</string>
    <string name="home_learn_kernelsu">KernelSU 알아보기</string>
    <string name="home_click_to_learn_kernelsu">KernelSU 설치 방법과 모듈 사용 방법을 확인합니다</string>
    <string name="home_support_title">지원이 필요합니다</string>
    <string name="home_support_content">KernelSU는 지금도, 앞으로도 항상 무료이며 오픈 소스로 유지됩니다. 기부를 통해 여러분의 관심을 보여주세요.</string>
    <string name="about_source_code"><![CDATA[%1$s에서 소스 코드 보기<br/>%2$s 채널 참가하기]]></string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="settings_umount_modules_default_summary">앱 프로필 메뉴의 \"모듈 사용 해제\" 설정에 대한 전역 기본값을 설정합니다. 활성화 시, 개별 프로필이 설정되지 않은 앱은 시스템에 대한 모듈의 모든 수정사항이 적용되지 않습니다.</string>
    <string name="restart_app">다시 시작</string>
    <string name="profile_selinux_rules">규칙</string>
    <string name="new_version_available">새 버전: %s 사용 가능, 여기를 눌러서 받기</string>
    <string name="module_start_downloading">다운로드 시작: %s</string>
    <string name="force_stop_app">강제 중지</string>
    <string name="profile_default">기본값</string>
    <string name="profile_custom">사용자 지정</string>
    <string name="profile_template">템플릿</string>
    <string name="profile_name">프로필 이름</string>
    <string name="profile_namespace">이름 공간 마운트</string>
    <string name="profile_namespace_inherited">상속</string>
    <string name="profile_namespace_global">전역</string>
    <string name="profile_namespace_individual">개별</string>
    <string name="profile_groups">사용자 그룹</string>
    <string name="profile_umount_modules">모듈 사용 해제</string>
    <string name="profile_selinux_context">SELinux 컨텍스트</string>
    <string name="profile_capabilities">권한</string>
    <string name="failed_to_update_app_profile">%s에 대한 앱 프로필 업데이트 실패</string>
    <string name="settings_umount_modules_default">기본값으로 모듈 사용 해제</string>
    <string name="profile_umount_modules_summary">이 옵션이 활성화되면, KernelSU는 이 애플리케이션에 대한 모듈의 모든 수정사항을 복구합니다.</string>
    <string name="module_update">업데이트</string>
    <string name="module_downloading">모듈 받는 중: %s</string>
    <string name="profile_selinux_domain">도메인</string>
    <string name="launch_app">실행</string>
    <string name="failed_to_update_sepolicy">다음 앱에 대한 SELinux 규칙 업데이트 실패: %s</string>
</resources>
```

`manager/app/src/main/res/values-lt/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_fingerprint">Pirštų atspaudas</string>
    <string name="selinux_status_disabled">Išjungta</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_unknown">Nežinomas</string>
    <string name="superuser">Supernaudotojai</string>
    <string name="module_failed_to_enable">Nepavyko įjungti modulio: %s</string>
    <string name="module_failed_to_disable">Nepavyko išjungti modulio: %s</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="module_empty">Nėra įdiegtų modulių</string>
    <string name="module">Moduliai</string>
    <string name="reboot_userspace">Perkrovimas neišjungus</string>
    <string name="reboot_recovery">Perkrauti į atkūrimo rėžimą</string>
    <string name="reboot_bootloader">Perkrauti į įkrovos tvarkyklę</string>
    <string name="reboot_download">Perkrauti į atsisiuntimo rėžimą</string>
    <string name="about">Apie</string>
    <string name="module_uninstall_failed">Nepavyko išdiegti: %s</string>
    <string name="module_uninstall_success">%s išdiegtas</string>
    <string name="module_version">Versija</string>
    <string name="module_author">Autorius</string>
    <string name="module_overlay_fs_not_available">overlayfs nepasiekiamas, modulis negali veikti!</string>
    <string name="show_system_apps">Rodyti sistemos programas</string>
    <string name="hide_system_apps">Slėpti sistemos programas</string>
    <string name="send_log">Siųsti žurnalą</string>
    <string name="reboot">Paleisti iš naujo</string>
    <string name="refresh">Atšviežinti</string>
    <string name="safe_mode">Saugus rėžimas</string>
    <string name="reboot_to_apply">Paleiskite iš naujo, kad įsigaliotų</string>
    <string name="module_magisk_conflict">Moduliai yra išjungti, nes jie konfliktuoja su Magisk\'s!</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_learn_kernelsu">Sužinokite apie KernelSU</string>
    <string name="home_click_to_learn_kernelsu">Sužinokite, kaip įdiegti KernelSU ir naudoti modulius</string>
    <string name="about_source_code">Peržiūrėkite šaltinio kodą %1$s<br/>Prisijunkite prie mūsų %2$s kanalo</string>
    <string name="profile_default">Numatytas</string>
    <string name="profile_template">Šablonas</string>
    <string name="profile_custom">Pasirinktinis</string>
    <string name="profile_name">Profilio pavadinimas</string>
    <string name="profile_namespace">Prijungti vardų erdvę</string>
    <string name="profile_namespace_inherited">Paveldėtas</string>
    <string name="profile_namespace_global">Globalus</string>
    <string name="profile_namespace_individual">Individualus</string>
    <string name="profile_groups">Grupės</string>
    <string name="profile_capabilities">Galimybės</string>
    <string name="profile_selinux_context">SELinux kontekstas</string>
    <string name="profile_umount_modules">Atjungti modulius</string>
    <string name="settings_umount_modules_default">Atjungti modulius pagal numatytuosius parametrus</string>
    <string name="profile_umount_modules_summary">Įjungus šią parinktį, KernelSU galės atkurti visus modulių modifikuotus failus šiai programai.</string>
    <string name="profile_selinux_domain">Domenas</string>
    <string name="profile_selinux_rules">Taisyklės</string>
    <string name="module_update">Atnaujinti</string>
    <string name="module_downloading">Atsisiunčiamas modulis: %s</string>
    <string name="module_start_downloading">Pradedamas atsisiuntimas: %s</string>
    <string name="new_version_available">Nauja versija: %s pasiekiama, spustelėkite norėdami atsisiųsti</string>
    <string name="launch_app">Paleisti</string>
    <string name="force_stop_app">Priversti sustoti</string>
    <string name="restart_app">Perkrauti</string>
    <string name="failed_to_update_sepolicy">Nepavyko atnaujinti SELinux taisyklių: %s</string>
    <string name="home">Namai</string>
    <string name="home_not_installed">Neįdiegta</string>
    <string name="home_unsupported_reason">KernelSU dabar palaiko tik GKI branduolius</string>
    <string name="home_click_to_install">Spustelėkite norėdami įdiegti</string>
    <string name="home_working">Veikia</string>
    <string name="home_superuser_count">Supernaudotojai: %d</string>
    <string name="home_working_version">Versija: %d</string>
    <string name="home_unsupported">Nepalaikoma</string>
    <string name="home_module_count">Moduliai: %d</string>
    <string name="home_manager_version">Tvarkyklės versija</string>
    <string name="home_kernel">Branduolys</string>
    <string name="home_selinux_status">SELinux statusas</string>
    <string name="uninstall">Išdiegti</string>
    <string name="module_install">Įdiegti</string>
    <string name="install">Įdiegti</string>
    <string name="settings">Parametrai</string>
    <string name="reboot_edl">Perkrauti į EDL</string>
    <string name="module_uninstall_confirm">Ar tikrai norite išdiegti modulį %s\?</string>
    <string name="home_support_title">Paremkite mus</string>
    <string name="home_support_content">KernelSU yra ir visada bus nemokamas ir atvirojo kodo. Tačiau galite parodyti, kad jums rūpi, paaukodami mums.</string>
    <string name="failed_to_update_app_profile">Nepavyko atnaujinti programos profilio %s</string>
    <string name="settings_umount_modules_default_summary">Visuotinė numatytoji „Modulių atjungimo“ reikšmė programų profiliuose. Jei įjungta, ji pašalins visus sistemos modulio pakeitimus programoms, kurios neturi profilio.</string>
</resources>
```

`manager/app/src/main/res/values-mr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_not_installed">इंस्टॉल केले नाही</string>
    <string name="home">होम</string>
    <string name="home_click_to_install">इंस्टॉल साठी क्लिक करा</string>
    <string name="home_working">कार्यरत</string>
    <string name="home_working_version">आवृत्ती: %d</string>
    <string name="home_module_count">मॉड्यूल्स: %d</string>
    <string name="home_superuser_count">सुपरयूझर: %d</string>
    <string name="home_unsupported">असमर्थित</string>
    <string name="home_unsupported_reason">KernelSU आता फक्त GKI कर्नलचे समर्थन करते</string>
    <string name="home_kernel">कर्नल</string>
    <string name="home_fingerprint">फिंगरप्रिंट</string>
    <string name="home_manager_version">व्यवस्थापक आवृत्ती</string>
    <string name="home_selinux_status">SELinux स्थिती</string>
    <string name="selinux_status_disabled">अक्षम</string>
    <string name="selinux_status_enforcing">एनफोर्सिंग</string>
    <string name="selinux_status_permissive">परमिसिव</string>
    <string name="selinux_status_unknown">अज्ञात</string>
    <string name="install">स्थापित करा</string>
    <string name="module_empty">कोणतेही मॉड्यूल स्थापित केलेले नाही</string>
    <string name="reboot">रीबूट करा</string>
    <string name="superuser">सुपरयुझर</string>
    <string name="module_failed_to_enable">मॉड्यूल सक्षम करण्यात अयशस्वी: %s</string>
    <string name="uninstall">विस्थापित करा</string>
    <string name="module_failed_to_disable">मॉड्यूल अक्षम करण्यात अयशस्वी: %s</string>
    <string name="module">मॉड्यूल</string>
    <string name="module_install">स्थापित करा</string>
    <string name="settings">सेटिंग्ज</string>
    <string name="reboot_userspace">सॉफ्ट रीबूट</string>
    <string name="about">बद्दल</string>
    <string name="reboot_edl">EDL वर रीबूट करा</string>
    <string name="module_uninstall_confirm">तुमची खात्री आहे की तुम्ही मॉड्यूल %s विस्थापित करू इच्छिता\?</string>
    <string name="module_uninstall_failed">विस्थापित करण्यात अयशस्वी: %s</string>
    <string name="module_overlay_fs_not_available">overlayfs उपलब्ध नाही, मॉड्यूल काम करू शकत नाही!</string>
    <string name="show_system_apps">सिस्टम अॅप्स दाखवा</string>
    <string name="reboot_bootloader">बूटलोडरवर रीबूट करा</string>
    <string name="module_uninstall_success">%s विस्थापित</string>
    <string name="module_version">आवृत्ती</string>
    <string name="module_author">लेखक</string>
    <string name="refresh">रिफ्रेश करा</string>
    <string name="reboot_recovery">रिकवरी मध्ये रिबुट करा</string>
    <string name="reboot_download">डाउनलोड करण्यासाठी रीबूट करा</string>
    <string name="send_log">लॉग पाठवा</string>
    <string name="safe_mode">सुरक्षित मोड</string>
    <string name="hide_system_apps">सिस्टम अॅप्स लपवा</string>
    <string name="reboot_to_apply">प्रभावी होण्यासाठी रीबूट करा</string>
    <string name="home_learn_kernelsu">KernelSU शिका</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="module_magisk_conflict">मॉड्यूल अक्षम केले आहेत कारण ते Magisk च्या विरोधाभास आहे!</string>
    <string name="home_click_to_learn_kernelsu">KernelSU कसे स्थापित करायचे आणि मॉड्यूल कसे वापरायचे ते शिका</string>
    <string name="home_support_content">KernelSU विनामूल्य आणि मुक्त स्रोत आहे, आणि नेहमीच असेल. तथापि, देणगी देऊन तुम्ही आम्हाला दाखवू शकता की तुमची काळजी आहे.</string>
    <string name="home_support_title">आम्हाला पाठिंबा द्या</string>
    <string name="profile_custom">कस्टम</string>
    <string name="profile_namespace">माउंट नेमस्पेस</string>
    <string name="profile_default">डीफॉल्ट</string>
    <string name="profile_template">साचा</string>
    <string name="profile_namespace_individual">वैयक्तिक</string>
    <string name="profile_capabilities">क्षमता</string>
    <string name="about_source_code">%1$s वर स्रोत कोड पहा<br/>आमच्या %2$s चॅनेलमध्ये सामील व्हा</string>
    <string name="profile_name">प्रोफाइल नाव</string>
    <string name="profile_namespace_inherited">इनहेरीटेड</string>
    <string name="profile_namespace_global">जागतिक</string>
    <string name="profile_groups">गट</string>
    <string name="profile_selinux_context">SELinux संदर्भ</string>
    <string name="profile_umount_modules">उमाउंट मॉड्यूल्स</string>
    <string name="failed_to_update_app_profile">%s साठी अॅप प्रोफाइल अपडेट करण्यात अयशस्वी</string>
    <string name="settings_umount_modules_default">डीफॉल्टनुसार मॉड्यूल्स उमाउंट करा</string>
    <string name="settings_umount_modules_default_summary">अॅप प्रोफाइलमधील \"उमाउंट मॉड्यूल्स\" साठी जागतिक डीफॉल्ट मूल्य. सक्षम असल्यास, ते प्रोफाइल सेट नसलेल्या ॲप्लिकेशनचे सिस्टममधील सर्व मॉड्यूल बदल काढून टाकेल.</string>
    <string name="profile_umount_modules_summary">हा पर्याय सक्षम केल्याने KernelSU ला या ऍप्लिकेशनसाठी मॉड्यूल्सद्वारे कोणत्याही सुधारित फाइल्स पुनर्संचयित करण्यास अनुमती मिळेल.</string>
    <string name="failed_to_update_sepolicy">यासाठी SELinux नियम अपडेट करण्यात अयशस्वी: %s</string>
    <string name="profile_selinux_rules">नियम</string>
    <string name="module_update">अपडेट करा</string>
    <string name="profile_selinux_domain">डोमेन</string>
    <string name="module_downloading">मॉड्यूल डाउनलोड करत आहे: %s</string>
    <string name="module_start_downloading">डाउनलोड करणे सुरू करा: %s</string>
    <string name="new_version_available">नवीन आवृत्ती: %s उपलब्ध आहे, डाउनलोड करण्यासाठी क्लिक करा</string>
    <string name="force_stop_app">सक्तीने थांबा</string>
    <string name="launch_app">लाँच करा</string>
    <string name="restart_app">पुन्हा सुरू करा</string>
</resources>
```

`manager/app/src/main/res/values-nl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Home</string>
    <string name="home_not_installed">Niet geïnstalleerd</string>
    <string name="home_click_to_install">Klik om te installeren</string>
    <string name="home_working">Werkend</string>
    <string name="home_working_version">Versie: %d</string>
    <string name="home_superuser_count">Supergebruikers: %d</string>
    <string name="home_module_count">Modules: %d</string>
    <string name="home_unsupported">Niet ondersteund</string>
    <string name="home_unsupported_reason">KernelSU ondersteunt alleen GKI kernels</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Manager Versie</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">SELinux status</string>
    <string name="selinux_status_disabled">Uitgeschakeld</string>
    <string name="selinux_status_enforcing">Afgedwongen</string>
    <string name="selinux_status_permissive">Permissief</string>
    <string name="selinux_status_unknown">Niet gekend</string>
    <string name="superuser">Supergebruiker</string>
    <string name="module_failed_to_enable">Mislukt om module in te schakelen: %s</string>
    <string name="module_failed_to_disable">Mislukt om module uit te schakelen: %s</string>
    <string name="module_empty">Geen module geïnstalleerd</string>
    <string name="module">Module</string>
    <string name="uninstall">Verwijderen</string>
    <string name="module_install">Installeren</string>
    <string name="install">Installeren</string>
    <string name="reboot">Herstart</string>
    <string name="settings">Instellingen</string>
    <string name="reboot_userspace">Soft herstart</string>
    <string name="reboot_recovery">Herstart naar Recovery</string>
    <string name="reboot_bootloader">Herstart naar Bootloader</string>
    <string name="reboot_download">Herstart om te downloaden</string>
    <string name="reboot_edl">Herstart naar EDL</string>
    <string name="about">Over</string>
    <string name="module_uninstall_confirm">Zeker van het verwijderen van module %s?</string>
    <string name="module_uninstall_success">%s verwijderd</string>
    <string name="module_uninstall_failed">Mislukt om te verwijderen: %s</string>
    <string name="module_version">Versie</string>
    <string name="module_author">Auteur</string>
    <string name="module_overlay_fs_not_available">overlayfs is niet beschikbaar, module kan niet werken!</string>
    <string name="refresh">Vernieuwen</string>
    <string name="show_system_apps">Toon systeem apps</string>
    <string name="hide_system_apps">Verberg systeem apps</string>
    <string name="send_log">Stuur Log</string>
    <string name="safe_mode">Safe mode</string>
    <string name="reboot_to_apply">Herstart om effect te hebben</string>
    <string name="module_magisk_conflict">Modules zijn uitgeschakeld omdat ze in conflict zijn met magisk!</string>
    <string name="home_learn_kernelsu">Leer KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Leer hoe KernelSU te installeren en modules te gebruiken</string>
    <string name="home_support_title">Ondersteun ons</string>
    <string name="home_support_content">KernelSU is, en zal altijd, vrij en open source zijn. Je kan altijd je appreciatie tonen met een donatie.</string>
    <string name="about_source_code"><![CDATA[Bekijk source code op %1$s<br/>Vervoeg ons %2$s kanaal]]></string>
    <string name="profile" translatable="false">App profiel</string>
    <string name="profile_default">Standaard</string>
    <string name="profile_template">Sjabloon</string>
    <string name="profile_custom">Aangepast</string>
    <string name="profile_name">Profiel naam</string>
    <string name="profile_namespace">Koppel naamruimte</string>
    <string name="profile_namespace_inherited">Overgenomen</string>
    <string name="profile_namespace_global">Globaal</string>
    <string name="profile_namespace_individual">Individuëel</string>
    <string name="profile_groups">Groepen</string>
    <string name="profile_capabilities">Mogelijkheden</string>
    <string name="profile_selinux_context">SELinux context</string>
    <string name="profile_umount_modules">Ontkoppel modules</string>
    <string name="failed_to_update_app_profile">Mislukt om App Profiel te updaten voor %s</string>
    <string name="settings_umount_modules_default">Ontkoppel standaard de modules</string>
    <string name="settings_umount_modules_default_summary">De globale standaard waarde voor \"Ontkoppel modules\" in App Profielen. Indien geactiveerd, zal het alle module wijzigingen tot het systeem verwijderen voor applicaties die geen Profiel ingesteld hebben.</string>
    <string name="profile_umount_modules_summary">Met deze optie ingeschakeld zal KernelSU toelaten om alle gewijzigde bestanden door de modules voor deze applicatie te herstellen.</string>
    <string name="profile_selinux_domain">Domein</string>
    <string name="profile_selinux_rules">Regels</string>
    <string name="module_update">Update</string>
    <string name="module_downloading">Downloaden van module: %s</string>
    <string name="new_version_available">Nieuwe versie: %s is beschikbaar, klik om te downloaden</string>
    <string name="launch_app">Start</string>
    <string name="force_stop_app">Forceer Stop</string>
    <string name="restart_app">Herstart</string>
    <string name="module_start_downloading">Begin met downloaden: %s</string>
    <string name="failed_to_update_sepolicy">Kan SELinux-regels niet bijwerken voor: %s</string>
    <string name="require_kernel_version">De huidige KernelSU-versie %d is te laag om de manager correct te laten functioneren. Upgrade naar versie %d of hoger!</string>
</resources>
```

`manager/app/src/main/res/values-pl/strings.xml`:

```xml
<resources>
    <string name="app_name" translatable="false">KernelSU</string>

    <string name="home">Menu</string>
    <string name="home_not_installed">Nie zainstalowano</string>
    <string name="home_click_to_install">Kliknij, aby zainstalować</string>
    <string name="home_working">Działa</string>
    <string name="home_working_version">Wersja: %d</string>
    <string name="home_superuser_count">Superużytkowników: %d</string>
    <string name="home_module_count">Modułów: %d</string>
    <string name="home_unsupported">Nieobsługiwany</string>
    <string name="home_unsupported_reason">KernelSU obsługuje obecnie tylko jądra GKI</string>

    <string name="home_kernel">Jądro</string>
    <string name="home_manager_version">Wersja menedżera</string>
    <string name="home_fingerprint">Odcisk</string>

    <string name="home_selinux_status">Status SELinux</string>
    <string name="selinux_status_disabled">Wyłączony</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Nieznany</string>
    <string name="superuser">Superużytkownik</string>
    <string name="module_failed_to_enable">Nie udało się włączyć modułu: %s</string>
    <string name="module_failed_to_disable">Nie udało się wyłączyć modułu: %s</string>
    <string name="module_empty">Brak zainstalowanych modułów</string>

    <string name="module">Moduł</string>
    <string name="uninstall">Odinstaluj</string>
    <string name="module_install">Instaluj</string>
    <string name="install">Instaluj</string>
    <string name="reboot">Restartuj</string>
    <string name="settings">Ustawienia</string>
    <string name="reboot_userspace">Miękki restart</string>
    <string name="reboot_recovery">Restart do trybu Recovery</string>
    <string name="reboot_bootloader">Restart do trybu Bootloader</string>
    <string name="reboot_download">Restart do trybu Download</string>
    <string name="reboot_edl">Restart do trybu EDL</string>
    <string name="about">Informacje</string>
    <string name="module_uninstall_confirm">Czy na pewno chcesz odinstalować moduł %s?</string>
    <string name="module_uninstall_success">Odinstalowano %s</string>
    <string name="module_uninstall_failed">Nie udało się odinstalować:: %s</string>
    <string name="module_version">Wersja</string>
    <string name="module_author">Autor</string>
    <string name="module_overlay_fs_not_available">overlayfs jest niedostępny, moduł nie zadziała!</string>
    <string name="refresh">Odśwież</string>
    <string name="show_system_apps">Pokaż aplikacje systemowe</string>
    <string name="hide_system_apps">Ukryj aplikacje systemowe</string>
    <string name="send_log">Wyślij log</string>
    <string name="safe_mode">Tryb bezpieczny</string>
    <string name="reboot_to_apply">Uruchom ponownie, aby zastosować zmiany</string>
    <string name="module_magisk_conflict">Moduły są wyłączone, ponieważ są w konflikcie z modułami Magiska!</string>
    <string name="home_learn_kernelsu">Poznaj KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Dowiedz się jak zainstalować KernelSU i jak korzystać z modułów.</string>
    <string name="home_support_title">Wesprzyj nas</string>
    <string name="home_support_content">KernelSU jest i zawsze będzie darmowy oraz otwarty. Niemniej jednak możesz nam pokazać, że Ci zależy, wysyłając darowiznę.</string>
    <string name="about_source_code"><![CDATA[Przejrzyj kod źródłowy na %1$s<br/>Dołącz do kanału %2$s]]></string>
    <string name="profile" translatable="false">Profil aplikacji</string>
    <string name="profile_default">Domyślny</string>
    <string name="profile_template">Szablon</string>
    <string name="profile_custom">Własny</string>
    <string name="profile_name">Nazwa profilu</string>
    <string name="profile_namespace">Przestrzeń nazw montowania</string>
    <string name="profile_namespace_inherited">Odziedziczona</string>
    <string name="profile_namespace_global">Globalna</string>
    <string name="profile_namespace_individual">Indywidualna</string>
    <string name="profile_groups">Grupy</string>
    <string name="profile_capabilities">Uprawnienia</string>
    <string name="profile_selinux_context">Kontekst SELinux</string>
    <string name="profile_umount_modules">Odmontuj moduły</string>
    <string name="failed_to_update_app_profile">Nie udało się zaktualizować profilu aplikacji dla %s</string>
    <string name="settings_umount_modules_default">Domyślnie odmontuj moduły</string>
    <string name="settings_umount_modules_default_summary">Globalna wartość domyślna opcji \"Odmontuj moduły\" w profilach aplikacji. Jeśli jest włączona, odwraca wszystkie modyfikacje dokonane przez moduły dla aplikacji, które nie mają ustawionego profilu.</string>
    <string name="profile_umount_modules_summary">Włączenie tej opcji umożliwi KernelSU przywrócenie wszelkich zmodyfikowanych plików przez moduły dla tej aplikacji.</string>
    <string name="profile_selinux_domain">Domena</string>
    <string name="profile_selinux_rules">Reguły</string>
    <string name="module_update">Zaktualizuj</string>
    <string name="module_downloading">Pobieranie modułu: %s</string>
    <string name="module_start_downloading">Rozpocznij pobieranie: %s</string>
    <string name="new_version_available">Nowa wersja: %s jest dostępna, kliknij, aby pobrać</string>
    <string name="launch_app">Uruchom</string>
    <string name="force_stop_app">Wymuś zatrzymanie</string>
    <string name="restart_app">Restartuj</string>
    <string name="failed_to_update_sepolicy">Nie udało się zaktualizować reguł SELinux dla: %s</string>
</resources>

```

`manager/app/src/main/res/values-pt-rBR/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Início</string>
    <string name="home_not_installed">Não instalado</string>
    <string name="home_click_to_install">Clique para instalar</string>
    <string name="home_working">Em Execução</string>
    <string name="home_working_version">Versão: %d</string>
    <string name="home_superuser_count">Superusuários: %d</string>
    <string name="home_module_count">Módulos: %d</string>
    <string name="home_unsupported">Sem Suporte</string>
    <string name="home_unsupported_reason">Por enquanto, KernelSU suporta apenas kernels GKI</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Versão do gerenciador</string>
    <string name="home_fingerprint">Impressão digital</string>
    <string name="home_selinux_status">Status do SELinux</string>
    <string name="selinux_status_disabled">Desabilitado</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissivo</string>
    <string name="selinux_status_unknown">Desconhecido</string>
    <string name="superuser">Superusuário</string>
    <string name="module_failed_to_enable">Falha ao ativar o módulo: %s</string>
    <string name="module_failed_to_disable">Falha ao desativar o módulo: %s</string>
    <string name="module_empty">Nenhum módulo instalado</string>
    <string name="module">Módulos</string>
    <string name="uninstall">Desinstalar</string>
    <string name="module_install">Instalar</string>
    <string name="install">Instalar</string>
    <string name="reboot">Reiniciar</string>
    <string name="settings">Configurações</string>
    <string name="reboot_userspace">Reinicialização suave</string>
    <string name="reboot_recovery">Reiniciar para recuperação</string>
    <string name="reboot_bootloader">Reiniciar para bootloader</string>
    <string name="reboot_download">Reiniciar para download</string>
    <string name="reboot_edl">Reiniciar para EDL</string>
    <string name="about">Sobre</string>
    <string name="module_uninstall_confirm">Tem certeza de que deseja desinstalar o módulo %s?</string>
    <string name="module_uninstall_success">%s desinstalado</string>
    <string name="module_uninstall_failed">Falha ao desinstalar: %s</string>
    <string name="module_version">Versão</string>
    <string name="module_author">Autor</string>
    <string name="module_overlay_fs_not_available">overlayfs não está disponível, o módulo não funcionará!</string>
    <string name="refresh">Atualizar</string>
    <string name="show_system_apps">Mostrar aplicativos do sistema</string>
    <string name="hide_system_apps">Ocultar aplicativos do sistema</string>
    <string name="send_log">Enviar log</string>
    <string name="safe_mode">Modo de segurança</string>
    <string name="reboot_to_apply">Reinicie para entrar em vigor</string>
    <string name="module_magisk_conflict">Os módulos estão desativados porque entraram em conflito com o Magisk\'s!</string>
    <string name="home_learn_kernelsu">Leia mais sobre KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Saiba como instalar o KernelSU e usar os módulos</string>
    <string name="home_support_title">Apoie-nos</string>
    <string name="home_support_content">O KernelSU é, e sempre será, gratuito e de código aberto. No entanto, você pode mostrar seu apoio fazendo uma doação.</string>
    <string name="about_source_code"><![CDATA[Veja o código-fonte no %1$s<br/>Junte-se ao nosso canal do %2$s]]></string>
    <string name="profile" translatable="false">Perfil do Aplicativo</string>
    <string name="profile_default">Padrão</string>
    <string name="profile_template">Modelo</string>
    <string name="profile_custom">Personalizado</string>
    <string name="profile_name">Nome do perfil</string>
    <string name="profile_namespace">Montar namespace</string>
    <string name="profile_namespace_inherited">Herdada</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Grupos</string>
    <string name="profile_capabilities">Permissões</string>
    <string name="profile_selinux_context">Contexto do SELinux</string>
    <string name="profile_umount_modules">Módulos não montados</string>
    <string name="failed_to_update_app_profile">Falha ao atualizar o perfil do aplicativo para %s</string>
    <string name="settings_umount_modules_default">Não montar módulos por padrão</string>
    <string name="settings_umount_modules_default_summary">O valor padrão global para \"Módulos não montados\" em perfis de aplicativos. Se ativado, removerá todas as modificações do módulo do sistema para aplicativos que não possuem um perfil definido.</string>
    <string name="profile_umount_modules_summary">Ativar esta opção permitirá que o KernelSU restaure quaisquer arquivos modificados pelos módulos para este aplicativo.</string>
    <string name="profile_selinux_domain">Domínio</string>
    <string name="profile_selinux_rules">Regras</string>
    <string name="module_update">Atualizar</string>
    <string name="module_downloading">Baixando módulo: %s</string>
    <string name="module_start_downloading">Comece a baixar: %s</string>
    <string name="new_version_available">Nova versão: %s está disponível, clique para baixar</string>
    <string name="launch_app">Iniciar</string>
    <string name="force_stop_app">Forçar parada</string>
    <string name="restart_app">Reiniciar</string>
    <string name="failed_to_update_sepolicy">Falha ao atualizar as regras do SELinux para: %s</string>
</resources>
```

`manager/app/src/main/res/values-pt/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_not_installed">Não instalado</string>
    <string name="home">Início</string>
    <string name="home_click_to_install">Clique para instalar</string>
    <string name="home_working">Funcionando</string>
    <string name="home_superuser_count">Super Usuário: %d</string>
    <string name="home_module_count">Módulos: %d</string>
    <string name="home_working_version">Versão: %d</string>
    <string name="home_kernel">Kernel</string>
    <string name="install">Instalar</string>
    <string name="home_unsupported">Sem suporte</string>
    <string name="home_unsupported_reason">KernelSU suporta apenas kernels GKI agora</string>
    <string name="home_selinux_status">Status do SELinux</string>
    <string name="home_manager_version">Versão do aplicativo</string>
    <string name="module_failed_to_disable">Falha ao desativar o módulo: %s</string>
    <string name="home_fingerprint">Impressão digital</string>
    <string name="selinux_status_disabled">Desabilitado</string>
    <string name="selinux_status_enforcing">Impondo</string>
    <string name="selinux_status_permissive">Permissivo</string>
    <string name="selinux_status_unknown">Desconhecido</string>
    <string name="superuser">Super Usuário</string>
    <string name="module_failed_to_enable">Falha ao ativar o módulo: %s</string>
    <string name="module_empty">Nenhum módulo instalado</string>
    <string name="uninstall">Desinstalar</string>
    <string name="module">Modulos</string>
    <string name="reboot">Reiniciar</string>
    <string name="module_install">Instalar</string>
    <string name="reboot_userspace">Reinicialização Suave</string>
    <string name="settings">Configurações</string>
    <string name="reboot_bootloader">Reinicializar modo Bootloader</string>
    <string name="reboot_recovery">Reiniciar modo recuperação</string>
    <string name="module_uninstall_failed">Falha ao desinstalar: %s</string>
    <string name="module_version">Versão</string>
    <string name="module_author">Autor</string>
    <string name="refresh">Atualizar</string>
    <string name="hide_system_apps">Esconder apps do sistema</string>
    <string name="reboot_download">Reiniciar para baixar</string>
    <string name="reboot_edl">Reiniciar em EDL</string>
    <string name="module_uninstall_confirm">Tem certeza de que deseja desinstalar o módulo %s\?</string>
    <string name="about">Sobre</string>
    <string name="module_overlay_fs_not_available">overlayfs não está disponível, o módulo não pode funcionar!</string>
    <string name="send_log">Enviar log</string>
    <string name="module_uninstall_success">%s desinstalado</string>
    <string name="show_system_apps">Mostrar aplicativos do sistema</string>
    <string name="home_click_to_learn_kernelsu">Aprenda a instalar o KernelSU e usar os módulos</string>
    <string name="home_support_content">O KernelSU é, e sempre será, gratuito e de código aberto. No entanto, você pode nos mostrar que se importa fazendo uma doação.</string>
    <string name="about_source_code">Veja o código-fonte em %1$s<br/>Junte-se ao nosso canal %2$s</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_inherited">Herdado</string>
    <string name="profile_default">Padrão</string>
    <string name="profile_template">Modelo</string>
    <string name="profile_custom">Personalizado</string>
    <string name="profile_name">Nome do perfil</string>
    <string name="profile_namespace">Montar namespace</string>
    <string name="safe_mode">Modo de segurança</string>
    <string name="reboot_to_apply">Reinicie para entrar em vigor</string>
    <string name="home_learn_kernelsu">Aprender KernelSU</string>
    <string name="module_magisk_conflict">Os módulos estão desativados porque estão em conflito com os do Magisk!</string>
    <string name="home_support_title">Apoie-nos</string>
    <string name="profile_groups">Grupos</string>
    <string name="profile_capabilities">Capacidades</string>
    <string name="profile_selinux_context">contexto SELinux</string>
    <string name="profile_selinux_domain">Domínio</string>
    <string name="module_update">Atualização</string>
    <string name="profile_umount_modules">Desativar modulos</string>
    <string name="failed_to_update_app_profile">Falha ao atualizar o perfil do aplicativo para %s</string>
    <string name="settings_umount_modules_default">Módulos desativados por padrão</string>
    <string name="settings_umount_modules_default_summary">O valor padrão global para \"Módulos Umount\" em Perfis de Aplicativos. Se ativado, removerá todas as modificações de módulo do sistema para aplicativos que não possuem um Perfil definido.</string>
    <string name="profile_selinux_rules">Regras</string>
    <string name="profile_umount_modules_summary">Ativar esta opção permitirá que o KernelSU restaure quaisquer arquivos modificados pelos módulos para este aplicativo.</string>
    <string name="module_start_downloading">Iniciar o download: %s</string>
    <string name="module_downloading">Baixando módulo: %s</string>
    <string name="failed_to_update_sepolicy">Falha ao atualizar as regras do SELinux para: %s</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="restart_app">Reiniciar</string>
    <string name="launch_app">Lançar</string>
    <string name="force_stop_app">Forçar parada</string>
    <string name="new_version_available">Nova versão: %s está disponível, clique para baixar</string>
</resources>
```

`manager/app/src/main/res/values-ro/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Acasă</string>
    <string name="home_not_installed">Nu este instalat</string>
    <string name="home_click_to_install">Click pentru a instala</string>
    <string name="home_working">Funcționează</string>
    <string name="home_working_version">Versiune: %d</string>
    <string name="home_superuser_count">Superuseri: %d</string>
    <string name="home_module_count">Module: %d</string>
    <string name="home_unsupported">Necompatibil</string>
    <string name="home_unsupported_reason">KernelSU suportă doar nuclee GKI acum</string>
    <string name="home_kernel">Nucleu</string>
    <string name="home_manager_version">Versiune Manager</string>
    <string name="home_fingerprint">Amprentă</string>
    <string name="home_selinux_status">Stare SELinux</string>
    <string name="selinux_status_disabled">Dezactivat</string>
    <string name="selinux_status_enforcing">Obligatoriu</string>
    <string name="selinux_status_permissive">Permisiv</string>
    <string name="selinux_status_unknown">Necunoscut</string>
    <string name="superuser">Superutilizator</string>
    <string name="module_failed_to_enable">Activarea modulului %s a eșuat</string>
    <string name="module_failed_to_disable">Dezactivarea modulului %s a eșuat</string>
    <string name="module_empty">Niciun modul instalat</string>
    <string name="module">Module</string>
    <string name="uninstall">Dezinstalează</string>
    <string name="module_install">Instalează</string>
    <string name="install">Instalează</string>
    <string name="reboot">Repornește</string>
    <string name="settings">Setări</string>
    <string name="reboot_userspace">Repornire rapidă</string>
    <string name="reboot_recovery">Repornire în Recuperare</string>
    <string name="reboot_bootloader">Repornire în Bootloader</string>
    <string name="reboot_download">Repornire în Download</string>
    <string name="reboot_edl">Repornire în EDL</string>
    <string name="about">Despre</string>
    <string name="module_uninstall_confirm">Sigur dorești să dezinstalezi modulul %s?</string>
    <string name="module_uninstall_success">%s dezinstalat</string>
    <string name="module_uninstall_failed">Dezinstalare eșuată: %s</string>
    <string name="module_version">Versiune</string>
    <string name="module_author">Autor</string>
    <string name="module_overlay_fs_not_available">overlayfs nu este disponibil, modulul nu poate funcționa!</string>
    <string name="refresh">Reîmprospătează</string>
    <string name="show_system_apps">Arată aplicațiile de sistem</string>
    <string name="hide_system_apps">Ascunde aplicațiile de sistem</string>
    <string name="send_log">Trimite jurnal</string>
    <string name="safe_mode">Mod sigur</string>
    <string name="reboot_to_apply">Repornește pentru ca modificările să intre în vigoare</string>
    <string name="module_magisk_conflict">Modulele sunt dezactivate deoarece sunt în conflict cu cele ale Magisk-ului!</string>
    <string name="home_learn_kernelsu">Află mai multe despre KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Află cum să instalezi KernelSU și să utilizezi module</string>
    <string name="home_support_title">Suport</string>
    <string name="home_support_content">KernelSU este, și va fi întotdeauna, gratuit și cu codul sursă deschis. Cu toate acestea, ne poți arăta că îți pasă făcând o donație.</string>
    <string name="about_source_code"><![CDATA[Vezi codul sursă la %1$s<br/>Alătură-te canalului nostru %2$s]]></string>
    <string name="profile_default">Implicit</string>
    <string name="profile_template">Șablon</string>
    <string name="profile_custom">Personalizat</string>
    <string name="profile_name">Nume profil</string>
    <string name="profile_namespace">Montare spațiu de nume</string>
    <string name="profile_namespace_inherited">Moștenit</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Grupuri</string>
    <string name="profile_capabilities">Capabilități</string>
    <string name="profile_selinux_context">Context SELinux</string>
    <string name="profile_umount_modules">Module u-montate</string>
    <string name="failed_to_update_app_profile">Nu s-a putut actualiza profilul aplicației pentru %s</string>
    <string name="settings_umount_modules_default">U-montează modulele în mod implicit</string>
    <string name="settings_umount_modules_default_summary">Valoarea implicită globală pentru „Module u-montate” în Profilurile aplicațiilor. Dacă este activat, va elimina toate modificările modulelor aduse sistemului pentru aplicațiile care nu au un profil setat.</string>
    <string name="profile_umount_modules_summary">Activarea acestei opțiuni va permite KernelSU să restaureze orice fișiere modificate de către modulele pentru această aplicație.</string>
    <string name="profile_selinux_domain">Domeniu</string>
    <string name="profile_selinux_rules">Reguli</string>
    <string name="module_update">Actualizează</string>
    <string name="module_downloading">Se descarcă modulul: %s</string>
    <string name="module_start_downloading">Începe descărcarea: %s</string>
    <string name="new_version_available">Versiune nouă: %s disponibilă, clic pentru a descărca</string>
    <string name="failed_to_update_sepolicy">Nu s-au reușit actualizările regulilor SELinux pentru: %s</string>
    <string name="launch_app">Lansare</string>
    <string name="force_stop_app">Oprire forțată</string>
    <string name="restart_app">Repornește</string>
</resources>
```

`manager/app/src/main/res/values-ru/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Главная</string>
    <string name="home_not_installed">Не установлен</string>
    <string name="home_click_to_install">Нажмите, чтобы установить</string>
    <string name="home_working">Работает</string>
    <string name="home_working_version">Версия: %d</string>
    <string name="home_superuser_count">Суперпользователи: %d</string>
    <!--Don't translate this string!-->
    <string name="home_module_count">Модули: %d</string>
    <string name="home_unsupported">Не поддерживается</string>
    <string name="home_unsupported_reason">KernelSU поддерживает только GKI ядра</string>
    <string name="home_kernel">Ядро</string>
    <string name="home_manager_version">Версия менеджера</string>
    <string name="home_fingerprint">Подпись</string>
    <string name="home_selinux_status">Состояние SELinux</string>
    <string name="selinux_status_disabled">Выключен</string>
    <string name="selinux_status_enforcing">Принудительный</string>
    <string name="selinux_status_permissive">Разрешающий</string>
    <string name="selinux_status_unknown">Неизвестно</string>
    <string name="superuser">Суперпользователь</string>
    <!--Don't translate this string!-->
    <string name="module_failed_to_enable">Не удалось включить модуль: %s</string>
    <string name="module_failed_to_disable">Не удалось отключить модуль: %s</string>
    <string name="module_empty">Нет установленных модулей</string>
    <string name="module">Модули</string>
    <string name="uninstall">Удалить</string>
    <string name="module_install">Установить</string>
    <string name="install">Установка</string>
    <string name="reboot">Перезагрузить</string>
    <string name="settings">Настройки</string>
    <string name="reboot_userspace">Мягкая перезагрузка</string>
    <string name="reboot_recovery">Перезагрузить в Recovery</string>
    <string name="reboot_bootloader">Перезагрузить в Bootloader</string>
    <string name="reboot_download">Перезагрузить в Download</string>
    <string name="reboot_edl">Перезагрузить в EDL</string>
    <string name="about">О приложении</string>
    <string name="module_uninstall_confirm">Вы уверены, что хотите удалить модуль %s?</string>
    <string name="module_uninstall_success">%s удален</string>
    <string name="module_uninstall_failed">Не удалось удалить: %s</string>
    <string name="module_version">Версия</string>
    <string name="module_author">Автор</string>
    <string name="module_overlay_fs_not_available">overlayfs недоступен, модуль не может работать!</string>
    <string name="refresh">Обновить</string>
    <string name="show_system_apps">Показать системные приложения</string>
    <string name="hide_system_apps">Скрыть системные приложения</string>
    <string name="send_log">Отправить лог</string>
    <string name="safe_mode">Безопасный режим</string>
    <string name="reboot_to_apply">Перезагрузите, чтобы изменения вступили в силу</string>
    <string name="module_magisk_conflict">Модули отключены, потому что они конфликтуют с Magisk!</string>
    <string name="home_learn_kernelsu">Узнайте о KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/ru_RU/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Узнайте, как установить KernelSU и использовать модули</string>
    <string name="home_support_title">Поддержите нас</string>
    <string name="home_support_content">KernelSU был и всегда будет бесплатным и открытым проектом. Однако Вы всегда можете поддержать нас, отправив небольшое пожертвование.</string>
    <string name="about_source_code"><![CDATA[Посмотреть исходный код на %1$s<br/>Присоединяйтесь к нашему %2$s каналу]]></string>
    <string name="profile" translatable="false">App Profile</string>
    <!--Don't translate this string!-->
    <string name="profile_default">По умолчанию</string>
    <string name="profile_template">Шаблон</string>
    <string name="profile_custom">Пользовательский</string>
    <string name="profile_name">Название профиля</string>
    <string name="profile_namespace">Монтировать пространство имен</string>
    <string name="profile_namespace_inherited">Унаследованный</string>
    <string name="profile_namespace_global">Глобальный</string>
    <string name="profile_namespace_individual">Индивидуальный</string>
    <string name="profile_groups">Группы</string>
    <string name="profile_capabilities">Возможности</string>
    <string name="profile_selinux_context">Контекст SELinux</string>
    <string name="profile_umount_modules">Размонтировать модули</string>
    <string name="failed_to_update_app_profile">Не удалось обновить App Profile для %s</string>
    <string name="settings_umount_modules_default">Размонтировать модули по умолчанию</string>
    <string name="settings_umount_modules_default_summary">Глобальное значение по умолчанию для \"Размонтировать модули\" в App Profile. При включении будут удалены все модификации модулей в системе для приложений, у которых не задан Profile.</string>
    <string name="profile_umount_modules_summary">Включение этой опции позволит KernelSU восстанавливать любые измененные модулями файлы для данного приложения.</string>
    <string name="profile_selinux_domain">Домен</string>
    <string name="profile_selinux_rules">Правила</string>
    <string name="module_update">Обновить</string>
    <string name="module_downloading">Скачивание модуля: %s</string>
    <string name="module_start_downloading">Начало скачивания: %s</string>
    <string name="new_version_available">Новая версия: %s доступна, нажмите, чтобы скачать</string>
    <string name="force_stop_app">Принудительно остановить</string>
    <string name="failed_to_update_sepolicy">Не удалось обновить правила SELinux для %s</string>
    <string name="launch_app">Запустить</string>
    <string name="restart_app">Перезапустить</string>
</resources>
```

`manager/app/src/main/res/values-th/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">หน้าหลัก</string>
    <string name="home_not_installed">ยังไม่ได้ติดตั้ง</string>
    <string name="home_click_to_install">กดเพื่อติดตั้ง</string>
    <string name="home_working">กำลังทำงาน</string>
    <string name="home_working_version">เวอร์ชั่น: %d</string>
    <string name="home_manager_version">เวอร์ชั่นตัวจัดการ</string>
    <string name="home_superuser_count">สิทธิ์ผู้ใช้ขั้นสูง: %d</string>
    <string name="home_module_count">โมดูล: %d</string>
    <string name="home_unsupported">ไม่รองรับ</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="reboot_recovery">รีบูตเข้าสู่โหมดกู้คืน</string>
    <string name="reboot_userspace">ซอฟต์รีบูต</string>
    <string name="home_unsupported_reason">ตอนนี้ KernelSU รองรับเคอร์เนลประเภท GKI เท่านั้น</string>
    <string name="home_kernel">เคอร์เนล</string>
    <string name="selinux_status_disabled">ปิดใช้งาน</string>
    <string name="home_fingerprint">ลายนิ้วมือ</string>
    <string name="home_selinux_status">สถานะ SELinux</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">ไม่ทราบ</string>
    <string name="superuser">สิทธิ์ผู้ใช้ขั้นสูง</string>
    <string name="module_failed_to_enable">ล้มเหลวในการเปิดใช้งานโมดูล: %s</string>
    <string name="module_failed_to_disable">ล้มเหลวในการปิดใช้งานโมดูล: %s</string>
    <string name="module_empty">ไม่มีโมดูลที่ติดตั้ง</string>
    <string name="module">โมดูล</string>
    <string name="uninstall">ถอนการติดตั้ง</string>
    <string name="settings">ตั้งค่า</string>
    <string name="module_install">ติดตั้ง</string>
    <string name="install">ติดตั้ง</string>
    <string name="reboot">รีบูต</string>
    <string name="reboot_bootloader">รีบูตเข้าสู่โหมด Bootloader</string>
    <string name="about">เกี่ยวกับ</string>
    <string name="reboot_download">รีบูตเข้าสู่โหมด Download</string>
    <string name="reboot_edl">รีบูตเข้าสู่โหมด EDL</string>
    <string name="module_uninstall_success">%s ถอนการติดตั้งสำเร็จ</string>
    <string name="module_uninstall_failed">ล้มเหลวในการถอนการติดตั้ง: %s</string>
    <string name="module_overlay_fs_not_available">overlayfs ไม่สามารถใช้งานได้ โมดูลหยุดทำงาน!</string>
    <string name="module_uninstall_confirm">คุณแน่ใจว่าจะถอนการติดตั้งโมดูล %s หรือไม่\?</string>
    <string name="module_author">ผู้สร้าง</string>
    <string name="module_version">เวอร์ชั่น</string>
    <string name="show_system_apps">แสดงแอประบบ</string>
    <string name="hide_system_apps">ซ่อนแอประบบ</string>
    <string name="refresh">รีเฟรช</string>
    <string name="send_log">ส่ง Log</string>
    <string name="safe_mode">โหมดปลอดภัย</string>
    <string name="reboot_to_apply">รีบูตเพื่อให้มีผล</string>
    <string name="module_magisk_conflict">โมดูลถูกปิดใช้งานเนื่องจากขัดแย้งกับ Magisk!</string>
    <string name="home_learn_kernelsu">เรียนรู้เกี่ยวกับ KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">เรียนรู้วิธีการติดตั้ง KernelSU และวิธีใช้งานโมดูลต่าง ๆ</string>
    <string name="home_support_title">สนับสนุนพวกเรา</string>
    <string name="home_support_content">KernelSU เป็นโอเพ่นซอร์สฟรีและจะเป็นตลอดไป อย่างไรก็ตาม คุณสามารถแสดงความห่วงใยได้ด้วยการบริจาค</string>
    <string name="about_source_code">ดูซอร์สโค้ดที่ %1$s<br/> และเข้าร่วมช่อง %2$s ของเรา</string>
    <string name="profile_custom">กำหนดเอง</string>
    <string name="profile_default">ค่าเริ่มต้น</string>
    <string name="profile_template">เทมเพลต</string>
    <string name="profile_name">ชื่อโปรไฟล์</string>
    <string name="profile_namespace">Mount เนมสเปซ</string>
    <string name="profile_namespace_global">ทั่วไป</string>
    <string name="profile_namespace_inherited">การสืบทอด</string>
    <string name="profile_namespace_individual">ส่วนบุคคล</string>
    <string name="profile_groups">หมวดหมู่</string>
    <string name="profile_capabilities">ความสามารถของแอป</string>
    <string name="profile_umount_modules_summary">การเปิดใช้งานตัวเลือกนี้จะทำให้ KernelSU สามารถกู้คืนไฟล์ที่แก้ไขโดยโมดูลสำหรับแอปพลิเคชั่นนี้ได้</string>
    <string name="profile_selinux_context">บริบท SELinux</string>
    <string name="profile_umount_modules">Umount โมดูล</string>
    <string name="failed_to_update_app_profile">ไม่สามารถอัปเดตโปรไฟล์แอปสำหรับ %s ได้</string>
    <string name="settings_umount_modules_default">Umount โมดูลตามค่าเริ่มต้น</string>
    <string name="profile_selinux_domain">โดเมน</string>
    <string name="module_update">อัปเดต</string>
    <string name="profile_selinux_rules">กฎ</string>
    <string name="module_downloading">กำลังดาวน์โหลดโมดูล: %s</string>
    <string name="module_start_downloading">กำลังเริ่มดาวน์โหลด: %s</string>
    <string name="new_version_available">เวอร์ชั่นใหม่: %s พร้อมใช้งาน คลิกเพื่อดาวน์โหลด</string>
    <string name="force_stop_app">บังคับหยุด</string>
    <string name="restart_app">รีสตาร์ท</string>
    <string name="settings_umount_modules_default_summary">หากเปิดใช้งานค่าเริ่มต้นโดยทั่วไปสำหรับ \"Umount โมดูล\" ในโปรไฟล์แอป จะเป็นการลบการแก้ไขโมดูลทั้งหมดในระบบสำหรับแอปพลิเคชั่นที่ไม่มีการตั้งค่าโปรไฟล์</string>
    <string name="launch_app">เปิด</string>
    <string name="failed_to_update_sepolicy">ไม่สามารถอัปเดตกฎ SElinux สำหรับ: %s ได้</string>
</resources>
```

`manager/app/src/main/res/values-tr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Ana menü</string>
    <string name="home_not_installed">Yüklü değil</string>
    <string name="home_click_to_install">Yüklemek için tıkla</string>
    <string name="home_working">Çalışıyor</string>
    <string name="home_working_version">Sürüm: %d</string>
    <string name="home_superuser_count">Süper kullanıcılar: %d</string>
    <string name="home_module_count">Modüller: %d</string>
    <string name="home_unsupported">Desteklenmiyor</string>
    <string name="home_unsupported_reason">KernelSU şu an yalnızca GKI çekirdeklerini destekliyor</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Yönetici Sürümü</string>
    <string name="home_fingerprint">Parmak İzi</string>
    <string name="home_selinux_status">SELinux Durumu</string>
    <string name="selinux_status_disabled">Devre dışı</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Bilinmiyor</string>
    <string name="superuser">Süper kullanıcı</string>
    <string name="module_failed_to_enable">Modül etkinleştirilemedi: %s</string>
    <string name="module_failed_to_disable">Modül devre dışı bırakılamadı: %s</string>
    <string name="module_empty">Yüklü modül yok</string>
    <string name="module">Modül</string>
    <string name="uninstall">Kaldır</string>
    <string name="module_install">Yükle</string>
    <string name="install">Yükle</string>
    <string name="reboot">Cihazı yeniden başlat</string>
    <string name="settings">Ayarlar</string>
    <string name="reboot_userspace">Hızlı yeniden başlat</string>
    <string name="reboot_recovery">Kurtarma modunda başlat</string>
    <string name="reboot_bootloader">Bootloader modunda başlat</string>
    <string name="reboot_download">İndirme modunda başlat</string>
    <string name="reboot_edl">EDL modunda başlat</string>
    <string name="about">Hakkında</string>
    <string name="module_uninstall_confirm">%s modülünü kaldırmak istediğinizden emin misiniz?</string>
    <string name="module_uninstall_success">%s kaldırıldı</string>
    <string name="module_uninstall_failed">%s kaldırılamadı</string>
    <string name="module_version">Sürüm</string>
    <string name="module_author">Geliştirici</string>
    <string name="module_overlay_fs_not_available">overlayfs mevcut değil, modül çalışamaz!</string>
    <string name="refresh">Yenile</string>
    <string name="show_system_apps">Sistem uygulamalarını göster</string>
    <string name="hide_system_apps">Sistem uygulamalarını gizle</string>
    <string name="send_log">Log gönder</string>
    <string name="safe_mode">Güvenli mod</string>
    <string name="reboot_to_apply">Değişiklilerin kaydedilmesi için cihazı yeniden başlat</string>
    <string name="module_magisk_conflict">Modüller Magisk ile çakıştığı için devre dışı bırakıldı!</string>
    <string name="home_learn_kernelsu">KernelSU\'yu öğren</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">KernelSU\'yu nasıl kuracağınızı ve modülleri nasıl kullanacağınızı öğrenin</string>
    <string name="home_support_title">Bizi destekle</string>
    <string name="home_support_content">KernelSU ücretsiz ve açık kaynaktır ve her zaman öyle kalacaktır. Ancak bağış yaparak bize değer verdiğinizi gösterebilirsiniz.</string>
    <string name="about_source_code"><![CDATA[%1$s kaynak kodunu görüntüle<br/>%2$s kanalımıza katılın]]></string>
    <string name="profile">Uygulama profili</string>
    <string name="profile_default">Varsayılan</string>
    <string name="profile_template">Örnek</string>
    <string name="profile_custom">Özel</string>
    <string name="profile_name">Profil adı</string>
    <string name="profile_namespace">Ad alanını bağla</string>
    <string name="profile_namespace_inherited">Kalıtsal</string>
    <string name="profile_namespace_global">Küresel</string>
    <string name="profile_namespace_individual">Bireysel</string>
    <string name="profile_groups">Gruplar</string>
    <string name="profile_capabilities">Yetkiler</string>
    <string name="profile_selinux_context">SELinux içeriği</string>
    <string name="profile_umount_modules">Modüllerin bağlantısını kes</string>
    <string name="failed_to_update_app_profile">%s için uygulama profili güncellenemedi.</string>
    <string name="settings_umount_modules_default">Varsayılan olarak modüllerin bağlantısını kesin</string>
    <string name="settings_umount_modules_default_summary">Uygulama profillerindeki \"Modüllerin bağlantısını kes\" seçeneği için varsayılan değer. Etkinleştirilirse, profil ayarı yapılmamış uygulamalar için modüllerin sistemde yaptığı tüm değişiklikler kaldırılacaktır.</string>
    <string name="profile_umount_modules_summary">Bu seçeneğin etkinleştirilmesi ile, bu uygulama için modüller tarafından değiştirilen tüm dosyaların KernelSU tarafından geri alınmasına izin verilecektir.</string>
    <string name="profile_selinux_domain">Ad alanı</string>
    <string name="profile_selinux_rules">Kurallar</string>
    <string name="module_update">Güncelle</string>
    <string name="module_downloading">Modül indiriliyor: %s</string>
    <string name="module_start_downloading">İndirme başladı: %s</string>
    <string name="new_version_available">Yeni sürüm: %s mevcut, indirmek için tıklayın</string>
    <string name="launch_app">Uygulamayı çalıştır</string>
    <string name="force_stop_app">Uygulamayı durmaya zorla</string>
    <string name="restart_app">Uygulamayı yeniden başlat</string>
    <string name="failed_to_update_sepolicy">%s için SELinux kuralları güncellenemedi</string>
</resources>
```

`manager/app/src/main/res/values-uk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Головна</string>
    <string name="home_not_installed">Не встановлено</string>
    <string name="home_click_to_install">Натисніть щоб встановити</string>
    <string name="home_working">Працює</string>
    <string name="home_working_version">Версія: %d</string>
    <string name="home_superuser_count">Суперкористувачі: %d</string>
    <string name="home_module_count">Модулі: %d</string>
    <string name="home_unsupported">Не підтримується</string>
    <string name="home_unsupported_reason">KernelSU підтримує лише ядра GKI</string>
    <string name="home_kernel">Ядро</string>
    <string name="home_manager_version">Версія менеджера</string>
    <string name="home_fingerprint">Відбиток</string>
    <string name="home_selinux_status">Статус SELinux</string>
    <string name="selinux_status_disabled">Вимкнено</string>
    <string name="selinux_status_enforcing">Примусовий</string>
    <string name="selinux_status_permissive">Дозвільний</string>
    <string name="selinux_status_unknown">Невідомо</string>
    <string name="superuser">Суперкористувачі</string>
    <string name="module_failed_to_enable">Не вдалося ввімкнути модуль: %s</string>
    <string name="module_failed_to_disable">Не вдалося вимкнути модуль: %s</string>
    <string name="module_empty">Немає встановлених модулів</string>
    <string name="module">Модулі</string>
    <string name="uninstall">Видалити</string>
    <string name="module_install">Встановити</string>
    <string name="install">Встановити</string>
    <string name="reboot">Перезавантажити</string>
    <string name="settings">Налаштування</string>
    <string name="reboot_userspace">М\'яке перезавантаження</string>
    <string name="reboot_recovery">Перезавантажити до Recovery</string>
    <string name="reboot_bootloader">Перезавантажити до Bootloader</string>
    <string name="reboot_download">Перезавантажити до Download</string>
    <string name="reboot_edl">Перезавантажити до EDL</string>
    <string name="about">Про додаток</string>
    <string name="module_uninstall_confirm">Ви впевнені, що хочете видалити модуль %s?</string>
    <string name="module_uninstall_success">%s видалено</string>
    <string name="module_uninstall_failed">Не вдалося видалити: %s</string>
    <string name="module_version">Версія</string>
    <string name="module_author">Автор</string>
    <string name="module_overlay_fs_not_available">overlayfs не доступний, модуль не може працювати!</string>
    <string name="refresh">Оновити</string>
    <string name="show_system_apps">Показати системні додатки</string>
    <string name="hide_system_apps">Сховати системні додатки</string>
    <string name="send_log">Надіслати лог</string>
    <string name="safe_mode">Безпечний режим</string>
    <string name="reboot_to_apply">Перезавантажте, щоб застосувати</string>
    <string name="module_magisk_conflict">Модулі вимкнено, оскільки вони конфліктують із модулями Magisk!</string>
    <string name="home_learn_kernelsu">Дізнайтеся про KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Дізнайтеся, як інсталювати KernelSU і використовувати модулі</string>
    <string name="home_support_title">Підтримати нас</string>
    <string name="home_support_content">KernelSU є, і завжди буде безкоштовним та з відкритим кодом. Однак, якщо вам не байдуже, можете зробити невеличке пожертвування.</string>
    <string name="about_source_code"><![CDATA[Переглянути вихідний код на %1$s<br/>Приєднуйтесь до нашого каналу %2$s]]></string>
    <string name="profile">Профіль додатка</string>
    <string name="profile_default">Типовий</string>
    <string name="profile_template">Шаблон</string>
    <string name="profile_custom">Власний</string>
    <string name="profile_name">Назва профілю</string>
    <string name="profile_namespace">Монтування простору імен</string>
    <string name="profile_namespace_inherited">Наслідуваний</string>
    <string name="profile_namespace_global">Глобальний</string>
    <string name="profile_namespace_individual">Індивідуальний</string>
    <string name="profile_groups">Групи</string>
    <string name="profile_capabilities">Можливості</string>
    <string name="profile_selinux_context">Контекст SELinux</string>
    <string name="profile_umount_modules">Розмонтувати модулі</string>
    <string name="failed_to_update_app_profile">Не вдалося оновити профіль додатка для %s</string>
    <string name="settings_umount_modules_default">Розмонтувати модулі за замовчуванням</string>
    <string name="settings_umount_modules_default_summary">Загальне значення за замовчуванням для \"Розмонтувати модулі\" у профілях додатків. Якщо ввімкнено, буде видалено всі модифікації модулів у системі для додатків, які не мають встановленого профілю.</string>
    <string name="profile_umount_modules_summary">Увімкнення даної опції дозволить KernelSU відновити для цього додатка будь-які файли, змінені модулями.</string>
    <string name="profile_selinux_domain">Домен</string>
    <string name="profile_selinux_rules">Правила</string>
    <string name="module_update">Оновити</string>
    <string name="module_downloading">Завантаження модуля: %s</string>
    <string name="module_start_downloading">Початок завантаження: %s</string>
    <string name="launch_app">Запустити</string>
    <string name="force_stop_app">Примусово зупинити</string>
    <string name="restart_app">Перезапустити</string>
    <string name="new_version_available">Нова версія: %s доступна, натисніть, щоб завантажити</string>
    <string name="failed_to_update_sepolicy">Не вдалося оновити правила SELinux для: %s</string>
</resources>
```

`manager/app/src/main/res/values-vi/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="profile">Hồ sơ ứng dụng</string>
    <string name="profile_default">Mặc định</string>
    <string name="profile_template">Mẫu</string>
    <string name="profile_custom">Tuỳ chỉnh</string>
    <string name="profile_name">Tên hồ sơ</string>
    <string name="profile_groups">Nhóm</string>
    <string name="failed_to_update_app_profile">Không thể cập nhật Hồ sơ ứng dụng cho %s</string>
    <string name="settings_umount_modules_default">Ngắt mô-đun theo mặc định</string>
    <string name="settings_umount_modules_default_summary">Giá trị mặc định của \"Ngắt mô-đun\" trong Cấu hình ứng dụng. Nếu bật, KernelSU sẽ khôi phục mọi tệp hệ thống đã sửa đổi bởi mô-đun cho các ứng dụng chưa thiết lập Cấu hình.</string>
    <string name="profile_umount_modules_summary">Bật tùy chọn này sẽ khôi phục mọi tệp đã sửa đổi bởi các mô-đun cho ứng dụng này.</string>
    <string name="module_update">Cập nhật</string>
    <string name="module_downloading">Đang tải xuống mô-đun: %s</string>
    <string name="module_start_downloading">Bắt đầu tải xuống: %s</string>
    <string name="new_version_available">Đã có phiên bản mới: %s, nhấn để tải xuống</string>
    <string name="home_learn_kernelsu">Tìm hiểu KernelSU</string>
    <string name="home_click_to_learn_kernelsu">Tìm hiểu cách cài đặt KernelSU và sử dụng các mô-đun</string>
    <string name="home_support_title">Hỗ trợ chúng tôi</string>
    <string name="home_support_content">KernelSU sẽ luôn luôn miễn phí và mã nguồn mở. Tuy nhiên bạn có thể ủng hộ chúng tôi bằng một khoản đóng góp nhỏ.</string>
    <string name="about_source_code"><![CDATA[Xem mã nguồn tại %1$s<br/>Tham gia kênh %2$s của chúng tôi]]></string>
    <string name="module_magisk_conflict">Các mô-đun bị vô hiệu hóa vì chúng xung đột với Magisk!</string>
    <string name="module_uninstall_confirm">Bạn có muốn gỡ cài đặt mô-đun %s không\?</string>
    <string name="send_log">Gửi nhật ký</string>
    <string name="home">Trang chủ</string>
    <string name="home_not_installed">Chưa cài đặt</string>
    <string name="home_click_to_install">Nhấn để cài dặt</string>
    <string name="home_working">Đang hoạt động</string>
    <string name="home_working_version">Phiên bản: %d</string>
    <string name="home_unsupported">Không được hỗ trợ</string>
    <string name="home_unsupported_reason">KernelSU hiện tại chỉ hỗ trợ kernel GKI</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Phiên bản Manager</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">Trạng thái SELinux</string>
    <string name="selinux_status_disabled">Vô hiệu hóa</string>
    <string name="selinux_status_enforcing">Thực thi</string>
    <string name="selinux_status_permissive">Cho phép</string>
    <string name="selinux_status_unknown">Không rõ</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Không thể kích hoạt mô-đun: %s</string>
    <string name="module_failed_to_disable">Không thể vô hiệu hóa mô-đun: %s</string>
    <string name="module_empty">Chưa có mô-đun nào được cài đặt</string>
    <string name="module">Mô-đun</string>
    <string name="uninstall">Gỡ cài đặt</string>
    <string name="module_install">Cài đặt</string>
    <string name="install">Cài đặt</string>
    <string name="reboot">Khởi động lại</string>
    <string name="settings">Cài đặt</string>
    <string name="reboot_userspace">Khởi động mềm</string>
    <string name="reboot_recovery">Khởi động lại vào Recovery</string>
    <string name="reboot_bootloader">Khởi động lại vào Bootloader</string>
    <string name="reboot_download">Khởi động lại vào Download Mode</string>
    <string name="reboot_edl">Khởi động lại vào EDL</string>
    <string name="about">Về ứng dụng</string>
    <string name="module_uninstall_success">%s đã được gỡ cài đặt</string>
    <string name="module_uninstall_failed">Lỗi khi gỡ cài đặt: %s</string>
    <string name="module_version">Phiên bản</string>
    <string name="module_author">Tác giả</string>
    <string name="module_overlay_fs_not_available">overlayfs hiện không khả dụng, mô-đun không thể hoạt động!</string>
    <string name="refresh">Làm mới</string>
    <string name="show_system_apps">Hiển thị ứng dụng hệ thống</string>
    <string name="hide_system_apps">Ẩn ứng dụng hệ thống</string>
    <string name="safe_mode">Chế độ an toàn</string>
    <string name="reboot_to_apply">Khởi động lại để có hiệu lực</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/vi_VN/guide/what-is-kernelsu.html</string>
    <string name="home_superuser_count">Số superuser: %d</string>
    <string name="home_module_count">Số mô-đun: %d</string>
    <string name="profile_selinux_domain">Phạm vi</string>
    <string name="profile_selinux_rules">Quy định</string>
    <string name="launch_app">Mở</string>
    <string name="restart_app">Khởi động lại</string>
    <string name="profile_namespace">Danh sách mount</string>
    <string name="profile_capabilities">Quyền</string>
    <string name="failed_to_update_sepolicy">Không thể cập nhật quy định SELinux cho: %s</string>
    <string name="force_stop_app">Buộc dừng</string>
    <string name="profile_namespace_inherited">Thừa hưởng</string>
    <string name="profile_namespace_global">Chung</string>
    <string name="profile_namespace_individual">Riêng</string>
    <string name="profile_selinux_context">SELinux context</string>
    <string name="profile_umount_modules">Ngắt mô-đun</string>
    <string name="require_kernel_version">KernelSU phiên bản %d quá thấp để trình quản lý hoạt động, hãy cập nhật lên %d hoặc mới hơn!</string>
</resources>
```

`manager/app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">主页</string>
    <string name="home_not_installed">未安装</string>
    <string name="home_click_to_install">点击安装</string>
    <string name="home_working">工作中</string>
    <string name="home_working_version">版本: %d</string>
    <string name="home_superuser_count">超级用户数：%d</string>
    <string name="home_unsupported">不支持</string>
    <string name="home_unsupported_reason">KernelSU 现在只支持 GKI 内核</string>
    <string name="home_kernel">内核版本</string>
    <string name="home_manager_version">管理器版本</string>
    <string name="home_fingerprint">系统指纹</string>
    <string name="home_selinux_status">SELinux 状态</string>
    <string name="selinux_status_disabled">被禁用</string>
    <string name="selinux_status_enforcing">强制执行</string>
    <string name="selinux_status_permissive">宽容模式</string>
    <string name="selinux_status_unknown">未知</string>
    <string name="superuser">超级用户</string>
    <string name="module_failed_to_enable">无法启用模块: %s</string>
    <string name="module_failed_to_disable">无法禁用模块: %s</string>
    <string name="module_empty">没有安装模块</string>
    <string name="module">模块</string>
    <string name="uninstall">卸载</string>
    <string name="module_install">安装</string>
    <string name="install">安装</string>
    <string name="reboot">重启</string>
    <string name="settings">设置</string>
    <string name="reboot_userspace">软重启</string>
    <string name="reboot_recovery">重启到 Recovery</string>
    <string name="reboot_bootloader">重启到 BootLoader</string>
    <string name="reboot_download">重启到 Download</string>
    <string name="reboot_edl">重启到 EDL</string>
    <string name="about">关于</string>
    <string name="module_uninstall_confirm">确定要卸载模块 %s 吗？</string>
    <string name="module_uninstall_success">%s 已卸载</string>
    <string name="module_uninstall_failed">卸载失败: %s</string>
    <string name="module_version">版本</string>
    <string name="module_author">作者</string>
    <string name="module_overlay_fs_not_available">内核不支持 overlayfs，模块功能无法运作！</string>
    <string name="refresh">刷新</string>
    <string name="show_system_apps">显示系统应用</string>
    <string name="hide_system_apps">隐藏系统应用</string>
    <string name="send_log">发送日志</string>
    <string name="safe_mode">安全模式</string>
    <string name="reboot_to_apply">重启生效</string>
    <string name="module_magisk_conflict">所有模块已被禁用，因为它与 Magisk 的模块系统有冲突！</string>
    <string name="home_module_count">模块数：%d</string>
    <string name="home_learn_kernelsu">了解 KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/zh_CN/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">了解如何安装 KernelSU 以及如何开发模块</string>
    <string name="home_support_title">支持开发</string>
    <string name="home_support_content">KernelSU 将保持免费和开源，向开发者捐赠以表示支持。</string>
    <string name="about_source_code"><![CDATA[在 %1$s 查看源码<br/>加入我们的 %2$s 频道<br/>加入我们的 <b><a href="https://pd.qq.com/s/8lipl1brp">QQ 频道</a></b>]]></string>
    <string name="profile_default">默认</string>
    <string name="profile_template">模版</string>
    <string name="profile_custom">自定义</string>
    <string name="profile_name">名称</string>
    <string name="profile_namespace">命名空间</string>
    <string name="profile_namespace_inherited">继承</string>
    <string name="profile_namespace_global">全局</string>
    <string name="profile_namespace_individual">私有</string>
    <string name="profile_groups">组</string>
    <string name="profile_capabilities">权能</string>
    <string name="profile_selinux_context">SELinux</string>
    <string name="profile_umount_modules">卸载模块</string>
    <string name="failed_to_update_app_profile">为 %s 更新 App Profile 失败</string>
    <string name="require_kernel_version">当前 KernelSU 版本 %d 过低，管理器无法正常工作，请升级内核 KernelSU 版本至 %d 或以上！</string>
    <string name="settings_umount_modules_default">默认卸载模块</string>
    <string name="settings_umount_modules_default_summary">App Profile 中\"卸载模块\"的全局默认值，如果启用，将会为没有设置 Profile 的应用移除所有模块针对系统的修改。</string>
    <string name="profile_umount_modules_summary">启用后将允许 KernelSU 为本应用还原被模块修改过的文件。</string>
    <string name="profile_selinux_domain">域</string>
    <string name="profile_selinux_rules">规则</string>
    <string name="module_update">更新</string>
    <string name="module_downloading">正在下载模块：%s</string>
    <string name="module_start_downloading">开始下载：%s</string>
    <string name="new_version_available">发现新版本：%s，点击下载</string>
    <string name="launch_app">启动</string>
    <string name="force_stop_app">强制停止</string>
    <string name="restart_app">重新启动</string>
    <string name="failed_to_update_sepolicy">为：%s 更新翻译失败</string>
</resources>

```

`manager/app/src/main/res/values-zh-rHK/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">首頁</string>
    <string name="home_not_installed">未安裝</string>
    <string name="home_click_to_install">按一下以安裝</string>
    <string name="home_working">正在處理</string>
    <string name="home_working_version">版本：%d</string>
    <string name="home_superuser_count">超級使用者：%d 個</string>
    <string name="home_module_count">模組：%d 個</string>
    <string name="home_unsupported">不支援</string>
    <string name="home_unsupported_reason">KernelSU 現在僅支援 GKI 核心</string>
    <string name="home_kernel">核心</string>
    <string name="home_manager_version">管理員版本</string>
    <string name="home_fingerprint">指紋</string>
    <string name="home_selinux_status">SELinux 狀態</string>
    <string name="selinux_status_disabled">已停用</string>
    <string name="selinux_status_enforcing">強制</string>
    <string name="selinux_status_permissive">寬鬆</string>
    <string name="selinux_status_unknown">未知</string>
    <string name="superuser">超級使用者</string>
    <string name="module_failed_to_enable">無法啟用模組：%s</string>
    <string name="module_failed_to_disable">無法停用模組：%s</string>
    <string name="module_empty">尚未安裝模組</string>
    <string name="module">模組</string>
    <string name="uninstall">解除安裝</string>
    <string name="module_install">安裝</string>
    <string name="install">安裝</string>
    <string name="reboot">重新啟動</string>
    <string name="settings">設定</string>
    <string name="reboot_userspace">軟啟動</string>
    <string name="reboot_recovery">重新啟動至 Recovery</string>
    <string name="reboot_bootloader">重新啟動至 Bootloader</string>
    <string name="reboot_download">重新啟動至 Download</string>
    <string name="reboot_edl">重新啟動至 EDL</string>
    <string name="about">關於</string>
    <string name="module_uninstall_confirm">您確定要解除安裝模組「%s」嗎？</string>
    <string name="module_uninstall_success">「%s」已解除安裝</string>
    <string name="module_uninstall_failed">無法解除安裝：%s</string>
    <string name="module_version">版本</string>
    <string name="module_author">作者</string>
    <string name="module_overlay_fs_not_available">OverlayFS 無法使用，模組無法正常運作！</string>
    <string name="refresh">重新整理</string>
    <string name="show_system_apps">顯示系統應用程式</string>
    <string name="hide_system_apps">隱藏系統應用程式</string>
    <string name="send_log">傳送記錄</string>
    <string name="safe_mode">安全模式</string>
    <string name="reboot_to_apply">重新啟動以生效</string>
    <string name="module_magisk_conflict">模組已停用，因其與 Magisk 的模組存在衝突！</string>
    <string name="home_learn_kernelsu">深入瞭解 KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/zh_TW/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">瞭解如何安裝 KernelSU 和使用模組</string>
    <string name="home_support_title">支持我們</string>
    <string name="home_support_content">KernelSU 是免費且開源的，您可以透過捐贈來向我們展示您對我們的關心。</string>
    <string name="about_source_code"><![CDATA[在 %1$s 中檢視原始碼<br/>加入我們的 %2$s 頻道]]></string>
    <string name="profile_default">預設</string>
    <string name="profile_name">設定檔名稱</string>
    <string name="profile_template">範本</string>
    <string name="profile_namespace_inherited">繼承</string>
    <string name="profile_namespace_global">全域</string>
    <string name="profile_capabilities">功能</string>
    <string name="profile_umount_modules">卸載模組</string>
    <string name="failed_to_update_app_profile">無法更新 %s 應用程式設定檔</string>
    <string name="profile_selinux_rules">規則</string>
    <string name="require_kernel_version">目前 KernelSU 版本 %d 過低，管理員無法正常運作。請升級至 %d 或更高版本！</string>
    <string name="settings_umount_modules_default_summary">應用程式設定檔中「卸載模組」的全域預設值。如果啟用，將會為沒有設定檔的應用程式移除所有模組對系統的修改。</string>
    <string name="profile_umount_modules_summary">啟用此選項將允許 KernelSU 為這個應用程式還原任何被模組修改過的檔案。</string>
    <string name="profile_selinux_domain">網域</string>
    <string name="module_update">更新</string>
    <string name="profile_custom">自訂</string>
    <string name="profile_namespace">掛載命名空間</string>
    <string name="profile_namespace_individual">個人</string>
    <string name="profile_groups">群組</string>
    <string name="profile_selinux_context">SELinux 內容</string>
    <string name="settings_umount_modules_default">預設卸載模組</string>
    <string name="module_downloading">正在下載模組：%s</string>
    <string name="module_start_downloading">開始下載：%s</string>
    <string name="new_version_available">新版本：%s 已可供使用，按一下以下載</string>
    <string name="launch_app">啟動</string>
    <string name="force_stop_app">強制停止</string>
    <string name="restart_app">重新啟動</string>
    <string name="failed_to_update_sepolicy">無法為 %s 更新 SELinux 規則</string>
</resources>

```

`manager/app/src/main/res/values-zh-rTW/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">首頁</string>
    <string name="home_not_installed">未安裝</string>
    <string name="home_click_to_install">按一下以安裝</string>
    <string name="home_working">正在處理</string>
    <string name="home_working_version">KernelSU 版本：%d</string>
    <string name="home_superuser_count">已授權 Root：%d 個</string>
    <string name="home_unsupported">不支援</string>
    <string name="home_unsupported_reason">KernelSU 現在僅支援 GKI 核心</string>
    <string name="home_kernel">核心</string>
    <string name="home_manager_version">管理器版本</string>
    <string name="home_fingerprint">指紋</string>
    <string name="home_selinux_status">SELinux 狀態</string>
    <string name="selinux_status_disabled">已停用</string>
    <string name="selinux_status_enforcing">強制</string>
    <string name="selinux_status_permissive">寬鬆</string>
    <string name="selinux_status_unknown">未知</string>
    <string name="superuser">Root 授權</string>
    <string name="module_failed_to_enable">無法啟用模組：%s</string>
    <string name="module_failed_to_disable">無法停用模組：%s</string>
    <string name="module_empty">尚未安裝模組</string>
    <string name="module">模組</string>
    <string name="uninstall">解除安裝</string>
    <string name="module_install">安裝</string>
    <string name="install">安裝</string>
    <string name="reboot">重新啟動</string>
    <string name="settings">設定</string>
    <string name="reboot_userspace">軟重新啟動</string>
    <string name="reboot_recovery">重新啟動至 Recovery</string>
    <string name="reboot_bootloader">重新啟動至 Bootloader</string>
    <string name="reboot_download">重新啟動至 Download</string>
    <string name="reboot_edl">重新啟動至 EDL</string>
    <string name="about">關於</string>
    <string name="module_uninstall_confirm">您確定要解除安裝模組「%s」嗎？</string>
    <string name="module_uninstall_success">「%s」已解除安裝</string>
    <string name="module_uninstall_failed">無法解除安裝：%s</string>
    <string name="module_version">版本</string>
    <string name="module_author">作者</string>
    <string name="module_overlay_fs_not_available">OverlayFS 無法使用，模組無法正常運作！</string>
    <string name="refresh">重新整理</string>
    <string name="show_system_apps">顯示系統應用程式</string>
    <string name="hide_system_apps">隱藏系統應用程式</string>
    <string name="send_log">傳送記錄</string>
    <string name="safe_mode">安全模式</string>
    <string name="reboot_to_apply">重新啟動以生效</string>
    <string name="module_magisk_conflict">模組已停用，因其與 Magisk 的模組存在衝突！</string>
    <string name="home_module_count">已安裝模組：%d 個</string>
    <string name="home_learn_kernelsu">深入瞭解 KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/zh_TW/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">瞭解如何安裝 KernelSU 以及如何開發模組</string>
    <string name="home_support_title">支持開發</string>
    <string name="home_support_content">KernelSU 將保持免費和開源，您可以考慮向開發人員捐贈以表示支持。</string>
    <string name="about_source_code"><![CDATA[在 %1$s 中檢視原始碼<br/>加入我們的 %2$s 頻道]]></string>
    <string name="profile_umount_modules">解除安裝模組</string>
    <string name="failed_to_update_app_profile">無法更新 %s 應用程式設定檔</string>
    <string name="require_kernel_version">目前安裝的 KernelSU 版本 %d 過低，管理器無法正常工作，請升級核心 KernelSU 版本至 %d 或以上！</string>
    <string name="settings_umount_modules_default">預設解除安裝模組</string>
    <string name="settings_umount_modules_default_summary">應用程式設定檔中「解除安裝模組」的全域預設值，如果啟用，將會為沒有設定檔的應用程式移除所有模組針對系統的修改。</string>
    <string name="profile_umount_modules_summary">啟用後將允許 KernelSU 為本應用程式還原被模組修改過的檔案。</string>
    <string name="profile_default">預設</string>
    <string name="profile_custom">自訂</string>
    <string name="profile_capabilities">功能</string>
    <string name="profile_selinux_rules">規則</string>
    <string name="module_downloading">正在下載模組：%s</string>
    <string name="restart_app">重新啟動</string>
    <string name="profile_template">範本</string>
    <string name="profile_name">設定檔名稱</string>
    <string name="profile_namespace">掛載命名空間</string>
    <string name="profile_namespace_inherited">繼承</string>
    <string name="profile_namespace_global">全域</string>
    <string name="profile_namespace_individual">個人</string>
    <string name="profile_groups">群組</string>
    <string name="profile_selinux_context">SELinux 環境</string>
    <string name="profile_selinux_domain">網域</string>
    <string name="module_update">更新</string>
    <string name="module_start_downloading">開始下載：%s</string>
    <string name="new_version_available">發現新版本：%s 已可供使用，按一下即可下載</string>
    <string name="launch_app">啟動</string>
    <string name="force_stop_app">強制停止</string>
    <string name="failed_to_update_sepolicy">無法為 %s 更新 SELinux</string>
</resources>

```

`manager/app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name" translatable="false">KernelSU</string>

    <string name="home">Home</string>
    <string name="home_not_installed">Not installed</string>
    <string name="home_click_to_install">Click to install</string>
    <string name="home_working">Working</string>
    <string name="home_working_version">Version: %d</string>
    <string name="home_superuser_count">Superusers: %d</string>
    <string name="home_module_count">Modules: %d</string>
    <string name="home_unsupported">Unsupported</string>
    <string name="home_unsupported_reason">KernelSU only supports GKI kernels now</string>

    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Manager Version</string>
    <string name="home_fingerprint">Fingerprint</string>

    <string name="home_selinux_status">SELinux status</string>
    <string name="selinux_status_disabled">Disabled</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Unknown</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Failed to enable module: %s</string>
    <string name="module_failed_to_disable">Failed to disable module: %s</string>
    <string name="module_empty">No module installed</string>

    <string name="module">Module</string>
    <string name="uninstall">Uninstall</string>
    <string name="module_install">Install</string>
    <string name="install">Install</string>
    <string name="reboot">Reboot</string>
    <string name="settings">Settings</string>
    <string name="reboot_userspace">Soft Reboot</string>
    <string name="reboot_recovery">Reboot to Recovery</string>
    <string name="reboot_bootloader">Reboot to Bootloader</string>
    <string name="reboot_download">Reboot to Download</string>
    <string name="reboot_edl">Reboot to EDL</string>
    <string name="about">About</string>
    <string name="module_uninstall_confirm">Are you sure you want to uninstall module %s?</string>
    <string name="module_uninstall_success">%s uninstalled</string>
    <string name="module_uninstall_failed">Failed to uninstall: %s</string>
    <string name="module_version">Version</string>
    <string name="module_author">Author</string>
    <string name="module_overlay_fs_not_available">overlayfs is not available, module cannot work!</string>
    <string name="refresh">Refresh</string>
    <string name="show_system_apps">Show system apps</string>
    <string name="hide_system_apps">Hide system apps</string>
    <string name="send_log">Send Log</string>
    <string name="safe_mode">Safe mode</string>
    <string name="reboot_to_apply">Reboot to take effect</string>
    <string name="module_magisk_conflict">Modules are disabled because it is conflict with Magisk\'s!</string>
    <string name="home_learn_kernelsu">Learn KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Learn how to install KernelSU and use modules</string>
    <string name="home_support_title">Support Us</string>
    <string name="home_support_content">KernelSU is, and always will be, free, and open source. You can however show us that you care by making a donation.</string>
    <string name="about_source_code"><![CDATA[View source code at %1$s<br/>Join our %2$s channel]]></string>
    <string name="profile" translatable="false">App Profile</string>
    <string name="profile_default">Default</string>
    <string name="profile_template">Template</string>
    <string name="profile_custom">Custom</string>
    <string name="profile_name">Profile name</string>
    <string name="profile_namespace">Mount namespace</string>
    <string name="profile_namespace_inherited">Inherited</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Groups</string>
    <string name="profile_capabilities">Capabilities</string>
    <string name="profile_selinux_context">SELinux context</string>
    <string name="profile_umount_modules">Umount modules</string>
    <string name="failed_to_update_app_profile">Failed to update App Profile for %s</string>
    <string name="require_kernel_version">The current KernelSU version %d is too low for the manager to function properly. Please upgrade to version %d or higher!</string>
    <string name="settings_umount_modules_default">Umount modules by default</string>
    <string name="settings_umount_modules_default_summary">The global default value for \"Umount modules\" in App Profiles. If enabled, it will remove all module modifications to the system for applications that do not have a Profile set.</string>
    <string name="profile_umount_modules_summary">Enabling this option will allow KernelSU to restore any modified files by the modules for this application.</string>
    <string name="profile_selinux_domain">Domain</string>
    <string name="profile_selinux_rules">Rules</string>
    <string name="module_update">Update</string>
    <string name="module_downloading">Downloading module: %s</string>
    <string name="module_start_downloading">Start downloading: %s</string>
    <string name="new_version_available">New version: %s is available, click to download</string>
    <string name="launch_app">Launch</string>
    <string name="force_stop_app">Force Stop</string>
    <string name="restart_app">Restart</string>
    <string name="failed_to_update_sepolicy">Failed to update SELinux rules for: %s</string>
</resources>

```

`manager/app/src/main/res/values/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Theme.KernelSU" parent="android:Theme.Material.Light.NoActionBar">
    </style>
</resources>
```

`manager/app/src/main/res/xml/backup_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

`manager/app/src/main/res/xml/data_extraction_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

`manager/app/src/main/res/xml/filepaths.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<paths>
    <cache-path name="cache" path="."/>
    <root-path name="root" path="." />
</paths>
```

`manager/build.gradle.kts`:

```kts
import com.android.build.api.dsl.ApplicationDefaultConfig
import com.android.build.api.dsl.CommonExtension
import com.android.build.gradle.api.AndroidBasePlugin
import java.io.ByteArrayOutputStream

plugins {
    alias(libs.plugins.agp.app) apply false
    alias(libs.plugins.agp.lib) apply false
    alias(libs.plugins.kotlin) apply false
    alias(libs.plugins.lsplugin.cmaker)
}

cmaker {
    default {
        arguments.addAll(
            arrayOf(
                "-DANDROID_STL=c++_static",
            )
        )
        val flags = arrayOf(
            "-Wno-gnu-string-literal-operator-template",
            "-Wno-c++2b-extensions",
        )
        cFlags.addAll(flags)
        cppFlags.addAll(flags)
        abiFilters("arm64-v8a", "x86_64")
    }
    buildTypes {
        if (it.name == "release") {
            arguments += "-DDEBUG_SYMBOLS_PATH=${buildDir.absolutePath}/symbols"
        }
    }
}

val androidMinSdkVersion = 26
val androidTargetSdkVersion = 33
val androidCompileSdkVersion = 33
val androidBuildToolsVersion = "33.0.2"
val androidCompileNdkVersion = "25.2.9519653"
val androidSourceCompatibility = JavaVersion.VERSION_17
val androidTargetCompatibility = JavaVersion.VERSION_17
val managerVersionCode by extra(getVersionCode())
val managerVersionName by extra(getVersionName())

tasks.register<Delete>("clean") {
    delete(rootProject.buildDir)
}

fun getGitCommitCount(): Int {
    val out = ByteArrayOutputStream()
    exec {
        commandLine("git", "rev-list", "--count", "HEAD")
        standardOutput = out
    }
    return out.toString().trim().toInt()
}

fun getGitDescribe(): String {
    val out = ByteArrayOutputStream()
    exec {
        commandLine("git", "describe", "--tags", "--always")
        standardOutput = out
    }
    return out.toString().trim()
}

fun getVersionCode(): Int {
    val commitCount = getGitCommitCount()
    val major = 1
    return major * 10000 + commitCount + 200
}

fun getVersionName(): String {
    return getGitDescribe()
}

subprojects {
    plugins.withType(AndroidBasePlugin::class.java) {
        extensions.configure(CommonExtension::class.java) {
            compileSdk = androidCompileSdkVersion
            ndkVersion = androidCompileNdkVersion
            buildToolsVersion = androidBuildToolsVersion

            defaultConfig {
                minSdk = androidMinSdkVersion
                if (this is ApplicationDefaultConfig) {
                    targetSdk = androidTargetSdkVersion
                    versionCode = managerVersionCode
                    versionName = managerVersionName
                }
            }

            lint {
                abortOnError = true
                checkReleaseBuilds = false
            }

            compileOptions {
                sourceCompatibility = androidSourceCompatibility
                targetCompatibility = androidTargetCompatibility
            }
        }
    }
}

```

`manager/gradle.properties`:

```properties
android.experimental.enableNewResourceShrinker.preciseShrinking=true
android.enableAppCompileTimeRClass=true
android.useAndroidX=true

```

`manager/gradle/libs.versions.toml`:

```toml
[versions]
agp = "8.0.1"
kotlin = "1.8.10"
ksp = "1.8.10-1.0.9"
compose-bom = "2023.05.01"
lifecycle = "2.6.1"
accompanist = "0.30.0"
navigation = "2.5.3"
compose-destination = "1.9.42-beta"
libsu = "5.0.5"
sheets-compose-dialogs = "1.2.0"

[plugins]
agp-app = { id = "com.android.application", version.ref = "agp" }
agp-lib = { id = "com.android.library", version.ref = "agp" }
kotlin = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }
lsplugin-apksign = { id = "org.lsposed.lsplugin.apksign", version = "1.1" }
lsplugin-cmaker = { id = "org.lsposed.lsplugin.cmaker", version = "1.1" }

[libraries]
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version = "1.7.1" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigation" }

androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "compose-bom" }
androidx-compose-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended" }
androidx-compose-material = { group = "androidx.compose.material", name = "material" }
androidx-compose-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-compose-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-compose-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-compose-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }

androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycle" }
androidx-lifecycle-runtime-compose = { group = "androidx.lifecycle", name = "lifecycle-runtime-compose", version.ref = "lifecycle" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version = "lifecycle" }

com-google-accompanist-drawablepainter = { group = "com.google.accompanist", name = "accompanist-drawablepainter", version.ref = "accompanist" }
com-google-accompanist-navigation-animation = { group = "com.google.accompanist", name = "accompanist-navigation-animation", version.ref = "accompanist" }
com-google-accompanist-systemuicontroller = { group = "com.google.accompanist", name = "accompanist-systemuicontroller", version.ref = "accompanist" }

com-github-topjohnwu-libsu-core = { group = "com.github.topjohnwu.libsu", name = "core", version.ref = "libsu" }
com-github-topjohnwu-libsu-service = { group = "com.github.topjohnwu.libsu", name = "service", version.ref = "libsu" }

dev-rikka-rikkax-parcelablelist = { module = "dev.rikka.rikkax.parcelablelist:parcelablelist", version = "2.0.1" }

io-coil-kt-coil-compose = { group = "io.coil-kt", name = "coil-compose", version = "2.3.0" }

kotlinx-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version = "1.7.1" }

me-zhanghai-android-appiconloader-coil = { group = "me.zhanghai.android.appiconloader", name = "appiconloader-coil", version = "1.5.0" }

compose-destinations-animations-core = { group = "io.github.raamcosta.compose-destinations", name = "animations-core", version.ref = "compose-destination" }
compose-destinations-ksp = { group = "io.github.raamcosta.compose-destinations", name = "ksp", version.ref = "compose-destination" }

sheet-compose-dialogs-core = { group = "com.maxkeppeler.sheets-compose-dialogs", name = "core", version.ref = "sheets-compose-dialogs"}
sheet-compose-dialogs-list = { group = "com.maxkeppeler.sheets-compose-dialogs", name = "list", version.ref = "sheets-compose-dialogs"}
sheet-compose-dialogs-input = { group = "com.maxkeppeler.sheets-compose-dialogs", name = "input", version.ref = "sheets-compose-dialogs"}

```

`manager/gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionUrl=https\://services.gradle.org/distributions/gradle-8.1.1-bin.zip
distributionPath=wrapper/dists
zipStorePath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME

```

`manager/gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`manager/gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`manager/settings.gradle.kts`:

```kts
enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")

pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }
}

rootProject.name = "KernelSU"
include(":app")

```

`manager/sign.example.properties`:

```properties
KEYSTORE_FILE=
KEYSTORE_PASSWORD=
KEY_ALIAS=
KEY_PASSWORD=

```

`scripts/abi_gki_all.py`:

```py
from xml.dom.minidom import parse
import xml.dom.minidom
import sys


DOMTree = xml.dom.minidom.parse(sys.argv[1])
symbols = DOMTree.getElementsByTagName("elf-symbol")
print("[abi_symbol_list]")
for symbol in symbols:
    print("  " + symbol.getAttribute("name"))

```

`scripts/add_device_handler.py`:

```py
import json
import sys
import os


def main():
    assert len(sys.argv) == 2
    file_name = sys.argv[1]
    github = "https://github.com/"
    issue_content = os.environ["ISSUE_CONTENT"]
    lines = issue_content.split("\n\n")
    assert len(lines) == 6
    url = lines[1]
    print(url)
    device = lines[3]
    print(device)
    code_of_conduct = lines[5]
    print(code_of_conduct)
    assert code_of_conduct.find("[X]") > 0
    tmp = url.removesuffix("/").replace(github, "").split("/")
    print(tmp)
    assert len(tmp) == 2
    maintainer = tmp[0]
    print(maintainer)
    maintainer_link = "%s%s" % (github, maintainer)
    print(maintainer_link)
    kernel_name = tmp[1]
    print(kernel_name)
    kernel_link = "%s%s/%s" % (github, maintainer, kernel_name)
    print(kernel_link)
    with open(file_name, "r") as f:
        data = json.loads(f.read())
        data.append(
            {
                "maintainer": maintainer,
                "maintainer_link": maintainer_link,
                "kernel_name": kernel_name,
                "kernel_link": kernel_link,
                "devices": device,
            }
        )
    os.remove(file_name)
    with open(file_name, "w") as f:
        f.write(json.dumps(data, indent=4))
    os.system("echo success=true >> $GITHUB_OUTPUT")
    os.system("echo device=%s >> $GITHUB_OUTPUT" % device)


if __name__ == "__main__":
    main()
```

`scripts/bin2c.py`:

```py
#!/usr/bin/python3

import argparse
import os
import re

line_size = 80


def bin2c(filename, varname='data'):
    if not os.path.isfile(filename):
        print('File "%s" is not found!' % filename)
        return ''
    if not re.match('[a-zA-Z_][a-zA-Z0-9_]*', varname):
        print('Invalid variable name "%s"' % varname)
        return
    with open(filename, 'rb') as in_file:
        data = in_file.read()
    # limit the line length
    byte_len = 6  # '0x00, '
    out = 'unsigned int %s_size = %d;\n' \
          'const char %s[%d] = {\n' % (varname, len(data), varname, len(data))
    line = ''
    for byte in data:
        line += '0x%02x, ' % byte
        if len(line) + 4 + byte_len >= line_size:
            out += ' ' * 4 + line + '\n'
            line = ''
    # add the last line
    if len(line) + 4 + byte_len < line_size:
        out += ' ' * 4 + line + '\n'
    # strip the last comma
    out = out.rstrip(', \n') + '\n'
    out += '};'
    return out


def main():
    """ Main func """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'filename', help='filename to convert to C array')
    parser.add_argument(
        'varname', nargs='?', help='variable name', default='data')
    args = parser.parse_args()
    # print out the data
    print(bin2c(args.filename, args.varname))


if __name__ == '__main__':
    main()

```

`scripts/check_v2.c`:

```c
//
// Created by Thom on 2019/3/8.
//

// Credits: https://github.com/brevent/genuine/blob/master/src/main/jni/apk-sign-v2.c
#include <fcntl.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

#define MAIN

#ifdef MAIN
#include <stdio.h>
#else

#include "common.h"
#include "openat.h"

#endif

static bool isApkSigBlock42(const char *buffer) {
    // APK Sig Block 42
    return *buffer == 'A'
           && *++buffer == 'P'
           && *++buffer == 'K'
           && *++buffer == ' '
           && *++buffer == 'S'
           && *++buffer == 'i'
           && *++buffer == 'g'
           && *++buffer == ' '
           && *++buffer == 'B'
           && *++buffer == 'l'
           && *++buffer == 'o'
           && *++buffer == 'c'
           && *++buffer == 'k'
           && *++buffer == ' '
           && *++buffer == '4'
           && *++buffer == '2';
}

int checkSignature(const char *path) {
    unsigned char buffer[0x11] = {0};
    uint32_t size4;
    uint64_t size8, size_of_block;

#ifdef DEBUG
    LOGI("check signature for %s", path);
#endif

    int sign = -1;
    int fd = (int) openat(AT_FDCWD, path, O_RDONLY);
#ifdef DEBUG_OPENAT
    LOGI("openat %s returns %d", path, fd);
#endif
    if (fd < 0) {
        return sign;
    }

    sign = 1;
    // https://en.wikipedia.org/wiki/Zip_(file_format)#End_of_central_directory_record_(EOCD)
    for (int i = 0;; ++i) {
        unsigned short n;
        lseek(fd, -i - 2, SEEK_END);
        read(fd, &n, 2);
        if (n == i) {
            lseek(fd, -22, SEEK_CUR);
            read(fd, &size4, 4);
            if ((size4 ^ 0xcafebabeu) == 0xccfbf1eeu) {
#ifdef MAIN
                if (i > 0) {
                    printf("warning: comment length is %d\n", i);
                }
#endif
                break;
            }
        }
        if (i == 0xffff) {
#ifdef MAIN
            printf("error: cannot find eocd\n");
#endif
            goto clean;
        }
    }

    lseek(fd, 12, SEEK_CUR);
    // offset
    read(fd, &size4, 0x4);
    lseek(fd, (off_t) (size4 - 0x18), SEEK_SET);

    read(fd, &size8, 0x8);
    read(fd, buffer, 0x10);
    if (!isApkSigBlock42((char *) buffer)) {
        goto clean;
    }

    lseek(fd, (off_t) (size4 - (size8 + 0x8)), SEEK_SET);
    read(fd, &size_of_block, 0x8);
    if (size_of_block != size8) {
        goto clean;
    }

    for (;;) {
        uint32_t id;
        uint32_t offset;
        read(fd, &size8, 0x8); // sequence length
        if (size8 == size_of_block) {
            break;
        }
        read(fd, &id, 0x4); // id
        offset = 4;
#ifdef MAIN
        // printf("id: 0x%08x\n", id);
#endif
        if ((id ^ 0xdeadbeefu) == 0xafa439f5u || (id ^ 0xdeadbeefu) == 0x2efed62f) {
            read(fd, &size4, 0x4); // signer-sequence length
            read(fd, &size4, 0x4); // signer length
            read(fd, &size4, 0x4); // signed data length
            offset += 0x4 * 3;

            read(fd, &size4, 0x4); // digests-sequence length
            lseek(fd, (off_t) (size4), SEEK_CUR);// skip digests
            offset += 0x4 + size4;

            read(fd, &size4, 0x4); // certificates length
            read(fd, &size4, 0x4); // certificate length
            offset += 0x4 * 2;
#ifdef MAIN
            int hash = 1;
            signed char c;
            for (unsigned i = 0; i < size4; ++i) {
                read(fd, &c, 0x1);
                hash = 31 * hash + c;
            }
            offset += size4;
            // printf("    size: 0x%04x, hash: 0x%08x\n", size4, ((unsigned) hash) ^ 0x14131211u);
            printf("0x%04x 0x%08x\n", size4, ((unsigned) hash) ^ 0x14131211u);
#else
#if defined(GENUINE_SIZE) && defined(GENUINE_HASH)
            if (size4 == GENUINE_SIZE) {
                int hash = 1;
                signed char c;
                for (unsigned i = 0; i < size4; ++i) {
                    read(fd, &c, 0x1);
                    hash = 31 * hash + c;
                }
                offset += size4;
                if ((((unsigned) hash) ^ 0x14131211u) == GENUINE_HASH) {
                    sign = 0;
                    break;
                }
            }
#else
            sign = 0;
            break;
#endif
#endif
        }
        lseek(fd, (off_t) (size8 - offset), SEEK_CUR);
    }

clean:
    close(fd);

    return sign;
}

#ifdef MAIN
int main(int argc, char **argv) {
    if (argc > 1) {
        checkSignature(argv[1]);
    }
}
#endif

```

`userspace/ksud/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "adler32"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aae1277d39aeec15cb388266ecc24b11c80469deae6067e17a1a7aa9e5c1f234"

[[package]]
name = "aes"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e8b47f52ea9bae42228d07ec09eb676433d7c4ed1ebdf0f1d1c29ed446f1ab8"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
 "opaque-debug",
]

[[package]]
name = "aho-corasick"
version = "0.7.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc936419f96fa211c1b9166887b38e5e40b19958e5b895be7c1f93adec7071ac"
dependencies = [
 "memchr",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android_log-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27f0fc03f560e1aebde41c2398b691cb98b5ea5996a6184a7a67bbbb77448969"

[[package]]
name = "android_logger"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d70a974711fabdc7555de36765bbc237f093f5992d62cab3dcaa0b0bfc7d756"
dependencies = [
 "android_log-sys",
 "env_logger",
 "log",
 "once_cell",
]

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anyhow"
version = "1.0.68"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2cb2f989d18dd141ab8ae82f64d1a8cdd37e0840f73a406896cf5e99502fab61"

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "base64ct"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"

[[package]]
name = "bindgen"
version = "0.60.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "062dddbc1ba4aca46de6338e2bf87771414c335f7b2f2036e8f3e9befebf88e6"
dependencies = [
 "bitflags",
 "cexpr",
 "clang-sys",
 "lazy_static",
 "lazycell",
 "peeking_take_while",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "block-buffer"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cce20737498f97b993470a6e536b8523f0af7892a4f928cceb1ac5e52ebe7e"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d261e256854913907f67ed06efbc3338dfe6179796deefc1ff763fc1aee5535"

[[package]]
name = "byteorder"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"

[[package]]
name = "bzip2"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdb116a6ef3f6c3698828873ad02c3014b3c85cadb88496095628e3ef1e347f8"
dependencies = [
 "bzip2-sys",
 "libc",
]

[[package]]
name = "bzip2-sys"
version = "0.1.11+1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "736a955f3fa7875102d57c82b8cac37ec45224a07fd32d58f9f7a186b6cd4cdc"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
]

[[package]]
name = "cc"
version = "1.0.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f"
dependencies = [
 "jobserver",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16b0a3d9ed01224b22057780a37bb8c5dbfe1be8ba48678e7bf57ec4b385411f"
dependencies = [
 "iana-time-zone",
 "num-integer",
 "num-traits",
 "winapi",
]

[[package]]
name = "cipher"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ee52072ec15386f770805afd189a01c8841be8696bed250fa2f13c4c0d6dfb7"
dependencies = [
 "generic-array",
]

[[package]]
name = "clang-sys"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa2e27ae6ab525c3d369ded447057bca5438d86dc3a68f6faafb8269ba82ebf3"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "4.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f13b9c79b5d1dd500d20ef541215a6423c75829ef43117e1b4d17fd8af0b5d76"
dependencies = [
 "bitflags",
 "clap_derive",
 "clap_lex",
 "is-terminal",
 "once_cell",
 "strsim",
 "termcolor",
]

[[package]]
name = "clap_derive"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "684a277d672e91966334af371f1a7b5833f9aa00b07c84e92fbce95e00208ce8"
dependencies = [
 "heck",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "783fe232adfca04f90f56201b26d79682d4cd2625e0bc7290b95123afe558ade"
dependencies = [
 "os_str_bytes",
]

[[package]]
name = "codespan-reporting"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
dependencies = [
 "termcolor",
 "unicode-width",
]

[[package]]
name = "const_format"
version = "0.2.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7309d9b4d3d2c0641e018d449232f2e28f1b22933c137f157d3dbc14228b8c0e"
dependencies = [
 "const_format_proc_macros",
]

[[package]]
name = "const_format_proc_macros"
version = "0.2.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d897f47bf7270cf70d370f8f98c1abb6d2d4cf60a6845d30e05bfb90c6568650"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "constant_time_eq"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "245097e9a4535ee1e3e3931fcfcd55a796a44c643e8596ff6566d68f09b87bbc"

[[package]]
name = "core-foundation-sys"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5827cebf4670468b8772dd191856768aedcb1b0278a04f989f7766351917b9dc"

[[package]]
name = "cpufeatures"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d997bd5e24a5928dd43e46dc529867e207907fe0b239c3477d924f7f2ca320"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2801af0d36612ae591caa9568261fddce32ce6e08a7275ea334a06a4ad021a2c"
dependencies = [
 "cfg-if",
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-epoch",
 "crossbeam-queue",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc"
dependencies = [
 "cfg-if",
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01a9af1f4c2ef74bb8aa1f7e19706bc72d03598c8a570bb5de72243c7a9d9d5a"
dependencies = [
 "autocfg",
 "cfg-if",
 "crossbeam-utils",
 "memoffset",
 "scopeguard",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1cfb3ea8a53f37c40dea2c7bedcbd88bdfae54f5e2175d6ecaff1c988353add"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fb766fa798726286dbbb842f174001dab8abc7b627a1dd86e0b7222a95d929f"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "cxx"
version = "1.0.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc831ee6a32dd495436e317595e639a587aa9907bef96fe6e6abc290ab6204e9"
dependencies = [
 "cc",
 "cxxbridge-flags",
 "cxxbridge-macro",
 "link-cplusplus",
]

[[package]]
name = "cxx-build"
version = "1.0.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94331d54f1b1a8895cd81049f7eaaaef9d05a7dcb4d1fd08bf3ff0806246789d"
dependencies = [
 "cc",
 "codespan-reporting",
 "once_cell",
 "proc-macro2",
 "quote",
 "scratch",
 "syn",
]

[[package]]
name = "cxxbridge-flags"
version = "1.0.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48dcd35ba14ca9b40d6e4b4b39961f23d835dbb8eed74565ded361d93e1feb8a"

[[package]]
name = "cxxbridge-macro"
version = "1.0.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81bbeb29798b407ccd82a3324ade1a7286e0d29851475990b612670f6f5124d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "derive-new"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3418329ca0ad70234b9735dc4ceed10af4df60eff9c8e7b06cb5e520d92c3535"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "digest"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8168378f4e5023e7218c89c891c0fd8ecdb5e5e4f18cb78f38cf245dd021e76f"
dependencies = [
 "block-buffer",
 "crypto-common",
 "subtle",
]

[[package]]
name = "either"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"

[[package]]
name = "encoding"
version = "0.2.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b0d943856b990d12d3b55b359144ff341533e516d94098b1d3fc1ac666d36ec"
dependencies = [
 "encoding-index-japanese",
 "encoding-index-korean",
 "encoding-index-simpchinese",
 "encoding-index-singlebyte",
 "encoding-index-tradchinese",
]

[[package]]
name = "encoding-index-japanese"
version = "1.20141219.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04e8b2ff42e9a05335dbf8b5c6f7567e5591d0d916ccef4e0b1710d32a0d0c91"
dependencies = [
 "encoding_index_tests",
]

[[package]]
name = "encoding-index-korean"
version = "1.20141219.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4dc33fb8e6bcba213fe2f14275f0963fd16f0a02c878e3095ecfdf5bee529d81"
dependencies = [
 "encoding_index_tests",
]

[[package]]
name = "encoding-index-simpchinese"
version = "1.20141219.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d87a7194909b9118fc707194baa434a4e3b0fb6a5a757c73c3adb07aa25031f7"
dependencies = [
 "encoding_index_tests",
]

[[package]]
name = "encoding-index-singlebyte"
version = "1.20141219.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3351d5acffb224af9ca265f435b859c7c01537c0849754d3db3fdf2bfe2ae84a"
dependencies = [
 "encoding_index_tests",
]

[[package]]
name = "encoding-index-tradchinese"
version = "1.20141219.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd0e20d5688ce3cab59eb3ef3a2083a5c77bf496cb798dc6fcdb75f323890c18"
dependencies = [
 "encoding_index_tests",
]

[[package]]
name = "encoding_index_tests"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a246d82be1c9d791c5dfde9a2bd045fc3cbba3fa2b11ad558f27d01712f00569"

[[package]]
name = "env_logger"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85cdab6a89accf66733ad5a1693a4dcced6aeff64602b634530dd73c1f3ee9f0"
dependencies = [
 "humantime",
 "is-terminal",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "errno"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f639046355ee4f37944e44f60642c6f3a7efa3cf6b78c78a0d989a8ce6c396a1"
dependencies = [
 "errno-dragonfly",
 "libc",
 "winapi",
]

[[package]]
name = "errno-dragonfly"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "extattr"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b59f8a77817ff1b795adafc535941bdf664184f5f95e0b6d1d77dd6d12815dc"
dependencies = [
 "bitflags",
 "errno",
 "libc",
]

[[package]]
name = "flate2"
version = "1.0.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8a2db397cb1c8772f31494cb8917e48cd1e64f0fa7efac59fbd741a0a8ce841"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "generic-array"
version = "0.14.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bff49e947297f3312447abdca79f45f4738097cc82b06e72054d2223f601f1b9"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getopts"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5"
dependencies = [
 "unicode-width",
]

[[package]]
name = "getrandom"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
]

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "heck"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"

[[package]]
name = "hermit-abi"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7"
dependencies = [
 "libc",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "humansize"
version = "2.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6cb51c9a029ddc91b07a787f1d86b53ccfa49b0e86688c946ebe8d3555685dd7"
dependencies = [
 "libm",
]

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "iana-time-zone"
version = "0.1.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64c122667b287044802d6ce17ee2ddf13207ed924c712de9a66a5814d5b64765"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "winapi",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0703ae284fc167426161c2e3f1da3ea71d94b21bedbcc9494e92b28e334e3dca"
dependencies = [
 "cxx",
 "cxx-build",
]

[[package]]
name = "include-flate"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfdcb449c721557c1cf89bbd3412bf33fa963289e26e9badbd824a960912e148"
dependencies = [
 "include-flate-codegen-exports",
 "lazy_static",
 "libflate",
]

[[package]]
name = "include-flate-codegen"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a7d6e1419fa3129eb0802b4c99603c0d425c79fb5d76191d5a20d0ab0d664e8"
dependencies = [
 "libflate",
 "proc-macro-hack",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "include-flate-codegen-exports"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75657043ffe3d8280f1cb8aef0f505532b392ed7758e0baeac22edadcee31a03"
dependencies = [
 "include-flate-codegen",
 "proc-macro-hack",
]

[[package]]
name = "io-lifetimes"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1abeb7a0dd0f8181267ff8adc397075586500b81b28a73e8a0208b00fc170fb3"
dependencies = [
 "libc",
 "windows-sys 0.45.0",
]

[[package]]
name = "is-terminal"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dfb6c8100ccc63462345b67d1bbc3679177c75ee4bf59bf29c8b1d110b8189"
dependencies = [
 "hermit-abi",
 "io-lifetimes",
 "rustix",
 "windows-sys 0.42.0",
]

[[package]]
name = "is_executable"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa9acdc6d67b75e626ad644734e8bc6df893d9cd2a834129065d3dd6158ea9c8"
dependencies = [
 "winapi",
]

[[package]]
name = "itoa"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fad582f4b9e86b6caa621cabeb0963332d92eea04729ab12892c2533951e6440"

[[package]]
name = "java-properties"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1904d8654a1ef51034d02d5a9411b50bf91bea15b0ab644ae179d1325976263"
dependencies = [
 "encoding",
 "lazy_static",
 "regex",
]

[[package]]
name = "jobserver"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2"
dependencies = [
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445dde2150c55e483f3d8416706b97ec8e8237c307e5b7b4b8dd15e6af2a0730"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "jwalk"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2735847566356cd2179a2a38264839308f7079fa96e6bd5a42d740460e003c56"
dependencies = [
 "crossbeam",
 "rayon",
]

[[package]]
name = "ksud"
version = "0.1.0"
dependencies = [
 "android-properties",
 "android_logger",
 "anyhow",
 "clap",
 "const_format",
 "derive-new",
 "encoding",
 "env_logger",
 "extattr",
 "getopts",
 "humansize",
 "is_executable",
 "java-properties",
 "jwalk",
 "libc",
 "log",
 "nom",
 "procfs",
 "regex",
 "retry",
 "rust-embed",
 "serde",
 "serde_json",
 "sys-mount",
 "which",
 "zip 0.6.4",
 "zip-extensions",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "libc"
version = "0.2.139"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79"

[[package]]
name = "libflate"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05605ab2bce11bcfc0e9c635ff29ef8b2ea83f29be257ee7d730cac3ee373093"
dependencies = [
 "adler32",
 "crc32fast",
 "libflate_lz77",
]

[[package]]
name = "libflate_lz77"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39a734c0493409afcd49deee13c006a04e3586b9761a03543c6272c9c51f2f5a"
dependencies = [
 "rle-decode-fast",
]

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libm"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "348108ab3fba42ec82ff6e9564fc4ca0247bdccdc68dd8af9764bbc79c3c8ffb"

[[package]]
name = "link-cplusplus"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecd207c9c713c34f95a097a5b029ac2ce6010530c7b49d7fea24d977dede04f5"
dependencies = [
 "cc",
]

[[package]]
name = "linux-raw-sys"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f051f77a7c8e6957c0696eac88f26b0117e54f52d3fc682ab19397a8812846a4"

[[package]]
name = "log"
version = "0.4.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e"
dependencies = [
 "cfg-if",
]

[[package]]
name = "loopdev"
version = "0.5.0"
source = "git+https://github.com/tiann/loopdev?branch=loopfix#b6ca5e3ea163f66239f6a835874fe231b2a9286f"
dependencies = [
 "bindgen",
 "errno",
 "libc",
]

[[package]]
name = "memchr"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"

[[package]]
name = "memoffset"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4"
dependencies = [
 "autocfg",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b275950c28b37e794e8c55d88aeb5e139d0ce23fdbbeda68f8d7174abdf9e8fa"
dependencies = [
 "adler",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-integer"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9"
dependencies = [
 "autocfg",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_cpus"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fac9e2da13b5eb447a6ce3d392f23a29d8694bff781bf03a16cd9ac8697593b"
dependencies = [
 "hermit-abi",
 "libc",
]

[[package]]
name = "once_cell"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f61fba1741ea2b3d6a1e3178721804bb716a68a6aeba1149b5d52e3d464ea66"

[[package]]
name = "opaque-debug"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5"

[[package]]
name = "os_str_bytes"
version = "6.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b7820b9daea5457c9f21c69448905d723fbd21136ccf521748f23fd49e723ee"

[[package]]
name = "password-hash"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7676374caaee8a325c9e7a2ae557f216c5563a171d6997b0ef8a65af35147700"
dependencies = [
 "base64ct",
 "rand_core",
 "subtle",
]

[[package]]
name = "pbkdf2"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83a0692ec44e4cf1ef28ca317f14f8f07da2d95ec3fa01f86e4467b725e60917"
dependencies = [
 "digest",
 "hmac",
 "password-hash",
 "sha2",
]

[[package]]
name = "peeking_take_while"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"

[[package]]
name = "pin-project-lite"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116"

[[package]]
name = "pkg-config"
version = "0.3.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ac9a59f73473f1b8d852421e59e64809f025994837ef743615c6d0c5b305160"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro-hack"
version = "0.5.20+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc375e1527247fe1a97d8b7156678dfe7c1af2fc075c9a4db3690ecd2a148068"

[[package]]
name = "proc-macro2"
version = "1.0.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ef7d57beacfaf2d8aee5937dab7b7f28de3cb8b1828479bb5de2a7106f2bae2"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "procfs"
version = "0.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "943ca7f9f29bab5844ecd8fdb3992c5969b6622bb9609b9502fef9b4310e3f1f"
dependencies = [
 "bitflags",
 "byteorder",
 "chrono",
 "flate2",
 "hex",
 "lazy_static",
 "rustix",
]

[[package]]
name = "quote"
version = "1.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8856d8364d252a14d474036ea1358d63c9e6965c8e5c1885c18f73d70bff9c7b"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "rayon"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db3a213adf02b3bcfd2d3846bb41cb22857d131789e01df434fb7e7bc0759b7"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "356a0625f1954f730c0201cdab48611198dc6ce21f4acff55089b5a78e6e835b"
dependencies = [
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-utils",
 "num_cpus",
]

[[package]]
name = "regex"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48aaa5748ba571fb95cd2c85c09f629215d3a6ece942baa100950af03a34f733"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.6.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "456c603be3e8d448b072f410900c09faf164fbce2d480456f50eea6e25f9c848"

[[package]]
name = "retry"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9166d72162de3575f950507683fac47e30f6f2c3836b71b7fbc61aa517c9c5f4"
dependencies = [
 "rand",
]

[[package]]
name = "rle-decode-fast"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3582f63211428f83597b51b2ddb88e2a91a9d52d12831f9d08f5e624e8977422"

[[package]]
name = "rust-embed"
version = "6.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "283ffe2f866869428c92e0d61c2f35dfb4355293cdfdc48f49e895c15f1333d1"
dependencies = [
 "include-flate",
 "rust-embed-impl",
 "rust-embed-utils",
 "walkdir",
]

[[package]]
name = "rust-embed-impl"
version = "6.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31ab23d42d71fb9be1b643fe6765d292c5e14d46912d13f3ae2815ca048ea04d"
dependencies = [
 "proc-macro2",
 "quote",
 "rust-embed-utils",
 "syn",
 "walkdir",
]

[[package]]
name = "rust-embed-utils"
version = "7.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1669d81dfabd1b5f8e2856b8bbe146c6192b0ba22162edc738ac0a5de18f054"
dependencies = [
 "sha2",
 "walkdir",
]

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustix"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4fdebc4b395b7fbb9ab11e462e20ed9051e7b16e42d24042c776eca0ac81b03"
dependencies = [
 "bitflags",
 "errno",
 "io-lifetimes",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.42.0",
]

[[package]]
name = "ryu"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b4b9743ed687d4b4bcedf9ff5eaa7398495ae14e61cba0a295704edbc7decde"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scopeguard"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"

[[package]]
name = "scratch"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddccb15bcce173023b3fedd9436f882a0739b8dfb45e4f6b6002bee5929f61b2"

[[package]]
name = "serde"
version = "1.0.152"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb"

[[package]]
name = "serde_json"
version = "1.0.91"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha1"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f04293dc80c3993519f2d7f6f511707ee7094fe0c6d3406feb330cdb3540eba3"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43b2853a4d09f215c24cc5489c992ce46052d359b5109343cbafbf26bc62f8a3"

[[package]]
name = "smart-default"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "133659a15339456eeeb07572eb02a91c91e9815e9cbc89566944d2c8d3efdbf6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "strsim"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"

[[package]]
name = "subtle"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601"

[[package]]
name = "syn"
version = "1.0.107"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sys-mount"
version = "2.0.2"
source = "git+https://github.com/tiann/sys-mount?branch=loopfix#c7c4048e4a4ffdf8b108a85956363a75f2c554f0"
dependencies = [
 "bitflags",
 "libc",
 "loopdev",
 "smart-default",
 "thiserror",
 "tracing",
]

[[package]]
name = "termcolor"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a9cd18aa97d5c45c6603caea1da6628790b37f7a34b6ca89522331c5180fed0"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "time"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b797afad3f312d1c66a56d11d0316f916356d11bd158fbc6ca6389ff6bf805a"
dependencies = [
 "libc",
 "wasi 0.10.0+wasi-snapshot-preview1",
 "winapi",
]

[[package]]
name = "time"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd0cbfecb4d19b5ea75bb31ad904eb5b9fa13f21079c3b92017ebdf4999a5890"
dependencies = [
 "serde",
 "time-core",
]

[[package]]
name = "time-core"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e153e1f1acaef8acc537e68b44906d2db6436e2b35ac2c6b42640fff91f00fd"

[[package]]
name = "tracing"
version = "0.1.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8"
dependencies = [
 "cfg-if",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4017f8f45139870ca7e672686113917c71c7a6e02d4924eda67186083c03081a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24eb03ba0eab1fd845050058ce5e616558e8f8d8fca633e6b163fe25c797213a"
dependencies = [
 "once_cell",
]

[[package]]
name = "typenum"
version = "1.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba"

[[package]]
name = "unicode-ident"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc"

[[package]]
name = "unicode-width"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b"

[[package]]
name = "unicode-xid"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "walkdir"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56"
dependencies = [
 "same-file",
 "winapi",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.10.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a143597ca7c7793eff794def352d41792a93c481eb1042423ff7ff72ba2c31f"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.84"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31f8dcbc21f30d9b8f2ea926ecb58f6b91192c17e9d33594b3df58b2007ca53b"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.84"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95ce90fd5bcc06af55a641a86428ee4229e44e07033963a2290a8e241607ccb9"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.84"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c21f77c0bedc37fd5dc21f897894a5ca01e7bb159884559461862ae90c0b4c5"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.84"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2aff81306fcac3c7515ad4e177f521b5c9a15f2b08f4e32d823066102f35a5f6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.84"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0046fef7e28c3804e5e38bfa31ea2a0f73905319b677e57ebe37e49358989b5d"

[[package]]
name = "which"
version = "4.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2441c784c52b289a054b7201fc93253e288f094e2f4be9058343127c4226a269"
dependencies = [
 "either",
 "libc",
 "once_cell",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.42.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e2522491fbfcd58cc84d47aeb2958948c4b8982e9a2d8a2a35bbaed431390e7"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7"

[[package]]
name = "windows_i686_gnu"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640"

[[package]]
name = "windows_i686_msvc"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd"

[[package]]
name = "zip"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93ab48844d61251bb3835145c521d88aa4031d7139e8485990f60ca911fa0815"
dependencies = [
 "byteorder",
 "bzip2",
 "crc32fast",
 "flate2",
 "thiserror",
 "time 0.1.45",
]

[[package]]
name = "zip"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0445d0fbc924bb93539b4316c11afb121ea39296f99a3c4c9edad09e3658cdef"
dependencies = [
 "aes",
 "byteorder",
 "bzip2",
 "constant_time_eq",
 "crc32fast",
 "crossbeam-utils",
 "flate2",
 "hmac",
 "pbkdf2",
 "sha1",
 "time 0.3.20",
 "zstd",
]

[[package]]
name = "zip-extensions"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a64c3c977bc3434ce2d4bcea8ad3c644672de0f2c402b72b9171ca80a8885d14"
dependencies = [
 "zip 0.5.13",
]

[[package]]
name = "zstd"
version = "0.11.2+zstd.1.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20cc960326ece64f010d2d2107537f26dc589a6573a316bd5b1dba685fa5fde4"
dependencies = [
 "zstd-safe",
]

[[package]]
name = "zstd-safe"
version = "5.0.2+zstd.1.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d2a5585e04f9eea4b2a3d1eca508c4dee9592a89ef6f450c11719da0726f4db"
dependencies = [
 "libc",
 "zstd-sys",
]

[[package]]
name = "zstd-sys"
version = "2.0.7+zstd.1.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94509c3ba2fe55294d752b79842c530ccfab760192521df74a081a78d2b3c7f5"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
]

```

`userspace/ksud/Cargo.toml`:

```toml
[package]
name = "ksud"
version = "0.1.0"
edition = "2021"
rust-version = "1.65"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1.0.68"
clap = { version = "4.0.32", features = ["derive"] }
const_format = "0.2.30"
zip = "0.6.3"
zip-extensions = "0.6.1"
java-properties = "1.4.1"
log = "0.4.17"
env_logger = "0.10.0"
serde = { version = "1.0" }
serde_json = "1.0"
regex = "1.5.4"
encoding = "0.2.33"
retry = "2.0.0"
humansize = "2.0.0"
libc = "0.2"
extattr = "1.0.0"
jwalk = "0.8.1"
is_executable = "1.0.1"
nom = "7"
derive-new = "0.5"
rust-embed = { version = "6.4.2", features = [
    "debug-embed",
    "compression", # must clean build after updating binaries
] }
which = "4.2.2"
getopts = "0.2.21"

[target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
sys-mount = { git = "https://github.com/tiann/sys-mount", branch = "loopfix" }
# some android specific dependencies which compiles under unix are also listed here for convenience of coding
android-properties = { version = "0.2.2", features = ["bionic-deprecated"] }
procfs = "0.15"

[target.'cfg(target_os = "android")'.dependencies]
android_logger = "0.13"

[profile.release]
strip = true
opt-level = "z"
lto = true

```

`userspace/ksud/build.rs`:

```rs
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;

fn get_git_version() -> Result<(u32, String), std::io::Error> {
    let output = Command::new("git")
        .args(["rev-list", "--count", "HEAD"])
        .output()?;

    let output = output.stdout;
    let version_code = String::from_utf8(output).expect("Failed to read git count stdout");
    let version_code: u32 = version_code
        .trim()
        .parse()
        .map_err(|_| std::io::Error::new(std::io::ErrorKind::Other, "Failed to parse git count"))?;
    let version_code = 10000 + 200 + version_code; // For historical reasons

    let version_name = String::from_utf8(
        Command::new("git")
            .args(["describe", "--tags", "--always"])
            .output()?
            .stdout,
    )
    .map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::Other,
            "Failed to read git describe stdout",
        )
    })?;
    let version_name = version_name.trim_start_matches('v').to_string();
    Ok((version_code, version_name))
}

fn main() {
    let (code, name) = match get_git_version() {
        Ok((code, name)) => (code, name),
        Err(_) => {
            // show warning if git is not installed
            println!("cargo:warning=Failed to get git version, using 0.0.0");
            (0, "0.0.0".to_string())
        }
    };
    let out_dir = env::var("OUT_DIR").expect("Failed to get $OUT_DIR");
    let out_dir = Path::new(&out_dir);
    File::create(Path::new(out_dir).join("VERSION_CODE"))
        .expect("Failed to create VERSION_CODE")
        .write_all(code.to_string().as_bytes())
        .expect("Failed to write VERSION_CODE");

    File::create(Path::new(out_dir).join("VERSION_NAME"))
        .expect("Failed to create VERSION_NAME")
        .write_all(name.trim().as_bytes())
        .expect("Failed to write VERSION_NAME");
}

```

`userspace/ksud/src/apk_sign.rs`:

```rs
use anyhow::{ensure, Result};
use std::io::{Read, Seek, SeekFrom};

pub fn get_apk_signature(apk: &str) -> Result<(u32, u32)> {
    let mut buffer = [0u8; 0x10];
    let mut size4 = [0u8; 4];
    let mut size8 = [0u8; 8];
    let mut size_of_block = [0u8; 8];

    let mut f = std::fs::File::open(apk)?;

    let mut i = 0;
    loop {
        let mut n = [0u8; 2];
        f.seek(SeekFrom::End(-i - 2))?;
        f.read_exact(&mut n)?;

        let n = u16::from_le_bytes(n);
        if i64::from(n) == i {
            f.seek(SeekFrom::Current(-22))?;
            f.read_exact(&mut size4)?;

            if u32::from_le_bytes(size4) ^ 0xcafe_babe_u32 == 0xccfb_f1ee_u32 {
                if i > 0 {
                    println!("warning: comment length is {i}");
                }
                break;
            }
        }

        ensure!(n != 0xffff, "not a zip file");

        i += 1;
    }

    f.seek(SeekFrom::Current(12))?;
    // offset
    f.read_exact(&mut size4)?;
    f.seek(SeekFrom::Start(u64::from(u32::from_le_bytes(size4)) - 0x18))?;

    f.read_exact(&mut size8)?;
    f.read_exact(&mut buffer)?;

    ensure!(&buffer == b"APK Sig Block 42", "Can not found sig block");

    let pos = u64::from(u32::from_le_bytes(size4)) - (u64::from_le_bytes(size8) + 0x8);
    f.seek(SeekFrom::Start(pos))?;
    f.read_exact(&mut size_of_block)?;

    ensure!(size_of_block == size8, "not a signed apk");

    loop {
        let mut id = [0u8; 4];
        let offset = 4u32;

        f.read_exact(&mut size8)?; // sequence length
        if size8 == size_of_block {
            break;
        }

        f.read_exact(&mut id)?; // id

        let id = u32::from_le_bytes(id);
        if (id ^ 0xdead_beef_u32) == 0xafa4_39f5_u32 || (id ^ 0xdead_beef_u32) == 0x2efe_d62f_u32 {
            f.read_exact(&mut size4)?; // signer-sequence length
            f.read_exact(&mut size4)?; // signer length
            f.read_exact(&mut size4)?; // signed data length
                                       // offset += 0x4 * 3;

            f.read_exact(&mut size4)?; // digests-sequcence length
            let pos = u32::from_le_bytes(size4);
            f.seek(SeekFrom::Current(i64::from(pos)))?;
            // offset += 0x4 + pos;

            f.read_exact(&mut size4)?; // certificates length
            f.read_exact(&mut size4)?; // certificate length
                                       // offset += 0x4 * 2;

            let mut hash = 1i32;
            let mut c = [0u8; 1];

            let j = u32::from_le_bytes(size4);
            for _ in 0..j {
                f.read_exact(&mut c)?;
                hash = hash.wrapping_mul(31).wrapping_add(i32::from(c[0] as i8));
            }

            // offset += j;

            let out_size = j;
            let out_hash = (hash as u32) ^ 0x1413_1211_u32;

            return Ok((out_size, out_hash));
        }

        f.seek(SeekFrom::Current(
            i64::from_le_bytes(size8) - i64::from(offset),
        ))?;
    }

    Err(anyhow::anyhow!("Unknown error"))
}

```

`userspace/ksud/src/assets.rs`:

```rs
use anyhow::Result;
use const_format::concatcp;
use rust_embed::RustEmbed;

use crate::{defs::BINARY_DIR, utils};

pub const RESETPROP_PATH: &str = concatcp!(BINARY_DIR, "resetprop");
pub const BUSYBOX_PATH: &str = concatcp!(BINARY_DIR, "busybox");

#[cfg(target_arch = "aarch64")]
#[derive(RustEmbed)]
#[folder = "bin/aarch64"]
struct Asset;

#[cfg(target_arch = "x86_64")]
#[derive(RustEmbed)]
#[folder = "bin/x86_64"]
struct Asset;

pub fn ensure_binaries() -> Result<()> {
    for file in Asset::iter() {
        utils::ensure_binary(
            format!("{BINARY_DIR}{file}"),
            &Asset::get(&file).unwrap().data,
        )?
    }
    Ok(())
}

```

`userspace/ksud/src/cli.rs`:

```rs
use anyhow::{Ok, Result};
use clap::Parser;

#[cfg(target_os = "android")]
use android_logger::Config;
#[cfg(target_os = "android")]
use log::LevelFilter;

use crate::{apk_sign, debug, defs, event};

/// KernelSU userspace cli
#[derive(Parser, Debug)]
#[command(author, version = defs::VERSION_NAME, about, long_about = None)]
struct Args {
    #[command(subcommand)]
    command: Commands,
}

#[derive(clap::Subcommand, Debug)]
enum Commands {
    /// Trigger `post-fs-data` event
    PostFsData,

    /// Trigger `service` event
    Services,

    /// Trigger `boot-complete` event
    BootCompleted,

    /// Install KernelSU userspace component to system
    Install,

    /// SELinux policy Patch tool
    Sepolicy {
        #[command(subcommand)]
        command: Sepolicy,
    },

    /// Manage App Profiles
    Profile {
        #[command(subcommand)]
        command: Profile,
    },

    /// For developers
    Debug {
        #[command(subcommand)]
        command: Debug,
    },
}
#[derive(clap::Subcommand, Debug)]
enum Debug {
    /// Set the manager app, kernel CONFIG_KSU_DEBUG should be enabled.
    SetManager {
        /// manager package name
        #[arg(default_value_t = String::from("me.weishu.kernelsu"))]
        apk: String,
    },

    /// Get apk size and hash
    GetSign {
        /// apk path
        apk: String,
    },

    /// Root Shell
    Su,

    /// Get kernel version
    Version,

    /// For testing
    Test,
}

#[derive(clap::Subcommand, Debug)]
enum Sepolicy {
    /// Patch sepolicy
    Patch {
        /// sepolicy statements
        sepolicy: String,
    },

    /// Apply sepolicy from file
    Apply {
        /// sepolicy file path
        file: String,
    },

    /// Check if sepolicy statement is supported/valid
    Check {
        /// sepolicy statements
        sepolicy: String,
    },
}

#[derive(clap::Subcommand, Debug)]
enum Profile {
    /// get root profile's selinux policy of <package-name>
    GetSepolicy {
        /// package name
        package: String,
    },

    /// set root profile's selinux policy of <package-name> to <profile>
    SetSepolicy {
        /// package name
        package: String,
        /// policy statements
        policy: String,
    },

    /// get template of <package-name>
    GetTemplate {
        /// package name
        package: String,
    },

    /// set template of <package-name> to <template>
    SetTemplate {
        /// package name
        package: String,
        /// template
        template: String,
    },

    /// list all templates
    ListTemplates,
}

pub fn run() -> Result<()> {
    #[cfg(target_os = "android")]
    android_logger::init_once(
        Config::default()
            .with_max_level(LevelFilter::Trace) // limit log level
            .with_tag("KernelSU"), // logs will show under mytag tag
    );

    #[cfg(not(target_os = "android"))]
    env_logger::init();

    // the kernel executes su with argv[0] = "su" and replace it with us
    let arg0 = std::env::args().next().unwrap_or_default();
    if arg0 == "su" || arg0 == "/system/bin/su" {
        return crate::ksu::root_shell();
    }

    let cli = Args::parse();

    log::info!("command: {:?}", cli.command);

    let result = match cli.command {
        Commands::PostFsData => event::on_post_data_fs(),
        Commands::BootCompleted => event::on_boot_completed(),

        Commands::Install => event::install(),
        Commands::Sepolicy { command } => match command {
            Sepolicy::Patch { sepolicy } => crate::sepolicy::live_patch(&sepolicy),
            Sepolicy::Apply { file } => crate::sepolicy::apply_file(file),
            Sepolicy::Check { sepolicy } => crate::sepolicy::check_rule(&sepolicy),
        },
        Commands::Services => event::on_services(),
        Commands::Profile { command } => match command {
            Profile::GetSepolicy { package } => crate::profile::get_sepolicy(package),
            Profile::SetSepolicy { package, policy } => {
                crate::profile::set_sepolicy(package, policy)
            }
            Profile::GetTemplate { package } => crate::profile::get_template(package),
            Profile::SetTemplate { package, template } => {
                crate::profile::set_template(package, template)
            }
            Profile::ListTemplates => crate::profile::list_templates(),
        },

        Commands::Debug { command } => match command {
            Debug::SetManager { apk } => debug::set_manager(&apk),
            Debug::GetSign { apk } => {
                let sign = apk_sign::get_apk_signature(&apk)?;
                println!("size: {:#x}, hash: {:#x}", sign.0, sign.1);
                Ok(())
            }
            Debug::Version => {
                println!("Kernel Version: {}", crate::ksu::get_version());
                Ok(())
            }
            Debug::Su => crate::ksu::grant_root(),
            Debug::Test => todo!(),
        },
    };

    if let Err(e) = &result {
        log::error!("Error: {:?}", e);
    }
    result
}

```

`userspace/ksud/src/debug.rs`:

```rs
use anyhow::{Context, Ok, Result};
use std::{
    path::{Path, PathBuf},
    process::Command,
};

use crate::apk_sign::get_apk_signature;

const KERNEL_PARAM_PATH: &str = "/sys/module/kernelsu";

fn read_u32(path: &PathBuf) -> Result<u32> {
    let content = std::fs::read_to_string(path)?;
    let content = content.trim();
    let content = content.parse::<u32>()?;
    Ok(content)
}

fn set_kernel_param(size: u32, hash: u32) -> Result<()> {
    let kernel_param_path = Path::new(KERNEL_PARAM_PATH).join("parameters");
    let expeced_size_path = kernel_param_path.join("ksu_expected_size");
    let expeced_hash_path = kernel_param_path.join("ksu_expected_hash");

    println!(
        "before size: {:#x} hash: {:#x}",
        read_u32(&expeced_size_path)?,
        read_u32(&expeced_hash_path)?
    );

    std::fs::write(&expeced_size_path, size.to_string())?;
    std::fs::write(&expeced_hash_path, hash.to_string())?;

    println!(
        "after size: {:#x} hash: {:#x}",
        read_u32(&expeced_size_path)?,
        read_u32(&expeced_hash_path)?
    );

    Ok(())
}

fn get_apk_path(package_name: &str) -> Result<String> {
    // `cmd package path` is not available below Android 9
    let output = Command::new("pm").args(["path", package_name]).output()?;

    // package:/data/app/<xxxx>/base.apk
    let output = String::from_utf8_lossy(&output.stdout);
    let path = output.trim().replace("package:", "");
    Ok(path)
}

pub fn set_manager(pkg: &str) -> Result<()> {
    let path = get_apk_path(pkg).with_context(|| format!("{pkg} does not exist!"))?;
    let sign = get_apk_signature(&path)?;
    set_kernel_param(sign.0, sign.1)?;
    Ok(())
}

```

`userspace/ksud/src/defs.rs`:

```rs
use const_format::concatcp;

pub const ADB_DIR: &str = "/data/adb/";
pub const WORKING_DIR: &str = concatcp!(ADB_DIR, "ksu/");
pub const BINARY_DIR: &str = concatcp!(WORKING_DIR, "bin/");
pub const LOG_DIR: &str = concatcp!(WORKING_DIR, "log/");

pub const PROFILE_DIR: &str = concatcp!(WORKING_DIR, "profile/");
pub const PROFILE_SELINUX_DIR: &str = concatcp!(PROFILE_DIR, "selinux/");
pub const PROFILE_TEMPLATE_DIR: &str = concatcp!(PROFILE_DIR, "templates/");

pub const KSURC_PATH: &str = concatcp!(WORKING_DIR, ".ksurc");
pub const DAEMON_PATH: &str = concatcp!(ADB_DIR, "ksud");

#[cfg(target_os = "android")]
pub const DAEMON_LINK_PATH: &str = concatcp!(BINARY_DIR, "ksud");

pub const COMMON_DIR: &str = concatcp!(ADB_DIR, "common/");

pub const VERSION_CODE: &str = include_str!(concat!(env!("OUT_DIR"), "/VERSION_CODE"));
pub const VERSION_NAME: &str = include_str!(concat!(env!("OUT_DIR"), "/VERSION_NAME"));

```

`userspace/ksud/src/event.rs`:

```rs
use anyhow::{Context, Result};
use log::{info, warn};
use std::{path::Path, path::PathBuf};

use crate::{
    assets, defs, restorecon,
    utils::{self, ensure_dir_exists},
};

pub fn on_post_data_fs() -> Result<()> {
    crate::ksu::report_post_fs_data();

    utils::umask(0);

    #[cfg(unix)]
    let _ = catch_bootlog();

    let safe_mode = crate::utils::is_safe_mode();

    if safe_mode {
        // we should still mount modules.img to `/data/adb/modules` in safe mode
        // becuase we may need to operate the module dir in safe mode
        warn!("safe mode, skip common post-fs-data.d scripts");
    } else {
        // Then exec common post-fs-data scripts
        if let Err(e) = crate::module::exec_common_scripts("post-fs-data.d", true) {
            warn!("exec common post-fs-data scripts failed: {}", e);
        }
    }

    assets::ensure_binaries().with_context(|| "Failed to extract bin assets")?;

    // if we are in safe mode, we should disable all modules
    if safe_mode {
        warn!("safe mode, skip post-fs-data scripts");
        return Ok(());
    }

    if let Err(e) = restorecon::restorecon() {
        warn!("restorecon failed: {}", e);
    }

    // load sepolicy.rule
    if crate::module::load_sepolicy_rule().is_err() {
        warn!("load sepolicy.rule failed");
    }

    if let Err(e) = crate::profile::apply_sepolies() {
        warn!("apply root profile sepolicy failed: {}", e);
    }

    // exec modules post-fs-data scripts
    // TODO: Add timeout
    if let Err(e) = crate::module::exec_post_fs_data() {
        warn!("exec post-fs-data scripts failed: {}", e);
    }

    // load system.prop
    if let Err(e) = crate::module::load_system_prop() {
        warn!("load system.prop failed: {}", e);
    }

    std::env::set_current_dir("/").with_context(|| "failed to chdir to /")?;

    Ok(())
}

fn run_stage(stage: &str) {
    utils::umask(0);

    if crate::utils::is_safe_mode() {
        warn!("safe mode, skip {stage} scripts");
        return;
    }

    if let Err(e) = crate::module::exec_common_scripts(&format!("{stage}.d"), false) {
        warn!("Failed to exec common {stage} scripts: {e}");
    }
    if let Err(e) = crate::module::exec_stage_scripts(stage) {
        warn!("Failed to exec {stage} scripts: {e}");
    }
}

pub fn on_services() -> Result<()> {
    run_stage("service");

    Ok(())
}

pub fn on_boot_completed() -> Result<()> {
    crate::ksu::report_boot_complete();
    info!("on_boot_completed triggered!");

    run_stage("boot-completed");

    Ok(())
}

pub fn install() -> Result<()> {
    ensure_dir_exists(defs::ADB_DIR)?;
    std::fs::copy("/proc/self/exe", defs::DAEMON_PATH)?;
    restorecon::lsetfilecon(defs::DAEMON_PATH, restorecon::ADB_CON)?;
    // install binary assets
    assets::ensure_binaries().with_context(|| "Failed to extract assets")?;

    #[cfg(target_os = "android")]
    link_ksud_to_bin()?;

    Ok(())
}

#[cfg(target_os = "android")]
fn link_ksud_to_bin() -> Result<()> {
    let ksu_bin = PathBuf::from(defs::DAEMON_PATH);
    let ksu_bin_link = PathBuf::from(defs::DAEMON_LINK_PATH);
    if ksu_bin.exists() && !ksu_bin_link.exists() {
        std::os::unix::fs::symlink(&ksu_bin, &ksu_bin_link)?;
    }
    Ok(())
}

#[cfg(unix)]
fn catch_bootlog() -> Result<()> {
    use std::os::unix::process::CommandExt;
    use std::process::Stdio;

    let logdir = Path::new(defs::LOG_DIR);
    utils::ensure_dir_exists(logdir)?;
    let bootlog = logdir.join("boot.log");
    let oldbootlog = logdir.join("boot.old.log");

    if bootlog.exists() {
        std::fs::rename(&bootlog, oldbootlog)?;
    }

    let bootlog = std::fs::File::create(bootlog)?;

    // timeout -s 9 30s logcat > boot.log
    let result = unsafe {
        std::process::Command::new("timeout")
            .process_group(0)
            .pre_exec(|| {
                utils::switch_cgroups();
                Ok(())
            })
            .arg("-s")
            .arg("9")
            .arg("30s")
            .arg("logcat")
            .stdout(Stdio::from(bootlog))
            .spawn()
    };

    if let Err(e) = result {
        warn!("Failed to start logcat: {:#}", e);
    }

    Ok(())
}

```

`userspace/ksud/src/ksu.rs`:

```rs
use anyhow::{Ok, Result};

#[cfg(unix)]
use anyhow::ensure;
use getopts::Options;
use std::env;
#[cfg(unix)]
use std::os::unix::process::CommandExt;
use std::path::PathBuf;
use std::{ffi::CStr, process::Command};

use crate::{
    defs,
    utils::{self, umask},
};

pub const KERNEL_SU_OPTION: u32 = 0xDEAD_BEEF;

const CMD_GRANT_ROOT: u64 = 0;
// const CMD_BECOME_MANAGER: u64 = 1;
const CMD_GET_VERSION: u64 = 2;
// const CMD_ALLOW_SU: u64 = 3;
// const CMD_DENY_SU: u64 = 4;
// const CMD_GET_ALLOW_LIST: u64 = 5;
// const CMD_GET_DENY_LIST: u64 = 6;
const CMD_REPORT_EVENT: u64 = 7;
pub const CMD_SET_SEPOLICY: u64 = 8;
pub const CMD_CHECK_SAFEMODE: u64 = 9;

const EVENT_POST_FS_DATA: u64 = 1;
const EVENT_BOOT_COMPLETED: u64 = 2;

#[cfg(any(target_os = "linux", target_os = "android"))]
pub fn grant_root() -> Result<()> {
    let mut result: u32 = 0;
    unsafe {
        #[allow(clippy::cast_possible_wrap)]
        libc::prctl(
            KERNEL_SU_OPTION as i32, // supposed to overflow
            CMD_GRANT_ROOT,
            0,
            0,
            std::ptr::addr_of_mut!(result).cast::<libc::c_void>(),
        );
    }

    ensure!(result == KERNEL_SU_OPTION, "grant root failed");
    Err(std::process::Command::new("sh").exec().into())
}

#[cfg(not(any(target_os = "linux", target_os = "android")))]
pub fn grant_root() -> Result<()> {
    unimplemented!("grant_root is only available on android");
}

fn print_usage(program: &str, opts: Options) {
    let brief = format!("KernelSU\n\nUsage: {program} [options] [-] [user [argument...]]");
    print!("{}", opts.usage(&brief));
}

fn set_identity(uid: u32, gid: u32) {
    #[cfg(any(target_os = "linux", target_os = "android"))]
    unsafe {
        libc::seteuid(uid);
        libc::setresgid(gid, gid, gid);
        libc::setresuid(uid, uid, uid);
    }
}

#[cfg(not(unix))]
pub fn root_shell() -> Result<()> {
    unimplemented!()
}

#[cfg(unix)]
pub fn root_shell() -> Result<()> {
    // we are root now, this was set in kernel!
    let env_args: Vec<String> = std::env::args().collect();
    let program = env_args[0].clone();
    let args = env_args
        .iter()
        .position(|arg| arg == "-c")
        .map(|i| {
            let rest = env_args[i + 1..].to_vec();
            let mut new_args = env_args[..i].to_vec();
            new_args.push("-c".to_string());
            if !rest.is_empty() {
                new_args.push(rest.join(" "));
            }
            new_args
        })
        .unwrap_or_else(|| env_args.clone());

    let mut opts = Options::new();
    opts.optopt(
        "c",
        "command",
        "pass COMMAND to the invoked shell",
        "COMMAND",
    );
    opts.optflag("h", "help", "display this help message and exit");
    opts.optflag("l", "login", "pretend the shell to be a login shell");
    opts.optflag(
        "p",
        "preserve-environment",
        "preserve the entire environment",
    );
    opts.optflag(
        "s",
        "shell",
        "use SHELL instead of the default /system/bin/sh",
    );
    opts.optflag("v", "version", "display version number and exit");
    opts.optflag("V", "", "display version code and exit");
    opts.optflag(
        "M",
        "mount-master",
        "force run in the global mount namespace",
    );

    // Replace -cn with -z, -mm with -M for supporting getopt_long
    let args = args
        .into_iter()
        .map(|e| {
            if e == "-mm" {
                "-M".to_string()
            } else if e == "-cn" {
                "-z".to_string()
            } else {
                e
            }
        })
        .collect::<Vec<String>>();

    let matches = match opts.parse(&args[1..]) {
        std::result::Result::Ok(m) => m,
        Err(f) => {
            println!("{f}");
            print_usage(&program, opts);
            std::process::exit(-1);
        }
    };

    if matches.opt_present("h") {
        print_usage(&program, opts);
        return Ok(());
    }

    if matches.opt_present("v") {
        println!("{}:KernelSU", defs::VERSION_NAME);
        return Ok(());
    }

    if matches.opt_present("V") {
        println!("{}", defs::VERSION_CODE);
        return Ok(());
    }

    let shell = matches.opt_str("s").unwrap_or("/system/bin/sh".to_string());
    let mut is_login = matches.opt_present("l");
    let preserve_env = matches.opt_present("p");
    let mount_master = matches.opt_present("M");

    // we've make sure that -c is the last option and it already contains the whole command, no need to construct it again
    let args = matches
        .opt_str("c")
        .map(|cmd| vec!["-c".to_string(), cmd])
        .unwrap_or_default();

    let mut free_idx = 0;
    if !matches.free.is_empty() && matches.free[free_idx] == "-" {
        is_login = true;
        free_idx += 1;
    }

    // use current uid if no user specified, these has been done in kernel!
    let mut uid = unsafe { libc::getuid() };
    let gid = unsafe { libc::getgid() };
    if free_idx < matches.free.len() {
        let name = &matches.free[free_idx];
        uid = unsafe {
            #[cfg(target_arch = "aarch64")]
            let pw = libc::getpwnam(name.as_ptr() as *const u8).as_ref();
            #[cfg(target_arch = "x86_64")]
            let pw = libc::getpwnam(name.as_ptr() as *const i8).as_ref();

            match pw {
                Some(pw) => pw.pw_uid,
                None => name.parse::<u32>().unwrap_or(0),
            }
        }
    }

    // https://github.com/topjohnwu/Magisk/blob/master/native/src/su/su_daemon.cpp#L408
    let arg0 = if is_login { "-" } else { &shell };

    let mut command = &mut Command::new(&shell);

    if !preserve_env {
        // This is actually incorrect, i don't know why.
        // command = command.env_clear();

        let pw = unsafe { libc::getpwuid(uid).as_ref() };

        if let Some(pw) = pw {
            let home = unsafe { CStr::from_ptr(pw.pw_dir) };
            let pw_name = unsafe { CStr::from_ptr(pw.pw_name) };

            let home = home.to_string_lossy();
            let pw_name = pw_name.to_string_lossy();

            command = command
                .env("HOME", home.as_ref())
                .env("USER", pw_name.as_ref())
                .env("LOGNAME", pw_name.as_ref())
                .env("SHELL", &shell);
        }
    }

    // add /data/adb/ksu/bin to PATH
    #[cfg(any(target_os = "linux", target_os = "android"))]
    add_path_to_env(defs::BINARY_DIR)?;

    // when KSURC_PATH exists and ENV is not set, set ENV to KSURC_PATH
    if PathBuf::from(defs::KSURC_PATH).exists() && env::var("ENV").is_err() {
        command = command.env("ENV", defs::KSURC_PATH);
    }

    // escape from the current cgroup and become session leader
    // WARNING!!! This cause some root shell hang forever!
    // command = command.process_group(0);
    command = unsafe {
        command.pre_exec(move || {
            umask(0o22);
            utils::switch_cgroups();

            // switch to global mount namespace
            #[cfg(any(target_os = "linux", target_os = "android"))]
            if mount_master {
                let _ = utils::switch_mnt_ns(1);
                let _ = utils::unshare_mnt_ns();
            }

            set_identity(uid, gid);

            std::result::Result::Ok(())
        })
    };

    command = command.args(args).arg0(arg0);
    Err(command.exec().into())
}

fn add_path_to_env(path: &str) -> Result<()> {
    let mut paths =
        env::var_os("PATH").map_or(Vec::new(), |val| env::split_paths(&val).collect::<Vec<_>>());
    let new_path = PathBuf::from(path.trim_end_matches('/'));
    paths.push(new_path);
    let new_path_env = env::join_paths(paths)?;
    env::set_var("PATH", new_path_env);
    Ok(())
}

pub fn get_version() -> i32 {
    let mut result: i32 = 0;
    #[cfg(any(target_os = "linux", target_os = "android"))]
    unsafe {
        #[allow(clippy::cast_possible_wrap)]
        libc::prctl(
            KERNEL_SU_OPTION as i32, // supposed to overflow
            CMD_GET_VERSION,
            std::ptr::addr_of_mut!(result).cast::<libc::c_void>(),
        );
    }
    result
}

fn report_event(event: u64) {
    #[cfg(any(target_os = "linux", target_os = "android"))]
    unsafe {
        #[allow(clippy::cast_possible_wrap)]
        libc::prctl(
            KERNEL_SU_OPTION as i32, // supposed to overflow
            CMD_REPORT_EVENT,
            event,
        );
    }
}

pub fn check_kernel_safemode() -> bool {
    let mut result: i32 = 0;
    #[cfg(any(target_os = "linux", target_os = "android"))]
    unsafe {
        #[allow(clippy::cast_possible_wrap)]
        libc::prctl(
            KERNEL_SU_OPTION as i32, // supposed to overflow
            CMD_CHECK_SAFEMODE,
            0,
            0,
            std::ptr::addr_of_mut!(result).cast::<libc::c_void>(),
        );
    }
    result == KERNEL_SU_OPTION as i32
}

pub fn report_post_fs_data() {
    report_event(EVENT_POST_FS_DATA);
}

pub fn report_boot_complete() {
    report_event(EVENT_BOOT_COMPLETED);
}

```

`userspace/ksud/src/main.rs`:

```rs
mod apk_sign;
mod assets;
mod cli;
mod debug;
mod defs;
mod event;
mod ksu;
mod module;
mod profile;
mod restorecon;
mod sepolicy;
mod utils;

fn main() -> anyhow::Result<()> {
    cli::run()
}

```

`userspace/ksud/src/module.rs`:

```rs
#[allow(clippy::wildcard_imports)]
use crate::{assets, defs, sepolicy, utils::*};

use anyhow::{anyhow, Context, Result};
use is_executable::is_executable;
use log::{info, warn};
use std::{env::var as env_var, path::Path, process::Command};

#[cfg(unix)]
use std::os::unix::process::CommandExt;

pub fn load_sepolicy_rule() -> Result<()> {
    let rule_file = Path::new(defs::COMMON_DIR).join("sepolicy.rule");
    if !rule_file.exists() {
        return Ok(());
    }
    info!("load policy: {}", &rule_file.display());

    if sepolicy::apply_file(&rule_file).is_err() {
        warn!("Failed to load sepolicy.rule for {}", &rule_file.display());
    }
    Ok(())
}

fn exec_script<T: AsRef<Path>>(path: T, wait: bool) -> Result<()> {
    info!("exec {}", path.as_ref().display());

    let mut command = &mut Command::new(assets::BUSYBOX_PATH);
    #[cfg(unix)]
    {
        command = command.process_group(0);
        command = unsafe {
            command.pre_exec(|| {
                // ignore the error?
                switch_cgroups();
                Ok(())
            })
        };
    }
    command = command
        .current_dir(path.as_ref().parent().unwrap())
        .arg("sh")
        .arg(path.as_ref())
        .env("ASH_STANDALONE", "1")
        .env("KSU", "true")
        .env("KSU_KERNEL_VER_CODE", crate::ksu::get_version().to_string())
        .env("KSU_VER_CODE", defs::VERSION_CODE)
        .env("KSU_VER", defs::VERSION_NAME)
        .env(
            "PATH",
            format!(
                "{}:{}",
                env_var("PATH").unwrap(),
                defs::BINARY_DIR.trim_end_matches('/')
            ),
        );

    let result = if wait {
        command.status().map(|_| ())
    } else {
        command.spawn().map(|_| ())
    };
    result.map_err(|err| anyhow!("Failed to exec {}: {}", path.as_ref().display(), err))
}

pub fn exec_post_fs_data() -> Result<()> {
    let post_fs_data = Path::new(defs::COMMON_DIR).join("post-fs-data.sh");
    if !post_fs_data.exists() {
        return Ok(());
    }

    exec_script(&post_fs_data, true)
}

pub fn exec_common_scripts(dir: &str, wait: bool) -> Result<()> {
    let script_dir = Path::new(defs::ADB_DIR).join(dir);
    if !script_dir.exists() {
        info!("{} not exists, skip", script_dir.display());
        return Ok(());
    }

    let dir = std::fs::read_dir(&script_dir)?;
    for entry in dir.flatten() {
        let path = entry.path();

        if !is_executable(&path) {
            warn!("{} is not executable, skip", path.display());
            continue;
        }

        exec_script(path, wait)?;
    }

    Ok(())
}

/// execute every modules' [stage].sh (service.sh, boot-completed.sh)
pub fn exec_stage_scripts(stage: &str) -> Result<()> {
    let service = Path::new(defs::COMMON_DIR).join(format!("{stage}.sh"));
    if !service.exists() {
        return Ok(());
    }

    exec_script(&service, false)
}

pub fn load_system_prop() -> Result<()> {
    let system_prop = Path::new(defs::COMMON_DIR).join("system.prop");
    if !system_prop.exists() {
        return Ok(());
    }
    info!("load system.prop");

    // resetprop -n --file system.prop
    Command::new(assets::RESETPROP_PATH)
        .arg("-n")
        .arg("--file")
        .arg(&system_prop)
        .status()
        .with_context(|| format!("Failed to exec {}", system_prop.display()))?;

    Ok(())
}

```

`userspace/ksud/src/profile.rs`:

```rs
use crate::utils::ensure_dir_exists;
use crate::{defs, sepolicy};
use anyhow::{Context, Result};
use std::path::Path;

pub fn set_sepolicy(pkg: String, policy: String) -> Result<()> {
    ensure_dir_exists(defs::PROFILE_SELINUX_DIR)?;
    let policy_file = Path::new(defs::PROFILE_SELINUX_DIR).join(pkg);
    std::fs::write(&policy_file, policy)?;
    sepolicy::apply_file(&policy_file)?;
    Ok(())
}

pub fn get_sepolicy(pkg: String) -> Result<()> {
    let policy_file = Path::new(defs::PROFILE_SELINUX_DIR).join(pkg);
    let policy = std::fs::read_to_string(policy_file)?;
    println!("{policy}");
    Ok(())
}

pub fn set_template(name: String, template: String) -> Result<()> {
    ensure_dir_exists(defs::PROFILE_TEMPLATE_DIR)?;
    let template_file = Path::new(defs::PROFILE_TEMPLATE_DIR).join(name);
    std::fs::write(template_file, template)?;
    Ok(())
}

pub fn get_template(name: String) -> Result<()> {
    let template_file = Path::new(defs::PROFILE_TEMPLATE_DIR).join(name);
    let template = std::fs::read_to_string(template_file)?;
    println!("{template}");
    Ok(())
}

pub fn list_templates() -> Result<()> {
    let templates = std::fs::read_dir(defs::PROFILE_TEMPLATE_DIR)?;
    for template in templates {
        let template = template?;
        let template = template.file_name();
        if let Some(template) = template.to_str() {
            println!("{template}");
        };
    }
    Ok(())
}

pub fn apply_sepolies() -> Result<()> {
    let path = Path::new(defs::PROFILE_SELINUX_DIR);
    if !path.exists() {
        log::info!("profile sepolicy dir not exists.");
        return Ok(());
    }

    let sepolicies =
        std::fs::read_dir(path).with_context(|| "profile sepolicy dir open failed.".to_string())?;
    for sepolicy in sepolicies {
        let Ok(sepolicy) = sepolicy else {
            log::info!("profile sepolicy dir read failed.");
            continue;
        };
        let sepolicy = sepolicy.path();
        if sepolicy::apply_file(&sepolicy).is_ok() {
            log::info!("profile sepolicy applied: {:?}", sepolicy);
        } else {
            log::info!("profile sepolicy apply failed: {:?}", sepolicy);
        }
    }
    Ok(())
}

```

`userspace/ksud/src/restorecon.rs`:

```rs
use crate::defs;
use anyhow::Result;
use std::path::Path;

#[cfg(any(target_os = "linux", target_os = "android"))]
use anyhow::{Context, Ok};
#[cfg(any(target_os = "linux", target_os = "android"))]
use extattr::{lsetxattr, Flags as XattrFlags};

pub const ADB_CON: &str = "u:object_r:adb_data_file:s0";

const SELINUX_XATTR: &str = "security.selinux";

pub fn lsetfilecon<P: AsRef<Path>>(path: P, con: &str) -> Result<()> {
    #[cfg(any(target_os = "linux", target_os = "android"))]
    lsetxattr(&path, SELINUX_XATTR, con, XattrFlags::empty()).with_context(|| {
        format!(
            "Failed to change SELinux context for {}",
            path.as_ref().display()
        )
    })?;
    Ok(())
}

pub fn restorecon() -> Result<()> {
    lsetfilecon(defs::DAEMON_PATH, ADB_CON)?;
    Ok(())
}

```

`userspace/ksud/src/sepolicy.rs`:

```rs
use anyhow::{bail, Result};
use derive_new::new;
use nom::{
    branch::alt,
    bytes::complete::{tag, take_while, take_while1, take_while_m_n},
    character::{
        complete::{space0, space1},
        is_alphanumeric,
    },
    combinator::map,
    sequence::Tuple,
    IResult, Parser,
};
use std::{path::Path, vec};

type SeObject<'a> = Vec<&'a str>;

fn is_sepolicy_char(c: char) -> bool {
    is_alphanumeric(c as u8) || c == '_' || c == '-'
}

fn parse_single_word(input: &str) -> IResult<&str, &str> {
    take_while1(is_sepolicy_char).parse(input)
}

fn parse_bracket_objs(input: &str) -> IResult<&str, SeObject> {
    let (input, (_, words, _)) = (
        tag("{"),
        take_while_m_n(1, 100, |c: char| is_sepolicy_char(c) || c.is_whitespace()),
        tag("}"),
    )
        .parse(input)?;
    Ok((input, words.split_whitespace().collect()))
}

fn parse_single_obj(input: &str) -> IResult<&str, SeObject> {
    let (input, word) = take_while1(is_sepolicy_char).parse(input)?;
    Ok((input, vec![word]))
}

fn parse_star(input: &str) -> IResult<&str, SeObject> {
    let (input, _) = tag("*").parse(input)?;
    Ok((input, vec!["*"]))
}

// 1. a single sepolicy word
// 2. { obj1 obj2 obj3 ...}
// 3. *
fn parse_seobj(input: &str) -> IResult<&str, SeObject> {
    let (input, strs) = alt((parse_single_obj, parse_bracket_objs, parse_star)).parse(input)?;
    Ok((input, strs))
}

fn parse_seobj_no_star(input: &str) -> IResult<&str, SeObject> {
    let (input, strs) = alt((parse_single_obj, parse_bracket_objs)).parse(input)?;
    Ok((input, strs))
}

trait SeObjectParser<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self>
    where
        Self: Sized;
}

#[derive(Debug, PartialEq, Eq, new)]
struct NormalPerm<'a> {
    op: &'a str,
    source: SeObject<'a>,
    target: SeObject<'a>,
    class: SeObject<'a>,
    perm: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct XPerm<'a> {
    op: &'a str,
    source: SeObject<'a>,
    target: SeObject<'a>,
    class: SeObject<'a>,
    operation: &'a str,
    perm_set: &'a str,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeState<'a> {
    op: &'a str,
    stype: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeAttr<'a> {
    stype: SeObject<'a>,
    sattr: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct Type<'a> {
    name: &'a str,
    attrs: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct Attr<'a> {
    name: &'a str,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeTransition<'a> {
    source: &'a str,
    target: &'a str,
    class: &'a str,
    default_type: &'a str,
    object_name: Option<&'a str>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeChange<'a> {
    op: &'a str,
    source: &'a str,
    target: &'a str,
    class: &'a str,
    default_type: &'a str,
}

#[derive(Debug, PartialEq, Eq, new)]
struct GenFsCon<'a> {
    fs_name: &'a str,
    partial_path: &'a str,
    fs_context: &'a str,
}

#[derive(Debug)]
enum PolicyStatement<'a> {
    // "allow *source_type *target_type *class *perm_set"
    // "deny *source_type *target_type *class *perm_set"
    // "auditallow *source_type *target_type *class *perm_set"
    // "dontaudit *source_type *target_type *class *perm_set"
    NormalPerm(NormalPerm<'a>),

    // "allowxperm *source_type *target_type *class operation xperm_set"
    // "auditallowxperm *source_type *target_type *class operation xperm_set"
    // "dontauditxperm *source_type *target_type *class operation xperm_set"
    XPerm(XPerm<'a>),

    // "permissive ^type"
    // "enforce ^type"
    TypeState(TypeState<'a>),

    // "type type_name ^(attribute)"
    Type(Type<'a>),

    // "typeattribute ^type ^attribute"
    TypeAttr(TypeAttr<'a>),

    // "attribute ^attribute"
    Attr(Attr<'a>),

    // "type_transition source_type target_type class default_type (object_name)"
    TypeTransition(TypeTransition<'a>),

    // "type_change source_type target_type class default_type"
    // "type_member source_type target_type class default_type"
    TypeChange(TypeChange<'a>),

    // "genfscon fs_name partial_path fs_context"
    GenFsCon(GenFsCon<'a>),
}

impl<'a> SeObjectParser<'a> for NormalPerm<'a> {
    fn parse(input: &'a str) -> IResult<&str, Self> {
        let (input, op) = alt((
            tag("allow"),
            tag("deny"),
            tag("auditallow"),
            tag("dontaudit"),
        ))(input)?;

        let (input, _) = space0(input)?;
        let (input, source) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, target) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, class) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, perm) = parse_seobj(input)?;
        Ok((input, NormalPerm::new(op, source, target, class, perm)))
    }
}

impl<'a> SeObjectParser<'a> for XPerm<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((
            tag("allowxperm"),
            tag("auditallowxperm"),
            tag("dontauditxperm"),
        ))(input)?;

        let (input, _) = space0(input)?;
        let (input, source) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, target) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, class) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, operation) = parse_single_word(input)?;
        let (input, _) = space0(input)?;
        let (input, perm_set) = parse_single_word(input)?;

        Ok((
            input,
            XPerm::new(op, source, target, class, operation, perm_set),
        ))
    }
}

impl<'a> SeObjectParser<'a> for TypeState<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((tag("permissive"), tag("enforce")))(input)?;

        let (input, _) = space1(input)?;
        let (input, stype) = parse_seobj_no_star(input)?;

        Ok((input, TypeState::new(op, stype)))
    }
}

impl<'a> SeObjectParser<'a> for Type<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = tag("type")(input)?;
        let (input, _) = space1(input)?;
        let (input, name) = parse_single_word(input)?;

        if input.is_empty() {
            return Ok((input, Type::new(name, vec!["domain"]))); // default to domain
        }

        let (input, _) = space1(input)?;
        let (input, attrs) = parse_seobj_no_star(input)?;

        Ok((input, Type::new(name, attrs)))
    }
}

impl<'a> SeObjectParser<'a> for TypeAttr<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = alt((tag("typeattribute"), tag("attradd")))(input)?;
        let (input, _) = space1(input)?;
        let (input, stype) = parse_seobj_no_star(input)?;
        let (input, _) = space1(input)?;
        let (input, attr) = parse_seobj_no_star(input)?;

        Ok((input, TypeAttr::new(stype, attr)))
    }
}

impl<'a> SeObjectParser<'a> for Attr<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = tag("attribute")(input)?;
        let (input, _) = space1(input)?;
        let (input, attr) = parse_single_word(input)?;

        Ok((input, Attr::new(attr)))
    }
}

impl<'a> SeObjectParser<'a> for TypeTransition<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = alt((tag("type_transition"), tag("name_transition")))(input)?;
        let (input, _) = space1(input)?;
        let (input, source) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, target) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, class) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, default) = parse_single_word(input)?;

        if input.is_empty() {
            return Ok((
                input,
                TypeTransition::new(source, target, class, default, None),
            ));
        }

        let (input, _) = space1(input)?;
        let (input, object) = parse_single_word(input)?;

        Ok((
            input,
            TypeTransition::new(source, target, class, default, Some(object)),
        ))
    }
}

impl<'a> SeObjectParser<'a> for TypeChange<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((tag("type_change"), tag("type_member")))(input)?;
        let (input, _) = space1(input)?;
        let (input, source) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, target) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, class) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, default) = parse_single_word(input)?;

        Ok((input, TypeChange::new(op, source, target, class, default)))
    }
}

impl<'a> SeObjectParser<'a> for GenFsCon<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self>
    where
        Self: Sized,
    {
        let (input, _) = tag("genfscon")(input)?;
        let (input, _) = space1(input)?;
        let (input, fs) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, path) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, context) = parse_single_word(input)?;
        Ok((input, GenFsCon::new(fs, path, context)))
    }
}

impl<'a> PolicyStatement<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = space0(input)?;
        let (input, statement) = alt((
            map(NormalPerm::parse, PolicyStatement::NormalPerm),
            map(XPerm::parse, PolicyStatement::XPerm),
            map(TypeState::parse, PolicyStatement::TypeState),
            map(Type::parse, PolicyStatement::Type),
            map(TypeAttr::parse, PolicyStatement::TypeAttr),
            map(Attr::parse, PolicyStatement::Attr),
            map(TypeTransition::parse, PolicyStatement::TypeTransition),
            map(TypeChange::parse, PolicyStatement::TypeChange),
            map(GenFsCon::parse, PolicyStatement::GenFsCon),
        ))(input)?;
        let (input, _) = space0(input)?;
        let (input, _) = take_while(|c| c == ';')(input)?;
        let (input, _) = space0(input)?;
        Ok((input, statement))
    }
}

fn parse_sepolicy<'a, 'b>(input: &'b str, strict: bool) -> Result<Vec<PolicyStatement<'a>>>
where
    'b: 'a,
{
    let mut statements = vec![];

    for line in input.split(['\n', ';']) {
        if line.trim().is_empty() {
            continue;
        }
        if let Ok((_, statement)) = PolicyStatement::parse(line.trim()) {
            statements.push(statement);
        } else if strict {
            bail!("Failed to parse policy statement: {}", line)
        }
    }
    Ok(statements)
}

const SEPOLICY_MAX_LEN: usize = 128;

const CMD_NORMAL_PERM: u32 = 1;
const CMD_XPERM: u32 = 2;
const CMD_TYPE_STATE: u32 = 3;
const CMD_TYPE: u32 = 4;
const CMD_TYPE_ATTR: u32 = 5;
const CMD_ATTR: u32 = 6;
const CMD_TYPE_TRANSITION: u32 = 7;
const CMD_TYPE_CHANGE: u32 = 8;
const CMD_GENFSCON: u32 = 9;

#[derive(Debug, Default)]
enum PolicyObject {
    All, // for "*", stand for all objects, and is NULL in ffi
    One([u8; SEPOLICY_MAX_LEN]),
    #[default]
    None,
}

impl TryFrom<&str> for PolicyObject {
    type Error = anyhow::Error;
    fn try_from(s: &str) -> Result<Self> {
        anyhow::ensure!(s.len() <= SEPOLICY_MAX_LEN, "policy object too long");
        if s == "*" {
            return Ok(PolicyObject::All);
        }
        let mut buf = [0u8; SEPOLICY_MAX_LEN];
        buf[..s.len()].copy_from_slice(s.as_bytes());
        Ok(PolicyObject::One(buf))
    }
}

/// atomic statement, such as: allow domain1 domain2:file1 read;
/// normal statement would be expand to atomic statement, for example:
/// allow domain1 domain2:file1 { read write }; would be expand to two atomic statement
/// allow domain1 domain2:file1 read;allow domain1 domain2:file1 write;
#[allow(clippy::too_many_arguments)]
#[derive(Debug, new)]
struct AtomicStatement {
    cmd: u32,
    subcmd: u32,
    sepol1: PolicyObject,
    sepol2: PolicyObject,
    sepol3: PolicyObject,
    sepol4: PolicyObject,
    sepol5: PolicyObject,
    sepol6: PolicyObject,
    sepol7: PolicyObject,
}

impl<'a> TryFrom<&'a NormalPerm<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a NormalPerm<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "allow" => 1,
            "deny" => 2,
            "auditallow" => 3,
            "dontaudit" => 4,
            _ => 0,
        };
        for &s in &perm.source {
            for &t in &perm.target {
                for &c in &perm.class {
                    for &p in &perm.perm {
                        result.push(AtomicStatement {
                            cmd: CMD_NORMAL_PERM,
                            subcmd,
                            sepol1: s.try_into()?,
                            sepol2: t.try_into()?,
                            sepol3: c.try_into()?,
                            sepol4: p.try_into()?,
                            sepol5: PolicyObject::None,
                            sepol6: PolicyObject::None,
                            sepol7: PolicyObject::None,
                        });
                    }
                }
            }
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a XPerm<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a XPerm<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "allowxperm" => 1,
            "auditallowxperm" => 2,
            "dontauditxperm" => 3,
            _ => 0,
        };
        for &s in &perm.source {
            for &t in &perm.target {
                for &c in &perm.class {
                    result.push(AtomicStatement {
                        cmd: CMD_XPERM,
                        subcmd,
                        sepol1: s.try_into()?,
                        sepol2: t.try_into()?,
                        sepol3: c.try_into()?,
                        sepol4: perm.operation.try_into()?,
                        sepol5: perm.perm_set.try_into()?,
                        sepol6: PolicyObject::None,
                        sepol7: PolicyObject::None,
                    });
                }
            }
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeState<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeState<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "permissive" => 1,
            "enforcing" => 2,
            _ => 0,
        };
        for &t in &perm.stype {
            result.push(AtomicStatement {
                cmd: CMD_TYPE_STATE,
                subcmd,
                sepol1: t.try_into()?,
                sepol2: PolicyObject::None,
                sepol3: PolicyObject::None,
                sepol4: PolicyObject::None,
                sepol5: PolicyObject::None,
                sepol6: PolicyObject::None,
                sepol7: PolicyObject::None,
            });
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a Type<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a Type<'a>) -> Result<Self> {
        let mut result = vec![];
        for &attr in &perm.attrs {
            result.push(AtomicStatement {
                cmd: CMD_TYPE,
                subcmd: 0,
                sepol1: perm.name.try_into()?,
                sepol2: attr.try_into()?,
                sepol3: PolicyObject::None,
                sepol4: PolicyObject::None,
                sepol5: PolicyObject::None,
                sepol6: PolicyObject::None,
                sepol7: PolicyObject::None,
            });
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeAttr<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeAttr<'a>) -> Result<Self> {
        let mut result = vec![];
        for &t in &perm.stype {
            for &attr in &perm.sattr {
                result.push(AtomicStatement {
                    cmd: CMD_TYPE_ATTR,
                    subcmd: 0,
                    sepol1: t.try_into()?,
                    sepol2: attr.try_into()?,
                    sepol3: PolicyObject::None,
                    sepol4: PolicyObject::None,
                    sepol5: PolicyObject::None,
                    sepol6: PolicyObject::None,
                    sepol7: PolicyObject::None,
                });
            }
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a Attr<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a Attr<'a>) -> Result<Self> {
        let result = vec![AtomicStatement {
            cmd: CMD_ATTR,
            subcmd: 0,
            sepol1: perm.name.try_into()?,
            sepol2: PolicyObject::None,
            sepol3: PolicyObject::None,
            sepol4: PolicyObject::None,
            sepol5: PolicyObject::None,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        }];
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeTransition<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeTransition<'a>) -> Result<Self> {
        let mut result = vec![];
        let obj = match perm.object_name {
            Some(obj) => obj.try_into()?,
            None => PolicyObject::None,
        };
        result.push(AtomicStatement {
            cmd: CMD_TYPE_TRANSITION,
            subcmd: 0,
            sepol1: perm.source.try_into()?,
            sepol2: perm.target.try_into()?,
            sepol3: perm.class.try_into()?,
            sepol4: perm.default_type.try_into()?,
            sepol5: obj,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        });
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeChange<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeChange<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "type_change" => 1,
            "type_member" => 2,
            _ => 0,
        };
        result.push(AtomicStatement {
            cmd: CMD_TYPE_CHANGE,
            subcmd,
            sepol1: perm.source.try_into()?,
            sepol2: perm.target.try_into()?,
            sepol3: perm.class.try_into()?,
            sepol4: perm.default_type.try_into()?,
            sepol5: PolicyObject::None,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        });
        Ok(result)
    }
}

impl<'a> TryFrom<&'a GenFsCon<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a GenFsCon<'a>) -> Result<Self> {
        let result = vec![AtomicStatement {
            cmd: CMD_GENFSCON,
            subcmd: 0,
            sepol1: perm.fs_name.try_into()?,
            sepol2: perm.partial_path.try_into()?,
            sepol3: perm.fs_context.try_into()?,
            sepol4: PolicyObject::None,
            sepol5: PolicyObject::None,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        }];
        Ok(result)
    }
}

impl<'a> TryFrom<&'a PolicyStatement<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(value: &'a PolicyStatement) -> Result<Self> {
        match value {
            PolicyStatement::NormalPerm(perm) => perm.try_into(),
            PolicyStatement::XPerm(perm) => perm.try_into(),
            PolicyStatement::TypeState(perm) => perm.try_into(),
            PolicyStatement::Type(perm) => perm.try_into(),
            PolicyStatement::TypeAttr(perm) => perm.try_into(),
            PolicyStatement::Attr(perm) => perm.try_into(),
            PolicyStatement::TypeTransition(perm) => perm.try_into(),
            PolicyStatement::TypeChange(perm) => perm.try_into(),
            PolicyStatement::GenFsCon(perm) => perm.try_into(),
        }
    }
}

////////////////////////////////////////////////////////////////
///  for C FFI to call kernel interface
///////////////////////////////////////////////////////////////

#[derive(Debug)]
#[repr(C)]
struct FfiPolicy {
    cmd: u32,
    subcmd: u32,
    sepol1: *const libc::c_char,
    sepol2: *const libc::c_char,
    sepol3: *const libc::c_char,
    sepol4: *const libc::c_char,
    sepol5: *const libc::c_char,
    sepol6: *const libc::c_char,
    sepol7: *const libc::c_char,
}

fn to_c_ptr(pol: &PolicyObject) -> *const libc::c_char {
    match pol {
        PolicyObject::None | PolicyObject::All => std::ptr::null(),
        PolicyObject::One(s) => s.as_ptr().cast::<libc::c_char>(),
    }
}

impl From<AtomicStatement> for FfiPolicy {
    fn from(policy: AtomicStatement) -> FfiPolicy {
        FfiPolicy {
            cmd: policy.cmd,
            subcmd: policy.subcmd,
            sepol1: to_c_ptr(&policy.sepol1),
            sepol2: to_c_ptr(&policy.sepol2),
            sepol3: to_c_ptr(&policy.sepol3),
            sepol4: to_c_ptr(&policy.sepol4),
            sepol5: to_c_ptr(&policy.sepol5),
            sepol6: to_c_ptr(&policy.sepol6),
            sepol7: to_c_ptr(&policy.sepol7),
        }
    }
}

#[cfg(any(target_os = "linux", target_os = "android"))]
fn apply_one_rule<'a>(statement: &'a PolicyStatement<'a>, strict: bool) -> Result<()> {
    let policies: Vec<AtomicStatement> = statement.try_into()?;

    for policy in policies {
        let mut result: u32 = 0;
        let cpolicy = FfiPolicy::from(policy);
        unsafe {
            #[allow(clippy::cast_possible_wrap)]
            libc::prctl(
                crate::ksu::KERNEL_SU_OPTION as i32, // supposed to overflow
                crate::ksu::CMD_SET_SEPOLICY,
                0,
                std::ptr::addr_of!(cpolicy).cast::<libc::c_void>(),
                std::ptr::addr_of_mut!(result).cast::<libc::c_void>(),
            );
        }

        if result != crate::ksu::KERNEL_SU_OPTION {
            log::warn!("apply rule: {:?} failed.", statement);
            if strict {
                return Err(anyhow::anyhow!("apply rule {:?} failed.", statement));
            }
        }
    }

    Ok(())
}

#[cfg(not(any(target_os = "linux", target_os = "android")))]
fn apply_one_rule<'a>(_statement: &'a PolicyStatement<'a>, _strict: bool) -> Result<()> {
    unimplemented!()
}

pub fn live_patch(policy: &str) -> Result<()> {
    let result = parse_sepolicy(policy.trim(), false)?;
    for statement in result {
        println!("{statement:?}");
        apply_one_rule(&statement, false)?;
    }
    Ok(())
}

pub fn apply_file<P: AsRef<Path>>(path: P) -> Result<()> {
    let input = std::fs::read_to_string(path)?;
    live_patch(&input)
}

pub fn check_rule(policy: &str) -> Result<()> {
    let path = Path::new(policy);
    let policy = if path.exists() {
        std::fs::read_to_string(path)?
    } else {
        policy.to_string()
    };
    parse_sepolicy(policy.trim(), true)?;
    Ok(())
}

```

`userspace/ksud/src/utils.rs`:

```rs
use anyhow::{bail, Error, Ok, Result};
use std::{
    fs::{create_dir_all, write, OpenOptions},
    io::Write,
    path::Path,
};

#[allow(unused_imports)]
use std::fs::{set_permissions, Permissions};
#[cfg(unix)]
use std::os::unix::prelude::PermissionsExt;

pub fn ensure_dir_exists<T: AsRef<Path>>(dir: T) -> Result<()> {
    let result = create_dir_all(&dir).map_err(Error::from);
    if dir.as_ref().is_dir() {
        result
    } else if result.is_ok() {
        bail!("{} is not a regular directory", dir.as_ref().display())
    } else {
        result
    }
}

pub fn ensure_binary<T: AsRef<Path>>(path: T, contents: &[u8]) -> Result<()> {
    if path.as_ref().exists() {
        return Ok(());
    }

    ensure_dir_exists(path.as_ref().parent().ok_or_else(|| {
        anyhow::anyhow!(
            "{} does not have parent directory",
            path.as_ref().to_string_lossy()
        )
    })?)?;

    write(&path, contents)?;
    #[cfg(unix)]
    set_permissions(&path, Permissions::from_mode(0o755))?;
    Ok(())
}

#[cfg(any(target_os = "linux", target_os = "android"))]
pub fn getprop(prop: &str) -> Option<String> {
    android_properties::getprop(prop).value()
}

#[cfg(not(any(target_os = "linux", target_os = "android")))]
pub fn getprop(_prop: &str) -> Option<String> {
    unimplemented!()
}

pub fn is_safe_mode() -> bool {
    let safemode = getprop("persist.sys.safemode")
        .filter(|prop| prop == "1")
        .is_some()
        || getprop("ro.sys.safemode")
            .filter(|prop| prop == "1")
            .is_some();
    log::info!("safemode: {}", safemode);
    if safemode {
        return true;
    }
    let safemode = crate::ksu::check_kernel_safemode();
    log::info!("kernel_safemode: {}", safemode);
    safemode
}

#[cfg(any(target_os = "linux", target_os = "android"))]
pub fn switch_mnt_ns(pid: i32) -> Result<()> {
    use anyhow::ensure;
    use std::os::fd::AsRawFd;
    let path = format!("/proc/{pid}/ns/mnt");
    let fd = std::fs::File::open(path)?;
    let current_dir = std::env::current_dir();
    let ret = unsafe { libc::setns(fd.as_raw_fd(), libc::CLONE_NEWNS) };
    if let std::result::Result::Ok(current_dir) = current_dir {
        let _ = std::env::set_current_dir(current_dir);
    }
    ensure!(ret == 0, "switch mnt ns failed");
    Ok(())
}

#[cfg(any(target_os = "linux", target_os = "android"))]
pub fn unshare_mnt_ns() -> Result<()> {
    use anyhow::ensure;
    let ret = unsafe { libc::unshare(libc::CLONE_NEWNS) };
    ensure!(ret == 0, "unshare mnt ns failed");
    Ok(())
}

fn switch_cgroup(grp: &str, pid: u32) {
    let path = Path::new(grp).join("cgroup.procs");
    if !path.exists() {
        return;
    }

    let fp = OpenOptions::new().append(true).open(path);
    if let std::result::Result::Ok(mut fp) = fp {
        let _ = writeln!(fp, "{pid}");
    }
}

pub fn switch_cgroups() {
    let pid = std::process::id();
    switch_cgroup("/acct", pid);
    switch_cgroup("/dev/cg2_bpf", pid);
    switch_cgroup("/sys/fs/cgroup", pid);

    if getprop("ro.config.per_app_memcg")
        .filter(|prop| prop == "false")
        .is_none()
    {
        switch_cgroup("/dev/memcg/apps", pid);
    }
}

#[cfg(any(target_os = "linux", target_os = "android"))]
pub fn umask(mask: u32) {
    unsafe { libc::umask(mask) };
}

#[cfg(not(any(target_os = "linux", target_os = "android")))]
pub fn umask(_mask: u32) {
    unimplemented!("umask is not supported on this platform")
}

```

`userspace/su/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := su
LOCAL_SRC_FILES := su.c
include $(BUILD_EXECUTABLE)

```

`userspace/su/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a x86_64
APP_PLATFORM := android-24
APP_STL := none

```

`userspace/su/jni/su.c`:

```c
#include <unistd.h>
#include <stdlib.h>
#include <sys/prctl.h>

// This is a simple example. If you want a full-featured "su", please use "/data/adb/ksud debug su".
int main(){
    int32_t result = 0;
    prctl(0xdeadbeef, 0, 0, 0, &result);
    system("/system/bin/sh");
    return 0;
}

```