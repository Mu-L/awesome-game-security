Project Path: arc_SamuelTulach_OverlayCord_2iqq2bzi

Source Tree:

```txt
arc_SamuelTulach_OverlayCord_2iqq2bzi
├── Assets
│   ├── 0.png
│   ├── 1.png
│   └── 2.png
├── OverlayCord
│   ├── OverlayCord
│   │   ├── Example.cpp
│   │   ├── OverlayCord.h
│   │   ├── OverlayCord.vcxproj
│   │   └── OverlayCord.vcxproj.filters
│   └── OverlayCord.sln
├── README.md
└── imgui_example.cpp

```

`OverlayCord/OverlayCord.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33815.320
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OverlayCord", "OverlayCord\OverlayCord.vcxproj", "{DF5BD6D8-34B9-445A-B115-7BDA7AA89764}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DF5BD6D8-34B9-445A-B115-7BDA7AA89764}.Release|x64.ActiveCfg = Release|x64
		{DF5BD6D8-34B9-445A-B115-7BDA7AA89764}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {678DA3BA-3533-4A12-98D8-04520EEBFDAB}
	EndGlobalSection
EndGlobal

```

`OverlayCord/OverlayCord/Example.cpp`:

```cpp
#include "OverlayCord.h"
#include <iostream>

void Error()
{
	getchar();
	exit(-1);
}

int main()
{
	printf("[>] Searching for target window...\n");
	HWND targetWindow = FindWindowA(nullptr, "Kerbal Space Program");
	if (!targetWindow)
	{
		printf("[!] Target window not found\n");
		Error();
	}

	printf("[+] Target window found with HWND 0x%p\n", targetWindow);

	printf("[>] Resolving process ID...\n");
	UINT targetProcessId;
	GetWindowThreadProcessId(targetWindow, reinterpret_cast<LPDWORD>(&targetProcessId));
	if (!targetProcessId)
	{
		printf("[!] Failed to resolve process ID\n");
		Error();
	}

	printf("[+] Process ID resolved to %u\n", targetProcessId);

	printf("[>] Connecting to the process...\n");
	OverlayCord::Communication::ConnectedProcessInfo processInfo = { 0 };
	processInfo.ProcessId = targetProcessId;
	bool status = OverlayCord::Communication::ConnectToProcess(processInfo);
	if (!status)
	{
		printf("[!] Failed to connect to the process overlay backend\n");
		Error();
	}

	printf("[+] Connected to the process with mapped address 0x%p\n", processInfo.MappedAddress);

	printf("[>] Drawing...\n");
	OverlayCord::Drawing::Frame mainFrame = OverlayCord::Drawing::CreateFrame(1280, 720);

	const UINT rectangleWidth = 100;
	const UINT rectangleHeight = 200;
	constexpr double speed = 200.0;

	double currentPosition = 0.0;
	int direction = 1;
	OverlayCord::Drawing::Pixel color = { 0, 0, 255, 255 };

	LARGE_INTEGER frequency;
	QueryPerformanceFrequency(&frequency);

	LARGE_INTEGER t1, t2;
	QueryPerformanceCounter(&t1);

	while (!(GetKeyState(VK_INSERT) & 0x8000))
	{
		QueryPerformanceCounter(&t2);

		double deltaTime = (t2.QuadPart - t1.QuadPart) / static_cast<double>(frequency.QuadPart);
		t1 = t2;

		OverlayCord::Drawing::CleanFrame(mainFrame);

		OverlayCord::Drawing::DrawRectangle(mainFrame, static_cast<UINT>(currentPosition), mainFrame.Height / 2 - rectangleHeight / 2, rectangleWidth, rectangleHeight, color);

		currentPosition += direction * speed * deltaTime;

		if (currentPosition + rectangleWidth >= mainFrame.Width)
			direction = -1;
		else if (currentPosition <= 0)
			direction = 1;

		OverlayCord::Communication::SendFrame(processInfo, mainFrame.Width, mainFrame.Height, mainFrame.Buffer, mainFrame.Size);
	}

	getchar();
	return 0;
}
```

`OverlayCord/OverlayCord/OverlayCord.h`:

```h
/*
 * https://github.com/SamuelTulach/OverlayCord
 */

#ifndef OVERLAYCORD_H
#define OVERLAYCORD_H

#include <Windows.h>
#include <iostream>
#include <string>

namespace OverlayCord
{
	namespace Communication
	{
		typedef struct _Header
		{
			UINT Magic;
			UINT FrameCount;
			UINT NoClue;
			UINT Width;
			UINT Height;
			BYTE Buffer[1];
		} Header;

		typedef struct _ConnectedProcessInfo
		{
			UINT ProcessId;
			HANDLE File;
			Header* MappedAddress;
		} ConnectedProcessInfo;

		inline bool ConnectToProcess(ConnectedProcessInfo& processInfo)
		{
			std::string mappedFilename = "DiscordOverlay_Framebuffer_Memory_" + std::to_string(processInfo.ProcessId);
			processInfo.File = OpenFileMappingA(FILE_MAP_ALL_ACCESS, false, mappedFilename.c_str());
			if (!processInfo.File || processInfo.File == INVALID_HANDLE_VALUE)
				return false;

			processInfo.MappedAddress = static_cast<Header*>(MapViewOfFile(processInfo.File, FILE_MAP_ALL_ACCESS, 0, 0, 0));
			return processInfo.MappedAddress;
		}

		inline void DisconnectFromProcess(ConnectedProcessInfo& processInfo)
		{
			UnmapViewOfFile(processInfo.MappedAddress);
			processInfo.MappedAddress = nullptr;

			CloseHandle(processInfo.File);
			processInfo.File = nullptr;
		}

		inline void SendFrame(ConnectedProcessInfo& processInfo, UINT width, UINT height, void* frame, UINT size)
		{
			// frame is in B8G8R8A8 format
			// size can be nearly anything since it will get resized
			// for the screen appropriately, although the maximum size is
			// game window width * height * 4 (BGRA)
			processInfo.MappedAddress->Width = width;
			processInfo.MappedAddress->Height = height;

			memcpy(processInfo.MappedAddress->Buffer, frame, size);

			processInfo.MappedAddress->FrameCount++; // this will cause the internal module to copy over the framebuffer
		}
	}

	namespace Drawing
	{
		typedef struct _Frame
		{
			UINT Width;
			UINT Height;
			UINT Size;
			void* Buffer;
		} Frame;

		typedef struct _Pixel
		{
			BYTE B, G, R, A;
		} Pixel;

		inline Frame CreateFrame(UINT width, UINT height)
		{
			Frame output;
			output.Width = width;
			output.Height = height;
			output.Size = width * height * 4;

			output.Buffer = malloc(output.Size);
			memset(output.Buffer, 0, output.Size);

			return output;
		}

		inline void CleanFrame(Frame& frame)
		{
			memset(frame.Buffer, 0, frame.Size);
		}

		inline void SetPixel(Frame& frame, UINT x, UINT y, Pixel color)
		{
			if (x < frame.Width && y < frame.Height)
			{
				Pixel* buf = static_cast<Pixel*>(frame.Buffer);
				buf[y * frame.Width + x] = color;
			}
		}

		inline void DrawLine(Frame& frame, UINT x1, UINT y1, UINT x2, UINT y2, Pixel color)
		{
			int dx = abs(static_cast<int>(x2 - x1)), sx = x1 < x2 ? 1 : -1;
			int dy = -abs(static_cast<int>(y2 - y1)), sy = y1 < y2 ? 1 : -1;
			int err = dx + dy, e2;

			while (true)
			{
				SetPixel(frame, x1, y1, color);
				if (x1 == x2 && y1 == y2)
					break;
				e2 = 2 * err;
				if (e2 >= dy) { err += dy; x1 += sx; }
				if (e2 <= dx) { err += dx; y1 += sy; }
			}
		}

		inline void DrawRectangle(Frame& frame, UINT x1, UINT y1, UINT width, UINT height, Pixel color)
		{
			for (UINT x = x1; x < x1 + width; x++)
			{
				SetPixel(frame, x, y1, color);
				SetPixel(frame, x, y1 + height - 1, color);
			}

			for (UINT y = y1; y < y1 + height; y++)
			{
				SetPixel(frame, x1, y, color);
				SetPixel(frame, x1 + width - 1, y, color);
			}
		}

		inline void DrawCircle(Frame& frame, UINT x0, UINT y0, UINT radius, Pixel color)
		{
			int x = radius;
			int y = 0;
			int radiusError = 1 - x;

			while (x >= y)
			{
				SetPixel(frame, x0 + x, y0 + y, color);
				SetPixel(frame, x0 - x, y0 + y, color);
				SetPixel(frame, x0 - x, y0 - y, color);
				SetPixel(frame, x0 + x, y0 - y, color);
				SetPixel(frame, x0 + y, y0 + x, color);
				SetPixel(frame, x0 - y, y0 + x, color);
				SetPixel(frame, x0 - y, y0 - x, color);
				SetPixel(frame, x0 + y, y0 - x, color);

				y++;
				if (radiusError < 0)
				{
					radiusError += 2 * y + 1;
				}
				else
				{
					x--;
					radiusError += 2 * (y - x + 1);
				}
			}
		}
	}
}

#endif
```

`OverlayCord/OverlayCord/OverlayCord.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{df5bd6d8-34b9-445a-b115-7bda7aa89764}</ProjectGuid>
    <RootNamespace>OverlayCord</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Example.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="OverlayCord.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`OverlayCord/OverlayCord/OverlayCord.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Example.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="OverlayCord.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# OverlayCord
This project is a simple proof of concept that shows you how to hijack Discord's internal game overlay from an external process without modifying any Discord files, loading any Discord modules, or hooking anything.

## How does it work?
Discord's whitelisted internal module (DiscordHook64.dll), which is loaded by games using SetWindowHookEx, simply copies the framebuffer from a memory-mapped file. The code snippet from this repo is pretty much self-explanatory:

```
typedef struct _Header
{
	UINT Magic;
	UINT FrameCount;
	UINT NoClue;
	UINT Width;
	UINT Height;
	BYTE Buffer[1]; // B8G8R8A8
} Header;

bool ConnectToProcess(ConnectedProcessInfo& processInfo)
{
	std::string mappedFilename = "DiscordOverlay_Framebuffer_Memory_" + std::to_string(processInfo.ProcessId);
	processInfo.File = OpenFileMappingA(FILE_MAP_ALL_ACCESS, false, mappedFilename.c_str());
	if (!processInfo.File || processInfo.File == INVALID_HANDLE_VALUE)
		return false;

	processInfo.MappedAddress = static_cast<Header*>(MapViewOfFile(processInfo.File, FILE_MAP_ALL_ACCESS, 0, 0, 0));
	return processInfo.MappedAddress;
}
```
Please note that this straightforward example **uses very basic CPU rendering**, which does not offer optimal performance. In addition, regardless of your intention to use GPU rendering (such as DirectX), **the framebuffer will still be copied by the CPU**.

## Media
*Video showing the example (in case embed does not work [click here](https://www.youtube.com/watch?v=T2uftl9C9p8))*

[![video](https://img.youtube.com/vi/T2uftl9C9p8/0.jpg)](https://www.youtube.com/watch?v=T2uftl9C9p8)

*Image showing the example*

![pic1](Assets/0.png)

*Image showing custom project that renders using DX11*

![pic2](Assets/1.png)

*Image showing custom project rendering over anticheat protected game*

![pic3](Assets/2.png)


```

`imgui_example.cpp`:

```cpp
/*
 * This code contains code snippets that you can copy over into DX11 ImGui example project
 * Keep in mind that this implementation is not the most optimised one (repetitive calls, whole buffer copy)
 */

void SendBuffer(IDXGISwapChain* pSwapChain)
{
    ID3D11Device* pDevice;
    pSwapChain->GetDevice(__uuidof(ID3D11Device), reinterpret_cast<void**>(&pDevice));

    ID3D11DeviceContext* pContext;
    pDevice->GetImmediateContext(&pContext);

    ID3D11Texture2D* pBackBuffer;
    pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&pBackBuffer));

    D3D11_TEXTURE2D_DESC txtDesc;
    pBackBuffer->GetDesc(&txtDesc);
    txtDesc.Usage = D3D11_USAGE_STAGING;
    txtDesc.BindFlags = 0;
    txtDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

    ID3D11Texture2D* pBackBufferStaging;
    HRESULT status = pDevice->CreateTexture2D(&txtDesc, nullptr, &pBackBufferStaging);
    pContext->CopyResource(pBackBufferStaging, pBackBuffer);

    D3D11_MAPPED_SUBRESOURCE mappedResource;
    status = g_pd3dDeviceContext->Map(pBackBufferStaging, 0, D3D11_MAP_READ, 0, &mappedResource);

    unsigned int bufferSize = targetViewportHeight * mappedResource.RowPitch;
    memcpy(mainHeader->ActualBuffer, mappedResource.pData, bufferSize);

    mainHeader->Framecount++;

    g_pd3dDeviceContext->Unmap(pBackBufferStaging, 0);

    pBackBufferStaging->Release();
    pBackBuffer->Release();
}

bool CreateDeviceD3D(HWND hWnd)
{
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM; // Don't forget to use the correct colorspace
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    /* ... */
}

```