Project Path: arc_SamuelTulach_ida-unity-pdb-downloader_ir35qxwj

Source Tree:

```txt
arc_SamuelTulach_ida-unity-pdb-downloader_ir35qxwj
├── Assets
│   ├── log.png
│   └── menu.png
├── README.md
└── UnityPdb
    ├── UnityPdb
    │   ├── UnityPdb.vcxproj
    │   ├── UnityPdb.vcxproj.filters
    │   ├── global.hpp
    │   ├── plugin.cpp
    │   ├── utils.cpp
    │   └── utils.hpp
    └── UnityPdb.sln

```

`README.md`:

```md
# IDA Pro Unity PDB Downloader
This is a simple IDA Pro plugin for downloading symbols (PDBs) from the Unity symbol server.

![screenshot1](Assets/log.png)

```

`UnityPdb/UnityPdb.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33815.320
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UnityPdb", "UnityPdb\UnityPdb.vcxproj", "{7951D1F5-BC8B-4ABE-B24C-E17C5CE05162}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7951D1F5-BC8B-4ABE-B24C-E17C5CE05162}.Release|x64.ActiveCfg = Release|x64
		{7951D1F5-BC8B-4ABE-B24C-E17C5CE05162}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {374E0497-035B-4839-BDB4-C0F0B5C1927A}
	EndGlobalSection
EndGlobal

```

`UnityPdb/UnityPdb/UnityPdb.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7951d1f5-bc8b-4abe-b24c-e17c5ce05162}</ProjectGuid>
    <RootNamespace>UnityPdb</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>UnityPdb64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;UNITYPDB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;UNITYPDB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;UNITYPDB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;UNITYPDB_EXPORTS;_WINDOWS;_USRDLL;__NT__;__EA64__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>C:\Users\user\Documents\IDA Pro\IDA SDK and Tools\idasdk76\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalLibraryDirectories>C:\Users\user\Documents\IDA Pro\IDA SDK and Tools\idasdk76\lib\x64_win_vc_64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ida.lib;pro.lib;compress.lib;network.lib;user32.lib;urlmon.lib;SetupAPI.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="plugin.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.hpp" />
    <ClInclude Include="utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UnityPdb/UnityPdb/UnityPdb.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="global.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UnityPdb/UnityPdb/global.hpp`:

```hpp
#pragma once

#define USE_STANDARD_FILE_FUNCTIONS
#define USE_DANGEROUS_FUNCTIONS

#include <Windows.h>
#include <setupapi.h>
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <cstdint>
#include <vector>
#include <fstream>

#include "utils.hpp"
```

`UnityPdb/UnityPdb/plugin.cpp`:

```cpp
#include "global.hpp"

typedef struct _IMAGE_DEBUG_DIRECTORY_RAW
{
    char Format[4];
    GUID Guid;
    DWORD Age;
    char Name[255];
} IMAGE_DEBUG_DIRECTORY_RAW, * PIMAGE_DEBUG_DIRECTORY_RAW;

plugmod_t* idaapi init()
{
    msg("[unity-pdb] Plugin loaded\n");
    return PLUGIN_KEEP;
}

void idaapi term()
{
    /**/
}

bool idaapi run(size_t arg)
{
    char file_path[QMAXPATH];
    get_input_file_path(file_path, sizeof(file_path));

    msg("[unity-pdb] Reading file %s...\n", file_path);
    std::vector<uint8_t> file_buffer;
    bool status = utils::load_file_to_memory(file_path, &file_buffer);
    if (!status)
    {
        msg("[unity-pdb] Failed to read file\n");
        return false;
    }

    msg("[unity-pdb] Read %u bytes\n", file_buffer.size());

    msg("[unity-pdb] Parsing PE headers...\n");
    PIMAGE_DOS_HEADER dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(file_buffer.data());
    if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
    {
        msg("[unity-pdb] Invalid DOS signature\n");
        return false;
    }

    PIMAGE_NT_HEADERS64 nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(file_buffer.data() + dos_header->e_lfanew);
    if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
    {
        msg("[unity-pdb] Invalid NT signature\n");
        return false;
    }

    if (nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        msg("[unity-pdb] File is not 64-bit\n");
        return false;
    }

    IMAGE_DATA_DIRECTORY debug_entry = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
    if (!debug_entry.Size)
    {
        msg("[unity-pdb] File does not have debug information\n");
        return false;
    }

    msg("[unity-pdb] IMAGE_DIRECTORY_ENTRY_DEBUG has %u bytes\n", debug_entry.Size);

    msg("[unity-pdb] Parsing sections...\n");
    PIMAGE_DEBUG_DIRECTORY debug_directory = nullptr;
    PIMAGE_SECTION_HEADER current_image_section = IMAGE_FIRST_SECTION(nt_headers);
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++)
    {
        if (current_image_section[i].VirtualAddress <= debug_entry.VirtualAddress
            && (current_image_section[i].VirtualAddress + current_image_section[i].SizeOfRawData) > debug_entry.VirtualAddress)
        {
            debug_directory = reinterpret_cast<PIMAGE_DEBUG_DIRECTORY>(file_buffer.data() + debug_entry.VirtualAddress - current_image_section[i].
                VirtualAddress + current_image_section[i].PointerToRawData);
        }
    }

    if (!debug_directory)
    {
        msg("[unity-pdb] File does not have debug directory\n");
        return false;
    }

    if (debug_directory->Type != 2)
    {
        msg("[unity-pdb] File has invalid debug directory type\n");
        return false;
    }

    msg("[unity-pdb] Parsing debug info...\n");
    PIMAGE_DEBUG_DIRECTORY_RAW raw_info = reinterpret_cast<PIMAGE_DEBUG_DIRECTORY_RAW>(file_buffer.data() + debug_directory->PointerToRawData);

    char* guid = static_cast<char*>(malloc(128));
    utils::guid_to_string(raw_info->Guid, guid);

    std::string path_name = std::string(raw_info->Name);
    path_name = path_name.substr(path_name.find_last_of("/\\") + 1);
    path_name = path_name.substr(0, path_name.find_last_of('.'));

    msg("[unity-pdb] PDB name: %s\n", path_name.c_str());
    msg("[unity-pdb] PDB guid: %s\n", guid);
    msg("[unity-pdb] PDB age: %u\n", raw_info->Age);

    char* target_url = static_cast<char*>(malloc(512));
    wsprintfA(target_url, "http://symbolserver.unity3d.com/%s.pdb/%s%x/%s.pd_", path_name.c_str(), guid, raw_info->Age, path_name.c_str());

    msg("[unity-pdb] Downloading from URL %s...\n", target_url);

    constexpr const char* pdb_path = "unity_pdb.cab";
    HRESULT result = URLDownloadToFileA(nullptr, target_url, pdb_path, 0, nullptr);
    if (result != S_OK)
    {
        msg("[unity-pdb] Failed to download PDB file\n");
        return false;
    }

    msg("[unity-pdb] CAB file downloaded\n");

    msg("[unity-pdb] Extracting CAB file...\n");
    status = utils::extract_cab_file(pdb_path, "unity_pdb");
    if (!status)
    {
        msg("[unity-pdb] Failed to extract CAB file\n");
        return false;
    }

    msg("[unity-pdb] Run File->Load file->PDB file and load %s\n", utils::last_pdb_path.c_str());

    return true;
}

__declspec(dllexport) plugin_t PLUGIN = 
{
    IDP_INTERFACE_VERSION,
    PLUGIN_PROC,
    init,
    term,
    run,
    "Download symbols (PDB) for Unity game engine files",
    "Check Edit/Plugins/UnityPdb",
    "UnityPdb",
    nullptr
};
```

`UnityPdb/UnityPdb/utils.cpp`:

```cpp
#include "global.hpp"

bool utils::load_file_to_memory(const std::string& file_path, std::vector<uint8_t>* out_buffer)
{
	std::ifstream file_ifstream(file_path, std::ios::binary);

	if (!file_ifstream)
		return false;

	out_buffer->assign((std::istreambuf_iterator<char>(file_ifstream)), std::istreambuf_iterator<char>());
	file_ifstream.close();

	return true;
}

void utils::guid_to_string(const GUID guid, char* output)
{
	wsprintfA(output, "%08X%04X%04X%02X%02X%02X%02X%02X%02X%02X%02X",
		guid.Data1, guid.Data2, guid.Data3,
		guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
		guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

	for (char* p = output; *p; ++p) 
		*p = static_cast<char>(toupper(*p));
}

std::string utils::last_pdb_path;
UINT CALLBACK extract_callback(const PVOID context, const UINT notification, const UINT_PTR param1, UINT_PTR param2)
{
    const char* destination_path = static_cast<const char*>(context);

    if (notification == SPFILENOTIFY_FILEINCABINET) 
	{
        FILE_IN_CABINET_INFO_A* info = reinterpret_cast<FILE_IN_CABINET_INFO_A*>(param1);
        strcpy_s(info->FullTargetName, MAX_PATH, destination_path);
        strcat_s(info->FullTargetName, MAX_PATH, "\\");
        strcat_s(info->FullTargetName, MAX_PATH, info->NameInCabinet);

		msg("[unity-pdb] Extracted %s\n", info->FullTargetName);
		utils::last_pdb_path = info->FullTargetName;

        return FILEOP_DOIT;
    }

    return NO_ERROR;
}

bool utils::extract_cab_file(const std::string& input, const std::string& output)
{
	create_folder(output.c_str());
    return SetupIterateCabinetA(input.c_str(), 0, extract_callback, PVOID(output.c_str()));
}

bool utils::create_folder(const std::string& path)
{
    if (CreateDirectoryA(path.c_str(), nullptr) || ERROR_ALREADY_EXISTS == GetLastError())
        return true;

    return false;
}
```

`UnityPdb/UnityPdb/utils.hpp`:

```hpp
#pragma once

namespace utils
{
    extern std::string last_pdb_path;

    bool load_file_to_memory(const std::string& file_path, std::vector<uint8_t>* out_buffer);
    void guid_to_string(GUID guid, char* output);
    bool extract_cab_file(const std::string& input, const std::string& output);
    bool create_folder(const std::string& path);
}

```