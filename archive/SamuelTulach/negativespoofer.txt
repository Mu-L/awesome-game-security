Project Path: arc_SamuelTulach_negativespoofer_akshymg7

Source Tree:

```txt
arc_SamuelTulach_negativespoofer_akshymg7
├── CMakeLists.txt
├── LICENSE.md
├── README.md
├── compile_commands.json
├── img
│   ├── after.png
│   ├── all.png
│   └── before.png
├── pages
│   ├── BUGS.md
│   ├── LINUX.md
│   ├── USE.md
│   └── WINDOWS.md
├── pkg
│   └── Shell.efi
├── scripts
│   ├── build.sh
│   ├── clean.sh
│   ├── image.sh
│   ├── rebuild.sh
│   ├── test.sh
│   └── vm.sh
└── src
    ├── edk2
    │   └── PiHob.h
    ├── finder.c
    ├── finder.h
    ├── general.h
    ├── hob.c
    ├── hob.h
    ├── main.c
    ├── patch.c
    ├── patch.h
    ├── smbios.c
    ├── smbios.h
    ├── utils.c
    └── utils.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

set(CMAKE_CXX_COMPILER /usr/bin/g++)
set(CMAKE_C_COMPILER /usr/bin/gcc)

project(hwid)

set(EFIBIN "hwid.efi")

include_directories(/usr/include/efi)
include_directories(/usr/include/efi/x86_64)
include_directories(/usr/include/efi/protocol)

link_directories(/usr/lib)

set(COMMONFLAGS "-DGNU_EFI_USE_MS_ABI -fno-stack-protector -fpic -fshort-wchar -mno-red-zone -Wall -Werror")
set(LDFLAGS "-Wl,-nostdlib -Wl,-znocombreloc -Wl,-T,/usr/lib/elf_x86_64_efi.lds -Wl,-shared -Wl,-Bsymbolic,/usr/lib/crt0-efi-x86_64.o -Wl,-lefi -Wl,-lgnuefi") 

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --std=c++11 ${COMMONFLAGS}")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --std=c11 ${COMMONFLAGS}")

file(GLOB_RECURSE sourcefiles
    "*.h"
    "*.c"
)

add_library(hwid SHARED ${sourcefiles})
target_link_libraries(hwid ${LDFLAGS})

add_custom_command(
    TARGET hwid POST_BUILD
    COMMAND ${CMAKE_OBJCOPY} -j .text -j .sdata -j .data -j .dynamic -j .dynsym  -j .rel -j .rela -j .reloc --target=efi-app-x86_64 libhwid.so ${EFIBIN} # efi-rtdrv for runtime driver
)

```

`LICENSE.md`:

```md
Copyright 2020 Samuel Tulach - All rights reserved

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
**Archival note:** I put this together when I was 16-17, and as you can imagine, the code and repo quality reflect that. I am keeping this here for archival purposes.

---

# negativespoofer
[Based on Clover's bootloader SMBIOS patching method](https://github.com/CloverHackyColor/CloverBootloader/blob/22f9adcbc97e1291bc2361d69b66f96a29af0d05/rEFIt_UEFI/Platform/smbios.cpp) *negativespoofer* spoofs SMBIOS tables before the boot of the OS.

<p align="center">
  <img src="img/all.png">
</p>

## Useful links
To make this repo more readable, I made different pages for different topics.
- [How to compile (Linux)](pages/LINUX.md)
- [How to compile (Windows)](pages/WINDOWS.md)
- [How to use](pages/USE.md)
- [Reporting issue](pages/BUGS.md)

```

`compile_commands.json`:

```json
[
{
  "directory": "/home/q/Documents/Projects/06-01-2020/hwid/build",
  "command": "/usr/bin/gcc -Dhwid_EXPORTS -I/usr/include/efi -I/usr/include/efi/x86_64 -I/usr/include/efi/protocol   --std=c11 -DGNU_EFI_USE_MS_ABI -fno-stack-protector -fpic -fshort-wchar -mno-red-zone -Wall -Werror -fPIC   -o CMakeFiles/hwid.dir/CMakeFiles/3.17.2/CompilerIdC/CMakeCCompilerId.c.o   -c /home/q/Documents/Projects/06-01-2020/hwid/build/CMakeFiles/3.17.2/CompilerIdC/CMakeCCompilerId.c",
  "file": "/home/q/Documents/Projects/06-01-2020/hwid/build/CMakeFiles/3.17.2/CompilerIdC/CMakeCCompilerId.c"
},
{
  "directory": "/home/q/Documents/Projects/06-01-2020/hwid/build",
  "command": "/usr/bin/gcc -Dhwid_EXPORTS -I/usr/include/efi -I/usr/include/efi/x86_64 -I/usr/include/efi/protocol   --std=c11 -DGNU_EFI_USE_MS_ABI -fno-stack-protector -fpic -fshort-wchar -mno-red-zone -Wall -Werror -fPIC   -o CMakeFiles/hwid.dir/src/finder.c.o   -c /home/q/Documents/Projects/06-01-2020/hwid/src/finder.c",
  "file": "/home/q/Documents/Projects/06-01-2020/hwid/src/finder.c"
},
{
  "directory": "/home/q/Documents/Projects/06-01-2020/hwid/build",
  "command": "/usr/bin/gcc -Dhwid_EXPORTS -I/usr/include/efi -I/usr/include/efi/x86_64 -I/usr/include/efi/protocol   --std=c11 -DGNU_EFI_USE_MS_ABI -fno-stack-protector -fpic -fshort-wchar -mno-red-zone -Wall -Werror -fPIC   -o CMakeFiles/hwid.dir/src/main.c.o   -c /home/q/Documents/Projects/06-01-2020/hwid/src/main.c",
  "file": "/home/q/Documents/Projects/06-01-2020/hwid/src/main.c"
}
]
```

`pages/BUGS.md`:

```md
# Reporting issue
If you are having any issue, please [create an issue on this GitHub repo](https://github.com/SamuelTulach/negativespoofer/issues). I will not be responding to any emails/messages regarding this project.
```

`pages/LINUX.md`:

```md
# How to compile (Linux)
Compiling this EFI application is incredibly simple. All you need is a working rolling Linux distro.

First download and install gcc, gnu-efi.
```
sudo pacman -S gcc gnu-efi-libs cmake git
```
This should install all required packages that you will need to build.

Clone this repo.
```
git clone https://github.com/SamuelTulach/negativespoofer
```

Change directory to the repo root folder.
```
cd hwid
```

Build the application.
```
./scripts/build.sh
```

Now you should see hwid.efi in the build folder. Congrats!
```

`pages/USE.md`:

```md
# How to use
First, obtain a copy of hwid.efi ([compile it](pages/LINUX.md) or [download it from release section](https://github.com/SamuelTulach/negativespoofer/releases)) and a copy of [EDK2 efi shell](https://github.com/tianocore/edk2/releases). Now follow these steps:

1. Extract downloaded efi shell and rename file Shell.efi (should be in folder UefiShell/X64) to bootx64.efi
2. Format some USB drive to FAT32
3. Create following folder structure:
```
USB:.
 │   hwid.efi
 │
 └───EFI
      └───Boot
              bootx64.efi
```
4. Boot from the USB drive
5. An UEFI shell should start, change directory to your USB (FS0 should be the USB since we are booting from it) and list files:
```
FS0:
ls
```
6. You should see file hwid.efi, if you do, run it:
```
hwid.efi
```
7. Now you should see a log of the spoofer. If you do and there are no error, it means that it works!
8. Boot the os. Try typing exit and if your OS starts booting without the PC doing a full reboot, you should be fine. If not, you will need to locate bootx64.efi and run it to boot your system.
```

`pages/WINDOWS.md`:

```md
# How to compile (Windows)
[Use Linux subsystem for Windows](https://docs.microsoft.com/en-us/windows/wsl/install-win10).
```

`scripts/build.sh`:

```sh
# Run in project root
mkdir ./build
cd ./build
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ..
make
```

`scripts/clean.sh`:

```sh
# Run in project root
rm -rf ./build
```

`scripts/image.sh`:

```sh
# Run in build folder
dd if=/dev/zero of=fat.img bs=1k count=1440
mformat -i fat.img -f 1440 ::
mmd -i fat.img ::/EFI
mmd -i fat.img ::/EFI/BOOT
echo "\hwid.efi" > startup.nsh
mcopy -i fat.img startup.nsh ::/
mcopy -oi fat.img hwid.efi ::/hwid.efi
mcopy -oi fat.img ../pkg/Shell.efi ::/EFI/BOOT/BOOTX64.EFI
```

`scripts/rebuild.sh`:

```sh
./scripts/clean.sh
./scripts/build.sh
```

`scripts/test.sh`:

```sh
./scripts/rebuild.sh
cd build
../scripts/image.sh
../scripts/vm.sh
```

`scripts/vm.sh`:

```sh
# Run in build folder
# Open gdb and type "target remote :1234" to start debbuging
qemu-system-x86_64 -smp 2 -debugcon file:debug.log -global isa-debugcon.iobase=0x402 -L /usr/share/edk2-ovmf/x64/ -bios OVMF.fd -drive file=fat.img,if=ide,id=drive-ide0-0-0,format=raw #-s -S
```

`src/edk2/PiHob.h`:

```h
#include "../general.h"

/** @file
  HOB related definitions in PI.

Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Revision Reference:
  PI Version 1.6

**/

#ifndef __PI_HOB_H__
#define __PI_HOB_H__

typedef UINT32  EFI_BOOT_MODE;

//
// HobType of EFI_HOB_GENERIC_HEADER.
//
#define EFI_HOB_TYPE_HANDOFF              0x0001
#define EFI_HOB_TYPE_MEMORY_ALLOCATION    0x0002
#define EFI_HOB_TYPE_RESOURCE_DESCRIPTOR  0x0003
#define EFI_HOB_TYPE_GUID_EXTENSION       0x0004
#define EFI_HOB_TYPE_FV                   0x0005
#define EFI_HOB_TYPE_CPU                  0x0006
#define EFI_HOB_TYPE_MEMORY_POOL          0x0007
#define EFI_HOB_TYPE_FV2                  0x0009
#define EFI_HOB_TYPE_LOAD_PEIM_UNUSED     0x000A
#define EFI_HOB_TYPE_UEFI_CAPSULE         0x000B
#define EFI_HOB_TYPE_FV3                  0x000C
#define EFI_HOB_TYPE_UNUSED               0xFFFE
#define EFI_HOB_TYPE_END_OF_HOB_LIST      0xFFFF

///
/// Describes the format and size of the data inside the HOB.
/// All HOBs must contain this generic HOB header.
///
typedef struct {
  ///
  /// Identifies the HOB data structure type.
  ///
  UINT16    HobType;
  ///
  /// The length in bytes of the HOB.
  ///
  UINT16    HobLength;
  ///
  /// This field must always be set to zero.
  ///
  UINT32    Reserved;
} EFI_HOB_GENERIC_HEADER;


///
/// Value of version  in EFI_HOB_HANDOFF_INFO_TABLE.
///
#define EFI_HOB_HANDOFF_TABLE_VERSION 0x0009

///
/// Contains general state information used by the HOB producer phase.
/// This HOB must be the first one in the HOB list.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_HANDOFF.
  ///
  EFI_HOB_GENERIC_HEADER  Header;
  ///
  /// The version number pertaining to the PHIT HOB definition.
  /// This value is four bytes in length to provide an 8-byte aligned entry
  /// when it is combined with the 4-byte BootMode.
  ///
  UINT32                  Version;
  ///
  /// The system boot mode as determined during the HOB producer phase.
  ///
  EFI_BOOT_MODE           BootMode;
  ///
  /// The highest address location of memory that is allocated for use by the HOB producer
  /// phase. This address must be 4-KB aligned to meet page restrictions of UEFI.
  ///
  EFI_PHYSICAL_ADDRESS    EfiMemoryTop;
  ///
  /// The lowest address location of memory that is allocated for use by the HOB producer phase.
  ///
  EFI_PHYSICAL_ADDRESS    EfiMemoryBottom;
  ///
  /// The highest address location of free memory that is currently available
  /// for use by the HOB producer phase.
  ///
  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryTop;
  ///
  /// The lowest address location of free memory that is available for use by the HOB producer phase.
  ///
  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryBottom;
  ///
  /// The end of the HOB list.
  ///
  EFI_PHYSICAL_ADDRESS    EfiEndOfHobList;
} EFI_HOB_HANDOFF_INFO_TABLE;

///
/// EFI_HOB_MEMORY_ALLOCATION_HEADER describes the
/// various attributes of the logical memory allocation. The type field will be used for
/// subsequent inclusion in the UEFI memory map.
///
typedef struct {
  ///
  /// A GUID that defines the memory allocation region's type and purpose, as well as
  /// other fields within the memory allocation HOB. This GUID is used to define the
  /// additional data within the HOB that may be present for the memory allocation HOB.
  /// Type EFI_GUID is defined in InstallProtocolInterface() in the UEFI 2.0
  /// specification.
  ///
  EFI_GUID              Name;

  ///
  /// The base address of memory allocated by this HOB. Type
  /// EFI_PHYSICAL_ADDRESS is defined in AllocatePages() in the UEFI 2.0
  /// specification.
  ///
  EFI_PHYSICAL_ADDRESS  MemoryBaseAddress;

  ///
  /// The length in bytes of memory allocated by this HOB.
  ///
  UINT64                MemoryLength;

  ///
  /// Defines the type of memory allocated by this HOB. The memory type definition
  /// follows the EFI_MEMORY_TYPE definition. Type EFI_MEMORY_TYPE is defined
  /// in AllocatePages() in the UEFI 2.0 specification.
  ///
  EFI_MEMORY_TYPE       MemoryType;

  ///
  /// Padding for Itanium processor family
  ///
  UINT8                 Reserved[4];
} EFI_HOB_MEMORY_ALLOCATION_HEADER;

///
/// Describes all memory ranges used during the HOB producer
/// phase that exist outside the HOB list. This HOB type
/// describes how memory is used, not the physical attributes of memory.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER            Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor;
  //
  // Additional data pertaining to the "Name" Guid memory
  // may go here.
  //
} EFI_HOB_MEMORY_ALLOCATION;


///
/// Describes the memory stack that is produced by the HOB producer
/// phase and upon which all post-memory-installed executable
/// content in the HOB producer phase is executing.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER            Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor;
} EFI_HOB_MEMORY_ALLOCATION_STACK;

///
/// Defines the location of the boot-strap
/// processor (BSP) BSPStore ("Backing Store Pointer Store").
/// This HOB is valid for the Itanium processor family only
/// register overflow store.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER            Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor;
} EFI_HOB_MEMORY_ALLOCATION_BSP_STORE;

///
/// Defines the location and entry point of the HOB consumer phase.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.
  ///
  EFI_HOB_GENERIC_HEADER            Header;
  ///
  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the
  /// various attributes of the logical memory allocation.
  ///
  EFI_HOB_MEMORY_ALLOCATION_HEADER  MemoryAllocationHeader;
  ///
  /// The GUID specifying the values of the firmware file system name
  /// that contains the HOB consumer phase component.
  ///
  EFI_GUID                          ModuleName;
  ///
  /// The address of the memory-mapped firmware volume
  /// that contains the HOB consumer phase firmware file.
  ///
  EFI_PHYSICAL_ADDRESS              EntryPoint;
} EFI_HOB_MEMORY_ALLOCATION_MODULE;

///
/// The resource type.
///
typedef UINT32 EFI_RESOURCE_TYPE;

//
// Value of ResourceType in EFI_HOB_RESOURCE_DESCRIPTOR.
//
#define EFI_RESOURCE_SYSTEM_MEMORY          0x00000000
#define EFI_RESOURCE_MEMORY_MAPPED_IO       0x00000001
#define EFI_RESOURCE_IO                     0x00000002
#define EFI_RESOURCE_FIRMWARE_DEVICE        0x00000003
#define EFI_RESOURCE_MEMORY_MAPPED_IO_PORT  0x00000004
#define EFI_RESOURCE_MEMORY_RESERVED        0x00000005
#define EFI_RESOURCE_IO_RESERVED            0x00000006
#define EFI_RESOURCE_MAX_MEMORY_TYPE        0x00000007

///
/// A type of recount attribute type.
///
typedef UINT32 EFI_RESOURCE_ATTRIBUTE_TYPE;

//
// These types can be ORed together as needed.
//
// The following attributes are used to describe settings
//
#define EFI_RESOURCE_ATTRIBUTE_PRESENT                  0x00000001
#define EFI_RESOURCE_ATTRIBUTE_INITIALIZED              0x00000002
#define EFI_RESOURCE_ATTRIBUTE_TESTED                   0x00000004
#define EFI_RESOURCE_ATTRIBUTE_READ_PROTECTED           0x00000080
//
// This is typically used as memory cacheability attribute today.
// NOTE: Since PI spec 1.4, please use EFI_RESOURCE_ATTRIBUTE_READ_ONLY_PROTECTED
// as Physical write protected attribute, and EFI_RESOURCE_ATTRIBUTE_WRITE_PROTECTED
// means Memory cacheability attribute: The memory supports being programmed with
// a writeprotected cacheable attribute.
//
#define EFI_RESOURCE_ATTRIBUTE_WRITE_PROTECTED          0x00000100
#define EFI_RESOURCE_ATTRIBUTE_EXECUTION_PROTECTED      0x00000200
#define EFI_RESOURCE_ATTRIBUTE_PERSISTENT               0x00800000
//
// The rest of the attributes are used to describe capabilities
//
#define EFI_RESOURCE_ATTRIBUTE_SINGLE_BIT_ECC           0x00000008
#define EFI_RESOURCE_ATTRIBUTE_MULTIPLE_BIT_ECC         0x00000010
#define EFI_RESOURCE_ATTRIBUTE_ECC_RESERVED_1           0x00000020
#define EFI_RESOURCE_ATTRIBUTE_ECC_RESERVED_2           0x00000040
#define EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE              0x00000400
#define EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE        0x00000800
#define EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE  0x00001000
#define EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE     0x00002000
#define EFI_RESOURCE_ATTRIBUTE_16_BIT_IO                0x00004000
#define EFI_RESOURCE_ATTRIBUTE_32_BIT_IO                0x00008000
#define EFI_RESOURCE_ATTRIBUTE_64_BIT_IO                0x00010000
#define EFI_RESOURCE_ATTRIBUTE_UNCACHED_EXPORTED        0x00020000
#define EFI_RESOURCE_ATTRIBUTE_READ_PROTECTABLE         0x00100000
//
// This is typically used as memory cacheability attribute today.
// NOTE: Since PI spec 1.4, please use EFI_RESOURCE_ATTRIBUTE_READ_ONLY_PROTECTABLE
// as Memory capability attribute: The memory supports being protected from processor
// writes, and EFI_RESOURCE_ATTRIBUTE_WRITE_PROTEC TABLE means Memory cacheability attribute:
// The memory supports being programmed with a writeprotected cacheable attribute.
//
#define EFI_RESOURCE_ATTRIBUTE_WRITE_PROTECTABLE        0x00200000
#define EFI_RESOURCE_ATTRIBUTE_EXECUTION_PROTECTABLE    0x00400000
#define EFI_RESOURCE_ATTRIBUTE_PERSISTABLE              0x01000000

#define EFI_RESOURCE_ATTRIBUTE_READ_ONLY_PROTECTED      0x00040000
#define EFI_RESOURCE_ATTRIBUTE_READ_ONLY_PROTECTABLE    0x00080000

//
// Physical memory relative reliability attribute. This
// memory provides higher reliability relative to other
// memory in the system. If all memory has the same
// reliability, then this bit is not used.
//
#define EFI_RESOURCE_ATTRIBUTE_MORE_RELIABLE            0x02000000

///
/// Describes the resource properties of all fixed,
/// nonrelocatable resource ranges found on the processor
/// host bus during the HOB producer phase.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_RESOURCE_DESCRIPTOR.
  ///
  EFI_HOB_GENERIC_HEADER      Header;
  ///
  /// A GUID representing the owner of the resource. This GUID is used by HOB
  /// consumer phase components to correlate device ownership of a resource.
  ///
  EFI_GUID                    Owner;
  ///
  /// The resource type enumeration as defined by EFI_RESOURCE_TYPE.
  ///
  EFI_RESOURCE_TYPE           ResourceType;
  ///
  /// Resource attributes as defined by EFI_RESOURCE_ATTRIBUTE_TYPE.
  ///
  EFI_RESOURCE_ATTRIBUTE_TYPE ResourceAttribute;
  ///
  /// The physical start address of the resource region.
  ///
  EFI_PHYSICAL_ADDRESS        PhysicalStart;
  ///
  /// The number of bytes of the resource region.
  ///
  UINT64                      ResourceLength;
} EFI_HOB_RESOURCE_DESCRIPTOR;

///
/// Allows writers of executable content in the HOB producer phase to
/// maintain and manage HOBs with specific GUID.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_GUID_EXTENSION.
  ///
  EFI_HOB_GENERIC_HEADER      Header;
  ///
  /// A GUID that defines the contents of this HOB.
  ///
  EFI_GUID                    Name;
  //
  // Guid specific data goes here
  //
} EFI_HOB_GUID_TYPE;

///
/// Details the location of firmware volumes that contain firmware files.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV.
  ///
  EFI_HOB_GENERIC_HEADER Header;
  ///
  /// The physical memory-mapped base address of the firmware volume.
  ///
  EFI_PHYSICAL_ADDRESS   BaseAddress;
  ///
  /// The length in bytes of the firmware volume.
  ///
  UINT64                 Length;
} EFI_HOB_FIRMWARE_VOLUME;

///
/// Details the location of a firmware volume that was extracted
/// from a file within another firmware volume.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV2.
  ///
  EFI_HOB_GENERIC_HEADER  Header;
  ///
  /// The physical memory-mapped base address of the firmware volume.
  ///
  EFI_PHYSICAL_ADDRESS    BaseAddress;
  ///
  /// The length in bytes of the firmware volume.
  ///
  UINT64                  Length;
  ///
  /// The name of the firmware volume.
  ///
  EFI_GUID                FvName;
  ///
  /// The name of the firmware file that contained this firmware volume.
  ///
  EFI_GUID                FileName;
} EFI_HOB_FIRMWARE_VOLUME2;

///
/// Details the location of a firmware volume that was extracted
/// from a file within another firmware volume.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV3.
  ///
  EFI_HOB_GENERIC_HEADER  Header;
  ///
  /// The physical memory-mapped base address of the firmware volume.
  ///
  EFI_PHYSICAL_ADDRESS    BaseAddress;
  ///
  /// The length in bytes of the firmware volume.
  ///
  UINT64                  Length;
  ///
  /// The authentication status.
  ///
  UINT32                  AuthenticationStatus;
  ///
  /// TRUE if the FV was extracted as a file within another firmware volume.
  /// FALSE otherwise.
  ///
  BOOLEAN                 ExtractedFv;
  ///
  /// The name of the firmware volume.
  /// Valid only if IsExtractedFv is TRUE.
  ///
  EFI_GUID                FvName;
  ///
  /// The name of the firmware file that contained this firmware volume.
  /// Valid only if IsExtractedFv is TRUE.
  ///
  EFI_GUID                FileName;
} EFI_HOB_FIRMWARE_VOLUME3;

///
/// Describes processor information, such as address space and I/O space capabilities.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_CPU.
  ///
  EFI_HOB_GENERIC_HEADER  Header;
  ///
  /// Identifies the maximum physical memory addressability of the processor.
  ///
  UINT8                   SizeOfMemorySpace;
  ///
  /// Identifies the maximum physical I/O addressability of the processor.
  ///
  UINT8                   SizeOfIoSpace;
  ///
  /// This field will always be set to zero.
  ///
  UINT8                   Reserved[6];
} EFI_HOB_CPU;


///
/// Describes pool memory allocations.
///
typedef struct {
  ///
  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_POOL.
  ///
  EFI_HOB_GENERIC_HEADER  Header;
} EFI_HOB_MEMORY_POOL;

///
/// Each UEFI capsule HOB details the location of a UEFI capsule. It includes a base address and length
/// which is based upon memory blocks with a EFI_CAPSULE_HEADER and the associated
/// CapsuleImageSize-based payloads. These HOB's shall be created by the PEI PI firmware
/// sometime after the UEFI UpdateCapsule service invocation with the
/// CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE flag set in the EFI_CAPSULE_HEADER.
///
typedef struct {
  ///
  /// The HOB generic header where Header.HobType = EFI_HOB_TYPE_UEFI_CAPSULE.
  ///
  EFI_HOB_GENERIC_HEADER Header;

  ///
  /// The physical memory-mapped base address of an UEFI capsule. This value is set to
  /// point to the base of the contiguous memory of the UEFI capsule.
  /// The length of the contiguous memory in bytes.
  ///
  EFI_PHYSICAL_ADDRESS   BaseAddress;
  UINT64                 Length;
} EFI_HOB_UEFI_CAPSULE;

///
/// Union of all the possible HOB Types.
///
typedef union {
  EFI_HOB_GENERIC_HEADER              *Header;
  EFI_HOB_HANDOFF_INFO_TABLE          *HandoffInformationTable;
  EFI_HOB_MEMORY_ALLOCATION           *MemoryAllocation;
  EFI_HOB_MEMORY_ALLOCATION_BSP_STORE *MemoryAllocationBspStore;
  EFI_HOB_MEMORY_ALLOCATION_STACK     *MemoryAllocationStack;
  EFI_HOB_MEMORY_ALLOCATION_MODULE    *MemoryAllocationModule;
  EFI_HOB_RESOURCE_DESCRIPTOR         *ResourceDescriptor;
  EFI_HOB_GUID_TYPE                   *Guid;
  EFI_HOB_FIRMWARE_VOLUME             *FirmwareVolume;
  EFI_HOB_FIRMWARE_VOLUME2            *FirmwareVolume2;
  EFI_HOB_FIRMWARE_VOLUME3            *FirmwareVolume3;
  EFI_HOB_CPU                         *Cpu;
  EFI_HOB_MEMORY_POOL                 *Pool;
  EFI_HOB_UEFI_CAPSULE                *Capsule;
  UINT8                               *Raw;
} EFI_PEI_HOB_POINTERS;


#endif

```

`src/finder.c`:

```c
#include "general.h"
#include "finder.h"
#include "smbios.h"
#include "edk2/PiHob.h"
#include "hob.h"

EFI_GUID SmbiosTableGuid = { 0xEB9D2D31, 0x2D88, 0x11D3, { 0x9A, 0x16, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D } };
EFI_GUID Smbios3TableGuid = { 0xF2FD1544, 0x9794, 0x4A2C, { 0x99, 0x2E, 0xE5, 0xBB, 0xCF, 0x20, 0xE3, 0x94 } };

#define GET_GUID_HOB_DATA(GuidHob) ((VOID*) (((UINT8*) &((GuidHob)->Name)) + sizeof (EFI_GUID)))

int CheckEntry(SMBIOS_STRUCTURE_TABLE* entry) 
{
    if (!entry)
        return 0;

    char* pointer = (char*)entry;
    int checksum = 0;
    int length = entry->EntryPointLength;
    for (int i = 0; i < length; i++) 
    {
        checksum = checksum + (int)pointer[i];
    }

    return (checksum == 0);
}

void* FindBySignature()
{
    int signature = EFI_SIGNATURE_32('_','S','M','_');
    
    for (long offset = 0xf0000; offset < 0xfffff; offset += 0x10) 
    {
        if (*(int*)(offset) == signature && CheckEntry((SMBIOS_STRUCTURE_TABLE*)offset)) 
        {
            return (void*)offset;
        }
    }

    return 0;
}

void* FindByHob() 
{
    EFI_PHYSICAL_ADDRESS* table;
    EFI_PEI_HOB_POINTERS guidHob;

    guidHob.Raw = GetFirstGuidHob(&SmbiosTableGuid);

    if (guidHob.Raw != 0) 
    {
        table = (EFI_PHYSICAL_ADDRESS*)GET_GUID_HOB_DATA(guidHob.Guid);
        if (table != 0) 
        {
            return (void*)table;
        }
    }

    guidHob.Raw = GetFirstGuidHob(&Smbios3TableGuid);

    if (guidHob.Raw != 0) 
    {
        table = (EFI_PHYSICAL_ADDRESS*)GET_GUID_HOB_DATA(guidHob.Guid);
        if (table != 0) 
        {
            return (void*)table;
        }
    }

    return 0;
}

void* FindByConfig() 
{
    EFI_PHYSICAL_ADDRESS* table;
    EFI_STATUS status = LibGetSystemConfigurationTable(&SmbiosTableGuid, (void**)&table);
    if (status == EFI_SUCCESS)
        return table;

    status = LibGetSystemConfigurationTable(&Smbios3TableGuid, (void**)&table);
    if (status == EFI_SUCCESS)
        return table;

    return 0;
}

SMBIOS_STRUCTURE_TABLE* FindEntry() 
{
    SMBIOS_STRUCTURE_TABLE* address = FindBySignature();
    if (address) 
        return address;      

    address = FindByConfig();
    if (address) 
        return address;

    address = FindByHob();
    if (address) 
        return address;
         
    return 0;
}
```

`src/finder.h`:

```h
#ifndef FINDER_H
#define FINDER_H

#include "smbios.h"

int CheckEntry(SMBIOS_STRUCTURE_TABLE* entry);
void* FindBySignature();
void* FindByHob();
void* FindByConfig();
SMBIOS_STRUCTURE_TABLE* FindEntry();

#endif
```

`src/general.h`:

```h
#ifndef GENERAL_H
#define GENERAL_H

#define GNU_EFI_USE_MS_ABI 1
#include <efi.h>
#include <efilib.h>

#endif
```

`src/hob.c`:

```c
#include "general.h"
#include "edk2/PiHob.h"

EFI_GUID HobGuid = { 0x7739f24c, 0x93d7, 0x11d4, {0x9a, 0x3a, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } };
void* HobList = 0;

#define GET_HOB_TYPE(Hob) ((Hob).Header->HobType)
#define GET_HOB_LENGTH(Hob) ((Hob).Header->HobLength)
#define GET_NEXT_HOB(Hob) ((Hob).Raw + GET_HOB_LENGTH (Hob))
#define END_OF_HOB_LIST(Hob) (GET_HOB_TYPE (Hob) == EFI_HOB_TYPE_END_OF_HOB_LIST)

#define GET_GUID_HOB_DATA(GuidHob) ((VOID *) (((UINT8 *) &((GuidHob)->Name)) + sizeof (EFI_GUID)))
#define GET_GUID_HOB_DATA_SIZE(GuidHob) (((GuidHob)->Header).HobLength - sizeof (EFI_HOB_GUID_TYPE))

void* GetHobList() 
{
    if (!HobList) 
    {
        LibGetSystemConfigurationTable(&HobGuid, &HobList);
    }
    
    return HobList;
}

void* GetNextHob(UINT16 type, void* start) 
{
    EFI_PEI_HOB_POINTERS hob;

    hob.Raw = (UINT8*)start;

    while (!END_OF_HOB_LIST(hob)) 
    {
        if (hob.Header->HobType == type) 
        {
            return hob.Raw;
        }
        
        hob.Raw = GET_NEXT_HOB(hob);
    }

    return 0;
}

void* GetFirstHob(UINT16 type) 
{
    void* list = GetHobList();
    return GetNextHob(type, list);
}

void* GetNextGuidHob(EFI_GUID* guid, void* start) 
{
    EFI_PEI_HOB_POINTERS guidHob;

    guidHob.Raw = (UINT8*)start;

    while ((guidHob.Raw = GetNextHob(EFI_HOB_TYPE_GUID_EXTENSION, guidHob.Raw)) != 0)
    {
        if (CompareGuid(guid, &guidHob.Guid->Name))
        {
            break;
        }

        guidHob.Raw = GET_NEXT_HOB(guidHob);
    }

    return guidHob.Raw;
}

void* GetFirstGuidHob(EFI_GUID* guid) 
{
    void* list = GetHobList();
    return GetNextGuidHob(guid, list);
}
```

`src/hob.h`:

```h
#ifndef HOB_H
#define HOB_H

#include "general.h"

void* GetHobList();
void* GetNextHob(UINT16 type, void* start);
void* GetFirstHob(UINT16 type);
void* GetNextGuidHob(EFI_GUID* guid, void* start);
void* GetFirstGuidHob(EFI_GUID* guid);

#endif

```

`src/main.c`:

```c
#include "general.h"
#include "finder.h"
#include "patch.h"
#include "smbios.h"

EFI_STATUS efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) 
{
    InitializeLib(ImageHandle, SystemTable);
    
    Print(L"[WORK] Searching for SMBIOS table entry...\n");
    SMBIOS_STRUCTURE_TABLE* smbiosEntry = FindEntry();
    if (!smbiosEntry) 
    {
        Print(L"[FAIL] Failed to locate SMBIOS table entry\n");
        return EFI_NOT_FOUND;
    }
    Print(L"[INFO] SMBIOS table entry found on 0x%08x\n", smbiosEntry->TableAddress);  

    PatchAll(smbiosEntry);

    return EFI_SUCCESS;
}
```

`src/patch.c`:

```c
#include "general.h"
#include "patch.h"
#include "smbios.h"
#include "utils.h"

void EditRandom(SMBIOS_STRUCTURE_POINTER table, SMBIOS_STRING* field) 
{
    char buffer[258];
    RandomText(buffer, 257);

    if (field) 
    {
        EditString(table, field, buffer);
    } 
}

void PatchType0(SMBIOS_STRUCTURE_TABLE* entry) 
{
    SMBIOS_STRUCTURE_POINTER table = FindTableByType(entry, SMBIOS_TYPE_BIOS_INFORMATION, 0);
    Print(L"[WORK] Patching type0 table at 0x%08x...\n", table);

    if (!table.Type0) 
    {
        Print(L"[FAIL] Table is non existent\n");
        return;
    }

    EditRandom(table, &table.Type0->Vendor);
    EditRandom(table, &table.Type0->BiosVersion);
    EditRandom(table, &table.Type0->BiosReleaseDate);

    Print(L"[INFO] Patched type0 table\n");
}

void PatchType1(SMBIOS_STRUCTURE_TABLE* entry) 
{
    SMBIOS_STRUCTURE_POINTER table = FindTableByType(entry, SMBIOS_TYPE_SYSTEM_INFORMATION, 0);
    Print(L"[WORK] Patching type1 table at 0x%08x...\n", table);

    if (!table.Type1) 
    {
        Print(L"[FAIL] Table is non existent\n");
        return;
    }

    EditRandom(table, &table.Type1->Manufacturer);
    EditRandom(table, &table.Type1->ProductName);
    EditRandom(table, &table.Type1->Version);
    EditRandom(table, &table.Type1->SerialNumber);

    Print(L"[INFO] Patched type1 table\n");
}

void PatchType2(SMBIOS_STRUCTURE_TABLE* entry) 
{
    SMBIOS_STRUCTURE_POINTER table = FindTableByType(entry, SMBIOS_TYPE_BASEBOARD_INFORMATION, 0);
    Print(L"[WORK] Patching type2 table at 0x%08x...\n", table);

    if (!table.Type2) 
    {
        Print(L"[FAIL] Table is non existent\n");
        return;
    }

    EditRandom(table, &table.Type2->Manufacturer);
    EditRandom(table, &table.Type2->ProductName);
    EditRandom(table, &table.Type2->Version);
    EditRandom(table, &table.Type2->SerialNumber);

    Print(L"[INFO] Patched type2 table\n");
}

void PatchType3(SMBIOS_STRUCTURE_TABLE* entry) 
{
    SMBIOS_STRUCTURE_POINTER table = FindTableByType(entry, SMBIOS_TYPE_SYSTEM_ENCLOSURE, 0);
    Print(L"[WORK] Patching type3 table at 0x%08x...\n", table);

    if (!table.Type3) 
    {
        Print(L"[FAIL] Table is non existent\n");
        return;
    }

    EditRandom(table, &table.Type3->Manufacturer);
    EditRandom(table, &table.Type3->Version);
    EditRandom(table, &table.Type3->SerialNumber);
    EditRandom(table, &table.Type3->AssetTag);

    Print(L"[INFO] Patched type3 table\n");
}

void PatchAll(SMBIOS_STRUCTURE_TABLE* entry) 
{
    PatchType0(entry);
    PatchType1(entry);
    PatchType2(entry);
    PatchType3(entry);
}
```

`src/patch.h`:

```h
#ifndef PATCH_H
#define PATCH_H

#include "general.h"

void PatchType0(SMBIOS_STRUCTURE_TABLE* entry);
void PatchAll(SMBIOS_STRUCTURE_TABLE* entry);

#endif

```

`src/smbios.c`:

```c
#include "general.h"
#include "smbios.h"

UINT16 TableLenght(SMBIOS_STRUCTURE_POINTER table) 
{
    char* pointer = (char*)(table.Raw + table.Hdr->Length);
    while ((*pointer != 0) || (*(pointer + 1) != 0)) 
    {
        pointer++;
    }

    return (UINT16)((UINTN)pointer - (UINTN)table.Raw + 2);
}

SMBIOS_STRUCTURE_POINTER FindTableByType(SMBIOS_STRUCTURE_TABLE* entry, UINT8 type, UINTN index) 
{
    SMBIOS_STRUCTURE_POINTER smbiosTable;
    smbiosTable.Raw = (UINT8*)((UINTN)entry->TableAddress);
    if (!smbiosTable.Raw)
        return smbiosTable;

    UINTN typeIndex = 0;
    while ((typeIndex != index) || (smbiosTable.Hdr->Type != type)) 
    {
        if (smbiosTable.Hdr->Type == SMBIOS_TYPE_END_OF_TABLE) 
        {
            smbiosTable.Raw = 0;
            return smbiosTable;
        }

        if (smbiosTable.Hdr->Type == type) 
        {
            typeIndex++;
        }

        smbiosTable.Raw = (UINT8*)(smbiosTable.Raw + TableLenght(smbiosTable));
    }

    return smbiosTable;
}

UINTN SpaceLength(const char* text, UINTN maxLength) 
{
    UINTN lenght = 0;
    const char* ba;

    if (maxLength > 0) 
    {
        for (lenght = 0; lenght < maxLength; lenght++) 
        {
            if (text[lenght] == 0) 
            {
                break;
            }
        }

        ba = &text[lenght - 1];

        while ((lenght != 0) && ((*ba == ' ') || (*ba == 0))) 
        {
            ba--; lenght--;
        }
    } else 
    {
        ba = text;
        while(*ba)
        {
            ba++; 
            lenght++;
        }
    }

    return lenght;
}

void EditString(SMBIOS_STRUCTURE_POINTER table, SMBIOS_STRING* field, const char* buffer) 
{
    if (!table.Raw || !buffer || !field)
        return;

    UINT8 index = 1;
    char *astr = (char *)(table.Raw + table.Hdr->Length);
    while (index != *field) 
    {
        if (*astr)
        {
            index++;
        }

        while (*astr != 0)
            astr++;
        astr++;

        if (*astr == 0)
        {
            if (*field == 0) 
            {
                astr[1] = 0;
            }

            *field = index;

            if (index == 1) 
            {
                astr--;
            }
            break;
        }
    }

    UINTN astrLength = SpaceLength(astr, 0);
    UINTN bstrLength = SpaceLength(buffer, 256);

    // Print(L"Table type %d field %d\n", table.Hdr->Type, *field);
    // Print(L"Old string length=%d new length=%d\n", astrLength, bstrLength);

    if (bstrLength < astrLength) 
    {
        Print(L"[FAIL] Input string too short\n");
        return;
    }

    // I am lazy piece of shit and I am not implementing some string resizing
    CopyMem(astr, buffer, astrLength - 1);
}
```

`src/smbios.h`:

```h
#ifndef SMBIOS_H
#define SMBIOS_H

#include "general.h"

#define SMBIOS_TYPE_BIOS_INFORMATION                     0
#define SMBIOS_TYPE_SYSTEM_INFORMATION                   1
#define SMBIOS_TYPE_BASEBOARD_INFORMATION                2
#define SMBIOS_TYPE_SYSTEM_ENCLOSURE                     3
#define SMBIOS_TYPE_PROCESSOR_INFORMATION                4
#define SMBIOS_TYPE_MEMORY_CONTROLLER_INFORMATION        5
#define SMBIOS_TYPE_MEMORY_MODULE_INFORMATON             6
#define SMBIOS_TYPE_CACHE_INFORMATION                    7
#define SMBIOS_TYPE_PORT_CONNECTOR_INFORMATION           8
#define SMBIOS_TYPE_SYSTEM_SLOTS                         9
#define SMBIOS_TYPE_ONBOARD_DEVICE_INFORMATION           10
#define SMBIOS_TYPE_OEM_STRINGS                          11
#define SMBIOS_TYPE_SYSTEM_CONFIGURATION_OPTIONS         12
#define SMBIOS_TYPE_BIOS_LANGUAGE_INFORMATION            13
#define SMBIOS_TYPE_GROUP_ASSOCIATIONS                   14
#define SMBIOS_TYPE_SYSTEM_EVENT_LOG                     15
#define SMBIOS_TYPE_PHYSICAL_MEMORY_ARRAY                16
#define SMBIOS_TYPE_MEMORY_DEVICE                        17
#define SMBIOS_TYPE_32BIT_MEMORY_ERROR_INFORMATION       18
#define SMBIOS_TYPE_MEMORY_ARRAY_MAPPED_ADDRESS          19
#define SMBIOS_TYPE_MEMORY_DEVICE_MAPPED_ADDRESS         20
#define SMBIOS_TYPE_BUILT_IN_POINTING_DEVICE             21
#define SMBIOS_TYPE_PORTABLE_BATTERY                     22
#define SMBIOS_TYPE_SYSTEM_RESET                         23
#define SMBIOS_TYPE_HARDWARE_SECURITY                    24
#define SMBIOS_TYPE_SYSTEM_POWER_CONTROLS                25
#define SMBIOS_TYPE_VOLTAGE_PROBE                        26
#define SMBIOS_TYPE_COOLING_DEVICE                       27
#define SMBIOS_TYPE_TEMPERATURE_PROBE                    28
#define SMBIOS_TYPE_ELECTRICAL_CURRENT_PROBE             29
#define SMBIOS_TYPE_OUT_OF_BAND_REMOTE_ACCESS            30
#define SMBIOS_TYPE_BOOT_INTEGRITY_SERVICE               31
#define SMBIOS_TYPE_SYSTEM_BOOT_INFORMATION              32
#define SMBIOS_TYPE_64BIT_MEMORY_ERROR_INFORMATION       33
#define SMBIOS_TYPE_MANAGEMENT_DEVICE                    34
#define SMBIOS_TYPE_MANAGEMENT_DEVICE_COMPONENT          35
#define SMBIOS_TYPE_MANAGEMENT_DEVICE_THRESHOLD_DATA     36
#define SMBIOS_TYPE_MEMORY_CHANNEL                       37
#define SMBIOS_TYPE_IPMI_DEVICE_INFORMATION              38
#define SMBIOS_TYPE_SYSTEM_POWER_SUPPLY                  39
#define SMBIOS_TYPE_ADDITIONAL_INFORMATION               40
#define SMBIOS_TYPE_ONBOARD_DEVICES_EXTENDED_INFORMATION 41
#define SMBIOS_TYPE_MANAGEMENT_CONTROLLER_HOST_INTERFACE 42
#define SMBIOS_TYPE_TPM_DEVICE                           43
#define SMBIOS_TYPE_PROCESSOR_ADDITIONAL_INFORMATION     44

#define SMBIOS_TYPE_END_OF_TABLE     0x007F

UINT16 TableLenght(SMBIOS_STRUCTURE_POINTER table);
SMBIOS_STRUCTURE_POINTER FindTableByType(SMBIOS_STRUCTURE_TABLE* entry, UINT8 type, UINTN index);
UINTN SpaceLength(const char* text, UINTN maxLength);
void EditString(SMBIOS_STRUCTURE_POINTER table, SMBIOS_STRING* field, const char* buffer);

#endif
```

`src/utils.c`:

```c
#include "general.h"
#include "utils.h"

int lastRandom = 0;
int RandomNumber(int l, int h) 
{
    EFI_TIME time;
    EFI_TIME_CAPABILITIES cap;
    gRT->GetTime(&time, &cap); // hopefully this does not fail

    if (lastRandom == 0) 
    {
        lastRandom = time.Day + time.Hour + time.Minute + time.Second + time.Nanosecond;
    }
    lastRandom += time.Minute;
    
    int num = lastRandom % (h - l + 1);

    return num + l;
}

void RandomText(char* s, const int len) 
{
    for (int i = 0; i < len; i++) 
    {
        s[i] = RandomNumber(49, 90);
    }

    s[len] = 0;
}
```

`src/utils.h`:

```h
#ifndef UTILS_H
#define UTILS_H

int RandomNumber(int l, int h);
void RandomText(char *s, const int len);

#endif
```