Project Path: arc_SamuelTulach_unxorer_7y0xse8t

Source Tree:

```txt
arc_SamuelTulach_unxorer_7y0xse8t
├── CMakeLists.txt
├── CMakePresets.json
├── Folder.DotSettings
├── LICENSE.txt
├── README.md
├── assets
│   ├── demo.gif
│   ├── demo_macos.gif
│   ├── icon.png
│   ├── icon.psd
│   ├── menu.png
│   ├── progress.png
│   └── results.png
├── ida-plugin.json
├── ida-sdk
├── src
│   ├── branch_manager.hpp
│   ├── console.cpp
│   ├── console.hpp
│   ├── emulator.cpp
│   ├── emulator.hpp
│   ├── global.hpp
│   ├── handler.cpp
│   ├── handler.hpp
│   ├── instruction_classifier.hpp
│   ├── logger.hpp
│   ├── plugin.cpp
│   ├── register_mapper.hpp
│   ├── results.cpp
│   ├── results.hpp
│   ├── seh_support.hpp
│   ├── string_result.hpp
│   ├── strings.hpp
│   └── vector_operations.hpp
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)
project(unxorer LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")

set(IDASDK_ROOT "${CMAKE_CURRENT_LIST_DIR}/ida-sdk/src" CACHE PATH "Root of the IDA SDK")

if(NOT EXISTS "${IDASDK_ROOT}/include/ida.hpp")
    message(FATAL_ERROR "'${IDASDK_ROOT}' does not look like an IDA SDK (missing include/ida.hpp). Did you forget to init git submodules?")
endif()

message(STATUS "Using IDA SDK at: ${IDASDK_ROOT}")

string(TIMESTAMP BUILD_DATE "%Y-%m-%d %H:%M:%S")
find_package(Git QUIET)
if(Git_FOUND)
    execute_process(
        COMMAND ${GIT_EXECUTABLE} rev-parse --short=8 HEAD
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        OUTPUT_VARIABLE GIT_HASH
        OUTPUT_STRIP_TRAILING_WHITESPACE)
else()
    set(GIT_HASH "nogit")
endif()

message(STATUS "Build date: ${BUILD_DATE}, Git hash: ${GIT_HASH}")

find_package(fmt CONFIG REQUIRED)
find_package(PkgConfig REQUIRED)
pkg_check_modules(UNICORN REQUIRED IMPORTED_TARGET unicorn)

add_library(unxorer SHARED "src/plugin.cpp" "src/emulator.cpp" "src/console.cpp" "src/results.cpp" "src/handler.cpp")
target_link_libraries(unxorer PRIVATE fmt::fmt PkgConfig::UNICORN)

target_include_directories(unxorer PRIVATE "${IDASDK_ROOT}/include")
target_compile_definitions(unxorer PRIVATE __IDP__ __PLUGIN__ __EA64__
    BUILD_DATE=\"${BUILD_DATE}\"
    GIT_HASH=\"${GIT_HASH}\"
)

if(WIN32)
    if(EXISTS "${IDASDK_ROOT}/lib/x64_win_vc_64")
        set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/x64_win_vc_64")
    else()
        set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/x64_win_vc_64_home")
    endif()
    
    target_link_libraries(unxorer PRIVATE "${IDA_LIB_DIR}/ida.lib")
    set_target_properties(unxorer PROPERTIES SUFFIX ".dll")
elseif(APPLE)
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "arm64|aarch64|ARM64")
        set(IDA_ARCH "arm64")
        message(STATUS "Detected ARM64 architecture")
    else()
        set(IDA_ARCH "x64")
        message(STATUS "Detected x64 architecture")
    endif()
    
    if(IDA_ARCH STREQUAL "arm64")
        if(EXISTS "${IDASDK_ROOT}/lib/arm64_mac_clang_64")
            set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/arm64_mac_clang_64")
        elseif(EXISTS "${IDASDK_ROOT}/lib/arm64_mac_clang_64_home")
            set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/arm64_mac_clang_64_home")
        elseif(EXISTS "${IDASDK_ROOT}/lib/arm_mac_clang_64")
            set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/arm_mac_clang_64")
        elseif(EXISTS "${IDASDK_ROOT}/lib/arm_mac_clang_64_home")
            set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/arm_mac_clang_64_home")
        else()
            message(FATAL_ERROR "Could not find ARM64 IDA SDK library directory")
        endif()
    else()
        if(EXISTS "${IDASDK_ROOT}/lib/x64_mac_clang_64")
            set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/x64_mac_clang_64")
        elseif(EXISTS "${IDASDK_ROOT}/lib/x64_mac_clang_64_home")
            set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/x64_mac_clang_64_home")
        else()
            message(FATAL_ERROR "Could not find x64 IDA SDK library directory")
        endif()
    endif()
    
    message(STATUS "Using IDA library directory: ${IDA_LIB_DIR}")
    
    find_library(IDAAPI libida.dylib PATHS "${IDA_LIB_DIR}" NO_DEFAULT_PATH)
    if(NOT IDAAPI)
        message(FATAL_ERROR "Could not find libida.dylib in ${IDA_LIB_DIR}")
    endif()
    target_link_libraries(unxorer PRIVATE "${IDAAPI}")
    set_target_properties(unxorer PROPERTIES SUFFIX ".dylib")
else()
    # Linux
    if(EXISTS "${IDASDK_ROOT}/lib/x64_linux_gcc_64")
        set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/x64_linux_gcc_64")
    elseif(EXISTS "${IDASDK_ROOT}/lib/x64_linux_gcc_64_home")
        set(IDA_LIB_DIR "${IDASDK_ROOT}/lib/x64_linux_gcc_64_home")
    else()
        message(FATAL_ERROR "Could not find Linux IDA SDK library directory")
    endif()

    message(STATUS "Using IDA library directory: ${IDA_LIB_DIR}")
    
    find_library(IDAAPI libida.so PATHS "${IDA_LIB_DIR}" NO_DEFAULT_PATH)
    if(NOT IDAAPI)
        message(FATAL_ERROR "Could not find libida.so in ${IDA_LIB_DIR}")
    endif()
    target_link_libraries(unxorer PRIVATE "${IDAAPI}")
    set_target_properties(unxorer PROPERTIES SUFFIX ".so")
endif()

set_target_properties(unxorer PROPERTIES PREFIX "")

```

`CMakePresets.json`:

```json
{
  "version": 6,
  "configurePresets": [
    {
      "name": "windows-base",
      "hidden": true,
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/out/build/${presetName}",
      "installDir": "${sourceDir}/out/install/${presetName}",
      "cacheVariables": {
        "CMAKE_C_COMPILER": "cl.exe",
        "CMAKE_CXX_COMPILER": "cl.exe"
      },
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Windows"
      }
    },
    {
      "name": "win-debug-x64",
      "inherits": "windows-base",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-windows-static",
        "VCPKG_MANIFEST_MODE": "ON"
      }
    },
    {
      "name": "win-release-x64",
      "inherits": "win-debug-x64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_MSVC_DEBUG_INFORMATION_FORMAT": "ProgramDatabase",
        "CMAKE_EXE_LINKER_FLAGS_RELEASE": "/DEBUG",
        "CMAKE_SHARED_LINKER_FLAGS_RELEASE": "/DEBUG"
      }
    },
    {
      "name": "linux-base",
      "hidden": true,
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/out/build/${presetName}",
      "installDir": "${sourceDir}/out/install/${presetName}",
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Linux"
      }
    },
    {
      "name": "linux-debug-x64",
      "inherits": "linux-base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-linux",
        "VCPKG_MANIFEST_MODE": "ON"
      }
    },
    {
      "name": "linux-release-x64",
      "inherits": "linux-debug-x64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    },
    {
      "name": "macos-base",
      "hidden": true,
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/out/build/${presetName}",
      "installDir": "${sourceDir}/out/install/${presetName}",
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Darwin"
      }
    },
    {
      "name": "mac-debug-arm64",
      "inherits": "macos-base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "arm64-osx",
        "VCPKG_MANIFEST_MODE": "ON",
        "CMAKE_OSX_ARCHITECTURES": "arm64"
      }
    },
    {
      "name": "mac-release-arm64",
      "inherits": "mac-debug-arm64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    },
    {
      "name": "mac-debug-x64",
      "inherits": "macos-base",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-osx",
        "VCPKG_MANIFEST_MODE": "ON",
        "CMAKE_OSX_ARCHITECTURES": "x86_64"
      }
    },
    {
      "name": "mac-release-x64",
      "inherits": "mac-debug-x64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    }
  ]
}
```

`Folder.DotSettings`:

```DotSettings
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Fields/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Fields/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Functions/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Functions/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Non_002DType_0020Template_0020Parameters/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Non_002DType_0020Template_0020Parameters/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Types/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Types/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Variables/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Variables/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Class_0020and_0020struct_0020fields/@EntryIndexedValue">&lt;NamingElement Priority="11"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="class field" /&gt;&lt;type Name="struct field" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="_" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Class_0020and_0020struct_0020methods/@EntryIndexedValue">&lt;NamingElement Priority="10"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="member function" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Class_0020and_0020struct_0020public_0020fields/@EntryIndexedValue">&lt;NamingElement Priority="12"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="PUBLIC"&gt;&lt;type Name="class field" /&gt;&lt;type Name="struct field" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Classes_0020and_0020structs/@EntryIndexedValue">&lt;NamingElement Priority="1"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="__interface" /&gt;&lt;type Name="class" /&gt;&lt;type Name="struct" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Concepts/@EntryIndexedValue">&lt;NamingElement Priority="2"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="concept" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Enumerators/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Enumerators/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Enums/@EntryIndexedValue">&lt;NamingElement Priority="3"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="enum" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Events/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Events/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Global_0020constants/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Global_0020constants/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Global_0020functions/@EntryIndexedValue">&lt;NamingElement Priority="9"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="global function" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Global_0020variables/@EntryIndexedValue">&lt;NamingElement Priority="8"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="global variable" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Local_0020variables/@EntryIndexedValue">&lt;NamingElement Priority="7"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="local variable" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Macros/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Macros/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Namespaces/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Namespaces/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Other_0020constants/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Other_0020constants/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Parameters/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Parameters/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Properties/@EntryIndexedValue"></s:String>
	<s:Boolean x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Properties/@EntryIndexRemoved">True</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Template_0020parameters/@EntryIndexedValue">&lt;NamingElement Priority="5"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="non-type template parameter" /&gt;&lt;type Name="type template parameter" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="AaBb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Typedefs/@EntryIndexedValue">&lt;NamingElement Priority="18"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="type alias" /&gt;&lt;type Name="typedef" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Union_0020members/@EntryIndexedValue">&lt;NamingElement Priority="13"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="union member" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Unions/@EntryIndexedValue">&lt;NamingElement Priority="4"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="union" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" WarnAboutPrefixesAndSuffixes="False" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String></wpf:ResourceDictionary>
```

`LICENSE.txt`:

```txt
----------------------------------------------------------
| unxorer (https://github.com/SamuelTulach/unxorer)      |
----------------------------------------------------------

MIT License

Copyright (c) 2025 Samuel Tulach

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--------------------------------------------
| fmt (https://github.com/fmtlib/fmt)      |
--------------------------------------------

Copyright (c) 2012 - present, Victor Zverovich and {fmt} contributors

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--- Optional exception to the license ---

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into a machine-executable object form of such
source code, you may redistribute such embedded portions in such object form
without including the above copyright and permission notices.

-----------------------------------------------------
| pkgconf (https://github.com/pkgconf/pkgconf)      |
-----------------------------------------------------

Copyright (c) 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
    pkgconf authors (see AUTHORS file in source directory).

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

This software is provided 'as is' and without any warranty, express or
implied.  In no event shall the authors be liable for any damages arising
from the use of this software.

-------------------------------------------------------------
| Unicorn (https://github.com/unicorn-engine/unicorn)       |
-------------------------------------------------------------

		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

-------------------------------------------------------
| ida-sdk (https://github.com/HexRaysSA/ida-sdk)      |
-------------------------------------------------------

MIT License

Copyright (c) 2025  Hex-Rays SA

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# unxorer
Yet another plugin for deobfuscating stack strings.

![demo](/assets/demo.gif)

## Concept
You can specify one or more starting addresses (e.g. entry point, cursor location, or all functions in the database), from which the plugin will emulate every feasible execution path using [Unicorn](https://www.unicorn-engine.org/). Conditional jumps are forced to branch, and emulation states are saved and restored as needed. Throughout this process, the stack is scanned for strings. When it encounters calls to unknown memory regions (typically imports) or unsupported instructions, it attempts to skip over them so that as many paths as possible can be emulated.

## Installation
1. Download the latest release from the [releases page](https://github.com/SamuelTulach/unxorer/releases) or compile it yourself (see **Compiling** below).  
2. Copy the plugin file into your IDA "plugins" directory:
   - **Windows:** `C:\Program Files\IDA <version>\plugins`
   - **Linux/macOS:** `~/ida/plugins`
3. Restart IDA if it is running.
4. Confirm that the plugin has loaded by opening the **Edit -> Plugins** menu in IDA.

## Usage
1. Load binary or memory blob into IDA.
1. Open the **Edit -> Plugins -> unxorer** menu. Configure options as needed. Click **Ok** to start.
   
   ![menu](/assets/menu.png)
1. Wait for the emulation to complete.
   
   ![progress](/assets/progress.png)
1. List of found strings will be displayed, search in it with Ctrl+F, double-click to jump to where it was found.
   
   ![results](/assets/results.png)

## Compiling
This plugin is targetting [IDA SDK 9.2](https://github.com/HexRaysSA/ida-sdk) and Windows, but in theory should work on any platform and hopefully future IDA versions as well. Those instructions are Windows specific.
1. Download and install [Visual Studio 2022](https://visualstudio.microsoft.com/) with [C++ development tools and CMake](https://learn.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=msvc-170).
1. Setup vcpkg by following [the setup instructions](https://learn.microsoft.com/en-us/vcpkg/get_started/get-started?pivots=shell-powershell).
1. Open the `CMakeLists.txt` file in Visual Studio.
1. Select desired build configuration (**release-x64** or **debug-x64**).
1. Build the project (Ctrl+Shift+B).
1. The plugin will be compiled into `out\build\plugins\unxorer.dll`.

## Limitations
- The branching algorithm is *very* basic, it might get stuck in infinite loop sometimes or skip actual loops.
- All of the limitations of [Unicorn](https://www.unicorn-engine.org/) apply, such as:
  - It does not support all instructions (e.g. [some AVX instructions](https://github.com/unicorn-engine/unicorn/issues/1879)).
  - It fails to emulate heavilly obfuscated or virtualized code.
```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "unxorer",
    "entryPoint": "unxorer",
    "categories": [ "deobfuscation", "debugging-and-tracing", "malware-analysis" ],
    "logoPath": "assets/icon.png",
    "idaVersions": ">=9.1",
    "description": "Yet another plugin for deobfuscating stack strings.",
    "version": "1.0.3"
  }
}

```

`src/branch_manager.hpp`:

```hpp
#pragma once

class branch_manager
{
  public:
    struct branch_key
    {
        uint64_t rip;
        uint64_t target;

        bool operator==(const branch_key& other) const noexcept
        {
            return rip == other.rip && target == other.target;
        }
    };

    struct branch_key_hash
    {
        size_t operator()(const branch_key& key) const noexcept
        {
            size_t h1 = std::hash<uint64_t>{}(key.rip);
            size_t h2 = std::hash<uint64_t>{}(key.target);
            return h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1 << 6) + (h1 >> 2));
        }
    };

    struct branch_state_t
    {
        uc_context* ctx = nullptr;
        uint64_t pc = 0;

        branch_state_t() = default;
        branch_state_t(const branch_state_t&) = delete;
        branch_state_t& operator=(const branch_state_t&) = delete;

        branch_state_t(branch_state_t&& other) noexcept : ctx(other.ctx), pc(other.pc)
        {
            other.ctx = nullptr;
        }

        branch_state_t& operator=(branch_state_t&& other) noexcept
        {
            if (this != &other)
            {
                if (ctx)
                    uc_context_free(ctx);

                ctx = other.ctx;
                pc = other.pc;
                other.ctx = nullptr;
            }

            return *this;
        }

        ~branch_state_t()
        {
            if (ctx)
                uc_context_free(ctx);
        }
    };

    void save_branch(uc_engine* uc, uint64_t pc)
    {
        branch_state_t state;
        uc_context_alloc(uc, &state.ctx);
        uc_context_save(uc, state.ctx);
        state.pc = pc;
        pending_.push_back(std::move(state));
    }

    [[nodiscard]] bool has_pending() const noexcept
    {
        return !pending_.empty();
    }

    branch_state_t take_next()
    {
        auto state = std::move(pending_.back());
        pending_.pop_back();
        return state;
    }

    [[nodiscard]] bool is_visited(const branch_key& key) const noexcept
    {
        return visited_.contains(key);
    }

    void mark_visited(const branch_key& key)
    {
        visited_.insert(key);
    }

    void clear()
    {
        pending_.clear();
        visited_.clear();
    }

  private:
    std::vector<branch_state_t> pending_;
    std::unordered_set<branch_key, branch_key_hash> visited_;
};

```

`src/console.cpp`:

```cpp
#ifdef _WIN32
#include <Windows.h>
#endif
#include <iostream>
#include "console.hpp"

void console::init()
{
#ifdef _WIN32
    AllocConsole();
    freopen_s(reinterpret_cast<FILE**>(stdin), "CONIN$", "r", stdin);
    freopen_s(reinterpret_cast<FILE**>(stdout), "CONOUT$", "w", stdout);
#endif
}

void console::print(const std::string& message)
{
    std::cout << message;
}

```

`src/console.hpp`:

```hpp
#pragma once

namespace console
{
    void init();
    void print(const std::string& message);
}
```

`src/emulator.cpp`:

```cpp
#include "global.hpp"

void emulator::overwrite_all_registers(const uint64_t value) const
{
    constexpr int registers[] = {UC_X86_REG_RAX, UC_X86_REG_RBX, UC_X86_REG_RCX, UC_X86_REG_RDX,
                                 UC_X86_REG_RSI, UC_X86_REG_RDI, UC_X86_REG_RBP, UC_X86_REG_RSP,
                                 UC_X86_REG_R8,  UC_X86_REG_R9,  UC_X86_REG_R10, UC_X86_REG_R11,
                                 UC_X86_REG_R12, UC_X86_REG_R13, UC_X86_REG_R14, UC_X86_REG_R15};

    for (const auto reg : registers)
    {
        if (uc_reg_write(engine, reg, &value) != UC_ERR_OK)
        {
            logger::debug("failed to overwrite register");
            break;
        }
    }
}

void emulator::print_disasm(const ea_t address) const
{
    qstring line;
    generate_disasm_line(&line, address, GENDSM_REMOVE_TAGS);
    tag_remove(&line);
    logger::debug("{0:x}: {1}", address, line.c_str());
}

void emulator::push_string(const uint64_t rip, const uint64_t rsp, std::string str)
{
    if (str.empty())
        return;

    std::string escaped;
    escaped.reserve(str.size());

    for (const unsigned char c : str)
    {
        switch (c)
        {
        case '\n':
            escaped += "\\n";
            break;
        case '\r':
            escaped += "\\r";
            break;
        case '\t':
            escaped += "\\t";
            break;
        case '\v':
            escaped += "\\v";
            break;
        case '\f':
            escaped += "\\f";
            break;
        case '\a':
            escaped += "\\a";
            break;
        case '\b':
            escaped += "\\b";
            break;
        default:
            escaped += static_cast<char>(c);
        }
    }

    strings::left_trim(escaped);
    strings::right_trim(escaped);

    if (escaped.empty())
        return;

    const size_t hash = strings::hash_string(escaped);
    string_list_.emplace(found_string_t{rip, rsp, hash, std::move(escaped)});
}

void emulator::dump_stack_strings()
{
    uint64_t rsp = 0;
    uc_reg_read(engine, UC_X86_REG_RSP, &rsp);

    uint64_t rip = 0;
    uc_reg_read(engine, UC_X86_REG_RIP, &rip);

    if (rsp < stack_base - stack_size || rsp >= stack_base)
    {
        logger::debug("rsp {0:x} is out of stack bounds ({1:x} - {2:x})", rsp, stack_base - stack_size, stack_base);
        return;
    }

    constexpr size_t max_scan = 0x8000;
    const size_t scan_sz = std::min(static_cast<size_t>(stack_base - rsp), max_scan);
    if (scan_sz == 0)
        return;

    const uint64_t stack_begin = stack_base - stack_size;
    const size_t offset = static_cast<size_t>(rsp - stack_begin);
    if (offset >= stack_buffer_.size())
        return;

    if (offset + scan_sz > stack_buffer_.size())
        return;

    uint8_t* buffer = stack_buffer_.data() + offset;

    for (size_t i = 0; i < scan_sz;)
    {
        if (strings::is_ascii_printable(buffer[i]))
        {
            size_t j = i;
            while (j < scan_sz && strings::is_ascii_printable(buffer[j]))
                ++j;

            if (j - i >= 4 && j < scan_sz && buffer[j] == 0)
            {
                std::string s(reinterpret_cast<const char*>(buffer + i), j - i);
                push_string(rip, rsp - (i + 1), std::move(s));
            }

            i = j + 1;
            continue;
        }

        if (i + 3 < scan_sz && strings::is_utf16_printable(*reinterpret_cast<const uint16_t*>(buffer + i)))
        {
            size_t j = i;
            while (j + 1 < scan_sz && strings::is_utf16_printable(*reinterpret_cast<const uint16_t*>(buffer + j)))
                j += 2;

            if ((j - i) / 2 >= 4 && j + 1 < scan_sz && buffer[j] == 0 && buffer[j + 1] == 0)
            {
                std::string s = strings::utf16le_to_ascii(buffer + i, (j - i) / 2);
                push_string(rip, rsp - (i + 2), std::move(s));
            }

            i = j + 2;
            continue;
        }

        ++i;
    }
}

bool emulator::schedule_branch(uc_engine* uc, const uint64_t from, const uint64_t target)
{
    branch_manager::branch_key key{from, target};
    if (branches_.is_visited(key))
    {
        ++counters::already_visited;
        return false;
    }

    const ea_t img_min = inf_get_min_ea();
    const ea_t img_max = inf_get_max_ea();
    if (target < img_min || target >= img_max)
    {
        branches_.mark_visited(key);
        return false;
    }

    branches_.save_branch(uc, target);
    branches_.mark_visited(key);
    ++counters::branched;
    return true;
}

void emulator::discover_indirect_targets(uc_engine* uc, const uint64_t address, const insn_t& insn)
{
    constexpr int indirect_types[] = {NN_jmp, NN_jmpfi, NN_jmpni, NN_call, NN_callfi, NN_callni};
    bool relevant = false;
    for (const auto type : indirect_types)
    {
        if (type == insn.itype)
        {
            relevant = true;
            break;
        }
    }

    if (!relevant)
        return;

    if (insn.Op1.type != o_mem && insn.Op1.type != o_displ)
        return;

    uint64_t dest = 0;
    if (uc_mem_read(uc, insn.Op1.addr, &dest, sizeof(dest)) != UC_ERR_OK)
        return;

    schedule_branch(uc, address, dest);
}

void emulator::force_branch(uc_engine* uc, const insn_t& insn) const
{
    constexpr uint64_t f_cf = 0x00000001ull;
    constexpr uint64_t f_pf = 0x00000004ull;
    constexpr uint64_t f_zf = 0x00000040ull;
    constexpr uint64_t f_sf = 0x00000080ull;
    constexpr uint64_t f_of = 0x00000800ull;

    uint64_t eflags = 0;
    uc_reg_read(uc, UC_X86_REG_EFLAGS, &eflags);

    auto set = [&](const uint64_t mask) { eflags |= mask; };
    auto clear = [&](const uint64_t mask) { eflags &= ~mask; };

    switch (insn.itype)
    {
    case NN_jz:
    case NN_je:
    case NN_cmovz:
    case NN_sete:
    case NN_setz:
        set(f_zf);
        break;
    case NN_jnz:
    case NN_jne:
    case NN_cmovnz:
    case NN_setne:
    case NN_setnz:
        clear(f_zf);
        break;

    case NN_jc:
    case NN_jb:
    case NN_jnae:
    case NN_cmovb:
    case NN_setb:
    case NN_setc:
        set(f_cf);
        break;
    case NN_jnc:
    case NN_jnb:
    case NN_jae:
    case NN_setae:
        clear(f_cf);
        break;

    case NN_js:
    case NN_cmovs:
    case NN_sets:
        set(f_sf);
        break;
    case NN_jns:
    case NN_cmovns:
    case NN_setns:
        clear(f_sf);
        break;

    case NN_jo:
    case NN_cmovo:
    case NN_seto:
        set(f_of);
        break;
    case NN_jno:
    case NN_cmovno:
    case NN_setno:
        clear(f_of);
        break;

    case NN_jp:
    case NN_jpe:
    case NN_cmovp:
    case NN_setp:
        set(f_pf);
        break;
    case NN_jnp:
    case NN_jpo:
    case NN_cmovnp:
    case NN_setnp:
    case NN_setpo:
        clear(f_pf);
        break;

    case NN_ja:
    case NN_jnbe:
    case NN_cmova:
    case NN_seta:
        clear(f_cf | f_zf);
        break;
    case NN_jbe:
    case NN_jna:
    case NN_cmovbe:
    case NN_setbe:
        set(f_cf);
        break;

    case NN_jg:
    case NN_jnle:
    case NN_cmovg:
    case NN_setg:
        clear(f_zf | f_sf | f_of);
        break;
    case NN_jge:
    case NN_jnl:
    case NN_cmovge:
    case NN_setge:
        clear(f_sf | f_of);
        break;
    case NN_jl:
    case NN_jnge:
    case NN_cmovl:
    case NN_setl:
        set(f_sf);
        clear(f_of);
        break;
    case NN_jle:
    case NN_jng:
    case NN_cmovle:
    case NN_setle:
        set(f_zf);
        break;

    case NN_jcxz:
    case NN_jecxz:
    case NN_jrcxz: {
        const uint64_t rcx = 0;
        uc_reg_write(uc, UC_X86_REG_RCX, &rcx);
    }
    break;

    default:
        break;
    }

    uc_reg_write(uc, UC_X86_REG_EFLAGS, &eflags);
}

bool emulator::is_external_thunk(const ea_t ea) const
{
    insn_t jmp;
    if (!decode_insn(&jmp, ea))
        return false;

    constexpr std::array jmp_types = {NN_jmp, NN_jmpfi, NN_jmpni};
    const bool is_jmp = std::any_of(jmp_types.begin(), jmp_types.end(),
                                    [&jmp](const int type) { return std::cmp_equal(jmp.itype, type); });
    if (!is_jmp)
        return false;

    const ea_t img_min = inf_get_min_ea();
    const ea_t img_max = inf_get_max_ea();

    uint64_t final = 0;
    bool have_final = false;

    switch (jmp.Op1.type)
    {
    case o_near:
    case o_far:
        final = jmp.Op1.addr;
        have_final = true;
        break;

    case o_mem:
    case o_displ:
        if (uc_mem_read(engine, jmp.Op1.addr, &final, sizeof(final)) == UC_ERR_OK)
            have_final = true;
        break;

    default:
        break;
    }

    return have_final && (final < img_min || final >= img_max);
}

bool emulator::handle_call(uc_engine* uc, const uint64_t address, const uint32_t size, const insn_t& insn)
{
    if (insn.itype != NN_call && insn.itype != NN_callfi && insn.itype != NN_callni)
        return false;

    const ea_t img_min = inf_get_min_ea();
    const ea_t img_max = inf_get_max_ea();

    uint64_t dest = 0;
    bool have_dest = false;

    switch (insn.Op1.type)
    {
    case o_near:
    case o_far:
        dest = insn.Op1.addr;
        have_dest = true;
        break;

    case o_mem:
    case o_displ: {
        const uint64_t ptr_addr = insn.Op1.addr;
        if (uc_mem_read(uc, ptr_addr, &dest, sizeof(dest)) == UC_ERR_OK)
            have_dest = true;
        break;
    }

    default:
        break;
    }

    bool external = have_dest && (dest < img_min || dest >= img_max);
    if (!external && have_dest && is_external_thunk(dest))
    {
        ++counters::import_thunks;
        external = true;
    }

    if (!external)
        return false;

    const uint64_t new_rip = address + size;
    uc_reg_write(uc, UC_X86_REG_RIP, &new_rip);

    constexpr uint64_t zero = 0;
    uc_reg_write(uc, UC_X86_REG_RAX, &zero);

    ++counters::external_calls;
    return true;
}

void emulator::hook_code(uc_engine* uc, const uint64_t address, const uint32_t size, void* user_data)
{
    emulator* current = reinterpret_cast<emulator*>(user_data);

    insn_t insn;
    if (!decode_insn(&insn, address))
        return;

#ifndef NDEBUG
    current->print_disasm(address);
#endif

    ++counters::instructions_executed;

    if (current->should_update_dialog)
    {
        const auto now = std::chrono::high_resolution_clock::now();
        if (now >= current->next_waitbox_update)
        {
            size_t executed = counters::instructions_executed.load();
            replace_wait_box("Emulating at 0x%a, executed %zu instructions", address, executed);
            current->next_waitbox_update = now + std::chrono::seconds(1);
        }
    }

    if (instruction_classifier::should_skip(insn.itype))
    {
        const uint64_t rip = address + size;
        uc_reg_write(uc, UC_X86_REG_RIP, &rip);
        ++counters::skipped;
        return;
    }

    if (instruction_classifier::should_dump(insn.itype))
        current->dump_stack_strings();

    if (instruction_classifier::should_handle(insn.itype))
    {
        handler::handle(uc, address, insn.size, insn);
        return;
    }

    if (current->handle_call(uc, address, size, insn))
        return;

    current->discover_indirect_targets(uc, address, insn);

    if (!instruction_classifier::is_conditional(insn.itype))
        return;

    const bool is_branch = instruction_classifier::is_branch(insn.itype);
    if (!is_branch)
    {
        current->force_branch(uc, insn);
        return;
    }

    const uint64_t taken = insn.Op1.addr;
    const uint64_t fallthrough = address + size;

    current->schedule_branch(uc, address, fallthrough);

    if (taken <= address)
    {
        if (current->loop_iteration_limit == 0)
        {
            current->loop_iterations_.erase(address);
        }
        else
        {
            auto [entry, inserted] = current->loop_iterations_.try_emplace(address, emulator::loop_state{0, taken});
            auto& state = entry->second;
            if (state.last_target != taken)
            {
                state.last_target = taken;
                state.hits = 0;
            }

            ++state.hits;
            const uint64_t span = address - taken;
            uint64_t allowance = current->loop_iteration_limit;
            const uint64_t bonus = span / 4;
            if (bonus > std::numeric_limits<uint64_t>::max() - allowance)
                allowance = std::numeric_limits<uint64_t>::max();
            else
                allowance += bonus;

            if (state.hits >= allowance)
            {
                current->loop_iterations_.erase(entry);
                uc_reg_write(uc, UC_X86_REG_RIP, &fallthrough);
                return;
            }
        }
    }
    else
    {
        current->loop_iterations_.erase(address);
    }

    if (taken > address)
        current->force_branch(uc, insn);
}

bool emulator::hook_mem(uc_engine* uc, uc_mem_type type, const uint64_t address, int size, int64_t value,
                        void* user_data)
{
    uint64_t rip = 0;
    uc_reg_read(uc, UC_X86_REG_RIP, &rip);

    size_t advance = 1;
    insn_t insn;
    if (decode_insn(&insn, rip) && insn.size > 0)
        advance = insn.size;

    const uint64_t next = rip + advance;
    uc_reg_write(uc, UC_X86_REG_RIP, &next);
    logger::debug("skipped instruction {0:x} due to unmapped access at {1:x}", rip, address);
    return true;
}

emulator::emulator()
{
    stack_buffer_.resize(stack_size);

    uc_err err = uc_open(UC_ARCH_X86, UC_MODE_64, &engine);
    if (err != UC_ERR_OK)
    {
        logger::info("failed to initialize engine: {0}", uc_strerror(err));
        engine = nullptr;
        return;
    }

    auto cleanup = [&]() {
        if (engine != nullptr)
        {
            uc_close(engine);
            engine = nullptr;
        }
    };

    constexpr uint64_t page_size = 0x1000;
    constexpr uint64_t page_mask = ~(page_size - 1);

    const ea_t img_min = inf_get_min_ea();
    const ea_t img_max = inf_get_max_ea();

    const uint64_t map_start = img_min & page_mask;
    const uint64_t map_end = (img_max + page_size - 1) & page_mask;
    const size_t map_size = map_end - map_start;
    const size_t image_size = img_max - img_min;
    const size_t image_offset = static_cast<size_t>(img_min - map_start);

    image_buffer_.assign(map_size, 0);
    image_backup_.assign(map_size, 0);

    const ssize_t got = get_bytes(image_buffer_.data() + image_offset, image_size, img_min, GMB_READALL);
    if (got <= 0)
    {
        logger::info("failed to read memory from {0:x} to {1:x}: {2}", img_min, img_max, got);
        cleanup();
        return;
    }

    image_backup_ = image_buffer_;

    err = uc_mem_map_ptr(engine, map_start, map_size, UC_PROT_ALL, image_buffer_.data());
    if (err != UC_ERR_OK)
    {
        logger::info("failed to map image memory range {0:x} to {1:x}: {2}", img_min, img_max, uc_strerror(err));
        cleanup();
        return;
    }

    err =
        uc_mem_map_ptr(engine, stack_base - stack_size, stack_size, UC_PROT_READ | UC_PROT_WRITE, stack_buffer_.data());
    if (err != UC_ERR_OK)
    {
        logger::info("failed to map stack: {0}", uc_strerror(err));
        cleanup();
        return;
    }

    uc_hook_add(engine, &code_hook, UC_HOOK_CODE, reinterpret_cast<void*>(hook_code), this, 1, 0);
    uc_hook_add(engine, &mem_hook, UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED,
                reinterpret_cast<void*>(hook_mem), this, 1, 0);
}

emulator::~emulator()
{
    if (engine != nullptr)
    {
        uc_close(engine);
        engine = nullptr;
    }
}

const std::unordered_set<found_string_t, found_string_hash>& emulator::get_string_list() const noexcept
{
    return string_list_;
}

void emulator::run(ea_t start, const uint64_t max_time_ms, const uint64_t max_instr, const uint64_t max_loop_iterations)
{
    if (engine == nullptr)
        return;

    logger::debug("starting emulation from {0:x}...", start);

    branches_.clear();
    string_list_.clear();
    loop_iterations_.clear();
    loop_iteration_limit = max_loop_iterations;
    next_waitbox_update = std::chrono::high_resolution_clock::now();

    if (!image_backup_.empty())
        std::copy(image_backup_.begin(), image_backup_.end(), image_buffer_.begin());

    if (!stack_buffer_.empty())
        std::fill(stack_buffer_.begin(), stack_buffer_.end(), 0);

    if (!counters::start_time.load().has_value())
        counters::start_time.store(std::chrono::high_resolution_clock::now());

    overwrite_all_registers(0x2000);
    const uint64_t initial_rsp = stack_base - 0x1000;
    uc_reg_write(engine, UC_X86_REG_RSP, &initial_rsp);

    const bool limit_time = max_time_ms != 0;
    const bool limit_instr = max_instr != 0;
    uint64_t remaining_time_us = max_time_ms * 1000;
    uint64_t instructions_left = max_instr;

    uint64_t entry = start;

    for (;;)
    {
        if (limit_time && remaining_time_us == 0)
            break;

        if (limit_instr && instructions_left == 0)
            break;

        uc_reg_write(engine, UC_X86_REG_RIP, &entry);

        const uint64_t instr_slice = limit_instr ? instructions_left : 0;
        const uint64_t time_slice = limit_time ? remaining_time_us : 0;
        const auto slice_begin = std::chrono::high_resolution_clock::now();
        const uint64_t instr_before = counters::instructions_executed.load();

        const uc_err err = uc_emu_start(engine, entry, 0, time_slice, instr_slice);
        if (err != UC_ERR_OK)
            logger::debug("emulation failure: {0}", uc_strerror(err));

        if (limit_instr)
        {
            const uint64_t instr_after = counters::instructions_executed.load();
            const uint64_t delta = instr_after >= instr_before ? instr_after - instr_before : 0;
            if (delta >= instructions_left)
                instructions_left = 0;
            else
                instructions_left -= delta;
        }

        if (limit_time)
        {
            const auto slice_end = std::chrono::high_resolution_clock::now();
            const auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(slice_end - slice_begin);
            const int64_t elapsed_count = elapsed.count();
            const uint64_t elapsed_us = elapsed_count <= 0 ? 0 : static_cast<uint64_t>(elapsed_count);
            if (elapsed_us >= remaining_time_us)
                remaining_time_us = 0;
            else
                remaining_time_us -= elapsed_us;
        }

        if (!branches_.has_pending())
            break;

        const auto state = branches_.take_next();
        uc_context_restore(engine, state.ctx);
        entry = state.pc;
    }
}

```

`src/emulator.hpp`:

```hpp
#pragma once

constexpr ea_t stack_base = 0x00007FFF0000ULL;
constexpr size_t stack_size = 0x100000;

namespace counters
{
    // atomic for future multi-threading support
    inline std::atomic<size_t> instructions_executed = 0;
    inline std::atomic<size_t> branched = 0;
    inline std::atomic<size_t> already_visited = 0;
    inline std::atomic<size_t> skipped = 0;
    inline std::atomic<size_t> external_calls = 0;
    inline std::atomic<size_t> import_thunks = 0;
    inline std::atomic<std::optional<std::chrono::high_resolution_clock::time_point>> start_time;

    inline void reset()
    {
        instructions_executed = 0;
        branched = 0;
        already_visited = 0;
        skipped = 0;
        external_calls = 0;
        import_thunks = 0;
        start_time.store(std::nullopt);
    }
}

class emulator
{
  private:
    struct loop_state
    {
        uint64_t hits = 0;
        uint64_t last_target = 0;
    };

    uc_engine* engine = nullptr;
    uc_hook code_hook = 0;
    uc_hook mem_hook = 0;

    branch_manager branches_;
    std::unordered_set<found_string_t, found_string_hash> string_list_;
    std::unordered_map<uint64_t, loop_state> loop_iterations_;
    size_t loop_iteration_limit = 0;
    std::chrono::high_resolution_clock::time_point next_waitbox_update = std::chrono::high_resolution_clock::now();
    std::vector<uint8_t> stack_buffer_;
    std::vector<uint8_t> image_buffer_;
    std::vector<uint8_t> image_backup_;

    void overwrite_all_registers(uint64_t value) const;
    void print_disasm(ea_t address) const;
    void push_string(uint64_t rip, uint64_t rsp, std::string str);
    void dump_stack_strings();
    void force_branch(uc_engine* uc, const insn_t& insn) const;
    [[nodiscard]] bool is_external_thunk(ea_t ea) const;
    bool handle_call(uc_engine* uc, uint64_t address, uint32_t size, const insn_t& insn);
    bool schedule_branch(uc_engine* uc, uint64_t from, uint64_t target);
    void discover_indirect_targets(uc_engine* uc, uint64_t address, const insn_t& insn);

    static void hook_code(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
    static bool hook_mem(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);

  public:
    bool should_update_dialog = true;

    [[nodiscard]] const std::unordered_set<found_string_t, found_string_hash>& get_string_list() const noexcept;
    emulator();
    ~emulator();
    [[nodiscard]] bool is_ready() const noexcept
    {
        return engine != nullptr;
    }
    void run(ea_t start, uint64_t max_time_ms, uint64_t max_instr, uint64_t max_loop_iterations);
};
```

`src/global.hpp`:

```hpp
#pragma once

#define NOMINMAX
#include <fmt/format.h>
#include <vector>
#include <array>
#include <algorithm>
#include <unordered_set>
#include <unordered_map>
#include <chrono>
#include <utility>
#include <atomic>
#include <optional>
#include <iomanip>
#include <cstddef>
#include <cstdint>
#include <string>
#include <string_view>
#include <sstream>
#include <limits>

#if defined(_WIN32)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#endif

#pragma warning(push, 0)
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <gdl.hpp>
#include <allins.hpp>
#include <pro.h>
#pragma warning(pop)

#include <unicorn/unicorn.h>

#include "console.hpp"
#include "logger.hpp"
#include "string_result.hpp"
#include "instruction_classifier.hpp"
#include "branch_manager.hpp"
#include "register_mapper.hpp"
#include "vector_operations.hpp"
#include "emulator.hpp"
#include "strings.hpp"
#include "results.hpp"
#include "handler.hpp"

#if defined(_WIN32)
#include "seh_support.hpp"
#endif

```

`src/handler.cpp`:

```cpp
#include "global.hpp"

void handler::vmovdqu(uc_engine* uc, const uint64_t address, const uint32_t size, const insn_t& insn)
{
    vector_operations::vmov_operation(uc, insn, [](auto&&...) {});
}

void handler::vmovdqa(uc_engine* uc, const uint64_t address, const uint32_t size, const insn_t& insn)
{
    vector_operations::vmov_operation(uc, insn, [](auto&&...) {});
}

void handler::vpxor(uc_engine* uc, const uint64_t address, const uint32_t size, const insn_t& insn)
{
    if (insn.Op2.type != o_reg)
        return;

    const int data_size = register_mapper::vector_reg_size(insn.Op2.reg);
    if (data_size <= 0)
        return;

    std::array<uint8_t, 32> src1_data{};
    std::array<uint8_t, 32> src2_data{};

    if (!vector_operations::read_vector_register(uc, insn.Op2.reg, src1_data.data(), data_size))
        return;

    bool valid_src2 = false;
    if (insn.Op3.type == o_mem || insn.Op3.type == o_displ)
    {
        const uint64_t mem_addr = vector_operations::calculate_effective_address(uc, insn.Op3);
        valid_src2 = (uc_mem_read(uc, mem_addr, src2_data.data(), data_size) == UC_ERR_OK);
    }
    else if (insn.Op3.type == o_reg)
    {
        const int src3_size = register_mapper::vector_reg_size(insn.Op3.reg);
        valid_src2 = (src3_size == data_size &&
                      vector_operations::read_vector_register(uc, insn.Op3.reg, src2_data.data(), data_size));
    }

    if (!valid_src2 || insn.Op1.type != o_reg)
        return;

    std::array<uint8_t, 32> result_data{};
    for (int i = 0; i < data_size; i++)
        result_data[i] = src1_data[i] ^ src2_data[i];

    vector_operations::write_vector_register(uc, insn.Op1.reg, result_data.data(), data_size);
}

void handler::vzeroupper(uc_engine* uc, const uint64_t address, const uint32_t size, const insn_t& insn)
{
    std::array<uint8_t, 32> ymm_data{};

    for (int i = 0; i < 16; i++)
    {
        const int ymm_reg = UC_X86_REG_YMM0 + i;

        if (uc_reg_read(uc, ymm_reg, ymm_data.data()) != UC_ERR_OK)
            continue;

        std::fill(ymm_data.begin() + 16, ymm_data.end(), 0);
        uc_reg_write(uc, ymm_reg, ymm_data.data());
    }
}

void handler::handle(uc_engine* uc, const uint64_t address, const uint32_t size, const insn_t& insn)
{
    vector_operations::update_rip(uc, address, size);
    logger::debug("custom handling at {0:x} with size {1:d}...", address, size);

    switch (insn.itype)
    {
    case NN_vmovdqu:
        vmovdqu(uc, address, size, insn);
        break;
    case NN_vmovdqa:
        vmovdqa(uc, address, size, insn);
        break;
    case NN_vpxor:
        vpxor(uc, address, size, insn);
        break;
    case NN_vzeroupper:
        vzeroupper(uc, address, size, insn);
        break;
    default:
        break;
    }
}
```

`src/handler.hpp`:

```hpp
#pragma once

namespace handler
{
    void vmovdqu(uc_engine* uc, uint64_t address, uint32_t size, const insn_t& insn);
    void vmovdqa(uc_engine* uc, uint64_t address, uint32_t size, const insn_t& insn);
    void vpxor(uc_engine* uc, uint64_t address, uint32_t size, const insn_t& insn);
    void vzeroupper(uc_engine* uc, uint64_t address, uint32_t size, const insn_t& insn);
    void handle(uc_engine* uc, uint64_t address, uint32_t size, const insn_t& insn);
}
```

`src/instruction_classifier.hpp`:

```hpp
#pragma once

namespace instruction_classifier
{
    constexpr bool is_branch(int itype) noexcept
    {
        constexpr int jcc[] = {NN_ja,   NN_jae, NN_jb,   NN_jbe,  NN_jc,    NN_je,   NN_jz,  NN_jg,  NN_jge,
                               NN_jl,   NN_jle, NN_jna,  NN_jnae, NN_jnb,   NN_jnbe, NN_jnc, NN_jne, NN_jng,
                               NN_jnge, NN_jnl, NN_jnle, NN_jno,  NN_jnp,   NN_jns,  NN_jnz, NN_jo,  NN_jp,
                               NN_jpe,  NN_jpo, NN_js,   NN_jcxz, NN_jecxz, NN_jrcxz};

        for (const auto type : jcc)
        {
            if (type == itype)
                return true;
        }

        return false;
    }

    constexpr bool is_flag_dependent(int itype) noexcept
    {
        constexpr int flag_ops[] = {NN_cmova,  NN_cmovb,  NN_cmovbe, NN_cmovg,  NN_cmovge, NN_cmovl, NN_cmovle,
                                    NN_cmovno, NN_cmovnp, NN_cmovns, NN_cmovnz, NN_cmovo,  NN_cmovp, NN_cmovs,
                                    NN_cmovz,  NN_seta,   NN_setae,  NN_setb,   NN_setbe,  NN_setc,  NN_sete,
                                    NN_setg,   NN_setge,  NN_setl,   NN_setle,  NN_setne,  NN_setno, NN_setnp,
                                    NN_setns,  NN_setnz,  NN_seto,   NN_setp,   NN_setpo,  NN_sets,  NN_setz};

        for (const auto type : flag_ops)
        {
            if (type == itype)
                return true;
        }

        return false;
    }

    constexpr bool is_conditional(int itype) noexcept
    {
        return is_branch(itype) || is_flag_dependent(itype);
    }

    constexpr bool should_dump(int itype) noexcept
    {
        constexpr int ignored[] = {NN_mov, NN_xor, NN_push, NN_pop};

        for (const auto type : ignored)
        {
            if (type == itype)
                return false;
        }

        return true;
    }

    constexpr bool should_skip(int itype) noexcept
    {
        constexpr int skip[] = {NN_int3,     NN_hlt,      NN_ud2,     NN_syscall, NN_sysret, NN_vmcall,  NN_vmclear,
                                NN_vmlaunch, NN_vmresume, NN_vmptrld, NN_vmptrst, NN_vmread, NN_vmwrite, NN_vmxoff,
                                NN_vmxon,    NN_clgi,     NN_invlpga, NN_skinit,  NN_stgi,   NN_vmexit,  NN_vmload,
                                NN_vmmcall,  NN_vmrun,    NN_vmsave,  NN_invept,  NN_invvpid};

        for (const auto type : skip)
        {
            if (type == itype)
                return true;
        }

        return false;
    }

    constexpr bool should_handle(int itype) noexcept
    {
        constexpr int handle[] = {NN_vmovdqu, NN_vmovdqa, NN_vpxor, NN_vzeroupper};

        for (const auto type : handle)
        {
            if (type == itype)
                return true;
        }

        return false;
    }
}

```

`src/logger.hpp`:

```hpp
#pragma once
#include "console.hpp"

namespace logger
{
    constexpr const char* prefix = "[unxorer]";

    template <typename... Args> inline void info(fmt::format_string<Args...> fmtstr, Args&&... args)
    {
        auto line = fmt::format("{} {}\n", prefix, fmt::format(fmtstr, std::forward<Args>(args)...));
        msg("%s", line.c_str());
    }

    template <typename... Args> inline void debug(fmt::format_string<Args...> fmtstr, Args&&... args)
    {
#ifndef NDEBUG
        auto line = fmt::format("{} {}\n", prefix, fmt::format(fmtstr, std::forward<Args>(args)...));
        msg("%s", line.c_str());
        console::print(line);
#endif
    }

    inline void title()
    {
        msg("        %s\n", R"( __ _____ __ _____  _______ ____)");
        msg("        %s\n", R"(/ // / _ \\ \ / _ \/ __/ -_) __/)");
        msg("        %s\n", R"(\_,_/_//_/_\_\\___/_/  \__/_/   )");

        msg("   %s\n", fmt::format("build on {0} from {1}", BUILD_DATE, GIT_HASH).c_str());
    }
}
```

`src/plugin.cpp`:

```cpp
#include "global.hpp"

enum class emulation_scope
{
    current_function,
    every_function,
    current_cursor,
    entry_point
};

struct emulation_config
{
    emulation_scope scope;
    uval_t max_time_ms;
    uval_t max_instructions;
    uval_t max_loop_iterations;
};

static std::optional<emulation_config> get_user_config()
{
    static constexpr const char form[] = "unxorer\n"
                                         "Start from:\n"
                                         "<#Current function:R>\n"
                                         "<#Every function (very slow!):R>\n"
                                         "<#Current cursor location:R>\n"
                                         "<#Entry point                                          :R>>\n"
                                         "\n"
                                         "Limits:\n"
                                         "<Max time (ms)                      : D:20:10::>\n"
                                         "<Max instructions (per function)    : D:20:10::>\n"
                                         "<Max loop iterations (per function) : D:20:10::>\n";

    int scope_val = 0;
    uval_t max_time = 60000;
    uval_t max_instr = 1000000;
    uval_t max_loops = 50;

    if (!ask_form(form, &scope_val, &max_time, &max_instr, &max_loops))
        return std::nullopt;

    return emulation_config{static_cast<emulation_scope>(scope_val), max_time, max_instr, max_loops};
}

static void run_on_function(ea_t start, uval_t max_time, uval_t max_instr, uval_t max_loops)
{
    emulator emu;
    if (!emu.is_ready())
    {
        warning("Failed to initialize emulator");
        return;
    }

    emu.run(start, max_time, max_instr, max_loops);
    results::display(emu.get_string_list());
}

static void run_on_all_functions(uval_t max_time, uval_t max_instr, uval_t max_loops)
{
    const size_t total = get_func_qty();
    if (total == 0)
    {
        warning("No functions in the database");
        return;
    }

    logger::info("running on {0} functions in database", total);

    std::unordered_set<found_string_t, found_string_hash> aggregated;

    for (size_t i = 0; i < total; i++)
    {
        emulator emu;
        if (!emu.is_ready())
        {
            warning("Failed to initialize emulator");
            break;
        }

        emu.should_update_dialog = false;
        const ea_t start = getn_func(i)->start_ea;
        replace_wait_box("Emulating function %zu/%zu at 0x%llx", i + 1, total, start);

        emu.run(start, max_time, max_instr, max_loops);

        const auto& strings = emu.get_string_list();
        aggregated.insert(strings.begin(), strings.end());

        if (user_cancelled())
            break;
    }

    results::display(aggregated);
}

static plugmod_t* idaapi init()
{
#ifndef NDEBUG
    console::init();
#endif
    logger::title();
    return PLUGIN_OK;
}

static void idaapi term()
{
    /**/
}

static bool idaapi run(size_t)
{
    if (PH.id != PLFM_386 || !inf_is_64bit())
    {
        warning("CPU is not x86_64");
        return false;
    }

    const auto config = get_user_config();
    if (!config)
        return false;

    counters::reset();
    show_wait_box("Initializing");

    switch (config->scope)
    {
    case emulation_scope::current_function:
        if (const func_t* func = get_func(get_screen_ea()); func)
            run_on_function(func->start_ea, config->max_time_ms, config->max_instructions, config->max_loop_iterations);
        else
            warning("No function under cursor");
        break;

    case emulation_scope::every_function:
        run_on_all_functions(config->max_time_ms, config->max_instructions, config->max_loop_iterations);
        break;

    case emulation_scope::current_cursor:
        run_on_function(get_screen_ea(), config->max_time_ms, config->max_instructions, config->max_loop_iterations);
        break;

    case emulation_scope::entry_point:
        run_on_function(inf_get_start_ea(), config->max_time_ms, config->max_instructions, config->max_loop_iterations);
        break;
    }

    hide_wait_box();
    return true;
}

plugin_t PLUGIN = {IDP_INTERFACE_VERSION, 0, init, term, run, "", "", "unxorer", ""};
```

`src/register_mapper.hpp`:

```hpp
#pragma once

namespace register_mapper
{
    constexpr int ida_to_unicorn(int ida_reg) noexcept
    {
        constexpr int mapping[] = {UC_X86_REG_RAX, UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_RBX,
                                   UC_X86_REG_RSP, UC_X86_REG_RBP, UC_X86_REG_RSI, UC_X86_REG_RDI,
                                   UC_X86_REG_R8,  UC_X86_REG_R9,  UC_X86_REG_R10, UC_X86_REG_R11,
                                   UC_X86_REG_R12, UC_X86_REG_R13, UC_X86_REG_R14, UC_X86_REG_R15};

        if (ida_reg >= 0 && ida_reg < 16)
            return mapping[ida_reg];

        return 0;
    }

    constexpr bool is_xmm_reg(int reg_num) noexcept
    {
        return (reg_num >= 16 && reg_num <= 31) || (reg_num >= 64 && reg_num <= 79);
    }

    constexpr bool is_ymm_reg(int reg_num) noexcept
    {
        return reg_num >= 81 && reg_num <= 96;
    }

    constexpr int xmm_number(int ida_reg) noexcept
    {
        if (ida_reg >= 16 && ida_reg <= 31)
            return ida_reg - 16;

        if (ida_reg >= 64 && ida_reg <= 79)
            return ida_reg - 64;

        return -1;
    }

    constexpr int ymm_number(int ida_reg) noexcept
    {
        if (is_ymm_reg(ida_reg))
            return ida_reg - 81;

        return -1;
    }

    constexpr int xmm_to_unicorn(int ida_reg) noexcept
    {
        const int num = xmm_number(ida_reg);
        return num >= 0 ? UC_X86_REG_XMM0 + num : 0;
    }

    constexpr int ymm_to_unicorn(int ida_reg) noexcept
    {
        const int num = ymm_number(ida_reg);
        return num >= 0 ? UC_X86_REG_YMM0 + num : 0;
    }

    constexpr int vector_reg_size(int reg_num) noexcept
    {
        if (is_xmm_reg(reg_num))
            return 16;

        if (is_ymm_reg(reg_num))
            return 32;

        return 0;
    }
}

```

`src/results.cpp`:

```cpp
#include "global.hpp"

class results_chooser_t final : public chooser_t
{
  protected:
    static constexpr int results_widths_[] = {16, 16, 32};
    static constexpr const char* const results_headers_[] = {"rip", "rsp", "string"};

  private:
    std::vector<found_string_t> rows_;

  public:
    results_chooser_t(const char* desired_title, std::vector<found_string_t> list)
        : chooser_t(0, 3, results_widths_, results_headers_, desired_title)
    {
        rows_ = std::move(list);
    }

    const void* get_obj_id(size_t* len) const override
    {
        *len = strlen(title);
        return title;
    }

    [[nodiscard]] size_t idaapi get_count() const override
    {
        return rows_.size();
    }

    void idaapi get_row(qstrvec_t* cols, int* icon_, chooser_item_attrs_t* attrs, size_t n) const override
    {
        if (n >= rows_.size())
            return;

        const auto& item = rows_[n];
        (*cols)[0].sprnt("%016" PRIX64, item.rip);
        (*cols)[1].sprnt("%016" PRIX64, item.rsp);
        (*cols)[2].sprnt("%s", item.data.c_str());
    }

    cbret_t idaapi enter(size_t n) override
    {
        if (n < rows_.size())
            jumpto(rows_[n].rip);

        return cbret_t(0);
    }
};

void results::display(const std::unordered_set<found_string_t, found_string_hash>& string_list)
{
    const auto duration = std::chrono::high_resolution_clock::now() -
                          counters::start_time.load().value_or(std::chrono::high_resolution_clock::now());

    logger::info("stats:");
    logger::info(" - instructions:    {0}", counters::instructions_executed.load());
    logger::info(" - time:            {0}", strings::format_duration(duration));
    logger::info("finished, found {0} unique strings", string_list.size());

    std::vector<found_string_t> display_list;
    display_list.reserve(string_list.size());
    display_list.assign(string_list.begin(), string_list.end());

    const auto results = new results_chooser_t("unxorer", std::move(display_list));
    results->choose();
}
```

`src/results.hpp`:

```hpp
#pragma once

namespace results
{
    void display(const std::unordered_set<found_string_t, found_string_hash>& string_list);
}
```

`src/seh_support.hpp`:

```hpp
#pragma once

#if defined(_WIN32)

struct seh_details
{
    unsigned long code = 0;
    const void* address = nullptr;
};

inline int capture_seh_info(unsigned long code, EXCEPTION_POINTERS* info, seh_details* out)
{
    if (out != nullptr)
    {
        out->code = code;
        if (info != nullptr && info->ExceptionRecord != nullptr)
            out->address = info->ExceptionRecord->ExceptionAddress;
        else
            out->address = nullptr;
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

#endif

```

`src/string_result.hpp`:

```hpp
#pragma once

struct found_string_t
{
    uint64_t rip = 0;
    uint64_t rsp = 0;
    size_t hash = 0;
    std::string data;

    bool operator==(const found_string_t& other) const noexcept
    {
        return data == other.data;
    }
};

struct found_string_hash
{
    size_t operator()(const found_string_t& input) const noexcept
    {
        return input.hash;
    }
};

```

`src/strings.hpp`:

```hpp
#pragma once

namespace strings
{
    inline bool is_ascii_printable(const uint8_t c) noexcept
    {
        return (c >= 0x20 && c <= 0x7E) || c == 0x09 || c == 0x0A || c == 0x0D;
    }

    inline bool is_utf16_printable(const uint16_t w) noexcept
    {
        return (w >= 0x20 && w <= 0x7E) || w == 0x09 || w == 0x0A || w == 0x0D;
    }

    inline bool is_trim_space(const unsigned char c) noexcept
    {
        switch (c)
        {
        case ' ':
        case '\t':
        case '\n':
        case '\r':
        case '\v':
        case '\f':
            return true;
        default:
            return false;
        }
    }

    inline std::string utf16le_to_ascii(const uint8_t* buf, const size_t chars)
    {
        std::string out;
        out.reserve(chars);

        for (size_t i = 0; i < chars; ++i)
            out.push_back(static_cast<char>(buf[i * 2]));

        return out;
    }

    inline void left_trim(std::string& s)
    {
        size_t first = 0;
        const size_t len = s.size();
        while (first < len && is_trim_space(static_cast<unsigned char>(s[first])))
            ++first;

        if (first != 0)
            s.erase(0, first);
    }

    inline void right_trim(std::string& s)
    {
        size_t last = s.size();
        while (last > 0 && is_trim_space(static_cast<unsigned char>(s[last - 1])))
            --last;

        if (last != s.size())
            s.resize(last);
    }

    inline size_t hash_string(std::string_view value) noexcept
    {
        constexpr uint64_t offset = 1469598103934665603ull;
        constexpr uint64_t prime = 1099511628211ull;
        uint64_t hash = offset;

        for (unsigned char c : value)
        {
            hash ^= c;
            hash *= prime;
        }

        return static_cast<size_t>(hash);
    }

    inline std::string format_duration(const std::chrono::nanoseconds duration)
    {
        using namespace std::chrono;

        const auto ms_total = duration_cast<milliseconds>(duration).count();
        const auto hours = ms_total / (1000 * 60 * 60);
        const auto minutes = (ms_total / (1000 * 60)) % 60;
        const auto seconds = (ms_total / 1000) % 60;
        const auto millis = ms_total % 1000;

        std::ostringstream oss;
        oss << std::setfill('0') << std::setw(2) << hours << ":" << std::setw(2) << minutes << ":" << std::setw(2)
            << seconds << "." << std::setw(3) << millis;

        return oss.str();
    }
}

```

`src/vector_operations.hpp`:

```hpp
#pragma once

namespace vector_operations
{
    inline uint64_t calculate_effective_address(uc_engine* uc, const op_t& op)
    {
        if (op.type != o_mem && op.type != o_displ)
            return 0;

        uint64_t ea = op.addr;
        const int base_reg = register_mapper::ida_to_unicorn(op.reg);

        if (base_reg != 0)
        {
            uint64_t base_val = 0;
            if (uc_reg_read(uc, base_reg, &base_val) == UC_ERR_OK)
                ea += base_val;
        }

        return ea;
    }

    inline bool read_vector_register(uc_engine* uc, int ida_reg, uint8_t* data, int expected_size)
    {
        if (register_mapper::is_xmm_reg(ida_reg) && expected_size >= 16)
        {
            const int xmm_reg = register_mapper::xmm_to_unicorn(ida_reg);
            return xmm_reg != 0 && uc_reg_read(uc, xmm_reg, data) == UC_ERR_OK;
        }

        if (register_mapper::is_ymm_reg(ida_reg) && expected_size >= 32)
        {
            const int ymm_reg = register_mapper::ymm_to_unicorn(ida_reg);
            return ymm_reg != 0 && uc_reg_read(uc, ymm_reg, data) == UC_ERR_OK;
        }

        return false;
    }

    inline bool write_vector_register(uc_engine* uc, int ida_reg, const uint8_t* data, int data_size)
    {
        if (register_mapper::is_xmm_reg(ida_reg))
        {
            const int xmm_reg = register_mapper::xmm_to_unicorn(ida_reg);
            if (xmm_reg == 0)
                return false;

            if (data_size == 32)
            {
                const int reg_num = register_mapper::xmm_number(ida_reg);
                if (reg_num < 0)
                    return false;

                const int ymm_reg = UC_X86_REG_YMM0 + reg_num;
                return uc_reg_write(uc, ymm_reg, data) == UC_ERR_OK;
            }

            return uc_reg_write(uc, xmm_reg, data) == UC_ERR_OK;
        }

        if (!register_mapper::is_ymm_reg(ida_reg))
            return false;

        const int ymm_reg = register_mapper::ymm_to_unicorn(ida_reg);
        if (ymm_reg == 0)
            return false;

        std::array<uint8_t, 32> ymm_data{};
        const size_t copy_size = std::min(static_cast<size_t>(data_size), ymm_data.size());
        std::copy_n(data, copy_size, ymm_data.data());

        return uc_reg_write(uc, ymm_reg, ymm_data.data()) == UC_ERR_OK;
    }

    template <typename Operation> inline void vmov_operation(uc_engine* uc, const insn_t& insn, Operation&& op)
    {
        std::array<uint8_t, 32> data{};

        if (insn.Op1.type == o_reg && (insn.Op2.type == o_mem || insn.Op2.type == o_displ))
        {
            const uint64_t mem_addr = calculate_effective_address(uc, insn.Op2);
            const int data_size = register_mapper::vector_reg_size(insn.Op1.reg);

            if (data_size > 0 && uc_mem_read(uc, mem_addr, data.data(), data_size) == UC_ERR_OK)
                write_vector_register(uc, insn.Op1.reg, data.data(), data_size);
        }
        else if ((insn.Op1.type == o_mem || insn.Op1.type == o_displ) && insn.Op2.type == o_reg)
        {
            const uint64_t mem_addr = calculate_effective_address(uc, insn.Op1);
            const int data_size = register_mapper::vector_reg_size(insn.Op2.reg);

            if (data_size > 0 && read_vector_register(uc, insn.Op2.reg, data.data(), data_size))
                uc_mem_write(uc, mem_addr, data.data(), data_size);
        }
        else if (insn.Op1.type == o_reg && insn.Op2.type == o_reg)
        {
            const int src_size = register_mapper::vector_reg_size(insn.Op2.reg);

            if (src_size > 0 && read_vector_register(uc, insn.Op2.reg, data.data(), src_size))
                write_vector_register(uc, insn.Op1.reg, data.data(), src_size);
        }
    }

    inline void update_rip(uc_engine* uc, uint64_t address, uint32_t size)
    {
        const uint64_t rip = address + size;
        uc_reg_write(uc, UC_X86_REG_RIP, &rip);
    }
}

```

`vcpkg.json`:

```json
{
  "name": "unxorer",
  "builtin-baseline": "0d9d4684352ba8de70bdf251c6fc9a3c464fa12b",
  "dependencies": [
    "fmt",
    "pkgconf",
    "unicorn"
  ]
}
```