Project Path: arc_PixelGuys_Cubyz_ibromzhv

Source Tree:

```txt
arc_PixelGuys_Cubyz_ibromzhv
├── LICENSE
├── README.md
├── assets
│   └── cubyz
│       ├── biomes
│       │   ├── _migrations.zig.zon
│       │   ├── autumn
│       │   │   ├── dead_forest.zig.zon
│       │   │   ├── forest.zig.zon
│       │   │   └── mixed_forest.zig.zon
│       │   ├── beach
│       │   │   ├── cold
│       │   │   │   ├── base.zig.zon
│       │   │   │   └── wide.zig.zon
│       │   │   └── warm
│       │   │       ├── base.zig.zon
│       │   │       └── wide.zig.zon
│       │   ├── bog
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   └── pond.zig.zon
│       │   ├── bush_lands.zig.zon
│       │   ├── bush_mountains.zig.zon
│       │   ├── cave
│       │   │   ├── basalt.zig.zon
│       │   │   ├── cave.zig.zon
│       │   │   ├── crystal.zig.zon
│       │   │   ├── crystal_forest.zig.zon
│       │   │   ├── curl_forest.zig.zon
│       │   │   ├── dropoff.zig.zon
│       │   │   ├── ice_cave.zig.zon
│       │   │   ├── lava_cave.zig.zon
│       │   │   ├── marble_cave.zig.zon
│       │   │   ├── mushroom
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── big
│       │   │   │   │   ├── _defaults.zig.zon
│       │   │   │   │   ├── bolete.zig.zon
│       │   │   │   │   ├── glimmergill.zig.zon
│       │   │   │   │   └── toadstool.zig.zon
│       │   │   │   ├── glimmergill.zig.zon
│       │   │   │   └── toadstool_bolete.zig.zon
│       │   │   ├── rare
│       │   │   │   └── phantasmal.zig.zon
│       │   │   ├── sky.zig.zon
│       │   │   ├── stalagmite_cave.zig.zon
│       │   │   ├── stone_forest.zig.zon
│       │   │   └── void
│       │   │       ├── rare
│       │   │       │   └── phantasmal
│       │   │       │       ├── _defaults.zig.zon
│       │   │       │       ├── starlight.zig.zon
│       │   │       │       └── streamer.zig.zon
│       │   │       ├── void.zig.zon
│       │   │       ├── void_cavern.zig.zon
│       │   │       ├── void_crystal.zig.zon
│       │   │       └── void_roots.zig.zon
│       │   ├── decorative
│       │   │   ├── stone_pit.zig.zon
│       │   │   └── stone_rock.zig.zon
│       │   ├── desert
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── hoodoos
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── base.zig.zon
│       │   │   │   ├── mound.zig.zon
│       │   │   │   └── pit.zig.zon
│       │   │   └── oasis
│       │   │       ├── _defaults.zig.zon
│       │   │       ├── base.zig.zon
│       │   │       └── pond.zig.zon
│       │   ├── development
│       │   │   └── flat.zig.zon
│       │   ├── ferrock_mountains.zig.zon
│       │   ├── forest
│       │   │   ├── birch.zig.zon
│       │   │   ├── bluebell_woods.zig.zon
│       │   │   ├── chopped.zig.zon
│       │   │   ├── mixed
│       │   │   │   ├── oak_birch.zig.zon
│       │   │   │   ├── oak_birch_clearing.zig.zon
│       │   │   │   ├── oak_pine.zig.zon
│       │   │   │   └── oak_pine_clearing.zig.zon
│       │   │   └── thin_birch.zig.zon
│       │   ├── glacier.zig.zon
│       │   ├── grassland.zig.zon
│       │   ├── hills
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── cold.zig.zon
│       │   │   ├── huge
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── cold.zig.zon
│       │   │   │   └── temperate.zig.zon
│       │   │   ├── large
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── cold.zig.zon
│       │   │   │   └── temperate.zig.zon
│       │   │   └── temperate.zig.zon
│       │   ├── island.zig.zon
│       │   ├── island_shelf.zig.zon
│       │   ├── jungle.zig.zon
│       │   ├── limestone_mountains
│       │   │   └── base.zig.zon
│       │   ├── mountains.zig.zon
│       │   ├── ocean
│       │   │   ├── cold
│       │   │   │   ├── base.zig.zon
│       │   │   │   └── shelf.zig.zon
│       │   │   ├── temperate
│       │   │   │   ├── base.zig.zon
│       │   │   │   └── shelf.zig.zon
│       │   │   └── warm
│       │   │       └── base.zig.zon
│       │   ├── peak.zig.zon
│       │   ├── plateau
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── cold.zig.zon
│       │   │   ├── stacked
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── cold.zig.zon
│       │   │   │   └── temperate.zig.zon
│       │   │   └── temperate.zig.zon
│       │   ├── prairie
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── dry_spell
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── base.zig.zon
│       │   │   │   └── dead.zig.zon
│       │   │   ├── hill.zig.zon
│       │   │   └── limestone_pit
│       │   │       └── base.zig.zon
│       │   ├── rare
│       │   │   ├── crimson_wasteland
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── base.zig.zon
│       │   │   │   ├── black_pit.zig.zon
│       │   │   │   └── magma_rock.zig.zon
│       │   │   ├── glass_forest.zig.zon
│       │   │   ├── knitted
│       │   │   │   ├── forest.zig.zon
│       │   │   │   ├── funny_pit.zig.zon
│       │   │   │   └── mountain.zig.zon
│       │   │   ├── modern_art.zig.zon
│       │   │   ├── phantasmal_archipelago.zig.zon
│       │   │   ├── rainbow_forest.zig.zon
│       │   │   ├── spawn.zig.zon
│       │   │   ├── tuften
│       │   │   │   └── fields.zig.zon
│       │   │   └── winter_wonderland
│       │   │       ├── _defaults.zig.zon
│       │   │       ├── base.zig.zon
│       │   │       ├── forest.zig.zon
│       │   │       └── icicles.zig.zon
│       │   ├── rocky_grassland.zig.zon
│       │   ├── savannah
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── baobab_shrublands.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── butte.zig.zon
│       │   │   ├── elevated.zig.zon
│       │   │   └── grassy.zig.zon
│       │   ├── snowcapped_hill
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   └── snowcapped_rock.zig.zon
│       │   ├── swamp
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── clearing.zig.zon
│       │   │   └── pond.zig.zon
│       │   ├── taiga
│       │   │   ├── base.zig.zon
│       │   │   └── cold.zig.zon
│       │   ├── tall_mountain
│       │   │   ├── base.zig.zon
│       │   │   ├── peak.zig.zon
│       │   │   ├── slope1.zig.zon
│       │   │   ├── slope2.zig.zon
│       │   │   ├── slope3.zig.zon
│       │   │   ├── slope4.zig.zon
│       │   │   ├── slope5.zig.zon
│       │   │   └── slope6.zig.zon
│       │   ├── thicket.zig.zon
│       │   ├── tundra
│       │   │   ├── base.zig.zon
│       │   │   ├── patchy.zig.zon
│       │   │   └── snowy
│       │   │       ├── _defaults.zig.zon
│       │   │       ├── base.zig.zon
│       │   │       ├── pit.zig.zon
│       │   │       └── rock.zig.zon
│       │   ├── volcano
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── peak.zig.zon
│       │   │   ├── slope1.zig.zon
│       │   │   ├── slope2.zig.zon
│       │   │   ├── slope3.zig.zon
│       │   │   ├── slope4.zig.zon
│       │   │   ├── slope5.zig.zon
│       │   │   └── slope6.zig.zon
│       │   └── wetlands
│       │       ├── _defaults.zig.zon
│       │       ├── base.zig.zon
│       │       └── willows.zig.zon
│       ├── blocks
│       │   ├── _migrations.zig.zon
│       │   ├── air.zig.zon
│       │   ├── amber_block.zig.zon
│       │   ├── amber_ore.zig.zon
│       │   ├── baobab_branch.zig.zon
│       │   ├── baobab_fence.zig.zon
│       │   ├── baobab_log.zig.zon
│       │   ├── baobab_planks.zig.zon
│       │   ├── baobab_top.zig.zon
│       │   ├── bars
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── copper.zig.zon
│       │   │   ├── gold.zig.zon
│       │   │   ├── iron.zig.zon
│       │   │   ├── silver.zig.zon
│       │   │   └── uranium.zig.zon
│       │   ├── basalt
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── bellows.zig.zon
│       │   ├── birch_branch.zig.zon
│       │   ├── birch_fence.zig.zon
│       │   ├── birch_log.zig.zon
│       │   ├── birch_planks.zig.zon
│       │   ├── birch_top.zig.zon
│       │   ├── bluebells.zig.zon
│       │   ├── bolete.zig.zon
│       │   ├── bolete_branch.zig.zon
│       │   ├── bolete_cap.zig.zon
│       │   ├── bolete_stem.zig.zon
│       │   ├── branch
│       │   │   ├── leafy
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── baobab.zig.zon
│       │   │   │   ├── birch.zig.zon
│       │   │   │   ├── mahogany.zig.zon
│       │   │   │   ├── oak.zig.zon
│       │   │   │   ├── palm.zig.zon
│       │   │   │   ├── pine.zig.zon
│       │   │   │   └── willow.zig.zon
│       │   │   └── palm.zig.zon
│       │   ├── cactus.zig.zon
│       │   ├── cactus_arm.zig.zon
│       │   ├── cactus_flower.zig.zon
│       │   ├── candy_cane
│       │   │   ├── block.zig.zon
│       │   │   └── branch.zig.zon
│       │   ├── castilleja.zig.zon
│       │   ├── chain
│       │   │   └── iron.zig.zon
│       │   ├── chalk
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── aqua.zig.zon
│       │   │   ├── black.zig.zon
│       │   │   ├── blue.zig.zon
│       │   │   ├── brown.zig.zon
│       │   │   ├── crimson.zig.zon
│       │   │   ├── cyan.zig.zon
│       │   │   ├── dark_grey.zig.zon
│       │   │   ├── green.zig.zon
│       │   │   ├── grey.zig.zon
│       │   │   ├── indigo.zig.zon
│       │   │   ├── lime.zig.zon
│       │   │   ├── magenta.zig.zon
│       │   │   ├── orange.zig.zon
│       │   │   ├── pink.zig.zon
│       │   │   ├── purple.zig.zon
│       │   │   ├── red.zig.zon
│       │   │   ├── violet.zig.zon
│       │   │   ├── viridian.zig.zon
│       │   │   ├── white.zig.zon
│       │   │   └── yellow.zig.zon
│       │   ├── chest
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── baobab.zig.zon
│       │   │   ├── birch.zig.zon
│       │   │   ├── mahogany.zig.zon
│       │   │   ├── oak.zig.zon
│       │   │   ├── palm.zig.zon
│       │   │   ├── pine.zig.zon
│       │   │   └── willow.zig.zon
│       │   ├── chimney.zig.zon
│       │   ├── clay.zig.zon
│       │   ├── cloth
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── aqua.zig.zon
│       │   │   ├── black.zig.zon
│       │   │   ├── block
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── aqua.zig.zon
│       │   │   │   ├── black.zig.zon
│       │   │   │   ├── blue.zig.zon
│       │   │   │   ├── brown.zig.zon
│       │   │   │   ├── crimson.zig.zon
│       │   │   │   ├── cyan.zig.zon
│       │   │   │   ├── dark_grey.zig.zon
│       │   │   │   ├── green.zig.zon
│       │   │   │   ├── grey.zig.zon
│       │   │   │   ├── indigo.zig.zon
│       │   │   │   ├── lime.zig.zon
│       │   │   │   ├── magenta.zig.zon
│       │   │   │   ├── orange.zig.zon
│       │   │   │   ├── pink.zig.zon
│       │   │   │   ├── purple.zig.zon
│       │   │   │   ├── red.zig.zon
│       │   │   │   ├── violet.zig.zon
│       │   │   │   ├── viridian.zig.zon
│       │   │   │   ├── white.zig.zon
│       │   │   │   └── yellow.zig.zon
│       │   │   ├── blue.zig.zon
│       │   │   ├── brown.zig.zon
│       │   │   ├── crimson.zig.zon
│       │   │   ├── cyan.zig.zon
│       │   │   ├── dark_grey.zig.zon
│       │   │   ├── green.zig.zon
│       │   │   ├── grey.zig.zon
│       │   │   ├── indigo.zig.zon
│       │   │   ├── lime.zig.zon
│       │   │   ├── magenta.zig.zon
│       │   │   ├── orange.zig.zon
│       │   │   ├── pink.zig.zon
│       │   │   ├── purple.zig.zon
│       │   │   ├── red.zig.zon
│       │   │   ├── violet.zig.zon
│       │   │   ├── viridian.zig.zon
│       │   │   ├── white.zig.zon
│       │   │   └── yellow.zig.zon
│       │   ├── coal_block.zig.zon
│       │   ├── coal_ore.zig.zon
│       │   ├── cold_grass.zig.zon
│       │   ├── cold_grass_vegetation.zig.zon
│       │   ├── copper_block.zig.zon
│       │   ├── copper_ore.zig.zon
│       │   ├── cut_amber_block.zig.zon
│       │   ├── cut_diamond_block.zig.zon
│       │   ├── cut_ruby_block.zig.zon
│       │   ├── daffodil.zig.zon
│       │   ├── daisies.zig.zon
│       │   ├── dandelions.zig.zon
│       │   ├── dead_leaf_pile.zig.zon
│       │   ├── diamond_block.zig.zon
│       │   ├── diamond_ore.zig.zon
│       │   ├── dirt.zig.zon
│       │   ├── dry_grass.zig.zon
│       │   ├── dry_grass_vegetation.zig.zon
│       │   ├── duckweed.zig.zon
│       │   ├── fern.zig.zon
│       │   ├── ferrock
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── fog
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── blue.zig.zon
│       │   │   ├── cyan.zig.zon
│       │   │   ├── green.zig.zon
│       │   │   ├── magenta.zig.zon
│       │   │   ├── red.zig.zon
│       │   │   └── yellow.zig.zon
│       │   ├── frost.zig.zon
│       │   ├── furnace.zig.zon
│       │   ├── glacite
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── glass
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── aqua.zig.zon
│       │   │   ├── black.zig.zon
│       │   │   ├── blue.zig.zon
│       │   │   ├── brown.zig.zon
│       │   │   ├── crimson.zig.zon
│       │   │   ├── cyan.zig.zon
│       │   │   ├── dark_grey.zig.zon
│       │   │   ├── green.zig.zon
│       │   │   ├── grey.zig.zon
│       │   │   ├── indigo.zig.zon
│       │   │   ├── lime.zig.zon
│       │   │   ├── magenta.zig.zon
│       │   │   ├── orange.zig.zon
│       │   │   ├── pink.zig.zon
│       │   │   ├── purple.zig.zon
│       │   │   ├── red.zig.zon
│       │   │   ├── uranium.zig.zon
│       │   │   ├── violet.zig.zon
│       │   │   ├── viridian.zig.zon
│       │   │   ├── white.zig.zon
│       │   │   └── yellow.zig.zon
│       │   ├── glimmergill.zig.zon
│       │   ├── glimmergill_branch.zig.zon
│       │   ├── glimmergill_cap.zig.zon
│       │   ├── glimmergill_stem.zig.zon
│       │   ├── glow_crystal
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── aqua.zig.zon
│       │   │   ├── black.zig.zon
│       │   │   ├── blue.zig.zon
│       │   │   ├── brown.zig.zon
│       │   │   ├── crimson.zig.zon
│       │   │   ├── cyan.zig.zon
│       │   │   ├── dark_grey.zig.zon
│       │   │   ├── green.zig.zon
│       │   │   ├── grey.zig.zon
│       │   │   ├── indigo.zig.zon
│       │   │   ├── lime.zig.zon
│       │   │   ├── magenta.zig.zon
│       │   │   ├── orange.zig.zon
│       │   │   ├── pink.zig.zon
│       │   │   ├── purple.zig.zon
│       │   │   ├── red.zig.zon
│       │   │   ├── violet.zig.zon
│       │   │   ├── viridian.zig.zon
│       │   │   ├── white.zig.zon
│       │   │   └── yellow.zig.zon
│       │   ├── gold_block.zig.zon
│       │   ├── gold_ore.zig.zon
│       │   ├── grass.zig.zon
│       │   ├── grass_vegetation.zig.zon
│       │   ├── gravel.zig.zon
│       │   ├── hibiscus.zig.zon
│       │   ├── ice.zig.zon
│       │   ├── iron_block.zig.zon
│       │   ├── iron_ore.zig.zon
│       │   ├── ivy.zig.zon
│       │   ├── kiln.zig.zon
│       │   ├── lamp.zig.zon
│       │   ├── lantern
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── coal.zig.zon
│       │   │   └── sulfur.zig.zon
│       │   ├── lava.zig.zon
│       │   ├── leaves
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── baobab.zig.zon
│       │   │   ├── birch.zig.zon
│       │   │   ├── dead.zig.zon
│       │   │   ├── mahogany.zig.zon
│       │   │   ├── oak.zig.zon
│       │   │   ├── opaque
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── baobab.zig.zon
│       │   │   │   ├── birch.zig.zon
│       │   │   │   ├── dead.zig.zon
│       │   │   │   ├── mahogany.zig.zon
│       │   │   │   ├── oak.zig.zon
│       │   │   │   ├── palm.zig.zon
│       │   │   │   ├── pine.zig.zon
│       │   │   │   ├── red.zig.zon
│       │   │   │   ├── willow.zig.zon
│       │   │   │   └── yellow.zig.zon
│       │   │   ├── palm.zig.zon
│       │   │   ├── pine.zig.zon
│       │   │   ├── red.zig.zon
│       │   │   ├── willow.zig.zon
│       │   │   └── yellow.zig.zon
│       │   ├── lily_pad.zig.zon
│       │   ├── limestone
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── log
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── baobab.zig.zon
│       │   │   ├── birch.zig.zon
│       │   │   ├── bolete.zig.zon
│       │   │   ├── cactus.zig.zon
│       │   │   ├── glimmergill.zig.zon
│       │   │   ├── mahogany.zig.zon
│       │   │   ├── oak.zig.zon
│       │   │   ├── palm.zig.zon
│       │   │   ├── pine.zig.zon
│       │   │   ├── toadstool.zig.zon
│       │   │   └── willow.zig.zon
│       │   ├── lush_grass.zig.zon
│       │   ├── lush_grass_vegetation.zig.zon
│       │   ├── magma.zig.zon
│       │   ├── mahogany_branch.zig.zon
│       │   ├── mahogany_fence.zig.zon
│       │   ├── mahogany_log.zig.zon
│       │   ├── mahogany_planks.zig.zon
│       │   ├── mahogany_top.zig.zon
│       │   ├── marble
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── marigold.zig.zon
│       │   ├── moss.zig.zon
│       │   ├── mud.zig.zon
│       │   ├── oak_branch.zig.zon
│       │   ├── oak_fence.zig.zon
│       │   ├── oak_log.zig.zon
│       │   ├── oak_planks.zig.zon
│       │   ├── oak_top.zig.zon
│       │   ├── obsidian.zig.zon
│       │   ├── osier.zig.zon
│       │   ├── palm_fence.zig.zon
│       │   ├── palm_planks.zig.zon
│       │   ├── pebbles.zig.zon
│       │   ├── permafrost.zig.zon
│       │   ├── pine_branch.zig.zon
│       │   ├── pine_fence.zig.zon
│       │   ├── pine_log.zig.zon
│       │   ├── pine_planks.zig.zon
│       │   ├── pine_top.zig.zon
│       │   ├── red_leaf_pile.zig.zon
│       │   ├── resin.zig.zon
│       │   ├── resin_block.zig.zon
│       │   ├── ruby_block.zig.zon
│       │   ├── ruby_ore.zig.zon
│       │   ├── sand.zig.zon
│       │   ├── sandstone
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── sbb
│       │   │   ├── child
│       │   │   │   ├── _defaults.zig.zon
│       │   │   │   ├── aqua.zig.zon
│       │   │   │   ├── black.zig.zon
│       │   │   │   ├── blue.zig.zon
│       │   │   │   ├── brown.zig.zon
│       │   │   │   ├── crimson.zig.zon
│       │   │   │   ├── cyan.zig.zon
│       │   │   │   ├── dark_grey.zig.zon
│       │   │   │   ├── green.zig.zon
│       │   │   │   ├── grey.zig.zon
│       │   │   │   ├── indigo.zig.zon
│       │   │   │   ├── lime.zig.zon
│       │   │   │   ├── magenta.zig.zon
│       │   │   │   ├── orange.zig.zon
│       │   │   │   ├── pink.zig.zon
│       │   │   │   ├── purple.zig.zon
│       │   │   │   ├── red.zig.zon
│       │   │   │   ├── violet.zig.zon
│       │   │   │   ├── viridian.zig.zon
│       │   │   │   ├── white.zig.zon
│       │   │   │   └── yellow.zig.zon
│       │   │   └── origin.zig.zon
│       │   ├── sign
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── baobab.zig.zon
│       │   │   ├── birch.zig.zon
│       │   │   ├── mahogany.zig.zon
│       │   │   ├── oak.zig.zon
│       │   │   ├── palm.zig.zon
│       │   │   ├── pine.zig.zon
│       │   │   └── willow.zig.zon
│       │   ├── silver_block.zig.zon
│       │   ├── silver_ore.zig.zon
│       │   ├── slate
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── cobble.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── snow.zig.zon
│       │   ├── soil.zig.zon
│       │   ├── sulfur_block.zig.zon
│       │   ├── sulfur_lamp.zig.zon
│       │   ├── sulfur_ore.zig.zon
│       │   ├── sulfur_torch.zig.zon
│       │   ├── terracotta
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── textures
│       │   │   ├── amber_block.png
│       │   │   ├── amber_block_reflectivity.png
│       │   │   ├── amber_ore.png
│       │   │   ├── amber_ore_reflectivity.png
│       │   │   ├── baobab_fence.png
│       │   │   ├── baobab_fence_top.png
│       │   │   ├── baobab_log.png
│       │   │   ├── baobab_log_top.png
│       │   │   ├── baobab_planks.png
│       │   │   ├── bars
│       │   │   │   ├── copper.png
│       │   │   │   ├── copper_reflectivity.png
│       │   │   │   ├── gold.png
│       │   │   │   ├── gold_reflectivity.png
│       │   │   │   ├── iron.png
│       │   │   │   ├── iron_reflectivity.png
│       │   │   │   ├── silver.png
│       │   │   │   ├── silver_reflectivity.png
│       │   │   │   ├── uranium.png
│       │   │   │   └── uranium_reflectivity.png
│       │   │   ├── basalt
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── bellows
│       │   │   │   ├── bottom.png
│       │   │   │   ├── nozzle.png
│       │   │   │   ├── nozzle_reflectivity.png
│       │   │   │   ├── side.png
│       │   │   │   ├── side_reflectivity.png
│       │   │   │   ├── top.png
│       │   │   │   └── top_reflectivity.png
│       │   │   ├── birch_fence.png
│       │   │   ├── birch_fence_top.png
│       │   │   ├── birch_log.png
│       │   │   ├── birch_log_top.png
│       │   │   ├── birch_planks.png
│       │   │   ├── bluebells.png
│       │   │   ├── bluebells.zig.zon
│       │   │   ├── bolete_bottom.png
│       │   │   ├── bolete_cap.png
│       │   │   ├── bolete_side.png
│       │   │   ├── bolete_stem.png
│       │   │   ├── bolete_top.png
│       │   │   ├── branch
│       │   │   │   ├── baobab
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── birch
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── bolete
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── cactus
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── glimmergill
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── mahogany
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── oak
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── palm
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── pine
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   ├── toadstool
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── half_line.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   └── line.png
│       │   │   │   └── willow
│       │   │   │       ├── bend.png
│       │   │   │       ├── cross.png
│       │   │   │       ├── dot.png
│       │   │   │       ├── half_line.png
│       │   │   │       ├── intersection.png
│       │   │   │       └── line.png
│       │   │   ├── breaking
│       │   │   │   ├── 0.png
│       │   │   │   ├── 1.png
│       │   │   │   ├── 2.png
│       │   │   │   ├── 3.png
│       │   │   │   ├── 4.png
│       │   │   │   ├── 5.png
│       │   │   │   ├── 6.png
│       │   │   │   ├── 7.png
│       │   │   │   ├── 8.png
│       │   │   │   └── 9.png
│       │   │   ├── cactus.png
│       │   │   ├── cactus_flower.png
│       │   │   ├── cactus_flower.zig.zon
│       │   │   ├── cactus_flower_top.png
│       │   │   ├── cactus_flower_top.zig.zon
│       │   │   ├── cactus_top.png
│       │   │   ├── candy_cane
│       │   │   │   ├── block.png
│       │   │   │   └── branch
│       │   │   │       ├── bend.png
│       │   │   │       ├── cross.png
│       │   │   │       ├── dot.png
│       │   │   │       ├── half_line.png
│       │   │   │       ├── intersection.png
│       │   │   │       └── line.png
│       │   │   ├── castilleja.png
│       │   │   ├── castilleja.zig.zon
│       │   │   ├── castilleja_top.png
│       │   │   ├── castilleja_top.zig.zon
│       │   │   ├── chain
│       │   │   │   ├── iron.png
│       │   │   │   └── iron_reflectivity.png
│       │   │   ├── chalk
│       │   │   │   ├── aqua.png
│       │   │   │   ├── black.png
│       │   │   │   ├── blue.png
│       │   │   │   ├── brown.png
│       │   │   │   ├── crimson.png
│       │   │   │   ├── cyan.png
│       │   │   │   ├── dark_grey.png
│       │   │   │   ├── green.png
│       │   │   │   ├── grey.png
│       │   │   │   ├── indigo.png
│       │   │   │   ├── lime.png
│       │   │   │   ├── magenta.png
│       │   │   │   ├── orange.png
│       │   │   │   ├── pink.png
│       │   │   │   ├── purple.png
│       │   │   │   ├── red.png
│       │   │   │   ├── violet.png
│       │   │   │   ├── viridian.png
│       │   │   │   ├── white.png
│       │   │   │   └── yellow.png
│       │   │   ├── chest
│       │   │   │   ├── baobab
│       │   │   │   │   ├── back.png
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── front.png
│       │   │   │   │   ├── side.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── birch
│       │   │   │   │   ├── back.png
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── front.png
│       │   │   │   │   ├── side.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── mahogany
│       │   │   │   │   ├── back.png
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── front.png
│       │   │   │   │   ├── side.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── oak
│       │   │   │   │   ├── back.png
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── front.png
│       │   │   │   │   ├── side.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── palm
│       │   │   │   │   ├── back.png
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── front.png
│       │   │   │   │   ├── side.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── pine
│       │   │   │   │   ├── back.png
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── front.png
│       │   │   │   │   ├── side.png
│       │   │   │   │   └── top.png
│       │   │   │   └── willow
│       │   │   │       ├── back.png
│       │   │   │       ├── bottom.png
│       │   │   │       ├── front.png
│       │   │   │       ├── side.png
│       │   │   │       └── top.png
│       │   │   ├── chimney
│       │   │   │   ├── bottom.png
│       │   │   │   ├── side.png
│       │   │   │   ├── side_reflectivity.png
│       │   │   │   ├── top.png
│       │   │   │   └── top_reflectivity.png
│       │   │   ├── clay.png
│       │   │   ├── cloth
│       │   │   │   ├── aqua.png
│       │   │   │   ├── black.png
│       │   │   │   ├── blue.png
│       │   │   │   ├── brown.png
│       │   │   │   ├── crimson.png
│       │   │   │   ├── cyan.png
│       │   │   │   ├── dark_grey.png
│       │   │   │   ├── green.png
│       │   │   │   ├── grey.png
│       │   │   │   ├── indigo.png
│       │   │   │   ├── lime.png
│       │   │   │   ├── magenta.png
│       │   │   │   ├── orange.png
│       │   │   │   ├── pink.png
│       │   │   │   ├── purple.png
│       │   │   │   ├── red.png
│       │   │   │   ├── violet.png
│       │   │   │   ├── viridian.png
│       │   │   │   ├── white.png
│       │   │   │   └── yellow.png
│       │   │   ├── coal_block.png
│       │   │   ├── coal_ore.png
│       │   │   ├── cold_grass.png
│       │   │   ├── cold_grass_vegetation.png
│       │   │   ├── cold_grass_vegetation.zig.zon
│       │   │   ├── copper_block.png
│       │   │   ├── copper_block_reflectivity.png
│       │   │   ├── copper_ore.png
│       │   │   ├── copper_ore_reflectivity.png
│       │   │   ├── cut_amber_block.png
│       │   │   ├── cut_amber_block_reflectivity.png
│       │   │   ├── cut_diamond_block.png
│       │   │   ├── cut_diamond_block_reflectivity.png
│       │   │   ├── cut_ruby_block.png
│       │   │   ├── cut_ruby_block_reflectivity.png
│       │   │   ├── daffodil.png
│       │   │   ├── daffodil.zig.zon
│       │   │   ├── daffodil_top.png
│       │   │   ├── daffodil_top.zig.zon
│       │   │   ├── daisies.png
│       │   │   ├── dandelions.png
│       │   │   ├── dead_leaf_pile
│       │   │   │   ├── 0.png
│       │   │   │   ├── 1.png
│       │   │   │   ├── 2.png
│       │   │   │   └── 3.png
│       │   │   ├── diamond_block.png
│       │   │   ├── diamond_block_reflectivity.png
│       │   │   ├── diamond_ore.png
│       │   │   ├── diamond_ore_reflectivity.png
│       │   │   ├── dirt.png
│       │   │   ├── dither
│       │   │   │   ├── 1.png
│       │   │   │   ├── 16.png
│       │   │   │   ├── 2.png
│       │   │   │   ├── 32.png
│       │   │   │   ├── 4.png
│       │   │   │   ├── 64.png
│       │   │   │   └── 8.png
│       │   │   ├── dry_grass.png
│       │   │   ├── dry_grass_vegetation.png
│       │   │   ├── dry_grass_vegetation.zig.zon
│       │   │   ├── duckweed
│       │   │   │   ├── 0.png
│       │   │   │   ├── 1.png
│       │   │   │   ├── 2.png
│       │   │   │   └── 3.png
│       │   │   ├── fern.png
│       │   │   ├── fern.zig.zon
│       │   │   ├── ferrock
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── fog
│       │   │   │   ├── blue.png
│       │   │   │   ├── blue.zig.zon
│       │   │   │   ├── cyan.png
│       │   │   │   ├── cyan.zig.zon
│       │   │   │   ├── green.png
│       │   │   │   ├── green.zig.zon
│       │   │   │   ├── magenta.png
│       │   │   │   ├── magenta.zig.zon
│       │   │   │   ├── red.png
│       │   │   │   ├── red.zig.zon
│       │   │   │   ├── yellow.png
│       │   │   │   └── yellow.zig.zon
│       │   │   ├── frost.png
│       │   │   ├── frost_reflectivity.png
│       │   │   ├── furnace
│       │   │   │   ├── back.png
│       │   │   │   ├── bottom.png
│       │   │   │   ├── front.png
│       │   │   │   ├── front_lit.png
│       │   │   │   ├── front_lit.zig.zon
│       │   │   │   ├── front_lit_emission.png
│       │   │   │   ├── side.png
│       │   │   │   ├── side_lit.png
│       │   │   │   ├── side_lit.zig.zon
│       │   │   │   ├── side_lit_emission.png
│       │   │   │   └── top.png
│       │   │   ├── glacite
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── glass
│       │   │   │   ├── aqua.png
│       │   │   │   ├── aqua_absorption.png
│       │   │   │   ├── aqua_reflectivity.png
│       │   │   │   ├── black.png
│       │   │   │   ├── black_absorption.png
│       │   │   │   ├── black_reflectivity.png
│       │   │   │   ├── blue.png
│       │   │   │   ├── blue_absorption.png
│       │   │   │   ├── blue_reflectivity.png
│       │   │   │   ├── brown.png
│       │   │   │   ├── brown_absorption.png
│       │   │   │   ├── brown_reflectivity.png
│       │   │   │   ├── crimson.png
│       │   │   │   ├── crimson_absorption.png
│       │   │   │   ├── crimson_reflectivity.png
│       │   │   │   ├── cyan.png
│       │   │   │   ├── cyan_absorption.png
│       │   │   │   ├── cyan_reflectivity.png
│       │   │   │   ├── dark_grey.png
│       │   │   │   ├── dark_grey_absorption.png
│       │   │   │   ├── dark_grey_reflectivity.png
│       │   │   │   ├── green.png
│       │   │   │   ├── green_absorption.png
│       │   │   │   ├── green_reflectivity.png
│       │   │   │   ├── grey.png
│       │   │   │   ├── grey_absorption.png
│       │   │   │   ├── grey_reflectivity.png
│       │   │   │   ├── indigo.png
│       │   │   │   ├── indigo_absorption.png
│       │   │   │   ├── indigo_reflectivity.png
│       │   │   │   ├── lime.png
│       │   │   │   ├── lime_absorption.png
│       │   │   │   ├── lime_reflectivity.png
│       │   │   │   ├── magenta.png
│       │   │   │   ├── magenta_absorption.png
│       │   │   │   ├── magenta_reflectivity.png
│       │   │   │   ├── orange.png
│       │   │   │   ├── orange_absorption.png
│       │   │   │   ├── orange_reflectivity.png
│       │   │   │   ├── pink.png
│       │   │   │   ├── pink_absorption.png
│       │   │   │   ├── pink_reflectivity.png
│       │   │   │   ├── purple.png
│       │   │   │   ├── purple_absorption.png
│       │   │   │   ├── purple_reflectivity.png
│       │   │   │   ├── red.png
│       │   │   │   ├── red_absorption.png
│       │   │   │   ├── red_reflectivity.png
│       │   │   │   ├── uranium.png
│       │   │   │   ├── uranium_absorption.png
│       │   │   │   ├── uranium_emission.png
│       │   │   │   ├── uranium_reflectivity.png
│       │   │   │   ├── violet.png
│       │   │   │   ├── violet_absorption.png
│       │   │   │   ├── violet_reflectivity.png
│       │   │   │   ├── viridian.png
│       │   │   │   ├── viridian_absorption.png
│       │   │   │   ├── viridian_reflectivity.png
│       │   │   │   ├── white.png
│       │   │   │   ├── white_absorption.png
│       │   │   │   ├── white_reflectivity.png
│       │   │   │   ├── yellow.png
│       │   │   │   ├── yellow_absorption.png
│       │   │   │   └── yellow_reflectivity.png
│       │   │   ├── glimmergill_bottom.png
│       │   │   ├── glimmergill_bottom_emission.png
│       │   │   ├── glimmergill_cap.png
│       │   │   ├── glimmergill_cap_emission.png
│       │   │   ├── glimmergill_side.png
│       │   │   ├── glimmergill_side_emission.png
│       │   │   ├── glimmergill_stem.png
│       │   │   ├── glimmergill_top.png
│       │   │   ├── glimmergill_top_emission.png
│       │   │   ├── glow_crystal
│       │   │   │   ├── aqua.png
│       │   │   │   ├── aqua_emission.png
│       │   │   │   ├── aqua_reflectivity.png
│       │   │   │   ├── black.png
│       │   │   │   ├── black_emission.png
│       │   │   │   ├── black_reflectivity.png
│       │   │   │   ├── blue.png
│       │   │   │   ├── blue_emission.png
│       │   │   │   ├── blue_reflectivity.png
│       │   │   │   ├── brown.png
│       │   │   │   ├── brown_emission.png
│       │   │   │   ├── brown_reflectivity.png
│       │   │   │   ├── crimson.png
│       │   │   │   ├── crimson_emission.png
│       │   │   │   ├── crimson_reflectivity.png
│       │   │   │   ├── cyan.png
│       │   │   │   ├── cyan_emission.png
│       │   │   │   ├── cyan_reflectivity.png
│       │   │   │   ├── dark_grey.png
│       │   │   │   ├── dark_grey_emission.png
│       │   │   │   ├── dark_grey_reflectivity.png
│       │   │   │   ├── green.png
│       │   │   │   ├── green_emission.png
│       │   │   │   ├── green_reflectivity.png
│       │   │   │   ├── grey.png
│       │   │   │   ├── grey_emission.png
│       │   │   │   ├── grey_reflectivity.png
│       │   │   │   ├── indigo.png
│       │   │   │   ├── indigo_emission.png
│       │   │   │   ├── indigo_reflectivity.png
│       │   │   │   ├── lime.png
│       │   │   │   ├── lime_emission.png
│       │   │   │   ├── lime_reflectivity.png
│       │   │   │   ├── magenta.png
│       │   │   │   ├── magenta_emission.png
│       │   │   │   ├── magenta_reflectivity.png
│       │   │   │   ├── orange.png
│       │   │   │   ├── orange_emission.png
│       │   │   │   ├── orange_reflectivity.png
│       │   │   │   ├── pink.png
│       │   │   │   ├── pink_emission.png
│       │   │   │   ├── pink_reflectivity.png
│       │   │   │   ├── purple.png
│       │   │   │   ├── purple_emission.png
│       │   │   │   ├── purple_reflectivity.png
│       │   │   │   ├── red.png
│       │   │   │   ├── red_emission.png
│       │   │   │   ├── red_reflectivity.png
│       │   │   │   ├── violet.png
│       │   │   │   ├── violet_emission.png
│       │   │   │   ├── violet_reflectivity.png
│       │   │   │   ├── viridian.png
│       │   │   │   ├── viridian_emission.png
│       │   │   │   ├── viridian_reflectivity.png
│       │   │   │   ├── white.png
│       │   │   │   ├── white_emission.png
│       │   │   │   ├── white_reflectivity.png
│       │   │   │   ├── yellow.png
│       │   │   │   ├── yellow_emission.png
│       │   │   │   └── yellow_reflectivity.png
│       │   │   ├── gold_block.png
│       │   │   ├── gold_block_reflectivity.png
│       │   │   ├── gold_ore.png
│       │   │   ├── gold_ore_reflectivity.png
│       │   │   ├── grass_top.png
│       │   │   ├── grass_vegetation.png
│       │   │   ├── grass_vegetation.zig.zon
│       │   │   ├── gravel.png
│       │   │   ├── hibiscus.png
│       │   │   ├── hibiscus.zig.zon
│       │   │   ├── hibiscus_top.png
│       │   │   ├── hibiscus_top.zig.zon
│       │   │   ├── ice.png
│       │   │   ├── ice_reflectivity.png
│       │   │   ├── iron_block.png
│       │   │   ├── iron_block_reflectivity.png
│       │   │   ├── iron_ore.png
│       │   │   ├── iron_ore_reflectivity.png
│       │   │   ├── ivy.png
│       │   │   ├── kiln
│       │   │   │   ├── back.png
│       │   │   │   ├── bottom.png
│       │   │   │   ├── front.png
│       │   │   │   ├── front_lit.png
│       │   │   │   ├── front_lit.zig.zon
│       │   │   │   ├── front_lit_emission.png
│       │   │   │   ├── side.png
│       │   │   │   ├── side_lit.png
│       │   │   │   ├── side_lit.zig.zon
│       │   │   │   ├── side_lit_emission.png
│       │   │   │   └── top.png
│       │   │   ├── ladder
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── pine.png
│       │   │   │   └── willow.png
│       │   │   ├── lamp.png
│       │   │   ├── lamp_emission.png
│       │   │   ├── lamp_reflectivity.png
│       │   │   ├── lamp_top.png
│       │   │   ├── lamp_top_emission.png
│       │   │   ├── lamp_top_reflectivity.png
│       │   │   ├── lantern
│       │   │   │   ├── coal
│       │   │   │   │   ├── side.png
│       │   │   │   │   ├── side_emission.png
│       │   │   │   │   ├── side_reflectivity.png
│       │   │   │   │   ├── top.png
│       │   │   │   │   └── top_reflectivity.png
│       │   │   │   └── sulfur
│       │   │   │       ├── side.png
│       │   │   │       ├── side_emission.png
│       │   │   │       ├── side_reflectivity.png
│       │   │   │       ├── top.png
│       │   │   │       └── top_reflectivity.png
│       │   │   ├── lava.png
│       │   │   ├── lava.zig.zon
│       │   │   ├── lava_emission.png
│       │   │   ├── leaves
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── dead.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── opaque
│       │   │   │   │   ├── baobab.png
│       │   │   │   │   ├── birch.png
│       │   │   │   │   ├── dead.png
│       │   │   │   │   ├── mahogany.png
│       │   │   │   │   ├── oak.png
│       │   │   │   │   ├── palm.png
│       │   │   │   │   ├── pine.png
│       │   │   │   │   ├── red.png
│       │   │   │   │   ├── willow.png
│       │   │   │   │   └── yellow.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── palm_hanging.png
│       │   │   │   ├── pine.png
│       │   │   │   ├── red.png
│       │   │   │   ├── willow.png
│       │   │   │   └── yellow.png
│       │   │   ├── lily_pad.png
│       │   │   ├── lily_pad_reflectivity.png
│       │   │   ├── limestone
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── log
│       │   │   │   ├── baobab
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── birch
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── bolete
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── cactus
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── glimmergill
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── mahogany
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── oak
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── palm
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── pine
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   ├── toadstool
│       │   │   │   │   ├── bend.png
│       │   │   │   │   ├── cross.png
│       │   │   │   │   ├── dot.png
│       │   │   │   │   ├── intersection.png
│       │   │   │   │   ├── line.png
│       │   │   │   │   └── top.png
│       │   │   │   └── willow
│       │   │   │       ├── bend.png
│       │   │   │       ├── cross.png
│       │   │   │       ├── dot.png
│       │   │   │       ├── intersection.png
│       │   │   │       ├── line.png
│       │   │   │       └── top.png
│       │   │   ├── lush_grass_top.png
│       │   │   ├── lush_grass_vegetation.png
│       │   │   ├── lush_grass_vegetation.zig.zon
│       │   │   ├── magma.png
│       │   │   ├── magma_emission.png
│       │   │   ├── mahogany_fence.png
│       │   │   ├── mahogany_fence_top.png
│       │   │   ├── mahogany_log.png
│       │   │   ├── mahogany_log_top.png
│       │   │   ├── mahogany_planks.png
│       │   │   ├── marble
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── marigold.png
│       │   │   ├── marigold.zig.zon
│       │   │   ├── moss.png
│       │   │   ├── mud.png
│       │   │   ├── oak_fence.png
│       │   │   ├── oak_fence_top.png
│       │   │   ├── oak_log.png
│       │   │   ├── oak_log_top.png
│       │   │   ├── oak_planks.png
│       │   │   ├── obsidian.png
│       │   │   ├── osier.png
│       │   │   ├── palm_fence.png
│       │   │   ├── palm_fence_top.png
│       │   │   ├── palm_planks.png
│       │   │   ├── pebbles.png
│       │   │   ├── permafrost.png
│       │   │   ├── pine_fence.png
│       │   │   ├── pine_fence_top.png
│       │   │   ├── pine_log.png
│       │   │   ├── pine_log_top.png
│       │   │   ├── pine_planks.png
│       │   │   ├── red_leaf_pile
│       │   │   │   ├── 0.png
│       │   │   │   ├── 1.png
│       │   │   │   ├── 2.png
│       │   │   │   └── 3.png
│       │   │   ├── resin.png
│       │   │   ├── resin_block.png
│       │   │   ├── resin_block_reflectivity.png
│       │   │   ├── ruby_block.png
│       │   │   ├── ruby_block_reflectivity.png
│       │   │   ├── ruby_ore.png
│       │   │   ├── ruby_ore_reflectivity.png
│       │   │   ├── sand.png
│       │   │   ├── sandstone
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── sbb
│       │   │   │   ├── child
│       │   │   │   │   ├── bottom
│       │   │   │   │   │   ├── aqua.png
│       │   │   │   │   │   ├── black.png
│       │   │   │   │   │   ├── blue.png
│       │   │   │   │   │   ├── brown.png
│       │   │   │   │   │   ├── crimson.png
│       │   │   │   │   │   ├── cyan.png
│       │   │   │   │   │   ├── dark_grey.png
│       │   │   │   │   │   ├── green.png
│       │   │   │   │   │   ├── grey.png
│       │   │   │   │   │   ├── indigo.png
│       │   │   │   │   │   ├── lime.png
│       │   │   │   │   │   ├── magenta.png
│       │   │   │   │   │   ├── orange.png
│       │   │   │   │   │   ├── pink.png
│       │   │   │   │   │   ├── purple.png
│       │   │   │   │   │   ├── red.png
│       │   │   │   │   │   ├── violet.png
│       │   │   │   │   │   ├── viridian.png
│       │   │   │   │   │   ├── white.png
│       │   │   │   │   │   └── yellow.png
│       │   │   │   │   ├── side
│       │   │   │   │   │   ├── aqua.png
│       │   │   │   │   │   ├── black.png
│       │   │   │   │   │   ├── blue.png
│       │   │   │   │   │   ├── brown.png
│       │   │   │   │   │   ├── crimson.png
│       │   │   │   │   │   ├── cyan.png
│       │   │   │   │   │   ├── dark_grey.png
│       │   │   │   │   │   ├── green.png
│       │   │   │   │   │   ├── grey.png
│       │   │   │   │   │   ├── indigo.png
│       │   │   │   │   │   ├── lime.png
│       │   │   │   │   │   ├── magenta.png
│       │   │   │   │   │   ├── orange.png
│       │   │   │   │   │   ├── pink.png
│       │   │   │   │   │   ├── purple.png
│       │   │   │   │   │   ├── red.png
│       │   │   │   │   │   ├── violet.png
│       │   │   │   │   │   ├── viridian.png
│       │   │   │   │   │   ├── white.png
│       │   │   │   │   │   └── yellow.png
│       │   │   │   │   └── top
│       │   │   │   │       ├── aqua.png
│       │   │   │   │       ├── black.png
│       │   │   │   │       ├── blue.png
│       │   │   │   │       ├── brown.png
│       │   │   │   │       ├── crimson.png
│       │   │   │   │       ├── cyan.png
│       │   │   │   │       ├── dark_grey.png
│       │   │   │   │       ├── green.png
│       │   │   │   │       ├── grey.png
│       │   │   │   │       ├── indigo.png
│       │   │   │   │       ├── lime.png
│       │   │   │   │       ├── magenta.png
│       │   │   │   │       ├── orange.png
│       │   │   │   │       ├── pink.png
│       │   │   │   │       ├── purple.png
│       │   │   │   │       ├── red.png
│       │   │   │   │       ├── violet.png
│       │   │   │   │       ├── viridian.png
│       │   │   │   │       ├── white.png
│       │   │   │   │       └── yellow.png
│       │   │   │   ├── origin_bottom.png
│       │   │   │   ├── origin_side.png
│       │   │   │   └── origin_top.png
│       │   │   ├── sign
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── pine.png
│       │   │   │   └── willow.png
│       │   │   ├── silver_block.png
│       │   │   ├── silver_block_reflectivity.png
│       │   │   ├── silver_ore.png
│       │   │   ├── silver_ore_reflectivity.png
│       │   │   ├── slate
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── cobble.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── snow.png
│       │   │   ├── soil.png
│       │   │   ├── sulfur_block.png
│       │   │   ├── sulfur_lamp.png
│       │   │   ├── sulfur_lamp_emission.png
│       │   │   ├── sulfur_lamp_reflectivity.png
│       │   │   ├── sulfur_lamp_top.png
│       │   │   ├── sulfur_lamp_top_emission.png
│       │   │   ├── sulfur_lamp_top_reflectivity.png
│       │   │   ├── sulfur_ore.png
│       │   │   ├── sulfur_torch.png
│       │   │   ├── sulfur_torch_emission.png
│       │   │   ├── terracotta
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── toadstool_bottom.png
│       │   │   ├── toadstool_cap.png
│       │   │   ├── toadstool_side.png
│       │   │   ├── toadstool_stem.png
│       │   │   ├── toadstool_top.png
│       │   │   ├── torch.png
│       │   │   ├── torch_emission.png
│       │   │   ├── trumpet_lily.png
│       │   │   ├── trumpet_lily.zig.zon
│       │   │   ├── trumpet_lily_top.png
│       │   │   ├── trumpet_lily_top.zig.zon
│       │   │   ├── tussock.png
│       │   │   ├── tussock.zig.zon
│       │   │   ├── undefined.png
│       │   │   ├── uranium_block.png
│       │   │   ├── uranium_block_reflectivity.png
│       │   │   ├── uranium_ore.png
│       │   │   ├── uranium_ore_emission.png
│       │   │   ├── uranium_ore_reflectivity.png
│       │   │   ├── vetch.png
│       │   │   ├── vetch.zig.zon
│       │   │   ├── vine
│       │   │   │   ├── glimmer_worms
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── bottom.zig.zon
│       │   │   │   │   ├── bottom_emission.png
│       │   │   │   │   ├── top.png
│       │   │   │   │   ├── top.zig.zon
│       │   │   │   │   └── top_emission.png
│       │   │   │   ├── mahogany
│       │   │   │   │   ├── bottom.png
│       │   │   │   │   ├── bottom.zig.zon
│       │   │   │   │   ├── top.png
│       │   │   │   │   └── top.zig.zon
│       │   │   │   └── willow
│       │   │   │       ├── bottom.png
│       │   │   │       ├── bottom.zig.zon
│       │   │   │       ├── top.png
│       │   │   │       └── top.zig.zon
│       │   │   ├── void.png
│       │   │   ├── voidstone
│       │   │   │   ├── base.png
│       │   │   │   ├── bricks.png
│       │   │   │   ├── tile.png
│       │   │   │   ├── wall.png
│       │   │   │   └── wall_top.png
│       │   │   ├── water.png
│       │   │   ├── water.zig.zon
│       │   │   ├── water_absorption.png
│       │   │   ├── water_reflectivity.png
│       │   │   ├── willow_fence.png
│       │   │   ├── willow_fence_top.png
│       │   │   ├── willow_log.png
│       │   │   ├── willow_log_top.png
│       │   │   ├── willow_planks.png
│       │   │   ├── workbench_back.png
│       │   │   ├── workbench_bottom.png
│       │   │   ├── workbench_front.png
│       │   │   ├── workbench_side.png
│       │   │   ├── workbench_side_reflectivity.png
│       │   │   ├── workbench_top.png
│       │   │   └── yellow_leaf_pile
│       │   │       ├── 0.png
│       │   │       ├── 1.png
│       │   │       ├── 2.png
│       │   │       └── 3.png
│       │   ├── toadstool.zig.zon
│       │   ├── toadstool_branch.zig.zon
│       │   ├── toadstool_cap.zig.zon
│       │   ├── toadstool_stem.zig.zon
│       │   ├── torch.zig.zon
│       │   ├── trumpet_lily.zig.zon
│       │   ├── tussock.zig.zon
│       │   ├── uranium_block.zig.zon
│       │   ├── uranium_ore.zig.zon
│       │   ├── vetch.zig.zon
│       │   ├── vine
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── glimmer_worms.zig.zon
│       │   │   ├── mahogany.zig.zon
│       │   │   └── willow.zig.zon
│       │   ├── void.zig.zon
│       │   ├── voidstone
│       │   │   ├── _defaults.zig.zon
│       │   │   ├── base.zig.zon
│       │   │   ├── bricks.zig.zon
│       │   │   ├── tile.zig.zon
│       │   │   └── wall.zig.zon
│       │   ├── water.zig.zon
│       │   ├── willow_branch.zig.zon
│       │   ├── willow_fence.zig.zon
│       │   ├── willow_log.zig.zon
│       │   ├── willow_planks.zig.zon
│       │   ├── willow_top.zig.zon
│       │   ├── workbench.zig.zon
│       │   └── yellow_leaf_pile.zig.zon
│       ├── default_background.png
│       ├── entity
│       │   ├── models
│       │   │   └── snale.obj
│       │   └── textures
│       │       └── snale.png
│       ├── items
│       │   ├── _migrations.zig.zon
│       │   ├── apple.zig.zon
│       │   ├── copper_ingot.zig.zon
│       │   ├── gold_ingot.zig.zon
│       │   ├── iron_ingot.zig.zon
│       │   ├── raw_meat.zig.zon
│       │   ├── selection_wand.zig.zon
│       │   ├── silver_ingot.zig.zon
│       │   ├── textures
│       │   │   ├── amber.png
│       │   │   ├── apple.png
│       │   │   ├── bars
│       │   │   │   ├── copper.png
│       │   │   │   ├── gold.png
│       │   │   │   ├── iron.png
│       │   │   │   ├── silver.png
│       │   │   │   └── uranium.png
│       │   │   ├── bellows.png
│       │   │   ├── bluebells.png
│       │   │   ├── bolete.png
│       │   │   ├── branch
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── bolete.png
│       │   │   │   ├── glimmergill.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── pine.png
│       │   │   │   ├── toadstool.png
│       │   │   │   └── willow.png
│       │   │   ├── cactus_arm.png
│       │   │   ├── cactus_flower.png
│       │   │   ├── candy_cane.png
│       │   │   ├── castilleja.png
│       │   │   ├── chain
│       │   │   │   └── iron.png
│       │   │   ├── chimney.png
│       │   │   ├── chisel.png
│       │   │   ├── cloth
│       │   │   │   ├── aqua.png
│       │   │   │   ├── black.png
│       │   │   │   ├── blue.png
│       │   │   │   ├── brown.png
│       │   │   │   ├── crimson.png
│       │   │   │   ├── cyan.png
│       │   │   │   ├── dark_grey.png
│       │   │   │   ├── green.png
│       │   │   │   ├── grey.png
│       │   │   │   ├── indigo.png
│       │   │   │   ├── lime.png
│       │   │   │   ├── magenta.png
│       │   │   │   ├── orange.png
│       │   │   │   ├── pink.png
│       │   │   │   ├── purple.png
│       │   │   │   ├── red.png
│       │   │   │   ├── violet.png
│       │   │   │   ├── viridian.png
│       │   │   │   ├── white.png
│       │   │   │   └── yellow.png
│       │   │   ├── coal.png
│       │   │   ├── cold_grass.png
│       │   │   ├── copper_ingot.png
│       │   │   ├── daffodil.png
│       │   │   ├── daisies.png
│       │   │   ├── dandelions.png
│       │   │   ├── dead_leaf_pile.png
│       │   │   ├── diamond.png
│       │   │   ├── dry_grass.png
│       │   │   ├── duckweed.png
│       │   │   ├── fence
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── pine.png
│       │   │   │   └── willow.png
│       │   │   ├── fern.png
│       │   │   ├── fog
│       │   │   │   ├── blue.png
│       │   │   │   ├── cyan.png
│       │   │   │   ├── green.png
│       │   │   │   ├── magenta.png
│       │   │   │   ├── red.png
│       │   │   │   └── yellow.png
│       │   │   ├── glimmergill.png
│       │   │   ├── gold_ingot.png
│       │   │   ├── grass.png
│       │   │   ├── hibiscus.png
│       │   │   ├── iron_ingot.png
│       │   │   ├── ivy.png
│       │   │   ├── ladder
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── pine.png
│       │   │   │   └── willow.png
│       │   │   ├── lantern
│       │   │   │   ├── coal.png
│       │   │   │   └── sulfur.png
│       │   │   ├── lily_pad.png
│       │   │   ├── lush_grass.png
│       │   │   ├── marigold.png
│       │   │   ├── moss.png
│       │   │   ├── osier.png
│       │   │   ├── pebbles.png
│       │   │   ├── raw_copper.png
│       │   │   ├── raw_gold.png
│       │   │   ├── raw_iron.png
│       │   │   ├── raw_meat.png
│       │   │   ├── raw_silver.png
│       │   │   ├── raw_uranium.png
│       │   │   ├── red_leaf_pile.png
│       │   │   ├── resin.png
│       │   │   ├── ruby.png
│       │   │   ├── selection_wand.png
│       │   │   ├── sign
│       │   │   │   ├── baobab.png
│       │   │   │   ├── birch.png
│       │   │   │   ├── mahogany.png
│       │   │   │   ├── oak.png
│       │   │   │   ├── palm.png
│       │   │   │   ├── pine.png
│       │   │   │   └── willow.png
│       │   │   ├── silver_ingot.png
│       │   │   ├── sulfur.png
│       │   │   ├── sulfur_torch.png
│       │   │   ├── toadstool.png
│       │   │   ├── torch.png
│       │   │   ├── trumpet_lily.png
│       │   │   ├── tussock.png
│       │   │   ├── uranium_ingot.png
│       │   │   ├── vetch.png
│       │   │   ├── vine
│       │   │   │   ├── glimmer_worms.png
│       │   │   │   ├── mahogany.png
│       │   │   │   └── willow.png
│       │   │   ├── wall
│       │   │   │   ├── basalt.png
│       │   │   │   ├── ferrock.png
│       │   │   │   ├── glacite.png
│       │   │   │   ├── limestone.png
│       │   │   │   ├── marble.png
│       │   │   │   ├── sandstone.png
│       │   │   │   ├── slate.png
│       │   │   │   ├── terracotta.png
│       │   │   │   └── voidstone.png
│       │   │   └── yellow_leaf_pile.png
│       │   └── uranium_ingot.zig.zon
│       ├── logo.icns
│       ├── logo.png
│       ├── models
│       │   ├── bars.obj
│       │   ├── bellows.obj
│       │   ├── bolete
│       │   │   ├── floor.obj
│       │   │   └── shelf.obj
│       │   ├── cactus_flower.obj
│       │   ├── carpet.obj
│       │   ├── chain.obj
│       │   ├── chimney.obj
│       │   ├── cross.obj
│       │   ├── cross_with_texture_1.obj
│       │   ├── cube.obj
│       │   ├── cube_hanging_planes.obj
│       │   ├── fence.obj
│       │   ├── fern.obj
│       │   ├── flower
│       │   │   ├── height_10.obj
│       │   │   └── height_8.obj
│       │   ├── glimmergill
│       │   │   ├── floor.obj
│       │   │   └── shelf.obj
│       │   ├── lantern
│       │   │   ├── ceiling.obj
│       │   │   ├── floor.obj
│       │   │   └── side.obj
│       │   ├── plane.obj
│       │   ├── sign
│       │   │   ├── ceiling.obj
│       │   │   ├── floor.obj
│       │   │   └── side.obj
│       │   ├── toadstool
│       │   │   ├── floor.obj
│       │   │   └── shelf.obj
│       │   ├── torch.obj
│       │   ├── torch_side.obj
│       │   └── wall.obj
│       ├── particles
│       │   ├── flame.zig.zon
│       │   ├── poof.zig.zon
│       │   └── textures
│       │       ├── flame.png
│       │       ├── flame_emission.png
│       │       └── poof.png
│       ├── recipes
│       │   ├── brick_recipes.zig.zon
│       │   ├── cloth_recipes.zig.zon
│       │   ├── special_recipes.zig.zon
│       │   └── wood_recipes.zig.zon
│       ├── sbb
│       │   ├── cactus
│       │   │   ├── arm
│       │   │   │   ├── 0.blp
│       │   │   │   ├── 1.blp
│       │   │   │   ├── 2.blp
│       │   │   │   ├── 3.blp
│       │   │   │   └── 4.blp
│       │   │   ├── arms.zig.zon
│       │   │   ├── base
│       │   │   │   ├── 2_tall.blp
│       │   │   │   ├── 2_tall_1.blp
│       │   │   │   ├── 3_arms.blp
│       │   │   │   ├── 3_tall.blp
│       │   │   │   ├── 3_tall_1.blp
│       │   │   │   └── 4_arms.blp
│       │   │   ├── flower.zig.zon
│       │   │   ├── flowers
│       │   │   │   └── 0.blp
│       │   │   ├── old_growth
│       │   │   │   ├── 0.blp
│       │   │   │   └── 1.blp
│       │   │   ├── saguaro.zig.zon
│       │   │   ├── saguaro_upper.zig.zon
│       │   │   ├── upper
│       │   │   │   ├── 0.blp
│       │   │   │   ├── 1.blp
│       │   │   │   └── 2.blp
│       │   │   ├── young
│       │   │   │   ├── 2_tall.blp
│       │   │   │   ├── 3_tall.blp
│       │   │   │   ├── 4_tall.blp
│       │   │   │   ├── 5_tall.blp
│       │   │   │   └── 5_tall_1.blp
│       │   │   └── young.zig.zon
│       │   ├── candy_cane
│       │   │   ├── large
│       │   │   │   ├── stem
│       │   │   │   │   ├── 10.blp
│       │   │   │   │   ├── 11.blp
│       │   │   │   │   ├── 12.blp
│       │   │   │   │   ├── 13.blp
│       │   │   │   │   ├── 8.blp
│       │   │   │   │   └── 9.blp
│       │   │   │   ├── top
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   └── 2.blp
│       │   │   │   └── top.zig.zon
│       │   │   ├── large.zig.zon
│       │   │   ├── thick
│       │   │   │   ├── stem
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   ├── 5.blp
│       │   │   │   │   ├── 6.blp
│       │   │   │   │   ├── 7.blp
│       │   │   │   │   ├── 8.blp
│       │   │   │   │   └── 9.blp
│       │   │   │   ├── top
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   └── 1.blp
│       │   │   │   └── top.zig.zon
│       │   │   ├── thick.zig.zon
│       │   │   └── thin
│       │   │       ├── big.zig.zon
│       │   │       ├── small.zig.zon
│       │   │       ├── stem
│       │   │       │   ├── 2.blp
│       │   │       │   ├── 3.blp
│       │   │       │   ├── 4.blp
│       │   │       │   ├── 5.blp
│       │   │       │   ├── 6.blp
│       │   │       │   └── 7.blp
│       │   │       └── top
│       │   │           ├── big.blp
│       │   │           ├── big.zig.zon
│       │   │           ├── small.blp
│       │   │           └── small.zig.zon
│       │   ├── cave
│       │   │   ├── lava_spout
│       │   │   │   ├── 0.blp
│       │   │   │   ├── 1.blp
│       │   │   │   ├── 2.blp
│       │   │   │   ├── 3.blp
│       │   │   │   └── 4.blp
│       │   │   └── lava_spout.zig.zon
│       │   ├── deco
│       │   │   ├── birch_leaf.blp
│       │   │   ├── birch_leaf.zig.zon
│       │   │   ├── bolete.blp
│       │   │   ├── bolete_side.blp
│       │   │   ├── ivy_side_2.blp
│       │   │   ├── ivy_side_3.blp
│       │   │   └── side.zig.zon
│       │   ├── mushroom
│       │   │   ├── big
│       │   │   │   ├── bolete
│       │   │   │   │   ├── base
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   ├── 2.blp
│       │   │   │   │   │   ├── 3.blp
│       │   │   │   │   │   └── 4.blp
│       │   │   │   │   ├── cap
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   ├── 2.blp
│       │   │   │   │   │   ├── 3.blp
│       │   │   │   │   │   └── 4.blp
│       │   │   │   │   └── cap.zig.zon
│       │   │   │   ├── bolete.zig.zon
│       │   │   │   ├── glimmergill
│       │   │   │   │   ├── base
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   ├── 2.blp
│       │   │   │   │   │   └── 3.blp
│       │   │   │   │   ├── cap
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   ├── 2.blp
│       │   │   │   │   │   ├── 3.blp
│       │   │   │   │   │   ├── 4.blp
│       │   │   │   │   │   ├── 5.blp
│       │   │   │   │   │   └── 6.blp
│       │   │   │   │   └── cap.zig.zon
│       │   │   │   ├── glimmergill.zig.zon
│       │   │   │   ├── toadstool
│       │   │   │   │   ├── base
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   ├── 2.blp
│       │   │   │   │   │   ├── 3.blp
│       │   │   │   │   │   ├── 4.blp
│       │   │   │   │   │   └── 5.blp
│       │   │   │   │   ├── branch
│       │   │   │   │   │   ├── blue
│       │   │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   │   └── 1.blp
│       │   │   │   │   │   ├── blue.zig.zon
│       │   │   │   │   │   ├── green
│       │   │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   │   └── 1.blp
│       │   │   │   │   │   ├── green.zig.zon
│       │   │   │   │   │   ├── red
│       │   │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   │   └── 1.blp
│       │   │   │   │   │   └── red.zig.zon
│       │   │   │   │   ├── large_cap
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   ├── 2.blp
│       │   │   │   │   │   ├── 3.blp
│       │   │   │   │   │   └── 4.blp
│       │   │   │   │   ├── large_cap.zig.zon
│       │   │   │   │   ├── small_cap
│       │   │   │   │   │   ├── 0.blp
│       │   │   │   │   │   ├── 1.blp
│       │   │   │   │   │   └── 2.blp
│       │   │   │   │   └── small_cap.zig.zon
│       │   │   │   └── toadstool.zig.zon
│       │   │   ├── side
│       │   │   │   ├── bolete.blp
│       │   │   │   └── bolete.zig.zon
│       │   │   └── small
│       │   │       ├── bolete
│       │   │       │   └── variant
│       │   │       │       ├── 0.blp
│       │   │       │       ├── 1.blp
│       │   │       │       ├── 2.blp
│       │   │       │       ├── 3.blp
│       │   │       │       ├── 4.blp
│       │   │       │       ├── 5.blp
│       │   │       │       ├── 6.blp
│       │   │       │       └── 7.blp
│       │   │       ├── bolete.zig.zon
│       │   │       ├── glimmergill
│       │   │       │   └── variant
│       │   │       │       ├── 0.blp
│       │   │       │       ├── 1.blp
│       │   │       │       ├── 2.blp
│       │   │       │       ├── 3.blp
│       │   │       │       ├── 4.blp
│       │   │       │       ├── 5.blp
│       │   │       │       ├── 6.blp
│       │   │       │       └── 7.blp
│       │   │       ├── glimmergill.zig.zon
│       │   │       ├── toadstool
│       │   │       │   └── variant
│       │   │       │       ├── 0.blp
│       │   │       │       ├── 1.blp
│       │   │       │       ├── 2.blp
│       │   │       │       ├── 3.blp
│       │   │       │       ├── 4.blp
│       │   │       │       ├── 5.blp
│       │   │       │       ├── 6.blp
│       │   │       │       ├── 7.blp
│       │   │       │       ├── 8.blp
│       │   │       │       └── 9.blp
│       │   │       └── toadstool.zig.zon
│       │   ├── phantasmal
│       │   │   ├── auroras
│       │   │   │   ├── high
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   ├── 5.blp
│       │   │   │   │   ├── 6.blp
│       │   │   │   │   ├── 7.blp
│       │   │   │   │   ├── 8.blp
│       │   │   │   │   ├── broken_0.blp
│       │   │   │   │   ├── broken_1.blp
│       │   │   │   │   └── broken_2.blp
│       │   │   │   ├── high.zig.zon
│       │   │   │   ├── low
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   ├── 5.blp
│       │   │   │   │   ├── 6.blp
│       │   │   │   │   ├── 7.blp
│       │   │   │   │   ├── 8.blp
│       │   │   │   │   ├── 9.blp
│       │   │   │   │   ├── broken_0.blp
│       │   │   │   │   ├── broken_1.blp
│       │   │   │   │   └── broken_2.blp
│       │   │   │   └── low.zig.zon
│       │   │   ├── base
│       │   │   │   ├── large
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   └── 2.blp
│       │   │   │   ├── medium
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   └── 3.blp
│       │   │   │   └── small
│       │   │   │       ├── 0.blp
│       │   │   │       ├── 1.blp
│       │   │   │       ├── 2.blp
│       │   │   │       ├── 3.blp
│       │   │   │       ├── 4.blp
│       │   │   │       └── 5.blp
│       │   │   ├── bubble
│       │   │   │   ├── 0.blp
│       │   │   │   ├── 1.blp
│       │   │   │   ├── 2.blp
│       │   │   │   ├── 3.blp
│       │   │   │   ├── 4.blp
│       │   │   │   ├── 5.blp
│       │   │   │   ├── abandoned.blp
│       │   │   │   ├── broken_0.blp
│       │   │   │   ├── broken_1.blp
│       │   │   │   ├── broken_2.blp
│       │   │   │   ├── bubble.zig.zon
│       │   │   │   └── red.blp
│       │   │   ├── phantasmal_pillars.zig.zon
│       │   │   ├── pillar
│       │   │   │   ├── large
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   └── large.zig.zon
│       │   │   │   ├── medium
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   ├── 5.blp
│       │   │   │   │   ├── 6.blp
│       │   │   │   │   └── medium.zig.zon
│       │   │   │   ├── offshoot
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 10.blp
│       │   │   │   │   ├── 11.blp
│       │   │   │   │   ├── 12.blp
│       │   │   │   │   ├── 13.blp
│       │   │   │   │   ├── 14.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   ├── 5.blp
│       │   │   │   │   ├── 6.blp
│       │   │   │   │   ├── 7.blp
│       │   │   │   │   ├── 8.blp
│       │   │   │   │   ├── 9.blp
│       │   │   │   │   └── offshoot.zig.zon
│       │   │   │   ├── small
│       │   │   │   │   ├── 0.blp
│       │   │   │   │   ├── 1.blp
│       │   │   │   │   ├── 2.blp
│       │   │   │   │   ├── 3.blp
│       │   │   │   │   ├── 4.blp
│       │   │   │   │   ├── 5.blp
│       │   │   │   │   ├── 6.blp
│       │   │   │   │   ├── 7.blp
│       │   │   │   │   ├── 8.blp
│       │   │   │   │   ├── 9.blp
│       │   │   │   │   └── small.zig.zon
│       │   │   │   └── top
│       │   │   │       ├── 0.blp
│       │   │   │       ├── 1.blp
│       │   │   │       ├── 10.blp
│       │   │   │       ├── 11.blp
│       │   │   │       ├── 12.blp
│       │   │   │       ├── 2.blp
│       │   │   │       ├── 3.blp
│       │   │   │       ├── 4.blp
│       │   │   │       ├── 5.blp
│       │   │   │       ├── 6.blp
│       │   │   │       ├── 7.blp
│       │   │   │       ├── 8.blp
│       │   │   │       ├── 9.blp
│       │   │   │       └── top.zig.zon
│       │   │   └── star
│       │   │       ├── 0.blp
│       │   │       ├── 1.blp
│       │   │       ├── 2.blp
│       │   │       ├── 3.blp
│       │   │       ├── 4.blp
│       │   │       ├── 5.blp
│       │   │       ├── 6.blp
│       │   │       ├── 7.blp
│       │   │       ├── 8.blp
│       │   │       ├── blood_star.blp
│       │   │       ├── broken_0.blp
│       │   │       ├── broken_1.blp
│       │   │       ├── broken_2.blp
│       │   │       └── stars.zig.zon
│       │   ├── rare
│       │   │   ├── snow_snale
│       │   │   │   ├── baby.blp
│       │   │   │   ├── large.blp
│       │   │   │   ├── medium.blp
│       │   │   │   ├── shelled.blp
│       │   │   │   └── small
│       │   │   │       ├── 0.blp
│       │   │   │       └── 1.blp
│       │   │   └── snow_snale.zig.zon
│       │   ├── rock
│       │   │   └── hoodoo
│       │   │       ├── large
│       │   │       │   ├── 0.blp
│       │   │       │   ├── 1.blp
│       │   │       │   └── 2.blp
│       │   │       ├── large.zig.zon
│       │   │       ├── medium
│       │   │       │   ├── 0.blp
│       │   │       │   ├── 1.blp
│       │   │       │   ├── 2.blp
│       │   │       │   ├── 3.blp
│       │   │       │   ├── 4.blp
│       │   │       │   └── 5.blp
│       │   │       ├── small
│       │   │       │   └── 0.blp
│       │   │       └── small_medium.zig.zon
│       │   └── tree
│       │       ├── baobab
│       │       │   ├── grandidieri
│       │       │   │   ├── branch
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   ├── 1.blp
│       │       │   │   │   ├── 2.blp
│       │       │   │   │   └── 3.blp
│       │       │   │   ├── branch.zig.zon
│       │       │   │   ├── leaves
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   └── 1.blp
│       │       │   │   ├── leaves.zig.zon
│       │       │   │   ├── roots
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   └── 1.blp
│       │       │   │   ├── roots.zig.zon
│       │       │   │   └── trunk
│       │       │   │       ├── 0.blp
│       │       │   │       ├── 1.blp
│       │       │   │       ├── 2.blp
│       │       │   │       └── 3.blp
│       │       │   ├── grandidieri.zig.zon
│       │       │   ├── young
│       │       │   │   ├── leaves
│       │       │   │   │   ├── side
│       │       │   │   │   │   ├── 0.blp
│       │       │   │   │   │   ├── 1.blp
│       │       │   │   │   │   ├── 2.blp
│       │       │   │   │   │   └── 3.blp
│       │       │   │   │   ├── side.zig.zon
│       │       │   │   │   ├── top
│       │       │   │   │   │   ├── 0.blp
│       │       │   │   │   │   ├── 1.blp
│       │       │   │   │   │   └── 2.blp
│       │       │   │   │   └── top.zig.zon
│       │       │   │   └── trunk
│       │       │   │       ├── 0.blp
│       │       │   │       ├── 1.blp
│       │       │   │       ├── 2.blp
│       │       │   │       └── 3.blp
│       │       │   └── young.zig.zon
│       │       ├── birch
│       │       │   ├── branch
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── 3.blp
│       │       │   ├── leaf
│       │       │   │   └── 1.blp
│       │       │   ├── root
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── 3.blp
│       │       │   ├── silver
│       │       │   │   ├── 1.zig.zon
│       │       │   │   ├── 2.zig.zon
│       │       │   │   ├── branch.zig.zon
│       │       │   │   ├── leaf.zig.zon
│       │       │   │   ├── mixed_branch.zig.zon
│       │       │   │   ├── root.zig.zon
│       │       │   │   ├── small_branch.zig.zon
│       │       │   │   ├── stub.zig.zon
│       │       │   │   └── top.zig.zon
│       │       │   ├── small_branch
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── 3.blp
│       │       │   ├── stub
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   ├── 3.blp
│       │       │   │   └── 4.blp
│       │       │   ├── top
│       │       │   │   ├── 1.blp
│       │       │   │   └── 2.blp
│       │       │   └── trunk
│       │       │       ├── 1.blp
│       │       │       ├── 2.blp
│       │       │       ├── 3.blp
│       │       │       └── 4.blp
│       │       ├── coniferous
│       │       │   ├── branch
│       │       │   │   ├── lushy
│       │       │   │   │   ├── 2
│       │       │   │   │   │   └── 0.blp
│       │       │   │   │   ├── 3
│       │       │   │   │   │   └── 0.blp
│       │       │   │   │   ├── 4
│       │       │   │   │   │   └── 0.blp
│       │       │   │   │   ├── 5
│       │       │   │   │   │   └── 0.blp
│       │       │   │   │   └── 6
│       │       │   │   │       └── 0.blp
│       │       │   │   └── normal
│       │       │   │       ├── 1
│       │       │   │       │   ├── 0.blp
│       │       │   │       │   └── 1.blp
│       │       │   │       ├── 2
│       │       │   │       │   ├── 0.blp
│       │       │   │       │   ├── 1.blp
│       │       │   │       │   ├── 2.blp
│       │       │   │       │   ├── 3.blp
│       │       │   │       │   ├── 4.blp
│       │       │   │       │   └── 5.blp
│       │       │   │       ├── 3
│       │       │   │       │   ├── 0.blp
│       │       │   │       │   ├── 1.blp
│       │       │   │       │   ├── 2.blp
│       │       │   │       │   ├── 3.blp
│       │       │   │       │   ├── 4.blp
│       │       │   │       │   ├── 5.blp
│       │       │   │       │   └── 6.blp
│       │       │   │       ├── 4
│       │       │   │       │   ├── 0.blp
│       │       │   │       │   ├── 1.blp
│       │       │   │       │   ├── 2.blp
│       │       │   │       │   ├── 3.blp
│       │       │   │       │   ├── 4.blp
│       │       │   │       │   ├── 5.blp
│       │       │   │       │   └── 6.blp
│       │       │   │       ├── 5
│       │       │   │       │   ├── 0.blp
│       │       │   │       │   ├── 1.blp
│       │       │   │       │   ├── 2.blp
│       │       │   │       │   ├── 3.blp
│       │       │   │       │   └── 4.blp
│       │       │   │       ├── 6
│       │       │   │       │   ├── 0.blp
│       │       │   │       │   ├── 1.blp
│       │       │   │       │   ├── 2.blp
│       │       │   │       │   ├── 3.blp
│       │       │   │       │   ├── 4.blp
│       │       │   │       │   └── 5.blp
│       │       │   │       └── 7
│       │       │   │           ├── 0.blp
│       │       │   │           ├── 1.blp
│       │       │   │           ├── 2.blp
│       │       │   │           ├── 3.blp
│       │       │   │           └── 4.blp
│       │       │   ├── core.blp
│       │       │   ├── pine
│       │       │   │   ├── eastern_white
│       │       │   │   │   ├── 1_branchless_trunk.zig.zon
│       │       │   │   │   ├── 2_branched_trunk.zig.zon
│       │       │   │   │   ├── 3_tip.zig.zon
│       │       │   │   │   └── branches
│       │       │   │   │       └── normal
│       │       │   │   │           ├── 0_bottom.zig.zon
│       │       │   │   │           ├── 1_bottom_middle.zig.zon
│       │       │   │   │           ├── 2_middle.zig.zon
│       │       │   │   │           ├── 3_middle_top.zig.zon
│       │       │   │   │           └── 4_top.zig.zon
│       │       │   │   ├── eastern_white.zig.zon
│       │       │   │   ├── loblolly
│       │       │   │   │   ├── 1_branchless_trunk.zig.zon
│       │       │   │   │   ├── 2_branched_trunk.zig.zon
│       │       │   │   │   ├── 3_tip.zig.zon
│       │       │   │   │   └── branches
│       │       │   │   │       └── lushy
│       │       │   │   │           ├── 0_bottom.zig.zon
│       │       │   │   │           ├── 1_middle.zig.zon
│       │       │   │   │           └── 2_top.zig.zon
│       │       │   │   ├── loblolly.zig.zon
│       │       │   │   └── young_tree.zig.zon
│       │       │   ├── roots
│       │       │   │   ├── 0.blp
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── alone
│       │       │   │       ├── 0.blp
│       │       │   │       ├── 1.blp
│       │       │   │       ├── 2.blp
│       │       │   │       └── 3.blp
│       │       │   ├── sapling
│       │       │   │   ├── 0.blp
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   ├── 3.blp
│       │       │   │   └── 4.blp
│       │       │   ├── standalone_roots.zig.zon
│       │       │   ├── stem
│       │       │   │   ├── 3
│       │       │   │   │   └── 0.blp
│       │       │   │   ├── 5
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   ├── 1.blp
│       │       │   │   │   └── 2.blp
│       │       │   │   └── extender
│       │       │   │       ├── 0.blp
│       │       │   │       ├── 1.blp
│       │       │   │       ├── 2.blp
│       │       │   │       ├── 3.blp
│       │       │   │       ├── 4.blp
│       │       │   │       └── 5.blp
│       │       │   ├── tip
│       │       │   │   ├── 4
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   ├── 1.blp
│       │       │   │   │   ├── 2.blp
│       │       │   │   │   └── 3.blp
│       │       │   │   ├── 5
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   ├── 1.blp
│       │       │   │   │   └── 2.blp
│       │       │   │   └── 6
│       │       │   │       ├── 0.blp
│       │       │   │       └── 1.blp
│       │       │   └── tree_roots.zig.zon
│       │       ├── curl
│       │       │   ├── base
│       │       │   │   ├── 0.blp
│       │       │   │   └── 1.blp
│       │       │   ├── curl
│       │       │   │   ├── 0.blp
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   ├── 3.blp
│       │       │   │   └── 4.blp
│       │       │   └── curl.zig.zon
│       │       ├── curl.zig.zon
│       │       ├── oak
│       │       │   ├── base
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── 3.blp
│       │       │   ├── branch
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── 3.blp
│       │       │   ├── leaf
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   └── 3.blp
│       │       │   ├── root
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   ├── 3.blp
│       │       │   │   ├── 4.blp
│       │       │   │   ├── 5.blp
│       │       │   │   └── 6.blp
│       │       │   ├── stub
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   ├── 3.blp
│       │       │   │   └── 4.blp
│       │       │   ├── trunk
│       │       │   │   ├── 1.blp
│       │       │   │   ├── 2.blp
│       │       │   │   ├── 3.blp
│       │       │   │   ├── 4.blp
│       │       │   │   ├── 5.blp
│       │       │   │   └── 6.blp
│       │       │   ├── white
│       │       │   │   ├── branch.zig.zon
│       │       │   │   ├── leaf.zig.zon
│       │       │   │   ├── root.zig.zon
│       │       │   │   ├── stub.zig.zon
│       │       │   │   └── trunk.zig.zon
│       │       │   └── white.zig.zon
│       │       ├── palm
│       │       │   ├── coconut
│       │       │   │   ├── fronds
│       │       │   │   │   ├── 0.blp
│       │       │   │   │   ├── 1.blp
│       │       │   │   │   ├── 2.blp
│       │       │   │   │   ├── 3.blp
│       │       │   │   │   └── 4.blp
│       │       │   │   ├── fronds.zig.zon
│       │       │   │   └── trunk
│       │       │   │       ├── leaning
│       │       │   │       │   ├── 10.blp
│       │       │   │       │   ├── 11.blp
│       │       │   │       │   ├── 12.blp
│       │       │   │       │   ├── 7.blp
│       │       │   │       │   ├── 8.blp
│       │       │   │       │   └── 9.blp
│       │       │   │       ├── straight
│       │       │   │       │   ├── 10.blp
│       │       │   │       │   ├── 11.blp
│       │       │   │       │   ├── 6.blp
│       │       │   │       │   ├── 6a.blp
│       │       │   │       │   ├── 7.blp
│       │       │   │       │   ├── 8.blp
│       │       │   │       │   ├── 8a.blp
│       │       │   │       │   └── 9.blp
│       │       │   │       └── tilt
│       │       │   │           ├── 10.blp
│       │       │   │           ├── 11.blp
│       │       │   │           ├── 12.blp
│       │       │   │           ├── 6.blp
│       │       │   │           ├── 6a.blp
│       │       │   │           ├── 7.blp
│       │       │   │           ├── 7a.blp
│       │       │   │           ├── 8.blp
│       │       │   │           └── 9.blp
│       │       │   └── coconut.zig.zon
│       │       └── tuften
│       │           ├── stem
│       │           │   ├── askew
│       │           │   │   ├── 10.blp
│       │           │   │   ├── 7.blp
│       │           │   │   └── 8.blp
│       │           │   ├── curvy
│       │           │   │   ├── 10.blp
│       │           │   │   ├── 7.blp
│       │           │   │   └── 8.blp
│       │           │   ├── straight
│       │           │   │   ├── 10.blp
│       │           │   │   ├── 5.blp
│       │           │   │   ├── 6.blp
│       │           │   │   ├── 7.blp
│       │           │   │   ├── 8.blp
│       │           │   │   └── 9.blp
│       │           │   └── tilt
│       │           │       ├── 10.blp
│       │           │       ├── 7.blp
│       │           │       ├── 8.blp
│       │           │       └── 9.blp
│       │           ├── tuft_canopy.zig.zon
│       │           ├── tuft_tree.zig.zon
│       │           ├── tufts
│       │           │   ├── big
│       │           │   │   ├── orange.blp
│       │           │   │   ├── pink.blp
│       │           │   │   ├── red.blp
│       │           │   │   ├── violet.blp
│       │           │   │   └── yellow.blp
│       │           │   └── small
│       │           │       ├── 0
│       │           │       │   ├── orange.blp
│       │           │       │   ├── pink.blp
│       │           │       │   ├── red.blp
│       │           │       │   ├── violet.blp
│       │           │       │   └── yellow.blp
│       │           │       └── 1
│       │           │           ├── orange.blp
│       │           │           ├── pink.blp
│       │           │           ├── red.blp
│       │           │           ├── violet.blp
│       │           │           └── yellow.blp
│       │           ├── young
│       │           │   ├── stem
│       │           │   │   ├── curvy
│       │           │   │   │   ├── 6.blp
│       │           │   │   │   └── 7.blp
│       │           │   │   ├── straight
│       │           │   │   │   ├── 4.blp
│       │           │   │   │   ├── 5.blp
│       │           │   │   │   ├── 6.blp
│       │           │   │   │   └── 7.blp
│       │           │   │   └── tilt
│       │           │   │       ├── 5.blp
│       │           │   │       ├── 6.blp
│       │           │   │       └── 7.blp
│       │           │   └── tufts
│       │           │       ├── big
│       │           │       │   ├── orange.blp
│       │           │       │   ├── pink.blp
│       │           │       │   ├── red.blp
│       │           │       │   ├── violet.blp
│       │           │       │   └── yellow.blp
│       │           │       └── small
│       │           │           ├── orange.blp
│       │           │           ├── pink.blp
│       │           │           ├── red.blp
│       │           │           ├── violet.blp
│       │           │           └── yellow.blp
│       │           ├── young_tuft_canopy.zig.zon
│       │           └── young_tuft_tree.zig.zon
│       ├── shaders
│       │   ├── animation_pre_processing.comp
│       │   ├── background
│       │   │   ├── fragment.frag
│       │   │   └── vertex.vert
│       │   ├── block_entity
│       │   │   ├── sign.frag
│       │   │   └── sign.vert
│       │   ├── block_selection_fragment.frag
│       │   ├── block_selection_vertex.vert
│       │   ├── bloom
│       │   │   ├── color_extractor_downsample.frag
│       │   │   ├── color_extractor_downsample.vert
│       │   │   ├── first_pass.frag
│       │   │   ├── first_pass.vert
│       │   │   ├── second_pass.frag
│       │   │   └── second_pass.vert
│       │   ├── chunks
│       │   │   ├── chunk_fragment.frag
│       │   │   ├── chunk_vertex.vert
│       │   │   ├── fillIndirectBuffer.comp
│       │   │   ├── occlusionTestFragment.frag
│       │   │   ├── occlusionTestVertex.vert
│       │   │   └── transparent_fragment.frag
│       │   ├── deferred_render_pass.frag
│       │   ├── deferred_render_pass.vert
│       │   ├── entity_fragment.frag
│       │   ├── entity_vertex.vert
│       │   ├── fake_reflection.frag
│       │   ├── fake_reflection.vert
│       │   ├── graphics
│       │   │   ├── Circle.frag
│       │   │   ├── Circle.vert
│       │   │   ├── Image.frag
│       │   │   ├── Image.vert
│       │   │   ├── Line.frag
│       │   │   ├── Line.vert
│       │   │   ├── Rect.frag
│       │   │   ├── Rect.vert
│       │   │   ├── RectBorder.frag
│       │   │   ├── RectBorder.vert
│       │   │   ├── Text.frag
│       │   │   ├── Text.vert
│       │   │   ├── graph.frag
│       │   │   └── graph.vert
│       │   ├── item_drop.frag
│       │   ├── item_drop.vert
│       │   ├── item_texture_post.frag
│       │   ├── item_texture_post.vert
│       │   ├── particles
│       │   │   ├── particles.frag
│       │   │   └── particles.vert
│       │   ├── skybox
│       │   │   ├── star.frag
│       │   │   └── star.vert
│       │   └── ui
│       │       ├── button.frag
│       │       ├── button.vert
│       │       ├── window_border.frag
│       │       └── window_border.vert
│       ├── star.png
│       ├── tools
│       │   ├── axe.png
│       │   ├── axe.zig.zon
│       │   ├── axe_overlay.png
│       │   ├── chisel.png
│       │   ├── chisel.zig.zon
│       │   ├── chisel_overlay.png
│       │   ├── pickaxe.png
│       │   ├── pickaxe.zig.zon
│       │   ├── pickaxe_overlay.png
│       │   ├── shover.png
│       │   ├── shover.zig.zon
│       │   ├── shover_overlay.png
│       │   ├── sickle.png
│       │   ├── sickle.zig.zon
│       │   ├── sickle_overlay.png
│       │   └── template.png
│       ├── ui
│       │   ├── box.png
│       │   ├── box_hovered.png
│       │   ├── box_pressed.png
│       │   ├── button.png
│       │   ├── button_hovered.png
│       │   ├── button_hovered_outline.png
│       │   ├── button_outline.png
│       │   ├── button_pressed.png
│       │   ├── button_pressed_outline.png
│       │   ├── checked_box.png
│       │   ├── checked_box_hovered.png
│       │   ├── checked_box_pressed.png
│       │   ├── delete_icon.png
│       │   ├── file_explorer_icon.png
│       │   ├── gamepad_cursor.png
│       │   ├── hud
│       │   │   ├── crosshair.png
│       │   │   ├── dead_heart.png
│       │   │   ├── energy.png
│       │   │   ├── half_energy.png
│       │   │   ├── half_heart.png
│       │   │   ├── half_oxygen.png
│       │   │   ├── heart.png
│       │   │   ├── hunger_bar_icon.png
│       │   │   ├── no_energy.png
│       │   │   ├── no_oxygen.png
│       │   │   └── oxygen.png
│       │   ├── inventory
│       │   │   ├── crafting_arrow.png
│       │   │   ├── crafting_icon.png
│       │   │   ├── crafting_result_slot.png
│       │   │   ├── hotbar_slot.png
│       │   │   ├── immutable_slot.png
│       │   │   └── slot.png
│       │   ├── oak_log_side.png
│       │   ├── pause_icon.png
│       │   ├── scrollbar.png
│       │   ├── slider.png
│       │   ├── text_input.png
│       │   ├── window_background.png
│       │   ├── window_close.png
│       │   ├── window_title.png
│       │   ├── window_zoom_in.png
│       │   └── window_zoom_out.png
│       ├── wordlist
│       └── world_presets
│           ├── default.zig.zon
│           ├── flat.zig.zon
│           └── structure_world.zig.zon
├── build.zig
├── build.zig.zon
├── debug_linux.sh
├── debug_windows.bat
├── docs
│   ├── CONTENT_SUGGESTIONS.md
│   ├── CONTRIBUTING.md
│   └── GAME_DESIGN_PRINCIPLES.md
├── mods
│   └── cubyz
│       └── rotation
│           ├── branch.zig
│           ├── carpet.zig
│           ├── decayable.zig
│           ├── direction.zig
│           ├── fence.zig
│           ├── hanging.zig
│           ├── log.zig
│           ├── no_rotation.zig
│           ├── ore.zig
│           ├── planar.zig
│           ├── sign.zig
│           ├── stairs.zig
│           ├── texture_pile.zig
│           └── torch.zig
├── run_linux.sh
├── run_windows.bat
├── scripts
│   ├── install_compiler_linux.sh
│   ├── install_compiler_windows.bat
│   └── make_icons_macos.sh
└── src
    ├── Inventory.zig
    ├── assets.zig
    ├── audio.zig
    ├── block_entity.zig
    ├── blocks.zig
    ├── blueprint.zig
    ├── callbacks
    │   ├── block
    │   │   ├── client
    │   │   │   ├── _list.zig
    │   │   │   └── openWindow.zig
    │   │   ├── server
    │   │   │   ├── _list.zig
    │   │   │   ├── checkSupportBlocks.zig
    │   │   │   ├── decay.zig
    │   │   │   └── replaceBlock.zig
    │   │   └── touch
    │   │       ├── _list.zig
    │   │       └── hurt.zig
    │   └── callbacks.zig
    ├── chunk.zig
    ├── entity.zig
    ├── files.zig
    ├── formatter
    │   └── format.zig
    ├── game.zig
    ├── graphics
    │   ├── Window.zig
    │   └── vulkan.zig
    ├── graphics.zig
    ├── gui
    │   ├── GuiWindow.zig
    │   ├── components
    │   │   ├── Button.zig
    │   │   ├── CheckBox.zig
    │   │   ├── ContinuousSlider.zig
    │   │   ├── DiscreteSlider.zig
    │   │   ├── HorizontalList.zig
    │   │   ├── Icon.zig
    │   │   ├── ItemSlot.zig
    │   │   ├── Label.zig
    │   │   ├── MutexComponent.zig
    │   │   ├── ScrollBar.zig
    │   │   ├── TextInput.zig
    │   │   └── VerticalList.zig
    │   ├── gamepad_cursor.zig
    │   ├── gui.zig
    │   ├── gui_component.zig
    │   └── windows
    │       ├── _windowlist.zig
    │       ├── advanced_controls.zig
    │       ├── authentication
    │       │   ├── create_account.zig
    │       │   ├── login.zig
    │       │   └── unlock.zig
    │       ├── change_name.zig
    │       ├── chat.zig
    │       ├── chest.zig
    │       ├── clipboard_deleted.zig
    │       ├── controls.zig
    │       ├── creative_inventory.zig
    │       ├── crosshair.zig
    │       ├── debug.zig
    │       ├── debug_network.zig
    │       ├── debug_network_advanced.zig
    │       ├── delete_world_confirmation.zig
    │       ├── download_controller_mappings.zig
    │       ├── energybar.zig
    │       ├── error_prompt.zig
    │       ├── gpu_performance_measuring.zig
    │       ├── graphics.zig
    │       ├── healthbar.zig
    │       ├── hotbar.zig
    │       ├── inventory.zig
    │       ├── inventory_crafting.zig
    │       ├── invite.zig
    │       ├── main.zig
    │       ├── manage_players.zig
    │       ├── multiplayer.zig
    │       ├── notification.zig
    │       ├── pause.zig
    │       ├── pause_gear.zig
    │       ├── performance_graph.zig
    │       ├── save_creation.zig
    │       ├── save_selection.zig
    │       ├── settings.zig
    │       ├── sign_editor.zig
    │       ├── social.zig
    │       ├── sound.zig
    │       └── workbench.zig
    ├── itemdrop.zig
    ├── items
    │   └── recipes.zig
    ├── items.zig
    ├── main.zig
    ├── meta.zig
    ├── migrations.zig
    ├── models.zig
    ├── network
    │   ├── authentication.zig
    │   └── protocols.zig
    ├── network.zig
    ├── particles.zig
    ├── physics.zig
    ├── random.zig
    ├── renderer
    │   ├── chunk_meshing.zig
    │   ├── lighting.zig
    │   └── mesh_storage.zig
    ├── renderer.zig
    ├── rotation.zig
    ├── server
    │   ├── BlockUpdateSystem.zig
    │   ├── Entity.zig
    │   ├── SimulationChunk.zig
    │   ├── command
    │   │   ├── _command.zig
    │   │   ├── _list.zig
    │   │   ├── clear.zig
    │   │   ├── gamemode.zig
    │   │   ├── help.zig
    │   │   ├── invite.zig
    │   │   ├── kill.zig
    │   │   ├── particles.zig
    │   │   ├── permission
    │   │   │   └── perm.zig
    │   │   ├── spawn.zig
    │   │   ├── tickspeed.zig
    │   │   ├── time.zig
    │   │   ├── tp.zig
    │   │   └── worldedit
    │   │       ├── blueprint.zig
    │   │       ├── copy.zig
    │   │       ├── deselect.zig
    │   │       ├── mask.zig
    │   │       ├── paste.zig
    │   │       ├── pos1.zig
    │   │       ├── pos2.zig
    │   │       ├── redo.zig
    │   │       ├── replace.zig
    │   │       ├── rotate.zig
    │   │       ├── set.zig
    │   │       └── undo.zig
    │   ├── permission.zig
    │   ├── server.zig
    │   ├── storage.zig
    │   ├── terrain
    │   │   ├── CaveBiomeMap.zig
    │   │   ├── CaveMap.zig
    │   │   ├── ClimateMap.zig
    │   │   ├── LightMap.zig
    │   │   ├── StructureMap.zig
    │   │   ├── SurfaceMap.zig
    │   │   ├── biomes.zig
    │   │   ├── cavebiomegen
    │   │   │   ├── RandomBiomeDistribution.zig
    │   │   │   └── _list.zig
    │   │   ├── cavegen
    │   │   │   ├── FractalCaveGenerator.zig
    │   │   │   ├── NoiseCaveGenerator.zig
    │   │   │   ├── SurfaceGenerator.zig
    │   │   │   └── _list.zig
    │   │   ├── chunkgen
    │   │   │   ├── CrystalGenerator.zig
    │   │   │   ├── OreGenerator.zig
    │   │   │   ├── StructureGenerator.zig
    │   │   │   ├── TerrainGenerator.zig
    │   │   │   └── _list.zig
    │   │   ├── climategen
    │   │   │   ├── NoiseBasedVoronoi.zig
    │   │   │   ├── SingleBiome.zig
    │   │   │   └── _list.zig
    │   │   ├── mapgen
    │   │   │   ├── MapGenV1.zig
    │   │   │   └── _list.zig
    │   │   ├── noise
    │   │   │   ├── BlueNoise.zig
    │   │   │   ├── CachedFractalNoise.zig
    │   │   │   ├── CachedFractalNoise3D.zig
    │   │   │   ├── FractalNoise.zig
    │   │   │   ├── FractalNoise1D.zig
    │   │   │   ├── FractalNoise3D.zig
    │   │   │   ├── PerlinNoise.zig
    │   │   │   ├── RandomlyWeightedFractalNoise.zig
    │   │   │   ├── ValueNoise.zig
    │   │   │   └── noise.zig
    │   │   ├── simple_structures
    │   │   │   ├── Boulder.zig
    │   │   │   ├── FallenTree.zig
    │   │   │   ├── FlowerPatch.zig
    │   │   │   ├── GroundPatch.zig
    │   │   │   ├── SbbGen.zig
    │   │   │   ├── SimpleTreeModel.zig
    │   │   │   ├── SimpleVegetation.zig
    │   │   │   ├── Stalagmite.zig
    │   │   │   └── _list.zig
    │   │   ├── structure_building_blocks.zig
    │   │   ├── structuremapgen
    │   │   │   ├── SbbEnumerationGenerator.zig
    │   │   │   ├── SimpleStructureGen.zig
    │   │   │   └── _list.zig
    │   │   └── terrain.zig
    │   └── world.zig
    ├── settings.zig
    ├── sync.zig
    ├── tag.zig
    ├── tool
    │   └── modifiers
    │       ├── _list.zig
    │       ├── bad_at.zig
    │       ├── durable.zig
    │       ├── fragile.zig
    │       ├── good_at.zig
    │       ├── heavy.zig
    │       ├── light.zig
    │       ├── powerful.zig
    │       ├── restrictions
    │       │   ├── _list.zig
    │       │   ├── always.zig
    │       │   ├── and.zig
    │       │   ├── encased.zig
    │       │   ├── not.zig
    │       │   └── or.zig
    │       ├── single_use.zig
    │       └── weak.zig
    ├── utils
    │   ├── file_monitor.zig
    │   ├── heap.zig
    │   ├── list.zig
    │   ├── version.zig
    │   └── virtual_mem.zig
    ├── utils.zig
    ├── vec.zig
    └── zon.zig

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Cubyz
Cubyz is a 3D voxel sandbox game (inspired by Minecraft).

Cubyz has a bunch of interesting/unique features such as:
- Level of Detail (→ This enables far view distances.)
- 3D Chunks (→ There is no height or depth limit.)
- Procedural Crafting (→ There are infinite possibilites for tool crafting.)

# About
Cubyz is written in <img src="https://github.com/PixelGuys/Cubyz/assets/43880493/04dc89ca-3ef2-4167-9e1a-e23f25feb67c" width="20" height="20">
[Zig](https://ziglang.org/), a rather small language with some cool features and a focus on readability.

Windows and Linux are supported. Mac is not supported, as it does not have OpenGL 4.3.

Check out the [Discord server](https://discord.gg/XtqCRRG) for more information and announcements.

There are also some devlogs on [YouTube](https://www.youtube.com/playlist?list=PLYi_o2N3ImLb3SIUpTS_AFPWe0MUTk2Lf).

### History
Until recently (the Zig rewrite was started in August 2022) Cubyz was written in Java. You can still see the code in the [Cubyz-Java](https://github.com/PixelGuys/Cubyz-Java) repository and play it using the [Java Launcher](https://github.com/PixelGuys/Cubyz-Launcher/releases). `// TODO: Move this over to a separate repository`

Originally Cubyz was created on August 22, 2018 by <img src="https://avatars.githubusercontent.com/u/39484230" width="20" height="20">[zenith391](https://github.com/zenith391) and <img src="https://avatars.githubusercontent.com/u/39484479" width="20" height="20">[ZaUserA](https://github.com/ZaUserA). Back then, it was called "Cubz".

However, both of them lost interest at some point, and now Cubyz is maintained by <img src="https://avatars.githubusercontent.com/u/43880493" width="20" height="20">[IntegratedQuantum](https://github.com/IntegratedQuantum).


# Run Cubyz
### This section is about compiling a dev version, if you just want a precompiled version, go to [releases](https://github.com/PixelGuys/Cubyz/releases)
## The Easy Way (no tools needed)
1. Download the latest [source code](https://codeload.github.com/PixelGuys/Cubyz/zip/refs/heads/master)
2. Extract the zip file
3. Go into the extraced folder and double click the `run_linux.sh` or `run_windows.bat` depending on your operating system.
4. Congratulations: You just compiled your first program!

### It doesn't work?
- If it doesn't work and keeps running for more than 10 minutes without doing anything it can help to kill and restart the process. A few people seem to experience this, and I have not found the cause. It might also help to delete the `zig-cache` folder.
- If you see an error message in the terminal, please report it in the [Issues](https://github.com/PixelGuys/Cubyz/issues) tab or on the [Discord server](https://discord.gg/XtqCRRG).
- Otherwise you can always ask for help on the Discord server. If you are unable to get it compiling on your machine, you can also ask on the Discord server and we may compile a release for you.

## The Better Way
1. Install Git
2. Clone this repository `git clone https://github.com/pixelguys/Cubyz`
3. Run `run_linux.sh` or `run_windows.bat`, if you already have Zig installed on your computer (it must be a compatible version) you can also just use `zig build run`
4. When you want to update your local version you can use `git pull`. This keeps everything in one place, avoiding repeatedly downloading the compiler on every update.

# Contributing
### Code
Check out the [Contributing Guidelines](https://github.com/PixelGuys/Cubyz/blob/master/docs/CONTRIBUTING.md)

### Gameplay Additions
Check out the [Game Design Principles](https://github.com/PixelGuys/Cubyz/blob/master/docs/GAME_DESIGN_PRINCIPLES.md)

### Textures
If you want to add new textures, make sure they fit the style of the game. It's recommended that you have baseline skills in pixel art before attempting to make textures. A great collection of tutorials can be found [here](https://lospec.com/pixel-art-tutorials)

If any of the following points are ignored, your texture will be rejected:
1. Resolution is 16 x 16
2. Lighting direction is top-left for items and blocks.
3. Keep colour palettes small. Do not use near-duplicate colours, do not use noise, filters, or brushes that create unnecessary amounts of colours. Most blocks can be textured with ~4-6 colours.
4. Reference other block textures to see how colours & contrast is used. Test your textures ingame alongside other blocks.
5. Blocks should tile smoothly. Avoid creating seams or repetitive patterns.
6. Use hue shifting conservatively. Take the material into account when choosing colours.
7. Items have full, coloured, 1-pixel outlines. It should be shaded so that the side in light (top left) is brighter, while the side in shadow (bottom right) is darker.
8. Items should have higher contrast than their block counterparts.

Your texture may be edited or replaced to ensure a consistent art style throughout the game.

For further information, ask <img src="https://avatars.githubusercontent.com/u/122191047" width="20" height="20">[careeoki](https://github.com/careeoki) on [Discord](https://discord.gg/XtqCRRG). She has made a majority of the art for Cubyz.

```

`assets/cubyz/biomes/_migrations.zig.zon`:

```zon
.{
	.{.old = "cave/void_cavern", .new = "cave/void/void_cavern"},
	.{.old = "cave/void_roots", .new = "cave/void/void_roots"},
	.{.old = "clearing", .new = "forest/clearing"},
	.{.old = "desert", .new = "desert/base"},
	.{.old = "forest", .new = "forest/base"},
	.{.old = "jungle(TODO)", .new = "jungle"},
	.{.old = "swamp", .new = "swamp/base"},
	.{.old = "taiga", .new = "taiga/base"},
	.{.old = "tundra", .new = "tundra/base"},
	.{.old = "forest/base", .new = "forest/mixed/oak_birch"},
	.{.old = "forest/clearing", .new = "forest/mixed/oak_birch_clearing"},
	.{.old = "beach", .new = "beach/warm/base"},
	.{.old = "ocean", .new = "ocean/temperate/base"},
	.{.old = "ocean_shelf", .new = "ocean/temperate/shelf"},
	.{.old = "cold_ocean", .new = "ocean/cold/base"},
	.{.old = "warm_ocean", .new = "ocean/warm/base"},
	.{.old = "prairie/dry_spell", .new = "prairie/dry_spell/base"},
	.{.old = "prairie/limestone_pit", .new = "prairie/limestone_pit/base"},
	.{.old = "rainbow_forest", .new = "rare/rainbow_forest"},
	.{.old = "modern_art", .new = "rare/modern_art"},
	.{.old = "glass_forest", .new = "rare/glass_forest"},
	.{.old = "spawn", .new = "rare/spawn"},
	.{.old = "cave/glimmergill", .new = "cave/mushroom/glimmergill"},
	.{.old = "cave/glimmergill_big", .new = "cave/mushroom/big/glimmergill"},
	.{.old = "cave/toadstool_big", .new = "cave/mushroom/big/toadstool"},
	.{.old = "cave/bolete_big", .new = "cave/mushroom/big/bolete"},
	.{.old = "flatland", .new = "development/flat"},
}

```

`assets/cubyz/biomes/autumn/dead_forest.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
	},
	.chance = 0.5,
	.minHeightLimit = 7,
	.minHeight = 30,
	.maxHeight = 50,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 10,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"0 to 1 cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.5,
			.width = 5,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/loblolly",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.02,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_top",
			.chance = 0.03,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 0,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/dead",
			.log = "cubyz:leaves/dead",
			.top = "cubyz:leaves/dead",
			.chance = 0.8,
			.type = .round,
			.height = 0,
			.height_variation = 0,
			.branched = false,
			.leafRadius = 0.775,
			.leafRadius_variation = 1,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.05,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.03,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.075,
			.type = .round,
			.height = 8,
			.height_variation = 5,
			.leafRadius = 0,
			.leafRadius_variation = 0,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:0",
			.chance = 0.01,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:1",
			.chance = 0.015,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:2",
			.chance = 0.02,
			.width = 8,
			.variation = 6,
			.density = 0.6,
			.priority = 0.3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:3",
			.chance = 0.015,
			.width = 6,
			.variation = 6,
			.density = 0.6,
			.priority = 0.4,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.035,
			.width = 8,
			.variation = 4,
			.density = 0.08,
			.priority = 0.5,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:toadstool",
			.chance = 0.03,
			.width = 8,
			.variation = 4,
			.density = 0.08,
			.priority = 0.5,
		},
	},
}

```

`assets/cubyz/biomes/autumn/forest.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
	},
	.chance = 0.5,
	.minHeightLimit = 7,
	.minHeight = 25,
	.maxHeight = 45,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 10,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.015,
			.type = .round,
			.height = 8,
			.height_variation = 5,
			.leafRadius = 0,
			.leafRadius_variation = 0,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_top",
			.chance = 0.015,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 0,
			.leafRadius_variation = 0,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/yellow",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_top",
			.chance = 0.15,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 2.5,
			.leafRadius_variation = 1.5,
			.leafElongation = 1.7,
			.deltaLeafElongation = 0.2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/red",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.15,
			.type = .round,
			.height = 8,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 1.5,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/birch",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_top",
			.chance = 0.03,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 2.5,
			.leafRadius_variation = 1.5,
			.leafElongation = 1.7,
			.deltaLeafElongation = 0.2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.015,
			.type = .round,
			.height = 8,
			.height_variation = 5,
			.leafRadius = 3.5,
			.leafRadius_variation = 1.5,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.005,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.002,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:red_leaf_pile:0",
			.chance = 0.01,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:red_leaf_pile:1",
			.chance = 0.015,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:red_leaf_pile:2",
			.chance = 0.02,
			.width = 8,
			.variation = 6,
			.density = 0.6,
			.priority = 0.3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:red_leaf_pile:3",
			.chance = 0.015,
			.width = 6,
			.variation = 6,
			.density = 0.6,
			.priority = 0.4,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:yellow_leaf_pile:0",
			.chance = 0.01,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:yellow_leaf_pile:1",
			.chance = 0.015,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:yellow_leaf_pile:2",
			.chance = 0.02,
			.width = 8,
			.variation = 6,
			.density = 0.6,
			.priority = 0.3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:yellow_leaf_pile:3",
			.chance = 0.015,
			.width = 6,
			.variation = 6,
			.density = 0.6,
			.priority = 0.4,
		},
	},
}

```

`assets/cubyz/biomes/autumn/mixed_forest.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
	},
	.chance = 0.5,
	.minHeightLimit = 7,
	.minHeight = 30,
	.maxHeight = 50,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 10,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/loblolly",
			.placeMode = .degradable,
			.chance = 0.06,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.06,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.06,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.02,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/yellow",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_top",
			.chance = 0.1,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 2.5,
			.leafRadius_variation = 1.5,
			.leafElongation = 1.7,
			.deltaLeafElongation = 0.2,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.005,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.002,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/red",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.1,
			.type = .round,
			.height = 8,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 1.5,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:red_leaf_pile",
			.chance = 0.05,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:yellow_leaf_pile",
			.chance = 0.05,
			.width = 10,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/beach/cold/base.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = 5,
	.maxHeight = 7,
	.chance = 0,

	.interpolation = .linear,

	.hills = 5,

	.music = "cubyz:tides",

	.ground_structure = .{
		"2 to 4 cubyz:gravel",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:amber_ore:cubyz:gravel",
			.chance = 0.001,
			.width = 1,
			.variation = 2,
			.depth = 1,
			.smoothness = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/beach/cold/wide.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = 5,
	.maxHeight = 7,
	.chance = 0,

	.interpolation = .linear,

	.hills = 5,

	.music = "cubyz:tides",

	.ground_structure = .{
		"2 to 4 cubyz:gravel",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:amber_ore:cubyz:gravel",
			.chance = 0.002,
			.width = 1,
			.variation = 2,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.03,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 4,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:moss:cubyz:slate/base",
			.size = 5,
			.size_variance = 4,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.07,
			.block = "cubyz:slate/cobble",
			.size = 3,
			.size_variance = 2,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.02,
			.block = "cubyz:moss:cubyz:slate/cobble",
			.size = 3,
			.size_variance = 2,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:moss:cubyz:gravel",
			.chance = 0.064,
			.width = 3,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.05,
		},
	},
}

```

`assets/cubyz/biomes/beach/warm/base.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = 5,
	.maxHeight = 7,
	.chance = 0,

	.interpolation = .linear,

	.hills = 5,

	.music = "cubyz:tides",

	.stoneBlock = "cubyz:sandstone/base",
	.ground_structure = .{
		"2 to 4 cubyz:sand",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:amber_ore:cubyz:sand",
			.chance = 0.002,
			.width = 1,
			.variation = 2,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/palm/coconut",
			.placeMode = .degradable,
			.chance = 0.0015,
		},
	},
}

```

`assets/cubyz/biomes/beach/warm/wide.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = 5,
	.maxHeight = 7,
	.chance = 0,

	.interpolation = .linear,

	.hills = 5,

	.music = "cubyz:tides",

	.stoneBlock = "cubyz:sandstone/base",
	.ground_structure = .{
		"2 to 4 cubyz:sand",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:amber_ore:cubyz:sand",
			.chance = 0.002,
			.width = 1,
			.variation = 2,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/palm/coconut",
			.placeMode = .degradable,
			.chance = 0.015,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:tussock",
			.chance = 0.07,
			.width = 4,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/bog/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 1.5,
	.fogColor = 0xb0e9d2,
}

```

`assets/cubyz/biomes/bog/base.zig.zon`:

```zon
.{
	.properties = .{
		.wet,
		.overgrown,
	},
	.minHeightLimit = 0,
	.minHeight = 4,
	.maxHeight = 4,
	.maxHeightLimit = 10,
	.minRadius = 150,
	.maxRadius = 300,
	.roughness = 1,
	.hills = 2,
	.chance = 0.8,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"1 cubyz:lush_grass",
		"4 to 5 cubyz:mud",
	},
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lush_grass_vegetation",
			.chance = 0.25,
			.width = 6,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:fern",
			.chance = 0.8,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.15,
			.width = 4,
			.variation = 2,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.04,
			.width = 6,
			.variation = 6,
			.density = 0.05,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:toadstool",
			.chance = 0.02,
			.width = 6,
			.variation = 6,
			.density = 0.05,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/willow",
			.log = "cubyz:willow_log",
			.top = "cubyz:leaves/willow",
			.chance = 0.07,
			.type = .round,
			.height = 6,
			.height_variation = 3,
			.leafRadius = 4.0,
			.leafRadius_variation = 2.5,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.125,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:mud",
			.chance = 0.2,
			.width = 5,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.04,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.02,
		},
	},
}

```

`assets/cubyz/biomes/bog/pond.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.wet,
	},
	.minHeight = -3,
	.maxHeight = -3,
	.minRadius = 16,
	.maxRadius = 28,
	.chance = 0,
	.roughness = 2,
	.hills = 3,
	.music = "cubyz:leaves",
	.ground_structure = .{
		"4 to 5 cubyz:mud",
	},
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:0",
			.chance = 0.1,
			.width = 8,
			.variation = 4,
			.density = 0.9,
			.priority = 0.2,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:1",
			.chance = 0.08,
			.width = 6,
			.variation = 3,
			.density = 0.9,
			.priority = 0.3,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:2",
			.chance = 0.05,
			.width = 5,
			.variation = 2,
			.density = 0.9,
			.priority = 0.4,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lily_pad",
			.generationMode = .water_surface,
			.chance = 0.1,
			.width = 6,
			.variation = 6,
			.density = 0.1,
			.priority = 0.4,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:clay",
			.chance = 0.1,
			.width = 6,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.3,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:bog/base",
			.chance = 25,
		},
	},
}

```

`assets/cubyz/biomes/bush_lands.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
	},
	.minHeightLimit = 7,
	.minHeight = 24,
	.maxHeight = 60,
	.smoothBeaches = true,
	.maxHeightLimit = 100,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 20,
	.hills = 10,
	.rivers = true,

	.music = "cubyz:sunrise",

	.ground_structure = .{
		"cubyz:grass",
		"2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.16,
			.type = .round,
			.height = 1,
			.height_variation = 1,
			.leafRadius = 2,
			.leafRadius_variation = 1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.016,
			.width = 12,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.8,
			.height = 1,
			.height_variation = 0,
		},
	},
}

```

`assets/cubyz/biomes/bush_mountains.zig.zon`:

```zon
.{
	.properties = .{
		.mountain,
	},
	.minHeightLimit = 7,
	.minHeight = 80,
	.maxHeight = 256,
	.smoothBeaches = true,

	.roughness = 10,
	.mountains = 100,

	.rivers = true,

	.ground_structure = .{
		"0 to 1 cubyz:grass",
		"0 to 1 cubyz:gravel",
		"0 to 1 cubyz:slate/cobble",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.16,
			.type = .round,
			.height = 4,
			.height_variation = 1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.048,
			.width = 6,
			.variation = 2,
			.depth = 3,
			.smoothness = 0.8,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:snow",
			.chance = 0.032,
			.width = 6,
			.variation = 2,
			.depth = 3,
			.smoothness = 0.8,
		},
	},
}

```

`assets/cubyz/biomes/cave/basalt.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -1000,
	.minHeight = -48250,
	.chance = 0.2,
	.fogDensity = 8,

	.stoneBlock = "cubyz:basalt/base",
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cave/lava_spout",
			.placeMode = .degradable,
			.chance = 0.06,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:basalt/base",
			.chance = 0.1,
			.size = 4,
			.size_variation = 10,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:magma",
			.chance = 0.055,
			.width = 4,
			.variation = 3,
			.depth = 3,
			.smoothness = 0.2,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:lava",
			.chance = 0.007,
			.width = 4,
			.variation = 5,
			.depth = 1,
			.smoothness = 1,
		},
	},
}

```

`assets/cubyz/biomes/cave/cave.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = 0,
	.minHeight = -48250,

	.fogDensity = 2,

	.music = "cubyz:heart-of-the-beast",

	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.064,
			.width = 5,
			.variation = 5,
			.depth = 3,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:slate/base",
			.chance = 0.048,
			.size = 3,
			.size_variation = 6,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 4,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 4,
		},
	},
}

```

`assets/cubyz/biomes/cave/crystal.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -512,
	.minHeight = -48250,

	.chance = 0.2,

	.caves = -0.1,
	.crystals = 32,

	.music = "cubyz:la_kubisa_caverna",
	.stoneBlock = "cubyz:slate/base",
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 5,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 2,
		},
	},
}

```

`assets/cubyz/biomes/cave/crystal_forest.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -512,
	.minHeight = -48250,
	.chance = 0.01,

	.caves = -0.1,
	.crystals = 32,

	.music = "cubyz:leaves",

	.stoneBlock = "cubyz:slate/base",
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.32,
			.type = .round,
			.height = 4,
			.height_variation = 2,
		},
	},
}

```

`assets/cubyz/biomes/cave/curl_forest.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -512,
	.minHeight = -48250,

	.fogDensity = 2,

	.chance = 0.01,

	.caves = -0.1,

	.music = "cubyz:heart-of-the-beast",

	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/curl",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.064,
			.width = 5,
			.variation = 5,
			.depth = 3,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 4,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 4,
		},
	},
}

```

`assets/cubyz/biomes/cave/dropoff.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -48125,
	.minHeight = -48500,
	.stoneBlock = "cubyz:slate/base",
	.fogDensity = 10,
	.fogColor = 0x272334,
	.chance = 100,

	.music = "cubyz:heart-of-the-beast",

	.structures = .{},
}

```

`assets/cubyz/biomes/cave/ice_cave.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -256,
	.minHeight = -48250,
	.chance = 0.2,
	.caves = -0.02,
	.fogDensity = 20,
	.fogColor = 0xbabfbf,
	.stoneBlock = "cubyz:glacite/base",
	.ground_structure = .{
		"cubyz:ice",
		"7 to 8 cubyz:frost",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:frost",
			.chance = 0.25,
			.width = 2,
			.variation = 5,
			.depth = 1,
			.smoothness = 1,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:ice",
			.chance = 0.5,
			.size = 2,
			.size_variation = 8,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:snow",
			.chance = 0.1,
			.width = 5,
			.variation = 3,
			.depth = 1,
			.smoothness = 0.8,
		},
	},
}

```

`assets/cubyz/biomes/cave/lava_cave.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -1500,
	.minHeight = -48250,
	.fogDensity = 20,
	.chance = 0.1,
	.fogColor = 0x51240c,
	.caves = -0.03,
	.stoneBlock = "cubyz:obsidian",
	.stripes = .{
		.{
			.direction = .{4, 1, 3},
			.block = "cubyz:magma",
			.distance = 16,
			.offset = 5,
			.width = 2,
		},
		.{
			.direction = .{2, 2.5, 3},
			.block = "cubyz:magma",
			.distance = 14,
			.offset = 6,
			.width = 1,
		},
		.{
			.direction = .{3, 4, 2},
			.block = "cubyz:magma",
			.distance = 14,
			.offset = 7,
			.width = 1,
		},
	},
	.structures = .{
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:obsidian",
			.chance = 0.48,
			.size = 4,
			.size_variation = 6,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:lava",
			.chance = 0.064,
			.width = 6,
			.variation = 5,
			.depth = 2,
			.smoothness = 1,
		},
	},
}

```

`assets/cubyz/biomes/cave/marble_cave.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -64,
	.minHeight = -512,
	.chance = 0.2,

	.fogDensity = 10,

	.stoneBlock = "cubyz:marble/base",
	.structures = .{
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:marble/base",
			.chance = 0.112,
			.size = 4,
			.size_variation = 10,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:water",
			.chance = 0.064,
			.width = 6,
			.variation = 5,
			.depth = 1,
			.smoothness = 1,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/_defaults.zig.zon`:

```zon
.{
	.isCave = true,
	.fogDensity = 2,
	.music = "cubyz:heart-of-the-beast",
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:clay",
			.chance = 0.08,
			.width = 5,
			.variation = 5,
			.depth = 3,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:slate/base",
			.chance = 0.048,
			.size = 3,
			.size_variation = 6,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 4,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 4,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/big/_defaults.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -512,
	.minHeight = -48250,
	.music = "cubyz:la_kubisa_caverna",
	.ground_structure = .{
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:clay",
			.chance = 0.3,
			.width = 5,
			.variation = 5,
			.depth = 2,
			.smoothness = 0.5,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/big/bolete.zig.zon`:

```zon
.{
	.chance = 0.04,
	.caves = -0.015,
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/big/bolete",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/small/bolete",
			.placeMode = .degradable,
			.chance = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.1,
			.width = 8,
			.variation = 4,
			.density = 0.06,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/big/glimmergill.zig.zon`:

```zon
.{
	.chance = 0.02,
	.caves = -0.02,
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/big/glimmergill",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/small/glimmergill",
			.placeMode = .degradable,
			.chance = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:glimmergill",
			.chance = 0.15,
			.width = 8,
			.variation = 4,
			.density = 0.06,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:vine/glimmer_worms",
			.generationMode = .ceiling,
			.chance = 0.4,
			.height = 9,
			.height_variation = 7,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:vine/glimmer_worms",
			.generationMode = .ceiling,
			.chance = 0.2,
			.height = 15,
			.height_variation = 8,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/big/toadstool.zig.zon`:

```zon
.{
	.chance = 0.04,
	.caves = -0.02,
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/big/toadstool",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/small/toadstool",
			.placeMode = .degradable,
			.chance = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:toadstool",
			.chance = 0.1,
			.width = 8,
			.variation = 4,
			.density = 0.06,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/glimmergill.zig.zon`:

```zon
.{
	.maxHeight = -200,
	.minHeight = -48250,
	.chance = 0.05,
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:glimmergill",
			.chance = 0.35,
			.width = 8,
			.variation = 4,
			.density = 0.06,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:vine/glimmer_worms",
			.generationMode = .ceiling,
			.chance = 0.5,
			.height = 3,
			.height_variation = 2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:vine/glimmer_worms",
			.generationMode = .ceiling,
			.chance = 0.1,
			.height = 9,
			.height_variation = 7,
		},
	},
}

```

`assets/cubyz/biomes/cave/mushroom/toadstool_bolete.zig.zon`:

```zon
.{
	.maxHeight = -64,
	.minHeight = -1000,
	.chance = 0.3,
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:toadstool",
			.chance = 0.15,
			.width = 6,
			.variation = 3,
			.density = 0.04,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.15,
			.width = 6,
			.variation = 3,
			.density = 0.04,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/cave/rare/phantasmal.zig.zon`:

```zon
.{
	.isCave = true,
	.fogDensity = 35,
	.fogColor = 0x000C14,
	.chance = 0.01,
	.maxHeight = -5000,
	.minHeight = -48250,
	.music = "cubyz:cubyz",
	.stoneBlock = "cubyz:chalk/black",

	.ground_structure = .{
		"0 to 1 cubyz:obsidian",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/phantasmal_pillars",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:glimmergill",
			.chance = 0.015,
			.width = 8,
			.variation = 4,
			.density = 0.06,
			.priority = 0.12,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.008,
			.block = "cubyz:basalt/base",
			.size = 4,
			.size_variance = 12,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/small/glimmergill",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/big/glimmergill",
			.placeMode = .degradable,
			.chance = 0.02,
		},
	},
}

```

`assets/cubyz/biomes/cave/sky.zig.zon`:

```zon
.{
	.isCave = true,
	.minHeight = 0,

	.music = "cubyz:GymnopedieNo1",

	.ground_structure = .{},
}

```

`assets/cubyz/biomes/cave/stalagmite_cave.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -256,
	.minHeight = -48250,
	.chance = 0.2,

	.fogDensity = 10,
	.fogColor = 0x57575e,

	.caves = -0.1,

	.music = "cubyz:heart-of-the-beast",

	.structures = .{
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:limestone/base",
			.chance = 0.48,
			.size = 4,
			.size_variation = 6,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:limestone/base",
			.chance = 0.08,
			.size = 8,
			.size_variation = 12,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:limestone/base",
			.chance = 0.048,
			.width = 5,
			.variation = 6,
			.depth = 3,
			.smoothness = 1,
		},
	},
}

```

`assets/cubyz/biomes/cave/stone_forest.zig.zon`:

```zon
.{
	.isCave = true,

	.chance = 0.01,
	.maxHeight = -50,
	.minHeight = -48250,
	.caves = -0.2,

	.music = "cubyz:heart-of-the-beast",

	.ground_structure = .{
		"0 to 1 cubyz:gravel",
		"cubyz:slate/base",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 5,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.chance = 0.001,
			.block = "cubyz:workbench",
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:slate/cobble",
			.log = "cubyz:slate/base",
			.top = "cubyz:slate/base",
			.chance = 0.16,
			.type = .round,
			.height = 3,
			.height_variation = 2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:slate/base",
			.log = "cubyz:slate/base",
			.top = "cubyz:slate/base",
			.chance = 0.48,
			.type = .round,
			.height = 3,
			.height_variation = 2,
		},
	},
}

```

`assets/cubyz/biomes/cave/void/rare/phantasmal/_defaults.zig.zon`:

```zon
.{
	.isCave = true,
	.fogDensity = 35,
	.fogColor = 0x000C14,
	.maxHeight = -50000,
	.music = "cubyz:cubyz",
	.stoneBlock = "cubyz:chalk/black",
	.chance = 0.01,
	.ground_structure = .{
		"0 to 1 cubyz:obsidian",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/phantasmal_pillars",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:glimmergill",
			.chance = 0.02,
			.width = 10,
			.variation = 5,
			.density = 0.07,
			.priority = 0.13,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.008,
			.block = "cubyz:basalt/base",
			.size = 4,
			.size_variance = 8,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/small/glimmergill",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/big/glimmergill",
			.placeMode = .degradable,
			.chance = 0.02,
		},
	},
}

```

`assets/cubyz/biomes/cave/void/rare/phantasmal/starlight.zig.zon`:

```zon
.{
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/star/stars",
			.chance = 0.05,
		},
	},
}

```

`assets/cubyz/biomes/cave/void/rare/phantasmal/streamer.zig.zon`:

```zon
.{
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/auroras/high",
			.chance = 0.03,
			.rotation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/auroras/low",
			.rotation = 0,
			.chance = 0.04,
		},
	},
}

```

`assets/cubyz/biomes/cave/void/void.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -48500,
	.minHeight = -50000,
	.fogDensity = 10,
	.fogColor = 0x272334,
	.chance = 1,
	.caves = 1,
	.music = "cubyz:heart-of-the-beast",

	.structures = .{},
}

```

`assets/cubyz/biomes/cave/void/void_cavern.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -50000,
	.chance = 0.1,
	.fogDensity = 10,
	.fogColor = 0x272334,
	.caves = -0.1,

	.music = "cubyz:heart-of-the-beast",
	.stoneBlock = "cubyz:voidstone/base",
}

```

`assets/cubyz/biomes/cave/void/void_crystal.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -50000,
	.fogDensity = 10,
	.fogColor = 0x272334,
	.chance = 0.01,
	.caveRadiusFactor = -1,
	.caves = 0.5,
	.crystals = 32,

	.music = "cubyz:la_kubisa_caverna",
	.stoneBlock = "cubyz:slate/base",
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 5,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 2,
		},
	},
}

```

`assets/cubyz/biomes/cave/void/void_roots.zig.zon`:

```zon
.{
	.isCave = true,
	.maxHeight = -50000,
	.fogDensity = 10,
	.fogColor = 0x272334,
	.chance = 1,
	.caveRadiusFactor = -1,
	.caves = 0.5,

	.music = "cubyz:heart-of-the-beast",

	.structures = .{
		.{
			.id = "cubyz:simple_vegetation",
			.chance = 0.0001,
			.block = "cubyz:torch",
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.chance = 0.000001,
			.block = "cubyz:workbench",
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.064,
			.width = 5,
			.variation = 5,
			.depth = 3,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:slate/base",
			.chance = 0.048,
			.size = 3,
			.size_variation = 6,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 4,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 4,
			.size_variance = 4,
		},
	},
}

```

`assets/cubyz/biomes/decorative/stone_pit.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 16,
	.chance = 0,
	.minHeight = -2000,
	.maxHeight = -1000,
	.keepOriginalTerrain = 0.99,
	.roughness = 1,
	.stoneBlock = "cubyz:slate/base",
	.parentBiomes = .{
		.{
			.id = "cubyz:grassland",
			.chance = 4,
		},
		.{
			.id = "cubyz:autumn/dead_forest",
			.chance = 12,
		},
		.{
			.id = "cubyz:autumn/mixed_forest",
			.chance = 4,
		},
		.{
			.id = "cubyz:autumn/forest",
			.chance = 6,
		},
		.{
			.id = "cubyz:rocky_grassland",
			.chance = 16,
		},
		.{
			.id = "cubyz:taiga/base",
			.chance = 6,
		},
		.{
			.id = "cubyz:forest/mixed/oak_birch",
			.chance = 6,
		},
		.{
			.id = "cubyz:forest/mixed/oak_pine",
			.chance = 6,
		},
		.{
			.id = "cubyz:forest/birch",
			.chance = 6,
		},
		.{
			.id = "cubyz:forest/thin_birch",
			.chance = 4,
		},
		.{
			.id = "cubyz:tundra/base",
			.chance = 6,
		},
		.{
			.id = "cubyz:tundra/patchy",
			.chance = 16,
		},
		.{
			.id = "cubyz:hills/temperate",
			.chance = 2,
		},
		.{
			.id = "cubyz:hills/cold",
			.chance = 2,
		},
	},
}

```

`assets/cubyz/biomes/decorative/stone_rock.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 16,
	.chance = 0,
	.minHeight = 1500,
	.maxHeight = 3000,
	.keepOriginalTerrain = 0.99,
	.roughness = 1,
	.mountains = 50,
	.hills = 20,
	.stoneBlock = "cubyz:slate/base",
	.parentBiomes = .{
		.{
			.id = "cubyz:autumn/forest",
			.chance = 2,
		},
		.{
			.id = "cubyz:autumn/mixed_forest",
			.chance = 2,
		},
		.{
			.id = "cubyz:autumn/dead_forest",
			.chance = 3,
		},
		.{
			.id = "cubyz:grassland",
			.chance = 3,
		},
		.{
			.id = "cubyz:rocky_grassland",
			.chance = 24,
		},
		.{
			.id = "cubyz:taiga/base",
			.chance = 4,
		},
		.{
			.id = "cubyz:forest/mixed/oak_birch",
			.chance = 4,
		},
		.{
			.id = "cubyz:forest/mixed/oak_pine",
			.chance = 4,
		},
		.{
			.id = "cubyz:forest/birch",
			.chance = 4,
		},
		.{
			.id = "cubyz:tundra/base",
			.chance = 12,
		},
		.{
			.id = "cubyz:tundra/patchy",
			.chance = 6,
		},
		.{
			.id = "cubyz:rare/tuften/fields",
			.chance = 3,
		},
		.{
			.id = "cubyz:hills/temperate",
			.chance = 3,
		},
		.{
			.id = "cubyz:hills/cold",
			.chance = 3,
		},
	},
}

```

`assets/cubyz/biomes/desert/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 1.5,
	.fogColor = 0xe9f2e2,
}

```

`assets/cubyz/biomes/desert/base.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
		.barren,
	},
	.chance = 1.0,
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.minRadius = 512,
	.maxRadius = 640,
	.hills = 20,
	.validPlayerSpawn = false,
	.music = "cubyz:EasternThought",
	.ground_structure = .{
		"3 to 4 cubyz:sand",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/saguaro",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/young",
			.placeMode = .degradable,
			.chance = 0.006,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:tussock",
			.chance = 0.03,
			.width = 4,
			.variation = 4,
			.density = 0.2,
			.priority = 0.1,
		},
	},
	.stoneBlock = "cubyz:sandstone/base",
}

```

`assets/cubyz/biomes/desert/hoodoos/_defaults.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
		.barren,
	},
	.fogDensity = 1.5,
	.fogColor = 0xe9f2e2,
	.stripes = .{
		.{
			.direction = .{1, 1, 6},
			.block = "cubyz:limestone/base",
			.distance = 10,
			.offset = 6,
			.width = 2,
		},
	},
}

```

`assets/cubyz/biomes/desert/hoodoos/base.zig.zon`:

```zon
.{
	.chance = 0.2,
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.minRadius = 150,
	.maxRadius = 240,
	.hills = 15,
	.validPlayerSpawn = false,
	.music = "cubyz:EasternThought",
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:rock/hoodoo/small_medium",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:rock/hoodoo/large",
			.placeMode = .degradable,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/saguaro",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/young",
			.placeMode = .degradable,
			.chance = 0.006,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:sand",
			.chance = 0.2,
			.width = 7,
			.variation = 4,
			.depth = 3,
			.smoothness = 0.4,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:tussock",
			.chance = 0.03,
			.width = 4,
			.variation = 4,
			.density = 0.2,
			.priority = 0.1,
		},
	},
	.stoneBlock = "cubyz:sandstone/base",
}

```

`assets/cubyz/biomes/desert/hoodoos/mound.zig.zon`:

```zon
.{
	.properties = .{},
	.minRadius = 32,
	.maxRadius = 48,
	.chance = 0,
	.minHeight = 1500,
	.maxHeight = 3000,
	.keepOriginalTerrain = 0.99,
	.roughness = 1,
	.mountains = 50,
	.hills = 20,
	.stoneBlock = "cubyz:sandstone/base",
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:rock/hoodoo/small_medium",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/saguaro",
			.placeMode = .degradable,
			.chance = 0.003,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/young",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:tussock",
			.chance = 0.03,
			.width = 4,
			.variation = 4,
			.density = 0.2,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:desert/hoodoos/base",
			.chance = 15,
		},
	},
}

```

`assets/cubyz/biomes/desert/hoodoos/pit.zig.zon`:

```zon
.{
	.properties = .{},
	.minRadius = 16,
	.maxRadius = 32,
	.minHeightLimit = 1,
	.chance = 0,
	.minHeight = 1,
	.maxHeight = 10,
	.rivers = false,
	.roughness = 1,
	.stoneBlock = "cubyz:sandstone/base",
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:rock/hoodoo/small_medium",
			.placeMode = .degradable,
			.chance = 0.08,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:desert/hoodoos/base",
			.chance = 12,
		},
	},
}

```

`assets/cubyz/biomes/desert/oasis/_defaults.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
	},
	.music = "cubyz:EasternThought",
	.chance = 0,
	.fogDensity = 1.5,
	.fogColor = 0xe9f2e2,
	.ground_structure = .{
		"3 to 4 cubyz:sand",
	},
	.stoneBlock = "cubyz:sandstone/base",
}

```

`assets/cubyz/biomes/desert/oasis/base.zig.zon`:

```zon
.{
	.minHeightLimit = 1,
	.minHeight = 5,
	.maxHeight = 10,
	.maxHeightLimit = 10,
	.minRadius = 60,
	.maxRadius = 80,
	.hills = 5,
	.maxSubBiomeCount = 1,
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/saguaro",
			.placeMode = .degradable,
			.chance = 0.007,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/palm/coconut",
			.placeMode = .degradable,
			.chance = 0.04,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.2,
			.width = 7,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.4,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:cactus/young",
			.placeMode = .degradable,
			.chance = 0.015,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:tussock",
			.chance = 0.05,
			.width = 4,
			.variation = 4,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.15,
			.width = 5,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:castilleja",
			.chance = 0.03,
			.width = 4,
			.variation = 4,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:cactus",
			.top = "cubyz:cactus_flower",
			.chance = 0.05,
			.type = .round,
			.height = 2,
			.height_variation = 0,
			.leafRadius = 0,
			.branched = false,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/baobab",
			.log = "cubyz:baobab_log",
			.top = "cubyz:baobab_top",
			.chance = 0.08,
			.type = .round,
			.height = 1,
			.height_variation = 1,
			.leafRadius = 2,
			.leafRadius_variation = 1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:desert/base",
			.chance = 1,
		},
	},
}

```

`assets/cubyz/biomes/desert/oasis/pond.zig.zon`:

```zon
.{
	.properties = .{
		.wet,
	},
	.validPlayerSpawn = false,
	.minHeight = -5,
	.maxHeight = -1,
	.maxHeightLimit = -1,
	.minRadius = 30,
	.maxRadius = 45,
	.hills = 5,
	.parentBiomes = .{
		.{
			.id = "cubyz:desert/oasis/base",
			.chance = 1,
		},
	},
}

```

`assets/cubyz/biomes/development/flat.zig.zon`:

```zon
.{
	.properties = .{},
	.chance = 0,
	.minHeight = 0,
	.maxHeight = 0,

	.validPlayerSpawn = true,
}

```

`assets/cubyz/biomes/ferrock_mountains.zig.zon`:

```zon
.{
	.properties = .{
		.mountain,
		.hot,
		.dry,
		.barren,
	},
	.minHeightLimit = 7,
	.minHeight = 80,
	.maxHeight = 256,
	.minRadius = 240,
	.maxRadius = 256,
	.fogDensity = 1.5,
	.fogColor = 0xe9f2e2,
	.roughness = 10,
	.mountains = 20,
	.smoothBeaches = true,
	.hills = 50,
	.validPlayerSpawn = false,
	.rivers = true,
	.stripes = .{
		.{
			.direction = .{1, 1, 5},
			.block = "cubyz:limestone/base",
			.distance = 12,
			.offset = 6,
			.width = 6,
		},
		.{
			.direction = .{1, 1, 5},
			.block = "cubyz:sandstone/base",
			.distance = 10,
			.offset = 6,
			.width = 2,
		},
	},
	.stoneBlock = "cubyz:ferrock/base",
	.structures = .{
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cactus",
			.chance = 0.08,
			.height = 1,
			.height_variation = 2,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:ferrock/base",
			.size = 2,
			.size_variance = 7,
		},
	},
}

```

`assets/cubyz/biomes/forest/birch.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 20,
	.maxHeight = 48,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 200,
	.maxRadius = 256,
	.roughness = 10,
	.hills = 12,
	.chance = 0.66,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.1,
			.width = 2,
			.variation = 9,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/birch/silver/1",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/birch/silver/2",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.005,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:trumpet_lily",
			.chance = 0.01,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.01,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.005,
			.width = 3,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/forest/bluebell_woods.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 35,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.smoothBeaches = true,
	.minRadius = 200,
	.maxRadius = 280,
	.roughness = 5,
	.hills = 2,
	.chance = 0.3,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/birch/silver/1",
			.placeMode = .degradable,
			.chance = 0.005,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/birch/silver/2",
			.placeMode = .degradable,
			.chance = 0.005,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.01,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.003,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bluebells",
			.chance = 0.35,
			.width = 6,
			.variation = 3,
			.density = 0.5,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:vetch",
			.chance = 0.2,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.2,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/forest/chopped.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeight = 22,
	.maxHeight = 40,
	.minRadius = 64,
	.maxRadius = 128,
	.roughness = 10,
	.hills = 10,
	.chance = 0,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.25,
			.width = 2,
			.variation = 9,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:oak_log",
			.chance = 0.2,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:birch_log",
			.chance = 0.1,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.005,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.002,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.007,
			.width = 3,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:toadstool",
			.chance = 0.007,
			.width = 3,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile",
			.chance = 0.1,
			.width = 4,
			.variation = 4,
			.density = 0.9,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:ivy",
			.chance = 0.05,
			.width = 6,
			.variation = 6,
			.density = 0.8,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.008,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:castilleja",
			.chance = 0.006,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:forest/mixed/oak_birch",
			.chance = 0.01,
		},
	},
}

```

`assets/cubyz/biomes/forest/mixed/oak_birch.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 10,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/birch/silver/1",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/birch/silver/2",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.005,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.002,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.008,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:castilleja",
			.chance = 0.006,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/forest/mixed/oak_birch_clearing.zig.zon`:

```zon
.{
	.chance = 0,
	.properties = .{},
	.radius = 32,
	.minHeight = 22,
	.maxHeight = 40,
	.roughness = 1,
	.hills = 5,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.005,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.05,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_log",
			.chance = 0.02,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.6,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.008,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:castilleja",
			.chance = 0.006,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:forest/mixed/oak_birch",
			.chance = 0.25,
		},
	},
}

```

`assets/cubyz/biomes/forest/mixed/oak_pine.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 45,
	.maxHeightLimit = 55,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 12,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/loblolly",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.02,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.005,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.chance = 0.002,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 3,
			.variation = 6,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.1,
			.width = 5,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.008,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bluebells",
			.chance = 0.01,
			.width = 3,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:trumpet_lily",
			.chance = 0.006,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/forest/mixed/oak_pine_clearing.zig.zon`:

```zon
.{
	.chance = 0,
	.properties = .{},
	.radius = 32,
	.minHeight = 22,
	.maxHeight = 40,
	.roughness = 1,
	.hills = 5,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.005,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.03,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.chance = 0.03,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.6,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 3,
			.variation = 6,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.1,
			.width = 5,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.008,
			.width = 6,
			.variation = 3,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:trumpet_lily",
			.chance = 0.006,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:forest/mixed/oak_pine",
			.chance = 1,
		},
	},
}

```

`assets/cubyz/biomes/forest/thin_birch.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 20,
	.maxHeight = 24,
	.maxHeightLimit = 30,
	.minRadius = 200,
	.maxRadius = 256,
	.roughness = 2,
	.hills = 2,
	.chance = 0.33,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:moss:cubyz:gravel",
			.chance = 0.05,
			.width = 2,
			.variation = 5,
			.depth = 1,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:moss:cubyz:slate/cobble",
			.chance = 0.05,
			.width = 2,
			.variation = 9,
			.depth = 1,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/birch",
			.log = "cubyz:birch_branch:0b11",
			.top = "cubyz:birch_branch:0b11",
			.chance = 0.7,
			.type = .round,
			.height = 14,
			.height_variation = 6,
			.leafRadius = 2.5,
			.leafRadius_variation = 1.5,
			.leafElongation = 1.7,
			.deltaLeafElongation = 0.2,
			.branched = false,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/birch",
			.log = "cubyz:birch_log",
			.top = "cubyz:birch_top",
			.chance = 0.1,
			.type = .round,
			.height = 10,
			.height_variation = 8,
			.leafRadius = 2.5,
			.leafRadius_variation = 1.5,
			.leafElongation = 1.7,
			.deltaLeafElongation = 0.2,
			.branched = false,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:slate/base",
			.size = 3,
			.size_variance = 5,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.25,
			.width = 15,
			.variation = 8,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:fern",
			.chance = 0.25,
			.width = 15,
			.variation = 8,
			.density = 0.1,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/glacier.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.wet,
		.barren,
	},
	.minHeightLimit = 7,
	.minHeight = 80,
	.maxHeight = 256,
	.smoothBeaches = true,
	.fogDensity = 1.5,
	.fogColor = 0xe2f2ff,
	.minRadius = 150,
	.maxRadius = 300,
	.roughness = 50,
	.mountains = 50,
	.hills = 50,

	.ground_structure = .{
		"3 to 5 cubyz:snow",
		"4 cubyz:frost",
	},
	.stoneBlock = "cubyz:frost",
}

```

`assets/cubyz/biomes/grassland.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 1,
	.hills = 5,
	.chance = 2,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.0002,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.0024,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.003,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.002,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.03,
		},
	},
}

```

`assets/cubyz/biomes/hills/_defaults.zig.zon`:

```zon
.{
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 60,
	.maxHeightLimit = 65,
	.smoothBeaches = true,
	.minRadius = 128,
	.maxRadius = 256,
	.roughness = 1,
	.hills = 20,
	.chance = 0.6,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.003,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.003,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.002,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/hills/cold.zig.zon`:

```zon
.{
	.properties = .{.cold},
	.ground_structure = .{
		"cubyz:cold_grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.007,
		},
	},
}

```

`assets/cubyz/biomes/hills/huge/_defaults.zig.zon`:

```zon
.{
	.minHeightLimit = 50,
	.minHeight = 60,
	.maxHeight = 130,
	.maxHeightLimit = 150,
	.smoothBeaches = true,
	.minRadius = 128,
	.maxRadius = 220,
	.roughness = 3,
	.hills = 60,
	.mountains = 40,
	.soilCreep = 1.5,
	.chance = 0.2,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.02,
			.width = 5,
			.variation = 5,
			.depth = 3,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.005,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.003,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.002,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/hills/huge/cold.zig.zon`:

```zon
.{
	.properties = .{.cold},
	.ground_structure = .{
		"cubyz:cold_grass",
		"cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.015,
			.block = "cubyz:slate/base",
			.size = 3,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:pebbles:cubyz:cold_grass",
			.chance = 0.02,
			.width = 4,
			.variation = 3,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:slate/base",
			.chance = 0.015,
			.width = 8,
			.variation = 4,
			.depth = 3,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.008,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.004,
		},
	},
}

```

`assets/cubyz/biomes/hills/huge/temperate.zig.zon`:

```zon
.{
	.properties = .{},
	.ground_structure = .{
		"cubyz:grass",
		"cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.01,
			.width = 7,
			.variation = 3,
			.depth = 3,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:pebbles:cubyz:grass",
			.chance = 0.015,
			.width = 3,
			.variation = 3,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.008,
		},
	},
}

```

`assets/cubyz/biomes/hills/large/_defaults.zig.zon`:

```zon
.{
	.minHeightLimit = 16,
	.minHeight = 30,
	.maxHeight = 90,
	.maxHeightLimit = 100,
	.smoothBeaches = true,
	.minRadius = 128,
	.maxRadius = 256,
	.roughness = 3,
	.hills = 40,
	.mountains = 10,
	.soilCreep = 1.5,
	.chance = 0.4,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.005,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.003,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.002,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/hills/large/cold.zig.zon`:

```zon
.{
	.properties = .{.cold},
	.ground_structure = .{
		"cubyz:cold_grass",
		"cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.008,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.004,
		},
	},
}

```

`assets/cubyz/biomes/hills/large/temperate.zig.zon`:

```zon
.{
	.properties = .{},
	.ground_structure = .{
		"cubyz:grass",
		"cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.008,
		},
	},
}

```

`assets/cubyz/biomes/hills/temperate.zig.zon`:

```zon
.{
	.properties = .{},
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.01,
		},
	},
}

```

`assets/cubyz/biomes/island.zig.zon`:

```zon
.{
	.chance = 0,
	.properties = .{
		.ocean,
	},
	.minHeight = 4,
	.maxHeight = 4,

	.music = "cubyz:sunrise",

	.radius = 24,

	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.016,
			.type = .round,
			.height = 12,
			.height_variation = 10,
			.leafRadius = 5,
			.leafRadius_variation = 6,
		},
	},

	.parentBiomes = .{
		.{
			.id = "cubyz:island_shelf",
			.chance = 1,
		},
	},
}

```

`assets/cubyz/biomes/island_shelf.zig.zon`:

```zon
.{
	.chance = 0,
	.properties = .{
		.ocean,
	},
	.minHeight = -10,
	.maxHeight = -10,

	.music = "cubyz:Sincerely",

	.radius = 64,

	.ground_structure = .{
		"3 to 4 cubyz:slate/base",
	},

	.maxSubBiomeCount = 1,

	.parentBiomes = .{
		.{
			.id = "cubyz:ocean/temperate/base",
			.chance = 1,
		},
	},
}

```

`assets/cubyz/biomes/jungle.zig.zon`:

```zon
.{
	.properties = .{
		.wet,
		.hot,
	},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.smoothBeaches = true,

	.roughness = 10,
	.hills = 10,

	.music = "cubyz:leaves",

	.validPlayerSpawn = true,

	.ground_structure = .{
		"cubyz:grass",
	},
	.stoneBlock = "cubyz:soil",

	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/mahogany",
			.log = "cubyz:mahogany_log",
			.top = "cubyz:mahogany_top",
			.chance = 0.36,
			.type = .round,
			.height = 6,
			.height_variation = 10,
			.leafRadius = 3.5,
			.leafRadius_variation = 1.5,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/mahogany",
			.log = "cubyz:mahogany_log",
			.top = "cubyz:mahogany_top",
			.chance = 0.2,
			.type = .round,
			.height = 1,
			.height_variation = 0,
			.leafRadius = 2,
			.leafRadius_variation = 2,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:soil",
			.chance = 0.04,
			.width = 4,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:hibiscus",
			.chance = 0.007,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/limestone_mountains/base.zig.zon`:

```zon
.{
	.properties = .{
		.mountain,
		.dry,
		.hot,
	},
	.minHeightLimit = 7,
	.minHeight = 64,
	.maxHeight = 256,
	.smoothBeaches = true,

	.roughness = 10,
	.mountains = 100,
	.stoneBlock = "cubyz:limestone/base",
	.ground_structure = .{
		"cubyz:dry_grass",
		"0 to 3 cubyz:dirt",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:grass",
			.chance = 0.025,
			.width = 16,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/young",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.075,
			.type = .round,
			.height = 3,
			.height_variation = 3,
		},
	},
}

```

`assets/cubyz/biomes/mountains.zig.zon`:

```zon
.{
	.properties = .{
		.mountain,
	},
	.radius = 400,
	.minHeightLimit = 7,
	.minHeight = 60,
	.maxHeight = 256,
	.smoothBeaches = true,

	.roughness = 10,
	.mountains = 100,

	.rivers = true,

	.ground_structure = .{
		"cubyz:grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.8,
			.type = .round,
			.height = 3,
			.height_variation = 3,
		},
	},
}

```

`assets/cubyz/biomes/ocean/cold/base.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.ocean,
	},
	.type = .arctic_ocean,
	.minHeight = -100,
	.maxHeight = -22,
	.maxHeightLimit = 7,
	.smoothBeaches = true,

	.radius = 500,

	.roughness = 20,
	.hills = 10,

	.music = "cubyz:under_the_water_sky",

	.ground_structure = .{
		"1 to 2 cubyz:slate/cobble",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:moss:cubyz:slate/cobble",
			.chance = 0.064,
			.width = 6,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.2,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.032,
			.width = 6,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.2,
		},
	},
	.transitionBiomes = .{
		.{
			.id = "cubyz:beach/cold/wide",
			.chance = 0.2,
			.width = 2,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:beach/cold/base",
			.chance = 1,
			.width = 1,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:ocean/cold/shelf",
			.chance = 1,
			.width = 3,
			.properties = .{.land, .inland},
		},
	},
}

```

`assets/cubyz/biomes/ocean/cold/shelf.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = -4,
	.maxHeight = 0,
	.chance = 0,

	.interpolation = .linear,

	.hills = 10,

	.music = "cubyz:tides",

	.ground_structure = .{
		"2 to 4 cubyz:gravel",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:moss:cubyz:gravel",
			.chance = 0.064,
			.width = 6,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.2,
		},
	},
}

```

`assets/cubyz/biomes/ocean/temperate/base.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = -100,
	.maxHeight = -22,
	.maxHeightLimit = 7,
	.smoothBeaches = true,

	.roughness = 15,
	.hills = 15,

	.rivers = true,

	.music = "cubyz:under_the_water_sky",

	.ground_structure = .{
		"2 to 3 cubyz:gravel",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:moss:cubyz:slate/cobble",
			.chance = 0.064,
			.width = 6,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.2,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:sand",
			.chance = 0.032,
			.width = 6,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.2,
		},
	},
	.transitionBiomes = .{
		.{
			.id = "cubyz:beach/warm/wide",
			.chance = 0.2,
			.width = 2,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:beach/warm/base",
			.chance = 1,
			.width = 1,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:ocean/temperate/shelf",
			.chance = 1,
			.width = 3,
			.properties = .{.land, .inland},
		},
	},
}

```

`assets/cubyz/biomes/ocean/temperate/shelf.zig.zon`:

```zon
.{
	.properties = .{
		.ocean,
	},
	.radius = 500,
	.minHeight = -4,
	.maxHeight = 0,
	.chance = 0,

	.interpolation = .linear,

	.hills = 10,

	.music = "cubyz:tides",

	.ground_structure = .{
		"2 to 4 cubyz:sand",
	},
}

```

`assets/cubyz/biomes/ocean/warm/base.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.ocean,
	},
	.radius = 500,
	.minHeight = -100,
	.maxHeight = -22,
	.maxHeightLimit = 7,
	.smoothBeaches = true,

	.roughness = 10,
	.hills = 20,

	.music = "cubyz:tides",

	.ground_structure = .{
		"2 to 4 cubyz:sand",
	},
	.stoneBlock = "cubyz:sandstone/base",

	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.032,
			.width = 6,
			.variation = 2,
			.depth = 2,
			.smoothness = 0.2,
		},
	},
	.transitionBiomes = .{
		.{
			.id = "cubyz:beach/warm/wide",
			.chance = 0.2,
			.width = 2,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:beach/warm/base",
			.chance = 1,
			.width = 1,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:ocean/temperate/shelf",
			.chance = 1,
			.width = 3,
			.properties = .{.land, .inland},
		},
	},
}

```

`assets/cubyz/biomes/peak.zig.zon`:

```zon
.{
	.properties = .{
		.mountain,
		.cold,
		.barren,
		.wet,
	},
	.minHeightLimit = 7,
	.minHeight = 120,
	.maxHeight = 256,
	.smoothBeaches = true,
	.fogDensity = 1.5,
	.fogColor = 0xe2f2ff,
	.mountains = 125,

	.music = "cubyz:DarkTimes",

	.soilCreep = 1.0,

	.ground_structure = .{
		"3 to 6 cubyz:snow",
		"1 to 3 cubyz:permafrost",
	},
	.stoneBlock = "cubyz:glacite/base",
	.structures = .{
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:ice",
			.chance = 0.08,
			.size = 3,
			.size_variation = 5,
		},
	},
}

```

`assets/cubyz/biomes/plateau/_defaults.zig.zon`:

```zon
.{
	.interpolation = .none,
	.interpolationWeight = 0.7,
	.keepOriginalTerrain = 0.99,
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 2000,
	.maxHeight = 2100,
	.maxHeightLimit = 80,
	.smoothBeaches = true,
	.minRadius = 48,
	.maxRadius = 96,
	.roughness = 1,
	.hills = 2,
	.chance = 0,
	.soilCreep = 1,
	.music = "cubyz:sunrise",
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.003,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.003,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.002,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/plateau/cold.zig.zon`:

```zon
.{
	.properties = .{.cold},
	.ground_structure = .{
		"cubyz:cold_grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.007,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:hills/cold",
			.chance = 0.5,
		},
		.{
			.id = "cubyz:hills/large/cold",
			.chance = 0.5,
		},
	},
}

```

`assets/cubyz/biomes/plateau/stacked/_defaults.zig.zon`:

```zon
.{
	.properties = .{},
	.keepOriginalTerrain = 0.99,
	.minHeightLimit = 60,
	.minHeight = 1800,
	.maxHeight = 2000,
	.maxHeightLimit = 100,
	.smoothBeaches = true,
	.minRadius = 16,
	.maxRadius = 40,
	.roughness = 1,
	.hills = 8,
	.chance = 0,
	.soilCreep = 1,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.003,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.003,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.002,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/plateau/stacked/cold.zig.zon`:

```zon
.{
	.properties = .{.cold},
	.ground_structure = .{
		"cubyz:cold_grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:pine_log",
			.top = "cubyz:pine_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.007,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:plateau/cold",
			.chance = 0.06,
		},
	},
}

```

`assets/cubyz/biomes/plateau/stacked/temperate.zig.zon`:

```zon
.{
	.properties = .{},
	.ground_structure = .{
		"cubyz:grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.01,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:plateau/temperate",
			.chance = 0.06,
		},
	},
}

```

`assets/cubyz/biomes/plateau/temperate.zig.zon`:

```zon
.{
	.properties = .{},
	.ground_structure = .{
		"cubyz:grass",
		"1 to 2 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.height = 6,
			.height_variation = 3,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.01,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:grassland",
			.chance = 0.5,
		},
		.{
			.id = "cubyz:rocky_grassland",
			.chance = 0.2,
		},
		.{
			.id = "cubyz:hills/temperate",
			.chance = 0.5,
		},
		.{
			.id = "cubyz:hills/large/temperate",
			.chance = 0.5,
		},
	},
}

```

`assets/cubyz/biomes/prairie/_defaults.zig.zon`:

```zon
.{
	.properties = .{.dry},
	.minHeightLimit = 7,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.roughness = 1,
	.hills = 6,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"1 cubyz:dry_grass",
		"1 to 2 cubyz:dirt",
		"3 to 4 cubyz:limestone/base",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dirt",
			.chance = 0.01,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.4,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:grass",
			.chance = 0.015,
			.width = 9,
			.variation = 7,
			.depth = 1,
			.smoothness = 0.4,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.025,
			.type = .round,
			.height = 2,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.05,
			.block = "cubyz:limestone/base",
			.size = 3,
			.size_variance = 6,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:slate/base",
			.size = 3,
			.size_variance = 4,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.15,
			.width = 6,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.4,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.06,
			.width = 6,
			.variation = 6,
			.density = 0.6,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:vetch",
			.chance = 0.005,
			.width = 3,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:marigold",
			.chance = 0.01,
			.width = 4,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.02,
			.width = 5,
			.variation = 6,
			.density = 0.7,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.04,
			.width = 5,
			.variation = 6,
			.density = 0.7,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/prairie/base.zig.zon`:

```zon
.{
	.minHeight = 40,
	.maxHeight = 50,
	.minRadius = 256,
	.maxRadius = 320,
}

```

`assets/cubyz/biomes/prairie/dry_spell/_defaults.zig.zon`:

```zon
.{
	.properties = .{
		.dry,
	},
	.chance = 0,
	.minRadius = 45,
	.maxRadius = 60,
	.minHeight = 35,
	.maxHeight = 40,
	.roughness = 1,
	.hills = 3,
	.ground_structure = .{
		"4 to 5 cubyz:limestone/base",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dirt",
			.chance = 0.5,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:limestone/base",
			.size = 3,
			.size_variance = 9,
		},
	},
}

```

`assets/cubyz/biomes/prairie/dry_spell/base.zig.zon`:

```zon
.{
	.keepOriginalTerrain = 0.5,
	.parentBiomes = .{
		.{
			.id = "cubyz:prairie/base",
			.chance = 3,
		},
	},
	.maxSubBiomeCount = 1,
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.05,
			.width = 15,
			.variation = 7,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.05,
			.block = "cubyz:leaves/dead",
			.size = 3,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:1",
			.chance = 0.05,
			.width = 4,
			.variation = 3,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:0",
			.chance = 0.06,
			.width = 4,
			.variation = 3,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.05,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.01,
			.type = .round,
			.height = 3,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.025,
			.height = 5,
			.height_variation = 1,
		},
	},
}

```

`assets/cubyz/biomes/prairie/dry_spell/dead.zig.zon`:

```zon
.{
	.minRadius = 16,
	.maxRadius = 24,
	.keepOriginalTerrain = 1,
	.parentBiomes = .{
		.{
			.id = "cubyz:prairie/dry_spell/base",
			.chance = 2,
		},
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.02,
			.block = "cubyz:leaves/dead",
			.size = 3,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:1",
			.chance = 0.02,
			.width = 4,
			.variation = 3,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dead_leaf_pile:0",
			.chance = 0.03,
			.width = 4,
			.variation = 3,
			.density = 0.6,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:air",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.01,
			.type = .round,
			.height = 3,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:fallen_tree",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_log",
			.chance = 0.025,
			.height = 5,
			.height_variation = 1,
		},
	},
}

```

`assets/cubyz/biomes/prairie/hill.zig.zon`:

```zon
.{
	.minHeight = 54,
	.maxHeight = 58,
	.minRadius = 16,
	.maxRadius = 36,
	.chance = 0,
	.keepOriginalTerrain = 0.5,
	.parentBiomes = .{
		.{
			.id = "cubyz:prairie/base",
			.chance = 5,
		},
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.004,
		},
	},
}

```

`assets/cubyz/biomes/prairie/limestone_pit/base.zig.zon`:

```zon
.{
	.properties = .{
		.dry,
		.barren,
	},
	.minRadius = 16,
	.maxRadius = 22,
	.chance = 0,
	.minHeight = 30,
	.maxHeight = 36,
	.roughness = 1,
	.hills = 10,
	.stoneBlock = "cubyz:limestone/base",
	.parentBiomes = .{
		.{
			.id = "cubyz:prairie/base",
			.chance = 3,
		},
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.5,
			.block = "cubyz:limestone/base",
			.size = 2,
			.size_variance = 9,
		},
	},
}

```

`assets/cubyz/biomes/rare/crimson_wasteland/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 5.0,
	.fogColor = 0xd4b2b2,
	.skyColor = 0xd48e92,
	.music = "cubyz:in_the_depths",
}

```

`assets/cubyz/biomes/rare/crimson_wasteland/base.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
		.barren,
	},
	.minHeightLimit = 7,
	.minHeight = 42,
	.maxHeight = 60,
	.maxHeightLimit = 65,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 1,
	.hills = 15,
	.chance = 0.01,
	.validPlayerSpawn = false,
	.stoneBlock = "cubyz:obsidian",
	.structures = .{
		.{
			.id = "cubyz:stalagmite",
			.chance = 0.016,
			.block = "cubyz:basalt/base",
			.size = 12,
			.size_variation = 10,
		},
		.{
			.id = "cubyz:stalagmite",
			.chance = 0.2,
			.block = "cubyz:basalt/base",
			.size = 3,
			.size_variation = 5,
		},
		.{
			.id = "cubyz:stalagmite",
			.chance = 0.005,
			.block = "cubyz:obsidian",
			.size = 5,
			.size_variation = 7,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/red",
			.chance = 0.5,
			.width = 8,
			.variation = 2,
			.depth = 3,
			.smoothness = 0.8,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:basalt/base",
			.chance = 0.5,
			.width = 8,
			.variation = 2,
			.depth = 3,
			.smoothness = 0.8,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/crimson",
			.chance = 1.0,
			.width = 8,
			.variation = 2,
			.depth = 3,
			.smoothness = 0.8,
		},
	},
}

```

`assets/cubyz/biomes/rare/crimson_wasteland/black_pit.zig.zon`:

```zon
.{
	.properties = .{},
	.minRadius = 16,
	.maxRadius = 24,
	.chance = 0,
	.minHeight = 5,
	.maxHeight = 10,
	.roughness = 3,
	.hills = 3,
	.stoneBlock = "cubyz:chalk/black",
	.parentBiomes = .{
		.{
			.id = "cubyz:rare/crimson_wasteland/base",
			.chance = 24,
		},
	},
}

```

`assets/cubyz/biomes/rare/crimson_wasteland/magma_rock.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeight = 84,
	.maxHeight = 85,
	.minRadius = 16,
	.maxRadius = 36,
	.roughness = 24,
	.chance = 0,
	.hills = 2,
	.interpolation = .linear,
	.stoneBlock = "cubyz:obsidian",
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:magma",
			.chance = 0.4,
			.width = 3,
			.variation = 2,
			.depth = 3,
			.smoothness = 0.8,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:rare/crimson_wasteland/base",
			.chance = 6,
		},
	},
}

```

`assets/cubyz/biomes/rare/glass_forest.zig.zon`:

```zon
.{
	.chance = 0.02,
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.smoothBeaches = true,

	.roughness = 10,
	.hills = 10,

	.music = "cubyz:mana-two-part-2",

	.validPlayerSpawn = false,

	.ground_structure = .{},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/aqua",
			.log = "cubyz:chalk/aqua",
			.top = "cubyz:chalk/aqua",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/black",
			.log = "cubyz:chalk/black",
			.top = "cubyz:chalk/black",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/blue",
			.log = "cubyz:chalk/blue",
			.top = "cubyz:chalk/blue",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/brown",
			.log = "cubyz:chalk/brown",
			.top = "cubyz:chalk/brown",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/crimson",
			.log = "cubyz:chalk/crimson",
			.top = "cubyz:chalk/crimson",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/cyan",
			.log = "cubyz:chalk/cyan",
			.top = "cubyz:chalk/cyan",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/dark_grey",
			.log = "cubyz:chalk/dark_grey",
			.top = "cubyz:chalk/dark_grey",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/green",
			.log = "cubyz:chalk/green",
			.top = "cubyz:chalk/green",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/grey",
			.log = "cubyz:chalk/grey",
			.top = "cubyz:chalk/grey",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/indigo",
			.log = "cubyz:chalk/indigo",
			.top = "cubyz:chalk/indigo",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/lime",
			.log = "cubyz:chalk/lime",
			.top = "cubyz:chalk/lime",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/magenta",
			.log = "cubyz:chalk/magenta",
			.top = "cubyz:chalk/magenta",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/orange",
			.log = "cubyz:chalk/orange",
			.top = "cubyz:chalk/orange",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/pink",
			.log = "cubyz:chalk/pink",
			.top = "cubyz:chalk/pink",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/purple",
			.log = "cubyz:chalk/purple",
			.top = "cubyz:chalk/purple",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/red",
			.log = "cubyz:chalk/red",
			.top = "cubyz:chalk/red",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/violet",
			.log = "cubyz:chalk/violet",
			.top = "cubyz:chalk/violet",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/viridian",
			.log = "cubyz:chalk/viridian",
			.top = "cubyz:chalk/viridian",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/white",
			.log = "cubyz:chalk/white",
			.top = "cubyz:chalk/white",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:glass/yellow",
			.log = "cubyz:chalk/yellow",
			.top = "cubyz:chalk/yellow",
			.chance = 0.008,
			.type = .round,
			.height = 10,
			.height_variation = 5,
			.leafRadius = 3,
			.leafRadius_variation = 3,
		},
	},
}

```

`assets/cubyz/biomes/rare/knitted/forest.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 1,
	.hills = 8,
	.chance = 0.01,
	.validPlayerSpawn = false,
	.stoneBlock = "cubyz:cloth/block/grey",
	.ground_structure = .{
		"2 to 3 cubyz:cloth/block/brown",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:cloth/block/grey",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cloth/green",
			.chance = 0.5,
			.width = 10,
			.variation = 6,
			.density = 10,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cloth/yellow",
			.chance = 0.02,
			.width = 10,
			.variation = 5,
			.density = 0.2,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/green",
			.log = "cubyz:cloth/block/brown",
			.top = "cubyz:cloth/block/brown",
			.chance = 0.03,
			.type = .round,
			.height = 6,
			.height_variation = 4,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/lime",
			.log = "cubyz:cloth/block/brown",
			.top = "cubyz:cloth/block/brown",
			.chance = 0.03,
			.type = .round,
			.height = 6,
			.height_variation = 4,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/viridian",
			.log = "cubyz:cloth/block/brown",
			.top = "cubyz:cloth/block/brown",
			.chance = 0.03,
			.type = .round,
			.height = 6,
			.height_variation = 4,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/white",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.05,
			.type = .round,
			.height = 25,
			.height_variation = 10,
			.leafRadius = 5,
			.leafRadius_variation = 2,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.15,
		},
	},
}

```

`assets/cubyz/biomes/rare/knitted/funny_pit.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 16,
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.chance = 0,
	.maxHeightLimit = 50,
	.keepOriginalTerrain = 1,
	.smoothBeaches = true,
	.roughness = 1,
	.hills = 8,
	.validPlayerSpawn = false,
	.stoneBlock = "cubyz:cloth/block/grey",
	.ground_structure = .{
		"1 cubyz:cloth/brown:0b111111",
		"5 cubyz:air",
	},
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cloth/green",
			.chance = 0.5,
			.width = 10,
			.variation = 6,
			.density = 10,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:rare/knitted/forest",
			.chance = 6,
		},
	},
}

```

`assets/cubyz/biomes/rare/knitted/mountain.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 20,
	.chance = 0,
	.minHeight = 40,
	.maxHeight = 70,
	.keepOriginalTerrain = 0,
	.roughness = 1,
	.mountains = 4,
	.hills = 20,
	.stoneBlock = "cubyz:cloth/block/grey",
	.stripes = .{
		.{
			.direction = .{1, 1, 1},
			.block = "cubyz:cloth/block/dark_grey",
			.distance = 6,
			.offset = 3,
			.width = 2,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:rare/knitted/forest",
			.chance = 8,
		},
	},
}

```

`assets/cubyz/biomes/rare/modern_art.zig.zon`:

```zon
.{
	.chance = 0.02,
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.smoothBeaches = true,

	.roughness = 10,
	.hills = 10,

	.music = "cubyz:mana-two-part-2",

	.validPlayerSpawn = false,

	.ground_structure = .{},
	.stoneBlock = "cubyz:chalk/white",
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/aqua",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/black",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/blue",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/brown",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/crimson",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/cyan",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/dark_grey",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/green",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/grey",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/indigo",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/lime",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/magenta",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/orange",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/pink",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/purple",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/red",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/violet",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/viridian",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/white",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:chalk/yellow",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},

		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/aqua",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/black",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/blue",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/brown",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/crimson",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/cyan",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/dark_grey",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/green",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/grey",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/indigo",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/lime",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/magenta",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/orange",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/pink",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/purple",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/red",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/violet",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/viridian",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/white",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:cloth/block/yellow",
			.log = "cubyz:air",
			.top = "cubyz:air",
			.chance = 0.02,
			.type = .round,
			.height = 5,
			.height_variation = 20,
			.leafRadius = 3,
			.leafRadius_variation = 1,
			.leafElongation = 0.5,
			.deltaLeafElongation = 0.15,
		},
	},
}

```

`assets/cubyz/biomes/rare/phantasmal_archipelago.zig.zon`:

```zon
.{
	.fogDensity = 3,
	.fogColor = 0x000C14,
	.properties = .{.ocean},
	.chance = 0.01,
	.minHeight = -128,
	.maxHeight = -64,
	.maxHeightLimit = -48,
	.music = "cubyz:cubyz",
	.hills = 35,
	.roughness = 55,
	.stoneBlock = "cubyz:chalk/black",
	.ground_structure = .{
		"0 to 2 cubyz:obsidian",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/phantasmal_pillars",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:glimmergill",
			.chance = 0.04,
			.width = 12,
			.variation = 6,
			.density = 0.08,
			.priority = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/small/glimmergill",
			.placeMode = .degradable,
			.chance = 0.035,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:mushroom/big/glimmergill",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:phantasmal/bubble/bubble",
			.chance = 0.05,
			.rotation = 0,
		},
	},
	.transitionBiomes = .{
		.{
			.id = "cubyz:beach/warm/wide",
			.chance = 0.2,
			.width = 2,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:beach/warm/base",
			.chance = 1,
			.width = 1,
			.properties = .{.land, .inland},
		},
		.{
			.id = "cubyz:ocean/temperate/shelf",
			.chance = 1,
			.width = 3,
			.properties = .{.land, .inland},
		},
	},
}

```

`assets/cubyz/biomes/rare/rainbow_forest.zig.zon`:

```zon
.{
	.properties = .{
		.wet,
	},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.smoothBeaches = true,

	.roughness = 10,
	.hills = 10,

	.chance = 0.01,

	.music = "cubyz:leaves",

	.validPlayerSpawn = true,

	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/oak/white",
			.placeMode = .degradable,
			.chance = 0.3,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:fog/red",
			.log = "cubyz:fog/red",
			.top = "cubyz:fog/red",
			.chance = 0.05,
			.type = .round,
			.height = 0,
			.height_variation = 3,
			.leafRadius = 16,
			.leafRadius_variation = 3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:fog/green",
			.log = "cubyz:fog/green",
			.top = "cubyz:fog/green",
			.chance = 0.05,
			.type = .round,
			.height = 0,
			.height_variation = 3,
			.leafRadius = 16,
			.leafRadius_variation = 3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:fog/blue",
			.log = "cubyz:fog/blue",
			.top = "cubyz:fog/blue",
			.chance = 0.05,
			.type = .round,
			.height = 0,
			.height_variation = 3,
			.leafRadius = 16,
			.leafRadius_variation = 3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:fog/yellow",
			.log = "cubyz:fog/yellow",
			.top = "cubyz:fog/yellow",
			.chance = 0.05,
			.type = .round,
			.height = 0,
			.height_variation = 3,
			.leafRadius = 16,
			.leafRadius_variation = 3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:fog/cyan",
			.log = "cubyz:fog/cyan",
			.top = "cubyz:fog/cyan",
			.chance = 0.05,
			.type = .round,
			.height = 0,
			.height_variation = 3,
			.leafRadius = 16,
			.leafRadius_variation = 3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:fog/magenta",
			.log = "cubyz:fog/magenta",
			.top = "cubyz:fog/magenta",
			.chance = 0.05,
			.type = .round,
			.height = 0,
			.height_variation = 3,
			.leafRadius = 16,
			.leafRadius_variation = 3,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/rare/spawn.zig.zon`:

```zon
.{
	.properties = .{},
	.chance = 0.01,
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 10,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:air",
			.top = "cubyz:oak_top",
			.chance = 0.3,
			.type = .round,
			.height = 6,
			.height_variation = 3,
			.leafRadius = 3,
			.leafRadiusVariation = 2,
			.leafElongation = 1.0,
			.deltaLeafElongation = 0.2,
			.branched = false,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.004,
			.type = .round,
			.height = 6,
			.height_variation = 3,
			.leafRadius = 3,
			.leafRadiusVariation = 2,
			.leafElongation = 1.0,
			.deltaLeafElongation = 0.2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:oak_log",
			.chance = 0.01,
			.height = 1,
			.height_variation = 2,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:slate/cobble",
			.chance = 0.0015,
			.height = 2,
			.height_variation = 15,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:slate/base",
			.chance = 0.0015,
			.height = 2,
			.height_variation = 15,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:soil",
			.chance = 0.0015,
			.height = 2,
			.height_variation = 15,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:workbench",
			.chance = 0.05,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:workbench",
			.chance = 0.004,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:torch:1",
			.chance = 0.02,
			.width = 12,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:torch:1",
			.chance = 0.002,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.5,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:slate/base",
			.chance = 0.001,
			.width = 10,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:slate/cobble",
			.chance = 0.003,
			.width = 10,
			.variation = 3,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:soil",
			.chance = 0.003,
			.width = 10,
			.variation = 3,
			.density = 0.2,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/rare/tuften/fields.zig.zon`:

```zon
.{
	.properties = .{},
	.minHeightLimit = 7,
	.minHeight = 40,
	.maxHeight = 60,
	.maxHeightLimit = 50,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 1,
	.hills = 15,
	.chance = 0.01,
	.music = "cubyz:sunrise",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:boulder",
			.chance = 0.00016,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daisies",
			.chance = 0.01,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dandelions",
			.chance = 0.01,
			.width = 6,
			.variation = 4,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/tuften/tuft_tree",
			.placeMode = .degradable,
			.chance = 0.05,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/tuften/young_tuft_tree",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
	},
}

```

`assets/cubyz/biomes/rare/winter_wonderland/_defaults.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.wet,
	},
	.roughness = 0,
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.hills = 15,
	.mountains = 8,
	.stoneBlock = "cubyz:glacite/base",
	.ground_structure = .{
		"2 to 3 cubyz:snow",
		"1 to 2 cubyz:permafrost",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:rare/snow_snale",
			.placeMode = .degradable,
			.chance = 0.004,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:ice",
			.generationMode = .water_surface,
			.chance = 0.9,
			.width = 8,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:snow",
			.size = 5,
			.size_variance = 2,
		},
	},
	.fogDensity = 1.5,
	.fogColor = 0xe2f2ff,
}

```

`assets/cubyz/biomes/rare/winter_wonderland/base.zig.zon`:

```zon
.{
	.chance = 0.01,
	.minRadius = 256,
	.maxRadius = 320,
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/large",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/thick",
			.placeMode = .degradable,
			.chance = 0.02,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/thin/small",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/thin/big",
			.placeMode = .degradable,
			.chance = 0.02,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/loblolly",
			.placeMode = .degradable,
			.chance = 0.006,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.006,
		},
	},
}

```

`assets/cubyz/biomes/rare/winter_wonderland/forest.zig.zon`:

```zon
.{
	.minRadius = 32,
	.maxRadius = 48,
	.chance = 0,
	.keepOriginalTerrain = 1,
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/large",
			.placeMode = .degradable,
			.chance = 0.08,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/thick",
			.placeMode = .degradable,
			.chance = 0.3,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/thin/small",
			.placeMode = .degradable,
			.chance = 0.4,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:candy_cane/thin/big",
			.placeMode = .degradable,
			.chance = 0.2,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:rare/winter_wonderland/base",
			.chance = 10,
		},
	},
}

```

`assets/cubyz/biomes/rare/winter_wonderland/icicles.zig.zon`:

```zon
.{
	.minRadius = 16,
	.maxRadius = 40,
	.chance = 0,
	.keepOriginalTerrain = 1,
	.ground_structure = .{
		"1 to 2 cubyz:frost",
		"1 to 2 cubyz:permafrost",
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:rare/winter_wonderland/base",
			.chance = 8,
		},
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:ice",
			.chance = 0.7,
			.width = 4,
			.variation = 5,
			.depth = 1,
			.smoothness = 1,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:ice",
			.chance = 0.9,
			.size = 4,
			.size_variation = 5,
		},
		.{
			.id = "cubyz:stalagmite",
			.block = "cubyz:ice",
			.chance = 0.7,
			.size = 8,
			.size_variation = 5,
		},
	},
}

```

`assets/cubyz/biomes/rocky_grassland.zig.zon`:

```zon
.{
	.properties = .{},
	.chance = 0.25,
	.minHeightLimit = 7,
	.minHeight = 20,
	.maxHeight = 40,
	.maxHeightLimit = 50,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.mountains = 30,

	.music = "cubyz:sunrise",

	.ground_structure = .{
		"cubyz:grass",
		"0 to 1 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.016,
			.type = .round,
			.height = 6,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/cobble",
			.size = 5,
			.size_variance = 4,
		},
	},
}

```

`assets/cubyz/biomes/savannah/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 1.5,
	.fogColor = 0xe9f2e2,
}

```

`assets/cubyz/biomes/savannah/baobab_shrublands.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
	},
	.minHeightLimit = 30,
	.minHeight = 24,
	.maxHeight = 60,
	.smoothBeaches = true,
	.maxHeightLimit = 55,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 5,
	.hills = 10,
	.rivers = true,
	.chance = 0.5,

	.music = "cubyz:EasternThought",

	.stoneBlock = "cubyz:limestone/base",

	.ground_structure = .{
		"cubyz:grass",
		"1 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/grandidieri",
			.placeMode = .degradable,
			.chance = 0.03,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/young",
			.placeMode = .degradable,
			.chance = 0.005,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.08,
			.type = .round,
			.height = 1,
			.height_variation = 1,
			.leafRadius = 1,
			.leafRadius_variation = 1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:grass_vegetation",
			.chance = 0.8,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.07,
			.width = 5,
			.variation = 8,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:marigold",
			.chance = 0.03,
			.width = 5,
			.variation = 3,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dirt",
			.chance = 0.15,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.15,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/savannah/base.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
	},
	.minHeightLimit = 7,
	.minHeight = 30,
	.maxHeight = 40,
	.maxHeightLimit = 42,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.hills = 6,
	.validPlayerSpawn = true,
	.music = "cubyz:EasternThought",
	.ground_structure = .{
		"7 to 8 cubyz:limestone/base",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dirt",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.4,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.4,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/young",
			.placeMode = .degradable,
			.chance = 0.048,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/grandidieri",
			.placeMode = .degradable,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.2,
			.width = 5,
			.variation = 8,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cactus",
			.chance = 0.02,
			.height = 1,
			.height_variation = 3,
		},
	},
	.stoneBlock = "cubyz:sandstone/base",
}

```

`assets/cubyz/biomes/savannah/butte.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
		.barren,
	},
	.minHeight = 75,
	.maxHeight = 100,
	.minRadius = 33,
	.maxRadius = 48,
	.roughness = 15,
	.chance = 0,
	.hills = 40,
	.stripes = .{
		.{
			.direction = .{1, 1, 5},
			.block = "cubyz:ferrock/base",
			.distance = 12,
			.offset = 6,
			.width = 1,
		},
		.{
			.direction = .{1, 1, 5},
			.block = "cubyz:sandstone/base",
			.distance = 10,
			.offset = 6,
			.width = 1,
		},
	},
	.stoneBlock = "cubyz:limestone/base",
	.parentBiomes = .{
		.{
			.id = "cubyz:savannah/base",
			.chance = 24,
		},
	},
}

```

`assets/cubyz/biomes/savannah/elevated.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
	},
	.minHeight = 64,
	.maxHeight = 65,
	.minRadius = 80,
	.maxRadius = 128,
	.roughness = 15,
	.chance = 0,
	.hills = 2,
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:grass",
	},
	.stoneBlock = "cubyz:limestone/base",
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.05,
			.width = 5,
			.variation = 8,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:cactus",
			.chance = 0.01,
			.height = 1,
			.height_variation = 3,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dirt",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:marigold",
			.chance = 0.03,
			.width = 5,
			.variation = 3,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/young",
			.placeMode = .degradable,
			.chance = 0.035,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/grandidieri",
			.placeMode = .degradable,
			.chance = 0.015,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:savannah/base",
			.chance = 8,
		},
	},
}

```

`assets/cubyz/biomes/savannah/grassy.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.dry,
	},
	.chance = 0,
	.keepOriginalTerrain = 0.6,
	.minHeightLimit = 7,
	.minHeight = 30,
	.maxHeight = 46,
	.maxHeightLimit = 42,
	.smoothBeaches = true,
	.minRadius = 16,
	.maxRadius = 128,
	.hills = 10,
	.validPlayerSpawn = true,
	.music = "cubyz:EasternThought",
	.ground_structure = .{
		"cubyz:dry_grass",
		"7 to 8 cubyz:limestone/base",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dirt",
			.chance = 0.1,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/young",
			.placeMode = .degradable,
			.chance = 0.048,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/baobab/grandidieri",
			.placeMode = .degradable,
			.chance = 0.002,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.5,
			.width = 5,
			.variation = 8,
			.density = 0.2,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:marigold",
			.chance = 0.03,
			.width = 5,
			.variation = 3,
			.density = 0.2,
			.priority = 0.1,
		},
	},
	.stoneBlock = "cubyz:sandstone/base",
	.parentBiomes = .{
		.{
			.id = "cubyz:savannah/base",
			.chance = 12,
		},
	},
}

```

`assets/cubyz/biomes/snowcapped_hill/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 1.5,
	.fogColor = 0xe2f2ff,
	.soilCreep = 1.0,
}

```

`assets/cubyz/biomes/snowcapped_hill/base.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.wet,
	},
	.minHeightLimit = 50,
	.minHeight = 100,
	.maxHeight = 150,
	.maxHeightLimit = 200,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 5,
	.hills = 14,
	.validPlayerSpawn = true,
	.ground_structure = .{
		"1 cubyz:cold_grass",
		"1 to 3 cubyz:permafrost",
	},
	.stoneBlock = "cubyz:glacite/base",
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/loblolly",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.005,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:snow",
			.chance = 0.02,
			.width = 7,
			.variation = 3,
			.depth = 2,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:fern",
			.chance = 0.03,
			.width = 4,
			.variation = 7,
			.density = 0.4,
			.priority = 0.3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.04,
			.block = "cubyz:glacite/base",
			.size = 3,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:trumpet_lily",
			.chance = 0.007,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bluebells",
			.chance = 0.01,
			.width = 5,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/snowcapped_hill/snowcapped_rock.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 20,
	.chance = 0,
	.minHeight = 3000,
	.maxHeight = 4500,
	.keepOriginalTerrain = 0.99,
	.roughness = 1,
	.mountains = 70,
	.hills = 20,
	.ground_structure = .{
		"2 to 4 cubyz:snow",
	},
	.stoneBlock = "cubyz:glacite/base",
	.parentBiomes = .{
		.{
			.id = "cubyz:snowcapped_hill/base",
			.chance = 20,
		},
	},
}

```

`assets/cubyz/biomes/swamp/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 2,
	.fogColor = 0xb0e9d2,
}

```

`assets/cubyz/biomes/swamp/base.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.wet,
		.overgrown,
	},
	.minHeightLimit = 0,
	.minHeight = 4,
	.maxHeight = 4,
	.maxHeightLimit = 10,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 3,
	.hills = 1,
	.chance = 1.0,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"4 to 5 cubyz:mud",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:lush_grass",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lush_grass_vegetation",
			.chance = 0.25,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:fern",
			.chance = 0.8,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.5,
			.width = 1,
			.variation = 5,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.035,
			.width = 6,
			.variation = 6,
			.density = 0.05,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:toadstool",
			.chance = 0.03,
			.width = 6,
			.variation = 6,
			.density = 0.05,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/willow",
			.log = "cubyz:willow_log",
			.top = "cubyz:leaves/willow",
			.chance = 0.8,
			.type = .round,
			.height = 4,
			.height_variation = 3,
			.leafRadius = 4.0,
			.leafRadius_variation = 2.5,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.125,
		},
	},
}

```

`assets/cubyz/biomes/swamp/clearing.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.wet,
		.overgrown,
	},
	.minHeight = 4,
	.maxHeight = 4,
	.minRadius = 32,
	.maxRadius = 48,
	.roughness = 3,
	.hills = 1,
	.chance = 0,
	.music = "cubyz:leaves",
	.validPlayerSpawn = true,
	.ground_structure = .{
		"cubyz:lush_grass",
		"4 to 5 cubyz:mud",
	},
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lush_grass_vegetation",
			.chance = 0.25,
			.width = 10,
			.variation = 6,
			.density = 0.3,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:simple_vegetation",
			.block = "cubyz:fern",
			.chance = 0.8,
			.height = 1,
			.height_variation = 0,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:daffodil",
			.chance = 0.5,
			.width = 1,
			.variation = 5,
			.density = 0.3,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:swamp/base",
			.chance = 2,
		},
	},
}

```

`assets/cubyz/biomes/swamp/pond.zig.zon`:

```zon
.{
	.properties = .{
		.hot,
		.wet,
	},
	.minHeight = -4,
	.maxHeight = -4,
	.minRadius = 32,
	.maxRadius = 48,
	.chance = 0,
	.roughness = 4,
	.hills = 3,
	.music = "cubyz:leaves",
	.ground_structure = .{
		"4 to 5 cubyz:mud",
	},
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lily_pad",
			.generationMode = .water_surface,
			.chance = 0.1,
			.width = 6,
			.variation = 6,
			.density = 0.1,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:swamp/base",
			.chance = 6,
		},
	},
}

```

`assets/cubyz/biomes/taiga/base.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
	},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 10,
	.validPlayerSpawn = true,
	.ground_structure = .{
		"0 to 1 cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/loblolly",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.005,
			.width = 8,
			.variation = 4,
			.density = 0.08,
			.priority = 0.5,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:vetch",
			.chance = 0.01,
			.width = 6,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:trumpet_lily",
			.chance = 0.007,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/taiga/cold.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.wet,
	},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.fogDensity = 1.5,
	.fogColor = 0xe2f2ff,
	.maxHeightLimit = 60,
	.smoothBeaches = true,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 10,
	.hills = 13,
	.validPlayerSpawn = true,
	.ground_structure = .{
		"1 cubyz:cold_grass",
		"1 to 3 cubyz:permafrost",
	},
	.stoneBlock = "cubyz:glacite/base",
	.structures = .{
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/eastern_white",
			.placeMode = .degradable,
			.chance = 0.15,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/pine/young_tree",
			.placeMode = .degradable,
			.chance = 0.2,
		},
		.{
			.id = "cubyz:sbb",
			.structure = "cubyz:tree/coniferous/standalone_roots",
			.placeMode = .degradable,
			.chance = 0.01,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bolete",
			.chance = 0.01,
			.width = 8,
			.variation = 4,
			.density = 0.08,
			.priority = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.02,
			.width = 5,
			.variation = 4,
			.depth = 2,
			.smoothness = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.1,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:fern",
			.chance = 0.03,
			.width = 4,
			.variation = 7,
			.density = 0.4,
			.priority = 0.3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:glacite/base",
			.size = 3,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:trumpet_lily",
			.chance = 0.007,
			.width = 8,
			.variation = 3,
			.density = 0.1,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:bluebells",
			.chance = 0.01,
			.width = 5,
			.variation = 3,
			.density = 0.4,
			.priority = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/tall_mountain/base.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 320,
	.minHeight = 128,
	.maxHeight = 128,

	.interpolation = .linear,
	.mountains = 150,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:mountains",
			.chance = 0.2,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"cubyz:slate/cobble",
	},
}

```

`assets/cubyz/biomes/tall_mountain/peak.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 60,
	.minHeight = 864,
	.maxHeight = 864,

	.interpolation = .linear,
	.mountains = 30,
	.chance = 0,

	.soilCreep = 1.5,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/slope6",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"10 to 12 cubyz:snow",
	},
}

```

`assets/cubyz/biomes/tall_mountain/slope1.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 280,
	.minHeight = 256,
	.maxHeight = 256,

	.interpolation = .linear,
	.mountains = 75,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/base",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"cubyz:slate/cobble",
	},
}

```

`assets/cubyz/biomes/tall_mountain/slope2.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 240,
	.minHeight = 384,
	.maxHeight = 384,

	.interpolation = .linear,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/slope1",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"cubyz:slate/cobble",
	},
}

```

`assets/cubyz/biomes/tall_mountain/slope3.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 200,
	.minHeight = 480,
	.maxHeight = 480,

	.interpolation = .linear,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/slope2",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"0 to 1 cubyz:snow",
		"cubyz:slate/cobble",
	},
}

```

`assets/cubyz/biomes/tall_mountain/slope4.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 160,
	.minHeight = 576,
	.maxHeight = 576,

	.interpolation = .linear,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/slope3",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"10 to 12 cubyz:snow",
	},
}

```

`assets/cubyz/biomes/tall_mountain/slope5.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 120,
	.minHeight = 672,
	.maxHeight = 672,

	.interpolation = .linear,
	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/slope4",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"10 to 12 cubyz:snow",
	},
}

```

`assets/cubyz/biomes/tall_mountain/slope6.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 90,
	.minHeight = 768,
	.maxHeight = 768,

	.interpolation = .linear,
	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:tall_mountain/slope5",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"10 to 12 cubyz:snow",
	},
}

```

`assets/cubyz/biomes/thicket.zig.zon`:

```zon
.{
	.chance = 0,
	.properties = .{
		.wet,
	},
	.radius = 32,
	.minHeight = 22,
	.maxHeight = 40,

	.roughness = 10,
	.hills = 10,

	.music = "cubyz:leaves",

	.validPlayerSpawn = true,

	.ground_structure = .{
		"cubyz:grass",
		"2 to 3 cubyz:soil",
	},
	.structures = .{
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/oak",
			.log = "cubyz:oak_log",
			.top = "cubyz:oak_top",
			.chance = 0.8,
			.type = .round,
			.height = 6,
			.height_variation = 3,
		},
	},

	.parentBiomes = .{
		.{
			.id = "cubyz:grassland",
			.chance = 0.1,
		},
	},
}

```

`assets/cubyz/biomes/tundra/base.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.dry,
	},
	.minHeightLimit = 7,
	.minHeight = 22,
	.maxHeight = 40,
	.maxHeightLimit = 60,
	.minRadius = 256,
	.maxRadius = 320,
	.roughness = 2,
	.hills = 15,
	.mountains = 20,
	.chance = 0.5,
	.ground_structure = .{
		"0 to 1 cubyz:cold_grass",
	},
	.structures = .{
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.03,
			.width = 5,
			.variation = 8,
			.density = 0.4,
			.priority = 0.1,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:cold_grass_vegetation",
			.chance = 0.04,
			.width = 5,
			.variation = 8,
			.density = 0.5,
			.priority = 0.2,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:osier",
			.chance = 0.04,
			.width = 7,
			.variation = 8,
			.density = 1,
			.priority = 0.3,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:cold_grass",
			.chance = 0.1,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.09,
			.width = 6,
			.variation = 5,
			.depth = 1,
			.smoothness = 0.5,
		},
	},
}

```

`assets/cubyz/biomes/tundra/patchy.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.barren,
		.dry,
	},
	.minRadius = 60,
	.maxRadius = 100,
	.minHeight = 20,
	.chance = 0,
	.maxHeight = 40,
	.hills = 15,
	.roughness = 15,
	.mountains = 15,
	.music = "cubyz:sunrise",
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:gravel",
			.chance = 0.25,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:dry_grass",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.008,
			.block = "cubyz:slate/base",
			.size = 5,
			.size_variance = 3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.016,
			.block = "cubyz:slate/base",
			.size = 2,
			.size_variance = 5,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.032,
			.block = "cubyz:slate/base",
			.size = 1,
			.size_variance = 6,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:dry_grass_vegetation",
			.chance = 0.025,
			.width = 5,
			.variation = 8,
			.density = 0.2,
			.priority = 0.1,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:tundra/base",
			.chance = 5,
		},
	},
}

```

`assets/cubyz/biomes/tundra/snowy/_defaults.zig.zon`:

```zon
.{
	.properties = .{
		.cold,
		.wet,
		.barren,
	},
	.roughness = 1,
	.fogDensity = 1.5,
	.fogColor = 0xe2f2ff,
	.soilCreep = 1.0,
	.validPlayerSpawn = false,
}

```

`assets/cubyz/biomes/tundra/snowy/base.zig.zon`:

```zon
.{
	.minHeightLimit = 0,
	.minHeight = 18,
	.maxHeight = 20,
	.maxHeightLimit = 30,
	.minRadius = 256,
	.maxRadius = 320,
	.hills = 15,
	.mountains = 15,
	.stoneBlock = "cubyz:glacite/base",
	.chance = 0.5,
	.ground_structure = .{
		"1 cubyz:snow",
		"1 to 2 cubyz:permafrost",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:ice",
			.generationMode = .water_surface,
			.chance = 0.9,
			.width = 8,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:permafrost",
			.chance = 0.01,
			.width = 6,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.3,
		},
		.{
			.id = "cubyz:boulder",
			.chance = 0.01,
			.block = "cubyz:snow",
			.size = 5,
			.size_variance = 2,
		},
	},
}

```

`assets/cubyz/biomes/tundra/snowy/pit.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 16,
	.chance = 0,
	.minHeight = -2000,
	.maxHeight = -1000,
	.keepOriginalTerrain = 0.99,
	.stoneBlock = "cubyz:glacite/base",
	.ground_structure = .{
		"1 cubyz:snow",
		"1 to 2 cubyz:permafrost",
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:tundra/snowy/base",
			.chance = 10,
		},
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:ice",
			.generationMode = .water_surface,
			.chance = 0.9,
			.width = 8,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
	},
}

```

`assets/cubyz/biomes/tundra/snowy/rock.zig.zon`:

```zon
.{
	.properties = .{},
	.radius = 16,
	.chance = 0,
	.minHeight = 1500,
	.maxHeight = 3000,
	.keepOriginalTerrain = 0.99,
	.mountains = 50,
	.hills = 20,
	.stoneBlock = "cubyz:glacite/base",
	.ground_structure = .{
		"1 cubyz:snow",
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:tundra/snowy/base",
			.chance = 16,
		},
	},
}

```

`assets/cubyz/biomes/volcano/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 2,
	.fogColor = 0xb4b2b2,
	.skyColor = 0x9abbe3,
}

```

`assets/cubyz/biomes/volcano/base.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 320,
	.minHeight = 128,
	.maxHeight = 128,

	.interpolation = .linear,
	.mountains = 150,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:mountains",
			.chance = 0.1,
		},
	},

	.maxSubBiomeCount = 1,

	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/peak.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 40,
	.minHeight = 600,
	.maxHeight = 600,

	.interpolation = .smooth,
	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/slope6",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"10 to 12 cubyz:lava",
		"10 to 12 cubyz:magma",
	},
	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/slope1.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 260,
	.minHeight = 256,
	.maxHeight = 256,

	.interpolation = .linear,
	.mountains = 75,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/base",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/slope2.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 220,
	.minHeight = 384,
	.maxHeight = 384,
	.mountains = 50,

	.interpolation = .linear,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/slope1",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/slope3.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 180,
	.minHeight = 480,
	.maxHeight = 480,
	.roughness = 50,
	.mountains = 50,

	.interpolation = .linear,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/slope2",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/slope4.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 140,
	.minHeight = 576,
	.maxHeight = 576,
	.roughness = 100,
	.mountains = 100,

	.interpolation = .linear,

	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/slope3",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/slope5.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 100,
	.minHeight = 672,
	.maxHeight = 672,
	.roughness = 100,
	.mountains = 50,

	.interpolation = .linear,
	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/slope4",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"0 to 10 cubyz:magma",
	},
	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/volcano/slope6.zig.zon`:

```zon
.{
	.properties = .{.mountain},
	.radius = 80,
	.minHeight = 640,
	.maxHeight = 640,
	.roughness = 20,
	.mountains = 20,

	.interpolation = .linear,
	.chance = 0,

	.music = "cubyz:out_of_breath",

	.parentBiomes = .{
		.{
			.id = "cubyz:volcano/slope5",
			.chance = 1,
		},
	},

	.maxSubBiomeCount = 1,

	.ground_structure = .{
		"10 to 12 cubyz:magma",
	},
	.stoneBlock = "cubyz:basalt/base",
}

```

`assets/cubyz/biomes/wetlands/_defaults.zig.zon`:

```zon
.{
	.fogDensity = 2,
	.fogColor = 0xb0e9d2,
}

```

`assets/cubyz/biomes/wetlands/base.zig.zon`:

```zon
.{
	.properties = .{
		.wet,
		.hot,
	},
	.minHeightLimit = 0,
	.minHeight = 1,
	.maxHeight = 1,
	.maxHeightLimit = 5,
	.roughness = 2,
	.hills = 7.5,
	.minRadius = 256,
	.maxRadius = 320,
	.music = "cubyz:sunrise",
	.ground_structure = .{
		"cubyz:lush_grass",
		"5 to 7 cubyz:mud",
	},
	.chance = 0.5,
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:mud",
			.chance = 0.33,
			.width = 5,
			.variation = 4,
			.depth = 1,
			.smoothness = 0.5,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/willow",
			.log = "cubyz:willow_log",
			.top = "cubyz:willow_top",
			.chance = 0.02,
			.type = .round,
			.height = 12,
			.height_variation = 4,
			.leafRadius = 4.0,
			.leafRadius_variation = 2.5,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.125,
			.branched = false,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/willow",
			.log = "cubyz:willow_log",
			.top = "cubyz:willow_top",
			.chance = 0.02,
			.type = .round,
			.height = 10,
			.height_variation = 2,
			.leafRadius = 4.0,
			.leafRadius_variation = 2.5,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.125,
			.branched = false,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:0",
			.chance = 0.4,
			.width = 8,
			.variation = 4,
			.density = 0.9,
			.priority = 0.2,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:1",
			.chance = 0.33,
			.width = 6,
			.variation = 3,
			.density = 0.9,
			.priority = 0.3,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:2",
			.chance = 0.2,
			.width = 5,
			.variation = 2,
			.density = 0.9,
			.priority = 0.4,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:3",
			.chance = 0.1,
			.width = 3,
			.variation = 2,
			.density = 0.9,
			.priority = 0.5,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lily_pad",
			.generationMode = .water_surface,
			.chance = 0.1,
			.width = 6,
			.variation = 6,
			.density = 0.1,
			.priority = 0.4,
		},
	},
}

```

`assets/cubyz/biomes/wetlands/willows.zig.zon`:

```zon
.{
	.properties = .{
		.wet,
		.hot,
	},
	.minHeight = -2,
	.maxHeight = -2,
	.roughness = 2,
	.chance = 0,
	.hills = 3.5,
	.minRadius = 64,
	.maxRadius = 128,
	.music = "cubyz:sunrise",
	.ground_structure = .{
		"6 to 8 cubyz:mud",
	},
	.structures = .{
		.{
			.id = "cubyz:ground_patch",
			.block = "cubyz:clay",
			.chance = 0.25,
			.width = 1,
			.variation = 6,
			.depth = 2,
			.smoothness = 0.6,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/willow",
			.log = "cubyz:willow_log",
			.top = "cubyz:willow_top",
			.chance = 0.3,
			.type = .round,
			.height = 13,
			.height_variation = 4,
			.leafRadius = 4.0,
			.leafRadius_variation = 2.5,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.125,
			.branched = false,
		},
		.{
			.id = "cubyz:simple_tree",
			.leaves = "cubyz:leaves/willow",
			.log = "cubyz:willow_log",
			.top = "cubyz:willow_top",
			.chance = 0.3,
			.type = .round,
			.height = 11,
			.height_variation = 2,
			.leafRadius = 4.0,
			.leafRadius_variation = 2.5,
			.leafElongation = 0.4,
			.deltaLeafElongation = 0.125,
			.branched = false,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:0",
			.chance = 0.3,
			.width = 8,
			.variation = 4,
			.density = 0.66,
			.priority = 0.2,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:1",
			.chance = 0.25,
			.width = 6,
			.variation = 3,
			.density = 0.66,
			.priority = 0.3,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:2",
			.chance = 0.1,
			.width = 5,
			.variation = 2,
			.density = 0.66,
			.priority = 0.4,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:duckweed:3",
			.chance = 0.05,
			.width = 3,
			.variation = 2,
			.density = 0.66,
			.priority = 0.5,
			.generationMode = .water_surface,
		},
		.{
			.id = "cubyz:flower_patch",
			.block = "cubyz:lily_pad",
			.generationMode = .water_surface,
			.chance = 0.05,
			.width = 6,
			.variation = 6,
			.density = 0.05,
			.priority = 0.4,
		},
	},
	.parentBiomes = .{
		.{
			.id = "cubyz:wetlands/base",
			.chance = 8,
		},
	},
}

```

`assets/cubyz/blocks/_migrations.zig.zon`:

```zon
.{
	.{.old = "glow_crystal/dark_gray", .new = "glow_crystal/grey"},
	.{.old = "glow_crystal/dark_green", .new = "glow_crystal/viridian"},
	.{.old = "glow_crystal/dark_red", .new = "glow_crystal/crimson"},
	.{.old = "glow_crystal/gray", .new = "glow_crystal/grey"},
	.{.old = "glow_crystal/light_blue", .new = "glow_crystal/aqua"},
	.{.old = "stone", .new = "slate"},
	.{.old = "stone_bricks", .new = "slate_bricks"},
	.{.old = "stone_tile", .new = "slate_tile"},
	.{.old = "stone_wall", .new = "slate_wall"},
	.{.old = "mossy_cobblestone", .new = "cobblestone"},
	.{.old = "baobab_leaves", .new = "leaves/baobab"},
	.{.old = "baobab_leaves_opaque", .new = "leaves/opaque/baobab"},
	.{.old = "birch_leaves", .new = "leaves/birch"},
	.{.old = "birch_leaves_opaque", .new = "leaves/opaque/birch"},
	.{.old = "dead_leaves", .new = "leaves/dead"},
	.{.old = "dead_leaves_opaque", .new = "leaves/opaque/dead"},
	.{.old = "mahogany_leaves", .new = "leaves/mahogany"},
	.{.old = "mahogany_leaves_opaque", .new = "leaves/opaque/mahogany"},
	.{.old = "oak_leaves", .new = "leaves/oak"},
	.{.old = "oak_leaves_opaque", .new = "leaves/opaque/oak"},
	.{.old = "palm_leaves", .new = "leaves/palm"},
	.{.old = "palm_leaves_opaque", .new = "leaves/opaque/palm"},
	.{.old = "red_leaves", .new = "leaves/red"},
	.{.old = "red_leaves_opaque", .new = "leaves/opaque/red"},
	.{.old = "willow_leaves", .new = "leaves/willow"},
	.{.old = "willow_leaves_opaque", .new = "leaves/opaque/willow"},
	.{.old = "yellow_leaves", .new = "leaves/yellow"},
	.{.old = "yellow_leaves_opaque", .new = "leaves/opaque/yellow"},
	.{.old = "pine_needles", .new = "leaves/pine"},
	.{.old = "pine_needles_opaque", .new = "leaves/opaque/pine"},
	.{.old = "basalt", .new = "basalt/base"},
	.{.old = "basalt_bricks", .new = "basalt/bricks"},
	.{.old = "basalt_tile", .new = "basalt/tile"},
	.{.old = "basalt_wall", .new = "basalt/wall"},
	.{.old = "ferrock", .new = "ferrock/base"},
	.{.old = "ferrock_bricks", .new = "ferrock/bricks"},
	.{.old = "ferrock_tiles", .new = "ferrock/tile"},
	.{.old = "ferrock_wall", .new = "ferrock/wall"},
	.{.old = "glacite", .new = "glacite/base"},
	.{.old = "glacite_bricks", .new = "glacite/bricks"},
	.{.old = "glacite_tile", .new = "glacite/tile"},
	.{.old = "glacite_wall", .new = "glacite/wall"},
	.{.old = "limestone", .new = "limestone/base"},
	.{.old = "limestone_bricks", .new = "limestone/bricks"},
	.{.old = "limestone_tiles", .new = "limestone/tile"},
	.{.old = "limestone_wall", .new = "limestone/wall"},
	.{.old = "marble", .new = "marble/base"},
	.{.old = "marble_bricks", .new = "marble/bricks"},
	.{.old = "marble_tile", .new = "marble/tile"},
	.{.old = "marble_wall", .new = "marble/wall"},
	.{.old = "sandstone", .new = "sandstone/base"},
	.{.old = "sandstone_bricks", .new = "sandstone/bricks"},
	.{.old = "sandstone_tile", .new = "sandstone/tile"},
	.{.old = "sandstone_wall", .new = "sandstone/wall"},
	.{.old = "slate", .new = "slate/base"},
	.{.old = "slate_bricks", .new = "slate/bricks"},
	.{.old = "cobblestone", .new = "slate/cobble"},
	.{.old = "slate_tile", .new = "slate/tile"},
	.{.old = "slate_wall", .new = "slate/wall"},
	.{.old = "terracotta", .new = "terracotta/base"},
	.{.old = "terracotta_bricks", .new = "terracotta/bricks"},
	.{.old = "terracotta_tiles", .new = "terracotta/tile"},
	.{.old = "terracotta_wall", .new = "terracotta/wall"},
	.{.old = "void_stone", .new = "voidstone/base"},
	.{.old = "void_stone_bricks", .new = "voidstone/bricks"},
	.{.old = "void_stone_tile", .new = "voidstone/tile"},
	.{.old = "void_stone_wall", .new = "voidstone/wall"},
}

```

`assets/cubyz/blocks/air.zig.zon`:

```zon
.{
	.tags = .{.air},

	.transparent = true,
	.absorbedLight = 0x000000,
	.viewThrough = true,
	.replacable = true,
	.rotation = "cubyz:no_rotation",
	.degradable = true,
	.hasItem = false,
	.collide = false,

	.drops = .{},
	.model = .none,
}

```

`assets/cubyz/blocks/amber_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 30,
	.blockResistance = 3,
	.drops = .{
		.{.items = .{.auto}},
	},
	.transparent = true,
	.hasBackFace = true,
	.model = "cubyz:cube",
	.absorbedLight = 0x117edc,
	.texture = "cubyz:amber_block",
}

```

`assets/cubyz/blocks/amber_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 15,
	.blockResistance = 3,
	.item = .{
		.texture = "amber.png",
		.material = .{
			.durability = 140,
			.massDamage = 0.1,
			.hardnessDamage = 2.3,
			.swingSpeed = 8.5,
			.textureRoughness = 0.1,
			.colors = .{
				0xff9b3481b, 0xffd35a1c, 0xffee7023, 0xffff9134, 0xffffc14a,
			},
			.modifiers = .{
				.{
					.id = "light",
					.strength = 0.5,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 4,
					},
				},
			},
		},
	},
	.ore = .{
		.veins = 3,
		.size = 3,
		.height = -1250,
		.minHeight = -8000,
		.density = 0.15,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:amber_ore",
}

```

`assets/cubyz/blocks/baobab_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/baobab/dot",
	.texture1 = "cubyz:branch/baobab/half_line",
	.texture2 = "cubyz:branch/baobab/line",
	.texture3 = "cubyz:branch/baobab/bend",
	.texture4 = "cubyz:branch/baobab/intersection",
	.texture5 = "cubyz:branch/baobab/cross",
	.item = .{
		.material = .{
			.durability = 20,
			.massDamage = 0.4,
			.hardnessDamage = 0.4,
			.swingSpeed = 6.3,
			.textureRoughness = 0.7,
			.colors = .{
				0xff514438, 0xff665045, 0xff7a5d4d, 0xff93715c, 0xff7a5d4d,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/baobab.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/baobab_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:baobab_fence",
	.texture_top = "cubyz:baobab_fence_top",
	.texture_bottom = "cubyz:baobab_fence_top",
	.item = .{
		.texture = "fence/baobab.png",
	},
}

```

`assets/cubyz/blocks/baobab_log.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/baobab"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:baobab_log",
	.texture_top = "cubyz:baobab_log_top",
	.texture_bottom = "cubyz:baobab_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/baobab_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 20,
			.massDamage = 0.8,
			.hardnessDamage = 0.8,
			.swingSpeed = 4.2,
			.colors = .{
				0xff8c6f59, 0xffa07f66, 0xffb8917b, 0xffd7b194, 0xffe4c29f,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:baobab_planks",
}

```

`assets/cubyz/blocks/baobab_top.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/baobab"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:baobab_log",
	.texture_top = "cubyz:baobab_log",
	.texture_bottom = "cubyz:baobab_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/bars/_defaults.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:bars",
}

```

`assets/cubyz/blocks/bars/copper.zig.zon`:

```zon
.{
	.blockResistance = 2,
	.blockHealth = 10,
	.texture = "cubyz:bars/copper",
	.item = .{
		.texture = "bars/copper.png",
	},
}

```

`assets/cubyz/blocks/bars/gold.zig.zon`:

```zon
.{
	.blockResistance = 8.5,
	.blockHealth = 20,
	.texture = "cubyz:bars/gold",
	.item = .{
		.texture = "bars/gold.png",
	},
}

```

`assets/cubyz/blocks/bars/iron.zig.zon`:

```zon
.{
	.blockResistance = 5,
	.blockHealth = 15,
	.texture = "cubyz:bars/iron",
	.item = .{
		.texture = "bars/iron.png",
	},
}

```

`assets/cubyz/blocks/bars/silver.zig.zon`:

```zon
.{
	.blockResistance = 7,
	.blockHealth = 20,
	.texture = "cubyz:bars/silver",
	.item = .{
		.texture = "bars/silver.png",
	},
}

```

`assets/cubyz/blocks/bars/uranium.zig.zon`:

```zon
.{
	.blockResistance = 17.5,
	.blockHealth = 25,
	.texture = "cubyz:bars/uranium",
	.item = .{
		.texture = "bars/uranium.png",
	},
}

```

`assets/cubyz/blocks/basalt/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .basalt},
	.blockHealth = 30,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 75,
			.massDamage = 2.0,
			.hardnessDamage = 4.0,
			.swingSpeed = 2.9,
			.textureRoughness = 5.0,
			.colors = .{
				0xff282328, 0xff353135, 0xff434041, 0xff4A4849, 0xff605E5F,
			},
			.modifiers = .{
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .basalt,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/basalt/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:basalt/base",
}

```

`assets/cubyz/blocks/basalt/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:basalt/bricks",
}

```

`assets/cubyz/blocks/basalt/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:basalt/tile",
}

```

`assets/cubyz/blocks/basalt/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:basalt/wall",
	.texture_top = "cubyz:basalt/wall_top",
	.texture_bottom = "cubyz:basalt/wall_top",
	.item = .{
		.texture = "wall/basalt.png",
	},
}

```

`assets/cubyz/blocks/bellows.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:planar",
	.model = "cubyz:bellows",
	.texture = "cubyz:bellows/side",
	.texture_front = "cubyz:bellows/nozzle",
	.texture_left = "cubyz:bellows/nozzle",
	.texture_right = "cubyz:bellows/side",
	.texture_top = "cubyz:bellows/top",
	.texture_bottom = "cubyz:bellows/bottom",
	.item = .{
		.texture = "bellows.png",
	},
}

```

`assets/cubyz/blocks/birch_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/birch/dot",
	.texture1 = "cubyz:branch/birch/half_line",
	.texture2 = "cubyz:branch/birch/line",
	.texture3 = "cubyz:branch/birch/bend",
	.texture4 = "cubyz:branch/birch/intersection",
	.texture5 = "cubyz:branch/birch/cross",
	.item = .{
		.material = .{
			.durability = 24,
			.massDamage = 0.45,
			.hardnessDamage = 0.45,
			.swingSpeed = 6.9,
			.density = 0.3,
			.elasticity = 3.5,
			.hardness = 1.25,
			.textureRoughness = 0.7,
			.colors = .{
				0xffb8aa9e, 0xffd0c2b5, 0xffeedfd0, 0xfffff6ed, 0xffeedfd0,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/birch.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/birch_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:birch_fence",
	.texture_top = "cubyz:birch_fence_top",
	.texture_bottom = "cubyz:birch_fence_top",
	.item = .{
		.texture = "fence/birch.png",
	},
}

```

`assets/cubyz/blocks/birch_log.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/birch"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:birch_log",
	.texture_top = "cubyz:birch_log_top",
	.texture_bottom = "cubyz:birch_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/birch_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 24,
			.massDamage = 0.9,
			.hardnessDamage = 0.9,
			.swingSpeed = 4.6,
			.textureRoughness = 0.7,
			.colors = .{
				0xff9b7a5b, 0xffbf9872, 0xffdeb287, 0xfff2c89c, 0xffffdfb7,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:birch_planks",
}

```

`assets/cubyz/blocks/birch_top.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/birch"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:birch_log",
	.texture_top = "cubyz:birch_log",
	.texture_bottom = "cubyz:birch_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/bluebells.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x121012,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:bluebells",
	.item = .{
		.texture = "bluebells.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/bolete.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .mushroom},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.replacable = true,
	.viewThrough = true,
	.degradable = true,
	.absorbedLight = 0x010101,
	.collide = false,
	.rotation = "cubyz:torch",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.model = .{
		.base = "cubyz:bolete/floor",
		.side = "cubyz:bolete/shelf",
	},
	.texture = "cubyz:bolete_side",
	.texture_top = "cubyz:bolete_top",
	.texture_bottom = "cubyz:bolete_bottom",
	.item = .{
		.texture = "bolete.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/bolete_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/bolete/dot",
	.texture1 = "cubyz:branch/bolete/half_line",
	.texture2 = "cubyz:branch/bolete/line",
	.texture3 = "cubyz:branch/bolete/bend",
	.texture4 = "cubyz:branch/bolete/intersection",
	.texture5 = "cubyz:branch/bolete/cross",
	.item = .{
		.material = .{
			.durability = 200,
			.massDamage = 1.0,
			.hardnessDamage = 0.0,
			.swingSpeed = 4.6,
			.textureRoughness = 0.5,
			.colors = .{
				0xff9f7853, 0xffb38e65, 0xffcba275, 0xffe5b885, 0xffe5b885,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
		.texture = "branch/bolete.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/bolete_cap.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 3,
	.bounciness = 0.75,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:bolete_cap",
}

```

`assets/cubyz/blocks/bolete_stem.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{"cubyz:log/bolete"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:bolete_stem",
}

```

`assets/cubyz/blocks/branch/leafy/_defaults.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .leaf, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 0.5,
	.absorbedLight = 0x202830,
	.alwaysViewThrough = true,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
		.shellModel = "cubyz:cube",
		.textureSlotOffset = 6,
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/branch/leafy/baobab.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:baobab_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/baobab", "cubyz:baobab_branch"}},
	},
	.texture = "cubyz:leaves/baobab",
	.texture6 = "cubyz:branch/baobab/dot",
	.texture7 = "cubyz:branch/baobab/half_line",
	.texture8 = "cubyz:branch/baobab/line",
	.texture9 = "cubyz:branch/baobab/bend",
	.texture10 = "cubyz:branch/baobab/intersection",
	.texture11 = "cubyz:branch/baobab/cross",
	.lodReplacement = "cubyz:leaves/opaque/baobab",
	.opaqueVariant = "cubyz:leaves/opaque/baobab",
}

```

`assets/cubyz/blocks/branch/leafy/birch.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:birch_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/birch", "cubyz:birch_branch"}},
	},
	.texture = "cubyz:leaves/birch",
	.texture6 = "cubyz:branch/birch/dot",
	.texture7 = "cubyz:branch/birch/half_line",
	.texture8 = "cubyz:branch/birch/line",
	.texture9 = "cubyz:branch/birch/bend",
	.texture10 = "cubyz:branch/birch/intersection",
	.texture11 = "cubyz:branch/birch/cross",
	.lodReplacement = "cubyz:leaves/opaque/birch",
	.opaqueVariant = "cubyz:leaves/opaque/birch",
}

```

`assets/cubyz/blocks/branch/leafy/mahogany.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:mahogany_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/mahogany", "cubyz:mahogany_branch"}},
	},
	.texture = "cubyz:leaves/mahogany",
	.texture6 = "cubyz:branch/mahogany/dot",
	.texture7 = "cubyz:branch/mahogany/half_line",
	.texture8 = "cubyz:branch/mahogany/line",
	.texture9 = "cubyz:branch/mahogany/bend",
	.texture10 = "cubyz:branch/mahogany/intersection",
	.texture11 = "cubyz:branch/mahogany/cross",
	.lodReplacement = "cubyz:leaves/opaque/mahogany",
	.opaqueVariant = "cubyz:leaves/opaque/mahogany",
}

```

`assets/cubyz/blocks/branch/leafy/oak.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:oak_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/oak", "cubyz:oak_branch"}},
	},
	.texture = "cubyz:leaves/oak",
	.texture6 = "cubyz:branch/oak/dot",
	.texture7 = "cubyz:branch/oak/half_line",
	.texture8 = "cubyz:branch/oak/line",
	.texture9 = "cubyz:branch/oak/bend",
	.texture10 = "cubyz:branch/oak/intersection",
	.texture11 = "cubyz:branch/oak/cross",
	.lodReplacement = "cubyz:leaves/opaque/oak",
	.opaqueVariant = "cubyz:leaves/opaque/oak",
}

```

`assets/cubyz/blocks/branch/leafy/palm.zig.zon`:

```zon
.{
	.model = .{
		.radius = 4,
		.shellModel = "cubyz:cube_hanging_planes",
		.textureSlotOffset = 6,
	},
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:palm_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/palm", "cubyz:palm_branch"}},
	},
	.texture = "cubyz:leaves/palm",
	.texture12 = "cubyz:leaves/palm_hanging",
	.texture6 = "cubyz:branch/palm/dot",
	.texture7 = "cubyz:branch/palm/half_line",
	.texture8 = "cubyz:branch/palm/line",
	.texture9 = "cubyz:branch/palm/bend",
	.texture10 = "cubyz:branch/palm/intersection",
	.texture11 = "cubyz:branch/palm/cross",
	.lodReplacement = "cubyz:leaves/opaque/palm",
	.opaqueVariant = "cubyz:leaves/opaque/palm",
}

```

`assets/cubyz/blocks/branch/leafy/pine.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:pine_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/pine", "cubyz:pine_branch"}},
	},
	.texture = "cubyz:leaves/pine",
	.texture6 = "cubyz:branch/pine/dot",
	.texture7 = "cubyz:branch/pine/half_line",
	.texture8 = "cubyz:branch/pine/line",
	.texture9 = "cubyz:branch/pine/bend",
	.texture10 = "cubyz:branch/pine/intersection",
	.texture11 = "cubyz:branch/pine/cross",
	.lodReplacement = "cubyz:leaves/opaque/pine",
	.opaqueVariant = "cubyz:leaves/opaque/pine",
}

```

`assets/cubyz/blocks/branch/leafy/willow.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.drops = .{
			.{.items = .{"cubyz:willow_branch"}},
		},
	},
	.drops = .{
		.{.items = .{"cubyz:leaves/willow", "cubyz:willow_branch"}},
	},
	.texture = "cubyz:leaves/willow",
	.texture6 = "cubyz:branch/willow/dot",
	.texture7 = "cubyz:branch/willow/half_line",
	.texture8 = "cubyz:branch/willow/line",
	.texture9 = "cubyz:branch/willow/bend",
	.texture10 = "cubyz:branch/willow/intersection",
	.texture11 = "cubyz:branch/willow/cross",
	.lodReplacement = "cubyz:leaves/opaque/willow",
	.opaqueVariant = "cubyz:leaves/opaque/willow",
}

```

`assets/cubyz/blocks/branch/palm.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/palm/dot",
	.texture1 = "cubyz:branch/palm/half_line",
	.texture2 = "cubyz:branch/palm/line",
	.texture3 = "cubyz:branch/palm/bend",
	.texture4 = "cubyz:branch/palm/intersection",
	.texture5 = "cubyz:branch/palm/cross",
	.item = .{
		.material = .{
			.durability = 22,
			.massDamage = 0.4,
			.hardnessDamage = 0.4,
			.swingSpeed = 7.4,
			.textureRoughness = 0.7,
			.colors = .{
				0xff6d4f33, 0xff865f3d, 0xff9f6c46, 0xffb47f51, 0xff9f6c46,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/palm.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/cactus.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .log},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{"cubyz:log/cactus"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:cactus",
	.texture_top = "cubyz:cactus_top",
	.texture_bottom = "cubyz:cactus_top",
	.onTouch = .{
		.type = .hurt,
		.dps = 0.5,
		.damageType = .spiky,
	},
}

```

`assets/cubyz/blocks/cactus_arm.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 2.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/cactus/dot",
	.texture1 = "cubyz:branch/cactus/half_line",
	.texture2 = "cubyz:branch/cactus/line",
	.texture3 = "cubyz:branch/cactus/bend",
	.texture4 = "cubyz:branch/cactus/intersection",
	.texture5 = "cubyz:branch/cactus/cross",
	.onTouch = .{
		.type = .hurt,
		.dps = 0.5,
		.damageType = .spiky,
	},
	.item = .{
		.material = .{
			.durability = 50,
			.massDamage = 1.0,
			.hardnessDamage = 1.5,
			.swingSpeed = 5.6,
			.textureRoughness = 0.7,
			.colors = .{
				0xff4f6923, 0xff687630, 0xff74842d, 0xff879b2e, 0xff74842d,
			},
		},
		.texture = "cactus_arm.png",
	},
}

```

`assets/cubyz/blocks/cactus_flower.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x121012,
	.model = "cubyz:cactus_flower",
	.rotation = "cubyz:direction",
	.texture = "cubyz:cactus_flower",
	.texture_top = "cubyz:cactus_flower_top",
	.texture_bottom = "cubyz:cactus_flower_top",
	.item = .{
		.texture = "cactus_flower.png",
	},
	.lodReplacement = "cubyz:air",
	.onTouch = .{
		.type = .hurt,
		.dps = 0.2,
		.damageType = .spiky,
	},
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/candy_cane/block.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:candy_cane/block",
}

```

`assets/cubyz/blocks/candy_cane/branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:candy_cane/branch/dot",
	.texture1 = "cubyz:candy_cane/branch/half_line",
	.texture2 = "cubyz:candy_cane/branch/line",
	.texture3 = "cubyz:candy_cane/branch/bend",
	.texture4 = "cubyz:candy_cane/branch/intersection",
	.texture5 = "cubyz:candy_cane/branch/cross",
	.item = .{
		.material = .{
			.durability = 260,
			.massDamage = 1.5,
			.hardnessDamage = 0.5,
			.swingSpeed = 4.2,
			.textureRoughness = 0.7,
			.colors = .{
				0xffc4a6a8, 0xffce2632, 0xfffff1ec, 0xfff0424e, 0xffffffff,
			},
		},
		.texture = "candy_cane.png",
	},
}

```

`assets/cubyz/blocks/castilleja.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:flower/height_10",
	.rotation = "cubyz:planar",
	.texture = "cubyz:castilleja",
	.texture_top = "cubyz:castilleja_top",
	.texture_bottom = "cubyz:castilleja_top",
	.item = .{
		.texture = "castilleja.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/chain/iron.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 15,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:chain",
	.texture = "cubyz:chain/iron",
	.item = .{
		.texture = "chain/iron.png",
	},
}

```

`assets/cubyz/blocks/chalk/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable},
	.blockHealth = 12,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
}

```

`assets/cubyz/blocks/chalk/aqua.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/aqua",
}

```

`assets/cubyz/blocks/chalk/black.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/black",
}

```

`assets/cubyz/blocks/chalk/blue.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/blue",
}

```

`assets/cubyz/blocks/chalk/brown.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/brown",
}

```

`assets/cubyz/blocks/chalk/crimson.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/crimson",
}

```

`assets/cubyz/blocks/chalk/cyan.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/cyan",
}

```

`assets/cubyz/blocks/chalk/dark_grey.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/dark_grey",
}

```

`assets/cubyz/blocks/chalk/green.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/green",
}

```

`assets/cubyz/blocks/chalk/grey.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/grey",
}

```

`assets/cubyz/blocks/chalk/indigo.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/indigo",
}

```

`assets/cubyz/blocks/chalk/lime.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/lime",
}

```

`assets/cubyz/blocks/chalk/magenta.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/magenta",
}

```

`assets/cubyz/blocks/chalk/orange.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/orange",
}

```

`assets/cubyz/blocks/chalk/pink.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/pink",
}

```

`assets/cubyz/blocks/chalk/purple.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/purple",
}

```

`assets/cubyz/blocks/chalk/red.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/red",
}

```

`assets/cubyz/blocks/chalk/violet.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/violet",
}

```

`assets/cubyz/blocks/chalk/viridian.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/viridian",
}

```

`assets/cubyz/blocks/chalk/white.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/white",
}

```

`assets/cubyz/blocks/chalk/yellow.zig.zon`:

```zon
.{
	.texture = "cubyz:chalk/yellow",
}

```

`assets/cubyz/blocks/chest/_defaults.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:planar",
	.blockEntity = .chest,
}

```

`assets/cubyz/blocks/chest/baobab.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/baobab/back",
	.texture_front = "cubyz:chest/baobab/front",
	.texture_left = "cubyz:chest/baobab/side",
	.texture_right = "cubyz:chest/baobab/side",
	.texture_top = "cubyz:chest/baobab/top",
	.texture_bottom = "cubyz:chest/baobab/bottom",
}

```

`assets/cubyz/blocks/chest/birch.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/birch/back",
	.texture_front = "cubyz:chest/birch/front",
	.texture_left = "cubyz:chest/birch/side",
	.texture_right = "cubyz:chest/birch/side",
	.texture_top = "cubyz:chest/birch/top",
	.texture_bottom = "cubyz:chest/birch/bottom",
}

```

`assets/cubyz/blocks/chest/mahogany.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/mahogany/back",
	.texture_front = "cubyz:chest/mahogany/front",
	.texture_left = "cubyz:chest/mahogany/side",
	.texture_right = "cubyz:chest/mahogany/side",
	.texture_top = "cubyz:chest/mahogany/top",
	.texture_bottom = "cubyz:chest/mahogany/bottom",
}

```

`assets/cubyz/blocks/chest/oak.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/oak/back",
	.texture_front = "cubyz:chest/oak/front",
	.texture_left = "cubyz:chest/oak/side",
	.texture_right = "cubyz:chest/oak/side",
	.texture_top = "cubyz:chest/oak/top",
	.texture_bottom = "cubyz:chest/oak/bottom",
}

```

`assets/cubyz/blocks/chest/palm.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/palm/back",
	.texture_front = "cubyz:chest/palm/front",
	.texture_left = "cubyz:chest/palm/side",
	.texture_right = "cubyz:chest/palm/side",
	.texture_top = "cubyz:chest/palm/top",
	.texture_bottom = "cubyz:chest/palm/bottom",
}

```

`assets/cubyz/blocks/chest/pine.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/pine/back",
	.texture_front = "cubyz:chest/pine/front",
	.texture_left = "cubyz:chest/pine/side",
	.texture_right = "cubyz:chest/pine/side",
	.texture_top = "cubyz:chest/pine/top",
	.texture_bottom = "cubyz:chest/pine/bottom",
}

```

`assets/cubyz/blocks/chest/willow.zig.zon`:

```zon
.{
	.texture = "cubyz:chest/willow/back",
	.texture_front = "cubyz:chest/willow/front",
	.texture_left = "cubyz:chest/willow/side",
	.texture_right = "cubyz:chest/willow/side",
	.texture_top = "cubyz:chest/willow/top",
	.texture_bottom = "cubyz:chest/willow/bottom",
}

```

`assets/cubyz/blocks/chimney.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:chimney",
	.texture = "cubyz:chimney/side",
	.texture_top = "cubyz:chimney/top",
	.texture_bottom = "cubyz:chimney/bottom",
	.item = .{
		.texture = "chimney.png",
	},
}

```

`assets/cubyz/blocks/clay.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 5.75,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:clay",
}

```

`assets/cubyz/blocks/cloth/_defaults.zig.zon`:

```zon
.{
	.tags = .{.cloth, .cuttable},
	.blockHealth = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.collide = false,
	.model = "cubyz:carpet",
	.rotation = "cubyz:carpet",
	.degradable = true,
}

```

`assets/cubyz/blocks/cloth/aqua.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/aqua",
	.item = .{
		.texture = "cloth/aqua.png",
	},
}

```

`assets/cubyz/blocks/cloth/black.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/black",
	.item = .{
		.texture = "cloth/black.png",
	},
}

```

`assets/cubyz/blocks/cloth/block/_defaults.zig.zon`:

```zon
.{
	.tags = .{.cloth, .cuttable},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
}

```

`assets/cubyz/blocks/cloth/block/aqua.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/aqua",
}

```

`assets/cubyz/blocks/cloth/block/black.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/black",
}

```

`assets/cubyz/blocks/cloth/block/blue.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/blue",
}

```

`assets/cubyz/blocks/cloth/block/brown.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/brown",
}

```

`assets/cubyz/blocks/cloth/block/crimson.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/crimson",
}

```

`assets/cubyz/blocks/cloth/block/cyan.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/cyan",
}

```

`assets/cubyz/blocks/cloth/block/dark_grey.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/dark_grey",
}

```

`assets/cubyz/blocks/cloth/block/green.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/green",
}

```

`assets/cubyz/blocks/cloth/block/grey.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/grey",
}

```

`assets/cubyz/blocks/cloth/block/indigo.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/indigo",
}

```

`assets/cubyz/blocks/cloth/block/lime.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/lime",
}

```

`assets/cubyz/blocks/cloth/block/magenta.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/magenta",
}

```

`assets/cubyz/blocks/cloth/block/orange.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/orange",
}

```

`assets/cubyz/blocks/cloth/block/pink.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/pink",
}

```

`assets/cubyz/blocks/cloth/block/purple.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/purple",
}

```

`assets/cubyz/blocks/cloth/block/red.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/red",
}

```

`assets/cubyz/blocks/cloth/block/violet.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/violet",
}

```

`assets/cubyz/blocks/cloth/block/viridian.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/viridian",
}

```

`assets/cubyz/blocks/cloth/block/white.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/white",
}

```

`assets/cubyz/blocks/cloth/block/yellow.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/yellow",
}

```

`assets/cubyz/blocks/cloth/blue.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/blue",
	.item = .{
		.texture = "cloth/blue.png",
	},
}

```

`assets/cubyz/blocks/cloth/brown.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/brown",
	.item = .{
		.texture = "cloth/brown.png",
	},
}

```

`assets/cubyz/blocks/cloth/crimson.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/crimson",
	.item = .{
		.texture = "cloth/crimson.png",
	},
}

```

`assets/cubyz/blocks/cloth/cyan.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/cyan",
	.item = .{
		.texture = "cloth/cyan.png",
	},
}

```

`assets/cubyz/blocks/cloth/dark_grey.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/dark_grey",
	.item = .{
		.texture = "cloth/dark_grey.png",
	},
}

```

`assets/cubyz/blocks/cloth/green.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/green",
	.item = .{
		.texture = "cloth/green.png",
	},
}

```

`assets/cubyz/blocks/cloth/grey.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/grey",
	.item = .{
		.texture = "cloth/grey.png",
	},
}

```

`assets/cubyz/blocks/cloth/indigo.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/indigo",
	.item = .{
		.texture = "cloth/indigo.png",
	},
}

```

`assets/cubyz/blocks/cloth/lime.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/lime",
	.item = .{
		.texture = "cloth/lime.png",
	},
}

```

`assets/cubyz/blocks/cloth/magenta.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/magenta",
	.item = .{
		.texture = "cloth/magenta.png",
	},
}

```

`assets/cubyz/blocks/cloth/orange.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/orange",
	.item = .{
		.texture = "cloth/orange.png",
	},
}

```

`assets/cubyz/blocks/cloth/pink.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/pink",
	.item = .{
		.texture = "cloth/pink.png",
	},
}

```

`assets/cubyz/blocks/cloth/purple.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/purple",
	.item = .{
		.texture = "cloth/purple.png",
	},
}

```

`assets/cubyz/blocks/cloth/red.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/red",
	.item = .{
		.texture = "cloth/red.png",
	},
}

```

`assets/cubyz/blocks/cloth/violet.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/violet",
	.item = .{
		.texture = "cloth/violet.png",
	},
}

```

`assets/cubyz/blocks/cloth/viridian.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/viridian",
	.item = .{
		.texture = "cloth/viridian.png",
	},
}

```

`assets/cubyz/blocks/cloth/white.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/white",
	.item = .{
		.texture = "cloth/white.png",
	},
}

```

`assets/cubyz/blocks/cloth/yellow.zig.zon`:

```zon
.{
	.texture = "cubyz:cloth/yellow",
	.item = .{
		.texture = "cloth/yellow.png",
	},
}

```

`assets/cubyz/blocks/coal_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 35,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:coal_block",
}

```

`assets/cubyz/blocks/coal_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 16,
	.blockResistance = 1,
	.ore = .{
		.veins = 5,
		.size = 100,
		.height = 500,
		.density = 0.5,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:coal_ore",
	.item = .{
		.texture = "coal.png",
	},
}

```

`assets/cubyz/blocks/cold_grass.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 7,
	.drops = .{
		.{.items = .{"cubyz:permafrost"}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:cold_grass",
	.texture_bottom = "cubyz:permafrost",
}

```

`assets/cubyz/blocks/cold_grass_vegetation.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:cold_grass_vegetation",
	.item = .{
		.texture = "cold_grass.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/copper_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 35,
	.blockResistance = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:copper_block",
}

```

`assets/cubyz/blocks/copper_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 35,
	.blockResistance = 2,
	.ore = .{
		.veins = 5,
		.size = 15,
		.height = 20,
		.minHeight = -400,
		.density = 0.25,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:copper_ore",
	.item = .{
		.texture = "raw_copper.png",
	},
}

```

`assets/cubyz/blocks/cut_amber_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 30,
	.blockResistance = 3,
	.drops = .{
		.{.items = .{.auto}},
	},
	.transparent = true,
	.hasBackFace = true,
	.model = "cubyz:cube",
	.absorbedLight = 0x117edc,
	.texture = "cubyz:cut_amber_block",
}

```

`assets/cubyz/blocks/cut_diamond_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 55,
	.blockResistance = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:cut_diamond_block",
}

```

`assets/cubyz/blocks/cut_ruby_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 55,
	.blockResistance = 9,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:cut_ruby_block",
}

```

`assets/cubyz/blocks/daffodil.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:flower/height_8",
	.rotation = "cubyz:planar",
	.texture = "cubyz:daffodil",
	.texture_top = "cubyz:daffodil_top",
	.texture_bottom = "cubyz:daffodil_top",
	.item = .{
		.texture = "daffodil.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/daisies.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x121012,
	.model = "cubyz:plane",
	.rotation = "cubyz:carpet",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture = "cubyz:daisies",
	.item = .{
		.texture = "daisies.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/dandelions.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x121012,
	.model = "cubyz:plane",
	.rotation = "cubyz:carpet",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture = "cubyz:dandelions",
	.item = .{
		.texture = "dandelions.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/dead_leaf_pile.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .leaf},
	.blockHealth = 0.1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x000000,
	.model = .{
		.model = "cubyz:plane",
		.states = 4,
	},
	.rotation = "cubyz:texture_pile",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture0 = "cubyz:dead_leaf_pile/0",
	.texture1 = "cubyz:dead_leaf_pile/1",
	.texture2 = "cubyz:dead_leaf_pile/2",
	.texture3 = "cubyz:dead_leaf_pile/3",
	.item = .{
		.texture = "dead_leaf_pile.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/diamond_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 55,
	.blockResistance = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:diamond_block",
}

```

`assets/cubyz/blocks/diamond_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 80,
	.blockResistance = 10,
	.ore = .{
		.veins = 3,
		.size = 6,
		.height = -1000,
		.density = 0.1,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:diamond_ore",
	.item = .{
		.texture = "diamond.png",
		.material = .{
			.durability = 250,
			.massDamage = 0.7,
			.hardnessDamage = 8.7,
			.swingSpeed = 4.7,
			.textureRoughness = 0.1,
			.colors = .{
				0xff5d7ae4, 0xff8d85ff, 0xff78c1f9, 0xffa8f0ff, 0xffffffff,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.5,
					.restriction = .{
						.id = .not,
						.child = .{
							.id = .encased,
							.tag = .precious,
							.amount = 4,
						},
					},
				},
				.{
					.id = "powerful",
					.strength = 0.5,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 4,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/dirt.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 6.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:dirt",
}

```

`assets/cubyz/blocks/dry_grass.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 7,
	.drops = .{
		.{.items = .{"cubyz:dirt"}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:dry_grass",
	.texture_bottom = "cubyz:dirt",
}

```

`assets/cubyz/blocks/dry_grass_vegetation.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:dry_grass_vegetation",
	.item = .{
		.texture = "dry_grass.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/duckweed.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x000000,
	.model = .{
		.model = "cubyz:plane",
		.states = 4,
	},
	.rotation = "cubyz:texture_pile",
	.texture0 = "cubyz:duckweed/0",
	.texture1 = "cubyz:duckweed/1",
	.texture2 = "cubyz:duckweed/2",
	.texture3 = "cubyz:duckweed/3",
	.item = .{
		.texture = "duckweed.png",
		.tags = .{.fluidPlaceable},
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/fern.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:fern",
	.texture = "cubyz:fern",
	.item = .{
		.texture = "fern.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/ferrock/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .ferrock},
	.blockHealth = 32.5,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 45,
			.massDamage = 1.0,
			.hardnessDamage = 3.8,
			.swingSpeed = 2.9,
			.textureRoughness = 0.75,
			.colors = .{
				0xff72403C, 0xff905B57, 0xffB77966, 0xffC2846A, 0xffC49B77,
			},
			.modifiers = .{
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .ferrock,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/ferrock/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:ferrock/base",
}

```

`assets/cubyz/blocks/ferrock/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:ferrock/bricks",
}

```

`assets/cubyz/blocks/ferrock/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:ferrock/tile",
}

```

`assets/cubyz/blocks/ferrock/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:ferrock/wall",
	.texture_top = "cubyz:ferrock/wall_top",
	.texture_bottom = "cubyz:ferrock/wall_top",
	.item = .{
		.texture = "wall/ferrock.png",
	},
}

```

`assets/cubyz/blocks/fog/_defaults.zig.zon`:

```zon
.{
	.tags = .{.air},
	.blockHealth = 2,
	.drops = .{},
	.degradable = true,
	.transparent = true,
	.hasBackFace = true,
	.replacable = true,
	.collide = false,

	.model = "cubyz:cube",
}

```

`assets/cubyz/blocks/fog/blue.zig.zon`:

```zon
.{
	.absorbedLight = 0x010100,

	.texture = "cubyz:fog/blue",
	.item = .{
		.texture = "fog/blue.png",
	},
}

```

`assets/cubyz/blocks/fog/cyan.zig.zon`:

```zon
.{
	.absorbedLight = 0x010000,

	.texture = "cubyz:fog/cyan",
	.item = .{
		.texture = "fog/cyan.png",
	},
}

```

`assets/cubyz/blocks/fog/green.zig.zon`:

```zon
.{
	.absorbedLight = 0x010001,

	.texture = "cubyz:fog/green",
	.item = .{
		.texture = "fog/green.png",
	},
}

```

`assets/cubyz/blocks/fog/magenta.zig.zon`:

```zon
.{
	.absorbedLight = 0x000100,

	.texture = "cubyz:fog/magenta",
	.item = .{
		.texture = "fog/magenta.png",
	},
}

```

`assets/cubyz/blocks/fog/red.zig.zon`:

```zon
.{
	.absorbedLight = 0x000101,

	.texture = "cubyz:fog/red",
	.item = .{
		.texture = "fog/red.png",
	},
}

```

`assets/cubyz/blocks/fog/yellow.zig.zon`:

```zon
.{
	.absorbedLight = 0x000001,

	.texture = "cubyz:fog/yellow",
	.item = .{
		.texture = "fog/yellow.png",
	},
}

```

`assets/cubyz/blocks/frost.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:frost",
	.friction = 5,
}

```

`assets/cubyz/blocks/furnace.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 20,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:planar",
	.model = "cubyz:cube",
	.texture = "cubyz:furnace/back",
	.texture_front = "cubyz:furnace/front",
	.texture_left = "cubyz:furnace/side",
	.texture_right = "cubyz:furnace/side",
	.texture_top = "cubyz:furnace/top",
	.texture_bottom = "cubyz:furnace/bottom",
}

```

`assets/cubyz/blocks/glacite/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .glacite},
	.blockHealth = 25,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 65,
			.massDamage = 1.0,
			.hardnessDamage = 4.3,
			.swingSpeed = 2.6,
			.textureRoughness = 2.0,
			.colors = .{
				0xff6E757F, 0xff86898E, 0xffA4A7AA, 0xffB9BCBF, 0xffCACCCE,
			},
			.modifiers = .{
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .glacite,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/glacite/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:glacite/base",
}

```

`assets/cubyz/blocks/glacite/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:glacite/bricks",
}

```

`assets/cubyz/blocks/glacite/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:glacite/tile",
}

```

`assets/cubyz/blocks/glacite/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:glacite/wall",
	.texture_top = "cubyz:glacite/wall_top",
	.texture_bottom = "cubyz:glacite/wall_top",
	.item = .{
		.texture = "wall/glacite.png",
	},
}

```

`assets/cubyz/blocks/glass/_defaults.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 2.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.transparent = true,
	.hasBackFace = true,
	.model = "cubyz:cube",
}

```

`assets/cubyz/blocks/glass/aqua.zig.zon`:

```zon
.{
	.absorbedLight = 0xe95825,
	.texture = "cubyz:glass/aqua",
}

```

`assets/cubyz/blocks/glass/black.zig.zon`:

```zon
.{
	.absorbedLight = 0xe6e6e6,
	.texture = "cubyz:glass/black",
}

```

`assets/cubyz/blocks/glass/blue.zig.zon`:

```zon
.{
	.absorbedLight = 0xdc923c,
	.texture = "cubyz:glass/blue",
}

```

`assets/cubyz/blocks/glass/brown.zig.zon`:

```zon
.{
	.absorbedLight = 0x96bdd8,
	.texture = "cubyz:glass/brown",
}

```

`assets/cubyz/blocks/glass/crimson.zig.zon`:

```zon
.{
	.absorbedLight = 0x69e4e1,
	.texture = "cubyz:glass/crimson",
}

```

`assets/cubyz/blocks/glass/cyan.zig.zon`:

```zon
.{
	.absorbedLight = 0xc62031,
	.texture = "cubyz:glass/cyan",
}

```

`assets/cubyz/blocks/glass/dark_grey.zig.zon`:

```zon
.{
	.absorbedLight = 0xacacac,
	.texture = "cubyz:glass/dark_grey",
}

```

`assets/cubyz/blocks/glass/green.zig.zon`:

```zon
.{
	.absorbedLight = 0xd966d9,
	.texture = "cubyz:glass/green",
}

```

`assets/cubyz/blocks/glass/grey.zig.zon`:

```zon
.{
	.absorbedLight = 0x656565,
	.texture = "cubyz:glass/grey",
}

```

`assets/cubyz/blocks/glass/indigo.zig.zon`:

```zon
.{
	.absorbedLight = 0xd0c16d,
	.texture = "cubyz:glass/indigo",
}

```

`assets/cubyz/blocks/glass/lime.zig.zon`:

```zon
.{
	.absorbedLight = 0xa03ed0,
	.texture = "cubyz:glass/lime",
}

```

`assets/cubyz/blocks/glass/magenta.zig.zon`:

```zon
.{
	.absorbedLight = 0x0d9f35,
	.texture = "cubyz:glass/magenta",
}

```

`assets/cubyz/blocks/glass/orange.zig.zon`:

```zon
.{
	.absorbedLight = 0x1183ee,
	.texture = "cubyz:glass/orange",
}

```

`assets/cubyz/blocks/glass/pink.zig.zon`:

```zon
.{
	.absorbedLight = 0x056830,
	.texture = "cubyz:glass/pink",
}

```

`assets/cubyz/blocks/glass/purple.zig.zon`:

```zon
.{
	.absorbedLight = 0x83d66a,
	.texture = "cubyz:glass/purple",
}

```

`assets/cubyz/blocks/glass/red.zig.zon`:

```zon
.{
	.absorbedLight = 0x2ad6d6,
	.texture = "cubyz:glass/red",
}

```

`assets/cubyz/blocks/glass/uranium.zig.zon`:

```zon
.{
	.absorbedLight = 0x4001ff,
	.emittedLight = 0x214200,
	.texture = "cubyz:glass/uranium",
}

```

`assets/cubyz/blocks/glass/violet.zig.zon`:

```zon
.{
	.absorbedLight = 0x46c345,
	.texture = "cubyz:glass/violet",
}

```

`assets/cubyz/blocks/glass/viridian.zig.zon`:

```zon
.{
	.absorbedLight = 0xf09ad6,
	.texture = "cubyz:glass/viridian",
}

```

`assets/cubyz/blocks/glass/white.zig.zon`:

```zon
.{
	.absorbedLight = 0x0f0f0f,
	.texture = "cubyz:glass/white",
}

```

`assets/cubyz/blocks/glass/yellow.zig.zon`:

```zon
.{
	.absorbedLight = 0x0d36f1,
	.texture = "cubyz:glass/yellow",
}

```

`assets/cubyz/blocks/glimmergill.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .mushroom},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.replacable = true,
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x010101,
	.emittedLight = 0x392862,
	.collide = false,
	.rotation = "cubyz:torch",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.model = .{
		.base = "cubyz:glimmergill/floor",
		.side = "cubyz:glimmergill/shelf",
	},
	.texture = "cubyz:glimmergill_side",
	.texture_top = "cubyz:glimmergill_top",
	.texture_bottom = "cubyz:glimmergill_bottom",
	.item = .{
		.texture = "glimmergill.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/glimmergill_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/glimmergill/dot",
	.texture1 = "cubyz:branch/glimmergill/half_line",
	.texture2 = "cubyz:branch/glimmergill/line",
	.texture3 = "cubyz:branch/glimmergill/bend",
	.texture4 = "cubyz:branch/glimmergill/intersection",
	.texture5 = "cubyz:branch/glimmergill/cross",
	.item = .{
		.material = .{
			.durability = 260,
			.massDamage = 1.5,
			.hardnessDamage = 0.5,
			.swingSpeed = 4.2,
			.textureRoughness = 0.5,
			.colors = .{
				0xff4a3570, 0xff564085, 0xff684a97, 0xff7555b2, 0xff7555b2,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.45,
				},
			},
		},
		.texture = "branch/glimmergill.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/glimmergill_cap.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 3,
	.bounciness = 0.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.emittedLight = 0x594587,
	.texture = "cubyz:glimmergill_cap",
}

```

`assets/cubyz/blocks/glimmergill_stem.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{"cubyz:log/glimmergill"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:glimmergill_stem",
}

```

`assets/cubyz/blocks/glow_crystal/_defaults.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
}

```

`assets/cubyz/blocks/glow_crystal/aqua.zig.zon`:

```zon
.{
	.emittedLight = 0x16a7da,
	.texture = "cubyz:glow_crystal/aqua",
}

```

`assets/cubyz/blocks/glow_crystal/black.zig.zon`:

```zon
.{
	.emittedLight = 0x262626,
	.texture = "cubyz:glow_crystal/black",
}

```

`assets/cubyz/blocks/glow_crystal/blue.zig.zon`:

```zon
.{
	.emittedLight = 0x236dc3,
	.texture = "cubyz:glow_crystal/blue",
}

```

`assets/cubyz/blocks/glow_crystal/brown.zig.zon`:

```zon
.{
	.emittedLight = 0x694227,
	.texture = "cubyz:glow_crystal/brown",
}

```

`assets/cubyz/blocks/glow_crystal/crimson.zig.zon`:

```zon
.{
	.emittedLight = 0x961b1e,
	.texture = "cubyz:glow_crystal/crimson",
}

```

`assets/cubyz/blocks/glow_crystal/cyan.zig.zon`:

```zon
.{
	.emittedLight = 0x39dfce,
	.texture = "cubyz:glow_crystal/cyan",
}

```

`assets/cubyz/blocks/glow_crystal/dark_grey.zig.zon`:

```zon
.{
	.emittedLight = 0x414141,
	.texture = "cubyz:glow_crystal/dark_grey",
}

```

`assets/cubyz/blocks/glow_crystal/green.zig.zon`:

```zon
.{
	.emittedLight = 0x269926,
	.texture = "cubyz:glow_crystal/green",
}

```

`assets/cubyz/blocks/glow_crystal/grey.zig.zon`:

```zon
.{
	.emittedLight = 0xc1c1c1,
	.texture = "cubyz:glow_crystal/grey",
}

```

`assets/cubyz/blocks/glow_crystal/indigo.zig.zon`:

```zon
.{
	.emittedLight = 0x2f3e92,
	.texture = "cubyz:glow_crystal/indigo",
}

```

`assets/cubyz/blocks/glow_crystal/lime.zig.zon`:

```zon
.{
	.emittedLight = 0x5fc12f,
	.texture = "cubyz:glow_crystal/lime",
}

```

`assets/cubyz/blocks/glow_crystal/magenta.zig.zon`:

```zon
.{
	.emittedLight = 0xf260ca,
	.texture = "cubyz:glow_crystal/magenta",
}

```

`assets/cubyz/blocks/glow_crystal/orange.zig.zon`:

```zon
.{
	.emittedLight = 0xee7c11,
	.texture = "cubyz:glow_crystal/orange",
}

```

`assets/cubyz/blocks/glow_crystal/pink.zig.zon`:

```zon
.{
	.emittedLight = 0xfa97cf,
	.texture = "cubyz:glow_crystal/pink",
}

```

`assets/cubyz/blocks/glow_crystal/purple.zig.zon`:

```zon
.{
	.emittedLight = 0x7c2995,
	.texture = "cubyz:glow_crystal/purple",
}

```

`assets/cubyz/blocks/glow_crystal/red.zig.zon`:

```zon
.{
	.emittedLight = 0xd52929,
	.texture = "cubyz:glow_crystal/red",
}

```

`assets/cubyz/blocks/glow_crystal/violet.zig.zon`:

```zon
.{
	.emittedLight = 0xb93cba,
	.texture = "cubyz:glow_crystal/violet",
}

```

`assets/cubyz/blocks/glow_crystal/viridian.zig.zon`:

```zon
.{
	.emittedLight = 0x0f6529,
	.texture = "cubyz:glow_crystal/viridian",
}

```

`assets/cubyz/blocks/glow_crystal/white.zig.zon`:

```zon
.{
	.emittedLight = 0xffffff,
	.texture = "cubyz:glow_crystal/white",
}

```

`assets/cubyz/blocks/glow_crystal/yellow.zig.zon`:

```zon
.{
	.emittedLight = 0xffff00,
	.texture = "cubyz:glow_crystal/yellow",
}

```

`assets/cubyz/blocks/gold_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 50,
	.blockResistance = 8.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:gold_block",
}

```

`assets/cubyz/blocks/gold_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 50,
	.blockResistance = 8.5,
	.ore = .{
		.veins = 2,
		.size = 12,
		.height = -2000,
		.density = 0.25,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:gold_ore",
	.item = .{
		.texture = "raw_gold.png",
	},
}

```

`assets/cubyz/blocks/grass.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 7,
	.drops = .{
		.{.items = .{"cubyz:soil"}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:grass_top",
	.texture_bottom = "cubyz:soil",
}

```

`assets/cubyz/blocks/grass_vegetation.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:grass_vegetation",
	.item = .{
		.texture = "grass.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/gravel.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 5.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:gravel",
}

```

`assets/cubyz/blocks/hibiscus.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:flower/height_8",
	.rotation = "cubyz:planar",
	.texture = "cubyz:hibiscus",
	.texture_top = "cubyz:hibiscus_top",
	.texture_bottom = "cubyz:hibiscus_top",
	.item = .{
		.texture = "hibiscus.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/ice.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 7,
	.drops = .{
		.{.items = .{.auto}},
	},
	.transparent = true,
	.hasBackFace = true,
	.absorbedLight = 0xb15635,
	.model = "cubyz:cube",
	.texture = "cubyz:ice",
	.friction = 1,
}

```

`assets/cubyz/blocks/iron_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 45,
	.blockResistance = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:iron_block",
}

```

`assets/cubyz/blocks/iron_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 35,
	.blockResistance = 5,
	.ore = .{
		.veins = 4,
		.size = 20,
		.height = -250,
		.density = 0.25,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:iron_ore",
	.item = .{
		.texture = "raw_iron.png",
	},
}

```

`assets/cubyz/blocks/ivy.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x121012,
	.model = "cubyz:plane",
	.rotation = "cubyz:carpet",
	.texture = "cubyz:ivy",
	.item = .{
		.texture = "ivy.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/kiln.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:planar",
	.model = "cubyz:cube",
	.texture = "cubyz:kiln/back",
	.texture_front = "cubyz:kiln/front",
	.texture_left = "cubyz:kiln/side",
	.texture_right = "cubyz:kiln/side",
	.texture_top = "cubyz:kiln/top",
	.texture_bottom = "cubyz:kiln/bottom",
}

```

`assets/cubyz/blocks/lamp.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.emittedLight = 0xd9cab4,
	.texture = "cubyz:lamp",
	.texture_top = "cubyz:lamp_top",
	.texture_bottom = "cubyz:lamp_top",
}

```

`assets/cubyz/blocks/lantern/_defaults.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 0.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.viewThrough = true,
	.rotation = "cubyz:sign",
	.model = .{
		.side = "cubyz:lantern/side",
		.ceiling = "cubyz:lantern/ceiling",
		.floor = "cubyz:lantern/floor",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/lantern/coal.zig.zon`:

```zon
.{
	.emittedLight = 0xc5b29a,
	.texture = "cubyz:lantern/coal/side",
	.texture_top = "cubyz:lantern/coal/top",
	.texture_bottom = "cubyz:lantern/coal/top",
	.item = .{
		.texture = "lantern/coal.png",
	},
}

```

`assets/cubyz/blocks/lantern/sulfur.zig.zon`:

```zon
.{
	.emittedLight = 0x70b5de,
	.texture = "cubyz:lantern/sulfur/side",
	.texture_top = "cubyz:lantern/sulfur/top",
	.texture_bottom = "cubyz:lantern/sulfur/top",
	.item = .{
		.texture = "lantern/sulfur.png",
	},
}

```

`assets/cubyz/blocks/lava.zig.zon`:

```zon
.{
	.tags = .{.fluid},
	.drops = .{},
	.selectable = false,
	.replacable = true,
	.degradable = true,
	.transparent = true,
	.hasBackFace = true,
	.collide = false,
	.absorbedLight = 0x0084ff,
	.emittedLight = 0xff7b00,
	.density = 3,
	.terminalVelocity = 0.8,
	.mobility = 0.1,
	.model = "cubyz:cube",
	.texture = "cubyz:lava",
	.onTouch = .{
		.type = .hurt,
		.dps = 2.0,
		.damageType = .heat,
	},
}

```

`assets/cubyz/blocks/leaves/_defaults.zig.zon`:

```zon
.{
	.onUpdate = .{
		.type = .decay,
		.prevention = .{.log, .branch},
		.drops = .{
			.{.chance = 0.01, .items = .{"cubyz:apple"}},
		},
	},
	.drops = .{
		.{.items = .{.auto}},
		.{.chance = 0.01, .items = .{"cubyz:apple"}},
	},
	.rotation = "cubyz:decayable",
	.tags = .{.cuttable, .leaf},
	.blockHealth = 0.5,
	.degradable = true,
	.alwaysViewThrough = true,
	.absorbedLight = 0x363436,
	.model = "cubyz:cube",
}

```

`assets/cubyz/blocks/leaves/baobab.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/baobab",
	.lodReplacement = "cubyz:leaves/opaque/baobab",
	.opaqueVariant = "cubyz:leaves/opaque/baobab",
}

```

`assets/cubyz/blocks/leaves/birch.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/birch",
	.lodReplacement = "cubyz:leaves/opaque/birch",
	.opaqueVariant = "cubyz:leaves/opaque/birch",
}

```

`assets/cubyz/blocks/leaves/dead.zig.zon`:

```zon
.{
	.absorbedLight = 0x222222,
	.texture = "cubyz:leaves/dead",
	.lodReplacement = "cubyz:leaves/opaque/dead",
	.opaqueVariant = "cubyz:leaves/opaque/dead",
}

```

`assets/cubyz/blocks/leaves/mahogany.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/mahogany",
	.lodReplacement = "cubyz:leaves/opaque/mahogany",
	.opaqueVariant = "cubyz:leaves/opaque/mahogany",
}

```

`assets/cubyz/blocks/leaves/oak.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/oak",
	.lodReplacement = "cubyz:leaves/opaque/oak",
	.opaqueVariant = "cubyz:leaves/opaque/oak",
}

```

`assets/cubyz/blocks/leaves/opaque/_defaults.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .leaf},
	.hasItem = false,
	.absorbedLight = 0x363436,
	.model = "cubyz:cube",
}

```

`assets/cubyz/blocks/leaves/opaque/baobab.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/baobab",
}

```

`assets/cubyz/blocks/leaves/opaque/birch.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/birch",
}

```

`assets/cubyz/blocks/leaves/opaque/dead.zig.zon`:

```zon
.{
	.absorbedLight = 0x222222,
	.texture = "cubyz:leaves/opaque/dead",
}

```

`assets/cubyz/blocks/leaves/opaque/mahogany.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/mahogany",
}

```

`assets/cubyz/blocks/leaves/opaque/oak.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/oak",
}

```

`assets/cubyz/blocks/leaves/opaque/palm.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/palm",
}

```

`assets/cubyz/blocks/leaves/opaque/pine.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/pine",
}

```

`assets/cubyz/blocks/leaves/opaque/red.zig.zon`:

```zon
.{
	.absorbedLight = 0x213241,
	.texture = "cubyz:leaves/opaque/red",
}

```

`assets/cubyz/blocks/leaves/opaque/willow.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/opaque/willow",
}

```

`assets/cubyz/blocks/leaves/opaque/yellow.zig.zon`:

```zon
.{
	.absorbedLight = 0x1C1C38,
	.texture = "cubyz:leaves/opaque/yellow",
}

```

`assets/cubyz/blocks/leaves/palm.zig.zon`:

```zon
.{
	.model = "cubyz:cube_hanging_planes",
	.texture = "cubyz:leaves/palm",
	.texture12 = "cubyz:leaves/palm_hanging",
	.lodReplacement = "cubyz:leaves/opaque/palm",
	.opaqueVariant = "cubyz:leaves/opaque/palm",
}

```

`assets/cubyz/blocks/leaves/pine.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/pine",
	.lodReplacement = "cubyz:leaves/opaque/pine",
	.opaqueVariant = "cubyz:leaves/opaque/pine",
}

```

`assets/cubyz/blocks/leaves/red.zig.zon`:

```zon
.{
	.absorbedLight = 0x213241,
	.texture = "cubyz:leaves/red",
	.lodReplacement = "cubyz:leaves/opaque/red",
	.opaqueVariant = "cubyz:leaves/opaque/red",
}

```

`assets/cubyz/blocks/leaves/willow.zig.zon`:

```zon
.{
	.texture = "cubyz:leaves/willow",
	.lodReplacement = "cubyz:leaves/opaque/willow",
	.opaqueVariant = "cubyz:leaves/opaque/willow",
}

```

`assets/cubyz/blocks/leaves/yellow.zig.zon`:

```zon
.{
	.absorbedLight = 0x1C1C38,
	.texture = "cubyz:leaves/yellow",
	.lodReplacement = "cubyz:leaves/opaque/yellow",
	.opaqueVariant = "cubyz:leaves/opaque/yellow",
}

```

`assets/cubyz/blocks/lily_pad.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.alwaysViewThrough = true,
	.absorbedLight = 0x121012,
	.model = "cubyz:plane",
	.rotation = "cubyz:planar",
	.texture = "cubyz:lily_pad",
	.item = .{
		.texture = "lily_pad.png",
		.tags = .{.fluidPlaceable},
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/limestone/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .limestone},
	.blockHealth = 27.5,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 50,
			.massDamage = 1.0,
			.hardnessDamage = 3.4,
			.swingSpeed = 2.6,
			.textureRoughness = 0.5,
			.colors = .{
				0xff70583E, 0xff886D52, 0xffAB8D6A, 0xffC09B6E, 0xffCCA780,
			},
			.modifiers = .{
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .limestone,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/limestone/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:limestone/base",
}

```

`assets/cubyz/blocks/limestone/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:limestone/bricks",
}

```

`assets/cubyz/blocks/limestone/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:limestone/tile",
}

```

`assets/cubyz/blocks/limestone/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:limestone/wall",
	.texture_top = "cubyz:limestone/wall_top",
	.texture_bottom = "cubyz:limestone/wall_top",
	.item = .{
		.texture = "wall/limestone.png",
	},
}

```

`assets/cubyz/blocks/log/_defaults.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:log",
	.model = "cubyz:cube",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/log/baobab.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/baobab/dot",
	.texture1 = "cubyz:log/baobab/line",
	.texture2 = "cubyz:log/baobab/bend",
	.texture3 = "cubyz:log/baobab/intersection",
	.texture4 = "cubyz:log/baobab/cross",
	.texture5 = "cubyz:log/baobab/top",
}

```

`assets/cubyz/blocks/log/birch.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/birch/dot",
	.texture1 = "cubyz:log/birch/line",
	.texture2 = "cubyz:log/birch/bend",
	.texture3 = "cubyz:log/birch/intersection",
	.texture4 = "cubyz:log/birch/cross",
	.texture5 = "cubyz:log/birch/top",
}

```

`assets/cubyz/blocks/log/bolete.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .mushroom},
	.texture0 = "cubyz:log/bolete/dot",
	.texture1 = "cubyz:log/bolete/line",
	.texture2 = "cubyz:log/bolete/bend",
	.texture3 = "cubyz:log/bolete/intersection",
	.texture4 = "cubyz:log/bolete/cross",
	.texture5 = "cubyz:log/bolete/top",
}

```

`assets/cubyz/blocks/log/cactus.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable},
	.texture0 = "cubyz:log/cactus/dot",
	.texture1 = "cubyz:log/cactus/line",
	.texture2 = "cubyz:log/cactus/bend",
	.texture3 = "cubyz:log/cactus/intersection",
	.texture4 = "cubyz:log/cactus/cross",
	.texture5 = "cubyz:log/cactus/top",
	.onTouch = .{
		.type = .hurt,
		.dps = 0.5,
		.damageType = .spiky,
	},
}

```

`assets/cubyz/blocks/log/glimmergill.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .mushroom},
	.texture0 = "cubyz:log/glimmergill/dot",
	.texture1 = "cubyz:log/glimmergill/line",
	.texture2 = "cubyz:log/glimmergill/bend",
	.texture3 = "cubyz:log/glimmergill/intersection",
	.texture4 = "cubyz:log/glimmergill/cross",
	.texture5 = "cubyz:log/glimmergill/top",
}

```

`assets/cubyz/blocks/log/mahogany.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/mahogany/dot",
	.texture1 = "cubyz:log/mahogany/line",
	.texture2 = "cubyz:log/mahogany/bend",
	.texture3 = "cubyz:log/mahogany/intersection",
	.texture4 = "cubyz:log/mahogany/cross",
	.texture5 = "cubyz:log/mahogany/top",
}

```

`assets/cubyz/blocks/log/oak.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/oak/dot",
	.texture1 = "cubyz:log/oak/line",
	.texture2 = "cubyz:log/oak/bend",
	.texture3 = "cubyz:log/oak/intersection",
	.texture4 = "cubyz:log/oak/cross",
	.texture5 = "cubyz:log/oak/top",
}

```

`assets/cubyz/blocks/log/palm.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/palm/dot",
	.texture1 = "cubyz:log/palm/line",
	.texture2 = "cubyz:log/palm/bend",
	.texture3 = "cubyz:log/palm/intersection",
	.texture4 = "cubyz:log/palm/cross",
	.texture5 = "cubyz:log/palm/top",
}

```

`assets/cubyz/blocks/log/pine.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/pine/dot",
	.texture1 = "cubyz:log/pine/line",
	.texture2 = "cubyz:log/pine/bend",
	.texture3 = "cubyz:log/pine/intersection",
	.texture4 = "cubyz:log/pine/cross",
	.texture5 = "cubyz:log/pine/top",
}

```

`assets/cubyz/blocks/log/toadstool.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .mushroom},
	.texture0 = "cubyz:log/toadstool/dot",
	.texture1 = "cubyz:log/toadstool/line",
	.texture2 = "cubyz:log/toadstool/bend",
	.texture3 = "cubyz:log/toadstool/intersection",
	.texture4 = "cubyz:log/toadstool/cross",
	.texture5 = "cubyz:log/toadstool/top",
}

```

`assets/cubyz/blocks/log/willow.zig.zon`:

```zon
.{
	.texture0 = "cubyz:log/willow/dot",
	.texture1 = "cubyz:log/willow/line",
	.texture2 = "cubyz:log/willow/bend",
	.texture3 = "cubyz:log/willow/intersection",
	.texture4 = "cubyz:log/willow/cross",
	.texture5 = "cubyz:log/willow/top",
}

```

`assets/cubyz/blocks/lush_grass.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 7,
	.drops = .{
		.{.items = .{"cubyz:mud"}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:lush_grass_top",
	.texture_top = "cubyz:lush_grass_top",
	.texture_bottom = "cubyz:mud",
}

```

`assets/cubyz/blocks/lush_grass_vegetation.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:lush_grass_vegetation",
	.item = .{
		.texture = "lush_grass.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/magma.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable},
	.blockHealth = 15,
	.drops = .{
		.{.items = .{.auto}},
	},
	.emittedLight = 0x884928,
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:magma",
	.onTouch = .{
		.type = .hurt,
		.dps = 0.5,
		.damageType = .heat,
	},
}

```

`assets/cubyz/blocks/mahogany_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/mahogany/dot",
	.texture1 = "cubyz:branch/mahogany/half_line",
	.texture2 = "cubyz:branch/mahogany/line",
	.texture3 = "cubyz:branch/mahogany/bend",
	.texture4 = "cubyz:branch/mahogany/intersection",
	.texture5 = "cubyz:branch/mahogany/cross",
	.item = .{
		.material = .{
			.durability = 26,
			.massDamage = 0.45,
			.hardnessDamage = 0.5,
			.swingSpeed = 6.9,
			.textureRoughness = 0.7,
			.colors = .{
				0xff4b3324, 0xff5f4029, 0xff724e2e, 0xff885d36, 0xff724e2e,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/mahogany.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/mahogany_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:mahogany_fence",
	.texture_top = "cubyz:mahogany_fence_top",
	.texture_bottom = "cubyz:mahogany_fence_top",
	.item = .{
		.texture = "fence/mahogany.png",
	},
}

```

`assets/cubyz/blocks/mahogany_log.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/mahogany"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:mahogany_log",
	.texture_top = "cubyz:mahogany_log_top",
	.texture_bottom = "cubyz:mahogany_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/mahogany_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 26,
			.massDamage = 0.95,
			.hardnessDamage = 1.0,
			.swingSpeed = 4.6,
			.textureRoughness = 0.7,
			.colors = .{
				0xff734c2f, 0xff8e5d38, 0xffa26a3f, 0xffbd7e48, 0xffcf9459,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:mahogany_planks",
}

```

`assets/cubyz/blocks/mahogany_top.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/mahogany"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:mahogany_log",
	.texture_top = "cubyz:mahogany_log",
	.texture_bottom = "cubyz:mahogany_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/marble/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .marble},
	.blockHealth = 28,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 55,
			.massDamage = 1.0,
			.hardnessDamage = 3.7,
			.swingSpeed = 3.0,
			.textureRoughness = 1.0,
			.colors = .{
				0xffA89B94, 0xffC9C0BB, 0xffECE9E3, 0xffFBF8F1, 0xffECE9E3,
			},
			.modifiers = .{
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .marble,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/marble/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:marble/base",
}

```

`assets/cubyz/blocks/marble/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:marble/bricks",
}

```

`assets/cubyz/blocks/marble/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:marble/tile",
}

```

`assets/cubyz/blocks/marble/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:marble/wall",
	.texture_top = "cubyz:marble/wall_top",
	.texture_bottom = "cubyz:marble/wall_top",
	.item = .{
		.texture = "wall/marble.png",
	},
}

```

`assets/cubyz/blocks/marigold.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x121012,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:marigold",
	.item = .{
		.texture = "marigold.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/moss.zig.zon`:

```zon
.{
	.tags = .{.leaf, .cuttable},
	.blockHealth = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:moss",
	.item = .{
		.texture = "moss.png",
	},
}

```

`assets/cubyz/blocks/mud.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 6.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:mud",
}

```

`assets/cubyz/blocks/oak_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/oak/dot",
	.texture1 = "cubyz:branch/oak/half_line",
	.texture2 = "cubyz:branch/oak/line",
	.texture3 = "cubyz:branch/oak/bend",
	.texture4 = "cubyz:branch/oak/intersection",
	.texture5 = "cubyz:branch/oak/cross",
	.item = .{
		.material = .{
			.durability = 28,
			.massDamage = 0.5,
			.hardnessDamage = 0.45,
			.swingSpeed = 7.2,
			.textureRoughness = 0.7,
			.colors = .{
				0xff463724, 0xff55422b, 0xff6a5030, 0xff836136, 0xff6a5030,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/oak.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/oak_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:oak_fence",
	.texture_top = "cubyz:oak_fence_top",
	.texture_bottom = "cubyz:oak_fence_top",
	.item = .{
		.texture = "fence/oak.png",
	},
}

```

`assets/cubyz/blocks/oak_log.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/oak"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:oak_log",
	.texture_top = "cubyz:oak_log_top",
	.texture_bottom = "cubyz:oak_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/oak_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 28,
			.massDamage = 0.95,
			.hardnessDamage = 0.95,
			.swingSpeed = 4.8,
			.textureRoughness = 0.7,
			.colors = .{
				0xff835e37, 0xffa37543, 0xffbd8a4f, 0xffd3a164, 0xffe5b570,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:oak_planks",
}

```

`assets/cubyz/blocks/oak_top.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/oak"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:oak_log",
	.texture_top = "cubyz:oak_log",
	.texture_bottom = "cubyz:oak_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/obsidian.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 16,
	.blockResistance = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 55,
			.massDamage = 1.7,
			.hardnessDamage = 5.7,
			.swingSpeed = 2.5,
			.textureRoughness = 0.1,
			.colors = .{
				0xff0F0811, 0xff19121C, 0xff312436, 0xff69486B, 0xff462F47,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.33,
				},
			},
		},
	},
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:obsidian",
}

```

`assets/cubyz/blocks/osier.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x121012,
	.model = "cubyz:plane",
	.rotation = "cubyz:carpet",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture = "cubyz:osier",
	.item = .{
		.texture = "osier.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/palm_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:palm_fence",
	.texture_top = "cubyz:palm_fence_top",
	.texture_bottom = "cubyz:palm_fence_top",
	.item = .{
		.texture = "fence/palm.png",
	},
}

```

`assets/cubyz/blocks/palm_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 23,
			.massDamage = 0.8,
			.hardnessDamage = 0.8,
			.swingSpeed = 5.2,
			.colors = .{
				0xffa38041, 0xffc78a49, 0xffdcab5a, 0xfff1c061, 0xfffed87c,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:palm_planks",
}

```

`assets/cubyz/blocks/pebbles.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable},
	.blockHealth = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:pebbles",
	.item = .{
		.texture = "pebbles.png",
	},
}

```

`assets/cubyz/blocks/permafrost.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 6.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:permafrost",
}

```

`assets/cubyz/blocks/pine_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/pine/dot",
	.texture1 = "cubyz:branch/pine/half_line",
	.texture2 = "cubyz:branch/pine/line",
	.texture3 = "cubyz:branch/pine/bend",
	.texture4 = "cubyz:branch/pine/intersection",
	.texture5 = "cubyz:branch/pine/cross",
	.item = .{
		.material = .{
			.durability = 20,
			.massDamage = 0.5,
			.hardnessDamage = 0.35,
			.swingSpeed = 6.6,
			.textureRoughness = 0.7,
			.colors = .{
				0xff312a1e, 0xff3c3324, 0xff4a3c28, 0xff614e33, 0xff4a3c28,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/pine.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/pine_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:pine_fence",
	.texture_top = "cubyz:pine_fence_top",
	.texture_bottom = "cubyz:pine_fence_top",
	.item = .{
		.texture = "fence/pine.png",
	},
}

```

`assets/cubyz/blocks/pine_log.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/pine"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:pine_log",
	.texture_top = "cubyz:pine_log_top",
	.texture_bottom = "cubyz:pine_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/pine_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 20,
			.massDamage = 0.75,
			.hardnessDamage = 0.75,
			.swingSpeed = 4.4,
			.textureRoughness = 0.7,
			.colors = .{
				0xff533f27, 0xff664c2e, 0xff795a37, 0xff8c6b41, 0xffa37b46,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:pine_planks",
}

```

`assets/cubyz/blocks/pine_top.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/pine"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:pine_log",
	.texture_top = "cubyz:pine_log",
	.texture_bottom = "cubyz:pine_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/red_leaf_pile.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .leaf},
	.blockHealth = 0.1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x000000,
	.model = .{
		.model = "cubyz:plane",
		.states = 4,
	},
	.rotation = "cubyz:texture_pile",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture0 = "cubyz:red_leaf_pile/0",
	.texture1 = "cubyz:red_leaf_pile/1",
	.texture2 = "cubyz:red_leaf_pile/2",
	.texture3 = "cubyz:red_leaf_pile/3",
	.item = .{
		.texture = "red_leaf_pile.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/resin.zig.zon`:

```zon
.{
	.tags = .{.choppable},
	.blockHealth = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:resin",
	.item = .{
		.texture = "resin.png",
		.material = .{
			.durability = 200,
			.massDamage = 1.2,
			.hardnessDamage = 0.8,
			.swingSpeed = 5.1,
			.textureRoughness = 0.1,
			.colors = .{
				0xff7e331f, 0xffa03d25, 0xffc34b27, 0xffdf682d, 0xfffc813a,
			},
		},
	},
}

```

`assets/cubyz/blocks/resin_block.zig.zon`:

```zon
.{
	.tags = .{.choppable},
	.blockHealth = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.transparent = true,
	.hasBackFace = true,
	.model = "cubyz:cube",
	.absorbedLight = 0x30a8cc,
	.texture = "cubyz:resin_block",
	.friction = 30,
}

```

`assets/cubyz/blocks/ruby_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 55,
	.blockResistance = 9,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:ruby_block",
}

```

`assets/cubyz/blocks/ruby_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 100,
	.blockResistance = 9,
	.item = .{
		.texture = "ruby.png",
		.material = .{
			.durability = 300,
			.massDamage = 0.9,
			.hardnessDamage = 8.5,
			.swingSpeed = 4.5,
			.textureRoughness = 0.1,
			.colors = .{
				0xff9b2129, 0xffbd2936, 0xffda2f2f, 0xfffb4845, 0xffff7261,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.45,
					.restriction = .{
						.id = .not,
						.child = .{
							.id = .encased,
							.tag = .precious,
							.amount = 4,
						},
					},
				},
			},
		},
	},
	.ore = .{
		.veins = 4.5,
		.size = 3,
		.height = -5000,
		.minHeight = -15000,
		.density = 0.05,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:ruby_ore",
}

```

`assets/cubyz/blocks/sand.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:sand",
}

```

`assets/cubyz/blocks/sandstone/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .sandstone},
	.blockHealth = 20,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 10,
			.massDamage = 1.0,
			.hardnessDamage = 3.0,
			.swingSpeed = 3.0,
			.textureRoughness = 3.0,
			.colors = .{
				0xffAF8354, 0xffC89965, 0xffE6B776, 0xffEEC589, 0xffEDD0AD,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.20,
					.restriction = .{
						.id = .not,
						.child = .{
							.id = .encased,
							.tag = .precious,
							.amount = 2,
						},
					},
				},
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .sandstone,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/sandstone/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:sandstone/base",
}

```

`assets/cubyz/blocks/sandstone/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:sandstone/bricks",
}

```

`assets/cubyz/blocks/sandstone/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:sandstone/tile",
}

```

`assets/cubyz/blocks/sandstone/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:sandstone/wall",
	.texture_top = "cubyz:sandstone/wall_top",
	.texture_bottom = "cubyz:sandstone/wall_top",
	.item = .{
		.texture = "wall/sandstone.png",
	},
}

```

`assets/cubyz/blocks/sbb/child/_defaults.zig.zon`:

```zon
.{
	.tags = .{.sbbChild},
	.model = "cubyz:cube",
	.rotation = "cubyz:direction",
}

```

`assets/cubyz/blocks/sbb/child/aqua.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/aqua",
	.texture_top = "cubyz:sbb/child/top/aqua",
	.texture_bottom = "cubyz:sbb/child/bottom/aqua",
}

```

`assets/cubyz/blocks/sbb/child/black.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/black",
	.texture_top = "cubyz:sbb/child/top/black",
	.texture_bottom = "cubyz:sbb/child/bottom/black",
}

```

`assets/cubyz/blocks/sbb/child/blue.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/blue",
	.texture_top = "cubyz:sbb/child/top/blue",
	.texture_bottom = "cubyz:sbb/child/bottom/blue",
}

```

`assets/cubyz/blocks/sbb/child/brown.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/brown",
	.texture_top = "cubyz:sbb/child/top/brown",
	.texture_bottom = "cubyz:sbb/child/bottom/brown",
}

```

`assets/cubyz/blocks/sbb/child/crimson.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/crimson",
	.texture_top = "cubyz:sbb/child/top/crimson",
	.texture_bottom = "cubyz:sbb/child/bottom/crimson",
}

```

`assets/cubyz/blocks/sbb/child/cyan.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/cyan",
	.texture_top = "cubyz:sbb/child/top/cyan",
	.texture_bottom = "cubyz:sbb/child/bottom/cyan",
}

```

`assets/cubyz/blocks/sbb/child/dark_grey.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/dark_grey",
	.texture_top = "cubyz:sbb/child/top/dark_grey",
	.texture_bottom = "cubyz:sbb/child/bottom/dark_grey",
}

```

`assets/cubyz/blocks/sbb/child/green.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/green",
	.texture_top = "cubyz:sbb/child/top/green",
	.texture_bottom = "cubyz:sbb/child/bottom/green",
}

```

`assets/cubyz/blocks/sbb/child/grey.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/grey",
	.texture_top = "cubyz:sbb/child/top/grey",
	.texture_bottom = "cubyz:sbb/child/bottom/grey",
}

```

`assets/cubyz/blocks/sbb/child/indigo.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/indigo",
	.texture_top = "cubyz:sbb/child/top/indigo",
	.texture_bottom = "cubyz:sbb/child/bottom/indigo",
}

```

`assets/cubyz/blocks/sbb/child/lime.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/lime",
	.texture_top = "cubyz:sbb/child/top/lime",
	.texture_bottom = "cubyz:sbb/child/bottom/lime",
}

```

`assets/cubyz/blocks/sbb/child/magenta.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/magenta",
	.texture_top = "cubyz:sbb/child/top/magenta",
	.texture_bottom = "cubyz:sbb/child/bottom/magenta",
}

```

`assets/cubyz/blocks/sbb/child/orange.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/orange",
	.texture_top = "cubyz:sbb/child/top/orange",
	.texture_bottom = "cubyz:sbb/child/bottom/orange",
}

```

`assets/cubyz/blocks/sbb/child/pink.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/pink",
	.texture_top = "cubyz:sbb/child/top/pink",
	.texture_bottom = "cubyz:sbb/child/bottom/pink",
}

```

`assets/cubyz/blocks/sbb/child/purple.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/purple",
	.texture_top = "cubyz:sbb/child/top/purple",
	.texture_bottom = "cubyz:sbb/child/bottom/purple",
}

```

`assets/cubyz/blocks/sbb/child/red.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/red",
	.texture_top = "cubyz:sbb/child/top/red",
	.texture_bottom = "cubyz:sbb/child/bottom/red",
}

```

`assets/cubyz/blocks/sbb/child/violet.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/violet",
	.texture_top = "cubyz:sbb/child/top/violet",
	.texture_bottom = "cubyz:sbb/child/bottom/violet",
}

```

`assets/cubyz/blocks/sbb/child/viridian.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/viridian",
	.texture_top = "cubyz:sbb/child/top/viridian",
	.texture_bottom = "cubyz:sbb/child/bottom/viridian",
}

```

`assets/cubyz/blocks/sbb/child/white.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/white",
	.texture_top = "cubyz:sbb/child/top/white",
	.texture_bottom = "cubyz:sbb/child/bottom/white",
}

```

`assets/cubyz/blocks/sbb/child/yellow.zig.zon`:

```zon
.{
	.texture = "cubyz:sbb/child/side/yellow",
	.texture_top = "cubyz:sbb/child/top/yellow",
	.texture_bottom = "cubyz:sbb/child/bottom/yellow",
}

```

`assets/cubyz/blocks/sbb/origin.zig.zon`:

```zon
.{
	.tags = .{.sbbOrigin},
	.model = "cubyz:cube",
	.rotation = "cubyz:direction",
	.texture = "cubyz:sbb/origin_side",
	.texture_top = "cubyz:sbb/origin_top",
	.texture_bottom = "cubyz:sbb/origin_bottom",
}

```

`assets/cubyz/blocks/sign/_defaults.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.viewThrough = true,
	.alwaysViewThrough = true,
	.collide = false,
	.rotation = "cubyz:sign",
	.model = .{
		.side = "cubyz:sign/side",
		.ceiling = "cubyz:sign/ceiling",
		.floor = "cubyz:sign/floor",
	},
	.blockEntity = .sign,
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/sign/baobab.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/baobab",
	.item = .{
		.texture = "sign/baobab.png",
	},
}

```

`assets/cubyz/blocks/sign/birch.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/birch",
	.item = .{
		.texture = "sign/birch.png",
	},
}

```

`assets/cubyz/blocks/sign/mahogany.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/mahogany",
	.item = .{
		.texture = "sign/mahogany.png",
	},
}

```

`assets/cubyz/blocks/sign/oak.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/oak",
	.item = .{
		.texture = "sign/oak.png",
	},
}

```

`assets/cubyz/blocks/sign/palm.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/palm",
	.item = .{
		.texture = "sign/palm.png",
	},
}

```

`assets/cubyz/blocks/sign/pine.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/pine",
	.item = .{
		.texture = "sign/pine.png",
	},
}

```

`assets/cubyz/blocks/sign/willow.zig.zon`:

```zon
.{
	.texture = "cubyz:sign/willow",
	.item = .{
		.texture = "sign/willow.png",
	},
}

```

`assets/cubyz/blocks/silver_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 50,
	.blockResistance = 7,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:silver_block",
}

```

`assets/cubyz/blocks/silver_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 60,
	.blockResistance = 7.0,
	.ore = .{
		.veins = 3,
		.size = 15,
		.height = -500,
		.density = 0.25,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:silver_ore",
	.item = .{
		.texture = "raw_silver.png",
	},
}

```

`assets/cubyz/blocks/slate/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .slate},
	.blockHealth = 30,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 60,
			.massDamage = 1.0,
			.hardnessDamage = 3.9,
			.swingSpeed = 3.2,
			.textureRoughness = 1.0,
			.colors = .{
				0xff444444, 0xff626262, 0xff7A7876, 0xff878583, 0xff9c9996,
			},
			.modifiers = .{
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .slate,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/slate/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:slate/base",
}

```

`assets/cubyz/blocks/slate/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:slate/bricks",
}

```

`assets/cubyz/blocks/slate/cobble.zig.zon`:

```zon
.{
	.model = "cubyz:cube",
	.texture = "cubyz:slate/cobble",
	.rotation = "cubyz:stairs",
}

```

`assets/cubyz/blocks/slate/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:slate/tile",
}

```

`assets/cubyz/blocks/slate/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:slate/wall",
	.texture_top = "cubyz:slate/wall_top",
	.texture_bottom = "cubyz:slate/wall_top",
	.item = .{
		.texture = "wall/slate.png",
	},
}

```

`assets/cubyz/blocks/snow.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x6f6259,
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:snow",
}

```

`assets/cubyz/blocks/soil.zig.zon`:

```zon
.{
	.tags = .{.diggable},
	.blockHealth = 6.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:soil",
}

```

`assets/cubyz/blocks/sulfur_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 25,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:sulfur_block",
}

```

`assets/cubyz/blocks/sulfur_lamp.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.emittedLight = 0xa6deff,
	.texture = "cubyz:sulfur_lamp",
	.texture_top = "cubyz:sulfur_lamp_top",
	.texture_bottom = "cubyz:sulfur_lamp_top",
}

```

`assets/cubyz/blocks/sulfur_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 40,
	.blockResistance = 1,
	.item = .{
		.texture = "sulfur.png",
		.material = .{
			.durability = 20,
			.massDamage = 3.5,
			.hardnessDamage = 1.0,
			.swingSpeed = 3.7,
			.textureRoughness = 0.1,
			.colors = .{
				0xffa99942, 0xffbeb349, 0xffe5c64c, 0xfffae764, 0xfffeffc9,
			},
		},
	},
	.ore = .{
		.veins = 3,
		.size = 50,
		.height = -800,
		.density = 0.8,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:sulfur_ore",
}

```

`assets/cubyz/blocks/sulfur_torch.zig.zon`:

```zon
.{
	.tags = .{.choppable},
	.blockHealth = 0.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.replacable = true,
	.emittedLight = 0x2b81b2,
	.viewThrough = true,
	.absorbedLight = 0x010101,
	.collide = false,
	.rotation = "cubyz:torch",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.model = .{
		.base = "cubyz:torch",
		.side = "cubyz:torch_side",
	},
	.texture = "cubyz:sulfur_torch",
	.item = .{
		.texture = "sulfur_torch.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/terracotta/_defaults.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 20,
	.blockResistance = 1,
	.drops = .{
		.{.items = .{.auto}},
	},
}

```

`assets/cubyz/blocks/terracotta/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:terracotta/base",
}

```

`assets/cubyz/blocks/terracotta/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:terracotta/bricks",
}

```

`assets/cubyz/blocks/terracotta/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:terracotta/tile",
}

```

`assets/cubyz/blocks/terracotta/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:terracotta/wall",
	.texture_top = "cubyz:terracotta/wall_top",
	.texture_bottom = "cubyz:terracotta/wall_top",
	.item = .{
		.texture = "wall/terracotta.png",
	},
}

```

`assets/cubyz/blocks/textures/bluebells.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/cactus_flower.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/cactus_flower_top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/castilleja.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/castilleja_top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/cold_grass_vegetation.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/daffodil.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/daffodil_top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/dry_grass_vegetation.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/fern.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/fog/blue.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0x0000ff,
}

```

`assets/cubyz/blocks/textures/fog/cyan.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0x00ffff,
}

```

`assets/cubyz/blocks/textures/fog/green.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0x00ff00,
}

```

`assets/cubyz/blocks/textures/fog/magenta.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0xff00ff,
}

```

`assets/cubyz/blocks/textures/fog/red.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0xff0000,
}

```

`assets/cubyz/blocks/textures/fog/yellow.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0xffff00,
}

```

`assets/cubyz/blocks/textures/furnace/front_lit.zig.zon`:

```zon
.{
	.frames = 4,
	.time = 150,
}

```

`assets/cubyz/blocks/textures/furnace/side_lit.zig.zon`:

```zon
.{
	.frames = 4,
	.time = 150,
}

```

`assets/cubyz/blocks/textures/grass_vegetation.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/hibiscus.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/hibiscus_top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/kiln/front_lit.zig.zon`:

```zon
.{
	.frames = 4,
	.time = 150,
}

```

`assets/cubyz/blocks/textures/kiln/side_lit.zig.zon`:

```zon
.{
	.frames = 4,
	.time = 150,
}

```

`assets/cubyz/blocks/textures/lava.zig.zon`:

```zon
.{
	.fogDensity = 0.7,
	.fogColor = 0xff9000,
}

```

`assets/cubyz/blocks/textures/lush_grass_vegetation.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/marigold.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/trumpet_lily.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/trumpet_lily_top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/tussock.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vetch.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vine/glimmer_worms/bottom.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vine/glimmer_worms/top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vine/mahogany/bottom.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vine/mahogany/top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vine/willow/bottom.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/vine/willow/top.zig.zon`:

```zon
.{
	.hasOcclusion = false,
}

```

`assets/cubyz/blocks/textures/water.zig.zon`:

```zon
.{
	.fogDensity = 0.02,
	.fogColor = 0x203860,
	.frames = 16,
	.time = 400,
}

```

`assets/cubyz/blocks/toadstool.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .mushroom},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.replacable = true,
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x010101,
	.collide = false,
	.rotation = "cubyz:torch",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.model = .{
		.base = "cubyz:toadstool/floor",
		.side = "cubyz:toadstool/shelf",
	},
	.texture = "cubyz:toadstool_side",
	.texture_top = "cubyz:toadstool_top",
	.texture_bottom = "cubyz:toadstool_bottom",
	.item = .{
		.texture = "toadstool.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/toadstool_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/toadstool/dot",
	.texture1 = "cubyz:branch/toadstool/half_line",
	.texture2 = "cubyz:branch/toadstool/line",
	.texture3 = "cubyz:branch/toadstool/bend",
	.texture4 = "cubyz:branch/toadstool/intersection",
	.texture5 = "cubyz:branch/toadstool/cross",
	.item = .{
		.material = .{
			.durability = 230,
			.massDamage = 1.2,
			.hardnessDamage = 0.0,
			.swingSpeed = 4.4,
			.textureRoughness = 0.5,
			.colors = .{
				0xffa0876d, 0xffb99f82, 0xffd2b79b, 0xffeed4b4, 0xffeed4b4,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
		.texture = "branch/toadstool.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/toadstool_cap.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 3,
	.bounciness = 1.0,
	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:toadstool_cap",
}

```

`assets/cubyz/blocks/toadstool_stem.zig.zon`:

```zon
.{
	.tags = .{.choppable, .cuttable, .mushroom},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{"cubyz:log/toadstool"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:toadstool_stem",
}

```

`assets/cubyz/blocks/torch.zig.zon`:

```zon
.{
	.tags = .{.choppable},
	.blockHealth = 0.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.replacable = true,
	.emittedLight = 0xa58d73,
	.viewThrough = true,
	.absorbedLight = 0x010101,
	.collide = false,
	.rotation = "cubyz:torch",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.model = .{
		.base = "cubyz:torch",
		.side = "cubyz:torch_side",
	},
	.texture = "cubyz:torch",
	.item = .{
		.texture = "torch.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/trumpet_lily.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:flower/height_10",
	.rotation = "cubyz:planar",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture = "cubyz:trumpet_lily",
	.texture_top = "cubyz:trumpet_lily_top",
	.texture_bottom = "cubyz:trumpet_lily_top",
	.item = .{
		.texture = "trumpet_lily.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/tussock.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:tussock",
	.item = .{
		.texture = "tussock.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/uranium_block.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 50,
	.blockResistance = 17.5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:uranium_block",
}

```

`assets/cubyz/blocks/uranium_ore.zig.zon`:

```zon
.{
	.tags = .{.mineable},
	.blockHealth = 40,
	.blockResistance = 17.5,
	.ore = .{
		.veins = 1.5,
		.size = 15,
		.height = -1500,
		.density = 0.4,
	},
	.drops = .{
		.{.items = .{.auto}},
	},
	.emittedLight = 0x214200,
	.rotation = "cubyz:ore",
	.model = "cubyz:cube",
	.texture = "cubyz:uranium_ore",
	.item = .{
		.texture = "raw_uranium.png",
	},
}

```

`assets/cubyz/blocks/vetch.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.2,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x121012,
	.collide = false,
	.model = "cubyz:cross",
	.texture = "cubyz:vetch",
	.item = .{
		.texture = "vetch.png",
	},
	.lodReplacement = "cubyz:air",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
}

```

`assets/cubyz/blocks/vine/_defaults.zig.zon`:

```zon
.{
	.tags = .{.cuttable},
	.blockHealth = 0.3,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.viewThrough = true,
	.absorbedLight = 0x000000,
	.collide = false,
	.model = .{
		.top = "cubyz:cross",
		.bottom = "cubyz:cross_with_texture_1",
	},
	.rotation = "cubyz:hanging",
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/blocks/vine/glimmer_worms.zig.zon`:

```zon
.{
	.texture0 = "cubyz:vine/glimmer_worms/top",
	.texture1 = "cubyz:vine/glimmer_worms/bottom",
	.emittedLight = 0x392862,
	.item = .{
		.texture = "vine/glimmer_worms.png",
	},
}

```

`assets/cubyz/blocks/vine/mahogany.zig.zon`:

```zon
.{
	.texture0 = "cubyz:vine/mahogany/top",
	.texture1 = "cubyz:vine/mahogany/bottom",
	.item = .{
		.texture = "vine/mahogany.png",
	},
}

```

`assets/cubyz/blocks/vine/willow.zig.zon`:

```zon
.{
	.texture0 = "cubyz:vine/willow/top",
	.texture1 = "cubyz:vine/willow/bottom",
	.item = .{
		.texture = "vine/willow.png",
	},
}

```

`assets/cubyz/blocks/void.zig.zon`:

```zon
.{
	.tags = .{.void},

	.transparent = true,
	.absorbedLight = 0x000000,
	.viewThrough = true,
	.hasBackFace = true,
	.rotation = "cubyz:no_rotation",
	.degradable = false,
	.collide = false,
	.texture = "cubyz:void",

	.drops = .{},
	.model = "cubyz:cube",
}

```

`assets/cubyz/blocks/voidstone/_defaults.zig.zon`:

```zon
.{
	.tags = .{.stone, .mineable, .voidStone},
	.blockHealth = 60,
	.blockResistance = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.item = .{
		.material = .{
			.durability = 200,
			.massDamage = 3.0,
			.hardnessDamage = 7.0,
			.swingSpeed = 4.7,
			.textureRoughness = 1.0,
			.colors = .{
				0xff030308, 0xff0D0C11, 0xff151420, 0xff1C1A2B, 0xff28253D,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.1,
				},
				.{
					.id = "good_at",
					.strength = 0.5,
					.tag = .voidStone,
					.restriction = .{
						.id = .encased,
						.tag = .precious,
						.amount = 2,
					},
				},
			},
		},
	},
}

```

`assets/cubyz/blocks/voidstone/base.zig.zon`:

```zon
.{
	.allowOres = true,
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:voidstone/base",
}

```

`assets/cubyz/blocks/voidstone/bricks.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:voidstone/bricks",
}

```

`assets/cubyz/blocks/voidstone/tile.zig.zon`:

```zon
.{
	.rotation = "cubyz:stairs",
	.model = "cubyz:cube",
	.texture = "cubyz:voidstone/tile",
}

```

`assets/cubyz/blocks/voidstone/wall.zig.zon`:

```zon
.{
	.rotation = "cubyz:fence",
	.model = "cubyz:wall",
	.texture = "cubyz:voidstone/wall",
	.texture_top = "cubyz:voidstone/wall_top",
	.texture_bottom = "cubyz:voidstone/wall_top",
	.item = .{
		.texture = "wall/voidstone.png",
	},
}

```

`assets/cubyz/blocks/water.zig.zon`:

```zon
.{
	.tags = .{.fluid},
	.drops = .{},
	.selectable = false,
	.replacable = true,
	.degradable = true,
	.transparent = true,
	.hasBackFace = true,
	.collide = false,
	.absorbedLight = 0x090501,
	.density = 0.998,
	.terminalVelocity = 5,
	.mobility = 0.6,
	.model = "cubyz:cube",
	.texture = "cubyz:water",
}

```

`assets/cubyz/blocks/willow_branch.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .branch},
	.onUpdate = .{
		.type = .decay,
	},
	.blockHealth = 4,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:branch",
	.model = .{
		.radius = 4,
	},
	.texture0 = "cubyz:branch/willow/dot",
	.texture1 = "cubyz:branch/willow/half_line",
	.texture2 = "cubyz:branch/willow/line",
	.texture3 = "cubyz:branch/willow/bend",
	.texture4 = "cubyz:branch/willow/intersection",
	.texture5 = "cubyz:branch/willow/cross",
	.item = .{
		.material = .{
			.durability = 20,
			.massDamage = 0.5,
			.hardnessDamage = 0.45,
			.swingSpeed = 7.2,
			.textureRoughness = 0.7,
			.colors = .{
				0xff2a2521, 0xff332d28, 0xff413930, 0xff4f453a, 0xff413930,
			},
			.modifiers = .{
				.{
					.id = "fragile",
					.strength = 0.10,
				},
			},
		},
		.texture = "branch/willow.png",
	},
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/willow_fence.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 5,
	.drops = .{
		.{.items = .{.auto}},
	},
	.absorbedLight = 0x202830,
	.rotation = "cubyz:fence",
	.model = "cubyz:fence",
	.texture = "cubyz:willow_fence",
	.texture_top = "cubyz:willow_fence_top",
	.texture_bottom = "cubyz:willow_fence_top",
	.item = .{
		.texture = "fence/willow.png",
	},
}

```

`assets/cubyz/blocks/willow_log.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/willow"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:willow_log",
	.texture_top = "cubyz:willow_log_top",
	.texture_bottom = "cubyz:willow_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/willow_planks.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood},
	.blockHealth = 6,
	.item = .{
		.material = .{
			.durability = 20,
			.massDamage = 1.0,
			.hardnessDamage = 0.95,
			.swingSpeed = 4.8,
			.textureRoughness = 0.7,
			.colors = .{
				0xff35281b, 0xff493523, 0xff60462e, 0xff6f5133, 0xff815d39,
			},
			.modifiers = .{
				.{
					.id = "durable",
					.strength = 0.4,
				},
			},
		},
	},

	.drops = .{
		.{.items = .{.auto}},
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:stairs",
	.texture = "cubyz:willow_planks",
}

```

`assets/cubyz/blocks/willow_top.zig.zon`:

```zon
.{
	.tags = .{.choppable, .wood, .log},
	.blockHealth = 8,
	.drops = .{
		.{.items = .{"cubyz:log/willow"}},
	},
	.rotation = "cubyz:direction",
	.model = "cubyz:cube",
	.texture = "cubyz:willow_log",
	.texture_top = "cubyz:willow_log",
	.texture_bottom = "cubyz:willow_log_top",
	.decayProhibitor = true,
}

```

`assets/cubyz/blocks/workbench.zig.zon`:

```zon
.{
	.tags = .{.choppable},
	.blockHealth = 10,
	.drops = .{
		.{.items = .{.auto}},
	},
	.onInteract = .{
		.type = .openWindow,
		.name = "workbench",
	},
	.model = "cubyz:cube",
	.rotation = "cubyz:planar",
	.texture = "cubyz:workbench_back",
	.texture_front = "cubyz:workbench_front",
	.texture_left = "cubyz:workbench_side",
	.texture_right = "cubyz:workbench_side",
	.texture_top = "cubyz:workbench_top",
	.texture_bottom = "cubyz:workbench_bottom",
}

```

`assets/cubyz/blocks/yellow_leaf_pile.zig.zon`:

```zon
.{
	.tags = .{.cuttable, .leaf},
	.blockHealth = 0.1,
	.drops = .{
		.{.items = .{.auto}},
	},
	.degradable = true,
	.collide = false,
	.alwaysViewThrough = true,
	.absorbedLight = 0x000000,
	.model = .{
		.model = "cubyz:plane",
		.states = 4,
	},
	.rotation = "cubyz:texture_pile",
	.onUpdate = .{
		.type = .checkSupportBlocks,
	},
	.texture0 = "cubyz:yellow_leaf_pile/0",
	.texture1 = "cubyz:yellow_leaf_pile/1",
	.texture2 = "cubyz:yellow_leaf_pile/2",
	.texture3 = "cubyz:yellow_leaf_pile/3",
	.item = .{
		.texture = "yellow_leaf_pile.png",
	},
	.lodReplacement = "cubyz:air",
}

```

`assets/cubyz/entity/models/snale.obj`:

```obj
o Eyestalks
v 0.250000 0.062500 2.062500
v 0.250000 0.062500 2.062500
v 0.250000 0.062500 1.625000
v 0.250000 0.062500 1.625000
v -0.250000 0.062500 2.062500
v -0.250000 0.062500 2.062500
v -0.250000 0.062500 1.625000
v -0.250000 0.062500 1.625000
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.468750 0.890625
vt 0.593750 0.890625
vt 0.593750 1.000000
vt 0.468750 1.000000
vt 0.718750 0.890625
vt 0.718750 1.000000
s 1
f 4/1/1 7/2/1 5/3/1 2/4/1
s 0
f 3/1/1 4/1/2 2/4/1 1/4/2
s 1
f 8/2/3 3/5/3 1/6/3 6/3/3
s 0
f 7/2/1 8/2/4 6/3/1 5/3/4
f 6/3/5 1/4/1 2/4/5 5/3/1
f 7/6/6 4/3/1 3/3/6 8/6/1
o Head
v 0.250000 -0.187500 1.625000
v 0.250000 0.250000 1.625000
v 0.250000 -0.187500 1.375000
v 0.250000 0.250000 1.375000
v -0.250000 0.250000 1.625000
v -0.250000 -0.187500 1.625000
v -0.250000 0.250000 1.375000
v -0.250000 -0.187500 1.375000
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.109375 0.828125
vt 0.234375 0.828125
vt 0.234375 0.890625
vt 0.109375 0.890625
vt 0.000000 0.828125
vt 0.000000 0.890625
vt 0.343750 0.828125
vt 0.468750 0.828125
vt 0.468750 0.890625
vt 0.343750 0.890625
vt 0.234375 1.000000
vt 0.109375 1.000000
vt 0.359375 0.890625
vt 0.359375 1.000000
s 1
f 12/7/7 15/8/7 13/9/7 10/10/7
f 11/11/8 12/7/8 10/10/8 9/12/8
f 16/13/9 11/14/9 9/15/9 14/16/9
f 15/8/10 16/13/10 14/16/10 13/9/10
f 14/17/11 9/18/11 10/10/11 13/9/11
f 15/19/12 12/9/12 11/17/12 16/20/12
o LeftArm
v -0.250000 -0.062500 1.343750
v -0.250000 0.062500 1.343750
v -0.250000 -0.062500 0.593750
v -0.250000 0.062500 0.593750
v -0.375000 0.062500 1.343750
v -0.375000 -0.062500 1.343750
v -0.375000 0.062500 0.593750
v -0.375000 -0.062500 0.593750
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.406250 0.578125
vt 0.437500 0.578125
vt 0.437500 0.765625
vt 0.406250 0.765625
vt 0.375000 0.578125
vt 0.375000 0.765625
vt 0.468750 0.578125
vt 0.500000 0.578125
vt 0.500000 0.765625
vt 0.468750 0.765625
vt 0.437500 0.796875
vt 0.406250 0.796875
vt 0.468750 0.796875
s 1
f 20/21/13 23/22/13 21/23/13 18/24/13
f 19/25/14 20/21/14 18/24/14 17/26/14
f 24/27/15 19/28/15 17/29/15 22/30/15
f 23/22/16 24/27/16 22/30/16 21/23/16
f 22/31/17 17/32/17 18/24/17 21/23/17
f 23/30/18 20/23/18 19/31/18 24/33/18
o LeftLeg
v -0.031250 -0.093750 0.687500
v -0.031250 0.093750 0.687500
v -0.031250 -0.093750 0.000000
v -0.031250 0.093750 -0.000000
v -0.218750 0.093750 0.687500
v -0.218750 -0.093750 0.687500
v -0.218750 0.093750 -0.000000
v -0.218750 -0.093750 0.000000
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.234375 0.343750
vt 0.281250 0.343750
vt 0.281250 0.515625
vt 0.234375 0.515625
vt 0.187500 0.343750
vt 0.187500 0.515625
vt 0.328125 0.343750
vt 0.375000 0.343750
vt 0.375000 0.515625
vt 0.328125 0.515625
vt 0.281250 0.562500
vt 0.234375 0.562500
vt 0.328125 0.562500
s 1
f 28/34/19 31/35/19 29/36/19 26/37/19
f 27/38/20 28/34/20 26/37/20 25/39/20
f 32/40/21 27/41/21 25/42/21 30/43/21
f 31/35/22 32/40/22 30/43/22 29/36/22
f 30/44/23 25/45/23 26/37/23 29/36/23
f 31/43/24 28/36/24 27/44/24 32/46/24
o LeftPant
v 0.000000 -0.125000 0.688125
v 0.000000 0.125000 0.688125
v 0.000000 -0.125000 0.188125
v 0.000000 0.125000 0.188125
v -0.250000 0.125000 0.688125
v -0.250000 -0.125000 0.688125
v -0.250000 0.125000 0.188125
v -0.250000 -0.125000 0.188125
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.687500 0.390625
vt 0.750000 0.390625
vt 0.750000 0.515625
vt 0.687500 0.515625
vt 0.625000 0.390625
vt 0.625000 0.515625
vt 0.812500 0.390625
vt 0.875000 0.390625
vt 0.875000 0.515625
vt 0.812500 0.515625
vt 0.750000 0.578125
vt 0.687500 0.578125
vt 0.812500 0.578125
s 1
f 36/47/25 39/48/25 37/49/25 34/50/25
f 35/51/26 36/47/26 34/50/26 33/52/26
f 40/53/27 35/54/27 33/55/27 38/56/27
f 39/48/28 40/53/28 38/56/28 37/49/28
f 38/57/29 33/58/29 34/50/29 37/49/29
f 39/56/30 36/49/30 35/57/30 40/59/30
o LeftSleeve
v -0.218750 -0.093750 1.344375
v -0.218750 0.093750 1.344375
v -0.218750 -0.093750 0.781875
v -0.218750 0.093750 0.781875
v -0.406250 0.093750 1.344375
v -0.406250 -0.093750 1.344375
v -0.406250 0.093750 0.781875
v -0.406250 -0.093750 0.781875
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.859375 0.625000
vt 0.906250 0.625000
vt 0.906250 0.765625
vt 0.859375 0.765625
vt 0.812500 0.625000
vt 0.812500 0.765625
vt 0.953125 0.625000
vt 1.000000 0.625000
vt 1.000000 0.765625
vt 0.953125 0.765625
vt 0.906250 0.812500
vt 0.859375 0.812500
vt 0.953125 0.812500
s 1
f 44/60/31 47/61/31 45/62/31 42/63/31
f 43/64/32 44/60/32 42/63/32 41/65/32
f 48/66/33 43/67/33 41/68/33 46/69/33
f 47/61/34 48/66/34 46/69/34 45/62/34
f 46/70/35 41/71/35 42/63/35 45/62/35
f 47/69/36 44/62/36 43/70/36 48/72/36
o RightArm
v 0.375000 -0.062500 1.343750
v 0.375000 0.062500 1.343750
v 0.375000 -0.062500 0.593750
v 0.375000 0.062500 0.593750
v 0.250000 0.062500 1.343750
v 0.250000 -0.062500 1.343750
v 0.250000 0.062500 0.593750
v 0.250000 -0.062500 0.593750
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.531250 0.578125
vt 0.562500 0.578125
vt 0.562500 0.765625
vt 0.531250 0.765625
vt 0.500000 0.578125
vt 0.500000 0.765625
vt 0.593750 0.578125
vt 0.625000 0.578125
vt 0.625000 0.765625
vt 0.593750 0.765625
vt 0.562500 0.796875
vt 0.531250 0.796875
vt 0.593750 0.796875
s 1
f 52/73/37 55/74/37 53/75/37 50/76/37
f 51/77/38 52/73/38 50/76/38 49/78/38
f 56/79/39 51/80/39 49/81/39 54/82/39
f 55/74/40 56/79/40 54/82/40 53/75/40
f 54/83/41 49/84/41 50/76/41 53/75/41
f 55/82/42 52/75/42 51/83/42 56/85/42
o RightLeg
v 0.218750 -0.093750 0.687500
v 0.218750 0.093750 0.687500
v 0.218750 -0.093750 0.000000
v 0.218750 0.093750 -0.000000
v 0.031250 0.093750 0.687500
v 0.031250 -0.093750 0.687500
v 0.031250 0.093750 -0.000000
v 0.031250 -0.093750 0.000000
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.046875 0.343750
vt 0.093750 0.343750
vt 0.093750 0.515625
vt 0.046875 0.515625
vt 0.000000 0.343750
vt 0.000000 0.515625
vt 0.140625 0.343750
vt 0.187500 0.343750
vt 0.187500 0.515625
vt 0.140625 0.515625
vt 0.093750 0.562500
vt 0.046875 0.562500
vt 0.140625 0.562500
s 1
f 60/86/43 63/87/43 61/88/43 58/89/43
f 59/90/44 60/86/44 58/89/44 57/91/44
f 64/92/45 59/93/45 57/94/45 62/95/45
f 63/87/46 64/92/46 62/95/46 61/88/46
f 62/96/47 57/97/47 58/89/47 61/88/47
f 63/95/48 60/88/48 59/96/48 64/98/48
o RightPant
v 0.250000 -0.125000 0.688125
v 0.250000 0.125000 0.688125
v 0.250000 -0.125000 0.188125
v 0.250000 0.125000 0.188125
v 0.000000 0.125000 0.688125
v 0.000000 -0.125000 0.688125
v 0.000000 0.125000 0.188125
v 0.000000 -0.125000 0.188125
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.437500 0.390625
vt 0.500000 0.390625
vt 0.500000 0.515625
vt 0.437500 0.515625
vt 0.375000 0.390625
vt 0.375000 0.515625
vt 0.562500 0.390625
vt 0.625000 0.390625
vt 0.625000 0.515625
vt 0.562500 0.515625
vt 0.500000 0.578125
vt 0.437500 0.578125
vt 0.562500 0.578125
s 1
f 68/99/49 71/100/49 69/101/49 66/102/49
f 67/103/50 68/99/50 66/102/50 65/104/50
f 72/105/51 67/106/51 65/107/51 70/108/51
f 71/100/52 72/105/52 70/108/52 69/101/52
f 70/109/53 65/110/53 66/102/53 69/101/53
f 71/108/54 68/101/54 67/109/54 72/111/54
o RightSleeve
v 0.406250 -0.093750 1.344375
v 0.406250 0.093750 1.344375
v 0.406250 -0.093750 0.781875
v 0.406250 0.093750 0.781875
v 0.218750 0.093750 1.344375
v 0.218750 -0.093750 1.344375
v 0.218750 0.093750 0.781875
v 0.218750 -0.093750 0.781875
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.671875 0.625000
vt 0.718750 0.625000
vt 0.718750 0.765625
vt 0.671875 0.765625
vt 0.625000 0.625000
vt 0.625000 0.765625
vt 0.765625 0.625000
vt 0.812500 0.625000
vt 0.812500 0.765625
vt 0.765625 0.765625
vt 0.718750 0.812500
vt 0.671875 0.812500
vt 0.765625 0.812500
s 1
f 76/112/55 79/113/55 77/114/55 74/115/55
f 75/116/56 76/112/56 74/115/56 73/117/56
f 80/118/57 75/119/57 73/120/57 78/121/57
f 79/113/58 80/118/58 78/121/58 77/114/58
f 78/122/59 73/123/59 74/115/59 77/114/59
f 79/121/60 76/114/60 75/122/60 80/124/60
o Torso
v 0.250000 -0.125000 1.375000
v 0.250000 0.125000 1.375000
v 0.250000 -0.125000 0.687500
v 0.250000 0.125000 0.687500
v -0.250000 0.125000 1.375000
v -0.250000 -0.125000 1.375000
v -0.250000 0.125000 0.687500
v -0.250000 -0.125000 0.687500
vn -0.0000 1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -0.0000 -0.0000 -1.0000
vt 0.062500 0.593750
vt 0.187500 0.593750
vt 0.187500 0.765625
vt 0.062500 0.765625
vt 0.000000 0.593750
vt 0.000000 0.765625
vt 0.250000 0.593750
vt 0.375000 0.593750
vt 0.375000 0.765625
vt 0.250000 0.765625
vt 0.187500 0.828125
vt 0.062500 0.828125
vt 0.312500 0.765625
vt 0.312500 0.828125
s 1
f 84/125/61 87/126/61 85/127/61 82/128/61
f 83/129/62 84/125/62 82/128/62 81/130/62
f 88/131/63 83/132/63 81/133/63 86/134/63
f 87/126/64 88/131/64 86/134/64 85/127/64
f 86/135/65 81/136/65 82/128/65 85/127/65
f 87/137/66 84/127/66 83/135/66 88/138/66

```

`assets/cubyz/items/_migrations.zig.zon`:

```zon
.{
	.{.old = "stone", .new = "slate"},
	.{.old = "stone_bricks", .new = "slate_bricks"},
	.{.old = "stone_tile", .new = "slate_tile"},
	.{.old = "stone_wall", .new = "slate_wall"},
	.{.old = "coal", .new = "coal_ore"},
	.{.old = "diamond", .new = "diamond_ore"},
	.{.old = "mossy_cobblestone", .new = "cobblestone"},
	.{.old = "chisel", .new = "iron_ingot"},
	.{.old = "baobab_leaves", .new = "leaves/baobab"},
	.{.old = "birch_leaves", .new = "leaves/birch"},
	.{.old = "dead_leaves", .new = "leaves/dead"},
	.{.old = "mahogany_leaves", .new = "leaves/mahogany"},
	.{.old = "oak_leaves", .new = "leaves/oak"},
	.{.old = "palm_leaves", .new = "leaves/palm"},
	.{.old = "red_leaves", .new = "leaves/red"},
	.{.old = "willow_leaves", .new = "leaves/willow"},
	.{.old = "yellow_leaves", .new = "leaves/yellow"},
	.{.old = "pine_needles", .new = "leaves/pine"},
	.{.old = "basalt", .new = "basalt/base"},
	.{.old = "basalt_bricks", .new = "basalt/bricks"},
	.{.old = "basalt_tile", .new = "basalt/tile"},
	.{.old = "basalt_wall", .new = "basalt/wall"},
	.{.old = "ferrock", .new = "ferrock/base"},
	.{.old = "ferrock_bricks", .new = "ferrock/bricks"},
	.{.old = "ferrock_tiles", .new = "ferrock/tile"},
	.{.old = "ferrock_wall", .new = "ferrock/wall"},
	.{.old = "glacite", .new = "glacite/base"},
	.{.old = "glacite_bricks", .new = "glacite/bricks"},
	.{.old = "glacite_tile", .new = "glacite/tile"},
	.{.old = "glacite_wall", .new = "glacite/wall"},
	.{.old = "limestone", .new = "limestone/base"},
	.{.old = "limestone_bricks", .new = "limestone/bricks"},
	.{.old = "limestone_tiles", .new = "limestone/tile"},
	.{.old = "limestone_wall", .new = "limestone/wall"},
	.{.old = "marble", .new = "marble/base"},
	.{.old = "marble_bricks", .new = "marble/bricks"},
	.{.old = "marble_tile", .new = "marble/tile"},
	.{.old = "marble_wall", .new = "marble/wall"},
	.{.old = "sandstone", .new = "sandstone/base"},
	.{.old = "sandstone_bricks", .new = "sandstone/bricks"},
	.{.old = "sandstone_tile", .new = "sandstone/tile"},
	.{.old = "sandstone_wall", .new = "sandstone/wall"},
	.{.old = "slate", .new = "slate/base"},
	.{.old = "slate_bricks", .new = "slate/bricks"},
	.{.old = "cobblestone", .new = "slate/cobble"},
	.{.old = "slate_tile", .new = "slate/tile"},
	.{.old = "slate_wall", .new = "slate/wall"},
	.{.old = "terracotta", .new = "terracotta/base"},
	.{.old = "terracotta_bricks", .new = "terracotta/bricks"},
	.{.old = "terracotta_tiles", .new = "terracotta/tile"},
	.{.old = "terracotta_wall", .new = "terracotta/wall"},
	.{.old = "void_stone", .new = "voidstone/base"},
	.{.old = "void_stone_bricks", .new = "voidstone/bricks"},
	.{.old = "void_stone_tile", .new = "voidstone/tile"},
	.{.old = "void_stone_wall", .new = "voidstone/wall"},
}

```

`assets/cubyz/items/apple.zig.zon`:

```zon
.{
	.texture = "apple.png",
	.food = 4,
}

```

`assets/cubyz/items/copper_ingot.zig.zon`:

```zon
.{
	.tags = .{.metal},
	.texture = "copper_ingot.png",
	.material = .{
		.durability = 300,
		.massDamage = 1.0,
		.hardnessDamage = 5.1,
		.swingSpeed = 7.1,
		.textureRoughness = 0.1,
		.colors = .{
			0xffa24e37, 0xffb65f3f, 0xffd57e4b, 0xffee9168, 0xfff2b17e,
		},
	},
}

```

`assets/cubyz/items/gold_ingot.zig.zon`:

```zon
.{
	.tags = .{.metal, .precious},
	.texture = "gold_ingot.png",
	.material = .{
		.durability = 400,
		.massDamage = 14.0,
		.hardnessDamage = 1.0,
		.swingSpeed = 0.25,
		.textureRoughness = 0.05,
		.colors = .{
			0xffbc7132, 0xffda972b, 0xfff2cd53, 0xfff2cd53, 0xfffae39e,
		},
	},
}

```

`assets/cubyz/items/iron_ingot.zig.zon`:

```zon
.{
	.tags = .{.metal},
	.texture = "iron_ingot.png",
	.material = .{
		.durability = 1000,
		.massDamage = 3.0,
		.hardnessDamage = 6.0,
		.swingSpeed = 8.3,
		.textureRoughness = 0.1,
		.colors = .{
			0xff616163, 0xff797777, 0xff9c9c9c, 0xffb4b4b4, 0xffd9d9d9,
		},
	},
}

```

`assets/cubyz/items/raw_meat.zig.zon`:

```zon
.{
	.texture = "raw_meat.png",
	.food = 3,
}

```

`assets/cubyz/items/selection_wand.zig.zon`:

```zon
.{
	.texture = "selection_wand.png",
	.stackSize = 1,
}

```

`assets/cubyz/items/silver_ingot.zig.zon`:

```zon
.{
	.tags = .{.metal, .precious},
	.texture = "silver_ingot.png",
	.material = .{
		.durability = 800,
		.massDamage = 8.0,
		.hardnessDamage = 3.0,
		.swingSpeed = 2.1,
		.textureRoughness = 0.05,
		.colors = .{
			0xff67727f, 0xff89919e, 0xffbdc2c6, 0xffe4e6e6, 0xfffcfcfc,
		},
	},
}

```

`assets/cubyz/items/uranium_ingot.zig.zon`:

```zon
.{
	.tags = .{.metal},
	.texture = "uranium_ingot.png",
	.material = .{
		.durability = 1500,
		.massDamage = 10.0,
		.hardnessDamage = 15.0,
		.swingSpeed = 0.5,
		.textureRoughness = 0.3,
		.colors = .{
			0xff395533, 0xff466e45, 0xff5d8a5f, 0xff6da367, 0xff74c761,
		},
	},
}

```

`assets/cubyz/models/bars.obj`:

```obj
o unknown
v 0.4375 0.5625 1
v 0.4375 0.5625 0
v 0.4375 0.4375 0
v 0.4375 0.4375 1
v 0.5625 0.4375 1
v 0.5625 0.4375 0
v 0.5625 0.5625 0
v 0.5625 0.5625 1
v 0 0.5 1
v 0 0.5 0
v 1 0.5 0
v 1 0.5 1
v 1 0.5 1
v 1 0.5 0
v 0 0.5 0
v 0 0.5 1
v 0.5 1 1
v 0.5 1 0
v 0.5 0 0
v 0.5 0 1
v 0.5 0 1
v 0.5 0 0
v 0.5 1 0
v 0.5 1 1
vt 0.859375 0.25
vt 0.859375 0
vt 0.890625 0
vt 0.890625 0.25
vt 0.609375 0.25
vt 0.609375 0
vt 0.640625 0
vt 0.640625 0.25
vt 0.359375 0.5
vt 0.359375 0.25
vt 0.390625 0.25
vt 0.390625 0.5
vt 0.109375 0.5
vt 0.109375 0.25
vt 0.140625 0.25
vt 0.140625 0.5
vt 0.25 0.5
vt 0.25 0.25
vt 0.5 0.25
vt 0.5 0.5
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vt 0.75 0.25
vt 0.75 0
vt 1 0
vt 1 0.25
vt 0.5 0.25
vt 0.5 0
vt 0.75 0
vt 0.75 0.25
vt 0.109375 0.140625
vt 0.109375 0.109375
vt 0.140625 0.109375
vt 0.140625 0.140625
vt 0.359375 0.140625
vt 0.359375 0.109375
vt 0.390625 0.109375
vt 0.390625 0.140625
vn -1 0 0
vn 1 0 0
vn 0 -1 0
vn 0 1 0
vn 0 -1 0
vn 0 1 0
vn -1 0 0
vn 1 0 0
vn 0 0 1
vn 0 0 -1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 4/9/3 3/10/3 6/11/3 5/12/3
f 8/13/4 7/14/4 2/15/4 1/16/4
f 9/17/5 10/18/5 11/19/5 12/20/5
f 13/21/6 14/22/6 15/23/6 16/24/6
f 17/25/7 18/26/7 19/27/7 20/28/7
f 21/29/8 22/30/8 23/31/8 24/32/8
f 5/33/9 8/34/9 1/35/9 4/36/9
f 3/37/10 2/38/10 7/39/10 6/40/10
```

`assets/cubyz/models/bellows.obj`:

```obj
o Nozzle
v 0.625 1 0.3749999999999999
v 0.375 1 0.3749999999999999
v 0.625 1 0.12499999999999989
v 0.375 1 0.12499999999999989
v 0.625 0.875 0.3749999999999999
v 0.375 0.875 0.3749999999999999
v 0.625 0.875 0.1249999999999999
v 0.375 0.875 0.1249999999999999
vt 0.84375 0.15625
vt 0.84375 0.21875
vt 0.78125 0.21875
vt 0.78125 0.15625
vt 0.78125 0.21875
vt 0.84375 0.21875
vt 0.84375 0.25
vt 0.78125 0.25
vt 0.84375 0.125
vt 0.78125 0.125
vt 0.78125 0.15625
vt 0.84375 0.15625
vt 0.78125 0.15625
vt 0.78125 0.21875
vt 0.75 0.21875
vt 0.75 0.15625
vt 0.875 0.15625
vt 0.875 0.21875
vt 0.84375 0.21875
vt 0.84375 0.15625
vn 2.220446049250313e-16 1 -2.220446049250313e-16
vn 0 2.220446049250313e-16 1
vn 0 -2.220446049250313e-16 -1
vn 1 -2.220446049250313e-16 4.930380657631324e-32
vn -1 2.220446049250313e-16 -4.930380657631324e-32
f 4/1/1 2/2/1 1/3/1 3/4/1
f 1/5/2 2/6/2 6/7/2 5/8/2
f 4/9/3 3/10/3 7/11/3 8/12/3
f 3/13/4 1/14/4 5/15/4 7/16/4
f 8/17/5 6/18/5 2/19/5 4/20/5
o Bottom
v 0.9375 0.06249999999999989 0.1250000000000001
v 0.9375 0.9374999999999999 0.1249999999999999
v 0.9375 0.06249999999999989 9.71445146547012e-17
v 0.9375 0.9374999999999999 -9.71445146547012e-17
v 0.0625 0.06249999999999989 0.1250000000000001
v 0.0625 0.9374999999999999 0.1249999999999999
v 0.0625 0.06249999999999989 9.71445146547012e-17
v 0.0625 0.9374999999999999 -9.71445146547012e-17
vt 0.734375 0
vt 0.734375 0.03125
vt 0.515625 0.03125
vt 0.515625 0
vt 0.734375 0
vt 0.734375 0.03125
vt 0.515625 0.03125
vt 0.515625 0
vt 0.265625 0.234375
vt 0.265625 0.015625
vt 0.484375 0.015625
vt 0.484375 0.234375
vt 0.015625 0.015625
vt 0.015625 0.234375
vt 0.234375 0.234375
vt 0.234375 0.015625
vt 0.734375 0
vt 0.734375 0.03125
vt 0.515625 0.03125
vt 0.515625 0
vt 0.734375 0
vt 0.734375 0.03125
vt 0.515625 0.03125
vt 0.515625 0
vn 1 0 0
vn -1 0 0
vn 0 2.220446049250313e-16 1
vn 0 -2.220446049250313e-16 -1
vn 0 -1 2.220446049250313e-16
vn 0 1 -2.220446049250313e-16
f 12/21/6 10/22/6 9/23/6 11/24/6
f 15/25/7 13/26/7 14/27/7 16/28/7
f 9/29/8 10/30/8 14/31/8 13/32/8
f 12/33/9 11/34/9 15/35/9 16/36/9
f 11/37/10 9/38/10 13/39/10 15/40/10
f 16/41/11 14/42/11 10/43/11 12/44/11
o Center
v 0.875 0.12500000000000006 0.7500000000000001
v 0.875 0.875 0.7499999999999999
v 0.875 0.12499999999999994 0.1250000000000001
v 0.875 0.875 0.12499999999999989
v 0.125 0.12500000000000006 0.7500000000000001
v 0.125 0.875 0.7499999999999999
v 0.125 0.12499999999999994 0.1250000000000001
v 0.125 0.875 0.12499999999999989
vt 0.71875 0.03125
vt 0.71875 0.1875
vt 0.53125 0.1875
vt 0.53125 0.03125
vt 0.71875 0.03125
vt 0.71875 0.1875
vt 0.53125 0.1875
vt 0.53125 0.03125
vt 0.71875 0.03125
vt 0.71875 0.1875
vt 0.53125 0.1875
vt 0.53125 0.03125
vt 0.71875 0.03125
vt 0.71875 0.1875
vt 0.53125 0.1875
vt 0.53125 0.03125
vn 1 0 0
vn -1 0 0
vn 0 -1 2.220446049250313e-16
vn 0 1 -2.220446049250313e-16
f 20/45/12 18/46/12 17/47/12 19/48/12
f 23/49/13 21/50/13 22/51/13 24/52/13
f 19/53/14 17/54/14 21/55/14 23/56/14
f 24/57/15 22/58/15 18/59/15 20/60/15
o Top
v 0.9375 0.06250000000000011 0.8750000000000001
v 0.9375 0.9375000000000001 0.8749999999999999
v 0.9375 0.06250000000000011 0.7500000000000001
v 0.9375 0.9375000000000001 0.7499999999999999
v 0.0625 0.06250000000000011 0.8750000000000001
v 0.0625 0.9375000000000001 0.8749999999999999
v 0.0625 0.06250000000000011 0.7500000000000001
v 0.0625 0.9375000000000001 0.7499999999999999
vt 0.734375 0.1875
vt 0.734375 0.21875
vt 0.515625 0.21875
vt 0.515625 0.1875
vt 0.734375 0.1875
vt 0.734375 0.21875
vt 0.515625 0.21875
vt 0.515625 0.1875
vt 0.015625 0.234375
vt 0.015625 0.015625
vt 0.234375 0.015625
vt 0.234375 0.234375
vt 0.265625 0.015625
vt 0.265625 0.234375
vt 0.484375 0.234375
vt 0.484375 0.015625
vt 0.734375 0.1875
vt 0.734375 0.21875
vt 0.515625 0.21875
vt 0.515625 0.1875
vt 0.734375 0.1875
vt 0.734375 0.21875
vt 0.515625 0.21875
vt 0.515625 0.1875
vn 1 0 0
vn -1 0 0
vn 0 2.220446049250313e-16 1
vn 0 -2.220446049250313e-16 -1
vn 0 -1 2.220446049250313e-16
vn 0 1 -2.220446049250313e-16
f 28/61/16 26/62/16 25/63/16 27/64/16
f 31/65/17 29/66/17 30/67/17 32/68/17
f 25/69/18 26/70/18 30/71/18 29/72/18
f 28/73/19 27/74/19 31/75/19 32/76/19
f 27/77/20 25/78/20 29/79/20 31/80/20
f 32/81/21 30/82/21 26/83/21 28/84/21
```

`assets/cubyz/models/bolete/floor.obj`:

```obj
o unknown
v 1 1 0.25
v 1 1 0
v 0 0 0
v 0 0 0.25
v 0 1 0.25
v 0 1 0
v 1 0 0
v 1 0 0.25
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vn -0.7071067811865476 0.7071067811865476 0
vn 0.7071067811865476 -0.7071067811865476 0
vn -0.7071067811865476 -0.7071067811865476 0
vn 0.7071067811865476 0.7071067811865476 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 4/5/2 3/6/2 2/7/2 1/8/2
f 5/9/3 6/10/3 7/11/3 8/12/3
f 8/13/4 7/14/4 6/15/4 5/16/4
o unknown
v 0.75 0.25 0.375
v 0.75 0.75 0.375
v 0.25 0.75 0.375
v 0.25 0.25 0.375
v 0.25 0.25 0.25
v 0.25 0.75 0.25
v 0.75 0.75 0.25
v 0.75 0.25 0.25
vt 0 0.25
vt 0 0.125
vt 0.125 0.125
vt 0.125 0.25
vt 0.25 0.25
vt 0.25 0.125
vt 0.375 0.125
vt 0.375 0.25
vt 0.5625 0.09375
vt 0.5625 0.0625
vt 0.6875 0.0625
vt 0.6875 0.09375
vt 0.8125 0.09375
vt 0.8125 0.0625
vt 0.9375 0.0625
vt 0.9375 0.09375
vt 0.0625 0.34375
vt 0.0625 0.3125
vt 0.1875 0.3125
vt 0.1875 0.34375
vt 0.3125 0.34375
vt 0.3125 0.3125
vt 0.4375 0.3125
vt 0.4375 0.34375
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 9/17/5 10/18/5 11/19/5 12/20/5
f 13/21/6 14/22/6 15/23/6 16/24/6
f 9/25/7 16/26/7 15/27/7 10/28/7
f 11/29/8 14/30/8 13/31/8 12/32/8
f 10/33/9 15/34/9 14/35/9 11/36/9
f 12/37/10 13/38/10 16/39/10 9/40/10
```

`assets/cubyz/models/bolete/shelf.obj`:

```obj
o unknown
v 1.3877787807814457e-16 0.375 0.375
v 0.2500000000000001 0.375 0.375
v 0.25 0.9375 0.375
v 1.3877787807814457e-17 0.9375 0.375
v 1.3877787807814457e-17 0.9375 0.25
v 0.25 0.9375 0.25
v 0.2500000000000001 0.375 0.25
v 1.3877787807814457e-16 0.375 0.25
vt 0.140625 0
vt 0.140625 0.0625
vt 0 0.0625
vt 0 0
vt 0.25 0
vt 0.25 0.0625
vt 0.390625 0.0625
vt 0.390625 0
vt 0.75 0.21875
vt 0.75 0.1875
vt 0.828125 0.1875
vt 0.828125 0.21875
vt 0.828125 0.21875
vt 0.828125 0.1875
vt 0.890625 0.1875
vt 0.890625 0.21875
vt 0 0.46875
vt 0 0.4375
vt 0.140625 0.4375
vt 0.140625 0.46875
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
o unknown
v 2.0816681711721685e-16 0.0625 0.8125
v 0.18750000000000022 0.0625 0.8125
v 0.1875000000000001 0.5625 0.8125
v 9.71445146547012e-17 0.5625 0.8125
v 9.71445146547012e-17 0.5625 0.6875
v 0.1875000000000001 0.5625 0.6875
v 0.18750000000000022 0.0625 0.6875
v 2.0816681711721685e-16 0.0625 0.6875
vt 0.125 0.0625
vt 0.125 0.109375
vt 0 0.109375
vt 0 0.0625
vt 0.375 0.0625
vt 0.375 0.109375
vt 0.25 0.109375
vt 0.25 0.0625
vt 0.5 0.25
vt 0.5 0.21875
vt 0.546875 0.21875
vt 0.546875 0.25
vt 0.828125 0.25
vt 0.828125 0.21875
vt 0.875 0.21875
vt 0.875 0.25
vt 0 0.5
vt 0 0.46875
vt 0.125 0.46875
vt 0.125 0.5
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
f 9/21/6 10/22/6 11/23/6 12/24/6
f 13/25/7 14/26/7 15/27/7 16/28/7
f 9/29/8 16/30/8 15/31/8 10/32/8
f 11/33/9 14/34/9 13/35/9 12/36/9
f 10/37/10 15/38/10 14/39/10 11/40/10
```

`assets/cubyz/models/cactus_flower.obj`:

```obj
o unknown
v 1 1 1
v 1 1 0
v 0 0 0
v 0 0 1
v 0 1 1
v 0 1 0
v 1 0 0
v 1 0 1
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vn -0.7071067811865476 0.7071067811865476 0
vn 0.7071067811865476 -0.7071067811865476 0
vn -0.7071067811865476 -0.7071067811865476 0
vn 0.7071067811865476 0.7071067811865476 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 4/5/2 3/6/2 2/7/2 1/8/2
f 5/9/3 6/10/3 7/11/3 8/12/3
f 8/13/4 7/14/4 6/15/4 5/16/4
o plane
v 1 0 0.25
v 1 1 0.25
v 0 1 0.25
v 0 0 0.25
vt 0.25 0
vt 0.25 0.25
vt 0 0.25
vt 0 0
vn 0 0 1
f 9/17/5 10/18/5 11/19/5 12/20/5
o plane
v 0 0 0.25
v 0 1 0.25
v 1 1 0.25
v 1 0 0.25
vt 0 0
vt 0 0.25
vt 0.25 0.25
vt 0.25 0
vn 0 0 -1
f 13/21/6 14/22/6 15/23/6 16/24/6
```

`assets/cubyz/models/carpet.obj`:

```obj
o cube
v 1 0 0.0625
v 1 1 0.0625
v 0 1 0.0625
v 0 0 0.0625
v 0 0 0
v 0 1 0
v 1 1 0
v 1 0 0
vt 0 0.25
vt 0 0
vt 0.25 0
vt 0.25 0.25
vt 0.25 0.25
vt 0.25 0
vt 0.5 0
vt 0.5 0.25
vt 0.5 0.25
vt 0.515625 0.25
vt 0.515625 0
vt 0.5 0
vt 1 0
vt 0.984375 0
vt 0.984375 0.25
vt 1 0.25
vt 0 0.265625
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.265625
vt 0.25 0.5
vt 0.25 0.484375
vt 0.5 0.484375
vt 0.5 0.5
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
f 4/21/6 5/22/6 8/23/6 1/24/6
```

`assets/cubyz/models/chain.obj`:

```obj
o top0
v 0.625 0.4375 0.1875
v 0.625 0.5625 0.1875
v 0.375 0.4375 0.1875
v 0.375 0.5625 0.1875
vt 0.1875 0.25
vt 0.1875 0.21875
vt 0.25 0.21875
vt 0.25 0.25
vn 0 2.220446049250313e-16 1
f 1/1/1 2/2/1 4/3/1 3/4/1
o top1
v 0.4375 0.3750000000000001 0.4375
v 0.5625 0.3750000000000001 0.4375
v 0.4375 0.6250000000000001 0.4375
v 0.5625 0.6250000000000001 0.4375
vt 0.1875 0.21875
vt 0.1875 0.25
vt 0.25 0.25
vt 0.25 0.21875
vn 0 2.220446049250313e-16 1
f 5/5/2 6/6/2 8/7/2 7/8/2
o top2
v 0.625 0.4375000000000001 0.6875
v 0.625 0.5625000000000001 0.6875
v 0.375 0.4375000000000001 0.6875
v 0.375 0.5625000000000001 0.6875
vt 0.1875 0.25
vt 0.1875 0.21875
vt 0.25 0.21875
vt 0.25 0.25
vn 0 2.220446049250313e-16 1
f 9/9/3 10/10/3 12/11/3 11/12/3
o top3
v 0.4375 0.3750000000000002 0.9375
v 0.5625 0.3750000000000002 0.9375
v 0.4375 0.6250000000000002 0.9375
v 0.5625 0.6250000000000002 0.9375
vt 0.1875 0.21875
vt 0.1875 0.25
vt 0.25 0.25
vt 0.25 0.21875
vn 0 2.220446049250313e-16 1
f 13/13/4 14/14/4 16/15/4 15/16/4
o bottom0
v 0.5625 0.375 0.125
v 0.4375 0.375 0.125
v 0.5625 0.625 0.12499999999999999
v 0.4375 0.625 0.12499999999999999
vt 0.1875 0.21875
vt 0.1875 0.1875
vt 0.25 0.1875
vt 0.25 0.21875
vn -2.5407181807812022e-33 -9.957992501029599e-17 -1
f 17/17/5 18/18/5 20/19/5 19/20/5
o bottom1
v 0.625 0.5625000000000001 0.375
v 0.625 0.4375000000000001 0.375
v 0.375 0.5625000000000001 0.375
v 0.375 0.4375000000000001 0.375
vt 0.1875 0.1875
vt 0.1875 0.21875
vt 0.25 0.21875
vt 0.25 0.1875
vn 0 -9.957992501029599e-17 -1
f 21/21/6 22/22/6 24/23/6 23/24/6
o bottom2
v 0.5625 0.3750000000000001 0.625
v 0.4375 0.3750000000000001 0.625
v 0.5625 0.6250000000000001 0.625
v 0.4375 0.6250000000000001 0.625
vt 0.1875 0.21875
vt 0.1875 0.1875
vt 0.25 0.1875
vt 0.25 0.21875
vn -2.5407181807812022e-33 -9.957992501029599e-17 -1
f 25/25/7 26/26/7 28/27/7 27/28/7
o bottom3
v 0.625 0.5625000000000002 0.875
v 0.625 0.4375000000000002 0.875
v 0.375 0.5625000000000002 0.875
v 0.375 0.4375000000000002 0.875
vt 0.1875 0.1875
vt 0.1875 0.21875
vt 0.25 0.21875
vt 0.25 0.1875
vn 0 -9.957992501029599e-17 -1
f 29/29/8 30/30/8 32/31/8 31/32/8
o cube
v 0.375 0.4375000000000002 1
v 0.625 0.4375000000000002 1
v 0.375 0.4375 1.3877787807814463e-17
v 0.625 0.4375 1.387778780781445e-17
v 0.375 0.5625000000000002 1
v 0.625 0.5625000000000002 1
v 0.375 0.5625 -1.387778780781445e-17
v 0.625 0.5625 -1.3877787807814463e-17
v 0.5625 0.4375000000000002 1
v 0.5625 0.5625000000000002 1
v 0.5625 0.4375 1.3877787807814463e-17
v 0.5625 0.5625 -1.387778780781445e-17
v 0.4375 0.5625000000000002 1
v 0.4375 0.4375000000000002 1
v 0.4375 0.5625 -1.3877787807814463e-17
v 0.4375 0.4375 1.387778780781445e-17
vt 0.09375 0
vt 0.09375 0.25
vt 0.03125 0.25
vt 0.03125 0
vt 0.09375 0
vt 0.09375 0.25
vt 0.03125 0.25
vt 0.03125 0
vt 0.03125 0
vt 0.03125 0.25
vt 0 0.25
vt 0 0
vt 0.03125 0
vt 0.03125 0.25
vt 0 0.25
vt 0 0
vt 0.03125 0
vt 0.03125 0.25
vt 0 0.25
vt 0 0
vt 0.03125 0
vt 0.03125 0.25
vt 0 0.25
vt 0 0
vt 0.1875 0.125
vt 0.1875 0.15625
vt 0.25 0.15625
vt 0.25 0.125
vt 0.1875 0.1875
vt 0.1875 0.15625
vt 0.25 0.15625
vt 0.25 0.1875
vn 2.220446049250313e-16 -1 2.220446049250313e-16
vn -2.220446049250313e-16 1 -2.220446049250313e-16
vn -1 -2.220446049250313e-16 4.930380657631324e-32
vn 1 2.220446049250313e-16 -4.930380657631324e-32
vn -1 -2.220446049250313e-16 4.930380657631324e-32
vn 1 2.220446049250313e-16 -4.930380657631324e-32
vn 0 -2.220446049250313e-16 -1
vn 0 2.220446049250313e-16 1
f 36/33/9 34/34/9 33/35/9 35/36/9
f 39/37/10 37/38/10 38/39/10 40/40/10
f 35/41/11 33/42/11 37/43/11 39/44/11
f 40/45/12 38/46/12 34/47/12 36/48/12
f 43/49/13 41/50/13 42/51/13 44/52/13
f 47/53/14 45/54/14 46/55/14 48/56/14
f 40/57/15 36/58/15 35/59/15 39/60/15
f 34/61/16 38/62/16 37/63/16 33/64/16
o cube
v 0.5625 0.3750000000000002 1
v 0.5625 0.6250000000000002 1
v 0.5625 0.375 2.7755575615628914e-17
v 0.5625 0.625 -2.7755575615628914e-17
v 0.4375 0.3750000000000002 1
v 0.4375 0.6250000000000002 1
v 0.4375 0.375 2.7755575615628914e-17
v 0.4375 0.625 -2.7755575615628914e-17
v 0.4375 0.4375000000000002 1
v 0.5625 0.4375000000000002 1
v 0.4375 0.4375 1.3877787807814457e-17
v 0.5625 0.4375 1.3877787807814457e-17
v 0.5625 0.5625000000000002 1
v 0.4375 0.5625000000000002 1
v 0.5625 0.5625 -1.3877787807814457e-17
v 0.4375 0.5625 -1.3877787807814457e-17
vt 0.1875 0
vt 0.1875 0.25
vt 0.125 0.25
vt 0.125 0
vt 0.1875 0
vt 0.1875 0.25
vt 0.125 0.25
vt 0.125 0
vt 0.125 0
vt 0.125 0.25
vt 0.09375 0.25
vt 0.09375 0
vt 0.125 0
vt 0.125 0.25
vt 0.09375 0.25
vt 0.09375 0
vt 0.125 0
vt 0.125 0.25
vt 0.09375 0.25
vt 0.09375 0
vt 0.125 0
vt 0.125 0.25
vt 0.09375 0.25
vt 0.09375 0
vn 1 0 0
vn -1 0 0
vn 0 -1 2.220446049250313e-16
vn 0 1 -2.220446049250313e-16
vn 0 1 -2.220446049250313e-16
vn 0 -1 2.220446049250313e-16
f 52/65/17 50/66/17 49/67/17 51/68/17
f 55/69/18 53/70/18 54/71/18 56/72/18
f 51/73/19 49/74/19 53/75/19 55/76/19
f 56/77/20 54/78/20 50/79/20 52/80/20
f 59/81/21 57/82/21 58/83/21 60/84/21
f 63/85/22 61/86/22 62/87/22 64/88/22
```

`assets/cubyz/models/chimney.obj`:

```obj
o unknown
v 0.8125 0.1875 0.75
v 0.8125 0.8125 0.75
v 0.1875 0.8125 0.75
v 0.1875 0.1875 0.75
v 0.1875 0.1875 0
v 0.1875 0.8125 0
v 0.8125 0.8125 0
v 0.8125 0.1875 0
vt 0.296875 0.203125
vt 0.296875 0.046875
vt 0.453125 0.046875
vt 0.453125 0.203125
vt 0.546875 0.1875
vt 0.546875 0
vt 0.703125 0
vt 0.703125 0.1875
vt 0.796875 0.1875
vt 0.796875 0
vt 0.953125 0
vt 0.953125 0.1875
vt 0.046875 0.4375
vt 0.046875 0.25
vt 0.203125 0.25
vt 0.203125 0.4375
vt 0.296875 0.4375
vt 0.296875 0.25
vt 0.453125 0.25
vt 0.453125 0.4375
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 5/1/1 6/2/1 7/3/1 8/4/1
f 1/5/2 8/6/2 7/7/2 2/8/2
f 3/9/3 6/10/3 5/11/3 4/12/3
f 2/13/4 7/14/4 6/15/4 3/16/4
f 4/17/5 5/18/5 8/19/5 1/20/5
o unknown
v 0.875 0.125 1
v 0.875 0.875 1
v 0.125 0.875 1
v 0.125 0.125 1
v 0.125 0.125 0.75
v 0.125 0.875 0.75
v 0.875 0.875 0.75
v 0.875 0.125 0.75
vt 0.03125 0.21875
vt 0.03125 0.03125
vt 0.21875 0.03125
vt 0.21875 0.21875
vt 0.03125 0.21875
vt 0.03125 0.03125
vt 0.21875 0.03125
vt 0.21875 0.21875
vt 0.53125 0.25
vt 0.53125 0.1875
vt 0.71875 0.1875
vt 0.71875 0.25
vt 0.78125 0.25
vt 0.78125 0.1875
vt 0.96875 0.1875
vt 0.96875 0.25
vt 0.03125 0.5
vt 0.03125 0.4375
vt 0.21875 0.4375
vt 0.21875 0.5
vt 0.28125 0.5
vt 0.28125 0.4375
vt 0.46875 0.4375
vt 0.46875 0.5
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 9/21/6 10/22/6 11/23/6 12/24/6
f 13/25/7 14/26/7 15/27/7 16/28/7
f 9/29/8 16/30/8 15/31/8 10/32/8
f 11/33/9 14/34/9 13/35/9 12/36/9
f 10/37/10 15/38/10 14/39/10 11/40/10
f 12/41/11 13/42/11 16/43/11 9/44/11
```

`assets/cubyz/models/cross.obj`:

```obj
v 1 1 0
v 1 1 1
v 0 0 0
v 0 0 1
v 0 1 0
v 0 1 1
v 1 0 0
v 1 0 1
vt 0 0
vt 0 0.25
vt 0.25 0
vt 0.25 0.25
vn -0.70703125 0.70703125 0
vn 0.70703125 -0.70703125 0
vn -0.70703125 -0.70703125 0
vn 0.70703125 0.70703125 0
f 2/2/1 1/1/1 3/3/1 4/4/1
f 4/2/2 3/1/2 1/3/2 2/4/2
f 6/2/3 5/1/3 7/3/3 8/4/3
f 8/2/4 7/1/4 5/3/4 6/4/4

```

`assets/cubyz/models/cross_with_texture_1.obj`:

```obj
v 1 1 0
v 1 1 1
v 0 0 0
v 0 0 1
v 0 1 0
v 0 1 1
v 1 0 0
v 1 0 1
vt 0.25 0
vt 0.25 0.25
vt 0.5 0
vt 0.5 0.25
vn -0.70703125 0.70703125 0
vn 0.70703125 -0.70703125 0
vn -0.70703125 -0.70703125 0
vn 0.70703125 0.70703125 0
f 2/2/1 1/1/1 3/3/1 4/4/1
f 4/2/2 3/1/2 1/3/2 2/4/2
f 6/2/3 5/1/3 7/3/3 8/4/3
f 8/2/4 7/1/4 5/3/4 6/4/4

```

`assets/cubyz/models/cube.obj`:

```obj
v 1 1 1
v 1 0 1
v 0 1 1
v 0 0 1
v 0 1 0
v 0 0 0
v 1 1 0
v 1 0 0
vt 0 0
vt 0 0.25
vt 0.25 0
vt 0.25 0.25
vt 0.5 0
vt 0.5 0.25
vt 0.75 0
vt 0.75 0.25
vt 1 0
vt 1 0.25
vt 0 0.5
vt 0.25 0.5
vt 0.5 0.5
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 2/2/1 1/1/1 3/3/1 4/4/1
f 6/4/2 5/3/2 7/5/2 8/6/2
f 2/6/3 8/5/3 7/7/3 1/8/3
f 3/8/4 5/7/4 6/9/4 4/10/4
f 1/11/5 7/2/5 5/4/5 3/12/5
f 4/12/6 6/4/6 8/6/6 2/13/6

```

`assets/cubyz/models/cube_hanging_planes.obj`:

```obj
o unknown
v 1 0 1
v 1 1 1
v 0 1 1
v 0 0 1
v 0 0 0
v 0 1 0
v 1 1 0
v 1 0 0
vt 0 0.25
vt 0 0
vt 0.25 0
vt 0.25 0.25
vt 0.25 0.25
vt 0.25 0
vt 0.5 0
vt 0.5 0.25
vt 0.5 0.25
vt 0.5 0
vt 0.75 0
vt 0.75 0.25
vt 0.75 0.25
vt 0.75 0
vt 1 0
vt 1 0.25
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vt 0.25 0.5
vt 0.25 0.25
vt 0.5 0.25
vt 0.5 0.5
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
f 4/21/6 5/22/6 8/23/6 1/24/6
o plane
v 0 -0.00012500000000015022 0.125
v 0 -0.0001250000000000947 -0.3749999999999999
v 1 -0.00012499999999984979 -0.375
v 1 -0.0001249999999999053 0.12499999999999992
vt 0 1
vt 0 0.875
vt 0.25 0.875
vt 0.25 1
vn 2.4492935982947064e-16 -1 -1.110223024625157e-16
f 9/25/7 10/26/7 11/27/7 12/28/7
o plane
v 1 -0.0001249999999999053 0.12499999999999992
v 1 -0.00012499999999984979 -0.375
v 0 -0.0001250000000000947 -0.3749999999999999
v 0 -0.00012500000000015022 0.125
vt 0.25 1
vt 0.25 0.875
vt 0 0.875
vt 0 1
vn -2.4492935982947064e-16 1 1.110223024625157e-16
f 13/29/8 14/30/8 15/31/8 16/32/8
o plane
v 1 1.000125 0.125
v 1 1.000125 -0.3749999999999999
v 0 1.000125 -0.375
v 0 1.000125 0.12499999999999992
vt 0 1
vt 0 0.875
vt 0.25 0.875
vt 0.25 1
vn -1.2246467991473532e-16 1 -1.110223024625157e-16
f 17/33/9 18/34/9 19/35/9 20/36/9
o plane
v 0 1.000125 0.12499999999999992
v 0 1.000125 -0.375
v 1 1.000125 -0.3749999999999999
v 1 1.000125 0.125
vt 0.25 1
vt 0.25 0.875
vt 0 0.875
vt 0 1
vn 1.2246467991473532e-16 -1 1.110223024625157e-16
f 21/37/10 22/38/10 23/39/10 24/40/10
o plane
v -0.00012500000000026124 0.9999999999999999 0.125
v -0.00012500000000020573 0.9999999999999999 -0.3749999999999999
v -0.00012499999999973876 -1.1102230246251565e-16 -0.375
v -0.00012499999999979428 -1.1102230246251565e-16 0.12499999999999992
vt 0 1
vt 0 0.875
vt 0.25 0.875
vt 0.25 1
vn -1 -4.66973964754502e-16 -1.110223024625157e-16
f 25/41/11 26/42/11 27/43/11 28/44/11
o plane
v -0.00012499999999979428 -1.1102230246251565e-16 0.12499999999999992
v -0.00012499999999973876 -1.1102230246251565e-16 -0.375
v -0.00012500000000020573 0.9999999999999999 -0.3749999999999999
v -0.00012500000000026124 0.9999999999999999 0.125
vt 0.25 1
vt 0.25 0.875
vt 0 0.875
vt 0 1
vn 1 4.66973964754502e-16 1.110223024625157e-16
f 29/45/12 30/46/12 31/47/12 32/48/12
o plane
v 1.0001250000000002 1.1102230246251565e-16 0.125
v 1.0001250000000002 1.1102230246251565e-16 -0.3749999999999999
v 1.0001249999999997 1 -0.375
v 1.0001249999999997 1 0.12499999999999992
vt 0 1
vt 0 0.875
vt 0.25 0.875
vt 0.25 1
vn 1 3.4450928483976665e-16 -1.110223024625157e-16
f 33/49/13 34/50/13 35/51/13 36/52/13
o plane
v 1.0001249999999997 1 0.12499999999999992
v 1.0001249999999997 1 -0.375
v 1.0001250000000002 1.1102230246251565e-16 -0.3749999999999999
v 1.0001250000000002 1.1102230246251565e-16 0.125
vt 0.25 1
vt 0.25 0.875
vt 0 0.875
vt 0 1
vn -1 -3.4450928483976665e-16 1.110223024625157e-16
f 37/53/14 38/54/14 39/55/14 40/56/14
```

`assets/cubyz/models/fence.obj`:

```obj
o unknown
v 0.375 0.625 1
v 0.375 0.625 0
v 0.375 0.375 0
v 0.375 0.375 1
v 0.625 0.375 1
v 0.625 0.375 0
v 0.625 0.625 0
v 0.625 0.625 1
v 0 0.4375 0.375
v 0 0.4375 0.1875
v 1 0.4375 0.1875
v 1 0.4375 0.375
v 1 0.5625 0.375
v 1 0.5625 0.1875
v 0 0.5625 0.1875
v 0 0.5625 0.375
v 0 0.4375 0.875
v 0 0.4375 0.6875
v 1 0.4375 0.6875
v 1 0.4375 0.875
v 1 0.5625 0.875
v 1 0.5625 0.6875
v 0 0.5625 0.6875
v 0 0.5625 0.875
v 0.4375 1 0.375
v 0.4375 1 0.1875
v 0.4375 0 0.1875
v 0.4375 0 0.375
v 0.5625 0 0.375
v 0.5625 0 0.1875
v 0.5625 1 0.1875
v 0.5625 1 0.375
v 0.4375 1 0.875
v 0.4375 1 0.6875
v 0.4375 0 0.6875
v 0.4375 0 0.875
v 0.5625 0 0.875
v 0.5625 0 0.6875
v 0.5625 1 0.6875
v 0.5625 1 0.875
vt 0.84375 0.25
vt 0.84375 0
vt 0.90625 0
vt 0.90625 0.25
vt 0.59375 0.25
vt 0.59375 0
vt 0.65625 0
vt 0.65625 0.25
vt 0.34375 0.5
vt 0.34375 0.25
vt 0.40625 0.25
vt 0.40625 0.5
vt 0.09375 0.5
vt 0.09375 0.25
vt 0.15625 0.25
vt 0.15625 0.5
vt 0.25 0.34375
vt 0.25 0.296875
vt 0.5 0.296875
vt 0.5 0.34375
vt 0 0.34375
vt 0 0.296875
vt 0.25 0.296875
vt 0.25 0.34375
vt 0.25 0.140625
vt 0.25 0.109375
vt 0.5 0.109375
vt 0.5 0.140625
vt 0 0.140625
vt 0 0.109375
vt 0.25 0.109375
vt 0.25 0.140625
vt 0.25 0.453125
vt 0.25 0.40625
vt 0.5 0.40625
vt 0.5 0.453125
vt 0 0.453125
vt 0 0.40625
vt 0.25 0.40625
vt 0.25 0.453125
vt 0.25 0.140625
vt 0.25 0.109375
vt 0.5 0.109375
vt 0.5 0.140625
vt 0 0.140625
vt 0 0.109375
vt 0.25 0.109375
vt 0.25 0.140625
vt 0.75 0.09375
vt 0.75 0.046875
vt 1 0.046875
vt 1 0.09375
vt 0.5 0.09375
vt 0.5 0.046875
vt 0.75 0.046875
vt 0.75 0.09375
vt 0.359375 0.25
vt 0.359375 0
vt 0.390625 0
vt 0.390625 0.25
vt 0.109375 0.25
vt 0.109375 0
vt 0.140625 0
vt 0.140625 0.25
vt 0.75 0.203125
vt 0.75 0.15625
vt 1 0.15625
vt 1 0.203125
vt 0.5 0.203125
vt 0.5 0.15625
vt 0.75 0.15625
vt 0.75 0.203125
vt 0.359375 0.25
vt 0.359375 0
vt 0.390625 0
vt 0.390625 0.25
vt 0.109375 0.25
vt 0.109375 0
vt 0.140625 0
vt 0.140625 0.25
vt 0.09375 0.15625
vt 0.09375 0.09375
vt 0.15625 0.09375
vt 0.15625 0.15625
vt 0.34375 0.15625
vt 0.34375 0.09375
vt 0.40625 0.09375
vt 0.40625 0.15625
vn -1 0 0
vn 1 0 0
vn 0 -1 0
vn 0 1 0
vn 0 -1 0
vn 0 1 0
vn 0 0 -1
vn 0 0 1
vn 0 -1 0
vn 0 1 0
vn 0 0 -1
vn 0 0 1
vn -1 0 0
vn 1 0 0
vn 0 0 -1
vn 0 0 1
vn -1 0 0
vn 1 0 0
vn 0 0 -1
vn 0 0 1
vn 0 0 1
vn 0 0 -1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 4/9/3 3/10/3 6/11/3 5/12/3
f 8/13/4 7/14/4 2/15/4 1/16/4
f 9/17/5 10/18/5 11/19/5 12/20/5
f 13/21/6 14/22/6 15/23/6 16/24/6
f 10/25/7 15/26/7 14/27/7 11/28/7
f 12/29/8 13/30/8 16/31/8 9/32/8
f 17/33/9 18/34/9 19/35/9 20/36/9
f 21/37/10 22/38/10 23/39/10 24/40/10
f 18/41/11 23/42/11 22/43/11 19/44/11
f 20/45/12 21/46/12 24/47/12 17/48/12
f 25/49/13 26/50/13 27/51/13 28/52/13
f 29/53/14 30/54/14 31/55/14 32/56/14
f 27/57/15 26/58/15 31/59/15 30/60/15
f 29/61/16 32/62/16 25/63/16 28/64/16
f 33/65/17 34/66/17 35/67/17 36/68/17
f 37/69/18 38/70/18 39/71/18 40/72/18
f 35/73/19 34/74/19 39/75/19 38/76/19
f 37/77/20 40/78/20 33/79/20 36/80/20
f 5/81/21 8/82/21 1/83/21 4/84/21
f 3/85/22 2/86/22 7/87/22 6/88/22
```

`assets/cubyz/models/fern.obj`:

```obj
o plane
v 0 0.5 -2.7755575615628914e-17
v 0 1.2071067811865475 0.7071067811865476
v 1 1.2071067811865475 0.7071067811865476
v 1 0.5 -2.7755575615628914e-17
vt 0 0
vt 0 0.25
vt 0.25 0.25
vt 0.25 0
vn 0 0.7071067811865476 -0.7071067811865475
f 1/1/1 2/2/1 3/3/1 4/4/1
o plane
v 1 0.5 -2.7755575615628914e-17
v 1 1.2071067811865475 0.7071067811865476
v 0 1.2071067811865475 0.7071067811865476
v 0 0.5 -2.7755575615628914e-17
vt 0.25 0
vt 0.25 0.25
vt 0 0.25
vt 0 0
vn 0 -0.7071067811865476 0.7071067811865475
f 5/5/2 6/6/2 7/7/2 8/8/2
o plane
v 0.9375 0.4999999999999995 -8.326672684688674e-16
v 0.9375 -0.2071067811865484 0.7071067811865466
v -0.0625 -0.20710678118654696 0.7071067811865481
v -0.0625 0.5000000000000009 6.106226635438361e-16
vt 0 0
vt 0 0.25
vt 0.25 0.25
vt 0.25 0
vn -2.109423746787797e-15 -0.7071067811865474 -0.7071067811865478
f 9/9/3 10/10/3 11/11/3 12/12/3
o plane
v -0.0625 0.500000000000001 6.869504964868156e-16
v -0.0625 -0.2071067811865469 0.7071067811865481
v 0.9375 -0.20710678118654835 0.7071067811865467
v 0.9375 0.49999999999999956 -7.91033905045424e-16
vt 0.25 0
vt 0.25 0.25
vt 0 0.25
vt 0 0
vn 1.9984014443252814e-15 0.7071067811865474 0.7071067811865478
f 13/13/4 14/14/4 15/15/4 16/16/4
o plane
v 0.43750000000000033 1.0312500000000007 1.1032841307212493e-15
v -0.2696067811865476 1.0312499999999991 0.7071067811865483
v -0.2696067811865476 0.03124999999999913 0.7071067811865462
v 0.43750000000000033 0.03125000000000068 -1.0061396160665481e-15
vt 0.25 0
vt 0.25 0.25
vt 0 0.25
vt 0 0
vn 0.7071067811865472 -1.5543122344752192e-15 0.7071067811865479
f 17/17/5 18/18/5 19/19/5 20/20/5
o plane
v 0.4375000000000002 0.03125000000000072 -1.0547118733938987e-15
v -0.2696067811865477 0.031249999999999167 0.7071067811865461
v -0.2696067811865477 1.0312499999999991 0.7071067811865483
v 0.4375000000000002 1.0312500000000007 1.0547118733938987e-15
vt 0 0
vt 0 0.25
vt 0.25 0.25
vt 0.25 0
vn -0.7071067811865472 1.5543122344752192e-15 -0.7071067811865479
f 21/21/6 22/22/6 23/23/6 24/24/6
o plane
v 0.49999999999999895 0.9687499999999996 4.371503159461554e-16
v 1.2071067811865486 0.9687500000000004 0.7071067811865459
v 1.2071067811865486 -0.031249999999999667 0.707106781186547
v 0.49999999999999895 -0.031250000000000444 1.547373340571312e-15
vt 0 0
vt 0 0.25
vt 0.25 0.25
vt 0.25 0
vn 0.7071067811865455 -7.771561172376094e-16 -0.7071067811865497
f 25/25/7 26/26/7 27/27/7 28/28/7
o plane
v 0.49999999999999895 -0.031250000000000444 1.547373340571312e-15
v 1.2071067811865486 -0.031249999999999667 0.707106781186547
v 1.2071067811865486 0.9687500000000004 0.7071067811865459
v 0.49999999999999895 0.9687499999999996 4.371503159461554e-16
vt 0.25 0
vt 0.25 0.25
vt 0 0.25
vt 0 0
vn -0.7071067811865455 8.326672684688672e-16 0.7071067811865497
f 29/29/8 30/30/8 31/31/8 32/32/8
```

`assets/cubyz/models/flower/height_10.obj`:

```obj
o unknown
v 1 1 1
v 1 1 0
v 0 0 0
v 0 0 1
v 0 0.9375 1
v 0 0.9375 0
v 0.9375 0 0
v 0.9375 0 1
vt 0.75 0.25
vt 0.75 0
vt 1 0
vt 1 0.25
vt 1 0.25
vt 1 0
vt 0.75 0
vt 0.75 0.25
vt 0.515625 0.25
vt 0.515625 0
vt 0.75 0
vt 0.75 0.25
vt 0.75 0.25
vt 0.75 0
vt 0.515625 0
vt 0.515625 0.25
vn -0.7071067811865476 0.7071067811865476 0
vn 0.7071067811865476 -0.7071067811865476 0
vn -0.7071067811865476 -0.7071067811865476 0
vn 0.7071067811865476 0.7071067811865476 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 4/5/2 3/6/2 2/7/2 1/8/2
f 5/9/3 6/10/3 7/11/3 8/12/3
f 8/13/4 7/14/4 6/15/4 5/16/4
o plane
v 1 0 0.625
v 1 1 0.625
v 0 1 0.625
v 0 0 0.625
vt 0 0.25
vt 0 0
vt 0.25 0
vt 0.25 0.25
vn 0 0 1
f 9/17/5 10/18/5 11/19/5 12/20/5
o plane
v 0 0 0.625
v 0 1 0.625
v 1 1 0.625
v 1 0 0.625
vt 0.25 0.25
vt 0.25 0
vt 0 0
vt 0 0.25
vn 0 0 -1
f 13/21/6 14/22/6 15/23/6 16/24/6
```

`assets/cubyz/models/flower/height_8.obj`:

```obj
o unknown
v 1 1 1
v 1 1 0
v 0 0 0
v 0 0 1
v 0 0.9375 1
v 0 0.9375 0
v 0.9375 0 0
v 0.9375 0 1
vt 0.75 0.25
vt 0.75 0
vt 1 0
vt 1 0.25
vt 1 0.25
vt 1 0
vt 0.75 0
vt 0.75 0.25
vt 0.515625 0.25
vt 0.515625 0
vt 0.75 0
vt 0.75 0.25
vt 0.75 0.25
vt 0.75 0
vt 0.515625 0
vt 0.515625 0.25
vn -0.7071067811865476 0.7071067811865476 0
vn 0.7071067811865476 -0.7071067811865476 0
vn -0.7071067811865476 -0.7071067811865476 0
vn 0.7071067811865476 0.7071067811865476 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 4/5/2 3/6/2 2/7/2 1/8/2
f 5/9/3 6/10/3 7/11/3 8/12/3
f 8/13/4 7/14/4 6/15/4 5/16/4
o plane
v 1 0 0.5
v 1 1 0.5
v 0 1 0.5
v 0 0 0.5
vt 0 0.25
vt 0 0
vt 0.25 0
vt 0.25 0.25
vn 0 0 1
f 9/17/5 10/18/5 11/19/5 12/20/5
o plane
v 0 0 0.5
v 0 1 0.5
v 1 1 0.5
v 1 0 0.5
vt 0.25 0.25
vt 0.25 0
vt 0 0
vt 0 0.25
vn 0 0 -1
f 13/21/6 14/22/6 15/23/6 16/24/6
```

`assets/cubyz/models/glimmergill/floor.obj`:

```obj
o unknown
v 1 1 0.25
v 1 1 0
v 0 0 0
v 0 0 0.25
v 0 1 0.25
v 0 1 0
v 1 0 0
v 1 0 0.25
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vn -0.7071067811865476 0.7071067811865476 0
vn 0.7071067811865476 -0.7071067811865476 0
vn -0.7071067811865476 -0.7071067811865476 0
vn 0.7071067811865476 0.7071067811865476 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 4/5/2 3/6/2 2/7/2 1/8/2
f 5/9/3 6/10/3 7/11/3 8/12/3
f 8/13/4 7/14/4 6/15/4 5/16/4
o unknown
v 0.75 0.25 0.4375
v 0.75 0.75 0.4375
v 0.25 0.75 0.4375
v 0.25 0.25 0.4375
v 0.25 0.25 0.25
v 0.25 0.75 0.25
v 0.75 0.75 0.25
v 0.75 0.25 0.25
vt 0 0.25
vt 0 0.125
vt 0.125 0.125
vt 0.125 0.25
vt 0.25 0.25
vt 0.25 0.125
vt 0.375 0.125
vt 0.375 0.25
vt 0.5625 0.109375
vt 0.5625 0.0625
vt 0.6875 0.0625
vt 0.6875 0.109375
vt 0.8125 0.109375
vt 0.8125 0.0625
vt 0.9375 0.0625
vt 0.9375 0.109375
vt 0.0625 0.359375
vt 0.0625 0.3125
vt 0.1875 0.3125
vt 0.1875 0.359375
vt 0.3125 0.359375
vt 0.3125 0.3125
vt 0.4375 0.3125
vt 0.4375 0.359375
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 9/17/5 10/18/5 11/19/5 12/20/5
f 13/21/6 14/22/6 15/23/6 16/24/6
f 9/25/7 16/26/7 15/27/7 10/28/7
f 11/29/8 14/30/8 13/31/8 12/32/8
f 10/33/9 15/34/9 14/35/9 11/36/9
f 12/37/10 13/38/10 16/39/10 9/40/10
```

`assets/cubyz/models/glimmergill/shelf.obj`:

```obj
o unknown
v 1.3877787807814457e-16 0.375 0.4375
v 0.2500000000000001 0.375 0.4375
v 0.25 0.875 0.4375
v 1.3877787807814457e-17 0.875 0.4375
v 1.3877787807814457e-17 0.875 0.25
v 0.25 0.875 0.25
v 0.2500000000000001 0.375 0.25
v 1.3877787807814457e-16 0.375 0.25
vt 0.125 0
vt 0.125 0.0625
vt 0 0.0625
vt 0 0
vt 0.25 0
vt 0.25 0.0625
vt 0.375 0.0625
vt 0.375 0
vt 0.75 0.21875
vt 0.75 0.171875
vt 0.8125 0.171875
vt 0.8125 0.21875
vt 0.8125 0.21875
vt 0.8125 0.171875
vt 0.875 0.171875
vt 0.875 0.21875
vt 0 0.46875
vt 0 0.421875
vt 0.125 0.421875
vt 0.125 0.46875
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
o unknown
v 2.0816681711721685e-16 0.125 0.8125
v 0.1875000000000002 0.125 0.8125
v 0.1875000000000001 0.5625 0.8125
v 9.71445146547012e-17 0.5625 0.8125
v 9.71445146547012e-17 0.5625 0.6875
v 0.1875000000000001 0.5625 0.6875
v 0.1875000000000002 0.125 0.6875
v 2.0816681711721685e-16 0.125 0.6875
vt 0.109375 0.0625
vt 0.109375 0.109375
vt 0 0.109375
vt 0 0.0625
vt 0.359375 0.0625
vt 0.359375 0.109375
vt 0.25 0.109375
vt 0.25 0.0625
vt 0.5 0.25
vt 0.5 0.21875
vt 0.546875 0.21875
vt 0.546875 0.25
vt 0.8125 0.25
vt 0.8125 0.21875
vt 0.859375 0.21875
vt 0.859375 0.25
vt 0 0.5
vt 0 0.46875
vt 0.109375 0.46875
vt 0.109375 0.5
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
f 9/21/6 10/22/6 11/23/6 12/24/6
f 13/25/7 14/26/7 15/27/7 16/28/7
f 9/29/8 16/30/8 15/31/8 10/32/8
f 11/33/9 14/34/9 13/35/9 12/36/9
f 10/37/10 15/38/10 14/39/10 11/40/10
```

`assets/cubyz/models/lantern/ceiling.obj`:

```obj
o unknown
v 0.3124999999999998 0.3125000000000002 0.625
v 0.6874999999999998 0.3124999999999998 0.625
v 0.6875000000000002 0.6874999999999998 0.625
v 0.3125000000000002 0.6875000000000002 0.625
v 0.3125000000000002 0.6875000000000002 0.1875
v 0.6875000000000002 0.6874999999999998 0.1875
v 0.6874999999999998 0.3124999999999998 0.1875
v 0.3124999999999998 0.3125000000000002 0.1875
vt 0.265625 0.109375
vt 0.265625 0.015625
vt 0.359375 0.015625
vt 0.359375 0.109375
vt 0.640625 0.109375
vt 0.640625 0
vt 0.734375 0
vt 0.734375 0.109375
vt 0.890625 0.109375
vt 0.890625 0
vt 0.984375 0
vt 0.984375 0.109375
vt 0.015625 0.359375
vt 0.015625 0.25
vt 0.109375 0.25
vt 0.109375 0.359375
vt 0.265625 0.359375
vt 0.265625 0.25
vt 0.359375 0.25
vt 0.359375 0.359375
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 5/1/1 6/2/1 7/3/1 8/4/1
f 1/5/2 8/6/2 7/7/2 2/8/2
f 3/9/3 6/10/3 5/11/3 4/12/3
f 2/13/4 7/14/4 6/15/4 3/16/4
f 4/17/5 5/18/5 8/19/5 1/20/5
o unknown
v 0.37499999999999983 0.37500000000000017 0.8125
v 0.6249999999999998 0.37499999999999983 0.8125
v 0.6250000000000002 0.6249999999999998 0.8125
v 0.37500000000000017 0.6250000000000002 0.8125
v 0.37500000000000017 0.6250000000000002 0.6875
v 0.6250000000000002 0.6249999999999998 0.6875
v 0.6249999999999998 0.37499999999999983 0.6875
v 0.37499999999999983 0.37500000000000017 0.6875
vt 0.03125 0.21875
vt 0.03125 0.15625
vt 0.09375 0.15625
vt 0.09375 0.21875
vt 0.53125 0.15625
vt 0.53125 0.125
vt 0.59375 0.125
vt 0.59375 0.15625
vt 0.78125 0.15625
vt 0.78125 0.125
vt 0.84375 0.125
vt 0.84375 0.15625
vt 0.03125 0.40625
vt 0.03125 0.375
vt 0.09375 0.375
vt 0.09375 0.40625
vt 0.28125 0.40625
vt 0.28125 0.375
vt 0.34375 0.375
vt 0.34375 0.40625
vn 0 0 1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 9/21/6 10/22/6 11/23/6 12/24/6
f 9/25/7 16/26/7 15/27/7 10/28/7
f 11/29/8 14/30/8 13/31/8 12/32/8
f 10/33/9 15/34/9 14/35/9 11/36/9
f 12/37/10 13/38/10 16/39/10 9/40/10
o unknown
v 0.24999999999999967 0.25000000000000033 0.6875
v 0.7499999999999997 0.24999999999999967 0.6875
v 0.7500000000000003 0.7499999999999997 0.6875
v 0.25000000000000033 0.7500000000000003 0.6875
v 0.25000000000000033 0.7500000000000003 0.625
v 0.7500000000000003 0.7499999999999997 0.625
v 0.7499999999999997 0.24999999999999967 0.625
v 0.24999999999999967 0.25000000000000033 0.625
vt 0.125 0.25
vt 0.125 0.125
vt 0.25 0.125
vt 0.25 0.25
vt 0.375 0.125
vt 0.375 0
vt 0.5 0
vt 0.5 0.125
vt 0.5 0.125
vt 0.5 0.109375
vt 0.625 0.109375
vt 0.625 0.125
vt 0.75 0.125
vt 0.75 0.109375
vt 0.875 0.109375
vt 0.875 0.125
vt 0 0.375
vt 0 0.359375
vt 0.125 0.359375
vt 0.125 0.375
vt 0.25 0.375
vt 0.25 0.359375
vt 0.375 0.359375
vt 0.375 0.375
vn 0 0 1
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 17/41/11 18/42/11 19/43/11 20/44/11
f 21/45/12 22/46/12 23/47/12 24/48/12
f 17/49/13 24/50/13 23/51/13 18/52/13
f 19/53/14 22/54/14 21/55/14 20/56/14
f 18/57/15 23/58/15 22/59/15 19/60/15
f 20/61/16 21/62/16 24/63/16 17/64/16
o plane
v 0.500000003226196 0.37500000000000266 0.8125000000000024
v 0.500000003226196 0.3750000000000063 1.0000000000000024
v 0.49999999677380386 0.6250000000000062 0.9999999999999977
v 0.4999999967738039 0.6250000000000027 0.8124999999999977
vt 0.59375 0.15625
vt 0.59375 0.203125
vt 0.53125 0.203125
vt 0.53125 0.15625
vn -0.9999999999999998 -2.5809568260370955e-8 -1.1102181247266996e-16
f 25/65/17 26/66/17 27/67/17 28/68/17
o plane
v 0.4999999967738039 0.6250000000000027 0.8124999999999977
v 0.49999999677380386 0.6250000000000062 0.9999999999999977
v 0.500000003226196 0.3750000000000063 1.0000000000000024
v 0.500000003226196 0.37500000000000266 0.8125000000000024
vt 0.53125 0.15625
vt 0.53125 0.203125
vt 0.59375 0.203125
vt 0.59375 0.15625
vn 0.9999999999999998 2.5809568260370955e-8 1.1102181247266996e-16
f 29/69/18 30/70/18 31/71/18 32/72/18
```

`assets/cubyz/models/lantern/floor.obj`:

```obj
o unknown
v 0.3124999999999998 0.3125000000000002 0.4375
v 0.6874999999999998 0.3124999999999998 0.4375
v 0.6875000000000002 0.6874999999999998 0.4375
v 0.3125000000000002 0.6875000000000002 0.4375
v 0.3125000000000002 0.6875000000000002 0
v 0.6875000000000002 0.6874999999999998 0
v 0.6874999999999998 0.3124999999999998 0
v 0.3124999999999998 0.3125000000000002 0
vt 0.265625 0.109375
vt 0.265625 0.015625
vt 0.359375 0.015625
vt 0.359375 0.109375
vt 0.640625 0.109375
vt 0.640625 0
vt 0.734375 0
vt 0.734375 0.109375
vt 0.890625 0.109375
vt 0.890625 0
vt 0.984375 0
vt 0.984375 0.109375
vt 0.015625 0.359375
vt 0.015625 0.25
vt 0.109375 0.25
vt 0.109375 0.359375
vt 0.265625 0.359375
vt 0.265625 0.25
vt 0.359375 0.25
vt 0.359375 0.359375
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 5/1/1 6/2/1 7/3/1 8/4/1
f 1/5/2 8/6/2 7/7/2 2/8/2
f 3/9/3 6/10/3 5/11/3 4/12/3
f 2/13/4 7/14/4 6/15/4 3/16/4
f 4/17/5 5/18/5 8/19/5 1/20/5
o unknown
v 0.37499999999999983 0.37500000000000017 0.625
v 0.6249999999999998 0.37499999999999983 0.625
v 0.6250000000000002 0.6249999999999998 0.625
v 0.37500000000000017 0.6250000000000002 0.625
v 0.37500000000000017 0.6250000000000002 0.5
v 0.6250000000000002 0.6249999999999998 0.5
v 0.6249999999999998 0.37499999999999983 0.5
v 0.37499999999999983 0.37500000000000017 0.5
vt 0.03125 0.21875
vt 0.03125 0.15625
vt 0.09375 0.15625
vt 0.09375 0.21875
vt 0.53125 0.15625
vt 0.53125 0.125
vt 0.59375 0.125
vt 0.59375 0.15625
vt 0.78125 0.15625
vt 0.78125 0.125
vt 0.84375 0.125
vt 0.84375 0.15625
vt 0.03125 0.40625
vt 0.03125 0.375
vt 0.09375 0.375
vt 0.09375 0.40625
vt 0.28125 0.40625
vt 0.28125 0.375
vt 0.34375 0.375
vt 0.34375 0.40625
vn 0 0 1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 9/21/6 10/22/6 11/23/6 12/24/6
f 9/25/7 16/26/7 15/27/7 10/28/7
f 11/29/8 14/30/8 13/31/8 12/32/8
f 10/33/9 15/34/9 14/35/9 11/36/9
f 12/37/10 13/38/10 16/39/10 9/40/10
o unknown
v 0.24999999999999967 0.25000000000000033 0.5
v 0.7499999999999997 0.24999999999999967 0.5
v 0.7500000000000003 0.7499999999999997 0.5
v 0.25000000000000033 0.7500000000000003 0.5
v 0.25000000000000033 0.7500000000000003 0.4375
v 0.7500000000000003 0.7499999999999997 0.4375
v 0.7499999999999997 0.24999999999999967 0.4375
v 0.24999999999999967 0.25000000000000033 0.4375
vt 0.125 0.25
vt 0.125 0.125
vt 0.25 0.125
vt 0.25 0.25
vt 0.375 0.125
vt 0.375 0
vt 0.5 0
vt 0.5 0.125
vt 0.5 0.125
vt 0.5 0.109375
vt 0.625 0.109375
vt 0.625 0.125
vt 0.75 0.125
vt 0.75 0.109375
vt 0.875 0.109375
vt 0.875 0.125
vt 0 0.375
vt 0 0.359375
vt 0.125 0.359375
vt 0.125 0.375
vt 0.25 0.375
vt 0.25 0.359375
vt 0.375 0.359375
vt 0.375 0.375
vn 0 0 1
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 17/41/11 18/42/11 19/43/11 20/44/11
f 21/45/12 22/46/12 23/47/12 24/48/12
f 17/49/13 24/50/13 23/51/13 18/52/13
f 19/53/14 22/54/14 21/55/14 20/56/14
f 18/57/15 23/58/15 22/59/15 19/60/15
f 20/61/16 21/62/16 24/63/16 17/64/16
o plane
v 0.500000003226196 0.37500000000000266 0.6250000000000024
v 0.500000003226196 0.3750000000000063 0.8125000000000024
v 0.49999999677380386 0.6250000000000062 0.8124999999999977
v 0.4999999967738039 0.6250000000000027 0.6249999999999977
vt 0.59375 0.15625
vt 0.59375 0.203125
vt 0.53125 0.203125
vt 0.53125 0.15625
vn -0.9999999999999998 -2.5809568260370955e-8 -1.1102181247266996e-16
f 25/65/17 26/66/17 27/67/17 28/68/17
o plane
v 0.4999999967738039 0.6250000000000027 0.6249999999999977
v 0.49999999677380386 0.6250000000000062 0.8124999999999977
v 0.500000003226196 0.3750000000000063 0.8125000000000024
v 0.500000003226196 0.37500000000000266 0.6250000000000024
vt 0.53125 0.15625
vt 0.53125 0.203125
vt 0.59375 0.203125
vt 0.59375 0.15625
vn 0.9999999999999998 2.5809568260370955e-8 1.1102181247266996e-16
f 29/69/18 30/70/18 31/71/18 32/72/18
```

`assets/cubyz/models/lantern/side.obj`:

```obj
o unknown
v -1.1102230246251565e-16 0.43750000000000033 0.875
v 0.6874999999999999 0.43749999999999944 0.875
v 0.6875000000000001 0.5624999999999994 0.875
v 8.326672684688674e-17 0.5625000000000003 0.875
v 8.326672684688674e-17 0.5625000000000003 0.75
v 0.6875000000000001 0.5624999999999994 0.75
v 0.6874999999999999 0.43749999999999944 0.75
v -1.1102230246251565e-16 0.43750000000000033 0.75
vt 0.75 0.25
vt 0.578125 0.25
vt 0.578125 0.21875
vt 0.75 0.21875
vt 0.75 0.25
vt 0.578125 0.25
vt 0.578125 0.21875
vt 0.75 0.21875
vt 0.75 0.25
vt 0.75 0.21875
vt 0.578125 0.21875
vt 0.578125 0.25
vt 0.828125 0.25
vt 0.828125 0.21875
vt 1 0.21875
vt 1 0.25
vt 0.09375 0.5
vt 0.09375 0.46875
vt 0.125 0.46875
vt 0.125 0.5
vt 0.125 0.5
vt 0.09375 0.5
vt 0.09375 0.46875
vt 0.125 0.46875
vn 0 0 1
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
f 1/21/6 4/22/6 5/23/6 8/24/6
o plane
v 0.4999999967738039 0.6250000000000027 0.6249999999999977
v 0.49999999677380386 0.6250000000000062 0.8124999999999977
v 0.500000003226196 0.3750000000000063 0.8125000000000024
v 0.500000003226196 0.37500000000000266 0.6250000000000024
vt 0.53125 0.15625
vt 0.53125 0.203125
vt 0.59375 0.203125
vt 0.59375 0.15625
vn 0.9999999999999998 2.5809568260370955e-8 1.1102181247266996e-16
f 9/25/7 10/26/7 11/27/7 12/28/7
o plane
v 0.500000003226196 0.37500000000000266 0.6250000000000024
v 0.500000003226196 0.3750000000000063 0.8125000000000024
v 0.49999999677380386 0.6250000000000062 0.8124999999999977
v 0.4999999967738039 0.6250000000000027 0.6249999999999977
vt 0.59375 0.15625
vt 0.59375 0.203125
vt 0.53125 0.203125
vt 0.53125 0.15625
vn -0.9999999999999998 -2.5809568260370955e-8 -1.1102181247266996e-16
f 13/29/8 14/30/8 15/31/8 16/32/8
o unknown
v 0.24999999999999967 0.25000000000000033 0.5
v 0.7499999999999997 0.24999999999999967 0.5
v 0.7500000000000003 0.7499999999999997 0.5
v 0.25000000000000033 0.7500000000000003 0.5
v 0.25000000000000033 0.7500000000000003 0.4375
v 0.7500000000000003 0.7499999999999997 0.4375
v 0.7499999999999997 0.24999999999999967 0.4375
v 0.24999999999999967 0.25000000000000033 0.4375
vt 0.125 0.25
vt 0.125 0.125
vt 0.25 0.125
vt 0.25 0.25
vt 0.375 0.125
vt 0.375 0
vt 0.5 0
vt 0.5 0.125
vt 0.5 0.125
vt 0.5 0.109375
vt 0.625 0.109375
vt 0.625 0.125
vt 0.75 0.125
vt 0.75 0.109375
vt 0.875 0.109375
vt 0.875 0.125
vt 0 0.375
vt 0 0.359375
vt 0.125 0.359375
vt 0.125 0.375
vt 0.25 0.375
vt 0.25 0.359375
vt 0.375 0.359375
vt 0.375 0.375
vn 0 0 1
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 17/33/9 18/34/9 19/35/9 20/36/9
f 21/37/10 22/38/10 23/39/10 24/40/10
f 17/41/11 24/42/11 23/43/11 18/44/11
f 19/45/12 22/46/12 21/47/12 20/48/12
f 18/49/13 23/50/13 22/51/13 19/52/13
f 20/53/14 21/54/14 24/55/14 17/56/14
o unknown
v 0.37499999999999983 0.37500000000000017 0.625
v 0.6249999999999998 0.37499999999999983 0.625
v 0.6250000000000002 0.6249999999999998 0.625
v 0.37500000000000017 0.6250000000000002 0.625
v 0.37500000000000017 0.6250000000000002 0.5
v 0.6250000000000002 0.6249999999999998 0.5
v 0.6249999999999998 0.37499999999999983 0.5
v 0.37499999999999983 0.37500000000000017 0.5
vt 0.03125 0.21875
vt 0.03125 0.15625
vt 0.09375 0.15625
vt 0.09375 0.21875
vt 0.53125 0.15625
vt 0.53125 0.125
vt 0.59375 0.125
vt 0.59375 0.15625
vt 0.78125 0.15625
vt 0.78125 0.125
vt 0.84375 0.125
vt 0.84375 0.15625
vt 0.03125 0.40625
vt 0.03125 0.375
vt 0.09375 0.375
vt 0.09375 0.40625
vt 0.28125 0.40625
vt 0.28125 0.375
vt 0.34375 0.375
vt 0.34375 0.40625
vn 0 0 1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 25/57/15 26/58/15 27/59/15 28/60/15
f 25/61/16 32/62/16 31/63/16 26/64/16
f 27/65/17 30/66/17 29/67/17 28/68/17
f 26/69/18 31/70/18 30/71/18 27/72/18
f 28/73/19 29/74/19 32/75/19 25/76/19
o unknown
v 0.3124999999999998 0.3125000000000002 0.4375
v 0.6874999999999998 0.3124999999999998 0.4375
v 0.6875000000000002 0.6874999999999998 0.4375
v 0.3125000000000002 0.6875000000000002 0.4375
v 0.3125000000000002 0.6875000000000002 0
v 0.6875000000000002 0.6874999999999998 0
v 0.6874999999999998 0.3124999999999998 0
v 0.3124999999999998 0.3125000000000002 0
vt 0.265625 0.109375
vt 0.265625 0.015625
vt 0.359375 0.015625
vt 0.359375 0.109375
vt 0.640625 0.109375
vt 0.640625 0
vt 0.734375 0
vt 0.734375 0.109375
vt 0.890625 0.109375
vt 0.890625 0
vt 0.984375 0
vt 0.984375 0.109375
vt 0.015625 0.359375
vt 0.015625 0.25
vt 0.109375 0.25
vt 0.109375 0.359375
vt 0.265625 0.359375
vt 0.265625 0.25
vt 0.359375 0.25
vt 0.359375 0.359375
vn 0 0 -1
vn -1.3322676295501878e-15 -1 0
vn 1.3322676295501878e-15 1 0
vn 1 -1.3322676295501878e-15 0
vn -1 1.3322676295501878e-15 0
f 37/77/20 38/78/20 39/79/20 40/80/20
f 33/81/21 40/82/21 39/83/21 34/84/21
f 35/85/22 38/86/22 37/87/22 36/88/22
f 34/89/23 39/90/23 38/91/23 35/92/23
f 36/93/24 37/94/24 40/95/24 33/96/24
```

`assets/cubyz/models/plane.obj`:

```obj
o plane
v 1 0 0.0625
v 1 1 0.0625
v 0 0 0.0625
v 0 1 0.0625
vt 0.25 0
vt 0.25 0.25
vt 0 0.25
vt 0 0
vn 0 0 1
f 1/1/1 2/2/1 4/3/1 3/4/1
o plane
v 0 0 0.0625
v 0 1 0.0625
v 1 0 0.0625
v 1 1 0.0625
vt 0 0
vt 0 0.25
vt 0.25 0.25
vt 0.25 0
vn 0 0 -1
f 5/5/2 6/6/2 8/7/2 7/8/2

```

`assets/cubyz/models/sign/ceiling.obj`:

```obj
o unknown
v 0.4687500000000001 0 0.5625
v 0.5312500000000001 0 0.5625
v 0.5312499999999999 1 0.5625
v 0.4687499999999999 1 0.5625
v 0.4687499999999999 1 0
v 0.5312499999999999 1 0
v 0.5312500000000001 0 0
v 0.4687500000000001 0 0
vt 0 0.25
vt 0 0.234375
vt 0.25 0.234375
vt 0.25 0.25
vt 0.25 0.125
vt 0.25 0.109375
vt 0.5 0.109375
vt 0.5 0.125
vt 0.5 0.25
vt 0.5 0.109375
vt 0.515625 0.109375
vt 0.515625 0.25
vt 0.984375 0.25
vt 0.984375 0.109375
vt 1 0.109375
vt 1 0.25
vt 0 0.5
vt 0 0.359375
vt 0.25 0.359375
vt 0.25 0.5
vt 0.25 0.5
vt 0.25 0.359375
vt 0.5 0.359375
vt 0.5 0.5
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
vn -1 -2.220446049250313e-16 0
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
f 4/21/6 5/22/6 8/23/6 1/24/6
f 1/1/1 2/2/1 3/3/1 4/4/1
o unknown
v 0.46875 0.125 1
v 0.53125 0.125 1
v 0.53125 0.25 1
v 0.46875 0.25 1
v 0.46875 0.25 0.5625
v 0.53125 0.25 0.5625
v 0.53125 0.125 0.5625
v 0.46875 0.125 0.5625
vt 0.109375 0.109375
vt 0.109375 0.09375
vt 0.140625 0.09375
vt 0.140625 0.109375
vt 0.609375 0.109375
vt 0.609375 0
vt 0.625 0
vt 0.625 0.109375
vt 0.875 0.109375
vt 0.875 0
vt 0.890625 0
vt 0.890625 0.109375
vt 0.109375 0.359375
vt 0.109375 0.25
vt 0.140625 0.25
vt 0.140625 0.359375
vt 0.359375 0.359375
vt 0.359375 0.25
vt 0.390625 0.25
vt 0.390625 0.359375
vn 0 0 1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
vn -1 -2.220446049250313e-16 0
f 9/25/7 10/26/7 11/27/7 12/28/7
f 9/29/8 16/30/8 15/31/8 10/32/8
f 11/33/9 14/34/9 13/35/9 12/36/9
f 10/37/10 15/38/10 14/39/10 11/40/10
f 12/41/11 13/42/11 16/43/11 9/44/11
o unknown
v 0.46875 0.75 1
v 0.53125 0.75 1
v 0.53125 0.875 1
v 0.46875 0.875 1
v 0.46875 0.875 0.5625
v 0.53125 0.875 0.5625
v 0.53125 0.75 0.5625
v 0.46875 0.75 0.5625
vt 0.109375 0.109375
vt 0.109375 0.09375
vt 0.140625 0.09375
vt 0.140625 0.109375
vt 0.609375 0.109375
vt 0.609375 0
vt 0.625 0
vt 0.625 0.109375
vt 0.875 0.109375
vt 0.875 0
vt 0.890625 0
vt 0.890625 0.109375
vt 0.109375 0.359375
vt 0.109375 0.25
vt 0.140625 0.25
vt 0.140625 0.359375
vt 0.359375 0.359375
vt 0.359375 0.25
vt 0.390625 0.25
vt 0.390625 0.359375
vn 0 0 1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
vn -1 -2.220446049250313e-16 0
f 17/45/12 18/46/12 19/47/12 20/48/12
f 17/49/13 24/50/13 23/51/13 18/52/13
f 19/53/14 22/54/14 21/55/14 20/56/14
f 18/57/15 23/58/15 22/59/15 19/60/15
f 20/61/16 21/62/16 24/63/16 17/64/16
```

`assets/cubyz/models/sign/floor.obj`:

```obj
o unknown
v 0.4687500000000001 0 1
v 0.5312500000000001 0 1
v 0.5312499999999999 1 1
v 0.4687499999999999 1 1
v 0.4687499999999999 1 0.4375
v 0.5312499999999999 1 0.4375
v 0.5312500000000001 0 0.4375
v 0.4687500000000001 0 0.4375
vt 0 0.25
vt 0 0.234375
vt 0.25 0.234375
vt 0.25 0.25
vt 0.25 0.125
vt 0.25 0.109375
vt 0.5 0.109375
vt 0.5 0.125
vt 0.5 0.25
vt 0.5 0.109375
vt 0.515625 0.109375
vt 0.515625 0.25
vt 0.984375 0.25
vt 0.984375 0.109375
vt 1 0.109375
vt 1 0.25
vt 0 0.5
vt 0 0.359375
vt 0.25 0.359375
vt 0.25 0.5
vt 0.25 0.5
vt 0.25 0.359375
vt 0.5 0.359375
vt 0.5 0.5
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
vn -1 -2.220446049250313e-16 0
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
f 4/21/6 5/22/6 8/23/6 1/24/6
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
o unknown
v 0.46875 0.4375 0.4375
v 0.53125 0.4375 0.4375
v 0.53125 0.5625 0.4375
v 0.46875 0.5625 0.4375
v 0.46875 0.5625 0
v 0.53125 0.5625 0
v 0.53125 0.4375 0
v 0.46875 0.4375 0
vt 0.359375 0.015625
vt 0.359375 0
vt 0.390625 0
vt 0.390625 0.015625
vt 0.609375 0.109375
vt 0.609375 0
vt 0.625 0
vt 0.625 0.109375
vt 0.875 0.109375
vt 0.875 0
vt 0.890625 0
vt 0.890625 0.109375
vt 0.109375 0.359375
vt 0.109375 0.25
vt 0.140625 0.25
vt 0.140625 0.359375
vt 0.359375 0.359375
vt 0.359375 0.25
vt 0.390625 0.25
vt 0.390625 0.359375
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
vn -1 -2.220446049250313e-16 0
f 13/25/7 14/26/7 15/27/7 16/28/7
f 9/29/8 16/30/8 15/31/8 10/32/8
f 11/33/9 14/34/9 13/35/9 12/36/9
f 10/37/10 15/38/10 14/39/10 11/40/10
f 12/41/11 13/42/11 16/43/11 9/44/11
```

`assets/cubyz/models/sign/side.obj`:

```obj
o unknown
v 1.1102230246251565e-16 0 0.8125
v 0.06250000000000011 0 0.8125
v 0.06249999999999989 1 0.8125
v -1.1102230246251565e-16 1 0.8125
v -1.1102230246251565e-16 1 0.25
v 0.06249999999999989 1 0.25
v 0.06250000000000011 0 0.25
v 1.1102230246251565e-16 0 0.25
vt 0 0.25
vt 0 0.234375
vt 0.25 0.234375
vt 0.25 0.25
vt 0.25 0.125
vt 0.25 0.109375
vt 0.5 0.109375
vt 0.5 0.125
vt 0.5 0.25
vt 0.5 0.109375
vt 0.515625 0.109375
vt 0.515625 0.25
vt 0.984375 0.25
vt 0.984375 0.109375
vt 1 0.109375
vt 1 0.25
vt 0 0.5
vt 0 0.359375
vt 0.25 0.359375
vt 0.25 0.5
vt 0.25 0.5
vt 0.25 0.359375
vt 0.5 0.359375
vt 0.5 0.5
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
vn -1 -2.220446049250313e-16 0
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
f 4/21/6 5/22/6 8/23/6 1/24/6
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
```

`assets/cubyz/models/toadstool/floor.obj`:

```obj
o unknown
v 1 1 0.25
v 1 1 0
v 0 0 0
v 0 0 0.25
v 0 1 0.25
v 0 1 0
v 1 0 0
v 1 0 0.25
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vt 0 0.3125
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.3125
vn -0.7071067811865476 0.7071067811865476 0
vn 0.7071067811865476 -0.7071067811865476 0
vn -0.7071067811865476 -0.7071067811865476 0
vn 0.7071067811865476 0.7071067811865476 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 4/5/2 3/6/2 2/7/2 1/8/2
f 5/9/3 6/10/3 7/11/3 8/12/3
f 8/13/4 7/14/4 6/15/4 5/16/4
o unknown
v 0.75 0.25 0.5
v 0.75 0.75 0.5
v 0.25 0.75 0.5
v 0.25 0.25 0.5
v 0.25 0.25 0.25
v 0.25 0.75 0.25
v 0.75 0.75 0.25
v 0.75 0.25 0.25
vt 0 0.25
vt 0 0.125
vt 0.125 0.125
vt 0.125 0.25
vt 0.25 0.25
vt 0.25 0.125
vt 0.375 0.125
vt 0.375 0.25
vt 0.5625 0.125
vt 0.5625 0.0625
vt 0.6875 0.0625
vt 0.6875 0.125
vt 0.8125 0.125
vt 0.8125 0.0625
vt 0.9375 0.0625
vt 0.9375 0.125
vt 0.0625 0.375
vt 0.0625 0.3125
vt 0.1875 0.3125
vt 0.1875 0.375
vt 0.3125 0.375
vt 0.3125 0.3125
vt 0.4375 0.3125
vt 0.4375 0.375
vn 0 0 1
vn 0 0 -1
vn 1 0 0
vn -1 0 0
vn 0 1 0
vn 0 -1 0
f 9/17/5 10/18/5 11/19/5 12/20/5
f 13/21/6 14/22/6 15/23/6 16/24/6
f 9/25/7 16/26/7 15/27/7 10/28/7
f 11/29/8 14/30/8 13/31/8 12/32/8
f 10/33/9 15/34/9 14/35/9 11/36/9
f 12/37/10 13/38/10 16/39/10 9/40/10
```

`assets/cubyz/models/toadstool/shelf.obj`:

```obj
o unknown
v 1.3877787807814457e-16 0.4375 0.5
v 0.2500000000000001 0.4375 0.5
v 0.25 0.875 0.5
v 1.3877787807814457e-17 0.875 0.5
v 1.3877787807814457e-17 0.875 0.25
v 0.25 0.875 0.25
v 0.2500000000000001 0.4375 0.25
v 1.3877787807814457e-16 0.4375 0.25
vt 0.109375 0
vt 0.109375 0.0625
vt 0 0.0625
vt 0 0
vt 0.25 0
vt 0.25 0.0625
vt 0.359375 0.0625
vt 0.359375 0
vt 0.75 0.203125
vt 0.75 0.140625
vt 0.8125 0.140625
vt 0.8125 0.203125
vt 0.796875 0.203125
vt 0.796875 0.140625
vt 0.859375 0.140625
vt 0.859375 0.203125
vt 0 0.453125
vt 0 0.390625
vt 0.109375 0.390625
vt 0.109375 0.453125
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 1/9/3 8/10/3 7/11/3 2/12/3
f 3/13/4 6/14/4 5/15/4 4/16/4
f 2/17/5 7/18/5 6/19/5 3/20/5
o unknown
v 2.0816681711721685e-16 0.125 0.875
v 0.1875000000000002 0.125 0.875
v 0.1875000000000001 0.5 0.875
v 9.71445146547012e-17 0.5 0.875
v 9.71445146547012e-17 0.5 0.6875
v 0.1875000000000001 0.5 0.6875
v 0.1875000000000002 0.125 0.6875
v 2.0816681711721685e-16 0.125 0.6875
vt 0.09375 0.0625
vt 0.09375 0.109375
vt 0 0.109375
vt 0 0.0625
vt 0.34375 0.0625
vt 0.34375 0.109375
vt 0.25 0.109375
vt 0.25 0.0625
vt 0.5 0.25
vt 0.5 0.203125
vt 0.546875 0.203125
vt 0.546875 0.25
vt 0.796875 0.25
vt 0.796875 0.203125
vt 0.84375 0.203125
vt 0.84375 0.25
vt 0 0.5
vt 0 0.453125
vt 0.09375 0.453125
vt 0.09375 0.5
vn 0 0 1
vn 0 0 -1
vn 2.220446049250313e-16 -1 0
vn -2.220446049250313e-16 1 0
vn 1 2.220446049250313e-16 0
f 9/21/6 10/22/6 11/23/6 12/24/6
f 13/25/7 14/26/7 15/27/7 16/28/7
f 9/29/8 16/30/8 15/31/8 10/32/8
f 11/33/9 14/34/9 13/35/9 12/36/9
f 10/37/10 15/38/10 14/39/10 11/40/10
```

`assets/cubyz/models/torch.obj`:

```obj
v 0.4375 0.5625 0
v 0.4375 0.5625 0.75
v 0.4375 0.4375 0
v 0.4375 0.4375 0.75
v 0.5625 0.4375 0
v 0.5625 0.4375 0.75
v 0.5625 0.5625 0
v 0.5625 0.5625 0.75
vt 0.75 0.0625
vt 0.75 0.25
vt 0.78125 0.0625
vt 0.78125 0.25
vt 0.5 0.0625
vt 0.5 0.25
vt 0.53125 0.0625
vt 0.53125 0.25
vt 0.25 0.3125
vt 0.25 0.5
vt 0.28125 0.3125
vt 0.28125 0.5
vt 0 0.3125
vt 0 0.5
vt 0.03125 0.3125
vt 0.03125 0.5
vt 0 0.03125
vt 0 0.0625
vt 0.03125 0.03125
vt 0.03125 0.0625
vt 0.25 0
vt 0.25 0.03125
vt 0.28125 0
vt 0.28125 0.03125
vn -1 0 0
vn 1 0 0
vn 0 -1 0
vn 0 1 0
vn 0 0 1
vn 0 0 -1
f 2/2/1 1/1/1 3/3/1 4/4/1
f 6/6/2 5/5/2 7/7/2 8/8/2
f 4/10/3 3/9/3 5/11/3 6/12/3
f 8/14/4 7/13/4 1/15/4 2/16/4
f 6/18/5 8/17/5 2/19/5 4/20/5
f 3/22/6 1/21/6 7/23/6 5/24/6

```

`assets/cubyz/models/torch_side.obj`:

```obj
v -0.107468665 0.5625 0.24080175
v 0.114171505 0.5625 0.9573041
v -0.107468665 0.4375 0.24080175
v 0.114171505 0.4375 0.9573041
v 0.011948407 0.4375 0.20386171
v 0.23358858 0.4375 0.92036414
v 0.011948407 0.5625 0.20386171
v 0.23358858 0.5625 0.92036414
vt 0.75 0.0625
vt 0.75 0.25
vt 0.78125 0.0625
vt 0.78125 0.25
vt 0.5 0.0625
vt 0.5 0.25
vt 0.53125 0.0625
vt 0.53125 0.25
vt 0.25 0.3125
vt 0.25 0.5
vt 0.28125 0.3125
vt 0.28125 0.5
vt 0 0.3125
vt 0 0.5
vt 0.03125 0.3125
vt 0.03125 0.5
vt 0 0.03125
vt 0 0.0625
vt 0.03125 0.03125
vt 0.03125 0.0625
vt 0.25 0
vt 0.25 0.03125
vt 0.28125 0
vt 0.28125 0.03125
vn -0.9553365 0 0.29552022
vn 0.9553365 0 -0.29552022
vn 0 -1 0
vn 0 1 0
vn 0.29552022 0 0.9553365
vn -0.29552022 0 -0.9553365
f 2/2/1 1/1/1 3/3/1 4/4/1
f 6/6/2 5/5/2 7/7/2 8/8/2
f 4/10/3 3/9/3 5/11/3 6/12/3
f 8/14/4 7/13/4 1/15/4 2/16/4
f 6/18/5 8/17/5 2/19/5 4/20/5
f 3/22/6 1/21/6 7/23/6 5/24/6

```

`assets/cubyz/models/wall.obj`:

```obj
o unknown
v 0.25 0.75 1
v 0.25 0.75 0
v 0.25 0.25 0
v 0.25 0.25 1
v 0.75 0.25 1
v 0.75 0.25 0
v 0.75 0.75 0
v 0.75 0.75 1
v 0 0.25 1
v 0 0.25 0
v 1 0.25 0
v 1 0.25 1
v 1 0.75 1
v 1 0.75 0
v 0 0.75 0
v 0 0.75 1
v 0.25 1 1
v 0.25 1 0
v 0.25 0 0
v 0.25 0 1
v 0.75 0 1
v 0.75 0 0
v 0.75 1 0
v 0.75 1 1
vt 0.8125 0.25
vt 0.8125 0
vt 0.9375 0
vt 0.9375 0.25
vt 0.5625 0.25
vt 0.5625 0
vt 0.6875 0
vt 0.6875 0.25
vt 0.3125 0.5
vt 0.3125 0.25
vt 0.4375 0.25
vt 0.4375 0.5
vt 0.0625 0.5
vt 0.0625 0.25
vt 0.1875 0.25
vt 0.1875 0.5
vt 0.25 0.5
vt 0.25 0.25
vt 0.5 0.25
vt 0.5 0.5
vt 0 0.5
vt 0 0.25
vt 0.25 0.25
vt 0.25 0.5
vt 0.25 0.1875
vt 0.25 0.0625
vt 0.5 0.0625
vt 0.5 0.1875
vt 0 0.1875
vt 0 0.0625
vt 0.25 0.0625
vt 0.25 0.1875
vt 0.75 0.25
vt 0.75 0
vt 1 0
vt 1 0.25
vt 0.5 0.25
vt 0.5 0
vt 0.75 0
vt 0.75 0.25
vt 0.3125 0.25
vt 0.3125 0
vt 0.4375 0
vt 0.4375 0.25
vt 0.0625 0.25
vt 0.0625 0
vt 0.1875 0
vt 0.1875 0.25
vt 0.0625 0.1875
vt 0.0625 0.0625
vt 0.1875 0.0625
vt 0.1875 0.1875
vt 0.3125 0.1875
vt 0.3125 0.0625
vt 0.4375 0.0625
vt 0.4375 0.1875
vn -1 0 0
vn 1 0 0
vn 0 -1 0
vn 0 1 0
vn 0 -1 0
vn 0 1 0
vn 0 0 -1
vn 0 0 1
vn -1 0 0
vn 1 0 0
vn 0 0 -1
vn 0 0 1
vn 0 0 1
vn 0 0 -1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 4/9/3 3/10/3 6/11/3 5/12/3
f 8/13/4 7/14/4 2/15/4 1/16/4
f 9/17/5 10/18/5 11/19/5 12/20/5
f 13/21/6 14/22/6 15/23/6 16/24/6
f 10/25/7 15/26/7 14/27/7 11/28/7
f 12/29/8 13/30/8 16/31/8 9/32/8
f 17/33/9 18/34/9 19/35/9 20/36/9
f 21/37/10 22/38/10 23/39/10 24/40/10
f 19/41/11 18/42/11 23/43/11 22/44/11
f 21/45/12 24/46/12 17/47/12 20/48/12
f 5/49/13 8/50/13 1/51/13 4/52/13
f 3/53/14 2/54/14 7/55/14 6/56/14
```

`assets/cubyz/particles/flame.zig.zon`:

```zon
.{
	.texture = "cubyz:flame",
	.density = .{0.00065, 0.00085},
	.rotationVelocity = .{20, 35},
	.dragCoefficient = .{0.2, 0.3},
}

```

`assets/cubyz/particles/poof.zig.zon`:

```zon
.{
	.texture = "cubyz:poof",
	.density = .{0.001, 0.001},
	.rotationVelocity = .{60, 80},
	.dragCoefficient = .{0.7, 0.8},
}

```

`assets/cubyz/recipes/brick_recipes.zig.zon`:

```zon
.{
	.{
		.inputs = .{"cubyz:{item}/base"},
		.output = "cubyz:{item}/tile",
	},
	.{
		.inputs = .{"cubyz:{item}/base"},
		.output = "cubyz:{item}/bricks",
	},
	.{
		.inputs = .{"cubyz:{item}/base"},
		.output = "2 cubyz:{item}/wall",
	},
	.{
		.inputs = .{"cubyz:{item}/base"},
		.output = "cubyz:{item}/cobble",
	},
}

```

`assets/cubyz/recipes/cloth_recipes.zig.zon`:

```zon
.{
	.{
		.inputs = .{"4 cubyz:cloth/{color}"},
		.output = "cubyz:cloth/block/{color}",
		.reversible = true,
	},
}

```

`assets/cubyz/recipes/special_recipes.zig.zon`:

```zon
.{
	.{
		.inputs = .{"cubyz:coal_ore", "{mod}:{type}_ore"},
		.output = "{mod}:{type}_ingot",
	},
	.{
		.inputs = .{"cubyz:coal_ore", "8 cubyz:clay"},
		.output = "8 cubyz:terracotta/base",
	},
	.{
		.inputs = .{"cubyz:coal_ore", "8 cubyz:sand"},
		.output = "8 cubyz:glass/white",
	},
	.{
		.inputs = .{"1 cubyz:torch", "2 cubyz:iron_ingot"},
		.output = "cubyz:lamp",
	},
	.{
		.inputs = .{"1 cubyz:sulfur_torch", "2 cubyz:iron_ingot"},
		.output = "cubyz:sulfur_lamp",
	},
	.{
		.inputs = .{"2 cubyz:torch", "1 cubyz:iron_ingot"},
		.output = "2 cubyz:lantern/coal",
	},
	.{
		.inputs = .{"2 cubyz:sulfur_torch", "1 cubyz:iron_ingot"},
		.output = "2 cubyz:lantern/sulfur",
	},
	.{
		.inputs = .{"4 cubyz:resin"},
		.output = "cubyz:resin_block",
	},
	.{
		.inputs = .{"4 cubyz:coal_ore"},
		.output = "cubyz:coal_block",
	},
	.{
		.inputs = .{"4 cubyz:sulfur_ore"},
		.output = "cubyz:sulfur_block",
	},
	.{
		.inputs = .{"4 cubyz:copper_ingot"},
		.output = "cubyz:copper_block",
	},
	.{
		.inputs = .{"4 cubyz:iron_ingot"},
		.output = "cubyz:iron_block",
	},
	.{
		.inputs = .{"1 cubyz:iron_ingot"},
		.output = "4 cubyz:chain/iron",
	},
	.{
		.inputs = .{"{mod}:{type}_ingot"},
		.output = "4 {mod}:bars/{type}",
	},
	.{
		.inputs = .{"4 cubyz:silver_ingot"},
		.output = "cubyz:silver_block",
	},
	.{
		.inputs = .{"4 cubyz:gold_ingot"},
		.output = "cubyz:gold_block",
	},
	.{
		.inputs = .{"4 cubyz:uranium_ingot"},
		.output = "cubyz:uranium_block",
	},
	.{
		.inputs = .{"8 cubyz:glass/white", "cubyz:uranium_ingot"},
		.output = "8 cubyz:glass/uranium",
	},
	.{
		.inputs = .{"4 cubyz:diamond_ore"},
		.output = "cubyz:diamond_block",
	},
	.{
		.inputs = .{"cubyz:diamond_block"},
		.output = "cubyz:cut_diamond_block",
	},
	.{
		.inputs = .{"4 cubyz:amber_ore"},
		.output = "cubyz:amber_block",
	},
	.{
		.inputs = .{"cubyz:amber_block"},
		.output = "cubyz:cut_amber_block",
	},
	.{
		.inputs = .{"4 cubyz:ruby_ore"},
		.output = "cubyz:ruby_block",
	},
	.{
		.inputs = .{"cubyz:ruby_block"},
		.output = "cubyz:cut_ruby_block",
	},
	.{
		.inputs = .{"cubyz:resin_block"},
		.output = "4 cubyz:resin",
	},
	.{
		.inputs = .{"cubyz:coal_block"},
		.output = "4 cubyz:coal_ore",
	},
	.{
		.inputs = .{"cubyz:sulfur_block"},
		.output = "4 cubyz:sulfur_ore",
	},
	.{
		.inputs = .{"cubyz:copper_block"},
		.output = "4 cubyz:copper_ingot",
	},
	.{
		.inputs = .{"cubyz:iron_block"},
		.output = "4 cubyz:iron_ingot",
	},
	.{
		.inputs = .{"cubyz:silver_block"},
		.output = "4 cubyz:silver_ingot",
	},
	.{
		.inputs = .{"cubyz:gold_block"},
		.output = "4 cubyz:gold_ingot",
	},
	.{
		.inputs = .{"cubyz:uranium_block"},
		.output = "4 cubyz:uranium_ingot",
	},
	.{
		.inputs = .{"cubyz:diamond_block"},
		.output = "4 cubyz:diamond_ore",
	},
	.{
		.inputs = .{"cubyz:cut_diamond_block"},
		.output = "4 cubyz:diamond_ore",
	},
	.{
		.inputs = .{"cubyz:amber_block"},
		.output = "4 cubyz:amber_ore",
	},
	.{
		.inputs = .{"cubyz:cut_amber_block"},
		.output = "4 cubyz:amber_ore",
	},
	.{
		.inputs = .{"cubyz:ruby_block"},
		.output = "4 cubyz:ruby_ore",
	},
	.{
		.inputs = .{"cubyz:cut_ruby_block"},
		.output = "4 cubyz:ruby_ore",
	},
	.{
		.inputs = .{"cubyz:gravel"},
		.output = "4 cubyz:pebbles",
		.reversible = true,
	},
}

```

`assets/cubyz/recipes/wood_recipes.zig.zon`:

```zon
.{
	.{
		.inputs = .{"4 {mod}:{type}_planks"},
		.output = "cubyz:workbench",
	},
	.{
		.inputs = .{"cubyz:log/{type}"},
		.output = "4 cubyz:{type}_planks",
	},
	.{
		.inputs = .{"cubyz:log/{type}"},
		.output = "2 cubyz:{type}_branch",
	},
	.{
		.inputs = .{"cubyz:{type}_branch"},
		.output = "2 cubyz:{type}_planks",
	},
	.{
		.inputs = .{"cubyz:{type}_planks"},
		.output = "2 cubyz:{type}_fence",
	},
	.{
		.inputs = .{"cubyz:{type}_planks"},
		.output = "cubyz:sign/{type}",
	},
	.{
		.inputs = .{"4 cubyz:{type}_planks"},
		.output = "cubyz:chest/{type}",
	},
	.{
		.inputs = .{"cubyz:log/cactus"},
		.output = "2 cubyz:cactus_arm",
	},
	.{
		.inputs = .{"cubyz:candy_cane/block"},
		.output = "2 cubyz:candy_cane/branch",
	},
	.{
		.inputs = .{"{mod}:{type}_planks", "cubyz:coal_ore"},
		.output = "8 cubyz:torch",
	},
	.{
		.inputs = .{"{mod}:{type}_planks", "cubyz:sulfur_ore"},
		.output = "8 cubyz:sulfur_torch",
	},
}

```

`assets/cubyz/sbb/cactus/arms.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:cactus/arm/0"},
		.{.id = "cubyz:cactus/arm/1"},
		.{.id = "cubyz:cactus/arm/2"},
		.{.id = "cubyz:cactus/arm/3"},
		.{.id = "cubyz:cactus/arm/4", .chance = 0.5},
		.{.id = null},
	},
}

```

`assets/cubyz/sbb/cactus/flower.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:cactus/flowers/0"},
		.{.id = null, .chance = 0.5},
	},
}

```

`assets/cubyz/sbb/cactus/saguaro.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:cactus/base/4_arms"},
		.{.id = "cubyz:cactus/base/3_arms"},
		.{.id = "cubyz:cactus/base/2_tall"},
		.{.id = "cubyz:cactus/base/2_tall_1"},
		.{.id = "cubyz:cactus/base/3_tall"},
		.{.id = "cubyz:cactus/base/3_tall_1"},
		.{.id = "cubyz:cactus/old_growth/0", .chance = 0.1},
		.{.id = "cubyz:cactus/old_growth/1", .chance = 0.1},
	},
	.children = .{
		.lime = "cubyz:cactus/arms",
		.pink = "cubyz:cactus/flower",
		.viridian = "cubyz:cactus/saguaro_upper",
	},
}

```

`assets/cubyz/sbb/cactus/saguaro_upper.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:cactus/upper/0"},
		.{.id = "cubyz:cactus/upper/1"},
		.{.id = "cubyz:cactus/upper/2"},
	},
	.children = .{
		.pink = "cubyz:cactus/flower",
	},
}

```

`assets/cubyz/sbb/cactus/young.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:cactus/young/2_tall"},
		.{.id = "cubyz:cactus/young/3_tall"},
		.{.id = "cubyz:cactus/young/4_tall"},
		.{.id = "cubyz:cactus/young/5_tall"},
		.{.id = "cubyz:cactus/young/5_tall_1"},
	},
}

```

`assets/cubyz/sbb/candy_cane/large.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/large/stem/8"},
		.{.id = "cubyz:candy_cane/large/stem/9"},
		.{.id = "cubyz:candy_cane/large/stem/10"},
		.{.id = "cubyz:candy_cane/large/stem/11"},
		.{.id = "cubyz:candy_cane/large/stem/12"},
		.{.id = "cubyz:candy_cane/large/stem/13"},
	},
	.children = .{
		.red = "cubyz:candy_cane/large/top",
	},
}

```

`assets/cubyz/sbb/candy_cane/large/top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/large/top/0"},
		.{.id = "cubyz:candy_cane/large/top/1"},
		.{.id = "cubyz:candy_cane/large/top/2"},
	},
}

```

`assets/cubyz/sbb/candy_cane/thick.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/thick/stem/3"},
		.{.id = "cubyz:candy_cane/thick/stem/4"},
		.{.id = "cubyz:candy_cane/thick/stem/5"},
		.{.id = "cubyz:candy_cane/thick/stem/6"},
		.{.id = "cubyz:candy_cane/thick/stem/7"},
		.{.id = "cubyz:candy_cane/thick/stem/8"},
		.{.id = "cubyz:candy_cane/thick/stem/9"},
	},
	.children = .{
		.red = "cubyz:candy_cane/thick/top",
	},
}

```

`assets/cubyz/sbb/candy_cane/thick/top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/thick/top/0"},
		.{.id = "cubyz:candy_cane/thick/top/1"},
	},
}

```

`assets/cubyz/sbb/candy_cane/thin/big.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/thin/stem/5"},
		.{.id = "cubyz:candy_cane/thin/stem/6"},
		.{.id = "cubyz:candy_cane/thin/stem/7"},
	},
	.children = .{
		.red = "cubyz:candy_cane/thin/top/big",
	},
}

```

`assets/cubyz/sbb/candy_cane/thin/small.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/thin/stem/2"},
		.{.id = "cubyz:candy_cane/thin/stem/3"},
		.{.id = "cubyz:candy_cane/thin/stem/4"},
		.{.id = "cubyz:candy_cane/thin/stem/5"},
	},
	.children = .{
		.red = "cubyz:candy_cane/thin/top/small",
	},
}

```

`assets/cubyz/sbb/candy_cane/thin/top/big.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/thin/top/big"},
	},
}

```

`assets/cubyz/sbb/candy_cane/thin/top/small.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:candy_cane/thin/top/small"},
	},
}

```

`assets/cubyz/sbb/cave/lava_spout.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:cave/lava_spout/0"},
		.{.id = "cubyz:cave/lava_spout/1"},
		.{.id = "cubyz:cave/lava_spout/2"},
		.{.id = "cubyz:cave/lava_spout/3"},
		.{.id = "cubyz:cave/lava_spout/4"},
	},
}

```

`assets/cubyz/sbb/deco/birch_leaf.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:deco/birch_leaf", .chance = 0.25},
		.{.id = null, .chance = 0.75},
	},
}

```

`assets/cubyz/sbb/deco/side.zig.zon`:

```zon
.{.blueprints = .{
	.{.id = "cubyz:deco/ivy_side_2", .chance = 0.1},
	.{.id = "cubyz:deco/ivy_side_3", .chance = 0.05},
	.{.id = "cubyz:deco/bolete_side", .chance = 0.025},
	.{.id = null, .chance = 0.825},
}}

```

`assets/cubyz/sbb/mushroom/big/bolete.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/bolete/base/0", .chance = 1},
		.{.id = "cubyz:mushroom/big/bolete/base/1", .chance = 1},
		.{.id = "cubyz:mushroom/big/bolete/base/2", .chance = 1},
		.{.id = "cubyz:mushroom/big/bolete/base/3", .chance = 1},
		.{.id = "cubyz:mushroom/big/bolete/base/4", .chance = 0.05},
	},
	.children = .{
		.white = "cubyz:mushroom/big/bolete/cap",
	},
}

```

`assets/cubyz/sbb/mushroom/big/bolete/cap.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/bolete/cap/0"},
		.{.id = "cubyz:mushroom/big/bolete/cap/1"},
		.{.id = "cubyz:mushroom/big/bolete/cap/2"},
		.{.id = "cubyz:mushroom/big/bolete/cap/3"},
		.{.id = "cubyz:mushroom/big/bolete/cap/4"},
	},
}

```

`assets/cubyz/sbb/mushroom/big/glimmergill.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/glimmergill/base/0"},
		.{.id = "cubyz:mushroom/big/glimmergill/base/1"},
		.{.id = "cubyz:mushroom/big/glimmergill/base/2"},
		.{.id = "cubyz:mushroom/big/glimmergill/base/3"},
	},
	.children = .{
		.white = "cubyz:mushroom/big/glimmergill/cap",
	},
}

```

`assets/cubyz/sbb/mushroom/big/glimmergill/cap.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/glimmergill/cap/0"},
		.{.id = "cubyz:mushroom/big/glimmergill/cap/1"},
		.{.id = "cubyz:mushroom/big/glimmergill/cap/2"},
		.{.id = "cubyz:mushroom/big/glimmergill/cap/3"},
		.{.id = "cubyz:mushroom/big/glimmergill/cap/4"},
		.{.id = "cubyz:mushroom/big/glimmergill/cap/5"},
		.{.id = "cubyz:mushroom/big/glimmergill/cap/6"},
	},
}

```

`assets/cubyz/sbb/mushroom/big/toadstool.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/toadstool/base/0"},
		.{.id = "cubyz:mushroom/big/toadstool/base/1"},
		.{.id = "cubyz:mushroom/big/toadstool/base/2"},
		.{.id = "cubyz:mushroom/big/toadstool/base/3"},
		.{.id = "cubyz:mushroom/big/toadstool/base/4"},
		.{.id = "cubyz:mushroom/big/toadstool/base/5"},
	},
	.children = .{
		.white = "cubyz:mushroom/big/toadstool/large_cap",
		.grey = "cubyz:mushroom/big/toadstool/small_cap",
		.crimson = "cubyz:mushroom/big/toadstool/branch/red",
		.green = "cubyz:mushroom/big/toadstool/branch/green",
		.blue = "cubyz:mushroom/big/toadstool/branch/blue",
	},
}

```

`assets/cubyz/sbb/mushroom/big/toadstool/branch/blue.zig.zon`:

```zon
.{.blueprints = .{
	.{.id = "cubyz:mushroom/big/toadstool/branch/red/0", .chance = 0.125},
	.{.id = "cubyz:mushroom/big/toadstool/branch/red/1", .chance = 0.125},
	.{.id = null, .chance = 0.75},
}}

```

`assets/cubyz/sbb/mushroom/big/toadstool/branch/green.zig.zon`:

```zon
.{.blueprints = .{
	.{.id = "cubyz:mushroom/big/toadstool/branch/green/0", .chance = 0.125},
	.{.id = "cubyz:mushroom/big/toadstool/branch/green/1", .chance = 0.125},
	.{.id = null, .chance = 0.75},
}}

```

`assets/cubyz/sbb/mushroom/big/toadstool/branch/red.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/toadstool/branch/blue/0", .chance = 0.125},
		.{.id = "cubyz:mushroom/big/toadstool/branch/blue/1", .chance = 0.125},
		.{.id = null, .chance = 0.75},
	},
}

```

`assets/cubyz/sbb/mushroom/big/toadstool/large_cap.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/toadstool/large_cap/0"},
		.{.id = "cubyz:mushroom/big/toadstool/large_cap/1"},
		.{.id = "cubyz:mushroom/big/toadstool/large_cap/2"},
		.{.id = "cubyz:mushroom/big/toadstool/large_cap/3"},
		.{.id = "cubyz:mushroom/big/toadstool/large_cap/4"},
	},
}

```

`assets/cubyz/sbb/mushroom/big/toadstool/small_cap.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/big/toadstool/small_cap/0"},
		.{.id = "cubyz:mushroom/big/toadstool/small_cap/1"},
		.{.id = "cubyz:mushroom/big/toadstool/small_cap/2"},
	},
}

```

`assets/cubyz/sbb/mushroom/side/bolete.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/side/bolete", .chance = 0.1},
		.{.id = null},
	},
}

```

`assets/cubyz/sbb/mushroom/small/bolete.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/small/bolete/variant/0"},
		.{.id = "cubyz:mushroom/small/bolete/variant/1"},
		.{.id = "cubyz:mushroom/small/bolete/variant/2"},
		.{.id = "cubyz:mushroom/small/bolete/variant/3"},
		.{.id = "cubyz:mushroom/small/bolete/variant/4"},
		.{.id = "cubyz:mushroom/small/bolete/variant/5"},
		.{.id = "cubyz:mushroom/small/bolete/variant/6"},
		.{.id = "cubyz:mushroom/small/bolete/variant/7"},
	},
}

```

`assets/cubyz/sbb/mushroom/small/glimmergill.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/small/glimmergill/variant/0"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/1"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/2"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/3"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/4"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/5"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/6"},
		.{.id = "cubyz:mushroom/small/glimmergill/variant/7"},
	},
}

```

`assets/cubyz/sbb/mushroom/small/toadstool.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:mushroom/small/toadstool/variant/0"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/1"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/2"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/3"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/4"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/5"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/6"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/7"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/8"},
		.{.id = "cubyz:mushroom/small/toadstool/variant/9"},
	},
}

```

`assets/cubyz/sbb/phantasmal/auroras/high.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/auroras/high/0", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/1", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/2", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/3", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/4", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/5", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/6", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/7", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/8", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/high/broken_0", .chance = 0.5},
		.{.id = "cubyz:phantasmal/auroras/high/broken_1", .chance = 0.5},
		.{.id = "cubyz:phantasmal/auroras/high/broken_2", .chance = 0.5},
	},
}

```

`assets/cubyz/sbb/phantasmal/auroras/low.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/auroras/low/0", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/1", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/2", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/3", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/4", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/5", .chance = 0.25},
		.{.id = "cubyz:phantasmal/auroras/low/6", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/7", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/8", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/9", .chance = 1},
		.{.id = "cubyz:phantasmal/auroras/low/broken_0", .chance = 0.5},
		.{.id = "cubyz:phantasmal/auroras/low/broken_1", .chance = 0.5},
		.{.id = "cubyz:phantasmal/auroras/low/broken_2", .chance = 0.5},
	},
}

```

`assets/cubyz/sbb/phantasmal/bubble/bubble.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/bubble/0", .chance = 1.2},
		.{.id = "cubyz:phantasmal/bubble/1", .chance = 0.9},
		.{.id = "cubyz:phantasmal/bubble/2", .chance = 0.7},
		.{.id = "cubyz:phantasmal/bubble/3", .chance = 0.6},
		.{.id = "cubyz:phantasmal/bubble/4", .chance = 0.5},
		.{.id = "cubyz:phantasmal/bubble/5", .chance = 0.4},
		.{.id = "cubyz:phantasmal/bubble/broken_0", .chance = 0.5},
		.{.id = "cubyz:phantasmal/bubble/broken_1", .chance = 0.5},
		.{.id = "cubyz:phantasmal/bubble/broken_2", .chance = 0.5},
		.{.id = "cubyz:phantasmal/bubble/abandoned", .chance = 0.03},
		.{.id = "cubyz:phantasmal/bubble/red", .chance = 0.02},
	},
}

```

`assets/cubyz/sbb/phantasmal/phantasmal_pillars.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/base/small/0", .chance = 1},
		.{.id = "cubyz:phantasmal/base/small/1", .chance = 1},
		.{.id = "cubyz:phantasmal/base/small/2", .chance = 1},
		.{.id = "cubyz:phantasmal/base/small/3", .chance = 1},
		.{.id = "cubyz:phantasmal/base/small/4", .chance = 1},
		.{.id = "cubyz:phantasmal/base/small/5", .chance = 1},
		.{.id = "cubyz:phantasmal/base/medium/0", .chance = 0.3},
		.{.id = "cubyz:phantasmal/base/medium/1", .chance = 0.3},
		.{.id = "cubyz:phantasmal/base/medium/2", .chance = 0.3},
		.{.id = "cubyz:phantasmal/base/medium/3", .chance = 0.3},
		.{.id = "cubyz:phantasmal/base/large/0", .chance = 0.1},
		.{.id = "cubyz:phantasmal/base/large/1", .chance = 0.1},
		.{.id = "cubyz:phantasmal/base/large/2", .chance = 0.1},
	},
	.children = .{
		.black = "cubyz:phantasmal/pillar/large/large",
		.dark_grey = "cubyz:phantasmal/pillar/medium/medium",
		.grey = "cubyz:phantasmal/pillar/small/small",
	},
}

```

`assets/cubyz/sbb/phantasmal/pillar/large/large.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/pillar/large/0", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/large/1", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/large/2", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/large/3", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/large/4", .chance = 1},
		.{.id = null, .chance = 0.3},
	},
	.children = .{
		.white = "cubyz:phantasmal/pillar/offshoot/offshoot",
		.purple = "cubyz:phantasmal/pillar/top/top",
	},
}

```

`assets/cubyz/sbb/phantasmal/pillar/medium/medium.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/pillar/medium/0", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/medium/1", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/medium/2", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/medium/3", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/medium/4", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/medium/5", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/medium/6", .chance = 1},
		.{.id = null, .chance = 0.6},
	},
	.children = .{
		.white = "cubyz:phantasmal/pillar/offshoot/offshoot",
		.purple = "cubyz:phantasmal/pillar/top/top",
	},
}

```

`assets/cubyz/sbb/phantasmal/pillar/offshoot/offshoot.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/pillar/offshoot/0", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/1", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/2", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/3", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/4", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/5", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/6", .chance = 0.5},
		.{.id = "cubyz:phantasmal/pillar/offshoot/7", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/8", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/9", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/10", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/11", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/12", .chance = 0.08},
		.{.id = "cubyz:phantasmal/pillar/offshoot/13", .chance = 1.2},
		.{.id = "cubyz:phantasmal/pillar/offshoot/14", .chance = 0.8},
		.{.id = null, .chance = 0.3},
	},
}

```

`assets/cubyz/sbb/phantasmal/pillar/small/small.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/pillar/small/0", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/1", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/2", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/3", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/4", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/5", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/6", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/7", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/8", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/small/9", .chance = 1},
		.{.id = null, .chance = 2.3},
	},
	.children = .{
		.white = "cubyz:phantasmal/pillar/offshoot/offshoot",
		.purple = "cubyz:phantasmal/pillar/top/top",
	},
}

```

`assets/cubyz/sbb/phantasmal/pillar/top/top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/pillar/top/0", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/1", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/2", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/3", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/4", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/5", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/6", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/7", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/8", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/9", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/10", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/11", .chance = 1},
		.{.id = "cubyz:phantasmal/pillar/top/12", .chance = 1},
		.{.id = null, .chance = 8},
	},
}

```

`assets/cubyz/sbb/phantasmal/star/stars.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:phantasmal/star/0", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/1", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/2", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/3", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/4", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/5", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/6", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/7", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/8", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/broken_0", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/broken_1", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/broken_2", .chance = 0.25},
		.{.id = "cubyz:phantasmal/star/blood_star", .chance = 0.01},
	},
}

```

`assets/cubyz/sbb/rare/snow_snale.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:rare/snow_snale/small/0"},
		.{.id = "cubyz:rare/snow_snale/small/1"},
		.{.id = "cubyz:rare/snow_snale/baby"},
		.{.id = "cubyz:rare/snow_snale/shelled"},
		.{.id = "cubyz:rare/snow_snale/medium", .chance = 0.8},
		.{.id = "cubyz:rare/snow_snale/large", .chance = 0.4},
	},
}

```

`assets/cubyz/sbb/rock/hoodoo/large.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:rock/hoodoo/large/0"},
		.{.id = "cubyz:rock/hoodoo/large/1"},
		.{.id = "cubyz:rock/hoodoo/large/2"},
	},
}

```

`assets/cubyz/sbb/rock/hoodoo/small_medium.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:rock/hoodoo/small/0"},
		.{.id = "cubyz:rock/hoodoo/medium/0"},
		.{.id = "cubyz:rock/hoodoo/medium/1"},
		.{.id = "cubyz:rock/hoodoo/medium/2"},
		.{.id = "cubyz:rock/hoodoo/medium/3"},
		.{.id = "cubyz:rock/hoodoo/medium/4"},
		.{.id = "cubyz:rock/hoodoo/medium/5"},
	},
}

```

`assets/cubyz/sbb/tree/baobab/grandidieri.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/grandidieri/trunk/0"},
		.{.id = "cubyz:tree/baobab/grandidieri/trunk/1"},
		.{.id = "cubyz:tree/baobab/grandidieri/trunk/2"},
		.{.id = "cubyz:tree/baobab/grandidieri/trunk/3"},
	},
	.children = .{
		.white = "cubyz:tree/baobab/grandidieri/branch",
		.grey = "cubyz:tree/baobab/grandidieri/leaves",
		.brown = "cubyz:tree/baobab/grandidieri/roots",
	},
}

```

`assets/cubyz/sbb/tree/baobab/grandidieri/branch.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/grandidieri/branch/0"},
		.{.id = "cubyz:tree/baobab/grandidieri/branch/1"},
		.{.id = "cubyz:tree/baobab/grandidieri/branch/2"},
		.{.id = "cubyz:tree/baobab/grandidieri/branch/3"},
	},
	.children = .{
		.grey = "cubyz:tree/baobab/grandidieri/leaves",
	},
}

```

`assets/cubyz/sbb/tree/baobab/grandidieri/leaves.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/grandidieri/leaves/0"},
		.{.id = "cubyz:tree/baobab/grandidieri/leaves/1"},
	},
}

```

`assets/cubyz/sbb/tree/baobab/grandidieri/roots.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/grandidieri/roots/0"},
		.{.id = "cubyz:tree/baobab/grandidieri/roots/1"},
	},
}

```

`assets/cubyz/sbb/tree/baobab/young.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/young/trunk/0"},
		.{.id = "cubyz:tree/baobab/young/trunk/1"},
		.{.id = "cubyz:tree/baobab/young/trunk/2"},
		.{.id = "cubyz:tree/baobab/young/trunk/3"},
	},
	.children = .{
		.white = "cubyz:tree/baobab/young/leaves/side",
		.grey = "cubyz:tree/baobab/young/leaves/top",
	},
}

```

`assets/cubyz/sbb/tree/baobab/young/leaves/side.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/young/leaves/side/0"},
		.{.id = "cubyz:tree/baobab/young/leaves/side/1"},
		.{.id = "cubyz:tree/baobab/young/leaves/side/2"},
		.{.id = "cubyz:tree/baobab/young/leaves/side/3"},
	},
}

```

`assets/cubyz/sbb/tree/baobab/young/leaves/top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/baobab/young/leaves/top/0"},
		.{.id = "cubyz:tree/baobab/young/leaves/top/1"},
		.{.id = "cubyz:tree/baobab/young/leaves/top/2"},
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/1.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/trunk/1"},
		.{.id = "cubyz:tree/birch/trunk/2"},
		.{.id = "cubyz:tree/birch/trunk/3"},
	},
	.children = .{
		.crimson = "cubyz:tree/birch/silver/branch",
		.blue = "cubyz:tree/birch/silver/leaf",
		.yellow = "cubyz:tree/birch/silver/root",
		.lime = "cubyz:tree/birch/silver/stub",
		.pink = "cubyz:deco/side",
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/2.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/trunk/4"},
	},
	.children = .{
		.crimson = "cubyz:tree/birch/silver/mixed_branch",
		.blue = "cubyz:tree/birch/silver/top",
		.yellow = "cubyz:tree/birch/silver/root",
		.magenta = "cubyz:tree/birch/silver/small_branch",
		.lime = "cubyz:tree/birch/silver/top",
		.pink = "cubyz:deco/side",
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/branch.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/branch/1"},
		.{.id = "cubyz:tree/birch/branch/2"},
		.{.id = "cubyz:tree/birch/branch/3"},
	},
	.children = .{
		.crimson = "cubyz:tree/birch/silver/leaf",
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/leaf.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/leaf/1"},
	},
	.children = .{
		.lime = "cubyz:deco/birch_leaf",
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/mixed_branch.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/branch/1"},
		.{.id = "cubyz:tree/birch/branch/2"},
		.{.id = "cubyz:tree/birch/branch/3"},
		.{.id = "cubyz:tree/birch/small_branch/1"},
		.{.id = "cubyz:tree/birch/small_branch/2"},
		.{.id = "cubyz:tree/birch/small_branch/3"},
	},
	.children = .{
		.crimson = "cubyz:tree/birch/silver/leaf",
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/root.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/root/1"},
		.{.id = "cubyz:tree/birch/root/2"},
		.{.id = "cubyz:tree/birch/root/3"},
		.{.id = null},
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/small_branch.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/small_branch/1"},
		.{.id = "cubyz:tree/birch/small_branch/2"},
		.{.id = "cubyz:tree/birch/small_branch/3"},
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/stub.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/stub/1", .chance = 0.1},
		.{.id = "cubyz:tree/birch/stub/2", .chance = 0.1},
		.{.id = "cubyz:tree/birch/stub/3", .chance = 0.1},
		.{.id = "cubyz:tree/birch/stub/4", .chance = 0.1},
		.{.id = null, .chance = 0.6},
	},
}

```

`assets/cubyz/sbb/tree/birch/silver/top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/birch/top/1"},
		.{.id = "cubyz:tree/birch/top/2"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/core"},
	},
	.children = .{
		.white = "cubyz:tree/coniferous/pine/eastern_white/1_branchless_trunk",
		.black = "cubyz:tree/coniferous/tree_roots",
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/1_branchless_trunk.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/stem/extender/0"},
		.{.id = "cubyz:tree/coniferous/stem/extender/1"},
		.{.id = "cubyz:tree/coniferous/stem/extender/2"},
	},
	.children = .{
		.white = "cubyz:tree/coniferous/pine/eastern_white/2_branched_trunk",
		.red = "cubyz:mushroom/side/bolete",
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/2_branched_trunk.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/stem/5/0"},
	},
	.children = .{
		.white = "cubyz:tree/coniferous/pine/eastern_white/3_tip",
		.purple = "cubyz:tree/coniferous/pine/eastern_white/branches/normal/4_top",
		.crimson = "cubyz:tree/coniferous/pine/eastern_white/branches/normal/3_middle_top",
		.red = "cubyz:tree/coniferous/pine/eastern_white/branches/normal/2_middle",
		.orange = "cubyz:tree/coniferous/pine/eastern_white/branches/normal/1_bottom_middle",
		.yellow = "cubyz:tree/coniferous/pine/eastern_white/branches/normal/0_bottom",
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/3_tip.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/tip/4/0"},
		.{.id = "cubyz:tree/coniferous/tip/4/1"},
		.{.id = "cubyz:tree/coniferous/tip/4/2"},
		.{.id = "cubyz:tree/coniferous/tip/4/3"},
		.{.id = "cubyz:tree/coniferous/tip/5/0"},
		.{.id = "cubyz:tree/coniferous/tip/5/1"},
		.{.id = "cubyz:tree/coniferous/tip/5/2"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/branches/normal/0_bottom.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/normal/1/0"},
		.{.id = "cubyz:tree/coniferous/branch/normal/1/1"},
		.{.id = null},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/branches/normal/1_bottom_middle.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/normal/1/0"},
		.{.id = "cubyz:tree/coniferous/branch/normal/1/1"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/0"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/1"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/2"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/3"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/4"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/branches/normal/2_middle.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/normal/5/0"},
		.{.id = "cubyz:tree/coniferous/branch/normal/5/1"},
		.{.id = "cubyz:tree/coniferous/branch/normal/5/2"},
		.{.id = "cubyz:tree/coniferous/branch/normal/5/3"},
		.{.id = "cubyz:tree/coniferous/branch/normal/5/4"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/branches/normal/3_middle_top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/normal/4/0"},
		.{.id = "cubyz:tree/coniferous/branch/normal/4/1"},
		.{.id = "cubyz:tree/coniferous/branch/normal/4/2"},
		.{.id = "cubyz:tree/coniferous/branch/normal/4/3"},
		.{.id = "cubyz:tree/coniferous/branch/normal/4/4"},
		.{.id = "cubyz:tree/coniferous/branch/normal/4/5"},
		.{.id = "cubyz:tree/coniferous/branch/normal/4/6"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/eastern_white/branches/normal/4_top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/normal/2/3"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/4"},
		.{.id = "cubyz:tree/coniferous/branch/normal/2/5"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/core"},
	},
	.children = .{
		.white = "cubyz:tree/coniferous/pine/loblolly/1_branchless_trunk",
		.black = "cubyz:tree/coniferous/tree_roots",
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly/1_branchless_trunk.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/stem/extender/3"},
		.{.id = "cubyz:tree/coniferous/stem/extender/4"},
		.{.id = "cubyz:tree/coniferous/stem/extender/5"},
	},
	.children = .{
		.white = "cubyz:tree/coniferous/pine/loblolly/2_branched_trunk",
		.red = "cubyz:mushroom/side/bolete",
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly/2_branched_trunk.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/stem/3/0"},
	},
	.children = .{
		.white = "cubyz:tree/coniferous/pine/loblolly/3_tip",
		.red = "cubyz:tree/coniferous/pine/loblolly/branches/lushy/2_top",
		.orange = "cubyz:tree/coniferous/pine/loblolly/branches/lushy/1_middle",
		.yellow = "cubyz:tree/coniferous/pine/loblolly/branches/lushy/0_bottom",
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly/3_tip.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/tip/4/0"},
		.{.id = "cubyz:tree/coniferous/tip/4/1"},
		.{.id = "cubyz:tree/coniferous/tip/4/2"},
		.{.id = "cubyz:tree/coniferous/tip/4/3"},
		.{.id = "cubyz:tree/coniferous/tip/5/0"},
		.{.id = "cubyz:tree/coniferous/tip/5/1"},
		.{.id = "cubyz:tree/coniferous/tip/5/2"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly/branches/lushy/0_bottom.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/lushy/4/0"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly/branches/lushy/1_middle.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/lushy/3/0"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/loblolly/branches/lushy/2_top.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/branch/lushy/2/0"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/pine/young_tree.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/sapling/0"},
		.{.id = "cubyz:tree/coniferous/sapling/1"},
		.{.id = "cubyz:tree/coniferous/sapling/2"},
		.{.id = "cubyz:tree/coniferous/sapling/3"},
		.{.id = "cubyz:tree/coniferous/sapling/4"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/standalone_roots.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/roots/alone/0"},
		.{.id = "cubyz:tree/coniferous/roots/alone/1"},
		.{.id = "cubyz:tree/coniferous/roots/alone/2"},
		.{.id = "cubyz:tree/coniferous/roots/alone/3"},
	},
}

```

`assets/cubyz/sbb/tree/coniferous/tree_roots.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/coniferous/roots/0"},
		.{.id = "cubyz:tree/coniferous/roots/1"},
		.{.id = "cubyz:tree/coniferous/roots/2"},
	},
}

```

`assets/cubyz/sbb/tree/curl.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/curl/base/0"},
		.{.id = "cubyz:tree/curl/base/1"},
	},
	.children = .{
		.white = "cubyz:tree/curl/curl",
	},
}

```

`assets/cubyz/sbb/tree/curl/curl.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/curl/curl/0"},
		.{.id = "cubyz:tree/curl/curl/1"},
		.{.id = "cubyz:tree/curl/curl/2"},
		.{.id = "cubyz:tree/curl/curl/3"},
		.{.id = "cubyz:tree/curl/curl/4"},
	},
}

```

`assets/cubyz/sbb/tree/oak/white.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/oak/base/1"},
		.{.id = "cubyz:tree/oak/base/2"},
		.{.id = "cubyz:tree/oak/base/3"},
	},
	.children = .{
		.crimson = "cubyz:tree/oak/white/root",
		.red = "cubyz:tree/oak/white/root",
		.blue = "cubyz:tree/oak/white/root",
		.brown = "cubyz:tree/oak/white/trunk",
	},
}

```

`assets/cubyz/sbb/tree/oak/white/branch.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/oak/branch/1"},
		.{.id = "cubyz:tree/oak/branch/2"},
		.{.id = "cubyz:tree/oak/branch/3"},
	},
	.children = .{
		.crimson = "cubyz:tree/oak/white/leaf",
	},
}

```

`assets/cubyz/sbb/tree/oak/white/leaf.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/oak/leaf/1"},
		.{.id = "cubyz:tree/oak/leaf/2"},
		.{.id = "cubyz:tree/oak/leaf/3"},
	},
}

```

`assets/cubyz/sbb/tree/oak/white/root.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/oak/root/1", .chance = 0.125},
		.{.id = "cubyz:tree/oak/root/2", .chance = 0.125},
		.{.id = "cubyz:tree/oak/root/3", .chance = 0.125},
		.{.id = "cubyz:tree/oak/root/4", .chance = 0.125},
		.{.id = "cubyz:tree/oak/root/5", .chance = 0.125},
		.{.id = "cubyz:tree/oak/root/6", .chance = 0.125},
		.{.id = null, .chance = 0.25},
	},
}

```

`assets/cubyz/sbb/tree/oak/white/stub.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/oak/stub/1", .chance = 0.1},
		.{.id = "cubyz:tree/oak/stub/2", .chance = 0.1},
		.{.id = "cubyz:tree/oak/stub/3", .chance = 0.1},
		.{.id = "cubyz:tree/oak/stub/4", .chance = 0.1},
		.{.id = null, .chance = 0.6},
	},
}

```

`assets/cubyz/sbb/tree/oak/white/trunk.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/oak/trunk/1"},
		.{.id = "cubyz:tree/oak/trunk/2"},
		.{.id = "cubyz:tree/oak/trunk/3"},
		.{.id = "cubyz:tree/oak/trunk/4"},
		.{.id = "cubyz:tree/oak/trunk/5"},
		.{.id = "cubyz:tree/oak/trunk/6"},
	},
	.children = .{
		.blue = "cubyz:tree/oak/white/branch",
		.crimson = "cubyz:tree/oak/white/leaf",
		.yellow = "cubyz:tree/oak/white/stub",
	},
}

```

`assets/cubyz/sbb/tree/palm/coconut.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/6"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/6a"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/7"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/8"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/8a"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/9"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/10"},
		.{.id = "cubyz:tree/palm/coconut/trunk/straight/11"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/6"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/6a"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/7"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/7a"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/8"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/9"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/10"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/11"},
		.{.id = "cubyz:tree/palm/coconut/trunk/tilt/12"},
		.{.id = "cubyz:tree/palm/coconut/trunk/leaning/7"},
		.{.id = "cubyz:tree/palm/coconut/trunk/leaning/8"},
		.{.id = "cubyz:tree/palm/coconut/trunk/leaning/9"},
		.{.id = "cubyz:tree/palm/coconut/trunk/leaning/10"},
		.{.id = "cubyz:tree/palm/coconut/trunk/leaning/11"},
		.{.id = "cubyz:tree/palm/coconut/trunk/leaning/12"},
	},
	.children = .{
		.lime = "cubyz:tree/palm/coconut/fronds",
	},
}

```

`assets/cubyz/sbb/tree/palm/coconut/fronds.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/palm/coconut/fronds/0"},
		.{.id = "cubyz:tree/palm/coconut/fronds/1"},
		.{.id = "cubyz:tree/palm/coconut/fronds/2"},
		.{.id = "cubyz:tree/palm/coconut/fronds/3"},
		.{.id = "cubyz:tree/palm/coconut/fronds/4"},
	},
}

```

`assets/cubyz/sbb/tree/tuften/tuft_canopy.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/tuften/tufts/small/0/violet"},
		.{.id = "cubyz:tree/tuften/tufts/small/0/pink"},
		.{.id = "cubyz:tree/tuften/tufts/small/0/red"},
		.{.id = "cubyz:tree/tuften/tufts/small/0/orange"},
		.{.id = "cubyz:tree/tuften/tufts/small/0/yellow"},
		.{.id = "cubyz:tree/tuften/tufts/small/1/violet"},
		.{.id = "cubyz:tree/tuften/tufts/small/1/pink"},
		.{.id = "cubyz:tree/tuften/tufts/small/1/red"},
		.{.id = "cubyz:tree/tuften/tufts/small/1/orange"},
		.{.id = "cubyz:tree/tuften/tufts/small/1/yellow"},
		.{.id = "cubyz:tree/tuften/tufts/big/violet"},
		.{.id = "cubyz:tree/tuften/tufts/big/pink"},
		.{.id = "cubyz:tree/tuften/tufts/big/red"},
		.{.id = "cubyz:tree/tuften/tufts/big/orange"},
		.{.id = "cubyz:tree/tuften/tufts/big/yellow"},
	},
}

```

`assets/cubyz/sbb/tree/tuften/tuft_tree.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/tuften/stem/straight/5"},
		.{.id = "cubyz:tree/tuften/stem/straight/6"},
		.{.id = "cubyz:tree/tuften/stem/straight/7"},
		.{.id = "cubyz:tree/tuften/stem/straight/8", .chance = 0.5},
		.{.id = "cubyz:tree/tuften/stem/straight/9", .chance = 0.5},
		.{.id = "cubyz:tree/tuften/stem/straight/10", .chance = 0.5},
		.{.id = "cubyz:tree/tuften/stem/tilt/7"},
		.{.id = "cubyz:tree/tuften/stem/tilt/8"},
		.{.id = "cubyz:tree/tuften/stem/tilt/9"},
		.{.id = "cubyz:tree/tuften/stem/tilt/10"},
		.{.id = "cubyz:tree/tuften/stem/curvy/7"},
		.{.id = "cubyz:tree/tuften/stem/askew/8"},
		.{.id = "cubyz:tree/tuften/stem/askew/8"},
		.{.id = "cubyz:tree/tuften/stem/askew/10"},
		.{.id = "cubyz:tree/tuften/stem/curvy/7"},
		.{.id = "cubyz:tree/tuften/stem/curvy/8"},
		.{.id = "cubyz:tree/tuften/stem/curvy/10"},
	},
	.children = .{
		.pink = "cubyz:tree/tuften/tuft_canopy",
	},
}

```

`assets/cubyz/sbb/tree/tuften/young_tuft_canopy.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/tuften/young/tufts/small/violet"},
		.{.id = "cubyz:tree/tuften/young/tufts/small/pink"},
		.{.id = "cubyz:tree/tuften/young/tufts/small/red"},
		.{.id = "cubyz:tree/tuften/young/tufts/small/orange"},
		.{.id = "cubyz:tree/tuften/young/tufts/small/yellow"},
		.{.id = "cubyz:tree/tuften/young/tufts/big/violet"},
		.{.id = "cubyz:tree/tuften/young/tufts/big/pink"},
		.{.id = "cubyz:tree/tuften/young/tufts/big/red"},
		.{.id = "cubyz:tree/tuften/young/tufts/big/orange"},
		.{.id = "cubyz:tree/tuften/young/tufts/big/yellow"},
	},
}

```

`assets/cubyz/sbb/tree/tuften/young_tuft_tree.zig.zon`:

```zon
.{
	.blueprints = .{
		.{.id = "cubyz:tree/tuften/young/stem/straight/4"},
		.{.id = "cubyz:tree/tuften/young/stem/straight/5"},
		.{.id = "cubyz:tree/tuften/young/stem/straight/6"},
		.{.id = "cubyz:tree/tuften/young/stem/straight/7"},
		.{.id = "cubyz:tree/tuften/young/stem/tilt/5"},
		.{.id = "cubyz:tree/tuften/young/stem/tilt/6"},
		.{.id = "cubyz:tree/tuften/young/stem/curvy/6"},
		.{.id = "cubyz:tree/tuften/young/stem/curvy/7"},
	},
	.children = .{
		.pink = "cubyz:tree/tuften/young_tuft_canopy",
	},
}

```

`assets/cubyz/shaders/animation_pre_processing.comp`:

```comp
#version 460

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct AnimationData {
	uint startFrame;
	uint frames;
	uint time;
};

layout(std430, binding = 0) buffer _animation
{
	AnimationData animation[];
};
layout(std430, binding = 1) buffer _animatedTexture
{
	float animatedTexture[];
};

layout(location = 0) uniform uint time;
layout(location = 1) uniform uint size;

void main() {
	uint textureIndex = gl_GlobalInvocationID.x;
	if(textureIndex >= size) return;
	animatedTexture[textureIndex] = animation[textureIndex].startFrame + time / animation[textureIndex].time % animation[textureIndex].frames;
}

```

`assets/cubyz/shaders/background/fragment.frag`:

```frag
#version 460

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec2 outTexCoords;

layout(binding = 0) uniform sampler2D image;

void main() {
	fragColor = texture(image, outTexCoords);
}

```

`assets/cubyz/shaders/background/vertex.vert`:

```vert
#version 460

layout(location = 0) in vec3 vertexPos;
layout(location = 1) in vec2 texCoords;

layout(location = 0) out vec2 outTexCoords;

layout(location = 0) uniform mat4 viewMatrix;
layout(location = 1) uniform mat4 projectionMatrix;

void main() {
	gl_Position = projectionMatrix*viewMatrix*vec4(vertexPos, 1);

	outTexCoords = texCoords*vec2(1, -1);
}

```

`assets/cubyz/shaders/block_entity/sign.frag`:

```frag
#version 460

layout(location = 0) in vec3 mvVertexPos;
layout(location = 1) in vec3 direction;
layout(location = 2) in vec3 light;
layout(location = 3) in vec2 uv;
layout(location = 4) flat in vec3 normal;

layout(location = 0) out vec4 fragColor;

layout(binding = 0) uniform sampler2D textureSampler;

layout(location = 9) uniform float contrast;

float lightVariation(vec3 normal) {
	const vec3 directionalPart = vec3(0, contrast/2, contrast);
	const float baseLighting = 1 - contrast;
	return baseLighting + dot(normal, directionalPart);
}

void main() {
	float normalVariation = lightVariation(normal);

	vec3 pixelLight = light*normalVariation;
	fragColor = texture(textureSampler, uv)*vec4(pixelLight, 1);
}

```

`assets/cubyz/shaders/block_entity/sign.vert`:

```vert
#version 460

layout(location = 0) out vec3 mvVertexPos;
layout(location = 1) out vec3 direction;
layout(location = 2) out vec3 light;
layout(location = 3) out vec2 uv;
layout(location = 4) flat out vec3 normal;

layout(location = 0) uniform vec3 ambientLight;
layout(location = 1) uniform mat4 projectionMatrix;
layout(location = 2) uniform mat4 viewMatrix;
layout(location = 3) uniform ivec3 playerPositionInteger;
layout(location = 4) uniform vec3 playerPositionFraction;
layout(location = 5) uniform int quadIndex;
layout(location = 6) uniform uvec4 lightData;
layout(location = 7) uniform ivec3 chunkPos;
layout(location = 8) uniform ivec3 blockPos;

struct QuadInfo {
	vec3 normal;
	float corners[4][3];
	vec2 cornerUV[4];
	uint textureSlot;
	int opaqueInLod;
};

layout(std430, binding = 4) buffer _quads
{
	QuadInfo quads[];
};

void main() {
	int faceID = gl_VertexID >> 2;
	int vertexID = gl_VertexID & 3;
	uint fullLight = lightData[vertexID];
	vec3 sunLight = vec3(
		fullLight >> 25 & 31u,
		fullLight >> 20 & 31u,
		fullLight >> 15 & 31u
	);
	vec3 blockLight = vec3(
		fullLight >> 10 & 31u,
		fullLight >> 5 & 31u,
		fullLight >> 0 & 31u
	);
	light = max(sunLight*ambientLight, blockLight)/31;

	vec3 position = vec3(blockPos);

	normal = quads[quadIndex].normal;

	position += vec3(quads[quadIndex].corners[vertexID][0], quads[quadIndex].corners[vertexID][1], quads[quadIndex].corners[vertexID][2]);
	position += vec3(chunkPos - playerPositionInteger);
	position -= playerPositionFraction;

	direction = position;

	vec4 mvPos = viewMatrix*vec4(position, 1);
	gl_Position = projectionMatrix*mvPos;
	mvVertexPos = mvPos.xyz;
	vec2 maxUv = quads[quadIndex].cornerUV[0];
	vec2 minUv = quads[quadIndex].cornerUV[0];
	for(int i = 1; i < 4; i++) {
		maxUv = max(maxUv, quads[quadIndex].cornerUV[i]);
		minUv = min(minUv, quads[quadIndex].cornerUV[i]);
	}
	uv.x = (quads[quadIndex].cornerUV[vertexID].x == maxUv.x) ? 1 : 0;
	uv.y = (quads[quadIndex].cornerUV[vertexID].y == maxUv.y) ? 1 : 0;
}

```

`assets/cubyz/shaders/block_selection_fragment.frag`:

```frag
#version 460

layout(location = 0) in vec3 mvVertexPos;

layout(location = 0) out vec4 fragColor;

void main() {
	fragColor = vec4(0, 0, 0, 1);
}

```

`assets/cubyz/shaders/block_selection_vertex.vert`:

```vert
#version 460

layout(location = 0) out vec3 mvVertexPos;

layout(location = 0) uniform mat4 projectionMatrix;
layout(location = 1) uniform mat4 viewMatrix;
layout(location = 2) uniform vec3 modelPosition;
layout(location = 3) uniform vec3 lowerBounds;
layout(location = 4) uniform vec3 upperBounds;
layout(location = 5) uniform float lineSize;

vec3 offsetVertices[] = vec3[] (
	vec3(-1, -1, -1),
	vec3(-1, -1, 1),
	vec3(-1, 1, -1),
	vec3(-1, 1, 1),
	vec3(1, -1, -1),
	vec3(1, -1, 1),
	vec3(1, 1, -1),
	vec3(1, 1, 1),

	vec3(-1, -1, -1),
	vec3(-1, -1, 1),
	vec3(1, -1, -1),
	vec3(1, -1, 1),
	vec3(-1, 1, -1),
	vec3(-1, 1, 1),
	vec3(1, 1, -1),
	vec3(1, 1, 1),

	vec3(-1, -1, -1),
	vec3(-1, 1, -1),
	vec3(1, -1, -1),
	vec3(1, 1, -1),
	vec3(-1, -1, 1),
	vec3(-1, 1, 1),
	vec3(1, -1, 1),
	vec3(1, 1, 1)
);

vec3 lineVertices[] = vec3[] (
	vec3(0, 0, 0),
	vec3(0, 0, 1),
	vec3(0, 1, 0),
	vec3(0, 1, 1),
	vec3(1, 0, 0),
	vec3(1, 0, 1),
	vec3(1, 1, 0),
	vec3(1, 1, 1),

	vec3(0, 0, 0),
	vec3(0, 1, 0),
	vec3(0, 0, 1),
	vec3(0, 1, 1),
	vec3(1, 0, 0),
	vec3(1, 1, 0),
	vec3(1, 0, 1),
	vec3(1, 1, 1),

	vec3(0, 0, 0),
	vec3(1, 0, 0),
	vec3(0, 0, 1),
	vec3(1, 0, 1),
	vec3(0, 1, 0),
	vec3(1, 1, 0),
	vec3(0, 1, 1),
	vec3(1, 1, 1)
);

void main() {
	int vertexIndex = gl_VertexID%24;
	int lineIndex = gl_VertexID/24;
	vec3 lineStart = lineVertices[lineIndex*2];
	vec3 lineEnd = lineVertices[lineIndex*2 + 1];
	vec3 lineCenter = (lineStart + lineEnd)/2*(upperBounds - lowerBounds);

	vec3 offsetVector = vec3(lineSize);
	offsetVector += vec3(notEqual(lineStart, lineEnd))*(upperBounds - lowerBounds)/2;

	vec3 vertexPos = lineCenter + offsetVertices[vertexIndex]*offsetVector;
	vec4 mvPos = viewMatrix*vec4(lowerBounds + vertexPos + modelPosition, 1);
	gl_Position = projectionMatrix*mvPos;
	mvVertexPos = mvPos.xyz;
}

```

`assets/cubyz/shaders/bloom/color_extractor_downsample.frag`:

```frag
#version 460

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec2 texCoords;
layout(location = 1) in vec2 normalizedTexCoords;
layout(location = 2) in vec3 direction;

layout(binding = 3) uniform sampler2D color;
layout(binding = 4) uniform sampler2D depthTexture;

layout(location = 1) uniform vec2 tanXY;
layout(location = 2) uniform float zNear;
layout(location = 3) uniform float zFar;

layout(location = 4) uniform ivec3 playerPositionInteger;
layout(location = 5) uniform vec3 playerPositionFraction;

struct Fog {
	vec3 color;
	float density;
	float fogLower;
	float fogHigher;
};

layout(location = 6) uniform Fog fog;

float zFromDepth(float depthBufferValue) {
	return zNear*zFar/(depthBufferValue*(zNear - zFar) + zFar);
}

float densityIntegral(float dist, float zStart, float zDist, float fogLower, float fogHigher) {
	// The density is constant until fogLower, then gets smaller linearly until reaching fogHigher, past which there is no fog.
	if(zDist < 0) {
		zStart += zDist;
		zDist = -zDist;
	}
	if(abs(zDist) < 0.001) {
		zDist = 0.001;
	}
	float beginLower = min(fogLower, zStart);
	float endLower = min(fogLower, zStart + zDist);
	float beginMid = max(fogLower, min(fogHigher, zStart));
	float endMid = max(fogLower, min(fogHigher, zStart + zDist));
	float midIntegral = -0.5*(endMid - fogHigher)*(endMid - fogHigher)/(fogHigher - fogLower) - -0.5*(beginMid - fogHigher)*(beginMid - fogHigher)/(fogHigher - fogLower);
	if(fogHigher == fogLower) midIntegral = 0;

	return (endLower - beginLower + midIntegral)/zDist*dist;
}

float calculateFogDistance(float dist, float densityAdjustment, float zStart, float zScale, float fogDensity, float fogLower, float fogHigher) {
	float distCameraTerrain = densityIntegral(dist*densityAdjustment, zStart, zScale*dist*densityAdjustment, fogLower, fogHigher)*fogDensity;
	float distFromCamera = 0;
	float distFromTerrain = distFromCamera - distCameraTerrain;
	if(distCameraTerrain < 10) { // Resolution range is sufficient.
		return distFromTerrain;
	} else {
		// Here we have a few options to deal with this. We could for example weaken the fog effect to fit the entire range.
		// I decided to keep the fog strength close to the camera and far away, with a fog-free region in between.
		// I decided to this because I want far away fog to work (e.g. a distant ocean) as well as close fog(e.g. the top surface of the water when the player is under it)
		if(distFromTerrain > -5 && dist != 0) {
			return distFromTerrain;
		} else if(distFromCamera < 5) {
			return distFromCamera - 10;
		} else {
			return -5;
		}
	}
}

vec3 applyFrontfaceFog(float fogDistance, vec3 fogColor, vec3 inColor) {
	float fogFactor = exp(fogDistance);
	inColor *= fogFactor;
	inColor += fogColor;
	inColor -= fogColor*fogFactor;
	return inColor;
}

vec3 fetch(ivec2 pos) {
	vec4 rgba = texelFetch(color, pos, 0);
	float densityAdjustment = sqrt(dot(tanXY*(normalizedTexCoords*2 - 1), tanXY*(normalizedTexCoords*2 - 1)) + 1);
	float dist = zFromDepth(texelFetch(depthTexture, pos, 0).r);
	float fogDistance = calculateFogDistance(dist, densityAdjustment, playerPositionFraction.z, normalize(direction).z, fog.density, fog.fogLower - playerPositionInteger.z, fog.fogHigher - playerPositionInteger.z);
	vec3 fogColor = fog.color;
	rgba.rgb = applyFrontfaceFog(fogDistance, fog.color, rgba.rgb);
	return rgba.rgb/rgba.a;
}

vec3 linearSample(ivec2 start) {
	vec3 outColor = vec3(0);
	outColor += fetch(start);
	outColor += fetch(start + ivec2(0, 2));
	outColor += fetch(start + ivec2(2, 0));
	outColor += fetch(start + ivec2(2, 2));
	return outColor*0.25;
}

void main() {
	vec3 bufferData = linearSample(ivec2(texCoords));
	float bloomFactor = max(max(bufferData.x, max(bufferData.y, bufferData.z)) - 1.0, 0);
	fragColor = vec4(bufferData*bloomFactor, 1);
}

```

`assets/cubyz/shaders/bloom/color_extractor_downsample.vert`:

```vert
#version 460

layout(location = 0) in vec2 inTexCoords;

layout(location = 0) out vec2 texCoords;
layout(location = 1) out vec2 normalizedTexCoords;
layout(location = 2) out vec3 direction;

layout(binding = 3) uniform sampler2D color;

layout(location = 0) uniform mat4 invViewMatrix;
layout(location = 1) uniform vec2 tanXY;

void main() {
	vec2 position = inTexCoords*2 - vec2(1, 1);
	direction = (invViewMatrix * vec4(position.x*tanXY.x, 1, position.y*tanXY.y, 0)).xyz;
	normalizedTexCoords = inTexCoords;
	texCoords = inTexCoords*textureSize(color, 0) - 0.25;
	gl_Position = vec4(position, 0, 1);
}

```

`assets/cubyz/shaders/bloom/first_pass.frag`:

```frag
#version 460

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec2 texCoords;

layout(binding = 3) uniform sampler2D color;

float weights[8] = float[] (2.275305315223722e-01, 2.164337365563677e-01, 1.862862434215453e-01, 1.450798722521298e-01, 1.0223605803398833e-01, 6.518858871330833e-02, 3.7610543897114775e-02, 1.963442560317357e-02);
/* Weight generator:
const std = @import("std");

pub fn main() void {
	const len = 8;
	const sigma = 20;
	var vals: [len]f128 = undefined;
	var sum: f128 = 0;
	for(0..len) |i| {
		vals[i] = @exp(-@as(f128, @floatFromInt(i))*@as(f128, @floatFromInt(i))/sigma);
		sum += vals[i];
	}
	for(0..len) |i| {
		vals[i] /= sum;
		std.debug.print("{}, ", .{vals[i]});
	}
}
*/


void main() {
	vec2 tex_offset = 1.0/textureSize(color, 0);
	vec3 result = texture(color, texCoords).rgb * weights[0];
	for(int i = 1; i < 8; i++) {
		result += texture(color, texCoords + vec2(tex_offset.x * i, 0.0)).rgb * weights[i];
		result += texture(color, texCoords - vec2(tex_offset.x * i, 0.0)).rgb * weights[i];
	}
	fragColor = vec4(result, 1);
}

```

`assets/cubyz/shaders/bloom/first_pass.vert`:

```vert
#version 460

layout(location = 0) in vec2 inTexCoords;

layout(location = 0) out vec2 texCoords;

void main() {
	texCoords = inTexCoords;
	gl_Position = vec4(inTexCoords*2 - vec2(1, 1), 0, 1);
}

```

`assets/cubyz/shaders/bloom/second_pass.frag`:

```frag
#version 460

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec2 texCoords;

layout(binding = 3) uniform sampler2D color;

float weights[8] = float[] (2.275305315223722e-01, 2.164337365563677e-01, 1.862862434215453e-01, 1.450798722521298e-01, 1.0223605803398833e-01, 6.518858871330833e-02, 3.7610543897114775e-02, 1.963442560317357e-02);

void main() {
	vec2 tex_offset = 1.0/textureSize(color, 0);
	vec3 result = texture(color, texCoords).rgb * weights[0];
	for(int i = 1; i < 8; i++) {
		result += texture(color, texCoords + vec2(0, tex_offset.y * i)).rgb * weights[i];
		result += texture(color, texCoords - vec2(0, tex_offset.y * i)).rgb * weights[i];
	}
	fragColor = vec4(result, 1);
}

```

`assets/cubyz/shaders/bloom/second_pass.vert`:

```vert
#version 460

layout(location = 0) in vec2 inTexCoords;

layout(location = 0) out vec2 texCoords;

void main() {
	texCoords = inTexCoords;
	gl_Position = vec4(inTexCoords*2 - vec2(1, 1), 0, 1);
}

```

`assets/cubyz/shaders/chunks/chunk_fragment.frag`:

```frag
#version 460

layout(location = 0) in vec3 mvVertexPos;
layout(location = 1) in vec3 direction;
layout(location = 2) in vec3 light;
layout(location = 3) in vec2 uv;
layout(location = 4) flat in vec3 normal;
layout(location = 5) flat in int textureIndex;
layout(location = 6) flat in int isBackFace;
layout(location = 7) flat in float distanceForLodCheck;
layout(location = 8) flat in int opaqueInLod;

layout(location = 0) out vec4 fragColor;

layout(binding = 0) uniform sampler2DArray textureSampler;
layout(binding = 1) uniform sampler2DArray emissionSampler;
layout(binding = 2) uniform sampler2DArray reflectivityAndAbsorptionSampler;
layout(binding = 4) uniform samplerCube reflectionMap;
layout(binding = 5) uniform sampler2D ditherTexture;

layout(location = 5) uniform float reflectionMapSize;
layout(location = 6) uniform float contrast;
layout(location = 7) uniform float lodDistance;

layout(std430, binding = 1) buffer _animatedTexture
{
	float animatedTexture[];
};

float lightVariation(vec3 normal) {
	const vec3 directionalPart = vec3(0, contrast/2, contrast);
	const float baseLighting = 1 - contrast;
	return baseLighting + dot(normal, directionalPart);
}

bool passDitherTest(float alpha) {
	if(opaqueInLod != 0) {
		if(distanceForLodCheck > lodDistance) return true;
		float factor = max(0, distanceForLodCheck - (lodDistance - 32.0))/32.0;
		alpha = alpha*(1 - factor) + factor;
	}
	return alpha > texture(ditherTexture, uv).r*255.0/256.0 + 0.5/256.0;
}

vec4 fixedCubeMapLookup(vec3 v) { // Taken from http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
	float M = max(max(abs(v.x), abs(v.y)), abs(v.z));
	float scale = (reflectionMapSize - 1)/reflectionMapSize;
	if (abs(v.x) != M) v.x *= scale;
	if (abs(v.y) != M) v.y *= scale;
	if (abs(v.z) != M) v.z *= scale;
	return texture(reflectionMap, v);
}

void main() {
	float animatedTextureIndex = animatedTexture[textureIndex];
	float normalVariation = lightVariation(normal);
	vec3 textureCoords = vec3(uv, animatedTextureIndex);

	float reflectivity = texture(reflectivityAndAbsorptionSampler, textureCoords).a;
	float fresnelReflection = (1 + dot(normalize(direction), normal));
	fresnelReflection *= fresnelReflection;
	fresnelReflection *= min(1, 2*reflectivity); // Limit it to 2*reflectivity to avoid making every block reflective.
	reflectivity = reflectivity*fixedCubeMapLookup(reflect(direction, normal)).x;
	reflectivity = reflectivity*(1 - fresnelReflection) + fresnelReflection;

	vec3 pixelLight = max(light*normalVariation, texture(emissionSampler, textureCoords).r*4);
	fragColor = texture(textureSampler, textureCoords)*vec4(pixelLight, 1);
	fragColor.rgb += reflectivity*pixelLight;

	if(!passDitherTest(fragColor.a)) discard;
	fragColor.a = 1;
}

```

`assets/cubyz/shaders/chunks/chunk_vertex.vert`:

```vert
#version 460

layout(location = 0) out vec3 mvVertexPos;
layout(location = 1) out vec3 direction;
layout(location = 2) out vec3 light;
layout(location = 3) out vec2 uv;
layout(location = 4) flat out vec3 normal;
layout(location = 5) flat out int textureIndex;
layout(location = 6) flat out int isBackFace;
layout(location = 7) flat out float distanceForLodCheck;
layout(location = 8) flat out int opaqueInLod;

layout(location = 0) uniform vec3 ambientLight;
layout(location = 1) uniform mat4 projectionMatrix;
layout(location = 2) uniform mat4 viewMatrix;
layout(location = 3) uniform ivec3 playerPositionInteger;
layout(location = 4) uniform vec3 playerPositionFraction;

struct FaceData {
	int encodedPositionAndLightIndex;
	int textureAndQuad;
};
layout(std430, binding = 3) buffer _faceData
{
	FaceData faceData[];
};

struct QuadInfo {
	vec3 normal;
	float corners[4][3];
	vec2 cornerUV[4];
	uint textureSlot;
	int opaqueInLod;
};

layout(std430, binding = 4) buffer _quads
{
	QuadInfo quads[];
};

layout(std430, binding = 10) buffer _lightData
{
	uint lightData[];
};

struct ChunkData {
	ivec4 position;
	vec4 minPos;
	vec4 maxPos;
	int voxelSize;
	uint lightStart;
	uint vertexStartOpaque;
	uint faceCountsByNormalOpaque[14];
	uint vertexStartTransparent;
	uint vertexCountTransparent;
	uint visibilityState;
	uint oldVisibilityState;
};

layout(std430, binding = 6) buffer _chunks
{
	ChunkData chunks[];
};

vec3 square(vec3 x) {
	return x*x;
}

void main() {
	int faceID = gl_VertexID >> 2;
	int vertexID = gl_VertexID & 3;
	int chunkID = gl_BaseInstance;
	int voxelSize = chunks[chunkID].voxelSize;
	int encodedPositionAndLightIndex = faceData[faceID].encodedPositionAndLightIndex;
	int textureAndQuad = faceData[faceID].textureAndQuad;
	uint lightIndex = chunks[chunkID].lightStart + 4*(encodedPositionAndLightIndex >> 16);
	uint fullLight = lightData[lightIndex + vertexID];
	vec3 sunLight = vec3(
		fullLight >> 25 & 31u,
		fullLight >> 20 & 31u,
		fullLight >> 15 & 31u
	);
	vec3 blockLight = vec3(
		fullLight >> 10 & 31u,
		fullLight >> 5 & 31u,
		fullLight >> 0 & 31u
	);
	light = min(sqrt(square(sunLight*ambientLight) + square(blockLight)), vec3(31))/31;
	isBackFace = encodedPositionAndLightIndex>>15 & 1;

	textureIndex = textureAndQuad & 65535;
	int quadIndex = textureAndQuad >> 16;

	vec3 position = vec3(
		encodedPositionAndLightIndex & 31,
		encodedPositionAndLightIndex >> 5 & 31,
		encodedPositionAndLightIndex >> 10 & 31
	);

	normal = quads[quadIndex].normal;

	position += vec3(quads[quadIndex].corners[vertexID][0], quads[quadIndex].corners[vertexID][1], quads[quadIndex].corners[vertexID][2]);
	position *= voxelSize;
	position += vec3(chunks[chunkID].position.xyz - playerPositionInteger);
	position -= playerPositionFraction;

	direction = position;

	vec4 mvPos = viewMatrix*vec4(position, 1);
	gl_Position = projectionMatrix*mvPos;
	mvVertexPos = mvPos.xyz;
	distanceForLodCheck = length(mvPos.xyz) + voxelSize;
	uv = quads[quadIndex].cornerUV[vertexID]*voxelSize;
	opaqueInLod = quads[quadIndex].opaqueInLod;
}

```

`assets/cubyz/shaders/chunks/fillIndirectBuffer.comp`:

```comp
#version 460

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct AnimationData {
	uint frames;
	uint time;
};

struct ChunkData {
	ivec4 position;
	vec4 minPos;
	vec4 maxPos;
	int voxelSize;
	uint lightStart;
	uint vertexStartOpaque;
	uint faceCountsByNormalOpaque[14];
	uint vertexStartTransparent;
	uint vertexCountTransparent;
	uint visibilityState;
	uint oldVisibilityState;
};
layout(std430, binding = 6) buffer _chunks
{
	ChunkData chunks[];
};
struct DrawElementsIndirectCommand {
	uint  count;
	uint  instanceCount;
	uint  firstIndex;
	int  baseVertex;
	uint  baseInstance;
};
layout(std430, binding = 8) buffer _commands
{
	DrawElementsIndirectCommand commands[];
};
layout(std430, binding = 9) buffer _chunkIDs
{
	uint chunkIDs[];
};

layout(location = 0) uniform uint chunkIDIndex;
layout(location = 1) uniform uint commandIndexStart;
layout(location = 2) uniform uint size;
layout(location = 3) uniform bool isTransparent;
layout(location = 4) uniform bool onlyDrawPreviouslyInvisible;
layout(location = 5) uniform ivec3 playerPositionInteger;

layout(location = 6) uniform float lodDistance;

bool isVisible(int dir, ivec3 playerDist) {
	switch(dir) {
	case 0: // dirUp
		return playerDist.z >= 0;
	case 1: // dirDown
		return playerDist.z <= 0;
	case 2: // dirPosX
		return playerDist.x >= 0;
	case 3: // dirNegX
		return playerDist.x <= 0;
	case 4: // dirPosY
		return playerDist.y >= 0;
	case 5: // dirNegY
		return playerDist.y <= 0;
	}
	return true;
}

DrawElementsIndirectCommand addCommand(uint indices, uint vertexOffset, uint chunkID) {
	return DrawElementsIndirectCommand(indices, 1, 0, int(vertexOffset), chunkID);
}

void main() {
	uint chunkID = chunkIDs[chunkIDIndex + gl_GlobalInvocationID.x];
	if(gl_GlobalInvocationID.x >= size) return;
	if(isTransparent) {
		uint commandIndex = commandIndexStart + gl_GlobalInvocationID.x;
		if(chunks[chunkID].visibilityState != 0) {
			commands[commandIndex] = addCommand(chunks[chunkID].vertexCountTransparent, chunks[chunkID].vertexStartTransparent, chunkID);
		} else {
			commands[commandIndex] = DrawElementsIndirectCommand(0, 0, 0, 0, 0);
		}
		chunks[chunkID].visibilityState = 0;
	} else {
		uint commandIndex = commandIndexStart + gl_GlobalInvocationID.x*8;
		uint commandIndexEnd = commandIndex + 8;
		uint groupFaceOffset = 0;
		uint groupFaceCount = 0;
		uint oldoldvisibilityState = chunks[chunkID].oldVisibilityState;
		ivec3 playerDist = playerPositionInteger - chunks[chunkID].position.xyz;
		if(playerDist.x > 0) playerDist.x = max(0, playerDist.x - 32*chunks[chunkID].voxelSize);
		if(playerDist.y > 0) playerDist.y = max(0, playerDist.y - 32*chunks[chunkID].voxelSize);
		if(playerDist.z > 0) playerDist.z = max(0, playerDist.z - 32*chunks[chunkID].voxelSize);
		float playerDistSquare = dot(playerDist, playerDist);

		if((onlyDrawPreviouslyInvisible && chunks[chunkID].oldVisibilityState == 0 && chunks[chunkID].visibilityState != 0) || (chunks[chunkID].oldVisibilityState != 0 && !onlyDrawPreviouslyInvisible)) {
			for(int i = 0; i < 14; i++) {
				if(playerDistSquare >= lodDistance*lodDistance && i == 7) break;
				uint faceCount = chunks[chunkID].faceCountsByNormalOpaque[i];
				if(isVisible(i%7, playerDist) || faceCount == 0) {
					groupFaceCount += faceCount;
				} else {
					if(groupFaceCount != 0) {
						commands[commandIndex] = addCommand(6*groupFaceCount, chunks[chunkID].vertexStartOpaque + 4*groupFaceOffset, chunkID);
						commandIndex += 1;
						groupFaceOffset += groupFaceCount;
						groupFaceCount = 0;
					}
					groupFaceOffset += faceCount;
				}
			}
		}
		if(onlyDrawPreviouslyInvisible) {
			chunks[chunkID].oldVisibilityState = chunks[chunkID].visibilityState;
			chunks[chunkID].visibilityState = 0;
		}
		if(groupFaceCount != 0) {
			commands[commandIndex] = addCommand(6*groupFaceCount, chunks[chunkID].vertexStartOpaque + 4*groupFaceOffset, chunkID);
			commandIndex += 1;
		}

		for(; commandIndex < commandIndexEnd; commandIndex++) {
			commands[commandIndex] = DrawElementsIndirectCommand(0, 0, 0, 0, oldoldvisibilityState << 1 | chunks[chunkID].oldVisibilityState);
		}
	}
}

```

`assets/cubyz/shaders/chunks/occlusionTestFragment.frag`:

```frag
#version 460

layout(early_fragment_tests) in;

layout(location = 0) flat in uint chunkID;

struct ChunkData {
	ivec4 position;
	vec4 minPos;
	vec4 maxPos;
	int voxelSize;
	uint lightStart;
	uint vertexStartOpaque;
	uint faceCountsByNormalOpaque[14];
	uint vertexStartTransparent;
	uint vertexCountTransparent;
	uint visibilityState;
	uint oldVisibilityState;
};

layout(std430, binding = 6) buffer _chunks
{
	ChunkData chunks[];
};

void main() {
	chunks[chunkID].visibilityState = 1;
}

```

`assets/cubyz/shaders/chunks/occlusionTestVertex.vert`:

```vert
#version 460

layout(location = 0) flat out uint chunkID;

struct ChunkData {
	ivec4 position;
	vec4 minPos;
	vec4 maxPos;
	int voxelSize;
	uint lightStart;
	uint vertexStartOpaque;
	uint faceCountsByNormalOpaque[14];
	uint vertexStartTransparent;
	uint vertexCountTransparent;
	uint visibilityState;
	uint oldVisibilityState;
};

layout(std430, binding = 6) buffer _chunks
{
	ChunkData chunks[];
};
layout(std430, binding = 9) buffer _chunkIDs
{
	uint chunkIDs[];
};

vec3 vertexBuffer[24] = vec3[24](
	vec3(0, 1, 0),
	vec3(0, 1, 1),
	vec3(0, 0, 0),
	vec3(0, 0, 1),

	vec3(1, 0, 0),
	vec3(1, 0, 1),
	vec3(1, 1, 0),
	vec3(1, 1, 1),

	vec3(0, 0, 0),
	vec3(0, 0, 1),
	vec3(1, 0, 0),
	vec3(1, 0, 1),

	vec3(1, 1, 0),
	vec3(1, 1, 1),
	vec3(0, 1, 0),
	vec3(0, 1, 1),

	vec3(0, 1, 0),
	vec3(0, 0, 0),
	vec3(1, 1, 0),
	vec3(1, 0, 0),

	vec3(1, 1, 1),
	vec3(1, 0, 1),
	vec3(0, 1, 1),
	vec3(0, 0, 1)
);

layout(location = 0) uniform mat4 projectionMatrix;
layout(location = 1) uniform mat4 viewMatrix;
layout(location = 2) uniform ivec3 playerPositionInteger;
layout(location = 3) uniform vec3 playerPositionFraction;

void main() {
	uint chunkIDID = uint(gl_VertexID)/24u;
	uint vertexID = uint(gl_VertexID)%24u;
	chunkID = chunkIDs[chunkIDID];
	vec3 modelPosition = vec3(chunks[chunkID].position.xyz - playerPositionInteger) - playerPositionFraction;
	if(all(lessThan(modelPosition + chunks[chunkID].minPos.xyz*chunks[chunkID].voxelSize, vec3(0, 0, 0))) && all(greaterThan(modelPosition + chunks[chunkID].maxPos.xyz*chunks[chunkID].voxelSize, vec3(0, 0, 0)))) {
		chunks[chunkID].visibilityState = 1;
		gl_Position = vec4(-2, -2, -2, 1);
		return;
	}
	vec3 vertexPosition = modelPosition + (vertexBuffer[vertexID]*chunks[chunkID].maxPos.xyz + (1 - vertexBuffer[vertexID])*chunks[chunkID].minPos.xyz)*chunks[chunkID].voxelSize;
	gl_Position = projectionMatrix*viewMatrix*vec4(vertexPosition, 1);
}

```

`assets/cubyz/shaders/chunks/transparent_fragment.frag`:

```frag
#version 460

layout(location = 0) in vec3 mvVertexPos;
layout(location = 1) in vec3 direction;
layout(location = 2) in vec3 light;
layout(location = 3) in vec2 uv;
layout(location = 4) flat in vec3 normal;
layout(location = 5) flat in int textureIndex;
layout(location = 6) flat in int isBackFace;
layout(location = 7) flat in float distanceForLodCheck;
layout(location = 8) flat in int opaqueInLod;

layout(location = 0, index = 0) out vec4 fragColor;
layout(location = 0, index = 1) out vec4 blendColor;

layout(binding = 0) uniform sampler2DArray textureSampler;
layout(binding = 1) uniform sampler2DArray emissionSampler;
layout(binding = 2) uniform sampler2DArray reflectivityAndAbsorptionSampler;
layout(binding = 4) uniform samplerCube reflectionMap;
layout(binding = 5) uniform sampler2D depthTexture;

layout(location = 3) uniform ivec3 playerPositionInteger;
layout(location = 4) uniform vec3 playerPositionFraction;

layout(location = 5) uniform float reflectionMapSize;
layout(location = 6) uniform float contrast;

layout(location = 8) uniform float zNear;
layout(location = 9) uniform float zFar;

struct Fog {
	vec3 color;
	float density;
	float fogLower;
	float fogHigher;
};

layout(location = 10) uniform Fog fog;

layout(std430, binding = 1) buffer _animatedTexture
{
	float animatedTexture[];
};

struct FogData {
	float fogDensity;
	uint fogColor;
};

layout(std430, binding = 7) buffer _fogData
{
	FogData fogData[];
};

float lightVariation(vec3 normal) {
	const vec3 directionalPart = vec3(0, contrast/2, contrast);
	const float baseLighting = 1 - contrast;
	return baseLighting + dot(normal, directionalPart);
}

vec3 unpackColor(uint color) {
	return vec3(
		color>>16 & 255u,
		color>>8 & 255u,
		color & 255u
	)/255.0;
}

float zFromDepth(float depthBufferValue) {
	return zNear*zFar/(depthBufferValue*(zNear - zFar) + zFar);
}

float densityIntegral(float dist, float zStart, float zDist, float fogLower, float fogHigher) {
	// The density is constant until fogLower, then gets smaller linearly until reaching fogHigher, past which there is no fog.
	if(zDist < 0) {
		zStart += zDist;
		zDist = -zDist;
	}
	if(abs(zDist) < 0.001) {
		zDist = 0.001;
	}
	float beginLower = min(fogLower, zStart);
	float endLower = min(fogLower, zStart + zDist);
	float beginMid = max(fogLower, min(fogHigher, zStart));
	float endMid = max(fogLower, min(fogHigher, zStart + zDist));
	float midIntegral = -0.5*(endMid - fogHigher)*(endMid - fogHigher)/(fogHigher - fogLower) - -0.5*(beginMid - fogHigher)*(beginMid - fogHigher)/(fogHigher - fogLower);
	if(fogHigher == fogLower) midIntegral = 0;

	return (endLower - beginLower + midIntegral)/zDist*dist;
}

float calculateFogDistance(float dist, float densityAdjustment, float zStart, float zScale, float fogDensity, float fogLower, float fogHigher) {
	float distCameraTerrain = densityIntegral(dist*densityAdjustment, zStart, zScale*dist*densityAdjustment, fogLower, fogHigher)*fogDensity;
	float distFromCamera = abs(densityIntegral(mvVertexPos.y*densityAdjustment, zStart, zScale*mvVertexPos.y*densityAdjustment, fogLower, fogHigher))*fogDensity;
	float distFromTerrain = distFromCamera - distCameraTerrain;
	if(distCameraTerrain < 10) { // Resolution range is sufficient.
		return distFromTerrain;
	} else {
		// Here we have a few options to deal with this. We could for example weaken the fog effect to fit the entire range.
		// I decided to keep the fog strength close to the camera and far away, with a fog-free region in between.
		// I decided to this because I want far away fog to work (e.g. a distant ocean) as well as close fog(e.g. the top surface of the water when the player is under it)
		if(distFromTerrain > -5) {
			return distFromTerrain;
		} else if(distFromCamera < 5) {
			return distFromCamera - 10;
		} else {
			return -5;
		}
	}
}

void applyFrontfaceFog(float fogDistance, vec3 fogColor) {
	float fogFactor = exp(fogDistance);
	fragColor.rgb = fogColor*(1 - fogFactor);
	fragColor.a = fogFactor;
}

void applyBackfaceFog(float fogDistance, vec3 fogColor) {
	float fogFactor = exp(-fogDistance);
	fragColor.rgb = fragColor.rgb*fogFactor + fogColor*(1 - fogFactor);
	fragColor.a *= fogFactor;
}

vec4 fixedCubeMapLookup(vec3 v) { // Taken from http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
	float M = max(max(abs(v.x), abs(v.y)), abs(v.z));
	float scale = (reflectionMapSize - 1)/reflectionMapSize;
	if (abs(v.x) != M) v.x *= scale;
	if (abs(v.y) != M) v.y *= scale;
	if (abs(v.z) != M) v.z *= scale;
	return texture(reflectionMap, v);
}

void main() {
	float animatedTextureIndex = animatedTexture[textureIndex];
	vec3 textureCoords = vec3(uv, animatedTextureIndex);
	float normalVariation = lightVariation(normal);
	float densityAdjustment = sqrt(dot(mvVertexPos, mvVertexPos))/abs(mvVertexPos.y);
	float dist = zFromDepth(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).r);
	float fogDistance = calculateFogDistance(dist, densityAdjustment, playerPositionFraction.z, normalize(direction).z, fogData[int(animatedTextureIndex)].fogDensity, 1e10, 1e10);
	float airFogDistance = calculateFogDistance(dist, densityAdjustment, playerPositionFraction.z, normalize(direction).z, fog.density, fog.fogLower - playerPositionInteger.z, fog.fogHigher - playerPositionInteger.z);
	vec3 fogColor = unpackColor(fogData[int(animatedTextureIndex)].fogColor);
	vec3 pixelLight = max(light*normalVariation, texture(emissionSampler, textureCoords).r*4);
	vec4 textureColor = texture(textureSampler, textureCoords)*vec4(pixelLight, 1);

	float reflectivity = texture(reflectivityAndAbsorptionSampler, textureCoords).a;
	float fresnelReflection = (1 + dot(normalize(direction), normal));
	fresnelReflection *= fresnelReflection;
	fresnelReflection *= min(1, 2*reflectivity); // Limit it to 2*reflectivity to avoid making every block reflective.
	reflectivity = reflectivity*fixedCubeMapLookup(reflect(direction, normal)).x;
	reflectivity = reflectivity*(1 - fresnelReflection) + fresnelReflection;
	textureColor.rgb *= textureColor.a;
	textureColor.rgb += reflectivity*pixelLight;
	blendColor.rgb = vec3((1 - textureColor.a)*(1 - fresnelReflection));

	if(isBackFace == 0) {
		vec3 absorption = texture(reflectivityAndAbsorptionSampler, textureCoords).rgb;
		blendColor.rgb *= absorption;

		// Fake reflection:
		// TODO: Change this when it rains.
		// TODO: Normal mapping.
		textureColor.rgb += texture(emissionSampler, textureCoords).rgb;

		if(fogData[int(animatedTextureIndex)].fogDensity == 0.0) {
			// Apply the air fog, compensating for the potentially missing back-face:
			applyFrontfaceFog(airFogDistance, fog.color);
		} else {
			// Apply the block fog:
			applyFrontfaceFog(fogDistance, fogColor);
		}

		// Apply the texture+absorption
		fragColor.rgb *= blendColor.rgb;
		fragColor.rgb += textureColor.rgb;

		// Apply the air fog:
		applyBackfaceFog(airFogDistance, fog.color);
	} else {
		// Apply the air fog:
		applyFrontfaceFog(airFogDistance, fog.color);

		// Apply the texture:
		fragColor.rgb *= blendColor.rgb;
		fragColor.rgb += textureColor.rgb;

		// Apply the block fog:
		if(fogData[int(animatedTextureIndex)].fogDensity == 0.0) {
			// Apply the air fog, compensating for the above line where I compensated for the potentially missing back-face.
			applyBackfaceFog(airFogDistance, fog.color);
		} else {
			applyBackfaceFog(fogDistance, fogColor);
		}
	}
	blendColor.rgb *= fragColor.a;
	fragColor.a = 1;
}

```

`assets/cubyz/shaders/deferred_render_pass.frag`:

```frag
#version 460

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec2 texCoords;
layout(location = 1) flat in vec3[4] directions;

layout(binding = 3) uniform sampler2D color;

layout(binding = 4) uniform sampler2D depthTexture;

layout(binding = 5) uniform sampler2D bloomColor;

layout(location = 1) uniform vec2 tanXY;
layout(location = 2) uniform float zNear;
layout(location = 3) uniform float zFar;

layout(location = 4) uniform ivec3 playerPositionInteger;
layout(location = 5) uniform vec3 playerPositionFraction;

struct Fog {
	vec3 color;
	float density;
	float fogLower;
	float fogHigher;
};

layout(location = 6) uniform Fog fog;

float zFromDepth(float depthBufferValue) {
	return zNear*zFar/(depthBufferValue*(zNear - zFar) + zFar);
}

float densityIntegral(float dist, float zStart, float zDist, float fogLower, float fogHigher) {
	// The density is constant until fogLower, then gets smaller linearly until reaching fogHigher, past which there is no fog.
	if(zDist < 0) {
		zStart += zDist;
		zDist = -zDist;
	}
	if(abs(zDist) < 0.001) {
		zDist = 0.001;
	}
	float beginLower = min(fogLower, zStart);
	float endLower = min(fogLower, zStart + zDist);
	float beginMid = max(fogLower, min(fogHigher, zStart));
	float endMid = max(fogLower, min(fogHigher, zStart + zDist));
	float midIntegral = -0.5*(endMid - fogHigher)*(endMid - fogHigher)/(fogHigher - fogLower) - -0.5*(beginMid - fogHigher)*(beginMid - fogHigher)/(fogHigher - fogLower);
	if(fogHigher == fogLower) midIntegral = 0;

	return (endLower - beginLower + midIntegral)/zDist*dist;
}

float calculateFogDistance(float dist, float densityAdjustment, float zStart, float zScale, float fogDensity, float fogLower, float fogHigher) {
	float distCameraTerrain = densityIntegral(dist*densityAdjustment, zStart, zScale*dist*densityAdjustment, fogLower, fogHigher)*fogDensity;
	float distFromCamera = 0;
	float distFromTerrain = distFromCamera - distCameraTerrain;
	if(distCameraTerrain < 10) { // Resolution range is sufficient.
		return distFromTerrain;
	} else {
		// Here we have a few options to deal with this. We could for example weaken the fog effect to fit the entire range.
		// I decided to keep the fog strength close to the camera and far away, with a fog-free region in between.
		// I decided to this because I want far away fog to work (e.g. a distant ocean) as well as close fog(e.g. the top surface of the water when the player is under it)
		if(distFromTerrain > -5 && dist != 0) {
			return distFromTerrain;
		} else if(distFromCamera < 5) {
			return distFromCamera - 10;
		} else {
			return -5;
		}
	}
}

vec3 applyFrontfaceFog(float fogDistance, vec3 fogColor, vec3 inColor) {
	float fogFactor = exp(fogDistance);
	inColor *= fogFactor;
	inColor += fogColor;
	inColor -= fogColor*fogFactor;
	return inColor;
}

void main() {
	fragColor = texture(color, texCoords);
	fragColor += texture(bloomColor, texCoords);
	vec2 clampedTexCoords = (floor(texCoords*vec2(textureSize(color, 0))) + 0.5)/vec2(textureSize(color, 0));
	vec3 direction = clampedTexCoords.x*(
		clampedTexCoords.y*directions[0] + (1 - clampedTexCoords.y)*directions[1]
	) + (1 - clampedTexCoords.x)*(
		clampedTexCoords.y*directions[2] + (1 - clampedTexCoords.y)*directions[3]
	);
	float densityAdjustment = sqrt(dot(tanXY*(clampedTexCoords*2 - 1), tanXY*(clampedTexCoords*2 - 1)) + 1);
	float dist = zFromDepth(texture(depthTexture, texCoords).r);
	float fogDistance = calculateFogDistance(dist, densityAdjustment, playerPositionFraction.z, normalize(direction).z, fog.density, fog.fogLower - playerPositionInteger.z, fog.fogHigher - playerPositionInteger.z);
	fragColor.rgb = applyFrontfaceFog(fogDistance, fog.color, fragColor.rgb);
	float maxColor = max(1.0, max(fragColor.r, max(fragColor.g, fragColor.b)));
	fragColor.rgb = fragColor.rgb/maxColor;
}

```

`assets/cubyz/shaders/deferred_render_pass.vert`:

```vert
#version 460

layout(location = 0) in vec2 inTexCoords;

layout(location = 0) out vec2 texCoords;
layout(location = 1) flat out vec3[4] directions;

layout(location = 0) uniform mat4 invViewMatrix;
layout(location = 1) uniform vec2 tanXY;

void main() {
	directions[0] = (invViewMatrix * vec4(1*tanXY.x, 1, 1*tanXY.y, 0)).xyz;
	directions[1] = (invViewMatrix * vec4(1*tanXY.x, 1, -1*tanXY.y, 0)).xyz;
	directions[2] = (invViewMatrix * vec4(-1*tanXY.x, 1, 1*tanXY.y, 0)).xyz;
	directions[3] = (invViewMatrix * vec4(-1*tanXY.x, 1, -1*tanXY.y, 0)).xyz;
	texCoords = inTexCoords;
	vec2 position = inTexCoords*2 - vec2(1, 1);
	gl_Position = vec4(position, 0, 1);
}

```

`assets/cubyz/shaders/entity_fragment.frag`:

```frag
#version 460

layout(location = 0) in vec2 outTexCoord;
layout(location = 1) in vec3 mvVertexPos;
layout(location = 2) in vec3 outLight;
layout(location = 3) flat in vec3 normal;

layout(location = 0) out vec4 fragColor;

layout(binding = 0) uniform sampler2D textureSampler;

layout(location = 5) uniform float contrast;

float lightVariation(vec3 normal) {
	const vec3 directionalPart = vec3(0, contrast/2, contrast);
	const float baseLighting = 1 - contrast;
	return baseLighting + dot(normal, directionalPart);
}

float ditherThresholds[16] = float[16] (
	1/17.0, 9/17.0, 3/17.0, 11/17.0,
	13/17.0, 5/17.0, 15/17.0, 7/17.0,
	4/17.0, 12/17.0, 2/17.0, 10/17.0,
	16/17.0, 8/17.0, 14/17.0, 6/17.0
);

ivec2 random1to2(int v) {
	ivec4 fac = ivec4(11248723, 105436839, 45399083, 5412951);
	int seed = v.x*fac.x ^ fac.y;
	return seed*fac.zw;
}

bool passDitherTest(float alpha) {
	ivec2 screenPos = ivec2(gl_FragCoord.xy);
	screenPos += random1to2(0);
	screenPos &= 3;
	return alpha > ditherThresholds[screenPos.x*4 + screenPos.y];
}

void main() {
	fragColor = texture(textureSampler, outTexCoord)*vec4(outLight*lightVariation(normal), 1);
	if(!passDitherTest(fragColor.a)) discard;
	fragColor.a = 1;
}

```

`assets/cubyz/shaders/entity_vertex.vert`:

```vert
#version 460

layout(location = 0) out vec2 outTexCoord;
layout(location = 1) out vec3 mvVertexPos;
layout(location = 2) out vec3 outLight;
layout(location = 3) flat out vec3 normal;

layout(location = 0) uniform mat4 projectionMatrix;
layout(location = 1) uniform mat4 viewMatrix;
layout(location = 2) uniform vec3 ambientLight;
layout(location = 3) uniform uint light;

struct QuadInfo {
	vec3 normal;
	float corners[4][3];
	vec2 cornerUV[4];
	uint textureSlot;
	int opaqueInLod;
};

layout(std430, binding = 11) buffer _quads
{
	QuadInfo quads[];
};

vec3 square(vec3 x) {
	return x*x;
}

vec3 calcLight(uint fullLight) {
	vec3 sunLight = vec3(
		fullLight >> 25 & 31u,
		fullLight >> 20 & 31u,
		fullLight >> 15 & 31u
	);
	vec3 blockLight = vec3(
		fullLight >> 10 & 31u,
		fullLight >> 5 & 31u,
		fullLight >> 0 & 31u
	);
	return min(sqrt(square(sunLight*ambientLight) + square(blockLight)), vec3(31))/31;
}

void main() {
	int faceID = gl_VertexID >> 2;
	int vertexID = gl_VertexID & 3;

	normal = quads[faceID].normal;

	vec3 position = vec3(quads[faceID].corners[vertexID][0], quads[faceID].corners[vertexID][1], quads[faceID].corners[vertexID][2]);

	vec4 mvPos = viewMatrix*vec4(position, 1);
	gl_Position = projectionMatrix*mvPos;
	mvVertexPos = mvPos.xyz;
	outTexCoord = quads[faceID].cornerUV[vertexID];
	outLight = calcLight(light);
}

```

`assets/cubyz/shaders/fake_reflection.frag`:

```frag
#version 460

layout(location = 0) in vec3 coords;

layout(location = 0) out vec4 fragColor;

layout(location = 1) uniform vec3 normalVector;
layout(location = 2) uniform vec3 upVector;
layout(location = 3) uniform vec3 rightVector;
layout(location = 4) uniform float frequency;

ivec3 random3to3(ivec3 v) {
	v &= 15;
	ivec3 fac = ivec3(11248723, 105436839, 45399083);
	int seed = v.x*fac.x ^ v.y*fac.y ^ v.z*fac.z;
	v = seed*fac;
	return v;
}

float snoise(vec3 v) {
	const vec2 C = vec2(1.0/6.0, 1.0/3.0);

	// First corner
	vec3 i = floor(v + dot(v, C.yyy));
	vec3 x0 = v - i + dot(i, C.xxx);

	// Other corners
	vec3 g = step(x0.yzx, x0.xyz);
	vec3 l = 1.0 - g;
	vec3 i1 = min(g.xyz, l.zxy);
	vec3 i2 = max(g.xyz, l.zxy);

	// x0 = x0 - 0. + 0.0 * C
	vec3 x1 = x0 - i1 + 1.0*C.xxx;
	vec3 x2 = x0 - i2 + 2.0*C.xxx;
	vec3 x3 = x0 - 1. + 3.0*C.xxx;

	// Get gradients:
	ivec3 rand = random3to3(ivec3(i));
	vec3 p0 = vec3(rand);

	rand = random3to3((ivec3(i + i1)));
	vec3 p1 = vec3(rand);

	rand = random3to3((ivec3(i + i2)));
	vec3 p2 = vec3(rand);

	rand = random3to3((ivec3(i + 1)));
	vec3 p3 = vec3(rand);

	// Mix final noise value
	vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
	m = m*m;
	return 42.0*dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)))/(1 << 31);
}

void main() {
	vec3 position = normalize(coords);
	position = position.x*rightVector + position.y*upVector + position.z*normalVector;
	position *= frequency;
	fragColor = vec4(vec3(snoise(position)*0.5 + 0.5), 1);
}

```

`assets/cubyz/shaders/fake_reflection.vert`:

```vert
#version 460

layout(location = 0) in vec2 inTexCoords;

layout(location = 0) out vec3 coords;

layout(location = 0) uniform float reflectionMapSize;

void main() {
	coords = vec3((inTexCoords*2 - vec2(1, 1))*(reflectionMapSize + 1)/reflectionMapSize, 1);
	gl_Position = vec4(inTexCoords*2 - vec2(1, 1), 0, 1);
}

```

`assets/cubyz/shaders/graphics/Circle.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) in vec2 unitPosition;
layout(location = 1) flat in vec4 color;

// Like smooth step, but with linear interpolation instead of s-curve.
float linearstep(float edge0, float edge1, float x) {
	return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
}

void main(){
	float distSqr = sqrt(dot(unitPosition, unitPosition));
	float delta = fwidth(distSqr)/2;
	float alpha = linearstep(1+delta, 1-delta, distSqr);
	frag_color = color;
	frag_color.a *= alpha;
}

```

`assets/cubyz/shaders/graphics/Circle.vert`:

```vert
#version 460

layout(location = 0) in vec2 vertex_pos;

layout(location = 0) out vec2 unitPosition;
layout(location = 1) flat out vec4 color;

// in pixel
layout(location = 0) uniform vec2 center;
layout(location = 1) uniform float radius;
layout(location = 2) uniform vec2 screen;

layout(location = 3) uniform int circleColor;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (center + vertex_pos*radius)/screen;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	color = vec4((circleColor & 0xff0000)>>16, (circleColor & 0xff00)>>8, circleColor & 0xff, (circleColor>>24) & 255)/255.0;

	unitPosition = vertex_pos;
}

```

`assets/cubyz/shaders/graphics/Image.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;
layout(binding = 0) uniform sampler2D image;

layout(location = 0) in vec2 uv;
layout(location = 1) flat in vec4 fColor;

void main() {
	frag_color = texture(image, uv)*fColor;
	if(frag_color.a == 0) {
		discard;
	}
}

```

`assets/cubyz/shaders/graphics/Image.vert`:

```vert
#version 460

layout(location = 0) in vec2 vertex_pos;

layout(location = 0) out vec2 uv;
layout(location = 1) flat out vec4 fColor;

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 size;
layout(location = 2) uniform vec2 screen;
layout(location = 3) uniform vec2 uvOffset;
layout(location = 4) uniform vec2 uvDim;

layout(location = 5) uniform int color;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + vec2(vertex_pos.x*size.x, size.y - vertex_pos.y*size.y))/screen;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	fColor = vec4((color & 0xff0000)>>16, (color & 0xff00)>>8, color & 0xff, (color>>24) & 255)/255.0;
	uv = uvOffset + vertex_pos*uvDim;
}

```

`assets/cubyz/shaders/graphics/Line.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) flat in vec4 color;

void main() {
	frag_color = color;
}

```

`assets/cubyz/shaders/graphics/Line.vert`:

```vert
#version 460

layout(location = 0) in vec2 vertex_pos;

layout(location = 0) flat out vec4 color;

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 direction;
layout(location = 2) uniform vec2 screen;

layout(location = 3) uniform int lineColor;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + vertex_pos*direction)/screen;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	color = vec4((lineColor & 0xff0000)>>16, (lineColor & 0xff00)>>8, lineColor & 0xff, (lineColor>>24) & 255)/255.0;
}

```

`assets/cubyz/shaders/graphics/Rect.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) flat in vec4 color;

void main() {
	frag_color = color;
}

```

`assets/cubyz/shaders/graphics/Rect.vert`:

```vert
#version 460

layout(location = 0) in vec2 vertex_pos;

layout(location = 0) flat out vec4 color;

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 size;
layout(location = 2) uniform vec2 screen;

layout(location = 3) uniform int rectColor;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + vertex_pos*size)/screen;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	color = vec4((rectColor & 0xff0000)>>16, (rectColor & 0xff00)>>8, rectColor & 0xff, (rectColor>>24) & 255)/255.0;;
}

```

`assets/cubyz/shaders/graphics/RectBorder.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) flat in vec4 color;

void main(){
	frag_color = color;
}

```

`assets/cubyz/shaders/graphics/RectBorder.vert`:

```vert
#version 460

layout(location = 0) in vec4 vertex_pos;

layout(location = 0) flat out vec4 color;

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 size;
layout(location = 2) uniform vec2 screen;
layout(location = 3) uniform float lineWidth;

layout(location = 4) uniform int rectColor;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + vertex_pos.xy*size + vertex_pos.zw*lineWidth)/screen;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	color = vec4((rectColor & 0xff0000)>>16, (rectColor & 0xff00)>>8, rectColor & 0xff, (rectColor>>24) & 255)/255.0;;
}

```

`assets/cubyz/shaders/graphics/Text.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) in vec2 frag_face_pos;
layout(location = 1) flat in vec4 color;

layout(binding = 0) uniform sampler2D textureSampler;

// in pixels
layout(location = 0) uniform vec4 texture_rect;
layout(location = 1) uniform vec2 scene;
layout(location = 2) uniform vec2 offset;
layout(location = 3) uniform float ratio;
layout(location = 4) uniform int fontEffects;
layout(location = 6) uniform vec2 fontSize;

vec2 convert2Proportional(vec2 original, vec2 full){
	return vec2(original.x/full.x, original.y/full.y);
}

void main() {
	vec4 texture_rect_percentage = vec4(convert2Proportional(texture_rect.xy, fontSize), convert2Proportional(texture_rect.zw, fontSize));
	vec2 texture_position = vec2(
				texture_rect_percentage.x+
				frag_face_pos.x*texture_rect_percentage.z
			,
				texture_rect_percentage.y+
				frag_face_pos.y*texture_rect_percentage.w
			);
	if ((fontEffects & 0x01000000) != 0) { // make it bold in y by sampling more pixels.
		vec2 pixel_offset = 1/fontSize;
		frag_color = color*max(texture(textureSampler, texture_position).r,
					texture(textureSampler, texture_position + vec2(0, 0.5f/fontSize.y)).r);
	} else {
		frag_color = color*texture(textureSampler,
			texture_position).r;
	}
}

```

`assets/cubyz/shaders/graphics/Text.vert`:

```vert
#version 460

layout(location = 0) in vec2 face_pos;

layout(location = 0) out vec2 frag_face_pos;
layout(location = 1) flat out vec4 color;

// in pixels
layout(location = 0) uniform vec4 texture_rect;
layout(location = 1) uniform vec2 scene;
layout(location = 2) uniform vec2 offset;
layout(location = 3) uniform float ratio;
layout(location = 4) uniform int fontEffects;

layout(location = 5) uniform float alpha;

vec2 convert2Proportional(vec2 original, vec2 full) {
	return vec2(original.x/full.x, original.y/full.y);
}

void main() {
	vec2 vertex_pos = face_pos*vec2(1, -1);
	vec2 position_percentage 	= convert2Proportional(floor(offset), scene);
	vec2 size_percentage		= convert2Proportional(floor(vec2(texture_rect.z, texture_rect.w)*ratio), scene);
	if ((fontEffects & 0x02000000) != 0) { // italic
		vertex_pos.x += vertex_pos.y/texture_rect.z;
	}

	// convert glyph coords to opengl coords
	vec4 rect = vec4(position_percentage, size_percentage);

	vec2 position = vec2(rect.x+vertex_pos.x*rect.z, -rect.y+vertex_pos.y*rect.w)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);
	frag_face_pos = face_pos;
	color = vec4(vec3((fontEffects & 0xff0000)>>16, (fontEffects & 0xff00)>>8, fontEffects & 0xff)/255.0, alpha);
}

```

`assets/cubyz/shaders/graphics/graph.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 5) uniform vec3 lineColor;

void main() {
	frag_color = vec4(lineColor, 1);
}

```

`assets/cubyz/shaders/graphics/graph.vert`:

```vert
#version 460

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 dimension;
layout(location = 2) uniform vec2 screen;
layout(location = 3) uniform int points;
layout(location = 4) uniform int offset;

layout(std430, binding = 5) buffer _data
{
	float data[];
};


void main() {
	float x = gl_VertexID;
	float y = -data[(gl_VertexID+offset)%points];
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + dimension*vec2(x/points, y))/screen;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2 + vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);
}

```

`assets/cubyz/shaders/item_drop.frag`:

```frag
#version 460

layout(location = 0) in vec3 startPosition;
layout(location = 1) in vec3 direction;
layout(location = 2) in vec3 cameraSpacePos;
layout(location = 3) in vec2 uv;
layout(location = 4) flat in int faceNormalIndex;
layout(location = 5) flat in vec3 faceNormal;
layout(location = 6) flat in int voxelModel;
layout(location = 7) flat in int textureIndex;
layout(location = 8) flat in uvec3 lower;
layout(location = 9) flat in uvec3 upper;

layout(location = 0) out vec4 fragColor;

layout(binding = 0) uniform sampler2DArray textureSampler;
layout(binding = 1) uniform sampler2DArray emissionSampler;
layout(binding = 2) uniform sampler2DArray reflectivityAndAbsorptionSampler;
layout(binding = 4) uniform samplerCube reflectionMap;

layout(location = 0) uniform mat4 projectionMatrix;

layout(location = 5) uniform vec3 ambientLight;
layout(location = 7) uniform float sizeScale;

layout(location = 8) uniform float reflectionMapSize;
layout(location = 9) uniform float contrast;

layout(location = 10) uniform vec2 glDepthRange;

const float[6] normalVariations = float[6](
	1.0,
	0.80,
	0.9,
	0.9,
	0.95,
	0.85
);

layout(std430, binding = 1) buffer _animatedTexture
{
	float animatedTexture[];
};

// block drops -------------------------------------------------------------------------------------------------------------------------

float lightVariation(vec3 normal) {
	const vec3 directionalPart = vec3(0, contrast/2, contrast);
	const float baseLighting = 1 - contrast;
	return baseLighting + dot(normal, directionalPart);
}

vec4 fixedCubeMapLookup(vec3 v) { // Taken from http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
	float M = max(max(abs(v.x), abs(v.y)), abs(v.z));
	float scale = (reflectionMapSize - 1)/reflectionMapSize;
	if (abs(v.x) != M) v.x *= scale;
	if (abs(v.y) != M) v.y *= scale;
	if (abs(v.z) != M) v.z *= scale;
	return texture(reflectionMap, v);
}

float ditherThresholds[16] = float[16] (
	1/17.0, 9/17.0, 3/17.0, 11/17.0,
	13/17.0, 5/17.0, 15/17.0, 7/17.0,
	4/17.0, 12/17.0, 2/17.0, 10/17.0,
	16/17.0, 8/17.0, 14/17.0, 6/17.0
);

bool passDitherTest(float alpha) {
	ivec2 screenPos = ivec2(gl_FragCoord.xy);
	screenPos &= 3;
	return alpha > ditherThresholds[screenPos.x*4 + screenPos.y];
}

void mainBlockDrop() {
	float animatedTextureIndex = animatedTexture[textureIndex];
	float normalVariation = lightVariation(faceNormal);
	vec3 textureCoords = vec3(uv, animatedTextureIndex);

	float reflectivity = texture(reflectivityAndAbsorptionSampler, textureCoords).a;
	float fresnelReflection = (1 + dot(normalize(direction), faceNormal));
	fresnelReflection *= fresnelReflection;
	fresnelReflection *= min(1, 2*reflectivity); // Limit it to 2*reflectivity to avoid making every block reflective.
	reflectivity = reflectivity*fixedCubeMapLookup(reflect(direction, faceNormal)).x;
	reflectivity = reflectivity*(1 - fresnelReflection) + fresnelReflection;

	vec3 pixelLight = ambientLight*max(vec3(normalVariation), texture(emissionSampler, textureCoords).r*4);
	fragColor = texture(textureSampler, textureCoords)*vec4(pixelLight, 1);
	fragColor.rgb += reflectivity*pixelLight;

	if(!passDitherTest(fragColor.a)) discard;
	fragColor.a = 1;
	gl_FragDepth = gl_FragCoord.z;
}

// itemDrops -------------------------------------------------------------------------------------------------------------------------

layout(std430, binding = 2) buffer _modelInfo
{
	uint modelInfo[];
};

uint getVoxel(ivec3 pos) {
	pos = max(ivec3(0), min(pos, ivec3(upper)));
	int index = (pos.x | pos.y*int(upper.x))*int(upper.z) | pos.z;
	return modelInfo[voxelModel + index];
}

vec4 decodeColor(uint block) {
	return vec4(block >> 16 & uint(255), block >> 8 & uint(255), block & uint(255), block >> 24 & uint(255))/255.0;
}

void mainItemDrop() {
	// Implementation of "A Fast Voxel Traversal Algorithm for Ray Tracing"  http://www.cse.yorku.ca/~amana/research/grid.pdf
	ivec3 step = ivec3(sign(direction));
	vec3 t1 = (floor(startPosition) - startPosition)/direction;
	vec3 tDelta = 1/direction;
	vec3 t2 = t1 + tDelta;
	tDelta = abs(tDelta);
	vec3 tMax = max(t1, t2);
	if(direction.x == 0) tMax.x = 1.0/0.0;
	if(direction.y == 0) tMax.y = 1.0/0.0;
	if(direction.z == 0) tMax.z = 1.0/0.0;

	ivec3 voxelPosition = ivec3(floor(startPosition));
	int lastNormal = faceNormalIndex;
	uint block = getVoxel(voxelPosition);
	float total_tMax = 0;

	uvec3 sizeMask = upper - 1;

	while(block == 0) {
		if(tMax.x < tMax.y) {
			if(tMax.x < tMax.z) {
				voxelPosition.x += step.x;
				if((voxelPosition.x & sizeMask.x) != voxelPosition.x) {
					block = 0;
					break;
				}
				total_tMax = tMax.x;
				tMax.x += tDelta.x;
				lastNormal = 2 + (1 + int(step.x))/2;
			} else {
				voxelPosition.z += step.z;
				if((voxelPosition.z & sizeMask.z) != voxelPosition.z) {
					block = 0;
					break;
				}
				total_tMax = tMax.z;
				tMax.z += tDelta.z;
				lastNormal = 4 + (1 + int(step.z))/2;
			}
		} else {
			if(tMax.y < tMax.z) {
				voxelPosition.y += step.y;
				if((voxelPosition.y & sizeMask.y) != voxelPosition.y) {
					block = 0;
					break;
				}
				total_tMax = tMax.y;
				tMax.y += tDelta.y;
				lastNormal = 0 + (1 + int(step.y))/2;
			} else {
				voxelPosition.z += step.z;
				if((voxelPosition.z & sizeMask.z) != voxelPosition.z) {
					block = 0;
					break;
				}
				total_tMax = tMax.z;
				tMax.z += tDelta.z;
				lastNormal = 4 + (1 + int(step.z))/2;
			}
		}
		block = getVoxel(voxelPosition);
	}
	if(block == 0) discard;

	vec3 modifiedCameraSpacePos = cameraSpacePos*(1 + total_tMax*sizeScale*length(direction)/length(cameraSpacePos));
	vec4 projection = projectionMatrix*vec4(modifiedCameraSpacePos, 1);
	float depth = projection.z/projection.w;
	gl_FragDepth = (((glDepthRange.y - glDepthRange.x) * depth) + glDepthRange.x + glDepthRange.y)/2.0;

	fragColor = decodeColor(block);
	fragColor.a = 1; // No transparency supported!
	fragColor = fragColor*vec4(ambientLight*normalVariations[lastNormal], 1);
}

void main() {
	if(textureIndex >= 0) {
		mainBlockDrop();
	} else {
		mainItemDrop();
	}
}

```

`assets/cubyz/shaders/item_drop.vert`:

```vert
#version 460

layout(location = 0) out vec3 startPosition;
layout(location = 1) out vec3 direction;
layout(location = 2) out vec3 cameraSpacePos;
layout(location = 3) out vec2 uv;
layout(location = 4) flat out int faceNormalIndex;
layout(location = 5) flat out vec3 faceNormal;
layout(location = 6) flat out int voxelModel;
layout(location = 7) flat out int textureIndex;
layout(location = 8) flat out uvec3 lower;
layout(location = 9) flat out uvec3 upper;

layout(location = 0) uniform mat4 projectionMatrix;
layout(location = 1) uniform mat4 viewMatrix;
layout(location = 2) uniform mat4 modelMatrix;
layout(location = 3) uniform int modelIndex;
layout(location = 4) uniform int block;

layout(std430, binding = 2) buffer _modelInfo
{
	uint modelInfo[];
};

struct QuadInfo {
	vec3 normal;
	float corners[4][3];
	vec2 cornerUV[4];
	uint textureSlot;
	int opaqueInLod;
};

layout(std430, binding = 4) buffer _quads
{
	QuadInfo quads[];
};


const int[24] positions = int[24](
	0x010,
	0x110,
	0x011,
	0x111,

	0x000,
	0x001,
	0x100,
	0x101,

	0x100,
	0x101,
	0x110,
	0x111,

	0x000,
	0x010,
	0x001,
	0x011,

	0x001,
	0x011,
	0x101,
	0x111,

	0x000,
	0x100,
	0x010,
	0x110
);

void main() {
	int faceID = gl_VertexID >> 2;
	int vertexID = gl_VertexID & 3;
	int voxelModelIndex = modelIndex;
	bool isBlock = block != 0;
	vec3 pos;
	if(isBlock) {
		uint modelAndTexture = modelInfo[voxelModelIndex + faceID*2];
		uint offsetByNormal = modelInfo[voxelModelIndex + faceID*2 + 1];
		uint quadIndex = modelAndTexture >> 16u;
		textureIndex = int(modelAndTexture & 65535u);

		pos = vec3(quads[quadIndex].corners[vertexID][0], quads[quadIndex].corners[vertexID][1], quads[quadIndex].corners[vertexID][2]);
		uv = quads[quadIndex].cornerUV[vertexID];
		if(offsetByNormal != 0) {
			pos += quads[quadIndex].normal;
		}
		faceNormal = quads[quadIndex].normal;
	} else {
		int position = positions[gl_VertexID];
		pos = vec3 (
			position >> 8 & 1,
			position >> 4 & 1,
			position >> 0 & 1
		);
		faceNormalIndex = faceID;
		upper.x = modelInfo[voxelModelIndex++];
		upper.y = modelInfo[voxelModelIndex++];
		upper.z = modelInfo[voxelModelIndex++];
		lower = uvec3(0);

		startPosition = lower + vec3(upper - lower)*0.999*pos;
		float scale = max(upper.x - lower.x, max(upper.y - lower.y, upper.z - lower.z));
		pos = pos*(upper - lower)/scale + (0.5 - (lower + upper)/scale/2);
		textureIndex = -1;
	}
	voxelModel = voxelModelIndex;


	vec4 worldSpace = modelMatrix*vec4(pos, 1);
	direction = (transpose(mat3(modelMatrix))*worldSpace.xyz).xyz;

	vec4 cameraSpace = viewMatrix*worldSpace;
	gl_Position = projectionMatrix*cameraSpace;
	cameraSpacePos = cameraSpace.xyz;
}

```

`assets/cubyz/shaders/item_texture_post.frag`:

```frag
#version 460

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec2 texCoords;

layout(binding = 3) uniform sampler2D color;

layout(location = 0) uniform bool transparent;

void main() {
	fragColor = texture(color, texCoords);
	if(transparent) {
		fragColor.a = 1;
		// TODO: Remove the background color. Somehow?
	}
	float maxColor = max(1.0, max(fragColor.r, max(fragColor.g, fragColor.b)));
	fragColor.rgb = fragColor.rgb/maxColor;
}

```

`assets/cubyz/shaders/item_texture_post.vert`:

```vert
#version 460

layout(location = 0) in vec2 inTexCoords;

layout(location = 0) out vec2 texCoords;

void main() {
	texCoords = inTexCoords;
	gl_Position = vec4(inTexCoords*2 - vec2(1, 1), 0, 1);
}

```

`assets/cubyz/shaders/particles/particles.frag`:

```frag
#version 430

layout(location = 0) out vec4 fragColor;

layout(location = 0) in vec3 textureCoords;
layout(location = 1) flat in vec3 light;

layout(binding = 0) uniform sampler2DArray textureSampler;
layout(binding = 1) uniform sampler2DArray emissionTextureSampler;

void main() {
	const vec4 texColor = texture(textureSampler, textureCoords);
	if(texColor.a < 0.5) discard;

	const vec3 pixelLight = max(light, texture(emissionTextureSampler, textureCoords).r*4);
	fragColor = texColor*vec4(pixelLight, 1);
}

```

`assets/cubyz/shaders/particles/particles.vert`:

```vert
#version 460

layout(location = 0) out vec3 textureCoords;
layout(location = 1) flat out vec3 light;

layout(location = 0) uniform vec3 ambientLight;
layout(location = 1) uniform mat4 projectionAndViewMatrix;
layout(location = 2) uniform mat4 billboardMatrix;

struct ParticleData {
	vec3 pos;
	float rotation;
	float lifeRatio;
	uint light;
	uint type;
};
layout(std430, binding = 13) restrict readonly buffer _particleData
{
	ParticleData particleData[];
};

struct ParticleTypeData {
	float animationFrames;
	float startFrame;
	float size;
};
layout(std430, binding = 14) restrict readonly buffer _particleTypeData
{
	ParticleTypeData particleTypeData[];
};

const vec2 uvPositions[4] = vec2[4]
(
	vec2(0.0f, 0.0f),
	vec2(1.0f, 0.0f),
	vec2(0.0f, 1.0f),
	vec2(1.0f, 1.0f)
);

const vec3 facePositions[4] = vec3[4]
(
	vec3(-0.5f, -0.5f, 0.0f),
	vec3(-0.5f, 0.5f, 0.0f),
	vec3(0.5f, -0.5f, 0.0f),
	vec3(0.5f, 0.5f, 0.0f)
);

vec3 square(vec3 x) {
	return x*x;
}

void main() {
	int particleID = gl_VertexID >> 2;
	int vertexID = gl_VertexID & 3;
	ParticleData particle = particleData[particleID];
	ParticleTypeData particleType = particleTypeData[particle.type];

	uint fullLight = particle.light;
	vec3 sunLight = vec3(
		fullLight >> 25 & 31u,
		fullLight >> 20 & 31u,
		fullLight >> 15 & 31u
	);
	vec3 blockLight = vec3(
		fullLight >> 10 & 31u,
		fullLight >> 5 & 31u,
		fullLight >> 0 & 31u
	);
	light = min(sqrt(square(sunLight*ambientLight) + square(blockLight)), vec3(31))/31;

	float rotation = particle.rotation;
	vec3 faceVertPos = facePositions[vertexID];
	float sn = sin(rotation);
	float cs = cos(rotation);
	const vec3 vertexRotationPos = vec3(
		faceVertPos.x*cs - faceVertPos.y*sn,
		faceVertPos.x*sn + faceVertPos.y*cs,
		0
	);

	const vec3 vertexPos = (billboardMatrix*vec4(particleType.size*vertexRotationPos, 1)).xyz + particle.pos;
	gl_Position = projectionAndViewMatrix*vec4(vertexPos, 1);

	float textureIndex = floor(particle.lifeRatio*particleType.animationFrames + particleType.startFrame);
	textureCoords = vec3(uvPositions[vertexID], textureIndex);
}

```

`assets/cubyz/shaders/skybox/star.frag`:

```frag
#version 460

layout(location = 0) in vec3 pos;
layout(location = 1) in flat vec3 centerPos;
layout(location = 2) in flat vec3 color;

layout(location = 0, index = 0) out vec4 fragColor;

void main() {
	if (dot(pos - centerPos, pos - centerPos) > 1.0/12.0)
		discard;

	fragColor = vec4(color, 1);
}

```

`assets/cubyz/shaders/skybox/star.vert`:

```vert
#version 460

layout(location = 0) out vec3 pos;
layout(location = 1) out flat vec3 centerPos;
layout(location = 2) out flat vec3 color;

struct star {
	vec4 vertexPositions[3];

	vec3 pos;
	float padding1;
	vec3 color;
	float padding2;
};

layout (std430, binding = 12) buffer _starBuffer {
	star starData[];
};

layout(location = 0) uniform mat4 mvp;
layout(location = 1) uniform float starOpacity;

void main() {
	gl_Position = mvp*vec4(starData[gl_VertexID/3].vertexPositions[gl_VertexID%3].xyz, 1);

	pos = starData[gl_VertexID/3].vertexPositions[gl_VertexID%3].xyz;
	centerPos = starData[gl_VertexID/3].pos;
	color = starData[gl_VertexID/3].color*starOpacity;
}

```

`assets/cubyz/shaders/ui/button.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) in vec2 startCoord;
layout(location = 1) flat in vec4 fColor;

layout(binding = 0) uniform sampler2D image;

layout(location = 4) uniform float scale;

void main() {
	frag_color = texture(image, (gl_FragCoord.xy - startCoord)/(2*scale)/textureSize(image, 0));
	frag_color.a *= fColor.a;
	frag_color.rgb += fColor.rgb;
}

```

`assets/cubyz/shaders/ui/button.vert`:

```vert
#version 460

layout(location = 0) in vec2 vertex_pos;

layout(location = 0) out vec2 startCoord;
layout(location = 1) flat out vec4 fColor;

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 size;
layout(location = 2) uniform vec2 screen;

layout(location = 3) uniform int color;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + vertex_pos*size)/screen;
	startCoord.x = start.x;
	startCoord.y = screen.y - start.y;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	fColor = vec4((color & 0xff0000)>>16, (color & 0xff00)>>8, color & 0xff, (color>>24) & 255)/255.0;
}

```

`assets/cubyz/shaders/ui/window_border.frag`:

```frag
#version 460

layout(location = 0) out vec4 frag_color;

layout(location = 0) flat in vec2 startCoord;
layout(location = 1) flat in vec2 endCoord;
layout(location = 2) flat in vec4 fColor;

layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 size;

layout(location = 4) uniform float scale;
layout(location = 5) uniform vec2 effectLength;

void main() {
	vec2 distanceToBorder = min(gl_FragCoord.xy - startCoord, endCoord - gl_FragCoord.xy)/effectLength/scale;
	float reducedDistance = distanceToBorder.x*distanceToBorder.y/(distanceToBorder.x + distanceToBorder.y); // Inspired by the reduced mass from physics, to give a sort of curvy look to the outline.
	float opacity = max(1 - reducedDistance, 0);
	frag_color = fColor*vec4(1, 1, 1, opacity);
}

```

`assets/cubyz/shaders/ui/window_border.vert`:

```vert
#version 460

layout(location = 0) in vec2 vertex_pos;

layout(location = 0) flat out vec2 startCoord;
layout(location = 1) flat out vec2 endCoord;
layout(location = 2) flat out vec4 fColor;

// in pixel
layout(location = 0) uniform vec2 start;
layout(location = 1) uniform vec2 size;
layout(location = 2) uniform vec2 screen;

layout(location = 3) uniform int color;

void main() {
	// Convert to opengl coordinates:
	vec2 position_percentage = (start + vertex_pos*size)/screen;
	startCoord.x = start.x;
	startCoord.y = screen.y - start.y - size.y;
	endCoord.x = start.x + size.x;
	endCoord.y = screen.y - start.y;

	vec2 position = vec2(position_percentage.x, -position_percentage.y)*2+vec2(-1, 1);

	gl_Position = vec4(position, 0, 1);

	fColor = vec4((color & 0xff0000)>>16, (color & 0xff00)>>8, color & 0xff, (color>>24) & 255)/255.0;
}

```

`assets/cubyz/tools/axe.zig.zon`:

```zon
.{
	.blockTags = .{.choppable},
	.disabled = .{
		0, 0, 1, 1, 1,
		0, 0, 0, 1, 1,
		0, 0, 0, 0, 1,
		1, 0, 0, 0, 1,
		1, 1, 1, 1, 0,
	},
	.optional = .{
		1, 1, 0, 0, 0,
		1, 1, 1, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 1, 1, 0,
		0, 0, 0, 0, 0,
	},
	.parameters = .{
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				1.5, 2.0, 0x0, 0x0, 0x0,
				2.0, 2.0, 1.5, 0x0, 0x0,
				2.0, 1.5, 1.0, 0.5, 0x0,
				0x0, 1.0, 0.5, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.08,
			.method = .sum,
		},
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				1.5, 2.0, 0x0, 0x0, 0x0,
				2.0, 2.0, 1.5, 0x0, 0x0,
				2.0, 1.5, 1.0, 0.5, 0x0,
				0x0, 1.0, 0.5, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.32,
			.method = .average,
		},
		.{
			.source = .hardnessDamage,
			.destination = .damage,
			.matrix = .{
				0.0, 0.0, 0x0, 0x0, 0x0,
				0.1, 0.0, 0.0, 0x0, 0x0,
				1.0, 0.1, 0.0, 0.0, 0x0,
				0x0, 1.0, 0.1, 0.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.0,
			},
			.factor = 0.3,
			.method = .average,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				0.1, 0.5, 0x0, 0x0, 0x0,
				1.0, 1.5, 0.5, 0x0, 0x0,
				2.0, 2.0, 2.5, 0.5, 0x0,
				0x0, 2.0, 1.5, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 1.0,
			},
			.factor = 0.05,
			.method = .sum,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				0.1, 0.5, 0x0, 0x0, 0x0,
				1.0, 1.5, 0.5, 0x0, 0x0,
				2.0, 2.0, 2.5, 0.5, 0x0,
				0x0, 2.0, 1.5, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 1.0,
			},
			.factor = 0.2,
			.method = .average,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				0.1, 0.5, 0x0, 0x0, 0x0,
				0.5, 1.0, 0.5, 0x0, 0x0,
				2.0, 2.5, 1.5, 0.5, 0x0,
				0x0, 2.0, 0.5, 0.5, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.5,
			},
			.factor = -0.2,
			.method = .sum,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				0.1, 0.5, 0x0, 0x0, 0x0,
				0.5, 1.0, 0.5, 0x0, 0x0,
				2.0, 2.5, 1.5, 0.5, 0x0,
				0x0, 2.0, 0.5, 0.5, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.5,
			},
			.factor = 1.2,
			.method = .average,
		},
	},
}

```

`assets/cubyz/tools/chisel.zig.zon`:

```zon
.{
	.blockTags = .{.chiselable},
	.disabled = .{
		0, 0, 1, 1, 1,
		0, 0, 0, 1, 1,
		1, 0, 0, 1, 1,
		1, 1, 1, 0, 0,
		1, 1, 1, 0, 0,
	},
	.optional = .{
		0, 1, 0, 0, 0,
		1, 1, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 1, 1,
		0, 0, 0, 1, 0,
	},
	.parameters = .{
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				0.5, 0.5, 0x0, 0x0, 0x0,
				0.5, 0.5, 0.5, 0x0, 0x0,
				0x0, 0.5, 0.5, 0x0, 0x0,
				0x0, 0x0, 0x0, 0.5, 0.5,
				0x0, 0x0, 0x0, 0.5, 0.5,
			},
			.factor = 0.2,
			.method = .sum,
		},
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				0.5, 0.5, 0x0, 0x0, 0x0,
				0.5, 0.5, 0.5, 0x0, 0x0,
				0x0, 0.5, 0.5, 0x0, 0x0,
				0x0, 0x0, 0x0, 0.5, 0.5,
				0x0, 0x0, 0x0, 0.5, 0.5,
			},
			.factor = 0.8,
			.method = .average,
		},
		.{
			.source = .hardnessDamage,
			.destination = .damage,
			.matrix = .{
				0.2, 0.1, 0x0, 0x0, 0x0,
				0.1, 0.1, 0.0, 0x0, 0x0,
				0x0, 0.0, 0.0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0.0, 0.0,
				0x0, 0x0, 0x0, 0.0, 0.0,
			},
			.factor = 1.0,
			.method = .average,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				1.5, 1.5, 0x0, 0x0, 0x0,
				1.5, 2.0, 1.0, 0x0, 0x0,
				0x0, 1.0, 0.5, 0.5, 0x0,
				0x0, 0x0, 0.5, 0.1, 0.1,
				0x0, 0x0, 0x0, 0.1, 0.1,
			},
			.factor = 0.2,
			.method = .sum,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				1.5, 1.5, 0x0, 0x0, 0x0,
				1.5, 2.0, 1.0, 0x0, 0x0,
				0x0, 1.0, 0.5, 0.5, 0x0,
				0x0, 0x0, 0.5, 0.1, 0.1,
				0x0, 0x0, 0x0, 0.1, 0.1,
			},
			.factor = 0.8,
			.method = .average,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				1.0, 1.0, 0x0, 0x0, 0x0,
				1.0, 1.5, 1.0, 0x0, 0x0,
				0x0, 1.0, 1.0, 1.0, 0x0,
				0x0, 0x0, 1.0, 0.5, 0.5,
				0x0, 0x0, 0x0, 0.5, 0.5,
			},
			.factor = -0.2,
			.method = .sum,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				1.0, 1.0, 0x0, 0x0, 0x0,
				1.0, 1.5, 1.0, 0x0, 0x0,
				0x0, 1.0, 1.0, 1.0, 0x0,
				0x0, 0x0, 1.0, 0.5, 0.5,
				0x0, 0x0, 0x0, 0.5, 0.5,
			},
			.factor = 1.2,
			.method = .average,
		},
	},
}

```

`assets/cubyz/tools/pickaxe.zig.zon`:

```zon
.{
	.blockTags = .{.mineable},
	.disabled = .{
		0, 0, 0, 0, 1,
		0, 0, 0, 1, 1,
		0, 0, 0, 1, 1,
		0, 1, 1, 0, 1,
		1, 1, 1, 1, 0,
	},
	.optional = .{
		1, 1, 1, 1, 0,
		1, 1, 1, 0, 0,
		1, 1, 1, 0, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 0, 0,
	},
	.parameters = .{
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				2.5, 2.0, 1.5, 1.0, 0x0,
				2.0, 1.5, 1.0, 0x0, 0x0,
				1.5, 1.0, 0.5, 0x0, 0x0,
				1.0, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.2,
			.method = .sum,
		},
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				2.5, 2.0, 1.5, 1.0, 0x0,
				2.0, 1.5, 1.0, 0x0, 0x0,
				1.5, 1.0, 0.5, 0x0, 0x0,
				1.0, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.8,
			.method = .average,
		},
		.{
			.source = .hardnessDamage,
			.destination = .damage,
			.matrix = .{
				0.0, 0.0, 0.1, 0.1, 0x0,
				0.0, 0.1, 0.0, 0x0, 0x0,
				0.1, 0.0, 0.0, 0x0, 0x0,
				1.0, 0x0, 0x0, 0.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.0,
			},
			.factor = 1.0,
			.method = .average,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				0.5, 1.0, 1.0, 1.0, 0x0,
				1.0, 2.0, 1.5, 0x0, 0x0,
				1.0, 1.5, 1.5, 0x0, 0x0,
				1.0, 0x0, 0x0, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.5,
			},
			.factor = 0.2,
			.method = .sum,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				0.5, 1.0, 1.0, 1.0, 0x0,
				1.0, 2.0, 1.5, 0x0, 0x0,
				1.0, 1.5, 1.5, 0x0, 0x0,
				1.0, 0x0, 0x0, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.5,
			},
			.factor = 0.8,
			.method = .average,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				0.1, 0.5, 2.0, 2.5, 0x0,
				0.5, 1.5, 0.5, 0x0, 0x0,
				2.0, 0.5, 0.1, 0x0, 0x0,
				2.5, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = -0.2,
			.method = .sum,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				0.1, 0.5, 2.0, 2.5, 0x0,
				0.5, 1.5, 0.5, 0x0, 0x0,
				2.0, 0.5, 0.1, 0x0, 0x0,
				2.5, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 1.2,
			.method = .average,
		},
	},
}

```

`assets/cubyz/tools/shover.zig.zon`:

```zon
.{
	.blockTags = .{.diggable},
	.disabled = .{
		0, 0, 0, 1, 1,
		0, 0, 0, 0, 1,
		0, 0, 0, 0, 1,
		1, 0, 0, 0, 1,
		1, 1, 1, 1, 0,
	},
	.optional = .{
		1, 0, 1, 0, 0,
		0, 1, 1, 1, 0,
		1, 1, 1, 1, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
	},
	.parameters = .{
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				2.5, 2.0, 1.0, 0x0, 0x0,
				2.0, 2.0, 1.5, 0.5, 0x0,
				1.0, 1.5, 1.0, 0.5, 0x0,
				0x0, 0.5, 0.5, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.06,
			.method = .sum,
		},
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				2.5, 2.0, 1.0, 0x0, 0x0,
				2.0, 2.0, 1.5, 0.5, 0x0,
				1.0, 1.5, 1.0, 0.5, 0x0,
				0x0, 0.5, 0.5, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.24,
			.method = .average,
		},
		.{
			.source = .hardnessDamage,
			.destination = .damage,
			.matrix = .{
				2.0, 1.0, 0.1, 0x0, 0x0,
				1.0, 0.1, 0.1, 0.1, 0x0,
				0.1, 0.1, 0.1, 0.1, 0x0,
				0x0, 0.1, 0.1, 0.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.0,
			},
			.factor = 0.2,
			.method = .average,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				1.5, 1.0, 0.1, 0x0, 0x0,
				1.0, 2.0, 1.0, 0.1, 0x0,
				0.1, 1.0, 1.5, 0.5, 0x0,
				0x0, 0.1, 0.5, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 1.0,
			},
			.factor = 0.8,
			.method = .average,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				1.5, 1.0, 0.1, 0x0, 0x0,
				1.0, 2.0, 1.0, 0.1, 0x0,
				0.1, 1.0, 1.5, 0.5, 0x0,
				0x0, 0.1, 0.5, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 1.0,
			},
			.factor = 0.2,
			.method = .sum,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				1.5, 1.5, 0.5, 0x0, 0x0,
				1.5, 2.0, 1.5, 0.5, 0x0,
				0.5, 1.5, 1.0, 0.5, 0x0,
				0x0, 0.5, 0.5, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 1.2,
			.method = .average,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				1.5, 1.5, 0.5, 0x0, 0x0,
				1.5, 2.0, 1.5, 0.5, 0x0,
				0.5, 1.5, 1.0, 0.5, 0x0,
				0x0, 0.5, 0.5, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = -0.2,
			.method = .sum,
		},
	},
}

```

`assets/cubyz/tools/sickle.zig.zon`:

```zon
.{
	.blockTags = .{.cuttable},
	.disabled = .{
		1, 0, 0, 0, 1,
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		1, 1, 1, 0, 1,
		1, 1, 1, 1, 0,
	},
	.optional = .{
		0, 1, 1, 1, 0,
		1, 1, 1, 1, 1,
		0, 0, 0, 1, 1,
		0, 0, 0, 1, 0,
		0, 0, 0, 0, 0,
	},
	.parameters = .{
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				0x0, 2.5, 2.0, 2.0, 0x0,
				2.5, 1.5, 1.5, 1.0, 1.5,
				1.5, 0x0, 0x0, 0.5, 1.0,
				0x0, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.06,
			.method = .sum,
		},
		.{
			.source = .massDamage,
			.destination = .damage,
			.matrix = .{
				0x0, 2.5, 2.0, 2.0, 0x0,
				2.5, 1.5, 1.5, 1.0, 1.5,
				1.5, 0x0, 0x0, 0.5, 1.0,
				0x0, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 0.24,
			.method = .average,
		},
		.{
			.source = .hardnessDamage,
			.destination = .damage,
			.matrix = .{
				0x0, 0.1, 0.0, 0.0, 0x0,
				0.2, 0.5, 0.0, 0.0, 0.0,
				1.0, 0x0, 0x0, 0.0, 0.0,
				0x0, 0x0, 0x0, 0.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.0,
			},
			.factor = 0.2,
			.method = .average,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				0x0, 0.5, 1.0, 1.5, 0x0,
				0.5, 1.0, 1.5, 2.0, 1.5,
				1.0, 0x0, 0x0, 1.5, 1.0,
				0x0, 0x0, 0x0, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 1.0,
			},
			.factor = 0.2,
			.method = .sum,
		},
		.{
			.source = .durability,
			.destination = .maxDurability,
			.matrix = .{
				0x0, 0.5, 1.0, 1.5, 0x0,
				0.5, 1.0, 1.5, 2.0, 1.5,
				1.0, 0x0, 0x0, 1.5, 1.0,
				0x0, 0x0, 0x0, 1.0, 0x0,
				0x0, 0x0, 0x0, 0x0, 1.0,
			},
			.factor = 0.8,
			.method = .average,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				0x0, 1.0, 0.5, 0.5, 0x0,
				1.5, 1.5, 1.0, 1.0, 0.5,
				2.0, 0x0, 0x0, 0.1, 0.5,
				0x0, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = -0.2,
			.method = .sum,
		},
		.{
			.source = .swingSpeed,
			.destination = .swingSpeed,
			.matrix = .{
				0x0, 1.0, 0.5, 0.5, 0x0,
				1.5, 1.5, 1.0, 1.0, 0.5,
				2.0, 0x0, 0x0, 0.1, 0.5,
				0x0, 0x0, 0x0, 0.1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0.1,
			},
			.factor = 1.2,
			.method = .average,
		},
	},
}

```

`assets/cubyz/wordlist`:

```
abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo
```

`assets/cubyz/world_presets/default.zig.zon`:

```zon
.{
	.climateGenerator = .{
		.id = "cubyz:noise_based_voronoi",
	},
	.mapGenerator = .{
		.id = "cubyz:mapgen_v1",
	},
	.climateWavelengths = .{
		.hot_cold = 2400,
		.land_ocean = 3200,
		.wet_dry = 1800,
		.vegetation = 1600,
		.mountain = 512,
	},
}

```

`assets/cubyz/world_presets/flat.zig.zon`:

```zon
.{
	.climateGenerator = .{
		.id = "cubyz:single_biome",
		.biome = "cubyz:development/flat",
	},
	.mapGenerator = .{
		.id = "cubyz:mapgen_v1",
	},
	.generators = .{
		.@"cubyz:ore" = .{
			.state = .disabled,
		},
	},
	.caveGenerators = .{
		.@"cubyz:fractal_cave" = .{
			.state = .disabled,
		},
		.@"cubyz:noise_cave" = .{
			.state = .disabled,
		},
	},
	.climateWavelengths = .{
		.hot_cold = 2400,
		.land_ocean = 3200,
		.wet_dry = 1800,
		.vegetation = 1600,
		.mountain = 512,
	},
}

```

`assets/cubyz/world_presets/structure_world.zig.zon`:

```zon
.{
	.climateGenerator = .{
		.id = "cubyz:single_biome",
		.biome = "cubyz:development/flat",
	},
	.mapGenerator = .{
		.id = "cubyz:mapgen_v1",
	},
	.generators = .{
		.@"cubyz:ore" = .{
			.state = .disabled,
		},
	},
	.caveGenerators = .{
		.@"cubyz:fractal_cave" = .{
			.state = .disabled,
		},
		.@"cubyz:noise_cave" = .{
			.state = .disabled,
		},
	},
	.structureMapGenerators = .{
		.@"cubyz:simple_structures" = .{
			.state = .disabled,
		},
		.@"cubyz:sbb_enumeration_generator" = .{
			.state = .enabled,
		},
	},
	.climateWavelengths = .{
		.hot_cold = 2400,
		.land_ocean = 3200,
		.wet_dry = 1800,
		.vegetation = 1600,
		.mountain = 512,
	},
}

```

`build.zig`:

```zig
const std = @import("std");

fn libName(b: *std.Build, name: []const u8, target: std.Target) []const u8 {
	return switch (target.os.tag) {
		.windows => b.fmt("{s}.lib", .{name}),
		else => b.fmt("lib{s}.a", .{name}),
	};
}

fn linkLibraries(b: *std.Build, exe: *std.Build.Step.Compile, useLocalDeps: bool) void {
	const target = exe.root_module.resolved_target.?;
	const t = target.result;
	const optimize = exe.root_module.optimize.?;

	exe.linkLibC();
	exe.linkLibCpp();

	const depsLib = b.fmt("cubyz_deps_{s}-{s}-{s}", .{@tagName(t.cpu.arch), @tagName(t.os.tag), switch (t.os.tag) {
		.linux => "musl",
		.macos => "none",
		.windows => "gnu",
		else => "none",
	}});
	const artifactName = libName(b, depsLib, t);

	var depsName: []const u8 = b.fmt("cubyz_deps_{s}_{s}", .{@tagName(t.cpu.arch), @tagName(t.os.tag)});
	if (useLocalDeps) depsName = "local";

	const libsDeps = b.lazyDependency(depsName, .{
		.target = target,
		.optimize = optimize,
	}) orelse {
		// Lazy dependencies with a `url` field will fail here the first time.
		// build.zig will restart and try again.
		std.log.info("Downloading cubyz_deps libraries {s}.", .{depsName});
		return;
	};
	const headersDeps = if (useLocalDeps) libsDeps else b.lazyDependency("cubyz_deps_headers", .{}) orelse {
		std.log.info("Downloading cubyz_deps headers {s}.", .{depsName});
		return;
	};

	exe.addIncludePath(headersDeps.path("include"));
	exe.addObjectFile(libsDeps.path("lib").path(b, artifactName));
	const subPath = libsDeps.path("lib").path(b, depsLib);
	exe.addObjectFile(subPath.path(b, libName(b, "glslang", t)));
	exe.addObjectFile(subPath.path(b, libName(b, "MachineIndependent", t)));
	exe.addObjectFile(subPath.path(b, libName(b, "GenericCodeGen", t)));
	exe.addObjectFile(subPath.path(b, libName(b, "glslang-default-resource-limits", t)));
	exe.addObjectFile(subPath.path(b, libName(b, "SPIRV", t)));
	exe.addObjectFile(subPath.path(b, libName(b, "SPIRV-Tools", t)));
	exe.addObjectFile(subPath.path(b, libName(b, "SPIRV-Tools-opt", t)));

	if (t.os.tag == .macos) {
		const moltenVkLibInstall = b.addInstallFile(subPath.path(b, "libMoltenVK.dylib"), "bin/Cubyz.app/Contents/Frameworks/libMoltenVK.dylib");
		const moltenVkJsonInstall = b.addInstallFile(subPath.path(b, "MoltenVK_icd.json"), "bin/Cubyz.app/Contents/Resources/vulkan/icd.d/MoltenVK_icd.json");
		exe.step.dependOn(&moltenVkLibInstall.step);
		exe.step.dependOn(&moltenVkJsonInstall.step);

		const validationLayerLibInstall = b.addInstallFile(subPath.path(b, "libVkLayer_khronos_validation.dylib"), "bin/Cubyz.app/Contents/Frameworks/libVkLayer_khronos_validation.dylib");
		const validationLayerJsonInstall = b.addInstallFile(subPath.path(b, "VkLayer_khronos_validation.json"), "bin/Cubyz.app/Contents/Resources/vulkan/explicit_layer.d/VkLayer_khronos_validation.json");
		exe.step.dependOn(&validationLayerLibInstall.step);
		exe.step.dependOn(&validationLayerJsonInstall.step);
	}

	if (t.os.tag == .windows) {
		exe.linkSystemLibrary("bcrypt");
		exe.linkSystemLibrary("crypt32");
		exe.linkSystemLibrary("gdi32");
		exe.linkSystemLibrary("opengl32");
		exe.linkSystemLibrary("ws2_32");
	} else if (t.os.tag == .macos) {
		exe.linkFramework("Cocoa");
		exe.linkFramework("CoreFoundation");
		exe.linkFramework("IOKit");
		exe.linkFramework("QuartzCore");
	} else if (t.os.tag != .linux) {
		std.log.err("Unsupported target: {}\n", .{t.os.tag});
	}
}

pub fn makeModFeature(step: *std.Build.Step, name: []const u8) !void {
	var featureList: std.ArrayListUnmanaged(u8) = .{};
	defer featureList.deinit(step.owner.allocator);

	var modDir = try std.fs.cwd().openDir("mods", .{.iterate = true});
	defer modDir.close();

	var iterator = modDir.iterate();
	while (try iterator.next()) |modEntry| {
		if (modEntry.kind != .directory) continue;

		var mod = try modDir.openDir(modEntry.name, .{});
		defer mod.close();

		var featureDir = mod.openDir(name, .{.iterate = true}) catch continue;
		defer featureDir.close();

		var featureIterator = featureDir.iterate();
		while (try featureIterator.next()) |featureEntry| {
			if (featureEntry.kind != .file) continue;
			if (!std.mem.endsWith(u8, featureEntry.name, ".zig")) continue;

			try featureList.appendSlice(step.owner.allocator, step.owner.fmt(
				\\pub const @"{s}:{s}" = @import("{s}/{s}/{s}");
				\\
			,
				.{
					modEntry.name,
					featureEntry.name[0 .. featureEntry.name.len - 4],
					modEntry.name,
					name,
					featureEntry.name,
				},
			));
		}
	}

	const file_path = step.owner.fmt("mods/{s}.zig", .{name});
	try std.fs.cwd().writeFile(.{.data = featureList.items, .sub_path = file_path});
}

pub fn addModFeatureModule(b: *std.Build, exe: *std.Build.Step.Compile, name: []const u8) !void {
	const module = b.createModule(.{
		.root_source_file = b.path(b.fmt("mods/{s}.zig", .{name})),
		.target = exe.root_module.resolved_target,
		.optimize = exe.root_module.optimize,
	});
	module.addImport("main", exe.root_module);
	exe.root_module.addImport(name, module);
}

fn addModFeatures(b: *std.Build, exe: *std.Build.Step.Compile) !void {
	const step = try b.allocator.create(std.Build.Step);
	step.* = std.Build.Step.init(.{
		.id = .custom,
		.name = "Create Mods",
		.owner = b,
		.makeFn = makeModFeaturesStep,
	});
	exe.step.dependOn(step);

	try addModFeatureModule(b, exe, "rotation");
}

pub fn makeModFeaturesStep(step: *std.Build.Step, _: std.Build.Step.MakeOptions) anyerror!void {
	try makeModFeature(step, "rotation");
}

fn createLaunchConfig() !void {
	std.fs.cwd().access("launchConfig.zon", .{}) catch {
		const launchConfig =
			\\.{
			\\    .cubyzDir = "",
			\\    .autoEnterWorld = "",
			\\    .headlessServer = false,
			\\    // .preferredAuthenticationAlgorithm = .ed25519, // Uncomment and change this if you own a server in an outdated game version where the default algorithm got compromised.
			\\}
		;
		try std.fs.cwd().writeFile(.{
			.data = launchConfig,
			.sub_path = "launchConfig.zon",
		});
	};
}

pub fn build(b: *std.Build) !void {
	try createLaunchConfig();

	// Standard target options allows the person running `zig build` to choose
	// what target to build for. Here we do not override the defaults, which
	// means any target is allowed, and the default is native. Other options
	// for restricting supported target set are available.
	const target = b.standardTargetOptions(.{});

	// Standard release options allow the person running `zig build` to select
	// between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.
	const optimize = b.standardOptimizeOption(.{});

	const options = b.addOptions();
	const isRelease = b.option(bool, "release", "Removes the -dev flag from the version") orelse false;
	const version = b.fmt("0.2.0{s}", .{if (isRelease) "" else "-dev"});
	options.addOption([]const u8, "version", version);
	options.addOption(bool, "isTaggedRelease", isRelease);

	const useLocalDeps = b.option(bool, "local", "Use local cubyz_deps") orelse false;

	const largeAssets = b.dependency("cubyz_large_assets", .{});
	b.installDirectory(.{
		.source_dir = largeAssets.path("music"),
		.install_subdir = "assets/cubyz/music/",
		.install_dir = .{.custom = ".."},
	});
	b.installDirectory(.{
		.source_dir = largeAssets.path("fonts"),
		.install_subdir = "assets/cubyz/fonts/",
		.install_dir = .{.custom = ".."},
	});

	const mainModule = b.addModule("main", .{
		.root_source_file = b.path("src/main.zig"),
		.target = target,
		.optimize = optimize,
	});

	const exe = b.addExecutable(.{
		.name = "Cubyz",
		.root_module = mainModule,
		//.sanitize_thread = true,
		.use_llvm = true,
	});
	exe.root_module.addOptions("build_options", options);
	exe.root_module.addImport("main", mainModule);
	try addModFeatures(b, exe);

	if (isRelease and target.result.os.tag == .windows) {
		exe.subsystem = .Windows;
	}

	linkLibraries(b, exe, useLocalDeps);

	var exeInstallOptions: std.Build.Step.InstallArtifact.Options = .{};
	if (target.result.os.tag == .macos) {
		exeInstallOptions = .{
			.dest_dir = .{.override = .{.custom = "bin/Cubyz.app/Contents/MacOS"}},
		};

		const plistContents =
			\\<?xml version="1.0" encoding="UTF-8"?>
			\\<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
			\\<plist version="1.0">
			\\<dict>
			\\    <key>CFBundleIconFile</key>
			\\    <string>logo</string>
			\\</dict>
			\\</plist>
		;

		const writeFiles = b.addWriteFiles();
		const plistPath = writeFiles.add("Info.plist", plistContents);
		const plistInstall = b.addInstallFile(plistPath, "bin/Cubyz.app/Contents/Info.plist");
		b.getInstallStep().dependOn(&plistInstall.step);
		const iconsInstall = b.addInstallFile(b.path("assets/cubyz/logo.icns"), "bin/Cubyz.app/Contents/Resources/logo.icns");
		b.getInstallStep().dependOn(&iconsInstall.step);

		// NOTE(blackedout): This is to make the Vulkan loader search in (bundle)/Contents/Frameworks to find the libs referenced in the manifest files
		exe.root_module.addRPathSpecial("@loader_path/../Frameworks");
	}

	const installExe = b.addInstallArtifact(exe, exeInstallOptions);
	b.getInstallStep().dependOn(&installExe.step);

	const run_cmd = b.addRunArtifact(exe);
	run_cmd.step.dependOn(b.getInstallStep());
	if (b.args) |args| {
		run_cmd.addArgs(args);
	}

	const run_step = b.step("run", "Run the app");
	run_step.dependOn(&run_cmd.step);

	const dependencyWithTestRunner = b.lazyDependency("cubyz_test_runner", .{
		.target = target,
		.optimize = optimize,
	}) orelse {
		std.log.info("Downloading cubyz_test_runner dependency.", .{});
		return;
	};
	const exe_tests = b.addTest(.{
		.root_module = mainModule,
		.test_runner = .{.path = dependencyWithTestRunner.path("lib/compiler/test_runner.zig"), .mode = .simple},
	});
	linkLibraries(b, exe_tests, useLocalDeps);
	exe_tests.root_module.addOptions("build_options", options);
	exe_tests.root_module.addImport("main", mainModule);
	try addModFeatures(b, exe_tests);
	const run_exe_tests = b.addRunArtifact(exe_tests);

	const test_step = b.step("test", "Run unit tests");
	test_step.dependOn(&run_exe_tests.step);

	// MARK: Formatter

	const formatter = b.addExecutable(.{
		.name = "CubyzFormatter",
		.root_module = b.addModule("format", .{
			.root_source_file = b.path("src/formatter/format.zig"),
			.target = target,
			.optimize = optimize,
		}),
	});
	// ZLS is stupid and cannot detect which executable is the main one, so we add the import everywhere...
	formatter.root_module.addOptions("build_options", options);
	formatter.root_module.addImport("main", mainModule);

	const formatter_install = b.addInstallArtifact(formatter, .{});

	const formatter_cmd = b.addRunArtifact(formatter);
	formatter_cmd.step.dependOn(&formatter_install.step);
	if (b.args) |args| {
		formatter_cmd.addArgs(args);
	}

	const formatter_step = b.step("format", "Check the formatting of the code");
	formatter_step.dependOn(&formatter_cmd.step);
}

```

`build.zig.zon`:

```zon
.{
	.name = .Cubyzig,
	.fingerprint = 0x782a2e402c0ee887,
	.version = "0.0.0",
	.paths = .{""},
	.dependencies = .{
		.local = .{
			.path = "../Cubyz-libs/zig-out", // Local alternative to the cubyz_deps below
			.lazy = true,
		},
		.cubyz_deps_headers = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_headers.tar.gz",
			.hash = "N-V-__8AAAQ8dwBKANzWIqLXH227TZFN-Cs3SEUz1BlvOIdk",
		},
		.cubyz_deps_aarch64_macos = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_aarch64-macos-none.tar.gz",
			.hash = "N-V-__8AAFDsiwWqygpcW19zQ5qWleEjoqaiuzT1NiLJkwgV",
			.lazy = true,
		},
		.cubyz_deps_aarch64_linux = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_aarch64-linux-musl.tar.gz",
			.hash = "N-V-__8AANpf5AKBmNccW_gzB8L0ROUX23R9SvwakkIaC8dI",
			.lazy = true,
		},
		.cubyz_deps_aarch64_windows = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_aarch64-windows-gnu.tar.gz",
			.hash = "N-V-__8AAEpU-wLzojxVacuzuCWzgxX832c35NhDPdlpzzNV",
			.lazy = true,
		},
		.cubyz_deps_x86_64_macos = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_x86_64-macos-none.tar.gz",
			.hash = "N-V-__8AAFEIfwXPoQ_whMaJiUEiYTYbz7i3GLbtGJ5yyuYn",
			.lazy = true,
		},
		.cubyz_deps_x86_64_linux = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_x86_64-linux-musl.tar.gz",
			.hash = "N-V-__8AAIg94AIPPluGDS6T9ZsEmWU6NjyhrCVNhzb93w-V",
			.lazy = true,
		},
		.cubyz_deps_x86_64_windows = .{
			.url = "https://github.com/PixelGuys/Cubyz-Libs/releases/download/11/cubyz_deps_x86_64-windows-gnu.tar.gz",
			.hash = "N-V-__8AALI8HwOYeQDK3pbIUi7_ugLq5oXLbwdoVp6JNnYW",
			.lazy = true,
		},
		.cubyz_large_assets = .{
			.url = "https://github.com/PixelGuys/Cubyz-Assets/releases/download/0.1.0/assets.tar.gz",
			.hash = "N-V-__8AACQYrweKK0-hEabTekSwmGwxKrIbdY_2QTOEA7TN",
		},
		.cubyz_test_runner = .{
			.url = "https://github.com/PixelGuys/Cubyz-std-lib/archive/refs/tags/0.16.0-dev.1424+1.tar.gz",
			.hash = "zig-0.0.0-Fp4XJAXmXQ1r23tqehV14LpPFILnnXSyg7bPitqs8mrf",
			.lazy = true,
		},
	},
}

```

`debug_linux.sh`:

```sh
#!/bin/bash

cd "$(dirname "$0")"

fail () {
	exit 1
}

if ! ./scripts/install_compiler_linux.sh
then
	echo Failed to install Zig compiler.
	fail
fi

echo "Building Zig Cubyz ($@) from source. This may take a few minutes..."

./compiler/zig/zig build --error-style minimal "$@"

if [ $? != 0 ]
then
	fail
fi

echo "Cubyz successfully built!"
echo "Launching Cubyz."

if [ "$(uname)" = "Darwin" ]; then
    ./zig-out/bin/Cubyz.app/Contents/MacOS/Cubyz
else
    ./zig-out/bin/Cubyz
fi

```

`debug_windows.bat`:

```bat
@echo off

cd /D "%~dp0"

call scripts\install_compiler_windows.bat
if errorlevel 1 (
	echo Failed to install Zig compiler.
	exit /b 1
)

echo Building Zig Cubyz (%*^) from source. This may take a few minutes...

compiler\zig\zig build --error-style minimal %*

if errorlevel 1 (
	exit /b 1
)

echo Cubyz successfully built!
echo Launching Cubyz.

zig-out\bin\Cubyz

```

`docs/CONTENT_SUGGESTIONS.md`:

```md
## We do not accept low-effort content suggestions

It is easy to suggest something, but often it's much harder to implement and check if it fits the game.
So, before making a suggestion here on github (you can of course freely discuss ideas on the community discord server), please do the following steps:

- check if it follows the [Game Design Principles](https://github.com/PixelGuys/Cubyz/blob/master/docs/GAME_DESIGN_PRINCIPLES.md)
- make a reference implementation in the form of an addon, mod or fork of Cubyz (no content from other games)
- create a pull request with the suggested changes or make an issue using the blank issue template, don't forget to add some screenshots
```

`docs/CONTRIBUTING.md`:

```md
# About this document

This document contains a set of guidelines to help you contribute to Cubyz in a smooth and efficient manner.

Making a pull requests that go through multiple rounds of reviews before getting merged is annoying for everyone involved.

The sections are roughly sorted by the time you'll encounter them, starting before selecting what to work on and ending after you made your pull request.

I'd recommend to check out the [Discord Server](https://discord.gg/XtqCRRG) if you have any further questions.

# Please don't use AI/LLMs to make pull requests
Modern (narrow) AI is not trained to be good at programming, it is trained to be good at producing code that matches the training data. The result is inevitably going to be worse in quality and likely won't follow a project's conventions as outlined in this document.
Furthermore narrow AI is unable to learn. Compare that to a human who will generally not make the same mistake twice.

So, if you want to help the project, then please don't waste my time by making me review an AI-generated pull request. Instead please invest your own time and learn how to code properly. It is worth it, I promise.

# Learn Zig

Kind of obvious, but still important: https://ziglang.org/learn/

If you are new to Zig it can also be very helpful to ask questions. For example, if something feels annoying to write, then you might be missing knowledge about better approaches. Asking a question is usually faster than writing 100 lines of cumbersome code (and it saves a review cycle).

# Disable Zig's automatic formatter

Cubyz uses a slightly modified version of `zig fmt` which uses tabs and behaves slightly different in regards to spacing.
Because of that, if you use the the default Zig formatter it will reformat all your files.

To fix this you need to disable zig's formatter (In VSCode you can disable this in the Zig extension settings).

The formatter has the same command line arguments as `zig fmt` and you can download it [here](https://github.com/PixelGuys/Cubyz-formatter/releases).

# Select something to work on

The best way to start is obviously the issues tab. The issues are organized with labels (most importantly the Contributor friendly label) and milestones, so it should be easy to find something.

But of course the ever-growing list of issues is not complete and other changes are welcome as well, as long as they are not going in a completely different direction. And also make sure to explain what you are trying to do in the pull request description.

You might also find some ideas on [Discord](https://discord.gg/XtqCRRG).

# Start ₛₘₐₗₗ

Especially as a first time contributor it is likely that your code is not meeting the standards of Cubyz. This is totally normal, but obviously it means that your changes will go through more review cycles.

To have more success it would help to split things up into smaller PRs, maybe start by doing some preliminary changes leading up to feature, for example you could start by just introducing some new utility functions you will need for the actual feature. And of course it can be helpful to ask first if you are even going in the right direction.

This saves time on your end spent reworking your large pull request 10 times. And reviewing your large pull request 10 times is also not fun.

# Write correct, readable and maintainable code

## Explicitly handle all errors

Error handling usually means logging the error and continuing with a sensible default. For example if you can't read a file, then the best solution would be to write a message to `std.log.err` that states the file path and the error string. It is also fine to bubble up the error with `try` a few levels before handling it.

Not all errors can happen. Specifically in Cubyz the `error.OutOfMemory` cannot happen with the standard allocators (`main.globalAllocator` and `main.stackAllocator`). In this case `catch unreachable` is the right way to handle the error.

### Use (implicit) assertions for programming errors, and std.log.err for user errors

- An addon creator should get a nice error message in the console when they use incorrect parameters and similar.
- The player should get a nice error message in the console when something unexpected (but possible) happens, but the game should try to keep running.
- The programmer (that's you ;) ) should get a stacktrace when they made a mistake. This can be done with `std.debug.assert` or `.?` or `[]` or `unreachable` or `@panic`.

## Choose the right allocator for the job

Cubyz has four main allocators, choose them based on lifetime:
- global lifetime, things that are used until the end of the game (e.g. mod registry data) → `main.globalArena`
- world lifetime, things that are used until the player exits the world (e.g. assets/addons) → `main.worldArena`
- local lifetime, things that are freed at the end of the scope (including local data structures such as lists) → `main.stackAllocator`
- other lifetime → `main.globalAllocator`

Sometimes it might also make sense to use another arena allocator `allocator.create-/destroyArena()` (when you have many small allocations that share the same lifetime, e.g. dynamic structure data in the structure map), or a `MemoryPool` (if you have many items of the same type that get freed and allocated many times throughout the game).

Avoid the use of large stack buffers, the stack allocator is usually fast enough and provides protection against stack overflow. Stack buffers should only be used when there is a clear performance benefit.

Also it is important to note that Cubyz uses a different allocator interface `utils.NeverFailingAllocator` which cannot return `error.OutOfMemory`. Along with it come some data structures like `main.List` and more in `utils` which should be preferred over the standard library data structures because they simplify the code.

## Free all resources

Everything you allocate, needs to be freed.
Everything you init needs to be deinited.
Everything you lock needs to be unlocked.
This needs to be true even for error paths such as introduced by `try`.
Usually you should be fine by using `defer` and `errdefer` (always put them directly after the creation of the thing they are trying to clean to prevent mistakes). There is also leak-checking in debug mode, so make sure you test your feature in debug mode to check for leaks.

## Keep it simple

Often the simplest code is easier to read, easier to maintain and more efficient too.
- Don't generalize things that only have one variant (for now). (unless you are certain that a general interface is needed of course)<br>
  "Premature generalization is the root of all evil" (Knuth almost got it right)
- Use syntax sugar of the language where applicable (like `catch`, `orelse`, `for`, `.{}`, `&.{}`, `inline` case, decl literals)
- If you use the same segment of code multiple times, then it's time to make a helper function
- If a thing already exists in the code base or the standard library, then use it. Noteworthy namespaces are `std.mem`, `std.meta`, `std.math`, `main.utils`.
- Use the simplest data structure for the job: e.g. use a slice instead of List if you know the size upfront
- Don't make things public if they don't need to be

## A note on performance optimizations

I like to follow Casey Muratori's optimization philosophy as outlined here: https://www.youtube.com/watch?v=pgoetgxecw8

The most important optimization technique he mentions is non-pessimization, not needlessly making things worse.
This mostly overlaps with the points from above. Some example for this are:
- use the right data structure (don't force the square block through the circular hole), this may seem trivial, but often as code grows you may find yourself in a situation where the original data structure doesn't really fit anymore
- use the simplest data structure for the job, e.g. Use an array list or circular buffer instead of a linked list or queue
- keep data/object dependencies at a minimum, if you can put things flat into memory or on the stack without a pointer on the heap, then that's simpler and faster.
- use f32 if you don't need the precision of f64
- don't store things as zon if they don't need to be human readable, just use binary
- always lock mutexes in the tightest possible scope

The next important thing is to avoid fake optimizations, if you optimize something you must measure it in a realistic setting (and be mindful about measuring errors: https://www.youtube.com/watch?v=r-TLSBdHe1A ).
Otherwise you may just end up with a more complicated and slower thing.

## Follow the style guide

Most of the syntax is handled by a modified version of zig fmt and checked by the CI (see the formatting section above).

There are a few more things not covered by the formatter:
- **Naming conventions:** camelCase for variables, constants (no all-caps constants please!) and functions; CapitalCamelCase for types; snake_case for files and namespaces. Abbreviations are treated as one word, e.g. zon/ZonElement instead of ZON/ZONElement.
- **Line limit:** There is no line limit (I hate seeing code that gets wrapped over by 1 word, because of an arbitrary line limit), but of course try to be reasonable. If you need 200 characters, then you should probably consider splitting it or adding some well-named helper variables.
- **Comments:** Don't write comments, unless there is something non-obvious going on that needs to be explained.<br>
  But in either case it's better to write readable code with descriptive names, instead of writing long comments, since comments will naturally degrade over time as the surrounding code changes.<br>
  If you do want to write comments, make them explain the why, not the what and not the how.
- **Imports:** Import aliasing is nice (if only ZLS would support it). But please don't import/alias functions. If I see a function then knowing where it's from adds some more context. And if there are no aliases then I can assume that a bare function name is defined locally.<br>
  Imports/aliases should be at the top of the file before any other declarations. Also aliases should always use the same name as the original to avoid confusion (e.g. don't alias `main.stackAllocator` to `allocator`).
- **Files as Structs:** Don't use files as struct unless you have a good reason for it. I've tried it a few times, but generally I don't think it really adds much and in larger files it can be rather confusing.
- **File/Directory organization:** Generally try to split things off that are unrelated, and keep things together that are directly interacting with each other. In my opinion the sweet spot for file size is (very roughly) 1000 lines.<br>
  Instances of a generic interfaces (e.g. GuiWindow, *Generator, Command) should be put into separate files in one directory, since they usually don't have anything in common other than their interface.
- **Order of Declarations:** Generally I prefer seeing things (helper functions and variables) declared before they are used, as is required in languages like C and C++. However I don't really have a strong opinion on this.
  What matters most in my opinion is that related things are close together (e.g. init next to deinit, serialize next to deserialize, helper functions next to where they are used).
- **Magic constants:** All non-trivial constants should have a name to make it clear where they came from (especially important for physical or mathematical constants).
- **Const correctness:** While mostly enforced by the language, please try to make things `const` whenever possible, especially important for pointers. Your first instinct should be to write `const` and only use `var` as the second option.
- **Unused variables:** If you see `_ = ` anywhere then it's most likely a mistake, either in the API or the code itself. Unused function parameters are fine of course, but prefer `_: ` unless you have a good reason to keep the name
- **Parenthesis and operator precedence:** You should know the basics of operator precedence:<br>
  assignment ops < bool ops < compare ops < bitwise ops < shift ops < add/sub < mul/div < unary ops<br>
  Only add parenthesis if you need them. Precedence on the right side of the spectrum (unary and mul/div/mod) is also shown visually (enforced by the formatter) through spacing: `x = -a + b*c` instead of `x = - a + b * c`

# Don't put multiple changes into one pull request

This includes introduction of non-trivial helper functions, refactoring existing code.

**A good PR should be no more than 200 lines!** I may refuse to review larger PRs.

It may seem tempting to bundle up somewhat related features into one pull request. But this often causes unnecessary delays.

Let's say you have 3 features and made a small mistake in one of them.

If you bundle up all 3 features, then because of your small mistake, a review cycle is needed.
But by the time you fixed the mistake, maybe someone else worked on a file you touched and there are merge conflicts. The more changes you bundle into one PR the more likely it is that this happens. This is especially bad if one of your actions is refactoring a bunch of code.
And even if it doesn't happen, now the same code has to be reviewed again in it's entirety.

If instead you make 3 separate PRs, the first two can be merged on the same day, while the last one needs to be edited. The chances of a merge conflict are small, since 2/3 changes are already merged. And code review is also easier, since only the broken code has to be reviewed more than once.

# Check the changes after creating your pull request

With a quick check you can ensure that you didn't add any unintended changes.

With a more thorough review of your changes you can sometimes catch small mistakes, leftover TODOs or random debug code.

And of course make sure to check the CI results, you should also get an e-mail notification if the CI fails. **I will not review a PR if the CI failed!**


```

`docs/GAME_DESIGN_PRINCIPLES.md`:

```md
# Game Design Principles
This document is intended for contributors and may contain spoilers.

## What is Cubyz?
Cubyz is a voxel sandbox game with infinite world and focus on great adventures, immersive exploration with numerous challenges along the way. We cherish freedom and we are determined to give it to the players in abundance, so they can chose their own path through the world.

### Progression
We want to encourage interacting with different mechanics, such as exploring, building, crafting, and etc. Progression therefore encourages the player to interact with all of these systems.
Examples:
- Explore to Build: The player needs to interact with exploration to get the resources they want for building.
- Survive to Explore: Caves and structures may have enemies and traps that the player has to face if they want to explore in peace.
- Strategize to Survive: Prepare for a trip with tools, weapons, and gear in order to make survival easier.
- Build to Strategize: The player has to build defenses for events, invasions, and bosses. They also need to upgrade their workstations to allow for better gear.

## Break the Cycle
### No Dimensions
Instead of creating seperate dimensions, we can fit these places physically into Cubyz' massive world for the player to come across.

### No Teleportation
Teleportation makes the game less immersive, as it diminishes the exploring aspect and doesn't let the player get a good sense of the scale of the world.

### No Automation
Having quick, infinite resources at the palm of players' hands discourages exploration, as the player will never need to forage or search for blocks they desire.

### Mobs Don't Respawn Naturally
Clearing a dangerous area of its monsters will make it safe to build and explore.
This rule is also here to prevent mob farming.

### No Passive Animals
Animals do not want to die, so they will either run from an attacking player or attempt to defend themselves. The player will have to strategize to be able to hunt.

### No Unbreakable Tools
If a player gets too attached to their amazing tool, they won't want to make other types of tools, and low-tier materials will see less use as they will never be used in tool-making.

### Avoid Clutter
Inventories will often fill up with random items that the player does not want, making their inventory hard to manage. To mitigate this, find uses for existing items before adding new ones and prevent items from finding their way into a player's inventory when they don't want it.

### Use Realism Tastefully
Cubyz is not a realistic game. The world is very whimsical and has rules of its own, sometimes inspired by the real world, but never copied without a good reason.

### Avoid Excessive Additions
Unless there is a genuine functional reason for a variant or addition to be added, they should be avoided. Try to use or modify existing content first before creating new stuff.

## Player Engagement
### "How would the player feel?"
Put yourself in the shoes of a player encountering a mechanic for the first time and ask yourself this. The goal is to make the player feel how you want them to, whether that be satisfaction, fear, or intrigue.

### Depth in Simplicity
It's important to remember to keep the game approachable to new players, so appearing simple is key. However, what will keep a player around is the game's depth. Design mechanics around being simple on the surface, but have them able to be expanded upon, upgraded, or customized to meet the player's needs.

### Fuel the Player's Curiosity
Fill the world with secrets that will keep the player interested and engaged with exploration.

### Problems have Multiple Solutions
Problems faced in a particular age of progression should have multiple solutions, instead of just one solution for everything.
For example, in the "Pre-Caves Age," the player will not have access to coal, as coal spawns low in the world and is shrouded in darkness. There's many solutions to this, however:
- Find a dim, above ground light source.
- Search for a cave with exposed coal.
- Wander into the darkness to find a cave that's bright enough to mine in.
- Find an above-ground structure that can grant the player coal.
- Dig straight down until you find coal.

This problem is completely solved as soon as the player gets coal, as they can now explore caves to find more coal with their newfound torches. It's important that the player has these options to prevent them from getting stuck on a seemingly insurmountable barrier. This gives them more freedom in how they can approach the game, as no one option is particularly the best and can change depending on situation and location.

### Explain when Needed
Progress-related mechanics need explanations or subtle hints so players don't get stuck. Keep it simple on the surface so it's easily approachable, but leave out details that the player can find themselves through intuition.

### Embrace Micro Moments
These are tiny things the player does in between larger events; examples include:
- Travelling
- Parkour
- Mining
- Building
- Crafting
- Managing inventory
- Fighting

These moments are extremely important as they largely influence the player's mood, so making sure they're as satisfying and consistent as possible is a must.

### Make the World Feel Alive
To add immersion to the game, creatures should perform behaviors outside of player input, such as hunting, playing, migrating, eating, or sleeping.

## Balancing
When balancing the game, keep in mind how players might interact with the world, the wildlife, and each other.

### 2OP4ME
Players need to be vulnerable at all times to avoid power imbalances. Armor, tools, accessories, and buffs should aid the player, not let them win outright.

### Trade-offs
If the player is given something to aid them, then it should have an appropriate take-away to balance it.

**Examples:**
- Using rare resources to create a strong tool.
- An accessory that heals the player, but takes away energy or some other resource.
- Enemies have strengths and weaknesses towards particular damage types.

## Little Details

### Big Trees vs Small Trees
Big trees are designed to be built upon or left as decoration, whereas small trees are designed to be chopped down.

### Vegetation
Vegetation should fit the biome's climate. For example, Toadstools prefer humid areas, while Boletes prefer nutritious areas. Give some extra thought to the plants you place.

### Caves are Creepy and Mysterious
As the player descends into Cubyz, the music gets scarier, the monsters become more vicious and disturbing, and the cave generation becomes increasingly precarious. Outside of difficulty, this adds stress that the player needs to overcome to gain large rewards.

```

`mods/cubyz/rotation/branch.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec2f = vec.Vec2f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub const dependsOnNeighbors = true;
var branchModels: std.HashMap(HashMapKey, ModelIndex, HashMapKey, std.hash_map.default_max_load_percentage) = undefined;
const HashMapKey = struct {
	radius: u16,
	shellModelId: []const u8,
	textureSlotOffset: u32,

	pub fn hash(_: HashMapKey, val: HashMapKey) u64 {
		var hasher = std.hash.Wyhash.init(0);
		std.hash.autoHashStrat(&hasher, val, .DeepRecursive);
		return hasher.final();
	}
	pub fn eql(_: HashMapKey, val1: HashMapKey, val2: HashMapKey) bool {
		if (val1.radius != val2.radius) return false;
		if (val1.textureSlotOffset != val2.textureSlotOffset) return false;
		return std.mem.eql(u8, val1.shellModelId, val2.shellModelId);
	}
};
pub const BranchData = packed struct(u7) {
	enabledConnections: u6,
	placedByHuman: bool,

	pub inline fn init(blockData: u16) BranchData {
		return @bitCast(@as(u7, @truncate(blockData)));
	}

	pub inline fn isConnected(self: @This(), neighbor: Neighbor) bool {
		return (self.enabledConnections & Neighbor.bitMask(neighbor)) != 0;
	}

	pub inline fn setConnection(self: *@This(), neighbor: Neighbor, value: bool) void {
		if (value) {
			self.enabledConnections |= Neighbor.bitMask(neighbor);
		} else {
			self.enabledConnections &= ~Neighbor.bitMask(neighbor);
		}
	}
};

pub fn init() void {
	branchModels = .initContext(main.globalAllocator.allocator, undefined);
}

pub fn deinit() void {
	branchModels.deinit();
}

pub fn reset() void {
	branchModels.clearRetainingCapacity();
}

pub const Direction = enum(u2) {
	negYDir = 0,
	posXDir = 1,
	posYDir = 2,
	negXDir = 3,
};

const Pattern = union(enum) {
	dot: void,
	halfLine: Direction,
	line: Direction,
	bend: Direction,
	intersection: Direction,
	cross: void,
};

fn rotateQuad(originalCorners: [4]Vec2f, pattern: Pattern, min: f32, max: f32, side: Neighbor, textureSlotOffset: u32) main.models.QuadInfo {
	var corners: [4]Vec2f = originalCorners;

	switch (pattern) {
		.dot, .cross => {},
		inline else => |typ| {
			const angle: f32 = @as(f32, @floatFromInt(@intFromEnum(typ)))*std.math.pi/2.0;
			corners = .{
				vec.rotate2d(originalCorners[0], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[1], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[2], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[3], angle, @splat(0.5)),
			};
		},
	}

	const offX: f32 = @floatFromInt(@intFromBool(@reduce(.Add, side.textureX()) < 0));
	const offY: f32 = @floatFromInt(@intFromBool(@reduce(.Add, side.textureY()) < 0));

	const corners3d = .{
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(corners[0][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(corners[0][1] - offY)),
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(corners[1][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(corners[1][1] - offY)),
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(corners[2][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(corners[2][1] - offY)),
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(corners[3][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(corners[3][1] - offY)),
	};

	const offset: Vec3f = @as(Vec3f, @floatFromInt(@abs(side.relPos())))*@as(Vec3f, @splat(if (side.isPositive()) max else min));

	const res: main.models.QuadInfo = .{
		.corners = .{
			corners3d[0] + offset,
			corners3d[1] + offset,
			corners3d[2] + offset,
			corners3d[3] + offset,
		},
		.cornerUV = .{originalCorners[0], originalCorners[1], originalCorners[2], originalCorners[3]},
		.normal = @as(Vec3f, @floatFromInt(side.relPos())),
		.textureSlot = textureSlotOffset + @intFromEnum(pattern),
	};

	return res;
}

fn addQuads(pattern: Pattern, side: Neighbor, radius: f32, out: *main.List(main.models.QuadInfo), textureSlotOffset: u32) void {
	const min: f32 = (8.0 - radius)/16.0;
	const max: f32 = (8.0 + radius)/16.0;
	switch (pattern) {
		.dot => {
			out.append(rotateQuad(.{
				.{min, min},
				.{min, max},
				.{max, min},
				.{max, max},
			}, pattern, min, max, side, textureSlotOffset));
		},
		.halfLine => {
			out.append(rotateQuad(.{
				.{min, 0.0},
				.{min, max},
				.{max, 0.0},
				.{max, max},
			}, pattern, min, max, side, textureSlotOffset));
		},
		.line => {
			out.append(rotateQuad(.{
				.{min, 0.0},
				.{min, 1.0},
				.{max, 0.0},
				.{max, 1.0},
			}, pattern, min, max, side, textureSlotOffset));
		},
		.bend => {
			out.append(rotateQuad(.{
				.{0.0, 0.0},
				.{0.0, max},
				.{max, 0.0},
				.{max, max},
			}, pattern, min, max, side, textureSlotOffset));
		},
		.intersection => {
			out.append(rotateQuad(.{
				.{0.0, 0.0},
				.{0.0, max},
				.{1.0, 0.0},
				.{1.0, max},
			}, pattern, min, max, side, textureSlotOffset));
		},
		.cross => {
			out.append(rotateQuad(.{
				.{0.0, 0.0},
				.{0.0, 1.0},
				.{1.0, 0.0},
				.{1.0, 1.0},
			}, pattern, min, max, side, textureSlotOffset));
		},
	}
}

pub fn getPattern(data: BranchData, side: Neighbor) ?Pattern {
	const posX = Neighbor.fromRelPos(side.textureX()).?;
	const negX = Neighbor.fromRelPos(side.textureX()).?.reverse();
	const posY = Neighbor.fromRelPos(side.textureY()).?;
	const negY = Neighbor.fromRelPos(side.textureY()).?.reverse();

	const connectedPosX = data.isConnected(posX);
	const connectedNegX = data.isConnected(negX);
	const connectedPosY = data.isConnected(posY);
	const connectedNegY = data.isConnected(negY);

	const count: u6 = @as(u6, @intFromBool(connectedPosX)) + @as(u6, @intFromBool(connectedNegX)) + @as(u6, @intFromBool(connectedPosY)) + @as(u6, @intFromBool(connectedNegY));

	return switch (count) {
		0 => {
			if (data.isConnected(side)) {
				return null;
			}

			return .dot;
		},
		1 => {
			var dir: Direction = .negXDir;
			if (connectedNegY) {
				dir = .negYDir;
			} else if (connectedPosX) {
				dir = .posXDir;
			} else if (connectedPosY) {
				dir = .posYDir;
			}
			return .{.halfLine = dir};
		},
		2 => {
			if ((connectedPosX and connectedNegX) or (connectedPosY and connectedNegY)) {
				var dir: Direction = .negYDir;
				if (connectedPosX and connectedNegX) {
					dir = .posXDir;
				}

				return .{.line = dir};
			}

			var dir: Direction = .negXDir;

			if (connectedNegY) {
				dir = .negYDir;
				if (connectedPosX) {
					dir = .posXDir;
				}
			} else if (connectedPosX) {
				dir = .posXDir;
				if (connectedPosY) {
					dir = .posYDir;
				}
			} else if (connectedPosY) {
				dir = .posYDir;
				if (connectedNegX) {
					dir = .negXDir;
				}
			}

			return .{.bend = dir};
		},
		3 => {
			var dir: Direction = undefined;
			if (!connectedPosY) dir = .negYDir;
			if (!connectedNegX) dir = .posXDir;
			if (!connectedNegY) dir = .posYDir;
			if (!connectedPosX) dir = .negXDir;

			return .{.intersection = dir};
		},
		4 => {
			return .cross;
		},
		else => undefined,
	};
}

pub fn createBlockModel(_: Block, modeData: *u16, zon: ZonElement) ModelIndex {
	var radius = zon.get(f32, "radius", 4);
	const radiusForComparisons = std.math.lossyCast(u16, @round(radius*65536.0/16.0));
	radius = @as(f32, @floatFromInt(radiusForComparisons))*16.0/65536.0;
	modeData.* = radiusForComparisons;
	const shellModelId = zon.get([]const u8, "shellModel", "");
	const textureSlotOffset = zon.get(u32, "textureSlotOffset", 0);
	if (branchModels.get(.{.radius = radiusForComparisons, .shellModelId = shellModelId, .textureSlotOffset = textureSlotOffset})) |modelIndex| return modelIndex;

	var shellQuads = main.List(main.models.QuadInfo).init(main.stackAllocator);
	defer shellQuads.deinit();
	if (shellModelId.len != 0) {
		const shellModel = main.models.getModelIndex(shellModelId).model();
		shellModel.getRawFaces(&shellQuads);
	}

	var modelIndex: ModelIndex = undefined;
	for (0..64) |i| {
		var quads = main.List(main.models.QuadInfo).init(main.stackAllocator);
		defer quads.deinit();
		quads.appendSlice(shellQuads.items);

		for (Neighbor.iterable) |neighbor| {
			const pattern = getPattern(BranchData.init(@intCast(i)), neighbor);

			if (pattern) |pat| {
				addQuads(pat, neighbor, radius, &quads, textureSlotOffset);
			}
		}

		const index = main.models.Model.init(quads.items);
		if (i == 0) {
			modelIndex = index;
		}
	}

	branchModels.put(.{.radius = radiusForComparisons, .shellModelId = shellModelId, .textureSlotOffset = textureSlotOffset}, modelIndex) catch unreachable;

	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(block.data & 63);
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	@setEvalBranchQuota(65_536);

	comptime var rotationTable: [4][16]u8 = undefined;
	comptime for (0..16) |i| {
		rotationTable[0][i] = @intCast(i << 2);
	};
	comptime for (1..4) |a| {
		for (0..16) |i| {
			const old: BranchData = .init(rotationTable[a - 1][i]);
			var new: BranchData = .init(0);

			new.setConnection(Neighbor.dirPosX.rotateZ(), old.isConnected(Neighbor.dirPosX));
			new.setConnection(Neighbor.dirNegX.rotateZ(), old.isConnected(Neighbor.dirNegX));
			new.setConnection(Neighbor.dirPosY.rotateZ(), old.isConnected(Neighbor.dirPosY));
			new.setConnection(Neighbor.dirNegY.rotateZ(), old.isConnected(Neighbor.dirNegY));

			rotationTable[a][i] = new.enabledConnections;
		}
	};
	if (data > 0b111111) return 0;
	const rotationIndex = (data & 0b111100) >> 2;
	const upDownFlags = data & 0b000011;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][rotationIndex] | upDownFlags;
}

pub fn generateData(
	_: *main.game.World,
	_: Vec3i,
	_: Vec3f,
	_: Vec3f,
	_: Vec3i,
	neighbor: ?Neighbor,
	currentBlock: *Block,
	neighborBlock: Block,
	blockPlacing: bool,
) bool {
	const canConnectToNeighbor = currentBlock.mode() == neighborBlock.mode() and currentBlock.modeData() == neighborBlock.modeData();

	if (blockPlacing or canConnectToNeighbor or !neighborBlock.replacable()) {
		const neighborModel = blocks.meshes.model(neighborBlock).model();

		var currentData = BranchData.init(currentBlock.data);
		// Branch block upon placement should extend towards a block it was placed
		// on if the block is solid or also uses branch model.
		const targetVal = ((!neighborBlock.replacable() and (!neighborBlock.viewThrough() or canConnectToNeighbor)) and (canConnectToNeighbor or neighborModel.isNeighborOccluded[neighbor.?.reverse().toInt()]));
		currentData.setConnection(neighbor.?, targetVal);

		currentData.placedByHuman = true;
		const result: u7 = @bitCast(currentData);
		if (result == currentBlock.data) return false;

		currentBlock.data = result;
		return true;
	}
	return false;
}

pub fn updateData(block: *Block, neighbor: Neighbor, neighborBlock: Block) bool {
	const canConnectToNeighbor = block.mode() == neighborBlock.mode() and block.modeData() == neighborBlock.modeData();
	var currentData = BranchData.init(block.data);

	// Handle joining with other branches. While placed, branches extend in a
	// opposite direction than they were placed from, effectively connecting
	// to the block they were placed at.
	if (canConnectToNeighbor) {
		const neighborData = BranchData.init(neighborBlock.data);
		currentData.setConnection(neighbor, neighborData.isConnected(neighbor.reverse()));
	} else if (neighborBlock.replacable()) {
		currentData.setConnection(neighbor, false);
	}

	const result: u7 = @bitCast(currentData);
	if (result == block.data) return false;

	block.data = result;
	return true;
}

fn closestRay(block: Block, relativePlayerPos: Vec3f, playerDir: Vec3f) ?u16 {
	var closestIntersectionDistance: f64 = std.math.inf(f64);
	var resultBitMask: ?u16 = null;
	{
		const modelIndex = blocks.meshes.modelIndexStart(block);
		if (RotationMode.DefaultFunctions.rayModelIntersection(modelIndex, relativePlayerPos, playerDir)) |intersection| {
			closestIntersectionDistance = intersection.distance;
			resultBitMask = 0;
		}
	}
	for (Neighbor.iterable) |direction| {
		const directionBitMask = Neighbor.bitMask(direction);

		if ((block.data & directionBitMask) != 0) {
			const modelIndex: ModelIndex = blocks.meshes.modelIndexStart(block).add(directionBitMask);
			if (RotationMode.DefaultFunctions.rayModelIntersection(modelIndex, relativePlayerPos, playerDir)) |intersection| {
				if (@abs(closestIntersectionDistance) > @abs(intersection.distance)) {
					closestIntersectionDistance = intersection.distance;
					resultBitMask = direction.bitMask();
				}
			}
		}
	}
	return resultBitMask;
}

pub fn onBlockBreaking(_: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f, currentData: *Block) void {
	if (closestRay(currentData.*, relativePlayerPos, playerDir)) |directionBitMask| {
		// If player destroys a central part of branch block, branch block is completely destroyed.
		if (directionBitMask == 0) {
			currentData.typ = 0;
			currentData.data = 0;
			return;
		}
		// Otherwise only the connection player aimed at is destroyed.
		currentData.data &= ~directionBitMask;
	}
}

```

`mods/cubyz/rotation/carpet.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RayIntersectionResult = rotation.RayIntersectionResult;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

const torch = @import("torch.zig");

pub const naturalStandard: u16 = 0b10000;
var rotatedModels: std.StringHashMap(ModelIndex) = undefined;
const CarpetData = packed struct(u6) {
	negX: bool,
	posX: bool,
	negY: bool,
	posY: bool,
	negZ: bool,
	posZ: bool,
};

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	comptime var rotationTable: [4][64]u8 = undefined;
	comptime for (0..64) |i| {
		rotationTable[0][i] = @intCast(i);
	};
	comptime for (1..4) |a| {
		for (0..64) |i| {
			const old: CarpetData = @bitCast(@as(u6, @intCast(rotationTable[a - 1][i])));
			const new: CarpetData = .{
				.posZ = old.posZ,
				.negZ = old.negZ,
				.posY = old.posX,
				.negY = old.negX,
				.negX = old.posY,
				.posX = old.negY,
			};
			rotationTable[a][i] = @as(u6, @bitCast(new));
		}
	};
	if (data >= 64) return 0;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][data];
}

pub fn init() void {
	rotatedModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	rotatedModels.deinit();
}

pub fn reset() void {
	rotatedModels.clearRetainingCapacity();
}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const modelId = zon.as([]const u8, "cubyz:cube");
	if (rotatedModels.get(modelId)) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex(modelId).model();
	// Rotate the model:
	var negXModel: ModelIndex = undefined;
	var posXModel: ModelIndex = undefined;
	var negYModel: ModelIndex = undefined;
	var posYModel: ModelIndex = undefined;
	var negZModel: ModelIndex = undefined;
	var posZModel: ModelIndex = undefined;
	for (1..64) |i| {
		const carpetData: CarpetData = @bitCast(@as(u6, @intCast(i)));
		if (i & i - 1 == 0) {
			if (carpetData.negX) negXModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(-std.math.pi/2.0).mul(Mat4f.rotationX(-std.math.pi/2.0))});
			if (carpetData.posX) posXModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi/2.0).mul(Mat4f.rotationX(-std.math.pi/2.0))});
			if (carpetData.negY) negYModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationX(-std.math.pi/2.0)});
			if (carpetData.posY) posYModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi).mul(Mat4f.rotationX(-std.math.pi/2.0))});
			if (carpetData.negZ) negZModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
			if (carpetData.posZ) posZModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationY(std.math.pi)});
		} else {
			var models: [6]ModelIndex = undefined;
			var amount: usize = 0;
			if (carpetData.negX) {
				models[amount] = negXModel;
				amount += 1;
			}
			if (carpetData.posX) {
				models[amount] = posXModel;
				amount += 1;
			}
			if (carpetData.negY) {
				models[amount] = negYModel;
				amount += 1;
			}
			if (carpetData.posY) {
				models[amount] = posYModel;
				amount += 1;
			}
			if (carpetData.negZ) {
				models[amount] = negZModel;
				amount += 1;
			}
			if (carpetData.posZ) {
				models[amount] = posZModel;
				amount += 1;
			}
			_ = main.models.Model.mergeModels(models[0..amount]);
		}
	}
	const modelIndex = negXModel;
	rotatedModels.put(modelId, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(@as(u6, @truncate(block.data)) -| 1);
}

pub fn generateData(_: *main.game.World, _: Vec3i, relativePlayerPos: Vec3f, playerDir: Vec3f, relativeDir: Vec3i, _: ?Neighbor, currentData: *Block, neighbor: Block, _: bool) bool {
	if (neighbor.mode() == currentData.mode()) parallelPlacing: {
		const bit = closestRay(.bit, neighbor, .null, relativePlayerPos - @as(Vec3f, @floatFromInt(relativeDir)), playerDir);
		const bitData: CarpetData = @bitCast(@as(u6, @truncate(bit)));
		if ((bitData.negX or bitData.posX) and relativeDir[0] != 0) break :parallelPlacing;
		if ((bitData.negY or bitData.posY) and relativeDir[1] != 0) break :parallelPlacing;
		if ((bitData.negZ or bitData.posZ) and relativeDir[2] != 0) break :parallelPlacing;
		if (currentData.data & bit == bit) return false;
		currentData.data |= bit;
		return true;
	}
	var data: CarpetData = @bitCast(@as(u6, @truncate(currentData.data)));
	if (relativeDir[0] == 1) data.posX = true;
	if (relativeDir[0] == -1) data.negX = true;
	if (relativeDir[1] == 1) data.posY = true;
	if (relativeDir[1] == -1) data.negY = true;
	if (relativeDir[2] == 1) data.posZ = true;
	if (relativeDir[2] == -1) data.negZ = true;
	if (@as(u6, @bitCast(data)) != currentData.data) {
		currentData.data = @as(u6, @bitCast(data));
		return true;
	} else {
		return false;
	}
}

fn closestRay(comptime typ: enum { bit, intersection }, block: Block, _: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) if (typ == .intersection) ?RayIntersectionResult else u16 {
	var result: ?RayIntersectionResult = null;
	var resultBit: u16 = 0;
	for ([_]u16{1, 2, 4, 8, 16, 32}) |bit| {
		if (block.data & bit != 0) {
			const modelIndex: ModelIndex = blocks.meshes.modelIndexStart(block).add(bit - 1);
			if (RotationMode.DefaultFunctions.rayModelIntersection(modelIndex, relativePlayerPos, playerDir)) |intersection| {
				if (result == null or result.?.distance > intersection.distance) {
					result = intersection;
					resultBit = bit;
				}
			}
		}
	}
	if (typ == .bit) return resultBit;
	return result;
}

pub fn rayIntersection(block: Block, item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) ?RayIntersectionResult {
	return closestRay(.intersection, block, item, relativePlayerPos, playerDir);
}

pub fn onBlockBreaking(item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f, currentData: *Block) void {
	const bit = closestRay(.bit, currentData.*, item, relativePlayerPos, playerDir);
	currentData.data &= ~bit;
	if (currentData.data == 0) currentData.typ = 0;
}

pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) RotationMode.CanBeChangedInto {
	return torch.canBeChangedInto(oldBlock, newBlock, item, shouldDropSourceBlockOnSuccess);
}

pub fn itemDropsOnChange(oldBlock: Block, newBlock: Block) u16 {
	if (newBlock.typ != oldBlock.typ) return @popCount(oldBlock.data);
	return @popCount(oldBlock.data) -| @popCount(newBlock.data);
}

// MARK: non-interface fns

pub fn updateBlockFromNeighborConnectivity(block: *Block, neighborSupportive: [6]bool) void {
	var data: CarpetData = @bitCast(@as(u6, @truncate(block.data)));
	if (!neighborSupportive[Neighbor.dirNegX.toInt()]) data.negX = false;
	if (!neighborSupportive[Neighbor.dirPosX.toInt()]) data.posX = false;
	if (!neighborSupportive[Neighbor.dirNegY.toInt()]) data.negY = false;
	if (!neighborSupportive[Neighbor.dirPosY.toInt()]) data.posY = false;
	if (!neighborSupportive[Neighbor.dirDown.toInt()]) data.negZ = false;
	if (!neighborSupportive[Neighbor.dirUp.toInt()]) data.posZ = false;
	block.data = @as(u6, @bitCast(data));
	if (block.data == 0) block.* = .air;
}

```

`mods/cubyz/rotation/decayable.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RayIntersectionResult = rotation.RayIntersectionResult;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub fn init() void {}
pub fn deinit() void {}
pub fn reset() void {}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, _: ?Neighbor, block: *Block, _: Block, blockPlacing: bool) bool {
	if (blockPlacing) {
		block.data = 1;
	}
	return blockPlacing;
}

```

`mods/cubyz/rotation/direction.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

var rotatedModels: std.StringHashMap(ModelIndex) = undefined;

pub fn init() void {
	rotatedModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	rotatedModels.deinit();
}

pub fn reset() void {
	rotatedModels.clearRetainingCapacity();
}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const modelId = zon.as([]const u8, "cubyz:cube");
	if (rotatedModels.get(modelId)) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex(modelId).model();
	// Rotate the model:
	const modelIndex = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationY(std.math.pi)});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(-std.math.pi/2.0).mul(Mat4f.rotationX(-std.math.pi/2.0))});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi/2.0).mul(Mat4f.rotationX(-std.math.pi/2.0))});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationX(-std.math.pi/2.0)});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi).mul(Mat4f.rotationX(-std.math.pi/2.0))});
	rotatedModels.put(modelId, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(@min(block.data, 5));
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	comptime var rotationTable: [4][6]u8 = undefined;
	comptime for (0..6) |i| {
		rotationTable[0][i] = i;
	};
	comptime for (1..4) |a| {
		for (0..6) |i| {
			const neighbor: Neighbor = @enumFromInt(rotationTable[a - 1][i]);
			rotationTable[a][i] = neighbor.rotateZ().toInt();
		}
	};
	if (data >= 6) return 0;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][data];
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, neighbor: ?Neighbor, currentData: *Block, _: Block, blockPlacing: bool) bool {
	if (blockPlacing) {
		currentData.data = neighbor.?.reverse().toInt();
		return true;
	}
	return false;
}

// MARK: non-interface fns

pub fn updateBlockFromNeighborConnectivity(block: *Block, neighborSupportive: [6]bool) void {
	if (block.data >= 6) return;
	if (!neighborSupportive[@as(Neighbor, @enumFromInt(block.data)).reverse().toInt()]) block.* = .air;
}

```

`mods/cubyz/rotation/fence.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub const dependsOnNeighbors = true;
var fenceModels: std.StringHashMap(ModelIndex) = undefined;
const FenceData = packed struct(u4) {
	isConnectedNegX: bool,
	isConnectedPosX: bool,
	isConnectedNegY: bool,
	isConnectedPosY: bool,
};

pub fn init() void {
	fenceModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	fenceModels.deinit();
}

pub fn reset() void {
	fenceModels.clearRetainingCapacity();
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	comptime var rotationTable: [4][16]u8 = undefined;
	comptime for (0..16) |i| {
		rotationTable[0][i] = @intCast(i);
	};
	comptime for (1..4) |a| {
		for (0..16) |i| {
			const old: FenceData = @bitCast(@as(u4, @intCast(rotationTable[a - 1][i])));
			const new: FenceData = .{
				.isConnectedNegY = old.isConnectedNegX,
				.isConnectedPosY = old.isConnectedPosX,
				.isConnectedPosX = old.isConnectedNegY,
				.isConnectedNegX = old.isConnectedPosY,
			};
			rotationTable[a][i] = @as(u4, @bitCast(new));
		}
	};
	if (data >= 16) return 0;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][data];
}

fn fenceTransform(quad: *main.models.QuadInfo, data: FenceData) void {
	for (&quad.corners, &quad.cornerUV) |*corner, *cornerUV| {
		if (!data.isConnectedNegX and corner[0] == 0) {
			corner[0] = 0.5;
			cornerUV[0] = 0.5;
		}
		if (!data.isConnectedPosX and corner[0] == 1) {
			corner[0] = 0.5;
			cornerUV[0] = 0.5;
		}
		if (!data.isConnectedNegY and corner[1] == 0) {
			corner[1] = 0.5;
			if (@abs(quad.normal[2]) > 0.7) {
				cornerUV[1] = 0.5;
			} else {
				cornerUV[0] = 0.5;
			}
		}
		if (!data.isConnectedPosY and corner[1] == 1) {
			corner[1] = 0.5;
			if (@abs(quad.normal[2]) > 0.7) {
				cornerUV[1] = 0.5;
			} else {
				cornerUV[0] = 0.5;
			}
		}
	}
}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const modelId = zon.as([]const u8, "cubyz:cube");
	if (fenceModels.get(modelId)) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex(modelId).model();
	// Rotate the model:
	const modelIndex: ModelIndex = baseModel.transformModel(fenceTransform, .{@as(FenceData, @bitCast(@as(u4, 0)))});
	for (1..16) |fenceData| {
		_ = baseModel.transformModel(fenceTransform, .{@as(FenceData, @bitCast(@as(u4, @intCast(fenceData))))});
	}
	fenceModels.put(modelId, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(block.data & 15);
}

pub fn updateData(block: *Block, neighbor: Neighbor, neighborBlock: Block) bool {
	const blockBaseModelIndex = blocks.meshes.modelIndexStart(block.*);
	const neighborBaseModelIndex = blocks.meshes.modelIndexStart(neighborBlock);
	const neighborModel = blocks.meshes.model(neighborBlock).model();
	const targetVal = !neighborBlock.replacable() and !neighborBlock.transparent() and (blockBaseModelIndex == neighborBaseModelIndex or neighborModel.isNeighborOccluded[neighbor.reverse().toInt()]);
	var currentData: FenceData = @bitCast(@as(u4, @truncate(block.data)));
	switch (neighbor) {
		.dirNegX => {
			currentData.isConnectedNegX = targetVal;
		},
		.dirPosX => {
			currentData.isConnectedPosX = targetVal;
		},
		.dirNegY => {
			currentData.isConnectedNegY = targetVal;
		},
		.dirPosY => {
			currentData.isConnectedPosY = targetVal;
		},
		else => {},
	}
	const result: u16 = @as(u4, @bitCast(currentData));
	if (result == block.data) return false;
	block.data = result;
	return true;
}

```

`mods/cubyz/rotation/hanging.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub const dependsOnNeighbors = true;

fn transform(_: *main.models.QuadInfo) void {}

pub fn init() void {}
pub fn deinit() void {}
pub fn reset() void {}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const topModelIndex = main.models.getModelIndex(zon.get([]const u8, "top", "cubyz:cube"));
	const bottomModelIndex = main.models.getModelIndex(zon.get([]const u8, "bottom", "cubyz:cube"));

	const modelIndex = topModelIndex.model().transformModel(transform, .{});
	_ = bottomModelIndex.model().transformModel(transform, .{});
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(block.data%2);
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, neighbor: ?Neighbor, currentData: *Block, neighborBlock: Block, blockPlacing: bool) bool {
	const sameBlock = neighborBlock.typ == currentData.typ;
	if (blockPlacing) {
		if (neighbor != Neighbor.dirUp) return false;
		if (!sameBlock) {
			const neighborModel = neighborBlock.mode().model(neighborBlock).model();
			const support = !neighborBlock.replacable() and neighborModel.neighborFacingQuads[Neighbor.dirDown.toInt()].len != 0;
			if (!support) return false;
		}
		currentData.data = 1;
		return true;
	}
	return false;
}

pub fn updateData(block: *Block, neighbor: Neighbor, neighborBlock: Block) bool {
	if (neighbor != .dirDown) return false;

	const newData: u16 = if (neighborBlock.typ == block.typ) 0 else 1;

	if (newData == block.data) return false;
	block.data = newData;
	return true;
}

```

`mods/cubyz/rotation/log.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec2f = vec.Vec2f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;
const branch = @import("branch.zig");

pub const dependsOnNeighbors = true;

var modelIndex: ?ModelIndex = null;

const LogData = branch.BranchData;

pub fn init() void {}

pub fn deinit() void {}

pub fn reset() void {
	modelIndex = null;
}

const DirectionWithSign = branch.Direction;

const DirectionWithoutSign = enum(u1) {
	y = 0,
	x = 1,

	fn fromBranchDirection(dir: DirectionWithSign) DirectionWithoutSign {
		return switch (dir) {
			.negYDir => .y,
			.posXDir => .x,
			.posYDir => .y,
			.negXDir => .x,
		};
	}
};

const Pattern = union(enum) {
	dot: void,
	line: DirectionWithoutSign,
	bend: DirectionWithSign,
	intersection: DirectionWithSign,
	cross: void,
	cut: void,
};

fn rotateQuad(pattern: Pattern, side: Neighbor) main.models.QuadInfo {
	const originalCorners: [4]Vec2f = .{
		.{0, 0},
		.{0, 1},
		.{1, 0},
		.{1, 1},
	};
	var corners: [4]Vec2f = originalCorners;

	switch (pattern) {
		.dot, .cross, .cut => {},
		.line => |dir| {
			var angle: f32 = @as(f32, @floatFromInt(@intFromEnum(dir)))*std.math.pi/2.0;
			if (side.relZ() != 0) {
				angle *= -1;
			}
			if (side.isPositive()) {
				angle *= -1;
			}
			if (side.relY() != 0) {
				angle *= -1;
			}
			corners = .{
				vec.rotate2d(originalCorners[0], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[1], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[2], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[3], angle, @splat(0.5)),
			};
		},
		.bend, .intersection => |dir| {
			corners = originalCorners;

			const angle: f32 = -@as(f32, @floatFromInt(@intFromEnum(dir)))*std.math.pi/2.0;
			corners = .{
				vec.rotate2d(originalCorners[0], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[1], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[2], angle, @splat(0.5)),
				vec.rotate2d(originalCorners[3], angle, @splat(0.5)),
			};
		},
	}

	const offX: f32 = @floatFromInt(@intFromBool(@reduce(.Add, side.textureX()) < 0));
	const offY: f32 = @floatFromInt(@intFromBool(@reduce(.Add, side.textureY()) < 0));

	const corners3d = .{
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(originalCorners[0][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(originalCorners[0][1] - offY)),
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(originalCorners[1][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(originalCorners[1][1] - offY)),
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(originalCorners[2][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(originalCorners[2][1] - offY)),
		@as(Vec3f, @floatFromInt(side.textureX()))*@as(Vec3f, @splat(originalCorners[3][0] - offX)) + @as(Vec3f, @floatFromInt(side.textureY()))*@as(Vec3f, @splat(originalCorners[3][1] - offY)),
	};

	const offset: Vec3f = @floatFromInt(@intFromBool(side.relPos() == Vec3i{1, 1, 1}));

	const res: main.models.QuadInfo = .{
		.corners = .{
			corners3d[0] + offset,
			corners3d[1] + offset,
			corners3d[2] + offset,
			corners3d[3] + offset,
		},
		.cornerUV = .{corners[0], corners[1], corners[2], corners[3]},
		.normal = @as(Vec3f, @floatFromInt(side.relPos())),
		.textureSlot = @intFromEnum(pattern),
	};

	return res;
}

fn getPattern(data: LogData, side: Neighbor) Pattern {
	if (data.isConnected(side)) {
		return .cut;
	}

	const pattern = branch.getPattern(data, side).?;

	switch (pattern) {
		.dot => {
			return .dot;
		},
		.halfLine => |dir| {
			return .{.line = .fromBranchDirection(dir)};
		},
		.line => |dir| {
			return .{.line = .fromBranchDirection(dir)};
		},
		.bend => |dir| {
			return .{.bend = dir};
		},
		.intersection => |dir| {
			return .{.intersection = dir};
		},
		.cross => {
			return .cross;
		},
	}
}

pub fn createBlockModel(_: Block, _: *u16, _: ZonElement) ModelIndex {
	if (modelIndex) |idx| return idx;

	for (0..64) |i| {
		var quads = main.List(main.models.QuadInfo).init(main.stackAllocator);
		defer quads.deinit();

		const data = LogData.init(@intCast(i));

		for (Neighbor.iterable) |neighbor| {
			const pattern = getPattern(data, neighbor);

			quads.append(rotateQuad(pattern, neighbor));
		}

		const index = main.models.Model.init(quads.items);
		if (i == 0) {
			modelIndex = index;
		}
	}

	return modelIndex.?;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(block.data & 63);
}

pub const rotateZ = branch.rotateZ;

pub fn generateData(
	_: *main.game.World,
	pos: Vec3i,
	_: Vec3f,
	_: Vec3f,
	_: Vec3i,
	neighbor: ?Neighbor,
	currentBlock: *Block,
	neighborBlock: Block,
	blockPlacing: bool,
) bool {
	const canConnectToNeighbor = currentBlock.mode() == neighborBlock.mode();

	if (blockPlacing or canConnectToNeighbor or !neighborBlock.replacable()) {
		const neighborModel = blocks.meshes.model(neighborBlock).model();

		var currentData = LogData.init(currentBlock.data);
		// Log block upon placement should extend towards a block it was placed
		// on if the block is solid or also uses log model.
		const targetVal = ((!neighborBlock.replacable() and (!neighborBlock.viewThrough() or canConnectToNeighbor)) and (canConnectToNeighbor or neighborModel.isNeighborOccluded[neighbor.?.reverse().toInt()]));
		currentData.setConnection(neighbor.?, targetVal);

		for (Neighbor.iterable) |side| {
			if (side == neighbor.?) {
				continue;
			}

			const sidePos = pos + side.relPos();
			const sideBlock = main.renderer.mesh_storage.getBlockFromRenderThread(sidePos[0], sidePos[1], sidePos[2]) orelse continue;
			const canConnectToSide = currentBlock.mode() == sideBlock.mode() and currentBlock.modeData() == sideBlock.modeData();

			if (canConnectToSide) {
				const sideData = LogData.init(sideBlock.data);
				currentData.setConnection(side, sideData.isConnected(side.reverse()));
			}
		}

		currentBlock.data = currentData.enabledConnections;
		return true;
	}
	return false;
}

pub fn updateData(block: *Block, neighbor: Neighbor, neighborBlock: Block) bool {
	const canConnectToNeighbor = block.mode() == neighborBlock.mode();
	var currentData = LogData.init(block.data);

	// Handle joining with other logs. While placed, logs extend in a
	// opposite direction than they were placed from, effectively connecting
	// to the block they were placed at.
	if (canConnectToNeighbor) {
		const neighborData = LogData.init(neighborBlock.data);
		currentData.setConnection(neighbor, neighborData.isConnected(neighbor.reverse()));
	}

	const result: u16 = currentData.enabledConnections;
	if (result == block.data) return false;

	block.data = result;
	return true;
}

```

`mods/cubyz/rotation/no_rotation.zig`:

```zig
const main = @import("main");
const Block = main.blocks.Block;
const Neighbor = main.chunk.Neighbor;

pub fn init() void {}
pub fn deinit() void {}
pub fn reset() void {}

// MARK: non-interface fns

pub fn updateBlockFromNeighborConnectivity(block: *Block, neighborSupportive: [6]bool) void {
	if (!neighborSupportive[Neighbor.dirDown.toInt()]) block.* = .air;
}

```

`mods/cubyz/rotation/ore.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RayIntersectionResult = rotation.RayIntersectionResult;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

var modelCache: ?ModelIndex = null;

pub fn init() void {}
pub fn deinit() void {}
pub fn reset() void {
	modelCache = null;
}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const modelId = zon.as([]const u8, "cubyz:cube");
	if (!std.mem.eql(u8, modelId, "cubyz:cube")) {
		std.log.err("Ores can only be use on cube models, found '{s}'", .{modelId});
	}
	if (modelCache) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex("cubyz:cube").model();
	var quadList = main.List(main.models.QuadInfo).init(main.stackAllocator);
	defer quadList.deinit();
	baseModel.getRawFaces(&quadList);
	const len = quadList.items.len;
	for (0..len) |i| {
		quadList.append(quadList.items[i]);
		quadList.items[i + len].textureSlot += 16;
		quadList.items[i].opaqueInLod = 2;
	}
	const modelIndex = main.models.Model.init(quadList.items);
	modelCache = modelIndex;
	return modelIndex;
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, _: ?Neighbor, _: *Block, _: Block, _: bool) bool {
	return false;
}

pub fn modifyBlock(block: *Block, newBlockType: u16) bool {
	if (block.transparent() or block.viewThrough()) return false;
	if (!main.blocks.meshes.modelIndexStart(block.*).model().allNeighborsOccluded) return false;
	if (block.data != 0) return false;
	block.data = block.typ;
	block.typ = newBlockType;
	return true;
}

pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, _: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) RotationMode.CanBeChangedInto {
	if (oldBlock == newBlock) return .no;
	if (oldBlock.transparent() or oldBlock.viewThrough()) return .no;
	if (!main.blocks.meshes.modelIndexStart(oldBlock).model().allNeighborsOccluded) return .no;
	if (oldBlock.data != 0) return .no;
	if (newBlock.data != oldBlock.typ) return .no;
	shouldDropSourceBlockOnSuccess.* = false;
	return .{.yes_costsItems = 1};
}

pub fn onBlockBreaking(_: main.items.Item, _: Vec3f, _: Vec3f, currentData: *Block) void {
	currentData.typ = currentData.data;
	currentData.data = 0;
}

```

`mods/cubyz/rotation/planar.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

var rotatedModels: std.StringHashMap(ModelIndex) = undefined;

pub fn init() void {
	rotatedModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	rotatedModels.deinit();
}

pub fn reset() void {
	rotatedModels.clearRetainingCapacity();
}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const modelId = zon.as([]const u8, "cubyz:cube");
	if (rotatedModels.get(modelId)) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex(modelId).model();
	// Rotate the model:
	const modelIndex: ModelIndex = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi/2.0)});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(-std.math.pi/2.0)});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi)});
	_ = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
	rotatedModels.put(modelId, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(@min(block.data, 3));
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	comptime var rotationTable: [4][4]u8 = undefined;
	comptime for (0..4) |i| {
		rotationTable[0][i] = i;
	};
	comptime for (1..4) |a| {
		for (0..4) |i| {
			const neighbor: Neighbor = @enumFromInt(rotationTable[a - 1][i] + 2);
			rotationTable[a][i] = neighbor.rotateZ().toInt() - 2;
		}
	};
	if (data >= 4) return 0;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][data];
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, playerDir: Vec3f, _: Vec3i, _: ?Neighbor, currentData: *Block, _: Block, blockPlacing: bool) bool {
	if (blockPlacing) {
		if (@abs(playerDir[0]) > @abs(playerDir[1])) {
			const dir: Neighbor = if (playerDir[0] < 0) .dirNegX else .dirPosX;
			currentData.data = dir.toInt() - 2;
		} else {
			const dir: Neighbor = if (playerDir[1] < 0) .dirNegY else .dirPosY;
			currentData.data = dir.toInt() - 2;
		}
		return true;
	}
	return false;
}

// MARK: non-interface fns

pub fn updateBlockFromNeighborConnectivity(block: *Block, neighborSupportive: [6]bool) void {
	if (!neighborSupportive[Neighbor.dirDown.toInt()]) block.* = .air;
}

```

`mods/cubyz/rotation/sign.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RayIntersectionResult = rotation.RayIntersectionResult;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub const naturalStandard: u16 = 0;
var rotatedModels: std.StringHashMap(ModelIndex) = undefined;

pub fn init() void {
	rotatedModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	rotatedModels.deinit();
}

pub fn reset() void {
	rotatedModels.clearRetainingCapacity();
}

const centerRotations = 8;
const sideRotations = 4;

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const floorModelId: []const u8 = zon.get([]const u8, "floor", "cubyz:cube");
	const sideModelId: []const u8 = zon.get([]const u8, "side", "cubyz:cube");
	const ceilingModelId: []const u8 = zon.get([]const u8, "ceiling", "cubyz:cube");
	const key: []const u8 = std.mem.concat(main.stackAllocator.allocator, u8, &.{floorModelId, sideModelId, ceilingModelId}) catch unreachable;
	defer main.stackAllocator.free(key);

	if (rotatedModels.get(key)) |modelIndex| return modelIndex;

	const floorModel = main.models.getModelIndex(floorModelId).model();
	const sideModel = main.models.getModelIndex(sideModelId).model();
	const ceilingModel = main.models.getModelIndex(ceilingModelId).model();
	var modelIndex: ModelIndex = undefined;
	// Rotate the model:
	for (0..centerRotations) |i| {
		const index = floorModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(@as(f32, @floatFromInt(i))*2.0*std.math.pi/centerRotations)});
		if (i == 0) modelIndex = index;
	}
	for (0..centerRotations) |i| {
		_ = ceilingModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(@as(f32, @floatFromInt(i))*2.0*std.math.pi/centerRotations)});
	}
	for (0..sideRotations) |i| {
		_ = sideModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(@as(f32, @floatFromInt(i))*2.0*std.math.pi/sideRotations)});
	}
	rotatedModels.put(key, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(@min(centerRotations*2 + sideRotations - 1, block.data));
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	const rotationTable: [4][2*centerRotations + sideRotations]u8 = .{
		.{
			0,  1,  2,  3,  4,  5,  6,  7,
			8,  9,  10, 11, 12, 13, 14, 15,
			16, 17, 18, 19,
		},
		.{
			2,  3,  4,  5,  6,  7,  0, 1,
			10, 11, 12, 13, 14, 15, 8, 9,
			17, 18, 19, 16,
		},
		.{
			4,  5,  6,  7,  0, 1, 2,  3,
			12, 13, 14, 15, 8, 9, 10, 11,
			18, 19, 16, 17,
		},
		.{
			6,  7,  0,  1,  2,  3,  4,  5,
			14, 15, 8,  9,  10, 11, 12, 13,
			19, 16, 17, 18,
		},
	};
	if (data >= 2*centerRotations + sideRotations) return 0;
	return rotationTable[@intFromEnum(angle)][data];
}

fn getRotationFromDir(dir: Vec3f) u16 {
	const x = dir[0];
	const y = dir[1];
	var data: u3 = 0;
	if (@abs(x) > @abs(y)) {
		if (x < 0) {
			data = 0;
		} else {
			data = 4;
		}
		if (@abs(x) < 2*@abs(y)) {
			if ((x < 0) == (y < 0)) {
				data +%= 1;
			} else {
				data -%= 1;
			}
		}
	} else {
		if (y < 0) {
			data = 2;
		} else {
			data = 6;
		}
		if (@abs(y) < 2*@abs(x)) {
			if ((x < 0) == (y < 0)) {
				data -%= 1;
			} else {
				data +%= 1;
			}
		}
	}
	return data;
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, playerDir: Vec3f, relativeDir: Vec3i, neighbor: ?Neighbor, currentData: *Block, _: Block, blockPlacing: bool) bool {
	if (neighbor == null) return false;
	if (!blockPlacing) return false;
	currentData.data = switch (Neighbor.fromRelPos(relativeDir) orelse unreachable) {
		.dirNegX => 2*centerRotations,
		.dirNegY => 2*centerRotations + 1,
		.dirPosX => 2*centerRotations + 2,
		.dirPosY => 2*centerRotations + 3,
		.dirUp => centerRotations + getRotationFromDir(playerDir),
		.dirDown => getRotationFromDir(playerDir),
	};
	return true;
}

pub fn updateData(block: *Block, neighbor: Neighbor, _: Block) bool {
	const shouldBeBroken = switch (neighbor) {
		.dirNegX => block.data == 2*centerRotations,
		.dirNegY => block.data == 2*centerRotations + 1,
		.dirPosX => block.data == 2*centerRotations + 2,
		.dirPosY => block.data == 2*centerRotations + 3,
		.dirDown => block.data < centerRotations,
		.dirUp => block.data >= centerRotations and block.data < 2*centerRotations,
	};
	if (!shouldBeBroken) return false;
	block.* = .{.typ = 0, .data = 0};
	return true;
}

```

`mods/cubyz/rotation/stairs.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RayIntersectionResult = rotation.RayIntersectionResult;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Tag = main.Tag;
const Vec2f = vec.Vec2f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

var modelIndex: ?ModelIndex = null;

fn subBlockMask(x: u1, y: u1, z: u1) u8 {
	return @as(u8, 1) << ((@as(u3, x)*2 + @as(u3, y))*2 + z);
}
fn hasSubBlock(stairData: u8, x: u1, y: u1, z: u1) bool {
	return stairData & subBlockMask(x, y, z) == 0;
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	@setEvalBranchQuota(65_536);

	comptime var rotationTable: [4][256]u8 = undefined;
	comptime for (0..4) |a| {
		for (0..256) |old| {
			var new: u8 = 0b11_11_11_11;

			for (0..2) |i| for (0..2) |j| for (0..2) |k| {
				const sin: f32 = @sin((std.math.pi/2.0)*@as(f32, @floatFromInt(a)));
				const cos: f32 = @cos((std.math.pi/2.0)*@as(f32, @floatFromInt(a)));

				const x: f32 = (@as(f32, @floatFromInt(i)) - 0.5)*2.0;
				const y: f32 = (@as(f32, @floatFromInt(j)) - 0.5)*2.0;

				const rX = @intFromBool(x*cos - y*sin > 0);
				const rY = @intFromBool(x*sin + y*cos > 0);

				if (hasSubBlock(@intCast(old), @intCast(i), @intCast(j), @intCast(k))) {
					new &= ~subBlockMask(rX, rY, @intCast(k));
				}
			};
			rotationTable[a][old] = new;
		}
	};
	if (data >= 256) return 0;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][data];
}

pub fn init() void {}
pub fn deinit() void {}
pub fn reset() void {
	modelIndex = null;
}

const GreedyFaceInfo = struct { min: Vec2f, max: Vec2f };
fn mergeFaces(faceVisible: [2][2]bool, mem: []GreedyFaceInfo) []GreedyFaceInfo {
	var faces: usize = 0;
	if (faceVisible[0][0]) {
		if (faceVisible[0][1]) {
			if (faceVisible[1][0] and faceVisible[1][1]) {
				// One big face:
				mem[faces] = .{.min = .{0, 0}, .max = .{1, 1}};
				faces += 1;
			} else {
				mem[faces] = .{.min = .{0, 0}, .max = .{0.5, 1}};
				faces += 1;
				if (faceVisible[1][0]) {
					mem[faces] = .{.min = .{0.5, 0}, .max = .{1, 0.5}};
					faces += 1;
				}
				if (faceVisible[1][1]) {
					mem[faces] = .{.min = .{0.5, 0.5}, .max = .{1, 1}};
					faces += 1;
				}
			}
		} else {
			if (faceVisible[1][0]) {
				mem[faces] = .{.min = .{0, 0}, .max = .{1.0, 0.5}};
				faces += 1;
			} else {
				mem[faces] = .{.min = .{0, 0}, .max = .{0.5, 0.5}};
				faces += 1;
			}
			if (faceVisible[1][1]) {
				mem[faces] = .{.min = .{0.5, 0.5}, .max = .{1, 1}};
				faces += 1;
			}
		}
	} else {
		if (faceVisible[0][1]) {
			if (faceVisible[1][1]) {
				mem[faces] = .{.min = .{0, 0.5}, .max = .{1, 1}};
				faces += 1;
			} else {
				mem[faces] = .{.min = .{0, 0.5}, .max = .{0.5, 1}};
				faces += 1;
			}
			if (faceVisible[1][0]) {
				mem[faces] = .{.min = .{0.5, 0}, .max = .{1, 0.5}};
				faces += 1;
			}
		} else {
			if (faceVisible[1][0]) {
				if (faceVisible[1][1]) {
					mem[faces] = .{.min = .{0.5, 0}, .max = .{1, 1.0}};
					faces += 1;
				} else {
					mem[faces] = .{.min = .{0.5, 0}, .max = .{1, 0.5}};
					faces += 1;
				}
			} else if (faceVisible[1][1]) {
				mem[faces] = .{.min = .{0.5, 0.5}, .max = .{1, 1}};
				faces += 1;
			}
		}
	}
	return mem[0..faces];
}

pub fn createBlockModel(_: Block, _: *u16, _: ZonElement) ModelIndex {
	if (modelIndex) |idx| return idx;
	for (0..256) |i| {
		var quads = main.List(main.models.QuadInfo).init(main.stackAllocator);
		defer quads.deinit();
		for (Neighbor.iterable) |neighbor| {
			const xComponent = @abs(neighbor.textureX());
			const yComponent = @abs(neighbor.textureY());
			const normal = Vec3i{neighbor.relX(), neighbor.relY(), neighbor.relZ()};
			const zComponent = @abs(normal);
			const zMap: [2]@Vector(3, u32) = if (@reduce(.Add, normal) > 0) .{@splat(0), @splat(1)} else .{@splat(1), @splat(0)};
			var visibleFront: [2][2]bool = undefined;
			var visibleMiddle: [2][2]bool = undefined;
			for (0..2) |x| {
				for (0..2) |y| {
					const xSplat: @TypeOf(xComponent) = @splat(@intCast(x));
					const ySplat: @TypeOf(xComponent) = @splat(@intCast(y));
					const posFront = xComponent*xSplat + yComponent*ySplat + zComponent*zMap[1];
					const posBack = xComponent*xSplat + yComponent*ySplat + zComponent*zMap[0];
					visibleFront[x][y] = hasSubBlock(@intCast(i), @intCast(posFront[0]), @intCast(posFront[1]), @intCast(posFront[2]));
					visibleMiddle[x][y] = !visibleFront[x][y] and hasSubBlock(@intCast(i), @intCast(posBack[0]), @intCast(posBack[1]), @intCast(posBack[2]));
				}
			}
			const xAxis = @as(Vec3f, @floatFromInt(neighbor.textureX()));
			const yAxis = @as(Vec3f, @floatFromInt(neighbor.textureY()));
			const zAxis = @as(Vec3f, @floatFromInt(normal));
			// Greedy mesh it:
			var faces: [2]GreedyFaceInfo = undefined;
			const frontFaces = mergeFaces(visibleFront, &faces);
			for (frontFaces) |*face| {
				var xLower = @abs(xAxis)*@as(Vec3f, @splat(face.min[0]));
				var xUpper = @abs(xAxis)*@as(Vec3f, @splat(face.max[0]));
				if (@reduce(.Add, xAxis) < 0) std.mem.swap(Vec3f, &xLower, &xUpper);
				var yLower = @abs(yAxis)*@as(Vec3f, @splat(face.min[1]));
				var yUpper = @abs(yAxis)*@as(Vec3f, @splat(face.max[1]));
				if (@reduce(.Add, yAxis) < 0) std.mem.swap(Vec3f, &yLower, &yUpper);
				const zValue: Vec3f = @floatFromInt(zComponent*zMap[1]);
				if (neighbor == .dirNegX or neighbor == .dirPosY) {
					face.min[0] = 1 - face.min[0];
					face.max[0] = 1 - face.max[0];
					const swap = face.min[0];
					face.min[0] = face.max[0];
					face.max[0] = swap;
				}
				if (neighbor == .dirUp) {
					face.min = Vec2f{1, 1} - face.min;
					face.max = Vec2f{1, 1} - face.max;
					std.mem.swap(Vec2f, &face.min, &face.max);
				}
				if (neighbor == .dirDown) {
					face.min[1] = 1 - face.min[1];
					face.max[1] = 1 - face.max[1];
					const swap = face.min[1];
					face.min[1] = face.max[1];
					face.max[1] = swap;
				}
				quads.append(.{
					.normal = zAxis,
					.corners = .{
						xLower + yLower + zValue,
						xLower + yUpper + zValue,
						xUpper + yLower + zValue,
						xUpper + yUpper + zValue,
					},
					.cornerUV = .{.{face.min[0], face.min[1]}, .{face.min[0], face.max[1]}, .{face.max[0], face.min[1]}, .{face.max[0], face.max[1]}},
					.textureSlot = neighbor.toInt(),
				});
			}
			const middleFaces = mergeFaces(visibleMiddle, &faces);
			for (middleFaces) |*face| {
				var xLower = @abs(xAxis)*@as(Vec3f, @splat(face.min[0]));
				var xUpper = @abs(xAxis)*@as(Vec3f, @splat(face.max[0]));
				if (@reduce(.Add, xAxis) < 0) std.mem.swap(Vec3f, &xLower, &xUpper);
				var yLower = @abs(yAxis)*@as(Vec3f, @splat(face.min[1]));
				var yUpper = @abs(yAxis)*@as(Vec3f, @splat(face.max[1]));
				if (@reduce(.Add, yAxis) < 0) std.mem.swap(Vec3f, &yLower, &yUpper);
				const zValue = @as(Vec3f, @floatFromInt(zComponent))*@as(Vec3f, @splat(0.5));
				if (neighbor == .dirNegX or neighbor == .dirPosY) {
					face.min[0] = 1 - face.min[0];
					face.max[0] = 1 - face.max[0];
					const swap = face.min[0];
					face.min[0] = face.max[0];
					face.max[0] = swap;
				}
				if (neighbor == .dirUp) {
					face.min = Vec2f{1, 1} - face.min;
					face.max = Vec2f{1, 1} - face.max;
					std.mem.swap(Vec2f, &face.min, &face.max);
				}
				if (neighbor == .dirDown) {
					face.min[1] = 1 - face.min[1];
					face.max[1] = 1 - face.max[1];
					const swap = face.min[1];
					face.min[1] = face.max[1];
					face.max[1] = swap;
				}
				quads.append(.{
					.normal = zAxis,
					.corners = .{
						xLower + yLower + zValue,
						xLower + yUpper + zValue,
						xUpper + yLower + zValue,
						xUpper + yUpper + zValue,
					},
					.cornerUV = .{.{face.min[0], face.min[1]}, .{face.min[0], face.max[1]}, .{face.max[0], face.min[1]}, .{face.max[0], face.max[1]}},
					.textureSlot = neighbor.toInt(),
				});
			}
		}
		const index = main.models.Model.init(quads.items);
		if (i == 0) {
			modelIndex = index;
		}
	}
	return modelIndex.?;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(block.data & 255);
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, _: ?Neighbor, currentData: *Block, _: Block, blockPlacing: bool) bool {
	if (blockPlacing) {
		currentData.data = 0;
		return true;
	}
	return false;
}

fn closestRay(comptime typ: enum { bit, intersection }, block: Block, relativePlayerPos: Vec3f, playerDir: Vec3f) if (typ == .intersection) ?RayIntersectionResult else u16 {
	var result: ?RayIntersectionResult = null;
	var resultBit: u16 = 0;
	for ([_]u16{1, 2, 4, 8, 16, 32, 64, 128}) |bit| {
		if (block.data & bit == 0) {
			const cornerModelIndex: ModelIndex = blocks.meshes.modelIndexStart(block).add(255 ^ bit);
			if (RotationMode.DefaultFunctions.rayModelIntersection(cornerModelIndex, relativePlayerPos, playerDir)) |intersection| {
				if (result == null or intersection.distance < result.?.distance) {
					result = intersection;
					resultBit = bit;
				}
			}
		}
	}
	if (typ == .bit) return resultBit;
	return result;
}

pub fn rayIntersection(block: Block, item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) ?RayIntersectionResult {
	switch (item) {
		.tool => |tool| {
			const tags = tool.type.blockTags();
			for (tags) |tag| {
				if (tag == .chiselable) {
					return closestRay(.intersection, block, relativePlayerPos, playerDir);
				}
			}
		},
		else => {},
	}
	return RotationMode.DefaultFunctions.rayIntersection(block, item, relativePlayerPos, playerDir);
}

pub fn onBlockBreaking(item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f, currentData: *Block) void {
	switch (item) {
		.tool => |tool| {
			for (tool.type.blockTags()) |tag| {
				if (tag == .chiselable) {
					currentData.data |= closestRay(.bit, currentData.*, relativePlayerPos, playerDir);
					if (currentData.data == 255) currentData.* = .{.typ = 0, .data = 0};
					return;
				}
			}
		},
		else => {},
	}
	return RotationMode.DefaultFunctions.onBlockBreaking(item, relativePlayerPos, playerDir, currentData);
}

pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) RotationMode.CanBeChangedInto {
	if (oldBlock.typ != newBlock.typ) return RotationMode.DefaultFunctions.canBeChangedInto(oldBlock, newBlock, item, shouldDropSourceBlockOnSuccess);
	if (oldBlock.data == newBlock.data) return .no;
	if (item.item == .tool) {
		return .{.yes_costsDurability = 1};
	}
	return .no;
}

pub fn getBlockTags() []const Tag {
	return &.{.chiselable};
}

```

`mods/cubyz/rotation/texture_pile.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

var rotatedModels: std.StringHashMap(ModelIndex) = undefined;

pub fn init() void {
	rotatedModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	rotatedModels.deinit();
}

pub fn reset() void {
	rotatedModels.clearRetainingCapacity();
}

fn transform(quad: *main.models.QuadInfo, data: u16) void {
	quad.textureSlot = data%16;
}

pub fn createBlockModel(block: Block, modeData: *u16, zon: ZonElement) ModelIndex {
	const modelId = zon.get([]const u8, "model", "cubyz:cube");
	const stateCount = zon.get(u16, "states", 2);
	const blockId = block.id();
	if (stateCount <= 1) {
		std.log.err("Block '{s}' uses texture pile with {} states. 'texturePile' should have at least 2 states, use 'no_rotation' instead", .{blockId, stateCount});
	} else if (stateCount > 16) {
		std.log.err("Block '{s}' uses texture pile with {} states. 'texturePile' can have at most 16 states.", .{blockId, stateCount});
	}
	modeData.* = stateCount;

	if (rotatedModels.get(modelId)) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex(modelId).model();

	const modelIndex = baseModel.transformModel(transform, .{@as(u16, @intCast(0))});
	for (1..16) |data| {
		_ = baseModel.transformModel(transform, .{@as(u16, @intCast(data))});
	}
	rotatedModels.put(modelId, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(@min(block.data, block.modeData() - 1));
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, _: ?Neighbor, currentData: *Block, _: Block, blockPlacing: bool) bool {
	if (blockPlacing) {
		currentData.data = 0;
		return true;
	}
	if (currentData.data >= currentData.modeData() - 1) {
		return false;
	}
	currentData.data = currentData.data + 1;
	return true;
}

pub fn onBlockBreaking(_: main.items.Item, _: Vec3f, _: Vec3f, currentData: *Block) void {
	if (currentData.data == 0) {
		currentData.* = .{.typ = 0, .data = 0};
	} else {
		currentData.data = @min(currentData.data, currentData.modeData() - 1) - 1;
	}
}

fn isItemBlock(block: Block, item: main.items.ItemStack) bool {
	return item.item == .baseItem and item.item.baseItem.block() == block.typ;
}

pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) RotationMode.CanBeChangedInto {
	switch (RotationMode.DefaultFunctions.canBeChangedInto(oldBlock, newBlock, item, shouldDropSourceBlockOnSuccess)) {
		.no, .yes_costsDurability => return .no,
		.yes_costsItems => |r| return .{.yes_costsItems = r},
		.yes => {
			const oldAmount = if (oldBlock.typ == newBlock.typ) @min(oldBlock.data, oldBlock.modeData() - 1) else 0;
			if (oldAmount == newBlock.data) return .no;
			if (oldAmount > newBlock.data) return .yes;
			if (!isItemBlock(newBlock, item)) return .no;
			return .{.yes_costsItems = newBlock.data - oldAmount};
		},
	}
}

pub fn itemDropsOnChange(oldBlock: Block, newBlock: Block) u16 {
	if (newBlock.typ != oldBlock.typ) return oldBlock.data + 1;
	return oldBlock.data -| newBlock.data;
}

// MARK: non-interface fns

pub fn updateBlockFromNeighborConnectivity(block: *Block, neighborSupportive: [6]bool) void {
	if (!neighborSupportive[Neighbor.dirDown.toInt()]) block.* = .air;
}

```

`mods/cubyz/rotation/torch.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const Neighbor = main.chunk.Neighbor;
const ModelIndex = main.models.ModelIndex;
const rotation = main.rotation;
const Degrees = rotation.Degrees;
const RayIntersectionResult = rotation.RayIntersectionResult;
const RotationMode = rotation.RotationMode;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub const naturalStandard: u16 = 1;
var rotatedModels: std.StringHashMap(ModelIndex) = undefined;
const TorchData = packed struct(u5) {
	center: bool,
	negX: bool,
	posX: bool,
	negY: bool,
	posY: bool,
};

pub fn init() void {
	rotatedModels = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	rotatedModels.deinit();
}

pub fn reset() void {
	rotatedModels.clearRetainingCapacity();
}

pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
	const baseModelId: []const u8 = zon.get([]const u8, "base", "cubyz:cube");
	const sideModelId: []const u8 = zon.get([]const u8, "side", "cubyz:cube");
	const key: []const u8 = std.mem.concat(main.stackAllocator.allocator, u8, &.{baseModelId, sideModelId}) catch unreachable;
	defer main.stackAllocator.free(key);

	if (rotatedModels.get(key)) |modelIndex| return modelIndex;

	const baseModel = main.models.getModelIndex(baseModelId).model();
	const sideModel = main.models.getModelIndex(sideModelId).model();
	// Rotate the model:
	var centerModel: ModelIndex = undefined;
	var negXModel: ModelIndex = undefined;
	var posXModel: ModelIndex = undefined;
	var negYModel: ModelIndex = undefined;
	var posYModel: ModelIndex = undefined;
	for (1..32) |i| {
		const torchData: TorchData = @bitCast(@as(u5, @intCast(i)));
		if (i & i - 1 == 0) {
			if (torchData.center) centerModel = baseModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.identity()});
			if (torchData.negX) negXModel = sideModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(0)});
			if (torchData.posX) posXModel = sideModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi)});
			if (torchData.negY) negYModel = sideModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(std.math.pi/2.0)});
			if (torchData.posY) posYModel = sideModel.transformModel(rotation.rotationMatrixTransform, .{Mat4f.rotationZ(-std.math.pi/2.0)});
		} else {
			var models: [5]ModelIndex = undefined;
			var amount: usize = 0;
			if (torchData.center) {
				models[amount] = centerModel;
				amount += 1;
			}
			if (torchData.negX) {
				models[amount] = negXModel;
				amount += 1;
			}
			if (torchData.posX) {
				models[amount] = posXModel;
				amount += 1;
			}
			if (torchData.negY) {
				models[amount] = negYModel;
				amount += 1;
			}
			if (torchData.posY) {
				models[amount] = posYModel;
				amount += 1;
			}
			_ = main.models.Model.mergeModels(models[0..amount]);
		}
	}
	const modelIndex = centerModel;
	rotatedModels.put(key, modelIndex) catch unreachable;
	return modelIndex;
}

pub fn model(block: Block) ModelIndex {
	return blocks.meshes.modelIndexStart(block).add(@as(u5, @truncate(block.data)) -| 1);
}

pub fn rotateZ(data: u16, angle: Degrees) u16 {
	comptime var rotationTable: [4][32]u8 = undefined;
	comptime for (0..32) |i| {
		rotationTable[0][i] = @intCast(i);
	};
	comptime for (1..4) |a| {
		for (0..32) |i| {
			const old: TorchData = @bitCast(@as(u5, @intCast(rotationTable[a - 1][i])));
			const new: TorchData = .{
				.center = old.center,
				.negY = old.negX,
				.posY = old.posX,
				.posX = old.negY,
				.negX = old.posY,
			};
			rotationTable[a][i] = @as(u5, @bitCast(new));
		}
	};
	if (data >= 32) return 0;
	const runtimeTable = rotationTable;
	return runtimeTable[@intFromEnum(angle)][data];
}

pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, relativeDir: Vec3i, neighbor: ?Neighbor, currentData: *Block, neighborBlock: Block, _: bool) bool {
	if (neighbor == null) return false;
	const neighborModel = blocks.meshes.model(neighborBlock).model();
	const neighborSupport = !neighborBlock.replacable() and neighborModel.neighborFacingQuads[neighbor.?.reverse().toInt()].len != 0;
	if (!neighborSupport) return false;
	var data: TorchData = @bitCast(@as(u5, @truncate(currentData.data)));
	if (relativeDir[0] == 1) data.posX = true;
	if (relativeDir[0] == -1) data.negX = true;
	if (relativeDir[1] == 1) data.posY = true;
	if (relativeDir[1] == -1) data.negY = true;
	if (relativeDir[2] == -1) data.center = true;
	if (@as(u5, @bitCast(data)) != currentData.data) {
		currentData.data = @as(u5, @bitCast(data));
		return true;
	} else {
		return false;
	}
}

fn closestRay(comptime typ: enum { bit, intersection }, block: Block, _: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) if (typ == .intersection) ?RayIntersectionResult else u16 {
	var result: ?RayIntersectionResult = null;
	var resultBit: u16 = 0;
	for ([_]u16{1, 2, 4, 8, 16}) |bit| {
		if (block.data & bit != 0) {
			const modelIndex: ModelIndex = blocks.meshes.modelIndexStart(block).add(bit - 1);
			if (RotationMode.DefaultFunctions.rayModelIntersection(modelIndex, relativePlayerPos, playerDir)) |intersection| {
				if (result == null or intersection.distance < result.?.distance) {
					result = intersection;
					resultBit = bit;
				}
			}
		}
	}
	if (typ == .bit) return resultBit;
	return result;
}

pub fn rayIntersection(block: Block, item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) ?RayIntersectionResult {
	return closestRay(.intersection, block, item, relativePlayerPos, playerDir);
}

pub fn onBlockBreaking(item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f, currentData: *Block) void {
	const bit = closestRay(.bit, currentData.*, item, relativePlayerPos, playerDir);
	currentData.data &= ~bit;
	if (currentData.data == 0) currentData.typ = 0;
}

pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) RotationMode.CanBeChangedInto {
	switch (RotationMode.DefaultFunctions.canBeChangedInto(oldBlock, newBlock, item, shouldDropSourceBlockOnSuccess)) {
		.no, .yes_costsDurability => return .no,
		.yes, .yes_costsItems => {
			const torchAmountChange = @as(i32, @popCount(newBlock.data)) - if (oldBlock.typ == newBlock.typ) @as(i32, @popCount(oldBlock.data)) else 0;
			if (torchAmountChange <= 0) return .yes;
			if (item.item != .baseItem or !std.meta.eql(item.item.baseItem.block(), newBlock.typ)) return .no;
			return .{.yes_costsItems = @intCast(torchAmountChange)};
		},
	}
}

pub fn itemDropsOnChange(oldBlock: Block, newBlock: Block) u16 {
	if (newBlock.typ != oldBlock.typ) return @popCount(oldBlock.data);
	return @popCount(oldBlock.data) -| @popCount(newBlock.data);
}

// MARK: non-interface fns

pub fn updateBlockFromNeighborConnectivity(block: *Block, neighborSupportive: [6]bool) void {
	var data: TorchData = @bitCast(@as(u5, @truncate(block.data)));
	if (!neighborSupportive[Neighbor.dirDown.toInt()]) data.center = false;
	if (!neighborSupportive[Neighbor.dirNegX.toInt()]) data.negX = false;
	if (!neighborSupportive[Neighbor.dirPosX.toInt()]) data.posX = false;
	if (!neighborSupportive[Neighbor.dirNegY.toInt()]) data.negY = false;
	if (!neighborSupportive[Neighbor.dirPosY.toInt()]) data.posY = false;
	block.data = @as(u5, @bitCast(data));
	if (block.data == 0) block.* = .air;
}

```

`run_linux.sh`:

```sh
#!/bin/bash

cd "$(dirname "$0")"

./debug_linux.sh -Doptimize=ReleaseSafe "$@"

if [ ! $NO_PAUSE ]; then
	echo "Press enter key to continue. (Or export NO_PAUSE=1 to skip this prompt.)"
	read
fi

```

`run_windows.bat`:

```bat
@echo off

cd /D "%~dp0"

call debug_windows.bat -Doptimize=ReleaseFast %*

IF "%NO_PAUSE%" == "" (
	echo Press enter key to continue. (Or set NO_PAUSE=1 to skip this prompt.^)
	pause
)

```

`scripts/install_compiler_linux.sh`:

```sh
#!/bin/bash

fail () {
	exit 1
}

echo "Detecting Zig compiler..."

BASE_VERSION=$(< .zigversion)

case "$(uname -s)" in
"Darwin")
	OS=macos;;
*)
	OS=linux;;
esac

if [ -n $ARCH ]
then
	case "$(uname -m)" in
	"arm64" | "aarch64")
		ARCH=aarch64;;
	"arm*")
		ARCH=armv7a;;
	"amd64" | "x86_64")
		ARCH=x86_64;;
	"x86*")
		ARCH=x86;;
	*)
		echo "Machine architecture could not be recognized ($(uname -m)). Report this bug with the result of \`uname -m\` and your preferred Zig release name."
		echo "Defaulting architecture to x86_64."
		ARCH=x86_64;;
	esac
fi

VERSION=zig-$ARCH-$OS-$BASE_VERSION

mkdir -p compiler/zig
touch compiler/version.txt

CURRENT_VERSION=$(< compiler/version.txt)

if [[ "$CURRENT_VERSION" != "$VERSION" ]]; then
	echo "Your Zig is the wrong version."
	echo "Deleting current Zig installation..."
	rm -r compiler/zig
	mkdir compiler/zig
	echo "Downloading $VERSION..."
	curl -o compiler/archive.tar.xz -L -f -S https://github.com/PixelGuys/Cubyz-zig-versions/releases/download/$BASE_VERSION/"$VERSION".tar.xz
	if [ $? != 0 ]
	then
		echo "Failed to download the Zig compiler."
		fail
	fi
	echo "Extracting tar file..."
	tar --xz -xf compiler/archive.tar.xz --directory compiler/zig --strip-components 1
	rm compiler/archive.tar.xz
	echo "$VERSION" > compiler/version.txt
	echo "Done updating Zig."
else
	echo "Zig compiler is valid."
fi

```

`scripts/install_compiler_windows.bat`:

```bat
@echo off

echo Detecting Zig compiler...

set /p baseVersion=<".zigversion"

IF "%PROCESSOR_ARCHITECTURE%"=="AMD64"	(set arch=x86_64)
IF "%PROCESSOR_ARCHITECTURE%"=="IA64"	(set arch=x86_64)
IF "%PROCESSOR_ARCHITECTURE%"=="x86"	(set arch=x86)
IF "%PROCESSOR_ARCHITECTURE%"=="ARM64"	(set arch=aarch64)
IF "%arch%"=="" (
	echo Machine architecture could not be recognized: %arch%. Please file a bug report.
	echo Defaulting architecture to x86_64.
	set arch=x86_64
)

set version=zig-%arch%-windows-%baseVersion%

if not exist compiler mkdir compiler
if not exist compiler\version.txt copy NUL compiler\version.txt >NUL

set currVersion=
set /p currVersion=<"compiler\version.txt"

if not "%version%" == "%currVersion%" (
	echo Your Zig is the wrong version.
	echo Deleting current Zig installation...
	if exist compiler\zig rmdir /s /q compiler\zig
	echo Downloading %version%...
	powershell -Command $ProgressPreference = 'SilentlyContinue'; "Invoke-WebRequest -uri https://github.com/PixelGuys/Cubyz-zig-versions/releases/download/%baseVersion%/%version%.zip -OutFile compiler\archive.zip"
	if errorlevel 1 (
		echo Failed to download the Zig compiler.
		exit /b 1
	)
	echo Extracting zip file...
	C:\Windows\System32\tar.exe -xf compiler\archive.zip --directory compiler
	ren compiler\%version% zig
	del compiler\archive.zip
	echo %version%> compiler\version.txt
	echo Done updating Zig.
) ELSE (
	echo Zig compiler is valid.
)

```

`scripts/make_icons_macos.sh`:

```sh
# NOTE(blackedout): Original source https://stackoverflow.com/questions/646671/how-do-i-set-the-icon-for-my-applications-mac-os-x-app-bundle (2025-11-06)

SCRIPT_DIR=$(dirname "$0")

ASSETS_DIR=$SCRIPT_DIR/../assets/cubyz
TMP_DIR=$SCRIPT_DIR/logo.iconset
ORIGINAL_ICON=$ASSETS_DIR/logo.png

echo $ASSETS_DIR
echo $TMP_DIR
echo $ORIGINAL_ICON

mkdir $TMP_DIR

# Normal screen icons
for SIZE in 16 32 64 128 256 512; do
sips -z $SIZE $SIZE $ORIGINAL_ICON --out $TMP_DIR/icon_${SIZE}x${SIZE}.png ;
done

# Retina display icons
for SIZE in 32 64 256 512; do
sips -z $SIZE $SIZE $ORIGINAL_ICON --out $TMP_DIR/icon_$(expr $SIZE / 2)x$(expr $SIZE / 2)x2.png ;
done

# Make a multi-resolution Icon
iconutil -c icns -o $ASSETS_DIR/logo.icns $TMP_DIR
rm -rf $TMP_DIR #it is useless now

```

`src/Inventory.zig`:

```zig
const std = @import("std");

const main = @import("main");
const BaseItem = main.items.BaseItem;
const Block = main.blocks.Block;
const Item = main.items.Item;
const ItemStack = main.items.ItemStack;
const Tool = main.items.Tool;
const utils = main.utils;
const BinaryWriter = utils.BinaryWriter;
const BinaryReader = utils.BinaryReader;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const sync = main.sync;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;
const Neighbor = main.chunk.Neighbor;
const BaseItemIndex = main.items.BaseItemIndex;
const ToolTypeIndex = main.items.ToolTypeIndex;

pub const InventoryId = enum(u32) { _ };

pub const ClientSide = struct {
	var maxId: InventoryId = @enumFromInt(0);
	var freeIdList: main.List(InventoryId) = undefined;
	var serverToClientMap: std.AutoHashMap(InventoryId, Inventory) = undefined;

	pub fn init() void {
		freeIdList = .init(main.globalAllocator);
		serverToClientMap = .init(main.globalAllocator.allocator);
	}

	pub fn deinit() void {
		std.debug.assert(freeIdList.items.len == @intFromEnum(maxId)); // leak
		freeIdList.deinit();
		serverToClientMap.deinit();
	}

	fn nextId() InventoryId {
		main.sync.ClientSide.mutex.lock();
		defer main.sync.ClientSide.mutex.unlock();
		if (freeIdList.popOrNull()) |id| {
			return id;
		}
		defer maxId = @enumFromInt(@intFromEnum(maxId) + 1);
		return maxId;
	}

	fn freeId(id: InventoryId) void {
		sync.threadContext.assertCorrectContext(.client);
		main.utils.assertLocked(&main.sync.ClientSide.mutex);
		freeIdList.append(id);
	}

	pub fn mapServerId(serverId: InventoryId, inventory: Inventory) void {
		main.utils.assertLocked(&main.sync.ClientSide.mutex);
		serverToClientMap.put(serverId, inventory) catch unreachable;
	}

	pub fn unmapServerId(serverId: InventoryId, clientId: InventoryId) void {
		main.utils.assertLocked(&main.sync.ClientSide.mutex);
		std.debug.assert(serverToClientMap.fetchRemove(serverId).?.value.id == clientId);
	}

	fn getInventory(serverId: InventoryId) ?Inventory {
		main.utils.assertLocked(&main.sync.ClientSide.mutex);
		return serverToClientMap.get(serverId);
	}
};

pub const ServerSide = struct { // MARK: ServerSide
	const ServerInventory = struct {
		inv: Inventory,
		users: main.ListUnmanaged(struct { user: *main.server.User, cliendId: InventoryId }),
		source: Source,
		managed: Managed,

		const Managed = enum { internallyManaged, externallyManaged };

		fn init(len: usize, typ: Inventory.Type, source: Source, managed: Managed, callbacks: Callbacks) ServerInventory {
			main.utils.assertLocked(&inventoryCreationMutex);
			return .{
				.inv = Inventory._init(main.globalAllocator, len, typ, source, .server, callbacks),
				.users = .{},
				.source = source,
				.managed = managed,
			};
		}

		fn deinit(self: *ServerInventory) void {
			main.utils.assertLocked(&inventoryCreationMutex);
			while (self.users.items.len != 0) {
				self.removeUser(self.users.items[0].user, self.users.items[0].cliendId);
			}
			self.users.deinit(main.globalAllocator);
			self.inv._deinit(main.globalAllocator, .server);
			self.inv._items.len = 0;
			self.source = .alreadyFreed;
			self.managed = .internallyManaged;
		}

		fn addUser(self: *ServerInventory, user: *main.server.User, clientId: InventoryId) void {
			sync.threadContext.assertCorrectContext(.server);
			self.users.append(main.globalAllocator, .{.user = user, .cliendId = clientId});
			user.inventoryClientToServerIdMap.put(clientId, self.inv.id) catch unreachable;
			if (self.users.items.len == 1) {
				if (self.inv.callbacks.onFirstOpenCallback) |cb| {
					cb(self.inv.source);
				}
			}
		}

		fn removeUser(self: *ServerInventory, user: *main.server.User, clientId: InventoryId) void {
			sync.threadContext.assertCorrectContext(.server);
			var index: usize = undefined;
			for (self.users.items, 0..) |userData, i| {
				if (userData.user == user) {
					index = i;
					break;
				}
			}
			_ = self.users.swapRemove(index);
			std.debug.assert(user.inventoryClientToServerIdMap.fetchRemove(clientId).?.value == self.inv.id);
			if (self.users.items.len == 0) {
				if (self.inv.callbacks.onLastCloseCallback) |cb| {
					cb(self.inv.source);
				}
				if (self.managed == .internallyManaged) {
					if (self.inv.type.shouldDepositToUserOnClose()) {
						const playerInventory = getInventoryFromSource(.{.playerInventory = user.id}) orelse @panic("Could not find player inventory");
						sync.ServerSide.executeCommand(.{.depositOrDrop = .initWithInventories(&.{playerInventory}, self.inv, user.player.pos)}, null);
					}
					inventoryCreationMutex.lock();
					defer inventoryCreationMutex.unlock();
					self.deinit();
				}
			}
		}
	};

	var inventories: main.utils.VirtualList(ServerInventory, 1 << 24) = undefined;
	var maxId: InventoryId = @enumFromInt(0);
	var freeIdList: main.List(InventoryId) = undefined;
	var inventoryCreationMutex: std.Thread.Mutex = .{};

	pub fn init() void {
		inventories = .init();
		freeIdList = .init(main.globalAllocator);
	}

	pub fn deinit() void {
		for (inventories.items()) |inv| {
			if (inv.source != .alreadyFreed) {
				std.log.err("Leaked inventory with source {}", .{inv.source});
			}
		}
		std.debug.assert(freeIdList.items.len == @intFromEnum(maxId)); // leak
		freeIdList.deinit();
		inventories.deinit();
		maxId = @enumFromInt(0);
	}

	pub fn disconnectUser(user: *main.server.User) void {
		sync.threadContext.assertCorrectContext(.server);
		while (true) {
			// Reinitializing the iterator in the loop to allow for removal:
			var iter = user.inventoryClientToServerIdMap.keyIterator();
			const clientId = iter.next() orelse break;
			closeInventory(user, clientId.*) catch unreachable;
		}
	}

	fn nextId() InventoryId {
		main.utils.assertLocked(&inventoryCreationMutex);
		if (freeIdList.popOrNull()) |id| {
			return id;
		}
		defer maxId = @enumFromInt(@intFromEnum(maxId) + 1);
		_ = inventories.addOne();
		return maxId;
	}

	fn freeId(id: InventoryId) void {
		main.utils.assertLocked(&inventoryCreationMutex);
		freeIdList.append(id);
	}

	pub fn createExternallyManagedInventory(len: usize, typ: Inventory.Type, source: Source, data: *BinaryReader, callbacks: Callbacks) InventoryId {
		inventoryCreationMutex.lock();
		defer inventoryCreationMutex.unlock();
		const inventory = ServerInventory.init(len, typ, source, .externallyManaged, callbacks);
		inventories.items()[@intFromEnum(inventory.inv.id)] = inventory;
		inventory.inv.fromBytes(data);
		return inventory.inv.id;
	}

	pub fn destroyExternallyManagedInventory(invId: InventoryId) void {
		switch (sync.threadContext) {
			.server => {},
			.chunkDeiniting => std.debug.assert(inventories.items()[@intFromEnum(invId)].users.items.len == 0), // There should be no users here, since chunks shouldn't be deinited while players are still interacting with them.
			else => unreachable,
		}
		std.debug.assert(inventories.items()[@intFromEnum(invId)].managed == .externallyManaged);

		inventoryCreationMutex.lock();
		defer inventoryCreationMutex.unlock();
		inventories.items()[@intFromEnum(invId)].deinit();
	}

	pub fn destroyAndDropExternallyManagedInventory(invId: InventoryId, pos: Vec3i) void {
		sync.threadContext.assertCorrectContext(.server);
		std.debug.assert(inventories.items()[@intFromEnum(invId)].managed == .externallyManaged);
		const inv = &inventories.items()[@intFromEnum(invId)];
		for (inv.inv._items) |*itemStack| {
			if (itemStack.amount == 0) continue;
			main.server.world.?.drop(
				itemStack.*,
				@as(Vec3d, @floatFromInt(pos)) + main.random.nextDoubleVector(3, &main.seed),
				main.random.nextFloatVectorSigned(3, &main.seed),
				0.1,
			);
			itemStack.* = .{};
		}
		inventoryCreationMutex.lock();
		defer inventoryCreationMutex.unlock();
		inv.deinit();
	}

	pub fn createInventory(user: *main.server.User, clientId: InventoryId, len: usize, typ: Inventory.Type, source: Source) !void {
		sync.threadContext.assertCorrectContext(.server);
		switch (source) {
			.blockInventory, .playerInventory, .hand => {
				switch (source) {
					.playerInventory, .hand => |id| {
						if (id != user.id) {
							std.log.err("Player {s} tried to access the inventory of another player.", .{user.name});
							return error.Invalid;
						}
					},
					else => {},
				}
				inventoryCreationMutex.lock();
				defer inventoryCreationMutex.unlock();
				for (inventories.items()) |*inv| {
					if (std.meta.eql(inv.source, source)) {
						inv.addUser(user, clientId);
						return;
					}
				}
				return error.Invalid;
			},
			.other => {},
			.alreadyFreed => unreachable,
		}

		inventoryCreationMutex.lock();
		const inventory = ServerInventory.init(len, typ, source, .internallyManaged, .{});
		inventoryCreationMutex.unlock();

		inventories.items()[@intFromEnum(inventory.inv.id)] = inventory;
		inventories.items()[@intFromEnum(inventory.inv.id)].addUser(user, clientId);

		switch (source) {
			.blockInventory => unreachable, // Should be loaded by the block entity
			.playerInventory, .hand => unreachable, // Should be loaded on player creation
			.other => {},
			.alreadyFreed => unreachable,
		}
	}

	pub fn closeInventory(user: *main.server.User, clientId: InventoryId) !void {
		sync.threadContext.assertCorrectContext(.server);
		const serverId = user.inventoryClientToServerIdMap.get(clientId) orelse return error.InventoryNotFound;
		inventories.items()[@intFromEnum(serverId)].removeUser(user, clientId);
	}

	pub fn getInventory(user: *main.server.User, clientId: InventoryId) ?Inventory {
		sync.threadContext.assertCorrectContext(.server);
		const serverId = user.inventoryClientToServerIdMap.get(clientId) orelse return null;
		return inventories.items()[@intFromEnum(serverId)].inv;
	}

	pub fn getInventoryFromSource(source: Source) ?Inventory {
		sync.threadContext.assertCorrectContext(.server);
		inventoryCreationMutex.lock();
		defer inventoryCreationMutex.unlock();
		for (inventories.items()) |inv| {
			if (std.meta.eql(inv.source, source)) {
				return inv.inv;
			}
		}
		return null;
	}

	pub fn getInventoryFromId(serverId: InventoryId) Inventory {
		sync.threadContext.assertCorrectContext(.server);
		return inventories.items()[@intFromEnum(serverId)].inv;
	}

	pub fn getServerInventory(serverId: InventoryId) ServerInventory {
		sync.threadContext.assertCorrectContext(.server);
		return inventories.items()[@intFromEnum(serverId)];
	}

	pub fn clearPlayerInventory(user: *main.server.User) void {
		sync.threadContext.assertCorrectContext(.server);
		var inventoryIdIterator = user.inventoryClientToServerIdMap.valueIterator();
		while (inventoryIdIterator.next()) |inventoryId| {
			if (inventories.items()[@intFromEnum(inventoryId.*)].source == .playerInventory) {
				sync.ServerSide.executeCommand(.{.clear = .{.inv = inventories.items()[@intFromEnum(inventoryId.*)].inv}}, null);
			}
		}
	}

	pub fn tryCollectingToPlayerInventory(user: *main.server.User, itemStack: *ItemStack) void {
		if (itemStack.item == .null) return;
		sync.threadContext.assertCorrectContext(.server);
		var inventoryIdIterator = user.inventoryClientToServerIdMap.valueIterator();
		outer: while (inventoryIdIterator.next()) |inventoryId| {
			if (inventories.items()[@intFromEnum(inventoryId.*)].source == .playerInventory) {
				const inv = inventories.items()[@intFromEnum(inventoryId.*)].inv;
				for (inv._items, 0..) |invStack, slot| {
					if (std.meta.eql(invStack.item, itemStack.item)) {
						const amount = @min(itemStack.item.stackSize() - invStack.amount, itemStack.amount);
						if (amount == 0) continue;
						sync.ServerSide.executeCommand(.{.fillFromCreative = .{.dest = .{.inv = inv, .slot = @intCast(slot)}, .item = itemStack.item, .amount = invStack.amount + amount}}, null);
						itemStack.amount -= amount;
						if (itemStack.amount == 0) break :outer;
					}
				}
				for (inv._items, 0..) |invStack, slot| {
					if (invStack.item == .null) {
						sync.ServerSide.executeCommand(.{.fillFromCreative = .{.dest = .{.inv = inv, .slot = @intCast(slot)}, .item = itemStack.item, .amount = itemStack.amount}}, null);
						itemStack.amount = 0;
						break :outer;
					}
				}
			}
		}
		if (itemStack.amount == 0) itemStack.item = .null;
	}
};

pub fn getInventory(id: InventoryId, side: sync.Side, user: ?*main.server.User) ?Inventory {
	sync.threadContext.assertCorrectContext(side);
	return switch (side) {
		.client => ClientSide.getInventory(id),
		.server => ServerSide.getInventory(user.?, id),
	};
}

pub const Callbacks = struct {
	onUpdateCallback: ?*const fn (Source) void = null,
	onFirstOpenCallback: ?*const fn (Source) void = null,
	onLastCloseCallback: ?*const fn (Source) void = null,
};

pub const SourceType = enum(u8) {
	alreadyFreed = 0,
	playerInventory = 1,
	hand = 3,
	blockInventory = 5,
	other = 0xff, // TODO: List every type separately here.
};
pub const Source = union(SourceType) {
	alreadyFreed: void,
	playerInventory: u32,
	hand: u32,
	blockInventory: Vec3i,
	other: void,
};

pub const ClientInventory = struct { // MARK: ClientInventory
	const ClientType = union(enum) {
		serverShared: void,
		creative: void,
		crafting: *const main.items.Recipe,
	};
	super: Inventory,
	type: ClientType,

	pub fn init(allocator: NeverFailingAllocator, _size: usize, _type: Type, clientType: ClientType, source: Source, callbacks: Callbacks) ClientInventory {
		const self: ClientInventory = .{
			.super = Inventory._init(allocator, _size, _type, source, .client, callbacks),
			.type = clientType,
		};
		if (clientType == .serverShared) {
			sync.ClientSide.executeCommand(.{.open = .{.inv = self.super, .source = source}});
		}
		return self;
	}

	pub fn deinit(self: ClientInventory, allocator: NeverFailingAllocator) void {
		if (main.game.world.?.connected) {
			sync.ClientSide.executeCommand(.{.close = .{.inv = self.super, .allocator = allocator}});
		} else {
			main.sync.ClientSide.mutex.lock();
			defer main.sync.ClientSide.mutex.unlock();
			self.super._deinit(allocator, .client);
		}
	}

	pub fn depositOrSwap(dest: ClientInventory, destSlot: u32, carried: ClientInventory) void {
		if (dest.type == .creative) {
			carried.fillFromCreative(0, dest.getItem(destSlot));
			return;
		}
		std.debug.assert(dest.type == .serverShared);
		main.sync.ClientSide.executeCommand(.{.depositOrSwap = .{.dest = .{.inv = dest.super, .slot = destSlot}, .source = .{.inv = carried.super, .slot = 0}}});
	}

	pub fn deposit(dest: ClientInventory, destSlot: u32, source: ClientInventory, sourceSlot: u32, amount: u16) void {
		if (source.type == .creative) {
			std.debug.assert(dest.type == .serverShared);
			dest.fillFromCreative(destSlot, source.getItem(sourceSlot));
			return;
		}
		std.debug.assert(source.type == .serverShared);
		main.sync.ClientSide.executeCommand(.{.deposit = .{.dest = .{.inv = dest.super, .slot = destSlot}, .source = .{.inv = source.super, .slot = sourceSlot}, .amount = amount}});
	}

	pub fn takeHalf(source: ClientInventory, sourceSlot: u32, carried: ClientInventory) void {
		if (carried.type == .creative) {
			carried.fillFromCreative(0, source.getItem(sourceSlot));
			return;
		}
		main.sync.ClientSide.executeCommand(.{.takeHalf = .{.dest = .{.inv = carried.super, .slot = 0}, .source = .{.inv = source.super, .slot = sourceSlot}}});
	}

	pub fn distribute(carried: ClientInventory, destinationInventories: []const ClientInventory, destinationSlots: []const u32) void {
		const amount = carried.getAmount(0)/destinationInventories.len;
		if (amount == 0) return;
		for (0..destinationInventories.len) |i| {
			destinationInventories[i].deposit(destinationSlots[i], carried, 0, @intCast(amount));
		}
	}

	pub fn depositOrDrop(source: ClientInventory, destinations: []const ClientInventory) void {
		for (destinations) |dest| std.debug.assert(dest.type == .serverShared);
		std.debug.assert(source.type != .creative);
		main.sync.ClientSide.executeCommand(.{.depositOrDrop = .init(destinations, source.super, undefined)});
	}

	pub fn depositToAny(source: ClientInventory, sourceSlot: u32, destinations: []const ClientInventory, amount: u16) void {
		std.debug.assert(source.type == .serverShared);
		for (destinations) |inv| std.debug.assert(inv.super.type == .normal);
		main.sync.ClientSide.executeCommand(.{.depositToAny = .init(destinations, .{.inv = source.super, .slot = sourceSlot}, amount)});
	}

	pub fn dropStack(source: ClientInventory, sourceSlot: u32) void {
		if (source.type != .serverShared) return;
		main.sync.ClientSide.executeCommand(.{.drop = .{.source = .{.inv = source.super, .slot = sourceSlot}}});
	}

	pub fn dropOne(source: ClientInventory, sourceSlot: u32) void {
		if (source.type != .serverShared) return;
		main.sync.ClientSide.executeCommand(.{.drop = .{.source = .{.inv = source.super, .slot = sourceSlot}, .desiredAmount = 1}});
	}

	pub fn fillFromCreative(dest: ClientInventory, destSlot: u32, item: Item) void {
		main.sync.ClientSide.executeCommand(.{.fillFromCreative = .{.dest = .{.inv = dest.super, .slot = destSlot}, .item = item}});
	}

	pub fn fillAmountFromCreative(dest: ClientInventory, destSlot: u32, item: Item, amount: u16) void {
		main.sync.ClientSide.executeCommand(.{.fillFromCreative = .{.dest = .{.inv = dest.super, .slot = destSlot}, .item = item, .amount = amount}});
	}

	pub fn craftFrom(source: ClientInventory, destinations: []const ClientInventory, craftingInv: ClientInventory) void {
		std.debug.assert(source.type == .serverShared);
		for (destinations) |inv| std.debug.assert(inv.type == .serverShared);
		std.debug.assert(craftingInv.type == .crafting);

		main.sync.ClientSide.executeCommand(.{.craftFrom = .init(destinations, &.{source}, craftingInv.type.crafting)});
	}

	pub fn placeBlock(self: ClientInventory, slot: u32) void {
		std.debug.assert(self.type == .serverShared);
		main.renderer.MeshSelection.placeBlock(self, slot);
	}

	pub fn breakBlock(self: ClientInventory, slot: u32, deltaTime: f64) void {
		std.debug.assert(self.type == .serverShared);
		main.renderer.MeshSelection.breakBlock(self, slot, deltaTime);
	}

	pub fn size(self: ClientInventory) usize {
		return self.super.size();
	}

	pub fn getItem(self: ClientInventory, slot: usize) Item {
		return self.super.getItem(slot);
	}

	pub fn getStack(self: ClientInventory, slot: usize) ItemStack {
		return self.super.getStack(slot);
	}

	pub fn getAmount(self: ClientInventory, slot: usize) u16 {
		return self.super.getAmount(slot);
	}
};

const Inventory = @This(); // MARK: Inventory

pub const TypeEnum = enum(u8) {
	normal = 0,
	workbench = 3,
};
pub const Type = union(TypeEnum) {
	normal: void,
	workbench: ToolTypeIndex,

	pub fn shouldDepositToUserOnClose(self: Type) bool {
		return self == .workbench;
	}
};

type: Type,
id: InventoryId,
_items: []ItemStack,
source: Source,
callbacks: Callbacks,

fn _init(allocator: NeverFailingAllocator, _size: usize, _type: Type, source: Source, side: sync.Side, callbacks: Callbacks) Inventory {
	if (_type == .workbench) std.debug.assert(_size == 26);
	const self = Inventory{
		.type = _type,
		._items = allocator.alloc(ItemStack, _size),
		.id = switch (side) {
			.client => ClientSide.nextId(),
			.server => ServerSide.nextId(),
		},
		.source = source,
		.callbacks = callbacks,
	};
	for (self._items) |*item| {
		item.* = ItemStack{};
	}
	return self;
}

pub fn _deinit(self: Inventory, allocator: NeverFailingAllocator, side: sync.Side) void {
	switch (side) {
		.client => ClientSide.freeId(self.id),
		.server => ServerSide.freeId(self.id),
	}
	for (self._items) |*item| {
		item.deinit();
	}
	allocator.free(self._items);
}

pub fn update(self: Inventory) void {
	defer if (self.callbacks.onUpdateCallback) |cb| cb(self.source);
	if (self.type == .workbench) {
		self._items[self._items.len - 1].deinit();
		self._items[self._items.len - 1] = .{};
		var availableItems: [25]?BaseItemIndex = undefined;
		const slotInfos = self.type.workbench.slotInfos();

		for (0..25) |i| {
			if (self._items[i].item == .baseItem) {
				availableItems[i] = self._items[i].item.baseItem;
			} else {
				if (!slotInfos[i].optional and !slotInfos[i].disabled) {
					return;
				}
				availableItems[i] = null;
			}
		}
		var hash = std.hash.Crc32.init();
		for (availableItems) |item| {
			if (item != null) {
				hash.update(item.?.id());
			} else {
				hash.update("none");
			}
		}
		self._items[self._items.len - 1].item = Item{.tool = Tool.initFromCraftingGrid(availableItems, hash.final(), self.type.workbench)};
		self._items[self._items.len - 1].amount = 1;
	}
}

pub fn size(self: Inventory) usize {
	return self._items.len;
}

pub fn getItem(self: Inventory, slot: usize) Item {
	return self._items[slot].item;
}

pub fn getStack(self: Inventory, slot: usize) ItemStack {
	return self._items[slot];
}

pub fn getAmount(self: Inventory, slot: usize) u16 {
	return self._items[slot].amount;
}

pub const CanHoldReturn = union(enum) {
	yes: void,
	remainingAmount: u16,
};

pub fn canHold(self: Inventory, sourceStack: ItemStack) CanHoldReturn {
	if (sourceStack.amount == 0) return .yes;

	var remainingAmount = sourceStack.amount;
	for (self._items) |*destStack| {
		if (std.meta.eql(destStack.item, sourceStack.item) or destStack.item == .null) {
			const amount = @min(sourceStack.item.stackSize() - destStack.amount, remainingAmount);
			remainingAmount -= amount;
			if (remainingAmount == 0) return .yes;
		}
	}
	return .{.remainingAmount = remainingAmount};
}

pub fn toBytes(self: Inventory, writer: *BinaryWriter) void {
	writer.writeVarInt(u32, @intCast(self._items.len));
	for (self._items) |stack| {
		stack.toBytes(writer);
	}
}

pub fn fromBytes(self: Inventory, reader: *BinaryReader) void {
	var remainingCount = reader.readVarInt(u32) catch 0;
	for (self._items) |*stack| {
		if (remainingCount == 0) {
			stack.* = .{};
			continue;
		}
		remainingCount -= 1;
		stack.* = ItemStack.fromBytes(reader) catch |err| {
			std.log.err("Failed to read item stack from bytes: {s}", .{@errorName(err)});
			stack.* = .{};
			continue;
		};
	}
	for (0..remainingCount) |_| {
		var stack = ItemStack.fromBytes(reader) catch continue;
		if (stack.item != .null) {
			std.log.err("Lost {} of {s}", .{stack.amount, stack.item.id().?});
		}
		stack.deinit();
	}
}

pub const InventoryAndSlot = struct {
	inv: Inventory,
	slot: u32,

	pub fn ref(self: InventoryAndSlot) *ItemStack {
		return &self.inv._items[self.slot];
	}

	pub fn write(self: InventoryAndSlot, writer: *BinaryWriter) void {
		writer.writeEnum(InventoryId, self.inv.id);
		writer.writeInt(u32, self.slot);
	}

	pub fn read(reader: *BinaryReader, side: sync.Side, user: ?*main.server.User) !InventoryAndSlot {
		const id = try reader.readEnum(InventoryId);
		const result: InventoryAndSlot = .{
			.inv = Inventory.getInventory(id, side, user) orelse return error.InventoryNotFound,
			.slot = try reader.readInt(u32),
		};
		if (result.slot >= result.inv._items.len) return error.Invalid;
		return result;
	}
};

pub const Inventories = struct { // MARK: Inventories
	inventories: []const Inventory,

	pub fn init(alloctor: NeverFailingAllocator, inventories: []const Inventory) Inventories {
		return .{
			.inventories = alloctor.dupe(Inventory, inventories),
		};
	}

	pub fn initFromClientInventories(alloctor: NeverFailingAllocator, clientInventories: []const Inventory.ClientInventory) Inventories {
		const copy = alloctor.alloc(Inventory, clientInventories.len);
		for (copy, clientInventories) |*d, s| d.* = s.super;
		return .{
			.inventories = copy,
		};
	}

	pub fn fromBytes(allocator: NeverFailingAllocator, reader: *BinaryReader, side: sync.Side, user: ?*main.server.User) !Inventories {
		const inventoryCount = try reader.readVarInt(usize);
		if (inventoryCount == 0) return error.Invalid;
		if (inventoryCount*@sizeOf(InventoryId) >= reader.remaining.len) return error.Invalid;

		const inventories = allocator.alloc(Inventory, inventoryCount);
		errdefer allocator.free(inventories);

		for (inventories) |*inv| {
			const invId = try reader.readEnum(InventoryId);
			inv.* = Inventory.getInventory(invId, side, user) orelse return error.InventoryNotFound;
		}
		return .{
			.inventories = inventories,
		};
	}

	pub fn deinit(self: Inventories, alloctor: NeverFailingAllocator) void {
		alloctor.free(self.inventories);
	}

	pub fn toBytes(self: Inventories, writer: *BinaryWriter) void {
		writer.writeVarInt(usize, self.inventories.len);
		for (self.inventories) |inv| {
			writer.writeEnum(InventoryId, inv.id);
		}
	}

	pub fn canHold(self: Inventories, itemStack: ItemStack) Inventory.CanHoldReturn {
		var remainingAmount = itemStack.amount;
		for (self.inventories) |dest| {
			remainingAmount = switch (dest.canHold(.{.item = itemStack.item, .amount = remainingAmount})) {
				.yes => return .yes,
				.remainingAmount => |amount| amount,
			};
		}
		return .{.remainingAmount = remainingAmount};
	}

	const Provider = union(enum) {
		move: InventoryAndSlot,
		create: Item,

		pub fn getBaseOperation(provider: Provider, dest: InventoryAndSlot, amount: u16) sync.Command.BaseOperation {
			return switch (provider) {
				.move => |slot| .{.move = .{
					.dest = dest,
					.amount = amount,
					.source = slot,
				}},
				.create => |item| .{.create = .{
					.dest = dest,
					.amount = amount,
					.item = item,
				}},
			};
		}

		pub fn getItem(provider: Provider) Item {
			return switch (provider) {
				.move => |slot| slot.ref().item,
				.create => |item| item,
			};
		}
	};

	pub fn putItemsInto(self: Inventories, ctx: sync.Command.Context, itemAmount: u16, provider: Provider) u16 {
		const item = provider.getItem();
		var remainingAmount = itemAmount;
		var selectedEmptySlot: ?u32 = null;
		var selectedEmptyInv: ?Inventory = null;

		outer: for (self.inventories) |dest| {
			var emptySlot: ?u32 = null;
			var hasItem = false;
			for (dest._items, 0..) |*destStack, destSlot| {
				if (destStack.item == .null and emptySlot == null) {
					emptySlot = @intCast(destSlot);
					if (selectedEmptySlot == null) {
						selectedEmptySlot = emptySlot;
						selectedEmptyInv = dest;
					}
				}
				if (std.meta.eql(destStack.item, item)) {
					hasItem = true;
					const amount = @min(item.stackSize() - destStack.amount, remainingAmount);
					if (amount == 0) continue;
					ctx.execute(provider.getBaseOperation(.{.inv = dest, .slot = @intCast(destSlot)}, amount));
					remainingAmount -= amount;
					if (remainingAmount == 0) break :outer;
				}
			}
			if (emptySlot != null and hasItem) {
				ctx.execute(provider.getBaseOperation(.{.inv = dest, .slot = emptySlot.?}, remainingAmount));
				remainingAmount = 0;
				break :outer;
			}
		}
		if (remainingAmount > 0 and selectedEmptySlot != null) {
			ctx.execute(provider.getBaseOperation(.{.inv = selectedEmptyInv.?, .slot = selectedEmptySlot.?}, remainingAmount));
			remainingAmount = 0;
		}
		return remainingAmount;
	}

	pub fn removeItems(self: Inventories, ctx: sync.Command.Context, itemAmount: u16, baseItem: main.items.BaseItemIndex) void {
		var fullSlot: ?u32 = null;
		var fullInv: ?Inventory = null;
		var remainingAmount: usize = itemAmount;
		for (self.inventories) |source| {
			for (0..source._items.len) |reverseIndex| {
				const i: usize = source._items.len - reverseIndex - 1;
				const otherStack: *ItemStack = &source._items[i];
				if (otherStack.item == .baseItem and baseItem == otherStack.item.baseItem) {
					if (otherStack.amount == otherStack.item.stackSize()) {
						if (fullSlot == null) {
							fullSlot = @intCast(i);
							fullInv = source;
						}
						continue;
					}
					const amount = @min(remainingAmount, otherStack.amount);
					ctx.execute(.{.delete = .{
						.source = .{.inv = source, .slot = @intCast(i)},
						.amount = amount,
					}});
					remainingAmount -= amount;
					if (remainingAmount == 0) return;
				}
			}
		}
		if (remainingAmount > 0 and fullSlot != null) {
			ctx.execute(.{.delete = .{
				.source = .{.inv = fullInv.?, .slot = fullSlot.?},
				.amount = @min(remainingAmount, baseItem.stackSize()),
			}});
		}
	}
};

```

`src/assets.zig`:

```zig
const std = @import("std");

const blocks_zig = @import("blocks.zig");
const items_zig = @import("items.zig");
const migrations_zig = @import("migrations.zig");
const blueprints_zig = @import("blueprint.zig");
const Blueprint = blueprints_zig.Blueprint;
const particles_zig = @import("particles.zig");
const ZonElement = @import("zon.zig").ZonElement;
const main = @import("main");
const biomes_zig = main.server.terrain.biomes;
const sbb = main.server.terrain.structure_building_blocks;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const NeverFailingArenaAllocator = main.heap.NeverFailingArenaAllocator;
const ListUnmanaged = main.ListUnmanaged;
const files = main.files;

var common: Assets = undefined;

pub const Assets = struct {
	pub const ZonHashMap = std.StringHashMapUnmanaged(ZonElement);
	pub const BytesHashMap = std.StringHashMapUnmanaged([]const u8);
	pub const AddonNameToZonMap = std.StringHashMapUnmanaged(ZonElement);

	blocks: ZonHashMap,
	blockMigrations: AddonNameToZonMap,
	items: ZonHashMap,
	itemMigrations: ZonHashMap,
	tools: ZonHashMap,
	biomes: ZonHashMap,
	biomeMigrations: AddonNameToZonMap,
	recipes: ZonHashMap,
	models: BytesHashMap,
	structureBuildingBlocks: ZonHashMap,
	blueprints: BytesHashMap,
	particles: ZonHashMap,
	worldPresets: ZonHashMap,

	fn init() Assets {
		return .{
			.blocks = .{},
			.blockMigrations = .{},
			.items = .{},
			.itemMigrations = .{},
			.tools = .{},
			.biomes = .{},
			.biomeMigrations = .{},
			.recipes = .{},
			.models = .{},
			.structureBuildingBlocks = .{},
			.blueprints = .{},
			.particles = .{},
			.worldPresets = .{},
		};
	}
	fn deinit(self: *Assets, allocator: NeverFailingAllocator) void {
		self.blocks.deinit(allocator.allocator);
		self.blockMigrations.deinit(allocator.allocator);
		self.items.deinit(allocator.allocator);
		self.itemMigrations.deinit(allocator.allocator);
		self.tools.deinit(allocator.allocator);
		self.biomes.deinit(allocator.allocator);
		self.biomeMigrations.deinit(allocator.allocator);
		self.recipes.deinit(allocator.allocator);
		self.models.deinit(allocator.allocator);
		self.structureBuildingBlocks.deinit(allocator.allocator);
		self.blueprints.deinit(allocator.allocator);
		self.particles.deinit(allocator.allocator);
		self.worldPresets.deinit(allocator.allocator);
	}
	fn clone(self: Assets, allocator: NeverFailingAllocator) Assets {
		return .{
			.blocks = self.blocks.clone(allocator.allocator) catch unreachable,
			.blockMigrations = self.blockMigrations.clone(allocator.allocator) catch unreachable,
			.items = self.items.clone(allocator.allocator) catch unreachable,
			.itemMigrations = self.itemMigrations.clone(allocator.allocator) catch unreachable,
			.tools = self.tools.clone(allocator.allocator) catch unreachable,
			.biomes = self.biomes.clone(allocator.allocator) catch unreachable,
			.biomeMigrations = self.biomeMigrations.clone(allocator.allocator) catch unreachable,
			.recipes = self.recipes.clone(allocator.allocator) catch unreachable,
			.models = self.models.clone(allocator.allocator) catch unreachable,
			.structureBuildingBlocks = self.structureBuildingBlocks.clone(allocator.allocator) catch unreachable,
			.blueprints = self.blueprints.clone(allocator.allocator) catch unreachable,
			.particles = self.particles.clone(allocator.allocator) catch unreachable,
			.worldPresets = .{}, // Not accessible inside the world
		};
	}
	fn read(self: *Assets, allocator: NeverFailingAllocator, assetDir: main.files.Dir, assetPath: []const u8) void {
		const addons = Addon.discoverAll(main.stackAllocator, assetDir, assetPath);
		defer addons.deinit(main.stackAllocator);
		defer for (addons.items) |*addon| addon.deinit(main.stackAllocator);

		for (addons.items) |addon| {
			addon.readAllZon(allocator, "blocks", true, &self.blocks, &self.blockMigrations);
			addon.readAllZon(allocator, "items", true, &self.items, &self.itemMigrations);
			addon.readAllZon(allocator, "tools", true, &self.tools, null);
			addon.readAllZon(allocator, "biomes", true, &self.biomes, &self.biomeMigrations);
			addon.readAllZon(allocator, "recipes", false, &self.recipes, null);
			addon.readAllZon(allocator, "sbb", true, &self.structureBuildingBlocks, null);
			addon.readAllBlueprints(allocator, "sbb", &self.blueprints);
			addon.readAllModels(allocator, &self.models);
			addon.readAllZon(allocator, "particles", true, &self.particles, null);
			addon.readAllZon(allocator, "world_presets", true, &self.worldPresets, null);
		}
	}
	fn log(self: *Assets, typ: enum { common, world }) void {
		std.log.info(
			"Finished {s} assets reading with {} blocks, {} items, {} tools, {} biomes, {} recipes, {} structure building blocks, {} blueprints, {} particles, {} world presets",
			.{@tagName(typ), self.blocks.count(), self.items.count(), self.tools.count(), self.biomes.count(), self.recipes.count(), self.structureBuildingBlocks.count(), self.blueprints.count(), self.particles.count(), self.worldPresets.count()},
		);
	}

	const Addon = struct {
		name: []const u8,
		dir: files.Dir,

		fn discoverAll(allocator: NeverFailingAllocator, assetDir: main.files.Dir, path: []const u8) main.ListUnmanaged(Addon) {
			var addons: main.ListUnmanaged(Addon) = .{};

			var dir = assetDir.openIterableDir(path) catch |err| {
				std.log.err("Can't open asset path {s}: {s}", .{path, @errorName(err)});
				return addons;
			};
			defer dir.close();

			var iterator = dir.iterate();
			while (iterator.next() catch |err| blk: {
				std.log.err("Got error while iterating over asset path {s}: {s}", .{path, @errorName(err)});
				break :blk null;
			}) |addon| {
				if (addon.kind != .directory) continue;

				const directory = dir.openDir(addon.name) catch |err| {
					std.log.err("Got error while reading addon {s} from {s}: {s}", .{addon.name, path, @errorName(err)});
					continue;
				};
				addons.append(allocator, .{.name = allocator.dupe(u8, addon.name), .dir = directory});
			}
			return addons;
		}

		fn deinit(self: *Addon, allocator: NeverFailingAllocator) void {
			self.dir.close();
			allocator.free(self.name);
		}

		const Defaults = struct {
			localArena: NeverFailingArenaAllocator = undefined,
			localAllocator: NeverFailingAllocator = undefined,
			defaults: std.StringHashMapUnmanaged(ZonElement) = .{},

			fn init(self: *Defaults, allocator: NeverFailingAllocator) void {
				self.localArena = .init(allocator);
				self.localAllocator = self.localArena.allocator();
			}

			fn deinit(self: *Defaults) void {
				self.localArena.deinit();
			}

			fn get(self: *Defaults, dir: main.files.Dir, dirPath: []const u8) ZonElement {
				const result = self.defaults.getOrPut(self.localAllocator.allocator, dirPath) catch unreachable;

				if (!result.found_existing) {
					result.key_ptr.* = self.localAllocator.dupe(u8, dirPath);
					const default: ZonElement = self.read(dir) catch |err| blk: {
						std.log.err("Failed to read default file: {s}", .{@errorName(err)});
						break :blk .null;
					};

					result.value_ptr.* = default;
				}

				return result.value_ptr.*;
			}

			fn read(self: *Defaults, dir: main.files.Dir) !ZonElement {
				if (dir.readToZon(self.localAllocator, "_defaults.zig.zon")) |zon| {
					return zon;
				} else |err| {
					if (err != error.FileNotFound) return err;
				}

				if (dir.readToZon(self.localAllocator, "_defaults.zon")) |zon| {
					return zon;
				} else |err| {
					if (err != error.FileNotFound) return err;
				}

				return .null;
			}
		};

		pub fn readAllZon(addon: Addon, allocator: NeverFailingAllocator, assetType: []const u8, hasDefaults: bool, output: *ZonHashMap, migrations: ?*AddonNameToZonMap) void {
			var assetsDirectory = addon.dir.openIterableDir(assetType) catch |err| {
				if (err != error.FileNotFound) {
					std.log.err("Could not open addon directory {s}: {s}", .{assetType, @errorName(err)});
				}
				return;
			};
			defer assetsDirectory.close();

			var defaultsStorage: Defaults = .{};
			defaultsStorage.init(main.stackAllocator);
			defer defaultsStorage.deinit();

			var walker = assetsDirectory.walk(main.stackAllocator);
			defer walker.deinit();

			while (walker.next() catch |err| blk: {
				std.log.err("Got error while iterating addon directory {s}: {s}", .{assetType, @errorName(err)});
				break :blk null;
			}) |entry| {
				if (entry.kind != .file) continue;
				if (std.ascii.startsWithIgnoreCase(entry.basename, "_defaults")) continue;
				if (!std.ascii.endsWithIgnoreCase(entry.basename, ".zon")) continue;
				if (std.ascii.startsWithIgnoreCase(entry.path, "textures")) continue;
				if (std.ascii.eqlIgnoreCase(entry.basename, "_migrations.zig.zon")) continue;

				const id = createAssetStringID(allocator, addon.name, entry.path);

				const zon = assetsDirectory.readToZon(allocator, entry.path) catch |err| {
					std.log.err("Could not open {s}/{s}: {s}", .{assetType, entry.path, @errorName(err)});
					continue;
				};
				if (hasDefaults) {
					zon.join(.preferLeft, defaultsStorage.get(main.files.Dir.init(entry.dir), entry.path[0 .. entry.path.len - entry.basename.len]));
				}
				output.put(allocator.allocator, id, zon) catch unreachable;
			}
			if (migrations != null) blk: {
				const zon = assetsDirectory.readToZon(allocator, "_migrations.zig.zon") catch |err| {
					if (err != error.FileNotFound) std.log.err("Cannot read {s} migration file for addon {s}", .{assetType, addon.name});
					break :blk;
				};
				migrations.?.put(allocator.allocator, allocator.dupe(u8, addon.name), zon) catch unreachable;
			}
		}

		pub fn readAllBlueprints(addon: Addon, allocator: NeverFailingAllocator, subPath: []const u8, output: *BytesHashMap) void {
			var assetsDirectory = addon.dir.openIterableDir(subPath) catch |err| {
				if (err != error.FileNotFound) {
					std.log.err("Could not open addon directory {s}: {s}", .{subPath, @errorName(err)});
				}
				return;
			};
			defer assetsDirectory.close();

			var walker = assetsDirectory.walk(main.stackAllocator);
			defer walker.deinit();

			while (walker.next() catch |err| blk: {
				std.log.err("Got error while iterating addon directory {s}: {s}", .{subPath, @errorName(err)});
				break :blk null;
			}) |entry| {
				if (entry.kind != .file) continue;
				if (std.ascii.startsWithIgnoreCase(entry.basename, "_defaults")) continue;
				if (!std.ascii.endsWithIgnoreCase(entry.basename, ".blp")) continue;
				if (std.ascii.startsWithIgnoreCase(entry.basename, "_migrations")) continue;

				const id = createAssetStringID(allocator, addon.name, entry.path);

				const data = assetsDirectory.read(allocator, entry.path) catch |err| {
					std.log.err("Could not open {s}/{s}: {s}", .{subPath, entry.path, @errorName(err)});
					continue;
				};
				output.put(allocator.allocator, id, data) catch unreachable;
			}
		}

		pub fn readAllModels(addon: Addon, allocator: NeverFailingAllocator, output: *BytesHashMap) void {
			const subPath = "models";
			var assetsDirectory = addon.dir.openIterableDir(subPath) catch |err| {
				if (err != error.FileNotFound) {
					std.log.err("Could not open addon directory {s}: {s}", .{subPath, @errorName(err)});
				}
				return;
			};
			defer assetsDirectory.close();
			var walker = assetsDirectory.walk(main.stackAllocator);
			defer walker.deinit();

			while (walker.next() catch |err| blk: {
				std.log.err("Got error while iterating addon directory {s}: {s}", .{subPath, @errorName(err)});
				break :blk null;
			}) |entry| {
				if (entry.kind != .file) continue;
				if (!std.ascii.endsWithIgnoreCase(entry.basename, ".obj")) continue;

				const id = createAssetStringID(allocator, addon.name, entry.path);

				const string = assetsDirectory.read(allocator, entry.path) catch |err| {
					std.log.err("Could not open {s}/{s}: {s}", .{subPath, entry.path, @errorName(err)});
					continue;
				};
				output.put(allocator.allocator, id, string) catch unreachable;
			}
		}
	};
};

fn createAssetStringID(
	externalAllocator: NeverFailingAllocator,
	addonName: []const u8,
	relativeFilePath: []const u8,
) []u8 {
	const baseNameEndIndex = if (std.ascii.endsWithIgnoreCase(relativeFilePath, ".zig.zon")) relativeFilePath.len - ".zig.zon".len else std.mem.lastIndexOfScalar(u8, relativeFilePath, '.') orelse relativeFilePath.len;
	const pathNoExtension: []const u8 = relativeFilePath[0..baseNameEndIndex];

	const assetId: []u8 = externalAllocator.alloc(u8, addonName.len + 1 + pathNoExtension.len);

	@memcpy(assetId[0..addonName.len], addonName);
	assetId[addonName.len] = ':';

	// Convert from windows to unix style separators.
	for (0..pathNoExtension.len) |i| {
		if (pathNoExtension[i] == '\\') {
			assetId[addonName.len + 1 + i] = '/';
		} else {
			assetId[addonName.len + 1 + i] = pathNoExtension[i];
		}
	}

	return assetId;
}

pub fn init() void {
	biomes_zig.init();

	common = .init();
	common.read(main.globalArena, main.files.cwd(), "assets/");
	common.log(.common);
}

fn registerItem(assetFolder: []const u8, id: []const u8, zon: ZonElement) !void {
	var split = std.mem.splitScalar(u8, id, ':');
	const mod = split.first();
	var texturePath: []const u8 = &.{};
	defer main.stackAllocator.free(texturePath);
	var replacementTexturePath: []const u8 = &.{};
	defer main.stackAllocator.free(replacementTexturePath);
	if (zon.get(?[]const u8, "texture", null)) |texture| {
		texturePath = try std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{s}/items/textures/{s}", .{assetFolder, mod, texture});
		replacementTexturePath = try std.fmt.allocPrint(main.stackAllocator.allocator, "assets/{s}/items/textures/{s}", .{mod, texture});
	}
	_ = items_zig.register(assetFolder, texturePath, replacementTexturePath, id, zon);
}

fn registerTool(assetFolder: []const u8, id: []const u8, zon: ZonElement) void {
	items_zig.registerTool(assetFolder, id, zon);
}

fn registerBlock(assetFolder: []const u8, id: []const u8, zon: ZonElement) !void {
	if (zon == .null) std.log.err("Missing block: {s}. Replacing it with default block.", .{id});

	_ = blocks_zig.register(assetFolder, id, zon);
	blocks_zig.meshes.register(assetFolder, id, zon);
}

fn assignBlockItem(stringId: []const u8) !void {
	const block = blocks_zig.getTypeById(stringId);
	// TODO: This must be gone in PixelGuys/Cubyz#1205
	const index = items_zig.BaseItemIndex.fromId(stringId) orelse unreachable;
	const item = &items_zig.itemList[@intFromEnum(index)];
	item.block = block;
}

fn registerBiome(numericId: u32, stringId: []const u8, zon: ZonElement) void {
	if (zon == .null) std.log.err("Missing biome: {s}. Replacing it with default biome.", .{stringId});
	biomes_zig.register(stringId, numericId, zon);
}

fn registerRecipesFromZon(zon: ZonElement) void {
	items_zig.registerRecipes(zon);
}

pub const Palette = struct { // MARK: Palette
	palette: main.List([]const u8),

	pub fn init(allocator: NeverFailingAllocator, zon: ZonElement, firstElement: ?[]const u8) !*Palette {
		const self = switch (zon) {
			.object => try loadFromZonLegacy(allocator, zon),
			.array, .null => try loadFromZon(allocator, zon),
			else => return error.InvalidPaletteFormat,
		};

		if (firstElement) |elem| {
			if (self.palette.items.len == 0) {
				self.palette.append(allocator.dupe(u8, elem));
			}
			if (!std.mem.eql(u8, self.palette.items[0], elem)) {
				return error.FistItemMismatch;
			}
		}
		return self;
	}
	fn loadFromZon(allocator: NeverFailingAllocator, zon: ZonElement) !*Palette {
		const items = zon.toSlice();

		const self = allocator.create(Palette);
		self.* = Palette{
			.palette = .initCapacity(allocator, items.len),
		};
		errdefer self.deinit();

		for (items) |name| {
			const stringId = name.as(?[]const u8, null) orelse return error.InvalidPaletteFormat;
			self.palette.appendAssumeCapacity(allocator.dupe(u8, stringId));
		}
		return self;
	}
	fn loadFromZonLegacy(allocator: NeverFailingAllocator, zon: ZonElement) !*Palette {
		// Using zon.object.count() here has the implication that array can not be sparse.
		const paletteLength = zon.object.count();
		const translationPalette = main.stackAllocator.alloc(?[]const u8, paletteLength);
		defer main.stackAllocator.free(translationPalette);

		@memset(translationPalette, null);

		var iterator = zon.object.iterator();
		while (iterator.next()) |entry| {
			const numericId = entry.value_ptr.as(?usize, null) orelse return error.InvalidPaletteFormat;
			const name = entry.key_ptr.*;

			if (numericId >= translationPalette.len) {
				std.log.err("ID {} ('{s}') out of range. This can be caused by palette having missing block IDs.", .{numericId, name});
				return error.SparsePaletteNotAllowed;
			}
			translationPalette[numericId] = name;
		}

		const self = allocator.create(Palette);
		self.* = Palette{
			.palette = .initCapacity(allocator, paletteLength),
		};
		errdefer self.deinit();

		for (translationPalette) |val| {
			self.palette.appendAssumeCapacity(allocator.dupe(u8, val orelse return error.MissingKeyInPalette));
			std.log.info("palette[{}]: {s}", .{self.palette.items.len, val.?});
		}
		return self;
	}

	pub fn deinit(self: *Palette) void {
		for (self.palette.items) |item| {
			self.palette.allocator.free(item);
		}
		const allocator = self.palette.allocator;
		self.palette.deinit();
		allocator.destroy(self);
	}

	pub fn add(self: *Palette, id: []const u8) void {
		self.palette.append(self.palette.allocator.dupe(u8, id));
	}

	pub fn storeToZon(self: *Palette, allocator: NeverFailingAllocator) ZonElement {
		const zon = ZonElement.initArray(allocator);

		zon.array.ensureCapacity(self.palette.items.len);

		for (self.palette.items) |item| {
			zon.append(item);
		}
		return zon;
	}

	pub fn size(self: *Palette) usize {
		return self.palette.items.len;
	}

	pub fn replaceEntry(self: *Palette, entryIndex: usize, newEntry: []const u8) void {
		self.palette.allocator.free(self.palette.items[entryIndex]);
		self.palette.items[entryIndex] = self.palette.allocator.dupe(u8, newEntry);
	}
};

var loadedAssets: bool = false;

pub fn loadWorldAssets(assetFolder: []const u8, blockPalette: *Palette, itemPalette: *Palette, toolPalette: *Palette, biomePalette: *Palette) !void { // MARK: loadWorldAssets()
	if (loadedAssets) return; // The assets already got loaded by the server.
	loadedAssets = true;

	main.Tag.initTags();

	const worldArena = main.stackAllocator.createArena();
	defer main.stackAllocator.destroyArena(worldArena);

	var worldAssets = common.clone(worldArena);
	worldAssets.read(worldArena, main.files.cubyzDir(), assetFolder);

	errdefer unloadAssets();

	migrations_zig.registerAll(.block, &worldAssets.blockMigrations);
	migrations_zig.apply(.block, blockPalette);

	migrations_zig.registerAll(.item, &worldAssets.itemMigrations);
	migrations_zig.apply(.item, itemPalette);

	migrations_zig.registerAll(.biome, &worldAssets.biomeMigrations);
	migrations_zig.apply(.biome, biomePalette);

	// models:
	var modelIterator = worldAssets.models.iterator();
	while (modelIterator.next()) |entry| {
		_ = main.models.registerModel(entry.key_ptr.*, entry.value_ptr.*);
	}

	if (!main.settings.launchConfig.headlessServer) blocks_zig.meshes.registerBlockBreakingAnimation(assetFolder);

	// Blocks:
	// First blocks from the palette to enforce ID values.
	for (blockPalette.palette.items) |stringId| {
		try registerBlock(assetFolder, stringId, worldAssets.blocks.get(stringId) orelse .null);
	}

	// Then all the blocks that were missing in palette but are present in the game.
	var iterator = worldAssets.blocks.iterator();
	while (iterator.next()) |entry| {
		const stringId = entry.key_ptr.*;
		const zon = entry.value_ptr.*;

		if (blocks_zig.hasRegistered(stringId)) continue;

		try registerBlock(assetFolder, stringId, zon);
		blockPalette.add(stringId);
	}

	// Items:
	// First from the palette to enforce ID values.
	for (itemPalette.palette.items) |stringId| {
		// Some items are created automatically from blocks.
		if (worldAssets.blocks.get(stringId)) |zon| {
			if (!zon.get(bool, "hasItem", true)) continue;
			try registerItem(assetFolder, stringId, zon.getChild("item"));
			if (worldAssets.items.get(stringId) != null) {
				std.log.err("Item {s} appears as standalone item and as block item.", .{stringId});
			}
			continue;
		}
		// Items not related to blocks should appear in items hash map.
		if (worldAssets.items.get(stringId)) |zon| {
			try registerItem(assetFolder, stringId, zon);
			continue;
		}
		std.log.err("Missing item: {s}. Replacing it with default item.", .{stringId});
		try registerItem(assetFolder, stringId, .null);
	}

	// Then missing block-items to keep backwards compatibility of ID order.
	for (blockPalette.palette.items) |stringId| {
		const zon = worldAssets.blocks.get(stringId) orelse .null;

		if (!zon.get(bool, "hasItem", true)) continue;
		if (items_zig.hasRegistered(stringId)) continue;

		try registerItem(assetFolder, stringId, zon.getChild("item"));
		itemPalette.add(stringId);
	}

	// And finally normal items.
	iterator = worldAssets.items.iterator();
	while (iterator.next()) |entry| {
		const stringId = entry.key_ptr.*;
		const zon = entry.value_ptr.*;

		if (items_zig.hasRegistered(stringId)) continue;
		std.debug.assert(zon != .null);

		try registerItem(assetFolder, stringId, zon);
		itemPalette.add(stringId);
	}

	// After we have registered all items and all blocks, we can assign block references to those that come from blocks.
	for (blockPalette.palette.items) |stringId| {
		const zon = worldAssets.blocks.get(stringId) orelse .null;

		if (!zon.get(bool, "hasItem", true)) continue;
		std.debug.assert(items_zig.hasRegistered(stringId));

		try assignBlockItem(stringId);
	}

	for (toolPalette.palette.items) |id| {
		registerTool(assetFolder, id, worldAssets.tools.get(id) orelse .null);
	}

	// tools:
	iterator = worldAssets.tools.iterator();
	while (iterator.next()) |entry| {
		const id = entry.key_ptr.*;
		if (items_zig.hasRegisteredTool(id)) continue;
		registerTool(assetFolder, id, entry.value_ptr.*);
		toolPalette.add(id);
	}

	// block drops:
	blocks_zig.finishBlocks(worldAssets.blocks);

	iterator = worldAssets.recipes.iterator();
	while (iterator.next()) |entry| {
		registerRecipesFromZon(entry.value_ptr.*);
	}

	try sbb.registerBlueprints(&worldAssets.blueprints);
	try sbb.registerSBB(&worldAssets.structureBuildingBlocks);

	iterator = worldAssets.particles.iterator();
	while (iterator.next()) |entry| {
		particles_zig.ParticleManager.register(assetFolder, entry.key_ptr.*, entry.value_ptr.*);
	}

	// Biomes:
	var nextBiomeNumericId: u32 = 0;
	for (biomePalette.palette.items) |id| {
		registerBiome(nextBiomeNumericId, id, worldAssets.biomes.get(id) orelse .null);
		nextBiomeNumericId += 1;
	}
	iterator = worldAssets.biomes.iterator();
	while (iterator.next()) |entry| {
		if (biomes_zig.hasRegistered(entry.key_ptr.*)) continue;
		registerBiome(nextBiomeNumericId, entry.key_ptr.*, entry.value_ptr.*);
		biomePalette.add(entry.key_ptr.*);
		nextBiomeNumericId += 1;
	}
	biomes_zig.finishLoading();

	// Register paths for asset hot reloading:
	var dir = main.files.cwd().openIterableDir("assets") catch |err| {
		std.log.err("Can't open asset path {s}: {s}", .{"assets", @errorName(err)});
		return;
	};
	defer dir.close();
	var dirIterator = dir.iterate();
	while (dirIterator.next() catch |err| blk: {
		std.log.err("Got error while iterating over asset path {s}: {s}", .{"assets", @errorName(err)});
		break :blk null;
	}) |addon| {
		if (addon.kind == .directory) {
			const path = std.fmt.allocPrintSentinel(main.stackAllocator.allocator, "assets/{s}/blocks/textures", .{addon.name}, 0) catch unreachable;
			defer main.stackAllocator.free(path);
			// Check for access rights
			if (!main.files.cwd().hasDir(path)) continue;
			main.utils.file_monitor.listenToPath(path, main.blocks.meshes.reloadTextures, 0);
		}
	}

	worldAssets.log(.world);
}

pub fn unloadAssets() void { // MARK: unloadAssets()
	if (!loadedAssets) return;
	loadedAssets = false;

	sbb.reset();
	blocks_zig.reset();
	items_zig.reset();
	migrations_zig.reset();
	biomes_zig.reset();
	migrations_zig.reset();
	main.models.reset();
	main.particles.ParticleManager.reset();
	main.rotation.reset();
	main.Tag.resetTags();

	// Remove paths from asset hot reloading:
	var dir = main.files.cwd().openIterableDir("assets") catch |err| {
		std.log.err("Can't open asset path {s}: {s}", .{"assets", @errorName(err)});
		return;
	};
	defer dir.close();
	var dirIterator = dir.iterate();
	while (dirIterator.next() catch |err| blk: {
		std.log.err("Got error while iterating over asset path {s}: {s}", .{"assets", @errorName(err)});
		break :blk null;
	}) |addon| {
		if (addon.kind == .directory) {
			const path = std.fmt.allocPrintSentinel(main.stackAllocator.allocator, "assets/{s}/blocks/textures", .{addon.name}, 0) catch unreachable;
			defer main.stackAllocator.free(path);
			// Check for access rights
			if (!main.files.cwd().hasDir(path)) continue;
			main.utils.file_monitor.removePath(path);
		}
	}
}

pub fn worldPresets() *const Assets.ZonHashMap {
	return &common.worldPresets;
}

```

`src/audio.zig`:

```zig
const std = @import("std");

const main = @import("main");
const utils = main.utils;

const c = @cImport({
	@cDefine("_BITS_STDIO2_H", ""); // TODO: Zig fails to include this header file
	@cInclude("miniaudio.h");
	@cDefine("STB_VORBIS_HEADER_ONLY", "");
	@cInclude("stb/stb_vorbis.h");
});

fn handleError(miniaudioError: c.ma_result) !void {
	if (miniaudioError != c.MA_SUCCESS) {
		std.log.err("miniaudio error: {s}", .{c.ma_result_description(miniaudioError)});
		return error.miniaudioError;
	}
}

const AudioData = struct {
	musicId: []const u8,
	data: []f32 = &.{},

	fn open_vorbis_file_by_id(id: []const u8) ?*c.stb_vorbis {
		const colonIndex = std.mem.indexOfScalar(u8, id, ':') orelse {
			std.log.err("Invalid music id: {s}. Must be addon:file_name", .{id});
			return null;
		};
		const addon = id[0..colonIndex];
		const fileName = id[colonIndex + 1 ..];
		const path1 = std.fmt.allocPrintSentinel(main.stackAllocator.allocator, "assets/{s}/music/{s}.ogg", .{addon, fileName}, 0) catch unreachable;
		defer main.stackAllocator.free(path1);
		var err: c_int = 0;
		if (c.stb_vorbis_open_filename(path1.ptr, &err, null)) |ogg_stream| return ogg_stream;
		const path2 = std.fmt.allocPrintSentinel(main.stackAllocator.allocator, "{s}/serverAssets/{s}/music/{s}.ogg", .{main.files.cubyzDirStr(), addon, fileName}, 0) catch unreachable;
		defer main.stackAllocator.free(path2);
		if (c.stb_vorbis_open_filename(path2.ptr, &err, null)) |ogg_stream| return ogg_stream;
		std.log.err("Couldn't find music with id \"{s}\". Searched path \"{s}\" and \"{s}\"", .{id, path1, path2});
		return null;
	}

	fn init(musicId: []const u8) *AudioData {
		const self = main.globalAllocator.create(AudioData);
		self.* = .{.musicId = main.globalAllocator.dupe(u8, musicId)};

		const channels = 2;
		if (open_vorbis_file_by_id(musicId)) |ogg_stream| {
			defer c.stb_vorbis_close(ogg_stream);
			const ogg_info: c.stb_vorbis_info = c.stb_vorbis_get_info(ogg_stream);
			const samples = c.stb_vorbis_stream_length_in_samples(ogg_stream);
			if (sampleRate != @as(f32, @floatFromInt(ogg_info.sample_rate))) {
				const tempData = main.stackAllocator.alloc(f32, samples*channels);
				defer main.stackAllocator.free(tempData);
				_ = c.stb_vorbis_get_samples_float_interleaved(ogg_stream, channels, tempData.ptr, @as(c_int, @intCast(samples))*ogg_info.channels);
				var stepWidth = @as(f32, @floatFromInt(ogg_info.sample_rate))/sampleRate;
				const newSamples: usize = @intFromFloat(@as(f32, @floatFromInt(tempData.len/2))/stepWidth);
				stepWidth = @as(f32, @floatFromInt(samples))/@as(f32, @floatFromInt(newSamples));
				self.data = main.globalAllocator.alloc(f32, newSamples*channels);
				for (0..newSamples) |s| {
					const samplePosition = @as(f32, @floatFromInt(s))*stepWidth;
					const firstSample: usize = @intFromFloat(@floor(samplePosition));
					const interpolation = samplePosition - @floor(samplePosition);
					for (0..channels) |ch| {
						if (firstSample >= samples - 1) {
							self.data[s*channels + ch] = tempData[(samples - 1)*channels + ch];
						} else {
							self.data[s*channels + ch] = tempData[firstSample*channels + ch]*(1 - interpolation) + tempData[(firstSample + 1)*channels + ch]*interpolation;
						}
					}
				}
			} else {
				self.data = main.globalAllocator.alloc(f32, samples*channels);
				_ = c.stb_vorbis_get_samples_float_interleaved(ogg_stream, channels, self.data.ptr, @as(c_int, @intCast(samples))*ogg_info.channels);
			}
		} else {
			self.data = main.globalAllocator.alloc(f32, channels);
			@memset(self.data, 0);
		}
		return self;
	}

	fn deinit(self: *const AudioData) void {
		main.globalAllocator.free(self.data);
		main.globalAllocator.free(self.musicId);
		main.globalAllocator.destroy(self);
	}

	pub fn hashCode(self: *const AudioData) u32 {
		var result: u32 = 0;
		for (self.musicId) |char| {
			result = result + char;
		}
		return result;
	}

	pub fn equals(self: *const AudioData, _other: ?*const AudioData) bool {
		if (_other) |other| {
			return std.mem.eql(u8, self.musicId, other.musicId);
		} else return false;
	}
};

var activeTasks: main.ListUnmanaged([]const u8) = .{};
var taskMutex: std.Thread.Mutex = .{};

var musicCache: utils.Cache(AudioData, 4, 4, AudioData.deinit) = .{};

fn findMusic(musicId: []const u8) ?[]f32 {
	{
		taskMutex.lock();
		defer taskMutex.unlock();
		if (musicCache.find(AudioData{.musicId = musicId}, null)) |musicData| {
			return musicData.data;
		}
		for (activeTasks.items) |taskFileName| {
			if (std.mem.eql(u8, musicId, taskFileName)) {
				return null;
			}
		}
	}
	MusicLoadTask.schedule(musicId);
	return null;
}

const MusicLoadTask = struct {
	musicId: []const u8,

	const vtable = utils.ThreadPool.VTable{
		.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
		.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
		.run = main.meta.castFunctionSelfToAnyopaque(run),
		.clean = main.meta.castFunctionSelfToAnyopaque(clean),
		.taskType = .misc,
	};

	pub fn schedule(musicId: []const u8) void {
		const task = main.globalAllocator.create(MusicLoadTask);
		task.* = MusicLoadTask{
			.musicId = main.globalAllocator.dupe(u8, musicId),
		};
		main.threadPool.addTask(task, &vtable);
		taskMutex.lock();
		defer taskMutex.unlock();
		activeTasks.append(main.globalAllocator, task.musicId);
	}

	pub fn getPriority(_: *MusicLoadTask) f32 {
		return std.math.floatMax(f32);
	}

	pub fn isStillNeeded(_: *MusicLoadTask) bool {
		return true;
	}

	pub fn run(self: *MusicLoadTask) void {
		defer self.clean();
		const data = AudioData.init(self.musicId);
		const hasOld = musicCache.addToCache(data, data.hashCode());
		if (hasOld) |old| {
			old.deinit();
		}
	}

	pub fn clean(self: *MusicLoadTask) void {
		taskMutex.lock();
		var index: usize = 0;
		while (index < activeTasks.items.len) : (index += 1) {
			if (activeTasks.items[index].ptr == self.musicId.ptr) break;
		}
		_ = activeTasks.swapRemove(index);
		taskMutex.unlock();
		main.globalAllocator.free(self.musicId);
		main.globalAllocator.destroy(self);
	}
};

// TODO: Proper sound and music system

var device: c.ma_device = undefined;

var sampleRate: f32 = 0;

pub fn init() error{miniaudioError}!void {
	var config = c.ma_device_config_init(c.ma_device_type_playback);
	config.playback.format = c.ma_format_f32;
	config.playback.channels = 2;
	config.sampleRate = 44100;
	config.dataCallback = &miniaudioCallback;
	config.pUserData = undefined;

	try handleError(c.ma_device_init(null, &config, &device));

	try handleError(c.ma_device_start(&device));

	sampleRate = 44100;
}

pub fn deinit() void {
	handleError(c.ma_device_stop(&device)) catch {};
	c.ma_device_uninit(&device);
	mutex.lock();
	defer mutex.unlock();
	main.threadPool.closeAllTasksOfType(&MusicLoadTask.vtable);
	musicCache.clear();
	activeTasks.deinit(main.globalAllocator);
	main.globalAllocator.free(preferredMusic);
	preferredMusic.len = 0;
	main.globalAllocator.free(activeMusicId);
	activeMusicId.len = 0;
}

const currentMusic = struct {
	var buffer: []const f32 = undefined;
	var animationAmplitude: f32 = undefined;
	var animationVelocity: f32 = undefined;
	var animationDecaying: bool = undefined;
	var animationProgress: f32 = undefined;
	var interpolationPolynomial: [4]f32 = undefined;
	var pos: u32 = undefined;

	fn init(musicBuffer: []const f32) void {
		buffer = musicBuffer;
		animationAmplitude = 0;
		animationVelocity = 0;
		animationDecaying = false;
		animationProgress = 0;
		interpolationPolynomial = utils.unitIntervalSpline(f32, animationAmplitude, animationVelocity, 1, 0);
		pos = 0;
	}

	fn evaluatePolynomial() void {
		const t = animationProgress;
		const t2 = t*t;
		const t3 = t2*t;
		const a = interpolationPolynomial;
		animationAmplitude = a[0] + a[1]*t + a[2]*t2 + a[3]*t3; // value
		animationVelocity = a[1] + 2*a[2]*t + 3*a[3]*t2;
	}
};

var activeMusicId: []const u8 = &.{};
var partialFrame: f32 = 0;
const animationLengthInSeconds = 5.0;

var curIndex: u16 = 0;
var curEndIndex: std.atomic.Value(u16) = .{.value = sampleRate/60 & ~@as(u16, 1)};

var mutex: std.Thread.Mutex = .{};
var preferredMusic: []const u8 = "";

pub fn setMusic(music: []const u8) void {
	mutex.lock();
	defer mutex.unlock();
	if (std.mem.eql(u8, music, preferredMusic)) return;
	main.globalAllocator.free(preferredMusic);
	preferredMusic = main.globalAllocator.dupe(u8, music);
}

fn addMusic(buffer: []f32) void {
	mutex.lock();
	defer mutex.unlock();
	if (!std.mem.eql(u8, preferredMusic, activeMusicId)) {
		if (activeMusicId.len == 0) {
			if (findMusic(preferredMusic)) |musicBuffer| {
				currentMusic.init(musicBuffer);
				main.globalAllocator.free(activeMusicId);
				activeMusicId = main.globalAllocator.dupe(u8, preferredMusic);
			}
		} else if (!currentMusic.animationDecaying) {
			_ = findMusic(preferredMusic); // Start loading the next music into the cache ahead of time.
			currentMusic.animationDecaying = true;
			currentMusic.animationProgress = 0;
			currentMusic.interpolationPolynomial = utils.unitIntervalSpline(f32, currentMusic.animationAmplitude, currentMusic.animationVelocity, 0, 0);
		}
	} else if (currentMusic.animationDecaying) { // We returned to the biome before the music faded away.
		currentMusic.animationDecaying = false;
		currentMusic.animationProgress = 0;
		currentMusic.interpolationPolynomial = utils.unitIntervalSpline(f32, currentMusic.animationAmplitude, currentMusic.animationVelocity, 1, 0);
	}
	if (activeMusicId.len == 0) return;

	// Copy the music to the buffer.
	var i: usize = 0;
	while (i < buffer.len) : (i += 2) {
		currentMusic.animationProgress += 1.0/(animationLengthInSeconds*sampleRate);
		var amplitude: f32 = main.settings.musicVolume;
		if (currentMusic.animationProgress > 1) {
			if (currentMusic.animationDecaying) {
				main.globalAllocator.free(activeMusicId);
				activeMusicId = &.{};
				amplitude = 0;
			}
		} else {
			currentMusic.evaluatePolynomial();
			amplitude *= currentMusic.animationAmplitude;
		}
		buffer[i] += amplitude*currentMusic.buffer[currentMusic.pos];
		buffer[i + 1] += amplitude*currentMusic.buffer[currentMusic.pos + 1];
		currentMusic.pos += 2;
		if (currentMusic.pos >= currentMusic.buffer.len) {
			currentMusic.pos = 0;
		}
	}
}

fn miniaudioCallback(
	maDevice: ?*anyopaque,
	output: ?*anyopaque,
	input: ?*const anyopaque,
	frameCount: u32,
) callconv(.c) void {
	_ = input;
	_ = maDevice;
	const valuesPerBuffer = 2*frameCount; // Stereo
	const buffer = @as([*]f32, @ptrCast(@alignCast(output)))[0..valuesPerBuffer];
	@memset(buffer, 0);
	addMusic(buffer);
}

```

`src/block_entity.zig`:

```zig
const std = @import("std");

const main = @import("main.zig");
const Block = main.blocks.Block;
const Chunk = main.chunk.Chunk;
const ChunkPosition = main.chunk.ChunkPosition;
const getIndex = main.chunk.getIndex;
const graphics = main.graphics;
const c = graphics.c;
const server = main.server;
const User = server.User;
const mesh_storage = main.renderer.mesh_storage;
const BinaryReader = main.utils.BinaryReader;
const BinaryWriter = main.utils.BinaryWriter;
const vec = main.vec;
const Mat4f = vec.Mat4f;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const BlockEntityIndex = main.utils.DenseId(u32);

const UpdateEvent = union(enum) {
	remove: void,
	update: *BinaryReader,
};

pub const ErrorSet = BinaryReader.AllErrors || error{Invalid};

pub const BlockEntityType = struct {
	id: []const u8,
	vtable: VTable,

	const VTable = struct {
		onLoadClient: *const fn (pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void,
		onUnloadClient: *const fn (dataIndex: BlockEntityIndex) void,
		onLoadServer: *const fn (pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void,
		onUnloadServer: *const fn (dataIndex: BlockEntityIndex) void,
		onStoreServerToDisk: *const fn (dataIndex: BlockEntityIndex, writer: *BinaryWriter) void,
		onStoreServerToClient: *const fn (dataIndex: BlockEntityIndex, writer: *BinaryWriter) void,
		onInteract: *const fn (pos: Vec3i, chunk: *Chunk) main.callbacks.Result,
		updateClientData: *const fn (pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void,
		updateServerData: *const fn (pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void,
		getServerToClientData: *const fn (pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void,
		getClientToServerData: *const fn (pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void,
	};
	pub fn init(comptime BlockEntityTypeT: type) BlockEntityType {
		BlockEntityTypeT.init();
		var class = BlockEntityType{
			.id = BlockEntityTypeT.id,
			.vtable = undefined,
		};

		inline for (@typeInfo(BlockEntityType.VTable).@"struct".fields) |field| {
			if (!@hasDecl(BlockEntityTypeT, field.name)) {
				@compileError("BlockEntityType missing field '" ++ field.name ++ "'");
			}
			@field(class.vtable, field.name) = &@field(BlockEntityTypeT, field.name);
		}
		return class;
	}
	pub inline fn onLoadClient(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void {
		return self.vtable.onLoadClient(pos, chunk, reader);
	}
	pub inline fn onUnloadClient(self: *const BlockEntityType, dataIndex: BlockEntityIndex) void {
		return self.vtable.onUnloadClient(dataIndex);
	}
	pub inline fn onLoadServer(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void {
		return self.vtable.onLoadServer(pos, chunk, reader);
	}
	pub inline fn onUnloadServer(self: *const BlockEntityType, dataIndex: BlockEntityIndex) void {
		return self.vtable.onUnloadServer(dataIndex);
	}
	pub inline fn onStoreServerToDisk(self: *const BlockEntityType, dataIndex: BlockEntityIndex, writer: *BinaryWriter) void {
		return self.vtable.onStoreServerToDisk(dataIndex, writer);
	}
	pub inline fn onStoreServerToClient(self: *const BlockEntityType, dataIndex: BlockEntityIndex, writer: *BinaryWriter) void {
		return self.vtable.onStoreServerToClient(dataIndex, writer);
	}
	pub inline fn onInteract(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk) main.callbacks.Result {
		return self.vtable.onInteract(pos, chunk);
	}
	pub inline fn updateClientData(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void {
		return try self.vtable.updateClientData(pos, chunk, event);
	}
	pub inline fn updateServerData(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void {
		return try self.vtable.updateServerData(pos, chunk, event);
	}
	pub inline fn getServerToClientData(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void {
		return self.vtable.getServerToClientData(pos, chunk, writer);
	}
	pub inline fn getClientToServerData(self: *const BlockEntityType, pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void {
		return self.vtable.getClientToServerData(pos, chunk, writer);
	}
};

fn BlockEntityDataStorage(T: type) type {
	return struct {
		pub const DataT = T;
		var freeIndexList: main.ListUnmanaged(BlockEntityIndex) = .{};
		var nextIndex: BlockEntityIndex = @enumFromInt(0);
		var storage: main.utils.SparseSet(DataT, BlockEntityIndex) = .{};
		pub var mutex: std.Thread.Mutex = .{};

		pub fn init() void {
			storage = .{};
			freeIndexList = .{};
		}
		pub fn deinit() void {
			storage.deinit(main.globalAllocator);
			freeIndexList.deinit(main.globalAllocator);
			nextIndex = @enumFromInt(0);
		}
		pub fn reset() void {
			storage.clear();
			freeIndexList.clearRetainingCapacity();
		}
		fn createEntry(pos: Vec3i, chunk: *Chunk) BlockEntityIndex {
			main.utils.assertLocked(&mutex);
			const dataIndex: BlockEntityIndex = freeIndexList.popOrNull() orelse blk: {
				defer nextIndex = @enumFromInt(@intFromEnum(nextIndex) + 1);
				break :blk nextIndex;
			};
			const localPos = chunk.getLocalBlockPos(pos);

			chunk.blockPosToEntityDataMapMutex.lock();
			chunk.blockPosToEntityDataMap.put(main.globalAllocator.allocator, localPos, dataIndex) catch unreachable;
			chunk.blockPosToEntityDataMapMutex.unlock();
			return dataIndex;
		}
		pub fn add(pos: Vec3i, value: DataT, chunk: *Chunk) void {
			mutex.lock();
			defer mutex.unlock();

			const dataIndex = createEntry(pos, chunk);
			storage.set(main.globalAllocator, dataIndex, value);
		}
		pub fn removeAtIndex(dataIndex: BlockEntityIndex) ?DataT {
			main.utils.assertLocked(&mutex);
			freeIndexList.append(main.globalAllocator, dataIndex);
			return storage.fetchRemove(dataIndex) catch null;
		}
		pub fn remove(pos: Vec3i, chunk: *Chunk) ?DataT {
			mutex.lock();
			defer mutex.unlock();

			const localPos = chunk.getLocalBlockPos(pos);

			chunk.blockPosToEntityDataMapMutex.lock();
			const entityNullable = chunk.blockPosToEntityDataMap.fetchRemove(localPos);
			chunk.blockPosToEntityDataMapMutex.unlock();

			const entry = entityNullable orelse return null;

			const dataIndex = entry.value;
			return removeAtIndex(dataIndex);
		}
		pub fn getByIndex(dataIndex: BlockEntityIndex) ?*DataT {
			main.utils.assertLocked(&mutex);

			return storage.get(dataIndex);
		}
		pub fn get(pos: Vec3i, chunk: *Chunk) ?*DataT {
			main.utils.assertLocked(&mutex);

			const localPos = chunk.getLocalBlockPos(pos);

			chunk.blockPosToEntityDataMapMutex.lock();
			defer chunk.blockPosToEntityDataMapMutex.unlock();

			const dataIndex = chunk.blockPosToEntityDataMap.get(localPos) orelse return null;
			return storage.get(dataIndex);
		}
		pub const GetOrPutResult = struct {
			valuePtr: *DataT,
			foundExisting: bool,
		};
		pub fn getOrPut(pos: Vec3i, chunk: *Chunk) GetOrPutResult {
			main.utils.assertLocked(&mutex);
			if (get(pos, chunk)) |result| return .{.valuePtr = result, .foundExisting = true};

			const dataIndex = createEntry(pos, chunk);
			return .{.valuePtr = storage.add(main.globalAllocator, dataIndex), .foundExisting = false};
		}
	};
}

pub const BlockEntityTypes = struct {
	pub const Chest = struct {
		const inventorySize = 20;
		const StorageServer = BlockEntityDataStorage(struct {
			invId: main.items.Inventory.InventoryId,
		});

		pub const id = "chest";
		pub fn init() void {
			StorageServer.init();
		}
		pub fn deinit() void {
			StorageServer.deinit();
		}
		pub fn reset() void {
			StorageServer.reset();
		}

		fn onInventoryUpdateCallback(source: main.items.Inventory.Source) void {
			const pos = source.blockInventory;
			const simChunk = main.server.world.?.getSimulationChunkAndIncreaseRefCount(pos[0], pos[1], pos[2]) orelse return;
			defer simChunk.decreaseRefCount();
			const ch = simChunk.getChunk() orelse return;
			ch.mutex.lock();
			defer ch.mutex.unlock();
			ch.setChanged();
		}

		const inventoryCallbacks = main.items.Inventory.Callbacks{
			.onUpdateCallback = &onInventoryUpdateCallback,
		};

		pub fn onLoadClient(_: Vec3i, _: *Chunk, _: *BinaryReader) ErrorSet!void {}
		pub fn onUnloadClient(_: BlockEntityIndex) void {}
		pub fn onLoadServer(pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void {
			StorageServer.mutex.lock();
			defer StorageServer.mutex.unlock();

			const data = StorageServer.getOrPut(pos, chunk);
			std.debug.assert(!data.foundExisting);
			data.valuePtr.invId = main.items.Inventory.ServerSide.createExternallyManagedInventory(inventorySize, .normal, .{.blockInventory = pos}, reader, inventoryCallbacks);
		}

		pub fn onUnloadServer(dataIndex: BlockEntityIndex) void {
			StorageServer.mutex.lock();
			const data = StorageServer.removeAtIndex(dataIndex) orelse unreachable;
			StorageServer.mutex.unlock();
			main.items.Inventory.ServerSide.destroyExternallyManagedInventory(data.invId);
		}
		pub fn onStoreServerToDisk(dataIndex: BlockEntityIndex, writer: *BinaryWriter) void {
			StorageServer.mutex.lock();
			defer StorageServer.mutex.unlock();
			const data = StorageServer.getByIndex(dataIndex) orelse return;

			const inv = main.items.Inventory.ServerSide.getInventoryFromId(data.invId);
			var isEmpty: bool = true;
			for (inv._items) |item| {
				if (item.amount != 0) isEmpty = false;
			}
			if (isEmpty) return;
			inv.toBytes(writer);
		}
		pub fn onStoreServerToClient(_: BlockEntityIndex, _: *BinaryWriter) void {}
		pub fn onInteract(pos: Vec3i, _: *Chunk) main.callbacks.Result {
			main.network.protocols.blockEntityUpdate.sendClientDataUpdateToServer(main.game.world.?.conn, pos);

			const inventory = main.items.Inventory.ClientInventory.init(main.globalAllocator, inventorySize, .normal, .serverShared, .{.blockInventory = pos}, .{});

			main.gui.windowlist.chest.setInventory(inventory);
			main.gui.openWindow("chest");
			main.Window.setMouseGrabbed(false);

			return .handled;
		}

		pub fn updateClientData(_: Vec3i, _: *Chunk, _: UpdateEvent) ErrorSet!void {}
		pub fn updateServerData(pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void {
			switch (event) {
				.remove => {
					const chest = StorageServer.remove(pos, chunk) orelse return;
					main.items.Inventory.ServerSide.destroyAndDropExternallyManagedInventory(chest.invId, pos);
				},
				.update => |_| {
					StorageServer.mutex.lock();
					defer StorageServer.mutex.unlock();
					const data = StorageServer.getOrPut(pos, chunk);
					if (data.foundExisting) return;
					var reader = BinaryReader.init(&.{});
					data.valuePtr.invId = main.items.Inventory.ServerSide.createExternallyManagedInventory(inventorySize, .normal, .{.blockInventory = pos}, &reader, inventoryCallbacks);
				},
			}
		}
		pub fn getServerToClientData(_: Vec3i, _: *Chunk, _: *BinaryWriter) void {}
		pub fn getClientToServerData(_: Vec3i, _: *Chunk, _: *BinaryWriter) void {}

		pub fn renderAll(_: Mat4f, _: Vec3f, _: Vec3d) void {}
	};

	pub const Sign = struct {
		const StorageServer = BlockEntityDataStorage(struct {
			text: []const u8,
		});
		const StorageClient = BlockEntityDataStorage(struct {
			text: []const u8,
			renderedTexture: ?main.graphics.Texture = null,
			blockPos: Vec3i,
			block: main.blocks.Block,

			fn deinit(self: @This()) void {
				main.globalAllocator.free(self.text);
				if (self.renderedTexture) |texture| {
					textureDeinitLock.lock();
					defer textureDeinitLock.unlock();
					textureDeinitList.append(texture);
				}
			}
		});
		var textureDeinitList: main.List(graphics.Texture) = undefined;
		var textureDeinitLock: std.Thread.Mutex = .{};
		var pipeline: graphics.Pipeline = undefined;
		var uniforms: struct {
			ambientLight: c_int,
			projectionMatrix: c_int,
			viewMatrix: c_int,
			playerPositionInteger: c_int,
			playerPositionFraction: c_int,
			quadIndex: c_int,
			lightData: c_int,
			chunkPos: c_int,
			blockPos: c_int,
		} = undefined;

		// TODO: Load these from some per-block settings
		const textureWidth = 128;
		const textureHeight = 72;
		const textureMargin = 4;

		pub const id = "sign";
		pub fn init() void {
			StorageServer.init();
			StorageClient.init();
			textureDeinitList = .init(main.globalAllocator);
			if (!main.settings.launchConfig.headlessServer) {
				pipeline = graphics.Pipeline.init(
					"assets/cubyz/shaders/block_entity/sign.vert",
					"assets/cubyz/shaders/block_entity/sign.frag",
					"",
					&uniforms,
					.{},
					.{.depthTest = true, .depthCompare = .equal, .depthWrite = false},
					.{.attachments = &.{.alphaBlending}},
				);
			}
		}
		pub fn deinit() void {
			while (textureDeinitList.popOrNull()) |texture| {
				texture.deinit();
			}
			textureDeinitList.deinit();
			pipeline.deinit();
			StorageServer.deinit();
			StorageClient.deinit();
		}
		pub fn reset() void {
			StorageServer.reset();
			StorageClient.reset();
		}

		pub fn onUnloadClient(dataIndex: BlockEntityIndex) void {
			StorageClient.mutex.lock();
			defer StorageClient.mutex.unlock();
			const entry = StorageClient.removeAtIndex(dataIndex) orelse unreachable;
			entry.deinit();
		}
		pub fn onUnloadServer(dataIndex: BlockEntityIndex) void {
			StorageServer.mutex.lock();
			defer StorageServer.mutex.unlock();
			const entry = StorageServer.removeAtIndex(dataIndex) orelse unreachable;
			main.globalAllocator.free(entry.text);
		}
		pub fn onInteract(pos: Vec3i, chunk: *Chunk) main.callbacks.Result {
			StorageClient.mutex.lock();
			defer StorageClient.mutex.unlock();
			const data = StorageClient.get(pos, chunk);
			main.gui.windowlist.sign_editor.openFromSignData(pos, if (data) |_data| _data.text else "");

			return .handled;
		}

		pub fn onLoadClient(pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void {
			return updateClientData(pos, chunk, .{.update = reader});
		}
		pub fn updateClientData(pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void {
			if (event == .remove or event.update.remaining.len == 0) {
				const entry = StorageClient.remove(pos, chunk) orelse return;
				entry.deinit();
				return;
			}

			StorageClient.mutex.lock();
			defer StorageClient.mutex.unlock();

			const data = StorageClient.getOrPut(pos, chunk);
			if (data.foundExisting) {
				data.valuePtr.deinit();
			}
			data.valuePtr.* = .{
				.blockPos = pos,
				.block = chunk.data.getValue(chunk.getLocalBlockPos(pos).toIndex()),
				.renderedTexture = null,
				.text = main.globalAllocator.dupe(u8, event.update.remaining),
			};
		}

		pub fn onLoadServer(pos: Vec3i, chunk: *Chunk, reader: *BinaryReader) ErrorSet!void {
			return updateServerData(pos, chunk, .{.update = reader});
		}
		pub fn updateServerData(pos: Vec3i, chunk: *Chunk, event: UpdateEvent) ErrorSet!void {
			if (event == .remove or event.update.remaining.len == 0) {
				const entry = StorageServer.remove(pos, chunk) orelse return;
				main.globalAllocator.free(entry.text);
				return;
			}

			StorageServer.mutex.lock();
			defer StorageServer.mutex.unlock();

			const newText = event.update.remaining;

			if (!std.unicode.utf8ValidateSlice(newText)) {
				std.log.err("Received sign text with invalid UTF-8 characters.", .{});
				return error.Invalid;
			}

			const data = StorageServer.getOrPut(pos, chunk);
			if (data.foundExisting) main.globalAllocator.free(data.valuePtr.text);
			data.valuePtr.text = main.globalAllocator.dupe(u8, event.update.remaining);
		}

		pub const onStoreServerToClient = onStoreServerToDisk;
		pub fn onStoreServerToDisk(dataIndex: BlockEntityIndex, writer: *BinaryWriter) void {
			StorageServer.mutex.lock();
			defer StorageServer.mutex.unlock();

			const data = StorageServer.getByIndex(dataIndex) orelse return;
			writer.writeSlice(data.text);
		}
		pub fn getServerToClientData(pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void {
			StorageServer.mutex.lock();
			defer StorageServer.mutex.unlock();

			const data = StorageServer.get(pos, chunk) orelse return;
			writer.writeSlice(data.text);
		}

		pub fn getClientToServerData(pos: Vec3i, chunk: *Chunk, writer: *BinaryWriter) void {
			StorageClient.mutex.lock();
			defer StorageClient.mutex.unlock();

			const data = StorageClient.get(pos, chunk) orelse return;
			writer.writeSlice(data.text);
		}

		pub fn updateTextFromClient(pos: Vec3i, newText: []const u8) void {
			{
				const mesh = main.renderer.mesh_storage.getMesh(.initFromWorldPos(pos, 1)) orelse return;
				mesh.mutex.lock();
				defer mesh.mutex.unlock();
				const localPos = mesh.chunk.getLocalBlockPos(pos);
				const block = mesh.chunk.data.getValue(localPos.toIndex());
				const blockEntity = block.blockEntity() orelse return;
				if (!std.mem.eql(u8, blockEntity.id, id)) return;

				StorageClient.mutex.lock();
				defer StorageClient.mutex.unlock();

				const data = StorageClient.getOrPut(pos, mesh.chunk);
				if (data.foundExisting) {
					data.valuePtr.deinit();
				}
				data.valuePtr.* = .{
					.blockPos = pos,
					.block = mesh.chunk.data.getValue(localPos.toIndex()),
					.renderedTexture = null,
					.text = main.globalAllocator.dupe(u8, newText),
				};
			}

			main.network.protocols.blockEntityUpdate.sendClientDataUpdateToServer(main.game.world.?.conn, pos);
		}

		pub fn renderAll(projectionMatrix: Mat4f, ambientLight: Vec3f, playerPos: Vec3d) void {
			var oldFramebufferBinding: c_int = undefined;
			c.glGetIntegerv(c.GL_DRAW_FRAMEBUFFER_BINDING, &oldFramebufferBinding);

			StorageClient.mutex.lock();
			defer StorageClient.mutex.unlock();

			for (StorageClient.storage.dense.items) |*signData| {
				if (signData.renderedTexture != null) continue;

				var oldViewport: [4]c_int = undefined;
				c.glGetIntegerv(c.GL_VIEWPORT, &oldViewport);
				c.glViewport(0, 0, textureWidth, textureHeight);
				defer c.glViewport(oldViewport[0], oldViewport[1], oldViewport[2], oldViewport[3]);

				var finalFrameBuffer: graphics.FrameBuffer = undefined;
				finalFrameBuffer.init(false, c.GL_NEAREST, c.GL_REPEAT);
				finalFrameBuffer.updateSize(textureWidth, textureHeight, c.GL_RGBA8);
				finalFrameBuffer.bind();
				finalFrameBuffer.clear(.{0, 0, 0, 0});
				signData.renderedTexture = .{.textureID = finalFrameBuffer.texture};
				defer c.glDeleteFramebuffers(1, &finalFrameBuffer.frameBuffer);

				const oldTranslation = graphics.draw.setTranslation(.{textureMargin, textureMargin});
				defer graphics.draw.restoreTranslation(oldTranslation);
				const oldClip = graphics.draw.setClip(.{textureWidth - 2*textureMargin, textureHeight - 2*textureMargin});
				defer graphics.draw.restoreClip(oldClip);

				var textBuffer = graphics.TextBuffer.init(main.stackAllocator, signData.text, .{.color = 0x000000}, false, .center); // TODO: Make the color configurable in the zon
				defer textBuffer.deinit();
				_ = textBuffer.calculateLineBreaks(16, textureWidth - 2*textureMargin);
				textBuffer.renderTextWithoutShadow(0, 0, 16);
			}

			c.glBindFramebuffer(c.GL_FRAMEBUFFER, @bitCast(oldFramebufferBinding));

			pipeline.bind(null);
			c.glBindVertexArray(main.renderer.chunk_meshing.vao);

			c.glUniform3f(uniforms.ambientLight, ambientLight[0], ambientLight[1], ambientLight[2]);
			c.glUniformMatrix4fv(uniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projectionMatrix));
			c.glUniformMatrix4fv(uniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&main.game.camera.viewMatrix));
			c.glUniform3i(uniforms.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
			c.glUniform3f(uniforms.playerPositionFraction, @floatCast(@mod(playerPos[0], 1)), @floatCast(@mod(playerPos[1], 1)), @floatCast(@mod(playerPos[2], 1)));

			outer: for (StorageClient.storage.dense.items) |signData| {
				if (main.blocks.meshes.model(signData.block).model().internalQuads.len == 0) continue;
				const quad = main.blocks.meshes.model(signData.block).model().internalQuads[0];

				signData.renderedTexture.?.bindTo(0);

				c.glUniform1i(uniforms.quadIndex, @intFromEnum(quad));
				const mesh = main.renderer.mesh_storage.getMesh(main.chunk.ChunkPosition.initFromWorldPos(signData.blockPos, 1)) orelse continue :outer;
				const light: [4]u32 = main.renderer.chunk_meshing.PrimitiveMesh.getLight(mesh, signData.blockPos -% Vec3i{mesh.pos.wx, mesh.pos.wy, mesh.pos.wz}, 0, quad);
				c.glUniform4ui(uniforms.lightData, light[0], light[1], light[2], light[3]);
				c.glUniform3i(uniforms.chunkPos, signData.blockPos[0] & ~main.chunk.chunkMask, signData.blockPos[1] & ~main.chunk.chunkMask, signData.blockPos[2] & ~main.chunk.chunkMask);
				c.glUniform3i(uniforms.blockPos, signData.blockPos[0] & main.chunk.chunkMask, signData.blockPos[1] & main.chunk.chunkMask, signData.blockPos[2] & main.chunk.chunkMask);

				c.glDrawElements(c.GL_TRIANGLES, 6, c.GL_UNSIGNED_INT, null);
			}
		}
	};
};

var blockyEntityTypes: std.StringHashMapUnmanaged(BlockEntityType) = .{};

pub fn init() void {
	inline for (@typeInfo(BlockEntityTypes).@"struct".decls) |declaration| {
		const class = BlockEntityType.init(@field(BlockEntityTypes, declaration.name));
		blockyEntityTypes.putNoClobber(main.globalAllocator.allocator, class.id, class) catch unreachable;
		std.log.debug("Registered BlockEntityType '{s}'", .{class.id});
	}
}

pub fn reset() void {
	inline for (@typeInfo(BlockEntityTypes).@"struct".decls) |declaration| {
		@field(BlockEntityTypes, declaration.name).reset();
	}
}

pub fn deinit() void {
	inline for (@typeInfo(BlockEntityTypes).@"struct".decls) |declaration| {
		@field(BlockEntityTypes, declaration.name).deinit();
	}
	blockyEntityTypes.deinit(main.globalAllocator.allocator);
}

pub fn getByID(_id: ?[]const u8) ?*const BlockEntityType {
	const id = _id orelse return null;
	if (blockyEntityTypes.getPtr(id)) |cls| return cls;
	std.log.err("BlockEntityType with id '{s}' not found", .{id});
	return null;
}

pub fn renderAll(projectionMatrix: Mat4f, ambientLight: Vec3f, playerPos: Vec3d) void {
	inline for (@typeInfo(BlockEntityTypes).@"struct".decls) |declaration| {
		@field(BlockEntityTypes, declaration.name).renderAll(projectionMatrix, ambientLight, playerPos);
	}
}

```

`src/blocks.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tag = main.Tag;
const utils = main.utils;
const ZonElement = @import("zon.zig").ZonElement;
const chunk = @import("chunk.zig");
const Neighbor = chunk.Neighbor;
const Chunk = chunk.Chunk;
const graphics = @import("graphics.zig");
const SSBO = graphics.SSBO;
const Image = graphics.Image;
const Color = graphics.Color;
const TextureArray = graphics.TextureArray;
const items = @import("items.zig");
const models = @import("models.zig");
const ModelIndex = models.ModelIndex;
const rotation = @import("rotation.zig");
const RotationMode = rotation.RotationMode;
const Degrees = rotation.Degrees;
const Entity = main.server.Entity;
const block_entity = @import("block_entity.zig");
const BlockEntityType = block_entity.BlockEntityType;
const ClientBlockCallback = main.callbacks.ClientBlockCallback;
const ServerBlockCallback = main.callbacks.ServerBlockCallback;
const BlockTouchCallback = main.callbacks.BlockTouchCallback;
const sbb = main.server.terrain.structure_building_blocks;
const blueprint = main.blueprint;
const Assets = main.assets.Assets;

pub const maxBlockCount: usize = 65536; // 16 bit limit

pub const BlockDrop = struct {
	items: []const items.ItemStack,
	chance: f32,
};

/// Ores can be found underground in veins.
/// TODO: Add support for non-stone ores.
pub const Ore = struct {
	/// average size of a vein in blocks
	size: f32,
	/// average density of a vein
	density: f32,
	/// average veins per chunk
	veins: f32,
	/// maximum height this ore can be generated
	maxHeight: i32,
	minHeight: i32,

	blockType: u16,
	seed: u64,
};

var _transparent: [maxBlockCount]bool = undefined;
var _collide: [maxBlockCount]bool = undefined;
var _id: [maxBlockCount][]u8 = undefined;

var _blockHealth: [maxBlockCount]f32 = undefined;
var _blockResistance: [maxBlockCount]f32 = undefined;

/// Whether you can replace it with another block, mainly used for fluids/gases
var _replacable: [maxBlockCount]bool = undefined;
var _selectable: [maxBlockCount]bool = undefined;
var _blockDrops: [maxBlockCount][]const BlockDrop = undefined;
/// Meaning undegradable parts of trees or other structures can grow through this block.
var _degradable: [maxBlockCount]bool = undefined;
var _viewThrough: [maxBlockCount]bool = undefined;
var _alwaysViewThrough: [maxBlockCount]bool = undefined;
var _hasBackFace: [maxBlockCount]bool = undefined;
var _blockTags: [maxBlockCount][]Tag = undefined;
var _light: [maxBlockCount]u32 = undefined;
/// How much light this block absorbs if it is transparent
var _absorption: [maxBlockCount]u32 = undefined;

var _onInteract: [maxBlockCount]ClientBlockCallback = undefined;
var _onBreak: [maxBlockCount]ServerBlockCallback = undefined;
var _onUpdate: [maxBlockCount]ServerBlockCallback = undefined;
var _mode: [maxBlockCount]*const RotationMode = undefined;
var _modeData: [maxBlockCount]u16 = undefined;
var _lodReplacement: [maxBlockCount]u16 = undefined;
var _opaqueVariant: [maxBlockCount]u16 = undefined;

var _friction: [maxBlockCount]f32 = undefined;
var _bounciness: [maxBlockCount]f32 = undefined;
var _density: [maxBlockCount]f32 = undefined;
var _terminalVelocity: [maxBlockCount]f32 = undefined;
var _mobility: [maxBlockCount]f32 = undefined;

var _allowOres: [maxBlockCount]bool = undefined;
var _onTick: [maxBlockCount]ServerBlockCallback = undefined;
var _onTouch: [maxBlockCount]BlockTouchCallback = undefined;
var _blockEntity: [maxBlockCount]?*const BlockEntityType = undefined;

var reverseIndices: std.StringHashMapUnmanaged(u16) = .{};

var size: u32 = 0;

pub var ores: main.ListUnmanaged(Ore) = .{};

pub fn register(_: []const u8, id: []const u8, zon: ZonElement) u16 {
	_id[size] = main.worldArena.dupe(u8, id);
	reverseIndices.put(main.worldArena.allocator, _id[size], @intCast(size)) catch unreachable;

	_mode[size] = rotation.getByID(zon.get([]const u8, "rotation", "cubyz:no_rotation"));
	_blockHealth[size] = zon.get(f32, "blockHealth", 1);
	_blockResistance[size] = zon.get(f32, "blockResistance", 0);
	const rotation_tags = _mode[size].getBlockTags();
	const block_tags = Tag.loadTagsFromZon(main.stackAllocator, zon.getChild("tags"));
	defer main.stackAllocator.free(block_tags);
	_blockTags[size] = std.mem.concat(main.worldArena.allocator, Tag, &.{rotation_tags, block_tags}) catch unreachable;

	if (_blockTags[size].len == 0) std.log.err("Block {s} is missing 'tags' field", .{id});
	for (_blockTags[size]) |tag| {
		if (tag == Tag.sbbChild) {
			sbb.registerChildBlock(@intCast(size), _id[size]);
			break;
		}
	}

	_light[size] = zon.get(u32, "emittedLight", 0);
	_absorption[size] = zon.get(u32, "absorbedLight", 0xffffff);
	_degradable[size] = zon.get(bool, "degradable", false);
	_selectable[size] = zon.get(bool, "selectable", true);
	_replacable[size] = zon.get(bool, "replacable", false);

	_transparent[size] = zon.get(bool, "transparent", false);
	_collide[size] = zon.get(bool, "collide", true);
	_alwaysViewThrough[size] = zon.get(bool, "alwaysViewThrough", false);
	_viewThrough[size] = zon.get(bool, "viewThrough", false) or _transparent[size] or _alwaysViewThrough[size];
	_hasBackFace[size] = zon.get(bool, "hasBackFace", false);
	_friction[size] = zon.get(f32, "friction", 20);
	_bounciness[size] = zon.get(f32, "bounciness", 0.0);
	_density[size] = zon.get(f32, "density", main.physics.airDensity);
	_terminalVelocity[size] = zon.get(f32, "terminalVelocity", 90);
	_mobility[size] = zon.get(f32, "mobility", 1.0);
	_allowOres[size] = zon.get(bool, "allowOres", false);

	_blockEntity[size] = block_entity.getByID(zon.get(?[]const u8, "blockEntity", null));

	const oreProperties = zon.getChild("ore");
	if (oreProperties != .null) blk: {
		if (!std.mem.eql(u8, zon.get([]const u8, "rotation", "cubyz:no_rotation"), "cubyz:ore")) {
			std.log.err("Ore must have rotation mode \"cubyz:ore\"!", .{});
			break :blk;
		}
		ores.append(main.worldArena, .{
			.veins = oreProperties.get(f32, "veins", 0),
			.size = oreProperties.get(f32, "size", 0),
			.maxHeight = oreProperties.get(i32, "height", 0),
			.minHeight = oreProperties.get(i32, "minHeight", std.math.minInt(i32)),
			.density = oreProperties.get(f32, "density", 0.5),
			.blockType = @intCast(size),
			.seed = std.hash.Wyhash.hash(0, id),
		});
	}

	defer size += 1;
	std.log.debug("Registered block: {d: >5} '{s}'", .{size, id});
	return @intCast(size);
}

pub fn loadBlockDrop(blockId: ?[]const u8, zon: ZonElement) []const BlockDrop {
	const drops = zon.getChild("drops").toSlice();
	const blockDrops = main.worldArena.alloc(BlockDrop, drops.len);

	for (drops, 0..) |blockDrop, i| {
		blockDrops[i].chance = blockDrop.get(f32, "chance", 1);
		const itemZons = blockDrop.getChild("items").toSlice();
		var resultItems = main.List(items.ItemStack).initCapacity(main.stackAllocator, itemZons.len);
		defer resultItems.deinit();

		for (itemZons) |itemZon| {
			var string = itemZon.as([]const u8, "auto");
			string = std.mem.trim(u8, string, " ");
			var iterator = std.mem.splitScalar(u8, string, ' ');
			var name = iterator.first();
			var amount: u16 = 1;
			while (iterator.next()) |next| {
				if (next.len == 0) continue; // skip multiple spaces.
				amount = std.fmt.parseInt(u16, name, 0) catch 1;
				name = next;
				break;
			}

			if (std.mem.eql(u8, name, "auto")) {
				if (blockId) |id| {
					name = id;
				} else std.log.err("Cannot use 'auto' in this context", .{});
			}

			const item = items.BaseItemIndex.fromId(name) orelse continue;
			resultItems.append(.{.item = .{.baseItem = item}, .amount = amount});
		}
		blockDrops[i].items = main.worldArena.dupe(main.items.ItemStack, resultItems.items);
	}
	return blockDrops;
}

fn registerBlockDrop(typ: u16, zon: ZonElement) void {
	_blockDrops[typ] = loadBlockDrop(_id[typ], zon);
}

fn registerLodReplacement(typ: u16, zon: ZonElement) void {
	if (zon.get(?[]const u8, "lodReplacement", null)) |replacement| {
		_lodReplacement[typ] = getTypeById(replacement);
	} else {
		_lodReplacement[typ] = typ;
	}
}

fn registerOpaqueVariant(typ: u16, zon: ZonElement) void {
	if (zon.get(?[]const u8, "opaqueVariant", null)) |replacement| {
		_opaqueVariant[typ] = getTypeById(replacement);
	} else {
		_opaqueVariant[typ] = typ;
	}
}

fn registerCallbacks(typ: u16, zon: ZonElement) void {
	_onInteract[typ] = blk: {
		break :blk ClientBlockCallback.init(zon.getChildOrNull("onInteract") orelse break :blk .noop) orelse {
			std.log.err("Failed to load onInteract event for block {s}", .{_id[typ]});
			break :blk .noop;
		};
	};
	_onBreak[typ] = blk: {
		break :blk ServerBlockCallback.init(zon.getChildOrNull("onBreak") orelse break :blk .noop) orelse {
			std.log.err("Failed to load onBreak event for block {s}", .{_id[typ]});
			break :blk .noop;
		};
	};
	_onUpdate[typ] = blk: {
		break :blk ServerBlockCallback.init(zon.getChildOrNull("onUpdate") orelse break :blk .noop) orelse {
			std.log.err("Failed to load onUpdate event for block {s}", .{_id[typ]});
			break :blk .noop;
		};
	};
	_onTick[typ] = blk: {
		break :blk ServerBlockCallback.init(zon.getChildOrNull("onTick") orelse break :blk .noop) orelse {
			std.log.err("Failed to load onTick event for block {s}", .{_id[typ]});
			break :blk .noop;
		};
	};
	_onTouch[typ] = blk: {
		break :blk BlockTouchCallback.init(zon.getChildOrNull("onTouch") orelse break :blk .noop) orelse {
			std.log.err("Failed to load onTouch event for block {s}", .{_id[typ]});
			break :blk .noop;
		};
	};
}

pub fn finishBlocks(zonElements: Assets.ZonHashMap) void {
	var i: u16 = 0;
	while (i < size) : (i += 1) {
		registerBlockDrop(i, zonElements.get(_id[i]) orelse continue);
		registerLodReplacement(i, zonElements.get(_id[i]) orelse continue);
		registerOpaqueVariant(i, zonElements.get(_id[i]) orelse continue);
		registerCallbacks(i, zonElements.get(_id[i]) orelse continue);
	}
	blueprint.registerVoidBlock(parseBlock("cubyz:void"));
	meshes.finishTextureLoading();
}

pub fn reset() void {
	size = 0;
	ores = .{};
	reverseIndices = .{};
	meshes.reset();
}

pub fn getTypeById(id: []const u8) u16 {
	if (reverseIndices.get(id)) |result| {
		return result;
	} else {
		std.log.err("Couldn't find block {s}. Replacing it with air...", .{id});
		return 0;
	}
}

fn parseBlockData(fullBlockId: []const u8, data: []const u8) ?u16 {
	if (std.mem.containsAtLeastScalar(u8, data, 1, ':')) {
		const oreChild = parseBlock(data);
		if (oreChild.data != 0) {
			std.log.warn("Error while parsing ore block data of '{s}': Parent block data must be 0.", .{fullBlockId});
		}
		return oreChild.typ;
	}
	return std.fmt.parseInt(u16, data, 0) catch |err| {
		std.log.err("Error while parsing block data of '{s}': {s}", .{fullBlockId, @errorName(err)});
		return null;
	};
}

pub fn parseBlock(data: []const u8) Block {
	var id: []const u8 = data;
	var blockData: ?u16 = null;
	if (std.mem.indexOfScalarPos(u8, data, 1 + (std.mem.indexOfScalar(u8, data, ':') orelse 0), ':')) |pos| {
		id = data[0..pos];
		blockData = parseBlockData(data, data[pos + 1 ..]);
	}
	if (reverseIndices.get(id)) |resultType| {
		var result: Block = .{.typ = resultType, .data = 0};
		result.data = blockData orelse result.mode().naturalStandard;
		return result;
	} else {
		std.log.err("Couldn't find block {s}. Replacing it with air...", .{id});
		return .{.typ = 0, .data = 0};
	}
}

pub fn getBlockById(idAndData: []const u8) !u16 {
	const addonNameSeparatorIndex = std.mem.indexOfScalar(u8, idAndData, ':') orelse return error.MissingAddonNameSeparator;
	const blockIdEndIndex = std.mem.indexOfScalarPos(u8, idAndData, 1 + addonNameSeparatorIndex, ':') orelse idAndData.len;
	const id = idAndData[0..blockIdEndIndex];
	return reverseIndices.get(id) orelse return error.NotFound;
}

pub fn getBlockByIdWithMigrations(idAndData: []const u8) !u16 {
	const addonNameSeparatorIndex = std.mem.indexOfScalar(u8, idAndData, ':') orelse return error.MissingAddonNameSeparator;
	const blockIdEndIndex = std.mem.indexOfScalarPos(u8, idAndData, 1 + addonNameSeparatorIndex, ':') orelse idAndData.len;
	var id = idAndData[0..blockIdEndIndex];
	id = main.migrations.applySingle(.block, id);
	return reverseIndices.get(id) orelse return error.NotFound;
}

pub fn getBlockData(idLikeString: []const u8) !?u16 {
	const addonNameSeparatorIndex = std.mem.indexOfScalar(u8, idLikeString, ':') orelse return error.MissingAddonNameSeparator;
	const blockIdEndIndex = std.mem.indexOfScalarPos(u8, idLikeString, 1 + addonNameSeparatorIndex, ':') orelse return null;
	const dataString = idLikeString[blockIdEndIndex + 1 ..];
	if (dataString.len == 0) return error.EmptyDataString;
	return std.fmt.parseInt(u16, dataString, 0) catch return error.InvalidData;
}

pub fn hasRegistered(id: []const u8) bool {
	return reverseIndices.contains(id);
}

pub const Block = packed struct { // MARK: Block
	typ: u16,
	data: u16,

	pub const air = Block{.typ = 0, .data = 0};

	pub fn toInt(self: Block) u32 {
		return @as(u32, self.typ) | @as(u32, self.data) << 16;
	}
	pub fn fromInt(self: u32) Block {
		return Block{.typ = @truncate(self), .data = @intCast(self >> 16)};
	}

	pub inline fn transparent(self: Block) bool {
		return _transparent[self.typ];
	}

	pub inline fn collide(self: Block) bool {
		return _collide[self.typ];
	}

	pub inline fn id(self: Block) []u8 {
		return _id[self.typ];
	}

	pub inline fn blockHealth(self: Block) f32 {
		return _blockHealth[self.typ];
	}

	pub inline fn blockResistance(self: Block) f32 {
		return _blockResistance[self.typ];
	}

	/// Whether you can replace it with another block, mainly used for fluids/gases
	pub inline fn replacable(self: Block) bool {
		return _replacable[self.typ];
	}

	pub inline fn selectable(self: Block) bool {
		return _selectable[self.typ];
	}

	pub inline fn blockDrops(self: Block) []const BlockDrop {
		return _blockDrops[self.typ];
	}

	/// Meaning undegradable parts of trees or other structures can grow through this block.
	pub inline fn degradable(self: Block) bool {
		return _degradable[self.typ];
	}

	pub inline fn viewThrough(self: Block) bool {
		return _viewThrough[self.typ];
	}

	/// shows backfaces even when next to the same block type
	pub inline fn alwaysViewThrough(self: Block) bool {
		return _alwaysViewThrough[self.typ];
	}

	pub inline fn hasBackFace(self: Block) bool {
		return _hasBackFace[self.typ];
	}

	pub inline fn blockTags(self: Block) []const Tag {
		return _blockTags[self.typ];
	}

	pub inline fn hasTag(self: Block, tag: Tag) bool {
		return std.mem.containsAtLeastScalar(Tag, self.blockTags(), 1, tag);
	}

	pub inline fn light(self: Block) u32 {
		return _light[self.typ];
	}

	/// How much light this block absorbs if it is transparent.
	pub inline fn absorption(self: Block) u32 {
		return _absorption[self.typ];
	}

	pub inline fn onInteract(self: Block) ClientBlockCallback {
		return _onInteract[self.typ];
	}
	pub inline fn onBreak(self: Block) ServerBlockCallback {
		return _onBreak[self.typ];
	}
	pub inline fn onUpdate(self: Block) ServerBlockCallback {
		return _onUpdate[self.typ];
	}
	pub inline fn mode(self: Block) *const RotationMode {
		return _mode[self.typ];
	}

	pub inline fn modeData(self: Block) u16 {
		return _modeData[self.typ];
	}

	pub inline fn rotateZ(self: Block, angle: Degrees) Block {
		return .{.typ = self.typ, .data = self.mode().rotateZ(self.data, angle)};
	}

	pub inline fn lodReplacement(self: Block) u16 {
		return _lodReplacement[self.typ];
	}

	pub inline fn opaqueVariant(self: Block) u16 {
		return _opaqueVariant[self.typ];
	}

	pub inline fn friction(self: Block) f32 {
		return _friction[self.typ];
	}

	pub inline fn bounciness(self: Block) f32 {
		return _bounciness[self.typ];
	}

	pub inline fn density(self: Block) f32 {
		return _density[self.typ];
	}

	pub inline fn terminalVelocity(self: Block) f32 {
		return _terminalVelocity[self.typ];
	}

	pub inline fn mobility(self: Block) f32 {
		return _mobility[self.typ];
	}

	pub inline fn allowOres(self: Block) bool {
		return _allowOres[self.typ];
	}

	pub inline fn onTick(self: Block) ServerBlockCallback {
		return _onTick[self.typ];
	}

	pub inline fn onTouch(self: Block) BlockTouchCallback {
		return _onTouch[self.typ];
	}

	pub fn blockEntity(self: Block) ?*const BlockEntityType {
		return _blockEntity[self.typ];
	}

	pub fn canBeChangedInto(self: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) main.rotation.RotationMode.CanBeChangedInto {
		return newBlock.mode().canBeChangedInto(self, newBlock, item, shouldDropSourceBlockOnSuccess);
	}
};

pub const meshes = struct { // MARK: meshes
	const AnimationData = extern struct {
		startFrame: u32,
		frames: u32,
		time: u32,
	};

	const FogData = extern struct {
		fogDensity: f32,
		fogColor: u32,
	};
	var size: u32 = 0;
	var _modelIndex: [maxBlockCount]ModelIndex = undefined;
	var textureIndices: [maxBlockCount][16]u16 = undefined;
	/// Stores the number of textures after each block was added. Used to clean additional textures when the world is switched.
	var maxTextureCount: [maxBlockCount]u32 = undefined;
	/// Number of loaded meshes. Used to determine if an update is needed.
	var loadedMeshes: u32 = 0;

	var textureIDs: main.ListUnmanaged([]const u8) = .{};
	var animationData: []AnimationData = &.{};
	var blockTextures: main.ListUnmanaged(Image) = .{};
	var emissionTextures: main.ListUnmanaged(Image) = .{};
	var reflectivityTextures: main.ListUnmanaged(Image) = .{};
	var absorptionTextures: main.ListUnmanaged(Image) = .{};
	var textureFogData: main.ListUnmanaged(FogData) = .{};
	pub var textureOcclusionData: []std.atomic.Value(bool) = &.{};

	pub var blockBreakingTextures: main.ListUnmanaged(u16) = .{};

	const sideNames = blk: {
		var names: [6][]const u8 = undefined;
		names[Neighbor.dirDown.toInt()] = "texture_bottom";
		names[Neighbor.dirUp.toInt()] = "texture_top";
		names[Neighbor.dirPosX.toInt()] = "texture_right";
		names[Neighbor.dirNegX.toInt()] = "texture_left";
		names[Neighbor.dirPosY.toInt()] = "texture_front";
		names[Neighbor.dirNegY.toInt()] = "texture_back";
		break :blk names;
	};

	var animationSSBO: ?SSBO = null;
	var animatedTextureSSBO: ?SSBO = null;
	var fogSSBO: ?SSBO = null;

	var animationComputePipeline: graphics.ComputePipeline = undefined;
	var animationUniforms: struct {
		time: c_int,
		size: c_int,
	} = undefined;

	pub var blockTextureArray: TextureArray = undefined;
	pub var emissionTextureArray: TextureArray = undefined;
	pub var reflectivityAndAbsorptionTextureArray: TextureArray = undefined;
	pub var ditherTexture: graphics.Texture = undefined;

	const black: Color = Color{.r = 0, .g = 0, .b = 0, .a = 255};
	const magenta: Color = Color{.r = 255, .g = 0, .b = 255, .a = 255};
	var undefinedTexture = [_]Color{magenta, black, black, magenta};
	const undefinedImage = Image{.width = 2, .height = 2, .imageData = undefinedTexture[0..]};
	var emptyTexture = [_]Color{black};
	const emptyImage = Image{.width = 1, .height = 1, .imageData = emptyTexture[0..]};

	pub fn init() void {
		animationComputePipeline = graphics.ComputePipeline.init("assets/cubyz/shaders/animation_pre_processing.comp", "", &animationUniforms);
		blockTextureArray = .init();
		emissionTextureArray = .init();
		reflectivityAndAbsorptionTextureArray = .init();
		ditherTexture = .initFromMipmapFiles("assets/cubyz/blocks/textures/dither/", 64, 0.5);
	}

	pub fn deinit() void {
		if (animationSSBO) |ssbo| {
			ssbo.deinit();
		}
		if (animatedTextureSSBO) |ssbo| {
			ssbo.deinit();
		}
		if (fogSSBO) |ssbo| {
			ssbo.deinit();
		}
		animationComputePipeline.deinit();
		blockTextureArray.deinit();
		emissionTextureArray.deinit();
		reflectivityAndAbsorptionTextureArray.deinit();
		ditherTexture.deinit();
	}

	pub fn reset() void {
		meshes.size = 0;
		loadedMeshes = 0;
		textureIDs = .{};
		animationData = &.{};
		blockTextures = .{};
		emissionTextures = .{};
		reflectivityTextures = .{};
		absorptionTextures = .{};
		textureFogData = .{};
		textureOcclusionData = &.{};
		blockBreakingTextures = .{};
	}

	pub inline fn model(block: Block) ModelIndex {
		return block.mode().model(block);
	}

	pub inline fn modelIndexStart(block: Block) ModelIndex {
		return _modelIndex[block.typ];
	}

	pub inline fn fogDensity(block: Block) f32 {
		return textureFogData.items[animationData[textureIndices[block.typ][0]].startFrame].fogDensity;
	}

	pub inline fn fogColor(block: Block) u32 {
		return textureFogData.items[animationData[textureIndices[block.typ][0]].startFrame].fogColor;
	}

	pub inline fn hasFog(block: Block) bool {
		return fogDensity(block) != 0.0;
	}

	pub inline fn textureIndex(block: Block, orientation: usize) u16 {
		if (orientation < 16) {
			return textureIndices[block.typ][orientation];
		} else {
			return textureIndices[block.data][orientation - 16];
		}
	}

	fn extendedPath(_allocator: main.heap.NeverFailingAllocator, path: []const u8, ending: []const u8) []const u8 {
		return std.fmt.allocPrint(_allocator.allocator, "{s}{s}", .{path, ending}) catch unreachable;
	}

	fn readTextureFile(_path: []const u8, ending: []const u8, default: Image) Image {
		const path = extendedPath(main.stackAllocator, _path, ending);
		defer main.stackAllocator.free(path);
		return Image.readFromFile(main.worldArena, path) catch default;
	}

	fn extractAnimationSlice(image: Image, frame: usize, frames: usize) Image {
		if (image.height < frames) return image;
		var startHeight = image.height/frames*frame;
		if (image.height%frames > frame) startHeight += frame else startHeight += image.height%frames;
		var endHeight = image.height/frames*(frame + 1);
		if (image.height%frames > frame + 1) endHeight += frame + 1 else endHeight += image.height%frames;
		var result = image;
		result.height = @intCast(endHeight - startHeight);
		result.imageData = result.imageData[startHeight*image.width .. endHeight*image.width];
		return result;
	}

	fn readTextureData(index: usize, _path: []const u8) void {
		const path = _path[0 .. _path.len - ".png".len];
		const textureInfoPath = extendedPath(main.stackAllocator, path, ".zig.zon");
		defer main.stackAllocator.free(textureInfoPath);
		const textureInfoZon = main.files.cwd().readToZon(main.stackAllocator, textureInfoPath) catch .null;
		defer textureInfoZon.deinit(main.stackAllocator);
		const animationFrames = textureInfoZon.get(u32, "frames", 1);
		const animationTime = textureInfoZon.get(u32, "time", 1);
		animationData[index] = .{.startFrame = @intCast(blockTextures.items.len), .frames = animationFrames, .time = animationTime};
		const base = readTextureFile(path, ".png", Image.defaultImage);
		const emission = readTextureFile(path, "_emission.png", Image.emptyImage);
		const reflectivity = readTextureFile(path, "_reflectivity.png", Image.emptyImage);
		const absorption = readTextureFile(path, "_absorption.png", Image.whiteEmptyImage);
		for (0..animationFrames) |i| {
			blockTextures.append(main.worldArena, extractAnimationSlice(base, i, animationFrames));
			emissionTextures.append(main.worldArena, extractAnimationSlice(emission, i, animationFrames));
			reflectivityTextures.append(main.worldArena, extractAnimationSlice(reflectivity, i, animationFrames));
			absorptionTextures.append(main.worldArena, extractAnimationSlice(absorption, i, animationFrames));
			textureFogData.append(main.worldArena, .{
				.fogDensity = textureInfoZon.get(f32, "fogDensity", 0.0),
				.fogColor = textureInfoZon.get(u32, "fogColor", 0xffffff),
			});
		}
		textureOcclusionData[index].store(textureInfoZon.get(bool, "hasOcclusion", true), .monotonic);
	}

	pub fn findTexture(_textureId: ?[]const u8, assetFolder: []const u8) !u16 {
		const textureId = _textureId orelse return error.NotFound;
		var result: u16 = undefined;
		var splitter = std.mem.splitScalar(u8, textureId, ':');
		const mod = splitter.first();
		const id = splitter.rest();
		var path = try std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{s}/blocks/textures/{s}.png", .{assetFolder, mod, id});
		defer main.stackAllocator.free(path);
		// Test if it's already in the list:
		for (textureIDs.items, 0..) |other, j| {
			if (std.mem.eql(u8, other, path)) {
				result = @intCast(j);
				return result;
			}
		}
		const file = main.files.cwd().openFile(path) catch |err| blk: {
			if (err != error.FileNotFound) {
				std.log.err("Could not open file {s}: {s}", .{path, @errorName(err)});
			}
			main.stackAllocator.free(path);
			path = try std.fmt.allocPrint(main.stackAllocator.allocator, "assets/{s}/blocks/textures/{s}.png", .{mod, id}); // Default to global assets.
			break :blk main.files.cwd().openFile(path) catch |err2| {
				std.log.err("File not found. Searched in \"{s}\" and also in the assetFolder \"{s}\"", .{path, assetFolder});
				return err2;
			};
		};
		file.close(); // It was only openend to check if it exists.
		// Otherwise read it into the list:
		result = @intCast(textureIDs.items.len);

		textureIDs.append(main.worldArena, main.worldArena.dupe(u8, path));
		return result;
	}

	pub fn getTextureIndices(zon: ZonElement, assetFolder: []const u8, textureIndicesRef: *[16]u16) void {
		const defaultIndex = findTexture(zon.get(?[]const u8, "texture", null), assetFolder) catch 0;
		inline for (textureIndicesRef, 0..) |*ref, i| {
			var textureId = zon.get(?[]const u8, std.fmt.comptimePrint("texture{}", .{i}), null);
			if (i < sideNames.len) {
				textureId = zon.get(?[]const u8, sideNames[i], textureId);
			}
			ref.* = findTexture(textureId, assetFolder) catch defaultIndex;
		}
	}

	pub fn register(assetFolder: []const u8, _: []const u8, zon: ZonElement) void {
		_modelIndex[meshes.size] = _mode[meshes.size].createBlockModel(.{.typ = @intCast(meshes.size), .data = 0}, &_modeData[meshes.size], zon.getChild("model"));

		// The actual model is loaded later, in the rendering thread.
		// But textures can be loaded here:

		getTextureIndices(zon, assetFolder, &textureIndices[meshes.size]);

		maxTextureCount[meshes.size] = @intCast(textureIDs.items.len);

		meshes.size += 1;
	}

	pub fn registerBlockBreakingAnimation(assetFolder: []const u8) void {
		var i: usize = 0;
		while (true) : (i += 1) {
			const path1 = std.fmt.allocPrint(main.stackAllocator.allocator, "assets/cubyz/blocks/textures/breaking/{}.png", .{i}) catch unreachable;
			defer main.stackAllocator.free(path1);
			const path2 = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/cubyz/blocks/textures/breaking/{}.png", .{assetFolder, i}) catch unreachable;
			defer main.stackAllocator.free(path2);
			if (!main.files.cwd().hasFile(path1) and !main.files.cwd().hasFile(path2)) break;

			const id = std.fmt.allocPrint(main.stackAllocator.allocator, "cubyz:breaking/{}", .{i}) catch unreachable;
			defer main.stackAllocator.free(id);
			blockBreakingTextures.append(main.worldArena, findTexture(id, assetFolder) catch break);
		}
	}

	pub fn preProcessAnimationData(time: u32) void {
		animationComputePipeline.bind();
		graphics.c.glUniform1ui(animationUniforms.time, time);
		graphics.c.glUniform1ui(animationUniforms.size, @intCast(animationData.len));
		graphics.c.glDispatchCompute(@intCast(@divFloor(animationData.len + 63, 64)), 1, 1); // TODO: Replace with @divCeil once available
		graphics.c.glMemoryBarrier(graphics.c.GL_SHADER_STORAGE_BARRIER_BIT);
	}

	fn finishTextureLoading() void {
		animationData = main.worldArena.alloc(AnimationData, textureIDs.items.len);
		textureOcclusionData = main.worldArena.alloc(std.atomic.Value(bool), textureIDs.items.len);
		for (textureIDs.items, 0..) |path, i| {
			readTextureData(i, path);
		}
	}

	pub fn reloadTextures(_: usize) void {
		blockTextures.clearRetainingCapacity();
		emissionTextures.clearRetainingCapacity();
		reflectivityTextures.clearRetainingCapacity();
		absorptionTextures.clearRetainingCapacity();
		textureFogData.clearRetainingCapacity();
		for (textureIDs.items, 0..) |path, i| {
			readTextureData(i, path);
		}
		generateTextureArray();
	}

	pub fn generateTextureArray() void {
		const c = graphics.c;
		blockTextureArray.generate(blockTextures.items, true, true);
		c.glTexParameterf(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MAX_ANISOTROPY, @floatFromInt(main.settings.anisotropicFiltering));
		emissionTextureArray.generate(emissionTextures.items, true, false);
		c.glTexParameterf(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MAX_ANISOTROPY, @floatFromInt(main.settings.anisotropicFiltering));
		const reflectivityAndAbsorptionTextures = main.stackAllocator.alloc(Image, reflectivityTextures.items.len);
		defer main.stackAllocator.free(reflectivityAndAbsorptionTextures);
		defer for (reflectivityAndAbsorptionTextures) |texture| {
			texture.deinit(main.stackAllocator);
		};
		for (reflectivityTextures.items, absorptionTextures.items, reflectivityAndAbsorptionTextures) |reflecitivityTexture, absorptionTexture, *resultTexture| {
			const width = @max(reflecitivityTexture.width, absorptionTexture.width);
			const height = @max(reflecitivityTexture.height, absorptionTexture.height);
			resultTexture.* = Image.init(main.stackAllocator, width, height);
			for (0..width) |x| {
				for (0..height) |y| {
					const reflectivity = reflecitivityTexture.getRGB(x*reflecitivityTexture.width/width, y*reflecitivityTexture.height/height);
					const absorption = absorptionTexture.getRGB(x*absorptionTexture.width/width, y*absorptionTexture.height/height);
					resultTexture.setRGB(x, y, .{.r = absorption.r, .g = absorption.g, .b = absorption.b, .a = reflectivity.r});
				}
			}
		}
		reflectivityAndAbsorptionTextureArray.generate(reflectivityAndAbsorptionTextures, true, false);
		c.glTexParameterf(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MAX_ANISOTROPY, @floatFromInt(main.settings.anisotropicFiltering));

		// Also generate additional buffers:
		if (animationSSBO) |ssbo| {
			ssbo.deinit();
		}
		if (animatedTextureSSBO) |ssbo| {
			ssbo.deinit();
		}
		if (fogSSBO) |ssbo| {
			ssbo.deinit();
		}
		animationSSBO = SSBO.initStatic(AnimationData, animationData);
		animationSSBO.?.bind(0);

		animatedTextureSSBO = SSBO.initStaticSize(u32, animationData.len);
		animatedTextureSSBO.?.bind(1);
		fogSSBO = SSBO.initStatic(FogData, textureFogData.items);
		fogSSBO.?.bind(7);
	}
};

```

`src/blueprint.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Compression = main.utils.Compression;
const ZonElement = @import("zon.zig").ZonElement;
const vec = main.vec;
const Vec3i = vec.Vec3i;

const Array3D = main.utils.Array3D;
const Block = main.blocks.Block;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const User = main.server.User;
const ServerChunk = main.chunk.ServerChunk;
const Degrees = main.rotation.Degrees;
const Tag = main.Tag;

const GameIdToBlueprintIdMapType = std.AutoHashMap(u16, u16);
const BlockIdSizeType = u32;
const BlockStorageType = u32;

const BinaryWriter = main.utils.BinaryWriter;
const BinaryReader = main.utils.BinaryReader;

const AliasTable = main.utils.AliasTable;
const ListUnmanaged = main.ListUnmanaged;

pub const blueprintVersion = 0;
var voidType: ?u16 = null;

pub const BlueprintCompression = enum(u16) {
	deflate,
};

pub const Blueprint = struct {
	blocks: Array3D(Block),

	pub fn init(allocator: NeverFailingAllocator) Blueprint {
		return .{.blocks = .init(allocator, 0, 0, 0)};
	}
	pub fn deinit(self: Blueprint, allocator: NeverFailingAllocator) void {
		self.blocks.deinit(allocator);
	}
	pub fn clone(self: Blueprint, allocator: NeverFailingAllocator) Blueprint {
		return .{.blocks = self.blocks.clone(allocator)};
	}
	pub fn rotateZ(self: Blueprint, allocator: NeverFailingAllocator, angle: Degrees) Blueprint {
		var new = Blueprint{
			.blocks = switch (angle) {
				.@"0", .@"180" => .init(allocator, self.blocks.width, self.blocks.depth, self.blocks.height),
				.@"90", .@"270" => .init(allocator, self.blocks.depth, self.blocks.width, self.blocks.height),
			},
		};

		for (0..self.blocks.width) |xOld| {
			for (0..self.blocks.depth) |yOld| {
				const xNew, const yNew = switch (angle) {
					.@"0" => .{xOld, yOld},
					.@"90" => .{new.blocks.width - yOld - 1, xOld},
					.@"180" => .{new.blocks.width - xOld - 1, new.blocks.depth - yOld - 1},
					.@"270" => .{yOld, new.blocks.depth - xOld - 1},
				};

				for (0..self.blocks.height) |z| {
					const block = self.blocks.get(xOld, yOld, z);
					new.blocks.set(xNew, yNew, z, block.rotateZ(angle));
				}
			}
		}
		return new;
	}

	const CaptureResult = union(enum) {
		success: Blueprint,
		failure: struct { pos: Vec3i, message: []const u8 },
	};

	pub fn capture(allocator: NeverFailingAllocator, pos1: Vec3i, pos2: Vec3i) CaptureResult {
		const startX = @min(pos1[0], pos2[0]);
		const startY = @min(pos1[1], pos2[1]);
		const startZ = @min(pos1[2], pos2[2]);

		const endX = @max(pos1[0], pos2[0]);
		const endY = @max(pos1[1], pos2[1]);
		const endZ = @max(pos1[2], pos2[2]);

		const sizeX: u32 = @intCast(endX - startX + 1);
		const sizeY: u32 = @intCast(endY - startY + 1);
		const sizeZ: u32 = @intCast(endZ - startZ + 1);

		const self = Blueprint{.blocks = .init(allocator, sizeX, sizeY, sizeZ)};

		for (0..sizeX) |x| {
			const worldX = startX +% @as(i32, @intCast(x));

			for (0..sizeY) |y| {
				const worldY = startY +% @as(i32, @intCast(y));

				for (0..sizeZ) |z| {
					const worldZ = startZ +% @as(i32, @intCast(z));

					const maybeBlock = main.server.world.?.getBlock(worldX, worldY, worldZ);
					if (maybeBlock) |block| {
						self.blocks.set(x, y, z, block);
					} else {
						return .{.failure = .{.pos = .{worldX, worldY, worldZ}, .message = "Chunk containing block not loaded."}};
					}
				}
			}
		}
		return .{.success = self};
	}

	pub const PasteMode = enum { all, degradable };

	pub fn pasteInGeneration(self: Blueprint, pos: Vec3i, chunk: *ServerChunk, mode: PasteMode) void {
		switch (mode) {
			inline else => |comptimeMode| _pasteInGeneration(self, pos, chunk, comptimeMode),
		}
	}

	fn _pasteInGeneration(self: Blueprint, pos: Vec3i, chunk: *ServerChunk, comptime mode: PasteMode) void {
		const indexEndX: i32 = @min(@as(i32, chunk.super.width) - pos[0], @as(i32, @intCast(self.blocks.width)));
		const indexEndY: i32 = @min(@as(i32, chunk.super.width) - pos[1], @as(i32, @intCast(self.blocks.depth)));
		const indexEndZ: i32 = @min(@as(i32, chunk.super.width) - pos[2], @as(i32, @intCast(self.blocks.height)));

		var indexX: u31 = @max(0, -pos[0]);
		while (indexX < indexEndX) : (indexX += chunk.super.pos.voxelSize) {
			var indexY: u31 = @max(0, -pos[1]);
			while (indexY < indexEndY) : (indexY += chunk.super.pos.voxelSize) {
				var indexZ: u31 = @max(0, -pos[2]);
				while (indexZ < indexEndZ) : (indexZ += chunk.super.pos.voxelSize) {
					const block = self.blocks.get(indexX, indexY, indexZ);

					if (block.typ == voidType) continue;

					const chunkX = indexX + pos[0];
					const chunkY = indexY + pos[1];
					const chunkZ = indexZ + pos[2];
					switch (mode) {
						.all => chunk.updateBlockInGeneration(chunkX, chunkY, chunkZ, block),
						.degradable => chunk.updateBlockIfDegradable(chunkX, chunkY, chunkZ, block),
					}
				}
			}
		}
	}

	pub const PasteFlags = struct {
		preserveVoid: bool = false,
	};

	pub fn paste(self: Blueprint, pos: Vec3i, flags: PasteFlags) void {
		const startX = pos[0];
		const startY = pos[1];
		const startZ = pos[2];

		for (0..self.blocks.width) |x| {
			const worldX = startX +% @as(i32, @intCast(x));

			for (0..self.blocks.depth) |y| {
				const worldY = startY +% @as(i32, @intCast(y));

				for (0..self.blocks.height) |z| {
					const worldZ = startZ +% @as(i32, @intCast(z));

					const block = self.blocks.get(x, y, z);
					if (block.typ != voidType or flags.preserveVoid)
						_ = main.server.world.?.updateBlock(worldX, worldY, worldZ, block);
				}
			}
		}
	}
	pub fn load(allocator: NeverFailingAllocator, inputBuffer: []const u8) !Blueprint {
		var compressedReader = BinaryReader.init(inputBuffer);
		const version = try compressedReader.readInt(u16);

		if (version > blueprintVersion) {
			std.log.err("Blueprint version {d} is not supported. Current version is {d}.", .{version, blueprintVersion});
			return error.UnsupportedVersion;
		}
		const compression = try compressedReader.readEnum(BlueprintCompression);
		const blockPaletteSizeBytes = try compressedReader.readInt(u32);
		const paletteBlockCount = try compressedReader.readInt(u16);
		const width = try compressedReader.readInt(u16);
		const depth = try compressedReader.readInt(u16);
		const height = try compressedReader.readInt(u16);

		const self = Blueprint{.blocks = .init(allocator, width, depth, height)};

		const decompressedData = try self.decompressBuffer(compressedReader.remaining, blockPaletteSizeBytes, compression);
		defer main.stackAllocator.free(decompressedData);
		var decompressedReader = BinaryReader.init(decompressedData);

		const palette = try loadBlockPalette(main.stackAllocator, paletteBlockCount, &decompressedReader);
		defer main.stackAllocator.free(palette);

		const blueprintIdToGameIdMap = makeBlueprintIdToGameIdMap(main.stackAllocator, palette);
		defer main.stackAllocator.free(blueprintIdToGameIdMap);

		for (self.blocks.mem) |*block| {
			const blueprintBlockRaw = try decompressedReader.readInt(BlockStorageType);

			const blueprintBlock = Block.fromInt(blueprintBlockRaw);
			const gameBlockId = blueprintIdToGameIdMap[blueprintBlock.typ];

			block.* = .{.typ = gameBlockId, .data = blueprintBlock.data};
		}
		return self;
	}
	pub fn store(self: Blueprint, allocator: NeverFailingAllocator) []u8 {
		var gameIdToBlueprintId = self.makeGameIdToBlueprintIdMap(main.stackAllocator);
		defer gameIdToBlueprintId.deinit();
		std.debug.assert(gameIdToBlueprintId.count() != 0);

		var uncompressedWriter = BinaryWriter.init(main.stackAllocator);
		defer uncompressedWriter.deinit();

		const blockPaletteSizeBytes = storeBlockPalette(gameIdToBlueprintId, &uncompressedWriter);

		for (self.blocks.mem) |block| {
			const blueprintBlock: BlockStorageType = Block.toInt(.{.typ = gameIdToBlueprintId.get(block.typ).?, .data = block.data});
			uncompressedWriter.writeInt(BlockStorageType, blueprintBlock);
		}

		const compressed = self.compressOutputBuffer(main.stackAllocator, uncompressedWriter.data.items);
		defer main.stackAllocator.free(compressed.data);

		var outputWriter = BinaryWriter.initCapacity(allocator, @sizeOf(i16) + @sizeOf(BlueprintCompression) + @sizeOf(u32) + @sizeOf(u16)*4 + compressed.data.len);

		outputWriter.writeInt(u16, blueprintVersion);
		outputWriter.writeEnum(BlueprintCompression, compressed.mode);
		outputWriter.writeInt(u32, @intCast(blockPaletteSizeBytes));
		outputWriter.writeInt(u16, @intCast(gameIdToBlueprintId.count()));
		outputWriter.writeInt(u16, @intCast(self.blocks.width));
		outputWriter.writeInt(u16, @intCast(self.blocks.depth));
		outputWriter.writeInt(u16, @intCast(self.blocks.height));

		outputWriter.writeSlice(compressed.data);

		return outputWriter.data.toOwnedSlice();
	}
	fn makeBlueprintIdToGameIdMap(allocator: NeverFailingAllocator, palette: [][]const u8) []u16 {
		var blueprintIdToGameIdMap = allocator.alloc(u16, palette.len);

		for (palette, 0..) |blockName, blueprintBlockId| {
			const gameBlockId = main.blocks.getBlockByIdWithMigrations(blockName) catch |err| blk: {
				std.log.err("Couldn't find block with name {s}: {s}. Replacing it with air", .{blockName, @errorName(err)});
				break :blk 0;
			};
			blueprintIdToGameIdMap[blueprintBlockId] = gameBlockId;
		}
		return blueprintIdToGameIdMap;
	}
	fn makeGameIdToBlueprintIdMap(self: Blueprint, allocator: NeverFailingAllocator) GameIdToBlueprintIdMapType {
		var gameIdToBlueprintId: GameIdToBlueprintIdMapType = .init(allocator.allocator);

		for (self.blocks.mem) |block| {
			const result = gameIdToBlueprintId.getOrPut(block.typ) catch unreachable;
			if (!result.found_existing) {
				result.value_ptr.* = @intCast(gameIdToBlueprintId.count() - 1);
			}
		}

		return gameIdToBlueprintId;
	}
	fn loadBlockPalette(allocator: NeverFailingAllocator, paletteBlockCount: usize, reader: *BinaryReader) ![][]const u8 {
		var palette = allocator.alloc([]const u8, paletteBlockCount);

		for (0..@intCast(paletteBlockCount)) |index| {
			const blockNameSize = try reader.readInt(BlockIdSizeType);
			const blockName = try reader.readSlice(blockNameSize);
			palette[index] = blockName;
		}
		return palette;
	}
	fn storeBlockPalette(map: GameIdToBlueprintIdMapType, writer: *BinaryWriter) usize {
		var blockPalette = main.stackAllocator.alloc([]const u8, map.count());
		defer main.stackAllocator.free(blockPalette);

		var iterator = map.iterator();
		while (iterator.next()) |entry| {
			const block = Block{.typ = entry.key_ptr.*, .data = 0};
			const blockId = block.id();
			blockPalette[entry.value_ptr.*] = blockId;
		}

		std.log.info("Blueprint block palette:", .{});

		for (0..blockPalette.len) |index| {
			const blockName = blockPalette[index];
			std.log.info("palette[{d}]: {s}", .{index, blockName});

			writer.writeInt(BlockIdSizeType, @intCast(blockName.len));
			writer.writeSlice(blockName);
		}

		return writer.data.items.len;
	}
	fn decompressBuffer(self: Blueprint, data: []const u8, blockPaletteSizeBytes: usize, compression: BlueprintCompression) ![]u8 {
		const blockArraySizeBytes = self.blocks.width*self.blocks.depth*self.blocks.height*@sizeOf(BlockStorageType);
		const decompressedDataSizeBytes = blockPaletteSizeBytes + blockArraySizeBytes;

		const decompressedData = main.stackAllocator.alloc(u8, decompressedDataSizeBytes);

		switch (compression) {
			.deflate => {
				const sizeAfterDecompression = try Compression.inflateTo(decompressedData, data);
				std.debug.assert(sizeAfterDecompression == decompressedDataSizeBytes);
			},
		}
		return decompressedData;
	}
	fn compressOutputBuffer(_: Blueprint, allocator: NeverFailingAllocator, decompressedData: []u8) struct { mode: BlueprintCompression, data: []u8 } {
		const compressionMode: BlueprintCompression = .deflate;
		switch (compressionMode) {
			.deflate => {
				return .{.mode = .deflate, .data = Compression.deflate(allocator, decompressedData, .default)};
			},
		}
	}
	pub fn replace(self: *Blueprint, whitelist: ?Mask, blacklist: ?Mask, newBlocks: Pattern) void {
		for (0..self.blocks.width) |x| {
			for (0..self.blocks.depth) |y| {
				for (0..self.blocks.height) |z| {
					const current = self.blocks.get(x, y, z);
					if (whitelist) |m| if (!m.match(current)) continue;
					if (blacklist) |m| if (m.match(current)) continue;
					self.blocks.set(x, y, z, newBlocks.blocks.sample(&main.seed).block);
				}
			}
		}
	}
};

pub const Pattern = struct {
	const weightSeparator = '%';
	const expressionSeparator = ',';

	blocks: AliasTable(Entry),

	const Entry = struct {
		block: Block,
		chance: f32,
	};

	pub fn initFromString(allocator: NeverFailingAllocator, source: []const u8) !@This() {
		var specifiers = std.mem.splitScalar(u8, source, expressionSeparator);
		var totalWeight: f32 = 0;

		var weightedEntries: ListUnmanaged(struct { block: Block, weight: f32 }) = .{};
		defer weightedEntries.deinit(main.stackAllocator);

		while (specifiers.next()) |specifier| {
			var blockId = specifier;
			var weight: f32 = 1.0;

			if (std.mem.containsAtLeastScalar(u8, specifier, 1, weightSeparator)) {
				var iterator = std.mem.splitScalar(u8, specifier, weightSeparator);
				const weightString = iterator.first();
				blockId = iterator.rest();

				weight = std.fmt.parseFloat(f32, weightString) catch return error.@"Weight not a valid number";
				if (weight <= 0) return error.@"Weight must be greater than 0";
			}

			_ = main.blocks.getBlockById(blockId) catch return error.@"Block not found";
			const block = main.blocks.parseBlock(blockId);

			totalWeight += weight;
			weightedEntries.append(main.stackAllocator, .{.block = block, .weight = weight});
		}

		const entries = allocator.alloc(Entry, weightedEntries.items.len);
		for (weightedEntries.items, 0..) |entry, i| {
			entries[i] = .{.block = entry.block, .chance = entry.weight/totalWeight};
		}

		return .{.blocks = .init(allocator, entries)};
	}

	pub fn deinit(self: @This(), allocator: NeverFailingAllocator) void {
		self.blocks.deinit(allocator);
		allocator.free(self.blocks.items);
	}
};

pub const Mask = struct {
	const AndList = ListUnmanaged(Entry);
	const OrList = ListUnmanaged(AndList);

	entries: OrList,

	const or_ = '|';
	const and_ = '&';
	const inverse = '!';
	const tag = '$';
	const property = '@';

	const Entry = struct {
		inner: Inner,
		isInverse: bool,

		const Inner = union(enum) {
			block: Block,
			blockType: u16,
			blockTag: Tag,
			blockProperty: Property,

			const Property = blk: {
				var tempFields: [@typeInfo(Block).@"struct".decls.len]std.builtin.Type.EnumField = undefined;
				var count = 0;

				for (std.meta.declarations(Block)) |decl| {
					const declInfo = @typeInfo(@TypeOf(@field(Block, decl.name)));
					if (declInfo != .@"fn") continue;
					if (declInfo.@"fn".return_type != bool) continue;
					if (declInfo.@"fn".params.len != 1) continue;

					tempFields[count] = .{.name = decl.name, .value = count};
					count += 1;
				}

				const outFields: [count]std.builtin.Type.EnumField = tempFields[0..count].*;

				break :blk @Type(.{.@"enum" = .{
					.tag_type = u8,
					.fields = &outFields,
					.decls = &.{},
					.is_exhaustive = true,
				}});
			};

			fn initFromString(specifier: []const u8) !Inner {
				return switch (specifier[0]) {
					tag => .{.blockTag = Tag.get(specifier[1..]) orelse return error.TagNotFound},
					property => .{.blockProperty = std.meta.stringToEnum(Property, specifier[1..]) orelse return error.PropertyNotFound},
					else => return try parseBlockLike(specifier),
				};
			}

			fn match(self: Inner, block: Block) bool {
				return switch (self) {
					.block => |desired| block.typ == desired.typ and block.data == desired.data,
					.blockType => |desired| block.typ == desired,
					.blockTag => |desired| block.hasTag(desired),
					.blockProperty => |blockProperty| switch (blockProperty) {
						inline else => |prop| @field(Block, @tagName(prop))(block),
					},
				};
			}
		};

		fn initFromString(specifier: []const u8) !Entry {
			const isInverse = specifier[0] == '!';
			const entry = try Inner.initFromString(specifier[if (isInverse) 1 else 0..]);
			return .{.inner = entry, .isInverse = isInverse};
		}

		pub fn match(self: Entry, block: Block) bool {
			const isMatch = self.inner.match(block);
			if (self.isInverse) {
				return !isMatch;
			}
			return isMatch;
		}
	};

	pub fn initFromString(allocator: NeverFailingAllocator, source: []const u8) !@This() {
		var result: @This() = .{.entries = .{}};
		errdefer result.deinit(allocator);

		var oredExpressions = std.mem.splitScalar(u8, source, or_);
		while (oredExpressions.next()) |subExpression| {
			if (subExpression.len == 0) return error.MissingExpression;

			var andStorage: AndList = .{};
			errdefer andStorage.deinit(allocator);

			var andedExpressions = std.mem.splitScalar(u8, subExpression, and_);
			while (andedExpressions.next()) |specifier| {
				if (specifier.len == 0) return error.MissingExpression;

				const entry = try Entry.initFromString(specifier);
				andStorage.append(allocator, entry);
			}
			std.debug.assert(andStorage.items.len != 0);

			result.entries.append(allocator, andStorage);
		}
		std.debug.assert(result.entries.items.len != 0);

		return result;
	}

	pub fn deinit(self: @This(), allocator: NeverFailingAllocator) void {
		for (self.entries.items) |andStorage| {
			andStorage.deinit(allocator);
		}
		self.entries.deinit(allocator);
	}

	pub fn match(self: @This(), block: Block) bool {
		for (self.entries.items) |andedExpressions| {
			const status = blk: {
				for (andedExpressions.items) |expression| {
					if (!expression.match(block)) break :blk false;
				}
				break :blk true;
			};

			if (status) return true;
		}
		return false;
	}
};

fn parseBlockLike(block: []const u8) error{ DataParsingFailed, IdParsingFailed }!Mask.Entry.Inner {
	if (@import("builtin").is_test) return try Test.parseBlockLikeTest(block);
	const typ = main.blocks.getBlockById(block) catch return error.IdParsingFailed;
	const dataNullable = main.blocks.getBlockData(block) catch return error.DataParsingFailed;
	if (dataNullable) |data| return .{.block = .{.typ = typ, .data = data}};
	return .{.blockType = typ};
}

const Test = struct {
	var parseBlockLikeTest: *const @TypeOf(parseBlockLike) = &defaultParseBlockLike;

	fn defaultParseBlockLike(_: []const u8) !Mask.Entry.Inner {
		unreachable;
	}

	fn @"parseBlockLike 1 null"(_: []const u8) !Mask.Entry.Inner {
		return .{.blockType = 1};
	}
	fn @"parseBlockLike 1 1"(_: []const u8) !Mask.Entry.Inner {
		return .{.block = .{.typ = 1, .data = 1}};
	}

	fn @"parseBlockLike foo or bar"(data: []const u8) !Mask.Entry.Inner {
		if (std.mem.eql(u8, data, "addon:foo")) {
			return .{.block = .{.typ = 1, .data = 0}};
		}
		if (std.mem.eql(u8, data, "addon:bar")) {
			return .{.block = .{.typ = 2, .data = 0}};
		}
		unreachable;
	}
};

test "Mask match block type with any data" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	const mask = try Mask.initFromString(main.heap.testingAllocator, "addon:dummy");
	defer mask.deinit(main.heap.testingAllocator);

	try std.testing.expect(mask.match(.{.typ = 1, .data = 0}));
	try std.testing.expect(mask.match(.{.typ = 1, .data = 1}));
	try std.testing.expect(!mask.match(.{.typ = 2, .data = 0}));
}

test "Mask empty negative case" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	try std.testing.expectError(error.MissingExpression, Mask.initFromString(main.heap.testingAllocator, ""));
}

test "Mask half-or negative case" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	try std.testing.expectError(error.MissingExpression, Mask.initFromString(main.heap.testingAllocator, "addon:dummy|"));
}

test "Mask half-or negative case 2" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	try std.testing.expectError(error.MissingExpression, Mask.initFromString(main.heap.testingAllocator, "|addon:dummy"));
}

test "Mask half-and negative case" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	try std.testing.expectError(error.MissingExpression, Mask.initFromString(main.heap.testingAllocator, "addon:dummy&"));
}

test "Mask half-and negative case 2" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	try std.testing.expectError(error.MissingExpression, Mask.initFromString(main.heap.testingAllocator, "&addon:dummy"));
}

test "Mask inverse match block type with any data" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 null";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	const mask = try Mask.initFromString(main.heap.testingAllocator, "!addon:dummy");
	defer mask.deinit(main.heap.testingAllocator);

	try std.testing.expect(!mask.match(.{.typ = 1, .data = 0}));
	try std.testing.expect(!mask.match(.{.typ = 1, .data = 1}));
	try std.testing.expect(mask.match(.{.typ = 2, .data = 0}));
}

test "Mask match block type with exact data" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike 1 1";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	const mask = try Mask.initFromString(main.heap.testingAllocator, "addon:dummy");
	defer mask.deinit(main.heap.testingAllocator);

	try std.testing.expect(!mask.match(.{.typ = 1, .data = 0}));
	try std.testing.expect(mask.match(.{.typ = 1, .data = 1}));
	try std.testing.expect(!mask.match(.{.typ = 2, .data = 1}));
}

test "Mask match type 0 or type 1 with exact data" {
	Test.parseBlockLikeTest = &Test.@"parseBlockLike foo or bar";
	defer Test.parseBlockLikeTest = &Test.defaultParseBlockLike;

	const mask = try Mask.initFromString(main.heap.testingAllocator, "addon:foo|addon:bar");
	defer mask.deinit(main.heap.testingAllocator);

	try std.testing.expect(mask.match(.{.typ = 1, .data = 0}));
	try std.testing.expect(mask.match(.{.typ = 2, .data = 0}));
	try std.testing.expect(!mask.match(.{.typ = 1, .data = 1}));
	try std.testing.expect(!mask.match(.{.typ = 2, .data = 1}));
}

pub fn registerVoidBlock(block: Block) void {
	voidType = block.typ;
	std.debug.assert(voidType != 0);
}

pub fn getVoidBlock() Block {
	return Block{.typ = voidType.?, .data = 0};
}

```

`src/callbacks/block/client/_list.zig`:

```zig
pub const openWindow = @import("openWindow.zig");

```

`src/callbacks/block/client/openWindow.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Block = main.blocks.Block;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

windowName: []const u8,

pub fn init(zon: ZonElement) ?*@This() {
	const result = main.worldArena.create(@This());
	result.* = .{
		.windowName = main.worldArena.dupe(u8, zon.get(?[]const u8, "name", null) orelse {
			std.log.err("Missing field \"name\" for openWindow event.", .{});
			return null;
		}),
	};
	return result;
}

pub fn run(self: *@This(), _: main.callbacks.ClientBlockCallback.Params) main.callbacks.Result {
	main.gui.openWindow(self.windowName);
	main.Window.setMouseGrabbed(false);
	return .handled;
}

```

`src/callbacks/block/server/_list.zig`:

```zig
pub const checkSupportBlocks = @import("checkSupportBlocks.zig");
pub const decay = @import("decay.zig");
pub const replaceBlock = @import("replaceBlock.zig");

```

`src/callbacks/block/server/checkSupportBlocks.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Block = main.blocks.Block;
const blocks = main.blocks;
const Neighbor = main.chunk.Neighbor;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const ZonElement = main.ZonElement;
const server = main.server;

pub fn init(_: ZonElement) ?*@This() {
	return @as(*@This(), undefined);
}

pub fn run(_: *@This(), params: main.callbacks.ServerBlockCallback.Params) main.callbacks.Result {
	const wx = params.chunk.super.pos.wx + params.blockPos.x;
	const wy = params.chunk.super.pos.wy + params.blockPos.y;
	const wz = params.chunk.super.pos.wz + params.blockPos.z;

	var neighborSupportive: [6]bool = undefined;

	for (Neighbor.iterable) |neighbor| {
		const neighborBlock: Block = main.server.world.?.getBlock(wx +% neighbor.relX(), wy +% neighbor.relY(), wz +% neighbor.relZ()) orelse .{.typ = 0, .data = 0};
		const neighborModel = main.blocks.meshes.model(neighborBlock).model();
		neighborSupportive[neighbor.toInt()] = !neighborBlock.replacable() and neighborModel.neighborFacingQuads[neighbor.reverse().toInt()].len != 0;
	}

	var newBlock: Block = params.block;

	inline for (comptime std.meta.declarations(main.rotation.list)) |rotationMode| {
		if (params.block.mode() == main.rotation.getByID(rotationMode.name)) {
			if (@hasDecl(@field(main.rotation.list, rotationMode.name), "updateBlockFromNeighborConnectivity")) {
				@field(main.rotation.list, rotationMode.name).updateBlockFromNeighborConnectivity(&newBlock, neighborSupportive);
			} else {
				std.log.err("Rotation mode {s} has no updateBlockFromNeighborConnectivity function and cannot be used for {s} callback", .{rotationMode.name, @typeName(@This())});
			}
		}
	}

	if (newBlock == params.block) return .ignored;

	if (main.server.world.?.cmpxchgBlock(wx, wy, wz, params.block, newBlock) == null) {
		const dropAmount = params.block.mode().itemDropsOnChange(params.block, newBlock);
		const drops = params.block.blockDrops();
		for (0..dropAmount) |_| {
			for (drops) |drop| {
				if (drop.chance == 1 or main.random.nextFloat(&main.seed) < drop.chance) {
					for (drop.items) |stack| {
						var dir = main.vec.normalize(main.random.nextFloatVectorSigned(3, &main.seed));
						// Bias upwards
						dir[2] += main.random.nextFloat(&main.seed)*4.0;
						const model = params.block.mode().model(params.block).model();
						const pos = Vec3f{
							@as(f32, @floatFromInt(wx)) + model.min[0] + main.random.nextFloat(&main.seed)*(model.max[0] - model.min[0]),
							@as(f32, @floatFromInt(wy)) + model.min[1] + main.random.nextFloat(&main.seed)*(model.max[1] - model.min[1]),
							@as(f32, @floatFromInt(wz)) + model.min[2] + main.random.nextFloat(&main.seed)*(model.max[2] - model.min[2]),
						};
						main.server.world.?.drop(stack.clone(), pos, dir, 1);
					}
				}
			}
		}
		return .handled;
	}
	return .ignored;
}

```

`src/callbacks/block/server/decay.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Block = main.blocks.Block;
const blocks = main.blocks;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const ZonElement = main.ZonElement;
const server = main.server;
const Branch = main.rotation.list.@"cubyz:branch";

decayReplacement: blocks.Block,
prevention: []const main.Tag,
blockDrops: ?[]const blocks.BlockDrop,

pub fn init(zon: ZonElement) ?*@This() {
	const result = main.worldArena.create(@This());
	// replacement
	if (zon.get(?[]const u8, "replacement", null)) |blockname| {
		result.decayReplacement = main.blocks.parseBlock(blockname);
	} else result.decayReplacement = main.blocks.Block.air;
	// custom drop
	if (zon.getChildOrNull("drops")) |_| {
		result.blockDrops = blocks.loadBlockDrop(null, zon);
	} else result.blockDrops = null;
	// prevention
	result.prevention = &.{};
	if (zon.getChildOrNull("prevention")) |tagNames| {
		if (tagNames == .array) {
			var prevention = main.ListUnmanaged(main.Tag).initCapacity(main.worldArena, tagNames.array.items.len);
			for (tagNames.array.items) |value| {
				const tagName = value.as(?[]const u8, null) orelse {
					std.log.err("Invalid TagName for decay prevention.", .{});
					continue;
				};
				prevention.appendAssumeCapacity(main.Tag.find(tagName));
			}
			result.prevention = prevention.items;
		}
	}
	return result;
}
fn getIndexInCheckArray(relativePosition: Vec3i, checkRange: comptime_int) usize {
	const checkLength = checkRange*2 + 1;

	const arrayIndexX = relativePosition[0] + checkRange;
	const arrayIndexY = relativePosition[1] + checkRange;
	const arrayIndexZ = relativePosition[2] + checkRange;
	return @as(usize, @intCast((arrayIndexX*checkLength + arrayIndexY)*checkLength + arrayIndexZ));
}
fn preventsDecay(self: *@This(), log: Block) bool {
	for (self.prevention) |tag| {
		if (log.hasTag(tag))
			return true;
	}
	return false;
}
fn foundWayToLog(self: *@This(), world: *server.ServerWorld, leaf: Block, wx: i32, wy: i32, wz: i32) bool {

	// init array to mark already searched blocks.
	const checkRange = 5;
	const checkLength = checkRange*2 + 1;
	var checked: [checkLength*checkLength*checkLength]bool = undefined;
	for (0..checkLength*checkLength*checkLength) |i| {
		checked[i] = false;
	}

	// queue for breadth-first search
	var queue = main.utils.CircularBufferQueue(Vec3i).init(main.stackAllocator, 32);
	defer queue.deinit();

	queue.pushBack(Vec3i{0, 0, 0});
	checked[getIndexInCheckArray(Vec3i{0, 0, 0}, checkRange)] = true;

	const branchRotation = main.rotation.getByID("cubyz:branch");
	const sourceIsBranch = leaf.mode() == branchRotation;

	while (queue.popFront()) |value| {
		// get the (potential) log
		if (world.getBlock(value[0] +% wx, value[1] +% wy, value[2] +% wz)) |log| {
			// it is a log ? end search.
			if (self.preventsDecay(log)) {
				return true;
			}

			// it is the same type of leaf? continue search! (Don't do it for branches. We've got isConnected instead!)
			if (!sourceIsBranch and log.typ != leaf.typ) continue;
			if (sourceIsBranch and log.mode() != branchRotation and !log.viewThrough()) return true;
			const branchData = Branch.BranchData.init(log.data);

			for (main.chunk.Neighbor.iterable) |offset| {
				const relativePosition = value + offset.relPos();

				// out of range
				if (vec.lengthSquare(relativePosition) > checkRange*checkRange)
					continue;
				if (sourceIsBranch and !branchData.isConnected(offset))
					continue;

				// mark as checked
				if (checked[getIndexInCheckArray(relativePosition, checkRange)])
					continue;
				checked[getIndexInCheckArray(relativePosition, checkRange)] = true;
				queue.pushBack(relativePosition);
			}
		}
	}
	return false;
}
pub fn run(self: *@This(), params: main.callbacks.ServerBlockCallback.Params) main.callbacks.Result {
	const wx = params.chunk.super.pos.wx + params.blockPos.x;
	const wy = params.chunk.super.pos.wy + params.blockPos.y;
	const wz = params.chunk.super.pos.wz + params.blockPos.z;

	if (params.block.mode() == main.rotation.getByID("cubyz:decayable")) {
		if (params.block.data != 0)
			return .ignored;
	} else if (params.block.mode() == main.rotation.getByID("cubyz:branch")) {
		const bd = Branch.BranchData.init(params.block.data);
		if (bd.placedByHuman)
			return .ignored;
	} else {
		std.log.err("Expected {s} to have cubyz:decayable or cubyz:branch as rotation", .{params.block.id()});
	}

	if (server.world) |world| {
		if (world.getBlock(wx, wy, wz)) |leaf| {
			// check if there is any log in the proximity?^
			if (self.foundWayToLog(world, leaf, wx, wy, wz))
				return .ignored;

			// no, there is no log in proximity
			if (world.cmpxchgBlock(wx, wy, wz, leaf, self.decayReplacement) == null) {
				const drops = if (self.blockDrops) |blockDrops| blockDrops else params.block.blockDrops();
				for (drops) |drop| {
					if (drop.chance == 1 or main.random.nextFloat(&main.seed) < drop.chance) {
						for (drop.items) |stack| {
							var dir = main.vec.normalize(main.random.nextFloatVectorSigned(3, &main.seed));
							// Bias upwards
							dir[2] += main.random.nextFloat(&main.seed)*4.0;
							const model = leaf.mode().model(leaf).model();
							const pos = Vec3f{
								@as(f32, @floatFromInt(wx)) + model.min[0] + main.random.nextFloat(&main.seed)*(model.max[0] - model.min[0]),
								@as(f32, @floatFromInt(wy)) + model.min[1] + main.random.nextFloat(&main.seed)*(model.max[1] - model.min[1]),
								@as(f32, @floatFromInt(wz)) + model.min[2] + main.random.nextFloat(&main.seed)*(model.max[2] - model.min[2]),
							};
							main.server.world.?.drop(stack.clone(), pos, dir, 1);
						}
					}
				}
				return .handled;
			}
		}
	}
	return .ignored;
}

```

`src/callbacks/block/server/replaceBlock.zig`:

```zig
const std = @import("std");

const main = @import("main");

block: main.blocks.Block,

pub fn init(zon: main.ZonElement) ?*@This() {
	const result = main.worldArena.create(@This());
	result.* = .{
		.block = main.blocks.parseBlock(zon.get(?[]const u8, "block", null) orelse {
			std.log.err("Missing field \"block\" for replaceBlock event", .{});
			return null;
		}),
	};
	return result;
}

pub fn run(self: *@This(), params: main.callbacks.ServerBlockCallback.Params) main.callbacks.Result {
	const wx = params.chunk.super.pos.wx + params.blockPos.x;
	const wy = params.chunk.super.pos.wy + params.blockPos.y;
	const wz = params.chunk.super.pos.wz + params.blockPos.z;

	_ = main.server.world.?.cmpxchgBlock(wx, wy, wz, params.block, self.block);
	return .handled;
}

```

`src/callbacks/block/touch/_list.zig`:

```zig
pub const hurt = @import("hurt.zig");

```

`src/callbacks/block/touch/hurt.zig`:

```zig
const std = @import("std");

const main = @import("main");

dps: f32,
damageType: main.game.DamageType,

pub fn init(zon: main.ZonElement) ?*@This() {
	const result = main.worldArena.create(@This());
	result.* = .{
		.dps = zon.get(?f32, "dps", null) orelse {
			std.log.err("Missing field \"dps\" for hurt event", .{});
			return null;
		},
		.damageType = std.meta.stringToEnum(main.game.DamageType, zon.get(?[]const u8, "damageType", null) orelse {
			std.log.err("Missing field \"damageType\" for hurt event", .{});
			return null;
		}) orelse {
			std.log.err("Unknown damage type for hurt event", .{});
			return null;
		},
	};
	return result;
}

pub fn run(self: *@This(), params: main.callbacks.BlockTouchCallback.Params) main.callbacks.Result {
	std.debug.assert(params.entity == &main.game.Player.super); // TODO: Implement on the server side
	const damage = self.dps*@as(f32, @floatCast(params.deltaTime));
	main.sync.addHealth(-damage, self.damageType, .client, main.game.Player.id);
	return .handled;
}

```

`src/callbacks/callbacks.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Block = main.blocks.Block;
const vec = main.vec;
const Vec3i = vec.Vec3i;

pub const ClientBlockCallback = Callback(struct { block: Block, blockPos: Vec3i }, @import("block/client/_list.zig"));
pub const ServerBlockCallback = Callback(struct { block: Block, chunk: *main.chunk.ServerChunk, blockPos: main.chunk.BlockPos }, @import("block/server/_list.zig"));

pub const BlockTouchCallback = Callback(struct { entity: *main.server.Entity, source: Block, blockPos: Vec3i, deltaTime: f64 }, @import("block/touch/_list.zig"));

pub const Result = enum { handled, ignored };

pub fn init() void {
	ClientBlockCallback.globalInit();
	ServerBlockCallback.globalInit();
	BlockTouchCallback.globalInit();
}

fn Callback(_Params: type, list: type) type {
	return struct {
		data: *anyopaque,
		inner: *const fn (self: *anyopaque, params: Params) Result,

		pub const Params = _Params;

		const VTable = struct {
			init: *const fn (zon: main.ZonElement) ?*anyopaque,
			run: *const fn (self: *anyopaque, params: Params) Result,
		};

		var eventCreationMap: std.StringHashMapUnmanaged(VTable) = .{};

		fn globalInit() void {
			inline for (@typeInfo(list).@"struct".decls) |decl| {
				const CallbackStruct = @field(list, decl.name);
				eventCreationMap.put(main.globalArena.allocator, decl.name, .{
					.init = main.meta.castFunctionReturnToOptionalAnyopaque(CallbackStruct.init),
					.run = main.meta.castFunctionSelfToAnyopaque(CallbackStruct.run),
				}) catch unreachable;
			}
		}

		pub fn init(zon: main.ZonElement) ?@This() {
			const typ = zon.get(?[]const u8, "type", null) orelse {
				std.log.err("Missing field \"type\"", .{});
				return null;
			};
			const vtable = eventCreationMap.get(typ) orelse {
				std.log.err("Couldn't find block interact event {s}", .{typ});
				return null;
			};
			return .{
				.data = vtable.init(zon) orelse return null,
				.inner = vtable.run,
			};
		}

		pub const noop: @This() = .{
			.data = undefined,
			.inner = &noopCallback,
		};

		fn noopCallback(_: *anyopaque, _: Params) Result {
			return .ignored;
		}

		pub fn run(self: @This(), params: Params) Result {
			return self.inner(self.data, params);
		}

		pub fn isNoop(self: @This()) bool {
			return self.inner == &noopCallback;
		}
	};
}

pub const SimpleCallback = struct {
	data: *anyopaque = undefined,
	inner: ?*const fn (*anyopaque) void = null,

	fn genericWrapper(callbackFunction: fn () void) *const fn (*anyopaque) void {
		return &struct {
			fn wrapper(_: *anyopaque) void {
				callbackFunction();
			}
		}.wrapper;
	}

	pub fn init(comptime callbackFunction: fn () void) SimpleCallback {
		return .{
			.inner = genericWrapper(callbackFunction),
		};
	}

	pub fn initWithPtr(callbackFunction: anytype, data: *anyopaque) SimpleCallback {
		return .{
			.inner = main.meta.castFunctionSelfToAnyopaque(callbackFunction),
			.data = data,
		};
	}

	pub fn initWithInt(callbackFunction: fn (usize) void, data: usize) SimpleCallback {
		@setRuntimeSafety(false);
		return .{
			.inner = @ptrCast(&callbackFunction),
			.data = @ptrFromInt(data),
		};
	}

	pub fn run(self: SimpleCallback) void {
		if (self.inner) |callback| {
			callback(self.data);
		}
	}
};

```

`src/chunk.zig`:

```zig
const std = @import("std");

const blocks = @import("blocks.zig");
const Block = blocks.Block;
const main = @import("main");
const settings = @import("settings.zig");
const vec = @import("vec.zig");
const Vec3i = vec.Vec3i;
const Vec3d = vec.Vec3d;

pub const chunkShift: u5 = 5;
pub const chunkSize: u31 = 1 << chunkShift;
pub const chunkSizeIterator: [chunkSize]u0 = undefined;
pub const chunkVolume: u31 = 1 << 3*chunkShift;
pub const chunkMask: i32 = chunkSize - 1;

/// Contains a bunch of constants used to describe neighboring blocks.
pub const Neighbor = enum(u3) { // MARK: Neighbor
	dirUp = 0,
	dirDown = 1,
	dirPosX = 2,
	dirNegX = 3,
	dirPosY = 4,
	dirNegY = 5,

	pub inline fn toInt(self: Neighbor) u3 {
		return @intFromEnum(self);
	}

	/// Index to relative position
	pub fn relX(self: Neighbor) i32 {
		const arr = [_]i32{0, 0, 1, -1, 0, 0};
		return arr[@intFromEnum(self)];
	}
	/// Index to relative position
	pub fn relY(self: Neighbor) i32 {
		const arr = [_]i32{0, 0, 0, 0, 1, -1};
		return arr[@intFromEnum(self)];
	}
	/// Index to relative position
	pub fn relZ(self: Neighbor) i32 {
		const arr = [_]i32{1, -1, 0, 0, 0, 0};
		return arr[@intFromEnum(self)];
	}
	/// Index to relative position
	pub fn relPos(self: Neighbor) Vec3i {
		return .{self.relX(), self.relY(), self.relZ()};
	}

	pub fn fromRelPos(pos: Vec3i) ?Neighbor {
		if (@reduce(.Add, @abs(pos)) != 1) {
			return null;
		}
		return switch (pos[0]) {
			1 => return .dirPosX,
			-1 => return .dirNegX,
			else => switch (pos[1]) {
				1 => return .dirPosY,
				-1 => return .dirNegY,
				else => switch (pos[2]) {
					1 => return .dirUp,
					-1 => return .dirDown,
					else => return null,
				},
			},
		};
	}

	/// Index to bitMask for bitmap direction data
	pub inline fn bitMask(self: Neighbor) u6 {
		return @as(u6, 1) << @intFromEnum(self);
	}
	/// To iterate over all neighbors easily
	pub const iterable = [_]Neighbor{@enumFromInt(0), @enumFromInt(1), @enumFromInt(2), @enumFromInt(3), @enumFromInt(4), @enumFromInt(5)};
	/// Marks the two dimension that are orthogonal
	pub fn orthogonalComponents(self: Neighbor) Vec3i {
		const arr = [_]Vec3i{
			.{1, 1, 0},
			.{1, 1, 0},
			.{0, 1, 1},
			.{0, 1, 1},
			.{1, 0, 1},
			.{1, 0, 1},
		};
		return arr[@intFromEnum(self)];
	}
	pub fn textureX(self: Neighbor) Vec3i {
		const arr = [_]Vec3i{
			.{-1, 0, 0},
			.{1, 0, 0},
			.{0, 1, 0},
			.{0, -1, 0},
			.{-1, 0, 0},
			.{1, 0, 0},
		};
		return arr[@intFromEnum(self)];
	}
	pub fn textureY(self: Neighbor) Vec3i {
		const arr = [_]Vec3i{
			.{0, -1, 0},
			.{0, -1, 0},
			.{0, 0, 1},
			.{0, 0, 1},
			.{0, 0, 1},
			.{0, 0, 1},
		};
		return arr[@intFromEnum(self)];
	}

	pub inline fn reverse(self: Neighbor) Neighbor {
		return @enumFromInt(@intFromEnum(self) ^ 1);
	}

	pub inline fn isPositive(self: Neighbor) bool {
		return @intFromEnum(self) & 1 == 0;
	}
	const VectorComponentEnum = enum(u2) { x = 0, y = 1, z = 2 };
	pub fn vectorComponent(self: Neighbor) VectorComponentEnum {
		const arr = [_]VectorComponentEnum{.z, .z, .x, .x, .y, .y};
		return arr[@intFromEnum(self)];
	}

	pub fn extractDirectionComponent(self: Neighbor, in: anytype) @TypeOf(in[0]) {
		switch (self) {
			inline else => |val| {
				return in[@intFromEnum(comptime val.vectorComponent())];
			},
		}
	}

	// Returns the neighbor that is rotated by 90 degrees counterclockwise around the z axis.
	pub inline fn rotateZ(self: Neighbor) Neighbor {
		const arr = [_]Neighbor{.dirUp, .dirDown, .dirPosY, .dirNegY, .dirNegX, .dirPosX};
		return arr[@intFromEnum(self)];
	}
};

var memoryPool: main.heap.MemoryPool(Chunk) = undefined;
var serverPool: main.heap.MemoryPool(ServerChunk) = undefined;

pub fn init() void {
	memoryPool = .init(main.globalAllocator);
	serverPool = .init(main.globalAllocator);
}

pub fn deinit() void {
	memoryPool.deinit();
	serverPool.deinit();
}

pub const Lod = enum(u5) {
	@"1" = 0,
	@"2" = 1,
	@"4" = 2,
	@"8" = 3,
	@"16" = 4,
	@"32" = 5,

	const min: Lod = @enumFromInt(@typeInfo(Lod).@"enum".fields[0].value);
	const max: Lod = blk: {
		const fields = @typeInfo(Lod).@"enum".fields;
		const maxValue = fields[fields.len - 1].value;
		break :blk @enumFromInt(maxValue);
	};

	pub inline fn next(self: Lod) Lod {
		return @enumFromInt(@intFromEnum(self) + 1);
	}

	pub inline fn previous(self: Lod) Lod {
		return @enumFromInt(@intFromEnum(self) - 1);
	}

	pub inline fn toInt(self: Lod) @typeInfo(Lod).@"enum".tag_type {
		return @intFromEnum(self);
	}

	pub inline fn voxelSize(self: Lod) u31 {
		return 1 << @intFromEnum(self);
	}

	pub inline fn chunkWidth(self: Lod) u31 {
		return self.voxelSize()*chunkSize;
	}

	pub inline fn voxelSizeShift(self: Lod) u5 {
		return self.toInt();
	}

	// Mask for converting global coordinates to Lod resolution coordinates.
	pub inline fn voxelSizeMask(self: Lod) i32 {
		return ~@as(i32, self.voxelSize() - 1);
	}

	// Mask for converting global coordinates to chunk local coordinates.
	pub inline fn localMask(self: Lod) i32 {
		return ~@as(i32, self.voxelSize()*chunkSize - 1);
	}

	test "Lod.voxelSize() min" {
		try std.testing.expectEqual(1, Lod.min.voxelSize());
	}

	test "Lod.voxelSize() max" {
		try std.testing.expectEqual(32, Lod.max.voxelSize());
	}

	test "Lod.chunkWidth() min" {
		try std.testing.expectEqual(32, Lod.min.chunkWidth());
	}

	test "Lod.chunkWidth() max" {
		try std.testing.expectEqual(1024, Lod.max.chunkWidth());
	}

	test "Lod.voxelSizeShift() min" {
		try std.testing.expectEqual(0, Lod.min.voxelSizeShift());
	}

	test "Lod.voxelSizeShift() max" {
		try std.testing.expectEqual(5, Lod.max.voxelSizeShift());
	}

	test "Lod.voxelSizeMask() min" {
		try std.testing.expectEqual(~@as(i32, 0b00000), Lod.min.voxelSizeMask());
	}

	test "Lod.voxelSizeMask() max" {
		try std.testing.expectEqual(~@as(i32, 0b11111), Lod.max.voxelSizeMask());
	}

	test "Lod.localMask() min" {
		try std.testing.expectEqual(~@as(i32, 31), Lod.min.localMask());
	}

	test "Lod.localMask() max" {
		try std.testing.expectEqual(~@as(i32, 1023), Lod.max.localMask());
	}
};

pub const ChunkPosition = struct { // MARK: ChunkPosition
	wx: i32,
	wy: i32,
	wz: i32,
	voxelSize: u31,

	pub fn initFromWorldPos(pos: Vec3i, voxelSize: u31) ChunkPosition {
		const mask = ~@as(i32, voxelSize*chunkSize - 1);
		return .{.wx = pos[0] & mask, .wy = pos[1] & mask, .wz = pos[2] & mask, .voxelSize = voxelSize};
	}

	pub fn hashCode(self: ChunkPosition) u32 {
		const shift: u5 = @truncate(@min(@ctz(self.wx), @ctz(self.wy), @ctz(self.wz)));
		return (((@as(u32, @bitCast(self.wx)) >> shift)*%31 +% (@as(u32, @bitCast(self.wy)) >> shift))*%31 +% (@as(u32, @bitCast(self.wz)) >> shift))*%31 +% self.voxelSize; // TODO: Can I use one of zigs standard hash functions?
	}

	pub fn equals(self: ChunkPosition, other: anytype) bool {
		if (@typeInfo(@TypeOf(other)) == .optional) {
			if (other) |notNull| return self.equals(notNull);
			return false;
		}
		if (@TypeOf(other) == ChunkPosition) {
			return std.meta.eql(self, other);
		}
		if (@TypeOf(other.*) == ServerChunk) {
			return self.equals(other.super.pos);
		}
		if (@typeInfo(@TypeOf(other)) == .pointer) {
			return self.equals(other.pos);
		}

		@compileError("Unsupported");
	}

	pub fn getMinDistanceSquared(self: ChunkPosition, playerPosition: Vec3i) i64 {
		const halfWidth: i32 = self.voxelSize*@divExact(chunkSize, 2);
		var dx: i64 = @abs(self.wx +% halfWidth -% playerPosition[0]);
		var dy: i64 = @abs(self.wy +% halfWidth -% playerPosition[1]);
		var dz: i64 = @abs(self.wz +% halfWidth -% playerPosition[2]);
		dx = @max(0, dx - halfWidth);
		dy = @max(0, dy - halfWidth);
		dz = @max(0, dz - halfWidth);
		return dx*dx + dy*dy + dz*dz;
	}

	fn getMinDistanceSquaredFloat(self: ChunkPosition, playerPosition: Vec3d) f64 {
		const adjustedPosition = @mod(playerPosition + @as(Vec3d, @splat(1 << 31)), @as(Vec3d, @splat(1 << 32))) - @as(Vec3d, @splat(1 << 31));
		const halfWidth: f64 = @floatFromInt(self.voxelSize*@divExact(chunkSize, 2));
		var dx = @abs(@as(f64, @floatFromInt(self.wx)) + halfWidth - adjustedPosition[0]);
		var dy = @abs(@as(f64, @floatFromInt(self.wy)) + halfWidth - adjustedPosition[1]);
		var dz = @abs(@as(f64, @floatFromInt(self.wz)) + halfWidth - adjustedPosition[2]);
		dx = @max(0, dx - halfWidth);
		dy = @max(0, dy - halfWidth);
		dz = @max(0, dz - halfWidth);
		return dx*dx + dy*dy + dz*dz;
	}

	pub fn getMaxDistanceSquared(self: ChunkPosition, playerPosition: Vec3d) f64 {
		const adjustedPosition = @mod(playerPosition + @as(Vec3d, @splat(1 << 31)), @as(Vec3d, @splat(1 << 32))) - @as(Vec3d, @splat(1 << 31));
		const halfWidth: f64 = @floatFromInt(self.voxelSize*@divExact(chunkSize, 2));
		var dx = @abs(@as(f64, @floatFromInt(self.wx)) + halfWidth - adjustedPosition[0]);
		var dy = @abs(@as(f64, @floatFromInt(self.wy)) + halfWidth - adjustedPosition[1]);
		var dz = @abs(@as(f64, @floatFromInt(self.wz)) + halfWidth - adjustedPosition[2]);
		dx = dx + halfWidth;
		dy = dy + halfWidth;
		dz = dz + halfWidth;
		return dx*dx + dy*dy + dz*dz;
	}

	pub fn getCenterDistanceSquared(self: ChunkPosition, playerPosition: Vec3d) f64 {
		const adjustedPosition = @mod(playerPosition + @as(Vec3d, @splat(1 << 31)), @as(Vec3d, @splat(1 << 32))) - @as(Vec3d, @splat(1 << 31));
		const halfWidth: f64 = @floatFromInt(self.voxelSize*@divExact(chunkSize, 2));
		const dx = @as(f64, @floatFromInt(self.wx)) + halfWidth - adjustedPosition[0];
		const dy = @as(f64, @floatFromInt(self.wy)) + halfWidth - adjustedPosition[1];
		const dz = @as(f64, @floatFromInt(self.wz)) + halfWidth - adjustedPosition[2];
		return dx*dx + dy*dy + dz*dz;
	}

	pub fn getPriority(self: ChunkPosition, playerPos: Vec3d) f32 {
		return -@as(f32, @floatCast(self.getMinDistanceSquaredFloat(playerPos)))/@as(f32, @floatFromInt(self.voxelSize*self.voxelSize)) + 2*@as(f32, @floatFromInt(std.math.log2_int(u31, self.voxelSize)*chunkSize*chunkSize));
	}
};

/// Position of a block in chunk relative coordinates, 1 unit is equivalent to the voxel size of the chunk.
pub const BlockPos = packed struct(u15) { // MARK: BlockPos
	z: u5,
	y: u5,
	x: u5,

	pub fn fromCoords(x: u5, y: u5, z: u5) BlockPos {
		return .{
			.x = x,
			.y = y,
			.z = z,
		};
	}

	pub fn fromWorldCoords(wx: i32, wy: i32, wz: i32) BlockPos {
		return .{
			.x = @intCast(wx & chunkMask),
			.y = @intCast(wy & chunkMask),
			.z = @intCast(wz & chunkMask),
		};
	}

	pub fn fromLodCoords(_x: i32, _y: i32, _z: i32, voxelSizeShift: u5) BlockPos {
		const x = _x >> voxelSizeShift;
		const y = _y >> voxelSizeShift;
		const z = _z >> voxelSizeShift;
		return .fromCoords(@intCast(x), @intCast(y), @intCast(z));
	}

	pub fn fromIndex(index: u15) BlockPos {
		return @bitCast(index);
	}

	pub fn toIndex(self: BlockPos) u15 {
		return @bitCast(self);
	}

	pub fn neighbor(self: BlockPos, n: Neighbor) struct { BlockPos, enum { inSameChunk, inNeighborChunk } } {
		const result: BlockPos, const isInNeighborChunk: bool = switch (n) {
			.dirUp => .{.fromCoords(self.x, self.y, self.z +% 1), self.z == chunkMask},
			.dirDown => .{.fromCoords(self.x, self.y, self.z -% 1), self.z == 0},
			.dirPosY => .{.fromCoords(self.x, self.y +% 1, self.z), self.y == chunkMask},
			.dirNegY => .{.fromCoords(self.x, self.y -% 1, self.z), self.y == 0},
			.dirPosX => .{.fromCoords(self.x +% 1, self.y, self.z), self.x == chunkMask},
			.dirNegX => .{.fromCoords(self.x -% 1, self.y, self.z), self.x == 0},
		};
		return .{result, if (isInNeighborChunk) .inNeighborChunk else .inSameChunk};
	}
};

pub const Chunk = struct { // MARK: Chunk
	pos: ChunkPosition,
	data: main.utils.PaletteCompressedRegion(Block, chunkVolume) = undefined,

	width: u31,
	voxelSizeShift: u5,
	voxelSizeMask: i32,

	blockPosToEntityDataMap: std.AutoHashMapUnmanaged(BlockPos, main.block_entity.BlockEntityIndex),
	blockPosToEntityDataMapMutex: std.Thread.Mutex,

	pub fn init(pos: ChunkPosition) *Chunk {
		const self = memoryPool.create();
		std.debug.assert((pos.voxelSize - 1 & pos.voxelSize) == 0);
		std.debug.assert(@mod(pos.wx, pos.voxelSize) == 0 and @mod(pos.wy, pos.voxelSize) == 0 and @mod(pos.wz, pos.voxelSize) == 0);
		const voxelSizeShift: u5 = @intCast(std.math.log2_int(u31, pos.voxelSize));
		self.* = Chunk{
			.pos = pos,
			.width = pos.voxelSize*chunkSize,
			.voxelSizeShift = voxelSizeShift,
			.voxelSizeMask = pos.voxelSize - 1,
			.blockPosToEntityDataMap = .{},
			.blockPosToEntityDataMapMutex = .{},
		};
		self.data.init();
		return self;
	}

	pub fn deinit(self: *Chunk) void {
		self.deinitContent();
		memoryPool.destroy(@alignCast(self));
	}

	fn deinitContent(self: *Chunk) void {
		std.debug.assert(self.blockPosToEntityDataMap.count() == 0);
		self.blockPosToEntityDataMap.deinit(main.globalAllocator.allocator);
		self.data.deferredDeinit();
	}

	pub fn unloadBlockEntities(self: *Chunk, comptime side: main.utils.Side) void {
		self.blockPosToEntityDataMapMutex.lock();
		defer self.blockPosToEntityDataMapMutex.unlock();
		var iterator = self.blockPosToEntityDataMap.iterator();
		while (iterator.next()) |elem| {
			const pos = elem.key_ptr.*;
			const entityDataIndex = elem.value_ptr.*;
			const block = self.data.getValue(pos.toIndex());
			const blockEntity = block.blockEntity() orelse unreachable;
			switch (side) {
				.client => {
					blockEntity.onUnloadClient(entityDataIndex);
				},
				.server => {
					blockEntity.onUnloadServer(entityDataIndex);
				},
			}
		}
		self.blockPosToEntityDataMap.clearRetainingCapacity();
	}

	/// Updates a block if it is inside this chunk.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn updateBlock(self: *Chunk, x: i32, y: i32, z: i32, newBlock: Block) void {
		const pos = BlockPos.fromLodCoords(x, y, z, self.voxelSizeShift);
		self.data.setValue(pos.toIndex(), newBlock);
	}

	/// Gets a block if it is inside this chunk.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn getBlock(self: *const Chunk, x: i32, y: i32, z: i32) Block {
		const pos = BlockPos.fromLodCoords(x, y, z, self.voxelSizeShift);
		return self.data.getValue(pos.toIndex());
	}

	/// Checks if the given relative coordinates lie within the bounds of this chunk.
	pub fn liesInChunk(self: *const Chunk, x: i32, y: i32, z: i32) bool {
		return x >= 0 and x < self.width and y >= 0 and y < self.width and z >= 0 and z < self.width;
	}

	pub fn getLocalBlockPos(self: *const Chunk, worldPos: Vec3i) BlockPos {
		return .fromLodCoords(
			(worldPos[0] - self.pos.wx),
			(worldPos[1] - self.pos.wy),
			(worldPos[2] - self.pos.wz),
			self.voxelSizeShift,
		);
	}

	pub fn localToGlobalPosition(self: *const Chunk, pos: BlockPos) Vec3i {
		return .{
			(@as(i32, pos.x) << self.voxelSizeShift) + self.pos.wx,
			(@as(i32, pos.y) << self.voxelSizeShift) + self.pos.wy,
			(@as(i32, pos.z) << self.voxelSizeShift) + self.pos.wz,
		};
	}
};

pub const ServerChunk = struct { // MARK: ServerChunk
	super: Chunk,

	wasChanged: bool = false,
	generated: bool = false,
	wasStored: bool = false,
	shouldStoreNeighbors: bool = false,

	mutex: std.Thread.Mutex = .{},
	refCount: std.atomic.Value(u16),

	pub fn initAndIncreaseRefCount(pos: ChunkPosition) *ServerChunk {
		const self = serverPool.create();
		std.debug.assert((pos.voxelSize - 1 & pos.voxelSize) == 0);
		std.debug.assert(@mod(pos.wx, pos.voxelSize) == 0 and @mod(pos.wy, pos.voxelSize) == 0 and @mod(pos.wz, pos.voxelSize) == 0);
		const voxelSizeShift: u5 = @intCast(std.math.log2_int(u31, pos.voxelSize));
		self.* = ServerChunk{
			.super = .{
				.pos = pos,
				.width = pos.voxelSize*chunkSize,
				.voxelSizeShift = voxelSizeShift,
				.voxelSizeMask = pos.voxelSize - 1,
				.blockPosToEntityDataMap = .{},
				.blockPosToEntityDataMapMutex = .{},
			},
			.refCount = .init(1),
		};
		self.super.data.init();
		return self;
	}

	pub fn deinit(self: *ServerChunk) void {
		std.debug.assert(self.refCount.raw == 0);
		const oldContext = main.sync.threadContext;
		defer main.sync.threadContext = oldContext;
		main.sync.threadContext = .chunkDeiniting;
		if (self.wasChanged) {
			self.save(main.server.world.?);
		}
		self.super.unloadBlockEntities(.server);
		self.super.deinitContent();
		serverPool.destroy(@alignCast(self));
	}

	pub fn setChanged(self: *ServerChunk) void {
		main.utils.assertLocked(&self.mutex);
		if (!self.wasChanged) {
			self.wasChanged = true;
			self.increaseRefCount();
			main.server.world.?.queueChunkUpdateAndDecreaseRefCount(self);
		}
	}

	pub fn increaseRefCount(self: *ServerChunk) void {
		const prevVal = self.refCount.fetchAdd(1, .monotonic);
		std.debug.assert(prevVal != 0);
	}

	pub fn decreaseRefCount(self: *ServerChunk) void {
		const prevVal = self.refCount.fetchSub(1, .monotonic);
		std.debug.assert(prevVal != 0);
		if (prevVal == 1) {
			self.deinit();
		}
	}

	/// Checks if the given relative coordinates lie within the bounds of this chunk.
	pub fn liesInChunk(self: *const ServerChunk, x: i32, y: i32, z: i32) bool {
		return self.super.liesInChunk(x, y, z);
	}

	/// This is useful to convert for loops to work for reduced resolution:
	/// Instead of using
	/// for(int x = start; x < end; x++)
	/// for(int x = chunk.startIndex(start); x < end; x += chunk.getVoxelSize())
	/// should be used to only activate those voxels that are used in Cubyz's downscaling technique.
	pub fn startIndex(self: *const ServerChunk, start: i32) i32 {
		return start + self.super.voxelSizeMask & ~self.super.voxelSizeMask; // Rounds up to the nearest valid voxel coordinate.
	}

	/// Gets a block if it is inside this chunk.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn getBlock(self: *const ServerChunk, x: i32, y: i32, z: i32) Block {
		main.utils.assertLocked(&self.mutex);
		const pos = BlockPos.fromLodCoords(x, y, z, self.super.voxelSizeShift);
		return self.super.data.getValue(pos.toIndex());
	}

	/// Updates a block if it is inside this chunk.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn updateBlockAndSetChanged(self: *ServerChunk, x: i32, y: i32, z: i32, newBlock: Block) void {
		main.utils.assertLocked(&self.mutex);
		const pos = BlockPos.fromLodCoords(x, y, z, self.super.voxelSizeShift);
		self.super.data.setValue(pos.toIndex(), newBlock);
		self.shouldStoreNeighbors = true;
		self.setChanged();
	}

	/// Updates a block if current value is air or the current block is degradable.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn updateBlockIfDegradable(self: *ServerChunk, x: i32, y: i32, z: i32, newBlock: Block) void {
		main.utils.assertLocked(&self.mutex);
		const pos = BlockPos.fromLodCoords(x, y, z, self.super.voxelSizeShift);
		const oldBlock = self.super.data.getValue(pos.toIndex());
		if (oldBlock.typ == 0 or oldBlock.degradable()) {
			self.super.data.setValue(pos.toIndex(), newBlock);
		}
	}

	/// Updates a block if it is inside this chunk. Should be used in generation to prevent accidently storing these as changes.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn updateBlockInGeneration(self: *ServerChunk, x: i32, y: i32, z: i32, newBlock: Block) void {
		main.utils.assertLocked(&self.mutex);
		const pos = BlockPos.fromLodCoords(x, y, z, self.super.voxelSizeShift);
		self.super.data.setValue(pos.toIndex(), newBlock);
	}

	/// Updates a block if it is inside this chunk. Should be used in generation to prevent accidently storing these as changes.
	/// Does not do any bound checks. They are expected to be done with the `liesInChunk` function.
	pub fn updateBlockColumnInGeneration(self: *ServerChunk, x: i32, y: i32, zStartInclusive: i32, zEndInclusive: i32, newBlock: Block) void {
		std.debug.assert(zStartInclusive <= zEndInclusive);
		main.utils.assertLocked(&self.mutex);
		const posStart = BlockPos.fromLodCoords(x, y, zStartInclusive, self.super.voxelSizeShift);
		const posEnd = BlockPos.fromLodCoords(x, y, zEndInclusive, self.super.voxelSizeShift);
		self.super.data.setValueInColumn(posStart.toIndex(), @as(usize, posEnd.toIndex()) + 1, newBlock);
	}

	pub fn updateFromLowerResolution(self: *ServerChunk, other: *ServerChunk) void {
		const xOffset = if (other.super.pos.wx != self.super.pos.wx) chunkSize/2 else 0; // Offsets of the lower resolution chunk in this chunk.
		const yOffset = if (other.super.pos.wy != self.super.pos.wy) chunkSize/2 else 0;
		const zOffset = if (other.super.pos.wz != self.super.pos.wz) chunkSize/2 else 0;
		self.mutex.lock();
		defer self.mutex.unlock();
		main.utils.assertLocked(&other.mutex);

		// Count the neighbors for each subblock. An transparent block counts 5. A chunk border(unknown block) only counts 1.

		comptime std.debug.assert(chunkSize == 32);
		var isTransparent: [32][32]u32 = @splat(@splat(0));
		var count: [32][32][32]u8 = @splat(@splat(@splat(128)));
		for (0..32) |x| {
			for (0..32) |y| {
				for (0..32) |z| {
					const pos = BlockPos.fromCoords(@intCast(x), @intCast(y), @intCast(z));
					var block = other.super.data.getValue(pos.toIndex());
					block.typ = block.lodReplacement();
					if (block.typ == 0) count[x][y][z] = 0; // Air blocks should be avoided
					if (block.transparent()) isTransparent[x][y] |= @as(u32, 1) << @intCast(z);
				}
			}
		}
		for (0..32) |x| {
			for (0..32) |y| {
				var columnCount: @Vector(32, u8) = @splat(0);
				columnCount[0] = 1;
				columnCount[31] = 1;
				if (x == 0 or x == 31) columnCount += @splat(1);
				if (y == 0 or y == 31) columnCount += @splat(1);
				const zero: @Vector(32, u8) = @splat(0);
				const weight: @Vector(32, u8) = @splat(5);
				if (x != 0) {
					columnCount += @select(u8, @as(@Vector(32, bool), @bitCast(isTransparent[x - 1][y])), weight, zero);
				}
				if (x != 31) {
					columnCount += @select(u8, @as(@Vector(32, bool), @bitCast(isTransparent[x + 1][y])), weight, zero);
				}
				if (y != 0) {
					columnCount += @select(u8, @as(@Vector(32, bool), @bitCast(isTransparent[x][y - 1])), weight, zero);
				}
				if (y != 31) {
					columnCount += @select(u8, @as(@Vector(32, bool), @bitCast(isTransparent[x][y + 1])), weight, zero);
				}
				columnCount += @select(u8, @as(@Vector(32, bool), @bitCast(isTransparent[x][y] >> 1)), weight, zero);
				columnCount += @select(u8, @as(@Vector(32, bool), @bitCast(isTransparent[x][y] << 1)), weight, zero);
				count[x][y] = columnCount;
			}
		}

		for (0..chunkSize/2) |x| {
			for (0..chunkSize/2) |y| {
				for (0..chunkSize/2) |z| {
					var neighborCount: [8]u31 = undefined;
					var maxCount: i32 = 0;
					for (0..2) |dx| {
						for (0..2) |dy| {
							for (0..2) |dz| {
								const i = dx*4 + dz*2 + dy;
								neighborCount[i] = count[x*2 + dx][y*2 + dy][z*2 + dz];
								maxCount = @max(maxCount, neighborCount[i]);
							}
						}
					}
					// Uses a specific permutation here that keeps high resolution patterns in lower resolution.
					const permutationStart = (x & 1)*4 + (z & 1)*2 + (y & 1);
					var finalPermutation = permutationStart;
					for (0..8) |i| {
						const appliedPermutation = permutationStart ^ i;
						if (neighborCount[appliedPermutation] >= maxCount - 1) { // Avoid pattern breaks at chunk borders.
							finalPermutation = appliedPermutation;
						}
					}
					const dx = finalPermutation/4 & 1;
					const dy = finalPermutation/2 & 1;
					const dz = finalPermutation & 1;
					const pos = BlockPos.fromCoords(@intCast(x*2 + dx), @intCast(y*2 + dy), @intCast(z*2 + dz));
					var block = other.super.data.getValue(pos.toIndex());
					block.typ = block.lodReplacement();
					// Update the block:
					const thisPos = BlockPos.fromCoords(@intCast(x + xOffset), @intCast(y + yOffset), @intCast(z + zOffset));
					self.super.data.setValue(thisPos.toIndex(), block);
				}
			}
		}

		self.setChanged();
	}

	pub fn save(self: *ServerChunk, world: *main.server.ServerWorld) void {
		self.mutex.lock();
		defer self.mutex.unlock();
		if (self.shouldStoreNeighbors and self.super.pos.voxelSize == 1) {
			// Store all the neighbor chunks as well:
			self.mutex.unlock();
			defer self.mutex.lock();
			var dx: i32 = -@as(i32, chunkSize);
			while (dx <= chunkSize) : (dx += chunkSize) {
				var dy: i32 = -@as(i32, chunkSize);
				while (dy <= chunkSize) : (dy += chunkSize) {
					var dz: i32 = -@as(i32, chunkSize);
					while (dz <= chunkSize) : (dz += chunkSize) {
						if (dx == 0 and dy == 0 and dz == 0) continue;
						const ch = main.server.world.?.getOrGenerateChunkAndIncreaseRefCount(.{
							.wx = self.super.pos.wx +% dx,
							.wy = self.super.pos.wy +% dy,
							.wz = self.super.pos.wz +% dz,
							.voxelSize = 1,
						});
						defer ch.decreaseRefCount();
						ch.mutex.lock();
						defer ch.mutex.unlock();
						if (!ch.wasStored) {
							ch.setChanged();
						}
					}
				}
			}
		}
		if (!self.wasStored and self.super.pos.voxelSize == 1) {
			// Store the surrounding map pieces as well:
			self.mutex.unlock();
			defer self.mutex.lock();
			const mapStartX = self.super.pos.wx -% main.server.terrain.SurfaceMap.MapFragment.mapSize/2 & ~@as(i32, main.server.terrain.SurfaceMap.MapFragment.mapMask);
			const mapStartY = self.super.pos.wy -% main.server.terrain.SurfaceMap.MapFragment.mapSize/2 & ~@as(i32, main.server.terrain.SurfaceMap.MapFragment.mapMask);
			for (0..2) |dx| {
				for (0..2) |dy| {
					const mapX = mapStartX +% main.server.terrain.SurfaceMap.MapFragment.mapSize*@as(i32, @intCast(dx));
					const mapY = mapStartY +% main.server.terrain.SurfaceMap.MapFragment.mapSize*@as(i32, @intCast(dy));
					const map = main.server.terrain.SurfaceMap.getOrGenerateFragment(mapX, mapY, self.super.pos.voxelSize);
					if (!map.wasStored.swap(true, .monotonic)) {
						map.save(null, .{});
					}
				}
			}
		}
		self.wasStored = true;
		if (self.wasChanged) {
			const pos = self.super.pos;
			const regionSize = pos.voxelSize*chunkSize*main.server.storage.RegionFile.regionSize;
			const regionMask: i32 = regionSize - 1;
			const region = main.server.storage.loadRegionFileAndIncreaseRefCount(pos.wx & ~regionMask, pos.wy & ~regionMask, pos.wz & ~regionMask, pos.voxelSize);
			defer region.decreaseRefCount();
			const data = main.server.storage.ChunkCompression.storeChunk(main.stackAllocator, &self.super, .toDisk, false);
			defer main.stackAllocator.free(data);
			region.storeChunk(
				data,
				@as(usize, @intCast(pos.wx -% region.pos.wx))/pos.voxelSize/chunkSize,
				@as(usize, @intCast(pos.wy -% region.pos.wy))/pos.voxelSize/chunkSize,
				@as(usize, @intCast(pos.wz -% region.pos.wz))/pos.voxelSize/chunkSize,
			);

			self.wasChanged = false;
			// Update the next lod chunk:
			if (pos.voxelSize != 1 << settings.highestSupportedLod) {
				var nextPos = pos;
				nextPos.wx &= ~@as(i32, pos.voxelSize*chunkSize);
				nextPos.wy &= ~@as(i32, pos.voxelSize*chunkSize);
				nextPos.wz &= ~@as(i32, pos.voxelSize*chunkSize);
				nextPos.voxelSize *= 2;
				const nextHigherLod = world.getOrGenerateChunkAndIncreaseRefCount(nextPos);
				defer nextHigherLod.decreaseRefCount();
				nextHigherLod.updateFromLowerResolution(self);
			}
		}
	}
};

```

`src/entity.zig`:

```zig
const std = @import("std");

const chunk = @import("chunk.zig");
const game = @import("game.zig");
const graphics = @import("graphics.zig");
const c = graphics.c;
const ZonElement = @import("zon.zig").ZonElement;
const main = @import("main");
const renderer = @import("renderer.zig");
const settings = @import("settings.zig");
const utils = @import("utils.zig");
const vec = @import("vec.zig");
const Mat4f = vec.Mat4f;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec4f = vec.Vec4f;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const BinaryReader = main.utils.BinaryReader;

pub const EntityNetworkData = struct {
	id: u32,
	pos: Vec3d,
	vel: Vec3d,
	rot: Vec3f,
};

pub const ClientEntity = struct {
	interpolatedValues: utils.GenericInterpolation(6) = undefined,
	_interpolationPos: [6]f64 = undefined,
	_interpolationVel: [6]f64 = undefined,

	width: f64,
	height: f64,

	pos: Vec3d = undefined,
	rot: Vec3f = undefined,

	id: u32,
	name: []const u8,

	pub fn init(self: *ClientEntity, zon: ZonElement, allocator: NeverFailingAllocator) void {
		self.* = ClientEntity{
			.id = zon.get(u32, "id", std.math.maxInt(u32)),
			.width = zon.get(f64, "width", 1),
			.height = zon.get(f64, "height", 1),
			.name = allocator.dupe(u8, zon.get([]const u8, "name", "")),
		};
		self._interpolationPos = [_]f64{
			self.pos[0],
			self.pos[1],
			self.pos[2],
			@floatCast(self.rot[0]),
			@floatCast(self.rot[1]),
			@floatCast(self.rot[2]),
		};
		self._interpolationVel = @splat(0);
		self.interpolatedValues.init(&self._interpolationPos, &self._interpolationVel);
	}

	pub fn deinit(self: ClientEntity, allocator: NeverFailingAllocator) void {
		allocator.free(self.name);
	}

	pub fn getRenderPosition(self: *const ClientEntity) Vec3d {
		return Vec3d{self.pos[0], self.pos[1], self.pos[2]};
	}

	pub fn updatePosition(self: *ClientEntity, pos: *const [6]f64, vel: *const [6]f64, time: i16) void {
		self.interpolatedValues.updatePosition(pos, vel, time);
	}

	pub fn update(self: *ClientEntity, time: i16, lastTime: i16) void {
		self.interpolatedValues.update(time, lastTime);
		self.pos[0] = self.interpolatedValues.outPos[0];
		self.pos[1] = self.interpolatedValues.outPos[1];
		self.pos[2] = self.interpolatedValues.outPos[2];
		self.rot[0] = @floatCast(self.interpolatedValues.outPos[3]);
		self.rot[1] = @floatCast(self.interpolatedValues.outPos[4]);
		self.rot[2] = @floatCast(self.interpolatedValues.outPos[5]);
	}
};

pub const ClientEntityManager = struct {
	var lastTime: i16 = 0;
	var timeDifference: utils.TimeDifference = utils.TimeDifference{};
	var uniforms: struct {
		projectionMatrix: c_int,
		viewMatrix: c_int,
		light: c_int,
		contrast: c_int,
		ambientLight: c_int,
	} = undefined;
	var modelBuffer: main.graphics.SSBO = undefined;
	var modelSize: c_int = 0;
	var modelTexture: main.graphics.Texture = undefined;
	var pipeline: graphics.Pipeline = undefined; // Entities are sometimes small and sometimes big. Therefor it would mean a lot of work to still use smooth lighting. Therefor the non-smooth shader is used for those.
	pub var entities: main.utils.VirtualList(ClientEntity, 1 << 20) = undefined;
	pub var mutex: std.Thread.Mutex = .{};

	pub fn init() void {
		entities = .init();
		pipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/entity_vertex.vert",
			"assets/cubyz/shaders/entity_fragment.frag",
			"",
			&uniforms,
			.{},
			.{.depthTest = true},
			.{.attachments = &.{.alphaBlending}},
		);

		modelTexture = main.graphics.Texture.initFromFile("assets/cubyz/entity/textures/snale.png");
		const modelFile = main.files.cwd().read(main.stackAllocator, "assets/cubyz/entity/models/snale.obj") catch |err| blk: {
			std.log.err("Error while reading player model: {s}", .{@errorName(err)});
			break :blk &.{};
		};
		defer main.stackAllocator.free(modelFile);
		const quadInfos = main.models.Model.loadRawModelDataFromObj(main.stackAllocator, modelFile);
		defer main.stackAllocator.free(quadInfos);
		modelBuffer = .initStatic(main.models.QuadInfo, quadInfos);
		modelBuffer.bind(11);
		modelSize = @intCast(quadInfos.len);
	}

	pub fn deinit() void {
		for (entities.items()) |ent| {
			ent.deinit(main.globalAllocator);
		}
		entities.deinit();
		pipeline.deinit();
	}

	pub fn clear() void {
		for (entities.items()) |ent| {
			ent.deinit(main.globalAllocator);
		}
		entities.clearRetainingCapacity();
		timeDifference = utils.TimeDifference{};
	}

	fn update() void {
		main.utils.assertLocked(&mutex);
		var time: i16 = @truncate(main.timestamp().toMilliseconds() -% settings.entityLookback);
		time -%= timeDifference.difference.load(.monotonic);
		for (entities.items()) |*ent| {
			ent.update(time, lastTime);
		}
		lastTime = time;
	}

	pub fn renderNames(projMatrix: Mat4f, playerPos: Vec3d) void {
		mutex.lock();
		defer mutex.unlock();

		const screenUnits = @as(f32, @floatFromInt(main.Window.height))/1024;
		const fontBaseSize = 128.0;
		const fontMinScreenSize = 16.0;
		const fontScreenSize = fontBaseSize*screenUnits;

		for (entities.items()) |ent| {
			if (ent.id == game.Player.id or ent.name.len == 0) continue; // don't render local player
			const pos3d = ent.getRenderPosition() - playerPos;
			const pos4f = Vec4f{
				@floatCast(pos3d[0]),
				@floatCast(pos3d[1]),
				@floatCast(pos3d[2] + 1.1),
				1,
			};

			const rotatedPos = game.camera.viewMatrix.mulVec(pos4f);
			const projectedPos = projMatrix.mulVec(rotatedPos);
			if (projectedPos[2] < 0) continue;
			const xCenter = (1 + projectedPos[0]/projectedPos[3])*@as(f32, @floatFromInt(main.Window.width/2));
			const yCenter = (1 - projectedPos[1]/projectedPos[3])*@as(f32, @floatFromInt(main.Window.height/2));

			const transparency = 38.0*std.math.log10(vec.lengthSquare(pos3d) + 1) - 80.0;
			const alpha: u32 = @intFromFloat(std.math.clamp(0xff - transparency, 0, 0xff));
			graphics.draw.setColor(alpha << 24);

			var buf = graphics.TextBuffer.init(main.stackAllocator, ent.name, .{.color = 0xffffff}, false, .center);
			defer buf.deinit();
			const fontSize = std.mem.max(f32, &.{fontMinScreenSize, fontScreenSize/projectedPos[3]});
			const size = buf.calculateLineBreaks(fontSize, @floatFromInt(main.Window.width*8));
			buf.render(xCenter - size[0]/2, yCenter - size[1], fontSize);
		}
	}

	pub fn render(projMatrix: Mat4f, ambientLight: Vec3f, playerPos: Vec3d) void {
		mutex.lock();
		defer mutex.unlock();
		update();
		pipeline.bind(null);
		c.glBindVertexArray(main.renderer.chunk_meshing.vao);
		c.glUniformMatrix4fv(uniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projMatrix));
		modelTexture.bindTo(0);
		c.glUniform3fv(uniforms.ambientLight, 1, @ptrCast(&ambientLight));
		c.glUniform1f(uniforms.contrast, 0.12);

		for (entities.items()) |ent| {
			if (ent.id == game.Player.id) continue; // don't render local player

			const blockPos: vec.Vec3i = @intFromFloat(@floor(ent.pos));
			const lightVals: [6]u8 = main.renderer.mesh_storage.getLight(blockPos[0], blockPos[1], blockPos[2]) orelse @splat(0);
			const light = (@as(u32, lightVals[0] >> 3) << 25 |
				@as(u32, lightVals[1] >> 3) << 20 |
				@as(u32, lightVals[2] >> 3) << 15 |
				@as(u32, lightVals[3] >> 3) << 10 |
				@as(u32, lightVals[4] >> 3) << 5 |
				@as(u32, lightVals[5] >> 3) << 0);

			c.glUniform1ui(uniforms.light, @bitCast(@as(u32, light)));

			const pos: Vec3d = ent.getRenderPosition() - playerPos;
			const modelMatrix = (Mat4f.identity()
				.mul(Mat4f.translation(Vec3f{
					@floatCast(pos[0]),
					@floatCast(pos[1]),
					@floatCast(pos[2] - 1.0 + 0.09375),
				}))
				.mul(Mat4f.rotationZ(-ent.rot[2])));
			const modelViewMatrix = game.camera.viewMatrix.mul(modelMatrix);
			c.glUniformMatrix4fv(uniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&modelViewMatrix));
			c.glDrawElements(c.GL_TRIANGLES, 6*modelSize, c.GL_UNSIGNED_INT, null);
		}
	}

	pub fn addEntity(zon: ZonElement) void {
		mutex.lock();
		defer mutex.unlock();
		var ent = entities.addOne();
		ent.init(zon, main.globalAllocator);
	}

	pub fn removeEntity(id: u32) void {
		mutex.lock();
		defer mutex.unlock();
		for (entities.items(), 0..) |*ent, i| {
			if (ent.id == id) {
				ent.deinit(main.globalAllocator);
				_ = entities.swapRemove(i);
				if (i != entities.len) {
					entities.items()[i].interpolatedValues.outPos = &entities.items()[i]._interpolationPos;
					entities.items()[i].interpolatedValues.outVel = &entities.items()[i]._interpolationVel;
				}
				break;
			}
		}
	}

	pub fn serverUpdate(time: i16, entityData: []EntityNetworkData) void {
		mutex.lock();
		defer mutex.unlock();
		timeDifference.addDataPoint(time);

		for (entityData) |data| {
			const pos = [_]f64{
				data.pos[0],
				data.pos[1],
				data.pos[2],
				@floatCast(data.rot[0]),
				@floatCast(data.rot[1]),
				@floatCast(data.rot[2]),
			};
			const vel = [_]f64{
				data.vel[0],
				data.vel[1],
				data.vel[2],
				0,
				0,
				0,
			};
			for (entities.items()) |*ent| {
				if (ent.id == data.id) {
					ent.updatePosition(&pos, &vel, time);
					break;
				}
			}
		}
	}
};

```

`src/files.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ZonElement = main.ZonElement;

pub fn openDirInWindow(path: []const u8) void {
	const newPath = main.stackAllocator.dupe(u8, path);
	defer main.stackAllocator.free(newPath);

	if (builtin.os.tag == .windows) {
		std.mem.replaceScalar(u8, newPath, '/', '\\');
	}

	const command = switch (builtin.os.tag) {
		.windows => .{"explorer", newPath},
		.macos => .{"open", newPath},
		else => .{"xdg-open", newPath},
	};
	const result = std.process.Child.run(.{
		.allocator = main.stackAllocator.allocator,
		.argv = &command,
	}) catch |err| {
		std.log.err("Got error while trying to open file explorer: {s}", .{@errorName(err)});
		return;
	};
	defer {
		main.stackAllocator.free(result.stderr);
		main.stackAllocator.free(result.stdout);
	}
	if (result.stderr.len != 0) {
		std.log.err("Got error while trying to open file explorer: {s}", .{result.stderr});
	}
}

pub fn cwd() Dir {
	return Dir{
		.dir = std.fs.cwd(),
	};
}

var cubyzDir_: ?std.fs.Dir = null;
var cubyzDirStr_: []const u8 = ".";

pub fn cubyzDir() Dir {
	return .{
		.dir = cubyzDir_ orelse std.fs.cwd(),
	};
}

pub fn cubyzDirStr() []const u8 {
	return cubyzDirStr_;
}

fn flawedInit() !void {
	if (main.settings.launchConfig.cubyzDir.len != 0) {
		cubyzDir_ = try std.fs.cwd().makeOpenPath(main.settings.launchConfig.cubyzDir, .{});
		cubyzDirStr_ = main.globalAllocator.dupe(u8, main.settings.launchConfig.cubyzDir);
		return;
	}
	const homePath = try std.process.getEnvVarOwned(main.stackAllocator.allocator, if (builtin.os.tag == .windows) "USERPROFILE" else "HOME");
	defer main.stackAllocator.free(homePath);
	var homeDir = try std.fs.openDirAbsolute(homePath, .{});
	defer homeDir.close();
	if (builtin.os.tag == .windows) {
		cubyzDir_ = try homeDir.makeOpenPath("Saved Games/Cubyz", .{});
		cubyzDirStr_ = std.mem.concat(main.globalAllocator.allocator, u8, &.{homePath, "/Saved Games/Cubyz"}) catch unreachable;
	} else {
		cubyzDir_ = try homeDir.makeOpenPath(".cubyz", .{});
		cubyzDirStr_ = std.mem.concat(main.globalAllocator.allocator, u8, &.{homePath, "/.cubyz"}) catch unreachable;
	}
}

pub fn init() void {
	flawedInit() catch |err| {
		std.log.err("Error {s} while opening global Cubyz directory. Using working directory instead.", .{@errorName(err)});
	};
}

pub fn deinit() void {
	if (cubyzDir_ != null) {
		cubyzDir_.?.close();
	}
	if (cubyzDirStr_.ptr != ".".ptr) {
		main.globalAllocator.free(cubyzDirStr_);
	}
}

pub const Dir = struct {
	dir: std.fs.Dir,

	pub fn init(dir: std.fs.Dir) Dir {
		return .{.dir = dir};
	}

	pub fn close(self: *Dir) void {
		self.dir.close();
	}

	pub fn read(self: Dir, allocator: NeverFailingAllocator, path: []const u8) ![]u8 {
		return self.dir.readFileAlloc(path, allocator.allocator, .unlimited);
	}

	pub fn readToZon(self: Dir, allocator: NeverFailingAllocator, path: []const u8) !ZonElement {
		const string = try self.read(main.stackAllocator, path);
		defer main.stackAllocator.free(string);
		const realPath: ?[]const u8 = self.dir.realpathAlloc(main.stackAllocator.allocator, path) catch null;
		defer if (realPath) |p| main.stackAllocator.free(p);
		return ZonElement.parseFromString(allocator, realPath orelse path, string);
	}

	pub fn write(self: Dir, path: []const u8, data: []const u8) !void {
		const tempPath = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}.tmp0", .{path}) catch unreachable;
		defer main.stackAllocator.free(tempPath);

		try self.dir.writeFile(.{.data = data, .sub_path = tempPath});

		return self.dir.rename(tempPath, path);
	}

	pub fn writeZon(self: Dir, path: []const u8, zon: ZonElement) !void {
		const string = zon.toString(main.stackAllocator);
		defer main.stackAllocator.free(string);
		try self.write(path, string);
	}

	pub fn hasFile(self: Dir, path: []const u8) bool {
		const file = self.dir.openFile(path, .{}) catch return false;
		file.close();
		return true;
	}

	pub fn hasDir(self: Dir, path: []const u8) bool {
		var dir = self.dir.openDir(path, .{.iterate = false}) catch return false;
		dir.close();
		return true;
	}

	pub fn openDir(self: Dir, path: []const u8) !Dir {
		return .{.dir = try self.dir.makeOpenPath(path, .{})};
	}

	pub fn openIterableDir(self: Dir, path: []const u8) !Dir {
		return .{.dir = try self.dir.makeOpenPath(path, .{.iterate = true})};
	}

	pub fn openFile(self: Dir, path: []const u8) !std.fs.File {
		return self.dir.openFile(path, .{});
	}

	pub fn deleteTree(self: Dir, path: []const u8) !void {
		try self.dir.deleteTree(path);
	}

	pub fn deleteFile(self: Dir, path: []const u8) !void {
		try self.dir.deleteFile(path);
	}

	pub fn makePath(self: Dir, path: []const u8) !void {
		try self.dir.makePath(path);
	}

	pub fn walk(self: Dir, allocator: NeverFailingAllocator) std.fs.Dir.Walker {
		return self.dir.walk(allocator.allocator) catch unreachable;
	}

	pub fn iterate(self: Dir) std.fs.Dir.Iterator {
		return self.dir.iterate();
	}
};

```

`src/formatter/format.zig`:

```zig
const std = @import("std");

var global_gpa = std.heap.GeneralPurposeAllocator(.{.thread_safe = true}){};
pub const globalAllocator = global_gpa.allocator();

var failed: bool = false;

fn printError(msg: []const u8, filePath: []const u8, data: []const u8, charIndex: usize) void {
	var lineStart: usize = 0;
	var lineNumber: usize = 1;
	var lineEnd: usize = data.len;
	for (data[0..charIndex], 0..) |c, i| {
		if (c == '\n') {
			lineStart = i + 1;
			lineNumber += 1;
		}
	}
	for (data[charIndex..], charIndex..) |c, i| {
		if (c == '\n') {
			lineEnd = i;
			break;
		}
	}

	var startLineChars: std.ArrayList(u8) = .{};
	defer startLineChars.deinit(globalAllocator);
	for (data[lineStart..charIndex]) |c| {
		if (c == '\t') {
			startLineChars.append(globalAllocator, '\t') catch {};
		} else {
			startLineChars.append(globalAllocator, ' ') catch {};
		}
	}

	failed = true;

	std.log.err("Found formatting error in line {} of file {s}: {s}\n{s}\n{s}^", .{lineNumber, filePath, msg, data[lineStart..lineEnd], startLineChars.items});
}

fn checkFile(dir: std.fs.Dir, filePath: []const u8) !void {
	const data = try dir.readFileAlloc(filePath, globalAllocator, .unlimited);
	defer globalAllocator.free(data);

	var lineStart: bool = true;

	for (data, 0..) |c, i| {
		switch (c) {
			'\n' => {
				lineStart = true;
				if (i != 0 and (data[i - 1] == ' ' or data[i - 1] == '\t')) {
					printError("Line contains trailing whitespaces. Please remove them.", filePath, data, i - 1);
				}
			},
			'\r' => {
				printError("Incorrect line ending \\r. Please configure your editor to use LF instead CRLF.", filePath, data, i);
			},
			' ' => {
				if (lineStart) {
					printError("Incorrect indentation. Please use tabs instead of spaces.", filePath, data, i);
				}
			},
			'/' => {
				if (data[i + 1] == '/' and data[i + 2] != '/' and data[i + 2] != ' ' and data[i + 2] != '\n' and (i == 0 or (data[i - 1] != ':' and data[i - 1] != '"'))) {
					printError("Comments should include a space before text, ex: // whatever", filePath, data, i + 2);
				}
				lineStart = false;
			},
			'\t' => {},
			else => {
				lineStart = false;
			},
		}
	}
	if (data.len != 0 and data[data.len - 1] != '\n' or (data.len > 2 and data[data.len - 2] == '\n')) {
		printError("File should end with a single empty line", filePath, data, data.len - 1);
	}
}

fn checkDirectory(dir: std.fs.Dir) !void {
	var walker = try dir.walk(globalAllocator);
	defer walker.deinit();
	while (try walker.next()) |child| {
		if (std.mem.endsWith(u8, child.basename, ".zon") and !std.mem.endsWith(u8, child.basename, ".zig.zon")) {
			std.log.err("File name should end with .zig.zon so it gets syntax highlighting on github.", .{});
			failed = true;
		}
		if (child.kind == .file and (std.mem.endsWith(u8, child.basename, ".vert") or std.mem.endsWith(u8, child.basename, ".frag") or std.mem.endsWith(u8, child.basename, ".comp") or (std.mem.endsWith(u8, child.basename, ".zig") and !std.mem.eql(u8, child.basename, "fmt.zig")))) {
			try checkFile(dir, child.path);
		}
	}
}

pub fn main() !void {
	defer _ = global_gpa.deinit();

	var dir = try std.fs.cwd().openDir("src", .{.iterate = true});
	defer dir.close();
	try checkDirectory(dir);
	dir.close();
	dir = try std.fs.cwd().openDir("assets", .{.iterate = true});
	try checkDirectory(dir);

	if (failed) std.posix.exit(1);
}

```

`src/game.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const assets = @import("assets.zig");
const itemdrop = @import("itemdrop.zig");
const ClientItemDropManager = itemdrop.ClientItemDropManager;
const items = @import("items.zig");
const ClientInventory = items.Inventory.ClientInventory;
const ZonElement = @import("zon.zig").ZonElement;
const main = @import("main");
const network = @import("network.zig");
const particles = @import("particles.zig");
const Connection = network.Connection;
const ConnectionManager = network.ConnectionManager;
const vec = @import("vec.zig");
const Vec2f = vec.Vec2f;
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;
const Vec4f = vec.Vec4f;
const Vec3d = vec.Vec3d;
const Mat4f = vec.Mat4f;
const graphics = @import("graphics.zig");
const Fog = graphics.Fog;
const renderer = @import("renderer.zig");
const settings = @import("settings.zig");
const Block = main.blocks.Block;
const physics = main.physics;
const KeyBoard = main.KeyBoard;

pub const camera = struct { // MARK: camera
	pub var rotation: Vec3f = Vec3f{0, 0, 0};
	pub var direction: Vec3f = Vec3f{0, 0, 0};
	pub var viewMatrix: Mat4f = Mat4f.identity();
	pub fn moveRotation(mouseX: f32, mouseY: f32) void {
		// Mouse movement along the y-axis rotates the image along the x-axis.
		rotation[0] += mouseY;
		if (rotation[0] > std.math.pi/2.0) {
			rotation[0] = std.math.pi/2.0;
		} else if (rotation[0] < -std.math.pi/2.0) {
			rotation[0] = -std.math.pi/2.0;
		}
		// Mouse movement along the x-axis rotates the image along the z-axis.
		rotation[2] += mouseX;
	}

	pub fn updateViewMatrix() void {
		direction = vec.rotateZ(vec.rotateX(Vec3f{0, 1, 0}, -rotation[0]), -rotation[2]);
		viewMatrix = Mat4f.identity().mul(Mat4f.rotationX(rotation[0])).mul(Mat4f.rotationZ(rotation[2]));
	}
};

pub const collision = struct {
	pub const Box = struct {
		min: Vec3d,
		max: Vec3d,

		pub fn center(self: Box) Vec3d {
			return (self.min + self.max)*@as(Vec3d, @splat(0.5));
		}

		pub fn extent(self: Box) Vec3d {
			return (self.max - self.min)*@as(Vec3d, @splat(0.5));
		}

		pub fn intersects(self: Box, other: Box) bool {
			return @reduce(.And, (self.max > other.min)) and @reduce(.And, (self.min < other.max));
		}
	};

	const Direction = enum(u2) { x = 0, y = 1, z = 2 };

	pub fn collideWithBlock(block: main.blocks.Block, x: i32, y: i32, z: i32, entityPosition: Vec3d, entityBoundingBoxExtent: Vec3d, directionVector: Vec3d) ?struct { box: Box, dist: f64 } {
		var resultBox: ?Box = null;
		var minDistance: f64 = std.math.floatMax(f64);
		if (block.collide()) {
			const model = block.mode().model(block).model();

			const pos = Vec3d{@floatFromInt(x), @floatFromInt(y), @floatFromInt(z)};
			const entityCollision = Box{.min = entityPosition - entityBoundingBoxExtent, .max = entityPosition + entityBoundingBoxExtent};

			for (model.collision) |relativeBlockCollision| {
				const blockCollision = Box{.min = relativeBlockCollision.min + pos, .max = relativeBlockCollision.max + pos};
				if (blockCollision.intersects(entityCollision)) {
					const dotMin = vec.dot(directionVector, blockCollision.min);
					const dotMax = vec.dot(directionVector, blockCollision.max);

					const distance = @min(dotMin, dotMax);

					if (distance < minDistance) {
						resultBox = blockCollision;
						minDistance = distance;
					} else if (distance == minDistance) {
						resultBox = .{.min = @min(resultBox.?.min, blockCollision.min), .max = @max(resultBox.?.max, blockCollision.max)};
					}
				}
			}
		}
		return .{.box = resultBox orelse return null, .dist = minDistance};
	}

	pub fn collides(comptime side: main.utils.Side, dir: Direction, amount: f64, pos: Vec3d, hitBox: Box) ?Box {
		var boundingBox: Box = .{
			.min = pos + hitBox.min,
			.max = pos + hitBox.max,
		};
		switch (dir) {
			.x => {
				if (amount < 0) boundingBox.min[0] += amount else boundingBox.max[0] += amount;
			},
			.y => {
				if (amount < 0) boundingBox.min[1] += amount else boundingBox.max[1] += amount;
			},
			.z => {
				if (amount < 0) boundingBox.min[2] += amount else boundingBox.max[2] += amount;
			},
		}
		const minX: i32 = @intFromFloat(@floor(boundingBox.min[0]));
		const maxX: i32 = @intFromFloat(@floor(boundingBox.max[0]));
		const minY: i32 = @intFromFloat(@floor(boundingBox.min[1]));
		const maxY: i32 = @intFromFloat(@floor(boundingBox.max[1]));
		const minZ: i32 = @intFromFloat(@floor(boundingBox.min[2]));
		const maxZ: i32 = @intFromFloat(@floor(boundingBox.max[2]));

		const boundingBoxCenter = boundingBox.center();
		const fullBoundingBoxExtent = boundingBox.extent();

		var resultBox: ?Box = null;
		var minDistance: f64 = std.math.floatMax(f64);
		const directionVector: Vec3d = switch (dir) {
			.x => .{-std.math.sign(amount), 0, 0},
			.y => .{0, -std.math.sign(amount), 0},
			.z => .{0, 0, -std.math.sign(amount)},
		};

		var x: i32 = minX;
		while (x <= maxX) : (x += 1) {
			var y: i32 = minY;
			while (y <= maxY) : (y += 1) {
				var z: i32 = maxZ;
				while (z >= minZ) : (z -= 1) {
					const _block = if (side == .client) main.renderer.mesh_storage.getBlockFromRenderThread(x, y, z) else main.server.world.?.getBlock(x, y, z);
					if (_block) |block| {
						if (collideWithBlock(block, x, y, z, boundingBoxCenter, fullBoundingBoxExtent, directionVector)) |res| {
							if (res.dist < minDistance) {
								resultBox = res.box;
								minDistance = res.dist;
							} else if (res.dist == minDistance) {
								resultBox.?.min = @min(resultBox.?.min, res.box.min);
								resultBox.?.max = @min(resultBox.?.max, res.box.max);
							}
						}
					}
				}
			}
		}

		return resultBox;
	}

	const SurfaceProperties = struct {
		friction: f32,
		bounciness: f32,
	};

	pub fn calculateSurfaceProperties(comptime side: main.utils.Side, pos: Vec3d, hitBox: Box, defaultFriction: f32) SurfaceProperties {
		const boundingBox: Box = .{
			.min = pos + hitBox.min,
			.max = pos + hitBox.max,
		};
		const minX: i32 = @intFromFloat(@floor(boundingBox.min[0]));
		const maxX: i32 = @intFromFloat(@floor(boundingBox.max[0]));
		const minY: i32 = @intFromFloat(@floor(boundingBox.min[1]));
		const maxY: i32 = @intFromFloat(@floor(boundingBox.max[1]));

		const z: i32 = @intFromFloat(@floor(boundingBox.min[2] - 0.01));

		var friction: f64 = 0;
		var bounciness: f64 = 0;
		var totalArea: f64 = 0;

		var x = minX;
		while (x <= maxX) : (x += 1) {
			var y = minY;
			while (y <= maxY) : (y += 1) {
				const _block = if (side == .client) main.renderer.mesh_storage.getBlockFromRenderThread(x, y, z) else main.server.world.?.getBlock(x, y, z);

				if (_block) |block| {
					const blockPos: Vec3d = .{@floatFromInt(x), @floatFromInt(y), @floatFromInt(z)};

					const blockBox: Box = .{
						.min = blockPos + @as(Vec3d, @floatCast(block.mode().model(block).model().min)),
						.max = blockPos + @as(Vec3d, @floatCast(block.mode().model(block).model().max)),
					};

					if (boundingBox.min[2] > blockBox.max[2] or boundingBox.max[2] < blockBox.min[2]) {
						continue;
					}

					const max = std.math.clamp(vec.xy(blockBox.max), vec.xy(boundingBox.min), vec.xy(boundingBox.max));
					const min = std.math.clamp(vec.xy(blockBox.min), vec.xy(boundingBox.min), vec.xy(boundingBox.max));

					const area = (max[0] - min[0])*(max[1] - min[1]);

					if (block.collide()) {
						totalArea += area;
						friction += area*@as(f64, @floatCast(block.friction()));
						bounciness += area*@as(f64, @floatCast(block.bounciness()));
					}
				}
			}
		}

		if (totalArea == 0) {
			friction = defaultFriction;
			bounciness = 0.0;
		} else {
			friction = friction/totalArea;
			bounciness = bounciness/totalArea;
		}

		return .{
			.friction = @floatCast(friction),
			.bounciness = @floatCast(bounciness),
		};
	}

	const VolumeProperties = struct {
		terminalVelocity: f64,
		density: f64,
		maxDensity: f64,
		mobileFriction: f64,
	};

	fn overlapVolume(a: Box, b: Box) f64 {
		const min = @max(a.min, b.min);
		const max = @min(a.max, b.max);
		if (@reduce(.Or, min >= max)) return 0;
		return @reduce(.Mul, max - min);
	}

	pub fn calculateVolumeProperties(comptime side: main.utils.Side, pos: Vec3d, hitBox: Box, defaults: VolumeProperties) VolumeProperties {
		const boundingBox: Box = .{
			.min = pos + hitBox.min,
			.max = pos + hitBox.max,
		};
		const minX: i32 = @intFromFloat(@floor(boundingBox.min[0]));
		const maxX: i32 = @intFromFloat(@floor(boundingBox.max[0]));
		const minY: i32 = @intFromFloat(@floor(boundingBox.min[1]));
		const maxY: i32 = @intFromFloat(@floor(boundingBox.max[1]));
		const minZ: i32 = @intFromFloat(@floor(boundingBox.min[2]));
		const maxZ: i32 = @intFromFloat(@floor(boundingBox.max[2]));

		var invTerminalVelocitySum: f64 = 0;
		var densitySum: f64 = 0;
		var maxDensity: f64 = defaults.maxDensity;
		var mobileFrictionSum: f64 = 0;
		var volumeSum: f64 = 0;

		var x: i32 = minX;
		while (x <= maxX) : (x += 1) {
			var y: i32 = minY;
			while (y <= maxY) : (y += 1) {
				var z: i32 = maxZ;
				while (z >= minZ) : (z -= 1) {
					const _block = if (side == .client) main.renderer.mesh_storage.getBlockFromRenderThread(x, y, z) else main.server.world.?.getBlock(x, y, z);
					const totalBox: Box = .{
						.min = @floatFromInt(Vec3i{x, y, z}),
						.max = @floatFromInt(Vec3i{x + 1, y + 1, z + 1}),
					};
					const gridVolume = overlapVolume(boundingBox, totalBox);
					volumeSum += gridVolume;

					if (_block) |block| {
						const collisionBox: Box = .{ // TODO: Check all AABBs individually
							.min = totalBox.min + main.blocks.meshes.model(block).model().min,
							.max = totalBox.min + main.blocks.meshes.model(block).model().max,
						};
						const filledVolume = @min(gridVolume, overlapVolume(collisionBox, totalBox));
						const emptyVolume = gridVolume - filledVolume;
						invTerminalVelocitySum += emptyVolume/defaults.terminalVelocity;
						mobileFrictionSum += emptyVolume*defaults.mobileFriction;
						densitySum += emptyVolume*defaults.density;
						invTerminalVelocitySum += filledVolume/block.terminalVelocity();
						mobileFrictionSum += filledVolume*block.mobility()/block.terminalVelocity();
						densitySum += filledVolume*block.density();
						maxDensity = @max(maxDensity, block.density());
					} else {
						invTerminalVelocitySum += gridVolume/defaults.terminalVelocity;
						densitySum += gridVolume*defaults.density;
						mobileFrictionSum += gridVolume*defaults.mobileFriction;
					}
				}
			}
		}

		return .{
			.terminalVelocity = volumeSum/invTerminalVelocitySum,
			.density = densitySum/volumeSum,
			.maxDensity = maxDensity,
			.mobileFriction = mobileFrictionSum/volumeSum,
		};
	}

	pub fn collideOrStep(comptime side: main.utils.Side, comptime dir: Direction, amount: f64, pos: Vec3d, hitBox: Box, steppingHeight: f64) Vec3d {
		const index = @intFromEnum(dir);

		// First argument is amount we end up moving in dir, second argument is how far up we step
		var resultingMovement: Vec3d = .{0, 0, 0};
		resultingMovement[index] = amount;
		var checkPos = pos;
		checkPos[index] += amount;

		if (collision.collides(side, dir, -amount, checkPos, hitBox)) |box| {
			const newFloor = box.max[2] + hitBox.max[2];
			const heightDifference = newFloor - checkPos[2];
			if (heightDifference <= steppingHeight) {
				// If we collide but might be able to step up
				checkPos[2] = newFloor;
				if (collision.collides(side, dir, -amount, checkPos, hitBox) == null) {
					// If there's no new collision then we can execute the step-up
					resultingMovement[2] = heightDifference;
					return resultingMovement;
				}
			}

			// Otherwise move as close to the container as possible
			if (amount < 0) {
				resultingMovement[index] = box.max[index] - hitBox.min[index] - pos[index];
			} else {
				resultingMovement[index] = box.min[index] - hitBox.max[index] - pos[index];
			}
		}

		return resultingMovement;
	}

	fn isBlockIntersecting(block: Block, posX: i32, posY: i32, posZ: i32, center: Vec3d, extent: Vec3d) bool {
		const model = block.mode().model(block).model();
		const position = Vec3d{@floatFromInt(posX), @floatFromInt(posY), @floatFromInt(posZ)};
		const entityBox = Box{.min = center - extent, .max = center + extent};
		for (model.collision) |relativeBlockCollision| {
			const blockBox = Box{.min = position + relativeBlockCollision.min, .max = position + relativeBlockCollision.max};
			if (blockBox.intersects(entityBox)) {
				return true;
			}
		}

		return false;
	}

	pub fn touchBlocks(entity: *main.server.Entity, hitBox: Box, side: main.utils.Side, deltaTime: f64) void {
		const boundingBox: Box = .{.min = entity.pos + hitBox.min, .max = entity.pos + hitBox.max};

		const minX: i32 = @intFromFloat(@floor(boundingBox.min[0] - 0.01));
		const maxX: i32 = @intFromFloat(@floor(boundingBox.max[0] + 0.01));
		const minY: i32 = @intFromFloat(@floor(boundingBox.min[1] - 0.01));
		const maxY: i32 = @intFromFloat(@floor(boundingBox.max[1] + 0.01));
		const minZ: i32 = @intFromFloat(@floor(boundingBox.min[2] - 0.01));
		const maxZ: i32 = @intFromFloat(@floor(boundingBox.max[2] + 0.01));

		const center: Vec3d = boundingBox.center();
		const extent: Vec3d = boundingBox.extent();

		const extentX: Vec3d = extent + Vec3d{0.01, -0.01, -0.01};
		const extentY: Vec3d = extent + Vec3d{-0.01, 0.01, -0.01};
		const extentZ: Vec3d = extent + Vec3d{-0.01, -0.01, 0.01};

		var posX: i32 = minX;
		while (posX <= maxX) : (posX += 1) {
			var posY: i32 = minY;
			while (posY <= maxY) : (posY += 1) {
				var posZ: i32 = minZ;
				while (posZ <= maxZ) : (posZ += 1) {
					const block: ?Block =
						if (side == .client) main.renderer.mesh_storage.getBlockFromRenderThread(posX, posY, posZ) else main.server.world.?.getBlock(posX, posY, posZ);
					if (block == null or block.?.onTouch().isNoop())
						continue;
					const touchX: bool = isBlockIntersecting(block.?, posX, posY, posZ, center, extentX);
					const touchY: bool = isBlockIntersecting(block.?, posX, posY, posZ, center, extentY);
					const touchZ: bool = isBlockIntersecting(block.?, posX, posY, posZ, center, extentZ);
					if (touchX or touchY or touchZ) {
						_ = block.?.onTouch().run(.{.entity = entity, .source = block.?, .blockPos = .{posX, posY, posZ}, .deltaTime = deltaTime});
					}
				}
			}
		}
	}
};

pub const Gamemode = enum(u8) { survival = 0, creative = 1 };

pub const DamageType = enum(u8) {
	heal = 0, // For when you are adding health
	kill = 1,
	fall = 2,
	heat = 3,
	spiky = 4,

	pub fn sendMessage(self: DamageType, name: []const u8) void {
		switch (self) {
			.heal => main.server.sendMessage("{s}§#ffffff was healed", .{name}),
			.kill => main.server.sendMessage("{s}§#ffffff was killed", .{name}),
			.fall => main.server.sendMessage("{s}§#ffffff died of fall damage", .{name}),
			.heat => main.server.sendMessage("{s}§#ffffff burned to death", .{name}),
			.spiky => main.server.sendMessage("{s}§#ffffff experienced death by 1000 needles", .{name}),
		}
	}
};

pub const Player = struct { // MARK: Player
	pub const EyeData = struct {
		pos: Vec3d = .{0, 0, 0},
		vel: Vec3d = .{0, 0, 0},
		coyote: f64 = 0.0,
		step: @Vector(3, bool) = .{false, false, false},
		box: collision.Box = .{
			.min = -Vec3d{standingBoundingBoxExtent[0]*0.2, standingBoundingBoxExtent[1]*0.2, 0.6},
			.max = Vec3d{standingBoundingBoxExtent[0]*0.2, standingBoundingBoxExtent[1]*0.2, 0.9 - 0.05},
		},
		desiredPos: Vec3d = .{0, 0, 1.7 - standingBoundingBoxExtent[2]},
	};
	pub var super: main.server.Entity = .{};
	pub var eye: EyeData = .{};
	pub var crouching: bool = false;
	pub var id: u32 = 0;
	pub var gamemode: Atomic(Gamemode) = .init(.creative);
	pub var isFlying: Atomic(bool) = .init(false);
	pub var isGhost: Atomic(bool) = .init(false);
	pub var hyperSpeed: Atomic(bool) = .init(false);
	pub var mutex: std.Thread.Mutex = .{};
	pub const inventorySize = 32;
	pub var inventory: ClientInventory = undefined;
	pub var selectedSlot: u32 = 0;
	pub const defaultBlockDamage: f32 = 1;

	pub var selectionPosition1: ?Vec3i = null;
	pub var selectionPosition2: ?Vec3i = null;

	pub var currentFriction: f32 = 0;
	pub var mobileFriction: f32 = 0;
	pub var volumeProperties: collision.VolumeProperties = .{.density = 0, .maxDensity = 0, .mobileFriction = 0, .terminalVelocity = 0};

	pub var onGround: bool = false;
	pub var jumpCooldown: f64 = 0;
	pub var jumpCoyote: f64 = 0;
	pub const jumpCooldownConstant = 0.3;
	pub const jumpCoyoteTimeConstant = 0.100;

	pub const standingBoundingBoxExtent: Vec3d = .{0.3, 0.3, 0.9};
	pub const crouchingBoundingBoxExtent: Vec3d = .{0.3, 0.3, 0.725};
	pub var crouchPerc: f32 = 0;

	pub var outerBoundingBoxExtent: Vec3d = standingBoundingBoxExtent;
	pub var outerBoundingBox: collision.Box = .{
		.min = -standingBoundingBoxExtent,
		.max = standingBoundingBoxExtent,
	};
	pub const jumpHeight = 1.25;

	fn loadFrom(zon: ZonElement) void {
		super.loadFrom(zon);
	}

	pub fn setPosBlocking(newPos: Vec3d) void {
		mutex.lock();
		defer mutex.unlock();
		super.pos = newPos;
	}

	pub fn getPosBlocking() Vec3d {
		mutex.lock();
		defer mutex.unlock();
		return super.pos;
	}

	pub fn getVelBlocking() Vec3d {
		mutex.lock();
		defer mutex.unlock();
		return super.vel;
	}

	pub fn getEyePosBlocking() Vec3d {
		mutex.lock();
		defer mutex.unlock();
		return eye.pos + super.pos + eye.desiredPos;
	}

	pub fn getEyeVelBlocking() Vec3d {
		mutex.lock();
		defer mutex.unlock();
		return eye.vel;
	}

	pub fn getEyeCoyoteBlocking() f64 {
		mutex.lock();
		defer mutex.unlock();
		return eye.coyote;
	}

	pub fn getJumpCoyoteBlocking() f64 {
		mutex.lock();
		defer mutex.unlock();
		return jumpCoyote;
	}

	pub fn setGamemode(newGamemode: Gamemode) void {
		gamemode.store(newGamemode, .monotonic);

		if (newGamemode != .creative) {
			isFlying.store(false, .monotonic);
			isGhost.store(false, .monotonic);
			hyperSpeed.store(false, .monotonic);
		}
	}

	pub fn isCreative() bool {
		return gamemode.load(.monotonic) == .creative;
	}

	pub fn isActuallyFlying() bool {
		return isFlying.load(.monotonic) and !isGhost.load(.monotonic);
	}

	pub fn steppingHeight() Vec3d {
		if (onGround) {
			return .{0, 0, 0.6};
		} else {
			return .{0, 0, 0.08};
		}
	}

	pub fn placeBlock(mods: main.Window.Key.Modifiers) void {
		if (main.renderer.MeshSelection.selectedBlockPos) |blockPos| {
			if (!mods.shift) {
				if (main.renderer.mesh_storage.triggerOnInteractBlockFromRenderThread(blockPos[0], blockPos[1], blockPos[2]) == .handled) return;
			}
			const block = main.renderer.mesh_storage.getBlockFromRenderThread(blockPos[0], blockPos[1], blockPos[2]) orelse main.blocks.Block{.typ = 0, .data = 0};
			const onInteract = block.onInteract();
			if (!mods.shift) {
				if (onInteract.run(.{.blockPos = blockPos, .block = block}) == .handled) return;
			}
		}

		inventory.placeBlock(selectedSlot);
	}

	pub fn kill(spawnPos: Vec3d) void {
		Player.super.pos = spawnPos;
		Player.super.vel = .{0, 0, 0};

		Player.super.health = Player.super.maxHealth;
		Player.super.energy = Player.super.maxEnergy;

		Player.eye = .{};
		Player.jumpCoyote = 0;
	}

	pub fn dropFromHand(mods: main.Window.Key.Modifiers) void {
		if (mods.shift) {
			inventory.dropStack(selectedSlot);
		} else {
			inventory.dropOne(selectedSlot);
		}
	}

	pub fn breakBlock(deltaTime: f64) void {
		inventory.breakBlock(selectedSlot, deltaTime);
	}

	pub fn acquireSelectedBlock() void {
		if (main.renderer.MeshSelection.selectedBlockPos) |selectedPos| {
			const block = main.renderer.mesh_storage.getBlockFromRenderThread(selectedPos[0], selectedPos[1], selectedPos[2]) orelse return;

			const item: items.Item = for (0..items.itemListSize) |idx| {
				const baseItem: main.items.BaseItemIndex = @enumFromInt(idx);
				if (baseItem.block() == block.typ) {
					break .{.baseItem = baseItem};
				}
			} else return;

			// Check if there is already a slot with that item type
			for (0..12) |slotIdx| {
				if (std.meta.eql(inventory.getItem(slotIdx), item)) {
					if (isCreative()) {
						inventory.fillFromCreative(@intCast(slotIdx), item);
					}
					selectedSlot = @intCast(slotIdx);
					return;
				}
			}

			if (isCreative()) {
				const targetSlot = blk: {
					if (inventory.getItem(selectedSlot) == .null) break :blk selectedSlot;
					// Look for an empty slot
					for (0..12) |slotIdx| {
						if (inventory.getItem(slotIdx) == .null) {
							break :blk slotIdx;
						}
					}
					break :blk selectedSlot;
				};

				inventory.fillFromCreative(@intCast(targetSlot), item);
				selectedSlot = @intCast(targetSlot);
			}
		}
	}
};

pub const World = struct { // MARK: World
	pub const dayCycle: u63 = 12000; // Length of one in-game day in 100ms. Midnight is at DAY_CYCLE/2. Sunrise and sunset each take about 1/16 of the day. Currently set to 20 minutes

	conn: *Connection,
	manager: *ConnectionManager,
	ambientLight: f32 = 0,
	name: []const u8,
	milliTime: i64,
	gameTime: Atomic(i64) = .init(0),
	connected: bool = true,
	blockPalette: *assets.Palette = undefined,
	itemPalette: *assets.Palette = undefined,
	toolPalette: *assets.Palette = undefined,
	biomePalette: *assets.Palette = undefined,
	itemDrops: ClientItemDropManager = undefined,
	playerBiome: Atomic(*const main.server.terrain.biomes.Biome) = undefined,

	pub fn init(self: *World, ip: []const u8, manager: *ConnectionManager) !void {
		main.heap.allocators.createWorldArena();
		errdefer main.heap.allocators.destroyWorldArena();
		self.* = .{
			.conn = try Connection.init(manager, ip, null),
			.manager = manager,
			.name = "client",
			.milliTime = main.timestamp().toMilliseconds(),
		};
		errdefer self.conn.deinit();

		self.itemDrops.init(main.globalAllocator);
		errdefer self.itemDrops.deinit();
		try network.protocols.handShake.clientSide(self.conn, settings.playerName);

		main.Window.setMouseGrabbed(true);

		main.blocks.meshes.generateTextureArray();
		main.particles.ParticleManager.generateTextureArray();
		main.models.uploadModels();
	}

	pub fn deinit(self: *World) void {
		self.conn.deinit();

		self.connected = false;

		// TODO: Close all world related guis.
		main.gui.inventory.deinit();
		main.gui.deinit();
		main.gui.init();
		Player.inventory.deinit(main.globalAllocator);
		main.items.clearRecipeCachedInventories();
		main.sync.ClientSide.reset();

		main.threadPool.clear();
		main.entity.ClientEntityManager.clear();
		self.itemDrops.deinit();
		self.blockPalette.deinit();
		self.itemPalette.deinit();
		self.toolPalette.deinit();
		self.biomePalette.deinit();
		self.manager.deinit();
		main.server.stop();
		if (main.server.thread) |serverThread| {
			serverThread.join();
			main.server.thread = null;
		}
		main.threadPool.clear();
		renderer.mesh_storage.deinit();
		renderer.mesh_storage.init();
		assets.unloadAssets();
		main.heap.allocators.destroyWorldArena();
	}

	pub fn finishHandshake(self: *World, zon: ZonElement) !void {
		// TODO: Consider using a per-world allocator.
		self.blockPalette = try assets.Palette.init(main.globalAllocator, zon.getChild("blockPalette"), "cubyz:air");
		errdefer self.blockPalette.deinit();
		self.biomePalette = try assets.Palette.init(main.globalAllocator, zon.getChild("biomePalette"), null);
		errdefer self.biomePalette.deinit();
		self.itemPalette = try assets.Palette.init(main.globalAllocator, zon.getChild("itemPalette"), null);
		errdefer self.itemPalette.deinit();
		self.toolPalette = try assets.Palette.init(main.globalAllocator, zon.getChild("toolPalette"), null);
		errdefer self.toolPalette.deinit();

		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/serverAssets", .{main.files.cubyzDirStr()}) catch unreachable;
		defer main.stackAllocator.free(path);
		try assets.loadWorldAssets(path, self.blockPalette, self.itemPalette, self.toolPalette, self.biomePalette);
		Player.id = zon.get(u32, "player_id", std.math.maxInt(u32));
		Player.inventory = ClientInventory.init(main.globalAllocator, Player.inventorySize, .normal, .serverShared, .{.playerInventory = Player.id}, .{});
		Player.loadFrom(zon.getChild("player"));
		self.playerBiome = .init(main.server.terrain.biomes.getPlaceholderBiome());
		main.audio.setMusic(self.playerBiome.raw.preferredMusic);
	}

	fn dayNightLightFactor(gameTime: i64) struct { f32, Vec3f } {
		const dayTime = @abs(@mod(gameTime, dayCycle) - dayCycle/2);
		if (dayTime < dayCycle/4 - dayCycle/16) {
			return .{0.1, @splat(0)};
		}
		if (dayTime > dayCycle/4 + dayCycle/16) {
			return .{1, @splat(1)};
		}
		var skyColorFactor: Vec3f = undefined;
		// b:
		if (dayTime > dayCycle/4) {
			skyColorFactor[2] = @as(f32, @floatFromInt(dayTime - dayCycle/4))/@as(f32, @floatFromInt(dayCycle/16));
		} else {
			skyColorFactor[2] = 0;
		}
		// g:
		if (dayTime > dayCycle/4 + dayCycle/32) {
			skyColorFactor[1] = 1;
		} else if (dayTime > dayCycle/4 - dayCycle/32) {
			skyColorFactor[1] = 1 - @as(f32, @floatFromInt(dayCycle/4 + dayCycle/32 - dayTime))/@as(f32, @floatFromInt(dayCycle/16));
		} else {
			skyColorFactor[1] = 0;
		}
		// r:
		if (dayTime > dayCycle/4) {
			skyColorFactor[0] = 1;
		} else {
			skyColorFactor[0] = 1 - @as(f32, @floatFromInt(dayCycle/4 - dayTime))/@as(f32, @floatFromInt(dayCycle/16));
		}

		const ambientLight = 0.1 + 0.9*@as(f32, @floatFromInt(dayTime - (dayCycle/4 - dayCycle/16)))/@as(f32, @floatFromInt(dayCycle/8));
		return .{ambientLight, skyColorFactor};
	}

	pub fn update(self: *World) void {
		const newTime: i64 = main.timestamp().toMilliseconds();
		while (self.milliTime +% 100 -% newTime < 0) {
			self.milliTime +%= 100;
			var curTime = self.gameTime.load(.monotonic);
			while (self.gameTime.cmpxchgWeak(curTime, curTime +% 1, .monotonic, .monotonic)) |actualTime| {
				curTime = actualTime;
			}
		}
		// Ambient light:
		{
			self.ambientLight, const skyColorFactor = dayNightLightFactor(self.gameTime.load(.monotonic));
			fog.fogColor = biomeFog.fogColor*skyColorFactor;
			fog.skyColor = biomeFog.skyColor*skyColorFactor;
			fog.density = biomeFog.density;
			fog.fogLower = biomeFog.fogLower;
			fog.fogHigher = biomeFog.fogHigher;
		}
		network.protocols.playerPosition.send(self.conn, Player.getPosBlocking(), Player.getVelBlocking(), @intCast(newTime & 65535));
	}
};
pub var testWorld: World = undefined; // TODO:
pub var world: ?*World = null;

pub var projectionMatrix: Mat4f = Mat4f.identity();

var biomeFog = Fog{.skyColor = .{0.8, 0.8, 1}, .fogColor = .{0.8, 0.8, 1}, .density = 1.0/15.0/128.0, .fogLower = 100, .fogHigher = 1000};
pub var fog = Fog{.skyColor = .{0.8, 0.8, 1}, .fogColor = .{0.8, 0.8, 1}, .density = 1.0/15.0/128.0, .fogLower = 100, .fogHigher = 1000};

var nextBlockPlaceTime: ?std.Io.Timestamp = null;
var nextBlockBreakTime: ?std.Io.Timestamp = null;

pub fn pressPlace(mods: main.Window.Key.Modifiers) void {
	const time = main.timestamp();
	nextBlockPlaceTime = time.addDuration(main.settings.updateRepeatDelay);
	Player.placeBlock(mods);
}

pub fn releasePlace(_: main.Window.Key.Modifiers) void {
	nextBlockPlaceTime = null;
}

pub fn pressBreak(_: main.Window.Key.Modifiers) void {
	const time = main.timestamp();
	nextBlockBreakTime = time.addDuration(main.settings.updateRepeatDelay);
	Player.breakBlock(0);
}

pub fn releaseBreak(_: main.Window.Key.Modifiers) void {
	nextBlockBreakTime = null;
}

pub fn pressAcquireSelectedBlock(_: main.Window.Key.Modifiers) void {
	Player.acquireSelectedBlock();
}

pub fn flyToggle(_: main.Window.Key.Modifiers) void {
	if (!Player.isCreative()) return;

	const newIsFlying = !Player.isActuallyFlying();

	Player.isFlying.store(newIsFlying, .monotonic);
	Player.isGhost.store(false, .monotonic);
}

pub fn ghostToggle(_: main.Window.Key.Modifiers) void {
	if (!Player.isCreative()) return;

	const newIsGhost = !Player.isGhost.load(.monotonic);

	Player.isGhost.store(newIsGhost, .monotonic);
	Player.isFlying.store(newIsGhost, .monotonic);
}

pub fn hyperSpeedToggle(_: main.Window.Key.Modifiers) void {
	if (!Player.isCreative()) return;

	Player.hyperSpeed.store(!Player.hyperSpeed.load(.monotonic), .monotonic);
}

pub fn update(deltaTime: f64) void { // MARK: update()
	physics.calculateProperties();
	var acc = Vec3d{0, 0, 0};
	const speedMultiplier: f32 = if (Player.hyperSpeed.load(.monotonic)) 4.0 else 1.0;

	const density = if (Player.isFlying.load(.monotonic)) 0.0 else Player.volumeProperties.density;
	const maxDensity = if (Player.isFlying.load(.monotonic)) 0.0 else Player.volumeProperties.maxDensity;

	var jumping = false;
	Player.jumpCooldown -= deltaTime;
	// At equillibrium we want to have dv/dt = a - λv = 0 → a = λ*v
	const fricMul = speedMultiplier*Player.mobileFriction;

	const horizontalForward = vec.rotateZ(Vec3d{0, 1, 0}, -camera.rotation[2]);
	const forward = vec.normalize(std.math.lerp(horizontalForward, camera.direction, @as(Vec3d, @splat(density/@max(1.0, maxDensity)))));
	const right = Vec3d{-horizontalForward[1], horizontalForward[0], 0};
	var movementDir: Vec3d = .{0, 0, 0};
	var movementSpeed: f64 = 0;

	if (main.Window.grabbed) {
		const walkingSpeed: f64 = if (Player.crouching) 2.5 else 4.5;
		if (KeyBoard.key("forward").value > 0.0) {
			if (KeyBoard.key("sprint").pressed and !Player.crouching) {
				if (Player.isGhost.load(.monotonic)) {
					movementSpeed = @max(movementSpeed, 128*KeyBoard.key("forward").value);
					movementDir += forward*@as(Vec3d, @splat(128*KeyBoard.key("forward").value));
				} else if (Player.isFlying.load(.monotonic)) {
					movementSpeed = @max(movementSpeed, 32*KeyBoard.key("forward").value);
					movementDir += forward*@as(Vec3d, @splat(32*KeyBoard.key("forward").value));
				} else {
					movementSpeed = @max(movementSpeed, 8*KeyBoard.key("forward").value);
					movementDir += forward*@as(Vec3d, @splat(8*KeyBoard.key("forward").value));
				}
			} else {
				movementSpeed = @max(movementSpeed, walkingSpeed*KeyBoard.key("forward").value);
				movementDir += forward*@as(Vec3d, @splat(walkingSpeed*KeyBoard.key("forward").value));
			}
		}
		if (KeyBoard.key("backward").value > 0.0) {
			movementSpeed = @max(movementSpeed, walkingSpeed*KeyBoard.key("backward").value);
			movementDir += forward*@as(Vec3d, @splat(-walkingSpeed*KeyBoard.key("backward").value));
		}
		if (KeyBoard.key("left").value > 0.0) {
			movementSpeed = @max(movementSpeed, walkingSpeed*KeyBoard.key("left").value);
			movementDir += right*@as(Vec3d, @splat(walkingSpeed*KeyBoard.key("left").value));
		}
		if (KeyBoard.key("right").value > 0.0) {
			movementSpeed = @max(movementSpeed, walkingSpeed*KeyBoard.key("right").value);
			movementDir += right*@as(Vec3d, @splat(-walkingSpeed*KeyBoard.key("right").value));
		}
		if (KeyBoard.key("jump").pressed) {
			if (Player.isFlying.load(.monotonic)) {
				if (KeyBoard.key("sprint").pressed) {
					if (Player.isGhost.load(.monotonic)) {
						movementSpeed = @max(movementSpeed, 60);
						movementDir[2] += 60;
					} else {
						movementSpeed = @max(movementSpeed, 25);
						movementDir[2] += 25;
					}
				} else {
					movementSpeed = @max(movementSpeed, 5.5);
					movementDir[2] += 5.5;
				}
			} else if ((Player.onGround or Player.jumpCoyote > 0.0) and Player.jumpCooldown <= 0) {
				jumping = true;
				Player.jumpCooldown = Player.jumpCooldownConstant;
				if (!Player.onGround) {
					Player.eye.coyote = 0;
				}
				Player.jumpCoyote = 0;
			} else if (!KeyBoard.key("fall").pressed) {
				movementSpeed = @max(movementSpeed, walkingSpeed);
				movementDir[2] += walkingSpeed;
			}
		} else {
			Player.jumpCooldown = 0;
		}
		if (KeyBoard.key("fall").pressed) {
			if (Player.isFlying.load(.monotonic)) {
				if (KeyBoard.key("sprint").pressed) {
					if (Player.isGhost.load(.monotonic)) {
						movementSpeed = @max(movementSpeed, 60);
						movementDir[2] -= 60;
					} else {
						movementSpeed = @max(movementSpeed, 25);
						movementDir[2] -= 25;
					}
				} else {
					movementSpeed = @max(movementSpeed, 5.5);
					movementDir[2] -= 5.5;
				}
			} else if (!KeyBoard.key("jump").pressed) {
				movementSpeed = @max(movementSpeed, walkingSpeed);
				movementDir[2] -= walkingSpeed;
			}
		}

		if (movementSpeed != 0 and vec.lengthSquare(movementDir) != 0) {
			if (vec.lengthSquare(movementDir) > movementSpeed*movementSpeed) {
				movementDir = vec.normalize(movementDir);
			} else {
				movementDir /= @splat(movementSpeed);
			}
			acc += movementDir*@as(Vec3d, @splat(movementSpeed*fricMul));
		}

		const newSlot: i32 = @as(i32, @intCast(Player.selectedSlot)) -% main.Window.scrollOffsetInteger;
		Player.selectedSlot = @intCast(@mod(newSlot, 12));

		const newPos = Vec2f{
			@floatCast(main.KeyBoard.key("cameraRight").value - main.KeyBoard.key("cameraLeft").value),
			@floatCast(main.KeyBoard.key("cameraDown").value - main.KeyBoard.key("cameraUp").value),
		}*@as(Vec2f, @splat(std.math.pi*settings.controllerSensitivity));
		main.game.camera.moveRotation(newPos[0]/64.0, newPos[1]/64.0);
	}

	Player.crouching = KeyBoard.key("crouch").pressed and !Player.isFlying.load(.monotonic);

	if (collision.collides(.client, .x, 0, Player.super.pos + Player.standingBoundingBoxExtent - Player.crouchingBoundingBoxExtent, .{
		.min = -Player.standingBoundingBoxExtent,
		.max = Player.standingBoundingBoxExtent,
	}) == null) {
		if (Player.onGround) {
			if (Player.crouching) {
				Player.crouchPerc += @floatCast(deltaTime*10);
			} else {
				Player.crouchPerc -= @floatCast(deltaTime*10);
			}
			Player.crouchPerc = std.math.clamp(Player.crouchPerc, 0, 1);
		}

		const smoothPerc = Player.crouchPerc*Player.crouchPerc*(3 - 2*Player.crouchPerc);

		const newOuterBox = (Player.crouchingBoundingBoxExtent - Player.standingBoundingBoxExtent)*@as(Vec3d, @splat(smoothPerc)) + Player.standingBoundingBoxExtent;

		Player.super.pos += newOuterBox - Player.outerBoundingBoxExtent + Vec3d{0.0, 0.0, 0.0001*@abs(newOuterBox[2] - Player.outerBoundingBoxExtent[2])};

		Player.outerBoundingBoxExtent = newOuterBox;

		Player.outerBoundingBox = .{
			.min = -Player.outerBoundingBoxExtent,
			.max = Player.outerBoundingBoxExtent,
		};
		Player.eye.box = .{
			.min = -Vec3d{Player.outerBoundingBoxExtent[0]*0.2, Player.outerBoundingBoxExtent[1]*0.2, Player.outerBoundingBoxExtent[2] - 0.2},
			.max = Vec3d{Player.outerBoundingBoxExtent[0]*0.2, Player.outerBoundingBoxExtent[1]*0.2, Player.outerBoundingBoxExtent[2] - 0.05},
		};
		Player.eye.desiredPos = (Vec3d{0, 0, 1.3 - Player.crouchingBoundingBoxExtent[2]} - Vec3d{0, 0, 1.7 - Player.standingBoundingBoxExtent[2]})*@as(Vec3f, @splat(smoothPerc)) + Vec3d{0, 0, 1.7 - Player.standingBoundingBoxExtent[2]};
	}

	physics.update(deltaTime, acc, jumping);

	const time = main.timestamp();
	if (nextBlockPlaceTime) |*placeTime| {
		if (placeTime.durationTo(time).nanoseconds >= 0) {
			placeTime.* = placeTime.addDuration(main.settings.updateRepeatSpeed);
			Player.placeBlock(main.KeyBoard.key("placeBlock").modsOnPress);
		}
	}
	if (nextBlockBreakTime) |*breakTime| {
		if (breakTime.durationTo(time).nanoseconds >= 0 or !Player.isCreative()) {
			breakTime.* = breakTime.addDuration(main.settings.updateRepeatSpeed);
			Player.breakBlock(deltaTime);
		}
	}

	const biome = world.?.playerBiome.load(.monotonic);

	const t = 1 - @as(f32, @floatCast(@exp(-2*deltaTime)));

	biomeFog.fogColor = (biome.fogColor - biomeFog.fogColor)*@as(Vec3f, @splat(t)) + biomeFog.fogColor;
	biomeFog.skyColor = (biome.skyColor - biomeFog.skyColor)*@as(Vec3f, @splat(t)) + biomeFog.skyColor;
	biomeFog.density = (biome.fogDensity - biomeFog.density)*t + biomeFog.density;
	biomeFog.fogLower = (biome.fogLower - biomeFog.fogLower)*t + biomeFog.fogLower;
	biomeFog.fogHigher = (biome.fogHigher - biomeFog.fogHigher)*t + biomeFog.fogHigher;

	world.?.update();
	particles.ParticleSystem.update(@floatCast(deltaTime));
}

```

`src/graphics.zig`:

```zig
/// A collection of things that should make dealing with opengl easier.
/// Also contains some basic 2d drawing stuff.
const std = @import("std");
const builtin = @import("builtin");

pub const hbft = @cImport({
	@cDefine("_BITS_STDIO2_H", ""); // TODO: Zig fails to include this header file
	@cInclude("freetype/ftadvanc.h");
	@cInclude("freetype/ftbbox.h");
	@cInclude("freetype/ftbitmap.h");
	@cInclude("freetype/ftcolor.h");
	@cInclude("freetype/ftlcdfil.h");
	@cInclude("freetype/ftsizes.h");
	@cInclude("freetype/ftstroke.h");
	@cInclude("freetype/fttrigon.h");
	@cInclude("freetype/ftsynth.h");
	@cInclude("hb.h");
	@cInclude("hb-ft.h");
});

const vec = @import("vec.zig");
const Mat4f = vec.Mat4f;
const Vec4i = vec.Vec4i;
const Vec4f = vec.Vec4f;
const Vec2f = vec.Vec2f;
const Vec2i = vec.Vec2i;
const Vec3f = vec.Vec3f;

const main = @import("main");
const Window = main.Window;

const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const c = @cImport({
	@cInclude("glad/gl.h");
	// NOTE(blackedout): glad is currently not used on macOS, so use Vulkan header from the Vulkan-Headers repository instead
	@cInclude(if (builtin.target.os.tag == .macos) "vulkan/vulkan.h" else "glad/vulkan.h");
});

pub const stb_image = @cImport({
	@cDefine("_BITS_STDIO2_H", ""); // TODO: Zig fails to include this header file
	@cInclude("stb/stb_image.h");
	@cInclude("stb/stb_image_write.h");
});

const glslang = @cImport({
	@cInclude("glslang/Include/glslang_c_interface.h");
	@cInclude("glslang/Public/resource_limits_c.h");
});

pub const draw = struct { // MARK: draw
	var color: u32 = 0;
	var clip: ?Vec4i = null;
	var translation: Vec2f = Vec2f{0, 0};
	var scale: f32 = 1;

	pub fn setColor(newColor: u32) void {
		color = newColor;
	}

	/// Returns the previous translation.
	pub fn setTranslation(newTranslation: Vec2f) Vec2f {
		const oldTranslation = translation;
		translation += newTranslation*@as(Vec2f, @splat(scale));
		return oldTranslation;
	}

	pub fn restoreTranslation(previousTranslation: Vec2f) void {
		translation = previousTranslation;
	}

	/// Returns the previous scale.
	pub fn setScale(newScale: f32) f32 {
		std.debug.assert(newScale >= 0);
		const oldScale = scale;
		scale *= newScale;
		return oldScale;
	}

	pub fn restoreScale(previousScale: f32) void {
		scale = previousScale;
	}

	/// Returns the previous clip.
	pub fn setClip(clipRect: Vec2f) ?Vec4i {
		std.debug.assert(@reduce(.And, clipRect >= Vec2f{0, 0}));
		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		var newClip = Vec4i{
			std.math.lossyCast(i32, translation[0]),
			viewport[3] - std.math.lossyCast(i32, translation[1] + clipRect[1]*scale),
			std.math.lossyCast(i32, clipRect[0]*scale),
			std.math.lossyCast(i32, clipRect[1]*scale),
		};
		if (clip) |oldClip| {
			if (newClip[0] < oldClip[0]) {
				newClip[2] -= oldClip[0] - newClip[0];
				newClip[0] += oldClip[0] - newClip[0];
			}
			if (newClip[1] < oldClip[1]) {
				newClip[3] -= oldClip[1] - newClip[1];
				newClip[1] += oldClip[1] - newClip[1];
			}
			if (newClip[0] + newClip[2] > oldClip[0] + oldClip[2]) {
				newClip[2] -= (newClip[0] + newClip[2]) - (oldClip[0] + oldClip[2]);
			}
			if (newClip[1] + newClip[3] > oldClip[1] + oldClip[3]) {
				newClip[3] -= (newClip[1] + newClip[3]) - (oldClip[1] + oldClip[3]);
			}
			newClip[2] = @max(newClip[2], 0);
			newClip[3] = @max(newClip[3], 0);
		}
		const oldClip = clip;
		clip = newClip;
		return oldClip;
	}

	pub fn getScissor() ?c.VkRect2D {
		const clipRect = clip orelse return null;
		return .{
			.offset = .{
				.x = clipRect[0],
				.y = clipRect[1],
			},
			.extent = .{
				.width = @intCast(clipRect[2]),
				.height = @intCast(clipRect[3]),
			},
		};
	}

	/// Should be used to restore the old clip when leaving the render function.
	pub fn restoreClip(previousClip: ?Vec4i) void {
		clip = previousClip;
	}

	// ----------------------------------------------------------------------------
	// MARK: fillRect()
	var rectUniforms: struct {
		screen: c_int,
		start: c_int,
		size: c_int,
		rectColor: c_int,
	} = undefined;
	var rectPipeline: Pipeline = undefined;
	pub var rectVAO: c_uint = undefined;
	var rectVBO: c_uint = undefined;

	fn initRect() void {
		rectPipeline = Pipeline.init(
			"assets/cubyz/shaders/graphics/Rect.vert",
			"assets/cubyz/shaders/graphics/Rect.frag",
			"",
			&rectUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.alphaBlending}},
		);
		const rawData = [_]f32{
			0, 0,
			0, 1,
			1, 0,
			1, 1,
		};

		c.glGenVertexArrays(1, &rectVAO);
		c.glBindVertexArray(rectVAO);
		c.glGenBuffers(1, &rectVBO);
		c.glBindBuffer(c.GL_ARRAY_BUFFER, rectVBO);
		c.glBufferData(c.GL_ARRAY_BUFFER, rawData.len*@sizeOf(f32), &rawData, c.GL_STATIC_DRAW);
		c.glVertexAttribPointer(0, 2, c.GL_FLOAT, c.GL_FALSE, 2*@sizeOf(f32), null);
		c.glEnableVertexAttribArray(0);
	}

	fn deinitRect() void {
		rectPipeline.deinit();
		c.glDeleteVertexArrays(1, &rectVAO);
		c.glDeleteBuffers(1, &rectVBO);
	}

	pub fn rect(_pos: Vec2f, _dim: Vec2f) void {
		var pos = _pos;
		var dim = _dim;
		pos *= @splat(scale);
		pos += translation;
		dim *= @splat(scale);

		rectPipeline.bind(getScissor());

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(rectUniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(rectUniforms.start, pos[0], pos[1]);
		c.glUniform2f(rectUniforms.size, dim[0], dim[1]);
		c.glUniform1i(rectUniforms.rectColor, @bitCast(color));

		c.glBindVertexArray(rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	// ----------------------------------------------------------------------------
	// MARK: fillRectBorder()
	var rectBorderUniforms: struct {
		screen: c_int,
		start: c_int,
		size: c_int,
		rectColor: c_int,
		lineWidth: c_int,
	} = undefined;
	var rectBorderPipeline: Pipeline = undefined;
	var rectBorderVAO: c_uint = undefined;
	var rectBorderVBO: c_uint = undefined;

	fn initRectBorder() void {
		rectBorderPipeline = Pipeline.init(
			"assets/cubyz/shaders/graphics/RectBorder.vert",
			"assets/cubyz/shaders/graphics/RectBorder.frag",
			"",
			&rectBorderUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.alphaBlending}},
		);
		const rawData = [_]f32{
			0, 0, 0,  0,
			0, 0, 1,  1,
			0, 1, 0,  0,
			0, 1, 1,  -1,
			1, 1, 0,  0,
			1, 1, -1, -1,
			1, 0, 0,  0,
			1, 0, -1, 1,
			0, 0, 0,  0,
			0, 0, 1,  1,
		};

		c.glGenVertexArrays(1, &rectBorderVAO);
		c.glBindVertexArray(rectBorderVAO);
		c.glGenBuffers(1, &rectBorderVBO);
		c.glBindBuffer(c.GL_ARRAY_BUFFER, rectBorderVBO);
		c.glBufferData(c.GL_ARRAY_BUFFER, rawData.len*@sizeOf(f32), &rawData, c.GL_STATIC_DRAW);
		c.glVertexAttribPointer(0, 4, c.GL_FLOAT, c.GL_FALSE, 4*@sizeOf(f32), null);
		c.glEnableVertexAttribArray(0);
	}

	fn deinitRectBorder() void {
		rectBorderPipeline.deinit();
		c.glDeleteVertexArrays(1, &rectBorderVAO);
		c.glDeleteBuffers(1, &rectBorderVBO);
	}

	pub fn rectBorder(_pos: Vec2f, _dim: Vec2f, _width: f32) void {
		var pos = _pos;
		var dim = _dim;
		var width = _width;
		pos *= @splat(scale);
		pos += translation;
		dim *= @splat(scale);
		width *= scale;

		rectBorderPipeline.bind(getScissor());

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(rectBorderUniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(rectBorderUniforms.start, pos[0], pos[1]);
		c.glUniform2f(rectBorderUniforms.size, dim[0], dim[1]);
		c.glUniform1i(rectBorderUniforms.rectColor, @bitCast(color));
		c.glUniform1f(rectBorderUniforms.lineWidth, width);

		c.glBindVertexArray(rectBorderVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 10);
	}

	// ----------------------------------------------------------------------------
	// MARK: drawLine()
	var lineUniforms: struct {
		screen: c_int,
		start: c_int,
		direction: c_int,
		lineColor: c_int,
	} = undefined;
	var linePipeline: Pipeline = undefined;
	var lineVAO: c_uint = undefined;
	var lineVBO: c_uint = undefined;

	fn initLine() void {
		linePipeline = Pipeline.init(
			"assets/cubyz/shaders/graphics/Line.vert",
			"assets/cubyz/shaders/graphics/Line.frag",
			"",
			&lineUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.alphaBlending}},
		);
		const rawData = [_]f32{
			0, 0,
			1, 1,
		};

		c.glGenVertexArrays(1, &lineVAO);
		c.glBindVertexArray(lineVAO);
		c.glGenBuffers(1, &lineVBO);
		c.glBindBuffer(c.GL_ARRAY_BUFFER, lineVBO);
		c.glBufferData(c.GL_ARRAY_BUFFER, rawData.len*@sizeOf(f32), &rawData, c.GL_STATIC_DRAW);
		c.glVertexAttribPointer(0, 2, c.GL_FLOAT, c.GL_FALSE, 2*@sizeOf(f32), null);
		c.glEnableVertexAttribArray(0);
	}

	fn deinitLine() void {
		linePipeline.deinit();
		c.glDeleteVertexArrays(1, &lineVAO);
		c.glDeleteBuffers(1, &lineVBO);
	}

	pub fn line(_pos1: Vec2f, _pos2: Vec2f) void {
		var pos1 = _pos1;
		var pos2 = _pos2;
		pos1 *= @splat(scale);
		pos1 += translation;
		pos2 *= @splat(scale);
		pos2 += translation;

		linePipeline.bind(getScissor());

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(lineUniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(lineUniforms.start, pos1[0], pos1[1]);
		c.glUniform2f(lineUniforms.direction, pos2[0] - pos1[0], pos2[1] - pos1[1]);
		c.glUniform1i(lineUniforms.lineColor, @bitCast(color));

		c.glBindVertexArray(lineVAO);
		c.glDrawArrays(c.GL_LINE_STRIP, 0, 2);
	}

	// ----------------------------------------------------------------------------
	// MARK: drawRect()
	// Draw rect can use the same shader as drawline, because it essentially draws lines.
	var drawRectVAO: c_uint = undefined;
	var drawRectVBO: c_uint = undefined;

	fn initDrawRect() void {
		const rawData = [_]f32{
			0, 0,
			0, 1,
			1, 1,
			1, 0,
		};

		c.glGenVertexArrays(1, &drawRectVAO);
		c.glBindVertexArray(drawRectVAO);
		c.glGenBuffers(1, &drawRectVBO);
		c.glBindBuffer(c.GL_ARRAY_BUFFER, drawRectVBO);
		c.glBufferData(c.GL_ARRAY_BUFFER, rawData.len*@sizeOf(f32), &rawData, c.GL_STATIC_DRAW);
		c.glVertexAttribPointer(0, 2, c.GL_FLOAT, c.GL_FALSE, 2*@sizeOf(f32), null);
		c.glEnableVertexAttribArray(0);
	}

	fn deinitDrawRect() void {
		c.glDeleteVertexArrays(1, &drawRectVAO);
		c.glDeleteBuffers(1, &drawRectVBO);
	}

	pub fn rectOutline(_pos: Vec2f, _dim: Vec2f) void {
		var pos = _pos;
		var dim = _dim;
		pos *= @splat(scale);
		pos += translation;
		dim *= @splat(scale);

		linePipeline.bind(getScissor());

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(lineUniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(lineUniforms.start, pos[0], pos[1]); // Move the coordinates, so they are in the center of a pixel.
		c.glUniform2f(lineUniforms.direction, dim[0] - 1, dim[1] - 1); // The height is a lot smaller because the inner edge of the rect is drawn.
		c.glUniform1i(lineUniforms.lineColor, @bitCast(color));

		c.glBindVertexArray(lineVAO);
		c.glDrawArrays(c.GL_LINE_LOOP, 0, 5);
	}

	// ----------------------------------------------------------------------------
	// MARK: fillCircle()
	var circleUniforms: struct {
		screen: c_int,
		center: c_int,
		radius: c_int,
		circleColor: c_int,
	} = undefined;
	var circlePipeline: Pipeline = undefined;
	var circleVAO: c_uint = undefined;
	var circleVBO: c_uint = undefined;

	fn initCircle() void {
		circlePipeline = Pipeline.init(
			"assets/cubyz/shaders/graphics/Circle.vert",
			"assets/cubyz/shaders/graphics/Circle.frag",
			"",
			&circleUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.alphaBlending}},
		);
		const rawData = [_]f32{
			-1, -1,
			-1, 1,
			1,  -1,
			1,  1,
		};

		c.glGenVertexArrays(1, &circleVAO);
		c.glBindVertexArray(circleVAO);
		c.glGenBuffers(1, &circleVBO);
		c.glBindBuffer(c.GL_ARRAY_BUFFER, circleVBO);
		c.glBufferData(c.GL_ARRAY_BUFFER, rawData.len*@sizeOf(f32), &rawData, c.GL_STATIC_DRAW);
		c.glVertexAttribPointer(0, 2, c.GL_FLOAT, c.GL_FALSE, 2*@sizeOf(f32), null);
		c.glEnableVertexAttribArray(0);
	}

	fn deinitCircle() void {
		circlePipeline.deinit();
		c.glDeleteVertexArrays(1, &circleVAO);
		c.glDeleteBuffers(1, &circleVBO);
	}

	pub fn circle(_center: Vec2f, _radius: f32) void {
		var center = _center;
		var radius = _radius;
		center *= @splat(scale);
		center += translation;
		radius *= scale;
		circlePipeline.bind(getScissor());

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(circleUniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(circleUniforms.center, center[0], center[1]); // Move the coordinates, so they are in the center of a pixel.
		c.glUniform1f(circleUniforms.radius, radius); // The height is a lot smaller because the inner edge of the rect is drawn.
		c.glUniform1i(circleUniforms.circleColor, @bitCast(color));

		c.glBindVertexArray(circleVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	// ----------------------------------------------------------------------------
	// MARK: drawImage()
	// Luckily the vao of the regular rect can used.
	var imageUniforms: struct {
		screen: c_int,
		start: c_int,
		size: c_int,
		color: c_int,
		uvOffset: c_int,
		uvDim: c_int,
	} = undefined;
	var imagePipeline: Pipeline = undefined;

	fn initImage() void {
		imagePipeline = Pipeline.init(
			"assets/cubyz/shaders/graphics/Image.vert",
			"assets/cubyz/shaders/graphics/Image.frag",
			"",
			&imageUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.alphaBlending}},
		);
	}

	fn deinitImage() void {
		imagePipeline.deinit();
	}

	pub fn boundImage(_pos: Vec2f, _dim: Vec2f) void {
		imagePipeline.bind(getScissor());

		customShadedImage(&imageUniforms, _pos, _dim);
	}

	pub fn boundSubImage(_pos: Vec2f, _dim: Vec2f, uvOffset: Vec2f, uvDim: Vec2f) void {
		var pos = _pos;
		var dim = _dim;
		pos *= @splat(scale);
		pos += translation;
		dim *= @splat(scale);
		pos = @floor(pos);
		dim = @ceil(dim);

		imagePipeline.bind(getScissor());

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(imageUniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(imageUniforms.start, pos[0], pos[1]);
		c.glUniform2f(imageUniforms.size, dim[0], dim[1]);
		c.glUniform1i(imageUniforms.color, @bitCast(color));
		c.glUniform2f(imageUniforms.uvOffset, uvOffset[0], 1 - uvOffset[1] - uvDim[1]);
		c.glUniform2f(imageUniforms.uvDim, uvDim[0], uvDim[1]);

		c.glBindVertexArray(rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	pub fn customShadedImage(uniforms: anytype, _pos: Vec2f, _dim: Vec2f) void {
		var pos = _pos;
		var dim = _dim;
		pos *= @splat(scale);
		pos += translation;
		dim *= @splat(scale);
		pos = @floor(pos);
		dim = @ceil(dim);

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(uniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(uniforms.start, pos[0], pos[1]);
		c.glUniform2f(uniforms.size, dim[0], dim[1]);
		c.glUniform1i(uniforms.color, @bitCast(color));
		c.glUniform2f(uniforms.uvOffset, 0, 0);
		c.glUniform2f(uniforms.uvDim, 1, 1);

		c.glBindVertexArray(rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	// ----------------------------------------------------------------------------
	// MARK: customShadedRect()

	pub fn customShadedRect(uniforms: anytype, _pos: Vec2f, _dim: Vec2f) void {
		var pos = _pos;
		var dim = _dim;
		pos *= @splat(scale);
		pos += translation;
		dim *= @splat(scale);
		pos = @floor(pos);
		dim = @ceil(dim);

		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(uniforms.screen, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform2f(uniforms.start, pos[0], pos[1]);
		c.glUniform2f(uniforms.size, dim[0], dim[1]);
		c.glUniform1i(uniforms.color, @bitCast(color));
		c.glUniform1f(uniforms.scale, scale);

		c.glBindVertexArray(rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	// ----------------------------------------------------------------------------
	// MARK: text()

	pub fn text(_text: []const u8, x: f32, y: f32, fontSize: f32, alignment: TextBuffer.Alignment) void {
		TextRendering.renderText(_text, x, y, fontSize, .{.color = @truncate(@as(u32, @bitCast(color)))}, alignment);
	}

	pub inline fn print(comptime format: []const u8, args: anytype, x: f32, y: f32, fontSize: f32, alignment: TextBuffer.Alignment) void {
		const string = std.fmt.allocPrint(main.stackAllocator.allocator, format, args) catch unreachable;
		defer main.stackAllocator.free(string);
		text(string, x, y, fontSize, alignment);
	}
};

pub const TextBuffer = struct { // MARK: TextBuffer

	pub const Alignment = enum {
		left,
		center,
		right,
	};

	pub const FontEffect = packed struct(u28) {
		color: u24 = 0xffffff,
		bold: bool = false,
		italic: bool = false,
		underline: bool = false,
		strikethrough: bool = false,

		fn hasLine(self: FontEffect, comptime isUnderline: bool) bool {
			if (isUnderline) return self.underline;
			return self.strikethrough;
		}
	};

	const Line = struct {
		start: f32,
		end: f32,
		color: u24,
		isUnderline: bool,
	};

	const LineBreak = struct {
		index: u32,
		width: f32,
	};

	const GlyphData = struct {
		x_advance: f32,
		y_advance: f32,
		x_offset: f32,
		y_offset: f32,
		character: u21,
		index: u32,
		cluster: u32,
		fontEffect: FontEffect,
		characterIndex: u32,
	};

	alignment: Alignment,
	width: f32,
	buffer: ?*hbft.hb_buffer_t,
	glyphs: []GlyphData,
	lines: main.List(Line),
	lineBreaks: main.List(LineBreak),

	fn addLine(self: *TextBuffer, line: Line) void {
		if (line.start != line.end) {
			self.lines.append(line);
		}
	}

	fn initLines(self: *TextBuffer, comptime isUnderline: bool) void {
		var line: Line = Line{.start = 0, .end = 0, .color = 0, .isUnderline = isUnderline};
		var lastFontEffect: FontEffect = .{};
		for (self.glyphs) |glyph| {
			const fontEffect = glyph.fontEffect;
			if (lastFontEffect.hasLine(isUnderline)) {
				if (fontEffect.color != lastFontEffect.color) {
					self.addLine(line);
					line.color = fontEffect.color;
					line.start = line.end;
				} else if (!fontEffect.hasLine(isUnderline)) {
					self.addLine(line);
				}
			} else if (fontEffect.hasLine(isUnderline)) {
				line.start = line.end;
				line.color = fontEffect.color;
			}
			lastFontEffect = fontEffect;
			line.end += glyph.x_advance;
		}
		if (lastFontEffect.hasLine(isUnderline)) {
			self.addLine(line);
		}
	}

	pub const Parser = struct {
		unicodeIterator: std.unicode.Utf8Iterator,
		currentFontEffect: FontEffect,
		parsedText: main.List(u32),
		fontEffects: main.List(FontEffect),
		characterIndex: main.List(u32),
		showControlCharacters: bool,
		curChar: u21 = undefined,
		curIndex: u32 = 0,

		fn appendControlGetNext(self: *Parser) ?void {
			if (self.showControlCharacters) {
				self.fontEffects.append(.{.color = 0x808080});
				self.parsedText.append(self.curChar);
				self.characterIndex.append(self.curIndex);
			}
			self.curIndex = @intCast(self.unicodeIterator.i);
			self.curChar = self.unicodeIterator.nextCodepoint() orelse return null;
		}

		fn appendGetNext(self: *Parser) ?void {
			self.fontEffects.append(self.currentFontEffect);
			self.parsedText.append(self.curChar);
			self.characterIndex.append(self.curIndex);
			self.curIndex = @intCast(self.unicodeIterator.i);
			self.curChar = self.unicodeIterator.nextCodepoint() orelse return null;
		}

		fn peekNextByte(self: *Parser) u8 {
			const next = self.unicodeIterator.peek(1);
			if (next.len == 0) return 0;
			return next[0];
		}

		fn parse(self: *Parser) void {
			self.curIndex = @intCast(self.unicodeIterator.i);
			self.curChar = self.unicodeIterator.nextCodepoint() orelse return;
			while (true) switch (self.curChar) {
				'*' => {
					self.appendControlGetNext() orelse return;
					if (self.curChar == '*') {
						self.appendControlGetNext() orelse return;
						self.currentFontEffect.bold = !self.currentFontEffect.bold;
					} else {
						self.currentFontEffect.italic = !self.currentFontEffect.italic;
					}
				},
				'_' => {
					if (self.peekNextByte() == '_') {
						self.appendControlGetNext() orelse return;
						self.appendControlGetNext() orelse return;
						self.currentFontEffect.underline = !self.currentFontEffect.underline;
					} else {
						self.appendGetNext() orelse return;
					}
				},
				'~' => {
					if (self.peekNextByte() == '~') {
						self.appendControlGetNext() orelse return;
						self.appendControlGetNext() orelse return;
						self.currentFontEffect.strikethrough = !self.currentFontEffect.strikethrough;
					} else {
						self.appendGetNext() orelse return;
					}
				},
				'\\' => {
					self.appendControlGetNext() orelse return;
					self.appendGetNext() orelse return;
				},
				'#' => {
					self.appendControlGetNext() orelse return;
					var shift: u5 = 20;
					while (true) : (shift -= 4) {
						self.currentFontEffect.color = (self.currentFontEffect.color & ~(@as(u24, 0xf) << shift)) | @as(u24, switch (self.curChar) {
							'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => self.curChar - '0',
							'a', 'b', 'c', 'd', 'e', 'f' => self.curChar - 'a' + 10,
							'A', 'B', 'C', 'D', 'E', 'F' => self.curChar - 'A' + 10,
							else => 0,
						}) << shift;
						self.appendControlGetNext() orelse return;
						if (shift == 0) break;
					}
				},
				'§' => {
					self.currentFontEffect = .{.color = self.currentFontEffect.color};
					self.appendControlGetNext() orelse return;
				},
				else => {
					self.appendGetNext() orelse return;
				},
			};
		}

		pub fn countVisibleCharacters(text: []const u8) usize {
			var unicodeIterator = std.unicode.Utf8Iterator{.bytes = text, .i = 0};
			var count: usize = 0;
			var curChar = unicodeIterator.nextCodepoint() orelse return count;
			outer: while (true) switch (curChar) {
				'*' => {
					curChar = unicodeIterator.nextCodepoint() orelse break;
				},
				'_' => {
					curChar = unicodeIterator.nextCodepoint() orelse break;
					if (curChar == '_') {
						curChar = unicodeIterator.nextCodepoint() orelse break;
					} else {
						count += 1;
					}
				},
				'~' => {
					curChar = unicodeIterator.nextCodepoint() orelse break;
					if (curChar == '~') {
						curChar = unicodeIterator.nextCodepoint() orelse break;
					} else {
						count += 1;
					}
				},
				'\\' => {
					curChar = unicodeIterator.nextCodepoint() orelse break;
					curChar = unicodeIterator.nextCodepoint() orelse break;
					count += 1;
				},
				'#' => {
					for (0..7) |_| curChar = unicodeIterator.nextCodepoint() orelse break :outer;
				},
				'§' => {
					curChar = unicodeIterator.nextCodepoint() orelse break;
				},
				else => {
					count += 1;
					curChar = unicodeIterator.nextCodepoint() orelse break;
				},
			};
			return count;
		}
	};

	pub fn init(allocator: NeverFailingAllocator, text: []const u8, initialFontEffect: FontEffect, showControlCharacters: bool, alignment: Alignment) TextBuffer {
		var self: TextBuffer = .{
			.alignment = alignment,
			.width = 1e9,
			.buffer = null,
			.glyphs = &.{},
			.lines = .init(allocator),
			.lineBreaks = .init(allocator),
		};
		// Parse the input text:
		var parser = Parser{
			.unicodeIterator = std.unicode.Utf8Iterator{.bytes = text, .i = 0},
			.currentFontEffect = initialFontEffect,
			.parsedText = .init(main.stackAllocator),
			.fontEffects = .init(allocator),
			.characterIndex = .init(allocator),
			.showControlCharacters = showControlCharacters,
		};
		defer parser.fontEffects.deinit();
		defer parser.parsedText.deinit();
		defer parser.characterIndex.deinit();
		parser.parse();
		if (parser.parsedText.items.len == 0) {
			self.lineBreaks.append(.{.index = 0, .width = 0});
			return self;
		}

		// Let harfbuzz do its thing:
		const buffer = hbft.hb_buffer_create() orelse @panic("Out of Memory while creating harfbuzz buffer");
		defer hbft.hb_buffer_destroy(buffer);
		hbft.hb_buffer_add_utf32(buffer, parser.parsedText.items.ptr, @intCast(parser.parsedText.items.len), 0, @intCast(parser.parsedText.items.len));
		hbft.hb_buffer_set_direction(buffer, hbft.HB_DIRECTION_LTR);
		hbft.hb_buffer_set_script(buffer, hbft.HB_SCRIPT_COMMON);
		hbft.hb_buffer_set_language(buffer, hbft.hb_language_get_default());
		hbft.hb_shape(TextRendering.harfbuzzFont, buffer, null, 0);
		var glyphInfos: []hbft.hb_glyph_info_t = undefined;
		var glyphPositions: []hbft.hb_glyph_position_t = undefined;
		{
			var len: c_uint = 0;
			glyphInfos.ptr = hbft.hb_buffer_get_glyph_infos(buffer, &len).?;
			glyphPositions.ptr = hbft.hb_buffer_get_glyph_positions(buffer, &len).?;
			glyphInfos.len = len;
			glyphPositions.len = len;
		}

		// Guess the text index from the given cluster indices. Only works if the number of glyphs and the number of characters in a cluster is the same.
		const textIndexGuess = main.stackAllocator.alloc(u32, glyphInfos.len);
		defer main.stackAllocator.free(textIndexGuess);
		for (textIndexGuess, 0..) |*index, i| {
			if (i == 0 or glyphInfos[i - 1].cluster != glyphInfos[i].cluster) {
				index.* = glyphInfos[i].cluster;
			} else {
				index.* = @min(textIndexGuess[i - 1] + 1, @as(u32, @intCast(parser.parsedText.items.len - 1)));
				for (glyphInfos[i..]) |glyphInfo| {
					if (glyphInfo.cluster != glyphInfos[i].cluster) {
						index.* = @min(index.*, glyphInfo.cluster - 1);
						break;
					}
				}
			}
		}

		// Merge it all together:
		self.glyphs = allocator.alloc(GlyphData, glyphInfos.len);
		for (self.glyphs, 0..) |*glyph, i| {
			glyph.x_advance = @as(f32, @floatFromInt(glyphPositions[i].x_advance))/TextRendering.fontUnitsPerPixel;
			glyph.y_advance = @as(f32, @floatFromInt(glyphPositions[i].y_advance))/TextRendering.fontUnitsPerPixel;
			glyph.x_offset = @as(f32, @floatFromInt(glyphPositions[i].x_offset))/TextRendering.fontUnitsPerPixel;
			glyph.y_offset = @as(f32, @floatFromInt(glyphPositions[i].y_offset))/TextRendering.fontUnitsPerPixel;
			glyph.character = @intCast(parser.parsedText.items[textIndexGuess[i]]);
			glyph.index = glyphInfos[i].codepoint;
			glyph.cluster = glyphInfos[i].cluster;
			glyph.fontEffect = parser.fontEffects.items[textIndexGuess[i]];
			glyph.characterIndex = parser.characterIndex.items[textIndexGuess[i]];
		}

		// Find the lines:
		self.initLines(true);
		self.initLines(false);
		self.lineBreaks.append(.{.index = 0, .width = 0});
		self.lineBreaks.append(.{.index = @intCast(self.glyphs.len), .width = 0});
		return self;
	}

	pub fn deinit(self: TextBuffer) void {
		self.lines.allocator.free(self.glyphs);
		self.lines.deinit();
		self.lineBreaks.deinit();
	}

	fn getLineOffset(self: TextBuffer, line: usize) f32 {
		const factor: f32 = switch (self.alignment) {
			.left => 0,
			.center => 0.5,
			.right => 1,
		};
		const diff = self.width - self.lineBreaks.items[line + 1].width;
		return diff*factor;
	}

	pub fn mousePosToIndex(self: TextBuffer, mousePos: Vec2f, bufferLen: usize) u32 {
		var line: usize = @intFromFloat(@max(0, mousePos[1]/16.0));
		line = @min(line, self.lineBreaks.items.len - 2);
		var x: f32 = self.getLineOffset(line);
		const start = self.lineBreaks.items[line].index;
		const end = self.lineBreaks.items[line + 1].index;
		for (self.glyphs[start..end]) |glyph| {
			if (mousePos[0] < x + glyph.x_advance/2) {
				return @intCast(glyph.characterIndex);
			}

			x += glyph.x_advance;
		}
		return @intCast(if (end < self.glyphs.len) self.glyphs[end - 1].characterIndex else bufferLen);
	}

	pub fn indexToCursorPos(self: TextBuffer, index: u32) Vec2f {
		var x: f32 = 0;
		var y: f32 = 0;
		var i: usize = 0;
		while (true) {
			x = self.getLineOffset(i);
			for (self.glyphs[self.lineBreaks.items[i].index..self.lineBreaks.items[i + 1].index]) |glyph| {
				if (glyph.characterIndex == index) {
					return .{x, y};
				}

				x += glyph.x_advance;
				y -= glyph.y_advance;
			}
			i += 1;
			if (i >= self.lineBreaks.items.len - 1) {
				return .{x, y};
			}
			y += 16;
		}
	}

	/// Returns the calculated dimensions of the text block.
	pub fn calculateLineBreaks(self: *TextBuffer, fontSize: f32, maxLineWidth: f32) Vec2f {
		self.lineBreaks.clearRetainingCapacity();
		const spaceCharacterWidth = 8;
		self.lineBreaks.append(.{.index = 0, .width = 0});
		const scaledMaxWidth = maxLineWidth/fontSize*16.0;
		var lineWidth: f32 = 0;
		var lastSpaceWidth: f32 = 0;
		var lastSpaceIndex: u32 = 0;
		for (self.glyphs, 0..) |glyph, i| {
			lineWidth += glyph.x_advance;
			if (glyph.character == ' ') {
				lastSpaceWidth = lineWidth;
				lastSpaceIndex = @intCast(i + 1);
			}
			if (glyph.character == '\n') {
				self.lineBreaks.append(.{.index = @intCast(i + 1), .width = lineWidth - spaceCharacterWidth});
				lineWidth = 0;
				lastSpaceIndex = 0;
				lastSpaceWidth = 0;
			}
			if (lineWidth > scaledMaxWidth) {
				if (lastSpaceIndex != 0) {
					lineWidth -= lastSpaceWidth;
					self.lineBreaks.append(.{.index = lastSpaceIndex, .width = lastSpaceWidth - spaceCharacterWidth});
					lastSpaceIndex = 0;
					lastSpaceWidth = 0;
				} else {
					self.lineBreaks.append(.{.index = @intCast(i), .width = lineWidth - glyph.x_advance});
					lineWidth = glyph.x_advance;
					lastSpaceIndex = 0;
					lastSpaceWidth = 0;
				}
			}
		}
		self.width = maxLineWidth;
		self.lineBreaks.append(.{.index = @intCast(self.glyphs.len), .width = lineWidth});
		return Vec2f{maxLineWidth*fontSize/16.0, @as(f32, @floatFromInt(self.lineBreaks.items.len - 1))*fontSize};
	}

	pub fn drawSelection(self: TextBuffer, pos: Vec2f, selectionStart: u32, selectionEnd: u32) void {
		std.debug.assert(selectionStart <= selectionEnd);
		var x: f32 = self.getLineOffset(0);
		var y: f32 = 0;
		var i: usize = 0;
		var j: usize = 0;
		// Find the start row:
		outer: while (i < self.lineBreaks.items.len - 1) : (i += 1) {
			x = self.getLineOffset(i);
			while (j < self.lineBreaks.items[i + 1].index) : (j += 1) {
				const glyph = self.glyphs[j];
				if (glyph.characterIndex >= selectionStart) break :outer;
				x += glyph.x_advance;
				y -= glyph.y_advance;
			}
			y += 16;
		}
		while (i < self.lineBreaks.items.len - 1) {
			const startX = x;
			while (j < self.lineBreaks.items[i + 1].index and j < selectionEnd) : (j += 1) {
				const glyph = self.glyphs[j];
				if (glyph.characterIndex >= selectionEnd) break;
				x += glyph.x_advance;
				y -= glyph.y_advance;
			}
			draw.rect(pos + Vec2f{startX, y}, .{x - startX, 16});
			i += 1;
			if (i >= self.lineBreaks.items.len - 1) break;
			x = self.getLineOffset(i);
			y += 16;
		}
	}

	pub fn render(self: TextBuffer, _x: f32, _y: f32, _fontSize: f32) void {
		self.renderShadow(_x, _y, _fontSize);
		self.renderTextWithoutShadow(_x, _y, _fontSize);
	}

	pub fn renderTextWithoutShadow(self: TextBuffer, _x: f32, _y: f32, _fontSize: f32) void {
		const oldTranslation = draw.setTranslation(.{_x, _y});
		defer draw.restoreTranslation(oldTranslation);
		const oldScale = draw.setScale(_fontSize/16.0);
		defer draw.restoreScale(oldScale);
		var x: f32 = 0;
		var y: f32 = 0;
		TextRendering.pipeline.bind(draw.getScissor());
		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(TextRendering.uniforms.scene, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform1f(TextRendering.uniforms.ratio, draw.scale);
		c.glUniform1f(TextRendering.uniforms.alpha, @as(f32, @floatFromInt(draw.color >> 24))/255.0);
		c.glActiveTexture(c.GL_TEXTURE0);
		c.glBindTexture(c.GL_TEXTURE_2D, TextRendering.glyphTexture[0]);
		c.glBindVertexArray(draw.rectVAO);
		const lineWraps: []f32 = main.stackAllocator.alloc(f32, self.lineBreaks.items.len - 1);
		defer main.stackAllocator.free(lineWraps);
		var i: usize = 0;
		while (i < self.lineBreaks.items.len - 1) : (i += 1) {
			x = self.getLineOffset(i);
			for (self.glyphs[self.lineBreaks.items[i].index..self.lineBreaks.items[i + 1].index]) |glyph| {
				if (glyph.character != '\n') {
					const ftGlyph = TextRendering.getGlyph(glyph.index) catch continue;
					TextRendering.drawGlyph(ftGlyph, x + glyph.x_offset, y - glyph.y_offset, @bitCast(glyph.fontEffect));
				}
				x += glyph.x_advance;
				y -= glyph.y_advance;
			}
			lineWraps[i] = x - self.getLineOffset(i);
			x = 0;
			y += 16;
		}

		for (self.lines.items) |_line| {
			var line: Line = _line;
			y = 0;
			y += if (line.isUnderline) 15 else 8;
			const oldColor = draw.color;
			draw.setColor(line.color | (@as(u32, 0xff000000) & draw.color));
			defer draw.setColor(oldColor);
			for (lineWraps, 0..) |lineWrap, j| {
				const lineStart = @max(0, line.start);
				const lineEnd = @min(lineWrap, line.end);
				if (lineStart < lineEnd) {
					const start = Vec2f{lineStart + self.getLineOffset(j), y};
					const dim = Vec2f{lineEnd - lineStart, 1};
					draw.rect(start, dim);
				}
				line.start -= lineWrap;
				line.end -= lineWrap;
				y += 16;
			}
		}
	}

	fn shadowColor(color: u24) u24 {
		const r: f32 = @floatFromInt(color >> 16);
		const g: f32 = @floatFromInt(color >> 8 & 255);
		const b: f32 = @floatFromInt(color & 255);
		const perceivedBrightness = @sqrt(0.299*r*r + 0.587*g*g + 0.114*b*b);
		if (perceivedBrightness < 64) {
			return 0xffffff; // Make shadows white for better readability.
		} else {
			return 0;
		}
	}

	fn renderShadow(self: TextBuffer, _x: f32, _y: f32, _fontSize: f32) void { // Basically a copy of render with some color and position changes.
		const oldTranslation = draw.setTranslation(.{_x + _fontSize/16.0, _y + _fontSize/16.0});
		defer draw.restoreTranslation(oldTranslation);
		const oldScale = draw.setScale(_fontSize/16.0);
		defer draw.restoreScale(oldScale);
		var x: f32 = 0;
		var y: f32 = 0;
		TextRendering.pipeline.bind(draw.getScissor());
		var viewport: [4]c_int = undefined;
		c.glGetIntegerv(c.GL_VIEWPORT, &viewport);
		c.glUniform2f(TextRendering.uniforms.scene, @floatFromInt(viewport[2]), @floatFromInt(viewport[3]));
		c.glUniform1f(TextRendering.uniforms.ratio, draw.scale);
		c.glUniform1f(TextRendering.uniforms.alpha, @as(f32, @floatFromInt(draw.color >> 24))/255.0);
		c.glActiveTexture(c.GL_TEXTURE0);
		c.glBindTexture(c.GL_TEXTURE_2D, TextRendering.glyphTexture[0]);
		c.glBindVertexArray(draw.rectVAO);
		const lineWraps: []f32 = main.stackAllocator.alloc(f32, self.lineBreaks.items.len - 1);
		defer main.stackAllocator.free(lineWraps);
		var i: usize = 0;
		while (i < self.lineBreaks.items.len - 1) : (i += 1) {
			x = self.getLineOffset(i);
			for (self.glyphs[self.lineBreaks.items[i].index..self.lineBreaks.items[i + 1].index]) |glyph| {
				if (glyph.character != '\n') {
					const ftGlyph = TextRendering.getGlyph(glyph.index) catch continue;
					var fontEffect = glyph.fontEffect;
					fontEffect.color = shadowColor(fontEffect.color);
					TextRendering.drawGlyph(ftGlyph, x + glyph.x_offset, y - glyph.y_offset, @bitCast(fontEffect));
				}
				x += glyph.x_advance;
				y -= glyph.y_advance;
			}
			lineWraps[i] = x - self.getLineOffset(i);
			x = 0;
			y += 16;
		}

		for (self.lines.items) |_line| {
			var line: Line = _line;
			y = 0;
			y += if (line.isUnderline) 15 else 8;
			const oldColor = draw.color;
			draw.setColor(shadowColor(line.color) | (@as(u32, 0xff000000) & draw.color));
			defer draw.setColor(oldColor);
			for (lineWraps, 0..) |lineWrap, j| {
				const lineStart = @max(0, line.start);
				const lineEnd = @min(lineWrap, line.end);
				if (lineStart < lineEnd) {
					const start = Vec2f{lineStart + self.getLineOffset(j), y};
					const dim = Vec2f{lineEnd - lineStart, 1};
					draw.rect(start, dim);
				}
				line.start -= lineWrap;
				line.end -= lineWrap;
				y += 16;
			}
		}
	}
};

const TextRendering = struct { // MARK: TextRendering
	const Glyph = struct {
		textureX: i32,
		size: Vec2i,
		bearing: Vec2i,
		advance: f32,
	};
	var pipeline: Pipeline = undefined;
	var uniforms: struct {
		texture_rect: c_int,
		scene: c_int,
		offset: c_int,
		ratio: c_int,
		fontEffects: c_int,
		fontSize: c_int,
		alpha: c_int,
	} = undefined;

	var freetypeLib: hbft.FT_Library = undefined;
	var freetypeFace: hbft.FT_Face = undefined;
	var harfbuzzFace: ?*hbft.hb_face_t = undefined;
	var harfbuzzFont: ?*hbft.hb_font_t = undefined;
	var glyphMapping: main.List(u31) = undefined;
	var glyphData: main.List(Glyph) = undefined;
	var glyphTexture: [2]c_uint = undefined;
	var textureWidth: i32 = 1024;
	const textureHeight: i32 = 16;
	var textureOffset: i32 = 0;
	var fontUnitsPerPixel: f32 = undefined;

	fn ftError(errorCode: hbft.FT_Error) !void {
		if (errorCode == 0) return;
		const errorString = hbft.FT_Error_String(errorCode);
		std.log.err("Got freetype error {s}", .{errorString});
		return error.freetype;
	}

	fn init() !void {
		pipeline = Pipeline.init(
			"assets/cubyz/shaders/graphics/Text.vert",
			"assets/cubyz/shaders/graphics/Text.frag",
			"",
			&uniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.alphaBlending}},
		);
		pipeline.bind(null);
		errdefer pipeline.deinit();
		c.glUniform1f(uniforms.alpha, 1.0);
		c.glUniform2f(uniforms.fontSize, @floatFromInt(textureWidth), @floatFromInt(textureHeight));
		try ftError(hbft.FT_Init_FreeType(&freetypeLib));
		try ftError(hbft.FT_New_Face(freetypeLib, "assets/cubyz/fonts/unscii-16-full.ttf", 0, &freetypeFace));
		try ftError(hbft.FT_Set_Pixel_Sizes(freetypeFace, 0, textureHeight));
		harfbuzzFace = hbft.hb_ft_face_create_referenced(freetypeFace);
		harfbuzzFont = hbft.hb_font_create(harfbuzzFace);
		fontUnitsPerPixel = @as(f32, @floatFromInt(freetypeFace.*.units_per_EM))/@as(f32, @floatFromInt(textureHeight));

		glyphMapping = .init(main.globalAllocator);
		glyphData = .init(main.globalAllocator);
		glyphData.append(undefined); // 0 is a reserved value.
		c.glGenTextures(2, &glyphTexture);
		c.glBindTexture(c.GL_TEXTURE_2D, glyphTexture[0]);
		c.glTexImage2D(c.GL_TEXTURE_2D, 0, c.GL_R8, textureWidth, textureHeight, 0, c.GL_RED, c.GL_UNSIGNED_BYTE, null);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, c.GL_REPEAT);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, c.GL_REPEAT);
		c.glBindTexture(c.GL_TEXTURE_2D, glyphTexture[1]);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, c.GL_REPEAT);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, c.GL_REPEAT);
	}

	fn deinit() void {
		pipeline.deinit();
		ftError(hbft.FT_Done_FreeType(freetypeLib)) catch {};
		glyphMapping.deinit();
		glyphData.deinit();
		c.glDeleteTextures(2, &glyphTexture);
		hbft.hb_font_destroy(harfbuzzFont);
	}

	fn resizeTexture(newWidth: i32) void {
		textureWidth = newWidth;
		const swap = glyphTexture[1];
		glyphTexture[1] = glyphTexture[0];
		glyphTexture[0] = swap;
		c.glActiveTexture(c.GL_TEXTURE0);
		c.glBindTexture(c.GL_TEXTURE_2D, glyphTexture[0]);
		c.glTexImage2D(c.GL_TEXTURE_2D, 0, c.GL_R8, newWidth, textureHeight, 0, c.GL_RED, c.GL_UNSIGNED_BYTE, null);
		c.glCopyImageSubData(glyphTexture[1], c.GL_TEXTURE_2D, 0, 0, 0, 0, glyphTexture[0], c.GL_TEXTURE_2D, 0, 0, 0, 0, textureOffset, textureHeight, 1);
		pipeline.bind(draw.getScissor());
		c.glUniform2f(uniforms.fontSize, @floatFromInt(textureWidth), @floatFromInt(textureHeight));
	}

	fn uploadData(bitmap: hbft.FT_Bitmap) void {
		const width: i32 = @bitCast(bitmap.width);
		const height: i32 = @bitCast(bitmap.rows);
		const buffer = bitmap.buffer orelse return;
		if (textureOffset + width > textureWidth) {
			resizeTexture(textureWidth*2);
		}
		c.glPixelStorei(c.GL_UNPACK_ALIGNMENT, 1);
		c.glTexSubImage2D(c.GL_TEXTURE_2D, 0, textureOffset, 0, width, height, c.GL_RED, c.GL_UNSIGNED_BYTE, buffer);
		textureOffset += width;
	}

	fn getGlyph(index: u32) !Glyph {
		if (index >= glyphMapping.items.len) {
			glyphMapping.appendNTimes(0, index - glyphMapping.items.len + 1);
		}
		if (glyphMapping.items[index] == 0) { // glyph was not initialized yet.
			try ftError(hbft.FT_Load_Glyph(freetypeFace, index, hbft.FT_LOAD_RENDER));
			const glyph = freetypeFace.*.glyph;
			const bitmap = glyph.*.bitmap;
			const width = bitmap.width;
			const height = bitmap.rows;
			glyphMapping.items[index] = @intCast(glyphData.items.len);
			glyphData.addOne().* = Glyph{
				.textureX = textureOffset,
				.size = Vec2i{@intCast(width), @intCast(height)},
				.bearing = Vec2i{glyph.*.bitmap_left, 16 - glyph.*.bitmap_top},
				.advance = @as(f32, @floatFromInt(glyph.*.advance.x))/@as(f32, 1 << 6),
			};
			uploadData(bitmap);
		}
		return glyphData.items[glyphMapping.items[index]];
	}

	fn drawGlyph(glyph: Glyph, _x: f32, _y: f32, fontEffects: u28) void {
		var x = _x;
		var y = _y;
		x *= draw.scale;
		y *= draw.scale;
		x += draw.translation[0];
		y += draw.translation[1];
		x = @floor(x);
		y = @ceil(y);
		c.glUniform1i(uniforms.fontEffects, fontEffects);
		if (fontEffects & 0x1000000 != 0) { // bold
			c.glUniform2f(uniforms.offset, @as(f32, @floatFromInt(glyph.bearing[0]))*draw.scale + x, @as(f32, @floatFromInt(glyph.bearing[1]))*draw.scale + y - 1);
			c.glUniform4f(uniforms.texture_rect, @floatFromInt(glyph.textureX), -1, @floatFromInt(glyph.size[0]), @floatFromInt(glyph.size[1] + 1));
			c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
			// Just draw another thing on top in x direction. The y-direction is handled in the shader.
			c.glUniform2f(uniforms.offset, @as(f32, @floatFromInt(glyph.bearing[0]))*draw.scale + x + 0.5, @as(f32, @floatFromInt(glyph.bearing[1]))*draw.scale + y - 1);
			c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
		} else {
			c.glUniform2f(uniforms.offset, @as(f32, @floatFromInt(glyph.bearing[0]))*draw.scale + x, @as(f32, @floatFromInt(glyph.bearing[1]))*draw.scale + y);
			c.glUniform4f(uniforms.texture_rect, @floatFromInt(glyph.textureX), 0, @floatFromInt(glyph.size[0]), @floatFromInt(glyph.size[1]));
			c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
		}
	}

	fn renderText(text: []const u8, x: f32, y: f32, fontSize: f32, initialFontEffect: TextBuffer.FontEffect, alignment: TextBuffer.Alignment) void {
		const buf = TextBuffer.init(main.stackAllocator, text, initialFontEffect, false, alignment);
		defer buf.deinit();

		buf.render(x, y, fontSize);
	}
};

pub fn init() void { // MARK: init()
	draw.initCircle();
	draw.initDrawRect();
	draw.initImage();
	draw.initLine();
	draw.initRect();
	draw.initRectBorder();
	TextRendering.init() catch |err| {
		std.log.err("Error while initializing TextRendering: {s}", .{@errorName(err)});
	};
	block_texture.init();
	if (glslang.glslang_initialize_process() == glslang.false) std.log.err("glslang_initialize_process failed", .{});
}

pub fn deinit() void {
	draw.deinitCircle();
	draw.deinitDrawRect();
	draw.deinitImage();
	draw.deinitLine();
	draw.deinitRect();
	draw.deinitRectBorder();
	TextRendering.deinit();
	block_texture.deinit();
	glslang.glslang_finalize_process();
}

const Shader = struct { // MARK: Shader
	id: c_uint,

	fn compileToSpirV(allocator: NeverFailingAllocator, source: []const u8, filename: []const u8, defines: []const u8, shaderStage: glslang.glslang_stage_t) ![]c_uint {
		const versionLineEnd = if (std.mem.indexOfScalar(u8, source, '\n')) |len| len + 1 else 0;
		const versionLine = source[0..versionLineEnd];
		const sourceLines = source[versionLineEnd..];

		var sourceWithDefines = main.List(u8).init(main.stackAllocator);
		defer sourceWithDefines.deinit();
		sourceWithDefines.appendSlice(versionLine);
		sourceWithDefines.appendSlice(defines);
		sourceWithDefines.appendSlice(sourceLines);
		sourceWithDefines.append(0);

		const input = glslang.glslang_input_t{
			.language = glslang.GLSLANG_SOURCE_GLSL,
			.stage = shaderStage,
			.client = glslang.GLSLANG_CLIENT_OPENGL,
			.client_version = glslang.GLSLANG_TARGET_OPENGL_450,
			.target_language = glslang.GLSLANG_TARGET_SPV,
			.target_language_version = glslang.GLSLANG_TARGET_SPV_1_0,
			.code = sourceWithDefines.items.ptr,
			.default_version = 100,
			.default_profile = glslang.GLSLANG_NO_PROFILE,
			.force_default_version_and_profile = glslang.false,
			.forward_compatible = glslang.false,
			.messages = glslang.GLSLANG_MSG_DEFAULT_BIT,
			.resource = glslang.glslang_default_resource(),
			.callbacks = .{}, // TODO: Add support for shader includes
			.callbacks_ctx = null,
		};
		const shader = glslang.glslang_shader_create(&input);
		defer glslang.glslang_shader_delete(shader);
		if (glslang.glslang_shader_preprocess(shader, &input) == 0) {
			std.log.err("Error preprocessing shader {s}:\n{s}\n{s}\n", .{filename, glslang.glslang_shader_get_info_log(shader), glslang.glslang_shader_get_info_debug_log(shader)});
			return error.FailedCompiling;
		}

		if (glslang.glslang_shader_parse(shader, &input) == 0) {
			std.log.err("Error parsing shader {s}:\n{s}\n{s}\n", .{filename, glslang.glslang_shader_get_info_log(shader), glslang.glslang_shader_get_info_debug_log(shader)});
			return error.FailedCompiling;
		}

		const program = glslang.glslang_program_create();
		defer glslang.glslang_program_delete(program);
		glslang.glslang_program_add_shader(program, shader);

		if (glslang.glslang_program_link(program, glslang.GLSLANG_MSG_SPV_RULES_BIT | glslang.GLSLANG_MSG_VULKAN_RULES_BIT) == 0) {
			std.log.err("Error linking shader {s}:\n{s}\n{s}\n", .{filename, glslang.glslang_shader_get_info_log(shader), glslang.glslang_shader_get_info_debug_log(shader)});
			return error.FailedCompiling;
		}

		glslang.glslang_program_SPIRV_generate(program, shaderStage);
		const result = allocator.alloc(c_uint, glslang.glslang_program_SPIRV_get_size(program));
		glslang.glslang_program_SPIRV_get(program, result.ptr);
		return result;
	}

	fn addShader(self: *const Shader, filename: []const u8, defines: []const u8, shaderStage: c_uint) !void {
		const source = main.files.cwd().read(main.stackAllocator, filename) catch |err| {
			std.log.err("Couldn't read shader file: {s}", .{filename});
			return err;
		};
		defer main.stackAllocator.free(source);

		// SPIR-V will be used for the Vulkan, now it's completely useless due to lack of support in Vulkan drivers
		const glslangStage: glslang.glslang_stage_t = if (shaderStage == c.GL_VERTEX_SHADER) glslang.GLSLANG_STAGE_VERTEX else if (shaderStage == c.GL_FRAGMENT_SHADER) glslang.GLSLANG_STAGE_FRAGMENT else glslang.GLSLANG_STAGE_COMPUTE;
		main.stackAllocator.free(try compileToSpirV(main.stackAllocator, source, filename, defines, glslangStage));

		const shader = c.glCreateShader(shaderStage);
		defer c.glDeleteShader(shader);

		const versionLineEnd = if (std.mem.indexOfScalar(u8, source, '\n')) |len| len + 1 else 0;
		const versionLine = source[0..versionLineEnd];
		const sourceLines = source[versionLineEnd..];

		const sourceLen: [3]c_int = .{@intCast(versionLine.len), @intCast(defines.len), @intCast(sourceLines.len)};
		c.glShaderSource(shader, 3, &[3][*c]const u8{versionLine.ptr, defines.ptr, sourceLines.ptr}, &sourceLen);

		c.glCompileShader(shader);

		var success: c_int = undefined;
		c.glGetShaderiv(shader, c.GL_COMPILE_STATUS, &success);
		if (success != c.GL_TRUE) {
			var len: u32 = undefined;
			c.glGetShaderiv(shader, c.GL_INFO_LOG_LENGTH, @ptrCast(&len));
			var buf: [4096]u8 = undefined;
			c.glGetShaderInfoLog(shader, 4096, @ptrCast(&len), &buf);
			std.log.err("Error compiling shader {s}:\n{s}\n", .{filename, buf[0..len]});
			return error.FailedCompiling;
		}

		c.glAttachShader(self.id, shader);
	}

	fn link(self: *const Shader, file: []const u8) !void {
		c.glLinkProgram(self.id);

		var success: c_int = undefined;
		c.glGetProgramiv(self.id, c.GL_LINK_STATUS, &success);
		if (success != c.GL_TRUE) {
			var len: u32 = undefined;
			c.glGetProgramiv(self.id, c.GL_INFO_LOG_LENGTH, @ptrCast(&len));
			var buf: [4096]u8 = undefined;
			c.glGetProgramInfoLog(self.id, 4096, @ptrCast(&len), &buf);
			std.log.err("Error Linking Shader program {s}:\n{s}\n", .{file, buf[0..len]});
			return error.FailedLinking;
		}
	}

	fn init(vertex: []const u8, fragment: []const u8, defines: []const u8, uniformStruct: anytype) Shader {
		const shader = Shader{.id = c.glCreateProgram()};
		shader.addShader(vertex, defines, c.GL_VERTEX_SHADER) catch return shader;
		shader.addShader(fragment, defines, c.GL_FRAGMENT_SHADER) catch return shader;
		shader.link(fragment) catch return shader;

		if (@TypeOf(uniformStruct) != @TypeOf(null)) {
			inline for (@typeInfo(@TypeOf(uniformStruct.*)).@"struct".fields) |field| {
				if (field.type == c_int) {
					@field(uniformStruct, field.name) = c.glGetUniformLocation(shader.id, field.name[0..]);
				}
			}
		}
		return shader;
	}

	fn initCompute(compute: []const u8, defines: []const u8, uniformStruct: anytype) Shader {
		const shader = Shader{.id = c.glCreateProgram()};
		shader.addShader(compute, defines, c.GL_COMPUTE_SHADER) catch return shader;
		shader.link(compute) catch return shader;

		if (@TypeOf(uniformStruct) != @TypeOf(null)) {
			inline for (@typeInfo(@TypeOf(uniformStruct.*)).@"struct".fields) |field| {
				if (field.type == c_int) {
					@field(uniformStruct, field.name) = c.glGetUniformLocation(shader.id, field.name[0..]);
				}
			}
		}
		return shader;
	}

	fn bind(self: *const Shader) void {
		c.glUseProgram(self.id);
	}

	fn deinit(self: *const Shader) void {
		c.glDeleteProgram(self.id);
	}
};

pub const Pipeline = struct { // MARK: Pipeline
	shader: Shader,
	rasterState: RasterizationState,
	multisampleState: MultisampleState = .{}, // TODO: Not implemented
	depthStencilState: DepthStencilState,
	blendState: ColorBlendState,

	const RasterizationState = struct {
		depthClamp: bool = true,
		rasterizerDiscard: bool = false,
		polygonMode: PolygonMode = .fill,
		cullMode: CullModeFlags = .back,
		frontFace: FrontFace = .counterClockwise,
		depthBias: ?DepthBias = null,
		lineWidth: f32 = 1,

		const PolygonMode = enum(c.VkPolygonMode) {
			fill = c.VK_POLYGON_MODE_FILL,
			line = c.VK_POLYGON_MODE_LINE,
			point = c.VK_POLYGON_MODE_POINT,
		};

		const CullModeFlags = enum(c.VkCullModeFlags) {
			none = c.VK_CULL_MODE_NONE,
			front = c.VK_CULL_MODE_FRONT_BIT,
			back = c.VK_CULL_MODE_BACK_BIT,
			frontAndBack = c.VK_CULL_MODE_FRONT_AND_BACK,
		};

		const FrontFace = enum(c.VkFrontFace) {
			counterClockwise = c.VK_FRONT_FACE_COUNTER_CLOCKWISE,
			clockwise = c.VK_FRONT_FACE_CLOCKWISE,
		};

		const DepthBias = struct {
			constantFactor: f32,
			clamp: f32,
			slopeFactor: f32,
		};
	};

	const MultisampleState = struct {
		rasterizationSamples: Count = .@"1",
		sampleShading: bool = false,
		minSampleShading: f32 = undefined,
		sampleMask: [*]const c.VkSampleMask = &.{0, 0},
		alphaToCoverage: bool = false,
		alphaToOne: bool = false,

		const Count = enum(c.VkSampleCountFlags) {
			@"1" = c.VK_SAMPLE_COUNT_1_BIT,
			@"2" = c.VK_SAMPLE_COUNT_2_BIT,
			@"4" = c.VK_SAMPLE_COUNT_4_BIT,
			@"8" = c.VK_SAMPLE_COUNT_8_BIT,
			@"16" = c.VK_SAMPLE_COUNT_16_BIT,
			@"32" = c.VK_SAMPLE_COUNT_32_BIT,
			@"64" = c.VK_SAMPLE_COUNT_64_BIT,
		};
	};

	const DepthStencilState = struct {
		depthTest: bool,
		depthWrite: bool = true,
		depthCompare: CompareOp = .less,
		depthBoundsTest: ?DepthBoundsTest = null,
		stencilTest: ?StencilTest = null,

		const CompareOp = enum(c.VkCompareOp) {
			never = c.VK_COMPARE_OP_NEVER,
			less = c.VK_COMPARE_OP_LESS,
			equal = c.VK_COMPARE_OP_EQUAL,
			lessOrEqual = c.VK_COMPARE_OP_LESS_OR_EQUAL,
			greater = c.VK_COMPARE_OP_GREATER,
			notEqual = c.VK_COMPARE_OP_NOT_EQUAL,
			greateOrEqual = c.VK_COMPARE_OP_GREATER_OR_EQUAL,
			always = c.VK_COMPARE_OP_ALWAYS,
		};

		const StencilTest = struct {
			front: StencilOpState,
			back: StencilOpState,

			const StencilOpState = struct {
				failOp: StencilOp,
				passOp: StencilOp,
				depthFailOp: StencilOp,
				compareOp: CompareOp,
				compareMask: u32,
				writeMask: u32,
				reference: u32,

				const StencilOp = enum(c.VkStencilOp) {
					keep = c.VK_STENCIL_OP_KEEP,
					zero = c.VK_STENCIL_OP_ZERO,
					replace = c.VK_STENCIL_OP_REPLACE,
					incrementAndClamp = c.VK_STENCIL_OP_INCREMENT_AND_CLAMP,
					decrementAndClamp = c.VK_STENCIL_OP_DECREMENT_AND_CLAMP,
					invert = c.VK_STENCIL_OP_INVERT,
					incrementAndWrap = c.VK_STENCIL_OP_INCREMENT_AND_WRAP,
					decrementAndWrap = c.VK_STENCIL_OP_DECREMENT_AND_WRAP,
				};
			};
		};

		const DepthBoundsTest = struct {
			min: f32,
			max: f32,
		};
	};

	const ColorBlendAttachmentState = struct {
		enabled: bool = true,
		srcColorBlendFactor: BlendFactor,
		dstColorBlendFactor: BlendFactor,
		colorBlendOp: BlendOp,
		srcAlphaBlendFactor: BlendFactor,
		dstAlphaBlendFactor: BlendFactor,
		alphaBlendOp: BlendOp,
		colorWriteMask: ColorComponentFlags = .all,

		pub const alphaBlending: ColorBlendAttachmentState = .{
			.srcColorBlendFactor = .srcAlpha,
			.dstColorBlendFactor = .oneMinusSrcAlpha,
			.colorBlendOp = .add,
			.srcAlphaBlendFactor = .srcAlpha,
			.dstAlphaBlendFactor = .oneMinusSrcAlpha,
			.alphaBlendOp = .add,
		};
		pub const noBlending: ColorBlendAttachmentState = .{
			.enabled = false,
			.srcColorBlendFactor = undefined,
			.dstColorBlendFactor = undefined,
			.colorBlendOp = undefined,
			.srcAlphaBlendFactor = undefined,
			.dstAlphaBlendFactor = undefined,
			.alphaBlendOp = undefined,
		};

		const BlendFactor = enum(c.VkBlendFactor) {
			zero = c.VK_BLEND_FACTOR_ZERO,
			one = c.VK_BLEND_FACTOR_ONE,
			srcColor = c.VK_BLEND_FACTOR_SRC_COLOR,
			oneMinusSrcColor = c.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
			dstColor = c.VK_BLEND_FACTOR_DST_COLOR,
			oneMinusDstColor = c.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
			srcAlpha = c.VK_BLEND_FACTOR_SRC_ALPHA,
			oneMinusSrcAlpha = c.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
			dstAlpha = c.VK_BLEND_FACTOR_DST_ALPHA,
			oneMinusDstAlpha = c.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
			constantColor = c.VK_BLEND_FACTOR_CONSTANT_COLOR,
			oneMinusConstantColor = c.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
			constantAlpha = c.VK_BLEND_FACTOR_CONSTANT_ALPHA,
			oneMinusConstantAlpha = c.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
			srcAlphaSaturate = c.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
			src1Color = c.VK_BLEND_FACTOR_SRC1_COLOR,
			oneMinusSrc1Color = c.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
			src1Alpha = c.VK_BLEND_FACTOR_SRC1_ALPHA,
			oneMinusSrc1Alpha = c.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,

			fn toGl(self: BlendFactor) c.GLenum {
				return switch (self) {
					.zero => c.GL_ZERO,
					.one => c.GL_ONE,
					.srcColor => c.GL_SRC_COLOR,
					.oneMinusSrcColor => c.GL_ONE_MINUS_SRC_COLOR,
					.dstColor => c.GL_DST_COLOR,
					.oneMinusDstColor => c.GL_ONE_MINUS_DST_COLOR,
					.srcAlpha => c.GL_SRC_ALPHA,
					.oneMinusSrcAlpha => c.GL_ONE_MINUS_SRC_ALPHA,
					.dstAlpha => c.GL_DST_ALPHA,
					.oneMinusDstAlpha => c.GL_ONE_MINUS_DST_ALPHA,
					.constantColor => c.GL_CONSTANT_COLOR,
					.oneMinusConstantColor => c.GL_ONE_MINUS_CONSTANT_COLOR,
					.constantAlpha => c.GL_CONSTANT_ALPHA,
					.oneMinusConstantAlpha => c.GL_ONE_MINUS_CONSTANT_ALPHA,
					.srcAlphaSaturate => c.GL_SRC_ALPHA_SATURATE,
					.src1Color => c.GL_SRC1_COLOR,
					.oneMinusSrc1Color => c.GL_ONE_MINUS_SRC1_COLOR,
					.src1Alpha => c.GL_SRC1_ALPHA,
					.oneMinusSrc1Alpha => c.GL_ONE_MINUS_SRC1_ALPHA,
				};
			}
		};

		const BlendOp = enum(c.VkBlendOp) {
			add = c.VK_BLEND_OP_ADD,
			subtract = c.VK_BLEND_OP_SUBTRACT,
			reverseSubtract = c.VK_BLEND_OP_REVERSE_SUBTRACT,
			min = c.VK_BLEND_OP_MIN,
			max = c.VK_BLEND_OP_MAX,

			fn toGl(self: BlendOp) c.GLenum {
				return switch (self) {
					.add => c.GL_FUNC_ADD,
					.subtract => c.GL_FUNC_SUBTRACT,
					.reverseSubtract => c.GL_FUNC_REVERSE_SUBTRACT,
					.min => c.GL_MIN,
					.max => c.GL_MAX,
				};
			}
		};

		const ColorComponentFlags = packed struct {
			r: bool,
			g: bool,
			b: bool,
			a: bool,
			pub const all: ColorComponentFlags = .{.r = true, .g = true, .b = true, .a = true};
			pub const none: ColorComponentFlags = .{.r = false, .g = false, .b = false, .a = false};
		};
	};

	const ColorBlendState = struct {
		logicOp: ?LogicOp = null,
		attachments: []const ColorBlendAttachmentState,
		blendConstants: [4]f32 = .{0, 0, 0, 0},

		const LogicOp = enum(c.VkLogicOp) {
			clear = c.VK_LOGIC_OP_CLEAR,
			@"and" = c.VK_LOGIC_OP_AND,
			andReverse = c.VK_LOGIC_OP_AND_REVERSE,
			copy = c.VK_LOGIC_OP_COPY,
			andInverted = c.VK_LOGIC_OP_AND_INVERTED,
			noOp = c.VK_LOGIC_OP_NO_OP,
			xor = c.VK_LOGIC_OP_XOR,
			@"or" = c.VK_LOGIC_OP_OR,
			nor = c.VK_LOGIC_OP_NOR,
			equivalent = c.VK_LOGIC_OP_EQUIVALENT,
			invert = c.VK_LOGIC_OP_INVERT,
			orReverse = c.VK_LOGIC_OP_OR_REVERSE,
			copyInverted = c.VK_LOGIC_OP_COPY_INVERTED,
			orInverted = c.VK_LOGIC_OP_OR_INVERTED,
			nand = c.VK_LOGIC_OP_NAND,
			set = c.VK_LOGIC_OP_SET,
		};
	};

	pub fn init(vertexPath: []const u8, fragmentPath: []const u8, defines: []const u8, uniformStruct: anytype, rasterState: RasterizationState, depthStencilState: DepthStencilState, blendState: ColorBlendState) Pipeline {
		std.debug.assert(depthStencilState.depthBoundsTest == null); // Only available in Vulkan 1.3
		std.debug.assert(depthStencilState.stencilTest == null); // TODO: Not yet implemented
		std.debug.assert(rasterState.lineWidth <= 1); // Larger values are poorly supported among drivers
		std.debug.assert(blendState.logicOp == null); // TODO: Not yet implemented
		return .{
			.shader = .init(vertexPath, fragmentPath, defines, uniformStruct),
			.rasterState = rasterState,
			.multisampleState = .{}, // TODO: Not implemented
			.depthStencilState = depthStencilState,
			.blendState = blendState,
		};
	}

	pub fn deinit(self: Pipeline) void {
		self.shader.deinit();
	}

	fn conditionalEnable(typ: c.GLenum, val: bool) void {
		if (val) {
			c.glEnable(typ);
		} else {
			c.glDisable(typ);
		}
	}

	pub fn bind(self: Pipeline, scissor: ?c.VkRect2D) void {
		self.shader.bind();
		if (scissor) |s| {
			c.glEnable(c.GL_SCISSOR_TEST);
			c.glScissor(s.offset.x, s.offset.y, @intCast(s.extent.width), @intCast(s.extent.height));
		} else {
			c.glDisable(c.GL_SCISSOR_TEST);
		}

		conditionalEnable(c.GL_DEPTH_CLAMP, self.rasterState.depthClamp);
		conditionalEnable(c.GL_RASTERIZER_DISCARD, self.rasterState.rasterizerDiscard);
		conditionalEnable(c.GL_RASTERIZER_DISCARD, self.rasterState.rasterizerDiscard);
		c.glPolygonMode(c.GL_FRONT_AND_BACK, switch (self.rasterState.polygonMode) {
			.fill => c.GL_FILL,
			.line => c.GL_LINE,
			.point => c.GL_POINT,
		});
		if (self.rasterState.cullMode != .none) {
			c.glEnable(c.GL_CULL_FACE);
			c.glCullFace(switch (self.rasterState.cullMode) {
				.front => c.GL_FRONT,
				.back => c.GL_BACK,
				.frontAndBack => c.GL_FRONT_AND_BACK,
				else => unreachable,
			});
		} else {
			c.glDisable(c.GL_CULL_FACE);
		}
		c.glFrontFace(switch (self.rasterState.frontFace) {
			.counterClockwise => c.GL_CCW,
			.clockwise => c.GL_CW,
		});
		if (self.rasterState.depthBias) |depthBias| {
			c.glEnable(c.GL_POLYGON_OFFSET_FILL);
			c.glEnable(c.GL_POLYGON_OFFSET_LINE);
			c.glEnable(c.GL_POLYGON_OFFSET_POINT);
			c.glPolygonOffset(depthBias.slopeFactor, depthBias.constantFactor);
		} else {
			c.glDisable(c.GL_POLYGON_OFFSET_FILL);
			c.glDisable(c.GL_POLYGON_OFFSET_LINE);
			c.glDisable(c.GL_POLYGON_OFFSET_POINT);
		}
		c.glLineWidth(self.rasterState.lineWidth);

		// TODO: Multisampling

		conditionalEnable(c.GL_DEPTH_TEST, self.depthStencilState.depthTest);
		c.glDepthMask(@intFromBool(self.depthStencilState.depthWrite));
		c.glDepthFunc(switch (self.depthStencilState.depthCompare) {
			.never => c.GL_NEVER,
			.less => c.GL_LESS,
			.equal => c.GL_EQUAL,
			.lessOrEqual => c.GL_LEQUAL,
			.greater => c.GL_GREATER,
			.notEqual => c.GL_NOTEQUAL,
			.greateOrEqual => c.GL_GEQUAL,
			.always => c.GL_ALWAYS,
		});
		// TODO: stencilTest

		// TODO: logicOp
		for (self.blendState.attachments, 0..) |attachment, i| {
			c.glColorMask(@intFromBool(attachment.colorWriteMask.r), @intFromBool(attachment.colorWriteMask.g), @intFromBool(attachment.colorWriteMask.b), @intFromBool(attachment.colorWriteMask.a));
			if (!attachment.enabled) {
				c.glDisable(c.GL_BLEND);
				continue;
			}
			c.glEnable(c.GL_BLEND);
			c.glBlendEquationSeparatei(@intCast(i), attachment.colorBlendOp.toGl(), attachment.alphaBlendOp.toGl());
			c.glBlendFuncSeparatei(@intCast(i), attachment.srcColorBlendFactor.toGl(), attachment.dstColorBlendFactor.toGl(), attachment.srcAlphaBlendFactor.toGl(), attachment.dstAlphaBlendFactor.toGl());
		}
		c.glBlendColor(self.blendState.blendConstants[0], self.blendState.blendConstants[1], self.blendState.blendConstants[2], self.blendState.blendConstants[3]);
	}
};

pub const ComputePipeline = struct { // MARK: ComputePipeline
	shader: Shader,

	pub fn init(computePath: []const u8, defines: []const u8, uniformStruct: anytype) ComputePipeline {
		return .{
			.shader = .initCompute(computePath, defines, uniformStruct),
		};
	}

	pub fn deinit(self: ComputePipeline) void {
		self.shader.deinit();
	}

	pub fn bind(self: ComputePipeline) void {
		self.shader.bind();
	}
};

pub const SSBO = struct { // MARK: SSBO
	bufferID: c_uint,
	pub fn init() SSBO {
		var self = SSBO{.bufferID = undefined};
		c.glGenBuffers(1, &self.bufferID);
		return self;
	}

	pub fn initStatic(comptime T: type, data: []const T) SSBO {
		var self = SSBO{.bufferID = undefined};
		c.glGenBuffers(1, &self.bufferID);
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.bufferID);
		c.glBufferStorage(c.GL_SHADER_STORAGE_BUFFER, @intCast(data.len*@sizeOf(T)), data.ptr, 0);
		return self;
	}

	pub fn initStaticSize(comptime T: type, len: usize) SSBO {
		var self = SSBO{.bufferID = undefined};
		c.glGenBuffers(1, &self.bufferID);
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.bufferID);
		c.glBufferStorage(c.GL_SHADER_STORAGE_BUFFER, @intCast(len*@sizeOf(T)), null, 0);
		return self;
	}

	pub fn deinit(self: SSBO) void {
		c.glDeleteBuffers(1, &self.bufferID);
	}

	pub fn bind(self: SSBO, binding: c_uint) void {
		c.glBindBufferBase(c.GL_SHADER_STORAGE_BUFFER, binding, self.bufferID);
	}

	pub fn bufferData(self: SSBO, comptime T: type, data: []const T) void {
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.bufferID);
		c.glBufferData(c.GL_SHADER_STORAGE_BUFFER, @intCast(data.len*@sizeOf(T)), data.ptr, c.GL_STATIC_DRAW);
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, 0);
	}

	pub fn bufferSubData(self: SSBO, comptime T: type, data: []const T, length: usize) void {
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.bufferID);
		c.glBufferSubData(c.GL_SHADER_STORAGE_BUFFER, 0, @intCast(length*@sizeOf(T)), data.ptr);
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, 0);
	}

	pub fn createDynamicBuffer(self: SSBO, comptime T: type, size: usize) void {
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.bufferID);
		c.glBufferData(c.GL_SHADER_STORAGE_BUFFER, @intCast(size*@sizeOf(T)), null, c.GL_DYNAMIC_DRAW);
		c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, 0);
	}
};

pub const SubAllocation = struct {
	start: u31,
	len: u31,
};

/// A big SSBO that is able to allocate/free smaller regions.
pub fn LargeBuffer(comptime Entry: type) type { // MARK: LargerBuffer
	return struct {
		ssbo: SSBO,
		freeBlocks: main.List(SubAllocation),
		fences: [3]c.GLsync,
		fencedFreeLists: [3]main.List(SubAllocation),
		activeFence: u8,
		capacity: u31,
		used: u31,
		binding: c_uint,

		const Self = @This();

		fn createBuffer(self: *Self, size: u31) void {
			self.ssbo = .init();
			c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.ssbo.bufferID);
			const flags = c.GL_MAP_WRITE_BIT | c.GL_DYNAMIC_STORAGE_BIT;
			const bytes = @as(c.GLsizeiptr, size)*@sizeOf(Entry);
			c.glBufferStorage(c.GL_SHADER_STORAGE_BUFFER, bytes, null, flags);
			self.ssbo.bind(self.binding);
			self.capacity = size;
		}

		pub fn init(self: *Self, allocator: NeverFailingAllocator, size: u31, binding: c_uint) void {
			self.used = 0;
			self.binding = binding;
			self.createBuffer(size);
			self.activeFence = 0;
			for (&self.fences) |*fence| {
				fence.* = c.glFenceSync(c.GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
			}
			for (&self.fencedFreeLists) |*list| {
				list.* = .init(allocator);
			}

			self.freeBlocks = .init(allocator);
			self.freeBlocks.append(.{.start = 0, .len = size});
		}

		pub fn deinit(self: *Self) void {
			for (self.fences) |fence| {
				c.glDeleteSync(fence);
			}
			for (self.fencedFreeLists) |list| {
				list.deinit();
			}
			self.ssbo.deinit();
			self.freeBlocks.deinit();
		}

		pub fn beginRender(self: *Self) void {
			self.activeFence += 1;
			if (self.activeFence == self.fences.len) self.activeFence = 0;
			const endTime = main.timestamp().addDuration(.fromMilliseconds(5));
			while (self.fencedFreeLists[self.activeFence].popOrNull()) |allocation| {
				self.finalFree(allocation);
				if (main.timestamp().durationTo(endTime).nanoseconds < 0) break; // TODO: Remove after #1434
			}
			_ = c.glClientWaitSync(self.fences[self.activeFence], 0, c.GL_TIMEOUT_IGNORED); // Make sure the render calls that accessed these parts of the buffer have finished.
		}

		pub fn endRender(self: *Self) void {
			c.glDeleteSync(self.fences[self.activeFence]);
			self.fences[self.activeFence] = c.glFenceSync(c.GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
		}

		pub fn rawAlloc(self: *Self, size: u31) SubAllocation {
			var smallestBlock: ?*SubAllocation = null;
			for (self.freeBlocks.items, 0..) |*block, i| {
				if (size == block.len) {
					self.used += size;
					return self.freeBlocks.swapRemove(i);
				}
				if (size < block.len and if (smallestBlock) |_smallestBlock| block.len < _smallestBlock.len else true) {
					smallestBlock = block;
				}
			}
			if (smallestBlock) |block| {
				const result = SubAllocation{.start = block.start, .len = size};
				block.start += size;
				block.len -= size;
				self.used += size;
				return result;
			} else {
				std.log.info("Resizing internal mesh buffer from {} MiB to {} MiB", .{@as(usize, self.capacity)*@sizeOf(Entry) >> 20, (@as(usize, self.capacity)*@sizeOf(Entry) >> 20)*2});
				if (@as(usize, self.capacity)*@sizeOf(Entry)*2 > 1 << 31) @panic("OpenGL 2 GiB buffer size limit reached. Please lower your render distance.");
				const oldBuffer = self.ssbo;
				defer oldBuffer.deinit();
				const oldCapacity = self.capacity;
				self.createBuffer(self.capacity*|2); // TODO: Is there a way to free the old buffer before creating the new one?
				self.used += self.capacity - oldCapacity;
				self.finalFree(.{.start = oldCapacity, .len = self.capacity - oldCapacity});

				c.glBindBuffer(c.GL_COPY_READ_BUFFER, oldBuffer.bufferID);
				c.glBindBuffer(c.GL_COPY_WRITE_BUFFER, self.ssbo.bufferID);
				c.glCopyBufferSubData(c.GL_COPY_READ_BUFFER, c.GL_COPY_WRITE_BUFFER, 0, 0, @as(c.GLsizeiptr, oldCapacity)*@sizeOf(Entry));
				return rawAlloc(self, size);
			}
		}

		fn finalFree(self: *Self, _allocation: SubAllocation) void {
			if (_allocation.len == 0) return;
			self.used -= _allocation.len;
			var allocation = _allocation;
			for (self.freeBlocks.items, 0..) |*block, i| {
				if (allocation.start + allocation.len == block.start) {
					allocation.len += block.len;
					_ = self.freeBlocks.swapRemove(i);
					break;
				}
			}
			for (self.freeBlocks.items) |*block| {
				if (allocation.start == block.start + block.len) {
					block.len += allocation.len;
					return;
				}
			}
			self.freeBlocks.append(allocation);
		}

		pub fn free(self: *Self, allocation: SubAllocation) void {
			if (allocation.len == 0) return;
			self.fencedFreeLists[self.activeFence].append(allocation);
		}

		/// Must unmap after use!
		pub fn allocateAndMapRange(self: *Self, len: usize, allocation: *SubAllocation) []Entry {
			self.free(allocation.*);
			if (len == 0) {
				allocation.len = 0;
				return &.{};
			}
			allocation.* = self.rawAlloc(@intCast(len));
			c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.ssbo.bufferID);
			const ptr: [*]Entry = @ptrCast(@alignCast(c.glMapBufferRange(
				c.GL_SHADER_STORAGE_BUFFER,
				@as(c.GLintptr, allocation.start)*@sizeOf(Entry),
				@as(c.GLsizeiptr, allocation.len)*@sizeOf(Entry),
				c.GL_MAP_WRITE_BIT | c.GL_MAP_INVALIDATE_RANGE_BIT,
			)));
			return ptr[0..len];
		}

		pub fn unmapRange(self: *Self, range: []Entry) void {
			if (range.len == 0) return;
			c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.ssbo.bufferID);
			std.debug.assert(c.glUnmapBuffer(c.GL_SHADER_STORAGE_BUFFER) == c.GL_TRUE);
		}

		pub fn uploadData(self: *Self, data: []const Entry, allocation: *SubAllocation) void {
			self.free(allocation.*);
			if (data.len == 0) {
				allocation.len = 0;
				return;
			}
			allocation.* = self.rawAlloc(@intCast(data.len));
			c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, self.ssbo.bufferID);
			const ptr: [*]Entry = @ptrCast(@alignCast(c.glMapBufferRange(
				c.GL_SHADER_STORAGE_BUFFER,
				@as(c.GLintptr, allocation.start)*@sizeOf(Entry),
				@as(c.GLsizeiptr, allocation.len)*@sizeOf(Entry),
				c.GL_MAP_WRITE_BIT | c.GL_MAP_INVALIDATE_RANGE_BIT,
			)));
			@memcpy(ptr, data);
			std.debug.assert(c.glUnmapBuffer(c.GL_SHADER_STORAGE_BUFFER) == c.GL_TRUE);
		}
	};
}

pub const FrameBuffer = struct { // MARK: FrameBuffer
	frameBuffer: c_uint,
	texture: c_uint,
	hasDepthTexture: bool,
	depthTexture: c_uint,

	pub fn init(self: *FrameBuffer, hasDepthTexture: bool, textureFilter: c_int, textureWrap: c_int) void {
		self.* = FrameBuffer{
			.frameBuffer = undefined,
			.texture = undefined,
			.depthTexture = undefined,
			.hasDepthTexture = hasDepthTexture,
		};
		c.glGenFramebuffers(1, &self.frameBuffer);
		c.glBindFramebuffer(c.GL_FRAMEBUFFER, self.frameBuffer);
		if (hasDepthTexture) {
			c.glGenTextures(1, &self.depthTexture);
			c.glBindTexture(c.GL_TEXTURE_2D, self.depthTexture);
			c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, textureFilter);
			c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, textureFilter);
			c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, textureWrap);
			c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, textureWrap);
			c.glFramebufferTexture2D(c.GL_FRAMEBUFFER, c.GL_DEPTH_ATTACHMENT, c.GL_TEXTURE_2D, self.depthTexture, 0);
		}
		c.glGenTextures(1, &self.texture);
		c.glBindTexture(c.GL_TEXTURE_2D, self.texture);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, textureFilter);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, textureFilter);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, textureWrap);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, textureWrap);
		c.glFramebufferTexture2D(c.GL_FRAMEBUFFER, c.GL_COLOR_ATTACHMENT0, c.GL_TEXTURE_2D, self.texture, 0);

		c.glBindFramebuffer(c.GL_FRAMEBUFFER, 0);
	}

	pub fn deinit(self: *FrameBuffer) void {
		c.glDeleteFramebuffers(1, &self.frameBuffer);
		if (self.hasDepthTexture) {
			c.glDeleteRenderbuffers(1, &self.depthTexture);
		}
		c.glDeleteTextures(1, &self.texture);
	}

	pub fn updateSize(self: *FrameBuffer, _width: u31, _height: u31, internalFormat: c_int) void {
		const width = @max(_width, 1);
		const height = @max(_height, 1);
		c.glBindFramebuffer(c.GL_FRAMEBUFFER, self.frameBuffer);
		if (self.hasDepthTexture) {
			c.glBindTexture(c.GL_TEXTURE_2D, self.depthTexture);
			c.glTexImage2D(c.GL_TEXTURE_2D, 0, c.GL_DEPTH_COMPONENT32F, width, height, 0, c.GL_DEPTH_COMPONENT, c.GL_FLOAT, null);
		}

		c.glBindTexture(c.GL_TEXTURE_2D, self.texture);
		c.glTexImage2D(c.GL_TEXTURE_2D, 0, internalFormat, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
	}

	pub fn clear(_: FrameBuffer, clearColor: Vec4f) void {
		c.glDepthFunc(c.GL_LESS);
		c.glDepthMask(c.GL_TRUE);
		c.glDisable(c.GL_SCISSOR_TEST);
		c.glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
		c.glClear(c.GL_COLOR_BUFFER_BIT | c.GL_DEPTH_BUFFER_BIT);
	}

	pub fn validate(self: *const FrameBuffer) bool {
		c.glBindFramebuffer(c.GL_FRAMEBUFFER, self.frameBuffer);
		defer c.glBindFramebuffer(c.GL_FRAMEBUFFER, 0);
		if (c.glCheckFramebufferStatus(c.GL_FRAMEBUFFER) != c.GL_FRAMEBUFFER_COMPLETE) {
			std.log.err("Frame Buffer Object error: {}", .{c.glCheckFramebufferStatus(c.GL_FRAMEBUFFER)});
			return false;
		}
		return true;
	}

	pub fn bindTexture(self: *const FrameBuffer, target: c_uint) void {
		c.glActiveTexture(target);
		c.glBindTexture(c.GL_TEXTURE_2D, self.texture);
	}

	pub fn bindDepthTexture(self: *const FrameBuffer, target: c_uint) void {
		std.debug.assert(self.hasDepthTexture);
		c.glActiveTexture(target);
		c.glBindTexture(c.GL_TEXTURE_2D, self.depthTexture);
	}

	pub fn bind(self: *const FrameBuffer) void {
		c.glBindFramebuffer(c.GL_FRAMEBUFFER, self.frameBuffer);
	}

	pub fn unbind(_: *const FrameBuffer) void {
		c.glBindFramebuffer(c.GL_FRAMEBUFFER, 0);
	}
};

pub const TextureArray = struct { // MARK: TextureArray
	textureID: c_uint,

	pub fn init() TextureArray {
		var self: TextureArray = undefined;
		c.glGenTextures(1, &self.textureID);
		return self;
	}

	pub fn deinit(self: TextureArray) void {
		c.glDeleteTextures(1, &self.textureID);
	}

	pub fn bind(self: TextureArray) void {
		c.glBindTexture(c.GL_TEXTURE_2D_ARRAY, self.textureID);
	}

	fn lodColorInterpolation(colors: [4]Color, alphaCorrection: bool) Color {
		var r: [4]f32 = undefined;
		var g: [4]f32 = undefined;
		var b: [4]f32 = undefined;
		var a: [4]f32 = undefined;
		for (0..4) |i| {
			r[i] = @floatFromInt(colors[i].r);
			g[i] = @floatFromInt(colors[i].g);
			b[i] = @floatFromInt(colors[i].b);
			a[i] = @floatFromInt(colors[i].a);
		}
		// Use gamma corrected average(https://stackoverflow.com/a/832314/13082649):
		var aSum: f32 = 0;
		var rSum: f32 = 0;
		var gSum: f32 = 0;
		var bSum: f32 = 0;
		for (0..4) |i| {
			const w = if (alphaCorrection) a[i]*a[i] else 1;
			aSum += a[i]*a[i];
			rSum += w*r[i]*r[i];
			gSum += w*g[i]*g[i];
			bSum += w*b[i]*b[i];
		}
		aSum = @sqrt(aSum)/2;
		rSum = @sqrt(rSum)/2;
		gSum = @sqrt(gSum)/2;
		bSum = @sqrt(bSum)/2;
		if (alphaCorrection and aSum != 0) {
			rSum /= aSum;
			gSum /= aSum;
			bSum /= aSum;
		}
		return Color{.r = @intFromFloat(rSum), .g = @intFromFloat(gSum), .b = @intFromFloat(bSum), .a = @intFromFloat(aSum)};
	}

	/// (Re-)Generates the GPU buffer.
	pub fn generate(self: TextureArray, images: []Image, mipmapping: bool, alphaCorrectMipmapping: bool) void {
		var maxWidth: u31 = 1;
		var maxHeight: u31 = 1;
		for (images) |image| {
			maxWidth = @max(maxWidth, image.width);
			maxHeight = @max(maxHeight, image.height);
		}
		// Make sure the width and height use a power of 2:
		if (maxWidth - 1 & maxWidth != 0) {
			maxWidth = @as(u31, 2) << std.math.log2_int(u31, maxWidth);
		}
		if (maxHeight - 1 & maxHeight != 0) {
			maxHeight = @as(u31, 2) << std.math.log2_int(u31, maxHeight);
		}

		std.log.debug("Creating Texture Array of size {}×{} with {} layers.", .{maxWidth, maxHeight, images.len});

		self.bind();

		const maxLOD = if (mipmapping) 1 + std.math.log2_int(u31, @min(maxWidth, maxHeight)) else 1;
		for (0..maxLOD) |i| {
			c.glTexImage3D(c.GL_TEXTURE_2D_ARRAY, @intCast(i), c.GL_RGBA8, @max(0, maxWidth >> @intCast(i)), @max(0, maxHeight >> @intCast(i)), @intCast(images.len), 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		}
		const arena = main.stackAllocator.createArena();
		defer main.stackAllocator.destroyArena(arena);
		const lodBuffer: [][]Color = arena.alloc([]Color, maxLOD);
		for (lodBuffer, 0..) |*buffer, i| {
			buffer.* = arena.alloc(Color, (maxWidth >> @intCast(i))*(maxHeight >> @intCast(i)));
		}

		for (images, 0..) |image, i| {
			// Fill the buffer using nearest sampling. Probably not the best solutions for all textures, but that's what happens when someone doesn't use power of 2 textures...
			for (0..maxWidth) |x| {
				for (0..maxHeight) |y| {
					const index = x + y*maxWidth;
					const imageIndex = (x*image.width)/maxWidth + image.width*((y*image.height)/maxHeight);
					lodBuffer[0][index] = image.imageData[imageIndex];
				}
			}

			// Calculate the mipmap levels:
			for (0..lodBuffer.len) |_lod| {
				const lod: u5 = @intCast(_lod);
				const curWidth = maxWidth >> lod;
				const curHeight = maxHeight >> lod;
				if (lod != 0) {
					for (0..curWidth) |x| {
						for (0..curHeight) |y| {
							const index = x + y*curWidth;
							const index2 = 2*x + 2*y*2*curWidth;
							const colors = [4]Color{
								lodBuffer[lod - 1][index2],
								lodBuffer[lod - 1][index2 + 1],
								lodBuffer[lod - 1][index2 + curWidth*2],
								lodBuffer[lod - 1][index2 + curWidth*2 + 1],
							};
							lodBuffer[lod][index] = lodColorInterpolation(colors, alphaCorrectMipmapping);
						}
					}
				}
			}
			// Give the correct color to alpha 0 pixels, to avoid dark pixels:
			for (1..lodBuffer.len) |_lod| {
				const lod: u5 = @intCast(lodBuffer.len - 1 - _lod);
				const curWidth = maxWidth >> lod;
				const curHeight = maxHeight >> lod;
				for (0..curWidth) |x| {
					for (0..curHeight) |y| {
						const index = x + y*curWidth;
						const index2 = x/2 + y/2*curWidth/2;
						if (lodBuffer[lod][index].a == 0) {
							lodBuffer[lod][index].r = lodBuffer[lod + 1][index2].r;
							lodBuffer[lod][index].g = lodBuffer[lod + 1][index2].g;
							lodBuffer[lod][index].b = lodBuffer[lod + 1][index2].b;
						}
					}
				}
			}
			// Upload:
			for (0..lodBuffer.len) |_lod| {
				const lod: u5 = @intCast(lodBuffer.len - 1 - _lod);
				const curWidth = maxWidth >> lod;
				const curHeight = maxHeight >> lod;
				c.glTexSubImage3D(c.GL_TEXTURE_2D_ARRAY, lod, 0, 0, @intCast(i), curWidth, curHeight, 1, c.GL_RGBA, c.GL_UNSIGNED_BYTE, lodBuffer[lod].ptr);
			}
		}
		c.glTexParameteri(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MAX_LOD, maxLOD);
		c.glTexParameteri(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MIN_FILTER, c.GL_NEAREST_MIPMAP_LINEAR);
		c.glTexParameteri(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MAG_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_WRAP_S, c.GL_REPEAT);
		c.glTexParameteri(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_WRAP_T, c.GL_REPEAT);
	}
};

pub const Texture = struct { // MARK: Texture
	textureID: c_uint,

	pub fn init() Texture {
		var self: Texture = undefined;
		c.glGenTextures(1, &self.textureID);
		return self;
	}

	pub fn initFromFile(path: []const u8) Texture {
		const self = Texture.init();
		const image = Image.readFromFile(main.stackAllocator, path) catch |err| blk: {
			std.log.err("Couldn't read image from {s}: {s}", .{path, @errorName(err)});
			break :blk Image.defaultImage;
		};
		defer image.deinit(main.stackAllocator);
		self.generate(image);
		return self;
	}

	pub fn initFromMipmapFiles(pathPrefix: []const u8, largestSize: u31, lodBias: f32) Texture {
		const self = Texture.init();
		self.bind();

		const maxLod = std.math.log2_int(u31, largestSize);

		var curSize: u31 = largestSize;
		while (curSize != 0) : (curSize /= 2) {
			c.glTexImage2D(c.GL_TEXTURE_2D, maxLod - std.math.log2_int(u31, curSize), c.GL_RGBA8, curSize, curSize, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		}

		curSize = largestSize;
		while (curSize != 0) : (curSize /= 2) {
			const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}{}.png", .{pathPrefix, curSize}) catch unreachable;
			defer main.stackAllocator.free(path);
			const image = Image.readFromFile(main.stackAllocator, path) catch |err| blk: {
				std.log.err("Couldn't read image from {s}: {s}", .{path, @errorName(err)});
				break :blk Image.defaultImage;
			};
			defer image.deinit(main.stackAllocator);
			c.glTexSubImage2D(c.GL_TEXTURE_2D, maxLod - std.math.log2_int(u31, curSize), 0, 0, curSize, curSize, c.GL_RGBA, c.GL_UNSIGNED_BYTE, image.imageData.ptr);
		}

		c.glTexParameteri(c.GL_TEXTURE_2D_ARRAY, c.GL_TEXTURE_MAX_LOD, maxLod);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, c.GL_NEAREST_MIPMAP_LINEAR);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, c.GL_REPEAT);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, c.GL_REPEAT);
		c.glTexParameterf(c.GL_TEXTURE_2D, c.GL_TEXTURE_LOD_BIAS, lodBias);
		return self;
	}

	pub fn deinit(self: Texture) void {
		c.glDeleteTextures(1, &self.textureID);
	}

	pub fn bindTo(self: Texture, binding: u5) void {
		c.glActiveTexture(@intCast(c.GL_TEXTURE0 + binding));
		c.glBindTexture(c.GL_TEXTURE_2D, self.textureID);
	}

	pub fn bind(self: Texture) void {
		c.glBindTexture(c.GL_TEXTURE_2D, self.textureID);
	}

	/// (Re-)Generates the GPU buffer.
	pub fn generate(self: Texture, image: Image) void {
		self.bind();

		c.glTexImage2D(c.GL_TEXTURE_2D, 0, c.GL_RGBA8, image.width, image.height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, image.imageData.ptr);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, c.GL_REPEAT);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, c.GL_REPEAT);
	}

	pub fn render(self: Texture, pos: Vec2f, dim: Vec2f) void {
		self.bindTo(0);
		draw.boundImage(pos, dim);
	}

	pub fn size(self: Texture) Vec2i {
		self.bind();
		var result: Vec2i = undefined;
		c.glGetTexLevelParameteriv(c.GL_TEXTURE_2D, 0, c.GL_TEXTURE_WIDTH, &result[0]);
		c.glGetTexLevelParameteriv(c.GL_TEXTURE_2D, 0, c.GL_TEXTURE_HEIGHT, &result[1]);
		return result;
	}
};

pub const CubeMapTexture = struct { // MARK: CubeMapTexture
	textureID: c_uint,

	pub fn init() CubeMapTexture {
		var self: CubeMapTexture = undefined;
		c.glGenTextures(1, &self.textureID);
		return self;
	}

	pub fn deinit(self: CubeMapTexture) void {
		c.glDeleteTextures(1, &self.textureID);
	}

	pub fn bindTo(self: CubeMapTexture, binding: u5) void {
		c.glActiveTexture(@intCast(c.GL_TEXTURE0 + binding));
		c.glBindTexture(c.GL_TEXTURE_CUBE_MAP, self.textureID);
	}

	pub fn bind(self: CubeMapTexture) void {
		c.glBindTexture(c.GL_TEXTURE_CUBE_MAP, self.textureID);
	}

	/// (Re-)Generates the GPU buffer.
	pub fn generate(self: CubeMapTexture, width: u31, height: u31) void {
		self.bind();

		c.glTexImage2D(c.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, c.GL_RGBA8, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		c.glTexImage2D(c.GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c.GL_RGBA8, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		c.glTexImage2D(c.GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c.GL_RGBA8, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		c.glTexImage2D(c.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c.GL_RGBA8, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		c.glTexImage2D(c.GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c.GL_RGBA8, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		c.glTexImage2D(c.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c.GL_RGBA8, width, height, 0, c.GL_RGBA, c.GL_UNSIGNED_BYTE, null);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_MIN_FILTER, c.GL_LINEAR);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_MAG_FILTER, c.GL_LINEAR);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_WRAP_S, c.GL_CLAMP_TO_EDGE);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_WRAP_T, c.GL_CLAMP_TO_EDGE);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_WRAP_R, c.GL_CLAMP_TO_EDGE);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_BASE_LEVEL, 0);
		c.glTexParameteri(c.GL_TEXTURE_CUBE_MAP, c.GL_TEXTURE_MAX_LEVEL, 0);
	}

	pub fn faceNormal(face: usize) Vec3f {
		const normals = [_]Vec3f{
			.{1, 0, 0}, // +x
			.{-1, 0, 0}, // -x
			.{0, 1, 0}, // +y
			.{0, -1, 0}, // -y
			.{0, 0, 1}, // +z
			.{0, 0, -1}, // -z
		};
		return normals[face];
	}

	pub fn faceUp(face: usize) Vec3f {
		const ups = [_]Vec3f{
			.{0, -1, 0}, // +x
			.{0, -1, 0}, // -x
			.{0, 0, 1}, // +y
			.{0, 0, -1}, // -y
			.{0, -1, 0}, // +z
			.{0, -1, 0}, // -z
		};
		return ups[face];
	}

	pub fn faceRight(face: usize) Vec3f {
		comptime var rights: [6]Vec3f = undefined;
		inline for (0..6) |i| {
			rights[i] = comptime vec.cross(faceNormal(i), faceUp(i));
		}
		return rights[face];
	}

	pub fn bindToFramebuffer(self: CubeMapTexture, fb: FrameBuffer, face: c_uint) void {
		fb.bind();
		c.glFramebufferTexture2D(c.GL_FRAMEBUFFER, c.GL_COLOR_ATTACHMENT0, @as(c_uint, c.GL_TEXTURE_CUBE_MAP_POSITIVE_X) + face, self.textureID, 0);
	}
};

pub const Color = extern struct { // MARK: Color
	r: u8,
	g: u8,
	b: u8,
	a: u8,

	pub fn toARBG(self: Color) u32 {
		return @as(u32, self.a) << 24 | @as(u32, self.r) << 16 | @as(u32, self.g) << 8 | @as(u32, self.b);
	}
};

pub const Image = struct { // MARK: Image
	var defaultImageData = [4]Color{
		Color{.r = 0, .g = 0, .b = 0, .a = 255},
		Color{.r = 255, .g = 0, .b = 255, .a = 255},
		Color{.r = 255, .g = 0, .b = 255, .a = 255},
		Color{.r = 0, .g = 0, .b = 0, .a = 255},
	};
	pub const defaultImage = Image{
		.width = 2,
		.height = 2,
		.imageData = &defaultImageData,
	};
	var emptyImageData = [1]Color{
		Color{.r = 0, .g = 0, .b = 0, .a = 0},
	};
	pub const emptyImage = Image{
		.width = 1,
		.height = 1,
		.imageData = &emptyImageData,
	};
	var whiteImageData = [1]Color{
		Color{.r = 255, .g = 255, .b = 255, .a = 255},
	};
	pub const whiteEmptyImage = Image{
		.width = 1,
		.height = 1,
		.imageData = &whiteImageData,
	};
	width: u31,
	height: u31,
	imageData: []Color,
	pub fn init(allocator: NeverFailingAllocator, width: u31, height: u31) Image {
		return Image{
			.width = width,
			.height = height,
			.imageData = allocator.alloc(Color, width*height),
		};
	}
	pub fn deinit(self: Image, allocator: NeverFailingAllocator) void {
		if (self.imageData.ptr == &defaultImageData or self.imageData.ptr == &emptyImageData or self.imageData.ptr == &whiteImageData) return;
		allocator.free(self.imageData);
	}
	pub fn readFromFile(allocator: NeverFailingAllocator, path: []const u8) !Image {
		var result: Image = undefined;
		var channel: c_int = undefined;
		const nullTerminatedPath = main.stackAllocator.dupeZ(u8, path); // TODO: Find a more zig-friendly image loading library.
		errdefer main.stackAllocator.free(nullTerminatedPath);
		stb_image.stbi_set_flip_vertically_on_load(1);
		const data = stb_image.stbi_load(nullTerminatedPath.ptr, @ptrCast(&result.width), @ptrCast(&result.height), &channel, 4) orelse {
			return error.FileNotFound;
		};
		main.stackAllocator.free(nullTerminatedPath);
		result.imageData = allocator.dupe(Color, @as([*]Color, @ptrCast(data))[0 .. result.width*result.height]);
		stb_image.stbi_image_free(data);
		return result;
	}
	pub fn readUnflippedFromFile(allocator: NeverFailingAllocator, path: []const u8) !Image {
		var result: Image = undefined;
		var channel: c_int = undefined;
		const nullTerminatedPath = main.stackAllocator.dupeZ(u8, path); // TODO: Find a more zig-friendly image loading library.
		errdefer main.stackAllocator.free(nullTerminatedPath);
		const data = stb_image.stbi_load(nullTerminatedPath.ptr, @ptrCast(&result.width), @ptrCast(&result.height), &channel, 4) orelse {
			return error.FileNotFound;
		};
		main.stackAllocator.free(nullTerminatedPath);
		result.imageData = allocator.dupe(Color, @as([*]Color, @ptrCast(data))[0 .. result.width*result.height]);
		stb_image.stbi_image_free(data);
		return result;
	}
	pub fn exportToFile(self: Image, path: []const u8) !void {
		const nullTerminated = main.stackAllocator.dupeZ(u8, path);
		defer main.stackAllocator.free(nullTerminated);
		_ = stb_image.stbi_write_png(nullTerminated.ptr, self.width, self.height, 4, self.imageData.ptr, self.width*4); // TODO: Handle the return type.
	}
	pub fn getRGB(self: Image, x: usize, y: usize) Color {
		std.debug.assert(x < self.width);
		std.debug.assert(y < self.height);
		const index = x + y*self.width;
		return self.imageData[index];
	}
	pub fn setRGB(self: Image, x: usize, y: usize, rgb: Color) void {
		std.debug.assert(x < self.width);
		std.debug.assert(y < self.height);
		const index = x + y*self.width;
		self.imageData[index] = rgb;
	}
};

pub const Fog = struct { // MARK: Fog
	fogColor: Vec3f,
	skyColor: Vec3f,
	density: f32,
	fogLower: f32,
	fogHigher: f32,
};

const block_texture = struct { // MARK: block_texture
	var uniforms: struct {
		transparent: c_int,
	} = undefined;
	var pipeline: Pipeline = undefined;
	var depthTexture: Texture = undefined;
	const textureSize = 128;

	fn init() void {
		pipeline = Pipeline.init(
			"assets/cubyz/shaders/item_texture_post.vert",
			"assets/cubyz/shaders/item_texture_post.frag",
			"",
			&uniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.noBlending}},
		);
		depthTexture = .init();
		depthTexture.bind();
		var data: [128*128]f32 = undefined;

		const z: f32 = 134;
		const near = main.renderer.zNear;
		const far = main.renderer.zFar;
		const depth = ((far + near)/(near - far)*-z + 2*near*far/(near - far))/z*0.5 + 0.5;

		@memset(&data, depth);
		c.glTexImage2D(c.GL_TEXTURE_2D, 0, c.GL_R32F, textureSize, textureSize, 0, c.GL_RED, c.GL_FLOAT, &data);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MIN_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_MAG_FILTER, c.GL_NEAREST);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_S, c.GL_REPEAT);
		c.glTexParameteri(c.GL_TEXTURE_2D, c.GL_TEXTURE_WRAP_T, c.GL_REPEAT);
	}
	fn deinit() void {
		pipeline.deinit();
		depthTexture.deinit();
	}
};

pub fn generateBlockTexture(blockType: u16) Texture {
	const block = main.blocks.Block{.typ = blockType, .data = 0}; // TODO: Use natural standard data.
	const textureSize = block_texture.textureSize;
	c.glViewport(0, 0, textureSize, textureSize);

	var frameBuffer: FrameBuffer = undefined;

	frameBuffer.init(false, c.GL_NEAREST, c.GL_REPEAT);
	defer frameBuffer.deinit();
	frameBuffer.updateSize(textureSize, textureSize, c.GL_RGBA16F);
	frameBuffer.bind();
	if (block.transparent()) {
		frameBuffer.clear(.{0.683421, 0.6854237, 0.685426, 1});
	} else {
		frameBuffer.clear(.{0, 0, 0, 0});
	}

	const projMatrix = Mat4f.perspective(0.013, 1, 64, 256);
	const oldViewMatrix = main.game.camera.viewMatrix;
	main.game.camera.viewMatrix = Mat4f.identity().mul(Mat4f.rotationX(std.math.pi/4.0)).mul(Mat4f.rotationZ(1.0*std.math.pi/4.0));
	defer main.game.camera.viewMatrix = oldViewMatrix;
	const uniforms = if (block.transparent()) &main.renderer.chunk_meshing.transparentUniforms else &main.renderer.chunk_meshing.uniforms;

	var faceData: main.ListUnmanaged(main.renderer.chunk_meshing.FaceData) = .{};
	defer faceData.deinit(main.stackAllocator);
	const model = main.blocks.meshes.model(block).model();
	const pos: main.chunk.BlockPos = .fromCoords(1, 1, 1);
	if (block.hasBackFace()) {
		model.appendInternalQuadsToList(&faceData, main.stackAllocator, block, pos, true);
		for (main.chunk.Neighbor.iterable) |neighbor| {
			model.appendNeighborFacingQuadsToList(&faceData, main.stackAllocator, block, neighbor, pos, true);
		}
	}
	model.appendInternalQuadsToList(&faceData, main.stackAllocator, block, pos, false);
	for (main.chunk.Neighbor.iterable) |neighbor| {
		model.appendNeighborFacingQuadsToList(&faceData, main.stackAllocator, block, neighbor, pos.neighbor(neighbor)[0], false);
	}

	for (faceData.items) |*face| {
		face.position.lightIndex = 0;
	}
	var allocation: SubAllocation = .{.start = 0, .len = 0};
	main.renderer.chunk_meshing.faceBuffers[0].uploadData(faceData.items, &allocation);
	defer main.renderer.chunk_meshing.faceBuffers[0].free(allocation);
	var lightAllocation: SubAllocation = .{.start = 0, .len = 0};
	main.renderer.chunk_meshing.lightBuffers[0].uploadData(&.{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}, &lightAllocation);
	defer main.renderer.chunk_meshing.lightBuffers[0].free(lightAllocation);

	{
		const i = 4; // Easily switch between the 8 diagonal coordinates.
		var x: f64 = -65.5 + 1.5;
		var y: f64 = -65.5 + 1.5;
		var z: f64 = -92.631 + 1.5;
		if (i & 1 != 0) x = -x + 3;
		if (i & 2 != 0) y = -y + 3;
		if (i & 4 != 0) z = -z + 3;
		var chunkAllocation: SubAllocation = .{.start = 0, .len = 0};
		main.renderer.chunk_meshing.chunkBuffer.uploadData(&.{.{
			.position = .{0, 0, 0},
			.min = undefined,
			.max = undefined,
			.voxelSize = 1,
			.lightStart = lightAllocation.start,
			.vertexStartOpaque = undefined,
			.faceCountsByNormalOpaque = undefined,
			.vertexStartTransparent = undefined,
			.vertexCountTransparent = undefined,
			.visibilityState = 0,
			.oldVisibilityState = 0,
		}}, &chunkAllocation);
		defer main.renderer.chunk_meshing.chunkBuffer.free(chunkAllocation);
		if (block.transparent()) {
			c.glBlendEquation(c.GL_FUNC_ADD);
			c.glBlendFunc(c.GL_ONE, c.GL_SRC1_COLOR);
			main.renderer.chunk_meshing.bindTransparentShaderAndUniforms(projMatrix, .{1, 1, 1}, .{x, y, z});
		} else {
			main.renderer.chunk_meshing.bindShaderAndUniforms(projMatrix, .{1, 1, 1}, .{x, y, z});
		}
		c.glUniform1f(uniforms.contrast, 0.25);
		c.glActiveTexture(c.GL_TEXTURE0);
		main.blocks.meshes.blockTextureArray.bind();
		c.glActiveTexture(c.GL_TEXTURE1);
		main.blocks.meshes.emissionTextureArray.bind();
		c.glActiveTexture(c.GL_TEXTURE2);
		main.blocks.meshes.reflectivityAndAbsorptionTextureArray.bind();
		block_texture.depthTexture.bindTo(5);
		c.glDrawElementsInstancedBaseVertexBaseInstance(c.GL_TRIANGLES, @intCast(6*faceData.items.len), c.GL_UNSIGNED_INT, null, 1, allocation.start*4, chunkAllocation.start);
	}

	c.glDisable(c.GL_CULL_FACE);
	var finalFrameBuffer: FrameBuffer = undefined;
	finalFrameBuffer.init(false, c.GL_NEAREST, c.GL_REPEAT);
	finalFrameBuffer.updateSize(textureSize, textureSize, c.GL_RGBA8);
	finalFrameBuffer.bind();
	const texture = Texture{.textureID = finalFrameBuffer.texture};
	defer c.glDeleteFramebuffers(1, &finalFrameBuffer.frameBuffer);
	block_texture.pipeline.bind(null);
	c.glUniform1i(block_texture.uniforms.transparent, if (block.transparent()) c.GL_TRUE else c.GL_FALSE);
	frameBuffer.bindTexture(c.GL_TEXTURE3);

	c.glBindVertexArray(draw.rectVAO);
	c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);

	c.glBindFramebuffer(c.GL_FRAMEBUFFER, 0);

	c.glViewport(0, 0, main.Window.width, main.Window.height);
	c.glBlendFunc(c.GL_SRC_ALPHA, c.GL_ONE_MINUS_SRC_ALPHA);
	return texture;
}

```

`src/graphics/Window.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

const main = @import("main");
const settings = main.settings;
const files = main.files;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const vulkan = @import("vulkan.zig");

pub const c = @cImport({
	@cInclude("glad/gl.h");

	// NOTE(blackedout): glad is currently not used on macOS, so use Vulkan header from the Vulkan-Headers repository instead
	if (builtin.target.os.tag == .macos) {
		@cInclude("vulkan/vulkan.h");
		@cInclude("vulkan/vulkan_beta.h");
	} else {
		@cInclude("glad/vulkan.h");
	}
	@cInclude("GLFW/glfw3.h");
});

var isFullscreen: bool = false;
pub var lastUsedMouse: bool = true;
pub var width: u31 = 1280;
pub var height: u31 = 720;
pub var window: *c.GLFWwindow = undefined;
pub var vulkanWindow: *c.GLFWwindow = undefined;
pub var grabbed: bool = false;
pub var scrollOffset: f32 = 0;
pub var scrollOffsetInteger: i32 = 0;
var scrollOffsetFraction: f32 = 0;

pub const Gamepad = struct {
	pub var gamepadState: std.AutoHashMap(c_int, *c.GLFWgamepadstate) = undefined;
	pub var controllerMappingsDownloaded: std.atomic.Value(bool) = std.atomic.Value(bool).init(false);
	var controllerConnectedPreviously: bool = false;
	fn applyDeadzone(state: *c.GLFWgamepadstate, axis: usize) void {
		const value = state.axes[axis];
		const minValue = settings.controllerAxisDeadzone;
		const maxRange = 1.0 - minValue;
		state.axes[axis] = std.math.sign(value)*(@max(0, @abs(value) - minValue))/maxRange;
	}
	fn applyDeadzones2D(state: *c.GLFWgamepadstate, xAxis: usize, yAxis: usize) void {
		var axisVec: Vec2f = .{state.axes[xAxis], state.axes[yAxis]};
		const length: Vec2f = @splat(vec.length(axisVec));
		const minValue: Vec2f = @splat(settings.controllerAxisDeadzone);
		const maxRange: Vec2f = @splat((1.0 - minValue[0])*length[0]);

		axisVec = axisVec*(@max(Vec2f{0, 0}, length - minValue))/maxRange;
		if (vec.lengthSquare(axisVec) > 1) {
			axisVec = vec.normalize(axisVec);
		}

		state.axes[xAxis] = axisVec[0];
		state.axes[yAxis] = axisVec[1];
	}
	pub fn update(delta: f64) void {
		if (!controllerConnectedPreviously and isControllerConnected()) {
			controllerConnectedPreviously = true;
			downloadControllerMappings();
		}
		var jid: c_int = 0;
		while (jid < c.GLFW_JOYSTICK_LAST) : (jid += 1) {
			// Can't initialize with the state, or it will become a reference.
			var oldState: c.GLFWgamepadstate = std.mem.zeroes(c.GLFWgamepadstate);
			if (gamepadState.get(jid)) |v| {
				oldState = v.*;
			}
			const joystickFound = c.glfwJoystickPresent(jid) != 0 and c.glfwJoystickIsGamepad(jid) != 0;
			if (joystickFound) {
				if (!gamepadState.contains(jid)) {
					gamepadState.put(jid, main.globalAllocator.create(c.GLFWgamepadstate)) catch unreachable;
				}
				_ = c.glfwGetGamepadState(jid, gamepadState.get(jid).?);
			} else {
				if (gamepadState.contains(jid)) {
					main.globalAllocator.destroy(gamepadState.get(jid).?);
					_ = gamepadState.remove(jid);
				}
			}
			const newState: *c.GLFWgamepadstate = gamepadState.get(jid) orelse continue;
			applyDeadzones2D(newState, c.GLFW_GAMEPAD_AXIS_LEFT_X, c.GLFW_GAMEPAD_AXIS_LEFT_Y);
			applyDeadzones2D(newState, c.GLFW_GAMEPAD_AXIS_RIGHT_X, c.GLFW_GAMEPAD_AXIS_RIGHT_Y);
			applyDeadzone(newState, c.GLFW_GAMEPAD_AXIS_LEFT_TRIGGER);
			applyDeadzone(newState, c.GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER);
			if (nextGamepadListener != null) {
				for (0..c.GLFW_GAMEPAD_BUTTON_LAST) |btn| {
					if ((newState.buttons[btn] == 0) and (oldState.buttons[btn] != 0)) {
						nextGamepadListener.?(null, @intCast(btn));
						nextGamepadListener = null;
						break;
					}
				}
			}
			if (nextGamepadListener != null) {
				for (0..c.GLFW_GAMEPAD_AXIS_LAST) |axis| {
					const newAxis = newState.axes[axis];
					const oldAxis = oldState.axes[axis];
					if (newAxis != 0 and oldAxis == 0) {
						nextGamepadListener.?(.{.axis = @intCast(axis), .positive = newState.axes[axis] > 0}, -1);
						nextGamepadListener = null;
						break;
					}
				}
			}
			const isGrabbed = grabbed;
			for (&main.KeyBoard.keys) |*key| {
				if (key.gamepadAxis == null) {
					if (key.gamepadButton >= 0) {
						const oldPressed = oldState.buttons[@intCast(key.gamepadButton)] != 0;
						const newPressed = newState.buttons[@intCast(key.gamepadButton)] != 0;
						if (oldPressed != newPressed) {
							key.setPressed(newPressed, isGrabbed, .{}, false);
						}
					}
				} else {
					const axis = key.gamepadAxis.?.axis;
					const positive = key.gamepadAxis.?.positive;
					var newAxis = newState.axes[@intCast(axis)];
					var oldAxis = oldState.axes[@intCast(axis)];
					if (!positive) {
						newAxis *= -1.0;
						oldAxis *= -1.0;
					}
					newAxis = @max(newAxis, 0.0);
					oldAxis = @max(oldAxis, 0.0);
					const oldPressed = oldAxis > 0.5;
					const newPressed = newAxis > 0.5;
					if (oldPressed != newPressed) {
						key.setPressed(newPressed, isGrabbed, .{}, false);
					}
					if (newAxis != oldAxis) {
						key.value = newAxis;
					}
				}
			}
		}
		if (!grabbed) {
			const x = main.KeyBoard.key("uiRight").value - main.KeyBoard.key("uiLeft").value;
			const y = main.KeyBoard.key("uiDown").value - main.KeyBoard.key("uiUp").value;
			if (x != 0 or y != 0) {
				lastUsedMouse = false;
				GLFWCallbacks.currentPos[0] += @floatCast(x*delta*256);
				GLFWCallbacks.currentPos[1] += @floatCast(y*delta*256);
				const winSize = getWindowSize();
				GLFWCallbacks.currentPos[0] = std.math.clamp(GLFWCallbacks.currentPos[0], 0, winSize[0]);
				GLFWCallbacks.currentPos[1] = std.math.clamp(GLFWCallbacks.currentPos[1], 0, winSize[1]);
			}
			GLFWCallbacks.scroll(undefined, 0, @floatCast((main.KeyBoard.key("scrollUp").value - main.KeyBoard.key("scrollDown").value)*delta*4));
		}
		setCursorVisible(!grabbed and lastUsedMouse);
	}
	pub fn isControllerConnected() bool {
		return gamepadState.count() > 0;
	}
	pub fn wereControllerMappingsDownloaded() bool {
		return controllerMappingsDownloaded.load(std.builtin.AtomicOrder.acquire);
	}
	const ControllerMappingDownloadTask = struct { // MARK: ControllerMappingDownloadTask
		curTimestamp: i128,
		var running = std.atomic.Value(bool).init(false);
		const vtable = main.utils.ThreadPool.VTable{
			.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
			.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
			.run = main.meta.castFunctionSelfToAnyopaque(run),
			.clean = main.meta.castFunctionSelfToAnyopaque(clean),
		};

		pub fn schedule(curTimestamp: i128) void {
			if (running.swap(true, .monotonic)) {
				std.log.warn("Attempt to schedule a duplicate controller mapping download task!", .{});
				return; // Controller mappings are already downloading.
			}
			controllerMappingsDownloaded.store(false, .monotonic);
			const task = main.globalAllocator.create(ControllerMappingDownloadTask);
			task.* = ControllerMappingDownloadTask{
				.curTimestamp = curTimestamp,
			};
			main.threadPool.addTask(task, &vtable);
			// Don't attempt to open the window before the GUI is initialized.
			main.gui.openWindow("download_controller_mappings");
		}

		pub fn getPriority(_: *ControllerMappingDownloadTask) f32 {
			return std.math.inf(f32);
		}

		pub fn isStillNeeded(_: *ControllerMappingDownloadTask) bool {
			return true;
		}

		pub fn run(self: *ControllerMappingDownloadTask) void {
			std.log.info("Starting controller mapping download...", .{});
			defer self.clean();
			var client: std.http.Client = .{.allocator = main.stackAllocator.allocator, .io = main.io};
			defer client.deinit();
			var writer = std.Io.Writer.Allocating.init(main.stackAllocator.allocator);
			defer writer.deinit();
			defer controllerMappingsDownloaded.store(true, std.builtin.AtomicOrder.release);
			const fetchResult = client.fetch(.{
				.method = .GET,
				.location = .{.url = "https://raw.githubusercontent.com/mdqinc/SDL_GameControllerDB/master/gamecontrollerdb.txt"},
				.response_writer = &writer.writer,
			}) catch |err| {
				std.log.err("Failed to download controller mappings: {s}", .{@errorName(err)});
				return;
			};
			if (fetchResult.status != .ok) {
				std.log.err("Failed to download controller mappings: HTTP error {d}", .{@intFromEnum(fetchResult.status)});
				return;
			}
			files.cwd().write("./gamecontrollerdb.txt", writer.written()) catch |err| {
				std.log.err("Failed to write controller mappings: {s}", .{@errorName(err)});
				return;
			};
			const timeStampStr = std.fmt.allocPrint(main.stackAllocator.allocator, "{x}", .{self.*.curTimestamp}) catch unreachable;
			defer main.stackAllocator.free(timeStampStr);
			files.cwd().write("gamecontrollerdb.stamp", timeStampStr) catch |err| {
				std.log.err("Failed to write controller mappings: {s}", .{@errorName(err)});
				return;
			};
			std.log.info("Controller mappings downloaded succesfully!", .{});
		}

		pub fn clean(self: *ControllerMappingDownloadTask) void {
			main.globalAllocator.destroy(self);
			updateControllerMappings();
			running.store(false, .monotonic);
		}
	};
	pub fn downloadControllerMappings() void {
		if (builtin.mode == .Debug) return; // TODO: The http fetch adds ~5 seconds to the compile time, so it's disabled in debug mode, see #24435
		var needsDownload: bool = false;
		const curTimestamp: i96 = (std.Io.Clock.Timestamp.now(main.io, .real) catch unreachable).raw.nanoseconds;
		const timestamp: i96 = blk: {
			const stamp = files.cwd().read(main.stackAllocator, "./gamecontrollerdb.stamp") catch break :blk 0;
			defer main.stackAllocator.free(stamp);
			break :blk std.fmt.parseInt(i96, stamp, 16) catch 0;
		};
		const delta = curTimestamp -% timestamp;
		needsDownload = delta >= 7*std.time.ns_per_day;

		for (0..c.GLFW_JOYSTICK_LAST) |jsid| {
			if ((c.glfwJoystickPresent(@intCast(jsid)) != 0) and (c.glfwJoystickIsGamepad(@intCast(jsid)) == 0)) {
				needsDownload = true;
				break;
			}
		}
		std.log.info("Game controller mappings {s}need downloading.", .{if (needsDownload) "" else "do not "});
		if (needsDownload) {
			ControllerMappingDownloadTask.schedule(curTimestamp);
		} else {
			controllerMappingsDownloaded.store(true, .monotonic);
			updateControllerMappings();
		}
	}
	pub fn updateControllerMappings() void {
		std.log.info("Updating controller mappings in-memory...", .{});
		var _envMap = std.process.getEnvMap(main.stackAllocator.allocator) catch null;
		if (_envMap) |*envMap| {
			defer envMap.deinit();
			if (envMap.get("SDL_GAMECONTROLLERCONFIG")) |controller_config_env| {
				_ = c.glfwUpdateGamepadMappings(@ptrCast(controller_config_env));
				return;
			}
		}
		const data = main.files.cwd().read(main.stackAllocator, "./gamecontrollerdb.txt") catch |err| {
			if (@TypeOf(err) == std.fs.File.OpenError and err == std.fs.File.OpenError.FileNotFound) {
				return; // Ignore not finding mappings.
			}
			std.log.err("Error opening gamepad mappings file: {s}", .{@errorName(err)});
			return;
		};
		var newData = main.stackAllocator.realloc(data, data.len + 1);
		defer main.stackAllocator.free(newData);
		newData[data.len - 1] = 0;
		_ = c.glfwUpdateGamepadMappings(newData.ptr);
		std.log.info("Controller mappings updated!", .{});
	}

	pub fn init() void {
		gamepadState = .init(main.globalAllocator.allocator);
	}
	pub fn deinit() void {
		var iter = gamepadState.valueIterator();
		while (iter.next()) |value| {
			main.globalAllocator.destroy(value.*);
		}
		gamepadState.deinit();
	}
};
pub const GamepadAxis = struct {
	axis: c_int,
	positive: bool = true,
};
pub const Key = struct { // MARK: Key
	name: []const u8,
	pressed: bool = false,
	isToggling: IsToggling = .never,
	modsOnPress: Modifiers = .{},
	value: f32 = 0.0,
	key: c_int = c.GLFW_KEY_UNKNOWN,
	gamepadAxis: ?GamepadAxis = null,
	gamepadButton: c_int = -1,
	mouseButton: c_int = -1,
	scancode: c_int = 0,
	releaseAction: ?*const fn (Modifiers) void = null,
	pressAction: ?*const fn (Modifiers) void = null,
	repeatAction: ?*const fn (Modifiers) void = null,
	notifyRequirement: Requirement = .always,
	grabbedOnPress: bool = false,
	requiredModifiers: Modifiers = .{},

	pub const IsToggling = enum {
		never,
		no,
		yes,
	};

	pub const Modifiers = packed struct(u6) {
		shift: bool = false,
		control: bool = false,
		alt: bool = false,
		super: bool = false,
		capsLock: bool = false,
		numLock: bool = false,

		fn toInt(self: Modifiers) u6 {
			return @bitCast(self);
		}

		fn satisfiedBy(required: Modifiers, actual: Modifiers) bool {
			return (required.toInt() ^ actual.toInt()) & required.toInt() == 0;
		}

		fn isEmpty(self: Modifiers) bool {
			return self.toInt() == 0;
		}
	};
	const Requirement = enum {
		always,
		inGame,
		inMenu,

		fn met(self: Requirement, isGrabbed: bool) bool {
			switch (self) {
				.always => return true,
				.inGame => return isGrabbed,
				.inMenu => return !isGrabbed,
			}
		}
	};
	pub fn getGamepadName(self: Key) []const u8 {
		if (self.gamepadAxis != null) {
			const positive = self.gamepadAxis.?.positive;
			return switch (self.gamepadAxis.?.axis) {
				c.GLFW_GAMEPAD_AXIS_LEFT_X => if (positive) "Left stick right" else "Left stick left",
				c.GLFW_GAMEPAD_AXIS_RIGHT_X => if (positive) "Right stick right" else "Right stick left",
				c.GLFW_GAMEPAD_AXIS_LEFT_Y => if (positive) "Left stick down" else "Left stick up",
				c.GLFW_GAMEPAD_AXIS_RIGHT_Y => if (positive) "Right stick down" else "Right stick up",
				c.GLFW_GAMEPAD_AXIS_LEFT_TRIGGER => if (positive) "Left trigger" else "Left trigger (Negative)",
				c.GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER => if (positive) "Right trigger" else "Right trigger (Negative)",
				else => "(Invalid axis)",
			};
		} else {
			return switch (self.gamepadButton) {
				c.GLFW_GAMEPAD_BUTTON_A => "A",
				c.GLFW_GAMEPAD_BUTTON_B => "B",
				c.GLFW_GAMEPAD_BUTTON_X => "X",
				c.GLFW_GAMEPAD_BUTTON_Y => "Y",
				c.GLFW_GAMEPAD_BUTTON_BACK => "Back",
				c.GLFW_GAMEPAD_BUTTON_DPAD_DOWN => "Down",
				c.GLFW_GAMEPAD_BUTTON_DPAD_LEFT => "Left",
				c.GLFW_GAMEPAD_BUTTON_DPAD_RIGHT => "Right",
				c.GLFW_GAMEPAD_BUTTON_DPAD_UP => "Up",
				c.GLFW_GAMEPAD_BUTTON_GUIDE => "Guide",
				c.GLFW_GAMEPAD_BUTTON_LEFT_BUMPER => "Left bumper",
				c.GLFW_GAMEPAD_BUTTON_LEFT_THUMB => "Left stick press",
				c.GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER => "Right bumper",
				c.GLFW_GAMEPAD_BUTTON_RIGHT_THUMB => "Right stick press",
				c.GLFW_GAMEPAD_BUTTON_START => "Start",
				-1 => "(Unbound)",
				else => "(Unrecognized button)",
			};
		}
	}

	pub fn getName(self: Key) []const u8 {
		if (self.mouseButton == -1) {
			const cName = c.glfwGetKeyName(self.key, self.scancode);
			if (cName != null) return std.mem.span(cName);
			return switch (self.key) {
				c.GLFW_KEY_SPACE => "Space",
				c.GLFW_KEY_GRAVE_ACCENT => "Grave Accent",
				c.GLFW_KEY_ESCAPE => "Escape",
				c.GLFW_KEY_ENTER => "Enter",
				c.GLFW_KEY_TAB => "Tab",
				c.GLFW_KEY_BACKSPACE => "Backspace",
				c.GLFW_KEY_INSERT => "Insert",
				c.GLFW_KEY_DELETE => "Delete",
				c.GLFW_KEY_RIGHT => "Right",
				c.GLFW_KEY_LEFT => "Left",
				c.GLFW_KEY_DOWN => "Down",
				c.GLFW_KEY_UP => "Up",
				c.GLFW_KEY_PAGE_UP => "Page Up",
				c.GLFW_KEY_PAGE_DOWN => "Page Down",
				c.GLFW_KEY_HOME => "Home",
				c.GLFW_KEY_END => "End",
				c.GLFW_KEY_CAPS_LOCK => "Caps Lock",
				c.GLFW_KEY_SCROLL_LOCK => "Scroll Lock",
				c.GLFW_KEY_NUM_LOCK => "Num Lock",
				c.GLFW_KEY_PRINT_SCREEN => "Print Screen",
				c.GLFW_KEY_PAUSE => "Pause",
				c.GLFW_KEY_F1 => "F1",
				c.GLFW_KEY_F2 => "F2",
				c.GLFW_KEY_F3 => "F3",
				c.GLFW_KEY_F4 => "F4",
				c.GLFW_KEY_F5 => "F5",
				c.GLFW_KEY_F6 => "F6",
				c.GLFW_KEY_F7 => "F7",
				c.GLFW_KEY_F8 => "F8",
				c.GLFW_KEY_F9 => "F9",
				c.GLFW_KEY_F10 => "F10",
				c.GLFW_KEY_F11 => "F11",
				c.GLFW_KEY_F12 => "F12",
				c.GLFW_KEY_F13 => "F13",
				c.GLFW_KEY_F14 => "F14",
				c.GLFW_KEY_F15 => "F15",
				c.GLFW_KEY_F16 => "F16",
				c.GLFW_KEY_F17 => "F17",
				c.GLFW_KEY_F18 => "F18",
				c.GLFW_KEY_F19 => "F19",
				c.GLFW_KEY_F20 => "F20",
				c.GLFW_KEY_F21 => "F21",
				c.GLFW_KEY_F22 => "F22",
				c.GLFW_KEY_F23 => "F23",
				c.GLFW_KEY_F24 => "F24",
				c.GLFW_KEY_F25 => "F25",
				c.GLFW_KEY_KP_ENTER => "Keypad Enter",
				c.GLFW_KEY_LEFT_SHIFT => "Left Shift",
				c.GLFW_KEY_LEFT_CONTROL => "Left Control",
				c.GLFW_KEY_LEFT_ALT => "Left Alt",
				c.GLFW_KEY_LEFT_SUPER => "Left Super",
				c.GLFW_KEY_RIGHT_SHIFT => "Right Shift",
				c.GLFW_KEY_RIGHT_CONTROL => "Right Control",
				c.GLFW_KEY_RIGHT_ALT => "Right Alt",
				c.GLFW_KEY_RIGHT_SUPER => "Right Super",
				c.GLFW_KEY_MENU => "Menu",
				c.GLFW_KEY_UNKNOWN => "(Unbound)",
				else => "Unknown Key",
			};
		} else {
			return switch (self.mouseButton) {
				c.GLFW_MOUSE_BUTTON_LEFT => "Left Button",
				c.GLFW_MOUSE_BUTTON_MIDDLE => "Middle Button",
				c.GLFW_MOUSE_BUTTON_RIGHT => "Right Button",
				else => "Other Mouse Button",
			};
		}
	}

	fn setPressed(self: *Key, newPressed: bool, isGrabbed: bool, mods: Modifiers, textKeyPressedInTextField: bool) void {
		if (self.isToggling == .yes) {
			if (newPressed) {
				self.pressed = !self.pressed;
			}
			return;
		}
		if (newPressed != self.pressed) {
			self.pressed = newPressed;
			self.modsOnPress = mods;
			self.value = @floatFromInt(@intFromBool(newPressed));
			if (newPressed) {
				self.action(.press, isGrabbed, mods, textKeyPressedInTextField);
				self.action(.repeat, isGrabbed, mods, textKeyPressedInTextField);
			} else {
				self.action(.release, isGrabbed, mods, textKeyPressedInTextField);
			}
		}
	}

	fn action(self: *Key, typ: enum { press, release, repeat }, isGrabbed: bool, mods: Modifiers, textKeyPressedInTextField: bool) void {
		if (typ == .press) self.grabbedOnPress = isGrabbed;
		if (!self.notifyRequirement.met(self.grabbedOnPress)) return;
		if (!self.requiredModifiers.satisfiedBy(mods)) return;
		if (textKeyPressedInTextField and self.requiredModifiers.isEmpty()) return; // Don't send events for keys that are used in writing letters.
		switch (typ) {
			.press => if (self.pressAction) |a| a(mods),
			.release => if (self.releaseAction) |a| a(mods),
			.repeat => if (self.repeatAction) |a| a(mods),
		}
	}
};

pub const GLFWCallbacks = struct { // MARK: GLFWCallbacks
	fn errorCallback(errorCode: c_int, description: [*c]const u8) callconv(.c) void {
		std.log.err("GLFW Error({}): {s}", .{errorCode, description});
	}
	fn keyCallback(_: ?*c.GLFWwindow, glfw_key: c_int, scancode: c_int, action: c_int, _mods: c_int) callconv(.c) void {
		const mods: Key.Modifiers = @bitCast(@as(u6, @intCast(_mods)));
		const textKeyPressedInTextField = main.gui.selectedTextInput != null and c.glfwGetKeyName(glfw_key, scancode) != null;
		const isGrabbed = grabbed;
		if (action == c.GLFW_PRESS or action == c.GLFW_RELEASE) {
			for (&main.KeyBoard.keys) |*key| {
				if (glfw_key == key.key) {
					if (glfw_key != c.GLFW_KEY_UNKNOWN or scancode == key.scancode) {
						key.setPressed(action == c.GLFW_PRESS, isGrabbed, mods, textKeyPressedInTextField);
					}
				}
			}
			if (action == c.GLFW_PRESS) {
				if (nextKeypressListener) |listener| {
					listener(glfw_key, -1, scancode);
					nextKeypressListener = null;
				}
			}
		} else if (action == c.GLFW_REPEAT) {
			for (&main.KeyBoard.keys) |*key| {
				if (glfw_key == key.key) {
					if (glfw_key != c.GLFW_KEY_UNKNOWN or scancode == key.scancode) {
						key.action(.repeat, isGrabbed, mods, textKeyPressedInTextField);
					}
				}
			}
		}
	}
	fn charCallback(_: ?*c.GLFWwindow, codepoint: c_uint) callconv(.c) void {
		if (!grabbed) {
			main.gui.textCallbacks.char(@intCast(codepoint));
		}
	}

	pub fn framebufferSize(_: ?*c.GLFWwindow, newWidth: c_int, newHeight: c_int) callconv(.c) void {
		std.log.info("Framebuffer: {}, {}", .{newWidth, newHeight});
		width = @intCast(newWidth);
		height = @intCast(newHeight);
		main.renderer.updateViewport(width, height);
		main.gui.updateGuiScale();
		main.gui.updateWindowPositions();
	}
	// Mouse deltas are averaged over multiple frames using a circular buffer:
	const deltasLen: u2 = 3;
	var deltas: [deltasLen]Vec2f = @splat(.{0, 0});
	var deltaBufferPosition: u2 = 0;
	var currentPos: Vec2f = Vec2f{0, 0};
	var ignoreDataAfterRecentGrab: bool = true;
	fn cursorPosition(_: ?*c.GLFWwindow, x: f64, y: f64) callconv(.c) void {
		const newPos = Vec2f{
			@floatCast(x),
			@floatCast(y),
		};
		if (grabbed and !ignoreDataAfterRecentGrab) {
			var newDelta = (newPos - currentPos)*@as(Vec2f, @splat(main.settings.mouseSensitivity));
			if (settings.invertMouseY) {
				newDelta[1] *= -1;
			}
			deltas[deltaBufferPosition] += newDelta;
			var averagedDelta: Vec2f = Vec2f{0, 0};
			for (deltas) |delta| {
				averagedDelta += delta;
			}
			averagedDelta /= @splat(deltasLen);
			main.game.camera.moveRotation(averagedDelta[0]*0.0089, averagedDelta[1]*0.0089);
			deltaBufferPosition = (deltaBufferPosition + 1)%deltasLen;
			deltas[deltaBufferPosition] = Vec2f{0, 0};
		}
		ignoreDataAfterRecentGrab = false;
		currentPos = newPos;
		lastUsedMouse = true;
	}
	fn mouseButton(_: ?*c.GLFWwindow, button: c_int, action: c_int, _mods: c_int) callconv(.c) void {
		const mods: Key.Modifiers = @bitCast(@as(u6, @intCast(_mods)));
		const isGrabbed = grabbed;
		if (action == c.GLFW_PRESS or action == c.GLFW_RELEASE) {
			for (&main.KeyBoard.keys) |*key| {
				if (button == key.mouseButton) {
					key.setPressed(action == c.GLFW_PRESS, isGrabbed, mods, false);
				}
			}
			if (action == c.GLFW_PRESS) {
				if (nextKeypressListener) |listener| {
					listener(c.GLFW_KEY_UNKNOWN, button, 0);
					nextKeypressListener = null;
				}
			}
		}
	}
	fn scroll(_: ?*c.GLFWwindow, xOffset: f64, yOffset: f64) callconv(.c) void {
		_ = xOffset;
		scrollOffset += @floatCast(yOffset);
		scrollOffsetFraction += @floatCast(yOffset);
		scrollOffsetInteger += @intFromFloat(@round(scrollOffsetFraction));
		scrollOffsetFraction -= @round(scrollOffsetFraction);
	}
	fn glDebugOutput(source: c_uint, typ: c_uint, _: c_uint, severity: c_uint, length: c_int, message: [*c]const u8, _: ?*const anyopaque) callconv(.c) void {
		const sourceString: []const u8 = switch (source) {
			c.GL_DEBUG_SOURCE_API => "API",
			c.GL_DEBUG_SOURCE_APPLICATION => "Application",
			c.GL_DEBUG_SOURCE_OTHER => "Other",
			c.GL_DEBUG_SOURCE_SHADER_COMPILER => "Shader Compiler",
			c.GL_DEBUG_SOURCE_THIRD_PARTY => "Third Party",
			c.GL_DEBUG_SOURCE_WINDOW_SYSTEM => "Window System",
			else => "Unknown",
		};
		const typeString: []const u8 = switch (typ) {
			c.GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR => "deprecated behavior",
			c.GL_DEBUG_TYPE_ERROR => "error",
			c.GL_DEBUG_TYPE_MARKER => return,
			c.GL_DEBUG_TYPE_OTHER => return,
			c.GL_DEBUG_TYPE_PERFORMANCE => "performance",
			c.GL_DEBUG_TYPE_POP_GROUP => return,
			c.GL_DEBUG_TYPE_PORTABILITY => "portability",
			c.GL_DEBUG_TYPE_PUSH_GROUP => return,
			c.GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR => "undefined behavior",
			else => "unknown",
		};
		switch (severity) {
			c.GL_DEBUG_SEVERITY_HIGH => {
				std.log.err("OpenGL {s} {s}: {s}", .{sourceString, typeString, message[0..@intCast(length)]});
			},
			else => {
				std.log.warn("OpenGL {s} {s}: {s}", .{sourceString, typeString, message[0..@intCast(length)]});
			},
		}
	}
};

var nextKeypressListener: ?*const fn (c_int, c_int, c_int) void = null;
pub fn setNextKeypressListener(listener: ?*const fn (c_int, c_int, c_int) void) !void {
	if (nextKeypressListener != null) return error.AlreadyUsed;
	nextKeypressListener = listener;
}
var nextGamepadListener: ?*const fn (?GamepadAxis, c_int) void = null;
pub fn setNextGamepadListener(listener: ?*const fn (?GamepadAxis, c_int) void) !void {
	if (nextGamepadListener != null) return error.AlreadyUsed;
	nextGamepadListener = listener;
}

fn updateCursor() void {
	if (grabbed) {
		c.glfwSetInputMode(window, c.GLFW_CURSOR, c.GLFW_CURSOR_DISABLED);
		// Behavior seems much more intended without this line on MacOS.
		// Perhaps this is an inconsistency in GLFW due to its fresh XQuartz support?
		if (@import("builtin").target.os.tag != .macos) {
			if (c.glfwRawMouseMotionSupported() != 0)
				c.glfwSetInputMode(window, c.GLFW_RAW_MOUSE_MOTION, c.GLFW_TRUE);
		}
		GLFWCallbacks.ignoreDataAfterRecentGrab = true;
	} else {
		if (cursorVisible) {
			c.glfwSetInputMode(window, c.GLFW_CURSOR, c.GLFW_CURSOR_NORMAL);
		} else {
			c.glfwSetInputMode(window, c.GLFW_CURSOR, c.GLFW_CURSOR_HIDDEN);
		}
	}
}

fn releaseButtonsOnGrabChange(grab: bool) void {
	const state: Key.Requirement = if (grab) .inMenu else .inGame;
	for (&main.KeyBoard.keys) |*key| {
		if (key.notifyRequirement == state and key.pressed) {
			key.pressed = false;
			if (key.releaseAction) |rel| rel(key.modsOnPress);
			key.modsOnPress = .{};
		}
	}
}

pub fn setMouseGrabbed(grab: bool) void {
	if (grabbed != grab) {
		grabbed = grab;
		releaseButtonsOnGrabChange(grab);
		updateCursor();
	}
}

pub fn getMousePosition() Vec2f {
	return GLFWCallbacks.currentPos;
}

pub fn getWindowSize() Vec2f {
	return Vec2f{@floatFromInt(width), @floatFromInt(height)};
}

pub fn reloadSettings() void {
	c.glfwSwapInterval(@intFromBool(main.settings.vsync));
}

pub fn getClipboardString() []const u8 {
	return std.mem.span(c.glfwGetClipboardString(window) orelse @as([*c]const u8, ""));
}

pub fn setClipboardString(string: []const u8) void {
	const nullTerminatedString = main.stackAllocator.dupeZ(u8, string);
	defer main.stackAllocator.free(nullTerminatedString);
	c.glfwSetClipboardString(window, nullTerminatedString.ptr);
}

pub fn init() void { // MARK: init()
	_ = c.glfwSetErrorCallback(GLFWCallbacks.errorCallback);

	if (builtin.target.os.tag == .macos) {
		// NOTE(blackedout): Since the Vulkan loader is linked statically for Cubyz on macOS, libvulkan*.dylib is part of the Cubyz executable
		// and GLFW's default attempt to load it dynamically would fail. Instead, tell GLFW where it can find the loader functions directly.
		c.glfwInitVulkanLoader(c.vkGetInstanceProcAddr);

		c.glfwInitHint(c.GLFW_COCOA_CHDIR_RESOURCES, c.GLFW_FALSE);
	}

	if (c.glfwInit() == 0) {
		@panic("Failed to initialize GLFW");
	}

	if (c.glfwVulkanSupported() == c.GLFW_FALSE) {
		std.log.err("Vulkan is not supported. Please update your drivers if you want to keep playing Cubyz in the future.", .{});
	} else {
		c.glfwWindowHint(c.GLFW_CLIENT_API, c.GLFW_NO_API);
		c.glfwWindowHint(c.GLFW_VISIBLE, @intFromBool(main.settings.vulkanTestingWindow));
		vulkanWindow = c.glfwCreateWindow(width, height, "Cubyz", null, null) orelse @panic("Failed to create GLFW window");
		vulkan.init(vulkanWindow) catch |err| {
			std.log.err("Error while initializing Vulkan: {s}", .{@errorName(err)});
		};
	}

	c.glfwWindowHint(c.GLFW_CLIENT_API, c.GLFW_OPENGL_API);
	c.glfwWindowHint(c.GLFW_VISIBLE, c.GLFW_TRUE);
	c.glfwWindowHint(c.GLFW_OPENGL_DEBUG_CONTEXT, 1);
	c.glfwWindowHint(c.GLFW_CONTEXT_VERSION_MAJOR, 4);
	c.glfwWindowHint(c.GLFW_CONTEXT_VERSION_MINOR, 6);

	window = c.glfwCreateWindow(width, height, "Cubyz", null, null) orelse @panic("Failed to create GLFW window");
	iconBlock: {
		const image = main.graphics.Image.readUnflippedFromFile(main.stackAllocator, "assets/cubyz/logo.png") catch |err| {
			std.log.err("Error loading logo: {s}", .{@errorName(err)});
			break :iconBlock;
		};
		defer image.deinit(main.stackAllocator);
		const glfwImage: c.GLFWimage = .{
			.pixels = @ptrCast(image.imageData.ptr),
			.width = image.width,
			.height = image.height,
		};
		c.glfwSetWindowIcon(window, 1, &glfwImage);
	}

	_ = c.glfwSetKeyCallback(window, GLFWCallbacks.keyCallback);
	_ = c.glfwSetCharCallback(window, GLFWCallbacks.charCallback);
	_ = c.glfwSetFramebufferSizeCallback(window, GLFWCallbacks.framebufferSize);
	_ = c.glfwSetCursorPosCallback(window, GLFWCallbacks.cursorPosition);
	_ = c.glfwSetMouseButtonCallback(window, GLFWCallbacks.mouseButton);
	_ = c.glfwSetScrollCallback(window, GLFWCallbacks.scroll);

	c.glfwMakeContextCurrent(window);

	if (c.gladLoadGL(c.glfwGetProcAddress) == 0) {
		@panic("Failed to load OpenGL functions from GLAD");
	}
	reloadSettings();

	c.glEnable(c.GL_DEBUG_OUTPUT);
	c.glEnable(c.GL_DEBUG_OUTPUT_SYNCHRONOUS);
	c.glDebugMessageCallback(GLFWCallbacks.glDebugOutput, null);
	c.glDebugMessageControl(c.GL_DONT_CARE, c.GL_DONT_CARE, c.GL_DONT_CARE, 0, null, c.GL_TRUE);
	Gamepad.init();
}

pub fn deinit() void {
	Gamepad.deinit();
	c.glfwDestroyWindow(window);
	c.glfwDestroyWindow(vulkanWindow);
	vulkan.deinit();
	c.glfwTerminate();
}
var cursorVisible: bool = true;
fn setCursorVisible(visible: bool) void {
	if (cursorVisible != visible) {
		cursorVisible = visible;
		updateCursor();
	}
}

pub fn handleEvents(deltaTime: f64) void {
	scrollOffset = 0;
	scrollOffsetInteger = 0;
	c.glfwPollEvents();
	Gamepad.update(deltaTime);
}

var oldX: c_int = 0;
var oldY: c_int = 0;
var oldWidth: c_int = 0;
var oldHeight: c_int = 0;
pub fn toggleFullscreen(_: Key.Modifiers) void {
	isFullscreen = !isFullscreen;
	if (isFullscreen) {
		c.glfwGetWindowPos(window, &oldX, &oldY);
		c.glfwGetWindowSize(window, &oldWidth, &oldHeight);
		const monitor = c.glfwGetPrimaryMonitor();
		if (monitor == null) {
			isFullscreen = false;
			return;
		}
		const vidMode = c.glfwGetVideoMode(monitor).?;
		c.glfwSetWindowMonitor(window, monitor, 0, 0, vidMode[0].width, vidMode[0].height, c.GLFW_DONT_CARE);
	} else {
		c.glfwSetWindowMonitor(window, null, oldX, oldY, oldWidth, oldHeight, c.GLFW_DONT_CARE);
		c.glfwSetWindowAttrib(window, c.GLFW_DECORATED, c.GLFW_TRUE);
	}
}

```

`src/graphics/vulkan.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

const main = @import("main");
const c = main.Window.c;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const VkResultEnum = enum(c_int) { // MARK: VkResultEnum
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,
	VK_ERROR_UNKNOWN = -13,
	VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
	VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
	VK_ERROR_FRAGMENTATION = -1000161000,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
	VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
	VK_ERROR_NOT_PERMITTED = -1000174001,
	VK_ERROR_SURFACE_LOST_KHR = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
	VK_SUBOPTIMAL_KHR = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
	VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
	VK_ERROR_INVALID_SHADER_NV = -1000012000,
	VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
	VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
	VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
	VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
	VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
	VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
	VK_THREAD_IDLE_KHR = 1000268000,
	VK_THREAD_DONE_KHR = 1000268001,
	VK_OPERATION_DEFERRED_KHR = 1000268002,
	VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
	VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
	VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
	VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
	VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
	VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
	VK_RESULT_MAX_ENUM = 2147483647,
};

pub fn checkResult(result: c.VkResult) void {
	const resultEnum = std.meta.intToEnum(VkResultEnum, result) catch {
		std.log.err("Encountered a vulkan error with unknown error code {}", .{result});
		return;
	};
	if (resultEnum == .VK_SUCCESS) return;
	std.log.err("Encountered a vulkan error: {s}", .{@tagName(resultEnum)});
}

fn checkResultIfAvailable(result: anytype) void {
	if (@TypeOf(result) != void) {
		checkResult(result);
	}
}

fn allocEnumerationGeneric(function: anytype, allocator: NeverFailingAllocator, args: anytype) []@typeInfo(@typeInfo(@TypeOf(function)).@"fn".params[@typeInfo(@TypeOf(function)).@"fn".params.len - 1].type.?).pointer.child {
	const T = @typeInfo(@typeInfo(@TypeOf(function)).@"fn".params[@typeInfo(@TypeOf(function)).@"fn".params.len - 1].type.?).pointer.child;
	var count: u32 = 0;
	while (true) {
		checkResultIfAvailable(@call(.auto, function, args ++ .{&count, null}));
		const list = allocator.alloc(T, count);
		const result = @call(.auto, function, args ++ .{&count, list.ptr});
		if (@TypeOf(result) != void and result == c.VK_INCOMPLETE) {
			allocator.free(list);
			continue;
		}
		checkResultIfAvailable(result);

		if (count < list.len) return allocator.realloc(list, count);
		return list;
	}
}

// MARK: Enumerators

pub fn enumerateInstanceLayerProperties(allocator: NeverFailingAllocator) []c.VkLayerProperties {
	return allocEnumerationGeneric(c.vkEnumerateInstanceLayerProperties, allocator, .{});
}

pub fn enumerateInstanceExtensionProperties(allocator: NeverFailingAllocator, layerName: ?[*:0]const u8) []c.VkExtensionProperties {
	return allocEnumerationGeneric(c.vkEnumerateInstanceExtensionProperties, allocator, .{layerName});
}

pub fn enumeratePhysicalDevices(allocator: NeverFailingAllocator) []c.VkPhysicalDevice {
	return allocEnumerationGeneric(c.vkEnumeratePhysicalDevices, allocator, .{instance});
}

pub fn enumerateDeviceExtensionProperties(allocator: NeverFailingAllocator, dev: c.VkPhysicalDevice, layerName: ?[*:0]const u8) []c.VkExtensionProperties {
	return allocEnumerationGeneric(c.vkEnumerateDeviceExtensionProperties, allocator, .{dev, layerName});
}

pub fn getPhysicalDeviceQueueFamilyProperties(allocator: NeverFailingAllocator, dev: c.VkPhysicalDevice) []c.VkQueueFamilyProperties {
	return allocEnumerationGeneric(c.vkGetPhysicalDeviceQueueFamilyProperties, allocator, .{dev});
}

pub fn getPhysicalDeviceSurfaceFormatsKHR(allocator: NeverFailingAllocator, dev: c.VkPhysicalDevice) []c.VkSurfaceFormatKHR {
	return allocEnumerationGeneric(c.vkGetPhysicalDeviceSurfaceFormatsKHR, allocator, .{dev, surface});
}

pub fn getPhysicalDeviceSurfacePresentModesKHR(allocator: NeverFailingAllocator, dev: c.VkPhysicalDevice) []c.VkPresentModeKHR {
	return allocEnumerationGeneric(c.vkGetPhysicalDeviceSurfacePresentModesKHR, allocator, .{dev, surface});
}

// MARK: globals

var instance: c.VkInstance = undefined;
var surface: c.VkSurfaceKHR = undefined;
var physicalDevice: c.VkPhysicalDevice = undefined;
var device: c.VkDevice = undefined;
var graphicsQueue: c.VkQueue = undefined;
var presentQueue: c.VkQueue = undefined;

// MARK: init

pub fn init(window: ?*c.GLFWwindow) !void {
	// NOTE(blackedout): glad is currently not used on macOS
	if (builtin.target.os.tag != .macos) {
		if (c.gladLoaderLoadVulkan(null, null, null) == 0) {
			@panic("GLAD failed to load Vulkan functions");
		}
	}
	createInstance();
	checkResult(c.glfwCreateWindowSurface(instance, window, null, &surface));
	try pickPhysicalDevice();
	if (builtin.target.os.tag != .macos) {
		if (c.gladLoaderLoadVulkan(instance, physicalDevice, null) == 0) {
			@panic("GLAD failed to load Vulkan functions");
		}
	}
	createLogicalDevice();
	if (builtin.target.os.tag != .macos) {
		if (c.gladLoaderLoadVulkan(instance, physicalDevice, device) == 0) {
			@panic("GLAD failed to load Vulkan functions");
		}
	}
	SwapChain.init();
}

pub fn deinit() void {
	SwapChain.deinit();
	c.vkDestroyDevice(device, null);
	c.vkDestroySurfaceKHR(instance, surface, null);
	c.vkDestroyInstance(instance, null);
}

// MARK: Instance

const validationLayers: []const [*:0]const u8 = &.{
	"VK_LAYER_KHRONOS_validation",
};

fn checkValidationLayerSupport() bool {
	const availableLayers = enumerateInstanceLayerProperties(main.stackAllocator);
	defer main.stackAllocator.free(availableLayers);
	for (validationLayers) |layerName| continueOuter: {
		for (availableLayers) |layerProperties| {
			if (std.mem.eql(u8, std.mem.span(layerName), std.mem.span(@as([*:0]const u8, @ptrCast(&layerProperties.layerName))))) {
				break :continueOuter;
			}
		}
		std.log.warn("Couldn't find validation layer {s}", .{layerName});
		return false;
	}
	return true;
}

pub fn createInstance() void {
	const appInfo = c.VkApplicationInfo{
		.sType = c.VK_STRUCTURE_TYPE_APPLICATION_INFO,
		.pApplicationName = "Cubyz",
		.applicationVersion = c.VK_MAKE_VERSION(0, 0, 0),
		.pEngineName = "Cubyz",
		.engineVersion = c.VK_MAKE_VERSION(0, 0, 0),
		.apiVersion = c.VK_API_VERSION_1_0,
	};
	var glfwExtensionCount: u32 = 0;
	const glfwExtensions: [*c][*c]const u8 = c.glfwGetRequiredInstanceExtensions(&glfwExtensionCount);
	if (glfwExtensions == null) {
		@panic("glfwGetRequiredInstanceExtensions returned a null pointer. This may be a problem with your Vulkan driver.");
	}

	const availableExtensions = enumerateInstanceExtensionProperties(main.stackAllocator, null);
	defer main.stackAllocator.free(availableExtensions);
	std.log.debug("Availabe vulkan instance extensions:", .{});
	for (availableExtensions) |ext| {
		std.log.debug("\t{s}", .{@as([*:0]const u8, @ptrCast(&ext.extensionName))});
	}

	var createFlags: u32 = 0;
	var extensions = main.List([*c]const u8).init(main.stackAllocator);
	defer extensions.deinit();
	extensions.appendSlice(glfwExtensions[0..glfwExtensionCount]);

	if (builtin.target.os.tag == .macos) {
		// NOTE(blackedout): These constants may not be available for other targets because currently only macOS uses higher version headers
		extensions.appendSlice(&.{
			c.VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME,
			c.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
		});
		createFlags |= c.VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
	}

	const createInfo = c.VkInstanceCreateInfo{
		.sType = c.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
		.flags = createFlags,
		.pApplicationInfo = &appInfo,
		.enabledExtensionCount = @intCast(extensions.items.len),
		.ppEnabledExtensionNames = extensions.items.ptr,
		.ppEnabledLayerNames = validationLayers.ptr,
		.enabledLayerCount = if (checkValidationLayerSupport()) validationLayers.len else 0,
	};
	checkResult(c.vkCreateInstance(&createInfo, null, &instance));
}

// MARK: Physical Device

const deviceExtensions = blk: {
	const baseDeviceExtensions = [_][*:0]const u8{
		c.VK_KHR_SWAPCHAIN_EXTENSION_NAME,
	};
	if (builtin.target.os.tag == .macos) {
		break :blk baseDeviceExtensions ++ [_][*:0]const u8{c.VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME};
	}
	break :blk baseDeviceExtensions;
};

const deviceFeatures: c.VkPhysicalDeviceFeatures = .{
	.multiDrawIndirect = c.VK_TRUE,
	.dualSrcBlend = c.VK_TRUE,
};

const QueueFamilyIndidices = struct {
	graphicsFamily: ?u32 = null,
	presentFamily: ?u32 = null,

	fn isComplete(self: QueueFamilyIndidices) bool {
		return self.graphicsFamily != null and self.presentFamily != null;
	}
};

fn findQueueFamilies(dev: c.VkPhysicalDevice) QueueFamilyIndidices {
	var result: QueueFamilyIndidices = .{};
	const queueFamilies = getPhysicalDeviceQueueFamilyProperties(main.stackAllocator, dev);
	defer main.stackAllocator.free(queueFamilies);
	for (queueFamilies, 0..) |family, i| {
		if (family.queueFlags & c.VK_QUEUE_GRAPHICS_BIT != 0 and family.queueFlags & c.VK_QUEUE_COMPUTE_BIT != 0) {
			result.graphicsFamily = @intCast(i);
		}
		var presentSupport: u32 = 0;
		checkResult(c.vkGetPhysicalDeviceSurfaceSupportKHR(dev, @intCast(i), surface, &presentSupport));
		if (presentSupport != 0) {
			result.presentFamily = @intCast(i);
		}
	}
	return result;
}

fn checkDeviceExtensionSupport(dev: c.VkPhysicalDevice) bool {
	const availableExtension = enumerateDeviceExtensionProperties(main.stackAllocator, dev, null);
	defer main.stackAllocator.free(availableExtension);
	for (deviceExtensions) |requiredName| continueOuter: {
		for (availableExtension) |available| {
			if (std.mem.eql(u8, std.mem.span(requiredName), std.mem.span(@as([*:0]const u8, @ptrCast(&available.extensionName))))) {
				break :continueOuter;
			}
		}
		std.log.warn("Rejecting device because extension {s} was not found", .{requiredName});
		return false;
	}
	return true;
}

fn getDeviceScore(dev: c.VkPhysicalDevice) f32 {
	var properties: c.VkPhysicalDeviceProperties = undefined;
	c.vkGetPhysicalDeviceProperties(dev, &properties);
	var features: c.VkPhysicalDeviceFeatures = undefined;
	c.vkGetPhysicalDeviceFeatures(dev, &features);
	std.log.debug("Device: {s}", .{@as([*:0]const u8, @ptrCast(&properties.deviceName))});
	std.log.debug("Properties: {}", .{properties});
	std.log.debug("Features: {}", .{features});

	const baseScore: f32 = switch (properties.deviceType) {
		c.VK_PHYSICAL_DEVICE_TYPE_CPU => 1e-9,
		c.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU => 1e9,
		c.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU => 1,
		else => 0.1,
	};

	const availableExtension = enumerateDeviceExtensionProperties(main.stackAllocator, dev, null);
	defer main.stackAllocator.free(availableExtension);
	std.log.debug("Device extensions:", .{});
	for (availableExtension) |ext| {
		std.log.debug("\t{s}", .{@as([*:0]const u8, @ptrCast(&ext.extensionName))});
	}
	if (!findQueueFamilies(dev).isComplete() or !checkDeviceExtensionSupport(dev)) return 0;

	inline for (comptime std.meta.fieldNames(@TypeOf(deviceFeatures))) |name| {
		if (@field(deviceFeatures, name) == c.VK_TRUE and @field(features, name) == c.VK_FALSE) {
			std.log.warn("Rejecting device: {s} is not supported", .{name});
			return 0;
		}
	}

	return baseScore;
}

fn pickPhysicalDevice() !void {
	const devices = enumeratePhysicalDevices(main.stackAllocator);
	defer main.stackAllocator.free(devices);
	if (devices.len == 0) {
		return error.NoDevicesFound;
	}
	var bestScore: f32 = 0;
	for (devices) |dev| {
		const score = getDeviceScore(dev);
		if (score > bestScore) {
			bestScore = score;
			physicalDevice = dev;
		}
	}

	if (bestScore == 0) {
		return error.NoCapableDeviceFound;
	}

	var properties: c.VkPhysicalDeviceProperties = undefined;
	c.vkGetPhysicalDeviceProperties(physicalDevice, &properties);
	std.log.info("Selected device {s}", .{@as([*:0]const u8, @ptrCast(&properties.deviceName))});
}

// MARK: Logical Device

fn createLogicalDevice() void {
	const indices = findQueueFamilies(physicalDevice);
	var uniqueFamilies: std.AutoHashMapUnmanaged(u32, void) = .{};
	defer uniqueFamilies.deinit(main.stackAllocator.allocator);
	_ = uniqueFamilies.getOrPut(main.stackAllocator.allocator, indices.graphicsFamily.?) catch unreachable;
	_ = uniqueFamilies.getOrPut(main.stackAllocator.allocator, indices.presentFamily.?) catch unreachable;

	var queueCreateInfos = main.List(c.VkDeviceQueueCreateInfo).init(main.stackAllocator);
	defer queueCreateInfos.deinit();
	var iterator = uniqueFamilies.keyIterator();
	while (iterator.next()) |queueFamily| {
		queueCreateInfos.append(.{
			.sType = c.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
			.queueFamilyIndex = queueFamily.*,
			.queueCount = 1,
			.pQueuePriorities = &@as(f32, 1.0),
		});
	}

	const createInfo: c.VkDeviceCreateInfo = .{
		.sType = c.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
		.pQueueCreateInfos = queueCreateInfos.items.ptr,
		.queueCreateInfoCount = @intCast(queueCreateInfos.items.len),
		.pEnabledFeatures = &deviceFeatures,
		.ppEnabledLayerNames = validationLayers.ptr,
		.enabledLayerCount = if (checkValidationLayerSupport()) validationLayers.len else 0,
		.ppEnabledExtensionNames = &deviceExtensions,
		.enabledExtensionCount = @intCast(deviceExtensions.len),
	};
	checkResult(c.vkCreateDevice(physicalDevice, &createInfo, null, &device));
	c.vkGetDeviceQueue(device, indices.graphicsFamily.?, 0, &graphicsQueue);
	c.vkGetDeviceQueue(device, indices.presentFamily.?, 0, &presentQueue);
}

const SwapChain = struct { // MARK: SwapChain
	var swapChain: c.VkSwapchainKHR = null;
	var images: []c.VkImage = undefined;
	var imageViews: []c.VkImageView = undefined;
	var imageFormat: c.VkFormat = undefined;
	var extent: c.VkExtent2D = undefined;

	const SupportDetails = struct {
		capabilities: c.VkSurfaceCapabilitiesKHR,
		formats: []const c.VkSurfaceFormatKHR,
		presentModes: []const c.VkPresentModeKHR,

		fn init(allocator: NeverFailingAllocator, physical: c.VkPhysicalDevice) SupportDetails {
			var result: SupportDetails = undefined;
			checkResult(c.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical, surface, &result.capabilities));
			result.formats = getPhysicalDeviceSurfaceFormatsKHR(allocator, physical);
			result.presentModes = getPhysicalDeviceSurfacePresentModesKHR(allocator, physical);
			return result;
		}

		fn deinit(self: SupportDetails, allocator: NeverFailingAllocator) void {
			allocator.free(self.formats);
			allocator.free(self.presentModes);
		}

		fn chooseFormat(self: SupportDetails) c.VkSurfaceFormatKHR {
			for (self.formats) |format| {
				if (format.format == c.VK_FORMAT_B8G8R8A8_SRGB and format.colorSpace == c.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
					return format;
				}
			}
			@panic("Couldn't find swapchain format BGRA8 SRGB");
		}

		fn chooseSwapPresentMode(self: SupportDetails) c.VkPresentModeKHR {
			_ = self; // TODO: Use MAILBOX if vsync is disabled
			return c.VK_PRESENT_MODE_FIFO_KHR;
		}

		fn chooseSwapExtent(self: SupportDetails) c.VkExtent2D {
			if (self.capabilities.currentExtent.width != std.math.maxInt(u32)) {
				return self.capabilities.currentExtent;
			}
			var width: i32 = undefined;
			var height: i32 = undefined;
			c.glfwGetFramebufferSize(main.Window.vulkanWindow, &width, &height);
			return .{
				.width = @min(self.capabilities.maxImageExtent.width, @max(self.capabilities.minImageExtent.width, @max(0, width))),
				.height = @min(self.capabilities.maxImageExtent.height, @max(self.capabilities.minImageExtent.height, @max(0, height))),
			};
		}
	};

	fn createImageView(image: c.VkImage) c.VkImageView {
		const createInfo: c.VkImageViewCreateInfo = .{
			.sType = c.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
			.image = image,
			.viewType = c.VK_IMAGE_VIEW_TYPE_2D,
			.format = imageFormat,
			.components = .{
				.a = c.VK_COMPONENT_SWIZZLE_IDENTITY,
				.r = c.VK_COMPONENT_SWIZZLE_IDENTITY,
				.g = c.VK_COMPONENT_SWIZZLE_IDENTITY,
				.b = c.VK_COMPONENT_SWIZZLE_IDENTITY,
			},
			.subresourceRange = .{
				.aspectMask = c.VK_IMAGE_ASPECT_COLOR_BIT,
				.baseMipLevel = 0,
				.levelCount = 1,
				.baseArrayLayer = 0,
				.layerCount = 1,
			},
		};
		var result: c.VkImageView = undefined;
		checkResult(c.vkCreateImageView(device, &createInfo, null, &result));
		return result;
	}

	fn init() void {
		const support = SupportDetails.init(main.stackAllocator, physicalDevice);
		defer support.deinit(main.stackAllocator);

		const surfaceFormat = support.chooseFormat();
		imageFormat = surfaceFormat.format;
		const presentMode = support.chooseSwapPresentMode();
		extent = support.chooseSwapExtent();
		const imageCount = @min(support.capabilities.minImageCount + 1, support.capabilities.maxImageCount -% 1 +| 1);

		var createInfo: c.VkSwapchainCreateInfoKHR = .{
			.sType = c.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
			.surface = surface,
			.minImageCount = imageCount,
			.imageFormat = surfaceFormat.format,
			.imageColorSpace = surfaceFormat.colorSpace,
			.imageExtent = extent,
			.imageArrayLayers = 1,
			.imageUsage = c.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
			.preTransform = support.capabilities.currentTransform,
			.compositeAlpha = c.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
			.presentMode = presentMode,
			.clipped = c.VK_TRUE,
			.oldSwapchain = null,
		};
		const queueFamilies = findQueueFamilies(physicalDevice);
		if (queueFamilies.graphicsFamily.? != queueFamilies.presentFamily.?) {
			const queueFamilyIndices = [_]u32{queueFamilies.graphicsFamily.?, queueFamilies.presentFamily.?};
			createInfo.imageSharingMode = c.VK_SHARING_MODE_CONCURRENT;
			createInfo.queueFamilyIndexCount = @intCast(queueFamilyIndices.len);
			createInfo.pQueueFamilyIndices = &queueFamilyIndices;
		} else {
			createInfo.imageSharingMode = c.VK_SHARING_MODE_EXCLUSIVE;
		}

		checkResult(c.vkCreateSwapchainKHR(device, &createInfo, null, &swapChain));
		images = main.globalAllocator.alloc(c.VkImage, imageCount);
		var newImageCount = imageCount;
		checkResult(c.vkGetSwapchainImagesKHR(device, swapChain, &newImageCount, images.ptr));
		std.debug.assert(newImageCount == imageCount);

		imageViews = main.globalAllocator.alloc(c.VkImageView, imageCount);
		for (0..images.len) |i| {
			imageViews[i] = createImageView(images[i]);
		}
	}

	fn deinit() void {
		for (imageViews) |imageView| {
			c.vkDestroyImageView(device, imageView, null);
		}
		main.globalAllocator.free(imageViews);
		main.globalAllocator.free(images);
		c.vkDestroySwapchainKHR(device, swapChain, null);
	}
};

```

`src/gui/GuiWindow.zig`:

```zig
const std = @import("std");

const main = @import("main");
const utils = main.utils;
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const settings = main.settings;
const vec = main.vec;
const Vec2f = vec.Vec2f;
const Vec2i = vec.Vec2i;

const gui = @import("gui.zig");
const GuiComponent = gui.GuiComponent;

const GuiWindow = @This();

pub const AttachmentPoint = enum(u8) {
	lower = 0,
	middle = 1,
	upper = 2,
};

const OrientationLine = struct {
	pos: f32,
	start: f32,
	end: f32,
};

const RelativePosition = union(enum) {
	ratio: f32,
	attachedToFrame: struct {
		selfAttachmentPoint: AttachmentPoint,
		otherAttachmentPoint: AttachmentPoint,
	},
	relativeToWindow: struct {
		reference: *GuiWindow,
		ratio: f32,
	},
	attachedToWindow: struct {
		reference: *GuiWindow,
		selfAttachmentPoint: AttachmentPoint,
		otherAttachmentPoint: AttachmentPoint,
	},
};

const snapDistance = 3;
const titleBarHeight = 18;
const iconWidth = 18;

pos: Vec2f = undefined,
size: Vec2f = undefined,
contentSize: Vec2f,
scale: f32 = 1,
spacing: f32 = 0,
relativePosition: [2]RelativePosition = .{.{.ratio = 0.5}, .{.ratio = 0.5}},
id: []const u8 = undefined,
rootComponent: ?GuiComponent = null,
showTitleBar: bool = true,
hasBackground: bool = true,
hideIfMouseIsGrabbed: bool = true, // TODO: Allow the user to change this with a button, to for example leave the inventory open while playing.
closeIfMouseIsGrabbed: bool = false,
closeable: bool = true,
isHud: bool = false,

shiftClickableInventory: ?main.items.Inventory.ClientInventory = null,

/// Called every frame.
renderFn: *const fn () void = &defaultFunction,
/// Called every frame before rendering.
updateFn: *const fn () void = &defaultFunction,
/// Called every frame for the currently selected window.
updateSelectedFn: *const fn () void = &defaultFunction,
/// Called every frame for the currently hovered window.
updateHoveredFn: *const fn () void = &defaultFunction,

onOpenFn: *const fn () void = &defaultFunction,

onCloseFn: *const fn () void = &defaultFunction,

var grabbedWindow: *const GuiWindow = undefined;
var windowMoving: bool = false;
var grabPosition: ?Vec2f = null;
var selfPositionWhenGrabbed: Vec2f = undefined;

var backgroundTexture: Texture = undefined;
var titleTexture: Texture = undefined;
var closeTexture: Texture = undefined;
var zoomInTexture: Texture = undefined;
var zoomOutTexture: Texture = undefined;
var pipeline: graphics.Pipeline = undefined;
var windowUniforms: struct {
	screen: c_int,
	start: c_int,
	size: c_int,
	color: c_int,
	scale: c_int,
} = undefined;
pub var borderPipeline: graphics.Pipeline = undefined;
pub var borderUniforms: struct {
	screen: c_int,
	start: c_int,
	size: c_int,
	color: c_int,
	scale: c_int,
	effectLength: c_int,
} = undefined;

pub fn __init() void {
	pipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/ui/button.vert",
		"assets/cubyz/shaders/ui/button.frag",
		"",
		&windowUniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.alphaBlending}},
	);
	borderPipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/ui/window_border.vert",
		"assets/cubyz/shaders/ui/window_border.frag",
		"",
		&borderUniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.alphaBlending}},
	);

	backgroundTexture = Texture.initFromFile("assets/cubyz/ui/window_background.png");
	titleTexture = Texture.initFromFile("assets/cubyz/ui/window_title.png");
	closeTexture = Texture.initFromFile("assets/cubyz/ui/window_close.png");
	zoomInTexture = Texture.initFromFile("assets/cubyz/ui/window_zoom_in.png");
	zoomOutTexture = Texture.initFromFile("assets/cubyz/ui/window_zoom_out.png");
}

pub fn __deinit() void {
	pipeline.deinit();
	backgroundTexture.deinit();
	titleTexture.deinit();
}

pub fn defaultFunction() void {}

pub fn mainButtonPressed(self: *const GuiWindow, mousePosition: Vec2f) void {
	const scaledMousePos = (mousePosition - self.pos)/@as(Vec2f, @splat(self.scale));
	const btnPos = self.getButtonPositions();
	const zoomInPos = btnPos[2]/self.scale;
	if (scaledMousePos[1] < titleBarHeight and (self.showTitleBar or gui.reorderWindows)) {
		grabbedWindow = self;
		grabPosition = mousePosition;
		selfPositionWhenGrabbed = self.pos;
		windowMoving = scaledMousePos[0] <= zoomInPos;
	} else {
		if (self.rootComponent) |*component| {
			if (GuiComponent.contains(component.pos(), component.size(), scaledMousePos)) {
				component.mainButtonPressed(scaledMousePos);
			}
		}
	}
}

pub fn getButtonPositions(self: *const GuiWindow) [3]f32 {
	const closePos = if (self.closeable) self.size[0] - iconWidth*self.scale else self.size[0];
	const zoomOutPos = closePos - iconWidth*self.scale;
	const zoomInPos = zoomOutPos - iconWidth*self.scale;
	return .{closePos, zoomOutPos, zoomInPos};
}

pub fn mainButtonReleased(self: *GuiWindow, mousePosition: Vec2f) void {
	if (grabPosition != null and grabbedWindow == self and (self.showTitleBar or gui.reorderWindows)) {
		const btnPos = self.getButtonPositions();
		const closePos = btnPos[0];
		const zoomOutPos = btnPos[1];
		const zoomInPos = btnPos[2];
		const mousePositionRelative = mousePosition - self.pos;
		const grabPositionRelative = if (grabPosition) |gp| gp - self.pos else @as(@Vector(2, f32), .{0.0, 0.0});

		if (mousePositionRelative[1] >= 0 and mousePositionRelative[1] <= titleBarHeight) {
			if (mousePositionRelative[0] > zoomInPos and mousePositionRelative[0] <= zoomOutPos and grabPositionRelative[0] > zoomInPos and grabPositionRelative[0] <= zoomOutPos) {
				// Zoom in
				if (self.scale >= 1) {
					self.scale += 0.5;
				} else {
					self.scale += 0.25;
				}
				gui.updateWindowPositions();
				gui.save();
			}
			if (mousePositionRelative[0] > zoomOutPos and mousePositionRelative[0] <= closePos and grabPositionRelative[0] > zoomOutPos and grabPositionRelative[0] <= closePos) {
				// Zoom out
				if (self.scale > 1) {
					self.scale -= 0.5;
				} else {
					self.scale -= 0.25;
				}
				self.scale = @max(self.scale, 0.25);
				gui.updateWindowPositions();
				gui.save();
			}
			if (mousePositionRelative[0] > closePos and grabPositionRelative[0] > closePos) {
				// Close
				if (self.closeable) gui.closeWindowFromRef(self);
			}
		}
	}
	grabPosition = null;
	grabbedWindow = undefined;
	if (self.rootComponent) |*component| {
		component.mainButtonReleased((mousePosition - self.pos)/@as(Vec2f, @splat(self.scale)));
	}
}

fn detectCycles(self: *GuiWindow, other: *GuiWindow) bool {
	for (0..2) |xy| {
		var win: ?*GuiWindow = other;
		while (win) |_win| {
			if (win == self) return true;
			switch (_win.relativePosition[xy]) {
				.ratio => {
					win = null;
				},
				.attachedToFrame => {
					win = null;
				},
				.relativeToWindow => |relativeToWindow| {
					win = relativeToWindow.reference;
				},
				.attachedToWindow => |attachedToWindow| {
					win = attachedToWindow.reference;
				},
			}
		}
	}
	return false;
}

fn snapToOtherWindow(self: *GuiWindow) void {
	inline for (&self.relativePosition, 0..) |*relPos, i| {
		var minDist: f32 = snapDistance;
		var minWindow: ?*GuiWindow = null;
		var selfAttachment: AttachmentPoint = undefined;
		var otherAttachment: AttachmentPoint = undefined;
		for (gui.openWindows.items) |other| {
			// Check if they touch:
			const start = @max(self.pos[i ^ 1], other.pos[i ^ 1]);
			const end = @min(self.pos[i ^ 1] + self.size[i ^ 1], other.pos[i ^ 1] + other.size[i ^ 1]);
			if (start >= end) continue;
			if (detectCycles(self, other)) continue;

			const dist1 = @abs(self.pos[i] - other.pos[i] - other.size[i]);
			if (dist1 < minDist) {
				minDist = dist1;
				minWindow = other;
				selfAttachment = .lower;
				otherAttachment = .upper;
			}
			const dist2 = @abs(self.pos[i] + self.size[i] - other.pos[i]);
			if (dist2 < minDist) {
				minDist = dist2;
				minWindow = other;
				selfAttachment = .upper;
				otherAttachment = .lower;
			}
		}
		if (minWindow) |other| {
			relPos.* = .{.attachedToWindow = .{.reference = other, .selfAttachmentPoint = selfAttachment, .otherAttachmentPoint = otherAttachment}};
		}
	}
}

fn positionRelativeToFrame(self: *GuiWindow) void {
	const windowSize = main.Window.getWindowSize()/@as(Vec2f, @splat(gui.scale));
	inline for (&self.relativePosition, 0..) |*relPos, i| {
		// Snap to the center:
		if (@abs(self.pos[i] + self.size[i] - windowSize[i]/2) <= snapDistance) {
			relPos.* = .{.attachedToFrame = .{
				.selfAttachmentPoint = .upper,
				.otherAttachmentPoint = .middle,
			}};
		} else if (@abs(self.pos[i] + self.size[i]/2 - windowSize[i]/2) <= snapDistance) {
			relPos.* = .{.attachedToFrame = .{
				.selfAttachmentPoint = .middle,
				.otherAttachmentPoint = .middle,
			}};
		} else if (@abs(self.pos[i] - windowSize[i]/2) <= snapDistance) {
			relPos.* = .{.attachedToFrame = .{
				.selfAttachmentPoint = .lower,
				.otherAttachmentPoint = .middle,
			}};
		} else {
			var ratio: f32 = (self.pos[i] + self.size[i]/2)/windowSize[i];
			if (self.pos[i] <= 0) {
				ratio = 0;
			} else if (self.pos[i] + self.size[i] >= windowSize[i]) {
				ratio = 1;
			}
			relPos.* = .{.ratio = ratio};
		}
	}
}

fn positionRelativeToConnectedWindow(self: *GuiWindow, other: *GuiWindow, comptime i: usize) void {
	const otherSize = other.size;
	const relPos = &self.relativePosition[i];
	// Snap to the center:
	if (@abs(self.pos[i] + self.size[i] - (other.pos[i] + otherSize[i]/2)) <= snapDistance) {
		relPos.* = .{.attachedToWindow = .{
			.reference = other,
			.selfAttachmentPoint = .upper,
			.otherAttachmentPoint = .middle,
		}};
	} else if (@abs(self.pos[i] + self.size[i]/2 - (other.pos[i] + otherSize[i]/2)) <= snapDistance) {
		relPos.* = .{.attachedToWindow = .{
			.reference = other,
			.selfAttachmentPoint = .middle,
			.otherAttachmentPoint = .middle,
		}};
	} else if (@abs(self.pos[i] - (other.pos[i] + otherSize[i]/2)) <= snapDistance) {
		relPos.* = .{.attachedToWindow = .{
			.reference = other,
			.selfAttachmentPoint = .lower,
			.otherAttachmentPoint = .middle,
		}};
		// Snap to the edges:
	} else if (@abs(self.pos[i] - other.pos[i]) <= snapDistance) {
		relPos.* = .{.attachedToWindow = .{
			.reference = other,
			.selfAttachmentPoint = .lower,
			.otherAttachmentPoint = .lower,
		}};
	} else if (@abs(self.pos[i] + self.size[i] - (other.pos[i] + otherSize[i])) <= snapDistance) {
		relPos.* = .{.attachedToWindow = .{
			.reference = other,
			.selfAttachmentPoint = .upper,
			.otherAttachmentPoint = .upper,
		}};
	} else {
		relPos.* = .{.relativeToWindow = .{
			.reference = other,
			.ratio = (self.pos[i] + self.size[i]/2 - other.pos[i])/otherSize[i],
		}};
	}
}

pub fn update(self: *GuiWindow) void {
	self.updateFn();
}

pub fn updateSelected(self: *GuiWindow, mousePosition: Vec2f) void {
	self.updateSelectedFn();
	const windowSize = main.Window.getWindowSize()/@as(Vec2f, @splat(gui.scale));
	if (self == grabbedWindow and windowMoving and (gui.reorderWindows or self.showTitleBar)) if (grabPosition) |_grabPosition| {
		self.relativePosition[0] = .{.ratio = undefined};
		self.relativePosition[1] = .{.ratio = undefined};
		self.pos = (mousePosition - _grabPosition) + selfPositionWhenGrabbed;
		self.snapToOtherWindow();
		if (self.relativePosition[0] == .ratio and self.relativePosition[1] == .ratio) {
			self.positionRelativeToFrame();
		} else if (self.relativePosition[0] == .ratio) {
			self.positionRelativeToConnectedWindow(self.relativePosition[1].attachedToWindow.reference, 0);
		} else if (self.relativePosition[1] == .ratio) {
			self.positionRelativeToConnectedWindow(self.relativePosition[0].attachedToWindow.reference, 1);
		}
		self.pos = @max(self.pos, Vec2f{0, 0});
		self.pos = @min(self.pos, windowSize - self.size);
		gui.updateWindowPositions();
		gui.save();
	};
	if (self.rootComponent) |*component| {
		component.updateSelected();
	}
}

pub fn updateHovered(self: *GuiWindow, mousePosition: Vec2f) void {
	self.updateHoveredFn();
	if (self.rootComponent) |component| {
		if (GuiComponent.contains(component.pos(), component.size(), (mousePosition - self.pos)/@as(Vec2f, @splat(self.scale)))) {
			component.updateHovered((mousePosition - self.pos)/@as(Vec2f, @splat(self.scale)));
		}
	}
}
pub fn getMinWindowWidth(self: *GuiWindow) f32 {
	return iconWidth*@as(f32, (if (self.closeable) 4 else 3));
}
pub fn updateWindowPosition(self: *GuiWindow) void {
	const minSize = self.getMinWindowWidth();
	if (self.contentSize[0] < minSize) {
		std.log.err("Window '{s}' width is too small: {d}px before scaling", .{self.id, self.contentSize[0]});
		self.contentSize[0] = minSize;
		std.log.debug("Resized width to {d}px unscaled", .{self.contentSize[0]});
	}
	self.size = self.contentSize*@as(Vec2f, @splat(self.scale));
	const windowSize = main.Window.getWindowSize()/@as(Vec2f, @splat(gui.scale));
	inline for (self.relativePosition, 0..) |relPos, i| {
		switch (relPos) {
			.ratio => |ratio| {
				self.pos[i] = windowSize[i]*ratio - self.size[i]/2;
			},
			.attachedToFrame => |attachedToFrame| {
				const otherPos = switch (attachedToFrame.otherAttachmentPoint) {
					.lower => 0,
					.middle => 0.5*windowSize[i],
					.upper => windowSize[i],
				};
				self.pos[i] = switch (attachedToFrame.selfAttachmentPoint) {
					.lower => otherPos,
					.middle => otherPos - 0.5*self.size[i],
					.upper => otherPos - self.size[i],
				};
			},
			.attachedToWindow => |attachedToWindow| {
				const other = attachedToWindow.reference;
				const otherPos = switch (attachedToWindow.otherAttachmentPoint) {
					.lower => other.pos[i],
					.middle => other.pos[i] + 0.5*other.size[i],
					.upper => other.pos[i] + other.size[i],
				};
				self.pos[i] = switch (attachedToWindow.selfAttachmentPoint) {
					.lower => otherPos,
					.middle => otherPos - 0.5*self.size[i],
					.upper => otherPos - self.size[i],
				};
			},
			.relativeToWindow => |relativeToWindow| {
				const other = relativeToWindow.reference;
				const otherSize = other.size[i];
				const otherPos = other.pos[i];
				self.pos[i] = otherPos + relativeToWindow.ratio*otherSize - self.size[i]/2;
			},
		}
	}
	self.pos = @floor(self.pos); // Prevent floating point inaccuracies (these can happen when resizing the window) from causing weird window positioning issues.
	self.pos[0] = @max(self.pos[0], 0);
	self.pos[1] = @min(self.pos[1], windowSize[1] - self.size[1]);
	self.pos[0] = @min(self.pos[0], windowSize[0] - self.size[0]);
	self.pos[1] = @max(self.pos[1], 0);
}

fn drawOrientationLines(self: *const GuiWindow) void {
	draw.setColor(0x80000000);
	const windowSize = main.Window.getWindowSize()/@as(Vec2f, @splat(gui.scale));
	inline for (self.relativePosition, 0..) |relPos, i| _continue: {
		switch (relPos) {
			.ratio, .relativeToWindow => {
				break :_continue;
			},
			.attachedToFrame => |attachedToFrame| {
				const pos = switch (attachedToFrame.otherAttachmentPoint) {
					.lower => 0,
					.middle => 0.5*windowSize[i],
					.upper => windowSize[i],
				};
				if (i == 0) {
					draw.line(.{pos, 0}, .{pos, windowSize[i ^ 1]});
				} else {
					draw.line(.{0, pos}, .{windowSize[i ^ 1], pos});
				}
			},
			.attachedToWindow => |attachedToWindow| {
				const other = attachedToWindow.reference;
				const otherSize = other.size;
				const pos = switch (attachedToWindow.otherAttachmentPoint) {
					.lower => other.pos[i],
					.middle => other.pos[i] + 0.5*otherSize[i],
					.upper => other.pos[i] + otherSize[i],
				};
				const start = @min(self.pos[i ^ 1], other.pos[i ^ 1]);
				const end = @max(self.pos[i ^ 1] + self.size[i ^ 1], other.pos[i ^ 1] + otherSize[i ^ 1]);
				if (i == 0) {
					draw.line(.{pos, start}, .{pos, end});
				} else {
					draw.line(.{start, pos}, .{end, pos});
				}
			},
		}
	}
}

pub fn drawIcons(self: *const GuiWindow) void {
	draw.setColor(0xffffffff);
	var x = self.size[0]/self.scale;
	if (self.closeable) {
		x -= iconWidth;
		closeTexture.render(.{x, 0}, .{iconWidth, titleBarHeight});
	}
	x -= iconWidth;
	zoomOutTexture.render(.{x, 0}, .{iconWidth, titleBarHeight});
	x -= iconWidth;
	zoomInTexture.render(.{x, 0}, .{iconWidth, titleBarHeight});
}

pub fn render(self: *const GuiWindow, mousePosition: Vec2f) void {
	if (self.hideIfMouseIsGrabbed and main.Window.grabbed) return;
	const oldTranslation = draw.setTranslation(self.pos);
	const oldScale = draw.setScale(self.scale);
	if (self.hasBackground) {
		draw.setColor(0xff000000);
		pipeline.bind(draw.getScissor());
		backgroundTexture.bindTo(0);
		draw.customShadedRect(windowUniforms, .{0, 0}, self.size/@as(Vec2f, @splat(self.scale)));
	}
	self.renderFn();
	if (self.rootComponent) |*component| {
		component.render((mousePosition - self.pos)/@as(Vec2f, @splat(self.scale)));
	}
	if (self.showTitleBar or gui.reorderWindows) {
		pipeline.bind(draw.getScissor());
		titleTexture.bindTo(0);
		draw.setColor(0xff000000);
		draw.customShadedRect(windowUniforms, .{0, 0}, .{self.size[0]/self.scale, titleBarHeight});
		self.drawIcons();
	}
	if (self.hasBackground or (!main.Window.grabbed and gui.reorderWindows)) {
		draw.setColor(0xff2d2d2d);
		draw.rectBorder(.{-2, -2}, self.size/@as(Vec2f, @splat(self.scale)) + Vec2f{4, 4}, 2.0);
	}
	draw.restoreTranslation(oldTranslation);
	draw.restoreScale(oldScale);
	if (self == grabbedWindow and windowMoving and (gui.reorderWindows or self.showTitleBar) and grabPosition != null) {
		self.drawOrientationLines();
	}
}

```

`src/gui/components/Button.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const Texture = graphics.Texture;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const Icon = GuiComponent.Icon;
const Label = GuiComponent.Label;

const Button = @This();

const border: f32 = 3;
const fontSize: f32 = 16;

const Textures = struct {
	texture: Texture,
	outlineTexture: Texture,
	outlineTextureSize: Vec2f,

	pub fn init(basePath: []const u8) Textures {
		var self: Textures = undefined;
		const buttonPath = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}.png", .{basePath}) catch unreachable;
		defer main.stackAllocator.free(buttonPath);
		self.texture = Texture.initFromFile(buttonPath);
		const outlinePath = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}_outline.png", .{basePath}) catch unreachable;
		defer main.stackAllocator.free(outlinePath);
		self.outlineTexture = Texture.initFromFile(outlinePath);
		self.outlineTextureSize = @floatFromInt(self.outlineTexture.size());
		return self;
	}

	pub fn deinit(self: Textures) void {
		self.texture.deinit();
		self.outlineTexture.deinit();
	}
};
var normalTextures: Textures = undefined;
var hoveredTextures: Textures = undefined;
var pressedTextures: Textures = undefined;
pub var pipeline: graphics.Pipeline = undefined;
pub var buttonUniforms: struct {
	screen: c_int,
	start: c_int,
	size: c_int,
	color: c_int,
	scale: c_int,
} = undefined;

pos: Vec2f,
size: Vec2f,
pressed: bool = false,
hovered: bool = false,
onAction: main.callbacks.SimpleCallback,
child: GuiComponent,

pub fn __init() void {
	pipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/ui/button.vert",
		"assets/cubyz/shaders/ui/button.frag",
		"",
		&buttonUniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.alphaBlending}},
	);
	normalTextures = Textures.init("assets/cubyz/ui/button");
	hoveredTextures = Textures.init("assets/cubyz/ui/button_hovered");
	pressedTextures = Textures.init("assets/cubyz/ui/button_pressed");
}

pub fn __deinit() void {
	pipeline.deinit();
	normalTextures.deinit();
	hoveredTextures.deinit();
	pressedTextures.deinit();
}

fn defaultOnAction(_: usize) void {}

pub fn initText(pos: Vec2f, width: f32, text: []const u8, onAction: main.callbacks.SimpleCallback) *Button {
	const label = Label.init(undefined, width - 3*border, text, .center);
	const self = main.globalAllocator.create(Button);
	self.* = Button{
		.pos = pos,
		.size = Vec2f{width, label.size[1] + 3*border},
		.onAction = onAction,
		.child = label.toComponent(),
	};
	return self;
}

pub fn initIcon(pos: Vec2f, iconSize: Vec2f, iconTexture: Texture, hasShadow: bool, onAction: main.callbacks.SimpleCallback) *Button {
	const icon = Icon.init(undefined, iconSize, iconTexture, hasShadow);
	const self = main.globalAllocator.create(Button);
	self.* = Button{
		.pos = pos,
		.size = icon.size + @as(Vec2f, @splat(3*border)),
		.onAction = onAction,
		.child = icon.toComponent(),
	};
	return self;
}

pub fn deinit(self: *const Button) void {
	self.child.deinit();
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *Button) GuiComponent {
	return .{.button = self};
}

pub fn updateHovered(self: *Button, _: Vec2f) void {
	self.hovered = true;
}

pub fn mainButtonPressed(self: *Button, _: Vec2f) void {
	self.pressed = true;
}

pub fn mainButtonReleased(self: *Button, mousePosition: Vec2f) void {
	if (self.pressed) {
		self.pressed = false;
		if (GuiComponent.contains(self.pos, self.size, mousePosition)) {
			self.onAction.run();
		}
	}
}

pub fn render(self: *Button, mousePosition: Vec2f) void {
	const textures = if (self.pressed)
		pressedTextures
	else if (GuiComponent.contains(self.pos, self.size, mousePosition) and self.hovered)
		hoveredTextures
	else
		normalTextures;
	draw.setColor(0xff000000);
	textures.texture.bindTo(0);
	pipeline.bind(draw.getScissor());
	self.hovered = false;
	draw.customShadedRect(buttonUniforms, self.pos + Vec2f{2, 2}, self.size - Vec2f{4, 4});
	{ // Draw the outline using the 9-slice texture.
		const cornerSize = (textures.outlineTextureSize - Vec2f{1, 1});
		const cornerSizeUV = (textures.outlineTextureSize - Vec2f{1, 1})/Vec2f{2, 2}/textures.outlineTextureSize;
		const lowerTexture = (textures.outlineTextureSize - Vec2f{1, 1})/Vec2f{2, 2}/textures.outlineTextureSize;
		const upperTexture = (textures.outlineTextureSize + Vec2f{1, 1})/Vec2f{2, 2}/textures.outlineTextureSize;
		textures.outlineTexture.bindTo(0);
		draw.setColor(0xffffffff);
		// Corners:
		graphics.draw.boundSubImage(self.pos + Vec2f{0, 0}, cornerSize, .{0, 0}, cornerSizeUV);
		graphics.draw.boundSubImage(self.pos + Vec2f{self.size[0], 0} - Vec2f{cornerSize[0], 0}, cornerSize, .{upperTexture[0], 0}, cornerSizeUV);
		graphics.draw.boundSubImage(self.pos + Vec2f{0, self.size[1]} - Vec2f{0, cornerSize[1]}, cornerSize, .{0, upperTexture[1]}, cornerSizeUV);
		graphics.draw.boundSubImage(self.pos + self.size - cornerSize, cornerSize, upperTexture, cornerSizeUV);
		// Edges:
		graphics.draw.boundSubImage(self.pos + Vec2f{cornerSize[0], 0}, Vec2f{self.size[0] - 2*cornerSize[0], cornerSize[1]}, .{lowerTexture[0], 0}, .{upperTexture[0] - lowerTexture[0], cornerSizeUV[1]});
		graphics.draw.boundSubImage(self.pos + Vec2f{cornerSize[0], self.size[1] - cornerSize[1]}, Vec2f{self.size[0] - 2*cornerSize[0], cornerSize[1]}, .{lowerTexture[0], upperTexture[1]}, .{upperTexture[0] - lowerTexture[0], cornerSizeUV[1]});
		graphics.draw.boundSubImage(self.pos + Vec2f{0, cornerSize[1]}, Vec2f{cornerSize[0], self.size[1] - 2*cornerSize[1]}, .{0, lowerTexture[1]}, .{cornerSizeUV[0], upperTexture[1] - lowerTexture[1]});
		graphics.draw.boundSubImage(self.pos + Vec2f{self.size[0] - cornerSize[0], cornerSize[1]}, Vec2f{cornerSize[0], self.size[1] - 2*cornerSize[1]}, .{upperTexture[0], lowerTexture[1]}, .{cornerSizeUV[0], upperTexture[1] - lowerTexture[1]});
	}
	const textPos = self.pos + self.size/@as(Vec2f, @splat(2.0)) - self.child.size()/@as(Vec2f, @splat(2.0));
	self.child.mutPos().* = textPos;
	self.child.render(mousePosition - self.pos);
}

```

`src/gui/components/CheckBox.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const Texture = graphics.Texture;
const random = main.random;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const Button = GuiComponent.Button;
const Label = GuiComponent.Label;

const CheckBox = @This();

const border: f32 = 3;
const fontSize: f32 = 16;
const boxSize: f32 = 16;

var textureCheckedNormal: Texture = undefined;
var textureCheckedHovered: Texture = undefined;
var textureCheckedPressed: Texture = undefined;
var textureEmptyNormal: Texture = undefined;
var textureEmptyHovered: Texture = undefined;
var textureEmptyPressed: Texture = undefined;

pos: Vec2f,
size: Vec2f,
state: bool = false,
pressed: bool = false,
hovered: bool = false,
onAction: *const fn (bool) void,
label: *Label,

pub fn __init() void {
	textureCheckedNormal = Texture.initFromFile("assets/cubyz/ui/checked_box.png");
	textureCheckedHovered = Texture.initFromFile("assets/cubyz/ui/checked_box_hovered.png");
	textureCheckedPressed = Texture.initFromFile("assets/cubyz/ui/checked_box_pressed.png");
	textureEmptyNormal = Texture.initFromFile("assets/cubyz/ui/box.png");
	textureEmptyHovered = Texture.initFromFile("assets/cubyz/ui/box_hovered.png");
	textureEmptyPressed = Texture.initFromFile("assets/cubyz/ui/box_pressed.png");
}

pub fn __deinit() void {
	textureCheckedNormal.deinit();
	textureCheckedHovered.deinit();
	textureCheckedPressed.deinit();
	textureEmptyNormal.deinit();
	textureEmptyHovered.deinit();
	textureEmptyPressed.deinit();
}

pub fn init(pos: Vec2f, width: f32, text: []const u8, initialValue: bool, onAction: *const fn (bool) void) *CheckBox {
	const label = Label.init(undefined, width - 3*border - boxSize, text, .left);
	const self = main.globalAllocator.create(CheckBox);
	self.* = CheckBox{
		.pos = pos,
		.size = Vec2f{@max(width, label.size[0] + 3*border + boxSize), label.size[1] + 3*border},
		.state = initialValue,
		.onAction = onAction,
		.label = label,
	};
	return self;
}

pub fn deinit(self: *const CheckBox) void {
	self.label.deinit();
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *CheckBox) GuiComponent {
	return .{.checkBox = self};
}

pub fn updateHovered(self: *CheckBox, _: Vec2f) void {
	self.hovered = true;
}

pub fn mainButtonPressed(self: *CheckBox, _: Vec2f) void {
	self.pressed = true;
}

pub fn mainButtonReleased(self: *CheckBox, mousePosition: Vec2f) void {
	if (self.pressed) {
		self.pressed = false;
		if (GuiComponent.contains(self.pos, self.size, mousePosition)) {
			self.state = !self.state;
			self.onAction(self.state);
		}
	}
}

pub fn render(self: *CheckBox, mousePosition: Vec2f) void {
	if (self.state) {
		if (self.pressed) {
			textureCheckedPressed.bindTo(0);
		} else if (GuiComponent.contains(self.pos, self.size, mousePosition) and self.hovered) {
			textureCheckedHovered.bindTo(0);
		} else {
			textureCheckedNormal.bindTo(0);
		}
	} else {
		if (self.pressed) {
			textureEmptyPressed.bindTo(0);
		} else if (GuiComponent.contains(self.pos, self.size, mousePosition) and self.hovered) {
			textureEmptyHovered.bindTo(0);
		} else {
			textureEmptyNormal.bindTo(0);
		}
	}
	Button.pipeline.bind(draw.getScissor());
	self.hovered = false;
	draw.customShadedRect(Button.buttonUniforms, self.pos + Vec2f{0, self.size[1]/2 - boxSize/2}, @as(Vec2f, @splat(boxSize)));
	const textPos = self.pos + Vec2f{boxSize/2, 0} + self.size/@as(Vec2f, @splat(2.0)) - self.label.size/@as(Vec2f, @splat(2.0));
	self.label.pos = textPos;
	self.label.render(mousePosition - textPos);
}

```

`src/gui/components/ContinuousSlider.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const Texture = graphics.Texture;
const random = main.random;
const vec = main.vec;
const Vec2f = vec.Vec2f;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const Button = GuiComponent.Button;
const Label = GuiComponent.Label;

const ContinuousSlider = @This();

const border: f32 = 3;
const fontSize: f32 = 16;

var texture: Texture = undefined;

pos: Vec2f,
size: Vec2f,
minValue: f32,
maxValue: f32,
callback: *const fn (f32) void,
formatter: *const fn (NeverFailingAllocator, f32) []const u8,
currentValue: f32,
currentText: []const u8,
label: *Label,
button: *Button,
mouseAnchor: f32 = undefined,

pub fn __init() void {
	texture = Texture.initFromFile("assets/cubyz/ui/slider.png");
}

pub fn __deinit() void {
	texture.deinit();
}

pub fn init(pos: Vec2f, width: f32, minValue: f32, maxValue: f32, initialValue: f32, callback: *const fn (f32) void, formatter: *const fn (NeverFailingAllocator, f32) []const u8) *ContinuousSlider {
	const initialText = formatter(main.globalAllocator, initialValue);
	const label = Label.init(undefined, width - 3*border, initialText, .center);
	const button = Button.initText(.{0, 0}, undefined, "", .{});
	const self = main.globalAllocator.create(ContinuousSlider);
	self.* = ContinuousSlider{
		.pos = pos,
		.size = undefined,
		.minValue = minValue,
		.maxValue = maxValue,
		.callback = callback,
		.formatter = formatter,
		.currentValue = initialValue,
		.currentText = initialText,
		.label = label,
		.button = button,
	};
	self.button.size = .{16, 16};
	self.button.pos[1] = self.label.size[1] + 3.5*border;
	self.size = Vec2f{@max(width, self.label.size[0] + 3*border), self.label.size[1] + self.button.size[1] + 5*border};
	self.setButtonPosFromValue();
	return self;
}

pub fn deinit(self: *const ContinuousSlider) void {
	self.label.deinit();
	self.button.deinit();
	main.globalAllocator.free(self.currentText);
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *ContinuousSlider) GuiComponent {
	return .{.continuousSlider = self};
}

fn setButtonPosFromValue(self: *ContinuousSlider) void {
	const range: f32 = self.size[0] - 3*border - self.button.size[0];
	const len: f32 = self.maxValue - self.minValue;
	const val = std.math.clamp(self.currentValue, self.minValue, self.maxValue);
	self.button.pos[0] = 1.5*border + range*(val - self.minValue)/len;
	self.updateLabel(self.currentValue, self.size[0]);
}

fn updateLabel(self: *ContinuousSlider, newValue: f32, width: f32) void {
	main.globalAllocator.free(self.currentText);
	self.currentText = self.formatter(main.globalAllocator, newValue);
	const label = Label.init(undefined, width - 3*border, self.currentText, .center);
	self.label.deinit();
	self.label = label;
}

fn updateValueFromButtonPos(self: *ContinuousSlider) void {
	const range: f32 = self.size[0] - 3*border - self.button.size[0];
	const len: f32 = self.maxValue - self.minValue;
	const value: f32 = (self.button.pos[0] - 1.5*border)/range*len + self.minValue;
	if (value != self.currentValue) {
		self.currentValue = value;
		self.updateLabel(value, self.size[0]);
		self.callback(value);
	}
}

pub fn updateHovered(self: *ContinuousSlider, mousePosition: Vec2f) void {
	if (GuiComponent.contains(self.button.pos, self.button.size, mousePosition - self.pos)) {
		self.button.updateHovered(mousePosition - self.pos);
	}
}

pub fn mainButtonPressed(self: *ContinuousSlider, mousePosition: Vec2f) void {
	if (GuiComponent.contains(self.button.pos, self.button.size, mousePosition - self.pos)) {
		self.button.mainButtonPressed(mousePosition - self.pos);
		self.mouseAnchor = mousePosition[0] - self.button.pos[0];
	}
}

pub fn mainButtonReleased(self: *ContinuousSlider, _: Vec2f) void {
	self.button.mainButtonReleased(undefined);
}

pub fn render(self: *ContinuousSlider, mousePosition: Vec2f) void {
	texture.bindTo(0);
	Button.pipeline.bind(draw.getScissor());
	draw.setColor(0xff000000);
	draw.customShadedRect(Button.buttonUniforms, self.pos, self.size);

	const range: f32 = self.size[0] - 3*border - self.button.size[0];
	draw.setColor(0x80000000);
	draw.rect(self.pos + Vec2f{1.5*border + self.button.size[0]/2, self.button.pos[1] + self.button.size[1]/2 - border}, .{range, 2*border});

	self.label.pos = self.pos + @as(Vec2f, @splat(1.5*border));
	self.label.render(mousePosition);

	if (self.button.pressed) {
		self.button.pos[0] = mousePosition[0] - self.mouseAnchor;
		self.button.pos[0] = @min(@max(self.button.pos[0], 1.5*border), 1.5*border + range - 0.001);
		self.updateValueFromButtonPos();
	}
	const oldTranslation = draw.setTranslation(self.pos);
	defer draw.restoreTranslation(oldTranslation);
	self.button.render(mousePosition - self.pos);
}

```

`src/gui/components/DiscreteSlider.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const Texture = graphics.Texture;
const random = main.random;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const Button = GuiComponent.Button;
const Label = GuiComponent.Label;

const DiscreteSlider = @This();

const border: f32 = 3;
const fontSize: f32 = 16;

var texture: Texture = undefined;

pos: Vec2f,
size: Vec2f,
callback: *const fn (u16) void,
currentSelection: u16,
text: []const u8,
currentText: []u8,
values: [][]const u8,
label: *Label,
button: *Button,
mouseAnchor: f32 = undefined,

pub fn __init() void {
	texture = Texture.initFromFile("assets/cubyz/ui/slider.png");
}

pub fn __deinit() void {
	texture.deinit();
}

pub fn init(pos: Vec2f, width: f32, text: []const u8, comptime fmt: []const u8, valueList: anytype, initialValue: u16, callback: *const fn (u16) void) *DiscreteSlider {
	const values = main.globalAllocator.alloc([]const u8, valueList.len);
	var maxLen: usize = 0;
	for (valueList, 0..) |value, i| {
		values[i] = std.fmt.allocPrint(main.globalAllocator.allocator, fmt, .{value}) catch unreachable;
		maxLen = @max(maxLen, values[i].len);
	}

	const initialText = main.globalAllocator.alloc(u8, text.len + maxLen);
	@memcpy(initialText[0..text.len], text);
	@memset(initialText[text.len..], ' ');
	const label = Label.init(undefined, width - 3*border, initialText, .center);
	const button = Button.initText(.{0, 0}, undefined, "", .{});
	const self = main.globalAllocator.create(DiscreteSlider);
	self.* = DiscreteSlider{
		.pos = pos,
		.size = undefined,
		.callback = callback,
		.currentSelection = initialValue,
		.text = text,
		.currentText = initialText,
		.label = label,
		.button = button,
		.values = values,
	};
	self.button.size = .{16, 16};
	self.button.pos[1] = self.label.size[1] + 3.5*border;
	self.size = Vec2f{@max(width, self.label.size[0] + 3*border), self.label.size[1] + self.button.size[1] + 5*border};
	self.setButtonPosFromValue();
	return self;
}

pub fn deinit(self: *const DiscreteSlider) void {
	self.label.deinit();
	self.button.deinit();
	for (self.values) |value| {
		main.globalAllocator.free(value);
	}
	main.globalAllocator.free(self.values);
	main.globalAllocator.free(self.currentText);
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *DiscreteSlider) GuiComponent {
	return .{.discreteSlider = self};
}

fn setButtonPosFromValue(self: *DiscreteSlider) void {
	const range: f32 = self.size[0] - 3*border - self.button.size[0];
	const len: f32 = @floatFromInt(self.values.len);
	const selection: f32 = @floatFromInt(self.currentSelection);
	self.button.pos[0] = 1.5*border + range*(0.5 + selection)/len;
	self.updateLabel(self.values[self.currentSelection], self.size[0]);
}

fn updateLabel(self: *DiscreteSlider, newValue: []const u8, width: f32) void {
	main.globalAllocator.free(self.currentText);
	self.currentText = main.globalAllocator.alloc(u8, newValue.len + self.text.len);
	@memcpy(self.currentText[0..self.text.len], self.text);
	@memcpy(self.currentText[self.text.len..], newValue);
	const label = Label.init(undefined, width - 3*border, self.currentText, .center);
	self.label.deinit();
	self.label = label;
}

fn updateValueFromButtonPos(self: *DiscreteSlider) void {
	const range: f32 = self.size[0] - 3*border - self.button.size[0];
	const len: f32 = @floatFromInt(self.values.len);
	const selection: u16 = @intFromFloat((self.button.pos[0] - 1.5*border)/range*len);
	if (selection != self.currentSelection) {
		self.currentSelection = selection;
		self.updateLabel(self.values[selection], self.size[0]);
		self.callback(selection);
	}
}

pub fn updateHovered(self: *DiscreteSlider, mousePosition: Vec2f) void {
	if (GuiComponent.contains(self.button.pos, self.button.size, mousePosition - self.pos)) {
		self.button.updateHovered(mousePosition - self.pos);
	}
}

pub fn mainButtonPressed(self: *DiscreteSlider, mousePosition: Vec2f) void {
	if (GuiComponent.contains(self.button.pos, self.button.size, mousePosition - self.pos)) {
		self.button.mainButtonPressed(mousePosition - self.pos);
		self.mouseAnchor = mousePosition[0] - self.button.pos[0];
	}
}

pub fn mainButtonReleased(self: *DiscreteSlider, _: Vec2f) void {
	self.button.mainButtonReleased(undefined);
}

pub fn render(self: *DiscreteSlider, mousePosition: Vec2f) void {
	texture.bindTo(0);
	Button.pipeline.bind(draw.getScissor());
	draw.setColor(0xff000000);
	draw.customShadedRect(Button.buttonUniforms, self.pos, self.size);

	const range: f32 = self.size[0] - 3*border - self.button.size[0];
	draw.setColor(0x80000000);
	draw.rect(self.pos + Vec2f{1.5*border + self.button.size[0]/2, self.button.pos[1] + self.button.size[1]/2 - border}, .{range, 2*border});

	self.label.pos = self.pos + @as(Vec2f, @splat(1.5*border));
	self.label.render(mousePosition);

	if (self.button.pressed) {
		self.button.pos[0] = mousePosition[0] - self.mouseAnchor;
		self.button.pos[0] = @min(@max(self.button.pos[0], 1.5*border), 1.5*border + range - 0.001);
		self.updateValueFromButtonPos();
	}
	const oldTranslation = draw.setTranslation(self.pos);
	defer draw.restoreTranslation(oldTranslation);
	self.button.render(mousePosition - self.pos);
}

```

`src/gui/components/HorizontalList.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;

const HorizontalList = @This();

pos: Vec2f,
size: Vec2f,
children: main.List(GuiComponent),

pub fn init() *HorizontalList {
	const self = main.globalAllocator.create(HorizontalList);
	self.* = HorizontalList{
		.children = .init(main.globalAllocator),
		.pos = .{0, 0},
		.size = .{0, 0},
	};
	return self;
}

pub fn deinit(self: *const HorizontalList) void {
	for (self.children.items) |*child| {
		child.deinit();
	}
	self.children.deinit();
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *HorizontalList) GuiComponent {
	return .{.horizontalList = self};
}

pub fn add(self: *HorizontalList, _other: anytype) void {
	var other: GuiComponent = undefined;
	if (@TypeOf(_other) == GuiComponent) {
		other = _other;
	} else {
		other = _other.toComponent();
	}
	other.mutPos().*[0] += self.size[0];
	self.size[0] = other.pos()[0] + other.size()[0];
	self.size[1] = @max(self.size[1], other.pos()[1] + other.size()[1]);
	self.children.append(other);
}

pub fn finish(self: *HorizontalList, pos: Vec2f, alignment: graphics.TextBuffer.Alignment) void {
	self.pos = pos;
	self.children.shrinkAndFree(self.children.items.len);
	for (self.children.items) |_child| {
		const child: GuiComponent = _child;
		const mutPos = child.mutPos();
		const size = child.size();
		switch (alignment) {
			.left => {},
			.center => {
				mutPos.*[1] = mutPos.*[1]/2 + self.size[1]/2 - size[1]/2;
			},
			.right => {
				mutPos.*[1] = self.size[1] - size[1];
			},
		}
	}
}

pub fn updateSelected(self: *HorizontalList) void {
	for (self.children.items) |*child| {
		child.updateSelected();
	}
}

pub fn updateHovered(self: *HorizontalList, mousePosition: Vec2f) void {
	var i: usize = self.children.items.len;
	while (i != 0) {
		i -= 1;
		const child = &self.children.items[i];
		if (GuiComponent.contains(child.pos() + self.pos, child.size(), mousePosition)) {
			child.updateHovered(mousePosition - self.pos);
			break;
		}
	}
}

pub fn render(self: *HorizontalList, mousePosition: Vec2f) void {
	const oldTranslation = draw.setTranslation(self.pos);
	for (self.children.items) |*child| {
		child.render(mousePosition - self.pos);
	}
	draw.restoreTranslation(oldTranslation);
}

pub fn mainButtonPressed(self: *HorizontalList, mousePosition: Vec2f) void {
	var selectedChild: ?*GuiComponent = null;
	for (self.children.items) |*child| {
		if (GuiComponent.contains(child.pos() + self.pos, child.size(), mousePosition)) {
			selectedChild = child;
		}
	}
	if (selectedChild) |child| {
		child.mainButtonPressed(mousePosition - self.pos);
	}
}

pub fn mainButtonReleased(self: *HorizontalList, mousePosition: Vec2f) void {
	for (self.children.items) |*child| {
		child.mainButtonReleased(mousePosition - self.pos);
	}
}

```

`src/gui/components/Icon.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;

const Icon = @This();

const fontSize: f32 = 16;

pos: Vec2f,
size: Vec2f,
texture: Texture,
hasShadow: bool,

pub fn init(pos: Vec2f, size: Vec2f, texture: Texture, hasShadow: bool) *Icon {
	const self = main.globalAllocator.create(Icon);
	self.* = Icon{
		.texture = texture,
		.pos = pos,
		.size = size,
		.hasShadow = hasShadow,
	};
	return self;
}

pub fn deinit(self: *const Icon) void {
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *Icon) GuiComponent {
	return .{.icon = self};
}

pub fn updateTexture(self: *Icon, newTexture: Texture) !void {
	self.texture = newTexture;
}

pub fn render(self: *Icon, _: Vec2f) void {
	if (self.hasShadow) {
		draw.setColor(0xff000000);
		self.texture.render(self.pos + Vec2f{1, 1}, self.size);
	}
	draw.setColor(0xffffffff);
	self.texture.render(self.pos, self.size);
}

```

`src/gui/components/ItemSlot.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ClientInventory = main.items.Inventory.ClientInventory;
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const TextBuffer = graphics.TextBuffer;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;

const ItemSlot = @This();

const border: f32 = 2;

pub const sizeWithBorder = 32 + 2*border;

const Mode = enum {
	normal,
	takeOnly,
	immutable,
};

pos: Vec2f,
size: Vec2f = @splat(sizeWithBorder),
inventory: ClientInventory,
itemSlot: u32,
lastItemAmount: u16 = 0,
text: TextBuffer,
textSize: Vec2f = .{0, 0},
hovered: bool = false,
pressed: bool = false,
renderFrame: bool = true,
texture: ?Texture,
mode: Mode,

var defaultTexture: Texture = undefined;
var immutableTexture: Texture = undefined;
var craftingResultTexture: Texture = undefined;
const TextureParamType = union(enum) {
	default: void,
	immutable: void,
	craftingResult: void,
	invisible: void,
	custom: Texture,
	fn value(self: TextureParamType) ?Texture {
		return switch (self) {
			.default => defaultTexture,
			.immutable => immutableTexture,
			.craftingResult => craftingResultTexture,
			.invisible => null,
			.custom => |t| t,
		};
	}
};

pub fn __init() void {
	defaultTexture = Texture.initFromFile("assets/cubyz/ui/inventory/slot.png");
	immutableTexture = Texture.initFromFile("assets/cubyz/ui/inventory/immutable_slot.png");
	craftingResultTexture = Texture.initFromFile("assets/cubyz/ui/inventory/crafting_result_slot.png");
}

pub fn __deinit() void {
	defaultTexture.deinit();
	immutableTexture.deinit();
	craftingResultTexture.deinit();
}

pub fn init(pos: Vec2f, inventory: ClientInventory, itemSlot: u32, texture: TextureParamType, mode: Mode) *ItemSlot {
	const self = main.globalAllocator.create(ItemSlot);
	const amount = inventory.getAmount(itemSlot);
	var buf: [16]u8 = undefined;
	self.* = ItemSlot{
		.inventory = inventory,
		.itemSlot = itemSlot,
		.pos = pos,
		.text = TextBuffer.init(main.globalAllocator, std.fmt.bufPrint(&buf, "{}", .{amount}) catch "∞", .{}, false, .right),
		.lastItemAmount = amount,
		.texture = texture.value(),
		.mode = mode,
	};
	self.textSize = self.text.calculateLineBreaks(8, self.size[0] - 2*border);
	return self;
}

pub fn deinit(self: *const ItemSlot) void {
	main.gui.inventory.deleteItemSlotReferences(self);
	self.text.deinit();
	main.globalAllocator.destroy(self);
}

fn refreshText(self: *ItemSlot) void {
	const amount = self.inventory.getAmount(self.itemSlot);
	if (self.lastItemAmount == amount) return;
	self.lastItemAmount = amount;
	self.text.deinit();
	var buf: [16]u8 = undefined;
	self.text = TextBuffer.init(
		main.globalAllocator,
		std.fmt.bufPrint(&buf, "{}", .{amount}) catch "∞",
		.{.color = if (amount == 0) 0xff0000 else 0xffffff},
		false,
		.right,
	);
	self.textSize = self.text.calculateLineBreaks(8, self.size[0] - 2*border);
}

pub fn toComponent(self: *ItemSlot) GuiComponent {
	return .{.itemSlot = self};
}

pub fn updateHovered(self: *ItemSlot, _: Vec2f) void {
	self.hovered = true;
	gui.hoveredItemSlot = self;
}

pub fn mainButtonPressed(self: *ItemSlot, _: Vec2f) void {
	self.pressed = true;
}

pub fn mainButtonReleased(self: *ItemSlot, _: Vec2f) void {
	if (self.pressed) {
		self.pressed = false;
	}
}

pub fn render(self: *ItemSlot, _: Vec2f) void {
	self.refreshText();
	draw.setColor(0xffffffff);
	if (self.renderFrame and self.texture != null) {
		self.texture.?.bindTo(0);
		draw.boundImage(self.pos, self.size);
	}
	const item = self.inventory.getItem(self.itemSlot);
	if (item != .null) {
		const itemTexture = item.getTexture();
		itemTexture.bindTo(0);
		draw.setColor(0xffffffff);
		draw.boundImage(self.pos + @as(Vec2f, @splat(border)), self.size - @as(Vec2f, @splat(2*border)));
		const shouldRenderStackSizeText = item.stackSize() > 1 and self.inventory.type != .creative;
		if (shouldRenderStackSizeText) {
			self.text.render(self.pos[0] + self.size[0] - self.textSize[0] - border, self.pos[1] + self.size[1] - self.textSize[1] - border, 8);
		}
		if (item == .tool) {
			const tool = item.tool;
			const durabilityPercentage = @as(f32, @floatFromInt(tool.durability))/tool.maxDurability;

			if (durabilityPercentage < 1) {
				const width = durabilityPercentage*(self.size[0] - 2*border);
				draw.setColor(0xff000000);
				draw.rect(self.pos + Vec2f{border, 15*(self.size[1] - border)/16.0}, .{self.size[0] - 2*border, (self.size[1] - 2*border)/16.0});

				const red = std.math.lossyCast(u8, (2 - durabilityPercentage*2)*255);
				const green = std.math.lossyCast(u8, durabilityPercentage*2*255);

				draw.setColor(0xff000000 | (@as(u32, @intCast(red)) << 16) | (@as(u32, @intCast(green)) << 8));
				draw.rect(self.pos + Vec2f{border, 15*(self.size[1] - border)/16.0}, .{width, (self.size[1] - 2*border)/16.0});
			}
		}
	}
	if (self.mode != .immutable) {
		if (self.pressed) {
			draw.setColor(0x80808080);
			draw.rect(self.pos, self.size);
		} else if (self.hovered) {
			self.hovered = false;
			draw.setColor(0x300000ff);
			draw.rect(self.pos, self.size);
		}
	}
}

```

`src/gui/components/Label.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;

const Label = @This();

const fontSize: f32 = 16;

pos: Vec2f,
size: Vec2f,
text: TextBuffer,
alpha: f32 = 1,

pub fn init(pos: Vec2f, maxWidth: f32, text: []const u8, alignment: TextBuffer.Alignment) *Label {
	const self = main.globalAllocator.create(Label);
	self.* = Label{
		.text = TextBuffer.init(main.globalAllocator, text, .{}, false, alignment),
		.pos = pos,
		.size = undefined,
	};
	self.size = self.text.calculateLineBreaks(fontSize, maxWidth);
	return self;
}

pub fn deinit(self: *const Label) void {
	self.text.deinit();
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *Label) GuiComponent {
	return .{.label = self};
}

pub fn updateText(self: *Label, newText: []const u8) void {
	const alignment = self.text.alignment;
	self.text.deinit();
	self.text = TextBuffer.init(main.globalAllocator, newText, .{}, false, alignment);
	self.size = self.text.calculateLineBreaks(fontSize, self.size[0]);
}

pub fn render(self: *Label, _: Vec2f) void {
	draw.setColor(@as(u32, @intFromFloat(self.alpha*255)) << 24);
	self.text.render(self.pos[0], self.pos[1], fontSize);
}

```

`src/gui/components/MutexComponent.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const ScrollBar = GuiComponent.ScrollBar;

const MutexComponent = @This();

const scrollBarWidth = 5;
const border: f32 = 3;

pos: Vec2f = undefined,
size: Vec2f = undefined,
child: GuiComponent = undefined,
mutex: std.Thread.Mutex = .{},

pub fn updateInner(self: *MutexComponent, _other: anytype) void {
	main.utils.assertLocked(&self.mutex);
	var other: GuiComponent = undefined;
	if (@TypeOf(_other) == GuiComponent) {
		other = _other;
	} else {
		other = _other.toComponent();
	}
	self.child = other;
	self.pos = other.pos();
	self.size = other.size();
}

pub fn deinit(self: *MutexComponent) void {
	main.utils.assertLocked(&self.mutex);
	self.child.deinit();
}

pub fn toComponent(self: *MutexComponent) GuiComponent {
	return .{.mutexComponent = self};
}

pub fn updateSelected(self: *MutexComponent) void {
	self.mutex.lock();
	defer self.mutex.unlock();
	self.child.updateSelected();
}

pub fn updateHovered(self: *MutexComponent, mousePosition: Vec2f) void {
	self.mutex.lock();
	defer self.mutex.unlock();
	self.child.updateHovered(mousePosition);
}

pub fn render(self: *MutexComponent, mousePosition: Vec2f) void {
	self.mutex.lock();
	defer self.mutex.unlock();
	self.child.render(mousePosition);
	self.pos = self.child.pos();
	self.size = self.child.size();
}

pub fn mainButtonPressed(self: *MutexComponent, mousePosition: Vec2f) void {
	self.mutex.lock();
	defer self.mutex.unlock();
	self.child.mainButtonPressed(mousePosition);
}

pub fn mainButtonReleased(self: *MutexComponent, mousePosition: Vec2f) void {
	self.mutex.lock();
	defer self.mutex.unlock();
	self.child.mainButtonReleased(mousePosition);
}

```

`src/gui/components/ScrollBar.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const Texture = graphics.Texture;
const random = main.random;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const Button = GuiComponent.Button;
const Label = GuiComponent.Label;

const ScrollBar = @This();

const fontSize: f32 = 16;

var texture: Texture = undefined;

pos: Vec2f,
size: Vec2f,
currentState: f32,
button: *Button,
mouseAnchor: f32 = undefined,

pub fn __init() void {
	texture = Texture.initFromFile("assets/cubyz/ui/scrollbar.png");
}

pub fn __deinit() void {
	texture.deinit();
}

pub fn init(pos: Vec2f, width: f32, height: f32, initialState: f32) *ScrollBar {
	const button = Button.initText(.{0, 0}, undefined, "", .{});
	const self = main.globalAllocator.create(ScrollBar);
	self.* = ScrollBar{
		.pos = pos,
		.size = Vec2f{width, height},
		.currentState = initialState,
		.button = button,
	};
	self.button.size = .{width, 16};
	self.setButtonPosFromValue();
	return self;
}

pub fn deinit(self: *const ScrollBar) void {
	self.button.deinit();
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *ScrollBar) GuiComponent {
	return .{.scrollBar = self};
}

fn setButtonPosFromValue(self: *ScrollBar) void {
	const range: f32 = self.size[1] - self.button.size[1];
	self.button.pos[1] = range*self.currentState;
}

fn updateValueFromButtonPos(self: *ScrollBar) void {
	const range: f32 = self.size[1] - self.button.size[1];
	const value = self.button.pos[1]/range;
	if (value != self.currentState) {
		self.currentState = value;
	}
}

pub fn scroll(self: *ScrollBar, offset: f32) void {
	self.currentState += offset;
	self.currentState = @min(1, @max(0, self.currentState));
}

pub fn updateHovered(self: *ScrollBar, mousePosition: Vec2f) void {
	if (GuiComponent.contains(self.button.pos, self.button.size, mousePosition - self.pos)) {
		self.button.updateHovered(mousePosition - self.pos);
	}
}

pub fn mainButtonPressed(self: *ScrollBar, mousePosition: Vec2f) void {
	if (GuiComponent.contains(self.button.pos, self.button.size, mousePosition - self.pos)) {
		self.button.mainButtonPressed(mousePosition - self.pos);
		self.mouseAnchor = mousePosition[1] - self.button.pos[1];
	}
}

pub fn mainButtonReleased(self: *ScrollBar, mousePosition: Vec2f) void {
	self.button.mainButtonReleased(mousePosition - self.pos);
}

pub fn render(self: *ScrollBar, mousePosition: Vec2f) void {
	texture.bindTo(0);
	Button.pipeline.bind(draw.getScissor());
	draw.setColor(0xff000000);
	draw.customShadedRect(Button.buttonUniforms, self.pos, self.size);

	const range: f32 = self.size[1] - self.button.size[1];
	self.setButtonPosFromValue();
	if (self.button.pressed) {
		self.button.pos[1] = mousePosition[1] - self.mouseAnchor;
		self.button.pos[1] = @min(@max(self.button.pos[1], 0), range - 0.001);
		self.updateValueFromButtonPos();
	}
	const oldTranslation = draw.setTranslation(self.pos);
	defer draw.restoreTranslation(oldTranslation);
	self.button.render(mousePosition - self.pos);
}

```

`src/gui/components/TextInput.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const Texture = graphics.Texture;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const Button = GuiComponent.Button;
const ScrollBar = GuiComponent.ScrollBar;

const TextInput = @This();

const scrollBarWidth = 5;
const border: f32 = 3;
const fontSize: f32 = 16;
const blinkDuration: std.Io.Duration = .fromMilliseconds(500);

var texture: Texture = undefined;

pos: Vec2f,
size: Vec2f,
pressed: bool = false,
obfuscated: bool = false,
cursor: ?u32 = null,
selectionStart: ?u32 = null,
currentString: main.List(u8),
textBuffer: TextBuffer,
maxWidth: f32,
maxHeight: f32,
textSize: Vec2f = undefined,
scrollBar: *ScrollBar,
callbacks: Callbacks,
lastBlinkTime: std.Io.Timestamp = .fromNanoseconds(0),
showCusor: bool = true,

pub fn __init() void {
	texture = Texture.initFromFile("assets/cubyz/ui/text_input.png");
}

pub fn __deinit() void {
	texture.deinit();
}

const Callbacks = struct {
	onNewline: main.callbacks.SimpleCallback,
	onUp: main.callbacks.SimpleCallback = .{},
	onDown: main.callbacks.SimpleCallback = .{},
	onUpdate: main.callbacks.SimpleCallback = .{},
};

pub fn init(pos: Vec2f, maxWidth: f32, maxHeight: f32, text: []const u8, callbacks: Callbacks) *TextInput {
	const scrollBar = ScrollBar.init(undefined, scrollBarWidth, maxHeight - 2*border, 0);
	const self = main.globalAllocator.create(TextInput);
	self.* = TextInput{
		.pos = pos,
		.size = .{maxWidth, maxHeight},
		.currentString = .init(main.globalAllocator),
		.textBuffer = TextBuffer.init(main.globalAllocator, text, .{}, true, .left),
		.maxWidth = maxWidth,
		.maxHeight = maxHeight,
		.scrollBar = scrollBar,
		.callbacks = callbacks,
	};
	self.currentString.appendSlice(text);
	self.textSize = self.textBuffer.calculateLineBreaks(fontSize, maxWidth - 2*border - scrollBarWidth);
	return self;
}

pub fn deinit(self: *const TextInput) void {
	if (gui.selectedTextInput == self) {
		gui.setSelectedTextInput(null);
	}

	self.textBuffer.deinit();
	self.currentString.deinit();
	self.scrollBar.deinit();
	main.globalAllocator.destroy(self);
}

pub fn clear(self: *TextInput) void {
	if (self.cursor != null) {
		self.cursor = 0;
		self.selectionStart = null;
	}
	self.currentString.clearRetainingCapacity();
	self.reloadText();
}

pub fn toComponent(self: *TextInput) GuiComponent {
	return .{.textInput = self};
}

pub fn updateHovered(self: *TextInput, mousePosition: Vec2f) void {
	if (self.textSize[1] > self.maxHeight - 2*border) {
		const diff = self.textSize[1] - (self.maxHeight - 2*border);
		self.scrollBar.scroll(-main.Window.scrollOffset*32/diff);
		main.Window.scrollOffset = 0;
	}
	if (self.textSize[1] > self.maxHeight - 2*border) {
		self.scrollBar.pos = Vec2f{self.size[0] - border - scrollBarWidth, border};
		if (GuiComponent.contains(self.scrollBar.pos, self.scrollBar.size, mousePosition - self.pos)) {
			self.scrollBar.updateHovered(mousePosition - self.pos);
		}
	}
}

pub fn mainButtonPressed(self: *TextInput, mousePosition: Vec2f) void {
	if (self.textSize[1] > self.maxHeight - 2*border) {
		self.scrollBar.pos = Vec2f{self.size[0] - border - scrollBarWidth, border};
		if (GuiComponent.contains(self.scrollBar.pos, self.scrollBar.size, mousePosition - self.pos)) {
			self.scrollBar.mainButtonPressed(mousePosition - self.pos);
			return;
		}
	}
	self.cursor = null;
	var textPos = Vec2f{border, border};
	if (self.textSize[1] > self.maxHeight - 2*border) {
		const diff = self.textSize[1] - (self.maxHeight - 2*border);
		textPos[1] -= diff*self.scrollBar.currentState;
	}
	self.selectionStart = self.textBuffer.mousePosToIndex(mousePosition - textPos - self.pos, self.currentString.items.len);
	self.pressed = true;
	self.ensureCursorVisibility();
}

pub fn mainButtonReleased(self: *TextInput, mousePosition: Vec2f) void {
	if (self.pressed) {
		var textPos = Vec2f{border, border};
		if (self.textSize[1] > self.maxHeight - 2*border) {
			const diff = self.textSize[1] - (self.maxHeight - 2*border);
			textPos[1] -= diff*self.scrollBar.currentState;
		}
		self.cursor = self.textBuffer.mousePosToIndex(mousePosition - textPos - self.pos, self.currentString.items.len);
		if (self.cursor == self.selectionStart) {
			self.selectionStart = null;
		}
		self.pressed = false;
		gui.setSelectedTextInput(self);
	} else if (self.textSize[1] > self.maxHeight - 2*border) {
		self.scrollBar.pos = .{self.size[0] - border - scrollBarWidth, border};
		self.scrollBar.mainButtonReleased(mousePosition - self.pos);
		gui.setSelectedTextInput(self);
	}
}

pub fn select(self: *TextInput) void {
	gui.setSelectedTextInput(self);
	self.pressed = false;
	self.selectionStart = null;
	if (self.cursor == null)
		self.cursor = @intCast(self.currentString.items.len);
}

pub fn deselect(self: *TextInput) void {
	self.cursor = null;
	self.selectionStart = null;
}

fn reloadText(self: *TextInput) void {
	self.callbacks.onUpdate.run();
	self.textBuffer.deinit();
	self.textBuffer = TextBuffer.init(main.globalAllocator, self.currentString.items, .{}, true, .left);
	self.textSize = self.textBuffer.calculateLineBreaks(fontSize, self.maxWidth - 2*border - scrollBarWidth);
}

fn moveCursorLeft(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		const text = self.currentString.items;
		if (self.cursor.? == 0) return;
		self.cursor.? -= 1;
		// Find end of previous "word":
		while (!std.ascii.isAlphabetic(text[self.cursor.?]) and std.ascii.isAscii(text[self.cursor.?])) {
			if (self.cursor.? == 0) return;
			self.cursor.? -= 1;
		}
		// Find the start of the previous "word":
		while (std.ascii.isAlphabetic(text[self.cursor.?]) or !std.ascii.isAscii(text[self.cursor.?])) {
			if (self.cursor.? == 0) return;
			self.cursor.? -= 1;
		}
		self.cursor.? += 1;
	} else {
		while (self.cursor.? > 0) {
			self.cursor.? -= 1;
			if ((std.unicode.utf8ByteSequenceLength(self.currentString.items[self.cursor.?]) catch 0) != 0) break; // Ugly hack to check if we found a valid start byte.
		}
	}
}

pub fn left(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor) |*cursor| {
		if (mods.shift) {
			if (self.selectionStart == null) {
				self.selectionStart = cursor.*;
			}
			self.moveCursorLeft(mods);
			if (self.selectionStart == self.cursor) {
				self.selectionStart = null;
			}
		} else {
			if (self.selectionStart) |selectionStart| {
				cursor.* = @min(cursor.*, selectionStart);
				self.selectionStart = null;
			} else {
				self.moveCursorLeft(mods);
			}
		}
		self.ensureCursorVisibility();
	}
}

fn moveCursorRight(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor.? < self.currentString.items.len) {
		if (mods.control) {
			const text = self.currentString.items;
			// Find start of next "word":
			while (!std.ascii.isAlphabetic(text[self.cursor.?]) and std.ascii.isAscii(text[self.cursor.?])) {
				self.cursor.? += 1;
				if (self.cursor.? >= self.currentString.items.len) return;
			}
			// Find the end of the next "word":
			while (std.ascii.isAlphabetic(text[self.cursor.?]) or !std.ascii.isAscii(text[self.cursor.?])) {
				self.cursor.? += 1;
				if (self.cursor.? >= self.currentString.items.len) return;
			}
		} else {
			self.cursor.? += std.unicode.utf8ByteSequenceLength(self.currentString.items[self.cursor.?]) catch 0;
		}
	}
}

pub fn right(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor) |*cursor| {
		if (mods.shift) {
			if (self.selectionStart == null) {
				self.selectionStart = cursor.*;
			}
			self.moveCursorRight(mods);
			if (self.selectionStart == self.cursor) {
				self.selectionStart = null;
			}
		} else {
			if (self.selectionStart) |selectionStart| {
				cursor.* = @max(cursor.*, selectionStart);
				self.selectionStart = null;
			} else {
				self.moveCursorRight(mods);
			}
		}
		self.ensureCursorVisibility();
	}
}

fn moveCursorVertically(self: *TextInput, relativeLines: f32) enum { changed, same } {
	const newCursor = self.textBuffer.mousePosToIndex(self.textBuffer.indexToCursorPos(self.cursor.?) + Vec2f{0, 16*relativeLines}, self.currentString.items.len);
	self.cursor = newCursor;
	if (self.cursor != newCursor) {
		return .changed;
	}
	return .same;
}

pub fn down(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor) |*cursor| {
		if (mods.shift) {
			if (self.selectionStart == null) {
				self.selectionStart = cursor.*;
			}
			_ = self.moveCursorVertically(1);
			if (self.selectionStart == self.cursor) {
				self.selectionStart = null;
			}
		} else {
			if (self.selectionStart) |selectionStart| {
				cursor.* = @max(cursor.*, selectionStart);
				self.selectionStart = null;
			} else {
				if (self.moveCursorVertically(1) == .same) {
					self.callbacks.onDown.run();
				}
			}
		}
		self.ensureCursorVisibility();
	}
}

pub fn up(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor) |*cursor| {
		if (mods.shift) {
			if (self.selectionStart == null) {
				self.selectionStart = cursor.*;
			}
			_ = self.moveCursorVertically(-1);
			if (self.selectionStart == self.cursor) {
				self.selectionStart = null;
			}
		} else {
			if (self.selectionStart) |selectionStart| {
				cursor.* = @min(cursor.*, selectionStart);
				self.selectionStart = null;
			} else {
				if (self.moveCursorVertically(-1) == .same) {
					self.callbacks.onUp.run();
				}
			}
		}
		self.ensureCursorVisibility();
	}
}

fn moveCursorToStart(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		self.cursor.? = 0;
	} else {
		self.cursor.? = @intCast(if (std.mem.lastIndexOf(u8, self.currentString.items[0..self.cursor.?], "\n")) |nextPos| nextPos + 1 else 0);
	}
}

pub fn gotoStart(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor) |*cursor| {
		if (mods.shift) {
			if (self.selectionStart == null) {
				self.selectionStart = cursor.*;
			}
			self.moveCursorToStart(mods);
			if (self.selectionStart == self.cursor) {
				self.selectionStart = null;
			}
		} else {
			if (self.selectionStart) |selectionStart| {
				cursor.* = @min(cursor.*, selectionStart);
				self.selectionStart = null;
			} else {
				self.moveCursorToStart(mods);
			}
		}
		self.ensureCursorVisibility();
	}
}

fn moveCursorToEnd(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		self.cursor.? = @intCast(self.currentString.items.len);
	} else {
		self.cursor.? += @intCast(std.mem.indexOf(u8, self.currentString.items[self.cursor.?..], "\n") orelse self.currentString.items.len - self.cursor.?);
	}
}

pub fn gotoEnd(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (self.cursor) |*cursor| {
		if (mods.shift) {
			if (self.selectionStart == null) {
				self.selectionStart = cursor.*;
			}
			self.moveCursorToEnd(mods);
			if (self.selectionStart == self.cursor) {
				self.selectionStart = null;
			}
		} else {
			if (self.selectionStart) |selectionStart| {
				cursor.* = @min(cursor.*, selectionStart);
				self.selectionStart = null;
			} else {
				self.moveCursorToEnd(mods);
			}
		}
		self.ensureCursorVisibility();
	}
}

fn deleteSelection(self: *TextInput) void {
	if (self.selectionStart) |selectionStart| {
		const start = @min(selectionStart, self.cursor.?);
		const end = @max(selectionStart, self.cursor.?);

		self.currentString.replaceRange(start, end - start, &[0]u8{});
		self.cursor.? = start;
		self.selectionStart = null;
		self.ensureCursorVisibility();
	}
}

pub fn deleteLeft(self: *TextInput, _: main.Window.Key.Modifiers) void {
	if (self.cursor == null) return;
	if (self.selectionStart == null) {
		self.selectionStart = self.cursor;
		self.moveCursorLeft(.{});
	}
	self.deleteSelection();
	self.reloadText();
	self.ensureCursorVisibility();
}

pub fn deleteRight(self: *TextInput, _: main.Window.Key.Modifiers) void {
	if (self.cursor == null) return;
	if (self.selectionStart == null) {
		self.selectionStart = self.cursor;
		self.moveCursorRight(.{});
	}
	self.deleteSelection();
	self.reloadText();
	self.ensureCursorVisibility();
}

pub fn inputCharacter(self: *TextInput, character: u21) void {
	if (self.cursor) |*cursor| {
		self.deleteSelection();
		var buf: [4]u8 = undefined;
		const utf8 = buf[0 .. std.unicode.utf8Encode(character, &buf) catch return];
		self.currentString.insertSlice(cursor.*, utf8);
		self.reloadText();
		cursor.* += @intCast(utf8.len);
		self.ensureCursorVisibility();
	}
}

pub fn setString(self: *TextInput, utf8EncodedString: []const u8) void {
	self.clear();
	self.currentString.insertSlice(0, utf8EncodedString);
	self.reloadText();
	if (self.cursor != null) self.cursor = @intCast(utf8EncodedString.len);
	self.ensureCursorVisibility();
}

pub fn selectAll(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		self.selectionStart = 0;
		self.cursor = @intCast(self.currentString.items.len);
		self.ensureCursorVisibility();
	}
}

pub fn copy(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		if (self.cursor) |cursor| {
			if (self.selectionStart) |selectionStart| {
				const start = @min(cursor, selectionStart);
				const end = @max(cursor, selectionStart);
				main.Window.setClipboardString(self.currentString.items[start..end]);
			}
		}
		self.ensureCursorVisibility();
	}
}

pub fn paste(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		const string = main.Window.getClipboardString();
		self.deleteSelection();
		self.currentString.insertSlice(self.cursor.?, string);
		self.cursor.? += @intCast(string.len);
		self.reloadText();
		self.ensureCursorVisibility();
	}
}

pub fn cut(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (mods.control) {
		self.copy(mods);
		self.deleteSelection();
		self.reloadText();
		self.ensureCursorVisibility();
	}
}

pub fn newline(self: *TextInput, mods: main.Window.Key.Modifiers) void {
	if (!mods.shift and self.callbacks.onNewline.inner != null) {
		self.callbacks.onNewline.run();
		return;
	}
	self.inputCharacter('\n');
	self.ensureCursorVisibility();
}

fn ensureCursorVisibility(self: *TextInput) void {
	self.showCusor = true;
	self.lastBlinkTime = main.timestamp();
	if (self.textSize[1] > self.maxHeight - 2*border) {
		var y: f32 = 0;
		const diff = self.textSize[1] - (self.maxHeight - 2*border);
		y -= diff*self.scrollBar.currentState;
		if (self.cursor) |cursor| {
			const cursorPos = y + self.textBuffer.indexToCursorPos(cursor)[1];
			if (cursorPos < 0) {
				self.scrollBar.currentState += cursorPos/diff;
			} else if (cursorPos + 16 >= self.maxHeight - 2*border) {
				self.scrollBar.currentState += (cursorPos + 16 - (self.maxHeight - 2*border))/diff;
			}
		}
	}
}

fn getRenderCursorPos(self: *const TextInput, pos: u32) u32 {
	if (!self.obfuscated) return pos;
	const obfuscatedPos = (std.unicode.utf8CountCodepoints(self.currentString.items[0..pos]) catch 0)*main.utils.obfuscationChar.len;
	return @intCast(obfuscatedPos);
}

pub fn render(self: *TextInput, mousePosition: Vec2f) void {
	texture.bindTo(0);
	Button.pipeline.bind(draw.getScissor());
	draw.setColor(0xff000000);
	draw.customShadedRect(Button.buttonUniforms, self.pos, self.size);
	const oldTranslation = draw.setTranslation(self.pos);
	defer draw.restoreTranslation(oldTranslation);
	const oldClip = draw.setClip(self.size);
	defer draw.restoreClip(oldClip);

	var textPos = Vec2f{border, border};
	var textSize = self.textSize;
	const textBuffer = if (self.obfuscated) blk: {
		const obfuscatedString = main.utils.obfuscateString(main.stackAllocator, self.currentString.items);
		defer main.stackAllocator.free(obfuscatedString);

		var newTextBuffer = TextBuffer.init(main.stackAllocator, obfuscatedString, .{}, true, .left);
		textSize = newTextBuffer.calculateLineBreaks(fontSize, self.maxWidth - 2*border - scrollBarWidth);
		break :blk newTextBuffer;
	} else self.textBuffer;
	defer if (self.obfuscated) textBuffer.deinit();

	if (textSize[1] > self.maxHeight - 2*border) {
		const diff = textSize[1] - (self.maxHeight - 2*border);
		textPos[1] -= diff*self.scrollBar.currentState;
		self.scrollBar.pos = .{self.size[0] - self.scrollBar.size[0] - border, border};
		self.scrollBar.render(mousePosition - self.pos);
	}
	textBuffer.render(textPos[0], textPos[1], fontSize);
	if (self.pressed) {
		self.cursor = self.textBuffer.mousePosToIndex(mousePosition - textPos - self.pos, self.currentString.items.len);
	}
	if (self.cursor) |_cursor| {
		const cursor = self.getRenderCursorPos(_cursor);
		const cursorPos = textPos + textBuffer.indexToCursorPos(cursor);
		if (self.selectionStart) |_selectionStart| {
			const selectionStart = self.getRenderCursorPos(_selectionStart);
			draw.setColor(0x440000ff);
			textBuffer.drawSelection(textPos, @min(selectionStart, cursor), @max(selectionStart, cursor));
		}

		const currentTime = main.timestamp();
		if (self.lastBlinkTime.durationTo(currentTime).nanoseconds > blinkDuration.nanoseconds) {
			self.lastBlinkTime = currentTime;
			self.showCusor = !self.showCusor;
		}

		if (self.showCusor) {
			draw.setColor(0xff000000);
			const thickness = @min(@ceil(fontSize/8), 1);
			draw.rect(cursorPos, Vec2f{thickness, fontSize});
		}
	}
}

```

`src/gui/components/VerticalList.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const TextBuffer = graphics.TextBuffer;
const vec = main.vec;
const Vec2f = vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const ScrollBar = GuiComponent.ScrollBar;

const VerticalList = @This();

const scrollBarWidth = 10;
const border: f32 = 3;

pos: Vec2f,
size: Vec2f,
children: main.List(GuiComponent),
padding: f32,
maxHeight: f32,
childrenHeight: f32 = 0,
scrollBar: *ScrollBar,
scrollBarEnabled: bool = false,

pub fn init(pos: Vec2f, maxHeight: f32, padding: f32) *VerticalList {
	const scrollBar = ScrollBar.init(undefined, scrollBarWidth, maxHeight - 2*border, 0);
	const self = main.globalAllocator.create(VerticalList);
	self.* = VerticalList{
		.children = .init(main.globalAllocator),
		.pos = pos,
		.size = .{0, 0},
		.padding = padding,
		.maxHeight = maxHeight,
		.scrollBar = scrollBar,
	};
	return self;
}

pub fn deinit(self: *const VerticalList) void {
	for (self.children.items) |*child| {
		child.deinit();
	}
	self.scrollBar.deinit();
	self.children.deinit();
	main.globalAllocator.destroy(self);
}

pub fn toComponent(self: *VerticalList) GuiComponent {
	return .{.verticalList = self};
}

pub fn add(self: *VerticalList, _other: anytype) void {
	var other: GuiComponent = undefined;
	if (@TypeOf(_other) == GuiComponent) {
		other = _other;
	} else {
		other = _other.toComponent();
	}
	other.mutPos().*[1] += self.size[1];
	if (self.size[1] != 0) other.mutPos().*[1] += self.padding;
	self.size[1] = other.pos()[1] + other.size()[1];
	self.size[0] = @max(self.size[0], other.pos()[0] + other.size()[0]);
	self.children.append(other);
}

pub fn finish(self: *VerticalList, alignment: graphics.TextBuffer.Alignment) void {
	self.children.shrinkAndFree(self.children.items.len);
	for (self.children.items) |_child| {
		const child: GuiComponent = _child;
		const mutPos = child.mutPos();
		const size = child.size();
		switch (alignment) {
			.left => {},
			.center => {
				mutPos.*[0] = mutPos.*[0]/2 + self.size[0]/2 - size[0]/2;
			},
			.right => {
				mutPos.*[0] = self.size[0] - size[0];
			},
		}
	}
	if (self.size[1] > self.maxHeight) {
		self.scrollBarEnabled = true;
		self.childrenHeight = self.size[1];
		self.size[1] = self.maxHeight;
		self.scrollBar.pos = .{self.size[0] + border, border};
		self.size[0] += 2*border + scrollBarWidth;
	}
}

pub fn updateSelected(self: *VerticalList) void {
	for (self.children.items) |*child| {
		child.updateSelected();
	}
}

pub fn updateHovered(self: *VerticalList, mousePosition: Vec2f) void {
	var shiftedPos = self.pos;
	if (self.scrollBarEnabled) {
		const diff = self.childrenHeight - self.maxHeight;
		shiftedPos[1] -= diff*self.scrollBar.currentState;
	}
	var i: usize = self.children.items.len;
	while (i != 0) {
		i -= 1;
		const child = &self.children.items[i];
		if (GuiComponent.contains(child.pos() + shiftedPos, child.size(), mousePosition)) {
			child.updateHovered(mousePosition - shiftedPos);
			break;
		}
	}
	if (self.scrollBarEnabled) {
		const diff = self.childrenHeight - self.maxHeight;
		self.scrollBar.scroll(-main.Window.scrollOffset*32/diff);
		main.Window.scrollOffset = 0;
		if (GuiComponent.contains(self.scrollBar.pos, self.scrollBar.size, mousePosition - self.pos)) {
			self.scrollBar.updateHovered(mousePosition - self.pos);
		}
	}
}

pub fn render(self: *VerticalList, mousePosition: Vec2f) void {
	const oldTranslation = draw.setTranslation(self.pos);
	defer draw.restoreTranslation(oldTranslation);
	const oldClip = draw.setClip(self.size);
	defer draw.restoreClip(oldClip);
	var shiftedPos = self.pos;
	if (self.scrollBarEnabled) {
		const diff = self.childrenHeight - self.maxHeight;
		shiftedPos[1] -= diff*self.scrollBar.currentState;
		self.scrollBar.render(mousePosition - self.pos);
	}
	_ = draw.setTranslation(shiftedPos - self.pos);

	for (self.children.items) |*child| {
		const itemYPos = child.pos()[1];
		const adjustedYPos = itemYPos + shiftedPos[1] - self.pos[1];

		if (adjustedYPos + 2*child.size()[1] < 0 or adjustedYPos - child.size()[1] > self.maxHeight) {
			continue;
		}
		child.render(mousePosition - shiftedPos);
	}
}

pub fn mainButtonPressed(self: *VerticalList, mousePosition: Vec2f) void {
	var shiftedPos = self.pos;
	if (self.scrollBarEnabled) {
		const diff = self.childrenHeight - self.maxHeight;
		shiftedPos[1] -= diff*self.scrollBar.currentState;
		if (GuiComponent.contains(self.scrollBar.pos, self.scrollBar.size, mousePosition - self.pos)) {
			self.scrollBar.mainButtonPressed(mousePosition - self.pos);
			return;
		}
	}
	var selectedChild: ?*GuiComponent = null;
	for (self.children.items) |*child| {
		if (GuiComponent.contains(child.pos() + shiftedPos, child.size(), mousePosition)) {
			selectedChild = child;
		}
	}
	if (selectedChild) |child| {
		child.mainButtonPressed(mousePosition - shiftedPos);
	}
}

pub fn mainButtonReleased(self: *VerticalList, mousePosition: Vec2f) void {
	var shiftedPos = self.pos;
	if (self.scrollBarEnabled) {
		const diff = self.childrenHeight - self.maxHeight;
		shiftedPos[1] -= diff*self.scrollBar.currentState;
		self.scrollBar.mainButtonReleased(mousePosition - self.pos);
	}
	for (self.children.items) |*child| {
		child.mainButtonReleased(mousePosition - shiftedPos);
	}
}

```

`src/gui/gamepad_cursor.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("gui.zig");

const size: f32 = 16;

var texture: Texture = undefined;

pub fn init() void {
	texture = Texture.initFromFile("assets/cubyz/ui/gamepad_cursor.png");
}

pub fn deinit() void {
	texture.deinit();
}

pub fn render() void {
	if (main.Window.lastUsedMouse or main.Window.grabbed) return;
	texture.bindTo(0);
	graphics.draw.setColor(0xffffffff);
	const mousePos = main.Window.getMousePosition();
	graphics.draw.boundImage(@as(Vec2f, @splat(-size/2.0)) + (mousePos/@as(Vec2f, @splat(gui.scale))), .{size, size});
}

```

`src/gui/gui.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const ZonElement = main.ZonElement;
const settings = main.settings;
const vec = main.vec;
const Vec2f = vec.Vec2f;
const List = main.List;

const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const Button = @import("components/Button.zig");
const CheckBox = @import("components/CheckBox.zig");
const ItemSlot = @import("components/ItemSlot.zig");
const ScrollBar = @import("components/ScrollBar.zig");
const ContinuousSlider = @import("components/ContinuousSlider.zig");
const DiscreteSlider = @import("components/DiscreteSlider.zig");
const TextInput = @import("components/TextInput.zig");
pub const GuiComponent = @import("gui_component.zig").GuiComponent;
pub const GuiWindow = @import("GuiWindow.zig");

pub const windowlist = @import("windows/_windowlist.zig");
const GamepadCursor = @import("gamepad_cursor.zig");

var windowList: List(*GuiWindow) = undefined;
var hudWindows: List(*GuiWindow) = undefined;
pub var openWindows: List(*GuiWindow) = undefined;
var selectedWindow: ?*GuiWindow = null;
pub var selectedTextInput: ?*TextInput = null;
var hoveredAWindow: bool = false;
pub var reorderWindows: bool = false;
pub var hideGui: bool = false;

pub var scale: f32 = undefined;

pub var hoveredItemSlot: ?*ItemSlot = null;

const GuiCommandQueue = struct { // MARK: GuiCommandQueue
	const Action = enum {
		open,
		close,
	};
	const Command = struct {
		window: *GuiWindow,
		action: Action,
	};

	var commands: main.utils.ConcurrentQueue(Command) = undefined;

	fn init() void {
		commands = .init(main.globalAllocator, 16);
	}

	fn deinit() void {
		commands.deinit();
	}

	fn scheduleCommand(command: Command) void {
		commands.pushBack(command);
	}

	fn executeCommands() void {
		while (commands.popFront()) |command| {
			switch (command.action) {
				.open => {
					executeOpenWindowCommand(command.window);
				},
				.close => {
					executeCloseWindowCommand(command.window);
				},
			}
		}
	}

	fn executeOpenWindowCommand(window: *GuiWindow) void {
		defer updateWindowPositions();
		for (openWindows.items, 0..) |_openWindow, i| {
			if (_openWindow == window) {
				_ = openWindows.orderedRemove(i);
				openWindows.appendAssumeCapacity(window);
				selectedWindow = null;
				return;
			}
		}
		openWindows.append(window);
		window.onOpenFn();
		selectedWindow = null;
	}

	fn executeCloseWindowCommand(window: *GuiWindow) void {
		defer updateWindowPositions();
		if (selectedWindow == window) {
			selectedWindow = null;
		}
		for (openWindows.items, 0..) |_openWindow, i| {
			if (_openWindow == window) {
				_ = openWindows.orderedRemove(i);
				window.onCloseFn();
				break;
			}
		}
	}
};

pub fn initWindowList() void {
	GuiCommandQueue.init();
	windowList = .init(main.globalAllocator);
	hudWindows = .init(main.globalAllocator);
	openWindows = .init(main.globalAllocator);
	inline for (@typeInfo(windowlist).@"struct".decls) |decl| {
		const windowStruct = @field(windowlist, decl.name);
		windowStruct.window.id = decl.name;
		addWindow(&windowStruct.window);
		const functionNames = [_][]const u8{"render", "update", "updateSelected", "updateHovered", "onOpen", "onClose"};
		inline for (functionNames) |function| {
			if (@hasDecl(windowStruct, function)) {
				@field(windowStruct.window, function ++ "Fn") = &@field(windowStruct, function);
			}
		}
	}
}

pub fn deinitWindowList() void {
	windowList.clearAndFree();
	hudWindows.deinit();
	openWindows.deinit();
	GuiCommandQueue.deinit();
}

pub fn init() void { // MARK: init()
	inline for (@typeInfo(windowlist).@"struct".decls) |decl| {
		const windowStruct = @field(windowlist, decl.name);
		if (@hasDecl(windowStruct, "init")) {
			windowStruct.init();
		}
	}
	GuiWindow.__init();
	Button.__init();
	CheckBox.__init();
	ItemSlot.__init();
	ScrollBar.__init();
	ContinuousSlider.__init();
	DiscreteSlider.__init();
	TextInput.__init();
	load();
	GamepadCursor.init();
}

pub fn deinit() void {
	save();
	GamepadCursor.deinit();
	for (openWindows.items) |window| {
		window.onCloseFn();
	}
	openWindows.clearRetainingCapacity();
	GuiWindow.__deinit();
	Button.__deinit();
	CheckBox.__deinit();
	ItemSlot.__deinit();
	ScrollBar.__deinit();
	ContinuousSlider.__deinit();
	DiscreteSlider.__deinit();
	TextInput.__deinit();
	inline for (@typeInfo(windowlist).@"struct".decls) |decl| {
		const WindowStruct = @field(windowlist, decl.name);
		if (@hasDecl(WindowStruct, "deinit")) {
			WindowStruct.deinit();
		}
	}
}

pub fn save() void { // MARK: save()
	var guiZon = ZonElement.initObject(main.stackAllocator);
	defer guiZon.deinit(main.stackAllocator);
	for (windowList.items) |window| {
		const windowZon = ZonElement.initObject(main.stackAllocator);
		for (window.relativePosition, 0..) |relPos, i| {
			const relPosZon = ZonElement.initObject(main.stackAllocator);
			switch (relPos) {
				.ratio => |ratio| {
					relPosZon.put("type", "ratio");
					relPosZon.put("ratio", ratio);
				},
				.attachedToFrame => |attachedToFrame| {
					relPosZon.put("type", "attachedToFrame");
					relPosZon.put("selfAttachmentPoint", @intFromEnum(attachedToFrame.selfAttachmentPoint));
					relPosZon.put("otherAttachmentPoint", @intFromEnum(attachedToFrame.otherAttachmentPoint));
				},
				.relativeToWindow => |relativeToWindow| {
					relPosZon.put("type", "relativeToWindow");
					relPosZon.put("reference", relativeToWindow.reference.id);
					relPosZon.put("ratio", relativeToWindow.ratio);
				},
				.attachedToWindow => |attachedToWindow| {
					relPosZon.put("type", "attachedToWindow");
					relPosZon.put("reference", attachedToWindow.reference.id);
					relPosZon.put("selfAttachmentPoint", @intFromEnum(attachedToWindow.selfAttachmentPoint));
					relPosZon.put("otherAttachmentPoint", @intFromEnum(attachedToWindow.otherAttachmentPoint));
				},
			}
			windowZon.put(([_][]const u8{"relPos0", "relPos1"})[i], relPosZon);
		}
		windowZon.put("scale", window.scale);
		guiZon.put(window.id, windowZon);
	}

	// Merge with the old settings file to preserve unknown settings.
	var oldZon: ZonElement = main.files.cubyzDir().readToZon(main.stackAllocator, "gui_layout.zig.zon") catch |err| blk: {
		if (err != error.FileNotFound) {
			std.log.err("Could not read gui_layout.zig.zon: {s}", .{@errorName(err)});
		}
		break :blk .null;
	};
	defer oldZon.deinit(main.stackAllocator);

	if (oldZon == .object) {
		guiZon.join(.preferLeft, oldZon);
	}

	main.files.cubyzDir().writeZon("gui_layout.zig.zon", guiZon) catch |err| {
		std.log.err("Could not write gui_layout.zig.zon: {s}", .{@errorName(err)});
	};
}

fn load() void {
	const zon: ZonElement = main.files.cubyzDir().readToZon(main.stackAllocator, "gui_layout.zig.zon") catch |err| blk: {
		if (err != error.FileNotFound) {
			std.log.err("Could not read gui_layout.zig.zon: {s}", .{@errorName(err)});
		}
		break :blk .null;
	};
	defer zon.deinit(main.stackAllocator);

	for (windowList.items) |window| {
		const windowZon = zon.getChild(window.id);
		if (windowZon == .null) continue;
		for (&window.relativePosition, 0..) |*relPos, i| {
			const relPosZon = windowZon.getChild(([_][]const u8{"relPos0", "relPos1"})[i]);
			const typ = relPosZon.get([]const u8, "type", "ratio");
			if (std.mem.eql(u8, typ, "ratio")) {
				relPos.* = .{.ratio = relPosZon.get(f32, "ratio", 0.5)};
			} else if (std.mem.eql(u8, typ, "attachedToFrame")) {
				relPos.* = .{.attachedToFrame = .{
					.selfAttachmentPoint = @enumFromInt(relPosZon.get(u8, "selfAttachmentPoint", 0)),
					.otherAttachmentPoint = @enumFromInt(relPosZon.get(u8, "otherAttachmentPoint", 0)),
				}};
			} else if (std.mem.eql(u8, typ, "relativeToWindow")) {
				const reference = getWindowById(relPosZon.get([]const u8, "reference", "")) orelse continue;
				relPos.* = .{.relativeToWindow = .{
					.reference = reference,
					.ratio = relPosZon.get(f32, "ratio", 0.5),
				}};
			} else if (std.mem.eql(u8, typ, "attachedToWindow")) {
				const reference = getWindowById(relPosZon.get([]const u8, "reference", "")) orelse continue;
				relPos.* = .{.attachedToWindow = .{
					.reference = reference,
					.selfAttachmentPoint = @enumFromInt(relPosZon.get(u8, "selfAttachmentPoint", 0)),
					.otherAttachmentPoint = @enumFromInt(relPosZon.get(u8, "otherAttachmentPoint", 0)),
				}};
			} else {
				std.log.err("Unknown window attachment type: {s}", .{typ});
			}
		}
		window.scale = windowZon.get(f32, "scale", 1);
	}
}

fn getWindowById(id: []const u8) ?*GuiWindow {
	for (windowList.items) |window| {
		if (std.mem.eql(u8, id, window.id)) {
			return window;
		}
	}
	std.log.err("Could not find window with id: {s}", .{id});
	return null;
}

pub fn updateGuiScale() void {
	if (settings.guiScale) |guiScale| {
		scale = guiScale;
	} else {
		const windowSize = main.Window.getWindowSize();
		const screenWidth = @min(windowSize[0], windowSize[1]*16/9);
		scale = @floor(screenWidth/640.0 + 0.2);
		if (scale < 1) {
			scale = 0.5;
		}
	}
}

fn addWindow(window: *GuiWindow) void {
	for (windowList.items) |other| {
		if (std.mem.eql(u8, window.id, other.id)) {
			std.log.err("Duplicate window id: {s}", .{window.id});
			return;
		}
	}
	if (window.isHud) {
		hudWindows.append(window);
	}
	windowList.append(window);
}

pub fn openWindow(id: []const u8) void {
	defer updateWindowPositions();

	for (windowList.items) |window| {
		if (std.mem.eql(u8, window.id, id)) {
			openWindowFromRef(window);
			return;
		}
	}

	std.log.err("Could not find window with id {s}.", .{id});
}

pub fn openWindowFromRef(window: *GuiWindow) void {
	GuiCommandQueue.scheduleCommand(.{.action = .open, .window = window});
}

pub fn toggleWindow(id: []const u8) void {
	defer updateWindowPositions();
	for (windowList.items) |window| {
		if (std.mem.eql(u8, window.id, id)) {
			for (openWindows.items, 0..) |_openWindow, i| {
				if (_openWindow == window) {
					_ = openWindows.swapRemove(i);
					window.onCloseFn();
					selectedWindow = null;
					return;
				}
			}
			openWindows.append(window);
			window.onOpenFn();
			selectedWindow = null;
			return;
		}
	}
	std.log.err("Could not find window with id {s}.", .{id});
}

pub fn openHud() void {
	inventory.init();
	for (windowList.items) |window| {
		if (window.isHud) {
			openWindowFromRef(window);
		}
	}
	reorderWindows = false;
}

pub fn openWindowCallback(comptime id: []const u8) main.callbacks.SimpleCallback {
	return .initWithPtr(openWindowFromRef, &@field(windowlist, id).window);
}

pub fn closeWindowFromRef(window: *GuiWindow) void {
	GuiCommandQueue.scheduleCommand(.{.action = .close, .window = window});
}

pub fn closeWindow(id: []const u8) void {
	for (windowList.items) |window| {
		if (std.mem.eql(u8, window.id, id)) {
			closeWindowFromRef(window);
			return;
		}
	}
	std.log.err("Could not find window with id {s}.", .{id});
}

pub fn isWindowOpen(id: []const u8) bool {
	for (openWindows.items) |window| {
		if (std.mem.eql(u8, window.id, id)) return true;
	}
	return false;
}

pub fn setSelectedTextInput(newSelectedTextInput: ?*TextInput) void {
	if (selectedTextInput) |current| {
		if (current != newSelectedTextInput) {
			current.deselect();
		}
	}
	selectedTextInput = newSelectedTextInput;
}

pub const textCallbacks = struct {
	pub fn char(codepoint: u21) void {
		if (selectedTextInput) |current| {
			current.inputCharacter(codepoint);
		}
	}
	pub fn left(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.left(mods);
		}
	}
	pub fn right(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.right(mods);
		}
	}
	pub fn down(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.down(mods);
		}
	}
	pub fn up(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.up(mods);
		}
	}
	pub fn gotoStart(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.gotoStart(mods);
		}
	}
	pub fn gotoEnd(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.gotoEnd(mods);
		}
	}
	pub fn deleteLeft(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.deleteLeft(mods);
		}
	}
	pub fn deleteRight(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.deleteRight(mods);
		}
	}
	pub fn selectAll(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.selectAll(mods);
		}
	}
	pub fn copy(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.copy(mods);
		}
	}
	pub fn paste(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.paste(mods);
		}
	}
	pub fn cut(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.cut(mods);
		}
	}
	pub fn newline(mods: main.Window.Key.Modifiers) void {
		if (selectedTextInput) |current| {
			current.newline(mods);
		}
	}
};

pub fn mainButtonPressed(_: main.Window.Key.Modifiers) void {
	inventory.update();
	selectedWindow = null;
	setSelectedTextInput(null);
	var selectedI: usize = 0;
	for (openWindows.items, 0..) |window, i| {
		var mousePosition = main.Window.getMousePosition()/@as(Vec2f, @splat(scale));
		mousePosition -= window.pos;
		if (@reduce(.And, mousePosition >= Vec2f{0, 0}) and @reduce(.And, mousePosition < window.size)) {
			selectedWindow = window;
			selectedI = i;
		}
	}
	if (selectedWindow) |_selectedWindow| {
		const mousePosition = main.Window.getMousePosition()/@as(Vec2f, @splat(scale));
		_selectedWindow.mainButtonPressed(mousePosition);
		_ = openWindows.orderedRemove(selectedI);
		openWindows.appendAssumeCapacity(_selectedWindow);
	} else if (main.game.world != null and inventory.carried.getItem(0) == .null) {
		toggleGameMenu();
	}
}

pub fn mainButtonReleased(_: main.Window.Key.Modifiers) void {
	inventory.applyChanges(true);
	const oldWindow = selectedWindow;
	selectedWindow = null;
	for (openWindows.items) |window| {
		var mousePosition = main.Window.getMousePosition()/@as(Vec2f, @splat(scale));
		mousePosition -= window.pos;
		if (@reduce(.And, mousePosition >= Vec2f{0, 0}) and @reduce(.And, mousePosition < window.size)) {
			selectedWindow = window;
		}
	}
	if (selectedWindow != oldWindow) { // Unselect the window if the mouse left it.
		selectedWindow = null;
	}
	if (oldWindow) |_oldWindow| {
		const mousePosition = main.Window.getMousePosition()/@as(Vec2f, @splat(scale));
		_oldWindow.mainButtonReleased(mousePosition);
	}
}

pub fn secondaryButtonPressed(_: main.Window.Key.Modifiers) void {
	inventory.update();
}

pub fn secondaryButtonReleased(_: main.Window.Key.Modifiers) void {
	inventory.applyChanges(false);
}

pub fn updateWindowPositions() void {
	var wasChanged: bool = true;
	while (wasChanged) {
		wasChanged = false;
		for (windowList.items) |window| {
			const oldPos = window.pos;
			window.updateWindowPosition();
			const newPos = window.pos;
			if (vec.lengthSquare(oldPos - newPos) >= 1e-3) {
				wasChanged = true;
			}
		}
	}
}

pub fn updateAndRenderGui() void {
	const mousePos = main.Window.getMousePosition()/@as(Vec2f, @splat(scale));
	hoveredAWindow = false;
	GuiCommandQueue.executeCommands();
	if (!main.Window.grabbed) {
		if (selectedWindow) |selected| {
			selected.updateSelected(mousePos);
		}
		hoveredItemSlot = null;
		var i: usize = openWindows.items.len;
		while (i != 0) {
			i -= 1;
			const window: *GuiWindow = openWindows.items[i];
			if (GuiComponent.contains(window.pos, window.size, mousePos)) {
				window.updateHovered(mousePos);
				hoveredAWindow = true;
				break;
			}
		}
		inventory.update();
	}
	for (openWindows.items) |window| {
		window.update();
	}
	if (!hideGui) {
		if (!main.Window.grabbed) {
			draw.setColor(0x80000000);
			GuiWindow.borderPipeline.bind(draw.getScissor());
			graphics.c.glUniform2f(GuiWindow.borderUniforms.effectLength, main.Window.getWindowSize()[0]/6, main.Window.getWindowSize()[1]/6);
			draw.customShadedRect(GuiWindow.borderUniforms, .{0, 0}, main.Window.getWindowSize());
		}
		const oldScale = draw.setScale(scale);
		defer draw.restoreScale(oldScale);
		for (openWindows.items) |window| {
			window.render(mousePos);
		}
		inventory.render(mousePos);
	}
	const oldScale = draw.setScale(scale);
	defer draw.restoreScale(oldScale);
	GamepadCursor.render();
}

pub fn toggleGameMenu() void {
	main.Window.setMouseGrabbed(!main.Window.grabbed);
	if (!main.Window.grabbed) {
		hideGui = false;
	} else { // Take of the currently held item stack and close some windows
		inventory.carried.depositOrDrop(&.{main.game.Player.inventory});
		hoveredItemSlot = null;
		var i: usize = 0;
		while (i < openWindows.items.len) {
			const window = openWindows.items[i];
			if (window.closeIfMouseIsGrabbed) {
				_ = openWindows.swapRemove(i);
				window.onCloseFn();
			} else {
				i += 1;
			}
		}
		reorderWindows = false;
		selectedWindow = null;
	}
}

pub const inventory = struct { // MARK: inventory
	const ItemStack = main.items.ItemStack;
	const ClientInventory = main.items.Inventory.ClientInventory;
	pub var carried: ClientInventory = undefined;
	var carriedItemSlot: *ItemSlot = undefined;
	var leftClickSlots: List(*ItemSlot) = .init(main.globalAllocator);
	var rightClickSlots: List(*ItemSlot) = .init(main.globalAllocator);
	var recipeItem: main.items.Item = .null;
	var initialized: bool = false;
	const minCraftingCooldown: std.Io.Duration = .fromMilliseconds(20);
	const maxCraftingCooldown: std.Io.Duration = .fromMilliseconds(400);
	var nextCraftingAction: std.Io.Timestamp = undefined;
	var craftingCooldown: std.Io.Duration = undefined;
	var isCrafting: bool = false;

	pub fn init() void {
		carried = ClientInventory.init(main.globalAllocator, 1, .normal, .serverShared, .{.hand = main.game.Player.id}, .{});
		carriedItemSlot = ItemSlot.init(.{0, 0}, carried, 0, .default, .normal);
		carriedItemSlot.renderFrame = false;
		initialized = true;
		isCrafting = false;
	}

	pub fn deinit() void {
		initialized = false;
		carried.deinit(main.globalAllocator);
		carriedItemSlot.deinit();
		leftClickSlots.clearAndFree();
		rightClickSlots.clearAndFree();
	}

	pub fn deleteItemSlotReferences(slot: *const ItemSlot) void {
		if (slot == hoveredItemSlot) {
			hoveredItemSlot = null;
		}
		var i: usize = 0;
		while (i < leftClickSlots.items.len) {
			if (leftClickSlots.items[i] == slot) {
				_ = leftClickSlots.swapRemove(i);
				continue;
			}
			i += 1;
		}
		i = 0;
		while (i < rightClickSlots.items.len) {
			if (rightClickSlots.items[i] == slot) {
				_ = rightClickSlots.swapRemove(i);
				continue;
			}
			i += 1;
		}
	}

	fn update() void {
		if (!initialized) return;
		const itemSlot = hoveredItemSlot orelse {
			isCrafting = false;
			return;
		};
		if (itemSlot.mode == .immutable) return;
		const mainGuiButton = main.KeyBoard.key("mainGuiButton");
		const secondaryGuiButton = main.KeyBoard.key("secondaryGuiButton");
		if (itemSlot.inventory.type == .crafting and itemSlot.mode == .takeOnly and mainGuiButton.pressed and (recipeItem != .null or itemSlot.pressed)) {
			const item = itemSlot.inventory.getItem(itemSlot.itemSlot);
			if (recipeItem == .null and item != .null) recipeItem = item.clone();
			if (!std.meta.eql(item, recipeItem)) return;
			const time = main.timestamp();
			if (!isCrafting) {
				isCrafting = true;
				craftingCooldown = maxCraftingCooldown;
				nextCraftingAction = time;
			}
			while (time.durationTo(nextCraftingAction).nanoseconds <= 0) {
				nextCraftingAction = nextCraftingAction.addDuration(craftingCooldown);
				craftingCooldown.nanoseconds -= @divTrunc((craftingCooldown.nanoseconds -% minCraftingCooldown.nanoseconds)*craftingCooldown.nanoseconds, std.time.ns_per_s);
				if (mainGuiButton.modsOnPress.shift) {
					main.game.Player.inventory.craftFrom(&.{main.game.Player.inventory}, itemSlot.inventory);
				} else {
					main.game.Player.inventory.craftFrom(&.{carried}, itemSlot.inventory);
				}
			}
			return;
		}

		isCrafting = false;

		if (recipeItem != .null) return;
		if (itemSlot.mode != .normal) return;

		if (mainGuiButton.pressed and mainGuiButton.modsOnPress.shift) {
			if (itemSlot.inventory.super.id == main.game.Player.inventory.super.id) {
				var iterator = std.mem.reverseIterator(openWindows.items);
				while (iterator.next()) |window| {
					if (window.shiftClickableInventory) |inv| {
						itemSlot.inventory.depositToAny(itemSlot.itemSlot, &.{inv}, itemSlot.inventory.getAmount(itemSlot.itemSlot));
						break;
					}
				}
			} else {
				itemSlot.inventory.depositToAny(itemSlot.itemSlot, &.{main.game.Player.inventory}, itemSlot.inventory.getAmount(itemSlot.itemSlot));
			}
			return;
		}

		if (carried.getAmount(0) == 0) return;
		if (mainGuiButton.pressed) {
			for (leftClickSlots.items) |deliveredSlot| {
				if (itemSlot == deliveredSlot) return;
			}
			const item = itemSlot.inventory.getItem(itemSlot.itemSlot);
			if (item == .null or (std.meta.eql(item, carried.getItem(0))) and itemSlot.inventory.getAmount(itemSlot.itemSlot) != item.stackSize()) {
				leftClickSlots.append(itemSlot);
			}
		} else if (secondaryGuiButton.pressed) {
			for (rightClickSlots.items) |deliveredSlot| {
				if (itemSlot == deliveredSlot) return;
			}
			itemSlot.inventory.deposit(itemSlot.itemSlot, carried, 0, 1);
			rightClickSlots.append(itemSlot);
		}
	}

	fn applyChanges(leftClick: bool) void {
		if (!initialized) return;
		if (main.game.world == null) return;
		if (leftClick) {
			recipeItem.deinit();
			recipeItem = .null;
			isCrafting = false;
			if (leftClickSlots.items.len != 0) {
				const targetInventories = main.stackAllocator.alloc(ClientInventory, leftClickSlots.items.len);
				defer main.stackAllocator.free(targetInventories);
				const targetSlots = main.stackAllocator.alloc(u32, leftClickSlots.items.len);
				defer main.stackAllocator.free(targetSlots);
				for (0..leftClickSlots.items.len) |i| {
					targetInventories[i] = leftClickSlots.items[i].inventory;
					targetSlots[i] = leftClickSlots.items[i].itemSlot;
				}
				carried.distribute(targetInventories, targetSlots);
				leftClickSlots.clearRetainingCapacity();
			} else if (hoveredItemSlot) |hovered| {
				if (hovered.inventory.type == .crafting) return;
				hovered.inventory.depositOrSwap(hovered.itemSlot, carried);
			} else if (!hoveredAWindow) {
				carried.dropStack(0);
			}
		} else {
			if (rightClickSlots.items.len != 0) {
				rightClickSlots.clearRetainingCapacity();
			} else if (hoveredItemSlot) |hovered| {
				if (hovered.inventory.type == .crafting) return;
				if (hovered.inventory.type == .creative) {
					carried.deposit(0, hovered.inventory, hovered.itemSlot, 1);
				} else {
					hovered.inventory.takeHalf(hovered.itemSlot, carried);
				}
			} else if (!hoveredAWindow) {
				carried.dropOne(0);
			}
		}
	}

	fn render(mousePos: Vec2f) void {
		if (!initialized) return;
		carriedItemSlot.pos = mousePos - Vec2f{12, 12};
		carriedItemSlot.render(.{0, 0});
		// Draw tooltip:
		if (carried.getAmount(0) == 0) if (hoveredItemSlot) |hovered| {
			if (hovered.inventory.getItem(hovered.itemSlot).getTooltip()) |tooltip| {
				var textBuffer = graphics.TextBuffer.init(main.stackAllocator, tooltip, .{}, false, .left);
				defer textBuffer.deinit();
				const fontSize = 16;
				var size = textBuffer.calculateLineBreaks(fontSize, 300);
				size[0] = 0;
				for (textBuffer.lineBreaks.items) |lineBreak| {
					size[0] = @max(size[0], lineBreak.width);
				}
				const windowSize = main.Window.getWindowSize()/@as(Vec2f, @splat(scale));
				const xOffset = 18;
				const padding: f32 = 1;
				const border: f32 = padding + 1;
				var pos = mousePos;
				if (pos[0] + size[0] + border + xOffset >= windowSize[0]) {
					pos[0] -= size[0] + xOffset;
				} else {
					pos[0] += xOffset;
				}
				pos[1] = @min(pos[1] - fontSize, windowSize[1] - size[1] - border);
				pos = @max(pos, Vec2f{border, border});
				draw.setColor(0xffffff00);
				draw.rect(pos - @as(Vec2f, @splat(border)), size + @as(Vec2f, @splat(2*border)));
				draw.setColor(0xff000000);
				draw.rect(pos - @as(Vec2f, @splat(padding)), size + @as(Vec2f, @splat(2*padding)));
				textBuffer.render(pos[0], pos[1], fontSize);
			}
		};
	}
};

```

`src/gui/gui_component.zig`:

```zig
const std = @import("std");

const main = @import("main");
const vec = main.vec;
const Vec2f = vec.Vec2f;

pub const GuiComponent = union(enum) {
	pub const Button = @import("components/Button.zig");
	pub const CheckBox = @import("components/CheckBox.zig");
	pub const HorizontalList = @import("components/HorizontalList.zig");
	pub const Icon = @import("components/Icon.zig");
	pub const ItemSlot = @import("components/ItemSlot.zig");
	pub const Label = @import("components/Label.zig");
	pub const MutexComponent = @import("components/MutexComponent.zig");
	pub const ScrollBar = @import("components/ScrollBar.zig");
	pub const ContinuousSlider = @import("components/ContinuousSlider.zig");
	pub const DiscreteSlider = @import("components/DiscreteSlider.zig");
	pub const TextInput = @import("components/TextInput.zig");
	pub const VerticalList = @import("components/VerticalList.zig");

	button: *Button,
	checkBox: *CheckBox,
	horizontalList: *HorizontalList,
	icon: *Icon,
	itemSlot: *ItemSlot,
	label: *Label,
	mutexComponent: *MutexComponent,
	scrollBar: *ScrollBar,
	continuousSlider: *ContinuousSlider,
	discreteSlider: *DiscreteSlider,
	textInput: *TextInput,
	verticalList: *VerticalList,

	pub fn deinit(self: GuiComponent) void {
		switch (self) {
			inline else => |impl| {
				if (@hasDecl(@TypeOf(impl.*), "deinit")) {
					impl.deinit();
				}
			},
		}
	}

	pub fn mutPos(self: GuiComponent) *Vec2f {
		switch (self) {
			inline else => |impl| {
				return &impl.pos;
			},
		}
	}

	pub fn mutSize(self: GuiComponent) *Vec2f {
		switch (self) {
			inline else => |impl| {
				return &impl.size;
			},
		}
	}

	pub fn pos(self: GuiComponent) Vec2f {
		switch (self) {
			inline else => |impl| {
				return impl.pos;
			},
		}
	}

	pub fn size(self: GuiComponent) Vec2f {
		switch (self) {
			inline else => |impl| {
				return impl.size;
			},
		}
	}

	pub fn updateSelected(self: GuiComponent) void {
		switch (self) {
			inline else => |impl| {
				if (@hasDecl(@TypeOf(impl.*), "updateSelected")) {
					impl.updateSelected();
				}
			},
		}
	}

	pub fn updateHovered(self: GuiComponent, mousePosition: Vec2f) void {
		switch (self) {
			inline else => |impl| {
				if (@hasDecl(@TypeOf(impl.*), "updateHovered")) {
					impl.updateHovered(mousePosition);
				}
			},
		}
	}

	pub fn render(self: GuiComponent, mousePosition: Vec2f) void {
		switch (self) {
			inline else => |impl| {
				if (@hasDecl(@TypeOf(impl.*), "render")) {
					impl.render(mousePosition);
				}
			},
		}
	}

	pub fn mainButtonPressed(self: GuiComponent, mousePosition: Vec2f) void {
		switch (self) {
			inline else => |impl| {
				if (@hasDecl(@TypeOf(impl.*), "mainButtonPressed")) {
					impl.mainButtonPressed(mousePosition);
				}
			},
		}
	}

	pub fn mainButtonReleased(self: GuiComponent, mousePosition: Vec2f) void {
		switch (self) {
			inline else => |impl| {
				if (@hasDecl(@TypeOf(impl.*), "mainButtonReleased")) {
					impl.mainButtonReleased(mousePosition);
				}
			},
		}
	}

	pub fn contains(_pos: Vec2f, _size: Vec2f, point: Vec2f) bool {
		return @reduce(.And, point >= _pos) and @reduce(.And, point < _pos + _size);
	}
};

```

`src/gui/windows/_windowlist.zig`:

```zig
pub const advanced_controls = @import("advanced_controls.zig");
pub const change_name = @import("change_name.zig");
pub const chat = @import("chat.zig");
pub const chest = @import("chest.zig");
pub const clipboard_deleted = @import("clipboard_deleted.zig");
pub const controls = @import("controls.zig");
pub const creative_inventory = @import("creative_inventory.zig");
pub const crosshair = @import("crosshair.zig");
pub const debug_network = @import("debug_network.zig");
pub const debug_network_advanced = @import("debug_network_advanced.zig");
pub const debug = @import("debug.zig");
pub const delete_world_confirmation = @import("delete_world_confirmation.zig");
pub const download_controller_mappings = @import("download_controller_mappings.zig");
pub const energybar = @import("energybar.zig");
pub const error_prompt = @import("error_prompt.zig");
pub const gpu_performance_measuring = @import("gpu_performance_measuring.zig");
pub const graphics = @import("graphics.zig");
pub const healthbar = @import("healthbar.zig");
pub const hotbar = @import("hotbar.zig");
pub const inventory = @import("inventory.zig");
pub const inventory_crafting = @import("inventory_crafting.zig");
pub const invite = @import("invite.zig");
pub const main = @import("main.zig");
pub const manage_players = @import("manage_players.zig");
pub const multiplayer = @import("multiplayer.zig");
pub const notification = @import("notification.zig");
pub const pause = @import("pause.zig");
pub const pause_gear = @import("pause_gear.zig");
pub const performance_graph = @import("performance_graph.zig");
pub const save_creation = @import("save_creation.zig");
pub const save_selection = @import("save_selection.zig");
pub const settings = @import("settings.zig");
pub const sign_editor = @import("sign_editor.zig");
pub const social = @import("social.zig");
pub const sound = @import("sound.zig");
pub const workbench = @import("workbench.zig");

pub const @"authentication/create_account" = @import("authentication/create_account.zig");
pub const @"authentication/login" = @import("authentication/login.zig");
pub const @"authentication/unlock" = @import("authentication/unlock.zig");

```

`src/gui/windows/advanced_controls.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const CheckBox = @import("../components/CheckBox.zig");
const ContinuousSlider = @import("../components/ContinuousSlider.zig");
const DiscreteSlider = @import("../components/DiscreteSlider.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;

fn delayCallback(newValue: f32) void {
	settings.updateRepeatDelay.nanoseconds = @intFromFloat(newValue);
	settings.save();
}

fn delayFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "#ffffffPlace/Break Delay: {d:.0} ms", .{value/1.0e6}) catch unreachable;
}

fn speedCallback(newValue: f32) void {
	settings.updateRepeatSpeed.nanoseconds = @intFromFloat(newValue);
	settings.save();
}

fn speedFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "#ffffffPlace/Break Speed: {d:.0} ms", .{value/1.0e6}) catch unreachable;
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(ContinuousSlider.init(.{0, 0}, 128, 1.0e6, 1.0e9, @floatFromInt(settings.updateRepeatDelay.nanoseconds), &delayCallback, &delayFormatter));
	list.add(ContinuousSlider.init(.{0, 0}, 128, 1.0e6, 0.5e9, @floatFromInt(settings.updateRepeatSpeed.nanoseconds), &speedCallback, &speedFormatter));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/authentication/create_account.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = main.gui;
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const CheckBox = GuiComponent.CheckBox;
const HorizontalList = GuiComponent.HorizontalList;
const Label = GuiComponent.Label;
const TextInput = GuiComponent.TextInput;
const VerticalList = GuiComponent.VerticalList;

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
	.closeable = false,
};

const padding: f32 = 8;

var accountCodeLabel: *Label = undefined;
var accountCode: main.network.authentication.AccountCode = undefined;

fn next() void {
	gui.closeWindowFromRef(&window);
	gui.openWindow("authentication/login");
}

fn copy() void {
	main.Window.setClipboardString(accountCode.text);
}

pub fn onOpen() void {
	accountCode = .initRandomly();

	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	const width = 420;
	list.add(Label.init(.{0, 0}, width, "This is your Account Code:", .left));
	const row = HorizontalList.init();
	accountCodeLabel = Label.init(.{0, 0}, 350, accountCode.text, .left);
	row.add(accountCodeLabel);
	row.add(Button.initText(.{0, 0}, 70, "Copy", .init(copy)));
	list.add(row);
	list.add(Label.init(.{0, 0}, width, "Note: Do not give this to anyone else. We will only ask for the Account Code on the start of the game.", .left));
	list.add(Label.init(.{0, 0}, width, "Note 2: Make sure you store this somewhere safely and securely, there is no recovery option if you lose it. We recommend a password manager.", .left));
	list.add(Button.initText(.{0, 0}, 300, "Return to login (clears clipboard)", .init(next)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	// Make sure there remains no trace of the account code in memory
	main.network.authentication.secureZero(@TypeOf(accountCodeLabel.text.glyphs[0]), accountCodeLabel.text.glyphs);
	accountCode.deinit();
	// This also serves as a measure to ensure that the user indeed copied it somewhere else before closing the window
	main.Window.setClipboardString("");
	gui.openWindow("clipboard_deleted");

	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/authentication/login.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = main.gui;
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const CheckBox = GuiComponent.CheckBox;
const Label = GuiComponent.Label;
const HorizontalList = GuiComponent.HorizontalList;
const TextInput = GuiComponent.TextInput;
const VerticalList = GuiComponent.VerticalList;

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
	.closeable = false,
};
var textComponent: *TextInput = undefined;
var loginButton: *Button = undefined;
var loginAnyways: bool = false;

var innerList: *VerticalList = undefined;
var encryptWithPasswordCheckbox: *CheckBox = undefined;
var passwordTextField: *TextInput = undefined;
var passwordRow: *HorizontalList = undefined;

var storeAccountCode: bool = false;
var encryptAccountCode: bool = true;

const padding: f32 = 8;

fn login() void {
	var failureText: main.List(u8) = .init(main.stackAllocator);
	defer failureText.deinit();
	const accountCode = main.network.authentication.AccountCode.initFromUserInput(textComponent.currentString.items, &failureText);
	defer accountCode.deinit();

	if (accountCode.text.len == 0) {
		main.gui.windowlist.notification.raiseNotification("Account Code is empty. Please enter a valid Account Code.", .{});
		return;
	}

	if (failureText.items.len != 0 and !loginAnyways) {
		failureText.insertSlice(0, "Encountered errors while verifying your Account. This may happen if you created your account in a future version, in which case it's fine to continue.\n\n");

		main.gui.windowlist.notification.raiseNotification("{s}", .{failureText.items});

		loginAnyways = true;
		loginButton.child.label.updateText("Login anyways");

		return;
	}

	if (storeAccountCode) {
		if (encryptAccountCode) {
			settings.storedAccount.deinit(main.globalAllocator);
			settings.storedAccount = .initFromPassword(main.globalAllocator, accountCode, passwordTextField.currentString.items);
		} else {
			settings.storedAccount.deinit(main.globalAllocator);
			settings.storedAccount = .initUnencoded(main.globalAllocator, accountCode);
		}
		settings.save();
	}

	main.network.authentication.KeyCollection.init(accountCode);

	gui.closeWindowFromRef(&window);
	if (settings.playerName.len == 0) {
		gui.openWindow("change_name");
	} else {
		gui.openWindow("main");
	}
}

fn updateText() void {
	loginAnyways = false;
	loginButton.child.label.updateText("Login");
}

fn showTextCallback(showText: bool) void {
	textComponent.obfuscated = !showText;
}

fn storeAccountCodeCallback(storeAccountCode_: bool) void {
	storeAccountCode = storeAccountCode_;
	refreshInner();
}

fn encryptAccountCodeCallback(encryptAccountCode_: bool) void {
	encryptAccountCode = encryptAccountCode_;
	refreshInner();
}

fn refreshInner() void {
	innerList.children.clearRetainingCapacity();
	if (storeAccountCode) {
		innerList.children.append(encryptWithPasswordCheckbox.toComponent());
		if (encryptAccountCode) {
			innerList.children.append(passwordRow.toComponent());
		}
	}
}

fn none() void {}

fn openCreateAccountWindow() void {
	gui.closeWindowFromRef(&window);
	gui.openWindow("authentication/create_account");
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 320, 8);
	const width = 480;
	list.add(Label.init(.{0, 0}, width, "Please enter your Account Code:", .left));
	const textRow = HorizontalList.init();
	textComponent = TextInput.init(.{0, 0}, 400, 38, "", .{.onNewline = .init(none), .onUpdate = .init(updateText)});
	textComponent.obfuscated = true;
	textRow.add(textComponent);
	textRow.add(CheckBox.init(.{10, 0}, 70, "Show", false, &showTextCallback));
	textRow.finish(.{0, 0}, .center);
	list.add(textRow);
	list.add(Label.init(.{0, 0}, width, "#ff8080**Do not share your Account Code with anyone!**", .left));
	const createAccountRow = HorizontalList.init();
	createAccountRow.add(Label.init(.{0, 3}, 240, "Don't have an Account Code yet?", .left));
	createAccountRow.add(Button.initText(.{0, 0}, 140, "Create Account", .init(openCreateAccountWindow)));
	list.add(createAccountRow);
	list.add(CheckBox.init(.{0, 0}, width, "Store Account Code on disk", storeAccountCode, &storeAccountCodeCallback));
	innerList = VerticalList.init(.{0, 0}, 100, 16);
	encryptWithPasswordCheckbox = CheckBox.init(.{0, 0}, width, "Encrypt it on disk (recommended)", encryptAccountCode, &encryptAccountCodeCallback);
	innerList.add(encryptWithPasswordCheckbox);
	passwordRow = HorizontalList.init();
	passwordRow.add(Label.init(.{0, 0}, 130, "Local Password:", .left));
	passwordTextField = TextInput.init(.{0, 0}, width - 130, 22, "", .{.onNewline = .init(none)});
	passwordRow.add(passwordTextField);
	passwordRow.finish(.{0, 0}, .center);
	innerList.add(passwordRow);
	innerList.finish(.center);
	refreshInner();
	list.add(innerList);
	loginButton = Button.initText(.{padding, 0}, 200, "Login", .init(login));
	list.add(loginButton);
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	// Make sure there remains no trace of the account code or password in memory
	main.network.authentication.secureZero(@TypeOf(textComponent.textBuffer.glyphs[0]), textComponent.textBuffer.glyphs);
	std.crypto.secureZero(u8, textComponent.currentString.items);
	main.network.authentication.secureZero(@TypeOf(passwordTextField.textBuffer.glyphs[0]), passwordTextField.textBuffer.glyphs);
	std.crypto.secureZero(u8, passwordTextField.currentString.items);
	main.Window.setClipboardString("");
	gui.openWindow("clipboard_deleted");

	if (!storeAccountCode) {
		encryptWithPasswordCheckbox.deinit();
	}
	if (!encryptAccountCode or !storeAccountCode) {
		passwordRow.deinit();
	}

	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/authentication/unlock.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = main.gui;
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const CheckBox = GuiComponent.CheckBox;
const Label = GuiComponent.Label;
const HorizontalList = GuiComponent.HorizontalList;
const TextInput = GuiComponent.TextInput;
const VerticalList = GuiComponent.VerticalList;

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
	.closeable = false,
};

const padding: f32 = 8;

var textComponent: *TextInput = undefined;

fn apply() void {
	var failureText: main.List(u8) = .init(main.stackAllocator);
	defer failureText.deinit();
	const accountCode = main.settings.storedAccount.decryptFromPassword(textComponent.currentString.items, &failureText) catch |err| {
		std.log.err("Encountered error while decrypting password: {s}", .{@errorName(err)});
		return;
	};
	defer accountCode.deinit();

	if (failureText.items.len != 0) {
		std.log.warn("Encountered errors while verifying your Account. This may happen if you created your account in a future version, in which case it's fine to continue.\n{s}", .{failureText.items});
	}

	main.network.authentication.KeyCollection.init(accountCode);

	gui.closeWindowFromRef(&window);
	if (settings.playerName.len == 0) {
		gui.openWindow("change_name");
	} else {
		gui.openWindow("main");
	}
}

fn showTextCallback(showText: bool) void {
	textComponent.obfuscated = !showText;
}

fn logout() void {
	main.settings.storedAccount.deinit(main.globalAllocator);
	main.settings.storedAccount = .empty;
	main.settings.save();
	gui.closeWindowFromRef(&window);
	gui.openWindow("authentication/login");
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 320, 8);
	const width = 420;
	list.add(Label.init(.{0, 0}, width, "Please enter your local password!", .left));
	list.add(Label.init(.{0, 0}, width, "If you lost your password you can also log out and reenter your Account Code.", .left));
	const passwordRow = HorizontalList.init();
	textComponent = TextInput.init(.{0, 0}, width - 80, 22, "", .{.onNewline = .init(apply)});
	textComponent.obfuscated = true;
	passwordRow.add(textComponent);
	passwordRow.add(CheckBox.init(.{10, 0}, 70, "Show", false, &showTextCallback));
	passwordRow.finish(.{0, 0}, .center);
	list.add(passwordRow);
	const buttonRow = HorizontalList.init();
	buttonRow.add(Button.initText(.{0, 0}, 200, "Logout", .init(logout)));
	buttonRow.add(Button.initText(.{padding, 0}, 200, "Unlock", .init(apply)));
	list.add(buttonRow);
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	// Make sure there remains no trace of the password in memory
	main.network.authentication.secureZero(@TypeOf(textComponent.textBuffer.glyphs[0]), textComponent.textBuffer.glyphs);
	std.crypto.secureZero(u8, textComponent.currentString.items);
	main.Window.setClipboardString("");
	gui.openWindow("clipboard_deleted");

	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/change_name.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};
var textComponent: *TextInput = undefined;

const padding: f32 = 8;

fn apply() void {
	if (textComponent.currentString.items.len > 500 or main.graphics.TextBuffer.Parser.countVisibleCharacters(textComponent.currentString.items) > 50) {
		std.log.err("Name is too long with {}/{} characters. Limits are 50/500", .{main.graphics.TextBuffer.Parser.countVisibleCharacters(textComponent.currentString.items), textComponent.currentString.items.len});
		return;
	}
	const oldName = settings.playerName;
	main.globalAllocator.free(settings.playerName);
	settings.playerName = main.globalAllocator.dupe(u8, textComponent.currentString.items);
	settings.save();

	gui.closeWindowFromRef(&window);
	if (oldName.len == 0) {
		gui.openWindow("main");
	}
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	const width = 420;
	if (settings.playerName.len == 0) {
		list.add(Label.init(.{0, 0}, width, "Please enter your name!", .center));
		window.closeable = false;
	} else {
		list.add(Label.init(.{0, 0}, width, "#ff0000Warning: #ffffffYou lose access to your inventory data when changing the name!", .center));
		window.closeable = true;
	}
	list.add(Label.init(.{0, 0}, width, "Cubyz supports formatting your username using a markdown-like syntax:", .center));
	list.add(Label.init(.{0, 0}, width, "\\**italic*\\* \\*\\***bold**\\*\\* \\_\\___underlined__\\_\\_ \\~\\~~~strike-through~~\\~\\~", .center));
	list.add(Label.init(.{0, 0}, width, "Even colors are possible, using the hexadecimal color code:", .center));
	list.add(Label.init(.{0, 0}, width, "\\##ff0000ff#ffffff00#ffffff00#ff0000red#ffffff \\##ff0000ff#00770077#ffffff00#ff7700orange#ffffff \\##ffffff00#00ff00ff#ffffff00#00ff00green#ffffff \\##ffffff00#ffffff00#0000ffff#0000ffblue", .center));
	textComponent = TextInput.init(.{0, 0}, width, 32, if (settings.playerName.len == 0) "quanturmdoelvloper" else settings.playerName, .{.onNewline = .init(apply)});
	list.add(textComponent);
	list.add(Button.initText(.{0, 0}, 100, "Apply", .init(apply)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/chat.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = GuiComponent.Label;
const MutexComponent = GuiComponent.MutexComponent;
const TextInput = GuiComponent.TextInput;
const VerticalList = @import("../components/VerticalList.zig");
const FixedSizeCircularBuffer = main.utils.FixedSizeCircularBuffer;

pub var window: GuiWindow = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
	},
	.scale = 0.75,
	.contentSize = Vec2f{128, 256},
	.showTitleBar = false,
	.hasBackground = false,
	.isHud = true,
	.hideIfMouseIsGrabbed = false,
	.closeable = false,
};

const padding: f32 = 8;
const messageTimeout: i32 = 10000;
const messageFade = 1000;
const reusableHistoryMaxSize = 8192;

var history: main.List(*Label) = undefined;
var messageQueue: main.utils.ConcurrentQueue([]const u8) = undefined;
var expirationTime: main.List(i32) = undefined;
var historyStart: u32 = 0;
var fadeOutEnd: u32 = 0;
pub var input: *TextInput = undefined;
var hideInput: bool = true;
var messageHistory: History = undefined;

pub const History = struct {
	up: FixedSizeCircularBuffer([]const u8, reusableHistoryMaxSize),
	down: FixedSizeCircularBuffer([]const u8, reusableHistoryMaxSize),

	fn init() History {
		return .{
			.up = .init(main.globalAllocator),
			.down = .init(main.globalAllocator),
		};
	}
	fn deinit(self: *History) void {
		self.clear();
		self.up.deinit(main.globalAllocator);
		self.down.deinit(main.globalAllocator);
	}
	fn clear(self: *History) void {
		while (self.up.popFront()) |msg| {
			main.globalAllocator.free(msg);
		}
		while (self.down.popFront()) |msg| {
			main.globalAllocator.free(msg);
		}
	}
	fn flushUp(self: *History) void {
		while (self.down.popBack()) |msg| {
			if (msg.len == 0) {
				continue;
			}

			if (self.up.forcePushBack(msg)) |old| {
				main.globalAllocator.free(old);
			}
		}
	}
	pub fn isDuplicate(self: *History, new: []const u8) bool {
		if (new.len == 0) return true;
		if (self.down.peekBack()) |msg| {
			if (std.mem.eql(u8, msg, new)) return true;
		}
		if (self.up.peekBack()) |msg| {
			if (std.mem.eql(u8, msg, new)) return true;
		}
		return false;
	}
	pub fn pushDown(self: *History, new: []const u8) void {
		if (self.down.forcePushBack(new)) |old| {
			main.globalAllocator.free(old);
		}
	}
	pub fn pushUp(self: *History, new: []const u8) void {
		if (self.up.forcePushBack(new)) |old| {
			main.globalAllocator.free(old);
		}
	}
	pub fn cycleUp(self: *History) bool {
		if (self.down.popBack()) |msg| {
			self.pushUp(msg);
			return true;
		}
		return false;
	}
	pub fn cycleDown(self: *History) void {
		if (self.up.popBack()) |msg| {
			self.pushDown(msg);
		}
	}
};

pub fn clearChat() void {
	while (history.popOrNull()) |label| {
		label.deinit();
	}
	historyStart = 0;
	fadeOutEnd = 0;
	expirationTime.clearRetainingCapacity();
	refresh();
}

pub fn init() void {
	history = .init(main.globalAllocator);
	messageHistory = .init();
	expirationTime = .init(main.globalAllocator);
	messageQueue = .init(main.globalAllocator, 16);
}

pub fn deinit() void {
	for (history.items) |label| {
		label.deinit();
	}
	history.deinit();
	while (messageQueue.popFront()) |msg| {
		main.globalAllocator.free(msg);
	}
	messageHistory.deinit();
	messageQueue.deinit();
	expirationTime.deinit();
}

fn refresh() void {
	if (window.rootComponent) |old| {
		old.verticalList.children.clearRetainingCapacity();
		old.deinit();
	}
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 0);
	for (history.items[if (hideInput) historyStart else 0..]) |msg| {
		msg.pos = .{0, 0};
		list.add(msg);
	}
	if (!hideInput) {
		input.pos = .{0, 0};
		list.add(input);
	}
	list.finish(.center);
	list.scrollBar.currentState = 1;
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	window.contentSize[0] = @max(window.contentSize[0], window.getMinWindowWidth());
	gui.updateWindowPositions();
	if (!hideInput) {
		for (history.items) |label| {
			label.alpha = 1;
		}
	} else {
		list.scrollBar.currentState = 1;
		list.scrollBar.size = .{0, 0};
	}
}

pub fn onOpen() void {
	input = TextInput.init(.{0, 0}, 256, 32, "", .{.onNewline = .init(sendMessage), .onUp = .init(loadNextHistoryEntry), .onDown = .init(loadPreviousHistoryEntry)});
	refresh();
}

pub fn loadNextHistoryEntry() void {
	const isSuccess = messageHistory.cycleUp();
	if (messageHistory.isDuplicate(input.currentString.items)) {
		if (isSuccess) messageHistory.cycleDown();
		messageHistory.cycleDown();
	} else {
		messageHistory.pushDown(main.globalAllocator.dupe(u8, input.currentString.items));
		messageHistory.cycleDown();
	}
	const msg = messageHistory.down.peekBack() orelse "";
	input.setString(msg);
}

pub fn loadPreviousHistoryEntry() void {
	_ = messageHistory.cycleUp();
	if (messageHistory.isDuplicate(input.currentString.items)) {} else {
		messageHistory.pushUp(main.globalAllocator.dupe(u8, input.currentString.items));
	}
	const msg = messageHistory.down.peekBack() orelse "";
	input.setString(msg);
}

pub fn onClose() void {
	clearChat();
	while (messageQueue.popFront()) |msg| {
		main.globalAllocator.free(msg);
	}
	messageHistory.clear();
	input.deinit();
	window.rootComponent.?.verticalList.children.clearRetainingCapacity();
	window.rootComponent.?.deinit();
	window.rootComponent = null;
}

pub fn update() void {
	if (!messageQueue.isEmpty()) {
		const currentTime: i32 = @truncate(main.timestamp().toMilliseconds());
		while (messageQueue.popFront()) |msg| {
			history.append(Label.init(.{0, 0}, 256, msg, .left));
			main.globalAllocator.free(msg);
			expirationTime.append(currentTime +% messageTimeout);
		}
		refresh();
	}

	const currentTime: i32 = @truncate(main.timestamp().toMilliseconds());
	while (fadeOutEnd < history.items.len and currentTime -% expirationTime.items[fadeOutEnd] >= 0) {
		fadeOutEnd += 1;
	}
	if (hideInput != main.Window.grabbed) {
		hideInput = main.Window.grabbed;
		refresh();
	}
	if (hideInput) {
		for (expirationTime.items[historyStart..fadeOutEnd], history.items[historyStart..fadeOutEnd]) |time, label| {
			if (currentTime -% time >= messageFade) {
				historyStart += 1;
				refresh();
			} else {
				const timeDifference: f32 = @floatFromInt(currentTime -% time);
				label.alpha = 1.0 - timeDifference/messageFade;
			}
		}
	}
}

pub fn render() void {
	if (!hideInput) {
		main.graphics.draw.setColor(0x80000000);
		main.graphics.draw.rect(.{0, 0}, window.contentSize);
	}
}

pub fn addMessage(msg: []const u8) void {
	messageQueue.pushBack(main.globalAllocator.dupe(u8, msg));
}

pub fn sendMessage() void {
	if (input.currentString.items.len != 0) {
		const data = input.currentString.items;
		if (data.len > 10000 or main.graphics.TextBuffer.Parser.countVisibleCharacters(data) > 1000) {
			std.log.err("Chat message is too long with {}/{} characters. Limits are 1000/10000", .{main.graphics.TextBuffer.Parser.countVisibleCharacters(data), data.len});
		} else {
			messageHistory.flushUp();
			if (!messageHistory.isDuplicate(data)) {
				messageHistory.pushUp(main.globalAllocator.dupe(u8, data));
			}

			if (input.currentString.items[0] == '/') {
				main.sync.ClientSide.executeCommand(.{.chatCommand = .{.message = main.globalAllocator.dupe(u8, input.currentString.items[1..])}});
			} else {
				main.network.protocols.chat.send(main.game.world.?.conn, data);
			}
			input.clear();
		}
	}
}

```

`src/gui/windows/chest.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Player = main.game.Player;
const ItemStack = main.items.ItemStack;
const Vec2f = main.vec.Vec2f;
const Texture = main.graphics.Texture;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const HorizontalList = GuiComponent.HorizontalList;
const VerticalList = GuiComponent.VerticalList;
const ItemSlot = GuiComponent.ItemSlot;

const inventory = @import("inventory.zig");

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToWindow = .{.reference = &inventory.window, .selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
		.{.attachedToWindow = .{.reference = &inventory.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{64*10, 64*3},
	.scale = 0.75,
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;
var itemSlots: main.List(*ItemSlot) = undefined;

pub fn init() void {
	itemSlots = .init(main.globalAllocator);
}

pub fn deinit() void {
	itemSlots.deinit();
}

pub var openInventory: main.items.Inventory.ClientInventory = undefined;

pub fn setInventory(selectedInventory: main.items.Inventory.ClientInventory) void {
	openInventory = selectedInventory;
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, padding + 16}, 300, 0);

	for (0..2) |y| {
		const row = HorizontalList.init();
		for (0..10) |x| {
			const index: usize = y*10 + x;
			const slot = ItemSlot.init(.{0, 0}, openInventory, @intCast(index), .default, .normal);
			itemSlots.append(slot);
			row.add(slot);
		}
		list.add(row);
	}
	list.finish(.center);
	window.shiftClickableInventory = openInventory;
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	openInventory.deinit(main.globalAllocator);

	itemSlots.clearRetainingCapacity();
	if (window.rootComponent) |*comp| {
		comp.deinit();
		window.rootComponent = null;
	}
}

```

`src/gui/windows/clipboard_deleted.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;
const TaskType = main.utils.ThreadPool.TaskType;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{128, 16},
	.isHud = false,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
};

var time: std.Io.Timestamp = undefined;

pub fn onOpen() void {
	time = main.timestamp();
}

pub fn render() void {
	const duration = time.durationTo(main.timestamp());
	if (duration.toSeconds() > 2) {
		gui.closeWindowFromRef(&window);
		return;
	}
	draw.setColor(0xffff8080);
	draw.print("Your clipboard was cleared.", .{}, 0, 0, 16, .left);
}

```

`src/gui/windows/controls.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;
const c = main.Window.c;
const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const CheckBox = @import("../components/CheckBox.zig");
const HorizontalList = @import("../components/HorizontalList.zig");
const Label = @import("../components/Label.zig");
const VerticalList = @import("../components/VerticalList.zig");
const ContinuousSlider = @import("../components/ContinuousSlider.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 192},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;
var selectedKey: ?*main.Window.Key = null;
var editingKeyboard: bool = true;
var needsUpdate: bool = false;
fn keyFunction(key: *main.Window.Key) void {
	main.Window.setNextKeypressListener(&keypressListener) catch return;
	selectedKey = key;
	needsUpdate = true;
}
fn keypressListener(key: c_int, mouseButton: c_int, scancode: c_int) void {
	selectedKey.?.key = key;
	selectedKey.?.mouseButton = mouseButton;
	selectedKey.?.scancode = scancode;
	selectedKey = null;
	needsUpdate = true;
	main.settings.save();
}

fn gamepadFunction(key: *main.Window.Key) void {
	main.Window.setNextGamepadListener(&gamepadListener) catch return;
	selectedKey = key;
	needsUpdate = true;
}
fn gamepadListener(axis: ?main.Window.GamepadAxis, btn: c_int) void {
	selectedKey.?.gamepadAxis = axis;
	selectedKey.?.gamepadButton = btn;
	selectedKey = null;
	needsUpdate = true;
	main.settings.save();
}
fn updateSensitivity(sensitivity: f32) void {
	if (editingKeyboard) {
		main.settings.mouseSensitivity = sensitivity;
	} else {
		main.settings.controllerSensitivity = sensitivity;
	}
	main.settings.save();
}

fn invertMouseYCallback(newValue: bool) void {
	main.settings.invertMouseY = newValue;
	main.settings.save();
}
fn sprintIsToggleCallback(newValue: bool) void {
	main.KeyBoard.setIsToggling("sprint", newValue);
	main.settings.save();
}

fn updateDeadzone(deadzone: f32) void {
	main.settings.controllerAxisDeadzone = deadzone;
}

fn deadzoneFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "Deadzone: {d:.0}%", .{value*100}) catch unreachable;
}

fn sensitivityFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "{s} Sensitivity: {d:.0}%", .{if (editingKeyboard) "Mouse" else "Controller", value*100}) catch unreachable;
}

fn toggleKeyboard() void {
	editingKeyboard = !editingKeyboard;
	needsUpdate = true;
}
fn unbindKey(keyPtr: usize) void {
	var key: ?*main.Window.Key = @ptrFromInt(keyPtr);
	if (editingKeyboard) {
		key.?.key = c.GLFW_KEY_UNKNOWN;
		key.?.mouseButton = -1;
		key.?.scancode = 0;
	} else {
		key.?.gamepadAxis = null;
		key.?.gamepadButton = -1;
	}
	needsUpdate = true;
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 364, 8);
	list.add(Button.initText(.{0, 0}, 128, if (editingKeyboard) "Gamepad" else "Keyboard", .init(toggleKeyboard)));
	list.add(ContinuousSlider.init(.{0, 0}, 256, 0, 5, if (editingKeyboard) main.settings.mouseSensitivity else main.settings.controllerSensitivity, &updateSensitivity, &sensitivityFormatter));
	list.add(CheckBox.init(.{0, 0}, 256, "Invert mouse Y", main.settings.invertMouseY, &invertMouseYCallback));
	list.add(CheckBox.init(.{0, 0}, 256, "Toggle sprint", main.KeyBoard.key("sprint").isToggling == .yes, &sprintIsToggleCallback));

	if (!editingKeyboard) {
		list.add(ContinuousSlider.init(.{0, 0}, 256, 0, 1, main.settings.controllerAxisDeadzone, &updateDeadzone, &deadzoneFormatter));
	}
	for (&main.KeyBoard.keys) |*key| {
		const label = Label.init(.{0, 0}, 128, key.name, .left);
		const button = if (key == selectedKey) (Button.initText(.{16, 0}, 128, "...", .{})) else (Button.initText(.{16, 0}, 128, if (editingKeyboard) key.getName() else key.getGamepadName(), if (editingKeyboard) .initWithPtr(keyFunction, key) else .initWithPtr(gamepadFunction, key)));
		const unbindBtn = Button.initText(.{16, 0}, 64, "Unbind", .initWithPtr(unbindKey, key));
		const row = HorizontalList.init();
		row.add(label);
		row.add(button);
		row.add(unbindBtn);
		row.finish(.{0, 0}, .center);
		list.add(row);
	}
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

pub fn render() void {
	if (needsUpdate) {
		needsUpdate = false;
		const oldScroll = window.rootComponent.?.verticalList.scrollBar.currentState;
		onClose();
		onOpen();
		window.rootComponent.?.verticalList.scrollBar.currentState = oldScroll;
	}
}

```

`src/gui/windows/creative_inventory.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Item = main.items.Item;
const ClientInventory = main.items.Inventory.ClientInventory;
const Player = main.game.Player;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const TextInput = GuiComponent.TextInput;
const Label = GuiComponent.Label;
const HorizontalList = GuiComponent.HorizontalList;
const VerticalList = GuiComponent.VerticalList;
const ItemSlot = GuiComponent.ItemSlot;

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
	},
	.contentSize = Vec2f{64*8, 64*6},
	.scale = 0.75,
};

const padding: f32 = 8;
const slotsPerRow: u32 = 10;
var items: main.List(Item) = undefined;
var inventory: ClientInventory = undefined;
var searchInput: *TextInput = undefined;
var searchString: []const u8 = undefined;

fn lessThan(_: void, lhs: Item, rhs: Item) bool {
	if (lhs == .baseItem and rhs == .baseItem) {
		const lhsFolders = std.mem.count(u8, lhs.baseItem.id(), "/");
		const rhsFolders = std.mem.count(u8, rhs.baseItem.id(), "/");
		if (lhsFolders < rhsFolders) return true;
		if (lhsFolders > rhsFolders) return false;
		return std.ascii.lessThanIgnoreCase(lhs.baseItem.id(), rhs.baseItem.id());
	} else {
		if (lhs == .baseItem) return true;
		return false;
	}
}

pub fn onOpen() void {
	searchString = "";
	initContent();
}

pub fn onClose() void {
	deinitContent();
	main.globalAllocator.free(searchString);
}

fn hasMatchingTag(tags: []const main.Tag, target: []const u8) bool {
	for (tags) |tag| {
		if (std.mem.containsAtLeast(u8, tag.getName(), 1, target)) {
			return true;
		}
	}
	return false;
}

fn initContent() void {
	const root = VerticalList.init(.{padding, padding}, 300, 0);
	{
		const list = VerticalList.init(.{0, padding + padding}, 48, 0);
		const row = HorizontalList.init();
		const label = Label.init(.{0, 3}, 56, "Search:", .right);

		searchInput = TextInput.init(.{0, 0}, 288, 22, searchString, .{.onNewline = .init(filter)});

		row.add(label);
		row.add(searchInput);
		list.add(row);
		list.finish(.center);
		root.add(list);
	}
	{
		const list = VerticalList.init(.{0, padding}, 144, 0);
		items = .init(main.globalAllocator);
		var itemIterator = main.items.iterator();
		if (searchString.len > 1 and searchString[0] == '.') {
			const tag = searchString[1..];
			while (itemIterator.next()) |item| {
				if (hasMatchingTag(item.tags(), tag) or (item.block() != null and hasMatchingTag((main.blocks.Block{.typ = item.block().?, .data = undefined}).blockTags(), tag))) {
					items.append(Item{.baseItem = item.*});
				}
			}
		} else {
			while (itemIterator.next()) |item| {
				if (searchString.len != 0 and !std.mem.containsAtLeast(u8, item.id(), 1, searchString)) continue;
				items.append(Item{.baseItem = item.*});
			}
		}

		std.mem.sort(Item, items.items, {}, lessThan);
		const slotCount = items.items.len + (slotsPerRow - items.items.len%slotsPerRow);
		inventory = ClientInventory.init(main.globalAllocator, slotCount, .normal, .creative, .other, .{});
		for (0..items.items.len) |i| {
			inventory.super._items[i] = .{.item = items.items[i], .amount = 1};
		}
		var i: u32 = 0;
		while (i < items.items.len) {
			const row = HorizontalList.init();
			for (0..slotsPerRow) |_| {
				if (i >= items.items.len) {
					row.add(ItemSlot.init(.{0, 0}, inventory, i, .immutable, .immutable));
				} else {
					row.add(ItemSlot.init(.{0, 0}, inventory, i, .default, .takeOnly));
				}
				i += 1;
			}
			list.add(row);
		}
		list.finish(.center);
		root.add(list);
	}
	root.finish(.center);
	window.rootComponent = root.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

fn deinitContent() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
	items.deinit();
	inventory.deinit(main.globalAllocator);
}

pub fn update() void {
	if (std.mem.eql(u8, searchInput.currentString.items, searchString)) return;
	filter();
}

fn filter() void {
	const selectionStart = searchInput.selectionStart;
	const cursor = searchInput.cursor;

	main.globalAllocator.free(searchString);
	searchString = main.globalAllocator.dupe(u8, searchInput.currentString.items);
	deinitContent();
	initContent();

	searchInput.selectionStart = selectionStart;
	searchInput.cursor = cursor;

	searchInput.select();
}

```

`src/gui/windows/crosshair.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

const c = main.graphics.c;

const size: f32 = 64;
pub var window = GuiWindow{
	.contentSize = Vec2f{size, size},
	.showTitleBar = false,
	.hasBackground = false,
	.isHud = true,
	.hideIfMouseIsGrabbed = false,
	.closeable = false,
};

var texture: Texture = undefined;
var pipeline: graphics.Pipeline = undefined;
var uniforms: struct {
	screen: c_int,
	start: c_int,
	size: c_int,
	color: c_int,
	uvOffset: c_int,
	uvDim: c_int,
} = undefined;

pub fn init() void {
	pipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/graphics/Image.vert",
		"assets/cubyz/shaders/graphics/Image.frag",
		"",
		&uniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.{
			.srcColorBlendFactor = .one,
			.dstColorBlendFactor = .one,
			.colorBlendOp = .subtract,
			.srcAlphaBlendFactor = .one,
			.dstAlphaBlendFactor = .one,
			.alphaBlendOp = .subtract,
		}}},
	);
	texture = Texture.initFromFile("assets/cubyz/ui/hud/crosshair.png");
}

pub fn deinit() void {
	pipeline.deinit();
	texture.deinit();
}

pub fn render() void {
	texture.bindTo(0);
	graphics.draw.setColor(0xffffffff);
	pipeline.bind(graphics.draw.getScissor());
	graphics.draw.customShadedImage(&uniforms, .{0, 0}, .{size, size});
}

```

`src/gui/windows/debug.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;
const TaskType = main.utils.ThreadPool.TaskType;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

pub fn onOpen() void {
	main.threadPool.performance.clear();
}

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{128, 16},
	.isHud = false,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
};

pub fn render() void {
	draw.setColor(0xffffffff);
	var y: f32 = 0;
	const fpsCapText = if (main.settings.fpsCap) |fpsCap| std.fmt.allocPrint(main.stackAllocator.allocator, " (limit: {d:.0} Hz)", .{fpsCap}) catch unreachable else "";
	defer main.stackAllocator.allocator.free(fpsCapText);
	const fpsLimit = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}{s}", .{
		fpsCapText,
		if (main.settings.vsync) " (vsync)" else "",
	}) catch unreachable;
	defer main.stackAllocator.allocator.free(fpsLimit);
	draw.print("fps: {d:.0} Hz{s}", .{1.0/main.lastDeltaTime.load(.monotonic), fpsLimit}, 0, y, 8, .left);
	y += 8;
	draw.print("frameTime: {d:.1} ms", .{main.lastFrameTime.load(.monotonic)*1000.0}, 0, y, 8, .left);
	y += 8;
	draw.print("window size: {}×{}", .{main.Window.width, main.Window.height}, 0, y, 8, .left);
	y += 8;
	if (main.game.world != null) {
		const player = main.game.Player;
		draw.print("Pos: {d:.1}", .{player.getPosBlocking()}, 0, y, 8, .left);
		y += 8;
		draw.print("Gamemode: {} IsFlying: {} IsGhost: {} HyperSpeed: {}", .{
			player.gamemode.load(.monotonic),
			player.isFlying.load(.monotonic),
			player.isGhost.load(.monotonic),
			player.hyperSpeed.load(.monotonic),
		}, 0, y, 8, .left);
		y += 8;
		draw.print("OnGround: {} JumpCooldown: {d:.3} JumpCoyote: {d:.3}", .{
			player.onGround,
			player.jumpCooldown,
			@max(0, player.getJumpCoyoteBlocking()),
		}, 0, y, 8, .left);
		y += 8;
		draw.print("Velocity: {d:.1}", .{player.getVelBlocking()}, 0, y, 8, .left);
		y += 8;
		draw.print("EyePos: {d:.1} EyeVelocity: {d:.1} EyeCoyote: {d:.3}", .{player.getEyePosBlocking(), player.getEyeVelBlocking(), @max(0, player.getEyeCoyoteBlocking())}, 0, y, 8, .left);
		y += 8;
		draw.print("Game Time: {}", .{main.game.world.?.gameTime.load(.monotonic)}, 0, y, 8, .left);
		y += 8;
		draw.print("Queue size: {}", .{main.threadPool.queueSize()}, 0, y, 8, .left);
		y += 8;
		const perf = main.threadPool.performance.read();
		const values = comptime std.enums.values(TaskType);
		var totalUtime: i64 = 0;
		for (values) |task|
			totalUtime += perf.utime[@intFromEnum(task)];
		for (values) |t| {
			const name = @tagName(t);
			const i = @intFromEnum(t);
			const taskTime = @divFloor(perf.utime[i], @max(1, perf.tasks[i]));
			const relativeTime = 100.0*@as(f32, @floatFromInt(perf.utime[i]))/@as(f32, @floatFromInt(totalUtime));
			draw.print("    {s}: {} µs/task ({d:.1}%)", .{name, taskTime, relativeTime}, 0, y, 8, .left);
			y += 8;
		}
		draw.print("Mesh Queue size: {}", .{main.renderer.mesh_storage.updatableList.items.len}, 0, y, 8, .left);
		y += 8;
		for (0..main.settings.highestLod + 1) |lod| {
			const faceDataSize: usize = @sizeOf(main.renderer.chunk_meshing.FaceData);
			const size: usize = main.renderer.chunk_meshing.faceBuffers[lod].capacity*faceDataSize;
			const used: usize = main.renderer.chunk_meshing.faceBuffers[lod].used*faceDataSize;
			draw.print("ChunkMesh memory LOD{}: {} MiB / {} MiB", .{lod, used >> 20, size >> 20}, 0, y, 8, .left);
			y += 8;
		}
		for (0..main.settings.highestLod + 1) |lod| {
			const lightDataSize: usize = @sizeOf(u32);
			const size: usize = main.renderer.chunk_meshing.lightBuffers[lod].capacity*lightDataSize;
			const used: usize = main.renderer.chunk_meshing.lightBuffers[lod].used*lightDataSize;
			draw.print("Light memory LOD{}: {} MiB / {} MiB", .{lod, used >> 20, size >> 20}, 0, y, 8, .left);
			y += 8;
		}
		{
			const biome = main.game.world.?.playerBiome.load(.monotonic);
			var tags = main.List(u8).init(main.stackAllocator);
			defer tags.deinit();
			inline for (comptime std.meta.fieldNames(main.server.terrain.biomes.Biome.GenerationProperties)) |name| {
				if (@field(biome.properties, name)) {
					if (tags.items.len != 0) tags.appendSlice(", ");
					tags.appendSlice(name);
				}
			}
			draw.print("Biome: {s}", .{biome.id}, 0, y, 8, .left);
			y += 8;
			draw.print("Biome Properties: {s}", .{tags.items}, 0, y, 8, .left);
			y += 8;
		}
		draw.print("Opaque faces: {}, Transparent faces: {}", .{main.renderer.chunk_meshing.quadsDrawn, main.renderer.chunk_meshing.transparentQuadsDrawn}, 0, y, 8, .left);
		y += 8;
		draw.print("Particle count: {}/{}", .{main.particles.ParticleSystem.getParticleCount(), main.particles.ParticleSystem.maxCapacity}, 0, y, 8, .left);
		y += 8;
	}
}

```

`src/gui/windows/debug_network.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const network = main.network;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
	},
	.contentSize = Vec2f{192, 128},
	.isHud = false,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
};

pub fn render() void {
	draw.setColor(0xffffffff);
	var y: f32 = 0;
	if (main.game.world != null) {
		if (main.server.world != null) {
			const userList = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
			defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
			draw.print("Players Connected: {}", .{userList.len}, 0, y, 8, .left);
			y += 8;
		}
		const sent = network.Connection.packetsSent.load(.monotonic);
		const resent = network.Connection.packetsResent.load(.monotonic);
		const loss = @as(f64, @floatFromInt(resent))/@as(f64, @floatFromInt(sent))*100;
		draw.print("Packet loss: {d:.1}% ({}/{})", .{loss, resent, sent}, 0, y, 8, .left);
		y += 8;
		draw.print("Internal message overhead: {}kiB", .{network.Connection.internalMessageOverhead.load(.monotonic) >> 10}, 0, y, 8, .left);
		y += 8;
		draw.print("Internal header overhead: {}kiB", .{network.Connection.internalHeaderOverhead.load(.monotonic) >> 10}, 0, y, 8, .left);
		y += 8;
		draw.print("External header overhead: {}kiB", .{network.Connection.externalHeaderOverhead.load(.monotonic) >> 10}, 0, y, 8, .left);
		y += 8;
		inline for (@typeInfo(network.protocols).@"struct".decls) |decl| {
			if (@TypeOf(@field(network.protocols, decl.name)) == type) {
				const id = @field(network.protocols, decl.name).id;
				draw.print("{s}: received {}kiB sent {}kiB", .{decl.name, network.protocols.bytesReceived[id].load(.monotonic) >> 10, network.protocols.bytesSent[id].load(.monotonic) >> 10}, 0, y, 8, .left);
				y += 8;
			}
		}
	}
	if (window.contentSize[1] != y) {
		window.contentSize[1] = y;
		window.updateWindowPosition();
	}
}

```

`src/gui/windows/debug_network_advanced.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const network = main.network;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
	},
	.contentSize = Vec2f{192, 128},
	.isHud = false,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
};

fn renderConnectionData(conn: *main.network.Connection, name: []const u8, y: *f32) void {
	conn.mutex.lock();
	defer conn.mutex.unlock();
	var unconfirmed: [3]usize = @splat(0);
	var queued: [3]usize = @splat(0);
	conn.lossyChannel.getStatistics(&unconfirmed[0], &queued[0]);
	conn.secureChannel.getStatistics(&unconfirmed[1], &queued[1]);
	conn.slowChannel.getStatistics(&unconfirmed[2], &queued[2]);
	draw.print("{s} | RTT = {d:.1} ms | {d:.0} kiB/RTT", .{name, conn.rttEstimate/1000.0, conn.bandwidthEstimateInBytesPerRtt/1024.0}, 0, y.*, 8, .left);
	y.* += 8;
	draw.print("Waiting in queue:      {: >6} kiB |{: >6} kiB |{: >6} kiB", .{queued[0] >> 10, queued[1] >> 10, queued[2] >> 10}, 0, y.*, 8, .left);
	y.* += 8;
	draw.print("Sent but not confirmed:{: >6} kiB |{: >6} kiB |{: >6} kiB", .{unconfirmed[0] >> 10, unconfirmed[1] >> 10, unconfirmed[2] >> 10}, 0, y.*, 8, .left);
	y.* += 8;
}

pub fn render() void {
	draw.setColor(0xffffffff);
	var y: f32 = 0;
	if (main.game.world != null) {
		renderConnectionData(main.game.world.?.conn, "Client", &y);
	}
	y += 8;
	if (main.server.world != null) {
		const userList = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
		defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
		for (userList) |user| {
			renderConnectionData(user.conn, user.name, &y);
		}
	}
	if (window.contentSize[1] != y) {
		window.contentSize[1] = y;
		window.updateWindowPosition();
	}
}

```

`src/gui/windows/delete_world_confirmation.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = @import("../components/Label.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
};

const padding: f32 = 8;

var deleteWorldName: []const u8 = "";

pub fn init() void {
	deleteWorldName = "";
}

pub fn deinit() void {
	main.globalAllocator.free(deleteWorldName);
}

pub fn setDeleteWorldName(name: []const u8) void {
	main.globalAllocator.free(deleteWorldName);
	deleteWorldName = main.globalAllocator.dupe(u8, name);
}

fn flawedDeleteWorld(name: []const u8) !void {
	const path = std.mem.concat(main.stackAllocator.allocator, u8, &.{"saves/", name}) catch unreachable;
	defer main.stackAllocator.free(path);
	try main.files.cubyzDir().deleteTree(path);
	gui.windowlist.save_selection.needsUpdate = true;
}

fn deleteWorld() void {
	flawedDeleteWorld(deleteWorldName) catch |err| {
		std.log.err("Encountered error while deleting world \"{s}\": {s}", .{deleteWorldName, @errorName(err)});
	};
	gui.closeWindowFromRef(&window);
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	const text = std.fmt.allocPrint(main.stackAllocator.allocator, "Are you sure you want to delete the world **{s}**?", .{deleteWorldName}) catch unreachable;
	defer main.stackAllocator.free(text);
	list.add(Label.init(.{0, 0}, 128, text, .center));
	list.add(Button.initText(.{0, 0}, 128, "Yes", .init(deleteWorld)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/download_controller_mappings.zig`:

```zig
const std = @import("std");

const main = @import("main");
const files = main.files;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const CheckBox = @import("../components/CheckBox.zig");
const Label = @import("../components/Label.zig");
const VerticalList = @import("../components/VerticalList.zig");
const HorizontalList = @import("../components/HorizontalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 64},
	.hasBackground = true,
	.closeable = false,
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
	},
};

const padding: f32 = 8;
pub fn update() void {
	if (main.Window.Gamepad.wereControllerMappingsDownloaded()) {
		gui.closeWindowFromRef(&window);
	}
}
pub fn onOpen() void {
	const label = Label.init(.{padding, 16 + padding}, 128, "Downloading controller mappings...", .center);
	window.rootComponent = label.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/energybar.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

const hotbar = @import("hotbar.zig");

pub var window = GuiWindow{
	.scale = 0.5,
	.relativePosition = .{
		.{.attachedToWindow = .{.reference = &hotbar.window, .selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
		.{.attachedToWindow = .{.reference = &hotbar.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{160, 20},
	.isHud = true,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
	.closeable = false,
};

var energyTexture: Texture = undefined;
var halfEnergyTexture: Texture = undefined;
var noEnergyTexture: Texture = undefined;

pub fn init() void {
	energyTexture = Texture.initFromFile("assets/cubyz/ui/hud/energy.png");
	halfEnergyTexture = Texture.initFromFile("assets/cubyz/ui/hud/half_energy.png");
	noEnergyTexture = Texture.initFromFile("assets/cubyz/ui/hud/no_energy.png");
}

pub fn deinit() void {
	energyTexture.deinit();
	halfEnergyTexture.deinit();
	noEnergyTexture.deinit();
}

pub fn render() void {
	if (main.game.Player.isCreative())
		return;

	draw.setColor(0xffffffff);
	var y: f32 = 0;
	var x: f32 = 0;
	var energy: f32 = 0;
	while (energy < main.game.Player.super.maxEnergy) : (energy += 1) {
		if (x >= window.contentSize[0]) {
			x = 0;
			y += 20;
		}
		if (energy + 1 <= main.game.Player.super.energy) {
			energyTexture.bindTo(0);
		} else if (energy + 0.5 <= main.game.Player.super.energy) {
			halfEnergyTexture.bindTo(0);
		} else {
			noEnergyTexture.bindTo(0);
		}
		draw.boundImage(Vec2f{x, window.contentSize[1] - y - 20}, .{20, 20});
		x += 20;
	}
	y += 20;
	if (y != window.contentSize[1]) {
		window.contentSize[1] = y;
		gui.updateWindowPositions();
	}
}

```

`src/gui/windows/error_prompt.zig`:

```zig
const std = @import("std");

const main = @import("main");
const files = main.files;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;
const Texture = main.graphics.Texture;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const Label = @import("../components/Label.zig");
const VerticalList = @import("../components/VerticalList.zig");
const Button = @import("../components/Button.zig");

var fileExplorerIcon: Texture = undefined;

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 64},
	.hasBackground = true,
	.hideIfMouseIsGrabbed = false,
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
	},
};

pub fn init() void {
	fileExplorerIcon = Texture.initFromFile("assets/cubyz/ui/file_explorer_icon.png");
}

pub fn deinit() void {
	fileExplorerIcon.deinit();
}

fn openLog() void {
	main.files.openDirInWindow("logs");
}

const padding: f32 = 8;
pub fn update() void {
	if (main.Window.Gamepad.wereControllerMappingsDownloaded()) {
		gui.closeWindowFromRef(&window);
	}
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(Label.init(.{padding, 16 + padding}, 128, "#ffff00The game encountered errors. Check the logs for details", .center));
	list.add(Button.initIcon(.{0, 0}, .{16, 16}, fileExplorerIcon, false, .init(openLog)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/gpu_performance_measuring.zig`:

```zig
const std = @import("std");

const main = @import("main");
const c = main.Window.c;
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

pub const Samples = enum(u8) {
	screenbuffer_clear,
	clear,
	skybox,
	animation,
	chunk_rendering_preparation,
	chunk_rendering,
	entity_rendering,
	block_entity_rendering,
	particle_rendering,
	transparent_rendering_preparation,
	transparent_rendering,
	bloom_extract_downsample,
	bloom_first_pass,
	bloom_second_pass,
	final_copy,
	gui,
};

const names = [_][]const u8{
	"Screenbuffer clear",
	"Clear",
	"Skybox",
	"Pre-processing Block Animations",
	"Chunk Rendering Preparation",
	"Chunk Rendering",
	"Entity Rendering",
	"Block Entity Rendering",
	"Particle Rendering",
	"Transparent Rendering Preparation",
	"Transparent Rendering",
	"Bloom - Extract color and downsample",
	"Bloom - First Pass",
	"Bloom - Second Pass",
	"Copy to screen",
	"GUI Rendering",
};

const buffers = 4;
var curBuffer: u2 = 0;
var queryObjects: [buffers][@typeInfo(Samples).@"enum".fields.len]c_uint = undefined;

var activeSample: ?Samples = null;

pub fn init() void {
	for (&queryObjects) |*buf| {
		c.glGenQueries(buf.len, buf);
		for (buf) |queryObject| { // Start them to get an initial value.
			c.glBeginQuery(c.GL_TIME_ELAPSED, queryObject);
			c.glEndQuery(c.GL_TIME_ELAPSED);
		}
	}
}

pub fn deinit() void {
	c.glDeleteQueries(queryObjects.len*buffers, @ptrCast(&queryObjects));
}

pub fn startQuery(sample: Samples) void {
	std.debug.assert(activeSample == null); // There can be at most one active measurement at a time.
	activeSample = sample;
	c.glBeginQuery(c.GL_TIME_ELAPSED, queryObjects[curBuffer][@intFromEnum(sample)]);
}

pub fn stopQuery() void {
	std.debug.assert(activeSample != null); // There must be an active measurement to stop.
	activeSample = null;
	c.glEndQuery(c.GL_TIME_ELAPSED);
}

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{256, 16},
	.isHud = false,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
};

pub fn render() void {
	curBuffer +%= 1;
	draw.setColor(0xffffffff);
	var sum: isize = 0;
	var y: f32 = 8;
	inline for (0..queryObjects[curBuffer].len) |i| {
		var result: u32 = undefined;
		c.glGetQueryObjectuiv(queryObjects[curBuffer][i], c.GL_QUERY_RESULT, &result);
		draw.print("{s}: {} µs", .{names[i], @divTrunc(result, 1000)}, 0, y, 8, .left);
		sum += result;
		y += 8;
	}
	draw.print("Total: {} µs", .{@divTrunc(sum, 1000)}, 0, 0, 8, .left);
}

```

`src/gui/windows/graphics.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const CheckBox = @import("../components/CheckBox.zig");
const ContinuousSlider = @import("../components/ContinuousSlider.zig");
const DiscreteSlider = @import("../components/DiscreteSlider.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;
const renderDistances = [_]u16{5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24};
const lodValues = [_][]const u8{"0.5", "1", "2", "3", "4", "5"};

const anisotropy = [_]u8{1, 2, 4, 8, 16};

const resolutions = [_]u16{25, 50, 100};

const leavesQualities = [_]u8{0, 1, 2, 3, 4};

fn fpsCapRound(newValue: f32) ?u32 {
	if (newValue < 144.0) {
		return @as(u32, @intFromFloat(newValue/5.0))*5;
	} else if (newValue < 149.0) {
		return 144;
	} else {
		return null;
	}
}

fn fpsCapFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	const cap = fpsCapRound(value);
	if (cap == null)
		return allocator.dupe(u8, "#ffffffFPS: Unlimited");
	return std.fmt.allocPrint(allocator.allocator, "#ffffffFPS Limit: {d:.0}", .{cap.?}) catch unreachable;
}

fn fpsCapCallback(newValue: f32) void {
	settings.fpsCap = fpsCapRound(newValue);
	settings.save();
}

fn renderDistanceCallback(newValue: u16) void {
	settings.renderDistance = newValue + renderDistances[0];
	settings.save();
}

fn highestLodCallback(newValue: u16) void {
	settings.highestLod = @intCast(@min(newValue, settings.highestSupportedLod));
	settings.save();
}

fn leavesQualityCallback(newValue: u16) void {
	settings.leavesQuality = newValue;
	settings.save();
}

fn fovCallback(newValue: f32) void {
	settings.fov = newValue;
	settings.save();
}

fn fovFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "#ffffffField Of View: {d:.0}°", .{value}) catch unreachable;
}

fn lodDistanceFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "#ffffffOpaque leaves distance: {d:.0}", .{@round(value)}) catch unreachable;
}

fn lodDistanceCallback(newValue: f32) void {
	settings.@"lod0.5Distance" = @round(newValue);
	settings.save();
}

fn contrastFormatter(allocator: main.heap.NeverFailingAllocator, value: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "#ffffffBlock Contrast: {d:.0}%", .{@round(value*100)}) catch unreachable;
}

fn contrastCallback(newValue: f32) void {
	settings.blockContrast = @round(newValue*100)/100;
	settings.save();
}

fn nightBrightnessCallback(newValue: f32) void {
	settings.nightBrightness = newValue;
	settings.save();
}
fn nightBrightnessFormatter(allocator: main.heap.NeverFailingAllocator, _: f32) []const u8 {
	return std.fmt.allocPrint(allocator.allocator, "Night Brightness", .{}) catch unreachable;
}

fn bloomCallback(newValue: bool) void {
	settings.bloom = newValue;
	settings.save();
}

fn vsyncCallback(newValue: bool) void {
	settings.vsync = newValue;
	settings.save();
	main.Window.reloadSettings();
}

fn anisotropicFilteringCallback(newValue: u16) void {
	settings.anisotropicFiltering = anisotropy[newValue];
	settings.save();
	if (main.game.world != null) {
		main.blocks.meshes.reloadTextures(undefined);
	}
}

fn resolutionScaleCallback(newValue: u16) void {
	settings.resolutionScale = std.math.pow(f32, 2.0, @as(f32, @floatFromInt(newValue)) - 2.0);
	settings.save();
	main.Window.GLFWCallbacks.framebufferSize(null, main.Window.width, main.Window.height);
}

fn vulkanTestingWindowCallback(newValue: bool) void {
	settings.vulkanTestingWindow = newValue;
	settings.save();
	main.Window.reloadSettings();
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(ContinuousSlider.init(.{0, 0}, 128, 10.0, 154.0, @floatFromInt(settings.fpsCap orelse 154), &fpsCapCallback, &fpsCapFormatter));
	list.add(DiscreteSlider.init(.{0, 0}, 128, "#ffffffLOD1 Distance: ", "{} chunks", &renderDistances, @min(@max(settings.renderDistance, renderDistances[0]) - renderDistances[0], renderDistances.len - 1), &renderDistanceCallback));
	if (main.game.world == null) {
		list.add(DiscreteSlider.init(.{0, 0}, 128, "#ffffffHighest LOD: ", "{s}", &lodValues, @min(settings.highestLod, settings.highestSupportedLod), &highestLodCallback));
	}
	list.add(DiscreteSlider.init(.{0, 0}, 128, "#ffffffLeaves Quality (TODO: requires reload): ", "{}", &leavesQualities, settings.leavesQuality - leavesQualities[0], &leavesQualityCallback));
	list.add(ContinuousSlider.init(.{0, 0}, 128, 50.0, 400.0, settings.@"lod0.5Distance", &lodDistanceCallback, &lodDistanceFormatter));
	list.add(ContinuousSlider.init(.{0, 0}, 128, 0.0, 0.5, settings.blockContrast, &contrastCallback, &contrastFormatter));
	list.add(ContinuousSlider.init(.{0, 0}, 128, 0.0, 1.0, settings.nightBrightness, &nightBrightnessCallback, &nightBrightnessFormatter));
	list.add(ContinuousSlider.init(.{0, 0}, 128, 40.0, 120.0, settings.fov, &fovCallback, &fovFormatter));
	list.add(CheckBox.init(.{0, 0}, 128, "Bloom", settings.bloom, &bloomCallback));
	list.add(CheckBox.init(.{0, 0}, 128, "Vertical Synchronization", settings.vsync, &vsyncCallback));
	list.add(DiscreteSlider.init(.{0, 0}, 128, "#ffffffAnisotropic Filtering: ", "{}x", &anisotropy, switch (settings.anisotropicFiltering) {
		1 => 0,
		2 => 1,
		4 => 2,
		8 => 3,
		16 => 4,
		else => 2,
	}, &anisotropicFilteringCallback));
	list.add(DiscreteSlider.init(.{0, 0}, 128, "#ffffffResolution Scale: ", "{}%", &resolutions, @as(u16, @intFromFloat(@log2(settings.resolutionScale) + 2.0)), &resolutionScaleCallback));
	list.add(CheckBox.init(.{0, 0}, 128, "Vulkan testing window (requires restart)", settings.vulkanTestingWindow, &vulkanTestingWindowCallback));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/healthbar.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

const hotbar = @import("hotbar.zig");

pub var window = GuiWindow{
	.scale = 0.5,
	.relativePosition = .{
		.{.attachedToWindow = .{.reference = &hotbar.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
		.{.attachedToWindow = .{.reference = &hotbar.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{160, 20},
	.isHud = true,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
	.closeable = false,
};

var heartTexture: Texture = undefined;
var halfHeartTexture: Texture = undefined;
var deadHeartTexture: Texture = undefined;

pub fn init() void {
	heartTexture = Texture.initFromFile("assets/cubyz/ui/hud/heart.png");
	halfHeartTexture = Texture.initFromFile("assets/cubyz/ui/hud/half_heart.png");
	deadHeartTexture = Texture.initFromFile("assets/cubyz/ui/hud/dead_heart.png");
}

pub fn deinit() void {
	heartTexture.deinit();
	halfHeartTexture.deinit();
	deadHeartTexture.deinit();
}

pub fn render() void {
	if (main.game.Player.isCreative())
		return;

	draw.setColor(0xffffffff);
	const displayHealth = @max(0, main.game.Player.super.health);
	const halfHeartUnits: usize = @intFromFloat(@ceil(displayHealth*2));
	const wholeHearts = halfHeartUnits/2;
	const halfHeart = halfHeartUnits%2;
	const totalHearts: usize = @intFromFloat(@ceil(main.game.Player.super.maxHealth));

	var x: f32 = 0;
	var y: f32 = 0;
	for (0..totalHearts) |i| {
		if (x >= window.contentSize[0]) {
			x = 0;
			y += 20;
		}

		if (i < wholeHearts) {
			heartTexture.bindTo(0);
		} else if (i < wholeHearts + halfHeart) {
			halfHeartTexture.bindTo(0);
		} else {
			deadHeartTexture.bindTo(0);
		}

		draw.boundImage(Vec2f{x, window.contentSize[1] - y - 20}, .{20, 20});
		x += 20;
	}

	y += 20;
	if (y != window.contentSize[1]) {
		window.contentSize[1] = y;
		gui.updateWindowPositions();
	}
}

```

`src/gui/windows/hotbar.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ItemStack = main.items.ItemStack;
const Player = main.game.Player;
const Vec2f = main.vec.Vec2f;
const Texture = main.graphics.Texture;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const HorizontalList = GuiComponent.HorizontalList;
const ItemSlot = GuiComponent.ItemSlot;
const Icon = GuiComponent.Icon;

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
	},
	.contentSize = Vec2f{64*12, 64},
	.isHud = true,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
	.closeable = false,
	.scale = 0.75,
};

var hotbarSlotTexture: Texture = undefined;

pub fn init() void {
	hotbarSlotTexture = Texture.initFromFile("assets/cubyz/ui/inventory/hotbar_slot.png");
}

pub fn deinit() void {
	hotbarSlotTexture.deinit();
}

var itemSlots: [12]*ItemSlot = undefined;

pub fn onOpen() void {
	const list = HorizontalList.init();
	for (0..12) |i| {
		itemSlots[i] = ItemSlot.init(.{0, 0}, Player.inventory, @intCast(i), .{.custom = hotbarSlotTexture}, .normal);
		list.add(itemSlots[i]);
	}
	list.finish(.{0, 0}, .center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.size();
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

pub fn update() void {
	Player.mutex.lock();
	defer Player.mutex.unlock();
	itemSlots[Player.selectedSlot].hovered = true;
}

```

`src/gui/windows/inventory.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Player = main.game.Player;
const ItemStack = main.items.ItemStack;
const Vec2f = main.vec.Vec2f;
const Texture = main.graphics.Texture;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const HorizontalList = GuiComponent.HorizontalList;
const VerticalList = GuiComponent.VerticalList;
const ItemSlot = GuiComponent.ItemSlot;

const hotbar = @import("hotbar.zig");

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToWindow = .{.reference = &hotbar.window, .selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
		.{.attachedToWindow = .{.reference = &hotbar.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{64*10, 64*3},
	.scale = 0.75,
	.isHud = true,
	.closeable = false,
};

const padding: f32 = 8;

var craftingIcon: Texture = undefined;

pub fn init() void {
	craftingIcon = Texture.initFromFile("assets/cubyz/ui/inventory/crafting_icon.png");
}

pub fn deinit() void {
	craftingIcon.deinit();
}

var itemSlots: [20]*ItemSlot = undefined;

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, padding + 16}, 300, 0);
	// Some miscellanious slots and buttons:
	// TODO: armor slots, backpack slot + stack-based backpack inventory, other items maybe?
	{
		const row = HorizontalList.init();
		row.add(Button.initIcon(.{0, 0}, .{32, 32}, craftingIcon, true, gui.openWindowCallback("inventory_crafting")));
		list.add(row);
	}
	for (0..2) |y| {
		const row = HorizontalList.init();
		for (0..10) |x| {
			const index: usize = 12 + y*10 + x;
			const slot = ItemSlot.init(.{0, 0}, Player.inventory, @intCast(index), .default, .normal);
			itemSlots[index - 12] = slot;
			row.add(slot);
		}
		list.add(row);
	}
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/inventory_crafting.zig`:

```zig
const std = @import("std");

const main = @import("main");
const items = main.items;
const BaseItemIndex = items.BaseItemIndex;
const ClientInventory = items.Inventory.ClientInventory;
const ItemStack = items.ItemStack;
const Player = main.game.Player;
const Texture = main.graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const Label = GuiComponent.Label;
const HorizontalList = GuiComponent.HorizontalList;
const VerticalList = GuiComponent.VerticalList;
const Icon = GuiComponent.Icon;
const ItemSlot = GuiComponent.ItemSlot;

const inventory = @import("inventory.zig");

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToWindow = .{.reference = &inventory.window, .selfAttachmentPoint = .lower, .otherAttachmentPoint = .upper}},
		.{.attachedToWindow = .{.reference = &inventory.window, .selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
	},
	.contentSize = Vec2f{64*8, 64*4},
	.scale = 0.75,
};

const padding: f32 = 8;

var availableItems: main.List(BaseItemIndex) = undefined;
var itemAmount: main.List(u32) = undefined;
var inventories: main.List(ClientInventory) = undefined;

pub var arrowTexture: Texture = undefined;

pub fn init() void {
	arrowTexture = Texture.initFromFile("assets/cubyz/ui/inventory/crafting_arrow.png");
}

pub fn deinit() void {
	arrowTexture.deinit();
}

fn addItemStackToAvailable(itemStack: ItemStack) void {
	if (itemStack.item == .baseItem) {
		const baseItem = itemStack.item.baseItem;
		for (availableItems.items, 0..) |alreadyPresent, i| {
			if (baseItem == alreadyPresent) {
				itemAmount.items[i] += itemStack.amount;
				return;
			}
		}
		availableItems.append(baseItem);
		itemAmount.append(itemStack.amount);
	}
}

fn findAvailableRecipes(list: *VerticalList) bool {
	const oldAmounts = main.stackAllocator.dupe(u32, itemAmount.items);
	defer main.stackAllocator.free(oldAmounts);
	for (itemAmount.items) |*amount| {
		amount.* = 0;
	}
	// Figure out what items are available in the inventory:
	for (0..main.game.Player.inventory.size()) |i| {
		addItemStackToAvailable(main.game.Player.inventory.getStack(i));
	}
	if (std.mem.eql(u32, oldAmounts, itemAmount.items)) return false;
	// Remove no longer present items:
	var i: u32 = 0;
	while (i < availableItems.items.len) : (i += 1) {
		if (itemAmount.items[i] == 0) {
			_ = itemAmount.swapRemove(i);
			_ = availableItems.swapRemove(i);
		}
	}
	for (inventories.items) |inv| {
		inv.deinit(main.globalAllocator);
	}
	inventories.clearRetainingCapacity();
	// Find all recipes the player can make:
	outer: for (items.recipes()) |*recipe| {
		middle: for (recipe.sourceItems, recipe.sourceAmounts) |sourceItem, sourceAmount| {
			for (availableItems.items, itemAmount.items) |availableItem, availableAmount| {
				if (availableItem == sourceItem and availableAmount >= sourceAmount) {
					continue :middle;
				}
			}
			continue :outer; // Ingredient not found.
		}
		// All ingredients found: Add it to the list.
		const inv = ClientInventory.init(main.globalAllocator, recipe.sourceItems.len + 1, .normal, .{.crafting = recipe}, .other, .{});

		for (0..recipe.sourceAmounts.len) |index| {
			inv.super._items[index].amount = recipe.sourceAmounts[index];
			inv.super._items[index].item = .{.baseItem = recipe.sourceItems[index]};
		}
		inv.super._items[inv.super._items.len - 1].amount = recipe.resultAmount;
		inv.super._items[inv.super._items.len - 1].item = .{.baseItem = recipe.resultItem};

		inventories.append(inv);
		const rowList = HorizontalList.init();
		const maxColumns: u32 = 4;
		const itemsPerColumn = recipe.sourceItems.len/maxColumns;
		const remainder = recipe.sourceItems.len%maxColumns;
		i = 0;
		for (0..maxColumns) |col| {
			var itemsThisColumn = itemsPerColumn;
			if (col < remainder) itemsThisColumn += 1;
			const columnList = VerticalList.init(.{0, 0}, std.math.inf(f32), 0);
			for (0..itemsThisColumn) |_| {
				columnList.add(ItemSlot.init(.{0, 0}, inv, i, .immutable, .immutable));
				i += 1;
			}
			columnList.finish(.center);
			rowList.add(columnList);
		}
		rowList.add(Icon.init(.{8, 0}, .{32, 32}, arrowTexture, false));
		const itemSlot = ItemSlot.init(.{8, 0}, inv, @intCast(recipe.sourceItems.len), .craftingResult, .takeOnly);
		rowList.add(itemSlot);
		rowList.finish(.{0, 0}, .center);
		list.add(rowList);
	}
	return true;
}

fn refresh() void {
	const oldScrollState = if (window.rootComponent) |oldList| oldList.verticalList.scrollBar.currentState else 0;
	const list = VerticalList.init(.{padding, padding + 16}, 300, 8);
	const recipesChanged = findAvailableRecipes(list);
	if (!recipesChanged and window.rootComponent != null) {
		list.deinit();
		return;
	}
	if (window.rootComponent) |*comp| {
		main.heap.GarbageCollection.deferredFree(.{.ptr = comp.verticalList, .freeFunction = main.meta.castFunctionSelfToAnyopaque(VerticalList.deinit)});
	}
	if (list.children.items.len == 0) {
		list.add(Label.init(.{0, 0}, 120, "No craftable\nrecipes found", .center));
	}
	list.finish(.center);
	list.scrollBar.currentState = oldScrollState;
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	window.contentSize[0] = @max(window.contentSize[0], window.getMinWindowWidth());
	gui.updateWindowPositions();
}

pub fn onOpen() void {
	availableItems = .init(main.globalAllocator);
	itemAmount = .init(main.globalAllocator);
	inventories = .init(main.globalAllocator);
	refresh();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
		window.rootComponent = null;
	}
	availableItems.deinit();
	itemAmount.deinit();
	for (inventories.items) |inv| {
		inv.deinit(main.globalAllocator);
	}
	inventories.deinit();
}

pub fn update() void {
	refresh();
}

```

`src/gui/windows/invite.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ConnectionManager = main.network.ConnectionManager;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const CheckBox = @import("../components/CheckBox.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
};

var ipAddressLabel: *Label = undefined;
var ipAddressEntry: *TextInput = undefined;

const padding: f32 = 8;

var ipAddress: []const u8 = "";
var gotIpAddress: std.atomic.Value(bool) = .init(false);
var thread: ?std.Thread = null;
const width: f32 = 420;

fn discoverIpAddress() void {
	main.server.connectionManager.makeOnline();
	ipAddress = std.fmt.allocPrint(main.globalAllocator.allocator, "{f}", .{main.server.connectionManager.externalAddress}) catch unreachable;
	gotIpAddress.store(true, .release);
}

fn discoverIpAddressFromNewThread() void {
	main.initThreadLocals();
	defer main.deinitThreadLocals();

	discoverIpAddress();
}

fn invite() void {
	if (thread) |_thread| {
		_thread.join();
		thread = null;
	}
	const user = main.server.User.initAndIncreaseRefCount(main.server.connectionManager, ipAddressEntry.currentString.items) catch |err| {
		if (err != error.AlreadyConnected) {
			std.log.err("Cannot connect user: {s}", .{@errorName(err)});
		}
		return;
	};
	user.decreaseRefCount();
}

fn copyIp() void {
	main.Window.setClipboardString(ipAddress);
}

fn makePublic(public: bool) void {
	main.server.connectionManager.allowNewConnections.store(public, .monotonic);
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 260, 16);
	list.add(Label.init(.{0, 0}, width, "Please send your IP to the player who wants to join and enter their IP below.", .center));
	//                                           255.255.255.255:?65536 (longest possible ip address)
	ipAddressLabel = Label.init(.{0, 0}, width, "                      ", .center);
	list.add(ipAddressLabel);
	list.add(Button.initText(.{0, 0}, 100, "Copy IP", .init(copyIp)));
	ipAddressEntry = TextInput.init(.{0, 0}, width, 32, settings.lastUsedIPAddress, .{.onNewline = .init(invite)});
	ipAddressEntry.obfuscated = main.settings.streamerMode;
	list.add(ipAddressEntry);
	list.add(Button.initText(.{0, 0}, 100, "Invite", .init(invite)));
	list.add(Button.initText(.{0, 0}, 100, "Manage Players", gui.openWindowCallback("manage_players")));
	list.add(CheckBox.init(.{0, 0}, width, "Allow anyone to join (requires a publicly visible IP address+port which may need some configuration in your router)", main.server.connectionManager.allowNewConnections.load(.monotonic), &makePublic));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();

	thread = std.Thread.spawn(.{}, discoverIpAddressFromNewThread, .{}) catch |err| blk: {
		std.log.err("Error spawning thread: {s}. Doing it in the current thread instead.", .{@errorName(err)});
		discoverIpAddress();
		break :blk null;
	};
}

pub fn onClose() void {
	if (thread) |_thread| {
		_thread.join();
		thread = null;
	}
	if (ipAddress.len != 0) {
		main.globalAllocator.free(ipAddress);
		ipAddress = "";
	}

	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

pub fn update() void {
	if (gotIpAddress.load(.acquire)) {
		gotIpAddress.store(false, .monotonic);

		if (main.settings.streamerMode) {
			const obfuscatedIp = main.utils.obfuscateString(main.stackAllocator, ipAddress);
			defer main.stackAllocator.free(obfuscatedIp);
			ipAddressLabel.updateText(obfuscatedIp);
		} else {
			ipAddressLabel.updateText(ipAddress);
		}
	}
}

```

`src/gui/windows/main.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeable = false,
};

const padding: f32 = 8;

fn exitGame() void {
	main.Window.c.glfwSetWindowShouldClose(main.Window.window, main.Window.c.GLFW_TRUE);
}
pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(Button.initText(.{0, 0}, 128, "Singleplayer", gui.openWindowCallback("save_selection")));
	list.add(Button.initText(.{0, 0}, 128, "Multiplayer", gui.openWindowCallback("multiplayer")));
	list.add(Button.initText(.{0, 0}, 128, "Settings", gui.openWindowCallback("settings")));
	list.add(Button.initText(.{0, 0}, 128, "Touch Grass", .init(exitGame)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/manage_players.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ConnectionManager = main.network.ConnectionManager;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const VerticalList = @import("../components/VerticalList.zig");
const HorizontalList = @import("../components/HorizontalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;
var userList: []*main.server.User = &.{};

fn kick(conn: *main.network.Connection) void {
	conn.disconnect();
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	{
		main.server.connectionManager.mutex.lock();
		defer main.server.connectionManager.mutex.unlock();
		std.debug.assert(userList.len == 0);
		userList = main.globalAllocator.alloc(*main.server.User, main.server.connectionManager.connections.items.len);
		for (main.server.connectionManager.connections.items, 0..) |connection, i| {
			userList[i] = connection.user.?;
			userList[i].increaseRefCount();
			const row = HorizontalList.init();
			if (connection.user.?.name.len != 0) {
				row.add(Label.init(.{0, 0}, 200, connection.user.?.name, .left));
				row.add(Button.initText(.{0, 0}, 100, "Kick", .initWithPtr(kick, connection)));
			} else {
				const ip = std.fmt.allocPrint(main.stackAllocator.allocator, "{f}", .{connection.remoteAddress}) catch unreachable;
				defer main.stackAllocator.free(ip);
				row.add(Label.init(.{0, 0}, 200, ip, .left));
				row.add(Button.initText(.{0, 0}, 100, "Cancel", .initWithPtr(kick, connection)));
			}
			list.add(row);
		}
	}
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	for (userList) |user| {
		user.decreaseRefCount();
	}
	main.globalAllocator.free(userList);
	userList = &.{};
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

pub fn update() void {
	main.server.connectionManager.mutex.lock();
	const serverListLen = main.server.connectionManager.connections.items.len;
	main.server.connectionManager.mutex.unlock();
	if (userList.len != serverListLen) {
		onClose();
		onOpen();
	}
}

```

`src/gui/windows/multiplayer.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ConnectionManager = main.network.ConnectionManager;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
};

var ipAddressLabel: *Label = undefined;
var ipAddressEntry: *TextInput = undefined;

const padding: f32 = 8;

var connection: ?*ConnectionManager = null;
var ipAddress: []const u8 = "";
var gotIpAddress: std.atomic.Value(bool) = .init(false);
var thread: ?std.Thread = null;
const width: f32 = 420;

fn discoverIpAddress() void {
	connection = ConnectionManager.init(main.settings.defaultPort, true) catch |err| {
		std.log.err("Could not open Connection: {s}", .{@errorName(err)});
		ipAddress = main.globalAllocator.dupe(u8, @errorName(err));
		return;
	};
	ipAddress = std.fmt.allocPrint(main.globalAllocator.allocator, "{f}", .{connection.?.externalAddress}) catch unreachable;
	gotIpAddress.store(true, .release);
}

fn discoverIpAddressFromNewThread() void {
	main.initThreadLocals();
	defer main.deinitThreadLocals();

	discoverIpAddress();
}

fn join() void {
	if (thread) |_thread| {
		_thread.join();
		thread = null;
	}
	if (ipAddress.len != 0) {
		main.globalAllocator.free(ipAddress);
		ipAddress = "";
	}
	if (connection) |_connection| {
		_connection.world = &main.game.testWorld;
		main.game.world = &main.game.testWorld;
		std.log.info("Connecting to server: {s}", .{ipAddressEntry.currentString.items});
		main.game.testWorld.init(ipAddressEntry.currentString.items, _connection) catch |err| {
			std.log.err("Encountered error while opening world: {s}", .{@errorName(err)});
			main.gui.windowlist.notification.raiseNotification("Encountered error while opening world: {s}", .{@errorName(err)});
			main.game.world = null;
			_connection.world = null;
			return;
		};
		main.globalAllocator.free(settings.lastUsedIPAddress);
		settings.lastUsedIPAddress = main.globalAllocator.dupe(u8, ipAddressEntry.currentString.items);
		settings.save();
		connection = null;
	} else {
		std.log.err("No connection found. Cannot connect.", .{});
		main.gui.windowlist.notification.raiseNotification("No connection found. Cannot connect.", .{});
	}
	for (gui.openWindows.items) |openWindow| {
		gui.closeWindowFromRef(openWindow);
	}
	gui.openHud();
}

fn copyIp() void {
	main.Window.setClipboardString(ipAddress);
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(Label.init(.{0, 0}, width, "Please send your IP to the host of the game and enter the host's IP below.", .center));
	//                                               255.255.255.255:?65536 (longest possible ip address)
	ipAddressLabel = Label.init(.{0, 0}, width, "                      ", .center);
	list.add(ipAddressLabel);
	list.add(Button.initText(.{0, 0}, 100, "Copy IP", .init(copyIp)));
	ipAddressEntry = TextInput.init(.{0, 0}, width, 32, settings.lastUsedIPAddress, .{.onNewline = .init(join)});
	ipAddressEntry.obfuscated = main.settings.streamerMode;
	list.add(ipAddressEntry);
	list.add(Button.initText(.{0, 0}, 100, "Join", .init(join)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();

	thread = std.Thread.spawn(.{}, discoverIpAddressFromNewThread, .{}) catch |err| blk: {
		std.log.err("Error spawning thread: {s}. Doing it in the current thread instead.", .{@errorName(err)});
		discoverIpAddress();
		break :blk null;
	};
}

pub fn onClose() void {
	if (thread) |_thread| {
		_thread.join();
		thread = null;
	}
	if (connection) |_connection| {
		_connection.deinit();
		connection = null;
	}
	if (ipAddress.len != 0) {
		main.globalAllocator.free(ipAddress);
		ipAddress = "";
	}

	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

pub fn update() void {
	if (gotIpAddress.load(.acquire)) {
		gotIpAddress.store(false, .monotonic);

		if (main.settings.streamerMode) {
			const obfuscatedIp = main.utils.obfuscateString(main.stackAllocator, ipAddress);
			defer main.stackAllocator.free(obfuscatedIp);
			ipAddressLabel.updateText(obfuscatedIp);
		} else {
			ipAddressLabel.updateText(ipAddress);
		}
	}
}

```

`src/gui/windows/notification.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const VerticalList = @import("../components/VerticalList.zig");
const Label = @import("../components/Label.zig");

pub var window: GuiWindow = GuiWindow{
	.contentSize = Vec2f{128, 256},
};

const padding: f32 = 16;
const width: f32 = 256;

var text: []const u8 = "";

pub fn deinit() void {
	main.globalAllocator.free(text);
	text = "";
}

fn setNotificationText(comptime formatText: []const u8, args: anytype) void {
	main.globalAllocator.free(text);
	text = std.fmt.allocPrint(main.globalAllocator.allocator, formatText, args) catch unreachable;
}

pub fn raiseNotification(comptime formatText: []const u8, args: anytype) void {
	main.gui.closeWindow("notification");
	setNotificationText(formatText, args);
	main.gui.openWindow("notification");
}

fn ack() void {
	gui.closeWindowFromRef(&window);
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(Label.init(.{0, 0}, width, text, .left));
	list.add(Button.initText(.{0, 0}, 100, "OK", .init(ack)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/pause.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;

fn reorderHudCallbackFunction() void {
	gui.reorderWindows = !gui.reorderWindows;
}
pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	if (main.server.world != null) {
		list.add(Button.initText(.{0, 0}, 128, "Invite Player", gui.openWindowCallback("invite")));
	}
	list.add(Button.initText(.{0, 0}, 128, "Settings", gui.openWindowCallback("settings")));
	list.add(Button.initText(.{0, 0}, 128, "Reorder HUD", .init(reorderHudCallbackFunction)));
	list.add(Button.initText(.{0, 0}, 128, "Exit World", .init(main.exitToMenu)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/pause_gear.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Texture = main.graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = GuiComponent.Label;
const MutexComponent = GuiComponent.MutexComponent;
const TextInput = GuiComponent.TextInput;
const VerticalList = @import("../components/VerticalList.zig");

pub var window: GuiWindow = GuiWindow{
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
		.{.attachedToFrame = .{.selfAttachmentPoint = .upper, .otherAttachmentPoint = .upper}},
	},
	.scale = 0.5,
	.contentSize = Vec2f{64, 64},
	.showTitleBar = false,
	.hasBackground = false,
	.isHud = true,
	.hideIfMouseIsGrabbed = true,
	.closeable = false,
};

const padding: f32 = 8;
const messageTimeout: i32 = 10000;
const messageFade = 1000;

var mutexComponent: MutexComponent = .{};
var history: main.List(*Label) = undefined;
var expirationTime: main.List(i32) = undefined;
var historyStart: u32 = 0;
var fadeOutEnd: u32 = 0;
var input: *TextInput = undefined;
var hideInput: bool = true;

var pauseIcon: Texture = undefined;

pub fn init() void {
	pauseIcon = Texture.initFromFile("assets/cubyz/ui/pause_icon.png");
}

pub fn deinit() void {
	pauseIcon.deinit();
}

pub fn onOpen() void {
	const button = Button.initIcon(.{0, 0}, .{64, 64}, pauseIcon, true, gui.openWindowCallback("pause"));
	window.contentSize = button.size;
	window.rootComponent = button.toComponent();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/performance_graph.zig`:

```zig
const std = @import("std");

const main = @import("main");
const graphics = main.graphics;
const draw = graphics.draw;
const Texture = graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const GuiComponent = gui.GuiComponent;

const chat = @import("chat.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 64},
	.relativePosition = .{
		.{.attachedToFrame = .{.selfAttachmentPoint = .lower, .otherAttachmentPoint = .lower}},
		.{.attachedToWindow = .{.reference = &chat.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .lower}},
	},
	.isHud = false,
	.showTitleBar = false,
	.hasBackground = false,
	.hideIfMouseIsGrabbed = false,
};

var lastFrameTime: [2048]f32 = undefined;
var index: u31 = 0;
var ssbo: graphics.SSBO = undefined;
var pipeline: graphics.Pipeline = undefined;
const border: f32 = 8;

var uniforms: struct {
	start: c_int,
	dimension: c_int,
	screen: c_int,
	points: c_int,
	offset: c_int,
	lineColor: c_int,
} = undefined;

pub fn init() void {
	ssbo = graphics.SSBO.init();
	pipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/graphics/graph.vert",
		"assets/cubyz/shaders/graphics/graph.frag",
		"",
		&uniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.alphaBlending}},
	);
}

pub fn deinit() void {
	ssbo.deinit();
}

pub fn render() void {
	lastFrameTime[index] = @floatCast(main.lastFrameTime.load(.monotonic)*1000.0);
	index = (index + 1)%@as(u31, @intCast(lastFrameTime.len));
	draw.setColor(0xffffffff);
	draw.text("32 ms", 0, 16, 8, .left);
	draw.text("16 ms", 0, 32, 8, .left);
	draw.text("00 ms", 0, 48, 8, .left);
	draw.setColor(0x80ffffff);
	draw.line(.{border, 24}, .{window.contentSize[0] - border, 24});
	draw.line(.{border, 40}, .{window.contentSize[0] - border, 40});
	draw.line(.{border, 56}, .{window.contentSize[0] - border, 56});
	draw.setColor(0xffffffff);
	pipeline.bind(null);
	graphics.c.glUniform1i(uniforms.points, lastFrameTime.len);
	graphics.c.glUniform1i(uniforms.offset, index);
	graphics.c.glUniform3f(uniforms.lineColor, 1, 1, 1);
	var pos = Vec2f{border, border};
	var dim = window.contentSize - @as(Vec2f, @splat(2*border));
	pos *= @splat(draw.setScale(1));
	pos += draw.setTranslation(.{0, 0});
	dim *= @splat(draw.setScale(1));
	pos = @floor(pos);
	dim = @ceil(dim);
	pos[1] += dim[1];

	graphics.c.glUniform2f(uniforms.screen, @floatFromInt(main.Window.width), @floatFromInt(main.Window.height));
	graphics.c.glUniform2f(uniforms.start, pos[0], pos[1]);
	graphics.c.glUniform2f(uniforms.dimension, dim[0], draw.setScale(1));
	ssbo.bufferData(f32, &lastFrameTime);
	ssbo.bind(5);
	graphics.c.glDrawArrays(graphics.c.GL_LINE_STRIP, 0, lastFrameTime.len);
}

```

`src/gui/windows/save_creation.zig`:

```zig
const std = @import("std");

const build_options = @import("build_options");

const main = @import("main");
const ConnectionManager = main.network.ConnectionManager;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ZonElement = main.ZonElement;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const HorizontalList = @import("../components/HorizontalList.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const CheckBox = @import("../components/CheckBox.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
};

const padding: f32 = 8;

var nameInput: *TextInput = undefined;
var seedInput: *TextInput = undefined;

var gamemodeInput: *Button = undefined;

var worldSettings = main.server.world_zig.Settings.defaults;

const ZonMapEntry = std.StringHashMapUnmanaged(ZonElement).Entry;
var worldPresets: []ZonMapEntry = &.{};
var selectedPreset: usize = undefined;
var defaultPreset: usize = 0;
var presetButton: *Button = undefined;

fn chooseSeed(seedStr: []const u8) u64 {
	if (seedStr.len == 0) {
		return main.random.nextInt(u64, &main.seed);
	} else {
		return std.fmt.parseInt(u64, seedStr, 0) catch {
			return std.hash.Wyhash.hash(0, seedStr);
		};
	}
}

fn gamemodeCallback() void {
	worldSettings.defaultGamemode = std.meta.intToEnum(main.game.Gamemode, @intFromEnum(worldSettings.defaultGamemode) + 1) catch @enumFromInt(0);
	gamemodeInput.child.label.updateText(@tagName(worldSettings.defaultGamemode));
}

fn worldPresetCallback() void {
	selectedPreset += 1;
	if (selectedPreset == worldPresets.len) selectedPreset = 0;
	presetButton.child.label.updateText(worldPresets[selectedPreset].key_ptr.*);
}

fn allowCheatsCallback(allow: bool) void {
	worldSettings.allowCheats = allow;
}

fn testingModeCallback(enabled: bool) void {
	worldSettings.testingMode = enabled;
}

fn createWorld() void {
	const worldName = nameInput.currentString.items;
	worldSettings.seed = chooseSeed(seedInput.currentString.items);

	main.server.world_zig.tryCreateWorld(worldName, worldSettings, worldPresets[selectedPreset].value_ptr.*) catch |err| {
		std.log.err("Error while creating new world: {s}", .{@errorName(err)});
	};
	gui.closeWindowFromRef(&window);
	gui.windowlist.save_selection.needsUpdate = true;
	gui.openWindow("save_selection");
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 8);

	if (worldPresets.len == 0) {
		var presetMap = main.assets.worldPresets();
		var entryList: main.ListUnmanaged(ZonMapEntry) = .initCapacity(main.globalArena, presetMap.count());
		var iterator = presetMap.iterator();
		while (iterator.next()) |entry| {
			entryList.appendAssumeCapacity(entry);
		}

		std.sort.insertion(ZonMapEntry, entryList.items, {}, struct {
			fn lessThanFn(_: void, lhs: ZonMapEntry, rhs: ZonMapEntry) bool {
				return std.ascii.lessThanIgnoreCase(lhs.key_ptr.*, rhs.key_ptr.*);
			}
		}.lessThanFn);
		worldPresets = entryList.items;
		for (worldPresets, 0..) |entry, i| {
			if (std.mem.eql(u8, entry.key_ptr.*, "cubyz:default")) {
				defaultPreset = i;
			}
		}
	}
	selectedPreset = defaultPreset;

	var num: usize = 1;
	while (true) {
		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/Save{}", .{num}) catch unreachable;
		defer main.stackAllocator.free(path);
		if (!main.files.cubyzDir().hasDir(path)) break;
		num += 1;
	}
	const name = std.fmt.allocPrint(main.stackAllocator.allocator, "Save{}", .{num}) catch unreachable;
	defer main.stackAllocator.free(name);
	nameInput = TextInput.init(.{0, 0}, 128, 22, name, .{.onNewline = .init(createWorld)});
	list.add(nameInput);

	gamemodeInput = Button.initText(.{0, 0}, 128, @tagName(worldSettings.defaultGamemode), .init(gamemodeCallback));
	list.add(gamemodeInput);

	list.add(CheckBox.init(.{0, 0}, 128, "Allow Cheats", worldSettings.allowCheats, &allowCheatsCallback));

	if (!build_options.isTaggedRelease) {
		list.add(CheckBox.init(.{0, 0}, 128, "Testing mode (for developers)", worldSettings.testingMode, &testingModeCallback));
	}

	presetButton = Button.initText(.{0, 0}, 128, worldPresets[selectedPreset].key_ptr.*, .init(worldPresetCallback));
	list.add(presetButton);

	const seedLabel = Label.init(.{0, 0}, 48, "Seed:", .left);
	seedInput = TextInput.init(.{0, 0}, 128 - 48, 22, "", .{.onNewline = .init(createWorld)});
	const seedRow = HorizontalList.init();
	seedRow.add(seedLabel);
	seedRow.add(seedInput);
	seedRow.finish(.{0, 0}, .center);
	list.add(seedRow);

	list.add(Button.initText(.{0, 0}, 128, "Create World", .init(createWorld)));

	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/save_selection.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ConnectionManager = main.network.ConnectionManager;
const settings = main.settings;
const Vec2f = main.vec.Vec2f;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const Texture = main.graphics.Texture;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const HorizontalList = @import("../components/HorizontalList.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
};

const padding: f32 = 8;
const width: f32 = 128;
var buttonNameArena: main.heap.NeverFailingArenaAllocator = undefined;

pub var needsUpdate: bool = false;

var deleteIcon: Texture = undefined;
var fileExplorerIcon: Texture = undefined;

const WorldInfo = struct {
	lastUsedTime: i64,
	name: []const u8,
	fileName: []const u8,
};
var worldList: main.ListUnmanaged(WorldInfo) = .{};

pub fn init() void {
	deleteIcon = Texture.initFromFile("assets/cubyz/ui/delete_icon.png");
	fileExplorerIcon = Texture.initFromFile("assets/cubyz/ui/file_explorer_icon.png");
}

pub fn deinit() void {
	deleteIcon.deinit();
	fileExplorerIcon.deinit();
}

pub fn openWorld(name: []const u8) void {
	const clientConnection = ConnectionManager.init(0, false) catch |err| {
		std.log.err("Encountered error while opening connection: {s}", .{@errorName(err)});
		return;
	};

	std.log.info("Opening world {s}", .{name});
	main.server.thread = std.Thread.spawn(.{}, main.server.startFromNewThread, .{name, clientConnection.localPort}) catch |err| {
		std.log.err("Encountered error while starting server thread: {s}", .{@errorName(err)});
		return;
	};
	main.server.thread.?.setName("Server") catch |err| {
		std.log.err("Failed to rename Server thread: {s}", .{@errorName(err)});
	};

	while (!main.server.running.load(.acquire)) {
		main.io.sleep(.fromMilliseconds(1), .awake) catch {};
		main.heap.GarbageCollection.syncPoint();
	}
	clientConnection.world = &main.game.testWorld;
	const ipPort = std.fmt.allocPrint(main.stackAllocator.allocator, "127.0.0.1:{}", .{main.server.connectionManager.localPort}) catch unreachable;
	defer main.stackAllocator.free(ipPort);
	main.game.world = &main.game.testWorld;
	main.game.testWorld.init(ipPort, clientConnection) catch |err| {
		std.log.err("Encountered error while opening world: {s}", .{@errorName(err)});
	};
	for (gui.openWindows.items) |openWindow| {
		gui.closeWindowFromRef(openWindow);
	}
	gui.openHud();
}

fn openWorldWrap(index: usize) void { // TODO: Improve this situation. Maybe it makes sense to always use 2 arguments in the Callback.
	openWorld(worldList.items[index].fileName);
}

fn deleteWorld(index: usize) void {
	main.gui.closeWindow("delete_world_confirmation");
	main.gui.windowlist.delete_world_confirmation.setDeleteWorldName(worldList.items[index].fileName);
	main.gui.openWindow("delete_world_confirmation");
}

fn openFolder(index: usize) void {
	const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/saves/{s}", .{main.files.cubyzDirStr(), worldList.items[index].fileName}) catch unreachable;
	defer main.stackAllocator.free(path);

	main.files.openDirInWindow(path);
}

pub fn update() void {
	if (needsUpdate) {
		needsUpdate = false;
		onClose();
		onOpen();
	}
}

pub fn onOpen() void {
	buttonNameArena = main.heap.NeverFailingArenaAllocator.init(main.globalAllocator);
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 8);
	list.add(Label.init(.{0, 0}, width, "**Select World**", .center));
	list.add(Button.initText(.{0, 0}, 128, "Create New World", gui.openWindowCallback("save_creation")));
	readingSaves: {
		var dir = main.files.cubyzDir().openIterableDir("saves") catch |err| {
			list.add(Label.init(.{0, 0}, 128, "Encountered error while trying to open saves folder:", .center));
			list.add(Label.init(.{0, 0}, 128, @errorName(err), .center));
			break :readingSaves;
		};
		defer dir.close();

		var iterator = dir.iterate();
		while (iterator.next() catch |err| {
			list.add(Label.init(.{0, 0}, 128, "Encountered error while iterating over saves folder:", .center));
			list.add(Label.init(.{0, 0}, 128, @errorName(err), .center));
			break :readingSaves;
		}) |entry| {
			if (entry.kind == .directory) {
				const worldInfoPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/world.zig.zon", .{entry.name}) catch unreachable;
				defer main.stackAllocator.free(worldInfoPath);
				const worldInfo = main.files.cubyzDir().readToZon(main.stackAllocator, worldInfoPath) catch |err| {
					std.log.err("Couldn't open save {s}: {s}", .{worldInfoPath, @errorName(err)});
					continue;
				};
				defer worldInfo.deinit(main.stackAllocator);

				worldList.append(main.globalAllocator, .{
					.fileName = main.globalAllocator.dupe(u8, entry.name),
					.lastUsedTime = worldInfo.get(i64, "lastUsedTime", 0),
					.name = main.globalAllocator.dupe(u8, worldInfo.get([]const u8, "name", entry.name)),
				});
			}
		}
	}

	std.sort.insertion(WorldInfo, worldList.items, {}, struct {
		fn lessThan(_: void, lhs: WorldInfo, rhs: WorldInfo) bool {
			return rhs.lastUsedTime -% lhs.lastUsedTime < 0;
		}
	}.lessThan);

	for (worldList.items, 0..) |worldInfo, i| {
		const row = HorizontalList.init();
		row.add(Button.initText(.{0, 0}, 128, worldInfo.name, .initWithInt(openWorldWrap, i)));
		row.add(Button.initIcon(.{8, 0}, .{16, 16}, fileExplorerIcon, false, .initWithInt(openFolder, i)));
		row.add(Button.initIcon(.{8, 0}, .{16, 16}, deleteIcon, false, .initWithInt(deleteWorld, i)));
		row.finish(.{0, 0}, .center);
		list.add(row);
	}

	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	for (worldList.items) |worldInfo| {
		main.globalAllocator.free(worldInfo.fileName);
		main.globalAllocator.free(worldInfo.name);
	}
	worldList.clearAndFree(main.globalAllocator);
	buttonNameArena.deinit();
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/settings.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window: GuiWindow = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(Button.initText(.{0, 0}, 128, "Graphics", gui.openWindowCallback("graphics")));
	list.add(Button.initText(.{0, 0}, 128, "Sound", gui.openWindowCallback("sound")));
	list.add(Button.initText(.{0, 0}, 128, "Controls", gui.openWindowCallback("controls")));
	list.add(Button.initText(.{0, 0}, 128, "Advanced Controls", gui.openWindowCallback("advanced_controls")));
	list.add(Button.initText(.{0, 0}, 128, "Social", gui.openWindowCallback("social")));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/sign_editor.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const Label = @import("../components/Label.zig");
const TextInput = @import("../components/TextInput.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};
var textComponent: *TextInput = undefined;

const padding: f32 = 8;

var pos: main.vec.Vec3i = undefined;
var oldText: []const u8 = &.{};

pub fn deinit() void {
	main.globalAllocator.free(oldText);
	oldText = &.{};
}

pub fn openFromSignData(_pos: main.vec.Vec3i, _oldText: []const u8) void {
	pos = _pos;
	main.globalAllocator.free(oldText);
	oldText = main.globalAllocator.dupe(u8, _oldText);
	gui.closeWindowFromRef(&window);
	gui.openWindowFromRef(&window);
	main.Window.setMouseGrabbed(false);
}

fn apply() void {
	const visibleCharacterCount = main.graphics.TextBuffer.Parser.countVisibleCharacters(textComponent.currentString.items);
	if (textComponent.currentString.items.len > 500 or visibleCharacterCount > 100) {
		std.log.err("Text is too long with {}/{} characters. Limits are 100/500", .{visibleCharacterCount, textComponent.currentString.items.len});
		return;
	}

	main.block_entity.BlockEntityTypes.Sign.updateTextFromClient(pos, textComponent.currentString.items);

	gui.toggleGameMenu();
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	const width = 128 + padding;
	textComponent = TextInput.init(.{0, 0}, width, 16*4 + 8, oldText, .{.onNewline = .init(apply)});
	list.add(textComponent);
	list.add(Button.initText(.{0, 0}, 100, "Apply", .init(apply)));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/social.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const CheckBox = @import("../components/CheckBox.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window: GuiWindow = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;

fn toggleStreamerMode(value: bool) void {
	main.settings.streamerMode = value;
	main.settings.save();
}

fn logout() void {
	main.settings.storedAccount.deinit(main.globalAllocator);
	main.settings.storedAccount = .empty;
	main.settings.save();
	for (gui.openWindows.items) |openWindow| {
		gui.closeWindowFromRef(openWindow);
	}
	gui.openWindow("authentication/login");
}

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 400, 16);
	list.add(CheckBox.init(.{0, 0}, 316, "Streamer Mode (hides sensitive data)", main.settings.streamerMode, &toggleStreamerMode));
	if (main.game.world == null) {
		list.add(Button.initText(.{0, 0}, 128, "Change Name", gui.openWindowCallback("change_name")));
		list.add(Button.initText(.{0, 0}, 128, "Logout", .init(logout)));
	}
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/sound.zig`:

```zig
const std = @import("std");

const main = @import("main");
const settings = main.settings;
const Vec2f = main.vec.Vec2f;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = @import("../components/Button.zig");
const ContinuousSlider = @import("../components/ContinuousSlider.zig");
const VerticalList = @import("../components/VerticalList.zig");

pub var window = GuiWindow{
	.contentSize = Vec2f{128, 256},
	.closeIfMouseIsGrabbed = true,
};

fn musicCallback(newValue: f32) void {
	settings.musicVolume = deziBelToLinear(newValue);
	settings.save();
}

fn deziBelToLinear(x: f32) f32 {
	if (x < -59.95) return 0;
	return std.math.pow(f32, 10, x/20);
}

fn linearToDezibel(x: f32) f32 {
	const db = 20*std.math.log10(x);
	if (db < -59.95) return -60;
	return db;
}

fn musicFormatter(allocator: NeverFailingAllocator, value: f32) []const u8 {
	const percentage = 100*deziBelToLinear(value);
	if (percentage == 0) return allocator.dupe(u8, "Music volume: Off");
	return std.fmt.allocPrint(allocator.allocator, "Music volume:", .{}) catch unreachable;
}

const padding: f32 = 8;

pub fn onOpen() void {
	const list = VerticalList.init(.{padding, 16 + padding}, 300, 16);
	list.add(ContinuousSlider.init(.{0, 0}, 128, -60, 0, linearToDezibel(settings.musicVolume), &musicCallback, &musicFormatter));
	list.finish(.center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

pub fn onClose() void {
	if (window.rootComponent) |*comp| {
		comp.deinit();
	}
}

```

`src/gui/windows/workbench.zig`:

```zig
const std = @import("std");

const main = @import("main");
const items = main.items;
const BaseItem = items.BaseItem;
const ClientInventory = items.Inventory.ClientInventory;
const Item = items.Item;
const Tool = items.Tool;
const ToolType = items.ToolType;
const ToolTypeIndex = items.ToolTypeIndex;
const Player = main.game.Player;
const Texture = main.graphics.Texture;
const Vec2f = main.vec.Vec2f;

const gui = @import("../gui.zig");
const GuiComponent = gui.GuiComponent;
const GuiWindow = gui.GuiWindow;
const Button = GuiComponent.Button;
const HorizontalList = GuiComponent.HorizontalList;
const VerticalList = GuiComponent.VerticalList;
const Icon = GuiComponent.Icon;
const ItemSlot = GuiComponent.ItemSlot;

const inventory = @import("inventory.zig");
const inventory_crafting = @import("inventory_crafting.zig");

pub var window = GuiWindow{
	.relativePosition = .{
		.{.attachedToWindow = .{.reference = &inventory.window, .selfAttachmentPoint = .middle, .otherAttachmentPoint = .middle}},
		.{.attachedToWindow = .{.reference = &inventory.window, .selfAttachmentPoint = .upper, .otherAttachmentPoint = .lower}},
	},
	.contentSize = Vec2f{64*8, 64*4},
	.closeIfMouseIsGrabbed = true,
};

const padding: f32 = 8;

var inv: ClientInventory = undefined;

var itemSlots: [25]*ItemSlot = undefined;

var toolTypes: main.ListUnmanaged(ToolTypeIndex) = undefined;
var currentToolType: usize = 0;

var toolButton: *Button = undefined;

var needsUpdate: bool = false;

fn toggleTool() void {
	currentToolType += 1;
	currentToolType %= toolTypes.items.len;
	toolButton.child.label.updateText(toolTypes.items[currentToolType].id());
	needsUpdate = true;
}

fn openInventory() void {
	inv = ClientInventory.init(main.globalAllocator, 26, .{.workbench = toolTypes.items[currentToolType]}, .serverShared, .other, .{});
	const list = HorizontalList.init();
	{ // crafting grid
		const grid = VerticalList.init(.{0, 0}, 300, 0);
		// Inventory:
		for (0..5) |y| {
			const row = HorizontalList.init();
			for (0..5) |x| {
				const index = x + y*5;
				const slotInfo = toolTypes.items[currentToolType].slotInfos()[index];
				const slot = ItemSlot.init(.{0, 0}, inv, @intCast(index), if (slotInfo.disabled) .invisible else if (slotInfo.optional) .immutable else .default, if (slotInfo.disabled) .immutable else .normal);
				itemSlots[index] = slot;
				row.add(slot);
			}
			grid.add(row);
		}
		grid.finish(.center);
		list.add(grid);
	}
	const verticalThing = VerticalList.init(.{0, 0}, 300, padding);
	toolButton = Button.initText(.{8, 0}, 116, toolTypes.items[currentToolType].id(), .init(toggleTool));
	verticalThing.add(toolButton);
	const buttonHeight = verticalThing.size[1];
	const craftingResultList = HorizontalList.init();
	craftingResultList.add(Icon.init(.{0, 0}, .{32, 32}, inventory_crafting.arrowTexture, false));
	craftingResultList.add(ItemSlot.init(.{8, 0}, inv, 25, .craftingResult, .takeOnly));
	craftingResultList.finish(.{padding, padding}, .center);
	verticalThing.add(craftingResultList);
	verticalThing.size[1] += buttonHeight + 2*padding; // Centering the thing
	verticalThing.finish(.center);
	list.add(verticalThing);
	list.finish(.{padding, padding + 16}, .center);
	window.rootComponent = list.toComponent();
	window.contentSize = window.rootComponent.?.pos() + window.rootComponent.?.size() + @as(Vec2f, @splat(padding));
	gui.updateWindowPositions();
}

fn closeInventory() void {
	inv.deinit(main.globalAllocator);
	if (window.rootComponent) |*comp| {
		comp.deinit();
		window.rootComponent = null;
	}
}

pub fn update() void {
	if (needsUpdate) {
		needsUpdate = false;
		closeInventory();
		openInventory();
	}
}

pub fn render() void {
	const currentResult = inv.getItem(25);
	if (currentResult == .null) return;

	const offsetX = 5*ItemSlot.sizeWithBorder + 20;
	const offsetY = 4*ItemSlot.sizeWithBorder;
	const fontSize = 16;

	main.graphics.draw.print("{s}{} durability", .{if (currentResult.tool.maxDurability != 0) "#ffffff" else "#ff0000", @as(usize, @intFromFloat(currentResult.tool.maxDurability))}, offsetX, offsetY, fontSize, .left);
	main.graphics.draw.print("#ffffff{d:.1} swings/s", .{currentResult.tool.swingSpeed}, offsetX, offsetY + fontSize, fontSize, .left);
	main.graphics.draw.print("#ffffff{d:.1} damage", .{currentResult.tool.damage}, offsetX, offsetY + 2*fontSize, fontSize, .left);
}

pub fn onOpen() void {
	currentToolType = 0;

	toolTypes = .{};
	var iterator = ToolTypeIndex.iterator();
	while (iterator.next()) |toolType| {
		toolTypes.append(main.globalAllocator, toolType);
	}

	openInventory();
}

pub fn onClose() void {
	toolTypes.deinit(main.globalAllocator);
	closeInventory();
}

```

`src/itemdrop.zig`:

```zig
const std = @import("std");

const blocks = @import("blocks.zig");
const chunk_zig = @import("chunk.zig");
const ServerChunk = chunk_zig.ServerChunk;
const game = @import("game.zig");
const World = game.World;
const ServerWorld = main.server.ServerWorld;
const graphics = @import("graphics.zig");
const c = graphics.c;
const items = @import("items.zig");
const ItemStack = items.ItemStack;
const ZonElement = @import("zon.zig").ZonElement;
const main = @import("main");
const random = @import("random.zig");
const settings = @import("settings.zig");
const utils = @import("utils.zig");
const vec = @import("vec.zig");
const Mat4f = vec.Mat4f;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const BinaryReader = main.utils.BinaryReader;
const BinaryWriter = main.utils.BinaryWriter;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const ItemDrop = struct { // MARK: ItemDrop
	pos: Vec3d,
	vel: Vec3d,
	rot: Vec3f,
	itemStack: ItemStack,
	despawnTime: i32,
	pickupCooldown: i32,

	reverseIndex: u16,
};

pub const ItemDropNetworkData = struct {
	index: u16,
	pos: Vec3d,
	vel: Vec3d,
};

pub const ItemDropManager = struct { // MARK: ItemDropManager
	/// Half the side length of all item entities hitboxes as a cube.
	pub const radius: f64 = 0.1;
	/// Side length of all item entities hitboxes as a cube.
	pub const diameter: f64 = 2*radius;

	pub const pickupRange: f64 = 1.0;

	const terminalVelocity = 40.0;
	const gravity = 9.81;

	const maxCapacity = 65536;

	allocator: NeverFailingAllocator,

	list: std.MultiArrayList(ItemDrop),

	indices: [maxCapacity]u16 = undefined,

	emptyMutex: std.Thread.Mutex = .{},
	isEmpty: std.bit_set.ArrayBitSet(usize, maxCapacity),

	changeQueue: main.utils.ConcurrentQueue(union(enum) { add: struct { u16, ItemDrop }, remove: u16 }),

	world: ?*ServerWorld,
	airDragFactor: f64,

	size: u32 = 0,

	pub fn init(self: *ItemDropManager, allocator: NeverFailingAllocator, world: ?*ServerWorld) void {
		self.* = ItemDropManager{
			.allocator = allocator,
			.list = std.MultiArrayList(ItemDrop){},
			.isEmpty = .initFull(),
			.changeQueue = .init(allocator, 16),
			.world = world,
			.airDragFactor = gravity/terminalVelocity,
		};
		self.list.resize(self.allocator.allocator, maxCapacity) catch unreachable;
	}

	pub fn deinit(self: *ItemDropManager) void {
		self.processChanges();
		self.changeQueue.deinit();
		for (self.indices[0..self.size]) |i| {
			self.list.items(.itemStack)[i].item.deinit();
		}
		self.list.deinit(self.allocator.allocator);
	}

	pub fn loadFrom(self: *ItemDropManager, zon: ZonElement) void {
		const zonArray = zon.getChild("array");
		for (zonArray.toSlice()) |elem| {
			self.addFromZon(elem);
		}
	}

	pub fn loadFromBytes(self: *ItemDropManager, reader: *main.utils.BinaryReader) !void {
		const version = try reader.readInt(u8);
		if (version != 0) return error.UnsupportedVersion;
		var i: u16 = 0;
		while (reader.remaining.len != 0) : (i += 1) {
			try self.addFromBytes(reader, i);
		}
	}

	pub fn storeToBytes(self: *ItemDropManager, writer: *main.utils.BinaryWriter) void {
		const version = 0;
		writer.writeInt(u8, version);
		for (self.indices[0..self.size]) |i| {
			storeSingleToBytes(writer, self.list.get(i));
		}
	}

	fn addFromBytes(self: *ItemDropManager, reader: *main.utils.BinaryReader, i: u16) !void {
		const despawnTime = try reader.readInt(i32);
		const pos = try reader.readVec(Vec3d);
		const vel = try reader.readVec(Vec3d);
		const itemStack = try items.ItemStack.fromBytes(reader);
		self.addWithIndex(i, pos, vel, random.nextFloatVector(3, &main.seed)*@as(Vec3f, @splat(2*std.math.pi)), itemStack, despawnTime, 0);
	}

	fn storeSingleToBytes(writer: *main.utils.BinaryWriter, itemdrop: ItemDrop) void {
		writer.writeInt(i32, itemdrop.despawnTime);
		writer.writeVec(Vec3d, itemdrop.pos);
		writer.writeVec(Vec3d, itemdrop.vel);
		itemdrop.itemStack.toBytes(writer);
	}

	fn addFromZon(self: *ItemDropManager, zon: ZonElement) void {
		const item = items.Item.init(zon) catch |err| {
			const msg = zon.toStringEfficient(main.stackAllocator, "");
			defer main.stackAllocator.free(msg);
			std.log.err("Ignoring invalid item drop {s} which caused {s}", .{msg, @errorName(err)});
			return;
		};
		const properties = .{
			zon.get(Vec3d, "pos", .{0, 0, 0}),
			zon.get(Vec3d, "vel", .{0, 0, 0}),
			random.nextFloatVector(3, &main.seed)*@as(Vec3f, @splat(2*std.math.pi)),
			items.ItemStack{.item = item, .amount = zon.get(u16, "amount", 1)},
			zon.get(i32, "despawnTime", 60),
			0,
		};
		if (zon.get(?u16, "i", null)) |i| {
			@call(.auto, addWithIndex, .{self, i} ++ properties);
		} else {
			@call(.auto, add, .{self} ++ properties);
		}
	}

	pub fn getPositionAndVelocityData(self: *ItemDropManager, allocator: NeverFailingAllocator) []ItemDropNetworkData {
		const result = allocator.alloc(ItemDropNetworkData, self.size);
		for (self.indices[0..self.size], result) |i, *res| {
			res.* = .{
				.index = i,
				.pos = self.list.items(.pos)[i],
				.vel = self.list.items(.vel)[i],
			};
		}
		return result;
	}

	pub fn getInitialList(self: *ItemDropManager, allocator: NeverFailingAllocator) ZonElement {
		self.processChanges(); // Make sure all the items from the queue are included.
		var list = ZonElement.initArray(allocator);
		var ii: u32 = 0;
		while (ii < self.size) : (ii += 1) {
			const i = self.indices[ii];
			list.array.append(self.storeSingle(allocator, i));
		}
		return list;
	}

	fn storeDrop(allocator: NeverFailingAllocator, itemDrop: ItemDrop, i: u16) ZonElement {
		const obj = ZonElement.initObject(allocator);
		obj.put("i", i);
		obj.put("pos", itemDrop.pos);
		obj.put("vel", itemDrop.vel);
		itemDrop.itemStack.storeToZon(allocator, obj);
		obj.put("despawnTime", itemDrop.despawnTime);
		return obj;
	}

	fn storeSingle(self: *ItemDropManager, allocator: NeverFailingAllocator, i: u16) ZonElement {
		return storeDrop(allocator, self.list.get(i), i);
	}

	pub fn store(self: *ItemDropManager, allocator: NeverFailingAllocator) ZonElement {
		const zonArray = ZonElement.initArray(allocator);
		for (self.indices[0..self.size]) |i| {
			const item = self.storeSingle(allocator, i);
			zonArray.array.append(item);
		}
		const zon = ZonElement.initObject(allocator);
		zon.put("array", zonArray);
		return zon;
	}

	pub fn update(self: *ItemDropManager, deltaTime: f32) void {
		std.debug.assert(self.world != null);
		self.processChanges();
		const pos = self.list.items(.pos);
		const vel = self.list.items(.vel);
		const pickupCooldown = self.list.items(.pickupCooldown);
		const despawnTime = self.list.items(.despawnTime);
		var ii: u32 = 0;
		while (ii < self.size) {
			const i = self.indices[ii];
			if (self.world.?.getSimulationChunkAndIncreaseRefCount(@intFromFloat(pos[i][0]), @intFromFloat(pos[i][1]), @intFromFloat(pos[i][2]))) |simChunk| {
				defer simChunk.decreaseRefCount();
				if (simChunk.getChunk()) |chunk| {
					// Check collision with blocks:
					self.updateEnt(chunk, &pos[i], &vel[i], deltaTime);
				}
			}
			pickupCooldown[i] -= 1;
			despawnTime[i] -= 1;
			if (despawnTime[i] < 0) {
				self.directRemove(i);
			} else {
				ii += 1;
			}
		}
	}

	pub fn add(self: *ItemDropManager, pos: Vec3d, vel: Vec3d, rot: Vec3f, itemStack: ItemStack, despawnTime: i32, pickupCooldown: i32) void {
		self.emptyMutex.lock();
		const i: u16 = @intCast(self.isEmpty.findFirstSet() orelse {
			self.emptyMutex.unlock();
			std.log.err("Item drop capacitiy limit reached. Failed to add itemStack: {}×{s}", .{itemStack.amount, itemStack.item.id() orelse return});
			itemStack.item.deinit();
			return;
		});
		self.isEmpty.unset(i);
		const drop = ItemDrop{
			.pos = pos,
			.vel = vel,
			.rot = rot,
			.itemStack = itemStack,
			.despawnTime = despawnTime,
			.pickupCooldown = pickupCooldown,
			.reverseIndex = undefined,
		};
		if (self.world != null) {
			const list = ZonElement.initArray(main.stackAllocator);
			defer list.deinit(main.stackAllocator);
			list.array.append(.null);
			list.array.append(storeDrop(main.stackAllocator, drop, i));
			const updateData = list.toStringEfficient(main.stackAllocator, &.{});
			defer main.stackAllocator.free(updateData);

			const userList = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
			defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
			for (userList) |user| {
				main.network.protocols.entity.send(user.conn, updateData);
			}
		}

		self.emptyMutex.unlock();
		self.changeQueue.pushBack(.{.add = .{i, drop}});
	}

	fn addWithIndex(self: *ItemDropManager, i: u16, pos: Vec3d, vel: Vec3d, rot: Vec3f, itemStack: ItemStack, despawnTime: i32, pickupCooldown: i32) void {
		self.emptyMutex.lock();
		std.debug.assert(self.isEmpty.isSet(i));
		self.isEmpty.unset(i);
		const drop = ItemDrop{
			.pos = pos,
			.vel = vel,
			.rot = rot,
			.itemStack = itemStack,
			.despawnTime = despawnTime,
			.pickupCooldown = pickupCooldown,
			.reverseIndex = undefined,
		};
		if (self.world != null) {
			const list = ZonElement.initArray(main.stackAllocator);
			defer list.deinit(main.stackAllocator);
			list.array.append(.null);
			list.array.append(storeDrop(main.stackAllocator, drop, i));
			const updateData = list.toStringEfficient(main.stackAllocator, &.{});
			defer main.stackAllocator.free(updateData);

			const userList = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
			defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
			for (userList) |user| {
				main.network.protocols.entity.send(user.conn, updateData);
			}
		}

		self.emptyMutex.unlock();
		self.changeQueue.pushBack(.{.add = .{i, drop}});
	}

	fn processChanges(self: *ItemDropManager) void {
		while (self.changeQueue.popFront()) |data| {
			switch (data) {
				.add => |addData| {
					self.internalAdd(addData[0], addData[1]);
				},
				.remove => |index| {
					self.internalRemove(index);
				},
			}
		}
	}

	fn internalAdd(self: *ItemDropManager, i: u16, drop_: ItemDrop) void {
		var drop = drop_;
		if (self.world == null) {
			ClientItemDropManager.clientSideInternalAdd(self, i, drop);
		}
		drop.reverseIndex = @intCast(self.size);
		self.list.set(i, drop);
		self.indices[self.size] = i;
		self.size += 1;
	}

	fn internalRemove(self: *ItemDropManager, i: u16) void {
		self.size -= 1;
		const ii = self.list.items(.reverseIndex)[i];
		self.list.items(.itemStack)[i].deinit();
		self.list.items(.itemStack)[i] = .{};
		self.indices[ii] = self.indices[self.size];
		self.list.items(.reverseIndex)[self.indices[self.size]] = ii;
	}

	fn directRemove(self: *ItemDropManager, i: u16) void {
		std.debug.assert(self.world != null);
		self.emptyMutex.lock();
		self.isEmpty.set(i);

		const list = ZonElement.initArray(main.stackAllocator);
		defer list.deinit(main.stackAllocator);
		list.array.append(.null);
		list.array.append(.{.int = i});
		const updateData = list.toStringEfficient(main.stackAllocator, &.{});
		defer main.stackAllocator.free(updateData);

		const userList = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
		defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
		for (userList) |user| {
			main.network.protocols.entity.send(user.conn, updateData);
		}

		self.emptyMutex.unlock();
		self.internalRemove(i);
	}

	fn updateEnt(self: *ItemDropManager, chunk: *ServerChunk, pos: *Vec3d, vel: *Vec3d, deltaTime: f64) void {
		const hitBox = main.game.collision.Box{.min = @splat(-radius), .max = @splat(radius)};
		if (main.game.collision.collides(.server, .x, 0, pos.*, hitBox) != null) {
			self.fixStuckInBlock(chunk, pos, vel, deltaTime);
			return;
		}
		vel.* += Vec3d{0, 0, -gravity*deltaTime};
		inline for (0..3) |i| {
			const move = vel.*[i]*deltaTime; // + acceleration[i]*deltaTime;
			if (main.game.collision.collides(.server, @enumFromInt(i), move, pos.*, hitBox)) |box| {
				if (move < 0) {
					pos.*[i] = box.max[i] + radius;
				} else {
					pos.*[i] = box.max[i] - radius;
				}
				vel.*[i] = 0;
			} else {
				pos.*[i] += move;
			}
		}
		// Apply drag:
		vel.* *= @splat(@max(0, 1 - self.airDragFactor*deltaTime));
	}

	fn fixStuckInBlock(self: *ItemDropManager, chunk: *ServerChunk, pos: *Vec3d, vel: *Vec3d, deltaTime: f64) void {
		const centeredPos = pos.* - @as(Vec3d, @splat(0.5));
		const pos0: Vec3i = @intFromFloat(@floor(centeredPos));

		var closestEmptyBlock: Vec3i = @splat(-1);
		var closestDist = std.math.floatMax(f64);
		var delta = Vec3i{0, 0, 0};
		while (delta[0] <= 1) : (delta[0] += 1) {
			delta[1] = 0;
			while (delta[1] <= 1) : (delta[1] += 1) {
				delta[2] = 0;
				while (delta[2] <= 1) : (delta[2] += 1) {
					const isSolid = self.checkBlock(chunk, pos, pos0 + delta);
					if (!isSolid) {
						const dist = vec.lengthSquare(@as(Vec3d, @floatFromInt(pos0 + delta)) - centeredPos);
						if (dist < closestDist) {
							closestDist = dist;
							closestEmptyBlock = delta;
						}
					}
				}
			}
		}

		vel.* = @splat(0);
		const unstuckVelocity: f64 = 1;
		if (closestDist == std.math.floatMax(f64)) {
			// Surrounded by solid blocks → move upwards
			vel.*[2] = unstuckVelocity;
			pos.*[2] += vel.*[2]*deltaTime;
		} else {
			vel.* = @as(Vec3d, @splat(unstuckVelocity))*(@as(Vec3d, @floatFromInt(pos0 + closestEmptyBlock)) - centeredPos);
			pos.* += (vel.*)*@as(Vec3d, @splat(deltaTime));
		}
	}

	fn checkBlock(self: *ItemDropManager, chunk: *ServerChunk, pos: *Vec3d, blockPos: Vec3i) bool {
		// Transform to chunk-relative coordinates:
		const chunkPos = blockPos & ~@as(Vec3i, @splat(main.chunk.chunkMask));
		var block: blocks.Block = undefined;
		if (chunk.super.pos.wx == chunkPos[0] and chunk.super.pos.wy == chunkPos[1] and chunk.super.pos.wz == chunkPos[2]) {
			chunk.mutex.lock();
			defer chunk.mutex.unlock();
			block = chunk.getBlock(blockPos[0] - chunk.super.pos.wx, blockPos[1] - chunk.super.pos.wy, blockPos[2] - chunk.super.pos.wz);
		} else {
			const otherChunk = self.world.?.getSimulationChunkAndIncreaseRefCount(chunkPos[0], chunkPos[1], chunkPos[2]) orelse return true;
			defer otherChunk.decreaseRefCount();
			const ch = otherChunk.getChunk() orelse return true;
			ch.mutex.lock();
			defer ch.mutex.unlock();
			block = ch.getBlock(blockPos[0] - ch.super.pos.wx, blockPos[1] - ch.super.pos.wy, blockPos[2] - ch.super.pos.wz);
		}
		return main.game.collision.collideWithBlock(block, blockPos[0], blockPos[1], blockPos[2], pos.*, @splat(radius), @splat(0)) != null;
	}

	pub fn checkEntity(self: *ItemDropManager, user: *main.server.User) void {
		var ii: u32 = 0;
		while (ii < self.size) {
			const i = self.indices[ii];
			if (self.list.items(.pickupCooldown)[i] > 0) {
				ii += 1;
				continue;
			}
			const hitbox = main.game.Player.outerBoundingBox;
			const min = user.player.pos + hitbox.min;
			const max = user.player.pos + hitbox.max;
			const itemPos = self.list.items(.pos)[i];
			const dist = @max(min - itemPos, itemPos - max);
			if (@reduce(.Max, dist) < radius + pickupRange) {
				const itemStack = &self.list.items(.itemStack)[i];
				main.items.Inventory.ServerSide.tryCollectingToPlayerInventory(user, itemStack);
				if (itemStack.amount == 0) {
					self.directRemove(i);
					continue;
				}
			}
			ii += 1;
		}
	}
};

pub const ClientItemDropManager = struct { // MARK: ClientItemDropManager
	const maxf64Capacity = ItemDropManager.maxCapacity*@sizeOf(Vec3d)/@sizeOf(f64);

	super: ItemDropManager,

	lastTime: i16,

	timeDifference: utils.TimeDifference = .{},

	interpolation: utils.GenericInterpolation(maxf64Capacity) align(64) = undefined,

	var instance: ?*ClientItemDropManager = null;

	var mutex: std.Thread.Mutex = .{};

	pub fn init(self: *ClientItemDropManager, allocator: NeverFailingAllocator) void {
		std.debug.assert(instance == null); // Only one instance allowed.
		instance = self;
		self.* = .{
			.super = undefined,
			.lastTime = @as(i16, @truncate(main.timestamp().toMilliseconds())) -% settings.entityLookback,
		};
		self.super.init(allocator, null);
		self.interpolation.init(
			@ptrCast(self.super.list.items(.pos).ptr),
			@ptrCast(self.super.list.items(.vel).ptr),
		);
	}

	pub fn deinit(self: *ClientItemDropManager) void {
		std.debug.assert(instance != null); // Double deinit.
		self.super.deinit();
		instance = null;
	}

	pub fn readPosition(self: *ClientItemDropManager, time: i16, itemData: []ItemDropNetworkData) void {
		self.timeDifference.addDataPoint(time);
		var pos: [ItemDropManager.maxCapacity]Vec3d = undefined;
		var vel: [ItemDropManager.maxCapacity]Vec3d = undefined;
		for (itemData) |data| {
			pos[data.index] = data.pos;
			vel[data.index] = data.vel;
		}
		mutex.lock();
		defer mutex.unlock();
		self.interpolation.updatePosition(@ptrCast(&pos), @ptrCast(&vel), time); // TODO: Only update the ones we actually changed.
	}

	pub fn updateInterpolationData(self: *ClientItemDropManager) void {
		self.super.processChanges();
		var time = @as(i16, @truncate(main.timestamp().toMilliseconds())) -% settings.entityLookback;
		time -%= self.timeDifference.difference.load(.monotonic);
		{
			mutex.lock();
			defer mutex.unlock();
			self.interpolation.updateIndexed(time, self.lastTime, self.super.indices[0..self.super.size], 4);
		}
		self.lastTime = time;
	}

	fn clientSideInternalAdd(_: *ItemDropManager, i: u16, drop: ItemDrop) void {
		mutex.lock();
		defer mutex.unlock();
		for (&instance.?.interpolation.lastVel) |*lastVel| {
			@as(*align(8) [ItemDropManager.maxCapacity]Vec3d, @ptrCast(lastVel))[i] = Vec3d{0, 0, 0};
		}
		for (&instance.?.interpolation.lastPos) |*lastPos| {
			@as(*align(8) [ItemDropManager.maxCapacity]Vec3d, @ptrCast(lastPos))[i] = drop.pos;
		}
	}

	pub fn remove(self: *ClientItemDropManager, i: u16) void {
		self.super.emptyMutex.lock();
		self.super.isEmpty.set(i);
		self.super.emptyMutex.unlock();
		self.super.changeQueue.pushBack(.{.remove = i});
	}

	pub fn loadFrom(self: *ClientItemDropManager, zon: ZonElement) void {
		self.super.loadFrom(zon);
	}

	pub fn addFromZon(self: *ClientItemDropManager, zon: ZonElement) void {
		self.super.addFromZon(zon);
	}
};

// Going to handle item animations and other things like - bobbing, interpolation, movement reactions
pub const ItemDisplayManager = struct { // MARK: ItemDisplayManager
	pub var showItem: bool = true;
	var cameraFollow: Vec3f = @splat(0);
	var cameraFollowVel: Vec3f = @splat(0);
	const damping: Vec3f = @splat(130);

	pub fn update(deltaTime: f64) void {
		if (deltaTime == 0) return;
		const dt: f32 = @floatCast(deltaTime);

		var playerVel: Vec3f = .{@floatCast((game.Player.super.vel[2]*0.009 + game.Player.eye.vel[2]*0.0075)), 0, 0};
		playerVel = vec.clampMag(playerVel, 0.32);

		// TODO: add *smooth* item sway
		const n1: Vec3f = cameraFollowVel - (cameraFollow - playerVel)*damping*damping*@as(Vec3f, @splat(dt));
		const n2: Vec3f = @as(Vec3f, @splat(1)) + damping*@as(Vec3f, @splat(dt));
		cameraFollowVel = n1/(n2*n2);

		cameraFollow += cameraFollowVel*@as(Vec3f, @splat(dt));
	}
};

pub const ItemDropRenderer = struct { // MARK: ItemDropRenderer
	var itemPipeline: graphics.Pipeline = undefined;
	var itemUniforms: struct {
		projectionMatrix: c_int,
		modelMatrix: c_int,
		viewMatrix: c_int,
		ambientLight: c_int,
		modelIndex: c_int,
		block: c_int,
		reflectionMapSize: c_int,
		contrast: c_int,
		glDepthRange: c_int,
	} = undefined;

	var itemModelSSBO: graphics.SSBO = undefined;
	var modelData: main.List(u32) = undefined;
	var freeSlots: main.List(*ItemVoxelModel) = undefined;

	const ItemVoxelModel = struct {
		index: u31 = undefined,
		len: u31 = undefined,
		item: items.Item,

		fn getSlot(len: u31) u31 {
			for (freeSlots.items, 0..) |potentialSlot, i| {
				if (len == potentialSlot.len) {
					_ = freeSlots.swapRemove(i);
					const result = potentialSlot.index;
					main.globalAllocator.destroy(potentialSlot);
					return result;
				}
			}
			const result: u31 = @intCast(modelData.items.len);
			modelData.resize(result + len);
			return result;
		}

		fn init(template: ItemVoxelModel) *ItemVoxelModel {
			const self = main.globalAllocator.create(ItemVoxelModel);
			self.* = ItemVoxelModel{
				.item = template.item,
			};
			if (self.item == .baseItem and self.item.baseItem.block() != null and self.item.baseItem.image().imageData.ptr == graphics.Image.defaultImage.imageData.ptr) {
				// Find sizes and free index:
				var block = blocks.Block{.typ = self.item.baseItem.block().?, .data = 0};
				block.data = block.mode().naturalStandard;
				const model = blocks.meshes.model(block).model();
				var data = main.List(u32).init(main.stackAllocator);
				defer data.deinit();
				for (model.internalQuads) |quad| {
					const textureIndex = blocks.meshes.textureIndex(block, quad.quadInfo().textureSlot);
					data.append(@as(u32, @intFromEnum(quad)) << 16 | textureIndex); // modelAndTexture
					data.append(0); // offsetByNormal
				}
				for (model.neighborFacingQuads) |list| {
					for (list) |quad| {
						const textureIndex = blocks.meshes.textureIndex(block, quad.quadInfo().textureSlot);
						data.append(@as(u32, @intFromEnum(quad)) << 16 | textureIndex); // modelAndTexture
						data.append(1); // offsetByNormal
					}
				}
				self.len = @intCast(data.items.len);
				self.index = getSlot(self.len);
				@memcpy(modelData.items[self.index..][0..self.len], data.items);
			} else {
				// Find sizes and free index:
				const img = self.item.getImage();
				const size = Vec3i{img.width, 1, img.height};
				self.len = @intCast(3 + @reduce(.Mul, size));
				self.index = getSlot(self.len);
				var dataSection: []u32 = undefined;
				dataSection = modelData.items[self.index..][0..self.len];
				dataSection[0] = @intCast(size[0]);
				dataSection[1] = @intCast(size[1]);
				dataSection[2] = @intCast(size[2]);
				var i: u32 = 3;
				var z: u32 = 0;
				while (z < 1) : (z += 1) {
					var x: u32 = 0;
					while (x < img.width) : (x += 1) {
						var y: u32 = 0;
						while (y < img.height) : (y += 1) {
							dataSection[i] = img.getRGB(x, y).toARBG();
							i += 1;
						}
					}
				}
			}
			itemModelSSBO.bufferData(u32, modelData.items);
			return self;
		}

		fn deinit(self: *ItemVoxelModel) void {
			freeSlots.append(self);
		}

		pub fn equals(self: ItemVoxelModel, other: ?*ItemVoxelModel) bool {
			if (other == null) return false;
			return std.meta.eql(self.item, other.?.item);
		}

		pub fn hashCode(self: ItemVoxelModel) u32 {
			return self.item.hashCode();
		}
	};

	pub fn init() void {
		itemPipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/item_drop.vert",
			"assets/cubyz/shaders/item_drop.frag",
			"",
			&itemUniforms,
			.{},
			.{.depthTest = true},
			.{.attachments = &.{.alphaBlending}},
		);
		itemModelSSBO = .init();
		itemModelSSBO.bufferData(i32, &[3]i32{1, 1, 1});
		itemModelSSBO.bind(2);

		modelData = .init(main.globalAllocator);
		freeSlots = .init(main.globalAllocator);
	}

	pub fn deinit() void {
		itemPipeline.deinit();
		itemModelSSBO.deinit();
		modelData.deinit();
		voxelModels.clear();
		for (freeSlots.items) |freeSlot| {
			main.globalAllocator.destroy(freeSlot);
		}
		freeSlots.deinit();
	}

	var voxelModels: utils.Cache(ItemVoxelModel, 32, 32, ItemVoxelModel.deinit) = .{};

	fn getModel(item: items.Item) *ItemVoxelModel {
		const compareObject = ItemVoxelModel{.item = item};
		return voxelModels.findOrCreate(compareObject, ItemVoxelModel.init, null);
	}

	fn bindCommonUniforms(projMatrix: Mat4f, viewMatrix: Mat4f, ambientLight: Vec3f) void {
		itemPipeline.bind(null);
		c.glUniform1f(itemUniforms.reflectionMapSize, main.renderer.reflectionCubeMapSize);
		c.glUniformMatrix4fv(itemUniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projMatrix));
		c.glUniform3fv(itemUniforms.ambientLight, 1, @ptrCast(&ambientLight));
		c.glUniformMatrix4fv(itemUniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&viewMatrix));
		c.glUniform1f(itemUniforms.contrast, 0.12);
		var depthRange: [2]f32 = undefined;
		c.glGetFloatv(c.GL_DEPTH_RANGE, &depthRange);
		c.glUniform2fv(itemUniforms.glDepthRange, 1, &depthRange);
	}

	fn bindLightUniform(light: [6]u8, ambientLight: Vec3f) void {
		const sunLight: Vec3f = ambientLight*@as(Vec3f, @floatFromInt(Vec3i{light[0], light[1], light[2]}))/@as(Vec3f, @splat(255));
		const blockLight: Vec3f = @as(Vec3f, @floatFromInt(Vec3i{light[3], light[4], light[5]}))/@as(Vec3f, @splat(255));
		c.glUniform3fv(itemUniforms.ambientLight, 1, @ptrCast(&@min(@sqrt(sunLight*sunLight + blockLight*blockLight), @as(Vec3f, @splat(1)))));
	}

	fn bindModelUniforms(modelIndex: u31, blockType: u16) void {
		c.glUniform1i(itemUniforms.modelIndex, modelIndex);
		c.glUniform1i(itemUniforms.block, blockType);
	}

	fn drawItem(vertices: u31, modelMatrix: Mat4f) void {
		c.glUniformMatrix4fv(itemUniforms.modelMatrix, 1, c.GL_TRUE, @ptrCast(&modelMatrix));
		c.glBindVertexArray(main.renderer.chunk_meshing.vao);
		c.glDrawElements(c.GL_TRIANGLES, vertices, c.GL_UNSIGNED_INT, null);
	}

	pub fn renderItemDrops(projMatrix: Mat4f, ambientLight: Vec3f, playerPos: Vec3d) void {
		game.world.?.itemDrops.updateInterpolationData();

		bindCommonUniforms(projMatrix, game.camera.viewMatrix, ambientLight);
		const itemDrops = &game.world.?.itemDrops.super;
		for (itemDrops.indices[0..itemDrops.size]) |i| {
			const item = itemDrops.list.items(.itemStack)[i].item;
			if (item != .null) {
				var pos = itemDrops.list.items(.pos)[i];
				const rot = itemDrops.list.items(.rot)[i];
				const blockPos: Vec3i = @intFromFloat(@floor(pos));
				const light: [6]u8 = main.renderer.mesh_storage.getLight(blockPos[0], blockPos[1], blockPos[2]) orelse @splat(0);
				bindLightUniform(light, ambientLight);
				pos -= playerPos;

				const model = getModel(item);
				var vertices: u31 = 36;

				var scale: f32 = 0.3;
				var blockType: u16 = 0;
				if (item == .baseItem and item.baseItem.block() != null and item.baseItem.image().imageData.ptr == graphics.Image.defaultImage.imageData.ptr) {
					blockType = item.baseItem.block().?;
					vertices = model.len/2*6;
				} else {
					scale = 0.5;
				}
				bindModelUniforms(model.index, blockType);

				var modelMatrix = Mat4f.translation(@floatCast(pos));
				modelMatrix = modelMatrix.mul(Mat4f.rotationX(-rot[0]));
				modelMatrix = modelMatrix.mul(Mat4f.rotationY(-rot[1]));
				modelMatrix = modelMatrix.mul(Mat4f.rotationZ(-rot[2]));
				modelMatrix = modelMatrix.mul(Mat4f.scale(@splat(scale)));
				modelMatrix = modelMatrix.mul(Mat4f.translation(@splat(-0.5)));
				drawItem(vertices, modelMatrix);
			}
		}
	}

	inline fn getIndex(x: u8, y: u8, z: u8) u32 {
		return (z*4) + (y*2) + (x);
	}

	inline fn blendColors(a: [6]f32, b: [6]f32, t: f32) [6]f32 {
		var result: [6]f32 = .{0, 0, 0, 0, 0, 0};
		inline for (0..6) |i| {
			result[i] = std.math.lerp(a[i], b[i], t);
		}
		return result;
	}

	pub fn renderDisplayItems(ambientLight: Vec3f, playerPos: Vec3d) void {
		if (!ItemDisplayManager.showItem) return;

		const projMatrix: Mat4f = Mat4f.perspective(std.math.degreesToRadians(65), @as(f32, @floatFromInt(main.renderer.lastWidth))/@as(f32, @floatFromInt(main.renderer.lastHeight)), 0.01, 3);
		const viewMatrix = Mat4f.identity();
		bindCommonUniforms(projMatrix, viewMatrix, ambientLight);

		const item = game.Player.inventory.getItem(game.Player.selectedSlot);
		if (item != .null) {
			var pos: Vec3d = Vec3d{0, 0, 0};
			const rot: Vec3f = ItemDisplayManager.cameraFollow;

			const lightPos = @as(Vec3d, @floatCast(playerPos)) - @as(Vec3f, @splat(0.5));
			const blockPos: Vec3i = @intFromFloat(@floor(lightPos));
			const localBlockPos: Vec3f = @floatCast(lightPos - @as(Vec3d, @floatFromInt(blockPos)));

			var samples: [8][6]f32 = @splat(@splat(0));
			inline for (0..2) |z| {
				inline for (0..2) |y| {
					inline for (0..2) |x| {
						const light: [6]u8 = main.renderer.mesh_storage.getLight(
							blockPos[0] +% @as(i32, @intCast(x)),
							blockPos[1] +% @as(i32, @intCast(y)),
							blockPos[2] +% @as(i32, @intCast(z)),
						) orelse @splat(0);

						inline for (0..6) |i| {
							samples[getIndex(x, y, z)][i] = @as(f32, @floatFromInt(light[i]));
						}
					}
				}
			}

			inline for (0..2) |y| {
				inline for (0..2) |x| {
					samples[getIndex(x, y, 0)] = blendColors(samples[getIndex(x, y, 0)], samples[getIndex(x, y, 1)], localBlockPos[2]);
				}
			}

			inline for (0..2) |x| {
				samples[getIndex(x, 0, 0)] = blendColors(samples[getIndex(x, 0, 0)], samples[getIndex(x, 1, 0)], localBlockPos[1]);
			}

			var result: [6]u8 = .{0, 0, 0, 0, 0, 0};
			inline for (0..6) |i| {
				const val = std.math.lerp(samples[getIndex(0, 0, 0)][i], samples[getIndex(1, 0, 0)][i], localBlockPos[0]);
				result[i] = @as(u8, @intFromFloat(@floor(val)));
			}

			bindLightUniform(result, ambientLight);

			const model = getModel(item);
			var vertices: u31 = 36;

			const isBlock: bool = item == .baseItem and item.baseItem.block() != null and item.baseItem.image().imageData.ptr == graphics.Image.defaultImage.imageData.ptr;
			var scale: f32 = 0;
			var blockType: u16 = 0;
			if (isBlock) {
				blockType = item.baseItem.block().?;
				vertices = model.len/2*6;
				scale = 0.3;
				pos = Vec3d{0.4, 0.55, -0.32};
			} else {
				scale = 0.57;
				pos = Vec3d{0.4, 0.65, -0.3};
			}
			bindModelUniforms(model.index, blockType);

			var modelMatrix = Mat4f.rotationZ(-rot[2]);
			modelMatrix = modelMatrix.mul(Mat4f.rotationY(-rot[1]));
			modelMatrix = modelMatrix.mul(Mat4f.rotationX(-rot[0]));
			modelMatrix = modelMatrix.mul(Mat4f.translation(@floatCast(pos)));
			if (!isBlock) {
				if (item == .tool) {
					modelMatrix = modelMatrix.mul(Mat4f.rotationZ(-std.math.pi*0.47));
					modelMatrix = modelMatrix.mul(Mat4f.rotationY(std.math.pi*0.25));
				} else {
					modelMatrix = modelMatrix.mul(Mat4f.rotationZ(-std.math.pi*0.45));
				}
			} else {
				modelMatrix = modelMatrix.mul(Mat4f.rotationZ(-std.math.pi*0.2));
			}
			modelMatrix = modelMatrix.mul(Mat4f.scale(@splat(scale)));
			modelMatrix = modelMatrix.mul(Mat4f.translation(@splat(-0.5)));
			drawItem(vertices, modelMatrix);
		}
	}
};

```

`src/items.zig`:

```zig
const std = @import("std");

const blocks = @import("blocks.zig");
const Block = blocks.Block;
const graphics = @import("graphics.zig");
const Color = graphics.Color;
const Tag = main.Tag;
const ZonElement = @import("zon.zig").ZonElement;
const main = @import("main");
const ListUnmanaged = main.ListUnmanaged;
const BinaryReader = main.utils.BinaryReader;
const BinaryWriter = main.utils.BinaryWriter;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const chunk = main.chunk;
const random = @import("random.zig");
const vec = @import("vec.zig");
const Mat4f = vec.Mat4f;
const Vec2f = vec.Vec2f;
const Vec2i = vec.Vec2i;
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;

const modifierList = @import("tool/modifiers/_list.zig");
const modifierRestrictionList = @import("tool/modifiers/restrictions/_list.zig");

pub const recipes_zig = @import("items/recipes.zig");

pub const Inventory = @import("Inventory.zig");

const Material = struct { // MARK: Material
	massDamage: f32 = undefined,
	hardnessDamage: f32 = undefined,
	durability: f32 = undefined,
	swingSpeed: f32 = undefined,

	textureRoughness: f32 = undefined,
	colorPalette: []Color = undefined,
	modifiers: []Modifier = undefined,

	pub fn init(self: *Material, allocator: NeverFailingAllocator, zon: ZonElement) void {
		self.massDamage = zon.get(?f32, "massDamage", null) orelse blk: {
			std.log.err("Couldn't find material attribute 'massDamage'", .{});
			break :blk 0;
		};
		self.hardnessDamage = zon.get(?f32, "hardnessDamage", null) orelse blk: {
			std.log.err("Couldn't find material attribute 'hardnessDamage'", .{});
			break :blk 0;
		};
		self.durability = zon.get(?f32, "durability", null) orelse blk: {
			std.log.err("Couldn't find material attribute 'durability'", .{});
			break :blk 0;
		};
		self.swingSpeed = zon.get(?f32, "swingSpeed", null) orelse blk: {
			std.log.err("Couldn't find material attribute 'swingSpeed'", .{});
			break :blk 0;
		};
		self.textureRoughness = @max(0, zon.get(f32, "textureRoughness", 1.0));
		const colors = zon.getChild("colors");
		self.colorPalette = allocator.alloc(Color, colors.toSlice().len);
		for (colors.toSlice(), self.colorPalette) |item, *color| {
			const colorInt: u32 = @intCast(item.as(i64, 0xff000000) & 0xffffffff);
			color.* = Color{
				.r = @intCast(colorInt >> 16 & 0xff),
				.g = @intCast(colorInt >> 8 & 0xff),
				.b = @intCast(colorInt >> 0 & 0xff),
				.a = @intCast(colorInt >> 24 & 0xff),
			};
		}
		const modifiersZon = zon.getChild("modifiers");
		self.modifiers = allocator.alloc(Modifier, modifiersZon.toSlice().len);
		for (modifiersZon.toSlice(), self.modifiers) |item, *modifier| {
			const id = item.get([]const u8, "id", "not specified");
			const vTable = modifiers.get(id) orelse blk: {
				std.log.err("Couldn't find modifier with id '{s}'. Replacing it with 'durable'", .{id});
				break :blk modifiers.get("durable") orelse unreachable;
			};
			modifier.* = .{
				.vTable = vTable,
				.data = vTable.loadData(item),
				.restriction = ModifierRestriction.loadFromZon(allocator, item.getChild("restriction")),
			};
		}
	}

	pub fn hashCode(self: Material) u32 {
		var hash: u32 = 0;
		hash = 101*%hash +% @as(u32, @bitCast(self.massDamage));
		hash = 101*%hash +% @as(u32, @bitCast(self.hardnessDamage));
		hash = 101*%hash +% @as(u32, @bitCast(self.durability));
		hash = 101*%hash +% @as(u32, @bitCast(self.swingSpeed));
		hash = 101*%hash +% @as(u32, @bitCast(self.textureRoughness));
		hash ^= hash >> 24;
		return hash;
	}

	fn getProperty(self: Material, prop: MaterialProperty) f32 {
		switch (prop) {
			inline else => |field| return @field(self, @tagName(field)),
		}
	}

	pub fn printTooltip(self: Material, outString: *main.List(u8)) void {
		if (self.modifiers.len == 0) {
			outString.appendSlice("§#808080Material\n");
		}
		for (self.modifiers) |modifier| {
			if (modifier.restriction.vTable == modifierRestrictions.get("always") orelse unreachable) {
				modifier.printTooltip(outString);
				outString.appendSlice("\n");
			} else {
				outString.appendSlice("§#808080if ");
				modifier.restriction.printTooltip(outString);
				outString.appendSlice("\n  ");
				modifier.printTooltip(outString);
				outString.appendSlice("\n");
			}
		}
	}
};

pub const ModifierRestriction = struct {
	vTable: *const VTable,
	data: *anyopaque,

	pub const VTable = struct {
		satisfied: *const fn (data: *anyopaque, tool: *const Tool, x: i32, y: i32) bool,
		loadFromZon: *const fn (allocator: NeverFailingAllocator, zon: ZonElement) *anyopaque,
		printTooltip: *const fn (data: *anyopaque, outString: *main.List(u8)) void,
	};

	pub fn satisfied(self: ModifierRestriction, tool: *const Tool, x: i32, y: i32) bool {
		return self.vTable.satisfied(self.data, tool, x, y);
	}

	pub fn loadFromZon(allocator: NeverFailingAllocator, zon: ZonElement) ModifierRestriction {
		const id = zon.get([]const u8, "id", "always");
		const vTable = modifierRestrictions.get(id) orelse blk: {
			std.log.err("Couldn't find modifier restriction with id '{s}'. Replacing it with 'always'", .{id});
			break :blk modifierRestrictions.get("always") orelse unreachable;
		};
		return .{
			.vTable = vTable,
			.data = vTable.loadFromZon(allocator, zon),
		};
	}

	pub fn printTooltip(self: ModifierRestriction, outString: *main.List(u8)) void {
		self.vTable.printTooltip(self.data, outString);
	}
};

const Modifier = struct {
	data: VTable.Data,
	restriction: ModifierRestriction,
	vTable: *const VTable,

	pub const VTable = struct {
		const Data = packed struct(u128) { pad: u128 };
		combineModifiers: *const fn (data1: Data, data2: Data) ?Data,
		changeToolParameters: *const fn (tool: *Tool, data: Data) void,
		changeBlockDamage: *const fn (damage: f32, block: main.blocks.Block, data: Data) f32,
		printTooltip: *const fn (outString: *main.List(u8), data: Data) void,
		loadData: *const fn (zon: ZonElement) Data,
		priority: f32,
	};

	pub fn combineModifiers(a: Modifier, b: Modifier) ?Modifier {
		std.debug.assert(a.vTable == b.vTable);
		return .{
			.data = a.vTable.combineModifiers(a.data, b.data) orelse return null,
			.vTable = a.vTable,
			.restriction = undefined,
		};
	}

	pub fn changeToolParameters(self: Modifier, tool: *Tool) void {
		self.vTable.changeToolParameters(tool, self.data);
	}

	pub fn changeBlockDamage(self: Modifier, damage: f32, block: main.blocks.Block) f32 {
		return self.vTable.changeBlockDamage(damage, block, self.data);
	}

	pub fn printTooltip(self: Modifier, outString: *main.List(u8)) void {
		self.vTable.printTooltip(outString, self.data);
	}
};

const MaterialProperty = enum {
	massDamage,
	hardnessDamage,
	durability,
	swingSpeed,

	fn fromString(string: []const u8) ?MaterialProperty {
		return std.meta.stringToEnum(MaterialProperty, string) orelse {
			std.log.err("Couldn't find material property {s}.", .{string});
			return null;
		};
	}
};

pub const BaseItemIndex = enum(u16) { // MARK: BaseItemIndex
	_,

	pub fn fromId(_id: []const u8) ?BaseItemIndex {
		return reverseIndices.get(_id);
	}
	pub fn image(self: BaseItemIndex) graphics.Image {
		return itemList[@intFromEnum(self)].image;
	}
	pub fn texture(self: BaseItemIndex) ?graphics.Texture {
		return itemList[@intFromEnum(self)].texture;
	}
	pub fn id(self: BaseItemIndex) []const u8 {
		return itemList[@intFromEnum(self)].id;
	}
	pub fn name(self: BaseItemIndex) []const u8 {
		return itemList[@intFromEnum(self)].name;
	}
	pub fn tags(self: BaseItemIndex) []const Tag {
		return itemList[@intFromEnum(self)].tags;
	}
	pub fn stackSize(self: BaseItemIndex) u16 {
		return itemList[@intFromEnum(self)].stackSize;
	}
	pub fn material(self: BaseItemIndex) ?Material {
		return itemList[@intFromEnum(self)].material;
	}
	pub fn block(self: BaseItemIndex) ?u16 {
		return itemList[@intFromEnum(self)].block;
	}
	pub fn hasTag(self: BaseItemIndex, tag: Tag) bool {
		return itemList[@intFromEnum(self)].hasTag(tag);
	}
	pub fn hashCode(self: BaseItemIndex) u32 {
		return itemList[@intFromEnum(self)].hashCode();
	}
	pub fn getTexture(self: BaseItemIndex) graphics.Texture {
		return itemList[@intFromEnum(self)].getTexture();
	}
	pub fn getTooltip(self: BaseItemIndex) []const u8 {
		return itemList[@intFromEnum(self)].getTooltip();
	}
};

pub const BaseItem = struct { // MARK: BaseItem
	image: graphics.Image,
	texture: ?graphics.Texture, // TODO: Properly deinit
	id: []const u8,
	name: []const u8,
	tags: []const Tag,
	tooltip: []const u8,

	stackSize: u16,
	material: ?Material,
	block: ?u16,
	foodValue: f32, // TODO: Effects.

	fn init(self: *BaseItem, allocator: NeverFailingAllocator, texturePath: []const u8, replacementTexturePath: []const u8, id: []const u8, zon: ZonElement) void {
		self.id = allocator.dupe(u8, id);
		if (texturePath.len == 0) {
			self.image = graphics.Image.defaultImage;
		} else {
			self.image = graphics.Image.readFromFile(allocator, texturePath) catch graphics.Image.readFromFile(allocator, replacementTexturePath) catch blk: {
				std.log.err("Item texture not found in {s} and {s}.", .{texturePath, replacementTexturePath});
				break :blk graphics.Image.defaultImage;
			};
		}
		self.name = allocator.dupe(u8, zon.get([]const u8, "name", id));
		self.tags = Tag.loadTagsFromZon(allocator, zon.getChild("tags"));
		self.stackSize = zon.get(u16, "stackSize", 120);
		const material = zon.getChild("material");
		if (material == .object) {
			self.material = Material{};
			self.material.?.init(allocator, material);
		} else {
			self.material = null;
		}
		self.block = blk: {
			break :blk blocks.getTypeById(zon.get(?[]const u8, "block", null) orelse break :blk null);
		};
		self.texture = null;
		self.foodValue = zon.get(f32, "food", 0);

		var tooltip: main.List(u8) = .init(allocator);
		tooltip.appendSlice(self.name);
		tooltip.append('\n');
		if (self.material) |mat| {
			mat.printTooltip(&tooltip);
		}
		if (self.tags.len != 0) {
			tooltip.appendSlice("§#808080");
			for (self.tags, 0..) |tag, i| {
				if (i != 0) tooltip.append(' ');
				tooltip.append('.');
				tooltip.appendSlice(tag.getName());
			}
		}
		if (tooltip.items[tooltip.items.len - 1] == '\n') {
			_ = tooltip.swapRemove(tooltip.items.len - 1);
		}
		self.tooltip = tooltip.toOwnedSlice();
	}

	fn hashCode(self: BaseItem) u32 {
		var hash: u32 = 0;
		for (self.id) |char| {
			hash = hash*%33 +% char;
		}
		return hash;
	}

	pub fn getTexture(self: *BaseItem) graphics.Texture {
		if (self.texture == null) {
			if (self.image.imageData.ptr == graphics.Image.defaultImage.imageData.ptr) {
				if (self.block) |blockType| {
					self.texture = graphics.generateBlockTexture(blockType);
				} else {
					self.texture = graphics.Texture.init();
					self.texture.?.generate(self.image);
				}
			} else {
				self.texture = graphics.Texture.init();
				self.texture.?.generate(self.image);
			}
		}
		return self.texture.?;
	}

	fn getTooltip(self: BaseItem) []const u8 {
		return self.tooltip;
	}

	pub fn hasTag(self: *const BaseItem, tag: Tag) bool {
		for (self.tags) |other| {
			if (other == tag) return true;
		}
		return false;
	}
};

/// Generates the texture of a Tool using the material information.
const TextureGenerator = struct { // MARK: TextureGenerator
	fn generateHeightMap(itemGrid: *[16][16]?BaseItemIndex, seed: *u64) [17][17]f32 {
		var heightMap: [17][17]f32 = undefined;
		var x: u8 = 0;
		while (x < 17) : (x += 1) {
			var y: u8 = 0;
			while (y < 17) : (y += 1) {
				heightMap[x][y] = 0;
				// The heighmap basically consists of the amount of neighbors this pixel has.
				// Also check if there are different neighbors.
				const oneItem = itemGrid[if (x == 0) x else x - 1][if (y == 0) y else y - 1];
				var hasDifferentItems: bool = false;
				var dx: i32 = -1;
				while (dx <= 0) : (dx += 1) {
					if (x + dx < 0 or x + dx >= 16) continue;
					var dy: i32 = -1;
					while (dy <= 0) : (dy += 1) {
						if (y + dy < 0 or y + dy >= 16) continue;
						const otherItem = itemGrid[@intCast(x + dx)][@intCast(y + dy)];
						heightMap[x][y] = if (otherItem) |item| (if (item.material()) |material| 1 + (4*random.nextFloat(seed) - 2)*material.textureRoughness else 0) else 0;
						if (otherItem != oneItem) {
							hasDifferentItems = true;
						}
					}
				}

				// If there is multiple items at this junction, make it go inward to make embedded parts stick out more:
				if (hasDifferentItems) {
					heightMap[x][y] -= 1;
				}

				// Take into account further neighbors with lower priority:
				dx = -2;
				while (dx <= 1) : (dx += 1) {
					if (x + dx < 0 or x + dx >= 16) continue;
					var dy: i32 = -2;
					while (dy <= 1) : (dy += 1) {
						if (y + dy < 0 or y + dy >= 16) continue;
						const otherItem = itemGrid[@intCast(x + dx)][@intCast(y + dy)];
						const dVec = Vec2f{@as(f32, @floatFromInt(dx)) + 0.5, @as(f32, @floatFromInt(dy)) + 0.5};
						heightMap[x][y] += if (otherItem != null) 1.0/vec.dot(dVec, dVec) else 0;
					}
				}
			}
		}
		return heightMap;
	}

	pub fn generate(tool: *Tool) void {
		const img = tool.image;
		for (0..16) |x| {
			for (0..16) |y| {
				const source = tool.type.pixelSources()[x][y];
				const sourceOverlay = tool.type.pixelSourcesOverlay()[x][y];
				if (sourceOverlay < 25 and tool.craftingGrid[sourceOverlay] != null) {
					tool.materialGrid[x][y] = tool.craftingGrid[sourceOverlay];
				} else if (source < 25) {
					tool.materialGrid[x][y] = tool.craftingGrid[source];
				} else {
					tool.materialGrid[x][y] = null;
				}
			}
		}

		var seed: u64 = tool.seed;
		random.scrambleSeed(&seed);

		// Generate a height map, which will be used for lighting calulations.
		const heightMap = generateHeightMap(&tool.materialGrid, &seed);
		var x: u8 = 0;
		while (x < 16) : (x += 1) {
			var y: u8 = 0;
			while (y < 16) : (y += 1) {
				if (tool.materialGrid[x][y]) |item| {
					if (item.material()) |material| {
						// Calculate the lighting based on the nearest free space:
						const lightTL = heightMap[x][y] - heightMap[x + 1][y + 1];
						const lightTR = heightMap[x + 1][y] - heightMap[x][y + 1];
						var light = 2 - @as(i32, @intFromFloat(@round((lightTL*2 + lightTR)/6)));
						light = @max(@min(light, 4), 0);
						img.setRGB(x, 15 - y, material.colorPalette[@intCast(light)]);
					} else {
						img.setRGB(x, 15 - y, if ((x ^ y) & 1 == 0) Color{.r = 255, .g = 0, .b = 255, .a = 255} else Color{.r = 0, .g = 0, .b = 0, .a = 255});
					}
				} else {
					img.setRGB(x, 15 - y, Color{.r = 0, .g = 0, .b = 0, .a = 0});
				}
			}
		}
	}
};

/// Determines the physical properties of a tool to calculate in-game parameters such as durability and speed.
const ToolPhysics = struct { // MARK: ToolPhysics
	/// Determines all the basic properties of the tool.
	pub fn evaluateTool(tool: *Tool) void {
		inline for (comptime std.meta.fieldNames(ToolProperty)) |name| {
			@field(tool, name) = 0;
		}
		var tempModifiers: main.List(Modifier) = .init(main.stackAllocator);
		defer tempModifiers.deinit();
		for (tool.type.properties()) |property| {
			var sum: f32 = 0;
			var weight: f32 = 0;
			for (0..25) |i| {
				const material = (tool.craftingGrid[i] orelse continue).material() orelse continue;
				sum += property.weights[i]*material.getProperty(property.source orelse break);
				weight += property.weights[i];
			}
			if (weight == 0) continue;
			switch (property.method) {
				.sum => {},
				.average => {
					sum /= weight;
				},
			}
			sum *= property.resultScale;
			tool.getProperty(property.destination orelse continue).* += sum;
		}
		if (tool.damage < 1) tool.damage = 1/(2 - tool.damage);
		if (tool.swingSpeed < 1) tool.swingSpeed = 1/(2 - tool.swingSpeed);
		for (0..25) |i| {
			const material = (tool.craftingGrid[i] orelse continue).material() orelse continue;
			outer: for (material.modifiers) |newMod| {
				if (!newMod.restriction.satisfied(tool, @intCast(i%5), @intCast(i/5))) continue;
				for (tempModifiers.items) |*oldMod| {
					if (oldMod.vTable == newMod.vTable) {
						oldMod.* = oldMod.combineModifiers(newMod) orelse continue;
						continue :outer;
					}
				}
				tempModifiers.append(newMod);
			}
		}
		std.sort.insertion(Modifier, tempModifiers.items, {}, struct {
			fn lessThan(_: void, lhs: Modifier, rhs: Modifier) bool {
				return lhs.vTable.priority < rhs.vTable.priority;
			}
		}.lessThan);
		tool.modifiers = main.globalAllocator.dupe(Modifier, tempModifiers.items);
		for (tempModifiers.items) |mod| {
			mod.changeToolParameters(tool);
		}

		tool.maxDurability = @round(tool.maxDurability);
		if (tool.maxDurability < 1) tool.maxDurability = 1;
		tool.durability = std.math.lossyCast(u32, tool.maxDurability);

		if (!checkConnectivity(tool)) {
			tool.maxDurability = 0;
			tool.durability = 1;
		}
	}

	fn checkConnectivity(tool: *Tool) bool {
		var gridCellsReached: [16][16]bool = @splat(@splat(false));
		var floodfillQueue = main.utils.CircularBufferQueue(Vec2i).init(main.stackAllocator, 16);
		defer floodfillQueue.deinit();
		outer: for (tool.materialGrid, 0..) |row, x| {
			for (row, 0..) |entry, y| {
				if (entry != null) {
					floodfillQueue.pushBack(.{@intCast(x), @intCast(y)});
					gridCellsReached[x][y] = true;
					break :outer;
				}
			}
		}
		while (floodfillQueue.popFront()) |pos| {
			for ([4]Vec2i{.{-1, 0}, .{1, 0}, .{0, -1}, .{0, 1}}) |delta| {
				const newPos = pos + delta;
				if (newPos[0] < 0 or newPos[0] >= gridCellsReached.len) continue;
				if (newPos[1] < 0 or newPos[1] >= gridCellsReached.len) continue;
				const x: usize = @intCast(newPos[0]);
				const y: usize = @intCast(newPos[1]);
				if (gridCellsReached[x][y]) continue;
				if (tool.materialGrid[x][y] == null) continue;
				gridCellsReached[x][y] = true;
				floodfillQueue.pushBack(newPos);
			}
		}
		for (tool.materialGrid, 0..) |row, x| {
			for (row, 0..) |entry, y| {
				if (entry != null and !gridCellsReached[x][y]) {
					return false;
				}
			}
		}
		return true;
	}
};

const SlotInfo = packed struct { // MARK: SlotInfo
	disabled: bool = false,
	optional: bool = false,
};

const PropertyMatrix = struct { // MARK: PropertyMatrix
	source: ?MaterialProperty,
	destination: ?ToolProperty,
	weights: [25]f32,
	resultScale: f32,
	method: Method,

	const Method = enum {
		average,
		sum,

		fn fromString(string: []const u8) ?Method {
			return std.meta.stringToEnum(Method, string) orelse {
				std.log.err("Couldn't find property matrix method {s}.", .{string});
				return null;
			};
		}
	};
};

pub const ToolTypeIndex = enum(u16) {
	_,

	const ToolTypeIterator = struct {
		i: u16 = 0,

		pub fn next(self: *ToolTypeIterator) ?ToolTypeIndex {
			if (self.i >= toolTypeList.items.len) return null;
			defer self.i += 1;
			return @enumFromInt(self.i);
		}
	};

	pub fn iterator() ToolTypeIterator {
		return .{};
	}
	pub fn fromId(_id: []const u8) ?ToolTypeIndex {
		return toolTypeIdToIndex.get(_id);
	}
	pub fn id(self: ToolTypeIndex) []const u8 {
		return toolTypeList.items[@intFromEnum(self)].id;
	}
	pub fn blockTags(self: ToolTypeIndex) []const Tag {
		return toolTypeList.items[@intFromEnum(self)].blockTags;
	}
	pub fn properties(self: ToolTypeIndex) []const PropertyMatrix {
		return toolTypeList.items[@intFromEnum(self)].properties;
	}
	pub fn slotInfos(self: ToolTypeIndex) *const [25]SlotInfo {
		return &toolTypeList.items[@intFromEnum(self)].slotInfos;
	}
	pub fn pixelSources(self: ToolTypeIndex) *const [16][16]u8 {
		return &toolTypeList.items[@intFromEnum(self)].pixelSources;
	}
	pub fn pixelSourcesOverlay(self: ToolTypeIndex) *const [16][16]u8 {
		return &toolTypeList.items[@intFromEnum(self)].pixelSourcesOverlay;
	}
};

pub const ToolType = struct { // MARK: ToolType
	id: []const u8,
	blockTags: []main.Tag,
	properties: []PropertyMatrix,
	slotInfos: [25]SlotInfo,
	pixelSources: [16][16]u8,
	pixelSourcesOverlay: [16][16]u8,
};

const ToolProperty = enum {
	damage,
	maxDurability,
	swingSpeed,

	fn fromString(string: []const u8) ?ToolProperty {
		return std.meta.stringToEnum(ToolProperty, string) orelse {
			std.log.err("Couldn't find tool property {s}.", .{string});
			return null;
		};
	}
};

pub const Tool = struct { // MARK: Tool
	const craftingGridSize = 25;
	const CraftingGridMask = std.meta.Int(.unsigned, craftingGridSize);

	craftingGrid: [craftingGridSize]?BaseItemIndex,
	materialGrid: [16][16]?BaseItemIndex,
	modifiers: []Modifier,
	tooltip: main.List(u8),
	image: graphics.Image,
	texture: ?graphics.Texture,
	seed: u32,
	type: ToolTypeIndex,

	damage: f32,

	durability: u32,
	maxDurability: f32,

	/// swings per second
	swingSpeed: f32,

	mass: f32,

	///  Where the player holds the tool.
	handlePosition: Vec2f,
	/// Moment of inertia relative to the handle.
	inertiaHandle: f32,

	/// Where the tool rotates around when being thrown.
	centerOfMass: Vec2f,
	/// Moment of inertia relative to the center of mass.
	inertiaCenterOfMass: f32,

	pub fn init() *Tool {
		const self = main.globalAllocator.create(Tool);
		self.image = graphics.Image.init(main.globalAllocator, 16, 16);
		self.texture = null;
		self.tooltip = .init(main.globalAllocator);
		return self;
	}

	pub fn deinit(self: *const Tool) void {
		// TODO: This is leaking textures!
		// if(self.texture) |texture| {
		// texture.deinit();
		// }
		self.image.deinit(main.globalAllocator);
		self.tooltip.deinit();
		main.globalAllocator.free(self.modifiers);
		main.globalAllocator.destroy(self);
	}

	pub fn clone(self: *const Tool) *Tool {
		const result = main.globalAllocator.create(Tool);
		result.* = .{
			.craftingGrid = self.craftingGrid,
			.materialGrid = self.materialGrid,
			.modifiers = main.globalAllocator.dupe(Modifier, self.modifiers),
			.tooltip = .init(main.globalAllocator),
			.image = graphics.Image.init(main.globalAllocator, self.image.width, self.image.height),
			.texture = null,
			.seed = self.seed,
			.type = self.type,
			.damage = self.damage,
			.durability = self.durability,
			.maxDurability = self.maxDurability,
			.swingSpeed = self.swingSpeed,
			.mass = self.mass,
			.handlePosition = self.handlePosition,
			.inertiaHandle = self.inertiaHandle,
			.centerOfMass = self.centerOfMass,
			.inertiaCenterOfMass = self.inertiaCenterOfMass,
		};
		@memcpy(result.image.imageData, self.image.imageData);
		return result;
	}

	pub fn initFromCraftingGrid(craftingGrid: [25]?BaseItemIndex, seed: u32, typ: ToolTypeIndex) *Tool {
		const self = init();
		self.seed = seed;
		self.craftingGrid = craftingGrid;
		self.type = typ;
		// Produce the tool and its textures:
		// The material grid, which comes from texture generation, is needed on both server and client, to generate the tool properties.
		TextureGenerator.generate(self);
		ToolPhysics.evaluateTool(self);
		return self;
	}

	pub fn initFromZon(zon: ZonElement) *Tool {
		const self = initFromCraftingGrid(extractItemsFromZon(zon.getChild("grid")), zon.get(u32, "seed", 0), ToolTypeIndex.fromId(zon.get([]const u8, "type", "cubyz:pickaxe")) orelse blk: {
			std.log.err("Couldn't find tool with type {s}. Replacing it with cubyz:pickaxe", .{zon.get([]const u8, "type", "cubyz:pickaxe")});
			break :blk ToolTypeIndex.fromId("cubyz:pickaxe") orelse @panic("cubyz:pickaxe tool not found. Did you load the game with the correct assets?");
		});
		self.durability = zon.get(u32, "durability", std.math.lossyCast(u32, self.maxDurability));
		return self;
	}

	fn extractItemsFromZon(zonArray: ZonElement) [craftingGridSize]?BaseItemIndex {
		var items: [craftingGridSize]?BaseItemIndex = undefined;
		for (&items, 0..) |*item, i| {
			item.* = .fromId(zonArray.getAtIndex([]const u8, i, "null"));
			if (item.* != null and item.*.?.material() == null) item.* = null;
		}
		return items;
	}

	pub fn save(self: *const Tool, allocator: NeverFailingAllocator) ZonElement {
		const zonObject = ZonElement.initObject(allocator);
		const zonArray = ZonElement.initArray(allocator);
		for (self.craftingGrid) |nullableItem| {
			if (nullableItem) |item| {
				zonArray.array.append(.{.string = item.id()});
			} else {
				zonArray.array.append(.null);
			}
		}
		zonObject.put("grid", zonArray);
		zonObject.put("durability", self.durability);
		zonObject.put("seed", self.seed);
		zonObject.put("type", self.type.id());
		return zonObject;
	}

	pub fn fromBytes(reader: *BinaryReader) !*Tool {
		const durability = try reader.readInt(u32);
		const seed = try reader.readInt(u32);
		const typ = try reader.readEnum(ToolTypeIndex);

		var craftingGridMask = try reader.readInt(CraftingGridMask);
		var craftingGrid: [craftingGridSize]?BaseItemIndex = @splat(null);

		while (craftingGridMask != 0) {
			const i = @ctz(craftingGridMask);
			craftingGridMask &= ~(@as(CraftingGridMask, 1) << @intCast(i));
			craftingGrid[i] = try reader.readEnum(BaseItemIndex);
		}
		const self = initFromCraftingGrid(craftingGrid, seed, typ);

		self.durability = durability;
		return self;
	}

	pub fn toBytes(self: Tool, writer: *BinaryWriter) void {
		writer.writeInt(u32, self.durability);
		writer.writeInt(u32, self.seed);
		writer.writeEnum(ToolTypeIndex, self.type);

		var craftingGridMask: CraftingGridMask = 0;
		for (0..craftingGridSize) |i| {
			if (self.craftingGrid[i] != null) {
				craftingGridMask |= @as(CraftingGridMask, 1) << @intCast(i);
			}
		}
		writer.writeInt(CraftingGridMask, craftingGridMask);

		for (0..craftingGridSize) |i| {
			if (self.craftingGrid[i]) |baseItem| {
				writer.writeEnum(BaseItemIndex, baseItem);
			}
		}
	}

	pub fn hashCode(self: Tool) u32 {
		var hash: u32 = 0;
		for (self.craftingGrid) |nullItem| {
			if (nullItem) |item| {
				hash = 33*%hash +% item.material().?.hashCode();
			}
		}
		return hash;
	}

	pub fn getItemAt(self: *const Tool, x: i32, y: i32) ?BaseItemIndex {
		if (x < 0 or x >= 5) return null;
		if (y < 0 or y >= 5) return null;
		return self.craftingGrid[@intCast(x + y*5)];
	}

	fn getProperty(self: *Tool, prop: ToolProperty) *f32 {
		switch (prop) {
			inline else => |field| return &@field(self, @tagName(field)),
		}
	}

	fn getTexture(self: *Tool) graphics.Texture {
		if (self.texture == null) {
			self.texture = graphics.Texture.init();
			self.texture.?.generate(self.image);
		}
		return self.texture.?;
	}

	fn getTooltip(self: *Tool) []const u8 {
		self.tooltip.clearRetainingCapacity();
		self.tooltip.print(
			\\{s}
			\\{d:.2} swings/s
			\\Damage: {d:.2}
			\\Durability: {}/{}
		, .{
			self.type.id(),
			self.swingSpeed,
			self.damage,
			self.durability,
			std.math.lossyCast(u32, self.maxDurability),
		});
		if (self.modifiers.len != 0) {
			self.tooltip.appendSlice("\nModifiers:\n");
			for (self.modifiers) |modifier| {
				modifier.printTooltip(&self.tooltip);
				self.tooltip.appendSlice("§\n");
			}
			_ = self.tooltip.pop();
		}
		return self.tooltip.items;
	}

	pub fn isEffectiveOn(self: *Tool, block: main.blocks.Block) bool {
		for (block.blockTags()) |blockTag| {
			for (self.type.blockTags()) |toolTag| {
				if (toolTag == blockTag) return true;
			}
		}
		return false;
	}

	pub fn getBlockDamage(self: *Tool, block: main.blocks.Block) f32 {
		var damage = self.damage;
		for (self.modifiers) |modifier| {
			damage = modifier.changeBlockDamage(damage, block);
		}
		if (self.isEffectiveOn(block)) {
			return damage;
		}
		return main.game.Player.defaultBlockDamage;
	}

	pub fn onUseReturnBroken(self: *Tool) bool {
		self.durability -|= 1;
		return self.durability == 0;
	}
};

const ItemType = enum(u7) {
	baseItem,
	tool,
	null,
};

pub const Item = union(ItemType) { // MARK: Item
	baseItem: BaseItemIndex,
	tool: *Tool,
	null: void,

	pub fn init(zon: ZonElement) !Item {
		if (BaseItemIndex.fromId(zon.get([]const u8, "item", "null"))) |baseItem| {
			return Item{.baseItem = baseItem};
		} else {
			const toolZon = zon.getChild("tool");
			if (toolZon != .object) return error.ItemNotFound;
			return Item{.tool = Tool.initFromZon(toolZon)};
		}
	}

	pub fn deinit(self: Item) void {
		switch (self) {
			.baseItem, .null => {},
			.tool => |_tool| {
				_tool.deinit();
			},
		}
	}

	pub fn clone(self: Item) Item {
		switch (self) {
			.baseItem, .null => return self,
			.tool => |tool| {
				return .{.tool = tool.clone()};
			},
		}
	}

	pub fn stackSize(self: Item) u16 {
		switch (self) {
			.baseItem => |_baseItem| {
				return _baseItem.stackSize();
			},
			.tool => {
				return 1;
			},
			.null => {
				return 0;
			},
		}
	}

	pub fn insertIntoZon(self: Item, allocator: NeverFailingAllocator, zonObject: ZonElement) void {
		switch (self) {
			.baseItem => |_baseItem| {
				zonObject.put("item", _baseItem.id());
			},
			.tool => |_tool| {
				zonObject.put("tool", _tool.save(allocator));
			},
			.null => unreachable,
		}
	}

	pub fn fromBytes(reader: *BinaryReader) !Item {
		const typ = try reader.readEnum(ItemType);
		switch (typ) {
			.baseItem => {
				return .{.baseItem = try reader.readEnum(BaseItemIndex)};
			},
			.tool => {
				return .{.tool = try Tool.fromBytes(reader)};
			},
			.null => return error.UnexpectedItemType, // null should be handled at the call-site
		}
	}

	pub fn toBytes(self: Item, writer: *BinaryWriter) void {
		writer.writeEnum(ItemType, self);
		switch (self) {
			.baseItem => writer.writeEnum(BaseItemIndex, self.baseItem),
			.tool => |tool| tool.toBytes(writer),
			.null => unreachable,
		}
	}

	pub fn getTexture(self: Item) graphics.Texture {
		return switch (self) {
			.baseItem => |_baseItem| _baseItem.getTexture(),
			.tool => |_tool| _tool.getTexture(),
			.null => unreachable,
		};
	}

	pub fn id(self: Item) ?[]const u8 {
		switch (self) {
			.tool => |tool| {
				return tool.type.id();
			},
			.baseItem => |item| {
				return item.id();
			},
			.null => return null,
		}
	}

	pub fn getTooltip(self: Item) ?[]const u8 {
		switch (self) {
			.baseItem => |_baseItem| {
				return _baseItem.getTooltip();
			},
			.tool => |_tool| {
				return _tool.getTooltip();
			},
			.null => return null,
		}
	}

	pub fn getImage(self: Item) graphics.Image {
		switch (self) {
			.baseItem => |_baseItem| {
				return _baseItem.image();
			},
			.tool => |_tool| {
				return _tool.image;
			},
			.null => unreachable,
		}
	}

	pub fn hashCode(self: Item) u32 {
		return switch (self) {
			.null => unreachable,
			inline else => |item| item.hashCode(),
		};
	}
};

pub const ItemStack = struct { // MARK: ItemStack
	item: Item = .null,
	amount: u16 = 0,

	pub fn load(zon: ZonElement) !ItemStack {
		return .{
			.item = try Item.init(zon),
			.amount = zon.get(?u16, "amount", null) orelse return error.InvalidAmount,
		};
	}

	pub fn deinit(self: *ItemStack) void {
		self.item.deinit();
	}

	pub fn clone(self: *const ItemStack) ItemStack {
		return .{
			.item = self.item.clone(),
			.amount = self.amount,
		};
	}

	pub fn empty(self: *const ItemStack) bool {
		return self.amount == 0;
	}

	pub fn storeToZon(self: *const ItemStack, allocator: NeverFailingAllocator, zonObject: ZonElement) void {
		if (self.item != .null) {
			self.item.insertIntoZon(allocator, zonObject);
			zonObject.put("amount", self.amount);
		}
	}

	pub fn fromBytes(reader: *BinaryReader) !ItemStack {
		const amount = try reader.readVarInt(u16);
		if (amount == 0) {
			return .{};
		}
		const item = try Item.fromBytes(reader);
		return .{
			.item = item,
			.amount = amount,
		};
	}

	pub fn toBytes(self: *const ItemStack, writer: *BinaryWriter) void {
		if (self.item != .null) {
			writer.writeVarInt(u16, self.amount);
			self.item.toBytes(writer);
		} else {
			writer.writeVarInt(u16, 0);
		}
	}
};

pub const Recipe = struct { // MARK: Recipe
	sourceItems: []BaseItemIndex,
	sourceAmounts: []u16,
	resultItem: BaseItemIndex,
	resultAmount: u16,

	fn getValidRecipe(self: Recipe) error{Invalid}!*Recipe {
		outer: for (main.items.recipes()) |*recipe| {
			if (recipe.resultItem != self.resultItem) continue;
			if (recipe.resultAmount != self.resultAmount) continue;
			if (recipe.sourceItems.len != self.sourceItems.len) continue;
			for (recipe.sourceItems, recipe.sourceAmounts, self.sourceItems, self.sourceAmounts) |recipeItem, recipeAmount, selfItem, selfAmount| {
				if (recipeItem != selfItem) continue :outer;
				if (recipeAmount != selfAmount) continue :outer;
			}
			return recipe;
		}
		return error.Invalid;
	}

	pub fn toBytes(self: *const Recipe, writer: *BinaryWriter) void {
		writer.writeEnum(BaseItemIndex, self.resultItem);
		writer.writeVarInt(u16, self.resultAmount);
		writer.writeVarInt(usize, self.sourceItems.len);
		for (self.sourceItems, self.sourceAmounts) |item, amount| {
			writer.writeEnum(BaseItemIndex, item);
			writer.writeVarInt(u16, amount);
		}
	}

	pub fn fromBytes(reader: *BinaryReader) !*Recipe {
		const resultItem = try reader.readEnum(BaseItemIndex);
		const resultAmount = try reader.readVarInt(u16);
		const sourceCount = try reader.readVarInt(usize);

		var sourceItems: main.List(BaseItemIndex) = .initCapacity(main.stackAllocator, @min(256, sourceCount));
		defer sourceItems.deinit();
		var sourceAmounts: main.List(u16) = .initCapacity(main.stackAllocator, @min(256, sourceCount));
		defer sourceAmounts.deinit();

		while (reader.remaining.len > 0 and sourceItems.items.len < sourceCount) {
			sourceItems.append(try reader.readEnum(BaseItemIndex));
			sourceAmounts.append(try reader.readVarInt(u16));
		}

		return getValidRecipe(.{.sourceItems = sourceItems.items, .sourceAmounts = sourceAmounts.items, .resultItem = resultItem, .resultAmount = resultAmount});
	}
};

var toolTypeList: ListUnmanaged(ToolType) = .{};
var toolTypeIdToIndex: std.StringHashMapUnmanaged(ToolTypeIndex) = .{};

var reverseIndices: std.StringHashMapUnmanaged(BaseItemIndex) = .{};
var modifiers: std.StringHashMapUnmanaged(*const Modifier.VTable) = .{};
var modifierRestrictions: std.StringHashMapUnmanaged(*const ModifierRestriction.VTable) = .{};
pub var itemList: [65536]BaseItem = undefined;
pub var itemListSize: u16 = 0;

var recipeList: main.List(Recipe) = undefined;

pub fn hasRegistered(id: []const u8) bool {
	return reverseIndices.contains(id);
}

pub fn hasRegisteredTool(id: []const u8) bool {
	return toolTypeIdToIndex.contains(id);
}

pub fn iterator() std.StringHashMap(BaseItemIndex).ValueIterator {
	return reverseIndices.valueIterator();
}

pub fn recipes() []Recipe {
	return recipeList.items;
}

pub fn globalInit() void {
	toolTypeIdToIndex = .{};

	recipeList = .init(main.worldArena);
	itemListSize = 0;
	inline for (@typeInfo(modifierList).@"struct".decls) |decl| {
		const ModifierStruct = @field(modifierList, decl.name);
		modifiers.put(main.globalArena.allocator, decl.name, &.{
			.changeToolParameters = @ptrCast(&ModifierStruct.changeToolParameters),
			.changeBlockDamage = @ptrCast(&ModifierStruct.changeBlockDamage),
			.combineModifiers = @ptrCast(&ModifierStruct.combineModifiers),
			.printTooltip = @ptrCast(&ModifierStruct.printTooltip),
			.loadData = @ptrCast(&ModifierStruct.loadData),
			.priority = ModifierStruct.priority,
		}) catch unreachable;
	}
	inline for (@typeInfo(modifierRestrictionList).@"struct".decls) |decl| {
		const ModifierRestrictionStruct = @field(modifierRestrictionList, decl.name);
		modifierRestrictions.put(main.globalArena.allocator, decl.name, &.{
			.satisfied = comptime main.meta.castFunctionSelfToAnyopaque(ModifierRestrictionStruct.satisfied),
			.loadFromZon = comptime main.meta.castFunctionReturnToAnyopaque(ModifierRestrictionStruct.loadFromZon),
			.printTooltip = comptime main.meta.castFunctionSelfToAnyopaque(ModifierRestrictionStruct.printTooltip),
		}) catch unreachable;
	}
	Inventory.ClientSide.init();
}

pub fn register(_: []const u8, texturePath: []const u8, replacementTexturePath: []const u8, id: []const u8, zon: ZonElement) *BaseItem {
	const newItem = &itemList[itemListSize];
	defer itemListSize += 1;

	newItem.init(main.worldArena, texturePath, replacementTexturePath, id, zon);
	reverseIndices.put(main.worldArena.allocator, newItem.id, @enumFromInt(itemListSize)) catch unreachable;

	std.log.debug("Registered item: {d: >5} '{s}'", .{itemListSize, id});
	return newItem;
}

fn loadPixelSources(assetFolder: []const u8, id: []const u8, layerPostfix: []const u8, pixelSources: *[16][16]u8) void {
	var split = std.mem.splitScalar(u8, id, ':');
	const mod = split.first();
	const tool = split.rest();
	const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{s}/tools/{s}{s}.png", .{assetFolder, mod, tool, layerPostfix}) catch unreachable;
	defer main.stackAllocator.free(path);
	const image = main.graphics.Image.readFromFile(main.stackAllocator, path) catch |err| blk: {
		if (err != error.FileNotFound) {
			std.log.err("Error while reading tool image '{s}': {s}", .{path, @errorName(err)});
		}
		const replacementPath = std.fmt.allocPrint(main.stackAllocator.allocator, "assets/{s}/tools/{s}{s}.png", .{mod, tool, layerPostfix}) catch unreachable;
		defer main.stackAllocator.free(replacementPath);
		break :blk main.graphics.Image.readFromFile(main.stackAllocator, replacementPath) catch |err2| {
			if (layerPostfix.len == 0 or err2 != error.FileNotFound)
				std.log.err("Error while reading tool image. Tried '{s}' and '{s}': {s}", .{path, replacementPath, @errorName(err2)});
			break :blk main.graphics.Image.emptyImage;
		};
	};
	defer image.deinit(main.stackAllocator);
	if ((image.width != 16 or image.height != 16) and image.imageData.ptr != main.graphics.Image.emptyImage.imageData.ptr) {
		std.log.err("Truncating image for {s} with incorrect dimensions. Should be 16×16.", .{id});
	}
	for (0..16) |x| {
		for (0..16) |y| {
			const color = if (image.width != 0 and image.height != 0) image.getRGB(@min(image.width - 1, x), image.height - 1 - @min(image.height - 1, y)) else main.graphics.Color{.r = 0, .g = 0, .b = 0, .a = 0};
			pixelSources[x][y] = blk: {
				if (color.a == 0) break :blk 255;
				const xPos = color.r/52;
				const yPos = color.b/52;
				break :blk xPos + 5*yPos;
			};
		}
	}
}

pub fn registerTool(assetFolder: []const u8, id: []const u8, zon: ZonElement) void {
	var slotInfos: [25]SlotInfo = @splat(.{});
	for (zon.getChild("disabled").toSlice(), 0..) |zonDisabled, i| {
		if (i >= 25) {
			std.log.err("disabled array of {s} has too many entries", .{id});
			break;
		}
		slotInfos[i].disabled = zonDisabled.as(usize, 0) != 0;
	}
	for (zon.getChild("optional").toSlice(), 0..) |zonDisabled, i| {
		if (i >= 25) {
			std.log.err("disabled array of {s} has too many entries", .{id});
			break;
		}
		slotInfos[i].optional = zonDisabled.as(usize, 0) != 0;
	}
	var parameterMatrices: main.List(PropertyMatrix) = .init(main.worldArena);
	for (zon.getChild("parameters").toSlice()) |paramZon| {
		const val = parameterMatrices.addOne();
		val.source = MaterialProperty.fromString(paramZon.get([]const u8, "source", "not specified"));
		val.destination = ToolProperty.fromString(paramZon.get([]const u8, "destination", "not specified"));
		val.resultScale = paramZon.get(f32, "factor", 1.0);
		val.method = PropertyMatrix.Method.fromString(paramZon.get([]const u8, "method", "not specified")) orelse .sum;
		const matrixZon = paramZon.getChild("matrix");
		var total_weight: f32 = 0.0;
		for (0..25) |i| {
			val.weights[i] = matrixZon.getAtIndex(f32, i, 0.0);
		}
		for (0..25) |i| {
			total_weight += val.weights[i];
		}
		for (0..25) |i| {
			if (val.weights[i] != 0x0) {
				val.weights[i] /= total_weight;
			}
		}
	}
	var pixelSources: [16][16]u8 = undefined;
	loadPixelSources(assetFolder, id, "", &pixelSources);
	var pixelSourcesOverlay: [16][16]u8 = undefined;
	loadPixelSources(assetFolder, id, "_overlay", &pixelSourcesOverlay);

	const idDupe = main.worldArena.dupe(u8, id);
	toolTypeList.append(main.worldArena, .{
		.id = idDupe,
		.blockTags = Tag.loadTagsFromZon(main.worldArena, zon.getChild("blockTags")),
		.slotInfos = slotInfos,
		.properties = parameterMatrices.toOwnedSlice(),
		.pixelSources = pixelSources,
		.pixelSourcesOverlay = pixelSourcesOverlay,
	});
	toolTypeIdToIndex.put(main.worldArena.allocator, idDupe, @enumFromInt(toolTypeList.items.len - 1)) catch unreachable;

	std.log.debug("Registered tool: '{s}'", .{id});
}

fn parseRecipeItem(zon: ZonElement) !ItemStack {
	var id = zon.as([]const u8, "");
	id = std.mem.trim(u8, id, &std.ascii.whitespace);
	var result: ItemStack = .{.amount = 1};
	if (std.mem.indexOfScalar(u8, id, ' ')) |index| blk: {
		result.amount = std.fmt.parseInt(u16, id[0..index], 0) catch break :blk;
		id = id[index + 1 ..];
		id = std.mem.trim(u8, id, &std.ascii.whitespace);
	}
	result.item = .{.baseItem = BaseItemIndex.fromId(id) orelse return error.ItemNotFound};
	return result;
}

fn parseRecipe(zon: ZonElement) !Recipe {
	const inputs = zon.getChild("inputs").toSlice();
	const output = try parseRecipeItem(zon.getChild("output"));
	const recipe = Recipe{
		.sourceItems = main.worldArena.alloc(BaseItemIndex, inputs.len),
		.sourceAmounts = main.worldArena.alloc(u16, inputs.len),
		.resultItem = output.item.baseItem,
		.resultAmount = output.amount,
	};
	for (inputs, 0..) |inputZon, i| {
		const input = try parseRecipeItem(inputZon);
		recipe.sourceItems[i] = input.item.baseItem;
		recipe.sourceAmounts[i] = input.amount;
	}
	return recipe;
}

pub fn registerRecipes(zon: ZonElement) void {
	for (zon.toSlice()) |recipeZon| {
		recipes_zig.parseRecipe(main.globalAllocator, recipeZon, &recipeList) catch |err| {
			const recipeString = recipeZon.toString(main.stackAllocator);
			defer main.stackAllocator.free(recipeString);
			std.log.err("Skipping recipe with error {s}:\n{s}", .{@errorName(err), recipeString});
			continue;
		};
	}
}

pub fn clearRecipeCachedInventories() void {
	for (recipeList.items) |recipe| {
		main.globalAllocator.free(recipe.sourceItems);
		main.globalAllocator.free(recipe.sourceAmounts);
	}
}

pub fn reset() void {
	toolTypeList = .{};
	toolTypeIdToIndex = .{};
	reverseIndices = .{};
	recipeList.clearAndFree();
	itemListSize = 0;
}

pub fn deinit() void {
	Inventory.ClientSide.deinit();
}

```

`src/items/recipes.zig`:

```zig
const std = @import("std");
const main = @import("main");
const items = main.items;
const ZonElement = main.ZonElement;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const NeverFailingArenaAllocator = main.heap.NeverFailingArenaAllocator;
const Tag = main.Tag;
const Recipe = items.Recipe;
const BaseItemIndex = items.BaseItemIndex;
const Block = main.blocks.Block;

const Segment = union(enum) { literal: []const u8, symbol: []const u8 };

fn parsePattern(allocator: NeverFailingAllocator, pattern: []const u8) ![]const Segment {
	var segments: main.List(Segment) = .init(allocator);
	defer segments.deinit();
	var idx: usize = 0;
	while (idx < pattern.len) {
		if (pattern[idx] == '{') {
			if (segments.items.len > 0 and segments.items[segments.items.len - 1] == .symbol) {
				return error.AmbiguousSymbols;
			}
			idx += 1;
			const endIndex = std.mem.indexOfScalarPos(u8, pattern, idx, '}') orelse return error.UnclosedBraces;
			if (idx == endIndex) return error.EmptyBraces;
			const symbol = pattern[idx..endIndex];
			segments.append(.{.symbol = symbol});
			idx = endIndex + 1;
		} else {
			const endIndex = std.mem.indexOfScalarPos(u8, pattern, idx, '{') orelse pattern.len;
			segments.append(.{.literal = pattern[idx..endIndex]});
			idx = endIndex;
		}
	}
	return segments.toOwnedSlice();
}

const ItemStackPattern = struct {
	amount: u16,
	pattern: []const Segment,
};

fn parseItemZon(allocator: NeverFailingAllocator, zon: ZonElement) !ItemStackPattern {
	var id = zon.as([]const u8, "");
	var amount: u16 = 1;
	if (std.mem.indexOfScalar(u8, id, ' ')) |index| blk: {
		amount = std.fmt.parseInt(u16, id[0..index], 0) catch break :blk;
		id = id[index + 1 ..];
	}
	const pattern = try parsePattern(allocator, id);
	return .{
		.amount = amount,
		.pattern = pattern,
	};
}

fn matchWithKeys(allocator: NeverFailingAllocator, target: []const u8, pattern: []const Segment, keys: *const std.StringHashMap([]const u8)) ![]const std.StringHashMap([]const u8) {
	var idx: usize = 0;
	var newKeys = keys.clone() catch unreachable;
	errdefer newKeys.deinit();

	for (0.., pattern) |i, segment| {
		switch (segment) {
			.literal => |literal| {
				if (!std.mem.startsWith(u8, target[idx..], literal)) {
					return error.NoMatch;
				}
				idx += literal.len;
			},
			.symbol => |symbol| {
				var endIndices: main.List(usize) = .init(allocator);
				defer endIndices.deinit();
				if (newKeys.get(symbol)) |value| {
					if (!std.mem.startsWith(u8, target[idx..], value)) {
						return error.NoMatch;
					}
					idx += value.len;
				} else {
					if (i + 1 < pattern.len) {
						const nextSegment = pattern[i + 1];
						var nextIndex = idx;
						while (std.mem.indexOfPos(u8, target, nextIndex, nextSegment.literal)) |endIndex| {
							endIndices.append(endIndex);
							nextIndex = endIndex + 1;
						}
					} else {
						endIndices.append(target.len);
					}
					if (endIndices.items.len == 0) {
						return error.NoMatch;
					}
					if (endIndices.items.len == 1) {
						newKeys.put(symbol, target[idx..endIndices.items[0]]) catch unreachable;
						idx = endIndices.items[0];
					} else {
						defer newKeys.deinit();
						var newKeyPairs: main.List(std.StringHashMap([]const u8)) = .init(allocator);
						defer newKeyPairs.deinit();
						for (endIndices.items) |endIndex| {
							newKeys.put(symbol, target[idx..endIndex]) catch unreachable;
							if (matchWithKeys(allocator, target[endIndex..], pattern[i + 1 ..], &newKeys) catch null) |newKeyMatches| {
								newKeyPairs.appendSlice(newKeyMatches);
								allocator.free(newKeyMatches);
							}
						}
						if (newKeyPairs.items.len == 0) return error.NoMatch;
						return newKeyPairs.toOwnedSlice();
					}
				}
			},
		}
	}
	if (idx == target.len) {
		var newKeyPairs = allocator.alloc(std.StringHashMap([]const u8), 1);
		newKeyPairs[0] = newKeys;
		return newKeyPairs;
	} else {
		return error.NoMatch;
	}
}

const ItemWithAmount = struct {
	item: BaseItemIndex,
	amount: u16,
};

const ItemKeyPair = struct { item: ItemWithAmount, keys: std.StringHashMap([]const u8) };

fn findRecipeItemOptions(allocator: NeverFailingAllocator, itemStackPattern: ItemStackPattern, keys: *const std.StringHashMap([]const u8)) ![]const ItemKeyPair {
	const pattern = itemStackPattern.pattern;
	const amount = itemStackPattern.amount;

	if (pattern.len == 1 and pattern[0] == .literal) {
		const item = BaseItemIndex.fromId(pattern[0].literal) orelse return error.ItemNotFound;
		return allocator.dupe(ItemKeyPair, &.{.{
			.item = .{
				.item = item,
				.amount = amount,
			},
			.keys = keys.clone() catch unreachable,
		}});
	}
	var itemPairs: main.List(ItemKeyPair) = .initCapacity(allocator, 1);
	defer itemPairs.deinit();
	var iter = items.iterator();
	while (iter.next()) |item| {
		const newKeyMatches = matchWithKeys(allocator, item.id(), pattern, keys) catch continue;
		for (newKeyMatches) |match| {
			itemPairs.append(.{
				.item = .{
					.item = item.*,
					.amount = amount,
				},
				.keys = match,
			});
		}
	}
	return itemPairs.toOwnedSlice();
}

fn generateItemCombos(allocator: NeverFailingAllocator, recipe: []const ZonElement) ![]const []const ItemWithAmount {
	const arena = main.stackAllocator.createArena();
	defer main.stackAllocator.destroyArena(arena);

	var inputCombos: main.List([]const ItemWithAmount) = .initCapacity(arena, 1);
	inputCombos.append(arena.alloc(ItemWithAmount, recipe.len));
	var keyList: main.List(std.StringHashMap([]const u8)) = .initCapacity(arena, 1);
	keyList.append(.init(arena.allocator));
	for (0.., recipe[0..]) |i, itemZon| {
		const pattern = try parseItemZon(arena, itemZon);
		var newKeyList: main.List(std.StringHashMap([]const u8)) = .init(arena);
		var newInputCombos: main.List([]const ItemWithAmount) = .init(arena);

		for (keyList.items, inputCombos.items) |*keys, inputs| {
			const parsedItems = try findRecipeItemOptions(arena, pattern, keys);
			for (parsedItems) |item| {
				const newInputs = arena.dupe(ItemWithAmount, inputs);
				newInputs[i] = item.item;
				newInputCombos.append(newInputs);
				newKeyList.append(item.keys);
			}
		}
		keyList = newKeyList;
		inputCombos = newInputCombos;
	}
	const newInputCombos = allocator.alloc([]const ItemWithAmount, inputCombos.items.len);
	for (inputCombos.items, 0..) |inputCombo, i| {
		newInputCombos[i] = allocator.dupe(ItemWithAmount, inputCombo);
	}
	return newInputCombos;
}

pub fn addRecipe(allocator: NeverFailingAllocator, itemCombo: []const ItemWithAmount, list: *main.List(Recipe)) void {
	const inputs = itemCombo[0 .. itemCombo.len - 1];
	const output = itemCombo[itemCombo.len - 1];
	const recipe = Recipe{
		.sourceItems = allocator.alloc(BaseItemIndex, inputs.len),
		.sourceAmounts = allocator.alloc(u16, inputs.len),
		.resultItem = output.item,
		.resultAmount = output.amount,
	};
	for (inputs, 0..) |input, i| {
		recipe.sourceItems[i] = input.item;
		recipe.sourceAmounts[i] = input.amount;
	}
	list.append(recipe);
}

pub fn parseRecipe(allocator: NeverFailingAllocator, zon: ZonElement, list: *main.List(Recipe)) !void {
	const arena = main.stackAllocator.createArena();
	defer main.stackAllocator.destroyArena(arena);

	const inputs = zon.getChild("inputs").toSlice();
	const recipeItems = std.mem.concat(arena.allocator, ZonElement, &.{inputs, &.{zon.getChild("output")}}) catch unreachable;

	const reversible = zon.get(bool, "reversible", false);
	if (reversible and recipeItems.len != 2) {
		return error.InvalidReversibleRecipe;
	}

	const itemCombos = try generateItemCombos(arena, recipeItems);
	for (itemCombos) |itemCombo| {
		addRecipe(allocator, itemCombo, list);
		if (reversible) {
			addRecipe(allocator, &.{itemCombo[1], itemCombo[0]}, list);
		}
	}
}

test "pattern parsing" {
	try std.testing.expectError(error.AmbiguousSymbols, parsePattern(main.heap.testingAllocator, "cubyz:{a}{b}"));
	try std.testing.expectError(error.EmptyBraces, parsePattern(main.heap.testingAllocator, "{}"));
	try std.testing.expectError(error.UnclosedBraces, parsePattern(main.heap.testingAllocator, "cubyz:{foo"));

	const pattern = try parsePattern(main.heap.testingAllocator, "foo:{bar}/{baz}");
	defer main.heap.testingAllocator.free(pattern);
	const expected: []const Segment = &.{.{.literal = "foo:"}, .{.symbol = "bar"}, .{.literal = "/"}, .{.symbol = "baz"}};

	// Can't use expectEqualSlices because segments contain strings.
	try std.testing.expectEqualDeep(expected, pattern);
}

test "pattern matching" {
	const pattern = try parsePattern(main.heap.testingAllocator, "foo:{bar}/{baz}");
	defer main.heap.testingAllocator.free(pattern);

	var keys: std.StringHashMap([]const u8) = .init(main.heap.testingAllocator.allocator);
	defer keys.deinit();

	try std.testing.expectError(error.NoMatch, matchWithKeys(main.heap.testingAllocator, "foo:1", pattern, &keys));

	const newKeys = try matchWithKeys(main.heap.testingAllocator, "foo:1/2/3", pattern, &keys);
	defer {
		for (newKeys) |*keySet| {
			@constCast(keySet).deinit();
		}
		main.heap.testingAllocator.free(newKeys);
	}

	try std.testing.expectEqual(2, newKeys.len);
	try std.testing.expectEqualStrings("1", newKeys[0].get("bar").?);
	try std.testing.expectEqualStrings("2/3", newKeys[0].get("baz").?);
	try std.testing.expectEqualStrings("1/2", newKeys[1].get("bar").?);
	try std.testing.expectEqualStrings("3", newKeys[1].get("baz").?);
}

test "pattern matching with keys" {
	const pattern = try parsePattern(main.heap.testingAllocator, "foo:{bar}/{baz}");
	defer main.heap.testingAllocator.free(pattern);

	var keys: std.StringHashMap([]const u8) = .init(main.heap.testingAllocator.allocator);
	defer keys.deinit();
	keys.put("bar", "1/2") catch unreachable;

	const newKeys = try matchWithKeys(main.heap.testingAllocator, "foo:1/2/3", pattern, &keys);
	defer {
		for (newKeys) |*keySet| {
			@constCast(keySet).deinit();
		}
		main.heap.testingAllocator.free(newKeys);
	}

	try std.testing.expectEqual(1, newKeys.len);
	try std.testing.expectEqualStrings("1/2", newKeys[0].get("bar").?);
	try std.testing.expectEqualStrings("3", newKeys[0].get("baz").?);
}

```

`src/main.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

pub const gui = @import("gui/gui.zig");
pub const server = @import("server/server.zig");

pub const audio = @import("audio.zig");
pub const assets = @import("assets.zig");
pub const block_entity = @import("block_entity.zig");
pub const blocks = @import("blocks.zig");
pub const blueprint = @import("blueprint.zig");
pub const callbacks = @import("callbacks/callbacks.zig");
pub const chunk = @import("chunk.zig");
pub const entity = @import("entity.zig");
pub const files = @import("files.zig");
pub const game = @import("game.zig");
pub const graphics = @import("graphics.zig");
pub const itemdrop = @import("itemdrop.zig");
pub const items = @import("items.zig");
pub const meta = @import("meta.zig");
pub const migrations = @import("migrations.zig");
pub const models = @import("models.zig");
pub const network = @import("network.zig");
pub const physics = @import("physics.zig");
pub const random = @import("random.zig");
pub const renderer = @import("renderer.zig");
pub const rotation = @import("rotation.zig");
pub const settings = @import("settings.zig");
pub const sync = @import("sync.zig");
pub const particles = @import("particles.zig");
const tag = @import("tag.zig");
pub const Tag = tag.Tag;
pub const utils = @import("utils.zig");
pub const vec = @import("vec.zig");
pub const ZonElement = @import("zon.zig").ZonElement;

pub const Window = @import("graphics/Window.zig");

pub const heap = @import("utils/heap.zig");

pub const List = @import("utils/list.zig").List;
pub const ListUnmanaged = @import("utils/list.zig").ListUnmanaged;
pub const MultiArray = @import("utils/list.zig").MultiArray;

const file_monitor = utils.file_monitor;

const Vec2f = vec.Vec2f;
const Vec3d = vec.Vec3d;

pub threadlocal var stackAllocator: heap.NeverFailingAllocator = undefined;
pub threadlocal var seed: u64 = undefined;
threadlocal var stackAllocatorBase: heap.StackAllocator = undefined;
pub const globalAllocator: heap.NeverFailingAllocator = heap.allocators.handledGpa.allocator();
pub const globalArena = heap.allocators.globalArenaAllocator.allocator();
pub const worldArena = heap.allocators.worldArenaAllocator.allocator();
pub var threadPool: *utils.ThreadPool = undefined;
var threadedIo: std.Io.Threaded = undefined;
pub var io: std.Io = threadedIo.io();

pub fn initThreadLocals() void {
	seed = @bitCast(@as(i64, @truncate(timestamp().nanoseconds)));
	stackAllocatorBase = heap.StackAllocator.init(globalAllocator, 1 << 23);
	stackAllocator = stackAllocatorBase.allocator();
	heap.GarbageCollection.addThread();
}

pub fn deinitThreadLocals() void {
	stackAllocatorBase.deinit();
	heap.GarbageCollection.removeThread();
}

pub fn timestamp() std.Io.Timestamp {
	return (std.Io.Clock.Timestamp.now(io, if (@import("builtin").os.tag == .windows) .real else .awake) catch unreachable).raw; // TODO: On windows the awake time is broken
}

fn cacheStringImpl(comptime len: usize, comptime str: [len]u8) []const u8 {
	return str[0..len];
}

fn cacheString(comptime str: []const u8) []const u8 {
	return cacheStringImpl(str.len, str[0..].*);
}
var logFile: ?std.fs.File = undefined;
var logFileTs: ?std.fs.File = undefined;
var supportsANSIColors: bool = undefined;
var openingErrorWindow: bool = false;
// overwrite the log function:
pub const std_options: std.Options = .{ // MARK: std_options
	.log_level = .debug,
	.logFn = struct {
		pub fn logFn(
			comptime level: std.log.Level,
			comptime _: @Type(.enum_literal),
			comptime format: []const u8,
			args: anytype,
		) void {
			const color = comptime switch (level) {
				std.log.Level.err => "\x1b[31m",
				std.log.Level.info => "",
				std.log.Level.warn => "\x1b[33m",
				std.log.Level.debug => "\x1b[37;44m",
			};
			const colorReset = "\x1b[0m\n";
			const filePrefix = "[" ++ comptime level.asText() ++ "]" ++ ": ";
			const fileSuffix = "\n";
			comptime var formatString: []const u8 = "";
			comptime var i: usize = 0;
			comptime var mode: usize = 0;
			comptime var sections: usize = 0;
			comptime var sectionString: []const u8 = "";
			comptime var sectionResults: []const []const u8 = &.{};
			comptime var sectionId: []const usize = &.{};
			inline while (i < format.len) : (i += 1) {
				if (mode == 0) {
					if (format[i] == '{') {
						if (format[i + 1] == '{') {
							sectionString = sectionString ++ "{{";
							i += 1;
							continue;
						} else {
							mode = 1;
							formatString = formatString ++ "{s}{";
							sectionResults = sectionResults ++ &[_][]const u8{sectionString};
							sectionString = "";
							sectionId = sectionId ++ &[_]usize{sections};
							sections += 1;
							continue;
						}
					} else {
						sectionString = sectionString ++ format[i .. i + 1];
					}
				} else {
					formatString = formatString ++ format[i .. i + 1];
					if (format[i] == '}') {
						sections += 1;
						mode = 0;
					}
				}
			}
			formatString = formatString ++ "{s}";
			sectionResults = sectionResults ++ &[_][]const u8{sectionString};
			sectionId = sectionId ++ &[_]usize{sections};
			sections += 1;
			formatString = comptime cacheString("{s}" ++ formatString ++ "{s}");

			comptime var types: []const type = &.{};
			comptime var i_1: usize = 0;
			comptime var i_2: usize = 0;
			inline while (types.len != sections) {
				if (i_2 < sectionResults.len) {
					if (types.len == sectionId[i_2]) {
						types = types ++ &[_]type{[]const u8};
						i_2 += 1;
						continue;
					}
				}
				const TI = @typeInfo(@TypeOf(args[i_1]));
				if (@TypeOf(args[i_1]) == comptime_int) {
					types = types ++ &[_]type{i64};
				} else if (@TypeOf(args[i_1]) == comptime_float) {
					types = types ++ &[_]type{f64};
				} else if (TI == .pointer and TI.pointer.size == .slice and TI.pointer.child == u8) {
					types = types ++ &[_]type{[]const u8};
				} else if (TI == .int and TI.int.bits <= 64) {
					if (TI.int.signedness == .signed) {
						types = types ++ &[_]type{i64};
					} else {
						types = types ++ &[_]type{u64};
					}
				} else {
					types = types ++ &[_]type{@TypeOf(args[i_1])};
				}
				i_1 += 1;
			}
			types = &[_]type{[]const u8} ++ types ++ &[_]type{[]const u8};

			const ArgsType = std.meta.Tuple(types);
			comptime var comptimeTuple: ArgsType = undefined;
			comptime var len: usize = 0;
			i_1 = 0;
			i_2 = 0;
			inline while (len != sections) : (len += 1) {
				if (i_2 < sectionResults.len) {
					if (len == sectionId[i_2]) {
						comptimeTuple[len + 1] = sectionResults[i_2];
						i_2 += 1;
						continue;
					}
				}
				i_1 += 1;
			}
			comptimeTuple[0] = filePrefix;
			comptimeTuple[comptimeTuple.len - 1] = fileSuffix;
			var resultArgs: ArgsType = comptimeTuple;
			len = 0;
			i_1 = 0;
			i_2 = 0;
			inline while (len != sections) : (len += 1) {
				if (i_2 < sectionResults.len) {
					if (len == sectionId[i_2]) {
						i_2 += 1;
						continue;
					}
				}
				resultArgs[len + 1] = args[i_1];
				i_1 += 1;
			}

			logToFile(formatString, resultArgs);

			if (supportsANSIColors) {
				resultArgs[0] = color;
				resultArgs[resultArgs.len - 1] = colorReset;
			}
			logToStdErr(formatString, resultArgs);
			if (level == .err and !openingErrorWindow and !settings.launchConfig.headlessServer) {
				openingErrorWindow = true;
				gui.openWindow("error_prompt");
				openingErrorWindow = false;
			}
		}
	}.logFn,
};

fn initLogging() void {
	logFile = null;
	files.cwd().makePath("logs") catch |err| {
		std.log.err("Couldn't create logs folder: {s}", .{@errorName(err)});
		return;
	};
	logFile = std.fs.cwd().createFile("logs/latest.log", .{}) catch |err| {
		std.log.err("Couldn't create logs/latest.log: {s}", .{@errorName(err)});
		return;
	};

	const _timestamp = (std.Io.Clock.Timestamp.now(io, .real) catch unreachable).raw;

	const _path_str = std.fmt.allocPrint(stackAllocator.allocator, "logs/ts_{}.log", .{_timestamp.nanoseconds}) catch unreachable;
	defer stackAllocator.free(_path_str);

	logFileTs = std.fs.cwd().createFile(_path_str, .{}) catch |err| {
		std.log.err("Couldn't create {s}: {s}", .{_path_str, @errorName(err)});
		return;
	};

	supportsANSIColors = std.fs.File.stdout().supportsAnsiEscapeCodes();
}

fn deinitLogging() void {
	if (logFile) |_logFile| {
		_logFile.close();
		logFile = null;
	}

	if (logFileTs) |_logFileTs| {
		_logFileTs.close();
		logFileTs = null;
	}
}

fn logToFile(comptime format: []const u8, args: anytype) void {
	var buf: [65536]u8 = undefined;
	var fba = std.heap.FixedBufferAllocator.init(&buf);
	const allocator = fba.allocator();

	const string = std.fmt.allocPrint(allocator, format, args) catch format;
	(logFile orelse return).writeAll(string) catch {};
	(logFileTs orelse return).writeAll(string) catch {};
}

fn logToStdErr(comptime format: []const u8, args: anytype) void {
	var buf: [65536]u8 = undefined;
	var fba = std.heap.FixedBufferAllocator.init(&buf);
	const allocator = fba.allocator();

	const string = std.fmt.allocPrint(allocator, format, args) catch format;
	const writer = std.debug.lockStderrWriter(&.{});
	defer std.debug.unlockStderrWriter();
	nosuspend writer[0].writeAll(string) catch {};
}

// MARK: Callbacks
fn escape(mods: Window.Key.Modifiers) void {
	if (gui.selectedTextInput != null) gui.setSelectedTextInput(null);
	inventory(mods);
}
fn inventory(_: Window.Key.Modifiers) void {
	if (game.world == null) return;
	gui.openWindow("inventory");
	gui.openWindow("hotbar");
	gui.toggleGameMenu();
}
fn ungrabMouse(_: Window.Key.Modifiers) void {
	if (Window.grabbed) {
		gui.toggleGameMenu();
	}
}
fn openCreativeInventory(mods: Window.Key.Modifiers) void {
	if (game.world == null) return;
	if (!game.Player.isCreative()) return;
	ungrabMouse(mods);
	gui.openWindow("creative_inventory");
}
fn openChat(mods: Window.Key.Modifiers) void {
	if (!gui.isWindowOpen("chat")) return;
	ungrabMouse(mods);
	gui.openWindow("chat");
	gui.windowlist.chat.input.select();
}
fn openCommand(mods: Window.Key.Modifiers) void {
	if (!gui.isWindowOpen("chat")) return;
	openChat(mods);
	gui.windowlist.chat.input.clear();
	gui.windowlist.chat.input.inputCharacter('/');
}
fn takeBackgroundImageFn(_: Window.Key.Modifiers) void {
	if (game.world == null) return;

	const oldHideGui = gui.hideGui;
	gui.hideGui = true;
	const oldShowItem = itemdrop.ItemDisplayManager.showItem;
	itemdrop.ItemDisplayManager.showItem = false;

	renderer.MenuBackGround.takeBackgroundImage();

	gui.hideGui = oldHideGui;
	itemdrop.ItemDisplayManager.showItem = oldShowItem;
}
fn toggleHideGui(_: Window.Key.Modifiers) void {
	gui.hideGui = !gui.hideGui;
}
fn toggleHideDisplayItem(_: Window.Key.Modifiers) void {
	itemdrop.ItemDisplayManager.showItem = !itemdrop.ItemDisplayManager.showItem;
}
fn toggleDebugOverlay(_: Window.Key.Modifiers) void {
	gui.toggleWindow("debug");
}
fn togglePerformanceOverlay(_: Window.Key.Modifiers) void {
	gui.toggleWindow("performance_graph");
}
fn toggleGPUPerformanceOverlay(_: Window.Key.Modifiers) void {
	gui.toggleWindow("gpu_performance_measuring");
}
fn toggleNetworkDebugOverlay(_: Window.Key.Modifiers) void {
	gui.toggleWindow("debug_network");
}
fn toggleAdvancedNetworkDebugOverlay(_: Window.Key.Modifiers) void {
	gui.toggleWindow("debug_network_advanced");
}
fn cycleHotbarSlot(i: comptime_int) *const fn (Window.Key.Modifiers) void {
	return &struct {
		fn set(_: Window.Key.Modifiers) void {
			game.Player.selectedSlot = @intCast(@mod(@as(i33, game.Player.selectedSlot) + i, 12));
		}
	}.set;
}
fn setHotbarSlot(i: comptime_int) *const fn (Window.Key.Modifiers) void {
	return &struct {
		fn set(_: Window.Key.Modifiers) void {
			game.Player.selectedSlot = i - 1;
		}
	}.set;
}

pub const KeyBoard = struct { // MARK: KeyBoard
	const c = Window.c;
	pub var keys = [_]Window.Key{
		// Gameplay:
		.{.name = "forward", .key = c.GLFW_KEY_W, .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_Y, .positive = false}},
		.{.name = "left", .key = c.GLFW_KEY_A, .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_X, .positive = false}},
		.{.name = "backward", .key = c.GLFW_KEY_S, .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_Y, .positive = true}},
		.{.name = "right", .key = c.GLFW_KEY_D, .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_X, .positive = true}},
		.{.name = "sprint", .key = c.GLFW_KEY_LEFT_CONTROL, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_LEFT_THUMB, .isToggling = .no},
		.{.name = "jump", .key = c.GLFW_KEY_SPACE, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_A},
		.{.name = "crouch", .key = c.GLFW_KEY_LEFT_SHIFT, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_RIGHT_THUMB},
		.{.name = "fly", .key = c.GLFW_KEY_F, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_DPAD_DOWN, .pressAction = &game.flyToggle},
		.{.name = "ghost", .key = c.GLFW_KEY_G, .pressAction = &game.ghostToggle},
		.{.name = "hyperSpeed", .key = c.GLFW_KEY_H, .pressAction = &game.hyperSpeedToggle},
		.{.name = "fall", .key = c.GLFW_KEY_LEFT_SHIFT, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_RIGHT_THUMB},
		.{.name = "placeBlock", .mouseButton = c.GLFW_MOUSE_BUTTON_RIGHT, .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_TRIGGER}, .pressAction = &game.pressPlace, .releaseAction = &game.releasePlace, .notifyRequirement = .inGame},
		.{.name = "breakBlock", .mouseButton = c.GLFW_MOUSE_BUTTON_LEFT, .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER}, .pressAction = &game.pressBreak, .releaseAction = &game.releaseBreak, .notifyRequirement = .inGame},
		.{.name = "acquireSelectedBlock", .mouseButton = c.GLFW_MOUSE_BUTTON_MIDDLE, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_DPAD_LEFT, .pressAction = &game.pressAcquireSelectedBlock, .notifyRequirement = .inGame},
		.{.name = "drop", .key = c.GLFW_KEY_Q, .repeatAction = &game.Player.dropFromHand, .notifyRequirement = .inGame},

		.{.name = "takeBackgroundImage", .key = c.GLFW_KEY_PRINT_SCREEN, .pressAction = &takeBackgroundImageFn},
		.{.name = "fullscreen", .key = c.GLFW_KEY_F11, .pressAction = &Window.toggleFullscreen},

		// Gui:
		.{.name = "escape", .key = c.GLFW_KEY_ESCAPE, .pressAction = &escape, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_B},
		.{.name = "openInventory", .key = c.GLFW_KEY_E, .pressAction = &escape, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_X},
		.{.name = "openCreativeInventory(aka cheat inventory)", .key = c.GLFW_KEY_C, .pressAction = &openCreativeInventory, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_Y},
		.{.name = "openChat", .key = c.GLFW_KEY_T, .releaseAction = &openChat},
		.{.name = "openCommand", .key = c.GLFW_KEY_SLASH, .releaseAction = &openCommand},
		.{.name = "mainGuiButton", .mouseButton = c.GLFW_MOUSE_BUTTON_LEFT, .pressAction = &gui.mainButtonPressed, .releaseAction = &gui.mainButtonReleased, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_A, .notifyRequirement = .inMenu},
		.{.name = "secondaryGuiButton", .mouseButton = c.GLFW_MOUSE_BUTTON_RIGHT, .pressAction = &gui.secondaryButtonPressed, .releaseAction = &gui.secondaryButtonReleased, .gamepadButton = c.GLFW_GAMEPAD_BUTTON_Y, .notifyRequirement = .inMenu},
		// gamepad gui.
		.{.name = "scrollUp", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_Y, .positive = false}},
		.{.name = "scrollDown", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_Y, .positive = true}},
		.{.name = "uiUp", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_Y, .positive = false}},
		.{.name = "uiLeft", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_X, .positive = false}},
		.{.name = "uiDown", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_Y, .positive = true}},
		.{.name = "uiRight", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_LEFT_X, .positive = true}},
		// text:
		.{.name = "textCursorLeft", .key = c.GLFW_KEY_LEFT, .repeatAction = &gui.textCallbacks.left},
		.{.name = "textCursorRight", .key = c.GLFW_KEY_RIGHT, .repeatAction = &gui.textCallbacks.right},
		.{.name = "textCursorDown", .key = c.GLFW_KEY_DOWN, .repeatAction = &gui.textCallbacks.down},
		.{.name = "textCursorUp", .key = c.GLFW_KEY_UP, .repeatAction = &gui.textCallbacks.up},
		.{.name = "textGotoStart", .key = c.GLFW_KEY_HOME, .repeatAction = &gui.textCallbacks.gotoStart},
		.{.name = "textGotoEnd", .key = c.GLFW_KEY_END, .repeatAction = &gui.textCallbacks.gotoEnd},
		.{.name = "textDeleteLeft", .key = c.GLFW_KEY_BACKSPACE, .repeatAction = &gui.textCallbacks.deleteLeft},
		.{.name = "textDeleteRight", .key = c.GLFW_KEY_DELETE, .repeatAction = &gui.textCallbacks.deleteRight},
		.{.name = "textSelectAll", .key = c.GLFW_KEY_A, .repeatAction = &gui.textCallbacks.selectAll, .requiredModifiers = .{.control = true}},
		.{.name = "textCopy", .key = c.GLFW_KEY_C, .repeatAction = &gui.textCallbacks.copy, .requiredModifiers = .{.control = true}},
		.{.name = "textPaste", .key = c.GLFW_KEY_V, .repeatAction = &gui.textCallbacks.paste, .requiredModifiers = .{.control = true}},
		.{.name = "textCut", .key = c.GLFW_KEY_X, .repeatAction = &gui.textCallbacks.cut, .requiredModifiers = .{.control = true}},
		.{.name = "textNewline", .key = c.GLFW_KEY_ENTER, .repeatAction = &gui.textCallbacks.newline},

		// Hotbar shortcuts:
		.{.name = "Hotbar 1", .key = c.GLFW_KEY_1, .pressAction = setHotbarSlot(1)},
		.{.name = "Hotbar 2", .key = c.GLFW_KEY_2, .pressAction = setHotbarSlot(2)},
		.{.name = "Hotbar 3", .key = c.GLFW_KEY_3, .pressAction = setHotbarSlot(3)},
		.{.name = "Hotbar 4", .key = c.GLFW_KEY_4, .pressAction = setHotbarSlot(4)},
		.{.name = "Hotbar 5", .key = c.GLFW_KEY_5, .pressAction = setHotbarSlot(5)},
		.{.name = "Hotbar 6", .key = c.GLFW_KEY_6, .pressAction = setHotbarSlot(6)},
		.{.name = "Hotbar 7", .key = c.GLFW_KEY_7, .pressAction = setHotbarSlot(7)},
		.{.name = "Hotbar 8", .key = c.GLFW_KEY_8, .pressAction = setHotbarSlot(8)},
		.{.name = "Hotbar 9", .key = c.GLFW_KEY_9, .pressAction = setHotbarSlot(9)},
		.{.name = "Hotbar 10", .key = c.GLFW_KEY_0, .pressAction = setHotbarSlot(10)},
		.{.name = "Hotbar 11", .key = c.GLFW_KEY_MINUS, .pressAction = setHotbarSlot(11)},
		.{.name = "Hotbar 12", .key = c.GLFW_KEY_EQUAL, .pressAction = setHotbarSlot(12)},
		.{.name = "Hotbar left", .gamepadButton = c.GLFW_GAMEPAD_BUTTON_LEFT_BUMPER, .pressAction = cycleHotbarSlot(-1)},
		.{.name = "Hotbar right", .gamepadButton = c.GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER, .pressAction = cycleHotbarSlot(1)},
		.{.name = "cameraLeft", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_X, .positive = false}},
		.{.name = "cameraRight", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_X, .positive = true}},
		.{.name = "cameraUp", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_Y, .positive = false}},
		.{.name = "cameraDown", .gamepadAxis = .{.axis = c.GLFW_GAMEPAD_AXIS_RIGHT_Y, .positive = true}},
		// debug:
		.{.name = "hideMenu", .key = c.GLFW_KEY_F1, .pressAction = &toggleHideGui},
		.{.name = "hideDisplayItem", .key = c.GLFW_KEY_F2, .pressAction = &toggleHideDisplayItem},
		.{.name = "debugOverlay", .key = c.GLFW_KEY_F3, .pressAction = &toggleDebugOverlay},
		.{.name = "performanceOverlay", .key = c.GLFW_KEY_F4, .pressAction = &togglePerformanceOverlay},
		.{.name = "gpuPerformanceOverlay", .key = c.GLFW_KEY_F5, .pressAction = &toggleGPUPerformanceOverlay},
		.{.name = "networkDebugOverlay", .key = c.GLFW_KEY_F6, .pressAction = &toggleNetworkDebugOverlay},
		.{.name = "advancedNetworkDebugOverlay", .key = c.GLFW_KEY_F7, .pressAction = &toggleAdvancedNetworkDebugOverlay},
	};

	fn findKey(name: []const u8) ?*Window.Key { // TODO: Maybe I should use a hashmap here?
		for (&keys) |*_key| {
			if (std.mem.eql(u8, name, _key.name)) {
				return _key;
			}
		}
		return null;
	}
	pub fn key(name: []const u8) *const Window.Key {
		return findKey(name) orelse {
			std.log.err("Couldn't find keyboard key with name {s}", .{name});
			return &.{.name = ""};
		};
	}
	pub fn setIsToggling(name: []const u8, value: bool) void {
		if (findKey(name)) |theKey| {
			if (theKey.isToggling == .never) {
				std.log.err("Tried setting toggling on non-toggling key with name {s}", .{name});
				return;
			}
			theKey.isToggling = if (value) .yes else .no;
			if (!value) {
				theKey.pressed = false;
			}
		} else {
			std.log.err("Couldn't find keyboard key to toggle with name {s}", .{name});
		}
	}
};

/// Records gpu time per frame.
pub var lastFrameTime = std.atomic.Value(f64).init(0);
/// Measures time between different frames' beginnings.
pub var lastDeltaTime = std.atomic.Value(f64).init(0);

var shouldExitToMenu = std.atomic.Value(bool).init(false);
pub fn exitToMenu() void {
	shouldExitToMenu.store(true, .monotonic);
}

fn isHiddenOrParentHiddenPosix(path: []const u8) bool {
	var iter = std.fs.path.componentIterator(path) catch |err| {
		std.log.err("Cannot iterate on path {s}: {s}!", .{path, @errorName(err)});
		return false;
	};
	while (iter.next()) |component| {
		if (std.mem.eql(u8, component.name, ".") or std.mem.eql(u8, component.name, "..")) {
			continue;
		}
		if (component.name.len > 0 and component.name[0] == '.') {
			return true;
		}
	}
	return false;
}

pub fn main() void { // MARK: main()
	defer heap.allocators.deinit();
	defer heap.GarbageCollection.assertAllThreadsStopped();
	initThreadLocals();
	defer deinitThreadLocals();
	threadedIo = .init(globalAllocator.allocator);
	defer threadedIo.deinit();

	initLogging();
	defer deinitLogging();

	std.log.info("Starting game with version {s}", .{settings.version.version});

	if (builtin.os.tag == .windows) {
		std.log.warn("Cubyz detected it's running on Windows. For optimal performance and reduced power usage please install Linux.", .{});
	}

	settings.launchConfig.init();

	const headless = settings.launchConfig.headlessServer;

	if (!headless) gui.initWindowList();
	defer if (!headless) gui.deinitWindowList();

	files.init();
	defer files.deinit();

	settings.init();
	defer settings.deinit();

	threadPool = utils.ThreadPool.init(globalAllocator, settings.cpuThreads orelse @max(1, (std.Thread.getCpuCount() catch 4) -| 1));
	defer threadPool.deinit();

	file_monitor.init();
	defer file_monitor.deinit();

	if (!headless) Window.init();
	defer if (!headless) Window.deinit();

	if (!headless) graphics.init();
	defer if (!headless) graphics.deinit();

	if (!headless) audio.init() catch std.log.err("Failed to initialize audio. Continuing the game without sounds.", .{});
	defer if (!headless) audio.deinit();

	utils.initDynamicIntArrayStorage();
	defer utils.deinitDynamicIntArrayStorage();

	chunk.init();
	defer chunk.deinit();

	rotation.init();
	defer rotation.deinit();

	callbacks.init();

	block_entity.init();
	defer block_entity.deinit();

	models.init();
	defer models.deinit();

	items.globalInit();
	defer items.deinit();

	if (!headless) sync.ClientSide.init();
	defer if (!headless) sync.ClientSide.deinit();

	if (!headless) itemdrop.ItemDropRenderer.init();
	defer if (!headless) itemdrop.ItemDropRenderer.deinit();

	assets.init();

	if (!headless) blocks.meshes.init();
	defer if (!headless) blocks.meshes.deinit();

	if (!headless) renderer.init();
	defer if (!headless) renderer.deinit();

	network.init() catch @panic("Failed to initialize network");
	defer network.deinit();

	if (!headless) entity.ClientEntityManager.init();
	defer if (!headless) entity.ClientEntityManager.deinit();

	if (!headless) gui.init();
	defer if (!headless) gui.deinit();

	if (!headless) particles.ParticleManager.init();
	defer if (!headless) particles.ParticleManager.deinit();

	server.terrain.globalInit();
	defer server.terrain.globalDeinit();

	if (headless) {
		server.startFromExistingThread(settings.launchConfig.autoEnterWorld, null);
	} else {
		clientMain();
	}
}

pub fn clientMain() void { // MARK: clientMain()
	switch (settings.storedAccount.typ) {
		.none => blk: {
			if (settings.storedAccount.data.len == 0) {
				gui.openWindow("authentication/login");
				break :blk;
			}
			var failureText: List(u8) = .init(stackAllocator);
			defer failureText.deinit();
			const accountCode = settings.storedAccount.decryptFromPassword(undefined, &failureText) catch |err| {
				std.log.err("Got error while loading Account Code: {s}", .{@errorName(err)});
				gui.openWindow("authentication/login");
				break :blk;
			};
			defer accountCode.deinit();
			if (failureText.items.len != 0) {
				std.log.warn("Encountered errors while verifying your Account. This may happen if you created your account in a future version, in which case it's fine to continue.\n{s}", .{failureText.items});
			}
			network.authentication.KeyCollection.init(accountCode);
			if (settings.playerName.len == 0) {
				gui.openWindow("change_name");
			} else if (settings.launchConfig.autoEnterWorld.len == 0) {
				gui.openWindow("main");
			} else {
				// Speed up the dev process by entering the world directly.
				gui.windowlist.save_selection.openWorld(settings.launchConfig.autoEnterWorld);
			}
		},
		else => {
			gui.openWindow("authentication/unlock");
		},
	}

	const c = Window.c;
	Window.GLFWCallbacks.framebufferSize(undefined, Window.width, Window.height);
	var lastBeginRendering = timestamp();

	audio.setMusic("cubyz:TotalDemented/Cubyz");

	while (c.glfwWindowShouldClose(Window.window) == 0) {
		heap.GarbageCollection.syncPoint();
		const isHidden = c.glfwGetWindowAttrib(Window.window, c.GLFW_ICONIFIED) == c.GLFW_TRUE;
		if (!isHidden) {
			c.glfwSwapBuffers(Window.window);
			// Clear may also wait on vsync, so it's done before handling events:
			gui.windowlist.gpu_performance_measuring.startQuery(.screenbuffer_clear);
			c.glDepthFunc(c.GL_LESS);
			c.glDepthMask(c.GL_TRUE);
			c.glDisable(c.GL_SCISSOR_TEST);
			c.glClearColor(0.5, 1, 1, 1);
			c.glClear(c.GL_DEPTH_BUFFER_BIT | c.GL_STENCIL_BUFFER_BIT | c.GL_COLOR_BUFFER_BIT);
			gui.windowlist.gpu_performance_measuring.stopQuery();
		} else {
			io.sleep(.fromMilliseconds(16), .awake) catch {};
		}

		const endRendering = timestamp();
		const frameTime = @as(f64, @floatFromInt(endRendering.nanoseconds -% lastBeginRendering.nanoseconds))/1.0e9;
		lastFrameTime.store(frameTime, .monotonic);

		if (settings.fpsCap) |fpsCap| {
			const minFrameTime = @divFloor(1000*1000*1000, fpsCap);
			const sleep = @min(minFrameTime, @max(0, minFrameTime - (endRendering.nanoseconds -% lastBeginRendering.nanoseconds)));
			if (builtin.os.tag == .windows and minFrameTime < 20_000_000) { // Windows can oversleep a lot, so we waste power instead
				const targetTime = timestamp().addDuration(.fromNanoseconds(sleep));
				while (timestamp().durationTo(targetTime).nanoseconds > 0) {}
			} else {
				io.sleep(.fromNanoseconds(sleep), .awake) catch {};
			}
		}
		const begin = timestamp();
		const deltaTime = @as(f64, @floatFromInt(begin.nanoseconds -% lastBeginRendering.nanoseconds))/1.0e9;
		lastDeltaTime.store(deltaTime, .monotonic);
		lastBeginRendering = begin;

		Window.handleEvents(deltaTime);

		file_monitor.handleEvents();

		if (game.world != null) { // Update the game
			game.update(deltaTime);
		}

		if (!isHidden) {
			if (game.world != null) {
				renderer.updateFov(settings.fov);
				renderer.render(game.Player.getEyePosBlocking(), deltaTime);
			} else {
				renderer.updateFov(70.0);
				renderer.MenuBackGround.render(deltaTime);
			}
			// Render the GUI
			gui.windowlist.gpu_performance_measuring.startQuery(.gui);
			gui.updateAndRenderGui();
			gui.windowlist.gpu_performance_measuring.stopQuery();
		}

		if (shouldExitToMenu.load(.monotonic)) {
			shouldExitToMenu.store(false, .monotonic);
			Window.setMouseGrabbed(false);
			if (game.world) |world| {
				world.deinit();
				game.world = null;
			}
			gui.openWindow("main");
			audio.setMusic("cubyz:TotalDemented/Cubyz");
		}
	}

	if (game.world) |world| {
		world.deinit();
		game.world = null;
	}
}

/// std.testing.refAllDeclsRecursive, but ignores C imports (by name)
pub fn refAllDeclsRecursiveExceptCImports(comptime T: type) void {
	if (!@import("builtin").is_test) return;
	inline for (comptime std.meta.declarations(T)) |decl| blk: {
		if (comptime std.mem.eql(u8, decl.name, "c")) continue;
		if (comptime std.mem.eql(u8, decl.name, "hbft")) break :blk;
		if (comptime std.mem.eql(u8, decl.name, "stb_image")) break :blk;
		// TODO: Remove this after Zig removes Managed hashmap PixelGuys/Cubyz#308
		if (comptime std.mem.eql(u8, decl.name, "Managed")) continue;
		if (@TypeOf(@field(T, decl.name)) == type) {
			switch (@typeInfo(@field(T, decl.name))) {
				.@"struct", .@"enum", .@"union", .@"opaque" => refAllDeclsRecursiveExceptCImports(@field(T, decl.name)),
				else => {},
			}
		}
		_ = &@field(T, decl.name);
	}
}

test "abc" {
	@setEvalBranchQuota(1000000);
	refAllDeclsRecursiveExceptCImports(@This());
	_ = @import("zon.zig");
}

```

`src/meta.zig`:

```zig
const std = @import("std");

// MARK: functionPtrCast()
fn CastFunctionSelfToConstAnyopaqueType(Fn: type) type {
	var typeInfo = @typeInfo(Fn);
	var params = typeInfo.@"fn".params[0..typeInfo.@"fn".params.len].*;
	const isMutablePointer = @typeInfo(params[0].type.?) == .pointer and !@typeInfo(params[0].type.?).pointer.is_const;
	if (@sizeOf(params[0].type.?) != @sizeOf(*const anyopaque) or @alignOf(params[0].type.?) != @alignOf(*const anyopaque) or isMutablePointer) {
		@compileError(std.fmt.comptimePrint("Cannot convert {} to *const anyopaque", .{params[0].type.?}));
	}
	params[0].type = *const anyopaque;
	typeInfo.@"fn".params = params[0..];
	return @Type(typeInfo);
}
/// Turns the first parameter into a *const anyopaque
pub fn castFunctionSelfToConstAnyopaque(function: anytype) *const CastFunctionSelfToConstAnyopaqueType(@TypeOf(function)) {
	return @ptrCast(&function);
}

// MARK: functionPtrCast()
fn CastFunctionSelfToAnyopaqueType(Fn: type) type {
	var typeInfo = @typeInfo(Fn);
	var params = typeInfo.@"fn".params[0..typeInfo.@"fn".params.len].*;
	if (@sizeOf(params[0].type.?) != @sizeOf(*anyopaque) or @alignOf(params[0].type.?) != @alignOf(*anyopaque)) {
		@compileError(std.fmt.comptimePrint("Cannot convert {} to *anyopaque", .{params[0].type.?}));
	}
	params[0].type = *anyopaque;
	typeInfo.@"fn".params = params[0..];
	return @Type(typeInfo);
}
/// Turns the first parameter into a *anyopaque
pub fn castFunctionSelfToAnyopaque(function: anytype) *const CastFunctionSelfToAnyopaqueType(@TypeOf(function)) {
	return @ptrCast(&function);
}

fn CastFunctionReturnToAnyopaqueType(Fn: type) type {
	var typeInfo = @typeInfo(Fn);
	if (@sizeOf(typeInfo.@"fn".return_type.?) != @sizeOf(*anyopaque) or @alignOf(typeInfo.@"fn".return_type.?) != @alignOf(*anyopaque) or @typeInfo(typeInfo.@"fn".return_type.?) == .optional) {
		@compileError(std.fmt.comptimePrint("Cannot convert {} to *anyopaque", .{typeInfo.@"fn".return_type.?}));
	}
	typeInfo.@"fn".return_type = *anyopaque;
	return @Type(typeInfo);
}

fn CastFunctionReturnToOptionalAnyopaqueType(Fn: type) type {
	var typeInfo = @typeInfo(Fn);
	if (@sizeOf(typeInfo.@"fn".return_type.?) != @sizeOf(?*anyopaque) or @alignOf(typeInfo.@"fn".return_type.?) != @alignOf(?*anyopaque) or @typeInfo(typeInfo.@"fn".return_type.?) != .optional) {
		@compileError(std.fmt.comptimePrint("Cannot convert {} to ?*anyopaque", .{typeInfo.@"fn".return_type.?}));
	}
	typeInfo.@"fn".return_type = ?*anyopaque;
	return @Type(typeInfo);
}
/// Turns the return parameter into a *anyopaque
pub fn castFunctionReturnToAnyopaque(function: anytype) *const CastFunctionReturnToAnyopaqueType(@TypeOf(function)) {
	return @ptrCast(&function);
}
pub fn castFunctionReturnToOptionalAnyopaque(function: anytype) *const CastFunctionReturnToOptionalAnyopaqueType(@TypeOf(function)) {
	return @ptrCast(&function);
}

```

`src/migrations.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ZonElement = @import("zon.zig").ZonElement;
const Palette = @import("assets.zig").Palette;
const Assets = main.assets.Assets;

var blockMigrations: std.StringHashMapUnmanaged([]const u8) = .{};
var itemMigrations: std.StringHashMapUnmanaged([]const u8) = .{};
var biomeMigrations: std.StringHashMapUnmanaged([]const u8) = .{};

const MigrationType = enum {
	block,
	item,
	biome,
};

pub fn registerAll(comptime typ: MigrationType, migrations: *Assets.AddonNameToZonMap) void {
	std.log.info("Registering {s} migrations for {} addons", .{@tagName(typ), migrations.count()});
	const collection = switch (typ) {
		.block => &blockMigrations,
		.item => &itemMigrations,
		.biome => &biomeMigrations,
	};
	var migrationIterator = migrations.iterator();
	while (migrationIterator.next()) |migration| {
		register(typ, collection, migration.key_ptr.*, migration.value_ptr.*);
	}
}

fn register(
	comptime typ: MigrationType,
	collection: *std.StringHashMapUnmanaged([]const u8),
	addonName: []const u8,
	migrationZon: ZonElement,
) void {
	if (migrationZon != .array) {
		if (migrationZon == .object and migrationZon.object.count() == 0) {
			std.log.warn("Skipping empty {s} migration data structure from addon {s}", .{@tagName(typ), addonName});
			return;
		}
		std.log.err("Skipping incorrect {s} migration data structure from addon {s}", .{@tagName(typ), addonName});
		return;
	}
	if (migrationZon.array.items.len == 0) {
		std.log.warn("Skipping empty {s} migration data structure from addon {s}", .{@tagName(typ), addonName});
		return;
	}

	for (migrationZon.array.items) |migration| {
		const oldZonOpt = migration.get(?[]const u8, "old", null);
		const newZonOpt = migration.get(?[]const u8, "new", null);

		if (oldZonOpt == null or newZonOpt == null) {
			std.log.err("Skipping incomplete migration in {s} migrations: '{s}:{s}' -> '{s}:{s}'", .{@tagName(typ), addonName, oldZonOpt orelse "<null>", addonName, newZonOpt orelse "<null>"});
			continue;
		}

		const oldZon = oldZonOpt orelse unreachable;
		const newZon = newZonOpt orelse unreachable;

		if (std.mem.eql(u8, oldZon, newZon)) {
			std.log.err("Skipping identity migration in {s} migrations: '{s}:{s}' -> '{s}:{s}'", .{@tagName(typ), addonName, oldZon, addonName, newZon});
			continue;
		}

		const oldAssetId = std.fmt.allocPrint(main.worldArena.allocator, "{s}:{s}", .{addonName, oldZon}) catch unreachable;
		const result = collection.getOrPut(main.worldArena.allocator, oldAssetId) catch unreachable;

		if (result.found_existing) {
			std.log.err("Skipping name collision in {s} migration: '{s}' -> '{s}:{s}'", .{@tagName(typ), oldAssetId, addonName, newZon});
			const existingMigration = collection.get(oldAssetId) orelse unreachable;
			std.log.err("Already mapped to '{s}'", .{existingMigration});

			main.worldArena.free(oldAssetId);
		} else {
			const newAssetId = std.fmt.allocPrint(main.worldArena.allocator, "{s}:{s}", .{addonName, newZon}) catch unreachable;

			result.key_ptr.* = oldAssetId;
			result.value_ptr.* = newAssetId;
			std.log.info("Registered {s} migration: '{s}' -> '{s}'", .{@tagName(typ), oldAssetId, newAssetId});
		}
	}
}

pub fn applySingle(comptime typ: MigrationType, assetName: []const u8) []const u8 {
	const migrations = switch (typ) {
		.block => blockMigrations,
		.item => itemMigrations,
		.biome => biomeMigrations,
	};

	const newAssetName = migrations.get(assetName) orelse return assetName;
	std.log.info("Migrating {s} {s} -> {s}", .{@tagName(typ), assetName, newAssetName});
	return newAssetName;
}

pub fn apply(comptime typ: MigrationType, palette: *Palette) void {
	const migrations = switch (typ) {
		.block => blockMigrations,
		.item => itemMigrations,
		.biome => biomeMigrations,
	};
	std.log.info("Applying {} migrations to {s} palette", .{migrations.count(), @tagName(typ)});

	for (palette.palette.items, 0..) |assetName, i| {
		const newAssetName = migrations.get(assetName) orelse continue;
		std.log.info("Migrating {s} {s} -> {s}", .{@tagName(typ), assetName, newAssetName});
		palette.replaceEntry(i, newAssetName);
	}
}

pub fn reset() void {
	biomeMigrations = .{};
	blockMigrations = .{};
	itemMigrations = .{};
}

```

`src/models.zig`:

```zig
const std = @import("std");

const chunk = @import("chunk.zig");
const Neighbor = chunk.Neighbor;
const graphics = @import("graphics.zig");
const main = @import("main");
const vec = @import("vec.zig");
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;
const Vec3d = vec.Vec3d;
const Vec2f = vec.Vec2f;
const Mat4f = vec.Mat4f;

const FaceData = main.renderer.chunk_meshing.FaceData;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const Box = main.game.collision.Box;

var quadSSBO: graphics.SSBO = undefined;

pub const QuadInfo = extern struct {
	normal: [3]f32 align(16),
	corners: [4][3]f32,
	cornerUV: [4][2]f32 align(8),
	textureSlot: u32,
	opaqueInLod: u32 = 0,

	pub fn normalVec(self: QuadInfo) Vec3f {
		return self.normal;
	}
	pub fn cornerVec(self: QuadInfo, i: usize) Vec3f {
		return self.corners[i];
	}
	pub fn cornerUvVec(self: QuadInfo, i: usize) Vec2f {
		return self.cornerUV[i];
	}
};

const LightSample = struct {
	weights: [4]u16,
	offset: Vec3i,
};

const ExtraQuadInfo = struct {
	faceNeighbor: ?Neighbor,
	isFullQuad: bool,
	lightSampleListForAxisAlignedModels: []LightSample,
	hasOnlyCornerVertices: bool,
	alignedNormalDirection: ?Neighbor,
};

const gridSize = 4096;
const collisionGridSize = 16;
const CollisionGridInteger = std.meta.Int(.unsigned, collisionGridSize);

fn snapToGrid(x: anytype) @TypeOf(x) {
	const T = @TypeOf(x);
	const Vec = @Vector(x.len, std.meta.Child(T));
	const int = @as(@Vector(x.len, i32), @intFromFloat(std.math.round(@as(Vec, x)*@as(Vec, @splat(gridSize)))));
	return @as(Vec, @floatFromInt(int))/@as(Vec, @splat(gridSize));
}

const Triangle = struct {
	vertex: [3]usize,
	normal: usize,
	uvs: [3]usize,
};

const Quad = struct {
	vertex: [4]usize,
	normal: usize,
	uvs: [4]usize,
};

pub const ModelIndex = enum(u32) {
	_,

	pub fn model(self: ModelIndex) *const Model {
		return &models.items()[@intFromEnum(self)];
	}
	pub fn add(self: ModelIndex, offset: u32) ModelIndex {
		return @enumFromInt(@intFromEnum(self) + offset);
	}
};

pub const QuadIndex = enum(u16) {
	_,

	pub fn quadInfo(self: QuadIndex) *const QuadInfo {
		return &quads.items[@intFromEnum(self)];
	}

	pub fn extraQuadInfo(self: QuadIndex) *const ExtraQuadInfo {
		return &extraQuadInfos.items[@intFromEnum(self)];
	}
};

pub const Model = struct {
	min: Vec3f,
	max: Vec3f,
	internalQuads: []QuadIndex,
	neighborFacingQuads: [6][]QuadIndex,
	isNeighborOccluded: [6]bool,
	allNeighborsOccluded: bool,
	noNeighborsOccluded: bool,
	hasNeighborFacingQuads: bool,
	collision: []Box,

	fn getFaceNeighbor(quad: *const QuadInfo) ?chunk.Neighbor {
		var allZero: @Vector(3, bool) = .{true, true, true};
		var allOne: @Vector(3, bool) = .{true, true, true};
		for (quad.corners) |corner| {
			allZero = allZero & (corner == @as(Vec3f, @splat(0)));
			allOne = allOne & (corner == @as(Vec3f, @splat(1)));
		}
		if (allZero[0]) return .dirNegX;
		if (allZero[1]) return .dirNegY;
		if (allZero[2]) return .dirDown;
		if (allOne[0]) return .dirPosX;
		if (allOne[1]) return .dirPosY;
		if (allOne[2]) return .dirUp;
		return null;
	}

	fn fullyOccludesNeighbor(quad: *const QuadInfo) bool {
		var zeroes: @Vector(3, u32) = .{0, 0, 0};
		var ones: @Vector(3, u32) = .{0, 0, 0};
		for (quad.corners) |corner| {
			zeroes += @select(u32, corner == @as(Vec3f, @splat(0)), .{1, 1, 1}, .{0, 0, 0});
			ones += @select(u32, corner == @as(Vec3f, @splat(1)), .{1, 1, 1}, .{0, 0, 0});
		}
		// For full coverage there will 2 ones and 2 zeroes for two components, while the other one is constant.
		const hasTwoZeroes = zeroes == @Vector(3, u32){2, 2, 2};
		const hasTwoOnes = ones == @Vector(3, u32){2, 2, 2};
		return @popCount(@as(u3, @bitCast(hasTwoOnes))) == 2 and @popCount(@as(u3, @bitCast(hasTwoZeroes))) == 2;
	}

	pub fn init(quadInfos: []const QuadInfo) ModelIndex {
		const adjustedQuads = main.stackAllocator.alloc(QuadInfo, quadInfos.len);
		defer main.stackAllocator.free(adjustedQuads);
		for (adjustedQuads, quadInfos) |*dest, *src| {
			dest.* = src.*;
			// Snap all values to a fixed point grid to make comparisons more accurate.
			for (&dest.corners) |*corner| {
				corner.* = snapToGrid(corner.*);
			}
			for (&dest.cornerUV) |*uv| {
				uv.* = snapToGrid(uv.*);
			}
			// Snap the normals as well:
			dest.normal = snapToGrid(dest.normal);
		}
		const modelIndex: ModelIndex = @enumFromInt(models.len);
		const self = models.addOne();
		var amounts: [6]usize = .{0, 0, 0, 0, 0, 0};
		var internalAmount: usize = 0;
		self.min = .{1, 1, 1};
		self.max = .{0, 0, 0};
		self.isNeighborOccluded = @splat(false);
		for (adjustedQuads) |*quad| {
			for (quad.corners) |corner| {
				self.min = @min(self.min, @as(Vec3f, corner));
				self.max = @max(self.max, @as(Vec3f, corner));
			}
			if (getFaceNeighbor(quad)) |neighbor| {
				amounts[neighbor.toInt()] += 1;
			} else {
				internalAmount += 1;
			}
		}

		for (0..6) |i| {
			self.neighborFacingQuads[i] = main.globalAllocator.alloc(QuadIndex, amounts[i]);
		}
		self.internalQuads = main.globalAllocator.alloc(QuadIndex, internalAmount);

		var indices: [6]usize = .{0, 0, 0, 0, 0, 0};
		var internalIndex: usize = 0;
		for (adjustedQuads) |_quad| {
			var quad = _quad;
			if (getFaceNeighbor(&quad)) |neighbor| {
				for (&quad.corners) |*corner| {
					corner.* = @as(Vec3f, corner.*) - @as(Vec3f, quad.normal);
				}
				const quadIndex = addQuad(quad) catch continue;
				self.neighborFacingQuads[neighbor.toInt()][indices[neighbor.toInt()]] = quadIndex;
				indices[neighbor.toInt()] += 1;
			} else {
				const quadIndex = addQuad(quad) catch continue;
				self.internalQuads[internalIndex] = quadIndex;
				internalIndex += 1;
			}
		}
		for (0..6) |i| {
			self.neighborFacingQuads[i] = main.globalAllocator.realloc(self.neighborFacingQuads[i], indices[i]);
		}
		self.internalQuads = main.globalAllocator.realloc(self.internalQuads, internalIndex);
		self.hasNeighborFacingQuads = false;
		self.allNeighborsOccluded = true;
		self.noNeighborsOccluded = true;
		for (0..6) |neighbor| {
			for (self.neighborFacingQuads[neighbor]) |quad| {
				if (fullyOccludesNeighbor(quad.quadInfo())) {
					self.isNeighborOccluded[neighbor] = true;
				}
			}
			self.hasNeighborFacingQuads = self.hasNeighborFacingQuads or self.neighborFacingQuads[neighbor].len != 0;
			self.allNeighborsOccluded = self.allNeighborsOccluded and self.isNeighborOccluded[neighbor];
			self.noNeighborsOccluded = self.noNeighborsOccluded and !self.isNeighborOccluded[neighbor];
		}
		generateCollision(self, adjustedQuads);
		return modelIndex;
	}

	fn edgeInterp(y: f32, x0: f32, y0: f32, x1: f32, y1: f32) f32 {
		if (y1 == y0) return x0;
		return x0 + (x1 - x0)*(y - y0)/(y1 - y0);
	}

	fn solveDepth(normal: Vec3f, v0: Vec3f, xIndex: usize, yIndex: usize, zIndex: usize, u: f32, v: f32) f32 {
		const nX = @as([3]f32, normal)[xIndex];
		const nY = @as([3]f32, normal)[yIndex];
		const nZ = @as([3]f32, normal)[zIndex];

		const planeOffset = -vec.dot(v0, normal);

		return (-(nX*u + nY*v + planeOffset))/nZ;
	}

	fn rasterize(triangle: [3]Vec3f, grid: *[collisionGridSize][collisionGridSize]CollisionGridInteger, normal: Vec3f) void {
		var xIndex: usize = undefined;
		var yIndex: usize = undefined;
		var zIndex: usize = undefined;

		const v0 = triangle[0]*@as(Vec3f, @splat(@floatFromInt(collisionGridSize)));
		const v1 = triangle[1]*@as(Vec3f, @splat(@floatFromInt(collisionGridSize)));
		const v2 = triangle[2]*@as(Vec3f, @splat(@floatFromInt(collisionGridSize)));

		const absNormal = @abs(normal);
		if (absNormal[0] >= absNormal[1] and absNormal[0] >= absNormal[2]) {
			xIndex = 1;
			yIndex = 2;
			zIndex = 0;
		} else if (absNormal[1] >= absNormal[0] and absNormal[1] >= absNormal[2]) {
			xIndex = 0;
			yIndex = 2;
			zIndex = 1;
		} else {
			xIndex = 0;
			yIndex = 1;
			zIndex = 2;
		}

		const min: Vec3f = @min(v0, v1, v2);
		const max: Vec3f = @max(v0, v1, v2);

		const voxelMin: Vec3i = @max(@as(Vec3i, @intFromFloat(@floor(min))), @as(Vec3i, @splat(0)));
		const voxelMax: Vec3i = @max(@as(Vec3i, @intFromFloat(@ceil(max))), @as(Vec3i, @splat(0)));

		var p0 = Vec2f{@as([3]f32, v0)[xIndex], @as([3]f32, v0)[yIndex]};
		var p1 = Vec2f{@as([3]f32, v1)[xIndex], @as([3]f32, v1)[yIndex]};
		var p2 = Vec2f{@as([3]f32, v2)[xIndex], @as([3]f32, v2)[yIndex]};

		if (p0[1] > p1[1]) {
			std.mem.swap(Vec2f, &p0, &p1);
		}
		if (p0[1] > p2[1]) {
			std.mem.swap(Vec2f, &p0, &p2);
		}
		if (p1[1] > p2[1]) {
			std.mem.swap(Vec2f, &p1, &p2);
		}

		for (@intCast(@as([3]i32, voxelMin)[yIndex])..@intCast(@as([3]i32, voxelMax)[yIndex])) |y| {
			if (y >= collisionGridSize) continue;
			const yf = std.math.clamp(@as(f32, @floatFromInt(y)) + 0.5, @as([3]f32, min)[yIndex], @as([3]f32, max)[yIndex]);
			var xa: f32 = undefined;
			var xb: f32 = undefined;
			if (yf < p1[1]) {
				xa = edgeInterp(yf, p0[0], p0[1], p1[0], p1[1]);
				xb = edgeInterp(yf, p0[0], p0[1], p2[0], p2[1]);
			} else {
				xa = edgeInterp(yf, p1[0], p1[1], p2[0], p2[1]);
				xb = edgeInterp(yf, p0[0], p0[1], p2[0], p2[1]);
			}

			const xStart: f32 = @min(xa, xb);
			const xEnd: f32 = @max(xa, xb);

			const voxelXStart: usize = @intFromFloat(@max(@floor(xStart), 0.0));
			const voxelXEnd: usize = @intFromFloat(@max(@ceil(xEnd), 0.0));

			for (voxelXStart..voxelXEnd) |x| {
				if (x < 0 or x >= collisionGridSize) continue;
				const xf = std.math.clamp(@as(f32, @floatFromInt(x)) + 0.5, xStart, xEnd);

				const zf = solveDepth(normal, v0, xIndex, yIndex, zIndex, xf, yf);
				if (zf < 0.0) continue;
				const z: usize = @intFromFloat(zf);

				if (z >= collisionGridSize) continue;

				const pos: [3]usize = .{x, y, z};
				var realPos: [3]usize = undefined;
				realPos[xIndex] = pos[0];
				realPos[yIndex] = pos[1];
				realPos[zIndex] = pos[2];
				grid[realPos[0]][realPos[1]] |= @as(CollisionGridInteger, 1) << @intCast(realPos[2]);
			}
		}
	}

	fn generateCollision(self: *Model, modelQuads: []QuadInfo) void {
		var hollowGrid: [collisionGridSize][collisionGridSize]CollisionGridInteger = @splat(@splat(0));
		const voxelSize: Vec3f = @splat(1.0/@as(f32, collisionGridSize));

		for (modelQuads) |quad| {
			var shift = Vec3f{0, 0, 0};
			inline for (0..3) |i| {
				if (@abs(quad.normalVec()[i]) == 1.0 and @floor(quad.corners[0][i]*collisionGridSize) == quad.corners[0][i]*collisionGridSize) {
					shift = quad.normalVec()*voxelSize*@as(Vec3f, @splat(0.5));
				}
			}
			const triangle1: [3]Vec3f = .{
				quad.cornerVec(0) - shift,
				quad.cornerVec(1) - shift,
				quad.cornerVec(2) - shift,
			};
			const triangle2: [3]Vec3f = .{
				quad.cornerVec(1) - shift,
				quad.cornerVec(2) - shift,
				quad.cornerVec(3) - shift,
			};

			rasterize(triangle1, &hollowGrid, quad.normalVec());
			rasterize(triangle2, &hollowGrid, quad.normalVec());
		}

		const allOnes = ~@as(CollisionGridInteger, 0);
		var grid: [collisionGridSize][collisionGridSize]CollisionGridInteger = @splat(@splat(allOnes));

		var floodfillQueue = main.utils.CircularBufferQueue(struct { x: usize, y: usize, val: CollisionGridInteger }).init(main.stackAllocator, 1024);
		defer floodfillQueue.deinit();

		for (0..collisionGridSize) |x| {
			for (0..collisionGridSize) |y| {
				var val = 1 | @as(CollisionGridInteger, 1) << (@bitSizeOf(CollisionGridInteger) - 1);
				if (x == 0 or x == collisionGridSize - 1 or y == 0 or y == collisionGridSize - 1) val = allOnes;

				floodfillQueue.pushBack(.{.x = x, .y = y, .val = val});
			}
		}

		while (floodfillQueue.popFront()) |elem| {
			const oldValue = grid[elem.x][elem.y];
			const newValue = oldValue & ~(~hollowGrid[elem.x][elem.y] & elem.val);
			if (oldValue == newValue) continue;
			grid[elem.x][elem.y] = newValue;

			if (elem.x != 0) floodfillQueue.pushBack(.{.x = elem.x - 1, .y = elem.y, .val = ~newValue});
			if (elem.x != collisionGridSize - 1) floodfillQueue.pushBack(.{.x = elem.x + 1, .y = elem.y, .val = ~newValue});
			if (elem.y != 0) floodfillQueue.pushBack(.{.x = elem.x, .y = elem.y - 1, .val = ~newValue});
			if (elem.y != collisionGridSize - 1) floodfillQueue.pushBack(.{.x = elem.x, .y = elem.y + 1, .val = ~newValue});
			floodfillQueue.pushBack(.{.x = elem.x, .y = elem.y, .val = ~newValue << 1 | ~newValue >> 1});
		}

		var collision: main.List(Box) = .init(main.globalAllocator);

		for (0..collisionGridSize) |x| {
			for (0..collisionGridSize) |y| {
				while (grid[x][y] != 0) {
					const startZ = @ctz(grid[x][y]);
					const height = @min(@bitSizeOf(CollisionGridInteger) - startZ, @ctz(~grid[x][y] >> @intCast(startZ)));
					const mask = allOnes << @intCast(startZ) & ~((allOnes << 1) << @intCast(height + startZ - 1));

					const boxMin = Vec3i{@intCast(x), @intCast(y), startZ};
					var boxMax = Vec3i{@intCast(x + 1), @intCast(y + 1), startZ + height};

					while (canExpand(&grid, boxMin, boxMax, .x, mask)) boxMax[0] += 1;
					while (canExpand(&grid, boxMin, boxMax, .y, mask)) boxMax[1] += 1;
					disableAll(&grid, boxMin, boxMax, mask);

					const min = @as(Vec3f, @floatFromInt(boxMin))/@as(Vec3f, @splat(collisionGridSize));
					const max = @as(Vec3f, @floatFromInt(boxMax))/@as(Vec3f, @splat(collisionGridSize));

					collision.append(Box{.min = min, .max = max});
				}
			}
		}

		self.collision = collision.toOwnedSlice();
	}

	fn allTrue(grid: *const [collisionGridSize][collisionGridSize]CollisionGridInteger, min: Vec3i, max: Vec3i, mask: CollisionGridInteger) bool {
		if (max[0] > collisionGridSize or max[1] > collisionGridSize) {
			return false;
		}
		for (@intCast(min[0])..@intCast(max[0])) |x| {
			for (@intCast(min[1])..@intCast(max[1])) |y| {
				if ((grid[x][y] & mask) != mask) {
					return false;
				}
			}
		}
		return true;
	}

	fn disableAll(grid: *[collisionGridSize][collisionGridSize]CollisionGridInteger, min: Vec3i, max: Vec3i, mask: CollisionGridInteger) void {
		for (@intCast(min[0])..@intCast(max[0])) |x| {
			for (@intCast(min[1])..@intCast(max[1])) |y| {
				grid[x][y] &= ~mask;
			}
		}
	}

	fn canExpand(grid: *const [collisionGridSize][collisionGridSize]CollisionGridInteger, min: Vec3i, max: Vec3i, dir: enum { x, y }, mask: CollisionGridInteger) bool {
		return switch (dir) {
			.x => allTrue(grid, Vec3i{max[0], min[1], min[2]}, Vec3i{max[0] + 1, max[1], max[2]}, mask),
			.y => allTrue(grid, Vec3i{min[0], max[1], min[2]}, Vec3i{max[0], max[1] + 1, max[2]}, mask),
		};
	}

	fn addVert(vert: Vec3f, vertList: *main.List(Vec3f)) usize {
		const ind = for (vertList.*.items, 0..) |vertex, index| {
			if (vertex == vert) break index;
		} else vertList.*.items.len;

		if (ind == vertList.*.items.len) {
			vertList.*.append(vert);
		}

		return ind;
	}

	pub fn loadModel(data: []const u8) ModelIndex {
		const quadInfos = loadRawModelDataFromObj(main.stackAllocator, data);
		defer main.stackAllocator.free(quadInfos);
		for (quadInfos) |*quad| {
			var minUv: Vec2f = @splat(std.math.inf(f32));
			for (0..4) |i| {
				quad.cornerUV[i] = @as(Vec2f, quad.cornerUV[i])*@as(Vec2f, @splat(4));
				minUv = @min(minUv, @as(Vec2f, quad.cornerUV[i]));
			}
			minUv = @floor(minUv);
			quad.textureSlot = @as(u32, @intFromFloat(minUv[1]))*4 + @as(u32, @intFromFloat(minUv[0]));

			if (minUv[0] < 0 or minUv[0] > 4 or minUv[1] < 0 or minUv[1] > 4) {
				std.log.err("Uv value for model is outside of 0-1 range", .{});
			}

			for (0..4) |i| {
				quad.cornerUV[i] = @as(Vec2f, quad.cornerUV[i]) - minUv;
			}
		}
		return Model.init(quadInfos);
	}

	pub fn loadRawModelDataFromObj(allocator: main.heap.NeverFailingAllocator, data: []const u8) []QuadInfo {
		var vertices = main.List(Vec3f).init(main.stackAllocator);
		defer vertices.deinit();

		var normals = main.List(Vec3f).init(main.stackAllocator);
		defer normals.deinit();

		var uvs = main.List(Vec2f).init(main.stackAllocator);
		defer uvs.deinit();

		var tris = main.List(Triangle).init(main.stackAllocator);
		defer tris.deinit();

		var quadFaces = main.List(Quad).init(main.stackAllocator);
		defer quadFaces.deinit();

		var splitIterator = std.mem.splitScalar(u8, data, '\n');
		while (splitIterator.next()) |lineUntrimmed| {
			if (lineUntrimmed.len < 3)
				continue;

			var line = lineUntrimmed;
			if (line[line.len - 1] == '\r') {
				line = line[0 .. line.len - 1];
			}

			if (line[0] == '#')
				continue;

			if (std.mem.eql(u8, line[0..2], "v ")) {
				var coordsIter = std.mem.splitScalar(u8, line[2..], ' ');
				var coords: [3]f32 = undefined;
				var i: usize = 0;
				while (coordsIter.next()) |coord| : (i += 1) {
					coords[i] = std.fmt.parseFloat(f32, coord) catch |e| blk: {
						std.log.err("Failed parsing {s} into float: {any}", .{coord, e});
						break :blk 0;
					};
				}
				vertices.append(coords);
			} else if (std.mem.eql(u8, line[0..3], "vn ")) {
				var coordsIter = std.mem.splitScalar(u8, line[3..], ' ');
				var norm: [3]f32 = undefined;
				var i: usize = 0;
				while (coordsIter.next()) |coord| : (i += 1) {
					norm[i] = std.fmt.parseFloat(f32, coord) catch |e| blk: {
						std.log.err("Failed parsing {s} into float: {any}", .{coord, e});
						break :blk 0;
					};
				}
				normals.append(norm);
			} else if (std.mem.eql(u8, line[0..3], "vt ")) {
				var coordsIter = std.mem.splitScalar(u8, line[3..], ' ');
				var uv: [2]f32 = undefined;
				var i: usize = 0;
				while (coordsIter.next()) |coord| : (i += 1) {
					uv[i] = std.fmt.parseFloat(f32, coord) catch |e| blk: {
						std.log.err("Failed parsing {s} into float: {any}", .{coord, e});
						break :blk 0;
					};
				}
				uvs.append(uv);
			} else if (std.mem.eql(u8, line[0..2], "f ")) {
				var coordsIter = std.mem.splitScalar(u8, line[2..], ' ');
				var faceData: [3][4]usize = undefined;
				var i: usize = 0;
				var failed = false;
				while (coordsIter.next()) |vertex| : (i += 1) {
					if (i >= 4) {
						failed = true;
						std.log.err("More than 4 verticies in a face", .{});
						break;
					}
					var d = std.mem.splitScalar(u8, vertex, '/');
					var j: usize = 0;
					if (std.mem.count(u8, vertex, "/") != 2 or std.mem.count(u8, vertex, "//") != 0) {
						failed = true;
						std.log.err("Failed loading face {s}. Each vertex must use vertex/uv/normal", .{line});
						break;
					}
					while (d.next()) |value| : (j += 1) {
						faceData[j][i] = std.fmt.parseUnsigned(usize, value, 10) catch |e| blk: {
							std.log.err("Failed parsing {s} into uint: {any}", .{value, e});
							break :blk 1;
						};
						faceData[j][i] -= 1;
					}
				}
				if (!failed) {
					switch (i) {
						3 => {
							tris.append(.{.vertex = faceData[0][0..3].*, .uvs = faceData[1][0..3].*, .normal = faceData[2][0]});
						},
						4 => {
							quadFaces.append(.{.vertex = faceData[0], .uvs = faceData[1], .normal = faceData[2][0]});
						},
						else => std.log.err("Failed loading face {s} with {d} vertices", .{line, i}),
					}
				}
			}
		}

		var quadInfos = main.List(QuadInfo).initCapacity(allocator, tris.items.len + quads.items.len);
		defer quadInfos.deinit();

		for (tris.items) |face| {
			const normal: Vec3f = normals.items[face.normal];

			const uvA: Vec2f = uvs.items[face.uvs[0]];
			const uvB: Vec2f = uvs.items[face.uvs[2]];
			const uvC: Vec2f = uvs.items[face.uvs[1]];

			const cornerA: Vec3f = vertices.items[face.vertex[0]];
			const cornerB: Vec3f = vertices.items[face.vertex[2]];
			const cornerC: Vec3f = vertices.items[face.vertex[1]];

			quadInfos.append(.{
				.normal = normal,
				.corners = .{cornerA, cornerB, cornerC, cornerB},
				.cornerUV = .{uvA, uvB, uvC, uvB},
				.textureSlot = 0,
			});
		}

		for (quadFaces.items) |face| {
			const normal: Vec3f = normals.items[face.normal];

			const uvA: Vec2f = uvs.items[face.uvs[1]];
			const uvB: Vec2f = uvs.items[face.uvs[0]];
			const uvC: Vec2f = uvs.items[face.uvs[2]];
			const uvD: Vec2f = uvs.items[face.uvs[3]];

			const cornerA: Vec3f = vertices.items[face.vertex[1]];
			const cornerB: Vec3f = vertices.items[face.vertex[0]];
			const cornerC: Vec3f = vertices.items[face.vertex[2]];
			const cornerD: Vec3f = vertices.items[face.vertex[3]];

			quadInfos.append(.{
				.normal = normal,
				.corners = .{cornerA, cornerB, cornerC, cornerD},
				.cornerUV = .{uvA, uvB, uvC, uvD},
				.textureSlot = 0,
			});
		}

		return quadInfos.toOwnedSlice();
	}

	fn deinit(self: *const Model) void {
		for (0..6) |i| {
			main.globalAllocator.free(self.neighborFacingQuads[i]);
		}
		main.globalAllocator.free(self.internalQuads);
		main.globalAllocator.free(self.collision);
	}

	pub fn getRawFaces(model: Model, quadList: *main.List(QuadInfo)) void {
		for (model.internalQuads) |quadIndex| {
			quadList.append(quadIndex.quadInfo().*);
		}
		for (0..6) |neighbor| {
			for (model.neighborFacingQuads[neighbor]) |quadIndex| {
				var quad = quadIndex.quadInfo().*;
				for (&quad.corners) |*corner| {
					corner.* = @as(Vec3f, corner.*) + @as(Vec3f, quad.normal);
				}
				quadList.append(quad);
			}
		}
	}

	pub fn mergeModels(modelList: []ModelIndex) ModelIndex {
		var quadList = main.List(QuadInfo).init(main.stackAllocator);
		defer quadList.deinit();
		for (modelList) |model| {
			model.model().getRawFaces(&quadList);
		}
		return Model.init(quadList.items);
	}

	pub fn transformModel(model: Model, transformFunction: anytype, transformFunctionParameters: anytype) ModelIndex {
		var quadList = main.List(QuadInfo).init(main.stackAllocator);
		defer quadList.deinit();
		model.getRawFaces(&quadList);
		for (quadList.items) |*quad| {
			@call(.auto, transformFunction, .{quad} ++ transformFunctionParameters);
		}
		return Model.init(quadList.items);
	}

	fn appendQuadsToList(quadList: []const QuadIndex, list: *main.ListUnmanaged(FaceData), allocator: NeverFailingAllocator, block: main.blocks.Block, pos: main.chunk.BlockPos, comptime backFace: bool) void {
		for (quadList) |quadIndex| {
			const texture = main.blocks.meshes.textureIndex(block, quadIndex.quadInfo().textureSlot);
			list.append(allocator, FaceData.init(texture, quadIndex, pos, backFace));
		}
	}

	pub fn appendInternalQuadsToList(self: *const Model, list: *main.ListUnmanaged(FaceData), allocator: NeverFailingAllocator, block: main.blocks.Block, pos: main.chunk.BlockPos, comptime backFace: bool) void {
		appendQuadsToList(self.internalQuads, list, allocator, block, pos, backFace);
	}

	pub fn appendNeighborFacingQuadsToList(self: *const Model, list: *main.ListUnmanaged(FaceData), allocator: NeverFailingAllocator, block: main.blocks.Block, neighbor: Neighbor, pos: main.chunk.BlockPos, comptime backFace: bool) void {
		appendQuadsToList(self.neighborFacingQuads[neighbor.toInt()], list, allocator, block, pos, backFace);
	}
};

var nameToIndex: std.StringHashMap(ModelIndex) = undefined;

pub fn getModelIndex(string: []const u8) ModelIndex {
	return nameToIndex.get(string) orelse {
		std.log.err("Couldn't find voxelModel with name: {s}.", .{string});
		return @enumFromInt(0);
	};
}

var quads: main.List(QuadInfo) = undefined;
var extraQuadInfos: main.List(ExtraQuadInfo) = undefined;
var models: main.utils.VirtualList(Model, 1 << 20) = undefined;

var quadDeduplication: std.AutoHashMap([@sizeOf(QuadInfo)]u8, QuadIndex) = undefined;

fn addQuad(info_: QuadInfo) error{Degenerate}!QuadIndex {
	var info = info_;
	if (quadDeduplication.get(std.mem.toBytes(info))) |id| {
		return id;
	}
	// Check if it's degenerate:
	var cornerEqualities: u32 = 0;
	for (0..4) |i| {
		for (i + 1..4) |j| {
			if (@reduce(.And, @as(Vec3f, info.corners[i]) == @as(Vec3f, info.corners[j]))) cornerEqualities += 1;
		}
	}
	if (cornerEqualities >= 2) return error.Degenerate; // One corner equality is fine, since then the quad degenerates to a triangle, which has a non-zero area.
	const index: QuadIndex = @enumFromInt(quads.items.len);
	if (info.opaqueInLod == 2) {
		info.opaqueInLod = 0;
	} else {
		info.opaqueInLod = @intFromBool(Model.getFaceNeighbor(&info) != null);
	}
	quads.append(info);
	quadDeduplication.put(std.mem.toBytes(info), index) catch unreachable;

	var extraQuadInfo: ExtraQuadInfo = undefined;
	extraQuadInfo.faceNeighbor = Model.getFaceNeighbor(&info);
	extraQuadInfo.isFullQuad = Model.fullyOccludesNeighbor(&info);
	{
		var zeroes: @Vector(3, u32) = .{0, 0, 0};
		var ones: @Vector(3, u32) = .{0, 0, 0};
		for (info.corners) |corner| {
			zeroes += @select(u32, corner == @as(Vec3f, @splat(0)), .{1, 1, 1}, .{0, 0, 0});
			ones += @select(u32, corner == @as(Vec3f, @splat(1)), .{1, 1, 1}, .{0, 0, 0});
		}
		const cornerValues = @reduce(.Add, zeroes) + @reduce(.Add, ones);
		extraQuadInfo.hasOnlyCornerVertices = cornerValues == 4*3;
	}
	{
		extraQuadInfo.alignedNormalDirection = null;
		if (@reduce(.And, info.normal == Vec3f{-1, 0, 0})) extraQuadInfo.alignedNormalDirection = .dirNegX;
		if (@reduce(.And, info.normal == Vec3f{1, 0, 0})) extraQuadInfo.alignedNormalDirection = .dirPosX;
		if (@reduce(.And, info.normal == Vec3f{0, -1, 0})) extraQuadInfo.alignedNormalDirection = .dirNegY;
		if (@reduce(.And, info.normal == Vec3f{0, 1, 0})) extraQuadInfo.alignedNormalDirection = .dirPosY;
		if (@reduce(.And, info.normal == Vec3f{0, 0, -1})) extraQuadInfo.alignedNormalDirection = .dirDown;
		if (@reduce(.And, info.normal == Vec3f{0, 0, 1})) extraQuadInfo.alignedNormalDirection = .dirUp;
	}

	if (extraQuadInfo.alignedNormalDirection) |normal| {
		var lightSamples: main.ListUnmanaged(LightSample) = .initCapacity(main.stackAllocator, 4*8*4);
		defer lightSamples.deinit(main.stackAllocator);

		for (0..4) |i| {
			const vertexPos: Vec3f = info.corners[i];
			const lightPos = vertexPos;
			const containingBlockPos: Vec3i = @intFromFloat(@floor(lightPos));
			const interp = std.math.clamp(lightPos - @as(Vec3f, @floatFromInt(containingBlockPos)), @as(Vec3f, @splat(0)), @as(Vec3f, @splat(1)));

			var dx: u31 = 0;
			while (dx <= 1) : (dx += 1) {
				var dy: u31 = 0;
				while (dy <= 1) : (dy += 1) {
					var dz: u31 = 0;
					while (dz <= 1) : (dz += 1) {
						var weight: f32 = 0;
						if (dx == 0) weight = 1 - interp[0] else weight = interp[0];
						if (dy == 0) weight *= 1 - interp[1] else weight *= interp[1];
						if (dz == 0) weight *= 1 - interp[2] else weight *= interp[2];
						const integerWeight: u16 = @intFromFloat(weight/4.0*256);
						if (integerWeight == 0) continue;
						var weights: [4]u16 = @splat(0);
						weights[i] = integerWeight;
						addCornerLightSamples(&lightSamples, containingBlockPos +% Vec3i{dx, dy, dz}, normal, weights);
					}
				}
			}
		}

		std.sort.insertion(LightSample, lightSamples.items, {}, struct {
			fn lessThan(_: void, a: LightSample, b: LightSample) bool {
				if (a.offset[0] < b.offset[0]) return true;
				if (a.offset[0] > b.offset[0]) return false;
				if (a.offset[1] < b.offset[1]) return true;
				if (a.offset[1] > b.offset[1]) return false;
				if (a.offset[2] < b.offset[2]) return true;
				return false;
			}
		}.lessThan);

		var deduplicatedList: main.ListUnmanaged(LightSample) = .initCapacity(main.stackAllocator, lightSamples.items.len);
		defer deduplicatedList.deinit(main.stackAllocator);

		for (lightSamples.items) |sample| {
			if (deduplicatedList.items.len != 0 and @reduce(.And, deduplicatedList.items[deduplicatedList.items.len - 1].offset == sample.offset)) {
				for (0..4) |i| {
					deduplicatedList.items[deduplicatedList.items.len - 1].weights[i] += sample.weights[i];
				}
			} else {
				deduplicatedList.appendAssumeCapacity(sample);
			}
		}

		extraQuadInfo.lightSampleListForAxisAlignedModels = main.globalArena.dupe(LightSample, deduplicatedList.items);
	}
	extraQuadInfos.append(extraQuadInfo);

	return index;
}

fn addCornerLightSamples(lightSamples: *main.ListUnmanaged(LightSample), pos: Vec3i, direction: chunk.Neighbor, weights: [4]u16) void {
	const normal: Vec3f = @floatFromInt(Vec3i{direction.relX(), direction.relY(), direction.relZ()});
	const lightPos = @as(Vec3f, @floatFromInt(pos)) + normal*@as(Vec3f, @splat(0.5)) - @as(Vec3f, @splat(0.5));
	const startPos: Vec3i = @intFromFloat(@floor(lightPos));
	var dx: i32 = 0;
	while (dx <= 1) : (dx += 1) {
		var dy: i32 = 0;
		while (dy <= 1) : (dy += 1) {
			const finalPos = startPos +% @as(Vec3i, @intCast(@abs(direction.textureX())))*@as(Vec3i, @splat(dx)) +% @as(Vec3i, @intCast(@abs(direction.textureY()*@as(Vec3i, @splat(dy)))));
			lightSamples.appendAssumeCapacity(.{.offset = finalPos, .weights = weights});
		}
	}
}

fn box(min: Vec3f, max: Vec3f, uvOffset: Vec2f) [6]QuadInfo {
	const corner000: Vec3f = .{min[0], min[1], min[2]};
	const corner001: Vec3f = .{min[0], min[1], max[2]};
	const corner010: Vec3f = .{min[0], max[1], min[2]};
	const corner011: Vec3f = .{min[0], max[1], max[2]};
	const corner100: Vec3f = .{max[0], min[1], min[2]};
	const corner101: Vec3f = .{max[0], min[1], max[2]};
	const corner110: Vec3f = .{max[0], max[1], min[2]};
	const corner111: Vec3f = .{max[0], max[1], max[2]};
	return .{
		.{
			.normal = .{-1, 0, 0},
			.corners = .{corner010, corner011, corner000, corner001},
			.cornerUV = .{uvOffset + Vec2f{1 - max[1], min[2]}, uvOffset + Vec2f{1 - max[1], max[2]}, uvOffset + Vec2f{1 - min[1], min[2]}, uvOffset + Vec2f{1 - min[1], max[2]}},
			.textureSlot = Neighbor.dirNegX.toInt(),
		},
		.{
			.normal = .{1, 0, 0},
			.corners = .{corner100, corner101, corner110, corner111},
			.cornerUV = .{uvOffset + Vec2f{min[1], min[2]}, uvOffset + Vec2f{min[1], max[2]}, uvOffset + Vec2f{max[1], min[2]}, uvOffset + Vec2f{max[1], max[2]}},
			.textureSlot = Neighbor.dirPosX.toInt(),
		},
		.{
			.normal = .{0, -1, 0},
			.corners = .{corner000, corner001, corner100, corner101},
			.cornerUV = .{uvOffset + Vec2f{min[0], min[2]}, uvOffset + Vec2f{min[0], max[2]}, uvOffset + Vec2f{max[0], min[2]}, uvOffset + Vec2f{max[0], max[2]}},
			.textureSlot = Neighbor.dirNegY.toInt(),
		},
		.{
			.normal = .{0, 1, 0},
			.corners = .{corner110, corner111, corner010, corner011},
			.cornerUV = .{uvOffset + Vec2f{1 - max[0], min[2]}, uvOffset + Vec2f{1 - max[0], max[2]}, uvOffset + Vec2f{1 - min[0], min[2]}, uvOffset + Vec2f{1 - min[0], max[2]}},
			.textureSlot = Neighbor.dirPosY.toInt(),
		},
		.{
			.normal = .{0, 0, -1},
			.corners = .{corner010, corner000, corner110, corner100},
			.cornerUV = .{uvOffset + Vec2f{min[0], 1 - max[1]}, uvOffset + Vec2f{min[0], 1 - min[1]}, uvOffset + Vec2f{max[0], 1 - max[1]}, uvOffset + Vec2f{max[0], 1 - min[1]}},
			.textureSlot = Neighbor.dirDown.toInt(),
		},
		.{
			.normal = .{0, 0, 1},
			.corners = .{corner111, corner101, corner011, corner001},
			.cornerUV = .{uvOffset + Vec2f{1 - max[0], 1 - max[1]}, uvOffset + Vec2f{1 - max[0], 1 - min[1]}, uvOffset + Vec2f{1 - min[0], 1 - max[1]}, uvOffset + Vec2f{1 - min[0], 1 - min[1]}},
			.textureSlot = Neighbor.dirUp.toInt(),
		},
	};
}

fn openBox(min: Vec3f, max: Vec3f, uvOffset: Vec2f, openSide: enum { x, y, z }) [4]QuadInfo {
	const fullBox = box(min, max, uvOffset);
	switch (openSide) {
		.x => return fullBox[2..6].*,
		.y => return fullBox[0..2].* ++ fullBox[4..6].*,
		.z => return fullBox[0..4].*,
	}
}

pub fn registerModel(id: []const u8, data: []const u8) ModelIndex {
	const model = Model.loadModel(data);
	nameToIndex.put(id, model) catch unreachable;
	return model;
}

// TODO: Entity models.
pub fn init() void {
	models = .init();
	quads = .init(main.globalAllocator);
	extraQuadInfos = .init(main.globalAllocator);
	quadDeduplication = .init(main.globalAllocator.allocator);

	nameToIndex = .init(main.globalAllocator.allocator);

	nameToIndex.put("none", Model.init(&.{})) catch unreachable;
}

pub fn reset() void {
	for (models.items()) |model| {
		model.deinit();
	}
	models.clearRetainingCapacity();
	quads.clearRetainingCapacity();
	extraQuadInfos.clearRetainingCapacity();
	quadDeduplication.clearRetainingCapacity();
	nameToIndex.clearRetainingCapacity();
	nameToIndex.put("none", Model.init(&.{})) catch unreachable;
}

pub fn deinit() void {
	quadSSBO.deinit();
	nameToIndex.deinit();
	for (models.items()) |model| {
		model.deinit();
	}
	models.deinit();
	quads.deinit();
	extraQuadInfos.deinit();
	quadDeduplication.deinit();
}

pub fn uploadModels() void {
	quadSSBO = graphics.SSBO.initStatic(QuadInfo, quads.items);
	quadSSBO.bind(4);
}

```

`src/network.zig`:

```zig
const builtin = @import("builtin");
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const game = main.game;
const settings = main.settings;
const utils = main.utils;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const authentication = @import("network/authentication.zig");
pub const protocols = @import("network/protocols.zig");

const c = @cImport({
	@cDefine("_BITS_STDIO2_H", ""); // TODO: Zig fails to include this header file
	@cInclude("mbedtls/debug.h");
	@cInclude("mbedtls/ssl.h");
});

// TODO: Might want to use SSL or something similar to encode the message

const ms = 1_000;
inline fn networkTimestamp() i64 {
	return @truncate(@divTrunc(main.timestamp().toNanoseconds(), 1000));
}

const Socket = struct {
	const ws2 = @cImport({
		@cInclude("winsock2.h");
	});
	const posix = std.posix;
	socketID: if (builtin.os.tag == .windows) ws2.SOCKET else posix.socket_t,

	fn windowsError(err: c_int) !void {
		if (err == 0) return;
		switch (err) {
			ws2.WSASYSNOTREADY => return error.NetworkDown,
			ws2.WSAVERNOTSUPPORTED => return error.VersionUnsupported,
			ws2.WSAEINPROGRESS => return error.BlockingOperationInProgress,
			ws2.WSAEPROCLIM => return error.ProcessFdQuotaExceeded,
			ws2.WSAEFAULT => unreachable,
			ws2.WSANOTINITIALISED => unreachable,
			ws2.WSAENETDOWN => return error.NetworkDown,
			ws2.WSAEACCES => return error.AccessDenied,
			ws2.WSAEADDRINUSE => return error.AddressInUse,
			ws2.WSAEADDRNOTAVAIL => return error.AddressNotAvailable,
			ws2.WSAEINVAL => unreachable,
			ws2.WSAENOBUFS => return error.SystemResources,
			ws2.WSAENOTSOCK => return error.FileDescriptorNotASocket,
			else => return error.UNKNOWN,
		}
	}

	fn startup() void {
		if (builtin.os.tag == .windows) {
			var data: ws2.WSADATA = undefined;
			windowsError(ws2.WSAStartup(0x0202, &data)) catch |err| {
				std.log.err("Could not initialize the Windows Socket API: {s}", .{@errorName(err)});
				@panic("Could not init networking.");
			};
		}
	}

	fn init(localPort: u16) !Socket {
		const self = Socket{
			.socketID = blk: {
				if (builtin.os.tag == .windows) {
					const socket = ws2.socket(ws2.AF_INET, ws2.SOCK_DGRAM, ws2.IPPROTO_UDP);
					if (socket == ws2.INVALID_SOCKET) {
						try windowsError(ws2.WSAGetLastError());
						return error.UNKNOWN;
					}
					break :blk socket;
				} else {
					break :blk try posix.socket(posix.AF.INET, posix.SOCK.DGRAM, posix.IPPROTO.UDP);
				}
			},
		};
		errdefer self.deinit();
		const bindingAddr = posix.sockaddr.in{
			.port = @byteSwap(localPort),
			.addr = 0,
		};
		if (builtin.os.tag == .windows) {
			if (ws2.bind(self.socketID, @ptrCast(&bindingAddr), @sizeOf(posix.sockaddr.in)) == ws2.SOCKET_ERROR) {
				try windowsError(ws2.WSAGetLastError());
			}
		} else {
			try posix.bind(self.socketID, @ptrCast(&bindingAddr), @sizeOf(posix.sockaddr.in));
		}
		return self;
	}

	fn deinit(self: Socket) void {
		if (builtin.os.tag == .windows) {
			_ = ws2.closesocket(self.socketID);
		} else {
			posix.close(self.socketID);
		}
	}

	fn send(self: Socket, data: []const u8, destination: Address) void {
		const addr = posix.sockaddr.in{
			.port = @byteSwap(destination.port),
			.addr = destination.ip,
		};
		if (builtin.os.tag == .windows) {
			const result = ws2.sendto(self.socketID, data.ptr, @intCast(data.len), 0, @ptrCast(&addr), @sizeOf(posix.sockaddr.in));
			if (result == ws2.SOCKET_ERROR) {
				const err: anyerror = if (windowsError(ws2.WSAGetLastError())) error.Unknown else |err| err;
				std.log.warn("Got error while sending to {f}: {s}", .{destination, @errorName(err)});
			} else {
				std.debug.assert(@as(usize, @intCast(result)) == data.len);
			}
		} else {
			std.debug.assert(data.len == posix.sendto(self.socketID, data, 0, @ptrCast(&addr), @sizeOf(posix.sockaddr.in)) catch |err| {
				std.log.warn("Got error while sending to {f}: {s}", .{destination, @errorName(err)});
				return;
			});
		}
	}

	fn receive(self: Socket, buffer: []u8, timeout: i32, resultAddress: *Address) ![]u8 {
		if (builtin.os.tag == .windows) { // Of course Windows always has it's own special thing.
			var pfd = [1]ws2.pollfd{
				.{.fd = self.socketID, .events = std.c.POLL.RDNORM | std.c.POLL.RDBAND, .revents = undefined},
			};
			const length = ws2.WSAPoll(&pfd, pfd.len, 0); // The timeout is set to zero. Otherwise sendto operations from other threads will block on this.
			if (length == ws2.SOCKET_ERROR) {
				try windowsError(ws2.WSAGetLastError());
			} else if (length == 0) {
				main.io.sleep(.fromMilliseconds(1), .awake) catch {}; // Manually sleep, since WSAPoll is blocking.
				return error.Timeout;
			}
		} else {
			var pfd = [1]posix.pollfd{
				.{.fd = self.socketID, .events = posix.POLL.IN, .revents = undefined},
			};
			const length = try posix.poll(&pfd, timeout);
			if (length == 0) return error.Timeout;
		}
		var addr: posix.sockaddr.in = undefined;
		const length: usize = blk: {
			if (builtin.os.tag == .windows) {
				var addrLen: c_int = @sizeOf(posix.sockaddr.in);
				const result = ws2.recvfrom(self.socketID, buffer.ptr, @intCast(buffer.len), 0, @ptrCast(&addr), &addrLen);
				if (result == ws2.SOCKET_ERROR) {
					try windowsError(ws2.WSAGetLastError());
				}
				break :blk @intCast(result);
			} else {
				var addrLen: posix.socklen_t = @sizeOf(posix.sockaddr.in);
				break :blk try posix.recvfrom(self.socketID, buffer, 0, @ptrCast(&addr), &addrLen);
			}
		};
		resultAddress.ip = addr.addr;
		resultAddress.port = @byteSwap(addr.port);
		return buffer[0..length];
	}

	fn resolveIP(name: []const u8) !u32 {
		var nameBuf: [255]u8 = undefined;
		var buf: [16]std.Io.net.HostName.LookupResult = undefined;
		var resultQueue = std.Io.Queue(std.Io.net.HostName.LookupResult).init(&buf);
		std.Io.net.HostName.lookup(.{.bytes = name}, main.io, &resultQueue, .{.canonical_name_buffer = &nameBuf, .port = 0});
		while (true) {
			const entry = resultQueue.getOneUncancelable(main.io);
			switch (entry) {
				.address => |addr| {
					if (addr != .ip4) continue;
					return std.mem.bytesToValue(u32, addr.ip4.bytes[0..4]);
				},
				.canonical_name => {},
				.end => |err| {
					try err;
					break;
				},
			}
		}
		return error.ReachedEndWithoutFindingAnything;
	}

	fn getPort(self: Socket) !u16 {
		var addr: posix.sockaddr.in = undefined;
		if (builtin.os.tag == .windows) {
			var addrLen: c_int = @sizeOf(posix.sockaddr.in);
			if (ws2.getsockname(self.socketID, @ptrCast(&addr), &addrLen) == ws2.SOCKET_ERROR) {
				try windowsError(ws2.WSAGetLastError());
			}
		} else {
			var addrLen: posix.socklen_t = @sizeOf(posix.sockaddr.in);
			try posix.getsockname(self.socketID, @ptrCast(&addr), &addrLen);
		}
		return @byteSwap(addr.port);
	}
};

pub fn init() !void {
	Socket.startup();
	protocols.init();
	authentication.init();
	try Connection.SecureChannel.checkResult(c.psa_crypto_init(), "psa_crypto_init");
}

pub fn deinit() void {
	c.mbedtls_psa_crypto_free();
}

pub const Address = struct {
	ip: u32,
	port: u16,
	isSymmetricNAT: bool = false,

	pub const localHost = 0x0100007f;

	pub fn format(self: Address, writer: anytype) !void {
		if (self.isSymmetricNAT) {
			try writer.print("{}.{}.{}.{}:?{}", .{self.ip & 255, self.ip >> 8 & 255, self.ip >> 16 & 255, self.ip >> 24, self.port});
		} else {
			try writer.print("{}.{}.{}.{}:{}", .{self.ip & 255, self.ip >> 8 & 255, self.ip >> 16 & 255, self.ip >> 24, self.port});
		}
	}
};

const Request = struct {
	address: Address,
	data: []const u8,
	requestNotifier: std.Thread.Condition = std.Thread.Condition{},
};

/// Implements parts of the STUN(Session Traversal Utilities for NAT) protocol to discover public IP+Port
/// Reference: https://datatracker.ietf.org/doc/html/rfc5389
const stun = struct { // MARK: stun
	const ipServerList = [_][]const u8{
		"stun.12voip.com:3478",
		"stun.1und1.de:3478",
		"stun.acrobits.cz:3478",
		"stun.actionvoip.com:3478",
		"stun.antisip.com:3478",
		"stun.avigora.fr:3478",
		"stun.bluesip.net:3478",
		"stun.cablenet-as.net:3478",
		"stun.callromania.ro:3478",
		"stun.cheapvoip.com:3478",
		"stun.cope.es:3478",
		"stun.counterpath.com:3478",
		"stun.counterpath.net:3478",
		"stun.dcalling.de:3478",
		"stun.dus.net:3478",
		"stun.ekiga.net:3478",
		"stun.epygi.com:3478",
		"stun.freeswitch.org:3478",
		"stun.freevoipdeal.com:3478",
		"stun.gmx.de:3478",
		"stun.gmx.net:3478",
		"stun.halonet.pl:3478",
		"stun.hoiio.com:3478",
		"stun.internetcalls.com:3478",
		"stun.intervoip.com:3478",
		"stun.ipfire.org:3478",
		"stun.ippi.fr:3478",
		"stun.ipshka.com:3478",
		"stun.it1.hr:3478",
		"stun.jumblo.com:3478",
		"stun.justvoip.com:3478",
		"stun.l.google.com:19302",
		"stun.linphone.org:3478",
		"stun.liveo.fr:3478",
		"stun.lowratevoip.com:3478",
		"stun.myvoiptraffic.com:3478",
		"stun.netappel.com:3478",
		"stun.netgsm.com.tr:3478",
		"stun.nfon.net:3478",
		"stun.nonoh.net:3478",
		"stun.ozekiphone.com:3478",
		"stun.pjsip.org:3478",
		"stun.powervoip.com:3478",
		"stun.ppdi.com:3478",
		"stun.rockenstein.de:3478",
		"stun.rolmail.net:3478",
		"stun.rynga.com:3478",
		"stun.schlund.de:3478",
		"stun.sigmavoip.com:3478",
		"stun.sip.us:3478",
		"stun.sipdiscount.com:3478",
		"stun.sipgate.net:10000",
		"stun.sipgate.net:3478",
		"stun.siplogin.de:3478",
		"stun.siptraffic.com:3478",
		"stun.smartvoip.com:3478",
		"stun.smsdiscount.com:3478",
		"stun.solcon.nl:3478",
		"stun.solnet.ch:3478",
		"stun.sonetel.com:3478",
		"stun.sonetel.net:3478",
		"stun.srce.hr:3478",
		"stun.t-online.de:3478",
		"stun.tel.lu:3478",
		"stun.telbo.com:3478",
		"stun.tng.de:3478",
		"stun.twt.it:3478",
		"stun.vo.lu:3478",
		"stun.voicetrading.com:3478",
		"stun.voip.aebc.com:3478",
		"stun.voip.blackberry.com:3478",
		"stun.voip.eutelia.it:3478",
		"stun.voipblast.com:3478",
		"stun.voipbuster.com:3478",
		"stun.voipbusterpro.com:3478",
		"stun.voipcheap.co.uk:3478",
		"stun.voipcheap.com:3478",
		"stun.voipgain.com:3478",
		"stun.voipgate.com:3478",
		"stun.voipinfocenter.com:3478",
		"stun.voipplanet.nl:3478",
		"stun.voippro.com:3478",
		"stun.voipraider.com:3478",
		"stun.voipstunt.com:3478",
		"stun.voipwise.com:3478",
		"stun.voipzoom.com:3478",
		"stun.voys.nl:3478",
		"stun.voztele.com:3478",
		"stun.webcalldirect.com:3478",
		"stun.zadarma.com:3478",
		"stun1.l.google.com:19302",
		"stun2.l.google.com:19302",
		"stun3.l.google.com:19302",
		"stun4.l.google.com:19302",
		"stun.nextcloud.com:443",
		"relay.webwormhole.io:3478",
	};
	const MAPPED_ADDRESS: u16 = 0x0001;
	const XOR_MAPPED_ADDRESS: u16 = 0x0020;
	const MAGIC_COOKIE = [_]u8{0x21, 0x12, 0xA4, 0x42};

	fn requestAddress(connection: *ConnectionManager) Address {
		var oldAddress: ?Address = null;
		var seed: [std.Random.DefaultCsprng.secret_seed_length]u8 = @splat(0);
		std.mem.writeInt(i128, seed[0..16], main.timestamp().toMilliseconds(), builtin.cpu.arch.endian()); // Not the best seed, but it's not that important.
		var random = std.Random.DefaultCsprng.init(seed);
		for (0..16) |_| {
			// Choose a somewhat random server, so we faster notice if any one of them stopped working.
			const server = ipServerList[random.random().intRangeAtMost(usize, 0, ipServerList.len - 1)];
			var data = [_]u8{
				0x00, 0x01, // message type
				0x00, 0x00, // message length
				MAGIC_COOKIE[0], MAGIC_COOKIE[1], MAGIC_COOKIE[2], MAGIC_COOKIE[3], // "Magic cookie"
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // transaction ID
			};
			random.fill(data[8..]); // Fill the transaction ID.

			var splitter = std.mem.splitScalar(u8, server, ':');
			const ip = splitter.first();
			const serverAddress = Address{
				.ip = Socket.resolveIP(ip) catch |err| {
					std.log.warn("Cannot resolve STUN server address: {s}, error: {s}", .{ip, @errorName(err)});
					continue;
				},
				.port = std.fmt.parseUnsigned(u16, splitter.rest(), 10) catch 3478,
			};
			if (connection.sendRequest(main.globalAllocator, &data, serverAddress, 500*1000000)) |answer| {
				defer main.globalAllocator.free(answer);
				verifyHeader(answer, data[8..20]) catch |err| {
					std.log.err("Header verification failed with {s} for STUN server: {s} data: {any}", .{@errorName(err), server, answer});
					continue;
				};
				var result = findIPPort(answer) catch |err| {
					std.log.err("Could not parse IP+Port: {s} for STUN server: {s} data: {any}", .{@errorName(err), server, answer});
					continue;
				};
				if (oldAddress) |other| {
					std.log.info("{f}", .{result});
					if (other.ip == result.ip and other.port == result.port) {
						return result;
					} else {
						result.isSymmetricNAT = true;
						return result;
					}
				} else {
					oldAddress = result;
				}
			} else {
				std.log.warn("Couldn't reach STUN server: {s}", .{server});
			}
		}
		return Address{.ip = Socket.resolveIP("127.0.0.1") catch unreachable, .port = settings.defaultPort}; // TODO: Return ip address in LAN.
	}

	fn findIPPort(_data: []const u8) !Address {
		var data = _data[20..]; // Skip the header.
		while (data.len > 0) {
			const typ = std.mem.readInt(u16, data[0..2], .big);
			const len = std.mem.readInt(u16, data[2..4], .big);
			data = data[4..];
			switch (typ) {
				XOR_MAPPED_ADDRESS, MAPPED_ADDRESS => {
					const xor = data[0];
					if (typ == MAPPED_ADDRESS and xor != 0) return error.NonZeroXORForMappedAddress;
					if (data[1] == 0x01) {
						var addressData: [6]u8 = data[2..8].*;
						if (typ == XOR_MAPPED_ADDRESS) {
							addressData[0] ^= MAGIC_COOKIE[0];
							addressData[1] ^= MAGIC_COOKIE[1];
							addressData[2] ^= MAGIC_COOKIE[0];
							addressData[3] ^= MAGIC_COOKIE[1];
							addressData[4] ^= MAGIC_COOKIE[2];
							addressData[5] ^= MAGIC_COOKIE[3];
						}
						return Address{
							.port = std.mem.readInt(u16, addressData[0..2], .big),
							.ip = std.mem.readInt(u32, addressData[2..6], builtin.cpu.arch.endian()), // Needs to stay in big endian → native.
						};
					} else if (data[1] == 0x02) {
						data = data[(len + 3) & ~@as(usize, 3) ..]; // Pad to 32 Bit.
						continue; // I don't care about IPv6.
					} else {
						return error.UnknownAddressFamily;
					}
				},
				else => {
					data = data[(len + 3) & ~@as(usize, 3) ..]; // Pad to 32 Bit.
				},
			}
		}
		return error.IpPortNotFound;
	}

	fn verifyHeader(data: []const u8, transactionID: []const u8) !void {
		if (data[0] != 0x01 or data[1] != 0x01) return error.NotABinding;
		if (@as(u16, @intCast(data[2] & 0xff))*256 + (data[3] & 0xff) != data.len - 20) return error.BadSize;
		for (MAGIC_COOKIE, 0..) |cookie, i| {
			if (data[i + 4] != cookie) return error.WrongCookie;
		}
		for (transactionID, 0..) |_, i| {
			if (data[i + 8] != transactionID[i]) return error.WrongTransaction;
		}
	}
};

pub const ConnectionManager = struct { // MARK: ConnectionManager
	socket: Socket = undefined,
	thread: std.Thread = undefined,
	threadId: std.Thread.Id = undefined,
	externalAddress: Address = undefined,
	online: Atomic(bool) = .init(false),
	running: Atomic(bool) = .init(true),

	connections: main.List(*Connection) = undefined,
	requests: main.List(*Request) = undefined,

	mutex: std.Thread.Mutex = .{},
	waitingToFinishReceive: std.Thread.Condition = std.Thread.Condition{},
	allowNewConnections: Atomic(bool) = .init(false),

	receiveBuffer: [Connection.maxMtu]u8 = undefined,

	world: ?*game.World = null,

	localPort: u16 = undefined,

	packetSendRequests: std.PriorityQueue(PacketSendRequest, void, PacketSendRequest.compare) = undefined,

	const PacketSendRequest = struct {
		data: []const u8,
		target: Address,
		time: i64,

		fn compare(_: void, a: PacketSendRequest, b: PacketSendRequest) std.math.Order {
			return std.math.order(a.time, b.time);
		}
	};

	pub fn init(localPort: u16, online: bool) !*ConnectionManager {
		const result: *ConnectionManager = main.globalAllocator.create(ConnectionManager);
		errdefer main.globalAllocator.destroy(result);
		result.* = .{};
		result.connections = .init(main.globalAllocator);
		result.requests = .init(main.globalAllocator);
		result.packetSendRequests = .init(main.globalAllocator.allocator, {});

		result.localPort = localPort;
		result.socket = Socket.init(localPort) catch |err| blk: {
			if (err == error.AddressInUse) {
				const socket = try Socket.init(0); // Use any port.
				result.localPort = try socket.getPort();
				break :blk socket;
			} else return err;
		};
		errdefer result.socket.deinit();
		if (localPort == 0) result.localPort = try result.socket.getPort();

		result.thread = try std.Thread.spawn(.{}, run, .{result});
		result.thread.setName("Network Thread") catch |err| std.log.err("Couldn't rename thread: {s}", .{@errorName(err)});
		if (online) {
			result.makeOnline();
		}
		if (main.settings.launchConfig.headlessServer) {
			result.allowNewConnections.store(true, .monotonic);
		}
		return result;
	}

	pub fn deinit(self: *ConnectionManager) void {
		for (self.connections.items) |conn| {
			conn.disconnect();
		}

		self.running.store(false, .monotonic);
		self.thread.join();
		self.socket.deinit();
		self.connections.deinit();
		for (self.requests.items) |request| {
			request.requestNotifier.signal();
		}
		self.requests.deinit();
		while (self.packetSendRequests.removeOrNull()) |packet| {
			main.globalAllocator.free(packet.data);
		}
		self.packetSendRequests.deinit();

		main.globalAllocator.destroy(self);
	}

	pub fn makeOnline(self: *ConnectionManager) void {
		if (!self.online.load(.acquire)) {
			self.externalAddress = stun.requestAddress(self);
			self.online.store(true, .release);
		}
	}

	pub fn send(self: *ConnectionManager, data: []const u8, target: Address, nanoTime: ?i64) void {
		if (nanoTime) |time| {
			self.mutex.lock();
			defer self.mutex.unlock();
			self.packetSendRequests.add(.{
				.data = main.globalAllocator.dupe(u8, data),
				.target = target,
				.time = time,
			}) catch unreachable;
		} else {
			self.socket.send(data, target);
		}
	}

	pub fn sendRequest(self: *ConnectionManager, allocator: NeverFailingAllocator, data: []const u8, target: Address, timeout_ns: u64) ?[]const u8 {
		self.socket.send(data, target);
		var request = Request{.address = target, .data = data};
		{
			self.mutex.lock();
			defer self.mutex.unlock();
			self.requests.append(&request);

			request.requestNotifier.timedWait(&self.mutex, timeout_ns) catch {};

			for (self.requests.items, 0..) |req, i| {
				if (req == &request) {
					_ = self.requests.swapRemove(i);
					break;
				}
			}
		}

		// The request data gets modified when a result was received.
		if (request.data.ptr == data.ptr) {
			return null;
		} else {
			if (allocator.allocator.ptr == main.globalAllocator.allocator.ptr) {
				return request.data;
			} else {
				const result = allocator.dupe(u8, request.data);
				main.globalAllocator.free(request.data);
				return result;
			}
		}
	}

	pub fn addConnection(self: *ConnectionManager, conn: *Connection) error{AlreadyConnected}!void {
		self.mutex.lock();
		defer self.mutex.unlock();
		for (self.connections.items) |other| {
			if (other.remoteAddress.ip == conn.remoteAddress.ip and other.remoteAddress.port == conn.remoteAddress.port) return error.AlreadyConnected;
		}
		self.connections.append(conn);
	}

	pub fn finishCurrentReceive(self: *ConnectionManager) void {
		std.debug.assert(self.threadId != std.Thread.getCurrentId()); // WOuld cause deadlock, since we are in a receive.
		self.mutex.lock();
		defer self.mutex.unlock();
		self.waitingToFinishReceive.wait(&self.mutex);
	}

	pub fn removeConnection(self: *ConnectionManager, conn: *Connection) void {
		self.mutex.lock();
		defer self.mutex.unlock();

		for (self.connections.items, 0..) |other, i| {
			if (other == conn) {
				_ = self.connections.swapRemove(i);
				break;
			}
		}
	}

	fn onReceive(self: *ConnectionManager, data: []const u8, source: Address) void {
		std.debug.assert(self.threadId == std.Thread.getCurrentId());
		self.mutex.lock();

		for (self.connections.items) |conn| {
			if (conn.remoteAddress.ip == source.ip) {
				if (conn.bruteforcingPort) {
					conn.remoteAddress.port = source.port;
					conn.bruteforcingPort = false;
				}
				if (conn.remoteAddress.port == source.port) {
					self.mutex.unlock();
					conn.receive(data);
					return;
				}
			}
		}
		{
			defer self.mutex.unlock();
			// Check if it's part of an active request:
			for (self.requests.items) |request| {
				if (request.address.ip == source.ip and request.address.port == source.port) {
					request.data = main.globalAllocator.dupe(u8, data);
					request.requestNotifier.signal();
					return;
				}
			}
			if (self.online.load(.acquire) and source.ip == self.externalAddress.ip and source.port == self.externalAddress.port) return;
		}
		if (self.allowNewConnections.load(.monotonic) or source.ip == Address.localHost) {
			if (data.len != 0 and data[0] == @intFromEnum(Connection.ChannelId.init)) {
				const ip = std.fmt.allocPrint(main.stackAllocator.allocator, "{f}", .{source}) catch unreachable;
				defer main.stackAllocator.free(ip);
				const user = main.server.User.initAndIncreaseRefCount(main.server.connectionManager, ip) catch |err| {
					std.log.err("Cannot connect user from external IP {f}: {s}", .{source, @errorName(err)});
					return;
				};
				user.decreaseRefCount();
				user.conn.receive(data);
			}
		} else {
			// TODO: Reduce the number of false alarms in the short period after a disconnect.
			std.log.warn("Unknown connection from address: {f}", .{source});
			std.log.debug("Message: {any}", .{data});
		}
	}

	pub fn run(self: *ConnectionManager) void {
		self.threadId = std.Thread.getCurrentId();
		main.initThreadLocals();
		defer main.deinitThreadLocals();

		var lastTime: i64 = networkTimestamp();
		var lastExternalPacketTime = lastTime;
		while (self.running.load(.monotonic)) {
			main.heap.GarbageCollection.syncPoint();
			self.waitingToFinishReceive.broadcast();
			var source: Address = undefined;
			if (self.socket.receive(&self.receiveBuffer, 1, &source)) |data| {
				self.onReceive(data, source);
			} else |err| {
				if (err == error.Timeout) {
					// No message within the last ~100 ms.
				} else if (err == error.ConnectionResetByPeer) {
					std.log.err("Got error.ConnectionResetByPeer on receive. This indicates that a previous message did not find a valid destination.", .{});
				} else {
					std.log.warn("Got error on receive: {s}", .{@errorName(err)});
				}
			}
			const curTime: i64 = networkTimestamp();
			{
				self.mutex.lock();
				defer self.mutex.unlock();
				while (self.packetSendRequests.peek() != null and self.packetSendRequests.peek().?.time -% curTime <= 0) {
					const packet = self.packetSendRequests.remove();
					self.socket.send(packet.data, packet.target);
					main.globalAllocator.free(packet.data);
				}
			}

			// Send packets roughly every 1 ms:
			if (curTime -% lastTime > 1*ms) {
				lastTime = curTime;
				var i: u32 = 0;
				self.mutex.lock();
				defer self.mutex.unlock();
				while (i < self.connections.items.len) {
					var conn = self.connections.items[i];
					self.mutex.unlock();
					conn.processNextPackets();
					self.mutex.lock();
					i += 1;
				}
				if (self.connections.items.len == 0 and self.online.load(.acquire) and curTime -% lastExternalPacketTime > 1000*ms) {
					lastExternalPacketTime = curTime;
					// Send a message to external ip, to keep the port open:
					const data = [1]u8{0};
					self.socket.send(&data, self.externalAddress);
				}
			}
		}
	}
};

const UnconfirmedPacket = struct {
	data: []const u8,
	lastKeepAliveSentBefore: u32,
	id: u32,
};

pub const Connection = struct { // MARK: Connection
	const maxMtu: u32 = 65507; // max udp packet size
	const importantHeaderSize: u32 = 5;
	const minMtu: u32 = 576 - 20 - 8; // IPv4 MTU minus IP header minus udp header
	const headerOverhead = 20 + 8 + 42; // IP Header + UDP Header + Ethernet header/footer
	const congestionControl_historySize = 16;
	const congestionControl_historyMask = congestionControl_historySize - 1;
	const minimumBandWidth = 10_000;

	const receiveBufferSize = 8 << 20;

	// Statistics:
	pub var packetsSent: Atomic(u32) = .init(0);
	pub var packetsResent: Atomic(u32) = .init(0);
	pub var internalMessageOverhead: Atomic(usize) = .init(0);
	pub var internalHeaderOverhead: Atomic(usize) = .init(0);
	pub var externalHeaderOverhead: Atomic(usize) = .init(0);

	const SequenceIndex = i32;

	const LossStatus = enum {
		noLoss,
		singleLoss,
		doubleLoss,
	};

	const RangeBuffer = struct { // MARK: RangeBuffer
		const Range = struct {
			start: SequenceIndex,
			len: SequenceIndex,

			fn end(self: Range) SequenceIndex {
				return self.start +% self.len;
			}
		};
		ranges: main.ListUnmanaged(Range),

		pub fn init() RangeBuffer {
			return .{
				.ranges = .{},
			};
		}

		pub fn clear(self: *RangeBuffer) void {
			self.ranges.clearRetainingCapacity();
		}

		pub fn deinit(self: RangeBuffer, allocator: NeverFailingAllocator) void {
			self.ranges.deinit(allocator);
		}

		pub fn addRange(self: *RangeBuffer, allocator: NeverFailingAllocator, range: Range) void {
			if (self.hasRange(range)) return;
			var startRange: ?Range = null;
			var endRange: ?Range = null;
			var i: usize = 0;
			while (i < self.ranges.items.len) {
				const other = self.ranges.items[i];
				if (range.start -% other.start <= 0 and range.end() -% other.end() >= 0) {
					_ = self.ranges.swapRemove(i);
					continue;
				}
				if (range.start -% other.end() <= 0 and range.start -% other.start >= 0) {
					_ = self.ranges.swapRemove(i);
					startRange = other;
					continue;
				}
				if (range.end() -% other.start >= 0 and range.end() -% other.end() <= 0) {
					_ = self.ranges.swapRemove(i);
					endRange = other;
					continue;
				}
				i += 1;
			}
			var mergedRange = range;
			if (startRange) |start| {
				mergedRange.start = start.start;
				mergedRange.len = range.end() -% mergedRange.start;
			}
			if (endRange) |end| {
				mergedRange.len = end.end() -% mergedRange.start;
			}
			self.ranges.append(allocator, mergedRange);
		}

		pub fn hasRange(self: *RangeBuffer, range: Range) bool {
			for (self.ranges.items) |other| {
				if (range.start -% other.start >= 0 and range.end() -% other.end() <= 0) {
					return true;
				}
			}
			return false;
		}

		pub fn extractFirstRange(self: *RangeBuffer) ?Range {
			if (self.ranges.items.len == 0) return null;
			var firstRange = self.ranges.items[0];
			var index: usize = 0;
			for (self.ranges.items[1..], 1..) |range, i| {
				if (range.start -% firstRange.start < 0) {
					firstRange = range;
					index = i;
				}
			}
			_ = self.ranges.swapRemove(index);
			return firstRange;
		}
	};

	const ReceiveBuffer = struct { // MARK: ReceiveBuffer
		const Range = struct {
			start: SequenceIndex,
			len: SequenceIndex,
		};
		const Header = struct {
			protocolIndex: u8,
			size: u32,
		};
		ranges: RangeBuffer,
		availablePosition: SequenceIndex = undefined,
		currentReadPosition: SequenceIndex = undefined,
		decryptedBuffer: main.utils.FixedSizeCircularBuffer(u8, receiveBufferSize),
		buffer: main.utils.FixedSizeCircularBuffer(u8, receiveBufferSize),
		header: ?Header = null,
		protocolBuffer: main.ListUnmanaged(u8) = .{},

		pub fn init() ReceiveBuffer {
			return .{
				.ranges = .init(),
				.decryptedBuffer = .init(main.globalAllocator),
				.buffer = .init(main.globalAllocator),
			};
		}

		pub fn deinit(self: ReceiveBuffer) void {
			self.ranges.deinit(main.globalAllocator);
			self.protocolBuffer.deinit(main.globalAllocator);
			self.buffer.deinit(main.globalAllocator);
			self.decryptedBuffer.deinit(main.globalAllocator);
		}

		fn applyRanges(self: *ReceiveBuffer, secureChannel: ?*SecureChannel) !void {
			const range = self.ranges.extractFirstRange() orelse unreachable;
			std.debug.assert(range.start == self.availablePosition);
			self.availablePosition = range.end();
			const data = main.stackAllocator.alloc(u8, @intCast(range.len));
			defer main.stackAllocator.free(data);
			self.buffer.popSliceFront(data) catch unreachable;
			if (secureChannel) |ch| {
				try ch.receiveThroughTls(data);
			} else {
				try self.decryptedBuffer.pushBackSlice(data);
			}
		}

		fn getHeaderInformation(self: *ReceiveBuffer) !?Header {
			if (self.decryptedBuffer.len == 0) return null;
			var header: Header = .{
				.protocolIndex = self.decryptedBuffer.getAtOffset(0) orelse unreachable,
				.size = 0,
			};
			var i: u8 = 1;
			while (true) : (i += 1) {
				if (i == self.decryptedBuffer.len) return null;
				const nextByte = self.decryptedBuffer.getAtOffset(i) orelse unreachable;
				header.size = header.size << 7 | (nextByte & 0x7f);
				if (nextByte & 0x80 == 0) break;
				if (header.size > std.math.maxInt(@TypeOf(header.size)) >> 7) return error.Invalid;
			}
			self.decryptedBuffer.discardElementsFront(i + 1);
			return header;
		}

		fn collectRangesAndExecuteProtocols(self: *ReceiveBuffer, secureChannel: ?*SecureChannel, conn: *Connection) !void {
			try self.applyRanges(secureChannel);
			while (true) {
				if (self.header == null) {
					self.header = try self.getHeaderInformation() orelse return;
					self.protocolBuffer.ensureCapacity(main.globalAllocator, self.header.?.size);
				}
				const amount = @min(@as(usize, @intCast(self.decryptedBuffer.len)), self.header.?.size - self.protocolBuffer.items.len);
				if (self.decryptedBuffer.len == 0) return;

				self.decryptedBuffer.popSliceFront(self.protocolBuffer.addManyAssumeCapacity(amount)) catch unreachable;
				if (self.protocolBuffer.items.len != self.header.?.size) return;

				const protocolIndex = self.header.?.protocolIndex;
				self.header = null;
				try protocols.onReceive(conn, protocolIndex, self.protocolBuffer.items);
				self.protocolBuffer.clearRetainingCapacity();
				if (self.protocolBuffer.items.len > 1 << 24) {
					self.protocolBuffer.shrinkAndFree(main.globalAllocator, 1 << 24);
				}
			}
		}

		const ReceiveStatus = enum {
			accepted,
			rejected,
		};

		pub fn receive(self: *ReceiveBuffer, conn: *Connection, start: SequenceIndex, data: []const u8) !ReceiveStatus {
			return self.receiveSecure(null, conn, start, data);
		}

		pub fn receiveSecure(self: *ReceiveBuffer, secureChannel: ?*SecureChannel, conn: *Connection, start: SequenceIndex, data: []const u8) !ReceiveStatus {
			const len: SequenceIndex = @intCast(data.len);
			if (start -% self.availablePosition < 0) return .accepted; // We accepted it in the past.
			const offset: usize = @intCast(start -% self.availablePosition);
			self.buffer.insertSliceAtOffset(data, offset) catch return .rejected;
			self.ranges.addRange(main.globalAllocator, .{.start = start, .len = len});
			if (start == self.availablePosition) {
				try self.collectRangesAndExecuteProtocols(secureChannel, conn);
			}
			return .accepted;
		}
	};

	const SendBuffer = struct { // MARK: SendBuffer
		const Range = struct {
			start: SequenceIndex,
			len: SequenceIndex,
			timestamp: i64,
			wasResent: bool = false,
			wasResentAsFirstPacket: bool = false,
			considerForCongestionControl: bool,

			fn compareTime(_: void, a: Range, b: Range) std.math.Order {
				if (a.timestamp == b.timestamp) return .eq;
				if (a.timestamp -% b.timestamp > 0) return .gt;
				return .lt;
			}
		};
		unconfirmedRanges: std.PriorityQueue(Range, void, Range.compareTime),
		lostRanges: main.utils.CircularBufferQueue(Range),
		buffer: main.utils.CircularBufferQueue(u8),
		fullyConfirmedIndex: SequenceIndex,
		highestSentIndex: SequenceIndex,
		nextIndex: SequenceIndex,
		lastUnsentTime: i64,

		pub fn init(index: SequenceIndex) SendBuffer {
			return .{
				.unconfirmedRanges = .init(main.globalAllocator.allocator, {}),
				.lostRanges = .init(main.globalAllocator, 1 << 10),
				.buffer = .init(main.globalAllocator, 1 << 20),
				.fullyConfirmedIndex = index,
				.highestSentIndex = index,
				.nextIndex = index,
				.lastUnsentTime = networkTimestamp(),
			};
		}

		pub fn deinit(self: SendBuffer) void {
			self.unconfirmedRanges.deinit();
			self.lostRanges.deinit();
			self.buffer.deinit();
		}

		pub fn insertMessage(self: *SendBuffer, protocolIndex: u8, data: []const u8, time: i64) !void {
			try self.insertMessageSecure(null, protocolIndex, data, time);
		}

		pub fn insertMessageSecure(self: *SendBuffer, secureChannel: ?*SecureChannel, protocolIndex: u8, data: []const u8, time: i64) !void {
			if (self.highestSentIndex == self.fullyConfirmedIndex) {
				self.lastUnsentTime = time;
			}
			var fullData: main.List(u8) = .init(main.stackAllocator);
			defer fullData.deinit();
			if (data.len + self.buffer.len > std.math.maxInt(SequenceIndex)) return error.OutOfMemory;
			fullData.append(protocolIndex);
			_ = internalHeaderOverhead.fetchAdd(1, .monotonic);
			const bits = 1 + if (data.len == 0) 0 else std.math.log2_int(usize, data.len);
			const bytes = std.math.divCeil(usize, bits, 7) catch unreachable;
			for (0..bytes) |i| {
				const shift = 7*(bytes - i - 1);
				const byte = (data.len >> @intCast(shift) & 0x7f) | if (i == bytes - 1) @as(u8, 0) else 0x80;
				fullData.append(@intCast(byte));
				_ = internalHeaderOverhead.fetchAdd(1, .monotonic);
			}
			fullData.appendSlice(data);
			if (secureChannel) |ch| {
				try ch.sendThroughTls(fullData.items);
			} else {
				self.buffer.pushBackSlice(fullData.items);
				self.nextIndex +%= @intCast(fullData.items.len);
			}
		}

		const ReceiveConfirmationResult = struct {
			timestamp: i64,
			packetLen: SequenceIndex,
			considerForCongestionControl: bool,
		};

		pub fn receiveConfirmationAndGetTimestamp(self: *SendBuffer, start: SequenceIndex) ?ReceiveConfirmationResult {
			var result: ?ReceiveConfirmationResult = null;
			for (self.unconfirmedRanges.items, 0..) |range, i| {
				if (range.start == start) {
					result = .{
						.timestamp = range.timestamp,
						.considerForCongestionControl = range.considerForCongestionControl,
						.packetLen = range.len,
					};
					_ = self.unconfirmedRanges.removeIndex(i);
					break;
				}
			}
			var smallestUnconfirmed = self.highestSentIndex;
			for (self.unconfirmedRanges.items) |range| {
				if (smallestUnconfirmed -% range.start > 0) {
					smallestUnconfirmed = range.start;
				}
			}
			for (0..self.lostRanges.len) |i| {
				const range = self.lostRanges.getAtOffset(i) catch unreachable;
				if (smallestUnconfirmed -% range.start > 0) {
					smallestUnconfirmed = range.start;
				}
			}
			self.buffer.discardFront(@intCast(smallestUnconfirmed -% self.fullyConfirmedIndex)) catch unreachable;
			self.fullyConfirmedIndex = smallestUnconfirmed;
			return result;
		}

		pub fn checkForLosses(self: *SendBuffer, time: i64, retransmissionTimeout: i64) LossStatus {
			var hadLoss: bool = false;
			var hadDoubleLoss: bool = false;
			while (true) {
				var range = self.unconfirmedRanges.peek() orelse break;
				if (range.timestamp +% retransmissionTimeout -% time >= 0) break;
				_ = self.unconfirmedRanges.remove();
				if (self.fullyConfirmedIndex == range.start) {
					// In TCP effectively only the second loss of the lowest unconfirmed packet is counted for congestion control
					// This decreases the chance of triggering congestion control from random packet loss
					if (range.wasResentAsFirstPacket) hadDoubleLoss = true;
					hadLoss = true;
					range.wasResentAsFirstPacket = true;
				}
				range.wasResent = true;
				self.lostRanges.pushBack(range);
				_ = packetsResent.fetchAdd(1, .monotonic);
			}
			if (hadDoubleLoss) return .doubleLoss;
			if (hadLoss) return .singleLoss;
			return .noLoss;
		}

		pub fn getNextPacketToSend(self: *SendBuffer, byteIndex: *SequenceIndex, buf: []u8, time: i64, considerForCongestionControl: bool, allowedDelay: i64) ?usize {
			self.unconfirmedRanges.ensureUnusedCapacity(1) catch unreachable;
			// Resend old packet:
			if (self.lostRanges.popFront()) |_range| {
				var range = _range;
				if (range.len > buf.len) { // MTU changed → split the data
					self.lostRanges.pushFront(.{
						.start = range.start +% @as(SequenceIndex, @intCast(buf.len)),
						.len = range.len - @as(SequenceIndex, @intCast(buf.len)),
						.timestamp = range.timestamp,
						.considerForCongestionControl = range.considerForCongestionControl,
					});
					range.len = @intCast(buf.len);
				}

				self.buffer.getSliceAtOffset(@intCast(range.start -% self.fullyConfirmedIndex), buf[0..@intCast(range.len)]) catch unreachable;
				range.timestamp = time;
				byteIndex.* = range.start;
				self.unconfirmedRanges.add(range) catch unreachable;
				return @intCast(range.len);
			}

			if (self.highestSentIndex == self.nextIndex) return null;
			if (self.highestSentIndex +% @as(i32, @intCast(buf.len)) -% self.fullyConfirmedIndex > receiveBufferSize) return null;
			// Send new packet:
			const len: SequenceIndex = @min(self.nextIndex -% self.highestSentIndex, @as(i32, @intCast(buf.len)));
			if (len < buf.len and time -% self.lastUnsentTime < allowedDelay) return null;

			self.buffer.getSliceAtOffset(@intCast(self.highestSentIndex -% self.fullyConfirmedIndex), buf[0..@intCast(len)]) catch unreachable;
			byteIndex.* = self.highestSentIndex;
			self.unconfirmedRanges.add(.{
				.start = self.highestSentIndex,
				.len = len,
				.timestamp = time,
				.considerForCongestionControl = considerForCongestionControl,
			}) catch unreachable;
			self.highestSentIndex +%= len;
			return @intCast(len);
		}
	};

	const Channel = struct { // MARK: Channel
		receiveBuffer: ReceiveBuffer,
		sendBuffer: SendBuffer,
		allowedDelay: i64,
		channelId: ChannelId,

		pub fn init(sequenceIndex: SequenceIndex, delay: i64, id: ChannelId) Channel {
			return .{
				.receiveBuffer = .init(),
				.sendBuffer = .init(sequenceIndex),
				.allowedDelay = delay,
				.channelId = id,
			};
		}

		pub fn deinit(self: *Channel) void {
			self.receiveBuffer.deinit();
			self.sendBuffer.deinit();
		}

		pub fn connect(self: *Channel, remoteStart: SequenceIndex) void {
			std.debug.assert(self.receiveBuffer.buffer.len == 0);
			self.receiveBuffer.availablePosition = remoteStart;
			self.receiveBuffer.currentReadPosition = remoteStart;
		}

		pub fn receive(self: *Channel, conn: *Connection, start: SequenceIndex, data: []const u8) !ReceiveBuffer.ReceiveStatus {
			return self.receiveBuffer.receive(conn, start, data);
		}

		pub fn send(self: *Channel, protocolIndex: u8, data: []const u8, time: i64) !void {
			return self.sendBuffer.insertMessage(protocolIndex, data, time);
		}

		pub fn receiveConfirmationAndGetTimestamp(self: *Channel, start: SequenceIndex) ?SendBuffer.ReceiveConfirmationResult {
			return self.sendBuffer.receiveConfirmationAndGetTimestamp(start);
		}

		pub fn checkForLosses(self: *Channel, conn: *Connection, time: i64) LossStatus {
			const retransmissionTimeout: i64 = @intFromFloat(conn.rttEstimate + 3*conn.rttUncertainty + @as(f32, @floatFromInt(self.allowedDelay)));
			return self.sendBuffer.checkForLosses(time, retransmissionTimeout);
		}

		pub fn sendNextPacketAndGetSize(self: *Channel, conn: *Connection, time: i64, considerForCongestionControl: bool) ?usize {
			var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, conn.mtuEstimate);
			defer writer.deinit();

			writer.writeEnum(ChannelId, self.channelId);

			var byteIndex: SequenceIndex = undefined;
			const packetLen = self.sendBuffer.getNextPacketToSend(&byteIndex, writer.data.items.ptr[5..writer.data.capacity], time, considerForCongestionControl, self.allowedDelay) orelse return null;
			writer.writeInt(SequenceIndex, byteIndex);
			_ = internalHeaderOverhead.fetchAdd(5, .monotonic);
			_ = externalHeaderOverhead.fetchAdd(headerOverhead, .monotonic);
			writer.data.items.len += packetLen;

			_ = packetsSent.fetchAdd(1, .monotonic);
			conn.manager.send(writer.data.items, conn.remoteAddress, null);
			return writer.data.items.len;
		}

		pub fn getStatistics(self: *Channel, unconfirmed: *usize, queued: *usize) void {
			for (self.sendBuffer.unconfirmedRanges.items) |range| {
				unconfirmed.* += @intCast(range.len);
			}
			queued.* = @intCast(self.sendBuffer.nextIndex -% self.sendBuffer.highestSentIndex);
		}
	};

	const SecureChannel = struct { // MARK: SecureChannel
		super: Channel,
		sslContext: c.mbedtls_ssl_context = .{},
		sslConfig: c.mbedtls_ssl_config = .{},
		serverCertificate: c.mbedtls_x509_crt = .{},
		serverKey: c.mbedtls_pk_context = .{},
		dataToReceive: []const u8 = &.{},
		mutex: std.Thread.Mutex = .{},

		side: main.sync.Side,
		finishedCollectingClientVerificationData: bool = false,
		verificationDataForClientSignature: main.ListUnmanaged(u8) = .{},

		pub fn init(self: *SecureChannel, sequenceIndex: SequenceIndex, delay: i64, id: ChannelId, side: main.sync.Side) !void {
			self.* = .{
				.super = .init(sequenceIndex, delay, id),
				.side = side,
			};

			c.mbedtls_ssl_init(&self.sslContext);
			c.mbedtls_ssl_config_init(&self.sslConfig);

			try checkResult(c.mbedtls_ssl_config_defaults(
				&self.sslConfig,
				if (side == .client) c.MBEDTLS_SSL_IS_CLIENT else c.MBEDTLS_SSL_IS_SERVER,
				c.MBEDTLS_SSL_TRANSPORT_STREAM,
				c.MBEDTLS_SSL_PRESET_DEFAULT,
			), "mbedtls_ssl_config_defaults");
			c.mbedtls_ssl_conf_authmode(&self.sslConfig, c.MBEDTLS_SSL_VERIFY_NONE); // We don't care about server certificates for now. Only the client is authenticated, through an outside mechanism.
			c.mbedtls_ssl_conf_dbg(&self.sslConfig, &debugOutput, undefined);

			if (side == .server) { // Generate a self-signed certificate, since we do not key about authenticating the server. MITM will be mitigated during the client authentication
				var certificate: c.mbedtls_x509write_cert = .{};
				c.mbedtls_x509write_crt_init(&certificate);
				defer c.mbedtls_x509write_crt_free(&certificate);
				var attributes = c.psa_key_attributes_init();
				c.psa_set_key_type(&attributes, c.PSA_KEY_TYPE_RSA_KEY_PAIR);
				c.psa_set_key_bits(&attributes, 2048);
				c.psa_set_key_usage_flags(&attributes, c.PSA_KEY_USAGE_SIGN_HASH | c.PSA_KEY_USAGE_SIGN_MESSAGE);
				c.psa_set_key_algorithm(&attributes, c.PSA_ALG_RSA_PSS(c.PSA_ALG_ANY_HASH));
				var key: c.psa_key_id_t = 0;
				try checkResult(c.psa_generate_key(&attributes, &key), "psa_generate_key");
				try checkResult(c.mbedtls_pk_wrap_psa(&self.serverKey, key), "mbedtls_pk_wrap_psa");

				try checkResult(c.mbedtls_x509write_crt_set_subject_name(&certificate, "CN=localhost,O=Cubyz,C=Cubyz"), "mbedtls_x509write_crt_set_subject_name");
				try checkResult(c.mbedtls_x509write_crt_set_issuer_name(&certificate, "CN=localhost,O=Cubyz,C=Cubyz"), "mbedtls_x509write_crt_set_issuer_name");
				c.mbedtls_x509write_crt_set_issuer_key(&certificate, &self.serverKey);
				c.mbedtls_x509write_crt_set_subject_key(&certificate, &self.serverKey);

				c.mbedtls_x509write_crt_set_md_alg(&certificate, c.MBEDTLS_MD_SHA256);
				try checkResult(c.mbedtls_x509write_crt_set_validity(&certificate, "20000101000000", "50000101000000"), "mbedtls_x509write_crt_set_validity");

				var buf: [4096]u8 = undefined;
				try checkResult(c.mbedtls_x509write_crt_pem(&certificate, &buf, buf.len), "mbedtls_x509write_crt_pem");

				c.mbedtls_x509_crt_init(&self.serverCertificate);
				try checkResult(c.mbedtls_x509_crt_parse(&self.serverCertificate, &buf, buf.len), "mbedtls_x509_crt_parse");

				try checkResult(c.mbedtls_ssl_conf_own_cert(&self.sslConfig, &self.serverCertificate, &self.serverKey), "mbedtls_ssl_conf_own_cert");
			}

			try checkResult(c.mbedtls_ssl_setup(&self.sslContext, &self.sslConfig), "mbedtls_ssl_setup");
			try checkResult(c.mbedtls_ssl_set_hostname(&self.sslContext, "localhost"), "mbedtls_ssl_set_hostname");
			c.mbedtls_ssl_set_bio(&self.sslContext, self, &mbedTlsSend, null, &mbedTlsReceive);
		}

		pub fn deinit(self: *SecureChannel) void {
			c.mbedtls_ssl_free(&self.sslContext);
			c.mbedtls_ssl_config_free(&self.sslConfig);
			c.mbedtls_x509_crt_free(&self.serverCertificate);
			c.mbedtls_pk_free(&self.serverKey);
			self.super.deinit();
			self.verificationDataForClientSignature.deinit(main.globalAllocator);
		}

		fn checkResult(result: c_int, function: []const u8) !void {
			if (result != 0) {
				std.log.err("TLS function {s} failed with error code {}/0x{x}", .{function, result, result});
				return error.Failed;
			}
		}

		fn debugOutput(_: ?*anyopaque, debugLevel: c_int, fileName: [*c]const u8, lineNumber: c_int, message: [*c]const u8) callconv(.c) void {
			std.log.warn("Mbed TLS level: {} message: {s}, fileName: {s} line: {}", .{debugLevel, message, fileName, lineNumber});
		}

		pub fn connect(self: *SecureChannel, remoteStart: SequenceIndex) void {
			self.super.connect(remoteStart);
		}

		pub fn startTlsHandshake(self: *SecureChannel) !void {
			while (true) {
				self.mutex.lock();
				const result = c.mbedtls_ssl_handshake(&self.sslContext);
				self.mutex.unlock();
				if (result == c.MBEDTLS_ERR_SSL_WANT_READ) {
					main.io.sleep(.fromMilliseconds(10), .awake) catch {};
					continue;
				}
				try checkResult(result, "mbedtls_ssl_handshake");
				break;
			}
		}

		fn mbedTlsSend(self_: ?*anyopaque, data: [*c]const u8, len: usize) callconv(.c) c_int {
			const self: *SecureChannel = @ptrCast(@alignCast(self_.?));
			self.super.sendBuffer.buffer.pushBackSlice(data[0..len]);
			self.super.sendBuffer.nextIndex +%= @intCast(len);
			if (!self.finishedCollectingClientVerificationData) {
				@branchHint(.unlikely);
				if (self.side == .server) {
					self.verificationDataForClientSignature.appendSlice(main.globalAllocator, data[0..len]);
				}
			}
			return @intCast(len);
		}

		fn mbedTlsReceive(self_: ?*anyopaque, data: [*c]u8, len: usize, timeout: u32) callconv(.c) c_int {
			const self: *SecureChannel = @ptrCast(@alignCast(self_.?));
			std.debug.assert(timeout == 0);
			const copyLen = @min(len, self.dataToReceive.len);
			if (copyLen == 0) return c.MBEDTLS_ERR_SSL_WANT_READ;
			@memcpy(data[0..copyLen], self.dataToReceive[0..copyLen]);
			if (!self.finishedCollectingClientVerificationData) {
				@branchHint(.unlikely);
				if (self.side == .client) {
					self.verificationDataForClientSignature.appendSlice(main.globalAllocator, self.dataToReceive[0..copyLen]);
				}
			}
			self.dataToReceive = self.dataToReceive[copyLen..];
			return @intCast(copyLen);
		}

		fn receiveThroughTls(self: *SecureChannel, data: []const u8) !void {
			std.debug.assert(self.dataToReceive.len == 0);
			self.dataToReceive = data;
			var outBuffer: [4096]u8 = undefined;
			while (true) {
				self.mutex.lock();
				const len = c.mbedtls_ssl_read(&self.sslContext, &outBuffer, outBuffer.len);
				self.mutex.unlock();
				if (len == c.MBEDTLS_ERR_SSL_WANT_READ) break;
				if (len == 0) return error.Closed;
				if (len < 0) {
					try checkResult(len, "mbedtls_ssl_read");
				}
				try self.super.receiveBuffer.decryptedBuffer.pushBackSlice(outBuffer[0..@intCast(len)]);
			}
		}

		fn sendThroughTls(self: *SecureChannel, data: []const u8) !void {
			var remaining = data;
			while (remaining.len != 0) {
				self.mutex.lock();
				const len = c.mbedtls_ssl_write(&self.sslContext, remaining.ptr, remaining.len);
				self.mutex.unlock();
				if (len == c.MBEDTLS_ERR_SSL_WANT_READ) continue;
				if (len == 0) return error.Closed;
				if (len < 0) {
					try checkResult(len, "mbedtls_ssl_write");
				}
				remaining = remaining[@intCast(len)..];
			}
		}

		pub fn receive(self: *SecureChannel, conn: *Connection, start: SequenceIndex, data: []const u8) !ReceiveBuffer.ReceiveStatus {
			return self.super.receiveBuffer.receiveSecure(self, conn, start, data);
		}

		pub fn send(self: *SecureChannel, protocolIndex: u8, data: []const u8, time: i64) !void {
			std.debug.assert(c.mbedtls_ssl_is_handshake_over(&self.sslContext) != 0);
			return self.super.sendBuffer.insertMessageSecure(self, protocolIndex, data, time);
		}

		pub fn receiveConfirmationAndGetTimestamp(self: *SecureChannel, start: SequenceIndex) ?SendBuffer.ReceiveConfirmationResult {
			return self.super.receiveConfirmationAndGetTimestamp(start);
		}

		pub fn checkForLosses(self: *SecureChannel, conn: *Connection, time: i64) LossStatus {
			return self.super.checkForLosses(conn, time);
		}

		pub fn sendNextPacketAndGetSize(self: *SecureChannel, conn: *Connection, time: i64, considerForCongestionControl: bool) ?usize {
			return self.super.sendNextPacketAndGetSize(conn, time, considerForCongestionControl);
		}

		pub fn getStatistics(self: *SecureChannel, unconfirmed: *usize, queued: *usize) void {
			self.super.getStatistics(unconfirmed, queued);
		}
	};

	const ChannelId = enum(u8) { // MARK: ChannelId
		lossy = 0,
		secure = 1,
		slow = 2,
		confirmation = 3,
		init = 4,
		keepalive = 5,
		disconnect = 6,
	};

	const ConfirmationData = struct {
		channel: ChannelId,
		start: SequenceIndex,
		receiveTimeStamp: i64,
	};

	const ConnectionState = enum(u8) {
		awaitingClientConnection,
		awaitingServerResponse,
		awaitingClientAcknowledgement,
		connected,
		disconnectDesired,
	};

	pub const HandShakeState = enum(u8) {
		start = 0,
		userData = 1,
		signatureRequest = 2,
		signatureResponse = 3,
		assets = 4,
		serverData = 5,
		complete = 255,
	};

	// MARK: fields

	manager: *ConnectionManager,
	user: ?*main.server.User,

	remoteAddress: Address,
	bruteforcingPort: bool = false,
	bruteForcedPortRange: u16 = 0,

	lossyChannel: Channel, // TODO: Actually allow it to be lossy
	secureChannel: SecureChannel,
	slowChannel: Channel,

	hasRttEstimate: bool = false,
	rttEstimate: f32 = 1000*ms,
	rttUncertainty: f32 = 0.0,
	lastRttSampleTime: i64,
	nextPacketTimestamp: i64,
	nextConfirmationTimestamp: i64,
	queuedConfirmations: main.utils.CircularBufferQueue(ConfirmationData),
	mtuEstimate: u16 = minMtu,

	bandwidthEstimateInBytesPerRtt: f32 = minMtu,
	slowStart: bool = true,
	relativeSendTime: i64 = 0,
	relativeIdleTime: i64 = 0,

	connectionState: Atomic(ConnectionState),
	handShakeState: Atomic(HandShakeState) = .init(.start),
	handShakeWaiting: std.Thread.Condition = std.Thread.Condition{},
	lastConnectionTime: ?i64,

	// To distinguish different connections from the same computer to avoid multiple reconnects
	connectionIdentifier: i64,
	remoteConnectionIdentifier: i64,

	mutex: std.Thread.Mutex = .{},

	pub fn init(manager: *ConnectionManager, ipPort: []const u8, user: ?*main.server.User) !*Connection {
		const result: *Connection = main.globalAllocator.create(Connection);
		errdefer main.globalAllocator.destroy(result);
		result.* = Connection{
			.manager = manager,
			.user = user,
			.remoteAddress = undefined,
			.connectionState = .init(if (user != null) .awaitingClientConnection else .awaitingServerResponse),
			.lastConnectionTime = null,
			.nextPacketTimestamp = networkTimestamp(),
			.nextConfirmationTimestamp = networkTimestamp(),
			.lastRttSampleTime = networkTimestamp() -% 10_000*ms,
			.queuedConfirmations = .init(main.globalAllocator, 1024),
			.lossyChannel = .init(main.random.nextInt(SequenceIndex, &main.seed), 1*ms, .lossy),
			.secureChannel = undefined,
			.slowChannel = .init(main.random.nextInt(SequenceIndex, &main.seed), 100*ms, .slow),
			.connectionIdentifier = networkTimestamp(),
			.remoteConnectionIdentifier = 0,
		};
		errdefer {
			result.lossyChannel.deinit();
			result.slowChannel.deinit();
			result.queuedConfirmations.deinit();
		}
		try result.secureChannel.init(main.random.nextInt(SequenceIndex, &main.seed), 10*ms, .secure, if (user != null) .server else .client);
		errdefer result.secureChannel.deinit();
		if (result.connectionIdentifier == 0) result.connectionIdentifier = 1;

		var splitter = std.mem.splitScalar(u8, ipPort, ':');
		const ip = splitter.first();
		result.remoteAddress.ip = try Socket.resolveIP(ip);
		var port = splitter.rest();
		if (port.len != 0 and port[0] == '?') {
			result.remoteAddress.isSymmetricNAT = true;
			result.bruteforcingPort = true;
			port = port[1..];
		}
		result.remoteAddress.port = std.fmt.parseUnsigned(u16, port, 10) catch blk: {
			if (ip.len != ipPort.len) std.log.err("Could not parse port \"{s}\". Using default port instead.", .{port});
			break :blk settings.defaultPort;
		};

		try result.manager.addConnection(result);
		return result;
	}

	pub fn deinit(self: *Connection) void {
		self.disconnect();
		self.manager.finishCurrentReceive(); // Wait until all currently received packets are done.
		self.lossyChannel.deinit();
		self.secureChannel.deinit();
		self.slowChannel.deinit();
		self.queuedConfirmations.deinit();
		main.globalAllocator.destroy(self);
	}

	pub fn send(self: *Connection, comptime channel: ChannelId, protocolIndex: u8, data: []const u8) void {
		_ = protocols.bytesSent[protocolIndex].fetchAdd(data.len, .monotonic);
		self.mutex.lock();
		defer self.mutex.unlock();

		_ = switch (channel) {
			.lossy => self.lossyChannel.send(protocolIndex, data, networkTimestamp()),
			.secure => self.secureChannel.send(protocolIndex, data, networkTimestamp()),
			.slow => self.slowChannel.send(protocolIndex, data, networkTimestamp()),
			else => comptime unreachable,
		} catch {
			std.log.err("Cannot send any more packets. Disconnecting", .{});
			self.disconnect();
		};
	}

	pub fn isConnected(self: *Connection) bool {
		self.mutex.lock();
		defer self.mutex.unlock();

		return self.connectionState.load(.monotonic) == .connected;
	}

	pub fn isServerSide(conn: *Connection) bool {
		return conn.user != null;
	}

	fn handlePacketLoss(self: *Connection, loss: LossStatus) void {
		if (loss == .noLoss) return;
		self.slowStart = false;
		if (loss == .doubleLoss) {
			self.rttEstimate *= 1.5;
			self.bandwidthEstimateInBytesPerRtt /= 2;
			self.bandwidthEstimateInBytesPerRtt = @max(self.bandwidthEstimateInBytesPerRtt, minMtu);
		}
	}

	fn increaseCongestionBandwidth(self: *Connection, packetLen: SequenceIndex) void {
		const fullPacketLen: f32 = @floatFromInt(packetLen + headerOverhead);
		if (self.slowStart) {
			self.bandwidthEstimateInBytesPerRtt += fullPacketLen;
		} else {
			self.bandwidthEstimateInBytesPerRtt += fullPacketLen/self.bandwidthEstimateInBytesPerRtt*@as(f32, @floatFromInt(self.mtuEstimate)) + fullPacketLen/100.0;
		}
	}

	fn receiveConfirmationPacket(self: *Connection, reader: *utils.BinaryReader, timestamp: i64) !void {
		self.mutex.lock();
		defer self.mutex.unlock();

		var minRtt: f32 = std.math.floatMax(f32);
		var maxRtt: f32 = 1000;
		var sumRtt: f32 = 0;
		var numRtt: f32 = 0;
		while (reader.remaining.len != 0) {
			const channel = try reader.readEnum(ChannelId);
			const timeOffset = 2*@as(i64, try reader.readInt(u16));
			const start = try reader.readInt(SequenceIndex);
			const confirmationResult = switch (channel) {
				.lossy => self.lossyChannel.receiveConfirmationAndGetTimestamp(start) orelse continue,
				.secure => self.secureChannel.receiveConfirmationAndGetTimestamp(start) orelse continue,
				.slow => self.slowChannel.receiveConfirmationAndGetTimestamp(start) orelse continue,
				else => return error.Invalid,
			};
			const rtt: f32 = @floatFromInt(@max(1, timestamp -% confirmationResult.timestamp -% timeOffset));
			numRtt += 1;
			sumRtt += rtt;
			minRtt = @min(minRtt, rtt);
			maxRtt = @max(maxRtt, rtt);
			if (confirmationResult.considerForCongestionControl) {
				self.increaseCongestionBandwidth(confirmationResult.packetLen);
			}
		}
		if (numRtt > 0) {
			// Taken mostly from RFC 6298 with some minor changes
			const averageRtt = sumRtt/numRtt;
			const largestDifference = @max(maxRtt - averageRtt, averageRtt - minRtt, @abs(maxRtt - self.rttEstimate), @abs(self.rttEstimate - minRtt));
			const timeDifference: f32 = @floatFromInt(timestamp -% self.lastRttSampleTime);
			const alpha = 1.0 - std.math.pow(f32, 7.0/8.0, timeDifference/self.rttEstimate);
			const beta = 1.0 - std.math.pow(f32, 3.0/4.0, timeDifference/self.rttEstimate);
			self.rttEstimate = (1 - alpha)*self.rttEstimate + alpha*averageRtt;
			self.rttUncertainty = (1 - beta)*self.rttUncertainty + beta*largestDifference;
			self.lastRttSampleTime = timestamp;
			if (!self.hasRttEstimate) { // Kill the 1 second delay caused by the first packet
				self.nextPacketTimestamp = timestamp;
				self.hasRttEstimate = true;
			}
		}
	}

	fn sendConfirmationPacket(self: *Connection, timestamp: i64) void {
		std.debug.assert(self.manager.threadId == std.Thread.getCurrentId());
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, self.mtuEstimate);
		defer writer.deinit();

		writer.writeEnum(ChannelId, .confirmation);

		while (self.queuedConfirmations.popFront()) |confirmation| {
			writer.writeEnum(ChannelId, confirmation.channel);
			writer.writeInt(u16, std.math.lossyCast(u16, @divTrunc(timestamp -% confirmation.receiveTimeStamp, 2)));
			writer.writeInt(SequenceIndex, confirmation.start);
			if (writer.data.capacity - writer.data.items.len < @sizeOf(ChannelId) + @sizeOf(u16) + @sizeOf(SequenceIndex)) break;
		}

		_ = internalMessageOverhead.fetchAdd(writer.data.items.len + headerOverhead, .monotonic);
		self.manager.send(writer.data.items, self.remoteAddress, null);
	}

	pub fn receive(self: *Connection, data: []const u8) void {
		self.tryReceive(data) catch |err| {
			std.log.err("Got error while processing received network data: {s}", .{@errorName(err)});
			if (@errorReturnTrace()) |trace| {
				std.log.info("{f}", .{std.debug.FormatStackTrace{.stack_trace = trace.*, .tty_config = .no_color}});
			}
			std.log.debug("Packet data: {any}", .{data});
			self.disconnect();
		};
	}

	fn tryReceive(self: *Connection, data: []const u8) !void {
		std.debug.assert(self.manager.threadId == std.Thread.getCurrentId());
		self.lastConnectionTime = networkTimestamp();
		var reader = utils.BinaryReader.init(data);
		const channel = try reader.readEnum(ChannelId);
		if (channel == .init) {
			const remoteConnectionIdentifier = try reader.readInt(i64);
			const isAcknowledgement = reader.remaining.len == 0;
			if (isAcknowledgement) {
				switch (self.connectionState.load(.monotonic)) {
					.awaitingClientAcknowledgement => {
						if (self.remoteConnectionIdentifier == remoteConnectionIdentifier) {
							_ = self.connectionState.cmpxchgStrong(.awaitingClientAcknowledgement, .connected, .monotonic, .monotonic);
						}
					},
					else => {},
				}
				return;
			}
			const lossyStart = try reader.readInt(SequenceIndex);
			const secureStart = try reader.readInt(SequenceIndex);
			const slowStart = try reader.readInt(SequenceIndex);
			switch (self.connectionState.load(.monotonic)) {
				.awaitingClientConnection => {
					self.lossyChannel.connect(lossyStart);
					self.secureChannel.connect(secureStart);
					self.slowChannel.connect(slowStart);
					_ = self.connectionState.cmpxchgStrong(.awaitingClientConnection, .awaitingClientAcknowledgement, .monotonic, .monotonic);
					self.remoteConnectionIdentifier = remoteConnectionIdentifier;
				},
				.awaitingServerResponse => {
					self.lossyChannel.connect(lossyStart);
					self.secureChannel.connect(secureStart);
					self.slowChannel.connect(slowStart);
					_ = self.connectionState.cmpxchgStrong(.awaitingServerResponse, .connected, .monotonic, .monotonic);
					self.remoteConnectionIdentifier = remoteConnectionIdentifier;
				},
				.awaitingClientAcknowledgement => {},
				.connected => {
					if (self.remoteConnectionIdentifier != remoteConnectionIdentifier) { // Reconnection attempt
						if (self.user) |user| {
							self.manager.removeConnection(self);
							main.server.disconnect(user);
						} else {
							std.log.err("Server reconnected?", .{});
							self.disconnect();
						}
						return;
					}
				},
				.disconnectDesired => {},
			}
			// Acknowledge the packet on the client:
			if (self.user == null) {
				var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 1 + @sizeOf(i64));
				defer writer.deinit();

				writer.writeEnum(ChannelId, .init);
				writer.writeInt(i64, self.connectionIdentifier);

				_ = internalMessageOverhead.fetchAdd(writer.data.items.len + headerOverhead, .monotonic);
				self.manager.send(writer.data.items, self.remoteAddress, null);
			}
			return;
		}
		if (self.connectionState.load(.monotonic) != .connected) return; // Reject all non-handshake packets until the handshake is done.
		switch (channel) {
			.lossy => {
				const start = try reader.readInt(SequenceIndex);
				if (try self.lossyChannel.receive(self, start, reader.remaining) == .accepted) {
					self.queuedConfirmations.pushBack(.{
						.channel = channel,
						.start = start,
						.receiveTimeStamp = networkTimestamp(),
					});
				}
			},
			.secure => {
				const start = try reader.readInt(SequenceIndex);
				if (try self.secureChannel.receive(self, start, reader.remaining) == .accepted) {
					self.queuedConfirmations.pushBack(.{
						.channel = channel,
						.start = start,
						.receiveTimeStamp = networkTimestamp(),
					});
				}
			},
			.slow => {
				const start = try reader.readInt(SequenceIndex);
				if (try self.slowChannel.receive(self, start, reader.remaining) == .accepted) {
					self.queuedConfirmations.pushBack(.{
						.channel = channel,
						.start = start,
						.receiveTimeStamp = networkTimestamp(),
					});
				}
			},
			.confirmation => {
				try self.receiveConfirmationPacket(&reader, networkTimestamp());
			},
			.init => unreachable,
			.keepalive => {},
			.disconnect => {
				self.disconnect();
			},
		}

		// TODO: Packet statistics
	}

	pub fn processNextPackets(self: *Connection) void {
		const timestamp = networkTimestamp();
		if (self.lastConnectionTime != null and timestamp -% self.lastConnectionTime.? -% settings.connectionTimeout > 0) {
			std.log.info("timeout", .{});
			self.disconnect();
			return;
		}

		switch (self.connectionState.load(.monotonic)) {
			.awaitingClientConnection => {
				if (timestamp -% self.nextPacketTimestamp < 0) return;
				self.nextPacketTimestamp = timestamp +% 100*ms;
				self.manager.send(&.{@intFromEnum(ChannelId.keepalive)}, self.remoteAddress, null);
			},
			.awaitingServerResponse, .awaitingClientAcknowledgement => {
				// Send the initial packet once every 100 ms.
				if (timestamp -% self.nextPacketTimestamp < 0) return;
				self.nextPacketTimestamp = timestamp +% 100*ms;
				var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 1 + @sizeOf(i64) + 3*@sizeOf(SequenceIndex));
				defer writer.deinit();

				writer.writeEnum(ChannelId, .init);
				writer.writeInt(i64, self.connectionIdentifier);
				writer.writeInt(SequenceIndex, self.lossyChannel.sendBuffer.fullyConfirmedIndex);
				writer.writeInt(SequenceIndex, self.secureChannel.super.sendBuffer.fullyConfirmedIndex);
				writer.writeInt(SequenceIndex, self.slowChannel.sendBuffer.fullyConfirmedIndex);
				_ = internalMessageOverhead.fetchAdd(writer.data.items.len + headerOverhead, .monotonic);
				self.manager.send(writer.data.items, self.remoteAddress, null);
				return;
			},
			.connected => {},
			.disconnectDesired => return,
		}

		self.handlePacketLoss(self.lossyChannel.checkForLosses(self, timestamp));
		self.handlePacketLoss(self.secureChannel.checkForLosses(self, timestamp));
		self.handlePacketLoss(self.slowChannel.checkForLosses(self, timestamp));

		// We don't want to send too many packets at once if there was a period of no traffic.
		if (timestamp -% 10*ms -% self.nextPacketTimestamp > 0) {
			self.relativeIdleTime += timestamp -% 10*ms -% self.nextPacketTimestamp;
			self.nextPacketTimestamp = timestamp -% 10*ms;
		}

		if (self.relativeIdleTime + self.relativeSendTime > @as(i64, @intFromFloat(self.rttEstimate))) {
			self.relativeIdleTime >>= 1;
			self.relativeSendTime >>= 1;
		}

		while (timestamp -% self.nextConfirmationTimestamp > 0 and !self.queuedConfirmations.isEmpty()) {
			self.sendConfirmationPacket(timestamp);
		}

		while (timestamp -% self.nextPacketTimestamp > 0) {
			// Only attempt to increase the congestion bandwidth if we actual use the bandwidth, to prevent unbounded growth
			const considerForCongestionControl = @divFloor(self.relativeSendTime, 2) > self.relativeIdleTime;
			const dataLen = blk: {
				self.mutex.lock();
				defer self.mutex.unlock();
				if (self.lossyChannel.sendNextPacketAndGetSize(self, timestamp, considerForCongestionControl)) |dataLen| break :blk dataLen;
				if (self.secureChannel.sendNextPacketAndGetSize(self, timestamp, considerForCongestionControl)) |dataLen| break :blk dataLen;
				if (self.slowChannel.sendNextPacketAndGetSize(self, timestamp, considerForCongestionControl)) |dataLen| break :blk dataLen;

				break;
			};
			const networkLen: f32 = @floatFromInt(dataLen + headerOverhead);
			const packetTime: i64 = @intFromFloat(@max(1, networkLen/self.bandwidthEstimateInBytesPerRtt*self.rttEstimate));
			self.nextPacketTimestamp +%= packetTime;
			self.relativeSendTime += packetTime;
		}
	}

	pub fn disconnect(self: *Connection) void {
		self.manager.send(&.{@intFromEnum(ChannelId.disconnect)}, self.remoteAddress, null);
		self.connectionState.store(.disconnectDesired, .monotonic);
		if (builtin.os.tag == .windows and !self.isServerSide() and main.server.world != null) {
			main.io.sleep(.fromMilliseconds(10), .awake) catch {}; // Windows is too eager to close the socket, without waiting here we get a ConnectionResetByPeer on the other side.
		}
		self.manager.removeConnection(self);
		if (self.user) |user| {
			main.server.disconnect(user);
		} else {
			self.handShakeWaiting.broadcast();
			main.exitToMenu();
		}
		std.log.info("Disconnected", .{});
	}
};

```

`src/network/authentication.zig`:

```zig
const std = @import("std");

const main = @import("main");
const BinaryWriter = main.utils.BinaryWriter;
const BinaryReader = main.utils.BinaryReader;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ZonElement = main.ZonElement;

var wordlist: ?[2048][]const u8 = null;

fn wordToIndex(word: []const u8) ?u11 {
	if (wordlist == null) return null;
	for (wordlist.?, 0..) |other, i| {
		if (std.mem.eql(u8, word, other)) {
			return @intCast(i);
		}
	}
	return null;
}

pub fn init() void {
	const wordlistString = main.files.cwd().read(main.globalArena, "assets/cubyz/wordlist") catch |err| {
		std.log.err("Got error while reading word list: {s}", .{@errorName(err)});
		return;
	};
	var splitIterator = std.mem.splitScalar(u8, wordlistString, '\n');
	wordlist = @splat(&.{});
	var i: usize = 0;
	while (splitIterator.next()) |word| {
		wordlist.?[i] = std.mem.trim(u8, word, &std.ascii.whitespace);
		i += 1;
	}
}

pub const KeyTypeEnum = enum(u8) {
	ed25519 = 0,
	ecdsaP256Sha256 = 1,
	mldsa44 = 2,

	pub fn getAlgorithmType(self: KeyTypeEnum) type {
		return switch (self) {
			.ed25519 => std.crypto.sign.Ed25519,
			.ecdsaP256Sha256 => std.crypto.sign.ecdsa.EcdsaP256Sha256,
			.mldsa44 => std.crypto.sign.mldsa.MLDSA44,
		};
	}
};

pub const KeyCollection = struct { // Provides multiple methods to allow server hosts to react when one of the methods is compromised
	const Storage = struct {
		pub var ed25519: std.crypto.sign.Ed25519.KeyPair = undefined;
		pub var ecdsaP256Sha256: std.crypto.sign.ecdsa.EcdsaP256Sha256.KeyPair = undefined;
		pub var mldsa44: std.crypto.sign.mldsa.MLDSA44.KeyPair = undefined;
	};

	pub fn init(accountCode: AccountCode) void {
		// These are used to salt the the account code (or seed phrase) for each of the keys so we get unrelated keys in case one of them gets compromised.
		// They were generated by the keyboard mashing RNG
		const keySalts = [_][]const u8{
			"n59zw0qz53q05b73q9a50vmso",
			"4t7z3592a09p85z4piotfh7z",
			"u89564epogz1qi9up5zc94309",
		};
		inline for (comptime std.meta.declarations(Storage), 0..) |decl, i| {
			const hashableString = std.mem.concat(main.stackAllocator.allocator, u8, &.{accountCode.text, keySalts[i]}) catch unreachable;
			defer main.stackAllocator.free(hashableString);
			defer @memset(hashableString, 0);

			var hashedResult: [64]u8 = undefined;

			for (0..2048) |j| {
				const input = if (j == 0) hashableString else &hashedResult;
				var out: [64]u8 = undefined;
				std.crypto.hash.sha2.Sha512.hash(input, &out, .{});
				hashedResult = out;
			}

			const functionType = @TypeOf(@TypeOf(@field(Storage, decl.name)).generateDeterministic);
			const seed = hashedResult[0..@sizeOf(@typeInfo(functionType).@"fn".params[0].type.?)].*;

			@field(Storage, decl.name) = @TypeOf(@field(Storage, decl.name)).generateDeterministic(seed) catch @panic("Failed to generate key pair for " ++ decl.name);
		}
	}

	pub fn getPublicKeys(allocator: NeverFailingAllocator) ZonElement {
		const result = ZonElement.initObject(allocator);
		inline for (comptime std.meta.declarations(Storage)) |decl| {
			const bytes = if (@hasDecl(@TypeOf(@field(Storage, decl.name).public_key), "toBytes"))
				@field(Storage, decl.name).public_key.toBytes()
			else
				@field(Storage, decl.name).public_key.toUncompressedSec1();
			var base64: [std.base64.standard.Encoder.calcSize(bytes.len)]u8 = undefined;
			result.putOwnedString(decl.name, std.base64.standard.Encoder.encode(&base64, &bytes));
		}
		return result;
	}

	pub fn sign(writer: *BinaryWriter, typ: KeyTypeEnum, message: []const u8) void {
		switch (typ) {
			inline else => |_typ| {
				const AlgorithmType = _typ.getAlgorithmType();
				const randomBytes = std.crypto.random.array(u8, AlgorithmType.noise_length);
				const signature = @field(Storage, @tagName(_typ)).sign(message, randomBytes) catch |err| {
					std.debug.panic("Failed to sign message with error {s}. Maybe try reconnecting, if the error persists, I'd suggest creating a new account", .{@errorName(err)});
				};
				writer.writeSlice(&signature.toBytes());
			},
		}
	}
};

pub const PublicKey = union(KeyTypeEnum) {
	ed25519: std.crypto.sign.Ed25519.PublicKey,
	ecdsaP256Sha256: std.crypto.sign.ecdsa.EcdsaP256Sha256.PublicKey,
	mldsa44: std.crypto.sign.mldsa.MLDSA44.PublicKey,

	pub fn initFromBase64(base64: []const u8, typ: KeyTypeEnum) !PublicKey {
		switch (typ) {
			inline else => |_typ| {
				const KeyType = @TypeOf(@field(KeyCollection.Storage, @tagName(_typ)).public_key);
				const length = if (@hasDecl(KeyType, "fromBytes")) KeyType.encoded_length else KeyType.uncompressed_sec1_encoded_length;
				var bytes: [length]u8 = undefined;
				try std.base64.standard.Decoder.decode(&bytes, base64);
				if (@hasDecl(KeyType, "fromBytes")) {
					return @unionInit(PublicKey, @tagName(_typ), try KeyType.fromBytes(bytes));
				} else {
					return @unionInit(PublicKey, @tagName(_typ), try KeyType.fromSec1(&bytes));
				}
			},
		}
	}

	pub fn verifySignature(self: PublicKey, reader: *BinaryReader, message: []const u8) !void {
		switch (@as(KeyTypeEnum, self)) {
			inline else => |tag| {
				const AlgorithmType = tag.getAlgorithmType();
				const signature: error{InvalidEncoding}!AlgorithmType.Signature = AlgorithmType.Signature.fromBytes((try reader.readSlice(AlgorithmType.Signature.encoded_length))[0..AlgorithmType.Signature.encoded_length].*);
				try (try signature).verify(message, @field(self, @tagName(tag)));
			},
		}
	}
};

/// Also known as a seed phrase, implementation is based on BIP39 with some minor changes and limited to one word list
pub const AccountCode = struct {
	text: []u8,

	pub fn initFromUserInput(text: []const u8, failureText: *main.List(u8)) AccountCode {
		var result: main.ListUnmanaged(u8) = .initCapacity(main.stackAllocator, text.len);
		defer result.deinit(main.stackAllocator);
		defer std.crypto.secureZero(u8, result.items);

		const trimmed = std.mem.trim(u8, text, &std.ascii.whitespace);

		for (trimmed) |char| {
			if (std.ascii.isAlphabetic(char)) {
				result.appendAssumeCapacity(std.ascii.toLower(char));
			} else if (std.ascii.isWhitespace(char)) {
				if (result.items[result.items.len - 1] != ' ') {
					result.appendAssumeCapacity(' ');
				}
			} else {
				failureText.print("Account Code contains invalid character '{c}', only ASCII letters and whitespaces are allowed.\n", .{char});
			}
		}
		if (result.items.len == 0) {
			failureText.print("Account Code is empty.\n", .{});
			return .{.text = ""};
		}
		if (result.items[result.items.len - 1] == ' ') _ = result.pop();

		var split = std.mem.splitScalar(u8, result.items, ' ');
		var wordCount: usize = 0;
		var bits: [21]u8 = @splat(0);
		defer std.crypto.secureZero(u8, &bits);
		var failedWordlist: bool = false;
		while (split.next()) |word| {
			wordCount += 1;
			if (wordToIndex(word)) |wordIndex| {
				if (wordCount <= 15) {
					const bitIndex = (wordCount - 1)*11;
					const byteIndex = bitIndex/8;
					const containingRegion: usize = @as(usize, wordIndex) << @intCast(8*3 - 11 - bitIndex%8);

					bits[byteIndex] |= @truncate(containingRegion >> 16);
					bits[byteIndex + 1] |= @truncate(containingRegion >> 8);
					if (byteIndex + 2 < bits.len) bits[byteIndex + 2] |= @truncate(containingRegion);
				}
			} else {
				failureText.print("The {}{s} word of the Account Code is not a part of the wordlist.\n", .{wordCount, if (wordCount == 1) "st" else if (wordCount == 2) "nd" else if (wordCount == 3) "rd" else "th"});
				failedWordlist = true;
			}
		}

		if (wordCount != 15) {
			failureText.print("The Account Code contains an invalid number of words. Should be 15.\n", .{});
			failedWordlist = true;
		}

		if (!failedWordlist) {
			var sha256Result: [32]u8 = undefined;
			defer std.crypto.secureZero(u8, &sha256Result);
			std.crypto.hash.sha2.Sha256.hash(bits[0..20], &sha256Result, .{});
			if (sha256Result[0] >> 3 != bits[20] >> 3) {
				failureText.print("The Account Code has an incorrect checksum.\n", .{});
			}
		}

		return .{
			.text = main.globalAllocator.dupe(u8, result.items),
		};
	}

	pub fn initRandomly() AccountCode {
		if (wordlist == null) @panic("Cannot generate new Account without a valid wordlist.");
		var bits: [21]u8 = undefined;
		defer std.crypto.secureZero(u8, &bits);
		std.crypto.random.bytes(bits[0..20]);
		var sha256Result: [32]u8 = undefined;
		defer std.crypto.secureZero(u8, &sha256Result);
		std.crypto.hash.sha2.Sha256.hash(bits[0..20], &sha256Result, .{});
		bits[20] = sha256Result[0];

		var result: main.ListUnmanaged(u8) = .{};
		defer result.deinit(main.stackAllocator);
		defer std.crypto.secureZero(u8, result.items);

		for (0..15) |i| {
			const bitIndex = i*11;
			const byteIndex = bitIndex/8;

			const containingRegion = @as(usize, bits[byteIndex]) << 16 | @as(usize, bits[byteIndex + 1]) << 8 | if (byteIndex + 2 < bits.len) bits[byteIndex + 2] else 0;
			const wordIndex: u11 = @truncate(containingRegion >> @intCast(8*3 - 11 - bitIndex%8));

			if (i != 0) result.append(main.stackAllocator, ' ');
			result.appendSlice(main.stackAllocator, wordlist.?[wordIndex]);
		}

		return .{
			.text = main.globalAllocator.dupe(u8, result.items),
		};
	}

	pub fn deinit(self: AccountCode) void {
		std.crypto.secureZero(u8, self.text);
		main.globalAllocator.free(self.text);
	}
};

const EncodingType = enum { none, argon2_aes_gcm };

pub const PasswordEncodedAccountCode = struct {
	typ: EncodingType,
	salt: []u8,
	nonce: []u8,
	data: []u8,
	authenticationTag: []u8,

	pub const empty: PasswordEncodedAccountCode = .{.typ = .none, .salt = &.{}, .nonce = &.{}, .data = &.{}, .authenticationTag = &.{}};

	pub fn initFromPassword(allocator: NeverFailingAllocator, accountCode: AccountCode, password: []const u8) PasswordEncodedAccountCode {
		var salt: [32]u8 = std.crypto.random.array(u8, 32);
		const saltBase64 = allocator.alloc(u8, std.base64.standard.Encoder.calcSize(salt.len));
		std.debug.assert(std.base64.standard.Encoder.encode(saltBase64, &salt).len == saltBase64.len);

		var key: [32]u8 = undefined;
		defer std.crypto.secureZero(u8, &key);
		keyFromPassword(.argon2_aes_gcm, saltBase64, password, &key);

		const encryptedBuffer = allocator.alloc(u8, accountCode.text.len);
		var authenticationTag: [std.crypto.aead.aes_gcm.Aes256Gcm.tag_length]u8 = undefined;
		const nonce = std.crypto.random.array(u8, std.crypto.aead.aes_gcm.Aes256Gcm.nonce_length);
		std.crypto.aead.aes_gcm.Aes256Gcm.encrypt(encryptedBuffer, &authenticationTag, accountCode.text, &.{}, nonce, key);

		return .{
			.typ = .argon2_aes_gcm,
			.salt = saltBase64,
			.data = encryptedBuffer,
			.nonce = allocator.dupe(u8, &nonce),
			.authenticationTag = allocator.dupe(u8, &authenticationTag),
		};
	}

	pub fn initUnencoded(allocator: NeverFailingAllocator, accountCode: AccountCode) PasswordEncodedAccountCode {
		return .{
			.typ = .none,
			.salt = &.{},
			.nonce = &.{},
			.data = allocator.dupe(u8, accountCode.text),
			.authenticationTag = &.{},
		};
	}

	pub fn deinit(self: PasswordEncodedAccountCode, allocator: NeverFailingAllocator) void {
		allocator.free(self.salt);
		allocator.free(self.data);
		allocator.free(self.nonce);
		allocator.free(self.authenticationTag);
	}

	pub fn decryptFromPassword(self: PasswordEncodedAccountCode, password: []const u8, failureText: *main.List(u8)) !AccountCode {
		if (self.typ == .none) {
			return AccountCode.initFromUserInput(self.data, failureText);
		}
		var key: [32]u8 = undefined;
		defer std.crypto.secureZero(u8, &key);
		keyFromPassword(self.typ, self.salt, password, &key);

		switch (self.typ) {
			.none => unreachable,
			.argon2_aes_gcm => {
				if (self.authenticationTag.len != std.crypto.aead.aes_gcm.Aes256Gcm.tag_length) return error.Invalid;
				if (self.nonce.len != std.crypto.aead.aes_gcm.Aes256Gcm.nonce_length) return error.Invalid;
				const authenticationTag = self.authenticationTag[0..std.crypto.aead.aes_gcm.Aes256Gcm.tag_length];
				const nonce = self.nonce[0..std.crypto.aead.aes_gcm.Aes256Gcm.nonce_length];
				const decryptedBuffer = main.stackAllocator.alloc(u8, self.data.len);
				defer main.stackAllocator.free(decryptedBuffer);
				defer std.crypto.secureZero(u8, decryptedBuffer);
				try std.crypto.aead.aes_gcm.Aes256Gcm.decrypt(decryptedBuffer, self.data, authenticationTag.*, &.{}, nonce.*, key);
				return AccountCode.initFromUserInput(decryptedBuffer, failureText);
			},
		}
	}

	fn keyFromPassword(typ: EncodingType, salt: []const u8, password: []const u8, key: *[32]u8) void {
		switch (typ) {
			.none => unreachable,
			.argon2_aes_gcm => {
				std.crypto.pwhash.argon2.kdf(main.globalAllocator.allocator, key, password, salt, .{
					.t = 10,
					.m = 32000,
					.p = 1,
				}, .argon2id) catch unreachable;
			},
		}
	}

	pub fn fromZon(allocator: NeverFailingAllocator, zon: ZonElement) !PasswordEncodedAccountCode {
		if (zon == .null) return .empty;
		var self: PasswordEncodedAccountCode = undefined;

		self.typ = std.meta.stringToEnum(EncodingType, zon.get(?[]const u8, "type", null) orelse return error.Invalid) orelse return error.Invalid;
		self.salt = allocator.dupe(u8, zon.get([]const u8, "salt", ""));
		errdefer allocator.free(self.salt);
		if (self.salt.len < 32 and self.typ != .none) return error.Invalid;

		const base64EncodedData = zon.get([]const u8, "data", "");
		self.data = allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(base64EncodedData));
		errdefer allocator.free(self.data);
		try std.base64.standard.Decoder.decode(self.data, base64EncodedData);
		if (self.data.len == 0 and self.typ != .none) return error.Invalid;

		const base64EncodedTag = zon.get([]const u8, "authenticationTag", "");
		self.authenticationTag = allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(base64EncodedTag));
		errdefer allocator.free(self.authenticationTag);
		try std.base64.standard.Decoder.decode(self.authenticationTag, base64EncodedTag);
		if (self.authenticationTag.len == 0 and self.typ != .none) return error.Invalid;

		const base64EncodedNonce = zon.get([]const u8, "nonce", "");
		self.nonce = allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(base64EncodedNonce));
		errdefer allocator.free(self.nonce);
		try std.base64.standard.Decoder.decode(self.nonce, base64EncodedNonce);
		if (self.nonce.len == 0 and self.typ != .none) return error.Invalid;

		return self;
	}

	pub fn toZon(self: PasswordEncodedAccountCode, allocator: NeverFailingAllocator) ZonElement {
		const zon = ZonElement.initObject(allocator);
		zon.put("type", @tagName(self.typ));
		zon.putOwnedString("salt", self.salt);

		const base64EncodedData = main.stackAllocator.alloc(u8, std.base64.standard.Encoder.calcSize(self.data.len));
		defer main.stackAllocator.free(base64EncodedData);
		zon.putOwnedString("data", std.base64.standard.Encoder.encode(base64EncodedData, self.data));

		const base64EncodedTag = main.stackAllocator.alloc(u8, std.base64.standard.Encoder.calcSize(self.authenticationTag.len));
		defer main.stackAllocator.free(base64EncodedTag);
		zon.putOwnedString("authenticationTag", std.base64.standard.Encoder.encode(base64EncodedTag, self.authenticationTag));

		const base64EncodedNonce = main.stackAllocator.alloc(u8, std.base64.standard.Encoder.calcSize(self.nonce.len));
		defer main.stackAllocator.free(base64EncodedNonce);
		zon.putOwnedString("nonce", std.base64.standard.Encoder.encode(base64EncodedNonce, self.nonce));

		return zon;
	}
};

pub fn secureZero(comptime T: type, s: []volatile T) void { // TODO: Remove after zig#31197
	@memset(s, std.mem.zeroes(T));
}

```

`src/network/protocols.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const Block = main.blocks.Block;
const chunk = main.chunk;
const particles = main.particles;
const items = main.items;
const ZonElement = main.ZonElement;
const game = main.game;
const settings = main.settings;
const renderer = main.renderer;
const utils = main.utils;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const BlockUpdate = renderer.mesh_storage.BlockUpdate;

const network = main.network;
const Connection = network.Connection;

var clientReceiveList: [256]?*const fn (*Connection, *utils.BinaryReader) anyerror!void = @splat(null);
var serverReceiveList: [256]?*const fn (*Connection, *utils.BinaryReader) anyerror!void = @splat(null);
var isAsynchronous: [256]bool = @splat(false);
pub var bytesReceived: [256]Atomic(usize) = @splat(.init(0));
pub var bytesSent: [256]Atomic(usize) = @splat(.init(0));

pub fn init() void { // MARK: init()
	inline for (@typeInfo(@This()).@"struct".decls) |decl| {
		const Protocol = @field(@This(), decl.name);
		if (@TypeOf(Protocol) == type and @hasDecl(Protocol, "id")) {
			const id = Protocol.id;
			if (clientReceiveList[id] == null and serverReceiveList[id] == null) {
				if (@hasDecl(Protocol, "clientReceive")) {
					clientReceiveList[id] = Protocol.clientReceive;
				}
				if (@hasDecl(Protocol, "serverReceive")) {
					serverReceiveList[id] = Protocol.serverReceive;
				}
				isAsynchronous[id] = Protocol.asynchronous;
			} else {
				std.log.err("Duplicate list id {}.", .{id});
			}
		}
	}
}

pub fn onReceive(conn: *Connection, protocolIndex: u8, data: []const u8) !void { // MARK: onReceive()
	const protocolReceive = blk: {
		if (conn.isServerSide()) break :blk serverReceiveList[protocolIndex] orelse return error.Invalid;
		break :blk clientReceiveList[protocolIndex] orelse return error.Invalid;
	};

	if (isAsynchronous[protocolIndex]) {
		ProtocolTask.schedule(conn, protocolIndex, protocolReceive, data);
	} else {
		var reader = utils.BinaryReader.init(data);
		protocolReceive(conn, &reader) catch |err| {
			std.log.debug("Got error while executing protocol {} with data {any}", .{protocolIndex, data});
			return err;
		};
	}

	_ = bytesReceived[protocolIndex].fetchAdd(data.len, .monotonic);
}

const ProtocolTask = struct { // MARK: ProtocolTask
	conn: *Connection,
	protocol: u8,
	protocolReceive: *const fn (*Connection, *utils.BinaryReader) anyerror!void,
	data: []const u8,

	const vtable = utils.ThreadPool.VTable{
		.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
		.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
		.run = main.meta.castFunctionSelfToAnyopaque(run),
		.clean = main.meta.castFunctionSelfToAnyopaque(clean),
		.taskType = .misc,
	};

	pub fn schedule(conn: *Connection, protocol: u8, protocolReceive: *const fn (*Connection, *utils.BinaryReader) anyerror!void, data: []const u8) void {
		const task = main.globalAllocator.create(ProtocolTask);
		task.* = ProtocolTask{
			.conn = conn,
			.protocol = protocol,
			.protocolReceive = protocolReceive,
			.data = main.globalAllocator.dupe(u8, data),
		};
		main.threadPool.addTask(task, &vtable);
	}

	pub fn getPriority(_: *ProtocolTask) f32 {
		return std.math.floatMax(f32);
	}

	pub fn isStillNeeded(_: *ProtocolTask) bool {
		return true;
	}

	pub fn run(self: *ProtocolTask) void {
		defer self.clean();
		var reader = utils.BinaryReader.init(self.data);
		self.protocolReceive(self.conn, &reader) catch |err| {
			std.log.err("Got error {s} while executing protocol {} with data {any}", .{@errorName(err), self.protocol, self.data}); // TODO: Maybe disconnect on error
		};
	}

	pub fn clean(self: *ProtocolTask) void {
		main.globalAllocator.free(self.data);
		main.globalAllocator.destroy(self);
	}
};

pub const handShake = struct { // MARK: handShake
	pub const id: u8 = 1;
	pub const asynchronous = false;

	fn clientReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		const newState = try reader.readEnum(Connection.HandShakeState);
		if (@intFromEnum(conn.handShakeState.load(.monotonic)) < @intFromEnum(newState)) {
			conn.handShakeState.store(newState, .monotonic);
			switch (newState) {
				.userData, .signatureResponse => return error.InvalidSide,
				.signatureRequest => {
					const signature1Len = try reader.readVarInt(usize);
					const signature1 = try reader.readSlice(signature1Len);
					const signature2Len = try reader.readVarInt(usize);
					const signature2 = try reader.readSlice(signature2Len);

					var writer: utils.BinaryWriter = .init(main.stackAllocator);
					defer writer.deinit();
					writer.writeEnum(Connection.HandShakeState, .signatureResponse);
					conn.handShakeState.store(.signatureResponse, .monotonic);

					network.authentication.KeyCollection.sign(&writer, std.meta.stringToEnum(network.authentication.KeyTypeEnum, signature1) orelse return error.Invalid, conn.secureChannel.verificationDataForClientSignature.items);
					if (signature2.len != 0) {
						network.authentication.KeyCollection.sign(&writer, std.meta.stringToEnum(network.authentication.KeyTypeEnum, signature2) orelse return error.Invalid, conn.secureChannel.verificationDataForClientSignature.items);
					}
					conn.send(.secure, id, writer.data.items);
				},
				.assets => {
					std.log.info("Received assets.", .{});
					main.files.cubyzDir().deleteTree("serverAssets") catch {}; // Delete old assets.
					var dir = try main.files.cubyzDir().openDir("serverAssets");
					defer dir.close();
					try utils.Compression.unpack(dir, reader.remaining);
				},
				.serverData => {
					const zon = ZonElement.parseFromString(main.stackAllocator, null, reader.remaining);
					defer zon.deinit(main.stackAllocator);
					try conn.manager.world.?.finishHandshake(zon);
					conn.handShakeState.store(.complete, .monotonic);
					conn.handShakeWaiting.broadcast(); // Notify the waiting client thread.
				},
				.start, .complete => {},
			}
		} else {
			// Ignore packages that refer to an unexpected state. Normally those might be packages that were resent by the other side.
		}
	}

	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		const newState = try reader.readEnum(Connection.HandShakeState);
		if (@intFromEnum(conn.handShakeState.load(.monotonic)) < @intFromEnum(newState)) {
			conn.handShakeState.store(newState, .monotonic);
			switch (newState) {
				.userData => {
					conn.secureChannel.finishedCollectingClientVerificationData = true;
					const zon = ZonElement.parseFromString(main.stackAllocator, null, reader.remaining);
					defer zon.deinit(main.stackAllocator);
					const name = zon.get([]const u8, "name", "unnamed");
					if (!std.unicode.utf8ValidateSlice(name)) {
						std.log.err("Received player name with invalid UTF-8 characters.", .{});
						return error.Invalid;
					}
					if (name.len > 500 or main.graphics.TextBuffer.Parser.countVisibleCharacters(name) > 50) {
						std.log.err("Player has too long name with {}/{} characters.", .{main.graphics.TextBuffer.Parser.countVisibleCharacters(name), name.len});
						return error.Invalid;
					}
					const version = zon.get([]const u8, "version", "unknown");
					std.log.info("User {s} joined using version {s}", .{name, version});

					if (!try settings.version.isCompatibleClientVersion(version)) {
						std.log.warn("Version incompatible with server version {s}", .{settings.version.version});
						return error.IncompatibleVersion;
					}

					const keys = zon.getChild("keys");
					try conn.user.?.identifyFromKeysAndName(name, keys);

					var writer: utils.BinaryWriter = .init(main.stackAllocator);
					defer writer.deinit();
					writer.writeEnum(Connection.HandShakeState, .signatureRequest);
					conn.handShakeState.store(.signatureRequest, .monotonic);
					writer.writeVarInt(usize, @tagName(conn.user.?.key).len);
					writer.writeSlice(@tagName(conn.user.?.key));
					if (conn.user.?.legacyKey) |legacyKey| {
						writer.writeVarInt(usize, @tagName(legacyKey).len);
						writer.writeSlice(@tagName(legacyKey));
					} else {
						writer.writeVarInt(usize, 0);
					}
					conn.send(.secure, id, writer.data.items);
				},
				.signatureResponse => {
					try conn.user.?.verifySignatures(reader);
					{
						const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/assets/", .{main.server.world.?.path}) catch unreachable;
						defer main.stackAllocator.free(path);
						var dir = try main.files.cubyzDir().openIterableDir(path);
						defer dir.close();
						var writer = try std.Io.Writer.Allocating.initCapacity(main.stackAllocator.allocator, 16);
						defer writer.deinit();
						try writer.writer.writeByte(@intFromEnum(Connection.HandShakeState.assets));
						try utils.Compression.pack(dir, &writer.writer);
						conn.send(.secure, id, writer.written());
					}
					conn.handShakeState.store(.assets, .monotonic);

					main.server.connect(conn.user.?);
				},
				.assets, .serverData, .signatureRequest => return error.InvalidSide,
				.start, .complete => {},
			}
		} else {
			// Ignore packages that refer to an unexpected state. Normally those might be packages that were resent by the other side.
		}
	}

	pub fn serverSide(conn: *Connection) void {
		conn.handShakeState.store(.start, .monotonic);
	}

	pub fn sendServerPlayerData(conn: *Connection) void {
		const zonObject = ZonElement.initObject(main.stackAllocator);
		defer zonObject.deinit(main.stackAllocator);
		zonObject.put("player", conn.user.?.player.save(main.stackAllocator));
		zonObject.put("player_id", conn.user.?.id);
		zonObject.put("blockPalette", main.server.world.?.blockPalette.storeToZon(main.stackAllocator));
		zonObject.put("itemPalette", main.server.world.?.itemPalette.storeToZon(main.stackAllocator));
		zonObject.put("toolPalette", main.server.world.?.toolPalette.storeToZon(main.stackAllocator));
		zonObject.put("biomePalette", main.server.world.?.biomePalette.storeToZon(main.stackAllocator));

		const outData = zonObject.toStringEfficient(main.stackAllocator, &[1]u8{@intFromEnum(Connection.HandShakeState.serverData)});
		defer main.stackAllocator.free(outData);
		conn.send(.secure, id, outData);
	}

	pub fn clientSide(conn: *Connection, name: []const u8) !void {
		const zonObject = ZonElement.initObject(main.stackAllocator);
		defer zonObject.deinit(main.stackAllocator);
		zonObject.putOwnedString("version", settings.version.version);
		zonObject.putOwnedString("name", name);
		zonObject.put("keys", main.network.authentication.KeyCollection.getPublicKeys(main.stackAllocator));
		const prefix = [1]u8{@intFromEnum(Connection.HandShakeState.userData)};
		const data = zonObject.toStringEfficient(main.stackAllocator, &prefix);
		defer main.stackAllocator.free(data);
		try conn.secureChannel.startTlsHandshake();
		conn.secureChannel.finishedCollectingClientVerificationData = true;
		conn.send(.secure, id, data);

		conn.mutex.lock();
		while (true) {
			conn.handShakeWaiting.timedWait(&conn.mutex, 16_000_000) catch {
				main.heap.GarbageCollection.syncPoint();
				continue;
			};
			break;
		}
		if (conn.connectionState.load(.monotonic) == .disconnectDesired) return error.DisconnectedByServer;
		conn.mutex.unlock();
	}
};

pub const chunkRequest = struct { // MARK: chunkRequest
	pub const id: u8 = 2;
	pub const asynchronous = false;
	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		const basePosition = try reader.readVec(Vec3i);
		conn.user.?.clientUpdatePos = basePosition;
		conn.user.?.renderDistance = try reader.readInt(u16);
		while (reader.remaining.len >= 4) {
			const x: i32 = try reader.readInt(i8);
			const y: i32 = try reader.readInt(i8);
			const z: i32 = try reader.readInt(i8);
			const voxelSizeShift: u5 = try reader.readInt(u5);
			const positionMask = ~((@as(i32, 1) << voxelSizeShift + chunk.chunkShift) - 1);
			const request = chunk.ChunkPosition{
				.wx = (x << voxelSizeShift + chunk.chunkShift) +% (basePosition[0] & positionMask),
				.wy = (y << voxelSizeShift + chunk.chunkShift) +% (basePosition[1] & positionMask),
				.wz = (z << voxelSizeShift + chunk.chunkShift) +% (basePosition[2] & positionMask),
				.voxelSize = @as(u31, 1) << voxelSizeShift,
			};
			conn.user.?.increaseRefCount();
			main.server.world.?.queueChunkAndDecreaseRefCount(request, conn.user.?);
		}
	}
	pub fn sendRequest(conn: *Connection, requests: []chunk.ChunkPosition, basePosition: Vec3i, renderDistance: u16) void {
		if (requests.len == 0) return;
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 14 + 4*requests.len);
		defer writer.deinit();
		writer.writeVec(Vec3i, basePosition);
		writer.writeInt(u16, renderDistance);
		for (requests) |req| {
			const voxelSizeShift: u5 = std.math.log2_int(u31, req.voxelSize);
			const positionMask = ~((@as(i32, 1) << voxelSizeShift + chunk.chunkShift) - 1);
			writer.writeInt(i8, @intCast((req.wx -% (basePosition[0] & positionMask)) >> voxelSizeShift + chunk.chunkShift));
			writer.writeInt(i8, @intCast((req.wy -% (basePosition[1] & positionMask)) >> voxelSizeShift + chunk.chunkShift));
			writer.writeInt(i8, @intCast((req.wz -% (basePosition[2] & positionMask)) >> voxelSizeShift + chunk.chunkShift));
			writer.writeInt(u5, voxelSizeShift);
		}
		conn.send(.secure, id, writer.data.items); // TODO: Can this use the slow channel?
	}
};

pub const chunkTransmission = struct { // MARK: chunkTransmission
	pub const id: u8 = 3;
	pub const asynchronous = true;
	fn clientReceive(_: *Connection, reader: *utils.BinaryReader) !void {
		const pos = chunk.ChunkPosition{
			.wx = try reader.readInt(i32),
			.wy = try reader.readInt(i32),
			.wz = try reader.readInt(i32),
			.voxelSize = try reader.readInt(u31),
		};
		const ch = chunk.Chunk.init(pos);
		try main.server.storage.ChunkCompression.loadChunk(ch, .client, reader.remaining);
		renderer.mesh_storage.updateChunkMesh(ch);
	}
	fn sendChunkOverTheNetwork(conn: *Connection, ch: *chunk.ServerChunk) void {
		ch.mutex.lock();
		const chunkData = main.server.storage.ChunkCompression.storeChunk(main.stackAllocator, &ch.super, .toClient, ch.super.pos.voxelSize != 1);
		ch.mutex.unlock();
		defer main.stackAllocator.free(chunkData);
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, chunkData.len + 16);
		defer writer.deinit();
		writer.writeInt(i32, ch.super.pos.wx);
		writer.writeInt(i32, ch.super.pos.wy);
		writer.writeInt(i32, ch.super.pos.wz);
		writer.writeInt(u31, ch.super.pos.voxelSize);
		writer.writeSlice(chunkData);
		conn.send(.secure, id, writer.data.items); // TODO: Can this use the slow channel?
	}
	pub fn sendChunk(conn: *Connection, ch: *chunk.ServerChunk) void {
		sendChunkOverTheNetwork(conn, ch);
	}
};

pub const playerPosition = struct { // MARK: playerPosition
	pub const id: u8 = 4;
	pub const asynchronous = false;
	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		try conn.user.?.receiveData(reader);
	}
	var lastPositionSent: u16 = 0;
	pub fn send(conn: *Connection, playerPos: Vec3d, playerVel: Vec3d, time: u16) void {
		if (time -% lastPositionSent < 50) {
			return; // Only send at most once every 50 ms.
		}
		lastPositionSent = time;
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 62);
		defer writer.deinit();
		writer.writeInt(u64, @bitCast(playerPos[0]));
		writer.writeInt(u64, @bitCast(playerPos[1]));
		writer.writeInt(u64, @bitCast(playerPos[2]));
		writer.writeInt(u64, @bitCast(playerVel[0]));
		writer.writeInt(u64, @bitCast(playerVel[1]));
		writer.writeInt(u64, @bitCast(playerVel[2]));
		writer.writeInt(u32, @bitCast(game.camera.rotation[0]));
		writer.writeInt(u32, @bitCast(game.camera.rotation[1]));
		writer.writeInt(u32, @bitCast(game.camera.rotation[2]));
		writer.writeInt(u16, time);
		conn.send(.lossy, id, writer.data.items);
	}
};

pub const entityPosition = struct { // MARK: entityPosition
	pub const id: u8 = 6;
	pub const asynchronous = false;
	const type_entity: u8 = 0;
	const type_item: u8 = 1;
	const Type = enum(u8) {
		noVelocityEntity = 0,
		f16VelocityEntity = 1,
		f32VelocityEntity = 2,
		noVelocityItem = 3,
		f16VelocityItem = 4,
		f32VelocityItem = 5,
	};
	fn clientReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		if (conn.manager.world) |world| {
			const time = try reader.readInt(i16);
			const playerPos = try reader.readVec(Vec3d);
			var entityData: main.List(main.entity.EntityNetworkData) = .init(main.stackAllocator);
			defer entityData.deinit();
			var itemData: main.List(main.itemdrop.ItemDropNetworkData) = .init(main.stackAllocator);
			defer itemData.deinit();
			while (reader.remaining.len != 0) {
				const typ = try reader.readEnum(Type);
				switch (typ) {
					.noVelocityEntity, .f16VelocityEntity, .f32VelocityEntity => {
						entityData.append(.{
							.vel = switch (typ) {
								.noVelocityEntity => @splat(0),
								.f16VelocityEntity => @floatCast(try reader.readVec(@Vector(3, f16))),
								.f32VelocityEntity => @floatCast(try reader.readVec(@Vector(3, f32))),
								else => unreachable,
							},
							.id = try reader.readInt(u32),
							.pos = playerPos + try reader.readVec(Vec3f),
							.rot = try reader.readVec(Vec3f),
						});
					},
					.noVelocityItem, .f16VelocityItem, .f32VelocityItem => {
						itemData.append(.{
							.vel = switch (typ) {
								.noVelocityItem => @splat(0),
								.f16VelocityItem => @floatCast(try reader.readVec(@Vector(3, f16))),
								.f32VelocityItem => @floatCast(try reader.readVec(Vec3f)),
								else => unreachable,
							},
							.index = try reader.readInt(u16),
							.pos = playerPos + try reader.readVec(Vec3f),
						});
					},
				}
			}
			main.entity.ClientEntityManager.serverUpdate(time, entityData.items);
			world.itemDrops.readPosition(time, itemData.items);
		}
	}
	pub fn send(conn: *Connection, playerPos: Vec3d, entityData: []main.entity.EntityNetworkData, itemData: []main.itemdrop.ItemDropNetworkData) void {
		var writer = utils.BinaryWriter.init(main.stackAllocator);
		defer writer.deinit();

		writer.writeInt(i16, @truncate(main.timestamp().toMilliseconds()));
		writer.writeVec(Vec3d, playerPos);
		for (entityData) |data| {
			const velocityMagnitudeSqr = vec.lengthSquare(data.vel);
			if (velocityMagnitudeSqr < 1e-6*1e-6) {
				writer.writeEnum(Type, .noVelocityEntity);
			} else if (velocityMagnitudeSqr > 1000*1000) {
				writer.writeEnum(Type, .f32VelocityEntity);
				writer.writeVec(Vec3f, @floatCast(data.vel));
			} else {
				writer.writeEnum(Type, .f16VelocityEntity);
				writer.writeVec(@Vector(3, f16), @floatCast(data.vel));
			}
			writer.writeInt(u32, data.id);
			writer.writeVec(Vec3f, @floatCast(data.pos - playerPos));
			writer.writeVec(Vec3f, data.rot);
		}
		for (itemData) |data| {
			const velocityMagnitudeSqr = vec.lengthSquare(data.vel);
			if (velocityMagnitudeSqr < 1e-6*1e-6) {
				writer.writeEnum(Type, .noVelocityItem);
			} else if (velocityMagnitudeSqr > 1000*1000) {
				writer.writeEnum(Type, .f32VelocityItem);
				writer.writeVec(Vec3f, @floatCast(data.vel));
			} else {
				writer.writeEnum(Type, .f16VelocityItem);
				writer.writeVec(@Vector(3, f16), @floatCast(data.vel));
			}
			writer.writeInt(u16, data.index);
			writer.writeVec(Vec3f, @floatCast(data.pos - playerPos));
		}
		conn.send(.lossy, id, writer.data.items);
	}
};

pub const blockUpdate = struct { // MARK: blockUpdate
	pub const id: u8 = 7;
	pub const asynchronous = false;
	fn clientReceive(_: *Connection, reader: *utils.BinaryReader) !void {
		while (reader.remaining.len != 0) {
			renderer.mesh_storage.updateBlock(.{
				.x = try reader.readInt(i32),
				.y = try reader.readInt(i32),
				.z = try reader.readInt(i32),
				.newBlock = Block.fromInt(try reader.readInt(u32)),
				.blockEntityData = try reader.readSlice(try reader.readInt(usize)),
			});
		}
	}
	pub fn send(conn: *Connection, updates: []const BlockUpdate) void {
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 16);
		defer writer.deinit();

		for (updates) |update| {
			writer.writeInt(i32, update.x);
			writer.writeInt(i32, update.y);
			writer.writeInt(i32, update.z);
			writer.writeInt(u32, update.newBlock.toInt());
			writer.writeInt(usize, update.blockEntityData.len);
			writer.writeSlice(update.blockEntityData);
		}
		conn.send(.secure, id, writer.data.items);
	}
};

pub const entity = struct { // MARK: entity
	pub const id: u8 = 8;
	pub const asynchronous = false;
	fn clientReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		const zonArray = ZonElement.parseFromString(main.stackAllocator, null, reader.remaining);
		defer zonArray.deinit(main.stackAllocator);
		var i: u32 = 0;
		while (i < zonArray.array.items.len) : (i += 1) {
			const elem = zonArray.array.items[i];
			switch (elem) {
				.int => {
					main.entity.ClientEntityManager.removeEntity(elem.as(u32, 0));
				},
				.object => {
					main.entity.ClientEntityManager.addEntity(elem);
				},
				.null => {
					i += 1;
					break;
				},
				else => {
					std.log.err("Unrecognized zon parameters for protocol {}: {s}", .{id, reader.remaining});
				},
			}
		}
		while (i < zonArray.array.items.len) : (i += 1) {
			const elem: ZonElement = zonArray.array.items[i];
			if (elem == .int) {
				conn.manager.world.?.itemDrops.remove(elem.as(u16, 0));
			} else if (!elem.getChild("array").isNull()) {
				conn.manager.world.?.itemDrops.loadFrom(elem);
			} else {
				conn.manager.world.?.itemDrops.addFromZon(elem);
			}
		}
	}
	pub fn send(conn: *Connection, msg: []const u8) void {
		conn.send(.secure, id, msg);
	}
};

pub const genericUpdate = struct { // MARK: genericUpdate
	pub const id: u8 = 9;
	pub const asynchronous = false;

	const UpdateType = enum(u8) {
		gamemode = 0,
		teleport = 1,
		worldEditPos = 2,
		time = 3,
		biome = 4,
		particles = 5,
		clear = 6,
	};

	const WorldEditPosition = enum(u2) {
		selectedPos1 = 0,
		selectedPos2 = 1,
		clear = 2,
	};

	const ClearType = enum(u1) {
		chat = 0,
	};

	fn clientReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		switch (try reader.readEnum(UpdateType)) {
			.gamemode => {
				main.sync.setGamemode(null, try reader.readEnum(main.game.Gamemode));
			},
			.teleport => {
				game.Player.setPosBlocking(try reader.readVec(Vec3d));
			},
			.worldEditPos => {
				const typ = try reader.readEnum(WorldEditPosition);
				const pos: ?Vec3i = switch (typ) {
					.selectedPos1, .selectedPos2 => try reader.readVec(Vec3i),
					.clear => null,
				};
				switch (typ) {
					.selectedPos1 => game.Player.selectionPosition1 = pos,
					.selectedPos2 => game.Player.selectionPosition2 = pos,
					.clear => {
						game.Player.selectionPosition1 = null;
						game.Player.selectionPosition2 = null;
					},
				}
			},
			.time => {
				const world = conn.manager.world.?;
				const expectedTime = try reader.readInt(i64);

				var curTime = world.gameTime.load(.monotonic);
				if (@abs(curTime -% expectedTime) >= 10) {
					world.gameTime.store(expectedTime, .monotonic);
				} else if (curTime < expectedTime) { // world.gameTime++
					while (world.gameTime.cmpxchgWeak(curTime, curTime +% 1, .monotonic, .monotonic)) |actualTime| {
						curTime = actualTime;
					}
				} else { // world.gameTime--
					while (world.gameTime.cmpxchgWeak(curTime, curTime -% 1, .monotonic, .monotonic)) |actualTime| {
						curTime = actualTime;
					}
				}
			},
			.biome => {
				const world = conn.manager.world.?;
				const biomeId = try reader.readInt(u32);

				const newBiome = main.server.terrain.biomes.getByIndex(biomeId) orelse return error.MissingBiome;
				const oldBiome = world.playerBiome.swap(newBiome, .monotonic);
				if (oldBiome != newBiome) {
					main.audio.setMusic(newBiome.preferredMusic);
				}
			},
			.particles => {
				const particleIdLen = try reader.readVarInt(u16);
				const particleId = try reader.readSlice(particleIdLen);
				const pos = try reader.readVec(Vec3d);
				const collides = try reader.readBool();
				const count = try reader.readVarInt(u32);
				const spawnZonLen = try reader.readVarInt(usize);
				const spawnZon = try reader.readSlice(spawnZonLen);

				var emitter: particles.Emitter = undefined;
				if (spawnZonLen != 0) {
					const zon = ZonElement.parseFromString(main.stackAllocator, null, spawnZon);
					defer zon.deinit(main.stackAllocator);
					emitter = .initFromZon(particleId, collides, zon);
				} else {
					const emitterProperties = particles.EmitterProperties{
						.speed = .init(1, 1.5),
						.lifeTime = .init(0.75, 1),
						.randomizeRotation = true,
					};
					emitter = .init(particleId, collides, .{.point = .{}}, emitterProperties, .spread);
				}

				particles.ParticleSystem.addParticlesFromNetwork(emitter, pos, count);
			},
			.clear => {
				const typ = try reader.readEnum(ClearType);
				switch (typ) {
					.chat => main.gui.windowlist.chat.clearChat(),
				}
			},
		}
	}

	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		switch (try reader.readEnum(UpdateType)) {
			.gamemode, .teleport, .time, .biome, .particles, .clear => return error.InvalidSide,
			.worldEditPos => {
				const typ = try reader.readEnum(WorldEditPosition);
				const pos: ?Vec3i = switch (typ) {
					.selectedPos1, .selectedPos2 => try reader.readVec(Vec3i),
					.clear => null,
				};
				switch (typ) {
					.selectedPos1 => conn.user.?.worldEditData.selectionPosition1 = pos.?,
					.selectedPos2 => conn.user.?.worldEditData.selectionPosition2 = pos.?,
					.clear => {
						conn.user.?.worldEditData.selectionPosition1 = null;
						conn.user.?.worldEditData.selectionPosition2 = null;
					},
				}
			},
		}
	}

	pub fn sendGamemode(conn: *Connection, gamemode: main.game.Gamemode) void {
		conn.send(.secure, id, &.{@intFromEnum(UpdateType.gamemode), @intFromEnum(gamemode)});
	}

	pub fn sendTPCoordinates(conn: *Connection, pos: Vec3d) void {
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 25);
		defer writer.deinit();

		writer.writeEnum(UpdateType, .teleport);
		writer.writeVec(Vec3d, pos);

		conn.send(.secure, id, writer.data.items);
	}

	pub fn sendWorldEditPos(conn: *Connection, posType: WorldEditPosition, maybePos: ?Vec3i) void {
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 25);
		defer writer.deinit();

		writer.writeEnum(UpdateType, .worldEditPos);
		writer.writeEnum(WorldEditPosition, posType);
		if (maybePos) |pos| {
			writer.writeVec(Vec3i, pos);
		}

		conn.send(.secure, id, writer.data.items);
	}

	pub fn sendBiome(conn: *Connection, biomeIndex: u32) void {
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 13);
		defer writer.deinit();

		writer.writeEnum(UpdateType, .biome);
		writer.writeInt(u32, biomeIndex);

		conn.send(.secure, id, writer.data.items);
	}

	pub fn sendParticles(conn: *Connection, particleId: []const u8, pos: Vec3d, collides: bool, count: u32, spawnZon: []const u8) void {
		const bufferSize = particleId.len*8 + 32;
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, bufferSize);
		defer writer.deinit();

		writer.writeEnum(UpdateType, .particles);
		writer.writeVarInt(u16, @intCast(particleId.len));
		writer.writeSlice(particleId);
		writer.writeVec(Vec3d, pos);
		writer.writeBool(collides);
		writer.writeVarInt(u32, count);
		writer.writeVarInt(usize, spawnZon.len);
		writer.writeSlice(spawnZon);

		conn.send(.secure, id, writer.data.items);
	}

	pub fn sendTime(conn: *Connection, world: *const main.server.ServerWorld) void {
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 13);
		defer writer.deinit();

		writer.writeEnum(UpdateType, .time);
		writer.writeInt(i64, world.gameTime);

		conn.send(.secure, id, writer.data.items);
	}

	pub fn sendClear(conn: *Connection, cleartype: ClearType) void {
		conn.send(.lossy, id, &.{@intFromEnum(UpdateType.clear), @intFromEnum(cleartype)}); // TODO change channel afer #1879
	}
};

pub const chat = struct { // MARK: chat
	pub const id: u8 = 10;
	pub const asynchronous = false;
	fn clientReceive(_: *Connection, reader: *utils.BinaryReader) !void {
		const msg = reader.remaining;
		if (!std.unicode.utf8ValidateSlice(msg)) {
			std.log.err("Received chat message with invalid UTF-8 characters.", .{});
			return error.Invalid;
		}
		main.gui.windowlist.chat.addMessage(msg);
	}
	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		const msg = reader.remaining;
		if (!std.unicode.utf8ValidateSlice(msg)) {
			std.log.err("Received chat message with invalid UTF-8 characters.", .{});
			return error.Invalid;
		}
		const user = conn.user.?;
		if (msg.len > 10000 or main.graphics.TextBuffer.Parser.countVisibleCharacters(msg) > 1000) {
			std.log.err("Received too long chat message with {}/{} characters.", .{main.graphics.TextBuffer.Parser.countVisibleCharacters(msg), msg.len});
			return error.Invalid;
		}
		main.server.messageFrom(msg, user);
	}

	pub fn send(conn: *Connection, msg: []const u8) void {
		conn.send(.lossy, id, msg);
	}
};

pub const lightMapRequest = struct { // MARK: lightMapRequest
	pub const id: u8 = 11;
	pub const asynchronous = false;
	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		while (reader.remaining.len >= 9) {
			const wx = try reader.readInt(i32);
			const wy = try reader.readInt(i32);
			const voxelSizeShift = try reader.readInt(u5);
			const request = main.server.terrain.SurfaceMap.MapFragmentPosition{
				.wx = wx,
				.wy = wy,
				.voxelSize = @as(u31, 1) << voxelSizeShift,
				.voxelSizeShift = voxelSizeShift,
			};
			if (conn.user) |user| {
				user.increaseRefCount();
				main.server.world.?.queueLightMapAndDecreaseRefCount(request, user);
			}
		}
	}
	pub fn sendRequest(conn: *Connection, requests: []main.server.terrain.SurfaceMap.MapFragmentPosition) void {
		if (requests.len == 0) return;
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 9*requests.len);
		defer writer.deinit();
		for (requests) |req| {
			writer.writeInt(i32, req.wx);
			writer.writeInt(i32, req.wy);
			writer.writeInt(u8, req.voxelSizeShift);
		}
		conn.send(.secure, id, writer.data.items); // TODO: Can this use the slow channel?
	}
};

pub const lightMapTransmission = struct { // MARK: lightMapTransmission
	pub const id: u8 = 12;
	pub const asynchronous = true;
	fn clientReceive(_: *Connection, reader: *utils.BinaryReader) !void {
		const wx = try reader.readInt(i32);
		const wy = try reader.readInt(i32);
		const voxelSizeShift = try reader.readInt(u5);
		const pos = main.server.terrain.SurfaceMap.MapFragmentPosition{
			.wx = wx,
			.wy = wy,
			.voxelSize = @as(u31, 1) << voxelSizeShift,
			.voxelSizeShift = voxelSizeShift,
		};
		const _inflatedData = main.stackAllocator.alloc(u8, main.server.terrain.LightMap.LightMapFragment.mapSize*main.server.terrain.LightMap.LightMapFragment.mapSize*2);
		defer main.stackAllocator.free(_inflatedData);
		const _inflatedLen = try utils.Compression.inflateTo(_inflatedData, reader.remaining);
		if (_inflatedLen != main.server.terrain.LightMap.LightMapFragment.mapSize*main.server.terrain.LightMap.LightMapFragment.mapSize*2) {
			std.log.err("Transmission of light map has invalid size: {}. Input data: {any}, After inflate: {any}", .{_inflatedLen, reader.remaining, _inflatedData[0.._inflatedLen]});
			return error.Invalid;
		}
		var ligthMapReader = utils.BinaryReader.init(_inflatedData);
		const map = main.globalAllocator.create(main.server.terrain.LightMap.LightMapFragment);
		map.init(pos.wx, pos.wy, pos.voxelSize);
		for (&map.startHeight) |*val| {
			val.* = try ligthMapReader.readInt(i16);
		}
		renderer.mesh_storage.updateLightMap(map);
	}
	pub fn sendLightMap(conn: *Connection, map: *main.server.terrain.LightMap.LightMapFragment) void {
		var ligthMapWriter = utils.BinaryWriter.initCapacity(main.stackAllocator, @sizeOf(@TypeOf(map.startHeight)));
		defer ligthMapWriter.deinit();
		for (&map.startHeight) |val| {
			ligthMapWriter.writeInt(i16, val);
		}
		const compressedData = utils.Compression.deflate(main.stackAllocator, ligthMapWriter.data.items, .default);
		defer main.stackAllocator.free(compressedData);
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, 9 + compressedData.len);
		defer writer.deinit();
		writer.writeInt(i32, map.pos.wx);
		writer.writeInt(i32, map.pos.wy);
		writer.writeInt(u8, map.pos.voxelSizeShift);
		writer.writeSlice(compressedData);
		conn.send(.secure, id, writer.data.items); // TODO: Can this use the slow channel?
	}
};

pub const inventory = struct { // MARK: inventory
	pub const id: u8 = 13;
	pub const asynchronous = false;
	fn clientReceive(_: *Connection, reader: *utils.BinaryReader) !void {
		const typ = try reader.readInt(u8);
		if (typ == 0xff) { // Confirmation
			try main.sync.ClientSide.receiveConfirmation(reader);
		} else if (typ == 0xfe) { // Failure
			main.sync.ClientSide.receiveFailure();
		} else {
			try main.sync.ClientSide.receiveSyncOperation(reader);
		}
	}
	fn serverReceive(conn: *Connection, reader: *utils.BinaryReader) !void {
		const user = conn.user.?;
		if (reader.remaining[0] == 0xff) return error.InvalidPacket;
		main.sync.ServerSide.receiveCommand(user, reader);
	}
	pub fn sendCommand(conn: *Connection, payloadType: main.sync.Command.PayloadType, _data: []const u8) void {
		std.debug.assert(conn.user == null);
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, _data.len + 1);
		defer writer.deinit();
		writer.writeEnum(main.sync.Command.PayloadType, payloadType);
		std.debug.assert(writer.data.items[0] != 0xff);
		writer.writeSlice(_data);
		conn.send(.secure, id, writer.data.items);
	}
	pub fn sendConfirmation(conn: *Connection, _data: []const u8) void {
		std.debug.assert(conn.isServerSide());
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, _data.len + 1);
		defer writer.deinit();
		writer.writeInt(u8, 0xff);
		writer.writeSlice(_data);
		conn.send(.secure, id, writer.data.items);
	}
	pub fn sendFailure(conn: *Connection) void {
		std.debug.assert(conn.isServerSide());
		conn.send(.secure, id, &.{0xfe});
	}
	pub fn sendSyncOperation(conn: *Connection, _data: []const u8) void {
		std.debug.assert(conn.isServerSide());
		var writer = utils.BinaryWriter.initCapacity(main.stackAllocator, _data.len + 1);
		defer writer.deinit();
		writer.writeInt(u8, 0);
		writer.writeSlice(_data);
		conn.send(.secure, id, writer.data.items);
	}
};

pub const blockEntityUpdate = struct { // MARK: blockEntityUpdate
	pub const id: u8 = 14;
	pub const asynchronous = false;
	fn serverReceive(_: *Connection, reader: *utils.BinaryReader) !void {
		const pos = try reader.readVec(Vec3i);
		const blockType = try reader.readInt(u16);
		const simChunk = main.server.world.?.getSimulationChunkAndIncreaseRefCount(pos[0], pos[1], pos[2]) orelse return;
		defer simChunk.decreaseRefCount();
		const ch = simChunk.chunk.load(.monotonic) orelse return;
		ch.mutex.lock();
		defer ch.mutex.unlock();
		const block = ch.getBlock(pos[0] - ch.super.pos.wx, pos[1] - ch.super.pos.wy, pos[2] - ch.super.pos.wz);
		if (block.typ != blockType) return;
		const blockEntity = block.blockEntity() orelse return;
		try blockEntity.updateServerData(pos, &ch.super, .{.update = reader});
		ch.setChanged();

		sendServerDataUpdateToClientsInternal(pos, &ch.super, block, blockEntity);
	}

	pub fn sendClientDataUpdateToServer(conn: *Connection, pos: Vec3i) void {
		const mesh = main.renderer.mesh_storage.getMesh(.initFromWorldPos(pos, 1)) orelse return;
		mesh.mutex.lock();
		defer mesh.mutex.unlock();
		const localPos = mesh.chunk.getLocalBlockPos(pos);
		const block = mesh.chunk.data.getValue(localPos.toIndex());
		const blockEntity = block.blockEntity() orelse return;

		var writer = utils.BinaryWriter.init(main.stackAllocator);
		defer writer.deinit();
		writer.writeVec(Vec3i, pos);
		writer.writeInt(u16, block.typ);
		blockEntity.getClientToServerData(pos, mesh.chunk, &writer);

		conn.send(.secure, id, writer.data.items);
	}

	fn sendServerDataUpdateToClientsInternal(pos: Vec3i, ch: *chunk.Chunk, block: Block, blockEntity: *const main.block_entity.BlockEntityType) void {
		var writer = utils.BinaryWriter.init(main.stackAllocator);
		defer writer.deinit();
		blockEntity.getServerToClientData(pos, ch, &writer);

		const users = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
		defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, users);

		for (users) |user| {
			blockUpdate.send(user.conn, &.{.{.x = pos[0], .y = pos[1], .z = pos[2], .newBlock = block, .blockEntityData = writer.data.items}});
		}
	}

	pub fn sendServerDataUpdateToClients(pos: Vec3i) void {
		const simChunk = main.server.world.?.getSimulationChunkAndIncreaseRefCount(pos[0], pos[1], pos[2]) orelse return;
		defer simChunk.decreaseRefCount();
		const ch = simChunk.chunk.load(.monotonic) orelse return;
		ch.mutex.lock();
		defer ch.mutex.unlock();
		const block = ch.getBlock(pos[0] - ch.super.pos.wx, pos[1] - ch.super.pos.wy, pos[2] - ch.super.pos.wz);
		const blockEntity = block.blockEntity() orelse return;

		sendServerDataUpdateToClientsInternal(pos, &ch.super, block, blockEntity);
	}
};

```

`src/particles.zig`:

```zig
const std = @import("std");

const main = @import("main");
const physics = @import("physics.zig");
const chunk_meshing = @import("renderer/chunk_meshing.zig");
const graphics = @import("graphics.zig");
const SSBO = graphics.SSBO;
const TextureArray = graphics.TextureArray;
const Shader = graphics.Shader;
const Image = graphics.Image;
const c = graphics.c;
const game = @import("game.zig");
const ZonElement = @import("zon.zig").ZonElement;
const random = @import("random.zig");
const RandomRange = random.RandomRange;
const vec = @import("vec.zig");
const Mat4f = vec.Mat4f;
const Vec3d = vec.Vec3d;
const Vec4d = vec.Vec4d;
const Vec3f = vec.Vec3f;
const Vec4f = vec.Vec4f;
const Vec3i = vec.Vec3i;
const Vec2f = vec.Vec2f;

pub const ParticleManager = struct {
	var particleTypesSSBO: SSBO = undefined;
	var types: main.ListUnmanaged(ParticleType) = .{};
	var typesLocal: main.ListUnmanaged(ParticleTypeLocal) = .{};
	var textures: main.ListUnmanaged(Image) = .{};
	var emissionTextures: main.ListUnmanaged(Image) = .{};

	var textureArray: TextureArray = undefined;
	var emissionTextureArray: TextureArray = undefined;

	const ParticleIndex = u16;
	var particleTypeHashmap: std.StringHashMapUnmanaged(ParticleIndex) = .{};

	pub fn init() void {
		textureArray = .init();
		emissionTextureArray = .init();
		particleTypesSSBO = SSBO.init();
		ParticleSystem.init();
	}

	pub fn deinit() void {
		textureArray.deinit();
		emissionTextureArray.deinit();
		ParticleSystem.deinit();
		particleTypesSSBO.deinit();
	}

	pub fn reset() void {
		types = .{};
		typesLocal = .{};
		textures = .{};
		emissionTextures = .{};
		particleTypeHashmap = .{};
		ParticleSystem.reset();
	}

	pub fn register(assetsFolder: []const u8, id: []const u8, zon: ZonElement) void {
		const textureId = zon.get(?[]const u8, "texture", null) orelse {
			std.log.err("Particle texture id was not specified for {s} ({s})", .{id, assetsFolder});
			return;
		};

		const particleType = readTextureDataAndParticleType(assetsFolder, textureId);
		var rotVel: RandomRange(f32) = RandomRange(f32).fromZon(zon.getChild("rotationVelocity")) orelse .init(20, 60);
		rotVel.min = std.math.degreesToRadians(rotVel.min);
		rotVel.max = std.math.degreesToRadians(rotVel.max);
		const particleTypeLocal = ParticleTypeLocal{
			.density = RandomRange(f32).fromZon(zon.getChild("density")) orelse .init(2, 3),
			.rotVel = rotVel,
			.dragCoefficient = RandomRange(f32).fromZon(zon.getChild("dragCoefficient")) orelse .init(0.5, 0.6),
		};

		particleTypeHashmap.put(main.worldArena.allocator, id, @intCast(types.items.len)) catch unreachable;
		types.append(main.worldArena, particleType);
		typesLocal.append(main.worldArena, particleTypeLocal);

		std.log.debug("Registered particle type: {s}", .{id});
	}

	fn readTextureDataAndParticleType(assetsFolder: []const u8, textureId: []const u8) ParticleType {
		var typ: ParticleType = undefined;

		const base = readTexture(assetsFolder, textureId, ".png", Image.defaultImage, .isMandatory);
		const emission = readTexture(assetsFolder, textureId, "_emission.png", Image.emptyImage, .isOptional);
		const hasEmission = (emission.imageData.ptr != Image.emptyImage.imageData.ptr);
		const baseAnimationFrameCount = base.height/base.width;
		const emissionAnimationFrameCount = emission.height/emission.width;

		typ.frameCount = @floatFromInt(baseAnimationFrameCount);
		typ.startFrame = @floatFromInt(textures.items.len);
		typ.size = @as(f32, @floatFromInt(base.width))/16;

		var isBaseBroken = false;
		var isEmissionBroken = false;

		if (base.height%base.width != 0) {
			std.log.err("Particle base texture has incorrect dimensions ({}x{}) expected height to be multiple of width for {s} ({s})", .{base.width, base.height, textureId, assetsFolder});
			isBaseBroken = true;
		}
		if (hasEmission and emission.height%emission.width != 0) {
			std.log.err("Particle emission texture has incorrect dimensions ({}x{}) expected height to be multiple of width for {s} ({s})", .{base.width, base.height, textureId, assetsFolder});
			isEmissionBroken = true;
		}
		if (hasEmission and baseAnimationFrameCount != emissionAnimationFrameCount) {
			std.log.err("Particle base texture and emission texture frame count mismatch ({} vs {}) for {s} ({s})", .{baseAnimationFrameCount, emissionAnimationFrameCount, textureId, assetsFolder});
			isEmissionBroken = true;
		}

		createAnimationFrames(&textures, baseAnimationFrameCount, base, isBaseBroken);
		createAnimationFrames(&emissionTextures, baseAnimationFrameCount, emission, isBaseBroken or isEmissionBroken or !hasEmission);

		return typ;
	}

	fn readTexture(assetsFolder: []const u8, textureId: []const u8, suffix: []const u8, default: graphics.Image, status: enum { isOptional, isMandatory }) graphics.Image {
		var splitter = std.mem.splitScalar(u8, textureId, ':');
		const mod = splitter.first();
		const id = splitter.rest();

		const gameAssetsPath = std.fmt.allocPrint(main.stackAllocator.allocator, "assets/{s}/particles/textures/{s}{s}", .{mod, id, suffix}) catch unreachable;
		defer main.stackAllocator.free(gameAssetsPath);

		const worldAssetsPath = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{s}/particles/textures/{s}{s}", .{assetsFolder, mod, id, suffix}) catch unreachable;
		defer main.stackAllocator.free(worldAssetsPath);

		return graphics.Image.readFromFile(main.worldArena, worldAssetsPath) catch graphics.Image.readFromFile(main.worldArena, gameAssetsPath) catch {
			if (status == .isMandatory) std.log.err("Particle texture not found in {s} and {s}.", .{worldAssetsPath, gameAssetsPath});
			return default;
		};
	}

	fn createAnimationFrames(container: *main.ListUnmanaged(Image), frameCount: usize, image: Image, isBroken: bool) void {
		for (0..frameCount) |i| {
			container.append(main.worldArena, if (isBroken) image else extractAnimationSlice(image, i));
		}
	}

	fn extractAnimationSlice(image: Image, frameIndex: usize) Image {
		const frameCount = image.height/image.width;
		const frameHeight = image.height/frameCount;
		const startHeight = frameHeight*frameIndex;
		const endHeight = frameHeight*(frameIndex + 1);
		var result = image;
		result.height = @intCast(frameHeight);
		result.imageData = result.imageData[startHeight*image.width .. endHeight*image.width];
		return result;
	}

	pub fn generateTextureArray() void {
		textureArray.generate(textures.items, true, true);
		emissionTextureArray.generate(emissionTextures.items, true, false);

		particleTypesSSBO.bufferData(ParticleType, ParticleManager.types.items);
		particleTypesSSBO.bind(14);
	}
};

pub const ParticleSystem = struct {
	pub const maxCapacity: u32 = 524288;
	var particleCount: u32 = 0;
	var particles: [maxCapacity]Particle = undefined;
	var particlesLocal: [maxCapacity]ParticleLocal = undefined;
	var previousPlayerPos: Vec3d = undefined;

	var mutex: std.Thread.Mutex = .{};
	var networkCreationQueue: main.ListUnmanaged(struct { emitter: Emitter, pos: Vec3d, count: u32 }) = .{};

	var particlesSSBO: SSBO = undefined;

	var pipeline: graphics.Pipeline = undefined;
	const UniformStruct = struct {
		projectionAndViewMatrix: c_int,
		billboardMatrix: c_int,
		ambientLight: c_int,
	};
	var uniforms: UniformStruct = undefined;

	fn init() void {
		pipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/particles/particles.vert",
			"assets/cubyz/shaders/particles/particles.frag",
			"",
			&uniforms,
			.{},
			.{.depthTest = true, .depthWrite = true},
			.{.attachments = &.{.noBlending}},
		);

		particlesSSBO = SSBO.init();
		particlesSSBO.createDynamicBuffer(Particle, maxCapacity);
		particlesSSBO.bind(13);
	}

	fn deinit() void {
		pipeline.deinit();
		particlesSSBO.deinit();
	}

	fn reset() void {
		networkCreationQueue = .{};
	}

	pub fn update(deltaTime: f32) void {
		mutex.lock();
		if (networkCreationQueue.items.len != 0) {
			for (networkCreationQueue.items) |creation| {
				creation.emitter.spawnParticles(creation.pos, creation.count);
			}
			networkCreationQueue.clearRetainingCapacity();
		}
		mutex.unlock();

		const vecDeltaTime: Vec4f = @as(Vec4f, @splat(deltaTime));
		const playerPos = game.Player.getEyePosBlocking();
		const prevPlayerPosDifference: Vec3f = @floatCast(previousPlayerPos - playerPos);

		var i: u32 = 0;
		while (i < particleCount) {
			const particle = &particles[i];
			const particleLocal = &particlesLocal[i];
			particle.lifeRatio -= particleLocal.lifeVelocity*deltaTime;
			if (particle.lifeRatio < 0) {
				particleCount -= 1;
				particles[i] = particles[particleCount];
				particlesLocal[i] = particlesLocal[particleCount];
				continue;
			}

			var pos: Vec3f = particle.pos;
			var rot = particle.rot;
			const rotVel = particleLocal.velAndRotationVel[3];
			rot += rotVel*deltaTime;

			const airDensity: f32 = physics.airDensity;
			const frictionCoefficient = physics.gravity/physics.airTerminalVelocity*particleLocal.dragCoefficient;
			particleLocal.velAndRotationVel[3] = 0;
			const effectiveGravity: f32 = @floatCast(physics.gravity*(particleLocal.density - airDensity)/particleLocal.density);
			particleLocal.velAndRotationVel[2] -= effectiveGravity*deltaTime;
			particleLocal.velAndRotationVel *= @splat(@exp(-frictionCoefficient*deltaTime));

			if (particleLocal.collides) {
				var v3Pos = playerPos + @as(Vec3d, @floatCast(pos + prevPlayerPosDifference));
				const size = ParticleManager.types.items[particle.typ].size;
				const hitBox: game.collision.Box = .{.min = @splat(size*-0.5), .max = @splat(size*0.5)};

				const posDelta = particleLocal.velAndRotationVel*vecDeltaTime;

				v3Pos[0] += posDelta[0];
				if (game.collision.collides(.client, .x, -posDelta[0], v3Pos, hitBox)) |box| {
					v3Pos[0] = if (posDelta[0] < 0)
						box.max[0] - hitBox.min[0]
					else
						box.min[0] - hitBox.max[0];
				}
				v3Pos[1] += posDelta[1];
				if (game.collision.collides(.client, .y, -posDelta[1], v3Pos, hitBox)) |box| {
					v3Pos[1] = if (posDelta[1] < 0)
						box.max[1] - hitBox.min[1]
					else
						box.min[1] - hitBox.max[1];
				}
				v3Pos[2] += posDelta[2];
				if (game.collision.collides(.client, .z, -posDelta[2], v3Pos, hitBox)) |box| {
					v3Pos[2] = if (posDelta[2] < 0)
						box.max[2] - hitBox.min[2]
					else
						box.min[2] - hitBox.max[2];
				}
				pos = @as(Vec3f, @floatCast(v3Pos - playerPos));
			} else {
				const posDelta = particleLocal.velAndRotationVel*vecDeltaTime;

				pos += Vec3f{posDelta[0], posDelta[1], posDelta[2]} + prevPlayerPosDifference;
			}

			particle.pos = pos;
			particle.rot = rot;
			particleLocal.velAndRotationVel[3] = rotVel;

			const positionf64 = @as(Vec3d, @floatCast(pos)) + playerPos;
			const intPos: vec.Vec3i = @intFromFloat(@floor(positionf64));
			const light: [6]u8 = main.renderer.mesh_storage.getLight(intPos[0], intPos[1], intPos[2]) orelse @splat(0);
			const compressedLight =
				@as(u32, light[0] >> 3) << 25 |
				@as(u32, light[1] >> 3) << 20 |
				@as(u32, light[2] >> 3) << 15 |
				@as(u32, light[3] >> 3) << 10 |
				@as(u32, light[4] >> 3) << 5 |
				@as(u32, light[5] >> 3);
			particle.light = compressedLight;

			i += 1;
		}
		previousPlayerPos = playerPos;
	}

	fn addParticle(typ: u32, particleType: ParticleTypeLocal, pos: Vec3d, vel: Vec3f, collides: bool, properties: EmitterProperties) void {
		const lifeTime = properties.lifeTime.get(&main.seed);
		const density = particleType.density.get(&main.seed);
		const rot = if (properties.randomizeRotation) random.nextFloat(&main.seed)*std.math.pi*2 else 0;
		const rotVel = particleType.rotVel.get(&main.seed);
		const dragCoeff = particleType.dragCoefficient.get(&main.seed);

		particles[particleCount] = Particle{
			.pos = @as(Vec3f, @floatCast(pos - previousPlayerPos)),
			.rot = rot,
			.typ = typ,
		};
		particlesLocal[particleCount] = ParticleLocal{
			.velAndRotationVel = vec.combine(vel, rotVel),
			.lifeVelocity = 1/lifeTime,
			.density = density,
			.dragCoefficient = dragCoeff,
			.collides = collides,
		};
		particleCount += 1;
	}

	pub fn render(projectionMatrix: Mat4f, viewMatrix: Mat4f, ambientLight: Vec3f) void {
		particlesSSBO.bufferSubData(Particle, &particles, particleCount);

		pipeline.bind(null);

		const projectionAndViewMatrix = Mat4f.mul(projectionMatrix, viewMatrix);
		c.glUniformMatrix4fv(uniforms.projectionAndViewMatrix, 1, c.GL_TRUE, @ptrCast(&projectionAndViewMatrix));
		c.glUniform3fv(uniforms.ambientLight, 1, @ptrCast(&ambientLight));

		const billboardMatrix = Mat4f.rotationZ(-game.camera.rotation[2] + std.math.pi*0.5)
			.mul(Mat4f.rotationY(game.camera.rotation[0] - std.math.pi*0.5));
		c.glUniformMatrix4fv(uniforms.billboardMatrix, 1, c.GL_TRUE, @ptrCast(&billboardMatrix));

		c.glActiveTexture(c.GL_TEXTURE0);
		ParticleManager.textureArray.bind();
		c.glActiveTexture(c.GL_TEXTURE1);
		ParticleManager.emissionTextureArray.bind();

		c.glBindVertexArray(chunk_meshing.vao);

		const maxQuads = chunk_meshing.maxQuadsInIndexBuffer;
		const count = std.math.divCeil(u32, particleCount, maxQuads) catch unreachable;
		for (0..count) |i| {
			const particleOffset = (maxQuads*4)*i;
			const particleCurrentCount: u32 = @min(maxQuads, particleCount - maxQuads*i);
			c.glDrawElementsBaseVertex(c.GL_TRIANGLES, @intCast(particleCurrentCount*6), c.GL_UNSIGNED_INT, null, @intCast(particleOffset));
		}
	}

	pub fn getParticleCount() u32 {
		return particleCount;
	}

	pub fn addParticlesFromNetwork(emitter: Emitter, pos: Vec3d, count: u32) void {
		mutex.lock();
		defer mutex.unlock();
		networkCreationQueue.append(main.worldArena, .{.emitter = emitter, .pos = pos, .count = count});
	}
};

pub const EmitterProperties = struct {
	speed: RandomRange(f32),
	lifeTime: RandomRange(f32),
	randomizeRotation: bool,

	pub fn parse(zon: ZonElement) EmitterProperties {
		return EmitterProperties{
			.speed = RandomRange(f32).fromZon(zon.getChild("speed")) orelse .init(1, 1.5),
			.lifeTime = RandomRange(f32).fromZon(zon.getChild("lifeTime")) orelse .init(0.75, 1),
			.randomizeRotation = zon.get(bool, "randomRotate", true),
		};
	}
};

pub const DirectionMode = union(enum) {
	// The particle goes in the direction away from the center
	spread: void,
	// The particle goes in a random direction
	scatter: void,
	// The particle goes in the specified direction
	direction: Vec3f,

	pub fn parse(zon: ZonElement) !DirectionMode {
		const dirModeName = zon.get([]const u8, "mode", @tagName(DirectionMode.spread));
		const dirMode = std.meta.stringToEnum(std.meta.Tag(DirectionMode), dirModeName) orelse return error.InvalidDirectionMode;
		return switch (dirMode) {
			.direction => .{.direction = zon.get(Vec3f, "direction", .{0, 0, 1})},
			inline else => |mode| @unionInit(DirectionMode, @tagName(mode), {}),
		};
	}
};

pub const Emitter = struct {
	typ: u16 = 0,
	particleType: ParticleTypeLocal,
	collides: bool,
	spawnShape: SpawnShape,
	properties: EmitterProperties,
	mode: DirectionMode,

	pub const SpawnShape = union(enum) {
		point: SpawnPoint,
		sphere: SpawnSphere,
		cube: SpawnCube,

		pub fn spawn(self: SpawnShape, pos: Vec3d, properties: EmitterProperties, mode: DirectionMode) struct { Vec3d, Vec3f } {
			return switch (self) {
				inline else => |shape| shape.spawn(pos, properties, mode),
			};
		}

		pub fn parse(zon: ZonElement) !SpawnShape {
			const typeZon = zon.get([]const u8, "shape", @tagName(SpawnShape.point));
			const spawnType = std.meta.stringToEnum(std.meta.Tag(SpawnShape), typeZon) orelse return error.InvalidType;
			return switch (spawnType) {
				inline else => |shape| @unionInit(SpawnShape, @tagName(shape), try @FieldType(SpawnShape, @tagName(shape)).parse(zon)),
			};
		}
	};

	pub const SpawnPoint = struct {
		pub fn spawn(_: SpawnPoint, pos: Vec3d, properties: EmitterProperties, mode: DirectionMode) struct { Vec3d, Vec3f } {
			const particlePos = pos;
			const speed: Vec3f = @splat(properties.speed.get(&main.seed));
			const dir: Vec3f = switch (mode) {
				.direction => |dir| vec.normalize(dir),
				.scatter, .spread => vec.normalize(random.nextFloatVectorSigned(3, &main.seed)),
			};
			const particleVel = dir*speed;

			return .{particlePos, particleVel};
		}

		pub fn parse(_: ZonElement) !SpawnPoint {
			return SpawnPoint{};
		}
	};

	pub const SpawnSphere = struct {
		radius: f32,

		pub fn spawn(self: SpawnSphere, pos: Vec3d, properties: EmitterProperties, mode: DirectionMode) struct { Vec3d, Vec3f } {
			const spawnPos: Vec3f = @splat(self.radius);
			var offsetPos: Vec3f = undefined;
			while (true) {
				offsetPos = random.nextFloatVectorSigned(3, &main.seed);
				if (vec.lengthSquare(offsetPos) <= 1) break;
			}
			const particlePos = pos + @as(Vec3d, @floatCast(offsetPos*spawnPos));
			const speed: Vec3f = @splat(properties.speed.get(&main.seed));
			const dir: Vec3f = switch (mode) {
				.direction => |dir| vec.normalize(dir),
				.scatter => vec.normalize(random.nextFloatVectorSigned(3, &main.seed)),
				.spread => @floatCast(offsetPos),
			};
			const particleVel = dir*speed;

			return .{particlePos, particleVel};
		}

		pub fn parse(zon: ZonElement) !SpawnSphere {
			return SpawnSphere{
				.radius = zon.get(f32, "radius", 1),
			};
		}
	};

	pub const SpawnCube = struct {
		size: Vec3f,

		pub fn spawn(self: SpawnCube, pos: Vec3d, properties: EmitterProperties, mode: DirectionMode) struct { Vec3d, Vec3f } {
			const spawnPos: Vec3f = self.size;
			const offsetPos: Vec3f = random.nextFloatVectorSigned(3, &main.seed);
			const particlePos = pos + @as(Vec3d, @floatCast(offsetPos*spawnPos));
			const speed: Vec3f = @splat(properties.speed.get(&main.seed));
			const dir: Vec3f = switch (mode) {
				.direction => |dir| vec.normalize(dir),
				.scatter => vec.normalize(random.nextFloatVectorSigned(3, &main.seed)),
				.spread => vec.normalize(@as(Vec3f, @floatCast(offsetPos))),
			};
			const particleVel = dir*speed;

			return .{particlePos, particleVel};
		}

		pub fn parse(zon: ZonElement) !SpawnCube {
			return SpawnCube{
				.size = zon.get(?Vec3f, "size", null) orelse @splat(zon.get(f32, "size", 1)),
			};
		}
	};

	pub fn init(id: []const u8, collides: bool, spawnShape: SpawnShape, properties: EmitterProperties, mode: DirectionMode) Emitter {
		const typ = ParticleManager.particleTypeHashmap.get(id) orelse 0;

		return Emitter{
			.typ = typ,
			.particleType = ParticleManager.typesLocal.items[typ],
			.collides = collides,
			.spawnShape = spawnShape,
			.properties = properties,
			.mode = mode,
		};
	}

	pub fn initFromZon(id: []const u8, collides: bool, zon: ZonElement) Emitter {
		const typ = ParticleManager.particleTypeHashmap.get(id) orelse 0;
		const mode = DirectionMode.parse(zon) catch |err| blk: {
			std.log.err("Error while parsing direction mode: \"{s}\"", .{@errorName(err)});
			break :blk .spread;
		};
		const spawnShape = Emitter.SpawnShape.parse(zon) catch |err| blk: {
			std.log.err("Error while parsing particle spawn data: \"{s}\"", .{@errorName(err)});
			break :blk Emitter.SpawnShape{.point = .{}};
		};

		return Emitter{
			.typ = typ,
			.particleType = ParticleManager.typesLocal.items[typ],
			.collides = collides,
			.spawnShape = spawnShape,
			.properties = EmitterProperties.parse(zon),
			.mode = mode,
		};
	}

	pub fn spawnParticles(self: Emitter, pos: Vec3d, spawnCount: u32) void {
		const count = @min(spawnCount, ParticleSystem.maxCapacity - ParticleSystem.particleCount);
		for (0..count) |_| {
			const particlePos, const particleVel = self.spawnShape.spawn(pos, self.properties, self.mode);

			ParticleSystem.addParticle(self.typ, self.particleType, particlePos, particleVel, self.collides, self.properties);
		}
	}
};

pub const ParticleType = struct {
	frameCount: f32,
	startFrame: f32,
	size: f32,
};

pub const ParticleTypeLocal = struct {
	density: RandomRange(f32),
	rotVel: RandomRange(f32),
	dragCoefficient: RandomRange(f32),
};

pub const Particle = extern struct {
	pos: [3]f32 align(16),
	rot: f32 = 0,
	lifeRatio: f32 = 1,
	light: u32 = 0,
	typ: u32,
	// 4 bytes left for use
};

pub const ParticleLocal = struct {
	velAndRotationVel: Vec4f,
	lifeVelocity: f32,
	density: f32,
	dragCoefficient: f32,
	collides: bool,
};

```

`src/physics.zig`:

```zig
const std = @import("std");

const items = @import("items.zig");
const main = @import("main");
const vec = @import("vec.zig");
const Vec2f = vec.Vec2f;
const Vec3f = vec.Vec3f;
const Vec3d = vec.Vec3d;
const settings = @import("settings.zig");
const Player = main.game.Player;
const collision = main.game.collision;
const camera = main.game.camera;

pub const gravity = 30.0;
pub const airTerminalVelocity = 90.0;
pub const airDensity = 0.001;
const playerDensity = 1.2;

pub fn calculateProperties() void {
	if (main.renderer.mesh_storage.getBlockFromRenderThread(@intFromFloat(@floor(Player.super.pos[0])), @intFromFloat(@floor(Player.super.pos[1])), @intFromFloat(@floor(Player.super.pos[2]))) != null) {
		Player.volumeProperties = collision.calculateVolumeProperties(.client, Player.super.pos, Player.outerBoundingBox, .{.density = airDensity, .terminalVelocity = airTerminalVelocity, .maxDensity = airDensity, .mobileFriction = 1.0/airTerminalVelocity});
		const groundFriction = if (!Player.onGround and !Player.isFlying.load(.monotonic)) 0 else collision.calculateSurfaceProperties(.client, Player.super.pos, Player.outerBoundingBox, 20).friction;
		const volumeFrictionCoeffecient: f32 = @floatCast(gravity/Player.volumeProperties.terminalVelocity);
		const mobileFriction: f32 = @floatCast(gravity*Player.volumeProperties.mobileFriction);
		Player.currentFriction = if (Player.isFlying.load(.monotonic)) 20 else groundFriction + volumeFrictionCoeffecient;
		Player.mobileFriction = if (Player.isFlying.load(.monotonic)) 20 else groundFriction + mobileFriction;
	}
}

pub fn update(deltaTime: f64, inputAcc: Vec3d, jumping: bool) void { // MARK: update()
	var move: Vec3d = .{0, 0, 0};
	if (main.renderer.mesh_storage.getBlockFromRenderThread(@intFromFloat(@floor(Player.super.pos[0])), @intFromFloat(@floor(Player.super.pos[1])), @intFromFloat(@floor(Player.super.pos[2]))) != null) {
		const effectiveGravity = gravity*(playerDensity - Player.volumeProperties.density)/playerDensity;
		const volumeFrictionCoeffecient: f32 = @floatCast(gravity/Player.volumeProperties.terminalVelocity);
		var acc = inputAcc;
		if (!Player.isFlying.load(.monotonic)) {
			acc[2] -= effectiveGravity;
		}

		const baseFrictionCoefficient: f32 = Player.currentFriction;
		var directionalFrictionCoefficients: Vec3f = @splat(0);

		// This our model for movement on a single frame:
		// dv/dt = a - λ·v
		// dx/dt = v
		// Where a is the acceleration and λ is the friction coefficient
		inline for (0..3) |i| {
			var frictionCoefficient = baseFrictionCoefficient + directionalFrictionCoefficients[i];
			if (i == 2 and jumping) { // No friction while jumping
				// Here we want to ensure a specified jump height under air friction.
				const jumpVelocity = @sqrt(Player.jumpHeight*gravity*2);
				Player.super.vel[i] = @max(jumpVelocity, Player.super.vel[i] + jumpVelocity);
				frictionCoefficient = volumeFrictionCoeffecient;
			}
			const v_0 = Player.super.vel[i];
			const a = acc[i];
			// Here the solution can be easily derived:
			// dv/dt = a - λ·v
			// (1 - a)/v dv = -λ dt
			// (1 - a)ln(v) + C = -λt
			// v(t) = a/λ + c_1 e^(λ (-t))
			// v(0) = a/λ + c_1 = v₀
			// c_1 = v₀ - a/λ
			// x(t) = ∫v(t) dt
			// x(t) = ∫a/λ + c_1 e^(λ (-t)) dt
			// x(t) = a/λt - c_1/λ e^(λ (-t)) + C
			// With x(0) = 0 we get C = c_1/λ
			// x(t) = a/λt - c_1/λ e^(λ (-t)) + c_1/λ
			const c_1 = v_0 - a/frictionCoefficient;
			Player.super.vel[i] = a/frictionCoefficient + c_1*@exp(-frictionCoefficient*deltaTime);
			move[i] = a/frictionCoefficient*deltaTime - c_1/frictionCoefficient*@exp(-frictionCoefficient*deltaTime) + c_1/frictionCoefficient;
		}

		acc = @splat(0);
		// Apply springs to the eye position:
		var springConstants = Vec3d{0, 0, 0};
		{
			const forceMultipliers = Vec3d{
				400,
				400,
				400,
			};
			const frictionMultipliers = Vec3d{
				30,
				30,
				30,
			};
			const strength = (-Player.eye.pos)/(Player.eye.box.max - Player.eye.box.min);
			const force = strength*forceMultipliers;
			const friction = frictionMultipliers;
			springConstants += forceMultipliers/(Player.eye.box.max - Player.eye.box.min);
			directionalFrictionCoefficients += @floatCast(friction);
			acc += force;
		}

		// This our model for movement of the eye position on a single frame:
		// dv/dt = a - k*x - λ·v
		// dx/dt = v
		// Where a is the acceleration, k is the spring constant and λ is the friction coefficient
		inline for (0..3) |i| blk: {
			if (Player.eye.step[i]) {
				const oldPos = Player.eye.pos[i];
				const newPos = oldPos + Player.eye.vel[i]*deltaTime;
				if (newPos*std.math.sign(Player.eye.vel[i]) <= -0.1) {
					Player.eye.pos[i] = newPos;
					break :blk;
				} else {
					Player.eye.step[i] = false;
				}
			}
			if (i == 2 and Player.eye.coyote > 0) {
				break :blk;
			}
			const frictionCoefficient = directionalFrictionCoefficients[i];
			const v_0 = Player.eye.vel[i];
			const k = springConstants[i];
			const a = acc[i];
			// here we need to solve the full equation:
			// The solution of this differential equation is given by
			// x(t) = a/k + c_1 e^(1/2 t (-c_3 - λ)) + c_2 e^(1/2 t (c_3 - λ))
			// With c_3 = sqrt(λ^2 - 4 k) which can be imaginary
			// v(t) is just the derivative, given by
			// v(t) = 1/2 (-c_3 - λ) c_1 e^(1/2 t (-c_3 - λ)) + (1/2 (c_3 - λ)) c_2 e^(1/2 t (c_3 - λ))
			// Now for simplicity we set x(0) = 0 and v(0) = v₀
			// a/k + c_1 + c_2 = 0 → c_1 = -a/k - c_2
			// (-c_3 - λ) c_1 + (c_3 - λ) c_2 = 2v₀
			// → (-c_3 - λ) (-a/k - c_2) + (c_3 - λ) c_2 = 2v₀
			// → (-c_3 - λ) (-a/k) - (-c_3 - λ)c_2 + (c_3 - λ) c_2 = 2v₀
			// → ((c_3 - λ) - (-c_3 - λ))c_2 = 2v₀ - (c_3 + λ) (a/k)
			// → (c_3 - λ + c_3 + λ)c_2 = 2v₀ - (c_3 + λ) (a/k)
			// → 2 c_3 c_2 = 2v₀ - (c_3 + λ) (a/k)
			// → c_2 = (2v₀ - (c_3 + λ) (a/k))/(2 c_3)
			// → c_2 = v₀/c_3 - (1 + λ/c_3)/2 (a/k)
			// In total we get:
			// c_3 = sqrt(λ^2 - 4 k)
			// c_2 = (2v₀ - (c_3 + λ) (a/k))/(2 c_3)
			// c_1 = -a/k - c_2
			const c_3 = vec.Complex.fromSqrt(frictionCoefficient*frictionCoefficient - 4*k);
			const c_2 = (((c_3.addScalar(frictionCoefficient).mulScalar(-a/k)).addScalar(2*v_0)).div(c_3.mulScalar(2)));
			const c_1 = c_2.addScalar(a/k).negate();
			// v(t) = 1/2 (-c_3 - λ) c_1 e^(1/2 t (-c_3 - λ)) + (1/2 (c_3 - λ)) c_2 e^(1/2 t (c_3 - λ))
			// x(t) = a/k + c_1 e^(1/2 t (-c_3 - λ)) + c_2 e^(1/2 t (c_3 - λ))
			const firstTerm = c_1.mul((c_3.negate().subScalar(frictionCoefficient)).mulScalar(deltaTime/2).exp());
			const secondTerm = c_2.mul((c_3.subScalar(frictionCoefficient)).mulScalar(deltaTime/2).exp());
			Player.eye.vel[i] = firstTerm.mul(c_3.negate().subScalar(frictionCoefficient).mulScalar(0.5)).add(secondTerm.mul((c_3.subScalar(frictionCoefficient)).mulScalar(0.5))).val[0];
			Player.eye.pos[i] += firstTerm.add(secondTerm).addScalar(a/k).val[0];
		}
	}

	if (!Player.isGhost.load(.monotonic)) {
		Player.mutex.lock();
		defer Player.mutex.unlock();

		const hitBox = Player.outerBoundingBox;
		var steppingHeight = Player.steppingHeight()[2];
		if (Player.super.vel[2] > 0) {
			steppingHeight = Player.super.vel[2]*Player.super.vel[2]/gravity/2;
		}
		steppingHeight = @min(steppingHeight, Player.eye.pos[2] - Player.eye.box.min[2]);

		const slipLimit = 0.25*Player.currentFriction;

		const xMovement = collision.collideOrStep(.client, .x, move[0], Player.super.pos, hitBox, steppingHeight);
		Player.super.pos += xMovement;
		if (Player.crouching and Player.onGround and @abs(Player.super.vel[0]) < slipLimit) {
			if (collision.collides(.client, .x, 0, Player.super.pos - Vec3d{0, 0, 1}, hitBox) == null) {
				Player.super.pos -= xMovement;
				Player.super.vel[0] = 0;
			}
		}

		const yMovement = collision.collideOrStep(.client, .y, move[1], Player.super.pos, hitBox, steppingHeight);
		Player.super.pos += yMovement;
		if (Player.crouching and Player.onGround and @abs(Player.super.vel[1]) < slipLimit) {
			if (collision.collides(.client, .y, 0, Player.super.pos - Vec3d{0, 0, 1}, hitBox) == null) {
				Player.super.pos -= yMovement;
				Player.super.vel[1] = 0;
			}
		}

		if (xMovement[0] != move[0]) {
			Player.super.vel[0] = 0;
		}
		if (yMovement[1] != move[1]) {
			Player.super.vel[1] = 0;
		}

		const stepAmount = xMovement[2] + yMovement[2];
		if (stepAmount > 0) {
			if (Player.eye.coyote <= 0) {
				Player.eye.vel[2] = @max(1.5*vec.length(Player.super.vel), Player.eye.vel[2], 4);
				Player.eye.step[2] = true;
				if (Player.super.vel[2] > 0) {
					Player.eye.vel[2] = Player.super.vel[2];
					Player.eye.step[2] = false;
				}
			} else {
				Player.eye.coyote = 0;
			}
			Player.eye.pos[2] -= stepAmount;
			move[2] = -0.01;
			Player.onGround = true;
		}

		const wasOnGround = Player.onGround;
		Player.onGround = false;
		Player.super.pos[2] += move[2];
		if (collision.collides(.client, .z, -move[2], Player.super.pos, hitBox)) |box| {
			if (move[2] < 0) {
				if (!wasOnGround) {
					Player.eye.vel[2] = Player.super.vel[2];
					Player.eye.pos[2] -= (box.max[2] - hitBox.min[2] - Player.super.pos[2]);
				}
				Player.onGround = true;
				Player.super.pos[2] = box.max[2] - hitBox.min[2];
				Player.eye.coyote = 0;
			} else {
				Player.super.pos[2] = box.min[2] - hitBox.max[2];
			}
			var bounciness = if (Player.isFlying.load(.monotonic)) 0 else collision.calculateSurfaceProperties(.client, Player.super.pos, Player.outerBoundingBox, 0.0).bounciness;
			if (Player.crouching) {
				bounciness *= 0.5;
			}
			var velocityChange: f64 = undefined;

			if (bounciness != 0.0 and Player.super.vel[2] < -3.0) {
				velocityChange = Player.super.vel[2]*@as(f64, @floatCast(1 - bounciness));
				Player.super.vel[2] = -Player.super.vel[2]*bounciness;
				Player.jumpCoyote = Player.jumpCoyoteTimeConstant + deltaTime;
				Player.eye.vel[2] *= 2;
			} else {
				velocityChange = Player.super.vel[2];
				Player.super.vel[2] = 0;
			}
			const damage: f32 = @floatCast(@round(@max((velocityChange*velocityChange)/(2*gravity) - 7, 0))/2);
			if (damage > 0.01) {
				main.sync.addHealth(-damage, .fall, .client, Player.id);
			}

			// Always unstuck upwards for now
			while (collision.collides(.client, .z, 0, Player.super.pos, hitBox)) |_| {
				Player.super.pos[2] += 1;
			}
		} else if (wasOnGround and move[2] < 0) {
			// If the player drops off a ledge, they might just be walking over a small gap, so lock the y position of the eyes that long.
			// This calculates how long the player has to fall until we know they're not walking over a small gap.
			// We add deltaTime because we subtract deltaTime at the bottom of update
			Player.eye.coyote = @sqrt(2*Player.steppingHeight()[2]/gravity) + deltaTime;
			Player.jumpCoyote = Player.jumpCoyoteTimeConstant + deltaTime;
			Player.eye.pos[2] -= move[2];
		} else if (Player.eye.coyote > 0) {
			Player.eye.pos[2] -= move[2];
		}
		collision.touchBlocks(&Player.super, hitBox, .client, deltaTime);
	} else {
		Player.super.pos += move;
	}

	// Clamp the eye.position and subtract eye coyote time.
	Player.eye.pos = @max(Player.eye.box.min, @min(Player.eye.pos, Player.eye.box.max));
	Player.eye.coyote -= deltaTime;
	Player.jumpCoyote -= deltaTime;
}

```

`src/random.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec2f = main.vec.Vec2f;
const Vec2i = main.vec.Vec2i;
const Vec3i = main.vec.Vec3i;

const ZonElement = @import("zon.zig").ZonElement;

const multiplier: u64 = 0x5deece66d;
const addend: u64 = 0xb;
const mask: u64 = (1 << 48) - 1;

pub fn scrambleSeed(seed: *u64) void {
	seed.* = (seed.* ^ multiplier) & mask;
}

fn nextWithBitSize(comptime T: type, seed: *u64, bitSize: u6) T {
	seed.* = ((seed.*)*%multiplier +% addend) & mask;
	return @intCast((seed.* >> (48 - bitSize)) & std.math.maxInt(T));
}

fn next(comptime T: type, seed: *u64) T {
	return nextWithBitSize(T, seed, @bitSizeOf(T));
}

pub fn nextInt(comptime T: type, seed: *u64) T {
	if (@bitSizeOf(T) > 32) {
		var result: T = 0;
		for (0..(@bitSizeOf(T) + 31)/32) |_| {
			result = result << 32 | next(u32, seed);
		}
		return result;
	} else {
		return next(T, seed);
	}
}

pub fn nextIntBounded(comptime T: type, seed: *u64, bound: T) T {
	if (@typeInfo(T) != .int) @compileError("Type must be integer.");
	if (@typeInfo(T).int.signedness == .signed) return nextIntBounded(std.meta.Int(.unsigned, @bitSizeOf(T) - 1), seed, @intCast(bound));
	const bitSize = std.math.log2_int_ceil(T, bound);
	var result = nextWithBitSize(T, seed, bitSize);
	while (result >= bound) {
		result = nextWithBitSize(T, seed, bitSize);
	}
	return result;
}

pub fn nextFloat(seed: *u64) f32 {
	return @as(f32, @floatFromInt(nextInt(u24, seed)))/(1 << 24);
}

pub fn nextFloatSigned(seed: *u64) f32 {
	return @as(f32, @floatFromInt(@as(i24, @bitCast(nextInt(u24, seed)))))/(1 << 23);
}

pub fn nextFloatExp(seed: *u64) f32 {
	return -@log(nextFloat(seed));
}

pub fn nextFloatGauss(seed: *u64) f32 {
	const a = nextFloat(seed);
	const b = nextFloat(seed);

	return @sqrt(-2.0*@log(a))*@cos(2.0*std.math.pi*b);
}

pub fn nextFloatVector(len: comptime_int, seed: *u64) @Vector(len, f32) {
	var result: @Vector(len, f32) = undefined;
	inline for (0..len) |i| {
		result[i] = nextFloat(seed);
	}
	return result;
}

pub fn nextFloatVectorSigned(len: comptime_int, seed: *u64) @Vector(len, f32) {
	var result: @Vector(len, f32) = undefined;
	inline for (0..len) |i| {
		result[i] = nextFloatSigned(seed);
	}
	return result;
}

pub fn nextDouble(seed: *u64) f64 {
	const lower: u52 = nextInt(u32, seed);
	const upper: u52 = nextInt(u20, seed);
	return @as(f64, @floatFromInt(upper << 32 | lower))/(1 << 52);
}

pub fn nextDoubleSigned(seed: *u64) f64 {
	const lower: i52 = nextInt(u32, seed);
	const upper: i52 = nextInt(u20, seed);
	return @as(f64, @floatFromInt(upper << 32 | lower))/(1 << 51);
}

pub fn nextDoubleVector(len: comptime_int, seed: *u64) @Vector(len, f64) {
	var result: @Vector(len, f64) = undefined;
	inline for (0..len) |i| {
		result[i] = nextDouble(seed);
	}
	return result;
}

pub fn nextDoubleVectorSigned(len: comptime_int, seed: *u64) @Vector(len, f64) {
	var result: @Vector(len, f64) = undefined;
	inline for (0..len) |i| {
		result[i] = nextDoubleSigned(seed);
	}
	return result;
}

pub fn nextPointInUnitCircle(seed: *u64) Vec2f {
	while (true) {
		const x: f32 = nextFloatSigned(seed);
		const y: f32 = nextFloatSigned(seed);
		if (x*x + y*y < 1) {
			return Vec2f{x, y};
		}
	}
}

pub fn initSeed3D(worldSeed: u64, pos: Vec3i) u64 {
	const fac = Vec3i{11248723, 105436839, 45399083};
	const seed = @reduce(.Xor, fac*%pos);
	return @as(u32, @bitCast(seed)) ^ worldSeed;
}

pub fn initSeed2D(worldSeed: u64, pos: Vec2i) u64 {
	const fac = Vec2i{11248723, 105436839};
	const seed = @reduce(.Xor, fac*%pos);
	return @as(u32, @bitCast(seed)) ^ worldSeed;
}

pub fn RandomRange(T: type) type {
	return struct {
		min: T,
		max: T,

		pub fn init(min: T, max: T) @This() {
			return .{
				.min = min,
				.max = max,
			};
		}

		pub fn fromZon(zon: ZonElement) ?@This() {
			const vals: ?@Vector(2, T) = if (zon.as(?T, null)) |v| @splat(v) else zon.as(?@Vector(2, T), null);

			if (vals == null) return null;

			return .{
				.min = vals.?[0],
				.max = vals.?[1],
			};
		}

		pub fn get(self: @This(), seed: *u64) T {
			return self.min + (self.max - self.min)*nextFloat(seed);
		}
	};
}

```

`src/renderer.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const blocks = @import("blocks.zig");
const chunk = @import("chunk.zig");
const entity = @import("entity.zig");
const graphics = @import("graphics.zig");
const particles = @import("particles.zig");
const c = graphics.c;
const game = @import("game.zig");
const World = game.World;
const itemdrop = @import("itemdrop.zig");
const main = @import("main");
const Window = main.Window;
const models = @import("models.zig");
const network = @import("network.zig");
const settings = @import("settings.zig");
const vec = @import("vec.zig");
const gpu_performance_measuring = main.gui.windowlist.gpu_performance_measuring;
const crosshair = main.gui.windowlist.crosshair;
const Vec2f = vec.Vec2f;
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;
const Vec3d = vec.Vec3d;
const Vec4f = vec.Vec4f;
const Mat4f = vec.Mat4f;

pub const chunk_meshing = @import("renderer/chunk_meshing.zig");
pub const mesh_storage = @import("renderer/mesh_storage.zig");

/// Time after which no more chunk meshes are created. This allows the game to run smoother on movement.
const maximumMeshTime: std.Io.Duration = .fromMilliseconds(12);
pub const zNear = 0.1;
pub const zFar = 65536.0; // TODO: Fix z-fighting problems.

var deferredRenderPassPipeline: graphics.Pipeline = undefined;
var deferredUniforms: struct {
	@"fog.color": c_int,
	@"fog.density": c_int,
	@"fog.fogLower": c_int,
	@"fog.fogHigher": c_int,
	tanXY: c_int,
	zNear: c_int,
	zFar: c_int,
	invViewMatrix: c_int,
	playerPositionInteger: c_int,
	playerPositionFraction: c_int,
} = undefined;
var fakeReflectionPipeline: graphics.Pipeline = undefined;
var fakeReflectionUniforms: struct {
	normalVector: c_int,
	upVector: c_int,
	rightVector: c_int,
	frequency: c_int,
	reflectionMapSize: c_int,
} = undefined;

pub var activeFrameBuffer: c_uint = 0;

pub const reflectionCubeMapSize = 64;
var reflectionCubeMap: graphics.CubeMapTexture = undefined;

pub fn init() void {
	deferredRenderPassPipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/deferred_render_pass.vert",
		"assets/cubyz/shaders/deferred_render_pass.frag",
		"",
		&deferredUniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.noBlending}},
	);
	fakeReflectionPipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/fake_reflection.vert",
		"assets/cubyz/shaders/fake_reflection.frag",
		"",
		&fakeReflectionUniforms,
		.{.cullMode = .none},
		.{.depthTest = false, .depthWrite = false},
		.{.attachments = &.{.noBlending}},
	);
	worldFrameBuffer.init(true, c.GL_NEAREST, c.GL_CLAMP_TO_EDGE);
	worldFrameBuffer.updateSize(Window.width, Window.height, c.GL_RGB16F);
	Bloom.init();
	MeshSelection.init();
	MenuBackGround.init();
	Skybox.init();
	chunk_meshing.init();
	mesh_storage.init();
	reflectionCubeMap = .init();
	reflectionCubeMap.generate(reflectionCubeMapSize, reflectionCubeMapSize);
	initReflectionCubeMap();
}

pub fn deinit() void {
	deferredRenderPassPipeline.deinit();
	fakeReflectionPipeline.deinit();
	worldFrameBuffer.deinit();
	Bloom.deinit();
	MeshSelection.deinit();
	MenuBackGround.deinit();
	Skybox.deinit();
	mesh_storage.deinit();
	chunk_meshing.deinit();
	reflectionCubeMap.deinit();
}

fn initReflectionCubeMap() void {
	c.glViewport(0, 0, reflectionCubeMapSize, reflectionCubeMapSize);
	var framebuffer: graphics.FrameBuffer = undefined;
	framebuffer.init(false, c.GL_LINEAR, c.GL_CLAMP_TO_EDGE);
	defer framebuffer.deinit();
	framebuffer.bind();
	fakeReflectionPipeline.bind(null);
	c.glUniform1f(fakeReflectionUniforms.frequency, 1);
	c.glUniform1f(fakeReflectionUniforms.reflectionMapSize, reflectionCubeMapSize);
	for (0..6) |face| {
		c.glUniform3fv(fakeReflectionUniforms.normalVector, 1, @ptrCast(&graphics.CubeMapTexture.faceNormal(face)));
		c.glUniform3fv(fakeReflectionUniforms.upVector, 1, @ptrCast(&graphics.CubeMapTexture.faceUp(face)));
		c.glUniform3fv(fakeReflectionUniforms.rightVector, 1, @ptrCast(&graphics.CubeMapTexture.faceRight(face)));
		reflectionCubeMap.bindToFramebuffer(framebuffer, @intCast(face));
		c.glBindVertexArray(graphics.draw.rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}
}

var worldFrameBuffer: graphics.FrameBuffer = undefined;

pub var lastWidth: u31 = 0;
pub var lastHeight: u31 = 0;
var lastFov: f32 = 0;
pub fn updateFov(fov: f32) void {
	if (lastFov != fov) {
		lastFov = fov;
		game.projectionMatrix = Mat4f.perspective(std.math.degreesToRadians(fov), @as(f32, @floatFromInt(lastWidth))/@as(f32, @floatFromInt(lastHeight)), zNear, zFar);
	}
}
pub fn updateViewport(width: u31, height: u31) void {
	lastWidth = @intFromFloat(@as(f32, @floatFromInt(width))*main.settings.resolutionScale);
	lastHeight = @intFromFloat(@as(f32, @floatFromInt(height))*main.settings.resolutionScale);
	game.projectionMatrix = Mat4f.perspective(std.math.degreesToRadians(lastFov), @as(f32, @floatFromInt(lastWidth))/@as(f32, @floatFromInt(lastHeight)), zNear, zFar);
	worldFrameBuffer.updateSize(lastWidth, lastHeight, c.GL_RGB16F);
	worldFrameBuffer.unbind();
}

pub fn render(playerPosition: Vec3d, deltaTime: f64) void {
	// TODO: player bobbing
	// TODO: Handle colors and sun position in the world.
	std.debug.assert(game.world != null);

	const nightColor: Vec3f = .{0.3, 0.4, 0.5};
	const ambient = @max(nightColor*@as(Vec3f, @splat(settings.nightBrightness)), @as(Vec3f, @splat(game.world.?.ambientLight)));

	itemdrop.ItemDisplayManager.update(deltaTime);
	renderWorld(game.world.?, ambient, game.fog.skyColor, playerPosition);
	const startTime = main.timestamp();
	mesh_storage.updateMeshes(startTime.addDuration(maximumMeshTime));
}

pub fn crosshairDirection(rotationMatrix: Mat4f, fovY: f32, width: u31, height: u31) Vec3f {
	// stolen code from Frustum.init
	const invRotationMatrix = rotationMatrix.transpose();
	const cameraDir = vec.xyz(invRotationMatrix.mulVec(Vec4f{0, 1, 0, 1}));
	const cameraUp = vec.xyz(invRotationMatrix.mulVec(Vec4f{0, 0, 1, 1}));
	const cameraRight = vec.xyz(invRotationMatrix.mulVec(Vec4f{1, 0, 0, 1}));

	const screenSize = Vec2f{@floatFromInt(width), @floatFromInt(height)};
	const screenCoord = (crosshair.window.pos + crosshair.window.contentSize*Vec2f{0.5, 0.5}*@as(Vec2f, @splat(crosshair.window.scale)))*@as(Vec2f, @splat(main.gui.scale*main.settings.resolutionScale));

	const halfVSide = std.math.tan(std.math.degreesToRadians(fovY)*0.5);
	const halfHSide = halfVSide*screenSize[0]/screenSize[1];
	const sides = Vec2f{halfHSide, halfVSide};

	const scale = (Vec2f{-1, 1} + Vec2f{2, -2}*screenCoord/screenSize)*sides;
	const forwards = cameraDir;
	const horizontal = cameraRight*@as(Vec3f, @splat(scale[0]));
	const vertical = cameraUp*@as(Vec3f, @splat(scale[1])); // adjust for y coordinate

	const adjusted = forwards + horizontal + vertical;
	return adjusted;
}

pub fn renderWorld(world: *World, ambientLight: Vec3f, skyColor: Vec3f, playerPos: Vec3d) void { // MARK: renderWorld()
	worldFrameBuffer.bind();
	c.glViewport(0, 0, lastWidth, lastHeight);
	gpu_performance_measuring.startQuery(.clear);
	worldFrameBuffer.clear(Vec4f{skyColor[0], skyColor[1], skyColor[2], 1});
	gpu_performance_measuring.stopQuery();
	game.camera.updateViewMatrix();

	// Uses FrustumCulling on the chunks.
	const frustum = Frustum.init(Vec3f{0, 0, 0}, game.camera.viewMatrix, lastFov, lastWidth, lastHeight);

	const time: u32 = @intCast(main.timestamp().toMilliseconds() & std.math.maxInt(u32));

	gpu_performance_measuring.startQuery(.skybox);
	Skybox.render();
	gpu_performance_measuring.stopQuery();

	gpu_performance_measuring.startQuery(.animation);
	blocks.meshes.preProcessAnimationData(time);
	gpu_performance_measuring.stopQuery();

	// Update the uniforms. The uniforms are needed to render the replacement meshes.
	chunk_meshing.bindShaderAndUniforms(game.projectionMatrix, ambientLight, playerPos);

	c.glActiveTexture(c.GL_TEXTURE0);
	blocks.meshes.blockTextureArray.bind();
	c.glActiveTexture(c.GL_TEXTURE1);
	blocks.meshes.emissionTextureArray.bind();
	c.glActiveTexture(c.GL_TEXTURE2);
	blocks.meshes.reflectivityAndAbsorptionTextureArray.bind();
	c.glActiveTexture(c.GL_TEXTURE5);
	blocks.meshes.ditherTexture.bind();
	reflectionCubeMap.bindTo(4);

	chunk_meshing.quadsDrawn = 0;
	chunk_meshing.transparentQuadsDrawn = 0;
	const meshes = mesh_storage.updateAndGetRenderChunks(world.conn, &frustum, playerPos, settings.renderDistance);

	gpu_performance_measuring.startQuery(.chunk_rendering_preparation);
	const direction = crosshairDirection(game.camera.viewMatrix, lastFov, lastWidth, lastHeight);
	MeshSelection.select(playerPos, direction, game.Player.inventory.getItem(game.Player.selectedSlot));

	chunk_meshing.beginRender();

	var chunkLists: [main.settings.highestSupportedLod + 1]main.List(u32) = @splat(main.List(u32).init(main.stackAllocator));
	defer for (chunkLists) |list| list.deinit();
	for (meshes) |mesh| {
		mesh.prepareRendering(&chunkLists);
	}
	gpu_performance_measuring.stopQuery();
	gpu_performance_measuring.startQuery(.chunk_rendering);
	chunk_meshing.drawChunksIndirect(&chunkLists, game.projectionMatrix, ambientLight, playerPos, false);
	gpu_performance_measuring.stopQuery();

	gpu_performance_measuring.startQuery(.entity_rendering);
	entity.ClientEntityManager.render(game.projectionMatrix, ambientLight, playerPos);

	itemdrop.ItemDropRenderer.renderItemDrops(game.projectionMatrix, ambientLight, playerPos);
	gpu_performance_measuring.stopQuery();

	gpu_performance_measuring.startQuery(.block_entity_rendering);
	main.block_entity.renderAll(game.projectionMatrix, ambientLight, playerPos);
	gpu_performance_measuring.stopQuery();

	gpu_performance_measuring.startQuery(.particle_rendering);
	particles.ParticleSystem.render(game.projectionMatrix, game.camera.viewMatrix, ambientLight);
	gpu_performance_measuring.stopQuery();

	// Rebind block textures back to their original slots
	c.glActiveTexture(c.GL_TEXTURE0);
	blocks.meshes.blockTextureArray.bind();
	c.glActiveTexture(c.GL_TEXTURE1);
	blocks.meshes.emissionTextureArray.bind();

	MeshSelection.render(game.projectionMatrix, game.camera.viewMatrix, playerPos);

	// Render transparent chunk meshes:
	worldFrameBuffer.bindDepthTexture(c.GL_TEXTURE5);

	gpu_performance_measuring.startQuery(.transparent_rendering_preparation);
	c.glTextureBarrier();

	{
		for (&chunkLists) |*list| list.clearRetainingCapacity();
		var i: usize = meshes.len;
		while (true) {
			if (i == 0) break;
			i -= 1;
			meshes[i].prepareTransparentRendering(playerPos, &chunkLists);
		}
		gpu_performance_measuring.stopQuery();
		gpu_performance_measuring.startQuery(.transparent_rendering);
		chunk_meshing.drawChunksIndirect(&chunkLists, game.projectionMatrix, ambientLight, playerPos, true);
		gpu_performance_measuring.stopQuery();
	}

	c.glDepthRange(0, 0.001);
	itemdrop.ItemDropRenderer.renderDisplayItems(ambientLight, playerPos);
	c.glDepthRange(0.001, 1);

	chunk_meshing.endRender();

	worldFrameBuffer.bindTexture(c.GL_TEXTURE3);

	const playerBlock = mesh_storage.getBlockFromAnyLodFromRenderThread(@intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));

	if (settings.bloom) {
		Bloom.render(lastWidth, lastHeight, playerBlock, playerPos, game.camera.viewMatrix);
	} else {
		Bloom.bindReplacementImage();
	}
	gpu_performance_measuring.startQuery(.final_copy);
	if (activeFrameBuffer == 0) c.glViewport(0, 0, main.Window.width, main.Window.height);
	worldFrameBuffer.bindTexture(c.GL_TEXTURE3);
	worldFrameBuffer.bindDepthTexture(c.GL_TEXTURE4);
	worldFrameBuffer.unbind();
	deferredRenderPassPipeline.bind(null);
	if (!blocks.meshes.hasFog(playerBlock)) {
		c.glUniform3fv(deferredUniforms.@"fog.color", 1, @ptrCast(&game.fog.fogColor));
		c.glUniform1f(deferredUniforms.@"fog.density", game.fog.density);
		c.glUniform1f(deferredUniforms.@"fog.fogLower", game.fog.fogLower);
		c.glUniform1f(deferredUniforms.@"fog.fogHigher", game.fog.fogHigher);
	} else {
		const fogColor = blocks.meshes.fogColor(playerBlock);
		c.glUniform3f(deferredUniforms.@"fog.color", @as(f32, @floatFromInt(fogColor >> 16 & 255))/255.0, @as(f32, @floatFromInt(fogColor >> 8 & 255))/255.0, @as(f32, @floatFromInt(fogColor >> 0 & 255))/255.0);
		c.glUniform1f(deferredUniforms.@"fog.density", blocks.meshes.fogDensity(playerBlock));
		c.glUniform1f(deferredUniforms.@"fog.fogLower", 1e10);
		c.glUniform1f(deferredUniforms.@"fog.fogHigher", 1e10);
	}
	c.glUniformMatrix4fv(deferredUniforms.invViewMatrix, 1, c.GL_TRUE, @ptrCast(&game.camera.viewMatrix.transpose()));
	c.glUniform3i(deferredUniforms.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
	c.glUniform3f(deferredUniforms.playerPositionFraction, @floatCast(@mod(playerPos[0], 1)), @floatCast(@mod(playerPos[1], 1)), @floatCast(@mod(playerPos[2], 1)));
	c.glUniform1f(deferredUniforms.zNear, zNear);
	c.glUniform1f(deferredUniforms.zFar, zFar);
	c.glUniform2f(deferredUniforms.tanXY, 1.0/game.projectionMatrix.rows[0][0], 1.0/game.projectionMatrix.rows[1][2]);

	c.glBindFramebuffer(c.GL_FRAMEBUFFER, activeFrameBuffer);

	c.glBindVertexArray(graphics.draw.rectVAO);
	c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);

	c.glBindFramebuffer(c.GL_FRAMEBUFFER, 0);

	if (!main.gui.hideGui) entity.ClientEntityManager.renderNames(game.projectionMatrix, playerPos);
	gpu_performance_measuring.stopQuery();
}

const Bloom = struct { // MARK: Bloom
	var buffer1: graphics.FrameBuffer = undefined;
	var buffer2: graphics.FrameBuffer = undefined;
	var emptyBuffer: graphics.Texture = undefined;
	var width: u31 = std.math.maxInt(u31);
	var height: u31 = std.math.maxInt(u31);
	var firstPassPipeline: graphics.Pipeline = undefined;
	var secondPassPipeline: graphics.Pipeline = undefined;
	var colorExtractAndDownsamplePipeline: graphics.Pipeline = undefined;
	var colorExtractUniforms: struct {
		zNear: c_int,
		zFar: c_int,
		tanXY: c_int,
		@"fog.color": c_int,
		@"fog.density": c_int,
		@"fog.fogLower": c_int,
		@"fog.fogHigher": c_int,
		invViewMatrix: c_int,
		playerPositionInteger: c_int,
		playerPositionFraction: c_int,
	} = undefined;

	pub fn init() void {
		buffer1.init(false, c.GL_LINEAR, c.GL_CLAMP_TO_EDGE);
		buffer2.init(false, c.GL_LINEAR, c.GL_CLAMP_TO_EDGE);
		emptyBuffer = .init();
		emptyBuffer.generate(graphics.Image.emptyImage);
		firstPassPipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/bloom/first_pass.vert",
			"assets/cubyz/shaders/bloom/first_pass.frag",
			"",
			null,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.noBlending}},
		);
		secondPassPipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/bloom/second_pass.vert",
			"assets/cubyz/shaders/bloom/second_pass.frag",
			"",
			null,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.noBlending}},
		);
		colorExtractAndDownsamplePipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/bloom/color_extractor_downsample.vert",
			"assets/cubyz/shaders/bloom/color_extractor_downsample.frag",
			"",
			&colorExtractUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.noBlending}},
		);
	}

	pub fn deinit() void {
		buffer1.deinit();
		buffer2.deinit();
		firstPassPipeline.deinit();
		secondPassPipeline.deinit();
		colorExtractAndDownsamplePipeline.deinit();
	}

	fn extractImageDataAndDownsample(playerBlock: blocks.Block, playerPos: Vec3d, viewMatrix: Mat4f) void {
		colorExtractAndDownsamplePipeline.bind(null);
		worldFrameBuffer.bindTexture(c.GL_TEXTURE3);
		worldFrameBuffer.bindDepthTexture(c.GL_TEXTURE4);
		buffer1.bind();
		if (!blocks.meshes.hasFog(playerBlock)) {
			c.glUniform3fv(colorExtractUniforms.@"fog.color", 1, @ptrCast(&game.fog.fogColor));
			c.glUniform1f(colorExtractUniforms.@"fog.density", game.fog.density);
			c.glUniform1f(colorExtractUniforms.@"fog.fogLower", game.fog.fogLower);
			c.glUniform1f(colorExtractUniforms.@"fog.fogHigher", game.fog.fogHigher);
		} else {
			const fogColor = blocks.meshes.fogColor(playerBlock);
			c.glUniform3f(colorExtractUniforms.@"fog.color", @as(f32, @floatFromInt(fogColor >> 16 & 255))/255.0, @as(f32, @floatFromInt(fogColor >> 8 & 255))/255.0, @as(f32, @floatFromInt(fogColor >> 0 & 255))/255.0);
			c.glUniform1f(colorExtractUniforms.@"fog.density", blocks.meshes.fogDensity(playerBlock));
			c.glUniform1f(colorExtractUniforms.@"fog.fogLower", 1e10);
			c.glUniform1f(colorExtractUniforms.@"fog.fogHigher", 1e10);
		}

		c.glUniformMatrix4fv(colorExtractUniforms.invViewMatrix, 1, c.GL_TRUE, @ptrCast(&viewMatrix.transpose()));
		c.glUniform3i(colorExtractUniforms.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
		c.glUniform3f(colorExtractUniforms.playerPositionFraction, @floatCast(@mod(playerPos[0], 1)), @floatCast(@mod(playerPos[1], 1)), @floatCast(@mod(playerPos[2], 1)));
		c.glUniform1f(colorExtractUniforms.zNear, zNear);
		c.glUniform1f(colorExtractUniforms.zFar, zFar);
		c.glUniform2f(colorExtractUniforms.tanXY, 1.0/game.projectionMatrix.rows[0][0], 1.0/game.projectionMatrix.rows[1][2]);
		c.glBindVertexArray(graphics.draw.rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	fn firstPass() void {
		firstPassPipeline.bind(null);
		buffer1.bindTexture(c.GL_TEXTURE3);
		buffer2.bind();
		c.glBindVertexArray(graphics.draw.rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	fn secondPass() void {
		secondPassPipeline.bind(null);
		buffer2.bindTexture(c.GL_TEXTURE3);
		buffer1.bind();
		c.glBindVertexArray(graphics.draw.rectVAO);
		c.glDrawArrays(c.GL_TRIANGLE_STRIP, 0, 4);
	}

	fn render(currentWidth: u31, currentHeight: u31, playerBlock: blocks.Block, playerPos: Vec3d, viewMatrix: Mat4f) void {
		if (width != currentWidth or height != currentHeight) {
			width = currentWidth;
			height = currentHeight;
			buffer1.updateSize(width/4, height/4, c.GL_R11F_G11F_B10F);
			std.debug.assert(buffer1.validate());
			buffer2.updateSize(width/4, height/4, c.GL_R11F_G11F_B10F);
			std.debug.assert(buffer2.validate());
		}
		gpu_performance_measuring.startQuery(.bloom_extract_downsample);

		c.glViewport(0, 0, width/4, height/4);
		extractImageDataAndDownsample(playerBlock, playerPos, viewMatrix);
		gpu_performance_measuring.stopQuery();
		gpu_performance_measuring.startQuery(.bloom_first_pass);
		firstPass();
		gpu_performance_measuring.stopQuery();
		gpu_performance_measuring.startQuery(.bloom_second_pass);
		secondPass();

		c.glViewport(0, 0, width, height);
		buffer1.bindTexture(c.GL_TEXTURE5);

		gpu_performance_measuring.stopQuery();
	}

	fn bindReplacementImage() void {
		emptyBuffer.bindTo(5);
	}
};

pub const MenuBackGround = struct {
	var pipeline: graphics.Pipeline = undefined;
	var uniforms: struct {
		viewMatrix: c_int,
		projectionMatrix: c_int,
	} = undefined;

	var vao: c_uint = undefined;
	var vbos: [2]c_uint = undefined;
	var texture: graphics.Texture = undefined;

	var angle: f32 = 0;

	fn init() void {
		pipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/background/vertex.vert",
			"assets/cubyz/shaders/background/fragment.frag",
			"",
			&uniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.noBlending}},
		);
		// 4 sides of a simple cube with some panorama texture on it.
		const rawData = [_]f32{
			-1, 1,  -1, 1,    1,
			-1, 1,  1,  1,    0,
			-1, -1, -1, 0.75, 1,
			-1, -1, 1,  0.75, 0,
			1,  -1, -1, 0.5,  1,
			1,  -1, 1,  0.5,  0,
			1,  1,  -1, 0.25, 1,
			1,  1,  1,  0.25, 0,
			-1, 1,  -1, 0,    1,
			-1, 1,  1,  0,    0,
		};

		const indices = [_]c_int{
			0, 1, 2,
			2, 3, 1,
			2, 3, 4,
			4, 5, 3,
			4, 5, 6,
			6, 7, 5,
			6, 7, 8,
			8, 9, 7,
		};

		c.glGenVertexArrays(1, &vao);
		c.glBindVertexArray(vao);
		c.glGenBuffers(2, &vbos);
		c.glBindBuffer(c.GL_ARRAY_BUFFER, vbos[0]);
		c.glBufferData(c.GL_ARRAY_BUFFER, @intCast(rawData.len*@sizeOf(f32)), &rawData, c.GL_STATIC_DRAW);
		c.glVertexAttribPointer(0, 3, c.GL_FLOAT, c.GL_FALSE, 5*@sizeOf(f32), null);
		c.glVertexAttribPointer(1, 2, c.GL_FLOAT, c.GL_FALSE, 5*@sizeOf(f32), @ptrFromInt(3*@sizeOf(f32)));
		c.glEnableVertexAttribArray(0);
		c.glEnableVertexAttribArray(1);
		c.glBindBuffer(c.GL_ELEMENT_ARRAY_BUFFER, vbos[1]);
		c.glBufferData(c.GL_ELEMENT_ARRAY_BUFFER, @intCast(indices.len*@sizeOf(c_int)), &indices, c.GL_STATIC_DRAW);

		const backgroundPath = chooseBackgroundImagePath(main.stackAllocator) catch |err| {
			std.log.err("Couldn't open background path: {s}", .{@errorName(err)});
			texture = .{.textureID = 0};
			return;
		};
		defer main.stackAllocator.free(backgroundPath);
		texture = graphics.Texture.initFromFile(backgroundPath);
	}

	fn chooseBackgroundImagePath(allocator: main.heap.NeverFailingAllocator) ![]const u8 {
		var dir = try main.files.cubyzDir().openIterableDir("backgrounds");
		defer dir.close();

		// Whenever the version changes copy over the new background image and display it.
		if (!std.mem.eql(u8, settings.lastVersionString, settings.version.version)) {
			const defaultImageData = try main.files.cwd().read(main.stackAllocator, "assets/cubyz/default_background.png");
			defer main.stackAllocator.free(defaultImageData);
			try dir.write("default_background.png", defaultImageData);

			return std.fmt.allocPrint(allocator.allocator, "{s}/backgrounds/default_background.png", .{main.files.cubyzDirStr()}) catch unreachable;
		}

		// Otherwise load a random texture from the backgrounds folder. The player may make their own pictures which can be chosen as well.
		var walker = dir.walk(main.stackAllocator);
		defer walker.deinit();
		var fileList = main.List([]const u8).init(main.stackAllocator);
		defer {
			for (fileList.items) |fileName| {
				main.stackAllocator.free(fileName);
			}
			fileList.deinit();
		}

		while (try walker.next()) |entry| {
			if (entry.kind == .file and std.ascii.endsWithIgnoreCase(entry.basename, ".png")) {
				fileList.append(main.stackAllocator.dupe(u8, entry.path));
			}
		}
		if (fileList.items.len == 0) {
			return error.NoBackgroundImagesFound;
		}
		const theChosenOne = main.random.nextIntBounded(u32, &main.seed, @as(u32, @intCast(fileList.items.len)));
		return std.fmt.allocPrint(allocator.allocator, "{s}/backgrounds/{s}", .{main.files.cubyzDirStr(), fileList.items[theChosenOne]}) catch unreachable;
	}

	pub fn deinit() void {
		pipeline.deinit();
		c.glDeleteVertexArrays(1, &vao);
		c.glDeleteBuffers(2, &vbos);
	}

	pub fn hasImage() bool {
		return texture.textureID != 0;
	}

	pub fn render(deltaTime: f64) void {
		c.glViewport(0, 0, main.Window.width, main.Window.height);
		if (texture.textureID == 0) return;

		// Use a simple rotation around the z axis, with a steadily increasing angle.
		angle += @as(f32, @floatCast(deltaTime))/20.0;
		const viewMatrix = Mat4f.rotationZ(angle);
		pipeline.bind(null);
		c.glUniformMatrix4fv(uniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&viewMatrix));
		c.glUniformMatrix4fv(uniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&game.projectionMatrix));

		texture.bindTo(0);

		c.glBindVertexArray(vao);
		c.glDrawElements(c.GL_TRIANGLES, 24, c.GL_UNSIGNED_INT, null);
	}

	pub fn takeBackgroundImage() void {
		const size: usize = 1024; // Use a power of 2 here, to reduce video memory waste.
		const pixels: []u32 = main.stackAllocator.alloc(u32, size*size);
		defer main.stackAllocator.free(pixels);

		// Change the viewport and the matrices to render 4 cube faces:

		const oldResolutionScale = main.settings.resolutionScale;
		main.settings.resolutionScale = 1;
		updateViewport(size, size);
		updateFov(90.0);
		defer updateFov(main.settings.fov);
		main.settings.resolutionScale = oldResolutionScale;
		defer updateViewport(Window.width, Window.height);

		var buffer: graphics.FrameBuffer = undefined;
		buffer.init(true, c.GL_NEAREST, c.GL_REPEAT);
		defer buffer.deinit();
		buffer.updateSize(size, size, c.GL_RGBA8);

		activeFrameBuffer = buffer.frameBuffer;
		defer activeFrameBuffer = 0;

		const oldRotation = game.camera.rotation;
		defer game.camera.rotation = oldRotation;

		const angles = [_]f32{std.math.pi/2.0, std.math.pi, std.math.pi*3/2.0, std.math.pi*2};

		// All 4 sides are stored in a single image.
		const image = graphics.Image.init(main.stackAllocator, 4*size, size);
		defer image.deinit(main.stackAllocator);

		for (0..4) |i| {
			c.glDepthFunc(c.GL_LESS);
			c.glDepthMask(c.GL_TRUE);
			c.glDisable(c.GL_SCISSOR_TEST);
			game.camera.rotation = .{0, 0, angles[i]};
			// Draw to frame buffer.
			buffer.bind();
			c.glClear(c.GL_DEPTH_BUFFER_BIT | c.GL_STENCIL_BUFFER_BIT | c.GL_COLOR_BUFFER_BIT);
			main.renderer.render(game.Player.getEyePosBlocking(), 0);
			// Copy the pixels directly from OpenGL
			buffer.bind();
			c.glReadPixels(0, 0, size, size, c.GL_RGBA, c.GL_UNSIGNED_BYTE, pixels.ptr);

			for (0..size) |y| {
				for (0..size) |x| {
					const index = x + y*size;
					// Needs to flip the image in y-direction.
					image.setRGB(x + size*i, size - 1 - y, @bitCast(pixels[index]));
				}
			}
		}
		c.glBindFramebuffer(c.GL_FRAMEBUFFER, 0);

		const fileName = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/backgrounds/{s}_{}.png", .{main.files.cubyzDirStr(), game.world.?.name, game.world.?.gameTime.load(.monotonic)}) catch unreachable;
		defer main.stackAllocator.free(fileName);
		image.exportToFile(fileName) catch |err| {
			std.log.err("Cannot write file {s} due to {s}", .{fileName, @errorName(err)});
		};
		// TODO: Performance is terrible even with -O3. Consider using qoi instead.
	}
};

pub const Skybox = struct {
	var starPipeline: graphics.Pipeline = undefined;
	var starUniforms: struct {
		mvp: c_int,
		starOpacity: c_int,
	} = undefined;

	var starVao: c_uint = undefined;

	var starSsbo: graphics.SSBO = undefined;

	const numStars = 10000;

	fn getStarPos(seed: *u64) Vec3f {
		const x: f32 = @floatCast(main.random.nextFloatGauss(seed));
		const y: f32 = @floatCast(main.random.nextFloatGauss(seed));
		const z: f32 = @floatCast(main.random.nextFloatGauss(seed));

		const r = std.math.cbrt(main.random.nextFloat(seed))*5000.0;

		return vec.normalize(Vec3f{x, y, z})*@as(Vec3f, @splat(r));
	}

	fn getStarColor(temperature: f32, light: f32, image: graphics.Image) Vec3f {
		const rgbCol = image.getRGB(@intFromFloat(std.math.clamp(temperature/15000.0*@as(f32, @floatFromInt(image.width)), 0.0, @as(f32, @floatFromInt(image.width - 1)))), 0);
		var rgb: Vec3f = @floatFromInt(Vec3i{rgbCol.r, rgbCol.g, rgbCol.b});
		rgb /= @splat(255.0);

		rgb *= @as(Vec3f, @splat(light));

		const m = @reduce(.Max, rgb);
		if (m > 1.0) {
			rgb /= @as(Vec3f, @splat(m));
		}

		return rgb;
	}

	fn init() void {
		const starColorImage = graphics.Image.readFromFile(main.stackAllocator, "assets/cubyz/star.png") catch |err| {
			std.log.err("Failed to load star image: {s}", .{@errorName(err)});
			return;
		};
		defer starColorImage.deinit(main.stackAllocator);

		starPipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/skybox/star.vert",
			"assets/cubyz/shaders/skybox/star.frag",
			"",
			&starUniforms,
			.{.cullMode = .none},
			.{.depthTest = false, .depthWrite = false},
			.{.attachments = &.{.{
				.srcColorBlendFactor = .one,
				.dstColorBlendFactor = .one,
				.colorBlendOp = .add,
				.srcAlphaBlendFactor = .one,
				.dstAlphaBlendFactor = .one,
				.alphaBlendOp = .add,
			}}},
		);

		var starData: [numStars*20]f32 = undefined;

		const starDist = 200.0;

		const off: f32 = @sqrt(3.0)/6.0;

		const triVertA = Vec3f{0.5, starDist, -off};
		const triVertB = Vec3f{-0.5, starDist, -off};
		const triVertC = Vec3f{0.0, starDist, @sqrt(3.0)/2.0 - off};

		var seed: u64 = 0;

		for (0..numStars) |i| {
			var pos: Vec3f = undefined;

			var radius: f32 = undefined;

			var temperature: f32 = undefined;

			var light: f32 = 0;

			while (light < 0.1) {
				pos = getStarPos(&seed);

				radius = @floatCast(main.random.nextFloatExp(&seed)*4 + 0.2);

				temperature = @floatCast(@abs(main.random.nextFloatGauss(&seed)*3000.0 + 5000.0) + 1000.0);

				// 3.6e-12 can be modified to change the brightness of the stars
				light = (3.6e-12*radius*radius*temperature*temperature*temperature*temperature)/(vec.dot(pos, pos));
			}

			pos = vec.normalize(pos)*@as(Vec3f, @splat(starDist));

			const normPos = vec.normalize(pos);

			const color = getStarColor(temperature, light, starColorImage);

			const latitude: f32 = @floatCast(std.math.asin(normPos[2]));
			const longitude: f32 = @floatCast(std.math.atan2(-normPos[0], normPos[1]));

			const mat = Mat4f.rotationZ(longitude).mul(Mat4f.rotationX(latitude));

			const posA = vec.xyz(mat.mulVec(.{triVertA[0], triVertA[1], triVertA[2], 1.0}));
			const posB = vec.xyz(mat.mulVec(.{triVertB[0], triVertB[1], triVertB[2], 1.0}));
			const posC = vec.xyz(mat.mulVec(.{triVertC[0], triVertC[1], triVertC[2], 1.0}));

			starData[i*20 ..][0..3].* = posA;
			starData[i*20 + 4 ..][0..3].* = posB;
			starData[i*20 + 8 ..][0..3].* = posC;

			starData[i*20 + 12 ..][0..3].* = pos;
			starData[i*20 + 16 ..][0..3].* = color;
		}

		starSsbo = graphics.SSBO.initStatic(f32, &starData);

		c.glGenVertexArrays(1, &starVao);
		c.glBindVertexArray(starVao);
		c.glEnableVertexAttribArray(0);
	}

	pub fn deinit() void {
		starPipeline.deinit();
		starSsbo.deinit();
		c.glDeleteVertexArrays(1, &starVao);
	}

	pub fn render() void {
		const viewMatrix = game.camera.viewMatrix;

		const time = game.world.?.gameTime.load(.monotonic);

		var starOpacity: f32 = 0;
		const dayTime = @abs(@mod(time, game.World.dayCycle) -% game.World.dayCycle/2);
		if (dayTime < game.World.dayCycle/4 - game.World.dayCycle/16) {
			starOpacity = 1;
		} else if (dayTime > game.World.dayCycle/4 + game.World.dayCycle/16) {
			starOpacity = 0;
		} else {
			starOpacity = 1 - @as(f32, @floatFromInt(dayTime - (game.World.dayCycle/4 - game.World.dayCycle/16)))/@as(f32, @floatFromInt(game.World.dayCycle/8));
		}

		if (starOpacity != 0) {
			starPipeline.bind(null);

			const starMatrix = game.projectionMatrix.mul(viewMatrix.mul(Mat4f.rotationX(@as(f32, @floatFromInt(time))/@as(f32, @floatFromInt(main.game.World.dayCycle)))));

			starSsbo.bind(12);

			c.glUniform1f(starUniforms.starOpacity, starOpacity);
			c.glUniformMatrix4fv(starUniforms.mvp, 1, c.GL_TRUE, @ptrCast(&starMatrix));

			c.glBindVertexArray(starVao);
			c.glDrawArrays(c.GL_TRIANGLES, 0, numStars*3);

			c.glBindBuffer(c.GL_SHADER_STORAGE_BUFFER, 0);
		}
	}
};

pub const Frustum = struct { // MARK: Frustum
	const Plane = struct {
		pos: Vec3f,
		norm: Vec3f,
	};
	planes: [4]Plane, // Who cares about the near/far plane anyways?

	pub fn init(cameraPos: Vec3f, rotationMatrix: Mat4f, fovY: f32, width: u31, height: u31) Frustum {
		const invRotationMatrix = rotationMatrix.transpose();
		const cameraDir = vec.xyz(invRotationMatrix.mulVec(Vec4f{0, 1, 0, 1}));
		const cameraUp = vec.xyz(invRotationMatrix.mulVec(Vec4f{0, 0, 1, 1}));
		const cameraRight = vec.xyz(invRotationMatrix.mulVec(Vec4f{1, 0, 0, 1}));

		const halfVSide = std.math.tan(std.math.degreesToRadians(fovY)*0.5);
		const halfHSide = halfVSide*@as(f32, @floatFromInt(width))/@as(f32, @floatFromInt(height));

		var self: Frustum = undefined;
		self.planes[0] = Plane{.pos = cameraPos, .norm = vec.cross(cameraUp, cameraDir + cameraRight*@as(Vec3f, @splat(halfHSide)))}; // right
		self.planes[1] = Plane{.pos = cameraPos, .norm = vec.cross(cameraDir - cameraRight*@as(Vec3f, @splat(halfHSide)), cameraUp)}; // left
		self.planes[2] = Plane{.pos = cameraPos, .norm = vec.cross(cameraRight, cameraDir - cameraUp*@as(Vec3f, @splat(halfVSide)))}; // top
		self.planes[3] = Plane{.pos = cameraPos, .norm = vec.cross(cameraDir + cameraUp*@as(Vec3f, @splat(halfVSide)), cameraRight)}; // bottom
		return self;
	}

	pub fn testAAB(self: Frustum, pos: Vec3f, dim: Vec3f) bool {
		inline for (self.planes) |plane| {
			var dist: f32 = vec.dot(pos - plane.pos, plane.norm);
			// Find the most positive corner:
			dist += @reduce(.Add, @max(Vec3f{0, 0, 0}, dim*plane.norm));
			if (dist < 0) return false;
		}
		return true;
	}
};

pub const MeshSelection = struct { // MARK: MeshSelection
	var pipeline: graphics.Pipeline = undefined;
	var uniforms: struct {
		projectionMatrix: c_int,
		viewMatrix: c_int,
		modelPosition: c_int,
		lowerBounds: c_int,
		upperBounds: c_int,
		lineSize: c_int,
	} = undefined;

	pub fn init() void {
		pipeline = graphics.Pipeline.init(
			"assets/cubyz/shaders/block_selection_vertex.vert",
			"assets/cubyz/shaders/block_selection_fragment.frag",
			"",
			&uniforms,
			.{.cullMode = .none},
			.{.depthTest = true, .depthWrite = true},
			.{.attachments = &.{.alphaBlending}},
		);
	}

	pub fn deinit() void {
		pipeline.deinit();
	}

	var posBeforeBlock: Vec3i = undefined;
	var neighborOfSelection: chunk.Neighbor = undefined;
	pub var selectedBlockPos: ?Vec3i = null;
	var lastSelectedBlockPos: Vec3i = undefined;
	var currentBlockProgress: f32 = 0;
	var currentSwingProgress: f32 = 0;
	var currentSwingTime: f32 = 0;
	var selectionMin: Vec3f = undefined;
	var selectionMax: Vec3f = undefined;
	var selectionFace: chunk.Neighbor = undefined;
	var lastPos: Vec3d = undefined;
	var lastDir: Vec3f = undefined;
	pub fn select(pos: Vec3d, _dir: Vec3f, item: main.items.Item) void {
		lastPos = pos;
		const dir: Vec3d = @floatCast(_dir);
		lastDir = _dir;

		// Test blocks:
		const closestDistance: f64 = 6.0; // selection now limited
		// Implementation of "A Fast Voxel Traversal Algorithm for Ray Tracing"  http://www.cse.yorku.ca/~amana/research/grid.pdf
		const step: Vec3i = @intFromFloat(std.math.sign(dir));
		const invDir = @as(Vec3d, @splat(1))/dir;
		const tDelta = @abs(invDir);
		var tMax = (@floor(pos) - pos)*invDir;
		tMax = @max(tMax, tMax + tDelta*@as(Vec3f, @floatFromInt(step)));
		tMax = @select(f64, dir == @as(Vec3d, @splat(0)), @as(Vec3d, @splat(std.math.inf(f64))), tMax);
		var voxelPos: Vec3i = @intFromFloat(@floor(pos));

		var total_tMax: f64 = 0;

		selectedBlockPos = null;

		while (total_tMax < closestDistance) {
			const block = mesh_storage.getBlockFromRenderThread(voxelPos[0], voxelPos[1], voxelPos[2]) orelse break;
			if (block.typ != 0) blk: {
				const fluidPlaceable = item == .baseItem and item.baseItem.hasTag(.fluidPlaceable);
				const holdingTargetedBlock = item == .baseItem and item.baseItem.block() == block.typ;
				if (block.hasTag(.air) and !holdingTargetedBlock) break :blk;
				if (block.hasTag(.fluid) and !fluidPlaceable and !holdingTargetedBlock) break :blk; // TODO: Buckets could select fluids
				const relativePlayerPos: Vec3f = @floatCast(pos - @as(Vec3d, @floatFromInt(voxelPos)));
				if (block.mode().rayIntersection(block, item, relativePlayerPos, _dir)) |intersection| {
					if (intersection.distance <= closestDistance) {
						selectedBlockPos = voxelPos;
						selectionMin = intersection.min;
						selectionMax = intersection.max;
						selectionFace = intersection.face;
						break;
					}
				}
			}
			posBeforeBlock = voxelPos;
			if (tMax[0] < tMax[1]) {
				if (tMax[0] < tMax[2]) {
					voxelPos[0] +%= step[0];
					total_tMax = tMax[0];
					tMax[0] += tDelta[0];
					neighborOfSelection = if (step[0] == 1) .dirPosX else .dirNegX;
				} else {
					voxelPos[2] +%= step[2];
					total_tMax = tMax[2];
					tMax[2] += tDelta[2];
					neighborOfSelection = if (step[2] == 1) .dirUp else .dirDown;
				}
			} else {
				if (tMax[1] < tMax[2]) {
					voxelPos[1] +%= step[1];
					total_tMax = tMax[1];
					tMax[1] += tDelta[1];
					neighborOfSelection = if (step[1] == 1) .dirPosY else .dirNegY;
				} else {
					voxelPos[2] +%= step[2];
					total_tMax = tMax[2];
					tMax[2] += tDelta[2];
					neighborOfSelection = if (step[2] == 1) .dirUp else .dirDown;
				}
			}
		}
		// TODO: Test entities
	}

	fn canPlaceBlock(pos: Vec3i, block: main.blocks.Block) bool {
		if (main.game.collision.collideWithBlock(block, pos[0], pos[1], pos[2], main.game.Player.getPosBlocking() + main.game.Player.outerBoundingBox.center(), main.game.Player.outerBoundingBox.extent(), .{0, 0, 0}) != null) {
			return false;
		}
		return true; // TODO: Check other entities
	}

	pub fn placeBlock(inventory: main.items.Inventory.ClientInventory, slot: u32) void {
		if (selectedBlockPos) |selectedPos| {
			var oldBlock = mesh_storage.getBlockFromRenderThread(selectedPos[0], selectedPos[1], selectedPos[2]) orelse return;
			var block = oldBlock;
			switch (inventory.getItem(slot)) {
				.baseItem => |baseItem| {
					if (baseItem.block()) |itemBlock| {
						const rotationMode = blocks.Block.mode(.{.typ = itemBlock, .data = 0});
						var neighborDir = Vec3i{0, 0, 0};
						// Check if stuff can be added to the block itself:
						if (itemBlock == block.typ) {
							const relPos: Vec3f = @floatCast(lastPos - @as(Vec3d, @floatFromInt(selectedPos)));
							if (rotationMode.generateData(main.game.world.?, selectedPos, relPos, lastDir, neighborDir, null, &block, .{.typ = 0, .data = 0}, false)) {
								if (!canPlaceBlock(selectedPos, block)) return;
								updateBlockAndSendUpdate(inventory, slot, selectedPos[0], selectedPos[1], selectedPos[2], oldBlock, block);
								return;
							}
						} else {
							if (rotationMode.modifyBlock(&block, itemBlock)) {
								if (!canPlaceBlock(selectedPos, block)) return;
								updateBlockAndSendUpdate(inventory, slot, selectedPos[0], selectedPos[1], selectedPos[2], oldBlock, block);
								return;
							}
						}
						// Check the block in front of it:
						const neighborPos = posBeforeBlock;
						neighborDir = selectedPos - posBeforeBlock;
						const relPos: Vec3f = @floatCast(lastPos - @as(Vec3d, @floatFromInt(neighborPos)));
						const neighborBlock = block;
						oldBlock = mesh_storage.getBlockFromRenderThread(neighborPos[0], neighborPos[1], neighborPos[2]) orelse return;
						block = oldBlock;
						if (block.typ == itemBlock) {
							if (rotationMode.generateData(main.game.world.?, neighborPos, relPos, lastDir, neighborDir, neighborOfSelection, &block, neighborBlock, false)) {
								if (!canPlaceBlock(neighborPos, block)) return;
								updateBlockAndSendUpdate(inventory, slot, neighborPos[0], neighborPos[1], neighborPos[2], oldBlock, block);
								return;
							}
						} else {
							if (!block.replacable()) return;
							block.typ = itemBlock;
							block.data = 0;
							if (rotationMode.generateData(main.game.world.?, neighborPos, relPos, lastDir, neighborDir, neighborOfSelection, &block, neighborBlock, true)) {
								if (!canPlaceBlock(neighborPos, block)) return;
								updateBlockAndSendUpdate(inventory, slot, neighborPos[0], neighborPos[1], neighborPos[2], oldBlock, block);
								return;
							}
						}
					}
					if (std.mem.eql(u8, baseItem.id(), "cubyz:selection_wand")) {
						game.Player.selectionPosition2 = selectedPos;
						main.network.protocols.genericUpdate.sendWorldEditPos(main.game.world.?.conn, .selectedPos2, selectedPos);
						return;
					}
				},
				.tool => |tool| {
					_ = tool; // TODO: Tools might change existing blocks.
				},
				.null => {},
			}
		}
	}

	pub fn breakBlock(inventory: main.items.Inventory.ClientInventory, slot: u32, deltaTime: f64) void {
		if (selectedBlockPos) |selectedPos| {
			const stack = inventory.getStack(slot);
			const isSelectionWand = stack.item == .baseItem and std.mem.eql(u8, stack.item.baseItem.id(), "cubyz:selection_wand");
			if (isSelectionWand) {
				game.Player.selectionPosition1 = selectedPos;
				main.network.protocols.genericUpdate.sendWorldEditPos(main.game.world.?.conn, .selectedPos1, selectedPos);
				return;
			}

			if (@reduce(.Or, lastSelectedBlockPos != selectedPos)) {
				mesh_storage.removeBreakingAnimation(lastSelectedBlockPos);
				currentSwingProgress = 0;
				currentSwingTime = 0;
				lastSelectedBlockPos = selectedPos;
				currentBlockProgress = 0;
			}
			const block = mesh_storage.getBlockFromRenderThread(selectedPos[0], selectedPos[1], selectedPos[2]) orelse return;
			const holdingTargetedBlock = stack.item == .baseItem and stack.item.baseItem.block() == block.typ;
			if ((block.hasTag(.fluid) or block.hasTag(.air)) and !holdingTargetedBlock) return;

			const relPos: Vec3f = @floatCast(lastPos - @as(Vec3d, @floatFromInt(selectedPos)));

			main.sync.ClientSide.mutex.lock();
			if (!game.Player.isCreative()) {
				var damage: f32 = main.game.Player.defaultBlockDamage;
				const isTool = stack.item == .tool;
				if (isTool) {
					damage = stack.item.tool.getBlockDamage(block);
				}
				damage -= block.blockResistance();
				if (damage > 0) {
					const swingTime = if (isTool and stack.item.tool.isEffectiveOn(block)) 1.0/stack.item.tool.swingSpeed else 0.5;
					if (currentSwingTime > swingTime) {
						currentSwingProgress = 0;
						currentSwingTime = 0;
					}
					if (currentSwingTime == 0) {
						const swings = @ceil(block.blockHealth()/damage);
						const damagePerSwing = block.blockHealth()/swings;
						currentSwingTime = damagePerSwing/damage*swingTime;
					}
					currentSwingProgress += @floatCast(deltaTime);
					while (currentSwingProgress > currentSwingTime) {
						currentSwingProgress -= currentSwingTime;
						currentBlockProgress += damage*currentSwingTime/swingTime/block.blockHealth();
						if (currentBlockProgress > 0.9999) break;
						const swings = @ceil(block.blockHealth()/damage);
						const damagePerSwing = block.blockHealth()/swings;
						currentSwingTime = damagePerSwing/damage*swingTime;
					}
					if (currentBlockProgress < 0.9999) {
						mesh_storage.removeBreakingAnimation(lastSelectedBlockPos);
						if (currentBlockProgress != 0) {
							mesh_storage.addBreakingAnimation(lastSelectedBlockPos, currentBlockProgress);
						}
						main.sync.ClientSide.mutex.unlock();

						return;
					} else {
						currentSwingProgress = 0;
						mesh_storage.removeBreakingAnimation(lastSelectedBlockPos);
						currentBlockProgress = 0;
						currentSwingTime = 0;
					}
				} else {
					main.sync.ClientSide.mutex.unlock();
					return;
				}
			}

			var newBlock = block;
			block.mode().onBlockBreaking(inventory.getStack(slot).item, relPos, lastDir, &newBlock);
			main.sync.ClientSide.mutex.unlock();

			if (newBlock != block) {
				updateBlockAndSendUpdate(inventory, slot, selectedPos[0], selectedPos[1], selectedPos[2], block, newBlock);
			}
		}
	}

	fn updateBlockAndSendUpdate(source: main.items.Inventory.ClientInventory, slot: u32, x: i32, y: i32, z: i32, oldBlock: blocks.Block, newBlock: blocks.Block) void {
		main.sync.ClientSide.executeCommand(.{
			.updateBlock = .{
				.source = .{.inv = source.super, .slot = slot},
				.pos = .{x, y, z},
				.dropLocation = .{
					.dir = selectionFace,
					.min = selectionMin,
					.max = selectionMax,
				},
				.oldBlock = oldBlock,
				.newBlock = newBlock,
			},
		});
		mesh_storage.updateBlock(.{.x = x, .y = y, .z = z, .newBlock = newBlock, .blockEntityData = &.{}});
	}

	pub fn drawCube(projectionMatrix: Mat4f, viewMatrix: Mat4f, relativePositionToPlayer: Vec3d, min: Vec3f, max: Vec3f) void {
		pipeline.bind(null);

		c.glUniformMatrix4fv(uniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projectionMatrix));
		c.glUniformMatrix4fv(uniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&viewMatrix));

		c.glUniform3f(
			uniforms.modelPosition,
			@floatCast(relativePositionToPlayer[0]),
			@floatCast(relativePositionToPlayer[1]),
			@floatCast(relativePositionToPlayer[2]),
		);
		c.glUniform3f(uniforms.lowerBounds, min[0], min[1], min[2]);
		c.glUniform3f(uniforms.upperBounds, max[0], max[1], max[2]);
		c.glUniform1f(uniforms.lineSize, 1.0/128.0);

		c.glBindVertexArray(main.renderer.chunk_meshing.vao);
		c.glDrawElements(c.GL_TRIANGLES, 12*6*6, c.GL_UNSIGNED_INT, null);
	}

	pub fn render(projectionMatrix: Mat4f, viewMatrix: Mat4f, playerPos: Vec3d) void {
		if (main.gui.hideGui) return;
		if (selectedBlockPos) |_selectedBlockPos| {
			drawCube(projectionMatrix, viewMatrix, @as(Vec3d, @floatFromInt(_selectedBlockPos)) - playerPos, selectionMin, selectionMax);
		}
		if (game.Player.selectionPosition1) |pos1| {
			if (game.Player.selectionPosition2) |pos2| {
				const bottomLeft: Vec3i = @min(pos1, pos2);
				const topRight: Vec3i = @max(pos1, pos2);
				drawCube(projectionMatrix, viewMatrix, @as(Vec3d, @floatFromInt(bottomLeft)) - playerPos, .{0, 0, 0}, @floatFromInt(topRight - bottomLeft + Vec3i{1, 1, 1}));
			}
		}
	}
};

```

`src/renderer/chunk_meshing.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;
const builtin = @import("builtin");

const main = @import("main");
const blocks = main.blocks;
const Block = blocks.Block;
const chunk = main.chunk;
const game = main.game;
const models = main.models;
const QuadIndex = models.QuadIndex;
const renderer = main.renderer;
const graphics = main.graphics;
const c = graphics.c;
const SSBO = graphics.SSBO;
const lighting = @import("lighting.zig");
const settings = main.settings;
const vec = main.vec;
const Vec2f = vec.Vec2f;
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;
const Vec3d = vec.Vec3d;
const Mat4f = vec.Mat4f;
const gpu_performance_measuring = main.gui.windowlist.gpu_performance_measuring;

const mesh_storage = @import("mesh_storage.zig");

var pipeline: graphics.Pipeline = undefined;
var transparentPipeline: graphics.Pipeline = undefined;
const UniformStruct = struct {
	projectionMatrix: c_int,
	viewMatrix: c_int,
	playerPositionInteger: c_int,
	playerPositionFraction: c_int,
	screenSize: c_int,
	ambientLight: c_int,
	contrast: c_int,
	@"fog.color": c_int,
	@"fog.density": c_int,
	@"fog.fogLower": c_int,
	@"fog.fogHigher": c_int,
	reflectionMapSize: c_int,
	lodDistance: c_int,
	zNear: c_int,
	zFar: c_int,
};
pub var uniforms: UniformStruct = undefined;
pub var transparentUniforms: UniformStruct = undefined;
pub var commandPipeline: graphics.ComputePipeline = undefined;
pub var commandUniforms: struct {
	chunkIDIndex: c_int,
	commandIndexStart: c_int,
	size: c_int,
	isTransparent: c_int,
	playerPositionInteger: c_int,
	onlyDrawPreviouslyInvisible: c_int,
	lodDistance: c_int,
} = undefined;
pub var occlusionTestPipeline: graphics.Pipeline = undefined;
pub var occlusionTestUniforms: struct {
	projectionMatrix: c_int,
	viewMatrix: c_int,
	playerPositionInteger: c_int,
	playerPositionFraction: c_int,
} = undefined;
pub var vao: c_uint = undefined;
var vbo: c_uint = undefined;
pub var faceBuffers: [settings.highestSupportedLod + 1]graphics.LargeBuffer(FaceData) = undefined;
pub var lightBuffers: [settings.highestSupportedLod + 1]graphics.LargeBuffer(u32) = undefined;
pub var chunkBuffer: graphics.LargeBuffer(ChunkData) = undefined;
pub var commandBuffer: graphics.LargeBuffer(IndirectData) = undefined;
pub var chunkIDBuffer: graphics.LargeBuffer(u32) = undefined;
pub var quadsDrawn: usize = 0;
pub var transparentQuadsDrawn: usize = 0;
pub const maxQuadsInIndexBuffer = 3 << (3*chunk.chunkShift); // maximum 3 faces/block

pub fn init() void {
	lighting.init();
	pipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/chunks/chunk_vertex.vert",
		"assets/cubyz/shaders/chunks/chunk_fragment.frag",
		"",
		&uniforms,
		.{},
		.{.depthTest = true, .depthWrite = true},
		.{.attachments = &.{.noBlending}},
	);
	transparentPipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/chunks/chunk_vertex.vert",
		"assets/cubyz/shaders/chunks/transparent_fragment.frag",
		"#define transparent\n",
		&transparentUniforms,
		.{},
		.{.depthTest = true, .depthWrite = false, .depthCompare = .lessOrEqual},
		.{.attachments = &.{.{
			.srcColorBlendFactor = .one,
			.dstColorBlendFactor = .src1Color,
			.colorBlendOp = .add,
			.srcAlphaBlendFactor = .one,
			.dstAlphaBlendFactor = .src1Alpha,
			.alphaBlendOp = .add,
		}}},
	);
	commandPipeline = graphics.ComputePipeline.init("assets/cubyz/shaders/chunks/fillIndirectBuffer.comp", "", &commandUniforms);
	occlusionTestPipeline = graphics.Pipeline.init(
		"assets/cubyz/shaders/chunks/occlusionTestVertex.vert",
		"assets/cubyz/shaders/chunks/occlusionTestFragment.frag",
		"",
		&occlusionTestUniforms,
		.{},
		.{.depthTest = true, .depthWrite = false},
		.{.attachments = &.{.{
			.enabled = false,
			.srcColorBlendFactor = undefined,
			.dstColorBlendFactor = undefined,
			.colorBlendOp = undefined,
			.srcAlphaBlendFactor = undefined,
			.dstAlphaBlendFactor = undefined,
			.alphaBlendOp = undefined,
			.colorWriteMask = .none,
		}}},
	);

	var rawData: [6*maxQuadsInIndexBuffer]u32 = undefined;
	const lut = [_]u32{0, 2, 1, 1, 2, 3};
	for (0..rawData.len) |i| {
		rawData[i] = @as(u32, @intCast(i))/6*4 + lut[i%6];
	}

	c.glGenVertexArrays(1, &vao);
	c.glBindVertexArray(vao);
	c.glGenBuffers(1, &vbo);
	c.glBindBuffer(c.GL_ELEMENT_ARRAY_BUFFER, vbo);
	c.glBufferData(c.GL_ELEMENT_ARRAY_BUFFER, rawData.len*@sizeOf(u32), &rawData, c.GL_STATIC_DRAW);
	c.glBindVertexArray(0);

	for (0..settings.highestSupportedLod + 1) |i| {
		faceBuffers[i].init(main.globalAllocator, 1 << 20, 3);
		lightBuffers[i].init(main.globalAllocator, 1 << 20, 10);
	}
	chunkBuffer.init(main.globalAllocator, 1 << 20, 6);
	commandBuffer.init(main.globalAllocator, 1 << 20, 8);
	chunkIDBuffer.init(main.globalAllocator, 1 << 20, 9);
}

pub fn deinit() void {
	lighting.deinit();
	pipeline.deinit();
	transparentPipeline.deinit();
	occlusionTestPipeline.deinit();
	commandPipeline.deinit();
	c.glDeleteVertexArrays(1, &vao);
	c.glDeleteBuffers(1, &vbo);
	for (0..settings.highestSupportedLod + 1) |i| {
		faceBuffers[i].deinit();
		lightBuffers[i].deinit();
	}
	chunkBuffer.deinit();
	commandBuffer.deinit();
	chunkIDBuffer.deinit();
}

pub fn beginRender() void {
	for (0..settings.highestSupportedLod + 1) |i| {
		faceBuffers[i].beginRender();
		lightBuffers[i].beginRender();
	}
	chunkBuffer.beginRender();
	commandBuffer.beginRender();
	chunkIDBuffer.beginRender();
}

pub fn endRender() void {
	for (0..settings.highestSupportedLod + 1) |i| {
		faceBuffers[i].endRender();
		lightBuffers[i].endRender();
	}
	chunkBuffer.endRender();
	commandBuffer.endRender();
	chunkIDBuffer.endRender();
}

fn bindCommonUniforms(locations: *UniformStruct, projMatrix: Mat4f, ambient: Vec3f, playerPos: Vec3d) void {
	c.glUniformMatrix4fv(locations.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projMatrix));

	c.glUniform1f(locations.reflectionMapSize, renderer.reflectionCubeMapSize);

	c.glUniform1f(locations.contrast, main.settings.blockContrast);

	c.glUniform1f(locations.lodDistance, main.settings.@"lod0.5Distance");

	c.glUniformMatrix4fv(locations.viewMatrix, 1, c.GL_TRUE, @ptrCast(&game.camera.viewMatrix));

	c.glUniform3f(locations.ambientLight, ambient[0], ambient[1], ambient[2]);

	c.glUniform1f(locations.zNear, renderer.zNear);
	c.glUniform1f(locations.zFar, renderer.zFar);

	c.glUniform3i(locations.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
	c.glUniform3f(locations.playerPositionFraction, @floatCast(@mod(playerPos[0], 1)), @floatCast(@mod(playerPos[1], 1)), @floatCast(@mod(playerPos[2], 1)));
}

pub fn bindShaderAndUniforms(projMatrix: Mat4f, ambient: Vec3f, playerPos: Vec3d) void {
	pipeline.bind(null);

	bindCommonUniforms(&uniforms, projMatrix, ambient, playerPos);

	c.glBindVertexArray(vao);
}

pub fn bindTransparentShaderAndUniforms(projMatrix: Mat4f, ambient: Vec3f, playerPos: Vec3d) void {
	transparentPipeline.bind(null);

	c.glUniform3fv(transparentUniforms.@"fog.color", 1, @ptrCast(&game.fog.fogColor));
	c.glUniform1f(transparentUniforms.@"fog.density", game.fog.density);
	c.glUniform1f(transparentUniforms.@"fog.fogLower", game.fog.fogLower);
	c.glUniform1f(transparentUniforms.@"fog.fogHigher", game.fog.fogHigher);

	bindCommonUniforms(&transparentUniforms, projMatrix, ambient, playerPos);

	c.glBindVertexArray(vao);
}

fn bindBuffers(lod: usize) void {
	faceBuffers[lod].ssbo.bind(faceBuffers[lod].binding);
	lightBuffers[lod].ssbo.bind(lightBuffers[lod].binding);
}

pub fn drawChunksIndirect(chunkIds: *const [main.settings.highestSupportedLod + 1]main.List(u32), projMatrix: Mat4f, ambient: Vec3f, playerPos: Vec3d, transparent: bool) void {
	for (0..chunkIds.len) |i| {
		const lod = if (transparent) main.settings.highestSupportedLod - i else i;
		bindBuffers(lod);
		drawChunksOfLod(chunkIds[lod].items, projMatrix, ambient, playerPos, transparent);
	}
}

fn drawChunksOfLod(chunkIDs: []const u32, projMatrix: Mat4f, ambient: Vec3f, playerPos: Vec3d, transparent: bool) void {
	if (chunkIDs.len == 0) return;
	const drawCallsEstimate: u31 = @intCast(if (transparent) chunkIDs.len else chunkIDs.len*8);
	var chunkIDAllocation: main.graphics.SubAllocation = .{.start = 0, .len = 0};
	chunkIDBuffer.uploadData(chunkIDs, &chunkIDAllocation);
	defer chunkIDBuffer.free(chunkIDAllocation);
	const allocation = commandBuffer.rawAlloc(drawCallsEstimate);
	defer commandBuffer.free(allocation);
	commandPipeline.bind();
	c.glUniform1f(commandUniforms.lodDistance, main.settings.@"lod0.5Distance");
	c.glUniform1ui(commandUniforms.chunkIDIndex, chunkIDAllocation.start);
	c.glUniform1ui(commandUniforms.commandIndexStart, allocation.start);
	c.glUniform1ui(commandUniforms.size, @intCast(chunkIDs.len));
	c.glUniform1i(commandUniforms.isTransparent, @intFromBool(transparent));
	c.glUniform3i(commandUniforms.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
	if (!transparent) {
		c.glUniform1i(commandUniforms.onlyDrawPreviouslyInvisible, 0);
		c.glDispatchCompute(@intCast(@divFloor(chunkIDs.len + 63, 64)), 1, 1); // TODO: Replace with @divCeil once available
		c.glMemoryBarrier(c.GL_SHADER_STORAGE_BARRIER_BIT | c.GL_COMMAND_BARRIER_BIT);

		if (transparent) {
			bindTransparentShaderAndUniforms(projMatrix, ambient, playerPos);
		} else {
			bindShaderAndUniforms(projMatrix, ambient, playerPos);
		}
		c.glBindBuffer(c.GL_DRAW_INDIRECT_BUFFER, commandBuffer.ssbo.bufferID);
		c.glMultiDrawElementsIndirect(c.GL_TRIANGLES, c.GL_UNSIGNED_INT, @ptrFromInt(allocation.start*@sizeOf(IndirectData)), drawCallsEstimate, 0);
	}

	// Occlusion tests:
	occlusionTestPipeline.bind(null);
	c.glUniform3i(occlusionTestUniforms.playerPositionInteger, @intFromFloat(@floor(playerPos[0])), @intFromFloat(@floor(playerPos[1])), @intFromFloat(@floor(playerPos[2])));
	c.glUniform3f(occlusionTestUniforms.playerPositionFraction, @floatCast(@mod(playerPos[0], 1)), @floatCast(@mod(playerPos[1], 1)), @floatCast(@mod(playerPos[2], 1)));
	c.glUniformMatrix4fv(occlusionTestUniforms.projectionMatrix, 1, c.GL_TRUE, @ptrCast(&projMatrix));
	c.glUniformMatrix4fv(occlusionTestUniforms.viewMatrix, 1, c.GL_TRUE, @ptrCast(&game.camera.viewMatrix));
	c.glBindVertexArray(vao);
	c.glDrawElementsBaseVertex(c.GL_TRIANGLES, @intCast(6*6*chunkIDs.len), c.GL_UNSIGNED_INT, null, chunkIDAllocation.start*24);
	c.glMemoryBarrier(c.GL_SHADER_STORAGE_BARRIER_BIT);

	// Draw again:
	commandPipeline.bind();
	c.glUniform1i(commandUniforms.onlyDrawPreviouslyInvisible, 1);
	c.glDispatchCompute(@intCast(@divFloor(chunkIDs.len + 63, 64)), 1, 1); // TODO: Replace with @divCeil once available
	c.glMemoryBarrier(c.GL_SHADER_STORAGE_BARRIER_BIT | c.GL_COMMAND_BARRIER_BIT);

	if (transparent) {
		bindTransparentShaderAndUniforms(projMatrix, ambient, playerPos);
	} else {
		bindShaderAndUniforms(projMatrix, ambient, playerPos);
	}
	c.glBindBuffer(c.GL_DRAW_INDIRECT_BUFFER, commandBuffer.ssbo.bufferID);
	c.glMultiDrawElementsIndirect(c.GL_TRIANGLES, c.GL_UNSIGNED_INT, @ptrFromInt(allocation.start*@sizeOf(IndirectData)), drawCallsEstimate, 0);
}

pub const FaceData = extern struct {
	position: packed struct(u32) {
		x: u5,
		y: u5,
		z: u5,
		isBackFace: bool,
		lightIndex: u16 = 0,
	},
	blockAndQuad: packed struct(u32) {
		texture: u16,
		quadIndex: QuadIndex,
	},

	pub inline fn init(texture: u16, quadIndex: QuadIndex, pos: chunk.BlockPos, comptime backFace: bool) FaceData {
		return FaceData{
			.position = .{.x = pos.x, .y = pos.y, .z = pos.z, .isBackFace = backFace},
			.blockAndQuad = .{.texture = texture, .quadIndex = quadIndex},
		};
	}
};

pub const ChunkData = extern struct {
	position: Vec3i align(16),
	min: Vec3f align(16),
	max: Vec3f align(16),
	voxelSize: i32,
	lightStart: u32,
	vertexStartOpaque: u32,
	faceCountsByNormalOpaque: [14]u32,
	vertexStartTransparent: u32,
	vertexCountTransparent: u32,
	visibilityState: u32,
	oldVisibilityState: u32,
};

pub const IndirectData = extern struct {
	count: u32,
	instanceCount: u32,
	firstIndex: u32,
	baseVertex: i32,
	baseInstance: u32,
};

pub const PrimitiveMesh = struct { // MARK: PrimitiveMesh
	const FaceGroups = enum(u32) {
		core,
		neighbor0,
		neighbor1,
		neighbor2,
		neighbor3,
		neighbor4,
		neighbor5,
		neighborLod0,
		neighborLod1,
		neighborLod2,
		neighborLod3,
		neighborLod4,
		neighborLod5,
		optional,

		pub fn neighbor(n: main.chunk.Neighbor) FaceGroups {
			return @enumFromInt(@intFromEnum(FaceGroups.neighbor0) + @intFromEnum(n));
		}

		pub fn neighborLod(n: main.chunk.Neighbor) FaceGroups {
			return @enumFromInt(@intFromEnum(FaceGroups.neighborLod0) + @intFromEnum(n));
		}
	};
	completeList: main.MultiArray(FaceData, FaceGroups) = .{},
	lock: main.utils.ReadWriteLock = .{},
	bufferAllocation: graphics.SubAllocation = .{.start = 0, .len = 0},
	vertexCount: u31 = 0,
	byNormalCount: [14]u32 = @splat(0),
	wasChanged: bool = false,
	min: Vec3f = undefined,
	max: Vec3f = undefined,
	lod: u3,

	fn deinit(self: *PrimitiveMesh) void {
		faceBuffers[self.lod].free(self.bufferAllocation);
		self.completeList.deinit(main.globalAllocator);
	}

	fn replaceRange(self: *PrimitiveMesh, group: FaceGroups, items: []const FaceData) void {
		self.lock.lockWrite();
		self.completeList.replaceRange(main.globalAllocator, group, items);
		self.lock.unlockWrite();
	}

	fn finish(self: *PrimitiveMesh, parent: *ChunkMesh, lightList: *main.List(u32), lightMap: *std.AutoHashMap([4]u32, u16)) void {
		self.min = @splat(std.math.floatMax(f32));
		self.max = @splat(-std.math.floatMax(f32));

		self.lock.lockRead();
		for (self.completeList.getEverything()) |*face| {
			const light = getLight(parent, .{face.position.x, face.position.y, face.position.z}, face.blockAndQuad.texture, face.blockAndQuad.quadIndex);
			const result = lightMap.getOrPut(light) catch unreachable;
			if (!result.found_existing) {
				result.value_ptr.* = @intCast(lightList.items.len/4);
				lightList.appendSlice(&light);
			}
			face.position.lightIndex = result.value_ptr.*;
			const basePos: Vec3f = .{
				@floatFromInt(face.position.x),
				@floatFromInt(face.position.y),
				@floatFromInt(face.position.z),
			};
			for (face.blockAndQuad.quadIndex.quadInfo().corners) |cornerPos| {
				self.min = @min(self.min, basePos + cornerPos);
				self.max = @max(self.max, basePos + cornerPos);
			}
		}
		self.lock.unlockRead();
	}

	const LightVector = @Vector(8, u16);

	fn getValues(mesh: *ChunkMesh, pos: chunk.BlockPos) LightVector {
		const blockLight = mesh.lightingData[0].getValue(pos);
		const sunLight = mesh.lightingData[1].getValue(pos);
		std.debug.assert(builtin.cpu.arch.endian() == .little);
		const totalLight = @as(u64, sunLight.raw()) | (@as(u64, blockLight.raw()) << 32);
		return @as(@Vector(8, u8), @bitCast(totalLight));
	}

	fn getLightAt(parent: *ChunkMesh, x: i32, y: i32, z: i32) LightVector {
		const pos: chunk.BlockPos = .fromCoords(@intCast(x & chunk.chunkMask), @intCast(y & chunk.chunkMask), @intCast(z & chunk.chunkMask));
		if (x == pos.x and y == pos.y and z == pos.z) {
			return getValues(parent, pos);
		}
		const wx = parent.pos.wx +% x*parent.pos.voxelSize;
		const wy = parent.pos.wy +% y*parent.pos.voxelSize;
		const wz = parent.pos.wz +% z*parent.pos.voxelSize;
		const neighborMesh = mesh_storage.getMesh(.{.wx = wx, .wy = wy, .wz = wz, .voxelSize = parent.pos.voxelSize}) orelse return @splat(0);
		return getValues(neighborMesh, pos);
	}

	fn getCornerLight(parent: *ChunkMesh, pos: Vec3i, normal: Vec3f) LightVector {
		const lightPos = @as(Vec3f, @floatFromInt(pos)) + normal*@as(Vec3f, @splat(0.5)) - @as(Vec3f, @splat(0.5));
		const startPos: Vec3i = @intFromFloat(@floor(lightPos));
		const interp = lightPos - @floor(lightPos);
		var val: LightVector = @splat(0);
		var dx: i32 = 0;
		while (dx <= 1) : (dx += 1) {
			var dy: i32 = 0;
			while (dy <= 1) : (dy += 1) {
				var dz: i32 = 0;
				while (dz <= 1) : (dz += 1) {
					var weight: f32 = 0;
					if (dx == 0) weight = 1 - interp[0] else weight = interp[0];
					if (dy == 0) weight *= 1 - interp[1] else weight *= interp[1];
					if (dz == 0) weight *= 1 - interp[2] else weight *= interp[2];
					const integerWeight: u16 = @intFromFloat(weight*256);
					const lightVal: LightVector = getLightAt(parent, startPos[0] +% dx, startPos[1] +% dy, startPos[2] +% dz);
					val += lightVal*@as(LightVector, @splat(integerWeight));
				}
			}
		}
		return val/@as(LightVector, @splat(256));
	}

	fn getLightSampleAligned(parent: *ChunkMesh, pos: Vec3i, direction: chunk.Neighbor) LightVector {
		var lightVal: LightVector = getLightAt(parent, pos[0], pos[1], pos[2]);
		if (parent.pos.voxelSize == 1) {
			const nextVal = getLightAt(parent, pos[0] +% direction.relX(), pos[1] +% direction.relY(), pos[2] +% direction.relZ());
			const diff: LightVector = @min(@as(LightVector, @splat(8)), lightVal -| nextVal);
			lightVal = lightVal -| diff*@as(LightVector, @splat(5))/@as(LightVector, @splat(2));
		}
		return lightVal;
	}

	fn packLightValues(rawVals: [4]LightVector) [4]u32 {
		var result: [4]u32 = undefined;
		for (0..4) |i| {
			result[i] = (@as(u32, rawVals[i][0] >> 3) << 25 |
				@as(u32, rawVals[i][1] >> 3) << 20 |
				@as(u32, rawVals[i][2] >> 3) << 15 |
				@as(u32, rawVals[i][4] >> 3) << 10 |
				@as(u32, rawVals[i][5] >> 3) << 5 |
				@as(u32, rawVals[i][6] >> 3) << 0);
		}
		return result;
	}

	pub fn getLight(parent: *ChunkMesh, blockPos: Vec3i, textureIndex: u16, quadIndex: QuadIndex) [4]u32 {
		const quadInfo = quadIndex.quadInfo();
		const extraQuadInfo = quadIndex.extraQuadInfo();
		const normal = quadInfo.normal;
		if (!blocks.meshes.textureOcclusionData[textureIndex].load(.monotonic)) { // No ambient occlusion (→ no smooth lighting)
			const fullValues = getLightAt(parent, blockPos[0], blockPos[1], blockPos[2]);
			return packLightValues(@splat(fullValues));
		}
		if (extraQuadInfo.alignedNormalDirection) |dir| { // Fast path using precomputed samples
			var lightValues: [4]LightVector = @splat(@splat(0));
			for (extraQuadInfo.lightSampleListForAxisAlignedModels) |sample| {
				const lightVal = getLightSampleAligned(parent, blockPos +% sample.offset, dir);
				for (0..4) |i| {
					lightValues[i] += @as(LightVector, @splat(sample.weights[i]))*lightVal;
				}
			}
			for (0..4) |i| {
				lightValues[i] /= @splat(256);
			}
			return packLightValues(lightValues);
		}
		if (extraQuadInfo.hasOnlyCornerVertices) { // Fast path for simple quads.
			var rawVals: [4]LightVector = undefined;
			for (0..4) |i| {
				const vertexPos: Vec3f = quadInfo.corners[i];
				const fullPos = blockPos +% @as(Vec3i, @intFromFloat(vertexPos));
				rawVals[i] = getCornerLight(parent, fullPos, normal);
			}
			return packLightValues(rawVals);
		}
		var rawVals: [4]LightVector = undefined;
		for (0..4) |i| {
			const vertexPos: Vec3f = quadInfo.corners[i];
			const lightPos = vertexPos + @as(Vec3f, @floatFromInt(blockPos));
			const containingBlockPos: Vec3i = @intFromFloat(@floor(lightPos));
			const interp = std.math.clamp(lightPos - @as(Vec3f, @floatFromInt(containingBlockPos)), @as(Vec3f, @splat(0)), @as(Vec3f, @splat(1)));

			var cornerVals: [2][2][2]LightVector = undefined;
			{
				var dx: u31 = 0;
				while (dx <= 1) : (dx += 1) {
					var dy: u31 = 0;
					while (dy <= 1) : (dy += 1) {
						var dz: u31 = 0;
						while (dz <= 1) : (dz += 1) {
							cornerVals[dx][dy][dz] = getCornerLight(parent, containingBlockPos +% Vec3i{dx, dy, dz}, normal);
						}
					}
				}
			}

			var val: LightVector = @splat(0);
			for (0..2) |dx| {
				for (0..2) |dy| {
					for (0..2) |dz| {
						var weight: f32 = 0;
						if (dx == 0) weight = 1 - interp[0] else weight = interp[0];
						if (dy == 0) weight *= 1 - interp[1] else weight *= interp[1];
						if (dz == 0) weight *= 1 - interp[2] else weight *= interp[2];
						const integerWeight: u16 = @intFromFloat(weight*256);
						val += cornerVals[dx][dy][dz]*@as(LightVector, @splat(integerWeight));
					}
				}
			}
			rawVals[i] = val/@as(LightVector, @splat(256));
		}
		return packLightValues(rawVals);
	}

	fn uploadData(self: *PrimitiveMesh, isNeighborLod: [6]bool) void {
		self.lock.lockRead();
		defer self.lock.unlockRead();
		var len: usize = 0;
		const coreList = self.completeList.getRange(.core);
		len += coreList.len;
		const optionalList = self.completeList.getRange(.optional);
		len += optionalList.len;
		var list: [6][]FaceData = undefined;
		for (0..6) |i| {
			if (!isNeighborLod[i]) {
				list[i] = self.completeList.getRange(.neighbor(@enumFromInt(i)));
			} else {
				list[i] = self.completeList.getRange(.neighborLod(@enumFromInt(i)));
			}
			len += list[i].len;
		}

		const fullBuffer = faceBuffers[self.lod].allocateAndMapRange(len, &self.bufferAllocation);
		defer faceBuffers[self.lod].unmapRange(fullBuffer);
		// Sort the faces by normal to allow for backface culling on the GPU:
		var i: u32 = 0;
		var iStart = i;
		for (0..7) |normal| {
			for (coreList) |face| {
				if (face.blockAndQuad.quadIndex.extraQuadInfo().alignedNormalDirection) |normalDir| {
					if (normalDir.toInt() == normal) {
						fullBuffer[i] = face;
						i += 1;
					}
				} else if (normal == 6) {
					fullBuffer[i] = face;
					i += 1;
				}
			}
			if (normal < 6) {
				const normalDir: chunk.Neighbor = @enumFromInt(normal);
				@memcpy(fullBuffer[i..][0..list[normalDir.reverse().toInt()].len], list[normalDir.reverse().toInt()]);
				i += @intCast(list[normalDir.reverse().toInt()].len);
			}
			self.byNormalCount[normal] = i - iStart;
			iStart = i;
		}
		for (0..7) |normal| {
			for (optionalList) |face| {
				if (face.blockAndQuad.quadIndex.extraQuadInfo().alignedNormalDirection) |normalDir| {
					if (normalDir.toInt() == normal) {
						fullBuffer[i] = face;
						i += 1;
					}
				} else if (normal == 6) {
					fullBuffer[i] = face;
					i += 1;
				}
			}
			self.byNormalCount[normal + 7] = i - iStart;
			iStart = i;
		}
		std.debug.assert(i == fullBuffer.len);
		self.vertexCount = @intCast(6*fullBuffer.len);
		self.wasChanged = true;
	}
};

pub const ChunkMesh = struct { // MARK: ChunkMesh
	const SortingData = struct {
		face: FaceData,
		distance: u32,
		isBackFace: bool,
		shouldBeCulled: bool,

		pub fn update(self: *SortingData, chunkDx: i32, chunkDy: i32, chunkDz: i32) void {
			const x: i32 = self.face.position.x;
			const y: i32 = self.face.position.y;
			const z: i32 = self.face.position.z;
			const dx = x + chunkDx;
			const dy = y + chunkDy;
			const dz = z + chunkDz;
			self.isBackFace = self.face.position.isBackFace;
			const quadIndex = self.face.blockAndQuad.quadIndex;
			const normalVector: Vec3f = quadIndex.quadInfo().normal;
			self.shouldBeCulled = vec.dot(normalVector, @floatFromInt(Vec3i{dx, dy, dz})) > 0; // TODO: Adjust for arbitrary voxel models.
			const fullDx = dx - @as(i32, @intFromFloat(normalVector[0])); // TODO: This calculation should only be done for border faces.
			const fullDy = dy - @as(i32, @intFromFloat(normalVector[1]));
			const fullDz = dz - @as(i32, @intFromFloat(normalVector[2]));
			self.distance = @abs(fullDx) + @abs(fullDy) + @abs(fullDz);
		}
	};
	pos: chunk.ChunkPosition,
	size: i32,
	chunk: *chunk.Chunk,
	lightingData: [2]*lighting.ChannelChunk,
	opaqueMesh: PrimitiveMesh,
	transparentMesh: PrimitiveMesh,
	lightList: []u32 = &.{},
	lightListNeedsUpload: bool = false,
	lightAllocation: graphics.SubAllocation = .{.start = 0, .len = 0},

	lastNeighborsSameLod: [6]?*const ChunkMesh = @splat(null),
	lastNeighborsHigherLod: [6]?*const ChunkMesh = @splat(null),
	isNeighborLod: [6]bool = @splat(false),
	currentSorting: []SortingData = &.{},
	sortingOutputBuffer: []FaceData = &.{},
	culledSortingCount: u31 = 0,
	lastTransparentUpdatePos: Vec3i = Vec3i{0, 0, 0},
	needsLightRefresh: std.atomic.Value(bool) = .init(false),
	needsMeshUpdate: bool = false,
	finishedMeshing: bool = false, // Must be synced with node.finishedMeshing in mesh_storage.zig
	finishedLighting: bool = false,
	litNeighbors: Atomic(u32) = .init(0),
	mutex: std.Thread.Mutex = .{},
	chunkAllocation: graphics.SubAllocation = .{.start = 0, .len = 0},
	min: Vec3f = undefined,
	max: Vec3f = undefined,

	blockBreakingFaces: main.List(FaceData),
	blockBreakingFacesSortingData: []SortingData = &.{},
	blockBreakingFacesChanged: bool = false,

	pub fn init(pos: chunk.ChunkPosition, ch: *chunk.Chunk) *ChunkMesh {
		const self = mesh_storage.meshMemoryPool.create();
		self.* = ChunkMesh{
			.pos = pos,
			.size = chunk.chunkSize*pos.voxelSize,
			.opaqueMesh = .{
				.lod = @intCast(std.math.log2_int(u32, pos.voxelSize)),
			},
			.transparentMesh = .{
				.lod = @intCast(std.math.log2_int(u32, pos.voxelSize)),
			},
			.chunk = ch,
			.lightingData = .{
				lighting.ChannelChunk.init(ch, false),
				lighting.ChannelChunk.init(ch, true),
			},
			.blockBreakingFaces = .init(main.globalAllocator),
		};
		return self;
	}

	fn privateDeinit(self: *ChunkMesh) void {
		chunkBuffer.free(self.chunkAllocation);
		self.opaqueMesh.deinit();
		self.transparentMesh.deinit();
		self.chunk.unloadBlockEntities(.client);
		self.chunk.deinit();
		main.globalAllocator.free(self.currentSorting);
		main.globalAllocator.free(self.sortingOutputBuffer);
		for (self.lightingData) |lightingChunk| {
			lightingChunk.deinit();
		}
		self.blockBreakingFaces.deinit();
		main.globalAllocator.free(self.blockBreakingFacesSortingData);
		main.globalAllocator.free(self.lightList);
		lightBuffers[std.math.log2_int(u32, self.pos.voxelSize)].free(self.lightAllocation);
		mesh_storage.meshMemoryPool.destroy(self);
	}

	pub fn deferredDeinit(self: *ChunkMesh) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	pub fn scheduleLightRefresh(pos: chunk.ChunkPosition) void {
		LightRefreshTask.schedule(pos);
	}
	const LightRefreshTask = struct {
		pos: chunk.ChunkPosition,

		pub const vtable = main.utils.ThreadPool.VTable{
			.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
			.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
			.run = main.meta.castFunctionSelfToAnyopaque(run),
			.clean = main.meta.castFunctionSelfToAnyopaque(clean),
			.taskType = .misc,
		};

		pub fn schedule(pos: chunk.ChunkPosition) void {
			const task = main.globalAllocator.create(LightRefreshTask);
			task.* = .{
				.pos = pos,
			};
			main.threadPool.addTask(task, &vtable);
		}

		pub fn getPriority(_: *LightRefreshTask) f32 {
			return 1000000;
		}

		pub fn isStillNeeded(_: *LightRefreshTask) bool {
			return true;
		}

		pub fn run(self: *LightRefreshTask) void {
			defer main.globalAllocator.destroy(self);
			const mesh = mesh_storage.getMesh(self.pos) orelse return;
			if (mesh.needsLightRefresh.swap(false, .acq_rel)) {
				mesh.mutex.lock();
				mesh.finishData();
				mesh.mutex.unlock();
				mesh_storage.addToUpdateList(mesh);
			}
		}

		pub fn clean(self: *LightRefreshTask) void {
			main.globalAllocator.destroy(self);
		}
	};

	pub fn isEmpty(self: *const ChunkMesh) bool {
		return self.opaqueMesh.vertexCount == 0 and self.transparentMesh.vertexCount == 0;
	}

	fn canBeSeenThroughOtherBlock(block: Block, other: Block, neighbor: chunk.Neighbor) bool {
		const rotatedModel = blocks.meshes.model(block).model();
		_ = rotatedModel; // TODO: Check if the neighbor model occludes this one. (maybe not that relevant)
		return block.typ != 0 and (other.typ == 0 or (block != other and other.viewThrough()) or other.alwaysViewThrough() or !blocks.meshes.model(other).model().isNeighborOccluded[neighbor.reverse().toInt()]);
	}

	fn initLight(self: *ChunkMesh, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		self.mutex.lock();
		var lightEmittingBlocks = main.List(chunk.BlockPos).init(main.stackAllocator);
		defer lightEmittingBlocks.deinit();
		for (0..chunk.chunkVolume) |index| {
			const block = self.chunk.data.getValue(index);
			if (block.light() != 0) lightEmittingBlocks.append(.fromIndex(@intCast(index)));
		}
		self.mutex.unlock();
		self.lightingData[0].propagateLights(lightEmittingBlocks.items, true, lightRefreshList);
		sunLight: {
			var allSun: bool = self.chunk.data.palette().len == 1 and self.chunk.data.palette()[0].load(.unordered).typ == 0;
			var sunStarters: [chunk.chunkSize*chunk.chunkSize]chunk.BlockPos = undefined;
			var index: usize = 0;
			const lightStartMap = mesh_storage.getLightMapPiece(self.pos.wx, self.pos.wy, self.pos.voxelSize) orelse break :sunLight;
			var x: u8 = 0;
			while (x < chunk.chunkSize) : (x += 1) {
				var y: u8 = 0;
				while (y < chunk.chunkSize) : (y += 1) {
					const startHeight: i32 = lightStartMap.getHeight(self.pos.wx + x*self.pos.voxelSize, self.pos.wy + y*self.pos.voxelSize);
					const relHeight = startHeight -% self.pos.wz;
					if (relHeight < chunk.chunkSize*self.pos.voxelSize) {
						sunStarters[index] = .fromCoords(@intCast(x), @intCast(y), chunk.chunkSize - 1);
						index += 1;
					} else {
						allSun = false;
					}
				}
			}
			if (allSun) {
				self.lightingData[1].propagateUniformSun(lightRefreshList);
			} else {
				self.lightingData[1].propagateLights(sunStarters[0..index], true, lightRefreshList);
			}
		}
	}

	pub fn generateLightingData(self: *ChunkMesh) error{ AlreadyStored, NoLongerNeeded }!void {
		try mesh_storage.addMeshToStorage(self);

		var lightRefreshList = main.List(chunk.ChunkPosition).init(main.stackAllocator);
		defer lightRefreshList.deinit();
		self.initLight(&lightRefreshList);

		self.mutex.lock();
		self.finishedLighting = true;
		self.mutex.unlock();

		// Only generate a mesh if the surrounding 27 chunks finished the light generation steps.
		var dx: i32 = -1;
		while (dx <= 1) : (dx += 1) {
			var dy: i32 = -1;
			while (dy <= 1) : (dy += 1) {
				var dz: i32 = -1;
				while (dz <= 1) : (dz += 1) {
					var pos = self.pos;
					pos.wx +%= pos.voxelSize*chunk.chunkSize*dx;
					pos.wy +%= pos.voxelSize*chunk.chunkSize*dy;
					pos.wz +%= pos.voxelSize*chunk.chunkSize*dz;
					const neighborMesh = mesh_storage.getMesh(pos) orelse continue;

					const shiftSelf: u5 = @intCast(((dx + 1)*3 + dy + 1)*3 + dz + 1);
					const shiftOther: u5 = @intCast(((-dx + 1)*3 + -dy + 1)*3 + -dz + 1);
					if (neighborMesh.litNeighbors.fetchOr(@as(u27, 1) << shiftOther, .monotonic) ^ @as(u27, 1) << shiftOther == ~@as(u27, 0)) { // Trigger mesh creation for neighbor
						neighborMesh.generateMesh(&lightRefreshList);
					}
					neighborMesh.mutex.lock();
					const neighborFinishedLighting = neighborMesh.finishedLighting;
					neighborMesh.mutex.unlock();
					if (neighborFinishedLighting and self.litNeighbors.fetchOr(@as(u27, 1) << shiftSelf, .monotonic) ^ @as(u27, 1) << shiftSelf == ~@as(u27, 0)) {
						self.generateMesh(&lightRefreshList);
					}
				}
			}
		}

		for (lightRefreshList.items) |pos| {
			scheduleLightRefresh(pos);
		}
	}

	fn appendInternalQuads(block: Block, pos: chunk.BlockPos, comptime backFace: bool, list: *main.ListUnmanaged(FaceData), allocator: main.heap.NeverFailingAllocator) void {
		const model = blocks.meshes.model(block).model();
		model.appendInternalQuadsToList(list, allocator, block, pos, backFace);
	}

	fn appendNeighborFacingQuads(block: Block, neighbor: chunk.Neighbor, pos: chunk.BlockPos, comptime backFace: bool, list: *main.ListUnmanaged(FaceData), allocator: main.heap.NeverFailingAllocator) void {
		const model = blocks.meshes.model(block).model();
		model.appendNeighborFacingQuadsToList(list, allocator, block, neighbor, pos, backFace);
	}

	pub fn generateMesh(self: *ChunkMesh, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		var alwaysViewThroughMask: [chunk.chunkSize][chunk.chunkSize]u32 = undefined;
		@memset(std.mem.asBytes(&alwaysViewThroughMask), 0);
		var alwaysViewThroughMask2: [chunk.chunkSize][chunk.chunkSize]u32 = undefined;
		var canSeeNeighbor: [6][chunk.chunkSize][chunk.chunkSize]u32 = undefined;
		@memset(std.mem.asBytes(&canSeeNeighbor), 0);
		var canSeeAllNeighbors: [chunk.chunkSize][chunk.chunkSize]u32 = undefined;
		@memset(std.mem.asBytes(&canSeeAllNeighbors), 0);
		var hasFaces: [chunk.chunkSize][chunk.chunkSize]u32 = undefined;
		@memset(std.mem.asBytes(&hasFaces), 0);
		self.mutex.lock();

		var transparentCore: main.ListUnmanaged(FaceData) = .{};
		defer transparentCore.deinit(main.stackAllocator);
		var opaqueCore: main.ListUnmanaged(FaceData) = .{};
		defer opaqueCore.deinit(main.stackAllocator);
		var transparentOptional: main.ListUnmanaged(FaceData) = .{};
		defer transparentOptional.deinit(main.stackAllocator);
		var opaqueOptional: main.ListUnmanaged(FaceData) = .{};
		defer opaqueOptional.deinit(main.stackAllocator);

		const OcclusionInfo = packed struct {
			canSeeNeighbor: u6 = 0,
			canSeeAllNeighbors: bool = false,
			hasExternalQuads: bool = false,
			hasInternalQuads: bool = false,
			alwaysViewThrough: bool = false,
		};
		var paletteCache = main.stackAllocator.alloc(OcclusionInfo, self.chunk.data.palette().len);
		defer main.stackAllocator.free(paletteCache);
		for (0..self.chunk.data.palette().len) |i| {
			const block = self.chunk.data.palette()[i].load(.unordered);
			const model = blocks.meshes.model(block).model();
			var result: OcclusionInfo = .{};
			if (model.noNeighborsOccluded or block.viewThrough()) {
				result.canSeeAllNeighbors = true;
			} else if (!model.allNeighborsOccluded) {
				for (chunk.Neighbor.iterable) |neighbor| {
					if (!model.isNeighborOccluded[neighbor.toInt()]) {
						result.canSeeNeighbor |= neighbor.bitMask();
					}
				}
			}
			if (model.hasNeighborFacingQuads) {
				result.hasExternalQuads = true;
			}
			if (model.internalQuads.len != 0) {
				result.hasInternalQuads = true;
			}
			result.alwaysViewThrough = block.alwaysViewThrough() and block.opaqueVariant() != block.typ;
			paletteCache[i] = result;
		}
		// Generate the bitMasks:
		for (0..chunk.chunkVolume) |index| {
			const pos = chunk.BlockPos.fromIndex(@intCast(index));
			const paletteId = self.chunk.data.impl.raw.data.getValue(index);
			const occlusionInfo = paletteCache[paletteId];
			const setBit = @as(u32, 1) << pos.z;
			if (occlusionInfo.alwaysViewThrough or (!occlusionInfo.canSeeAllNeighbors and occlusionInfo.canSeeNeighbor == 0)) {
				alwaysViewThroughMask[pos.x][pos.y] |= setBit;
			}
		}
		const initialAlwaysViewThroughMask = alwaysViewThroughMask;
		const depthFilteredViewThroughMask = blk: {
			var a = &alwaysViewThroughMask;
			var b = &alwaysViewThroughMask2;
			for (0..main.settings.leavesQuality) |_| {
				for (0..chunk.chunkSize) |_x| {
					const x: u5 = @intCast(_x);
					for (0..chunk.chunkSize) |_y| {
						const y: u5 = @intCast(_y);
						var mask = a[x][y];
						mask &= mask << 1;
						mask &= mask >> 1;
						if (x == 0) mask = 0 else mask &= a[x - 1][y];
						if (x == chunk.chunkSize - 1) mask = 0 else mask &= a[x + 1][y];
						if (y == 0) mask = 0 else mask &= a[x][y - 1];
						if (y == chunk.chunkSize - 1) mask = 0 else mask &= a[x][y + 1];
						b[x][y] = mask;
					}
				}
				const swap = a;
				a = b;
				b = swap;
			}
			break :blk a;
		};
		for (0..chunk.chunkVolume) |index| {
			const pos = chunk.BlockPos.fromIndex(@intCast(index));
			const paletteId = self.chunk.data.impl.raw.data.getValue(index);
			const occlusionInfo = paletteCache[paletteId];
			const setBit = @as(u32, 1) << pos.z;
			if (depthFilteredViewThroughMask[pos.x][pos.y] & setBit != 0) {} else if (occlusionInfo.canSeeAllNeighbors) {
				canSeeAllNeighbors[pos.x][pos.y] |= setBit;
			} else if (occlusionInfo.canSeeNeighbor != 0) {
				for (chunk.Neighbor.iterable) |neighbor| {
					if (occlusionInfo.canSeeNeighbor & neighbor.bitMask() != 0) {
						canSeeNeighbor[neighbor.toInt()][pos.x][pos.y] |= setBit;
					}
				}
			}
			if (occlusionInfo.hasExternalQuads) {
				hasFaces[pos.x][pos.y] |= setBit;
			}
			if (occlusionInfo.hasInternalQuads) {
				const block = self.chunk.data.palette()[paletteId].load(.unordered);
				if (block.transparent()) {
					appendInternalQuads(block, pos, false, &transparentCore, main.stackAllocator);
				} else {
					appendInternalQuads(block, pos, false, &opaqueCore, main.stackAllocator);
				}
			}
		}
		// Generate the meshes:
		{
			const neighbor = chunk.Neighbor.dirNegX;
			for (1..chunk.chunkSize) |x| {
				for (0..chunk.chunkSize) |y| {
					var bitMask = hasFaces[x][y] & (canSeeNeighbor[comptime neighbor.reverse().toInt()][x - 1][y] | canSeeAllNeighbors[x - 1][y]);
					while (bitMask != 0) {
						const z: u5 = @intCast(@ctz(bitMask));
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z);
						const neighborPos: chunk.BlockPos = .fromCoords(@intCast(x - 1), @intCast(y), z);
						const setBit = @as(u32, 1) << z;
						bitMask &= ~setBit;
						var block = self.chunk.data.getValue(pos.toIndex());
						if (depthFilteredViewThroughMask[x][y] & setBit != 0) block.typ = block.opaqueVariant();
						if (block.viewThrough() and !block.alwaysViewThrough()) { // Needs to check the neighbor block
							const neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
							if (block == neighborBlock) continue;
						}
						if (block.transparent()) {
							if (block.hasBackFace()) {
								appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentCore, main.stackAllocator);
							}
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentCore, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, if (initialAlwaysViewThroughMask[x - 1][y] & setBit != 0) &opaqueOptional else &opaqueCore, main.stackAllocator);
						}
					}
				}
			}
		}
		{
			const neighbor = chunk.Neighbor.dirPosX;
			for (0..chunk.chunkSize - 1) |x| {
				for (0..chunk.chunkSize) |y| {
					var bitMask = hasFaces[x][y] & (canSeeNeighbor[comptime neighbor.reverse().toInt()][x + 1][y] | canSeeAllNeighbors[x + 1][y]);
					while (bitMask != 0) {
						const z: u5 = @intCast(@ctz(bitMask));
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z);
						const neighborPos: chunk.BlockPos = .fromCoords(@intCast(x + 1), @intCast(y), z);
						const setBit = @as(u32, 1) << z;
						bitMask &= ~setBit;
						var block = self.chunk.data.getValue(pos.toIndex());
						if (depthFilteredViewThroughMask[x][y] & setBit != 0) block.typ = block.opaqueVariant();
						if (block.viewThrough() and !block.alwaysViewThrough()) { // Needs to check the neighbor block
							const neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
							if (block == neighborBlock) continue;
						}
						if (block.transparent()) {
							if (block.hasBackFace()) {
								appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentCore, main.stackAllocator);
							}
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentCore, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, if (initialAlwaysViewThroughMask[x + 1][y] & setBit != 0) &opaqueOptional else &opaqueCore, main.stackAllocator);
						}
					}
				}
			}
		}
		{
			const neighbor = chunk.Neighbor.dirNegY;
			for (0..chunk.chunkSize) |x| {
				for (1..chunk.chunkSize) |y| {
					var bitMask = hasFaces[x][y] & (canSeeNeighbor[comptime neighbor.reverse().toInt()][x][y - 1] | canSeeAllNeighbors[x][y - 1]);
					while (bitMask != 0) {
						const z: u5 = @intCast(@ctz(bitMask));
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z);
						const neighborPos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y - 1), z);
						const setBit = @as(u32, 1) << z;
						bitMask &= ~setBit;
						var block = self.chunk.data.getValue(pos.toIndex());
						if (depthFilteredViewThroughMask[x][y] & setBit != 0) block.typ = block.opaqueVariant();
						if (block.viewThrough() and !block.alwaysViewThrough()) { // Needs to check the neighbor block
							const neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
							if (block == neighborBlock) continue;
						}
						if (block.transparent()) {
							if (block.hasBackFace()) {
								appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentCore, main.stackAllocator);
							}
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentCore, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, if (initialAlwaysViewThroughMask[x][y - 1] & setBit != 0) &opaqueOptional else &opaqueCore, main.stackAllocator);
						}
					}
				}
			}
		}
		{
			const neighbor = chunk.Neighbor.dirPosY;
			for (0..chunk.chunkSize) |x| {
				for (0..chunk.chunkSize - 1) |y| {
					var bitMask = hasFaces[x][y] & (canSeeNeighbor[comptime neighbor.reverse().toInt()][x][y + 1] | canSeeAllNeighbors[x][y + 1]);
					while (bitMask != 0) {
						const z: u5 = @intCast(@ctz(bitMask));
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z);
						const neighborPos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y + 1), z);
						const setBit = @as(u32, 1) << z;
						bitMask &= ~setBit;
						var block = self.chunk.data.getValue(pos.toIndex());
						if (depthFilteredViewThroughMask[x][y] & setBit != 0) block.typ = block.opaqueVariant();
						if (block.viewThrough() and !block.alwaysViewThrough()) { // Needs to check the neighbor block
							const neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
							if (block == neighborBlock) continue;
						}
						if (block.transparent()) {
							if (block.hasBackFace()) {
								appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentCore, main.stackAllocator);
							}
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentCore, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, if (initialAlwaysViewThroughMask[x][y + 1] & setBit != 0) &opaqueOptional else &opaqueCore, main.stackAllocator);
						}
					}
				}
			}
		}
		{
			const neighbor = chunk.Neighbor.dirDown;
			for (0..chunk.chunkSize) |x| {
				for (0..chunk.chunkSize) |y| {
					var bitMask = hasFaces[x][y] & (canSeeNeighbor[comptime neighbor.reverse().toInt()][x][y] | canSeeAllNeighbors[x][y]) << 1;
					while (bitMask != 0) {
						const z: u5 = @intCast(@ctz(bitMask));
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z);
						const neighborPos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z - 1);
						const setBit = @as(u32, 1) << z;
						bitMask &= ~setBit;
						var block = self.chunk.data.getValue(pos.toIndex());
						if (depthFilteredViewThroughMask[x][y] & setBit != 0) block.typ = block.opaqueVariant();
						if (block.viewThrough() and !block.alwaysViewThrough()) { // Needs to check the neighbor block
							const neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
							if (block == neighborBlock) continue;
						}
						if (block.transparent()) {
							if (block.hasBackFace()) {
								appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentCore, main.stackAllocator);
							}
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentCore, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, if (initialAlwaysViewThroughMask[x][y] << 1 & setBit != 0) &opaqueOptional else &opaqueCore, main.stackAllocator);
						}
					}
				}
			}
		}
		{
			const neighbor = chunk.Neighbor.dirUp;
			for (0..chunk.chunkSize) |x| {
				for (0..chunk.chunkSize) |y| {
					var bitMask = hasFaces[x][y] & (canSeeNeighbor[comptime neighbor.reverse().toInt()][x][y] | canSeeAllNeighbors[x][y]) >> 1;
					while (bitMask != 0) {
						const z: u5 = @intCast(@ctz(bitMask));
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z);
						const neighborPos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), z + 1);
						const setBit = @as(u32, 1) << z;
						bitMask &= ~setBit;
						var block = self.chunk.data.getValue(pos.toIndex());
						if (depthFilteredViewThroughMask[x][y] & setBit != 0) block.typ = block.opaqueVariant();
						if (block.viewThrough() and !block.alwaysViewThrough()) { // Needs to check the neighbor block
							const neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
							if (block == neighborBlock) continue;
						}
						if (block.transparent()) {
							if (block.hasBackFace()) {
								appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentCore, main.stackAllocator);
							}
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentCore, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(block, neighbor, neighborPos, false, if (initialAlwaysViewThroughMask[x][y] >> 1 & setBit != 0) &opaqueOptional else &opaqueCore, main.stackAllocator);
						}
					}
				}
			}
		}

		self.mutex.unlock();

		self.opaqueMesh.replaceRange(.core, opaqueCore.items);
		self.opaqueMesh.replaceRange(.optional, opaqueOptional.items);

		self.transparentMesh.replaceRange(.core, transparentCore.items);
		self.transparentMesh.replaceRange(.optional, transparentOptional.items);

		self.finishNeighbors(lightRefreshList);
	}

	fn updateBlockLight(self: *ChunkMesh, pos: chunk.BlockPos, newBlock: Block, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		for (self.lightingData[0..]) |lightingData| {
			lightingData.propagateLightsDestructive(&.{pos}, lightRefreshList);
		}
		if (newBlock.light() != 0) {
			self.lightingData[0].propagateLights(&.{pos}, false, lightRefreshList);
		}
	}

	pub fn updateBlock(self: *ChunkMesh, _x: i32, _y: i32, _z: i32, _newBlock: Block, blockEntityData: []const u8, lightRefreshList: *main.List(chunk.ChunkPosition), regenerateMeshList: *main.List(*ChunkMesh)) void {
		const blockPos = chunk.BlockPos.fromWorldCoords(_x, _y, _z);
		var newBlock = _newBlock;
		self.mutex.lock();
		const oldBlock = self.chunk.data.getValue(blockPos.toIndex());

		if (oldBlock == newBlock) {
			if (newBlock.blockEntity()) |blockEntity| {
				var reader = main.utils.BinaryReader.init(blockEntityData);
				blockEntity.updateClientData(.{_x, _y, _z}, self.chunk, .{.update = &reader}) catch |err| {
					std.log.err("Got error {s} while trying to apply block entity data {any} in position {} for block {s}", .{@errorName(err), blockEntityData, Vec3i{_x, _y, _z}, newBlock.id()});
				};
			}
			self.mutex.unlock();
			return;
		}
		self.mutex.unlock();

		if (oldBlock.blockEntity()) |blockEntity| {
			blockEntity.updateClientData(.{_x, _y, _z}, self.chunk, .remove) catch |err| {
				std.log.err("Got error {s} while trying to remove entity data in position {} for block {s}", .{@errorName(err), Vec3i{_x, _y, _z}, oldBlock.id()});
			};
		}

		var neighborBlocks: [6]Block = undefined;
		@memset(&neighborBlocks, .{.typ = 0, .data = 0});

		for (chunk.Neighbor.iterable) |neighbor| {
			const neighborPos, const chunkLocation = blockPos.neighbor(neighbor);

			if (chunkLocation == .inNeighborChunk) {
				const neighborChunkMesh = mesh_storage.getNeighbor(self.pos, self.pos.voxelSize, neighbor) orelse continue;

				neighborChunkMesh.mutex.lock();
				var neighborBlock = neighborChunkMesh.chunk.data.getValue(neighborPos.toIndex());

				if (neighborBlock.mode().dependsOnNeighbors and neighborBlock.mode().updateData(&neighborBlock, neighbor.reverse(), newBlock)) {
					neighborChunkMesh.chunk.data.setValue(neighborPos.toIndex(), neighborBlock);
					neighborChunkMesh.mutex.unlock();
					neighborChunkMesh.updateBlockLight(neighborPos, neighborBlock, lightRefreshList);
					appendIfNotContained(regenerateMeshList, neighborChunkMesh);
					neighborChunkMesh.mutex.lock();
				}
				neighborChunkMesh.mutex.unlock();
				neighborBlocks[neighbor.toInt()] = neighborBlock;
			} else {
				self.mutex.lock();
				var neighborBlock = self.chunk.data.getValue(neighborPos.toIndex());
				if (neighborBlock.mode().dependsOnNeighbors and neighborBlock.mode().updateData(&neighborBlock, neighbor.reverse(), newBlock)) {
					self.chunk.data.setValue(neighborPos.toIndex(), neighborBlock);
					self.updateBlockLight(neighborPos, neighborBlock, lightRefreshList);
				}
				self.mutex.unlock();
				neighborBlocks[neighbor.toInt()] = neighborBlock;
			}
		}
		if (newBlock.mode().dependsOnNeighbors) {
			for (chunk.Neighbor.iterable) |neighbor| {
				_ = newBlock.mode().updateData(&newBlock, neighbor, neighborBlocks[neighbor.toInt()]);
			}
		}
		self.mutex.lock();
		self.chunk.data.setValue(blockPos.toIndex(), newBlock);
		self.mutex.unlock();

		self.updateBlockLight(blockPos, newBlock, lightRefreshList);

		self.mutex.lock();
		// Update neighbor chunks:
		if (blockPos.x == 0) {
			self.lastNeighborsHigherLod[chunk.Neighbor.dirNegX.toInt()] = null;
			self.lastNeighborsSameLod[chunk.Neighbor.dirNegX.toInt()] = null;
		} else if (blockPos.x == 31) {
			self.lastNeighborsHigherLod[chunk.Neighbor.dirPosX.toInt()] = null;
			self.lastNeighborsSameLod[chunk.Neighbor.dirPosX.toInt()] = null;
		}
		if (blockPos.y == 0) {
			self.lastNeighborsHigherLod[chunk.Neighbor.dirNegY.toInt()] = null;
			self.lastNeighborsSameLod[chunk.Neighbor.dirNegY.toInt()] = null;
		} else if (blockPos.y == 31) {
			self.lastNeighborsHigherLod[chunk.Neighbor.dirPosY.toInt()] = null;
			self.lastNeighborsSameLod[chunk.Neighbor.dirPosY.toInt()] = null;
		}
		if (blockPos.z == 0) {
			self.lastNeighborsHigherLod[chunk.Neighbor.dirDown.toInt()] = null;
			self.lastNeighborsSameLod[chunk.Neighbor.dirDown.toInt()] = null;
		} else if (blockPos.z == 31) {
			self.lastNeighborsHigherLod[chunk.Neighbor.dirUp.toInt()] = null;
			self.lastNeighborsSameLod[chunk.Neighbor.dirUp.toInt()] = null;
		}
		self.mutex.unlock();

		appendIfNotContained(regenerateMeshList, self);
	}

	fn appendIfNotContained(list: *main.List(*ChunkMesh), mesh: *ChunkMesh) void {
		for (list.items) |other| {
			if (other == mesh) {
				return;
			}
		}
		list.append(mesh);
	}

	fn clearNeighborA(self: *ChunkMesh, neighbor: chunk.Neighbor, comptime isLod: bool) void {
		self.opaqueMesh.clearNeighbor(neighbor, isLod);
		self.transparentMesh.clearNeighbor(neighbor, isLod);
	}

	pub fn finishData(self: *ChunkMesh) void {
		main.utils.assertLocked(&self.mutex);

		var lightList = main.List(u32).init(main.stackAllocator);
		defer lightList.deinit();
		var lightMap = std.AutoHashMap([4]u32, u16).init(main.stackAllocator.allocator);
		defer lightMap.deinit();

		self.opaqueMesh.finish(self, &lightList, &lightMap);
		self.transparentMesh.finish(self, &lightList, &lightMap);

		self.lightList = main.globalAllocator.realloc(self.lightList, lightList.items.len);
		@memcpy(self.lightList, lightList.items);
		self.lightListNeedsUpload = true;

		self.min = @min(self.opaqueMesh.min, self.transparentMesh.min);
		self.max = @max(self.opaqueMesh.max, self.transparentMesh.max);
	}

	pub fn uploadData(self: *ChunkMesh) void {
		self.opaqueMesh.uploadData(self.isNeighborLod);
		self.transparentMesh.uploadData(self.isNeighborLod);

		self.mutex.lock();
		if (self.lightListNeedsUpload) {
			self.lightListNeedsUpload = false;
			lightBuffers[std.math.log2_int(u32, self.pos.voxelSize)].uploadData(self.lightList, &self.lightAllocation);
		}
		self.mutex.unlock();

		self.uploadChunkPosition();
	}

	fn deadlockFreeDoubleLock(m1: *std.Thread.Mutex, m2: *std.Thread.Mutex) void {
		if (@intFromPtr(m1) < @intFromPtr(m2)) {
			m1.lock();
			m2.lock();
		} else {
			m2.lock();
			m1.lock();
		}
	}

	fn finishNeighbors(self: *ChunkMesh, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		for (chunk.Neighbor.iterable) |neighbor| {
			const nullNeighborMesh = mesh_storage.getNeighbor(self.pos, self.pos.voxelSize, neighbor);
			if (nullNeighborMesh) |neighborMesh| sameLodBlock: {
				std.debug.assert(neighborMesh != self);
				deadlockFreeDoubleLock(&self.mutex, &neighborMesh.mutex);
				defer self.mutex.unlock();
				defer neighborMesh.mutex.unlock();
				if (self.lastNeighborsSameLod[neighbor.toInt()] == neighborMesh) break :sameLodBlock;
				self.lastNeighborsSameLod[neighbor.toInt()] = neighborMesh;
				neighborMesh.lastNeighborsSameLod[neighbor.reverse().toInt()] = self;

				var transparentSelf: main.ListUnmanaged(FaceData) = .{};
				defer transparentSelf.deinit(main.stackAllocator);
				var opaqueSelf: main.ListUnmanaged(FaceData) = .{};
				defer opaqueSelf.deinit(main.stackAllocator);
				var transparentNeighbor: main.ListUnmanaged(FaceData) = .{};
				defer transparentNeighbor.deinit(main.stackAllocator);
				var opaqueNeighbor: main.ListUnmanaged(FaceData) = .{};
				defer opaqueNeighbor.deinit(main.stackAllocator);

				const x3: i32 = if (neighbor.isPositive()) chunk.chunkMask else 0;
				var x1: i32 = 0;
				while (x1 < chunk.chunkSize) : (x1 += 1) {
					var x2: i32 = 0;
					while (x2 < chunk.chunkSize) : (x2 += 1) {
						var x: i32 = undefined;
						var y: i32 = undefined;
						var z: i32 = undefined;
						if (neighbor.relX() != 0) {
							x = x3;
							y = x1;
							z = x2;
						} else if (neighbor.relY() != 0) {
							x = x1;
							y = x3;
							z = x2;
						} else {
							x = x2;
							y = x1;
							z = x3;
						}
						const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), @intCast(z));
						const neighborPos, _ = pos.neighbor(neighbor);
						var block = self.chunk.data.getValue(pos.toIndex());
						if (settings.leavesQuality == 0) block.typ = block.opaqueVariant();
						var otherBlock = neighborMesh.chunk.data.getValue(neighborPos.toIndex());
						if (settings.leavesQuality == 0) otherBlock.typ = otherBlock.opaqueVariant();
						if (canBeSeenThroughOtherBlock(block, otherBlock, neighbor)) {
							if (block.transparent()) {
								if (block.hasBackFace()) {
									appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentSelf, main.stackAllocator);
								}
								appendNeighborFacingQuads(block, neighbor, neighborPos, false, &transparentNeighbor, main.stackAllocator);
							} else {
								appendNeighborFacingQuads(block, neighbor, neighborPos, false, &opaqueNeighbor, main.stackAllocator);
							}
						}
						if (canBeSeenThroughOtherBlock(otherBlock, block, neighbor.reverse())) {
							if (otherBlock.transparent()) {
								if (otherBlock.hasBackFace()) {
									appendNeighborFacingQuads(otherBlock, neighbor, neighborPos, true, &transparentNeighbor, main.stackAllocator);
								}
								appendNeighborFacingQuads(otherBlock, neighbor.reverse(), pos, false, &transparentSelf, main.stackAllocator);
							} else {
								appendNeighborFacingQuads(otherBlock, neighbor.reverse(), pos, false, &opaqueSelf, main.stackAllocator);
							}
						}
					}
				}
				self.opaqueMesh.replaceRange(.neighbor(neighbor), opaqueSelf.items);
				self.transparentMesh.replaceRange(.neighbor(neighbor), transparentSelf.items);
				neighborMesh.opaqueMesh.replaceRange(.neighbor(neighbor.reverse()), opaqueNeighbor.items);
				neighborMesh.transparentMesh.replaceRange(.neighbor(neighbor.reverse()), transparentNeighbor.items);

				_ = neighborMesh.needsLightRefresh.store(true, .release);
				lightRefreshList.append(neighborMesh.pos);
			} else {
				self.mutex.lock();
				defer self.mutex.unlock();
				if (self.lastNeighborsSameLod[neighbor.toInt()] != null) {
					self.opaqueMesh.replaceRange(.neighbor(neighbor), &.{});
					self.transparentMesh.replaceRange(.neighbor(neighbor), &.{});
					self.lastNeighborsSameLod[neighbor.toInt()] = null;
				}
			}
			// lod border:
			if (self.pos.voxelSize == @as(u31, 1) << settings.highestLod) continue;
			const neighborMesh = mesh_storage.getNeighbor(self.pos, 2*self.pos.voxelSize, neighbor) orelse {
				self.mutex.lock();
				defer self.mutex.unlock();
				if (self.lastNeighborsHigherLod[neighbor.toInt()] != null) {
					self.opaqueMesh.replaceRange(.neighborLod(neighbor), &.{});
					self.transparentMesh.replaceRange(.neighborLod(neighbor), &.{});
					self.lastNeighborsHigherLod[neighbor.toInt()] = null;
				}
				continue;
			};
			deadlockFreeDoubleLock(&self.mutex, &neighborMesh.mutex);
			defer self.mutex.unlock();
			defer neighborMesh.mutex.unlock();
			if (self.lastNeighborsHigherLod[neighbor.toInt()] == neighborMesh) continue;
			self.lastNeighborsHigherLod[neighbor.toInt()] = neighborMesh;

			var transparentSelf: main.ListUnmanaged(FaceData) = .{};
			defer transparentSelf.deinit(main.stackAllocator);
			var opaqueSelf: main.ListUnmanaged(FaceData) = .{};
			defer opaqueSelf.deinit(main.stackAllocator);

			const x3: i32 = if (neighbor.isPositive()) chunk.chunkMask else 0;
			const offsetX = @divExact(self.pos.wx, self.pos.voxelSize) & chunk.chunkSize;
			const offsetY = @divExact(self.pos.wy, self.pos.voxelSize) & chunk.chunkSize;
			const offsetZ = @divExact(self.pos.wz, self.pos.voxelSize) & chunk.chunkSize;
			var x1: i32 = 0;
			while (x1 < chunk.chunkSize) : (x1 += 1) {
				var x2: i32 = 0;
				while (x2 < chunk.chunkSize) : (x2 += 1) {
					var x: i32 = undefined;
					var y: i32 = undefined;
					var z: i32 = undefined;
					if (neighbor.relX() != 0) {
						x = x3;
						y = x1;
						z = x2;
					} else if (neighbor.relY() != 0) {
						x = x1;
						y = x3;
						z = x2;
					} else {
						x = x2;
						y = x1;
						z = x3;
					}
					const pos: chunk.BlockPos = .fromCoords(@intCast(x), @intCast(y), @intCast(z));
					const otherX = (x +% neighbor.relX() +% offsetX >> 1) & chunk.chunkMask;
					const otherY = (y +% neighbor.relY() +% offsetY >> 1) & chunk.chunkMask;
					const otherZ = (z +% neighbor.relZ() +% offsetZ >> 1) & chunk.chunkMask;
					const neighborPos: chunk.BlockPos = .fromCoords(@intCast(otherX), @intCast(otherY), @intCast(otherZ));
					var block = self.chunk.data.getValue(pos.toIndex());
					if (settings.leavesQuality == 0) block.typ = block.opaqueVariant();
					var otherBlock = neighborMesh.chunk.data.getValue(neighborPos.toIndex());
					if (settings.leavesQuality == 0) otherBlock.typ = otherBlock.opaqueVariant();
					if (canBeSeenThroughOtherBlock(otherBlock, block, neighbor.reverse())) {
						if (otherBlock.transparent()) {
							appendNeighborFacingQuads(otherBlock, neighbor.reverse(), pos, false, &transparentSelf, main.stackAllocator);
						} else {
							appendNeighborFacingQuads(otherBlock, neighbor.reverse(), pos, false, &opaqueSelf, main.stackAllocator);
						}
					}
					if (block.hasBackFace()) {
						if (canBeSeenThroughOtherBlock(block, otherBlock, neighbor)) {
							appendNeighborFacingQuads(block, neighbor.reverse(), pos, true, &transparentSelf, main.stackAllocator);
						}
					}
				}
			}
			self.opaqueMesh.replaceRange(.neighborLod(neighbor), opaqueSelf.items);
			self.transparentMesh.replaceRange(.neighborLod(neighbor), transparentSelf.items);
		}
		self.mutex.lock();
		defer self.mutex.unlock();
		_ = self.needsLightRefresh.swap(false, .acq_rel);
		self.finishData();
		mesh_storage.finishMesh(self.pos);
	}

	fn uploadChunkPosition(self: *ChunkMesh) void {
		chunkBuffer.uploadData(&.{ChunkData{
			.position = .{self.pos.wx, self.pos.wy, self.pos.wz},
			.voxelSize = self.pos.voxelSize,
			.lightStart = self.lightAllocation.start,
			.vertexStartOpaque = self.opaqueMesh.bufferAllocation.start*4,
			.faceCountsByNormalOpaque = self.opaqueMesh.byNormalCount,
			.vertexStartTransparent = self.transparentMesh.bufferAllocation.start*4,
			.vertexCountTransparent = self.transparentMesh.bufferAllocation.len*6,
			.min = self.min,
			.max = self.max,
			.visibilityState = 0,
			.oldVisibilityState = 0,
		}}, &self.chunkAllocation);
	}

	pub fn prepareRendering(self: *ChunkMesh, chunkLists: *[main.settings.highestSupportedLod + 1]main.List(u32)) void {
		if (self.opaqueMesh.vertexCount == 0) return;

		chunkLists[std.math.log2_int(u32, self.pos.voxelSize)].append(self.chunkAllocation.start);

		quadsDrawn += self.opaqueMesh.vertexCount/6;
	}

	pub fn prepareTransparentRendering(self: *ChunkMesh, playerPosition: Vec3d, chunkLists: *[main.settings.highestSupportedLod + 1]main.List(u32)) void {
		if (self.transparentMesh.vertexCount == 0 and self.blockBreakingFaces.items.len == 0) return;

		var needsUpdate: bool = false;
		if (self.transparentMesh.wasChanged) {
			self.transparentMesh.wasChanged = false;
			self.transparentMesh.lock.lockRead();
			defer self.transparentMesh.lock.unlockRead();
			var len: usize = 0;
			const coreList = self.transparentMesh.completeList.getRange(.core);
			len += coreList.len;
			var list: [6][]FaceData = undefined;
			for (0..6) |i| {
				if (!self.isNeighborLod[i]) {
					list[i] = self.transparentMesh.completeList.getRange(.neighbor(@enumFromInt(i)));
				} else {
					list[i] = self.transparentMesh.completeList.getRange(.neighborLod(@enumFromInt(i)));
				}
				len += list[i].len;
			}
			self.currentSorting = main.globalAllocator.realloc(self.currentSorting, len);
			self.sortingOutputBuffer = main.globalAllocator.realloc(self.sortingOutputBuffer, len + self.blockBreakingFaces.items.len);
			for (0..coreList.len) |i| {
				self.currentSorting[i].face = coreList[i];
			}
			var offset = coreList.len;
			for (0..6) |n| {
				for (0..list[n].len) |i| {
					self.currentSorting[offset + i].face = list[n][i];
				}
				offset += list[n].len;
			}

			needsUpdate = true;
		}

		var relativePos = Vec3d{
			@as(f64, @floatFromInt(self.pos.wx)) - playerPosition[0],
			@as(f64, @floatFromInt(self.pos.wy)) - playerPosition[1],
			@as(f64, @floatFromInt(self.pos.wz)) - playerPosition[2],
		}/@as(Vec3d, @splat(@as(f64, @floatFromInt(self.pos.voxelSize))));
		relativePos = @min(relativePos, @as(Vec3d, @splat(0)));
		relativePos = @max(relativePos, @as(Vec3d, @splat(-32)));
		const updatePos: Vec3i = @intFromFloat(relativePos);
		if (@reduce(.Or, updatePos != self.lastTransparentUpdatePos)) {
			self.lastTransparentUpdatePos = updatePos;
			needsUpdate = true;
		}
		if (self.blockBreakingFacesChanged) {
			self.blockBreakingFacesChanged = false;
			self.sortingOutputBuffer = main.globalAllocator.realloc(self.sortingOutputBuffer, self.currentSorting.len + self.blockBreakingFaces.items.len);
			self.blockBreakingFacesSortingData = main.globalAllocator.realloc(self.blockBreakingFacesSortingData, self.blockBreakingFaces.items.len);
			for (0..self.blockBreakingFaces.items.len) |i| {
				self.blockBreakingFacesSortingData[i].face = self.blockBreakingFaces.items[i];
			}
			needsUpdate = true;
		}
		if (needsUpdate) {
			for (self.currentSorting) |*val| {
				val.update(
					updatePos[0],
					updatePos[1],
					updatePos[2],
				);
			}
			for (0..self.blockBreakingFaces.items.len) |i| {
				self.blockBreakingFacesSortingData[i].update(updatePos[0], updatePos[1], updatePos[2]);
			}

			// Sort by back vs front face:
			var backFaceStart: usize = 0;
			{
				var i: usize = 0;
				var culledStart: usize = self.currentSorting.len;
				while (culledStart > 0) {
					if (!self.currentSorting[culledStart - 1].shouldBeCulled) {
						break;
					}
					culledStart -= 1;
				}
				while (i < culledStart) : (i += 1) {
					if (self.currentSorting[i].shouldBeCulled) {
						culledStart -= 1;
						std.mem.swap(SortingData, &self.currentSorting[i], &self.currentSorting[culledStart]);
						while (culledStart > 0) {
							if (!self.currentSorting[culledStart - 1].shouldBeCulled) {
								break;
							}
							culledStart -= 1;
						}
					}
					if (!self.currentSorting[i].isBackFace) {
						std.mem.swap(SortingData, &self.currentSorting[i], &self.currentSorting[backFaceStart]);
						backFaceStart += 1;
					}
				}
				self.culledSortingCount = @intCast(culledStart);
			}

			// Sort it using bucket sort:
			var buckets: [34*3]u32 = undefined;
			@memset(&buckets, 0);
			for (self.blockBreakingFacesSortingData) |val| {
				buckets[34*3 - 1 - val.distance] += 1;
			}
			for (self.currentSorting[0..self.culledSortingCount]) |val| {
				buckets[34*3 - 1 - val.distance] += 1;
			}
			var prefixSum: u32 = 0;
			for (&buckets) |*val| {
				const copy = val.*;
				val.* = prefixSum;
				prefixSum += copy;
			}
			// Move it over into a new buffer:
			for (0..backFaceStart) |i| {
				const bucket = 34*3 - 1 - self.currentSorting[i].distance;
				self.sortingOutputBuffer[buckets[bucket]] = self.currentSorting[i].face;
				buckets[bucket] += 1;
			}
			// Block breaking faces should be drawn after front faces, but before the corresponding backfaces.
			for (self.blockBreakingFacesSortingData) |val| {
				const bucket = 34*3 - 1 - val.distance;
				self.sortingOutputBuffer[buckets[bucket]] = val.face;
				buckets[bucket] += 1;
			}
			for (backFaceStart..self.culledSortingCount) |i| {
				const bucket = 34*3 - 1 - self.currentSorting[i].distance;
				self.sortingOutputBuffer[buckets[bucket]] = self.currentSorting[i].face;
				buckets[bucket] += 1;
			}
			self.culledSortingCount += @intCast(self.blockBreakingFaces.items.len);
			// Upload:
			faceBuffers[self.transparentMesh.lod].uploadData(self.sortingOutputBuffer[0..self.culledSortingCount], &self.transparentMesh.bufferAllocation);
			self.uploadChunkPosition();
		}

		chunkLists[std.math.log2_int(u32, self.pos.voxelSize)].append(self.chunkAllocation.start);
		transparentQuadsDrawn += self.culledSortingCount;
	}
};

```

`src/renderer/lighting.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const blocks = main.blocks;
const chunk = main.chunk;
const BlockPos = chunk.BlockPos;
const chunk_meshing = @import("chunk_meshing.zig");
const mesh_storage = @import("mesh_storage.zig");

var memoryPool: main.heap.MemoryPool(ChannelChunk) = undefined;

pub fn init() void {
	memoryPool = .init(main.globalAllocator);
}

pub fn deinit() void {
	memoryPool.deinit();
}

pub const LightValue = packed struct(u32) {
	r: u8,
	g: u8,
	b: u8,
	pad: u8 = undefined,

	fn fromArray(arr: [3]u8) LightValue {
		return .{.r = arr[0], .g = arr[1], .b = arr[2]};
	}

	pub fn toArray(self: LightValue) [3]u8 {
		return .{self.r, self.g, self.b};
	}

	pub fn raw(self: LightValue) u32 {
		return @bitCast(self);
	}
};

fn extractColor(in: u32) [3]u8 {
	return .{
		@truncate(in >> 16),
		@truncate(in >> 8),
		@truncate(in),
	};
}

pub const ChannelChunk = struct {
	data: main.utils.PaletteCompressedRegion(LightValue, chunk.chunkVolume),
	mutex: std.Thread.Mutex,
	ch: *chunk.Chunk,
	isSun: bool,

	pub fn init(ch: *chunk.Chunk, isSun: bool) *ChannelChunk {
		const self = memoryPool.create();
		self.mutex = .{};
		self.ch = ch;
		self.isSun = isSun;
		self.data.init();
		return self;
	}

	pub fn deinit(self: *ChannelChunk) void {
		self.data.deferredDeinit();
		memoryPool.destroy(self);
	}

	const Entry = struct {
		pos: BlockPos,
		value: [3]u8,
		sourceDir: u3,
		activeValue: u3,
	};

	const ChunkEntries = struct {
		mesh: ?*chunk_meshing.ChunkMesh,
		entries: main.ListUnmanaged(BlockPos),
	};

	pub fn getValue(self: *ChannelChunk, pos: BlockPos) LightValue {
		return self.data.getValue(pos.toIndex());
	}

	fn calculateIncomingOcclusion(result: *[3]u8, block: blocks.Block, voxelSize: u31, neighbor: chunk.Neighbor) void {
		if (block.typ == 0) return;
		if (blocks.meshes.model(block).model().isNeighborOccluded[neighbor.toInt()]) {
			var absorption: [3]u8 = extractColor(block.absorption());
			absorption[0] *|= @intCast(voxelSize);
			absorption[1] *|= @intCast(voxelSize);
			absorption[2] *|= @intCast(voxelSize);
			result[0] -|= absorption[0];
			result[1] -|= absorption[1];
			result[2] -|= absorption[2];
		}
	}

	fn calculateOutgoingOcclusion(result: *[3]u8, block: blocks.Block, voxelSize: u31, neighbor: chunk.Neighbor) void {
		if (block.typ == 0) return;
		const model = blocks.meshes.model(block).model();
		if (model.isNeighborOccluded[neighbor.toInt()] and !model.isNeighborOccluded[neighbor.reverse().toInt()]) { // Avoid calculating the absorption twice.
			var absorption: [3]u8 = extractColor(block.absorption());
			absorption[0] *|= @intCast(voxelSize);
			absorption[1] *|= @intCast(voxelSize);
			absorption[2] *|= @intCast(voxelSize);
			result[0] -|= absorption[0];
			result[1] -|= absorption[1];
			result[2] -|= absorption[2];
		}
	}

	fn propagateDirect(self: *ChannelChunk, lightQueue: *main.utils.CircularBufferQueue(Entry), lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		var neighborLists: [6]main.ListUnmanaged(Entry) = @splat(.{});
		defer {
			for (&neighborLists) |*list| {
				list.deinit(main.stackAllocator);
			}
		}

		self.mutex.lock();
		while (lightQueue.popFront()) |entry| {
			const pos = entry.pos;
			const oldValue: [3]u8 = self.data.getValue(pos.toIndex()).toArray();
			const newValue: [3]u8 = .{
				@max(entry.value[0], oldValue[0]),
				@max(entry.value[1], oldValue[1]),
				@max(entry.value[2], oldValue[2]),
			};
			if (newValue[0] == oldValue[0] and newValue[1] == oldValue[1] and newValue[2] == oldValue[2]) continue;
			self.data.setValue(pos.toIndex(), .fromArray(newValue));
			for (chunk.Neighbor.iterable) |neighbor| {
				if (neighbor.toInt() == entry.sourceDir) continue;
				const neighborPos, const chunkLocation = pos.neighbor(neighbor);
				var result: Entry = .{.pos = neighborPos, .value = newValue, .sourceDir = neighbor.reverse().toInt(), .activeValue = 0b111};
				if (!self.isSun or neighbor != .dirDown or result.value[0] != 255 or result.value[1] != 255 or result.value[2] != 255) {
					result.value[0] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
					result.value[1] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
					result.value[2] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
				}
				calculateOutgoingOcclusion(&result.value, self.ch.data.getValue(pos.toIndex()), self.ch.pos.voxelSize, neighbor);
				if (result.value[0] == 0 and result.value[1] == 0 and result.value[2] == 0) continue;
				if (chunkLocation == .inNeighborChunk) {
					neighborLists[neighbor.toInt()].append(main.stackAllocator, result);
					continue;
				}
				calculateIncomingOcclusion(&result.value, self.ch.data.getValue(neighborPos.toIndex()), self.ch.pos.voxelSize, neighbor.reverse());
				if (result.value[0] != 0 or result.value[1] != 0 or result.value[2] != 0) lightQueue.pushBack(result);
			}
		}
		self.data.optimizeLayout();
		self.mutex.unlock();
		self.addSelfToLightRefreshList(lightRefreshList);

		for (chunk.Neighbor.iterable) |neighbor| {
			if (neighborLists[neighbor.toInt()].items.len == 0) continue;
			const neighborMesh = mesh_storage.getNeighbor(self.ch.pos, self.ch.pos.voxelSize, neighbor) orelse continue;
			neighborMesh.lightingData[@intFromBool(self.isSun)].propagateFromNeighbor(lightQueue, neighborLists[neighbor.toInt()].items, lightRefreshList);
		}
	}

	fn addSelfToLightRefreshList(self: *ChannelChunk, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		for (lightRefreshList.items) |other| {
			if (self.ch.pos.equals(other)) {
				return;
			}
		}
		if (mesh_storage.getMesh(self.ch.pos)) |mesh| {
			mesh.needsLightRefresh.store(true, .release);
			lightRefreshList.append(self.ch.pos);
		}
	}

	fn propagateDestructive(self: *ChannelChunk, lightQueue: *main.utils.CircularBufferQueue(Entry), constructiveEntries: *main.ListUnmanaged(ChunkEntries), isFirstBlock: bool, lightRefreshList: *main.List(chunk.ChunkPosition)) main.ListUnmanaged(BlockPos) {
		var neighborLists: [6]main.ListUnmanaged(Entry) = @splat(.{});
		var constructiveList: main.ListUnmanaged(BlockPos) = .{};
		defer {
			for (&neighborLists) |*list| {
				list.deinit(main.stackAllocator);
			}
		}
		var isFirstIteration: bool = isFirstBlock;

		self.mutex.lock();
		while (lightQueue.popFront()) |entry| {
			const pos: BlockPos = entry.pos;
			const oldValue: [3]u8 = self.data.getValue(pos.toIndex()).toArray();
			var activeValue: @Vector(3, bool) = @bitCast(entry.activeValue);
			var append: bool = false;
			if (activeValue[0] and entry.value[0] != oldValue[0]) {
				if (oldValue[0] != 0) append = true;
				activeValue[0] = false;
			}
			if (activeValue[1] and entry.value[1] != oldValue[1]) {
				if (oldValue[1] != 0) append = true;
				activeValue[1] = false;
			}
			if (activeValue[2] and entry.value[2] != oldValue[2]) {
				if (oldValue[2] != 0) append = true;
				activeValue[2] = false;
			}
			const blockLight = if (self.isSun) .{0, 0, 0} else extractColor(self.ch.data.getValue(pos.toIndex()).light());
			if ((activeValue[0] and blockLight[0] != 0) or (activeValue[1] and blockLight[1] != 0) or (activeValue[2] and blockLight[2] != 0)) {
				append = true;
			}
			if (append) {
				constructiveList.append(main.stackAllocator, pos);
			}
			if (entry.value[0] == 0) activeValue[0] = false;
			if (entry.value[1] == 0) activeValue[1] = false;
			if (entry.value[2] == 0) activeValue[2] = false;
			if (isFirstIteration) activeValue = .{true, true, true};
			if (!@reduce(.Or, activeValue)) {
				continue;
			}
			isFirstIteration = false;
			var insertValue: [3]u8 = oldValue;
			if (activeValue[0]) insertValue[0] = 0;
			if (activeValue[1]) insertValue[1] = 0;
			if (activeValue[2]) insertValue[2] = 0;
			self.data.setValue(pos.toIndex(), .fromArray(insertValue));
			for (chunk.Neighbor.iterable) |neighbor| {
				if (neighbor.toInt() == entry.sourceDir) continue;
				const neighborPos, const chunkLocation = pos.neighbor(neighbor);
				var result: Entry = .{.pos = neighborPos, .value = entry.value, .sourceDir = neighbor.reverse().toInt(), .activeValue = @bitCast(activeValue)};
				if (!self.isSun or neighbor != .dirDown or result.value[0] != 255 or result.value[1] != 255 or result.value[2] != 255) {
					result.value[0] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
					result.value[1] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
					result.value[2] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
				}
				calculateOutgoingOcclusion(&result.value, self.ch.data.getValue(pos.toIndex()), self.ch.pos.voxelSize, neighbor);
				if (chunkLocation == .inNeighborChunk) {
					neighborLists[neighbor.toInt()].append(main.stackAllocator, result);
					continue;
				}
				calculateIncomingOcclusion(&result.value, self.ch.data.getValue(neighborPos.toIndex()), self.ch.pos.voxelSize, neighbor.reverse());
				lightQueue.pushBack(result);
			}
		}
		self.mutex.unlock();
		self.addSelfToLightRefreshList(lightRefreshList);

		for (chunk.Neighbor.iterable) |neighbor| {
			if (neighborLists[neighbor.toInt()].items.len == 0) continue;
			const neighborMesh = mesh_storage.getNeighbor(self.ch.pos, self.ch.pos.voxelSize, neighbor) orelse continue;
			constructiveEntries.append(main.stackAllocator, .{
				.mesh = neighborMesh,
				.entries = neighborMesh.lightingData[@intFromBool(self.isSun)].propagateDestructiveFromNeighbor(lightQueue, neighborLists[neighbor.toInt()].items, constructiveEntries, lightRefreshList),
			});
		}

		return constructiveList;
	}

	fn propagateFromNeighbor(self: *ChannelChunk, lightQueue: *main.utils.CircularBufferQueue(Entry), lights: []const Entry, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		std.debug.assert(lightQueue.isEmpty());
		for (lights) |entry| {
			var result = entry;
			calculateIncomingOcclusion(&result.value, self.ch.data.getValue(entry.pos.toIndex()), self.ch.pos.voxelSize, @enumFromInt(entry.sourceDir));
			if (result.value[0] != 0 or result.value[1] != 0 or result.value[2] != 0) lightQueue.pushBack(result);
		}
		self.propagateDirect(lightQueue, lightRefreshList);
	}

	fn propagateDestructiveFromNeighbor(self: *ChannelChunk, lightQueue: *main.utils.CircularBufferQueue(Entry), lights: []const Entry, constructiveEntries: *main.ListUnmanaged(ChunkEntries), lightRefreshList: *main.List(chunk.ChunkPosition)) main.ListUnmanaged(BlockPos) {
		std.debug.assert(lightQueue.isEmpty());
		for (lights) |entry| {
			var result = entry;
			calculateIncomingOcclusion(&result.value, self.ch.data.getValue(entry.pos.toIndex()), self.ch.pos.voxelSize, @enumFromInt(entry.sourceDir));
			lightQueue.pushBack(result);
		}
		return self.propagateDestructive(lightQueue, constructiveEntries, false, lightRefreshList);
	}

	pub fn propagateLights(self: *ChannelChunk, lights: []const BlockPos, comptime checkNeighbors: bool, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		var lightQueue = main.utils.CircularBufferQueue(Entry).init(main.stackAllocator, 1 << 12);
		defer lightQueue.deinit();
		for (lights) |pos| {
			if (self.isSun) {
				lightQueue.pushBack(.{.pos = pos, .value = .{255, 255, 255}, .sourceDir = 6, .activeValue = 0b111});
			} else {
				lightQueue.pushBack(.{.pos = pos, .value = extractColor(self.ch.data.getValue(pos.toIndex()).light()), .sourceDir = 6, .activeValue = 0b111});
			}
		}
		if (checkNeighbors) {
			for (chunk.Neighbor.iterable) |neighbor| {
				const x3: i32 = if (neighbor.isPositive()) chunk.chunkMask else 0;
				var x1: i32 = 0;
				while (x1 < chunk.chunkSize) : (x1 += 1) {
					var x2: i32 = 0;
					while (x2 < chunk.chunkSize) : (x2 += 1) {
						var x: i32 = undefined;
						var y: i32 = undefined;
						var z: i32 = undefined;
						if (neighbor.relX() != 0) {
							x = x3;
							y = x1;
							z = x2;
						} else if (neighbor.relY() != 0) {
							x = x1;
							y = x3;
							z = x2;
						} else {
							x = x2;
							y = x1;
							z = x3;
						}
						const neighborMesh = mesh_storage.getNeighbor(self.ch.pos, self.ch.pos.voxelSize, neighbor) orelse continue;
						const neighborLightChunk = neighborMesh.lightingData[@intFromBool(self.isSun)];
						const pos: BlockPos = .fromCoords(@intCast(x), @intCast(y), @intCast(z));
						const neighborPos, _ = pos.neighbor(neighbor);
						var value: [3]u8 = neighborLightChunk.data.getValue(neighborPos.toIndex()).toArray();
						if (!self.isSun or neighbor != .dirUp or value[0] != 255 or value[1] != 255 or value[2] != 255) {
							value[0] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
							value[1] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
							value[2] -|= 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
						}
						calculateOutgoingOcclusion(&value, self.ch.data.getValue(neighborPos.toIndex()), self.ch.pos.voxelSize, neighbor);
						if (value[0] == 0 and value[1] == 0 and value[2] == 0) continue;
						calculateIncomingOcclusion(&value, self.ch.data.getValue(pos.toIndex()), self.ch.pos.voxelSize, neighbor.reverse());
						if (value[0] != 0 or value[1] != 0 or value[2] != 0) lightQueue.pushBack(.{.pos = pos, .value = value, .sourceDir = neighbor.toInt(), .activeValue = 0b111});
					}
				}
			}
		}
		self.propagateDirect(&lightQueue, lightRefreshList);
	}

	pub fn propagateUniformSun(self: *ChannelChunk, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		std.debug.assert(self.isSun);
		self.mutex.lock();
		self.data.fillUniform(.fromArray(.{255, 255, 255}));
		self.mutex.unlock();
		const val = 255 -| 8*|@as(u8, @intCast(self.ch.pos.voxelSize));
		var lightQueue = main.utils.CircularBufferQueue(Entry).init(main.stackAllocator, 1 << 12);
		defer lightQueue.deinit();
		for (chunk.Neighbor.iterable) |neighbor| {
			if (neighbor == .dirUp) continue;
			const neighborMesh = mesh_storage.getNeighbor(self.ch.pos, self.ch.pos.voxelSize, neighbor) orelse continue;
			var list: [chunk.chunkSize*chunk.chunkSize]Entry = undefined;
			for (0..chunk.chunkSize) |x| {
				for (0..chunk.chunkSize) |y| {
					const entry = &list[x*chunk.chunkSize + y];
					entry.pos, _ = entry.pos.neighbor(neighbor);
					switch (neighbor.vectorComponent()) {
						.x => {
							entry.pos = .{
								.x = if (neighbor.isPositive()) 0 else chunk.chunkSize - 1,
								.y = @intCast(x),
								.z = @intCast(y),
							};
							entry.value = .{val, val, val};
						},
						.y => {
							entry.pos = .{
								.y = if (neighbor.isPositive()) 0 else chunk.chunkSize - 1,
								.x = @intCast(x),
								.z = @intCast(y),
							};
							entry.value = .{val, val, val};
						},
						.z => {
							entry.pos = .{
								.z = if (neighbor.isPositive()) 0 else chunk.chunkSize - 1,
								.x = @intCast(x),
								.y = @intCast(y),
							};
							entry.value = .{255, 255, 255};
						},
					}
					entry.activeValue = 0b111;
					entry.sourceDir = neighbor.reverse().toInt();
				}
			}
			neighborMesh.lightingData[1].propagateFromNeighbor(&lightQueue, &list, lightRefreshList);
		}
	}

	pub fn propagateLightsDestructive(self: *ChannelChunk, lights: []const BlockPos, lightRefreshList: *main.List(chunk.ChunkPosition)) void {
		var lightQueue = main.utils.CircularBufferQueue(Entry).init(main.stackAllocator, 1 << 12);
		defer lightQueue.deinit();
		for (lights) |pos| {
			lightQueue.pushBack(.{.pos = pos, .value = self.data.getValue(pos.toIndex()).toArray(), .sourceDir = 6, .activeValue = 0b111});
		}
		var constructiveEntries: main.ListUnmanaged(ChunkEntries) = .{};
		defer constructiveEntries.deinit(main.stackAllocator);
		constructiveEntries.append(main.stackAllocator, .{
			.mesh = null,
			.entries = self.propagateDestructive(&lightQueue, &constructiveEntries, true, lightRefreshList),
		});
		for (constructiveEntries.items) |entries| {
			const mesh = entries.mesh;
			var entryList = entries.entries;
			defer entryList.deinit(main.stackAllocator);
			const channelChunk = if (mesh) |_mesh| _mesh.lightingData[@intFromBool(self.isSun)] else self;
			channelChunk.mutex.lock();
			for (entryList.items) |entry| {
				var value = channelChunk.data.getValue(entry.toIndex()).toArray();
				const light = if (self.isSun) .{0, 0, 0} else extractColor(channelChunk.ch.data.getValue(entry.toIndex()).light());
				value = .{
					@max(value[0], light[0]),
					@max(value[1], light[1]),
					@max(value[2], light[2]),
				};
				if (value[0] == 0 and value[1] == 0 and value[2] == 0) continue;
				channelChunk.data.setValue(entry.toIndex(), .fromArray(.{0, 0, 0}));
				lightQueue.pushBack(.{.pos = entry, .value = value, .sourceDir = 6, .activeValue = 0b111});
			}
			channelChunk.mutex.unlock();
			channelChunk.propagateDirect(&lightQueue, lightRefreshList);
		}
	}
};

```

`src/renderer/mesh_storage.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const blocks = main.blocks;
const chunk = main.chunk;
const game = main.game;
const network = main.network;
const settings = main.settings;
const utils = main.utils;
const LightMap = main.server.terrain.LightMap;
const vec = main.vec;
const Vec2f = vec.Vec2f;
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;
const Vec3d = vec.Vec3d;
const Vec4f = vec.Vec4f;
const Mat4f = vec.Mat4f;
const EventStatus = main.block_entity.EventStatus;

const chunk_meshing = @import("chunk_meshing.zig");
const ChunkMesh = chunk_meshing.ChunkMesh;

const ChunkMeshNode = struct {
	mesh: Atomic(?*chunk_meshing.ChunkMesh) = .init(null),
	active: bool = false,
	rendered: bool = false,
	finishedMeshing: bool = false, // Must be synced with mesh.finishedMeshing
	finishedMeshingHigherResolution: u8 = 0, // Must be synced with finishedMeshing of the 8 higher resolution chunks.
	pos: chunk.ChunkPosition = undefined,
	isNeighborLod: [6]bool = @splat(false), // Must be synced with mesh.isNeighborLod
};
const storageSize = 64;
const storageMask = storageSize - 1;
var storageLists: [settings.highestSupportedLod + 1]*[storageSize*storageSize*storageSize]ChunkMeshNode = undefined;
var mapStorageLists: [settings.highestSupportedLod + 1]*[storageSize*storageSize]Atomic(?*LightMap.LightMapFragment) = undefined;
var meshList = main.List(*chunk_meshing.ChunkMesh).init(main.globalAllocator);
var priorityMeshUpdateList: main.utils.ConcurrentQueue(chunk.ChunkPosition) = undefined;
pub var updatableList = main.List(chunk.ChunkPosition).init(main.globalAllocator);
var mapUpdatableList: main.utils.ConcurrentQueue(*LightMap.LightMapFragment) = undefined;
var lastPx: i32 = 0;
var lastPy: i32 = 0;
var lastPz: i32 = 0;
var lastRD: u16 = 0;
var mutex: std.Thread.Mutex = .{};

pub const BlockUpdate = struct {
	x: i32,
	y: i32,
	z: i32,
	newBlock: blocks.Block,
	blockEntityData: []const u8,

	pub fn init(pos: Vec3i, block: blocks.Block, blockEntityData: []const u8) BlockUpdate {
		return .{.x = pos[0], .y = pos[1], .z = pos[2], .newBlock = block, .blockEntityData = blockEntityData};
	}

	pub fn initManaged(allocator: main.heap.NeverFailingAllocator, template: BlockUpdate) BlockUpdate {
		return .{
			.x = template.x,
			.y = template.y,
			.z = template.z,
			.newBlock = template.newBlock,
			.blockEntityData = allocator.dupe(u8, template.blockEntityData),
		};
	}

	pub fn deinitManaged(self: BlockUpdate, allocator: main.heap.NeverFailingAllocator) void {
		allocator.free(self.blockEntityData);
	}
};

var blockUpdateList: main.utils.ConcurrentQueue(BlockUpdate) = undefined;

pub var meshMemoryPool: main.heap.MemoryPool(chunk_meshing.ChunkMesh) = undefined;

pub fn init() void { // MARK: init()
	lastRD = 0;
	blockUpdateList = .init(main.globalAllocator, 16);
	meshMemoryPool = .init(main.globalAllocator);
	for (&storageLists) |*storageList| {
		storageList.* = main.globalAllocator.create([storageSize*storageSize*storageSize]ChunkMeshNode);
		for (storageList.*) |*val| {
			val.* = .{};
		}
	}
	for (&mapStorageLists) |*mapStorageList| {
		mapStorageList.* = main.globalAllocator.create([storageSize*storageSize]Atomic(?*LightMap.LightMapFragment));
		@memset(mapStorageList.*, .init(null));
	}
	priorityMeshUpdateList = .init(main.globalAllocator, 16);
	mapUpdatableList = .init(main.globalAllocator, 16);
}

pub fn deinit() void {
	const olderPx = lastPx;
	const olderPy = lastPy;
	const olderPz = lastPz;
	const olderRD = lastRD;
	lastPx = 0;
	lastPy = 0;
	lastPz = 0;
	lastRD = 0;
	freeOldMeshes(olderPx, olderPy, olderPz, olderRD);
	for (storageLists) |storageList| {
		main.globalAllocator.destroy(storageList);
	}
	for (mapStorageLists) |mapStorageList| {
		main.globalAllocator.destroy(mapStorageList);
	}

	updatableList.clearAndFree();
	while (mapUpdatableList.popFront()) |map| {
		map.deferredDeinit();
	}
	mapUpdatableList.deinit();
	priorityMeshUpdateList.deinit();
	while (blockUpdateList.popFront()) |blockUpdate| {
		blockUpdate.deinitManaged(main.globalAllocator);
	}
	blockUpdateList.deinit();
	meshList.clearAndFree();
	main.heap.GarbageCollection.waitForFreeCompletion();
	meshMemoryPool.deinit();
}

// MARK: getters

fn getNodePointer(pos: chunk.ChunkPosition) *ChunkMeshNode {
	const lod = std.math.log2_int(u31, pos.voxelSize);
	var xIndex = pos.wx >> lod + chunk.chunkShift;
	var yIndex = pos.wy >> lod + chunk.chunkShift;
	var zIndex = pos.wz >> lod + chunk.chunkShift;
	xIndex &= storageMask;
	yIndex &= storageMask;
	zIndex &= storageMask;
	const index = (xIndex*storageSize + yIndex)*storageSize + zIndex;
	return &storageLists[lod][@intCast(index)];
}

fn finishedMeshingMask(x: bool, y: bool, z: bool) u8 {
	return @as(u8, 1) << (@as(u3, @intFromBool(x))*4 + @as(u3, @intFromBool(y))*2 + @as(u3, @intFromBool(z)));
}

fn updateHigherLodNodeFinishedMeshing(pos_: chunk.ChunkPosition, finishedMeshing: bool) void {
	const lod = std.math.log2_int(u31, pos_.voxelSize);
	if (lod == settings.highestLod) return;
	var pos = pos_;
	pos.wx &= ~@as(i32, pos.voxelSize*chunk.chunkSize);
	pos.wy &= ~@as(i32, pos.voxelSize*chunk.chunkSize);
	pos.wz &= ~@as(i32, pos.voxelSize*chunk.chunkSize);
	pos.voxelSize *= 2;
	const mask = finishedMeshingMask(pos.wx != pos_.wx, pos.wy != pos_.wy, pos.wz != pos_.wz);
	const node = getNodePointer(pos);
	if (finishedMeshing) {
		node.finishedMeshingHigherResolution |= mask;
	} else {
		node.finishedMeshingHigherResolution &= ~mask;
	}
}

fn getMapPiecePointer(x: i32, y: i32, voxelSize: u31) *Atomic(?*LightMap.LightMapFragment) {
	const lod = std.math.log2_int(u31, voxelSize);
	var xIndex = x >> lod + LightMap.LightMapFragment.mapShift;
	var yIndex = y >> lod + LightMap.LightMapFragment.mapShift;
	xIndex &= storageMask;
	yIndex &= storageMask;
	const index = xIndex*storageSize + yIndex;
	return &mapStorageLists[lod][@intCast(index)];
}

pub fn getLightMapPiece(x: i32, y: i32, voxelSize: u31) ?*LightMap.LightMapFragment {
	return getMapPiecePointer(x, y, voxelSize).load(.acquire);
}

pub fn getBlockFromRenderThread(x: i32, y: i32, z: i32) ?blocks.Block {
	const node = getNodePointer(.{.wx = x, .wy = y, .wz = z, .voxelSize = 1});
	const mesh = node.mesh.load(.acquire) orelse return null;
	const block = mesh.chunk.getBlock(x & chunk.chunkMask, y & chunk.chunkMask, z & chunk.chunkMask);
	return block;
}

pub fn triggerOnInteractBlockFromRenderThread(x: i32, y: i32, z: i32) main.callbacks.Result {
	const node = getNodePointer(.{.wx = x, .wy = y, .wz = z, .voxelSize = 1});
	const mesh = node.mesh.load(.acquire) orelse return .ignored;
	const block = mesh.chunk.getBlock(x & chunk.chunkMask, y & chunk.chunkMask, z & chunk.chunkMask);
	if (block.blockEntity()) |blockEntity| {
		return blockEntity.onInteract(.{x, y, z}, mesh.chunk);
	}
	// Event was not handled.
	return .ignored;
}

pub fn getLight(wx: i32, wy: i32, wz: i32) ?[6]u8 {
	const node = getNodePointer(.{.wx = wx, .wy = wy, .wz = wz, .voxelSize = 1});
	const mesh = node.mesh.load(.acquire) orelse return null;
	const pos: chunk.BlockPos = .fromWorldCoords(wx, wy, wz);
	return mesh.lightingData[1].getValue(pos).toArray() ++ mesh.lightingData[0].getValue(pos).toArray();
}

pub fn getBlockFromAnyLodFromRenderThread(x: i32, y: i32, z: i32) blocks.Block {
	var lod: u5 = 0;
	while (lod <= settings.highestLod) : (lod += 1) {
		const node = getNodePointer(.{.wx = x, .wy = y, .wz = z, .voxelSize = @as(u31, 1) << lod});
		const mesh = node.mesh.load(.acquire) orelse continue;
		const block = mesh.chunk.getBlock(x & chunk.chunkMask << lod, y & chunk.chunkMask << lod, z & chunk.chunkMask << lod);
		return block;
	}
	return blocks.Block{.typ = 0, .data = 0};
}

pub fn getMesh(pos: chunk.ChunkPosition) ?*chunk_meshing.ChunkMesh {
	const lod = std.math.log2_int(u31, pos.voxelSize);
	const mask = ~((@as(i32, 1) << lod + chunk.chunkShift) - 1);
	const node = getNodePointer(pos);
	const mesh = node.mesh.load(.acquire) orelse return null;
	if (pos.wx & mask != mesh.pos.wx or pos.wy & mask != mesh.pos.wy or pos.wz & mask != mesh.pos.wz) {
		return null;
	}
	return mesh;
}

pub fn getMeshFromAnyLod(wx: i32, wy: i32, wz: i32, voxelSize: u31) ?*chunk_meshing.ChunkMesh {
	var lod: u5 = @ctz(voxelSize);
	while (lod < settings.highestLod) : (lod += 1) {
		const mesh = getMesh(.{.wx = wx & ~chunk.chunkMask << lod, .wy = wy & ~chunk.chunkMask << lod, .wz = wz & ~chunk.chunkMask << lod, .voxelSize = @as(u31, 1) << lod});
		return mesh orelse continue;
	}
	return null;
}

pub fn getNeighbor(_pos: chunk.ChunkPosition, resolution: u31, neighbor: chunk.Neighbor) ?*chunk_meshing.ChunkMesh {
	var pos = _pos;
	pos.wx +%= pos.voxelSize*chunk.chunkSize*neighbor.relX();
	pos.wy +%= pos.voxelSize*chunk.chunkSize*neighbor.relY();
	pos.wz +%= pos.voxelSize*chunk.chunkSize*neighbor.relZ();
	pos.voxelSize = resolution;
	return getMesh(pos);
}

fn reduceRenderDistance(fullRenderDistance: i64, reduction: i64) i32 {
	const reducedRenderDistanceSquare: f64 = @floatFromInt(fullRenderDistance*fullRenderDistance - reduction*reduction);
	const reducedRenderDistance: i32 = @intFromFloat(@ceil(@sqrt(@max(0, reducedRenderDistanceSquare))));
	return reducedRenderDistance;
}

fn isInRenderDistance(pos: chunk.ChunkPosition) bool { // MARK: isInRenderDistance()
	const maxRenderDistance = lastRD*chunk.chunkSize*pos.voxelSize;
	const size: u31 = chunk.chunkSize*pos.voxelSize;
	const mask: i32 = size - 1;
	const invMask: i32 = ~mask;

	const minX = lastPx -% maxRenderDistance & invMask;
	const maxX = lastPx +% maxRenderDistance +% size & invMask;
	if (pos.wx -% minX < 0) return false;
	if (pos.wx -% maxX >= 0) return false;
	var deltaX: i64 = @abs(pos.wx +% size/2 -% lastPx);
	deltaX = @max(0, deltaX - size/2);

	const maxYRenderDistance: i32 = reduceRenderDistance(maxRenderDistance, deltaX);
	const minY = lastPy -% maxYRenderDistance & invMask;
	const maxY = lastPy +% maxYRenderDistance +% size & invMask;
	if (pos.wy -% minY < 0) return false;
	if (pos.wy -% maxY >= 0) return false;
	var deltaY: i64 = @abs(pos.wy +% size/2 -% lastPy);
	deltaY = @max(0, deltaY - size/2);

	const maxZRenderDistance: i32 = reduceRenderDistance(maxYRenderDistance, deltaY);
	if (maxZRenderDistance == 0) return false;
	const minZ = lastPz -% maxZRenderDistance & invMask;
	const maxZ = lastPz +% maxZRenderDistance +% size & invMask;
	if (pos.wz -% minZ < 0) return false;
	if (pos.wz -% maxZ >= 0) return false;
	return true;
}

fn isMapInRenderDistance(pos: LightMap.MapFragmentPosition) bool {
	const maxRenderDistance = lastRD*chunk.chunkSize*pos.voxelSize;
	const size: u31 = @as(u31, LightMap.LightMapFragment.mapSize)*pos.voxelSize;
	const mask: i32 = size - 1;
	const invMask: i32 = ~mask;

	const minX = lastPx -% maxRenderDistance & invMask;
	const maxX = lastPx +% maxRenderDistance +% size & invMask;
	if (pos.wx -% minX < 0) return false;
	if (pos.wx -% maxX >= 0) return false;
	var deltaX: i64 = @abs(pos.wx +% size/2 -% lastPx);
	deltaX = @max(0, deltaX - size/2);

	const maxYRenderDistance: i32 = reduceRenderDistance(maxRenderDistance, deltaX);
	if (maxYRenderDistance == 0) return false;
	const minY = lastPy -% maxYRenderDistance & invMask;
	const maxY = lastPy +% maxYRenderDistance +% size & invMask;
	if (pos.wy -% minY < 0) return false;
	if (pos.wy -% maxY >= 0) return false;
	return true;
}

fn freeOldMeshes(olderPx: i32, olderPy: i32, olderPz: i32, olderRD: u16) void { // MARK: freeOldMeshes()
	for (0..settings.highestLod + 1) |_lod| {
		const lod: u5 = @intCast(_lod);
		const maxRenderDistanceNew = lastRD*chunk.chunkSize << lod;
		const maxRenderDistanceOld = olderRD*chunk.chunkSize << lod;
		const size: u31 = chunk.chunkSize << lod;
		const mask: i32 = size - 1;
		const invMask: i32 = ~mask;

		std.debug.assert(@divFloor(2*maxRenderDistanceNew + size - 1, size) + 2 <= storageSize);

		const minX = olderPx -% maxRenderDistanceOld & invMask;
		const maxX = olderPx +% maxRenderDistanceOld +% size & invMask;
		var x = minX;
		while (x != maxX) : (x +%= size) {
			const xIndex = @divExact(x, size) & storageMask;
			var deltaXNew: i64 = @abs(x +% size/2 -% lastPx);
			deltaXNew = @max(0, deltaXNew - size/2);
			var deltaXOld: i64 = @abs(x +% size/2 -% olderPx);
			deltaXOld = @max(0, deltaXOld - size/2);
			const maxYRenderDistanceNew: i32 = reduceRenderDistance(maxRenderDistanceNew, deltaXNew);
			const maxYRenderDistanceOld: i32 = reduceRenderDistance(maxRenderDistanceOld, deltaXOld);

			const minY = olderPy -% maxYRenderDistanceOld & invMask;
			const maxY = olderPy +% maxYRenderDistanceOld +% size & invMask;
			var y = minY;
			while (y != maxY) : (y +%= size) {
				const yIndex = @divExact(y, size) & storageMask;
				var deltaYOld: i64 = @abs(y +% size/2 -% olderPy);
				deltaYOld = @max(0, deltaYOld - size/2);
				var deltaYNew: i64 = @abs(y +% size/2 -% lastPy);
				deltaYNew = @max(0, deltaYNew - size/2);
				var maxZRenderDistanceOld: i32 = reduceRenderDistance(maxYRenderDistanceOld, deltaYOld);
				if (maxZRenderDistanceOld == 0) maxZRenderDistanceOld -= size/2;
				var maxZRenderDistanceNew: i32 = reduceRenderDistance(maxYRenderDistanceNew, deltaYNew);
				if (maxZRenderDistanceNew == 0) maxZRenderDistanceNew -= size/2;

				const minZOld = olderPz -% maxZRenderDistanceOld & invMask;
				const maxZOld = olderPz +% maxZRenderDistanceOld +% size & invMask;
				const minZNew = lastPz -% maxZRenderDistanceNew & invMask;
				const maxZNew = lastPz +% maxZRenderDistanceNew +% size & invMask;

				var zValues: [storageSize]i32 = undefined;
				var zValuesLen: usize = 0;
				if (minZNew -% minZOld > 0) {
					var z = minZOld;
					while (z != minZNew and z != maxZOld) : (z +%= size) {
						zValues[zValuesLen] = z;
						zValuesLen += 1;
					}
				}
				if (maxZOld -% maxZNew > 0) {
					var z = minZOld +% @max(0, maxZNew -% minZOld);
					while (z != maxZOld) : (z +%= size) {
						zValues[zValuesLen] = z;
						zValuesLen += 1;
					}
				}

				for (zValues[0..zValuesLen]) |z| {
					const zIndex = @divExact(z, size) & storageMask;
					const index = (xIndex*storageSize + yIndex)*storageSize + zIndex;

					const node = &storageLists[_lod][@intCast(index)];
					const oldMesh = node.mesh.swap(null, .monotonic);
					node.pos = undefined;
					if (oldMesh) |mesh| {
						node.finishedMeshing = false;
						updateHigherLodNodeFinishedMeshing(mesh.pos, false);
						mesh.deferredDeinit();
					}
					node.isNeighborLod = @splat(false);
				}
			}
		}
	}
	for (0..settings.highestLod + 1) |_lod| {
		const lod: u5 = @intCast(_lod);
		const maxRenderDistanceNew = lastRD*chunk.chunkSize << lod;
		const maxRenderDistanceOld = olderRD*chunk.chunkSize << lod;
		const size: u31 = @as(u31, LightMap.LightMapFragment.mapSize) << lod;
		const mask: i32 = size - 1;
		const invMask: i32 = ~mask;

		std.debug.assert(@divFloor(2*maxRenderDistanceNew + size - 1, size) + 2 <= storageSize);

		const minX = olderPx -% maxRenderDistanceOld & invMask;
		const maxX = olderPx +% maxRenderDistanceOld +% size & invMask;
		var x = minX;
		while (x != maxX) : (x +%= size) {
			const xIndex = @divExact(x, size) & storageMask;
			var deltaXNew: i64 = @abs(x +% size/2 -% lastPx);
			deltaXNew = @max(0, deltaXNew - size/2);
			var deltaXOld: i64 = @abs(x +% size/2 -% olderPx);
			deltaXOld = @max(0, deltaXOld - size/2);
			var maxYRenderDistanceNew: i32 = reduceRenderDistance(maxRenderDistanceNew, deltaXNew);
			if (maxYRenderDistanceNew == 0) maxYRenderDistanceNew -= size/2;
			var maxYRenderDistanceOld: i32 = reduceRenderDistance(maxRenderDistanceOld, deltaXOld);
			if (maxYRenderDistanceOld == 0) maxYRenderDistanceOld -= size/2;

			const minYOld = olderPy -% maxYRenderDistanceOld & invMask;
			const maxYOld = olderPy +% maxYRenderDistanceOld +% size & invMask;
			const minYNew = lastPy -% maxYRenderDistanceNew & invMask;
			const maxYNew = lastPy +% maxYRenderDistanceNew +% size & invMask;

			var yValues: [storageSize]i32 = undefined;
			var yValuesLen: usize = 0;
			if (minYNew -% minYOld > 0) {
				var y = minYOld;
				while (y != minYNew and y != maxYOld) : (y +%= size) {
					yValues[yValuesLen] = y;
					yValuesLen += 1;
				}
			}
			if (maxYOld -% maxYNew > 0) {
				var y = minYOld +% @max(0, maxYNew -% minYOld);
				while (y != maxYOld) : (y +%= size) {
					yValues[yValuesLen] = y;
					yValuesLen += 1;
				}
			}

			for (yValues[0..yValuesLen]) |y| {
				const yIndex = @divExact(y, size) & storageMask;
				const index = xIndex*storageSize + yIndex;

				const oldMap = mapStorageLists[_lod][@intCast(index)].swap(null, .monotonic);
				if (oldMap) |map| {
					map.deferredDeinit();
				}
			}
		}
	}
}

fn createNewMeshes(olderPx: i32, olderPy: i32, olderPz: i32, olderRD: u16, meshRequests: *main.List(chunk.ChunkPosition), mapRequests: *main.List(LightMap.MapFragmentPosition)) void { // MARK: createNewMeshes()
	for (0..settings.highestLod + 1) |_lod| {
		const lod: u5 = @intCast(_lod);
		const maxRenderDistanceNew = lastRD*chunk.chunkSize << lod;
		const maxRenderDistanceOld = olderRD*chunk.chunkSize << lod;
		const size: u31 = chunk.chunkSize << lod;
		const mask: i32 = size - 1;
		const invMask: i32 = ~mask;

		std.debug.assert(@divFloor(2*maxRenderDistanceNew + size - 1, size) + 2 <= storageSize);

		const minX = lastPx -% maxRenderDistanceNew & invMask;
		const maxX = lastPx +% maxRenderDistanceNew +% size & invMask;
		var x = minX;
		while (x != maxX) : (x +%= size) {
			const xIndex = @divExact(x, size) & storageMask;
			var deltaXNew: i64 = @abs(x +% size/2 -% lastPx);
			deltaXNew = @max(0, deltaXNew - size/2);
			var deltaXOld: i64 = @abs(x +% size/2 -% olderPx);
			deltaXOld = @max(0, deltaXOld - size/2);
			const maxYRenderDistanceNew: i32 = reduceRenderDistance(maxRenderDistanceNew, deltaXNew);
			const maxYRenderDistanceOld: i32 = reduceRenderDistance(maxRenderDistanceOld, deltaXOld);

			const minY = lastPy -% maxYRenderDistanceNew & invMask;
			const maxY = lastPy +% maxYRenderDistanceNew +% size & invMask;
			var y = minY;
			while (y != maxY) : (y +%= size) {
				const yIndex = @divExact(y, size) & storageMask;
				var deltaYOld: i64 = @abs(y +% size/2 -% olderPy);
				deltaYOld = @max(0, deltaYOld - size/2);
				var deltaYNew: i64 = @abs(y +% size/2 -% lastPy);
				deltaYNew = @max(0, deltaYNew - size/2);
				var maxZRenderDistanceNew: i32 = reduceRenderDistance(maxYRenderDistanceNew, deltaYNew);
				if (maxZRenderDistanceNew == 0) maxZRenderDistanceNew -= size/2;
				var maxZRenderDistanceOld: i32 = reduceRenderDistance(maxYRenderDistanceOld, deltaYOld);
				if (maxZRenderDistanceOld == 0) maxZRenderDistanceOld -= size/2;

				const minZOld = olderPz -% maxZRenderDistanceOld & invMask;
				const maxZOld = olderPz +% maxZRenderDistanceOld +% size & invMask;
				const minZNew = lastPz -% maxZRenderDistanceNew & invMask;
				const maxZNew = lastPz +% maxZRenderDistanceNew +% size & invMask;

				var zValues: [storageSize]i32 = undefined;
				var zValuesLen: usize = 0;
				if (minZOld -% minZNew > 0) {
					var z = minZNew;
					while (z != minZOld and z != maxZNew) : (z +%= size) {
						zValues[zValuesLen] = z;
						zValuesLen += 1;
					}
				}
				if (maxZNew -% maxZOld > 0) {
					var z = minZNew +% @max(0, maxZOld -% minZNew);
					while (z != maxZNew) : (z +%= size) {
						zValues[zValuesLen] = z;
						zValuesLen += 1;
					}
				}

				for (zValues[0..zValuesLen]) |z| {
					const zIndex = @divExact(z, size) & storageMask;
					const index = (xIndex*storageSize + yIndex)*storageSize + zIndex;
					const pos = chunk.ChunkPosition{.wx = x, .wy = y, .wz = z, .voxelSize = @as(u31, 1) << lod};

					const node = &storageLists[_lod][@intCast(index)];
					node.pos = pos;
					if (node.mesh.load(.acquire)) |mesh| {
						std.debug.assert(std.meta.eql(pos, mesh.pos));
					} else {
						meshRequests.append(pos);
					}
				}
			}
		}
	}
	for (0..settings.highestLod + 1) |_lod| {
		const lod: u5 = @intCast(_lod);
		const maxRenderDistanceNew = lastRD*chunk.chunkSize << lod;
		const maxRenderDistanceOld = olderRD*chunk.chunkSize << lod;
		const size: u31 = @as(u31, LightMap.LightMapFragment.mapSize) << lod;
		const mask: i32 = size - 1;
		const invMask: i32 = ~mask;

		std.debug.assert(@divFloor(2*maxRenderDistanceNew + size - 1, size) + 2 <= storageSize);

		const minX = lastPx -% maxRenderDistanceNew & invMask;
		const maxX = lastPx +% maxRenderDistanceNew +% size & invMask;
		var x = minX;
		while (x != maxX) : (x +%= size) {
			const xIndex = @divExact(x, size) & storageMask;
			var deltaXNew: i64 = @abs(x +% size/2 -% lastPx);
			deltaXNew = @max(0, deltaXNew - size/2);
			var deltaXOld: i64 = @abs(x +% size/2 -% olderPx);
			deltaXOld = @max(0, deltaXOld - size/2);
			var maxYRenderDistanceNew: i32 = reduceRenderDistance(maxRenderDistanceNew, deltaXNew);
			if (maxYRenderDistanceNew == 0) maxYRenderDistanceNew -= size/2;
			var maxYRenderDistanceOld: i32 = reduceRenderDistance(maxRenderDistanceOld, deltaXOld);
			if (maxYRenderDistanceOld == 0) maxYRenderDistanceOld -= size/2;

			const minYOld = olderPy -% maxYRenderDistanceOld & invMask;
			const maxYOld = olderPy +% maxYRenderDistanceOld +% size & invMask;
			const minYNew = lastPy -% maxYRenderDistanceNew & invMask;
			const maxYNew = lastPy +% maxYRenderDistanceNew +% size & invMask;

			var yValues: [storageSize]i32 = undefined;
			var yValuesLen: usize = 0;
			if (minYOld -% minYNew > 0) {
				var y = minYNew;
				while (y != minYOld and y != maxYNew) : (y +%= size) {
					yValues[yValuesLen] = y;
					yValuesLen += 1;
				}
			}
			if (maxYNew -% maxYOld > 0) {
				var y = minYNew +% @max(0, maxYOld -% minYNew);
				while (y != maxYNew) : (y +%= size) {
					yValues[yValuesLen] = y;
					yValuesLen += 1;
				}
			}

			for (yValues[0..yValuesLen]) |y| {
				const yIndex = @divExact(y, size) & storageMask;
				const index = xIndex*storageSize + yIndex;
				const pos = LightMap.MapFragmentPosition{.wx = x, .wy = y, .voxelSize = @as(u31, 1) << lod, .voxelSizeShift = lod};

				const map = mapStorageLists[_lod][@intCast(index)].load(.monotonic);
				if (map) |_map| {
					std.debug.assert(std.meta.eql(pos, _map.pos));
				} else {
					mapRequests.append(pos);
				}
			}
		}
	}
}

pub noinline fn updateAndGetRenderChunks(conn: *network.Connection, frustum: *const main.renderer.Frustum, playerPos: Vec3d, renderDistance: u16) []*chunk_meshing.ChunkMesh { // MARK: updateAndGetRenderChunks()
	meshList.clearRetainingCapacity();

	const playerPosInt: Vec3i = @intFromFloat(@floor(playerPos));

	var meshRequests = main.List(chunk.ChunkPosition).init(main.stackAllocator);
	defer meshRequests.deinit();
	var mapRequests = main.List(LightMap.MapFragmentPosition).init(main.stackAllocator);
	defer mapRequests.deinit();

	const olderPx = lastPx;
	const olderPy = lastPy;
	const olderPz = lastPz;
	const olderRD = lastRD;
	mutex.lock();
	lastPx = @intFromFloat(playerPos[0]);
	lastPy = @intFromFloat(playerPos[1]);
	lastPz = @intFromFloat(playerPos[2]);
	lastRD = renderDistance;
	mutex.unlock();
	freeOldMeshes(olderPx, olderPy, olderPz, olderRD);

	createNewMeshes(olderPx, olderPy, olderPz, olderRD, &meshRequests, &mapRequests);

	// Make requests as soon as possible to reduce latency:
	network.protocols.lightMapRequest.sendRequest(conn, mapRequests.items);
	network.protocols.chunkRequest.sendRequest(conn, meshRequests.items, .{lastPx, lastPy, lastPz}, lastRD);

	// Finds all visible chunks and lod chunks using a breadth-first hierarchical search.

	var searchList = main.utils.CircularBufferQueue(*ChunkMeshNode).init(main.stackAllocator, 1024);
	defer searchList.deinit();
	{
		var firstPos = chunk.ChunkPosition{
			.wx = @intFromFloat(@floor(playerPos[0])),
			.wy = @intFromFloat(@floor(playerPos[1])),
			.wz = @intFromFloat(@floor(playerPos[2])),
			.voxelSize = 1,
		};
		const lod: u3 = settings.highestLod;
		firstPos.wx &= ~@as(i32, chunk.chunkMask << lod | (@as(i32, 1) << lod) - 1);
		firstPos.wy &= ~@as(i32, chunk.chunkMask << lod | (@as(i32, 1) << lod) - 1);
		firstPos.wz &= ~@as(i32, chunk.chunkMask << lod | (@as(i32, 1) << lod) - 1);
		firstPos.voxelSize <<= lod;
		const node = getNodePointer(firstPos);
		const hasMesh = node.finishedMeshing;
		if (hasMesh) {
			node.active = true;
			node.rendered = true;
			searchList.pushBack(node);
		}
	}
	var nodeList = main.List(*ChunkMeshNode).initCapacity(main.stackAllocator, 1024);
	defer nodeList.deinit();
	while (searchList.popFront()) |node| {
		std.debug.assert(node.finishedMeshing);
		std.debug.assert(node.active);
		if (!node.active) continue;
		node.active = false;

		const pos = node.pos;

		const relPos: Vec3d = @as(Vec3d, @floatFromInt(Vec3i{pos.wx, pos.wy, pos.wz})) - playerPos;
		const relPosFloat: Vec3f = @floatCast(relPos);

		if (pos.voxelSize == @as(i32, 1) << settings.highestLod) {
			for (chunk.Neighbor.iterable) |neighbor| {
				const component = neighbor.extractDirectionComponent(relPosFloat);
				if (neighbor.isPositive() and component + @as(f32, @floatFromInt(chunk.chunkSize*pos.voxelSize)) <= 0) continue;
				if (!neighbor.isPositive() and component >= 0) continue;
				const neighborPos = chunk.ChunkPosition{
					.wx = pos.wx +% neighbor.relX()*chunk.chunkSize*pos.voxelSize,
					.wy = pos.wy +% neighbor.relY()*chunk.chunkSize*pos.voxelSize,
					.wz = pos.wz +% neighbor.relZ()*chunk.chunkSize*pos.voxelSize,
					.voxelSize = pos.voxelSize,
				};
				const node2 = getNodePointer(neighborPos);
				if (!node2.active and node2.finishedMeshing) {
					if (!frustum.testAAB(relPosFloat + @as(Vec3f, @floatFromInt(Vec3i{neighbor.relX()*chunk.chunkSize*pos.voxelSize, neighbor.relY()*chunk.chunkSize*pos.voxelSize, neighbor.relZ()*chunk.chunkSize*pos.voxelSize})), @splat(@floatFromInt(chunk.chunkSize*pos.voxelSize))))
						continue;
					node2.active = true;
					node2.rendered = true;
					searchList.pushBack(node2);
				}
			}
		}

		if (node.finishedMeshingHigherResolution == 0xff) {
			node.rendered = false;
			const lowerLodBit: i32 = pos.voxelSize*chunk.chunkSize >> 1;
			const startPos: chunk.ChunkPosition = .{
				.wx = pos.wx | if ((pos.wx | lowerLodBit) -% playerPosInt[0] > 0) lowerLodBit else 0,
				.wy = pos.wy | if ((pos.wy | lowerLodBit) -% playerPosInt[1] > 0) lowerLodBit else 0,
				.wz = pos.wz | if ((pos.wz | lowerLodBit) -% playerPosInt[2] > 0) lowerLodBit else 0,
				.voxelSize = pos.voxelSize >> 1,
			};
			for (0..2) |dx| {
				for (0..2) |dy| {
					for (0..2) |dz| {
						var nextPos = startPos;
						if (dx == 1) nextPos.wx ^= lowerLodBit;
						if (dy == 1) nextPos.wy ^= lowerLodBit;
						if (dz == 1) nextPos.wz ^= lowerLodBit;
						const node2 = getNodePointer(nextPos);
						const relNextPos: Vec3d = @as(Vec3d, @floatFromInt(Vec3i{nextPos.wx, nextPos.wy, nextPos.wz})) - playerPos;
						if (!frustum.testAAB(@floatCast(relNextPos), @splat(@floatFromInt(chunk.chunkSize*nextPos.voxelSize))))
							continue;
						std.debug.assert(node2.finishedMeshing);
						node2.active = true;
						node2.rendered = true;
						searchList.pushFront(node2);
					}
				}
			}
		} else {
			nodeList.append(node);
		}
	}
	for (nodeList.items) |node| {
		const pos = node.pos;
		var isNeighborLod: [6]bool = @splat(false);
		if (pos.voxelSize != @as(i32, 1) << settings.highestLod) {
			for (chunk.Neighbor.iterable) |neighbor| {
				var neighborPos = chunk.ChunkPosition{
					.wx = pos.wx +% neighbor.relX()*chunk.chunkSize*pos.voxelSize,
					.wy = pos.wy +% neighbor.relY()*chunk.chunkSize*pos.voxelSize,
					.wz = pos.wz +% neighbor.relZ()*chunk.chunkSize*pos.voxelSize,
					.voxelSize = pos.voxelSize,
				};
				neighborPos.wx &= ~@as(i32, neighborPos.voxelSize*chunk.chunkSize);
				neighborPos.wy &= ~@as(i32, neighborPos.voxelSize*chunk.chunkSize);
				neighborPos.wz &= ~@as(i32, neighborPos.voxelSize*chunk.chunkSize);
				neighborPos.voxelSize *= 2;
				const node2 = getNodePointer(neighborPos);
				isNeighborLod[neighbor.toInt()] = node2.finishedMeshingHigherResolution != 0xff;
			}
		}
		if (!std.meta.eql(node.isNeighborLod, isNeighborLod)) {
			const mesh = node.mesh.load(.acquire).?; // no other thread is allowed to overwrite the mesh (unless it's null).
			mesh.isNeighborLod = isNeighborLod;
			node.isNeighborLod = isNeighborLod;
			mesh.uploadData();
		}
	}
	for (nodeList.items) |node| {
		node.rendered = false;
		if (!node.finishedMeshing) continue;

		const mesh = node.mesh.load(.acquire).?; // no other thread is allowed to overwrite the mesh (unless it's null).

		if (mesh.needsMeshUpdate) {
			mesh.uploadData();
			mesh.needsMeshUpdate = false;
		}
		// Remove empty meshes.
		if (!mesh.isEmpty()) {
			meshList.append(mesh);
		}
	}

	return meshList.items;
}

pub fn updateMeshes(targetTime: std.Io.Timestamp) void { // MARK: updateMeshes()
	if (!blockUpdateList.isEmpty()) batchUpdateBlocks();

	mutex.lock();
	defer mutex.unlock();
	while (priorityMeshUpdateList.popFront()) |pos| {
		const mesh = getMesh(pos) orelse continue;
		if (!mesh.needsMeshUpdate) {
			continue;
		}
		mesh.needsMeshUpdate = false;
		mutex.unlock();
		defer mutex.lock();
		mesh.uploadData();
		if (targetTime.durationTo(main.timestamp()).nanoseconds >= 0) break; // Update at least one mesh.
	}
	while (mapUpdatableList.popFront()) |map| {
		if (!isMapInRenderDistance(map.pos)) {
			map.deferredDeinit();
		} else {
			const mapPointer = getMapPiecePointer(map.pos.wx, map.pos.wy, map.pos.voxelSize).swap(map, .release);
			if (mapPointer) |old| {
				old.deferredDeinit();
			}
		}
	}
	while (updatableList.items.len != 0) {
		// TODO: Find a faster solution than going through the entire list every frame.
		var closestPriority: f32 = -std.math.floatMax(f32);
		var closestIndex: usize = 0;
		const playerPos = game.Player.getEyePosBlocking();
		{
			var i: usize = 0;
			while (i < updatableList.items.len) {
				const pos = updatableList.items[i];
				if (!isInRenderDistance(pos)) {
					_ = updatableList.swapRemove(i);
					mutex.unlock();
					defer mutex.lock();
					continue;
				}
				const priority = pos.getPriority(playerPos);
				if (priority > closestPriority) {
					closestPriority = priority;
					closestIndex = i;
				}
				i += 1;
			}
			if (updatableList.items.len == 0) break;
		}
		const pos = updatableList.swapRemove(closestIndex);
		mutex.unlock();
		defer mutex.lock();
		if (isInRenderDistance(pos)) {
			const node = getNodePointer(pos);
			if (node.finishedMeshing) continue;
			const mesh = getMesh(pos) orelse continue;
			node.finishedMeshing = true;
			mesh.finishedMeshing = true;
			updateHigherLodNodeFinishedMeshing(pos, true);
			mesh.uploadData();
		}
		if (targetTime.durationTo(main.timestamp()).nanoseconds >= 0) break; // Update at least one mesh.
	}
}

fn batchUpdateBlocks() void {
	var lightRefreshList = main.List(chunk.ChunkPosition).init(main.stackAllocator);
	defer lightRefreshList.deinit();

	var regenerateMeshList = main.List(*ChunkMesh).init(main.stackAllocator);
	defer regenerateMeshList.deinit();

	// First of all process all the block updates:
	while (blockUpdateList.popFront()) |blockUpdate| {
		defer blockUpdate.deinitManaged(main.globalAllocator);
		const pos = chunk.ChunkPosition{.wx = blockUpdate.x, .wy = blockUpdate.y, .wz = blockUpdate.z, .voxelSize = 1};
		if (getMesh(pos)) |mesh| {
			mesh.updateBlock(blockUpdate.x, blockUpdate.y, blockUpdate.z, blockUpdate.newBlock, blockUpdate.blockEntityData, &lightRefreshList, &regenerateMeshList);
		} // TODO: It seems like we simply ignore the block update if we don't have the mesh yet.
	}
	for (regenerateMeshList.items) |mesh| {
		mesh.generateMesh(&lightRefreshList);
	}
	for (lightRefreshList.items) |pos| {
		ChunkMesh.scheduleLightRefresh(pos);
	}
	for (regenerateMeshList.items) |mesh| {
		mesh.uploadData();
	}
}

// MARK: adders

pub fn addToUpdateList(mesh: *chunk_meshing.ChunkMesh) void {
	mutex.lock();
	defer mutex.unlock();
	if (mesh.finishedMeshing) {
		priorityMeshUpdateList.pushBack(mesh.pos);
		mesh.needsMeshUpdate = true;
	}
}

pub fn addMeshToStorage(mesh: *chunk_meshing.ChunkMesh) error{ AlreadyStored, NoLongerNeeded }!void {
	mutex.lock();
	defer mutex.unlock();
	if (!isInRenderDistance(mesh.pos)) {
		return error.NoLongerNeeded;
	}
	const node = getNodePointer(mesh.pos);
	if (node.mesh.cmpxchgStrong(null, mesh, .release, .monotonic) != null) {
		return error.AlreadyStored;
	}
	node.finishedMeshing = mesh.finishedMeshing;
	updateHigherLodNodeFinishedMeshing(mesh.pos, mesh.finishedMeshing);
}

pub fn finishMesh(pos: chunk.ChunkPosition) void {
	mutex.lock();
	defer mutex.unlock();
	updatableList.append(pos);
}

pub const MeshGenerationTask = struct { // MARK: MeshGenerationTask
	mesh: *chunk.Chunk,

	pub const vtable = utils.ThreadPool.VTable{
		.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
		.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
		.run = main.meta.castFunctionSelfToAnyopaque(run),
		.clean = main.meta.castFunctionSelfToAnyopaque(clean),
		.taskType = .meshgenAndLighting,
	};

	fn schedule(mesh: *chunk.Chunk) void {
		const task = main.globalAllocator.create(MeshGenerationTask);
		task.* = MeshGenerationTask{
			.mesh = mesh,
		};
		main.threadPool.addTask(task, &vtable);
	}

	pub fn getPriority(self: *MeshGenerationTask) f32 {
		return self.mesh.pos.getPriority(game.Player.getPosBlocking()); // TODO: This is called in loop, find a way to do this without calling the mutex every time.
	}

	pub fn isStillNeeded(self: *MeshGenerationTask) bool {
		const distanceSqr = self.mesh.pos.getMinDistanceSquared(@intFromFloat(game.Player.getPosBlocking())); // TODO: This is called in loop, find a way to do this without calling the mutex every time.
		var maxRenderDistance = settings.renderDistance*chunk.chunkSize*self.mesh.pos.voxelSize;
		maxRenderDistance += 2*self.mesh.pos.voxelSize*chunk.chunkSize;
		return distanceSqr < maxRenderDistance*maxRenderDistance;
	}

	pub fn run(self: *MeshGenerationTask) void {
		defer main.globalAllocator.destroy(self);
		const pos = self.mesh.pos;
		const mesh = ChunkMesh.init(pos, self.mesh);
		mesh.generateLightingData() catch mesh.deferredDeinit();
	}

	pub fn clean(self: *MeshGenerationTask) void {
		self.mesh.unloadBlockEntities(.client);
		self.mesh.deinit();
		main.globalAllocator.destroy(self);
	}
};

// MARK: updaters

pub fn updateBlock(update: BlockUpdate) void {
	blockUpdateList.pushBack(BlockUpdate.initManaged(main.globalAllocator, update));
}

pub fn updateChunkMesh(mesh: *chunk.Chunk) void {
	MeshGenerationTask.schedule(mesh);
}

pub fn updateLightMap(map: *LightMap.LightMapFragment) void {
	mapUpdatableList.pushBack(map);
}

// MARK: Block breaking animation

pub fn addBreakingAnimation(pos: Vec3i, breakingProgress: f32) void {
	const animationFrame: usize = @intFromFloat(breakingProgress*@as(f32, @floatFromInt(main.blocks.meshes.blockBreakingTextures.items.len)));
	const texture = main.blocks.meshes.blockBreakingTextures.items[animationFrame];

	const block = getBlockFromRenderThread(pos[0], pos[1], pos[2]) orelse return;
	const model = main.blocks.meshes.model(block).model();

	for (model.internalQuads) |quadIndex| {
		addBreakingAnimationFace(pos, quadIndex, texture, null, block.transparent());
	}
	for (&model.neighborFacingQuads, 0..) |quads, n| {
		for (quads) |quadIndex| {
			addBreakingAnimationFace(pos, quadIndex, texture, @enumFromInt(n), block.transparent());
		}
	}
}

fn addBreakingAnimationFace(pos: Vec3i, quadIndex: main.models.QuadIndex, texture: u16, neighbor: ?chunk.Neighbor, isTransparent: bool) void {
	const worldPos = pos +% if (neighbor) |n| n.relPos() else Vec3i{0, 0, 0};
	const relPos = worldPos & @as(Vec3i, @splat(main.chunk.chunkMask));
	const mesh = getMesh(.{.wx = worldPos[0], .wy = worldPos[1], .wz = worldPos[2], .voxelSize = 1}) orelse return;
	mesh.mutex.lock();
	defer mesh.mutex.unlock();
	const lightIndex = blk: {
		const meshData = if (isTransparent) &mesh.transparentMesh else &mesh.opaqueMesh;
		meshData.lock.lockRead();
		defer meshData.lock.unlockRead();
		for (meshData.completeList.getEverything()) |face| {
			if (face.position.x == relPos[0] and face.position.y == relPos[1] and face.position.z == relPos[2] and face.blockAndQuad.quadIndex == quadIndex) {
				break :blk face.position.lightIndex;
			}
		}
		// The face doesn't exist.
		return;
	};
	mesh.blockBreakingFacesChanged = true;
	mesh.blockBreakingFaces.append(.{
		.position = .{
			.x = @intCast(relPos[0]),
			.y = @intCast(relPos[1]),
			.z = @intCast(relPos[2]),
			.isBackFace = false,
			.lightIndex = lightIndex,
		},
		.blockAndQuad = .{
			.texture = texture,
			.quadIndex = quadIndex,
		},
	});
}

fn removeBreakingAnimationFace(pos: Vec3i, quadIndex: main.models.QuadIndex, neighbor: ?chunk.Neighbor) void {
	const worldPos = pos +% if (neighbor) |n| n.relPos() else Vec3i{0, 0, 0};
	const relPos = worldPos & @as(Vec3i, @splat(main.chunk.chunkMask));
	const mesh = getMesh(.{.wx = worldPos[0], .wy = worldPos[1], .wz = worldPos[2], .voxelSize = 1}) orelse return;
	for (mesh.blockBreakingFaces.items, 0..) |face, i| {
		if (face.position.x == relPos[0] and face.position.y == relPos[1] and face.position.z == relPos[2] and face.blockAndQuad.quadIndex == quadIndex) {
			_ = mesh.blockBreakingFaces.swapRemove(i);
			mesh.blockBreakingFacesChanged = true;
			break;
		}
	}
}

pub fn removeBreakingAnimation(pos: Vec3i) void {
	const block = getBlockFromRenderThread(pos[0], pos[1], pos[2]) orelse return;
	const model = main.blocks.meshes.model(block).model();

	for (model.internalQuads) |quadIndex| {
		removeBreakingAnimationFace(pos, quadIndex, null);
	}
	for (&model.neighborFacingQuads, 0..) |quads, n| {
		for (quads) |quadIndex| {
			removeBreakingAnimationFace(pos, quadIndex, @enumFromInt(n));
		}
	}
}

```

`src/rotation.zig`:

```zig
const std = @import("std");

const blocks = @import("blocks.zig");
const Block = blocks.Block;
const chunk = @import("chunk.zig");
const Neighbor = chunk.Neighbor;
const main = @import("main");
const ModelIndex = main.models.ModelIndex;
const Tag = main.Tag;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const Vec3f = vec.Vec3f;
const Mat4f = vec.Mat4f;
const ZonElement = main.ZonElement;

pub const list = @import("rotation");

pub const RayIntersectionResult = struct {
	distance: f64,
	min: Vec3f,
	max: Vec3f,
	face: Neighbor,
};

pub const Degrees = enum(u2) {
	@"0" = 0,
	@"90" = 1,
	@"180" = 2,
	@"270" = 3,
};

// TODO: Why not just use a tagged union?
/// Each block gets 16 bit of additional storage(apart from the reference to the block type).
/// These 16 bits are accessed and interpreted by the `RotationMode`.
/// With the `RotationMode` interface there is almost no limit to what can be done with those 16 bit.
pub const RotationMode = struct { // MARK: RotationMode
	pub const DefaultFunctions = struct {
		pub fn model(block: Block) ModelIndex {
			return blocks.meshes.modelIndexStart(block);
		}
		pub fn rotateZ(data: u16, _: Degrees) u16 {
			return data;
		}
		pub fn generateData(_: *main.game.World, _: Vec3i, _: Vec3f, _: Vec3f, _: Vec3i, _: ?Neighbor, _: *Block, _: Block, blockPlacing: bool) bool {
			return blockPlacing;
		}
		pub fn createBlockModel(_: Block, _: *u16, zon: ZonElement) ModelIndex {
			return main.models.getModelIndex(zon.as([]const u8, "cubyz:cube"));
		}
		pub fn updateData(_: *Block, _: Neighbor, _: Block) bool {
			return false;
		}
		pub fn modifyBlock(_: *Block, _: u16) bool {
			return false;
		}
		pub fn rayIntersection(block: Block, _: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) ?RayIntersectionResult {
			return rayModelIntersection(blocks.meshes.model(block), relativePlayerPos, playerDir);
		}
		pub fn rayModelIntersection(modelIndex: ModelIndex, relativePlayerPos: Vec3f, playerDir: Vec3f) ?RayIntersectionResult {
			// Check the true bounding box (using this algorithm here: https://tavianator.com/2011/ray_box.html):
			const invDir = @as(Vec3f, @splat(1))/playerDir;
			const modelData = modelIndex.model();
			const min: Vec3f = modelData.min;
			const max: Vec3f = modelData.max;
			const t1 = (min - relativePlayerPos)*invDir;
			const t2 = (max - relativePlayerPos)*invDir;
			const boxTMin = @reduce(.Max, @min(t1, t2));
			const boxTMax = @reduce(.Min, @max(t1, t2));
			if (boxTMin <= boxTMax and boxTMax > 0) {
				var face: Neighbor = undefined;
				if (boxTMin == t1[0]) {
					face = Neighbor.dirNegX;
				} else if (boxTMin == t1[1]) {
					face = Neighbor.dirNegY;
				} else if (boxTMin == t1[2]) {
					face = Neighbor.dirDown;
				} else if (boxTMin == t2[0]) {
					face = Neighbor.dirPosX;
				} else if (boxTMin == t2[1]) {
					face = Neighbor.dirPosY;
				} else if (boxTMin == t2[2]) {
					face = Neighbor.dirUp;
				} else {
					unreachable;
				}
				return .{
					.distance = boxTMin,
					.min = min,
					.max = max,
					.face = face,
				};
			}
			return null;
		}
		pub fn onBlockBreaking(_: main.items.Item, _: Vec3f, _: Vec3f, currentData: *Block) void {
			currentData.* = .{.typ = 0, .data = 0};
		}
		pub fn canBeChangedInto(oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) CanBeChangedInto {
			shouldDropSourceBlockOnSuccess.* = true;
			if (oldBlock == newBlock) return .no;
			if (oldBlock.typ == newBlock.typ) return .yes;
			if (!oldBlock.replacable()) {
				var damage: f32 = main.game.Player.defaultBlockDamage;
				const isTool = item.item == .tool;
				if (isTool) {
					damage = item.item.tool.getBlockDamage(oldBlock);
				}
				damage -= oldBlock.blockResistance();
				if (damage > 0) {
					if (isTool and item.item.tool.isEffectiveOn(oldBlock)) {
						return .{.yes_costsDurability = 1};
					} else return .yes;
				}
			} else {
				if (item.item == .baseItem) {
					if (item.item.baseItem.block() != null and item.item.baseItem.block().? == newBlock.typ) {
						return .{.yes_costsItems = 1};
					}
				}
				if (newBlock.typ == 0) {
					return .yes;
				}
			}
			return .no;
		}
		pub fn itemDropsOnChange(oldBlock: Block, newBlock: Block) u16 {
			if (newBlock.typ != oldBlock.typ) return 1;
			return 0;
		}
		pub fn getBlockTags() []const Tag {
			return &.{};
		}
	};

	pub const CanBeChangedInto = union(enum) {
		no: void,
		yes: void,
		yes_costsDurability: u16,
		yes_costsItems: u16,
	};

	/// if the block should be destroyed or changed when a certain neighbor is removed.
	dependsOnNeighbors: bool = false,

	/// The default rotation data intended for generation algorithms
	naturalStandard: u16 = 0,

	model: *const fn (block: Block) ModelIndex = &DefaultFunctions.model,

	// Rotates block data counterclockwise around the Z axis.
	rotateZ: *const fn (data: u16, angle: Degrees) u16 = DefaultFunctions.rotateZ,

	createBlockModel: *const fn (block: Block, modeData: *u16, zon: ZonElement) ModelIndex = &DefaultFunctions.createBlockModel,

	/// Updates the block data of a block in the world or places a block in the world.
	/// return true if the placing was successful, false otherwise.
	generateData: *const fn (world: *main.game.World, pos: Vec3i, relativePlayerPos: Vec3f, playerDir: Vec3f, relativeDir: Vec3i, neighbor: ?Neighbor, currentData: *Block, neighborBlock: Block, blockPlacing: bool) bool = DefaultFunctions.generateData,

	/// Updates data of a placed block if the RotationMode dependsOnNeighbors.
	updateData: *const fn (block: *Block, neighbor: Neighbor, neighborBlock: Block) bool = &DefaultFunctions.updateData,

	modifyBlock: *const fn (block: *Block, newType: u16) bool = DefaultFunctions.modifyBlock,

	rayIntersection: *const fn (block: Block, item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f) ?RayIntersectionResult = &DefaultFunctions.rayIntersection,

	onBlockBreaking: *const fn (item: main.items.Item, relativePlayerPos: Vec3f, playerDir: Vec3f, currentData: *Block) void = &DefaultFunctions.onBlockBreaking,

	canBeChangedInto: *const fn (oldBlock: Block, newBlock: Block, item: main.items.ItemStack, shouldDropSourceBlockOnSuccess: *bool) CanBeChangedInto = DefaultFunctions.canBeChangedInto,

	itemDropsOnChange: *const fn (oldBlock: Block, newBlock: Block) u16 = DefaultFunctions.itemDropsOnChange,

	getBlockTags: *const fn () []const Tag = DefaultFunctions.getBlockTags,
};

var rotationModes: std.StringHashMap(RotationMode) = undefined;

pub fn rotationMatrixTransform(quad: *main.models.QuadInfo, transformMatrix: Mat4f) void {
	quad.normal = vec.xyz(Mat4f.mulVec(transformMatrix, vec.combine(quad.normal, 0)));
	for (&quad.corners) |*corner| {
		corner.* = vec.xyz(Mat4f.mulVec(transformMatrix, vec.combine(corner.* - Vec3f{0.5, 0.5, 0.5}, 1))) + Vec3f{0.5, 0.5, 0.5};
	}
}

// MARK: init/register

pub fn init() void {
	rotationModes = .init(main.globalAllocator.allocator);
	inline for (@typeInfo(list).@"struct".decls) |declaration| {
		register(declaration.name, @field(list, declaration.name));
	}
}

pub fn reset() void {
	inline for (@typeInfo(list).@"struct".decls) |declaration| {
		@field(list, declaration.name).reset();
	}
}

pub fn deinit() void {
	rotationModes.deinit();
	inline for (@typeInfo(list).@"struct".decls) |declaration| {
		@field(list, declaration.name).deinit();
	}
}

pub fn getByID(id: []const u8) *const RotationMode {
	if (rotationModes.getPtr(id)) |mode| return mode;
	std.log.err("Could not find rotation mode {s}. Using cubyz:no_rotation instead.", .{id});
	return rotationModes.getPtr("cubyz:no_rotation").?;
}

pub fn register(comptime id: []const u8, comptime Mode: type) void {
	Mode.init();
	var result: RotationMode = RotationMode{};
	inline for (@typeInfo(RotationMode).@"struct".fields) |field| {
		if (@hasDecl(Mode, field.name)) {
			if (field.type == @TypeOf(@field(Mode, field.name))) {
				@field(result, field.name) = @field(Mode, field.name);
			} else {
				@field(result, field.name) = &@field(Mode, field.name);
			}
		}
	}
	rotationModes.putNoClobber(id, result) catch unreachable;
}

```

`src/server/BlockUpdateSystem.zig`:

```zig
const std = @import("std");

const main = @import("main");
const BlockPos = main.chunk.BlockPos;
const ZonElement = main.ZonElement;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

list: main.ListUnmanaged(BlockPos) = .{},
mutex: std.Thread.Mutex = .{},

pub fn init() @This() {
	return .{};
}
pub fn deinit(self: *@This()) void {
	self.mutex = undefined;
	self.list.deinit(main.globalAllocator);
}
pub fn add(self: *@This(), position: BlockPos) void {
	self.mutex.lock();
	defer self.mutex.unlock();
	self.list.append(main.globalAllocator, position);
}
pub fn update(self: *@This(), ch: *main.chunk.ServerChunk) void {
	// swap
	self.mutex.lock();
	const list = self.list;
	defer list.deinit(main.globalAllocator);
	self.list = .{};
	self.mutex.unlock();

	// handle events
	for (list.items) |event| {
		ch.mutex.lock();
		const block = ch.getBlock(event.x, event.y, event.z);
		ch.mutex.unlock();

		_ = block.onUpdate().run(.{
			.block = block,
			.chunk = ch,
			.blockPos = event,
		});
	}
}

```

`src/server/Entity.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ZonElement = main.ZonElement;
const vec = main.vec;
const Vec3f = vec.Vec3f;
const Vec3d = vec.Vec3d;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pos: Vec3d = .{0, 0, 0},
vel: Vec3d = .{0, 0, 0},
rot: Vec3f = .{0, 0, 0},

health: f32 = 8,
maxHealth: f32 = 8,
energy: f32 = 8,
maxEnergy: f32 = 8,
// TODO: Name

pub fn loadFrom(self: *@This(), zon: ZonElement) void {
	self.pos = zon.get(Vec3d, "position", .{0, 0, 0});
	self.vel = zon.get(Vec3d, "velocity", .{0, 0, 0});
	self.rot = zon.get(Vec3f, "rotation", .{0, 0, 0});
	self.health = zon.get(f32, "health", self.maxHealth);
	self.energy = zon.get(f32, "energy", self.maxEnergy);
}

pub fn save(self: *@This(), allocator: NeverFailingAllocator) ZonElement {
	const zon = ZonElement.initObject(allocator);
	zon.put("position", self.pos);
	zon.put("velocity", self.vel);
	zon.put("rotation", self.rot);
	zon.put("health", self.health);
	zon.put("energy", self.energy);
	return zon;
}

```

`src/server/SimulationChunk.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ChunkPosition = main.chunk.ChunkPosition;
const ServerChunk = main.chunk.ServerChunk;
const BlockUpdateSystem = main.server.BlockUpdateSystem;

const SimulationChunk = @This();

chunk: std.atomic.Value(?*ServerChunk) = .init(null),
refCount: std.atomic.Value(u32),
pos: ChunkPosition,
blockUpdateSystem: BlockUpdateSystem,

pub fn initAndIncreaseRefCount(pos: ChunkPosition) *SimulationChunk {
	const self = main.globalAllocator.create(SimulationChunk);
	self.* = .{
		.refCount = .init(1),
		.pos = pos,
		.blockUpdateSystem = .init(),
	};
	return self;
}

fn deinit(self: *SimulationChunk) void {
	std.debug.assert(self.refCount.load(.monotonic) == 0);
	self.blockUpdateSystem.deinit();
	if (self.chunk.raw) |ch| ch.decreaseRefCount();
	main.globalAllocator.destroy(self);
}

pub fn increaseRefCount(self: *SimulationChunk) void {
	const prevVal = self.refCount.fetchAdd(1, .monotonic);
	std.debug.assert(prevVal != 0);
}

pub fn decreaseRefCount(self: *SimulationChunk) void {
	const prevVal = self.refCount.fetchSub(1, .monotonic);
	std.debug.assert(prevVal != 0);
	if (prevVal == 2) {
		main.server.world_zig.ChunkManager.tryRemoveSimulationChunk(self);
	}
	if (prevVal == 1) {
		self.deinit();
	}
}

pub fn getChunk(self: *SimulationChunk) ?*ServerChunk {
	return self.chunk.load(.acquire);
}

pub fn setChunkAndDecreaseRefCount(self: *SimulationChunk, ch: *ServerChunk) void {
	std.debug.assert(self.chunk.swap(ch, .release) == null);
}

pub fn update(self: *SimulationChunk, randomTickSpeed: u32) void {
	const serverChunk = self.getChunk() orelse return;
	tickBlocksInChunk(serverChunk, randomTickSpeed);
	self.blockUpdateSystem.update(serverChunk);
}

fn tickBlocksInChunk(_chunk: *ServerChunk, randomTickSpeed: u32) void {
	for (0..randomTickSpeed) |_| {
		const blockIndex = main.random.nextInt(u15, &main.seed);
		const pos = main.chunk.BlockPos.fromIndex(blockIndex);

		_chunk.mutex.lock();
		const block = _chunk.getBlock(pos.x, pos.y, pos.z);
		_chunk.mutex.unlock();
		_ = block.onTick().run(.{.block = block, .chunk = _chunk, .blockPos = pos});
	}
}

```

`src/server/command/_command.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const Command = struct {
	exec: *const fn (args: []const u8, source: *User) void,
	name: []const u8,
	description: []const u8,
	usage: []const u8,
	permissionPath: []const u8,
};

pub var commands: std.StringHashMap(Command) = undefined;

pub fn init() void {
	commands = .init(main.globalAllocator.allocator);
	const commandList = @import("_list.zig");
	inline for (@typeInfo(commandList).@"struct".decls) |decl| {
		commands.put(decl.name, .{
			.name = decl.name,
			.description = @field(commandList, decl.name).description,
			.usage = @field(commandList, decl.name).usage,
			.exec = &@field(commandList, decl.name).execute,
			.permissionPath = "/command/" ++ decl.name,
		}) catch unreachable;
		std.log.debug("Registered command: '/{s}'", .{decl.name});
	}
}

pub fn deinit() void {
	commands.deinit();
}

pub fn execute(msg: []const u8, source: *User) void {
	const end = std.mem.indexOfScalar(u8, msg, ' ') orelse msg.len;
	const command = msg[0..end];
	if (commands.get(command)) |cmd| {
		if (!source.hasPermission(cmd.permissionPath)) {
			source.sendMessage("#ff0000No permission to use Command \"{s}\"", .{command});
			return;
		}
		source.sendMessage("#00ff00Executing Command /{s}", .{msg});
		cmd.exec(msg[@min(end + 1, msg.len)..], source);
	} else {
		source.sendMessage("#ff0000Unrecognized Command \"{s}\"", .{command});
	}
}

```

`src/server/command/_list.zig`:

```zig
pub const clear = @import("clear.zig");
pub const gamemode = @import("gamemode.zig");
pub const help = @import("help.zig");
pub const invite = @import("invite.zig");
pub const kill = @import("kill.zig");
pub const particles = @import("particles.zig");
pub const spawn = @import("spawn.zig");
pub const tickspeed = @import("tickspeed.zig");
pub const time = @import("time.zig");
pub const tp = @import("tp.zig");

pub const perm = @import("permission/perm.zig");

pub const undo = @import("worldedit/undo.zig");
pub const redo = @import("worldedit/redo.zig");
pub const pos1 = @import("worldedit/pos1.zig");
pub const pos2 = @import("worldedit/pos2.zig");
pub const deselect = @import("worldedit/deselect.zig");
pub const copy = @import("worldedit/copy.zig");
pub const paste = @import("worldedit/paste.zig");
pub const blueprint = @import("worldedit/blueprint.zig");
pub const rotate = @import("worldedit/rotate.zig");
pub const set = @import("worldedit/set.zig");
pub const mask = @import("worldedit/mask.zig");
pub const replace = @import("worldedit/replace.zig");

```

`src/server/command/clear.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Clears your inventory/chat";
pub const usage = "/clear <inventory/chat>";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len == 0) {
		source.sendMessage("#ff0000Too few arguments for command /clear. Expected one argument.", .{});
		return;
	}
	var split = std.mem.splitScalar(u8, args, ' ');
	if (split.next()) |arg| {
		if (split.next() != null) {
			source.sendMessage("#ff0000Too many arguments for command /clear", .{});
			return;
		}
		if (std.ascii.eqlIgnoreCase(arg, "inventory")) {
			main.items.Inventory.ServerSide.clearPlayerInventory(source);
		} else if (std.ascii.eqlIgnoreCase(arg, "chat")) {
			main.network.protocols.genericUpdate.sendClear(source.conn, .chat);
		} else {
			source.sendMessage("#ff0000Expected either inventory or chat, found \"{s}\"", .{arg});
		}
	}
}

```

`src/server/command/gamemode.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Get or set your gamemode.";
pub const usage = "/gamemode\n/gamemode <survival/creative>";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len == 0) {
		source.sendMessage("#ffff00{s}", .{@tagName(source.gamemode.load(.monotonic))});
		return;
	}
	if (std.ascii.eqlIgnoreCase(args, "survival")) {
		main.sync.setGamemode(source, .survival);
	} else if (std.ascii.eqlIgnoreCase(args, "creative")) {
		main.sync.setGamemode(source, .creative);
	} else {
		source.sendMessage("#ff0000Invalid argument for command /gamemode. Must be 'survival' or 'creative'.", .{});
		return;
	}
}

```

`src/server/command/help.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

const command = @import("_command.zig");

pub const description = "Shows info about all the commands.";
pub const usage = "/help\n/help <command>";

pub fn execute(args: []const u8, source: *User) void {
	var msg = main.List(u8).init(main.stackAllocator);
	defer msg.deinit();
	msg.appendSlice("#ffff00");
	if (args.len == 0) {
		var iterator = command.commands.valueIterator();
		while (iterator.next()) |cmd| {
			msg.append('/');
			msg.appendSlice(cmd.name);
			msg.appendSlice(": ");
			msg.appendSlice(cmd.description);
			msg.append('\n');
		}
		msg.appendSlice("\nUse /help <command> for usage of a specific command.\n");
	} else {
		var split = std.mem.splitScalar(u8, args, ' ');
		while (split.next()) |arg| {
			if (command.commands.get(arg)) |cmd| {
				msg.append('/');
				msg.appendSlice(cmd.name);
				msg.appendSlice(": ");
				msg.appendSlice(cmd.description);
				msg.append('\n');
				msg.appendSlice(cmd.usage);
				msg.append('\n');
			} else {
				msg.appendSlice("#ff0000Unrecognized Command \"");
				msg.appendSlice(arg);
				msg.appendSlice("\"#ffff00\n");
			}
		}
	}
	if (msg.items[msg.items.len - 1] == '\n') _ = msg.pop();
	source.sendMessage("{s}", .{msg.items});
}

```

`src/server/command/invite.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Invite a player";
pub const usage = "/invite <IP>";

pub fn execute(args: []const u8, source: *User) void {
	var split = std.mem.splitScalar(u8, args, ' ');
	if (split.next()) |arg| blk: {
		if (arg.len == 0) break :blk;
		if (split.next() != null) {
			source.sendMessage("#ff0000Too many arguments for command /invite", .{});
		}
		const user = main.server.User.initAndIncreaseRefCount(main.server.connectionManager, arg) catch |err| {
			std.log.err("Error while trying to connect: {s}", .{@errorName(err)});
			source.sendMessage("#ff0000Error while trying to connect: {s}", .{@errorName(err)});
			return;
		};
		user.decreaseRefCount();
		return;
	}
	source.sendMessage("#ff0000Too few arguments for command /invite", .{});
}

```

`src/server/command/kill.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Kills the player";
pub const usage = "/kill";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /kill. Expected no arguments.", .{});
		return;
	}
	main.sync.addHealth(-std.math.floatMax(f32), .kill, .server, source.id);
}

```

`src/server/command/particles.zig`:

```zig
const std = @import("std");

const main = @import("main");
const particles = main.particles;
const User = main.server.User;

pub const description = "Spawns particles.";
pub const usage =
	\\/particles <id> <x> <y> <z>
	\\/particles <id> <x> <y> <z> <collides>
	\\/particles <id> <x> <y> <z> <collides> <count>
	\\/particles <id> <x> <y> <z> <collides> <count> <spawnDataZon>
	\\
	\\tip: use "~" to apply current player position coordinate in <x> <y> <z> fields.
	\\zon example:
	\\.{
	\\  .shape = .sphere,
	\\  .radius = 5,
	\\  .mode = .scatter,
	\\  .speed = .{0.5, 10},
	\\  .lifeTime = .{0.5, 10},
	\\  .randomRotate = true,
	\\}
;

pub fn execute(args: []const u8, source: *User) void {
	parseArguments(source, args) catch |err| {
		switch (err) {
			error.TooFewArguments => source.sendMessage("#ff0000Too few arguments for command /particles", .{}),
			error.TooManyArguments => source.sendMessage("#ff0000Too many arguments for command /particles", .{}),
			error.InvalidParticleId => source.sendMessage("#ff0000Invalid particle id", .{}),
			error.InvalidBoolean => source.sendMessage("#ff0000Invalid argument. Expected \"true\" or \"false\"", .{}),
			error.InvalidNumber => return,
			else => source.sendMessage("#ff0000Error: {s}", .{@errorName(err)}),
		}
		return;
	};
}

fn parseArguments(source: *User, args: []const u8) anyerror!void {
	const zonIndex = std.mem.indexOf(u8, args, " .{") orelse args.len;
	const zonStr = args[zonIndex..];
	var split = std.mem.splitScalar(u8, std.mem.trimRight(u8, args[0..zonIndex], " "), ' ');
	const particleId = split.next() orelse return error.TooFewArguments;

	const x = try parsePosition(split.next() orelse return error.TooFewArguments, source.player.pos[0], source);
	const y = try parsePosition(split.next() orelse return error.TooFewArguments, source.player.pos[1], source);
	const z = try parsePosition(split.next() orelse return error.TooFewArguments, source.player.pos[2], source);
	const collides = try parseBool(split.next() orelse "true");
	const particleCount = try parseNumber(split.next() orelse "1", source);

	if (split.next() != null) return error.TooManyArguments;

	const users = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
	defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, users);
	for (users) |user| {
		main.network.protocols.genericUpdate.sendParticles(user.conn, particleId, .{x, y, z}, collides, particleCount, zonStr);
	}
}

fn parsePosition(arg: []const u8, playerPos: f64, source: *User) anyerror!f64 {
	const hasTilde = if (arg.len == 0) false else arg[0] == '~';
	const numberSlice = if (hasTilde) arg[1..] else arg;
	const num: f64 = std.fmt.parseFloat(f64, numberSlice) catch ret: {
		if (arg.len > 1 or arg.len == 0) {
			source.sendMessage("#ff0000Expected number or \"~\", found \"{s}\"", .{arg});
			return error.InvalidNumber;
		}
		break :ret 0;
	};

	return if (hasTilde) playerPos + num else num;
}

fn parseBool(arg: []const u8) anyerror!bool {
	if (std.mem.eql(u8, arg, "true")) {
		return true;
	} else if (std.mem.eql(u8, arg, "false")) {
		return false;
	}

	return error.InvalidBoolean;
}

fn parseNumber(arg: []const u8, source: *User) anyerror!u32 {
	return std.fmt.parseUnsigned(u32, arg, 0) catch |err| {
		switch (err) {
			error.Overflow => {
				const maxParticleCount = particles.ParticleSystem.maxCapacity;
				source.sendMessage("#ff0000Too many particles spawned \"{s}\", maximum: \"{d}\"", .{arg, maxParticleCount});
				return maxParticleCount;
			},
			error.InvalidCharacter => {
				source.sendMessage("#ff0000Expected number, found \"{s}\"", .{arg});
				return error.InvalidNumber;
			},
		}
	};
}

```

`src/server/command/permission/perm.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;
const permission = main.server.permission;
const ListType = permission.Permissions.ListType;

pub const description = "Performs changes on the permissions of the player or shows the if has permission for a specific permission path";
pub const usage =
	\\/perm add <whitelist/blacklist> <permissionPath>
	\\/perm remove <whitelist/blacklist> <permissionPath>
	\\/perm <permissionPath>
;

pub fn execute(args: []const u8, source: *User) void {
	if (args.len == 0) {
		source.sendMessage("#ff0000Too few arguments for command /perm. Expected at least one argument.", .{});
		return;
	}
	var split = std.mem.splitScalar(u8, args, ' ');
	if (split.next()) |arg| {
		if (std.ascii.eqlIgnoreCase(arg, "remove")) {
			const helper = Helper.parseHelper(source, &split) catch return;
			if (!source.permissions.removePermission(helper.listType, helper.permissionPath)) {
				source.sendMessage("#ff0000Permission path {s} is not present inside users permission {s}list", .{helper.permissionPath, @tagName(helper.listType)});
			}
		} else if (std.ascii.eqlIgnoreCase(arg, "add")) {
			const helper = Helper.parseHelper(source, &split) catch return;
			source.permissions.addPermission(helper.listType, helper.permissionPath);
		} else if (arg[0] == '/') {
			if (split.next() != null) {
				source.sendMessage("#ff0000Not the right amount of arguments for /perm", .{});
				return;
			}
			if (source.hasPermission(arg)) {
				source.sendMessage("#00ff00User has permission for path: {s}", .{arg});
			} else {
				source.sendMessage("#ff0000User has no permission for path: {s}", .{arg});
			}
		} else {
			source.sendMessage("#ff0000Expected either add, remove or a valid permission path, found \"{s}\"", .{arg});
		}
	}
}

const Helper = struct {
	listType: ListType,
	permissionPath: []const u8,

	pub fn parseHelper(source: *User, split: *std.mem.SplitIterator(u8, .scalar)) error{InvalidArgs}!Helper {
		var listType: ListType = undefined;
		const arg = split.next() orelse {
			source.sendMessage("#ff0000Too few arguments for command /perm", .{});
			return error.InvalidArgs;
		};
		if (std.ascii.eqlIgnoreCase(arg, "whitelist")) {
			listType = .white;
		} else if (std.ascii.eqlIgnoreCase(arg, "blacklist")) {
			listType = .black;
		} else {
			source.sendMessage("#ff0000Expected either whitelist or blacklist, found \"{s}\"", .{arg});
			return error.InvalidArgs;
		}

		const permissionPath = split.next() orelse {
			source.sendMessage("#ff0000Too few arguments for command /perm.", .{});
			return error.InvalidArgs;
		};

		if (permissionPath[0] != '/') {
			source.sendMessage("#ff0000Permission paths always begin with a \"/\", got: {s}", .{permissionPath});
			return error.InvalidArgs;
		}

		if (split.next() != null) {
			source.sendMessage("#ff0000Too many arguments for command /perm", .{});
			return error.InvalidArgs;
		}

		return .{.listType = listType, .permissionPath = permissionPath};
	}
};

```

`src/server/command/spawn.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Get or set the player spawn point";
pub const usage =
	\\/spawn
	\\/spawn <x> <y>
	\\/spawn <x> <y> <z>
;

pub fn execute(args: []const u8, source: *User) void {
	var x: ?f64 = null;
	var y: ?f64 = null;
	var z: ?f64 = null;
	var split = std.mem.splitScalar(u8, args, ' ');
	while (split.next()) |arg| {
		if (arg.len == 0) break;
		const num: f64 = std.fmt.parseFloat(f64, arg) catch {
			source.sendMessage("#ff0000Expected number, found \"{s}\"", .{arg});
			return;
		};
		if (x == null) {
			x = num;
		} else if (y == null) {
			y = num;
		} else if (z == null) {
			z = num;
		} else {
			source.sendMessage("#ff0000Too many arguments for command /spawn", .{});
			return;
		}
	}
	if (x == null) {
		source.sendMessage("#ffff00{}", .{source.spawnPos});
		return;
	}
	if (y == null) {
		source.sendMessage("#ff0000Invalid number of arguments for /spawn.\nUsage: \n" ++ usage, .{});
		return;
	}
	if (z == null) {
		z = source.player.pos[2];
	}
	x = std.math.clamp(x.?, -1e9, 1e9); // TODO: Remove after #310 is implemented
	y = std.math.clamp(y.?, -1e9, 1e9);
	z = std.math.clamp(z.?, -1e9, 1e9);

	source.spawnPos = .{x.?, y.?, z.?};
}

```

`src/server/command/tickspeed.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Get or set the server's random tickrate, measured in blocks per chunk per tick.";
pub const usage = "/tickspeed\n/tickspeed <rate>";

pub fn execute(args: []const u8, source: *User) void {
	var split = std.mem.splitScalar(u8, args, ' ');
	if (split.next()) |arg| blk: {
		if (arg.len == 0) break :blk;
		if (split.next() != null) {
			source.sendMessage("#ff0000Too many arguments for command /tickspeed", .{});
			return;
		}
		const tickSpeed = std.fmt.parseInt(u32, arg, 0) catch {
			source.sendMessage("#ff0000Expected u32 number, found \"{s}\"", .{arg});
			return;
		};
		main.server.world.?.tickSpeed.store(tickSpeed, .monotonic);
		return;
	}
	source.sendMessage("#ffff00{}", .{main.server.world.?.tickSpeed.load(.monotonic)});
}

```

`src/server/command/time.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Get or set the server time.";
pub const usage = "/time\n/time <day/night>\n/time <time>\n/time <start/stop>";

pub fn execute(args: []const u8, source: *User) void {
	var split = std.mem.splitScalar(u8, args, ' ');
	if (split.next()) |arg| blk: {
		if (arg.len == 0) break :blk;
		var gameTime: i64 = undefined;
		if (std.ascii.eqlIgnoreCase(arg, "day")) {
			gameTime = 0;
		} else if (std.ascii.eqlIgnoreCase(arg, "night")) {
			gameTime = main.server.ServerWorld.dayCycle/2;
		} else if (std.ascii.eqlIgnoreCase(arg, "start")) {
			main.server.world.?.doGameTimeCycle = true;
			return;
		} else if (std.ascii.eqlIgnoreCase(arg, "stop")) {
			main.server.world.?.doGameTimeCycle = false;
			return;
		} else {
			gameTime = std.fmt.parseInt(i64, arg, 0) catch {
				source.sendMessage("#ff0000Expected i64 number, found \"{s}\"", .{arg});
				return;
			};
		}
		if (split.next() != null) {
			source.sendMessage("#ff0000Too many arguments for command /time", .{});
			return;
		}
		main.server.world.?.gameTime = gameTime;
		return;
	}
	source.sendMessage("#ffff00{}", .{main.server.world.?.gameTime});
}

```

`src/server/command/tp.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Teleport to location.";
pub const usage = "/tp <x> <y>\n/tp <x> <y> <z>\n/tp <biome>";

pub fn execute(args: []const u8, source: *User) void {
	if (std.mem.containsAtLeast(u8, args, 1, ":")) {
		const biome = main.server.terrain.biomes.getById(args);
		if (!std.mem.eql(u8, biome.id, args)) {
			source.sendMessage("#ff0000Couldn't find biome with id \"{s}\"", .{args});
			return;
		}
		if (biome.isCave) {
			source.sendMessage("#ff0000Teleport to biome is only available for surface biomes.", .{});
			return;
		}
		const radius = 16384;
		const mapSize: i32 = main.server.terrain.ClimateMap.ClimateMapFragment.mapSize;
		// Explore chunks in a spiral from the center:
		const spiralLen = 2*radius/mapSize*2*radius/mapSize;
		var wx = source.lastPos[0] & ~(mapSize - 1);
		var wy = source.lastPos[1] & ~(mapSize - 1);
		var dirChanges: usize = 1;
		var dir: main.chunk.Neighbor = .dirNegX;
		var stepsRemaining: usize = 1;
		for (0..spiralLen) |_| {
			const map = main.server.terrain.ClimateMap.getOrGenerateFragment(wx, wy);
			for (0..map.map.len) |_| {
				const x = main.random.nextIntBounded(u31, &main.seed, map.map.len);
				const y = main.random.nextIntBounded(u31, &main.seed, map.map.len);
				const sample = map.map[x][y];
				if (sample.biome == biome) {
					const z = sample.height + sample.hills + sample.mountains + sample.roughness;
					const biomeSize = main.server.terrain.SurfaceMap.MapFragment.biomeSize;
					main.network.protocols.genericUpdate.sendTPCoordinates(source.conn, .{@floatFromInt(wx + x*biomeSize + biomeSize/2), @floatFromInt(wy + y*biomeSize + biomeSize/2), @floatCast(z + biomeSize/2)});
					return;
				}
			}
			switch (dir) {
				.dirNegX => wx -%= mapSize,
				.dirPosX => wx +%= mapSize,
				.dirNegY => wy -%= mapSize,
				.dirPosY => wy +%= mapSize,
				else => unreachable,
			}
			stepsRemaining -= 1;
			if (stepsRemaining == 0) {
				switch (dir) {
					.dirNegX => dir = .dirNegY,
					.dirPosX => dir = .dirPosY,
					.dirNegY => dir = .dirPosX,
					.dirPosY => dir = .dirNegX,
					else => unreachable,
				}
				dirChanges += 1;
				// Every second turn the number of steps needed doubles.
				stepsRemaining = dirChanges/2;
			}
		}
		source.sendMessage("#ff0000Couldn't find biome. Searched in a radius of 16384 blocks.", .{});
		return;
	}
	var x: ?f64 = null;
	var y: ?f64 = null;
	var z: ?f64 = null;
	var split = std.mem.splitScalar(u8, args, ' ');
	while (split.next()) |arg| {
		const num: f64 = std.fmt.parseFloat(f64, arg) catch {
			source.sendMessage("#ff0000Expected number, found \"{s}\"", .{arg});
			return;
		};
		if (x == null) {
			x = num;
		} else if (y == null) {
			y = num;
		} else if (z == null) {
			z = num;
		} else {
			source.sendMessage("#ff0000Too many arguments for command /tp", .{});
			return;
		}
	}
	if (x == null or y == null) {
		source.sendMessage("#ff0000Too few arguments for command /tp", .{});
		return;
	}
	if (z == null) {
		z = source.player.pos[2];
	}
	x = std.math.clamp(x.?, -1e9, 1e9); // TODO: Remove after #310 is implemented
	y = std.math.clamp(y.?, -1e9, 1e9);
	z = std.math.clamp(z.?, -1e9, 1e9);
	main.network.protocols.genericUpdate.sendTPCoordinates(source.conn, .{x.?, y.?, z.?});
}

```

`src/server/command/worldedit/blueprint.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;
const vec = main.vec;
const Vec3i = vec.Vec3i;

const Dir = main.files.Dir;
const List = main.List;
const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const description = "Input-output operations on blueprints.";
pub const usage =
	\\/blueprint save <file-name>
	\\/blueprint delete <file-name>
	\\/blueprint load <file-name>
	\\/blueprint list
;

const BlueprintSubCommand = enum {
	save,
	delete,
	load,
	list,
	unknown,
	empty,

	fn fromString(string: []const u8) BlueprintSubCommand {
		return std.meta.stringToEnum(BlueprintSubCommand, string) orelse {
			if (string.len == 0) return .empty;
			return .unknown;
		};
	}
};

pub fn execute(args: []const u8, source: *User) void {
	var argsList = List([]const u8).init(main.stackAllocator);
	defer argsList.deinit();

	var splitIterator = std.mem.splitScalar(u8, args, ' ');
	while (splitIterator.next()) |a| {
		argsList.append(a);
	}

	if (argsList.items.len < 1) {
		source.sendMessage("#ff0000Not enough arguments for /blueprint, expected at least 1.", .{});
		return;
	}
	const subcommand = BlueprintSubCommand.fromString(argsList.items[0]);
	switch (subcommand) {
		.save => blueprintSave(argsList.items, source),
		.delete => blueprintDelete(argsList.items, source),
		.load => blueprintLoad(argsList.items, source),
		.list => blueprintList(source),
		.unknown => {
			source.sendMessage("#ff0000Unrecognized subcommand for /blueprint: '{s}'", .{argsList.items[0]});
		},
		.empty => {
			source.sendMessage("#ff0000Missing subcommand for /blueprint, usage: {s} ", .{usage});
		},
	}
}

fn blueprintSave(args: []const []const u8, source: *User) void {
	if (args.len < 2) {
		return source.sendMessage("#ff0000/blueprint save requires file-name argument.", .{});
	}
	if (args.len >= 3) {
		return source.sendMessage("#ff0000Too many arguments for /blueprint save. Expected 1 argument, file-name.", .{});
	}

	if (source.worldEditData.clipboard) |clipboard| {
		const storedBlueprint = clipboard.store(main.stackAllocator);
		defer main.stackAllocator.free(storedBlueprint);

		const fileName: []const u8 = ensureBlueprintExtension(main.stackAllocator, args[1]);
		defer main.stackAllocator.free(fileName);

		var blueprintsDir = openBlueprintsDir(source) orelse return;
		defer blueprintsDir.close();

		blueprintsDir.write(fileName, storedBlueprint) catch |err| {
			return sendWarningAndLog("Failed to write blueprint file '{s}' ({s})", .{fileName, @errorName(err)}, source);
		};

		sendInfoAndLog("Saved clipboard to blueprint file: {s}", .{fileName}, source);
	} else {
		source.sendMessage("#ff0000Error: No clipboard content to save.", .{});
	}
}

fn sendWarningAndLog(comptime fmt: []const u8, args: anytype, user: *User) void {
	std.log.warn(fmt, args);
	user.sendMessage("#ff0000" ++ fmt, args);
}

fn sendInfoAndLog(comptime fmt: []const u8, args: anytype, user: *User) void {
	std.log.info(fmt, args);
	user.sendMessage("#00ff00" ++ fmt, args);
}

fn openBlueprintsDir(source: *User) ?Dir {
	return main.files.cubyzDir().openDir("blueprints") catch |err| {
		sendWarningAndLog("Failed to open 'blueprints' directory ({s})", .{@errorName(err)}, source);
		return null;
	};
}

fn ensureBlueprintExtension(allocator: NeverFailingAllocator, fileName: []const u8) []const u8 {
	if (!std.ascii.endsWithIgnoreCase(fileName, ".blp")) {
		return std.fmt.allocPrint(allocator.allocator, "{s}.blp", .{fileName}) catch unreachable;
	} else {
		return allocator.dupe(u8, fileName);
	}
}

fn blueprintDelete(args: []const []const u8, source: *User) void {
	if (args.len < 2) {
		return source.sendMessage("#ff0000/blueprint delete requires file-name argument.", .{});
	}
	if (args.len >= 3) {
		return source.sendMessage("#ff0000Too many arguments for /blueprint delete. Expected 1 argument, file-name.", .{});
	}

	const fileName: []const u8 = ensureBlueprintExtension(main.stackAllocator, args[1]);
	defer main.stackAllocator.free(fileName);

	var blueprintsDir = openBlueprintsDir(source) orelse return;
	defer blueprintsDir.close();

	blueprintsDir.deleteFile(fileName) catch |err| {
		return sendWarningAndLog("Failed to delete blueprint file '{s}' ({s})", .{fileName, @errorName(err)}, source);
	};

	sendWarningAndLog("Deleted blueprint file: {s}", .{fileName}, source);
}

fn blueprintList(source: *User) void {
	var blueprintsDir = main.files.cubyzDir().openIterableDir("blueprints") catch |err| {
		return sendWarningAndLog("Failed to open 'blueprints' directory ({s})", .{@errorName(err)}, source);
	};
	defer blueprintsDir.close();

	var directoryIterator = blueprintsDir.iterate();

	while (directoryIterator.next() catch |err| {
		return sendWarningAndLog("Failed to read blueprint directory ({s})", .{@errorName(err)}, source);
	}) |entry| {
		if (entry.kind != .file) break;
		if (!std.ascii.endsWithIgnoreCase(entry.name, ".blp")) break;

		source.sendMessage("#ffffff- {s}", .{entry.name});
	}
}

fn blueprintLoad(args: []const []const u8, source: *User) void {
	if (args.len < 2) {
		return source.sendMessage("#ff0000/blueprint load requires file-name argument.", .{});
	}
	if (args.len >= 3) {
		return source.sendMessage("#ff0000Too many arguments for /blueprint load. Expected 1 argument, file-name.", .{});
	}

	const fileName: []const u8 = ensureBlueprintExtension(main.stackAllocator, args[1]);
	defer main.stackAllocator.free(fileName);

	var blueprintsDir = openBlueprintsDir(source) orelse return;
	defer blueprintsDir.close();

	const storedBlueprint = blueprintsDir.read(main.stackAllocator, fileName) catch |err| {
		sendWarningAndLog("Failed to read blueprint file '{s}' ({s})", .{fileName, @errorName(err)}, source);
		return;
	};
	defer main.stackAllocator.free(storedBlueprint);

	if (source.worldEditData.clipboard) |oldClipboard| {
		oldClipboard.deinit(main.globalAllocator);
	}
	source.worldEditData.clipboard = Blueprint.load(main.globalAllocator, storedBlueprint) catch |err| {
		return sendWarningAndLog("Failed to load blueprint file '{s}' ({s})", .{fileName, @errorName(err)}, source);
	};

	sendInfoAndLog("Loaded blueprint file: {s}", .{fileName}, source);
}

```

`src/server/command/worldedit/copy.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;

pub const description = "Copy selection to clipboard.";
pub const usage = "/copy";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /copy. Expected no arguments.", .{});
		return;
	}
	const pos1 = source.worldEditData.selectionPosition1 orelse {
		return source.sendMessage("#ff0000Position 1 isn't set", .{});
	};
	const pos2 = source.worldEditData.selectionPosition2 orelse {
		return source.sendMessage("#ff0000Position 2 isn't set", .{});
	};

	source.sendMessage("Copying: {} {}", .{pos1, pos2});

	const result = Blueprint.capture(main.globalAllocator, pos1, pos2);
	switch (result) {
		.success => {
			if (source.worldEditData.clipboard != null) {
				source.worldEditData.clipboard.?.deinit(main.globalAllocator);
			}
			source.worldEditData.clipboard = result.success;

			source.sendMessage("Copied selection to clipboard.", .{});
		},
		.failure => |e| {
			source.sendMessage("#ff0000Error while copying block {}: {s}", .{e.pos, e.message});
			std.log.warn("Error while copying block {}: {s}", .{e.pos, e.message});
		},
	}
}

```

`src/server/command/worldedit/deselect.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

pub const description = "Clears pos1 and pos2 of selection.";
pub const usage = "/deselect";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /deselect. Expected no arguments.", .{});
		return;
	}

	source.worldEditData.selectionPosition1 = null;
	source.worldEditData.selectionPosition2 = null;

	main.network.protocols.genericUpdate.sendWorldEditPos(source.conn, .clear, null);
	source.sendMessage("Cleared selection.", .{});
}

```

`src/server/command/worldedit/mask.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

const Mask = main.blueprint.Mask;

pub const description = "Set edit mask. When used with no mask expression it will clear current mask.";
pub const usage =
	\\/mask <mask>
	\\/mask
;

pub fn execute(args: []const u8, source: *User) void {
	if (args.len == 0) {
		if (source.worldEditData.mask) |mask| mask.deinit(main.globalAllocator);
		source.worldEditData.mask = null;
		source.sendMessage("#00ff00Mask cleared.", .{});
		return;
	}
	const mask = Mask.initFromString(main.globalAllocator, args) catch |err| {
		source.sendMessage("#ff0000Error parsing mask: {}", .{err});
		return;
	};
	source.worldEditData.mask = mask;
	source.sendMessage("#00ff00Mask set.", .{});
}

```

`src/server/command/worldedit/paste.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;
const vec = main.vec;
const Vec3i = vec.Vec3i;

const copy = @import("copy.zig");

const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;

pub const description =
	\\Paste clipboard content to current player position.
	\\'-v' - Enable preserving void blocks. By default, void blocks are not preserved.
;
pub const usage = "/paste [-v]";

pub fn execute(args: []const u8, source: *User) void {
	var flags = Blueprint.PasteFlags{};

	if (args.len != 0) {
		if (std.mem.eql(u8, args, "-v")) {
			flags.preserveVoid = true;
		} else {
			source.sendMessage("#ff0000Argument(s) '{s}' not recognized.", .{args});
			return;
		}
	}

	if (source.worldEditData.clipboard) |clipboard| {
		const pos: Vec3i = @intFromFloat(source.player.pos);
		source.sendMessage("Pasting: {}", .{pos});

		const undo = Blueprint.capture(main.globalAllocator, pos, .{
			pos[0] + @as(i32, @intCast(clipboard.blocks.width)) - 1,
			pos[1] + @as(i32, @intCast(clipboard.blocks.depth)) - 1,
			pos[2] + @as(i32, @intCast(clipboard.blocks.height)) - 1,
		});
		switch (undo) {
			.success => |blueprint| {
				source.worldEditData.undoHistory.push(.init(blueprint, pos, "paste"));
				source.worldEditData.redoHistory.clear();
			},
			.failure => {
				source.sendMessage("#ff0000Error: Could not capture undo history.", .{});
			},
		}

		clipboard.paste(pos, flags);
	} else {
		source.sendMessage("#ff0000Error: No clipboard content to paste.", .{});
	}
}

```

`src/server/command/worldedit/pos1.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;
const Vec3i = main.vec.Vec3i;

pub const description = "Select the player position as position 1.";
pub const usage = "/pos1";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /pos1. Expected no arguments.", .{});
		return;
	}

	const pos: Vec3i = @intFromFloat(source.player.pos);

	source.worldEditData.selectionPosition1 = pos;
	main.network.protocols.genericUpdate.sendWorldEditPos(source.conn, .selectedPos1, pos);

	source.sendMessage("Position 1: {}", .{pos});
}

```

`src/server/command/worldedit/pos2.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;
const Vec3i = main.vec.Vec3i;

pub const description = "Select the player position as position 2.";
pub const usage = "/pos2";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /pos2. Expected no arguments.", .{});
		return;
	}

	const pos: Vec3i = @intFromFloat(source.player.pos);

	source.worldEditData.selectionPosition2 = pos;
	main.network.protocols.genericUpdate.sendWorldEditPos(source.conn, .selectedPos2, pos);

	source.sendMessage("Position 2: {}", .{pos});
}

```

`src/server/command/worldedit/redo.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;

pub const description = "Redo last change done to world with world editing commands.";
pub const usage = "/redo";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /redo. Expected no arguments.", .{});
		return;
	}
	if (source.worldEditData.redoHistory.pop()) |action| {
		const undo = Blueprint.capture(main.globalAllocator, action.position, .{
			action.position[0] + @as(i32, @intCast(action.blueprint.blocks.width)) - 1,
			action.position[1] + @as(i32, @intCast(action.blueprint.blocks.depth)) - 1,
			action.position[2] + @as(i32, @intCast(action.blueprint.blocks.height)) - 1,
		});
		action.blueprint.paste(action.position, .{.preserveVoid = true});

		switch (undo) {
			.success => |blueprint| {
				source.worldEditData.undoHistory.push(.init(blueprint, action.position, action.message));
			},
			.failure => {
				source.sendMessage("#ff0000Error: Could not capture undo history.", .{});
			},
		}
		source.sendMessage("#00ff00Re-done last {s}.", .{action.message});
	} else {
		source.sendMessage("#ccccccNothing to redo.", .{});
	}
}

```

`src/server/command/worldedit/replace.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec3i = main.vec.Vec3i;
const User = main.server.User;

const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;
const Pattern = main.blueprint.Pattern;
const Mask = main.blueprint.Mask;

pub const description = "Replace blocks in the world edit selection.";
pub const usage = "/replace <old mask> <new pattern>";

pub fn execute(args: []const u8, source: *User) void {
	var argsSplit = std.mem.splitScalar(u8, args, ' ');
	const oldMaskString = argsSplit.next() orelse {
		return source.sendMessage("#ff0000Missing required <old> argument.", .{});
	};
	const newPatternString = argsSplit.next() orelse {
		return source.sendMessage("#ff0000Missing required <new> argument.", .{});
	};

	const pos1 = source.worldEditData.selectionPosition1 orelse {
		return source.sendMessage("#ff0000Position 1 isn't set", .{});
	};
	const pos2 = source.worldEditData.selectionPosition2 orelse {
		return source.sendMessage("#ff0000Position 2 isn't set", .{});
	};

	const oldMask = Mask.initFromString(main.stackAllocator, oldMaskString) catch |err| {
		return source.sendMessage("#ff0000Error parsing mask: {s}", .{@errorName(err)});
	};
	defer oldMask.deinit(main.stackAllocator);

	const newPattern = Pattern.initFromString(main.stackAllocator, newPatternString) catch |err| {
		return source.sendMessage("#ff0000Error parsing pattern: {s}", .{@errorName(err)});
	};
	defer newPattern.deinit(main.stackAllocator);

	const posStart: Vec3i = @min(pos1, pos2);
	const posEnd: Vec3i = @max(pos1, pos2);

	const selection = Blueprint.capture(main.globalAllocator, posStart, posEnd);

	switch (selection) {
		.success => |blueprint| {
			source.worldEditData.undoHistory.push(.init(blueprint, posStart, "replace"));
			source.worldEditData.redoHistory.clear();

			var modifiedBlueprint = blueprint.clone(main.stackAllocator);
			defer modifiedBlueprint.deinit(main.stackAllocator);

			modifiedBlueprint.replace(oldMask, null, newPattern);
			modifiedBlueprint.paste(posStart, .{.preserveVoid = true});
		},
		.failure => |err| {
			source.sendMessage("#ff0000Error: Could not capture selection. (at {}, {s})", .{err.pos, err.message});
		},
	}
}

```

`src/server/command/worldedit/rotate.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;
const Degrees = main.rotation.Degrees;

pub const description = "rotate clipboard content around Z axis counterclockwise.";
pub const usage =
	\\/rotate
	\\/rotate <0/90/180/270>
;

pub fn execute(args: []const u8, source: *User) void {
	var angle: Degrees = .@"90";
	if (args.len != 0) {
		angle = std.meta.stringToEnum(Degrees, args) orelse {
			source.sendMessage("#ff0000Error: Invalid angle '{s}'. Use 0, 90, 180 or 270.", .{args});
			return;
		};
	}
	if (source.worldEditData.clipboard == null) {
		source.sendMessage("#ff0000Error: No clipboard content to rotate.", .{});
		return;
	}
	const current = source.worldEditData.clipboard.?;
	defer current.deinit(main.globalAllocator);
	source.worldEditData.clipboard = current.rotateZ(main.globalAllocator, angle);
}

```

`src/server/command/worldedit/set.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec3i = main.vec.Vec3i;
const User = main.server.User;

const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;
const Pattern = main.blueprint.Pattern;

pub const description = "Set all blocks within selection to a block.";
pub const usage = "/set <pattern>";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len == 0) {
		source.sendMessage("#ff0000Missing required <pattern> argument.", .{});
		return;
	}
	const pos1 = source.worldEditData.selectionPosition1 orelse {
		return source.sendMessage("#ff0000Position 1 isn't set", .{});
	};
	const pos2 = source.worldEditData.selectionPosition2 orelse {
		return source.sendMessage("#ff0000Position 2 isn't set", .{});
	};
	const pattern = Pattern.initFromString(main.stackAllocator, args) catch |err| {
		source.sendMessage("#ff0000Error parsing pattern: {s}", .{@errorName(err)});
		return;
	};
	defer pattern.deinit(main.stackAllocator);

	const posStart: Vec3i = @min(pos1, pos2);
	const posEnd: Vec3i = @max(pos1, pos2);

	const selection = Blueprint.capture(main.globalAllocator, posStart, posEnd);

	switch (selection) {
		.success => |blueprint| {
			source.worldEditData.undoHistory.push(.init(blueprint, posStart, "set"));
			source.worldEditData.redoHistory.clear();

			var modifiedBlueprint = blueprint.clone(main.stackAllocator);
			defer modifiedBlueprint.deinit(main.stackAllocator);

			modifiedBlueprint.replace(null, source.worldEditData.mask, pattern);
			modifiedBlueprint.paste(posStart, .{.preserveVoid = true});
		},
		.failure => |err| {
			source.sendMessage("#ff0000Error: Could not capture selection. (at {}, {s})", .{err.pos, err.message});
		},
	}
}

```

`src/server/command/worldedit/undo.zig`:

```zig
const std = @import("std");

const main = @import("main");
const User = main.server.User;

const Block = main.blocks.Block;
const Blueprint = main.blueprint.Blueprint;

pub const description = "Undo last change done to world with world editing commands.";
pub const usage = "/undo";

pub fn execute(args: []const u8, source: *User) void {
	if (args.len != 0) {
		source.sendMessage("#ff0000Too many arguments for command /undo. Expected no arguments.", .{});
		return;
	}
	if (source.worldEditData.undoHistory.pop()) |action| {
		const redo = Blueprint.capture(main.globalAllocator, action.position, .{
			action.position[0] + @as(i32, @intCast(action.blueprint.blocks.width)) - 1,
			action.position[1] + @as(i32, @intCast(action.blueprint.blocks.depth)) - 1,
			action.position[2] + @as(i32, @intCast(action.blueprint.blocks.height)) - 1,
		});
		action.blueprint.paste(action.position, .{.preserveVoid = true});

		switch (redo) {
			.success => |blueprint| {
				source.worldEditData.redoHistory.push(.init(blueprint, action.position, action.message));
			},
			.failure => {
				source.sendMessage("#ff0000Error: Could not capture redo history.", .{});
			},
		}
		source.sendMessage("#00ff00Un-done last {s}.", .{action.message});
	} else {
		source.sendMessage("#ccccccNothing to undo.", .{});
	}
}

```

`src/server/permission.zig`:

```zig
const std = @import("std");

const main = @import("main");
const server = main.server;
const User = server.User;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const NeverFailingArenaAllocator = main.heap.NeverFailingArenaAllocator;
const ZonElement = main.ZonElement;
const sync = main.sync;

const PermissionMap = struct { // MARK: PermissionMap
	map: std.StringHashMapUnmanaged(void) = .{},

	pub fn fromZon(self: *PermissionMap, arena: NeverFailingAllocator, zon: ZonElement) void {
		sync.threadContext.assertCorrectContext(.server);
		for (zon.toSlice()) |item| {
			const string = item.as(?[]const u8, null) orelse continue;
			self.put(arena, string);
		}
	}

	pub fn toZon(self: *PermissionMap, arena: NeverFailingAllocator) ZonElement {
		sync.threadContext.assertCorrectContext(.server);
		const zon: ZonElement = .initArray(arena);

		var it = self.map.keyIterator();
		while (it.next()) |key| {
			zon.append(key.*);
		}
		return zon;
	}

	pub fn put(self: *PermissionMap, arena: NeverFailingAllocator, key: []const u8) void {
		const result = self.map.getOrPut(arena.allocator, key) catch unreachable;
		if (!result.found_existing) result.key_ptr.* = arena.dupe(u8, key);
	}
};

pub const Permissions = struct { // MARK: Permissions
	pub const ListType = enum {
		white,
		black,
	};

	arena: NeverFailingArenaAllocator,
	whitelist: PermissionMap = .{},
	blacklist: PermissionMap = .{},

	pub fn init(allocator: NeverFailingAllocator) Permissions {
		return .{
			.arena = .init(allocator),
		};
	}

	pub fn deinit(self: *Permissions) void {
		sync.threadContext.assertCorrectContext(.server);
		self.arena.deinit();
	}

	const PermissionResult = enum {
		yes,
		no,
		neutral,
	};

	fn list(self: *Permissions, listType: ListType) *PermissionMap {
		return switch (listType) {
			.white => &self.whitelist,
			.black => &self.blacklist,
		};
	}

	pub fn fromZon(self: *Permissions, zon: ZonElement) void {
		sync.threadContext.assertCorrectContext(.server);
		self.list(.white).fromZon(self.arena.allocator(), zon.getChild("permissionWhitelist"));
		self.list(.black).fromZon(self.arena.allocator(), zon.getChild("permissionBlacklist"));
	}

	pub fn toZon(self: *Permissions, allocator: NeverFailingAllocator, zon: *ZonElement) void {
		sync.threadContext.assertCorrectContext(.server);
		zon.put("permissionWhitelist", self.list(.white).toZon(allocator));
		zon.put("permissionBlacklist", self.list(.black).toZon(allocator));
	}

	pub fn addPermission(self: *Permissions, listType: ListType, permissionPath: []const u8) void {
		sync.threadContext.assertCorrectContext(.server);
		self.list(listType).put(self.arena.allocator(), permissionPath);
	}

	pub fn removePermission(self: *Permissions, listType: ListType, permissionPath: []const u8) bool {
		sync.threadContext.assertCorrectContext(.server);
		return self.list(listType).map.remove(permissionPath);
	}

	pub fn hasPermission(self: *Permissions, permissionPath: []const u8) PermissionResult {
		sync.threadContext.assertCorrectContext(.server);
		var current = permissionPath;

		while (std.mem.lastIndexOfScalar(u8, current, '/')) |nextPos| {
			if (self.blacklist.map.contains(current)) return .no;
			if (self.whitelist.map.contains(current)) return .yes;

			current = permissionPath[0..nextPos];
		}
		return if (self.whitelist.map.contains("/")) .yes else .neutral;
	}
};

// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// MARK: Testing
// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

test "WhitePermission" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/command/test");
	try std.testing.expectEqual(.yes, permissions.hasPermission("/command/test"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/command"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/"));
}

test "Blacklist" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/command");
	permissions.addPermission(.black, "/command/test");

	try std.testing.expectEqual(.no, permissions.hasPermission("/command/test"));
	try std.testing.expectEqual(.yes, permissions.hasPermission("/command"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/"));
}

test "DeepPermission" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/server/command/testing/test");

	try std.testing.expectEqual(.yes, permissions.hasPermission("/server/command/testing/test"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/server/command/testing"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/server/command"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/server"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/"));
	try std.testing.expectEqual(.neutral, permissions.hasPermission("/server/command/testing/test2"));
}

test "RootPermission" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/");

	try std.testing.expectEqual(.yes, permissions.hasPermission("/command/test"));
}

test "RootBlackPermission" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/");
	permissions.addPermission(.black, "/command/test");

	try std.testing.expectEqual(.no, permissions.hasPermission("/command/test"));
	try std.testing.expectEqual(.yes, permissions.hasPermission("/command/test2"));
}

test "addRemovePermission" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/command/test");

	try std.testing.expectEqual(true, permissions.removePermission(.white, "/command/test"));
}

test "RemoveNonExistentPermission" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/command/test");

	try std.testing.expectEqual(false, permissions.removePermission(.white, "/command/test2"));
}

test "PermissionListToFromZon" {
	var permissions: Permissions = .init(main.heap.testingAllocator);
	defer permissions.deinit();

	permissions.addPermission(.white, "/command/test");
	permissions.addPermission(.white, "/command/spawn");

	const zon = permissions.whitelist.toZon(main.heap.testingAllocator);
	defer zon.deinit(main.heap.testingAllocator);

	var testPermissions: Permissions = .init(main.heap.testingAllocator);
	defer testPermissions.deinit();

	testPermissions.whitelist.fromZon(testPermissions.arena.allocator(), zon);

	try std.testing.expectEqual(2, testPermissions.whitelist.map.size);

	var it = testPermissions.whitelist.map.keyIterator();
	while (it.next()) |item| {
		try std.testing.expectEqual(true, permissions.whitelist.map.contains(item.*));
	}
}

```

`src/server/server.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const chunk = main.chunk;
const network = main.network;
const Connection = network.Connection;
const ConnectionManager = network.ConnectionManager;
const InventoryId = main.items.Inventory.InventoryId;
const utils = main.utils;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const BinaryReader = main.utils.BinaryReader;
const BinaryWriter = main.utils.BinaryWriter;
const Blueprint = main.blueprint.Blueprint;
const Mask = main.blueprint.Mask;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const CircularBufferQueue = main.utils.CircularBufferQueue;
const sync = main.sync;

pub const BlockUpdateSystem = @import("BlockUpdateSystem.zig");
pub const world_zig = @import("world.zig");
pub const ServerWorld = world_zig.ServerWorld;
pub const terrain = @import("terrain/terrain.zig");
pub const Entity = @import("Entity.zig");
pub const SimulationChunk = @import("SimulationChunk.zig");
pub const storage = @import("storage.zig");
pub const permission = @import("permission.zig");

pub const command = @import("command/_command.zig");

pub const WorldEditData = struct {
	const maxWorldEditHistoryCapacity: u32 = 1024;

	selectionPosition1: ?Vec3i = null,
	selectionPosition2: ?Vec3i = null,
	clipboard: ?Blueprint = null,
	undoHistory: History,
	redoHistory: History,
	mask: ?Mask = null,

	const History = struct {
		changes: CircularBufferQueue(Value),

		const Value = struct {
			blueprint: Blueprint,
			position: Vec3i,
			message: []const u8,

			pub fn init(blueprint: Blueprint, position: Vec3i, message: []const u8) Value {
				return .{.blueprint = blueprint, .position = position, .message = main.globalAllocator.dupe(u8, message)};
			}
			pub fn deinit(self: Value) void {
				main.globalAllocator.free(self.message);
				self.blueprint.deinit(main.globalAllocator);
			}
		};
		pub fn init() History {
			return .{.changes = .init(main.globalAllocator, maxWorldEditHistoryCapacity)};
		}
		pub fn deinit(self: *History) void {
			self.clear();
			self.changes.deinit();
		}
		pub fn clear(self: *History) void {
			while (self.changes.popFront()) |item| item.deinit();
		}
		pub fn push(self: *History, value: Value) void {
			if (self.changes.reachedCapacity()) {
				if (self.changes.popFront()) |oldValue| oldValue.deinit();
			}

			self.changes.pushBack(value);
		}
		pub fn pop(self: *History) ?Value {
			return self.changes.popBack();
		}
	};
	pub fn init() WorldEditData {
		return .{.undoHistory = History.init(), .redoHistory = History.init()};
	}
	pub fn deinit(self: *WorldEditData) void {
		if (self.clipboard != null) {
			self.clipboard.?.deinit(main.globalAllocator);
		}
		self.undoHistory.deinit();
		self.redoHistory.deinit();
		if (self.mask) |mask| {
			mask.deinit(main.globalAllocator);
		}
	}
};

pub const User = struct { // MARK: User
	const maxSimulationDistance = 8;
	const simulationSize = 2*maxSimulationDistance;
	const simulationMask = simulationSize - 1;
	conn: *Connection = undefined,
	player: Entity = .{},
	timeDifference: utils.TimeDifference = .{},
	interpolation: utils.GenericInterpolation(3) = undefined,
	lastTime: i16 = undefined,
	lastSaveTime: std.Io.Timestamp = .fromNanoseconds(0),
	name: []const u8 = "",
	renderDistance: u16 = undefined,
	clientUpdatePos: Vec3i = .{0, 0, 0},
	receivedFirstEntityData: bool = false,
	isLocal: bool = false,
	id: u32 = 0, // TODO: Use entity id.
	// TODO: ipPort: []const u8,
	loadedChunks: [simulationSize][simulationSize][simulationSize]*SimulationChunk = undefined,
	lastRenderDistance: u16 = 0,
	lastPos: Vec3i = @splat(0),
	gamemode: std.atomic.Value(main.game.Gamemode) = .init(.creative),
	spawnPos: Vec3d = .{0, 0, 0},
	worldEditData: WorldEditData = undefined,

	playerIndex: usize = undefined,

	jobQueue: main.utils.ConcurrentMaxHeap(main.utils.ThreadPool.Task) = undefined,
	jobQueueScheduled: bool = false,
	jobQueueLastUpdate: struct { position: Vec3i, time: std.Io.Timestamp, alreadyInUpdate: bool = false } = .{.position = @splat(0), .time = .{.nanoseconds = 0}},

	lastSentBiomeId: u32 = 0xffffffff,

	newKeyString: []const u8 = &.{},
	key: network.authentication.PublicKey = undefined,
	legacyKey: ?network.authentication.PublicKey = null,

	inventoryClientToServerIdMap: std.AutoHashMap(InventoryId, InventoryId) = undefined,
	inventory: ?InventoryId = null,
	handInventory: ?InventoryId = null,

	connected: Atomic(bool) = .init(true),

	refCount: Atomic(u32) = .init(1),

	mutex: std.Thread.Mutex = .{},

	inventoryCommands: main.ListUnmanaged([]const u8) = .{},

	permissions: permission.Permissions = undefined,

	pub fn initAndIncreaseRefCount(manager: *ConnectionManager, ipPort: []const u8) !*User {
		const self = main.globalAllocator.create(User);
		errdefer main.globalAllocator.destroy(self);
		self.* = .{};
		self.inventoryClientToServerIdMap = .init(main.globalAllocator.allocator);
		self.jobQueue = .init(main.globalAllocator);
		self.conn = try Connection.init(manager, ipPort, self);
		self.increaseRefCount();
		self.worldEditData = .init();
		self.permissions = .init(main.globalAllocator);
		network.protocols.handShake.serverSide(self.conn);
		return self;
	}

	pub fn deinit(self: *User) void {
		std.debug.assert(self.refCount.load(.monotonic) == 0);

		main.items.Inventory.ServerSide.disconnectUser(self);
		std.debug.assert(self.inventoryClientToServerIdMap.count() == 0); // leak
		self.inventoryClientToServerIdMap.deinit();

		if (self.inventory != null) {
			world.?.savePlayer(self) catch |err| {
				std.log.err("Failed to save player: {s}", .{@errorName(err)});
				return;
			};

			main.items.Inventory.ServerSide.destroyExternallyManagedInventory(self.inventory.?);
			main.items.Inventory.ServerSide.destroyExternallyManagedInventory(self.handInventory.?);
		}

		self.permissions.deinit();

		self.worldEditData.deinit();

		self.unloadOldChunk(.{0, 0, 0}, 0);
		self.conn.deinit();
		self.jobQueue.deinit();
		main.globalAllocator.free(self.name);
		main.globalAllocator.free(self.newKeyString);
		for (self.inventoryCommands.items) |commandData| {
			main.globalAllocator.free(commandData);
		}
		self.inventoryCommands.deinit(main.globalAllocator);
		main.globalAllocator.destroy(self);
	}

	pub fn increaseRefCount(self: *User) void {
		const prevVal = self.refCount.fetchAdd(1, .monotonic);
		std.debug.assert(prevVal != 0);
	}

	pub fn decreaseRefCount(self: *User) void {
		const prevVal = self.refCount.fetchSub(1, .monotonic);
		std.debug.assert(prevVal != 0);
		if (prevVal == 1) {
			self.deinit();
		}
	}

	pub fn identifyFromKeysAndName(self: *User, name: []const u8, keys: main.ZonElement) !void {
		std.debug.assert(self.name.len == 0);
		self.name = main.globalAllocator.dupe(u8, name);
		{
			const keyBase64 = keys.get(?[]const u8, @tagName(main.settings.launchConfig.preferredAuthenticationAlgorithm), null) orelse return error.PublicKeyNotPresent;
			self.key = try .initFromBase64(keyBase64, main.settings.launchConfig.preferredAuthenticationAlgorithm);
			self.newKeyString = std.fmt.allocPrint(main.globalAllocator.allocator, "{s}:{s}", .{@tagName(main.settings.launchConfig.preferredAuthenticationAlgorithm), keyBase64}) catch unreachable;
		}
		var foundKey: bool = false;
		for (std.meta.fieldNames(main.network.authentication.KeyTypeEnum)) |keyTypeName| {
			const keyBase64 = keys.get(?[]const u8, keyTypeName, null) orelse continue;
			const keyWithType = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}:{s}", .{keyTypeName, keyBase64}) catch unreachable;
			defer main.stackAllocator.free(keyWithType);
			self.playerIndex = world.?.playerDatabase.get(keyWithType) orelse continue;
			foundKey = true;
			const keyType = std.meta.stringToEnum(main.network.authentication.KeyTypeEnum, keyTypeName) orelse unreachable;
			if (keyType == self.key) break;
			self.legacyKey = try .initFromBase64(keyBase64, keyType);
			break;
		}
		if (!foundKey) {
			const nameEntry = std.fmt.allocPrint(main.stackAllocator.allocator, "name:{s}", .{name}) catch unreachable;
			defer main.stackAllocator.free(nameEntry);
			self.playerIndex = world.?.playerDatabase.get(nameEntry) orelse world.?.nextPlayerIndex.fetchAdd(1, .monotonic);
		}
	}

	pub fn verifySignatures(self: *User, reader: *BinaryReader) !void {
		try self.key.verifySignature(reader, self.conn.secureChannel.verificationDataForClientSignature.items);
		if (self.legacyKey) |key| {
			try key.verifySignature(reader, self.conn.secureChannel.verificationDataForClientSignature.items);
		}
	}

	var freeId: u32 = 0;
	pub fn initPlayer(self: *User) void {
		self.id = freeId;
		freeId += 1;

		world.?.loadPlayer(self);
		self.interpolation.init(@ptrCast(&self.player.pos), @ptrCast(&self.player.vel));
		self.loadUnloadChunks();
	}

	fn simArrIndex(x: i32) usize {
		return @intCast(x >> chunk.chunkShift & simulationMask);
	}

	fn unloadOldChunk(self: *User, newPos: Vec3i, newRenderDistance: u16) void {
		const lastBoxStart = (self.lastPos -% @as(Vec3i, @splat(self.lastRenderDistance*chunk.chunkSize))) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const lastBoxEnd = (self.lastPos +% @as(Vec3i, @splat(self.lastRenderDistance*chunk.chunkSize))) +% @as(Vec3i, @splat(chunk.chunkSize - 1)) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const newBoxStart = (newPos -% @as(Vec3i, @splat(newRenderDistance*chunk.chunkSize))) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const newBoxEnd = (newPos +% @as(Vec3i, @splat(newRenderDistance*chunk.chunkSize))) +% @as(Vec3i, @splat(chunk.chunkSize - 1)) & ~@as(Vec3i, @splat(chunk.chunkMask));
		// Clear all chunks not inside the new box:
		var x: i32 = lastBoxStart[0];
		while (x != lastBoxEnd[0]) : (x +%= chunk.chunkSize) {
			const inXDistance = x -% newBoxStart[0] >= 0 and x -% newBoxEnd[0] < 0;
			var y: i32 = lastBoxStart[1];
			while (y != lastBoxEnd[1]) : (y +%= chunk.chunkSize) {
				const inYDistance = y -% newBoxStart[1] >= 0 and y -% newBoxEnd[1] < 0;
				var z: i32 = lastBoxStart[2];
				while (z != lastBoxEnd[2]) : (z +%= chunk.chunkSize) {
					const inZDistance = z -% newBoxStart[2] >= 0 and z -% newBoxEnd[2] < 0;
					if (!inXDistance or !inYDistance or !inZDistance) {
						self.loadedChunks[simArrIndex(x)][simArrIndex(y)][simArrIndex(z)].decreaseRefCount();
						self.loadedChunks[simArrIndex(x)][simArrIndex(y)][simArrIndex(z)] = undefined;
					}
				}
			}
		}
	}

	fn loadNewChunk(self: *User, newPos: Vec3i, newRenderDistance: u16) void {
		const lastBoxStart = (self.lastPos -% @as(Vec3i, @splat(self.lastRenderDistance*chunk.chunkSize))) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const lastBoxEnd = (self.lastPos +% @as(Vec3i, @splat(self.lastRenderDistance*chunk.chunkSize))) +% @as(Vec3i, @splat(chunk.chunkSize - 1)) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const newBoxStart = (newPos -% @as(Vec3i, @splat(newRenderDistance*chunk.chunkSize))) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const newBoxEnd = (newPos +% @as(Vec3i, @splat(newRenderDistance*chunk.chunkSize))) +% @as(Vec3i, @splat(chunk.chunkSize - 1)) & ~@as(Vec3i, @splat(chunk.chunkMask));
		// Clear all chunks not inside the new box:
		var x: i32 = newBoxStart[0];
		while (x != newBoxEnd[0]) : (x +%= chunk.chunkSize) {
			const inXDistance = x -% lastBoxStart[0] >= 0 and x -% lastBoxEnd[0] < 0;
			var y: i32 = newBoxStart[1];
			while (y != newBoxEnd[1]) : (y +%= chunk.chunkSize) {
				const inYDistance = y -% lastBoxStart[1] >= 0 and y -% lastBoxEnd[1] < 0;
				var z: i32 = newBoxStart[2];
				while (z != newBoxEnd[2]) : (z +%= chunk.chunkSize) {
					const inZDistance = z -% lastBoxStart[2] >= 0 and z -% lastBoxEnd[2] < 0;
					if (!inXDistance or !inYDistance or !inZDistance) {
						self.loadedChunks[simArrIndex(x)][simArrIndex(y)][simArrIndex(z)] = world_zig.ChunkManager.getOrGenerateSimulationChunkAndIncreaseRefCount(.{.wx = x, .wy = y, .wz = z, .voxelSize = 1});
					}
				}
			}
		}
	}

	fn loadUnloadChunks(self: *User) void {
		const newPos: Vec3i = @as(Vec3i, @intFromFloat(self.player.pos)) +% @as(Vec3i, @splat(chunk.chunkSize/2)) & ~@as(Vec3i, @splat(chunk.chunkMask));
		const newRenderDistance = main.settings.simulationDistance;
		if (@reduce(.Or, newPos != self.lastPos) or newRenderDistance != self.lastRenderDistance) {
			self.unloadOldChunk(newPos, newRenderDistance);
			self.loadNewChunk(newPos, newRenderDistance);
			self.lastRenderDistance = newRenderDistance;
			self.lastPos = newPos;
		}
	}

	pub fn getTaskFromJobQueue(self: *User) ?struct { main.utils.ThreadPool.Task, enum { hasMoreTasks, empty } } {
		self.mutex.lock();
		defer self.mutex.unlock();
		if (vec.lengthSquare(@as(@Vector(3, i64), self.jobQueueLastUpdate.position -% self.lastPos)) > 32*32) {
			const startTime = main.timestamp();
			if (self.jobQueueLastUpdate.time.durationTo(startTime).toMilliseconds() > 100 and !self.jobQueueLastUpdate.alreadyInUpdate) {
				const ResortTaskTask = struct { // MARK: ResortTaskTask
					const vtable = utils.ThreadPool.VTable{
						.getPriority = &getPriority,
						.isStillNeeded = &isStillNeeded,
						.run = main.meta.castFunctionSelfToAnyopaque(run),
						.clean = main.meta.castFunctionSelfToAnyopaque(clean),
						.taskType = .taskPriorityUpdate,
					};

					pub fn getPriority(_: *anyopaque) f32 {
						return undefined;
					}

					pub fn isStillNeeded(_: *anyopaque) bool {
						return true;
					}

					pub fn run(user: *User) void {
						defer user.decreaseRefCount();

						var newTasks: main.ListUnmanaged(main.utils.ThreadPool.Task) = .initCapacity(main.stackAllocator, user.jobQueue.size);
						defer newTasks.deinit(main.stackAllocator);
						while (user.jobQueue.extractAny()) |_task| {
							var task = _task;
							if (!task.vtable.isStillNeeded(task.self)) {
								task.vtable.clean(task.self);
								continue;
							}
							task.cachedPriority = task.vtable.getPriority(task.self);
							newTasks.append(main.stackAllocator, task);
						}
						user.jobQueue.addMany(newTasks.items);
						user.mutex.lock();
						defer user.mutex.unlock();
						user.jobQueueLastUpdate = .{
							.position = user.lastPos,
							.time = main.timestamp(),
						};
					}

					pub fn clean(user: *User) void {
						user.decreaseRefCount();
					}
				};
				// Create a task to resort tasks:
				self.jobQueueLastUpdate.alreadyInUpdate = true;
				self.increaseRefCount();
				return .{
					.{
						.cachedPriority = undefined,
						.vtable = &ResortTaskTask.vtable,
						.self = self,
					},
					.hasMoreTasks,
				};
			}
		}
		if (self.isNetworkQueueFull()) {
			self.jobQueueScheduled = false;
			return null;
		}
		const task = self.jobQueue.extractMax() orelse {
			self.jobQueueScheduled = false;
			return null;
		};
		if (self.jobQueue.size == 0) {
			self.jobQueueScheduled = false;
			return .{task, .empty};
		} else {
			return .{task, .hasMoreTasks};
		}
	}

	pub fn addTask(self: *User, task: *anyopaque, vtable: *const main.utils.ThreadPool.VTable) void {
		self.mutex.lock();
		defer self.mutex.unlock();
		self.jobQueue.add(.{
			.cachedPriority = vtable.getPriority(task),
			.vtable = vtable,
			.self = task,
		});
	}

	fn isNetworkQueueFull(self: *User) bool {
		return self.conn.secureChannel.super.sendBuffer.buffer.len > 900000;
	}

	fn scheduleJobQueue(self: *User) void {
		main.utils.assertLocked(&self.mutex);
		if (self.jobQueueScheduled) return;
		if (self.jobQueue.size == 0) return;
		if (self.isNetworkQueueFull()) return;
		self.jobQueueScheduled = true;
		main.threadPool.addPlayer(self);
	}

	pub fn update(self: *User) void {
		self.mutex.lock();
		self.scheduleJobQueue();
		const commands = self.inventoryCommands;
		defer commands.deinit(main.globalAllocator);
		self.inventoryCommands = .{};
		self.mutex.unlock();

		for (commands.items) |commandData| {
			defer main.globalAllocator.free(commandData);
			var reader: BinaryReader = .init(commandData);
			main.sync.ServerSide.executeUserCommand(self, &reader) catch |err| {
				if (err == error.InventoryNotFound) {
					main.network.protocols.inventory.sendFailure(self.conn);
				} else {
					std.log.err("Got error while executing user command: {s}. Disconnecting.", .{@errorName(err)});
					std.log.debug("Command data: {any}", .{commandData});
					self.conn.disconnect();
				}
			};
		}

		self.mutex.lock();
		defer self.mutex.unlock();
		var time = @as(i16, @truncate(main.timestamp().toMilliseconds())) -% main.settings.entityLookback;
		time -%= self.timeDifference.difference.load(.monotonic);
		self.interpolation.update(time, self.lastTime);
		self.lastTime = time;

		const saveTime = main.timestamp();
		if (self.lastSaveTime.durationTo(saveTime).toSeconds() > 5) {
			world.?.savePlayer(self) catch |err| {
				std.log.err("Failed to save player {s}: {s}", .{self.name, @errorName(err)});
			};
			self.lastSaveTime = saveTime;
		}

		self.loadUnloadChunks();
	}

	pub fn receiveCommand(self: *User, commandData: []const u8) void {
		self.mutex.lock();
		defer self.mutex.unlock();
		self.inventoryCommands.append(main.globalAllocator, main.globalAllocator.dupe(u8, commandData));
	}

	pub fn receiveData(self: *User, reader: *BinaryReader) !void {
		self.mutex.lock();
		defer self.mutex.unlock();
		const position: [3]f64 = try reader.readVec(Vec3d);
		const velocity: [3]f64 = try reader.readVec(Vec3d);
		const rotation: [3]f32 = try reader.readVec(Vec3f);
		self.player.rot = rotation;
		const time = try reader.readInt(i16);
		self.timeDifference.addDataPoint(time);
		self.interpolation.updatePosition(&position, &velocity, time);
	}

	pub fn sendMessage(self: *User, comptime fmt: []const u8, args: anytype) void {
		const msg = std.fmt.allocPrint(main.stackAllocator.allocator, fmt, args) catch unreachable;
		defer main.stackAllocator.free(msg);
		self.sendRawMessage(msg);
	}
	pub fn sendRawMessage(self: *User, msg: []const u8) void {
		main.network.protocols.chat.send(self.conn, msg);
	}

	pub fn hasPermission(user: *User, permissionPath: []const u8) bool {
		return switch (user.permissions.hasPermission(permissionPath)) {
			.yes => true,
			.no, .neutral => false,
		};
	}
};

pub const updatesPerSec: u32 = 20;
const updateTime: std.Io.Duration = .fromNanoseconds(1000000000/20);

pub var world: ?*ServerWorld = null;
var userMutex: std.Thread.Mutex = .{};
var users: main.List(*User) = undefined;
var userDeinitList: main.utils.ConcurrentQueue(*User) = undefined;
var userConnectList: main.utils.ConcurrentQueue(*User) = undefined;

pub var connectionManager: *ConnectionManager = undefined;

pub var running: std.atomic.Value(bool) = .init(false);
var lastTime: std.Io.Timestamp = undefined;

pub var thread: ?std.Thread = null;

fn init(name: []const u8, singlePlayerPort: ?u16) void { // MARK: init()
	main.heap.allocators.createWorldArena();
	std.debug.assert(world == null); // There can only be one world.
	command.init();
	users = .init(main.globalAllocator);
	userDeinitList = .init(main.globalAllocator, 16);
	userConnectList = .init(main.globalAllocator, 16);
	lastTime = main.timestamp();
	connectionManager = ConnectionManager.init(main.settings.defaultPort, false) catch |err| {
		std.log.err("Couldn't create socket: {s}", .{@errorName(err)});
		@panic("Could not open Server.");
	}; // TODO Configure the second argument in the server settings.

	main.items.Inventory.ServerSide.init();
	main.sync.ServerSide.init();

	world = ServerWorld.init(name) catch |err| {
		std.log.err("Failed to create world: {s}", .{@errorName(err)});
		@panic("Can't create world.");
	};
	world.?.generate() catch |err| {
		std.log.err("Failed to generate world: {s}", .{@errorName(err)});
		@panic("Can't generate world.");
	};
	if (singlePlayerPort) |port| blk: {
		const ipString = std.fmt.allocPrint(main.stackAllocator.allocator, "127.0.0.1:{}", .{port}) catch unreachable;
		defer main.stackAllocator.free(ipString);
		const user = User.initAndIncreaseRefCount(connectionManager, ipString) catch |err| {
			std.log.err("Cannot create singleplayer user {s}", .{@errorName(err)});
			break :blk;
		};
		defer user.decreaseRefCount();
		user.isLocal = true;
		user.permissions.addPermission(.white, "/");
	}
}

fn deinit() void {
	users.clearAndFree();
	while (userDeinitList.popFront()) |user| {
		user.deinit();
	}
	userDeinitList.deinit();
	userConnectList.deinit();
	for (connectionManager.connections.items) |conn| {
		conn.user.?.decreaseRefCount();
	}
	connectionManager.deinit();
	connectionManager = undefined;

	if (world) |_world| {
		_world.deinit();
	}
	world = null;

	main.sync.ServerSide.deinit();
	main.items.Inventory.ServerSide.deinit();

	command.deinit();
	main.heap.allocators.destroyWorldArena();
}

pub fn getUserListAndIncreaseRefCount(allocator: main.heap.NeverFailingAllocator) []*User {
	userMutex.lock();
	defer userMutex.unlock();
	const result = allocator.dupe(*User, users.items);
	for (result) |user| {
		user.increaseRefCount();
	}
	return result;
}

pub fn freeUserListAndDecreaseRefCount(allocator: main.heap.NeverFailingAllocator, list: []*User) void {
	for (list) |user| {
		user.decreaseRefCount();
	}
	allocator.free(list);
}

fn getInitialEntityList(allocator: main.heap.NeverFailingAllocator) []const u8 {
	// Send the entity updates:
	var initialList: []const u8 = undefined;
	const list = main.ZonElement.initArray(main.stackAllocator);
	defer list.deinit(main.stackAllocator);
	list.array.append(.null);
	const itemDropList = world.?.itemDropManager.getInitialList(main.stackAllocator);
	list.array.appendSlice(itemDropList.array.items);
	itemDropList.array.items.len = 0;
	itemDropList.deinit(main.stackAllocator);
	initialList = list.toStringEfficient(allocator, &.{});
	return initialList;
}

fn update() void { // MARK: update()
	world.?.update();

	while (userConnectList.popFront()) |user| {
		connectInternal(user);
		user.decreaseRefCount();
	}

	const userList = getUserListAndIncreaseRefCount(main.stackAllocator);
	defer freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
	for (userList) |user| {
		user.update();
	}

	// Send the entity data:
	const itemData = world.?.itemDropManager.getPositionAndVelocityData(main.stackAllocator);
	defer main.stackAllocator.free(itemData);

	var entityData: main.List(main.entity.EntityNetworkData) = .init(main.stackAllocator);
	defer entityData.deinit();

	for (userList) |user| {
		const id = user.id; // TODO
		entityData.append(.{
			.id = id,
			.pos = user.player.pos,
			.vel = user.player.vel,
			.rot = user.player.rot,
		});
	}
	for (userList) |user| {
		main.network.protocols.entityPosition.send(user.conn, user.player.pos, entityData.items, itemData);
	}

	for (userList) |user| {
		const pos = @as(Vec3i, @intFromFloat(user.player.pos));
		const biomeId = world.?.getBiome(pos[0], pos[1], pos[2]).paletteId;
		if (biomeId != user.lastSentBiomeId) {
			user.lastSentBiomeId = biomeId;
			main.network.protocols.genericUpdate.sendBiome(user.conn, biomeId);
		}
	}

	while (userDeinitList.popFront()) |user| {
		if (user.refCount.load(.monotonic) == 1) {
			user.decreaseRefCount();
		} else {
			userDeinitList.pushBack(user);
			break;
		}
	}
}

pub fn startFromNewThread(name: []const u8, port: ?u16) void {
	main.initThreadLocals();
	defer main.deinitThreadLocals();
	startFromExistingThread(name, port);
}

pub fn startFromExistingThread(name: []const u8, port: ?u16) void {
	std.debug.assert(!running.load(.monotonic)); // There can only be one server.
	init(name, port);
	defer deinit();
	running.store(true, .release);
	while (running.load(.monotonic)) {
		main.heap.GarbageCollection.syncPoint();
		const newTime = main.timestamp();
		if (lastTime.durationTo(newTime).nanoseconds < updateTime.nanoseconds) {
			main.io.sleep(newTime.durationTo(lastTime.addDuration(updateTime)), .awake) catch {};
			lastTime = lastTime.addDuration(updateTime);
		} else {
			std.log.warn("The server is lagging behind by {d:.1} ms", .{@as(f32, @floatFromInt(newTime.nanoseconds -% lastTime.nanoseconds -% updateTime.nanoseconds))/1000000.0});
			lastTime = newTime;
		}
		update();
	}
}

pub fn stop() void {
	running.store(false, .monotonic);
}

pub fn disconnect(user: *User) void { // MARK: disconnect()
	if (!user.connected.load(.monotonic)) return;
	removePlayer(user);
	userDeinitList.pushBack(user);
	user.connected.store(false, .monotonic);
}

pub fn removePlayer(user: *User) void { // MARK: removePlayer()
	if (!user.connected.load(.monotonic)) return;

	const foundUser = blk: {
		userMutex.lock();
		defer userMutex.unlock();
		for (users.items, 0..) |other, i| {
			if (other == user) {
				_ = users.swapRemove(i);
				break :blk true;
			}
		}
		break :blk false;
	};
	if (!foundUser) return;

	sendMessage("{s}§#ffff00 left", .{user.name});
	// Let the other clients know about that this new one left.
	const zonArray = main.ZonElement.initArray(main.stackAllocator);
	defer zonArray.deinit(main.stackAllocator);
	zonArray.array.append(.{.int = user.id});
	const data = zonArray.toStringEfficient(main.stackAllocator, &.{});
	defer main.stackAllocator.free(data);
	const userList = getUserListAndIncreaseRefCount(main.stackAllocator);
	defer freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
	for (userList) |other| {
		main.network.protocols.entity.send(other.conn, data);
	}
}

pub fn connect(user: *User) void {
	user.increaseRefCount();
	userConnectList.pushBack(user);
}

pub fn connectInternal(user: *User) void {
	user.initPlayer();
	main.network.protocols.handShake.sendServerPlayerData(user.conn);
	// TODO: addEntity(player);
	const userList = getUserListAndIncreaseRefCount(main.stackAllocator);
	defer freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
	// Check if a user with that account is already present
	if (!world.?.settings.testingMode) {
		for (userList) |other| {
			if (other.playerIndex == user.playerIndex) {
				user.conn.disconnect();
				return;
			}
		}
	}
	// Let the other clients know about this new one.
	{
		const zonArray = main.ZonElement.initArray(main.stackAllocator);
		defer zonArray.deinit(main.stackAllocator);
		const entityZon = main.ZonElement.initObject(main.stackAllocator);
		entityZon.put("id", user.id);
		entityZon.put("name", user.name);
		zonArray.array.append(entityZon);
		const data = zonArray.toStringEfficient(main.stackAllocator, &.{});
		defer main.stackAllocator.free(data);
		for (userList) |other| {
			main.network.protocols.entity.send(other.conn, data);
		}
	}
	{ // Let this client know about the others:
		const zonArray = main.ZonElement.initArray(main.stackAllocator);
		defer zonArray.deinit(main.stackAllocator);
		for (userList) |other| {
			const entityZon = main.ZonElement.initObject(main.stackAllocator);
			entityZon.put("id", other.id);
			entityZon.put("name", other.name);
			zonArray.array.append(entityZon);
		}
		const data = zonArray.toStringEfficient(main.stackAllocator, &.{});
		defer main.stackAllocator.free(data);
		if (user.connected.load(.monotonic)) main.network.protocols.entity.send(user.conn, data);
	}
	const initialList = getInitialEntityList(main.stackAllocator);
	main.network.protocols.entity.send(user.conn, initialList);
	main.stackAllocator.free(initialList);
	sendMessage("{s}§#ffff00 joined", .{user.name});

	userMutex.lock();
	users.append(user);
	userMutex.unlock();
	user.conn.handShakeState.store(.complete, .monotonic);
}

pub fn messageFrom(msg: []const u8, source: *User) void { // MARK: message
	main.server.sendMessage("[{s}§#ffffff] {s}", .{source.name, msg});
}

fn sendRawMessage(msg: []const u8) void {
	chatMutex.lock();
	defer chatMutex.unlock();
	std.log.info("Chat: {s}", .{msg}); // TODO use color \033[0;32m
	const userList = getUserListAndIncreaseRefCount(main.stackAllocator);
	defer freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
	for (userList) |user| {
		user.sendRawMessage(msg);
	}
}

var chatMutex: std.Thread.Mutex = .{};
pub fn sendMessage(comptime fmt: []const u8, args: anytype) void {
	const msg = std.fmt.allocPrint(main.stackAllocator.allocator, fmt, args) catch unreachable;
	defer main.stackAllocator.free(msg);
	sendRawMessage(msg);
}

```

`src/server/storage.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const chunk = main.chunk;
const server = @import("server.zig");

const utils = main.utils;
const BinaryWriter = utils.BinaryWriter;
const BinaryReader = utils.BinaryReader;

pub const RegionFile = struct { // MARK: RegionFile
	const version = 0;
	pub const regionShift = 2;
	pub const regionSize = 1 << regionShift;
	pub const regionVolume = 1 << 3*regionShift;

	const headerSize = 8 + regionSize*regionSize*regionSize*@sizeOf(u32);

	chunks: [regionVolume][]u8 = @splat(&.{}),
	pos: chunk.ChunkPosition,
	mutex: std.Thread.Mutex = .{},
	modified: bool = false,
	refCount: Atomic(u16) = .init(1),
	storedInHashMap: bool = false,
	saveFolder: []const u8,

	pub fn getIndex(x: usize, y: usize, z: usize) usize {
		std.debug.assert(x < regionSize and y < regionSize and z < regionSize);
		return ((x*regionSize) + y)*regionSize + z;
	}

	pub fn init(pos: chunk.ChunkPosition, saveFolder: []const u8) *RegionFile {
		std.debug.assert(pos.wx & (1 << chunk.chunkShift + regionShift) - 1 == 0);
		std.debug.assert(pos.wy & (1 << chunk.chunkShift + regionShift) - 1 == 0);
		std.debug.assert(pos.wz & (1 << chunk.chunkShift + regionShift) - 1 == 0);
		const self = main.globalAllocator.create(RegionFile);
		self.* = .{
			.pos = pos,
			.saveFolder = main.globalAllocator.dupe(u8, saveFolder),
		};

		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{}/{}/{}/{}.region", .{saveFolder, pos.voxelSize, pos.wx, pos.wy, pos.wz}) catch unreachable;
		defer main.stackAllocator.free(path);
		const data = main.files.cubyzDir().read(main.stackAllocator, path) catch {
			return self;
		};
		defer main.stackAllocator.free(data);
		self.load(path, data) catch {
			std.log.err("Corrupted region file: {s}", .{path});
			if (@errorReturnTrace()) |trace| std.log.info("{f}", .{std.debug.FormatStackTrace{.stack_trace = trace.*, .tty_config = .no_color}});
		};
		return self;
	}

	fn load(self: *RegionFile, path: []const u8, data: []const u8) !void {
		var reader = BinaryReader.init(data);

		const fileVersion = try reader.readInt(u32);
		const fileSize = try reader.readInt(u32);

		if (fileVersion != version) {
			std.log.err("Region file {s} has incorrect version {}. Requires version {}.", .{path, fileVersion, version});
			return error.corrupted;
		}

		var chunkDataLengths: [regionVolume]u32 = undefined;
		var totalSize: usize = 0;
		for (0..regionVolume) |i| {
			const size = try reader.readInt(u32);
			chunkDataLengths[i] = size;
			totalSize += size;
		}

		if (fileSize != reader.remaining.len or totalSize != fileSize) {
			return error.corrupted;
		}

		for (0..regionVolume) |j| {
			const chunkDataLength = chunkDataLengths[j];
			if (chunkDataLength != 0) {
				self.chunks[j] = main.globalAllocator.dupe(u8, try reader.readSlice(chunkDataLength));
			}
		}
		if (reader.remaining.len != 0) {
			return error.corrupted;
		}
	}

	pub fn deinit(self: *RegionFile) void {
		std.debug.assert(self.refCount.raw == 0);
		std.debug.assert(!self.modified);
		for (self.chunks) |ch| {
			main.globalAllocator.free(ch);
		}
		main.globalAllocator.free(self.saveFolder);
		main.globalAllocator.destroy(self);
	}

	pub fn increaseRefCount(self: *RegionFile) void {
		const prevVal = self.refCount.fetchAdd(1, .monotonic);
		std.debug.assert(prevVal != 0);
	}

	pub fn decreaseRefCount(self: *RegionFile) void {
		const prevVal = self.refCount.fetchSub(1, .monotonic);
		std.debug.assert(prevVal != 0);
		if (prevVal == 1) {
			if (self.modified) {
				self.store();
			}
			self.deinit();
		} else if (prevVal == 2) {
			tryHashmapDeinit(self);
		}
	}

	pub fn store(self: *RegionFile) void {
		self.mutex.lock();
		defer self.mutex.unlock();
		self.modified = false;

		var totalSize: usize = 0;
		for (self.chunks) |ch| {
			totalSize += ch.len;
		}
		if (totalSize > std.math.maxInt(u32)) {
			std.log.err("Size of region file {} is too big to be stored", .{self.pos});
			return;
		}

		var writer = BinaryWriter.initCapacity(main.stackAllocator, totalSize + headerSize);
		defer writer.deinit();

		writer.writeInt(u32, version);
		writer.writeInt(u32, @intCast(totalSize));

		for (0..regionVolume) |i| {
			writer.writeInt(u32, @intCast(self.chunks[i].len));
		}
		for (0..regionVolume) |i| {
			writer.writeSlice(self.chunks[i]);
		}
		std.debug.assert(writer.data.items.len == totalSize + headerSize);

		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{}/{}/{}/{}.region", .{self.saveFolder, self.pos.voxelSize, self.pos.wx, self.pos.wy, self.pos.wz}) catch unreachable;
		defer main.stackAllocator.free(path);
		const folder = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{}/{}/{}", .{self.saveFolder, self.pos.voxelSize, self.pos.wx, self.pos.wy}) catch unreachable;
		defer main.stackAllocator.free(folder);

		main.files.cubyzDir().makePath(folder) catch |err| {
			std.log.err("Error while writing to file {s}: {s}", .{path, @errorName(err)});
		};

		main.files.cubyzDir().write(path, writer.data.items) catch |err| {
			std.log.err("Error while writing to file {s}: {s}", .{path, @errorName(err)});
		};
	}

	pub fn storeChunk(self: *RegionFile, ch: []const u8, relX: usize, relY: usize, relZ: usize) void {
		self.mutex.lock();
		defer self.mutex.unlock();
		const index = getIndex(relX, relY, relZ);
		self.chunks[index] = main.globalAllocator.realloc(self.chunks[index], ch.len);
		@memcpy(self.chunks[index], ch);
		if (!self.modified) {
			self.modified = true;
			self.increaseRefCount();
			main.server.world.?.queueRegionFileUpdateAndDecreaseRefCount(self);
		}
	}

	pub fn getChunk(self: *RegionFile, allocator: main.heap.NeverFailingAllocator, relX: usize, relY: usize, relZ: usize) ?[]const u8 {
		self.mutex.lock();
		defer self.mutex.unlock();
		const index = getIndex(relX, relY, relZ);
		const ch = self.chunks[index];
		if (ch.len == 0) return null;
		return allocator.dupe(u8, ch);
	}
};

// MARK: cache
const cacheSize = 1 << 8; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8;
var cache: main.utils.Cache(RegionFile, cacheSize, associativity, cacheDeinit) = .{};
const HashContext = struct {
	pub fn hash(_: HashContext, a: chunk.ChunkPosition) u64 {
		return a.hashCode();
	}
	pub fn eql(_: HashContext, a: chunk.ChunkPosition, b: chunk.ChunkPosition) bool {
		return std.meta.eql(a, b);
	}
};
var stillUsedHashMap: std.HashMap(chunk.ChunkPosition, *RegionFile, HashContext, 50) = undefined;
var hashMapMutex: std.Thread.Mutex = .{};

fn cacheDeinit(region: *RegionFile) void {
	if (region.refCount.load(.monotonic) != 1) { // Someone else might still use it, so we store it in the hashmap.
		hashMapMutex.lock();
		defer hashMapMutex.unlock();
		region.storedInHashMap = true;
		stillUsedHashMap.put(region.pos, region) catch unreachable;
	} else {
		region.decreaseRefCount();
	}
}
fn cacheInit(pos: chunk.ChunkPosition) *RegionFile {
	hashMapMutex.lock();
	if (stillUsedHashMap.fetchRemove(pos)) |kv| {
		const region = kv.value;
		region.storedInHashMap = false;
		hashMapMutex.unlock();
		return region;
	}
	hashMapMutex.unlock();
	const path: []const u8 = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/chunks", .{server.world.?.path}) catch unreachable;
	defer main.stackAllocator.free(path);
	return RegionFile.init(pos, path);
}
fn tryHashmapDeinit(region: *RegionFile) void {
	{
		hashMapMutex.lock();
		defer hashMapMutex.unlock();
		if (!region.storedInHashMap) return;
		std.debug.assert(stillUsedHashMap.fetchRemove(region.pos).?.value == region);
		region.storedInHashMap = false;
	}
	std.debug.assert(region.refCount.load(.monotonic) == 1);
	region.decreaseRefCount();
}

pub fn init() void {
	stillUsedHashMap = .init(main.globalAllocator.allocator);
}

pub fn deinit() void {
	cache.clear();
	stillUsedHashMap.deinit();
}

pub fn loadRegionFileAndIncreaseRefCount(wx: i32, wy: i32, wz: i32, voxelSize: u31) *RegionFile {
	const compare = chunk.ChunkPosition{
		.wx = wx & ~@as(i32, RegionFile.regionSize*voxelSize - 1),
		.wy = wy & ~@as(i32, RegionFile.regionSize*voxelSize - 1),
		.wz = wz & ~@as(i32, RegionFile.regionSize*voxelSize - 1),
		.voxelSize = voxelSize,
	};
	const result = cache.findOrCreate(compare, cacheInit, RegionFile.increaseRefCount);
	return result;
}

pub const ChunkCompression = struct { // MARK: ChunkCompression
	const ChunkCompressionAlgo = enum(u32) {
		deflate_with_position_no_block_entities = 0,
		deflate_no_block_entities = 1,
		uniform = 2,
		deflate_with_8bit_palette_no_block_entities = 3,
		deflate = 4,
		deflate_with_8bit_palette = 5,
	};
	const BlockEntityCompressionAlgo = enum(u8) {
		raw = 0, // TODO: Maybe we need some basic compression at some point. For now this is good enough though.
	};

	const Target = enum { toClient, toDisk };

	pub fn storeChunk(allocator: main.heap.NeverFailingAllocator, ch: *chunk.Chunk, comptime target: Target, allowLossy: bool) []const u8 {
		var writer = BinaryWriter.init(allocator);

		compressBlockData(ch, allowLossy, &writer);
		compressBlockEntityData(ch, target, &writer);

		return writer.data.toOwnedSlice();
	}

	pub fn loadChunk(ch: *chunk.Chunk, comptime side: main.utils.Side, data: []const u8) !void {
		var reader = BinaryReader.init(data);
		try decompressBlockData(ch, &reader);
		try decompressBlockEntityData(ch, side, &reader);
	}

	fn compressBlockData(ch: *chunk.Chunk, allowLossy: bool, writer: *BinaryWriter) void {
		if (ch.data.palette().len == 1) {
			writer.writeEnum(ChunkCompressionAlgo, .uniform);
			writer.writeInt(u32, ch.data.palette()[0].load(.unordered).toInt());
			return;
		}
		if (ch.data.palette().len < 256) {
			var uncompressedData: [chunk.chunkVolume]u8 = undefined;
			var solidMask: [chunk.chunkSize*chunk.chunkSize]u32 = undefined;
			for (0..chunk.chunkVolume) |i| {
				uncompressedData[i] = @intCast(ch.data.impl.raw.data.getValue(i));
				if (allowLossy) {
					const block = ch.data.palette()[uncompressedData[i]].load(.unordered);
					const model = main.blocks.meshes.model(block).model();
					const occluder = model.allNeighborsOccluded and !block.viewThrough();
					if (occluder) {
						solidMask[i >> 5] |= @as(u32, 1) << @intCast(i & 31);
					} else {
						solidMask[i >> 5] &= ~(@as(u32, 1) << @intCast(i & 31));
					}
				}
			}
			if (allowLossy) {
				for (0..32) |x| {
					for (0..32) |y| {
						if (x == 0 or x == 31 or y == 0 or y == 31) {
							continue;
						}
						const index = x*32 + y;
						var colMask = solidMask[index] >> 1 & solidMask[index] << 1 & solidMask[index - 1] & solidMask[index + 1] & solidMask[index - 32] & solidMask[index + 32];
						while (colMask != 0) {
							const z = @ctz(colMask);
							colMask &= ~(@as(u32, 1) << @intCast(z));
							uncompressedData[index*32 + z] = uncompressedData[index*32 + z - 1];
						}
					}
				}
			}
			const compressedData = main.utils.Compression.deflate(main.stackAllocator, &uncompressedData, .default);
			defer main.stackAllocator.free(compressedData);

			writer.writeEnum(ChunkCompressionAlgo, .deflate_with_8bit_palette);
			writer.writeInt(u8, @intCast(ch.data.palette().len));

			for (0..ch.data.palette().len) |i| {
				writer.writeInt(u32, ch.data.palette()[i].load(.unordered).toInt());
			}
			writer.writeVarInt(usize, compressedData.len);
			writer.writeSlice(compressedData);
			return;
		}
		var uncompressedWriter = BinaryWriter.initCapacity(main.stackAllocator, chunk.chunkVolume*@sizeOf(u32));
		defer uncompressedWriter.deinit();

		for (0..chunk.chunkVolume) |i| {
			uncompressedWriter.writeInt(u32, ch.data.getValue(i).toInt());
		}
		const compressedData = main.utils.Compression.deflate(main.stackAllocator, uncompressedWriter.data.items, .default);
		defer main.stackAllocator.free(compressedData);

		writer.writeEnum(ChunkCompressionAlgo, .deflate);
		writer.writeVarInt(usize, compressedData.len);
		writer.writeSlice(compressedData);
	}

	fn decompressBlockData(ch: *chunk.Chunk, reader: *BinaryReader) !void {
		std.debug.assert(ch.data.palette().len == 1);

		const compressionAlgorithm = try reader.readEnum(ChunkCompressionAlgo);

		switch (compressionAlgorithm) {
			.deflate, .deflate_no_block_entities, .deflate_with_position_no_block_entities => {
				if (compressionAlgorithm == .deflate_with_position_no_block_entities) _ = try reader.readSlice(16);
				const decompressedData = main.stackAllocator.alloc(u8, chunk.chunkVolume*@sizeOf(u32));
				defer main.stackAllocator.free(decompressedData);

				const compressedDataLen = if (compressionAlgorithm == .deflate) try reader.readVarInt(usize) else reader.remaining.len;
				const compressedData = try reader.readSlice(compressedDataLen);
				const decompressedLength = try main.utils.Compression.inflateTo(decompressedData, compressedData);
				if (decompressedLength != chunk.chunkVolume*@sizeOf(u32)) return error.corrupted;

				var decompressedReader = BinaryReader.init(decompressedData);

				for (0..chunk.chunkVolume) |i| {
					ch.data.setValue(i, main.blocks.Block.fromInt(try decompressedReader.readInt(u32)));
				}
			},
			.deflate_with_8bit_palette, .deflate_with_8bit_palette_no_block_entities => {
				const paletteLength = try reader.readInt(u8);

				ch.data.deferredDeinit();
				ch.data.initCapacity(paletteLength);

				for (0..paletteLength) |i| {
					ch.data.palette()[i] = .init(main.blocks.Block.fromInt(try reader.readInt(u32)));
				}

				const decompressedData = main.stackAllocator.alloc(u8, chunk.chunkVolume);
				defer main.stackAllocator.free(decompressedData);

				const compressedDataLen = if (compressionAlgorithm == .deflate_with_8bit_palette) try reader.readVarInt(usize) else reader.remaining.len;
				const compressedData = try reader.readSlice(compressedDataLen);

				const decompressedLength = try main.utils.Compression.inflateTo(decompressedData, compressedData);
				if (decompressedLength != chunk.chunkVolume) return error.corrupted;

				for (0..chunk.chunkVolume) |i| {
					ch.data.setRawValue(i, decompressedData[i]);
				}
			},
			.uniform => {
				ch.data.palette()[0] = .init(main.blocks.Block.fromInt(try reader.readInt(u32)));
			},
		}
	}

	pub fn compressBlockEntityData(ch: *chunk.Chunk, comptime target: Target, writer: *BinaryWriter) void {
		ch.blockPosToEntityDataMapMutex.lock();
		defer ch.blockPosToEntityDataMapMutex.unlock();

		if (ch.blockPosToEntityDataMap.count() == 0) return;

		writer.writeEnum(BlockEntityCompressionAlgo, .raw);

		var iterator = ch.blockPosToEntityDataMap.iterator();
		while (iterator.next()) |entry| {
			const pos = entry.key_ptr.*;
			const blockEntityIndex = entry.value_ptr.*;
			const block = ch.data.getValue(pos.toIndex());
			const blockEntity = block.blockEntity() orelse continue;

			var tempWriter = BinaryWriter.init(main.stackAllocator);
			defer tempWriter.deinit();

			if (target == .toDisk) {
				blockEntity.onStoreServerToDisk(blockEntityIndex, &tempWriter);
			} else {
				blockEntity.onStoreServerToClient(blockEntityIndex, &tempWriter);
			}

			if (tempWriter.data.items.len == 0) continue;

			writer.writeInt(u15, pos.toIndex());
			writer.writeVarInt(usize, tempWriter.data.items.len);
			writer.writeSlice(tempWriter.data.items);
		}
	}

	pub fn decompressBlockEntityData(ch: *chunk.Chunk, comptime side: main.utils.Side, reader: *BinaryReader) !void {
		if (reader.remaining.len == 0) return;

		const compressionAlgo = try reader.readEnum(BlockEntityCompressionAlgo);
		std.debug.assert(compressionAlgo == .raw);

		while (reader.remaining.len != 0) {
			const pos: chunk.BlockPos = .fromIndex(try reader.readInt(u15));
			const globalPos = ch.localToGlobalPosition(pos);
			const dataLength = try reader.readVarInt(usize);

			const blockEntityData = try reader.readSlice(dataLength);
			const block = ch.data.getValue(pos.toIndex());
			const blockEntity = block.blockEntity() orelse {
				std.log.err("Could not load BlockEntity at position {} for block {s}: Block has no block entity", .{globalPos, block.id()});
				continue;
			};

			var tempReader = BinaryReader.init(blockEntityData);
			if (side == .server) {
				blockEntity.onLoadServer(globalPos, ch, &tempReader) catch |err| {
					std.log.err("Could not load BlockEntity at position {} for block {s}: {s}", .{globalPos, block.id(), @errorName(err)});
					continue;
				};
			} else {
				try blockEntity.onLoadClient(globalPos, ch, &tempReader);
			}
		}
	}
};

```

`src/server/terrain/CaveBiomeMap.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array3D = main.utils.Array3D;
const Cache = main.utils.Cache;
const ServerChunk = main.chunk.ServerChunk;
const ChunkPosition = main.chunk.ChunkPosition;
const ZonElement = main.ZonElement;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const terrain = @import("terrain.zig");
const GeneratorState = terrain.GeneratorState;
const TerrainGenerationProfile = terrain.TerrainGenerationProfile;
const MapFragment = terrain.SurfaceMap.MapFragment;
const Biome = terrain.biomes.Biome;
const SurfaceMap = terrain.SurfaceMap;

/// Cave biome data from a big chunk of the world.
pub const CaveBiomeMapFragment = struct { // MARK: caveBiomeMapFragment
	pub const caveBiomeShift = 7;
	pub const caveBiomeSize = 1 << caveBiomeShift;
	pub const caveBiomeMask = caveBiomeSize - 1;
	pub const caveBiomeMapShift = 11;
	pub const caveBiomeMapSize = 1 << caveBiomeMapShift;
	pub const caveBiomeMapMask = caveBiomeMapSize - 1;

	pos: main.chunk.ChunkPosition,
	biomeMap: [1 << 3*(caveBiomeMapShift - caveBiomeShift)][2]*const Biome = undefined,

	pub fn init(self: *CaveBiomeMapFragment, wx: i32, wy: i32, wz: i32) void {
		self.* = .{
			.pos = main.chunk.ChunkPosition{
				.wx = wx,
				.wy = wy,
				.wz = wz,
				.voxelSize = caveBiomeSize,
			},
		};
	}

	fn privateDeinit(self: *CaveBiomeMapFragment) void {
		memoryPool.destroy(self);
	}

	pub fn deferredDeinit(self: *CaveBiomeMapFragment) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	const rotationMatrixShift = 30;
	const fac: comptime_int = @intFromFloat(@as(comptime_float, 1 << rotationMatrixShift)/25.0);
	const rotationMatrix = .{
		@Vector(3, i64){20*fac, 0*fac, 15*fac},
		@Vector(3, i64){9*fac, 20*fac, -12*fac},
		@Vector(3, i64){-12*fac, 15*fac, 16*fac},
	}; // divide result by shift to do a proper rotation

	const transposeRotationMatrix = .{
		@Vector(3, i64){20*fac, 9*fac, -12*fac},
		@Vector(3, i64){0*fac, 20*fac, 15*fac},
		@Vector(3, i64){15*fac, -12*fac, 16*fac},
	}; // divide result by shift to do a proper rotation

	pub fn rotate(in: Vec3i) Vec3i {
		return @truncate(@Vector(3, i64){
			vec.dot(rotationMatrix[0], in) >> rotationMatrixShift,
			vec.dot(rotationMatrix[1], in) >> rotationMatrixShift,
			vec.dot(rotationMatrix[2], in) >> rotationMatrixShift,
		});
	}

	pub fn rotateInverse(in: Vec3i) Vec3i {
		return @truncate(@Vector(3, i64){
			vec.dot(transposeRotationMatrix[0], in) >> rotationMatrixShift,
			vec.dot(transposeRotationMatrix[1], in) >> rotationMatrixShift,
			vec.dot(transposeRotationMatrix[2], in) >> rotationMatrixShift,
		});
	}

	pub fn getIndex(_relX: u31, _relY: u31, _relZ: u31) usize {
		var relX: usize = _relX;
		var relY: usize = _relY;
		var relZ: usize = _relZ;
		std.debug.assert(relX < caveBiomeMapSize);
		std.debug.assert(relY < caveBiomeMapSize);
		std.debug.assert(relZ < caveBiomeMapSize);
		relX >>= caveBiomeShift;
		relY >>= caveBiomeShift;
		relZ >>= caveBiomeShift;
		return relX << 2*(caveBiomeMapShift - caveBiomeShift) | relY << caveBiomeMapShift - caveBiomeShift | relZ;
	}
};

/// A generator for the cave biome map.
pub const CaveBiomeGenerator = struct { // MARK: CaveBiomeGenerator
	init: *const fn (parameters: ZonElement) void,
	generate: *const fn (map: *CaveBiomeMapFragment, seed: u64) void,
	/// Used to prioritize certain generators over others.
	priority: i32,
	/// To avoid duplicate seeds in similar generation algorithms, the SurfaceGenerator xors the world-seed with the generator specific seed.
	generatorSeed: u64,
	defaultState: GeneratorState,

	var generatorRegistry: std.StringHashMapUnmanaged(CaveBiomeGenerator) = .{};

	pub fn registerGenerator(comptime Generator: type) void {
		const self = CaveBiomeGenerator{
			.init = &Generator.init,
			.generate = &Generator.generate,
			.priority = Generator.priority,
			.generatorSeed = Generator.generatorSeed,
			.defaultState = Generator.defaultState,
		};
		generatorRegistry.put(main.globalAllocator.allocator, Generator.id, self) catch unreachable;
	}

	pub fn getAndInitGenerators(allocator: NeverFailingAllocator, settings: ZonElement) []CaveBiomeGenerator {
		var list: main.ListUnmanaged(CaveBiomeGenerator) = .initCapacity(allocator, generatorRegistry.size);
		var iterator = generatorRegistry.iterator();
		while (iterator.next()) |generatorEntry| {
			const generator = generatorEntry.value_ptr.*;
			const generatorSettings = settings.getChild(generatorEntry.key_ptr.*);
			if (generatorSettings.get(GeneratorState, "state", generator.defaultState) == .disabled) continue;
			generator.init(generatorSettings);
			list.appendAssumeCapacity(generator);
		}
		const lessThan = struct {
			fn lessThan(_: void, lhs: CaveBiomeGenerator, rhs: CaveBiomeGenerator) bool {
				return lhs.priority < rhs.priority;
			}
		}.lessThan;
		std.sort.insertion(CaveBiomeGenerator, list.items, {}, lessThan);
		return list.toOwnedSlice(allocator);
	}
};

/// Doesn't allow getting the biome at one point and instead is only useful for interpolating values between biomes.
pub const InterpolatableCaveBiomeMapView = struct { // MARK: InterpolatableCaveBiomeMapView
	fragments: Array3D(*CaveBiomeMapFragment),
	surfaceFragments: [4]*MapFragment,
	pos: ChunkPosition,
	width: i32,
	allocator: NeverFailingAllocator,

	pub fn init(allocator: main.heap.NeverFailingAllocator, pos: ChunkPosition, width: u31, margin: u31) InterpolatableCaveBiomeMapView {
		const center = Vec3i{
			pos.wx +% width/2,
			pos.wy +% width/2,
			pos.wz +% width/2,
		};
		const rotatedCenter = CaveBiomeMapFragment.rotate(center);
		const marginDiv = 1024;
		const marginMul: comptime_int = @reduce(.Max, @abs(comptime CaveBiomeMapFragment.rotate(.{marginDiv, marginDiv, marginDiv})));
		const caveBiomeFragmentWidth = 1 + (width + margin + CaveBiomeMapFragment.caveBiomeMapSize)*marginMul/marginDiv/CaveBiomeMapFragment.caveBiomeMapSize;
		var result = InterpolatableCaveBiomeMapView{
			.fragments = Array3D(*CaveBiomeMapFragment).init(allocator, caveBiomeFragmentWidth, caveBiomeFragmentWidth, caveBiomeFragmentWidth),
			.surfaceFragments = [_]*MapFragment{
				SurfaceMap.getOrGenerateFragment(center[0] -% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, center[1] -% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, pos.voxelSize),
				SurfaceMap.getOrGenerateFragment(center[0] -% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, center[1] +% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, pos.voxelSize),
				SurfaceMap.getOrGenerateFragment(center[0] +% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, center[1] -% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, pos.voxelSize),
				SurfaceMap.getOrGenerateFragment(center[0] +% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, center[1] +% SurfaceMap.MapFragment.mapSize/2*pos.voxelSize, pos.voxelSize),
			},
			.pos = pos,
			.width = width,
			.allocator = allocator,
		};
		const startX = rotatedCenter[0] -% CaveBiomeMapFragment.caveBiomeMapSize/2*(caveBiomeFragmentWidth - 1);
		const startY = rotatedCenter[1] -% CaveBiomeMapFragment.caveBiomeMapSize/2*(caveBiomeFragmentWidth - 1);
		const startZ = rotatedCenter[2] -% CaveBiomeMapFragment.caveBiomeMapSize/2*(caveBiomeFragmentWidth - 1);
		for (0..caveBiomeFragmentWidth) |x| {
			for (0..caveBiomeFragmentWidth) |y| {
				for (0..caveBiomeFragmentWidth) |z| {
					result.fragments.set(x, y, z, getOrGenerateFragment(
						startX +% CaveBiomeMapFragment.caveBiomeMapSize*@as(i32, @intCast(x)),
						startY +% CaveBiomeMapFragment.caveBiomeMapSize*@as(i32, @intCast(y)),
						startZ +% CaveBiomeMapFragment.caveBiomeMapSize*@as(i32, @intCast(z)),
					));
				}
			}
		}
		return result;
	}

	pub fn deinit(self: InterpolatableCaveBiomeMapView) void {
		self.fragments.deinit(self.allocator);
	}

	fn rotate231(in: Vec3i) Vec3i {
		return @shuffle(i32, in, undefined, Vec3i{1, 2, 0});
	}
	fn rotate312(in: Vec3i) Vec3i {
		return @shuffle(i32, in, undefined, Vec3i{2, 0, 1});
	}
	fn argMaxDistance0(distance: Vec3i) u2 {
		const absDistance = @abs(distance);
		if (absDistance[0] > absDistance[1]) {
			if (absDistance[0] > absDistance[2]) {
				return 0;
			} else {
				return 2;
			}
		} else {
			if (absDistance[1] > absDistance[2]) {
				return 1;
			} else {
				return 2;
			}
		}
	}
	fn argMaxDistance1(distance: Vec3i) u2 {
		const absDistance = @abs(distance);
		if (absDistance[0] >= absDistance[1]) {
			if (absDistance[0] >= absDistance[2]) {
				return 0;
			} else {
				return 2;
			}
		} else {
			if (absDistance[1] >= absDistance[2]) {
				return 1;
			} else {
				return 2;
			}
		}
	}
	fn vectorElement(val: Vec3i, i: u2) i32 {
		return switch (i) {
			0 => val[0],
			1 => val[1],
			2 => val[2],
			else => unreachable,
		};
	}
	fn indexToBool(i: u2) @Vector(3, bool) {
		return switch (i) {
			0 => .{true, false, false},
			1 => .{false, true, false},
			2 => .{false, false, true},
			else => unreachable,
		};
	}

	/// Return either +1 or -1 depending on the sign of the input number.
	fn nonZeroSign(in: Vec3i) Vec3i {
		return @select(i32, in >= Vec3i{0, 0, 0}, Vec3i{1, 1, 1}, Vec3i{-1, -1, -1});
	}

	pub fn bulkInterpolateValue(self: InterpolatableCaveBiomeMapView, comptime field: []const u8, wx: i32, wy: i32, wz: i32, voxelSize: u31, map: Array3D(f32), comptime mode: enum { addToMap }, comptime scale: f32) void {
		var x: u31 = 0;
		while (x < map.width) : (x += 1) {
			var y: u31 = 0;
			while (y < map.height) : (y += 1) {
				var z: u31 = 0;
				while (z < map.depth) : (z += 1) {
					switch (mode) {
						.addToMap => {
							// TODO: Do a tetrahedron voxelization here, so parts of the tetrahedral barycentric coordinates can be precomputed.
							map.ptr(x, y, z).* += scale*interpolateValue(self, wx +% x*voxelSize, wy +% y*voxelSize, wz +% z*voxelSize, field);
						},
					}
				}
			}
		}
	}

	pub noinline fn interpolateValue(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32, wz: i32, comptime field: []const u8) f32 {
		const worldPos = CaveBiomeMapFragment.rotate(.{wx, wy, wz});
		const closestGridpoint0 = (worldPos +% @as(Vec3i, @splat(CaveBiomeMapFragment.caveBiomeSize/2))) & @as(Vec3i, @splat(~@as(i32, CaveBiomeMapFragment.caveBiomeMask)));
		const distance0 = worldPos -% closestGridpoint0;
		const coordinate0 = argMaxDistance0(distance0);
		const step0 = @select(i32, indexToBool(coordinate0), @as(Vec3i, @splat(CaveBiomeMapFragment.caveBiomeSize)), @as(Vec3i, @splat(0)));
		const secondGridPoint0 = closestGridpoint0 +% step0*nonZeroSign(distance0);

		const closestGridpoint1 = (worldPos & @as(Vec3i, @splat(~@as(i32, CaveBiomeMapFragment.caveBiomeMask)))) +% @as(Vec3i, @splat(CaveBiomeMapFragment.caveBiomeSize/2));
		const distance1 = worldPos -% closestGridpoint1;
		const coordinate1 = argMaxDistance1(distance1);
		const step1 = @select(i32, indexToBool(coordinate1), @as(Vec3i, @splat(CaveBiomeMapFragment.caveBiomeSize)), @as(Vec3i, @splat(0)));
		const secondGridPoint1 = closestGridpoint1 +% step1*nonZeroSign(distance1);

		const coordinateFinal = 3 ^ coordinate0 ^ coordinate1;
		const interpFinal = @abs(0.5 + @as(f32, @floatFromInt(vectorElement(distance0, coordinateFinal))))*2/CaveBiomeMapFragment.caveBiomeSize;

		const interp0 = 0.5 + (@abs(@as(f32, @floatFromInt(vectorElement(distance0, coordinate0))))/CaveBiomeMapFragment.caveBiomeSize - 0.5)/(1 - interpFinal);
		const interp1 = 0.5 + (@abs(@as(f32, @floatFromInt(vectorElement(distance1, coordinate1))))/CaveBiomeMapFragment.caveBiomeSize - 0.5)/interpFinal;

		const biome00 = self._getBiome(closestGridpoint0[0], closestGridpoint0[1], closestGridpoint0[2], 0);
		const biome01 = self._getBiome(secondGridPoint0[0], secondGridPoint0[1], secondGridPoint0[2], 0);
		const biome10 = self._getBiome(closestGridpoint1[0], closestGridpoint1[1], closestGridpoint1[2], 1);
		const biome11 = self._getBiome(secondGridPoint1[0], secondGridPoint1[1], secondGridPoint1[2], 1);
		const val0 = @field(biome00, field)*(1 - interp0) + @field(biome01, field)*interp0;
		const val1 = @field(biome10, field)*(1 - interp1) + @field(biome11, field)*interp1;
		return val0*(1 - interpFinal) + val1*interpFinal;
	}

	/// On failure returnHeight contains the lower border of the terrain height.
	fn checkSurfaceBiomeWithHeight(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32, wz: i32, returnHeight: *i32) ?*const Biome {
		var index: u8 = 0;
		if (wx -% self.surfaceFragments[0].pos.wx >= MapFragment.mapSize*self.pos.voxelSize) {
			index += 2;
		}
		if (wy -% self.surfaceFragments[0].pos.wy >= MapFragment.mapSize*self.pos.voxelSize) {
			index += 1;
		}
		const height: i32 = self.surfaceFragments[index].getHeight(wx, wy);
		if (wz < height - 32*self.pos.voxelSize or wz >= height + 128 + self.pos.voxelSize) {
			const len = height - 32*self.pos.voxelSize -% wz;
			if (len > 0) returnHeight.* = @min(returnHeight.*, len);
			return null;
		}
		returnHeight.* = height + 128 + self.pos.voxelSize - wz;
		return self.surfaceFragments[index].getBiome(wx, wy);
	}

	fn checkSurfaceBiome(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32, wz: i32) ?*const Biome {
		var index: u8 = 0;
		if (wx -% self.surfaceFragments[0].pos.wx >= MapFragment.mapSize*self.pos.voxelSize) {
			index += 2;
		}
		if (wy -% self.surfaceFragments[0].pos.wy >= MapFragment.mapSize*self.pos.voxelSize) {
			index += 1;
		}
		const height: i32 = self.surfaceFragments[index].getHeight(wx, wy);
		if (wz < height - 32*self.pos.voxelSize or wz > height + 128 + self.pos.voxelSize) return null;
		return self.surfaceFragments[index].getBiome(wx, wy);
	}

	pub fn getSurfaceHeight(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32) i32 {
		var index: u8 = 0;
		if (wx -% self.surfaceFragments[0].pos.wx >= MapFragment.mapSize*self.pos.voxelSize) {
			index += 2;
		}
		if (wy -% self.surfaceFragments[0].pos.wy >= MapFragment.mapSize*self.pos.voxelSize) {
			index += 1;
		}
		return self.surfaceFragments[index].getHeight(wx, wy);
	}

	noinline fn _getBiome(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32, wz: i32, map: u1) *const Biome {
		const indexX: usize = @intCast((wx -% self.fragments.mem[0].pos.wx) >> CaveBiomeMapFragment.caveBiomeMapShift);
		const indexY: usize = @intCast((wy -% self.fragments.mem[0].pos.wy) >> CaveBiomeMapFragment.caveBiomeMapShift);
		const indexZ: usize = @intCast((wz -% self.fragments.mem[0].pos.wz) >> CaveBiomeMapFragment.caveBiomeMapShift);
		const frag = self.fragments.get(indexX, indexY, indexZ);
		const relX: u31 = @intCast(wx - frag.pos.wx);
		const relY: u31 = @intCast(wy - frag.pos.wy);
		const relZ: u31 = @intCast(wz - frag.pos.wz);
		const indexInArray = CaveBiomeMapFragment.getIndex(relX, relY, relZ);
		return frag.biomeMap[indexInArray][map];
	}

	fn getGridPointFromPrerotated(rotatedPos: Vec3i, map: *u1) Vec3i {
		var gridPoint = rotatedPos +% @as(Vec3i, @splat(CaveBiomeMapFragment.caveBiomeSize/2)) & @as(Vec3i, @splat(~@as(i32, CaveBiomeMapFragment.caveBiomeMask)));

		const distance = rotatedPos -% gridPoint;
		const totalDistance = @reduce(.Add, @abs(distance));
		if (totalDistance > CaveBiomeMapFragment.caveBiomeSize*3/4) {
			// Or with 1 to prevent errors if the value is 0.
			gridPoint +%= std.math.sign(distance)*@as(Vec3i, @splat(CaveBiomeMapFragment.caveBiomeSize/2));
			map.* = 1;
		} else {
			map.* = 0;
		}
		return gridPoint;
	}

	fn getGridPoint(pos: Vec3i, map: *u1) Vec3i {
		const rotatedPos = CaveBiomeMapFragment.rotate(pos);
		return getGridPointFromPrerotated(rotatedPos, map);
	}

	fn getGridPointAndHeight(pos: Vec3i, map: *u1, returnHeight: *i32, voxelSize: u31) Vec3i {
		const preRotatedPos = @Vector(3, i64){
			vec.dot(CaveBiomeMapFragment.rotationMatrix[0], pos),
			vec.dot(CaveBiomeMapFragment.rotationMatrix[1], pos),
			vec.dot(CaveBiomeMapFragment.rotationMatrix[2], pos),
		};
		var startMap: u1 = undefined;
		const gridPoint = getGridPointFromPrerotated(@truncate(preRotatedPos >> @splat(CaveBiomeMapFragment.rotationMatrixShift)), &startMap);

		var start: i32 = 0;
		var end = @min(returnHeight.*, @as(comptime_int, @intFromFloat(@ceil(CaveBiomeMapFragment.caveBiomeSize*@sqrt(5.0)/2.0)))) & ~@as(i32, voxelSize - 1);
		{
			var otherMap: u1 = undefined;
			const nextGridPoint = getGridPointFromPrerotated(@truncate(preRotatedPos +% CaveBiomeMapFragment.transposeRotationMatrix[2]*@as(Vec3i, @splat(end)) >> @splat(CaveBiomeMapFragment.rotationMatrixShift)), &otherMap);
			if (@reduce(.And, nextGridPoint == gridPoint) and otherMap == startMap) start = end;
		}
		while (start + voxelSize < end) {
			const mid = start +% @divTrunc(end -% start, 2) & ~@as(i32, voxelSize - 1);
			var otherMap: u1 = undefined;
			const nextGridPoint = getGridPointFromPrerotated(@truncate(preRotatedPos +% CaveBiomeMapFragment.transposeRotationMatrix[2]*@as(Vec3i, @splat(mid)) >> @splat(CaveBiomeMapFragment.rotationMatrixShift)), &otherMap);
			if (@reduce(.Or, nextGridPoint != gridPoint) or otherMap != startMap) {
				end = mid;
			} else {
				start = mid;
			}
		}
		returnHeight.* = end;
		map.* = startMap;
		return gridPoint;
	}

	/// Useful when the rough biome location is enough, for example for music.
	pub noinline fn getRoughBiome(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32, wz: i32, comptime getSeed: bool, seed: *u64, comptime _checkSurfaceBiome: bool) *const Biome {
		if (_checkSurfaceBiome) {
			if (self.checkSurfaceBiome(wx, wy, wz)) |surfaceBiome| {
				return surfaceBiome;
			}
		}
		var map: u1 = undefined;
		const gridPoint = getGridPoint(.{wx, wy, wz}, &map);

		if (getSeed) {
			// A good old "I don't know what I'm doing" hash (TODO: Use some standard hash maybe):
			seed.* = @as(u64, @bitCast(@as(i64, gridPoint[0]) << 48 ^ @as(i64, gridPoint[1]) << 23 ^ @as(i64, gridPoint[2]) << 11 ^ @as(i64, gridPoint[0]) >> 5 ^ @as(i64, gridPoint[1]) << 3 ^ @as(i64, gridPoint[2]) ^ @as(i64, map)*5427642781)) ^ main.server.world.?.settings.seed;
		}

		return self._getBiome(gridPoint[0], gridPoint[1], gridPoint[2], map);
	}

	/// returnHeight should contain an upper estimate for the biome size.
	fn getRoughBiomeAndHeight(self: InterpolatableCaveBiomeMapView, wx: i32, wy: i32, wz: i32, comptime getSeed: bool, seed: *u64, comptime _checkSurfaceBiome: bool, returnHeight: *i32) *const Biome {
		if (_checkSurfaceBiome) {
			if (self.checkSurfaceBiome(wx, wy, wz)) |surfaceBiome| {
				return surfaceBiome;
			}
		}
		var map: u1 = undefined;
		const gridPoint = getGridPointAndHeight(.{wx, wy, wz}, &map, returnHeight, self.pos.voxelSize);

		if (getSeed) {
			// A good old "I don't know what I'm doing" hash (TODO: Use some standard hash maybe):
			seed.* = @as(u64, @bitCast(@as(i64, gridPoint[0]) << 48 ^ @as(i64, gridPoint[1]) << 23 ^ @as(i64, gridPoint[2]) << 11 ^ @as(i64, gridPoint[0]) >> 5 ^ @as(i64, gridPoint[1]) << 3 ^ @as(i64, gridPoint[2]) ^ @as(i64, map)*5427642781)) ^ main.server.world.?.settings.seed;
		}

		return self._getBiome(gridPoint[0], gridPoint[1], gridPoint[2], map);
	}
};

pub const CaveBiomeMapView = struct { // MARK: CaveBiomeMapView
	const CachedFractalNoise = terrain.noise.CachedFractalNoise;

	super: InterpolatableCaveBiomeMapView,
	noise: ?CachedFractalNoise = null,

	pub fn init(allocator: NeverFailingAllocator, pos: ChunkPosition, width: u31, margin: u31) CaveBiomeMapView {
		var self = CaveBiomeMapView{
			.super = InterpolatableCaveBiomeMapView.init(allocator, pos, width, margin),
		};
		if (pos.voxelSize < 8) {
			const startX = (pos.wx -% margin) & ~@as(i32, 63);
			const startY = (pos.wy -% margin) & ~@as(i32, 63);
			self.noise = CachedFractalNoise.init(startX, startY, pos.voxelSize, width + 64 + 2*margin, main.server.world.?.settings.seed ^ 0x764923684396, 64);
		}
		return self;
	}

	pub fn deinit(self: CaveBiomeMapView) void {
		self.super.deinit();
		if (self.noise) |noise| {
			noise.deinit();
		}
	}

	pub fn getSurfaceHeight(self: CaveBiomeMapView, wx: i32, wy: i32) i32 {
		return self.super.getSurfaceHeight(wx, wy);
	}

	pub fn getBiome(self: CaveBiomeMapView, relX: i32, relY: i32, relZ: i32) *const Biome {
		return self.getBiomeAndSeed(relX, relY, relZ, false, undefined);
	}

	/// Also returns a seed that is unique for the corresponding biome position.
	pub noinline fn getBiomeAndSeed(self: CaveBiomeMapView, relX: i32, relY: i32, relZ: i32, comptime getSeed: bool, seed: *u64) *const Biome {
		std.debug.assert(relX >= -32 and relX < self.super.width + 32); // coordinate out of bounds
		std.debug.assert(relY >= -32 and relY < self.super.width + 32); // coordinate out of bounds
		std.debug.assert(relZ >= -32 and relZ < self.super.width + 32); // coordinate out of bounds
		const wx = relX +% self.super.pos.wx;
		const wy = relY +% self.super.pos.wy;
		var wz = relZ +% self.super.pos.wz;
		if (self.super.checkSurfaceBiome(wx, wy, wz)) |surfaceBiome| {
			return surfaceBiome;
		}
		if (self.noise) |noise| {
			const value = noise.getValue(wx, wy);
			wz +%= @intFromFloat(value);
		}

		return self.super.getRoughBiome(wx, wy, wz, getSeed, seed, false);
	}

	/// Also returns a seed that is unique for the corresponding biome position.
	/// returnHeight should contain an upper estimate for the biome size.
	pub noinline fn getBiomeColumnAndSeed(self: CaveBiomeMapView, relX: i32, relY: i32, relZ: i32, comptime getSeed: bool, seed: *u64, returnHeight: *i32) *const Biome {
		std.debug.assert(relX >= -32 and relX < self.super.width + 32); // coordinate out of bounds
		std.debug.assert(relY >= -32 and relY < self.super.width + 32); // coordinate out of bounds
		std.debug.assert(relZ >= -32 and relZ < self.super.width + 32); // coordinate out of bounds
		const wx = relX +% self.super.pos.wx;
		const wy = relY +% self.super.pos.wy;
		var wz = relZ +% self.super.pos.wz;
		if (self.super.checkSurfaceBiomeWithHeight(wx, wy, wz, returnHeight)) |surfaceBiome| {
			return surfaceBiome;
		}
		if (self.noise) |noise| {
			const value = noise.getValue(wx, wy);
			wz +%= @intFromFloat(value);
		}

		return self.super.getRoughBiomeAndHeight(wx, wy, wz, getSeed, seed, false, returnHeight);
	}
};

// MARK: cache
const cacheSize = 1 << 8; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8; // 128 MiB
var cache: Cache(CaveBiomeMapFragment, cacheSize, associativity, CaveBiomeMapFragment.deferredDeinit) = .{};

var profile: TerrainGenerationProfile = undefined;

var memoryPool: main.heap.MemoryPool(CaveBiomeMapFragment) = undefined;

pub fn globalInit() void {
	const list = @import("cavebiomegen/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		CaveBiomeGenerator.registerGenerator(@field(list, decl.name));
	}
	memoryPool = .init(main.globalAllocator);
}

pub fn globalDeinit() void {
	CaveBiomeGenerator.generatorRegistry.clearAndFree(main.globalAllocator.allocator);
	memoryPool.deinit();
}

pub fn init(_profile: TerrainGenerationProfile) void {
	profile = _profile;
}

pub fn deinit() void {
	cache.clear();
}

fn cacheInit(pos: ChunkPosition) *CaveBiomeMapFragment {
	const mapFragment = memoryPool.create();
	mapFragment.init(pos.wx, pos.wy, pos.wz);
	for (profile.caveBiomeGenerators) |generator| {
		generator.generate(mapFragment, profile.seed ^ generator.generatorSeed);
	}
	return mapFragment;
}

fn getOrGenerateFragment(_wx: i32, _wy: i32, _wz: i32) *CaveBiomeMapFragment {
	const wx = _wx & ~@as(i32, CaveBiomeMapFragment.caveBiomeMapMask);
	const wy = _wy & ~@as(i32, CaveBiomeMapFragment.caveBiomeMapMask);
	const wz = _wz & ~@as(i32, CaveBiomeMapFragment.caveBiomeMapMask);
	const compare = ChunkPosition{
		.wx = wx,
		.wy = wy,
		.wz = wz,
		.voxelSize = CaveBiomeMapFragment.caveBiomeSize,
	};
	const result = cache.findOrCreate(compare, cacheInit, null);
	return result;
}

```

`src/server/terrain/CaveMap.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const ServerChunk = main.chunk.ServerChunk;
const ChunkPosition = main.chunk.ChunkPosition;
const Cache = main.utils.Cache;
const ZonElement = main.ZonElement;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const Vec3i = main.vec.Vec3i;

const terrain = @import("terrain.zig");
const GeneratorState = terrain.GeneratorState;
const TerrainGenerationProfile = terrain.TerrainGenerationProfile;

/// Cave data represented in a 1-Bit per block format, where 0 means empty and 1 means not empty.
pub const CaveMapFragment = struct { // MARK: CaveMapFragment
	pub const width = 1 << 6;
	pub const widthMask = width - 1;
	pub const height = 64; // Size of u64
	pub const heightMask = height - 1;

	data: [width*width]u64 = undefined,
	pos: ChunkPosition,
	voxelShift: u5,

	pub fn init(self: *CaveMapFragment, wx: i32, wy: i32, wz: i32, voxelSize: u31) void {
		self.* = .{
			.pos = .{
				.wx = wx,
				.wy = wy,
				.wz = wz,
				.voxelSize = voxelSize,
			},
			.voxelShift = @ctz(voxelSize),
		};
		@memset(&self.data, std.math.maxInt(u64));
	}

	fn privateDeinit(self: *CaveMapFragment) void {
		memoryPool.destroy(self);
	}

	pub fn deferredDeinit(self: *CaveMapFragment) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	fn getIndex(x: i32, y: i32) usize {
		std.debug.assert(x >= 0 and x < width and y >= 0 and y < width); // Coordinates out of range.
		return @intCast(x*width + y);
	}

	/// for example 3,11 would create the mask ...111_11111100_00000011
	/// start inclusive
	/// end exclusive
	fn getMask(start: i32, end: i32) u64 {
		const maskLower = if (start <= 0) (0) else if (start >= 64) (std.math.maxInt(u64)) else (@as(u64, std.math.maxInt(u64)) >> @intCast(64 - start));
		const maskUpper = if (end <= 0) (std.math.maxInt(u64)) else if (end >= 64) (0) else (@as(u64, std.math.maxInt(u64)) << @intCast(end));
		return maskLower | maskUpper;
	}

	pub fn addRange(self: *CaveMapFragment, _relX: i32, _relY: i32, _start: i32, _end: i32) void {
		const relX = _relX >> self.voxelShift;
		const relY = _relY >> self.voxelShift;
		const start = _start >> self.voxelShift;
		const end = _end >> self.voxelShift;
		self.data[getIndex(relX, relY)] |= ~getMask(start, end);
	}

	pub fn removeRange(self: *CaveMapFragment, _relX: i32, _relY: i32, _start: i32, _end: i32) void {
		const relX = _relX >> self.voxelShift;
		const relY = _relY >> self.voxelShift;
		const start = _start >> self.voxelShift;
		const end = _end >> self.voxelShift;
		self.data[getIndex(relX, relY)] &= getMask(start, end);
	}

	pub fn getColumnData(self: *CaveMapFragment, _relX: i32, _relY: i32) u64 {
		const relX = _relX >> self.voxelShift;
		const relY = _relY >> self.voxelShift;
		return self.data[getIndex(relX, relY)];
	}
};

/// A generator for the cave map.
pub const CaveGenerator = struct { // MARK: CaveGenerator
	init: *const fn (parameters: ZonElement) void,
	generate: *const fn (map: *CaveMapFragment, seed: u64) void,
	/// Used to prioritize certain generators over others.
	priority: i32,
	/// To avoid duplicate seeds in similar generation algorithms, the SurfaceGenerator xors the world-seed with the generator specific seed.
	generatorSeed: u64,
	defaultState: GeneratorState,

	var generatorRegistry: std.StringHashMapUnmanaged(CaveGenerator) = .{};

	pub fn registerGenerator(comptime Generator: type) void {
		const self = CaveGenerator{
			.init = &Generator.init,
			.generate = &Generator.generate,
			.priority = Generator.priority,
			.generatorSeed = Generator.generatorSeed,
			.defaultState = Generator.defaultState,
		};
		generatorRegistry.put(main.globalAllocator.allocator, Generator.id, self) catch unreachable;
	}

	pub fn getAndInitGenerators(allocator: NeverFailingAllocator, settings: ZonElement) []CaveGenerator {
		var list: main.ListUnmanaged(CaveGenerator) = .initCapacity(allocator, generatorRegistry.size);
		var iterator = generatorRegistry.iterator();
		while (iterator.next()) |generatorEntry| {
			const generator = generatorEntry.value_ptr.*;
			const generatorSettings = settings.getChild(generatorEntry.key_ptr.*);
			if (generatorSettings.get(GeneratorState, "state", generator.defaultState) == .disabled) continue;
			generator.init(generatorSettings);
			list.appendAssumeCapacity(generator);
		}
		const lessThan = struct {
			fn lessThan(_: void, lhs: CaveGenerator, rhs: CaveGenerator) bool {
				return lhs.priority < rhs.priority;
			}
		}.lessThan;
		std.sort.insertion(CaveGenerator, list.items, {}, lessThan);
		return list.toOwnedSlice(allocator);
	}
};

pub const CaveMapView = struct { // MARK: CaveMapView
	pos: ChunkPosition,
	lowerCorner: Vec3i,
	widthShift: u5,
	heightShift: u5,
	fragments: main.utils.Array3D(*CaveMapFragment),

	pub fn init(allocator: NeverFailingAllocator, pos: ChunkPosition, size: u31, margin: u31) CaveMapView {
		const widthShift = std.math.log2_int(u31, pos.voxelSize*CaveMapFragment.width);
		const heightShift = std.math.log2_int(u31, pos.voxelSize*CaveMapFragment.height);
		const widthMask = ~@as(i32, (@as(u31, 1) << widthShift) - 1);
		const heightMask = ~@as(i32, (@as(u31, 1) << heightShift) - 1);
		const lowerCorner = Vec3i{
			(pos.wx -% margin) & widthMask,
			(pos.wy -% margin) & widthMask,
			(pos.wz -% margin) & heightMask,
		};
		const higherCorner = Vec3i{
			(pos.wx +% margin +% size) & widthMask,
			(pos.wy +% margin +% size) & widthMask,
			(pos.wz +% margin +% size) & heightMask,
		};
		const result = CaveMapView{
			.pos = pos,
			.lowerCorner = lowerCorner,
			.widthShift = widthShift,
			.heightShift = heightShift,
			.fragments = .init(
				allocator,
				@intCast((higherCorner[0] -% lowerCorner[0] >> widthShift) + 1),
				@intCast((higherCorner[1] -% lowerCorner[1] >> widthShift) + 1),
				@intCast((higherCorner[2] -% lowerCorner[2] >> heightShift) + 1),
			),
		};
		var wx = lowerCorner[0];
		while (wx -% higherCorner[0] <= 0) : (wx += @as(u31, 1) << widthShift) {
			var wy = lowerCorner[1];
			while (wy -% higherCorner[1] <= 0) : (wy += @as(u31, 1) << widthShift) {
				var wz = lowerCorner[2];
				while (wz -% higherCorner[2] <= 0) : (wz += @as(u31, 1) << heightShift) {
					const x: usize = @intCast((wx -% lowerCorner[0]) >> widthShift);
					const y: usize = @intCast((wy -% lowerCorner[1]) >> widthShift);
					const z: usize = @intCast((wz -% lowerCorner[2]) >> heightShift);
					result.fragments.ptr(x, y, z).* = getOrGenerateFragment(wx, wy, wz, pos.voxelSize);
				}
			}
		}
		return result;
	}

	pub fn deinit(self: CaveMapView, allocator: NeverFailingAllocator) void {
		self.fragments.deinit(allocator);
	}

	pub fn isSolid(self: CaveMapView, relX: i32, relY: i32, relZ: i32) bool {
		const wx = relX +% self.pos.wx;
		const wy = relY +% self.pos.wy;
		const wz = relZ +% self.pos.wz;
		const x: usize = @intCast((wx -% self.lowerCorner[0]) >> self.widthShift);
		const y: usize = @intCast((wy -% self.lowerCorner[1]) >> self.widthShift);
		const z: usize = @intCast((wz -% self.lowerCorner[2]) >> self.heightShift);
		const fragment = self.fragments.get(x, y, z);

		const fragmentRelX = wx - fragment.pos.wx;
		const fragmentRelY = wy - fragment.pos.wy;
		const fragmentRelZ = @divFloor(wz - fragment.pos.wz, self.pos.voxelSize);
		const height = fragment.getColumnData(fragmentRelX, fragmentRelY);
		return (height & @as(u64, 1) << @intCast(fragmentRelZ)) != 0;
	}

	pub fn getHeightData(self: CaveMapView, relX: i32, relY: i32) u32 {
		const wx = relX +% self.pos.wx;
		const wy = relY +% self.pos.wy;
		const wz = self.pos.wz;
		const x: usize = @intCast((wx -% self.lowerCorner[0]) >> self.widthShift);
		const y: usize = @intCast((wy -% self.lowerCorner[1]) >> self.widthShift);
		const z: usize = @intCast((wz -% self.lowerCorner[2]) >> self.heightShift);
		const fragment = self.fragments.get(x, y, z);

		const deltaZ = self.pos.wz -% fragment.pos.wz;
		const fragmentRelX = wx - fragment.pos.wx;
		const fragmentRelY = wy - fragment.pos.wy;
		const height = fragment.getColumnData(fragmentRelX, fragmentRelY);
		if (deltaZ == 0) {
			return @truncate(height);
		} else {
			return @intCast(height >> 32);
		}
	}

	pub fn findTerrainChangeAbove(self: CaveMapView, relX: i32, relY: i32, relZ: i32) i32 {
		const wx = relX +% self.pos.wx;
		const wy = relY +% self.pos.wy;
		const wz = relZ +% self.pos.wz;
		const x: usize = @intCast((wx -% self.lowerCorner[0]) >> self.widthShift);
		const y: usize = @intCast((wy -% self.lowerCorner[1]) >> self.widthShift);
		const z: usize = @intCast((wz -% self.lowerCorner[2]) >> self.heightShift);
		const fragment = self.fragments.get(x, y, z);

		const relativeZ = @divFloor(wz -% fragment.pos.wz, self.pos.voxelSize);
		std.debug.assert(relativeZ >= 0 and relativeZ < CaveMapFragment.height);
		const fragmentRelX = wx - fragment.pos.wx;
		const fragmentRelY = wy - fragment.pos.wy;
		var height: u64 = fragment.getColumnData(fragmentRelX, fragmentRelY) >> @intCast(relativeZ);
		const startFilled = (height & 1) != 0;
		if (relativeZ != 0 and z + 1 < self.fragments.height) {
			height |= self.fragments.get(x, y, z + 1).getColumnData(fragmentRelX, fragmentRelY) << @intCast(CaveMapFragment.height - relativeZ);
		}
		if (startFilled) {
			height = ~height;
		}
		const result: i32 = relativeZ + @ctz(height);
		return result*self.pos.voxelSize +% fragment.pos.wz -% self.pos.wz;
	}

	pub fn findTerrainChangeBelow(self: CaveMapView, relX: i32, relY: i32, relZ: i32) i32 {
		const wx = relX +% self.pos.wx;
		const wy = relY +% self.pos.wy;
		const wz = relZ +% self.pos.wz;
		const x: usize = @intCast((wx -% self.lowerCorner[0]) >> self.widthShift);
		const y: usize = @intCast((wy -% self.lowerCorner[1]) >> self.widthShift);
		const z: usize = @intCast((wz -% self.lowerCorner[2]) >> self.heightShift);
		const fragment = self.fragments.get(x, y, z);

		const relativeZ = @divFloor(wz -% fragment.pos.wz, self.pos.voxelSize);
		std.debug.assert(relativeZ >= 0 and relativeZ < CaveMapFragment.height);
		const fragmentRelX = wx - fragment.pos.wx;
		const fragmentRelY = wy - fragment.pos.wy;
		var height: u64 = fragment.getColumnData(fragmentRelX, fragmentRelY) << (CaveMapFragment.height - 1 - @as(u6, @intCast(relativeZ)));
		const startFilled = height & 1 << 63 != 0;
		if (relativeZ != CaveMapFragment.height - 1 and z != 0) {
			height |= self.fragments.get(x, y, z - 1).getColumnData(fragmentRelX, fragmentRelY) >> @as(u6, @intCast(relativeZ + 1));
		}
		if (startFilled) {
			height = ~height;
		}
		const result: i32 = relativeZ - @clz(height);
		return result*self.pos.voxelSize +% fragment.pos.wz -% self.pos.wz;
	}
};

// MARK: cache
const cacheSize = 1 << 12; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8; // 1024 MiB Cache size
var cache: Cache(CaveMapFragment, cacheSize, associativity, CaveMapFragment.deferredDeinit) = .{};
var profile: TerrainGenerationProfile = undefined;

var memoryPool: main.heap.MemoryPool(CaveMapFragment) = undefined;

fn cacheInit(pos: ChunkPosition) *CaveMapFragment {
	const mapFragment = memoryPool.create();
	mapFragment.init(pos.wx, pos.wy, pos.wz, pos.voxelSize);
	for (profile.caveGenerators) |generator| {
		generator.generate(mapFragment, profile.seed ^ generator.generatorSeed);
	}
	return mapFragment;
}

pub fn globalInit() void {
	const list = @import("cavegen/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		CaveGenerator.registerGenerator(@field(list, decl.name));
	}
	memoryPool = .init(main.globalAllocator);
}

pub fn globalDeinit() void {
	CaveGenerator.generatorRegistry.clearAndFree(main.globalAllocator.allocator);
	memoryPool.deinit();
}

pub fn init(_profile: TerrainGenerationProfile) void {
	profile = _profile;
}

pub fn deinit() void {
	cache.clear();
}

fn getOrGenerateFragment(wx: i32, wy: i32, wz: i32, voxelSize: u31) *CaveMapFragment {
	const compare = ChunkPosition{
		.wx = wx & ~@as(i32, CaveMapFragment.widthMask*voxelSize | voxelSize - 1),
		.wy = wy & ~@as(i32, CaveMapFragment.widthMask*voxelSize | voxelSize - 1),
		.wz = wz & ~@as(i32, CaveMapFragment.heightMask*voxelSize | voxelSize - 1),
		.voxelSize = voxelSize,
	};
	const result = cache.findOrCreate(compare, cacheInit, null);
	return result;
}

```

`src/server/terrain/ClimateMap.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const Array2D = main.utils.Array2D;
const Cache = main.utils.Cache;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const TerrainGenerationProfile = terrain.TerrainGenerationProfile;
const Biome = terrain.biomes.Biome;
const MapFragment = terrain.SurfaceMap.MapFragment;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const BiomeSample = struct {
	biome: *const Biome,
	height: f32,
	roughness: f32,
	hills: f32,
	mountains: f32,
	seed: u64,
};

const ClimateMapFragmentPosition = struct {
	wx: i32,
	wy: i32,

	pub fn equals(self: ClimateMapFragmentPosition, other: anytype) bool {
		if (@TypeOf(other) == ?*ClimateMapFragment) {
			if (other) |ch| {
				return self.wx == ch.pos.wx and self.wy == ch.pos.wy;
			}
			return false;
		} else @compileError("Unsupported");
	}

	pub fn hashCode(self: ClimateMapFragmentPosition) u32 {
		return @bitCast((self.wx >> ClimateMapFragment.mapShift)*%33 +% (self.wy >> ClimateMapFragment.mapShift));
	}
};

pub const ClimateMapFragment = struct {
	pub const mapShift = 8 + MapFragment.biomeShift;
	pub const mapSize = 1 << mapShift;
	pub const mapMask: i32 = mapSize - 1;

	pub const mapEntrysSize = mapSize >> MapFragment.biomeShift;

	pos: ClimateMapFragmentPosition,
	map: [mapEntrysSize][mapEntrysSize]BiomeSample = undefined,

	pub fn init(self: *ClimateMapFragment, wx: i32, wy: i32) void {
		self.* = .{
			.pos = .{.wx = wx, .wy = wy},
		};
	}

	fn privateDeinit(self: *ClimateMapFragment) void {
		memoryPool.destroy(self);
	}

	pub fn deferredDeinit(self: *ClimateMapFragment) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	pub fn hashCode(wx: i32, wy: i32) u32 {
		return @bitCast((wx >> mapShift)*%33 + (wy >> mapShift));
	}
};

/// Generates the climate(aka Biome) map, which is a rough representation of the world.
pub const ClimateMapGenerator = struct {
	init: *const fn (parameters: ZonElement) void,
	generateMapFragment: *const fn (fragment: *ClimateMapFragment, seed: u64) void,

	var generatorRegistry: std.StringHashMapUnmanaged(ClimateMapGenerator) = .{};

	pub fn registerGenerator(comptime Generator: type) void {
		const self = ClimateMapGenerator{
			.init = &Generator.init,
			.generateMapFragment = &Generator.generateMapFragment,
		};
		generatorRegistry.put(main.globalAllocator.allocator, Generator.id, self) catch unreachable;
	}

	pub fn getGeneratorById(id: []const u8) !ClimateMapGenerator {
		return generatorRegistry.get(id) orelse {
			std.log.err("Couldn't find climate map generator with id {s}", .{id});
			return error.UnknownClimateMapGenerator;
		};
	}
};

const cacheSize = 1 << 5; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8; // ~400 MiB
var cache: Cache(ClimateMapFragment, cacheSize, associativity, ClimateMapFragment.deferredDeinit) = .{};
var profile: TerrainGenerationProfile = undefined;

var memoryPool: main.heap.MemoryPool(ClimateMapFragment) = undefined;

pub fn globalInit() void {
	const list = @import("climategen/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		ClimateMapGenerator.registerGenerator(@field(list, decl.name));
	}
	memoryPool = .init(main.globalAllocator);
}

pub fn globalDeinit() void {
	ClimateMapGenerator.generatorRegistry.clearAndFree(main.globalAllocator.allocator);
	memoryPool.deinit();
}

fn cacheInit(pos: ClimateMapFragmentPosition) *ClimateMapFragment {
	const mapFragment = memoryPool.create();
	mapFragment.init(pos.wx, pos.wy);
	profile.climateGenerator.generateMapFragment(mapFragment, profile.seed);
	return mapFragment;
}

pub fn init(_profile: TerrainGenerationProfile) void {
	profile = _profile;
}

pub fn deinit() void {
	cache.clear();
}

pub fn getOrGenerateFragment(wx: i32, wy: i32) *ClimateMapFragment {
	const compare = ClimateMapFragmentPosition{.wx = wx, .wy = wy};
	const result = cache.findOrCreate(compare, cacheInit, null);
	return result;
}

pub fn getBiomeMap(allocator: NeverFailingAllocator, wx: i32, wy: i32, width: u31, height: u31) Array2D(BiomeSample) {
	const map = Array2D(BiomeSample).init(allocator, width >> MapFragment.biomeShift, height >> MapFragment.biomeShift);
	const wxStart = wx & ~ClimateMapFragment.mapMask;
	const wzStart = wy & ~ClimateMapFragment.mapMask;
	const wxEnd = wx +% width & ~ClimateMapFragment.mapMask;
	const wzEnd = wy +% height & ~ClimateMapFragment.mapMask;
	var x = wxStart;
	while (wxEnd -% x >= 0) : (x +%= ClimateMapFragment.mapSize) {
		var y = wzStart;
		while (wzEnd -% y >= 0) : (y +%= ClimateMapFragment.mapSize) {
			const mapPiece = getOrGenerateFragment(x, y);
			// Offset of the indices in the result map:
			const xOffset = (x -% wx) >> MapFragment.biomeShift;
			const yOffset = (y -% wy) >> MapFragment.biomeShift;
			// Go through all indices in the mapPiece:
			for (&mapPiece.map, 0..) |*col, lx| {
				const resultX = @as(i32, @intCast(lx)) + xOffset;
				if (resultX < 0 or resultX >= width >> MapFragment.biomeShift) continue;
				for (col, 0..) |*spot, ly| {
					const resultY = @as(i32, @intCast(ly)) + yOffset;
					if (resultY < 0 or resultY >= height >> MapFragment.biomeShift) continue;
					map.set(@intCast(resultX), @intCast(resultY), spot.*);
				}
			}
		}
	}
	return map;
}

```

`src/server/terrain/LightMap.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const Chunk = main.chunk.Chunk;
const ChunkPosition = main.chunk.ChunkPosition;
const Cache = main.utils.Cache;

const terrain = @import("terrain.zig");
const TerrainGenerationProfile = terrain.TerrainGenerationProfile;
pub const MapFragmentPosition = terrain.SurfaceMap.MapFragmentPosition;
const Biome = terrain.biomes.Biome;

/// Generates and stores the light start position for each block column.
pub const LightMapFragment = struct {
	pub const mapShift = 8;
	pub const mapSize = 1 << mapShift;
	pub const mapMask = mapSize - 1;

	startHeight: [mapSize*mapSize]i16 = undefined,
	pos: MapFragmentPosition,

	pub fn init(self: *LightMapFragment, wx: i32, wy: i32, voxelSize: u31) void {
		self.* = .{
			.pos = MapFragmentPosition.init(wx, wy, voxelSize),
		};
	}

	fn privateDeinit(self: *const LightMapFragment) void {
		main.globalAllocator.destroy(self);
	}

	pub fn deferredDeinit(self: *LightMapFragment) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	pub fn getHeight(self: *LightMapFragment, wx: i32, wy: i32) i32 {
		const xIndex = wx >> self.pos.voxelSizeShift & mapMask;
		const yIndex = wy >> self.pos.voxelSizeShift & mapMask;
		return self.startHeight[@as(usize, @intCast(xIndex)) << mapShift | @as(usize, @intCast(yIndex))];
	}
};

const cacheSize = 1 << 6; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8; // 64MiB MiB Cache size
var cache: Cache(LightMapFragment, cacheSize, associativity, LightMapFragment.deferredDeinit) = .{};

fn cacheInit(pos: MapFragmentPosition) *LightMapFragment {
	const mapFragment = main.globalAllocator.create(LightMapFragment);
	mapFragment.init(pos.wx, pos.wy, pos.voxelSize);
	const surfaceMap = terrain.SurfaceMap.getOrGenerateFragment(pos.wx, pos.wy, pos.voxelSize);
	comptime std.debug.assert(LightMapFragment.mapSize == terrain.SurfaceMap.MapFragment.mapSize);
	for (0..LightMapFragment.mapSize) |x| {
		for (0..LightMapFragment.mapSize) |y| {
			const baseHeight: i16 = std.math.lossyCast(i16, surfaceMap.heightMap[x][y]);
			mapFragment.startHeight[x << LightMapFragment.mapShift | y] = @max(0, baseHeight +| 16); // Simple heuristic. TODO: Update this value once chunks get generated in the region.
		}
	}
	return mapFragment;
}

pub fn deinit() void {
	cache.clear();
}

pub fn getOrGenerateFragment(wx: i32, wy: i32, voxelSize: u31) *LightMapFragment {
	const compare = MapFragmentPosition.init(
		wx & ~@as(i32, LightMapFragment.mapMask*voxelSize | voxelSize - 1),
		wy & ~@as(i32, LightMapFragment.mapMask*voxelSize | voxelSize - 1),
		voxelSize,
	);
	const result = cache.findOrCreate(compare, cacheInit, null);
	return result;
}

```

`src/server/terrain/StructureMap.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const ServerChunk = main.chunk.ServerChunk;
const ChunkPosition = main.chunk.ChunkPosition;
const Cache = main.utils.Cache;
const ZonElement = main.ZonElement;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const vec = main.vec;
const Vec3i = vec.Vec3i;

const terrain = @import("terrain.zig");
const GeneratorState = terrain.GeneratorState;
const TerrainGenerationProfile = terrain.TerrainGenerationProfile;

const StructureInternal = struct {
	generateFn: *const fn (self: *const anyopaque, chunk: *ServerChunk, caveMap: terrain.CaveMap.CaveMapView, biomeMap: terrain.CaveBiomeMap.CaveBiomeMapView) void,
	data: *const anyopaque,

	pub fn generate(self: StructureInternal, chunk: *ServerChunk, caveMap: terrain.CaveMap.CaveMapView, biomeMap: terrain.CaveBiomeMap.CaveBiomeMapView) void {
		self.generateFn(self.data, chunk, caveMap, biomeMap);
	}
};

pub const Structure = struct {
	internal: StructureInternal,
	priority: f32,

	fn lessThan(_: void, lhs: Structure, rhs: Structure) bool {
		return lhs.priority < rhs.priority;
	}
};

pub const StructureMapFragment = struct {
	pub const size = 1 << 7;
	pub const sizeMask = size - 1;
	pub const chunkedSize = size >> main.chunk.chunkShift;

	data: [chunkedSize*chunkedSize*chunkedSize][]StructureInternal = undefined,

	pos: ChunkPosition,
	voxelShift: u5,
	arena: main.heap.NeverFailingArenaAllocator,
	allocator: main.heap.NeverFailingAllocator,

	tempData: struct {
		lists: *[chunkedSize*chunkedSize*chunkedSize]main.ListUnmanaged(Structure),
		allocator: NeverFailingAllocator,
	},

	pub fn init(self: *StructureMapFragment, tempAllocator: NeverFailingAllocator, wx: i32, wy: i32, wz: i32, voxelSize: u31) void {
		self.* = .{
			.pos = .{
				.wx = wx,
				.wy = wy,
				.wz = wz,
				.voxelSize = voxelSize,
			},
			.voxelShift = @ctz(voxelSize),
			.arena = .init(main.globalAllocator),
			.allocator = self.arena.allocator(),
			.tempData = .{
				.lists = tempAllocator.create([chunkedSize*chunkedSize*chunkedSize]main.ListUnmanaged(Structure)),
				.allocator = tempAllocator,
			},
		};
		@memset(self.tempData.lists, .{});
	}

	fn privateDeinit(self: *StructureMapFragment) void {
		self.arena.deinit();
		memoryPool.destroy(self);
	}

	pub fn deferredDeinit(self: *StructureMapFragment) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	fn finishGeneration(self: *StructureMapFragment) void {
		for (0..self.data.len) |i| {
			std.sort.insertion(Structure, self.tempData.lists[i].items, {}, Structure.lessThan);
			self.data[i] = self.allocator.alloc(StructureInternal, self.tempData.lists[i].items.len);
			for (0..self.tempData.lists[i].items.len) |j| {
				self.data[i][j] = self.tempData.lists[i].items[j].internal;
			}
			self.tempData.lists[i].deinit(self.tempData.allocator);
			self.tempData.lists[i] = undefined;
		}
		self.tempData.allocator.destroy(self.tempData.lists);
		self.tempData = undefined;
		self.arena.shrinkAndFree();
	}

	fn getIndex(self: *const StructureMapFragment, x: i32, y: i32, z: i32) usize {
		std.debug.assert(x >= 0 and x < size*self.pos.voxelSize and y >= 0 and y < size*self.pos.voxelSize and z >= 0 and z < size*self.pos.voxelSize); // Coordinates out of range.
		return @intCast(((x >> main.chunk.chunkShift + self.voxelShift)*chunkedSize + (y >> main.chunk.chunkShift + self.voxelShift))*chunkedSize + (z >> main.chunk.chunkShift + self.voxelShift));
	}

	pub fn generateStructuresInChunk(self: *const StructureMapFragment, chunk: *ServerChunk, caveMap: terrain.CaveMap.CaveMapView, biomeMap: terrain.CaveBiomeMap.CaveBiomeMapView) void {
		const index = self.getIndex(chunk.super.pos.wx - self.pos.wx, chunk.super.pos.wy - self.pos.wy, chunk.super.pos.wz - self.pos.wz);
		for (self.data[index]) |structure| {
			structure.generate(chunk, caveMap, biomeMap);
		}
	}

	pub fn addStructure(self: *StructureMapFragment, structure: Structure, min: Vec3i, max: Vec3i) void {
		var x = min[0] & ~@as(i32, main.chunk.chunkMask << self.voxelShift | self.pos.voxelSize - 1);
		while (x < max[0]) : (x += main.chunk.chunkSize << self.voxelShift) {
			if (x < 0 or x >= size*self.pos.voxelSize) continue;
			var y = min[1] & ~@as(i32, main.chunk.chunkMask << self.voxelShift | self.pos.voxelSize - 1);
			while (y < max[1]) : (y += main.chunk.chunkSize << self.voxelShift) {
				if (y < 0 or y >= size*self.pos.voxelSize) continue;
				var z = min[2] & ~@as(i32, main.chunk.chunkMask << self.voxelShift | self.pos.voxelSize - 1);
				while (z < max[2]) : (z += main.chunk.chunkSize << self.voxelShift) {
					if (z < 0 or z >= size*self.pos.voxelSize) continue;
					self.tempData.lists[self.getIndex(x, y, z)].append(self.tempData.allocator, structure);
				}
			}
		}
	}
};

/// A generator for the cave map.
pub const StructureMapGenerator = struct {
	init: *const fn (parameters: ZonElement) void,
	generate: *const fn (map: *StructureMapFragment, seed: u64) void,
	/// Used to prioritize certain generators over others.
	priority: i32,
	/// To avoid duplicate seeds in similar generation algorithms, the SurfaceGenerator xors the world-seed with the generator specific seed.
	generatorSeed: u64,
	defaultState: GeneratorState,

	var generatorRegistry: std.StringHashMapUnmanaged(StructureMapGenerator) = .{};

	pub fn registerGenerator(comptime Generator: type) void {
		const self = StructureMapGenerator{
			.init = &Generator.init,
			.generate = &Generator.generate,
			.priority = Generator.priority,
			.generatorSeed = Generator.generatorSeed,
			.defaultState = Generator.defaultState,
		};
		generatorRegistry.put(main.globalAllocator.allocator, Generator.id, self) catch unreachable;
	}

	pub fn getAndInitGenerators(allocator: NeverFailingAllocator, settings: ZonElement) []StructureMapGenerator {
		var list: main.ListUnmanaged(StructureMapGenerator) = .initCapacity(allocator, generatorRegistry.size);
		var iterator = generatorRegistry.iterator();
		while (iterator.next()) |generatorEntry| {
			const generator = generatorEntry.value_ptr.*;
			const generatorSettings = settings.getChild(generatorEntry.key_ptr.*);
			if (generatorSettings.get(GeneratorState, "state", generator.defaultState) == .disabled) continue;
			generator.init(generatorSettings);
			list.appendAssumeCapacity(generator);
		}
		const lessThan = struct {
			fn lessThan(_: void, lhs: StructureMapGenerator, rhs: StructureMapGenerator) bool {
				return lhs.priority < rhs.priority;
			}
		}.lessThan;
		std.sort.insertion(StructureMapGenerator, list.items, {}, lessThan);
		return list.toOwnedSlice(allocator);
	}
};

const cacheSize = 1 << 10; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8;
var cache: Cache(StructureMapFragment, cacheSize, associativity, StructureMapFragment.deferredDeinit) = .{};
var profile: TerrainGenerationProfile = undefined;

var memoryPool: main.heap.MemoryPool(StructureMapFragment) = undefined;

fn cacheInit(pos: ChunkPosition) *StructureMapFragment {
	const mapFragment = memoryPool.create();
	mapFragment.init(main.stackAllocator, pos.wx, pos.wy, pos.wz, pos.voxelSize);
	for (profile.structureMapGenerators) |generator| {
		generator.generate(mapFragment, profile.seed ^ generator.generatorSeed);
	}
	mapFragment.finishGeneration();
	return mapFragment;
}

pub fn globalInit() void {
	const list = @import("structuremapgen/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		StructureMapGenerator.registerGenerator(@field(list, decl.name));
	}
	memoryPool = .init(main.globalAllocator);
}

pub fn globalDeinit() void {
	StructureMapGenerator.generatorRegistry.clearAndFree(main.globalAllocator.allocator);
	memoryPool.deinit();
}

pub fn init(_profile: TerrainGenerationProfile) void {
	profile = _profile;
}

pub fn deinit() void {
	cache.clear();
}

pub fn getOrGenerateFragment(wx: i32, wy: i32, wz: i32, voxelSize: u31) *StructureMapFragment {
	const compare = ChunkPosition{
		.wx = wx & ~@as(i32, StructureMapFragment.sizeMask*voxelSize | voxelSize - 1),
		.wy = wy & ~@as(i32, StructureMapFragment.sizeMask*voxelSize | voxelSize - 1),
		.wz = wz & ~@as(i32, StructureMapFragment.sizeMask*voxelSize | voxelSize - 1),
		.voxelSize = voxelSize,
	};
	const result = cache.findOrCreate(compare, cacheInit, null);
	return result;
}

```

`src/server/terrain/SurfaceMap.zig`:

```zig
const std = @import("std");
const Atomic = std.atomic.Value;

const main = @import("main");
const Chunk = main.chunk.Chunk;
const ChunkPosition = main.chunk.ChunkPosition;
const Cache = main.utils.Cache;
const ZonElement = main.ZonElement;
const Vec3d = main.vec.Vec3d;
const BinaryWriter = main.utils.BinaryWriter;
const BinaryReader = main.utils.BinaryReader;

const terrain = @import("terrain.zig");
const TerrainGenerationProfile = terrain.TerrainGenerationProfile;
const Biome = terrain.biomes.Biome;

pub const MapFragmentPosition = struct {
	wx: i32,
	wy: i32,
	voxelSize: u31,
	voxelSizeShift: u5,

	pub fn init(wx: i32, wy: i32, voxelSize: u31) MapFragmentPosition {
		std.debug.assert(voxelSize - 1 & voxelSize == 0); // voxelSize must be a power of 2.
		std.debug.assert(wx & voxelSize - 1 == 0 and wy & voxelSize - 1 == 0); // The coordinates are misaligned. They need to be aligned to the voxelSize grid.
		return MapFragmentPosition{
			.wx = wx,
			.wy = wy,
			.voxelSize = voxelSize,
			.voxelSizeShift = @ctz(voxelSize),
		};
	}

	pub fn equals(self: MapFragmentPosition, other: anytype) bool {
		if (other) |ch| {
			return self.wx == ch.pos.wx and self.wy == ch.pos.wy and self.voxelSize == ch.pos.voxelSize;
		}
		return false;
	}

	pub fn hashCode(self: MapFragmentPosition) u32 {
		return @bitCast((self.wx >> (MapFragment.mapShift + self.voxelSizeShift))*%33 +% (self.wy >> (MapFragment.mapShift + self.voxelSizeShift)) ^ self.voxelSize);
	}

	pub fn getMinDistanceSquared(self: MapFragmentPosition, playerPosition: Vec3d, comptime width: comptime_int) f64 {
		const adjustedPosition = @mod(playerPosition + @as(Vec3d, @splat(1 << 31)), @as(Vec3d, @splat(1 << 32))) - @as(Vec3d, @splat(1 << 31));
		const halfWidth: f64 = @floatFromInt(self.voxelSize*@divExact(width, 2));
		var dx = @abs(@as(f64, @floatFromInt(self.wx)) + halfWidth - adjustedPosition[0]);
		var dy = @abs(@as(f64, @floatFromInt(self.wy)) + halfWidth - adjustedPosition[1]);
		dx = @max(0, dx - halfWidth);
		dy = @max(0, dy - halfWidth);
		return dx*dx + dy*dy;
	}

	pub fn getPriority(self: MapFragmentPosition, playerPos: Vec3d, comptime width: comptime_int) f32 {
		return -@as(f32, @floatCast(self.getMinDistanceSquared(playerPos, width)))/@as(f32, @floatFromInt(self.voxelSize*self.voxelSize)) + 2*@as(f32, @floatFromInt(std.math.log2_int(u31, self.voxelSize)))*width*width;
	}
};

/// Generates and stores the height and Biome maps of the planet.
pub const MapFragment = struct { // MARK: MapFragment
	pub const biomeShift = 5;
	/// The average diameter of a biome.
	pub const biomeSize = 1 << biomeShift;
	pub const mapShift = 8;
	pub const mapSize = 1 << mapShift;
	pub const mapMask = mapSize - 1;

	heightMap: [mapSize][mapSize]i32 = undefined,
	biomeMap: [mapSize][mapSize]*const Biome = undefined,
	minHeight: i32 = std.math.maxInt(i32),
	maxHeight: i32 = 0,
	pos: MapFragmentPosition,

	wasStored: Atomic(bool) = .init(false),

	pub fn init(self: *MapFragment, wx: i32, wy: i32, voxelSize: u31) void {
		self.* = .{
			.pos = MapFragmentPosition.init(wx, wy, voxelSize),
		};
	}

	fn privateDeinit(self: *MapFragment) void {
		memoryPool.destroy(self);
	}

	pub fn deferredDeinit(self: *MapFragment) void {
		main.heap.GarbageCollection.deferredFree(.{.ptr = self, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
	}

	pub fn getBiome(self: *MapFragment, wx: i32, wy: i32) *const Biome {
		const xIndex = wx >> self.pos.voxelSizeShift & mapMask;
		const yIndex = wy >> self.pos.voxelSizeShift & mapMask;
		return self.biomeMap[@intCast(xIndex)][@intCast(yIndex)];
	}

	pub fn getHeight(self: *MapFragment, wx: i32, wy: i32) i32 {
		const xIndex = wx >> self.pos.voxelSizeShift & mapMask;
		const yIndex = wy >> self.pos.voxelSizeShift & mapMask;
		return self.heightMap[@intCast(xIndex)][@intCast(yIndex)];
	}

	const StorageHeader = struct {
		const minSupportedVersion: u8 = 0;
		const activeVersion: u8 = 1;
		version: u8 = activeVersion,
		neighborInfo: NeighborInfo,
	};
	const NeighborInfo = packed struct(u8) {
		@"-o": bool = false,
		@"+o": bool = false,
		@"o-": bool = false,
		@"o+": bool = false,
		@"--": bool = false,
		@"-+": bool = false,
		@"+-": bool = false,
		@"++": bool = false,
	};

	pub fn load(self: *MapFragment, biomePalette: *main.assets.Palette, originalHeightMap: ?*[mapSize][mapSize]i32) !NeighborInfo {
		const saveFolder: []const u8 = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/maps", .{main.server.world.?.path}) catch unreachable;
		defer main.stackAllocator.free(saveFolder);

		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{}/{}/{}.surface", .{saveFolder, self.pos.voxelSize, self.pos.wx, self.pos.wy}) catch unreachable;
		defer main.stackAllocator.free(path);

		const fullData = try main.files.cubyzDir().read(main.stackAllocator, path);
		defer main.stackAllocator.free(fullData);

		var fullReader = BinaryReader.init(fullData);

		const header: StorageHeader = .{
			.version = try fullReader.readInt(u8),
			.neighborInfo = @bitCast(try fullReader.readInt(u8)),
		};
		switch (header.version) {
			0 => { // TODO: Remove after next breaking change
				const rawData: []u8 = main.stackAllocator.alloc(u8, mapSize*mapSize*(@sizeOf(u32) + 2*@sizeOf(f32)));
				defer main.stackAllocator.free(rawData);
				if (try main.utils.Compression.inflateTo(rawData, fullReader.remaining) != rawData.len) return error.CorruptedFile;
				const biomeData = rawData[0 .. mapSize*mapSize*@sizeOf(u32)];
				const heightData = rawData[mapSize*mapSize*@sizeOf(u32) ..][0 .. mapSize*mapSize*@sizeOf(f32)];
				const originalHeightData = rawData[mapSize*mapSize*(@sizeOf(u32) + @sizeOf(f32)) ..][0 .. mapSize*mapSize*@sizeOf(f32)];
				for (0..mapSize) |x| {
					for (0..mapSize) |y| {
						self.biomeMap[x][y] = main.server.terrain.biomes.getById(biomePalette.palette.items[std.mem.readInt(u32, biomeData[4*(x*mapSize + y) ..][0..4], .big)]);
						self.heightMap[x][y] = @intFromFloat(@as(f32, @bitCast(std.mem.readInt(u32, heightData[4*(x*mapSize + y) ..][0..4], .big))));
						if (originalHeightMap) |map| map[x][y] = @intFromFloat(@as(f32, @bitCast(std.mem.readInt(u32, originalHeightData[4*(x*mapSize + y) ..][0..4], .big))));
					}
				}
			},
			1 => {
				const biomeDataSize = mapSize*mapSize*@sizeOf(u32);
				const heightDataSize = mapSize*mapSize*@sizeOf(i32);
				const originalHeightDataSize = mapSize*mapSize*@sizeOf(i32);

				const rawData: []u8 = main.stackAllocator.alloc(u8, biomeDataSize + heightDataSize + originalHeightDataSize);
				defer main.stackAllocator.free(rawData);
				if (try main.utils.Compression.inflateTo(rawData, fullReader.remaining) != rawData.len) return error.CorruptedFile;

				var reader = BinaryReader.init(rawData);

				for (0..mapSize) |x| for (0..mapSize) |y| {
					self.biomeMap[x][y] = main.server.terrain.biomes.getById(biomePalette.palette.items[try reader.readInt(u32)]);
				};
				for (0..mapSize) |x| for (0..mapSize) |y| {
					self.heightMap[x][y] = try reader.readInt(i32);
				};
				if (originalHeightMap) |map| for (0..mapSize) |x| for (0..mapSize) |y| {
					map[x][y] = try reader.readInt(i32);
				};
			},
			else => return error.OutdatedFileVersion,
		}
		self.wasStored.store(true, .monotonic);
		return header.neighborInfo;
	}

	pub fn save(self: *MapFragment, originalData: ?*[mapSize][mapSize]i32, neighborInfo: NeighborInfo) void {
		const biomeDataSize = mapSize*mapSize*@sizeOf(u32);
		const heightDataSize = mapSize*mapSize*@sizeOf(i32);
		const originalHeightDataSize = mapSize*mapSize*@sizeOf(i32);

		var writer = BinaryWriter.initCapacity(main.stackAllocator, biomeDataSize + heightDataSize + originalHeightDataSize);
		defer writer.deinit();

		for (0..mapSize) |x| for (0..mapSize) |y| writer.writeInt(u32, self.biomeMap[x][y].paletteId);
		for (0..mapSize) |x| for (0..mapSize) |y| writer.writeInt(i32, self.heightMap[x][y]);
		for (0..mapSize) |x| for (0..mapSize) |y| writer.writeInt(i32, (if (originalData) |map| map else &self.heightMap)[x][y]);

		const compressedData = main.utils.Compression.deflate(main.stackAllocator, writer.data.items, .fastest); // Using fast to increase performance of the regenerating map LODs step
		defer main.stackAllocator.free(compressedData);

		var outputWriter = BinaryWriter.initCapacity(main.stackAllocator, @sizeOf(StorageHeader) + compressedData.len);
		defer outputWriter.deinit();

		const header: StorageHeader = .{
			.neighborInfo = neighborInfo,
		};
		outputWriter.writeInt(u8, header.version);
		outputWriter.writeInt(u8, @bitCast(header.neighborInfo));
		outputWriter.writeSlice(compressedData);

		const saveFolder: []const u8 = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/maps", .{main.server.world.?.path}) catch unreachable;
		defer main.stackAllocator.free(saveFolder);

		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{}/{}/{}.surface", .{saveFolder, self.pos.voxelSize, self.pos.wx, self.pos.wy}) catch unreachable;
		defer main.stackAllocator.free(path);
		const folder = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}/{}/{}", .{saveFolder, self.pos.voxelSize, self.pos.wx}) catch unreachable;
		defer main.stackAllocator.free(folder);

		main.files.cubyzDir().makePath(folder) catch |err| {
			std.log.err("Error while writing to file {s}: {s}", .{path, @errorName(err)});
		};

		main.files.cubyzDir().write(path, outputWriter.data.items) catch |err| {
			std.log.err("Error while writing to file {s}: {s}", .{path, @errorName(err)});
		};
	}
};

/// Generates the detailed(block-level precision) height and biome maps from the climate map.
pub const MapGenerator = struct {
	init: *const fn (parameters: ZonElement) void,
	generateMapFragment: *const fn (fragment: *MapFragment, seed: u64) void,

	var generatorRegistry: std.StringHashMapUnmanaged(MapGenerator) = .{};

	fn registerGenerator(comptime Generator: type) void {
		const self = MapGenerator{
			.init = &Generator.init,
			.generateMapFragment = &Generator.generateMapFragment,
		};
		generatorRegistry.put(main.globalAllocator.allocator, Generator.id, self) catch unreachable;
	}

	pub fn getGeneratorById(id: []const u8) !MapGenerator {
		return generatorRegistry.get(id) orelse {
			std.log.err("Couldn't find map generator with id {s}", .{id});
			return error.UnknownMapGenerator;
		};
	}
};

const cacheSize = 1 << 6; // Must be a power of 2!
const cacheMask = cacheSize - 1;
const associativity = 8; // ~400MiB MiB Cache size
var cache: Cache(MapFragment, cacheSize, associativity, MapFragment.deferredDeinit) = .{};
var profile: TerrainGenerationProfile = undefined;

var memoryPool: main.heap.MemoryPool(MapFragment) = undefined;

pub fn globalInit() void {
	const list = @import("mapgen/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		MapGenerator.registerGenerator(@field(list, decl.name));
	}
	memoryPool = .init(main.globalAllocator);
}

pub fn globalDeinit() void {
	MapGenerator.generatorRegistry.clearAndFree(main.globalAllocator.allocator);
	memoryPool.deinit();
}

fn cacheInit(pos: MapFragmentPosition) *MapFragment {
	const mapFragment = memoryPool.create();
	mapFragment.init(pos.wx, pos.wy, pos.voxelSize);
	_ = mapFragment.load(main.server.world.?.biomePalette, null) catch {
		profile.mapFragmentGenerator.generateMapFragment(mapFragment, profile.seed);
	};
	return mapFragment;
}

pub fn regenerateLOD(worldName: []const u8) !void { // MARK: regenerateLOD()
	std.log.info("Regenerating map LODs...", .{});
	// Delete old LODs:
	for (1..main.settings.highestSupportedLod + 1) |i| {
		const lod = @as(u32, 1) << @intCast(i);
		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/maps/{}", .{worldName, lod}) catch unreachable;
		defer main.stackAllocator.free(path);
		main.files.cubyzDir().deleteTree(path) catch |err| {
			if (err != error.FileNotFound) {
				std.log.err("Error while deleting directory {s}: {s}", .{path, @errorName(err)});
			}
		};
	}
	// Find all the stored maps:
	var mapPositions = main.List(MapFragmentPosition).init(main.stackAllocator);
	defer mapPositions.deinit();
	const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/maps/1", .{worldName}) catch unreachable;
	defer main.stackAllocator.free(path);
	{
		var dirX = try main.files.cubyzDir().openIterableDir(path);
		defer dirX.close();
		var iterX = dirX.iterate();
		while (try iterX.next()) |entryX| {
			if (entryX.kind != .directory) continue;
			const wx = std.fmt.parseInt(i32, entryX.name, 0) catch continue;
			var dirY = try dirX.openIterableDir(entryX.name);
			defer dirY.close();
			var iterY = dirY.iterate();
			while (try iterY.next()) |entryY| {
				if (entryY.kind != .file) continue;
				const nameY = entryY.name[0 .. std.mem.indexOfScalar(u8, entryY.name, '.') orelse entryY.name.len];
				const wy = std.fmt.parseInt(i32, nameY, 0) catch continue;
				mapPositions.append(.{.wx = wx, .wy = wy, .voxelSize = 1, .voxelSizeShift = 0});
			}
		}
	}
	// Load all the stored maps and update their next LODs.
	const interpolationDistance = 64;
	for (mapPositions.items) |pos| {
		main.heap.GarbageCollection.syncPoint();
		var neighborInfo: MapFragment.NeighborInfo = undefined;
		inline for (comptime std.meta.fieldNames(MapFragment.NeighborInfo)) |name| {
			var neighborPos = pos;
			if (name[0] == '+') neighborPos.wx +%= MapFragment.mapSize;
			if (name[0] == '-') neighborPos.wx -%= MapFragment.mapSize;
			if (name[1] == '+') neighborPos.wy +%= MapFragment.mapSize;
			if (name[1] == '-') neighborPos.wy -%= MapFragment.mapSize;
			var isPresent: bool = false;
			for (mapPositions.items) |otherPos| {
				if (neighborPos.wx == otherPos.wx and neighborPos.wy == otherPos.wy) {
					isPresent = true;
					break;
				}
			}
			@field(neighborInfo, name) = isPresent;
		}
		const mapFragment = main.stackAllocator.create(MapFragment);
		defer main.stackAllocator.destroy(mapFragment);
		mapFragment.init(pos.wx, pos.wy, pos.voxelSize);
		var xNoise: [MapFragment.mapSize]f32 = undefined;
		var yNoise: [MapFragment.mapSize]f32 = undefined;
		terrain.noise.FractalNoise1D.generateSparseFractalTerrain(pos.wx, 32, main.server.world.?.settings.seed, &xNoise);
		terrain.noise.FractalNoise1D.generateSparseFractalTerrain(pos.wy, 32, main.server.world.?.settings.seed ^ 0x785298638131, &yNoise);
		var originalHeightMap: [MapFragment.mapSize][MapFragment.mapSize]i32 = undefined;
		const oldNeighborInfo = mapFragment.load(main.server.world.?.biomePalette, &originalHeightMap) catch |err| {
			std.log.err("Error loading map at position {}: {s}", .{pos, @errorName(err)});
			continue;
		};
		if (@as(u8, @bitCast(neighborInfo)) != @as(u8, @bitCast(oldNeighborInfo))) {
			// Now we do the fun stuff
			// Basically we want to only keep the interpolated map in the direction of the changes.
			// Edges:
			if (neighborInfo.@"+o" != oldNeighborInfo.@"+o" or neighborInfo.@"-o" != oldNeighborInfo.@"-o" or neighborInfo.@"o+" != oldNeighborInfo.@"o+" or neighborInfo.@"o-" != oldNeighborInfo.@"o-") {
				for (0..interpolationDistance) |a| { // edges
					for (interpolationDistance..MapFragment.mapSize - interpolationDistance) |b| {
						if (neighborInfo.@"+o" and !oldNeighborInfo.@"+o") {
							const x = MapFragment.mapSize - 1 - a;
							const y = b;
							originalHeightMap[x][y] = mapFragment.heightMap[x][y];
						}
						if (neighborInfo.@"-o" and !oldNeighborInfo.@"-o") {
							const x = a;
							const y = b;
							originalHeightMap[x][y] = mapFragment.heightMap[x][y];
						}
						if (neighborInfo.@"o+" and !oldNeighborInfo.@"o+") {
							const x = b;
							const y = MapFragment.mapSize - 1 - a;
							originalHeightMap[x][y] = mapFragment.heightMap[x][y];
						}
						if (neighborInfo.@"o-" and !oldNeighborInfo.@"o-") {
							const x = b;
							const y = a;
							originalHeightMap[x][y] = mapFragment.heightMap[x][y];
						}
					}
				}
			}
			// Corners:
			{
				for (0..interpolationDistance) |a| { // corners:
					for (0..interpolationDistance) |b| {
						const weirdSquareInterpolation = struct {
							fn interp(x: f32, y: f32) f32 {
								// Basically we want to interpolate the values such that two sides of the square have value zero, while the opposing two sides have value 1.
								// Change coordinate system:
								if (x == y) return 0.5;
								const sqrt2 = @sqrt(0.5);
								const k = sqrt2*x + sqrt2*y - sqrt2;
								const l = -sqrt2*x + sqrt2*y;
								const maxMagnitude = sqrt2 - @abs(k);
								return l/maxMagnitude*0.5 + 0.5;
								// if x = y:
							}
						}.interp;
						var factorA = @as(f32, @floatFromInt(a))/interpolationDistance;
						factorA = (3 - 2*factorA)*factorA*factorA;
						var factorB = @as(f32, @floatFromInt(b))/interpolationDistance;
						factorB = (3 - 2*factorB)*factorB*factorB;
						if (neighborInfo.@"+o" or neighborInfo.@"o+") {
							var factor: f32 = 1;
							if (neighborInfo.@"+o" and neighborInfo.@"o+" == oldNeighborInfo.@"o+" and !oldNeighborInfo.@"+o") factor = weirdSquareInterpolation(1 - factorB, 1 - factorA);
							if (neighborInfo.@"o+" and neighborInfo.@"+o" == oldNeighborInfo.@"+o" and !oldNeighborInfo.@"o+") factor = weirdSquareInterpolation(1 - factorA, 1 - factorB);
							if (neighborInfo.@"+o" == oldNeighborInfo.@"+o" and neighborInfo.@"o+" == oldNeighborInfo.@"o+") factor = 0;
							if (neighborInfo.@"+o" and neighborInfo.@"o+" and neighborInfo.@"++") factor = 1;
							const x = MapFragment.mapSize - 1 - a;
							const y = MapFragment.mapSize - 1 - b;
							originalHeightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(originalHeightMap[x][y]))*(1 - factor));
						}
						if (neighborInfo.@"+o" or neighborInfo.@"o-") {
							var factor: f32 = 1;
							if (neighborInfo.@"+o" and neighborInfo.@"o-" == oldNeighborInfo.@"o-" and !oldNeighborInfo.@"+o") factor = weirdSquareInterpolation(1 - factorB, 1 - factorA);
							if (neighborInfo.@"o-" and neighborInfo.@"+o" == oldNeighborInfo.@"+o" and !oldNeighborInfo.@"o-") factor = weirdSquareInterpolation(1 - factorA, 1 - factorB);
							if (neighborInfo.@"+o" == oldNeighborInfo.@"+o" and neighborInfo.@"o-" == oldNeighborInfo.@"o-") factor = 0;
							if (neighborInfo.@"+o" and neighborInfo.@"o-" and neighborInfo.@"+-") factor = 1;
							const x = MapFragment.mapSize - 1 - a;
							const y = b;
							originalHeightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(originalHeightMap[x][y]))*(1 - factor));
						}
						if (neighborInfo.@"-o" or neighborInfo.@"o+") {
							var factor: f32 = 1;
							if (neighborInfo.@"-o" and neighborInfo.@"o+" == oldNeighborInfo.@"o+" and !oldNeighborInfo.@"-o") factor = weirdSquareInterpolation(1 - factorB, 1 - factorA);
							if (neighborInfo.@"o+" and neighborInfo.@"-o" == oldNeighborInfo.@"-o" and !oldNeighborInfo.@"o+") factor = weirdSquareInterpolation(1 - factorA, 1 - factorB);
							if (neighborInfo.@"-o" == oldNeighborInfo.@"-o" and neighborInfo.@"o+" == oldNeighborInfo.@"o+") factor = 0;
							if (neighborInfo.@"-o" and neighborInfo.@"o+" and neighborInfo.@"-+") factor = 1;
							const x = a;
							const y = MapFragment.mapSize - 1 - b;
							originalHeightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(originalHeightMap[x][y]))*(1 - factor));
						}
						if (neighborInfo.@"-o" or neighborInfo.@"o-") {
							var factor: f32 = 1;
							if (neighborInfo.@"-o" and neighborInfo.@"o-" == oldNeighborInfo.@"o-" and !oldNeighborInfo.@"-o") factor = weirdSquareInterpolation(1 - factorB, 1 - factorA);
							if (neighborInfo.@"o-" and neighborInfo.@"-o" == oldNeighborInfo.@"-o" and !oldNeighborInfo.@"o-") factor = weirdSquareInterpolation(1 - factorA, 1 - factorB);
							if (neighborInfo.@"-o" == oldNeighborInfo.@"-o" and neighborInfo.@"o-" == oldNeighborInfo.@"o-") factor = 0;
							if (neighborInfo.@"-o" and neighborInfo.@"o-" and neighborInfo.@"--") factor = 1;
							const x = a;
							const y = b;
							originalHeightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(originalHeightMap[x][y]))*(1 - factor));
						}
					}
				}
			}
		}
		{ // Interpolate the terraing height:
			const InterpolationPolynomial = struct {
				// Basically we want an interpolation function with the following properties:
				// f(0) = 0
				// f(1) = 1
				// f'(0) = 0
				// f'(1) = 0
				// f(noise) = 0.5
				// This must be a polynomial of degree 4 with a factor x²
				// f(x) = ax⁴ + bx³ + cx²
				// f'(x) = 4ax³ + 3x² + 2cx
				// f(1) = a + b + c = 1 → c = 1 - a - b
				// f'(1) = 4a + 3b + 2c = 0 → 4a + 3b + 2 - 2a - 2b = 0 → 2a + b + 2 = 0 → b = -2a - 2
				// f(noise) = a noise⁴ + b noise³ + c noise² = 0.5 → a noise⁴ + (-2a - 2) noise³ + (3 + a) noise² = 0.5 → a (noise⁴ - 2noise³ + noise²) = 2noise³ - 3 noise² + 0.5
				// → a = (2noise³ - 3 noise² + 0.5)/(noise⁴ - 2noise³ + noise²)
				// → a = (2noise - 3 + 0.5/noise²)/(noise² - 2noise + 1)
				// → a = (2noise - 3 + 0.5/noise²)/(noise - 1)²
				a: f32,
				b: f32,
				c: f32,
				fn get(noise: f32) @This() {
					const noise2 = noise*noise;
					const noise3 = noise2*noise;
					const noise4 = noise2*noise2;
					const a = (2*noise3 - 3*noise2 + 0.5)/(noise4 - 2*noise3 + noise2);
					const b = -2*a - 2;
					const c = 1 - a - b;
					return .{.a = a, .b = b, .c = c};
				}
				fn eval(self: @This(), x: f32) f32 {
					return @max(0, @min(0.99999, ((self.a*x + self.b)*x + self.c)*x*x));
				}
			};
			const generatedMap = main.stackAllocator.create(MapFragment);
			defer main.stackAllocator.destroy(generatedMap);
			generatedMap.init(pos.wx, pos.wy, pos.voxelSize);
			profile.mapFragmentGenerator.generateMapFragment(generatedMap, profile.seed);

			@memcpy(&mapFragment.heightMap, &originalHeightMap);
			for (0..MapFragment.mapSize) |b| {
				const polynomialX = InterpolationPolynomial.get(yNoise[b]*0.5 + 0.25);
				const polynomialY = InterpolationPolynomial.get(xNoise[b]*0.5 + 0.25);
				for (0..interpolationDistance) |a| { // edges
					const factorX = polynomialX.eval(@as(f32, @floatFromInt(a))/interpolationDistance);
					const factorY = polynomialY.eval(@as(f32, @floatFromInt(a))/interpolationDistance);
					if (!neighborInfo.@"+o") {
						const x = MapFragment.mapSize - 1 - a;
						const y = b;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factorX + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factorX));
						if (factorX < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
					if (!neighborInfo.@"-o") {
						const x = a;
						const y = b;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factorX + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factorX));
						if (factorX < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
					if (!neighborInfo.@"o+") {
						const x = b;
						const y = MapFragment.mapSize - 1 - a;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factorY + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factorY));
						if (factorY < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
					if (!neighborInfo.@"o-") {
						const x = b;
						const y = a;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factorY + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factorY));
						if (factorY < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
				}
			}
			for (0..interpolationDistance) |a| { // corners:
				const polynomialY1 = InterpolationPolynomial.get(xNoise[a]*0.5 + 0.25);
				const polynomialY2 = InterpolationPolynomial.get(xNoise[MapFragment.mapSize - 1 - a]*0.5 + 0.25);
				for (0..interpolationDistance) |b| {
					const polynomialX1 = InterpolationPolynomial.get(yNoise[b]*0.5 + 0.25);
					const polynomialX2 = InterpolationPolynomial.get(yNoise[MapFragment.mapSize - 1 - b]*0.5 + 0.25);
					const factorX1 = polynomialX1.eval(@as(f32, @floatFromInt(a))/interpolationDistance);
					const factorX2 = polynomialX2.eval(@as(f32, @floatFromInt(a))/interpolationDistance);
					const factorY1 = polynomialY1.eval(@as(f32, @floatFromInt(b))/interpolationDistance);
					const factorY2 = polynomialY2.eval(@as(f32, @floatFromInt(b))/interpolationDistance);
					if (!neighborInfo.@"++" and neighborInfo.@"+o" and neighborInfo.@"o+") {
						const factor = 1 - (1 - factorX2)*(1 - factorY2);
						const x = MapFragment.mapSize - 1 - a;
						const y = MapFragment.mapSize - 1 - b;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factor));
						if (factor < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
					if (!neighborInfo.@"+-" and neighborInfo.@"+o" and neighborInfo.@"o-") {
						const factor = 1 - (1 - factorX1)*(1 - factorY2);
						const x = MapFragment.mapSize - 1 - a;
						const y = b;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factor));
						if (factor < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
					if (!neighborInfo.@"-+" and neighborInfo.@"-o" and neighborInfo.@"o+") {
						const factor = 1 - (1 - factorX2)*(1 - factorY1);
						const x = a;
						const y = MapFragment.mapSize - 1 - b;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factor));
						if (factor < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
					if (!neighborInfo.@"--" and neighborInfo.@"-o" and neighborInfo.@"o-") {
						const factor = 1 - (1 - factorX1)*(1 - factorY1);
						const x = a;
						const y = b;
						mapFragment.heightMap[x][y] = @intFromFloat(0.5 + @as(f32, @floatFromInt(mapFragment.heightMap[x][y]))*factor + @as(f32, @floatFromInt(generatedMap.heightMap[x][y]))*(1 - factor));
						if (factor < 0.25) {
							mapFragment.biomeMap[x][y] = generatedMap.biomeMap[x][y];
						}
					}
				}
			}
		}
		mapFragment.save(&originalHeightMap, neighborInfo); // Store the interpolated map
		// Generate LODs
		var cur = mapFragment;
		while (cur.pos.voxelSizeShift < main.settings.highestSupportedLod) {
			var nextPos = cur.pos;
			nextPos.voxelSize *= 2;
			nextPos.voxelSizeShift += 1;
			const nextMask = ~@as(i32, nextPos.voxelSize*MapFragment.mapSize - 1);
			nextPos.wx &= nextMask;
			nextPos.wy &= nextMask;
			const next = getOrGenerateFragment(nextPos.wx, nextPos.wy, nextPos.voxelSize);
			const offSetX: usize = @intCast((cur.pos.wx -% nextPos.wx) >> nextPos.voxelSizeShift);
			const offSetY: usize = @intCast((cur.pos.wy -% nextPos.wy) >> nextPos.voxelSizeShift);
			for (0..MapFragment.mapSize/2) |x| {
				for (0..MapFragment.mapSize/2) |y| {
					var biomes: [4]?*const Biome = @splat(null);
					var biomeCounts: [4]u8 = @splat(0);
					var height: i32 = 0;
					for (0..2) |dx| {
						for (0..2) |dy| {
							const curX = x*2 + dx;
							const curY = y*2 + dy;
							height += cur.heightMap[curX][curY];
							const biome = cur.biomeMap[curX][curY];
							for (0..4) |i| {
								if (biomes[i] == biome) {
									biomeCounts[i] += 1;
									break;
								} else if (biomes[i] == null) {
									biomes[i] = biome;
									biomeCounts[i] += 1;
									break;
								}
							}
						}
					}
					var bestBiome: *const Biome = biomes[0].?;
					var bestBiomeCount: u8 = biomeCounts[0];
					for (1..4) |i| {
						if (biomeCounts[i] > bestBiomeCount) {
							bestBiomeCount = biomeCounts[i];
							bestBiome = biomes[i].?;
						}
					}
					const nextX = offSetX + x;
					const nextY = offSetY + y;
					next.heightMap[nextX][nextY] = @divFloor(height, 4);
					next.biomeMap[nextX][nextY] = bestBiome;
				}
			}
			next.save(null, .{});
			next.wasStored.store(true, .monotonic);
			cur = next;
		}
	}
	std.log.info("Finished regenerating map LODs...", .{});
}

pub fn init(_profile: TerrainGenerationProfile) void {
	profile = _profile;
}

pub fn deinit() void {
	cache.clear();
}

/// Call deinit on the result.
pub fn getOrGenerateFragment(wx: i32, wy: i32, voxelSize: u31) *MapFragment {
	const compare = MapFragmentPosition.init(
		wx & ~@as(i32, MapFragment.mapMask*voxelSize | voxelSize - 1),
		wy & ~@as(i32, MapFragment.mapMask*voxelSize | voxelSize - 1),
		voxelSize,
	);
	const result = cache.findOrCreate(compare, cacheInit, null);
	return result;
}

```

`src/server/terrain/biomes.zig`:

```zig
const std = @import("std");

const main = @import("main");
const blocks = main.blocks;
const ServerChunk = main.chunk.ServerChunk;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const vec = @import("main.vec");
const Vec3f = main.vec.Vec3f;
const Vec3d = main.vec.Vec3d;

pub const SimpleStructureModel = struct { // MARK: SimpleStructureModel
	pub const GenerationMode = enum {
		floor,
		ceiling,
		floor_and_ceiling,
		air,
		underground,
		water_surface,
	};
	const VTable = struct {
		loadModel: *const fn (parameters: ZonElement) ?*anyopaque,
		generate: *const fn (self: *anyopaque, generationMode: GenerationMode, x: i32, y: i32, z: i32, chunk: *ServerChunk, caveMap: terrain.CaveMap.CaveMapView, biomeMap: terrain.CaveBiomeMap.CaveBiomeMapView, seed: *u64, isCeiling: bool) void,
		hashFunction: *const fn (self: *anyopaque) u64,
		generationMode: GenerationMode,
	};

	vtable: VTable,
	data: *anyopaque,
	chance: f32,
	priority: f32,
	generationMode: GenerationMode,

	pub fn initModel(parameters: ZonElement) ?SimpleStructureModel {
		const id = parameters.get([]const u8, "id", "");
		const vtable = modelRegistry.get(id) orelse {
			std.log.err("Couldn't find structure model with id {s}", .{id});
			return null;
		};
		const vtableModel = vtable.loadModel(parameters) orelse {
			std.log.err("Error occurred while loading structure with id '{s}'. Dropping model from biome.", .{id});
			return null;
		};
		return SimpleStructureModel{
			.vtable = vtable,
			.data = vtableModel,
			.chance = parameters.get(f32, "chance", 0.1),
			.priority = parameters.get(f32, "priority", 1),
			.generationMode = std.meta.stringToEnum(GenerationMode, parameters.get([]const u8, "generationMode", "")) orelse vtable.generationMode,
		};
	}

	pub fn generate(self: SimpleStructureModel, x: i32, y: i32, z: i32, chunk: *ServerChunk, caveMap: terrain.CaveMap.CaveMapView, biomeMap: terrain.CaveBiomeMap.CaveBiomeMapView, seed: *u64, isCeiling: bool) void {
		self.vtable.generate(self.data, self.generationMode, x, y, z, chunk, caveMap, biomeMap, seed, isCeiling);
	}

	var modelRegistry: std.StringHashMapUnmanaged(VTable) = .{};

	pub fn registerGenerator(comptime Generator: type) void {
		var self: VTable = undefined;
		self.loadModel = main.meta.castFunctionReturnToOptionalAnyopaque(Generator.loadModel);
		self.generate = main.meta.castFunctionSelfToAnyopaque(Generator.generate);
		self.hashFunction = main.meta.castFunctionSelfToAnyopaque(struct {
			fn hash(ptr: *Generator) u64 {
				return hashGeneric(ptr.*);
			}
		}.hash);
		self.generationMode = Generator.generationMode;
		modelRegistry.put(main.globalArena.allocator, Generator.id, self) catch unreachable;
	}

	fn getHash(self: SimpleStructureModel) u64 {
		return self.vtable.hashFunction(self.data);
	}
};

const Stripe = struct { // MARK: Stripe
	direction: ?Vec3d,
	block: main.blocks.Block,
	minDistance: f64,
	maxDistance: f64,
	minOffset: f64,
	maxOffset: f64,
	minWidth: f64,
	maxWidth: f64,

	pub fn init(parameters: ZonElement) Stripe {
		var dir: ?Vec3d = parameters.get(?Vec3d, "direction", null);
		if (dir != null) {
			dir = main.vec.normalize(dir.?);
		}

		const block: main.blocks.Block = blocks.parseBlock(parameters.get([]const u8, "block", ""));

		var minDistance: f64 = 0;
		var maxDistance: f64 = 0;
		if (parameters.object.get("distance")) |dist| {
			minDistance = dist.as(f64, 0);
			maxDistance = dist.as(f64, 0);
		} else {
			minDistance = parameters.get(f64, "minDistance", 0);
			maxDistance = parameters.get(f64, "maxDistance", 0);
		}

		var minOffset: f64 = 0;
		var maxOffset: f64 = 0;
		if (parameters.object.get("offset")) |off| {
			minOffset = off.as(f64, 0);
			maxOffset = off.as(f64, 0);
		} else {
			minOffset = parameters.get(f64, "minOffset", 0);
			maxOffset = parameters.get(f64, "maxOffset", 0);
		}

		var minWidth: f64 = 0;
		var maxWidth: f64 = 0;
		if (parameters.object.get("width")) |width| {
			minWidth = width.as(f64, 0);
			maxWidth = width.as(f64, 0);
		} else {
			minWidth = parameters.get(f64, "minWidth", 0);
			maxWidth = parameters.get(f64, "maxWidth", 0);
		}

		return Stripe{
			.direction = dir,
			.block = block,

			.minDistance = minDistance,
			.maxDistance = maxDistance,

			.minOffset = minOffset,
			.maxOffset = maxOffset,

			.minWidth = minWidth,
			.maxWidth = maxWidth,
		};
	}
};

fn hashGeneric(input: anytype) u64 {
	const T = @TypeOf(input);
	return switch (@typeInfo(T)) {
		.bool => hashCombine(hashInt(@intFromBool(input)), 0xbf58476d1ce4e5b9),
		.@"enum" => hashCombine(hashInt(@as(u64, @intFromEnum(input))), 0x94d049bb133111eb),
		.int, .float => blk: {
			const value = @as(std.meta.Int(.unsigned, @bitSizeOf(T)), @bitCast(input));
			break :blk hashInt(@as(u64, value));
		},
		.@"struct" => blk: {
			if (@hasDecl(T, "getHash")) {
				break :blk input.getHash();
			}
			var result: u64 = hashGeneric(@typeName(T));
			inline for (@typeInfo(T).@"struct".fields) |field| {
				const keyHash = hashGeneric(@as([]const u8, field.name));
				const valueHash = hashGeneric(@field(input, field.name));
				const keyValueHash = hashCombine(keyHash, valueHash);
				result = hashCombine(result, keyValueHash);
			}
			break :blk result;
		},
		.optional => if (input) |_input| hashGeneric(_input) else 0,
		.pointer => switch (@typeInfo(T).pointer.size) {
			.one => blk: {
				if (@typeInfo(@typeInfo(T).pointer.child) == .@"fn") break :blk 0;
				if (@typeInfo(T).pointer.child == Biome) return hashGeneric(input.id);
				if (@typeInfo(T).pointer.child == anyopaque) break :blk 0;
				break :blk hashGeneric(input.*);
			},
			.slice => blk: {
				var result: u64 = hashInt(input.len);
				for (input) |val| {
					const valueHash = hashGeneric(val);
					result = hashCombine(result, valueHash);
				}
				break :blk result;
			},
			else => @compileError("Unsupported type " ++ @typeName(T)),
		},
		.array => blk: {
			var result: u64 = 0xbf58476d1ce4e5b9;
			for (input) |val| {
				const valueHash = hashGeneric(val);
				result = hashCombine(result, valueHash);
			}
			break :blk result;
		},
		.vector => blk: {
			var result: u64 = 0x94d049bb133111eb;
			inline for (0..@typeInfo(T).vector.len) |i| {
				const valueHash = hashGeneric(input[i]);
				result = hashCombine(result, valueHash);
			}
			break :blk result;
		},
		else => @compileError("Unsupported type " ++ @typeName(T)),
	};
}

// https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes
fn hashCombine(left: u64, right: u64) u64 {
	return left ^ (right +% 0x517cc1b727220a95 +% (left << 6) +% (left >> 2));
}

// https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
fn hashInt(input: u64) u64 {
	var x = input;
	x = (x ^ (x >> 30))*%0xbf58476d1ce4e5b9;
	x = (x ^ (x >> 27))*%0x94d049bb133111eb;
	x = x ^ (x >> 31);
	return x;
}

pub const Interpolation = enum(u8) {
	none,
	linear,
	square,
};

fn u32ToVec3(color: u32) Vec3f {
	const r = @as(f32, @floatFromInt((color >> 16) & 0xFF))/255.0;
	const g = @as(f32, @floatFromInt((color >> 8) & 0xFF))/255.0;
	const b = @as(f32, @floatFromInt(color & 0xFF))/255.0;

	return .{r, g, b};
}

/// A climate region with special ground, plants and structures.
pub const Biome = struct { // MARK: Biome
	pub const GenerationProperties = packed struct(u15) {
		// pairs of opposite properties. In-between values are allowed.
		hot: bool = false,
		temperate: bool = false,
		cold: bool = false,

		inland: bool = false,
		land: bool = false,
		ocean: bool = false,

		wet: bool = false,
		neitherWetNorDry: bool = false,
		dry: bool = false,

		barren: bool = false,
		balanced: bool = false,
		overgrown: bool = false,

		mountain: bool = false,
		lowTerrain: bool = false,
		antiMountain: bool = false,

		pub const mask: u15 = 0b001001001001001;

		pub fn fromZon(zon: ZonElement, initMidValues: bool) GenerationProperties {
			var result: GenerationProperties = .{};
			for (zon.toSlice()) |child| {
				const property = child.as([]const u8, "");
				inline for (@typeInfo(GenerationProperties).@"struct".fields) |field| {
					if (std.mem.eql(u8, field.name, property)) {
						@field(result, field.name) = true;
					}
				}
			}
			if (initMidValues) {
				// Fill all mid values if no value was specified in a group:
				const val: u15 = @bitCast(result);
				const empty = ~val & ~val >> 1 & ~val >> 2 & mask;
				result = @bitCast(val | empty << 1);
			}
			return result;
		}
	};

	properties: GenerationProperties,
	isCave: bool,
	radius: f32,
	radiusVariation: f32,
	minHeight: i32,
	maxHeight: i32,
	minHeightLimit: i32,
	maxHeightLimit: i32,
	smoothBeaches: bool,
	interpolation: Interpolation,
	interpolationWeight: f32,
	roughness: f32,
	hills: f32,
	mountains: f32,
	keepOriginalTerrain: f32,
	caves: f32,
	caveRadiusFactor: f32,
	crystals: u32,
	/// How much of the surface structure should be eroded depending on the slope.
	soilCreep: f32,
	stoneBlock: main.blocks.Block,
	fogLower: f32,
	fogHigher: f32,
	fogDensity: f32,
	fogColor: Vec3f,
	skyColor: Vec3f,
	id: []const u8,
	paletteId: u32,
	structure: BlockStructure = undefined,
	/// Whether the starting point of a river can be in this biome. If false rivers will be able to flow through this biome anyways.
	supportsRivers: bool, // TODO: Reimplement rivers.
	/// The first members in this array will get prioritized.
	vegetationModels: []SimpleStructureModel = &.{},
	stripes: []Stripe = &.{},
	subBiomes: main.utils.AliasTable(*const Biome) = .{.items = &.{}, .aliasData = &.{}},
	transitionBiomes: []TransitionBiome = &.{},
	maxSubBiomeCount: f32,
	subBiomeTotalChance: f32 = 0,
	preferredMusic: []const u8, // TODO: Support multiple possibilities that are chosen based on time and danger.
	isValidPlayerSpawn: bool,
	chance: f32,

	pub fn init(self: *Biome, id: []const u8, paletteId: u32, zon: ZonElement) void {
		const minRadius = zon.get(f32, "radius", zon.get(f32, "minRadius", 256));
		const maxRadius = zon.get(f32, "maxRadius", minRadius);
		self.* = Biome{
			.id = main.worldArena.dupe(u8, id),
			.paletteId = paletteId,
			.properties = GenerationProperties.fromZon(zon.getChild("properties"), true),
			.isCave = zon.get(bool, "isCave", false),
			.radius = (maxRadius + minRadius)/2,
			.radiusVariation = (maxRadius - minRadius)/2,
			.stoneBlock = blocks.parseBlock(zon.get([]const u8, "stoneBlock", "cubyz:slate/base")),
			.fogColor = u32ToVec3(zon.get(u32, "fogColor", 0xffbfe2ff)),
			.skyColor = blk: {
				break :blk u32ToVec3(zon.get(?u32, "skyColor", null) orelse break :blk .{0.46, 0.7, 1.0});
			},
			.fogDensity = zon.get(f32, "fogDensity", 1.0)/15.0/128.0,
			.fogLower = zon.get(f32, "fogLower", 100.0),
			.fogHigher = zon.get(f32, "fogHigher", 1000.0),
			.roughness = zon.get(f32, "roughness", 0),
			.hills = zon.get(f32, "hills", 0),
			.mountains = zon.get(f32, "mountains", 0),
			.keepOriginalTerrain = zon.get(f32, "keepOriginalTerrain", 0),
			.interpolation = std.meta.stringToEnum(Interpolation, zon.get([]const u8, "interpolation", "square")) orelse .square,
			.interpolationWeight = @max(zon.get(f32, "interpolationWeight", 1), std.math.floatMin(f32)),
			.caves = zon.get(f32, "caves", -0.375),
			.caveRadiusFactor = @max(-2, @min(2, zon.get(f32, "caveRadiusFactor", 1))),
			.crystals = zon.get(u32, "crystals", 0),
			.soilCreep = zon.get(f32, "soilCreep", 0.5),
			.minHeight = zon.get(i32, "minHeight", std.math.minInt(i32)),
			.maxHeight = zon.get(i32, "maxHeight", std.math.maxInt(i32)),
			.minHeightLimit = zon.get(i32, "minHeightLimit", std.math.minInt(i32)),
			.maxHeightLimit = zon.get(i32, "maxHeightLimit", std.math.maxInt(i32)),
			.smoothBeaches = zon.get(bool, "smoothBeaches", false),
			.supportsRivers = zon.get(bool, "rivers", false),
			.preferredMusic = main.worldArena.dupe(u8, zon.get([]const u8, "music", "cubyz:TotalDemented/Cubyz")),
			.isValidPlayerSpawn = zon.get(bool, "validPlayerSpawn", false),
			.chance = zon.get(f32, "chance", if (zon == .null) 0 else 1),
			.maxSubBiomeCount = zon.get(f32, "maxSubBiomeCount", std.math.floatMax(f32)),
		};
		if (minRadius > maxRadius) {
			std.log.err("Biome {s} has invalid radius range ({d}, {d})", .{self.id, minRadius, maxRadius});
		}
		if (minRadius < terrain.SurfaceMap.MapFragment.biomeSize/2) {
			std.log.err("Biome {s} has radius {d}, smaller than grid resolution. It should be at least {d}", .{self.id, minRadius, terrain.SurfaceMap.MapFragment.biomeSize/2});
		}
		if (self.minHeight > self.maxHeight) {
			std.log.err("Biome {s} has invalid height range ({}, {})", .{self.id, self.minHeight, self.maxHeight});
		}
		const parentBiomeList = zon.getChild("parentBiomes");
		for (parentBiomeList.toSlice()) |parent| {
			const result = unfinishedSubBiomes.getOrPutValue(main.globalAllocator.allocator, parent.get([]const u8, "id", ""), .{}) catch unreachable;
			result.value_ptr.append(main.globalAllocator, .{.biomeId = self.id, .chance = parent.get(f32, "chance", 1)});
		}

		const transitionBiomeList = zon.getChild("transitionBiomes").toSlice();
		if (transitionBiomeList.len != 0) {
			const transitionBiomes = main.globalAllocator.alloc(UnfinishedTransitionBiomeData, transitionBiomeList.len);
			for (transitionBiomes, transitionBiomeList) |*dst, src| {
				dst.* = .{
					.biomeId = src.get([]const u8, "id", ""),
					.chance = src.get(f32, "chance", 1),
					.propertyMask = GenerationProperties.fromZon(src.getChild("properties"), false),
					.width = src.get(u8, "width", 2),
				};
				// Fill all unspecified property groups:
				var properties: u15 = @bitCast(dst.propertyMask);
				const empty = ~properties & ~properties >> 1 & ~properties >> 2 & GenerationProperties.mask;
				properties |= empty | empty << 1 | empty << 2;
				dst.propertyMask = @bitCast(properties);
			}
			unfinishedTransitionBiomes.put(main.globalAllocator.allocator, self.id, transitionBiomes) catch unreachable;
		}

		self.structure = BlockStructure.init(main.worldArena, zon.getChild("ground_structure"));

		const structures = zon.getChild("structures");
		var vegetation = main.ListUnmanaged(SimpleStructureModel){};
		var totalChance: f32 = 0;
		defer vegetation.deinit(main.stackAllocator);
		for (structures.toSlice()) |elem| {
			if (SimpleStructureModel.initModel(elem)) |model| {
				vegetation.append(main.stackAllocator, model);
				totalChance += model.chance;
			}
		}
		if (totalChance > 1) {
			for (vegetation.items) |*model| {
				model.chance /= totalChance;
			}
		}
		self.vegetationModels = main.worldArena.dupe(SimpleStructureModel, vegetation.items);

		const stripes = zon.getChild("stripes");
		self.stripes = main.worldArena.alloc(Stripe, stripes.toSlice().len);
		for (stripes.toSlice(), 0..) |elem, i| {
			self.stripes[i] = Stripe.init(elem);
		}
	}

	fn getCheckSum(self: *Biome) u64 {
		return hashGeneric(self.*);
	}
};

/// Stores the vertical ground structure of a biome from top to bottom.
pub const BlockStructure = struct { // MARK: BlockStructure
	pub const BlockStack = struct {
		block: main.blocks.Block = .{.typ = 0, .data = 0},
		min: u31 = 0,
		max: u31 = 0,

		fn init(self: *BlockStack, string: []const u8) !void {
			var tokenIt = std.mem.tokenizeAny(u8, string, &std.ascii.whitespace);
			const first = tokenIt.next() orelse return error.@"String is empty.";
			var blockId: []const u8 = first;
			if (tokenIt.next()) |second| {
				self.min = try std.fmt.parseInt(u31, first, 0);
				if (tokenIt.next()) |third| {
					const fourth = tokenIt.next() orelse return error.@"Expected 1, 2 or 4 parameters, found 3.";
					if (!std.mem.eql(u8, second, "to")) return error.@"Expected layout '<min> to <max> <block>'. Missing 'to'.";
					self.max = try std.fmt.parseInt(u31, third, 0);
					blockId = fourth;
					if (tokenIt.next() != null) return error.@"Found too many parameters. Expected 1, 2 or 4.";
					if (self.max < self.min) return error.@"The max value must be bigger than the min value.";
				} else {
					self.max = self.min;
					blockId = second;
				}
			} else {
				self.min = 1;
				self.max = 1;
			}
			self.block = blocks.parseBlock(blockId);
		}
	};
	structure: []BlockStack,

	pub fn init(allocator: NeverFailingAllocator, zonArray: ZonElement) BlockStructure {
		const blockStackDescriptions = zonArray.toSlice();
		const self = BlockStructure{
			.structure = allocator.alloc(BlockStack, blockStackDescriptions.len),
		};
		for (blockStackDescriptions, self.structure) |zonString, *blockStack| {
			blockStack.init(zonString.as([]const u8, "That's not a zon string.")) catch |err| {
				std.log.err("Couldn't parse blockStack '{s}': {s} Removing it.", .{zonString.as([]const u8, "(not a zon string)"), @errorName(err)});
				blockStack.* = .{};
			};
		}
		return self;
	}

	pub fn deinit(self: BlockStructure, allocator: NeverFailingAllocator) void {
		allocator.free(self.structure);
	}

	pub fn addSubTerranian(self: BlockStructure, chunk: *ServerChunk, startingDepth: i32, minDepth: i32, slope: i32, soilCreep: f32, x: i32, y: i32, seed: *u64) i32 {
		var depth = startingDepth;
		var remainingSkippedBlocks = @as(i32, @intFromFloat(@as(f32, @floatFromInt(slope))*soilCreep)) - 1;
		for (self.structure) |blockStack| {
			const total = blockStack.min + main.random.nextIntBounded(u32, seed, @as(u32, 1) + blockStack.max - blockStack.min);
			for (0..total) |_| {
				if (remainingSkippedBlocks > 0) {
					remainingSkippedBlocks -= 1;
					continue;
				}
				if (chunk.liesInChunk(x, y, depth)) {
					chunk.updateBlockInGeneration(x, y, depth, blockStack.block);
				}
				depth -%= chunk.super.pos.voxelSize;
				if (depth -% minDepth <= 0)
					return depth +% chunk.super.pos.voxelSize;
			}
		}
		return depth +% chunk.super.pos.voxelSize;
	}
};

pub const TreeNode = union(enum) { // MARK: TreeNode
	leaf: struct {
		totalChance: f64 = 0,
		aliasTable: main.utils.AliasTable(Biome) = undefined,
	},
	branch: struct {
		lowerBorder: f32,
		upperBorder: f32,
		children: [3]*TreeNode,
	},

	pub fn init(arena: NeverFailingAllocator, currentSlice: []Biome, parameterShift: u5) *TreeNode {
		const self = arena.create(TreeNode);
		if (currentSlice.len <= 1 or parameterShift >= @bitSizeOf(Biome.GenerationProperties)) {
			self.* = .{.leaf = .{}};
			for (currentSlice) |biome| {
				self.leaf.totalChance += biome.chance;
			}
			self.leaf.aliasTable = .init(arena, currentSlice);
			return self;
		}
		var chanceLower: f32 = 0;
		var chanceMiddle: f32 = 0;
		var chanceUpper: f32 = 0;
		for (currentSlice) |*biome| {
			var properties: u32 = @as(u15, @bitCast(biome.properties));
			properties >>= parameterShift;
			properties = properties & 7;
			if (properties == 1) {
				chanceLower += biome.chance;
			} else if (properties == 4) {
				chanceUpper += biome.chance;
			} else {
				chanceMiddle += biome.chance;
			}
		}
		const totalChance = chanceLower + chanceMiddle + chanceUpper;
		chanceLower /= totalChance;
		chanceMiddle /= totalChance;
		chanceUpper /= totalChance;

		self.* = .{.branch = .{
			.lowerBorder = terrain.noise.ValueNoise.percentile(chanceLower),
			.upperBorder = terrain.noise.ValueNoise.percentile(chanceLower + chanceMiddle),
			.children = undefined,
		}};

		// Partition the slice:
		var lowerIndex: usize = undefined;
		var upperIndex: usize = undefined;
		{
			var lists: [3]main.ListUnmanaged(Biome) = .{
				.initCapacity(main.stackAllocator, currentSlice.len),
				.initCapacity(main.stackAllocator, currentSlice.len),
				.initCapacity(main.stackAllocator, currentSlice.len),
			};
			defer for (lists) |list| {
				list.deinit(main.stackAllocator);
			};
			for (currentSlice) |biome| {
				var properties: u32 = @as(u15, @bitCast(biome.properties));
				properties >>= parameterShift;
				const valueMap = [8]usize{1, 0, 1, 1, 2, 1, 1, 1};
				lists[valueMap[properties & 7]].appendAssumeCapacity(biome);
			}
			lowerIndex = lists[0].items.len;
			@memcpy(currentSlice[0..lowerIndex], lists[0].items);
			upperIndex = lowerIndex + lists[1].items.len;
			@memcpy(currentSlice[lowerIndex..upperIndex], lists[1].items);
			@memcpy(currentSlice[upperIndex..], lists[2].items);
		}

		self.branch.children[0] = TreeNode.init(arena, currentSlice[0..lowerIndex], parameterShift + 3);
		self.branch.children[1] = TreeNode.init(arena, currentSlice[lowerIndex..upperIndex], parameterShift + 3);
		self.branch.children[2] = TreeNode.init(arena, currentSlice[upperIndex..], parameterShift + 3);

		return self;
	}

	pub fn getBiome(self: *const TreeNode, seed: *u64, x: i32, y: i32, depth: usize) *const Biome {
		switch (self.*) {
			.leaf => |leaf| {
				var biomeSeed = main.random.initSeed2D(seed.*, main.vec.Vec2i{x, y});
				const result = leaf.aliasTable.sample(&biomeSeed);
				return result;
			},
			.branch => |branch| {
				const wavelength = main.server.world.?.chunkManager.terrainGenerationProfile.climateWavelengths[depth];
				const value = terrain.noise.ValueNoise.samplePoint2D(@as(f32, @floatFromInt(x))/wavelength, @as(f32, @floatFromInt(y))/wavelength, main.random.nextInt(u32, seed));
				var index: u2 = 0;
				if (value >= branch.lowerBorder) {
					if (value >= branch.upperBorder) {
						index = 2;
					} else {
						index = 1;
					}
				}
				return branch.children[index].getBiome(seed, x, y, depth + 1);
			},
		}
	}
};

// MARK: init/register
var finishedLoading: bool = false;
var biomes: main.ListUnmanaged(Biome) = .{};
var caveBiomes: main.ListUnmanaged(Biome) = .{};
var biomesById: std.StringHashMapUnmanaged(*Biome) = .{};
var biomesByIndex: main.ListUnmanaged(*Biome) = .{};
pub var byTypeBiomes: *TreeNode = undefined;

const UnfinishedSubBiomeData = struct {
	biomeId: []const u8,
	chance: f32,
	pub fn getItem(self: UnfinishedSubBiomeData) *const Biome {
		return getById(self.biomeId);
	}
};
var unfinishedSubBiomes: std.StringHashMapUnmanaged(main.ListUnmanaged(UnfinishedSubBiomeData)) = .{};

const UnfinishedTransitionBiomeData = struct {
	biomeId: []const u8,
	chance: f32,
	propertyMask: Biome.GenerationProperties,
	width: u8,
};
const TransitionBiome = struct {
	biome: *const Biome,
	chance: f32,
	propertyMask: Biome.GenerationProperties,
	width: u8,
};
var unfinishedTransitionBiomes: std.StringHashMapUnmanaged([]UnfinishedTransitionBiomeData) = .{};

pub fn init() void {
	const list = @import("simple_structures/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		SimpleStructureModel.registerGenerator(@field(list, decl.name));
	}
}

pub fn reset() void {
	finishedLoading = false;
	biomes = .{};
	caveBiomes = .{};
	biomesById = .{};
	biomesByIndex = .{};
	byTypeBiomes = undefined;
}

pub fn register(id: []const u8, paletteId: u32, zon: ZonElement) void {
	std.debug.assert(!finishedLoading);
	var biome: Biome = undefined;
	biome.init(id, paletteId, zon);
	if (biome.isCave) {
		caveBiomes.append(main.worldArena, biome);
		std.log.debug("Registered    cave biome: {d: >5} '{s}'", .{paletteId, id});
	} else {
		biomes.append(main.worldArena, biome);
		std.log.debug("Registered surface biome: {d: >5} '{s}'", .{paletteId, id});
	}
}

pub fn finishLoading() void {
	std.debug.assert(!finishedLoading);
	finishedLoading = true;
	var nonZeroBiomes: usize = biomes.items.len;
	for (0..biomes.items.len) |_i| {
		const i = biomes.items.len - _i - 1;
		if (biomes.items[i].chance == 0) {
			nonZeroBiomes -= 1;
			const biome = biomes.items[i];
			for (i..nonZeroBiomes) |j| {
				biomes.items[j] = biomes.items[j + 1];
			}
			biomes.items[nonZeroBiomes] = biome;
		}
	}
	byTypeBiomes = TreeNode.init(main.worldArena, biomes.items[0..nonZeroBiomes], 0);
	biomesByIndex.resize(main.worldArena, biomes.items.len + caveBiomes.items.len);
	biomesById.ensureTotalCapacity(main.worldArena.allocator, @intCast(biomes.items.len + caveBiomes.items.len)) catch unreachable;

	for (biomes.items) |*biome| {
		biomesById.putAssumeCapacity(biome.id, biome);
		biomesByIndex.items[biome.paletteId] = biome;
	}
	for (caveBiomes.items) |*biome| {
		biomesById.putAssumeCapacity(biome.id, biome);
		biomesByIndex.items[biome.paletteId] = biome;
	}
	var subBiomeIterator = unfinishedSubBiomes.iterator();
	while (subBiomeIterator.next()) |subBiomeData| {
		const subBiomeDataList = subBiomeData.value_ptr;
		defer subBiomeDataList.deinit(main.globalAllocator);
		const parentBiome = biomesById.get(subBiomeData.key_ptr.*) orelse {
			std.log.err("Couldn't find biome with id {s}. Cannot add sub-biomes.", .{subBiomeData.key_ptr.*});
			continue;
		};
		for (subBiomeDataList.items) |item| {
			parentBiome.subBiomeTotalChance += item.chance;
		}
		parentBiome.subBiomes = .initFromContext(main.worldArena, subBiomeDataList.items);
	}
	unfinishedSubBiomes.clearAndFree(main.globalAllocator.allocator);

	var transitionBiomeIterator = unfinishedTransitionBiomes.iterator();
	while (transitionBiomeIterator.next()) |transitionBiomeData| {
		const parentBiome = biomesById.get(transitionBiomeData.key_ptr.*) orelse unreachable;
		const transitionBiomes = transitionBiomeData.value_ptr.*;
		parentBiome.transitionBiomes = main.worldArena.alloc(TransitionBiome, transitionBiomes.len);
		for (parentBiome.transitionBiomes, transitionBiomes) |*res, src| {
			res.* = .{
				.biome = biomesById.get(src.biomeId) orelse {
					std.log.err("Skipping transition biome with unknown id {s}", .{src.biomeId});
					res.* = .{
						.biome = &biomes.items[0],
						.chance = 0,
						.propertyMask = .{},
						.width = 0,
					};
					continue;
				},
				.chance = src.chance,
				.propertyMask = src.propertyMask,
				.width = src.width,
			};
		}
		main.globalAllocator.free(transitionBiomes);
	}
	unfinishedTransitionBiomes.clearAndFree(main.globalAllocator.allocator);
}

pub fn hasRegistered(id: []const u8) bool {
	for (biomes.items) |*biome| {
		if (std.mem.eql(u8, biome.id, id)) {
			return true;
		}
	}
	for (caveBiomes.items) |*biome| {
		if (std.mem.eql(u8, biome.id, id)) {
			return true;
		}
	}
	return false;
}

pub fn getById(id: []const u8) *const Biome {
	std.debug.assert(finishedLoading);
	return biomesById.get(id) orelse {
		std.log.err("Couldn't find biome with id {s}. Replacing it with some other biome.", .{id});
		return &biomes.items[0];
	};
}

pub fn getByIndex(index: u32) ?*const Biome {
	std.debug.assert(finishedLoading);
	return biomesByIndex.items[index];
}

pub fn getPlaceholderBiome() *const Biome {
	return &biomes.items[0];
}

pub fn getCaveBiomes() []const Biome {
	return caveBiomes.items;
}

/// A checksum that can be used to check for changes i nthe biomes being used.
pub fn getBiomeCheckSum(seed: u64) u64 {
	var result: u64 = seed;
	for (biomes.items) |*biome| {
		result ^= biome.getCheckSum();
	}
	for (caveBiomes.items) |*biome| {
		result ^= biome.getCheckSum();
	}
	return result;
}

```

`src/server/terrain/cavebiomegen/RandomBiomeDistribution.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapFragment = terrain.CaveBiomeMap.CaveBiomeMapFragment;
const Biome = terrain.biomes.Biome;

// Generates the climate map using a fluidynamics simulation, with a circular heat distribution.

pub const id = "cubyz:random_biome";

pub const priority = 1024;

pub const generatorSeed = 765893678349;

pub const defaultState = .enabled;

var caveBiomes: []const Biome = undefined;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
	caveBiomes = terrain.biomes.getCaveBiomes();
}

pub fn generate(map: *CaveBiomeMapFragment, worldSeed: u64) void {
	// Select all the biomes that are within the given height range.
	var validBiomes = main.ListUnmanaged(*const Biome).initCapacity(main.stackAllocator, caveBiomes.len);
	defer validBiomes.deinit(main.stackAllocator);
	const worldPos = CaveBiomeMapFragment.rotateInverse(.{map.pos.wx, map.pos.wy, map.pos.wz});
	const marginDiv = 1024;
	const marginMulPositive: comptime_int = comptime CaveBiomeMapFragment.rotateInverse(.{marginDiv, 0, marginDiv})[2];
	const marginMulNegative: comptime_int = comptime CaveBiomeMapFragment.rotateInverse(.{0, marginDiv, 0})[2];
	for (caveBiomes) |*biome| {
		if (biome.minHeight < worldPos[2] +% CaveBiomeMapFragment.caveBiomeMapSize*marginMulPositive/marginDiv and biome.maxHeight > worldPos[2] +% CaveBiomeMapFragment.caveBiomeMapSize*marginMulNegative/marginDiv) {
			validBiomes.appendAssumeCapacity(biome);
		}
	}
	if (validBiomes.items.len == 0) {
		std.log.err("Couldn't find any cave biome on height {}. Using biome {s} instead.", .{worldPos[2], caveBiomes[0].id});
		validBiomes.appendAssumeCapacity(&caveBiomes[0]);
	}

	var seed = random.initSeed3D(worldSeed, .{map.pos.wx, map.pos.wy, map.pos.wz});
	var z: u31 = 0;
	while (z < CaveBiomeMapFragment.caveBiomeMapSize) : (z += CaveBiomeMapFragment.caveBiomeSize) {
		// Sort all biomes to the start that fit into the height region of the given z plane:
		var totalChance: f64 = 0;
		for (validBiomes.items) |b| {
			totalChance += b.chance;
		}
		if (totalChance == 0) {
			totalChance = 1;
		}
		var x: u31 = 0;
		while (x < CaveBiomeMapFragment.caveBiomeMapSize) : (x += CaveBiomeMapFragment.caveBiomeSize) {
			var y: u31 = 0;
			while (y < CaveBiomeMapFragment.caveBiomeMapSize) : (y += CaveBiomeMapFragment.caveBiomeSize) {
				const biomeWorldPos = CaveBiomeMapFragment.rotateInverse(.{map.pos.wx + x, map.pos.wy + y, map.pos.wz + z});
				for (0..2) |_map| {
					while (true) {
						var randomValue = random.nextDouble(&seed)*totalChance;
						var biome: *const Biome = undefined;
						var i: usize = 0;
						while (true) {
							biome = validBiomes.items[i];
							i += 1;
							randomValue -= biome.chance;
							if (randomValue < 0) break;
						}
						const index = CaveBiomeMapFragment.getIndex(x, y, z);
						map.biomeMap[index][_map] = biome;
						if (biome.minHeight < biomeWorldPos[2] + CaveBiomeMapFragment.caveBiomeSize*marginMulPositive/marginDiv and biome.maxHeight > biomeWorldPos[2] + CaveBiomeMapFragment.caveBiomeSize*marginMulNegative/marginDiv) {
							break;
						}
					}
				}
			}
		}
	}
}

```

`src/server/terrain/cavebiomegen/_list.zig`:

```zig
pub const RandomBiomeDistribution = @import("RandomBiomeDistribution.zig");

```

`src/server/terrain/cavegen/FractalCaveGenerator.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMapFragment = terrain.CaveMap.CaveMapFragment;
const InterpolatableCaveBiomeMapView = terrain.CaveBiomeMap.InterpolatableCaveBiomeMapView;
const vec = main.vec;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:fractal_cave";

pub const priority = 65536;

pub const generatorSeed = 0xb898ec9ce9d2ef37;

pub const defaultState = .enabled;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

const chunkShift = 5;
const chunkSize = 1 << chunkShift;
const range = 8*chunkSize;
const initialBranchLength = 64;
const splittingChance = 0.4;
const splitFactor = 1.0;
const zSplitReduction = 0.5; // To reduce splitting in z-direction.
const maxSplitLength = 128;
const branchChance = 0.4;
const minRadius = 2.0;
const maxInitialRadius = 5;
const heightVariance = 0.15;
const maxCaveHeight = 128;
const caveHeightWithMaxDensity = -512;
const maxCaveDensity = 1.0/32.0;

// TODO: Should probably use fixed point arithmetic to avoid crashes at the world border.

pub fn generate(map: *CaveMapFragment, worldSeed: u64) void {
	if (map.pos.voxelSize > 2) return;

	const biomeMap: InterpolatableCaveBiomeMapView = InterpolatableCaveBiomeMapView.init(main.stackAllocator, map.pos, CaveMapFragment.width*map.pos.voxelSize, CaveMapFragment.width*map.pos.voxelSize + maxCaveHeight*3);
	defer biomeMap.deinit();
	// Generate caves from all nearby chunks:
	var wx = map.pos.wx -% range;
	while (wx -% map.pos.wx -% CaveMapFragment.width*map.pos.voxelSize -% range < 0) : (wx +%= chunkSize) {
		var wy = map.pos.wy -% 2*range;
		while (wy -% map.pos.wy -% CaveMapFragment.width*map.pos.voxelSize -% range < 0) : (wy +%= chunkSize) {
			var wz = map.pos.wz -% 2*range;
			while (wz -% map.pos.wz -% CaveMapFragment.height*map.pos.voxelSize -% range < 0) : (wz +%= chunkSize) {
				var seed: u64 = random.initSeed3D(worldSeed, .{wx, wy, wz});
				considerCoordinates(wx, wy, wz, map, &biomeMap, &seed, worldSeed);
			}
		}
	}
}

fn generateSphere_(seed: *u64, map: *CaveMapFragment, relPos: Vec3f, radius: f32, comptime addTerrain: bool) void {
	const relX = relPos[0];
	const relY = relPos[1];
	const relZ = relPos[2];
	var xMin = @as(i32, @intFromFloat(relX - radius)) - 1;
	xMin = @max(xMin, 0);
	var xMax = @as(i32, @intFromFloat(relX + radius)) + 1;
	xMax = @min(xMax, CaveMapFragment.width*map.pos.voxelSize);
	var yMin = @as(i32, @intFromFloat(relY - radius)) - 1;
	yMin = @max(yMin, 0);
	var yMax = @as(i32, @intFromFloat(relY + radius)) + 1;
	yMax = @min(yMax, CaveMapFragment.width*map.pos.voxelSize);
	if (xMin >= xMax or yMin >= yMax or relZ - radius + 1 >= @as(f32, @floatFromInt(CaveMapFragment.height*map.pos.voxelSize)) or relZ + radius + 1 < 0) {
		return;
	}
	// Go through all blocks within range of the sphere center and remove them.
	var curX = xMin;
	while (curX < xMax) : (curX += map.pos.voxelSize) {
		const distToCenterX = (@as(f32, @floatFromInt(curX)) - relX)/radius;
		var curY = yMin;
		while (curY < yMax) : (curY += map.pos.voxelSize) {
			const distToCenterY = (@as(f32, @floatFromInt(curY)) - relY)/radius;
			const xyDistanceSquared = distToCenterX*distToCenterX + distToCenterY*distToCenterY;
			var zMin: i32 = @intFromFloat(relZ);
			var zMax: i32 = @intFromFloat(relZ);
			if (xyDistanceSquared < 0.9*0.9) {
				const zDistance = radius*@sqrt(0.9*0.9 - xyDistanceSquared);
				zMin = @intFromFloat(relZ - zDistance);
				zMax = @intFromFloat(relZ + zDistance);
				if (addTerrain) {
					map.addRange(curX, curY, zMin, zMax); // Add the center range in a single call.
				} else {
					map.removeRange(curX, curY, zMin, zMax); // Remove the center range in a single call.
				}
			}
			// Add some roughness at the upper cave walls:
			var curZ: i32 = zMax;
			while (curZ <= CaveMapFragment.height*map.pos.voxelSize) : (curZ += map.pos.voxelSize) {
				const distToCenterZ = (@as(f32, @floatFromInt(curZ)) - relZ)/radius;
				const distToCenter = distToCenterZ*distToCenterZ + xyDistanceSquared;
				if (distToCenter < 1) {
					// Add a small roughness parameter to make walls look a bit rough by filling only 5/6 of the blocks at the walls with air:
					if (random.nextIntBounded(u8, seed, 6) != 0) {
						if (addTerrain) {
							map.addRange(curX, curY, curZ, curZ + 1);
						} else {
							map.removeRange(curX, curY, curZ, curZ + 1);
						}
					}
				} else break;
			}
			// Add some roughness at the lower cave walls:
			curZ = zMin;
			while (curZ >= 0) : (curZ -= map.pos.voxelSize) {
				const distToCenterZ = (@as(f32, @floatFromInt(curZ)) - relZ)/radius;
				const distToCenter = distToCenterZ*distToCenterZ + xyDistanceSquared;
				if (distToCenter < 1) {
					// Add a small roughness parameter to make walls look a bit rough by filling only 5/6 of the blocks at the walls with air:
					if (random.nextIntBounded(u8, seed, 6) != 0) {
						if (addTerrain) {
							map.addRange(curX, curY, curZ, curZ + 1);
						} else {
							map.removeRange(curX, curY, curZ, curZ + 1);
						}
					}
				} else break;
			}
		}
	}
}

fn generateSphere(seed: *u64, map: *CaveMapFragment, relPos: Vec3f, radius: f32) void {
	if (radius < 0) {
		generateSphere_(seed, map, relPos, -radius, true);
	} else {
		generateSphere_(seed, map, relPos, radius, false);
	}
}

fn generateCaveBetween(_seed: u64, map: *CaveMapFragment, startRelPos: Vec3f, endRelPos: Vec3f, bias: Vec3f, startRadius: f32, endRadius: f32, randomness: f32) void {
	// Check if the segment can cross this chunk:
	const maxHeight = @max(@abs(startRadius), @abs(endRadius));
	const distance = vec.length(startRelPos - endRelPos);
	const maxFractalShift = distance*randomness;
	const safetyInterval = maxHeight + maxFractalShift;
	const min: Vec3i = @intFromFloat(@min(startRelPos, endRelPos) - @as(Vec3f, @splat(safetyInterval)));
	const max: Vec3i = @intFromFloat(@max(startRelPos, endRelPos) + @as(Vec3f, @splat(safetyInterval)));
	// Only divide further if the cave may go through the considered chunk.
	if (min[0] >= CaveMapFragment.width*map.pos.voxelSize or max[0] < 0) return;
	if (min[1] >= CaveMapFragment.width*map.pos.voxelSize or max[1] < 0) return;
	if (min[2] >= CaveMapFragment.height*map.pos.voxelSize or max[2] < 0) return;

	var seed = _seed;
	random.scrambleSeed(&seed);
	if (distance < @as(f32, @floatFromInt(map.pos.voxelSize))) {
		generateSphere(&seed, map, startRelPos, startRadius);
	} else { // Otherwise go to the next fractal level:
		const mid = (startRelPos + endRelPos)/@as(Vec3f, @splat(2)) + @as(Vec3f, @splat(maxFractalShift))*Vec3f{
			random.nextFloatSigned(&seed),
			random.nextFloatSigned(&seed),
			random.nextFloatSigned(&seed),
		} + bias/@as(Vec3f, @splat(4));
		var midRadius = (startRadius + endRadius)/2 + maxFractalShift*random.nextFloatSigned(&seed)*heightVariance;
		midRadius = std.math.sign(midRadius)*@max(@abs(midRadius), minRadius);
		generateCaveBetween(random.nextInt(u64, &seed), map, startRelPos, mid, bias/@as(Vec3f, @splat(4)), startRadius, midRadius, randomness);
		generateCaveBetween(random.nextInt(u64, &seed), map, mid, endRelPos, bias/@as(Vec3f, @splat(4)), midRadius, endRadius, randomness);
	}
}

fn generateCaveBetweenAndCheckBiomeProperties(_seed: u64, map: *CaveMapFragment, biomeMap: *const InterpolatableCaveBiomeMapView, startRelPos: Vec3f, endRelPos: Vec3f, bias: Vec3f, startRadius: f32, endRadius: f32, randomness: f32) void {
	// Check if the segment can cross this chunk:
	const maxHeight = @max(@abs(startRadius), @abs(endRadius));
	const distance = vec.length(startRelPos - endRelPos);
	const maxFractalShift = distance*randomness;
	const safetyInterval = maxHeight + maxFractalShift;
	const min: Vec3i = @intFromFloat(@min(startRelPos, endRelPos) - @as(Vec3f, @splat(safetyInterval)));
	const max: Vec3i = @intFromFloat(@max(startRelPos, endRelPos) + @as(Vec3f, @splat(safetyInterval)));
	// Only divide further if the cave may go through the considered chunk.
	if (min[0] >= CaveMapFragment.width*map.pos.voxelSize or max[0] < 0) return;
	if (min[1] >= CaveMapFragment.width*map.pos.voxelSize or max[1] < 0) return;
	if (min[2] >= CaveMapFragment.height*map.pos.voxelSize or max[2] < 0) return;

	const startRadiusFactor = biomeMap.getRoughBiome(map.pos.wx +% @as(i32, @intFromFloat(startRelPos[0])), map.pos.wy +% @as(i32, @intFromFloat(startRelPos[1])), map.pos.wz +% @as(i32, @intFromFloat(startRelPos[2])), false, undefined, false).caveRadiusFactor;
	const endRadiusFactor = biomeMap.getRoughBiome(map.pos.wx +% @as(i32, @intFromFloat(endRelPos[0])), map.pos.wy +% @as(i32, @intFromFloat(endRelPos[1])), map.pos.wz +% @as(i32, @intFromFloat(endRelPos[2])), false, undefined, false).caveRadiusFactor;
	generateCaveBetween(_seed, map, startRelPos, endRelPos, bias, startRadius*startRadiusFactor, endRadius*endRadiusFactor, randomness);
}

fn generateBranchingCaveBetween(_seed: u64, map: *CaveMapFragment, biomeMap: *const InterpolatableCaveBiomeMapView, startRelPos: Vec3f, endRelPos: Vec3f, bias: Vec3f, startRadius: f32, endRadius: f32, seedPos: Vec3f, branchLength: f32, randomness: f32, isStart: bool, isEnd: bool) void {
	const distance = vec.length(startRelPos - endRelPos);
	var seed = _seed;
	random.scrambleSeed(&seed);
	if (distance < 32) {
		// No more branches below that level to avoid crowded caves.
		generateCaveBetweenAndCheckBiomeProperties(random.nextInt(u64, &seed), map, biomeMap, startRelPos, endRelPos, bias, startRadius, endRadius, randomness);
		// Small chance to branch off:
		if (!isStart and random.nextFloat(&seed) < branchChance and branchLength > 8) {
			var newEndPos = startRelPos + Vec3f{
				branchLength*random.nextFloatSigned(&seed),
				branchLength*random.nextFloatSigned(&seed),
				branchLength*random.nextFloatSigned(&seed),
			};
			const distanceToSeedPoint = vec.length(newEndPos - seedPos);
			// Reduce distance to avoid cutoffs:
			if (distanceToSeedPoint > range - chunkSize) {
				newEndPos = seedPos + (newEndPos - seedPos)*@as(Vec3f, @splat((range - chunkSize)/distanceToSeedPoint));
			}
			const newStartRadius = (startRadius - minRadius)*random.nextFloat(&seed) + minRadius;
			const newBias = Vec3f{
				branchLength*random.nextFloatSigned(&seed),
				branchLength*random.nextFloatSigned(&seed),
				branchLength*random.nextFloatSigned(&seed)/2,
			};
			generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, startRelPos, newEndPos, newBias, newStartRadius, minRadius, seedPos, branchLength/2, @min(0.5/@sqrt(3.0) - 0.01, randomness + randomness*random.nextFloat(&seed)*random.nextFloat(&seed)), true, true);
		}
		return;
	}

	const maxFractalShift = distance*randomness;
	const weight: f32 = 0.25 + random.nextFloat(&seed)*0.5; // Do slightly random subdivision instead of binary subdivision, to avoid regular patterns.

	const w1 = (1 - weight)*(1 - weight);
	const w2 = weight*weight;
	// Small chance to generate a split:
	if (!isStart and !isEnd and distance < maxSplitLength and random.nextFloat(&seed) < splittingChance) {
		// Find a random direction perpendicular to the current cave direction:
		var splitXY: f32 = random.nextFloat(&seed) - 0.5;
		var splitZ: f32 = zSplitReduction*(random.nextFloat(&seed) - 0.5);
		// Normalize
		const length = @sqrt(splitXY*splitXY + splitZ*splitZ);
		splitXY /= length;
		splitZ /= length;
		// Calculate bias offsets:
		const biasLength = vec.length(bias);
		const offsetX = splitXY*splitFactor*distance*bias[1]/biasLength;
		const offsetY = splitXY*splitFactor*distance*bias[0]/biasLength;
		const offsetZ = splitZ*splitFactor*distance;

		const newBias1 = bias + Vec3f{offsetX, offsetY, offsetZ};
		const newBias2 = bias - Vec3f{offsetX, offsetY, offsetZ};

		const mid1 = startRelPos*@as(Vec3f, @splat(weight)) + endRelPos*@as(Vec3f, @splat(1 - weight)) + @as(Vec3f, @splat(maxFractalShift))*Vec3f{
			random.nextFloatSigned(&seed),
			random.nextFloatSigned(&seed),
			random.nextFloatSigned(&seed),
		} + newBias1*@as(Vec3f, @splat(weight*(1 - weight)));
		const mid2 = startRelPos*@as(Vec3f, @splat(weight)) + endRelPos*@as(Vec3f, @splat(1 - weight)) + @as(Vec3f, @splat(maxFractalShift))*Vec3f{
			random.nextFloatSigned(&seed),
			random.nextFloatSigned(&seed),
			random.nextFloatSigned(&seed),
		} + newBias2*@as(Vec3f, @splat(weight*(1 - weight)));

		var midRadius = @max(minRadius, (startRadius + endRadius)/2 + maxFractalShift*random.nextFloatSigned(&seed)*heightVariance);
		generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, startRelPos, mid1, newBias1*@as(Vec3f, @splat(w1)), startRadius, midRadius, seedPos, branchLength, randomness, isStart, false);
		generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, mid1, endRelPos, newBias1*@as(Vec3f, @splat(w2)), midRadius, endRadius, seedPos, branchLength, randomness, false, isEnd);
		// Do some tweaking to the radius before making the second part:
		const newStartRadius = (startRadius - minRadius)*random.nextFloat(&seed) + minRadius;
		const newEndRadius = (endRadius - minRadius)*random.nextFloat(&seed) + minRadius;
		midRadius = @max(minRadius, (newStartRadius + newEndRadius)/2 + maxFractalShift*random.nextFloatSigned(&seed)*heightVariance);
		generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, startRelPos, mid2, newBias2*@as(Vec3f, @splat(w1)), newStartRadius, midRadius, seedPos, branchLength, randomness, isStart, false);
		generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, mid2, endRelPos, newBias2*@as(Vec3f, @splat(w2)), midRadius, newEndRadius, seedPos, branchLength, randomness, false, isEnd);
		return;
	}
	const mid = startRelPos*@as(Vec3f, @splat(weight)) + endRelPos*@as(Vec3f, @splat(1 - weight)) + @as(Vec3f, @splat(maxFractalShift))*Vec3f{
		random.nextFloatSigned(&seed),
		random.nextFloatSigned(&seed),
		random.nextFloatSigned(&seed),
	} + bias*@as(Vec3f, @splat(weight*(1 - weight)));
	const midRadius = @max(minRadius, (startRadius + endRadius)/2 + maxFractalShift*random.nextFloatSigned(&seed)*heightVariance);
	generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, startRelPos, mid, bias*@as(Vec3f, @splat(w1)), startRadius, midRadius, seedPos, branchLength, randomness, isStart, false);
	generateBranchingCaveBetween(random.nextInt(u64, &seed), map, biomeMap, mid, endRelPos, bias*@as(Vec3f, @splat(w2)), midRadius, endRadius, seedPos, branchLength, randomness, false, isEnd);
}

fn considerCoordinates(wx: i32, wy: i32, wz: i32, map: *CaveMapFragment, biomeMap: *const InterpolatableCaveBiomeMapView, seed: *u64, worldSeed: u64) void {
	// Choose some in world coordinates to start generating:
	const startWorldPos = Vec3f{
		@floatFromInt(wx +% random.nextIntBounded(u8, seed, chunkSize) -% map.pos.wx),
		@floatFromInt(wy +% random.nextIntBounded(u8, seed, chunkSize) -% map.pos.wy),
		@floatFromInt(wz +% random.nextIntBounded(u8, seed, chunkSize) -% map.pos.wz),
	};

	// At z = caveHeightWithMaxDensity blocks the chance is saturated, while at maxCaveHeight the chance gets 0:
	if (random.nextFloat(seed) >= maxCaveDensity*@min(1, @as(f32, @floatFromInt(maxCaveHeight -% wz))/(maxCaveHeight - caveHeightWithMaxDensity))) return;

	var starters = 1 + random.nextIntBounded(u8, seed, 4);
	while (starters != 0) : (starters -= 1) {
		const endX = wx +% random.nextIntBounded(u31, seed, 2*range - 3*chunkSize) -% range +% chunkSize & ~@as(i32, chunkSize - 1);
		const endY = wy +% random.nextIntBounded(u31, seed, 2*range - 3*chunkSize) -% range +% chunkSize & ~@as(i32, chunkSize - 1);
		const endZ = wz +% random.nextIntBounded(u31, seed, 2*range - 3*chunkSize) -% range +% chunkSize & ~@as(i32, chunkSize - 1);
		seed.* = random.initSeed3D(worldSeed, .{endX, endY, endZ}); // Every chunk has the same start/destination position, to increase cave connectivity.
		const endWorldPos = Vec3f{
			@floatFromInt(endX +% random.nextIntBounded(u8, seed, chunkSize) -% map.pos.wx),
			@floatFromInt(endY +% random.nextIntBounded(u8, seed, chunkSize) -% map.pos.wy),
			@floatFromInt(endZ +% random.nextIntBounded(u8, seed, chunkSize) -% map.pos.wz),
		};
		const startRadius: f32 = random.nextFloat(seed)*maxInitialRadius + 2*minRadius;
		const endRadius: f32 = random.nextFloat(seed)*maxInitialRadius + 2*minRadius;
		const caveLength = vec.length(startWorldPos - endWorldPos);
		generateBranchingCaveBetween(random.nextInt(u64, seed), map, biomeMap, startWorldPos, endWorldPos, Vec3f{
			caveLength*random.nextFloatSigned(seed)/2,
			caveLength*random.nextFloatSigned(seed)/2,
			caveLength*random.nextFloatSigned(seed)/4,
		}, startRadius, endRadius, @floatFromInt(Vec3i{wx -% map.pos.wx, wy -% map.pos.wy, wz -% map.pos.wz}), initialBranchLength, 0.1, true, true);
	}
}

```

`src/server/terrain/cavegen/NoiseCaveGenerator.zig`:

```zig
const std = @import("std");
const sign = std.math.sign;

const main = @import("main");
const Array3D = main.utils.Array3D;
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMapFragment = terrain.CaveMap.CaveMapFragment;
const InterpolatableCaveBiomeMapView = terrain.CaveBiomeMap.InterpolatableCaveBiomeMapView;
const FractalNoise3D = terrain.noise.FractalNoise3D;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:noise_cave";

pub const priority = 65536;

pub const generatorSeed = 0x76490367012869;

pub const defaultState = .enabled;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

const scale = 64;
const interpolatedPart = 4;

fn getValue(noise: Array3D(f32), outerSizeShift: u5, relX: u31, relY: u31, relZ: u31) f32 {
	return noise.get(relX >> outerSizeShift, relY >> outerSizeShift, relZ >> outerSizeShift);
}

pub fn generate(map: *CaveMapFragment, worldSeed: u64) void {
	if (map.pos.voxelSize > 2) return;
	const biomeMap = InterpolatableCaveBiomeMapView.init(main.stackAllocator, map.pos, CaveMapFragment.width*map.pos.voxelSize, 0);
	defer biomeMap.deinit();
	const outerSize = @max(map.pos.voxelSize, interpolatedPart);
	const outerSizeShift = std.math.log2_int(u31, outerSize);
	const outerSizeFloat: f32 = @floatFromInt(outerSize);
	const noise = FractalNoise3D.generateAligned(main.stackAllocator, map.pos.wx, map.pos.wy, map.pos.wz, outerSize, CaveMapFragment.width*map.pos.voxelSize/outerSize + 1, CaveMapFragment.height*map.pos.voxelSize/outerSize + 1, CaveMapFragment.width*map.pos.voxelSize/outerSize + 1, worldSeed, scale);
	defer noise.deinit(main.stackAllocator);
	biomeMap.bulkInterpolateValue("caves", map.pos.wx, map.pos.wy, map.pos.wz, outerSize, noise, .addToMap, scale);
	var x: u31 = 0;
	while (x < map.pos.voxelSize*CaveMapFragment.width) : (x += outerSize) {
		var y: u31 = 0;
		while (y < map.pos.voxelSize*CaveMapFragment.width) : (y += outerSize) {
			var z: u31 = 0;
			while (z < map.pos.voxelSize*CaveMapFragment.height) : (z += outerSize) {
				const val000 = getValue(noise, outerSizeShift, x, y, z);
				const val001 = getValue(noise, outerSizeShift, x, y, z + outerSize);
				const val010 = getValue(noise, outerSizeShift, x, y + outerSize, z);
				const val011 = getValue(noise, outerSizeShift, x, y + outerSize, z + outerSize);
				const val100 = getValue(noise, outerSizeShift, x + outerSize, y, z);
				const val101 = getValue(noise, outerSizeShift, x + outerSize, y, z + outerSize);
				const val110 = getValue(noise, outerSizeShift, x + outerSize, y + outerSize, z);
				const val111 = getValue(noise, outerSizeShift, x + outerSize, y + outerSize, z + outerSize);
				// Test if they are all inside or all outside the cave to skip these cases:
				const measureForEquality = sign(val000) + sign(val001) + sign(val010) + sign(val011) + sign(val100) + sign(val101) + sign(val110) + sign(val111);
				if (measureForEquality == -8) {
					// No cave in here :)
					continue;
				}
				if (measureForEquality == 8) {
					// All cave in here :)
					var dx: u31 = 0;
					while (dx < outerSize) : (dx += map.pos.voxelSize) {
						var dy: u31 = 0;
						while (dy < outerSize) : (dy += map.pos.voxelSize) {
							map.removeRange(x + dx, y + dy, z, z + outerSize);
						}
					}
				} else {
					// Uses trilinear interpolation for the details.
					// Luckily due to the blocky nature of the game there is no visible artifacts from it.
					var dx: u31 = 0;
					while (dx < outerSize) : (dx += map.pos.voxelSize) {
						var dy: u31 = 0;
						while (dy < outerSize) : (dy += map.pos.voxelSize) {
							const ix = @as(f32, @floatFromInt(dx))/outerSizeFloat;
							const iy = @as(f32, @floatFromInt(dy))/outerSizeFloat;
							const lowerVal = ((1 - ix)*(1 - iy)*val000 + (1 - ix)*iy*val010 + ix*(1 - iy)*val100 + ix*iy*val110);
							const upperVal = ((1 - ix)*(1 - iy)*val001 + (1 - ix)*iy*val011 + ix*(1 - iy)*val101 + ix*iy*val111);
							// TODO: Determine the range that needs to be removed, and remove it in one go.
							if (upperVal*lowerVal > 0) { // All z values have the same sign → the entire column is the same.
								if (upperVal > 0) {
									// All cave in here :)
									map.removeRange(x + dx, y + dy, z, z + outerSize);
								} else {
									// No cave in here :)
								}
							} else {
								// Could be more efficient, but I'm lazy right now and I'll just go through the entire range:
								var dz: u31 = 0;
								while (dz < outerSize) : (dz += map.pos.voxelSize) {
									const iz = @as(f32, @floatFromInt(dz))/outerSizeFloat;
									const val = (1 - iz)*lowerVal + iz*upperVal;
									if (val > 0)
										map.removeRange(x + dx, y + dy, z + dz, z + dz + map.pos.voxelSize);
								}
							}
						}
					}
				}
			}
		}
	}
}

```

`src/server/terrain/cavegen/SurfaceGenerator.zig`:

```zig
const std = @import("std");
const sign = std.math.sign;

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMapFragment = terrain.CaveMap.CaveMapFragment;
const SurfaceMap = terrain.SurfaceMap;
const MapFragment = SurfaceMap.MapFragment;
const InterpolatableCaveBiomeMapView = terrain.CaveBiomeMap.InterpolatableCaveBiomeMapView;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:surface";

pub const priority = 131072;

pub const generatorSeed = 0x7658930674389;

pub const defaultState = .enabled;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

pub fn generate(map: *CaveMapFragment, worldSeed: u64) void {
	_ = worldSeed;
	const width = CaveMapFragment.width*map.pos.voxelSize;
	const biomeMap = InterpolatableCaveBiomeMapView.init(main.stackAllocator, map.pos, width, 0);
	defer biomeMap.deinit();
	var x: u31 = 0;
	while (x < width) : (x += map.pos.voxelSize) {
		var y: u31 = 0;
		while (y < width) : (y += map.pos.voxelSize) {
			const height = biomeMap.getSurfaceHeight(map.pos.wx + x, map.pos.wy + y);
			const smallestHeight: i32 = @min(
				biomeMap.getSurfaceHeight(map.pos.wx +% x +% 1, map.pos.wy +% y),
				biomeMap.getSurfaceHeight(map.pos.wx +% x, map.pos.wy +% y +% 1),
				biomeMap.getSurfaceHeight(map.pos.wx +% x -% 1, map.pos.wy +% y),
				biomeMap.getSurfaceHeight(map.pos.wx +% x, map.pos.wy +% y -% 1),
				height,
			);
			const relativeHeight: i32 = height -% map.pos.wz;
			map.removeRange(x, y, relativeHeight, CaveMapFragment.height*map.pos.voxelSize);
			if (smallestHeight < 1) { // Seal off caves that intersect the ocean floor.
				map.addRange(x, y, smallestHeight -% 1 -% map.pos.wz, relativeHeight);
			}
		}
	}
}

```

`src/server/terrain/cavegen/_list.zig`:

```zig
pub const FractalCaveGenerator = @import("FractalCaveGenerator.zig");
pub const NoiseCaveGenerator = @import("NoiseCaveGenerator.zig");
pub const SurfaceGenerator = @import("SurfaceGenerator.zig");

```

`src/server/terrain/chunkgen/CrystalGenerator.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMap = terrain.CaveMap;
const CaveBiomeMap = terrain.CaveBiomeMap;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:crystal";

pub const priority = 65537;

pub const generatorSeed = 0x9b450ffb0d415317;

pub const defaultState = .enabled;

const crystalColor = [_][]const u8{
	"red", "orange", "yellow", "lime", "green", "cyan", "aqua", "blue", "pink", "magenta", "violet", // 8 Base colors
	"crimson", "viridian", "indigo", "purple", "brown", // 5 darker colors
	"white", "grey", "dark_grey", "black", // 4 grayscale colors
};
var glowCrystals: [crystalColor.len]u16 = undefined;

const surfaceDist = 2; // How far away crystal can spawn from the wall.

pub fn init(parameters: ZonElement) void {
	_ = parameters;
	// Find all the glow crystal ores:
	inline for (crystalColor[0..], glowCrystals[0..]) |color, *block| {
		const oreID = "cubyz:glow_crystal/" ++ color;
		block.* = main.blocks.getTypeById(oreID);
	}
}

pub fn generate(worldSeed: u64, chunk: *main.chunk.ServerChunk, caveMap: CaveMap.CaveMapView, biomeMap: CaveBiomeMap.CaveBiomeMapView) void {
	if (chunk.super.pos.voxelSize > 2) return;
	const size = chunk.super.width;
	// Generate caves from all nearby chunks:
	var x = chunk.super.pos.wx -% main.chunk.chunkSize;
	while (x != chunk.super.pos.wx +% size +% main.chunk.chunkSize) : (x +%= main.chunk.chunkSize) {
		var y = chunk.super.pos.wy -% main.chunk.chunkSize;
		while (y != chunk.super.pos.wy +% size +% main.chunk.chunkSize) : (y +%= main.chunk.chunkSize) {
			var z = chunk.super.pos.wz -% main.chunk.chunkSize;
			while (z != chunk.super.pos.wz +% size +% main.chunk.chunkSize) : (z +%= main.chunk.chunkSize) {
				var seed = random.initSeed3D(worldSeed, .{x, y, z});
				considerCoordinates(x, y, z, chunk, caveMap, biomeMap, &seed);
			}
		}
	}
}

fn distSqr(x: f32, y: f32, z: f32) f32 {
	return x*x + y*y + z*z;
}

fn considerCrystal(x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, seed: *u64, useNeedles: bool, types: []u16) void {
	const relX: f32 = @floatFromInt(x -% chunk.super.pos.wx);
	const relY: f32 = @floatFromInt(y -% chunk.super.pos.wy);
	const relZ: f32 = @floatFromInt(z -% chunk.super.pos.wz);
	const typ = types[random.nextIntBounded(u32, seed, @as(u32, @intCast(types.len)))];
	// Make some crystal spikes in random directions:
	var spikes: f32 = 4;
	if (useNeedles) spikes += 2;
	spikes += random.nextFloat(seed)*spikes; // Use somewhat between spikes and 2*spikes spikes.
	var _spike: f32 = 0;
	while (_spike < spikes) : (_spike += 1) {
		const length = 8 + random.nextFloat(seed)*24;
		// Choose a random direction:
		const theta = 2*std.math.pi*random.nextFloat(seed);
		const phi = std.math.acos(1 - 2*random.nextFloat(seed));
		const delX = @sin(phi)*@cos(theta);
		const delY = @sin(phi)*@sin(theta);
		const delZ = @cos(phi);
		var j: f32 = 0;
		while (j < length) {
			const x2 = relX + delX*j;
			const y2 = relY + delY*j;
			const z2 = relZ + delZ*j;
			var size: f32 = 0;
			if (useNeedles)
				size = 0.7
			else
				size = 12*(length - j)/length/spikes;
			const xMin: i32 = @intFromFloat(x2 - size);
			const xMax: i32 = @intFromFloat(x2 + size);
			const yMin: i32 = @intFromFloat(y2 - size);
			const yMax: i32 = @intFromFloat(y2 + size);
			const zMin: i32 = @intFromFloat(z2 - size);
			const zMax: i32 = @intFromFloat(z2 + size);
			var x3: i32 = xMin;
			while (x3 <= xMax) : (x3 += 1) {
				var y3: i32 = yMin;
				while (y3 <= yMax) : (y3 += 1) {
					var z3: i32 = zMin;
					while (z3 <= zMax) : (z3 += 1) {
						const dist = distSqr(@as(f32, @floatFromInt(x3)) - x2, @as(f32, @floatFromInt(y3)) - y2, @as(f32, @floatFromInt(z3)) - z2);
						if (dist < size*size) {
							if (x3 >= 0 and x3 < chunk.super.width and y3 >= 0 and y3 < chunk.super.width and z3 >= 0 and z3 < chunk.super.width) {
								const block: main.blocks.Block = chunk.getBlock(x3, y3, z3);
								if (block.typ == 0 or block.degradable()) {
									chunk.updateBlockInGeneration(x3, y3, z3, .{.typ = typ, .data = 0});
								}
							}
						}
					}
				}
			}
			if (size > 2) size = 2;
			j += size/2; // Make sure there are no crystal bits floating in the air.
			if (size < 0.5) break; // Also preventing floating crystal bits.
		}
	}
}

fn considerCoordinates(x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMap.CaveMapView, biomeMap: CaveBiomeMap.CaveBiomeMapView, seed: *u64) void {
	const oldSeed = seed.*;
	const crystalSpawns = biomeMap.getBiomeAndSeed(x +% main.chunk.chunkSize/2 -% chunk.super.pos.wx, y +% main.chunk.chunkSize/2 -% chunk.super.pos.wy, z +% main.chunk.chunkSize/2 -% chunk.super.pos.wz, true, seed).crystals;
	random.scrambleSeed(seed);
	var differendColors: u32 = 1;
	if (random.nextInt(u1, seed) != 0) {
		// ¹⁄₄ Chance that a cave has multiple crystals.
		while (random.nextInt(u1, seed) != 0 and differendColors < 32) {
			differendColors += 1; // Exponentially diminishing chance to have more differend crystals per cavern.
		}
	}
	var _colors: [32]u16 = undefined;
	const colors = _colors[0..differendColors];
	for (colors) |*color| {
		color.* = glowCrystals[random.nextIntBounded(u16, seed, glowCrystals.len)];
	}
	const useNeedles = random.nextInt(u1, seed) != 0; // Different crystal type.
	// Spawn the crystals using the old position specific seed:
	seed.* = oldSeed;
	for (0..crystalSpawns) |_| {
		// Choose some in world coordinates to start generating:
		const worldX = x + random.nextIntBounded(u31, seed, main.chunk.chunkSize);
		const worldY = y + random.nextIntBounded(u31, seed, main.chunk.chunkSize);
		const worldZ = z + random.nextIntBounded(u31, seed, main.chunk.chunkSize);
		const relX = worldX -% chunk.super.pos.wx;
		const relY = worldY -% chunk.super.pos.wy;
		const relZ = worldZ -% chunk.super.pos.wz;
		if (caveMap.isSolid(relX, relY, relZ)) { // Only start crystal in solid blocks
			// Only start crystal when they are close to the surface (±SURFACE_DIST blocks)
			if ((worldX - x >= surfaceDist and !caveMap.isSolid(relX - surfaceDist, relY, relZ)) or (worldX - x < main.chunk.chunkSize - surfaceDist and !caveMap.isSolid(relX + surfaceDist, relY, relZ)) or (worldY - y >= surfaceDist and !caveMap.isSolid(relX, relY - surfaceDist, relZ)) or (worldY - y < main.chunk.chunkSize - surfaceDist and !caveMap.isSolid(relX, relY + surfaceDist, relZ)) or (worldZ - z >= surfaceDist and !caveMap.isSolid(relX, relY, relZ - surfaceDist)) or (worldZ - z < main.chunk.chunkSize - surfaceDist and !caveMap.isSolid(relX, relY, relZ + surfaceDist))) {
				// Generate the crystal:
				considerCrystal(worldX, worldY, worldZ, chunk, seed, useNeedles, colors);
			}
		}
	}
}

```

`src/server/terrain/chunkgen/OreGenerator.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMap = terrain.CaveMap;
const CaveBiomeMap = terrain.CaveBiomeMap;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:ore";

pub const priority = 32768;

pub const generatorSeed = 0x88773787bc9e0105;

pub const defaultState = .enabled;

var ores: []main.blocks.Ore = undefined;

// TODO: Idea:
// Add a RotationMode that allows you to overlay the ore texture onto a regular block to get more ore-in-stone-types for free.

pub fn init(parameters: ZonElement) void {
	_ = parameters;
	ores = main.blocks.ores.items;
}

// Works basically similar to cave generation, but considers a lot less chunks and has a few other differences.
pub fn generate(worldSeed: u64, chunk: *main.chunk.ServerChunk, caveMap: CaveMap.CaveMapView, biomeMap: CaveBiomeMap.CaveBiomeMapView) void {
	_ = caveMap;
	_ = biomeMap;
	if (chunk.super.pos.voxelSize != 1) return;
	const cx = chunk.super.pos.wx >> main.chunk.chunkShift;
	const cy = chunk.super.pos.wy >> main.chunk.chunkShift;
	const cz = chunk.super.pos.wz >> main.chunk.chunkShift;
	// Generate caves from all nearby chunks:
	var x = cx - 1;
	while (x < cx + 1) : (x +%= 1) {
		var y = cy - 1;
		while (y < cy + 1) : (y +%= 1) {
			var z = cz - 1;
			while (z < cz + 1) : (z +%= 1) {
				const seed = random.initSeed3D(worldSeed, .{x, y, z});
				const relX: f32 = @floatFromInt(x - cx << main.chunk.chunkShift);
				const relY: f32 = @floatFromInt(y - cy << main.chunk.chunkShift);
				const relZ: f32 = @floatFromInt(z - cz << main.chunk.chunkShift);
				for (ores) |*ore| {
					if (ore.maxHeight <= z << main.chunk.chunkShift or ore.minHeight > z << main.chunk.chunkShift) continue;
					considerCoordinates(ore, relX, relY, relZ, chunk, seed);
				}
			}
		}
	}
}

fn considerCoordinates(ore: *const main.blocks.Ore, relX: f32, relY: f32, relZ: f32, chunk: *main.chunk.ServerChunk, startSeed: u64) void {
	const chunkSizeFloat: f32 = @floatFromInt(main.chunk.chunkSize);
	// Compose the seeds from some random stats of the ore. They generally shouldn't be the same for two different ores. TODO: Give each block a hash function (id based) that can be used in cases like this.
	var seed = startSeed ^ ore.seed;
	// Determine how many veins of this type start in this chunk. The number depends on parameters set for the specific ore:
	const veins: u32 = @intFromFloat(random.nextFloat(&seed)*ore.veins*2);
	for (0..veins) |_| {
		// Choose some in world coordinates to start generating:
		const veinRelX = relX + random.nextFloat(&seed)*chunkSizeFloat;
		const veinRelY = relY + random.nextFloat(&seed)*chunkSizeFloat;
		const veinRelZ = relZ + random.nextFloat(&seed)*chunkSizeFloat;
		// Choose a random volume and create a radius from that:
		const size = (random.nextFloat(&seed) + 0.5)*ore.size;
		const expectedVolume = 2*size/ore.density; // Double the volume, because later the density is actually halfed.
		const radius = std.math.cbrt(expectedVolume*3/4/std.math.pi);
		var xMin: i32 = @intFromFloat(veinRelX - radius);
		var xMax: i32 = @intFromFloat(@ceil(veinRelX + radius));
		var yMin: i32 = @intFromFloat(veinRelY - radius);
		var yMax: i32 = @intFromFloat(@ceil(veinRelY + radius));
		xMin = @max(xMin, 0);
		xMax = @min(xMax, chunk.super.width);
		yMin = @max(yMin, 0);
		yMax = @min(yMax, chunk.super.width);

		var veinSeed = random.nextInt(u64, &seed);
		var curX = xMin;
		while (curX < xMax) : (curX += 1) {
			const distToCenterX = (@as(f32, @floatFromInt(curX)) - veinRelX)/radius;
			var curY = yMin;
			while (curY < yMax) : (curY += 1) {
				const distToCenterY = (@as(f32, @floatFromInt(curY)) - veinRelY)/radius;
				const xyDistSqr = distToCenterX*distToCenterX + distToCenterY*distToCenterY;
				if (xyDistSqr > 1) continue;
				const zDistance = radius*@sqrt(1 - xyDistSqr);
				var zMin: i32 = @intFromFloat(veinRelZ - zDistance);
				var zMax: i32 = @intFromFloat(@ceil(veinRelZ + zDistance));
				zMin = @max(zMin, 0);
				zMax = @min(zMax, chunk.super.width);
				var curZ = zMin;
				while (curZ < zMax) : (curZ += 1) {
					const distToCenterZ = (@as(f32, @floatFromInt(curZ)) - veinRelZ)/radius;
					const distSqr = xyDistSqr + distToCenterZ*distToCenterZ;
					if (distSqr < 1) {
						// Add some roughness. The ore density gets smaller at the edges:
						if ((1 - distSqr)*ore.density >= random.nextFloat(&veinSeed)) {
							const stoneBlock = chunk.getBlock(curX, curY, curZ);
							if (chunk.getBlock(curX, curY, curZ).allowOres()) {
								chunk.updateBlockInGeneration(curX, curY, curZ, .{.typ = ore.blockType, .data = stoneBlock.typ});
							}
						}
					}
				}
			}
		}
	}
}

```

`src/server/terrain/chunkgen/StructureGenerator.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMap = terrain.CaveMap;
const CaveBiomeMap = terrain.CaveBiomeMap;
const noise = terrain.noise;
const Biome = terrain.biomes.Biome;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:vegetation";

pub const priority = 131072;

pub const generatorSeed = 0x2026b65487da9226;

pub const defaultState = .enabled;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

pub fn generate(_: u64, chunk: *main.chunk.ServerChunk, caveMap: CaveMap.CaveMapView, biomeMap: CaveBiomeMap.CaveBiomeMapView) void {
	const structureMap = terrain.StructureMap.getOrGenerateFragment(chunk.super.pos.wx, chunk.super.pos.wy, chunk.super.pos.wz, chunk.super.pos.voxelSize);
	structureMap.generateStructuresInChunk(chunk, caveMap, biomeMap);
}

```

`src/server/terrain/chunkgen/TerrainGenerator.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveMap = terrain.CaveMap;
const CaveBiomeMap = terrain.CaveBiomeMap;
const Biome = terrain.biomes.Biome;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:terrain";

pub const priority = 1024; // Within Cubyz the first to be executed, but mods might want to come before that for whatever reason.

pub const generatorSeed = 0x65c7f9fdc0641f94;

pub const defaultState = .enabled;

var air: main.blocks.Block = undefined;
var stone: main.blocks.Block = undefined;
var water: main.blocks.Block = undefined;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
	air = main.blocks.parseBlock("cubyz:air");
	stone = main.blocks.parseBlock("cubyz:slate/base");
	water = main.blocks.parseBlock("cubyz:water");
}

pub fn generate(worldSeed: u64, chunk: *main.chunk.ServerChunk, caveMap: CaveMap.CaveMapView, biomeMap: CaveBiomeMap.CaveBiomeMapView) void {
	if (chunk.super.pos.voxelSize >= 8) {
		var maxHeight: i32 = 0;
		var minHeight: i32 = std.math.maxInt(i32);
		var dx: i32 = -1;
		while (dx < main.chunk.chunkSize + 1) : (dx += 1) {
			var dy: i32 = -1;
			while (dy < main.chunk.chunkSize + 1) : (dy += 1) {
				const height = biomeMap.getSurfaceHeight(chunk.super.pos.wx +% dx*chunk.super.pos.voxelSize, chunk.super.pos.wy +% dy*chunk.super.pos.voxelSize);
				maxHeight = @max(maxHeight, height);
				minHeight = @min(minHeight, height - chunk.super.pos.voxelSize);
			}
		}
		if (minHeight > chunk.super.pos.wz +| chunk.super.width) {
			chunk.super.data.fillUniform(stone);
			return;
		}
		if (maxHeight < chunk.super.pos.wz) {
			chunk.super.data.fillUniform(air);
			return;
		}
	}
	const voxelSizeShift = @ctz(chunk.super.pos.voxelSize);
	var x: u31 = 0;
	while (x < chunk.super.width) : (x += chunk.super.pos.voxelSize) {
		var y: u31 = 0;
		while (y < chunk.super.width) : (y += chunk.super.pos.voxelSize) {
			const heightData = caveMap.getHeightData(x, y);
			var zBiome: i32 = 0;
			while (zBiome < chunk.super.width) {
				var biomeHeight: i32 = chunk.super.width - zBiome;
				var baseSeed: u64 = undefined;
				const biome = biomeMap.getBiomeColumnAndSeed(x, y, zBiome, true, &baseSeed, &biomeHeight);
				defer zBiome = chunk.startIndex(zBiome + biomeHeight - 1 + chunk.super.pos.voxelSize);
				var z: i32 = @min(chunk.super.width - chunk.super.pos.voxelSize, chunk.startIndex(zBiome + biomeHeight - 1));
				while (z >= zBiome) : (z -= chunk.super.pos.voxelSize) {
					const mask = @as(u64, 1) << @intCast(z >> voxelSizeShift);
					if (heightData & mask != 0) {
						const cardinalDirections = [_]Vec3i{
							Vec3i{1, 0, 0},
							Vec3i{-1, 0, 0},
							Vec3i{0, 1, 0},
							Vec3i{0, -1, 0},
						};

						const surfaceBlock = caveMap.findTerrainChangeAbove(x, y, z) - chunk.super.pos.voxelSize;
						var maxUp: i32 = 0;
						var maxDown: i32 = 0;
						for (cardinalDirections) |direction| {
							const move = direction*@as(Vec3i, @splat(@intCast(chunk.super.pos.voxelSize)));
							if (caveMap.isSolid(x + move[0], y + move[1], z + move[2])) {
								const diff = caveMap.findTerrainChangeAbove(x + move[0], y + move[1], z + move[2]) - chunk.super.pos.voxelSize - surfaceBlock;
								maxUp = @max(maxUp, diff >> chunk.super.voxelSizeShift);
							} else {
								const diff = caveMap.findTerrainChangeBelow(x + move[0], y + move[1], z + move[2]) - surfaceBlock;
								maxDown = @max(maxDown, -diff >> chunk.super.voxelSizeShift);
							}
						}
						const slope = @min(maxUp, maxDown);

						const soilCreep: f32 = biome.soilCreep;
						var bseed: u64 = random.initSeed3D(worldSeed, .{chunk.super.pos.wx + x, chunk.super.pos.wy + y, chunk.super.pos.wz + z});
						const airBlockBelow = caveMap.findTerrainChangeBelow(x, y, z);
						// Add the biomes surface structure:
						z = @min(z + chunk.super.pos.voxelSize, biome.structure.addSubTerranian(chunk, surfaceBlock, @max(airBlockBelow, zBiome - 1), slope, soilCreep, x, y, &bseed));
						z -= chunk.super.pos.voxelSize;
						if (z < zBiome) break;
						if (z > airBlockBelow) {
							const zMin = @max(airBlockBelow + 1, zBiome);
							if (biome.stripes.len == 0) {
								chunk.updateBlockColumnInGeneration(x, y, zMin, z, biome.stoneBlock);
								z = zMin;
							} else {
								while (z >= zMin) : (z -= chunk.super.pos.voxelSize) {
									var block = biome.stoneBlock;
									var seed = baseSeed;
									for (biome.stripes) |stripe| {
										const pos: Vec3d = .{
											@as(f64, @floatFromInt(x + chunk.super.pos.wx)),
											@as(f64, @floatFromInt(y + chunk.super.pos.wy)),
											@as(f64, @floatFromInt(z + chunk.super.pos.wz)),
										};
										var d: f64 = 0;
										if (stripe.direction) |direction| {
											d = vec.dot(direction, pos);
										} else {
											const dx = main.random.nextDoubleSigned(&seed);
											const dy = main.random.nextDoubleSigned(&seed);
											const dz = main.random.nextDoubleSigned(&seed);
											const dir: Vec3d = .{dx, dy, dz};
											d = vec.dot(vec.normalize(dir), pos);
										}

										const distance = (stripe.maxDistance - stripe.minDistance)*main.random.nextDouble(&seed) + stripe.minDistance;

										const offset = (stripe.maxOffset - stripe.minOffset)*main.random.nextDouble(&seed) + stripe.minOffset;

										const width = (stripe.maxWidth - stripe.minWidth)*main.random.nextDouble(&seed) + stripe.minWidth;

										if (@mod(d + offset, distance) < width) {
											block = stripe.block;
											break;
										}
									}
									chunk.updateBlockInGeneration(x, y, z, block);
								}
								z += chunk.super.pos.voxelSize;
							}
						}
					} else {
						const surface = biomeMap.getSurfaceHeight(x + chunk.super.pos.wx, y + chunk.super.pos.wy) - (chunk.super.pos.voxelSize - 1) -% chunk.super.pos.wz;
						const oceanHeight = 0 -% chunk.super.pos.wz;
						const airVolumeStart = caveMap.findTerrainChangeBelow(x, y, z) + chunk.super.pos.voxelSize;
						const zStart = @max(airVolumeStart, zBiome);
						if (z < surface or zStart >= oceanHeight) {
							chunk.updateBlockColumnInGeneration(x, y, zStart, z, .{.typ = 0, .data = 0});
						} else {
							if (z >= oceanHeight) {
								chunk.updateBlockColumnInGeneration(x, y, oceanHeight, z, .{.typ = 0, .data = 0});
								z = oceanHeight - chunk.super.pos.voxelSize;
							}
							chunk.updateBlockColumnInGeneration(x, y, zStart, z, water);
						}
						z = zStart;
					}
				}
			}
		}
	}
}

```

`src/server/terrain/chunkgen/_list.zig`:

```zig
pub const CrystalGenerator = @import("CrystalGenerator.zig");
pub const OreGenerator = @import("OreGenerator.zig");
pub const TerrainGenerator = @import("TerrainGenerator.zig");
pub const StructureGenerator = @import("StructureGenerator.zig");

```

`src/server/terrain/climategen/NoiseBasedVoronoi.zig`:

```zig
const std = @import("std");

const build_options = @import("build_options");

const main = @import("main");
const Array2D = main.utils.Array2D;
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const ClimateMapFragment = terrain.ClimateMap.ClimateMapFragment;
const BiomeSample = terrain.ClimateMap.BiomeSample;
const Biome = terrain.biomes.Biome;
const TreeNode = terrain.biomes.TreeNode;
const vec = main.vec;
const Vec2i = vec.Vec2i;
const Vec2f = vec.Vec2f;

const NeverFailingAllocator = main.heap.NeverFailingAllocator;

// Generates the climate map using a fluidynamics simulation, with a circular heat distribution.

pub const id = "cubyz:noise_based_voronoi";

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

pub fn generateMapFragment(map: *ClimateMapFragment, worldSeed: u64) void {
	var seed: u64 = worldSeed;

	const generator = GenerationStructure.init(main.stackAllocator, map.pos.wx, map.pos.wy, ClimateMapFragment.mapSize, ClimateMapFragment.mapSize, terrain.biomes.byTypeBiomes, seed);
	defer generator.deinit(main.stackAllocator);

	generator.toMap(map, ClimateMapFragment.mapSize, ClimateMapFragment.mapSize, worldSeed);

	// TODO: Remove debug image:
	if (!build_options.isTaggedRelease) {
		const image = main.graphics.Image.init(main.stackAllocator, @intCast(map.map.len), @intCast(map.map[0].len));
		defer image.deinit(main.stackAllocator);
		var x: u31 = 0;
		while (x < map.map.len) : (x += 1) {
			var y: u31 = 0;
			while (y < map.map[0].len) : (y += 1) {
				const bp = map.map[x][y];
				seed = std.hash.Adler32.hash(bp.biome.id) ^ 4371741;
				image.setRGB(x, y, @bitCast(0xff000000 | main.random.nextInt(u32, &seed)));
			}
		}
		image.exportToFile("test.png") catch {};
	}
}

const BiomePoint = struct {
	biome: *const Biome,
	height: f32,
	pos: Vec2i = .{0, 0},
	weight: f32 = 1,
	radius: f32,

	fn voronoiDistanceFunction(self: @This(), pos: Vec2i) f32 {
		const len: f32 = @sqrt(vec.lengthSquare(@as(Vec2f, @floatFromInt(self.pos -% pos))));
		const result = len*self.weight;
		return result;
	}

	pub fn lessThan(lhs: @This(), rhs: @This()) bool {
		return lhs.pos[0] < rhs.pos[0];
	}
};

const maxBiomeRadius = 2048;

const chunkSize = maxBiomeRadius;
const Chunk = struct {
	wx: i32,
	wy: i32,
	biomesSortedByX: []BiomePoint,
	maxBiomeRadius: i32,

	fn getStartCoordinate(minX: i32, biomesSortedByX: []BiomePoint) usize {
		// TODO: Should this be vectorized by storing the x-coordinate in a seperate []u8?
		var start: usize = 0;
		var end: usize = biomesSortedByX.len;
		while (end - start > 16) {
			const mid = (start + end)/2 - 1;
			if (biomesSortedByX[mid].pos[0] -% minX < 0) {
				start = mid + 1;
			} else {
				end = mid + 1;
			}
		}
		return start;
	}

	fn checkIfBiomeIsValid(x: i32, y: i32, biomeRadius: f32, biomesSortedByX: []BiomePoint, chunkLocalMaxBiomeRadius: i32) bool {
		const ceiledBiomeRadius: i32 = @intFromFloat(@ceil(biomeRadius));
		const minX = x -% ceiledBiomeRadius -% chunkLocalMaxBiomeRadius;
		const maxX = x +% ceiledBiomeRadius +% chunkLocalMaxBiomeRadius;
		const i: usize = getStartCoordinate(minX, biomesSortedByX);
		for (biomesSortedByX[i..]) |other| {
			if (other.pos[0] -% maxX >= 0) break;
			const minDistance = (biomeRadius + other.radius)*0.85;

			if (@as(f32, @floatFromInt(vec.lengthSquare(other.pos -% Vec2i{x, y}))) < minDistance*minDistance) {
				return false;
			}
		}
		return true;
	}

	pub fn init(allocator: NeverFailingAllocator, tree: *TreeNode, worldSeed: u64, wx: i32, wy: i32, neighbors: []const *const Chunk) *Chunk {
		var chunkLocalMaxBiomeRadius: i32 = 0;
		var seed = random.initSeed2D(worldSeed, .{wx, wy});
		var selectedBiomes: main.utils.SortedList(BiomePoint) = .{};
		var rejections: usize = 0;
		outer: while (rejections < 100) {
			const x = random.nextIntBounded(u31, &seed, chunkSize) + wx;
			const y = random.nextIntBounded(u31, &seed, chunkSize) + wy;
			var biomeSeed: u64 = worldSeed;
			const drawnBiome = tree.getBiome(&biomeSeed, x, y, 0);
			const radius = drawnBiome.radius + drawnBiome.radiusVariation*random.nextFloatSigned(&seed);
			if (!checkIfBiomeIsValid(x, y, radius, selectedBiomes.items(), chunkLocalMaxBiomeRadius)) {
				rejections += 1;
				continue :outer;
			}
			for (neighbors) |otherChunk| {
				if (!checkIfBiomeIsValid(x, y, radius, otherChunk.biomesSortedByX, otherChunk.maxBiomeRadius)) {
					rejections += 1;
					continue :outer;
				}
			}
			rejections = 0;
			chunkLocalMaxBiomeRadius = @max(chunkLocalMaxBiomeRadius, @as(i32, @intFromFloat(@ceil(radius))));
			selectedBiomes.insertSorted(allocator, .{
				.biome = drawnBiome,
				.pos = .{x, y},
				.height = random.nextFloat(&seed)*@as(f32, @floatFromInt(drawnBiome.maxHeight - drawnBiome.minHeight)) + @as(f32, @floatFromInt(drawnBiome.minHeight)),
				.weight = 1.0/@sqrt(std.math.pi*radius*radius),
				.radius = radius,
			});
		}

		const self = allocator.create(Chunk);
		self.* = .{
			.wx = wx,
			.wy = wy,
			.biomesSortedByX = selectedBiomes.toOwnedSlice(allocator),
			.maxBiomeRadius = chunkLocalMaxBiomeRadius,
		};
		return self;
	}

	pub fn deinit(self: *Chunk, allocator: NeverFailingAllocator) void {
		allocator.free(self.biomesSortedByX);
		allocator.destroy(self);
	}
};

const GenerationStructure = struct {
	chunks: Array2D(*Chunk) = undefined, // Implemented as slices into the original array!

	pub fn init(allocator: NeverFailingAllocator, wx: i32, wy: i32, width: u31, height: u31, tree: *TreeNode, worldSeed: u64) GenerationStructure {
		const self: GenerationStructure = .{
			.chunks = Array2D(*Chunk).init(allocator, 8 + @divExact(width, chunkSize), 8 + @divExact(height, chunkSize)),
		};
		// Generate chunks in an interleaved pattern:
		const offset: [4][2]u31 = .{
			.{0, 0},
			.{0, 1},
			.{1, 0},
			.{1, 1},
		};
		const neighborOffsets: [4][]const [2]i32 = .{
			&.{},
			&.{.{0, -1}, .{0, 1}},
			&.{.{-1, 0}, .{1, 0}, .{-1, -1}, .{1, -1}, .{-1, 1}, .{1, 1}},
			&.{.{0, -1}, .{0, 1}, .{-1, 0}, .{1, 0}, .{-1, -1}, .{1, -1}, .{-1, 1}, .{1, 1}},
		};
		for (0..4) |i| {
			var x: u31 = offset[i][0];
			while (x < self.chunks.width) : (x += 2) {
				var y: u31 = offset[i][1];
				while (y < self.chunks.height) : (y += 2) {
					var neighbors: [8]*const Chunk = undefined;
					var j: usize = 0;
					for (neighborOffsets[i]) |neighborOffset| {
						const nx = x + neighborOffset[0];
						if (nx < 0 or @as(usize, @intCast(nx)) >= self.chunks.width) continue;
						const ny = y + neighborOffset[1];
						if (ny < 0 or @as(usize, @intCast(ny)) >= self.chunks.height) continue;
						neighbors[j] = self.chunks.get(@intCast(nx), @intCast(ny));
						j += 1;
					}
					self.chunks.ptr(x, y).* = Chunk.init(allocator, tree, worldSeed, wx +% x*chunkSize -% 4*chunkSize, wy +% y*chunkSize -% 4*chunkSize, neighbors[0..j]);
				}
			}
		}
		return self;
	}

	pub fn deinit(self: GenerationStructure, allocator: NeverFailingAllocator) void {
		for (self.chunks.mem) |chunk| {
			chunk.deinit(allocator);
		}
		self.chunks.deinit(allocator);
	}

	fn smoothInterpolation(x: f32) f32 {
		return x*x*(3 - 2*x);
	}

	fn findClosestBiomeTo(prefilteredCandidates: []*BiomePoint, wx: i32, wy: i32, relX: i32, relY: i32, worldSeed: u64) BiomeSample {
		const x = wx +% relX*terrain.SurfaceMap.MapFragment.biomeSize;
		const y = wy +% relY*terrain.SurfaceMap.MapFragment.biomeSize;
		var closestDist = std.math.floatMax(f32);
		var secondClosestDist = std.math.floatMax(f32);
		var closestBiomePoint: BiomePoint = undefined;
		var height: f32 = 0;
		var roughness: f32 = 0;
		var hills: f32 = 0;
		var mountains: f32 = 0;
		var totalWeight: f32 = 0;
		// all BiomePoints are within ±2 chunks of the current one.
		var candidateList: main.ListUnmanaged(struct { point: *BiomePoint, weight: f32 }) = .initCapacity(main.stackAllocator, prefilteredCandidates.len);
		defer candidateList.deinit(main.stackAllocator);
		for (prefilteredCandidates) |candidate| {
			candidateList.appendAssumeCapacity(.{.point = candidate, .weight = 1});
		}
		// Interpolate between all pairs of biomes.
		var i: usize = 0;
		outer: while (i < candidateList.items.len) {
			const dist = candidateList.items[i].point.voronoiDistanceFunction(.{x, y});
			var j = i + 1;
			while (j < candidateList.items.len) {
				const dist2 = candidateList.items[j].point.voronoiDistanceFunction(.{x, y});
				const totalDist = dist + dist2;
				const interpolationStrength = 0.5;
				const centerPos = totalDist*0.5;
				const interpolationStart = centerPos - interpolationStrength*0.5;
				const interpolationEnd = centerPos + interpolationStrength*0.5;
				if (dist < interpolationStart) {
					_ = candidateList.swapRemove(j);
					continue;
				}
				if (dist > interpolationEnd) {
					_ = candidateList.swapRemove(i);
					continue :outer;
				}
				const interp = smoothInterpolation((dist - interpolationStart)/(interpolationEnd - interpolationStart));
				candidateList.items[i].weight *= 1 - interp;
				candidateList.items[j].weight *= interp;
				j += 1;
			}
			i += 1;
		}
		for (candidateList.items) |candidate| {
			const weight = candidate.weight;
			height += candidate.point.height*weight;
			totalWeight += weight;
		}
		for (candidateList.items) |candidate| {
			const weight = blk: {
				if (!candidate.point.biome.smoothBeaches) break :blk candidate.weight;
				const maxHeight = @abs(height);
				const noiseHeightInfluence = candidate.point.biome.roughness + candidate.point.biome.hills + candidate.point.biome.mountains;
				break :blk candidate.weight*@min(maxHeight, noiseHeightInfluence)/noiseHeightInfluence;
			};
			roughness += candidate.point.biome.roughness*weight;
			hills += candidate.point.biome.hills*weight;
			mountains += candidate.point.biome.mountains*weight;
		}
		for (candidateList.items) |candidate| {
			var dist = candidate.point.voronoiDistanceFunction(.{x, y});
			if (@as(f32, @floatFromInt(candidate.point.biome.maxHeightLimit)) < height/totalWeight) {
				dist += 10.0;
			}
			if (@as(f32, @floatFromInt(candidate.point.biome.minHeightLimit)) > height/totalWeight) {
				dist += 10.0;
			}
			if (dist < closestDist) {
				secondClosestDist = closestDist;
				closestDist = dist;
				closestBiomePoint = candidate.point.*;
			}
		}
		std.debug.assert(totalWeight > 0);
		std.debug.assert(closestDist != std.math.floatMax(f32));
		return .{
			.biome = closestBiomePoint.biome,
			.height = height/totalWeight,
			.roughness = roughness/totalWeight,
			.hills = hills/totalWeight,
			.mountains = mountains/totalWeight,
			.seed = random.initSeed2D(worldSeed, closestBiomePoint.pos),
		};
	}

	fn drawCircleOnTheMap(map: *ClimateMapFragment, biome: *const Biome, biomeRadius: f32, wx: i32, wy: i32, width: u31, height: u31, pos: Vec2i, comptime skipMismatched: bool, parentBiome: *const Biome) !void {
		const relPos = @as(Vec2f, @floatFromInt(pos -% Vec2i{wx, wy}))/@as(Vec2f, @splat(terrain.SurfaceMap.MapFragment.biomeSize));
		const relRadius = biomeRadius/terrain.SurfaceMap.MapFragment.biomeSize;
		const min = @floor(@max(Vec2f{0, 0}, relPos - @as(Vec2f, @splat(relRadius))));
		const max = @ceil(@min(@as(Vec2f, @floatFromInt(Vec2i{width, height}))/@as(Vec2f, @splat(terrain.SurfaceMap.MapFragment.biomeSize)), relPos + @as(Vec2f, @splat(relRadius))));
		if (skipMismatched) {
			var x: f32 = min[0];
			while (x < max[0]) : (x += 1) {
				var y: f32 = min[1];
				while (y < max[1]) : (y += 1) {
					const distSquare = vec.lengthSquare(Vec2f{x, y} - relPos);
					if (distSquare < relRadius*relRadius) {
						if (map.map[@intFromFloat(x)][@intFromFloat(y)].biome != parentBiome) {
							return error.biomeMismatch;
						}
					}
				}
			}
		}
		var x: f32 = min[0];
		while (x < max[0]) : (x += 1) {
			var y: f32 = min[1];
			while (y < max[1]) : (y += 1) {
				const distSquare = vec.lengthSquare(Vec2f{x, y} - relPos);
				if (distSquare < relRadius*relRadius) {
					const entry = &map.map[@intFromFloat(x)][@intFromFloat(y)];
					var seed = entry.seed;
					const newHeight = @as(f32, @floatFromInt(biome.minHeight)) + @as(f32, @floatFromInt(biome.maxHeight - biome.minHeight))*random.nextFloat(&seed);
					entry.* = .{
						.biome = biome,
						.roughness = std.math.lerp(biome.roughness, entry.roughness, biome.keepOriginalTerrain),
						.hills = std.math.lerp(biome.hills, entry.hills, biome.keepOriginalTerrain),
						.mountains = std.math.lerp(biome.mountains, entry.mountains, biome.keepOriginalTerrain),
						.height = std.math.lerp(newHeight, entry.height, biome.keepOriginalTerrain),
						.seed = entry.seed,
					};
				}
			}
		}
	}

	fn addSubBiomesOf(biome: BiomePoint, map: *ClimateMapFragment, extraBiomes: *main.List(BiomePoint), wx: i32, wy: i32, width: u31, height: u31, worldSeed: u64, comptime radius: enum { known, unknown }) void {
		var seed = random.initSeed2D(worldSeed, @bitCast(biome.pos));
		var biomeCount: f32 = undefined;
		if (biome.biome.subBiomeTotalChance > biome.biome.maxSubBiomeCount) {
			biomeCount = biome.biome.maxSubBiomeCount;
		} else if (biome.biome.subBiomeTotalChance > biome.biome.maxSubBiomeCount/2) {
			biomeCount = biome.biome.maxSubBiomeCount - (biome.biome.maxSubBiomeCount - biome.biome.subBiomeTotalChance*2)*random.nextFloat(&seed);
		} else {
			biomeCount = biome.biome.subBiomeTotalChance*2*random.nextFloat(&seed);
		}
		biomeCount = @min(biomeCount, biome.biome.maxSubBiomeCount);
		var i: f32 = 0;
		var fails: usize = 0;
		while (i < biomeCount) : (i += 1) {
			if (biomeCount - i < random.nextFloat(&seed)) break;
			const subBiome = biome.biome.subBiomes.sample(&seed).*;
			const subRadius = subBiome.radius + subBiome.radiusVariation*random.nextFloatSigned(&seed);
			var maxCenterOffset: f32 = biome.radius - subRadius;
			if (radius == .unknown) {
				maxCenterOffset += biome.radius/2;
			}
			if (maxCenterOffset < 0) {
				maxCenterOffset = 0;
			}
			const point = biome.pos +% @as(Vec2i, @intFromFloat(random.nextPointInUnitCircle(&seed)*@as(Vec2f, @splat(maxCenterOffset))));
			drawCircleOnTheMap(map, subBiome, subRadius, wx, wy, width, height, point, radius == .unknown, biome.biome) catch if (radius == .unknown) {
				fails += 1;
				if (fails < @as(usize, @intFromFloat(biomeCount))) {
					i -= 1;
				}
			};
			extraBiomes.append(.{
				.biome = subBiome,
				.pos = point,
				.height = random.nextFloat(&seed)*@as(f32, @floatFromInt(subBiome.maxHeight - subBiome.minHeight)) + @as(f32, @floatFromInt(subBiome.minHeight)),
				.weight = 1.0/(std.math.pi*subRadius*subRadius),
				.radius = subRadius,
			});
		}
	}

	fn addTransitionBiomes(map: *[preMapSize][preMapSize]BiomeSample) void {
		const neighborData = main.stackAllocator.create([16][preMapSize][preMapSize]u15);
		defer main.stackAllocator.free(neighborData);
		for (0..preMapSize) |x| {
			for (0..preMapSize) |y| {
				neighborData[0][x][y] = @bitCast(map[x][y].biome.properties);
			}
		}
		for (1..neighborData.len) |i| {
			for (1..preMapSize - 1) |x| {
				for (1..preMapSize - 1) |y| {
					neighborData[i][x][y] = neighborData[i - 1][x][y] | neighborData[i - 1][x - 1][y] | neighborData[i - 1][x + 1][y] | neighborData[i - 1][x][y - 1] | neighborData[i - 1][x][y + 1];
				}
			}
		}
		for (margin..preMapSize - margin) |x| {
			for (margin..preMapSize - margin) |y| {
				const point = map[x][y];
				if (point.biome.transitionBiomes.len == 0) {
					std.debug.assert(!std.mem.eql(u8, "cubyz:ocean", point.biome.id));
					continue;
				}
				var seed = point.seed;
				for (point.biome.transitionBiomes) |transitionBiome| {
					const biomeMask: u15 = @bitCast(transitionBiome.propertyMask);
					const neighborMask = neighborData[@min(neighborData.len - 1, transitionBiome.width)][x][y];
					// Check if all triplets have a matching entry:
					var result = biomeMask & neighborMask;
					result = (result | result >> 1 | result >> 2);
					if (result & Biome.GenerationProperties.mask == Biome.GenerationProperties.mask) {
						if (random.nextFloat(&seed) < transitionBiome.chance) {
							const newHeight = @as(f32, @floatFromInt(transitionBiome.biome.minHeight)) + @as(f32, @floatFromInt(transitionBiome.biome.maxHeight - transitionBiome.biome.minHeight))*random.nextFloat(&seed);
							map[x][y] = .{
								.biome = transitionBiome.biome,
								.roughness = std.math.lerp(transitionBiome.biome.roughness, map[x][y].roughness, transitionBiome.biome.keepOriginalTerrain),
								.hills = std.math.lerp(transitionBiome.biome.hills, map[x][y].hills, transitionBiome.biome.keepOriginalTerrain),
								.mountains = std.math.lerp(transitionBiome.biome.mountains, map[x][y].mountains, transitionBiome.biome.keepOriginalTerrain),
								.height = std.math.lerp(newHeight, map[x][y].height, transitionBiome.biome.keepOriginalTerrain),
								.seed = map[x][y].seed,
							};
							break;
						}
					}
				}
			}
		}
	}

	const margin = chunkSize >> terrain.SurfaceMap.MapFragment.biomeShift;
	const preMapSize = ClimateMapFragment.mapEntrysSize + 2*margin;
	pub fn fillRecursively(wx: i32, wy: i32, preMap: *[preMapSize][preMapSize]BiomeSample, biomeCandidates: []*BiomePoint, worldSeed: u64, relX: i32, relY: i32, width: u31, height: u31) void {
		if (width <= 1 or height <= 1) {
			for (0..width) |dx| {
				const indexX = @as(usize, @intCast(relX + margin)) + dx;
				for (0..height) |dy| {
					const indexY = @as(usize, @intCast(relY + margin)) + dy;
					preMap[indexX][indexY] = findClosestBiomeTo(biomeCandidates, wx, wy, relX + @as(u31, @intCast(dx)), relY + @as(u31, @intCast(dy)), worldSeed);
				}
			}
			return;
		}
		// Subdivide
		const halfWidth = width/2;
		const halfHeight = height/2;
		var newCandidates: main.ListUnmanaged(*BiomePoint) = .initCapacity(main.stackAllocator, biomeCandidates.len);
		defer newCandidates.deinit(main.stackAllocator);
		for (0..2) |dx| {
			for (0..2) |dy| {
				const newRelX = relX + if (dx == 0) 0 else halfWidth;
				const newWidth = if (dx == 0) halfWidth else width - halfWidth;
				const newRelY = relY + if (dy == 0) 0 else halfHeight;
				const newHeight = if (dy == 0) halfHeight else height - halfHeight;

				const wxMin = wx +% newRelX*terrain.SurfaceMap.MapFragment.biomeSize;
				const wxMax = wxMin +% newWidth*terrain.SurfaceMap.MapFragment.biomeSize;
				const wyMin = wy +% newRelY*terrain.SurfaceMap.MapFragment.biomeSize;
				const wyMax = wyMin +% newHeight*terrain.SurfaceMap.MapFragment.biomeSize;

				newCandidates.clearRetainingCapacity();
				for (biomeCandidates) |candidate| {
					const influenceRadius = 3*@as(i32, @intFromFloat(@ceil(candidate.radius)));
					const candidateMinX = wxMin -% influenceRadius;
					const candidateMaxX = wxMax +% influenceRadius;
					const candidateMinY = wyMin -% influenceRadius;
					const candidateMaxY = wyMax +% influenceRadius;
					if (candidate.pos[0] -% candidateMinX < 0 or candidate.pos[0] -% candidateMaxX > 0) continue;
					if (candidate.pos[1] -% candidateMinY < 0 or candidate.pos[1] -% candidateMaxY > 0) continue;
					newCandidates.appendAssumeCapacity(candidate);
				}
				fillRecursively(wx, wy, preMap, newCandidates.items, worldSeed, newRelX, newRelY, newWidth, newHeight);
			}
		}
	}

	pub fn toMap(self: GenerationStructure, map: *ClimateMapFragment, width: u31, height: u31, worldSeed: u64) void {
		var preMap: [preMapSize][preMapSize]BiomeSample = undefined;
		var allCandidates: main.List(*BiomePoint) = .initCapacity(main.stackAllocator, 1024);
		defer allCandidates.deinit();
		for (self.chunks.mem) |chunk| {
			for (chunk.biomesSortedByX) |*candidate| {
				allCandidates.append(candidate);
			}
		}
		fillRecursively(map.pos.wx, map.pos.wy, &preMap, allCandidates.items, worldSeed, -margin, -margin, preMapSize, preMapSize);
		addTransitionBiomes(&preMap);
		for (0..ClimateMapFragment.mapEntrysSize) |_x| {
			@memcpy(&map.map[_x], preMap[_x + margin][margin..][0..ClimateMapFragment.mapEntrysSize]);
		}

		// Add some sub-biomes:
		var extraBiomes = main.List(BiomePoint).init(main.stackAllocator);
		defer extraBiomes.deinit();
		for (self.chunks.mem) |chunk| {
			for (chunk.biomesSortedByX) |biome| {
				addSubBiomesOf(biome, map, &extraBiomes, map.pos.wx, map.pos.wy, width, height, worldSeed, .unknown);
			}
		}
		// Add some sub-sub(-sub)*-biomes
		while (extraBiomes.popOrNull()) |biomePoint| {
			addSubBiomesOf(biomePoint, map, &extraBiomes, map.pos.wx, map.pos.wy, width, height, worldSeed, .known);
		}
	}
};

```

`src/server/terrain/climategen/SingleBiome.zig`:

```zig
const std = @import("std");

const build_options = @import("build_options");

const main = @import("main");
const Array2D = main.utils.Array2D;
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const ClimateMapFragment = terrain.ClimateMap.ClimateMapFragment;
const BiomeSample = terrain.ClimateMap.BiomeSample;
const Biome = terrain.biomes.Biome;
const TreeNode = terrain.biomes.TreeNode;
const vec = main.vec;
const Vec2i = vec.Vec2i;
const Vec2f = vec.Vec2f;

const NeverFailingAllocator = main.heap.NeverFailingAllocator;

// Generates the climate map using a fluidynamics simulation, with a circular heat distribution.

pub const id = "cubyz:single_biome";

var biome: *const Biome = undefined;

pub fn init(parameters: ZonElement) void {
	biome = terrain.biomes.getById(parameters.get([]const u8, "biome", "missing parameter 'biome'"));
}

pub fn generateMapFragment(map: *ClimateMapFragment, worldSeed: u64) void {
	var x: u31 = 0;
	while (x < map.map.len) : (x += 1) {
		var y: u31 = 0;
		while (y < map.map[0].len) : (y += 1) {
			const wx = map.pos.wx +% x*ClimateMapFragment.mapSize/ClimateMapFragment.mapEntrysSize;
			const wy = map.pos.wy +% y*ClimateMapFragment.mapSize/ClimateMapFragment.mapEntrysSize;
			const noiseValue = terrain.noise.ValueNoise.samplePoint2D(@as(f32, @floatFromInt(wx))/biome.radius/2, @as(f32, @floatFromInt(wy))/biome.radius/2, worldSeed);
			map.map[x][y] = .{
				.biome = biome,
				.height = @as(f32, @floatFromInt(biome.minHeight)) + @as(f32, @floatFromInt(biome.maxHeight - biome.minHeight))*noiseValue,
				.roughness = biome.roughness,
				.hills = biome.hills,
				.mountains = biome.mountains,
				.seed = worldSeed ^ 53298562891,
			};
		}
	}
}

```

`src/server/terrain/climategen/_list.zig`:

```zig
pub const NoiseBasedVoronoi = @import("NoiseBasedVoronoi.zig");
pub const SingleBiome = @import("SingleBiome.zig");

```

`src/server/terrain/mapgen/MapGenV1.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array2D = main.utils.Array2D;
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const MapFragment = terrain.SurfaceMap.MapFragment;
const noise = terrain.noise;
const FractalNoise = noise.FractalNoise;
const RandomlyWeightedFractalNoise = noise.RandomlyWeightedFractalNoise;
const PerlinNoise = noise.PerlinNoise;
const vec = main.vec;
const Vec2f = vec.Vec2f;

pub const id = "cubyz:mapgen_v1";

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

/// Assumes the 2 points are at tᵢ = (0, 1)
fn interpolationWeights(t: f32, interpolation: terrain.biomes.Interpolation) Vec2f {
	switch (interpolation) {
		.none => {
			if (t < 0.5) {
				return .{1, 0};
			} else {
				return .{0, 1};
			}
		},
		.linear => {
			return .{1 - t, t};
		},
		.square => {
			if (t < 0.5) {
				const tSqr = 2*t*t;
				return .{1 - tSqr, tSqr};
			} else {
				const tSqr = 2*(1 - t)*(1 - t);
				return .{tSqr, 1 - tSqr};
			}
		},
	}
}

pub fn generateMapFragment(map: *MapFragment, worldSeed: u64) void {
	const scaledSize = MapFragment.mapSize;
	const mapSize = scaledSize*map.pos.voxelSize;
	const biomeSize = MapFragment.biomeSize;
	const offset = 32;
	const biomePositions = terrain.ClimateMap.getBiomeMap(main.stackAllocator, map.pos.wx -% offset*biomeSize, map.pos.wy -% offset*biomeSize, mapSize + 2*offset*biomeSize, mapSize + 2*offset*biomeSize);
	defer biomePositions.deinit(main.stackAllocator);
	var seed = random.initSeed2D(worldSeed, .{map.pos.wx, map.pos.wy});
	random.scrambleSeed(&seed);
	seed ^= seed >> 16;

	const offsetScale = biomeSize*16;
	const xOffsetMap = Array2D(f32).init(main.stackAllocator, scaledSize, scaledSize);
	defer xOffsetMap.deinit(main.stackAllocator);
	const yOffsetMap = Array2D(f32).init(main.stackAllocator, scaledSize, scaledSize);
	defer yOffsetMap.deinit(main.stackAllocator);
	FractalNoise.generateSparseFractalTerrain(map.pos.wx, map.pos.wy, offsetScale, worldSeed ^ 675396758496549, xOffsetMap, map.pos.voxelSize);
	FractalNoise.generateSparseFractalTerrain(map.pos.wx, map.pos.wy, offsetScale, worldSeed ^ 543864367373859, yOffsetMap, map.pos.voxelSize);

	// A ridgid noise map to generate interesting mountains.
	const mountainMap = Array2D(f32).init(main.stackAllocator, scaledSize, scaledSize);
	defer mountainMap.deinit(main.stackAllocator);
	RandomlyWeightedFractalNoise.generateSparseFractalTerrain(map.pos.wx, map.pos.wy, 256, worldSeed ^ 6758947592930535, mountainMap, map.pos.voxelSize);

	// A smooth map for smaller hills.
	const hillMap = PerlinNoise.generateSmoothNoise(main.stackAllocator, map.pos.wx, map.pos.wy, mapSize, mapSize, 128, 32, worldSeed ^ 157839765839495820, map.pos.voxelSize, 0.5);
	defer hillMap.deinit(main.stackAllocator);

	// A fractal map to generate high-detail roughness.
	const roughMap = Array2D(f32).init(main.stackAllocator, scaledSize, scaledSize);
	defer roughMap.deinit(main.stackAllocator);
	FractalNoise.generateSparseFractalTerrain(map.pos.wx, map.pos.wy, 64, worldSeed ^ 954936678493, roughMap, map.pos.voxelSize);

	var x: u31 = 0;
	while (x < map.heightMap.len) : (x += 1) {
		var y: u31 = 0;
		while (y < map.heightMap.len) : (y += 1) {
			// Do the biome interpolation:
			var height: f32 = 0;
			var roughness: f32 = 0;
			var hills: f32 = 0;
			var mountains: f32 = 0;
			const wx: f32 = @floatFromInt(x*map.pos.voxelSize + map.pos.wx);
			const wy: f32 = @floatFromInt(y*map.pos.voxelSize + map.pos.wy);
			const offsetX = (xOffsetMap.get(x, y) - 0.5)*offsetScale;
			const offsetY = (yOffsetMap.get(x, y) - 0.5)*offsetScale;
			const updatedX = wx + offsetX;
			const updatedY = wy + offsetY;
			const rawXBiome = (updatedX - @as(f32, @floatFromInt(map.pos.wx)))/biomeSize;
			const rawYBiome = (updatedY - @as(f32, @floatFromInt(map.pos.wy)))/biomeSize;
			const xBiome: i32 = @as(i32, @intFromFloat(@floor(rawXBiome))) + offset;
			const yBiome: i32 = @as(i32, @intFromFloat(@floor(rawYBiome))) + offset;
			const relXBiome = rawXBiome - @floor(rawXBiome);
			const relYBiome = rawYBiome - @floor(rawYBiome);
			const interpolationCoefficientsX = interpolationWeights(relXBiome, .square);
			const interpolationCoefficientsY = interpolationWeights(relYBiome, .square);
			var coefficientsX: vec.Vec2f = .{0, 0};
			var coefficientsY: vec.Vec2f = .{0, 0};
			var totalWeight: f32 = 0;
			for (0..2) |dx| {
				for (0..2) |dy| {
					const biomeMapX = @as(usize, @intCast(xBiome)) + dx;
					const biomeMapY = @as(usize, @intCast(yBiome)) + dy;
					const biomeSample = biomePositions.get(biomeMapX, biomeMapY);
					const weight = @as([2]f32, interpolationCoefficientsX)[dx]*@as([2]f32, interpolationCoefficientsY)[dy]*biomeSample.biome.interpolationWeight;
					coefficientsX += interpolationWeights(relXBiome, biomeSample.biome.interpolation)*@as(Vec2f, @splat(weight));
					coefficientsY += interpolationWeights(relYBiome, biomeSample.biome.interpolation)*@as(Vec2f, @splat(weight));
					totalWeight += weight;
				}
			}
			coefficientsX /= @splat(totalWeight);
			coefficientsY /= @splat(totalWeight);
			for (0..2) |dx| {
				for (0..2) |dy| {
					const biomeMapX = @as(usize, @intCast(xBiome)) + dx;
					const biomeMapY = @as(usize, @intCast(yBiome)) + dy;
					const weight = @as([2]f32, coefficientsX)[dx]*@as([2]f32, coefficientsY)[dy];
					const biomeSample = biomePositions.get(biomeMapX, biomeMapY);
					height += biomeSample.height*weight;
					roughness += biomeSample.roughness*weight;
					hills += biomeSample.hills*weight;
					mountains += biomeSample.mountains*weight;
				}
			}
			height += (roughMap.get(x, y) - 0.5)*2*roughness;
			height += (hillMap.get(x, y) - 0.5)*2*hills;
			height += (mountainMap.get(x, y) - 0.5)*2*mountains;
			map.heightMap[x][y] = @intFromFloat(height);
			map.minHeight = @min(map.minHeight, @as(i32, @intFromFloat(height)));
			map.minHeight = @max(map.minHeight, 0);
			map.maxHeight = @max(map.maxHeight, @as(i32, @intFromFloat(height)));

			// Select a biome. Also adding some white noise to make a smoother transition.
			const roundedXBiome = @as(i32, @intFromFloat(@round(rawXBiome))) + offset;
			const roundedYBiome = @as(i32, @intFromFloat(@round(rawYBiome))) + offset;
			const biomePoint = biomePositions.get(@intCast(roundedXBiome), @intCast(roundedYBiome));
			map.biomeMap[x][y] = biomePoint.biome;
		}
	}
}

```

`src/server/terrain/mapgen/_list.zig`:

```zig
pub const MapGenV1 = @import("MapGenV1.zig");

```

`src/server/terrain/noise/BlueNoise.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const Array2D = main.utils.Array2D;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const sizeShift = 7; // TODO: Increase back to 10 once this is no longer impacting loading time.
const size = 1 << sizeShift;
const sizeMask = size - 1;
const featureShift = 2;
const featureSize = 1 << featureShift;
const featureMask = featureSize - 1;

/// Uses a simple square grid as a base.
var pattern: [size*size]u8 = undefined;

/// Loads a pre-seeded noise map that is used for world generation.
pub fn load() void { // TODO: Do this at compile time once the caching is good enough.
	@setRuntimeSafety(false); // TODO: Replace with optimizations.
	var seed: u64 = 54095248685739;
	const distSquareLimit = 8;
	const repetitions = 4;
	const iterations = 16;
	// Go through all points and try to move them randomly.
	// Ensures that the grid is valid in each step.
	// This is repeated multiple times for optimal results.
	// In the last repetition is enforced, to remove grid artifacts.
	for (0..repetitions) |_| {
		for (0..pattern.len) |i| {
			const x: i32 = @intCast(i >> sizeShift);
			const y: i32 = @intCast(i & sizeMask);
			outer: for (0..iterations) |_| {
				const point = random.nextInt(u6, &seed);
				const xOffset = point >> 3 & 7;
				const yOffset = point & 7;
				// Go through all neighbors and check validity:
				var dx: i32 = -2;
				while (dx <= 2) : (dx += 1) {
					var dy: i32 = -2;
					while (dy <= 2) : (dy += 1) {
						if (dx == 0 and dy == 0) continue; // Don't compare with itself!
						const neighbor = (x + dx & sizeMask) << sizeShift | (y + dy & sizeMask);
						const neighborPos = pattern[@intCast(neighbor)];
						const nx = (neighborPos >> 3) + (dx << featureShift);
						const ny = (neighborPos & 7) + (dy << featureShift);
						const distSqr = (nx - xOffset)*(nx - xOffset) + (ny - yOffset)*(ny - yOffset);
						if (distSqr < distSquareLimit) continue :outer;
					}
				}

				pattern[i] = point;
				break;
			}
		}
	}
}

fn sample(x: i32, y: i32) u8 {
	return pattern[@intCast(x << sizeShift | y)];
}

/// Takes a subregion of the grid. Corrdinates are returned relative to x and y compressed into 16 bits each.
pub fn getRegionData(allocator: NeverFailingAllocator, x: i32, y: i32, width: u31, height: u31) []u32 {
	const xMin = ((x & ~@as(i32, featureMask)) -% featureSize);
	const yMin = ((y & ~@as(i32, featureMask)) -% featureSize);
	const xMax = ((x +% width & ~@as(i32, featureMask)));
	const yMax = ((y +% height & ~@as(i32, featureMask)));
	var result = main.ListUnmanaged(u32).initCapacity(allocator, @intCast((((xMax -% xMin) >> featureShift) + 1)*(((yMax -% yMin) >> featureShift) + 1)));
	var xMap: i32 = xMin;
	while (xMap -% xMax <= 0) : (xMap +%= featureSize) {
		var yMap: i32 = yMin;
		while (yMap -% yMax <= 0) : (yMap +%= featureSize) {
			const val = sample(xMap >> featureShift & sizeMask, yMap >> featureShift & sizeMask);
			var xRes = xMap -% xMin;
			xRes += val >> 3;
			var yRes = yMap -% yMin;
			yRes += val & 7;
			if (xRes >= 0 and xRes < width and yRes >= 0 and yRes < height) {
				result.appendAssumeCapacity(@bitCast(xRes << 16 | yRes));
			}
		}
	}
	return result.toOwnedSlice(allocator);
}

```

`src/server/terrain/noise/CachedFractalNoise.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array2D = main.utils.Array2D;
const MapFragmentPosition = main.server.terrain.SurfaceMap.MapFragmentPosition;

const CachedFractalNoise = @This();

pos: MapFragmentPosition,
cache: Array2D(f32),
scale: u31,
worldSeed: u64,

pub fn init(wx: i32, wy: i32, voxelSize: u31, size: u31, worldSeed: u64, scale: u31) CachedFractalNoise {
	const maxSize = size/voxelSize;
	const cacheWidth = maxSize + 1;
	var self = CachedFractalNoise{
		.pos = .{
			.wx = wx,
			.wy = wy,
			.voxelSize = voxelSize,
			.voxelSizeShift = @ctz(voxelSize),
		},
		.cache = .init(main.globalAllocator, cacheWidth, cacheWidth),
		.scale = scale,
		.worldSeed = worldSeed,
	};
	// Init the corners:
	@memset(self.cache.mem, 0);
	const reducedScale = scale/voxelSize;
	var x: u31 = 0;
	while (x <= maxSize) : (x += reducedScale) {
		var y: u31 = 0;
		while (y <= maxSize) : (y += reducedScale) {
			self.cache.ptr(x, y).* = (@as(f32, @floatFromInt(reducedScale + 1 + scale))*self.getGridValue(x, y))*@as(f32, @floatFromInt(voxelSize));
		} //                                                 ↑ sacrifice some resolution to reserve the value 0, for determining if the value was initialized. This prevents an expensive array initialization.
	}
	return self;
}

pub fn deinit(self: CachedFractalNoise) void {
	self.cache.deinit(main.globalAllocator);
}

pub fn getRandomValue(self: CachedFractalNoise, wx: i32, wy: i32) f32 {
	var seed: u64 = main.random.initSeed2D(self.worldSeed, .{wx, wy});
	return main.random.nextFloat(&seed) - 0.5;
}

fn getGridValue(self: CachedFractalNoise, relX: u31, relY: u31) f32 {
	return self.getRandomValue(self.pos.wx +% relX*%self.pos.voxelSize, self.pos.wy +% relY*%self.pos.voxelSize);
}

fn generateRegion(self: CachedFractalNoise, _x: u31, _y: u31, voxelSize: u31) void {
	const x = _x & ~@as(u31, voxelSize - 1);
	const y = _y & ~@as(u31, voxelSize - 1);
	// Make sure that all higher points are generated:
	_ = self._getValue(x | voxelSize, y | voxelSize);

	const xMid = x + @divExact(voxelSize, 2);
	const yMid = y + @divExact(voxelSize, 2);
	const randomFactor: f32 = @floatFromInt(voxelSize*self.pos.voxelSize);

	const cache = self.cache;

	var a: u31 = 0;
	while (a <= voxelSize) : (a += voxelSize) { // 1 coordinate on the grid.
		// x
		cache.ptr(x + a, yMid).* = (cache.get(x + a, y) + cache.get(x + a, y + voxelSize))/2;
		cache.ptr(x + a, yMid).* += randomFactor*self.getGridValue(x + a, yMid);
		// y
		cache.ptr(xMid, y + a).* = (cache.get(x, y + a) + cache.get(x + voxelSize, y + a))/2;
		cache.ptr(xMid, y + a).* += randomFactor*self.getGridValue(xMid, y + a);
	}

	// Center point:
	cache.ptr(xMid, yMid).* = (cache.get(xMid, y) + cache.get(xMid, y + voxelSize) + cache.get(x, yMid) + cache.get(x + voxelSize, yMid))/4 + randomFactor*self.getGridValue(xMid, yMid);
}

fn _getValue(self: CachedFractalNoise, x: u31, y: u31) f32 {
	const value = self.cache.get(x, y);
	if (value != 0) return value;
	// Need to actually generate stuff now.
	const minShift = @min(@ctz(x), @ctz(y));
	self.generateRegion(x, y, @as(u31, 2) << @intCast(minShift));
	return self.cache.get(x, y);
}

pub fn getValue(self: CachedFractalNoise, wx: i32, wy: i32) f32 {
	const x: u31 = @intCast((wx -% self.pos.wx) >> self.pos.voxelSizeShift);
	const y: u31 = @intCast((wy -% self.pos.wy) >> self.pos.voxelSizeShift);
	return self._getValue(x, y) - @as(f32, @floatFromInt(self.scale));
}

```

`src/server/terrain/noise/CachedFractalNoise3D.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array3D = main.utils.Array3D;
const ChunkPosition = main.chunk.ChunkPosition;

const CachedFractalNoise3D = @This();

pos: ChunkPosition,
cache: Array3D(f32),
voxelShift: u5,
scale: u31,
worldSeed: u64,

pub fn init(wx: i32, wy: i32, wz: i32, voxelSize: u31, size: u31, worldSeed: u64, scale: u31) CachedFractalNoise3D {
	const maxSize = size/voxelSize;
	const cacheWidth = maxSize + 1;
	var self = CachedFractalNoise3D{
		.pos = .{
			.wx = wx,
			.wy = wy,
			.wz = wz,
			.voxelSize = voxelSize,
		},
		.voxelShift = @ctz(voxelSize),
		.cache = Array3D(f32).init(main.globalAllocator, cacheWidth, cacheWidth, cacheWidth),
		.scale = scale,
		.worldSeed = worldSeed,
	};
	// Init the corners:
	@memset(self.cache.mem, 0);
	const reducedScale = scale/voxelSize;
	var x: u31 = 0;
	while (x <= maxSize) : (x += reducedScale) {
		var y: u31 = 0;
		while (y <= maxSize) : (y += reducedScale) {
			var z: u31 = 0;
			while (z <= maxSize) : (z += reducedScale) {
				self.cache.ptr(x, y, z).* = (@as(f32, @floatFromInt(reducedScale + 1 + scale))*self.getGridValue(x, y, z))*@as(f32, @floatFromInt(voxelSize));
			} //                                                    ↑ sacrifice some resolution to reserve the value 0, for determining if the value was initialized. This prevents an expensive array initialization.
		}
	}
	return self;
}

pub fn deinit(self: CachedFractalNoise3D) void {
	self.cache.deinit(main.globalAllocator);
}

pub fn getRandomValue(self: CachedFractalNoise3D, wx: i32, wy: i32, wz: i32) f32 {
	var seed: u64 = main.random.initSeed3D(self.worldSeed, .{wx, wy, wz});
	return main.random.nextFloat(&seed) - 0.5;
}

fn getGridValue(self: CachedFractalNoise3D, relX: u31, relY: u31, relZ: u31) f32 {
	return self.getRandomValue(self.pos.wx +% relX*%self.pos.voxelSize, self.pos.wy +% relY*%self.pos.voxelSize, self.pos.wz +% relZ*%self.pos.voxelSize);
}

fn generateRegion(self: CachedFractalNoise3D, _x: u31, _y: u31, _z: u31, voxelSize: u31) void {
	const x = _x & ~@as(u31, voxelSize - 1);
	const y = _y & ~@as(u31, voxelSize - 1);
	const z = _z & ~@as(u31, voxelSize - 1);
	// Make sure that all higher points are generated:
	_ = self._getValue(x | voxelSize, y | voxelSize, z | voxelSize);

	const xMid = x + @divExact(voxelSize, 2);
	const yMid = y + @divExact(voxelSize, 2);
	const zMid = z + @divExact(voxelSize, 2);
	const randomFactor: f32 = @floatFromInt(voxelSize*self.pos.voxelSize);

	const cache = self.cache;

	var a: u31 = 0;
	while (a <= voxelSize) : (a += voxelSize) { // 2 coordinates on the grid.
		var b: u31 = 0;
		while (b <= voxelSize) : (b += voxelSize) {
			// x-y
			cache.ptr(x + a, y + b, zMid).* = (cache.get(x + a, y + b, z) + cache.get(x + a, y + b, z + voxelSize))/2;
			cache.ptr(x + a, y + b, zMid).* += randomFactor*self.getGridValue(x + a, y + b, zMid);
			// x-z
			cache.ptr(x + a, yMid, z + b).* = (cache.get(x + a, y, z + b) + cache.get(x + a, y + voxelSize, z + b))/2;
			cache.ptr(x + a, yMid, z + b).* += randomFactor*self.getGridValue(x + a, yMid, z + b);
			// x-z
			cache.ptr(xMid, y + a, z + b).* = (cache.get(x, y + a, z + b) + cache.get(x + voxelSize, y + a, z + b))/2;
			cache.ptr(xMid, y + a, z + b).* += randomFactor*self.getGridValue(xMid, y + a, z + b);
		}
	}

	a = 0;
	while (a <= voxelSize) : (a += voxelSize) { // 1 coordinate on the grid.
		// x
		cache.ptr(x + a, yMid, zMid).* = (cache.get(x + a, yMid, z) + cache.get(x + a, yMid, z + voxelSize) + cache.get(x + a, y, zMid) + cache.get(x + a, y + voxelSize, zMid))/4 + randomFactor*self.getGridValue(x + a, yMid, zMid);
		// y
		cache.ptr(xMid, y + a, zMid).* = (cache.get(xMid, y + a, z) + cache.get(xMid, y + a, z + voxelSize) + cache.get(x, y + a, zMid) + cache.get(x + voxelSize, y + a, zMid))/4 + randomFactor*self.getGridValue(xMid, y + a, zMid);
		// z
		cache.ptr(xMid, yMid, z + a).* = (cache.get(xMid, y, z + a) + cache.get(xMid, y + voxelSize, z + a) + cache.get(x, yMid, z + a) + cache.get(x + voxelSize, yMid, z + a))/4 + randomFactor*self.getGridValue(xMid, yMid, z + a);
	}

	// Center point:
	cache.ptr(xMid, yMid, zMid).* = (cache.get(xMid, yMid, z) + cache.get(xMid, yMid, z + voxelSize) + cache.get(xMid, y, zMid) + cache.get(xMid, y + voxelSize, zMid) + cache.get(x, yMid, zMid) + cache.get(x + voxelSize, yMid, zMid))/6 + randomFactor*self.getGridValue(xMid, yMid, zMid);
}

fn _getValue(self: CachedFractalNoise3D, x: u31, y: u31, z: u31) f32 {
	const value = self.cache.get(x, y, z);
	if (value != 0) return value;
	// Need to actually generate stuff now.
	const minShift = @min(@ctz(x), @ctz(y), @ctz(z));
	self.generateRegion(x, y, z, @as(u31, 2) << @intCast(minShift));
	return self.cache.get(x, y, z);
}

pub fn getValue(self: CachedFractalNoise3D, wx: i32, wy: i32, wz: i32) f32 {
	const x: u31 = @intCast((wx -% self.pos.wx) >> self.voxelShift);
	const y: u31 = @intCast((wy -% self.pos.wy) >> self.voxelShift);
	const z: u31 = @intCast((wz -% self.pos.wz) >> self.voxelShift);
	return self._getValue(x, y, z) - @as(f32, @floatFromInt(self.scale));
}

```

`src/server/terrain/noise/FractalNoise.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array2D = main.utils.Array2D;

fn setSeed(x: i32, y: i32, offsetX: i32, offsetY: i32, seed: *u64, worldSeed: u64, scale: u31, maxResolution: u31) void {
	seed.* = main.random.initSeed2D(worldSeed*%(scale*maxResolution | 1), .{(offsetX +% x)*%maxResolution, (offsetY +% y)*%maxResolution});
}

pub fn generateFractalTerrain(wx: i32, wy: i32, x0: u31, y0: u31, width: u32, height: u32, scale: u31, worldSeed: u64, map: Array2D(f32), maxResolution: u31) void {
	const max = scale + 1;
	const mask: i32 = scale - 1;
	const bigMap = Array2D(f32).init(main.stackAllocator, max, max);
	defer bigMap.deinit(main.stackAllocator);
	const offsetX = wx & ~mask;
	const offsetY = wy & ~mask;
	var seed: u64 = undefined;
	// Generate the 4 corner points of this map using a coordinate-depending seed:
	setSeed(0, 0, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(0, 0).* = main.random.nextFloat(&seed);
	setSeed(0, scale, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(0, scale).* = main.random.nextFloat(&seed);
	setSeed(scale, 0, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(scale, 0).* = main.random.nextFloat(&seed);
	setSeed(scale, scale, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(scale, scale).* = main.random.nextFloat(&seed);
	generateInitializedFractalTerrain(offsetX, offsetY, scale, scale, worldSeed, bigMap, 0, 0.9999, maxResolution);
	var px: u31 = 0;
	while (px < width) : (px += 1) {
		@memcpy(map.getRow(x0 + px)[y0..][0..height], bigMap.getRow(@intCast((wx & mask) + px))[@intCast((wy & mask))..][0..height]);
	}
}

pub fn generateInitializedFractalTerrain(offsetX: i32, offsetY: i32, scale: u31, startingScale: u31, worldSeed: u64, bigMap: Array2D(f32), lowerLimit: f32, upperLimit: f32, maxResolution: u31) void {
	// Increase the "grid" of points with already known heights in each round by a factor of 2×2, like so(# marks the gridpoints of the first grid, * the points of the second grid and + the points of the third grid(and so on…)):
	//
	//  #+*+#
	//  +++++
	//  *+*+*
	//  +++++
	//  #+*+#
	//
	// Each new gridpoint gets the average height value of the surrounding known grid points which is afterwards offset by a random value. Here is a visual representation of this process(with random starting values):
	//
	// █░▒▓                     small                           small
	//  █???█   grid    █?█?█   random  █?▓?█   grid    ██▓██   random  ██▓██
	//  ?????   resize  ?????   change  ?????   resize  ▓▓▒▓█   change  ▒▒▒▓█
	//  ?????   →→→→    ▒?▒?▓   →→→→    ▒?░?▓   →→→→    ▒▒░▒▓   →→→→    ▒░░▒▓
	//  ?????           ?????   of new  ?????           ░░░▒▓   of new  ░░▒▓█
	//   ???▒            ?░?▒   values   ?░?▒            ░░▒▒   values   ░░▒▒
	//
	// Another important thing to note is that the side length of the grid has to be 2^n + 1 because every new gridpoint needs a new neighbor. So the rightmost column and the bottom row are already part of the next map piece.
	// One other important thing in the implementation of this algorithm is that the relative height change has to decrease the in every iteration. Otherwise the terrain would look really noisy.
	const max = startingScale + 1;
	var seed: u64 = undefined;
	var res: u31 = startingScale/2;
	while (res != 0) : (res /= 2) {
		const randomnessScale = @as(f32, @floatFromInt(res))/@as(f32, @floatFromInt(scale))/2;
		// x coordinate on the grid:
		var x: u31 = 0;
		while (x < max) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < max) : (y += 2*res) {
				setSeed(x, y, offsetX, offsetY, &seed, worldSeed, res, maxResolution);
				bigMap.ptr(x, y).* = (bigMap.get(x, y - res) + bigMap.get(x, y + res))/2 + main.random.nextFloatSigned(&seed)*randomnessScale;
				bigMap.ptr(x, y).* = @min(upperLimit, @max(lowerLimit, bigMap.get(x, y)));
			}
		}
		// y coordinate on the grid:
		x = res;
		while (x + res < max) : (x += 2*res) {
			var y: u31 = 0;
			while (y < max) : (y += 2*res) {
				setSeed(x, y, offsetX, offsetY, &seed, worldSeed, res, maxResolution);
				bigMap.ptr(x, y).* = (bigMap.get(x - res, y) + bigMap.get(x + res, y))/2 + main.random.nextFloatSigned(&seed)*randomnessScale;
				bigMap.ptr(x, y).* = @min(upperLimit, @max(lowerLimit, bigMap.get(x, y)));
			}
		}
		// No coordinate on the grid:
		x = res;
		while (x + res < max) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < max) : (y += 2*res) {
				setSeed(x, y, offsetX, offsetY, &seed, worldSeed, res, maxResolution);
				bigMap.ptr(x, y).* = (bigMap.get(x - res, y - res) + bigMap.get(x - res, y + res) + bigMap.get(x + res, y - res) + bigMap.get(x + res, y + res))/4 + main.random.nextFloatSigned(&seed)*randomnessScale;
				bigMap.ptr(x, y).* = @min(upperLimit, @max(lowerLimit, bigMap.get(x, y)));
			}
		}
	}
}

/// Same as `generateFractalTerrain`, but it generates only a reduced resolution version of the map.
pub fn generateSparseFractalTerrain(wx: i32, wy: i32, scale: u31, worldSeed: u64, map: Array2D(f32), maxResolution: u31) void {
	const scaledWx = @divFloor(wx, maxResolution);
	const scaledWy = @divFloor(wy, maxResolution);
	const scaledScale = scale/maxResolution;
	var x0: u31 = 0;
	while (x0 < map.width) : (x0 += scaledScale) {
		var y0: u31 = 0;
		while (y0 < map.height) : (y0 += scaledScale) {
			generateFractalTerrain(scaledWx +% x0, scaledWy +% y0, x0, y0, @min(map.width - x0, scaledScale), @min(map.height - y0, scaledScale), scaledScale, worldSeed, map, maxResolution);
		}
	}
}

```

`src/server/terrain/noise/FractalNoise1D.zig`:

```zig
const std = @import("std");

const main = @import("main");

fn setSeed(x: i32, offsetX: i32, seed: *u64, worldSeed: u64, scale: u31) void {
	seed.* = main.random.initSeed2D(worldSeed, .{offsetX +% x, scale});
}

pub fn generateFractalTerrain(wx: i32, x0: u31, width: u32, scale: u31, worldSeed: u64, map: []f32) void {
	const max = scale + 1;
	const mask: i32 = scale - 1;
	const bigMap = main.stackAllocator.alloc(f32, max);
	defer main.stackAllocator.free(bigMap);
	const offset = wx & ~mask;
	var seed: u64 = undefined;
	// Generate the 4 corner points of this map using a coordinate-depending seed:
	setSeed(0, offset, &seed, worldSeed, scale);
	bigMap[0] = main.random.nextFloat(&seed);
	setSeed(scale, offset, &seed, worldSeed, scale);
	bigMap[scale] = main.random.nextFloat(&seed);
	generateInitializedFractalTerrain(offset, scale, scale, worldSeed, bigMap, 0, 0.9999);
	@memcpy(map[x0..][0..width], bigMap[@intCast((wx & mask))..][0..width]);
}

pub fn generateInitializedFractalTerrain(offset: i32, scale: u31, startingScale: u31, worldSeed: u64, bigMap: []f32, lowerLimit: f32, upperLimit: f32) void {
	const max = startingScale + 1;
	var seed: u64 = undefined;
	var res: u31 = startingScale/2;
	while (res != 0) : (res /= 2) {
		const randomnessScale = @as(f32, @floatFromInt(res))/@as(f32, @floatFromInt(scale))/2;
		// No coordinate on the grid:
		var x = res;
		while (x + res < max) : (x += 2*res) {
			setSeed(x, offset, &seed, worldSeed, res);
			bigMap[x] = (bigMap[x - res] + bigMap[x + res])/2 + main.random.nextFloatSigned(&seed)*randomnessScale;
			bigMap[x] = @min(upperLimit, @max(lowerLimit, bigMap[x]));
		}
	}
}

pub fn generateSparseFractalTerrain(wx: i32, scale: u31, worldSeed: u64, map: []f32) void {
	var x0: u31 = 0;
	while (x0 < map.len) : (x0 += scale) {
		generateFractalTerrain(wx +% x0, x0, @min(map.len - x0, scale), scale, worldSeed, map);
	}
}

```

`src/server/terrain/noise/FractalNoise3D.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array3D = main.utils.Array3D;
const ChunkPosition = main.chunk.ChunkPosition;
const random = main.random;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const FractalNoise3D = @This();

pos: ChunkPosition,
cache: Array3D(f32),
voxelShift: u5,
scale: u31,
worldSeed: u64,

pub fn generateAligned(allocator: NeverFailingAllocator, wx: i32, wy: i32, wz: i32, voxelSize: u31, width: u31, height: u31, depth: u31, worldSeed: u64, scale: u31) Array3D(f32) {
	std.debug.assert(wx & scale - 1 == 0 and wy & scale - 1 == 0 and wz & scale - 1 == 0); // Alignment;
	std.debug.assert(width - 1 & scale/voxelSize - 1 == 0 and height - 1 & scale/voxelSize - 1 == 0 and depth - 1 & scale/voxelSize - 1 == 0); // dimensions need to be of the form n*scale + 1 with n ∈ ℕ \ {0}
	std.debug.assert(width > 1 and height > 1 and depth > 1); // dimensions need to be of the form n*scale + 1 with n ∈ ℕ \ {0}
	const map = Array3D(f32).init(allocator, width, depth, height);

	// Generate the corners:
	const scaledScale = scale/voxelSize;
	var x0: u31 = 0;
	while (x0 < width) : (x0 += scaledScale) {
		var y0: u31 = 0;
		while (y0 < depth) : (y0 += scaledScale) {
			var z0: u31 = 0;
			while (z0 < height) : (z0 += scaledScale) {
				var seed = random.initSeed3D(worldSeed, .{wx +% x0*voxelSize, wy +% y0*voxelSize, wz +% z0*voxelSize});
				map.ptr(x0, y0, z0).* = (random.nextFloat(&seed) - 0.5)*@as(f32, @floatFromInt(scale));
			}
		}
	}

	generateInitializedFractalTerrain(wx, wy, wz, scaledScale, worldSeed, map, voxelSize);

	return map;
}

fn generateInitializedFractalTerrain(wx: i32, wy: i32, wz: i32, startingScale: u31, worldSeed: u64, bigMap: Array3D(f32), maxResolution: u31) void {
	// Basically an extension to 3D of the FractalNoise algorithm.
	var seed: u64 = undefined;
	var res: u31 = startingScale/2;
	while (res != 0) : (res /= 2) {
		const randomnessScale: f32 = @floatFromInt(res*maxResolution);
		// x and y coordinate on the grid:
		var x: u31 = 0;
		while (x < bigMap.width) : (x += 2*res) {
			var y: u31 = 0;
			while (y < bigMap.depth) : (y += 2*res) {
				var z: u31 = res;
				while (z + res < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x, y, z - res) + bigMap.get(x, y, z + res))/2;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
		// x and z coordinate on the grid:
		x = 0;
		while (x < bigMap.width) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < bigMap.depth) : (y += 2*res) {
				var z: u31 = 0;
				while (z < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x, y - res, z) + bigMap.get(x, y + res, z))/2;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
		// y and z coordinate on the grid:
		x = res;
		while (x + res < bigMap.width) : (x += 2*res) {
			var y: u31 = 0;
			while (y < bigMap.depth) : (y += 2*res) {
				var z: u31 = 0;
				while (z < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x - res, y, z) + bigMap.get(x + res, y, z))/2;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
		// x coordinate on the grid:
		x = 0;
		while (x < bigMap.width) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < bigMap.depth) : (y += 2*res) {
				var z: u31 = res;
				while (z + res < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x, y - res, z) + bigMap.get(x, y + res, z) + bigMap.get(x, y, z - res) + bigMap.get(x, y, z + res))/4;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
		// y coordinate on the grid:
		x = res;
		while (x + res < bigMap.width) : (x += 2*res) {
			var y: u31 = 0;
			while (y < bigMap.depth) : (y += 2*res) {
				var z: u31 = res;
				while (z + res < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x - res, y, z) + bigMap.get(x + res, y, z) + bigMap.get(x, y, z - res) + bigMap.get(x, y, z + res))/4;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
		// z coordinate on the grid:
		x = res;
		while (x + res < bigMap.width) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < bigMap.depth) : (y += 2*res) {
				var z: u31 = 0;
				while (z < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x - res, y, z) + bigMap.get(x + res, y, z) + bigMap.get(x, y - res, z) + bigMap.get(x, y + res, z))/4;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
		// No coordinate on the grid:
		x = res;
		while (x < bigMap.width) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < bigMap.depth) : (y += 2*res) {
				var z: u31 = res;
				while (z + res < bigMap.height) : (z += 2*res) {
					seed = random.initSeed3D(worldSeed, .{x*maxResolution +% wx, y*maxResolution +% wy, z*maxResolution +% wz});
					bigMap.ptr(x, y, z).* = (bigMap.get(x - res, y, z) + bigMap.get(x + res, y, z) + bigMap.get(x, y - res, z) + bigMap.get(x, y + res, z) + bigMap.get(x, y, z - res) + bigMap.get(x, y, z + res))/6;
					bigMap.ptr(x, y, z).* += randomnessScale*(random.nextFloat(&seed) - 0.5);
				}
			}
		}
	}
}

```

`src/server/terrain/noise/PerlinNoise.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array2D = main.utils.Array2D;
const random = main.random;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

// TODO: Simplify with Vec2f and Vec2i.

const Context = struct {
	xGridPoints: Array2D(f32) = undefined,
	yGridPoints: Array2D(f32) = undefined,
	l1: u64,
	l2: u64,
	l3: u64,
	resolution: u31 = undefined,
	resolutionMask: i32 = undefined,

	fn generateGradient(self: Context, x: i32, y: i32, i: i32, resolution: u32) f32 {
		var seed: u64 = self.l1*%@as(u32, @bitCast(x)) +% self.l2*%@as(u32, @bitCast(y)) +% self.l3*%@as(u32, @bitCast(i)) +% resolution; // TODO: Use random.initSeed3D();
		random.scrambleSeed(&seed);
		return 2*random.nextFloat(&seed) - 1;
	}

	fn getGradientX(self: Context, x: i32, y: i32) f32 {
		return self.xGridPoints.get(@intCast(x), @intCast(y));
	}

	fn getGradientY(self: Context, x: i32, y: i32) f32 {
		return self.yGridPoints.get(@intCast(x), @intCast(y));
	}

	/// Function to linearly interpolate between a0 and a1
	fn lerp(a0: f32, a1: f32, w: f32) f32 {
		return a0 + w*(a1 - a0);
	}

	fn sCurve(x: f32) f32 {
		return 3*x*x - 2*x*x*x;
	}

	/// Computes the dot product of the distance and gradient vectors.
	fn dotGridGradient(self: Context, ix: i32, iy: i32, x: f32, y: f32) f32 {
		// Compute the distance vector
		const dx = x/@as(f32, @floatFromInt(self.resolution)) - @as(f32, @floatFromInt(ix));
		const dy = y/@as(f32, @floatFromInt(self.resolution)) - @as(f32, @floatFromInt(iy));

		// Compute the dot-product
		var gx = self.getGradientX(ix, iy);
		var gy = self.getGradientY(ix, iy);
		const gr = @sqrt(gx*gx + gy*gy);
		gx /= gr;
		gy /= gr;
		return dx*gx + dy*gy;
	}

	fn perlin(self: Context, x: i32, y: i32) f32 {
		// Determine grid cell coordinates
		const x0 = @divFloor(x, self.resolution);
		const x1 = x0 + 1;
		const y0 = @divFloor(y, self.resolution);
		const y1 = y0 + 1;

		// Determine interpolation weights using s-curve for smoother edges.
		const sx = sCurve(@as(f32, @floatFromInt(x & self.resolutionMask))/@as(f32, @floatFromInt(self.resolution)));
		const sy = sCurve(@as(f32, @floatFromInt(y & self.resolutionMask))/@as(f32, @floatFromInt(self.resolution)));

		// Interpolate between grid point gradients
		const n00 = self.dotGridGradient(x0, y0, @floatFromInt(x), @floatFromInt(y));
		const n01 = self.dotGridGradient(x0, y1, @floatFromInt(x), @floatFromInt(y));
		const n10 = self.dotGridGradient(x1, y0, @floatFromInt(x), @floatFromInt(y));
		const n11 = self.dotGridGradient(x1, y1, @floatFromInt(x), @floatFromInt(y));
		const n0 = lerp(n00, n01, sy);
		const n1 = lerp(n10, n11, sy);
		const n = lerp(n0, n1, sx);
		return n*@sqrt(2.0);
	}

	// Calculate all grid points that will be needed to prevent double calculating them.
	fn calculateGridPoints(self: *Context, allocator: NeverFailingAllocator, x: i32, y: i32, _width: u31, _height: u31, scale: u31) void {
		// Create one gridpoint more, just in case...
		const width = _width + scale;
		const height = _height + scale;
		const resolutionShift = @ctz(scale);
		// Determine grid cell coordinates of all cells that points can be in:
		self.xGridPoints = Array2D(f32).init(allocator, width/scale + 3, height/scale + 3); // Simply assume the absolute maximum number of grid points are generated.
		self.yGridPoints = Array2D(f32).init(allocator, width/scale + 3, height/scale + 3); // Simply assume the absolute maximum number of grid points are generated.
		var numX: u31 = 0;
		var numY: u31 = undefined;
		var x0: i32 = 0;
		var ix: i32 = x;
		while (ix != x +% width) : (ix +%= scale) {
			numY = 0;
			x0 = ix >> resolutionShift;
			var y0: i32 = 0;
			var iy: i32 = y;
			while (iy != y +% width) : (iy +%= scale) {
				y0 = iy >> resolutionShift;
				self.xGridPoints.ptr(numX, numY).* = self.generateGradient(x0, y0, 0, resolutionShift);
				self.yGridPoints.ptr(numX, numY).* = self.generateGradient(x0, y0, 1, resolutionShift);
				numY += 1;
			}
			self.xGridPoints.ptr(numX, numY).* = self.generateGradient(x0, y0 + 1, 0, resolutionShift);
			self.yGridPoints.ptr(numX, numY).* = self.generateGradient(x0, y0 + 1, 1, resolutionShift);
			numX += 1;
		}
		numY = 0;
		var y0: i32 = 0;
		var iy: i32 = y;
		while (iy != y +% width) : (iy +%= scale) {
			y0 = iy >> resolutionShift;
			self.xGridPoints.ptr(numX, numY).* = self.generateGradient(x0 + 1, y0, 0, resolutionShift);
			self.yGridPoints.ptr(numX, numY).* = self.generateGradient(x0 + 1, y0, 1, resolutionShift);
			numY += 1;
		}
		self.xGridPoints.ptr(numX, numY).* = self.generateGradient(x0 + 1, y0 + 1, 0, resolutionShift);
		self.yGridPoints.ptr(numX, numY).* = self.generateGradient(x0 + 1, y0 + 1, 1, resolutionShift);
		numX += 1;
	}

	fn freeGridPoints(self: *Context, allocator: NeverFailingAllocator) void {
		self.yGridPoints.deinit(allocator);
		self.xGridPoints.deinit(allocator);
		self.yGridPoints = undefined;
		self.xGridPoints = undefined;
	}
};

/// Returns a smooth map of floats with values between 0 and 1.
pub fn generateSmoothNoise(allocator: NeverFailingAllocator, x: i32, y: i32, width: u31, height: u31, maxScale: u31, minScale: u31, worldSeed: u64, voxelSize: u31, reductionFactor: f32) Array2D(f32) {
	const map = Array2D(f32).init(allocator, width/voxelSize, height/voxelSize);
	@memset(map.mem, 0);
	var seed = worldSeed;
	random.scrambleSeed(&seed);
	var context = Context{
		.l1 = random.nextInt(u64, &seed),
		.l2 = random.nextInt(u64, &seed),
		.l3 = random.nextInt(u64, &seed),
	};
	var fac = 1/((1 - std.math.pow(f32, reductionFactor, @as(f32, @floatFromInt(@ctz(maxScale/minScale) + 1))))/(1 - reductionFactor)); // geometric series.
	var scale = maxScale;
	while (scale >= minScale) : (scale >>= 1) {
		context.resolution = scale;
		context.resolutionMask = scale - 1;
		const x0 = x & ~context.resolutionMask;
		const y0 = y & ~context.resolutionMask;
		context.calculateGridPoints(main.stackAllocator, x, y, width, height, scale);
		defer context.freeGridPoints(main.stackAllocator);

		var x1 = x;
		while (x1 -% width -% x < 0) : (x1 +%= voxelSize) {
			var y1 = y;
			while (y1 -% y -% height < 0) : (y1 +%= voxelSize) {
				map.ptr(@as(u32, @intCast(x1 -% x))/voxelSize, @as(u32, @intCast(y1 -% y))/voxelSize).* += @abs(context.perlin(x1 -% x0, y1 -% y0))*fac;
			}
		}
		fac *= reductionFactor;
	}
	return map;
}

```

`src/server/terrain/noise/RandomlyWeightedFractalNoise.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Array2D = main.utils.Array2D;

fn setSeed(x: i32, y: i32, offsetX: i32, offsetY: i32, seed: *u64, worldSeed: u64, scale: u31, maxResolution: u31) void {
	seed.* = main.random.initSeed2D(worldSeed*%(scale*maxResolution | 1), .{(offsetX +% x)*%maxResolution, (offsetY +% y)*%maxResolution});
}

pub fn generateFractalTerrain(wx: i32, wy: i32, x0: u31, y0: u31, width: u32, height: u32, scale: u31, worldSeed: u64, map: Array2D(f32), maxResolution: u31) void {
	const max = scale + 1;
	const mask: i32 = scale - 1;
	const bigMap = Array2D(f32).init(main.stackAllocator, max, max);
	defer bigMap.deinit(main.stackAllocator);
	const offsetX = wx & ~mask;
	const offsetY = wy & ~mask;
	var seed: u64 = undefined;
	// Generate the 4 corner points of this map using a coordinate-depending seed:
	setSeed(0, 0, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(0, 0).* = main.random.nextFloat(&seed);
	setSeed(0, scale, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(0, scale).* = main.random.nextFloat(&seed);
	setSeed(scale, 0, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(scale, 0).* = main.random.nextFloat(&seed);
	setSeed(scale, scale, offsetX, offsetY, &seed, worldSeed, scale, maxResolution);
	bigMap.ptr(scale, scale).* = main.random.nextFloat(&seed);
	generateInitializedFractalTerrain(offsetX, offsetY, scale, scale, worldSeed, bigMap, maxResolution);
	var px: u31 = 0;
	while (px < width) : (px += 1) {
		@memcpy(map.getRow(x0 + px)[y0..][0..height], bigMap.getRow(@intCast((wx & mask) + px))[@intCast((wy & mask))..][0..height]);
	}
}

pub fn generateInitializedFractalTerrain(offsetX: i32, offsetY: i32, scale: u31, startingScale: u31, worldSeed: u64, bigMap: Array2D(f32), maxResolution: u31) void {
	// Increase the "grid" of points with already known heights in each round by a factor of 2×2, like so(# marks the gridpoints of the first grid, * the points of the second grid and + the points of the third grid(and so on…)):
	//
	//  #+*+#
	//  +++++
	//  *+*+*
	//  +++++
	//  #+*+#
	//
	// Each new gridpoint gets the interpolated height value of the surrounding known grid points using random weights. Afterwards this value gets offset by a random value.
	// Here is a visual representation of this process(with random starting values):
	//
	// █░▒▓                     small                           small
	//  █???█   grid    █?█?█   random  █?▓?█   grid    ██▓▓█   random  ██▓▓█
	//  ?????   resize  ?????   change  ?????   resize  █▓▓▓▒   change  █▓█▓▒
	//  ?????   →→→→    ▓?▓?▒   →→→→    ▒?█?▒   →→→→    ▒▒██▒   →→→→    ▒▒██▒
	//  ?????           ?????   of new  ?????           ░▒░▒▒   of new  ░▒░▒░
	//  ???▒            ? ?▒   values   ?░?▒             ░░▒   values    ░░▒
	//
	// Another important thing to note is that the side length of the grid has to be 2^n + 1 because every new gridpoint needs a new neighbor.
	// So the rightmost column and the bottom row are already part of the next map piece.
	// One other important thing in the implementation of this algorithm is that the relative height change has to decrease in every iteration. Otherwise the terrain would look noisy.
	const max = startingScale + 1;
	var seed: u64 = undefined;
	var res: u31 = startingScale/2;
	while (res != 0) : (res /= 2) {
		const randomnessScale = @as(f32, @floatFromInt(res))/@as(f32, @floatFromInt(scale))/2;
		// x coordinate on the grid:
		var x: u31 = 0;
		while (x < max) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < max) : (y += 2*res) {
				setSeed(x, y, offsetX, offsetY, &seed, worldSeed, res, maxResolution);
				const w = main.random.nextFloat(&seed);
				bigMap.ptr(x, y).* = bigMap.get(x, y - res)*(1 - w) + bigMap.get(x, y + res)*w + main.random.nextFloatSigned(&seed)*randomnessScale;
				bigMap.ptr(x, y).* = bigMap.get(x, y);
			}
		}
		// y coordinate on the grid:
		x = res;
		while (x + res < max) : (x += 2*res) {
			var y: u31 = 0;
			while (y < max) : (y += 2*res) {
				setSeed(x, y, offsetX, offsetY, &seed, worldSeed, res, maxResolution);
				const w = main.random.nextFloat(&seed);
				bigMap.ptr(x, y).* = bigMap.get(x - res, y)*(1 - w) + bigMap.get(x + res, y)*w + main.random.nextFloatSigned(&seed)*randomnessScale;
				bigMap.ptr(x, y).* = bigMap.get(x, y);
			}
		}
		// No coordinate on the grid:
		x = res;
		while (x + res < max) : (x += 2*res) {
			var y: u31 = res;
			while (y + res < max) : (y += 2*res) {
				setSeed(x, y, offsetX, offsetY, &seed, worldSeed, res, maxResolution);
				const w1 = main.random.nextFloat(&seed);
				const w2 = main.random.nextFloat(&seed);
				bigMap.ptr(x, y).* = (bigMap.get(x - res, y - res)*(1 - w1) + bigMap.get(x - res, y + res)*w1)*(1 - w2) + (bigMap.get(x + res, y - res)*(1 - w1) + bigMap.get(x + res, y + res)*w1)*w2 + main.random.nextFloatSigned(&seed)*randomnessScale;
				bigMap.ptr(x, y).* = bigMap.get(x, y);
			}
		}
	}
}

/// Same as `generateFractalTerrain`, but it generates only a reduced resolution version of the map.
pub fn generateSparseFractalTerrain(wx: i32, wy: i32, scale: u31, worldSeed: u64, map: Array2D(f32), maxResolution: u31) void {
	const scaledWx = @divFloor(wx, maxResolution);
	const scaledWy = @divFloor(wy, maxResolution);
	const scaledScale = scale/maxResolution;
	var x0: u31 = 0;
	while (x0 < map.width) : (x0 += scaledScale) {
		var y0: u31 = 0;
		while (y0 < map.height) : (y0 += scaledScale) {
			generateFractalTerrain(scaledWx +% x0, scaledWy +% y0, x0, y0, @min(map.width - x0, scaledScale), @min(map.height - y0, scaledScale), scaledScale, worldSeed, map, maxResolution);
		}
	}
}

```

`src/server/terrain/noise/ValueNoise.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;

fn getSeedX(x: f32, worldSeed: u64) u64 {
	return worldSeed ^ @as(u64, 54275629861)*%@as(u32, @bitCast(@as(i32, @intFromFloat(x))));
}

fn getSeedY(x: f32, worldSeed: u64) u64 {
	return worldSeed ^ @as(u64, 5478938690717)*%@as(u32, @bitCast(@as(i32, @intFromFloat(x))));
}

fn getGridValue1D(x: f32, worldSeed: u64) f32 {
	var seed: u64 = getSeedX(x, worldSeed);
	return random.nextFloat(&seed);
}

fn samplePoint1D(_x: f32, lineSeed: u64) f32 {
	var seed = lineSeed;
	const x = _x + 0.0001*random.nextFloat(&seed); // random offset
	const start = @floor(x);
	const interp = x - start;
	return (1 - interp)*getGridValue1D(start, lineSeed) + interp*getGridValue1D(start + 1, lineSeed);
}

/// The result will be between 0 and 1.
pub fn samplePoint2D(x: f32, _y: f32, worldSeed: u64) f32 {
	var seed = worldSeed;
	const y = _y + random.nextFloat(&seed); // random offset
	const lineSeed = random.nextInt(u64, &seed);

	const start = @floor(y);
	const interp = y - start;
	const lower = samplePoint1D(x, getSeedY(start, lineSeed));
	const upper = samplePoint1D(x, getSeedY(start + 1, lineSeed));
	return (1 - interp)*lower + interp*upper;
}

const percentileTable = [_]f32{0.0e+00, 9.20569300e-02, 1.18748918e-01, 1.38117700e-01, 1.53936773e-01, 1.67584523e-01, 1.79740771e-01, 1.90797567e-01, 2.01004371e-01, 2.10530936e-01, 2.19498828e-01, 2.27998286e-01, 2.36098647e-01, 2.43854254e-01, 2.51308768e-01, 2.58497864e-01, 2.65450924e-01, 2.72192806e-01, 2.78744399e-01, 2.85123795e-01, 2.91346460e-01, 2.97426044e-01, 3.03374379e-01, 3.09202045e-01, 3.14918369e-01, 3.20531696e-01, 3.26049506e-01, 3.31478625e-01, 3.36825191e-01, 3.42094779e-01, 3.47292482e-01, 3.52423042e-01, 3.57490718e-01, 3.62499535e-01, 3.67453157e-01, 3.72355014e-01, 3.77208292e-01, 3.82015973e-01, 3.86780887e-01, 3.91505628e-01, 3.96192669e-01, 4.00844365e-01, 4.05462920e-01, 4.10050421e-01, 4.14608865e-01, 4.19140160e-01, 4.23646122e-01, 4.28128510e-01, 4.32588934e-01, 4.37029063e-01, 4.41450417e-01, 4.45854485e-01, 4.50242727e-01, 4.54616576e-01, 4.58977371e-01, 4.63326483e-01, 4.67665165e-01, 4.71994757e-01, 4.76316481e-01, 4.80631619e-01, 4.84941333e-01, 4.89246904e-01, 4.93549466e-01, 4.97850269e-01, 5.02150475e-01, 5.06451249e-01, 5.10753810e-01, 5.15059411e-01, 5.19369125e-01, 5.23684263e-01, 5.28005957e-01, 5.32335579e-01, 5.36674261e-01, 5.41023373e-01, 5.45384168e-01, 5.49758017e-01, 5.54146230e-01, 5.58550298e-01, 5.62971651e-01, 5.67411780e-01, 5.71872234e-01, 5.76354622e-01, 5.80860555e-01, 5.85391879e-01, 5.89950323e-01, 5.94537794e-01, 5.99156379e-01, 6.03808045e-01, 6.08495116e-01, 6.13219857e-01, 6.17984771e-01, 6.22792422e-01, 6.27645730e-01, 6.32547557e-01, 6.37501180e-01, 6.42509996e-01, 6.47577702e-01, 6.52708232e-01, 6.57905936e-01, 6.63175523e-01, 6.68522059e-01, 6.73951208e-01, 6.79469048e-01, 6.85082376e-01, 6.90798640e-01, 6.96626305e-01, 7.02574670e-01, 7.08654224e-01, 7.14876949e-01, 7.21256315e-01, 7.27807879e-01, 7.34549760e-01, 7.41502821e-01, 7.48691916e-01, 7.56146430e-01, 7.63902068e-01, 7.72002398e-01, 7.80501842e-01, 7.89469778e-01, 7.98996329e-01, 8.09203147e-01, 8.20259928e-01, 8.32416176e-01, 8.46063911e-01, 8.61882984e-01, 8.81251752e-01, 9.07943725e-01, 1.0e+00};

fn preGeneratePercentileTable() void {
	const randomNumbers = 4096;
	const positions = 4096;
	const totalValues = randomNumbers*positions;
	const values = randomNumbers;
	var amount1D: [values + 1]u128 = undefined;
	@memset(&amount1D, 0);
	for (0..randomNumbers) |a| {
		for (0..randomNumbers) |b| {
			for (0..positions + 1) |x| {
				const val = x*(2*a + 1) + (positions - x)*(2*b + 1);
				amount1D[(val*values)/totalValues/2] += 1;
			}
		}
	}
	var amount2D: [values + 1]u128 = undefined;
	@memset(&amount2D, 0);
	for (0..randomNumbers) |a| {
		for (0..randomNumbers) |b| {
			for (0..positions + 1) |x| {
				const val = x*(2*a + 1) + (positions - x)*(2*b + 1);
				amount2D[(val*values)/totalValues/2] += amount1D[a]*amount1D[b];
			}
		}
	}
	var samples: u128 = 0;
	for (&amount2D) |val| {
		samples = std.math.add(u128, samples, val) catch @panic("Number too big");
	}
	std.log.info("{}", .{samples});

	var percentiles: [128]f32 = undefined;
	var current: u128 = 0;
	var i: usize = 0;
	for (&percentiles, 0..) |*_percentile, j| {
		const goal = j*samples/(percentiles.len - 1);
		while (current + amount2D[i] < goal) {
			current += amount2D[i];
			i += 1;
		}
		const diff = goal - current;
		_percentile.* = (@as(f32, @floatFromInt(i)) + @as(f32, @floatFromInt(diff))/@as(f32, @floatFromInt(amount2D[i])))/randomNumbers;
	}

	for (&percentiles) |_percentile| {
		std.log.info("{}", .{_percentile});
	}
}

pub fn percentile(ratio: f32) f32 {
	std.debug.assert(ratio >= 0);
	const scaledToList = ratio*@as(f32, @floatFromInt(percentileTable.len));
	const index: u32 = @intFromFloat(scaledToList);
	if (index >= percentileTable.len - 1) return 1;
	const offset = (scaledToList - @as(f32, @floatFromInt(index)));
	return (1 - offset)*percentileTable[index] + offset*percentileTable[index + 1];
}

```

`src/server/terrain/noise/noise.zig`:

```zig
/// Like FractalNoise, except in 3D and it generates values on demand and caches results, instead of generating everything at once.
pub const CachedFractalNoise3D = @import("CachedFractalNoise3D.zig");

/// Like FractalNoise, except in 1D.
pub const FractalNoise1D = @import("FractalNoise1D.zig");

/// Like FractalNoise, except in 3D.
pub const FractalNoise3D = @import("FractalNoise3D.zig");

/// Uses a recursive subdivision algorithm to generate a noise map.
pub const FractalNoise = @import("FractalNoise.zig");

/// Like FractalNoise, except it generates values on demand and caches results, instead of generating everything at once.
pub const CachedFractalNoise = @import("CachedFractalNoise.zig");

/// The same as fractal noise, but uses random weigths during interpolation phase.
/// This generates a rough terrain with some cliffs.
pub const RandomlyWeightedFractalNoise = @import("RandomlyWeightedFractalNoise.zig");

/// Blue noise (aka Poisson Disk Sampling) is a pattern that ensures that all points have a minimum distance towards their neigbors.
/// This contains a static blue noise pattern that is calculated once and then used everywhere around the world. because it is so big the player will never notice issues.
pub const BlueNoise = @import("BlueNoise.zig");

pub const PerlinNoise = @import("PerlinNoise.zig");

pub const ValueNoise = @import("ValueNoise.zig");

```

`src/server/terrain/simple_structures/Boulder.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:boulder";

pub const generationMode = .floor;

const Boulder = @This();

block: main.blocks.Block,
size: f32,
sizeVariation: f32,

pub fn loadModel(parameters: ZonElement) ?*Boulder {
	const self = main.worldArena.create(Boulder);
	self.* = .{
		.block = main.blocks.parseBlock(parameters.get([]const u8, "block", "cubyz:slate/base")),
		.size = parameters.get(f32, "size", 4),
		.sizeVariation = parameters.get(f32, "size_variation", 1),
	};
	return self;
}

pub fn generate(self: *Boulder, _: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, _: CaveBiomeMapView, seed: *u64, _: bool) void {
	_ = caveMap;
	const radius = self.size + self.sizeVariation*(random.nextFloat(seed)*2 - 1);
	// My basic idea is to use a point cloud and a potential function to achieve somewhat smooth boulders without being a sphere.
	const numberOfPoints = 4;
	var pointCloud: [numberOfPoints]Vec3f = undefined;
	for (&pointCloud) |*point| {
		point.* = Vec3f{
			(random.nextFloat(seed) - 0.5)*radius/2,
			(random.nextFloat(seed) - 0.5)*radius/2,
			(random.nextFloat(seed) - 0.5)*radius/2,
		};
	}
	// My potential functions is ¹⁄ₙ Σ (radius/2)²/(x⃗ - x⃗ₚₒᵢₙₜ)²
	// This ensures that the entire boulder is inside of a square with sidelength 2*radius.
	const maxRadius: i32 = @intFromFloat(@ceil(radius));
	var px = chunk.startIndex(x - maxRadius);
	while (px < x + maxRadius) : (px += chunk.super.pos.voxelSize) {
		var py = chunk.startIndex(y - maxRadius);
		while (py < y + maxRadius) : (py += chunk.super.pos.voxelSize) {
			var pz = chunk.startIndex(z - maxRadius);
			while (pz < z + maxRadius) : (pz += chunk.super.pos.voxelSize) {
				if (!chunk.liesInChunk(px, py, pz)) continue;
				var potential: f32 = 0;
				for (&pointCloud) |point| {
					const delta = @as(Vec3f, @floatFromInt(Vec3i{px, py, pz} - Vec3i{x, y, z})) - point;
					const distSqr = vec.dot(delta, delta);
					potential += 1/distSqr;
				}
				potential *= radius*radius/4/numberOfPoints;
				if (potential >= 1) {
					chunk.updateBlockInGeneration(px, py, pz, self.block);
				}
			}
		}
	}
}

```

`src/server/terrain/simple_structures/FallenTree.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:fallen_tree";

pub const generationMode = .floor;

const FallenTree = @This();

woodBlock: u16,
topWoodBlock: u16,
height0: u32,
deltaHeight: u31,

pub fn loadModel(parameters: ZonElement) ?*FallenTree {
	const self = main.worldArena.create(FallenTree);
	self.* = .{
		.woodBlock = main.blocks.getTypeById(parameters.get([]const u8, "log", "cubyz:oak_log")),
		.topWoodBlock = main.blocks.getTypeById(parameters.get([]const u8, "top", "cubyz:oak_top")),
		.height0 = parameters.get(u32, "height", 6),
		.deltaHeight = parameters.get(u31, "height_variation", 3),
	};
	return self;
}

pub fn generateStump(self: *FallenTree, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk) void {
	if (chunk.liesInChunk(x, y, z))
		chunk.updateBlockIfDegradable(x, y, z, .{.typ = self.woodBlock, .data = 0});
}

pub fn generateFallen(self: *FallenTree, x: i32, y: i32, z: i32, length: u32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, seed: *u64) void {
	var d: ?u32 = null;

	const sh = caveMap.getHeightData(x, y);

	for (0..4) |_| {
		const dir: u32 = main.random.nextIntBounded(u32, seed, 4);

		var dx: i32 = 0;
		var dy: i32 = 0;

		if (dir == 0) {
			dx = 1;
		} else if (dir == 1) {
			dx = -1;
		} else if (dir == 2) {
			dy = 1;
		} else if (dir == 3) {
			dy = -1;
		}

		var works = true;
		for (0..length) |j| {
			const v: i32 = @intCast(j);
			if (caveMap.getHeightData(x + dx*(v + 2), y + dy*(v + 2)) != sh) {
				works = false;
				break;
			}
		}

		if (works) {
			d = dir;
			break;
		}
	}

	if (d == null)
		return;

	var dx: i32 = 0;
	var dy: i32 = 0;

	if (d.? == 0) {
		dx = 1;
	} else if (d.? == 1) {
		dx = -1;
	} else if (d.? == 2) {
		dy = 1;
	} else if (d.? == 3) {
		dy = -1;
	}

	for (0..length) |val| {
		const v: i32 = @intCast(val);
		if (chunk.liesInChunk(x + dx*(v + 2), y + dy*(v + 2), z)) {
			const typ = if (v == (length - 1)) self.topWoodBlock else self.woodBlock;
			chunk.updateBlockIfDegradable(x + dx*(v + 2), y + dy*(v + 2), z, .{.typ = typ, .data = @intCast(d.? + 2)});
		}
	}
}

pub fn generate(self: *FallenTree, _: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, _: CaveBiomeMapView, seed: *u64, _: bool) void {
	const height = self.height0 + random.nextIntBounded(u31, seed, self.deltaHeight);

	generateStump(self, x, y, z, chunk);

	generateFallen(self, x, y, z, height - 2, chunk, caveMap, seed);
}

```

`src/server/terrain/simple_structures/FlowerPatch.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:flower_patch";

pub const generationMode = .floor;

const FlowerPatch = @This();

block: main.blocks.Block,
width: f32,
variation: f32,
density: f32,

pub fn loadModel(parameters: ZonElement) ?*FlowerPatch {
	const self = main.worldArena.create(FlowerPatch);
	self.* = .{
		.block = main.blocks.parseBlock(parameters.get([]const u8, "block", "")),
		.width = parameters.get(f32, "width", 5),
		.variation = parameters.get(f32, "variation", 1),
		.density = parameters.get(f32, "density", 0.5),
	};
	return self;
}

pub fn generate(self: *FlowerPatch, mode: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, caveBiomeMap: CaveBiomeMapView, seed: *u64, _: bool) void {
	const width = self.width + (random.nextFloat(seed) - 0.5)*self.variation;
	const orientation = 2*std.math.pi*random.nextFloat(seed);
	const ellipseParam = 1 + random.nextFloat(seed);

	// Orientation of the major and minor half axis of the ellipse.
	// For now simply use a minor axis 1/ellipseParam as big as the major.
	const xMain = @sin(orientation)/width;
	const yMain = @cos(orientation)/width;
	const xSecn = ellipseParam*@cos(orientation)/width;
	const ySecn = -ellipseParam*@sin(orientation)/width;

	const xMin = @max(0, x - @as(i32, @intFromFloat(@ceil(width))));
	const xMax = @min(chunk.super.width, x + @as(i32, @intFromFloat(@ceil(width))));
	const yMin = @max(0, y - @as(i32, @intFromFloat(@ceil(width))));
	const yMax = @min(chunk.super.width, y + @as(i32, @intFromFloat(@ceil(width))));

	var baseHeight = z;
	if (mode != .water_surface) {
		if (caveMap.isSolid(x, y, baseHeight)) {
			baseHeight = caveMap.findTerrainChangeAbove(x, y, baseHeight) - 1;
		} else {
			baseHeight = caveMap.findTerrainChangeBelow(x, y, baseHeight);
		}
	}

	var px = chunk.startIndex(xMin);
	while (px < xMax) : (px += 1) {
		var py = chunk.startIndex(yMin);
		while (py < yMax) : (py += 1) {
			const mainDist = xMain*@as(f32, @floatFromInt(x - px)) + yMain*@as(f32, @floatFromInt(y - py));
			const secnDist = xSecn*@as(f32, @floatFromInt(x - px)) + ySecn*@as(f32, @floatFromInt(y - py));
			const distSqr = mainDist*mainDist + secnDist*secnDist;
			if (distSqr <= 1) {
				if ((1 - distSqr)*self.density < random.nextFloat(seed)) continue;
				var startHeight = z;

				if (mode == .water_surface) {
					if (caveBiomeMap.getSurfaceHeight(chunk.super.pos.wx + px, chunk.super.pos.wy + py) >= 0) continue;
					startHeight = z -% 1;
				} else {
					if (caveMap.isSolid(px, py, startHeight)) {
						startHeight = caveMap.findTerrainChangeAbove(px, py, startHeight) -% 1;
					} else {
						startHeight = caveMap.findTerrainChangeBelow(px, py, startHeight);
					}
				}

				startHeight = chunk.startIndex(startHeight + chunk.super.pos.voxelSize);
				if (@abs(startHeight -% baseHeight) > 5) continue;
				if (chunk.liesInChunk(px, py, startHeight)) {
					chunk.updateBlockInGeneration(px, py, startHeight, self.block);
				}
			}
		}
	}
}

```

`src/server/terrain/simple_structures/GroundPatch.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:ground_patch";

pub const generationMode = .floor;

const GroundPatch = @This();

block: main.blocks.Block,
width: f32,
variation: f32,
depth: i32,
smoothness: f32,

pub fn loadModel(parameters: ZonElement) ?*GroundPatch {
	const self = main.worldArena.create(GroundPatch);
	self.* = .{
		.block = main.blocks.parseBlock(parameters.get([]const u8, "block", "")),
		.width = parameters.get(f32, "width", 5),
		.variation = parameters.get(f32, "variation", 1),
		.depth = parameters.get(i32, "depth", 2),
		.smoothness = parameters.get(f32, "smoothness", 0),
	};
	return self;
}

pub fn generate(self: *GroundPatch, mode: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, caveBiomeMap: CaveBiomeMapView, seed: *u64, _: bool) void {
	const width = self.width + (random.nextFloat(seed) - 0.5)*self.variation;
	const orientation = 2*std.math.pi*random.nextFloat(seed);
	const ellipseParam = 1 + random.nextFloat(seed);

	// Orientation of the major and minor half axis of the ellipse.
	// For now simply use a minor axis 1/ellipseParam as big as the major.
	const xMain = @sin(orientation)/width;
	const yMain = @cos(orientation)/width;
	const xSecn = ellipseParam*@cos(orientation)/width;
	const ySecn = -ellipseParam*@sin(orientation)/width;

	const xMin = @max(0, x - @as(i32, @intFromFloat(@ceil(width))));
	const xMax = @min(chunk.super.width, x + @as(i32, @intFromFloat(@ceil(width))));
	const yMin = @max(0, y - @as(i32, @intFromFloat(@ceil(width))));
	const yMax = @min(chunk.super.width, y + @as(i32, @intFromFloat(@ceil(width))));

	var baseHeight = z;
	if (mode != .water_surface) {
		if (caveMap.isSolid(x, y, baseHeight)) {
			baseHeight = caveMap.findTerrainChangeAbove(x, y, baseHeight) - 1;
		} else {
			baseHeight = caveMap.findTerrainChangeBelow(x, y, baseHeight);
		}
	}

	var px = chunk.startIndex(xMin);
	while (px < xMax) : (px += 1) {
		var py = chunk.startIndex(yMin);
		while (py < yMax) : (py += 1) {
			const mainDist = xMain*@as(f32, @floatFromInt(x - px)) + yMain*@as(f32, @floatFromInt(y - py));
			const secnDist = xSecn*@as(f32, @floatFromInt(x - px)) + ySecn*@as(f32, @floatFromInt(y - py));
			const dist = mainDist*mainDist + secnDist*secnDist;
			if (dist <= 1) {
				var startHeight = z;

				if (mode == .water_surface) {
					startHeight -%= 1;
					startHeight &= ~chunk.super.voxelSizeMask;
				} else {
					if (caveMap.isSolid(px, py, startHeight)) {
						startHeight = caveMap.findTerrainChangeAbove(px, py, startHeight) -% 1;
					} else {
						startHeight = caveMap.findTerrainChangeBelow(px, py, startHeight);
					}
				}
				var pz = chunk.startIndex(startHeight - self.depth + 1);
				if (mode == .water_surface) {
					const surfaceHeight = caveBiomeMap.getSurfaceHeight(chunk.super.pos.wx + px, chunk.super.pos.wy + py);
					pz = @max(pz, surfaceHeight -% chunk.super.pos.wz);
				}
				if (@abs(startHeight -% baseHeight) > 5) continue;
				while (pz <= startHeight) : (pz += chunk.super.pos.voxelSize) {
					if (dist <= self.smoothness or (dist - self.smoothness)/(1 - self.smoothness) < random.nextFloat(seed)) {
						if (chunk.liesInChunk(px, py, pz)) {
							chunk.updateBlockInGeneration(px, py, pz, self.block);
						}
					}
				}
			}
		}
	}
}

```

`src/server/terrain/simple_structures/SbbGen.zig`:

```zig
const std = @import("std");

const main = @import("main");
const terrain = main.server.terrain;
const Vec3i = main.vec.Vec3i;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const CaveMapView = terrain.CaveMap.CaveMapView;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const sbb = terrain.structure_building_blocks;
const Blueprint = main.blueprint.Blueprint;
const ZonElement = main.ZonElement;
const Neighbor = main.chunk.Neighbor;
const ServerChunk = main.chunk.ServerChunk;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:sbb";
pub const generationMode = .floor;

const SbbGen = @This();

structureRef: *const sbb.StructureBuildingBlock,
placeMode: Blueprint.PasteMode,
rotation: sbb.Rotation,

pub fn getHash(self: SbbGen) u64 {
	return std.hash.Wyhash.hash(@intFromEnum(self.placeMode), self.structureRef.id);
}

pub fn loadModel(parameters: ZonElement) ?*SbbGen {
	const structureId = parameters.get(?[]const u8, "structure", null) orelse {
		std.log.err("Error loading generator 'cubyz:sbb' structure field is mandatory.", .{});
		return null;
	};
	const structureRef = sbb.getByStringId(structureId) orelse {
		std.log.err("Could not find blueprint with id {s}. Structure will not be added.", .{structureId});
		return null;
	};
	const rotationParam = parameters.getChild("rotation");
	const rotation = sbb.Rotation.fromZon(rotationParam) catch |err| blk: {
		switch (err) {
			error.UnknownString => std.log.err("Error loading generator 'cubyz:sbb' structure '{s}': Specified unknown rotation '{s}'", .{structureId, rotationParam.as([]const u8, "")}),
			error.UnknownType => std.log.err("Error loading generator 'cubyz:sbb' structure '{s}': Unsupported type of rotation field '{s}'", .{structureId, @tagName(rotationParam)}),
		}
		break :blk .random;
	};
	const self = main.worldArena.create(SbbGen);
	self.* = .{
		.structureRef = structureRef,
		.placeMode = std.meta.stringToEnum(Blueprint.PasteMode, parameters.get([]const u8, "placeMode", "degradable")) orelse Blueprint.PasteMode.degradable,
		.rotation = rotation,
	};
	return self;
}

pub fn generate(self: *SbbGen, _: GenerationMode, x: i32, y: i32, z: i32, chunk: *ServerChunk, _: CaveMapView, _: CaveBiomeMapView, seed: *u64, _: bool) void {
	placeSbb(self, self.structureRef, Vec3i{x, y, z}, null, self.rotation.getInitialRotation(seed), chunk, seed);
}

fn placeSbb(self: *SbbGen, structure: *const sbb.StructureBuildingBlock, placementPosition: Vec3i, placementDirection: ?Neighbor, rotation: sbb.Rotation, chunk: *ServerChunk, seed: *u64) void {
	const blueprints = &(structure.getBlueprints(seed).* orelse return);

	const origin = blueprints[0].originBlock;
	const blueprintRotation = rotation.apply(alignDirections(origin.direction(), placementDirection orelse origin.direction()) catch |err| {
		std.log.err("Could not align directions for structure '{s}' for directions '{s}'' and '{s}', error: {s}", .{structure.id, @tagName(origin.direction()), @tagName(placementDirection orelse origin.direction()), @errorName(err)});
		return;
	});
	const rotated = &blueprints[@intFromEnum(blueprintRotation)];
	const rotatedOrigin = rotated.originBlock.pos();
	const pastePosition = placementPosition - rotatedOrigin - (placementDirection orelse origin.direction()).relPos();

	rotated.blueprint.pasteInGeneration(pastePosition, chunk, self.placeMode);

	for (rotated.childBlocks) |childBlock| {
		const child = structure.getChildStructure(childBlock) orelse continue;
		const childRotation = rotation.getChildRotation(seed, child.rotation, childBlock.direction());
		placeSbb(self, child, pastePosition + childBlock.pos(), childBlock.direction(), childRotation, chunk, seed);
	}
}

fn alignDirections(input: Neighbor, desired: Neighbor) !sbb.Rotation.FixedRotation {
	comptime var alignTable: [6][6]error{NotPossibleToAlign}!sbb.Rotation.FixedRotation = undefined;
	comptime for (Neighbor.iterable) |in| {
		for (Neighbor.iterable) |out| blk: {
			var current = in;
			for (0..4) |i| {
				if (current == out) {
					alignTable[in.toInt()][out.toInt()] = @enumFromInt(i);
					break :blk;
				}
				current = current.rotateZ();
			}
			alignTable[in.toInt()][out.toInt()] = error.NotPossibleToAlign;
		}
	};
	const runtimeTable = alignTable;
	return runtimeTable[input.toInt()][desired.toInt()];
}

```

`src/server/terrain/simple_structures/SimpleTreeModel.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:simple_tree";

const SimpleTreeModel = @This();

pub const generationMode = .floor;

const Type = enum {
	pyramid,
	round,
};

typ: Type,
leavesBlock: main.blocks.Block,
woodBlock: main.blocks.Block,
topWoodBlock: main.blocks.Block,
height0: i32,
deltaHeight: u31,
leafRadius: f32,
deltaLeafRadius: f32,
leafElongation: f32,
deltaLeafElongation: f32,
branched: bool,

pub fn loadModel(parameters: ZonElement) ?*SimpleTreeModel {
	const self = main.worldArena.create(SimpleTreeModel);
	self.* = .{
		.typ = std.meta.stringToEnum(Type, parameters.get([]const u8, "type", "")) orelse blk: {
			if (parameters.get(?[]const u8, "type", null)) |typ| std.log.err("Unknown tree type \"{s}\"", .{typ});
			break :blk .round;
		},
		.leavesBlock = main.blocks.parseBlock(parameters.get([]const u8, "leaves", "cubyz:leaves/oak")),
		.woodBlock = main.blocks.parseBlock(parameters.get([]const u8, "log", "cubyz:oak_log")),
		.topWoodBlock = main.blocks.parseBlock(parameters.get([]const u8, "top", "cubyz:oak_top")),
		.height0 = parameters.get(i32, "height", 6),
		.deltaHeight = parameters.get(u31, "height_variation", 3),
		.leafRadius = parameters.get(f32, "leafRadius", (1 + parameters.get(f32, "height", 6))/2),
		.deltaLeafRadius = parameters.get(f32, "leafRadius_variation", parameters.get(f32, "height_variation", 3)/2),
		.leafElongation = parameters.get(f32, "leafElongation", 1),
		.deltaLeafElongation = parameters.get(f32, "deltaLeafElongation", 0),
		.branched = parameters.get(bool, "branched", true),
	};
	return self;
}

pub fn generateStem(self: *SimpleTreeModel, x: i32, y: i32, z: i32, height: i32, chunk: *main.chunk.ServerChunk, seed: *u64) void {
	if (chunk.super.pos.voxelSize <= 2) {
		var pz: i32 = chunk.startIndex(z);
		while (pz < z + height) : (pz += chunk.super.pos.voxelSize) {
			if (chunk.liesInChunk(x, y, pz)) {
				chunk.updateBlockIfDegradable(x, y, pz, if (pz == z + height - 1) self.topWoodBlock else self.woodBlock);

				if (self.branched) {
					const chance = @sqrt(@as(f32, @floatFromInt(pz - z))/@as(f32, @floatFromInt(height*2)));
					if (main.random.nextFloat(seed) < chance) {
						const d = main.random.nextIntBounded(u32, seed, 4);
						generateBranch(self, x, y, pz, d, chunk, seed);
					}
				}
			}
		}
	}
}

pub fn generateBranch(self: *SimpleTreeModel, x: i32, y: i32, z: i32, d: u32, chunk: *main.chunk.ServerChunk, seed: *u64) void {
	_ = seed;

	if (d == 0 and chunk.liesInChunk(x + 1, y, z)) {
		chunk.updateBlockIfDegradable(x + 1, y, z, .{.typ = self.topWoodBlock.typ, .data = 2});
	} else if (d == 1 and chunk.liesInChunk(x - 1, y, z)) {
		chunk.updateBlockIfDegradable(x - 1, y, z, .{.typ = self.topWoodBlock.typ, .data = 3});
	} else if (d == 2 and chunk.liesInChunk(x, y + 1, z)) {
		chunk.updateBlockIfDegradable(x, y + 1, z, .{.typ = self.topWoodBlock.typ, .data = 4});
	} else if (d == 3 and chunk.liesInChunk(x, y - 1, z)) {
		chunk.updateBlockIfDegradable(x, y - 1, z, .{.typ = self.topWoodBlock.typ, .data = 5});
	}
}

pub fn generate(self: *SimpleTreeModel, _: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, _: CaveBiomeMapView, seed: *u64, _: bool) void {
	const factor = random.nextFloat(seed);
	var height = self.height0 + @as(i32, @intFromFloat(factor*@as(f32, @floatFromInt(self.deltaHeight))));
	const leafRadius = self.leafRadius + factor*self.deltaLeafRadius;
	const leafElongation: f32 = self.leafElongation + random.nextFloatSigned(seed)*self.deltaLeafElongation;

	if (z + height >= caveMap.findTerrainChangeAbove(x, y, z)) // Space is too small.Allocator
		return;

	if (z > chunk.super.width) return;

	if (chunk.super.pos.voxelSize >= 16) {
		// Ensures that even at lowest resolution some leaves are rendered for smaller trees.
		if (chunk.liesInChunk(x, y, z)) {
			chunk.updateBlockIfDegradable(x, y, z, self.leavesBlock);
		}
		if (chunk.liesInChunk(x, y, z + chunk.super.pos.voxelSize)) {
			chunk.updateBlockIfDegradable(x, y, z + chunk.super.pos.voxelSize, self.leavesBlock);
		}
	}

	switch (self.typ) {
		.pyramid => {
			self.generateStem(x, y, z, height, chunk, seed);
			// Position of the first block of leaves
			height = 3*height >> 1;
			var pz = chunk.startIndex(z + @divTrunc(height, 3));
			while (pz < z + height) : (pz += chunk.super.pos.voxelSize) {
				const j = @divFloor(height - (pz - z), 2);
				var px = chunk.startIndex(x + 1 - j);
				while (px < x + j) : (px += chunk.super.pos.voxelSize) {
					var py = chunk.startIndex(y + 1 - j);
					while (py < y + j) : (py += chunk.super.pos.voxelSize) {
						if (chunk.liesInChunk(px, py, pz))
							chunk.updateBlockIfDegradable(px, py, pz, self.leavesBlock);
					}
				}
			}
		},
		.round => {
			self.generateStem(x, y, z, height, chunk, seed);

			const ceilZRadius: i32 = @intFromFloat(@ceil(leafRadius*leafElongation));
			const ceilRadius: i32 = @intFromFloat(@ceil(leafRadius));
			const radiusSqr: f32 = leafRadius*leafRadius;
			const randomRadiusSqr: f32 = (leafRadius - 0.25)*(leafRadius - 0.25);
			const invLeafElongationSqr = 1.0/(leafElongation*leafElongation);
			const center = z + height;
			var pz = chunk.startIndex(center - ceilZRadius);
			while (pz < center + ceilZRadius) : (pz += chunk.super.pos.voxelSize) {
				var px = chunk.startIndex(x - ceilRadius);
				while (px < x + ceilRadius) : (px += chunk.super.pos.voxelSize) {
					var py = chunk.startIndex(y - ceilRadius);
					while (py < y + ceilRadius) : (py += chunk.super.pos.voxelSize) {
						const distSqr = @as(f32, @floatFromInt((pz - center)*(pz - center)))*invLeafElongationSqr + @as(f32, @floatFromInt((px - x)*(px - x) + (py - y)*(py - y)));
						if (chunk.liesInChunk(px, py, pz) and distSqr < radiusSqr and (distSqr < randomRadiusSqr or random.nextInt(u1, seed) != 0)) { // TODO: Use another seed to make this more reliable!
							chunk.updateBlockIfDegradable(px, py, pz, self.leavesBlock);
						}
					}
				}
			}
		},
	}
}

```

`src/server/terrain/simple_structures/SimpleVegetation.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:simple_vegetation";

pub const generationMode = .floor;

const SimpleVegetation = @This();

block: main.blocks.Block,
height0: u31,
deltaHeight: u31,

pub fn loadModel(parameters: ZonElement) ?*SimpleVegetation {
	const self = main.worldArena.create(SimpleVegetation);
	self.* = .{
		.block = main.blocks.parseBlock(parameters.get([]const u8, "block", "")),
		.height0 = parameters.get(u31, "height", 1),
		.deltaHeight = parameters.get(u31, "height_variation", 0),
	};
	return self;
}

pub fn generate(self: *SimpleVegetation, _: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, caveMap: CaveMapView, _: CaveBiomeMapView, seed: *u64, isCeiling: bool) void {
	if (chunk.super.pos.voxelSize > 2 and (x & chunk.super.pos.voxelSize - 1 != 0 or y & chunk.super.pos.voxelSize - 1 != 0)) return;
	const height = self.height0 + random.nextIntBounded(u31, seed, self.deltaHeight + 1);
	if (z + height >= caveMap.findTerrainChangeAbove(x, y, z)) return; // Space is too small.
	var pz: i32 = chunk.startIndex(z);
	if (isCeiling) {
		while (pz >= z - height) : (pz -= chunk.super.pos.voxelSize) {
			if (chunk.liesInChunk(x, y, pz)) {
				chunk.updateBlockIfDegradable(x, y, pz, self.block);
			}
		}
	} else {
		while (pz < z + height) : (pz += chunk.super.pos.voxelSize) {
			if (chunk.liesInChunk(x, y, pz)) {
				chunk.updateBlockIfDegradable(x, y, pz, self.block);
			}
		}
	}
}

```

`src/server/terrain/simple_structures/Stalagmite.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const CaveMapView = terrain.CaveMap.CaveMapView;
const GenerationMode = terrain.biomes.SimpleStructureModel.GenerationMode;
const vec = main.vec;
const Vec2f = vec.Vec2f;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const id = "cubyz:stalagmite";

pub const generationMode = .floor_and_ceiling;

const Stalagmite = @This();

block: main.blocks.Block,
size: f32,
sizeVariation: f32,
topSlope: f32,
baseSlope: f32,

pub fn loadModel(parameters: ZonElement) ?*Stalagmite {
	const self = main.worldArena.create(Stalagmite);
	const baseSlope = parameters.get(f32, "baseSlope", 4.0);
	self.* = .{
		.block = main.blocks.parseBlock(parameters.get([]const u8, "block", "cubyz:stalagmite")),
		.size = parameters.get(f32, "size", 12),
		.sizeVariation = parameters.get(f32, "size_variation", 8),
		.baseSlope = baseSlope,
		.topSlope = parameters.get(f32, "topSlope", baseSlope),
	};
	return self;
}

pub fn generate(self: *Stalagmite, _: GenerationMode, x: i32, y: i32, z: i32, chunk: *main.chunk.ServerChunk, _: CaveMapView, _: CaveBiomeMapView, seed: *u64, _: bool) void {
	const relX: f32 = @as(f32, @floatFromInt(x)) + main.random.nextFloat(seed)*0.6 - 0.3;
	const relY: f32 = @as(f32, @floatFromInt(y)) + main.random.nextFloat(seed)*0.6 - 0.3;
	const relZ: f32 = @as(f32, @floatFromInt(z)) + main.random.nextFloat(seed)*0.6 - 0.3;

	const height = self.size + random.nextFloat(seed)*self.sizeVariation;

	// We want to ensure the following properties:
	// height(r = 0) = height
	// height'(r = 0) = -topSlope
	// height(r = baseRadius) = 0
	// height'(r = baseRadius) = -baseSlope
	// With height(r) = a·r² + b·r + c → height'(r) = 2a·r + b
	// c = height, b = -topSlope
	// 0 = a·baseRadius² + b·baseRadius + c
	// -baseSlope = 2a·baseRadius + b
	// → a·baseRadius = (-baseSlope - b)/2
	// This permits both positive and negative values for baseRadius, so we need to account for that during substitution:
	// = (-baseSlope - b)/2·±baseRadius + b·baseRadius + c
	// → baseRadius = -c/(±(-baseSlope - b)/2 + b)
	const c = height;
	const b = -self.topSlope;
	var baseRadius: f32 = undefined;
	var a: f32 = undefined;
	if (self.baseSlope == self.topSlope) {
		baseRadius = height/self.topSlope;
		a = 0;
	} else {
		baseRadius = -c/((-self.baseSlope - b)/2 + b);
		if (baseRadius < 0) {
			baseRadius = -c/(-(-self.baseSlope - b)/2 + b);
		}
		a = (-self.baseSlope - b)/(2*baseRadius);
	}

	const xMin: i32 = @intFromFloat(@floor(relX - baseRadius));
	const xMax: i32 = @intFromFloat(@ceil(relX + baseRadius));
	const yMin: i32 = @intFromFloat(@floor(relY - baseRadius));
	const yMax: i32 = @intFromFloat(@ceil(relY + baseRadius));
	var x3: i32 = xMin;
	while (x3 <= xMax) : (x3 += 1) {
		var y3: i32 = yMin;
		while (y3 <= yMax) : (y3 += 1) {
			const distSquare = vec.lengthSquare(Vec2f{@as(f32, @floatFromInt(x3)) - relX, @as(f32, @floatFromInt(y3)) - relY});
			if (distSquare >= baseRadius*baseRadius) continue;
			const r = @sqrt(distSquare);
			const columnHeight = a*r*r + b*r + c;
			if (x3 >= 0 and x3 < chunk.super.width and y3 >= 0 and y3 < chunk.super.width) {
				const zMin: i32 = @intFromFloat(@round(relZ - columnHeight));
				const zMax: i32 = @intFromFloat(@round(relZ + columnHeight));
				var z3: i32 = zMin;
				while (z3 <= zMax) : (z3 += 1) {
					if (z3 >= 0 and z3 < chunk.super.width) {
						const block: main.blocks.Block = chunk.getBlock(x3, y3, z3);
						if (block.typ == 0 or block.degradable()) {
							chunk.updateBlockInGeneration(x3, y3, z3, self.block);
						}
					}
				}
			}
		}
	}
}

```

`src/server/terrain/simple_structures/_list.zig`:

```zig
pub const Boulder = @import("Boulder.zig");
pub const FallenTree = @import("FallenTree.zig");
pub const FlowerPatch = @import("FlowerPatch.zig");
pub const GroundPatch = @import("GroundPatch.zig");
pub const SbbGen = @import("SbbGen.zig");
pub const SimpleTreeModel = @import("SimpleTreeModel.zig");
pub const SimpleVegetation = @import("SimpleVegetation.zig");
pub const Stalagmite = @import("Stalagmite.zig");

```

`src/server/terrain/structure_building_blocks.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Vec3i = main.vec.Vec3i;
const ZonElement = main.ZonElement;
const Blueprint = main.blueprint.Blueprint;
const List = main.List;
const ListUnmanaged = main.ListUnmanaged;
const AliasTable = main.utils.AliasTable;
const Neighbor = main.chunk.Neighbor;
const Block = main.blocks.Block;
const Degrees = main.rotation.Degrees;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const Assets = main.assets.Assets;

var structureList: ListUnmanaged(StructureBuildingBlock) = .{};
var structureMap: std.StringHashMapUnmanaged(StructureIndex) = .{};

var blueprintList: ListUnmanaged([4]BlueprintEntry) = .{};
var blueprintMap: std.StringHashMapUnmanaged(BlueprintIndex) = .{};

var childrenToResolve: List(struct { structureId: []const u8, structure: *?*StructureBuildingBlock }) = undefined;

const originBlockStringId = "cubyz:sbb/origin";
var originBlockNumericId: u16 = 0;

var childBlockNumericIdMap: std.AutoHashMapUnmanaged(GlobalBlockIndex, LocalBlockIndex) = .{};
var childBlockName: ListUnmanaged([]const u8) = .{};
var childBlockNameToLocalIndex: std.StringHashMapUnmanaged(LocalBlockIndex) = .{};

pub const BlueprintIndex = enum(u32) {
	_,

	pub fn fromId(_id: []const u8) ?BlueprintIndex {
		return blueprintMap.get(_id);
	}
	pub fn get(self: BlueprintIndex) [4]BlueprintEntry {
		return blueprintList.items[@intFromEnum(self)];
	}
};

pub const StructureIndex = enum(u32) {
	_,

	pub fn fromId(_id: []const u8) ?StructureIndex {
		return structureMap.get(_id);
	}
	pub fn get(self: StructureIndex) *StructureBuildingBlock {
		return &structureList.items[@intFromEnum(self)];
	}
};

pub const LocalBlockIndex = enum(u16) {
	origin = std.math.maxInt(u16),
	_,

	pub fn name(self: LocalBlockIndex) []const u8 {
		return childBlockName.items[@intFromEnum(self)];
	}
	pub fn fromName(_name: []const u8) ?LocalBlockIndex {
		return childBlockNameToLocalIndex.get(_name) orelse return null;
	}
};
pub const GlobalBlockIndex = u16;

const Blueprints = struct {
	items: ?[4]BlueprintEntry,
	chance: f32,
};

const BlueprintEntry = struct {
	blueprint: Blueprint,
	originBlock: StructureBlock,
	childBlocks: []StructureBlock,

	const StructureBlock = struct {
		x: u16,
		y: u16,
		z: u16,
		index: LocalBlockIndex,
		data: u16,

		pub inline fn direction(self: StructureBlock) Neighbor {
			return @enumFromInt(self.data);
		}

		pub inline fn pos(self: StructureBlock) Vec3i {
			return Vec3i{self.x, self.y, self.z};
		}

		pub fn id(self: StructureBlock) []const u8 {
			return self.index.name();
		}
	};

	fn init(blueprint: Blueprint, stringId: []const u8) !BlueprintEntry {
		var self: BlueprintEntry = .{
			.blueprint = blueprint,
			.originBlock = undefined,
			.childBlocks = undefined,
		};

		var hasOrigin = false;
		var childBlocks: ListUnmanaged(StructureBlock) = .{};
		defer childBlocks.deinit(main.stackAllocator);

		for (0..blueprint.blocks.width) |x| {
			for (0..blueprint.blocks.depth) |y| {
				for (0..blueprint.blocks.height) |z| {
					const block = blueprint.blocks.get(x, y, z);
					if (isOriginBlock(block)) {
						if (hasOrigin) {
							std.log.err("[{s}] Multiple origin blocks found.", .{stringId});
							return error.MultipleOriginBlocks;
						} else {
							self.originBlock = StructureBlock{
								.x = @intCast(x),
								.y = @intCast(y),
								.z = @intCast(z),
								.index = LocalBlockIndex.origin,
								.data = block.data,
							};
							hasOrigin = true;
							self.blueprint.blocks.set(x, y, z, main.blueprint.getVoidBlock());
						}
					} else if (isChildBlock(block)) {
						const childBlockLocalId = childBlockNumericIdMap.get(block.typ) orelse return error.ChildBlockNotRecognized;
						childBlocks.append(main.stackAllocator, .{
							.x = @intCast(x),
							.y = @intCast(y),
							.z = @intCast(z),
							.index = childBlockLocalId,
							.data = block.data,
						});
						self.blueprint.blocks.set(x, y, z, main.blueprint.getVoidBlock());
					}
				}
			}
		}
		if (!hasOrigin) {
			std.log.err("[{s}] No origin block found.", .{stringId});
			return error.NoOriginBlock;
		}
		self.childBlocks = main.worldArena.dupe(StructureBlock, childBlocks.items);

		return self;
	}
};

pub fn isChildBlock(block: Block) bool {
	return childBlockNumericIdMap.contains(block.typ);
}

pub fn isOriginBlock(block: Block) bool {
	return block.typ == originBlockNumericId;
}

pub const RotationMode = enum {
	fixed,
	random,
	inherit,
};

pub const Rotation = union(RotationMode) {
	fixed: FixedRotation,
	random: void,
	inherit: void,

	pub const FixedRotation = enum(u2) {
		@"0" = 0,
		@"90" = 1,
		@"180" = 2,
		@"270" = 3,
	};

	pub fn apply(self: Rotation, rotation: FixedRotation) FixedRotation {
		return switch (self) {
			.fixed => |fixed| @enumFromInt(@intFromEnum(rotation) +% @intFromEnum(fixed)),
			.random, .inherit => rotation,
		};
	}
	pub fn getInitialRotation(self: Rotation, seed: *u64) Rotation {
		return switch (self) {
			.fixed => self,
			.random => sampleRandom(seed),
			.inherit => .{.fixed = .@"0"},
		};
	}
	fn sampleRandom(seed: *u64) Rotation {
		return .{.fixed = @enumFromInt(main.random.nextInt(u2, seed))};
	}
	pub fn getChildRotation(self: Rotation, seed: *u64, child: Rotation, direction: Neighbor) Rotation {
		return switch (direction) {
			.dirDown, .dirUp => switch (child) {
				.random => sampleRandom(seed),
				.inherit => self,
				else => |r| r,
			},
			else => .{.fixed = .@"0"},
		};
	}
	pub fn fromZon(zon: ZonElement) error{ UnknownString, UnknownType }!Rotation {
		return switch (zon) {
			.string, .stringOwned => |str| {
				if (std.meta.stringToEnum(FixedRotation, str)) |r| {
					return .{.fixed = r};
				}
				if (std.meta.stringToEnum(RotationMode, str)) |mode| {
					return switch (mode) {
						.fixed => .{.fixed = .@"0"},
						.random => .{.random = {}},
						.inherit => .{.inherit = {}},
					};
				}
				return error.UnknownString;
			},
			.int => |value| .{.fixed = @enumFromInt(@abs(@divTrunc(value, 90))%4)},
			.float => |value| .{.fixed = @enumFromInt(@abs(@as(u64, @intFromFloat(value/90.0)))%4)},
			.null => Rotation.random,
			else => return error.UnknownType,
		};
	}
};

pub const StructureBuildingBlock = struct {
	id: []const u8,
	children: []?*StructureBuildingBlock,
	blueprints: AliasTable(Blueprints),
	rotation: Rotation,

	fn initFromZon(stringId: []const u8, zon: ZonElement) !StructureBuildingBlock {
		const zonBlueprintsList = zon.getChild("blueprints");
		if (zonBlueprintsList == .null) {
			std.log.err("['{s}'] Missing 'blueprints' field.", .{stringId});
			return error.MissingBlueprintsField;
		}
		if (zonBlueprintsList != .array) {
			std.log.err("['{s}'] 'blueprints' field must contain a list.", .{stringId});
			return error.InvalidType;
		}
		if (zonBlueprintsList.array.items.len == 0) {
			std.log.err("['{s}'] Empty 'blueprints' list not allowed.", .{stringId});
			return error.EmptyBlueprintsList;
		}
		const blueprintArray = main.worldArena.alloc(Blueprints, zonBlueprintsList.array.items.len);
		for (zonBlueprintsList.array.items, 0..) |zonBlueprintConfig, index| {
			if (zonBlueprintConfig != .object) {
				std.log.err("['{s}'->'{}'] Invalid blueprint configuration (object expected, got {s}).", .{stringId, index, @tagName(zonBlueprintConfig)});
				return error.InvalidBlueprintConfig;
			}
			const chance = zonBlueprintConfig.get(f32, "chance", 1.0);

			if (!zonBlueprintConfig.object.contains("id")) {
				std.log.err("['{s}'] Blueprint configuration ({}): Missing 'id' field. Use null for empty entry.", .{stringId, index});
				blueprintArray[index] = Blueprints{.items = null, .chance = chance};
				continue;
			}
			switch (zonBlueprintConfig.getChild("id")) {
				.string, .stringOwned => |_id| {
					const blueprints = BlueprintIndex.fromId(_id) orelse {
						std.log.err("['{s}'] Could not find blueprint '{s}'.", .{stringId, _id});
						return error.MissingBlueprint;
					};
					blueprintArray[index] = Blueprints{.items = blueprints.get(), .chance = chance};
				},
				.null => blueprintArray[index] = Blueprints{.items = null, .chance = chance},
				else => |e| std.log.err("['{s}'] Blueprint entry must be an object, found {s}.", .{stringId, @tagName(e)}),
			}
		}

		const rotationParam = zon.getChild("rotation");
		const rotation = Rotation.fromZon(rotationParam) catch |err| blk: {
			switch (err) {
				error.UnknownString => std.log.err("['{s}'] specified unknown rotation '{s}'", .{stringId, rotationParam.as([]const u8, "")}),
				error.UnknownType => std.log.err("['{s}'] unsupported type of rotation field '{s}'", .{stringId, @tagName(rotationParam)}),
			}
			break :blk .inherit;
		};

		const self = StructureBuildingBlock{
			.id = stringId,
			.children = main.worldArena.alloc(?*StructureBuildingBlock, childBlockName.items.len),
			.blueprints = .init(main.worldArena, blueprintArray),
			.rotation = rotation,
		};
		@memset(self.children, null);

		const zonChildrenDict = zon.getChild("children");
		switch (zonChildrenDict) {
			.null => {},
			.object => {
				var childrenDictIterator = zonChildrenDict.object.iterator();
				while (childrenDictIterator.next()) |entry| {
					if (LocalBlockIndex.fromName(entry.key_ptr.*)) |localIndex| {
						switch (entry.value_ptr.*) {
							.string, .stringOwned => |_id| childrenToResolve.append(.{.structureId = _id, .structure = &self.children[@intFromEnum(localIndex)]}),
							.null => std.log.err("['{s}'] Child '{s}' ID can not be null. Leave child key undefined if it is not used by blueprints.", .{stringId, localIndex.name()}),
							else => |e| std.log.err("['{s}'->'{s}'] Value has to be a string ID of one of the structures, found {s}.", .{stringId, localIndex.name(), @tagName(e)}),
						}
					} else {
						std.log.err("['{s}'] Unexpected configuration key '{s}'", .{stringId, entry.key_ptr.*});
						continue;
					}
				}
			},
			else => |e| std.log.err("['{s}'] Children configuration must be an object, found {s}.", .{stringId, @tagName(e)}),
		}
		return self;
	}
	pub fn postResolutionChecks(self: StructureBuildingBlock) void {
		// Collect all unique child blocks used in blueprints of this SBB.
		var childBlocksInBlueprints: ListUnmanaged(LocalBlockIndex) = .{};
		defer childBlocksInBlueprints.deinit(main.stackAllocator);

		for (self.blueprints.items, 0..) |blueprints, blueprintIndex| {
			if (blueprints.items == null) continue;

			for (blueprints.items.?[0].childBlocks) |child| {
				if (std.mem.containsAtLeastScalar(LocalBlockIndex, childBlocksInBlueprints.items, 1, child.index)) continue;
				childBlocksInBlueprints.append(main.stackAllocator, child.index);
				// Check that all child blocks present in any of the blueprints have corresponding configurations.
				if (self.children[@intFromEnum(child.index)] != null) continue;
				std.log.err("['{s}'] Blueprint ({}) requires child block {s} but no configuration was specified for it.", .{self.id, blueprintIndex, child.id()});
			}
		}
		// Check that all configured child blocks are used somewhere in one of the blueprints.
		for (self.children, 0..) |child, childBlockIndex| {
			if (child == null) continue;
			if (std.mem.containsAtLeastScalar(LocalBlockIndex, childBlocksInBlueprints.items, 1, @enumFromInt(childBlockIndex))) continue;
			std.log.err("['{s}'] None of the blueprints contains a child '{s}' but configuration for it was specified.", .{self.id, @as(LocalBlockIndex, @enumFromInt(childBlockIndex)).name()});
		}
	}
	pub fn getBlueprints(self: StructureBuildingBlock, seed: *u64) *?[4]BlueprintEntry {
		return &self.blueprints.sample(seed).items;
	}
	pub fn getChildStructure(self: StructureBuildingBlock, block: BlueprintEntry.StructureBlock) ?*const StructureBuildingBlock {
		return self.children[@intFromEnum(block.index)];
	}
};

pub fn registerSBB(structures: *Assets.ZonHashMap) !void {
	std.debug.assert(structureList.items.len == 0);
	std.debug.assert(structureMap.capacity() == 0);

	structureList.ensureCapacity(main.worldArena, structures.count());
	structureMap.ensureTotalCapacity(main.worldArena.allocator, structures.count()) catch unreachable;

	childrenToResolve = .init(main.stackAllocator);
	defer childrenToResolve.deinit();
	{
		var iterator = structures.iterator();
		var loadedCount: u32 = 0;
		while (iterator.next()) |entry| {
			structureList.appendAssumeCapacity(StructureBuildingBlock.initFromZon(entry.key_ptr.*, entry.value_ptr.*) catch |err| {
				std.log.err("Could not register structure building block '{s}' ({s})", .{entry.key_ptr.*, @errorName(err)});
				continue;
			});

			const key = main.worldArena.dupe(u8, entry.key_ptr.*);
			structureMap.put(main.worldArena.allocator, key, @enumFromInt(loadedCount)) catch unreachable;

			std.log.debug("Registered structure building block: '{s}'", .{entry.key_ptr.*});
			loadedCount += 1;
		}
	}
	{
		for (childrenToResolve.items) |entry| {
			const childStructure = StructureIndex.fromId(entry.structureId) orelse {
				std.log.err("Could not find child structure '{s}' for child resolution.", .{entry.structureId});
				continue;
			};
			entry.structure.* = childStructure.get();
		}
	}
	for (structureList.items) |sbb| sbb.postResolutionChecks();
}

pub fn registerChildBlock(numericId: u16, stringId: []const u8) void {
	std.debug.assert(numericId != 0);

	const index: u16 = @intCast(childBlockNumericIdMap.count());
	childBlockNumericIdMap.put(main.worldArena.allocator, numericId, @enumFromInt(index)) catch unreachable;
	// Take only color name from the ID.
	var iterator = std.mem.splitBackwardsScalar(u8, stringId, '/');
	const colorName = iterator.first();
	const colorNameDupe = main.worldArena.dupe(u8, colorName);
	childBlockName.append(main.worldArena, colorNameDupe);

	childBlockNameToLocalIndex.put(main.worldArena.allocator, colorNameDupe, @enumFromInt(index)) catch unreachable;
}

pub fn registerBlueprints(blueprints: *Assets.BytesHashMap) !void {
	std.debug.assert(blueprintList.items.len == 0);
	std.debug.assert(blueprintMap.capacity() == 0);

	blueprintList.resize(main.worldArena, blueprints.count());
	blueprintMap.ensureTotalCapacity(main.worldArena.allocator, blueprints.count()) catch unreachable;

	originBlockNumericId = main.blocks.parseBlock(originBlockStringId).typ;
	std.debug.assert(originBlockNumericId != 0);

	var iterator = blueprints.iterator();
	var index: u32 = 0;
	while (iterator.next()) |entry| {
		defer index += 1;

		const stringId = entry.key_ptr.*;

		// Rotated copies need to be made before initializing BlueprintEntry as to removes origin and child blocks.
		const blueprint0 = Blueprint.load(main.worldArena, entry.value_ptr.*) catch |err| {
			std.log.err("Could not load blueprint '{s}' ({s})", .{stringId, @errorName(err)});
			continue;
		};
		const blueprint90 = blueprint0.rotateZ(main.worldArena, .@"90");
		const blueprint180 = blueprint0.rotateZ(main.worldArena, .@"180");
		const blueprint270 = blueprint0.rotateZ(main.worldArena, .@"270");

		blueprintList.items[index][0] = BlueprintEntry.init(blueprint0, stringId) catch continue;
		blueprintList.items[index][1] = BlueprintEntry.init(blueprint90, stringId) catch continue;
		blueprintList.items[index][2] = BlueprintEntry.init(blueprint180, stringId) catch continue;
		blueprintList.items[index][3] = BlueprintEntry.init(blueprint270, stringId) catch continue;

		blueprintMap.put(main.worldArena.allocator, main.worldArena.dupe(u8, stringId), @enumFromInt(index)) catch unreachable;
		std.log.debug("Registered blueprint: '{s}'", .{stringId});
	}
}

pub fn getByStringId(stringId: []const u8) ?*StructureBuildingBlock {
	if (structureMap.get(stringId)) |index| return index.get();
	return null;
}

pub fn list() []const StructureBuildingBlock {
	return structureList.items;
}

pub fn reset() void {
	childBlockNumericIdMap = .{};
	childBlockName = .{};
	childBlockNameToLocalIndex = .{};

	structureList = .{};
	structureMap = .{};

	blueprintList = .{};
	blueprintMap = .{};
}

```

`src/server/terrain/structuremapgen/SbbEnumerationGenerator.zig`:

```zig
const std = @import("std");

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const biomes = terrain.biomes;
const noise = terrain.noise;
const StructureMapFragment = terrain.StructureMap.StructureMapFragment;
const SurfaceMap = terrain.SurfaceMap;
const MapFragment = SurfaceMap.MapFragment;
const CaveMapView = terrain.CaveMap.CaveMapView;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const SbbGen = @import("../simple_structures/SbbGen.zig");
const ServerChunk = main.chunk.ServerChunk;
const SimpleStructure = @import("SimpleStructureGen.zig").SimpleStructure;
const StructureBuildingBlock = terrain.structure_building_blocks.StructureBuildingBlock;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:sbb_enumeration_generator";

pub const priority = 131072;

pub const generatorSeed = 0x7568492764892;

pub const defaultState = .disabled;

var sbbList: []main.server.terrain.biomes.SimpleStructureModel = undefined;
var signBlock: main.blocks.Block = undefined;

pub fn init(parameters: ZonElement) void {
	_ = parameters;

	const Entry = struct { sbb: *const StructureBuildingBlock, hasParent: bool, reachable: bool };
	var localSbbList: main.ListUnmanaged(Entry) = .{};
	defer localSbbList.deinit(main.stackAllocator);
	for (terrain.structure_building_blocks.list()) |*entry| {
		localSbbList.append(main.stackAllocator, .{.sbb = entry, .hasParent = false, .reachable = false});
	}

	{ // Mark all SBBs that are children of other SBBs.
		outer: for (localSbbList.items) |*candidate| {
			for (localSbbList.items) |other| {
				if (other.sbb == candidate.sbb) continue;
				for (other.sbb.children) |child| {
					if (child == candidate.sbb) {
						candidate.hasParent = true;
						continue :outer;
					}
				}
			}
		}
	}
	var rootSbbList: main.ListUnmanaged(*const StructureBuildingBlock) = .initCapacity(main.stackAllocator, localSbbList.items.len);
	defer rootSbbList.deinit(main.stackAllocator);
	{ // Ensure that every structure was reachable (in case of recursion)
		var unreachables: main.ListUnmanaged(*Entry) = .initCapacity(main.stackAllocator, localSbbList.items.len);
		defer unreachables.deinit(main.stackAllocator);

		for (localSbbList.items) |*candidate| {
			if (candidate.hasParent) {
				unreachables.appendAssumeCapacity(candidate);
			} else {
				candidate.reachable = true;
				rootSbbList.appendAssumeCapacity(candidate.sbb);
			}
		}

		while (unreachables.items.len != 0) {
			var lastLen: usize = 0;
			while (lastLen != unreachables.items.len) {
				lastLen = unreachables.items.len;
				var i: usize = 0;
				outer: while (i < unreachables.items.len) {
					const candidate = unreachables.items[i];
					for (localSbbList.items) |other| {
						if (!other.reachable) continue;
						for (other.sbb.children) |child| {
							if (child == candidate.sbb) {
								candidate.reachable = true;
								_ = unreachables.swapRemove(i);
								continue :outer;
							}
						}
					}
					i += 1;
				}
			}
			const recursiveOne = unreachables.popOrNull() orelse break;
			recursiveOne.reachable = true;
			rootSbbList.appendAssumeCapacity(recursiveOne.sbb);
		}
	}

	std.sort.insertion(*const StructureBuildingBlock, rootSbbList.items, {}, struct {
		fn lessThanFn(_: void, lhs: *const StructureBuildingBlock, rhs: *const StructureBuildingBlock) bool {
			return std.ascii.orderIgnoreCase(lhs.id, rhs.id) == .lt;
		}
	}.lessThanFn);

	sbbList = main.worldArena.alloc(main.server.terrain.biomes.SimpleStructureModel, rootSbbList.items.len);

	for (rootSbbList.items, 0..) |sbb, i| {
		const structureData = main.worldArena.create(SbbGen);
		structureData.* = .{
			.structureRef = sbb,
			.placeMode = .all,
			.rotation = .{.fixed = .@"0"},
		};
		sbbList[i] = .{
			.chance = undefined,
			.generationMode = .floor,
			.priority = 1.0,
			.vtable = .{
				.generate = main.meta.castFunctionSelfToAnyopaque(SbbGen.generate),
				.generationMode = .floor,
				.hashFunction = undefined,
				.loadModel = undefined,
			},
			.data = structureData,
		};
	}

	signBlock.typ = main.blocks.getBlockById("cubyz:sign/oak") catch |err| blk: {
		std.log.err("Could not find sign with id cubyz:sign/oak: {s}", .{@errorName(err)});
		break :blk 0;
	};
	signBlock.data = 6;
}

pub fn generate(map: *StructureMapFragment, worldSeed: u64) void {
	const size = StructureMapFragment.size*map.pos.voxelSize;
	const margin = 16;
	const marginZ = 32;
	var px: i32 = 0;
	while (px < size + 2*margin) : (px += 32) {
		var py: i32 = 0;
		while (py < size + 2*margin) : (py += 32) {
			const wpx = px +% map.pos.wx;
			const wpy = py +% map.pos.wy;
			const index: u32 = @intCast(@mod(@divFloor(wpx, 32), @as(i32, @intCast(sbbList.len))));
			const sbb = &sbbList[index];

			inline for (.{0, 128}) |startZ| blk: {
				const relZ = startZ -% map.pos.wz;
				if (relZ < -32 or relZ >= size + 32) break :blk;

				const signRow = wpy & 1023 == 0;
				if (signRow) {
					const structure = map.allocator.create(SignGenerator);
					structure.* = .{
						.wx = wpx,
						.wy = wpy,
						.wz = map.pos.wz +% relZ,
						.id = @as(*SbbGen, @ptrCast(@alignCast(sbb.data))).structureRef.id,
					};
					map.addStructure(.{
						.internal = .{
							.data = structure,
							.generateFn = main.meta.castFunctionSelfToConstAnyopaque(SignGenerator.generate),
						},
						.priority = sbb.priority,
					}, .{px, py, structure.wz -% map.pos.wz}, .{px +% 1, py +% 1, structure.wz -% map.pos.wz +% 1});
				} else {
					const structure = map.allocator.create(SimpleStructure);
					structure.* = .{
						.wx = wpx,
						.wy = wpy,
						.wz = map.pos.wz +% relZ,
						.seed = worldSeed*%@as(u32, @bitCast(wpy)),
						.model = sbb,
						.isCeiling = false,
					};
					map.addStructure(.{
						.internal = .{
							.data = structure,
							.generateFn = main.meta.castFunctionSelfToConstAnyopaque(SimpleStructure.generate),
						},
						.priority = sbb.priority,
					}, .{px -% margin, py -% margin, structure.wz -% map.pos.wz -% marginZ}, .{px +% margin, py +% margin, structure.wz -% map.pos.wz +% marginZ});
				}
			}
		}
	}
}

const SignGenerator = struct {
	wx: i32,
	wy: i32,
	wz: i32,
	id: []const u8,

	pub fn generate(self: *const SignGenerator, chunk: *ServerChunk, _: terrain.CaveMap.CaveMapView, _: terrain.CaveBiomeMap.CaveBiomeMapView) void {
		if (chunk.super.pos.voxelSize != 1) return;
		const relX = self.wx - chunk.super.pos.wx;
		const relY = self.wy - chunk.super.pos.wy;
		const relZ = self.wz - chunk.super.pos.wz;
		if (signBlock.blockEntity()) |blockEntity| {
			chunk.updateBlockIfDegradable(relX, relY, relZ, signBlock);
			var reader: main.utils.BinaryReader = .init(self.id);
			blockEntity.onLoadServer(.{self.wx, self.wy, self.wz}, &chunk.super, &reader) catch |err| {
				std.log.err("Error while loading id to sign: {s}", .{@errorName(err)});
			};
		}
	}
};

```

`src/server/terrain/structuremapgen/SimpleStructureGen.zig`:

```zig
const std = @import("std");
const sign = std.math.sign;

const main = @import("main");
const random = main.random;
const ZonElement = main.ZonElement;
const terrain = main.server.terrain;
const biomes = terrain.biomes;
const noise = terrain.noise;
const StructureMapFragment = terrain.StructureMap.StructureMapFragment;
const SurfaceMap = terrain.SurfaceMap;
const MapFragment = SurfaceMap.MapFragment;
const CaveMapView = terrain.CaveMap.CaveMapView;
const CaveBiomeMapView = terrain.CaveBiomeMap.CaveBiomeMapView;
const ServerChunk = main.chunk.ServerChunk;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;

pub const id = "cubyz:simple_structures";

pub const priority = 131072;

pub const generatorSeed = 0x7568492764892;

pub const defaultState = .enabled;

pub fn init(parameters: ZonElement) void {
	_ = parameters;
}

fn adjustToCaveMap(biomeMap: CaveBiomeMapView, caveMap: CaveMapView, wx: i32, wy: i32, wz: i32, model: *const biomes.SimpleStructureModel, seed: *u64) ?struct { relZ: i32, isCeiling: bool } {
	const relX = wx - caveMap.pos.wx;
	const relY = wy - caveMap.pos.wy;
	var relZ = wz - caveMap.pos.wz;
	var isCeiling = false;
	switch (model.generationMode) {
		.floor => {
			if (caveMap.isSolid(relX, relY, relZ)) {
				relZ = caveMap.findTerrainChangeAbove(relX, relY, relZ);
			} else {
				relZ = caveMap.findTerrainChangeBelow(relX, relY, relZ) + caveMap.pos.voxelSize;
			}
			if (relZ & ~@as(i32, 31) != wz -% caveMap.pos.wz & ~@as(i32, 31)) return null; // Too far from the surface.
		},
		.ceiling => {
			isCeiling = true;
			if (caveMap.isSolid(relX, relY, relZ)) {
				relZ = caveMap.findTerrainChangeBelow(relX, relY, relZ) - caveMap.pos.voxelSize;
			} else {
				relZ = caveMap.findTerrainChangeAbove(relX, relY, relZ);
			}
			if (relZ & ~@as(i32, 31) != wz -% caveMap.pos.wz & ~@as(i32, 31)) return null; // Too far from the surface.
		},
		.floor_and_ceiling => {
			if (random.nextInt(u1, seed) != 0) {
				if (caveMap.isSolid(relX, relY, relZ)) {
					relZ = caveMap.findTerrainChangeAbove(relX, relY, relZ);
				} else {
					relZ = caveMap.findTerrainChangeBelow(relX, relY, relZ) + caveMap.pos.voxelSize;
				}
			} else {
				isCeiling = true;
				if (caveMap.isSolid(relX, relY, relZ)) {
					relZ = caveMap.findTerrainChangeBelow(relX, relY, relZ) - caveMap.pos.voxelSize;
				} else {
					relZ = caveMap.findTerrainChangeAbove(relX, relY, relZ);
				}
			}
			if (relZ & ~@as(i32, 31) != wz -% caveMap.pos.wz & ~@as(i32, 31)) return null; // Too far from the surface.
		},
		.air => {
			relZ += -16 + random.nextIntBounded(i32, seed, 32);
			if (caveMap.isSolid(relX, relY, relZ)) return null;
		},
		.underground => {
			relZ += -16 + random.nextIntBounded(i32, seed, 32);
			if (!caveMap.isSolid(relX, relY, relZ)) return null;
		},
		.water_surface => {
			if (biomeMap.getSurfaceHeight(wx, wy) >= 0) return null;
		},
	}
	return .{
		.relZ = relZ,
		.isCeiling = isCeiling,
	};
}

pub fn generate(map: *StructureMapFragment, worldSeed: u64) void {
	const size = StructureMapFragment.size*map.pos.voxelSize;
	const biomeMap = CaveBiomeMapView.init(main.stackAllocator, map.pos, size, 32);
	defer biomeMap.deinit();
	const caveMap = CaveMapView.init(main.stackAllocator, map.pos, size, 32);
	defer caveMap.deinit(main.stackAllocator);
	const margin = 16;
	const marginZ = 32;
	if (map.pos.voxelSize <= 4) {
		const blueNoise = noise.BlueNoise.getRegionData(main.stackAllocator, map.pos.wx -% margin, map.pos.wy -% margin, size + 2*margin, size + 2*margin);
		defer main.stackAllocator.free(blueNoise);
		var z: i32 = -32;
		while (z < size + 32) : (z += 32) {
			for (blueNoise) |coordinatePair| {
				const px = @as(i32, @intCast(coordinatePair >> 16)) - margin; // TODO: Maybe add a blue-noise iterator or something like that?
				const py = @as(i32, @intCast(coordinatePair & 0xffff)) - margin;
				const wpx = map.pos.wx +% px;
				const wpy = map.pos.wy +% py;
				const wpz = map.pos.wz +% z;
				var seed = random.initSeed3D(worldSeed, .{wpx, wpy, wpz});
				const relZ = z + 16;
				const biome = biomeMap.getBiome(px, py, relZ);
				var randomValue = random.nextFloat(&seed);
				for (biome.vegetationModels) |*model| { // TODO: Could probably use an alias table here.
					if (randomValue < model.chance) {
						const heightFinalized = adjustToCaveMap(biomeMap, caveMap, wpx, wpy, map.pos.wz +% relZ, model, &seed) orelse break;
						const data = map.allocator.create(SimpleStructure);
						data.* = .{
							.wx = wpx,
							.wy = wpy,
							.wz = map.pos.wz +% heightFinalized.relZ,
							.seed = seed,
							.model = model,
							.isCeiling = heightFinalized.isCeiling,
						};
						if (model.generationMode == .water_surface) {
							if (wpz != 0) break;
							data.wz = 0;
						}
						map.addStructure(.{
							.internal = .{
								.data = @ptrCast(data),
								.generateFn = main.meta.castFunctionSelfToConstAnyopaque(SimpleStructure.generate),
							},
							.priority = model.priority,
						}, .{px -% margin, py -% margin, data.wz -% map.pos.wz -% marginZ}, .{px +% margin, py +% margin, data.wz -% map.pos.wz +% marginZ});
						break;
					} else {
						randomValue -= model.chance;
					}
				}
			}
		}
	} else { // TODO: Make this case work with cave-structures. Low priority because caves aren't even generated this far out.
		var px: i32 = 0;
		while (px < size + 2*margin) : (px += map.pos.voxelSize) {
			var py: i32 = 0;
			while (py < size + 2*margin) : (py += map.pos.voxelSize) {
				const wpx = px -% margin +% map.pos.wx;
				const wpy = py -% margin +% map.pos.wy;

				const relZ = biomeMap.getSurfaceHeight(wpx, wpy) -% map.pos.wz;
				if (relZ < -32 or relZ >= size + 32) continue;

				var seed = random.initSeed3D(worldSeed, .{wpx, wpy, relZ});
				var randomValue = random.nextFloat(&seed);
				const biome = biomeMap.getBiome(px, py, relZ);
				for (biome.vegetationModels) |*model| { // TODO: Could probably use an alias table here.
					var adaptedChance = model.chance/16;
					// Increase chance if there are less spawn points considered. Messes up positions, but at that distance density matters more.
					adaptedChance = 1 - std.math.pow(f32, 1 - adaptedChance, @as(f32, @floatFromInt(map.pos.voxelSize*map.pos.voxelSize)));
					if (randomValue < adaptedChance) {
						const heightFinalized = adjustToCaveMap(biomeMap, caveMap, wpx, wpy, map.pos.wz +% relZ, model, &seed) orelse break;
						const data = map.allocator.create(SimpleStructure);
						data.* = .{
							.wx = wpx,
							.wy = wpy,
							.wz = map.pos.wz +% heightFinalized.relZ,
							.seed = seed,
							.model = model,
							.isCeiling = heightFinalized.isCeiling,
						};
						if (model.generationMode == .water_surface) data.wz = 0;
						map.addStructure(.{
							.internal = .{
								.data = data,
								.generateFn = main.meta.castFunctionSelfToConstAnyopaque(SimpleStructure.generate),
							},
							.priority = model.priority,
						}, .{px -% margin, py -% margin, data.wz -% map.pos.wz -% marginZ}, .{px +% margin, py +% margin, data.wz -% map.pos.wz +% marginZ});
						break;
					} else {
						randomValue -= adaptedChance;
					}
				}
			}
		}
	}
}

pub const SimpleStructure = struct {
	model: *const biomes.SimpleStructureModel,
	seed: u64,
	wx: i32,
	wy: i32,
	wz: i32,
	isCeiling: bool,

	pub fn generate(self: *const SimpleStructure, chunk: *ServerChunk, caveMap: terrain.CaveMap.CaveMapView, biomeMap: terrain.CaveBiomeMap.CaveBiomeMapView) void {
		var seed = self.seed;
		const relX = self.wx - chunk.super.pos.wx;
		const relY = self.wy - chunk.super.pos.wy;
		const relZ = self.wz - chunk.super.pos.wz;
		self.model.generate(relX, relY, relZ, chunk, caveMap, biomeMap, &seed, self.isCeiling);
	}
};

```

`src/server/terrain/structuremapgen/_list.zig`:

```zig
pub const SbbEnumerationGenerator = @import("SbbEnumerationGenerator.zig");
pub const SimpleStructureGen = @import("SimpleStructureGen.zig");

```

`src/server/terrain/terrain.zig`:

```zig
const std = @import("std");

const main = @import("main");
const ZonElement = main.ZonElement;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const biomes = @import("biomes.zig");
pub const noise = @import("noise/noise.zig");
const Biome = biomes.Biome;

pub const ClimateMap = @import("ClimateMap.zig");

pub const SurfaceMap = @import("SurfaceMap.zig");

pub const LightMap = @import("LightMap.zig");

pub const CaveBiomeMap = @import("CaveBiomeMap.zig");

pub const CaveMap = @import("CaveMap.zig");

pub const StructureMap = @import("StructureMap.zig");

pub const structure_building_blocks = @import("structure_building_blocks.zig");

pub const GeneratorState = enum { enabled, disabled };

/// A generator for setting the actual Blocks in each Chunk.
pub const BlockGenerator = struct {
	init: *const fn (parameters: ZonElement) void,
	generate: *const fn (seed: u64, chunk: *main.chunk.ServerChunk, caveMap: CaveMap.CaveMapView, biomeMap: CaveBiomeMap.CaveBiomeMapView) void,
	/// Used to prioritize certain generators over others.
	priority: i32,
	/// To avoid duplicate seeds in similar generation algorithms, the SurfaceGenerator xors the world-seed with the generator specific seed.
	generatorSeed: u64,
	defaultState: GeneratorState,

	var generatorRegistry: std.StringHashMapUnmanaged(BlockGenerator) = .{};

	pub fn registerGenerator(comptime GeneratorType: type) void {
		const self = BlockGenerator{
			.init = &GeneratorType.init,
			.generate = &GeneratorType.generate,
			.priority = GeneratorType.priority,
			.generatorSeed = GeneratorType.generatorSeed,
			.defaultState = GeneratorType.defaultState,
		};
		generatorRegistry.put(main.globalAllocator.allocator, GeneratorType.id, self) catch unreachable;
	}

	fn getAndInitGenerators(allocator: NeverFailingAllocator, settings: ZonElement) []BlockGenerator {
		var list: main.ListUnmanaged(BlockGenerator) = .initCapacity(allocator, generatorRegistry.size);
		var iterator = generatorRegistry.iterator();
		while (iterator.next()) |generatorEntry| {
			const generator = generatorEntry.value_ptr.*;
			const generatorSettings = settings.getChild(generatorEntry.key_ptr.*);
			if (generatorSettings.get(GeneratorState, "state", generator.defaultState) == .disabled) continue;
			generator.init(generatorSettings);
			list.appendAssumeCapacity(generator);
		}
		const lessThan = struct {
			fn lessThan(_: void, lhs: BlockGenerator, rhs: BlockGenerator) bool {
				return lhs.priority < rhs.priority;
			}
		}.lessThan;
		std.sort.insertion(BlockGenerator, list.items, {}, lessThan);
		return list.toOwnedSlice(allocator);
	}
};

/// Lists all the Generators and Biomes that should be used for a given world.
/// TODO: Generator/Biome blackslisting (from the world creation menu).
/// TODO: Generator settings (from the world creation menu).
pub const TerrainGenerationProfile = struct {
	mapFragmentGenerator: SurfaceMap.MapGenerator = undefined,
	climateGenerator: ClimateMap.ClimateMapGenerator = undefined,
	caveBiomeGenerators: []CaveBiomeMap.CaveBiomeGenerator = undefined,
	caveGenerators: []CaveMap.CaveGenerator = undefined,
	structureMapGenerators: []StructureMap.StructureMapGenerator = undefined,
	generators: []BlockGenerator = undefined,
	climateWavelengths: [5]f32 = undefined,
	seed: u64,

	pub fn init(settings: ZonElement, seed: u64) !TerrainGenerationProfile {
		var self = TerrainGenerationProfile{
			.seed = seed,
		};
		var generator = settings.getChild("mapGenerator");
		self.mapFragmentGenerator = try SurfaceMap.MapGenerator.getGeneratorById(generator.get([]const u8, "id", "cubyz:mapgen_v1"));
		self.mapFragmentGenerator.init(generator);

		generator = settings.getChild("climateGenerator");
		self.climateGenerator = try ClimateMap.ClimateMapGenerator.getGeneratorById(generator.get([]const u8, "id", "cubyz:polar_circles"));
		self.climateGenerator.init(generator);

		generator = settings.getChild("caveBiomeGenerators");
		self.caveBiomeGenerators = CaveBiomeMap.CaveBiomeGenerator.getAndInitGenerators(main.worldArena, generator);

		generator = settings.getChild("caveGenerators");
		self.caveGenerators = CaveMap.CaveGenerator.getAndInitGenerators(main.worldArena, generator);

		generator = settings.getChild("structureMapGenerators");
		self.structureMapGenerators = StructureMap.StructureMapGenerator.getAndInitGenerators(main.worldArena, generator);

		generator = settings.getChild("generators");
		self.generators = BlockGenerator.getAndInitGenerators(main.worldArena, generator);

		const climateWavelengths = settings.getChild("climateWavelengths");
		self.climateWavelengths[0] = climateWavelengths.get(f32, "hot_cold", 2400);
		self.climateWavelengths[1] = climateWavelengths.get(f32, "land_ocean", 3200);
		self.climateWavelengths[2] = climateWavelengths.get(f32, "wet_dry", 2400);
		self.climateWavelengths[3] = climateWavelengths.get(f32, "vegetation", 2400);
		self.climateWavelengths[4] = climateWavelengths.get(f32, "mountain", 500);

		return self;
	}
};

pub fn globalInit() void {
	SurfaceMap.globalInit();
	ClimateMap.globalInit();
	CaveBiomeMap.globalInit();
	CaveMap.globalInit();
	StructureMap.globalInit();
	const list = @import("chunkgen/_list.zig");
	inline for (@typeInfo(list).@"struct".decls) |decl| {
		BlockGenerator.registerGenerator(@field(list, decl.name));
	}
	const t1 = main.timestamp();
	noise.BlueNoise.load();
	std.log.info("Blue noise took {} ms to load", .{t1.durationTo(main.timestamp()).toMilliseconds()});
}

pub fn globalDeinit() void {
	CaveBiomeMap.globalDeinit();
	CaveMap.globalDeinit();
	StructureMap.globalDeinit();
	ClimateMap.globalDeinit();
	SurfaceMap.globalDeinit();
	BlockGenerator.generatorRegistry.clearAndFree(main.globalAllocator.allocator);
}

pub fn init(profile: TerrainGenerationProfile) void {
	CaveBiomeMap.init(profile);
	CaveMap.init(profile);
	StructureMap.init(profile);
	ClimateMap.init(profile);
	SurfaceMap.init(profile);
}

pub fn deinit() void {
	CaveBiomeMap.deinit();
	CaveMap.deinit();
	StructureMap.deinit();
	ClimateMap.deinit();
	SurfaceMap.deinit();
	LightMap.deinit();
}

```

`src/server/world.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Block = main.blocks.Block;
const Cache = main.utils.Cache;
const chunk = main.chunk;
const ChunkPosition = chunk.ChunkPosition;
const ServerChunk = chunk.ServerChunk;
const files = main.files;
const utils = main.utils;
const ItemDropManager = main.itemdrop.ItemDropManager;
const ItemStack = main.items.ItemStack;
const ZonElement = main.ZonElement;
const vec = main.vec;
const Vec3i = vec.Vec3i;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const terrain = server.terrain;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

const server = @import("server.zig");
const User = server.User;
const Entity = server.Entity;
const permission = server.permission;
const Palette = main.assets.Palette;

const storage = @import("storage.zig");
const Gamemode = main.game.Gamemode;

const BlockUpdateSystem = main.server.BlockUpdateSystem;
const SimulationChunk = main.server.SimulationChunk;

pub const Settings = struct {
	defaultGamemode: Gamemode = .creative,
	allowCheats: bool = true,
	testingMode: bool = false,
	seed: u64 = undefined,

	pub const defaults: Settings = .{};

	pub fn fromZon(zon: ZonElement) error{NoSeed}!Settings {
		return .{
			.seed = zon.get(?u64, "seed", null) orelse {
				std.log.err("Cannot load world. World has no seed!", .{});
				return error.NoSeed;
			},
			.defaultGamemode = std.meta.stringToEnum(main.game.Gamemode, zon.get([]const u8, "defaultGamemode", @tagName(defaults.defaultGamemode))) orelse defaults.defaultGamemode,
			.allowCheats = zon.get(bool, "allowCheats", defaults.allowCheats),
			.testingMode = zon.get(bool, "testingMode", defaults.testingMode),
		};
	}

	pub fn toZon(self: Settings, allocator: NeverFailingAllocator) ZonElement {
		const zon = main.ZonElement.initObject(allocator);

		zon.put("defaultGamemode", @tagName(self.defaultGamemode));
		zon.put("allowCheats", self.allowCheats);
		zon.put("testingMode", self.testingMode);
		zon.put("seed", self.seed);

		return zon;
	}
};

fn findValidFolderName(allocator: main.heap.NeverFailingAllocator, name: []const u8) []const u8 {
	// Remove illegal ASCII characters:
	const escapedName = main.stackAllocator.alloc(u8, name.len);
	defer main.stackAllocator.free(escapedName);
	for (name, 0..) |char, i| {
		escapedName[i] = switch (char) {
			'a'...'z', 'A'...'Z', '0'...'9', '_', '-', '.', ' ' => char,
			128...255 => char,
			else => '-',
		};
	}

	// Avoid duplicates:
	var resultName = main.stackAllocator.dupe(u8, escapedName);
	defer main.stackAllocator.free(resultName);
	var i: usize = 0;
	while (true) {
		const resultPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}", .{resultName}) catch unreachable;
		defer main.stackAllocator.free(resultPath);

		if (!main.files.cubyzDir().hasDir(resultPath)) break;

		main.stackAllocator.free(resultName);
		resultName = std.fmt.allocPrint(main.stackAllocator.allocator, "{s}_{}", .{escapedName, i}) catch unreachable;
		i += 1;
	}
	return allocator.dupe(u8, resultName);
}

pub fn tryCreateWorld(worldName: []const u8, worldSettings: Settings, preset: ZonElement) !void {
	const worldPath = findValidFolderName(main.stackAllocator, worldName);
	defer main.stackAllocator.free(worldPath);
	const saveFolder = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}", .{worldPath}) catch unreachable;
	defer main.stackAllocator.free(saveFolder);
	try main.files.cubyzDir().makePath(saveFolder);

	const worldInfo = main.ZonElement.initObject(main.stackAllocator);
	defer worldInfo.deinit(main.stackAllocator);

	worldInfo.put("generatorSettings", preset.clone(main.stackAllocator));
	worldInfo.put("settings", worldSettings.toZon(main.stackAllocator));

	{
		const worldInfoPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/world.zig.zon", .{worldPath}) catch unreachable;
		defer main.stackAllocator.free(worldInfoPath);

		worldInfo.put("name", worldName);
		worldInfo.put("version", worldDataVersion);
		worldInfo.put("lastUsedTime", (try std.Io.Clock.Timestamp.now(main.io, .real)).raw.toMilliseconds());

		try main.files.cubyzDir().writeZon(worldInfoPath, worldInfo);
	}
	{ // Make assets subfolder
		const assetsPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/assets", .{worldPath}) catch unreachable;
		defer main.stackAllocator.free(assetsPath);
		try main.files.cubyzDir().makePath(assetsPath);
	}
}

pub const ChunkManager = struct { // MARK: ChunkManager
	world: *ServerWorld,
	terrainGenerationProfile: server.terrain.TerrainGenerationProfile,

	// There will be at most 1 GiB of chunks in here. TODO: Allow configuring this in the server settings.
	const reducedChunkCacheMask = 2047;
	var chunkCache: Cache(ServerChunk, reducedChunkCacheMask + 1, 4, chunkDeinitFunctionForCache) = .{};
	const HashContext = struct {
		pub fn hash(_: HashContext, a: chunk.ChunkPosition) u64 {
			return a.hashCode();
		}
		pub fn eql(_: HashContext, a: chunk.ChunkPosition, b: chunk.ChunkPosition) bool {
			return std.meta.eql(a, b);
		}
	};
	var simulationChunkHashMap: std.HashMap(chunk.ChunkPosition, *SimulationChunk, HashContext, 50) = undefined;
	var mutex: std.Thread.Mutex = .{};

	fn getSimulationChunkAndIncreaseRefCount(pos: chunk.ChunkPosition) ?*SimulationChunk {
		std.debug.assert(pos.voxelSize == 1);
		mutex.lock();
		defer mutex.unlock();
		if (simulationChunkHashMap.get(pos)) |ch| {
			ch.increaseRefCount();
			return ch;
		}
		return null;
	}

	pub fn getOrGenerateSimulationChunkAndIncreaseRefCount(pos: chunk.ChunkPosition) *SimulationChunk {
		std.debug.assert(pos.voxelSize == 1);
		mutex.lock();
		if (simulationChunkHashMap.get(pos)) |ch| {
			ch.increaseRefCount();
			mutex.unlock();
			return ch;
		}
		const ch = SimulationChunk.initAndIncreaseRefCount(pos);
		ch.increaseRefCount();
		ch.increaseRefCount();
		simulationChunkHashMap.put(pos, ch) catch unreachable;
		mutex.unlock();
		ChunkLoadTask.scheduleAndDecreaseRefCount(pos, .{.simulationChunk = ch});
		return ch;
	}

	pub fn tryRemoveSimulationChunk(ch: *SimulationChunk) void {
		mutex.lock();
		defer mutex.unlock();
		if (ch.refCount.load(.monotonic) == 1) { // Only we hold it.
			std.debug.assert(simulationChunkHashMap.remove(ch.pos));
			ch.decreaseRefCount();
		}
	}

	const Source = union(enum) {
		user: *User,
		simulationChunk: *SimulationChunk,
	};

	const ChunkLoadTask = struct { // MARK: ChunkLoadTask
		pos: ChunkPosition,
		source: Source,

		const vtable = utils.ThreadPool.VTable{
			.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
			.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
			.run = main.meta.castFunctionSelfToAnyopaque(run),
			.clean = main.meta.castFunctionSelfToAnyopaque(clean),
			.taskType = .chunkgen,
		};

		pub fn scheduleAndDecreaseRefCount(pos: ChunkPosition, source: Source) void {
			const task = main.globalAllocator.create(ChunkLoadTask);
			task.* = ChunkLoadTask{
				.pos = pos,
				.source = source,
			};
			switch (source) {
				.user => |user| {
					user.addTask(task, &vtable);
				},
				else => {
					main.threadPool.addTask(task, &vtable);
				},
			}
		}

		pub fn getPriority(self: *ChunkLoadTask) f32 {
			switch (self.source) {
				.user => |user| return self.pos.getPriority(user.player.pos),
				else => return std.math.floatMax(f32),
			}
		}

		pub fn isStillNeeded(self: *ChunkLoadTask) bool {
			switch (self.source) { // Remove the task if the player disconnected
				.user => |user| if (!user.connected.load(.monotonic)) return false,
				.simulationChunk => |ch| if (ch.refCount.load(.monotonic) == 2) return false,
			}
			switch (self.source) { // Remove the task if it's far enough away from the player:
				.user => |user| {
					const minDistSquare = self.pos.getMinDistanceSquared(user.clientUpdatePos);
					//                                                                              ↓ Margin for error. (diagonal of 1 chunk)
					var targetRenderDistance: i64 = @as(i64, user.renderDistance)*chunk.chunkSize + @as(i64, @intFromFloat(@as(comptime_int, chunk.chunkSize)*@sqrt(3.0)));
					targetRenderDistance *= self.pos.voxelSize;
					return minDistSquare <= targetRenderDistance*targetRenderDistance;
				},
				.simulationChunk => {},
			}
			return true;
		}

		pub fn run(self: *ChunkLoadTask) void {
			defer self.clean();
			generateChunk(self.pos, self.source);
		}

		pub fn clean(self: *ChunkLoadTask) void {
			switch (self.source) {
				.user => |user| user.decreaseRefCount(),
				.simulationChunk => |ch| ch.decreaseRefCount(),
			}
			main.globalAllocator.destroy(self);
		}
	};

	const LightMapLoadTask = struct { // MARK: LightMapLoadTask
		pos: terrain.SurfaceMap.MapFragmentPosition,
		source: ?*User,

		const vtable = utils.ThreadPool.VTable{
			.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
			.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
			.run = main.meta.castFunctionSelfToAnyopaque(run),
			.clean = main.meta.castFunctionSelfToAnyopaque(clean),
			.taskType = .misc,
		};

		pub fn scheduleAndDecreaseRefCount(pos: terrain.SurfaceMap.MapFragmentPosition, source: ?*User) void {
			const task = main.globalAllocator.create(LightMapLoadTask);
			task.* = LightMapLoadTask{
				.pos = pos,
				.source = source,
			};
			if (source) |user| {
				user.addTask(task, &vtable);
			} else {
				main.threadPool.addTask(task, &vtable);
			}
		}

		pub fn getPriority(self: *LightMapLoadTask) f32 {
			if (self.source) |user| {
				return self.pos.getPriority(user.player.pos, terrain.LightMap.LightMapFragment.mapSize) + 100;
			} else {
				return std.math.floatMax(f32);
			}
		}

		pub fn isStillNeeded(self: *LightMapLoadTask) bool {
			_ = self; // TODO: Do these tasks need to be culled?
			return true;
		}

		pub fn run(self: *LightMapLoadTask) void {
			defer self.clean();
			const map = terrain.LightMap.getOrGenerateFragment(self.pos.wx, self.pos.wy, self.pos.voxelSize);
			if (self.source) |source| {
				if (source.connected.load(.monotonic)) main.network.protocols.lightMapTransmission.sendLightMap(source.conn, map);
			} else {
				const userList = server.getUserListAndIncreaseRefCount(main.stackAllocator);
				defer server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
				for (userList) |user| {
					main.network.protocols.lightMapTransmission.sendLightMap(user.conn, map);
				}
			}
		}

		pub fn clean(self: *LightMapLoadTask) void {
			if (self.source) |source| {
				source.decreaseRefCount();
			}
			main.globalAllocator.destroy(self);
		}
	};

	pub fn init(world: *ServerWorld, settings: ZonElement) !ChunkManager { // MARK: init()
		const self = ChunkManager{
			.world = world,
			.terrainGenerationProfile = try server.terrain.TerrainGenerationProfile.init(settings, world.settings.seed),
		};
		simulationChunkHashMap = .init(main.globalAllocator.allocator);
		server.terrain.init(self.terrainGenerationProfile);
		storage.init();
		return self;
	}

	pub fn deinit(_: ChunkManager) void {
		for (0..main.settings.highestSupportedLod) |_| {
			chunkCache.clear();
		}
		simulationChunkHashMap.deinit();
		server.terrain.deinit();
		main.assets.unloadAssets();
		storage.deinit();
	}

	pub fn queueLightMapAndDecreaseRefCount(self: ChunkManager, pos: terrain.SurfaceMap.MapFragmentPosition, source: ?*User) void {
		_ = self;
		LightMapLoadTask.scheduleAndDecreaseRefCount(pos, source);
	}

	pub fn queueChunkAndDecreaseRefCount(self: ChunkManager, pos: ChunkPosition, source: *User) void {
		_ = self;
		ChunkLoadTask.scheduleAndDecreaseRefCount(pos, .{.user = source});
	}

	pub fn generateChunk(pos: ChunkPosition, source: Source) void { // MARK: generateChunk()
		const ch = getOrGenerateChunkAndIncreaseRefCount(pos);
		switch (source) {
			.user => |user| {
				main.network.protocols.chunkTransmission.sendChunk(user.conn, ch);
				ch.decreaseRefCount();
			},
			.simulationChunk => |simulationChunk| {
				simulationChunk.setChunkAndDecreaseRefCount(ch);
			},
		}
	}

	fn chunkInitFunctionForCacheAndIncreaseRefCount(pos: ChunkPosition) *ServerChunk {
		if (pos.voxelSize == 1) if (getSimulationChunkAndIncreaseRefCount(pos)) |simulationChunk| { // Check if we already have it in memory.
			defer simulationChunk.decreaseRefCount();
			if (simulationChunk.getChunk()) |ch| {
				ch.increaseRefCount();
				return ch;
			}
		};
		const regionSize = pos.voxelSize*chunk.chunkSize*storage.RegionFile.regionSize;
		const regionMask: i32 = regionSize - 1;
		const region = storage.loadRegionFileAndIncreaseRefCount(pos.wx & ~regionMask, pos.wy & ~regionMask, pos.wz & ~regionMask, pos.voxelSize);
		defer region.decreaseRefCount();
		const ch = ServerChunk.initAndIncreaseRefCount(pos);
		ch.mutex.lock();
		defer ch.mutex.unlock();
		if (region.getChunk(
			main.stackAllocator,
			@as(usize, @intCast(pos.wx -% region.pos.wx))/pos.voxelSize/chunk.chunkSize,
			@as(usize, @intCast(pos.wy -% region.pos.wy))/pos.voxelSize/chunk.chunkSize,
			@as(usize, @intCast(pos.wz -% region.pos.wz))/pos.voxelSize/chunk.chunkSize,
		)) |data| blk: { // Load chunk from file:
			defer main.stackAllocator.free(data);
			storage.ChunkCompression.loadChunk(&ch.super, .server, data) catch {
				std.log.err("Storage for chunk {} in region file at {} is corrupted", .{pos, region.pos});
				break :blk;
			};
			ch.wasStored = true;
			return ch;
		}
		ch.generated = true;
		const caveMap = terrain.CaveMap.CaveMapView.init(main.stackAllocator, ch.super.pos, ch.super.width, 32);
		defer caveMap.deinit(main.stackAllocator);
		const biomeMap = terrain.CaveBiomeMap.CaveBiomeMapView.init(main.stackAllocator, ch.super.pos, ch.super.width, 32);
		defer biomeMap.deinit();
		for (server.world.?.chunkManager.terrainGenerationProfile.generators) |generator| {
			generator.generate(server.world.?.settings.seed ^ generator.generatorSeed, ch, caveMap, biomeMap);
		}
		if (pos.voxelSize != 1) { // Generate LOD replacements
			for (ch.super.data.palette()) |*block| {
				block.store(.{.typ = block.load(.unordered).lodReplacement(), .data = block.load(.unordered).data}, .unordered);
			}
		}
		return ch;
	}

	fn chunkDeinitFunctionForCache(ch: *ServerChunk) void {
		ch.decreaseRefCount();
	}
	/// Generates a normal chunk at a given location, or if possible gets it from the cache.
	pub fn getOrGenerateChunkAndIncreaseRefCount(pos: ChunkPosition) *ServerChunk {
		const mask = pos.voxelSize*chunk.chunkSize - 1;
		std.debug.assert(pos.wx & mask == 0 and pos.wy & mask == 0 and pos.wz & mask == 0);
		const result = chunkCache.findOrCreate(pos, chunkInitFunctionForCacheAndIncreaseRefCount, ServerChunk.increaseRefCount);
		return result;
	}

	pub fn getChunkFromCacheAndIncreaseRefCount(pos: ChunkPosition) ?*ServerChunk {
		const mask = pos.voxelSize*chunk.chunkSize - 1;
		std.debug.assert(pos.wx & mask == 0 and pos.wy & mask == 0 and pos.wz & mask == 0);
		const result = chunkCache.find(pos, ServerChunk.increaseRefCount) orelse return null;
		return result;
	}
};

pub const worldDataVersion: u32 = 5;

pub const ServerWorld = struct { // MARK: ServerWorld
	pub const dayCycle: u31 = 12000; // Length of one in-game day in units of 100ms. Midnight is at DAY_CYCLE/2. Sunrise and sunset each take about 1/16 of the day. Currently set to 20 minutes

	itemDropManager: ItemDropManager = undefined,
	blockPalette: *main.assets.Palette = undefined,
	itemPalette: *main.assets.Palette = undefined,
	toolPalette: *main.assets.Palette = undefined,
	biomePalette: *main.assets.Palette = undefined,
	chunkManager: ChunkManager = undefined,

	gameTime: i64 = 0,
	milliTime: std.Io.Timestamp,
	lastUpdateTime: std.Io.Timestamp,
	lastUnimportantDataSent: std.Io.Timestamp,
	doGameTimeCycle: bool = true,

	tickSpeed: std.atomic.Value(u32) = .init(12),

	settings: Settings = undefined,

	path: []const u8,
	name: []const u8 = &.{},
	spawn: Vec3i = undefined,

	mutex: std.Thread.Mutex = .{},

	chunkUpdateQueue: main.utils.CircularBufferQueue(ChunkUpdateRequest),
	regionUpdateQueue: main.utils.CircularBufferQueue(RegionUpdateRequest),

	playerDatabase: std.StringHashMapUnmanaged(usize) = .{},
	nextPlayerIndex: std.atomic.Value(usize) = .init(0),

	biomeChecksum: i64 = 0,

	const ChunkUpdateRequest = struct {
		ch: *ServerChunk,
		milliTimeStamp: i64,
	};

	const RegionUpdateRequest = struct {
		region: *storage.RegionFile,
		milliTimeStamp: i64,
	};

	pub fn init(path: []const u8) !*ServerWorld { // MARK: init()
		const self = main.globalAllocator.create(ServerWorld);
		errdefer main.globalAllocator.destroy(self);
		self.* = ServerWorld{
			.lastUpdateTime = main.timestamp(),
			.milliTime = main.timestamp(),
			.lastUnimportantDataSent = main.timestamp(),
			.path = main.globalAllocator.dupe(u8, path),
			.chunkUpdateQueue = .init(main.globalAllocator, 256),
			.regionUpdateQueue = .init(main.globalAllocator, 256),
		};
		self.itemDropManager.init(main.globalAllocator, self);
		errdefer self.itemDropManager.deinit();

		const arena = main.stackAllocator.createArena();
		defer main.stackAllocator.destroyArena(arena);

		var dir = try files.cubyzDir().openDir(try std.fmt.allocPrint(arena.allocator, "saves/{s}", .{path}));
		defer dir.close();

		self.blockPalette = try loadPalette(arena, path, "palette", "cubyz:air");
		errdefer self.blockPalette.deinit();

		self.itemPalette = try loadPalette(arena, path, "item_palette", null);
		errdefer self.itemPalette.deinit();

		self.toolPalette = try loadPalette(arena, path, "tool_palette", null);
		errdefer self.toolPalette.deinit();

		self.biomePalette = try loadPalette(arena, path, "biome_palette", null);
		errdefer self.biomePalette.deinit();

		errdefer main.assets.unloadAssets();

		const worldData = try dir.readToZon(arena, "world.zig.zon");
		try self.loadWorldConfig(arena, dir, worldData);
		try self.loadPlayerLoginInfo(dir);

		try main.assets.loadWorldAssets(try std.fmt.allocPrint(arena.allocator, "{s}/saves/{s}/assets/", .{files.cubyzDirStr(), path}), self.blockPalette, self.itemPalette, self.toolPalette, self.biomePalette);
		// Store the block palette now that everything is loaded.
		try dir.writeZon("palette.zig.zon", self.blockPalette.storeToZon(arena));
		try dir.writeZon("item_palette.zig.zon", self.itemPalette.storeToZon(arena));
		try dir.writeZon("tool_palette.zig.zon", self.toolPalette.storeToZon(arena));
		try dir.writeZon("biome_palette.zig.zon", self.biomePalette.storeToZon(arena));

		self.chunkManager = try ChunkManager.init(self, worldData.getChild("generatorSettings"));
		errdefer self.chunkManager.deinit();

		return self;
	}

	pub fn loadPalette(allocator: NeverFailingAllocator, worldName: []const u8, paletteName: []const u8, firstEntry: ?[]const u8) !*Palette {
		const path = try std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/{s}.zig.zon", .{worldName, paletteName});
		defer main.stackAllocator.allocator.free(path);
		const paletteZon = files.cubyzDir().readToZon(allocator, path) catch .null;
		const palette = try main.assets.Palette.init(main.globalAllocator, paletteZon, firstEntry);
		std.log.info("Loaded {s} with {} entries.", .{paletteName, palette.size()});
		return palette;
	}

	pub fn deinit(self: *ServerWorld) void {
		self.forceSave() catch |err| {
			std.log.err("Error while saving the world: {s}", .{@errorName(err)});
		};
		while (self.chunkUpdateQueue.popFront()) |updateRequest| {
			updateRequest.ch.save(self);
			updateRequest.ch.decreaseRefCount();
		}
		self.chunkUpdateQueue.deinit();
		while (self.regionUpdateQueue.popFront()) |updateRequest| {
			updateRequest.region.store();
			updateRequest.region.decreaseRefCount();
		}
		self.regionUpdateQueue.deinit();
		self.chunkManager.deinit();
		self.itemDropManager.deinit();
		self.blockPalette.deinit();
		self.itemPalette.deinit();
		self.toolPalette.deinit();
		self.biomePalette.deinit();
		main.globalAllocator.free(self.path);
		main.globalAllocator.free(self.name);
		main.globalAllocator.destroy(self);
	}

	pub fn loadWorldConfig(self: *ServerWorld, arena: NeverFailingAllocator, dir: main.files.Dir, worldData: ZonElement) !void { // MARK: loadWorldConfig
		if (worldData.get(u32, "version", 0) == 2) { // TODO: #2458
			std.log.info("Migrating old world with world version 2 to version 3", .{});

			const gamerules = try dir.readToZon(arena, "gamerules.zig.zon");
			const settings = ZonElement.initObject(arena);
			settings.put("defaultGamemode", gamerules.getChild("default_gamemode"));
			settings.put("allowCheats", gamerules.getChild("cheats"));
			settings.put("testingMode", gamerules.getChild("testingMode"));
			settings.put("seed", worldData.get(?u64, "seed", null) orelse {
				std.log.err("Cannot migrate world. World has no seed!", .{});
				return error.NoSeed;
			});
			worldData.put("settings", settings);

			const generatorSettings = try dir.readToZon(arena, "generatorSettings.zig.zon");
			worldData.put("generatorSettings", generatorSettings);

			worldData.put("version", 3);
			try dir.writeZon("world.zig.zon", worldData);
			try dir.deleteFile("gamerules.zig.zon");
			try dir.deleteFile("generatorSettings.zig.zon");
		}

		if (worldData.get(u32, "version", 0) == 3) { // TODO: #2458
			std.log.info("Migrating old world with world version 3 to version 4", .{});
			// In version 0.1.0 these values were written incorrectly
			const settings = worldData.getChild("settings");
			if (settings.removeChild("default_gamemode")) |gamemode| {
				settings.put("defaultGamemode", gamemode);
			}
			if (settings.removeChild("cheats")) |allowCheats| {
				settings.put("allowCheats", allowCheats);
			}

			worldData.put("version", 4);
			try dir.writeZon("world.zig.zon", worldData);
		}

		if (worldData.get(u32, "version", 0) == 4) { // TODO: #2458
			std.log.info("Migrating old world with world version 4 to version 5", .{});
			// Player file names are now numerical instead of based on the name.
			var fileNames: main.List([]const u8) = .init(arena);
			var playerDir = try dir.openIterableDir("players");
			defer playerDir.close();
			var iterator = playerDir.iterate();
			while (try iterator.next()) |file| {
				if (file.kind == .file and std.mem.endsWith(u8, file.name, ".zon")) {
					fileNames.append(arena.dupe(u8, file.name));
				}
			}

			for (fileNames.items, 0..) |oldName, i| {
				const newName = std.fmt.allocPrint(arena.allocator, "{}.zon", .{i}) catch unreachable;
				try playerDir.dir.rename(oldName, newName);
			}

			worldData.put("version", 5);
			try dir.writeZon("world.zig.zon", worldData);
		}

		if (worldData.get(u32, "version", 0) != worldDataVersion) {
			std.log.err("Cannot read world file version {}. Expected version {}.", .{worldData.get(u32, "version", 0), worldDataVersion});
			return error.OldWorld;
		}
		self.settings = try .fromZon(worldData.getChild("settings"));

		self.doGameTimeCycle = worldData.get(bool, "doGameTimeCycle", true);
		self.gameTime = worldData.get(i64, "gameTime", 0);
		self.spawn = worldData.get(Vec3i, "spawn", .{0, 0, 0});
		self.biomeChecksum = worldData.get(i64, "biomeChecksum", 0);
		self.name = main.globalAllocator.dupe(u8, worldData.get([]const u8, "name", self.path));
		self.tickSpeed = .init(worldData.get(u32, "tickSpeed", 12));
	}

	pub fn saveWorldConfig(self: *ServerWorld) !void {
		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/world.zig.zon", .{self.path}) catch unreachable;
		defer main.stackAllocator.free(path);
		const worldData = try files.cubyzDir().readToZon(main.stackAllocator, path);
		defer worldData.deinit(main.stackAllocator);
		worldData.put("version", worldDataVersion);
		worldData.put("doGameTimeCycle", self.doGameTimeCycle);
		worldData.put("gameTime", self.gameTime);
		worldData.put("spawn", self.spawn);
		worldData.put("biomeChecksum", self.biomeChecksum);
		worldData.put("name", self.name);
		worldData.put("lastUsedTime", (try std.Io.Clock.Timestamp.now(main.io, .real)).raw.toMilliseconds());
		worldData.put("tickSpeed", self.tickSpeed.load(.monotonic));

		try files.cubyzDir().writeZon(path, worldData);
	}

	pub fn loadPlayerLoginInfo(self: *ServerWorld, dir: main.files.Dir) !void {
		var playerDir = try dir.openIterableDir("players");
		defer playerDir.close();
		var iterator = playerDir.iterate();
		while (try iterator.next()) |file| {
			if (file.kind == .file and std.mem.endsWith(u8, file.name, ".zon")) {
				const zon = try playerDir.readToZon(main.stackAllocator, file.name);
				defer zon.deinit(main.stackAllocator);
				const fileNameBase = file.name[0 .. std.mem.findScalar(u8, file.name, '.') orelse unreachable];
				if (fileNameBase[0] == '0' and fileNameBase.len != 1) {
					std.log.err("Player file {s} contains leading zeroes. Skipping.", .{file.name});
					continue;
				}
				const index = std.fmt.parseInt(usize, fileNameBase, 10) catch |err| {
					std.log.err("Couldn't parse player file {s}: {s} Skipping.", .{file.name, @errorName(err)});
					continue;
				};
				_ = self.nextPlayerIndex.fetchMax(index + 1, .monotonic);
				if (zon.get(?[]const u8, "publicKey", null)) |key| {
					const keyType = key[0 .. std.mem.findScalar(u8, key, ':') orelse {
						std.log.err("Player file {s} has invalid key entry {s}: Type is missing. Skipping.", .{file.name, key});
						continue;
					}];
					_ = std.meta.stringToEnum(main.network.authentication.KeyTypeEnum, keyType) orelse {
						std.log.err("Player file {s} has invalid key type {s}. Skipping.", .{file.name, keyType});
						continue;
					};
					self.playerDatabase.put(main.worldArena.allocator, main.worldArena.dupe(u8, key), index) catch unreachable;
				} else {
					const name = zon.get(?[]const u8, "name", null) orelse {
						std.log.err("Couldn't read player file {s}. Skipping.", .{file.name});
						continue;
					};
					const fullEntry = std.fmt.allocPrint(main.worldArena.allocator, "name:{s}", .{name}) catch unreachable;
					self.playerDatabase.put(main.worldArena.allocator, fullEntry, index) catch unreachable;
				}
			}
		}
	}

	const RegenerateLODTask = struct { // MARK: RegenerateLODTask
		pos: ChunkPosition,
		storeMaps: bool,

		const vtable = utils.ThreadPool.VTable{
			.getPriority = main.meta.castFunctionSelfToAnyopaque(getPriority),
			.isStillNeeded = main.meta.castFunctionSelfToAnyopaque(isStillNeeded),
			.run = main.meta.castFunctionSelfToAnyopaque(run),
			.clean = main.meta.castFunctionSelfToAnyopaque(clean),
			.taskType = .chunkgen,
		};

		pub fn schedule(pos: ChunkPosition, storeMaps: bool) void {
			const task = main.globalAllocator.create(RegenerateLODTask);
			task.* = .{
				.pos = pos,
				.storeMaps = storeMaps,
			};
			main.threadPool.addTask(task, &vtable);
		}

		pub fn getPriority(_: *RegenerateLODTask) f32 {
			return std.math.floatMax(f32);
		}

		pub fn isStillNeeded(_: *RegenerateLODTask) bool {
			return true;
		}

		pub fn run(self: *RegenerateLODTask) void {
			defer self.clean();
			const region = storage.loadRegionFileAndIncreaseRefCount(self.pos.wx, self.pos.wy, self.pos.wz, self.pos.voxelSize);
			defer region.decreaseRefCount();
			region.mutex.lock();
			defer region.mutex.unlock();
			for (0..storage.RegionFile.regionSize) |x| {
				for (0..storage.RegionFile.regionSize) |y| {
					for (0..storage.RegionFile.regionSize) |z| {
						if (region.chunks[storage.RegionFile.getIndex(x, y, z)].len != 0) {
							region.mutex.unlock();
							defer region.mutex.lock();
							const pos = ChunkPosition{
								.wx = self.pos.wx + @as(i32, @intCast(x))*chunk.chunkSize,
								.wy = self.pos.wy + @as(i32, @intCast(y))*chunk.chunkSize,
								.wz = self.pos.wz + @as(i32, @intCast(z))*chunk.chunkSize,
								.voxelSize = 1,
							};
							const ch = ChunkManager.getOrGenerateChunkAndIncreaseRefCount(pos);
							defer ch.decreaseRefCount();
							var nextPos = pos;
							nextPos.wx &= ~@as(i32, self.pos.voxelSize*chunk.chunkSize);
							nextPos.wy &= ~@as(i32, self.pos.voxelSize*chunk.chunkSize);
							nextPos.wz &= ~@as(i32, self.pos.voxelSize*chunk.chunkSize);
							nextPos.voxelSize *= 2;
							const nextHigherLod = ChunkManager.getOrGenerateChunkAndIncreaseRefCount(nextPos);
							defer nextHigherLod.decreaseRefCount();
							ch.mutex.lock();
							defer ch.mutex.unlock();
							nextHigherLod.updateFromLowerResolution(ch);
						}
					}
				}
			}
		}

		pub fn clean(self: *RegenerateLODTask) void {
			main.globalAllocator.destroy(self);
		}
	};

	fn regenerateLOD(self: *ServerWorld, newBiomeCheckSum: i64) !void {
		std.log.info("Biomes have changed. Regenerating LODs... (this might take some time)", .{});
		const mapsPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/maps", .{self.path}) catch unreachable;
		defer main.stackAllocator.free(mapsPath);
		const hasSurfaceMaps = main.files.cubyzDir().hasDir(mapsPath);
		if (hasSurfaceMaps) {
			try terrain.SurfaceMap.regenerateLOD(self.path);
		}
		// Delete old LODs:
		for (1..main.settings.highestSupportedLod + 1) |i| {
			const lod = @as(u32, 1) << @intCast(i);
			const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/chunks/{}", .{self.path, lod}) catch unreachable;
			defer main.stackAllocator.free(path);
			main.files.cubyzDir().deleteTree(path) catch |err| {
				if (err != error.FileNotFound) {
					std.log.err("Error while deleting directory {s}: {s}", .{path, @errorName(err)});
				}
			};
		}
		// Find all the stored chunks:
		var chunkPositions = main.List(ChunkPosition).init(main.stackAllocator);
		defer chunkPositions.deinit();
		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/chunks/1", .{self.path}) catch unreachable;
		defer main.stackAllocator.free(path);
		blk: {
			var dirX = main.files.cubyzDir().openIterableDir(path) catch |err| {
				if (err == error.FileNotFound) break :blk;
				return err;
			};
			defer dirX.close();
			var iterX = dirX.iterate();
			while (try iterX.next()) |entryX| {
				if (entryX.kind != .directory) continue;
				const wx = std.fmt.parseInt(i32, entryX.name, 0) catch continue;
				var dirY = try dirX.openIterableDir(entryX.name);
				defer dirY.close();
				var iterY = dirY.iterate();
				while (try iterY.next()) |entryY| {
					if (entryY.kind != .directory) continue;
					const wy = std.fmt.parseInt(i32, entryY.name, 0) catch continue;
					var dirZ = try dirY.openIterableDir(entryY.name);
					defer dirZ.close();
					var iterZ = dirZ.iterate();
					while (try iterZ.next()) |entryZ| {
						if (entryZ.kind != .file) continue;
						const nameZ = entryZ.name[0 .. std.mem.indexOfScalar(u8, entryZ.name, '.') orelse entryZ.name.len];
						const wz = std.fmt.parseInt(i32, nameZ, 0) catch continue;
						chunkPositions.append(.{.wx = wx, .wy = wy, .wz = wz, .voxelSize = 1});
					}
				}
			}
		}
		// Load all the stored chunks and update their next LODs.
		for (chunkPositions.items) |pos| {
			RegenerateLODTask.schedule(pos, !hasSurfaceMaps);
		}

		self.mutex.lock();
		defer self.mutex.unlock();
		while (true) {
			while (self.chunkUpdateQueue.popFront()) |updateRequest| {
				self.mutex.unlock();
				defer self.mutex.lock();
				updateRequest.ch.save(self);
				updateRequest.ch.decreaseRefCount();
				main.heap.GarbageCollection.syncPoint();
			}
			while (self.regionUpdateQueue.popFront()) |updateRequest| {
				self.mutex.unlock();
				defer self.mutex.lock();
				updateRequest.region.store();
				updateRequest.region.decreaseRefCount();
				main.heap.GarbageCollection.syncPoint();
			}
			self.mutex.unlock();
			main.io.sleep(.fromMilliseconds(1), .awake) catch {};
			main.heap.GarbageCollection.syncPoint();
			self.mutex.lock();
			if (main.threadPool.queueSize() == 0 and self.chunkUpdateQueue.peekFront() == null and self.regionUpdateQueue.peekFront() == null) break;
		}
		std.log.info("Finished LOD update.", .{});

		self.biomeChecksum = newBiomeCheckSum;
	}

	pub fn generate(self: *ServerWorld) !void {
		if (@reduce(.And, self.spawn == Vec3i{0, 0, 0})) {
			var seed: u64 = self.settings.seed ^ 275892235728371;
			std.log.info("Finding spawn position...", .{});
			foundPosition: {
				// Explore chunks in a spiral from the center:
				const radius = 65536;
				const mapSize = terrain.ClimateMap.ClimateMapFragment.mapSize;
				const spiralLen = 2*radius/mapSize*2*radius/mapSize;
				var wx: i32 = 0;
				var wy: i32 = 0;
				var dirChanges: usize = 1;
				var dir: main.chunk.Neighbor = .dirNegX;
				var stepsRemaining: usize = 1;
				for (0..spiralLen) |_| {
					const map = main.server.terrain.ClimateMap.getOrGenerateFragment(wx, wy);
					for (0..map.map.len) |_| {
						const x = main.random.nextIntBounded(u31, &seed, map.map.len);
						const y = main.random.nextIntBounded(u31, &seed, map.map.len);
						const biomeSize = main.server.terrain.SurfaceMap.MapFragment.biomeSize;
						std.log.info("Trying roughly ({}, {})", .{wx + x*biomeSize, wy + y*biomeSize});
						const sample = map.map[x][y];
						if (sample.biome.isValidPlayerSpawn) {
							for (0..16) |_| {
								self.spawn[0] = wx + x*biomeSize + main.random.nextIntBounded(u31, &seed, biomeSize*2) - biomeSize;
								self.spawn[1] = wy + y*biomeSize + main.random.nextIntBounded(u31, &seed, biomeSize*2) - biomeSize;
								std.log.info("Trying ({}, {})", .{self.spawn[0], self.spawn[1]});
								if (self.isValidSpawnLocation(self.spawn[0], self.spawn[1])) break :foundPosition;
							}
						}
					}
					switch (dir) {
						.dirNegX => wx -%= mapSize,
						.dirPosX => wx +%= mapSize,
						.dirNegY => wy -%= mapSize,
						.dirPosY => wy +%= mapSize,
						else => unreachable,
					}
					stepsRemaining -= 1;
					if (stepsRemaining == 0) {
						switch (dir) {
							.dirNegX => dir = .dirNegY,
							.dirPosX => dir = .dirPosY,
							.dirNegY => dir = .dirPosX,
							.dirPosY => dir = .dirNegX,
							else => unreachable,
						}
						dirChanges += 1;
						// Every second turn the number of steps needed doubles.
						stepsRemaining = dirChanges/2;
					}
				}
				std.log.err("Found no valid spawn location", .{});
			}
			const map = terrain.SurfaceMap.getOrGenerateFragment(self.spawn[0], self.spawn[1], 1);
			self.spawn[2] = map.getHeight(self.spawn[0], self.spawn[1]) + 1;
		}
		const newBiomeCheckSum: i64 = @bitCast(terrain.biomes.getBiomeCheckSum(self.settings.seed));
		if (newBiomeCheckSum != self.biomeChecksum) {
			if (self.settings.testingMode) {
				const dir = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/maps", .{self.path}) catch unreachable;
				defer main.stackAllocator.free(dir);
				main.files.cubyzDir().deleteTree("maps") catch |err| {
					std.log.err("Error while trying to remove maps folder of testingMode world: {s}", .{@errorName(err)});
				};
			} else {
				self.regenerateLOD(newBiomeCheckSum) catch |err| {
					std.log.err("Error while trying to regenerate LODs: {s}", .{@errorName(err)});
				};
			}
		}
		try self.saveWorldConfig();
		loadItemDrops: {
			const itemsPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/itemdrops.bin", .{self.path}) catch unreachable;
			defer main.stackAllocator.free(itemsPath);
			const itemDropData: []const u8 = files.cubyzDir().read(main.stackAllocator, itemsPath) catch |err| {
				if (err != error.FileNotFound) {
					std.log.err("Got error while loading {s}: {s}", .{itemsPath, @errorName(err)});
				}
				break :loadItemDrops;
			};
			defer main.stackAllocator.free(itemDropData);
			var reader = main.utils.BinaryReader.init(itemDropData);
			self.itemDropManager.loadFromBytes(&reader) catch |err| {
				std.log.err("Failed to load item drop data: {s}", .{@errorName(err)});
				std.log.debug("Data: {any}", .{itemDropData});
			};
		}
	}

	pub fn loadPlayer(self: *ServerWorld, user: *User) void {
		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/players/{}.zon", .{self.path, user.playerIndex}) catch unreachable;
		defer main.stackAllocator.free(path);

		const playerData = files.cubyzDir().readToZon(main.stackAllocator, path) catch .null;
		defer playerData.deinit(main.stackAllocator);
		if (playerData.get(?[]const u8, "publicKey", null)) |publicKey| {
			if (!std.mem.eql(u8, publicKey, user.newKeyString)) {
				std.debug.assert(self.playerDatabase.remove(publicKey));
				self.playerDatabase.put(main.worldArena.allocator, main.worldArena.dupe(u8, user.newKeyString), user.playerIndex) catch unreachable;
			}
		} else {
			removeOld: {
				const nameEntry = std.fmt.allocPrint(main.stackAllocator.allocator, "name:{s}", .{playerData.get(?[]const u8, "name", null) orelse break :removeOld}) catch unreachable;
				defer main.stackAllocator.free(nameEntry);
				std.debug.assert(self.playerDatabase.remove(nameEntry));
			}
			self.playerDatabase.put(main.worldArena.allocator, main.worldArena.dupe(u8, user.newKeyString), user.playerIndex) catch unreachable;
		}
		const player = &user.player;
		if (playerData == .null) {
			player.pos = @floatFromInt(self.spawn);

			main.sync.setGamemode(user, self.settings.defaultGamemode);
		} else {
			player.loadFrom(playerData.getChild("entity"));

			user.permissions.fromZon(playerData);

			main.sync.setGamemode(user, std.meta.stringToEnum(main.game.Gamemode, playerData.get([]const u8, "gamemode", @tagName(self.settings.defaultGamemode))) orelse self.settings.defaultGamemode);
		}
		user.inventory = loadPlayerInventory(main.game.Player.inventorySize, playerData.get([]const u8, "playerInventory", ""), .{.playerInventory = user.id}, path);
		user.handInventory = loadPlayerInventory(1, playerData.get([]const u8, "hand", ""), .{.hand = user.id}, path);

		user.spawnPos = playerData.get(Vec3d, "playerSpawnPos", @as(Vec3d, @floatFromInt(self.spawn)));
	}

	fn loadPlayerInventory(size: usize, base64EncodedData: []const u8, source: main.items.Inventory.Source, playerDataFilePath: []const u8) main.items.Inventory.InventoryId {
		const decodedSize = std.base64.url_safe.Decoder.calcSizeForSlice(base64EncodedData) catch |err| blk: {
			std.log.err("Encountered incorrectly encoded inventory data ({s}) while loading data from file '{s}': '{s}'", .{@errorName(err), playerDataFilePath, base64EncodedData});
			break :blk 0;
		};

		const bytes: []u8 = main.stackAllocator.alloc(u8, decodedSize);
		defer main.stackAllocator.free(bytes);

		var readerInput: []const u8 = bytes;

		std.base64.url_safe.Decoder.decode(bytes, base64EncodedData) catch |err| {
			std.log.err("Encountered incorrectly encoded inventory data ({s}) while loading data from file '{s}': '{s}'", .{@errorName(err), playerDataFilePath, base64EncodedData});
			readerInput = "";
		};
		var reader: main.utils.BinaryReader = .init(readerInput);
		return main.items.Inventory.ServerSide.createExternallyManagedInventory(size, .normal, source, &reader, .{});
	}

	fn savePlayerInventory(allocator: NeverFailingAllocator, inv: main.items.Inventory) []const u8 {
		var writer = main.utils.BinaryWriter.init(main.stackAllocator);
		defer writer.deinit();

		inv.toBytes(&writer);

		const destination: []u8 = allocator.alloc(u8, std.base64.url_safe.Encoder.calcSize(writer.data.items.len));
		return std.base64.url_safe.Encoder.encode(destination, writer.data.items);
	}

	pub fn savePlayer(self: *ServerWorld, user: *User) !void {
		const path = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/players/{}.zon", .{self.path, user.playerIndex}) catch unreachable;
		defer main.stackAllocator.free(path);

		var playerZon: ZonElement = files.cubyzDir().readToZon(main.stackAllocator, path) catch .null;
		defer playerZon.deinit(main.stackAllocator);

		if (playerZon != .object) {
			playerZon.deinit(main.stackAllocator);
			playerZon = ZonElement.initObject(main.stackAllocator);
		}

		playerZon.put("name", user.name);
		playerZon.put("publicKey", user.newKeyString);

		playerZon.put("entity", user.player.save(main.stackAllocator));
		user.permissions.toZon(main.stackAllocator, &playerZon);
		playerZon.put("gamemode", @tagName(user.gamemode.load(.monotonic)));

		{
			main.sync.threadContext.assertCorrectContext(.server);
			if (main.items.Inventory.ServerSide.getInventoryFromSource(.{.playerInventory = user.id})) |inv| {
				playerZon.put("playerInventory", ZonElement{.stringOwned = savePlayerInventory(main.stackAllocator, inv)});
			} else @panic("The player inventory wasn't found. Cannot save player data.");

			if (main.items.Inventory.ServerSide.getInventoryFromSource(.{.hand = user.id})) |inv| {
				playerZon.put("hand", ZonElement{.stringOwned = savePlayerInventory(main.stackAllocator, inv)});
			} else @panic("The player hand inventory wasn't found. Cannot save player data.");
		}

		playerZon.put("playerSpawnPos", user.spawnPos);

		const playerPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/players", .{self.path}) catch unreachable;
		defer main.stackAllocator.free(playerPath);

		try files.cubyzDir().makePath(playerPath);

		try files.cubyzDir().writeZon(path, playerZon);
	}

	pub fn saveAllPlayers(self: *ServerWorld) !void {
		const userList = server.getUserListAndIncreaseRefCount(main.stackAllocator);
		defer server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);

		for (userList) |user| {
			try savePlayer(self, user);
		}
	}

	pub fn forceSave(self: *ServerWorld) !void {
		// TODO: Save chunks and player data
		try self.saveWorldConfig();

		try self.saveAllPlayers();

		var itemDropData = main.utils.BinaryWriter.init(main.stackAllocator);
		defer itemDropData.deinit();
		self.itemDropManager.storeToBytes(&itemDropData);
		const itemsPath = std.fmt.allocPrint(main.stackAllocator.allocator, "saves/{s}/itemdrops.bin", .{self.path}) catch unreachable;
		defer main.stackAllocator.free(itemsPath);
		try files.cubyzDir().write(itemsPath, itemDropData.data.items);
	}

	fn isValidSpawnLocation(_: *ServerWorld, wx: i32, wy: i32) bool {
		const map = terrain.SurfaceMap.getOrGenerateFragment(wx, wy, 1);
		return map.getBiome(wx, wy).isValidPlayerSpawn;
	}

	pub fn dropWithCooldown(self: *ServerWorld, stack: ItemStack, pos: Vec3d, dir: Vec3f, velocity: f32, pickupCooldown: i32) void {
		const vel: Vec3d = @floatCast(dir*@as(Vec3f, @splat(velocity)));
		const rot = main.random.nextFloatVector(3, &main.seed)*@as(Vec3f, @splat(2*std.math.pi));
		self.itemDropManager.add(pos, vel, rot, stack, server.updatesPerSec*900, pickupCooldown);
	}

	pub fn drop(self: *ServerWorld, stack: ItemStack, pos: Vec3d, dir: Vec3f, velocity: f32) void {
		self.dropWithCooldown(stack, pos, dir, velocity, 0);
	}

	fn tick(self: *ServerWorld) void {
		ChunkManager.mutex.lock();
		var iter = ChunkManager.simulationChunkHashMap.valueIterator();
		var currentChunks: main.ListUnmanaged(*SimulationChunk) = .initCapacity(main.stackAllocator, iter.len);
		defer currentChunks.deinit(main.stackAllocator);
		while (iter.next()) |simulationChunk| {
			simulationChunk.*.increaseRefCount();
			currentChunks.append(main.stackAllocator, simulationChunk.*);
		}
		ChunkManager.mutex.unlock();

		for (currentChunks.items) |simulationChunk| {
			defer simulationChunk.decreaseRefCount();
			simulationChunk.update(self.tickSpeed.load(.monotonic));
		}
	}

	pub fn update(self: *ServerWorld) void { // MARK: update()
		const newTime = main.timestamp();
		var deltaTime = @as(f32, @floatFromInt(self.lastUpdateTime.durationTo(newTime).toNanoseconds()))/1.0e9;
		self.lastUpdateTime = newTime;
		if (deltaTime > 0.3) {
			std.log.warn("Update time is getting too high. It's already at {} s!", .{deltaTime});
			deltaTime = 0.3;
		}

		while (self.milliTime.durationTo(newTime).toMilliseconds() > 100) {
			self.milliTime = self.milliTime.addDuration(.fromMilliseconds(100));
			if (self.doGameTimeCycle) self.gameTime +%= 1; // gameTime is measured in 100ms.
		}
		if (self.lastUnimportantDataSent.durationTo(newTime).toSeconds() > 2) {
			self.lastUnimportantDataSent = newTime;
			const userList = server.getUserListAndIncreaseRefCount(main.stackAllocator);
			defer server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
			for (userList) |user| {
				main.network.protocols.genericUpdate.sendTime(user.conn, self);
			}
		}
		self.tick();
		// TODO: Entities

		// Item Entities
		self.itemDropManager.update(deltaTime);
		{ // Collect item entities:
			const userList = server.getUserListAndIncreaseRefCount(main.stackAllocator);
			defer server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
			for (userList) |user| {
				self.itemDropManager.checkEntity(user);
			}
		}

		// Store chunks and regions.
		// Stores at least one chunk and one region per iteration.
		// All chunks and regions will be stored within the storage time.
		const insertionTime = newTime.subDuration(main.settings.storageTime);
		self.mutex.lock();
		defer self.mutex.unlock();
		while (self.chunkUpdateQueue.popFront()) |updateRequest| {
			self.mutex.unlock();
			defer self.mutex.lock();
			updateRequest.ch.save(self);
			updateRequest.ch.decreaseRefCount();
			if (updateRequest.milliTimeStamp -% insertionTime.toMilliseconds() <= 0) break;
		}
		while (self.regionUpdateQueue.popFront()) |updateRequest| {
			self.mutex.unlock();
			defer self.mutex.lock();
			updateRequest.region.store();
			updateRequest.region.decreaseRefCount();
			if (updateRequest.milliTimeStamp -% insertionTime.toMilliseconds() <= 0) break;
		}
	}

	pub fn queueChunkAndDecreaseRefCount(self: *ServerWorld, pos: ChunkPosition, source: *User) void {
		self.chunkManager.queueChunkAndDecreaseRefCount(pos, source);
	}

	pub fn queueLightMapAndDecreaseRefCount(self: *ServerWorld, pos: terrain.SurfaceMap.MapFragmentPosition, source: *User) void {
		self.chunkManager.queueLightMapAndDecreaseRefCount(pos, source);
	}

	pub fn getSimulationChunkAndIncreaseRefCount(_: *ServerWorld, x: i32, y: i32, z: i32) ?*SimulationChunk {
		if (ChunkManager.getSimulationChunkAndIncreaseRefCount(.{.wx = x & ~@as(i32, chunk.chunkMask), .wy = y & ~@as(i32, chunk.chunkMask), .wz = z & ~@as(i32, chunk.chunkMask), .voxelSize = 1})) |entityChunk| {
			return entityChunk;
		}
		return null;
	}

	pub fn getOrGenerateChunkAndIncreaseRefCount(_: *ServerWorld, pos: chunk.ChunkPosition) *ServerChunk {
		return ChunkManager.getOrGenerateChunkAndIncreaseRefCount(pos);
	}

	pub fn getChunkFromCacheAndIncreaseRefCount(_: *ServerWorld, pos: chunk.ChunkPosition) ?*ServerChunk {
		return ChunkManager.getChunkFromCacheAndIncreaseRefCount(pos);
	}

	pub fn getBiome(_: *const ServerWorld, wx: i32, wy: i32, wz: i32) *const terrain.biomes.Biome {
		const map = terrain.CaveBiomeMap.InterpolatableCaveBiomeMapView.init(main.stackAllocator, .{.wx = wx, .wy = wy, .wz = wz, .voxelSize = 1}, 1, 0);
		defer map.deinit();
		return map.getRoughBiome(wx, wy, wz, false, undefined, true);
	}

	pub fn getBlock(self: *ServerWorld, x: i32, y: i32, z: i32) ?Block {
		const chunkPos = Vec3i{x, y, z} & ~@as(Vec3i, @splat(main.chunk.chunkMask));
		const otherChunk = self.getSimulationChunkAndIncreaseRefCount(chunkPos[0], chunkPos[1], chunkPos[2]) orelse return null;
		defer otherChunk.decreaseRefCount();
		const ch = otherChunk.getChunk() orelse return null;
		ch.mutex.lock();
		defer ch.mutex.unlock();
		return ch.getBlock(x - ch.super.pos.wx, y - ch.super.pos.wy, z - ch.super.pos.wz);
	}

	pub fn getBlockAndBlockEntityData(self: *ServerWorld, x: i32, y: i32, z: i32, blockEntityDataWriter: *utils.BinaryWriter) ?Block {
		const chunkPos = Vec3i{x, y, z} & ~@as(Vec3i, @splat(main.chunk.chunkMask));
		const otherChunk = self.getSimulationChunkAndIncreaseRefCount(chunkPos[0], chunkPos[1], chunkPos[2]) orelse return null;
		defer otherChunk.decreaseRefCount();
		const ch = otherChunk.getChunk() orelse return null;
		ch.mutex.lock();
		defer ch.mutex.unlock();
		const block = ch.getBlock(x - ch.super.pos.wx, y - ch.super.pos.wy, z - ch.super.pos.wz);
		if (block.blockEntity()) |blockEntity| {
			blockEntity.getServerToClientData(.{x, y, z}, &ch.super, blockEntityDataWriter);
		}
		return block;
	}

	/// Returns the actual block on failure
	pub fn cmpxchgBlock(self: *ServerWorld, wx: i32, wy: i32, wz: i32, oldBlock: ?Block, _newBlock: Block) ?Block {
		main.sync.threadContext.assertCorrectContext(.server);
		const baseChunk = ChunkManager.getOrGenerateChunkAndIncreaseRefCount(.{.wx = wx & ~@as(i32, chunk.chunkMask), .wy = wy & ~@as(i32, chunk.chunkMask), .wz = wz & ~@as(i32, chunk.chunkMask), .voxelSize = 1});
		defer baseChunk.decreaseRefCount();
		const pos: chunk.BlockPos = .fromWorldCoords(wx, wy, wz);
		baseChunk.mutex.lock();
		const currentBlock = baseChunk.getBlock(pos.x, pos.y, pos.z);
		if (oldBlock != null) {
			if (oldBlock.? != currentBlock) {
				baseChunk.mutex.unlock();
				return currentBlock;
			}
		}
		baseChunk.mutex.unlock();

		var newBlock = _newBlock;
		for (chunk.Neighbor.iterable) |neighbor| {
			const neighborPos, const chunkLocation = pos.neighbor(neighbor);
			var ch = baseChunk;
			if (chunkLocation == .inNeighborChunk) {
				ch = ChunkManager.getOrGenerateChunkAndIncreaseRefCount(.{
					.wx = baseChunk.super.pos.wx +% pos.x +% neighbor.relX() & ~@as(i32, chunk.chunkMask),
					.wy = baseChunk.super.pos.wy +% pos.y +% neighbor.relY() & ~@as(i32, chunk.chunkMask),
					.wz = baseChunk.super.pos.wz +% pos.z +% neighbor.relZ() & ~@as(i32, chunk.chunkMask),
					.voxelSize = 1,
				});
			}
			defer if (ch != baseChunk) {
				ch.decreaseRefCount();
			};

			ch.mutex.lock();
			defer ch.mutex.unlock();

			var neighborBlock = ch.getBlock(neighborPos.x, neighborPos.y, neighborPos.z);
			if (neighborBlock.mode().dependsOnNeighbors and neighborBlock.mode().updateData(&neighborBlock, neighbor.reverse(), newBlock)) {
				ch.updateBlockAndSetChanged(neighborPos.x, neighborPos.y, neighborPos.z, neighborBlock);
			}
			if (newBlock.mode().dependsOnNeighbors) {
				_ = newBlock.mode().updateData(&newBlock, neighbor, neighborBlock);
			}
		}
		baseChunk.mutex.lock();
		defer baseChunk.mutex.unlock();

		if (currentBlock != _newBlock) {
			if (currentBlock.blockEntity()) |blockEntity| blockEntity.updateServerData(.{wx, wy, wz}, &baseChunk.super, .remove) catch |err| {
				std.log.err("Got error {s} while trying to remove entity data in position {} for block {s}", .{@errorName(err), Vec3i{wx, wy, wz}, currentBlock.id()});
			};
		}
		baseChunk.updateBlockAndSetChanged(pos.x, pos.y, pos.z, newBlock);

		const userList = server.getUserListAndIncreaseRefCount(main.stackAllocator);
		defer server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);

		for (userList) |user| {
			main.network.protocols.blockUpdate.send(user.conn, &.{.{.x = wx, .y = wy, .z = wz, .newBlock = newBlock, .blockEntityData = &.{}}});
		}
		// onBreak event
		if (oldBlock) |block| {
			if (block.typ != newBlock.typ) {
				_ = block.onBreak().run(.{
					.block = block,
					.chunk = baseChunk,
					.blockPos = pos,
				});
			}
		}
		self.triggerNeighborBlockUpdates(wx, wy, wz);

		return null;
	}
	pub fn triggerNeighborBlockUpdates(self: *ServerWorld, wx: i32, wy: i32, wz: i32) void {
		for (chunk.Neighbor.iterable) |value| {
			const pos = Vec3i{
				wx + value.relX(),
				wy + value.relY(),
				wz + value.relZ(),
			};

			var ch = self.getSimulationChunkAndIncreaseRefCount(pos[0], pos[1], pos[2]) orelse continue;
			defer ch.decreaseRefCount();

			ch.blockUpdateSystem.add(.{
				.x = @truncate(@as(u32, @bitCast(pos[0]))),
				.y = @truncate(@as(u32, @bitCast(pos[1]))),
				.z = @truncate(@as(u32, @bitCast(pos[2]))),
			});
		}
	}

	pub fn updateBlock(self: *ServerWorld, wx: i32, wy: i32, wz: i32, newBlock: Block) void {
		_ = self.cmpxchgBlock(wx, wy, wz, null, newBlock);
	}

	pub fn queueChunkUpdateAndDecreaseRefCount(self: *ServerWorld, ch: *ServerChunk) void {
		self.mutex.lock();
		self.chunkUpdateQueue.pushBack(.{.ch = ch, .milliTimeStamp = main.timestamp().toMilliseconds()});
		self.mutex.unlock();
	}

	pub fn queueRegionFileUpdateAndDecreaseRefCount(self: *ServerWorld, region: *storage.RegionFile) void {
		self.mutex.lock();
		self.regionUpdateQueue.pushBack(.{.region = region, .milliTimeStamp = main.timestamp().toMilliseconds()});
		self.mutex.unlock();
	}
};

```

`src/settings.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

const ZonElement = @import("zon.zig").ZonElement;
const main = @import("main");
const Window = @import("graphics/Window.zig");

pub const version = @import("utils/version.zig");

pub const defaultPort: u16 = 47649;
pub const connectionTimeout = 60_000_000;

pub const entityLookback: i16 = 100;

pub const highestSupportedLod: u3 = 5;

pub var lastVersionString: []const u8 = "";

pub var simulationDistance: u16 = 4;

pub var cpuThreads: ?u64 = null;

pub var anisotropicFiltering: u8 = 4.0;

pub var fpsCap: ?u32 = null;

pub var fov: f32 = 70;

pub var vulkanTestingWindow: bool = false;

pub var mouseSensitivity: f32 = 1;
pub var controllerSensitivity: f32 = 1;

pub var invertMouseY: bool = false;

pub var renderDistance: u16 = 7;

pub var highestLod: u3 = highestSupportedLod;

pub var resolutionScale: f32 = 1;

pub var bloom: bool = true;

pub var vsync: bool = true;

pub var playerName: []const u8 = "";

pub var streamerMode: bool = false;

pub var lastUsedIPAddress: []const u8 = "";

pub var storedAccount: main.network.authentication.PasswordEncodedAccountCode = .empty;

pub var guiScale: ?f32 = null;

pub var musicVolume: f32 = 1;

pub var leavesQuality: u16 = 2;

pub var @"lod0.5Distance": f32 = 200;

pub var blockContrast: f32 = 0;

pub var nightBrightness: f32 = 0.5;

pub var storageTime: std.Io.Duration = .fromSeconds(5);

pub var updateRepeatSpeed: std.Io.Duration = .fromMilliseconds(200);

pub var updateRepeatDelay: std.Io.Duration = .fromMilliseconds(500);

pub var controllerAxisDeadzone: f32 = 0.2;

const settingsFile = if (builtin.mode == .Debug) "debug_settings.zig.zon" else "settings.zig.zon";

pub fn init() void {
	const zon: ZonElement = main.files.cubyzDir().readToZon(main.stackAllocator, settingsFile) catch |err| blk: {
		if (err != error.FileNotFound) {
			std.log.err("Could not read settings file: {s}", .{@errorName(err)});
		}
		break :blk .null;
	};
	defer zon.deinit(main.stackAllocator);

	inline for (@typeInfo(@This()).@"struct".decls) |decl| runtimeContinueInsideOfComptimeBlock: {
		const is_const = @typeInfo(@TypeOf(&@field(@This(), decl.name))).pointer.is_const; // Sadly there is no direct way to check if a declaration is const.
		if (!is_const) {
			const DeclType = @TypeOf(@field(@This(), decl.name));
			if (@typeInfo(DeclType) == .@"struct") {
				if (DeclType == std.Io.Duration) {
					const defaultMilli = @as(f64, @floatFromInt(@field(@This(), decl.name).toNanoseconds()))/1.0e6;
					@field(@This(), decl.name) = .fromNanoseconds(@intFromFloat(zon.get(f64, decl.name, defaultMilli)*1.0e6));
					continue;
				}
				@field(@This(), decl.name) = DeclType.fromZon(main.globalAllocator, zon.getChild(decl.name)) catch |err| {
					std.log.err("Got error while loading setting {s}: {s}", .{decl.name, @errorName(err)});
					break :runtimeContinueInsideOfComptimeBlock;
				};
				continue;
			}
			@field(@This(), decl.name) = zon.get(DeclType, decl.name, @field(@This(), decl.name));
			if (@typeInfo(DeclType) == .pointer) {
				if (@typeInfo(DeclType).pointer.size == .slice) {
					@field(@This(), decl.name) = main.globalAllocator.dupe(@typeInfo(DeclType).pointer.child, @field(@This(), decl.name));
				} else {
					@compileError("Not implemented yet.");
				}
			}
		}
	}

	if (resolutionScale != 1 and resolutionScale != 0.5 and resolutionScale != 0.25) resolutionScale = 1;

	// keyboard settings:
	const keyboard = zon.getChild("keyboard");
	for (&main.KeyBoard.keys) |*key| {
		const keyZon = keyboard.getChild(key.name);
		key.key = keyZon.get(c_int, "key", key.key);
		key.mouseButton = keyZon.get(c_int, "mouseButton", key.mouseButton);
		key.scancode = keyZon.get(c_int, "scancode", key.scancode);
		if (key.isToggling != .never) {
			key.isToggling = std.meta.stringToEnum(Window.Key.IsToggling, keyZon.get([]const u8, "isToggling", "")) orelse key.isToggling;
		}
	}
}

pub fn deinit() void {
	save();
	inline for (@typeInfo(@This()).@"struct".decls) |decl| {
		const is_const = @typeInfo(@TypeOf(&@field(@This(), decl.name))).pointer.is_const; // Sadly there is no direct way to check if a declaration is const.
		if (!is_const) {
			const DeclType = @TypeOf(@field(@This(), decl.name));
			if (@typeInfo(DeclType) == .@"struct") {
				if (DeclType == std.Io.Duration) continue;
				@field(@This(), decl.name).deinit(main.globalAllocator);
				continue;
			}
			if (@typeInfo(DeclType) == .pointer) {
				if (@typeInfo(DeclType).pointer.size == .slice) {
					main.globalAllocator.free(@field(@This(), decl.name));
				} else {
					@compileError("Not implemented yet.");
				}
			}
		}
	}
}

pub fn save() void {
	var zonObject = ZonElement.initObject(main.stackAllocator);
	defer zonObject.deinit(main.stackAllocator);

	inline for (@typeInfo(@This()).@"struct".decls) |decl| {
		if (comptime std.mem.eql(u8, decl.name, "lastVersionString")) {
			zonObject.put(decl.name, version.version);
			continue;
		}
		const is_const = @typeInfo(@TypeOf(&@field(@This(), decl.name))).pointer.is_const; // Sadly there is no direct way to check if a declaration is const.
		if (!is_const) {
			const DeclType = @TypeOf(@field(@This(), decl.name));
			if (@typeInfo(DeclType) == .@"struct") {
				if (DeclType == std.Io.Duration) {
					zonObject.put(decl.name, @as(f64, @floatFromInt(@field(@This(), decl.name).toNanoseconds()))/1.0e6);
					continue;
				}
				zonObject.put(decl.name, @field(@This(), decl.name).toZon(main.stackAllocator));
				continue;
			}
			if (DeclType == []const u8) {
				zonObject.putOwnedString(decl.name, @field(@This(), decl.name));
			} else {
				zonObject.put(decl.name, @field(@This(), decl.name));
			}
		}
	}

	// keyboard settings:
	const keyboard = ZonElement.initObject(main.stackAllocator);
	for (&main.KeyBoard.keys) |key| {
		const keyZon = ZonElement.initObject(main.stackAllocator);
		keyZon.put("key", key.key);
		keyZon.put("mouseButton", key.mouseButton);
		keyZon.put("scancode", key.scancode);
		if (key.isToggling != .never) {
			keyZon.put("isToggling", @tagName(key.isToggling));
		}
		keyboard.put(key.name, keyZon);
	}
	zonObject.put("keyboard", keyboard);

	// Merge with the old settings file to preserve unknown settings.
	var oldZonObject: ZonElement = main.files.cubyzDir().readToZon(main.stackAllocator, settingsFile) catch |err| blk: {
		if (err != error.FileNotFound) {
			std.log.err("Could not read settings file: {s}", .{@errorName(err)});
		}
		break :blk .null;
	};
	defer oldZonObject.deinit(main.stackAllocator);

	if (oldZonObject == .object) {
		zonObject.join(.preferLeft, oldZonObject);
	}

	main.files.cubyzDir().writeZon(settingsFile, zonObject) catch |err| {
		std.log.err("Couldn't write settings to file: {s}", .{@errorName(err)});
	};
}

pub const launchConfig = struct {
	pub var cubyzDir: []const u8 = "";
	pub var autoEnterWorld: []const u8 = "";
	pub var headlessServer: bool = false;
	pub var preferredAuthenticationAlgorithm: main.network.authentication.KeyTypeEnum = .ed25519;

	pub fn init() void {
		const zon: ZonElement = main.files.cwd().readToZon(main.stackAllocator, "launchConfig.zon") catch |err| blk: {
			std.log.err("Could not read launchConfig.zon: {s}", .{@errorName(err)});
			break :blk .null;
		};
		defer zon.deinit(main.stackAllocator);

		cubyzDir = main.globalArena.dupe(u8, zon.get([]const u8, "cubyzDir", cubyzDir));
		headlessServer = zon.get(bool, "headlessServer", headlessServer);
		autoEnterWorld = main.globalArena.dupe(u8, zon.get([]const u8, "autoEnterWorld", autoEnterWorld));
		preferredAuthenticationAlgorithm = zon.get(main.network.authentication.KeyTypeEnum, "preferredAuthenticationAlgorithm", preferredAuthenticationAlgorithm);
	}
};

```

`src/sync.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Block = main.blocks.Block;
const Neighbor = main.chunk.Neighbor;
const Gamemode = main.game.Gamemode;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const Inventory = main.items.Inventory;
const InventoryId = Inventory.InventoryId;
const InventoryAndSlot = Inventory.InventoryAndSlot;
const Item = main.items.Item;
const ItemStack = main.items.ItemStack;
const utils = main.utils;
const BinaryReader = utils.BinaryReader;
const BinaryWriter = utils.BinaryWriter;
const vec = main.vec;
const Vec3d = vec.Vec3d;
const Vec3f = vec.Vec3f;
const Vec3i = vec.Vec3i;
const ZonElement = main.ZonElement;

pub const Side = enum { client, server };

pub const ClientSide = struct {
	pub var mutex: std.Thread.Mutex = .{};
	var commands: utils.CircularBufferQueue(Command) = undefined;

	pub fn init() void {
		commands = utils.CircularBufferQueue(Command).init(main.globalAllocator, 256);
	}

	pub fn deinit() void {
		reset();
		commands.deinit();
	}

	pub fn reset() void {
		mutex.lock();
		while (commands.popFront()) |cmd| {
			var reader = BinaryReader.init(&.{});
			cmd.finalize(main.globalAllocator, .client, &reader) catch |err| {
				std.log.err("Got error while cleaning remaining inventory commands: {s}", .{@errorName(err)});
			};
		}
		mutex.unlock();
	}

	pub fn executeCommand(payload: Command.Payload) void {
		var cmd: Command = .{
			.payload = payload,
		};

		mutex.lock();
		defer mutex.unlock();
		cmd.do(main.globalAllocator, .client, null, main.game.Player.gamemode.raw) catch unreachable;
		const data = cmd.serializePayload(main.stackAllocator);
		defer main.stackAllocator.free(data);
		main.network.protocols.inventory.sendCommand(main.game.world.?.conn, cmd.payload, data);
		commands.pushBack(cmd);
	}

	pub fn receiveConfirmation(reader: *BinaryReader) !void {
		mutex.lock();
		defer mutex.unlock();
		try commands.popFront().?.finalize(main.globalAllocator, .client, reader);
	}

	pub fn receiveFailure() void {
		mutex.lock();
		defer mutex.unlock();
		var tempData = main.List(Command).init(main.stackAllocator);
		defer tempData.deinit();
		while (commands.popBack()) |_cmd| {
			var cmd = _cmd;
			cmd.undo();
			tempData.append(cmd);
		}
		if (tempData.popOrNull()) |_cmd| {
			var cmd = _cmd;
			var reader = BinaryReader.init(&.{});
			cmd.finalize(main.globalAllocator, .client, &reader) catch |err| {
				std.log.err("Got error while cleaning rejected inventory command: {s}", .{@errorName(err)});
			};
		}
		while (tempData.popOrNull()) |_cmd| {
			var cmd = _cmd;
			cmd.do(main.globalAllocator, .client, null, main.game.Player.gamemode.raw) catch unreachable;
			commands.pushBack(cmd);
		}
	}

	pub fn receiveSyncOperation(reader: *BinaryReader) !void {
		mutex.lock();
		defer mutex.unlock();
		var tempData = main.List(Command).init(main.stackAllocator);
		defer tempData.deinit();
		while (commands.popBack()) |_cmd| {
			var cmd = _cmd;
			cmd.undo();
			tempData.append(cmd);
		}
		try Command.SyncOperation.executeFromData(reader);
		while (tempData.popOrNull()) |_cmd| {
			var cmd = _cmd;
			cmd.do(main.globalAllocator, .client, null, main.game.Player.gamemode.raw) catch unreachable;
			commands.pushBack(cmd);
		}
	}

	fn setGamemode(gamemode: Gamemode) void {
		mutex.lock();
		defer mutex.unlock();
		main.game.Player.setGamemode(gamemode);
		var tempData = main.List(Command).init(main.stackAllocator);
		defer tempData.deinit();
		while (commands.popBack()) |_cmd| {
			var cmd = _cmd;
			cmd.undo();
			tempData.append(cmd);
		}
		while (tempData.popOrNull()) |_cmd| {
			var cmd = _cmd;
			cmd.do(main.globalAllocator, .client, null, gamemode) catch unreachable;
			commands.pushBack(cmd);
		}
	}
};

pub const ServerSide = struct { // MARK: ServerSide

	pub fn init() void {
		threadContext = .server;
	}

	pub fn deinit() void {
		threadContext.assertCorrectContext(.server);
		threadContext = .other;
	}

	pub fn executeCommand(payload: Command.Payload, source: ?*main.server.User) void {
		var command = Command{
			.payload = payload,
		};
		command.do(main.globalAllocator, .server, source, if (source) |s| s.gamemode.raw else .creative) catch {
			main.network.protocols.inventory.sendFailure(source.?.conn);
			return;
		};
		if (source != null) {
			const confirmationData = command.confirmationData(main.stackAllocator);
			defer main.stackAllocator.free(confirmationData);
			main.network.protocols.inventory.sendConfirmation(source.?.conn, confirmationData);
		}
		for (command.syncOperations.items) |op| {
			const syncData = op.serialize(main.stackAllocator);
			defer main.stackAllocator.free(syncData);

			const users = op.getUsers(main.stackAllocator);
			defer main.stackAllocator.free(users);

			for (users) |user| {
				if (user == source and op.ignoreSource()) continue;
				main.network.protocols.inventory.sendSyncOperation(user.conn, syncData);
			}
		}
		if (source != null and command.payload == .open) { // Send initial items
			for (command.payload.open.inv._items, 0..) |stack, slot| {
				if (stack.item != .null) {
					const syncOp = Command.SyncOperation{.create = .{
						.inv = .{.inv = command.payload.open.inv, .slot = @intCast(slot)},
						.amount = stack.amount,
						.item = stack.item,
					}};
					const syncData = syncOp.serialize(main.stackAllocator);
					defer main.stackAllocator.free(syncData);
					main.network.protocols.inventory.sendSyncOperation(source.?.conn, syncData);
				}
			}
		}
		var reader = BinaryReader.init(&.{});
		command.finalize(main.globalAllocator, .server, &reader) catch |err| {
			std.log.err("Got error while finalizing command on the server side: {s}", .{@errorName(err)});
		};
	}

	pub fn executeUserCommand(source: *main.server.User, reader: *BinaryReader) !void {
		threadContext.assertCorrectContext(.server);
		const typ = try reader.readEnum(Command.PayloadType);
		@setEvalBranchQuota(100000);
		const payload: Command.Payload = switch (typ) {
			inline else => |_typ| @unionInit(Command.Payload, @tagName(_typ), try @FieldType(Command.Payload, @tagName(_typ)).deserialize(reader, .server, source)),
		};
		executeCommand(payload, source);
	}

	pub fn receiveCommand(source: *main.server.User, reader: *BinaryReader) void {
		source.receiveCommand(reader.remaining);
	}

	fn setGamemode(user: *main.server.User, gamemode: Gamemode) void {
		threadContext.assertCorrectContext(.server);
		user.gamemode.store(gamemode, .monotonic);
		main.network.protocols.genericUpdate.sendGamemode(user.conn, gamemode);
	}
};

pub fn addHealth(health: f32, cause: main.game.DamageType, side: Side, userId: u32) void {
	threadContext.assertCorrectContext(side);
	if (side == .client) {
		ClientSide.executeCommand(.{.addHealth = .{.target = userId, .health = health, .cause = cause}});
	} else {
		ServerSide.executeCommand(.{.addHealth = .{.target = userId, .health = health, .cause = cause}}, null);
	}
}

pub fn setGamemode(user: ?*main.server.User, gamemode: Gamemode) void {
	if (user == null) {
		ClientSide.setGamemode(gamemode);
	} else {
		ServerSide.setGamemode(user.?, gamemode);
	}
}
pub const Command = struct { // MARK: Command
	pub const PayloadType = enum(u8) {
		open = 0,
		close = 1,
		depositOrSwap = 2,
		deposit = 3,
		takeHalf = 4,
		drop = 5,
		fillFromCreative = 6,
		depositOrDrop = 7,
		depositToAny = 11,
		craftFrom = 13,
		clear = 8,
		updateBlock = 9,
		addHealth = 10,
		chatCommand = 12,
	};
	pub const Payload = union(PayloadType) {
		open: Open,
		close: Close,
		depositOrSwap: DepositOrSwap,
		deposit: Deposit,
		takeHalf: TakeHalf,
		drop: Drop,
		fillFromCreative: FillFromCreative,
		depositOrDrop: DepositOrDrop,
		depositToAny: DepositToAny,
		craftFrom: CraftFrom,
		clear: Clear,
		updateBlock: UpdateBlock,
		addHealth: AddHealth,
		chatCommand: ChatCommand,
	};

	const BaseOperationType = enum(u8) {
		move = 0,
		swap = 1,
		delete = 2,
		create = 3,
		useDurability = 4,
		addHealth = 5,
		addEnergy = 6,
	};

	pub const BaseOperation = union(BaseOperationType) {
		move: struct {
			dest: InventoryAndSlot,
			source: InventoryAndSlot,
			amount: u16,
		},
		swap: struct {
			dest: InventoryAndSlot,
			source: InventoryAndSlot,
		},
		delete: struct {
			source: InventoryAndSlot,
			item: Item = undefined,
			amount: u16,
		},
		create: struct {
			dest: InventoryAndSlot,
			item: Item,
			amount: u16,
		},
		useDurability: struct {
			source: InventoryAndSlot,
			item: main.items.Item = undefined,
			durability: u31,
			previousDurability: u32 = undefined,
		},
		addHealth: struct {
			target: ?*main.server.User,
			health: f32,
			cause: main.game.DamageType,
			previous: f32,
		},
		addEnergy: struct {
			target: ?*main.server.User,
			energy: f32,
			previous: f32,
		},
	};

	const SyncOperationType = enum(u8) {
		create = 0,
		delete = 1,
		useDurability = 2,
		health = 3,
		kill = 4,
		energy = 5,
	};

	const SyncOperation = union(SyncOperationType) { // MARK: SyncOperation
		// Since the client doesn't know about all inventories, we can only use create(+amount)/delete(-amount) and use durability operations to apply the server side updates.
		create: struct {
			inv: InventoryAndSlot,
			amount: u16,
			item: Item,
		},
		delete: struct {
			inv: InventoryAndSlot,
			amount: u16,
		},
		useDurability: struct {
			inv: InventoryAndSlot,
			durability: u32,
		},
		health: struct {
			target: ?*main.server.User,
			health: f32,
		},
		kill: struct {
			target: ?*main.server.User,
			spawnPoint: Vec3d,
		},
		energy: struct {
			target: ?*main.server.User,
			energy: f32,
		},

		pub fn executeFromData(reader: *BinaryReader) !void {
			switch (try deserialize(reader)) {
				.create => |create| {
					if (create.item != .null) {
						create.inv.ref().item = create.item;
					} else if (create.inv.ref().item == .null) {
						return error.Invalid;
					}

					if (create.inv.ref().amount +| create.amount > create.inv.ref().item.stackSize()) {
						return error.Invalid;
					}
					create.inv.ref().amount += create.amount;

					create.inv.inv.update();
				},
				.delete => |delete| {
					if (delete.inv.ref().amount < delete.amount) {
						return error.Invalid;
					}
					delete.inv.ref().amount -= delete.amount;
					if (delete.inv.ref().amount == 0) {
						delete.inv.ref().item = .null;
					}

					delete.inv.inv.update();
				},
				.useDurability => |durability| {
					durability.inv.ref().item.tool.durability -|= durability.durability;
					if (durability.inv.ref().item.tool.durability == 0) {
						durability.inv.ref().item = .null;
						durability.inv.ref().amount = 0;
					}

					durability.inv.inv.update();
				},
				.health => |health| {
					main.game.Player.super.health = std.math.clamp(main.game.Player.super.health + health.health, 0, main.game.Player.super.maxHealth);
				},
				.kill => |kill| {
					main.game.Player.kill(kill.spawnPoint);
				},
				.energy => |energy| {
					main.game.Player.super.energy = std.math.clamp(main.game.Player.super.energy + energy.energy, 0, main.game.Player.super.maxEnergy);
				},
			}
		}

		pub fn getUsers(self: SyncOperation, allocator: NeverFailingAllocator) []*main.server.User {
			switch (self) {
				inline .create, .delete, .useDurability => |data| {
					const users = Inventory.ServerSide.getServerInventory(data.inv.inv.id).users.items;
					const result = allocator.alloc(*main.server.User, users.len);
					for (0..users.len) |i| {
						result[i] = users[i].user;
					}
					return result;
				},
				inline .health, .kill, .energy => |data| {
					const out = allocator.alloc(*main.server.User, 1);
					out[0] = data.target.?;
					return out;
				},
			}
		}

		pub fn ignoreSource(self: SyncOperation) bool {
			return switch (self) {
				.create, .delete, .useDurability, .health, .energy => true,
				.kill => false,
			};
		}

		fn deserialize(reader: *BinaryReader) !SyncOperation {
			const typ = try reader.readEnum(SyncOperationType);

			switch (typ) {
				.create => {
					const out: SyncOperation = .{.create = .{
						.inv = try InventoryAndSlot.read(reader, .client, null),
						.amount = try reader.readInt(u16),
						.item = if (reader.remaining.len > 0) try Item.fromBytes(reader) else .null,
					}};
					return out;
				},
				.delete => {
					const out: SyncOperation = .{.delete = .{
						.inv = try InventoryAndSlot.read(reader, .client, null),
						.amount = try reader.readInt(u16),
					}};

					return out;
				},
				.useDurability => {
					const out: SyncOperation = .{.useDurability = .{
						.inv = try InventoryAndSlot.read(reader, .client, null),
						.durability = try reader.readInt(u32),
					}};

					return out;
				},
				.health => {
					return .{.health = .{
						.target = null,
						.health = try reader.readFloat(f32),
					}};
				},
				.kill => {
					return .{.kill = .{
						.target = null,
						.spawnPoint = try reader.readVec(Vec3d),
					}};
				},
				.energy => {
					return .{.energy = .{
						.target = null,
						.energy = try reader.readFloat(f32),
					}};
				},
			}
		}

		pub fn serialize(self: SyncOperation, allocator: NeverFailingAllocator) []const u8 {
			var writer = BinaryWriter.initCapacity(allocator, 13);
			writer.writeEnum(SyncOperationType, self);
			switch (self) {
				.create => |create| {
					create.inv.write(&writer);
					writer.writeInt(u16, create.amount);
					if (create.item != .null) {
						create.item.toBytes(&writer);
					}
				},
				.delete => |delete| {
					delete.inv.write(&writer);
					writer.writeInt(u16, delete.amount);
				},
				.useDurability => |durability| {
					durability.inv.write(&writer);
					writer.writeInt(u32, durability.durability);
				},
				.health => |health| {
					writer.writeFloat(f32, health.health);
				},
				.kill => |kill| {
					writer.writeVec(Vec3d, kill.spawnPoint);
				},
				.energy => |energy| {
					writer.writeFloat(f32, energy.energy);
				},
			}
			return writer.data.toOwnedSlice();
		}
	};

	payload: Payload,
	baseOperations: main.ListUnmanaged(BaseOperation) = .{},
	syncOperations: main.ListUnmanaged(SyncOperation) = .{},

	fn serializePayload(self: *Command, allocator: NeverFailingAllocator) []const u8 {
		var writer = BinaryWriter.init(allocator);
		defer writer.deinit();
		switch (self.payload) {
			inline else => |payload| {
				payload.serialize(&writer);
			},
		}
		return writer.data.toOwnedSlice();
	}

	fn do(self: *Command, allocator: NeverFailingAllocator, side: Side, user: ?*main.server.User, gamemode: main.game.Gamemode) error{serverFailure}!void { // MARK: do()
		threadContext.assertCorrectContext(side);
		std.debug.assert(self.baseOperations.items.len == 0); // do called twice without cleaning up
		switch (self.payload) {
			inline else => |payload| {
				try payload.run(.{.allocator = allocator, .cmd = self, .side = side, .user = user, .gamemode = gamemode});
			},
		}
	}

	fn undo(self: *Command) void {
		threadContext.assertCorrectContext(.client);
		// Iterating in reverse order!
		while (self.baseOperations.popOrNull()) |step| {
			switch (step) {
				.move => |info| {
					if (info.amount == 0) continue;
					std.debug.assert(std.meta.eql(info.source.ref().item, info.dest.ref().item) or info.source.ref().item == .null);
					info.source.ref().item = info.dest.ref().item;
					info.source.ref().amount += info.amount;
					info.dest.ref().amount -= info.amount;
					if (info.dest.ref().amount == 0) {
						info.dest.ref().item = .null;
					}
					info.source.inv.update();
					info.dest.inv.update();
				},
				.swap => |info| {
					const temp = info.dest.ref().*;
					info.dest.ref().* = info.source.ref().*;
					info.source.ref().* = temp;
					info.source.inv.update();
					info.dest.inv.update();
				},
				.delete => |info| {
					std.debug.assert(info.source.ref().item == .null or std.meta.eql(info.source.ref().item, info.item));
					info.source.ref().item = info.item;
					info.source.ref().amount += info.amount;
					info.source.inv.update();
				},
				.create => |info| {
					std.debug.assert(info.dest.ref().amount >= info.amount);
					info.dest.ref().amount -= info.amount;
					if (info.dest.ref().amount == 0) {
						info.dest.ref().item.deinit();
						info.dest.ref().item = .null;
					}
					info.dest.inv.update();
				},
				.useDurability => |info| {
					std.debug.assert(info.source.ref().item == .null or std.meta.eql(info.source.ref().item, info.item));
					info.source.ref().item = info.item;
					info.item.tool.durability = info.previousDurability;
					info.source.inv.update();
				},
				.addHealth => |info| {
					main.game.Player.super.health = info.previous;
				},
				.addEnergy => |info| {
					main.game.Player.super.energy = info.previous;
				},
			}
		}
	}

	fn finalize(self: Command, allocator: NeverFailingAllocator, side: Side, reader: *BinaryReader) !void {
		for (self.baseOperations.items) |step| {
			switch (step) {
				.move, .swap, .create, .addHealth, .addEnergy => {},
				.delete => |info| {
					info.item.deinit();
				},
				.useDurability => |info| {
					if (info.previousDurability <= info.durability) {
						info.item.deinit();
					}
				},
			}
		}
		self.baseOperations.deinit(allocator);
		if (side == .server) {
			self.syncOperations.deinit(allocator);
		} else {
			std.debug.assert(self.syncOperations.capacity == 0);
		}

		switch (self.payload) {
			inline else => |payload| {
				if (@hasDecl(@TypeOf(payload), "finalize")) {
					try payload.finalize(side, reader);
				}
			},
		}
	}

	fn confirmationData(self: *Command, allocator: NeverFailingAllocator) []const u8 {
		switch (self.payload) {
			inline else => |payload| {
				if (@hasDecl(@TypeOf(payload), "confirmationData")) {
					return payload.confirmationData(allocator);
				}
			},
		}
		return &.{};
	}

	fn executeAddOperation(self: *Command, allocator: NeverFailingAllocator, side: Side, inv: InventoryAndSlot, amount: u16, item: Item) void {
		if (amount == 0) return;
		if (item == .null) return;
		if (side == .server) {
			self.syncOperations.append(allocator, .{.create = .{
				.inv = inv,
				.amount = amount,
				.item = if (inv.ref().amount == 0) item else .null,
			}});
		}
		std.debug.assert(inv.ref().item == .null or std.meta.eql(inv.ref().item, item));
		inv.ref().item = item;
		inv.ref().amount += amount;
		std.debug.assert(inv.ref().amount <= item.stackSize());
	}

	fn executeRemoveOperation(self: *Command, allocator: NeverFailingAllocator, side: Side, inv: InventoryAndSlot, amount: u16) void {
		if (amount == 0) return;
		if (side == .server) {
			self.syncOperations.append(allocator, .{.delete = .{
				.inv = inv,
				.amount = amount,
			}});
		}
		inv.ref().amount -= amount;
		if (inv.ref().amount == 0) {
			inv.ref().item = .null;
		}
	}

	fn executeDurabilityUseOperation(self: *Command, allocator: NeverFailingAllocator, side: Side, inv: InventoryAndSlot, durability: u31) void {
		if (durability == 0) return;
		if (side == .server) {
			self.syncOperations.append(allocator, .{.useDurability = .{
				.inv = inv,
				.durability = durability,
			}});
		}
		inv.ref().item.tool.durability -|= durability;
		if (inv.ref().item.tool.durability == 0) {
			inv.ref().item = .null;
			inv.ref().amount = 0;
		}
	}

	fn executeBaseOperation(self: *Command, allocator: NeverFailingAllocator, _op: BaseOperation, side: Side) void { // MARK: executeBaseOperation()
		threadContext.assertCorrectContext(side);
		var op = _op;
		switch (op) {
			.move => |info| {
				self.executeAddOperation(allocator, side, info.dest, info.amount, info.source.ref().item);
				self.executeRemoveOperation(allocator, side, info.source, info.amount);
				info.source.inv.update();
				info.dest.inv.update();
			},
			.swap => |info| {
				const oldDestStack = info.dest.ref().*;
				const oldSourceStack = info.source.ref().*;
				self.executeRemoveOperation(allocator, side, info.source, oldSourceStack.amount);
				self.executeRemoveOperation(allocator, side, info.dest, oldDestStack.amount);
				self.executeAddOperation(allocator, side, info.source, oldDestStack.amount, oldDestStack.item);
				self.executeAddOperation(allocator, side, info.dest, oldSourceStack.amount, oldSourceStack.item);
				info.source.inv.update();
				info.dest.inv.update();
			},
			.delete => |*info| {
				info.item = info.source.ref().item;
				self.executeRemoveOperation(allocator, side, info.source, info.amount);
				info.source.inv.update();
			},
			.create => |info| {
				self.executeAddOperation(allocator, side, info.dest, info.amount, info.item);
				info.dest.inv.update();
			},
			.useDurability => |*info| {
				info.item = info.source.ref().item;
				info.previousDurability = info.item.tool.durability;
				self.executeDurabilityUseOperation(allocator, side, info.source, info.durability);
				info.source.inv.update();
			},
			.addHealth => |*info| {
				if (side == .server) {
					info.previous = info.target.?.player.health;

					info.target.?.player.health = std.math.clamp(info.target.?.player.health + info.health, 0, info.target.?.player.maxHealth);

					if (info.target.?.player.health <= 0) {
						info.target.?.player.health = info.target.?.player.maxHealth;
						info.cause.sendMessage(info.target.?.name);

						self.syncOperations.append(allocator, .{.kill = .{
							.target = info.target.?,
							.spawnPoint = info.target.?.spawnPos,
						}});
					} else {
						self.syncOperations.append(allocator, .{.health = .{
							.target = info.target.?,
							.health = info.health,
						}});
					}
				} else {
					info.previous = main.game.Player.super.health;
					main.game.Player.super.health = std.math.clamp(main.game.Player.super.health + info.health, 0, main.game.Player.super.maxHealth);
				}
			},
			.addEnergy => |*info| {
				if (side == .server) {
					info.previous = info.target.?.player.energy;

					info.target.?.player.energy = std.math.clamp(info.target.?.player.energy + info.energy, 0, info.target.?.player.maxEnergy);
					self.syncOperations.append(allocator, .{.energy = .{
						.target = info.target.?,
						.energy = info.energy,
					}});
				} else {
					info.previous = main.game.Player.super.energy;
					main.game.Player.super.energy = std.math.clamp(main.game.Player.super.energy + info.energy, 0, main.game.Player.super.maxEnergy);
				}
			},
		}
		self.baseOperations.append(allocator, op);
	}

	fn removeToolCraftingIngredients(self: *Command, allocator: NeverFailingAllocator, inv: Inventory, side: Side) void {
		std.debug.assert(inv.type == .workbench);
		for (0..25) |i| {
			if (inv._items[i].amount != 0) {
				self.executeBaseOperation(allocator, .{.delete = .{
					.source = .{.inv = inv, .slot = @intCast(i)},
					.amount = 1,
				}}, side);
			}
		}
	}

	fn canPutIntoWorkbench(source: InventoryAndSlot) bool {
		return switch (source.ref().item) {
			.null => true,
			.baseItem => |item| item.material() != null,
			.tool => false,
		};
	}

	pub const Context = struct {
		allocator: NeverFailingAllocator,
		cmd: *Command,
		side: Side,
		user: ?*main.server.User,
		gamemode: Gamemode,

		pub fn execute(self: Context, _op: BaseOperation) void {
			return self.cmd.executeBaseOperation(self.allocator, _op, self.side);
		}
	};

	const Open = struct { // MARK: Open
		inv: Inventory,
		source: Inventory.Source,

		fn run(_: Open, _: Context) error{serverFailure}!void {}

		fn finalize(self: Open, side: Side, reader: *BinaryReader) !void {
			if (side != .client) return;
			if (reader.remaining.len != 0) {
				const serverId = try reader.readEnum(InventoryId);
				Inventory.ClientSide.mapServerId(serverId, self.inv);
			}
		}

		fn confirmationData(self: Open, allocator: NeverFailingAllocator) []const u8 {
			var writer = BinaryWriter.initCapacity(allocator, 4);
			writer.writeEnum(InventoryId, self.inv.id);
			return writer.data.toOwnedSlice();
		}

		fn serialize(self: Open, writer: *BinaryWriter) void {
			writer.writeEnum(InventoryId, self.inv.id);
			writer.writeInt(usize, self.inv._items.len);
			writer.writeEnum(Inventory.TypeEnum, self.inv.type);
			writer.writeEnum(Inventory.SourceType, self.source);
			switch (self.source) {
				.playerInventory, .hand => |val| {
					writer.writeInt(u32, val);
				},
				.blockInventory => |val| {
					writer.writeVec(Vec3i, val);
				},
				.other => {},
				.alreadyFreed => unreachable,
			}
			switch (self.inv.type) {
				.normal => {},
				.workbench => {
					writer.writeSlice(self.inv.type.workbench.id());
				},
			}
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !Open {
			if (side != .server or user == null) return error.Invalid;
			const id = try reader.readEnum(InventoryId);
			const len = try reader.readInt(u64);
			const typeEnum = try reader.readEnum(Inventory.TypeEnum);
			const sourceType = try reader.readEnum(Inventory.SourceType);
			const source: Inventory.Source = switch (sourceType) {
				.playerInventory => .{.playerInventory = try reader.readInt(u32)},
				.hand => .{.hand = try reader.readInt(u32)},
				.blockInventory => .{.blockInventory = try reader.readVec(Vec3i)},
				.other => .{.other = {}},
				.alreadyFreed => return error.Invalid,
			};
			const typ: Inventory.Type = switch (typeEnum) {
				inline .normal => |tag| tag,
				.workbench => .{.workbench = main.items.ToolTypeIndex.fromId(reader.remaining) orelse return error.Invalid},
			};
			try Inventory.ServerSide.createInventory(user.?, id, len, typ, source);
			return .{
				.inv = Inventory.ServerSide.getInventory(user.?, id) orelse return error.InventoryNotFound,
				.source = source,
			};
		}
	};

	const Close = struct { // MARK: Close
		inv: Inventory,
		allocator: NeverFailingAllocator,

		fn run(_: Close, _: Context) error{serverFailure}!void {}

		fn finalize(self: Close, side: Side, reader: *BinaryReader) !void {
			if (side != .client) return;
			self.inv._deinit(self.allocator, .client);
			if (reader.remaining.len != 0) {
				const serverId = try reader.readEnum(InventoryId);
				Inventory.ClientSide.unmapServerId(serverId, self.inv.id);
			}
		}

		fn serialize(self: Close, writer: *BinaryWriter) void {
			writer.writeEnum(InventoryId, self.inv.id);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !Close {
			if (side != .server or user == null) return error.Invalid;
			const id = try reader.readEnum(InventoryId);
			try Inventory.ServerSide.closeInventory(user.?, id);
			return undefined;
		}
	};

	const DepositOrSwap = struct { // MARK: DepositOrSwap
		dest: InventoryAndSlot,
		source: InventoryAndSlot,

		fn run(self: DepositOrSwap, ctx: Context) error{serverFailure}!void {
			std.debug.assert(self.source.inv.type == .normal);
			if (self.dest.inv.type == .workbench and self.dest.slot != 25 and self.dest.inv.type.workbench.slotInfos()[self.dest.slot].disabled) return;
			if (self.dest.inv.type == .workbench and self.dest.slot == 25) {
				if (self.source.ref().item == .null and self.dest.ref().item != .null) {
					ctx.execute(.{.move = .{
						.dest = self.source,
						.source = self.dest,
						.amount = 1,
					}});
					ctx.cmd.removeToolCraftingIngredients(ctx.allocator, self.dest.inv, ctx.side);
				}
				return;
			}
			if (self.dest.inv.type == .workbench and !canPutIntoWorkbench(self.source)) return;

			const itemDest = self.dest.ref().item;
			const itemSource = self.source.ref().item;
			if (itemDest != .null and itemSource != .null) {
				if (std.meta.eql(itemDest, itemSource)) {
					if (self.dest.ref().amount >= itemDest.stackSize()) return;
					const amount = @min(itemDest.stackSize() - self.dest.ref().amount, self.source.ref().amount);
					ctx.execute(.{.move = .{
						.dest = self.dest,
						.source = self.source,
						.amount = amount,
					}});
					return;
				}
			}
			if (self.source.inv.type == .workbench and !canPutIntoWorkbench(self.dest)) return;
			ctx.execute(.{.swap = .{
				.dest = self.dest,
				.source = self.source,
			}});
		}

		fn serialize(self: DepositOrSwap, writer: *BinaryWriter) void {
			self.dest.write(writer);
			self.source.write(writer);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !DepositOrSwap {
			return .{
				.dest = try InventoryAndSlot.read(reader, side, user),
				.source = try InventoryAndSlot.read(reader, side, user),
			};
		}
	};

	const Deposit = struct { // MARK: Deposit
		dest: InventoryAndSlot,
		source: InventoryAndSlot,
		amount: u16,

		fn run(self: Deposit, ctx: Context) error{serverFailure}!void {
			if (self.source.inv.type != .normal and self.dest.inv.type != .normal) return error.serverFailure;
			if (self.dest.inv.type == .workbench and (self.dest.slot == 25 or self.dest.inv.type.workbench.slotInfos()[self.dest.slot].disabled)) return;
			if (self.dest.inv.type == .workbench and !canPutIntoWorkbench(self.source)) return;
			const itemSource = self.source.ref().item;
			if (itemSource == .null) return;
			const itemDest = self.dest.ref().item;
			if (itemDest != .null) {
				if (std.meta.eql(itemDest, itemSource)) {
					if (self.dest.ref().amount >= itemDest.stackSize()) return;
					const amount = @min(itemDest.stackSize() - self.dest.ref().amount, self.source.ref().amount, self.amount);
					ctx.execute(.{.move = .{
						.dest = self.dest,
						.source = self.source,
						.amount = amount,
					}});
				}
			} else {
				const amount = @min(self.amount, self.source.ref().amount);
				ctx.execute(.{.move = .{
					.dest = self.dest,
					.source = self.source,
					.amount = amount,
				}});
			}
		}

		fn serialize(self: Deposit, writer: *BinaryWriter) void {
			self.dest.write(writer);
			self.source.write(writer);
			writer.writeInt(u16, self.amount);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !Deposit {
			return .{
				.dest = try InventoryAndSlot.read(reader, side, user),
				.source = try InventoryAndSlot.read(reader, side, user),
				.amount = try reader.readInt(u16),
			};
		}
	};

	const TakeHalf = struct { // MARK: TakeHalf
		dest: InventoryAndSlot,
		source: InventoryAndSlot,

		fn run(self: TakeHalf, ctx: Context) error{serverFailure}!void {
			std.debug.assert(self.dest.inv.type == .normal);
			if (self.source.inv.type == .workbench and self.source.slot != 25 and self.source.inv.type.workbench.slotInfos()[self.source.slot].disabled) return;
			if (self.source.inv.type == .workbench and self.source.slot == 25) {
				if (self.dest.ref().item == .null and self.source.ref().item != .null) {
					ctx.execute(.{.move = .{
						.dest = self.dest,
						.source = self.source,
						.amount = 1,
					}});
					ctx.cmd.removeToolCraftingIngredients(ctx.allocator, self.source.inv, ctx.side);
				}
				return;
			}
			const itemSource = self.source.ref().item;
			if (itemSource == .null) return;
			const desiredAmount = (1 + self.source.ref().amount)/2;
			const itemDest = self.dest.ref().item;
			if (itemDest != .null) {
				if (std.meta.eql(itemDest, itemSource)) {
					if (self.dest.ref().amount >= itemDest.stackSize()) return;
					const amount = @min(itemDest.stackSize() - self.dest.ref().amount, desiredAmount);
					ctx.execute(.{.move = .{
						.dest = self.dest,
						.source = self.source,
						.amount = amount,
					}});
				}
			} else {
				ctx.execute(.{.move = .{
					.dest = self.dest,
					.source = self.source,
					.amount = desiredAmount,
				}});
			}
		}

		fn serialize(self: TakeHalf, writer: *BinaryWriter) void {
			self.dest.write(writer);
			self.source.write(writer);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !TakeHalf {
			return .{
				.dest = try InventoryAndSlot.read(reader, side, user),
				.source = try InventoryAndSlot.read(reader, side, user),
			};
		}
	};

	const Drop = struct { // MARK: Drop
		source: InventoryAndSlot,
		desiredAmount: u16 = 0xffff,

		fn run(self: Drop, ctx: Context) error{serverFailure}!void {
			if (self.source.ref().item == .null) return;
			if (self.source.inv.type == .workbench and self.source.slot != 25 and self.source.inv.type.workbench.slotInfos()[self.source.slot].disabled) return;
			if (self.source.inv.type == .workbench and self.source.slot == 25) {
				ctx.cmd.removeToolCraftingIngredients(ctx.allocator, self.source.inv, ctx.side);
			}
			const amount = @min(self.source.ref().amount, self.desiredAmount);
			if (ctx.side == .server) {
				const direction = vec.rotateZ(vec.rotateX(Vec3f{0, 1, 0}, -ctx.user.?.player.rot[0]), -ctx.user.?.player.rot[2]);
				main.server.world.?.dropWithCooldown(.{.item = self.source.ref().item.clone(), .amount = amount}, ctx.user.?.player.pos, direction, 20, main.server.updatesPerSec*2);
			}
			ctx.execute(.{.delete = .{
				.source = self.source,
				.amount = amount,
			}});
		}

		fn serialize(self: Drop, writer: *BinaryWriter) void {
			self.source.write(writer);
			if (self.desiredAmount != 0xffff) {
				writer.writeInt(u16, self.desiredAmount);
			}
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !Drop {
			return .{
				.source = try InventoryAndSlot.read(reader, side, user),
				.desiredAmount = reader.readInt(u16) catch 0xffff,
			};
		}
	};

	const FillFromCreative = struct { // MARK: FillFromCreative
		dest: InventoryAndSlot,
		item: Item,
		amount: u16 = 0,

		fn run(self: FillFromCreative, ctx: Context) error{serverFailure}!void {
			if (self.dest.inv.type == .workbench and (self.dest.slot == 25 or self.dest.inv.type.workbench.slotInfos()[self.dest.slot].disabled)) return;
			if (ctx.side == .server and ctx.user != null and ctx.gamemode != .creative) return;
			if (ctx.side == .client and ctx.gamemode != .creative) return;

			if (!self.dest.ref().empty()) {
				ctx.execute(.{.delete = .{
					.source = self.dest,
					.amount = self.dest.ref().amount,
				}});
			}
			if (self.item != .null) {
				ctx.execute(.{.create = .{
					.dest = self.dest,
					.item = self.item,
					.amount = if (self.amount == 0) self.item.stackSize() else self.amount,
				}});
			}
		}

		fn serialize(self: FillFromCreative, writer: *BinaryWriter) void {
			self.dest.write(writer);
			writer.writeInt(u16, self.amount);
			if (self.item != .null) {
				const zon = ZonElement.initObject(main.stackAllocator);
				defer zon.deinit(main.stackAllocator);
				self.item.insertIntoZon(main.stackAllocator, zon);
				const string = zon.toStringEfficient(main.stackAllocator, &.{});
				defer main.stackAllocator.free(string);
				writer.writeSlice(string);
			}
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !FillFromCreative {
			const dest = try InventoryAndSlot.read(reader, side, user);
			const amount = try reader.readInt(u16);
			var item: Item = .null;
			if (reader.remaining.len != 0) {
				const zon = ZonElement.parseFromString(main.stackAllocator, null, reader.remaining);
				defer zon.deinit(main.stackAllocator);
				item = try Item.init(zon);
			}
			return .{
				.dest = dest,
				.item = item,
				.amount = amount,
			};
		}
	};

	const DepositOrDrop = struct { // MARK: DepositOrDrop
		destinations: Inventory.Inventories,
		source: Inventory,
		dropLocation: Vec3d,

		pub fn init(destinations: []const Inventory.ClientInventory, source: Inventory, dropLocation: Vec3d) DepositOrDrop {
			return .{
				.destinations = .initFromClientInventories(main.globalAllocator, destinations),
				.source = source,
				.dropLocation = dropLocation,
			};
		}

		pub fn initWithInventories(destinations: []const Inventory, source: Inventory, dropLocation: Vec3d) DepositOrDrop {
			return .{
				.destinations = .init(main.globalAllocator, destinations),
				.source = source,
				.dropLocation = dropLocation,
			};
		}

		fn finalize(self: DepositOrDrop, _: Side, _: *BinaryReader) !void {
			self.destinations.deinit(main.globalAllocator);
		}

		pub fn run(self: DepositOrDrop, ctx: Context) error{serverFailure}!void {
			for (self.destinations.inventories) |dest| {
				std.debug.assert(dest.type == .normal);
			}
			var sourceItems = self.source._items;
			if (self.source.type == .workbench) sourceItems = self.source._items[0..25];
			for (sourceItems, 0..) |*sourceStack, sourceSlot| {
				if (sourceStack.item == .null) continue;
				const remainingAmount = self.destinations.putItemsInto(ctx, sourceStack.amount, .{.move = .{.inv = self.source, .slot = @intCast(sourceSlot)}});
				if (remainingAmount == 0) continue;
				if (ctx.side == .server) {
					const direction = if (ctx.user) |_user| vec.rotateZ(vec.rotateX(Vec3f{0, 1, 0}, -_user.player.rot[0]), -_user.player.rot[2]) else Vec3f{0, 0, 0};
					main.server.world.?.drop(sourceStack.clone(), self.dropLocation, direction, 20);
				}
				ctx.execute(.{.delete = .{
					.source = .{.inv = self.source, .slot = @intCast(sourceSlot)},
					.amount = self.source._items[sourceSlot].amount,
				}});
			}
		}

		fn serialize(self: DepositOrDrop, writer: *BinaryWriter) void {
			self.destinations.toBytes(writer);
			writer.writeEnum(InventoryId, self.source.id);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !DepositOrDrop {
			const destinations: Inventory.Inventories = try .fromBytes(main.globalAllocator, reader, side, user);
			errdefer destinations.deinit(main.globalAllocator);
			const sourceId = try reader.readEnum(InventoryId);
			return .{
				.destinations = destinations,
				.source = Inventory.getInventory(sourceId, side, user) orelse return error.InventoryNotFound,
				.dropLocation = (user orelse return error.Invalid).player.pos,
			};
		}
	};

	const DepositToAny = struct { // MARK: DepositToAny
		destinations: Inventory.Inventories,
		source: InventoryAndSlot,
		amount: u16,

		pub fn init(destinations: []const Inventory.ClientInventory, source: InventoryAndSlot, amount: u16) DepositToAny {
			return .{
				.destinations = .initFromClientInventories(main.globalAllocator, destinations),
				.source = source,
				.amount = amount,
			};
		}

		fn finalize(self: DepositToAny, _: Side, _: *BinaryReader) !void {
			self.destinations.deinit(main.globalAllocator);
		}

		fn run(self: DepositToAny, ctx: Context) error{serverFailure}!void {
			for (self.destinations.inventories) |dest| {
				if (dest.type != .normal) return;
			}
			const sourceStack = self.source.ref();
			if (sourceStack.item == .null) return;
			if (self.amount > sourceStack.amount) return;

			_ = self.destinations.putItemsInto(ctx, self.amount, .{.move = self.source});
		}

		fn serialize(self: DepositToAny, writer: *BinaryWriter) void {
			self.destinations.toBytes(writer);
			self.source.write(writer);
			writer.writeInt(u16, self.amount);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !DepositToAny {
			const destinations: Inventory.Inventories = try .fromBytes(main.globalAllocator, reader, side, user);
			errdefer destinations.deinit(main.globalAllocator);
			return .{
				.destinations = destinations,
				.source = try InventoryAndSlot.read(reader, side, user),
				.amount = try reader.readInt(u16),
			};
		}
	};

	const CraftFrom = struct { // MARK: CraftFrom
		destinations: Inventory.Inventories,
		sources: Inventory.Inventories,
		recipe: *const main.items.Recipe,

		pub fn init(destinations: []const Inventory.ClientInventory, sources: []const Inventory.ClientInventory, recipe: *const main.items.Recipe) CraftFrom {
			return .{
				.destinations = .initFromClientInventories(main.globalAllocator, destinations),
				.sources = .initFromClientInventories(main.globalAllocator, sources),
				.recipe = recipe,
			};
		}

		fn finalize(self: CraftFrom, _: Side, _: *BinaryReader) !void {
			self.destinations.deinit(main.globalAllocator);
			self.sources.deinit(main.globalAllocator);
		}

		fn run(self: CraftFrom, ctx: Context) error{serverFailure}!void {
			for (self.destinations.inventories) |dest| if (dest.type != .normal) return;
			for (self.sources.inventories) |source| if (source.type != .normal) return;

			if (self.destinations.canHold(.{.item = .{.baseItem = self.recipe.resultItem}, .amount = self.recipe.resultAmount}) != .yes) return;

			// Can we even craft it?
			outer: for (self.recipe.sourceItems) |requiredItem| {
				var amount: usize = 0;
				// There might be duplicate entries:
				for (self.recipe.sourceItems, self.recipe.sourceAmounts) |otherItem, otherAmount| {
					if (requiredItem == otherItem) amount += otherAmount;
				}
				for (self.sources.inventories) |source| {
					for (source._items) |otherStack| {
						if (otherStack.item == .baseItem and requiredItem == otherStack.item.baseItem) {
							amount -|= otherStack.amount;
							if (amount == 0) continue :outer;
						}
					}
				}
				// Not enough ingredients
				if (amount != 0) return;
			}

			for (self.recipe.sourceItems, self.recipe.sourceAmounts) |requiredItem, requiredAmount| {
				self.sources.removeItems(ctx, requiredAmount, requiredItem);
			}

			const remainingAmount = self.destinations.putItemsInto(ctx, self.recipe.resultAmount, .{.create = .{.baseItem = self.recipe.resultItem}});
			std.debug.assert(remainingAmount == 0);
		}

		fn serialize(self: CraftFrom, writer: *BinaryWriter) void {
			self.destinations.toBytes(writer);
			self.sources.toBytes(writer);
			self.recipe.toBytes(writer);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !CraftFrom {
			const destinations = try Inventory.Inventories.fromBytes(main.globalAllocator, reader, side, user);
			errdefer destinations.deinit(main.globalAllocator);
			const sources = try Inventory.Inventories.fromBytes(main.globalAllocator, reader, side, user);
			errdefer sources.deinit(main.globalAllocator);
			const recipe = try main.items.Recipe.fromBytes(reader);
			return .{
				.destinations = destinations,
				.sources = sources,
				.recipe = recipe,
			};
		}
	};

	const Clear = struct { // MARK: Clear
		inv: Inventory,

		pub fn run(self: Clear, ctx: Context) error{serverFailure}!void {
			var items = self.inv._items;
			if (self.inv.type == .workbench) items = self.inv._items[0..25];
			for (items, 0..) |stack, slot| {
				if (stack.item == .null) continue;

				ctx.execute(.{.delete = .{
					.source = .{.inv = self.inv, .slot = @intCast(slot)},
					.amount = stack.amount,
				}});
			}
		}

		fn serialize(self: Clear, writer: *BinaryWriter) void {
			writer.writeEnum(InventoryId, self.inv.id);
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !Clear {
			const invId = try reader.readEnum(InventoryId);
			return .{
				.inv = Inventory.getInventory(invId, side, user) orelse return error.InventoryNotFound,
			};
		}
	};

	const UpdateBlock = struct { // MARK: UpdateBlock
		source: InventoryAndSlot,
		pos: Vec3i,
		dropLocation: BlockDropLocation,
		oldBlock: Block,
		newBlock: Block,

		const half = @as(Vec3f, @splat(0.5));
		const itemHitBoxMargin: f32 = @floatCast(main.itemdrop.ItemDropManager.radius);
		const itemHitBoxMarginVec: Vec3f = @splat(itemHitBoxMargin);

		const BlockDropLocation = struct {
			dir: Neighbor,
			min: Vec3f,
			max: Vec3f,

			pub fn drop(self: BlockDropLocation, pos: Vec3i, newBlock: Block, _drop: main.blocks.BlockDrop) void {
				if (newBlock.collide()) {
					self.dropOutside(pos, _drop);
				} else {
					self.dropInside(pos, _drop);
				}
			}
			fn dropInside(self: BlockDropLocation, pos: Vec3i, _drop: main.blocks.BlockDrop) void {
				for (_drop.items) |itemStack| {
					main.server.world.?.drop(itemStack.clone(), self.insidePos(pos), self.dropDir(), self.dropVelocity());
				}
			}
			fn insidePos(self: BlockDropLocation, _pos: Vec3i) Vec3d {
				const pos: Vec3d = @floatFromInt(_pos);
				return pos + self.randomOffset();
			}
			fn randomOffset(self: BlockDropLocation) Vec3f {
				const max = @min(@as(Vec3f, @splat(1.0)) - itemHitBoxMarginVec, @max(itemHitBoxMarginVec, self.max - itemHitBoxMarginVec));
				const min = @min(max, @max(itemHitBoxMarginVec, self.min + itemHitBoxMarginVec));
				const center = (max + min)*half;
				const width = (max - min)*half;
				return center + width*main.random.nextFloatVectorSigned(3, &main.seed)*half;
			}
			fn dropOutside(self: BlockDropLocation, pos: Vec3i, _drop: main.blocks.BlockDrop) void {
				for (_drop.items) |itemStack| {
					main.server.world.?.drop(itemStack.clone(), self.outsidePos(pos), self.dropDir(), self.dropVelocity());
				}
			}
			fn outsidePos(self: BlockDropLocation, _pos: Vec3i) Vec3d {
				const pos: Vec3d = @floatFromInt(_pos);
				return pos + self.randomOffset()*self.minor() + self.directionOffset()*self.major() + self.direction()*itemHitBoxMarginVec;
			}
			fn directionOffset(self: BlockDropLocation) Vec3d {
				return half + self.direction()*half;
			}
			inline fn direction(self: BlockDropLocation) Vec3d {
				return @floatFromInt(self.dir.relPos());
			}
			inline fn major(self: BlockDropLocation) Vec3d {
				return @floatFromInt(@abs(self.dir.relPos()));
			}
			inline fn minor(self: BlockDropLocation) Vec3d {
				return @floatFromInt(self.dir.orthogonalComponents());
			}
			fn dropDir(self: BlockDropLocation) Vec3f {
				const randomnessVec: Vec3f = main.random.nextFloatVectorSigned(3, &main.seed)*@as(Vec3f, @splat(0.25));
				const directionVec: Vec3f = @as(Vec3f, @floatCast(self.direction())) + randomnessVec;
				const z: f32 = directionVec[2];
				return vec.normalize(Vec3f{
					directionVec[0],
					directionVec[1],
					if (z < -0.5) 0 else if (z < 0.0) (z + 0.5)*4.0 else z + 2.0,
				});
			}
			fn dropVelocity(self: BlockDropLocation) f32 {
				const velocity = 3.5 + main.random.nextFloatSigned(&main.seed)*0.5;
				if (self.direction()[2] < -0.5) return velocity*0.333;
				return velocity;
			}
		};

		fn run(self: UpdateBlock, ctx: Context) error{serverFailure}!void {
			if (self.source.inv.type != .normal) return;

			const stack = self.source.ref();

			var shouldDropSourceBlockOnSuccess: bool = true;
			const costOfChange = if (ctx.gamemode != .creative) self.oldBlock.canBeChangedInto(self.newBlock, stack.*, &shouldDropSourceBlockOnSuccess) else .yes;

			// Check if we can change it:
			if (!switch (costOfChange) {
				.no => false,
				.yes => true,
				.yes_costsDurability => |_| stack.item == .tool,
				.yes_costsItems => |amount| stack.amount >= amount,
			}) {
				if (ctx.side == .server) {
					// Inform the client of the actual block:
					var writer = BinaryWriter.init(main.stackAllocator);
					defer writer.deinit();

					const actualBlock = main.server.world.?.getBlockAndBlockEntityData(self.pos[0], self.pos[1], self.pos[2], &writer) orelse return;
					main.network.protocols.blockUpdate.send(ctx.user.?.conn, &.{.init(self.pos, actualBlock, writer.data.items)});
				}
				return;
			}

			if (ctx.side == .server) {
				if (main.server.world.?.cmpxchgBlock(self.pos[0], self.pos[1], self.pos[2], self.oldBlock, self.newBlock) != null) {
					// Inform the client of the actual block:
					var writer = BinaryWriter.init(main.stackAllocator);
					defer writer.deinit();

					const actualBlock = main.server.world.?.getBlockAndBlockEntityData(self.pos[0], self.pos[1], self.pos[2], &writer) orelse return;
					main.network.protocols.blockUpdate.send(ctx.user.?.conn, &.{.init(self.pos, actualBlock, writer.data.items)});
					return error.serverFailure;
				}
			}

			// Apply inventory changes:
			switch (costOfChange) {
				.no => unreachable,
				.yes => {},
				.yes_costsDurability => |durability| {
					ctx.execute(.{.useDurability = .{
						.source = self.source,
						.durability = durability,
					}});
				},
				.yes_costsItems => |amount| {
					ctx.execute(.{.delete = .{
						.source = self.source,
						.amount = amount,
					}});
				},
			}
			if (ctx.side == .server and ctx.gamemode != .creative and shouldDropSourceBlockOnSuccess) {
				const dropAmount = self.oldBlock.mode().itemDropsOnChange(self.oldBlock, self.newBlock);
				for (0..dropAmount) |_| {
					for (self.oldBlock.blockDrops()) |drop| {
						if (drop.chance == 1 or main.random.nextFloat(&main.seed) < drop.chance) {
							self.dropLocation.drop(self.pos, self.newBlock, drop);
						}
					}
				}
			}
		}

		fn serialize(self: UpdateBlock, writer: *BinaryWriter) void {
			self.source.write(writer);
			writer.writeVec(Vec3i, self.pos);
			writer.writeEnum(Neighbor, self.dropLocation.dir);
			writer.writeVec(Vec3f, self.dropLocation.min);
			writer.writeVec(Vec3f, self.dropLocation.max);
			writer.writeInt(u32, @as(u32, @bitCast(self.oldBlock)));
			writer.writeInt(u32, @as(u32, @bitCast(self.newBlock)));
		}

		fn deserialize(reader: *BinaryReader, side: Side, user: ?*main.server.User) !UpdateBlock {
			return .{
				.source = try InventoryAndSlot.read(reader, side, user),
				.pos = try reader.readVec(Vec3i),
				.dropLocation = .{
					.dir = try reader.readEnum(Neighbor),
					.min = try reader.readVec(Vec3f),
					.max = try reader.readVec(Vec3f),
				},
				.oldBlock = @bitCast(try reader.readInt(u32)),
				.newBlock = @bitCast(try reader.readInt(u32)),
			};
		}
	};

	const AddHealth = struct { // MARK: AddHealth
		target: u32,
		health: f32,
		cause: main.game.DamageType,

		pub fn run(self: AddHealth, ctx: Context) error{serverFailure}!void {
			var target: ?*main.server.User = null;

			if (ctx.side == .server) {
				const userList = main.server.getUserListAndIncreaseRefCount(main.stackAllocator);
				defer main.server.freeUserListAndDecreaseRefCount(main.stackAllocator, userList);
				for (userList) |user| {
					if (user.id == self.target) {
						target = user;
						break;
					}
				}

				if (target == null) return error.serverFailure;

				if (target.?.gamemode.raw == .creative) return;
			} else {
				if (main.game.Player.gamemode.raw == .creative) return;
			}

			ctx.execute(.{.addHealth = .{
				.target = target,
				.health = self.health,
				.cause = self.cause,
				.previous = if (ctx.side == .server) target.?.player.health else main.game.Player.super.health,
			}});
		}

		fn serialize(self: AddHealth, writer: *BinaryWriter) void {
			writer.writeInt(u32, self.target);
			writer.writeInt(u32, @bitCast(self.health));
			writer.writeEnum(main.game.DamageType, self.cause);
		}

		fn deserialize(reader: *BinaryReader, _: Side, user: ?*main.server.User) !AddHealth {
			const result: AddHealth = .{
				.target = try reader.readInt(u32),
				.health = @bitCast(try reader.readInt(u32)),
				.cause = try reader.readEnum(main.game.DamageType),
			};
			if (user.?.id != result.target) return error.Invalid;
			return result;
		}
	};

	const ChatCommand = struct { // MARK: ChatCommand
		message: []const u8,

		fn finalize(self: ChatCommand, _: Side, _: *BinaryReader) !void {
			main.globalAllocator.free(self.message);
		}

		pub fn run(self: ChatCommand, ctx: Context) error{serverFailure}!void {
			if (ctx.side == .server) {
				const user = ctx.user orelse return;
				if (main.server.world.?.settings.allowCheats) {
					std.log.info("User \"{s}\" executed command \"{s}\"", .{user.name, self.message}); // TODO use color \033[0;32m
					main.server.command.execute(self.message, user);
				} else {
					user.sendRawMessage("Commands are not allowed because cheats are disabled");
				}
			}
		}

		fn serialize(self: ChatCommand, writer: *BinaryWriter) void {
			writer.writeVarInt(usize, self.message.len);
			writer.writeSlice(self.message);
		}

		fn deserialize(reader: *BinaryReader, _: Side, _: ?*main.server.User) !ChatCommand {
			const len = try reader.readVarInt(usize);
			return .{
				.message = main.globalAllocator.dupe(u8, try reader.readSlice(len)),
			};
		}
	};
};

pub threadlocal var threadContext: ThreadContext = .other;
pub const ThreadContext = enum { // MARK: ThreadContext
	other,
	server,
	chunkDeiniting,

	pub fn assertCorrectContext(self: ThreadContext, side: Side) void {
		if (@import("builtin").is_test) return;
		switch (side) {
			.server => {
				std.debug.assert(self == .server);
			},
			.client => {},
		}
	}
};

```

`src/tag.zig`:

```zig
const std = @import("std");

const main = @import("main");

var tagList: main.ListUnmanaged([]const u8) = .{};
var tagIds: std.StringHashMapUnmanaged(Tag) = .{};

pub const Tag = enum(u32) {
	air = 0,
	fluid = 1,
	sbbChild = 2,
	fluidPlaceable = 3,
	chiselable = 4,
	_,

	pub fn initTags() void {
		inline for (comptime std.meta.fieldNames(Tag)) |tag| {
			std.debug.assert(Tag.find(tag) == @field(Tag, tag));
		}
	}

	pub fn resetTags() void {
		tagList = .{};
		tagIds = .{};
	}

	pub fn get(tag: []const u8) ?Tag {
		return tagIds.get(tag);
	}

	pub fn find(tag: []const u8) Tag {
		if (tagIds.get(tag)) |res| return res;
		const result: Tag = @enumFromInt(tagList.items.len);
		const dupedTag = main.worldArena.dupe(u8, tag);
		tagList.append(main.worldArena, dupedTag);
		tagIds.put(main.worldArena.allocator, dupedTag, result) catch unreachable;
		return result;
	}

	pub fn loadTagsFromZon(_allocator: main.heap.NeverFailingAllocator, zon: main.ZonElement) []Tag {
		const result = _allocator.alloc(Tag, zon.toSlice().len);
		for (zon.toSlice(), 0..) |tagZon, i| {
			result[i] = Tag.find(tagZon.as([]const u8, "incorrect"));
		}
		return result;
	}

	pub fn getName(tag: Tag) []const u8 {
		return tagList.items[@intFromEnum(tag)];
	}
};

```

`src/tool/modifiers/_list.zig`:

```zig
pub const bad_at = @import("bad_at.zig");
pub const durable = @import("durable.zig");
pub const fragile = @import("fragile.zig");
pub const good_at = @import("good_at.zig");
pub const heavy = @import("heavy.zig");
pub const light = @import("light.zig");
pub const powerful = @import("powerful.zig");
pub const single_use = @import("single_use.zig");
pub const weak = @import("weak.zig");

```

`src/tool/modifiers/bad_at.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, tag: main.Tag, pad: u64 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = std.math.clamp(zon.get(f32, "strength", 0), 0, 1), .tag = .find(zon.get([]const u8, "tag", "incorrect"))};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	if (data1.tag != data2.tag) return null;
	return .{.strength = 1.0 - 1.0/std.math.hypot(1.0/(1.0 - data1.strength), 1.0/(1.0 - data2.strength)), .tag = data1.tag};
}

pub fn changeToolParameters(_: *Tool, _: Data) void {}

pub fn changeBlockDamage(damage: f32, block: main.blocks.Block, data: Data) f32 {
	for (block.blockTags()) |tag| {
		if (tag == data.tag) return damage*(1 - data.strength);
	}
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#a00050**Bad at**#808080 *Decreases damage by **{d:.0}%** on \n***#a00050{s}#808080*** blocks", .{data.strength*100, data.tag.getName()});
}

```

`src/tool/modifiers/durable.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = @max(0, zon.get(f32, "strength", 0))};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = std.math.hypot(data1.strength, data2.strength)};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.maxDurability *= 1 + data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#500090**Durable**#808080 *Increases durability by **{d:.0}%", .{data.strength*100});
}

```

`src/tool/modifiers/fragile.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = std.math.clamp(zon.get(f32, "strength", 0), 0, 1)};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = 1.0 - 1.0/std.math.hypot(1.0/(1.0 - data1.strength), 1.0/(1.0 - data2.strength))};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.maxDurability *= 1 - data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#ccddff**Fragile**#808080 *Decreases durability by **{d:.0}%", .{data.strength*100});
}

```

`src/tool/modifiers/good_at.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, tag: main.Tag, pad: u64 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = @max(0, zon.get(f32, "strength", 0)), .tag = .find(zon.get([]const u8, "tag", "incorrect"))};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	if (data1.tag != data2.tag) return null;
	return .{.strength = std.math.hypot(data1.strength, data2.strength), .tag = data1.tag};
}

pub fn changeToolParameters(_: *Tool, _: Data) void {}

pub fn changeBlockDamage(damage: f32, block: main.blocks.Block, data: Data) f32 {
	for (block.blockTags()) |tag| {
		if (tag == data.tag) return damage*(1 + data.strength);
	}
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#80ff40**Good at**#808080 *Increases damage by **{d:.0}%** on \n***#80ff40{s}#808080*** blocks", .{data.strength*100, data.tag.getName()});
}

```

`src/tool/modifiers/heavy.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = @max(0, zon.get(f32, "strength", 0))};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = std.math.hypot(data1.strength, data2.strength)};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.swingSpeed /= 1 + data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#ffcc30**Heavy**#808080 *Increases swing time by **{d:.0}%", .{data.strength*100});
}

```

`src/tool/modifiers/light.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = std.math.clamp(zon.get(f32, "strength", 0), 0, 1)};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = 1.0 - 1.0/std.math.hypot(1.0/(1.0 - data1.strength), 1.0/(1.0 - data2.strength))};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.swingSpeed /= 1 - data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#9fffde**Light**#808080 *Decreases swing time by **{d:.0}%", .{data.strength*100});
}

```

`src/tool/modifiers/powerful.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = @max(0, zon.get(f32, "strength", 0))};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = std.math.hypot(data1.strength, data2.strength)};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.damage *= 1 + data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#f84a00**Powerful**#808080 *Increases damage by **{d:.0}%", .{data.strength*100});
}

```

`src/tool/modifiers/restrictions/_list.zig`:

```zig
pub const always = @import("always.zig");
pub const @"and" = @import("and.zig");
pub const encased = @import("encased.zig");
pub const not = @import("not.zig");
pub const @"or" = @import("or.zig");

```

`src/tool/modifiers/restrictions/always.zig`:

```zig
const std = @import("std");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const Tool = main.items.Tool;
const ZonElement = main.ZonElement;

pub fn satisfied(_: *const anyopaque, _: *const Tool, _: i32, _: i32) bool {
	return true;
}

pub fn loadFromZon(_: NeverFailingAllocator, _: ZonElement) *const anyopaque {
	return undefined;
}

pub fn printTooltip(_: *const anyopaque, outString: *main.List(u8)) void {
	outString.appendSlice("always");
}

```

`src/tool/modifiers/restrictions/and.zig`:

```zig
const std = @import("std");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ModifierRestriction = main.items.ModifierRestriction;
const Tool = main.items.Tool;
const ZonElement = main.ZonElement;

const And = struct {
	children: []ModifierRestriction,
};

pub fn satisfied(self: *const And, tool: *const Tool, x: i32, y: i32) bool {
	for (self.children) |child| {
		if (!child.satisfied(tool, x, y)) return false;
	}
	return true;
}

pub fn loadFromZon(allocator: NeverFailingAllocator, zon: ZonElement) *const And {
	const result = allocator.create(And);
	const childrenZon = zon.getChild("children").toSlice();
	result.children = allocator.alloc(ModifierRestriction, childrenZon.len);
	for (result.children, childrenZon) |*child, childZon| {
		child.* = ModifierRestriction.loadFromZon(allocator, childZon);
	}
	return result;
}

pub fn printTooltip(self: *const And, outString: *main.List(u8)) void {
	outString.append('(');
	for (self.children, 0..) |child, i| {
		if (i != 0) outString.appendSlice(" and ");
		child.printTooltip(outString);
	}
	outString.append(')');
}

```

`src/tool/modifiers/restrictions/encased.zig`:

```zig
const std = @import("std");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ModifierRestriction = main.items.ModifierRestriction;
const Tool = main.items.Tool;
const ZonElement = main.ZonElement;

const Encased = struct {
	tag: main.Tag,
	amount: usize,
};

pub fn satisfied(self: *const Encased, tool: *const Tool, x: i32, y: i32) bool {
	var count: usize = 0;
	for ([_]i32{-1, 0, 1}) |dx| {
		for ([_]i32{-1, 0, 1}) |dy| {
			if ((tool.getItemAt(x + dx, y + dy) orelse continue).hasTag(self.tag)) count += 1;
		}
	}
	return count >= self.amount;
}

pub fn loadFromZon(allocator: NeverFailingAllocator, zon: ZonElement) *const Encased {
	const result = allocator.create(Encased);
	result.* = .{
		.tag = main.Tag.find(zon.get([]const u8, "tag", "not specified")),
		.amount = zon.get(usize, "amount", 8),
	};
	return result;
}

pub fn printTooltip(self: *const Encased, outString: *main.List(u8)) void {
	outString.print("encased in {} .{s}", .{self.amount, self.tag.getName()});
}

```

`src/tool/modifiers/restrictions/not.zig`:

```zig
const std = @import("std");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ModifierRestriction = main.items.ModifierRestriction;
const Tool = main.items.Tool;
const ZonElement = main.ZonElement;

const Not = struct {
	child: ModifierRestriction,
};

pub fn satisfied(self: *const Not, tool: *const Tool, x: i32, y: i32) bool {
	return !self.child.satisfied(tool, x, y);
}

pub fn loadFromZon(allocator: NeverFailingAllocator, zon: ZonElement) *const Not {
	const result = allocator.create(Not);
	result.* = .{
		.child = ModifierRestriction.loadFromZon(allocator, zon.getChild("child")),
	};
	return result;
}

pub fn printTooltip(self: *const Not, outString: *main.List(u8)) void {
	outString.appendSlice("not ");
	self.child.printTooltip(outString);
}

```

`src/tool/modifiers/restrictions/or.zig`:

```zig
const std = @import("std");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ModifierRestriction = main.items.ModifierRestriction;
const Tool = main.items.Tool;
const ZonElement = main.ZonElement;

const Or = struct {
	children: []ModifierRestriction,
};

pub fn satisfied(self: *const Or, tool: *const Tool, x: i32, y: i32) bool {
	for (self.children) |child| {
		if (child.satisfied(tool, x, y)) return true;
	}
	return false;
}

pub fn loadFromZon(allocator: NeverFailingAllocator, zon: ZonElement) *const Or {
	const result = allocator.create(Or);
	const childrenZon = zon.getChild("children").toSlice();
	result.children = allocator.alloc(ModifierRestriction, childrenZon.len);
	for (result.children, childrenZon) |*child, childZon| {
		child.* = ModifierRestriction.loadFromZon(allocator, childZon);
	}
	return result;
}

pub fn printTooltip(self: *const Or, outString: *main.List(u8)) void {
	outString.append('(');
	for (self.children, 0..) |child, i| {
		if (i != 0) outString.appendSlice(" or ");
		child.printTooltip(outString);
	}
	outString.append(')');
}

```

`src/tool/modifiers/single_use.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1000;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = @max(1, zon.get(f32, "strength", 1))};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = @min(data1.strength, data2.strength)};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.maxDurability = data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#800000**Single-use**#808080 *Sets durability to **{d:.0}", .{data.strength});
}

```

`src/tool/modifiers/weak.zig`:

```zig
const std = @import("std");

const main = @import("main");
const Tool = main.items.Tool;

pub const Data = packed struct(u128) { strength: f32, pad: u96 = undefined };

pub const priority = 1;

pub fn loadData(zon: main.ZonElement) Data {
	return .{.strength = std.math.clamp(zon.get(f32, "strength", 0), 0, 1)};
}

pub fn combineModifiers(data1: Data, data2: Data) ?Data {
	return .{.strength = 1.0 - 1.0/std.math.hypot(1.0/(1.0 - data1.strength), 1.0/(1.0 - data2.strength))};
}

pub fn changeToolParameters(tool: *Tool, data: Data) void {
	tool.damage *= 1 - data.strength;
}

pub fn changeBlockDamage(damage: f32, _: main.blocks.Block, _: Data) f32 {
	return damage;
}

pub fn printTooltip(outString: *main.List(u8), data: Data) void {
	outString.print("#fcb5e3**Weak**#808080 *Decreases damage by **{d:.0}%", .{data.strength*100});
}

```

`src/utils.zig`:

```zig
const std = @import("std");
const Allocator = std.mem.Allocator;
const Atomic = std.atomic.Value;
const builtin = @import("builtin");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

pub const file_monitor = @import("utils/file_monitor.zig");
pub const VirtualList = @import("utils/virtual_mem.zig").VirtualList;

pub const Compression = struct { // MARK: Compression
	pub fn deflate(allocator: NeverFailingAllocator, data: []const u8, level: std.compress.flate.Compress.Options) []u8 {
		var result = std.Io.Writer.Allocating.initCapacity(allocator.allocator, 16) catch unreachable;
		var buffer: [65536]u8 = undefined;
		var compress = std.compress.flate.Compress.init(&result.writer, &buffer, .raw, level) catch unreachable;
		compress.writer.writeAll(data) catch unreachable;
		compress.writer.flush() catch unreachable;
		result.writer.flush() catch unreachable;
		return result.toOwnedSlice() catch unreachable;
	}

	pub fn inflateTo(buf: []u8, data: []const u8) !usize {
		var reader = std.Io.Reader.fixed(data);
		var buffer: [65536]u8 = undefined;
		var decompressor = std.compress.flate.Decompress.init(&reader, .raw, &buffer);
		return try decompressor.reader.readSliceShort(buf);
	}

	pub fn pack(sourceDir: main.files.Dir, writer: *std.Io.Writer) !void {
		var buffer: [65536]u8 = undefined;
		var comp = try std.compress.flate.Compress.init(writer, &buffer, .raw, .default);
		var walker = sourceDir.walk(main.stackAllocator);
		defer walker.deinit();

		while (try walker.next()) |entry| {
			if (entry.kind == .file) {
				var relPath: []const u8 = entry.path;
				if (builtin.os.tag == .windows) { // I hate you
					const copy = main.stackAllocator.dupe(u8, relPath);
					std.mem.replaceScalar(u8, copy, '\\', '/');
					relPath = copy;
				}
				defer if (builtin.os.tag == .windows) {
					main.stackAllocator.free(relPath);
				};
				var len: [4]u8 = undefined;
				std.mem.writeInt(u32, &len, @as(u32, @intCast(relPath.len)), endian);
				_ = try comp.writer.write(&len);
				_ = try comp.writer.write(relPath);

				const fileData = try sourceDir.read(main.stackAllocator, relPath);
				defer main.stackAllocator.free(fileData);

				std.mem.writeInt(u32, &len, @as(u32, @intCast(fileData.len)), endian);
				_ = try comp.writer.write(&len);
				_ = try comp.writer.write(fileData);
			}
		}
		try comp.writer.flush();
		try writer.flush();
	}

	pub fn unpack(outDir: main.files.Dir, input: []const u8) !void {
		var inputReader = std.Io.Reader.fixed(input);
		var buffer: [65536]u8 = undefined;
		var decompressor = std.compress.flate.Decompress.init(&inputReader, .raw, &buffer);
		const reader = &decompressor.reader;
		const _data = try reader.allocRemainingAlignedSentinel(main.stackAllocator.allocator, .unlimited, .@"1", null);
		defer main.stackAllocator.free(_data);
		var data = _data;
		while (data.len != 0) {
			var len = std.mem.readInt(u32, data[0..4], endian);
			data = data[4..];
			const path = data[0..len];
			data = data[len..];
			len = std.mem.readInt(u32, data[0..4], endian);
			data = data[4..];
			const fileData = data[0..len];
			data = data[len..];

			var splitter = std.mem.splitBackwardsScalar(u8, path, '/');
			_ = splitter.first();
			try outDir.makePath(splitter.rest());
			try outDir.write(path, fileData);
		}
	}
};

/// Implementation of https://en.wikipedia.org/wiki/Alias_method
pub fn AliasTable(comptime T: type) type { // MARK: AliasTable
	return struct {
		const AliasData = struct {
			chance: u16,
			alias: u16,
		};
		items: []T,
		aliasData: []AliasData,
		ownsSlice: bool = false,

		fn initAliasData(self: *@This(), totalChance: f32, currentChances: []f32) void {
			const desiredChance = totalChance/@as(f32, @floatFromInt(self.aliasData.len));

			var lastOverfullIndex: u16 = 0;
			var lastUnderfullIndex: u16 = 0;
			outer: while (true) {
				while (currentChances[lastOverfullIndex] <= desiredChance) {
					lastOverfullIndex += 1;
					if (lastOverfullIndex == self.items.len)
						break :outer;
				}
				while (currentChances[lastUnderfullIndex] >= desiredChance) {
					lastUnderfullIndex += 1;
					if (lastUnderfullIndex == self.items.len)
						break :outer;
				}
				const delta = desiredChance - currentChances[lastUnderfullIndex];
				currentChances[lastUnderfullIndex] = desiredChance;
				currentChances[lastOverfullIndex] -= delta;
				self.aliasData[lastUnderfullIndex] = .{
					.alias = lastOverfullIndex,
					.chance = @intFromFloat(delta/desiredChance*std.math.maxInt(u16)),
				};
				if (currentChances[lastOverfullIndex] < desiredChance) {
					lastUnderfullIndex = @min(lastUnderfullIndex, lastOverfullIndex);
				}
			}
		}

		pub fn init(allocator: NeverFailingAllocator, items: []T) @This() {
			var self: @This() = .{
				.items = items,
				.aliasData = allocator.alloc(AliasData, items.len),
			};
			if (items.len == 0) return self;
			@memset(self.aliasData, AliasData{.chance = 0, .alias = 0});
			const currentChances = main.stackAllocator.alloc(f32, items.len);
			defer main.stackAllocator.free(currentChances);
			var totalChance: f32 = 0;
			for (items, 0..) |*item, i| {
				totalChance += item.chance;
				currentChances[i] = item.chance;
			}

			self.initAliasData(totalChance, currentChances);

			return self;
		}

		pub fn initFromContext(allocator: NeverFailingAllocator, slice: anytype) @This() {
			const items = allocator.alloc(T, slice.len);
			for (slice, items) |context, *result| {
				result.* = context.getItem();
			}
			var self: @This() = .{
				.items = items,
				.aliasData = allocator.alloc(AliasData, items.len),
				.ownsSlice = true,
			};
			if (items.len == 0) return self;
			@memset(self.aliasData, AliasData{.chance = 0, .alias = 0});
			const currentChances = main.stackAllocator.alloc(f32, items.len);
			defer main.stackAllocator.free(currentChances);
			var totalChance: f32 = 0;
			for (slice, 0..) |context, i| {
				totalChance += context.chance;
				currentChances[i] = context.chance;
			}

			self.initAliasData(totalChance, currentChances);

			return self;
		}

		pub fn deinit(self: *const @This(), allocator: NeverFailingAllocator) void {
			allocator.free(self.aliasData);
			if (self.ownsSlice) {
				allocator.free(self.items);
			}
		}

		pub fn sample(self: *const @This(), seed: *u64) *T {
			const initialIndex = main.random.nextIntBounded(u16, seed, @as(u16, @intCast(self.items.len)));
			if (main.random.nextInt(u16, seed) < self.aliasData[initialIndex].chance) {
				return &self.items[self.aliasData[initialIndex].alias];
			}
			return &self.items[initialIndex];
		}
	};
}

/// A list that is always sorted in ascending order based on T.lessThan(lhs, rhs).
pub fn SortedList(comptime T: type) type { // MARK: SortedList
	return struct {
		const Self = @This();

		ptr: [*]T = undefined,
		len: u32 = 0,
		capacity: u32 = 0,

		pub fn deinit(self: Self, allocator: NeverFailingAllocator) void {
			allocator.free(self.ptr[0..self.capacity]);
		}

		pub fn items(self: Self) []T {
			return self.ptr[0..self.len];
		}

		fn increaseCapacity(self: *Self, allocator: NeverFailingAllocator) void {
			const newSize = 8 + self.capacity*3/2;
			const newSlice = allocator.realloc(self.ptr[0..self.capacity], newSize);
			self.capacity = @intCast(newSlice.len);
			self.ptr = newSlice.ptr;
		}

		pub fn insertSorted(self: *Self, allocator: NeverFailingAllocator, object: T) void {
			if (self.len == self.capacity) {
				self.increaseCapacity(allocator);
			}
			var i = self.len;
			while (i != 0) { // Find the point to insert and move the rest out of the way.
				if (object.lessThan(self.ptr[i - 1])) {
					self.ptr[i] = self.ptr[i - 1];
				} else {
					break;
				}
				i -= 1;
			}
			self.len += 1;
			self.ptr[i] = object;
		}

		pub fn toOwnedSlice(self: *Self, allocator: NeverFailingAllocator) []T {
			const output = allocator.realloc(self.ptr[0..self.capacity], self.len);
			self.* = .{};
			return output;
		}
	};
}

pub fn Array2D(comptime T: type) type { // MARK: Array2D
	return struct {
		const Self = @This();
		mem: []T,
		width: u32,
		height: u32,

		pub fn init(allocator: NeverFailingAllocator, width: u32, height: u32) Self {
			return .{
				.mem = allocator.alloc(T, width*height),
				.width = width,
				.height = height,
			};
		}

		pub fn deinit(self: Self, allocator: NeverFailingAllocator) void {
			allocator.free(self.mem);
		}

		pub fn get(self: Self, x: usize, y: usize) T {
			std.debug.assert(x < self.width and y < self.height);
			return self.mem[x*self.height + y];
		}

		pub fn getRow(self: Self, x: usize) []T {
			std.debug.assert(x < self.width);
			return self.mem[x*self.height ..][0..self.height];
		}

		pub fn set(self: Self, x: usize, y: usize, t: T) void {
			std.debug.assert(x < self.width and y < self.height);
			self.mem[x*self.height + y] = t;
		}

		pub fn ptr(self: Self, x: usize, y: usize) *T {
			std.debug.assert(x < self.width and y < self.height);
			return &self.mem[x*self.height + y];
		}
	};
}

pub fn Array3D(comptime T: type) type { // MARK: Array3D
	return struct {
		const Self = @This();
		mem: []T,
		width: u32,
		depth: u32,
		height: u32,

		pub fn init(allocator: NeverFailingAllocator, width: u32, depth: u32, height: u32) Self {
			return .{
				.mem = allocator.alloc(T, width*height*depth),
				.width = width,
				.depth = depth,
				.height = height,
			};
		}

		pub fn deinit(self: Self, allocator: NeverFailingAllocator) void {
			allocator.free(self.mem);
		}

		pub fn get(self: Self, x: usize, y: usize, z: usize) T {
			std.debug.assert(x < self.width and y < self.depth and z < self.height);
			return self.mem[(x*self.depth + y)*self.height + z];
		}

		pub fn set(self: Self, x: usize, y: usize, z: usize, t: T) void {
			std.debug.assert(x < self.width and y < self.depth and z < self.height);
			self.mem[(x*self.depth + y)*self.height + z] = t;
		}

		pub fn ptr(self: Self, x: usize, y: usize, z: usize) *T {
			std.debug.assert(x < self.width and y < self.depth and z < self.height);
			return &self.mem[(x*self.depth + y)*self.height + z];
		}

		pub fn clone(self: Self, allocator: NeverFailingAllocator) Self {
			const new = Self.init(allocator, self.width, self.depth, self.height);
			@memcpy(new.mem, self.mem);
			return new;
		}
	};
}

pub fn FixedSizeCircularBuffer(T: type, capacity: comptime_int) type { // MARK: FixedSizeCircularBuffer
	std.debug.assert(capacity - 1 & capacity == 0 and capacity > 0);
	const mask = capacity - 1;
	return struct {
		const Self = @This();
		mem: *[capacity]T = undefined,
		startIndex: usize = 0,
		len: usize = 0,

		pub fn init(allocator: NeverFailingAllocator) Self {
			return .{
				.mem = allocator.create([capacity]T),
			};
		}

		pub fn deinit(self: Self, allocator: NeverFailingAllocator) void {
			allocator.destroy(self.mem);
		}

		pub fn peekBack(self: Self) ?T {
			if (self.len == 0) return null;
			return self.mem[self.startIndex + self.len - 1 & mask];
		}

		pub fn peekFront(self: Self) ?T {
			if (self.len == 0) return null;
			return self.mem[self.startIndex];
		}

		pub fn pushBack(self: *Self, elem: T) !void {
			if (self.len >= capacity) return error.OutOfMemory;
			self.pushBackAssumeCapacity(elem);
		}

		pub fn forcePushBack(self: *Self, elem: T) ?T {
			const result = if (self.len >= capacity) self.popFront() else null;
			self.pushBackAssumeCapacity(elem);
			return result;
		}

		pub fn pushBackAssumeCapacity(self: *Self, elem: T) void {
			self.mem[self.startIndex + self.len & mask] = elem;
			self.len += 1;
		}

		pub fn pushFront(self: *Self, elem: T) !void {
			if (self.len >= capacity) return error.OutOfMemory;
			self.pushFrontAssumeCapacity(elem);
		}

		pub fn pushFrontAssumeCapacity(self: *Self, elem: T) void {
			self.startIndex = (self.startIndex -% 1) & mask;
			self.mem[self.startIndex] = elem;
			self.len += 1;
		}

		pub fn forcePushFront(self: *Self, elem: T) ?T {
			const result = if (self.len >= capacity) self.popBack() else null;
			self.pushFrontAssumeCapacity(elem);
			return result;
		}

		pub fn pushBackSlice(self: *Self, elems: []const T) !void {
			if (elems.len + self.len > capacity) {
				return error.OutOfMemory;
			}
			const start = self.startIndex + self.len & mask;
			const end = start + elems.len;
			if (end < self.mem.len) {
				@memcpy(self.mem[start..end], elems);
			} else {
				const mid = self.mem.len - start;
				@memcpy(self.mem[start..], elems[0..mid]);
				@memcpy(self.mem[0 .. end & mask], elems[mid..]);
			}
			self.len += elems.len;
		}

		pub fn insertSliceAtOffset(self: *Self, elems: []const T, offset: usize) !void {
			if (offset + elems.len > capacity) {
				return error.OutOfMemory;
			}
			self.len = @max(self.len, offset + elems.len);
			const start = self.startIndex + offset & mask;
			const end = start + elems.len;
			if (end < self.mem.len) {
				@memcpy(self.mem[start..end], elems);
			} else {
				const mid = self.mem.len - start;
				@memcpy(self.mem[start..], elems[0..mid]);
				@memcpy(self.mem[0 .. end & mask], elems[mid..]);
			}
		}

		pub fn popBack(self: *Self) ?T {
			if (self.len == 0) return null;
			self.len -= 1;
			return self.mem[self.startIndex + self.len & mask];
		}

		pub fn popFront(self: *Self) ?T {
			if (self.len == 0) return null;
			const result = self.mem[self.startIndex];
			self.startIndex = (self.startIndex + 1) & mask;
			self.len -= 1;
			return result;
		}

		pub fn popSliceFront(self: *Self, out: []T) !void {
			if (out.len > self.len) return error.OutOfBounds;
			const start = self.startIndex;
			const end = start + out.len;
			if (end < self.mem.len) {
				@memcpy(out, self.mem[start..end]);
			} else {
				const mid = self.mem.len - start;
				@memcpy(out[0..mid], self.mem[start..]);
				@memcpy(out[mid..], self.mem[0 .. end & mask]);
			}
			self.startIndex = self.startIndex + out.len & mask;
			self.len -= out.len;
		}

		pub fn discardElementsFront(self: *Self, n: usize) void {
			self.len -= n;
			self.startIndex = (self.startIndex + n) & mask;
		}

		pub fn getAtOffset(self: Self, i: usize) ?T {
			if (i >= self.len) return null;
			return self.mem[(self.startIndex + i) & mask];
		}
	};
}

pub fn CircularBufferQueue(comptime T: type) type { // MARK: CircularBufferQueue
	return struct {
		const Self = @This();
		mem: []T,
		mask: usize,
		startIndex: usize,
		len: usize,
		allocator: NeverFailingAllocator,

		pub fn init(allocator: NeverFailingAllocator, initialCapacity: usize) Self {
			comptime std.debug.assert(@sizeOf(Self) <= 64);
			std.debug.assert(initialCapacity - 1 & initialCapacity == 0 and initialCapacity > 0);
			return .{
				.mem = allocator.alloc(T, initialCapacity),
				.mask = initialCapacity - 1,
				.startIndex = 0,
				.len = 0,
				.allocator = allocator,
			};
		}

		pub fn deinit(self: Self) void {
			self.allocator.free(self.mem);
		}

		pub fn reset(self: *Self) void {
			self.len = 0;
		}

		fn increaseCapacity(self: *Self) void {
			const newMem = self.allocator.alloc(T, self.mem.len*2);
			@memcpy(newMem[0..(self.mem.len - self.startIndex)], self.mem[self.startIndex..]);
			@memcpy(newMem[(self.mem.len - self.startIndex)..][0..self.startIndex], self.mem[0..self.startIndex]);
			self.startIndex = 0;
			self.allocator.free(self.mem);
			self.mem = newMem;
			self.mask = self.mem.len - 1;
		}

		pub fn pushBack(self: *Self, elem: T) void {
			if (self.len == self.mem.len) {
				self.increaseCapacity();
			}
			self.mem[self.startIndex + self.len & self.mask] = elem;
			self.len += 1;
		}

		pub fn pushBackSlice(self: *Self, elems: []const T) void {
			while (elems.len + self.len > self.mem.len) {
				self.increaseCapacity();
			}
			const start = self.startIndex + self.len & self.mask;
			const end = start + elems.len;
			if (end < self.mem.len) {
				@memcpy(self.mem[start..end], elems);
			} else {
				const mid = self.mem.len - start;
				@memcpy(self.mem[start..], elems[0..mid]);
				@memcpy(self.mem[0 .. end & self.mask], elems[mid..]);
			}
			self.len += elems.len;
		}

		pub fn pushFront(self: *Self, elem: T) void {
			if (self.len == self.mem.len) {
				self.increaseCapacity();
			}
			self.startIndex = (self.startIndex -% 1) & self.mask;
			self.mem[self.startIndex] = elem;
			self.len += 1;
		}

		pub fn popFront(self: *Self) ?T {
			if (self.isEmpty()) return null;
			const result = self.mem[self.startIndex];
			self.startIndex = (self.startIndex + 1) & self.mask;
			self.len -= 1;
			return result;
		}

		pub fn popBack(self: *Self) ?T {
			if (self.isEmpty()) return null;
			self.len -= 1;
			return self.mem[self.startIndex + self.len & self.mask];
		}

		pub fn discardFront(self: *Self, amount: usize) !void {
			if (amount > self.len) return error.OutOfBounds;
			self.startIndex = (self.startIndex + amount) & self.mask;
			self.len -= amount;
		}

		pub fn peekFront(self: *Self) ?T {
			if (self.isEmpty()) return null;
			return self.mem[self.startIndex];
		}

		pub fn getSliceAtOffset(self: Self, offset: usize, result: []T) !void {
			if (offset + result.len > self.len) return error.OutOfBounds;
			const start = self.startIndex + offset & self.mask;
			const end = start + result.len;
			if (end < self.mem.len) {
				@memcpy(result, self.mem[start..end]);
			} else {
				const mid = self.mem.len - start;
				@memcpy(result[0..mid], self.mem[start..]);
				@memcpy(result[mid..], self.mem[0 .. end & self.mask]);
			}
		}

		pub fn getAtOffset(self: Self, offset: usize) !T {
			if (offset >= self.len) return error.OutOfBounds;
			return self.mem[(self.startIndex + offset) & self.mask];
		}

		pub fn isEmpty(self: *Self) bool {
			return self.len == 0;
		}

		pub fn reachedCapacity(self: *Self) bool {
			return self.len == self.mem.len;
		}
	};
}

/// Basically just a regular queue with a mutex. TODO: Find a good lock-free implementation.
pub fn ConcurrentQueue(comptime T: type) type { // MARK: ConcurrentQueue
	return struct {
		const Self = @This();
		super: CircularBufferQueue(T),
		mutex: std.Thread.Mutex = .{},

		pub fn init(allocator: NeverFailingAllocator, initialCapacity: usize) Self {
			return .{
				.super = .init(allocator, initialCapacity),
			};
		}

		pub fn deinit(self: Self) void {
			self.super.deinit();
		}

		pub fn pushBack(self: *Self, elem: T) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			self.super.pushBack(elem);
		}

		pub fn popFront(self: *Self) ?T {
			self.mutex.lock();
			defer self.mutex.unlock();
			return self.super.popFront();
		}

		pub fn isEmpty(self: *Self) bool {
			self.mutex.lock();
			defer self.mutex.unlock();
			return self.super.isEmpty();
		}
	};
}

/// A simple binary heap.
/// Thread safe.
/// Expects T to have a `biggerThan(T) bool` function
pub fn ConcurrentMaxHeap(comptime T: type) type { // MARK: ConcurrentMaxHeap
	return struct {
		const initialSize = 16;
		size: usize,
		array: []T,
		mutex: std.Thread.Mutex = .{},
		allocator: NeverFailingAllocator,

		pub fn init(allocator: NeverFailingAllocator) @This() {
			return .{
				.size = 0,
				.array = allocator.alloc(T, initialSize),
				.allocator = allocator,
			};
		}

		pub fn deinit(self: *@This()) void {
			self.allocator.free(self.array);
			self.* = undefined;
		}

		/// Moves an element from a given index down the heap, such that all children are always smaller than their parents.
		fn siftDown(self: *@This(), _i: usize) void {
			assertLocked(&self.mutex);
			var i = _i;
			while (2*i + 1 < self.size) {
				const biggest = if (2*i + 2 < self.size and self.array[2*i + 2].biggerThan(self.array[2*i + 1])) 2*i + 2 else 2*i + 1;
				// Break if all childs are smaller.
				if (self.array[i].biggerThan(self.array[biggest])) return;
				// Swap it:
				const local = self.array[biggest];
				self.array[biggest] = self.array[i];
				self.array[i] = local;
				// goto the next node:
				i = biggest;
			}
		}

		/// Moves an element from a given index up the heap, such that all children are always smaller than their parents.
		fn siftUp(self: *@This(), _i: usize) void {
			assertLocked(&self.mutex);
			var i = _i;
			while (i > 0) {
				const parentIndex = (i - 1)/2;
				if (!self.array[i].biggerThan(self.array[parentIndex])) break;
				const local = self.array[parentIndex];
				self.array[parentIndex] = self.array[i];
				self.array[i] = local;
				i = parentIndex;
			}
		}

		/// Needs to be called after updating the priority of all elements.
		pub fn updatePriority(self: *@This()) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			for (0..self.size) |i| {
				self.siftUp(i);
			}
		}

		/// Returns the i-th element in the heap. Useless for most applications.
		pub fn get(self: *@This(), i: usize) ?T {
			assertLocked(&self.mutex);
			if (i >= self.size) return null;
			return self.array[i];
		}

		/// Adds a new element to the heap.
		pub fn add(self: *@This(), elem: T) void {
			self.mutex.lock();
			defer self.mutex.unlock();

			if (self.size == self.array.len) {
				self.increaseCapacity(self.size*2);
			}
			self.array[self.size] = elem;
			self.siftUp(self.size);
			self.size += 1;
		}

		pub fn addMany(self: *@This(), elems: []const T) void {
			self.mutex.lock();
			defer self.mutex.unlock();

			if (self.size + elems.len > self.array.len) {
				self.increaseCapacity(self.size*2 + elems.len);
			}
			for (elems) |elem| {
				self.array[self.size] = elem;
				self.siftUp(self.size);
				self.size += 1;
			}
		}

		fn removeIndex(self: *@This(), i: usize) void {
			assertLocked(&self.mutex);
			self.size -= 1;
			self.array[i] = self.array[self.size];
			self.siftDown(i);
		}

		/// Returns the biggest element and removes it from the heap.
		/// If empty blocks until a new object is added or the datastructure is closed.
		pub fn extractMax(self: *@This()) ?T {
			self.mutex.lock();
			defer self.mutex.unlock();
			if (self.size == 0) return null;
			const ret = self.array[0];
			self.removeIndex(0);
			return ret;
		}

		pub fn extractAny(self: *@This()) ?T {
			self.mutex.lock();
			defer self.mutex.unlock();
			if (self.size == 0) return null;
			self.size -= 1;
			return self.array[self.size];
		}

		fn increaseCapacity(self: *@This(), newCapacity: usize) void {
			self.array = self.allocator.realloc(self.array, newCapacity);
		}
	};
}

pub const ThreadPool = struct { // MARK: ThreadPool
	pub const TaskType = enum(usize) {
		chunkgen,
		meshgenAndLighting,
		misc,
		taskPriorityUpdate,
	};
	pub const taskTypes = std.enums.directEnumArrayLen(TaskType, 0);
	pub const Task = struct {
		cachedPriority: f32,
		self: *anyopaque,
		vtable: *const VTable,

		fn biggerThan(self: Task, other: Task) bool {
			return self.cachedPriority > other.cachedPriority;
		}
	};
	pub const VTable = struct {
		getPriority: *const fn (*anyopaque) f32,
		isStillNeeded: *const fn (*anyopaque) bool,
		run: *const fn (*anyopaque) void,
		clean: *const fn (*anyopaque) void,
		taskType: TaskType = .misc,
	};
	pub const Performance = struct {
		mutex: std.Thread.Mutex = .{},
		tasks: [taskTypes]u32 = undefined,
		utime: [taskTypes]i64 = undefined,

		pub fn add(self: *Performance, task: TaskType, time: i64) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			const i = @intFromEnum(task);
			self.tasks[i] += 1;
			self.utime[i] += time;
		}

		pub fn clear(self: *Performance) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			for (0..taskTypes) |i| {
				self.tasks[i] = 0;
				self.utime[i] = 0;
			}
		}

		pub fn read(self: *Performance) Performance {
			self.mutex.lock();
			defer self.mutex.unlock();
			return self.*;
		}
	};
	const refreshTime: std.Io.Duration = .fromMilliseconds(100); // The time after which all priorities get refreshed.

	threads: []std.Thread,
	currentTasks: []Atomic(?*const VTable),
	loadList: ConcurrentMaxHeap(Task),
	playerJobQueue: ConcurrentQueue(*main.server.User),
	semaphore: std.Thread.Semaphore = .{},
	allocator: NeverFailingAllocator,
	running: Atomic(bool) = .init(true),

	performance: Performance,

	trueQueueSize: Atomic(usize) = .init(0),

	pub fn init(allocator: NeverFailingAllocator, threadCount: usize) *ThreadPool {
		const self = allocator.create(ThreadPool);
		self.* = .{
			.threads = allocator.alloc(std.Thread, threadCount),
			.currentTasks = allocator.alloc(Atomic(?*const VTable), threadCount),
			.loadList = .init(allocator),
			.playerJobQueue = .init(allocator, 1024),
			.performance = .{},
			.allocator = allocator,
		};
		self.performance.clear();
		for (self.threads, 0..) |*thread, i| {
			thread.* = std.Thread.spawn(.{}, run, .{self, i}) catch |err| {
				std.log.err("Could not spawn Thread due to {s}", .{@errorName(err)});
				@panic("ThreadPool Creation Failed.");
			};
			var buf: [std.Thread.max_name_len]u8 = undefined;
			thread.setName(std.fmt.bufPrint(&buf, "Worker {}", .{i + 1}) catch "Worker n") catch |err| std.log.err("Couldn't rename thread: {s}", .{@errorName(err)});
		}
		return self;
	}

	pub fn deinit(self: *ThreadPool) void {
		self.running.store(false, .monotonic);
		// Clear the remaining tasks:
		while (self.loadList.extractAny()) |task| {
			task.vtable.clean(task.self);
		}

		while (self.playerJobQueue.popFront()) |player| {
			player.decreaseRefCount();
		}

		for (self.threads) |thread| {
			thread.join();
		}

		self.loadList.deinit();

		self.playerJobQueue.deinit();

		self.allocator.free(self.currentTasks);
		self.allocator.free(self.threads);
		self.allocator.destroy(self);
	}

	pub fn closeAllTasksOfType(self: *ThreadPool, vtable: *const VTable) void {
		std.debug.assert(vtable.taskType != .chunkgen);
		self.loadList.mutex.lock();
		defer self.loadList.mutex.unlock();
		var i: u32 = 0;
		while (i < self.loadList.size) {
			const task = &self.loadList.array[i];
			if (task.vtable == vtable) {
				task.vtable.clean(task.self);
				self.loadList.removeIndex(i);
				self.semaphore.timedWait(0) catch {};
			} else {
				i += 1;
			}
		}
		// Wait for active tasks:
		for (self.currentTasks) |*task| {
			while (task.load(.monotonic) == vtable) {
				main.io.sleep(.fromMilliseconds(1), .awake) catch {};
			}
		}
	}

	fn getNextTask(self: *ThreadPool) ?Task {
		blk: {
			return self.loadList.extractMax() orelse break :blk;
		}
		blk: {
			const player = self.playerJobQueue.popFront() orelse break :blk;
			const result, const hasMoreTasks = player.getTaskFromJobQueue() orelse {
				_ = self.trueQueueSize.fetchSub(1, .monotonic);
				player.decreaseRefCount();
				break :blk;
			};
			switch (hasMoreTasks) {
				.empty => {
					player.decreaseRefCount();
				},
				.hasMoreTasks => {
					self.playerJobQueue.pushBack(player);
					self.semaphore.post();
					_ = self.trueQueueSize.fetchAdd(1, .monotonic);
				},
			}
			return result;
		}
		return null;
	}

	fn run(self: *ThreadPool, id: usize) void {
		main.initThreadLocals();
		defer main.deinitThreadLocals();

		var lastUpdate = main.timestamp();
		outer: while (self.running.load(.monotonic)) {
			main.heap.GarbageCollection.syncPoint();

			self.semaphore.timedWait(10_000_000) catch continue :outer;

			{
				const task = self.getNextTask() orelse continue :outer;
				self.currentTasks[id].store(task.vtable, .monotonic);
				const start = main.timestamp();
				task.vtable.run(task.self);
				const end = main.timestamp();
				self.performance.add(task.vtable.taskType, @intCast(@divTrunc(start.durationTo(end).toNanoseconds(), 1000)));
				self.currentTasks[id].store(null, .monotonic);
				_ = self.trueQueueSize.fetchSub(1, .monotonic);
			}

			if (id == 0 and lastUpdate.durationTo(main.timestamp()).nanoseconds > refreshTime.nanoseconds) {
				const start = main.timestamp();
				var temporaryTaskList = main.List(Task).init(main.stackAllocator);
				defer temporaryTaskList.deinit();
				while (self.loadList.extractAny()) |task| {
					self.semaphore.timedWait(0) catch {};
					if (!task.vtable.isStillNeeded(task.self)) {
						task.vtable.clean(task.self);
						_ = self.trueQueueSize.fetchSub(1, .monotonic);
					} else {
						const taskPtr = temporaryTaskList.addOne();
						taskPtr.* = task;
						taskPtr.cachedPriority = task.vtable.getPriority(task.self);
					}
				}
				self.loadList.addMany(temporaryTaskList.items);
				for (0..temporaryTaskList.items.len) |_| {
					self.semaphore.post();
				}
				const end = main.timestamp();
				lastUpdate = end;
				self.performance.add(.taskPriorityUpdate, @intCast(@divTrunc(start.durationTo(end).toNanoseconds(), 1000)));
			}
		}
	}

	pub fn addTask(self: *ThreadPool, task: *anyopaque, vtable: *const VTable) void {
		self.loadList.add(Task{
			.cachedPriority = vtable.getPriority(task),
			.vtable = vtable,
			.self = task,
		});
		self.semaphore.post();
		_ = self.trueQueueSize.fetchAdd(1, .monotonic);
	}

	pub fn addPlayer(self: *ThreadPool, player: *main.server.User) void {
		player.increaseRefCount();
		self.playerJobQueue.pushBack(player);
		self.semaphore.post();
		_ = self.trueQueueSize.fetchAdd(1, .monotonic);
	}

	pub fn clear(self: *ThreadPool) void {
		// Clear the remaining tasks:
		while (self.loadList.extractAny()) |task| {
			self.semaphore.timedWait(0) catch {};
			task.vtable.clean(task.self);
			_ = self.trueQueueSize.fetchSub(1, .monotonic);
		}
		while (self.playerJobQueue.popFront()) |player| {
			while (player.getTaskFromJobQueue()) |task| {
				task[0].vtable.clean(task[0].self);
			}
			self.semaphore.timedWait(0) catch {};
			player.decreaseRefCount();
			_ = self.trueQueueSize.fetchSub(1, .monotonic);
		}
		// Wait for the in-progress tasks to finish:
		while (self.trueQueueSize.load(.monotonic) != 0) {
			main.io.sleep(.fromMilliseconds(1), .awake) catch {};
		}
	}

	pub fn queueSize(self: *const ThreadPool) usize {
		return self.trueQueueSize.load(.monotonic);
	}
};

var dynamicIntArrayAllocator: main.heap.PowerOfTwoPoolAllocator(main.chunk.chunkVolume/@bitSizeOf(u8), main.chunk.chunkVolume*@sizeOf(u16), 64) = undefined;

pub fn initDynamicIntArrayStorage() void {
	dynamicIntArrayAllocator = .init(main.globalAllocator);
}

pub fn deinitDynamicIntArrayStorage() void {
	dynamicIntArrayAllocator.deinit();
}

/// An packed array of integers with dynamic bit size.
/// The bit size can be changed using the `resize` function.
pub fn DynamicPackedIntArray(size: comptime_int) type { // MARK: DynamicPackedIntArray
	std.debug.assert(std.math.isPowerOfTwo(size));
	return struct {
		data: []align(64) Atomic(u32) = &.{},
		bitSize: u5 = 0,

		const Self = @This();

		pub fn initCapacity(bitSize: u5) Self {
			std.debug.assert(bitSize == 0 or bitSize & bitSize - 1 == 0); // Must be a power of 2
			return .{
				.data = dynamicIntArrayAllocator.allocator().alignedAlloc(Atomic(u32), .@"64", @as(usize, @divExact(size, @bitSizeOf(u32)))*bitSize),
				.bitSize = bitSize,
			};
		}

		fn deinit(self: *Self) void {
			dynamicIntArrayAllocator.allocator().free(self.data);
			self.* = .{};
		}

		inline fn bitInterleave(bits: comptime_int, source: u32) u32 {
			var result = source;
			if (bits <= 8) result = (result ^ (result << 8)) & 0x00ff00ff;
			if (bits <= 4) result = (result ^ (result << 4)) & 0x0f0f0f0f;
			if (bits <= 2) result = (result ^ (result << 2)) & 0x33333333;
			if (bits <= 1) result = (result ^ (result << 1)) & 0x55555555;
			return result;
		}

		pub fn resizeOnceFrom(self: *Self, other: *const Self) void {
			const newBitSize = if (other.bitSize != 0) other.bitSize*2 else 1;
			std.debug.assert(self.bitSize == newBitSize);

			switch (other.bitSize) {
				0 => @memset(self.data, .init(0)),
				inline 1, 2, 4, 8 => |bits| {
					for (0..other.data.len) |i| {
						const oldVal = other.data[i].load(.unordered);
						self.data[2*i].store(bitInterleave(bits, oldVal & 0xffff), .unordered);
						self.data[2*i + 1].store(bitInterleave(bits, oldVal >> 16), .unordered);
					}
				},
				else => unreachable,
			}
		}

		pub fn getValue(self: *const Self, i: usize) u32 {
			std.debug.assert(i < size);
			if (self.bitSize == 0) return 0;
			const bitIndex = i*self.bitSize;
			const intIndex = bitIndex >> 5;
			const bitOffset: u5 = @intCast(bitIndex & 31);
			const bitMask = (@as(u32, 1) << self.bitSize) - 1;
			return self.data[intIndex].load(.unordered) >> bitOffset & bitMask;
		}

		pub fn setValue(self: *Self, i: usize, value: u32) void {
			std.debug.assert(i < size);
			if (self.bitSize == 0) return;
			const bitIndex = i*self.bitSize;
			const intIndex = bitIndex >> 5;
			const bitOffset: u5 = @intCast(bitIndex & 31);
			const bitMask = (@as(u32, 1) << self.bitSize) - 1;
			std.debug.assert(value <= bitMask);
			const ptr: *Atomic(u32) = &self.data[intIndex];
			const newValue = (ptr.load(.unordered) & ~(bitMask << bitOffset)) | value << bitOffset;
			ptr.store(newValue, .unordered);
		}

		pub fn setAndGetValue(self: *Self, i: usize, value: u32) u32 {
			std.debug.assert(i < size);
			if (self.bitSize == 0) return 0;
			const bitIndex = i*self.bitSize;
			const intIndex = bitIndex >> 5;
			const bitOffset: u5 = @intCast(bitIndex & 31);
			const bitMask = (@as(u32, 1) << self.bitSize) - 1;
			std.debug.assert(value <= bitMask);
			const ptr: *Atomic(u32) = &self.data[intIndex];
			const oldValue = ptr.load(.unordered);
			const result = oldValue >> bitOffset & bitMask;
			const newValue = (oldValue & ~(bitMask << bitOffset)) | value << bitOffset;
			ptr.store(newValue, .unordered);
			return result;
		}
	};
}

pub fn PaletteCompressedRegion(T: type, size: comptime_int) type { // MARK: PaletteCompressedRegion
	const Impl = struct {
		data: DynamicPackedIntArray(size) = .{},
		palette: []Atomic(T),
		paletteOccupancy: []u32,
		paletteLength: u32,
		activePaletteEntries: u32,
	};
	return struct {
		impl: Atomic(*Impl),
		const Self = @This();

		pub fn init(self: *Self) void {
			const impl = main.globalAllocator.create(Impl);
			self.* = .{
				.impl = .init(impl),
			};
			impl.* = .{
				.palette = main.globalAllocator.alloc(Atomic(T), 1),
				.paletteOccupancy = main.globalAllocator.alloc(u32, 1),
				.paletteLength = 1,
				.activePaletteEntries = 1,
			};
			impl.palette[0] = .init(std.mem.zeroes(T));
			impl.paletteOccupancy[0] = size;
		}

		pub fn initCopy(self: *Self, template: *const Self) void {
			const impl = main.globalAllocator.create(Impl);
			const templateImpl = template.impl.load(.acquire);
			const dataDupe = DynamicPackedIntArray(size).initCapacity(templateImpl.data.bitSize);
			@memcpy(dataDupe.data, templateImpl.data.data);
			self.* = .{
				.impl = .init(impl),
			};
			impl.* = .{
				.data = dataDupe,
				.palette = main.globalAllocator.dupe(Atomic(T), templateImpl.palette),
				.paletteOccupancy = main.globalAllocator.dupe(u32, templateImpl.paletteOccupancy),
				.paletteLength = templateImpl.paletteLength,
				.activePaletteEntries = templateImpl.activePaletteEntries,
			};
		}

		pub fn initCapacity(self: *Self, paletteLength: u32) void {
			std.debug.assert(paletteLength < 0x80000000 and paletteLength > 0);
			const bitSize: u5 = getTargetBitSize(paletteLength);
			const bufferLength = @as(u32, 1) << bitSize;
			const impl = main.globalAllocator.create(Impl);
			self.* = .{
				.impl = .init(impl),
			};
			impl.* = .{
				.data = DynamicPackedIntArray(size).initCapacity(bitSize),
				.palette = main.globalAllocator.alloc(Atomic(T), bufferLength),
				.paletteOccupancy = main.globalAllocator.alloc(u32, bufferLength),
				.paletteLength = paletteLength,
				.activePaletteEntries = 1,
			};
			impl.palette[0] = .init(std.mem.zeroes(T));
			impl.paletteOccupancy[0] = size;
			@memset(impl.paletteOccupancy[1..], 0);
			@memset(impl.data.data, .init(0));
		}

		fn privateDeinit(impl: *Impl) void {
			impl.data.deinit();
			main.globalAllocator.free(impl.palette);
			main.globalAllocator.free(impl.paletteOccupancy);
			main.globalAllocator.destroy(impl);
		}

		pub fn deferredDeinit(self: *Self) void {
			main.heap.GarbageCollection.deferredFree(.{.ptr = self.impl.raw, .freeFunction = main.meta.castFunctionSelfToAnyopaque(privateDeinit)});
		}

		fn getTargetBitSize(paletteLength: u32) u5 {
			const base: u5 = @intCast(std.math.log2_int_ceil(u32, paletteLength));
			if (base == 0) return 0;
			const logLog = std.math.log2_int_ceil(u5, base);
			return @as(u5, 1) << logLog;
		}

		pub fn getValue(self: *const Self, i: usize) T {
			const impl = self.impl.load(.acquire);
			return impl.palette[impl.data.getValue(i)].load(.unordered);
		}

		pub fn palette(self: *const Self) []Atomic(T) {
			const impl = self.impl.raw;
			return impl.palette[0..impl.paletteLength];
		}

		pub fn fillUniform(self: *Self, value: T) void {
			const impl = self.impl.raw;
			if (impl.paletteLength == 1) {
				impl.palette[0].store(value, .unordered);
				return;
			}
			var newSelf: Self = undefined;
			newSelf.init();
			newSelf.impl.raw.palette[0] = .init(value);
			newSelf.impl.raw = self.impl.swap(newSelf.impl.raw, .release);
			newSelf.deferredDeinit();
		}

		fn getOrInsertPaletteIndex(noalias self: *Self, val: T) u32 {
			var impl = self.impl.raw;
			std.debug.assert(impl.paletteLength <= impl.palette.len);
			var paletteIndex: u32 = 0;
			while (paletteIndex < impl.paletteLength) : (paletteIndex += 1) {
				if (std.meta.eql(impl.palette[paletteIndex].load(.unordered), val)) {
					break;
				}
			}
			if (paletteIndex == impl.paletteLength) {
				if (impl.paletteLength == impl.palette.len) {
					if (impl.data.bitSize == 16) {
						self.optimizeLayoutInternal();
						return self.getOrInsertPaletteIndex(val);
					}
					var newSelf: Self = undefined;
					newSelf.initCapacity(impl.paletteLength*2);
					const newImpl = newSelf.impl.raw;
					// TODO: Resize stuff
					newImpl.data.resizeOnceFrom(&impl.data);
					@memcpy(newImpl.palette[0..impl.palette.len], impl.palette);
					@memcpy(newImpl.paletteOccupancy[0..impl.paletteOccupancy.len], impl.paletteOccupancy);
					@memset(newImpl.paletteOccupancy[impl.paletteOccupancy.len..], 0);
					newImpl.activePaletteEntries = impl.activePaletteEntries;
					newImpl.paletteLength = impl.paletteLength;
					newSelf.impl.raw = self.impl.swap(newImpl, .release);
					newSelf.deferredDeinit();
					impl = newImpl;
				}
				impl.palette[paletteIndex].store(val, .unordered);
				impl.paletteLength += 1;
				std.debug.assert(impl.paletteLength <= impl.palette.len);
			}
			return paletteIndex;
		}

		pub fn setRawValue(noalias self: *Self, i: usize, paletteIndex: u32) void {
			const impl = self.impl.raw;
			const previousPaletteIndex = impl.data.setAndGetValue(i, paletteIndex);
			if (previousPaletteIndex != paletteIndex) {
				if (impl.paletteOccupancy[paletteIndex] == 0) {
					impl.activePaletteEntries += 1;
				}
				impl.paletteOccupancy[paletteIndex] += 1;
				impl.paletteOccupancy[previousPaletteIndex] -= 1;
				if (impl.paletteOccupancy[previousPaletteIndex] == 0) {
					impl.activePaletteEntries -= 1;
				}
			}
		}

		pub fn setValue(noalias self: *Self, i: usize, val: T) void {
			const paletteIndex = self.getOrInsertPaletteIndex(val);
			const impl = self.impl.raw;
			const previousPaletteIndex = impl.data.setAndGetValue(i, paletteIndex);
			if (previousPaletteIndex != paletteIndex) {
				if (impl.paletteOccupancy[paletteIndex] == 0) {
					impl.activePaletteEntries += 1;
				}
				impl.paletteOccupancy[paletteIndex] += 1;
				impl.paletteOccupancy[previousPaletteIndex] -= 1;
				if (impl.paletteOccupancy[previousPaletteIndex] == 0) {
					impl.activePaletteEntries -= 1;
				}
			}
		}

		pub fn setValueInColumn(noalias self: *Self, startIndex: usize, endIndex: usize, val: T) void {
			std.debug.assert(startIndex < endIndex);
			const paletteIndex = self.getOrInsertPaletteIndex(val);
			const impl = self.impl.raw;
			for (startIndex..endIndex) |i| {
				const previousPaletteIndex = impl.data.setAndGetValue(i, paletteIndex);
				impl.paletteOccupancy[previousPaletteIndex] -= 1;
				if (impl.paletteOccupancy[previousPaletteIndex] == 0) {
					impl.activePaletteEntries -= 1;
				}
			}
			if (impl.paletteOccupancy[paletteIndex] == 0) {
				impl.activePaletteEntries += 1;
			}
			impl.paletteOccupancy[paletteIndex] += @intCast(endIndex - startIndex);
		}

		pub fn optimizeLayout(self: *Self) void {
			const impl = self.impl.raw;
			const newBitSize = getTargetBitSize(@intCast(impl.activePaletteEntries));
			if (impl.data.bitSize == newBitSize) return;
			self.optimizeLayoutInternal();
		}

		fn optimizeLayoutInternal(self: *Self) void {
			const impl = self.impl.raw;
			var newSelf: Self = undefined;
			newSelf.initCapacity(impl.activePaletteEntries);
			const newImpl = newSelf.impl.raw;
			const paletteMap: []u32 = main.stackAllocator.alloc(u32, impl.paletteLength);
			defer main.stackAllocator.free(paletteMap);
			{
				var iNew: u32 = 0;
				var iOld: u32 = 0;
				const len: u32 = impl.paletteLength;
				while (iOld < len) : ({
					iNew += 1;
					iOld += 1;
				}) outer: {
					while (impl.paletteOccupancy[iOld] == 0) {
						iOld += 1;
						if (iOld >= len) break :outer;
					}
					std.debug.assert(iNew < impl.activePaletteEntries);
					std.debug.assert(iOld < impl.paletteLength);
					paletteMap[iOld] = iNew;
					newImpl.palette[iNew] = .init(impl.palette[iOld].load(.unordered));
					newImpl.paletteOccupancy[iNew] = impl.paletteOccupancy[iOld];
				}
			}
			for (0..size) |i| {
				newImpl.data.setValue(i, paletteMap[impl.data.getValue(i)]);
			}
			newImpl.paletteLength = impl.activePaletteEntries;
			newImpl.activePaletteEntries = impl.activePaletteEntries;
			newSelf.impl.raw = self.impl.swap(newSelf.impl.raw, .release);
			newSelf.deferredDeinit();
		}
	};
}

/// Implements a simple set associative cache with LRU replacement strategy.
pub fn Cache(comptime T: type, comptime numberOfBuckets: u32, comptime bucketSize: u32, comptime deinitFunction: fn (*T) void) type { // MARK: Cache
	const hashMask = numberOfBuckets - 1;
	if (numberOfBuckets & hashMask != 0) @compileError("The number of buckets should be a power of 2!");

	const Bucket = struct {
		mutex: std.Thread.Mutex = .{},
		items: [bucketSize]?*T = @splat(null),

		fn find(self: *@This(), compare: anytype) ?*T {
			assertLocked(&self.mutex);
			for (self.items, 0..) |item, i| {
				if (compare.equals(item)) {
					if (i != 0) {
						std.mem.copyBackwards(?*T, self.items[1..], self.items[0..i]);
						self.items[0] = item;
					}
					return item;
				}
			}
			return null;
		}

		/// Returns the object that got kicked out of the cache. This must be deinited by the user.
		fn add(self: *@This(), item: *T) ?*T {
			assertLocked(&self.mutex);
			const previous = self.items[bucketSize - 1];
			std.mem.copyBackwards(?*T, self.items[1..], self.items[0 .. bucketSize - 1]);
			self.items[0] = item;
			return previous;
		}

		fn findOrCreate(self: *@This(), compare: anytype, comptime initFunction: fn (@TypeOf(compare)) *T) *T {
			assertLocked(&self.mutex);
			if (self.find(compare)) |item| {
				return item;
			}
			const new = initFunction(compare);
			if (self.add(new)) |toRemove| {
				deinitFunction(toRemove);
			}
			return new;
		}

		fn clear(self: *@This()) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			for (&self.items) |*nullItem| {
				if (nullItem.*) |item| {
					deinitFunction(item);
					nullItem.* = null;
				}
			}
		}

		fn foreach(self: @This(), comptime function: fn (*T) void) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			for (self.items) |*nullItem| {
				if (nullItem) |item| {
					function(item);
				}
			}
		}
	};

	return struct {
		buckets: [numberOfBuckets]Bucket = @splat(.{}),
		cacheRequests: Atomic(usize) = .init(0),
		cacheMisses: Atomic(usize) = .init(0),

		///  Tries to find the entry that fits to the supplied hashable.
		pub fn find(self: *@This(), compareAndHash: anytype, comptime postGetFunction: ?fn (*T) void) ?*T {
			const index: u32 = compareAndHash.hashCode() & hashMask;
			_ = @atomicRmw(usize, &self.cacheRequests.raw, .Add, 1, .monotonic);
			self.buckets[index].mutex.lock();
			defer self.buckets[index].mutex.unlock();
			if (self.buckets[index].find(compareAndHash)) |item| {
				if (postGetFunction) |fun| fun(item);
				return item;
			}
			_ = @atomicRmw(usize, &self.cacheMisses.raw, .Add, 1, .monotonic);
			return null;
		}

		/// Clears all elements calling the deinitFunction for each element.
		pub fn clear(self: *@This()) void {
			for (&self.buckets) |*bucket| {
				bucket.clear();
			}
		}

		pub fn foreach(self: *@This(), comptime function: fn (*T) void) void {
			for (&self.buckets) |*bucket| {
				bucket.foreach(function);
			}
		}

		/// Returns the object that got kicked out of the cache. This must be deinited by the user.
		pub fn addToCache(self: *@This(), item: *T, hash: u32) ?*T {
			const index = hash & hashMask;
			self.buckets[index].mutex.lock();
			defer self.buckets[index].mutex.unlock();
			return self.buckets[index].add(item);
		}

		pub fn findOrCreate(self: *@This(), compareAndHash: anytype, comptime initFunction: fn (@TypeOf(compareAndHash)) *T, comptime postGetFunction: ?fn (*T) void) *T {
			const index: u32 = compareAndHash.hashCode() & hashMask;
			self.buckets[index].mutex.lock();
			defer self.buckets[index].mutex.unlock();
			const result = self.buckets[index].findOrCreate(compareAndHash, initFunction);
			if (postGetFunction) |fun| fun(result);
			return result;
		}
	};
}

///  https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Unit_interval_(0,_1)
pub fn unitIntervalSpline(comptime Float: type, p0: Float, m0: Float, p1: Float, m1: Float) [4]Float { // MARK: unitIntervalSpline()
	return .{
		p0,
		m0,
		-3*p0 - 2*m0 + 3*p1 - m1,
		2*p0 + m0 - 2*p1 + m1,
	};
}

pub fn GenericInterpolation(comptime elements: comptime_int) type { // MARK: GenericInterpolation
	const frames: u32 = 8;
	return struct {
		lastPos: [frames][elements]f64,
		lastVel: [frames][elements]f64,
		lastTimes: [frames]i16,
		frontIndex: u32,
		currentPoint: ?u31,
		outPos: *[elements]f64,
		outVel: *[elements]f64,

		pub fn init(self: *@This(), initialPosition: *[elements]f64, initialVelocity: *[elements]f64) void {
			self.outPos = initialPosition;
			self.outVel = initialVelocity;
			@memset(&self.lastPos, self.outPos.*);
			@memset(&self.lastVel, self.outVel.*);
			self.frontIndex = 0;
			self.currentPoint = null;
		}

		pub fn updatePosition(self: *@This(), pos: *const [elements]f64, vel: *const [elements]f64, time: i16) void {
			self.frontIndex = (self.frontIndex + 1)%frames;
			@memcpy(&self.lastPos[self.frontIndex], pos);
			@memcpy(&self.lastVel[self.frontIndex], vel);
			self.lastTimes[self.frontIndex] = time;
		}

		fn evaluateSplineAt(_t: f64, tScale: f64, p0: f64, _m0: f64, p1: f64, _m1: f64) [2]f64 {
			//  https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Unit_interval_(0,_1)
			const t = _t/tScale;
			const m0 = _m0*tScale;
			const m1 = _m1*tScale;
			const t2 = t*t;
			const t3 = t2*t;
			const a = unitIntervalSpline(f64, p0, m0, p1, m1);
			return [_]f64{
				a[0] + a[1]*t + a[2]*t2 + a[3]*t3, // value
				(a[1] + 2*a[2]*t + 3*a[3]*t2)/tScale, // first derivative
			};
		}

		fn interpolateCoordinate(self: *@This(), i: usize, t: f64, tScale: f64) void {
			if (self.outVel[i] == 0 and self.lastVel[self.currentPoint.?][i] == 0) {
				self.outPos[i] += (self.lastPos[self.currentPoint.?][i] - self.outPos[i])*t/tScale;
			} else {
				// Use cubic interpolation to interpolate the velocity as well.
				const newValue = evaluateSplineAt(t, tScale, self.outPos[i], self.outVel[i], self.lastPos[self.currentPoint.?][i], self.lastVel[self.currentPoint.?][i]);
				self.outPos[i] = newValue[0];
				self.outVel[i] = newValue[1];
			}
		}

		fn determineNextDataPoint(self: *@This(), time: i16, lastTime: *i16) void {
			if (self.currentPoint != null and self.lastTimes[self.currentPoint.?] -% time <= 0) {
				// Jump to the last used value and adjust the time to start at that point.
				lastTime.* = self.lastTimes[self.currentPoint.?];
				@memcpy(self.outPos, &self.lastPos[self.currentPoint.?]);
				@memcpy(self.outVel, &self.lastVel[self.currentPoint.?]);
				self.currentPoint = null;
			}

			if (self.currentPoint == null) {
				// Need a new point:
				var smallestTime: i16 = std.math.maxInt(i16);
				var smallestIndex: ?u31 = null;
				for (self.lastTimes, 0..) |lastTimeI, i| {
					//                   ↓ Only using a future time value that is far enough away to prevent jumping.
					if (lastTimeI -% time >= 50 and lastTimeI -% time < smallestTime) {
						smallestTime = lastTimeI -% time;
						smallestIndex = @intCast(i);
					}
				}
				self.currentPoint = smallestIndex;
			}
		}

		pub fn update(self: *@This(), time: i16, _lastTime: i16) void {
			var lastTime = _lastTime;
			self.determineNextDataPoint(time, &lastTime);

			var deltaTime = @as(f64, @floatFromInt(time -% lastTime))/1000;
			if (deltaTime < 0) {
				std.log.warn("Experienced time travel. Current time: {} Last time: {}", .{time, lastTime});
				lastTime = time;
				deltaTime = 0;
			}

			if (self.currentPoint == null) {
				const drag = std.math.pow(f64, 0.5, deltaTime);
				for (self.outPos, self.outVel) |*pos, *vel| {
					// Just move on with the current velocity.
					pos.* += (vel.*)*deltaTime;
					// Add some drag to prevent moving far away on short connection loss.
					vel.* *= drag;
				}
			} else {
				const tScale = @as(f64, @floatFromInt(self.lastTimes[self.currentPoint.?] -% lastTime))/1000;
				const t = deltaTime;
				for (self.outPos, 0..) |_, i| {
					self.interpolateCoordinate(i, t, tScale);
				}
			}
		}

		pub fn updateIndexed(self: *@This(), time: i16, _lastTime: i16, indices: []u16, comptime coordinatesPerIndex: comptime_int) void {
			var lastTime = _lastTime;
			self.determineNextDataPoint(time, &lastTime);

			var deltaTime = @as(f64, @floatFromInt(time -% lastTime))/1000;
			if (deltaTime < 0) {
				std.log.warn("Experienced time travel. Current time: {} Last time: {}", .{time, lastTime});
				lastTime = time;
				deltaTime = 0;
			}

			if (self.currentPoint == null) {
				const drag = std.math.pow(f64, 0.5, deltaTime);
				for (indices) |i| {
					const index = @as(usize, i)*coordinatesPerIndex;
					for (0..coordinatesPerIndex) |j| {
						// Just move on with the current velocity.
						self.outPos[index + j] += self.outVel[index + j]*deltaTime;
						// Add some drag to prevent moving far away on short connection loss.
						self.outVel[index + j] *= drag;
					}
				}
			} else {
				const tScale = @as(f64, @floatFromInt(self.lastTimes[self.currentPoint.?] -% lastTime))/1000;
				const t = deltaTime;
				for (indices) |i| {
					const index = @as(usize, i)*coordinatesPerIndex;
					for (0..coordinatesPerIndex) |j| {
						self.interpolateCoordinate(index + j, t, tScale);
					}
				}
			}
		}
	};
}

pub const TimeDifference = struct { // MARK: TimeDifference
	difference: Atomic(i16) = .init(0),
	firstValue: bool = true,

	pub fn addDataPoint(self: *TimeDifference, time: i16) void {
		const currentTime: i16 = @truncate(main.timestamp().toMilliseconds());
		const timeDifference = currentTime -% time;
		if (self.firstValue) {
			self.difference.store(timeDifference, .monotonic);
			self.firstValue = false;
		}
		if (timeDifference -% self.difference.load(.monotonic) > 0) {
			_ = @atomicRmw(i16, &self.difference.raw, .Add, 1, .monotonic);
		} else if (timeDifference -% self.difference.load(.monotonic) < 0) {
			_ = @atomicRmw(i16, &self.difference.raw, .Add, -1, .monotonic);
		}
	}
};

pub fn assertLocked(mutex: *const std.Thread.Mutex) void { // MARK: assertLocked()
	if (builtin.mode == .Debug) {
		std.debug.assert(!@constCast(mutex).tryLock());
	}
}

pub fn assertLockedShared(lock: *const std.Thread.RwLock) void {
	if (builtin.mode == .Debug) {
		std.debug.assert(!@constCast(lock).tryLock());
	}
}

/// A read-write lock with read priority.
pub const ReadWriteLock = struct { // MARK: ReadWriteLock
	condition: std.Thread.Condition = .{},
	mutex: std.Thread.Mutex = .{},
	readers: u32 = 0,

	pub fn lockRead(self: *ReadWriteLock) void {
		self.mutex.lock();
		self.readers += 1;
		self.mutex.unlock();
	}

	pub fn unlockRead(self: *ReadWriteLock) void {
		self.mutex.lock();
		self.readers -= 1;
		if (self.readers == 0) {
			self.condition.broadcast();
		}
		self.mutex.unlock();
	}

	pub fn lockWrite(self: *ReadWriteLock) void {
		self.mutex.lock();
		while (self.readers != 0) {
			self.condition.wait(&self.mutex);
		}
	}

	pub fn unlockWrite(self: *ReadWriteLock) void {
		self.mutex.unlock();
	}

	pub fn assertLockedWrite(self: *ReadWriteLock) void {
		if (builtin.mode == .Debug) {
			std.debug.assert(!self.mutex.tryLock());
		}
	}

	pub fn assertLockedRead(self: *ReadWriteLock) void {
		if (builtin.mode == .Debug and !builtin.sanitize_thread) {
			if (self.readers == 0) {
				std.debug.assert(!self.mutex.tryLock());
			}
		}
	}
};

pub const Side = enum {
	client,
	server,
};

const endian: std.builtin.Endian = .big;

pub const BinaryReader = struct {
	remaining: []const u8,

	pub const AllErrors = error{ OutOfBounds, IntOutOfBounds, InvalidEnumTag, InvalidFloat };

	pub fn init(data: []const u8) BinaryReader {
		return .{.remaining = data};
	}

	pub fn readVec(self: *BinaryReader, T: type) error{ OutOfBounds, IntOutOfBounds, InvalidFloat }!T {
		const typeInfo = @typeInfo(T).vector;
		var result: T = undefined;
		inline for (0..typeInfo.len) |i| {
			switch (@typeInfo(typeInfo.child)) {
				.int => {
					result[i] = try self.readInt(typeInfo.child);
				},
				.float => {
					result[i] = try self.readFloat(typeInfo.child);
				},
				else => unreachable,
			}
		}
		return result;
	}

	pub fn readInt(self: *BinaryReader, T: type) error{ OutOfBounds, IntOutOfBounds }!T {
		if (@mod(@typeInfo(T).int.bits, 8) != 0) {
			const fullBits = comptime std.mem.alignForward(u16, @typeInfo(T).int.bits, 8);
			const FullType = std.meta.Int(@typeInfo(T).int.signedness, fullBits);
			const val = try self.readInt(FullType);
			return std.math.cast(T, val) orelse return error.IntOutOfBounds;
		}
		const bufSize = @divExact(@typeInfo(T).int.bits, 8);
		if (self.remaining.len < bufSize) return error.OutOfBounds;
		defer self.remaining = self.remaining[bufSize..];
		return std.mem.readInt(T, self.remaining[0..bufSize], endian);
	}

	pub fn readVarInt(self: *BinaryReader, T: type) !T {
		comptime std.debug.assert(@typeInfo(T).int.signedness == .unsigned);
		comptime std.debug.assert(@bitSizeOf(T) > 8); // Why would you use a VarInt for this?
		var result: T = 0;
		var shift: std.meta.Int(.unsigned, std.math.log2_int_ceil(usize, @bitSizeOf(T))) = 0;
		while (true) {
			const nextByte = try self.readInt(u8);
			const value: T = nextByte & 0x7f;
			result |= try std.math.shlExact(T, value, shift);
			if (nextByte & 0x80 == 0) break;
			shift = try std.math.add(@TypeOf(shift), shift, 7);
		}
		return result;
	}

	pub fn readFloat(self: *BinaryReader, T: type) error{ OutOfBounds, IntOutOfBounds, InvalidFloat }!T {
		const IntT = std.meta.Int(.unsigned, @typeInfo(T).float.bits);
		const result: T = @bitCast(try self.readInt(IntT));
		if (!std.math.isFinite(result)) return error.InvalidFloat;
		return result;
	}

	pub fn readEnum(self: *BinaryReader, T: type) error{ OutOfBounds, IntOutOfBounds, InvalidEnumTag }!T {
		const int = try self.readInt(@typeInfo(T).@"enum".tag_type);
		return std.meta.intToEnum(T, int);
	}

	pub fn readBool(self: *BinaryReader) error{ OutOfBounds, IntOutOfBounds, InvalidEnumTag }!bool {
		const int = try self.readInt(u1);
		return int != 0;
	}

	pub fn readUntilDelimiter(self: *BinaryReader, comptime delimiter: u8) ![:delimiter]const u8 {
		const len = std.mem.indexOfScalar(u8, self.remaining, delimiter) orelse return error.OutOfBounds;
		defer self.remaining = self.remaining[len + 1 ..];
		return self.remaining[0..len :delimiter];
	}

	pub fn readSlice(self: *BinaryReader, length: usize) error{ OutOfBounds, IntOutOfBounds }![]const u8 {
		if (self.remaining.len < length) return error.OutOfBounds;
		defer self.remaining = self.remaining[length..];
		return self.remaining[0..length];
	}
};

pub const BinaryWriter = struct {
	data: main.List(u8),

	pub fn init(allocator: NeverFailingAllocator) BinaryWriter {
		return .{.data = .init(allocator)};
	}

	pub fn initCapacity(allocator: NeverFailingAllocator, capacity: usize) BinaryWriter {
		return .{.data = .initCapacity(allocator, capacity)};
	}

	pub fn deinit(self: *BinaryWriter) void {
		self.data.deinit();
	}

	pub fn writeVec(self: *BinaryWriter, T: type, value: T) void {
		const typeInfo = @typeInfo(T).vector;
		inline for (0..typeInfo.len) |i| {
			switch (@typeInfo(typeInfo.child)) {
				.int => {
					self.writeInt(typeInfo.child, value[i]);
				},
				.float => {
					self.writeFloat(typeInfo.child, value[i]);
				},
				else => unreachable,
			}
		}
	}

	pub fn writeInt(self: *BinaryWriter, T: type, value: T) void {
		if (@mod(@typeInfo(T).int.bits, 8) != 0) {
			const fullBits = comptime std.mem.alignForward(u16, @typeInfo(T).int.bits, 8);
			const FullType = std.meta.Int(@typeInfo(T).int.signedness, fullBits);
			return self.writeInt(FullType, value);
		}
		const bufSize = @divExact(@typeInfo(T).int.bits, 8);
		std.mem.writeInt(T, self.data.addMany(bufSize)[0..bufSize], value, endian);
	}

	pub fn writeVarInt(self: *BinaryWriter, T: type, value: T) void {
		comptime std.debug.assert(@typeInfo(T).int.signedness == .unsigned);
		comptime std.debug.assert(@bitSizeOf(T) > 8); // Why would you use a VarInt for this?
		var remaining: T = value;
		while (true) {
			var writeByte: u8 = @intCast(remaining & 0x7f);
			remaining >>= 7;
			if (remaining != 0) writeByte |= 0x80;
			self.writeInt(u8, writeByte);
			if (remaining == 0) break;
		}
	}

	pub fn writeFloat(self: *BinaryWriter, T: type, value: T) void {
		const IntT = std.meta.Int(.unsigned, @typeInfo(T).float.bits);
		self.writeInt(IntT, @bitCast(value));
	}

	pub fn writeEnum(self: *BinaryWriter, T: type, value: T) void {
		self.writeInt(@typeInfo(T).@"enum".tag_type, @intFromEnum(value));
	}

	pub fn writeBool(self: *BinaryWriter, value: bool) void {
		self.writeInt(u1, @intFromBool(value));
	}

	pub fn writeSlice(self: *BinaryWriter, slice: []const u8) void {
		self.data.appendSlice(slice);
	}

	pub fn writeWithDelimiter(self: *BinaryWriter, slice: []const u8, delimiter: u8) void {
		std.debug.assert(!std.mem.containsAtLeast(u8, slice, 1, &.{delimiter}));
		self.writeSlice(slice);
		self.data.append(delimiter);
	}
};

const ReadWriteTest = struct {
	fn getWriter() BinaryWriter {
		return .init(main.heap.testingAllocator);
	}
	fn getReader(data: []const u8) BinaryReader {
		return .init(data);
	}
	fn testInt(comptime IntT: type, expected: IntT) !void {
		var writer = getWriter();
		defer writer.deinit();
		writer.writeInt(IntT, expected);

		const expectedWidth = std.math.divCeil(comptime_int, @bitSizeOf(IntT), 8);
		try std.testing.expectEqual(expectedWidth, writer.data.items.len);

		var reader = getReader(writer.data.items);
		const actual = try reader.readInt(IntT);

		try std.testing.expectEqual(expected, actual);
	}
	fn testVarInt(comptime IntT: type, expected: IntT) !void {
		var writer = getWriter();
		defer writer.deinit();
		writer.writeVarInt(IntT, expected);

		const expectedWidth = 1 + std.math.log2_int(IntT, @max(1, expected))/7;
		try std.testing.expectEqual(expectedWidth, writer.data.items.len);

		var reader = getReader(writer.data.items);
		const actual = try reader.readVarInt(IntT);

		try std.testing.expectEqual(expected, actual);
	}
	fn testFloat(comptime FloatT: type, expected: FloatT) !void {
		var writer = getWriter();
		defer writer.deinit();
		writer.writeFloat(FloatT, expected);

		var reader = getReader(writer.data.items);
		const actual = try reader.readFloat(FloatT);

		try std.testing.expectEqual(expected, actual);
	}
	fn testInvalidFloat(comptime FloatT: type, input: FloatT) !void {
		var writer = getWriter();
		defer writer.deinit();
		writer.writeFloat(FloatT, input);

		var reader = getReader(writer.data.items);
		const actual = reader.readFloat(FloatT);

		try std.testing.expectError(error.InvalidFloat, actual);
	}
	fn testEnum(comptime EnumT: type, expected: EnumT) !void {
		var writer = getWriter();
		defer writer.deinit();
		writer.writeEnum(EnumT, expected);

		var reader = getReader(writer.data.items);
		const actual = try reader.readEnum(EnumT);

		try std.testing.expectEqual(expected, actual);
	}
	fn TestEnum(comptime IntT: type) type {
		return enum(IntT) {
			first = std.math.minInt(IntT),
			center = (std.math.maxInt(IntT) + std.math.minInt(IntT))/2,
			last = std.math.maxInt(IntT),
		};
	}
	fn testVec(comptime VecT: type, expected: VecT) !void {
		var writer = getWriter();
		defer writer.deinit();
		writer.writeVec(VecT, expected);

		var reader = getReader(writer.data.items);
		const actual = try reader.readVec(VecT);

		try std.testing.expectEqual(expected, actual);
	}
};

test "read/write unsigned int" {
	inline for ([_]type{u0, u1, u2, u4, u5, u8, u16, u31, u32, u64, u128}) |intT| {
		const min = std.math.minInt(intT);
		const max = std.math.maxInt(intT);
		const mid = (max + min)/2;

		try ReadWriteTest.testInt(intT, min);
		try ReadWriteTest.testInt(intT, mid);
		try ReadWriteTest.testInt(intT, max);
	}
}

test "read/write signed int" {
	inline for ([_]type{i1, i2, i4, i5, i8, i16, i31, i32, i64, i128}) |intT| {
		const min = std.math.minInt(intT);
		const lowerMid = std.math.minInt(intT)/2;
		const upperMid = std.math.maxInt(intT)/2;
		const max = std.math.maxInt(intT);

		try ReadWriteTest.testInt(intT, min);
		try ReadWriteTest.testInt(intT, lowerMid);
		try ReadWriteTest.testInt(intT, 0);
		try ReadWriteTest.testInt(intT, upperMid);
		try ReadWriteTest.testInt(intT, max);
	}
}

test "read/write unsigned varint" {
	inline for ([_]type{u9, u16, u31, u32, u64, u128}) |IntT| {
		for (0..@bitSizeOf(IntT)) |i| {
			try ReadWriteTest.testVarInt(IntT, @as(IntT, 1) << @intCast(i));
			try ReadWriteTest.testVarInt(IntT, (@as(IntT, 1) << @intCast(i)) - 1);
		}
		const max = std.math.maxInt(IntT);
		try ReadWriteTest.testVarInt(IntT, max);
	}
}

test "read/write float" {
	inline for ([_]type{f16, f32, f64, f80, f128}) |floatT| {
		try ReadWriteTest.testFloat(floatT, std.math.floatMax(floatT));
		try ReadWriteTest.testFloat(floatT, 0.0012443);
		try ReadWriteTest.testFloat(floatT, 0.0);
		try ReadWriteTest.testFloat(floatT, 6457.0);
		try ReadWriteTest.testInvalidFloat(floatT, std.math.inf(floatT));
		try ReadWriteTest.testInvalidFloat(floatT, -std.math.inf(floatT));
		try ReadWriteTest.testInvalidFloat(floatT, std.math.nan(floatT));
		try ReadWriteTest.testFloat(floatT, std.math.floatMin(floatT));
	}
}

test "read/write enum" {
	inline for ([_]type{
		ReadWriteTest.TestEnum(u2),
		ReadWriteTest.TestEnum(u4),
		ReadWriteTest.TestEnum(u5),
		ReadWriteTest.TestEnum(u8),
		ReadWriteTest.TestEnum(u16),
		ReadWriteTest.TestEnum(u32),
		ReadWriteTest.TestEnum(i2),
		ReadWriteTest.TestEnum(i4),
		ReadWriteTest.TestEnum(i5),
		ReadWriteTest.TestEnum(i8),
		ReadWriteTest.TestEnum(i16),
		ReadWriteTest.TestEnum(i32),
	}) |enumT| {
		try ReadWriteTest.testEnum(enumT, .first);
		try ReadWriteTest.testEnum(enumT, .center);
		try ReadWriteTest.testEnum(enumT, .last);
	}
}

test "read/write Vec3i" {
	try ReadWriteTest.testVec(main.vec.Vec3i, .{0, 0, 0});
	try ReadWriteTest.testVec(main.vec.Vec3i, .{
		std.math.maxInt(@typeInfo(main.vec.Vec3i).vector.child),
		std.math.minInt(@typeInfo(main.vec.Vec3i).vector.child),
		std.math.minInt(@typeInfo(main.vec.Vec3i).vector.child),
	});
	try ReadWriteTest.testVec(main.vec.Vec3i, .{
		std.math.minInt(@typeInfo(main.vec.Vec3i).vector.child),
		std.math.maxInt(@typeInfo(main.vec.Vec3i).vector.child),
		std.math.maxInt(@typeInfo(main.vec.Vec3i).vector.child),
	});
}

test "read/write Vec3f/Vec3d" {
	inline for ([_]type{main.vec.Vec3f, main.vec.Vec3d}) |vecT| {
		try ReadWriteTest.testVec(vecT, .{0, 0, 0});
		try ReadWriteTest.testVec(vecT, .{0.0043, 0.01123, 0.05043});
		try ReadWriteTest.testVec(vecT, .{5345.0, 42.0, 7854.0});
		try ReadWriteTest.testVec(vecT, .{
			std.math.floatMax(@typeInfo(vecT).vector.child),
			std.math.floatMin(@typeInfo(vecT).vector.child),
			std.math.floatMin(@typeInfo(vecT).vector.child),
		});
		try ReadWriteTest.testVec(vecT, .{
			std.math.floatMin(@typeInfo(vecT).vector.child),
			std.math.floatMax(@typeInfo(vecT).vector.child),
			std.math.floatMax(@typeInfo(vecT).vector.child),
		});
	}
}

test "read/write mixed" {
	const type0 = u4;
	const expected0 = 5;

	const type1 = main.vec.Vec3i;
	const expected1 = type1{3, -10, 44};

	const type2 = enum(u3) { first, second, third };
	const expected2 = .second;

	const type3 = f32;
	const expected3 = 0.1234;

	const expected4 = "Hello World!";

	var writer = ReadWriteTest.getWriter();
	defer writer.deinit();

	writer.writeInt(type0, expected0);
	writer.writeVec(type1, expected1);
	writer.writeEnum(type2, expected2);
	writer.writeFloat(type3, expected3);
	writer.writeSlice(expected4);

	var reader = ReadWriteTest.getReader(writer.data.items);

	try std.testing.expectEqual(expected0, try reader.readInt(type0));
	try std.testing.expectEqual(expected1, try reader.readVec(type1));
	try std.testing.expectEqual(expected2, try reader.readEnum(type2));
	try std.testing.expectEqual(expected3, try reader.readFloat(type3));
	try std.testing.expectEqualStrings(expected4, try reader.readSlice(expected4.len));

	try std.testing.expect(reader.remaining.len == 0);
}

pub fn DenseId(comptime IdType: type) type {
	std.debug.assert(@typeInfo(IdType) == .int);
	std.debug.assert(@typeInfo(IdType).int.signedness == .unsigned);

	return enum(IdType) {
		noValue = std.math.maxInt(IdType),
		_,
	};
}

pub fn SparseSet(comptime T: type, comptime IdType: type) type { // MARK: SparseSet
	std.debug.assert(@intFromEnum(IdType.noValue) == std.math.maxInt(@typeInfo(IdType).@"enum".tag_type));

	return struct {
		const Self = @This();

		dense: main.ListUnmanaged(T) = .{},
		denseToSparseIndex: main.ListUnmanaged(IdType) = .{},
		sparseToDenseIndex: main.ListUnmanaged(IdType) = .{},

		pub fn clear(self: *Self) void {
			self.dense.clearRetainingCapacity();
			self.denseToSparseIndex.clearRetainingCapacity();
			self.sparseToDenseIndex.clearRetainingCapacity();
		}

		pub fn deinit(self: *Self, allocator: NeverFailingAllocator) void {
			self.dense.deinit(allocator);
			self.denseToSparseIndex.deinit(allocator);
			self.sparseToDenseIndex.deinit(allocator);
		}

		pub fn contains(self: *Self, id: IdType) bool {
			return @intFromEnum(id) < self.sparseToDenseIndex.items.len and self.sparseToDenseIndex.items[@intFromEnum(id)] != .noValue;
		}

		pub fn add(self: *Self, allocator: NeverFailingAllocator, id: IdType) *T {
			std.debug.assert(id != .noValue);

			const denseId: IdType = @enumFromInt(self.dense.items.len);

			if (@intFromEnum(id) >= self.sparseToDenseIndex.items.len) {
				self.sparseToDenseIndex.appendNTimes(allocator, .noValue, @intFromEnum(id) - self.sparseToDenseIndex.items.len + 1);
			}

			std.debug.assert(self.sparseToDenseIndex.items[@intFromEnum(id)] == .noValue);

			self.sparseToDenseIndex.items[@intFromEnum(id)] = denseId;
			self.denseToSparseIndex.append(allocator, id);
			return self.dense.addOne(allocator);
		}

		pub fn set(self: *Self, allocator: NeverFailingAllocator, id: IdType, value: T) void {
			self.add(allocator, id).* = value;
		}

		pub fn fetchRemove(self: *Self, id: IdType) !T {
			if (!self.contains(id)) return error.ElementNotFound;

			const denseId = @intFromEnum(self.sparseToDenseIndex.items[@intFromEnum(id)]);
			self.sparseToDenseIndex.items[@intFromEnum(id)] = .noValue;

			const result = self.dense.swapRemove(denseId);
			_ = self.denseToSparseIndex.swapRemove(denseId);

			if (denseId != self.dense.items.len) {
				self.sparseToDenseIndex.items[@intFromEnum(self.denseToSparseIndex.items[denseId])] = @enumFromInt(denseId);
			}
			return result;
		}

		pub fn remove(self: *Self, id: IdType) !void {
			_ = try self.fetchRemove(id);
		}

		pub fn get(self: *Self, id: IdType) ?*T {
			if (@intFromEnum(id) >= self.sparseToDenseIndex.items.len) return null;
			const index = self.sparseToDenseIndex.items[@intFromEnum(id)];
			if (index == .noValue) return null;
			return &self.dense.items[@intFromEnum(index)];
		}
	};
}

test "SparseSet/set at zero" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	const index: IdType = @enumFromInt(0);

	set.set(main.heap.testingAllocator, index, 5);
	try std.testing.expectEqual(set.get(index).?.*, 5);
}

test "SparseSet/set at 100" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	const index: IdType = @enumFromInt(100);

	set.set(main.heap.testingAllocator, index, 5);
	try std.testing.expectEqual(set.get(index).?.*, 5);
}

test "SparseSet/remove first" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	const expectSecond: u32 = 100;

	const firstId: IdType = @enumFromInt(0);
	const secondId: IdType = @enumFromInt(1);

	set.set(main.heap.testingAllocator, firstId, 5);
	set.set(main.heap.testingAllocator, secondId, expectSecond);

	try set.remove(firstId);

	try std.testing.expectEqual(set.get(secondId).?.*, expectSecond);
}

test "SparseSet/remove last" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	set.set(main.heap.testingAllocator, @enumFromInt(0), 5);

	try set.remove(@enumFromInt(0));
}

test "SparseSet/remove entry that doesn't exist" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	try std.testing.expectError(error.ElementNotFound, set.remove(@enumFromInt(0)));
}

test "SparseSet/remove entry twice" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	set.set(main.heap.testingAllocator, @enumFromInt(0), 5);

	try set.remove(@enumFromInt(0));
	try std.testing.expectError(error.ElementNotFound, set.remove(@enumFromInt(0)));
}

test "SparseSet/reusing" {
	const IdType = DenseId(u32);
	var set: SparseSet(u32, IdType) = .{};
	defer set.deinit(main.heap.testingAllocator);

	const expectSecond = 100;
	const expectNew = 10;

	const firstId: IdType = @enumFromInt(0);
	const secondId: IdType = @enumFromInt(1);

	set.set(main.heap.testingAllocator, firstId, 5);
	set.set(main.heap.testingAllocator, secondId, expectSecond);

	try set.remove(firstId);

	set.set(main.heap.testingAllocator, firstId, expectNew);

	try std.testing.expectEqual(set.get(secondId).?.*, expectSecond);
	try std.testing.expectEqual(set.get(firstId).?.*, expectNew);
}

pub fn panicWithMessage(comptime fmt: []const u8, args: anytype) noreturn {
	const message = std.fmt.allocPrint(main.stackAllocator.allocator, fmt, args) catch unreachable;
	@panic(message);
}

pub const obfuscationChar = "∗".*;

pub fn obfuscateString(allocator: NeverFailingAllocator, string: []const u8) []const u8 {
	const len = std.unicode.utf8CountCodepoints(string) catch 0;
	const obfuscated = allocator.alloc(u8, len*obfuscationChar.len);
	var i: usize = 0;
	while (i < obfuscated.len) : (i += obfuscationChar.len) {
		@memcpy(obfuscated[i .. i + obfuscationChar.len], &obfuscationChar);
	}
	return obfuscated;
}

```

`src/utils/file_monitor.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

const main = @import("main");

const CallbackFunction = *const fn (usize) void;

const Impl = if (builtin.os.tag == .windows)
	WindowsImpl
else if (builtin.os.tag == .linux)
	LinuxImpl
else
	NoImpl;

pub fn init() void {
	Impl.init();
}

pub fn deinit() void {
	Impl.deinit();
}

pub fn handleEvents() void {
	Impl.handleEvents();
}

pub fn listenToPath(path: [:0]const u8, callback: CallbackFunction, userData: usize) void {
	Impl.listenToPath(path, callback, userData);
}

pub fn removePath(path: [:0]const u8) void {
	Impl.removePath(path);
}

const NoImpl = struct {
	fn init() void {}
	fn deinit() void {}
	fn handleEvents() void {}
	fn listenToPath(_: [:0]const u8, _: CallbackFunction, _: usize) void {}
	fn removePath(_: [:0]const u8) void {}
};

const LinuxImpl = struct { // MARK: LinuxImpl
	const c = @cImport({
		@cInclude("sys/inotify.h");
		@cInclude("sys/ioctl.h");
		@cInclude("unistd.h");
		@cInclude("errno.h");
	});

	const DirectoryInfo = struct {
		callback: CallbackFunction,
		userData: usize,
		watchDescriptors: main.ListUnmanaged(c_int),
		needsUpdate: bool,
		path: []const u8,
	};

	var fd: c_int = undefined;
	var watchDescriptors: std.StringHashMap(*DirectoryInfo) = undefined;
	var callbacks: std.AutoHashMap(c_int, *DirectoryInfo) = undefined;
	var mutex: std.Thread.Mutex = .{};

	fn init() void {
		fd = c.inotify_init();
		if (fd == -1) {
			std.log.err("Error while initializing inotifiy: {}", .{std.posix.errno(fd)});
		}
		watchDescriptors = .init(main.globalAllocator.allocator);
		callbacks = .init(main.globalAllocator.allocator);
	}

	fn deinit() void {
		const result = c.close(fd);
		if (result == -1) {
			std.log.err("Error while closing file descriptor: {}", .{std.posix.errno(result)});
		}
		var iterator = watchDescriptors.iterator();
		while (iterator.next()) |entry| {
			main.globalAllocator.free(entry.key_ptr.*);
			entry.value_ptr.*.watchDescriptors.deinit(main.globalAllocator);
			main.globalAllocator.destroy(entry.value_ptr.*);
		}
		watchDescriptors.deinit();
		callbacks.deinit();
	}

	fn addWatchDescriptorsRecursive(info: *DirectoryInfo, path: []const u8) void {
		main.utils.assertLocked(&mutex);
		var iterableDir = main.files.cwd().openIterableDir(path) catch |err| {
			std.log.err("Error while opening dirs {s}: {s}", .{path, @errorName(err)});
			return;
		};
		defer iterableDir.close();
		var iterator = iterableDir.iterate();
		while (iterator.next() catch |err| {
			std.log.err("Error while iterating dir {s}: {s}", .{path, @errorName(err)});
			return;
		}) |entry| {
			if (entry.kind == .directory) {
				const subPath = std.fmt.allocPrintSentinel(main.stackAllocator.allocator, "{s}/{s}", .{path, entry.name}, 0) catch unreachable;
				defer main.stackAllocator.free(subPath);
				addWatchDescriptor(info, subPath);
				addWatchDescriptorsRecursive(info, subPath);
			}
		}
	}

	fn updateRecursiveCallback(info: *DirectoryInfo) void {
		main.utils.assertLocked(&mutex);
		for (info.watchDescriptors.items[1..]) |watchDescriptor| {
			removeWatchDescriptor(watchDescriptor, info.path);
		}
		info.watchDescriptors.items.len = 1;
		addWatchDescriptorsRecursive(info, info.path);
	}

	fn handleEvents() void {
		mutex.lock();
		defer mutex.unlock();
		var available: c_uint = 0;
		const result = c.ioctl(fd, c.FIONREAD, &available);
		if (result == -1) {
			std.log.err("Error while checking the number of available bytes for the inotify file descriptor: {}", .{std.posix.errno(result)});
		}
		if (available == 0) return;
		const events: []u8 = main.stackAllocator.alloc(u8, available);
		defer main.stackAllocator.free(events);
		const readBytes = c.read(fd, events.ptr, available);
		if (readBytes == -1) {
			std.log.err("Error while reading inotify event: {}", .{std.posix.errno(readBytes)});
			return;
		}
		var triggeredCallbacks = std.AutoHashMap(*DirectoryInfo, void).init(main.stackAllocator.allocator); // Avoid duplicate calls
		defer triggeredCallbacks.deinit();
		var offset: usize = 0;
		while (offset < available) {
			const eventPtr: *const c.inotify_event = @ptrCast(@alignCast(events.ptr[offset..]));
			defer offset += @sizeOf(c.inotify_event) + eventPtr.len;

			const callback = callbacks.get(eventPtr.wd) orelse continue;
			if (eventPtr.mask & c.IN_ISDIR != 0) callback.needsUpdate = true;
			_ = triggeredCallbacks.getOrPut(callback) catch unreachable;
		}
		var iterator = triggeredCallbacks.keyIterator();
		while (iterator.next()) |callback| {
			if (callback.*.needsUpdate) {
				callback.*.needsUpdate = false;
				updateRecursiveCallback(callback.*);
			}
			mutex.unlock();
			callback.*.callback(callback.*.userData);
			mutex.lock();
		}
	}

	fn addWatchDescriptor(info: *DirectoryInfo, path: [:0]const u8) void {
		main.utils.assertLocked(&mutex);
		const watchDescriptor = c.inotify_add_watch(fd, path.ptr, c.IN_CLOSE_WRITE | c.IN_DELETE | c.IN_CREATE | c.IN_MOVE | c.IN_ONLYDIR);
		if (watchDescriptor == -1) {
			std.log.err("Error while adding watch descriptor for path {s}: {}", .{path, std.posix.errno(watchDescriptor)});
		}
		callbacks.put(watchDescriptor, info) catch unreachable;
		info.watchDescriptors.append(main.globalAllocator, watchDescriptor);
	}

	fn removeWatchDescriptor(watchDescriptor: c_int, path: []const u8) void {
		main.utils.assertLocked(&mutex);
		_ = callbacks.remove(watchDescriptor);
		const result = c.inotify_rm_watch(fd, watchDescriptor);
		if (result == -1) {
			const err = std.posix.errno(result);
			if (err != .INVAL) std.log.err("Error while removing watch descriptors for path {s}: {}", .{path, err});
		}
	}

	fn listenToPath(path: [:0]const u8, callback: CallbackFunction, userData: usize) void {
		mutex.lock();
		defer mutex.unlock();
		if (watchDescriptors.contains(path)) {
			std.log.err("Tried to add duplicate watch descriptor for path {s}", .{path});
			return;
		}
		const callbackInfo = main.globalAllocator.create(DirectoryInfo);
		callbackInfo.* = .{
			.callback = callback,
			.userData = userData,
			.watchDescriptors = .{},
			.path = main.globalAllocator.dupe(u8, path),
			.needsUpdate = false,
		};
		watchDescriptors.putNoClobber(callbackInfo.path, callbackInfo) catch unreachable;
		addWatchDescriptor(callbackInfo, path);
		updateRecursiveCallback(callbackInfo);
	}

	fn removePath(path: [:0]const u8) void {
		mutex.lock();
		defer mutex.unlock();
		if (watchDescriptors.fetchRemove(path)) |kv| {
			for (kv.value.watchDescriptors.items) |watchDescriptor| {
				removeWatchDescriptor(watchDescriptor, path);
			}
			main.globalAllocator.free(kv.key);
			kv.value.watchDescriptors.deinit(main.globalAllocator);
			main.globalAllocator.destroy(kv.value);
		} else {
			std.log.err("Tried to remove non-existent watch descriptor for path {s}", .{path});
		}
	}
};

const WindowsImpl = struct { // MARK: WindowsImpl
	const c = @cImport({
		@cInclude("fileapi.h");
	});
	const HANDLE = std.os.windows.HANDLE;
	var notificationHandlers: std.StringHashMap(*DirectoryInfo) = undefined;
	var callbacks: main.List(*DirectoryInfo) = undefined;
	var justTheHandles: main.List(HANDLE) = undefined;
	var mutex: std.Thread.Mutex = .{};

	const DirectoryInfo = struct {
		callback: CallbackFunction,
		userData: usize,
		notificationHandler: HANDLE,
		needsUpdate: bool,
		path: []const u8,
	};

	fn init() void {
		notificationHandlers = .init(main.globalAllocator.allocator);
		callbacks = .init(main.globalAllocator);
		justTheHandles = .init(main.globalAllocator);
	}

	fn deinit() void {
		var iterator = notificationHandlers.iterator();
		while (iterator.next()) |entry| {
			main.globalAllocator.free(entry.key_ptr.*);
			main.globalAllocator.destroy(entry.value_ptr.*);
		}
		notificationHandlers.deinit();
		callbacks.deinit();
		justTheHandles.deinit();
	}

	fn handleEvents() void {
		mutex.lock();
		defer mutex.unlock();
		while (true) {
			if (justTheHandles.items.len == 0) break;
			const waitResult = std.os.windows.kernel32.WaitForMultipleObjects(@intCast(justTheHandles.items.len), justTheHandles.items.ptr, @intFromBool(false), 0);
			if (waitResult == std.os.windows.WAIT_TIMEOUT) break;
			if (waitResult == std.os.windows.WAIT_FAILED) {
				std.log.err("Error while waiting: {}", .{std.os.windows.kernel32.GetLastError()});
				break;
			}
			if (waitResult < std.os.windows.WAIT_OBJECT_0 or waitResult - std.os.windows.WAIT_OBJECT_0 >= justTheHandles.items.len) {
				std.log.err("Windows gave an unexpected wait result: {}", .{waitResult});
				break;
			}
			const callbackInfo = callbacks.items[@intCast(waitResult - std.os.windows.WAIT_OBJECT_0)];
			const result = c.FindNextChangeNotification(callbackInfo.notificationHandler);
			if (result == 0) {
				std.log.err("Error on FindNextChangeNotification for path {s}: {}", .{callbackInfo.path, result});
			}
			mutex.unlock();
			callbackInfo.callback(callbackInfo.userData);
			mutex.lock();
		}
	}

	fn listenToPath(path: [:0]const u8, callback: CallbackFunction, userData: usize) void {
		mutex.lock();
		defer mutex.unlock();
		if (notificationHandlers.contains(path)) {
			std.log.err("Tried to add duplicate notification handler for path {s}", .{path});
			return;
		}
		const handle = c.FindFirstChangeNotificationA(path.ptr, @intFromBool(true), c.FILE_NOTIFY_CHANGE_LAST_WRITE);
		if (handle == std.os.windows.INVALID_HANDLE_VALUE) {
			std.log.err("Got error while creating notification handler for path {s}: {}", .{path, std.os.windows.kernel32.GetLastError()});
		}

		const callbackInfo = main.globalAllocator.create(DirectoryInfo);
		callbackInfo.* = .{
			.callback = callback,
			.userData = userData,
			.notificationHandler = handle.?,
			.path = main.globalAllocator.dupe(u8, path),
			.needsUpdate = false,
		};
		notificationHandlers.putNoClobber(callbackInfo.path, callbackInfo) catch unreachable;
		callbacks.append(callbackInfo);
		justTheHandles.append(callbackInfo.notificationHandler);
	}

	fn removePath(path: [:0]const u8) void {
		mutex.lock();
		defer mutex.unlock();
		if (notificationHandlers.fetchRemove(path)) |kv| {
			const index = std.mem.indexOfScalar(*DirectoryInfo, callbacks.items, kv.value).?;
			_ = callbacks.swapRemove(index);
			_ = justTheHandles.swapRemove(index);
			if (c.FindCloseChangeNotification(kv.value.notificationHandler) == 0) {
				std.log.err("Error while closing notification handler for path {s}: {}", .{path, std.os.windows.kernel32.GetLastError()});
			}
			main.globalAllocator.free(kv.key);
			main.globalAllocator.destroy(kv.value);
		} else {
			std.log.err("Tried to remove non-existent notification handler for path {s}", .{path});
		}
	}
};

```

`src/utils/heap.zig`:

```zig
const std = @import("std");
const Allocator = std.mem.Allocator;

const build_options = @import("build_options");

const main = @import("main");

var testingErrorHandlingAllocator = ErrorHandlingAllocator.init(std.testing.allocator);
pub const testingAllocator = testingErrorHandlingAllocator.allocator();

pub const allocators = struct { // MARK: allocators
	pub var globalGpa = std.heap.GeneralPurposeAllocator(.{.thread_safe = true}){};
	pub var handledGpa = ErrorHandlingAllocator.init(globalGpa.allocator());
	pub var globalArenaAllocator: ThreadSafeAllocator(NeverFailingArenaAllocator) = .init(.init(handledGpa.allocator()));
	pub var worldArenaAllocator: ThreadSafeAllocator(NeverFailingArenaAllocator) = undefined;
	var worldArenaOpenCount: usize = 0;
	var worldArenaMutex: std.Thread.Mutex = .{};

	pub fn deinit() void {
		std.log.info("Clearing global arena with {} MiB", .{globalArenaAllocator.child.arena.queryCapacity() >> 20});
		globalArenaAllocator.deinit();
		globalArenaAllocator = undefined;
		if (globalGpa.deinit() == .leak) {
			std.log.err("Memory leak", .{});
		}
		globalGpa = undefined;
	}

	pub fn createWorldArena() void {
		worldArenaMutex.lock();
		defer worldArenaMutex.unlock();
		if (worldArenaOpenCount == 0) {
			worldArenaAllocator = .init(.init(handledGpa.allocator()));
		}
		worldArenaOpenCount += 1;
	}

	pub fn destroyWorldArena() void {
		worldArenaMutex.lock();
		defer worldArenaMutex.unlock();
		worldArenaOpenCount -= 1;
		if (worldArenaOpenCount == 0) {
			std.log.info("Clearing world arena with {} MiB", .{worldArenaAllocator.child.arena.queryCapacity() >> 20});
			worldArenaAllocator.deinit();
			worldArenaAllocator = undefined;
		}
	}
};

/// Allows for stack-like allocations in a fast and safe way.
/// It is safe in the sense that a regular allocator will be used when the buffer is full.
pub const StackAllocator = struct { // MARK: StackAllocator
	const AllocationTrailer = packed struct { wasFreed: bool, previousAllocationTrailer: u31 };
	backingAllocator: NeverFailingAllocator,
	buffer: []align(4096) u8,
	index: usize,

	pub fn init(backingAllocator: NeverFailingAllocator, size: u31) StackAllocator {
		return .{
			.backingAllocator = backingAllocator,
			.buffer = backingAllocator.alignedAlloc(u8, .fromByteUnits(4096), size),
			.index = 0,
		};
	}

	pub fn deinit(self: StackAllocator) void {
		if (self.index != 0) {
			std.log.err("Memory leak in Stack Allocator", .{});
		}
		self.backingAllocator.free(self.buffer);
	}

	pub fn allocator(self: *StackAllocator) NeverFailingAllocator {
		return .{
			.allocator = .{
				.vtable = &.{
					.alloc = &alloc,
					.resize = &resize,
					.remap = &remap,
					.free = &free,
				},
				.ptr = self,
			},
			.IAssertThatTheProvidedAllocatorCantFail = {},
		};
	}

	fn isInsideBuffer(self: *StackAllocator, buf: []u8) bool {
		const bufferStart = @intFromPtr(self.buffer.ptr);
		const bufferEnd = bufferStart + self.buffer.len;
		const compare = @intFromPtr(buf.ptr);
		return compare >= bufferStart and compare < bufferEnd;
	}

	fn indexInBuffer(self: *StackAllocator, buf: []u8) usize {
		const bufferStart = @intFromPtr(self.buffer.ptr);
		const compare = @intFromPtr(buf.ptr);
		return compare - bufferStart;
	}

	fn getTrueAllocationEnd(start: usize, len: usize) usize {
		const trailerStart = std.mem.alignForward(usize, start + len, @alignOf(AllocationTrailer));
		return trailerStart + @sizeOf(AllocationTrailer);
	}

	fn getTrailerBefore(self: *StackAllocator, end: usize) *AllocationTrailer {
		const trailerStart = end - @sizeOf(AllocationTrailer);
		return @ptrCast(@alignCast(self.buffer[trailerStart..].ptr));
	}

	fn alloc(ctx: *anyopaque, len: usize, alignment: std.mem.Alignment, ret_addr: usize) ?[*]u8 {
		const self: *StackAllocator = @ptrCast(@alignCast(ctx));
		const start = std.mem.alignForward(usize, self.index, @as(usize, 1) << @intCast(@intFromEnum(alignment)));
		const end = getTrueAllocationEnd(start, len);
		if (end >= self.buffer.len) return self.backingAllocator.rawAlloc(len, alignment, ret_addr);
		const trailer = self.getTrailerBefore(end);
		trailer.* = .{.wasFreed = false, .previousAllocationTrailer = @intCast(self.index)};
		self.index = end;
		return self.buffer.ptr + start;
	}

	fn resize(ctx: *anyopaque, memory: []u8, alignment: std.mem.Alignment, new_len: usize, ret_addr: usize) bool {
		const self: *StackAllocator = @ptrCast(@alignCast(ctx));
		if (self.isInsideBuffer(memory)) {
			const start = self.indexInBuffer(memory);
			const end = getTrueAllocationEnd(start, memory.len);
			if (end != self.index) return false;
			const newEnd = getTrueAllocationEnd(start, new_len);
			if (newEnd >= self.buffer.len) return false;

			const trailer = self.getTrailerBefore(end);
			std.debug.assert(!trailer.wasFreed);
			const newTrailer = self.getTrailerBefore(newEnd);

			newTrailer.* = .{.wasFreed = false, .previousAllocationTrailer = trailer.previousAllocationTrailer};
			self.index = newEnd;
			return true;
		} else {
			return self.backingAllocator.rawResize(memory, alignment, new_len, ret_addr);
		}
	}

	fn remap(ctx: *anyopaque, memory: []u8, alignment: std.mem.Alignment, new_len: usize, ret_addr: usize) ?[*]u8 {
		if (resize(ctx, memory, alignment, new_len, ret_addr)) return memory.ptr;
		return null;
	}

	fn free(ctx: *anyopaque, memory: []u8, alignment: std.mem.Alignment, ret_addr: usize) void {
		const self: *StackAllocator = @ptrCast(@alignCast(ctx));
		if (self.isInsideBuffer(memory)) {
			const start = self.indexInBuffer(memory);
			const end = getTrueAllocationEnd(start, memory.len);
			const trailer = self.getTrailerBefore(end);
			std.debug.assert(!trailer.wasFreed); // Double Free

			if (end == self.index) {
				self.index = trailer.previousAllocationTrailer;
				if (self.index != 0) {
					var previousTrailer = self.getTrailerBefore(trailer.previousAllocationTrailer);
					while (previousTrailer.wasFreed) {
						self.index = previousTrailer.previousAllocationTrailer;
						if (self.index == 0) break;
						previousTrailer = self.getTrailerBefore(previousTrailer.previousAllocationTrailer);
					}
				}
			}
			trailer.wasFreed = true;
		} else {
			self.backingAllocator.rawFree(memory, alignment, ret_addr);
		}
	}
};

/// An allocator that handles OutOfMemory situations by panicing or freeing memory(TODO), making it safe to ignore errors.
pub const ErrorHandlingAllocator = struct { // MARK: ErrorHandlingAllocator
	backingAllocator: Allocator,

	pub fn init(backingAllocator: Allocator) ErrorHandlingAllocator {
		return .{
			.backingAllocator = backingAllocator,
		};
	}

	pub fn allocator(self: *ErrorHandlingAllocator) NeverFailingAllocator {
		return .{
			.allocator = .{
				.vtable = &.{
					.alloc = &alloc,
					.resize = &resize,
					.remap = &remap,
					.free = &free,
				},
				.ptr = self,
			},
			.IAssertThatTheProvidedAllocatorCantFail = {},
		};
	}

	fn handleError() noreturn {
		@panic("Out Of Memory. Please download more RAM, reduce the render distance, or close some of your 100 browser tabs.");
	}

	/// Return a pointer to `len` bytes with specified `alignment`, or return
	/// `null` indicating the allocation failed.
	///
	/// `ret_addr` is optionally provided as the first return address of the
	/// allocation call stack. If the value is `0` it means no return address
	/// has been provided.
	fn alloc(ctx: *anyopaque, len: usize, alignment: std.mem.Alignment, ret_addr: usize) ?[*]u8 {
		const self: *ErrorHandlingAllocator = @ptrCast(@alignCast(ctx));
		return self.backingAllocator.rawAlloc(len, alignment, ret_addr) orelse handleError();
	}

	/// Attempt to expand or shrink memory in place.
	///
	/// `memory.len` must equal the length requested from the most recent
	/// successful call to `alloc`, `resize`, or `remap`. `alignment` must
	/// equal the same value that was passed as the `alignment` parameter to
	/// the original `alloc` call.
	///
	/// A result of `true` indicates the resize was successful and the
	/// allocation now has the same address but a size of `new_len`. `false`
	/// indicates the resize could not be completed without moving the
	/// allocation to a different address.
	///
	/// `new_len` must be greater than zero.
	///
	/// `ret_addr` is optionally provided as the first return address of the
	/// allocation call stack. If the value is `0` it means no return address
	/// has been provided.
	fn resize(ctx: *anyopaque, memory: []u8, alignment: std.mem.Alignment, new_len: usize, ret_addr: usize) bool {
		const self: *ErrorHandlingAllocator = @ptrCast(@alignCast(ctx));
		return self.backingAllocator.rawResize(memory, alignment, new_len, ret_addr);
	}

	/// Attempt to expand or shrink memory, allowing relocation.
	///
	/// `memory.len` must equal the length requested from the most recent
	/// successful call to `alloc`, `resize`, or `remap`. `alignment` must
	/// equal the same value that was passed as the `alignment` parameter to
	/// the original `alloc` call.
	///
	/// A non-`null` return value indicates the resize was successful. The
	/// allocation may have same address, or may have been relocated. In either
	/// case, the allocation now has size of `new_len`. A `null` return value
	/// indicates that the resize would be equivalent to allocating new memory,
	/// copying the bytes from the old memory, and then freeing the old memory.
	/// In such case, it is more efficient for the caller to perform the copy.
	///
	/// `new_len` must be greater than zero.
	///
	/// `ret_addr` is optionally provided as the first return address of the
	/// allocation call stack. If the value is `0` it means no return address
	/// has been provided.
	fn remap(ctx: *anyopaque, memory: []u8, alignment: std.mem.Alignment, new_len: usize, ret_addr: usize) ?[*]u8 {
		const self: *ErrorHandlingAllocator = @ptrCast(@alignCast(ctx));
		return self.backingAllocator.rawRemap(memory, alignment, new_len, ret_addr);
	}

	/// Free and invalidate a region of memory.
	///
	/// `memory.len` must equal the length requested from the most recent
	/// successful call to `alloc`, `resize`, or `remap`. `alignment` must
	/// equal the same value that was passed as the `alignment` parameter to
	/// the original `alloc` call.
	///
	/// `ret_addr` is optionally provided as the first return address of the
	/// allocation call stack. If the value is `0` it means no return address
	/// has been provided.
	fn free(ctx: *anyopaque, memory: []u8, alignment: std.mem.Alignment, ret_addr: usize) void {
		const self: *ErrorHandlingAllocator = @ptrCast(@alignCast(ctx));
		self.backingAllocator.rawFree(memory, alignment, ret_addr);
	}
};

/// An allocator interface signaling that you can use
pub const NeverFailingAllocator = struct { // MARK: NeverFailingAllocator
	allocator: Allocator,
	IAssertThatTheProvidedAllocatorCantFail: void,

	const Alignment = std.mem.Alignment;
	const math = std.math;

	/// This function is not intended to be called except from within the
	/// implementation of an `Allocator`.
	pub inline fn rawAlloc(a: NeverFailingAllocator, len: usize, alignment: Alignment, ret_addr: usize) ?[*]u8 {
		return a.allocator.vtable.alloc(a.allocator.ptr, len, alignment, ret_addr);
	}

	/// This function is not intended to be called except from within the
	/// implementation of an `Allocator`.
	pub inline fn rawResize(a: NeverFailingAllocator, memory: []u8, alignment: Alignment, new_len: usize, ret_addr: usize) bool {
		return a.allocator.vtable.resize(a.allocator.ptr, memory, alignment, new_len, ret_addr);
	}

	/// This function is not intended to be called except from within the
	/// implementation of an `Allocator`.
	pub inline fn rawRemap(a: NeverFailingAllocator, memory: []u8, alignment: Alignment, new_len: usize, ret_addr: usize) ?[*]u8 {
		return a.allocator.vtable.remap(a.allocator.ptr, memory, alignment, new_len, ret_addr);
	}

	/// This function is not intended to be called except from within the
	/// implementation of an `Allocator`.
	pub inline fn rawFree(a: NeverFailingAllocator, memory: []u8, alignment: Alignment, ret_addr: usize) void {
		return a.allocator.vtable.free(a.allocator.ptr, memory, alignment, ret_addr);
	}

	/// Returns a pointer to undefined memory.
	/// Call `destroy` with the result to free the memory.
	pub fn create(self: NeverFailingAllocator, comptime T: type) *T {
		return self.allocator.create(T) catch unreachable;
	}

	/// `ptr` should be the return value of `create`, or otherwise
	/// have the same address and alignment property.
	pub fn destroy(self: NeverFailingAllocator, ptr: anytype) void {
		self.allocator.destroy(ptr);
	}

	/// Allocates an array of `n` items of type `T` and sets all the
	/// items to `undefined`. Depending on the Allocator
	/// implementation, it may be required to call `free` once the
	/// memory is no longer needed, to avoid a resource leak. If the
	/// `Allocator` implementation is unknown, then correct code will
	/// call `free` when done.
	///
	/// For allocating a single item, see `create`.
	pub fn alloc(self: NeverFailingAllocator, comptime T: type, n: usize) []T {
		return self.allocator.alloc(T, n) catch unreachable;
	}

	pub fn allocWithOptions(
		self: NeverFailingAllocator,
		comptime Elem: type,
		n: usize,
		/// null means naturally aligned
		comptime optional_alignment: ?u29,
		comptime optional_sentinel: ?Elem,
	) AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel) {
		return self.allocator.allocWithOptions(Elem, n, optional_alignment, optional_sentinel) catch unreachable;
	}

	pub fn allocWithOptionsRetAddr(
		self: NeverFailingAllocator,
		comptime Elem: type,
		n: usize,
		/// null means naturally aligned
		comptime optional_alignment: ?u29,
		comptime optional_sentinel: ?Elem,
		return_address: usize,
	) AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel) {
		return self.allocator.allocWithOptionsRetAddr(Elem, n, optional_alignment, optional_sentinel, return_address) catch unreachable;
	}

	fn AllocWithOptionsPayload(comptime Elem: type, comptime alignment: ?u29, comptime sentinel: ?Elem) type {
		if (sentinel) |s| {
			return [:s]align(alignment orelse @alignOf(Elem)) Elem;
		} else {
			return []align(alignment orelse @alignOf(Elem)) Elem;
		}
	}

	/// Allocates an array of `n + 1` items of type `T` and sets the first `n`
	/// items to `undefined` and the last item to `sentinel`. Depending on the
	/// Allocator implementation, it may be required to call `free` once the
	/// memory is no longer needed, to avoid a resource leak. If the
	/// `Allocator` implementation is unknown, then correct code will
	/// call `free` when done.
	///
	/// For allocating a single item, see `create`.
	pub fn allocSentinel(
		self: NeverFailingAllocator,
		comptime Elem: type,
		n: usize,
		comptime sentinel: Elem,
	) [:sentinel]Elem {
		return self.allocator.allocSentinel(Elem, n, sentinel) catch unreachable;
	}

	pub fn alignedAlloc(
		self: NeverFailingAllocator,
		comptime T: type,
		/// null means naturally aligned
		comptime alignment: ?Alignment,
		n: usize,
	) []align(if (alignment) |a| a.toByteUnits() else @alignOf(T)) T {
		return self.allocator.alignedAlloc(T, alignment, n) catch unreachable;
	}

	pub inline fn allocAdvancedWithRetAddr(
		self: NeverFailingAllocator,
		comptime T: type,
		/// null means naturally aligned
		comptime alignment: ?Alignment,
		n: usize,
		return_address: usize,
	) []align(if (alignment) |a| a.toByteUnits() else @alignOf(T)) T {
		return self.allocator.allocAdvancedWithRetAddr(T, alignment, n, return_address) catch unreachable;
	}

	fn allocWithSizeAndAlignment(self: NeverFailingAllocator, comptime size: usize, comptime alignment: u29, n: usize, return_address: usize) [*]align(alignment) u8 {
		return self.allocator.allocWithSizeAndAlignment(alignment, size, alignment, n, return_address) catch unreachable;
	}

	fn allocBytesWithAlignment(self: NeverFailingAllocator, comptime alignment: u29, byte_count: usize, return_address: usize) [*]align(alignment) u8 {
		return self.allocator.allocBytesWithAlignment(alignment, byte_count, return_address) catch unreachable;
	}

	/// Request to modify the size of an allocation.
	///
	/// It is guaranteed to not move the pointer, however the allocator
	/// implementation may refuse the resize request by returning `false`.
	///
	/// `allocation` may be an empty slice, in which case a new allocation is made.
	///
	/// `new_len` may be zero, in which case the allocation is freed.
	pub fn resize(self: NeverFailingAllocator, allocation: anytype, new_len: usize) bool {
		return self.allocator.resize(allocation, new_len);
	}

	/// Request to modify the size of an allocation, allowing relocation.
	///
	/// A non-`null` return value indicates the resize was successful. The
	/// allocation may have same address, or may have been relocated. In either
	/// case, the allocation now has size of `new_len`. A `null` return value
	/// indicates that the resize would be equivalent to allocating new memory,
	/// copying the bytes from the old memory, and then freeing the old memory.
	/// In such case, it is more efficient for the caller to perform those
	/// operations.
	///
	/// `allocation` may be an empty slice, in which case a new allocation is made.
	///
	/// `new_len` may be zero, in which case the allocation is freed.
	pub fn remap(self: NeverFailingAllocator, allocation: anytype, new_len: usize) t: {
		const Slice = @typeInfo(@TypeOf(allocation)).pointer;
		break :t ?[]align(Slice.alignment) Slice.child;
	} {
		return self.allocator.remap(allocation, new_len);
	}

	/// This function requests a new byte size for an existing allocation, which
	/// can be larger, smaller, or the same size as the old memory allocation.
	///
	/// If `new_n` is 0, this is the same as `free` and it always succeeds.
	///
	/// `old_mem` may have length zero, which makes a new allocation.
	///
	/// This function only fails on out-of-memory conditions, unlike:
	/// * `remap` which returns `null` when the `Allocator` implementation cannot
	///   do the realloc more efficiently than the caller
	/// * `resize` which returns `false` when the `Allocator` implementation cannot
	///   change the size without relocating the allocation.
	pub fn realloc(self: NeverFailingAllocator, old_mem: anytype, new_n: usize) t: {
		const Slice = @typeInfo(@TypeOf(old_mem)).pointer;
		break :t []align(Slice.alignment) Slice.child;
	} {
		return self.allocator.realloc(old_mem, new_n) catch unreachable;
	}

	pub fn reallocAdvanced(
		self: NeverFailingAllocator,
		old_mem: anytype,
		new_n: usize,
		return_address: usize,
	) t: {
		const Slice = @typeInfo(@TypeOf(old_mem)).pointer;
		break :t []align(Slice.alignment) Slice.child;
	} {
		return self.allocator.reallocAdvanced(old_mem, new_n, return_address) catch unreachable;
	}

	/// Free an array allocated with `alloc`.
	/// If memory has length 0, free is a no-op.
	/// To free a single item, see `destroy`.
	pub fn free(self: NeverFailingAllocator, memory: anytype) void {
		self.allocator.free(memory);
	}

	/// Copies `m` to newly allocated memory. Caller owns the memory.
	pub fn dupe(self: NeverFailingAllocator, comptime T: type, m: []const T) []T {
		return self.allocator.dupe(T, m) catch unreachable;
	}

	/// Copies `m` to newly allocated memory, with a null-terminated element. Caller owns the memory.
	pub fn dupeZ(self: NeverFailingAllocator, comptime T: type, m: []const T) [:0]T {
		return self.allocator.dupeZ(T, m) catch unreachable;
	}

	pub fn createArena(self: NeverFailingAllocator) NeverFailingAllocator {
		const arenaPtr = self.create(NeverFailingArenaAllocator);
		arenaPtr.* = NeverFailingArenaAllocator.init(self);
		return arenaPtr.allocator();
	}

	pub fn destroyArena(self: NeverFailingAllocator, arena: NeverFailingAllocator) void {
		const arenaAllocatorPtr: *NeverFailingArenaAllocator = @ptrCast(@alignCast(arena.allocator.ptr));
		arenaAllocatorPtr.deinit();
		self.destroy(arenaAllocatorPtr);
	}
};

pub const NeverFailingArenaAllocator = struct { // MARK: NeverFailingArena
	arena: std.heap.ArenaAllocator,

	pub fn init(childAllocator: NeverFailingAllocator) NeverFailingArenaAllocator {
		return .{
			.arena = .init(childAllocator.allocator),
		};
	}

	pub fn deinit(self: NeverFailingArenaAllocator) void {
		self.arena.deinit();
	}

	pub fn allocator(self: *NeverFailingArenaAllocator) NeverFailingAllocator {
		return .{
			.allocator = self.arena.allocator(),
			.IAssertThatTheProvidedAllocatorCantFail = {},
		};
	}

	/// Resets the arena allocator and frees all allocated memory.
	///
	/// `mode` defines how the currently allocated memory is handled.
	/// See the variant documentation for `ResetMode` for the effects of each mode.
	///
	/// The function will return whether the reset operation was successful or not.
	/// If the reallocation  failed `false` is returned. The arena will still be fully
	/// functional in that case, all memory is released. Future allocations just might
	/// be slower.
	///
	/// NOTE: If `mode` is `free_all`, the function will always return `true`.
	pub fn reset(self: *NeverFailingArenaAllocator, mode: std.heap.ArenaAllocator.ResetMode) bool {
		return self.arena.reset(mode);
	}

	pub fn shrinkAndFree(self: *NeverFailingArenaAllocator) void {
		if (true) return;
		const node = self.arena.state.buffer_list.first orelse return;
		const allocBuf = @as([*]u8, @ptrCast(node))[0..node.data];
		const dataSize = std.mem.alignForward(usize, @sizeOf(std.SinglyLinkedList(usize).Node) + self.arena.state.end_index, @alignOf(std.SinglyLinkedList(usize).Node));
		if (self.arena.childAllocator.rawResize(allocBuf, @enumFromInt(std.math.log2(@alignOf(std.SinglyLinkedList(usize).Node))), dataSize, @returnAddress())) {
			node.data = dataSize;
		}
	}
};

pub fn ThreadSafeAllocator(ChildAllocatorType: type) type { // MARK: ThreadSafeAllocator
	std.debug.assert(@TypeOf(ChildAllocatorType.allocator(undefined)) == NeverFailingAllocator);

	return struct {
		child: ChildAllocatorType,
		mutex: std.Thread.Mutex = .{},

		pub fn init(childAllocator: ChildAllocatorType) @This() {
			return .{
				.child = childAllocator,
			};
		}

		pub fn deinit(self: @This()) void {
			self.child.deinit();
		}

		pub fn allocator(self: *@This()) NeverFailingAllocator {
			return .{
				.allocator = .{
					.ptr = self,
					.vtable = &.{
						.alloc = alloc,
						.resize = resize,
						.remap = remap,
						.free = free,
					},
				},
				.IAssertThatTheProvidedAllocatorCantFail = {},
			};
		}

		pub fn swapChild(self: *@This(), other: *ChildAllocatorType) void {
			self.mutex.lock();
			defer self.mutex.unlock();
			std.mem.swap(ChildAllocatorType, &self.child, other);
		}

		fn alloc(context: *anyopaque, n: usize, alignment: std.mem.Alignment, ra: usize) ?[*]u8 {
			const self: *@This() = @ptrCast(@alignCast(context));

			self.mutex.lock();
			defer self.mutex.unlock();

			return self.child.allocator().rawAlloc(n, alignment, ra);
		}

		fn resize(context: *anyopaque, buf: []u8, alignment: std.mem.Alignment, new_len: usize, ret_addr: usize) bool {
			const self: *@This() = @ptrCast(@alignCast(context));

			self.mutex.lock();
			defer self.mutex.unlock();

			return self.child.allocator().rawResize(buf, alignment, new_len, ret_addr);
		}

		fn remap(context: *anyopaque, memory: []u8, alignment: std.mem.Alignment, new_len: usize, return_address: usize) ?[*]u8 {
			const self: *@This() = @ptrCast(@alignCast(context));

			self.mutex.lock();
			defer self.mutex.unlock();

			return self.child.allocator().rawRemap(memory, alignment, new_len, return_address);
		}

		fn free(context: *anyopaque, buf: []u8, alignment: std.mem.Alignment, ret_addr: usize) void {
			const self: *@This() = @ptrCast(@alignCast(context));

			self.mutex.lock();
			defer self.mutex.unlock();

			return self.child.allocator().rawFree(buf, alignment, ret_addr);
		}
	};
}

/// basically a copy of std.heap.MemoryPool, except it's thread-safe and has some more diagnostics.
pub fn MemoryPool(Item: type) type { // MARK: MemoryPool
	return struct {
		const Pool = @This();

		/// Size of the memory pool items. This is not necessarily the same
		/// as `@sizeOf(Item)` as the pool also uses the items for internal means.
		pub const item_size = @max(@sizeOf(Node), @sizeOf(Item));

		// This needs to be kept in sync with Node.
		const node_alignment = @alignOf(*anyopaque);

		/// Alignment of the memory pool items. This is not necessarily the same
		/// as `@alignOf(Item)` as the pool also uses the items for internal means.
		pub const item_alignment = @max(node_alignment, @alignOf(Item));

		const Node = struct {
			next: ?*align(item_alignment) @This(),
		};
		const NodePtr = *align(item_alignment) Node;
		const ItemPtr = *align(item_alignment) Item;

		arena: NeverFailingArenaAllocator,
		free_list: ?NodePtr = null,
		freeAllocations: usize = 0,
		totalAllocations: usize = 0,
		mutex: std.Thread.Mutex = .{},

		/// Creates a new memory pool.
		pub fn init(allocator: NeverFailingAllocator) Pool {
			return .{.arena = NeverFailingArenaAllocator.init(allocator)};
		}

		/// Destroys the memory pool and frees all allocated memory.
		pub fn deinit(pool: *Pool) void {
			if (pool.freeAllocations != pool.totalAllocations) {
				std.log.err("Memory pool of type {s} leaked {} elements", .{@typeName(Item), pool.totalAllocations - pool.freeAllocations});
			} else if (pool.totalAllocations != 0) {
				std.log.info("{} MiB ({} elements) in {s} Memory pool", .{pool.totalAllocations*item_size >> 20, pool.totalAllocations, @typeName(Item)});
			}
			pool.arena.deinit();
			pool.* = undefined;
		}

		/// Creates a new item and adds it to the memory pool.
		pub fn create(pool: *Pool) ItemPtr {
			pool.mutex.lock();
			defer pool.mutex.unlock();
			const node = if (pool.free_list) |item| blk: {
				pool.free_list = item.next;
				break :blk item;
			} else @as(NodePtr, @ptrCast(pool.allocNew()));

			pool.freeAllocations -= 1;
			const ptr = @as(ItemPtr, @ptrCast(node));
			ptr.* = undefined;
			return ptr;
		}

		/// Destroys a previously created item.
		/// Only pass items to `ptr` that were previously created with `create()` of the same memory pool!
		pub fn destroy(pool: *Pool, ptr: ItemPtr) void {
			pool.mutex.lock();
			defer pool.mutex.unlock();
			ptr.* = undefined;

			const node = @as(NodePtr, @ptrCast(ptr));
			node.* = Node{
				.next = pool.free_list,
			};
			pool.free_list = node;
			pool.freeAllocations += 1;
		}

		fn allocNew(pool: *Pool) *align(item_alignment) [item_size]u8 {
			main.utils.assertLocked(&pool.mutex);
			pool.totalAllocations += 1;
			pool.freeAllocations += 1;
			const mem = pool.arena.allocator().alignedAlloc(u8, .fromByteUnits(item_alignment), item_size);
			return mem[0..item_size]; // coerce slice to array pointer
		}
	};
}

pub const GarbageCollection = struct { // MARK: GarbageCollection
	var sharedState: std.atomic.Value(u32) = .init(0);
	threadlocal var threadCycle: u2 = undefined;
	threadlocal var lastSyncPointTime: std.Io.Timestamp = undefined;
	const FreeItem = struct {
		ptr: *anyopaque,
		freeFunction: *const fn (*anyopaque) void,
	};
	threadlocal var lists: [4]main.ListUnmanaged(FreeItem) = undefined;

	const State = packed struct {
		waitingThreads: u15 = 0,
		totalThreads: u15 = 0,
		cycle: u2 = 0,
	};

	pub fn addThread() void {
		const old: State = @bitCast(sharedState.fetchAdd(@bitCast(State{.totalThreads = 1}), .monotonic));
		_ = old.totalThreads + 1; // Assert no overflow
		threadCycle = old.cycle;
		lastSyncPointTime = main.timestamp();
		for (&lists) |*list| {
			list.* = .initCapacity(main.globalAllocator, 1024);
		}
		if (old.waitingThreads == 0) {
			startNewCycle();
		}
	}

	fn freeItemsFromList(list: *main.ListUnmanaged(FreeItem)) void {
		while (list.popOrNull()) |item| {
			item.freeFunction(item.ptr);
		}
	}

	pub fn removeThread() void {
		const old: State = @bitCast(sharedState.fetchSub(@bitCast(State{.totalThreads = 1}), .monotonic));
		_ = old.totalThreads - 1; // Assert no overflow
		if (old.cycle != threadCycle) removeThreadFromWaiting();
		const newTime = main.timestamp();
		if (lastSyncPointTime.durationTo(newTime).toSeconds() > 20) {
			if (!build_options.isTaggedRelease) {
				std.log.err("No sync point executed in {} ms for thread. Did you forget to add a sync point in the thread's main loop?", .{lastSyncPointTime.durationTo(newTime).toMilliseconds()});
				std.debug.dumpCurrentStackTrace(.{});
			}
		}
		for (&lists) |*list| {
			freeItemsFromList(list);
			list.deinit(main.globalAllocator);
		}
	}

	pub fn assertAllThreadsStopped() void {
		std.debug.assert(sharedState.load(.monotonic) & 0x3fffffff == 0);
	}

	fn startNewCycle() void {
		var cur = sharedState.load(.monotonic);
		while (true) {
			var new: State = @bitCast(cur);
			new.waitingThreads = new.totalThreads;
			new.cycle +%= 1;
			cur = sharedState.cmpxchgWeak(cur, @bitCast(new), .monotonic, .monotonic) orelse break;
		}
	}

	fn removeThreadFromWaiting() void {
		const old: State = @bitCast(sharedState.fetchSub(@bitCast(State{.waitingThreads = 1}), .acq_rel));
		_ = old.waitingThreads - 1; // Assert no overflow
		threadCycle = old.cycle;

		if (old.waitingThreads == 1) startNewCycle();
	}

	/// Must be called when no objects originating from other threads are held on the current function stack
	pub fn syncPoint() void {
		const newTime = main.timestamp();
		if (lastSyncPointTime.durationTo(newTime).toSeconds() > 20) {
			std.log.err("No sync point executed in {} ms. Did you forget to add a sync point in the thread's main loop", .{lastSyncPointTime.durationTo(newTime).toMilliseconds()});
			std.debug.dumpCurrentStackTrace(.{});
		}
		lastSyncPointTime = newTime;

		const old: State = @bitCast(sharedState.load(.monotonic));
		if (old.cycle == threadCycle) return;
		removeThreadFromWaiting();
		freeItemsFromList(&lists[threadCycle]);
		// TODO: Free all the data here and swap lists
	}

	pub fn deferredFree(item: FreeItem) void {
		lists[threadCycle].append(main.globalAllocator, item);
	}

	/// Waits until all deferred frees have been completed.
	pub fn waitForFreeCompletion() void {
		const startCycle = threadCycle;
		while (threadCycle == startCycle) {
			syncPoint();
			main.io.sleep(.fromMilliseconds(1), .awake) catch {};
		}
		while (threadCycle != startCycle) {
			syncPoint();
			main.io.sleep(.fromMilliseconds(1), .awake) catch {};
		}
	}
};

pub fn PowerOfTwoPoolAllocator(minSize: comptime_int, maxSize: comptime_int, maxAlignment: comptime_int) type { // MARK: PowerOfTwoPoolAllocator
	std.debug.assert(std.math.isPowerOfTwo(minSize));
	std.debug.assert(std.math.isPowerOfTwo(maxSize));
	std.debug.assert(maxSize > minSize);
	std.debug.assert(minSize >= maxAlignment);
	std.debug.assert(minSize >= @sizeOf(usize));

	const alignment = @max(maxAlignment, @sizeOf(usize));

	const baseShift = std.math.log2_int(usize, minSize);
	const bucketCount = std.math.log2_int(usize, maxSize) - baseShift + 1;
	return struct {
		const Self = @This();

		const Node = struct {
			next: ?*align(alignment) @This(),
		};
		const NodePtr = *align(alignment) Node;

		const Bucket = struct {
			freeLists: ?*align(alignment) Node = null,
			freeAllocations: usize = 0,
			totalAllocations: usize = 0,

			pub fn deinit(self: *Bucket, size: usize) void {
				if (self.freeAllocations != self.totalAllocations) {
					std.log.err("PowerOfTwoPoolAllocator bucket of size {} leaked {} elements", .{size, self.totalAllocations - self.freeAllocations});
				} else if (self.totalAllocations != 0) {
					std.log.info("{} MiB ({} elements) in size {} PowerOfTwoPoolAllocator bucket", .{self.totalAllocations*size >> 20, self.totalAllocations, size});
				}
				self.* = undefined;
			}

			/// Creates a new item and adds it to the memory pool.
			pub fn create(self: *Bucket, arena: NeverFailingAllocator, size: usize) [*]u8 {
				const node = if (self.freeLists) |item| blk: {
					self.freeLists = item.next;
					break :blk item;
				} else @as(NodePtr, @ptrCast(self.allocNew(arena, size)));

				self.freeAllocations -= 1;
				return @ptrCast(node);
			}

			/// Destroys a previously created item.
			/// Only pass items to `ptr` that were previously created with `create()` of the same memory pool!
			pub fn destroy(self: *Bucket, ptr: [*]u8) void {
				const node = @as(NodePtr, @ptrCast(@alignCast(ptr)));
				node.* = Node{
					.next = self.freeLists,
				};
				self.freeLists = node;
				self.freeAllocations += 1;
			}

			fn allocNew(self: *Bucket, arena: NeverFailingAllocator, size: usize) [*]align(alignment) u8 {
				self.totalAllocations += 1;
				self.freeAllocations += 1;
				return arena.alignedAlloc(u8, .fromByteUnits(alignment), size).ptr;
			}
		};

		arena: NeverFailingArenaAllocator,
		buckets: [bucketCount]Bucket = @splat(.{}),
		mutex: std.Thread.Mutex = .{},

		pub fn init(backingAllocator: NeverFailingAllocator) Self {
			return .{.arena = .init(backingAllocator)};
		}

		pub fn deinit(self: *Self) void {
			for (&self.buckets, 0..) |*bucket, i| {
				bucket.deinit(@as(usize, minSize) << @intCast(i));
			}
			self.arena.deinit();
		}

		pub fn allocator(self: *Self) NeverFailingAllocator {
			return .{
				.allocator = .{
					.vtable = &.{
						.alloc = &alloc,
						.resize = &resize,
						.remap = &remap,
						.free = &free,
					},
					.ptr = self,
				},
				.IAssertThatTheProvidedAllocatorCantFail = {},
			};
		}

		fn alloc(ctx: *anyopaque, len: usize, _alignment: std.mem.Alignment, _: usize) ?[*]u8 {
			std.debug.assert(@as(usize, 1) << @intFromEnum(_alignment) <= maxAlignment);
			std.debug.assert(std.math.isPowerOfTwo(len));
			std.debug.assert(len >= minSize);
			std.debug.assert(len <= maxSize);
			const self: *Self = @ptrCast(@alignCast(ctx));
			const bucket = @ctz(len) - baseShift;
			self.mutex.lock();
			defer self.mutex.unlock();
			return self.buckets[bucket].create(self.arena.allocator(), len);
		}

		fn resize(_: *anyopaque, _: []u8, _: std.mem.Alignment, _: usize, _: usize) bool {
			return false;
		}

		fn remap(_: *anyopaque, _: []u8, _: std.mem.Alignment, _: usize, _: usize) ?[*]u8 {
			return null;
		}

		fn free(ctx: *anyopaque, memory: []u8, _alignment: std.mem.Alignment, _: usize) void {
			std.debug.assert(@as(usize, 1) << @intFromEnum(_alignment) <= maxAlignment);
			std.debug.assert(std.math.isPowerOfTwo(memory.len));
			const self: *Self = @ptrCast(@alignCast(ctx));
			const bucket = @ctz(memory.len) - baseShift;
			self.mutex.lock();
			defer self.mutex.unlock();
			self.buckets[bucket].destroy(memory.ptr);
		}
	};
}

```

`src/utils/list.zig`:

```zig
const std = @import("std");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;

fn growCapacity(current: usize, minimum: usize) usize {
	var new = current;
	while (true) {
		new +|= new/2 + 8;
		if (new >= minimum)
			return new;
	}
}

pub fn List(comptime T: type) type {
	return struct {
		items: []T = &.{},
		capacity: usize = 0,
		allocator: NeverFailingAllocator,

		pub fn init(allocator: NeverFailingAllocator) @This() {
			return .{
				.allocator = allocator,
			};
		}

		pub fn initCapacity(allocator: NeverFailingAllocator, capacity: usize) @This() {
			return .{
				.items = allocator.alloc(T, capacity)[0..0],
				.capacity = capacity,
				.allocator = allocator,
			};
		}

		pub fn deinit(self: @This()) void {
			if (self.capacity != 0) {
				self.allocator.free(self.items.ptr[0..self.capacity]);
			}
		}

		pub fn clearAndFree(self: *@This()) void {
			self.deinit();
			self.* = .{.allocator = self.allocator};
		}

		pub fn clearRetainingCapacity(self: *@This()) void {
			self.items.len = 0;
		}

		pub fn shrinkAndFree(self: *@This(), newLen: usize) void {
			const result = self.allocator.realloc(self.items.ptr[0..self.capacity], newLen);
			self.items.ptr = result.ptr;
			self.capacity = result.len;
		}

		pub fn toOwnedSlice(self: *@This()) []T {
			const result = self.allocator.realloc(self.items.ptr[0..self.capacity], self.items.len);
			self.* = .{.allocator = self.allocator};
			return result;
		}

		pub fn ensureCapacity(self: *@This(), newCapacity: usize) void {
			std.debug.assert(newCapacity >= self.items.len);
			const newAllocation = self.allocator.realloc(self.items.ptr[0..self.capacity], newCapacity);
			self.items.ptr = newAllocation.ptr;
			self.capacity = newAllocation.len;
		}

		fn ensureFreeCapacity(self: *@This(), freeCapacity: usize) void {
			if (freeCapacity + self.items.len <= self.capacity) return;
			self.ensureCapacity(growCapacity(self.capacity, freeCapacity + self.items.len));
		}

		pub fn resizeAssumeCapacity(self: *@This(), new_len: usize) void {
			self.items.len = new_len;
			std.debug.assert(self.items.len <= self.capacity);
		}

		pub fn resize(self: *@This(), new_len: usize) void {
			self.ensureCapacity(new_len);
			self.items.len = new_len;
		}

		pub fn addOneAssumeCapacity(self: *@This()) *T {
			self.items.len += 1;
			std.debug.assert(self.items.len <= self.capacity);
			return &self.items[self.items.len - 1];
		}

		pub fn addOne(self: *@This()) *T {
			self.ensureFreeCapacity(1);
			return self.addOneAssumeCapacity();
		}

		pub fn addManyAssumeCapacity(self: *@This(), n: usize) []T {
			self.items.len += n;
			std.debug.assert(self.items.len <= self.capacity);
			return self.items[self.items.len - n ..];
		}

		pub fn addMany(self: *@This(), n: usize) []T {
			self.ensureFreeCapacity(n);
			return self.addManyAssumeCapacity(n);
		}

		pub fn appendAssumeCapacity(self: *@This(), elem: T) void {
			self.addOneAssumeCapacity().* = elem;
		}

		pub fn append(self: *@This(), elem: T) void {
			self.addOne().* = elem;
		}

		pub fn appendNTimesAssumeCapacity(self: *@This(), elem: T, n: usize) void {
			@memset(self.addManyAssumeCapacity(n), elem);
		}

		pub fn appendNTimes(self: *@This(), elem: T, n: usize) void {
			@memset(self.addMany(n), elem);
		}

		pub fn appendSliceAssumeCapacity(self: *@This(), elems: []const T) void {
			@memcpy(self.addManyAssumeCapacity(elems.len), elems);
		}

		pub fn appendSlice(self: *@This(), elems: []const T) void {
			@memcpy(self.addMany(elems.len), elems);
		}

		pub fn insertAssumeCapacity(self: *@This(), i: usize, elem: T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.appendAssumeCapacity(elem);
			_ = self.addOneAssumeCapacity();
			std.mem.copyBackwards(T, self.items[i + 1 ..], self.items[0 .. self.items.len - 1][i..]);
			self.items[i] = elem;
		}

		pub fn insert(self: *@This(), i: usize, elem: T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.append(elem);
			_ = self.addOne();
			std.mem.copyBackwards(T, self.items[i + 1 ..], self.items[0 .. self.items.len - 1][i..]);
			self.items[i] = elem;
		}

		pub fn insertSliceAssumeCapacity(self: *@This(), i: usize, elems: []const T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.appendSliceAssumeCapacity(elems);
			_ = self.addManyAssumeCapacity(elems.len);
			std.mem.copyBackwards(T, self.items[i + elems.len ..], self.items[0 .. self.items.len - elems.len][i..]);
			@memcpy(self.items[i..][0..elems.len], elems);
		}

		pub fn insertSlice(self: *@This(), i: usize, elems: []const T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.appendSlice(elems);
			_ = self.addMany(elems.len);
			std.mem.copyBackwards(T, self.items[i + elems.len ..], self.items[0 .. self.items.len - elems.len][i..]);
			@memcpy(self.items[i..][0..elems.len], elems);
		}

		pub fn swapRemove(self: *@This(), i: usize) T {
			const old = self.items[i];
			self.items[i] = self.items[self.items.len - 1];
			self.items.len -= 1;
			return old;
		}

		pub fn orderedRemove(self: *@This(), i: usize) T {
			const newlen = self.items.len - 1;
			const old = self.items[i];
			for (self.items[i..newlen], i + 1..) |*b, j| b.* = self.items[j];
			self.items.len = newlen;
			return old;
		}

		pub fn popOrNull(self: *@This()) ?T {
			if (self.items.len == 0) return null;
			const val = self.items[self.items.len - 1];
			self.items.len -= 1;
			return val;
		}

		pub fn pop(self: *@This()) T {
			return self.popOrNull() orelse unreachable;
		}

		pub fn replaceRange(self: *@This(), start: usize, len: usize, new_items: []const T) void {
			const after_range = start + len;
			const range = self.items[start..after_range];

			if (range.len == new_items.len)
				@memcpy(range[0..new_items.len], new_items)
			else if (range.len < new_items.len) {
				const first = new_items[0..range.len];
				const rest = new_items[range.len..];

				@memcpy(range[0..first.len], first);
				self.insertSlice(after_range, rest);
			} else {
				@memcpy(range[0..new_items.len], new_items);
				const after_subrange = start + new_items.len;

				for (self.items[after_range..], 0..) |item, i| {
					self.items[after_subrange..][i] = item;
				}

				self.items.len -= len - new_items.len;
			}
		}

		pub fn print(self: *@This(), comptime fmt: []const u8, args: anytype) void {
			var writer = std.Io.Writer.Allocating.init(main.stackAllocator.allocator); // TODO: Is there no easier way to make this without an extra copy?
			defer writer.deinit();
			writer.writer.print(fmt, args) catch unreachable;
			self.appendSlice(writer.written());
		}
	};
}

pub fn ListUnmanaged(comptime T: type) type {
	return struct {
		items: []T = &.{},
		capacity: usize = 0,

		pub fn initCapacity(allocator: NeverFailingAllocator, capacity: usize) @This() {
			return .{
				.items = allocator.alloc(T, capacity)[0..0],
				.capacity = capacity,
			};
		}

		pub fn deinit(self: @This(), allocator: NeverFailingAllocator) void {
			if (self.capacity != 0) {
				allocator.free(self.items.ptr[0..self.capacity]);
			}
		}

		pub fn clearAndFree(self: *@This(), allocator: NeverFailingAllocator) void {
			self.deinit(allocator);
			self.* = .{};
		}

		pub fn clearRetainingCapacity(self: *@This()) void {
			self.items.len = 0;
		}

		pub fn shrinkAndFree(self: *@This(), allocator: NeverFailingAllocator, newLen: usize) void {
			const result = allocator.realloc(self.items.ptr[0..self.capacity], newLen);
			self.items.ptr = result.ptr;
			self.capacity = result.len;
		}

		pub fn toOwnedSlice(self: *@This(), allocator: NeverFailingAllocator) []T {
			const result = allocator.realloc(self.items.ptr[0..self.capacity], self.items.len);
			self.* = .{};
			return result;
		}

		pub fn ensureCapacity(self: *@This(), allocator: NeverFailingAllocator, newCapacity: usize) void {
			std.debug.assert(newCapacity >= self.items.len);
			const newAllocation = allocator.realloc(self.items.ptr[0..self.capacity], newCapacity);
			self.items.ptr = newAllocation.ptr;
			self.capacity = newAllocation.len;
		}

		pub fn ensureFreeCapacity(self: *@This(), allocator: NeverFailingAllocator, freeCapacity: usize) void {
			if (freeCapacity + self.items.len <= self.capacity) return;
			self.ensureCapacity(allocator, growCapacity(self.capacity, freeCapacity + self.items.len));
		}

		pub fn resizeAssumeCapacity(self: *@This(), new_len: usize) void {
			self.items.len = new_len;
			std.debug.assert(self.items.len <= self.capacity);
		}

		pub fn resize(self: *@This(), allocator: NeverFailingAllocator, new_len: usize) void {
			self.ensureCapacity(allocator, new_len);
			self.items.len = new_len;
		}

		pub fn addOneAssumeCapacity(self: *@This()) *T {
			self.items.len += 1;
			std.debug.assert(self.items.len <= self.capacity);
			return &self.items[self.items.len - 1];
		}

		pub fn addOne(self: *@This(), allocator: NeverFailingAllocator) *T {
			self.ensureFreeCapacity(allocator, 1);
			return self.addOneAssumeCapacity();
		}

		pub fn addManyAssumeCapacity(self: *@This(), n: usize) []T {
			self.items.len += n;
			std.debug.assert(self.items.len <= self.capacity);
			return self.items[self.items.len - n ..];
		}

		pub fn addMany(self: *@This(), allocator: NeverFailingAllocator, n: usize) []T {
			self.ensureFreeCapacity(allocator, n);
			return self.addManyAssumeCapacity(n);
		}

		pub fn appendAssumeCapacity(self: *@This(), elem: T) void {
			self.addOneAssumeCapacity().* = elem;
		}

		pub fn append(self: *@This(), allocator: NeverFailingAllocator, elem: T) void {
			self.addOne(allocator).* = elem;
		}

		pub fn appendNTimesAssumeCapacity(self: *@This(), elem: T, n: usize) void {
			@memset(self.addManyAssumeCapacity(n), elem);
		}

		pub fn appendNTimes(self: *@This(), allocator: NeverFailingAllocator, elem: T, n: usize) void {
			@memset(self.addMany(allocator, n), elem);
		}

		pub fn appendSliceAssumeCapacity(self: *@This(), elems: []const T) void {
			@memcpy(self.addManyAssumeCapacity(elems.len), elems);
		}

		pub fn appendSlice(self: *@This(), allocator: NeverFailingAllocator, elems: []const T) void {
			@memcpy(self.addMany(allocator, elems.len), elems);
		}

		pub fn insertAssumeCapacity(self: *@This(), i: usize, elem: T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.appendAssumeCapacity(elem);
			_ = self.addOneAssumeCapacity();
			std.mem.copyBackwards(T, self.items[i + 1 ..], self.items[0 .. self.items.len - 1][i..]);
			self.items[i] = elem;
		}

		pub fn insert(self: *@This(), i: usize, elem: T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.append(elem);
			_ = self.addOne();
			std.mem.copyBackwards(T, self.items[i + 1 ..], self.items[0 .. self.items.len - 1][i..]);
			self.items[i] = elem;
		}

		pub fn insertSliceAssumeCapacity(self: *@This(), i: usize, elems: []const T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.appendSliceAssumeCapacity(elems);
			_ = self.addManyAssumeCapacity(elems.len);
			std.mem.copyBackwards(T, self.items[i + elems.len ..], self.items[0 .. self.items.len - elems.len][i..]);
			@memcpy(self.items[i..][0..elems.len], elems);
		}

		pub fn insertSlice(self: *@This(), i: usize, elems: []const T) void {
			std.debug.assert(i <= self.items.len);
			if (i == self.items.len) return self.appendSlice(elems);
			_ = self.addMany(elems.len);
			std.mem.copyBackwards(T, self.items[i + elems.len ..], self.items[0 .. self.items.len - elems.len][i..]);
			@memcpy(self.items[i..][0..elems.len], elems);
		}

		pub fn swapRemove(self: *@This(), i: usize) T {
			const old = self.items[i];
			self.items[i] = self.items[self.items.len - 1];
			self.items.len -= 1;
			return old;
		}

		pub fn orderedRemove(self: *@This(), i: usize) T {
			const newlen = self.items.len - 1;
			const old = self.items[i];
			for (self.items[i..newlen], i + 1..) |*b, j| b.* = self.items[j];
			self.items.len = newlen;
			return old;
		}

		pub fn popOrNull(self: *@This()) ?T {
			if (self.items.len == 0) return null;
			const val = self.items[self.items.len - 1];
			self.items.len -= 1;
			return val;
		}

		pub fn pop(self: *@This()) T {
			return self.popOrNull() orelse unreachable;
		}

		pub fn replaceRange(self: *@This(), start: usize, len: usize, new_items: []const T) void {
			const after_range = start + len;
			const range = self.items[start..after_range];

			if (range.len == new_items.len)
				@memcpy(range[0..new_items.len], new_items)
			else if (range.len < new_items.len) {
				const first = new_items[0..range.len];
				const rest = new_items[range.len..];

				@memcpy(range[0..first.len], first);
				self.insertSlice(after_range, rest);
			} else {
				@memcpy(range[0..new_items.len], new_items);
				const after_subrange = start + new_items.len;

				for (self.items[after_range..], 0..) |item, i| {
					self.items[after_subrange..][i] = item;
				}

				self.items.len -= len - new_items.len;
			}
		}
	};
}

/// Holds multiple arrays sequentially in memory.
/// Allows addressing and remove each subarray individually, as well as iterating through all of them at once.
pub fn MultiArray(T: type, Range: type) type {
	const size = @typeInfo(Range).@"enum".fields.len;
	std.debug.assert(@typeInfo(Range).@"enum".is_exhaustive);
	for (@typeInfo(Range).@"enum".fields) |field| {
		std.debug.assert(field.value < size);
	}
	return struct {
		offsets: [size + 1]usize = @splat(0),
		items: [*]T = undefined,
		capacity: usize = 0,

		pub fn initCapacity(allocator: NeverFailingAllocator, capacity: usize) @This() {
			return .{
				.items = allocator.alloc(T, capacity)[0..0],
				.capacity = capacity,
			};
		}

		pub fn deinit(self: @This(), allocator: NeverFailingAllocator) void {
			if (self.capacity != 0) {
				allocator.free(self.items[0..self.capacity]);
			}
		}

		pub fn clearAndFree(self: *@This(), allocator: NeverFailingAllocator) void {
			self.deinit(allocator);
			self.* = .{};
		}

		pub fn clearRetainingCapacity(self: *@This()) void {
			self.offsets = @splat(0);
		}

		pub fn ensureCapacity(self: *@This(), allocator: NeverFailingAllocator, newCapacity: usize) void {
			if (newCapacity <= self.capacity) return;
			const newAllocation = allocator.realloc(self.items[0..self.capacity], newCapacity);
			self.items = newAllocation.ptr;
			self.capacity = newAllocation.len;
		}

		pub fn addMany(self: *@This(), allocator: NeverFailingAllocator, n: usize) []T {
			self.ensureFreeCapacity(allocator, n);
			return self.addManyAssumeCapacity(n);
		}

		pub fn replaceRange(self: *@This(), allocator: NeverFailingAllocator, range: Range, elems: []const T) void {
			const i: usize = @intFromEnum(range);
			const oldLen = self.offsets[i + 1] - self.offsets[i];
			self.ensureCapacity(allocator, self.offsets[size] - oldLen + elems.len);
			const startIndex = self.offsets[i + 1];
			const newStartIndex = self.offsets[i + 1] - oldLen + elems.len;
			const endIndex = self.offsets[size];
			const newEndIndex = self.offsets[size] - oldLen + elems.len;
			if (newStartIndex > startIndex) {
				std.mem.copyBackwards(T, self.items[newStartIndex..newEndIndex], self.items[startIndex..endIndex]);
			} else {
				std.mem.copyForwards(T, self.items[newStartIndex..newEndIndex], self.items[startIndex..endIndex]);
			}
			@memcpy(self.items[self.offsets[i]..][0..elems.len], elems);
			for (self.offsets[i + 1 ..]) |*offset| {
				offset.* = offset.* - oldLen + elems.len;
			}
		}

		pub fn getRange(self: *@This(), range: Range) []T {
			const i: usize = @intFromEnum(range);
			const startIndex = self.offsets[i];
			const endIndex = self.offsets[i + 1];
			return self.items[startIndex..endIndex];
		}

		pub fn getEverything(self: *@This()) []T {
			return self.items[0..self.offsets[size]];
		}
	};
}

```

`src/utils/version.zig`:

```zig
const std = @import("std");
const build_options = @import("build_options");

pub const version = build_options.version;

fn isCompatibleClientVersionImpl(clientVersion: []const u8, serverVersion: []const u8) !bool {
	if (std.mem.endsWith(u8, serverVersion, "-dev")) return true;
	if (std.mem.endsWith(u8, clientVersion, "-dev")) return false;

	const client = try std.SemanticVersion.parse(clientVersion);
	const server = try std.SemanticVersion.parse(serverVersion);

	return client.major == server.major and client.minor == server.minor;
}

pub fn isCompatibleClientVersion(clientVersion: []const u8) !bool {
	return isCompatibleClientVersionImpl(clientVersion, version);
}

test "version correctness" {
	_ = try std.SemanticVersion.parse(version);
}

test "dev version" {
	const serverVersion = "1054.11.423-dev";
	try std.testing.expect(try isCompatibleClientVersionImpl("0.3.1", serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl("100.0.0-dev", serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl("0.0.0-dev", serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl("1055.12.424", serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl(serverVersion, serverVersion));
}

test "release version" {
	const serverVersion = "4.5.6";
	try std.testing.expect(!try isCompatibleClientVersionImpl("0.3.1", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("100.0.0-dev", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("0.0.0-dev", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("1055.12.424", serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl(serverVersion, serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl("4.5.0", serverVersion));
	try std.testing.expect(try isCompatibleClientVersionImpl("4.5.10", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("4.6.6", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("4.4.6", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("3.5.6", serverVersion));
	try std.testing.expect(!try isCompatibleClientVersionImpl("5.5.6", serverVersion));
}

```

`src/utils/virtual_mem.zig`:

```zig
const builtin = @import("builtin");
const std = @import("std");

const page_size_min = std.heap.page_size_min;
const page_size_max = std.heap.page_size_max;
const pageSize = std.heap.pageSize;

fn reserveMemory(len: usize) [*]align(page_size_min) u8 {
	if (builtin.os.tag == .windows) {
		return @ptrCast(@alignCast(std.os.windows.VirtualAlloc(null, len, std.os.windows.MEM_RESERVE, std.os.windows.PAGE_READWRITE) catch |err| {
			std.log.err("Got error while reserving virtual memory of size {}: {s}", .{len, @errorName(err)});
			@panic("Out of Memory");
		}));
	} else {
		return (std.posix.mmap(null, len, std.posix.PROT.NONE, .{.TYPE = .PRIVATE, .ANONYMOUS = true, .NORESERVE = true}, -1, 0) catch |err| {
			std.log.err("Got error while reserving virtual memory of size {}: {s}", .{len, @errorName(err)});
			@panic("Out of Memory");
		}).ptr;
	}
}

fn commitMemory(start: [*]align(page_size_min) u8, len: usize) void {
	if (builtin.os.tag == .windows) {
		_ = std.os.windows.VirtualAlloc(start, len, std.os.windows.MEM_COMMIT, std.os.windows.PAGE_READWRITE) catch |err| {
			std.log.err("Got error while committing virtual memory of size {}: {s}.", .{len, @errorName(err)});
			@panic("Out of Memory");
		};
	} else {
		std.posix.mprotect(start[0..len], std.posix.PROT.READ | std.posix.PROT.WRITE) catch |err| {
			std.log.err("Got error while committing virtual memory of size {}: {s}.", .{len, @errorName(err)});
			@panic("Out of Memory");
		};
	}
}

fn releaseMemory(start: [*]align(page_size_min) u8, len: usize) void {
	if (builtin.os.tag == .windows) {
		std.os.windows.VirtualFree(start, 0, std.os.windows.MEM_RELEASE);
	} else {
		std.posix.munmap(start[0..len]);
	}
}

/// A list that reserves a continuous region of virtual memory without actually committing its pages.
/// This allows it to grow without ever invalidating pointers.
pub fn VirtualList(T: type, maxSize: u32) type {
	return struct {
		mem: [*]align(page_size_min) T,
		len: u32,
		committedCapacity: u32,

		fn maxSizeBytes() usize {
			return std.mem.alignForward(usize, @as(usize, maxSize)*@sizeOf(T), pageSize());
		}

		pub fn init() @This() {
			return .{
				.mem = @ptrCast(reserveMemory(maxSizeBytes())),
				.len = 0,
				.committedCapacity = 0,
			};
		}

		pub fn deinit(self: @This()) void {
			releaseMemory(@ptrCast(self.mem), maxSizeBytes());
		}

		pub fn items(self: *@This()) []T {
			return self.mem[0..self.len];
		}

		pub fn clearRetainingCapacity(self: *@This()) void {
			self.len = 0;
		}

		pub fn ensureCapacity(self: *@This(), newCapacity: usize) void {
			if (newCapacity > self.committedCapacity) {
				const alignedCapacity = std.mem.alignForward(usize, self.committedCapacity*@sizeOf(T), pageSize());
				const newAlignedCapacity = std.mem.alignForward(usize, newCapacity*@sizeOf(T), pageSize());

				commitMemory(@alignCast(@as([*]align(page_size_min) u8, @ptrCast(self.mem))[alignedCapacity..]), newAlignedCapacity - alignedCapacity);
				self.committedCapacity = @intCast(newAlignedCapacity/@sizeOf(T));
			}
		}

		fn ensureFreeCapacity(self: *@This(), freeCapacity: usize) void {
			if (freeCapacity + self.len <= self.committedCapacity) return;
			self.ensureCapacity(freeCapacity + self.len);
		}

		pub fn resizeAssumeCapacity(self: *@This(), new_len: usize) void {
			self.len = new_len;
			std.debug.assert(self.len <= self.committedCapacity);
		}

		pub fn resize(self: *@This(), new_len: usize) void {
			self.ensureCapacity(new_len);
			self.len = new_len;
		}

		pub fn addOneAssumeCapacity(self: *@This()) *T {
			self.len += 1;
			std.debug.assert(self.len <= self.committedCapacity);
			return &self.mem[self.len - 1];
		}

		pub fn addOne(self: *@This()) *T {
			self.ensureFreeCapacity(1);
			return self.addOneAssumeCapacity();
		}

		pub fn addManyAssumeCapacity(self: *@This(), n: usize) []T {
			self.len += n;
			std.debug.assert(self.len <= self.committedCapacity);
			return self.items()[self.len - n ..];
		}

		pub fn addMany(self: *@This(), n: usize) []T {
			self.ensureFreeCapacity(n);
			return self.addManyAssumeCapacity(n);
		}

		pub fn appendAssumeCapacity(self: *@This(), elem: T) void {
			self.addOneAssumeCapacity().* = elem;
		}

		pub fn append(self: *@This(), elem: T) void {
			self.addOne().* = elem;
		}

		pub fn appendNTimesAssumeCapacity(self: *@This(), elem: T, n: usize) void {
			@memset(self.addManyAssumeCapacity(n), elem);
		}

		pub fn appendNTimes(self: *@This(), elem: T, n: usize) void {
			@memset(self.addMany(n), elem);
		}

		pub fn appendSliceAssumeCapacity(self: *@This(), elems: []const T) void {
			@memcpy(self.addManyAssumeCapacity(elems.len), elems);
		}

		pub fn appendSlice(self: *@This(), elems: []const T) void {
			@memcpy(self.addMany(elems.len), elems);
		}

		pub fn insertAssumeCapacity(self: *@This(), i: usize, elem: T) void {
			std.debug.assert(i <= self.len);
			if (i == self.len) return self.appendAssumeCapacity(elem);
			_ = self.addOneAssumeCapacity();
			std.mem.copyBackwards(T, self.items()[i + 1 ..], self.items()[0 .. self.len - 1][i..]);
			self.mem[i] = elem;
		}

		pub fn insert(self: *@This(), i: usize, elem: T) void {
			std.debug.assert(i <= self.len);
			if (i == self.len) return self.append(elem);
			_ = self.addOne();
			std.mem.copyBackwards(T, self.items()[i + 1 ..], self.items()[0 .. self.len - 1][i..]);
			self.mem[i] = elem;
		}

		pub fn insertSliceAssumeCapacity(self: *@This(), i: usize, elems: []const T) void {
			std.debug.assert(i <= self.len);
			if (i == self.len) return self.appendSliceAssumeCapacity(elems);
			_ = self.addManyAssumeCapacity(elems.len);
			std.mem.copyBackwards(T, self.items()[i + elems.len ..], self.items()[0 .. self.len - elems.len][i..]);
			@memcpy(self.items()[i..][0..elems.len], elems);
		}

		pub fn insertSlice(self: *@This(), i: usize, elems: []const T) void {
			std.debug.assert(i <= self.len);
			if (i == self.len) return self.appendSlice(elems);
			_ = self.addMany(elems.len);
			std.mem.copyBackwards(T, self.items()[i + elems.len ..], self.items()[0 .. self.len - elems.len][i..]);
			@memcpy(self.items()[i..][0..elems.len], elems);
		}

		pub fn swapRemove(self: *@This(), i: usize) T {
			const old = self.items()[i];
			self.items()[i] = self.items()[self.len - 1];
			self.len -= 1;
			return old;
		}

		pub fn orderedRemove(self: *@This(), i: usize) T {
			const newlen = self.len - 1;
			const old = self.items()[i];
			for (self.items()[i..newlen], i + 1..) |*b, j| b.* = self.items()[j];
			self.len = newlen;
			return old;
		}

		pub fn popOrNull(self: *@This()) ?T {
			if (self.len == 0) return null;
			const val = self.items()[self.len - 1];
			self.len -= 1;
			return val;
		}

		pub fn pop(self: *@This()) T {
			return self.popOrNull() orelse unreachable;
		}

		pub fn replaceRange(self: *@This(), start: usize, len: usize, new_items: []const T) void {
			const after_range = start + len;
			const range = self.items()[start..after_range];

			if (range.len == new_items.len)
				@memcpy(range[0..new_items.len], new_items)
			else if (range.len < new_items.len) {
				const first = new_items[0..range.len];
				const rest = new_items[range.len..];

				@memcpy(range[0..first.len], first);
				self.insertSlice(after_range, rest);
			} else {
				@memcpy(range[0..new_items.len], new_items);
				const after_subrange = start + new_items.len;

				for (self.items()[after_range..], 0..) |item, i| {
					self.items()[after_subrange..][i] = item;
				}

				self.len -= len - new_items.len;
			}
		}

		pub const Writer = if (T != u8)
			@compileError("The Writer interface is only defined for ArrayList(u8) " ++
				"but the given type is ArrayList(" ++ @typeName(T) ++ ")")
		else
			std.io.Writer(*@This(), error{}, appendWrite);

		pub fn writer(self: *@This()) Writer {
			return .{.context = self};
		}

		fn appendWrite(self: *@This(), m: []const u8) !usize {
			self.appendSlice(m);
			return m.len;
		}
	};
}

```

`src/vec.zig`:

```zig
const std = @import("std");

pub const Vec2i = @Vector(2, i32);
pub const Vec2f = @Vector(2, f32);
pub const Vec2d = @Vector(2, f64);
pub const Vec3i = @Vector(3, i32);
pub const Vec3f = @Vector(3, f32);
pub const Vec3d = @Vector(3, f64);
pub const Vec4i = @Vector(4, i32);
pub const Vec4f = @Vector(4, f32);
pub const Vec4d = @Vector(4, f64);

pub inline fn combine(pos: Vec3f, w: f32) Vec4f {
	return .{pos[0], pos[1], pos[2], w};
}

pub fn xyz(self: anytype) @Vector(3, @typeInfo(@TypeOf(self)).vector.child) {
	return @Vector(3, @typeInfo(@TypeOf(self)).vector.child){self[0], self[1], self[2]};
}

pub fn xy(self: anytype) @Vector(2, @typeInfo(@TypeOf(self)).vector.child) {
	return @Vector(2, @typeInfo(@TypeOf(self)).vector.child){self[0], self[1]};
}

pub fn dot(self: anytype, other: @TypeOf(self)) @typeInfo(@TypeOf(self)).vector.child {
	return @reduce(.Add, self*other);
}

pub fn lengthSquare(self: anytype) @typeInfo(@TypeOf(self)).vector.child {
	return @reduce(.Add, self*self);
}

pub fn length(self: anytype) @typeInfo(@TypeOf(self)).vector.child {
	return @sqrt(@reduce(.Add, self*self));
}

pub fn normalize(self: anytype) @TypeOf(self) {
	return self/@as(@TypeOf(self), @splat(length(self)));
}

pub fn clampMag(self: anytype, maxMag: @typeInfo(@TypeOf(self)).vector.child) @TypeOf(self) {
	if (lengthSquare(self) > maxMag*maxMag) {
		return normalize(self)*@as(@TypeOf(self), @splat(maxMag));
	}

	return self;
}

pub fn cross(self: anytype, other: @TypeOf(self)) @TypeOf(self) {
	if (@typeInfo(@TypeOf(self)).vector.len != 3) @compileError("Only available for vectors of length 3.");
	return @TypeOf(self){
		self[1]*other[2] - self[2]*other[1],
		self[2]*other[0] - self[0]*other[2],
		self[0]*other[1] - self[1]*other[0],
	};
}

pub fn rotateX(self: anytype, angle: @typeInfo(@TypeOf(self)).vector.child) @TypeOf(self) {
	if (@typeInfo(@TypeOf(self)).vector.len != 3) @compileError("Only available for vectors of length 3.");
	const sin = @sin(angle);
	const cos = @cos(angle);
	return @TypeOf(self){
		self[0],
		self[1]*cos - self[2]*sin,
		self[1]*sin + self[2]*cos,
	};
}

pub fn rotateY(self: anytype, angle: @typeInfo(@TypeOf(self)).vector.child) @TypeOf(self) {
	if (@typeInfo(@TypeOf(self)).vector.len != 3) @compileError("Only available for vectors of length 3.");
	const sin = @sin(angle);
	const cos = @cos(angle);
	return @TypeOf(self){
		self[0]*cos + self[2]*sin,
		self[1],
		-self[0]*sin + self[2]*cos,
	};
}

pub fn rotateZ(self: anytype, angle: @typeInfo(@TypeOf(self)).vector.child) @TypeOf(self) {
	if (@typeInfo(@TypeOf(self)).vector.len != 3) @compileError("Only available for vectors of length 3.");
	const sin = @sin(angle);
	const cos = @cos(angle);
	return @TypeOf(self){
		self[0]*cos - self[1]*sin,
		self[0]*sin + self[1]*cos,
		self[2],
	};
}

pub fn rotate2d(self: anytype, angle: @typeInfo(@TypeOf(self)).vector.child, center: @TypeOf(self)) @TypeOf(self) {
	if (@typeInfo(@TypeOf(self)).vector.len != 2) @compileError("Only available for vectors of length 2.");

	const sin = @sin(angle);
	const cos = @cos(angle);
	const pos = self - center;

	return @TypeOf(self){
		cos*pos[0] - sin*pos[1],
		sin*pos[0] + cos*pos[1],
	} + center;
}

pub const Mat4f = struct { // MARK: Mat4f
	rows: [4]Vec4f,
	pub fn identity() Mat4f {
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{1, 0, 0, 0},
				Vec4f{0, 1, 0, 0},
				Vec4f{0, 0, 1, 0},
				Vec4f{0, 0, 0, 1},
			},
		};
	}

	pub fn translation(pos: Vec3f) Mat4f {
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{1, 0, 0, pos[0]},
				Vec4f{0, 1, 0, pos[1]},
				Vec4f{0, 0, 1, pos[2]},
				Vec4f{0, 0, 0, 1},
			},
		};
	}

	pub fn scale(vector: Vec3f) Mat4f { // zig fmt: off
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{vector[0], 0,         0,         0},
				Vec4f{0,         vector[1], 0,         0},
				Vec4f{0,         0,         vector[2], 0},
				Vec4f{0,         0,         0,         1},
			},
		};
	} // zig fmt: on

	pub fn rotationX(rad: f32) Mat4f {
		const s = @sin(rad);
		const c = @cos(rad);
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{1, 0, 0, 0},
				Vec4f{0, c, -s, 0},
				Vec4f{0, s, c, 0},
				Vec4f{0, 0, 0, 1},
			},
		};
	}

	pub fn rotationY(rad: f32) Mat4f {
		const s = @sin(rad);
		const c = @cos(rad);
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{c, 0, s, 0},
				Vec4f{0, 1, 0, 0},
				Vec4f{-s, 0, c, 0},
				Vec4f{0, 0, 0, 1},
			},
		};
	}

	pub fn rotationZ(rad: f32) Mat4f {
		const s = @sin(rad);
		const c = @cos(rad);
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{c, -s, 0, 0},
				Vec4f{s, c, 0, 0},
				Vec4f{0, 0, 1, 0},
				Vec4f{0, 0, 0, 1},
			},
		};
	}

	pub fn perspective(fovY: f32, aspect: f32, near: f32, far: f32) Mat4f { // zig fmt: off
		const tanY = std.math.tan(fovY*0.5);
		const tanX = aspect*tanY;
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{1/tanX, 0,                          0,      0},
				Vec4f{0,      0,                          1/tanY, 0},
				Vec4f{0,      -(far + near)/(near - far), 0,      2*near*far/(near - far)},
				Vec4f{0,      1,                          0,      0},
			},
		};
	} // zig fmt: on

	pub fn transpose(self: Mat4f) Mat4f {
		return Mat4f{
			.rows = [4]Vec4f{
				Vec4f{self.rows[0][0], self.rows[1][0], self.rows[2][0], self.rows[3][0]},
				Vec4f{self.rows[0][1], self.rows[1][1], self.rows[2][1], self.rows[3][1]},
				Vec4f{self.rows[0][2], self.rows[1][2], self.rows[2][2], self.rows[3][2]},
				Vec4f{self.rows[0][3], self.rows[1][3], self.rows[2][3], self.rows[3][3]},
			},
		};
	}

	pub fn mul(self: Mat4f, other: Mat4f) Mat4f {
		const transposeOther = other.transpose();
		var result: Mat4f = undefined;
		for (&result.rows, self.rows) |*resRow, selfRow| {
			resRow.* = .{
				dot(selfRow, transposeOther.rows[0]),
				dot(selfRow, transposeOther.rows[1]),
				dot(selfRow, transposeOther.rows[2]),
				dot(selfRow, transposeOther.rows[3]),
			};
		}
		return result;
	}

	pub fn mulVec(self: Mat4f, vec: Vec4f) Vec4f {
		return Vec4f{
			dot(self.rows[0], vec),
			dot(self.rows[1], vec),
			dot(self.rows[2], vec),
			dot(self.rows[3], vec),
		};
	}
};

pub const Complex = struct { // MARK: Complex
	val: Vec2d,

	fn valSquare(a: Complex) f64 {
		return @reduce(.Add, a.val*a.val);
	}

	fn conjugate(a: Complex) Complex {
		return .{.val = a.val*Vec2d{1, -1}};
	}

	pub fn negate(a: Complex) Complex {
		return .{.val = -a.val};
	}

	pub fn add(a: Complex, b: Complex) Complex {
		return .{.val = a.val + b.val};
	}

	pub fn addScalar(a: Complex, b: f64) Complex {
		return .{.val = a.val + Vec2d{b, 0}};
	}

	pub fn sub(a: Complex, b: Complex) Complex {
		return .{.val = a.val - b.val};
	}

	pub fn subScalar(a: Complex, b: f64) Complex {
		return .{.val = a.val - Vec2d{b, 0}};
	}

	pub fn mul(a: Complex, b: Complex) Complex {
		return .{.val = .{a.val[0]*b.val[0] - a.val[1]*b.val[1], a.val[0]*b.val[1] + a.val[1]*b.val[0]}};
	}

	pub fn mulScalar(a: Complex, b: f64) Complex {
		return .{.val = a.val*@as(Vec2d, @splat(b))};
	}

	pub fn div(a: Complex, b: Complex) Complex {
		const denom = b.valSquare();
		return a.mul(b.conjugate()).divScalar(denom);
	}

	pub fn divScalar(a: Complex, b: f64) Complex {
		return .{.val = a.val/@as(Vec2d, @splat(b))};
	}

	pub fn fromSqrt(val: f64) Complex {
		if (val < 0) {
			return .{.val = .{0, @sqrt(-val)}};
		} else {
			return .{.val = .{@sqrt(val), 0}};
		}
	}

	pub fn exp(a: Complex) Complex {
		const realFactor = @exp(a.val[0]);
		const complexFactor: Complex = .{.val = .{@cos(a.val[1]), @sin(a.val[1])}};
		return complexFactor.mulScalar(realFactor);
	}
};

```

`src/zon.zig`:

```zig
const std = @import("std");
const builtin = @import("builtin");

const main = @import("main");
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const List = main.List;

pub const ZonElement = union(enum) { // MARK: Zon
	int: i128,
	float: f64,
	string: []const u8,
	stringOwned: []const u8,
	bool: bool,
	null: void,
	array: *List(ZonElement),
	object: *std.StringHashMap(ZonElement),

	pub fn initObject(allocator: NeverFailingAllocator) ZonElement {
		const map = allocator.create(std.StringHashMap(ZonElement));
		map.* = .init(allocator.allocator);
		return .{.object = map};
	}

	pub fn initArray(allocator: NeverFailingAllocator) ZonElement {
		const list = allocator.create(List(ZonElement));
		list.* = .init(allocator);
		return .{.array = list};
	}

	pub fn getAtIndex(self: *const ZonElement, comptime _type: type, index: usize, replacement: _type) _type {
		if (self.* != .array) {
			return replacement;
		} else {
			if (index < self.array.items.len) {
				return self.array.items[index].as(_type, replacement);
			} else {
				return replacement;
			}
		}
	}

	pub fn getChildAtIndex(self: *const ZonElement, index: usize) ZonElement {
		if (self.* != .array) {
			return .null;
		} else {
			if (index < self.array.items.len) {
				return self.array.items[index];
			} else {
				return .null;
			}
		}
	}

	pub fn get(self: *const ZonElement, comptime _type: type, key: []const u8, replacement: _type) _type {
		if (self.* != .object) {
			return replacement;
		} else {
			if (self.object.get(key)) |elem| {
				return elem.as(_type, replacement);
			} else {
				return replacement;
			}
		}
	}

	pub fn getChild(self: *const ZonElement, key: []const u8) ZonElement {
		return self.getChildOrNull(key) orelse .null;
	}

	pub fn getChildOrNull(self: *const ZonElement, key: []const u8) ?ZonElement {
		if (self.* == .object) return self.object.get(key);
		return null;
	}

	pub fn removeChild(self: *const ZonElement, key: []const u8) ?ZonElement {
		if (self.* != .object) return null;
		return (self.object.fetchRemove(key) orelse return null).value;
	}

	pub fn clone(self: *const ZonElement, allocator: NeverFailingAllocator) ZonElement {
		return switch (self.*) {
			.int, .float, .string, .bool, .null => self.*,
			.stringOwned => |stringOwned| .{.stringOwned = allocator.allocator.dupe(u8, stringOwned) catch unreachable},
			.array => |array| blk: {
				const out = ZonElement.initArray(allocator);

				for (0..array.items.len) |i| {
					out.array.append(array.items[i].clone(allocator));
				}

				break :blk out;
			},
			.object => |object| blk: {
				const out = ZonElement.initObject(allocator);

				var iter = object.iterator();
				while (iter.next()) |entry| {
					out.put(entry.key_ptr.*, entry.value_ptr.clone(allocator));
				}

				break :blk out;
			},
		};
	}

	pub const JoinPriority = enum { preferLeft, preferRight };

	fn joinGetNew(left: ZonElement, priority: JoinPriority, right: ZonElement, allocator: NeverFailingAllocator) ZonElement {
		switch (left) {
			.int, .float, .string, .stringOwned, .bool, .null => {
				return switch (priority) {
					.preferLeft => left.clone(allocator),
					.preferRight => right.clone(allocator),
				};
			},
			.array => {
				const out = left.clone(allocator);
				for (right.array.items) |item| {
					out.array.append(item.clone(allocator));
				}
				return out;
			},
			.object => {
				const out = left.clone(allocator);

				out.join(priority, right);
				return out;
			},
		}

		return .null;
	}

	pub fn join(left: *const ZonElement, priority: JoinPriority, right: ZonElement) void {
		if (right == .null) {
			return;
		}
		if (left.* != .object or right != .object) {
			if (!builtin.is_test) std.log.err("Trying to join zon that isn't an object.", .{}); // TODO: #1275
			return;
		}

		var iter = right.object.iterator();
		while (iter.next()) |entry| {
			if (left.object.get(entry.key_ptr.*)) |val| {
				left.put(entry.key_ptr.*, val.joinGetNew(priority, entry.value_ptr.*, .{.allocator = left.object.allocator, .IAssertThatTheProvidedAllocatorCantFail = {}}));
			} else {
				left.put(entry.key_ptr.*, entry.value_ptr.clone(.{.allocator = left.object.allocator, .IAssertThatTheProvidedAllocatorCantFail = {}}));
			}
		}
	}

	pub fn as(self: *const ZonElement, comptime T: type, replacement: T) T {
		comptime var typeInfo: std.builtin.Type = @typeInfo(T);
		comptime var innerType = T;
		inline while (typeInfo == .optional) {
			innerType = typeInfo.optional.child;
			typeInfo = @typeInfo(innerType);
		}
		switch (typeInfo) {
			.int => {
				switch (self.*) {
					.int => return std.math.cast(innerType, self.int) orelse replacement,
					.float => return std.math.lossyCast(innerType, std.math.round(self.float)),
					else => return replacement,
				}
			},
			.float => {
				switch (self.*) {
					.int => return @floatFromInt(self.int),
					.float => return @floatCast(self.float),
					else => return replacement,
				}
			},
			.vector => {
				const len = typeInfo.vector.len;
				const elems = self.toSlice();
				if (elems.len != len) return replacement;
				var result: innerType = undefined;
				if (innerType == T) result = replacement;
				inline for (0..len) |i| {
					if (innerType == T) {
						result[i] = elems[i].as(typeInfo.vector.child, result[i]);
					} else {
						result[i] = elems[i].as(?typeInfo.vector.child, null) orelse return replacement;
					}
				}
				return result;
			},
			.@"enum" => {
				return std.meta.stringToEnum(T, self.as(?[]const u8, null) orelse return replacement) orelse return replacement;
			},
			else => {
				switch (innerType) {
					[]const u8 => {
						switch (self.*) {
							.string => return self.string,
							.stringOwned => return self.stringOwned,
							else => return replacement,
						}
					},
					bool => {
						switch (self.*) {
							.bool => return self.bool,
							else => return replacement,
						}
					},
					else => {
						@compileError("Unsupported type '" ++ @typeName(T) ++ "'.");
					},
				}
			},
		}
	}

	fn createElementFromRandomType(value: anytype, allocator: std.mem.Allocator) ZonElement {
		switch (@typeInfo(@TypeOf(value))) {
			.void => return .null,
			.null => return .null,
			.bool => return .{.bool = value},
			.int, .comptime_int => return .{.int = value},
			.float, .comptime_float => return .{.float = value},
			.@"union" => {
				if (@TypeOf(value) == ZonElement) {
					return value;
				} else {
					@compileError("Unknown value type.");
				}
			},
			.pointer => |ptr| {
				if (ptr.child == u8 and ptr.size == .slice) {
					return .{.string = value};
				} else {
					const childInfo = @typeInfo(ptr.child);
					if (ptr.size == .one and childInfo == .array and childInfo.array.child == u8) {
						return .{.string = value};
					} else {
						@compileError("Unknown value type.");
					}
				}
			},
			.optional => {
				if (value) |val| {
					return createElementFromRandomType(val, allocator);
				} else {
					return .null;
				}
			},
			.vector => {
				const len = @typeInfo(@TypeOf(value)).vector.len;
				const result = initArray(main.heap.NeverFailingAllocator{.allocator = allocator, .IAssertThatTheProvidedAllocatorCantFail = {}});
				result.array.ensureCapacity(len);
				inline for (0..len) |i| {
					result.array.appendAssumeCapacity(createElementFromRandomType(value[i], allocator));
				}
				return result;
			},
			.@"enum" => {
				return createElementFromRandomType(@tagName(value), allocator);
			},
			else => {
				if (@TypeOf(value) == ZonElement) {
					return value;
				} else {
					@compileError("Unknown value type.");
				}
			},
		}
	}

	pub fn append(self: *const ZonElement, value: anytype) void {
		self.array.append(createElementFromRandomType(value, self.array.allocator.allocator));
	}

	pub fn put(self: *const ZonElement, key: []const u8, value: anytype) void {
		const result = createElementFromRandomType(value, self.object.allocator);

		if (self.object.contains(key)) {
			self.getChild(key).deinit(NeverFailingAllocator{.allocator = self.object.allocator, .IAssertThatTheProvidedAllocatorCantFail = {}});

			self.object.put(key, result) catch unreachable;
			return;
		}

		self.object.put(self.object.allocator.dupe(u8, key) catch unreachable, result) catch unreachable;
	}

	pub fn putOwnedString(self: *const ZonElement, key: []const u8, value: []const u8) void {
		const result = ZonElement{.stringOwned = self.object.allocator.dupe(u8, value) catch unreachable};

		if (self.object.contains(key)) {
			self.getChild(key).deinit(NeverFailingAllocator{.allocator = self.object.allocator, .IAssertThatTheProvidedAllocatorCantFail = {}});

			self.object.put(key, result) catch unreachable;
			return;
		}

		self.object.put(self.object.allocator.dupe(u8, key) catch unreachable, result) catch unreachable;
	}

	pub fn toSlice(self: *const ZonElement) []ZonElement {
		switch (self.*) {
			.array => |arr| {
				return arr.items;
			},
			else => return &.{},
		}
	}

	pub fn deinit(self: *const ZonElement, allocator: NeverFailingAllocator) void {
		switch (self.*) {
			.int, .float, .bool, .null, .string => return,
			.stringOwned => {
				allocator.free(self.stringOwned);
			},
			.array => {
				for (self.array.items) |*elem| {
					elem.deinit(allocator);
				}
				self.array.clearAndFree();
				allocator.destroy(self.array);
			},
			.object => {
				var iterator = self.object.iterator();
				while (true) {
					const elem = iterator.next() orelse break;
					allocator.free(elem.key_ptr.*);
					elem.value_ptr.deinit(allocator);
				}
				self.object.clearAndFree();
				allocator.destroy(self.object);
			},
		}
	}

	pub fn isNull(self: *const ZonElement) bool {
		return self.* == .null;
	}

	fn escape(list: *List(u8), string: []const u8) void {
		for (string) |char| {
			switch (char) {
				'\\' => list.appendSlice("\\\\"),
				'\n' => list.appendSlice("\\n"),
				'\"' => list.appendSlice("\\\""),
				'\t' => list.appendSlice("\\t"),
				else => list.append(char),
			}
		}
	}
	fn writeTabs(list: *List(u8), tabs: u32) void {
		for (0..tabs) |_| {
			list.append('\t');
		}
	}
	fn isValidIdentifierName(str: []const u8) bool {
		if (str.len == 0) return false;
		if (!std.ascii.isAlphabetic(str[0]) and str[0] != '_') return false;
		for (str[1..]) |c| {
			if (!std.ascii.isAlphanumeric(c) and c != '_') return false;
		}
		return true;
	}
	fn recurseToString(zon: ZonElement, list: *List(u8), tabs: u32, comptime visualCharacters: bool) void {
		switch (zon) {
			.int => |value| {
				list.print("{d}", .{value});
			},
			.float => |value| {
				list.print("{e}", .{value});
			},
			.bool => |value| {
				if (value) {
					list.appendSlice("true");
				} else {
					list.appendSlice("false");
				}
			},
			.null => {
				list.appendSlice("null");
			},
			.string, .stringOwned => |value| {
				if (isValidIdentifierName(value)) {
					// Can use an enum literal:
					list.append('.');
					list.appendSlice(value);
				} else {
					list.append('\"');
					escape(list, value);
					list.append('\"');
				}
			},
			.array => |array| {
				if (visualCharacters) list.append('.');
				list.append('{');
				for (array.items, 0..) |elem, i| {
					if (i != 0) {
						list.append(',');
					}
					if (visualCharacters) list.append('\n');
					if (visualCharacters) writeTabs(list, tabs + 1);
					recurseToString(elem, list, tabs + 1, visualCharacters);
				}
				if (visualCharacters and array.items.len != 0) list.append(',');
				if (visualCharacters) list.append('\n');
				if (visualCharacters) writeTabs(list, tabs);
				list.append('}');
			},
			.object => |obj| {
				if (visualCharacters) list.append('.');
				list.append('{');
				var iterator = obj.iterator();
				var first: bool = true;
				while (true) {
					const elem = iterator.next() orelse break;
					if (!first) {
						list.append(',');
					}
					if (visualCharacters) list.append('\n');
					if (visualCharacters) writeTabs(list, tabs + 1);
					if (isValidIdentifierName(elem.key_ptr.*)) {
						if (visualCharacters) list.append('.');
						list.appendSlice(elem.key_ptr.*);
					} else {
						if (visualCharacters) list.append('@');
						list.append('\"');
						escape(list, elem.key_ptr.*);
						list.append('\"');
					}
					if (visualCharacters) list.append(' ');
					list.append('=');
					if (visualCharacters) list.append(' ');

					recurseToString(elem.value_ptr.*, list, tabs + 1, visualCharacters);
					first = false;
				}
				if (visualCharacters and !first) list.append(',');
				if (visualCharacters) list.append('\n');
				if (visualCharacters) writeTabs(list, tabs);
				list.append('}');
			},
		}
	}
	pub fn toString(zon: ZonElement, allocator: NeverFailingAllocator) []const u8 {
		var string = List(u8).init(allocator);
		recurseToString(zon, &string, 0, true);
		return string.toOwnedSlice();
	}

	/// Ignores all the visual characters(spaces, tabs and newlines) and allows adding a custom prefix(which is for example required by networking).
	pub fn toStringEfficient(zon: ZonElement, allocator: NeverFailingAllocator, prefix: []const u8) []const u8 {
		var string = List(u8).init(allocator);
		string.appendSlice(prefix);
		recurseToString(zon, &string, 0, false);
		return string.toOwnedSlice();
	}

	pub fn parseFromString(allocator: NeverFailingAllocator, filePath: ?[]const u8, string: []const u8) ZonElement {
		var index: u32 = 0;
		Parser.skipWhitespaceAndComments(string, &index);
		return Parser.parseElement(allocator, filePath, string, &index);
	}
};

const Parser = struct { // MARK: Parser
	/// All whitespaces from unicode 14.
	const whitespaces = [_][]const u8{"\u{0009}", "\u{000A}", "\u{000B}", "\u{000C}", "\u{000D}", "\u{0020}", "\u{0085}", "\u{00A0}", "\u{1680}", "\u{2000}", "\u{2001}", "\u{2002}", "\u{2003}", "\u{2004}", "\u{2005}", "\u{2006}", "\u{2007}", "\u{2008}", "\u{2009}", "\u{200A}", "\u{2028}", "\u{2029}", "\u{202F}", "\u{205F}", "\u{3000}"};

	fn skipWhitespaceAndComments(chars: []const u8, index: *u32) void {
		outerLoop: while (index.* < chars.len) {
			whitespaceLoop: for (whitespaces) |whitespace| {
				for (whitespace, 0..) |char, i| {
					if (char != chars[index.* + i]) {
						continue :whitespaceLoop;
					}
				}
				index.* += @intCast(whitespace.len);
				continue :outerLoop;
			}
			if (chars[index.*] == '/' and chars[index.* + 1] == '/') {
				while (chars[index.*] != '\n') {
					index.* += 1;
				}
				index.* += 1;
				continue :outerLoop;
			}
			// Next character is no whitespace.
			return;
		}
	}

	/// Assumes that the region starts with a number character ('+', '-', '.' or a digit).
	fn parseNumber(chars: []const u8, index: *u32) ZonElement {
		var sign: i2 = 1;
		if (chars[index.*] == '-') {
			sign = -1;
			index.* += 1;
		} else if (chars[index.*] == '+') {
			index.* += 1;
		}
		var intPart: i128 = 0;
		if (index.* + 1 < chars.len and chars[index.*] == '0' and chars[index.* + 1] == 'x') {
			// Parse hex int
			index.* += 2;
			while (index.* < chars.len) : (index.* += 1) {
				switch (chars[index.*]) {
					'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
						intPart = (chars[index.*] - '0') +% intPart*%16;
					},
					'a', 'b', 'c', 'd', 'e', 'f' => {
						intPart = (chars[index.*] - 'a' + 10) +% intPart*%16;
					},
					'A', 'B', 'C', 'D', 'E', 'F' => {
						intPart = (chars[index.*] - 'A' + 10) +% intPart*%16;
					},
					else => {
						break;
					},
				}
			}
			return .{.int = sign*intPart};
		}
		while (index.* < chars.len) : (index.* += 1) {
			switch (chars[index.*]) {
				'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
					intPart = (chars[index.*] - '0') +% intPart*%10;
				},
				else => {
					break;
				},
			}
		}
		if (index.* >= chars.len or (chars[index.*] != '.' and chars[index.*] != 'e' and chars[index.*] != 'E')) { // This is an int
			return .{.int = sign*intPart};
		}
		// So this is a float apparently.

		var floatPart: f64 = 0;
		var currentFactor: f64 = 0.1;
		if (chars[index.*] == '.') {
			index.* += 1;
			while (index.* < chars.len) : (index.* += 1) {
				switch (chars[index.*]) {
					'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
						floatPart += @as(f64, @floatFromInt(chars[index.*] - '0'))*currentFactor;
						currentFactor *= 0.1;
					},
					else => {
						break;
					},
				}
			}
		}
		var exponent: i64 = 0;
		var exponentSign: i2 = 1;
		if (index.* < chars.len and (chars[index.*] == 'e' or chars[index.*] == 'E')) {
			index.* += 1;
			if (index.* < chars.len and chars[index.*] == '-') {
				exponentSign = -1;
				index.* += 1;
			} else if (index.* < chars.len and chars[index.*] == '+') {
				index.* += 1;
			}
			while (index.* < chars.len) : (index.* += 1) {
				switch (chars[index.*]) {
					'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
						exponent = (chars[index.*] - '0') +% exponent*%10;
					},
					else => {
						break;
					},
				}
			}
		}
		return .{.float = @as(f64, @floatFromInt(sign))*(@as(f64, @floatFromInt(intPart)) + floatPart)*std.math.pow(f64, 10, @as(f64, @floatFromInt(exponentSign*exponent)))};
	}

	fn parseString(allocator: NeverFailingAllocator, chars: []const u8, index: *u32) []const u8 {
		var builder = List(u8).init(allocator);
		while (index.* < chars.len) : (index.* += 1) {
			if (chars[index.*] == '\"') {
				index.* += 1;
				break;
			} else if (chars[index.*] == '\\') {
				index.* += 1;
				if (index.* >= chars.len)
					break;
				switch (chars[index.*]) {
					't' => {
						builder.append('\t');
					},
					'n' => {
						builder.append('\n');
					},
					'r' => {
						builder.append('\r');
					},
					else => {
						builder.append(chars[index.*]);
					},
				}
			} else {
				builder.append(chars[index.*]);
			}
		}
		return builder.toOwnedSlice();
	}

	fn parseIdentifierOrStringOrEnumLiteral(allocator: NeverFailingAllocator, chars: []const u8, index: *u32) []const u8 {
		var builder = List(u8).init(allocator);
		if (index.* == chars.len) return &.{};
		if (chars[index.*] == '@') {
			index.* += 1;
		}
		if (index.* == chars.len) return &.{};
		if (chars[index.*] == '"') {
			index.* += 1;
			return parseString(allocator, chars, index);
		}
		while (index.* < chars.len) : (index.* += 1) {
			switch (chars[index.*]) {
				'a'...'z', 'A'...'Z', '0'...'9', '_' => |c| builder.append(c),
				else => break,
			}
		}
		return builder.toOwnedSlice();
	}

	fn parseArray(allocator: NeverFailingAllocator, filePath: ?[]const u8, chars: []const u8, index: *u32) ZonElement {
		const list = allocator.create(List(ZonElement));
		list.* = .init(allocator);
		while (index.* < chars.len) {
			skipWhitespaceAndComments(chars, index);
			if (index.* >= chars.len) break;
			if (chars[index.*] == '}') {
				index.* += 1;
				return .{.array = list};
			}
			list.append(parseElement(allocator, filePath, chars, index));
			skipWhitespaceAndComments(chars, index);
			if (index.* < chars.len and chars[index.*] == ',') {
				index.* += 1;
			}
		}
		printError(filePath, chars, index.*, "Unexpected end of file in array parsing.");
		return .{.array = list};
	}

	fn parseObject(allocator: NeverFailingAllocator, filePath: ?[]const u8, chars: []const u8, index: *u32) ZonElement {
		const map = allocator.create(std.StringHashMap(ZonElement));
		map.* = .init(allocator.allocator);
		while (index.* < chars.len) {
			skipWhitespaceAndComments(chars, index);
			if (index.* >= chars.len) break;
			if (chars[index.*] == '}') {
				index.* += 1;
				return .{.object = map};
			}
			if (chars[index.*] == '.') index.* += 1; // Just ignoring the dot in front of identifiers, the file might as well not have for all I care.
			const keyIndex = index.*;
			const key: []const u8 = parseIdentifierOrStringOrEnumLiteral(allocator, chars, index);
			skipWhitespaceAndComments(chars, index);
			while (index.* < chars.len and chars[index.*] != '=') {
				printError(filePath, chars, index.*, "Unexpected character in object parsing, expected '='.");
				index.* += 1;
			}
			index.* += 1;
			skipWhitespaceAndComments(chars, index);
			const value: ZonElement = parseElement(allocator, filePath, chars, index);
			if (map.fetchPut(key, value) catch unreachable) |old| {
				printError(filePath, chars, keyIndex, "Duplicate key.");
				allocator.free(old.key);
				old.value.deinit(allocator);
			}
			skipWhitespaceAndComments(chars, index);
			if (index.* < chars.len and chars[index.*] == ',') {
				index.* += 1;
			}
		}
		printError(filePath, chars, index.*, "Unexpected end of file in object parsing.");
		return .{.object = map};
	}

	fn printError(filePath: ?[]const u8, chars: []const u8, index: u32, msg: []const u8) void {
		var lineNumber: u32 = 1;
		var lineStart: u32 = 0;
		var i: u32 = 0;
		while (i < index and i < chars.len) : (i += 1) {
			if (chars[i] == '\n') {
				lineNumber += 1;
				lineStart = i + 1;
			}
		}
		while (i < chars.len) : (i += 1) {
			if (chars[i] == '\n') {
				break;
			}
		}
		const lineEnd: u32 = i;
		if (filePath) |_filePath| {
			std.log.err("In file {s}:", .{_filePath});
		}
		std.log.err("Error in line {}: {s}", .{lineNumber, msg});
		std.log.err("{s}", .{chars[lineStart..lineEnd]});
		// Mark the position:
		var message: [512]u8 = undefined;
		i = lineStart;
		var outputI: u32 = 0;
		while (i < index and i < chars.len) : (i += 1) {
			if ((chars[i] & 128) != 0 and (chars[i] & 64) == 0) {
				// Not the start of a utf8 character
				continue;
			}
			if (chars[i] == '\t') {
				message[outputI] = '\t';
			} else {
				message[outputI] = ' ';
			}
			outputI += 1;
			if (outputI >= message.len) {
				return; // 512 characters is too long for this output to be helpful.
			}
		}
		message[outputI] = '^';
		outputI += 1;
		std.log.err("{s}", .{message[0..outputI]});
	}

	/// Assumes that the region starts with a non-space character.
	fn parseElement(allocator: NeverFailingAllocator, filePath: ?[]const u8, chars: []const u8, index: *u32) ZonElement {
		if (index.* >= chars.len) {
			printError(filePath, chars, index.*, "Unexpected end of file.");
			return .null;
		}
		sw: switch (chars[index.*]) {
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-' => {
				return parseNumber(chars, index);
			},
			't' => { // Value can only be true.
				if (index.* + 3 >= chars.len) {
					printError(filePath, chars, index.*, "Unexpected end of file.");
				} else if (chars[index.* + 1] != 'r' or chars[index.* + 2] != 'u' or chars[index.* + 3] != 'e') {
					printError(filePath, chars, index.*, "Unknown expression, interpreting as true.");
				}
				index.* += 4;
				return .{.bool = true};
			},
			'f' => { // Value can only be false.
				if (index.* + 4 >= chars.len) {
					printError(filePath, chars, index.*, "Unexpected end of file.");
				} else if (chars[index.* + 1] != 'a' or chars[index.* + 2] != 'l' or chars[index.* + 3] != 's' or chars[index.* + 4] != 'e') {
					printError(filePath, chars, index.*, "Unknown expression, interpreting as false.");
				}
				index.* += 5;
				return .{.bool = false};
			},
			'n' => { // Value can only be null.
				if (index.* + 3 >= chars.len) {
					printError(filePath, chars, index.*, "Unexpected end of file.");
				} else if (chars[index.* + 1] != 'u' or chars[index.* + 2] != 'l' or chars[index.* + 3] != 'l') {
					printError(filePath, chars, index.*, "Unknown expression, interpreting as null.");
				}
				index.* += 4;
				return .{.null = {}};
			},
			'\"' => {
				index.* += 1;
				return .{.stringOwned = parseString(allocator, chars, index)};
			},
			'.' => {
				index.* += 1;
				if (index.* >= chars.len) {
					printError(filePath, chars, index.*, "Unexpected end of file.");
					return .null;
				}
				if (chars[index.*] == '{') continue :sw '{';
				if (std.ascii.isDigit(chars[index.*])) {
					index.* -= 1;
					return parseNumber(chars, index);
				}
				return .{.stringOwned = parseIdentifierOrStringOrEnumLiteral(allocator, chars, index)};
			},
			'{' => {
				index.* += 1;
				skipWhitespaceAndComments(chars, index);
				var foundEqualSign: bool = false;
				var i: usize = index.*;
				while (i < chars.len) : (i += 1) {
					if (chars[i] == '"') {
						i += 1;
						while (chars[i] != '"' and i < chars.len) {
							if (chars[i] == '\\') i += 1;
							i += 1;
						}
						continue;
					}
					if (chars[i] == ',' or chars[i] == '{') break;
					if (chars[i] == '=') {
						foundEqualSign = true;
						break;
					}
				}
				if (foundEqualSign) {
					return parseObject(allocator, filePath, chars, index);
				} else {
					return parseArray(allocator, filePath, chars, index);
				}
			},
			else => {
				printError(filePath, chars, index.*, "Unexpected character.");
				index.* += 1;
				return .null;
			},
		}
	}
};

// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// MARK: Testing
// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

test "skipWhitespaceAndComments" {
	var index: u32 = 0;
	var testString: []const u8 = "  fbdn  ";
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 2);
	testString = "\nĦŊ@Λħŋ";
	index = 0;
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 1);
	testString = "\tβρδ→øβν";
	index = 0;
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 1);
	testString = "\t  \n \t  a lot of whitespaces";
	index = 0;
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 8);
	testString = " unicode whitespace";
	index = 0;
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 3);
	testString = "starting     in the middle";
	index = 8;
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 13);
	testString = "// this should all get skipped\nBut Not this";
	index = 0;
	Parser.skipWhitespaceAndComments(testString, &index);
	try std.testing.expectEqual(index, 31);
}

test "number parsing" {
	// Integers:
	var index: u32 = 0;
	try std.testing.expectEqual(Parser.parseNumber("0", &index), ZonElement{.int = 0});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("+0", &index), ZonElement{.int = 0});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("abcd", &index), ZonElement{.int = 0});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("-0+1", &index), ZonElement{.int = 0});
	index = 5;
	try std.testing.expectEqual(Parser.parseNumber(" abcd185473896", &index), ZonElement{.int = 185473896});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("0xff34786056.0", &index), ZonElement{.int = 0xff34786056});
	// Floats:
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("0.0", &index), ZonElement{.float = 0.0});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("0e10e10", &index), ZonElement{.float = 0.0});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("-0.0.0", &index), ZonElement{.float = 0.0});
	index = 0;
	try std.testing.expectEqual(Parser.parseNumber("0xabcd.0e10+-+-", &index), ZonElement{.int = 0xabcd});
	index = 0;
	try std.testing.expectApproxEqAbs(Parser.parseNumber("1.234589e10", &index).float, 1.234589e10, 1.0);
	index = 5;
	try std.testing.expectApproxEqAbs(Parser.parseNumber("_____0.0000000000234589e10abcdfe", &index).float, 0.234589, 1e-10);
}

test "element parsing" {
	var wrap = main.heap.ErrorHandlingAllocator.init(std.testing.allocator);
	const allocator = wrap.allocator();
	// Integers:
	var index: u32 = 0;
	try std.testing.expectEqual(Parser.parseElement(allocator, null, "0", &index), ZonElement{.int = 0});
	index = 0;
	try std.testing.expectEqual(Parser.parseElement(allocator, null, "0xff34786056.0, true", &index), ZonElement{.int = 0xff34786056});
	// Floats:
	index = 10;
	try std.testing.expectEqual(Parser.parseElement(allocator, null, ".{.abcd = 0.0,}", &index), ZonElement{.float = 0.0});
	index = 0;
	try std.testing.expectApproxEqAbs((Parser.parseElement(allocator, null, "1543.234589e10", &index)).float, 1543.234589e10, 1.0);
	index = 5;
	try std.testing.expectApproxEqAbs((Parser.parseElement(allocator, null, "_____0.0000000000675849301354e10abcdfe", &index)).float, 0.675849301354, 1e-10);
	// Null:
	index = 0;
	try std.testing.expectEqual(Parser.parseElement(allocator, null, "null", &index), ZonElement{.null = {}});
	// true:
	index = 0;
	try std.testing.expectEqual(Parser.parseElement(allocator, null, "true", &index), ZonElement{.bool = true});
	// false:
	index = 0;
	try std.testing.expectEqual(Parser.parseElement(allocator, null, "false", &index), ZonElement{.bool = false});

	// String:
	index = 0;
	var result: ZonElement = Parser.parseElement(allocator, null, "\"abcd\\\"\\\\ħσ→ ↑Φ∫€ ⌬ ε→Π\"", &index);
	try std.testing.expectEqualStrings("abcd\"\\ħσ→ ↑Φ∫€ ⌬ ε→Π", result.as([]const u8, ""));
	result.deinit(allocator);
	index = 0;
	result = Parser.parseElement(allocator, null, "\"12345", &index);
	try std.testing.expectEqualStrings("12345", result.as([]const u8, ""));
	result.deinit(allocator);

	// Object:
	index = 0;
	result = Parser.parseElement(allocator, null, ".{.name = 1}", &index);
	try std.testing.expectEqual(.object, std.meta.activeTag(result));
	try std.testing.expectEqual(result.object.get("name"), ZonElement{.int = 1});
	result.deinit(allocator);
	index = 0;
	result = Parser.parseElement(allocator, null, ".{@\"object\"=.{},}", &index);
	try std.testing.expectEqual(.object, std.meta.activeTag(result));
	try std.testing.expectEqual(.array, std.meta.activeTag(result.object.get("object") orelse .null));
	result.deinit(allocator);
	index = 0;
	result = Parser.parseElement(allocator, null, ".{   .object1   =   \"\"  \n, .object2  =\t.{\n},.object3   =1.0e4\t,@\"\nobject1\"=.{},@\"\tobject1θ\"=.{},}", &index);
	try std.testing.expectEqual(.object, std.meta.activeTag(result));
	try std.testing.expectEqual(.float, std.meta.activeTag(result.object.get("object3") orelse .null));
	try std.testing.expectEqual(.stringOwned, std.meta.activeTag(result.object.get("object1") orelse .null));
	try std.testing.expectEqual(.array, std.meta.activeTag(result.object.get("\nobject1") orelse .null));
	try std.testing.expectEqual(.array, std.meta.activeTag(result.object.get("\tobject1θ") orelse .null));
	result.deinit(allocator);

	// Array:
	index = 0;
	result = Parser.parseElement(allocator, null, ".{.name,1}", &index);
	try std.testing.expectEqual(.array, std.meta.activeTag(result));
	try std.testing.expectEqual(.stringOwned, std.meta.activeTag(result.array.items[0]));
	try std.testing.expectEqual(ZonElement{.int = 1}, result.array.items[1]);
	result.deinit(allocator);
	index = 0;
	result = Parser.parseElement(allocator, null, ".{   \"name\"\t1\n,    17.1}", &index);
	try std.testing.expectEqual(.array, std.meta.activeTag(result));
	try std.testing.expectEqual(.stringOwned, std.meta.activeTag(result.array.items[0]));
	try std.testing.expectEqual(ZonElement{.int = 1}, result.array.items[1]);
	try std.testing.expectEqual(ZonElement{.float = 17.1}, result.array.items[2]);
	result.deinit(allocator);
}

test "merging" {
	var wrap = main.heap.ErrorHandlingAllocator.init(std.testing.allocator);
	const allocator = wrap.allocator();

	const zon1 = ZonElement.parseFromString(allocator, null, ".{.object1 = \"\", .object2 = .{}, .object3 = 1.0e4, @\"\nobject1\" = .{}, @\"\tobject1θ\" = .{}}");
	defer zon1.deinit(allocator);

	const zon2 = ZonElement.parseFromString(allocator, null, ".{.object5 = 1}");
	zon2.join(.preferRight, zon1);
	try std.testing.expectEqual(.object, std.meta.activeTag(zon2));
	try std.testing.expectEqual(.float, std.meta.activeTag(zon2.object.get("object3") orelse .null));
	try std.testing.expectEqual(.stringOwned, std.meta.activeTag(zon2.object.get("object1") orelse .null));
	try std.testing.expectEqual(.array, std.meta.activeTag(zon2.object.get("\nobject1") orelse .null));
	try std.testing.expectEqual(.array, std.meta.activeTag(zon2.object.get("\tobject1θ") orelse .null));
	try std.testing.expectEqual(.int, std.meta.activeTag(zon2.object.get("object5") orelse .null));
	zon2.deinit(allocator);

	const zon3 = ZonElement.parseFromString(allocator, null, "1");
	zon3.join(.preferRight, zon1);
	zon3.deinit(allocator);

	const zon4 = ZonElement.parseFromString(allocator, null, "true");
	zon1.join(.preferRight, zon4);
	zon4.deinit(allocator);

	const zon5 = ZonElement.parseFromString(allocator, null, ".{.object1 = \"\", .object2 = .{}, .object3 = 1.0e4, @\"\nobject1\" = .{}, @\"\tobject1θ\" = .{}}");
	defer zon5.deinit(allocator);

	const zon6 = ZonElement.parseFromString(allocator, null, ".{.object5 = 1}");
	zon5.join(.preferLeft, zon6);
	try std.testing.expectEqual(.object, std.meta.activeTag(zon5));
	try std.testing.expectEqual(.float, std.meta.activeTag(zon5.object.get("object3") orelse .null));
	try std.testing.expectEqual(.stringOwned, std.meta.activeTag(zon5.object.get("object1") orelse .null));
	try std.testing.expectEqual(.array, std.meta.activeTag(zon5.object.get("\nobject1") orelse .null));
	try std.testing.expectEqual(.array, std.meta.activeTag(zon5.object.get("\tobject1θ") orelse .null));
	try std.testing.expectEqual(.int, std.meta.activeTag(zon5.object.get("object5") orelse .null));
	zon6.deinit(allocator);

	const zon7 = ZonElement.parseFromString(allocator, null, "1");
	zon5.join(.preferLeft, zon7);
	zon7.deinit(allocator);

	const zon8 = ZonElement.parseFromString(allocator, null, "true");
	zon8.join(.preferLeft, zon5);
	zon8.deinit(allocator);

	const zon9 = ZonElement.parseFromString(allocator, null, ".{.a = 1, .b = .{.a = 2, .b = 3}}");
	defer zon9.deinit(allocator);
	const zon10 = ZonElement.parseFromString(allocator, null, ".{.c = \"foo\", .b = .{.a = \"bar\"}}");
	defer zon10.deinit(allocator);
	zon9.join(.preferLeft, zon10);
	try std.testing.expectEqual(zon9.get(?i32, "a", null), 1);
	try std.testing.expectEqualSlices(u8, zon9.get(?[]const u8, "c", null).?, "foo");
	try std.testing.expectEqual(zon9.getChild("b").get(?i32, "a", null), 2);
	try std.testing.expectEqual(zon9.getChild("b").get(?i32, "b", null), 3);

	const zon11 = ZonElement.parseFromString(allocator, null, ".{.a = 1, .b = .{.a = 2, .b = 3}}");
	defer zon11.deinit(allocator);
	const zon12 = ZonElement.parseFromString(allocator, null, ".{.c = \"foo\", .b = .{.a = \"bar\"}}");
	defer zon12.deinit(allocator);
	zon11.join(.preferRight, zon12);
	try std.testing.expectEqual(zon11.get(?i32, "a", null), 1);
	try std.testing.expectEqualSlices(u8, zon11.get(?[]const u8, "c", null).?, "foo");
	try std.testing.expectEqualSlices(u8, zon11.getChild("b").get(?[]const u8, "a", null).?, "bar");
	try std.testing.expectEqual(zon11.getChild("b").get(?i32, "b", null), 3);
}

```