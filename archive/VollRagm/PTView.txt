Project Path: arc_VollRagm_PTView_06hz2o35

Source Tree:

```txt
arc_VollRagm_PTView_06hz2o35
├── LICENSE
├── README.md
└── src
    └── PTView
        ├── PTView.sln
        ├── PTViewClient
        │   ├── App.config
        │   ├── HexDumpView.Designer.cs
        │   ├── HexDumpView.cs
        │   ├── HexDumpView.resx
        │   ├── MainForm.Designer.cs
        │   ├── MainForm.cs
        │   ├── MainForm.resx
        │   ├── PTView
        │   │   ├── Driver
        │   │   │   ├── DriverInterface.cs
        │   │   │   └── Internal
        │   │   │       └── Constants.cs
        │   │   ├── Misc.cs
        │   │   ├── Native.cs
        │   │   └── Structures.cs
        │   ├── PTViewClient.csproj
        │   ├── Program.cs
        │   ├── Properties
        │   │   ├── AssemblyInfo.cs
        │   │   ├── Resources.Designer.cs
        │   │   ├── Resources.resx
        │   │   ├── Settings.Designer.cs
        │   │   └── Settings.settings
        │   └── app.manifest
        └── PTViewDriver
            ├── PTViewDriver.inf
            ├── PTViewDriver.vcxproj
            ├── PTViewDriver.vcxproj.filters
            ├── com.cpp
            ├── com.h
            ├── main.cpp
            ├── ptutil.cpp
            ├── ptutil.h
            ├── undocumented.h
            └── util.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 VollRagm

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# PTView
This utility allows you to inspect a Windows processes Page Tables live.
You can browse through them in a GUI and dump the physical pages they point to, as well as translate virtual to physical addresses and get the virtual address to a PTE.

## Usage
You will have to load the driver before running the client.
I recommend loading the Driver normally in test mode, but it can be mapped as well, just make sure the first argument is the driver base and the second argument is NULL.
After opening the client, select a process and start browsing its page tables!

## Key features

 - Browse Page Tables of Processes, including system processes
 - Highlight different types of Pages
 - Dump a physical page
 - Get the virtual address that leads to the current selection
 - Translate a physical address to virtual address with visualization
 - Get information on a Page table entry
 - Support for Large Pages

## Things worth trying out

 1. **Dump the PML4 itself over its auto-entry (self-reference):**  

Every PML4 keeps an entry that has the PML4's address as PFN itself. This entry is at a fixed index, that Windows nowadays sets randomly during boot.
If this entry is selected the PDPT actually is the PML4 itself again. If you select it in the PDPT again, the PD also is the PML4 again. If you continue that until the end, the PT will be the PML4, and you will be able to use the PML4 auto-entry to dump the PML4 itself or get its virtual address.
Note that this address only is valid in the selected processes context.

![PML4 auto-entry selected](https://i.imgur.com/qUI7WDO.png) 

 2. **Watch Windows Memory manager map pages, that have been paged out to disk:**  

Get the virtual address of an unused loaded module in the process. Enter it in the Virtual Address textbox and translate it.
Chances are that the PTE of that VA or the subsequent PTE's PFNs is 0x0. 
Now access the virtual address using a Debugger or Memory viewer, like Cheat Engine, and you will see how it raises a page fault, causing Windows Memory Manager to map the pages live.


A prebuilt release can be downloaded [here.](https://github.com/VollRagm/PTView/releases/latest)

```

`src/PTView/PTView.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PTViewDriver", "PTViewDriver\PTViewDriver.vcxproj", "{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PTViewClient", "PTViewClient\PTViewClient.csproj", "{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|ARM.ActiveCfg = Debug|ARM
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|ARM.Build.0 = Debug|ARM
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|ARM.Deploy.0 = Debug|ARM
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|ARM64.Build.0 = Debug|ARM64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|x64.ActiveCfg = Debug|x64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|x64.Build.0 = Debug|x64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|x64.Deploy.0 = Debug|x64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|x86.ActiveCfg = Debug|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|x86.Build.0 = Debug|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Debug|x86.Deploy.0 = Debug|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|Any CPU.ActiveCfg = Release|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|ARM.ActiveCfg = Release|ARM
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|ARM.Build.0 = Release|ARM
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|ARM.Deploy.0 = Release|ARM
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|ARM64.ActiveCfg = Release|ARM64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|ARM64.Build.0 = Release|ARM64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|ARM64.Deploy.0 = Release|ARM64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|x64.ActiveCfg = Release|x64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|x64.Build.0 = Release|x64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|x64.Deploy.0 = Release|x64
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|x86.ActiveCfg = Release|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|x86.Build.0 = Release|Win32
		{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}.Release|x86.Deploy.0 = Release|Win32
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|ARM.Build.0 = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|ARM64.Build.0 = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|x64.Build.0 = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Debug|x86.Build.0 = Debug|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|Any CPU.Build.0 = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|ARM.ActiveCfg = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|ARM.Build.0 = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|ARM64.ActiveCfg = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|ARM64.Build.0 = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|x64.ActiveCfg = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|x64.Build.0 = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|x86.ActiveCfg = Release|Any CPU
		{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5DD1F5DE-E5A1-41F9-8BC0-17A8BF3D7128}
	EndGlobalSection
EndGlobal

```

`src/PTView/PTViewClient/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
</configuration>
```

`src/PTView/PTViewClient/HexDumpView.Designer.cs`:

```cs

namespace PTViewClient
{
    partial class HexDumpView
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.ByteViewerPanel = new System.Windows.Forms.Panel();
            this.SaveRawBtn = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // ByteViewerPanel
            // 
            this.ByteViewerPanel.Location = new System.Drawing.Point(1, 2);
            this.ByteViewerPanel.Name = "ByteViewerPanel";
            this.ByteViewerPanel.Size = new System.Drawing.Size(660, 547);
            this.ByteViewerPanel.TabIndex = 0;
            // 
            // SaveRawBtn
            // 
            this.SaveRawBtn.Location = new System.Drawing.Point(586, 555);
            this.SaveRawBtn.Name = "SaveRawBtn";
            this.SaveRawBtn.Size = new System.Drawing.Size(75, 23);
            this.SaveRawBtn.TabIndex = 1;
            this.SaveRawBtn.Text = "Save Raw";
            this.SaveRawBtn.UseVisualStyleBackColor = true;
            this.SaveRawBtn.Click += new System.EventHandler(this.SaveRawBtn_Click);
            // 
            // HexDumpView
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(666, 590);
            this.Controls.Add(this.SaveRawBtn);
            this.Controls.Add(this.ByteViewerPanel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.Name = "HexDumpView";
            this.Text = "Hex Dump";
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel ByteViewerPanel;
        private System.Windows.Forms.Button SaveRawBtn;
    }
}
```

`src/PTView/PTViewClient/HexDumpView.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace PTViewClient
{
    public partial class HexDumpView : Form
    {
        private byte[] Data;

        public HexDumpView(byte[] data)
        {
            InitializeComponent();
            Data = data;

            ByteViewer bw = new ByteViewer();
            bw.SetBytes(Data);
            bw.Height = ByteViewerPanel.Height;
            ByteViewerPanel.Controls.Add(bw);
        }

        private void SaveRawBtn_Click(object sender, EventArgs e)
        {
            SaveFileDialog sfd = new SaveFileDialog();
            sfd.Title = "Save dump...";
            sfd.InitialDirectory = Directory.GetCurrentDirectory();
            
            if(sfd.ShowDialog() == DialogResult.OK)
            {
                File.WriteAllBytes(sfd.FileName, Data);
            }
        }
    }
}

```

`src/PTView/PTViewClient/HexDumpView.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`src/PTView/PTViewClient/MainForm.Designer.cs`:

```cs

namespace PTViewClient
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.lbl1 = new System.Windows.Forms.Label();
            this.ProcessesComboBox = new System.Windows.Forms.ComboBox();
            this.PTViewPanel = new System.Windows.Forms.Panel();
            this.DumpPageBtn = new System.Windows.Forms.Button();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.TranslateBtn = new System.Windows.Forms.Button();
            this.VirtualAddressInfoLblInput = new System.Windows.Forms.Label();
            this.label7 = new System.Windows.Forms.Label();
            this.VirtualAddressInput = new System.Windows.Forms.TextBox();
            this.label6 = new System.Windows.Forms.Label();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.VirtualAddressOutput = new System.Windows.Forms.TextBox();
            this.VirtualAddressInfoLbl = new System.Windows.Forms.Label();
            this.PTeInfoLbl = new System.Windows.Forms.Label();
            this.PDeInfoLbl = new System.Windows.Forms.Label();
            this.PDPTeLblInfo = new System.Windows.Forms.Label();
            this.PML4eInfoLbl = new System.Windows.Forms.Label();
            this.PtTextLbl = new System.Windows.Forms.Label();
            this.PTListBox = new System.Windows.Forms.ListBox();
            this.label3 = new System.Windows.Forms.Label();
            this.PDListBox = new System.Windows.Forms.ListBox();
            this.label2 = new System.Windows.Forms.Label();
            this.PDPTListBox = new System.Windows.Forms.ListBox();
            this.label1 = new System.Windows.Forms.Label();
            this.PML4ListBox = new System.Windows.Forms.ListBox();
            this.DirbaseLbl = new System.Windows.Forms.Label();
            this.UpdateContentTmr = new System.Windows.Forms.Timer(this.components);
            this.label5 = new System.Windows.Forms.Label();
            this.HighlightModeNx = new System.Windows.Forms.RadioButton();
            this.HighlightModeSupervisor = new System.Windows.Forms.RadioButton();
            this.HighlightModeNone = new System.Windows.Forms.RadioButton();
            this.PML4AutoEntryHighlight = new System.Windows.Forms.CheckBox();
            this.PTViewPanel.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.SuspendLayout();
            // 
            // lbl1
            // 
            this.lbl1.AutoSize = true;
            this.lbl1.Location = new System.Drawing.Point(25, 21);
            this.lbl1.Name = "lbl1";
            this.lbl1.Size = new System.Drawing.Size(48, 13);
            this.lbl1.TabIndex = 0;
            this.lbl1.Text = "Process:";
            // 
            // ProcessesComboBox
            // 
            this.ProcessesComboBox.FormattingEnabled = true;
            this.ProcessesComboBox.Location = new System.Drawing.Point(79, 18);
            this.ProcessesComboBox.Name = "ProcessesComboBox";
            this.ProcessesComboBox.Size = new System.Drawing.Size(211, 21);
            this.ProcessesComboBox.TabIndex = 1;
            this.ProcessesComboBox.DropDown += new System.EventHandler(this.ProcessesComboBox_DropDown);
            this.ProcessesComboBox.SelectedValueChanged += new System.EventHandler(this.ProcessesComboBox_SelectedValueChanged);
            // 
            // PTViewPanel
            // 
            this.PTViewPanel.Controls.Add(this.DumpPageBtn);
            this.PTViewPanel.Controls.Add(this.groupBox2);
            this.PTViewPanel.Controls.Add(this.groupBox1);
            this.PTViewPanel.Controls.Add(this.PTeInfoLbl);
            this.PTViewPanel.Controls.Add(this.PDeInfoLbl);
            this.PTViewPanel.Controls.Add(this.PDPTeLblInfo);
            this.PTViewPanel.Controls.Add(this.PML4eInfoLbl);
            this.PTViewPanel.Controls.Add(this.PtTextLbl);
            this.PTViewPanel.Controls.Add(this.PTListBox);
            this.PTViewPanel.Controls.Add(this.label3);
            this.PTViewPanel.Controls.Add(this.PDListBox);
            this.PTViewPanel.Controls.Add(this.label2);
            this.PTViewPanel.Controls.Add(this.PDPTListBox);
            this.PTViewPanel.Controls.Add(this.label1);
            this.PTViewPanel.Controls.Add(this.PML4ListBox);
            this.PTViewPanel.Controls.Add(this.DirbaseLbl);
            this.PTViewPanel.Location = new System.Drawing.Point(12, 45);
            this.PTViewPanel.Name = "PTViewPanel";
            this.PTViewPanel.Size = new System.Drawing.Size(1145, 661);
            this.PTViewPanel.TabIndex = 2;
            this.PTViewPanel.Visible = false;
            // 
            // DumpPageBtn
            // 
            this.DumpPageBtn.Location = new System.Drawing.Point(894, 468);
            this.DumpPageBtn.Name = "DumpPageBtn";
            this.DumpPageBtn.Size = new System.Drawing.Size(129, 23);
            this.DumpPageBtn.TabIndex = 7;
            this.DumpPageBtn.Text = "Dump Selected Page";
            this.DumpPageBtn.UseVisualStyleBackColor = true;
            this.DumpPageBtn.Click += new System.EventHandler(this.DumpPageBtn_Click);
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.TranslateBtn);
            this.groupBox2.Controls.Add(this.VirtualAddressInfoLblInput);
            this.groupBox2.Controls.Add(this.label7);
            this.groupBox2.Controls.Add(this.VirtualAddressInput);
            this.groupBox2.Controls.Add(this.label6);
            this.groupBox2.Location = new System.Drawing.Point(906, 204);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(220, 149);
            this.groupBox2.TabIndex = 6;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Address Translation";
            // 
            // TranslateBtn
            // 
            this.TranslateBtn.Location = new System.Drawing.Point(60, 117);
            this.TranslateBtn.Name = "TranslateBtn";
            this.TranslateBtn.Size = new System.Drawing.Size(102, 23);
            this.TranslateBtn.TabIndex = 3;
            this.TranslateBtn.Text = "Translate";
            this.TranslateBtn.UseVisualStyleBackColor = true;
            this.TranslateBtn.Click += new System.EventHandler(this.TranslateBtn_Click);
            // 
            // VirtualAddressInfoLblInput
            // 
            this.VirtualAddressInfoLblInput.AutoSize = true;
            this.VirtualAddressInfoLblInput.Location = new System.Drawing.Point(16, 50);
            this.VirtualAddressInfoLblInput.Name = "VirtualAddressInfoLblInput";
            this.VirtualAddressInfoLblInput.Size = new System.Drawing.Size(0, 13);
            this.VirtualAddressInfoLblInput.TabIndex = 2;
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Location = new System.Drawing.Point(8, 28);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(80, 13);
            this.label7.TabIndex = 2;
            this.label7.Text = "Virtual Address:";
            // 
            // VirtualAddressInput
            // 
            this.VirtualAddressInput.Location = new System.Drawing.Point(88, 25);
            this.VirtualAddressInput.Name = "VirtualAddressInput";
            this.VirtualAddressInput.Size = new System.Drawing.Size(125, 20);
            this.VirtualAddressInput.TabIndex = 1;
            this.VirtualAddressInput.TextChanged += new System.EventHandler(this.VirtualAddressInput_TextChanged);
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(17, 25);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(0, 13);
            this.label6.TabIndex = 0;
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.VirtualAddressOutput);
            this.groupBox1.Controls.Add(this.VirtualAddressInfoLbl);
            this.groupBox1.Location = new System.Drawing.Point(906, 58);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(220, 122);
            this.groupBox1.TabIndex = 5;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Virtual Address";
            // 
            // VirtualAddressOutput
            // 
            this.VirtualAddressOutput.Location = new System.Drawing.Point(9, 92);
            this.VirtualAddressOutput.Name = "VirtualAddressOutput";
            this.VirtualAddressOutput.ReadOnly = true;
            this.VirtualAddressOutput.Size = new System.Drawing.Size(205, 20);
            this.VirtualAddressOutput.TabIndex = 1;
            // 
            // VirtualAddressInfoLbl
            // 
            this.VirtualAddressInfoLbl.AutoSize = true;
            this.VirtualAddressInfoLbl.Location = new System.Drawing.Point(17, 25);
            this.VirtualAddressInfoLbl.Name = "VirtualAddressInfoLbl";
            this.VirtualAddressInfoLbl.Size = new System.Drawing.Size(0, 13);
            this.VirtualAddressInfoLbl.TabIndex = 0;
            // 
            // PTeInfoLbl
            // 
            this.PTeInfoLbl.AutoSize = true;
            this.PTeInfoLbl.Location = new System.Drawing.Point(687, 495);
            this.PTeInfoLbl.Name = "PTeInfoLbl";
            this.PTeInfoLbl.Size = new System.Drawing.Size(0, 13);
            this.PTeInfoLbl.TabIndex = 4;
            // 
            // PDeInfoLbl
            // 
            this.PDeInfoLbl.AutoSize = true;
            this.PDeInfoLbl.Location = new System.Drawing.Point(469, 497);
            this.PDeInfoLbl.Name = "PDeInfoLbl";
            this.PDeInfoLbl.Size = new System.Drawing.Size(0, 13);
            this.PDeInfoLbl.TabIndex = 4;
            // 
            // PDPTeLblInfo
            // 
            this.PDPTeLblInfo.AutoSize = true;
            this.PDPTeLblInfo.Location = new System.Drawing.Point(259, 497);
            this.PDPTeLblInfo.Name = "PDPTeLblInfo";
            this.PDPTeLblInfo.Size = new System.Drawing.Size(0, 13);
            this.PDPTeLblInfo.TabIndex = 4;
            // 
            // PML4eInfoLbl
            // 
            this.PML4eInfoLbl.AutoSize = true;
            this.PML4eInfoLbl.Location = new System.Drawing.Point(39, 497);
            this.PML4eInfoLbl.Name = "PML4eInfoLbl";
            this.PML4eInfoLbl.Size = new System.Drawing.Size(0, 13);
            this.PML4eInfoLbl.TabIndex = 3;
            // 
            // PtTextLbl
            // 
            this.PtTextLbl.AutoSize = true;
            this.PtTextLbl.Location = new System.Drawing.Point(778, 42);
            this.PtTextLbl.Name = "PtTextLbl";
            this.PtTextLbl.Size = new System.Drawing.Size(21, 13);
            this.PtTextLbl.TabIndex = 2;
            this.PtTextLbl.Text = "PT";
            // 
            // PTListBox
            // 
            this.PTListBox.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
            this.PTListBox.Location = new System.Drawing.Point(678, 58);
            this.PTListBox.Name = "PTListBox";
            this.PTListBox.Size = new System.Drawing.Size(210, 433);
            this.PTListBox.TabIndex = 1;
            this.PTListBox.DrawItem += new System.Windows.Forms.DrawItemEventHandler(this.PTListBox_DrawItem);
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(567, 42);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(22, 13);
            this.label3.TabIndex = 2;
            this.label3.Text = "PD";
            // 
            // PDListBox
            // 
            this.PDListBox.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
            this.PDListBox.Location = new System.Drawing.Point(462, 58);
            this.PDListBox.Name = "PDListBox";
            this.PDListBox.Size = new System.Drawing.Size(210, 433);
            this.PDListBox.TabIndex = 1;
            this.PDListBox.DrawItem += new System.Windows.Forms.DrawItemEventHandler(this.PDListBox_DrawItem);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(338, 42);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(36, 13);
            this.label2.TabIndex = 2;
            this.label2.Text = "PDPT";
            // 
            // PDPTListBox
            // 
            this.PDPTListBox.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
            this.PDPTListBox.Location = new System.Drawing.Point(246, 58);
            this.PDPTListBox.Name = "PDPTListBox";
            this.PDPTListBox.Size = new System.Drawing.Size(210, 433);
            this.PDPTListBox.TabIndex = 1;
            this.PDPTListBox.DrawItem += new System.Windows.Forms.DrawItemEventHandler(this.PDPTListBox_DrawItem);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(99, 42);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(35, 13);
            this.label1.TabIndex = 2;
            this.label1.Text = "PML4";
            // 
            // PML4ListBox
            // 
            this.PML4ListBox.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
            this.PML4ListBox.Location = new System.Drawing.Point(30, 58);
            this.PML4ListBox.Name = "PML4ListBox";
            this.PML4ListBox.Size = new System.Drawing.Size(210, 433);
            this.PML4ListBox.TabIndex = 1;
            this.PML4ListBox.DrawItem += new System.Windows.Forms.DrawItemEventHandler(this.PML4ListBox_DrawItem);
            // 
            // DirbaseLbl
            // 
            this.DirbaseLbl.AutoSize = true;
            this.DirbaseLbl.Location = new System.Drawing.Point(13, 12);
            this.DirbaseLbl.Name = "DirbaseLbl";
            this.DirbaseLbl.Size = new System.Drawing.Size(70, 13);
            this.DirbaseLbl.TabIndex = 0;
            this.DirbaseLbl.Text = "Dirbase (cr3):";
            // 
            // UpdateContentTmr
            // 
            this.UpdateContentTmr.Tick += new System.EventHandler(this.UpdateContentTmr_Tick);
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(370, 17);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(81, 13);
            this.label5.TabIndex = 4;
            this.label5.Text = "Highlight Mode:";
            // 
            // HighlightModeNx
            // 
            this.HighlightModeNx.AutoSize = true;
            this.HighlightModeNx.Location = new System.Drawing.Point(457, 54);
            this.HighlightModeNx.Name = "HighlightModeNx";
            this.HighlightModeNx.Size = new System.Drawing.Size(194, 17);
            this.HighlightModeNx.TabIndex = 5;
            this.HighlightModeNx.Text = "Highlight executable pages in green";
            this.HighlightModeNx.UseVisualStyleBackColor = true;
            this.HighlightModeNx.CheckedChanged += new System.EventHandler(this.HighlightModeNx_CheckedChanged);
            // 
            // HighlightModeSupervisor
            // 
            this.HighlightModeSupervisor.AutoSize = true;
            this.HighlightModeSupervisor.Location = new System.Drawing.Point(457, 34);
            this.HighlightModeSupervisor.Name = "HighlightModeSupervisor";
            this.HighlightModeSupervisor.Size = new System.Drawing.Size(242, 17);
            this.HighlightModeSupervisor.TabIndex = 5;
            this.HighlightModeSupervisor.Text = "Highlight User (green) and Kernel (blue) pages";
            this.HighlightModeSupervisor.UseVisualStyleBackColor = true;
            // 
            // HighlightModeNone
            // 
            this.HighlightModeNone.AutoSize = true;
            this.HighlightModeNone.Checked = true;
            this.HighlightModeNone.Location = new System.Drawing.Point(457, 15);
            this.HighlightModeNone.Name = "HighlightModeNone";
            this.HighlightModeNone.Size = new System.Drawing.Size(51, 17);
            this.HighlightModeNone.TabIndex = 6;
            this.HighlightModeNone.TabStop = true;
            this.HighlightModeNone.Text = "None";
            this.HighlightModeNone.UseVisualStyleBackColor = true;
            this.HighlightModeNone.CheckedChanged += new System.EventHandler(this.HighlightModeNone_CheckedChanged);
            // 
            // PML4AutoEntryHighlight
            // 
            this.PML4AutoEntryHighlight.AutoSize = true;
            this.PML4AutoEntryHighlight.Location = new System.Drawing.Point(713, 16);
            this.PML4AutoEntryHighlight.Name = "PML4AutoEntryHighlight";
            this.PML4AutoEntryHighlight.Size = new System.Drawing.Size(210, 17);
            this.PML4AutoEntryHighlight.TabIndex = 7;
            this.PML4AutoEntryHighlight.Text = "Highlight PML4 auto-entry in lime green";
            this.PML4AutoEntryHighlight.UseVisualStyleBackColor = true;
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1169, 710);
            this.Controls.Add(this.PML4AutoEntryHighlight);
            this.Controls.Add(this.HighlightModeNone);
            this.Controls.Add(this.HighlightModeSupervisor);
            this.Controls.Add(this.HighlightModeNx);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.PTViewPanel);
            this.Controls.Add(this.ProcessesComboBox);
            this.Controls.Add(this.lbl1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.Name = "MainForm";
            this.Text = "PTView";
            this.PTViewPanel.ResumeLayout(false);
            this.PTViewPanel.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lbl1;
        private System.Windows.Forms.ComboBox ProcessesComboBox;
        private System.Windows.Forms.Panel PTViewPanel;
        private System.Windows.Forms.Label DirbaseLbl;
        private System.Windows.Forms.Label PtTextLbl;
        private System.Windows.Forms.ListBox PTListBox;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.ListBox PDListBox;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.ListBox PDPTListBox;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.ListBox PML4ListBox;
        private System.Windows.Forms.Timer UpdateContentTmr;
        private System.Windows.Forms.Label PTeInfoLbl;
        private System.Windows.Forms.Label PDeInfoLbl;
        private System.Windows.Forms.Label PDPTeLblInfo;
        private System.Windows.Forms.Label PML4eInfoLbl;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.RadioButton HighlightModeNx;
        private System.Windows.Forms.RadioButton HighlightModeSupervisor;
        private System.Windows.Forms.RadioButton HighlightModeNone;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.Label VirtualAddressInfoLbl;
        private System.Windows.Forms.TextBox VirtualAddressOutput;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.TextBox VirtualAddressInput;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Label VirtualAddressInfoLblInput;
        private System.Windows.Forms.Button TranslateBtn;
        private System.Windows.Forms.Button DumpPageBtn;
        private System.Windows.Forms.CheckBox PML4AutoEntryHighlight;
    }
}


```

`src/PTView/PTViewClient/MainForm.cs`:

```cs
using PTViewClient.PTView;
using PTViewClient.PTView.Driver;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace PTViewClient
{
    public partial class MainForm : Form
    {
        private Process SelectedProcess;
        private ulong SelectedProcessDirbase;

        private PML4E[] PML4Es;
        private PDPTE[] PDPTEs;
        private PDE[] PDEs;
        private PTE[] PTEs;

        private DriverInterface Driver;

        public MainForm()
        {
            InitializeComponent();

            Driver = new DriverInterface();
            
            if (!Driver.Initialize("PTView"))
            {

                MessageBox.Show("Driver could not be initialized, make sure it's loaded properly.");
                Environment.Exit(0);
            }

            this.FormClosing += (o, ev) => Driver.Close();
        }

        private void ProcessesComboBox_DropDown(object sender, EventArgs e)
        {
            var processes = Process.GetProcesses();
            ProcessesComboBox.Items.AddRange(processes.Select(x => $"{x.ProcessName} | {x.Id}").ToArray());
        }

        private void ProcessesComboBox_SelectedValueChanged(object sender, EventArgs e)
        {
            var selectedItem = ProcessesComboBox.SelectedItem.ToString();
            PTViewPanel.Visible = true;
            var procId = uint.Parse(selectedItem.Substring(selectedItem.IndexOf(" | ") + 3));
            try
            {
                SelectedProcess = Process.GetProcessById((int)procId);
                SelectedProcessDirbase = Driver.GetProcessDirbase(procId);
                DirbaseLbl.Text = $"Dirbase (cr3): 0x{SelectedProcessDirbase:X8}";
                
            }
            catch(Exception ex)
            {
                MessageBox.Show("Couldn't get process -> " + ex.Message);
            }

            DumpPageTables();
            UpdateContentTmr.Start();
        }

        private void DumpPageTables()
        {
            PML4Es = Driver.DumpPageTables(SelectedProcessDirbase).Cast<PML4E>().ToArray();
            PopulateListView(PML4Es, PML4ListBox);

            if(PML4ListBox.SelectedItems.Count > 0)
            {
                var pml4Index = PML4ListBox.SelectedIndex;
                var pml4e = PML4Es[pml4Index];

                if (pml4e.PFN != 0x0)
                {
                    PDPTEs = Driver.DumpPageTables(pml4e.PFN).Cast<PDPTE>().ToArray();
                    PopulateListView(PDPTEs, PDPTListBox);
                }
                else
                    PDPTListBox.Items.Clear();
            }
            else PDPTListBox.Items.Clear();

            if (PDPTListBox.SelectedItems.Count > 0)
            {
                var pdptIndex = PDPTListBox.SelectedIndex;
                var pdpte = PDPTEs[pdptIndex];

                if (pdpte.PFN != 0x0)
                {
                    PDEs = Driver.DumpPageTables(pdpte.PFN).Cast<PDE>().ToArray();
                    PopulateListView(PDEs, PDListBox);
                }
                else
                    PDListBox.Items.Clear();
            }
            else PDListBox.Items.Clear();

            if (PDListBox.SelectedItems.Count > 0)
            {
                var pdIndex = PDListBox.SelectedIndex;
                var pde = PDEs[pdIndex];

                if (pde.PFN != 0x0)
                {
                    if (pde.PageSize > 0)
                    {
                        //large page
                        PtTextLbl.Text = "(Large Page)";
                        PTListBox.Items.Clear();
                    }
                    else
                    {
                        PTEs = Driver.DumpPageTables(pde.PFN).Cast<PTE>().ToArray();
                        PopulateListView(PTEs, PTListBox);
                        PtTextLbl.Text = "PT";
                    }
                }
                else
                    PTListBox.Items.Clear();
            }
            else PTListBox.Items.Clear();
        }

        private void WriteEntryInfo()
        {
            if(PML4ListBox.SelectedItems.Count > 0)
            {
                var pml4e = PML4Es[PML4ListBox.SelectedIndex];
                PML4eInfoLbl.Text = BuildPteInfo((PTE)pml4e);
            }
            else PML4eInfoLbl.Text = "";

            if (PDPTListBox.SelectedItems.Count > 0)
            {
                var pdpte = PDPTEs[PDPTListBox.SelectedIndex];
                PDPTeLblInfo.Text = BuildPteInfo((PTE)pdpte);
            }
            else PDPTeLblInfo.Text = "";

            if (PDListBox.SelectedItems.Count > 0)
            {
                var pde = PDEs[PDListBox.SelectedIndex];
                PDeInfoLbl.Text = BuildPteInfo((PTE)pde);
            }
            else PDeInfoLbl.Text = "";


            if (PTListBox.SelectedItems.Count > 0)
            {
                var pte = PTEs[PTListBox.SelectedIndex];
                PTeInfoLbl.Text = BuildPteInfoEx(pte);
            }
            else PTeInfoLbl.Text = "";
        }

        private string BuildPteInfo(PTE pte)
        {
            return
                $"Present: {pte.Present}\n" +
                $"R/W: {pte.ReadWrite}\n" +
                $"UserSupervisor: {pte.UserSupervisor}\n" +
                $"PageWriteThrough: {pte.PageWriteThrough}\n" +
                $"PageCache: {pte.PageCache}\n" +
                $"Accessed: {pte.Accessed}\n" +
                $"PageSize: {pte.PageSize}\n" +
                $"PFN: 0x{pte.PFN:X8}\n" +
                $"NX: {pte.NX}";
        }

        private string BuildPteInfoEx(PTE pte)
        {
            return
                $"Present: {pte.Present}\n" +
                $"R/W: {pte.ReadWrite}\n" +
                $"UserSupervisor: {pte.UserSupervisor}\n" +
                $"PageWriteThrough: {pte.PageWriteThrough}\n" +
                $"PageCache: {pte.PageCache}\n" +
                $"Accessed: {pte.Accessed}\n" +
                $"Dirty: {pte.Dirty}\n" +
                $"PageAccessType: {pte.PageAccessType}\n" +
                $"Global: {pte.Global}\n" +
                $"PFN: 0x{pte.PFN:X8}\n" +
                $"ProtectionKey: 0x{pte.ProtectionKey:X8}\n" +
                $"NX: {pte.NX}";
        }

        private void PopulateListView(object[] ptes, ListBox listView)
        {
            var isPml4ListEmpty = listView.Items.Count == 0;


            for (int i = 0; i < ptes.Length; i++)
            {
                var item = $"[ {i} ] ➔ PA: 0x{(((PTE)ptes[i]).PFN) << 12:X8}";
                if (isPml4ListEmpty)
                    listView.Items.Add(item);
                else
                    listView.Items[i] = item;
            }
        }

        private void UpdateVirtualAddress()
        {
            string vaInfo = "";
            if (PML4ListBox.SelectedItems.Count > 0)
            {
                vaInfo += "PML4 Index: " + PML4ListBox.SelectedIndex + "\n";
            }

            if (PDPTListBox.SelectedItems.Count > 0)
            {
                vaInfo += "PDPT Index: " + PDPTListBox.SelectedIndex + "\n";
            }

            if (PDListBox.SelectedItems.Count > 0)
            {
                vaInfo += "PD Index: " + PDListBox.SelectedIndex + "\n";
            }

            if (PTListBox.SelectedItems.Count > 0)
            {
                vaInfo += "PT Index: " + PTListBox.SelectedIndex + "\n";
            }

            VirtualAddress virtualAddress = new VirtualAddress(0x0);
            virtualAddress.PML4Index = (ulong)(PML4ListBox.SelectedIndex == -1 ? 0 : PML4ListBox.SelectedIndex);
            virtualAddress.PDPTIndex = (ulong)(PDPTListBox.SelectedIndex == -1 ? 0 : PDPTListBox.SelectedIndex);
            virtualAddress.PDIndex = (ulong)(PDListBox.SelectedIndex == -1 ? 0 : PDListBox.SelectedIndex);
            virtualAddress.PTIndex = (ulong)(PTListBox.SelectedIndex == -1 ? 0 : PTListBox.SelectedIndex);

            //make sure the address is canonical
            if (virtualAddress.PML4Index > 255) virtualAddress.Reserved = 0xFFFF;

            VirtualAddressInfoLbl.Text = vaInfo;
            VirtualAddressOutput.Text = $"0x{virtualAddress.Value:X8}";
        }

        private void UpdateContentTmr_Tick(object sender, EventArgs e)
        {
            DumpPageTables();
            WriteEntryInfo();
            UpdateVirtualAddress();
        }

        private SolidBrush LightBlue = new SolidBrush(Color.LightBlue);
        private SolidBrush LightGreen = new SolidBrush(Color.LightGreen);
        private SolidBrush Lime = new SolidBrush(Color.Lime);

        private void PML4ListBox_DrawItem(object sender, DrawItemEventArgs e) => DrawListBoxItem(PML4ListBox, e, PML4Es);
        private void PDPTListBox_DrawItem(object sender, DrawItemEventArgs e) => DrawListBoxItem(PDPTListBox, e, PDPTEs);
        private void PDListBox_DrawItem(object sender, DrawItemEventArgs e) => DrawListBoxItem(PDListBox, e, PDEs);
        private void PTListBox_DrawItem(object sender, DrawItemEventArgs e) => DrawListBoxItem(PTListBox, e, PTEs);

        private void DrawListBoxItem(ListBox listBox, DrawItemEventArgs e, object[] ptes)
        {
            if (e.Index > -1)
            {
                bool isNxHighlightMode = HighlightModeNx.Checked;
                var pml4e = (PML4E)ptes[e.Index];

                SolidBrush sb = null;

                if (pml4e.Present > 0 && pml4e.PFN != 0x0 && !HighlightModeNone.Checked)
                {
                    if (isNxHighlightMode && pml4e.NX == 0)
                    {
                        sb = LightGreen;
                    }
                    else if (!isNxHighlightMode)
                    {
                        if (pml4e.UserSupervisor > 0)
                            sb = LightGreen;
                        else
                            sb = LightBlue;
                    }
                }

                if (pml4e.PFN == SelectedProcessDirbase && PML4AutoEntryHighlight.Checked)
                    sb = Lime;

                if(sb != null)
                    e.Graphics.FillRectangle(sb, e.Bounds);
                else
                    e.DrawBackground();

                using (Brush textBrush = new SolidBrush(e.ForeColor))
                {
                    e.Graphics.DrawString(listBox.Items[e.Index].ToString(), e.Font, textBrush, e.Bounds.Location);
                }
            }
        }

        private void HighlightModeNx_CheckedChanged(object sender, EventArgs e)
        {
            PML4ListBox.Refresh();
            PDPTListBox.Refresh();
            PDListBox.Refresh();
            PTListBox.Refresh();
        }

        private void HighlightModeNone_CheckedChanged(object sender, EventArgs e)
        {
            PML4ListBox.Refresh();
            PDPTListBox.Refresh();
            PDListBox.Refresh();
            PTListBox.Refresh();
        }

        private void VirtualAddressInput_TextChanged(object sender, EventArgs e)
        {
            if(ulong.TryParse(VirtualAddressInput.Text.Replace("0x", ""), NumberStyles.HexNumber, CultureInfo.CurrentCulture, out ulong address))
            {
                VirtualAddress va = new VirtualAddress(address);
                VirtualAddressInfoLblInput.Text =
                    $"PML4 Index: {va.PML4Index}\n" +
                    $"PDPT Index: {va.PDPTIndex}\n" +
                    $"PD Index: {va.PDIndex}\n" +
                    $"PT Index: {va.PTIndex}\n";
            }
            else
            {
                VirtualAddressInfoLblInput.Text = "";
            }
        }

        private void TranslateBtn_Click(object sender, EventArgs e)
        {
            if (ulong.TryParse(VirtualAddressInput.Text.Replace("0x", ""), NumberStyles.HexNumber, CultureInfo.CurrentCulture, out ulong address))
            {
                VirtualAddress va = new VirtualAddress(address);

                if (PML4ListBox.Items.Count == 512) PML4ListBox.SelectedIndex = (int)va.PML4Index;
                DumpPageTables();
                if (PDPTListBox.Items.Count == 512) PDPTListBox.SelectedIndex = (int)va.PDPTIndex;
                DumpPageTables();
                if (PDListBox.Items.Count == 512) PDListBox.SelectedIndex = (int)va.PDIndex;
                DumpPageTables();
                if (PTListBox.Items.Count == 512) PTListBox.SelectedIndex = (int)va.PTIndex;
            }
            else
            {
                MessageBox.Show("Invalid address!");
            }
        }

        private void DumpPageBtn_Click(object sender, EventArgs e)
        {
            if (PTListBox.SelectedItems.Count > 0)
            {
                DumpIndexFromPT(PTEs, PTListBox.SelectedIndex, false);
            }
            else if (PDListBox.SelectedItems.Count > 0 && PDEs[PDListBox.SelectedIndex].PageSize > 0) //check if selected PDE is a large page
            {
                DumpIndexFromPT(PDEs, PDListBox.SelectedIndex, true);
            }
            else
                MessageBox.Show("No Page Table Entry selected!");
        }

        private void DumpIndexFromPT(object[] pt, int index, bool largePage)
        {
            var pte = (PTE)pt[index];
            if (pte.Present > 0 && pte.PFN != 0x0)
            {
                var pageDump = Driver.DumpPage(pte.PFN, largePage);
                HexDumpView hdv = new HexDumpView(pageDump);
                hdv.Show();
            }
            else
            {
                if (MessageBox.Show("PTE is invalid, do you want to dump it anyways?", "", MessageBoxButtons.YesNo) == DialogResult.Yes)
                {
                    var pageDump = Driver.DumpPage(pte.PFN, largePage);
                    HexDumpView hdv = new HexDumpView(pageDump);
                    hdv.Show();
                }
            }
        }
    }
}

```

`src/PTView/PTViewClient/MainForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="UpdateContentTmr.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`src/PTView/PTViewClient/PTView/Driver/DriverInterface.cs`:

```cs
using System;
using System.IO;
using static PTViewClient.PTView.Native;
using static PTViewClient.PTView.Driver.Internal.Constants;
using System.Linq;
using System.Windows.Forms;
using System.Runtime.InteropServices;

namespace PTViewClient.PTView.Driver
{
    public unsafe class DriverInterface
    {
        public IntPtr DriverHandle;

        public bool Initialize(string symlink)
        {
            DriverHandle = CreateFile($"\\\\.\\{symlink}", 0x80000000,
                                                   FileShare.Read, IntPtr.Zero, FileMode.Open,
                                                               FileOptions.None, IntPtr.Zero);

            if (DriverHandle == new IntPtr(-1)) return false;
            return true;
        }

        public ulong GetProcessDirbase(uint processId)
        {
            ulong dirbase = 0;
            ulong procId = (ulong)processId;

            DeviceIoControl(DriverHandle, IOCTL_DIRBASE, 
                            &procId, sizeof(ulong),
                            &dirbase, sizeof(ulong));

            return dirbase;
        }

        public PTE[] DumpPageTables(ulong pfn)
        {
            ulong[] ptBuffer = new ulong[512];

            fixed (void* buf = ptBuffer)
                DeviceIoControl(DriverHandle, IOCTL_DUMP_PT,
                                &pfn, sizeof(ulong),
                                buf, (uint)ptBuffer.Length * sizeof(ulong));

            return ptBuffer.Select(x => (PTE)x).ToArray();
        }

        public byte[] DumpPage(ulong pfn, bool largePage)
        {
            uint bufferLength = largePage ? 0x1000 * 512u : 0x1000;
            byte[] pageBuffer = new byte[bufferLength];

            fixed(void* buf = pageBuffer)
            DeviceIoControl(DriverHandle, largePage ? IOCTL_DUMP_LARGE_PAGE : IOCTL_DUMP_PAGE,
                            &pfn, sizeof(ulong),
                            buf, bufferLength);

            return pageBuffer;
        }

        public void Close()
        {
            CloseHandle(DriverHandle);
        }
    }
}

```

`src/PTView/PTViewClient/PTView/Driver/Internal/Constants.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PTViewClient.PTView.Driver.Internal
{
    public static class Constants
    {
        public static readonly uint IOCTL_DIRBASE = CTL_CODE(0x8000, 0x800, METHOD_NEITHER, 0);
        public static readonly uint IOCTL_DUMP_PT = CTL_CODE(0x8000, 0x801, METHOD_NEITHER, 0);
        public static readonly uint IOCTL_DUMP_PAGE = CTL_CODE(0x8000, 0x802, METHOD_NEITHER, 0);
        public static readonly uint IOCTL_DUMP_LARGE_PAGE = CTL_CODE(0x8000, 0x803, METHOD_NEITHER, 0);

        private const uint METHOD_NEITHER = 3;

        private static uint CTL_CODE(uint deviceType, uint function, uint method, uint access)
        {
            return ((deviceType) << 16) | ((access) << 14) | ((function) << 2) | (method);
        }
    }
}

```

`src/PTView/PTViewClient/PTView/Misc.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PTViewClient.PTView
{
    public static class Misc
    {
        public static ulong SetBits(ulong word, ulong value, int pos, int size)
        {
            ulong mask = ((((ulong)1) << size) - 1) << pos;
            word &= ~mask;
            word |= (value << pos) & mask;
            return word;
        }

        public static ulong ReadBits(ulong word, int pos, int size)
        {
            ulong mask = ((((ulong)1) << size) - 1) << pos;
            return (word & mask) >> pos;
        }
    }
}

```

`src/PTView/PTViewClient/PTView/Native.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace PTViewClient.PTView
{
    public static unsafe class Native
    {
        [DllImport("kernel32.dll")]
        public static extern void CloseHandle(IntPtr hdl);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr CreateFile(string filename, uint fileAccess, FileShare sharing, IntPtr SecurityAttributes, FileMode mode, FileOptions options, IntPtr template);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool DeviceIoControl(IntPtr hDevice, uint dwIoControlCode, void* lpInBuffer, uint lpInBufferSize, void* lpOutBuffer, uint nOutBufferSize, uint lpBytesReturned = 0, long overlapped = 0);

    }
}

```

`src/PTView/PTViewClient/PTView/Structures.cs`:

```cs
using static PTViewClient.PTView.Misc;

namespace PTViewClient.PTView
{
    public class PML4E
    {
        public ulong Value;

        public PML4E(ulong value)
        {
            Value = value;
        }

        public ulong Present { get => ReadBits(Value, 0, 1); }
        public ulong ReadWrite { get => ReadBits(Value, 1, 1); }
        public ulong UserSupervisor { get => ReadBits(Value, 2, 1); }
        public ulong PageWriteThrough { get => ReadBits(Value, 3, 1); }
        public ulong PageCache { get => ReadBits(Value, 4, 1); }
        public ulong Accessed { get => ReadBits(Value, 5, 1); }
        public ulong PageSize { get => ReadBits(Value, 7, 1); } //this must be 0 for pml4e's (Intel Manual page 2940)
        public ulong PFN { get => ReadBits(Value, 12, 36); }
        public ulong NX { get => ReadBits(Value, 63, 1); }
    }

    public class PDPTE : PML4E
    {
        public PDPTE(ulong value) : base(value) { }
    }

    public class PDE : PDPTE
    {
        public PDE(ulong value) : base(value) { }
    }

    public class PTE : PDE
    {
        public PTE(ulong value) : base(value) { }

        public static implicit operator PTE(ulong value)
        {
            return new PTE(value);
        }

        public ulong Dirty { get => ReadBits(Value, 6, 1); }
        public ulong PageAccessType { get => ReadBits(Value, 7, 1); }
        public ulong Global { get => ReadBits(Value, 8, 1); }
        public ulong ProtectionKey { get => ReadBits(Value, 59, 4); }
    }

    public class VirtualAddress
    {
        public static implicit operator VirtualAddress(ulong value)
        {
            return new VirtualAddress(value);
        }

        public ulong Value;

        public VirtualAddress(ulong value)
        {
            Value = value;
        }

        public ulong Offset 
        { 
            get => ReadBits(Value, 0, 12);
            set => Value = SetBits(Value, value, 0, 12);
        }

        public ulong PTIndex 
        { 
            get => ReadBits(Value, 12, 9);
            set => Value = SetBits(Value, value, 12, 9);
        }

        public ulong PDIndex 
        { 
            get => ReadBits(Value, 21, 9);
            set => Value = SetBits(Value, value, 21, 9);
        }

        public ulong PDPTIndex 
        { 
            get => ReadBits(Value, 30, 9);
            set => Value = SetBits(Value, value, 30, 9);
        }

        public ulong PML4Index 
        {
            get => ReadBits(Value, 39, 9);
            set => Value = SetBits(Value, value, 39, 9);
        }

        public ulong Reserved
        {
            get => ReadBits(Value, 48, 16);
            set => Value = SetBits(Value, value, 48, 16);
        }

    }
}

```

`src/PTView/PTViewClient/PTViewClient.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{A3A2C7A9-7CAD-46A5-BAA4-2C19F342D391}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>PTViewClient</RootNamespace>
    <AssemblyName>PTViewClient</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Design" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="HexDumpView.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="HexDumpView.Designer.cs">
      <DependentUpon>HexDumpView.cs</DependentUpon>
    </Compile>
    <Compile Include="MainForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="PTView\Driver\DriverInterface.cs" />
    <Compile Include="PTView\Driver\Internal\Constants.cs" />
    <Compile Include="PTView\Misc.cs" />
    <Compile Include="PTView\Native.cs" />
    <Compile Include="PTView\Structures.cs" />
    <EmbeddedResource Include="HexDumpView.resx">
      <DependentUpon>HexDumpView.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="app.manifest" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`src/PTView/PTViewClient/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace PTViewClient
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}

```

`src/PTView/PTViewClient/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PTViewClient")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("PTViewClient")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a3a2c7a9-7cad-46a5-baa4-2c19f342d391")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`src/PTView/PTViewClient/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


namespace PTViewClient.Properties
{
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("PTViewClient.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}

```

`src/PTView/PTViewClient/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`src/PTView/PTViewClient/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


namespace PTViewClient.Properties
{
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}

```

`src/PTView/PTViewClient/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```

`src/PTView/PTViewClient/app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC Manifest Options
             If you want to change the Windows User Account Control level replace the 
             requestedExecutionLevel node with one of the following.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
            Remove this element if your application requires this virtualization for backwards
            compatibility.
        -->
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->

      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->

      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->

      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->

      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->

    </application>
  </compatibility>

  <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. 
       
       Makes the application long-path aware. See https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation -->
  <!--
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
  -->

  <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->

</assembly>

```

`src/PTView/PTViewDriver/PTViewDriver.inf`:

```inf
;
; PTViewDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=PTViewDriver.cat
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="PTViewDriver Source Disk"

```

`src/PTView/PTViewDriver/PTViewDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{38E90BC3-890C-4507-AC9A-BAA07AAD96C4}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PTViewDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="com.h" />
    <ClInclude Include="ptutil.h" />
    <ClInclude Include="undocumented.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="com.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="ptutil.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`src/PTView/PTViewDriver/PTViewDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="undocumented.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="com.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ptutil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="com.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ptutil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/PTView/PTViewDriver/com.cpp`:

```cpp
#include "com.h"

PDRIVER_OBJECT DriverObject;
PDEVICE_OBJECT DeviceObject;

UNICODE_STRING SymlinkName = RTL_CONSTANT_STRING(L"\\DosDevices\\PTView");
UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L"\\Device\\PTView");

NTSTATUS CompleteRequest(PDEVICE_OBJECT deviceObject, PIRP irp)
{
	(deviceObject);
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}


void Unload(PDRIVER_OBJECT driverObject)
{
	UNREFERENCED_PARAMETER(driverObject);
	IoDeleteSymbolicLink(&SymlinkName);
	IoDeleteDevice(DeviceObject);
}

NTSTATUS SetupDevice(PDRIVER_OBJECT driverObject, PDRIVER_DISPATCH ioHandler)
{
	DriverObject = driverObject;

	auto status = IoCreateDevice(driverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject);
	DbgPrintEx(0, 0, "IoCreateDevice -> %lx\n", status);
	ReturnOnFail(status);

	status = IoCreateSymbolicLink(&SymlinkName, &DeviceName);
	DbgPrintEx(0, 0, "IoCreateSymbolicLink -> %lx\n", status);
	ReturnOnFail(status);

	DriverObject->MajorFunction[IRP_MJ_CREATE] = CompleteRequest;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = CompleteRequest;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ioHandler;
	DriverObject->DriverUnload = Unload;

	DeviceObject->Flags |= DO_DIRECT_IO;
	DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

	return status;
}
```

`src/PTView/PTViewDriver/com.h`:

```h
#pragma once
#include "util.h"
#include "undocumented.h"

#define IOCTL_DIRBASE (ULONG)CTL_CODE(0x8000, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DUMP_PT (ULONG)CTL_CODE(0x8000, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DUMP_PAGE (ULONG)CTL_CODE(0x8000, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DUMP_LARGE_PAGE (ULONG)CTL_CODE(0x8000, 0x803, METHOD_NEITHER, FILE_ANY_ACCESS)

NTSTATUS SetupDevice(PDRIVER_OBJECT driverObject, PDRIVER_DISPATCH ioHandler);

```

`src/PTView/PTViewDriver/main.cpp`:

```cpp
#include "util.h"
#include "undocumented.h"
#include "com.h"
#include "ptutil.h"

NTSTATUS DriverDispatch(PDEVICE_OBJECT device, PIRP irp)
{
	UNREFERENCED_PARAMETER(device);

	PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);

	auto inputBuffer = irpStack->Parameters.DeviceIoControl.Type3InputBuffer;
	NTSTATUS status = STATUS_SUCCESS;

	switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_DIRBASE:
			if (inputBuffer)
			{
				HANDLE pid = *(HANDLE*)inputBuffer;
				PEPROCESS proc;
				status = PsLookupProcessByProcessId(pid, &proc);
				if (NT_SUCCESS(status))
				{
					ULONG64 dirbase = PsGetDirbase(proc);
					ObDereferenceObject(proc);
					*(ULONG64*)irp->UserBuffer = dirbase;
				}
			}
			break;
		
		case IOCTL_DUMP_PT:
			if (inputBuffer)
			{
				ULONG64 pfn = *(ULONG64*)inputBuffer;
				status = DumpPageTable(pfn, irp->UserBuffer);
			}
			break;

		case IOCTL_DUMP_PAGE:
			if (inputBuffer)
			{
				ULONG64 pfn = *(ULONG64*)inputBuffer;
				status = DumpPage(pfn, false, irp->UserBuffer);
			}
			break;

		case IOCTL_DUMP_LARGE_PAGE:
			if (inputBuffer)
			{
				ULONG64 pfn = *(ULONG64*)inputBuffer;
				status = DumpPage(pfn, true, irp->UserBuffer);
			}
			break;
	}

	irp->IoStatus.Information = 0;
	irp->IoStatus.Status = status;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return status;
}

NTSTATUS ManualDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);
	return SetupDevice(DriverObject, DriverDispatch);
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	if (!DriverObject || DriverObject->DriverInit != DriverEntry)
	{
		// Create driver if manually mapped
		UNICODE_STRING driverName = RTL_CONSTANT_STRING(L"\\Driver\\PTView");
		auto status = IoCreateDriver(&driverName, ManualDriverEntry);
		DbgPrintEx(0, 0, "IoCreateDriver -> %lx", status);
		return status;
	}

	return SetupDevice(DriverObject, DriverDispatch);
}
```

`src/PTView/PTViewDriver/ptutil.cpp`:

```cpp
#include "ptutil.h"

ULONG64 PsGetDirbase(PEPROCESS proc)
{
	return ((*(_cr3*)((BYTE*)proc + 0x28)).dirbase);
}

NTSTATUS MmReadPhysical(PVOID targetAddress, ULONG64 sourceAddress, size_t size, size_t* bytesRead)
{
	PHYSICAL_ADDRESS address = { 0 };
	MM_COPY_ADDRESS copyInfo = { 0 };
	address.QuadPart = (LONGLONG)sourceAddress;
	copyInfo.PhysicalAddress = address;
	return MmCopyMemory(targetAddress, copyInfo, size, MM_COPY_MEMORY_PHYSICAL, bytesRead);
}

NTSTATUS DumpPageTable(ULONG64 pfn, PVOID outputBuffer)
{
	ULONG64 sourceAddress = pfn << 12;

	size_t dummy;
	// 512 possible PTE's, because 9 bits in the virtual address are used to index them
	// 2^9 = 512
	return MmReadPhysical(outputBuffer, sourceAddress, sizeof(pte) * 512, &dummy);
}

NTSTATUS DumpPage(ULONG64 pfn, bool largePage, PVOID outputBuffer)
{
	ULONG64 sourceAddress = pfn << 12;
	size_t dummy;

	size_t copySize = largePage ? (PAGE_SIZE * 512) : PAGE_SIZE;

	//MmCopyMemory raises the IRQL to dispatch level, paging becomes unavailable.
	//In this case I use a NonPagedPool as intermediate buffer
	//The same should be done in DumpPageTable, but it's fine there I guess, since its only gonna copy a single page, 
	//which is very likely to be mapped
	PVOID buffer = ExAllocatePool(NonPagedPool, copySize);

	if (buffer)
	{
		auto status = MmReadPhysical(buffer, sourceAddress, copySize, &dummy);
		if (NT_SUCCESS(status))
			memcpy(outputBuffer, buffer, copySize);
		
		ExFreePool(buffer);

		return status;
	}
	else return STATUS_UNSUCCESSFUL;
	
}
```

`src/PTView/PTViewDriver/ptutil.h`:

```h
#pragma once
#include "util.h"

ULONG64 PsGetDirbase(PEPROCESS proc);
NTSTATUS DumpPageTable(ULONG64 pfn, PVOID outputBuffer);
NTSTATUS DumpPage(ULONG64 pfn, bool largePage, PVOID outputBuffer);

typedef union _cr3
{
    ULONG64 flags;
    struct
    {
        ULONG64 reserved1 : 3;
        ULONG64 page_level_write_through : 1;
        ULONG64 page_level_cache_disable : 1;
        ULONG64 reserved2 : 7;
        ULONG64 dirbase : 36;
        ULONG64 reserved3 : 16;
    };
} cr3;

typedef union _pml4e
{
    ULONG64 value;
    struct
    {
        ULONG64 present : 1; //0
        ULONG64 ReadWrite : 1; // 1
        ULONG64 user_supervisor : 1; // 2
        ULONG64 PageWriteThrough : 1; // 3
        ULONG64 page_cache : 1; // 4
        ULONG64 accessed : 1; // 5
        ULONG64 Ignored1 : 1; // 6
        ULONG64 page_size : 1; // 7
        ULONG64 Ignored2 : 4; // 8
        ULONG64 pfn : 36; // 12
        ULONG64 Reserved : 4;
        ULONG64 Ignored3 : 11;
        ULONG64 nx : 1;
    };
} pml4e, * ppml4e;

typedef union _pdpte
{
    ULONG64 value;
    struct
    {
        ULONG64 present : 1;
        ULONG64 ReadWrite : 1;
        ULONG64 user_supervisor : 1;
        ULONG64 PageWriteThrough : 1;
        ULONG64 page_cache : 1;
        ULONG64 accessed : 1;
        ULONG64 Ignored1 : 1;
        ULONG64 page_size : 1;
        ULONG64 Ignored2 : 4;
        ULONG64 pfn : 36;
        ULONG64 Reserved : 4;
        ULONG64 Ignored3 : 11;
        ULONG64 nx : 1;
    };
} pdpte, * ppdpte;

typedef union _pde
{
    ULONG64 value;
    struct
    {
        ULONG64 present : 1;
        ULONG64 ReadWrite : 1;
        ULONG64 user_supervisor : 1;
        ULONG64 PageWriteThrough : 1;
        ULONG64 page_cache : 1;
        ULONG64 accessed : 1;
        ULONG64 Ignored1 : 1;
        ULONG64 page_size : 1;
        ULONG64 Ignored2 : 4;
        ULONG64 pfn : 36;
        ULONG64 Reserved : 4;
        ULONG64 Ignored3 : 11;
        ULONG64 nx : 1;
    };
} pde, * ppde;

typedef union _pte
{
    ULONG64 value;
    struct
    {
        ULONG64 present : 1;
        ULONG64 ReadWrite : 1;
        ULONG64 user_supervisor : 1;
        ULONG64 PageWriteThrough : 1;
        ULONG64 page_cache : 1;
        ULONG64 accessed : 1;
        ULONG64 Dirty : 1;
        ULONG64 PageAccessType : 1;
        ULONG64 Global : 1;
        ULONG64 Ignored2 : 3;
        ULONG64 pfn : 36;
        ULONG64 Reserved : 4;
        ULONG64 Ignored3 : 7;
        ULONG64 ProtectionKey : 4;
        ULONG64 nx : 1;
    };
} pte, * ppte;

typedef union _virt_addr_t
{
    PVOID value;
    struct
    {
        ULONG64 offset : 12;
        ULONG64 pt_index : 9;
        ULONG64 pd_index : 9;
        ULONG64 pdpt_index : 9;
        ULONG64 pml4_index : 9;
        ULONG64 reserved : 16;
    };
} virtual_address, * pvirtual_address;

```

`src/PTView/PTViewDriver/undocumented.h`:

```h
#pragma once
#include "util.h"

extern "C" NTKERNELAPI
NTSTATUS IoCreateDriver(
	IN PUNICODE_STRING DriverName, OPTIONAL
	IN PDRIVER_INITIALIZE InitializationFunction
);

```

`src/PTView/PTViewDriver/util.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <stdlib.h>
#include <wdm.h>
#include <ntstrsafe.h>
#include <windef.h>

#define ReturnOnFail(status) if (!NT_SUCCESS(status)) return status;
```