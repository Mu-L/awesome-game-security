Project Path: arc_DerekSelander_dynadump_9ftbaq30

Source Tree:

```txt
arc_DerekSelander_dynadump_9ftbaq30
├── Dynamic Dump
│   ├── AppDelegate.m
│   ├── Assets.xcassets
│   │   ├── AccentColor.colorset
│   │   │   └── Contents.json
│   │   ├── AppIcon.appiconset
│   │   │   └── Contents.json
│   │   └── Contents.json
│   ├── Base.lproj
│   │   ├── LaunchScreen.storyboard
│   │   └── Main.storyboard
│   ├── DetailViewController.h
│   ├── DetailViewController.m
│   ├── Info.plist
│   ├── SceneDelegate.m
│   ├── ViewController.h
│   ├── ViewController.m
│   └── main.m
├── README.md
├── dynadump
│   ├── codesigning.h
│   ├── codesigning.m
│   ├── dyld.h
│   ├── dyld.m
│   ├── exception_handler.h
│   ├── exception_handler.m
│   ├── main.m
│   ├── misc.c
│   ├── misc.h
│   ├── objc.h
│   └── objc.m
└── dynadump.xcodeproj
    ├── project.pbxproj
    ├── project.xcworkspace
    │   ├── contents.xcworkspacedata
    │   └── xcshareddata
    │       └── IDEWorkspaceChecks.plist
    └── xcshareddata
        └── xcschemes
            ├── Dynamic Dump.xcscheme
            ├── dynadump.xcscheme
            └── dynadump_catalyst.xcscheme

```

`Dynamic Dump/AppDelegate.m`:

```m
//
//  AppDelegate.m
//  dynadump_ios
//
//  Created by Derek Selander on 6/10/24.
//

@import UIKit;
@interface AppDelegate : UIResponder <UIApplicationDelegate>
@end



@interface AppDelegate ()

@end

@implementation AppDelegate


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    return YES;
}


#pragma mark - UISceneSession lifecycle


- (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options {
    // Called when a new scene session is being created.
    // Use this method to select a configuration to create the new scene with.
    return [[UISceneConfiguration alloc] initWithName:@"Default Configuration" sessionRole:connectingSceneSession.role];
}


- (void)application:(UIApplication *)application didDiscardSceneSessions:(NSSet<UISceneSession *> *)sceneSessions {
    // Called when the user discards a scene session.
    // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
    // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
}


@end

```

`Dynamic Dump/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Dynamic Dump/Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Dynamic Dump/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Dynamic Dump/Base.lproj/LaunchScreen.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>

```

`Dynamic Dump/Base.lproj/Main.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="22154" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="BYZ-38-t0r">
    <device id="retina6_12" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22130"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="System colors in document resources" minToolsVersion="11.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="ViewController" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <tableView clipsSubviews="YES" contentMode="scaleToFill" alwaysBounceVertical="YES" dataMode="prototypes" style="plain" separatorStyle="default" rowHeight="-1" estimatedRowHeight="-1" sectionHeaderHeight="-1" estimatedSectionHeaderHeight="-1" sectionFooterHeight="-1" estimatedSectionFooterHeight="-1" translatesAutoresizingMaskIntoConstraints="NO" id="Icc-t0-N9f">
                                <rect key="frame" x="0.0" y="59" width="393" height="759"/>
                                <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                                <prototypes>
                                    <tableViewCell clipsSubviews="YES" contentMode="scaleToFill" preservesSuperviewLayoutMargins="YES" selectionStyle="default" indentationWidth="10" reuseIdentifier="cell" id="vEw-kD-Vmi">
                                        <rect key="frame" x="0.0" y="50" width="393" height="43.666667938232422"/>
                                        <autoresizingMask key="autoresizingMask"/>
                                        <tableViewCellContentView key="contentView" opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" preservesSuperviewLayoutMargins="YES" insetsLayoutMarginsFromSafeArea="NO" tableViewCell="vEw-kD-Vmi" id="WR8-vH-Gjx">
                                            <rect key="frame" x="0.0" y="0.0" width="393" height="43.666667938232422"/>
                                            <autoresizingMask key="autoresizingMask"/>
                                        </tableViewCellContentView>
                                        <connections>
                                            <segue destination="zAA-r3-hsT" kind="show" id="cYN-ZN-CVQ"/>
                                        </connections>
                                    </tableViewCell>
                                </prototypes>
                            </tableView>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                        <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                        <constraints>
                            <constraint firstItem="6Tk-OE-BBY" firstAttribute="trailing" secondItem="Icc-t0-N9f" secondAttribute="trailing" id="2E3-jg-ced"/>
                            <constraint firstItem="Icc-t0-N9f" firstAttribute="top" secondItem="6Tk-OE-BBY" secondAttribute="top" id="4IL-tF-7mf"/>
                            <constraint firstItem="Icc-t0-N9f" firstAttribute="leading" secondItem="6Tk-OE-BBY" secondAttribute="leading" id="lVT-ED-51e"/>
                            <constraint firstItem="6Tk-OE-BBY" firstAttribute="bottom" secondItem="Icc-t0-N9f" secondAttribute="bottom" id="szm-sm-emr"/>
                        </constraints>
                    </view>
                    <connections>
                        <outlet property="tableView" destination="Icc-t0-N9f" id="Ar1-6d-qPc"/>
                    </connections>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="58.778625954198468" y="3.5211267605633805"/>
        </scene>
        <!--Detail View Controller-->
        <scene sceneID="x5Q-6x-hAq">
            <objects>
                <viewController id="zAA-r3-hsT" customClass="DetailViewController" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="G5N-qS-6F1">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="842"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <textView clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" textAlignment="natural" translatesAutoresizingMaskIntoConstraints="NO" id="opg-QP-x5h">
                                <rect key="frame" x="0.0" y="42" width="393" height="800"/>
                                <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                                <string key="text">Lorem ipsum dolor sit er elit lamet, consectetaur cillium adipisicing pecu, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Nam liber te conscient to factor tum poen legum odioque civiuda.</string>
                                <color key="textColor" systemColor="labelColor"/>
                                <fontDescription key="fontDescription" type="system" pointSize="14"/>
                                <textInputTraits key="textInputTraits" autocapitalizationType="sentences"/>
                            </textView>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="lwb-8P-yLA"/>
                        <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                        <constraints>
                            <constraint firstItem="opg-QP-x5h" firstAttribute="topMargin" secondItem="lwb-8P-yLA" secondAttribute="top" constant="50" id="El4-ie-xBh"/>
                            <constraint firstItem="lwb-8P-yLA" firstAttribute="trailing" secondItem="opg-QP-x5h" secondAttribute="trailing" id="Oqw-eh-wRH"/>
                            <constraint firstItem="lwb-8P-yLA" firstAttribute="bottom" secondItem="opg-QP-x5h" secondAttribute="bottom" id="WnB-kY-8ue"/>
                            <constraint firstItem="opg-QP-x5h" firstAttribute="leading" secondItem="lwb-8P-yLA" secondAttribute="leading" id="Xit-0U-QkU"/>
                        </constraints>
                    </view>
                    <navigationItem key="navigationItem" id="GTR-gu-r53"/>
                    <connections>
                        <outlet property="textView" destination="opg-QP-x5h" id="Bq8-ZC-rJm"/>
                    </connections>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="Mz3-6b-jAt" userLabel="First Responder" customClass="UIResponder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="1565" y="8"/>
        </scene>
    </scenes>
    <resources>
        <systemColor name="labelColor">
            <color white="0.0" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
        </systemColor>
        <systemColor name="systemBackgroundColor">
            <color white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
        </systemColor>
    </resources>
</document>

```

`Dynamic Dump/DetailViewController.h`:

```h
//
//  DetailViewController.h
//  dynadump
//
//  Created by Derek Selander on 6/10/24.
//

@import UIKit;

@interface DetailViewController : UIViewController
@property (nonatomic, assign) uint32_t dsc_num;
@end


```

`Dynamic Dump/DetailViewController.m`:

```m
//
//  DetailViewController.m
//  Dynamic Dump
//
//  Created by Derek Selander on 6/10/24.
//

#include "DetailViewController.h"
@interface DetailViewController ()
@property (weak, nonatomic) IBOutlet UITextView *textView;

@end

@implementation DetailViewController


- (void)viewDidLoad {
    [super viewDidLoad];
    
    
}

@end

```

`Dynamic Dump/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>SceneDelegate</string>
					<key>UISceneStoryboardFile</key>
					<string>Main</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>

```

`Dynamic Dump/SceneDelegate.m`:

```m
//
//  SceneDelegate.m
//  dynadump_ios
//
//  Created by Derek Selander on 6/10/24.
//
@import UIKit;

@interface SceneDelegate : UIResponder <UIWindowSceneDelegate>

@property (strong, nonatomic) UIWindow * window;

@end



@interface SceneDelegate ()

@end

@implementation SceneDelegate


- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
    // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
    // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
    // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
}


- (void)sceneDidDisconnect:(UIScene *)scene {
    // Called as the scene is being released by the system.
    // This occurs shortly after the scene enters the background, or when its session is discarded.
    // Release any resources associated with this scene that can be re-created the next time the scene connects.
    // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
}


- (void)sceneDidBecomeActive:(UIScene *)scene {
    // Called when the scene has moved from an inactive state to an active state.
    // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
}


- (void)sceneWillResignActive:(UIScene *)scene {
    // Called when the scene will move from an active state to an inactive state.
    // This may occur due to temporary interruptions (ex. an incoming phone call).
}


- (void)sceneWillEnterForeground:(UIScene *)scene {
    // Called as the scene transitions from the background to the foreground.
    // Use this method to undo the changes made on entering the background.
}


- (void)sceneDidEnterBackground:(UIScene *)scene {
    // Called as the scene transitions from the foreground to the background.
    // Use this method to save data, release shared resources, and store enough scene-specific state information
    // to restore the scene back to its current state.
}


@end

```

`Dynamic Dump/ViewController.h`:

```h
//
//  ViewController.h
//  Dynamic Dump
//
//  Created by Derek Selander on 3/14/24.
//

#import <UIKit/UIKit.h>

@interface ViewController : UIViewController


@end


```

`Dynamic Dump/ViewController.m`:

```m
//
//  ViewController.m
//  dynadump_ios
//
//  Created by Derek Selander on 6/10/24.
//

#import "ViewController.h"
#import "DetailViewController.h"
#include "dynadump/dyld.h"
@interface ViewController () <UITableViewDelegate, UITableViewDataSource>
@property (weak, nonatomic) IBOutlet UITableView *tableView;


@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.tableView.delegate = self;
    self.tableView.dataSource = self;
}


- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return dsc_images_count();
}

// Row display. Implementers should *always* try to reuse cells by setting each cell's reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier:
// Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls)

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"];
    const char *path = dsc_image_as_num((uint32_t)indexPath.row);
    NSString *pathStr = [NSString stringWithCString:path ? path : "?" encoding:NSUTF8StringEncoding];
    cell.textLabel.text = pathStr;
    return cell;
}


- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    NSIndexPath* indexPath = [self.tableView indexPathForSelectedRow];
    DetailViewController* vc = (DetailViewController*)[segue destinationViewController];
//    auto application = self.filteredInstalledApplications[indexPath.row];
//    vc.application = application;
//    auto pidInfo = self.processDictionary[application.canonicalExecutablePath];
//    vc.pidInfo = pidInfo;
}


@end

```

`Dynamic Dump/main.m`:

```m
//
//  main.m
//  Dynamic Dump
//
//  Created by Derek Selander on 3/14/24.
//

#import <UIKit/UIKit.h>

int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass(NSClassFromString(@"AppDelegate"));
    }
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}

```

`README.md`:

```md
# dynadump

Yet another Objective-C class-dump CLI tool

## Why?

For fun. I got burnt out on the complexity of `dsdump` trying to grab all of Apple's dyld/objc4 opensource code and compiling it. This attempts to class-dump ObjC code via mostly public or unlikely to change private APIs

## Features
```
  dynadump (built: May 30 2024, 00:59:46) - yet another class-dump done via dlopen & exception catching

	Parameters:
	list                list all the dylibs in the dyld shared cache (dsc)
	list  $DYLIB        list all the objc classes in a dylib $DYLIB
	dump  $DYLIB        dump all the ObjC classes found in a dylib on disk
	dump  $DYLIB $CLASS dump a specific ObjC class found in dylib $DYLIB
	sig   $SIGSTR       prints the demangled objc signature
	sign  $DYLIB        attempts to sign a dylib in place
	list  $DYLIB $CLASS Same cmd as above (convenience for listing then dumping)

	Environment Variables:
	NOCOLOR - Forces no color, color will be on by default unless piped
	COLOR   - Forces color, regardless of stdout destination
	VERBOSE - Verbose output
	NOEXC   - Don't use an exception handler (on in x86_64)
	DEBUG   - Used internally to hunt down f ups
```


The following example looks for any images in the dsc with `Shaz`, which can display a numerical number to print for `list`ing or `dump`ing. You can dump every ObjC class in the module or just a specific class. Use the **`VERBOSE`** flag to provide more detail, like load addresses or offsets.
<img width="1402" alt="screenshot" src="https://github.com/DerekSelander/dynadump/assets/1037191/7d18a258-fb6f-4044-bc67-cafbad641d55">

If the color hurts the eyes, a `NOCOLOR` environment variable can calm it down.

<img width="1402" alt="screenshot2" src="https://github.com/DerekSelander/dynadump/assets/1037191/d58f2b51-b6a3-481f-8f44-575ccd36fae8">


### Neat/bad design choices

Since this loads an image through `dlopen`, one has to be careful to prevent the image constructors from doing something bad, like crashing the program (I am looking at you, `/S*/L*/PrivateFrameworks/SpringBoard.framework`). To get around this, exception handlers are created on all callouts to load addresses. So when an image loads, an exception (a breakpoint) is hit and the exception handler steps over the code. This will prevent all constructors from executing for good or for bad. If you see something not working try using the **`NOEXC=1`** to prevent exception handlers from being setup

The other shitty consequence of this design is that `dlopen` really is limited to dylibs and not standalone executables. In addition, a platform could be for iOS while being opened for Mac Catalyst. To deal with this, after `dlopen` fails for the first time, `dynadump` will copy the image of interest and patch the needed commands needed to be able to `dlopen`. This gets more fun when dealing with things like `LC_RPATH`.

## Caveats

Due to the different platforms and the architectures that can be run, you will need to use `arch -arm64` or `arch -arm64e` depending on the desired images to inspect. Apple will use arm64e on their stuff, while 3rd party code will be in arm64 (at the time of writing). You also need to be aware of any images that are Mac Catalyst builds as they're viewed as a different platform and will import different libraries when loaded. As a result, there's a Xcode scheme to build a Catalyst versino of `dynadump`


Here's an example of looking at `Amazon Prime` which appears to be ported from the iPad version.

<img width="1562" alt="Screenshot 2024-05-30 at 2 25 07 AM" src="https://github.com/DerekSelander/dynadump/assets/1037191/410eba7a-e708-4e3f-a9c0-ab15bbe31675">



```

`dynadump.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		BF6ABEE62BA3CBD900419D5A /* dynadump in CopyFiles */ = {isa = PBXBuildFile; fileRef = BF7559E72BA2AFC500F887DF /* dynadump */; };
		BF6ABEEF2BA4149D00419D5A /* AppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = BF6ABEEE2BA4149D00419D5A /* AppDelegate.m */; };
		BF6ABEF22BA4149D00419D5A /* SceneDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = BF6ABEF12BA4149D00419D5A /* SceneDelegate.m */; };
		BF6ABEF52BA4149D00419D5A /* ViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = BF6ABEF42BA4149D00419D5A /* ViewController.m */; };
		BF6ABEF82BA4149D00419D5A /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = BF6ABEF62BA4149D00419D5A /* Main.storyboard */; };
		BF6ABEFA2BA4149E00419D5A /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = BF6ABEF92BA4149E00419D5A /* Assets.xcassets */; };
		BF6ABEFD2BA4149E00419D5A /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = BF6ABEFB2BA4149E00419D5A /* LaunchScreen.storyboard */; };
		BF6ABF002BA4149E00419D5A /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = BF6ABEFF2BA4149E00419D5A /* main.m */; };
		BF7559EB2BA2AFC500F887DF /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = BF7559EA2BA2AFC500F887DF /* main.m */; };
		BF7EA0122C17C45B004B66EC /* exception_handler.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD6A2C0768110031E582 /* exception_handler.m */; };
		BF7EA0132C17C45E004B66EC /* dyld.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD672C0761C50031E582 /* dyld.m */; };
		BF7EA0142C17C461004B66EC /* objc.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD642C0761880031E582 /* objc.m */; };
		BF7EA0152C17C464004B66EC /* codesigning.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD5E2C06E4220031E582 /* codesigning.m */; };
		BF7EA0162C17C468004B66EC /* misc.c in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD612C06E4AC0031E582 /* misc.c */; };
		BF7EA0192C180484004B66EC /* DetailViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = BF7EA0182C180484004B66EC /* DetailViewController.m */; };
		BFA4AD5F2C06E4220031E582 /* codesigning.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD5E2C06E4220031E582 /* codesigning.m */; };
		BFA4AD622C06E4AC0031E582 /* misc.c in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD612C06E4AC0031E582 /* misc.c */; };
		BFA4AD652C0761880031E582 /* objc.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD642C0761880031E582 /* objc.m */; };
		BFA4AD682C0761C50031E582 /* dyld.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD672C0761C50031E582 /* dyld.m */; };
		BFA4AD6B2C0768110031E582 /* exception_handler.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD6A2C0768110031E582 /* exception_handler.m */; };
		BFA4ADA62C085A130031E582 /* exception_handler.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD6A2C0768110031E582 /* exception_handler.m */; };
		BFA4ADA72C085A130031E582 /* misc.c in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD612C06E4AC0031E582 /* misc.c */; };
		BFA4ADA82C085A130031E582 /* dyld.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD672C0761C50031E582 /* dyld.m */; };
		BFA4ADA92C085A130031E582 /* objc.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD642C0761880031E582 /* objc.m */; };
		BFA4ADAA2C085A130031E582 /* codesigning.m in Sources */ = {isa = PBXBuildFile; fileRef = BFA4AD5E2C06E4220031E582 /* codesigning.m */; };
		BFA4ADAB2C085A130031E582 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = BF7559EA2BA2AFC500F887DF /* main.m */; };
		BFA4ADB32C085A7B0031E582 /* dynadump_catalyst in CopyFiles */ = {isa = PBXBuildFile; fileRef = BFA4ADB22C085A130031E582 /* dynadump_catalyst */; };
/* End PBXBuildFile section */

/* Begin PBXCopyFilesBuildPhase section */
		BF7559E52BA2AFC500F887DF /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 12;
			dstPath = /usr/local/bin;
			dstSubfolderSpec = 0;
			files = (
				BF6ABEE62BA3CBD900419D5A /* dynadump in CopyFiles */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		BFA4ADAD2C085A130031E582 /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 12;
			dstPath = /usr/local/bin;
			dstSubfolderSpec = 0;
			files = (
				BFA4ADB32C085A7B0031E582 /* dynadump_catalyst in CopyFiles */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		BF6ABEEB2BA4149D00419D5A /* Dynamic Dump.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "Dynamic Dump.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		BF6ABEEE2BA4149D00419D5A /* AppDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AppDelegate.m; sourceTree = "<group>"; };
		BF6ABEF12BA4149D00419D5A /* SceneDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = SceneDelegate.m; sourceTree = "<group>"; };
		BF6ABEF32BA4149D00419D5A /* ViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ViewController.h; sourceTree = "<group>"; };
		BF6ABEF42BA4149D00419D5A /* ViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ViewController.m; sourceTree = "<group>"; };
		BF6ABEF72BA4149D00419D5A /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		BF6ABEF92BA4149E00419D5A /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		BF6ABEFC2BA4149E00419D5A /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		BF6ABEFE2BA4149E00419D5A /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		BF6ABEFF2BA4149E00419D5A /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
		BF7559E72BA2AFC500F887DF /* dynadump */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = dynadump; sourceTree = BUILT_PRODUCTS_DIR; };
		BF7559EA2BA2AFC500F887DF /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
		BF7EA0182C180484004B66EC /* DetailViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DetailViewController.m; sourceTree = "<group>"; };
		BF7EA01A2C18052B004B66EC /* DetailViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DetailViewController.h; sourceTree = "<group>"; };
		BFA4AD5D2C06E4220031E582 /* codesigning.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = codesigning.h; sourceTree = "<group>"; };
		BFA4AD5E2C06E4220031E582 /* codesigning.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = codesigning.m; sourceTree = "<group>"; };
		BFA4AD602C06E4AC0031E582 /* misc.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = misc.h; sourceTree = "<group>"; };
		BFA4AD612C06E4AC0031E582 /* misc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = misc.c; sourceTree = "<group>"; };
		BFA4AD632C0761880031E582 /* objc.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = objc.h; sourceTree = "<group>"; };
		BFA4AD642C0761880031E582 /* objc.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = objc.m; sourceTree = "<group>"; };
		BFA4AD662C0761C50031E582 /* dyld.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = dyld.h; sourceTree = "<group>"; };
		BFA4AD672C0761C50031E582 /* dyld.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = dyld.m; sourceTree = "<group>"; };
		BFA4AD692C0768110031E582 /* exception_handler.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = exception_handler.h; sourceTree = "<group>"; };
		BFA4AD6A2C0768110031E582 /* exception_handler.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = exception_handler.m; sourceTree = "<group>"; };
		BFA4ADB22C085A130031E582 /* dynadump_catalyst */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = dynadump_catalyst; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		BF6ABEE82BA4149D00419D5A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		BF7559E42BA2AFC500F887DF /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		BFA4ADAC2C085A130031E582 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		BF6ABEEC2BA4149D00419D5A /* Dynamic Dump */ = {
			isa = PBXGroup;
			children = (
				BF6ABEEE2BA4149D00419D5A /* AppDelegate.m */,
				BF6ABEF12BA4149D00419D5A /* SceneDelegate.m */,
				BF6ABEF32BA4149D00419D5A /* ViewController.h */,
				BF6ABEF42BA4149D00419D5A /* ViewController.m */,
				BF7EA0182C180484004B66EC /* DetailViewController.m */,
				BF7EA01A2C18052B004B66EC /* DetailViewController.h */,
				BF6ABEF62BA4149D00419D5A /* Main.storyboard */,
				BF6ABEF92BA4149E00419D5A /* Assets.xcassets */,
				BF6ABEFB2BA4149E00419D5A /* LaunchScreen.storyboard */,
				BF6ABEFE2BA4149E00419D5A /* Info.plist */,
				BF6ABEFF2BA4149E00419D5A /* main.m */,
			);
			path = "Dynamic Dump";
			sourceTree = "<group>";
		};
		BF7559DE2BA2AFC500F887DF = {
			isa = PBXGroup;
			children = (
				BF7559E92BA2AFC500F887DF /* dynadump */,
				BF6ABEEC2BA4149D00419D5A /* Dynamic Dump */,
				BF7559E82BA2AFC500F887DF /* Products */,
			);
			sourceTree = "<group>";
		};
		BF7559E82BA2AFC500F887DF /* Products */ = {
			isa = PBXGroup;
			children = (
				BF7559E72BA2AFC500F887DF /* dynadump */,
				BF6ABEEB2BA4149D00419D5A /* Dynamic Dump.app */,
				BFA4ADB22C085A130031E582 /* dynadump_catalyst */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		BF7559E92BA2AFC500F887DF /* dynadump */ = {
			isa = PBXGroup;
			children = (
				BF7559EA2BA2AFC500F887DF /* main.m */,
				BFA4AD6A2C0768110031E582 /* exception_handler.m */,
				BFA4AD672C0761C50031E582 /* dyld.m */,
				BFA4AD642C0761880031E582 /* objc.m */,
				BFA4AD5E2C06E4220031E582 /* codesigning.m */,
				BFA4AD612C06E4AC0031E582 /* misc.c */,
				BFA4AD692C0768110031E582 /* exception_handler.h */,
				BFA4AD662C0761C50031E582 /* dyld.h */,
				BFA4AD632C0761880031E582 /* objc.h */,
				BFA4AD602C06E4AC0031E582 /* misc.h */,
				BFA4AD5D2C06E4220031E582 /* codesigning.h */,
			);
			path = dynadump;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		BF6ABEEA2BA4149D00419D5A /* Dynamic Dump */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = BF6ABF012BA4149E00419D5A /* Build configuration list for PBXNativeTarget "Dynamic Dump" */;
			buildPhases = (
				BF6ABEE72BA4149D00419D5A /* Sources */,
				BF6ABEE82BA4149D00419D5A /* Frameworks */,
				BF6ABEE92BA4149D00419D5A /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = "Dynamic Dump";
			productName = "Dynamic Dump";
			productReference = BF6ABEEB2BA4149D00419D5A /* Dynamic Dump.app */;
			productType = "com.apple.product-type.application";
		};
		BF7559E62BA2AFC500F887DF /* dynadump */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = BF7559EE2BA2AFC500F887DF /* Build configuration list for PBXNativeTarget "dynadump" */;
			buildPhases = (
				BF7559E32BA2AFC500F887DF /* Sources */,
				BF7559E42BA2AFC500F887DF /* Frameworks */,
				BF7559E52BA2AFC500F887DF /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = dynadump;
			productName = dyno_dump;
			productReference = BF7559E72BA2AFC500F887DF /* dynadump */;
			productType = "com.apple.product-type.tool";
		};
		BFA4ADA42C085A130031E582 /* dynadump_catalyst */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = BFA4ADAF2C085A130031E582 /* Build configuration list for PBXNativeTarget "dynadump_catalyst" */;
			buildPhases = (
				BFA4ADA52C085A130031E582 /* Sources */,
				BFA4ADAC2C085A130031E582 /* Frameworks */,
				BFA4ADAD2C085A130031E582 /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = dynadump_catalyst;
			productName = dyno_dump;
			productReference = BFA4ADB22C085A130031E582 /* dynadump_catalyst */;
			productType = "com.apple.product-type.tool";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		BF7559DF2BA2AFC500F887DF /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastUpgradeCheck = 1500;
				TargetAttributes = {
					BF6ABEEA2BA4149D00419D5A = {
						CreatedOnToolsVersion = 15.0;
					};
					BF7559E62BA2AFC500F887DF = {
						CreatedOnToolsVersion = 15.0;
					};
				};
			};
			buildConfigurationList = BF7559E22BA2AFC500F887DF /* Build configuration list for PBXProject "dynadump" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = BF7559DE2BA2AFC500F887DF;
			productRefGroup = BF7559E82BA2AFC500F887DF /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				BF7559E62BA2AFC500F887DF /* dynadump */,
				BF6ABEEA2BA4149D00419D5A /* Dynamic Dump */,
				BFA4ADA42C085A130031E582 /* dynadump_catalyst */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		BF6ABEE92BA4149D00419D5A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BF6ABEFD2BA4149E00419D5A /* LaunchScreen.storyboard in Resources */,
				BF6ABEFA2BA4149E00419D5A /* Assets.xcassets in Resources */,
				BF6ABEF82BA4149D00419D5A /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		BF6ABEE72BA4149D00419D5A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BF7EA0122C17C45B004B66EC /* exception_handler.m in Sources */,
				BF6ABEF52BA4149D00419D5A /* ViewController.m in Sources */,
				BF7EA0152C17C464004B66EC /* codesigning.m in Sources */,
				BF7EA0132C17C45E004B66EC /* dyld.m in Sources */,
				BF7EA0162C17C468004B66EC /* misc.c in Sources */,
				BF7EA0192C180484004B66EC /* DetailViewController.m in Sources */,
				BF6ABEEF2BA4149D00419D5A /* AppDelegate.m in Sources */,
				BF6ABF002BA4149E00419D5A /* main.m in Sources */,
				BF6ABEF22BA4149D00419D5A /* SceneDelegate.m in Sources */,
				BF7EA0142C17C461004B66EC /* objc.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		BF7559E32BA2AFC500F887DF /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BFA4AD6B2C0768110031E582 /* exception_handler.m in Sources */,
				BFA4AD622C06E4AC0031E582 /* misc.c in Sources */,
				BFA4AD682C0761C50031E582 /* dyld.m in Sources */,
				BFA4AD652C0761880031E582 /* objc.m in Sources */,
				BFA4AD5F2C06E4220031E582 /* codesigning.m in Sources */,
				BF7559EB2BA2AFC500F887DF /* main.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		BFA4ADA52C085A130031E582 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BFA4ADA62C085A130031E582 /* exception_handler.m in Sources */,
				BFA4ADA72C085A130031E582 /* misc.c in Sources */,
				BFA4ADA82C085A130031E582 /* dyld.m in Sources */,
				BFA4ADA92C085A130031E582 /* objc.m in Sources */,
				BFA4ADAA2C085A130031E582 /* codesigning.m in Sources */,
				BFA4ADAB2C085A130031E582 /* main.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXVariantGroup section */
		BF6ABEF62BA4149D00419D5A /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				BF6ABEF72BA4149D00419D5A /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		BF6ABEFB2BA4149E00419D5A /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				BF6ABEFC2BA4149E00419D5A /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		BF6ABF022BA4149E00419D5A /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Manual;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = "";
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
					"SHARED_DYNAMIC_DUMP=1",
				);
				GENERATE_INFOPLIST_FILE = YES;
				HEADER_SEARCH_PATHS = "${PROJECT_DIR}";
				INFOPLIST_FILE = "Dynamic Dump/Info.plist";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UIMainStoryboardFile = Main;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 13.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				ONLY_ACTIVE_ARCH = NO;
				OTHER_LDFLAGS = "-Wl,-U,__dyld_debugger_notification";
				PRODUCT_BUNDLE_IDENTIFIER = "com.company.Dynamic-Dump";
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				SDKROOT = iphoneos;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		BF6ABF032BA4149E00419D5A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Manual;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = "";
				GCC_PREPROCESSOR_DEFINITIONS = (
					"SHARED_DYNAMIC_DUMP=1",
					"USE_CONSOLE=1",
				);
				GENERATE_INFOPLIST_FILE = YES;
				HEADER_SEARCH_PATHS = "${PROJECT_DIR}";
				INFOPLIST_FILE = "Dynamic Dump/Info.plist";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UIMainStoryboardFile = Main;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 13.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = "-Wl,-U,__dyld_debugger_notification";
				PRODUCT_BUNDLE_IDENTIFIER = "com.company.Dynamic-Dump";
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				SDKROOT = iphoneos;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		BF7559EC2BA2AFC500F887DF /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MACOSX_DEPLOYMENT_TARGET = 14.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
			};
			name = Debug;
		};
		BF7559ED2BA2AFC500F887DF /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MACOSX_DEPLOYMENT_TARGET = 14.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = macosx;
			};
			name = Release;
		};
		BF7559EF2BA2AFC500F887DF /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				ARCHS = (
					arm64,
					arm64e,
					x86_64,
				);
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = H4U46V6494;
				ENABLE_HARDENED_RUNTIME = NO;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = macosx;
				SUPPORTS_MACCATALYST = YES;
			};
			name = Debug;
		};
		BF7559F02BA2AFC500F887DF /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				ARCHS = (
					arm64,
					arm64e,
					x86_64,
				);
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = H4U46V6494;
				ENABLE_HARDENED_RUNTIME = NO;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = macosx;
				SUPPORTS_MACCATALYST = YES;
			};
			name = Release;
		};
		BFA4ADB02C085A130031E582 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				ARCHS = (
					arm64,
					arm64e,
				);
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = H4U46V6494;
				ENABLE_HARDENED_RUNTIME = YES;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = "watchsimulator watchos macosx iphonesimulator iphoneos driverkit appletvsimulator appletvos";
				SUPPORTS_MACCATALYST = YES;
			};
			name = Debug;
		};
		BFA4ADB12C085A130031E582 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				ARCHS = (
					arm64,
					arm64e,
				);
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = H4U46V6494;
				ENABLE_HARDENED_RUNTIME = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = "watchsimulator watchos macosx iphonesimulator iphoneos driverkit appletvsimulator appletvos";
				SUPPORTS_MACCATALYST = YES;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		BF6ABF012BA4149E00419D5A /* Build configuration list for PBXNativeTarget "Dynamic Dump" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				BF6ABF022BA4149E00419D5A /* Debug */,
				BF6ABF032BA4149E00419D5A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		BF7559E22BA2AFC500F887DF /* Build configuration list for PBXProject "dynadump" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				BF7559EC2BA2AFC500F887DF /* Debug */,
				BF7559ED2BA2AFC500F887DF /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		BF7559EE2BA2AFC500F887DF /* Build configuration list for PBXNativeTarget "dynadump" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				BF7559EF2BA2AFC500F887DF /* Debug */,
				BF7559F02BA2AFC500F887DF /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		BFA4ADAF2C085A130031E582 /* Build configuration list for PBXNativeTarget "dynadump_catalyst" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				BFA4ADB02C085A130031E582 /* Debug */,
				BFA4ADB12C085A130031E582 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = BF7559DF2BA2AFC500F887DF /* Project object */;
}

```

`dynadump.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:/Users/meow/code/dyno_dump/dynadump.xcodeproj">
   </FileRef>
</Workspace>

```

`dynadump.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

```

`dynadump.xcodeproj/xcshareddata/xcschemes/Dynamic Dump.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1500"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "BF6ABEEA2BA4149D00419D5A"
               BuildableName = "Dynamic Dump.app"
               BlueprintName = "Dynamic Dump"
               ReferencedContainer = "container:dynadump.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "BF6ABEEA2BA4149D00419D5A"
            BuildableName = "Dynamic Dump.app"
            BlueprintName = "Dynamic Dump"
            ReferencedContainer = "container:dynadump.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <EnvironmentVariables>
         <EnvironmentVariable
            key = "NOCOLOR"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "DEBUG"
            value = ""
            isEnabled = "NO">
         </EnvironmentVariable>
      </EnvironmentVariables>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "BF6ABEEA2BA4149D00419D5A"
            BuildableName = "Dynamic Dump.app"
            BlueprintName = "Dynamic Dump"
            ReferencedContainer = "container:dynadump.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`dynadump.xcodeproj/xcshareddata/xcschemes/dynadump.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1500"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "BF7559E62BA2AFC500F887DF"
               BuildableName = "dynadump"
               BlueprintName = "dynadump"
               ReferencedContainer = "container:dynadump.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES"
      viewDebuggingEnabled = "No">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "BF7559E62BA2AFC500F887DF"
            BuildableName = "dynadump"
            BlueprintName = "dynadump"
            ReferencedContainer = "container:dynadump.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
         <CommandLineArgument
            argument = "list"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dump CoreMotion CMDeviceOrientationManager"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dump /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "sig v16@?0@&quot;NSString&quot;8"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dump &quot;/Applications/Prime Video.app/Contents/MacOS/Prime Video&quot;"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "sign /tmp/yolo"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dump /tmp/yolo"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dump Foundation"
            isEnabled = "YES">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dump /usr/local/bin/mobdevim"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "cls NSFileManager"
            isEnabled = "NO">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "dsc 2149"
            isEnabled = "NO">
         </CommandLineArgument>
      </CommandLineArguments>
      <EnvironmentVariables>
         <EnvironmentVariable
            key = "NOCOLOR"
            value = ""
            isEnabled = "YES">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "DEBUG"
            value = ""
            isEnabled = "YES">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "USEEXC"
            value = "1"
            isEnabled = "NO">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "VERBOSE"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
      </EnvironmentVariables>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "BF7559E62BA2AFC500F887DF"
            BuildableName = "dynadump"
            BlueprintName = "dynadump"
            ReferencedContainer = "container:dynadump.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`dynadump.xcodeproj/xcshareddata/xcschemes/dynadump_catalyst.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1500"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "BFA4ADA42C085A130031E582"
               BuildableName = "dynadump_catalyst"
               BlueprintName = "dynadump_catalyst"
               ReferencedContainer = "container:dynadump.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES"
      viewDebuggingEnabled = "No">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "BFA4ADA42C085A130031E582"
            BuildableName = "dynadump_catalyst"
            BlueprintName = "dynadump_catalyst"
            ReferencedContainer = "container:dynadump.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
         <CommandLineArgument
            argument = "dump &quot;/Applications/Prime Video.app/Contents/MacOS/Prime Video&quot;"
            isEnabled = "YES">
         </CommandLineArgument>
      </CommandLineArguments>
      <EnvironmentVariables>
         <EnvironmentVariable
            key = "NOCOLOR"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
         <EnvironmentVariable
            key = "DEBUG"
            value = "1"
            isEnabled = "YES">
         </EnvironmentVariable>
      </EnvironmentVariables>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "BFA4ADA42C085A130031E582"
            BuildableName = "dynadump_catalyst"
            BlueprintName = "dynadump_catalyst"
            ReferencedContainer = "container:dynadump.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`dynadump/codesigning.h`:

```h
//
//  codesigning.h
//  dynadump
//
//  Created by Derek Selander on 5/28/24.
//

@import Foundation;
@import Security;

#import "misc.h"

int ad_hoc_codesign_file(const char *path);

```

`dynadump/codesigning.m`:

```m
//
//  codesigning.c
//  dynadump
//
//

#import "codesigning.h"

#ifndef log_debug
#define log_debug(S, ...)  {fprintf(stdout, "dbg %4d: " S, __LINE__, ##__VA_ARGS__); }
#endif
#ifndef log_error
#define log_error(S, ...)  { fprintf(stderr, "ERR: %s:%5d", __FILE__, __LINE__);} fprintf(stderr, S, ##__VA_ARGS__);
#endif

/*********************************************************************/
# pragma mark - codesigning + private APIs -
/*********************************************************************/

extern const CFStringRef kSecCodeSignerApplicationData;
extern const CFStringRef kSecCodeSignerDetached;
extern const CFStringRef kSecCodeSignerDigestAlgorithm;
extern const CFStringRef kSecCodeSignerDryRun;
extern const CFStringRef kSecCodeSignerEntitlements;
extern const CFStringRef kSecCodeSignerFlags;
extern const CFStringRef kSecCodeSignerIdentifier;
extern const CFStringRef kSecCodeSignerIdentifierPrefix;
extern const CFStringRef kSecCodeSignerIdentity;
extern const CFStringRef kSecCodeSignerPageSize;
extern const CFStringRef kSecCodeSignerRequirements;
extern const CFStringRef kSecCodeSignerResourceRules;
extern const CFStringRef kSecCodeSignerSDKRoot;
extern const CFStringRef kSecCodeSignerSigningTime;
extern const CFStringRef kSecCodeSignerTimestampAuthentication;
extern const CFStringRef kSecCodeSignerRequireTimestamp;
extern const CFStringRef kSecCodeSignerTimestampServer;
extern const CFStringRef kSecCodeSignerTimestampOmitCertificates;
extern const CFStringRef kSecCodeSignerPreserveMetadata;
extern const CFStringRef kSecCodeSignerTeamIdentifier;
extern const CFStringRef kSecCodeSignerPlatformIdentifier;
extern const CFStringRef kSecCodeSignerRuntimeVersion;
extern const CFStringRef kSecCodeSignerPreserveAFSC;

enum {
    kSecCodeSignerPreserveIdentifier = 1 << 0,        // preserve signing identifier
    kSecCodeSignerPreserveRequirements = 1 << 1,    // preserve internal requirements (including DR)
    kSecCodeSignerPreserveEntitlements = 1 << 2,    // preserve entitlements
    kSecCodeSignerPreserveResourceRules = 1 << 3,    // preserve resource rules (and thus resources)
    kSecCodeSignerPreserveFlags = 1 << 4,            // preserve signing flags
    kSecCodeSignerPreserveTeamIdentifier = 1 << 5,  // preserve team identifier flags
    kSecCodeSignerPreserveDigestAlgorithm = 1 << 6, // preserve digest algorithms used
    kSecCodeSignerPreservePEH = 1 << 7,                // preserve pre-encryption hashes
    kSecCodeSignerPreserveRuntime = 1 << 8,        // preserve the runtime version
};

enum {
    kSecCSRemoveSignature = 1 << 0,        // strip existing signature
    kSecCSSignPreserveSignature = 1 << 1, // do not (re)sign if an embedded signature is already present
    kSecCSSignNestedCode = 1 << 2,        // recursive (deep) signing
    kSecCSSignOpaque = 1 << 3,            // treat all files as resources (no nest scan, no flexibility)
    kSecCSSignV1 = 1 << 4,                // sign ONLY in V1 form
    kSecCSSignNoV1 = 1 << 5,            // do not include V1 form
    kSecCSSignBundleRoot = 1 << 6,        // include files in bundle root
    kSecCSSignStrictPreflight = 1 << 7, // fail signing operation if signature would fail strict validation
    kSecCSSignGeneratePEH = 1 << 8,        // generate pre-encryption hashes
    kSecCSSignGenerateEntitlementDER = 1 << 9, // generate entitlement DER
    kSecCSEditSignature = 1 << 10,      // edit existing signature
    kSecCSSingleThreadedSigning = 1 << 11, // disable concurrency when building the resource seal
};

typedef struct __SecCodeSigner *SecCodeSignerRef;

// Get around private imports for iOS which don't seem to have these in the sdk
#ifndef _H_CSCOMMON
typedef uint32_t SecCSFlags;
typedef struct SecStaticCode *SecStaticCodeRef;
#endif

__attribute__((weak))
OSStatus SecCodeSignerCreate(CFDictionaryRef parameters, SecCSFlags flags,
    SecCodeSignerRef *signer);

__attribute__((weak))
OSStatus SecCodeSignerAddSignature(SecCodeSignerRef signer,
    SecStaticCodeRef code, SecCSFlags flags);
    
__attribute__((weak))
OSStatus SecCodeSignerAddSignatureWithErrors(SecCodeSignerRef signer,
    SecStaticCodeRef code, SecCSFlags flags, CFErrorRef *errors);

__attribute__((weak))
extern OSStatus SecStaticCodeCreateWithPathAndAttributes(CFURLRef path, SecCSFlags flags, CFDictionaryRef attributes,
    SecStaticCodeRef * __nonnull CF_RETURNS_RETAINED staticCode);


/*********************************************************************/
# pragma mark - public -
/*********************************************************************/

int ad_hoc_codesign_file(const char *path) {
    NSDictionary *dict = @{ @"signer" :  [NSNull null]};
    SecCodeSignerRef ref = NULL;
    if (!SecCodeSignerCreate || !SecCodeSignerAddSignature || !SecCodeSignerAddSignatureWithErrors) {
        log_error("SDK doesn't support the required APIs, are you on iOS 15+/macOS 10.5+?\n")
        return -1;
    }
    
    OSStatus status = SecCodeSignerCreate((__bridge CFDictionaryRef)(dict),  /*kSecCSDefaultFlags*/ 0, &ref);
    if (status) {
        log_error("SecCodeSignerCreate error: %d\n", status);
        return -1;
    }
    
    NSString *pathStr = [NSString stringWithCString:path encoding:NSUTF8StringEncoding];
    NSURL *url = [NSURL fileURLWithPath:pathStr];
    SecStaticCodeRef staticCodeRef = nil;

    status = SecStaticCodeCreateWithPathAndAttributes((__bridge CFURLRef _Nonnull)(url), 0, (__bridge CFDictionaryRef _Nonnull)@{}, &staticCodeRef);
    if (status) {
        log_error("SecStaticCodeCreateWithPathAndAttributes error: %d\n", status);
        return -1;
    }
    
    CFErrorRef error = NULL;
    status = SecCodeSignerAddSignatureWithErrors(ref, staticCodeRef, /*kSecCSDefaultFlags*/ 0, &error);
    if (status || error) {
        log_error("SecCodeSignerAddSignatureWithErrors error: %d\n", status);
        return -1;
    }
    
    log_debug("we appeared to have codesigned \'%s\' correctly...\n", path);
    /*
        NSDictionary *verifyDict = nil;
        CFDictionaryRef omg = (__bridge CFDictionaryRef)verifyDict;
        status = SecCodeCopySigningInformation(staticCodeRef , kSecCSDynamicInformation | kSecCSSigningInformation | kSecCSRequirementInformation | kSecCSInternalInformation, &omg);
     */
    
    
    return 0;
}

```

`dynadump/dyld.h`:

```h
//
//  dsc.h
//  dynadump
//
//  Created by Derek Selander on 5/29/24.
//

#ifndef my_dyld_h
#define my_dyld_h

#include <stdio.h>

const char* generate_dlopen_path_backup_plan(const char* arg);
const char* dsc_image_as_num(uint32_t num);
const char* dsc_image_as_path(const char *path);
const char* dsc_image_as_name(const char *name);
void dump_dsc_images(void);
uint32_t dsc_images_count(void);
#endif /* dsc_h */


```

`dynadump/dyld.m`:

```m
//
//  dsc.c
//  dynadump
//
//  Created by Derek Selander on 5/29/24.
//

@import Foundation;
@import Darwin.POSIX;
@import MachO;
#include "dyld.h"
#include "misc.h"
#include "codesigning.h"

static bool can_use_dyld_apis = true;

static int copy_file(const char *sourceFile, const char *destFile) {
    FILE *src, *dst;
    int ch;
    
    log_debug("attempting to write %s -> %s\n", sourceFile, destFile);
    
    // Open source file for reading
    src = fopen(sourceFile, "r");
    if (src == NULL) {
        perror("Error opening source file");
        return 1;
    }
    
    // Open destination file for writing
    dst = fopen(destFile, "w");
    if (dst == NULL) {
        perror("Error opening destination file");
        fclose(src);
        return 1;
    }
    
    // Copy the contents from source to destination
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }
    
    // Close the files
    fclose(src);
    fclose(dst);
    
    return 0;
}


static int extract_architecture(const char *input_filename, const char *output_filename, cpu_type_t cpu_type, cpu_subtype_t cpu_subtype) {
    int fd = open(input_filename, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return -1;
    }
    
    struct stat st;
    if (fstat(fd, &st) == -1) {
        perror("fstat");
        close(fd);
        return -1;
    }
    
    void *file = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (file == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return -1;
    }
    
    struct fat_header *fat = (struct fat_header *)file;
    if (fat->magic != FAT_MAGIC && fat->magic != FAT_CIGAM) {
        log_debug("not a fat file, using normal copy\n");
        munmap(file, st.st_size);
        close(fd);
        return copy_file(input_filename, output_filename);
    }
    
    uint32_t nfat_arch = ntohl(fat->nfat_arch);
    struct fat_arch *archs = (struct fat_arch *)(fat + 1);
    bool success = false;
    for (uint32_t i = 0; i < nfat_arch; i++) {
        cpu_type_t arch_cpu_type = ntohl(archs[i].cputype);
        cpu_subtype_t arch_cpu_subtype = ntohl(archs[i].cpusubtype);
        
        if (arch_cpu_type == cpu_type && arch_cpu_subtype == cpu_subtype) {
            uint32_t offset = ntohl(archs[i].offset);
            uint32_t size = ntohl(archs[i].size);
            
            int out_fd = open(output_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (out_fd == -1) {
                perror("open output file");
                munmap(file, st.st_size);
                close(fd);
                return -1;
            }
            
            if (write(out_fd, (char *)file + offset, size) != size) {
                perror("write");
                close(out_fd);
                munmap(file, st.st_size);
                close(fd);
                return -1;
            }
            
            close(out_fd);
            success = true;
            break;
        }
    }
    
    munmap(file, st.st_size);
    close(fd);
    return success ? 0 : -1;
}


/// some code could be in a different platform, so we are gonna convert it to our currently running platform
static struct build_version_command* get_exe_platform(void) {
    struct mach_header_64 *header = (void*)&_mh_execute_header;
    int ncmds = header->ncmds;
    char *lc_ptr = (char*)&_mh_execute_header + sizeof(struct mach_header_64);
    for (uint32_t i = 0; i < ncmds; i++) {
        struct load_command *lc = (struct load_command *)lc_ptr;
        if (lc->cmd == LC_BUILD_VERSION) {
            return (void*)lc_ptr;
        }
        lc_ptr += lc->cmdsize;
    }
    return NULL;
}

uint32_t parseFat(struct fat_header* header) {
    
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
    
    
    //current fat_arch
    struct fat_arch* currentArch = NULL;
    
    //local architecture
    const NXArchInfo *localArch = NULL;
    
    //best matching slice
    struct fat_arch *bestSlice = NULL;
    
    //get local architecture
    localArch = NXGetLocalArchInfo();
    
    //swap?
    if(FAT_CIGAM == header->magic)
    {
        //swap fat header
        swap_fat_header(header, localArch->byteorder);
        
        //swap (all) fat arch
        swap_fat_arch((struct fat_arch*)((unsigned char*)header
                                         + sizeof(struct fat_header)), header->nfat_arch, localArch->byteorder);
    }
    
    //first arch, starts right after fat_header
    currentArch = (struct fat_arch*)((unsigned char*)header + sizeof(struct fat_header));
    
    bestSlice = NXFindBestFatArch(localArch->cputype,
                                  localArch->cpusubtype, (void*)((uintptr_t)header + sizeof(struct fat_header)), header->nfat_arch);
    if (!bestSlice) {
        log_error("Couldn't find a suitable slice in a FAT binary\n");
    }
    
#if __has_feature(ptrauth_calls)
    struct mach_header_64 *my_header = &_mh_execute_header;
    bestSlice->cpusubtype = my_header->cpusubtype;
    bestSlice->cputype = my_header->cputype;
#endif
    
    uint32_t offset = bestSlice->offset;
    swap_fat_arch((struct fat_arch*)((unsigned char*)header
                                     + sizeof(struct fat_header)), header->nfat_arch, localArch->byteorder);
    swap_fat_header(header, localArch->byteorder);
    
#pragma clang diagnostic pop
    
    return offset;
}


static void write_load_command_rpath(struct mach_header_64 *header64, char **ptr, NSString *resolvedPath) {
    unsigned long alignedSize = sizeof(struct rpath_command) +  strlen(resolvedPath.UTF8String) + 1;
    alignedSize += (4 - alignedSize % 4 );
    struct rpath_command rpath = {
        .cmd = LC_RPATH,
        .cmdsize = (uint32_t)alignedSize,
        .path.offset = sizeof(struct rpath_command),
    };
    memcpy(*ptr, &rpath, sizeof(struct rpath_command));
    strcpy(*ptr + sizeof(struct rpath_command), [resolvedPath UTF8String]);
    *ptr += alignedSize;
    header64->sizeofcmds += alignedSize;
    header64->ncmds++;
}

// On iOS (but not macOS!) dlopen will fail on an executable, so copy the file, if present, flip a bit,
// then resign it as an adhoc framework and then try again
const char* generate_dlopen_path_backup_plan(const char* arg) {
    NSString *originalExecutable = [NSString stringWithCString:dirname((char*)arg) encoding:NSUTF8StringEncoding];
    char buffer[1024] = {};
#if TARGET_OS_IPHONE
    snprintf(buffer, 1024, "/private/var/tmp/%d_%s", arc4random_uniform(0x1000000), basename((char*)arg));
#else
    snprintf(buffer, 1024, "/private/tmp/%d_%s", arc4random_uniform(0x1000000), basename((char*)arg));
#endif
    struct mach_header_64 *header = (void*)&_mh_execute_header;
    log_debug("generating patched image for dlopen @ %s -> %s\n", arg, buffer);
    
    if (extract_architecture(arg, buffer, header->cputype, header->cpusubtype)) {
        log_error("couldn't extract architecutre\n");
        return NULL;
    }
#pragma clang diagnostic pop
    
    int fd = open(buffer, O_RDWR|S_IXUSR);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    
    struct stat st;
    if (fstat(fd, &st) < 0) {
        perror("fstat");
        close(fd);
        exit(EXIT_FAILURE);
    }
    
    void *mapped = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mapped == MAP_FAILED) {
        perror("mmap");
        close(fd);
        exit(EXIT_FAILURE);
    }
    
    struct mach_header_64 *header64 = (struct mach_header_64 *)mapped;
    uint32_t ncmds;
    
restart:
    if (header64->magic == MH_MAGIC_64) {
        ncmds = header64->ncmds;
        if (header64->filetype != MH_DYLIB) {
            header64->filetype = MH_DYLIB;
        }
#if __has_feature(ptrauth_calls)
        // we could be building for arm64e that knocks out Apple, but then we'd need to pull
        // in arm64 executables as well
        struct mach_header_64 *my_header = (void*)&_mh_execute_header;
        header64->cpusubtype = my_header->cpusubtype;
        header64->cputype = my_header->cputype;
#endif
        if (getenv("FORCE_EXE")) {
            header64->filetype = MH_EXECUTE;
        }
        
    } else if (header64->magic == FAT_CIGAM) {
        
        uint32_t offset = parseFat((void*)header64);
        header64 = mapped + offset;
        
        goto restart;
        
    } else {
        fprintf(stderr, "Not a valid Mach-O file\n");
        munmap(mapped, st.st_size);
        close(fd);
        exit(EXIT_FAILURE);
    }
    
    NSMutableArray <NSString *>* rpaths = [NSMutableArray array];
    char *lc_ptr = (char*)header64 + sizeof(struct mach_header_64);
    for (uint32_t i = 0; i < ncmds; i++) {
        struct load_command *lc = (struct load_command *)lc_ptr;
        if (lc->cmd == LC_BUILD_VERSION) {
            struct build_version_command* my_platform = get_exe_platform();
            log_debug("changed LC_BUILD_VERSION to match executable %p\n", my_platform);
            memcpy(lc_ptr, my_platform, sizeof(struct build_version_command));
        }
        if (lc->cmd == LC_RPATH) {
            struct rpath_command *p = (void*)lc;
            NSString *rpathStr = [NSString stringWithCString:(char*)p + p->path.offset encoding:NSUTF8StringEncoding];
            [rpaths addObject:rpathStr];
            printf("");
        }
        lc_ptr += lc->cmdsize;
    }
    
    char* end_of_lc = (char*)header64 + sizeof(struct mach_header_64) + header64->sizeofcmds;
    char *ptr = end_of_lc;
    // attempt to add a LC_RPATH at the end that points to the OG spot
    
    NSMutableSet *set = [NSMutableSet set];
    for (NSString *rpathStr in rpaths) {
        if (![rpathStr containsString:@"@executable_path"] && ![rpathStr containsString:@"@loader_path"]) {
            continue;
        }
        NSString *resolvedPath = [[rpathStr stringByReplacingOccurrencesOfString:@"@executable_path" withString:originalExecutable] stringByReplacingOccurrencesOfString:@"@loader_path" withString:originalExecutable];
        if ([set containsObject:resolvedPath]) {
            continue;;
        }
        [set addObject:resolvedPath];
        write_load_command_rpath(header64, &ptr, resolvedPath);
    }
    
    // if we are opening a framework, it could be dependent on other frameworks
    // with an rpath so add that crap in
    //    NSString *originalPath = @"/Users/username/Library/Frameworks/MyFramework.framework";
    //         NSString *newBasePath = @"/New/Base/Directory";
    
    NSRange range = [originalExecutable rangeOfString:@"/Frameworks"];
    if (range.location != NSNotFound) {
        NSString *newPath = [originalExecutable stringByReplacingCharactersInRange:NSMakeRange(range.location + strlen("/Frameworks"), originalExecutable.length - range.length - range.location) withString:@""];
        write_load_command_rpath(header64, &ptr, newPath);
    }
    
    int projected_size = sizeof(struct dylib_command) + (uint32_t)strlen(arg) + 1;
    projected_size += (4 - (projected_size % 4)); // this lc needs to be 4 byte aligned
    struct dylib_command dylib = {
        .cmd = LC_ID_DYLIB,
        .cmdsize = projected_size,
        .dylib = {
            .name.offset = sizeof(struct dylib_command)
        }
    };
    memcpy(ptr, &dylib, sizeof(dylib));
    strcpy(ptr + sizeof(dylib), arg);
    header64->sizeofcmds += projected_size;
    header64->ncmds++;
    
    if (munmap(mapped, st.st_size) < 0) {
        perror("munmap");
    }
    
    close(fd);
    log_debug("writing to %s, about to codesign\n", buffer);
    ad_hoc_codesign_file(buffer);
    
    return strdup(buffer);
}


__attribute__((constructor)) static void init(void) {
    if (!dyld_shared_cache_for_each_image || !dyld_image_path_containing_address) {
        can_use_dyld_apis = false;
    }
}

typedef void(^dsc_image_callback) (int idx, dyld_image_t image, bool *stop);
static void dsc_iterate_images(dsc_image_callback callback) {
    if (!can_use_dyld_apis) {
        return;
    }
    const char *dsc_path = dyld_shared_cache_file_path();
    __block int counter = 0;
    __block bool stop = false;
    dyld_shared_cache_for_file(dsc_path, ^(dyld_shared_cache_t cache) {
        dyld_shared_cache_for_each_image(cache, ^(dyld_image_t image) {
            if (stop) {
                return;
            }
            if (callback) {
                callback(++counter, image, &stop);
            }
        });
    });
    
}

const char* dsc_image_as_num(uint32_t num) {
    if (!can_use_dyld_apis) {
        return NULL;
    }
    
    
    
    __block const char *str = NULL;
    dsc_iterate_images(^(int idx, dyld_image_t image, bool *stop) {
        if (num == idx) {
            str = strdup(my_dyld_image_get_installname(image));
            *stop = true;
        }
    });
    
    return str;
}

const char* dsc_image_as_path(const char *path) {
    if (!can_use_dyld_apis) {
        return NULL;
    }
    __block const char *outparam = NULL;
    dsc_iterate_images(^(int idx, dyld_image_t image, bool *stop) {
        const char * cur = my_dyld_image_get_installname(image);
        if (!strcmp(path, cur)) {
            outparam = cur;
            *stop = true;
        }
    });
    
    return outparam;
}

const char* dsc_image_as_name(const char *name) {
    if (!can_use_dyld_apis) {
        return NULL;
    }
    __block const char *outparam = NULL;
    dsc_iterate_images(^(int idx, dyld_image_t image, bool *stop) {
        const char * cur = my_dyld_image_get_installname(image);
        //    log_debug("image is: \"%s\"\n", basename((char*)cur));
        if (!strcmp(name, basename((char*)cur))) {
            outparam = cur;
            *stop = true;
        }
    });
    
    return outparam;
}

void dump_dsc_images(void) {
    if (!can_use_dyld_apis) {
        return;
    }
    dsc_iterate_images(^(int idx, dyld_image_t image, bool *stop) {
        log_out("%s%5lu%s %s%s%s\n", DYELLOW, (unsigned long)idx, DCOLOR_END, DCYAN, my_dyld_image_get_installname(image), DCOLOR_END);
    });
}

uint32_t dsc_images_count(void) {
    if (!can_use_dyld_apis) {
        return 0;
    }
    __block uint32_t counter = 0;
    dsc_iterate_images(^(int idx, dyld_image_t image, bool *stop) {
        counter++;
    });
    return counter;
}


```

`dynadump/exception_handler.h`:

```h
//
//  exception_handler.h
//  dynadump
//
//  Created by Derek Selander on 5/29/24.
//

#ifndef exception_handler_h
#define exception_handler_h

#include <stdio.h>

void exception_add_stepover_address(void* address);
void* safe_dlopen(const char *image);
void safe_dlopen_cleanup(void);
#endif /* exception_handler_h */

```

`dynadump/exception_handler.m`:

```m
//
//  exception_handler.c
//  dynadump
//
//  Created by Derek Selander on 5/29/24.
//

#include <dispatch/dispatch.h>
#include <dlfcn.h>
#include <pthread.h>
#include "exception_handler.h"
#include "misc.h"

static dispatch_group_t g_dispatch_group = nil;
static uintptr_t constructor_addresses[10] = {};
static uint8_t constructor_addresses_count = 0;
static mach_port_t exc_port = MACH_PORT_NULL;
static uintptr_t dyld_header = 0;


static void thread_walkback_frames_to_safe_code(thread_t thread) {
#if defined(__arm64__)
    arm_thread_state64_t state = {};
    mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
    HANDLE_ERR(thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, &count));
    Dl_info pinfo, linfo;
    
#if __has_feature(ptrauth_calls)
    void* pc = (void*)(state.__opaque_pc);
    void* lr = (void*)(state.__opaque_lr);
    uintptr_t stripped_pc = (uintptr_t)strip_pac((void*)state.__opaque_pc);
    uintptr_t stripped_lr = (uintptr_t)strip_pac((void*)state.__opaque_lr);
#else
    void* pc = (void*)(state.__pc);
    void* lr = (void*)(state.__lr);
    uintptr_t stripped_pc = (uintptr_t)(void*)(state.__pc);
    uintptr_t stripped_lr = (uintptr_t)(void*)(state.__lr);
    
#endif
    dladdr((void*)stripped_pc, &pinfo);
    dladdr((void*)stripped_lr, &linfo);
    log_debug("caught message\n   pc: 0x%012lx %s\n   lr: 0x%012lx %s\n", (uintptr_t)pc, pinfo.dli_sname, (uintptr_t)lr, linfo.dli_sname);
#ifdef __arm64__
    
#elif __x86_64__
TODO: implement geriatric CPU arch
#endif
    
    arm_debug_state64_t dbg = {};
    mach_msg_type_number_t dbg_cnt = ARM_DEBUG_STATE64_COUNT;
    HANDLE_ERR(thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbg, &dbg_cnt));
    
    // lldb puts a breakpoint on _dyld_debugger_notification, so catch & release
    Dl_info info = {};
    
    if (dladdr((void*)pc, &info) != 0) {
        if (!strcmp(info.dli_sname, "_dyld_debugger_notification")) {
            log_debug("it's _dyld_debugger_notification\n");
#if __has_feature(ptrauth_calls)
            state.__opaque_pc = state.__opaque_lr;
#else
            state.__pc = state.__lr;
#endif
            HANDLE_ERR(thread_set_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, count));
            return;
        }
    }
    
    
    for (uint8_t i = 0; i < constructor_addresses_count; i++) {
        
        if (constructor_addresses[i] == stripped_pc) {
            if (g_debug) {
                log_out("found caller 0x%012lx\n", constructor_addresses[i])
            }
            stripped_pc += ARM64_OPCODE_SIZE;
#if __has_feature(ptrauth_calls)
            stripped_pc = (uintptr_t)ptrauth_sign_unauthenticated((void*)stripped_pc, ptrauth_key_process_independent_code, 0);
            state.__opaque_pc = (void*)stripped_pc;
#else
            state.__pc = stripped_pc;
#endif
            HANDLE_ERR(thread_set_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, count))
            return;
        }
    }
    
    // This is for all other code that I've missed
#if __has_feature(ptrauth_calls)
    void* sp = strip_pac((void*)state.__opaque_sp);
    struct fp_ptr *frame = strip_pac((void*)state.__opaque_fp);
#else
    uintptr_t sp = (uintptr_t)strip_pac((void*)state.__sp);
    struct fp_ptr *frame = strip_pac((void*)state.__fp);
#endif
    
    while (frame && frame->next != NULL) {
        
        off_t offset = ((uintptr_t)frame - (uintptr_t)sp) + sizeof(struct fp_ptr);
        sp += offset;
        
        // walk back the stack frames looking for libobjc / [lib]dyld
        const void* addr = strip_pac(frame->address);
        const char* path = dyld_image_path_containing_address(addr);
        
        if (!strcmp("/usr/lib/libobjc.A.dylib", path) ||
            !strcmp("/usr/lib/system/libdyld.dylib", path) ||
            !strcmp("/usr/lib/dyld", path)) {
            break;
        }
        frame = strip_pac(frame->next);
    }
    
#if __has_feature(ptrauth_calls)
    state.__opaque_lr = ptrauth_sign_unauthenticated(frame->address, ptrauth_key_return_address, 0);
    state.__opaque_pc = ptrauth_sign_unauthenticated(frame->address, ptrauth_key_return_address, 0);
    state.__opaque_fp = ptrauth_sign_unauthenticated(frame->next, ptrauth_key_frame_pointer, 0);
    state.__opaque_sp = ptrauth_sign_unauthenticated(sp, ptrauth_key_frame_pointer, 0);
#else
    state.__lr = (uintptr_t)strip_pac(frame->address);
    state.__pc = (uintptr_t)strip_pac(frame->address);
    state.__fp = (uintptr_t)strip_pac(frame->next);
    state.__sp = (uintptr_t)strip_pac((void*)sp);
    
#endif
    
    HANDLE_ERR(thread_set_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, count))
#endif
}

void* server_thread(void *arg) {
    pthread_setname_np("Exception Handler");
    thread_t thread = (thread_t)(uintptr_t)arg;
#if defined(__arm64__)
    arm_debug_state64_t dbg = {};
    mach_msg_type_number_t cnt = ARM_DEBUG_STATE64_COUNT;
    HANDLE_ERR(thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbg, &cnt));
    for (int i = 0; i < constructor_addresses_count; i++) {
        dbg.__bvr[i] = (__int64_t)constructor_addresses[i];
        dbg.__bcr[i] = S_USER|BCR_ENABLE|BCR_BAS;
    }
    HANDLE_ERR(thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbg, ARM_DEBUG_STATE64_COUNT));
#elif defined(__x86_64__)
    
#else
#error "da fuck you compiling?"
#endif
    
    
    mach_port_options_t options = {.flags = MPO_INSERT_SEND_RIGHT};
    HANDLE_ERR(mach_port_construct(mach_task_self(), &options, 0, &exc_port));
    HANDLE_ERR(thread_set_exception_ports(thread, EXC_MASK_ALL, exc_port, EXCEPTION_DEFAULT|MACH_EXCEPTION_CODES, THREAD_STATE_NONE));
    
    dispatch_group_leave(g_dispatch_group);
    
    kern_return_t kr = KERN_SUCCESS;
    
    
    while(1) {
        char buffer[GOOD_E_NUFF_BUFSIZE];
        mach_msg_header_t *msg = (void*)buffer;
        msg->msgh_remote_port = MACH_PORT_NULL;
        msg->msgh_id = 2405;
        msg->msgh_local_port = exc_port;
        msg->msgh_size = GOOD_E_NUFF_BUFSIZE;
        
        if ((kr = mach_msg_receive(msg))) {
            // other thread will mod -1 the port so ignore MACH_RCV_PORT_CHANGED
            if (kr != MACH_RCV_PORT_CHANGED) {
                fprintf(stderr, "recv err %s %x\n", mach_error_string(kr), kr);
                HANDLE_ERR(kr);
            }
            break;
        }
        exc_req* req = ((exc_req*)msg);
        
        log_debug("exception: %d, subcode: 0x%016llx, 0x%016llx\n", req->exception, req->code[0], req->code[1]);
        thread_t thread = req->thread.name;
        thread_walkback_frames_to_safe_code(thread);
        msg->msgh_local_port = MACH_PORT_NULL;
        msg->msgh_bits = MACH_RCV_MSG | MACH_SEND_TIMEOUT;
        msg->msgh_id = 2505;
        msg->msgh_size = sizeof(exc_resp);
        exc_resp *resp = (exc_resp*)msg;
        resp->NDR = NDR_record;
        resp->RetCode = KERN_SUCCESS;
        if ((kr = mach_msg_send(msg))) {
            HANDLE_ERR(kr);
            break;
        }
    }
    return NULL;
}


void safe_dlopen_cleanup(void) {
    if (!USE_EXECPTION_HANDLER()) {
        return;
    }
#if defined(__arm64__)
    arm_debug_state64_t dbg = {};
    mach_msg_type_number_t cnt = ARM_DEBUG_STATE64_COUNT;
    HANDLE_ERR(thread_get_state(mach_thread_self(), ARM_DEBUG_STATE64, (thread_state_t)&dbg, &cnt));
    for (int i = 0; i < constructor_addresses_count; i++) {
        dbg.__bcr[i] &= ~BCR_ENABLE;
    }
    HANDLE_ERR(thread_set_state(mach_thread_self(), ARM_DEBUG_STATE64, (thread_state_t)&dbg, cnt));
    
    // remove the handler so debuggers can catch f ups better
    HANDLE_ERR(thread_set_exception_ports(mach_thread_self(), EXC_MASK_ALL, MACH_PORT_NULL, EXCEPTION_DEFAULT|MACH_EXCEPTION_CODES, THREAD_STATE_NONE));
    
    // yanking the port will break the while loop on in the server_thread
    mach_port_mod_refs(mach_task_self(), exc_port, MACH_PORT_RIGHT_RECEIVE, -1);
#endif
}

void* safe_dlopen(const char *image) {
#if defined(__arm64__)
    // setup a handler in case a constructor tries to take us down
    g_dispatch_group = dispatch_group_create();
    thread_t thread = mach_thread_self();
    dispatch_group_enter(g_dispatch_group);
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        server_thread((void*)(uintptr_t)thread);
    });
    
    if (dispatch_group_wait(g_dispatch_group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)))) {
        log_out("timeout for exception handler setup, resuming...\n");
    }
    
    
    void* handle = dlopen(image, RTLD_NOW);
    
    return handle;
#else
    return NULL;
#endif
}



void exception_add_stepover_address(void* address) {
    address = strip_pac(address);
    constructor_addresses[constructor_addresses_count++] = (uintptr_t)address;
    
}

```

`dynadump/main.m`:

```m
//
//  MIT License
//
//  Copyright (c) 2024 Derek Selander
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software. Attribution is requested but not
//  required if Software is public facing
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//
// dynadump:
// Quick'n'Dirty imp of an ObjC class-dump primarily for inspecting dyld shared
// cache libraries on the host machine done via dlopen and public ObjC APIs. So hopefully,
// this code will better withstand breaking changes to objc/dyld internal changes.
// On ARM64, this will use hardware breakpoints to prevent the constructors from firing
// which will sometimes crash the process. On x86_64, this is disabled.
//
// to compile for jb'd iOS:
// xcrun -sdk iphoneos clang -fmodules -arch arm64 -Wl,-U,_dyld_shared_cache_for_each_image,-U,_dyld_image_path_containing_address -o /tmp/dynadump  /Users/meow/code/dyno_dump/dynadump/main.m
// echo "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgcGxpc3QgUFVCTElDICItLy9BcHBsZS8vRFREIFBMSVNUIDEuMC8vRU4iICJodHRwczovL3d3dy5hcHBsZS5jb20vRFREcy9Qcm9wZXJ0eUxpc3QtMS4wLmR0ZCI+PHBsaXN0IHZlcnNpb249IjEuMCI+PGRpY3Q+CjxrZXk+Y29tLmFwcGxlLnByaXZhdGUuY3MuZGVidWdnZXI8L2tleT48dHJ1ZS8+CjxrZXk+Y29tLmFwcGxlLnByaXZhdGUudGhyZWFkLXNldC1zdGF0ZTwva2V5Pjx0cnVlLz4KPGtleT5jb20uYXBwbGUucHJpdmF0ZS5zZXQtZXhjZXB0aW9uLXBvcnQ8L2tleT48dHJ1ZS8+CjwvZGljdD48L3BsaXN0PgoK" | base64 -D > /tmp/entitlements
// codesign -f -s - --entitlements /tmp/entitlement /tmp/dynadump
//
// to compile for macOS
// xcrun -sdk macos clang -arch arm64 -arch x86_64 -fmodules -o /usr/local/bin/dynadump /path/to/this/file/main.m -Wl,-U,_dyld_shared_cache_for_each_image,-U,_dyld_image_path_containing_address
// codesign -f -s - /usr/local/bin/dynadump
//
// to compile as a shared framework
// xcrun -sdk iphoneos clang -fmodules -o /tmp/dynadump.dylib /path/to/this/file/main.m -shared -DSHARED_DYNAMIC_DUMP

// full ios
// xcrun -sdk iphoneos clang -fmodules -arch arm64 -Wl,-U,_dyld_shared_cache_for_each_image,-U,_dyld_image_path_containing_address -o /tmp/dynadump  /Users/meow/code/dyno_dump/dynadump/main.m  && echo "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgcGxpc3QgUFVCTElDICItLy9BcHBsZS8vRFREIFBMSVNUIDEuMC8vRU4iICJodHRwczovL3d3dy5hcHBsZS5jb20vRFREcy9Qcm9wZXJ0eUxpc3QtMS4wLmR0ZCI+PHBsaXN0IHZlcnNpb249IjEuMCI+PGRpY3Q+CjxrZXk+Y29tLmFwcGxlLnByaXZhdGUuY3MuZGVidWdnZXI8L2tleT48dHJ1ZS8+CjxrZXk+Y29tLmFwcGxlLnByaXZhdGUudGhyZWFkLXNldC1zdGF0ZTwva2V5Pjx0cnVlLz4KPGtleT5jb20uYXBwbGUucHJpdmF0ZS5zZXQtZXhjZXB0aW9uLXBvcnQ8L2tleT48dHJ1ZS8+CjwvZGljdD48L3BsaXN0PgoK" | base64 -D > /tmp/entitlements && codesign -f -s - --entitlements /tmp/entitlements /tmp/dynadump &&  ssh root@localhost  -p 2323 -o "StrictHostKeyChecking=no" "rm -rf /var/jb/usr/local/bin/dynadump" &&   scp -O -P 2323 /tmp/dynadump root@localhost:/var/jb/usr/local/bin/

@import ObjectiveC;
@import Foundation;
@import Darwin;
@import OSLog;
@import MachO;
@import Security;

#include <mach-o/dyld_images.h>
#import "misc.h"
#import "codesigning.h"
#import "objc.h"
#import "dyld.h"
#import "exception_handler.h"

/*********************************************************************/
# pragma mark - internal testing
/*********************************************************************/

#if 0
@interface TestInterface : NSObject
@property (nonatomic, strong) NSURL *someURL;
@end

@implementation TestInterface (MyCategory)
- (void)categoryMethod {}
@end

@implementation TestInterface
- (void)booopbeepbop{}
@end
#endif


/*
 We need to find all the locations that constructors are called and map them so we can catch them if we need to use the safe dlopen
 */
__attribute__((constructor)) static void grab_caller_address(void) {
    void* return_address = strip_pac((void*)__builtin_return_address(0)) - ARM64_OPCODE_SIZE;
    exception_add_stepover_address(return_address);
    if (getenv("DEBUG")) {
        Dl_info info;
        dladdr((void*)return_address, &info);
        log_out("patching load address 0x%012lx %s\n",  (uintptr_t)return_address, info.dli_sname);
    }
}

@interface MERPLERPBURPDERP : NSObject
@end
@implementation MERPLERPBURPDERP
+ (void)load {
    void* return_address = strip_pac((void*)__builtin_return_address(0)) - ARM64_OPCODE_SIZE;
    exception_add_stepover_address(return_address);
    if (getenv("DEBUG")) {
        Dl_info info;
        dladdr((void*)return_address, &info);
        log_out("patching load address 0x%012lx %s\n",  (uintptr_t)return_address, info.dli_sname);
    }
}
@end

@implementation NSObject (BOWMEOWYAYHEY)
+ (void)load {
    void* return_address = strip_pac((void*)__builtin_return_address(0)) - ARM64_OPCODE_SIZE;
    exception_add_stepover_address(return_address);
    if (getenv("DEBUG")) {
        Dl_info info;
        dladdr(return_address, &info);
        log_out("patching load address 0x%012lx %s\n", (uintptr_t)return_address, info.dli_sname);
    }
}
@end

void dlopen_n_dump_objc_classes(const char *_arg, const char*clsName, bool do_classlist) {
    
    void* handle = NULL;
    uint32_t dsc_num = strtod(_arg, NULL);
    const char *path = NULL;
    const struct mach_header_64* header = NULL;
    
    char arg[PATH_MAX] = {};
    realpath(_arg, arg);
    // can we even open this thing? i.e. for cases like dynadump dump Foundation
    log_debug("can we open this? %s", arg);
    handle = dlopen(arg, RTLD_NOLOAD);
    log_debug(", did we open this? %p\n", handle);
    
    if (dsc_num) {
        path = dsc_image_as_num(dsc_num);
    } else if (handle) {
        path = strdup(arg);
    } else {
        path = dsc_image_as_name(_arg);
        log_debug("changing arg %s -> %s\n", arg, path);
        // if we can't find a path we'll just start with the OG and fail later if needed
        if (!path) {
            path = strdup(arg);
        }
    }
    
    // use stderr, so everything else is still grep-able
    fprintf(stderr, "%s%s%s\n", DCYAN, path, DCOLOR_END);
#if 0
#warning you've got normal dlopen going, derek
    handle = dlopen(path, RTLD_NOW);
#else
    if (USE_EXECPTION_HANDLER()) {
        handle = safe_dlopen(path);
    } else {
        handle = dlopen(path, RTLD_NOW);
    }
#endif
    
    // we tried to dlopen but failed, potentially due to a different platform or an exe
    // since dlopen doesn't work on executables (on certain platforms)
    // so we will make a copy of this image and tweak the platform, arch type (if needed)
    // and the load commands, and then resign this with an ad-hoc signature
    if (!handle) {
        log_debug("couldn't open initial file %s, error %s\n\n...  falling back patching image\n", path, dlerror());
        const char *newPath = generate_dlopen_path_backup_plan(path);
        if (!newPath){
            log_error("couldn't generate patched dlopen file. bailing\n");
            exit(1);
        }
        log_debug("trying to open patched file at %s\n", newPath);
        
        // regardless of the safe or non-safe, the catch logic has been set, just use dlopen
        handle = dlopen(newPath, RTLD_NOW);
        
        // rewrite the `path` var so logic past this conditional block will work
        if (newPath) {
            if (path) {
                free((void*)path);
                path = strdup(newPath);
            }
            free((void*)newPath);
        }
        
        // keep the modified dylib around while debugging
        if (!g_debug) {
            remove(newPath);
        }
        // f it, I give up
        if (!handle) {
            log_error("couldn't open \"%s\", err: %s\n", arg, dlerror());
            return;
        }
    }
    
    // remove breakpoints
    safe_dlopen_cleanup();
    
    
    // iterate loaded images in process looking for the dlopen's start address
    task_dyld_info_data_t info;
    mach_msg_type_number_t count = TASK_DYLD_INFO_COUNT;
    HANDLE_ERR(task_info(mach_task_self(), TASK_DYLD_INFO, (task_info_t)&info, &count));
    struct dyld_all_image_infos *all_image_infos = (void*)info.all_image_info_addr;
    struct dyld_image_info *imageArray = (void*)all_image_infos->infoArray;
    
    char resolved[PATH_MAX] = {};
    realpath(path, resolved);
    for (uint i = 0; i < all_image_infos->infoArrayCount; i++) {
        struct dyld_image_info *info = &imageArray[i];
        log_debug("searching loaded image: %s\n", info->imageFilePath);
        if (!strcmp(info->imageFilePath, resolved)) {
            header = (void*)info->imageLoadAddress;
            log_debug("FOUND IMAGE! at %p\n", header);
            break;
        }
    }
    
    // Try again with a different path in the case dlopen views the lib as a different nmae
    if (!header) {
        for (uint i = 0; i < all_image_infos->infoArrayCount; i++) {
            struct dyld_image_info *info = &imageArray[i];
            if (!strcmp(basename((char *)info->imageFilePath), basename((char *)path))) {
                header = (void*)info->imageLoadAddress;
                break;
            }
        }
    }
    
    if (clsName) {
        Class cls = objc_getClass(clsName);
        dump_objc_class_info(cls);
    } else {
        dump_all_objc_classes(do_classlist, path, header);
    }
    
    // TODO potential leak for some cases
    //    if (path) {
    //        free((void*)path);
    //    }
}

__attribute__((constructor)) static void setup(void) {
    g_color = getenv("NOCOLOR") ? false : true;
    g_debug = getenv("DEBUG") ? true : false;
    g_use_exc = getenv("USEEXC") ? true : false;
    g_verbose = getenv("VERBOSE") ? 5 : 0;
    
    // if piping remove color
    if (isatty(STDOUT_FILENO) == 0) {
        g_color = false;
    }
    
    // but turn it on if specified
    if (getenv("COLOR")) {
        g_color = true;
    }
}

#ifndef SHARED_DYNAMIC_DUMP

void print_help(void) {
    log_out("\n  dynadump (built: %s, %s) - yet another class-dump done via dlopen & exception catching\n\n", __DATE__, __TIME__);
    log_out("\tParameters:\n")
    log_out("\tlist                list all the dylibs in the dyld shared cache (dsc)\n");
    log_out("\tlist  $DYLIB        list all the objc classes in a dylib $DYLIB\n");
    log_out("\tdump  $DYLIB        dump all the ObjC classes found in a dylib on disk\n");
    log_out("\tdump  $DYLIB $CLASS dump a specific ObjC class found in dylib $DYLIB\n");
    log_out("\tsig   $SIGSTR       prints the demangled objc signature\n");
    log_out("\tsign  $DYLIB        attempts to sign a dylib in place\n");
    log_out("\tlist  $DYLIB $CLASS Same cmd as above (convenience for listing then dumping)\n");
    
    
    log_out("\n\tEnvironment Variables:\n");
    log_out("\tNOCOLOR, (-c) - Forces no color, color will be on by default unless piped\n");
    log_out("\tCOLOR         - Forces color, regardless of stdout destination\n");
    log_out("\tVERBOSE  (-v) - Verbose output\n");
    log_out("\tUSEEXC   (-D) - Use an exception handler (off by default in x86_64)\n");
    log_out("\tDEBUG    (-g) - Used internally to hunt down f ups\n");
    
    exit(1);
}

int main(int argc, char * const  argv[]) {
    int opt;
    if (argc == 1) {
        print_help();
    }
    
    while ((opt = getopt(argc, argv, "vcgVD")) != -1) {
        switch (opt) {
            case 'v':
                g_verbose = 5;
                break;
            case 'g':
                g_debug = true;
                break;
            case 'c':
                g_color = false;
                break;
            case 'D':
                g_use_exc = true;
                break;
            case 'V':
                print_help();
                exit(1);
            default: /* '?' */
                log_error("bad argument\n");
                return 1;
        }
    }
    if (getenv("COLOR")) {
        g_color = true;
    }
    if (g_debug) {
        setenv("DYLD_PRINT_INITIALIZERS", "1", 1);
        setenv("DYLD_PRINT_BINDINGS", "1", 1);
    }
    
    // list the dsc images
    if (!strcmp("list", argv[1])) {
        if (argc == 2) {
            dump_dsc_images();
        } else {
            if (argc == 3) {
                dlopen_n_dump_objc_classes(argv[2], NULL, true);
            } else if (argc == 4) {
                dlopen_n_dump_objc_classes(argv[2], argv[3], true);
            }
        }
        exit(0);
    } else if (!strcmp("dump", argv[1])) {
        if (argc < 3) {
            log_error("dump <NUM|PATH_2_DYLIB\n");
            exit(1);
        }
        dlopen_n_dump_objc_classes(argv[2], argc > 2 ? argv[3] : NULL,  false);
    } else if (!strcmp("sign", argv[1])) {
        if (argc < 3) {
            log_error("sign /path/to/file\n");
            exit(1);
        }
        char buff[PATH_MAX];
        realpath(argv[2], buff);
        int fd = open(buff, O_RDWR|S_IXUSR);
        if (fd == -1) {
            log_error("couldn't open file \"%s\"\n", buff);
            exit(1);
        }
        ad_hoc_codesign_file(buff);
    } else if (!strcmp("sig", argv[1])) {
        if (argc < 3) {
            log_error("sig objc_signature_str\n");
            exit(1);
        }
        
        // hack just for debugging purposes
        struct big_method_t {
            SEL name;
            const char *types;
            void* imp;
        } m = {
            .types = argv[2],
            .name = sel_registerName(""),
        };
        
        char buffer[PATH_MAX] = {};
        method_getReturnType((Method)&m, buffer, PATH_MAX);
        get_object_type_description(buffer, buffer);
        log_out("ret: %s", buffer);
        int count = method_getNumberOfArguments((Method)&m);
        log_out(" function( ");
        for (int i = 0; i < count; i ++) {
            const char *arg = method_copyArgumentType((Method)&m, i);
            get_object_type_description(arg, buffer);
            log_out("%s arg%d", buffer, i+1);
            if (i < count - 1 && count > 1) {
                log_out(", ");
            }
            free((void*)arg);
        }
        log_out(")\n");
    } else {
        print_help();
    }
    
    return 0;
}

#endif

```

`dynadump/misc.c`:

```c
//
//  misc.c
//  dynadump
//
//  Created by Derek Selander on 5/28/24.
//

#include <stdlib.h>
#include <stdbool.h>
#include <sys/sysctl.h>
#include "misc.h"

bool g_debug = false;
bool g_color = true;
bool g_use_exc = false;
int g_verbose = 0;

// DYLD_MACOS_12_ALIGNED_SPI
const char* my_dyld_image_get_installname(dyld_image_t image) {
    extern __attribute__((weak)) const char* dyld_image_get_installname(dyld_image_t image);
    if (dyld_image_get_installname) {
        return dyld_image_get_installname(image);
    }
    return "???";
}

void* strip_pac(void* addr) {
#if defined(__arm64__)
    static uint32_t g_addressing_bits = 0;
    if (g_addressing_bits == 0) {
        size_t len = sizeof(uint32_t);
        if (sysctlbyname("machdep.virtual_address_size", &g_addressing_bits, &len,
                         NULL, 0) != 0) {
            g_addressing_bits = -1; // if err, f it, just assume anything goes
        }
    }
    uintptr_t mask = ((1UL << g_addressing_bits) - 1) ;
    return (void*)((uintptr_t)addr & mask);
#else
    return addr;
#endif
}

```

`dynadump/misc.h`:

```h
//
//  misc.h
//  dynadump
//
//  Created by Derek Selander on 5/28/24.
//

#ifndef misc_h
#define misc_h

#include <stdio.h>
#include <mach/message.h>
#include <mach/mach.h>

extern bool g_debug;
extern bool g_color;
extern int g_verbose;
/// Use SHARED_DYNAMIC_DUMP to make a shared library
#ifndef SHARED_DYNAMIC_DUMP
#define DYNAMIC_DUMP_VISIBILITY static
#else
#define DYNAMIC_DUMP_VISIBILITY __attribute__((visibility("default")))
#endif

#define DYLD_LOADER_CLASS_MAGIC 'l4yd'

#define GOOD_E_NUFF_BUFSIZE 1000

#define do_copy_n_return(STR) { strcpy(buffer, (STR)); return 0; }
#define append_content(FORMAT, ...) { buff_offset += snprintf(buffer + buff_offset, GOOD_E_NUFF_BUFSIZE - buff_offset, FORMAT, ##__VA_ARGS__); }
#define ARM64_OPCODE_SIZE sizeof(uint32_t)

// error handling
#define HANDLE_ERR(E) {if ((E)) { log_error("Error: %d, %s \n", (E), mach_error_string((E)));}}

// stolen from objc4
# if __arm64__
// ARM64 simulators have a larger address space, so use the ARM64e
// scheme even when simulators build for ARM64-not-e.
#   if __has_feature(ptrauth_calls) || defined(TARGET_OS_SIMULATOR)
#     define ISA_MASK        0x007ffffffffffff8ULL
#   else
#     define ISA_MASK        0x0000000ffffffff8ULL
#   endif
# elif __x86_64__
#   define ISA_MASK        0x00007ffffffffff8ULL
# else
#   error unknown architecture for packed isa
# endif

/// -DUSE_CONSOLE for NSLog, else fprintf
#ifdef USE_CONSOLE
#define log_out(S, ...)   NSLog(@ S, ##__VA_ARGS__);
#define log_error(S, ...)  { NSLog(@  "ERR: %5d", __LINE__);} NSLog(@  S, ##__VA_ARGS__);
#define log_debug(S, ...) if (g_debug) {NSLog(@ "dbg %4d: " S, __LINE__, ##__VA_ARGS__); }
#else
#define log_out(S, ...)   fprintf(stdout, S, ##__VA_ARGS__);
#define log_out_verbose(S, ...)  if (g_verbose) { fprintf(stdout, S, ##__VA_ARGS__); }
#define log_error(S, ...)  { fprintf(stderr, "ERR: %s:%5d", __FILE__, __LINE__);} fprintf(stderr, S, ##__VA_ARGS__);
#define log_debug(S, ...) if (g_debug) { fprintf(stderr, "%s:%-4d  " S, __FUNCTION__, __LINE__, ##__VA_ARGS__); }
#endif

/// arm64 debug stuff
#define S_USER                  ((uint32_t)(2u << 1))
#define BCR_ENABLE              ((uint32_t)(1u))
#define SS_ENABLE               ((uint32_t)(1u))
#define BCR_BAS                 ((uint32_t)(15u << 5))

#define DCYAN  (g_color ? "\e[36m" : "")
#define DYELLOW   (g_color ? "\e[33m" : "")
#define DMAGENTA   (g_color ? "\e[95m" : "")
#define DRED   (g_color ? "\e[91m" : "")
#define DPURPLE   (g_color ? "\e[35m" : "")
#define DBLUE   (g_color ? "\e[34m" : "")
#define DGRAY   (g_color ? "\e[90m" : "")
#define DGREEN   (g_color ? "\e[92m" : "")
#define DDARK_GREEN    (g_color ? "\e[32m" : "")
#define DBOLD   (g_color ? "\e[1m" : "")
#define DCYAN_UNDERLINE   (g_color ? "\033[36;1;4m" : "")
#define DPURPLE_BOLD  (g_color ? "\e[35;1m" : "")
#define DCYAN_LIGHT   (g_color ? "\e[96m" : "")
#define DYELLOW_LIGHT (g_color ? "\e[93m" : "")
#define DSTRONG_RED   (g_color ? "\e[31;4m" : "")
#define DLIGHT_BLUE  (g_color ? "\e[94m" : "")
#define DCOLOR_END  (g_color ? "\e[0m" : "")
#define DMETHOD_COLOR DCYAN
#define DPUNC_COLOR DGRAY
#define DPARAM_COLOR DYELLOW


#if __has_feature(ptrauth_calls)
#define DO_SIGN(X) (void*)__builtin_ptrauth_sign_unauthenticated((X), ptrauth_key_asia, 0)
#define DO_PROC_SIGN(X) (void*)__builtin_ptrauth_sign_unauthenticated((X), ptrauth_key_asib, 0)
#define DO_STRIP(X) X = (__typeof__((X)))ptrauth_strip((void*)(X), 0);
#define DO_STRIP_OBJC(X)  X = (__bridge id)ptrauth_strip((__bridge void*)(X), 0);
#else
#define DO_SIGN(X) (X)
#define DO_PROC_SIGN(X) (X)
#define DO_STRIP(X)
#define DO_STRIP_OBJC(X)
#endif



/*********************************************************************/
# pragma mark - dyld declarations -
/*********************************************************************/

typedef struct dyld_shared_cache_s*         dyld_shared_cache_t;
typedef struct dyld_image_s*                dyld_image_t;

// Exists in Mac OS X 10.6 and later
extern __attribute__((weak)) const char* dyld_image_path_containing_address(const void* addr);

// DYLD_MACOS_12_ALIGNED_SPI
extern __attribute__((weak)) void dyld_shared_cache_for_each_image(dyld_shared_cache_t cache, void (^block)(dyld_image_t image));

// Exists in Mac OS X 10.11 and later
extern __attribute__((weak)) const char* dyld_shared_cache_file_path(void);

// DYLD_MACOS_12_ALIGNED_SPI
extern __attribute__((weak)) bool dyld_shared_cache_for_file(const char* filePath, void (^block)(dyld_shared_cache_t cache));

// DYLD_MACOS_12_ALIGNED_SPI
const char* my_dyld_image_get_installname(dyld_image_t image);

// Exists in Mac OS X 10.11 and later
extern __attribute__((weak)) const struct mach_header* dyld_image_header_containing_address(const void* addr);



/*********************************************************************/
# pragma mark - struct declarations / globals -
/*********************************************************************/

/// For unwinding stack frames in an exception handler
struct fp_ptr {
    struct fp_ptr *next;
    void* address;
};

/// mig generated structs
#pragma pack(push, 4)
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t thread;
    mach_msg_port_descriptor_t task;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    exception_type_t exception;
    mach_msg_type_number_t codeCnt;
    int64_t code[2];
} exc_req;

typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} exc_resp;
#pragma pack(pop)

void* strip_pac(void* addr);

extern bool g_use_exc;
#define USE_EXECPTION_HANDLER() g_use_exc
#endif /* misc_h */

```

`dynadump/objc.h`:

```h
//
//  objc.h
//  dynadump
//
//  Created by Derek Selander on 5/29/24.
//

#ifndef objc_h
#define objc_h

#import <stdio.h>
#import "misc.h"

void dump_all_objc_classes(bool do_classlist, const char *path, const struct mach_header_64* header_pac);

void dump_objc_protocol_info(Protocol *p);

void dump_objc_class_info(Class cls);
int get_object_type_description(const char *typeEncoding, char *buffer);
void dump_method_description_constrained_to_header(id instanceOrCls, struct mach_header_64 *header);
#endif /* objc_h */

```

`dynadump/objc.m`:

```m
//
//  objc.c
//  dynadump
//
//  Created by Derek Selander on 5/29/24.
//

@import Foundation;
@import MachO;
@import ObjectiveC;
#import  "objc.h"

extern Class objc_opt_class(id _Nullable obj);

/*********************************************************************/
# pragma mark - private -
/*********************************************************************/
__attribute__((always_inline))
static uintptr_t get_cls_isa(Class cls) {
    if (!cls) {
        return 0;
    }
    uintptr_t *isa_packed =  (__bridge void*)cls;
    uintptr_t isa = (*isa_packed) & ISA_MASK;
    return (uintptr_t)strip_pac((void*)isa);
}

static 
void extract_and_print_method(Method method, const char *name, uintptr_t image_start, BOOL isClassMethod, BOOL pretendMethod) {
    char buffer[GOOD_E_NUFF_BUFSIZE];
    buffer[0] = '\0';
#if __has_feature(ptrauth_calls)
    if (pretendMethod) {
        method = ptrauth_sign_unauthenticated(method, ptrauth_key_process_dependent_data,  ptrauth_string_discriminator("method_t"));
    }
#endif
    const char* returnType = method_copyReturnType(method);
    if (get_object_type_description(returnType, buffer)) {
        log_error("\nerror!\n failed to parse \"%s\"", returnType);
    }
    free((void*)returnType);
    
    // ugly hack eeeeeeeeeeek
    // pretendMethod means the method param is actually a objc_method_description* that
    // is masquerading as a Method_t. objc_method_description are missing the IMP, but are
    // identical to a "large" Method_t. So... if we ignore any IMP APIs, we get the same
    // helpful APIs for pulling out type encodings
    
    if (g_verbose && !pretendMethod) {
        uintptr_t implementation = (uintptr_t)strip_pac((void*)method_getImplementation(method));
        log_out( "  %s/* +0x%08lx 0x%016lx %s */%s", DGRAY, implementation - image_start, implementation, name, DCOLOR_END);
    }
    
    log_out("  %s%c(%s%s%s%s%s)%s", DGRAY, isClassMethod ? '+' : '-', DCOLOR_END, DPARAM_COLOR, buffer, DCOLOR_END, DPUNC_COLOR, DCOLOR_END);
    const char* method_name = sel_getName(method_getName(method));
    char *cur_param = strchr(method_name, ':');
    if (cur_param) {
        char *prev_param = (char*)method_name;
        int index = 0;
        char tmp[GOOD_E_NUFF_BUFSIZE];
        do {
            log_out( "%s%.*s:%s",  DMETHOD_COLOR, (int)(cur_param - prev_param), prev_param, DCOLOR_END);
            // method_copyArgumentType 0 == self, 1 == SEL, 2... actual methods
            char *argType = method_copyArgumentType(method, index + 2);
            if (get_object_type_description(argType, tmp)) {
                log_error("\nerror!\n failed to parse \"%s\"", argType);
            }
            free(argType);
            // printts a type and param ie. (id)a2
            log_out( "%s(%s%s%s%s%s)%s%sa%d%s", DGRAY, DCOLOR_END, DPARAM_COLOR, tmp, DCOLOR_END, DGRAY, DCOLOR_END, DGRAY, index + 1, DCOLOR_END);
            prev_param = cur_param + 1;
            cur_param = strchr(cur_param + 1, ':');
            
            if (cur_param) {
                log_out( " ");
            }
            index++;
        } while (cur_param);
        log_out( "%s;%s\n", DPUNC_COLOR, DCOLOR_END);
    } else {
        log_out( "%s%s%s%s;%s\n", DMETHOD_COLOR, method_name, DCOLOR_END, DPUNC_COLOR, DCOLOR_END);
    }
}

#define append_comma_if_needed() if (attributeCount > 1 &&  i > 1) { append_content(", ") }
static
int get_property_description(objc_property_t *property, char *buffer) {
    uint buff_offset = 0;
    unsigned int attributeCount = 0;
    objc_property_attribute_t *attributes = property_copyAttributeList(*property, &attributeCount);
    
    append_content("%s@property ", DGREEN);
    if (attributeCount >= 2) {
        append_content("(")
    }
    for (int i = attributeCount - 1; i >= 0; i--) {
        const char *name = attributes[i].name;
        
        if (i == 0 && attributeCount >= 2) {
            append_content(")%s ", DCOLOR_END);
        }
        if (!strcmp(name, "R")) {
            append_content("readonly");
            append_comma_if_needed();
        } else if (!strcmp(name, "C")) {
            append_content("copy");
            append_comma_if_needed();
        } else if (!strcmp(name, "&")) {
            append_content("retain");
            append_comma_if_needed();
        } else if (!strcmp(name, "N")) {
            append_content("nonatomic");
            append_comma_if_needed();
        } else if (!strcmp(name, "G")) {
            append_content("getter=%s", &name[2]);
            append_comma_if_needed();
        } else if (!strcmp(name, "S")) {
            append_content("setter=%s", &name[2]);
            append_comma_if_needed();
        } else if (!strcmp(name, "D")) {
            append_content("assign");
            append_comma_if_needed();
        } else if (!strcmp(name, "W")) {
            append_content("weak");
            append_comma_if_needed();
        } else if (!strcmp(name, "T")) {
            char tmp[GOOD_E_NUFF_BUFSIZE];
            get_object_type_description(attributes->value, tmp);
            append_content("%s%s%s ", DRED, tmp, DCOLOR_END);
        } else if (!strcmp(name, "V")) {
            // Ignore this one, it's called a 'oneway'
        } else {
            log_debug("/*  %d TODO DEREK S */ %s", __LINE__, &name[0])
        }
        
    }
    append_content("%s%s%s;\n", DBOLD, property_getName(*property), DCOLOR_END);
    free(attributes);
    return 0;
}

/*********************************************************************/
# pragma mark - public -
/*********************************************************************/

int get_object_type_description(const char *typeEncoding, char *buffer) {
    int buff_offset = 0;
    if (!typeEncoding) {
        do_copy_n_return("void*");
    }
    
    if (!strcmp(typeEncoding, "@")) {
        do_copy_n_return("id");
    } else if (!strcmp(typeEncoding, "v")) {
        do_copy_n_return("void");
    } else if (!strcmp(typeEncoding, "^v")) {
        do_copy_n_return("void*");
    } else if (!strcmp(typeEncoding, ":")) {
        do_copy_n_return("SEL");
    } else if (!strcmp(typeEncoding, "B")) { // TODO there are 2 of these? B/b
        do_copy_n_return("BOOL");
    } else if (!strcmp(typeEncoding, "b")) {
        do_copy_n_return("BOOL");
    }  else if (!strcmp(typeEncoding, "c")) {
        do_copy_n_return("char");
    } else  if (!strcmp(typeEncoding, "i")) {
        do_copy_n_return("int");
    } else if (!strcmp(typeEncoding, "s")) {
        do_copy_n_return("short");
    } else if (!strcmp(typeEncoding, "q")) {
        do_copy_n_return("long");
    } else if (!strcmp(typeEncoding, "C")){
        do_copy_n_return("unsigned char");
    } else if (!strcmp(typeEncoding, "I")) {
        do_copy_n_return("unsigned int");
    } else if (!strcmp(typeEncoding, "S")) {
        do_copy_n_return("unsigned short");
    } else if (!strcmp(typeEncoding, "Q")) {
        do_copy_n_return("unsigned long");
    } else if (!strcmp(typeEncoding, "f")) {
        do_copy_n_return("float");
    } else if (!strcmp(typeEncoding, "d")) {
        do_copy_n_return("double");
    } else if (!strcmp(typeEncoding, "D")) {
        do_copy_n_return("unsigned double");
    } else if (!strcmp(typeEncoding, "*")) {
        do_copy_n_return("char*");
    } else if (!strcmp(typeEncoding, "#")) {
        do_copy_n_return("Class");
    } else if (!strcmp(typeEncoding, "@?")) {
        do_copy_n_return("id /*^block*/");
    }
    
    size_t len = strlen(typeEncoding);
    
    // Normal C struct type {_NSZone=}  >>> NSZone*
    if (typeEncoding[0] == '{' && len >= 4 && typeEncoding[len -1] == '}') {
        if (g_verbose) { // print the complete struct if verbose else just the first name
            snprintf(buffer, GOOD_E_NUFF_BUFSIZE, "struct %.*s", (int)(len - 3), &typeEncoding[1]);
        } else {
            char* found = strchr(&typeEncoding[1], '=');
            snprintf(buffer, GOOD_E_NUFF_BUFSIZE, "struct %.*s", (int)(len - ((char*)&typeEncoding[1] - found)), &typeEncoding[1]);
        }
        return 0;
    }
    
    // handle objc instance @"some_objc_here"
    if (typeEncoding[0] == '@' && len >= 4) {
        if (typeEncoding[2] == '<') {
            snprintf(buffer, GOOD_E_NUFF_BUFSIZE, "id%.*s", (int)(len - 3), &typeEncoding[2]);
            return 0;
        }
        snprintf(buffer, GOOD_E_NUFF_BUFSIZE, "%.*s*", (int)(len - 3), &typeEncoding[2]);
        return 0;
    }
    
    // handle pointers
    if (typeEncoding[0] == '^') {
        if (len > 1) {
            char tmp[GOOD_E_NUFF_BUFSIZE];
            get_object_type_description(&typeEncoding[1], tmp);
            append_content("%s*", tmp);
            return 0;
        }
        return 1;
    }
    if ( len >= 2 )
    {
        if (typeEncoding[0] <= 'm')
        {
            switch (typeEncoding[0])
            {
                case 'N':
                    append_content("inout ");
                    break;
                case 'O':
                    append_content("bycopy ");
                    break;
                case 'R':
                    append_content("byref ");
                    break;
                case 'V':
                    append_content("oneway ");
                    break;
                default:
                    do_copy_n_return(typeEncoding);
            }
            
            get_object_type_description(&typeEncoding[1], buffer + buff_offset);
            return 0;
        }
        switch (typeEncoding[0])
        {
            case 'r':
                append_content("const ");
                break;
            case 'o':
                append_content("out ");
                break;
            case 'n':
                append_content("in ");
                break;
        }
        get_object_type_description(&typeEncoding[1], buffer + buff_offset);
        return 0;
    }
    return 1;
}

//bool ptr_is_block_class(uintptr_t ptr) {
//    static uintptr_t block_classes[6] = {};
//    if (!block_classes[0]) {
//        block_classes[0] = (uintptr_t)objc_getClass("__NSStackBlock__");
//        block_classes[1] = (uintptr_t)objc_getClass("__NSMallocBlock__");
//        block_classes[2] = (uintptr_t)objc_getClass("__NSAutoBlock__");
//        block_classes[3] = (uintptr_t)objc_getClass("__NSFinalizingBlock__");
//        block_classes[4] = (uintptr_t)objc_getClass("__NSGlobalBlock__");
//        block_classes[5] = (uintptr_t)objc_getClass("__NSBlockVariable__");
//    };
//    // ~7 needed because isa's can pack bits AND have ptrauth
//    uintptr_t resolved = (uintptr_t)ptrauth_strip((void*)ptr, ptrauth_key_objc_isa_pointer) & ~7LL;
//    for (int i = 0; i < sizeof(block_classes)/sizeof(void*); i++) {
//        if (resolved == block_classes[i]) {
//            return true;
//        }
//    }
//    return false;
//}

void dump_all_objc_classes(bool do_classlist, const char *path, const struct mach_header_64* header_pac) {
    
    struct mach_header_64 *header = strip_pac((void*)header_pac);
    // if we have the mach header we don't have to iterate all classes
    if (header) {
        unsigned long size = 0;
        const char *segments[] = { "__DATA", "__DATA_CONST"};
        for (int z = 0; z < 2; z++) {
            // dirty knowledge of the layout but we need the protocol names
            struct objc_protocol_t {
                uintptr_t isa;
                const char* name;
                //.. more, but whatever
            };
            size = 0;
            if (!do_classlist) {
                struct objc_protocol_t** protocols = (void*)getsectiondata(header, segments[z], "__objc_protolist", &size);
                for (int i = 0; i < (size / sizeof(uintptr_t)); i++) {
                    struct objc_protocol_t *prot = protocols[i];
                    if (prot->name) {
                        Protocol *p = objc_getProtocol(prot->name);
                        if (!p) {
                            continue;
                        }
                        dump_objc_protocol_info(p);
                        log_out("\n");
                    }
                }
            }
        }
     
        // at runtime all implementations are realized so we'll capture all classes
        // and if there's a category that references the class, we'll note it.
        // if the class hasn't been dumped at the category stage, we'll dump it there
        NSMutableSet <Class>*classSet = [NSMutableSet set];
        for (int z = 0; z < 2; z++) {
            size = 0;
            Class *classes = (__unsafe_unretained Class*)(void*)getsectiondata(header, segments[z], "__objc_classlist", &size);
            for (int i = 0; i < size / sizeof(uintptr_t); i++) {
                Class cls = classes[i];
                if (class_respondsToSelector(cls, @selector(doesNotRecognizeSelector:))) {
                    [classSet addObject:cls];
                } else {
                    log_error("non-NSObject root class, \"%s\", skipping\n", class_getName(cls));
                    continue;
                }
                if (do_classlist) {
                    Class supercls =  class_getSuperclass(cls);
                    log_out("%s0x%016lx%s %s%s%s : %s%s%s\n", DGRAY, (uintptr_t)cls, DCOLOR_END, DYELLOW, class_getName(cls), DCOLOR_END, DGREEN, class_getName(supercls), DCOLOR_END);
                } else {
                    dump_objc_class_info(cls);
                }
            }
        }
        
        if (!do_classlist) {
            for (int z = 0; z < 2; z++) {
                size = 0;
                
                // Internal header eeeeeeeeek, but no APIs for categories : [
                struct category_t {
                    const char *name;
                    Class cls;
                    void* instanceMethods;
                    void* classMethods;
                    struct protocol_list_t *protocols;
                    struct property_list_t *instanceProperties;
                    // Fields below this point are not always present on disk.
                    struct property_list_t *_classProperties;
                };
                struct category_t **categories = (struct category_t**)getsectiondata(header, segments[z], "__objc_catlist", &size);
                for (int i = 0; i < size / sizeof(uintptr_t); i++) {
                    struct category_t *cat = categories[i];
                    // TODO: not quite accurate, think of a better way of describing this to user, objc categories don't have the APIs to show which category they
                    // are coming from, so check if we've printed the cls already or see if
                    // they are in the same image as we're inspecting
                    if (![classSet containsObject:cat->cls]) {
                        log_out("%s@interface%s %s%s (%s) %s// category%s\n", DMAGENTA, DCOLOR_END, DYELLOW, class_getName(cat->cls), cat->name, DGRAY, DCOLOR_END);
                        if (dyld_image_header_containing_address((__bridge const void *)(cat->cls)) != (void*)header) {
                            log_out("%s// category for %s, which is declared in \"%s\"%s\n", DRED, class_getName(cat->cls), dyld_image_path_containing_address((__bridge const void *)(cat->cls)), DCOLOR_END);
                        }
                        dump_method_description_constrained_to_header(cat->cls, (void*)header_pac);
                    } else {
                        log_out("%s@interface%s %s%s (%s) %s// category%s\n", DMAGENTA, DCOLOR_END, DYELLOW, class_getName(cat->cls), cat->name, DGRAY, DCOLOR_END);
                        log_out("%s@end%s\n", DYELLOW, DCOLOR_END);
                    }
                }
            }
        }
        
    } else { // plan B is to just load everything and dump it
        
        log_out("// Couldn't find header, dumping everything\n");
        unsigned int count = 0;
        Class *classes = objc_copyClassList(&count);
        
        log_debug("found %d classes...\n", count);
        for (int i = 0; i < count; i++) {
            Class cls = classes[i];
            void* isa = (void*)get_cls_isa(cls);
            const char * curpath = dyld_image_path_containing_address(isa);
            log_debug("%s %s\n", class_getName(cls),  curpath);
            if (!curpath) {
                continue;
            }
            if (strcmp(curpath, path)) {
                continue;
            }
            
            if (do_classlist) {
                Class supercls = class_getSuperclass(cls);
                log_out("%s0x%016lx%s %s%s%s : %s%s%s\n", DGRAY, (uintptr_t)cls, DCOLOR_END, DYELLOW, class_getName(cls), DCOLOR_END, DGREEN, class_getName(supercls), DCOLOR_END);
            } else {
                dump_objc_class_info(cls);
            }
        }
    }
}


void dump_objc_protocol_info(Protocol *p) {
    unsigned int count = 0;
    struct objc_method_description *descriptions = NULL;
    if (!p) {
        return;
    }
    Protocol *prot = (__bridge Protocol*)strip_pac((__bridge void *)(p));
    const char* name = protocol_getName(prot);
    log_out("  %s@protocol %s%s", DYELLOW_LIGHT, name, DCOLOR_END);
    log_out_verbose(" %s// 0x%012lx%s", DGRAY, (uintptr_t)prot, DCOLOR_END);
    log_out("\n");
    
    // required class
    descriptions = protocol_copyMethodDescriptionList(prot, YES, NO,  &count);
    for (uint i = 0; i < count; i++) {
        struct objc_method_description *desc = &descriptions[i];
        extract_and_print_method((Method)desc, name, 0, YES, YES);
    }
    free(descriptions);
    count = 0;
    
    // required instance
    descriptions = protocol_copyMethodDescriptionList(prot, YES, YES,  &count);
    for (uint i = 0; i < count; i++) {
        struct objc_method_description *desc = &descriptions[i];
        // we are cheating to pretend it's a method which ptrauth doesn't like so....
        extract_and_print_method((Method)desc, name, 0, NO, YES);
    }
    free(descriptions);
    count = 0;
    
    // optional class
    descriptions = protocol_copyMethodDescriptionList(prot, NO, NO, &count);
    bool did_print_optional = false;
    if (count) {
        did_print_optional = true;
        log_out("  %s@optional%s\n", DYELLOW_LIGHT, DCOLOR_END);
    }
    for (uint i = 0; i < count; i++) {
        struct objc_method_description *desc = &descriptions[i];
        extract_and_print_method((Method)desc, name, 0, YES, YES);
    }
    free(descriptions);
    count = 0;
    
    // optional instance
    descriptions = protocol_copyMethodDescriptionList(prot, NO, YES, &count);
    if (count && did_print_optional == false) {
        log_out("  %s@optional%s\n", DYELLOW_LIGHT, DCOLOR_END);
    }
    for (uint i = 0; i < count; i++) {
        struct objc_method_description *desc = &descriptions[i];
        extract_and_print_method((Method)desc, name, 0, NO, YES);
    }
    log_out("  %s@end%s\n", DYELLOW_LIGHT, DCOLOR_END);
    
}

static void _dump_ivar_description(id instanceOrCls, bool standaloneDescription) {
    const char *imagePath = dyld_image_path_containing_address((__bridge const void * _Nonnull)(instanceOrCls));
    Class cls = objc_opt_class(instanceOrCls);
    bool isClass = (instanceOrCls == cls) ? true: false;
    unsigned int ivarCount = 0;
    if (standaloneDescription) {
        if (isClass) {
            log_out("%s", class_getName(cls));
        } else {
            log_out("%s <%p>", class_getName(cls), instanceOrCls);
        }
        
        Class superCls = class_getSuperclass(cls);
        if (superCls) {
            log_out(": %s ", class_getName(superCls));
        }
        if (imagePath) {
            log_out(" %s(%s)%s\n", DYELLOW_LIGHT, imagePath, DCOLOR_END);
        } else {
            log_out(" %s(?)%s\n", DYELLOW_LIGHT, DCOLOR_END);
        }
    }
    Ivar *ivars = class_copyIvarList(cls, &ivarCount);
    if (ivarCount) {
        log_out("\n {\n");
    }
    for (uint i = 0; i < ivarCount; i++) {
        const char *typeEncoding = ivar_getTypeEncoding(ivars[i]);
        typeEncoding = typeEncoding ? typeEncoding : "";
        const char *name = ivar_getName(ivars[i]);
        long int offset = ivar_getOffset(ivars[i]);
        char buffer[GOOD_E_NUFF_BUFSIZE];
        get_object_type_description(typeEncoding, buffer);
        if (isClass) {
            log_out("  %s/* +0x%04lx */%s  %s%s%s %s%s%s\n", DGRAY, offset, DCOLOR_END, DCYAN_LIGHT, buffer, DCOLOR_END, DCYAN, name, DCOLOR_END);
        } else {
            log_out("  %s/* +0x%04lx 0x%016lx */%s  %s%s%s %s%s%s \n", DGRAY, offset,  *(uintptr_t*)((uintptr_t)instanceOrCls + offset), DCOLOR_END, DCYAN_LIGHT, buffer, DCOLOR_END, DCYAN, name, DCOLOR_END);
        }
    }
    free(ivars);
    if (ivarCount) {
        log_out(" }\n");
    }
}

void dump_ivar_description(id instanceOrCls) {
    _dump_ivar_description(instanceOrCls, true);
}

void dump_method_description_constrained_to_header(id instanceOrCls, struct mach_header_64 *header) {
    Class cls = objc_opt_class(instanceOrCls);
    const char* clsName = class_getName(cls);
    unsigned int metaMethodCount = 0;
    Class metaCls = objc_getMetaClass(clsName);
    Class superCls = class_getSuperclass(cls);
    bool has_done_newline = false;
    uintptr_t image_start = (uintptr_t)dyld_image_header_containing_address((__bridge const void * _Nonnull)(cls));
    
    // if we have a header then likely means we are dealing with a category
    if (!header) {
        
        if (!superCls) {
            log_out( "%sNS_ROOT_CLASS%s ", DYELLOW, DCOLOR_END);
        }
        log_out( "%s@interface%s %s%s%s ", DMAGENTA, DCOLOR_END, DYELLOW, clsName, DCOLOR_END);
        
        // superclass
        if (superCls) {
            const char* superClsName = class_getName(superCls);
            if (superClsName) {
                log_out( "%s: %s%s ", DYELLOW, superClsName, DCOLOR_END);
            }
        }
        
        // protocols
        unsigned int cnt = 0;
        Protocol * __unsafe_unretained _Nonnull * _Nullable protocols = class_copyProtocolList(cls, &cnt);
        for (int i = 0; i< cnt; i++) {
            if (i == 0) {
                log_out("%s<", DGREEN)
            }
            log_out("%s", protocol_getName(protocols[i]));
            if (cnt > 1 && i < cnt - 1) {
                log_out(", ")
            }
            
            if (i == cnt - 1) {
                log_out(">%s", DCOLOR_END);
            }
        }
        if (protocols) {
            free((void*)protocols);
        }
        
        // ivars
        _dump_ivar_description(cls, false);
        
        // Properties
        unsigned int propertyCount = 0;
        objc_property_t *properties = class_copyPropertyList(cls, &propertyCount);
        if (propertyCount) {
            log_out( "\n\n  %s// \"%s\" properties:%s\n", DGRAY, clsName, DCOLOR_END);
            has_done_newline = true;
        }
        for (uint i = 0; i < propertyCount; i++) {
            char buffer[GOOD_E_NUFF_BUFSIZE];
            if (get_property_description(&properties[i], buffer)) {
                log_error(  "\nfailed to parse \"%s\"", property_getName(properties[i]));
            }
            log_out( "  %s", buffer);
        }
        free(properties);
        if (propertyCount) {
            log_out( "\n");
        }
    }
    
    // Class methods
    if (metaCls) {
        Method *clsMethods = class_copyMethodList(metaCls, &metaMethodCount);
        if (!header) {
            if (has_done_newline == false) {
                has_done_newline = true;
                log_out("\n\n");
            }
            if (metaMethodCount) {
                log_out( "  %s// \"%s\" class methods:%s\n", DGRAY, clsName, DCOLOR_END);
            }
        }
        for (uint i = 0; i < metaMethodCount; i++) {
            if (header) {
                IMP implementation = method_getImplementation(clsMethods[i]);
                if (dyld_image_header_containing_address(implementation) != (void*)header) {
                    continue;
                }
            }
            extract_and_print_method(clsMethods[i], clsName, image_start, YES, NO);
        }
        if (metaMethodCount) {
            log_out( "\n");
        }
        free(clsMethods);
    }
    
    // Instance methods
    if (cls) {
        unsigned int methodCount = 0;
        Method *instanceMethods = class_copyMethodList(cls, &methodCount);
        if (!header) {
            if (has_done_newline == false) {
                log_out("\n\n");
                has_done_newline = true;
            }
            if (methodCount) {
                log_out( "  %s// \"%s\" instance methods:%s\n", DGRAY, clsName, DCOLOR_END);
            }
        }
        for (uint i = 0; i < methodCount; i++) {
            if (header) {
                IMP implementation = method_getImplementation(instanceMethods[i]);
                if (dyld_image_header_containing_address(implementation) != (void*)header) {
                    continue;
                }
            }
            extract_and_print_method(instanceMethods[i], clsName, header ? header : image_start, NO, NO);
        }
        free(instanceMethods);
    }
    if (has_done_newline) {
        log_out("\n");
    }
    
    log_out( "%s@end%s\n\n", DYELLOW, DCOLOR_END);
    log_debug("leaving %s:%d\n", __FUNCTION__, __LINE__);
    
}

DYNAMIC_DUMP_VISIBILITY
void dump_method_description(id instanceOrCls) {
    dump_method_description_constrained_to_header(instanceOrCls, NULL);
}

void dump_objc_class_info(Class cls) {
    uintptr_t isa = get_cls_isa(cls);
    const char* path = dyld_image_path_containing_address((const void*)isa);
    log_out("%s//> %s %s%s\n", DGRAY, class_getName(cls), path, DCOLOR_END);
    dump_method_description(cls);
}


```