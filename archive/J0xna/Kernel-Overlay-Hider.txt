Project Path: arc_J0xna_Kernel-Overlay-Hider_y6303pjm

Source Tree:

```txt
arc_J0xna_Kernel-Overlay-Hider_y6303pjm
├── EnumWindows_TEST
│   ├── EnumWindows_TEST.vcxproj
│   ├── EnumWindows_TEST.vcxproj.filters
│   └── main.cpp
├── README.md
├── dkom_overlay
│   ├── dkom_overlay.inf
│   ├── dkom_overlay.vcxproj
│   ├── dkom_overlay.vcxproj.filters
│   ├── entry.cpp
│   ├── includes.h
│   ├── skcrypt.h
│   ├── structs.h
│   └── util.h
├── dkom_overlay.sln
└── usermode
    ├── main.cpp
    ├── usermode.vcxproj
    └── usermode.vcxproj.filters

```

`EnumWindows_TEST/EnumWindows_TEST.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{100ec34c-1c55-4261-90df-c84114571066}</ProjectGuid>
    <RootNamespace>EnumWindowsTEST</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EnumWindows_TEST/EnumWindows_TEST.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EnumWindows_TEST/main.cpp`:

```cpp
#include <iostream>
#include <Windows.h>

BOOL CALLBACK EnumWindowsProc(HWND hWnd, long lParam) {
    char buff[255];

    if (IsWindowVisible(hWnd)) {
        GetWindowTextA(hWnd, buff, 64);
        printf("%s\n", buff);
    }
    return TRUE;
}

int main() {
    EnumWindows((WNDENUMPROC)EnumWindowsProc, 0);
    std::cin.get( );
    return 0;
}
```

`README.md`:

```md
A cursed PoC of hiding the overlay handle from TAGWND linked list.

```

`dkom_overlay.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dkom_overlay", "dkom_overlay\dkom_overlay.vcxproj", "{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "usermode", "usermode\usermode.vcxproj", "{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EnumWindows_TEST", "EnumWindows_TEST\EnumWindows_TEST.vcxproj", "{100EC34C-1C55-4261-90DF-C84114571066}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|ARM64.Build.0 = Debug|ARM64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|x64.ActiveCfg = Debug|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|x64.Build.0 = Debug|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|x64.Deploy.0 = Debug|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|x86.ActiveCfg = Debug|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|x86.Build.0 = Debug|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Debug|x86.Deploy.0 = Debug|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|ARM64.ActiveCfg = Release|ARM64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|ARM64.Build.0 = Release|ARM64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|ARM64.Deploy.0 = Release|ARM64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|x64.ActiveCfg = Release|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|x64.Build.0 = Release|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|x64.Deploy.0 = Release|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|x86.ActiveCfg = Release|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|x86.Build.0 = Release|x64
		{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}.Release|x86.Deploy.0 = Release|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Debug|ARM64.ActiveCfg = Debug|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Debug|ARM64.Build.0 = Debug|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Debug|x64.ActiveCfg = Debug|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Debug|x64.Build.0 = Debug|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Debug|x86.ActiveCfg = Debug|Win32
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Debug|x86.Build.0 = Debug|Win32
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Release|ARM64.ActiveCfg = Release|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Release|ARM64.Build.0 = Release|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Release|x64.ActiveCfg = Release|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Release|x64.Build.0 = Release|x64
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Release|x86.ActiveCfg = Release|Win32
		{FCF73A40-41D6-41D7-B018-FC15E6FFED9E}.Release|x86.Build.0 = Release|Win32
		{100EC34C-1C55-4261-90DF-C84114571066}.Debug|ARM64.ActiveCfg = Debug|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Debug|ARM64.Build.0 = Debug|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Debug|x64.ActiveCfg = Debug|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Debug|x64.Build.0 = Debug|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Debug|x86.ActiveCfg = Debug|Win32
		{100EC34C-1C55-4261-90DF-C84114571066}.Debug|x86.Build.0 = Debug|Win32
		{100EC34C-1C55-4261-90DF-C84114571066}.Release|ARM64.ActiveCfg = Release|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Release|ARM64.Build.0 = Release|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Release|x64.ActiveCfg = Release|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Release|x64.Build.0 = Release|x64
		{100EC34C-1C55-4261-90DF-C84114571066}.Release|x86.ActiveCfg = Release|Win32
		{100EC34C-1C55-4261-90DF-C84114571066}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1A2301AC-44C4-452E-B3CC-E687AD35B879}
	EndGlobalSection
EndGlobal

```

`dkom_overlay/dkom_overlay.inf`:

```inf
;
; dkom_overlay.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=dkom_overlay.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
dkom_overlay_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
dkom_overlay.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%dkom_overlay.DeviceDesc%=dkom_overlay_Device, Root\dkom_overlay ; TODO: edit hw-id

[dkom_overlay_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
dkom_overlay.sys

;-------------- Service installation
[dkom_overlay_Device.NT.Services]
AddService = dkom_overlay,%SPSVCINST_ASSOCSERVICE%, dkom_overlay_Service_Inst

; -------------- dkom_overlay driver install sections
[dkom_overlay_Service_Inst]
DisplayName    = %dkom_overlay.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\dkom_overlay.sys

;
;--- dkom_overlay_Device Coinstaller installation ------
;

[dkom_overlay_Device.NT.CoInstallers]
AddReg=dkom_overlay_Device_CoInstaller_AddReg
CopyFiles=dkom_overlay_Device_CoInstaller_CopyFiles

[dkom_overlay_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[dkom_overlay_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[dkom_overlay_Device.NT.Wdf]
KmdfService =  dkom_overlay, dkom_overlay_wdfsect
[dkom_overlay_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "dkom_overlay Installation Disk"
dkom_overlay.DeviceDesc = "dkom_overlay Device"
dkom_overlay.SVCDESC = "dkom_overlay Service"

```

`dkom_overlay/dkom_overlay.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2C5CDDFA-7AFE-4D1B-A427-B03F24B7D46B}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>dkom_overlay</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>driver</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>entry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_DEBUG;_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>entry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="dkom_overlay.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h" />
    <ClInclude Include="skcrypt.h" />
    <ClInclude Include="structs.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`dkom_overlay/dkom_overlay.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="dkom_overlay.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="skcrypt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`dkom_overlay/entry.cpp`:

```cpp
#include "includes.h"
#include "util.h"

#define rva(addr, size)((PBYTE)(addr + *(DWORD*)(addr + ((size) - 4)) + size))

// .data ptr signature 48 8B 05 FD 6F 05 ? 48 85 C0 ( NtMITPostWindowEventMessage )
std::int64_t (__fastcall* orig_callback)(void*, void*) = nullptr;

struct comms_t {
	std::uint32_t key;

	struct {
		void* handle;
	}window;
};

bool handle_overlay( comms_t* ptr ) {
	if ( !ptr->window.handle ) {
		log_e( "passed hwnd invalid...\n" );
		return false;
	}

	/* 
	Exposing TAG_WND structure pointer of our hwnd
	Note: If you're calling this export from a thread without Win32StartAddress, it will not work. 
	Solutions: Attach to a process with a win32thread, dkom the win32startaddress of the target to your thread's win32startaddress.
	*/

	static const auto validate_hwnd = util::module_t::win32k_base->get_export< TAG_WND* ( * )( void* ) >( _( "ValidateHwnd" ) );

	if ( !validate_hwnd ) {
		log_e( "couldn't find validate_hwnd...\n" );
		return false;
	}

	// Validating the kernel window handle
	const auto our_wnd = validate_hwnd( ptr->window.handle );

	if ( !our_wnd ) {
		log_e( "failed to obtain our window instance...\n" );
		return false;
	}

	// Sanity check to avoid Blue Screen of Death.
	if ( our_wnd != our_wnd->prev->next || our_wnd != our_wnd->next->prev ) {
		log_e( "TAG_WND structure outdated, check offsets with bruteforcer above!\n" );
		return false;
	}

	if ( !( our_wnd->prev->next = our_wnd->next ) || !( our_wnd->next->prev = our_wnd->prev ) ) {
		log_e( "something went really really wrong...\n" );
		return false;
	}

	log_s( "overlay handled successfully!\n" );

	return true;
}

std::int64_t callback( comms_t* a1, void* a2 ) {
	static comms_t buffer = { };
	if ( ExGetPreviousMode( ) != UserMode || !util::memory_t::safe_copy( &buffer, a1, sizeof( comms_t )) || buffer.key != 0xCA ) {
		return orig_callback( a1, a2 );
	}

	handle_overlay( a1 );

	return 0;
}

NTSTATUS entry( ) {

	if ( !util::module_t::init( ) )
		return STATUS_UNSUCCESSFUL;

	const auto ptr = rva( util::module_t::win32k->find_pattern( _( "\x48\x8B\x05\xFD\x6F\x05\x00\x48\x85\xC0" ), _( "xxxxxx?xxx" ) ), 7 );

	if ( !ptr ) {
		log_e( "ptr not found...\n" );
		return STATUS_UNSUCCESSFUL;
	}

	if ( !( *reinterpret_cast< void** >( &orig_callback ) = _InterlockedExchangePointer( reinterpret_cast< void** >( ptr ), callback ) ) ){
		log_e( "swapping pointer failed...\n" );
		return STATUS_UNSUCCESSFUL;
	}

	log_s( "driver initialized!\n" );

	return STATUS_SUCCESS;
}

```

`dkom_overlay/includes.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <ntdef.h>
#include <windef.h>
#include <ntimage.h>
#include <cstdint>
#include <cstddef>
#include <intrin.h>
#include <wingdi.h>
#include <ntstrsafe.h>

#include "skcrypt.h"

#pragma comment(lib, "ntoskrnl.lib")

#ifdef _DEBUG
#define log( s, ... ) DbgPrintEx( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[DEBUG-LOG] " s), __VA_ARGS__ )
#define log_s( s, ... ) DbgPrintEx( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[+] " s), __VA_ARGS__ )
#define log_e( s, ... ) DbgPrintEx( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[-] " s), __VA_ARGS__ )
#define log_w( s, ... ) DbgPrintEx( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[!] " s), __VA_ARGS__ )
#else
#define log( s, ... ) ( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[DEBUG-LOG] " s), __VA_ARGS__ )
#define log_s( s, ... ) ( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[+] " s), __VA_ARGS__ )
#define log_e( s, ... ) ( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[-] " s), __VA_ARGS__ )
#define log_w( s, ... ) ( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, _("[!] " s), __VA_ARGS__ )
#endif
```

`dkom_overlay/skcrypt.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define _(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()
```

`dkom_overlay/structs.h`:

```h
#pragma once
#include "includes.h"

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;  // in bytes
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;  // LDR_*
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    PVOID SectionPointer;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef enum SYSTEM_INFORMATION_CLASS
{
    SystemInformationClassMin = 0,
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemNotImplemented1 = 4,
    SystemProcessInformation = 5,
    SystemProcessesAndThreadsInformation = 5,
    SystemCallCountInfoInformation = 6,
    SystemCallCounts = 6,
    SystemDeviceInformation = 7,
    SystemConfigurationInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemProcessorTimes = 8,
    SystemFlagsInformation = 9,
    SystemGlobalFlag = 9,
    SystemCallTimeInformation = 10,
    SystemNotImplemented2 = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemLockInformation = 12,
    SystemStackTraceInformation = 13,
    SystemNotImplemented3 = 13,
    SystemPagedPoolInformation = 14,
    SystemNotImplemented4 = 14,
    SystemNonPagedPoolInformation = 15,
    SystemNotImplemented5 = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemPagefileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemInstructionEmulationCounts = 19,
    SystemVdmBopInformation = 20,
    SystemInvalidInfoClass1 = 20,
    SystemFileCacheInformation = 21,
    SystemCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemProcessorStatistics = 23,
    SystemDpcBehaviourInformation = 24,
    SystemDpcInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemNotImplemented6 = 25,
    SystemLoadImage = 26,
    SystemUnloadImage = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemTimeAdjustment = 28,
    SystemSummaryMemoryInformation = 29,
    SystemNotImplemented7 = 29,
    SystemNextEventIdInformation = 30,
    SystemNotImplemented8 = 30,
    SystemEventIdsInformation = 31,
    SystemNotImplemented9 = 31,
    SystemCrashDumpInformation = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemLoadAndCallImage = 38,
    SystemPrioritySeparation = 39,
    SystemPlugPlayBusInformation = 40,
    SystemNotImplemented10 = 40,
    SystemDockInformation = 41,
    SystemNotImplemented11 = 41,
    SystemInvalidInfoClass2 = 42,
    SystemProcessorSpeedInformation = 43,
    SystemInvalidInfoClass3 = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemSetTimeSlipEvent = 46,
    SystemCreateSession = 47,
    SystemDeleteSession = 48,
    SystemInvalidInfoClass4 = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemAddVerifier = 52,
    SystemSessionProcessesInformation = 53,
    SystemInformationClassMax
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

// This structure was reversed by my friend and I via bruteforcing.
typedef struct _TAG_WND
{
    char padding_0[0x10];
    struct _TAG_INFO* tag_info;
    char padding_0x0[0x40];
    struct _TAG_WND* next; // 0x58
    struct _TAG_WND* prev; // 0x60
    struct _TAG_WND* parent; // 0x68
    struct _TAG_WND* child; // 0x70
}TAG_WND, * PTAG_WND;
```

`dkom_overlay/util.h`:

```h
#pragma once
#include "includes.h"
#include "structs.h"

extern "C" {
	NTSTATUS 
		WINAPI ZwQuerySystemInformation(
		_In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
		_Inout_   PVOID                    SystemInformation,
		_In_      ULONG                    SystemInformationLength,
		_Out_opt_ PULONG                   ReturnLength
	);
	NTSTATUS
		MmCopyVirtualMemory(
			IN  PEPROCESS FromProcess,
			IN  CONST VOID *FromAddress,
			IN  PEPROCESS ToProcess,
			OUT PVOID ToAddress,
			IN  SIZE_T BufferSize,
			IN  KPROCESSOR_MODE PreviousMode,
			OUT PSIZE_T NumberOfBytesCopied
		);
	NTKERNELAPI
		PVOID
			NTAPI
				RtlFindExportedRoutineByName (
			_In_ PVOID ImageBase,
			_In_ PCCH RoutineNam
		);
}

namespace util
{
	struct string_t {
		static UNICODE_STRING ansi_to_unicode( const char* str ) {
			ANSI_STRING a_str{};
			UNICODE_STRING u_str{};

			RtlInitAnsiString(&a_str, str);
			RtlAnsiStringToUnicodeString(&u_str, &a_str, true);

			return u_str;
		}
	};

	struct system_t {
		template< typename t >
		static t get_routine_address( const char* routine_name ) {
			UNICODE_STRING u_str = string_t::ansi_to_unicode( routine_name );

			return ( t )MmGetSystemRoutineAddress(&u_str);
		}
	};

	struct process_t {
		static inline PEPROCESS e_process = { };

		static PEPROCESS get_e_process( std::int32_t process_id ) {
			PEPROCESS proc = { };

			if ( !NT_SUCCESS( PsLookupProcessByProcessId( reinterpret_cast< HANDLE >( process_id ), &proc ) ) )
				return nullptr;

			return proc;
		}
	};

	struct memory_t {
		static bool safe_copy( void* dst, void* src, size_t size ) {
			size_t bytes = 0; 

			if ( !NT_SUCCESS( MmCopyVirtualMemory( IoGetCurrentProcess( ), src, IoGetCurrentProcess( ), dst, size, KernelMode, &bytes ) ) )
				return false;

			return true;
		}
	};

	struct module_t {
		static inline module_t* ntos = nullptr, *win32k = nullptr, *win32k_base = nullptr;

		static module_t* get_ntos_base( ) {
			const auto idt_base = reinterpret_cast< std::uintptr_t >( KeGetPcr( )->IdtBase );
			auto align_page = *reinterpret_cast< std::uintptr_t* >( idt_base + 4 ) >> 0xc << 0xc;

			for ( ; align_page; align_page -= 0x1000 )
			{
				for ( int index = 0; index < 0x1000 - 0x7; index++ ) {
					const auto current_address = static_cast< std::intptr_t >( align_page ) + index;

					if 
						(
							*reinterpret_cast< std::uint8_t* >( current_address )       ==	0x48 &&
							*reinterpret_cast< std::uint8_t* >( current_address + 0x1 ) ==   0x8d &&
							*reinterpret_cast< std::uint8_t* >( current_address + 0x2 ) ==   0x1d &&
							*reinterpret_cast< std::uint8_t* >( current_address + 0x6 ) ==   0xff
							) 
					{
						const auto nto_base_offset = *reinterpret_cast< int* >( current_address + 0x3 );
						const auto nto_base_ = ( current_address + nto_base_offset + 0x7 );

						if (! ( nto_base_ & 0xfff ) )
							return reinterpret_cast< module_t* >(nto_base_);
					}
				}
			}
			return nullptr;
		}

		static module_t* get_system_module_base( const char* name ) {
			module_t* base = 0;
			ULONG bytes = 0;

			ZwQuerySystemInformation( SystemModuleInformation, 0, bytes, &bytes );

			if ( !bytes ) {
				log_e( "get_system_module_base failed...\n" );
				return nullptr;
			}

			const auto modules = reinterpret_cast< RTL_PROCESS_MODULES* >( ExAllocatePoolWithTag( NonPagedPoolNx, bytes, 'udom' ) );

			if ( !modules )
				return 0;

			if ( !NT_SUCCESS( ZwQuerySystemInformation( SystemModuleInformation, modules, bytes, &bytes ) ) ) {
				ExFreePoolWithTag( modules, 'udom' );
				return 0;
			}

			for ( ULONG i = 0; i < modules->NumberOfModules; i++ ) {
				const auto current_module = modules->Modules[ i ];

				if ( !_stricmp( reinterpret_cast< const char* >( current_module.FullPathName ), name ) ) {
					base = reinterpret_cast< module_t* >( current_module.ImageBase );
					break;
				}
			}

			if ( modules )
				ExFreePoolWithTag( modules, 'udom' );

			return base;
		}

		template< typename t >
		t get_export( char* name ) {
			return ( t )RtlFindExportedRoutineByName( this, name );
		}

		__forceinline std::uint8_t* find_pattern( module_t* _this, std::uint32_t size, const char* pattern, const char* mask ) {
			auto check_mask = [ ]( std::uint8_t* buf, const char* _pattern, const char* _mask ) -> bool {
				for ( std::uint8_t* x = buf; *_mask; _pattern++, _mask++, x++ ) {
					const auto addr = *( std::uint8_t* )( _pattern );

					if ( addr != *x && *_mask != '?' )
						return false;
				}
				return true;
			};

			for ( int i = 0; i < size - strlen( mask ); i++ ) {
				const auto addr = reinterpret_cast< std::uint8_t* >(_this) + i;

				if ( check_mask( addr, pattern, mask ) )
					return addr;
			}
			return nullptr;
		}

		__forceinline std::uint8_t* find_pattern( const char* pattern, const char* mask ) {
			const auto dos = reinterpret_cast< IMAGE_DOS_HEADER* >( this );

			const auto header = reinterpret_cast< IMAGE_NT_HEADERS64* >(reinterpret_cast< std::uintptr_t >( this ) + dos->e_lfanew);

			if ( !header ) {
				log_e( "nt header invalid\n" );
				return nullptr;
			}

			auto section = IMAGE_FIRST_SECTION( header );

			if ( !section ) {
				log_e( "pe section invalid\n" );
				return nullptr;
			}

			for ( int i = 0; i < header->FileHeader.NumberOfSections; i++, section++ ) {
				if ( !memcmp( section->Name, _( ".text" ), 5 ) || !memcmp( section->Name, _( "PAGE" ), 4 ) )
					return find_pattern( reinterpret_cast< module_t* >( this + section->VirtualAddress ), section->Misc.VirtualSize, pattern, mask );
			}
			return nullptr;
		}

		static bool init( ) {
			ntos = get_ntos_base( );

			if ( !ntos ) {
				log_e( "couldn't obtain ntos base...\n" );
				return false;
			}

			win32k = util::module_t::get_system_module_base( _( "\\SystemRoot\\System32\\win32k.sys" ) );

			if ( !win32k ) {
				log_e( "couldn't obtain win32k...\n" );
				return false;
			}

			win32k_base = util::module_t::get_system_module_base( _( "\\SystemRoot\\System32\\win32kbase.sys" ) );

			if ( !win32k_base ) {
				log_e( "couldn't obtain win32kbase...\n" );
				return false;
			}

			log_s( "initialized modules!\n" );

			return true;
		}
	};
}
```

`usermode/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <d3d11.h>
#include <d3dx11.h>
#include <dwmapi.h>

#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dx11.lib")
#pragma comment(lib, "dwmapi.lib")

std::int64_t (__fastcall* kernel_call)(void*, void*) = nullptr;

struct comms_t {
	std::uint32_t key;

	struct {
		void* handle;
	}window;
};

bool init_driver( ) {
	
	// Manually loading user32.dll to avoid stupid exceptions / crashes encountered previously.
	LoadLibraryA("user32.dll");

	const auto mod = LoadLibraryA("win32u.dll");

	if ( !mod )
		return false;

	const auto address = GetProcAddress(mod, "NtMITPostWindowEventMessage");

	if ( !address )
		return false;

	if ( !( *reinterpret_cast< void** >( &kernel_call ) = address ) )
		return false;

	return true;
}

void handle_overlay( HWND hwnd ) {
	comms_t req{};

	req.key = 0xCA;
	req.window.handle = hwnd;

	kernel_call(&req, 0);
}


// CreateWindow stuff
// Data
static ID3D11Device* g_pd3dDevice = NULL;
static ID3D11DeviceContext* g_pd3dDeviceContext = NULL;
static IDXGISwapChain* g_pSwapChain = NULL;
static ID3D11RenderTargetView* g_mainRenderTargetView = NULL;

// Forward declarations of helper functions
bool CreateDeviceD3D(HWND hWnd);
void CleanupDeviceD3D();
void CreateRenderTarget();
void CleanupRenderTarget();
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);



int main( ) {
	if ( !init_driver( ) ) {
		printf( "failed to initialize driver...\n" );
		std::cin.get( );
		return 0;
	}

    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, L"JZ'S TEST_WND", NULL };
    RegisterClassEx(&wc);
    HWND hwnd = CreateWindow(wc.lpszClassName, L"JZ_WND", WS_OVERLAPPEDWINDOW, 100, 100, 400, 200, NULL, NULL, wc.hInstance, NULL);

    if (!CreateDeviceD3D(hwnd)) {
        CleanupDeviceD3D();
        ::UnregisterClass(wc.lpszClassName, wc.hInstance);
        return 1;
    }

    ShowWindow(hwnd, SW_SHOWDEFAULT);
    UpdateWindow(hwnd);

    printf( "press END to spoof overlay!\n" );

    bool done = false;
    while (!done) {
        if( GetAsyncKeyState( VK_END ) ) {
            static bool do_once = false;

            if ( !do_once ) {
                handle_overlay( hwnd );
                do_once = true;
                printf( "overlay handled!\n" );
            }
        }

        MSG msg;
        while (::PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE)) {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
            if (msg.message == WM_QUIT)
                done = true;
        }
        if (done)
            break;

        const float clear_color_with_alpha[4] = { 255, 255, 255, 255 };
        g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);
        g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color_with_alpha);
        g_pSwapChain->Present(1, 0); // Present with vsync
    }

	printf( "overlay should be handled now\n" );

	return 0;
}

bool CreateDeviceD3D(HWND hWnd)
{
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
    if (D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext) != S_OK)
        return false;

    CreateRenderTarget();
    return true;
}

void CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = NULL; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = NULL; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }
}

void CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer;
    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = NULL; }
}


LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_SIZE:
        if (g_pd3dDevice != NULL && wParam != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
            return 0;
        break;
    case WM_DESTROY:
        ::PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProc(hWnd, msg, wParam, lParam);
}
```

`usermode/usermode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{fcf73a40-41d6-41d7-b018-fc15e6ffed9e}</ProjectGuid>
    <RootNamespace>usermode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);$(DXSDK_DIR)Lib\x64</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);$(DXSDK_DIR)Lib\x64</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`usermode/usermode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```