Project Path: arc_cursey_sdkgenny_ap8sio9p

Source Tree:

```txt
arc_cursey_sdkgenny_ap8sio9p
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake.toml
├── cmkr.cmake
├── examples
│   ├── badname.cpp
│   ├── bitfield.cpp
│   ├── car.cpp
│   ├── childstruct.cpp
│   ├── constants.cpp
│   ├── dummydata.cpp
│   ├── generictype.cpp
│   ├── multiple_inheritance.cpp
│   ├── nestedstruct.cpp
│   ├── parser.cpp
│   ├── sdk.cpp
│   ├── typename.cpp
│   └── usage.cpp
├── format.ps1
├── format.sh
├── include
│   ├── sdkgenny
│   │   ├── array.hpp
│   │   ├── class.hpp
│   │   ├── constant.hpp
│   │   ├── detail
│   │   │   └── indent.hpp
│   │   ├── enum.hpp
│   │   ├── enum_class.hpp
│   │   ├── function.hpp
│   │   ├── generic_type.hpp
│   │   ├── namespace.hpp
│   │   ├── object.hpp
│   │   ├── parameter.hpp
│   │   ├── pointer.hpp
│   │   ├── reference.hpp
│   │   ├── sdk.hpp
│   │   ├── static_function.hpp
│   │   ├── struct.hpp
│   │   ├── type.hpp
│   │   ├── typename.hpp
│   │   ├── variable.hpp
│   │   └── virtual_function.hpp
│   ├── sdkgenny.hpp
│   ├── sdkgenny_ida.hpp
│   └── sdkgenny_parser.hpp
├── src
│   ├── array.cpp
│   ├── class.cpp
│   ├── constant.cpp
│   ├── detail
│   │   └── indent.cpp
│   ├── enum.cpp
│   ├── enum_class.cpp
│   ├── function.cpp
│   ├── generic_type.cpp
│   ├── namespace.cpp
│   ├── object.cpp
│   ├── parameter.cpp
│   ├── pointer.cpp
│   ├── reference.cpp
│   ├── sdk.cpp
│   ├── static_function.cpp
│   ├── struct.cpp
│   ├── type.cpp
│   ├── typename.cpp
│   ├── variable.cpp
│   └── virtual_function.cpp
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr and automatically regenerate CMakeLists.txt
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)

	# Create a configure-time dependency on cmake.toml to improve IDE support
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

# Options
option(SDKGENNY_BUILD_EXAMPLES "" OFF)
option(SDKGENNY_BUILD_PARSER "" OFF)

project(sdkgenny)

include(FetchContent)

if(SDKGENNY_BUILD_PARSER) # build-parser
	message(STATUS "Fetching PEGTL (3.2.7)...")
	FetchContent_Declare(PEGTL
		GIT_REPOSITORY
			"https://github.com/taocpp/PEGTL.git"
		GIT_TAG
			3.2.7
		GIT_SHALLOW
			ON
	)
	FetchContent_MakeAvailable(PEGTL)

endif()
# Target: sdkgenny
set(sdkgenny_SOURCES
	"src/array.cpp"
	"src/class.cpp"
	"src/constant.cpp"
	"src/detail/indent.cpp"
	"src/enum.cpp"
	"src/enum_class.cpp"
	"src/function.cpp"
	"src/generic_type.cpp"
	"src/namespace.cpp"
	"src/object.cpp"
	"src/parameter.cpp"
	"src/pointer.cpp"
	"src/reference.cpp"
	"src/sdk.cpp"
	"src/static_function.cpp"
	"src/struct.cpp"
	"src/type.cpp"
	"src/typename.cpp"
	"src/variable.cpp"
	"src/virtual_function.cpp"
	"include/sdkgenny.hpp"
	"include/sdkgenny/array.hpp"
	"include/sdkgenny/class.hpp"
	"include/sdkgenny/constant.hpp"
	"include/sdkgenny/detail/indent.hpp"
	"include/sdkgenny/enum.hpp"
	"include/sdkgenny/enum_class.hpp"
	"include/sdkgenny/function.hpp"
	"include/sdkgenny/generic_type.hpp"
	"include/sdkgenny/namespace.hpp"
	"include/sdkgenny/object.hpp"
	"include/sdkgenny/parameter.hpp"
	"include/sdkgenny/pointer.hpp"
	"include/sdkgenny/reference.hpp"
	"include/sdkgenny/sdk.hpp"
	"include/sdkgenny/static_function.hpp"
	"include/sdkgenny/struct.hpp"
	"include/sdkgenny/type.hpp"
	"include/sdkgenny/typename.hpp"
	"include/sdkgenny/variable.hpp"
	"include/sdkgenny/virtual_function.hpp"
	"include/sdkgenny_ida.hpp"
	"include/sdkgenny_parser.hpp"
	cmake.toml
)

add_library(sdkgenny STATIC)

target_sources(sdkgenny PRIVATE ${sdkgenny_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${sdkgenny_SOURCES})

add_library(sdkgenny::sdkgenny ALIAS sdkgenny)
target_compile_features(sdkgenny PUBLIC
	cxx_std_23
)

if(MSVC) # msvc
	target_compile_options(sdkgenny PRIVATE
		"/permissive-"
		"/W4"
		"/w14640"
	)
endif()

if((CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND NOT CMAKE_CXX_COMPILER_FRONTEND_VARIANT MATCHES "^MSVC$") OR (CMAKE_C_COMPILER_ID MATCHES "Clang" AND NOT CMAKE_C_COMPILER_FRONTEND_VARIANT MATCHES "^MSVC$")) # clang
	target_compile_options(sdkgenny PRIVATE
		-Wall
		-Wextra
		-Wshadow
		-Wnon-virtual-dtor
		-pedantic
	)
endif()

if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR CMAKE_C_COMPILER_ID STREQUAL "GNU") # gcc
	target_compile_options(sdkgenny PRIVATE
		-Wall
		-Wextra
		-Wshadow
		-Wnon-virtual-dtor
		-pedantic
	)
endif()

target_include_directories(sdkgenny PUBLIC
	"include/"
)

# Target: example_car
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_car_SOURCES
		"examples/car.cpp"
		cmake.toml
	)

	add_executable(example_car)

	target_sources(example_car PRIVATE ${example_car_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_car_SOURCES})

	target_link_libraries(example_car PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_car)
	endif()

endif()
# Target: example_bitfield
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_bitfield_SOURCES
		"examples/bitfield.cpp"
		cmake.toml
	)

	add_executable(example_bitfield)

	target_sources(example_bitfield PRIVATE ${example_bitfield_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_bitfield_SOURCES})

	target_link_libraries(example_bitfield PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_bitfield)
	endif()

endif()
# Target: example_typename
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_typename_SOURCES
		"examples/typename.cpp"
		cmake.toml
	)

	add_executable(example_typename)

	target_sources(example_typename PRIVATE ${example_typename_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_typename_SOURCES})

	target_link_libraries(example_typename PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_typename)
	endif()

endif()
# Target: example_usage
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_usage_SOURCES
		"examples/usage.cpp"
		cmake.toml
	)

	add_executable(example_usage)

	target_sources(example_usage PRIVATE ${example_usage_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_usage_SOURCES})

	target_link_libraries(example_usage PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_usage)
	endif()

endif()
# Target: example_sdk
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_sdk_SOURCES
		"examples/sdk.cpp"
		cmake.toml
	)

	add_executable(example_sdk)

	target_sources(example_sdk PRIVATE ${example_sdk_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_sdk_SOURCES})

	target_link_libraries(example_sdk PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_sdk)
	endif()

endif()
# Target: example_dummydata
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_dummydata_SOURCES
		"examples/dummydata.cpp"
		cmake.toml
	)

	add_executable(example_dummydata)

	target_sources(example_dummydata PRIVATE ${example_dummydata_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_dummydata_SOURCES})

	target_link_libraries(example_dummydata PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_dummydata)
	endif()

endif()
# Target: example_badname
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_badname_SOURCES
		"examples/badname.cpp"
		cmake.toml
	)

	add_executable(example_badname)

	target_sources(example_badname PRIVATE ${example_badname_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_badname_SOURCES})

	target_link_libraries(example_badname PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_badname)
	endif()

endif()
# Target: example_constants
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_constants_SOURCES
		"examples/constants.cpp"
		cmake.toml
	)

	add_executable(example_constants)

	target_sources(example_constants PRIVATE ${example_constants_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_constants_SOURCES})

	target_link_libraries(example_constants PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_constants)
	endif()

endif()
# Target: example_multiple_inheritance
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_multiple_inheritance_SOURCES
		"examples/multiple_inheritance.cpp"
		cmake.toml
	)

	add_executable(example_multiple_inheritance)

	target_sources(example_multiple_inheritance PRIVATE ${example_multiple_inheritance_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_multiple_inheritance_SOURCES})

	target_link_libraries(example_multiple_inheritance PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_multiple_inheritance)
	endif()

endif()
# Target: example_parser
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	if(SDKGENNY_BUILD_PARSER) # build-parser
		set(example_parser_SOURCES
			"examples/parser.cpp"
			cmake.toml
		)

		add_executable(example_parser)

		target_sources(example_parser PRIVATE ${example_parser_SOURCES})
		source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_parser_SOURCES})

		target_link_libraries(example_parser PRIVATE
			sdkgenny
		)

		target_link_libraries(example_parser PRIVATE
			taocpp::pegtl
		)

		get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
		if(NOT CMKR_VS_STARTUP_PROJECT)
			set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_parser)
		endif()

	endif()
endif()
# Target: example_generictype
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_generictype_SOURCES
		"examples/generictype.cpp"
		cmake.toml
	)

	add_executable(example_generictype)

	target_sources(example_generictype PRIVATE ${example_generictype_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_generictype_SOURCES})

	target_link_libraries(example_generictype PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_generictype)
	endif()

endif()
# Target: example_childstruct
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(example_childstruct_SOURCES
		"examples/childstruct.cpp"
		cmake.toml
	)

	add_executable(example_childstruct)

	target_sources(example_childstruct PRIVATE ${example_childstruct_SOURCES})
	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_childstruct_SOURCES})

	target_link_libraries(example_childstruct PRIVATE
		sdkgenny
	)

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_childstruct)
	endif()

endif()
# Target: example_nestedstruct
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	if(SDKGENNY_BUILD_PARSER) # build-parser
		set(example_nestedstruct_SOURCES
			"examples/nestedstruct.cpp"
			cmake.toml
		)

		add_executable(example_nestedstruct)

		target_sources(example_nestedstruct PRIVATE ${example_nestedstruct_SOURCES})
		source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_nestedstruct_SOURCES})

		target_link_libraries(example_nestedstruct PRIVATE
			sdkgenny
		)

		target_link_libraries(example_nestedstruct PRIVATE
			taocpp::pegtl
		)

		get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
		if(NOT CMKR_VS_STARTUP_PROJECT)
			set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_nestedstruct)
		endif()

	endif()
endif()

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 cursey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# SdkGenny

SdkGenny is a library for generating C++ compatible SDKs for third party applications.

## Installation

This project uses CMake. Just get the `include/` and `src/` dirs integrated into your project in some way. The only dependency is on `PEGTL` which is only necessary if you're using the included parser.

## Usage

Here is a short example of how to use SdkGenny. This does not showcase every feature. For more examples check the `examples/` directory.

```C++
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    // Make an SDK generator.
    sdkgenny::Sdk sdk{};

    // Get the global namespace for the SDK.
    auto g = sdk.global_ns();

    // Add some basic types to the global namespace.
    g->type("int")->size(4);
    g->type("float")->size(4);

    // Make an actual namespace.
    auto ns = g->namespace_("foobar");

    // Make a class in the namespace.
    auto foo = ns->class_("Foo");

    // Add some members.
    foo->variable("a")->type("int")->offset(0);
    foo->variable("b")->type("float")->append();

    // Make a subclass.
    auto bar = ns->class_("Bar")->parent(foo);

    // Add a member after 'b'.
    bar->variable("c")->type("int")->append();

    // Generate the SDK to the "usage_sdk" folder.
    sdk.generate(std::filesystem::current_path() / "usage_sdk");

    return 0;
}
```

Will produce the following 2 files

### `foobar/Foo.hpp`

```C++
#pragma once
namespace foobar {
#pragma pack(push, 1)
class Foo {
public:
    int a; // 0x0
    float b; // 0x4
}; // Size: 0x8
#pragma pack(pop)
}
```

### `foobar/Bar.hpp`

```C++
#pragma once
#include ".\Foo.hpp"
namespace foobar {
#pragma pack(push, 1)
class Bar : public Foo {
public:
    int c; // 0x8
}; // Size: 0xc
#pragma pack(pop)
}
```

## Projects

* [REFramework](https://github.com/praydog/REFramework) by [@praydog](https://github.com/praydog) - A mod framework for Resident-Evil 2
* [GlacierGenny](https://github.com/praydog/GlacierGenny) by [@praydog](https://github.com/praydog) - An SDK generator for HITMAN3
* [UE4Genny](https://github.com/cursey/ue4genny) - An SDK generator for Unreal Engine 4 games
* [luagenny](https://github.com/praydog/luagenny) - Lua bindings & utilities for sdkgenny
* [REGenny](https://github.com/cursey/regenny) - A reverse engineering tool to interactively reconstruct structures

## License

[MIT](https://choosealicense.com/licenses/mit/)

```

`cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml
[project]
name = "sdkgenny"

[options]
SDKGENNY_BUILD_EXAMPLES = false
SDKGENNY_BUILD_PARSER = false

[conditions]
build-examples = "SDKGENNY_BUILD_EXAMPLES"
build-parser = "SDKGENNY_BUILD_PARSER"

[fetch-content.PEGTL]
condition = "build-parser"
git = "https://github.com/taocpp/PEGTL.git"
tag = "3.2.7"
shallow = true

[target.sdkgenny]
type = "static"
headers = ["include/**.hpp"]
sources = ["src/**.cpp"]
include-directories = ["include/"]
compile-features = ["cxx_std_23"]
alias = "sdkgenny::sdkgenny"
msvc.private-compile-options = ["/permissive-", "/W4", "/w14640"]
clang.private-compile-options = ["-Wall", "-Wextra", "-Wshadow", "-Wnon-virtual-dtor", "-pedantic"]
gcc.private-compile-options = ["-Wall", "-Wextra", "-Wshadow", "-Wnon-virtual-dtor", "-pedantic"]

[template.example]
condition = "build-examples"
type = "executable"
link-libraries = ["sdkgenny"]

[target.example_car]
type = "example"
sources = ["examples/car.cpp"]

[target.example_bitfield]
type = "example"
sources = ["examples/bitfield.cpp"]

[target.example_typename]
type = "example"
sources = ["examples/typename.cpp"]

[target.example_usage]
type = "example"
sources = ["examples/usage.cpp"]

[target.example_sdk]
type = "example"
sources = ["examples/sdk.cpp"]

[target.example_dummydata]
type = "example"
sources = ["examples/dummydata.cpp"]

[target.example_badname]
type = "example"
sources = ["examples/badname.cpp"]

[target.example_constants]
type = "example"
sources = ["examples/constants.cpp"]

[target.example_multiple_inheritance]
type = "example"
sources = ["examples/multiple_inheritance.cpp"]

[target.example_parser]
condition = "build-parser"
type = "example"
sources = ["examples/parser.cpp"]
link-libraries = ["taocpp::pegtl"]

[target.example_generictype]
type = "example"
sources = ["examples/generictype.cpp"]

[target.example_childstruct]
type = "example"
sources = ["examples/childstruct.cpp"]

[target.example_nestedstruct]
condition = "build-parser"
type = "example"
sources = ["examples/nestedstruct.cpp"]
link-libraries = ["taocpp::pegtl"]
```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.22" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`examples/badname.cpp`:

```cpp
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};

    auto g = sdk.global_ns();
    auto bad_type = g->type("Bad name type")->size(8);
    auto bad_class = g->class_("Bad class");

    bad_class->variable("123 bad variable")->type(bad_type)->offset(0);
    bad_class->variable("shorthand bad variable")->type("Bad name type")->offset(8);

    sdk.generate(std::filesystem::current_path() / "bad_name_sdk");

    return 0;
}
```

`examples/bitfield.cpp`:

```cpp
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto ushort = g->type("unsigned short")->size(2);

    // Generate the Date struct described @ https://docs.microsoft.com/en-us/cpp/cpp/cpp-bit-fields
    auto date = g->struct_("Date");

    date->variable("nWeekDay")->type(ushort)->bit_size(3)->append()->bit_append();
    date->variable("nMonthDay")->type(ushort)->bit_size(6)->append()->bit_append();
    date->variable("nMonth")->type(ushort)->bit_size(5)->append()->bit_append();
    date->variable("nYear")->type(ushort)->bit_size(8)->append()->bit_append();

    sdk.generate(std::filesystem::current_path() / "bitfield_sdk");

    return 0;
}
```

`examples/car.cpp`:

```cpp
#include <cassert>

#include <sdkgenny.hpp>

constexpr auto PREAMBLE =
    R"(MIT License

Copyright (c) 2021 cursey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.)";

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    sdk.preamble(PREAMBLE)->postamble("End of file");
    sdk.include("cstdint")->include_local("Types.hpp");

    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("short")->size(2);
    g->type("int")->size(4);
    g->type("long")->size(4);
    g->type("long long")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);

    g->enum_("CarTypes")->value("TWO_DOOR", 0)->value("FOUR_DOOR", 1)->value("TRUCK", 2)->value("VAN", 3);

    auto vec3 = g->struct_("Vec3")->size(16);

    vec3->variable("x")->type(g->type("float"))->offset(0);
    vec3->variable("y")->type(g->type("float"))->offset(4);
    vec3->variable("z")->type(g->type("float"))->offset(8);

    auto car = g->class_("Car")->parent(g->class_("ModeOfTransportation"));

    car->variable("weight")->type(g->type("int"))->offset(8);
    car->variable("value")->type(g->type("float"))->offset(12);

    auto wheel = car->class_("Wheel");
    auto color = car->enum_("Color")->value("RED", 0)->value("BLACK", 1);
    auto door = car->struct_("Door");

    wheel->variable("size")->type(g->type("int"))->offset(0);
    door->variable("color")->type(color)->offset(0);
    car->variable("wheels")->type(wheel->array_(4))->offset(16);
    car->variable("doors")->type(door->array_(4))->offset(16 + 4 * 4);
    car->variable("pos")->type(g->type("Vec3"))->offset(car->variable("doors")->end());
    car->variable("pos_history")->type(g->type("Vec3")->ptr())->offset(car->variable("pos")->end());

    auto drive = car->function("drive");

    drive->returns(g->type("float"));
    drive->param("speed")->type(g->type("float"));
    drive->param("distance")->type(g->type("float"));
    drive->procedure(R"(std::cout << "Oh my god guys I'm driving!"; return 5.0f;)");

    auto open_door = car->virtual_function("open_door");

    open_door->param("where")->type(g->type("Vec3")->ptr());

    car->enum_class("Title")->value("SALVAGE", 0)->value("CLEAN", 1)->type(g->type("long long"));

    auto two_door = g->class_("TwoDoorCar")->parent(g->class_("Car"));

    // Name collision will occur. Will have a number appended in the output.
    two_door->variable("weight")->type(g->type("long"))->offset(120);
    assert(two_door->owner<sdkgenny::Namespace>() == g);

    sdk.generate(std::filesystem::current_path() / "car_sdk");

    return 0;
}

```

`examples/childstruct.cpp`:

```cpp
// This example originally showcased an error in dependency resolving for structs declared within other structs.
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto i32 = g->type("int")->size(4);
    auto foo = g->struct_("Foo");

    foo->variable("a")->type(i32)->append();

    auto bar = foo->struct_("Bar");

    bar->variable("b")->type(i32)->append();

    auto baz = foo->struct_("Baz");

    baz->variable("c")->type(i32)->append();

    auto qux = g->struct_("Qux");

    // qux->variable("d")->type(bar)->append();
    qux->variable("e")->type(baz->ptr())->append();

    sdk.generate(std::filesystem::current_path() / "child_struct_sdk");

    return 0;
}

```

`examples/constants.cpp`:

```cpp
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto i32 = g->type("int")->size(4);
    auto f32 = g->type("float")->size(4);
    auto char8 = g->type("char")->size(1);

    auto s = g->struct_("StructWithConstants");

    s->constant("SOME_INT")->integer(42)->type(i32);
    s->constant("SOME_OTHER_INT")->integer(777)->type(i32);
    s->constant("SOME_FLOAT")->real(123.456f)->type(f32);
    s->constant("SOME_STR")->string("Hello, world!")->type(char8->ptr());

    sdk.generate(std::filesystem::current_path() / "constants_sdk");

    return 0;
}

```

`examples/dummydata.cpp`:

```cpp
// This example originally highlighted an issue with include path resolution that
// has since been fixed.
#include <sdkgenny.hpp>

int main() {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    sdk.include("REFramework.hpp");
    sdk.include("sdk/ReClass.hpp");
    sdk.include("cstdint");

    g->type("int8_t")->size(1);
    g->type("int16_t")->size(2);
    g->type("int32_t")->size(4);
    g->type("int64_t")->size(8);
    g->type("uint8_t")->size(1);
    g->type("uint16_t")->size(2);
    g->type("uint32_t")->size(4);
    g->type("uint64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);
    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("int")->size(4);
    g->type("void")->size(0);
    g->type("void*")->size(8);

    auto dummy_type = g->namespace_("sdk")->struct_("DummyData")->size(0x100);

    auto c = g->namespace_("not-sdk")->class_("SomeClass");
    c->function("SomeFunc")->returns(dummy_type);

    sdk.generate("sdk");

    return 0;
}

```

`examples/generictype.cpp`:

```cpp
#include <iostream>
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};

    auto g = sdk.global_ns();
    g->type("int")->size(4);
    g->type("float")->size(4);

    auto foo = g->class_("Foo");
    foo->variable("a")->type("int")->append();
    foo->variable("b")->type("float")->append();

    auto bar = g->class_("Bar");
    bar->variable("c")->type("int")->append();

    auto baz = g->generic_type("Baz<Foo, Bar*>")->template_type(foo)->template_type(bar->ptr())->size(42);

    auto qux = g->class_("Qux");
    qux->variable("baz")->type(baz)->append();

    auto quux = g->class_("Quux");
    quux->function("hello")->param("name")->type(baz->ref());

    sdk.generate(std::filesystem::current_path() / "generic_type_sdk");

    return 0;
}
```

`examples/multiple_inheritance.cpp`:

```cpp
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};

    auto g = sdk.global_ns();
    g->type("int")->size(4);
    g->type("float")->size(4);

    auto person = g->class_("Person");
    person->variable("age")->type("int")->offset(0);

    auto student = g->class_("Student")->parent(person);
    student->variable("gpa")->type("float")->offset(person->size());

    auto faculty = g->class_("Faculty")->parent(person);
    faculty->variable("wage")->type("int")->offset(person->size());

    auto ta = g->class_("TA")->parent(student)->parent(faculty);
    ta->variable("hours")->type("int")->offset(student->size() + faculty->size());

    sdk.generate(std::filesystem::current_path() / "multiple_inheritance_sdk");

    return 0;
}
```

`examples/nestedstruct.cpp`:

```cpp
// This example originally showcased an error in nested struct generation.
#include <iostream>

#include <sdkgenny_parser.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    sdkgenny::parser::State s{};
    s.parents.push_back(sdk.global_ns());

    tao::pegtl::string_input in{/*R"(
                                    namespace foo {
                                        struct bar {
                                            struct baz {}
                                        }
                                    }
                                )"*/
        R"(
            struct foo {
                struct bar* bar
            }

        )",
        ""};

    try {
        tao::pegtl::parse<sdkgenny::parser::Grammar, sdkgenny::parser::Action>(in, s);
    } catch (const tao::pegtl::parse_error& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    auto sdk_path = std::filesystem::current_path() / "nested_struct_sdk";
    std::filesystem::remove_all(sdk_path);
    sdk.generate(sdk_path);

    return 0;
}

```

`examples/parser.cpp`:

```cpp
#include <cstdlib>
#include <iostream>
#include <optional>

#include <sdkgenny_parser.hpp>

#include <tao/pegtl/contrib/analyze.hpp>

constexpr auto g_example_str = R"(
type float 4
type double 8

struct vec3
    float x @ 0 // omg thats @ 0
    float y // This will follow the x variable and land @ 4
    float z // This will follow y and land @ 8

// The total size will be... 12!
)";

constexpr auto g_usage_str = R"(
// Add some basic types to the global namespace.
type char 1 [[i8 ]];
type int 4 [[ i32]]
type float 4 [[f32]]

// Make an actual namespace.
namespace foo.bar {

// Make a class in the namespace.
struct Foo 0x10 {
    // Add some members.
    int a @ 0 [[u32]]
    float b
};

// Make a subclass.
struct Bar : Foo 0x20 {
    // Add a member after 'b'.
    int c
}

// Make a subclass with multiple parents.
struct Baz : Foo, Bar {
    float d 
}
}

namespace baz {


/* this is a cool struct
 * and this is a long comment
 * how neat. */
struct Qux  { 
    foo.bar.Baz baz
    char* str
    char* str_array[10];
    int add(int a, /* bad place for a comment but w/e */ int b)   
    int sub(int a, int b, int* c)
}

}

struct Vec3 {
    float x;
    float y;
    float z;
    float length    ( );
    Vec3 add( Vec3 other );
    static Vec3 zero();
};

struct OtherVec3 {
    float xyz[3]
    float* xyz_ptr
    int** xyz_ptr_ptr // woah
}

struct Mat4x3 {
    float m[4][3]
    float[4] n[3]; // Very strange.
    float[4][3] o
}

enum Color {
    RED = 1,
    BLUE = 2,
    GREEN = 0x3
}

namespace enums {
    
enum Size : char {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    XLARGE = 3,
    XXLARGE = 4,
}

enum class Speed : int {
    SLOW = 25,
    MEDIUM = 40,
    FAST = 65
};
}

type uint16_t 2 [[u16]]

struct Date {
    uint16_t nWeekDay : 3
    uint16_t nMonthDay : 6
    uint16_t nMonth : 5
    uint16_t nYear : 8
    Vec3 v
}

struct Nested {
    enum Enum {
        HELLO = 0,
        WORLD = 1,
    }

    struct Struct {
        int a
        int b +4
        int c +8
    }

    Enum enum_
    Struct struct_
}

class CoolClass {
    Nested nest @ 8
    virtual int say_hi(char* name)
    virtual void say_hello_world() @ 1
    virtual void say_goodbye() @ 10
}
)";

constexpr auto g_ns_bug = R"(
type int 4

namespace qux
struct foo
    int a

namespace bar
    struct baz : qux.foo
        int b

namespace   
    struct quux
        int c
)";

constexpr auto g_new = R"(
type int 4
type char 1

namespace enums {
enum Size : char {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    XLARGE = 3,
    XXLARGE = 4
}

namespace this_enum.is.nested.deep {

    enum class Speed : int {
        SLOW = 25,
        MEDIUM = 40,    
        FAST = 65
    }

}
}

namespace structs {
struct Vec3i {
    int x
    int y
    int z
}
}
)";

constexpr auto g_include = R"(
#include <cstdint>
#include "cool_thing.hpp"

import "types.genny"

struct Vec3f {
    float x
    float y
    float z
}

struct Vec3i {
    int x
    int y
    int z
}

struct Baz : foobar.Bar {
    int c
}
)";

constexpr auto g_fwd_decl_members = R"(
class Foo {
    struct Bar* bar
}

struct Bar {
    class Foo* foo
    enum class Baz* baz
}

enum class Baz {
    A = 0, 
    B = 1, 
    C = 2
}
)";

constexpr auto g_reclass = R"(
type char 1

// Created with ReClass.NET 1.2 by KN4CK3R

class Foo
{
public:
	char pad_0000[128]; //0x0000
}; //Size: 0x0080
static_assert(sizeof(Foo) == 0x80);

class Bar
{
public:
	char pad_0000[128]; //0x0000
}; //Size: 0x0080
static_assert(sizeof(Bar) == 0x80);

class Baz
{
public:
	class Foo *foo; //0x0000
	class Bar *bar; //0x0008
	char pad_0010[112]; //0x0010
}; //Size: 0x0080
static_assert(sizeof(Baz) == 0x80);

class Qux : public Baz
{
public:
	char pad_0080[120]; //0x0080
}; //Size: 0x00F8
static_assert(sizeof(Qux) == 0xF8);
)";

constexpr auto g_multiple_inheritance = R"(
type int 4
type float 4

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}
)";

constexpr auto g_enum_with_type = R"(
type byte 1 [[u8]]

enum Place : byte {
    EARTH = 0,
    MOON = 1,
    MARS = 2,
}

enum class Color : byte {
    RED = 0,
    BLUE = 1,
    GREEN = 2, 
}
)";

constexpr auto g_bad_metadata = R"(
type byte 1 [[u8]]]
)";

namespace pegtl = tao::pegtl;

int main(int argc, char* argv[]) {
    auto _ = tao::pegtl::analyze<sdkgenny::parser::Grammar>(1);

    sdkgenny::Sdk sdk{};

    sdk.header_extension(".hxx");
    sdk.source_extension(".cxx");

    sdkgenny::parser::State s{};
    // s.global_ns = s.cur_ns = sdk.global_ns();
    s.parents.push_back(sdk.global_ns());

    // pegtl::string_input in{"float type 4", "example_string"};
    // pegtl::string_input in{g_example_str, "example_string"};
    pegtl::string_input in{g_usage_str, "usage_str"};
    // pegtl::string_input in{g_ns_bug, "ns_bug_str"};
    // pegtl::string_input in{g_new, "new_str"};
    // pegtl::string_input in{g_include, "include_str"};
    // pegtl::string_input in{g_fwd_decl_members, "fwd_decl_members"};
    // pegtl::string_input in{g_reclass, "reclass"};
    // pegtl::string_input in{g_multiple_inheritance, "multiple_inheritance"};
    // pegtl::string_input in{g_enum_with_type, "enum_with_type"};
    // pegtl::string_input in{g_bad_metadata, "bad_metadata"};

    try {
        auto r = pegtl::parse<sdkgenny::parser::Grammar, sdkgenny::parser::Action>(in, s);
        std::cout << r << std::endl;
    } catch (const pegtl::parse_error& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    auto sdk_path = std::filesystem::current_path() / "parser_sdk";
    std::filesystem::remove_all(sdk_path);
    sdk.generate(sdk_path);

    std::cout << sdk_path.string() << std::endl;

    return 0;
}
```

`examples/sdk.cpp`:

```cpp
#include <sdkgenny.hpp>

void car(sdkgenny::Namespace* g) {
    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("short")->size(2);
    g->type("int")->size(4);
    g->type("long")->size(4);
    g->type("int64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);

    g->enum_("CarTypes")->value("TWO_DOOR", 0)->value("FOUR_DOOR", 1)->value("TRUCK", 2)->value("VAN", 3);

    auto vec3 = g->owner<sdkgenny::Namespace>()->struct_("Vec3")->size(16);

    vec3->variable("x")->type(g->type("float"))->offset(0);
    vec3->variable("y")->type(g->type("float"))->offset(4);
    vec3->variable("z")->type(g->type("float"))->offset(8);

    auto car = g->class_("Car")->parent(g->class_("ModeOfTransportation"));

    car->variable("weight")->type(g->type("int"))->offset(8);
    car->variable("value")->type(g->type("float"))->offset(12);

    auto wheel = car->class_("Wheel");
    auto color = car->enum_("Color")->value("RED", 0)->value("BLACK", 1);
    auto door = car->struct_("Door");

    wheel->variable("size")->type(g->type("int"))->offset(0);
    door->variable("color")->type(color)->offset(0);
    car->variable("wheels")->type(wheel->array_(4))->offset(16);
    car->variable("doors")->type(door->array_(4))->offset(16 + 4 * 4);
    car->variable("pos")->type(g->type("Vec3"))->offset(car->variable("doors")->end());
    car->variable("pos_history")->type(g->type("Vec3")->ptr())->offset(car->variable("pos")->end());

    auto drive = car->function("drive");

    drive->returns(g->type("float"));
    drive->param("speed")->type(g->type("float"));
    drive->param("distance")->type(g->type("float"));
    drive->procedure(R"(std::cout << "Oh my god guys I'm driving!"; return 5.0f;)");

    auto open_door = car->virtual_function("open_door");

    open_door->param("where")->type(g->type("Vec3")->ptr());

    car->enum_class("Title")->value("SALVAGE", 0)->value("CLEAN", 1)->type(g->type("int64_t"));

    auto two_door = g->class_("TwoDoorCar")->parent(g->class_("Car"));

    // Name collision will occur. Will have a number appended in the output.
    two_door->variable("weight")->type(g->type("long"))->offset(120);
}

void usage(sdkgenny::Namespace* sdk) {
    // Add some basic types to the global namespace.
    sdk->type("int")->size(4);
    sdk->type("float")->size(4);

    // Make an actual namespace.
    auto ns = sdk->namespace_("foobar");

    // Make a class in the namespace.
    auto foo = ns->class_("Foo");

    // Add some members.
    foo->variable("a")->type("int")->offset(0);
    foo->variable("b")->type("float")->append();

    // Make a subclass.
    auto bar = ns->class_("Bar")->parent(foo);

    // Add a member after 'b'.
    bar->variable("c")->type("int")->append();
}

void multiple_inheritance(sdkgenny::Namespace* ns) {
    auto foo = ns->namespace_("foo")->class_("Foo");
    foo->variable("a")->offset(8)->type("int");

    auto bar = ns->namespace_("bar")->class_("Bar");
    bar->variable("b")->offset(16)->type("float");

    auto baz = ns->namespace_("baz")->class_("Baz")->parent(foo)->parent(bar);
    auto c = baz->variable("c")->offset(foo->size() + bar->size() + 4)->type("long");
    baz->variable("a")->offset(c->end())->type("double");
}

void nested_type_inclusion(sdkgenny::Namespace* ns) {
    auto foo = ns->class_("Foo");
    auto foo_bar = foo->enum_("Bar");
    auto baz = ns->class_("Baz");
    baz->variable("bar")->type(foo_bar);
}

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    // sdk.include("cstdint")->include("vector");

    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("short")->size(2);
    g->type("int")->size(4);
    g->type("long")->size(4);
    g->type("int64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);

    auto SdkEnum = g->enum_("SdkEnum")->value("A", 1)->value("B", 2)->value("C", 3);
    auto a = g->namespace_("a");
    auto AEnum = a->enum_("AEnum")->value("A", 1)->value("B", 2)->value("C", 3);
    auto b = g->namespace_("b");
    auto ba = b->namespace_("ba");
    auto BAClass = ba->class_("BAClass");
    BAClass->variable("a_enum")->offset(8)->type(AEnum->ptr());
    auto c = g->namespace_("c");
    auto CClass = c->class_("CClass");
    CClass->variable("ba_class")->type(BAClass->ptr());
    CClass->variable("a_enum")->offset(CClass->variable("ba_class")->end())->type(AEnum);
    CClass->variable("ba_class_2")->offset(CClass->variable("a_enum")->end())->type(BAClass->ptr()->ptr()->ptr());

    car(g->namespace_("car"));
    usage(g->namespace_("usage"));
    multiple_inheritance(g->namespace_("multi"));
    nested_type_inclusion(g->namespace_("nested_type"));

    auto say_hi = CClass->static_function("say_hi");
    say_hi->returns(g->type("int"));
    say_hi->procedure("std::cout << \"hi\\n\";\nreturn 1;");

    auto drive = BAClass->virtual_function("car_at_pos")->vtable_index(5);
    drive->returns(g->namespace_("car")->class_("Car")->ptr());
    drive->param("pos")->type(g->struct_("Vec3")->ref());

    auto cclasses = g->generic_type("std::vector<c::CClass*>");
    cclasses->template_type(CClass->ptr());
    cclasses->size(sizeof(std::vector<void*>));

    drive->param("cclasses")->type(cclasses->ptr());

    auto nested = CClass->class_("Nested");
    nested->function("aloha")->procedure("std::cout << \"aloha\\n\";");

    g->class_("EmptyClass");

    auto sdk_path = std::filesystem::current_path() / "example_sdk";
    std::filesystem::remove_all(sdk_path);
    sdk.generate(sdk_path);

    return 0;
}
```

`examples/typename.cpp`:

```cpp
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    sdkgenny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto foo = g->namespace_("foo")->namespace_("baz")->class_("Foo");
    foo->variable("bar")->type(g->namespace_("bar")->class_("Bar")->ptr());

    auto bar = g->namespace_("bar")->class_("Bar");
    bar->variable("foo")->type(foo->ptr());

    for (int i = 0; i < 100; ++i) {
        g->namespace_("bs_ns_" + std::to_string(i));
    }

    sdk.generate(std::filesystem::current_path() / "typename_sdk");

    return 0;
}
```

`examples/usage.cpp`:

```cpp
#include <sdkgenny.hpp>

int main(int argc, char* argv[]) {
    // Make an SDK generator.
    sdkgenny::Sdk sdk{};

    // Get the global namespace for the SDK.
    auto g = sdk.global_ns();

    // Add some basic types to the global namespace.
    g->type("int")->size(4);
    g->type("float")->size(4);

    // Make an actual namespace.
    auto ns = g->namespace_("foobar");

    // Make a class in the namespace.
    auto foo = ns->class_("Foo")->comment("A class")->as<sdkgenny::Class>();

    // Add some members.
    foo->variable("a")->type("int")->offset(0)->comment("The first member")->prepend_comment("This is");
    foo->variable("b")->type("float")->append()->comment("The second member")->append_comment("Is really cool");

    // Make a subclass.
    auto bar = ns->class_("Bar")->parent(foo)->comment("A subclass of Foo")->as<sdkgenny::Class>();

    // Add a member after 'b'.
    bar->variable("c")->type("int")->append()->comment("The third member");

    // Generate the SDK to the "usage_sdk" folder.
    sdk.generate(std::filesystem::current_path() / "usage_sdk");

    return 0;
}
```

`format.ps1`:

```ps1
Get-ChildItem -Path .\include,.\src,.\examples -Include *.hpp, *.cpp -Recurse | 
ForEach-Object {
    Write-Output $_.FullName
    &clang-format -i -style=file $_.FullName
}

```

`format.sh`:

```sh
#!/usr/bin/env sh

find include src examples -type f \( -name "*.hpp" -o -name "*.cpp" \) |
while read file; do
    echo "$file"
    clang-format -i -style=file "$file"
done

```

`include/sdkgenny.hpp`:

```hpp
#pragma once

#include <sdkgenny/array.hpp>
#include <sdkgenny/class.hpp>
#include <sdkgenny/constant.hpp>
#include <sdkgenny/enum.hpp>
#include <sdkgenny/enum_class.hpp>
#include <sdkgenny/function.hpp>
#include <sdkgenny/generic_type.hpp>
#include <sdkgenny/namespace.hpp>
#include <sdkgenny/object.hpp>
#include <sdkgenny/parameter.hpp>
#include <sdkgenny/pointer.hpp>
#include <sdkgenny/reference.hpp>
#include <sdkgenny/sdk.hpp>
#include <sdkgenny/static_function.hpp>
#include <sdkgenny/struct.hpp>
#include <sdkgenny/type.hpp>
#include <sdkgenny/typename.hpp>
#include <sdkgenny/variable.hpp>
#include <sdkgenny/virtual_function.hpp>

```

`include/sdkgenny/array.hpp`:

```hpp
#pragma once

#include <cstddef>

#include <sdkgenny/type.hpp>

namespace sdkgenny {
class Array : public Type {
public:
    explicit Array(std::string_view name);

    auto of() const { return m_of; }
    auto of(Type* of) {
        m_of = of;
        return this;
    }

    auto count() const { return m_count; }
    Array* count(size_t count);

    size_t size() const override;

    void generate_typename_for(std::ostream& os, const Object* obj) const override;
    void generate_variable_postamble(std::ostream& os) const override;

protected:
    Type* m_of{};
    size_t m_count{};
};
} // namespace sdkgenny
```

`include/sdkgenny/class.hpp`:

```hpp
#pragma once

#include <sdkgenny/struct.hpp>

namespace sdkgenny {
class Class : public Struct {
public:
    explicit Class(std::string_view name);

    void generate_forward_decl(std::ostream& os) const override;
    void generate(std::ostream& os) const override;
};
} // namespace sdkgenny
```

`include/sdkgenny/constant.hpp`:

```hpp
#pragma once

#include <ostream>
#include <string>

#include <sdkgenny/object.hpp>

namespace sdkgenny {
class Type;

class Constant : public Object {
public:
    explicit Constant(std::string_view name);

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    // Helper that recurses though owners to find the correct type.
    Constant* type(std::string_view name);

    const auto& value() const { return m_value; }
    auto value(std::string_view value) {
        m_value = value;
        return this;
    }

    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true> auto real(T value) {
        m_value = std::to_string(value);
        return this;
    }

    template <typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true> auto integer(T value) {
        m_value = std::to_string(value);
        return this;
    }

    Constant* string(const std::string& value);

    virtual void generate(std::ostream& os) const;

protected:
    Type* m_type{};
    std::string m_value{};
};
} // namespace sdkgenny
```

`include/sdkgenny/detail/indent.hpp`:

```hpp
#pragma once

#include <streambuf>
#include <string>

namespace sdkgenny::detail {
class Indent : public std::streambuf {
public:
    explicit Indent(std::streambuf* dest, int indent = 4);
    explicit Indent(std::ostream& dest, int indent = 4);
    ~Indent() override;

protected:
    int overflow(int ch) override;

private:
    std::streambuf* m_dest{};
    bool m_is_at_start_of_line{true};
    std::string m_indent{};
    std::ostream* m_owner{};
};
} // namespace sdkgenny::detail

```

`include/sdkgenny/enum.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <tuple>
#include <vector>

#include <sdkgenny/type.hpp>

namespace sdkgenny {
class Enum : public Type {
public:
    explicit Enum(std::string_view name);

    Enum* value(std::string_view name, uint64_t value);

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    auto&& values() const { return m_values; }
    auto&& values() { return m_values; }

    size_t size() const override;

    virtual void generate_forward_decl(std::ostream& os) const;
    virtual void generate(std::ostream& os) const;

protected:
    std::vector<std::tuple<std::string, uint64_t>> m_values{};
    Type* m_type{};

    void generate_type(std::ostream& os) const;
    void generate_enums(std::ostream& os) const;
};
} // namespace sdkgenny
```

`include/sdkgenny/enum_class.hpp`:

```hpp
#pragma once

#include <sdkgenny/enum.hpp>

namespace sdkgenny {
class EnumClass : public Enum {
public:
    explicit EnumClass(std::string_view name);

    void generate_forward_decl(std::ostream& os) const override;
    void generate(std::ostream& os) const override;
};
} // namespace sdkgenny
```

`include/sdkgenny/function.hpp`:

```hpp
#pragma once

#include <ostream>
#include <string>
#include <unordered_set>

#include <sdkgenny/object.hpp>

namespace sdkgenny {
class Type;
class Parameter;

class Function : public Object {
public:
    explicit Function(std::string_view name);

    Parameter* param(std::string_view name);

    auto returns() const { return m_return_value; }
    auto returns(Type* return_value) {
        m_return_value = return_value;
        return this;
    }

    auto&& procedure() const { return m_procedure; }
    auto procedure(std::string_view procedure) {
        m_procedure = procedure;
        return this;
    }

    auto&& dependencies() const { return m_dependencies; }
    auto depends_on(Type* type) {
        m_dependencies.emplace(type);
        return this;
    }

    auto&& defined() const { return m_is_defined; }
    auto defined(bool is_defined) {
        m_is_defined = is_defined;
        return this;
    }

    virtual void generate(std::ostream& os) const;
    virtual void generate_source(std::ostream& os) const;

protected:
    Type* m_return_value{};
    std::string m_procedure{};
    std::unordered_set<Type*> m_dependencies{};
    bool m_is_defined{true};

    void generate_prototype(std::ostream& os) const;
    void generate_prototype_internal(std::ostream& os) const;
    void generate_procedure(std::ostream& os) const;
};
} // namespace sdkgenny
```

`include/sdkgenny/generic_type.hpp`:

```hpp
#pragma once

#include <unordered_set>

#include <sdkgenny/type.hpp>

namespace sdkgenny {
class GenericType : public Type {
public:
    explicit GenericType(std::string_view name);

    auto&& template_types() const { return m_template_types; }
    auto template_type(Type* type) {
        m_template_types.emplace(type);
        return this;
    }

protected:
    std::unordered_set<Type*> m_template_types{};
};
} // namespace sdkgenny
```

`include/sdkgenny/namespace.hpp`:

```hpp
#pragma once

#include <sdkgenny/typename.hpp>

namespace sdkgenny {
class Class;
class Enum;
class EnumClass;
class GenericType;
class Struct;
class Type;

class Namespace : public Typename {
public:
    explicit Namespace(std::string_view name);

    Type* type(std::string_view name);
    GenericType* generic_type(std::string_view name);
    Struct* struct_(std::string_view name);
    Class* class_(std::string_view name);
    Enum* enum_(std::string_view name);
    EnumClass* enum_class(std::string_view name);
    Namespace* namespace_(std::string_view name);
};
} // namespace sdkgenny
```

`include/sdkgenny/object.hpp`:

```hpp
#pragma once

#include <algorithm>
#include <cstring>
#include <filesystem>
#include <functional>
#include <memory>
#include <string>
#include <unordered_set>
#include <vector>
#include <format>

namespace sdkgenny {
class Struct;

class Object {
public:
    Object() = delete;
    explicit Object(std::string_view name);
    virtual ~Object() = default;

    const auto& name() const { return m_name; }
    auto name(std::string name) {
        m_name = std::move(name);
        return this;
    }

    const auto& metadata() const { return m_metadata; }
    auto& metadata() { return m_metadata; }
    virtual void generate_metadata(std::ostream& os) const;

    const std::string& comment() const { return m_comment; }
    Object* comment(std::string_view format, auto&&... args) {
        m_comment = std::vformat(format, std::make_format_args(args...)) + "\n";
        return this;
    }
    Object* append_comment(std::string_view format, auto&&... args) {
        m_comment += std::vformat(format, std::make_format_args(args...)) + "\n";
        return this;
    }
    Object* prepend_comment(std::string_view format, auto&&... args) {
        m_comment = std::vformat(format, std::make_format_args(args...)) + "\n" + m_comment;
        return this;
    }
    virtual void generate_comment(std::ostream& os) const;

    template <typename T> bool is_a() const { return dynamic_cast<const T*>(this) != nullptr; }
    template <typename T> const T* as() const { return dynamic_cast<const T*>(this); }
    template <typename T> T* as() { return dynamic_cast<T*>(this); }

    // Searches for an owner of the correct type.
    template <typename T> const T* owner() const {
        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                return (const T*)owner;
            }
        }

        return nullptr;
    }

    template <typename T> T* owner() { return (T*)((const Object*)this)->owner<T>(); }

    template <typename T> const T* topmost_owner() const {
        const T* topmost{};

        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                topmost = (const T*)owner;
            }
        }

        return topmost;
    }

    template <typename T> T* topmost_owner() { return (T*)((const Object*)this)->topmost_owner<T>(); }

    auto direct_owner() const { return m_owner; }

    template <typename T> std::vector<T*> owners() const {
        std::vector<T*> owners{};

        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                owners.emplace_back((T*)owner);
            }
        }

        return owners;
    }

    template <typename T> std::vector<T*> get_all() const {
        std::vector<T*> children{};

        for (auto&& child : m_children) {
            if (child->is_a<T>()) {
                children.emplace_back((T*)child.get());
            }
        }

        return children;
    }

    template <typename T> void get_all_in_children(std::unordered_set<T*>& objects) const {
        if (is_a<T>()) {
            objects.emplace((T*)this);
        }

        for (auto&& child : m_children) {
            child->get_all_in_children(objects);
        }
    }

    template <typename T> bool has_any() const {
        return std::any_of(
            m_children.cbegin(), m_children.cend(), [](const auto& child) { return child->template is_a<T>(); });
    }

    template <typename T> bool has_any_in_children() const {
        return std::any_of(m_children.cbegin(), m_children.cend(),
            [](const auto& child) { return child->template is_a<T>() || child->template has_any_in_children<T>(); });
    }

    template <typename T> bool is_child_of(T* obj) const {
        const auto o = owners<T>();
        return std::any_of(o.cbegin(), o.cend(), [obj](const auto& owner) { return owner == obj; });
    }

    bool is_direct_child_of(Object* obj) const { return m_owner == obj; }

    template <typename T> T* add(std::unique_ptr<T> object) {
        object->m_owner = this;
        return (T*)m_children.emplace_back(std::move(object)).get();
    }

    template <typename T> T* find(std::string_view name) const {
        for (auto&& child : m_children) {
            if (child->is_a<T>() && child->m_name == name) {
                return (T*)child.get();
            }
        }

        return nullptr;
    }

    template <typename T> T* find_in_owners(std::string_view name, bool include_self) const {
        auto owner = (include_self) ? this : m_owner;

        for (; owner != nullptr; owner = owner->m_owner) {
            if (auto search = owner->find<T>(name)) {
                return search;
            }
        }

        return nullptr;
    }

    template <typename T, typename... TArgs> T* find_or_add(std::string_view name, TArgs... args) {
        if (auto search = find<T>(name)) {
            return search;
        }

        return add(std::make_unique<T>(name, args...));
    }

    template <typename T, typename... TArgs> T* find_in_owners_or_add(std::string_view name, TArgs... args) {
        if (auto search = find_in_owners<T>(name, true)) {
            return search;
        }

        return add(std::make_unique<T>(name, args...));
    }

    // Returns the unique_ptr to the removed object.
    std::unique_ptr<Object> remove(Object* obj);

    template <typename T> void remove_all() {
        for (auto&& child : get_all<T>()) {
            remove(child);
        }
    }

    // Will fix up a desired name so that it's usable as a C++ identifier. Things like spaces get converted to
    // underscores, and we make sure it doesn't begin with a number. More checks could be done here in the future if
    // necessary.
    std::function<std::string()> usable_name = [this] {
        std::string name{};
        constexpr auto allowed_chars = "*&[]:";

        for (auto&& c : m_name) {
            auto cc = static_cast<unsigned char>(c);

            if (!std::isalnum(cc) && std::strchr(allowed_chars, cc) == nullptr) {
                name += '_';
            } else {
                name += c;
            }
        }

        if (!name.empty() && isdigit(name[0])) {
            name = "_" + name;
        }

        return name;
    };

    // The name used when declaring the object (only for types).
    std::function<std::string()> usable_name_decl = usable_name;

    std::filesystem::path path();

    auto skip_generation(bool g) {
        m_skip_generation = g;
        return this;
    }
    auto skip_generation() const { return m_skip_generation; }

protected:
    friend class Type;
    friend class Pointer;
    friend class Namespace;
    friend class Sdk;

    Object* m_owner{};

    std::string m_name{};
    std::vector<std::unique_ptr<Object>> m_children{};
    std::vector<std::string> m_metadata{};
    std::string m_comment{};

    bool m_skip_generation{};
};
} // namespace sdkgenny

```

`include/sdkgenny/parameter.hpp`:

```hpp
#pragma once

#include <ostream>

#include <sdkgenny/object.hpp>

namespace sdkgenny {
class Type;

class Parameter : public Object {
public:
    explicit Parameter(std::string_view name);

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    virtual void generate(std::ostream& os) const;

protected:
    Type* m_type{};
};
} // namespace sdkgenny
```

`include/sdkgenny/pointer.hpp`:

```hpp
#pragma once

#include <sdkgenny/reference.hpp>

namespace sdkgenny {
class Pointer : public Reference {
public:
    explicit Pointer(std::string_view name);

    void generate_typename_for(std::ostream& os, const Object* obj) const override;
};

} // namespace sdkgenny
```

`include/sdkgenny/reference.hpp`:

```hpp
#pragma once

#include <sdkgenny/type.hpp>

namespace sdkgenny {
class Reference : public Type {
public:
    explicit Reference(std::string_view name);

    auto to() const { return m_to; }
    auto to(Type* to) {
        m_to = to;
        return this;
    }

    size_t size() const override { return sizeof(uintptr_t); }

    void generate_typename_for(std::ostream& os, const Object* obj) const override;

protected:
    Type* m_to{};
};
} // namespace sdkgenny
```

`include/sdkgenny/sdk.hpp`:

```hpp
#pragma once

#include <filesystem>
#include <fstream>
#include <memory>
#include <set>
#include <sstream>
#include <string>
#include <unordered_set>

#include <sdkgenny/enum.hpp>
#include <sdkgenny/function.hpp>
#include <sdkgenny/namespace.hpp>
#include <sdkgenny/struct.hpp>
#include <sdkgenny/type.hpp>
#include <sdkgenny/virtual_function.hpp>

namespace sdkgenny {
class Sdk : public Object {
public:
    Sdk();

    auto global_ns() const { return m_global_ns.get(); }

    auto preamble(std::string_view preamble) {
        m_preamble = preamble;
        return this;
    }
    auto postamble(std::string_view postamble) {
        m_postamble = postamble;
        return this;
    }

    auto include(std::string_view header) {
        m_includes.emplace(header);
        return this;
    }
    auto include_local(std::string_view header) {
        m_local_includes.emplace(header);
        return this;
    }

    void generate(const std::filesystem::path& sdk_path) const;

    const auto& header_extension() const { return m_header_extension; }
    auto header_extension(std::string_view ext) {
        m_header_extension = ext;
        return this;
    }

    const auto& source_extension() const { return m_source_extension; }
    auto source_extension(std::string_view ext) {
        m_source_extension = ext;
        return this;
    }

    const auto& generate_namespaces() const { return m_generate_namespaces; }
    auto generate_namespaces(bool gen_ns) {
        m_generate_namespaces = gen_ns;
        return this;
    }

    // These are intended to be used by either the genny parser or tooling such
    // as ReGenny.
    const auto& imports() const { return m_imports; }
    auto import(std::filesystem::path filepath) {
        m_imports.emplace(std::move(filepath));
        return this;
    }

protected:
    std::unique_ptr<Namespace> m_global_ns{std::make_unique<Namespace>("")};
    std::string m_preamble{};
    std::string m_postamble{};
    std::set<std::string> m_includes{};
    std::set<std::string> m_local_includes{};
    std::set<std::filesystem::path> m_imports{};
    std::string m_header_extension{".hpp"};
    std::string m_source_extension{".cpp"};
    bool m_generate_namespaces{true};

    void generate_namespace(const std::filesystem::path& sdk_path, Namespace* ns) const;

    template <typename T> void generate_header(const std::filesystem::path& sdk_path, T* obj) const {
        if (obj->skip_generation()) {
            return;
        }

        auto obj_inc_path = sdk_path / (obj->path() += m_header_extension);
        std::ofstream file_list{sdk_path / "file_list.txt", std::ios::app};
        file_list << "\"" << obj_inc_path.string() << "\" \\\n";
        std::filesystem::create_directories(obj_inc_path.parent_path());
        std::ofstream os{obj_inc_path};

        if (!m_preamble.empty()) {
            std::istringstream sstream{m_preamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }

        os << "#pragma once\n";

        for (auto&& include : m_includes) {
            os << "#include <" << include << ">\n";
        }

        for (auto&& include : m_local_includes) {
            os << "#include \"" << include << "\"\n";
        }

        std::unordered_set<Type*> types_to_include{};
        std::unordered_set<Type*> types_to_forward_decl{};
        std::set<std::filesystem::path> includes{};

        if (auto s = dynamic_cast<Struct*>(obj)) {
            auto deps = s->dependencies();
            types_to_include = deps.hard;
            types_to_forward_decl = deps.soft;
        }

        for (auto&& ty : types_to_include) {
            includes.emplace(ty->path() += m_header_extension);
        }

        for (auto&& inc : includes) {
            os << "#include \"" << std::filesystem::relative(inc, obj->path().parent_path()).string() << "\"\n";
        }

        for (auto&& type : types_to_forward_decl) {
            auto owners = type->owners<Namespace>();

            if (owners.size() > 1 && m_generate_namespaces) {
                std::reverse(owners.begin(), owners.end());

                os << "namespace ";

                for (auto&& owner : owners) {
                    if (owner->usable_name().empty()) {
                        continue;
                    }

                    os << owner->usable_name();

                    if (owner != owners.back()) {
                        os << "::";
                    }
                }

                os << " {\n";
            }

            if (auto s = dynamic_cast<Struct*>(type)) {
                s->generate_forward_decl(os);
            } else if (auto e = dynamic_cast<Enum*>(type)) {
                e->generate_forward_decl(os);
            }

            if (owners.size() > 1 && m_generate_namespaces) {
                os << "}\n";
            }
        }

        auto owners = obj->template owners<Namespace>();

        if (owners.size() > 1 && m_generate_namespaces) {
            std::reverse(owners.begin(), owners.end());

            os << "namespace ";

            for (auto&& owner : owners) {
                if (owner->usable_name().empty()) {
                    continue;
                }

                os << owner->usable_name();

                if (owner != owners.back()) {
                    os << "::";
                }
            }

            os << " {\n";
        }

        os << "#pragma pack(push, 1)\n";
        obj->generate(os);
        os << "#pragma pack(pop)\n";

        if (owners.size() > 1 && m_generate_namespaces) {
            os << "}\n";
        }

        if (!m_postamble.empty()) {
            std::istringstream sstream{m_postamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }
    }

    template <typename T> void generate_source(const std::filesystem::path& sdk_path, T* obj) const {
        if (obj->skip_generation()) {
            return;
        }

        // Skip generating a source file for an object with no functions.
        if (!obj->template has_any<Function>()) {
            return;
        }

        // Skip generating a source file for an object if all the functions it does have lack a procedure.
        std::unordered_set<Function*> functions{};
        obj->template get_all_in_children<Function>(functions);

        auto any_procedure = false;

        for (auto&& fn : functions) {
            if (!fn->procedure().empty()) {
                any_procedure = true;
                break;
            }
        }

        if (!any_procedure) {
            return;
        }

        auto obj_src_path = sdk_path / (obj->path() += m_source_extension);
        std::ofstream file_list{sdk_path / "file_list.txt", std::ios::app};
        file_list << "\"" << obj_src_path.string() << "\" \\\n";

        std::filesystem::create_directories(obj_src_path.parent_path());
        std::ofstream os{obj_src_path};

        if (!m_preamble.empty()) {
            std::istringstream sstream{m_preamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }

        std::unordered_set<Type*> types_to_include{};

        if (auto s = dynamic_cast<Struct*>(obj)) {
            auto deps = s->dependencies();
            types_to_include = deps.hard;
            types_to_include.merge(deps.soft);
            types_to_include.emplace(s);
        }

        for (auto&& fn : functions) {
            auto deps = fn->dependencies();
            types_to_include.merge(deps);
        }

        std::set<std::filesystem::path> includes{};

        for (auto&& ty : types_to_include) {
            includes.emplace(ty->path() += m_header_extension);
        }

        for (auto&& inc : includes) {
            os << "#include \"" << std::filesystem::relative(inc, obj->path().parent_path()).string() << "\"\n";
        }

        for (auto&& fn : functions) {
            // Skip pure virtual functions.
            if (fn->is_a<VirtualFunction>() && fn->procedure().empty()) {
                continue;
            }

            fn->generate_source(os);
        }

        if (!m_postamble.empty()) {
            std::istringstream sstream{m_postamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }
    }

    template <typename T> void generate(const std::filesystem::path& sdk_path, Namespace* ns) const {
        for (auto&& obj : ns->get_all<T>()) {
            generate_header(sdk_path, obj);
            generate_source(sdk_path, obj);
        }
    }
};

} // namespace sdkgenny
```

`include/sdkgenny/static_function.hpp`:

```hpp
#pragma once

#include <sdkgenny/function.hpp>

namespace sdkgenny {
class StaticFunction : public Function {
public:
    explicit StaticFunction(std::string_view name);

    void generate(std::ostream& os) const override;
};
} // namespace sdkgenny
```

`include/sdkgenny/struct.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <map>
#include <ostream>
#include <string>
#include <unordered_set>

#include <sdkgenny/type.hpp>

namespace sdkgenny {
class Variable;
class Constant;
class Class;
class Enum;
class EnumClass;
class Function;
class VirtualFunction;
class StaticFunction;

class Struct : public Type {
public:
    explicit Struct(std::string_view name);

    Variable* variable(std::string_view name);
    Constant* constant(std::string_view name);

    // Returns a map of bit_offset, bitfield_variable at a given offset. Optionally, it will ignore a given variable
    // while constructing the map.
    std::map<uintptr_t, Variable*> bitfield(uintptr_t offset, Variable* ignore = nullptr) const;

    Struct* struct_(std::string_view name);
    Class* class_(std::string_view name);
    Enum* enum_(std::string_view name);
    EnumClass* enum_class(std::string_view name);
    Function* function(std::string_view name);
    VirtualFunction* virtual_function(std::string_view name);
    StaticFunction* static_function(std::string_view name);

    const std::vector<Struct*>& parents() const;
    Struct* parent(Struct* parent);

    size_t size() const override;
    auto size(int size) {
        m_size = size;
        return this;
    }

    virtual void generate_forward_decl(std::ostream& os) const;
    virtual void generate(std::ostream& os) const;

    struct Dependencies {
        std::unordered_set<Type*> hard{};
        std::unordered_set<Type*> soft{};
    };

    Dependencies dependencies();

    template <typename T> T* find_in_parents(std::string_view name) {
        for (auto&& parent : m_parents) {
            if (auto obj = parent->find<T>(name)) {
                return obj;
            }
        }

        return nullptr;
    }

protected:
    std::vector<Struct*> m_parents{};

    int vtable_size() const;

    template <typename T, typename... TArgs> T* find_or_add_unique(std::string_view name, TArgs... args) {
        if (auto search = find<T>(name); search != nullptr) {
            return search;
        }

        std::string fixed_name{};
        auto num_collisions = 0;
        auto has_collision = false;

        do {
            has_collision = false;

            if (find_in_parents<Object>(fixed_name.empty() ? name : fixed_name) != nullptr) {
                fixed_name = name;
                fixed_name += std::to_string(num_collisions);
                ++num_collisions;
                has_collision = true;
            }
        } while (has_collision);

        if (num_collisions == 0) {
            return add(std::make_unique<T>(name, args...));
        }

        return add(std::make_unique<T>(fixed_name, args...));
    }

    void generate_inheritance(std::ostream& os) const;
    void generate_bitfield(std::ostream& os, uintptr_t offset) const;
    void generate_internal(std::ostream& os) const;
};
} // namespace sdkgenny
```

`include/sdkgenny/type.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <ostream>
#include <string_view>

#include <sdkgenny/typename.hpp>

namespace sdkgenny {
class Reference;
class Pointer;
class Array;

class Type : public Typename {
public:
    explicit Type(std::string_view name);

    virtual void generate_variable_postamble(std::ostream& os [[maybe_unused]]) const {}

    virtual size_t size() const { return m_size; }
    auto size(size_t size) {
        m_size = size;
        return this;
    }

    Reference* ref();
    Pointer* ptr();
    Array* array_(size_t count = 0);

protected:
    size_t m_size{};
};
} // namespace sdkgenny

```

`include/sdkgenny/typename.hpp`:

```hpp
#pragma once

#include <sdkgenny/object.hpp>

namespace sdkgenny {
class Typename : public Object {
public:
    explicit Typename(std::string_view name);

    virtual void generate_typename_for(std::ostream& os, const Object* obj) const;

    bool simple_typename_generation() const { return m_simple_typename_generation; }
    Typename* simple_typename_generation(bool simple_generation) {
        m_simple_typename_generation = simple_generation;
        return this;
    }

protected:
    bool m_simple_typename_generation{};
};
} // namespace sdkgenny
```

`include/sdkgenny/variable.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <ostream>
#include <string_view>

#include <sdkgenny/object.hpp>
#include <sdkgenny/type.hpp>

namespace sdkgenny {
class Variable : public Object {
public:
    explicit Variable(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    // Helper that recurses though owners to find the correct type.
    auto type(std::string_view name) {
        m_type = find_in_owners_or_add<Type>(name);
        return this;
    }

    auto offset() const { return m_offset; }
    auto offset(uintptr_t offset) {
        m_offset = offset;
        return this;
    }

    // Sets the offset to be after the last variable in the struct.
    Variable* append();

    virtual size_t size() const;

    auto end() const { return offset() + size(); }

    auto bit_size(size_t size) {
        // assert(size <= m_type->size() * CHAR_BIT);
        m_bit_size = size;
        return this;
    }
    auto bit_size() const { return m_bit_size; }

    auto bit_offset(uintptr_t offset) {
        // assert(offset < m_type->size() * CHAR_BIT);
        m_bit_offset = offset;
        return this;
    }
    auto bit_offset() const { return m_bit_offset; }

    auto is_bitfield() const { return m_bit_size != 0; }

    // Call this after append() or offset()
    Variable* bit_append();

    virtual void generate(std::ostream& os) const;

protected:
    Type* m_type{};
    uintptr_t m_offset{};
    size_t m_bit_size{};
    uintptr_t m_bit_offset{};
};
} // namespace sdkgenny
```

`include/sdkgenny/virtual_function.hpp`:

```hpp
#pragma once

#include <cstdint>

#include <sdkgenny/function.hpp>

namespace sdkgenny {
class VirtualFunction : public Function {
public:
    explicit VirtualFunction(std::string_view name);

    auto vtable_index() const { return m_vtable_index; }
    auto vtable_index(uint32_t vtable_index) {
        m_vtable_index = vtable_index;
        return this;
    }

    void generate(std::ostream& os) const override;

protected:
    uint32_t m_vtable_index{};
};
} // namespace sdkgenny
```

`include/sdkgenny_ida.hpp`:

```hpp
// SdkGenny - Genny.hpp - A single file header framework for generating C++ compatible SDKs
// https://github.com/cursey/sdkgenny
// sdkgenny_ida.hpp is an optional extra for SdkGenny that generates output intended to be consumed by IDA.

#pragma once

#include <sdkgenny.hpp>

namespace genny::ida {
// Does a destructive transformation to the Sdk to make it's output parsable by IDA.
inline void transform(Sdk& sdk) {
    auto g = sdk.global_ns();
    std::unordered_set<EnumClass*> enum_classes{};

    // Make plain enum types for all enum classes.
    g->get_all_in_children<EnumClass>(enum_classes);

    // We have to remove the enum class from it's owner before we can add a normal enum with the same name to it.
    // Variables may still reference the enum class however so we must keep them alive until all variables have had
    // their types changed to the normal enum versions.
    std::vector<std::unique_ptr<Object>> enumclass_keepalive{};

    for (auto& e : enum_classes) {
        Enum* new_enum{};
        auto owner = e->direct_owner();

        if (auto ns_owner = dynamic_cast<Namespace*>(owner)) {
            enumclass_keepalive.emplace_back(ns_owner->remove(e));
            new_enum = ns_owner->enum_(e->name());
        } else if (auto owner_struct = dynamic_cast<Struct*>(owner)) {
            enumclass_keepalive.emplace_back(owner_struct->remove(e));
            new_enum = owner_struct->enum_(e->name());
        } else {
            continue;
        }

        for (auto&& [name, value] : e->values()) {
            new_enum->value(name, value);
        }

        new_enum->type(e->type());
    }

    std::unordered_set<Type*> types{};
    std::unordered_map<Type*, std::string> new_names{};

    g->get_all_in_children<Type>(types);

    // Go through all the types making new names for them (but not setting them yet) and removing things like their
    // functions/constants and fixing their enum class types etc.
    for (auto&& t : types) {
        if (!t->is_a<Struct>() && !t->is_a<Enum>()) {
            continue;
        }

        auto owners = t->owners<Object>();
        auto new_name = t->usable_name();

        for (auto&& owner : owners) {
            if (!owner->usable_name().empty()) {
                new_name = owner->usable_name() + "::" + new_name;
            }
        }

        new_names.emplace(t, std::move(new_name));

        t->simple_typename_generation(true);
        t->remove_all<Function>();
        t->remove_all<Constant>();

        // Convert all enum classes to normal enums
        for (auto&& v : t->get_all<Variable>()) {
            auto v_t = v->type();

            if (!v_t->is_a<EnumClass>()) {
                continue;
            }

            auto owner = v_t->direct_owner();

            if (auto owner_ns = dynamic_cast<Namespace*>(owner)) {
                v->type(owner_ns->enum_(v_t->name()));
            } else if (auto owner_struct = dynamic_cast<Struct*>(owner)) {
                v->type(owner_struct->enum_(v_t->name()));
            }
        }
    }

    // Now that all the new names have been built we can set them.
    for (auto&& [t, name] : new_names) {
        t->usable_name = [new_name = std::move(name)] { return new_name; };

        if (!t->direct_owner()->is_a<Struct>()) {
            t->usable_name_decl = t->usable_name;
        }
    }

    sdk.generate_namespaces(false);
}

} // namespace genny::ida

```

`include/sdkgenny_parser.hpp`:

```hpp
// SdkGenny - A framework for generating C++ compatible SDKs
// https://github.com/cursey/sdkgenny
// sdkgenny_parser.hpp is an optional extra for SdkGenny that parses .genny formatted files into a usable genny::Sdk.

#pragma once

#include <cstdlib>
#include <optional>
#include <stack>

#include <tao/pegtl.hpp>

#include <sdkgenny.hpp>

namespace sdkgenny::parser {
using namespace tao::pegtl;

struct ShortComment : disable<two<'/'>, until<eolf>> {};
struct LongComment : disable<one<'/'>, one<'*'>, until<seq<one<'*'>, one<'/'>>>> {};
struct Comment : sor<ShortComment, LongComment> {};
struct Sep : sor<space, Comment> {};
struct Seps : star<Sep> {};

struct Endl : star<one<';'>> {};

struct HexNum : seq<one<'0'>, one<'x'>, plus<xdigit>> {};
struct DecNum : plus<digit> {};
struct Num : sor<HexNum, DecNum> {};

struct Metadata : plus<not_one<',', ']'>> {};
struct MetadataDecl : if_must<two<'['>, Seps, list<Metadata, one<','>, Sep>, Seps, two<']'>> {};

struct IncludeId : TAO_PEGTL_STRING("#include") {};
struct IncludePath : plus<not_one<'"', '>'>> {};
struct IncludeLocalPath : seq<one<'"'>, IncludePath, one<'"'>> {};
struct IncludeGlobalPath : seq<one<'<'>, IncludePath, one<'>'>> {};
struct IncludeDecl : if_must<IncludeId, Seps, sor<IncludeLocalPath, IncludeGlobalPath>, Endl> {};

struct ImportId : TAO_PEGTL_STRING("import") {};
struct ImportPath : plus<not_one<'"'>> {};
struct ImportDecl : if_must<ImportId, Seps, one<'"'>, ImportPath, one<'"'>, Endl> {};

struct NsId : TAO_PEGTL_STRING("namespace") {};
struct NsName : identifier {};
struct NsNameList : list_must<NsName, one<'.'>, Sep> {};
struct NsDecl : if_must<NsId, Seps, opt<NsNameList>> {};
struct NsExpr;
struct EnumExpr;
struct StructExpr;
struct NsExprs : list<sor<Sep, NsExpr, EnumExpr, StructExpr>, Seps> {};
struct NsExpr : if_must<NsDecl, Seps, one<'{'>, Seps, opt<NsExprs>, Seps, one<'}'>, Endl> {};

struct TypeId : TAO_PEGTL_STRING("type") {};
struct TypeName : identifier {};
struct TypeSize : Num {};
struct TypeDecl : if_must<TypeId, Seps, TypeName, Seps, TypeSize, Seps, opt<MetadataDecl>, Endl> {};

struct EnumVal : Num {};
struct EnumValName : identifier {};
struct EnumValDecl : seq<EnumValName, Seps, one<'='>, Seps, EnumVal> {};
struct EnumVals : seq<list<EnumValDecl, one<','>, Sep>, opt<one<','>>> {};
struct EnumId : TAO_PEGTL_STRING("enum") {};
struct EnumClassId : TAO_PEGTL_STRING("class") {};
struct EnumName : identifier {};
struct EnumType : identifier {};
struct EnumDecl
    : seq<EnumId, Seps, opt<EnumClassId>, Seps, EnumName, Seps, opt<one<':'>, Seps, EnumType>, Seps, one<'{'>> {};
struct EnumExpr : if_must<EnumDecl, Seps, EnumVals, Seps, one<'}'>, Endl> {};

struct StructPrivacyId : sor<TAO_PEGTL_STRING("public"), TAO_PEGTL_STRING("private"), TAO_PEGTL_STRING("protected")> {};
struct StructId : sor<TAO_PEGTL_STRING("struct"), TAO_PEGTL_STRING("class")> {};
struct StructName : identifier {};
struct StructParentPart : identifier {};
struct StructParent : seq<opt<disable<StructPrivacyId>>, Seps, list_must<StructParentPart, one<'.'>>> {};
struct StructParentList : list<StructParent, one<','>, Sep> {};
struct StructParentListDecl : seq<one<':'>, Seps, StructParentList> {};
struct StructSize : Num {};
struct StructDecl
    : seq<StructId, Seps, StructName, Seps, opt<StructParentListDecl>, Seps, opt<StructSize>, Seps, one<'{'>> {};
struct StructPrivacyDecl : disable<StructPrivacyId, Seps, one<':'>> {};
struct StructExpr;
struct FnDecl;
struct VarDecl;
struct StructExprs : list<sor<StructPrivacyDecl, EnumExpr, StructExpr, FnDecl, VarDecl>, Seps> {};
struct StructExpr : if_must<StructDecl, Seps, opt<StructExprs>, Seps, one<'}'>, Endl> {};

struct VarTypeNamePart : identifier {};
struct VarTypeName : list_must<VarTypeNamePart, one<'.'>> {};
struct VarTypePtr : one<'*'> {};
struct VarTypeArrayCount : Num {};
struct VarTypeArray : if_must<one<'['>, VarTypeArrayCount, one<']'>> {};
struct VarTypeHintId : sor<TAO_PEGTL_STRING("struct"), TAO_PEGTL_STRING("class"), TAO_PEGTL_STRING("enum class"),
                           TAO_PEGTL_STRING("enum")> {};
struct VarType : seq<opt<VarTypeHintId>, Seps, VarTypeName, Seps, star<VarTypePtr>, star<VarTypeArray>> {};
struct VarName : identifier {};
struct VarOffset : Num {};
struct VarOffsetDecl : if_must<one<'@'>, Seps, VarOffset> {};
struct VarDelta : Num {};
struct VarDeltaDecl : if_must<one<'+'>, Seps, VarDelta> {};
struct VarOffsetDeltaDecl : sor<VarOffsetDecl, VarDeltaDecl> {};
struct VarBitSize : Num {};
struct VarBitSizeDecl : seq<one<':'>, Seps, VarBitSize> {};
struct VarDecl : seq<VarType, Seps, VarName, star<VarTypeArray>, Seps, opt<VarBitSizeDecl>, Seps,
                     opt<VarOffsetDeltaDecl>, Seps, opt<MetadataDecl>, Endl> {};

struct FnVoidId : TAO_PEGTL_STRING("void") {};
struct FnRetType : VarType {};
struct FnRet : sor<FnVoidId, FnRetType> {};
struct FnName : identifier {};
struct FnParamType : VarType {};
struct FnParamName : identifier {};
struct FnParam : seq<FnParamType, Seps, FnParamName> {};
struct FnParamList : list_must<FnParam, one<','>, Sep> {};
struct FnParams : if_must<one<'('>, Seps, opt<FnParamList>, Seps, one<')'>> {};
struct FnStaticId : TAO_PEGTL_STRING("static") {};
struct FnVirtualId : TAO_PEGTL_STRING("virtual") {};
struct FnPrefix : sor<FnStaticId, FnVirtualId> {};
struct FnVirtualIndex : Num {};
struct FnDecl : seq<opt<FnPrefix>, Seps, FnRet, Seps, FnName, Seps, FnParams, Seps,
                    opt_must<one<'@'>, Seps, FnVirtualIndex>, Endl> {};

struct StaticAssert : disable<TAO_PEGTL_STRING("static_assert"), until<one<';'>>> {};

struct Decl : sor<IncludeDecl, ImportDecl, TypeDecl, NsExpr, EnumExpr, StructExpr, StaticAssert> {};
struct Grammar : until<eof, must<sor<eol, Sep, Decl>>> {};

struct State {
    std::filesystem::path filepath{std::filesystem::current_path()};
    std::vector<Object*> parents{};
    std::stack<int> namespace_depth{};

    std::vector<std::string> metadata_parts{};
    std::vector<std::string> metadata{};

    std::string include_path{};
    bool include_local{};

    std::string import_path{};

    std::vector<std::string> ns_parts{};
    std::vector<std::string> ns{};

    std::string type_name{};
    int type_size{};

    std::string enum_name{};
    std::string enum_type{};
    bool enum_class{};
    std::string enum_val_name{};
    uint32_t enum_val{};
    std::vector<std::tuple<std::string, uint64_t>> enum_vals{};

    std::string struct_name{};
    std::vector<std::string> struct_parent{};
    std::vector<sdkgenny::Struct*> struct_parents{};
    std::optional<size_t> struct_size{};
    bool struct_is_class{};

    sdkgenny::Type* cur_type{};
    std::string var_type_hint{};
    std::vector<std::string> var_type{};
    std::optional<size_t> var_type_array_count{};
    std::vector<size_t> var_type_array_counts{};
    std::string var_name{};
    std::optional<uintptr_t> var_offset{};
    std::optional<uintptr_t> var_delta{};
    std::optional<uintptr_t> var_bit_offset{};
    std::optional<size_t> var_bit_size{};

    sdkgenny::Type* fn_ret_type{};
    std::string fn_name{};
    bool fn_is_static{};
    bool fn_is_virtual{};
    std::optional<uint32_t> fn_virtual_index{};

    struct Param {
        sdkgenny::Type* type{};
        std::string name{};
    };

    Param cur_param{};
    std::vector<Param> fn_params{};

    // Searches for the type identified by a vector of names.
    template <typename T> T* lookup(const std::vector<std::string>& names) {
        std::function<T*(Object*, int)> search = [&](Object* parent, int i) -> T* {
            if (names.empty()) {
                return dynamic_cast<T*>(parents.front());
            } else if (i >= names.size()) {
                return nullptr;
            }

            const auto& name = names[i];

            // Search for the name.
            auto child = parent->find<Object>(name);

            if (child == nullptr) {
                return nullptr;
            }

            // We found the name. Is this the type we were looking for?
            if (i == names.size() - 1) {
                return dynamic_cast<T*>(child);
            }

            return search(child, ++i);
        };

        for (auto it = parents.rbegin(); it != parents.rend(); ++it) {
            if (auto type = search(*it, 0)) {
                return type;
            }
        }

        return nullptr;
    }
};

template <typename Rule> struct Action : nothing<Rule> {};

template <> struct Action<Metadata> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.metadata_parts.emplace_back(in.string_view());
    }
};

template <> struct Action<MetadataDecl> {
    template <typename Input> static void apply(const Input& in, State& s) { s.metadata = std::move(s.metadata_parts); }
};

template <> struct Action<IncludePath> {
    template <typename Input> static void apply(const Input& in, State& s) { s.include_path = in.string_view(); }
};

template <> struct Action<IncludeLocalPath> {
    template <typename Input> static void apply(const Input& in, State& s) { s.include_local = true; }
};

template <> struct Action<IncludeGlobalPath> {
    template <typename Input> static void apply(const Input& in, State& s) { s.include_local = false; }
};

template <> struct Action<IncludeDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (s.include_local) {
            s.parents.front()->owner<Sdk>()->include_local(s.include_path);
        } else {
            s.parents.front()->owner<Sdk>()->include(s.include_path);
        }

        s.include_path.clear();
        s.include_local = false;
    }
};

template <> struct Action<ImportPath> {
    template <typename Input> static void apply(const Input& in, State& s) { s.import_path = in.string_view(); }
};

template <> struct Action<ImportDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        auto import_path = std::move(s.import_path);
        auto filepath = (s.filepath.has_extension() ? s.filepath.parent_path() : s.filepath) / import_path;

        if (!filepath.is_absolute()) {
            filepath = std::filesystem::absolute(filepath);
        }

        // Return early if we've already imported this file.
        auto& imports = s.parents.front()->owner<Sdk>()->imports();

        if (imports.find(filepath) != imports.end()) {
            return;
        }

        auto backup_filepath = s.filepath;

        try {
            auto newstate = std::make_unique<State>();
            newstate->filepath = filepath;
            newstate->parents.push_back(s.parents.front());
            file_input f{newstate->filepath};

            if (!parse<sdkgenny::parser::Grammar, sdkgenny::parser::Action>(f, *newstate)) {
                throw parse_error{"Failed to parse file '" + import_path + "'", in};
            }

            s.parents.front()->owner<Sdk>()->import(newstate->filepath);
        } catch (const parse_error& e) {
            throw e;
        } catch (const std::exception& e) {
            throw parse_error{std::string{"Failed to import file: "} + e.what(), in};
        }

        s.filepath = backup_filepath;
    }
};

template <> struct Action<NsName> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.ns_parts.emplace_back(in.string_view());
    }
};

template <> struct Action<NsNameList> {
    template <typename Input> static void apply(const Input& in, State& s) { s.ns = std::move(s.ns_parts); }
};

template <> struct Action<NsDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (auto cur_ns = dynamic_cast<Namespace*>(s.parents.back())) {
            auto depth = 0;

            for (auto&& ns : s.ns) {
                cur_ns = cur_ns->namespace_(ns);
                s.parents.push_back(cur_ns);
                ++depth;
            }

            s.namespace_depth.push(depth);
            s.ns.clear();
        } else {
            throw parse_error{"Can only declare a namespace within the context of another namespace", in};
        }
    }
};

template <> struct Action<NsExpr> {
    template <typename Input> static void apply(const Input& in, State& s) {
        auto depth = s.namespace_depth.top();

        s.namespace_depth.pop();

        for (auto i = 0; i < depth; ++i) {
            s.parents.pop_back();
        }
    }
};

template <> struct Action<TypeSize> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.type_size = std::stoi(in.string(), nullptr, 0);
    }
};

template <> struct Action<TypeName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.type_name = in.string_view(); }
};

template <> struct Action<TypeDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (auto ns = dynamic_cast<Namespace*>(s.parents.back())) {
            auto type = ns->type(s.type_name);

            type->size(s.type_size);

            if (!s.metadata.empty()) {
                type->metadata() = std::move(s.metadata);
            }

            s.type_name.clear();
            s.type_size = -1;
        } else {
            throw parse_error{"Can only declare a type within the context of a namespace", in};
        }
    }
};

template <> struct Action<EnumName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_name = in.string_view(); }
};

template <> struct Action<EnumType> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_type = in.string_view(); }
};

template <> struct Action<EnumClassId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_class = true; }
};

template <> struct Action<EnumExpr> {
    template <typename Input> static void apply(const Input& in, State& s) {
        Enum* enum_{};

        if (auto p = dynamic_cast<Namespace*>(s.parents.back())) {
            if (s.enum_class) {
                enum_ = p->enum_class(s.enum_name);
            } else {
                enum_ = p->enum_(s.enum_name);
            }
        } else if (auto p = dynamic_cast<Struct*>(s.parents.back())) {
            if (s.enum_class) {
                enum_ = p->enum_class(s.enum_name);
            } else {
                enum_ = p->enum_(s.enum_name);
            }
        } else {
            throw parse_error{"Cannot create an enum here. Parent must be a namespace or a struct.", in};
        }

        for (auto&& [name, val] : s.enum_vals) {
            enum_->value(name, val);
        }

        enum_->type(s.lookup<Type>({s.enum_type}));

        s.enum_vals.clear();
        s.enum_name.clear();
        s.enum_type.clear();
        s.enum_class = false;
    }
};

template <> struct Action<EnumVal> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.enum_val = std::stoul(in.string(), nullptr, 0);
    }
};

template <> struct Action<EnumValName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_val_name = in.string_view(); }
};

template <> struct Action<EnumValDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.enum_vals.emplace_back(s.enum_val_name, s.enum_val);
    }
};

template <> struct Action<StructId> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.struct_is_class = in.string_view() == "class";
    }
};

template <> struct Action<StructName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.struct_name = in.string_view(); }
};

template <> struct Action<StructParentPart> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.struct_parent.emplace_back(in.string_view());
    }
};

template <> struct Action<StructParent> {
    template <typename Input> static void apply(const Input& in, State& s) {
        auto parent = s.lookup<sdkgenny::Struct>(s.struct_parent);

        if (parent == nullptr) {
            throw parse_error{"Can't find parent struct type with name '" + s.struct_parent.back() + "'", in};
        }

        s.struct_parents.emplace_back(parent);
        s.struct_parent.clear();
    }
};

template <> struct Action<StructSize> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.struct_size = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<StructDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        Struct* struct_{};

        if (auto p = dynamic_cast<Namespace*>(s.parents.back())) {
            if (s.struct_is_class) {
                struct_ = p->class_(s.struct_name);
            } else {
                struct_ = p->struct_(s.struct_name);
            }
        } else if (auto p = dynamic_cast<Struct*>(s.parents.back())) {
            if (s.struct_is_class) {
                struct_ = p->class_(s.struct_name);
            } else {
                struct_ = p->struct_(s.struct_name);
            }
        } else {
            throw parse_error{"Structs can only be declared within the context of a namespace or another struct", in};
        }

        for (auto&& parent : s.struct_parents) {
            struct_->parent(parent);
        }

        if (s.struct_size) {
            struct_->size(*s.struct_size);
        }

        s.parents.push_back(struct_);
        s.struct_name.clear();
        s.struct_parents.clear();
        s.struct_size = std::nullopt;
        s.struct_is_class = false;
    }
};

template <> struct Action<StructExpr> {
    template <typename Input> static void apply(const Input& in, State& s) { s.parents.pop_back(); }
};

template <> struct Action<VarTypeHintId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.var_type_hint = in.string_view(); }
};

template <> struct Action<VarTypeNamePart> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_type.emplace_back(in.string_view());
    }
};

template <> struct Action<VarTypeName> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.cur_type = s.lookup<Type>(s.var_type);

        if (s.cur_type == nullptr && !s.var_type_hint.empty()) {
            auto owner_type = s.var_type;
            owner_type.pop_back();
            auto owner = s.lookup<Namespace>(owner_type);

            if (owner != nullptr) {
                if (s.var_type_hint == "struct") {
                    s.cur_type = owner->struct_(s.var_type.back());
                } else if (s.var_type_hint == "class") {
                    s.cur_type = owner->class_(s.var_type.back());
                } else if (s.var_type_hint == "enum") {
                    s.cur_type = owner->enum_(s.var_type.back());
                } else if (s.var_type_hint == "enum class") {
                    s.cur_type = owner->enum_class(s.var_type.back());
                }
            }
        }

        if (s.cur_type == nullptr) {
            throw parse_error{"Can't find type with name '" + s.var_type.back() + "'", in};
        }

        s.var_type.clear();
        s.var_type_array_counts.clear();
    }
};

template <> struct Action<VarTypePtr> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (s.cur_type == nullptr) {
            throw parse_error{"The current type is null", in};
        }

        s.cur_type = s.cur_type->ptr();
    }
};

template <> struct Action<VarTypeArrayCount> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_type_array_count = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarTypeArray> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (!s.var_type_array_count) {
            throw parse_error{"The array count is invalid", in};
        }

        s.var_type_array_counts.emplace_back(*s.var_type_array_count);
        s.var_type_array_count = std::nullopt;
    }
};

template <> struct Action<VarName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.var_name = in.string_view(); }
};

template <> struct Action<VarOffset> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_offset = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarDelta> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_delta = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarBitSize> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_bit_size = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (s.cur_type == nullptr) {
            throw parse_error{"The current type is null", in};
        }

        // Make sure the variable we're parsing isn't the same type as one of its parents.
        if (!s.cur_type->is_a<Reference>()) {
            for (auto it = s.parents.rbegin(); it != s.parents.rend(); ++it) {
                if (s.cur_type == *it) {
                    throw parse_error{"The variable cannot be the same type as its parent.", in};
                }
            }
        }

        // Reverse the order because we want to adhear to how multi-dimensional arrays are declared in C/C++.
        std::reverse(s.var_type_array_counts.begin(), s.var_type_array_counts.end());

        for (auto&& count : s.var_type_array_counts) {
            s.cur_type = s.cur_type->array_(count);
        }

        s.var_type_array_counts.clear();

        if (auto struct_ = dynamic_cast<Struct*>(s.parents.back())) {
            auto var = struct_->variable(s.var_name);

            var->type(s.cur_type);

            if (s.var_bit_size) {
                var->bit_size(*s.var_bit_size);
            }

            if (s.var_offset) {
                var->offset(*s.var_offset);
            } else {
                var->append();

                if (s.var_delta) {
                    var->offset(var->offset() + *s.var_delta);
                }
            }

            if (var->is_bitfield()) {
                var->bit_append();
            }

            if (!s.metadata.empty()) {
                var->metadata() = std::move(s.metadata);
            }

            s.var_name.clear();
            s.cur_type = nullptr;
            s.var_offset = std::nullopt;
            s.var_delta = std::nullopt;
            s.var_bit_size = std::nullopt;
            s.var_bit_offset = std::nullopt;
            s.var_type_hint.clear();
        } else {
            throw parse_error{"Can't declare a variable outside of a struct", in};
        }
    }
};

template <> struct Action<FnRetType> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_ret_type = s.cur_type; }
};

template <> struct Action<FnName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_name = in.string_view(); }
};

template <> struct Action<FnParamType> {
    template <typename Input> static void apply(const Input& in, State& s) { s.cur_param.type = s.cur_type; }
};

template <> struct Action<FnParamName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.cur_param.name = in.string_view(); }
};

template <> struct Action<FnParam> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.fn_params.emplace_back(std::move(s.cur_param));
    }
};

template <> struct Action<FnStaticId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_is_static = true; }
};

template <> struct Action<FnVirtualId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_is_virtual = true; }
};

template <> struct Action<FnVirtualIndex> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (!s.fn_is_virtual) {
            throw parse_error{"Only virtual methods can specify a virtual index", in};
        }

        s.fn_virtual_index = std::stoul(in.string(), nullptr, 0);
    }
};

template <> struct Action<FnDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (auto struct_ = dynamic_cast<Struct*>(s.parents.back())) {
            Function* fn{};

            if (s.fn_is_static) {
                fn = struct_->static_function(s.fn_name);
            } else if (s.fn_is_virtual) {
                fn = struct_->virtual_function(s.fn_name);

                if (s.fn_virtual_index) {
                    dynamic_cast<VirtualFunction*>(fn)->vtable_index(*s.fn_virtual_index);
                }
            } else {
                fn = struct_->function(s.fn_name);
            }

            if (s.fn_ret_type) {
                fn->returns(s.fn_ret_type);
            }

            fn->defined(false);

            for (auto&& param : s.fn_params) {
                fn->param(param.name)->type(param.type);
            }

            s.fn_name.clear();
            s.fn_ret_type = nullptr;
            s.fn_params.clear();
            s.fn_is_static = false;
            s.fn_is_virtual = false;
            s.fn_virtual_index = std::nullopt;
        } else {
            throw parse_error{"Can't declare a function outside of a struct", in};
        }
    }
};
} // namespace sdkgenny::parser

```

`src/array.cpp`:

```cpp
#include <sdkgenny/array.hpp>

namespace sdkgenny {
Array::Array(std::string_view name) : Type{name} {
}

Array* Array::count(size_t count) {
    // Fix the name of this array type.
    if (m_of != nullptr && count != m_count) {
        const auto& base = m_of->name();
        auto first_brace = base.find_first_of('[');
        auto head = base.substr(0, first_brace);
        std::string tail{};

        if (first_brace != std::string::npos) {
            tail = base.substr(first_brace);
        }

        m_name = head + '[' + std::to_string(count) + ']' + tail;
    }

    m_count = count;

    return this;
}

size_t Array::size() const {
    if (m_of == nullptr) {
        return 0;
    }

    return m_of->size() * m_count;
}

void Array::generate_typename_for(std::ostream& os, const Object* obj) const {
    m_of->generate_typename_for(os, obj);
}

void Array::generate_variable_postamble(std::ostream& os) const {
    os << "[" << std::dec << m_count << "]";
    m_of->generate_variable_postamble(os);
}
} // namespace sdkgenny
```

`src/class.cpp`:

```cpp
#include <sdkgenny/class.hpp>

namespace sdkgenny {
Class::Class(std::string_view name) : Struct{name} {
}

void Class::generate_forward_decl(std::ostream& os) const {
    os << "class " << usable_name_decl() << ";\n";
}

void Class::generate(std::ostream& os) const {
    generate_comment(os);
    os << "class " << usable_name_decl();
    generate_inheritance(os);
    os << " {\n";

    if (!m_children.empty()) {
        os << "public:\n";
    }

    generate_internal(os);

    os << "}; // Size: 0x" << std::hex << size() << "\n";
}
} // namespace sdkgenny

```

`src/constant.cpp`:

```cpp
#include <sdkgenny/type.hpp>

#include <sdkgenny/constant.hpp>

namespace sdkgenny {
Constant::Constant(std::string_view name) : Object{name} {
}

Constant* Constant::type(std::string_view name) {
    m_type = find_in_owners_or_add<Type>(name);
    return this;
}

Constant* Constant::string(const std::string& value) {
    m_value = "\"" + value + "\"";
    return this;
}

void Constant::generate(std::ostream& os) const {
    generate_comment(os);
    generate_metadata(os);
    os << "static constexpr ";
    m_type->generate_typename_for(os, this);
    os << " " << usable_name();
    m_type->generate_variable_postamble(os);
    os << " = " << m_value << ";";
}
} // namespace sdkgenny
```

`src/detail/indent.cpp`:

```cpp
#include <ostream>

#include <sdkgenny/detail/indent.hpp>

namespace sdkgenny::detail {
Indent::Indent(std::streambuf* dest, int indent) : m_dest{dest}, m_indent(indent, ' ') {
}

Indent::Indent(std::ostream& dest, int indent) : m_dest{dest.rdbuf()}, m_indent(indent, ' '), m_owner{&dest} {
    m_owner->rdbuf(this);
}

Indent::~Indent() {
    if (m_owner != nullptr) {
        m_owner->rdbuf(m_dest);
    }
}

int Indent::overflow(int ch) {
    if (m_is_at_start_of_line && ch != '\n') {
        m_dest->sputn(m_indent.data(), m_indent.size());
    }
    m_is_at_start_of_line = ch == '\n';
    return m_dest->sputc(static_cast<char>(ch));
}
} // namespace sdkgenny::detail
```

`src/enum.cpp`:

```cpp
#include <sdkgenny/detail/indent.hpp>

#include <sdkgenny/enum.hpp>

namespace sdkgenny {
Enum::Enum(std::string_view name) : Type{name} {
}

Enum* Enum::value(std::string_view name, uint64_t value) {
    for (auto&& [val_name, val_val] : m_values) {
        if (val_name == name) {
            val_val = value;
            return this;
        }
    }

    m_values.emplace_back(name, value);
    return this;
}

size_t Enum::size() const {
    if (m_type == nullptr) {
        return sizeof(int);
    } else {
        return m_type->size();
    }
}

void Enum::generate_forward_decl(std::ostream& os) const {
    os << "enum " << usable_name_decl() << ";\n";
}

void Enum::generate(std::ostream& os) const {
    generate_comment(os);
    os << "enum " << usable_name_decl();
    generate_type(os);
    os << " {\n";
    generate_enums(os);
    os << "};\n";
}

void Enum::generate_type(std::ostream& os) const {
    if (m_type != nullptr) {
        os << " : ";
        m_type->generate_typename_for(os, this);
    }
}

void Enum::generate_enums(std::ostream& os) const {
    detail::Indent _{os};

    for (auto&& [name, value] : m_values) {
        if (!m_type || 1ull << (m_type->size() * 8) > value)
            os << name << " = " << value << ",\n";
    }
}
} // namespace sdkgenny
```

`src/enum_class.cpp`:

```cpp
#include <sdkgenny/enum_class.hpp>

namespace sdkgenny {
EnumClass::EnumClass(std::string_view name) : Enum{name} {
}

void EnumClass::generate_forward_decl(std::ostream& os) const {
    os << "enum class " << usable_name_decl() << ";\n";
}
void EnumClass::generate(std::ostream& os) const {
    generate_comment(os);
    os << "enum class " << usable_name_decl();
    generate_type(os);
    os << " {\n";
    generate_enums(os);
    os << "};\n";
}
} // namespace sdkgenny
```

`src/function.cpp`:

```cpp
#include <sdkgenny/detail/indent.hpp>
#include <sdkgenny/parameter.hpp>
#include <sdkgenny/type.hpp>

#include <sdkgenny/function.hpp>

namespace sdkgenny {
Function::Function(std::string_view name) : Object{name} {
}

Parameter* Function::param(std::string_view name) {
    return find_or_add<Parameter>(name);
}

void Function::generate(std::ostream& os) const {
    generate_comment(os);
    generate_prototype(os);
    os << ";\n";
}

void Function::generate_source(std::ostream& os) const {
    if (m_is_defined) {
        generate_procedure(os);
    }
}

void Function::generate_prototype(std::ostream& os) const {
    if (m_return_value == nullptr) {
        os << "void";
    } else {
        m_return_value->generate_typename_for(os, this);
    }

    os << " ";
    generate_prototype_internal(os);
}

void Function::generate_prototype_internal(std::ostream& os) const {
    os << usable_name() << "(";

    auto is_first_param = true;

    for (auto&& param : get_all<Parameter>()) {
        if (is_first_param) {
            is_first_param = false;
        } else {
            os << ", ";
        }

        param->generate(os);
    }

    os << ")";
}

void Function::generate_procedure(std::ostream& os) const {
    if (m_return_value == nullptr) {
        os << "void";
    } else {
        m_return_value->generate_typename_for(os, nullptr);
    }

    os << " ";

    std::vector<const Object*> owners{};

    for (auto o = owner<Object>(); o != nullptr; o = o->owner<Object>()) {
        // The global NS will have an empty name, at which point we stop.
        if (o->usable_name().empty()) {
            break;
        }

        owners.emplace_back(o);
    }

    std::reverse(owners.begin(), owners.end());

    for (auto&& o : owners) {
        os << o->usable_name() << "::";
    }

    generate_prototype_internal(os);

    if (m_procedure.empty()) {
        os << " {}\n";
    } else {
        os << " {\n";
        {
            detail::Indent _{os};
            os << m_procedure;
        }
        if (m_procedure.back() != '\n') {
            os << "\n";
        }
        os << "}\n";
    }
}
} // namespace sdkgenny
```

`src/generic_type.cpp`:

```cpp
#include <sdkgenny/generic_type.hpp>

namespace sdkgenny {
GenericType::GenericType(std::string_view name) : Type{name} {
    usable_name = [this] {
        std::string name{};
        constexpr auto allowed_chars = "*&[]:<>, ";

        for (auto&& c : m_name) {
            if (!std::isalnum(c) && std::strchr(allowed_chars, c) == nullptr) {
                name += '_';
            } else {
                name += c;
            }
        }

        if (!name.empty() && std::isdigit(name[0])) {
            name = "_" + name;
        }

        return name;
    };
}
} // namespace sdkgenny
```

`src/namespace.cpp`:

```cpp
#include <sdkgenny/class.hpp>
#include <sdkgenny/enum.hpp>
#include <sdkgenny/enum_class.hpp>
#include <sdkgenny/generic_type.hpp>
#include <sdkgenny/struct.hpp>

#include <sdkgenny/namespace.hpp>

namespace sdkgenny {

Namespace::Namespace(std::string_view name) : Typename{name} {
}

Type* Namespace::type(std::string_view name) {
    return find_in_owners_or_add<Type>(name);
}
GenericType* Namespace::generic_type(std::string_view name) {
    return find_in_owners_or_add<GenericType>(name);
}
Struct* Namespace::struct_(std::string_view name) {
    return find_or_add<Struct>(name);
}
Class* Namespace::class_(std::string_view name) {
    return find_or_add<Class>(name);
}
Enum* Namespace::enum_(std::string_view name) {
    return find_or_add<Enum>(name);
}
EnumClass* Namespace::enum_class(std::string_view name) {
    return find_or_add<EnumClass>(name);
}
Namespace* Namespace::namespace_(std::string_view name) {
    return find_or_add<Namespace>(name);
}
} // namespace sdkgenny
```

`src/object.cpp`:

```cpp
#include <sstream>

#include <sdkgenny/namespace.hpp>
#include <sdkgenny/struct.hpp>

#include <sdkgenny/object.hpp>

namespace sdkgenny {
Object::Object(std::string_view name) : m_name{name} {
}

void Object::generate_metadata(std::ostream& os) const {
    if (m_metadata.empty()) {
        return;
    }

    os << "// Metadata: ";

    for (auto&& md : m_metadata) {
        os << md;
        if (&md != &*m_metadata.rbegin()) {
            os << md << ", ";
        }
    }

    os << "\n";
}

void Object::generate_comment(std::ostream& os) const {
    if (m_comment.empty()) {
        return;
    }

    std::istringstream iss{m_comment};
    std::string line{};

    while (std::getline(iss, line)) {
        os << "// " << line << "\n";
    }
}

std::unique_ptr<Object> Object::remove(Object* obj) {
    obj->m_owner = nullptr;

    if (auto search = std::find_if(m_children.begin(), m_children.end(), [obj](auto&& c) { return c.get() == obj; });
        search != m_children.end()) {
        auto p = std::move(*search);
        m_children.erase(search);
        return p;
    }
    /* m_children.erase(
        std::remove_if(m_children.begin(), m_children.end(), [obj](auto&& c) { return c.get() == obj; }));*/
    return nullptr;
}

std::filesystem::path Object::path() {
    if (m_owner == nullptr) {
        return usable_name();
    }

    std::filesystem::path p{};
    auto os = owners<Object>();

    std::reverse(os.begin(), os.end());

    for (auto&& o : os) {
        if (o->template is_a<Namespace>()) {
            p /= o->usable_name();
        } else if (o->is_a<Struct>()) {
            p /= o->usable_name();
            break;
        }
    }

    if (m_owner->template is_a<Namespace>()) {
        p /= usable_name();
    }

    return p;
}
} // namespace sdkgenny

```

`src/parameter.cpp`:

```cpp
#include <sdkgenny/type.hpp>

#include <sdkgenny/parameter.hpp>

namespace sdkgenny {
Parameter::Parameter(std::string_view name) : Object{name} {
}

void Parameter::generate(std::ostream& os) const {
    m_type->generate_typename_for(os, this);
    os << " " << usable_name();
}
} // namespace sdkgenny
```

`src/pointer.cpp`:

```cpp
#include <sdkgenny/pointer.hpp>

namespace sdkgenny {
Pointer::Pointer(std::string_view name) : Reference{name} {
}

void Pointer::generate_typename_for(std::ostream& os, const Object* obj) const {
    m_to->generate_typename_for(os, obj);
    os << "*";
}
} // namespace sdkgenny
```

`src/reference.cpp`:

```cpp
#include <sdkgenny/reference.hpp>

namespace sdkgenny {
Reference::Reference(std::string_view name) : Type{name} {
}

void Reference::generate_typename_for(std::ostream& os, const Object* obj) const {
    m_to->generate_typename_for(os, obj);
    os << "&";
}
} // namespace sdkgenny
```

`src/sdk.cpp`:

```cpp
#include <sdkgenny/sdk.hpp>

namespace sdkgenny {
Sdk::Sdk() : Object{"Sdk"} {
    m_global_ns->m_owner = this;
}

void Sdk::generate(const std::filesystem::path& sdk_path) const {
    // erase the file_list.txt
    std::filesystem::remove(sdk_path / "file_list.txt");

    generate_namespace(sdk_path, m_global_ns.get());
}

void Sdk::generate_namespace(const std::filesystem::path& sdk_path, Namespace* ns) const {
    generate<Enum>(sdk_path, ns);
    generate<Struct>(sdk_path, ns);

    for (auto&& child : ns->get_all<Namespace>()) {
        generate_namespace(sdk_path, child);
    }
}

} // namespace sdkgenny
```

`src/static_function.cpp`:

```cpp
#include <sdkgenny/static_function.hpp>

namespace sdkgenny {
StaticFunction::StaticFunction(std::string_view name) : Function{name} {
}

void StaticFunction::generate(std::ostream& os) const {
    generate_comment(os);
    os << "static ";
    generate_prototype(os);
    os << ";\n";
}
} // namespace sdkgenny
```

`src/struct.cpp`:

```cpp
#include <climits>
#include <unordered_map>

#include <sdkgenny/array.hpp>
#include <sdkgenny/class.hpp>
#include <sdkgenny/constant.hpp>
#include <sdkgenny/detail/indent.hpp>
#include <sdkgenny/enum.hpp>
#include <sdkgenny/enum_class.hpp>
#include <sdkgenny/function.hpp>
#include <sdkgenny/generic_type.hpp>
#include <sdkgenny/parameter.hpp>
#include <sdkgenny/reference.hpp>
#include <sdkgenny/static_function.hpp>
#include <sdkgenny/variable.hpp>
#include <sdkgenny/virtual_function.hpp>

#include <sdkgenny/struct.hpp>

namespace sdkgenny {
Struct::Struct(std::string_view name) : Type{name} {
}

Variable* Struct::variable(std::string_view name) {
    return find_or_add_unique<Variable>(name);
}

Constant* Struct::constant(std::string_view name) {
    return find_or_add_unique<Constant>(name);
}

std::map<uintptr_t, Variable*> Struct::bitfield(uintptr_t offset, Variable* ignore) const {
    std::map<uintptr_t, Variable*> vars{};

    for (auto&& child : m_children) {
        if (auto var = dynamic_cast<Variable*>(child.get()); var != nullptr && var != ignore) {
            if (var->offset() == offset) {
                vars[var->bit_offset()] = var;
            }
        }
    }

    return vars;
}

Struct* Struct::struct_(std::string_view name) {
    return find_or_add_unique<Struct>(name);
}
Class* Struct::class_(std::string_view name) {
    return find_or_add_unique<Class>(name);
}
Enum* Struct::enum_(std::string_view name) {
    return find_or_add_unique<Enum>(name);
}
EnumClass* Struct::enum_class(std::string_view name) {
    return find_or_add_unique<EnumClass>(name);
}
Function* Struct::function(std::string_view name) {
    return find_or_add_unique<Function>(name);
}
VirtualFunction* Struct::virtual_function(std::string_view name) {
    return find_or_add_unique<VirtualFunction>(name);
}
StaticFunction* Struct::static_function(std::string_view name) {
    return find_or_add<StaticFunction>(name);
}

const std::vector<Struct*>& Struct::parents() const {
    return m_parents;
}

Struct* Struct::parent(Struct* parent) {
    if (std::find(m_parents.begin(), m_parents.end(), parent) == m_parents.end()) {
        m_parents.emplace_back(parent);
    }

    return this;
}

size_t Struct::size() const {
    size_t size = 0;

    for (auto&& parent : m_parents) {
        size += parent->size();
    }

    for (auto&& var : get_all<Variable>()) {
        auto var_end = var->end();

        if (var_end > size) {
            size = var_end;
        }
    }

    if (size == 0 && has_any<VirtualFunction>()) {
        size += sizeof(uintptr_t);
    }

    return std::max<size_t>(size, m_size);
}

void Struct::generate_forward_decl(std::ostream& os) const {
    os << "struct " << usable_name_decl() << ";\n";
}

void Struct::generate(std::ostream& os) const {
    generate_comment(os);
    generate_metadata(os);
    os << "struct " << usable_name_decl();
    generate_inheritance(os);
    os << " {\n";
    generate_internal(os);
    os << "}; // Size: 0x" << std::hex << size() << "\n";
}

Struct::Dependencies Struct::dependencies() {
    Dependencies deps{};

    std::function<void(Object*)> add_dep{};
    std::function<void(Object*)> add_hard_dep = [&](Object* obj) {
        if (obj == nullptr || obj == this || obj->is_child_of(this)) {
            return;
        }

        if (auto parent = obj->direct_owner(); parent != nullptr && parent->is_a<Struct>()) {
            // Structs declared within structs need their parent struct to be a hard dependency.
            add_hard_dep(parent);
        } else if (obj->is_a<Struct>() || obj->is_a<Enum>()) {
            deps.hard.emplace(dynamic_cast<Type*>(obj));
        }
    };
    std::function<void(Object*)> add_soft_dep = [&](Object* obj) {
        if (obj == nullptr || obj == this || obj->is_child_of(this)) {
            return;
        }

        if (auto ref = dynamic_cast<Reference*>(obj)) {
            add_soft_dep(ref->to());
        } else if (obj->is_a<Struct>() || obj->is_a<Enum>() || obj->is_a<GenericType>()) {
            if (obj->is_a<Enum>()) {
                // Enums are always hard dependencies.
                add_hard_dep(obj);
            } else if (obj->is_a<GenericType>()) {
                // GenericTypes may have hard or soft dependencies as template types.
                add_dep(obj);
            } else if (auto parent = obj->direct_owner(); parent != nullptr && parent->is_a<Struct>()) {
                // Structs declared within structs need their parent struct to be a hard dependency.
                add_hard_dep(parent);
            } else {
                deps.soft.emplace(dynamic_cast<Type*>(obj));
            }
        }
    };
    add_dep = [&](Object* obj) {
        if (auto arr = dynamic_cast<Array*>(obj)) {
            add_dep(arr->of());
        } else if (auto gt = dynamic_cast<GenericType*>(obj)) {
            for (auto&& type : gt->template_types()) {
                add_dep(type);
            }
        } else if (auto ref = dynamic_cast<Reference*>(obj)) {
            add_soft_dep(ref->to());
        } else {
            add_hard_dep(obj);
        }
    };

    for (auto&& parent : parents()) {
        add_hard_dep(parent);
    }

    for (auto&& var : get_all<Variable>()) {
        add_dep(var->type());
    }

    for (auto&& var : get_all<Constant>()) {
        add_dep(var->type());
    }

    for (auto&& fn : get_all<Function>()) {
        for (auto&& param : fn->get_all<Parameter>()) {
            add_dep(param->type());
        }

        add_dep(fn->returns());
    }

    for (auto&& s : get_all<Struct>()) {
        auto s_deps = s->dependencies();

        for (auto&& dep : s_deps.hard) {
            add_hard_dep(dep);
        }

        for (auto&& dep : s_deps.soft) {
            add_soft_dep(dep);
        }
    }

    // If a type is both a hard and soft dependency, remove it from the soft dependencies.
    for (auto&& dep : deps.hard) {
        if (deps.soft.find(dep) != deps.soft.end()) {
            deps.soft.erase(dep);
        }
    }

    return deps;
}

int Struct::vtable_size() const {
    auto max_index = -1;

    if (!m_parents.empty()) {
        max_index = 0;

        for (auto&& parent : m_parents) {
            if (auto parent_vtable_size = parent->vtable_size(); parent_vtable_size != -1) {
                max_index += parent_vtable_size;
            }
        }

        if (max_index == 0) {
            max_index = -1;
        }
    }

    for (auto&& child : get_all<VirtualFunction>()) {
        max_index = std::max<int>(max_index, child->vtable_index());
    }

    return max_index + 1;
}

void Struct::generate_inheritance(std::ostream& os) const {
    if (m_parents.empty()) {
        return;
    }

    os << " : ";

    bool is_first = true;

    for (auto&& parent : m_parents) {
        if (is_first) {
            is_first = false;
        } else {
            os << ", ";
        }

        os << "public ";
        parent->generate_typename_for(os, this);
    }
}

void Struct::generate_bitfield(std::ostream& os, uintptr_t offset) const {
    uintptr_t last_bit = 0;
    Type* bitfield_type{};

    for (auto&& [bit_offset, var] : bitfield(offset)) {
        if (bit_offset - last_bit > 0) {
            os << "private: ";
            var->type()->generate_typename_for(os, var);
            os << " pad_bitfield_" << std::hex << offset << "_" << std::hex << last_bit << " : " << std::dec
               << bit_offset - last_bit << "; public:\n";
        }

        var->generate(os);
        last_bit = bit_offset + var->bit_size();
        bitfield_type = var->type();
    }

    // Fill out the remaining space in the bitfield if necessary.
    auto num_bits = bitfield_type->size() * CHAR_BIT;

    if (last_bit != num_bits) {
        auto bit_offset = num_bits;

        os << "private: ";
        bitfield_type->generate_typename_for(os, nullptr);
        os << " pad_bitfield_" << std::hex << offset << "_" << std::hex << last_bit << " : " << std::dec
           << bit_offset - last_bit << "; public:\n";
    }
}

void Struct::generate_internal(std::ostream& os) const {
    detail::Indent _{os};

    for (auto&& child : get_all<Enum>()) {
        child->generate(os);
        os << "\n";
    }

    for (auto&& child : get_all<Struct>()) {
        child->generate(os);
        os << "\n";
    }

    for (auto&& child : get_all<Constant>()) {
        child->generate(os);
        os << "\n";
    }

    std::unordered_map<std::uintptr_t, Variable*> var_map{};

    for (auto&& var : get_all<Variable>()) {
        var_map[var->offset()] = var;
    }

    auto max_offset = size();
    size_t offset = 0;

    // Skip over the vtable.
    if (has_any<VirtualFunction>()) {
        offset = sizeof(uintptr_t);
    }

    // Start off where the parent ends.
    if (!m_parents.empty()) {
        offset = 0;

        for (auto&& parent : m_parents) {
            offset += parent->size();
        }
    }

    auto last_offset = offset;

    while (offset < max_offset) {
        if (auto search = var_map.find(offset); search != var_map.end()) {
            auto var = search->second;

            // Skip variables where the user has not given us a valid size (forgot to set a type or the type is
            // unfinished).
            if (var->size() == 0) {
                ++offset;
                continue;
            }

            if (offset - last_offset > 0) {
                os << "private: char pad_" << std::hex << last_offset << "[0x" << std::hex << offset - last_offset
                   << "]; public:\n";
            }

            if (var->is_bitfield()) {
                generate_bitfield(os, offset);
            } else {
                var->generate(os);
            }

            offset += var->size();
            last_offset = offset;
        } else {
            ++offset;
        }
    }

    if (offset - last_offset > 0) {
        os << "private: char pad_" << std::hex << last_offset << "[0x" << std::hex << offset - last_offset
           << "]; public:\n";
    }

    if (has_any<Function>()) {
        // Generate normal functions normally.
        for (auto&& child : get_all<Function>()) {
            if (!child->is_a<VirtualFunction>()) {
                child->generate(os);
            }
        }
    }

    if (has_any<VirtualFunction>()) {
        std::unordered_map<int, VirtualFunction*> vtable{};

        for (auto&& child : get_all<VirtualFunction>()) {
            auto vtable_index = child->vtable_index();

            vtable[vtable_index] = child;
        }

        auto vtable_index = 0;
        auto vtbl_size = vtable_size();

        for (; vtable_index < vtbl_size; ++vtable_index) {
            if (auto search = vtable.find(vtable_index); search != vtable.end()) {
                search->second->generate(os);
            } else {
                // Generate a default destructor to force addition of the vtable ptr.
                if (vtable_index == 0) {
                    os << "virtual ~" << usable_name() << "() = default;\n";
                } else {
                    os << "private: virtual void virtual_function_" << std::dec << vtable_index << "() = 0; public:\n";
                }
            }
        }
    }
}
} // namespace sdkgenny
```

`src/type.cpp`:

```cpp
#include <sdkgenny/array.hpp>
#include <sdkgenny/pointer.hpp>
#include <sdkgenny/reference.hpp>

#include <sdkgenny/type.hpp>

namespace sdkgenny {
Type::Type(std::string_view name) : Typename{name} {
}

Reference* Type::ref() {
    return m_owner->find_or_add<Reference>(name() + '&')->to(this);
}

Pointer* Type::ptr() {
    return (Pointer*)m_owner->find_or_add<Pointer>(name() + '*')->to(this);
}

Array* Type::array_(size_t count) {
    return m_owner->find_or_add<Array>(name() + "[0]")->of(this)->count(count);
}
} // namespace sdkgenny
```

`src/typename.cpp`:

```cpp
#include <sdkgenny/typename.hpp>

namespace sdkgenny {
Typename::Typename(std::string_view name) : Object{name} {
}

void Typename::generate_typename_for(std::ostream& os, const Object* obj) const {
    if (m_simple_typename_generation) {
        os << usable_name();
        return;
    }

    if (auto owner_type = owner<Typename>()) {
        if (obj == nullptr || owner_type != obj->owner<Typename>()) {
            auto&& name = owner_type->name();

            if (!name.empty()) {
                owner_type->generate_typename_for(os, obj);
                os << "::";
            }
        }
    }

    os << usable_name();
}

} // namespace sdkgenny
```

`src/variable.cpp`:

```cpp
#include <climits>

#include <sdkgenny/struct.hpp>

#include <sdkgenny/variable.hpp>

namespace sdkgenny {
Variable* Variable::append() {
    auto struct_ = owner<Struct>();
    uintptr_t highest_offset{};
    Variable* highest_var{};

    for (auto&& var : struct_->get_all<Variable>()) {
        if (var->offset() >= highest_offset && var != this) {
            highest_offset = var->offset();
            highest_var = var;
        }
    }

    if (highest_var != nullptr) {
        // Both bitfields of the same type.
        if (is_bitfield() && highest_var->is_bitfield() && m_type == highest_var->type()) {
            uintptr_t highest_bit = 0;
            auto bf = struct_->bitfield(highest_var->offset(), this);

            for (auto&& [bit_offset, bit_var] : bf) {
                if (bit_offset >= highest_bit && bit_var != this) {
                    highest_bit = bit_offset;
                    highest_var = bit_var;
                }
            }

            auto end_bit = highest_var->bit_offset() + highest_var->bit_size();

            if (end_bit + m_bit_size <= m_type->size() * CHAR_BIT) {
                // Squeeze into the remainign bits.
                m_offset = highest_var->offset();
            } else {
                // Not enough room, so start where the previous bitfield ended.
                m_offset = highest_var->end();
            }
        } else {
            m_offset = highest_var->end();
        }
    } else if (auto parents = struct_->parents(); !parents.empty()) {
        size_t size{};

        for (auto&& parent : parents) {
            size += parent->size();
        }

        m_offset = size;
    } else {
        m_offset = 0;
    }

    return this;
}

size_t Variable::size() const {
    if (m_type == nullptr) {
        return 0;
    }

    return m_type->size();
}

Variable* Variable::bit_append() {
    auto struct_ = owner<Struct>();
    uintptr_t highest_bit{};
    Variable* highest_var{};
    auto bf = struct_->bitfield(m_offset, this);

    for (auto&& [bit_offset, bit_var] : bf) {
        if (bit_offset >= highest_bit && bit_var != this) {
            highest_bit = bit_offset;
            highest_var = bit_var;
        }
    }

    if (highest_var != nullptr) {
        auto end_bit = highest_var->bit_offset() + highest_var->bit_size();

        m_bit_offset = end_bit;
    } else {
        m_bit_offset = 0;
    }

    return this;
}

void Variable::generate(std::ostream& os) const {
    generate_comment(os);
    generate_metadata(os);
    m_type->generate_typename_for(os, this);
    os << " " << usable_name();
    m_type->generate_variable_postamble(os);

    if (m_bit_size != 0) {
        os << " : " << std::dec << m_bit_size;
    }

    os << "; // 0x" << std::hex << m_offset << "\n";
}
} // namespace sdkgenny
```

`src/virtual_function.cpp`:

```cpp
#include <sdkgenny/virtual_function.hpp>

namespace sdkgenny {
VirtualFunction::VirtualFunction(std::string_view name) : Function{name} {
}

void VirtualFunction::generate(std::ostream& os) const {
    generate_comment(os);
    os << "virtual ";
    generate_prototype(os);

    if (m_procedure.empty()) {
        os << " = 0;\n";
    } else {
        os << ";\n";
    }
}
} // namespace sdkgenny

```

`vcpkg.json`:

```json
{
  "$cmkr": "This file is automatically generated from cmake.toml - DO NOT EDIT",
  "$cmkr-url": "https://github.com/build-cpp/cmkr",
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "dependencies": [
    "pegtl"
  ],
  "description": "",
  "name": "sdkgenny",
  "version-string": ""
}

```