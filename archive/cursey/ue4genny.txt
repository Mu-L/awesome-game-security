Project Path: arc_cursey_ue4genny_i4jzi1ee

Source Tree:

```txt
arc_cursey_ue4genny_i4jzi1ee
├── CMakeLists.txt
├── LICENSE
├── README.md
├── format.ps1
└── src
    ├── DRGConfig.hpp
    ├── Genny.hpp
    ├── UE4Genny.cpp
    ├── UE4Genny.hpp
    ├── UE4Impl.cpp
    └── kanan
        └── core
            ├── Memory.cpp
            ├── Memory.hpp
            ├── Module.cpp
            ├── Module.hpp
            ├── Patch.cpp
            ├── Patch.hpp
            ├── Pattern.cpp
            ├── Pattern.hpp
            ├── Scan.cpp
            ├── Scan.hpp
            ├── String.cpp
            ├── String.hpp
            ├── Utility.cpp
            └── Utility.hpp

```

`CMakeLists.txt`:

```txt
project(ue4genny)
set(UE4_SOURCE_DIR "${CMAKE_SOURCE_DIR}/Source" CACHE PATH "Where the UE4 source is located")
set(SDK_OUTPUT_DIR "${CMAKE_SOURCE_DIR}/sdk" CACHE PATH "Where the generated SDK files will go")
set(CONFIG_HPP "DRGConfig.hpp" CACHE STRING "The config header file to use")
set(SDK_ADDITIONAL_INCLUDE_HPP "" CACHE STRING "An optional additional header to include in every generated file")
set(SDK_UOBJECT_STRING_LOOKUP OFF CACHE BOOL "Whether to perform StaticClass lookups with strings instead of hashes")
add_library(ue4genny SHARED 
    "src/kanan/core/Memory.cpp"
    "src/kanan/core/Module.cpp"
    "src/kanan/core/Patch.cpp"
    "src/kanan/core/Pattern.cpp"
    "src/kanan/core/Scan.cpp"
    "src/kanan/core/String.cpp"
    "src/kanan/core/Utility.cpp"
    "src/UE4Genny.cpp"
    "src/UE4Impl.cpp"
    "src/DRGConfig.hpp"
)
target_include_directories(ue4genny PUBLIC 
    "src"
    "${UE4_SOURCE_DIR}/Runtime/Core/Public" 
    "${UE4_SOURCE_DIR}/Runtime/CoreUObject/Public"
    "${UE4_SOURCE_DIR}/Runtime/TraceLog/Public"
)
target_compile_definitions(ue4genny PUBLIC 
    UBT_COMPILED_PLATFORM=Windows 
    UE_BUILD_SHIPPING=1 
    WITH_EDITOR=0 
    WITH_EDITORONLY_DATA=0
    WITH_ENGINE=1 
    WITH_UNREAL_DEVELOPER_TOOLS=0
    WITH_PLUGIN_SUPPORT=0
    WITH_SERVER_CODE=0
    IS_MONOLITHIC=1
    IS_PROGRAM=1
    PLATFORM_WINDOWS
    PLATFORM_64BITS
    CORE_API=
    COREUOBJECT_API=
    UNICODE
    _UNICODE
    NOMINMAX
    WINVER=0x0A00
    CONFIG_HPP="${CONFIG_HPP}"
    SDK_OUTPUT_DIR="${SDK_OUTPUT_DIR}"
)
if(SDK_ADDITIONAL_INCLUDE_HPP)
    target_compile_definitions(ue4genny PUBLIC SDK_ADDITIONAL_INCLUDE_HPP="${SDK_ADDITIONAL_INCLUDE_HPP}")
endif()
if(SDK_UOBJECT_STRING_LOOKUP)
    target_compile_definitions(ue4genny PUBLIC SDK_UOBJECT_STRING_LOOKUP)
endif()
target_compile_features(ue4genny PUBLIC cxx_std_17)

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 cursey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# **UE4Genny**

**UE4Genny** is an SDK generator for Unreal Engine games (late UE4 versions and UE5 supported). It aims to provide a functional SDK that requires little to no editing after generation to use. Actual SDK generation is done via the sister project [SdkGenny](https://github.com/cursey/sdkgenny).

***UE4Genny is intended for MODDING games not CHEATING!***

## Usage

**UE4Genny** requires some assembly (work on your part). It does not function out of the box. It contains **NO** code from Unreal Engine, you must provide that yourself. Here are the general steps to get **UE4Genny** working:

1. Clone this repository.
2. Download the source code for the correct version of UE that the game you are targeting uses.
    * You should also try using the same compiler the game uses to compile **UE4Genny**. 
3. Copy the `Engine/Source/` directory from UE to your **UE4Genny** directory (`<UE4Genny directory>/Source/`). **UE4Genny** will use this copy of UE's source code.
    * If you already have a copy of UE somewhere else and you would prefer to use that, you can set the CMake variable `UE4_SOURCE_DIR` to the directory you want to use.
4. Compilation will likely fail at this point because some edits to the UE source is required. Namely:
    * `<UE4 Source>/Runtime/CoreUObject/Public/UObject/Class.h`: Make `UEnum::Names`, `UStruct::SuperStruct` public.
    * `<UE4 Source>/Runtime/CoreUObject/Public/UObject/UnrealType.h`: Make `FBoolProperty::FieldSize`, `FBoolProperty::ByteMask` and `FBoolProperty::FieldMask` public.
    * `<UE4 Source>/Runtime/CoreUObject/Public/UObject/UObjectBase.h`: Make `UObjectBase::ClassPrivate` public.
5. **UE4Genny** should now compile.
6. Make a new config header file for the game you are targeting (an example is provided in `src/DRGConfig.hpp` which works for the current Xbox Game Pass version of *Deep Rock Galactic*).
7. Set the CMake variable `CONFIG_HPP` to the newly created config header file.
8. Define the following constants in your newly created config header file (you need to find the values for these constants yourself):

```
// A memory pattern string that can be used to find the games GUObjectArray global variable.
constexpr char* GUOBJECTARRAY_PAT = "...";

// A memory pattern string that can be used to find the games FName::ToString() method.
constexpr char* FNAME_TOSTRING_PAT = "...";

// The VTable index of the games UObject::ProcessEvent virtual method.
constexpr int UOBJECT_PROCESSEVENT_INDEX = ...;
```

At this point you should be able to compile a game specific version of **UE4Genny** that will work with your target game. If it still does not work, attach a debugger and see what the problem is. Occasionally you will need to modify certain base structures so that they match what the game has (usually not required if you're using the correct version of UE's source for a given game). You may also need to edit or add UE specific compiler definitions in the `CMakeLists.txt`. If it isn't working now it's up to you to fiddle around and figure out what changes you need to make to get everything that **UE4Genny** uses to match up with what your target game is using.

At the end of this process, simply inject `UE4Genny.dll` into the target game and wait for an `sdk/` folder to appear.

## Note about compatibility

This main branch version of **UE4Genny** is intended for recent versions of UE4 and UE5 that utilize the new `FProperty` system. If you're targeting a game that uses an older version of UE4 that still uses the `UProperty` system, please check out the experimental [uproperty branch](https://github.com/cursey/ue4genny/tree/uproperty).

```

`format.ps1`:

```ps1
Get-ChildItem -Path .\src -Include *.hpp, *.cpp -Recurse | 
ForEach-Object {
    Write-Output $_.FullName
    &clang-format -i -style=file $_.FullName
}

```

`src/DRGConfig.hpp`:

```hpp
#pragma once
constexpr char* GUOBJECTARRAY_PAT = "48 8D 0D ? ? ? ? E8 ? ? ? ? 48 8D 8D 98 02 00 00 E8 ? ? ? ? 48 8D 8D B0 02 00 00";
constexpr char* FNAME_TOSTRING_PAT = "48 89 5C 24 18 55 56 57 48 8B EC 48 83 EC ? 8B 01";
constexpr int UOBJECT_PROCESSEVENT_INDEX = 66;
```

`src/Genny.hpp`:

```hpp
// SdkGenny - Genny.hpp - A single file header framework for generating C++ compatible SDKs
// https://github.com/cursey/sdkgenny

#pragma once

#include <algorithm>
#include <cassert>
#include <climits>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <functional>
#include <map>
#include <memory>
#include <ostream>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <string_view>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace genny {

class Type;
class Reference;
class Pointer;
class Array;
class Struct;
class Class;
class Enum;
class Variable;
class Function;

class Indent : public std::streambuf {
public:
    explicit Indent(std::streambuf* dest, int indent = 4) : m_dest{dest}, m_indent(indent, ' ') {}
    explicit Indent(std::ostream& dest, int indent = 4) : m_dest{dest.rdbuf()}, m_indent(indent, ' '), m_owner{&dest} {
        m_owner->rdbuf(this);
    }
    ~Indent() override {
        if (m_owner != nullptr) {
            m_owner->rdbuf(m_dest);
        }
    }

protected:
    int overflow(int ch) override {
        if (m_is_at_start_of_line && ch != '\n') {
            m_dest->sputn(m_indent.data(), m_indent.size());
        }
        m_is_at_start_of_line = ch == '\n';
        return m_dest->sputc(ch);
    }

private:
    std::streambuf* m_dest{};
    bool m_is_at_start_of_line{true};
    std::string m_indent{};
    std::ostream* m_owner{};
};

class Object {
public:
    Object() = delete;
    explicit Object(std::string_view name) : m_name{name} {}
    virtual ~Object() = default;

    const auto& name() const { return m_name; }
    auto name(std::string name) {
        m_name = std::move(name);
        return this;
    }

    const auto& metadata() const { return m_metadata; }
    auto& metadata() { return m_metadata; }

    virtual void generate_metadata(std::ostream& os) const {
        if (m_metadata.empty()) {
            return;
        }

        os << "// Metadata: ";

        for (auto&& md : m_metadata) {
            os << md;
            if (&md != &*m_metadata.rbegin()) {
                os << md << ", ";
            }
        }

        os << "\n";
    }

    template <typename T> bool is_a() const { return dynamic_cast<const T*>(this) != nullptr; }

    // Searches for an owner of the correct type.
    template <typename T> const T* owner() const {
        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                return (const T*)owner;
            }
        }

        return nullptr;
    }

    template <typename T> T* owner() { return (T*)((const Object*)this)->owner<T>(); }

    template <typename T> const T* topmost_owner() const {
        const T* topmost{};

        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                topmost = (const T*)owner;
            }
        }

        return topmost;
    }

    template <typename T> T* topmost_owner() { return (T*)((const Object*)this)->topmost_owner<T>(); }

    auto direct_owner() const { return m_owner; }

    template <typename T> std::vector<T*> owners() const {
        std::vector<T*> owners{};

        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                owners.emplace_back((T*)owner);
            }
        }

        return owners;
    }

    template <typename T> std::vector<T*> get_all() const {
        std::vector<T*> children{};

        for (auto&& child : m_children) {
            if (child->is_a<T>()) {
                children.emplace_back((T*)child.get());
            }
        }

        return children;
    }

    template <typename T> void get_all_in_children(std::unordered_set<T*>& objects) const {
        if (is_a<T>()) {
            objects.emplace((T*)this);
        }

        for (auto&& child : m_children) {
            child->get_all_in_children(objects);
        }
    }

    template <typename T> bool has_any() const {
        return std::any_of(m_children.cbegin(), m_children.cend(), [](const auto& child) { return child->is_a<T>(); });
    }

    template <typename T> bool has_any_in_children() const {
        return std::any_of(m_children.cbegin(), m_children.cend(),
            [](const auto& child) { return child->is_a<T>() || child->has_any_in_children<T>(); });
    }

    template <typename T> bool is_child_of(T* obj) const {
        const auto o = owners<T>();
        return std::any_of(o.cbegin(), o.cend(), [obj](const auto& owner) { return owner == obj; });
    }

    bool is_direct_child_of(Object* obj) const { return m_owner == obj; }

    template <typename T> T* add(std::unique_ptr<T> object) {
        object->m_owner = this;
        return (T*)m_children.emplace_back(std::move(object)).get();
    }

    template <typename T> T* find(std::string_view name) const {
        for (auto&& child : m_children) {
            if (child->is_a<T>() && child->m_name == name) {
                return (T*)child.get();
            }
        }

        return nullptr;
    }

    template <typename T> T* find_in_owners(std::string_view name, bool include_self) const {
        auto owner = (include_self) ? this : m_owner;

        for (; owner != nullptr; owner = owner->m_owner) {
            if (auto search = owner->find<T>(name)) {
                return search;
            }
        }

        return nullptr;
    }

    template <typename T, typename... TArgs> T* find_or_add(std::string_view name, TArgs... args) {
        if (auto search = find<T>(name)) {
            return search;
        }

        return add(std::make_unique<T>(name, args...));
    }

    template <typename T, typename... TArgs> T* find_in_owners_or_add(std::string_view name, TArgs... args) {
        if (auto search = find_in_owners<T>(name, true)) {
            return search;
        }

        return add(std::make_unique<T>(name, args...));
    }

    // Returns the unique_ptr to the removed object.
    std::unique_ptr<Object> remove(Object* obj) {
        obj->m_owner = nullptr;

        if (auto search =
                std::find_if(m_children.begin(), m_children.end(), [obj](auto&& c) { return c.get() == obj; });
            search != m_children.end()) {
            auto p = std::move(*search);
            m_children.erase(search);
            return p;
        }
        /* m_children.erase(
            std::remove_if(m_children.begin(), m_children.end(), [obj](auto&& c) { return c.get() == obj; }));*/
        return nullptr;
    }

    template <typename T> void remove_all() {
        for (auto&& child : get_all<T>()) {
            remove(child);
        }
    }

    // Will fix up a desired name so that it's usable as a C++ identifier. Things like spaces get converted to
    // underscores, and we make sure it doesn't begin with a number. More checks could be done here in the future if
    // necessary.
    std::function<std::string()> usable_name = [this] {
        std::string name{};
        constexpr auto allowed_chars = "*&[]:";

        for (auto&& c : m_name) {
            if (!std::isalnum(c) && std::strchr(allowed_chars, c) == nullptr) {
                name += '_';
            } else {
                name += c;
            }
        }

        if (!name.empty() && isdigit(name[0])) {
            name = "_" + name;
        }

        return name;
    };

    // The name used when declaring the object (only for types).
    std::function<std::string()> usable_name_decl = usable_name;

    std::filesystem::path path() {
        if (m_owner == nullptr) {
            return usable_name();
        }

        std::filesystem::path p{};
        auto os = owners<Object>();

        std::reverse(os.begin(), os.end());

        for (auto&& o : os) {
            if (o->is_a<Namespace>()) {
                p /= o->usable_name();
            } else if (o->is_a<Struct>()) {
                p /= o->usable_name();
                break;
            }
        }

        if (m_owner->is_a<Namespace>()) {
            p /= usable_name();
        }

        return p;
    }

    auto skip_generation(bool g) { m_skip_generation = g; return this; }
    auto skip_generation() { return m_skip_generation; }

protected:
    friend class Type;
    friend class Pointer;
    friend class Namespace;
    friend class Sdk;

    Object* m_owner{};

    std::string m_name{};
    std::vector<std::unique_ptr<Object>> m_children{};
    std::vector<std::string> m_metadata{};

    bool m_skip_generation{};
};

template <typename T> T* cast(const Object* object) {
    if (object->is_a<T>()) {
        return (T*)object;
    }

    return nullptr;
}

class Typename : public Object {
public:
    explicit Typename(std::string_view name) : Object{name} {}

    virtual void generate_typename_for(std::ostream& os, const Object* obj) const {
        if (m_simple_typename_generation) {
            os << usable_name();
            return;
        }

        if (auto owner_type = owner<Typename>()) {
            if (obj == nullptr || owner_type != obj->owner<Typename>()) {
                auto&& name = owner_type->name();

                if (!name.empty()) {
                    owner_type->generate_typename_for(os, obj);
                    os << "::";
                }
            }
        }

        os << usable_name();
    }

    auto simple_typename_generation() const { return m_simple_typename_generation; }
    auto simple_typename_generation(bool simple_generation) {
        m_simple_typename_generation = simple_generation;
        return this;
    }

protected:
    bool m_simple_typename_generation{};
};

class Type : public Typename {
public:
    explicit Type(std::string_view name) : Typename{name} {}

    virtual void generate_variable_postamble(std::ostream& os) const {}

    virtual size_t size() const { return m_size; }
    auto size(int size) {
        m_size = size;
        return this;
    }

    Reference* ref();
    Pointer* ptr();
    Array* array_(size_t count = 0);

protected:
    size_t m_size{};
};

class Reference : public Type {
public:
    explicit Reference(std::string_view name) : Type{name} {}

    auto to() const { return m_to; }
    auto to(Type* to) {
        m_to = to;
        return this;
    }

    size_t size() const override { return sizeof(uintptr_t); }

    void generate_typename_for(std::ostream& os, const Object* obj) const override {
        m_to->generate_typename_for(os, obj);
        os << "&";
    }

protected:
    Type* m_to{};
};

inline Reference* Type::ref() {
    return m_owner->find_or_add<Reference>(name() + '&')->to(this);
}

class Pointer : public Reference {
public:
    explicit Pointer(std::string_view name) : Reference{name} {}

    auto ptr() { return m_owner->find_or_add<Pointer>(m_name + '*')->to(this); }

    void generate_typename_for(std::ostream& os, const Object* obj) const override {
        m_to->generate_typename_for(os, obj);
        os << "*";
    }
};

inline Pointer* Type::ptr() {
    return (Pointer*)m_owner->find_or_add<Pointer>(name() + '*')->to(this);
}

class Array : public Type {
public:
    explicit Array(std::string_view name) : Type{name} {}

    auto of() const { return m_of; }
    auto of(Type* of) {
        m_of = of;
        return this;
    }

    auto count() const { return m_count; }
    auto count(size_t count) {
        // Fix the name of this array type.
        if (m_of != nullptr && count != m_count) {
            const auto& base = m_of->name();
            auto first_brace = base.find_first_of('[');
            auto head = base.substr(0, first_brace);
            std::string tail{};

            if (first_brace != std::string::npos) {
                tail = base.substr(first_brace);
            }

            m_name = head + '[' + std::to_string(count) + ']' + tail;
        }

        m_count = count;

        return this;
    }

    size_t size() const override {
        if (m_of == nullptr) {
            return 0;
        }

        return m_of->size() * m_count;
    }

    void generate_typename_for(std::ostream& os, const Object* obj) const override {
        m_of->generate_typename_for(os, obj);
    }

    void generate_variable_postamble(std::ostream& os) const override {
        os << "[" << std::dec << m_count << "]";
        m_of->generate_variable_postamble(os);
    }

protected:
    Type* m_of{};
    size_t m_count{};
};

inline Array* Type::array_(size_t count) {
    return (Array*)m_owner->find_or_add<Array>(name() + "[0]")->of(this)->count(count);
}

class GenericType : public Type {
public:
    explicit GenericType(std::string_view name) : Type{name} {
        usable_name = [this] {
            std::string name{};
            constexpr auto allowed_chars = "*&[]:<>, ";

            for (auto&& c : m_name) {
                if (!std::isalnum(c) && std::strchr(allowed_chars, c) == nullptr) {
                    name += '_';
                } else {
                    name += c;
                }
            }

            if (!name.empty() && isdigit(name[0])) {
                name = "_" + name;
            }

            return name;
        };
    }

    auto template_types() const { return m_template_types; }
    auto template_type(Type* type) {
        m_template_types.emplace(type);
        return this;
    }


protected:
    std::unordered_set<Type*> m_template_types{};
};

class Variable : public Object {
public:
    explicit Variable(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    // Helper that recurses though owners to find the correct type.
    auto type(std::string_view name) {
        m_type = find_in_owners_or_add<Type>(name);
        return this;
    }

    auto offset() const { return m_offset; }
    auto offset(uintptr_t offset) {
        m_offset = offset;
        return this;
    }

    // Sets the offset to be after the last variable in the struct.
    Variable* append();

    virtual size_t size() const {
        if (m_type == nullptr) {
            return 0;
        }

        return m_type->size();
    }

    auto end() const { return offset() + size(); }

    auto bit_size(size_t size) {
        // assert(size <= m_type->size() * CHAR_BIT);
        m_bit_size = size;
        return this;
    }
    auto bit_size() const { return m_bit_size; }

    auto bit_offset(uintptr_t offset) {
        // assert(offset < m_type->size() * CHAR_BIT);
        m_bit_offset = offset;
        return this;
    }
    auto bit_offset() const { return m_bit_offset; }

    auto is_bitfield() const { return m_bit_size != 0; }

    // Call this after append() or offset()
    Variable* bit_append();

    virtual void generate(std::ostream& os) const {
        generate_metadata(os);
        m_type->generate_typename_for(os, this);
        os << " " << usable_name();
        m_type->generate_variable_postamble(os);

        if (m_bit_size != 0) {
            os << " : " << std::dec << m_bit_size;
        }

        os << "; // 0x" << std::hex << m_offset << "\n";
    }

protected:
    Type* m_type{};
    uintptr_t m_offset{};
    size_t m_bit_size{};
    uintptr_t m_bit_offset{};
};

class Constant : public Object {
public:
    explicit Constant(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    // Helper that recurses though owners to find the correct type.
    auto type(std::string_view name) {
        m_type = find_in_owners_or_add<Type>(name);
        return this;
    }

    const auto& value() const { return m_value; }
    auto value(std::string_view value) {
        m_value = std::move(value);
        return this;
    }

    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true> auto real(T value) {
        m_value = std::to_string(value);
        return this;
    }

    template <typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true> auto integer(T value) {
        m_value = std::to_string(value);
        return this;
    }

    auto string(const std::string& value) {
        m_value = "\"" + value + "\"";
        return this;
    }

    virtual void generate(std::ostream& os) const {
        os << "static constexpr ";
        generate_metadata(os);
        m_type->generate_typename_for(os, this);
        os << " " << usable_name();
        m_type->generate_variable_postamble(os);
        os << " = " << m_value << ";";
    }

protected:
    Type* m_type{};
    std::string m_value{};
};

class Parameter : public Object {
public:
    explicit Parameter(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    virtual void generate(std::ostream& os) const {
        m_type->generate_typename_for(os, this);
        os << " " << usable_name();
    }

protected:
    Type* m_type{};
};

class Function : public Object {
public:
    explicit Function(std::string_view name) : Object{name} {}

    auto param(std::string_view name) { return find_or_add<Parameter>(name); }

    auto returns() const { return m_return_value; }
    auto returns(Type* return_value) {
        m_return_value = return_value;
        return this;
    }

    auto&& procedure() const { return m_procedure; }
    auto procedure(std::string_view procedure) {
        m_procedure = procedure;
        return this;
    }

    auto&& dependencies() const { return m_dependencies; }
    auto depends_on(Type* type) {
        m_dependencies.emplace(type);
        return this;
    }

    auto&& defined() const { return m_is_defined; }
    auto defined(bool is_defined) {
        m_is_defined = is_defined;
        return this;
    }

    virtual void generate(std::ostream& os) const {
        generate_prototype(os);
        os << ";\n";
    }

    virtual void generate_source(std::ostream& os) const {
        if (m_is_defined) {
            generate_procedure(os);
        }
    }

protected:
    Type* m_return_value{};
    std::string m_procedure{};
    std::unordered_set<Type*> m_dependencies{};
    bool m_is_defined{true};

    void generate_prototype(std::ostream& os) const {
        if (m_return_value == nullptr) {
            os << "void";
        } else {
            m_return_value->generate_typename_for(os, this);
        }

        os << " ";
        generate_prototype_internal(os);
    }

    void generate_prototype_internal(std::ostream& os) const {
        os << usable_name() << "(";

        auto is_first_param = true;

        for (auto&& param : get_all<Parameter>()) {
            if (is_first_param) {
                is_first_param = false;
            } else {
                os << ", ";
            }

            param->generate(os);
        }

        os << ")";
    }

    void generate_procedure(std::ostream& os) const {
        if (m_return_value == nullptr) {
            os << "void";
        } else {
            m_return_value->generate_typename_for(os, nullptr);
        }

        os << " ";

        std::vector<const Object*> owners{};

        for (auto o = owner<Object>(); o != nullptr; o = o->owner<Object>()) {
            owners.emplace_back(o);
        }

        std::reverse(owners.begin(), owners.end());

        for (auto&& o : owners) {
            if (o->usable_name().empty()) {
                continue;
            }

            os << o->usable_name() << "::";
        }

        generate_prototype_internal(os);

        if (m_procedure.empty()) {
            os << " {}\n";
        } else {
            os << " {\n";
            {
                Indent _{os};
                os << m_procedure;
            }
            if (m_procedure.back() != '\n') {
                os << "\n";
            }
            os << "}\n";
        }
    }
};

class VirtualFunction : public Function {
public:
    explicit VirtualFunction(std::string_view name) : Function{name} {}

    auto vtable_index() const { return m_vtable_index; }
    auto vtable_index(uint32_t vtable_index) {
        m_vtable_index = vtable_index;
        return this;
    }

    void generate(std::ostream& os) const override {
        os << "virtual ";
        generate_prototype(os);

        if (m_procedure.empty()) {
            os << " = 0;\n";
        } else {
            os << ";\n";
        }
    }

protected:
    uint32_t m_vtable_index{};
};

class StaticFunction : public Function {
public:
    explicit StaticFunction(std::string_view name) : Function{name} {}

    void generate(std::ostream& os) const override {
        os << "static ";
        generate_prototype(os);
        os << ";\n";
    }
};

class Enum : public Type {
public:
    explicit Enum(std::string_view name) : Type{name} {}

    auto value(std::string_view name, uint64_t value) {
        for (auto&& [val_name, val_val] : m_values) {
            if (val_name == name) {
                val_val = value;
                return this;
            }
        }

        m_values.emplace_back(name, value);
        return this;
    }

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    auto&& values() const { return m_values; }
    auto&& values() { return m_values; }

    size_t size() const override {
        if (m_type == nullptr) {
            return sizeof(int);
        } else {
            return m_type->size();
        }
    }

    virtual void generate_forward_decl(std::ostream& os) const { os << "enum " << usable_name_decl() << ";\n"; }

    virtual void generate(std::ostream& os) const {
        os << "enum " << usable_name_decl();
        generate_type(os);
        os << " {\n";
        generate_enums(os);
        os << "};\n";
    }

protected:
    std::vector<std::tuple<std::string, uint64_t>> m_values{};
    Type* m_type{};

    void generate_type(std::ostream& os) const {
        if (m_type != nullptr) {
            os << " : ";
            m_type->generate_typename_for(os, this);
        }
    }

    void generate_enums(std::ostream& os) const {
        Indent _{os};

        for (auto&& [name, value] : m_values) {
            if (!m_type || 1ull << (m_type->size() * 8) > value)
                os << name << " = " << value << ",\n";
        }
    }
};

class EnumClass : public Enum {
public:
    explicit EnumClass(std::string_view name) : Enum{name} {}

    void generate_forward_decl(std::ostream& os) const override { os << "enum class " << usable_name_decl() << ";\n"; }
    void generate(std::ostream& os) const override {
        os << "enum class " << usable_name_decl();
        generate_type(os);
        os << " {\n";
        generate_enums(os);
        os << "};\n";
    }
};

class Struct : public Type {
public:
    explicit Struct(std::string_view name) : Type{name} {}

    auto variable(std::string_view name) { return find_or_add_unique<Variable>(name); }
    auto constant(std::string_view name) { return find_or_add_unique<Constant>(name); }

    // Returns a map of bit_offset, bitfield_variable at a given offset. Optionally, it will ignore a given variable
    // while constructing the map.
    auto bitfield(uintptr_t offset, Variable* ignore = nullptr) const {
        std::map<uintptr_t, Variable*> vars{};

        for (auto&& child : m_children) {
            if (auto var = dynamic_cast<Variable*>(child.get()); var != nullptr && var != ignore) {
                if (var->offset() == offset) {
                    vars[var->bit_offset()] = var;
                }
            }
        }

        return vars;
    }

    auto struct_(std::string_view name) { return find_or_add_unique<Struct>(name); }
    auto class_(std::string_view name) { return find_or_add_unique<Class>(name); }
    auto enum_(std::string_view name) { return find_or_add_unique<Enum>(name); }
    auto enum_class(std::string_view name) { return find_or_add_unique<EnumClass>(name); }
    auto function(std::string_view name) { return find_or_add_unique<Function>(name); }
    auto virtual_function(std::string_view name) { return find_or_add_unique<VirtualFunction>(name); }
    auto static_function(std::string_view name) { return find_or_add<StaticFunction>(name); }

    auto&& parents() const { return m_parents; }
    auto parent(Struct* parent) {
        if (std::find(m_parents.begin(), m_parents.end(), parent) == m_parents.end()) {
            m_parents.emplace_back(parent);
        }

        return this;
    }

    size_t size() const override {
        size_t size = 0;

        for (auto&& parent : m_parents) {
            size += parent->size();
        }

        for (auto&& var : get_all<Variable>()) {
            auto var_end = var->end();

            if (var_end > size) {
                size = var_end;
            }
        }

        if (size == 0 && has_any<VirtualFunction>()) {
            size += sizeof(uintptr_t);
        }

        return std::max<size_t>(size, m_size);
    }
    auto size(int size) {
        m_size = size;
        return this;
    }

    virtual void generate_forward_decl(std::ostream& os) const { os << "struct " << usable_name_decl() << ";\n"; }

    virtual void generate(std::ostream& os) const {
        generate_metadata(os);
        os << "struct " << usable_name_decl();
        generate_inheritance(os);
        os << " {\n";
        generate_internal(os);
        os << "}; // Size: 0x" << std::hex << size() << "\n";
    }

    struct Dependencies {
        std::unordered_set<Type*> hard{};
        std::unordered_set<Type*> soft{};
    };

    Dependencies dependencies() {
        Dependencies deps{};

        std::function<void(Object*)> add_dep{};
        auto add_hard_dep = [&](Object* obj) {
            if (obj != nullptr && obj != this && !obj->is_child_of(this) &&
                (obj->is_a<Struct>() || obj->is_a<Enum>())) {
                deps.hard.emplace(dynamic_cast<Type*>(obj));
            }
        };
        std::function<void(Object*)> add_soft_dep = [&](Object* obj) {
            if (auto ref = dynamic_cast<Reference*>(obj)) {
                add_soft_dep(ref->to());
            } else if (obj != nullptr && obj != this && !obj->is_child_of(this) &&
                                        (obj->is_a<Struct>() || obj->is_a<Enum>() || obj->is_a<GenericType>())) {
                if (obj->is_a<Enum>()) {
                    // Enums are always hard dependencies.
                    add_hard_dep(obj);
                } else if (obj->is_a<GenericType>()) {
                    // GenericTypes may have hard or soft dependencies as template types.
                    add_dep(obj);
                } else {
                    deps.soft.emplace(dynamic_cast<Type*>(obj));
                }
            }
        };
        add_dep = [&](Object* obj) {
            if (auto arr = dynamic_cast<Array*>(obj)) {
                add_dep(arr->of());
            }
            else if (auto gt = dynamic_cast<GenericType*>(obj)) {
                for (auto&& type : gt->template_types()) {
                    add_dep(type);
                }
            } else if (auto ref = dynamic_cast<Reference*>(obj)) {
                add_soft_dep(ref->to());
            } else {
                add_hard_dep(obj);
            }
        };

        for (auto&& parent : parents()) {
            add_hard_dep(parent);
        }

        for (auto&& var : get_all<Variable>()) {
            add_dep(var->type());
        }

        for (auto&& var : get_all<Constant>()) {
            add_dep(var->type());
        }

        for (auto&& fn : get_all<Function>()) {
            for (auto&& param : fn->get_all<Parameter>()) {
                add_dep(param->type());
            }

            add_dep(fn->returns());
        }

        for (auto&& s : get_all<Struct>()) {
            auto s_deps = s->dependencies();

            for (auto&& dep : s_deps.hard) {
                add_hard_dep(dep);
            }

            for (auto&& dep : s_deps.soft) {
                add_soft_dep(dep);
            }
        }

        // If a type is both a hard and soft dependency, remove it from the soft dependencies.
        for (auto&& dep : deps.hard) {
            if (deps.soft.find(dep) != deps.soft.end()) {
                deps.soft.erase(dep);
            }
        }

        return deps;
    }

protected:
    std::vector<Struct*> m_parents{};

    int vtable_size() const {
        auto max_index = -1;

        if (!m_parents.empty()) {
            max_index = 0;

            for (auto&& parent : m_parents) {
                if (auto parent_vtable_size = parent->vtable_size(); parent_vtable_size != -1) {
                    max_index += parent_vtable_size;
                }
            }

            if (max_index == 0) {
                max_index = -1;
            }
        }

        for (auto&& child : get_all<VirtualFunction>()) {
            max_index = std::max<int>(max_index, child->vtable_index());
        }

        return max_index + 1;
    }

    template <typename T> T* find_in_parents(std::string_view name) {
        for (auto&& parent : m_parents) {
            if (auto obj = parent->find<T>(name)) {
                return obj;
            }
        }

        return nullptr;
    }

    template <typename T, typename... TArgs> T* find_or_add_unique(std::string_view name, TArgs... args) {
        if (auto search = find<T>(name); search != nullptr) {
            return search;
        }

        std::string fixed_name{};
        auto num_collisions = 0;
        auto has_collision = false;

        do {
            has_collision = false;

            if (find_in_parents<Object>(fixed_name.empty() ? name : fixed_name) != nullptr) {
                fixed_name = name;
                fixed_name += std::to_string(num_collisions);
                ++num_collisions;
                has_collision = true;
            }
        } while (has_collision);

        if (num_collisions == 0) {
            return add(std::make_unique<T>(name, args...));
        }

        return add(std::make_unique<T>(fixed_name, args...));
    }

    void generate_inheritance(std::ostream& os) const {
        if (m_parents.empty()) {
            return;
        }

        os << " : ";

        bool is_first = true;

        for (auto&& parent : m_parents) {
            if (is_first) {
                is_first = false;
            } else {
                os << ", ";
            }

            os << "public ";
            parent->generate_typename_for(os, this);
        }
    }

    void generate_bitfield(std::ostream& os, uintptr_t offset) const {
        auto last_bit = 0;
        Type* bitfield_type{};

        for (auto&& [bit_offset, var] : bitfield(offset)) {
            if (bit_offset - last_bit > 0) {
                var->type()->generate_typename_for(os, var);
                os << " pad_bitfield_" << std::hex << offset << "_" << std::hex << last_bit << " : " << std::dec
                   << bit_offset - last_bit << ";\n";
            }

            var->generate(os);
            last_bit = bit_offset + var->bit_size();
            bitfield_type = var->type();
        }

        // Fill out the remaining space in the bitfield if necessary.
        auto num_bits = bitfield_type->size() * CHAR_BIT;

        if (last_bit != num_bits) {
            auto bit_offset = num_bits;

            bitfield_type->generate_typename_for(os, nullptr);
            os << " pad_bitfield_" << std::hex << offset << "_" << std::hex << last_bit << " : " << std::dec
               << bit_offset - last_bit << ";\n";
        }
    }

    void generate_internal(std::ostream& os) const {
        Indent _{os};

        for (auto&& child : get_all<Enum>()) {
            child->generate(os);
            os << "\n";
        }

        for (auto&& child : get_all<Struct>()) {
            child->generate(os);
            os << "\n";
        }

        for (auto&& child : get_all<Constant>()) {
            child->generate(os);
            os << "\n";
        }

        std::unordered_map<std::uintptr_t, Variable*> var_map{};

        for (auto&& var : get_all<Variable>()) {
            var_map[var->offset()] = var;
        }

        auto max_offset = size();
        size_t offset = 0;

        // Skip over the vtable.
        if (has_any<VirtualFunction>()) {
            offset = sizeof(uintptr_t);
        }

        // Start off where the parent ends.
        if (!m_parents.empty()) {
            offset = 0;

            for (auto&& parent : m_parents) {
                offset += parent->size();
            }
        }

        auto last_offset = offset;

        while (offset < max_offset) {
            if (auto search = var_map.find(offset); search != var_map.end()) {
                auto var = search->second;

                // Skip variables where the user has not given us a valid size (forgot to set a type or the type is
                // unfinished).
                if (var->size() == 0) {
                    ++offset;
                    continue;
                }

                if (offset - last_offset > 0) {
                    os << "char pad_" << std::hex << last_offset << "[0x" << std::hex << offset - last_offset << "];\n";
                }

                if (var->is_bitfield()) {
                    generate_bitfield(os, offset);
                } else {
                    var->generate(os);
                }

                offset += var->size();
                last_offset = offset;
            } else {
                ++offset;
            }
        }

        if (offset - last_offset > 0) {
            os << "char pad_" << std::hex << last_offset << "[0x" << std::hex << offset - last_offset << "];\n";
        }

        if (has_any<Function>()) {
            // Generate normal functions normally.
            for (auto&& child : get_all<Function>()) {
                if (!child->is_a<VirtualFunction>()) {
                    child->generate(os);
                }
            }
        }

        if (has_any<VirtualFunction>()) {
            std::unordered_map<int, VirtualFunction*> vtable{};

            for (auto&& child : get_all<VirtualFunction>()) {
                auto vtable_index = child->vtable_index();

                vtable[vtable_index] = child;
            }

            auto vtable_index = 0;
            auto vtbl_size = vtable_size();

            for (; vtable_index < vtbl_size; ++vtable_index) {
                if (auto search = vtable.find(vtable_index); search != vtable.end()) {
                    search->second->generate(os);
                } else {
                    // Generate a default destructor to force addition of the vtable ptr.
                    if (vtable_index == 0) {
                        os << "virtual ~" << usable_name() << "() = default;\n";
                    } else {
                        os << "virtual void virtual_function_" << std::dec << vtable_index << "() = 0;\n";
                    }
                }
            }
        }
    }
};

inline Variable* Variable::append() {
    auto struct_ = owner<Struct>();
    uintptr_t highest_offset{};
    Variable* highest_var{};

    for (auto&& var : struct_->get_all<Variable>()) {
        if (var->offset() >= highest_offset && var != this) {
            highest_offset = var->offset();
            highest_var = var;
        }
    }

    if (highest_var != nullptr) {
        // Both bitfields of the same type.
        if (is_bitfield() && highest_var->is_bitfield() && m_type == highest_var->type()) {
            auto highest_bit = 0;
            auto bf = struct_->bitfield(highest_var->offset(), this);

            for (auto&& [bit_offset, bit_var] : bf) {
                if (bit_offset >= highest_bit && bit_var != this) {
                    highest_bit = bit_offset;
                    highest_var = bit_var;
                }
            }

            auto end_bit = highest_var->bit_offset() + highest_var->bit_size();

            if (end_bit + m_bit_size <= m_type->size() * CHAR_BIT) {
                // Squeeze into the remainign bits.
                m_offset = highest_var->offset();
            } else {
                // Not enough room, so start where the previous bitfield ended.
                m_offset = highest_var->end();
            }
        } else {
            m_offset = highest_var->end();
        }
    } else if (auto parents = struct_->parents(); !parents.empty()) {
        size_t size{};

        for (auto&& parent : parents) {
            size += parent->size();
        }

        m_offset = size;
    } else {
        m_offset = 0;
    }

    return this;
}

inline Variable* Variable::bit_append() {
    auto struct_ = owner<Struct>();
    uintptr_t highest_bit{};
    Variable* highest_var{};
    auto bf = struct_->bitfield(m_offset, this);

    for (auto&& [bit_offset, bit_var] : bf) {
        if (bit_offset >= highest_bit && bit_var != this) {
            highest_bit = bit_offset;
            highest_var = bit_var;
        }
    }

    if (highest_var != nullptr) {
        auto end_bit = highest_var->bit_offset() + highest_var->bit_size();

        m_bit_offset = end_bit;
    } else {
        m_bit_offset = 0;
    }

    return this;
}

class Class : public Struct {
public:
    explicit Class(std::string_view name) : Struct{name} {}

    void generate_forward_decl(std::ostream& os) const override { os << "class " << usable_name_decl() << ";\n"; }

    void generate(std::ostream& os) const override {
        os << "class " << usable_name_decl();
        generate_inheritance(os);
        os << " {\n";

        if (!m_children.empty()) {
            os << "public:\n";
        }

        generate_internal(os);

        os << "}; // Size: 0x" << std::hex << size() << "\n";
    }
};

class Namespace : public Typename {
public:
    explicit Namespace(std::string_view name) : Typename{name} {}

    auto type(std::string_view name) { return find_in_owners_or_add<Type>(name); }
    auto generic_type(std::string_view name) { return find_in_owners_or_add<GenericType>(name); }
    auto struct_(std::string_view name) { return find_or_add<Struct>(name); }
    auto class_(std::string_view name) { return find_or_add<Class>(name); }
    auto enum_(std::string_view name) { return find_or_add<Enum>(name); }
    auto enum_class(std::string_view name) { return find_or_add<EnumClass>(name); }
    auto namespace_(std::string_view name) { return find_or_add<Namespace>(name); }
};

class Sdk {
public:
    Sdk() = default;
    virtual ~Sdk() = default;

    auto global_ns() const { return m_global_ns.get(); }

    auto preamble(std::string_view preamble) {
        m_preamble = preamble;
        return this;
    }
    auto postamble(std::string_view postamble) {
        m_postamble = postamble;
        return this;
    }

    auto include(std::string_view header) {
        m_includes.emplace(header);
        return this;
    }
    auto include_local(std::string_view header) {
        m_local_includes.emplace(header);
        return this;
    }

    void generate(const std::filesystem::path& sdk_path) const {
        // erase the file_list.txt
        std::filesystem::remove(sdk_path / "file_list.txt");

        generate_namespace(sdk_path, m_global_ns.get());
    }

    const auto& header_extension() const { return m_header_extension; }
    auto header_extension(std::string_view ext) {
        m_header_extension = ext;
        return this;
    }

    const auto& source_extension() const { return m_source_extension; }
    auto source_extension(std::string_view ext) {
        m_source_extension = ext;
        return this;
    }

    const auto& generate_namespaces() { return m_generate_namespaces; }
    auto generate_namespaces(bool gen_ns) {
        m_generate_namespaces = gen_ns;
        return this;
    }

protected:
    std::unique_ptr<Namespace> m_global_ns{std::make_unique<Namespace>("")};
    std::string m_preamble{};
    std::string m_postamble{};
    std::set<std::string> m_includes{};
    std::set<std::string> m_local_includes{};
    std::string m_header_extension{".hpp"};
    std::string m_source_extension{".cpp"};
    bool m_generate_namespaces{true};

    template <typename T> void generate_header(const std::filesystem::path& sdk_path, T* obj) const {
        if (obj->skip_generation()) {
            return;
        }

        auto obj_inc_path = sdk_path / (obj->path() += m_header_extension);
        std::ofstream file_list{sdk_path / "file_list.txt", std::ios::app};
        file_list << "\"" << obj_inc_path.string() << "\" \\\n";
        std::filesystem::create_directories(obj_inc_path.parent_path());
        std::ofstream os{obj_inc_path};

        if (!m_preamble.empty()) {
            std::istringstream sstream{m_preamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }

        os << "#pragma once\n";

        for (auto&& include : m_includes) {
            os << "#include <" << include << ">\n";
        }

        for (auto&& include : m_local_includes) {
            os << "#include \"" << include << "\"\n";
        }

        std::unordered_set<Type*> types_to_include{};
        std::unordered_set<Type*> types_to_forward_decl{};
        std::set<std::filesystem::path> includes{};

        if (auto s = dynamic_cast<Struct*>(obj)) {
            auto deps = s->dependencies();
            types_to_include = deps.hard;
            types_to_forward_decl = deps.soft;
        }

        for (auto&& ty : types_to_include) {
            includes.emplace(ty->path() += m_header_extension);
        }

        for (auto&& inc : includes) {
            os << "#include \"" << std::filesystem::relative(inc, obj->path().parent_path()).string() << "\"\n";
        }

        for (auto&& type : types_to_forward_decl) {
            auto owners = type->owners<Namespace>();

            if (owners.size() > 1 && m_generate_namespaces) {
                std::reverse(owners.begin(), owners.end());

                os << "namespace ";

                for (auto&& owner : owners) {
                    if (owner->usable_name().empty()) {
                        continue;
                    }

                    os << owner->usable_name();

                    if (owner != owners.back()) {
                        os << "::";
                    }
                }

                os << " {\n";
            }

            if (auto s = dynamic_cast<Struct*>(type)) {
                s->generate_forward_decl(os);
            } else if (auto e = dynamic_cast<Enum*>(type)) {
                e->generate_forward_decl(os);
            }

            if (owners.size() > 1 && m_generate_namespaces) {
                os << "}\n";
            }
        }

        auto owners = obj->owners<Namespace>();

        if (owners.size() > 1 && m_generate_namespaces) {
            std::reverse(owners.begin(), owners.end());

            os << "namespace ";

            for (auto&& owner : owners) {
                if (owner->usable_name().empty()) {
                    continue;
                }

                os << owner->usable_name();

                if (owner != owners.back()) {
                    os << "::";
                }
            }

            os << " {\n";
        }

        os << "#pragma pack(push, 1)\n";
        obj->generate(os);
        os << "#pragma pack(pop)\n";

        if (owners.size() > 1 && m_generate_namespaces) {
            os << "}\n";
        }

        if (!m_postamble.empty()) {
            std::istringstream sstream{m_postamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }
    }

    template <typename T> void generate_source(const std::filesystem::path& sdk_path, T* obj) const {
        if (obj->skip_generation()) {
            return;
        }

        // Skip generating a source file for an object with no functions.
        if (!obj->has_any<Function>()) {
            return;
        }

        // Skip generating a source file for an object if all the functions it does have lack a procedure.
        std::unordered_set<Function*> functions{};
        obj->get_all_in_children<Function>(functions);

        auto any_procedure = false;

        for (auto&& fn : functions) {
            if (!fn->procedure().empty()) {
                any_procedure = true;
                break;
            }
        }

        if (!any_procedure) {
            return;
        }

        auto obj_src_path = sdk_path / (obj->path() += m_source_extension);
        std::ofstream file_list{sdk_path / "file_list.txt", std::ios::app};
        file_list << "\"" << obj_src_path.string() << "\" \\\n";

        std::filesystem::create_directories(obj_src_path.parent_path());
        std::ofstream os{obj_src_path};

        if (!m_preamble.empty()) {
            std::istringstream sstream{m_preamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }

        std::unordered_set<Type*> types_to_include{};

        if (auto s = dynamic_cast<Struct*>(obj)) {
            auto deps = s->dependencies();
            types_to_include = deps.hard;
            types_to_include.merge(deps.soft);
            types_to_include.emplace(s);
        }

        for (auto&& fn : functions) {
            auto deps = fn->dependencies();
            types_to_include.merge(deps);
        }

        std::set<std::filesystem::path> includes{};

        for (auto&& ty : types_to_include) {
            includes.emplace(ty->path() += m_header_extension);
        }

        for (auto&& inc : includes) {
            os << "#include \"" << std::filesystem::relative(inc, obj->path().parent_path()).string() << "\"\n";
        }

        for (auto&& fn : functions) {
            // Skip pure virtual functions.
            if (fn->is_a<VirtualFunction>() && fn->procedure().empty()) {
                continue;
            }

            fn->generate_source(os);
        }

        if (!m_postamble.empty()) {
            std::istringstream sstream{m_postamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }
    }

    template <typename T> void generate(const std::filesystem::path& sdk_path, Namespace* ns) const {
        for (auto&& obj : ns->get_all<T>()) {
            generate_header(sdk_path, obj);
            generate_source(sdk_path, obj);
        }
    }

    void generate_namespace(const std::filesystem::path& sdk_path, Namespace* ns) const {
        generate<Enum>(sdk_path, ns);
        generate<Struct>(sdk_path, ns);

        for (auto&& child : ns->get_all<Namespace>()) {
            generate_namespace(sdk_path, child);
        }
    }
};
} // namespace genny

```

`src/UE4Genny.cpp`:

```cpp
#include <fstream>
#include <sstream>
#include <thread>
#include <unordered_map>

#include "UObject/Class.h"
#include "UObject/EnumProperty.h"
#include "UObject/UObjectArray.h"
#include "UObject/UnrealType.h"

#include <Windows.h>

#include "Genny.hpp"
#include "kanan/core/Scan.hpp"
#include "kanan/core/String.hpp"
#include "kanan/core/Utility.hpp"

#include "UE4Genny.hpp"
#include CONFIG_HPP

FUObjectArray* get_GUObjectArray() {
    static FUObjectArray* obj_array{};

    if (obj_array == nullptr) {
        OutputDebugString(L"Finding GUObjectArray...");

        auto lea = kanan::scan(GUOBJECTARRAY_PAT);

        if (!lea) {
            OutputDebugString(L"Failed to find GUObjectArray!");
            return nullptr;
        }

        obj_array = (FUObjectArray*)kanan::rel_to_abs(*lea + 3);

        OutputDebugString(L"Found GUObjectArray!");
    }

    return obj_array;
}

std::string get_full_name(UObjectBase* obj) {
    auto c = obj->GetClass();

    if (c == nullptr) {
        return "null";
    }

    auto obj_name = narrow(obj->GetFName());

    for (auto outer = obj->GetOuter(); outer != nullptr; outer = outer->GetOuter()) {
        obj_name = narrow(outer->GetFName()) + '.' + obj_name;
    }

    return narrow(c->GetFName()) + ' ' + obj_name;
}

UObjectBase* find_uobject(const char* obj_full_name) {
    static std::unordered_map<std::string, UObjectBase*> obj_map{};

    if (auto search = obj_map.find(obj_full_name); search != obj_map.end()) {
        return search->second;
    }

    auto obj_array = get_GUObjectArray();

    for (auto i = 0; i < obj_array->GetObjectArrayNum(); ++i) {
        if (auto obj_item = obj_array->IndexToObject(i)) {
            if (auto obj_base = obj_item->Object) {
                if (get_full_name(obj_base) == obj_full_name) {
                    obj_map[obj_full_name] = obj_base;
                    return obj_base;
                }
            }
        }
    }

    return nullptr;
}

UObjectBase* find_uobject(size_t obj_full_name_hash) {
    static std::unordered_map<size_t, UObjectBase*> obj_map{};

    if (auto search = obj_map.find(obj_full_name_hash); search != obj_map.end()) {
        return search->second;
    }

    auto obj_array = get_GUObjectArray();

    for (auto i = 0; i < obj_array->GetObjectArrayNum(); ++i) {
        if (auto obj_item = obj_array->IndexToObject(i)) {
            if (auto obj_base = obj_item->Object) {
                if (kanan::hash(get_full_name(obj_base)) == obj_full_name_hash) {
                    obj_map[obj_full_name_hash] = obj_base;
                    return obj_base;
                }
            }
        }
    }

    return nullptr;
}

std::string narrow(const FString& fstr) {
    auto& char_array = fstr.GetCharArray();
    return kanan::narrow(char_array.Num() ? char_array.GetData() : L"");
}

std::string narrow(const FName& fname) {
    return narrow(fname.ToString());
}

void generate_uenum(genny::Namespace* g, UEnum* uenum) {
    auto enum_name = narrow(uenum->GetFName());
    enum_name = enum_name.substr(enum_name.find_last_of(':') + 1);
    genny::Enum* genny_enum{};

    auto enum_class = uenum->GetClass();
    auto enum_class_name = narrow(enum_class->GetFName());

    switch (uenum->GetCppForm()) {
    case UEnum::ECppForm::EnumClass:
        genny_enum = g->enum_class(enum_name);
        break;
    case UEnum::ECppForm::Namespaced: {
        auto ns_name = enum_name;
        enum_name = narrow(uenum->CppType);
        enum_name = enum_name.substr(enum_name.find_last_of(':') + 1);

        if (enum_name.empty()) {
            enum_name = "Type";
        }

        genny_enum = g->namespace_(ns_name)->enum_(enum_name);

        // Unreal included types
        if (ns_name == "ESearchCase" || ns_name == "ESearchDir")
            genny_enum->skip_generation(true);

        break;
    }
    default:
        genny_enum = g->enum_(enum_name);
        break;
    }

    // NOTE: Must make UEnum::Names public.
    for (auto n = 0; n < uenum->Names.Num(); ++n) {
        auto& name = uenum->Names[n];
        auto key = narrow(name.Key);
        key = key.substr(key.find_last_of(':') + 1);

        // Work around windows defines PF_MAX AF_INET
        if (key == "PF_MAX")
            key = "PF_MAX_";

        genny_enum->value(key, name.Value);
    }
}

std::string get_fproperty_typename(FProperty* fprop) {
    if (fprop->IsA<FByteProperty>()) {
        auto fbyte = (FByteProperty*)fprop;

        // TODO: Handle FByteProperty's that are actual enums.
        if (fbyte->Enum != nullptr) {
            auto uenum = fbyte->Enum;
            auto enum_name = narrow(uenum->GetFName());
            enum_name = enum_name.substr(enum_name.find_last_of(':') + 1);

            if (uenum->GetCppForm()  == UEnum::ECppForm::Namespaced) {
                auto ns_name = enum_name;
                enum_name = narrow(uenum->CppType);
                enum_name = enum_name.substr(enum_name.find_last_of(':') + 1);

                if (enum_name.empty()) {
                    enum_name = "Type";
                }

                return ns_name + "::" + enum_name;
            } else {
                return enum_name;
            }
        } else {
            return "uint8_t";
        }
    } else if (fprop->IsA<FInt8Property>()) {
        return "int8_t";
    } else if (fprop->IsA<FInt16Property>()) {
        return "int16_t";
    } else if (fprop->IsA<FIntProperty>()) {
        return "int32_t";
    } else if (fprop->IsA<FInt64Property>()) {
        return "int64_t";
    } else if (fprop->IsA<FUInt16Property>()) {
        return "uint16_t";
    } else if (fprop->IsA<FUInt32Property>()) {
        return "uint32_t";
    } else if (fprop->IsA<FUInt64Property>()) {
        return "uint64_t";
    } else if (fprop->IsA<FFloatProperty>()) {
        return "float";
    } else if (fprop->IsA<FDoubleProperty>()) {
        return "double";
    } else if (fprop->IsA<FBoolProperty>()) {
        auto fbool = (FBoolProperty*)fprop;

        // A FieldMask of 0xFF indicates a native bool, otherwise its part of a bitfield.
        // NOTE: Must make FieldMask public.
        if (fbool->FieldMask == 0xFF) {
            return "bool";
        } else {
            return "uint8_t";
        }
    } else if (fprop->IsA<FObjectProperty>()) {
        auto fobj = (FObjectProperty*)fprop;
        if (auto uclass = fobj->PropertyClass) {
            return kanan::narrow(uclass->GetPrefixCPP()) + narrow(uclass->GetFName()) + '*';
        }
    } else if (fprop->IsA<FStructProperty>()) {
        auto fstruct = (FStructProperty*)fprop;
        auto ustruct = fstruct->Struct;
        return kanan::narrow(ustruct->GetPrefixCPP()) + narrow(ustruct->GetFName());
    } else if (fprop->IsA<FArrayProperty>()) {
        auto farray = (FArrayProperty*)fprop;
        auto inner = farray->Inner;
        auto inner_typename = get_fproperty_typename(inner);

        if (inner_typename.empty()) {
            inner_typename = "void*";
        }

        return "TArray<" + inner_typename + '>';
    } else if (fprop->IsA<FNameProperty>()) {
        return "FName";
    } else if (fprop->IsA<FStrProperty>()) {
        return "FString";
    } else if (fprop->IsA<FEnumProperty>()) {
        auto fenum = (FEnumProperty*)fprop;
        auto uenum = fenum->GetEnum();
        auto enum_name = narrow(uenum->GetFName());
        enum_name = enum_name.substr(enum_name.find_last_of(':') + 1);

        if (uenum->GetCppForm() == UEnum::ECppForm::Namespaced) {
            auto ns_name = enum_name;
            enum_name = narrow(uenum->CppType);
            enum_name = enum_name.substr(enum_name.find_last_of(':') + 1);

            if (enum_name.empty()) {
                enum_name = "Type";
            }

            return ns_name + "::" + enum_name;
        } else {
            return enum_name;
        }
    }

    return "";
}

genny::Type* genny_type_for_fproperty(genny::Namespace* g, FProperty* fprop) {
    auto prop_typename = get_fproperty_typename(fprop);
    genny::Type* prop_type{};
    auto ns = g;

    while (true) {
        if (auto first_colon = prop_typename.find_first_of(':'); first_colon != std::string::npos) {
            auto ns_name = prop_typename.substr(0, first_colon);
            prop_typename = prop_typename.substr(first_colon + 2);
            ns = ns->namespace_(ns_name);
        } else {
            break;
        }
    }

    if (fprop->IsA<FByteProperty>()) {
        auto fbyte = (FByteProperty*)fprop;

        // Change the enum type to a uint8_t if necessary.
        if (fbyte->Enum != nullptr) {
            auto enum_type = ns->enum_(prop_typename);
            enum_type->type(g->type("uint8_t"));
        }

        prop_type = ns->type(prop_typename);
    } else if (fprop->IsA<FArrayProperty>()) {
        auto farray = (FArrayProperty*)fprop;
        auto inner = farray->Inner;
        auto inner_type = genny_type_for_fproperty(g, inner);

        if (inner_type != nullptr) {
            prop_type = ns->generic_type(prop_typename)->template_type(inner_type)->size(sizeof(TArray<int>));
        } else {
            prop_type = ns->generic_type(prop_typename)->size(sizeof(TArray<int>));
        }
    } else if (fprop->IsA<FEnumProperty>()) {
        auto fenum = (FEnumProperty*)fprop;

        // Change the enum type to the correct one.
        auto genny_enum = ns->enum_(prop_typename);
        auto genny_enum_type = genny_type_for_fproperty(g, fenum->GetUnderlyingProperty());

        genny_enum->type(genny_enum_type);
        prop_type = genny_enum;
    } else if (!prop_typename.empty()) {
        if (prop_typename.back() == '*') {
            prop_type = ns->type(prop_typename.substr(0, prop_typename.length() - 1))->ptr();
        } else {
            prop_type = ns->type(prop_typename);
        }
    }

    return prop_type;
}

void generate_fproperty(genny::Struct* s, FProperty* fprop) {
    auto ns = s->owner<genny::Namespace>();
    auto prop_name = narrow(fprop->NamePrivate);
    auto prop_type = genny_type_for_fproperty(ns, fprop);

    if (fprop->IsA<FBoolProperty>()) {
        auto fbool = (FBoolProperty*)fprop;

        // A FieldMask of 0xFF indicates a native bool, otherwise its part of a bitfield.
        if (fbool->FieldMask != 0xFF) {
            auto bf = s->variable(prop_name)->offset(fprop->GetOffset_ForInternal());

            auto mask = fbool->ByteMask;
            auto offset = -1;

            for (; mask != 0; mask /= 2, ++offset);

            bf->type(prop_type);
            bf->bit_offset(offset);
            bf->bit_size(fbool->FieldSize);
            // bf->field(prop_name)->size(fbool->FieldSize)->offset(offset);

            // Return early since we're done for bitfields.
            return;
        }
    }

    if (prop_type != nullptr) {
        if (fprop->ArrayDim > 1) {
            s->variable(prop_name)->type(prop_type->array_(fprop->ArrayDim))->offset(fprop->GetOffset_ForInternal());
        } else {
            s->variable(prop_name)->type(prop_type)->offset(fprop->GetOffset_ForInternal());
        }
    } /*else {
        // Don't know what type it is so just fill up the space.
        s->array_(prop_name)
            ->count(fprop->ElementSize * fprop->ArrayDim)
            ->offset(fprop->Offset_Internal)
            ->type("uint8_t");
    }*/
}

void generate_ufunction(genny::Struct* s, UFunction* ufunc) {
    auto ns = s->owner<genny::Namespace>();
    auto func_name = narrow(ufunc->GetFName());
    genny::Function* genny_func{};

    if ((ufunc->FunctionFlags & FUNC_Static) != 0) {
        genny_func = s->static_function(func_name);
    } else {
        genny_func = s->function(func_name);
    }

    auto param_struct = std::make_unique<genny::Struct>("Params_" + func_name);
    genny::Variable* ret_param{};
    std::unordered_set<genny::Variable*> out_params{};

    // Add params.
    for (auto field = ufunc->ChildProperties; field != nullptr; field = field->Next) {
        if (field->IsA<FProperty>()) {
            auto fparam = (FProperty*)field;
            auto param_flags = fparam->PropertyFlags;
            auto param_name = narrow(fparam->NamePrivate);
            auto param_type = genny_type_for_fproperty(ns, fparam);

            // Unknown parameter type (probably a soft object ptr or something we don't support) so just return early.
            if (param_type == nullptr) {
                return;
                // param_type = ns->type("uint8_t");
            }

            if ((param_flags & CPF_ReturnParm) != 0) {
                genny_func->returns(param_type);
            } else {
                auto param = genny_func->param(param_name);

                if ((param_flags & CPF_ReferenceParm) != 0 || (param_flags & CPF_OutParm) != 0) {
                    param->type(param_type->ref());
                } else {
                    param->type(param_type);
                }
            }

            auto params_param = param_struct->variable(param_name)->offset(fparam->GetOffset_ForInternal());

            if (param_type->size() == fparam->ElementSize * fparam->ArrayDim) {
                params_param->type(param_type);
            } else {
                params_param->type(ns->type("uint8_t"));
            }

            if ((param_flags & CPF_ReturnParm) != 0) {
                ret_param = params_param;
            } else if ((param_flags & CPF_ReferenceParm) != 0 || (param_flags & CPF_OutParm) != 0) {
                out_params.emplace(params_param);
            }
        }
    }

    // Generate the procedure.
    std::ostringstream os{};
#ifdef SDK_UOBJECT_STRING_LOOKUP
    os << "static auto func = (UFunction*)(find_uobject(\"" << get_full_name(ufunc) << "\"));\n";
#else
    os << "static auto func = (UFunction*)(find_uobject(" << kanan::hash(get_full_name(ufunc)) << ")); // " << get_full_name(ufunc) << "\n";
#endif
    param_struct->generate(os);
    param_struct->generate_typename_for(os, nullptr);
    os << " params{};\n";

    for (auto&& param : param_struct->get_all<genny::Variable>()) {
        // Skip return param.
        if (param == ret_param) {
            continue;
        }

        os << "params." << param->usable_name() << " = (";
        param->type()->generate_typename_for(os, nullptr);
        os << ")" << param->usable_name() << ";\n";
    }

    if (genny_func->is_a<genny::StaticFunction>()) {
        os << "((UClass*)StaticClass())->ClassDefaultObject->ProcessEvent(func, &params);\n";
    } else {
        os << "ProcessEvent(func, &params);\n";
    }

    for (auto&& param : out_params) {
        os << param->usable_name() << " = params." << param->usable_name() << ";\n";
    }

    if (ret_param != nullptr) {
        os << "return (";
        genny_func->returns()->generate_typename_for(os, nullptr);
        os << ")params." << ret_param->usable_name() << ";\n";
    }

    genny_func->procedure(os.str());
    genny_func->depends_on(ns->type("UFunction"));
}

void generate_ustruct(genny::Struct* genny_struct, UStruct* ustruct) {
    auto ustruct_name = [](UStruct* ustruct) {
        return kanan::narrow(ustruct->GetPrefixCPP()) + narrow(ustruct->GetFName());
    };
    auto ns = genny_struct->owner<genny::Namespace>();

    // Set inheritance.
    auto uparent = ustruct->GetSuperStruct();

    if (uparent != nullptr) {
        auto uparent_name = ustruct_name(uparent);

        if (uparent->IsA<UClass>()) {
            genny_struct->parent(ns->class_(uparent_name));
        } else {
            genny_struct->parent(ns->struct_(uparent_name));
        }
    }

    // Set size.
    if (ustruct->IsA<UScriptStruct>()) {
        auto uscript = (UScriptStruct*)ustruct;

        if (auto struct_ops = uscript->GetCppStructOps()) {
            genny_struct->size(struct_ops->GetSize());
        }
    }

    if (ustruct->PropertiesSize > genny_struct->size()) {
        genny_struct->size(
            ((ustruct->PropertiesSize + ustruct->MinAlignment - 1) / ustruct->MinAlignment) * ustruct->MinAlignment);
    }
}

void generate_ustruct_members(genny::Struct* genny_struct, UStruct* ustruct) {
    // Add properties.
    for (auto field = ustruct->ChildProperties; field != nullptr; field = field->Next) {
        if (field->IsA<FProperty>()) {
            generate_fproperty(genny_struct, (FProperty*)field);
        }
    }
}

void generate_uclass_functions(genny::Struct* genny_struct, UClass* uclass) {
    // Add StaticClass().
    auto static_class = genny_struct->static_function("StaticClass")->returns(genny_struct->ptr());
    std::ostringstream os{};
#ifdef SDK_UOBJECT_STRING_LOOKUP
    os << "static auto res = find_uobject(\"" << get_full_name(uclass) << "\");\n";
#else
    os << "static auto res = find_uobject(" << kanan::hash(get_full_name(uclass)) << "); // " << get_full_name(uclass) << "\n";
#endif
    os << "return (";
    static_class->returns()->generate_typename_for(os, genny_struct);
    os << ")res;";
    static_class->procedure(os.str());

    // Add functions.
    for (auto field = uclass->Children; field != nullptr; field = field->Next) {
        if (field->IsA<UFunction>()) {
            generate_ufunction(genny_struct, (UFunction*)field);
        }
    }
}

void generate() {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    sdk.include("cstdint");

#ifdef SDK_ADDITIONAL_INCLUDE_HPP
    sdk.include(SDK_ADDITIONAL_INCLUDE_HPP);
#endif

    // Add basic types
    g->type("int8_t")->size(1);
    g->type("int16_t")->size(2);
    g->type("int32_t")->size(4);
    g->type("int64_t")->size(8);
    g->type("uint8_t")->size(1);
    g->type("uint16_t")->size(2);
    g->type("uint32_t")->size(4);
    g->type("uint64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);
    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("int")->size(4);
    g->type("void")->size(0);

    // Add UE4 types
    auto uobj = g->class_("UObject");

    auto ufunc = g->class_("UFunction");
    auto uobj_process_event = uobj->virtual_function("ProcessEvent")->vtable_index(UOBJECT_PROCESSEVENT_INDEX);
    uobj_process_event->param("Function")->type(ufunc->ptr());
    uobj_process_event->param("Parms")->type(g->type("void")->ptr());

    auto ustruct = g->class_("UStruct");
    ustruct->variable("SuperStruct")
        ->type(ustruct->ptr())
        ->offset(offsetof(UStruct, SuperStruct)); // NOTE: Make SuperStruct public.

    auto uclass = g->class_("UClass");
    uclass->variable("ClassDefaultObject")->type(uobj->ptr())->offset(offsetof(UClass, ClassDefaultObject));

    uobj->variable("ClassPrivate")
        ->type(uclass->ptr())
        ->offset(offsetof(UObjectBase, ClassPrivate)); // NOTE: Make ClassPrivate public.

    g->type("FName")->size(sizeof(FName));
    g->type("FString")->size(sizeof(FString));

    std::unordered_map<genny::Struct*, UStruct*> struct_map{};

    for (auto i = 0; i < get_GUObjectArray()->GetObjectArrayNum(); ++i) {
        auto obj_item = get_GUObjectArray()->IndexToObject(i);

        if (obj_item == nullptr) {
            continue;
        }

        auto obj = obj_item->Object;

        if (auto uenum = DCast<UEnum*>(obj)) {
            generate_uenum(g, uenum);
        } else if (auto ustruct = DCast<UStruct*>(obj)) {
            // Skip functions and blueprints for now.
            if (ustruct->IsA<UFunction>() /*|| ustruct->IsA<UBlueprintGeneratedClass>()*/) {
                continue;
            }

            auto name = kanan::narrow(ustruct->GetPrefixCPP()) + narrow(ustruct->GetFName());
            genny::Struct* genny_struct{};

            if (ustruct->IsA<UClass>()) {
                genny_struct = g->class_(name);
            } else {
                genny_struct = g->struct_(name);
            }

            if (name == "FTimespan" || name == "FFloatInterval" || name == "FInt32Interval")
                genny_struct->skip_generation(true);

            generate_ustruct(genny_struct, ustruct);
            struct_map.emplace(genny_struct, ustruct);
        }
    }

    for (auto&& [genny_struct, ustruct] : struct_map) {
        generate_ustruct_members(genny_struct, ustruct);
    }

    // Have to generate the functions seperately so the size of all the types are known.
    for (auto&& [genny_struct, ustruct] : struct_map) {
        if (!ustruct->IsA<UClass>()) {
            continue;
        }

        generate_uclass_functions(genny_struct, (UClass*)ustruct);
    }

    sdk.generate(SDK_OUTPUT_DIR);
}

void startup_thread() {
    generate();
    MessageBox(nullptr, L"SDK generation finished.", L"UE4Genny", MB_ICONINFORMATION);
}

BOOL WINAPI DllMain(HINSTANCE dllHandle, DWORD reason, void* reserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        std::thread{startup_thread}.detach();
    }

    return 1;
}
```

`src/UE4Genny.hpp`:

```hpp
#pragma once

#include <string>

#include "UObject/UObjectArray.h"

FUObjectArray* get_GUObjectArray();
UObjectBase* find_uobject(const char* obj_path);
UObjectBase* find_uobject(size_t obj_path_hash);
std::string narrow(const FString& fstr);
std::string narrow(const FName& fname);

template <typename T, typename T2 = UObject*> T DCast(T2 In) {
    if (In && ((UObject*)In)->IsA<std::remove_pointer<T>::type>()) {
        return (T)In;
    }

    return nullptr;
}


```

`src/UE4Impl.cpp`:

```cpp
#include "UE4Genny.hpp"
#include "UObject/Class.h"
#include "kanan/core/Scan.hpp"
#include CONFIG_HPP

void FMemory::Free(void* mem) {
    // Big leaks.
}

void* FMemory::Realloc(void* mem, size_t size, uint32_t) {
    return realloc(mem, size);
}

size_t FMemory::QuantizeSize(size_t size, uint32_t) {
    return size;
}

UClass* UStruct::GetPrivateStaticClass() {
    return (UClass*)find_uobject("Class /Script/CoreUObject.Struct");
}

UClass* UClass::GetPrivateStaticClass() {
    return (UClass*)find_uobject("Class /Script/CoreUObject.Class");
}

UClass* UScriptStruct::GetPrivateStaticClass() {
    return (UClass*)find_uobject("Class /Script/CoreUObject.ScriptStruct");
}

UClass* UEnum::GetPrivateStaticClass() {
    return (UClass*)find_uobject("Class /Script/CoreUObject.Enum");
}

UClass* UFunction::GetPrivateStaticClass() {
    return (UClass*)find_uobject("Class /Script/CoreUObject.Function");
}

FString FName::ToString() const {
    FString out;

    static void (*toString)(const FName*, FString&){};

    if (toString == nullptr) {
        OutputDebugString(L"Finding FName::ToString...");

        toString = (decltype(toString))kanan::scan(FNAME_TOSTRING_PAT).value_or(0);

        if (toString == nullptr) {
            OutputDebugString(L"Failed to find FName::ToString!");
        } else {
            OutputDebugString(L"Found FName::ToString!");
        }
    }

    toString(this, out);
    return out;
}
```

`src/kanan/core/Memory.cpp`:

```cpp
#include <optional>
#include <vector>

#include <Windows.h>

#include "Memory.hpp"
#include "String.hpp"

using namespace std;

namespace kanan {
thread_local vector<MEMORY_BASIC_INFORMATION> g_pages{};

optional<MEMORY_BASIC_INFORMATION> findInCache(uintptr_t ptr, size_t len) {
    for (const auto& mbi : g_pages) {
        auto start = (uintptr_t)mbi.BaseAddress;
        auto end = start + mbi.RegionSize;

        if (start <= ptr && ptr + len < end) {
            return mbi;
        }
    }

    return {};
}

bool memoryHasAccess(const MEMORY_BASIC_INFORMATION& mbi, DWORD protect) {
    // Pages are commited, not guarded or no access, and same protect.
    return (mbi.State & MEM_COMMIT && !(mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) && mbi.Protect & protect);
}

bool isGoodPtr(uintptr_t ptr, size_t len, uint32_t access) {
    // See if the address is in our cache.
    auto cachedMBI = findInCache(ptr, len);

    if (cachedMBI) {
        return memoryHasAccess(*cachedMBI, access);
    }

    MEMORY_BASIC_INFORMATION mbi{};

    if (VirtualQuery((LPCVOID)ptr, &mbi, sizeof(mbi)) == 0) {
        return false;
    }

    // Add it to our cache if its not there.
    if (!findInCache((uintptr_t)mbi.BaseAddress, 0)) {
        g_pages.push_back(mbi);
    }

    return memoryHasAccess(mbi, access);
}

bool isGoodReadPtr(uintptr_t ptr, size_t len) {
    // return isGoodPtr(ptr, len, PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ |
    // PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
    return IsBadReadPtr((const void*)ptr, len) == FALSE;
}

bool isGoodWritePtr(uintptr_t ptr, size_t len) {
    // return isGoodPtr(ptr, len, PAGE_READWRITE | PAGE_EXECUTE_READWRITE);
    return IsBadWritePtr((LPVOID)ptr, len) == FALSE;
}

bool isGoodCodePtr(uintptr_t ptr, size_t len) {
    // return isGoodPtr(ptr, len, PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE);
    return IsBadCodePtr((FARPROC)ptr) == FALSE;
}
} // namespace kanan
```

`src/kanan/core/Memory.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace kanan {
bool isGoodPtr(uintptr_t ptr, size_t len, uint32_t access);
bool isGoodReadPtr(uintptr_t ptr, size_t len);
bool isGoodWritePtr(uintptr_t ptr, size_t len);
bool isGoodCodePtr(uintptr_t ptr, size_t len);
} // namespace kanan

```

`src/kanan/core/Module.cpp`:

```cpp
#include "Module.hpp"
#include "String.hpp"

using namespace std;

namespace kanan {
optional<size_t> getModuleSize(const string& module) {
    return getModuleSize(GetModuleHandle(widen(module).c_str()));
}

optional<size_t> getModuleSize(HMODULE module) {
    if (module == nullptr) {
        return {};
    }

    // Get the dos header and verify that it seems valid.
    auto dosHeader = (PIMAGE_DOS_HEADER)module;

    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return {};
    }

    // Get the nt headers and verify that they seem valid.
    auto ntHeaders = (PIMAGE_NT_HEADERS)((uintptr_t)dosHeader + dosHeader->e_lfanew);

    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return {};
    }

    // OptionalHeader is not actually optional.
    return ntHeaders->OptionalHeader.SizeOfImage;
}

optional<uintptr_t> ptrFromRVA(uint8_t* dll, uintptr_t rva) {
    // Get the first section.
    auto dosHeader = (PIMAGE_DOS_HEADER)&dll[0];
    auto ntHeaders = (PIMAGE_NT_HEADERS)&dll[dosHeader->e_lfanew];
    auto section = IMAGE_FIRST_SECTION(ntHeaders);

    // Go through each section searching for where the rva lands.
    for (uint16_t i = 0; i < ntHeaders->FileHeader.NumberOfSections; ++i, ++section) {
        auto size = section->Misc.VirtualSize;

        if (size == 0) {
            size = section->SizeOfRawData;
        }

        if (rva >= section->VirtualAddress && rva < (section->VirtualAddress + size)) {
            auto delta = section->VirtualAddress - section->PointerToRawData;

            return (uintptr_t)(dll + (rva - delta));
        }
    }

    return {};
}
} // namespace kanan

```

`src/kanan/core/Module.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>

#include <Windows.h>

namespace kanan {
//
// Module utilities.
//
std::optional<size_t> getModuleSize(const std::string& module);
std::optional<size_t> getModuleSize(HMODULE module);

// Note: This function doesn't validate the dll's headers so make sure you've
// done so before calling it.
std::optional<uintptr_t> ptrFromRVA(uint8_t* dll, uintptr_t rva);
} // namespace kanan

```

`src/kanan/core/Patch.cpp`:

```cpp
#include <Windows.h>

#include "Patch.hpp"

using namespace std;

namespace kanan {
bool patch(uintptr_t address, const vector<int16_t>& bytes) {
    auto oldProtection = protect(address, bytes.size(), PAGE_EXECUTE_READWRITE);

    if (!oldProtection) {
        return false;
    }

    unsigned int count = 0;

    for (auto byte : bytes) {
        if (byte >= 0 && byte <= 0xFF) {
            *(uint8_t*)(address + count) = (uint8_t)byte;
        }

        ++count;
    }

    FlushInstructionCache(GetCurrentProcess(), (LPCVOID)address, bytes.size());
    protect(address, bytes.size(), *oldProtection);

    return true;
}

bool patch(Patch& p) {
    if (p.address == 0 || p.bytes.empty()) {
        return false;
    }

    // Backup the original bytes.
    if (p.originalBytes.empty()) {
        p.originalBytes.resize(p.bytes.size());

        unsigned int count = 0;

        for (auto& byte : p.originalBytes) {
            byte = *(uint8_t*)(p.address + count++);
        }
    }

    // Apply the patch.
    return patch(p.address, p.bytes);
}

bool undoPatch(const Patch& p) {
    if (p.address == 0 || p.originalBytes.empty()) {
        return false;
    }

    // Patch in the original bytes.
    return patch(p.address, p.originalBytes);
}

optional<DWORD> protect(uintptr_t address, size_t size, DWORD protection) {
    DWORD oldProtection{0};

    if (VirtualProtect((LPVOID)address, size, protection, &oldProtection) != FALSE) {
        return oldProtection;
    }

    return {};
}
} // namespace kanan

```

`src/kanan/core/Patch.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <vector>

#include <Windows.h>

namespace kanan {
struct Patch {
    uintptr_t address{0};
    std::vector<int16_t> bytes;
    std::vector<int16_t> originalBytes;
};

bool patch(uintptr_t address, const std::vector<int>& bytes);

bool patch(Patch& p);
bool undoPatch(const Patch& p);

// Returns the old protection on success.
// Note: you don't need to call this if you're using the above patch function.
std::optional<DWORD> protect(uintptr_t address, size_t size, DWORD protection);
} // namespace kanan

```

`src/kanan/core/Pattern.cpp`:

```cpp
#include <algorithm>

#include <Windows.h>

#include "Memory.hpp"
#include "Pattern.hpp"

using namespace std;

namespace kanan {
static uint8_t toByte(char digit) {
    if (digit >= '0' && digit <= '9') {
        return (digit - '0');
    }

    if (digit >= 'a' && digit <= 'f') {
        return (digit - 'a' + 10);
    }

    if (digit >= 'A' && digit <= 'F') {
        return (digit - 'A' + 10);
    }

    return 0;
}

Pattern::Pattern(const string& pattern) : m_pattern{} {
    m_pattern = move(buildPattern(pattern));
}

optional<uintptr_t> Pattern::find(uintptr_t start, size_t length, bool scanCodeOnly) {
    auto patternLength = m_pattern.size();
    auto end = start + length - patternLength;
    auto i = start;

    // Do we start at a readable address? If not, align to the next page.
    if (!isGoodPtr(i, patternLength, scanCodeOnly)) {
        i = ((i + 0x1000 - 1) / 0x1000) * 0x1000;
    }

    while (i <= end) {
        // If we're at the start of a new page, check to see if its a readable
        // address. If not, skip an entire page.
        if ((i % 0x1000) == 0 && !isGoodPtr(i, patternLength, scanCodeOnly)) {
            i += 0x1000;
            continue;
        }

        // If we're at the end of a page, check the next page to see if its
        // a readable one. If not, skip it.
        if (((i + patternLength - 1) % 0x1000) == 0) {
            auto pageToTest = ((i + 0x1000 - 1) / 0x1000) * 0x1000;

            if (!isGoodPtr(pageToTest, patternLength, scanCodeOnly)) {
                i = pageToTest + 0x1000;
                continue;
            }
        }

        // Test the pattern at this address.
        auto j = i;
        auto failedToMatch = false;

        for (auto& k : m_pattern) {
            if (k != -1 && k != *(uint8_t*)j) {
                failedToMatch = true;
                break;
            }

            ++j;
        }

        // If we didn't fail to match, then we found a match so return it.
        if (!failedToMatch) {
            return i;
        }

        // Otherwise, advance a byte.
        ++i;
    }

    // No match found.
    return nullopt;
}

bool Pattern::isGoodPtr(uintptr_t ptr, size_t len, bool codeOnly) {
    return codeOnly ? isGoodCodePtr(ptr, len) : isGoodReadPtr(ptr, len);
}

vector<int16_t> buildPattern(string patternStr) {
    // Remove spaces from the pattern string.
    patternStr.erase(remove_if(begin(patternStr), end(patternStr), isspace), end(patternStr));

    auto length = patternStr.length();
    vector<int16_t> pattern{};

    for (size_t i = 0; i < length;) {
        auto p1 = patternStr[i];

        if (p1 != '?') {
            // Bytes require 2 hex characters to encode, make sure we don't read
            // past the end of the pattern string attempting to read the next char.
            if (i + 1 >= length) {
                break;
            }

            auto p2 = patternStr[i + 1];
            auto value = toByte(p1) << 4 | toByte(p2);

            pattern.emplace_back(value);

            i += 2;
        } else {
            // Wildcard's (?'s) get encoded as a -1.
            pattern.emplace_back(-1);
            i += 1;
        }
    }

    return pattern;
}
} // namespace kanan

```

`src/kanan/core/Pattern.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

namespace kanan {
class Pattern {
public:
    Pattern() = delete;
    Pattern(const Pattern& other) = default;
    Pattern(Pattern&& other) = default;
    Pattern(const std::string& pattern);
    ~Pattern() = default;

    std::optional<uintptr_t> find(uintptr_t start, size_t length, bool scanCodeOnly = true);

    Pattern& operator=(const Pattern& other) = default;
    Pattern& operator=(Pattern&& other) = default;

private:
    std::vector<int16_t> m_pattern;

    bool isGoodPtr(uintptr_t ptr, size_t len, bool codeOnly);
};

// Converts a string pattern (eg. "90 90 ? EB ? ? ?") to a vector of int's where
// wildcards are -1.
std::vector<int16_t> buildPattern(std::string patternStr);
} // namespace kanan

```

`src/kanan/core/Scan.cpp`:

```cpp
#include "Scan.hpp"
#include "Module.hpp"
#include "Pattern.hpp"
#include "String.hpp"

using namespace std;

namespace kanan {
optional<uintptr_t> scan(const string& module, const string& pattern) {
    return scan(GetModuleHandle(widen(module).c_str()), pattern);
}

optional<uintptr_t> scan(const string& module, uintptr_t start, const string& pattern) {
    HMODULE mod = GetModuleHandle(widen(module).c_str());
    return scan(start, (getModuleSize(mod).value_or(0) - start + (uintptr_t)mod), pattern);
}

optional<uintptr_t> scan(HMODULE module, const string& pattern) {
    return scan((uintptr_t)module, getModuleSize(module).value_or(0), pattern);
}

optional<uintptr_t> scan(uintptr_t start, size_t length, const string& pattern) {
    if (start == 0 || length == 0) {
        return {};
    }

    Pattern p{pattern};

    return p.find(start, length);
}

std::optional<uintptr_t> scan(const std::string& pattern) {
    auto mod = GetModuleHandle(nullptr);
    auto size = getModuleSize(mod).value_or(0);
    return scan((uintptr_t)mod, size, pattern);
}
} // namespace kanan

```

`src/kanan/core/Scan.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>

#include <Windows.h>

namespace kanan {
std::optional<uintptr_t> scan(const std::string& module, const std::string& pattern);
std::optional<uintptr_t> scan(const std::string& module, uintptr_t start, const std::string& pattern);
std::optional<uintptr_t> scan(HMODULE module, const std::string& pattern);
std::optional<uintptr_t> scan(uintptr_t start, size_t length, const std::string& pattern);
std::optional<uintptr_t> scan(const std::string& pattern);
} // namespace kanan

```

`src/kanan/core/String.cpp`:

```cpp
#include <cstdarg>

#include <Windows.h>

#include "String.hpp"

using namespace std;

namespace kanan {
string narrow(wstring_view str) {
    auto length = WideCharToMultiByte(CP_UTF8, 0, str.data(), (int)str.length(), nullptr, 0, nullptr, nullptr);
    string narrowStr{};

    narrowStr.resize(length);
    WideCharToMultiByte(CP_UTF8, 0, str.data(), (int)str.length(), (LPSTR)narrowStr.c_str(), length, nullptr, nullptr);

    return narrowStr;
}

wstring widen(string_view str) {
    auto length = MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.length(), nullptr, 0);
    wstring wideStr{};

    wideStr.resize(length);
    MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.length(), (LPWSTR)wideStr.c_str(), length);

    return wideStr;
}

string formatString(const char* format, va_list args) {
    va_list argsCopy{};

    va_copy(argsCopy, args);

    auto len = vsnprintf(nullptr, 0, format, argsCopy);

    va_end(argsCopy);

    if (len <= 0) {
        return {};
    }

    string buffer{};

    buffer.resize(len + 1, 0);
    vsnprintf(buffer.data(), buffer.size(), format, args);
    buffer.resize(buffer.size() - 1); // Removes the extra 0 vsnprintf adds.

    return buffer;
}

std::vector<std::string> split(std::string str, const std::string& delim) {
    std::vector<std::string> pieces{};
    std::size_t last{};
    std::size_t next{};

    while ((next = str.find(delim, last)) != std::string::npos) {
        pieces.emplace_back(str.substr(last, next - last));
        last = next + delim.length();
    }

    return pieces;
}
} // namespace kanan

```

`src/kanan/core/String.hpp`:

```hpp
#pragma once

#include <string>
#include <string_view>
#include <vector>

namespace kanan {
//
// String utilities.
//

// Conversion functions for UTF8<->UTF16.
std::string narrow(std::wstring_view str);
std::wstring widen(std::string_view str);

std::string formatString(const char* format, va_list args);

std::vector<std::string> split(std::string str, const std::string& delim);

// FNV-1a
static constexpr auto hash(std::string_view data) {
    size_t result = 0xcbf29ce484222325;

    for (char c : data) {
        result ^= c;
        result *= (size_t)1099511628211;
    }

    return result;
}
} // namespace kanan

```

`src/kanan/core/Utility.cpp`:

```cpp
#include <Windows.h>

#include "Utility.hpp"

using namespace std;

namespace kanan {
bool isKeyDown(int key) {
    return (GetAsyncKeyState(key) & (1 << 15)) != 0;
}

bool wasKeyPressed(int key) {
    static bool keys[0xFF]{false};

    if (isKeyDown(key) && !keys[key]) {
        keys[key] = true;

        return true;
    }

    if (!isKeyDown(key)) {
        keys[key] = false;
    }

    return false;
}

string hexify(const uint8_t* data, size_t length) {
    constexpr char hexmap[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    string result{};

    result.resize(length * 2);

    for (size_t i = 0; i < length; ++i) {
        result[2 * i] = hexmap[(data[i] & 0xF0) >> 4];
        result[2 * i + 1] = hexmap[data[i] & 0x0F];
    }

    return result;
}

string hexify(const vector<uint8_t>& data) {
    return hexify(data.data(), data.size());
}
} // namespace kanan

```

`src/kanan/core/Utility.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

namespace kanan {
bool isKeyDown(int key);
bool wasKeyPressed(int key);

std::string hexify(const uint8_t* data, size_t length);
std::string hexify(const std::vector<uint8_t>& data);

// Given the address of a relative offset, calculate the absolute address.
constexpr uintptr_t rel_to_abs(uintptr_t address, int offset = 4) {
    auto rel = *(int*)(address);
    auto ip = address + offset;

    return ip + rel;
}
} // namespace kanan

```